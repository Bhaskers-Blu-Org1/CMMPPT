head	1.53;
access;
symbols;
locks; strict;
comment	@// @;


1.53
date	2004.11.19.23.35.47;	author fasano;	state Exp;
branches;
next	1.52;

1.52
date	2004.11.19.21.08.12;	author grzes;	state Exp;
branches;
next	1.51;

1.51
date	2004.11.19.19.31.29;	author grzes;	state Exp;
branches;
next	1.50;

1.50
date	2004.11.19.18.27.54;	author grzes;	state Exp;
branches;
next	1.49;

1.49
date	2004.11.19.14.24.17;	author fasano;	state Exp;
branches;
next	1.48;

1.48
date	2004.11.19.04.14.37;	author fasano;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.18.23.24.08;	author grzes;	state Exp;
branches;
next	1.46;

1.46
date	2004.11.18.22.55.25;	author grzes;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.18.22.38.05;	author grzes;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.16.15.54.58;	author grzes;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.15.22.48.18;	author grzes;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.15.22.07.56;	author grzes;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.15.19.52.42;	author grzes;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.15.16.50.23;	author fasano;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.15.16.39.16;	author grzes;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.15.15.17.00;	author grzes;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.12.23.24.56;	author grzes;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.12.18.33.24;	author grzes;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.11.19.20.36;	author fasano;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.10.16.53.23;	author fasano;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.10.15.34.08;	author grzes;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.10.14.50.14;	author fasano;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.10.04.11.31;	author fasano;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.09.18.29.44;	author fasano;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.09.05.12.12;	author fasano;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.06.23.51.19;	author fasano;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.06.17.29.17;	author fasano;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.06.15.46.52;	author fasano;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.06.14.05.57;	author fasano;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.06.13.23.23;	author fasano;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.03.14.10.13;	author fasano;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.03.14.02.43;	author grzes;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.03.12.49.12;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.02.22.39.20;	author grzes;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.02.16.52.57;	author grzes;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.02.03.29.43;	author fasano;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.01.23.34.12;	author grzes;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.01.19.27.15;	author fasano;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.31.19.38.07;	author fasano;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.31.13.59.17;	author fasano;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.31.00.00.51;	author fasano;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.30.23.08.23;	author fasano;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.30.20.22.38;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.30.16.19.57;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.30.15.40.20;	author fasano;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.30.12.15.44;	author fasano;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.30.04.25.05;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.29.23.19.12;	author grzes;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.29.18.44.17;	author grzes;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.29.12.37.41;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.29.02.59.35;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.29.01.42.16;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.28.19.24.05;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.53
log
@added method getEccObjValueByPeriod
@
text
@#if defined(_MSC_VER)
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#pragma warning(disable:4290)
#endif

#include <numeric>
#include <set>
#include <algorithm>
#include <climits>

#include <cassert>
#include <iostream>
#include <sstream>
#include <cfloat>
#include <cstdio>
#include <climits>

#include "CoinFinite.h"
#include "CoinFloatEqual.h"
#include "ovptProblem.h"
#include "populateOvpt.h"


//----------------------
// Methods for materials.
//----------------------
void ECCovptProblem::addMaterial(const std::string & materialName)
{
  witAddPart(witRun(),materialName.c_str(),WitCAPACITY); 
  materialNames_.insert(materialName);
}

bool ECCovptProblem::materialExists(const std::string & materialName)const
{
  bool retVal = false;

  std::set<std::string>::const_iterator it = materialNames_.find(materialName);
  if ( it != materialNames_.end() ) retVal = true;

  return retVal;
}

void ECCovptProblem::setMaterialSupply(const std::string & materialName, 
                                      int period,
                                      float supply)
{
  wwitSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,materialName,period,supply);
}

std::vector<float> ECCovptProblem::getMaterialSupply(const std::string & materialName ) const
{
  return wwitGetNameAttribute(witGetPartSupplyVol,materialName);
}

void ECCovptProblem::getMaterialNames( std::vector<std::string> & materialNames ) const
{
  materialNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=materialNames_.begin(); it!=materialNames_.end(); ++it ) {
    materialNames.push_back( *it );
  }
}


std::vector<float> ECCovptProblem::getMaterialConsumptionVolume(const std::string & materialName )const
{
  return getResourceConsumptionVolume(materialName);
}
std::vector<float> ECCovptProblem::getMaterialProductionVolume(const std::string & materialName )const
{
  return getResourceProductionVolume(materialName);
}
std::vector<float> ECCovptProblem::getMaterialScrapVolume(const std::string & materialName )const
{
  return getResourceScrapVolume(materialName);
}
std::vector<float> ECCovptProblem::getResourceConsumptionVolume(const std::string & materialName )const
{
  return wwitGetNameAttribute(witGetPartConsVol,materialName);
}
std::vector<float> ECCovptProblem::getResourceProductionVolume(const std::string & materialName )const
{
  return wwitGetNameAttribute(witGetPartProdVol,materialName);
}
std::vector<float> ECCovptProblem::getResourceScrapVolume(const std::string & materialName )const
{
  return wwitGetNameAttribute(witGetPartScrapVol,materialName);
}

std::vector<float> ECCovptProblem::getResourceExcessVolume(const std::string & materialName )const
{
  return wwitGetNameAttribute(witGetPartExcessVol,materialName);
}

  //----------------------
  // Methods for capacities.
  //----------------------
  
void ECCovptProblem::addCapacity(const std::string & capacityName)
{
  witAddPart(witRun(),capacityName.c_str(),WitCAPACITY); 
  capacityNames_.insert(capacityName);
}

bool ECCovptProblem::capacityExists(const std::string & capacityName)const
{
  bool retVal = false;

  std::set<std::string>::const_iterator it = capacityNames_.find(capacityName);
  if ( it != capacityNames_.end() ) retVal = true;

  return retVal;
}

void ECCovptProblem::setCapacitySupply(const std::string & capacityName, int period, float supply )
{
  wwitSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,capacityName,period,supply);
}

std::vector<float> ECCovptProblem::getCapacitySupply(const std::string & capacityName )const
{
  return wwitGetNameAttribute(witGetPartSupplyVol,capacityName);
}

  
void ECCovptProblem::getCapacityNames( std::vector<std::string> & capacityNames )const
 {
  capacityNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=capacityNames_.begin(); it!=capacityNames_.end(); ++it ) {
    capacityNames.push_back( *it );
  }
}

std::vector<float> ECCovptProblem::getCapacityConsumptionVolume(const std::string & capacityName )const
{
  return getResourceConsumptionVolume(capacityName);
}

std::vector<float> ECCovptProblem::getCapacityExcessVolume(const std::string & capacityName )const
{
  return getResourceExcessVolume(capacityName);
}

//----------------------
// Methods for operations.
//----------------------
void ECCovptProblem::addOperation(const std::string & operationName)
{
  witAddOperation(witRun(),operationName.c_str()); 
  operationNames_.insert(operationName);
}

void ECCovptProblem::setOperationContribution(const std::string &operationName, int period, float contrib )
{
  wwitSetNameAttribute(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,operationName,period,-contrib);
}

std::vector<float> ECCovptProblem::getOperationContribution(const std::string & operationName )const
{
  std::vector<float> retVal = wwitGetNameAttribute(witGetOperationObj1ExecCost, operationName );
  for (int t=0; t<retVal.size(); ++t ) {
    retVal[t]=-retVal[t];
  }
  return retVal;
}

void ECCovptProblem::setOperationMinimumProduction(const std::string &operationName, int period, float mp )
{
  std::vector<float> hlb;
  std::vector<float> slb;
  std::vector<float> hub;
  wwitGetNameBoundAttribute(witGetOperationExecBounds,operationName,hlb,slb,hub);
  slb[period] = mp;
  wwitSetNameBoundAttribute(witSetOperationExecBounds,operationName, hlb,slb,hub);
}
std::vector<float> ECCovptProblem::getOperationMinimumProduction(const std::string & operationName )const
{
  std::vector<float> hlb;
  std::vector<float> slb;
  std::vector<float> hub;
  wwitGetNameBoundAttribute(witGetOperationExecBounds,operationName, hlb,slb,hub);
  return slb;
}

void ECCovptProblem::getOperationNames( std::vector<std::string> & operationNames )const
{
  operationNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=operationNames_.begin(); it!=operationNames_.end(); ++it ) {
    operationNames.push_back( *it );
  }
}

bool ECCovptProblem::operationExists    (const std::string & operationName)const
{
  bool retVal = false;

  std::set<std::string>::const_iterator it = operationNames_.find(operationName);
  if ( it != operationNames_.end() ) retVal = true;

  return retVal;
}
  
std::vector<float> ECCovptProblem::getOperationExecutionVolume(const std::string & operationName )const
{
  return wwitGetNameAttribute(witGetOperationExecVol, operationName );
}
//----------------------
// Methods for demands.
//----------------------
  
// To specify a demand we need to use BOTH the demandName (e.g. US) AND the material (e.g. Kingsport Tow)

void ECCovptProblem::addDemand(const std::string & material, const std::string & demandName)
{
  assert( materialExists(material) );
  std::string fullDemandName = materialDemandName(material,demandName);

  // create a part that will be connected to the demand
  witAddPart(witRun(),fullDemandName.c_str(),WitCAPACITY);

  // connect demand to just created part.
  witAddDemand(witRun(),fullDemandName.c_str(),demandName.c_str()); 

  // create operation and have it produce the just created part.
  // This operation is where the minShipVol will be specified as soft lower bound on execution volume.
  witAddOperation(witRun(),fullDemandName.c_str()); 
  witAddBopEntry(witRun(),fullDemandName.c_str(),fullDemandName.c_str()); 

  // now connect material with bom to just created operation
  witAddBomEntry(witRun(),fullDemandName.c_str(),material.c_str()); 

  // create a capacity and connect it to operation with a bop.
  // this capacity is used to ensure that unmet demand is not shipped late
  std::string demRegulatorName = demandRegulatorName(material,demandName);
  witAddPart(witRun(),demRegulatorName.c_str(),WitCAPACITY);
  witAddBomEntry(witRun(),fullDemandName.c_str(),demRegulatorName.c_str()); 

  materialDemandNames_.insert(fullDemandName);
}

bool ECCovptProblem::demandExists(const std::string & material, const std::string & demandName)const
{
  bool retVal = false;
  std::string fullDemandName = materialDemandName(material,demandName);

  std::set<std::string>::const_iterator it = materialDemandNames_.find(fullDemandName);
  if ( it != materialDemandNames_.end() ) retVal = true;

  return retVal;
}

void ECCovptProblem::setDemandDemandVol(const std::string & material, const std::string & demandName, int period, float demVol )
{
  std::string fullDemandName = materialDemandName(material,demandName);
  std::string demRegulatorName = demandRegulatorName(material,demandName);
  wwitSetDemandAttribute(witGetDemandDemandVol,witSetDemandDemandVol,fullDemandName,demandName,period,demVol);
  wwitSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,demRegulatorName,period,demVol);
}

std::vector<float> ECCovptProblem::getDemandDemandVol(const std::string & material, const std::string & demandName)const
{
  std::string fullDemandName = materialDemandName(material,demandName);
  return wwitGetDemandAttribute(witGetDemandDemandVol,fullDemandName,demandName);
}

void ECCovptProblem::setDemandContribution(const std::string & material, const std::string & demandName, int period, float contribution )
{
  std::string fullDemandName = materialDemandName(material,demandName);
  wwitSetDemandAttribute(witGetDemandObj1ShipReward,witSetDemandObj1ShipReward,fullDemandName,demandName,period,contribution);
}

std::vector<float> ECCovptProblem::getDemandContribution(const std::string & material, const std::string & demandName)const
{
  std::string fullDemandName = materialDemandName(material,demandName);
  return wwitGetDemandAttribute(witGetDemandObj1ShipReward,fullDemandName,demandName);
}


void ECCovptProblem::setDemandMinShipVol(const std::string & demandedMaterial, const std::string & demandName, int period, float minShipVol )
{
  std::string fullDemandName = materialDemandName(demandedMaterial,demandName);
  std::vector<float> hlb;
  std::vector<float> slb;
  std::vector<float> hub;
  wwitGetNameBoundAttribute(witGetOperationExecBounds,fullDemandName,hlb,slb,hub);
  slb[period] = minShipVol;
  wwitSetNameBoundAttribute(witSetOperationExecBounds,fullDemandName, hlb,slb,hub);
}
std::vector<float> ECCovptProblem::getDemandMinShipVol(const std::string & demandedMaterial, const std::string & demandName)const
{
  std::string fullDemandName = materialDemandName(demandedMaterial,demandName);
  std::vector<float> hlb;
  std::vector<float> slb;
  std::vector<float> hub;
  wwitGetNameBoundAttribute(witGetOperationExecBounds,fullDemandName, hlb,slb,hub);
  return slb;
}


void ECCovptProblem::getDemandNames( std::vector<std::string> & materialNames, std::vector<std::string> & demandNames )const
{
  materialNames.clear();
  demandNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=materialDemandNames_.begin(); it!=materialDemandNames_.end(); ++it ) {
    materialNames.push_back( materialFromMaterialDemandName(*it) );
    demandNames.push_back( demandFromMaterialDemandName(*it) );
  }
}

std::vector<float> ECCovptProblem::getDemandShipVol(const std::string & material, const std::string & demandName)const
{
  std::string fullDemandName = materialDemandName(material,demandName);
  return wwitGetDemandAttribute(witGetDemandShipVol,fullDemandName,demandName);
}
  
//----------------------
// Methods for consumption arcs.
//----------------------

void ECCovptProblem::addConsumptionArc(const std::string & operationName, const std::string & consumedResourceName )
{
  assert(operationExists(operationName));
  assert(wwitPartExists(consumedResourceName));

  // make sure arc does not already exist.
  // adding it again will foul up the code that determines a BOM Entry Index
  assert(!consumptionArcExists(operationName,consumedResourceName));

  // Get bom entry index of bom which is being added
  int nBomEntries;
  witGetOperationNBomEntries(witRun(),operationName.c_str(),&nBomEntries);

  // add the bom
  witAddBomEntry(witRun(),operationName.c_str(),consumedResourceName.c_str());

  // Set Bom Entry cons rate to 0.
  std::vector<float> zeroTv = floatToStlVec(0.f);
  wwitSetArcAttribute(witSetBomEntryConsRate,operationName,nBomEntries,zeroTv);

  std::string consArcName = consumptionArcName(operationName,consumedResourceName);
  consumptionArcNames_.insert(consArcName);
}


void ECCovptProblem::setConsumptionArcConsumptionRate(
                                                      const std::string & operationName, 
                                                      const std::string & consumedResourceName, 
                                                      int period, 
                                                      float consumptionRate )
{
  assert(consumptionArcExists(operationName,consumedResourceName));
  int bei = getBomEntryIndex(operationName,consumedResourceName);
  wwitSetArcAttribute(witGetBomEntryConsRate,witSetBomEntryConsRate,operationName,bei,period,consumptionRate);
}


std::vector<float> ECCovptProblem::getConsumptionArcConsumptionRate(const std::string & operationName, const std::string & consumedResourceName)
{
  assert(consumptionArcExists(operationName,consumedResourceName));
  int bei = getBomEntryIndex(operationName,consumedResourceName);
  return wwitGetArcAttribute(witGetBomEntryConsRate,operationName,bei);
}

void ECCovptProblem::getConsumptionArcNames( std::vector<std::string> & operationNames, std::vector<std::string> & consumedResourceNames )const
{
  operationNames.clear();
  consumedResourceNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=consumptionArcNames_.begin(); it!=consumptionArcNames_.end(); ++it ) {
    operationNames.push_back( operationFromConsumptionArcName(*it) );
    consumedResourceNames.push_back( consumedResourceFromConsumptionArcName(*it) );
  }
}


bool ECCovptProblem::consumptionArcExists(const std::string & operationName, const std::string & consumedResourceName)const
{
  bool retVal = false;

  std::string consArcName = consumptionArcName(operationName,consumedResourceName);
  std::set<std::string>::const_iterator it = consumptionArcNames_.find(consArcName);
  if ( it != consumptionArcNames_.end() ) retVal = true;

  return retVal;
}


//----------------------
// Methods for substitution arcs.
//----------------------

void ECCovptProblem::addSubstitutionArc(const std::string & operationName, 
										const std::string & consumedResourceName, 
										const std::string & substituteConsumedResourceName)
{
  assert(operationExists(operationName));
  assert(wwitPartExists(consumedResourceName));
  assert(wwitPartExists(substituteConsumedResourceName));

  // make sure arc does not already exist.
  // adding it again will foul up the code that determines a BOM Entry Index
  assert(!substitutionArcExists(operationName,consumedResourceName, substituteConsumedResourceName));

  //Get bom entry index of bom for wchich we create a substitute
  int bomEntryIndex = getBomEntryIndex(operationName,consumedResourceName);
  assert(bomEntryIndex>=0);

  // Get bom entry index of bom which is being added
  int nSubsBomEntries;
  witGetBomEntryNSubsBomEntries(witRun(),operationName.c_str(),bomEntryIndex,&nSubsBomEntries);

  // add the substitute bom
  witAddSubsBomEntry(witRun(),operationName.c_str(),bomEntryIndex, substituteConsumedResourceName.c_str());
  
  // Set substitute Bom Entry cons rate to 0.
  std::vector<float> zeroTv = floatToStlVec(0.f);
  wwitSetSubArcAttribute(witSetSubsBomEntryConsRate,operationName,bomEntryIndex,nSubsBomEntries,zeroTv);

  std::string consArcName = substitutionArcName(operationName,consumedResourceName,substituteConsumedResourceName);
  substitutionArcNames_.insert(consArcName);
}

void ECCovptProblem::setSubstitutionArcConsumptionRate(
                                                       const std::string & operationName, 
                                                       const std::string & consumedResourceName,
                                                       const std::string & substituteConsumedResourceName,
                                                       int period, 
                                                       float consumptionRate )
{
  assert(substitutionArcExists(operationName,consumedResourceName,substituteConsumedResourceName));
  int bei = getBomEntryIndex(operationName,consumedResourceName);
  int sbei = getSubBomEntryIndex(operationName,consumedResourceName,substituteConsumedResourceName);
  wwitSetSubArcAttribute(witGetSubsBomEntryConsRate,witSetSubsBomEntryConsRate,operationName,bei,sbei,period,consumptionRate);
}


std::vector<float> ECCovptProblem::getSubstitutionArcConsumptionRate(const std::string & operationName, 
																	 const std::string & consumedResourceName,
																	 const std::string & substituteConsumedResourceName)
{
  assert(substitutionArcExists(operationName,consumedResourceName,substituteConsumedResourceName));
  int bei = getBomEntryIndex(operationName,consumedResourceName);
  int sbei = getSubBomEntryIndex(operationName,consumedResourceName,substituteConsumedResourceName);
  return wwitGetSubArcAttribute(witGetSubsBomEntryConsRate,operationName,bei,sbei);
}

void ECCovptProblem::getSubstitutionArcNames( std::vector<std::string> & operationNames, 
                                         	  std::vector<std::string> & consumedResourceNames, 
											  std::vector<std::string> & substituteConsumedResourceNames )const
{
  operationNames.clear();
  consumedResourceNames.clear();
  substituteConsumedResourceNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=substitutionArcNames_.begin(); it!=substitutionArcNames_.end(); ++it ) {
    operationNames.push_back( operationFromSubstitutionArcName(*it) );
    consumedResourceNames.push_back( consumedResourceFromSubstitutionArcName(*it) );
	substituteConsumedResourceNames.push_back( substituteConsumedResourceFromSubstitutionArcName(*it) );
  }
}


bool ECCovptProblem::substitutionArcExists(const std::string & operationName, 
										   const std::string & consumedResourceName, 
										   const std::string & substituteConsumedResourceName)const
{
  bool retVal = false;

  std::string subsArcName = substitutionArcName(operationName,consumedResourceName,substituteConsumedResourceName);
  std::set<std::string>::const_iterator it = substitutionArcNames_.find(subsArcName);
  if ( it != substitutionArcNames_.end() ) retVal = true;

  return retVal;
}

//----------------------
// Methods for production arcs.
//----------------------

void ECCovptProblem::addProductionArc(const std::string & operationName, const std::string & producedResourceName )
{
  assert(operationExists(operationName));
  assert(wwitPartExists(producedResourceName));

  // make sure arc does not already exist.
  // adding it again will foul up the code that determines a BOM Entry Index
  assert(!productionArcExists(operationName,producedResourceName));

  // Get bom entry index of bom which is being added
  int nBopEntries;
  witGetOperationNBopEntries(witRun(),operationName.c_str(),&nBopEntries);

  // add the bom
  witAddBopEntry(witRun(),operationName.c_str(),producedResourceName.c_str());

  // Set Bop Entry production rate to 0.
  std::vector<float> zeroTv = floatToStlVec(0.f);
  wwitSetArcAttribute(witSetBopEntryProductRate,operationName,nBopEntries,zeroTv);

  // Since model can have loops, need to set explode allowed to false
  witSetBopEntryExpAllowed(witRun(),operationName.c_str(),nBopEntries,WitFALSE);

  std::string arcName = productionArcName(operationName,producedResourceName);
  productionArcNames_.insert(arcName);
}


void ECCovptProblem::setProductionArcProductionRate(const std::string & operationName, const std::string & producedResourceName, int period, float productionRate )
{
  assert(productionArcExists(operationName,producedResourceName));
  int bei = getBopEntryIndex(operationName,producedResourceName);
  wwitSetArcAttribute(witGetBopEntryProductRate,witSetBopEntryProductRate,operationName,bei,period,productionRate);
}
std::vector<float> ECCovptProblem::getProductionArcProductionRate(const std::string & operationName, const std::string & producedResourceName)
{
  assert(productionArcExists(operationName,producedResourceName));
  int bei = getBopEntryIndex(operationName,producedResourceName);
  return wwitGetArcAttribute(witGetBopEntryProductRate,operationName,bei);
}


void ECCovptProblem::getProductionArcNames( std::vector<std::string> & operationNames, std::vector<std::string> & producedResourceNames )const
{
  operationNames.clear();
  producedResourceNames.clear();
  
  std::set<std::string>::const_iterator it;
  for ( it=productionArcNames_.begin(); it!=productionArcNames_.end(); ++it ) {
    operationNames.push_back( operationFromProductionArcName(*it) );
    producedResourceNames.push_back( producedResourceFromProductionArcName(*it) );
  }
}

bool ECCovptProblem::productionArcExists    (const std::string & operationName, const std::string & producedResourceName)const
{
  bool retVal = false;

  std::string consArcName = productionArcName(operationName,producedResourceName);
  std::set<std::string>::const_iterator it = productionArcNames_.find(consArcName);
  if ( it != productionArcNames_.end() ) retVal = true;

  return retVal;
}
  
  // methods for checking if WIT model makes sense (no disconnected operations or resources)
  void ECCovptProblem::getMaterialOrphanNames( std::vector<std::string> & materialOrphanNames )const
  {
	  materialOrphanNames.clear();
	  std::vector<std::string> materialNames;
	  std::vector<std::string> operationNames;
	  getMaterialNames(materialNames);
	  getOperationNames(operationNames);

	  int i, j;
	  bool found;
	  for (i=0; i<materialNames.size(); i++)
	  {
		  found=false;
		  for (j=0; j<operationNames.size(); j++)
		  {
			  found = (found || consumptionArcExists(operationNames[j], materialNames[i]) || productionArcExists(operationNames[j], materialNames[i]) );
		  }
		  if (!found) materialOrphanNames.push_back(materialNames[i]);
	  }

  }
  
  void ECCovptProblem::getCapacityOrphanNames( std::vector<std::string> & capacityOrphanNames )const
  {
	  capacityOrphanNames.clear();
	  std::vector<std::string> capacityNames;
	  std::vector<std::string> operationNames;
	  getCapacityNames(capacityNames);
	  getOperationNames(operationNames);

	  int i, j;
	  bool found;
	  for (i=0; i<capacityNames.size(); i++)
	  {
		  found=false;
		  for (j=0; j<operationNames.size(); j++)
		  {
			  found = (found || consumptionArcExists(operationNames[j], capacityNames[i]));
		  }
		  if (!found) capacityOrphanNames.push_back(capacityNames[i]);
	  }
  }
  // Operation is an orphan if:
  //1. It does not consume any material OR
  //2. Does not produce any material

  void ECCovptProblem::getOperationOrphanNames( std::vector<std::string> & operationOrphanNames )const
  {
	  operationOrphanNames.clear();
	  std::vector<std::string> materialNames;
	  std::vector<std::string> resourceNames;
	  std::vector<std::string> operationNames;
	  getMaterialNames(materialNames);
	  getCapacityNames(resourceNames);
	  getOperationNames(operationNames);

	  int i, j;
	  for (i=0; i<materialNames.size(); i++){
		  resourceNames.push_back(materialNames[i]);}

	  bool foundC, foundP;
	  for (i=0; i<operationNames.size(); i++)
	  {
		  foundC=false;
		  for (j=0; j<resourceNames.size(); j++)
		  {
			  foundC = (foundC || consumptionArcExists(operationNames[i], resourceNames[j]) );
		  }
		  foundP=false;
		  for (j=0; j<materialNames.size(); j++)
		  {
			  foundP = (foundP || productionArcExists(operationNames[i], materialNames[j]) );
		  }
		  if (!foundC || !foundP) operationOrphanNames.push_back(operationNames[i]);
	  }
  }
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
// Demand Name Methods
//-------------------------------------------------------------------------
std::string ECCovptProblem::materialDemandName(const std::string & material, const std::string demand )
{
  return "Demand: "+demand+". for: "+material;
}
std::string ECCovptProblem::demandFromMaterialDemandName(const std::string & materialDemandName )
{
  return textBetween(materialDemandName,"Demand: ",". for: ");
}
std::string ECCovptProblem::materialFromMaterialDemandName(const std::string & materialDemandName )
{
  return textAfter(materialDemandName,". for: ");
}

std::string ECCovptProblem::demandRegulatorName(const std::string & material, const std::string demand )
{
  return "DemandRegulator: "+demand+". for: "+material;
}


//-------------------------------------------------------------------------
// Consumption Arc Name Methods
//-------------------------------------------------------------------------
std::string ECCovptProblem::consumptionArcName(const std::string & operation, const std::string consumedResource )
{
  return "Operation: "+operation+" consumes resource: "+consumedResource;
}
std::string ECCovptProblem::operationFromConsumptionArcName(const std::string & consumptionArcName )
{
  return textBetween(consumptionArcName,"Operation: "," consumes resource: ");
}
std::string ECCovptProblem::consumedResourceFromConsumptionArcName(const std::string & consumptionArcName )
{
  return textAfter(consumptionArcName," consumes resource: ");
}

//-------------------------------------------------------------------------
// Substitution Arc Name Methods
//-------------------------------------------------------------------------
std::string ECCovptProblem::substitutionArcName(const std::string & operation, 
												const std::string consumedResource, 
												const std::string substituteConsumedResource )
{
	return "Operation: "+operation+" consumes resource: "+consumedResource+" with a substitute: "+substituteConsumedResource ;
}
std::string ECCovptProblem::operationFromSubstitutionArcName(const std::string & substitutionArcName )
{
  return textBetween(substitutionArcName,"Operation: "," consumes resource: ");
}
std::string ECCovptProblem::consumedResourceFromSubstitutionArcName(const std::string & substitutionArcName )
{
  return textBetween(substitutionArcName," consumes resource: "," with a substitute: ");
}
std::string ECCovptProblem::substituteConsumedResourceFromSubstitutionArcName(const std::string & substitutionArcName )
{
  return textAfter(substitutionArcName," with a substitute: ");
}

//-------------------------------------------------------------------------
// Production Arc Name Methods
//-------------------------------------------------------------------------
std::string ECCovptProblem::productionArcName(const std::string & operation, const std::string producedResource )
{
  return "Operation: "+operation+" produces resource: "+producedResource;
}
std::string ECCovptProblem::operationFromProductionArcName(const std::string & productionArcName )
{
  return textBetween(productionArcName,"Operation: "," produces resource: ");
}
std::string ECCovptProblem::producedResourceFromProductionArcName(const std::string & productionArcName )
{
  return textAfter(productionArcName," produces resource: ");
}
//--------------------------------------------------------


std::string ECCovptProblem::modelReport() const
{
  std::ostringstream msgStream;
  
  // get all model objects
  std::vector<std::string> capacities, materials, operations;
  getCapacityNames(capacities);
  getMaterialNames(materials);
  getOperationNames(operations);

  std::vector<std::string> subsOperations, subsPrimaryMaterials, subsMaterials;
  getSubstitutionArcNames( subsOperations, subsPrimaryMaterials, subsMaterials );

  std::vector<std::string> demMaterials, demands;
  getDemandNames( demMaterials, demands );

  // create map from substitute Material to consArcs and
  // another map from consArcs to substitute materials
  typedef std::pair<std::string,std::string> ECCarc;
  typedef std::vector<ECCarc> ECCvectorArc;
  std::map<std::string, ECCvectorArc > subMaterialToConsArcMap;
  std::map<ECCarc, std::vector<std::string> > consArcToSubMaterialMap;
  int s;
  for ( s=0; s<subsMaterials.size(); ++s ) {
    ECCarc bomArc(subsOperations[s], subsPrimaryMaterials[s]);
    subMaterialToConsArcMap[subsMaterials[s]].push_back(bomArc);
    consArcToSubMaterialMap[bomArc].push_back(subsMaterials[s]);
  }

  
  // create map from material to demands and
  // another map from demands to materials
  typedef std::pair<std::string,std::string> ECCarc;
  typedef std::vector<ECCarc> ECCvectorArc;
  std::map<std::string, std::vector<std::string> > materialToDemandMap;
  std::map<std::string, std::vector<std::string> > demandToMaterialMap;
  int d;
  for ( d=0; d<demMaterials.size(); ++d ) {
    materialToDemandMap[demMaterials[d]].push_back(demands[d]);
    demandToMaterialMap[demands[d]].push_back(demMaterials[d]);
  }

  
  // report on capacities
  msgStream <<std::endl <<"Capacities:" <<std::endl;
  int c;
  for ( c=0; c<capacities.size(); ++c ) {
    msgStream <<"  " <<c+1 <<".  " <<capacities[c] <<std::endl;
    std::vector<std::string> consOps = getPartConsumingOperations(capacities[c]);
    msgStream <<"        Consuming operations: " <<std::endl;
    int count = 0;
    int o;
    for ( o=0; o<consOps.size(); ++o ) {
      count++;
      msgStream <<"          " <<count <<".  " <<consOps[o] <<std::endl;
    }
    if ( count==0 ) 
      msgStream <<"          **none**" <<std::endl;
  }

  // report on materials
  int m;
  msgStream <<std::endl <<"Materials:" <<std::endl;
  for ( m=0; m<materials.size(); ++m ) {
    msgStream <<"  " <<m+1 <<".  " <<materials[m] <<std::endl;

    // consuming operations
    std::vector<std::string> consOps = getPartConsumingOperations(materials[m]);
    msgStream <<"        Consuming operations: " <<std::endl;
    int count = 0;
    int o;
    for ( o=0; o<consOps.size(); ++o ) {
      // make sure this is not a wit modeling trick operation
      if ( !operationExists(consOps[o]) ) continue;
      count++;
      msgStream <<"          " <<count <<".  " <<consOps[o] <<std::endl;
    }
    if ( count==0 ) 
      msgStream <<"          **none**" <<std::endl;


    // operations consuming as substitute
    {
      ECCvectorArc consBoms = subMaterialToConsArcMap[materials[m]];
      if ( consBoms.size()!=0 ) {
        msgStream <<"        Consuming operations as substitute: " <<std::endl;
        int count = 0;
        int o;
        for ( o=0; o<consBoms.size(); ++o ) {
          count++;
          msgStream <<"          " <<count <<".  " <<consBoms[o].first <<" as substitute for material " <<consBoms[o].second <<std::endl;
        }
      }
    }
    
    // producing operations
    std::vector<std::string> prodOps = getPartProducingOperations(materials[m]);
    msgStream <<"        Producing operations: " <<std::endl;
    count = 0;
    for ( o=0; o<prodOps.size(); ++o ) {
      // make sure this is not a wit modeling trick operation
      if ( !operationExists(prodOps[o]) ) continue;
      count++;
      msgStream <<"          " <<count <<".  " <<prodOps[o] <<std::endl;
    }
    if ( count==0 ) 
      msgStream <<"          **none**" <<std::endl;

    // demands on material
    {
      std::vector<std::string> dems = materialToDemandMap[materials[m]];
      if ( dems.size()>0 ) {
        msgStream <<"        Demands: " <<std::endl;
        int d;
        for ( d=0; d<dems.size(); ++d ) {
          msgStream <<"          " <<d+1 <<".  " <<dems[d] <<std::endl;
        }
      }
    }
  }

  // report on operations
  msgStream <<std::endl <<"Operations:" <<std::endl;
  int o;
  for ( o=0; o<operations.size(); ++o ) {
    
    msgStream <<"  " <<o+1 <<".  " <<operations[o] <<std::endl;

    std::vector<std::string> consRes = getOperationConsumedParts(operations[o]);
    msgStream <<"        Consumed capacities: " <<std::endl;
    int count = 0;
    int r;
    for ( r=0; r<consRes.size(); ++r ) {
      // make sure resource is a capacity
      if ( !capacityExists(consRes[r]) ) continue;
      count++;
      msgStream <<"          " <<count <<".  " <<consRes[r] <<std::endl;
    }
    if ( count==0 ) 
      msgStream <<"          **none**" <<std::endl;

    msgStream <<"        Consumed materials: " <<std::endl;
    count = 0;
    for ( r=0; r<consRes.size(); ++r ) {
      // make sure resource is a capacity
      if ( !materialExists(consRes[r]) ) continue;
      count++;
      msgStream <<"          " <<count <<".  " <<consRes[r] <<std::endl;

      // Report on consumption of substitutes by bom arc (operations[o],consRes[r]);
      {
        ECCarc bomArc(operations[o],consRes[r]);
        std::vector<std::string> subsMaterials = consArcToSubMaterialMap[bomArc];
        if ( subsMaterials.size()>0 ) {
          msgStream <<"          Consumed substitute materials: " <<std::endl;
          int s;
          for ( s=0; s<subsMaterials.size(); ++s ) {
            msgStream <<"            " <<s+1 <<".  " <<subsMaterials[s] <<std::endl;
          }
        }
      }
    }
    if ( count==0 ) 
      msgStream <<"          **none**" <<std::endl;

    std::vector<std::string> prodRes = getOperationProducedParts(operations[o]);
    msgStream <<"        Produced materials: " <<std::endl;
    count = 0;
    for ( r=0; r<prodRes.size(); ++r ) {
      // make sure resource is a capacity
      if ( !materialExists(prodRes[r]) ) continue;
      count++;
      msgStream <<"          " <<count <<".  " <<prodRes[r] <<std::endl;
    }
    if ( count==0 ) 
      msgStream <<"          **none**" <<std::endl;

  }

  
  // report on demands
  {
    msgStream <<std::endl <<"Demands:" <<std::endl;
    std::map<std::string, std::vector<std::string> >::iterator it;
    int demCount=0;
    for ( it = demandToMaterialMap.begin(); it!=demandToMaterialMap.end(); ++it ) {
      demCount++;
      msgStream <<"  " <<demCount <<".  " <<it->first <<std::endl;
      const std::vector<std::string> & demMats = it->second;
      int m=0;
      for ( m=0; m<demMats.size(); ++m ) {
        msgStream <<"          " <<m+1 <<".  " <<demMats[m] <<std::endl;
      }
    }
  }

  msgStream <<std::endl;
  return msgStream.str();
}

//-----------------------------
// Presolve. Complete the WIT model
// 1. Set substitute arc consumption rates to consumption rate of it bom
// 2. Set obj1ScrapCost to zero for all parts (They might not be zero, if multiple solves are performed
//    on same problem.  This is done in the testing).
//-----------------------------
void ECCovptProblem::presolve()
{
  // get the list of all operations and a list of all parts and a list of all subsArcs
  std::vector<std::string>  operationNames;
  std::vector<std::string>  consumedResourceNames; 
  std::vector<std::string>  substituteConsumedResourceNames;
  
  getSubstitutionArcNames(operationNames, consumedResourceNames, substituteConsumedResourceNames );
  int nSubsArcs =  substituteConsumedResourceNames.size();
  
  int nPeriods = getNPeriods();
  
  //Copy all consRates from bomArcs to subsBomArcs
  int i;
  for (i=0; i<nSubsArcs; i++) {
    std::string activeSubstitutionArcName = substituteConsumedResourceNames[i]; 
    std::string activeOperationName =  operationNames[i];
    std::string activeConsumedResourceName = consumedResourceNames[i];
    std::string activeSubstituteConsumedResourceName = substituteConsumedResourceNames[i];
    
    int activeBomEntryIndex = getBomEntryIndex( activeOperationName,activeConsumedResourceName);
    std::vector<float> activeBomConsumptionRates = getConsumptionArcConsumptionRate(activeOperationName, activeConsumedResourceName);
    
    int t;
    for (t=0; t < nPeriods; t++) {
      setSubstitutionArcConsumptionRate(activeOperationName, activeConsumedResourceName, 
        activeSubstituteConsumedResourceName, t, activeBomConsumptionRates[t] );
    }
  }

  // Set obj1ScrapCost to zero for all materials
  {
    std::vector<std::string> witMaterials = getMaterialParts();
    int m;
    for (m=0; m<witMaterials.size(); ++m) {
      wwitSetNameAttribute(witSetPartObj1ScrapCost,witMaterials[m],0.0f);
    }
  } // finished setting obj1ScrapCost to zero
}
  
  //Methods for setting scrap costs in order to prevent unnecessary production

//-------------------------------------------------------------------------------------------------
//Set scrap costs using arbitrary fixed scaling factor, not taking into account the number of parts
//that appear or might appear in the model. This method is used by solve().
//-------------------------------------------------------------------------------------------------
void ECCovptProblem::getRidOfUnnecessaryProductionUsingFixedScalingOnScrapCost()
{
  const double scaleFactor=1.0e-6;
  
  // Set scrap vols on demanded parts
  {
    // Get list of all demands
    std::vector<std::string> demandNames;
    std::vector<std::string> materialNames;
    getDemandNames(materialNames,demandNames);
    
    // loop once for each demand
    unsigned int d;
    for ( d=0; d<demandNames.size(); ++d ) {
      std::string fullDemandName = materialDemandName(materialNames[d],demandNames[d]);
      float scrapCost = fabs(objValueWithNoScrapCosts_*scaleFactor);
      wwitSetNameAttribute(witSetPartObj1ScrapCost,fullDemandName,scrapCost);
    }
  } // finished setting scrapVol on demanded parts
  
  // Set scrapCosts on materials
  {
    std::vector<std::string> materialNames;
    getMaterialNames(materialNames);
    // loop once for each material
    unsigned int m;
    for ( m=0; m<materialNames.size(); ++m ) {
      float scrapCost = fabs(objValueWithNoScrapCosts_*scaleFactor);
      wwitSetNameAttribute(witSetPartObj1ScrapCost,materialNames[m],scrapCost);
    }
  } // finished setting scrapVol on materials
  witOptImplode(witRun());
  
}

//-------------------------------------------------------------------------------------------------
// Achieve what scrap costs do using Bob's trick with ExecVol Lo Bounds
//-------------------------------------------------------------------------------------------------
void ECCovptProblem::getRidOfUnnecessaryProductionBobsWay()
{
  //Add checking if WIT is in post-processed state!! 
  
  // some useful constants
  std::vector<float> vecOne = floatToStlVec(1.0f);
  std::vector<float> vecZero = floatToStlVec(0.0f);
  int nPeriods = getNPeriods();

  // maps for saving temporarily changed wit attributes
  std::map<std::string,ECCvecFloat> opExecCost, opExecSlb, opExecHub;
  std::map<ECCstringPair,ECCvecFloat> demShipRew;
  
  // For all ECC Demands set execVolSLB=shopVol, execCost=1, and DON'T set obj1ShipReward=0
  {
    // Get list of all demands
    std::vector<std::string> demandNames;
    std::vector<std::string> materialNames;
    
    getDemandNames(materialNames,demandNames);
    
    // loop once for each demand
    unsigned int d;
    for ( d=0; d<demandNames.size(); ++d ) {
      std::string fullDemandName = materialDemandName(materialNames[d],demandNames[d]);
      std::vector<float> sv = wwitGetDemandAttribute(witGetDemandShipVol,fullDemandName,demandNames[d]);
      
      // execVolSlb = shipVol
      std::vector<float> hlb, slb, hub;
      wwitGetNameBoundAttribute(witGetOperationExecBounds,fullDemandName,hlb,slb,hub);
      opExecSlb[fullDemandName] = slb;
      wwitSetNameBoundAttribute(witSetOperationExecBounds,fullDemandName,hlb,sv,hub);

      //obj1ExecCost=1 
      opExecCost[fullDemandName]=wwitGetNameAttribute(witGetOperationObj1ExecCost,fullDemandName);
      wwitSetNameAttribute(witSetOperationObj1ExecCost,fullDemandName,vecOne);

      ECCstringPair dp(fullDemandName,demandNames[d]);
      demShipRew[dp]=wwitGetDemandAttribute(witGetDemandObj1ShipReward,fullDemandName,demandNames[d]);
      //wwitSetDemandAttribute(witSetDemandObj1ShipReward,fullDemandName,demandNames[d],0.0f);
    }
  } // finished setting execVolSLB=shopVol, execCost=1, and obj1ShipReward=0
  
  // For all ecc operations with postitive contribution set execSLB=execVol
  // For all ecc operations with negative contribution set execHub=execVol
  // For all ecc operations set execCost=1
  {
    std::vector<std::string> operationNames;
    getOperationNames(operationNames);
    
    // loop once for each operation
    unsigned int o;
    for ( o=0; o<operationNames.size(); o++ ) {
      std::vector<float> contrib = getOperationContribution(operationNames[o]);
      std::vector<float> ec = wwitGetNameAttribute(witGetOperationObj1ExecCost,operationNames[o]);
      std::vector<float> ev = wwitGetNameAttribute(witGetOperationExecVol,operationNames[o]);

      std::vector<float> hlb, slb, hub;
      wwitGetNameBoundAttribute(witGetOperationExecBounds,operationNames[o],hlb,slb,hub);
      opExecSlb[operationNames[o]] = slb;
      opExecHub[operationNames[o]] = hub;

      std::vector<float> execSlb = slb;
      std::vector<float> execHub = hub;
      int t;
      for (t=0; t<nPeriods; ++t ) {
        if ( contrib[t] > 0 ) {
          execSlb[t]=ev[t];
        }
        if ( contrib[t] < 0 ) {
          execHub[t]=ev[t];
        }
      }
      wwitSetNameBoundAttribute(witSetOperationExecBounds,operationNames[o],hlb,execSlb,execHub);

      
      //obj1ExecCost=1 
      opExecCost[operationNames[o]]=wwitGetNameAttribute(witGetOperationObj1ExecCost,operationNames[o]);
      wwitSetNameAttribute(witSetOperationObj1ExecCost,operationNames[o],vecOne);
    } // end of for o loop over all operations
  } // finished setting execSLB=execVol, execHub=execVol, execCost=1

  //check if we are really in the accelerated mode, only for debug purposes
  witBoolean accelerated;
  witGetAccelerated (witRun(), & accelerated);

  witOptImplode(witRun());

  // restore wit attributes 
  {
    std::map<std::string,ECCvecFloat>::const_iterator opIt;
    for (opIt=opExecCost.begin(); opIt!=opExecCost.end(); ++opIt ) {
      wwitSetNameAttribute(witSetOperationObj1ExecCost,opIt->first,opIt->second);
    }
    for (opIt=opExecSlb.begin(); opIt!=opExecSlb.end(); ++opIt ) {
      std::vector<float> hlb, hub;
      wwitSetNameBoundAttribute(witSetOperationExecBounds,opIt->first,hlb,opIt->second,hub);
    }
    for (opIt=opExecHub.begin(); opIt!=opExecHub.end(); ++opIt ) {
      std::vector<float> hlb, slb;
      wwitSetNameBoundAttribute(witSetOperationExecBounds,opIt->first,hlb,slb,opIt->second);
    }

    std::map<ECCstringPair,ECCvecFloat>::const_iterator dIt;
    for (dIt=demShipRew.begin(); dIt!=demShipRew.end(); ++dIt ) {
      wwitSetDemandAttribute(witSetDemandObj1ShipReward,(dIt->first).first,(dIt->first).second,dIt->second);
    }
  }
  witPostprocess(witRun());
  
}


//-----------------------------
// get objValue from eastman's point of view
//-----------------------------
double ECCovptProblem::getEccObjValue() const
{
  double retVal = 0;
  int np=getNPeriods();
  std::vector<double> objByPeriod=getEccObjValueByPeriod();
  int t;
  for (t=0; t<np; ++t) {
    retVal+=objByPeriod[t];
  }
  return retVal;
}
//-----------------------------
// get objValue from eastman's point of view
//-----------------------------
std::vector<double> ECCovptProblem::getEccObjValueByPeriod() const
{
  int np=getNPeriods();
  std::vector<double> retVal(np,0.0);

  // get demand component of objValue
  {
    // Get list of all demands
    std::vector<std::string> demandNames;
    std::vector<std::string> materialNames;
    getDemandNames(materialNames,demandNames);
    
    // loop once for each demand
    unsigned int d;
    for ( d=0; d<demandNames.size(); ++d ) {
      std::vector<float> shipVol = getDemandShipVol(materialNames[d],demandNames[d]);
      std::vector<float> contrib = getDemandContribution(materialNames[d],demandNames[d]);
      int t;
      for (t=0; t<np; ++t) 
        retVal[t]+=shipVol[t]*contrib[t];
      //std::cout <<materialNames[d] <<" " <<demandNames[d] <<" " <<retVal <<std::endl;
    }
  } // finished with demand component of objValue

  
  // get operation component of objValue
  {
    // Get list of all operations
    std::vector<std::string> operationNames;
    getOperationNames(operationNames);
    
    // loop once for each demand
    unsigned int o;
    for ( o=0; o<operationNames.size(); ++o ) {
      std::vector<float> execVol = getOperationExecutionVolume(operationNames[o]);
      std::vector<float> contrib = getOperationContribution(operationNames[o]);
      int t;
      for (t=0; t<np; ++t) 
        retVal[t]+=execVol[t]*contrib[t];
    }
  } // finished with demand component of objValue
  return retVal;

}


//-----------------------------
// unnecessaryProduction: return true if solution has
// unnecessaryProduction which means scrapCosts should be higher
// An operation should produce at least one material that has zero scrapVol.
// If this is not the case, then there is unnecessaryProduction.
//-----------------------------
bool ECCovptProblem::unnecessaryProduction() const
{
  CoinRelFltEq eq;
  bool retVal=false;
  std::vector<std::string> ops = getOperations();
  int np=getNPeriods();
  
  //loop once for each operation
  int o;
  for( o=0; o<ops.size(); ++o ) {
    int nBops;
    witGetOperationNBopEntries(mutableWitRun(),ops[o].c_str(),&nBops);
    
    typedef std::vector<float> ECCvecFloat;
    std::vector<ECCvecFloat> scrapVols;
    
    // loop once for each bop
    int b;
    for( b=0; b<nBops; ++b ) {
      char * prodPart;
      witGetBopEntryProducedPart(mutableWitRun(),ops[o].c_str(),b,&prodPart);
      
      ECCvecFloat scrapVol=wwitGetNameAttribute(witGetPartScrapVol,prodPart);
      witFree(prodPart);
      
      scrapVols.push_back(scrapVol);
    } //end of for b loop

    int t;
    for ( t=0; t<np; ++t ) {
      bool bopWithZeroScrapVol=false;
      for( b=0; b<nBops; ++b ) {
        if( eq(scrapVols[b][t],0.0f) ) {
          bopWithZeroScrapVol=true;
          break;
        }
      } //end of for b loop
      if ( !bopWithZeroScrapVol ) {
        retVal=true;
        return retVal;
      }
    } // end of t loop

  } // end of for o loop
  return retVal;
}

//-----------------------------
// Solve. Formulate and solve LP
//-----------------------------
void ECCovptProblem::solve()
{
  CoinRelFltEq eq;
  
  // Do final setup of wit model
  presolve();
  
  // solve wit no scrap costs which may cause unnecessary production.
  witOptImplode(witRun());
  objValueWithNoScrapCosts_ = getEccObjValue();
  
  // If solution has unneed production, then must set a scrapCost
  //if (unnecessaryProduction()) {

    //getRidOfUnnecessaryProductionUsingFixedScalingOnScrapCost();
    getRidOfUnnecessaryProductionBobsWay();

  //}
}

// Test solution for the following properties:
// - there is no unnecessary production 
// - The objective function value from Eastman's perspective
//   is unchanged by the possible addition of scrapCost
bool ECCovptProblem::isSolutionOK() const
{
  CoinRelFltEq eq(7);
  bool unProd = unnecessaryProduction();
  double objWithNoScrap = getObjValueWithNoScrapCosts();
  double objValue = getEccObjValue();
  bool objUnchanged = eq(objWithNoScrap,objValue);
  bool retVal = !unProd && objUnchanged;
  return retVal;
}

double ECCovptProblem::getObjValueWithNoScrapCosts() const
{
  return objValueWithNoScrapCosts_;
}

// default constructor
ECCovptProblem::ECCovptProblem()
:
SCOproblemBase(),
outputDirectory_("."),
objValueWithNoScrapCosts_(FLT_MIN),
materialNames_(),
capacityNames_(),
operationNames_(),
materialDemandNames_(),
consumptionArcNames_(),
substitutionArcNames_(),
productionArcNames_()
{
  //checkWitRC(witSetExecEmptyBom(witRun(),WitTRUE));

  //make WIT use Accelerated Mode
	witSetAccAfterOptImp (witRun(),WitTRUE);
	witSetAccAfterSoftLB (witRun(),WitTRUE);

  // Turn off warning message about having negative obj1ExecCost
  witSetMesgTimesPrint( witRun(), WitTRUE, 605, 0);
}

ECCovptProblem::ECCovptProblem(const std::string & outputDirectory)
:
SCOproblemBase(outputDirectory),
outputDirectory_(outputDirectory),
objValueWithNoScrapCosts_(FLT_MIN),
materialNames_(),
capacityNames_(),
operationNames_(),
materialDemandNames_(),
consumptionArcNames_(),
substitutionArcNames_(),
productionArcNames_()
{
  //checkWitRC(witSetExecEmptyBom(witRun(),WitTRUE));

	
  //make WIT use Accelerated Mode
    witSetAccAfterOptImp (witRun(),WitTRUE);
	witSetAccAfterSoftLB (witRun(),WitTRUE);


  // Turn off warning message about having negative obj1ExecCost
  witSetMesgTimesPrint( witRun(), WitTRUE, 605, 0);
}

// destructor
ECCovptProblem::~ECCovptProblem()
{
  gutsOfDestructor();
}

// copy constructor
ECCovptProblem::ECCovptProblem( const ECCovptProblem& source ):
SCOproblemBase(source),
outputDirectory_(),
objValueWithNoScrapCosts_(FLT_MIN),
materialNames_(),
capacityNames_(),
operationNames_(),
materialDemandNames_(),
consumptionArcNames_(),
substitutionArcNames_(),
productionArcNames_()
{
  gutsOfCopy(source);
}

// assignment operator
ECCovptProblem&
ECCovptProblem::operator=(const ECCovptProblem& rhs)
{  
  if (this != &rhs) { 
    SCOproblemBase::operator=(rhs);
    gutsOfCopy(rhs);
  }
  return *this;
}

// copy object
void ECCovptProblem::gutsOfCopy( const ECCovptProblem& source )
{
  outputDirectory_ = source.outputDirectory_;
  objValueWithNoScrapCosts_ = source.objValueWithNoScrapCosts_; 
  materialNames_ = source.materialNames_; 
  capacityNames_ = source.capacityNames_;
  operationNames_ = source.operationNames_; 
  materialDemandNames_ = source.materialDemandNames_; 
  consumptionArcNames_ = source.consumptionArcNames_;
  substitutionArcNames_ = source.substitutionArcNames_; 
  productionArcNames_ = source.productionArcNames_; 
}

// destructor
void ECCovptProblem::gutsOfDestructor()
{
 // Nothing to do here 
}



#ifdef NDEBUG
#undef NDEBUG
#endif
//------------------------------------------------------------------------------
// Test function
//------------------------------------------------------------------------------
void
ECCovptProblem::test()
{
  CoinRelFltEq eq;
  
  // Test constructor and set/get nPeriods
  {
    ECCovptProblem prob;
    
    prob.setNPeriods(12);
    assert( prob.getNPeriods() == 12 );    
  }
  
  
  // Test material methods
  {
    ECCovptProblem prob;
    
    prob.setNPeriods(2);

    assert(  !prob.materialExists("e1") );
    
    prob.addMaterial("e1");  
    prob.addMaterial("e2");
    
    assert(  prob.materialExists("e1") );
    assert(  prob.materialExists("e2") );
    assert( !prob.materialExists("e3") );
    
    assert( prob.getMaterialSupply("e1").size() == 2 );
    assert( prob.getMaterialSupply("e1")[0] == 0.0f );
    assert( prob.getMaterialSupply("e1")[1] == 0.0f );
    prob.setMaterialSupply("e1",0,1.234f);
    assert( prob.getMaterialSupply("e1").size() == 2 );
    assert( prob.getMaterialSupply("e1")[0] == 1.234f );
    assert( prob.getMaterialSupply("e1")[1] == 0.0f );
    prob.setMaterialSupply("e1",1,2.234f);
    assert( prob.getMaterialSupply("e1").size() == 2 );
    assert( prob.getMaterialSupply("e1")[0] == 1.234f );
    assert( prob.getMaterialSupply("e1")[1] == 2.234f );
    
        
    std::vector<std::string> names;
    prob.getMaterialNames(names);
    assert( names.size()==2 );
    assert( names[0]=="e1" || names[1]=="e1" );
    assert( names[0]=="e2" || names[1]=="e2" ); 
    
    assert(  !prob.materialExists("x1") );
    prob.addCapacity("x1");
    assert(  !prob.materialExists("x1") );
  } // end of material method tests
  
  // Test capacity methods
  {  
    ECCovptProblem prob;
    
    prob.setNPeriods(2);

    assert(  !prob.capacityExists("c1") );
    
    prob.addCapacity("c1");  
    prob.addCapacity("c2");
    
	assert(  prob.capacityExists("c1") );
    assert(  prob.capacityExists("c2") );
    assert( !prob.capacityExists("c3") );
   
    assert( prob.getCapacitySupply("c1").size() == 2 );
    assert( prob.getCapacitySupply("c1")[0] == 0.0f );
    assert( prob.getCapacitySupply("c1")[1] == 0.0f );
    prob.setCapacitySupply("c1",0,1.254f);
    assert( prob.getCapacitySupply("c1").size() == 2 );
    assert( prob.getCapacitySupply("c1")[0] == 1.254f );
    assert( prob.getCapacitySupply("c1")[1] == 0.0f );
    prob.setCapacitySupply("c1",1,2.534f);
    assert( prob.getCapacitySupply("c1").size() == 2 );
    assert( prob.getCapacitySupply("c1")[0] == 1.254f );
    assert( prob.getCapacitySupply("c1")[1] == 2.534f );
    
    std::vector<std::string> names;
    prob.getCapacityNames(names);
    assert( names.size()==2 );
    assert( names[0]=="c1" || names[1]=="c1" );
    assert( names[0]=="c2" || names[1]=="c2" ); 
    
    assert(  !prob.capacityExists("x1") );
    prob.addMaterial("x1");
    assert(  !prob.capacityExists("x1") );
  } // end capacity method tests

  // Test operation methods
  {
    ECCovptProblem prob;
    
    prob.setNPeriods(2);

    assert(  !prob.operationExists("e1") );
    
    prob.addOperation("e1");  
    prob.addOperation("e2");
    
    assert(  prob.operationExists("e1") );
    assert(  prob.operationExists("e2") );
    assert( !prob.operationExists("e3") );
    
    assert( prob.getOperationContribution("e1").size() == 2 );
    assert( prob.getOperationContribution("e1")[0] == 0.0f );
    assert( prob.getOperationContribution("e1")[1] == 0.0f );
    prob.setOperationContribution("e1",0,1.234f);
    assert( prob.getOperationContribution("e1").size() == 2 );
    float x = prob.getOperationContribution("e1")[0];
    assert( prob.getOperationContribution("e1")[0] == 1.234f );
    assert( prob.getOperationContribution("e1")[1] == 0.0f );
    prob.setOperationContribution("e1",1,2.234f);
    assert( prob.getOperationContribution("e1").size() == 2 );
    assert( prob.getOperationContribution("e1")[0] == 1.234f );
    assert( prob.getOperationContribution("e1")[1] == 2.234f );
    
    assert( prob.getOperationMinimumProduction("e2").size() == 2 );
    assert( prob.getOperationMinimumProduction("e2")[0] == 0.0f );
    assert( prob.getOperationMinimumProduction("e2")[1] == 0.0f );
    prob.setOperationMinimumProduction("e2",0,1.234f);
    assert( prob.getOperationMinimumProduction("e2").size() == 2 );
    assert( prob.getOperationMinimumProduction("e2")[0] == 1.234f );
    assert( prob.getOperationMinimumProduction("e2")[1] == 0.0f );
    prob.setOperationMinimumProduction("e2",1,2.234f);
    assert( prob.getOperationMinimumProduction("e2").size() == 2 );
    assert( prob.getOperationMinimumProduction("e2")[0] == 1.234f );
    assert( prob.getOperationMinimumProduction("e2")[1] == 2.234f );
    
        
    std::vector<std::string> names;
    prob.getOperationNames(names);
    assert( names.size()==2 );
    assert( names[0]=="e1" || names[1]=="e1" );
    assert( names[0]=="e2" || names[1]=="e2" );   
  }


  // Consumption Arc Test
  {
    ECCovptProblem prob;

    prob.setNPeriods(5);

    assert( !prob.consumptionArcExists("o1","r1") );
    prob.addOperation("o1");
    prob.addCapacity("r1");
    assert( !prob.consumptionArcExists("o1","r1") );
    prob.addConsumptionArc("o1","r1");
    assert( prob.consumptionArcExists("o1","r1") );

    prob.addOperation("o2");
    prob.addConsumptionArc("o2","r1");

    prob.addMaterial("r2");
    prob.addConsumptionArc("o1","r2");
    prob.addConsumptionArc("o2","r2");

    assert( prob.consumptionArcExists("o1","r1") );
    assert( prob.consumptionArcExists("o1","r2") );
    assert( prob.consumptionArcExists("o2","r1") );
    assert( prob.consumptionArcExists("o2","r2") );

    std::vector<float> cr = prob.getConsumptionArcConsumptionRate("o2","r1");
    assert( cr[0] == 0.0f );
    assert( cr[1] == 0.0f );
    assert( cr[2] == 0.0f );
    assert( cr[3] == 0.0f );
    assert( cr[4] == 0.0f );

    prob.setConsumptionArcConsumptionRate("o2","r1",0,1.f);
    prob.setConsumptionArcConsumptionRate("o2","r1",1,2.f);
    prob.setConsumptionArcConsumptionRate("o2","r1",2,3.f);
    prob.setConsumptionArcConsumptionRate("o2","r1",3,4.f);
    prob.setConsumptionArcConsumptionRate("o2","r1",4,5.f);
    cr = prob.getConsumptionArcConsumptionRate("o2","r1");
    assert( cr[0] == 1.0f );
    assert( cr[1] == 2.0f );
    assert( cr[2] == 3.0f );
    assert( cr[3] == 4.0f );
    assert( cr[4] == 5.0f );
  } // End of consumption arc test

   // Testing the method getSubBomEntryIndex in problemBase
  {
    ECCovptProblem prob;

    prob.setNPeriods(5);

	witAddOperation(prob.witRun(),"o1");
	witAddPart(prob.witRun(),"m1",WitMATERIAL);
	witAddPart(prob.witRun(),"s1",WitMATERIAL);
	witAddPart(prob.witRun(),"s2",WitMATERIAL);

	//assert(prob.getSubBomEntryIndex("o1","m2",0)==-1);
	witAddBomEntry(prob.witRun(),"o1","m1");
	assert(prob.getBomEntryIndex("o1","m1")==0);
	//witAddBomEntry(prob.witRun(),"o1","m1");
	assert(prob.getSubBomEntryIndex("o1","m1","s1")==-1);
    witAddSubsBomEntry(prob.witRun(),"o1",0, "s1");
	assert(prob.getSubBomEntryIndex("o1","m1","s1")==0);
	witAddSubsBomEntry(prob.witRun(),"o1",0, "s2");
	assert(prob.getSubBomEntryIndex("o1","m1","s1")==0);
	assert(prob.getSubBomEntryIndex("o1","m1","s2")==1);
  }
  //----------------

  // Substitution Arc Test
  {
    ECCovptProblem prob;
    
    prob.setNPeriods(5);
    
    assert( !prob.substitutionArcExists("o1","m1","s1") );
    prob.addOperation("o1");
    prob.addCapacity("m1");
    prob.addCapacity("s1");
    assert( !prob.substitutionArcExists("o1","m1","s1") );    
    assert(prob.getSubBomEntryIndex("o1","m1","s1")==-1);
    prob.addConsumptionArc("o1","m1");
    prob.addSubstitutionArc("o1","m1","s1");
    assert( prob.substitutionArcExists("o1","m1","s1") );
    assert(prob.getSubBomEntryIndex("o1","m1","s1")==0);
    
    prob.addOperation("o2");
    prob.addConsumptionArc("o2","m1");
    
    prob.addMaterial("m2");
    prob.addMaterial("s2");
    prob.addConsumptionArc("o1","m2");
    assert(prob.getSubBomEntryIndex("o1","m2","s1")==-1);
    prob.addConsumptionArc("o2","m2");
    
    prob.addSubstitutionArc("o1","m2","s1");
    assert(prob.getSubBomEntryIndex("o1","m2","s1")==0);
    prob.addSubstitutionArc("o2","m1","s1");
    prob.addSubstitutionArc("o2","m2","s1");
    
    prob.addSubstitutionArc("o1","m1","s2");
    prob.addSubstitutionArc("o1","m2","s2");
    prob.addSubstitutionArc("o2","m1","s2");
    prob.addSubstitutionArc("o2","m2","s2");
    
    assert( prob.substitutionArcExists("o1","m1","s1") );
    assert(   prob.getSubBomEntryIndex("o1","m1","s1")==0);
    assert( prob.substitutionArcExists("o1","m2","s1") );
    assert(   prob.getSubBomEntryIndex("o1","m2","s1")==0);
    assert( prob.substitutionArcExists("o2","m1","s1") );
    assert(   prob.getSubBomEntryIndex("o2","m1","s1")==0);
    assert( prob.substitutionArcExists("o2","m2","s1") );
    assert(   prob.getSubBomEntryIndex("o2","m2","s1")==0);
    
    assert( prob.substitutionArcExists("o1","m1","s2") );
    assert(   prob.getSubBomEntryIndex("o1","m1","s2")==1);
    assert( prob.substitutionArcExists("o1","m2","s2") );
    assert(   prob.getSubBomEntryIndex("o1","m2","s2")==1);
    assert( prob.substitutionArcExists("o2","m1","s2") );
    assert(   prob.getSubBomEntryIndex("o2","m1","s2")==1);
    assert( prob.substitutionArcExists("o2","m2","s2") );
    assert(   prob.getSubBomEntryIndex("o2","m2","s2")==1);
    
    std::vector<float> cr = prob.getSubstitutionArcConsumptionRate("o2","m1","s1");
    assert( cr[0] == 0.0f );
    assert( cr[1] == 0.0f );
    assert( cr[2] == 0.0f );
    assert( cr[3] == 0.0f );
    assert( cr[4] == 0.0f );
    
    prob.setSubstitutionArcConsumptionRate("o2","m1","s1",0,1.f);
    prob.setSubstitutionArcConsumptionRate("o2","m1","s1",1,2.f);
    prob.setSubstitutionArcConsumptionRate("o2","m1","s1",2,3.f);
    prob.setSubstitutionArcConsumptionRate("o2","m1","s1",3,4.f);
    prob.setSubstitutionArcConsumptionRate("o2","m1","s1",4,5.f);
    cr = prob.getSubstitutionArcConsumptionRate("o2","m1","s1");
    assert( cr[0] == 1.0f );
    assert( cr[1] == 2.0f );
    assert( cr[2] == 3.0f );
    assert( cr[3] == 4.0f );
    assert( cr[4] == 5.0f );
    
    cr = prob.getSubstitutionArcConsumptionRate("o1","m1","s2");
    assert( cr[0] == 0.0f );
    assert( cr[1] == 0.0f );
    assert( cr[2] == 0.0f );
    assert( cr[3] == 0.0f );
    assert( cr[4] == 0.0f );
    
    
    //test presolve method
    
    prob.setConsumptionArcConsumptionRate("o1","m1",0,1.f);
    prob.setConsumptionArcConsumptionRate("o1","m1",1,2.f);
    prob.setConsumptionArcConsumptionRate("o1","m1",2,3.f);
    prob.setConsumptionArcConsumptionRate("o1","m1",3,4.f);
    prob.setConsumptionArcConsumptionRate("o1","m1",4,5.f);
    
    prob.presolve();
        
    cr = prob.getSubstitutionArcConsumptionRate("o2","m1","s1");
    assert( cr[0] == 0.0f );
    assert( cr[1] == 0.0f );
    assert( cr[2] == 0.0f );
    assert( cr[3] == 0.0f );
    assert( cr[4] == 0.0f );
    
    cr = prob.getSubstitutionArcConsumptionRate("o1","m1","s2");
    assert( cr[0] == 1.0f );
    assert( cr[1] == 2.0f );
    assert( cr[2] == 3.0f );
    assert( cr[3] == 4.0f );
    assert( cr[4] == 5.0f );
    
  } // End of substitution arc test
    
    // Production Arc Test
  {
    ECCovptProblem prob;

    prob.setNPeriods(5);

    assert( !prob.productionArcExists("o1","r1") );
    prob.addOperation("o1");
    prob.addCapacity("r1");
    assert( !prob.productionArcExists("o1","r1") );
    prob.addProductionArc("o1","r1");
    assert( prob.productionArcExists("o1","r1") );

    prob.addOperation("o2");
    prob.addProductionArc("o2","r1");

    prob.addMaterial("r2");
    prob.addProductionArc("o1","r2");
    prob.addProductionArc("o2","r2");

    assert( prob.productionArcExists("o1","r1") );
    assert( prob.productionArcExists("o1","r2") );
    assert( prob.productionArcExists("o2","r1") );
    assert( prob.productionArcExists("o2","r2") );

    std::vector<float> cr = prob.getProductionArcProductionRate("o2","r1");
    assert( cr[0] == 0.0f );
    assert( cr[1] == 0.0f );
    assert( cr[2] == 0.0f );
    assert( cr[3] == 0.0f );
    assert( cr[4] == 0.0f );

    prob.setProductionArcProductionRate("o2","r1",0,1.f);
    prob.setProductionArcProductionRate("o2","r1",1,2.f);
    prob.setProductionArcProductionRate("o2","r1",2,3.f);
    prob.setProductionArcProductionRate("o2","r1",3,4.f);
    prob.setProductionArcProductionRate("o2","r1",4,5.f);
    cr = prob.getProductionArcProductionRate("o2","r1");
    assert( cr[0] == 1.0f );
    assert( cr[1] == 2.0f );
    assert( cr[2] == 3.0f );
    assert( cr[3] == 4.0f );
    assert( cr[4] == 5.0f );
  } // End of production arc test

  // Test demand methods
  {  
    ECCovptProblem prob;
    
    prob.setNPeriods(2);
    
    assert(  !prob.demandExists("DullYarn", "d1") );
    
    prob.addMaterial("DullYarn");
    prob.addDemand("DullYarn","d1");
    
    prob.addMaterial("WeakAceticAcid");
    prob.addDemand("WeakAceticAcid","d2");
    
    assert(  prob.demandExists("DullYarn","d1") );
    assert(  prob.demandExists("WeakAceticAcid","d2") );
    assert( !prob.demandExists("Tow","d3") );
    
    //test demVol methods
    assert( prob.getDemandDemandVol("DullYarn","d1").size() == 2 );
    assert( prob.getDemandDemandVol("DullYarn","d1")[0] == 0.0f );
    assert( prob.getDemandDemandVol("DullYarn","d1")[1] == 0.0f );
    prob.setDemandDemandVol("DullYarn","d1",0,1.754f);
    assert( prob.getDemandDemandVol("DullYarn","d1").size() == 2 );
    assert( prob.getDemandDemandVol("DullYarn","d1")[0] == 1.754f );
    assert( prob.getDemandDemandVol("DullYarn","d1")[1] == 0.0f );
    prob.setDemandDemandVol("DullYarn","d1",1,2.514f);
    assert( prob.getDemandDemandVol("DullYarn","d1").size() == 2 );
    assert( prob.getDemandDemandVol("DullYarn","d1")[0] == 1.754f );
    assert( prob.getDemandDemandVol("DullYarn","d1")[1] == 2.514f );
    
    //test contribution methods
    assert( prob.getDemandContribution("DullYarn","d1").size() == 2 );
    assert( prob.getDemandContribution("DullYarn","d1")[0] == 0.0f );
    assert( prob.getDemandContribution("DullYarn","d1")[1] == 0.0f );
    prob.setDemandContribution("DullYarn","d1",0,1.754f);
    assert( prob.getDemandContribution("DullYarn","d1").size() == 2 );
    assert( prob.getDemandContribution("DullYarn","d1")[0] == 1.754f );
    assert( prob.getDemandContribution("DullYarn","d1")[1] == 0.0f );
    prob.setDemandContribution("DullYarn","d1",1,2.514f);
    assert( prob.getDemandContribution("DullYarn","d1").size() == 2 );
    assert( prob.getDemandContribution("DullYarn","d1")[0] == 1.754f );
    assert( prob.getDemandContribution("DullYarn","d1")[1] == 2.514f );
    
    //test minShipVol methods
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2").size() == 2 );
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2")[0] == 0.0f );
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2")[1] == 0.0f );
    prob.setDemandMinShipVol("WeakAceticAcid","d2",1,20.f);
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2").size() == 2 );
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2")[0] == 0.0f );
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2")[1] == 20.0f );
    prob.setDemandMinShipVol("WeakAceticAcid","d2",0,10.f);
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2").size() == 2 );
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2")[0] == 10.f );
    assert( prob.getDemandMinShipVol("WeakAceticAcid","d2")[1] == 20.f );
    
    
    std::vector<std::string> mns;
    std::vector<std::string> dns;
    prob.getDemandNames(mns,dns);
    assert( mns.size()==2 );
    assert( dns.size()==2 );
    assert( mns[0]=="DullYarn" || mns[1]=="DullYarn" );
    if ( mns[0]=="DullYarn" ) {
      assert( mns[1]=="WeakAceticAcid" );
      assert( dns[0]=="d1" );
      assert( dns[1]=="d2" );
    }
    else {
      assert( mns[0]=="WeakAceticAcid" );
      assert( dns[1]=="d1" );
      assert( dns[0]=="d2" );
    }
  } // end of demand method tests


 // Test materialOrphan methods
  {
    ECCovptProblem prob;
    
    prob.setNPeriods(2);

	std::vector<std::string> materialOrphanNames;

	prob.getMaterialOrphanNames(materialOrphanNames);
    assert(  materialOrphanNames.size()==0 );
    
    //check if the code does not mistake capacities or operations for materials
    prob.addCapacity("c1");  
    prob.addCapacity("c2");
	prob.addOperation("o1"); 

    prob.getMaterialOrphanNames(materialOrphanNames);
    assert(  materialOrphanNames.size()==0 );
    
	//now add real materials
    prob.addMaterial("e1");  
    prob.addMaterial("e2");
    
	prob.getMaterialOrphanNames(materialOrphanNames);
    assert(  materialOrphanNames.size()==2 );
	assert(  (materialOrphanNames[0]=="e1") || (materialOrphanNames[1]=="e1") );
    
    prob.addConsumptionArc("o1","e1");
    
	prob.getMaterialOrphanNames(materialOrphanNames);
    assert(  materialOrphanNames.size()==1 );
	assert(materialOrphanNames[0]=="e2");

	prob.addProductionArc("o1","e2");
    
	prob.getMaterialOrphanNames(materialOrphanNames);
    assert(  materialOrphanNames.size()==0 );
  } // end of materialOrphan method tests

 // Test capacityOrphan methods
  {
    ECCovptProblem prob;
    
    prob.setNPeriods(2);

	std::vector<std::string> capacityOrphanNames;

	prob.getCapacityOrphanNames(capacityOrphanNames);
    assert(  capacityOrphanNames.size()==0 );
    
	//check if the code does not mistake capacities and materials
    prob.addMaterial("e1");  
    prob.addMaterial("e2");
    prob.addOperation("o1"); 

    prob.getCapacityOrphanNames(capacityOrphanNames);
    assert(  capacityOrphanNames.size()==0 );
    
	//now add real capacities
    prob.addCapacity("c1");  
    prob.addCapacity("c2");

	prob.getCapacityOrphanNames(capacityOrphanNames);
    assert(  capacityOrphanNames.size()==2 );
	assert(  (capacityOrphanNames[0]=="c1") || (capacityOrphanNames[1]=="c1") );
    
    prob.addConsumptionArc("o1","c1");
    
	prob.getCapacityOrphanNames(capacityOrphanNames);
    assert(  capacityOrphanNames.size()==1 );
	assert(capacityOrphanNames[0]=="c2");

	prob.addProductionArc("o1","c2");
    
	prob.getCapacityOrphanNames(capacityOrphanNames);
    assert(  capacityOrphanNames.size()==1 );

    prob.addConsumptionArc("o1","c2");
    
	prob.getCapacityOrphanNames(capacityOrphanNames);
    assert(  capacityOrphanNames.size()==0 );
  } // end of capacityOrphan method tests

   // Test operationOrphan methods
  {
    ECCovptProblem prob;
    
    prob.setNPeriods(2);

	std::vector<std::string> operationOrphanNames;

	prob.getOperationOrphanNames(operationOrphanNames);
    assert(  operationOrphanNames.size()==0 );
    
	//check if the code does not mistake capacities or materials for operations
    prob.addMaterial("m1");  
    prob.addMaterial("m2");
	prob.addCapacity("c1");  
    prob.addCapacity("c2");

    prob.getOperationOrphanNames(operationOrphanNames);
    assert( operationOrphanNames.size()==0 );
    
	//now add real operations

	prob.addOperation("o1");  
    prob.addOperation("o2");
  
	prob.getOperationOrphanNames(operationOrphanNames);
    assert(  operationOrphanNames.size()==2 );
	assert(  (operationOrphanNames[0]=="o1") || (operationOrphanNames[1]=="o1") );
    
    prob.addConsumptionArc("o1","m1");
	prob.addConsumptionArc("o2","c1");
    
	prob.getOperationOrphanNames(operationOrphanNames);
    assert( operationOrphanNames.size()==2 );
	assert( operationOrphanNames[0]=="o2" || operationOrphanNames[1]=="o2");

	prob.addProductionArc("o1","m2");
    prob.addProductionArc("o2","m2");

	prob.getOperationOrphanNames(operationOrphanNames);
    assert( operationOrphanNames.size()==0 );
  } // end of operationOrphan method tests

  // Test assignment operator
  {
    ECCovptProblem prob0;
    {
      ECCovptProblem prob1;
      prob1.setNPeriods(2);
      
      prob1.addMaterial("e1");
      
      prob1.setMaterialSupply("e1",1,1.0f);
      
      prob0=prob1;
    }
    
    assert(prob0.getMaterialSupply("e1")[0]==0.0f);
    assert(prob0.getMaterialSupply("e1")[1]==1.0f);
  }
  

  // Test reading example1 with populate
  {
    std::string inputDirectory = "../data/example1";
    std::string logFileName = "../data/example1/ovptLog.txt";
    ECCovptProblem prob(inputDirectory);
    //this problem must use priority substitute skills to satisfy demand
    ECCpopulateProblem(prob, inputDirectory,logFileName).readDirectoryFiles();
    
    assert(prob.getNPeriods() == 5);

    // Test that materials were read
    assert(prob.materialExists("Tow"));
    assert(prob.materialExists("DullYarn"));
    assert( eq( prob.getMaterialSupply("CG_AC20")[3-1], 549.f  ) );
    assert( eq( prob.getMaterialSupply("CG_Acid")[2-1], 1293.f ) );

    // Test that capacities were read
    assert(prob.capacityExists("EctonaTowCapacity"));
    assert(prob.capacityExists("B81FlakesCapacity"));
    assert(prob.capacityExists("KingsportTowCapacity"));
    assert(prob.capacityExists("PrimesterFlakesCapacity"));
    assert(prob.capacityExists("AcetateYarnCapacity"));
    assert( prob.getCapacitySupply("EctonaTowCapacity").size() == 5 );
    assert( eq( prob.getCapacitySupply("EctonaTowCapacity")[1-1], 14100.f  ) );
    assert( eq( prob.getCapacitySupply("B81FlakesCapacity")[2-1], 196859.f  ) );
    assert( eq( prob.getCapacitySupply("KingsportTowCapacity")[3-1], 158000.f  ) );
    assert( eq( prob.getCapacitySupply("PrimesterFlakesCapacity")[4-1], 79242.f  ) );
    assert( eq( prob.getCapacitySupply("AcetateYarnCapacity")[5-1], 22000.f  ) );

    // Test that operations were read
    assert(prob.operationExists("MakeKingsportTow"));
    assert(prob.operationExists("CombineFlakes"));
    assert(prob.operationExists("MakePrimesterFlakes"));
    assert( prob.getOperationContribution("CombineFlakes").size() == 5 );
    assert( eq( prob.getOperationContribution("CombineFlakes")[3-1], 0.0f  ) );
    assert( prob.getOperationContribution("MakePrimesterFlakes").size() == 5 );
    assert( eq( prob.getOperationContribution("MakePrimesterFlakes")[4-1], 1234.5f  ) );
    assert( prob.getOperationMinimumProduction("CombineFlakes").size() == 5 );
    assert( eq( prob.getOperationMinimumProduction("CombineFlakes")[3-1], 0.0f  ) );
    assert( prob.getOperationMinimumProduction("MakePrimesterFlakes").size() == 5 );
    assert( eq( prob.getOperationMinimumProduction("MakePrimesterFlakes")[4-1], 0.0f  ) );

    // Test that consumption arcs were read
    assert(prob.consumptionArcExists("MakeEctonaTow","EctonaTowCapacity") );
    assert(prob.consumptionArcExists("MakeB81Flakes","CG_Acid") );
    assert(prob.getConsumptionArcConsumptionRate("MakePrimesterFlakes","CG_Acid").size() == 5 );
    assert(eq(prob.getConsumptionArcConsumptionRate("MakePrimesterFlakes","CG_Acid")[2],4.6788f) );

    // Test that production arcs were read
    assert(prob.productionArcExists("MakePrimesterFlakes","CG_Acid") );
    assert(prob.productionArcExists("MakeB81Flakes","RecoveredAceticAcid") );
    assert(prob.getProductionArcProductionRate("MakePrimesterFlakes","CG_Acid").size() == 5 );
    assert(eq(prob.getProductionArcProductionRate("MakePrimesterFlakes","CG_Acid")[2],3.7f) );

    // Test that demands were read
    assert(prob.demandExists("BrightYarn","US Bright Yarn") );
    assert(prob.demandExists("Flake","AP Ester") );
    assert(prob.getDemandDemandVol("BrightYarn","US Bright Yarn").size() == 5 );
    assert(eq(prob.getDemandDemandVol("BrightYarn","US Bright Yarn")[2],150.f) );
    assert(eq(prob.getDemandContribution("BrightYarn","US Bright Yarn")[2],26.f) );
    assert(eq(prob.getDemandMinShipVol("BrightYarn","US Bright Yarn")[2],0.0f) );
    
    // Test that substitutes were read
    assert(prob.substitutionArcExists("CombineFlakes","B81Flake","PrimesterFlake"));
  }

  // The most simple problem. Single raw material, product, and demand
  {
     ECCovptProblem prob;
     prob.setNPeriods(1);
     prob.addMaterial("raw");
     prob.addMaterial("product");
     prob.addOperation("make product");
     prob.addConsumptionArc("make product","raw");
     prob.addProductionArc("make product","product");
     prob.addDemand("product","sales");

     prob.setMaterialSupply( "raw", 0, 10.f );
     prob.setConsumptionArcConsumptionRate("make product","raw",0,1.0f);
     prob.setProductionArcProductionRate("make product","product",0,1.0f);
     prob.setDemandDemandVol("product", "sales", 0, 9.0f );
     prob.setDemandContribution("product", "sales", 0, 1.0f );

     prob.solve();
     assert(prob.isSolutionOK());

     assert( eq(prob.getDemandShipVol("product", "sales")[0],9.0f) );

     assert( eq(prob.getMaterialConsumptionVolume("raw")[0],9.0f) );
     assert( eq(prob.getMaterialProductionVolume("raw")[0] ,0.0f) );

     assert( eq(prob.getMaterialConsumptionVolume("product")[0],9.0f) );
     assert( eq(prob.getMaterialProductionVolume("product")[0] ,9.0f) );

     double objValue = prob.getEccObjValue();
     assert( eq(objValue,9.0f) );

  }  //end of "The most simple problem. Single raw material, product, and demand"
    
  
  // simple problem. Single capacity, product, & demand. 2 periods.
  {
     ECCovptProblem prob;
     prob.setNPeriods(2);
     prob.addCapacity("capacity");
     prob.addMaterial("product");
     prob.addOperation("make product");
     prob.addConsumptionArc("make product","capacity");
     prob.addProductionArc("make product","product");
     prob.addDemand("product","sales");

     // Period 0 settings
     prob.setCapacitySupply( "capacity", 0, 10.f );
     prob.setConsumptionArcConsumptionRate("make product","capacity",0,1.0f);
     prob.setProductionArcProductionRate("make product","product",0,1.0f);
     prob.setDemandDemandVol("product", "sales", 0, 9.0f );
     prob.setDemandContribution("product", "sales", 0, 1.0f );

     // Period 1 settings
     prob.setCapacitySupply( "capacity", 1, 10.f );
     prob.setConsumptionArcConsumptionRate("make product","capacity",1,1.0f);
     prob.setProductionArcProductionRate("make product","product",1,1.0f);
     prob.setDemandDemandVol("product", "sales", 1, 12.0f );
     prob.setDemandContribution("product", "sales", 1, 1.0f );

     prob.solve();
     assert(prob.isSolutionOK());

     assert( eq(prob.getDemandShipVol("product", "sales")[0],9.0f) );
     assert( eq(prob.getCapacityConsumptionVolume("capacity")[0],9.0f) );
     assert( eq(prob.getMaterialConsumptionVolume("product")[0],9.0f) );
     assert( eq(prob.getMaterialProductionVolume("product")[0] ,9.0f) );


     assert( eq(prob.getDemandShipVol("product", "sales")[1],10.0f) );
     assert( eq(prob.getCapacityConsumptionVolume("capacity")[1],10.0f) );
     assert( eq(prob.getMaterialConsumptionVolume("product")[1],10.0f) );
     assert( eq(prob.getMaterialProductionVolume("product")[1] ,10.0f) );
     
     double objValue = prob.getEccObjValue();
     assert( eq(objValue,19.0f) );

  }  //end of "simple problem. Single capacity, product, & demand. 2 periods."

    
  // 2 products with demand from 1 capacity. 1 period.
  {
     ECCovptProblem prob;
     prob.setNPeriods(1);
     prob.addCapacity("capacity");
     prob.addMaterial("p1");
     prob.addMaterial("p2");
     prob.addOperation("make p1");
     prob.addOperation("make p2");
     prob.addConsumptionArc("make p1","capacity");
     prob.addConsumptionArc("make p2","capacity");
     prob.addProductionArc("make p1","p1");
     prob.addProductionArc("make p2","p2");
     prob.addDemand("p1","sales");
     prob.addDemand("p2","sales");

     // Set attributes
     prob.setCapacitySupply( "capacity", 0, 20.f );
     prob.setConsumptionArcConsumptionRate("make p1","capacity",0,1.0f);
     prob.setConsumptionArcConsumptionRate("make p2","capacity",0,1.0f);
     prob.setProductionArcProductionRate("make p1","p1",0,1.0f);
     prob.setProductionArcProductionRate("make p2","p2",0,1.0f);
     prob.setDemandDemandVol("p1", "sales", 0, 10.0f );
     prob.setDemandDemandVol("p2", "sales", 0, 10.0f );
     prob.setDemandContribution("p1", "sales", 0, 1.0f );
     prob.setDemandContribution("p2", "sales", 0, 2.0f );


     prob.solve();
     assert(prob.isSolutionOK());

     // There is enough capacity to meet all demand
     assert( eq(prob.getDemandShipVol("p1", "sales")[0],10.f) );
     assert( eq(prob.getDemandShipVol("p2", "sales")[0],10.f) );
     assert( eq(prob.getCapacityConsumptionVolume("capacity")[0],20.0f) );
     assert( eq(prob.getMaterialConsumptionVolume("p1")[0],10.0f) );
     assert( eq(prob.getMaterialConsumptionVolume("p2")[0],10.0f) );
     assert( eq(prob.getMaterialProductionVolume("p1")[0] ,10.0f) );
     assert( eq(prob.getMaterialProductionVolume("p2")[0] ,10.0f) );

     double objValue = prob.getEccObjValue();
     assert( eq(objValue,30.0f) );

     // Constrain problem so not enough capacity to meet both demands.
     // Test to ensure that higher contribution demand is satified first
     prob.setCapacitySupply( "capacity", 0, 12.f );
     prob.solve();
     assert(prob.isSolutionOK());
     assert( eq(prob.getDemandShipVol("p1", "sales")[0], 2.f) );
     assert( eq(prob.getDemandShipVol("p2", "sales")[0],10.f) );
     assert( eq(prob.getCapacityConsumptionVolume("capacity")[0],12.0f) );
     assert( eq(prob.getMaterialConsumptionVolume("p1")[0], 2.0f) );
     assert( eq(prob.getMaterialConsumptionVolume("p2")[0],10.0f) );
     assert( eq(prob.getMaterialProductionVolume("p1")[0] , 2.0f) );
     assert( eq(prob.getMaterialProductionVolume("p2")[0] ,10.0f) );
     objValue = prob.getEccObjValue();
     assert( eq(objValue,22.0f) );

     // now set minShipVol on demand with lower contribution.
     // Test to ensure that this demand is met
     prob.setDemandMinShipVol("p1","sales",0,8.0f);
     prob.solve();
     assert(prob.isSolutionOK());
     assert( eq(prob.getDemandShipVol("p1", "sales")[0], 8.f) );
     assert( eq(prob.getDemandShipVol("p2", "sales")[0], 4.f) );
     assert( eq(prob.getCapacityConsumptionVolume("capacity")[0],12.0f) );
     assert( eq(prob.getMaterialConsumptionVolume("p1")[0], 8.0f) );
     assert( eq(prob.getMaterialConsumptionVolume("p2")[0], 4.0f) );
     assert( eq(prob.getMaterialProductionVolume("p1")[0] , 8.0f) );
     assert( eq(prob.getMaterialProductionVolume("p2")[0] , 4.0f) );
     objValue = prob.getEccObjValue();
     assert( eq(objValue,16.0f) );

  }  //end of "2 products with demand from 1 capacity. 1 period."

  // Test that loops work
  {
    ECCovptProblem prob;
    prob.setNPeriods(1);
    prob.addCapacity("cap");
    prob.setCapacitySupply("cap",0,100.f);
    prob.addMaterial("product");
    prob.addMaterial("byProduct");
    prob.addOperation("make product");
    prob.addConsumptionArc("make product","cap");
    prob.setConsumptionArcConsumptionRate("make product","cap",0,1.0f);
    prob.addConsumptionArc("make product","byProduct");
    prob.setConsumptionArcConsumptionRate("make product","byProduct",0,1.f);
    prob.addProductionArc("make product","product");
    prob.setProductionArcProductionRate("make product","product",0,1.0f);
    prob.addProductionArc("make product","byProduct");
    prob.setProductionArcProductionRate("make product","byProduct",0,1.0f);
    prob.addDemand("product","sales");
    prob.setDemandDemandVol("product","sales",0,10.0f);
    prob.setDemandContribution("product","sales",0,1.0f);
    prob.solve();
    assert(prob.isSolutionOK());
    float sv=prob.getDemandShipVol("product","sales")[0];
    assert( eq(sv,10.f) );
  }

  // Test that solution is OK for sample data
  {
    std::vector<std::string> dataDirNames;
 
    dataDirNames.push_back("example1");
    dataDirNames.push_back("example2");
    dataDirNames.push_back("example3");
	dataDirNames.push_back("example4");

    // loop once for each data directory
    int d;
    for ( d=0; d<dataDirNames.size(); ++d ) {
      std::string inputDirectory = "../data/" + dataDirNames[d];
      std::string logFileName = "../data/"+dataDirNames[d]+"/ovptLog.txt";
      ECCovptProblem prob(inputDirectory);
      ECCpopulateProblem(prob, inputDirectory,logFileName).readDirectoryFiles();
      prob.solve();
      assert(prob.isSolutionOK());
    } // end of for d loop
  } // end Test that solution is OK for sample data

}

@


1.52
log
@Theis version works in an Accelerated mode.
@
text
@d1122 14
d1151 1
a1151 1
        retVal+=shipVol[t]*contrib[t];
d1170 1
a1170 1
        retVal+=execVol[t]*contrib[t];
@


1.51
log
@Minor changes to make unitTest read example4 as well.
@
text
@d1083 5
a1087 1
  
d1276 4
d1299 6
@


1.50
log
@Fixed Bob's method for getting rid of unnecessary production.
Modified slightly isSolutionOK() method.
Now it works fine for all test cases.
@
text
@d2188 1
a2188 1
	  dataDirNames.push_back("example3");
d2191 2
@


1.49
log
@changes to restore wit attributes after applying bobs method
@
text
@d1000 1
a1000 1
// Achieve what scrap costs do using Bobn's trick with ExecVol Lo Bounds
d1015 1
a1015 1
  // For all ECC Demands set execVolSLB=shopVol, execCost=1, and obj1ShipReward=0
d1041 1
a1041 1
      wwitSetDemandAttribute(witSetDemandObj1ShipReward,fullDemandName,demandNames[d],0.0f);
d1230 2
a1231 2
    getRidOfUnnecessaryProductionUsingFixedScalingOnScrapCost();
    //getRidOfUnnecessaryProductionBobsWay();
d1242 1
a1242 1
  CoinRelFltEq eq;
@


1.48
log
@Formatting changes. Removed tabs.
No code was changed
@
text
@d24 1
d964 1
a964 1
void ECCovptProblem::setScrapCostsUsingFixedScalingFactor()
d995 1
d1006 3
d1010 4
d1015 1
a1015 1
  // Set Lower bounds on all operations being parts of demands 
d1026 22
a1047 15
      std::string processedDemandName = materialDemandName(materialNames[d],demandNames[d]);
      //for each demand get the actual production of the demanded material
      std::vector<float> operationExecVols;
      operationExecVols = wwitGetNameAttribute(witGetOperationExecVol,processedDemandName);
      //and set soft lower ExecBounds
      std::vector<float> nullVector(operationExecVols.size(), 0);
      std::vector<float> upperVector(operationExecVols.size(), -1);
      setExecBounds(processedDemandName,nullVector,operationExecVols,upperVector);
      //and set obj1ExecCost=1 on all these operation
      std::vector<float> operationObj1ExecCosts(nPeriods, 1);
      wwitSetNameAttribute(witSetOperationObj1ExecCost,processedDemandName,operationObj1ExecCosts);
    }
  } // finished setting Lower Exec Bounds on operations making demanded parts
  
  // Set Lower bounds on all operations with positive contribution
d1055 18
a1072 14
      std::vector<float> operationExecVols, operationObj1ExecCosts;
      operationObj1ExecCosts = wwitGetNameAttribute(witGetOperationObj1ExecCost,operationNames[o]);
      operationExecVols = wwitGetNameAttribute(witGetOperationExecVol,operationNames[o]);
  		  unsigned int i;
        //we set lower bound only on these operations, which have positive contribution, 
        //and we put zero lower bound on the periods with nonnegative obj1ExecCost
        bool positiveContribution = false;
        for (i=0; i<operationExecVols.size(); i++)
        {
          if (operationObj1ExecCosts[i]>=0){ 
            operationExecVols[i]=0;
          } else {
            positiveContribution = true;
          }
a1073 21
        std::vector<float> nullVector(operationExecVols.size(), 0);
        std::vector<float> upperVector(operationExecVols.size(), -1);
        if (positiveContribution) setExecBounds(operationNames[o],nullVector,operationExecVols,upperVector);
    }
  }
  
  // we set obj1ShipReward for all the demands equal to 0
  {
    std::vector<std::string> demandNames;
    std::vector<std::string> materialNames;
    
    getDemandNames(materialNames,demandNames);
    // loop once for each demand
    unsigned int d;
    for ( d=0; d<demandNames.size(); ++d ) {
      std::string fullDemandName = materialDemandName(materialNames[d],demandNames[d]);
      //loop once for each period
      int period;
      for (period = 0; period < nPeriods; period++)
      {
        wwitSetDemandAttribute(witGetDemandObj1ShipReward,witSetDemandObj1ShipReward,fullDemandName,demandNames[d],period,0);
d1075 8
a1082 2
    }  
  }
d1084 3
a1086 1
  // Set ob1ExecCost = 1 for all operations
d1088 16
a1103 8
    std::vector<std::string> operationNames;
    getOperationNames(operationNames);
    
    // loop once for each operation
    unsigned int o;
    for ( o=0; o<operationNames.size(); o++ ) {
      std::vector<float> operationObj1ExecCosts(nPeriods, 1);
      wwitSetNameAttribute(witSetOperationObj1ExecCost,operationNames[o],operationObj1ExecCosts);
d1106 2
d1228 6
a1233 9
  if (unnecessaryProduction()) {
    // Set scrapCosts to ensure that parts are not being produced when not needed
    {
      setScrapCostsUsingFixedScalingFactor();
      //getRidOfUnnecessaryProductionBobsWay();
    } // finished setting scrapVol
    // solve with scrapVols set
    witOptImplode(witRun());
  }
d2188 1
a2190 1
	dataDirNames.push_back("example3");
@


1.47
log
@Minor changes.
@
text
@d959 9
a967 5
  //-------------------------------------------------------------------------------------------------
  //Set scrap costs using arbitrary fixed scaling factor, not taking into account the number of parts
  //that appear or might appear in the model. This method is used by solve().
  //-------------------------------------------------------------------------------------------------
  void ECCovptProblem::setScrapCostsUsingFixedScalingFactor()
d969 27
a995 1
	   const double scaleFactor=1.0e-6;
d997 56
a1052 13
      // Set scrap vols on demanded parts
      {
        // Get list of all demands
        std::vector<std::string> demandNames;
        std::vector<std::string> materialNames;
        getDemandNames(materialNames,demandNames);
        
        // loop once for each demand
        unsigned int d;
        for ( d=0; d<demandNames.size(); ++d ) {
          std::string fullDemandName = materialDemandName(materialNames[d],demandNames[d]);
          float scrapCost = fabs(objValueWithNoScrapCosts_*scaleFactor);
          wwitSetNameAttribute(witSetPartObj1ScrapCost,fullDemandName,scrapCost);
d1054 4
a1057 14
      } // finished setting scrapVol on demanded parts

      // Set scrapCosts on materials
      {
        std::vector<std::string> materialNames;
        getMaterialNames(materialNames);
        // loop once for each material
        unsigned int m;
        for ( m=0; m<materialNames.size(); ++m ) {
          float scrapCost = fabs(objValueWithNoScrapCosts_*scaleFactor);
          wwitSetNameAttribute(witSetPartObj1ScrapCost,materialNames[m],scrapCost);
        }
      } // finished setting scrapVol on materials

d1059 14
a1072 11

  //-------------------------------------------------------------------------------------------------
  // Achieve what scrap costs do using Bobn's trick with ExecVol Lo Bounds
  //-------------------------------------------------------------------------------------------------
  void ECCovptProblem::getRidOfUnnecessaryProductionBobsWay()
  {
	  //Add checking if WIT is in post-processed state!! 
	  
	  int nPeriods = getNPeriods();

      // Set Lower bounds on all operations being parts of demands 
d1074 1
a1074 82
        // Get list of all demands
        std::vector<std::string> demandNames;
        std::vector<std::string> materialNames;
		        
        getDemandNames(materialNames,demandNames);
	        
        // loop once for each demand
        unsigned int d;
        for ( d=0; d<demandNames.size(); ++d ) {
			std::string processedDemandName = materialDemandName(materialNames[d],demandNames[d]);
			//for each demand get the actual production of the demanded material
			std::vector<float> operationExecVols;
            operationExecVols = wwitGetNameAttribute(witGetOperationExecVol,processedDemandName);
			//and set soft lower ExecBounds
			std::vector<float> nullVector(operationExecVols.size(), 0);
			std::vector<float> upperVector(operationExecVols.size(), -1);
			setExecBounds(processedDemandName,nullVector,operationExecVols,upperVector);
			//and set obj1ExecCost=1 on all these operation
			std::vector<float> operationObj1ExecCosts(nPeriods, 1);
            wwitSetNameAttribute(witSetOperationObj1ExecCost,processedDemandName,operationObj1ExecCosts);
        }
      } // finished setting Lower Exec Bounds on operations making demanded parts

      // Set Lower bounds on all operations with positive contribution
	  {
        std::vector<std::string> operationNames;
        getOperationNames(operationNames);

        // loop once for each operation
        unsigned int o;
        for ( o=0; o<operationNames.size(); o++ ) {
		  std::vector<float> operationExecVols, operationObj1ExecCosts;
          operationObj1ExecCosts = wwitGetNameAttribute(witGetOperationObj1ExecCost,operationNames[o]);
		  operationExecVols = wwitGetNameAttribute(witGetOperationExecVol,operationNames[o]);
  		  unsigned int i;
		  //we set lower bound only on these operations, which have positive contribution, 
		  //and we put zero lower bound on the periods with nonnegative obj1ExecCost
		  bool positiveContribution = false;
		  for (i=0; i<operationExecVols.size(); i++)
		  {
			  if (operationObj1ExecCosts[i]>=0){ 
				  operationExecVols[i]=0;
			  } else {
				  positiveContribution = true;
			  }
		  }
		  std::vector<float> nullVector(operationExecVols.size(), 0);
		  std::vector<float> upperVector(operationExecVols.size(), -1);
		  if (positiveContribution) setExecBounds(operationNames[o],nullVector,operationExecVols,upperVector);
        }
      }

	  // we set obj1ShipReward for all the demands equal to 0
	  {
		std::vector<std::string> demandNames;
        std::vector<std::string> materialNames;
		       
        getDemandNames(materialNames,demandNames);
	  // loop once for each demand
        unsigned int d;
        for ( d=0; d<demandNames.size(); ++d ) {
	      std::string fullDemandName = materialDemandName(materialNames[d],demandNames[d]);
          //loop once for each period
		  int period;
		  for (period = 0; period < nPeriods; period++)
		  {
			  wwitSetDemandAttribute(witGetDemandObj1ShipReward,witSetDemandObj1ShipReward,fullDemandName,demandNames[d],period,0);
		  }
		}  
	  }
	  
	  // Set ob1ExecCost = 1 for all operations
	  {
        std::vector<std::string> operationNames;
        getOperationNames(operationNames);

        // loop once for each operation
        unsigned int o;
        for ( o=0; o<operationNames.size(); o++ ) {
		  std::vector<float> operationObj1ExecCosts(nPeriods, 1);
          wwitSetNameAttribute(witSetOperationObj1ExecCost,operationNames[o],operationObj1ExecCosts);
		}
d1076 14
d1091 1
d1202 1
a1202 1

d1214 2
a1215 2
    setScrapCostsUsingFixedScalingFactor();
	//getRidOfUnnecessaryProductionBobsWay();
d1219 1
a1219 1
    }
@


1.46
log
@Fixed minor problems. The method
getRidOfUnnecessaryProductionBobsWay()
runs, but I dont know if it does what it is supposed to.
It is untested and is not called anywhere in the present code.
I'll check if it works and add test cases tomorrow first thing in the morning.
The code builds and runs.
@
text
@d1025 3
d1037 2
a1038 2
        unsigned int m;
        for ( m=0; m<operationNames.size(); ++m ) {
d1040 2
a1041 2
          operationObj1ExecCosts = wwitGetNameAttribute(witGetOperationObj1ExecCost,operationNames[m]);
		  operationExecVols = wwitGetNameAttribute(witGetOperationExecVol,operationNames[m]);
d1056 1
a1056 1
		  if (positiveContribution) setExecBounds(operationNames[m],nullVector,operationExecVols,upperVector);
d1085 2
a1086 2
        unsigned int m;
        for ( m=0; m<operationNames.size(); ++m ) {
d1088 1
a1088 1
          wwitSetNameAttribute(witSetOperationObj1ExecCost,operationNames[m],operationObj1ExecCosts);
@


1.45
log
@1. Separated the part setting scrap costs as a method
setScrapCostsUsingFixedScalingFactor()

2. Added a method
getRidOfUnnecessaryProductionBobsWay()
The last method is untested and is not called anywhere.
I'll check if it runs and add test cases tomorrow first thing in the morning.
The code builds and runs.
@
text
@d1011 1
a1011 2
		
        
d1013 1
a1013 2
	
        
d1023 2
a1024 1
			setExecBounds(processedDemandName,nullVector,operationExecVols,nullVector);
d1052 2
a1053 1
		  if (positiveContribution) setExecBounds(operationNames[m],nullVector,operationExecVols,nullVector);
d1212 1
@


1.44
log
@Minor improvements & bugfixes.
@
text
@d956 72
d1029 60
a1208 1

d1211 1
a1211 29
      const double scaleFactor=1.0e-6;

      // Set scrap vols on demanded parts
      {
        // Get list of all demands
        std::vector<std::string> demandNames;
        std::vector<std::string> materialNames;
        getDemandNames(materialNames,demandNames);
        
        // loop once for each demand
        unsigned int d;
        for ( d=0; d<demandNames.size(); ++d ) {
          std::string fullDemandName = materialDemandName(materialNames[d],demandNames[d]);
          float scrapCost = fabs(objValueWithNoScrapCosts_*scaleFactor);
          wwitSetNameAttribute(witSetPartObj1ScrapCost,fullDemandName,scrapCost);
        }
      } // finished setting scrapVol on demanded parts

      // Set scrapCosts on materials
      {
        std::vector<std::string> materialNames;
        getMaterialNames(materialNames);
        // loop once for each material
        unsigned int m;
        for ( m=0; m<materialNames.size(); ++m ) {
          float scrapCost = fabs(objValueWithNoScrapCosts_*scaleFactor);
          wwitSetNameAttribute(witSetPartObj1ScrapCost,materialNames[m],scrapCost);
        }
      } // finished setting scrapVol on materials
a1212 1
    
d1215 1
a1215 3
    
  }
  
d1219 1
a1219 1
// - there is no unnecessary production
@


1.43
log
@Added tests for orphan operation
and minor bugfixes
@
text
@d2072 1
a2072 1
	//dataDirNames.push_back("example3");
@


1.42
log
@Added tests for orphan materials and orphan capacities
with test cases.
@
text
@d605 1
d608 1
d612 2
d619 1
a619 1
		  for (j=0; j<materialNames.size(); j++)
d621 1
a621 1
			  foundC = (foundC || consumptionArcExists(operationNames[i], materialNames[j]) );
d1799 1
a1799 1
    assert( operationOrphanNames.size()==1 );
@


1.41
log
@Minor changes
@
text
@d597 4
a600 1
  
a604 1
	  std::vector<std::string> resourceNames;
a606 1
	  getCapacityNames(resourceNames);
a609 4
	  for (i=0; i<materialNames.size(); i++)
	  {
		  resourceNames.push_back(materialNames[i]);
      }
d611 1
a611 1
	  bool found;
d614 7
a620 2
		  found=false;
		  for (j=0; j<resourceNames.size(); j++)
d622 1
a622 1
			  found = (found || consumptionArcExists(operationNames[i], resourceNames[j]) || productionArcExists(operationNames[i], resourceNames[j]) );
d624 1
a624 1
		  if (!found) operationOrphanNames.push_back(operationNames[i]);
d1747 5
a1778 2
	prob.addOperation("o3");
	prob.addOperation("o4");
d1781 2
a1782 2
    assert(  operationOrphanNames.size()==4 );
	assert(  (operationOrphanNames[0]=="o1") || (operationOrphanNames[1]=="o1") || (operationOrphanNames[2]=="o1") || (operationOrphanNames[3]=="o1") );
d1789 1
a1789 1
	assert( operationOrphanNames[0]=="o3" || operationOrphanNames[1]=="o3");
d1791 2
a1792 2
	prob.addProductionArc("o3","m2");
    prob.addProductionArc("o4","c2");
d1795 1
a1795 1
    assert( operationOrphanNames.size()==0 );
@


1.40
log
@Added code to write a report describing the input model
@
text
@d592 1
a592 1
			  found = (found || consumptionArcExists(operationNames[j], capacityNames[i]) || productionArcExists(operationNames[j], capacityNames[i]) );
@


1.39
log
@all three getOrphan... methods have been added and tested.
@
text
@d200 6
a205 1
  return wwitOperationExists(operationName);
d704 201
@


1.38
log
@add example3 directory to test
@
text
@d574 17
d595 24
d620 1
a620 1

d1475 9
a1483 1
	
a1490 1
    prob.addOperation("o1");  
d1503 83
d1857 1
a1857 1
	dataDirNames.push_back("example3");
@


1.37
log
@Added getMaterialOrphanNames and created test cases for it.
Builds and runs fine.
@
text
@d1726 1
@


1.36
log
@Error message text for nonxisting consumptionArc updated.
Declarations with empty definitions of 3 methods added.
@
text
@d552 18
d1422 34
a1538 1
      
@


1.35
log
@added assert and comment
@
text
@d548 13
@


1.34
log
@added methods and testcases to test that solution has some required properties
@
text
@d409 1
@


1.33
log
@updated setting material scapCost
@
text
@d788 1
a788 1
  float objValueWithNoScrapCosts_ = getEccObjValue();
a828 4
    bool unProd = unnecessaryProduction();
    float objVal2 = getEccObjValue();
    assert( eq(objValueWithNoScrapCosts_,objVal2) );
    assert( !unProd );   
d833 20
d1252 1
a1252 1
    
d1494 1
d1536 1
d1584 1
d1602 1
d1617 1
d1651 1
d1656 1
a1656 1
  // Test reading example2 
d1658 16
a1673 6
    std::string inputDirectory = "../data/example2";
    std::string logFileName = "../data/example2/ovptLog.txt";
    ECCovptProblem prob(inputDirectory);
    ECCpopulateProblem(prob, inputDirectory,logFileName).readDirectoryFiles();
    prob.solve();
  }
@


1.32
log
@added methods to get objective value when there is not scrap cost
@
text
@d793 1
a793 1
    // Set scrapVols to ensure that parts are not being produced when not needed
d813 1
a813 1
      // Set scrap vols on materials
d820 2
a821 1
          std::vector<float> scrapVol= wwitGetNameAttribute(witGetPartScrapVol,materialNames[m]);
@


1.31
log
@added code to write output files.
added code to set scrapVol
@
text
@d10 1
d628 3
a631 1

d661 9
d677 1
a677 1
double ECCovptProblem::getObjValue() const
d782 3
d786 1
a786 1
  // solve to get magnitude of solution
d788 1
d790 1
a791 1
    float objVal1 = getObjValue();
d808 2
a809 1
          wwitSetNameAttribute(witSetPartObj1ScrapCost,fullDemandName,fabs(objVal1*scaleFactor));
d829 2
a830 2
    float objVal2 = getObjValue();
    assert( eq(objVal1,objVal2) );
d841 1
d860 1
d885 1
d911 2
a912 1
  outputDirectory_ = source.outputDirectory_; 
d1486 1
a1486 1
     double objValue = prob.getObjValue();
d1530 1
a1530 1
     double objValue = prob.getObjValue();
d1575 1
a1575 1
     double objValue = prob.getObjValue();
d1589 1
a1589 1
     objValue = prob.getObjValue();
d1603 1
a1603 1
     objValue = prob.getObjValue();
@


1.30
log
@modified to have 3 logfiles: osl, wit, ovpt
@
text
@d13 1
d73 4
d85 9
d141 6
a146 1
 //----------------------
d201 5
a205 1

d220 1
a220 1
  // connect demand to just created part
d231 6
d254 1
d256 1
d564 5
d661 103
d769 3
d773 44
d1611 9
@


1.29
log
@Changes to have a witLog and oslLog file written to output directory.
@
text
@d1188 1
d1191 1
a1191 1
    ECCpopulateProblem(prob, inputDirectory,prob.getWitMesgFilePtr()).readDirectoryFiles();
@


1.28
log
@Modified so populate method is now a class
@
text
@d637 19
d679 1
d705 1
a1186 1
    ECCovptProblem prob;
d1188 1
d1190 1
a1190 1
    ECCpopulateProblem(prob, inputDirectory).readDirectoryFiles();
@


1.27
log
@populate updated to read substitutionMaterials
@
text
@d1169 1
a1169 1
    populate(prob, inputDirectory);
@


1.26
log
@populate updated to read demands
@
text
@d1224 3
@


1.25
log
@populate updated to read production arcs
@
text
@d1216 8
@


1.24
log
@added code to test populating of consumption arcs.
setting expAllowed to false.
@
text
@d1210 6
@


1.23
log
@Cosmetic changes to presolve (removed unused variables).
@
text
@d471 3
d1204 6
d1360 1
d1362 24
a1385 1
  }  //end of "2 products with demand from 1 capacity. 1 period."
@


1.22
log
@Erased one line, that was not necessary.
@
text
@d592 1
a592 1
  // create the list of all operations and a list of all parts and a list of all subsArcs
d600 1
a600 4
  int i, period,Periods = getNPeriods();
  std::string activeSubstitutionArcName, activeOperationName, activeConsumedResourceName, activeSubstituteConsumedResourceName;
  int activeBomEntryIndex;
  std::vector<float> activeBomConsumptionRates;
d602 15
a616 15
  //Here I copy all consRates from bomArcs to subsBomArcs
  for (i=0; i<nSubsArcs; i++)
  {
    activeSubstitutionArcName = substituteConsumedResourceNames[i]; 
    activeOperationName =  operationNames[i];
    activeConsumedResourceName = consumedResourceNames[i];
    activeSubstituteConsumedResourceName = substituteConsumedResourceNames[i];
    
    activeBomEntryIndex = getBomEntryIndex( activeOperationName,activeConsumedResourceName);
    activeBomConsumptionRates = getConsumptionArcConsumptionRate(activeOperationName, activeConsumedResourceName);
    
    for (period=0; period < Periods; period++)
    {
        setSubstitutionArcConsumptionRate(activeOperationName, activeConsumedResourceName, 
        activeSubstituteConsumedResourceName, period, activeBomConsumptionRates[period] );
d986 1
a986 1

d993 4
a996 4


	//test presolve method

d1002 1
a1002 1

d1004 2
a1005 2

	cr = prob.getSubstitutionArcConsumptionRate("o2","m1","s1");
d1011 2
a1012 2

	cr = prob.getSubstitutionArcConsumptionRate("o1","m1","s2");
d1018 1
a1018 3

	

@


1.21
log
@Changed indentation, changed tabs to spaces for readability.
Changed set/getConsumptionArcConsumptionRate to be private methods.
@
text
@d618 1
a618 2
      int temp = activeBomConsumptionRates[period];
      setSubstitutionArcConsumptionRate(activeOperationName, activeConsumedResourceName, 
@


1.20
log
@Private presolve() method has been added and test cases for it
have been added in the section where we test substitution arcs.
Minor bugfixes ("Consumpiton" -> "Consumption")
@
text
@d592 31
a622 31
	// create the list of all operations and a list of all parts and a list of all subsArcs
	std::vector<std::string>  operationNames;
    std::vector<std::string>  consumedResourceNames; 
	std::vector<std::string>  substituteConsumedResourceNames;

	getSubstitutionArcNames(operationNames, consumedResourceNames, substituteConsumedResourceNames );
    int nSubsArcs =  substituteConsumedResourceNames.size();

	int i, period,Periods = getNPeriods();
	std::string activeSubstitutionArcName, activeOperationName, activeConsumedResourceName, activeSubstituteConsumedResourceName;
	int activeBomEntryIndex;
	std::vector<float> activeBomConsumptionRates;

	//Here I copy all consRates from bomArcs to subsBomArcs
	for (i=0; i<nSubsArcs; i++)
	{
      activeSubstitutionArcName = substituteConsumedResourceNames[i]; 
      activeOperationName =  operationNames[i];
      activeConsumedResourceName = consumedResourceNames[i];
	  activeSubstituteConsumedResourceName = substituteConsumedResourceNames[i];

	  activeBomEntryIndex = getBomEntryIndex( activeOperationName,activeConsumedResourceName);
	  activeBomConsumptionRates = getConsumptionArcConsumptionRate(activeOperationName, activeConsumedResourceName);

      for (period=0; period < Periods; period++)
	  {
		  int temp = activeBomConsumptionRates[period];
		  setSubstitutionArcConsumptionRate(activeOperationName, activeConsumedResourceName, 
			  activeSubstituteConsumedResourceName, period, activeBomConsumptionRates[period] );
	  }
	}
@


1.19
log
@Added test cases for getSubBomEntryIndex method.
@
text
@d315 1
a315 1
void ECCovptProblem::setConsumpitonArcConsumptionRate(
d556 1
a556 1
std::string ECCovptProblem::operationFromSubstitutionArcName(const std::string & consumptionArcName )
d558 1
a558 1
  return textBetween(consumptionArcName,"Operation: "," consumes resource: ");
d560 1
a560 1
std::string ECCovptProblem::consumedResourceFromSubstitutionArcName(const std::string & consumptionArcName )
d562 1
a562 1
  return textBetween(consumptionArcName," consumes resource: "," with a substitute: ");
d564 1
a564 1
std::string ECCovptProblem::substituteConsumedResourceFromSubstitutionArcName(const std::string & consumptionArcName )
d566 1
a566 1
  return textAfter(consumptionArcName," with a substitute: ");
d586 39
d881 5
a885 5
    prob.setConsumpitonArcConsumptionRate("o2","r1",0,1.f);
    prob.setConsumpitonArcConsumptionRate("o2","r1",1,2.f);
    prob.setConsumpitonArcConsumptionRate("o2","r1",2,3.f);
    prob.setConsumpitonArcConsumptionRate("o2","r1",3,4.f);
    prob.setConsumpitonArcConsumptionRate("o2","r1",4,5.f);
d991 34
d1222 1
a1222 1
     prob.setConsumpitonArcConsumptionRate("make product","raw",0,1.0f);
d1256 1
a1256 1
     prob.setConsumpitonArcConsumptionRate("make product","capacity",0,1.0f);
d1263 1
a1263 1
     prob.setConsumpitonArcConsumptionRate("make product","capacity",1,1.0f);
d1305 2
a1306 2
     prob.setConsumpitonArcConsumptionRate("make p1","capacity",0,1.0f);
     prob.setConsumpitonArcConsumptionRate("make p2","capacity",0,1.0f);
@


1.18
log
@modified some subArc code
@
text
@d855 24
d953 2
a954 3


  // Production Arc Test
@


1.17
log
@Substitution Arc methods have been added.
Test cases for Substitution Arc methods have been added, all runs fine.
@
text
@a392 1

d394 5
a398 5
                                                      const std::string & operationName, 
                                                      const std::string & consumedResourceName,
													  const std::string & substituteConsumedResourceName,
                                                      int period, 
                                                      float consumptionRate )
d400 1
a400 1
  assert(consumptionArcExists(operationName,consumedResourceName));
d402 1
a402 1
  int sbei = getSubBomEntryIndex(operationName,substituteConsumedResourceName,bei);
d411 1
a411 1
  assert(consumptionArcExists(operationName,consumedResourceName));
d413 1
a413 1
  int sbei = getSubBomEntryIndex(operationName,substituteConsumedResourceName,bei);
d858 1
a858 1

d860 1
a860 1

d864 3
a866 2
	prob.addCapacity("s1");
    assert( !prob.substitutionArcExists("o1","m1","s1") );
d868 1
a868 1
	prob.addSubstitutionArc("o1","m1","s1");
d870 2
a871 1

d874 1
a874 1

d876 1
a876 1
	prob.addMaterial("s2");
d878 1
d880 6
a885 5

	prob.addSubstitutionArc("o1","m2","s1");
	prob.addSubstitutionArc("o2","m1","s1");
	prob.addSubstitutionArc("o2","m2","s1");

d887 4
a890 4
	prob.addSubstitutionArc("o1","m2","s2");
	prob.addSubstitutionArc("o2","m1","s2");
	prob.addSubstitutionArc("o2","m2","s2");

d892 3
a894 1
	assert( prob.substitutionArcExists("o1","m2","s1") );
d896 4
a899 2
	assert( prob.substitutionArcExists("o2","m2","s1") );

d901 3
a903 1
	assert( prob.substitutionArcExists("o1","m2","s2") );
d905 4
a908 2
	assert( prob.substitutionArcExists("o2","m2","s2") );

d915 1
a915 1

d927 1
@


1.16
log
@added test of setDemandMinShipVol
@
text
@d360 89
d548 21
d605 1
d628 1
d652 2
a653 1
  consumptionArcNames_ = source.consumptionArcNames_; 
d856 63
@


1.15
log
@added following methods: solve,getMaterialConsumptionVolume,getMaterialProductionVolume,getCapacityConsumptionVolume,getDemandShipVol
@
text
@d1001 74
@


1.14
log
@implemented setDemandMinShipVol and getDemandMinShipVol
@
text
@d63 18
d122 5
d280 5
d477 9
d925 32
d959 42
d1002 1
@


1.13
log
@populate function updated to add read operation file
@
text
@a167 7
#if 0
  if ( !materialExists(material) ) 
  {
	  std::cerr<<"Material "<< material << " does not exist, I cannot create the demand: "<< material << ", " << demandName <<" !" <<std::endl; 
	  exit(1);
  }
#endif
d171 14
a184 1
  witAddDemand(witRun(),material.c_str(),demandName.c_str()); 
a189 1
#if 0
d191 1
a191 1
  std::string fullDemandName = material+"zAmowienie"+demandName;
a196 3
#else
  return wwitGetDemandExists(material,demandName);
#endif
d201 2
a202 1
  wwitSetDemandAttribute(witGetDemandDemandVol,witSetDemandDemandVol,material,demandName,period,demVol);
d207 2
a208 1
  return wwitGetDemandAttribute(witGetDemandDemandVol,material,demandName);
d213 2
a214 1
  wwitSetDemandAttribute(witGetDemandObj1ShipReward,witSetDemandObj1ShipReward,material,demandName,period,contribution);
d219 23
a241 1
  return wwitGetDemandAttribute(witGetDemandObj1ShipReward,material,demandName);
d756 1
a756 1

d759 1
a759 1
	prob.addMaterial("DullYarn");
d762 1
a762 1
	prob.addMaterial("WeakAceticAcid");
d765 1
a765 1
	assert(  prob.demandExists("DullYarn","d1") );
d768 2
a769 2
   
	//test demVol methods
d781 2
a782 2

	//test contribution methods
d794 15
a808 3

   
	
@


1.12
log
@populate function updated to add read capacity file
@
text
@d834 13
@


1.11
log
@added methods to class ECCovptProblem to add productionArcs and get and set their input attributes
@
text
@d821 14
@


1.10
log
@Changed methods in problemBase that began with characters wit, to now beging with characters wwit (wrap wit).
@
text
@d304 66
d404 16
d430 2
a431 1
consumptionArcNames_()
d452 2
a453 1
consumptionArcNames_()
d477 1
d677 33
a709 1
  }
d711 12
@


1.9
log
@Added methods for consumptionArcs
@
text
@d45 1
a45 1
  witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,materialName,period,supply);
d50 1
a50 1
  return witGetNameAttribute(witGetPartSupplyVol,materialName);
d85 1
a85 1
  witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,capacityName,period,supply);
d90 1
a90 1
  return witGetNameAttribute(witGetPartSupplyVol,capacityName);
d115 1
a115 1
  witSetNameAttribute(witGetOperationObj1ExecCost,witSetOperationObj1ExecCost,operationName,period,-contrib);
d120 1
a120 1
  std::vector<float> retVal = witGetNameAttribute(witGetOperationObj1ExecCost, operationName );
d132 1
a132 1
  witGetNameBoundAttribute(witGetOperationExecBounds,operationName,hlb,slb,hub);
d134 1
a134 1
  witSetNameBoundAttribute(witSetOperationExecBounds,operationName, hlb,slb,hub);
d141 1
a141 1
  witGetNameBoundAttribute(witGetOperationExecBounds,operationName, hlb,slb,hub);
d157 1
a157 1
  return witOperationExists(operationName);
d193 1
a193 1
  return witGetDemandExists(material,demandName);
d199 1
a199 1
  witSetDemandAttribute(witGetDemandDemandVol,witSetDemandDemandVol,material,demandName,period,demVol);
d204 1
a204 1
  return witGetDemandAttribute(witGetDemandDemandVol,material,demandName);
d209 1
a209 1
  witSetDemandAttribute(witGetDemandObj1ShipReward,witSetDemandObj1ShipReward,material,demandName,period,contribution);
d214 1
a214 1
  return witGetDemandAttribute(witGetDemandObj1ShipReward,material,demandName);
d238 1
a238 1
  assert(witPartExists(consumedResourceName));
d253 1
a253 1
  witSetArcAttribute(witSetBomEntryConsRate,operationName,nBomEntries,zeroTv);
d268 1
a268 1
  witSetArcAttribute(witGetBomEntryConsRate,witSetBomEntryConsRate,operationName,bei,period,consumptionRate);
d276 1
a276 1
  return witGetArcAttribute(witGetBomEntryConsRate,operationName,bei);
@


1.8
log
@Added tests to see if populate functions is reading material correctly
@
text
@d160 3
a162 3
  //----------------------
  // Methods for demands.
  //----------------------
d219 1
a219 1
 {
d230 74
d322 16
d345 4
a348 1
operationNames_()
d366 4
a369 1
operationNames_()
d388 5
a392 2
  materialNames_ = source.materialNames_;  
  operationNames_ = source.operationNames_;  
d460 1
a460 1
  }
d498 1
a498 1
  }
d547 49
a595 1
    // Test demand methods
d657 2
a658 3
    
	
  }
d678 1
a678 1
  // Test reading example1
@


1.7
log
@Added method to getDemandNames.
A few other cosmetic changes. (Made method names consistent with wit).
@
text
@d540 2
d543 3
@


1.6
log
@Some methods for Demands have been added.
There are methods for all the attributes except for
the minShipVol, which I don't think I understand well.
All new methods have their test cases.
@
text
@d168 1
d174 3
a176 1
  std::string fullDemandName = material+"zAmowienie"+demandName;
d179 1
a179 1
  demandNames_.insert(fullDemandName);
d184 1
d188 2
a189 2
  std::set<std::string>::const_iterator it = demandNames_.find(fullDemandName);
  if ( it != demandNames_.end() ) retVal = true;
d192 3
d197 1
a197 1
void ECCovptProblem::setDemandDemVol(const std::string & material, const std::string & demandName, int period, float demVol )
d202 1
a202 1
std::vector<float> ECCovptProblem::getDemandDemVol(const std::string & material, const std::string & demandName)const
d217 2
a218 2
/*
void ECCovptProblem::getCapacityNames( std::vector<std::string> & capacityNames )const
d220 2
a221 1
  capacityNames.clear();
d224 3
a226 2
  for ( it=capacityNames_.begin(); it!=capacityNames_.end(); ++it ) {
    capacityNames.push_back( *it );
d229 19
a247 1
*/
d356 5
a360 1
    assert( names[0]=="e2" || names[1]=="e2" );   
d394 5
a398 1
    assert( names[0]=="c2" || names[1]=="c2" );   
d400 1
d467 11
a477 11
    assert( prob.getDemandDemVol("DullYarn","d1").size() == 2 );
    assert( prob.getDemandDemVol("DullYarn","d1")[0] == 0.0f );
    assert( prob.getDemandDemVol("DullYarn","d1")[1] == 0.0f );
    prob.setDemandDemVol("DullYarn","d1",0,1.754f);
    assert( prob.getDemandDemVol("DullYarn","d1").size() == 2 );
    assert( prob.getDemandDemVol("DullYarn","d1")[0] == 1.754f );
    assert( prob.getDemandDemVol("DullYarn","d1")[1] == 0.0f );
    prob.setDemandDemVol("DullYarn","d1",1,2.514f);
    assert( prob.getDemandDemVol("DullYarn","d1").size() == 2 );
    assert( prob.getDemandDemVol("DullYarn","d1")[0] == 1.754f );
    assert( prob.getDemandDemVol("DullYarn","d1")[1] == 2.514f );
d493 19
a511 7
	/*
    std::vector<std::string> names;
    prob.getCapacityNames(names);
    assert( names.size()==2 );
    assert( names[0]=="c1" || names[1]=="c1" );
    assert( names[0]=="c2" || names[1]=="c2" );   
	*/
@


1.5
log
@Implemented 4 capacity methods and added test cases for them.
@
text
@a21 1

d23 1
a23 1
// Methods for engagements.
d160 61
d412 53
a464 1
  
@


1.4
log
@added comments defining capacity method prototypes.
modified the way materialExists method works.
@
text
@a27 1
  
d48 1
a53 2


d64 42
a105 1
//----------------------
d271 6
d278 4
d283 22
@


1.3
log
@updated ovptProblem to implement operation methods
@
text
@d30 1
a30 1
  materialNames_.push_back(materialName);
d35 6
a40 1
  return witPartExists(materialName.c_str());
d60 1
a60 1
  std::vector<std::string>::const_iterator it;
d72 1
a72 1
  operationNames_.push_back(operationName);
d111 1
a111 1
  std::vector<std::string>::const_iterator it;
d119 1
a119 1
  return witOperationExists(operationName.c_str());
@


1.2
log
@Updated so populate uses ovptProblem.
@
text
@d33 1
a33 1
bool ECCovptProblem::materialExists    (const std::string & materialName)const
d61 55
d123 2
a124 1
materialNames_()
d127 3
d141 2
a142 1
materialNames_()
d162 1
d184 1
d189 1
a189 3
    assert( prob.getNPeriods() == 12 );
    
    
d193 1
a193 1

d225 11
a235 1
    assert( names[0]=="e2" || names[1]=="e2" );
d237 2
d240 35
@


1.1
log
@Added skeleton to start
@
text
@a61 3049
#if 0

//----------------------
// Methods for resources.
//----------------------
void ECCovptProblem::addResource(const std::vector<std::string> &resourceAttributeVector)
{
  std::string acquireOp = acquireResourceOperationName(resourceAttributeVector);
  std::string benchRes = benchResourceName(resourceAttributeVector);
  std::string enableOp = enableResourceOperationName(resourceAttributeVector);
  std::string workingRes = workingResourceName(resourceAttributeVector);
  std::string scrapRes = scrapResourceName(resourceAttributeVector);
  std::string enableScrapOp = enableScrapResourceName(resourceAttributeVector);
  
  int np = getNPeriods();
  
  // Add parts and operations
  checkWitRC(witAddOperation(witRun(),acquireOp.c_str()));
  checkWitRC(witAddPart(witRun(),benchRes.c_str(),WitMATERIAL));
  checkWitRC(witAddOperation(witRun(),enableOp.c_str()));
  checkWitRC(witAddPart(witRun(),workingRes.c_str(),WitCAPACITY));
  checkWitRC(witAddOperation(witRun(),scrapRes.c_str()));
  checkWitRC(witAddPart(witRun(),scrapRes.c_str(),WitCAPACITY));
  checkWitRC(witAddOperation(witRun(),enableScrapOp.c_str()));
  
  // Add appData for working resource
  RCPresourceAppData * workingAppData = new RCPresourceAppData(np);
  checkWitRC(witSetPartAppData(witRun(),workingRes.c_str(),workingAppData));
  
  //Set the scrap cost for the working part to a large quantity
  {
    float * scrapCost = floatToFloatStar(1000000.0f);
    checkWitRC(witSetPartObj1ScrapCost(witRun(),workingRes.c_str(),scrapCost));
    delete [] scrapCost;
  }

  //Set the scrap cost for the bench part to a large quantity
  {
    float * scrapCost = floatToFloatStar(1000000.0f);
    checkWitRC(witSetPartObj1ScrapCost(witRun(),benchRes.c_str(),scrapCost));
    delete [] scrapCost;
  }

  
  // connect parts and operations.
  checkWitRC(witAddBopEntry(witRun(),acquireOp.c_str(),benchRes.c_str()));
  //  checkWitRC(witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),0,WitTRUE));
  
  // dpc --- test for MRP
  checkWitRC(witSetBopEntryExpAllowed(witRun(),acquireOp.c_str(),0,WitFALSE));
  
  checkWitRC(witAddBomEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
  checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),workingRes.c_str()));
  //  checkWitRC(witSetBopEntrySelForDel(witRun(),enableOp.c_str(),0,WitTRUE));
  // For MRP calculation and priorityPlan, set expAllowed to false;  doesn't impact optimalPlan
  checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),0,WitFALSE));  
  
  if (np>1){
    checkWitRC(witAddBopEntry(witRun(),enableOp.c_str(),benchRes.c_str()));
    
    float * offsetVec = floatToFloatStar(-1.f);
    checkWitRC(witSetBopEntryOffset(witRun(),enableOp.c_str(),1,offsetVec));
    delete [] offsetVec;
    checkWitRC(witSetBopEntryExpAllowed(witRun(),enableOp.c_str(),1,WitFALSE));
    checkWitRC(witSetBopEntryLatestPeriod(witRun(),enableOp.c_str(),1,np-2));
  }
  
  // connect up the release side of the model
  checkWitRC(witAddBomEntry(witRun(),scrapRes.c_str(),benchRes.c_str()));
  checkWitRC(witAddBomEntry(witRun(),enableScrapOp.c_str(),scrapRes.c_str()));
  checkWitRC(witAddBopEntry(witRun(),enableScrapOp.c_str(),workingRes.c_str()));
  checkWitRC(witSetBopEntryExpAllowed(witRun(),enableScrapOp.c_str(),0,WitFALSE));

  std::string baseName = baseResourceName(resourceAttributeVector);
  resourceNames_.insert(baseName);
  //jobToResourceNames_[jobRole].insert(baseName);
  //skillToResourceNames_[skillSet].insert(baseName);
  //lobToResourceNames_[LOB].insert(baseName);
  //sourceToResourceNames_[source].insert(baseName);
  //locToResourceNames_[locName].insert(baseName);
  for (unsigned int i=0; i<resourceAttributeVector.size(); i++) {
    const std::string & resourceID = getResourceIdentifierNames()[i];
    const std::string & resourceValue = resourceAttributeVector.at(i);
    resourceIdToResourceNames_[resourceID][resourceValue].insert(baseName);
  }
  //resourceIdToResourceNames_["jobRole"][jobRole].insert(baseName);
  //resourceIdToResourceNames_["skillSet"][skillSet].insert(baseName);
  //resourceIdToResourceNames_["LOB"][LOB].insert(baseName);
  //resourceIdToResourceNames_["source"][source].insert(baseName);
  //resourceIdToResourceNames_["locName"][locName].insert(baseName);
}


bool ECCovptProblem::resourceExists(const std::vector<std::string> &resourceAttributeVector)const 
{
  std::string witName = benchResourceName(resourceAttributeVector);
  return witPartExists(witName);
}

// Return list of names.
// returned value names[i][j]
//   where i=[0,numberOfResourceIdentifiers]
//         j=[0,numberOfResources]
void ECCovptProblem::getResourceNames( std::vector<RCPvectorString> & names )const
{
  names.clear();
  
  // loop once for each resource
  std::set<std::string>::const_iterator r;
  for ( r=resourceNames_.begin(); r!=resourceNames_.end(); ++r) {
    
    const std::string & baseName = *r;
    RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
    
    names.push_back( resourceIdValues );
  }
}


const std::vector<std::string> & ECCovptProblem::getResourceIdentifierNames() const
{
  return resourceIdentifierNames_;
}

void ECCovptProblem::addResourceIdentifierName(const std::string & resourceIdentifierName )
{
  int nResIdentNames = resourceNames_.size();
  
  // resource identifier names must be specified before adding resources.
  // make sure this is the case.
  assert( nResIdentNames == 0 );
  
  resourceIdentifierNames_.push_back(resourceIdentifierName);
  mapResourceIdentifierNameToSubsPriority_[resourceIdentifierName]=0;  //setting priority default value to zero
  
}

bool ECCovptProblem::resourceIdentifierNameExists( const std::string & name ) const
{
  return mapResourceIdentifierNameToSubsPriority_.find(name)!=mapResourceIdentifierNameToSubsPriority_.end();
}


void ECCovptProblem::setResourceIdentifierPriority(const std::string & identifierName, int priority )
{
  assert( resourceIdentifierNameExists(identifierName) );
  mapResourceIdentifierNameToSubsPriority_[identifierName]=priority;
}
int ECCovptProblem::getResourceIdentifierPriority(const std::string & identifierName ) const
{
  assert( resourceIdentifierNameExists(identifierName) );
  int retVal = mapResourceIdentifierNameToSubsPriority_.find(identifierName)->second;
  return retVal;
}


std::vector<std::string> ECCovptProblem::getResourceIdentifiersSortedByPriority() const
{
  std::vector<std::string> retVal;

  RCPsortStringIntPairSet sortedSet;
  std::vector<std::string> idNames = getResourceIdentifierNames();

  // Loop through each resourceIdName and create a sorted set
  unsigned int i;
  for ( i=0; i<idNames.size(); ++i ) {
    std::string idName = idNames[i];
    int priority = getResourceIdentifierPriority(idName);
    RCPstringIntPair pair(idName,priority);
    sortedSet.insert(pair);
  }

  // Loop through sorted set and creat return vector
  RCPsortStringIntPairSetConstIter it;
  for ( it=sortedSet.begin(); it!=sortedSet.end(); ++it ) {
    std::string idName = it->first;
    retVal.push_back(idName);
  }

  return retVal;
}



RCPvectorString ECCovptProblem::resourceIdentifierValuesFromResourceName(const std::string &baseResourceName ) const
{
  RCPvectorString retVal;
  for (unsigned int i=0; i<getResourceIdentifierNames().size(); ++i ) {
    std::string value = resourceIdentifierValueFromResourceName(baseResourceName, i);
    retVal.push_back(value);
  }
  return retVal;
}

std::string ECCovptProblem::resourceIdentifierValueFromResourceName(const std::string &resourcename, int which)const
{
  int last = getResourceIdentifierNames().size()-1;
  std::string retVal;
  if (which!=last) {
    std::string thisone = getResourceIdentifierNames()[which];
    thisone = thisone + ": ";
    std::string nextone = getResourceIdentifierNames()[which+1];
    nextone = " " +nextone + ": ";
    retVal = textBetween(resourcename, thisone, nextone);
  }
  else {
    std::string thisone = getResourceIdentifierNames()[which];
    thisone = thisone + ": ";
    retVal = textAfter(resourcename, thisone);
  }
  return retVal;
}


void ECCovptProblem::setResourceSupplyQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float supplyQuantity)
{
    std::string workingRes = workingResourceName(resourceIdentifierValues);
    RCPresourceAppData * appData;
    checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
    appData->setSupplyAppData(period, supplyQuantity);
}




void ECCovptProblem::setResourceMrpQuantity(
                                        const std::vector<std::string> &resourceIdentifierValues,
                                        int period,
                                        float mrpGrossQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setMrpAppData(period, mrpGrossQuantity);
}





void ECCovptProblem::setResourceGapQuantity(
                                        const std::vector<std::string> &resourceIdentifierValues,
                                        int period,
                                        float gapQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setGapAppData(period, gapQuantity);
}




void ECCovptProblem::setResourceGlutQuantity(
                                         const std::vector<std::string> &resourceIdentifierValues,
                                         int period,
                                         float glutQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setGlutAppData(period, glutQuantity);
}



std::vector<float> ECCovptProblem::getResourceGlutQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getGlutAppData());
  
}

std::vector<float> ECCovptProblem::getResourceGapQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getGapAppData());
  
}

#if 0

std::vector<float> ECCovptProblem::getResourceGlutQuantity(
                                                       const std::string & jobRole,
                                                       const std::string & skillSet,
                                                       const std::string & LOB,
                                                       const std::string & source,
                                                       const std::string & locName)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,locName);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getGlutAppData());
  
}

std::vector<float> ECCovptProblem::getResourceGlutQuantity(
                                                       const std::string & jobRole,
                                                       const std::string & skillSet,
                                                       const std::string & LOB,
                                                       const std::string & source,
                                                       const std::string & region,
                                                       const std::string & country,
                                                       const std::string & city,
                                                       const std::string & reportingUnit,
                                                       const std::string & band,
                                                       const std::string & global,
                                                       const std::string & competency,
                                                       const std::string & industry)const
{
  std::string workingRes = workingResourceName(jobRole,skillSet,LOB,source,region,country,city,reportingUnit,band,global,competency,industry);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getGlutAppData());
  
}
#endif


void ECCovptProblem::setResourceWorkingQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float workingQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setWorkingAppData(period, workingQuantity);
}



void ECCovptProblem::setResourceAcquireQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float acquireQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setAcquireAppData(period, acquireQuantity);
}


void ECCovptProblem::setResourceReleaseQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float releaseQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setReleaseAppData(period, releaseQuantity);
}


void ECCovptProblem::setResourceBenchQuantity(const std::vector<std::string> &resourceIdentifierValues, int period, float benchQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),workingRes.c_str(),(void**)&appData));
  appData->setBenchAppData(period, benchQuantity);
}







void ECCovptProblem::setBenchResourceSupplyQuantity(
                                                const std::vector<std::string> &resourceAttributeVector,
                                                int period,
                                                float supplyQuantity)
{
  std::string benchRes = benchResourceName(resourceAttributeVector);
  witSetNameAttribute(
    witGetPartSupplyVol,witSetPartSupplyVol,
    benchRes,
    period, supplyQuantity );
}




std::vector<float> ECCovptProblem::getResourceSupplyQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getSupplyAppData());
}



std::vector<float> ECCovptProblem::getResourceReleaseQuantity(const std::vector<std::string> &resourceIdentifierValues) const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getReleaseAppData());
}


std::vector<float> ECCovptProblem::getResourceMrpQuantity(
                                                      const std::vector<std::string> &resourceAttributeVector)const
{
  std::string workingRes = workingResourceName(resourceAttributeVector);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getMrpAppData());
  
}

std::vector<float> ECCovptProblem::getResourceBenchQuantity(
                                                        const std::vector<std::string> &resourceAttributeVector)const
{
  std::string workingRes = workingResourceName(resourceAttributeVector);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getBenchAppData());
}



std::vector<float> ECCovptProblem::getResourceAcquireQuantity(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getAcquireAppData());
}


std::vector<float> ECCovptProblem::getResourceWorkingQuantity(
                                                          const std::vector<std::string> &resourceIdentifierValues )const 
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  RCPresourceAppData * appData;
  checkWitRC(witGetPartAppData(mutableWitRun(),workingRes.c_str(),(void**)&appData));
  return(appData->getWorkingAppData());
}
std::vector<float> ECCovptProblem::getOptimalWorkingQuantity(
                                                         const std::vector<std::string> &resourceIdentifierValues )const 
{
  std::string opName = enableResourceOperationName(resourceIdentifierValues);
  return witGetNameAttribute(witGetOperationExecVol,opName);
}

std::vector<float> ECCovptProblem::getOptimalBenchQuantity(const std::vector<std::string> &resourceIdentifierValues) const
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  return witGetNameAttribute(witGetPartStockVol,benchRes);
}


void ECCovptProblem::setResourceAcquireCost(
                                        const std::vector<std::string> &resourceIdentifierValues,
                                        float acquireCost)
{
  std::string acquireOp = acquireResourceOperationName(resourceIdentifierValues);
  float * acv = floatToFloatStar(acquireCost);
  checkWitRC(witSetOperationObj1ExecCost(witRun(),acquireOp.c_str(),acv));
  delete [] acv;
}


void ECCovptProblem::setResourceAcquireTime(const std::vector<std::string> &resourceIdentifierValues, float acquireTime)
{
  std::string acquireOp = acquireResourceOperationName(resourceIdentifierValues);
  float invacquireTime = -acquireTime; //offset should be negative so that
  //the resource is available after it's acquired
  float * atv = floatToFloatStar(invacquireTime);
  checkWitRC(witSetBopEntryOffset(witRun(),acquireOp.c_str(),0,atv));
  delete [] atv;
}


void ECCovptProblem::setResourceReleaseTime(const std::vector<std::string>&resourceIdentifierValues, float releaseTime)
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);
  float * rtv = floatToFloatStar(releaseTime);
  checkWitRC(witSetBomEntryOffset(mutableWitRun(),scrapRes.c_str(),0,rtv));
  delete [] rtv;
}


void ECCovptProblem::setResourceReleaseCost(const std::vector<std::string> &resourceIdentifierValues, float releaseCost)
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues); 
  float * rcv = floatToFloatStar(releaseCost);
  checkWitRC(witSetOperationObj1ExecCost(witRun(),scrapRes.c_str(),rcv));
  delete [] rcv;
}




std::vector<float> ECCovptProblem::getResourceFixedCost(const std::vector<std::string> &resourceIdentifierValues) const
{
  std::string benchRes = benchResourceName(resourceIdentifierValues);
  return witGetNameAttribute(witGetPartObj1StockCost,benchRes);
}



void ECCovptProblem::setResourceFixedCost(
                                      const std::vector<std::string> &resourceIdentifierValues,
                                      int   period,
                                      float fixedCost)
{
  std::string benchOp = benchResourceName(resourceIdentifierValues);
  std::string enableOp = enableResourceOperationName(resourceIdentifierValues);
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);  
  std::string enableScrapOp = enableScrapResourceName(resourceIdentifierValues);
  float * stockcost;
  checkWitRC(witGetPartObj1StockCost(witRun(), benchOp.c_str(), &stockcost));
  stockcost[period] = fixedCost;
  checkWitRC(witSetPartObj1StockCost(witRun(),benchOp.c_str(),stockcost));
  checkWitRC(witSetOperationObj1ExecCost(witRun(),enableOp.c_str(),stockcost));
  checkWitRC(witSetPartObj1ScrapCost(witRun(),scrapRes.c_str(),stockcost));
  checkWitRC(witSetOperationObj1ExecCost(witRun(),enableScrapOp.c_str(),stockcost));

  checkWitRC(witFree(stockcost));
}



float ECCovptProblem::getResourceAcquireCost(const std::vector<std::string> & resourceIdentifierValues) const
{
  std::string acquireOp = acquireResourceOperationName(resourceIdentifierValues);
  float * acv;
  checkWitRC(witGetOperationObj1ExecCost(mutableWitRun(),acquireOp.c_str(),&acv));
  float returnVal = acv[0];
  checkWitRC(witFree(acv));
  return returnVal;
}



float ECCovptProblem::getResourceAcquireTime(const std::vector<std::string> & resourceIdentifierValues) const
{
  std::string acquireOp = acquireResourceOperationName(resourceIdentifierValues);
  float * atv;
  checkWitRC(witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&atv));
  float returnVal = atv[0];
  checkWitRC(witFree(atv));
  return returnVal;
}


float ECCovptProblem::getResourceReleaseCost(const std::vector<std::string> & resourceIdentifierValues) const
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);
  float * rcv;
  checkWitRC(witGetOperationObj1ExecCost(mutableWitRun(),scrapRes.c_str(),&rcv));
  float returnVal = rcv[0];
  checkWitRC(witFree(rcv));
  return returnVal;
}



float ECCovptProblem::getResourceReleaseTime(const std::vector<std::string> & resourceIdentifierValues) const
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);
  float * rtv;
  checkWitRC(witGetBomEntryOffset(mutableWitRun(),scrapRes.c_str(),0,&rtv));
  float returnVal = rtv[0];
  checkWitRC(witFree(rtv));
  return returnVal;
} 

std::vector<float> ECCovptProblem::getDemandShipReward(const std::string & engName)const
{
  std::string witDemandName = engagementName(engName);
  return witGetDemandAttribute(witGetDemandObj1ShipReward,witDemandName,witDemandName);
}


std::vector<float> ECCovptProblem::getResourceMRPGrossQuantity(
                                                           const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  return witGetNameAttribute(witGetPartReqVol,workingRes);
}

void ECCovptProblem::addReleaseLeadtimeStructure(const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string scrapRes = scrapResourceName(resourceIdentifierValues);
  int releaseTime = (int) getResourceReleaseTime(resourceIdentifierValues);  
  float * rtVec = floatToFloatStar((float)releaseTime);
  checkWitRC(witSetBomEntryOffset(mutableWitRun(),scrapRes.c_str(),0,rtVec));
  delete [] rtVec;
  
  int i;
  int np = getNPeriods();
  if (releaseTime > np)
    releaseTime = np;
  for (i=1; i<=releaseTime; i++){
    checkWitRC(witAddBopEntry(mutableWitRun(),scrapRes.c_str(),scrapRes.c_str()));
    float * offsetVec = floatToFloatStar((float)i);
    checkWitRC(witSetBopEntryOffset(mutableWitRun(),scrapRes.c_str(),i-1,offsetVec));
    delete [] offsetVec;
  }
}
#endif

#if 0
//----------------------
// Methods for boms.
//----------------------


void ECCovptProblem::addBom(const std::string & engagementName, 
                        const std::vector<std::string> &resourceIdentifierValues)
{ 
  assert( !bomExists(engagementName,resourceIdentifierValues) );
  std::string bn = bomName(engagementName,resourceIdentifierValues);
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  
  // nothing to do here. 
  // wit bomEntries are added when the usage period is known
  
  bomNames_.insert(bn);
  mapEngagementToConsumedResources_[engagementName].push_back(resourceIdentifierValues);
}



void ECCovptProblem::setBomUsageQuantity(
                                     const std::string & engName, 
                                     const std::vector<std::string> &resourceIdentifierValues,
                                     int period, 
                                     float usageQuantity)
{
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  std::string engagement = engagementName(engName);
  
  // Get the index for the bom connecting the operation to the part for this period
  int bomIndex = getBomEntryIndex(engagement,workingRes,period);
  
  // if the bomEntry was not found then add it.
  if ( bomIndex==-1 ) {
    // The RCP BOM must have already been added.
    assert( bomExists(engName,resourceIdentifierValues) );
    
    checkWitRC(witGetOperationNBomEntries(witRun(),engagement.c_str(),&bomIndex));
    checkWitRC(witAddBomEntry(witRun(),engagement.c_str(),workingRes.c_str()));
    
    RCPbomAppData * appData = new RCPbomAppData;
    appData->setPeriod(period);
    checkWitRC(witSetBomEntryAppData(witRun(),engagement.c_str(),bomIndex,appData));
  }
  
  // set the RCP's usageQuantity to consRate
  witSetArcAttribute(witSetBomEntryConsRate,engagement,bomIndex,usageQuantity);
  
  
  // The BOM entries offset is set just before wit*Implode.
  // The offset will be set to engagementDuration-period
  
}



bool ECCovptProblem::bomExists(
                           const std::string & engagementName, 
                           const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string bn = bomName(engagementName,resourceIdentifierValues);
  std::set<std::string>::const_iterator it = bomNames_.find(bn);
  if ( it==bomNames_.end() )
    return false;
  else
    return true;
}




std::vector<RCPvectorString> ECCovptProblem::getEngagementConsumedResources(const std::string & engagementName) const
{
  std::vector<RCPvectorString> retVal;
  std::map<std::string,RCPvectorVectorString>::const_iterator it;
  it=mapEngagementToConsumedResources_.find(engagementName);
  if ( it != mapEngagementToConsumedResources_.end() )
    retVal = it->second;
  return retVal;
}

void ECCovptProblem::getBomNames(std::vector<std::string> &engagements, std::vector<RCPvectorString> & resourceNames )const
{
  resourceNames.clear();
  engagements.clear();
  
  // loop once for each bom
  std::set<std::string>::const_iterator r;
  for ( r=bomNames_.begin(); r!=bomNames_.end(); ++r) {
    const std::string & baseName = *r;
    
    // do the engagements 
    const std::string engagementName = engagementFromBomName(baseName);
    engagements.push_back(engagementName);
    
    RCPvectorString bomIdValues = resourceIdentifierValuesFromResourceName(baseName);
    
    resourceNames.push_back( bomIdValues );
  }
}


std::vector<float> ECCovptProblem::getBomUsageQuantity(const std::string & engName,  
                                                   const std::vector<std::string> &resourceIdentifierValues)const
{
  std::vector<float> retVal;
  
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  std::string theEngagement = engagementName(engName);
  
  int np = getNPeriods();
  
  int t;
  for (t=0; t<np; ++t) {
    //int bomIndex = getBomEntryIndex(theEngagement,workingRes,t);
    retVal.push_back( getBomUsageQuantity(engName,resourceIdentifierValues,t) );
  }
  
  return retVal;
}

float ECCovptProblem::getBomUsageQuantity(const std::string & engName,  
                                      const std::vector<std::string> &resourceIdentifierValues,int period)const
{
  float retVal;
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  std::string theEngagement = engagementName(engName);
  
  int bomIndex = getBomEntryIndex(theEngagement,workingRes,period);
  if ( bomIndex==-1 ) {
    // A bomEntry does not exist for this period
    retVal = 0.0f;
  }
  else {
    std::vector<float> consVol = 
      witGetArcAttribute(witGetBomEntryConsRate,theEngagement,bomIndex);
    retVal = consVol[0];    
  }
  
  return retVal;
}


//-------------------------------------------------------------------------------------
// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
void ECCovptProblem::setBomSub(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName , int sub)
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( resourceIdentifierNameExists(resourceIdName) );
  
  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  checkWitRC(witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData));
  appData->setSub(resourceIdName,sub);
}
//-------------------------------------------------------------------------------------
// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData



// Method for setting bomAppData substitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  ECCovptProblem::getBomSub(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName ) const
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( resourceIdentifierNameExists(resourceIdName) );
  
  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  checkWitRC(witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData));
  return appData->getSub(resourceIdName);
}


//-----------------------------------------------------------------------------

//-------------------------------------------------------------------------------------

void ECCovptProblem::setBomMatch(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName , int match)
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( resourceIdentifierNameExists(resourceIdName) );
  
  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  checkWitRC(witGetBomEntryAppData(witRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData));
  appData->setMatch(resourceIdName,match);
}
// Method for setting bomAppData match attributes.


// Method for setting bomAppData matchstitute attributes.
// The attribute set is determined by passing a method pointer of RCPbomAppData
int  ECCovptProblem::getBomMatch(const std::string & engName, const std::vector<std::string> &resourceIdentifierValues, int period, const std::string & resourceIdName ) const
{
  // make sure resourceIdName is one of the defined resource attribute names
  assert( resourceIdentifierNameExists(resourceIdName) );
  
  std::string witPartName = workingResourceName(resourceIdentifierValues);
  std::string witOpName = engagementName(engName);
  int bomIndex = getBomEntryIndex(witOpName,witPartName,period);
  
  RCPbomAppData * appData;
  checkWitRC(witGetBomEntryAppData(mutableWitRun(),engagementName(engName).c_str(),bomIndex, (void**)&appData));
  return appData->getMatch(resourceIdName);
}
#endif


#if 0
//----------------------
// Methods for handling resource substitution in a common way
//----------------------
void ECCovptProblem::addSubs(const std::string & resourceIdName, const std::string & from, const std::string & to )
{
  RCPmapMapStringToSubs & subCollection = resourceIdToSubs_[resourceIdName];
  assert( !subsExists(resourceIdName,from,to) );
  RCPbaseSubs subs(from,to);
  subCollection[from][to]=subs;
}
void ECCovptProblem::setSubsCost(const std::string & resourceIdName, const std::string & from, const std::string & to, float cost )
{
  RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  subs.setCost(cost);
}
void ECCovptProblem::setSubsLeadTime(const std::string & resourceIdName, const std::string & from, const std::string & to, float leadTime )
{
  RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  subs.setLeadTime(leadTime);
} 
void ECCovptProblem::setSubsAversion(const std::string & resourceIdName, const std::string & from, const std::string & to, int aversion )
{
  RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  subs.setAversion(aversion);
}
bool ECCovptProblem::subsExists(const std::string & resourceIdName, const std::string & from, const std::string & to )const
{
  bool retVal=false;
  
  // if resourceIdName does not exist in resourceIdToSubs_ collection, then return that substitute does not exist
  RCPmapResoruceIdToSubsConstIterator subCollIt = resourceIdToSubs_.find(resourceIdName);
  if( subCollIt == resourceIdToSubs_.end() )
    return retVal;
  const RCPmapMapStringToSubs & subCollection = subCollIt->second;
  
  // does the fromSkill exist
  RCPmapMapStringToSubs::const_iterator itFrom = subCollection.find(from);
  if ( itFrom!=subCollection.end() ) {
    
    // the fromSkill exists, now see if this fromSkill has the toSkill
    RCPmapStringToSubs::const_iterator itTo = itFrom->second.find(to);
    if ( itTo!=itFrom->second.end() ) 
      retVal=true;
  }
  return retVal;
}

void ECCovptProblem::getSubsNames(const std::string & resourceIdName, std::vector<std::string> & froms, std::vector<std::string> & tos)const
{
  froms.clear();
  tos.clear();
  
  // if resourceIdName does not exist in resourceIdToSubs_ collection, then return empty vectors
  RCPmapResoruceIdToSubsConstIterator subCollIt = resourceIdToSubs_.find(resourceIdName);
  if( subCollIt == resourceIdToSubs_.end() )
    return;
  const RCPmapMapStringToSubs & subCollection = subCollIt->second;
  
  // loop once for each fromSkill
  RCPmapMapStringToSubs::const_iterator itFrom;
  for (itFrom=subCollection.begin(); itFrom!=subCollection.end(); ++itFrom) {
    
    // loop once for each toSkill
    RCPmapStringToSubs::const_iterator itTo;
    for (itTo=itFrom->second.begin(); itTo!=itFrom->second.end(); ++itTo ) {
      
      // get skillSubs and append from and to skills to returned vectors
      const RCPbaseSubs & subs  = (*itTo).second;
      froms.push_back(subs.getFromName() );
      tos.push_back(subs.getToName() );
      
    }
  }
}
float ECCovptProblem::getSubsCost(const std::string & resourceIdName, const std::string & from, const std::string & to )const
{
  const RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  return subs.getCost();
}
float ECCovptProblem::getSubsLeadTime(const std::string & resourceIdName, const std::string & from, const std::string & to )const
{
  const RCPbaseSubs & subs = getSubs(resourceIdName,from,to);
  return subs.getLeadTime();
}

// Get baseSubs from collection class
RCPbaseSubs & ECCovptProblem::getSubs(const std::string & resourceIdName, const std::string & from, const std::string & to ) 
{
  RCPmapMapStringToSubs & subCollection = resourceIdToSubs_[resourceIdName];
  assert( subsExists(resourceIdName,from,to) );
  RCPmapStringToSubs & tos = subCollection.find(from)->second;
  RCPbaseSubs & subs = tos.find(to)->second;
  return subs;
}
const RCPbaseSubs & ECCovptProblem::getSubs(const std::string & resourceIdName, const std::string & from, const std::string & to ) const
{
  assert( subsExists(resourceIdName,from,to) );
  
  RCPmapResoruceIdToSubsConstIterator subCollIt = resourceIdToSubs_.find(resourceIdName);
  assert( subCollIt != resourceIdToSubs_.end() );
  const RCPmapMapStringToSubs & subCollection = subCollIt->second;
  
  const RCPmapStringToSubs & tos = subCollection.find(from)->second;
  const RCPbaseSubs & subs = tos.find(to)->second;
  return subs;
}

// given 2 sets return their union
void ECCovptProblem::unionCollectionOfStrings(
                                          const RCPcollectionOfStrings & set1,
                                          const RCPcollectionOfStrings & set2,
                                          RCPcollectionOfStrings & retVal)
{
  retVal.clear();
  std::insert_iterator<RCPcollectionOfStrings>  insert(retVal, retVal.begin());
  std::set_union(set1.begin(),set1.end(), set2.begin(),set2.end(), insert);
}
// given 2 sets return their intersection
void ECCovptProblem::intersectionCollectionOfStrings(
                                                 const RCPcollectionOfStrings & set1,
                                                 const RCPcollectionOfStrings & set2,
                                                 RCPcollectionOfStrings & retVal)
{
  retVal.clear();
  std::insert_iterator<RCPcollectionOfStrings>  insert(retVal, retVal.begin());
  std::set_intersection(set1.begin(),set1.end(), set2.begin(),set2.end(), insert);
}

void ECCovptProblem::removeIneligibleResources(
                                           RCPcollectionOfStrings & currentToResources,
                                           int subAllowed,
                                           const std::string & resourceIdName,
                                           const std::string & fromResourceAttribute )
{  
  
  
  //find the set of possible values in the given resourceIdName field
  const std::map<std::string,RCPcollectionOfStrings> & attributeToResourceNames = resourceIdToResourceNames_[resourceIdName];
  
  
  RCPcollectionOfStrings unionSet1;
  
  //if substitution is allowed on this field...
  if ( subAllowed ) {
    //find the set of all {from/to} substitutes specified for the given resourceIdName
    const RCPmapMapStringToSubs & attributeSubs = resourceIdToSubs_[resourceIdName];

    //there were no substitutes specified for this field
    

    if (attributeSubs.find(fromResourceAttribute)==attributeSubs.end()) {
      #if 0
      std::cerr <<"WARNING: Substitute requested but no substitutes for given resource value provided. " <<std::endl
        <<"   resource ID name   : " << resourceIdName <<std::endl
        <<"   resource Value: " << fromResourceAttribute <<std::endl ;
      #endif
        
       //it is AS IF we require an exact match. So do it.
       
       // Are there any resources with the attribute value? If no, then just return
       if ( attributeToResourceNames.find(fromResourceAttribute)==attributeToResourceNames.end() ) return; 
    
       // Get all resources whose attribute value matches
       const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
    
       // Intersect resource whose attribute matches with set passed into this method
       RCPcollectionOfStrings intersection;
       intersectionCollectionOfStrings(currentToResources,resWithMatch,intersection);
    
       // update set passed into this method with insection just computed
       currentToResources = intersection;        
        
       return;
    }

    
    // This will be the set we build up
    RCPcollectionOfStrings unionSet;
    
    // this bom entry had a particular "from" specifed. Look for the legal substitutes
    // get toResources that can substitute for fromResources
    const RCPmapStringToSubs & toResources = attributeSubs.find(fromResourceAttribute)->second;
    
    // loop over each toResource creating a collection of all resources that have the toResource.
    RCPmapStringToSubs::const_iterator toResourcesIt;
    
    // Get all resources whose attribute value matches exactly the specified (from) value
    const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
    
    for ( toResourcesIt=toResources.begin(); toResourcesIt!=toResources.end(); ++toResourcesIt ) {
      
      //What is the "to" resource attribute?
      std::string toResourceAttribute = toResourcesIt->first;
      
      // If there aren't any actual resources with to attribute then there is nothing to do
      if ( attributeToResourceNames.find(toResourceAttribute)==attributeToResourceNames.end() ) continue;
      
      // Get set of all resources that have toAttribute
      const RCPcollectionOfStrings & resWithToAttributes = attributeToResourceNames.find(toResourceAttribute)->second;
      
      
      //take the union of the current union with the substitute possibilities
      unionCollectionOfStrings(unionSet,resWithToAttributes,unionSet1);
      unionSet=unionSet1;
      
    } // end of for toResourcesIt loop
    
    //take the union of the current union with the direct matches
    unionCollectionOfStrings(unionSet,resWithMatch,unionSet1);
    
    
    // Take the intersection of unionSet1 and currentToResources storing result in intersectionSet
    RCPcollectionOfStrings intersection;
    intersectionCollectionOfStrings(currentToResources,unionSet1,intersection);
    currentToResources=intersection;
  }
  else { // substitution is not specified for this resource Id name; just look at matches
    // Are there any resources with the attribute value? If no, then just return
    if ( attributeToResourceNames.find(fromResourceAttribute)==attributeToResourceNames.end() ) return; 
    
    // Get all resources whose attribute value matches
    const RCPcollectionOfStrings & resWithMatch = attributeToResourceNames.find(fromResourceAttribute)->second;
    
    // Intersect resource whose attribute matches with set passed into this method
    RCPcollectionOfStrings intersection;
    intersectionCollectionOfStrings(currentToResources,resWithMatch,intersection);
    
    // update set passed into this method with insection just computed
    currentToResources = intersection;
  }
}
//--------------------------------------------------------------------------
// Add wit substitute arcs 
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
// Add wit substitute arcs 
//--------------------------------------------------------------------------
void ECCovptProblem::addSubsArcsToWitModel04Feb(RCPoperationBomSubBomIndices & subBomsAdded )
{
  int np = getNPeriods();
  
  // Get rcp boms
  std::vector<RCPvectorString> resourceNames;
  std::vector<std::string> engagementNames;
  getBomNames(engagementNames, resourceNames);
  // loop once for each rcp bom
  
  int numIdentifiers = getResourceIdentifierNames().size();
  unsigned int b;
  for ( b=0; b<resourceNames.size(); ++b ) {
    const RCPvectorString & fromResourceVector = resourceNames[b];
    
    
    // Name of wit part connected to bomEntry
    std::string workingRes = workingResourceName(fromResourceVector);
    
    // Name of wit operation connected to bomEntry
    std::string witEngagement = engagementName(engagementNames[b]);
    
    // Get the indices for the boms connecting the operation to the part
    std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
    
    
    // loop once for each bomEntry connecting engagement and workingRes for which a substitute needs to 
    // be added.  Need loop over bomEntries, because data files allow substitution rules to be different
    // by period.
    unsigned int be;
    for( be=0; be<bomIndices.size(); ++be ) {
      int bomIndex = bomIndices[be];  
      
      // get the period associated with this bomEntry
      RCPbomAppData * appData;
      checkWitRC(witGetBomEntryAppData(mutableWitRun(),witEngagement.c_str(),bomIndex,(void**)&appData));
      int period = appData->getPeriod();
      
      // Collection that will be manipulated to contain all allowed substitute resources
      RCPcollectionOfStrings subsResources = resourceNames_;;
      
      
      // Does this bom allow jobRole substitution? 
      
      // Check each attribute to see if substitution is allowed
      for (unsigned int i=0; i<getResourceIdentifierNames().size(); i++) {
        std::string resourceIdName = getResourceIdentifierNames()[i];
        std::string resourceValue = fromResourceVector.at(i);
        int subAllowed = getBomSub(engagementNames[b], fromResourceVector, period, resourceIdName);
        int matching = getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
        if (matching)
          removeIneligibleResources(subsResources,subAllowed,resourceIdName,resourceValue);
      }
      
      // Remove resource connected to BOM from the set of substitute resources
      subsResources.erase(baseNameFromWorkingResourceName(workingRes));
      
      // loop once for each substitute resource
      RCPcollectionOfStrings::const_iterator subsResIt;
      for ( subsResIt=subsResources.begin(); subsResIt!=subsResources.end(); ++subsResIt ) {
        std::vector<std::string> toResourceVector(numIdentifiers);
        std::string subsResource = *subsResIt;
        unsigned int i;
        for ( i=0; i<getResourceIdentifierNames().size(); i++) {
          toResourceVector[i]=resourceIdentifierValueFromResourceName(subsResource, i);
        }
         
        // make sure substitute resource exists
        assert( resourceExists(toResourceVector ));
        
        // compute the substitute arcs cost and leadTime
        // subsCost is the sum of the substitute cost for each substituted attribute
        // subsLeadTime is the maximum of the lead time for each substituted attribute
        float subsLeadTime = 0.f;
        float subsCost =0.f;
        int subsAversion = 0;
        
        
        //look over all the resource attributes and get substitute lead times and costs
        for ( i=0; i<getResourceIdentifierNames().size(); i++) {
          std::string fromValue = fromResourceVector.at(i);
          std::string toValue = toResourceVector.at(i);
          std::string resourceIdName = getResourceIdentifierNames()[i];
          int matching =  getBomMatch(engagementNames[b], fromResourceVector, period, resourceIdName);
          if (fromValue != toValue && matching==1) {
            //this particular resource attribute was substituted
            subsLeadTime = max( subsLeadTime, resourceIdToSubs_[resourceIdName][fromValue][toValue].getLeadTime());
            subsCost     = subsCost       +   resourceIdToSubs_[resourceIdName][fromValue][toValue].getCost();
            //DLG this is where we need to do something clever
            //to figure out the appropriate aversion from the COMBINATION
            //of aversions for each of the relevant Id fields.
            subsAversion = subsAversion + resourceIdToSubs_[resourceIdName][fromValue][toValue].getAversion(); 
          }
        }
        
        
        // Assert that the subs resource exists
        assert( resourceExists(toResourceVector) );
        
        // Name of witPart to be connected to subsBomEntry
        std::string subsWorkingRes = workingResourceName(toResourceVector);
        
        //std::cout <<"  resource: " <<workingRes <<std::endl;
        //std::cout <<"    substitute resource: " <<subsWorkingRes <<std::endl;
        
        
        // get some attributes of bomEntry that will have substitute added
        std::vector<float> bomConsRate = witGetArcAttribute(witGetBomEntryConsRate,witEngagement,bomIndex);
        std::vector<float> offset = witGetArcAttribute(witGetBomEntryOffset,witEngagement,bomIndex);
        
        // bomConsRate is a constant vector.  This makes setting the consRate on the sub easier, because
        // no shifting by lead time is needed
        
        
#ifndef NDEBUG
        {
          int t;
          for( t=1; t<np; ++t )
            assert(bomConsRate[0]==bomConsRate[t]);
        }
#endif
        
        // get index of substitute to be added
        int subIndex;
        checkWitRC(witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&subIndex));
        
        // add substitute
        checkWitRC(witAddSubsBomEntry(witRun(),witEngagement.c_str(),bomIndex,subsWorkingRes.c_str() ));
        
        subBomsAdded[witEngagement][bomIndex].push_back(subIndex);
        
        // set substitute consRate
        witSetSubArcAttribute(witSetSubsBomEntryConsRate,witEngagement,bomIndex,subIndex,bomConsRate);
        
        // compute substitute offset
        // JP, Donna, Dan: need to verify that offset is being set correctly.
        std::vector<float> subsOffset(np);
        int t;
        for (t=0; t<np; ++t) {
          subsOffset[t]=offset[t]-subsLeadTime;
        }
        
        // set substitutes offset
        witSetSubArcAttribute(witSetSubsBomEntryOffset,witEngagement,bomIndex,subIndex,subsOffset);
        
        // set cost of using substitute
        witSetSubArcAttribute(witSetSubsBomEntryObj1SubCost,witEngagement,bomIndex,subIndex,subsCost);
        
        // set aversion of using substitute
        checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),witEngagement.c_str(),bomIndex,subIndex,(float)subsAversion));      
      }  // end for subsResIt loop         
    }  // end of for be loop 
    
  } // end for b loop
}

// For a specified BOM return all of the resources that can substitute for it
void ECCovptProblem::getSubsResources( 
                                  const std::string & engName, 
                                  const RCPvectorString &resourceIdentifierValues,
                                  RCPcollectionOfStrings & retVal) const
{
  // There are 3 steps.
  // 1. add substitutes to wit model
  // 2. retrieve subs from wit model and populate returned data structures
  // 3. remove substitutes from wit model.
  //
  // this could be coded more efficiently.
  // Right now this method is just used for testing, so it is probably OK that it is 
  // inefficent.
  
  // 1. Add Substitutes to wit model
  RCPoperationBomSubBomIndices subBomsAdded;
  ((ECCovptProblem *)this)->addSubsArcsToWitModel04Feb(subBomsAdded);
  
  // 2. Get subs from wit model and populate returned data structures
  retVal.clear();
  
  // Name of wit part connected to bomEntry
  std::string workingRes = workingResourceName(resourceIdentifierValues);
  
  // Name of wit operation connected to bomEntry
  std::string witEngagement = engagementName(engName);
  
  // Get the indices of the boms connecting the operation to the part
  std::vector<int> bomIndices = getBomEntryIndex(witEngagement,workingRes);
  //int nBomIndices =bomIndices.size();
  unsigned int b;
  for( b=0; b<bomIndices.size(); ++b ) {
    int bomIndex = bomIndices[b]; 
    
    // Get the number of substitutes
    int nSubs;
    checkWitRC(witGetBomEntryNSubsBomEntries(mutableWitRun(),witEngagement.c_str(),bomIndex,&nSubs));
    
    // loop once for each subs
    int s;
    for ( s=0; s<nSubs; ++s ) {
      char * subResName;
      checkWitRC(witGetSubsBomEntryConsumedPart(mutableWitRun(),witEngagement.c_str(),bomIndex,s,&subResName));
      std::string baseName = baseNameFromWorkingResourceName(subResName);
      retVal.insert(baseName);
      checkWitRC(witFree(subResName));
    }
  }
  
  // 3. Remove Substitutes to wit model
  ((ECCovptProblem *)this)->removeSubsArcsFromWitModel04Feb(subBomsAdded);
  
}
#endif




#if 0


void ECCovptProblem::presolveForPriorityAllocation()
{
  int np=getNPeriods();
  float scalingFactor = 0.001f;
  checkWitRC(witSetSelSplit(witRun(), WitTRUE));
  checkWitRC(witSetExpCutoff(witRun(), 0.0001f));
  // Scale the prodRate of each engagement operation 
  // Then scale the consRate of each BOM and subBOM arc going into that engagement operation
  // Loop over all engagements
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      //      std::cout << "theEngagement:" << theEngagement << std::endl;
      float * prodRate = new float[np];
      int t;
      for (t=0; t<np; t++){
        prodRate[t] = scalingFactor;
        //std::cout << "Period(prodRate):" << t << ":" << prodRate[t] <<std::endl;
      }       
      checkWitRC(witSetBopEntryProductRate(witRun(),theEngagement.c_str(),0,prodRate));
      delete [] prodRate;
      
      // Get the number of BOM arcs going into the engagement operation
      int nBomArcs;
      checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs));
      int i;
      float * consRate = new float[np];
      for (i=0; i<nBomArcs; i++){
        checkWitRC(witGetBomEntryConsRate(witRun(),theEngagement.c_str(),i,&consRate));
        for (t=0;t<np;t++){
          consRate[t] = consRate[t]*scalingFactor;
          //std::cout << "Period(consRate): " << t << ":" << consRate[t] << std::endl; 
        }
        checkWitRC(witSetBomEntryConsRate(witRun(),theEngagement.c_str(),i,consRate));
        
        // Get the number of subBOM arcs hanging off this BOM arc and scale each of them
        int nSubBomArcs;
        checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs));
        int j;
        for (j=0;j<nSubBomArcs;j++){
          checkWitRC(witGetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,&consRate));
          for (t=0;t<np;t++){
            consRate[t] = consRate[t]*scalingFactor;
            //std::cout << "Period(subBomArc): " << t << ":" << consRate[t] << std::endl;
          }
          checkWitRC(witSetSubsBomEntryConsRate(witRun(),theEngagement.c_str(),i,j,consRate));
        }
      } 
      delete [] consRate;
    }
  }
}



void ECCovptProblem::presolveForOptimalGapGlut()
{
  int np=getNPeriods();
  
  // set witOperationExecBounds for RCP engagement
  // Set softLB to be 1 in the requested startPeriod
  // Loop over all engagements
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      float * softLB = new float[np];
      int t;
      for (t=0; t<np; t++)
        softLB[t] = 0.0f;
      softLB[startPeriod] = 1.0f;
      checkWitRC(witSetOperationExecBounds(witRun(),theEngagement.c_str(),NULL,softLB,NULL));
      delete [] softLB;
    }
  }
}

void ECCovptProblem::postsolveForOptimalGapGlut()
{  
  // reset witOperationExecBounds for RCP engagement
  // reset softLB to be 0 for all periods
  // Loop over all engagements
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  float * softLB = floatToFloatStar(0.0f);
  unsigned int e;
  for( e=0; e<engagementNames.size(); ++e ) {
    std::string theEngagement = engagementName(engagementNames[e]);
    //int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
    checkWitRC(witSetOperationExecBounds(witRun(),theEngagement.c_str(),NULL,softLB,NULL));
  } 
  delete [] softLB;
}



void ECCovptProblem::presolve(RCPoperationBomSubBomIndices & subBomsAdded)
{
  int np=getNPeriods();
  
  // set wit obj1ShipReward from RCP engagement revenue, startTime, duration.
  // Loop over all engagements
  {
    float * obj1ShipReward = new float[np];
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      float revenue = getEngagementRevenue(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      //int duration = getEngagementDuration(engagementNames[e]);
      int lateAllowance = getEngagementLateAllowance(engagementNames[e]);
      
      //   int lastPeriod = startPeriod+duration-1;
      //if (lastPeriod>np) lastPeriod=np;
      int t;
      for ( t=0; t<startPeriod; t++ ) obj1ShipReward[t]=0.0f;
      if (lateAllowance < 0 ){
        for ( t=startPeriod; t<np; t++ ) obj1ShipReward[t]=revenue;
      }
      else {
        int endPoint = startPeriod+lateAllowance +1 < np ? startPeriod+lateAllowance+1:np;
        for ( t=startPeriod; t<endPoint; t++) obj1ShipReward[t]=revenue;
        for (t=endPoint; t<np; t++) obj1ShipReward[t]=0.0f;
      }
      checkWitRC(witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),obj1ShipReward));
    }
    delete [] obj1ShipReward;   
  }
  
  // set wit bomEntryOffset for each RCP bom.
  // The offset = (engagement duration) - (wit's bomEntry period)
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      
      // Get engagements duration
      //int duration = getEngagementDuration(engagementNames[e]);
      std::string theEngagement = engagementName(engagementNames[e]);
      
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries));
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        // get the period associated with this bomEntry
        RCPbomAppData * appData;
        checkWitRC(witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&appData));
        int period = appData->getPeriod();
        
        // compute offset for bomEntry
        float offset = -(float)period;
        
        // Set bomEntry offest
        witSetArcAttribute(witSetBomEntryOffset,theEngagement,b,offset);
        
      } // end of b loop
    } // end of e loop
  } // finished setting wit bomEntryOffset for each RCP BOM
  
  // Add substitute arcs.  
  getTimer().printElapsedTime("done most of presolve");
  addSubsArcsToWitModel04Feb(subBomsAdded);
  getTimer().printElapsedTime("done addSubsArcsToWitMOdel");
}
void ECCovptProblem::presolve04Feb(RCPoperationBomSubBomIndices & subsAddedByPresolve)
{
  int np=getNPeriods();
  
  // set wit obj1ShipReward from RCP engagement revenue, startTime, duration.
  // Loop over all engagements
  {
    float * obj1ShipReward = new float[np];
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      float revenue = getEngagementRevenue(engagementNames[e]);
      int startPeriod = getEngagementRequestedStartPeriod(engagementNames[e]);
      float quantity = getEngagementQuantity(engagementNames[e]);

      // set the demand quantity 
      float * demandQty = floatToFloatStar(0.f);
      demandQty[startPeriod] = quantity;
      checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),demandQty));
      delete [] demandQty;

      //int duration = getEngagementDuration(engagementNames[e]);
      int lateAllowance = getEngagementLateAllowance(engagementNames[e]);
      
      //   int lastPeriod = startPeriod+duration-1;
      //if (lastPeriod>np) lastPeriod=np;
      int t;
      for ( t=0; t<startPeriod; t++ ) obj1ShipReward[t]=0.0f;
      if (lateAllowance < 0 ){
        for ( t=startPeriod; t<np; t++ ) obj1ShipReward[t]=revenue;
      }
      else {
        int endPoint = startPeriod+lateAllowance +1 < np ? startPeriod+lateAllowance+1:np;
        for ( t=startPeriod; t<endPoint; t++) obj1ShipReward[t]=revenue;
        for (t=endPoint; t<np; t++) obj1ShipReward[t]=0.0f;
      }
      checkWitRC(witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),obj1ShipReward));
    }
    delete [] obj1ShipReward;   
  }
  
  // set wit bomEntryOffset for each RCP bom.
  // The offset = (engagement duration) - (wit's bomEntry period)
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      
      // Get engagements duration
      //int duration = getEngagementDuration(engagementNames[e]);
      std::string theEngagement = engagementName(engagementNames[e]);
      
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries));
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        // get the period associated with this bomEntry
        RCPbomAppData * appData;
        checkWitRC(witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&appData));
        int period = appData->getPeriod();
        
        // compute offset for bomEntry
        float offset = -(float)period;
        
        // Set bomEntry offest
        witSetArcAttribute(witSetBomEntryOffset,theEngagement,b,offset);
        
      } // end of b loop
    } // end of e loop
  } // finished setting wit bomEntryOffset for each RCP BOM
  
  // Add substitute arcs.
  getTimer().printElapsedTime("done most of presolve");
  addSubsArcsToWitModel04Feb(subsAddedByPresolve);
  getTimer().printElapsedTime("done addSubsArcsToWitMOdel");

}

void ECCovptProblem::postsolve(RCPoperationBomSubBomIndices & subsAddedByPresolve)
{
  removeSubsArcsFromWitModel04Feb(subsAddedByPresolve);
}
// remove subs boms which were added by presolve
void ECCovptProblem::removeSubsArcsFromWitModel04Feb(RCPoperationBomSubBomIndices & subsToBeRemoved)
{
  // Loop once for each operation
  RCPoperationBomSubBomIndicesConstIter opIt;
  for ( opIt=subsToBeRemoved.begin(); opIt!=subsToBeRemoved.end(); ++opIt ){
    const std::string & witOpName = opIt->first;
    const RCPbomSubBomIndices & bomSubIndices = opIt->second;
    
    // Loop once for bomEntry
    RCPbomSubBomIndicesConstIter bomIt;
    for ( bomIt=bomSubIndices.begin(); bomIt!=bomSubIndices.end(); ++bomIt ) {
      int bomEntryIndex = bomIt->first;
      const RCPsubBomIndices & subsEntryIndices = bomIt->second;
      
      // loop once for each subBomEntry
      unsigned int s;
      for ( s=0; s<subsEntryIndices.size(); ++s ) {
        checkWitRC(witSetSubsBomEntrySelForDel(witRun(),witOpName.c_str(),bomEntryIndex,subsEntryIndices[s],WitTRUE));
      } // end of loop once for each subBomEntry
      
    } // end of Loop once for bomEntry
    
  } // end of for operation loop.
  
  checkWitRC(witPurgeData(witRun()));  
  
}

void ECCovptProblem::priorityGapGlut()
{
  // (1)Set the wit supply volume for every working part to the exogenous supply
  // volume for that part
  // (2)set mrpNetAllowed to true on all the subBOM arcs
  // (3)perform witMRP
  // (4)gap is reqVol and glut is mrpExcessVol of the working part
  // (5)Reset the wit supply volume for every working part to zero
  
  // Get list of all resources
  // Need to branch on format type;  right now it's hardcoded for the old format 
  std::vector<RCPvectorString> names;
  
  int numResources, np;
  
  np = getNPeriods();
  getResourceNames(names);
  numResources = names.size();
  
  // (1) loop once for each resource and set supply of the working part to the exogenous supply
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    std::vector<float> exogSup;
    workingRes = workingResourceName(names[r]);
    exogSup = getResourceSupplyQuantity(names[r]);
    
    int t;
    for (t=0; t<np; t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,
      workingRes,t,exogSup[t]);
  }
  // (2) Now loop through all the subs and set mrpNetAllowed to true
  // Loop over all engagements
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      //      std::cout << "theEngagement:" << theEngagement << std::endl;
      // Get the number of BOM arcs going into the engagement operation
      int nBomArcs;
      checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs));
      int i;
      for (i=0; i<nBomArcs; i++){
        // Get the number of subBOM arcs hanging off this BOM arc and scale each of them
        int nSubBomArcs;
        checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs));
        int j;
        for (j=0;j<nSubBomArcs;j++){
          checkWitRC(witSetSubsBomEntryMrpNetAllowed(witRun(),theEngagement.c_str(),i,j,WitTRUE));
        } 
      }
    }
  }
  
  // (3) perform the wit MRP
  checkWitRC(witMrp(witRun()));
  
  // (4) pick off the results
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    std::vector<float> gapQty = witGetNameAttribute(witGetPartReqVol,workingRes);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartMrpExcessVol,workingRes);
    for (int t=0; t<np; t++ ) {
      setResourceGapQuantity(names[r],t,gapQty[t]);
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
  }
  
  // (5) Reset the supply of the working part to zero
  // loop once for each resource
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    
    int t;
    for (t=0; t<np; t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,0.0f);
  }
  
}

void ECCovptProblem::priorityGapGlut1()
{
  // Assume that the offset of the acquireOp is zero for gapGlut computation
  // (0) Check to see that there is only one engagement,its requested start 
  // time is period zero and get its name.
  // (1) Set the base engagement demand to zero
  // (2) Create additional demand structures, one for the demand that must be met exactly and one for the demand
  // that can be met with substitution; mark these SelForDel
  // (3)Set the wit supply volume for every working part to the exogenous supply
  // volume for that part; Set the productRate of the acquireOp to vecZero. 
  // (4) Loop through all the BOMs in the base model add "copies" of the 'must be met exactly' BOMs to the 'must
  // be met exactly' demand and copies of the rest to the demand that can be met with substitution, while setting
  //  mrpNetAllowed to true on all the subBOM arcs; (mark SelForDel)
  // (5) perform witHeurImplode
  // (6) gap is acquire execVol of the resource and glut is scrapVol of the working part
  // (7) Set the base engagement demand back to one
  // (8) Set the wit supply volume for every working part to zeroVec
  // (9) witPurgeData
  // (10) Set the productRate of the acquireOp to vecOne
  
  int nPeriods = getNPeriods();
  int t;
  
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  int engSize = engagementNames.size();
  
  // (2)
  int nSpecialDemands = getResourceIdentifierNames().size();
  int maxPriority = 1;
  const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  
  for (int i=0; i<nSpecialDemands; i++){
    int pr = getResourceIdentifierPriority(resourceIdentifierNames[i]);
    if (pr > maxPriority)
      maxPriority = pr;
  }
  
  

  // (3) 
  // Get list of all resources
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  
  // loop once for each resource; connect the acquire resource operation to the working resource part; set the 
  // external supply for the working part; set the productRate of the acquireOp to zeroVec
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    std::string acquireRes;
    std::vector<float> exogSup;
    workingRes = workingResourceName(names[r]);
    acquireRes = acquireResourceOperationName(names[r]);
    checkWitRC(witAddBopEntry(witRun(),acquireRes.c_str(),workingRes.c_str()));
    checkWitRC(witSetBopEntrySelForDel(witRun(),acquireRes.c_str(),1,WitTRUE));
    exogSup = getResourceSupplyQuantity(names[r]);
    
    for (t=0; t<(int)exogSup.size(); t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,exogSup[t]);
    
    std::string acquireOp;
    acquireOp = acquireResourceOperationName(names[r]);
    
    float * zeroVec = floatToFloatStar(0.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,zeroVec));
    delete [] zeroVec;
    
  }

  // Need to assign priorities to the demands
  // (4) Loop over all the engagements and assign a priority to the demand
  {
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    int engCount;
    
    for(engCount=0; engCount<engSize; engCount++){
      std::string theEngagement = engagementName(engagementNames[engCount]);
      
      
      // Get the number of BOM arcs going into the engagement operation
      int nBomArcs;
      checkWitRC(witGetOperationNBomEntries(witRun(),theEngagement.c_str(),&nBomArcs));
      int i;
      
      //      for (i=0; i<nBomArcs; i++){  //Still assuming that there is a "single" bom arc, so don't need to loop through other arcs  DPC
      if (nBomArcs > 0){
        i=0;
        // Get the number of subBOM arcs hanging off this BOM arc 
        int nSubBomArcs;
        char * consumedPartName;
        std::string priorityDemand;
        
        checkWitRC(witGetBomEntryConsumedPart(witRun(),theEngagement.c_str(),i,&consumedPartName));
        
        std::string baseName, workingPartName(consumedPartName);
        baseName = baseNameFromWorkingResourceName(workingPartName);
        RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
        
        checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),theEngagement.c_str(),i,&nSubBomArcs));
        
        // Now go through the working resource and see how many "UNSPECIFIED" or "PRIORITY" values it has;
        // if it is just one, than add it to the appropriate Special Demand 
        
        int index, tempIndex, count = 0;
        std::string idName;
        //assert (resourceIdValues.size() == nSpecialDemands);
        for (index=0; index<nSpecialDemands; index++){
          if (resourceIdValues[index] == "UNSPECIFIED" || resourceIdValues[index] == "PRIORITY"){   
            // Still need to check on the match flag DPC;  Donna may have fixed this on the input side by changing the data for non-matched stuff
            count ++;
            tempIndex = index;
            idName = resourceIdentifierNames[index];
          }
        }
        
        int * priorityVec;
        int priority;
        checkWitRC(witGetDemandPriority(witRun(),theEngagement.c_str(),theEngagement.c_str(),&priorityVec));

        switch (count)
          {
            // set the demand priority based on the following rules
          case 0:
            for (t=0; t<nPeriods; t++)
              priorityVec[t] = 1;
            break;
          case 1:
            priority = getResourceIdentifierPriority(idName);
            if (priority <= 0)
              priority = maxPriority + 2;  //should check that this won't cause overflow  DPC
            else
              if (priority < INT_MAX)
                priority ++;
            for(t=0; t<nPeriods; t++)
              priorityVec[t] = priority;  
            break;
          default:
            for(t=0; t<nPeriods; t++)
              priorityVec[t] = maxPriority+2;
          }

        checkWitRC(witSetDemandPriority(witRun(),theEngagement.c_str(),theEngagement.c_str(),priorityVec));
        checkWitRC(witFree(priorityVec));
        checkWitRC(witFree(consumedPartName));
      } 
    }
  }
  
  // (5) perform witHeurImplode
  checkWitRC(witWriteData(witRun(),"wit3.dat"));
  //  checkWitRC(witSetPerfPegging(witRun(), WitTRUE));
  checkWitRC(witHeurImplode(witRun()));
  //  generatePriorityGapGlut1PeggingResults();
  //  checkWitRC(witClearPegging(witRun()));
  //  checkWitRC(witSetPerfPegging(witRun(), WitFALSE));
  
  // (6) pick off the results for gap/glut from the execVol of the acquire operation and from the scrapVol of the 
  // working part
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes, acquireOp;
    workingRes = workingResourceName(names[r]);
    acquireOp = acquireResourceOperationName(names[r]);
    std::vector<float> gapQty = witGetNameAttribute(witGetOperationExecVol,acquireOp);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartScrapVol,workingRes);
    for (unsigned int t=0; t<gapQty.size(); t++ ) {
      setResourceGapQuantity(names[r],t,gapQty[t]);
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
  }
  
  // (8) 
  for ( r=0; r<numResources; ++r ) {
    float * vecZero = floatToFloatStar(0.0f);
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    checkWitRC(witSetPartSupplyVol(witRun(),workingRes.c_str(),vecZero));
    delete [] vecZero;
  }
  
  // (10)
  for ( r=0; r<numResources; ++r ) {
    std::string acquireOp;
    acquireOp = acquireResourceOperationName(names[r]);
    
    float * oneVec = floatToFloatStar(1.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec));
    delete [] oneVec;
  }
  
}

void ECCovptProblem::priorityGapGlut2()
{
  // (1) Set the wit supply volume for every working part to the exogenous supply
  // volume for that part; add arc from acquire to working; set the productRate of the acquireOp to vecZero. 
  // (1.1) Create a global dummy part, which is needed to make the heuristic work right
  // A subarc will be added to this dummy part for those BOMs that have no existing subarcs
  // (2) Loop through each engagement.  Get its name and report if the engagement's requested start 
  // time is not in period zero.  Set the engagement's demand priority and demand volume.
  // (3) Create the sorting layer. (Mark selForDel)
  // (4) For the engagement, loop through each BOM coming off the engagement.  Add "copies" of the 
  // 'must be met exactly' BOMs to the 'must be met exactly' sort layer operation and 
  // copies of the rest to the demand that can be met with substitution, while setting
  //  mrpNetAllowed to true on all the subBOM arcs; (mark SelForDel)
  // (5) perform witHeurImplode
  // (6) gap is acquire execVol of the resource and glut is scrapVol of the working part
  // (7) For each BOM in each engagement, set earliestPeriod to zero
  // (8) Set the wit supply volume for every working part to zeroVec
  // (9) witPurgeData
  // (10) Set the productRate of the acquireOp to vecOne
  
  int nPeriods = getNPeriods();
  int t;

  // (1) Get list of all resources and set the supply volume for the working part to the exogenous supply
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  // loop once for each resource; connect the acquire resource operation to the working resource part; set the 
  // external supply for the working part; set the productRate of the acquireOp to zeroVec
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes;
    std::string acquireRes;
    std::vector<float> exogSup;
    workingRes = workingResourceName(names[r]);
    acquireRes = acquireResourceOperationName(names[r]);
    checkWitRC(witAddBopEntry(witRun(),acquireRes.c_str(),workingRes.c_str()));
    checkWitRC(witSetBopEntrySelForDel(witRun(),acquireRes.c_str(),1,WitTRUE));
    exogSup = getResourceSupplyQuantity(names[r]);
    
    for (t=0; t<(int)exogSup.size(); t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,exogSup[t]);
    
    std::string acquireOp;
    acquireOp = acquireResourceOperationName(names[r]);
    
    float * zeroVec = floatToFloatStar(0.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,zeroVec));
    delete [] zeroVec;
    
  }

  //(1.1)
  std::string globalSubPart = "global_sub";
  witBoolean exists = WitTRUE;
  while (exists) {
    globalSubPart = "__" + globalSubPart + "__";
    checkWitRC(witGetPartExists(witRun(), globalSubPart.c_str(), &exists));
  }
  checkWitRC(witAddPart(witRun(),globalSubPart.c_str(),WitCAPACITY));
  checkWitRC(witSetPartSelForDel(witRun(),globalSubPart.c_str(),WitTRUE));
  
  // (2) Loop through each engagement.  Get its name and check to see that the engagement's requested start 
  // time is period zero.  (Still assuming all engagements are starting at period 0).  Set the the engagement's priority
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  int numEngagements = engagementNames.size();
  int engCount;

  for(engCount=0; engCount<numEngagements; engCount++){
    std::string engName = engagementNames[engCount];
    int reqStartPer = getEngagementRequestedStartPeriod(engName);
    if (reqStartPer != 0){
      std::cout << "This version of RCP loops over shipment time when sorting the demands." << std::endl;
      std::cout << "The start period for engagement " << engName << " is not zero."  << std::endl;
    }
  
    int priority = getEngagementPriority(engName);
    int * vecPriority = intToIntStar(priority);
    checkWitRC(witSetDemandPriority(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),vecPriority));
    delete [] vecPriority;
    
    float * demandQty = floatToFloatStar(0.f);
    demandQty[reqStartPer] = getEngagementQuantity(engName);
    checkWitRC(witSetDemandDemandVol(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),demandQty));
    delete [] demandQty;


    // (3) Create the sorting layer. (Mark selForDel)
    const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifiersSortedByPriority();
    const std::vector<std::string> & unsortedResourceIdentifierNames = getResourceIdentifierNames();
    int nResIDs = resourceIdentifierNames.size();
    std::string sortName1, sortName2, sortEngagementName1, sortEngagementName2;
    int i;
    
    for (i=0; i<=nResIDs+1; i++){
      if (i==0) 
        sortName1 = "__exact__";
      else if (i==nResIDs+1)
        sortName1 = "__last__";
      else
        sortName1 = "__" + resourceIdentifierNames[i-1] + "__";
      
      sortEngagementName1 = sortLayerEngagementName(engName, sortName1);
      
      checkWitRC(witAddPart(witRun(),sortEngagementName1.c_str(),WitCAPACITY));
      checkWitRC(witSetPartSelForDel(witRun(),sortEngagementName1.c_str(),WitTRUE));
      checkWitRC(witAddOperation(witRun(),sortEngagementName1.c_str()));
      checkWitRC(witSetOperationSelForDel(witRun(),sortEngagementName1.c_str(),WitTRUE));
      checkWitRC(witAddBopEntry(witRun(),sortEngagementName1.c_str(),sortEngagementName1.c_str()));
      checkWitRC(witAddBomEntry(witRun(),engagementName(engName).c_str(),sortEngagementName1.c_str())); 
    }
  
    if (nResIDs == 0){
      sortName1 = "__exact__";
      sortName2 = "__last__";
      sortEngagementName1 = sortLayerEngagementName(engName, sortName1);
      sortEngagementName2 = sortLayerEngagementName(engName, sortName2);
      checkWitRC(witAddBomEntry(witRun(), sortEngagementName1.c_str(), sortEngagementName2.c_str()));
      checkWitRC(witSetBomEntryEarliestPeriod(witRun(),sortEngagementName1.c_str(),0,nPeriods));
    }
    else for (i=0; i<=nResIDs; i++){
      if (i==0){
        sortName1 = "__exact__";
        sortName2 = "__" + resourceIdentifierNames[0] + "__";
      }
      else if (i == nResIDs ) {
        sortName1 = "__" + resourceIdentifierNames[nResIDs-1] + "__";
        sortName2 = "__last__";
      }
      else {
        sortName1 = "__" + resourceIdentifierNames[i-1] + "__";
        sortName2 = "__" + resourceIdentifierNames[i] + "__";
      }
      sortEngagementName1 = sortLayerEngagementName(engName, sortName1);
      sortEngagementName2 = sortLayerEngagementName(engName, sortName2);
      checkWitRC(witAddBomEntry(witRun(), sortEngagementName1.c_str(), sortEngagementName2.c_str()));
      checkWitRC(witSetBomEntryEarliestPeriod(witRun(),sortEngagementName1.c_str(),0,nPeriods));
    }

    // tie the "last" part in the sort layer to the globalSubPart
    sortEngagementName1 = sortLayerEngagementName(engName, "__last__");
    checkWitRC(witAddBomEntry(witRun(), sortEngagementName1.c_str(), globalSubPart.c_str()));
    checkWitRC(witSetBomEntryEarliestPeriod(witRun(),sortEngagementName1.c_str(),0,nPeriods));    


  // (4) For the engagement, loop through each BOM coming off the engagement.  Add "copies" of the 
  // 'must be met exactly' BOMs to the 'must be met exactly' sort layer operation and 
  // copies of the rest to the demand that can be met with substitution, while setting
  //  mrpNetAllowed to true on all the subBOM arcs; (mark SelForDel)


    {
      // Get the number of BOM arcs going into the engagement operation
      int nBomArcs;
      checkWitRC(witGetOperationNBomEntries(witRun(),engagementName(engName).c_str(),&nBomArcs));
      int i;
      int nBomsAddedToExactLayer = 0, nBomsAddedToLastLayer = 0, nBomsAddedToSortLayer;
      
      std::vector<int> nBomsAddedToSpecialSortLayer (nResIDs);
      {
        int k;
        for (k=0; k<nResIDs; k++)
          nBomsAddedToSpecialSortLayer[k] = 0;
      }
      
      for (i=0; i<nBomArcs; i++){
        // Get the number of subBOM arcs hanging off this BOM arc 
        int nSubBomArcs;
        char * consumedPartName;
        float * consRate, * offset, aversion;
        std::string sortLayerOp;

        

        checkWitRC(witGetBomEntryConsumedPart(witRun(),engagementName(engName).c_str(),i,&consumedPartName));
        // Copy over those bom arcs that aren't related to the sortLayer
        if (!beginsWith(consumedPartName, "sortLayer:")) {

          // Shut off BOM arc by setting earliestPeriod to nPeriods
          checkWitRC(witSetBomEntryEarliestPeriod(witRun(),engagementName(engName).c_str(),i,nPeriods));
                  
          std::string baseName, workingPartName(consumedPartName);
          baseName = baseNameFromWorkingResourceName(workingPartName);
          RCPvectorString resourceIdValues = resourceIdentifierValuesFromResourceName( baseName );
          
          checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),engagementName(engName).c_str(),i,&nSubBomArcs));

          // Work with Donna to get the right criteria for the linking up of the resource to the right sort layer
          // This is a temporary approach.
        
          int index, tempIndex, count = 0;
          assert (resourceIdValues.size() == nResIDs);
          for (index=0; index<nResIDs; index++){
            if (resourceIdValues[index] == "UNSPECIFIED" || resourceIdValues[index] == "PRIORITY"){   // Still need to check on the match flag DPC
              count ++;
              tempIndex = index;
            }
          }
          switch (count)
            {
            case 0:
              sortLayerOp = sortLayerEngagementName(engName, "__exact__");
              nBomsAddedToSortLayer = nBomsAddedToExactLayer;
              break;
            case 1:
              // NOTE:  We went through the resourceIdValues in the order of definition,
              // so we use the unsorted list of resourceIDs to get the proper column.
              sortLayerOp = sortLayerEngagementName(engName, "__"+ unsortedResourceIdentifierNames[tempIndex] + "__");
              nBomsAddedToSortLayer = nBomsAddedToSpecialSortLayer[tempIndex];
              break;
            default:
              sortLayerOp = sortLayerEngagementName(engName, "__last__");
              nBomsAddedToSortLayer = nBomsAddedToLastLayer;
            }
          
          checkWitRC(witAddBomEntry(witRun(),sortLayerOp.c_str(),consumedPartName));        
          checkWitRC(witSetBomEntrySelForDel(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,WitTRUE));
          // Add a subBomArc to the global_sub_part for those bom arcs that have no subBomArcs
          if (nSubBomArcs == 0)
            checkWitRC(witAddSubsBomEntry(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,globalSubPart.c_str()));

          // copy over the attributes of this BOM arc from the base model to the LastLayerDemand
          // and then bring over all of the subBOMs and their attributes
          checkWitRC(witGetBomEntryConsRate(witRun(),engagementName(engName).c_str(),i,&consRate));
          checkWitRC(witGetBomEntryOffset(witRun(),engagementName(engName).c_str(),i,&offset));
          checkWitRC(witSetBomEntryConsRate(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,consRate));
          checkWitRC(witSetBomEntryOffset(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,offset));
          // Now copy over the subBOM arcs
          
          int j;
          for (j=0; j<nSubBomArcs; j++)
            {
              char * subConsumedPartName;
              float *subConsRate, *subOffset;
              checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),engagementName(engName).c_str(),i,j,&subConsumedPartName));
              checkWitRC(witAddSubsBomEntry(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,subConsumedPartName));
              checkWitRC(witSetSubsBomEntrySelForDel(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,WitTRUE));
              checkWitRC(witGetSubsBomEntryConsRate(witRun(),engagementName(engName).c_str(),i,j,&subConsRate));
              checkWitRC(witSetSubsBomEntryConsRate(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,subConsRate));
              checkWitRC(witGetSubsBomEntryOffset(witRun(),engagementName(engName).c_str(),i,j,&subOffset));
              checkWitRC(witSetSubsBomEntryOffset(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,subOffset));
              checkWitRC(witGetSubsBomEntryExpNetAversion(witRun(),engagementName(engName).c_str(),i,j,&aversion));
              checkWitRC(witSetSubsBomEntryExpNetAversion(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,aversion));
              checkWitRC(witSetSubsBomEntryMrpNetAllowed(witRun(),sortLayerOp.c_str(),nBomsAddedToSortLayer+1,j,WitTRUE));
              checkWitRC(witFree(subOffset));
              checkWitRC(witFree(subConsRate));
              checkWitRC(witFree(subConsumedPartName));
            }
          switch (count)
            {
            case 0: 
              nBomsAddedToExactLayer ++;
              break;
            case 1:
              nBomsAddedToSpecialSortLayer[tempIndex] ++;
              break;
            default:
              nBomsAddedToLastLayer ++;
            }
          checkWitRC(witFree(consumedPartName));
          checkWitRC(witFree(consRate));
          checkWitRC(witFree(offset));
        } 
      }
    }
  }


  
  // (5) perform witHeurImplode
  checkWitRC(witWriteData(witRun(),"wit3.dat"));

  checkWitRC(witSetPerfPegging(witRun(), WitTRUE));
  checkWitRC(witHeurImplode(witRun()));
  generatePriorityGapGlut2PeggingResults();
  checkWitRC(witClearPegging(witRun()));
  checkWitRC(witSetPerfPegging(witRun(), WitFALSE));
  
  // (6) pick off the results for gap/glut from the execVol of the acquire operation and from the scrapVol of the 
  // working part
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes, acquireOp;
    workingRes = workingResourceName(names[r]);
    acquireOp = acquireResourceOperationName(names[r]);
    std::vector<float> gapQty = witGetNameAttribute(witGetOperationExecVol,acquireOp);
    std::vector<float> glutQty = witGetNameAttribute(witGetPartScrapVol,workingRes);
    for (unsigned int t=0; t<gapQty.size(); t++ ) {
      setResourceGapQuantity(names[r],t,gapQty[t]);
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
  }
  
  // (7) Reset the priority of the engagements back to zero.   For each BOM in each engagement, set earliestPeriod back to zero

  for(engCount=0; engCount<numEngagements; engCount++){
    std::string engName = engagementNames[engCount];
    int * vecPriority = intToIntStar(0);
    
    checkWitRC(witSetDemandPriority(witRun(),engagementName(engName).c_str(),engagementName(engName).c_str(),vecPriority));
    delete [] vecPriority;
            
    
    int nBomArcs;
    checkWitRC(witGetOperationNBomEntries(witRun(),engagementName(engName).c_str(),&nBomArcs));
    int i;
    
    for (i=0; i<nBomArcs; i++)
      checkWitRC(witSetBomEntryEarliestPeriod(witRun(),engagementName(engName).c_str(),i,0));
  }
  
  // (8) Set the wit supply volume for every working part to zeroVec
  for ( r=0; r<numResources; ++r ) {
    float * vecZero = floatToFloatStar(0.0f);
    std::string workingRes;
    workingRes = workingResourceName(names[r]);
    checkWitRC(witSetPartSupplyVol(witRun(),workingRes.c_str(),vecZero));
    delete [] vecZero;
  }
  
  // (9) purge the model of the temporary modeling elements
  checkWitRC(witPurgeData(witRun()));

  // (10) Set the productRate of the acquireOp to vecOne
  for ( r=0; r<numResources; ++r ) {
    std::string acquireOp;
    acquireOp = acquireResourceOperationName(names[r]);
    
    float * oneVec = floatToFloatStar(1.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec));
    delete [] oneVec;
  }
}


void ECCovptProblem::generatePriorityGapGlut1PeggingResults()
{
  // (1) Loop through each demand

  //const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  //int nSpecialDemands = getResourceIdentifierNames().size();
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  unsigned int e;
  for( e=0; e<engagementNames.size(); ++e ) 
    computePegging(engagementName(engagementNames[e].c_str()));
}

void ECCovptProblem::generatePriorityGapGlut2PeggingResults()
{
  // (1) Loop through each demand

  //const std::vector<std::string> & resourceIdentifierNames = getResourceIdentifierNames();
  //int nSpecialDemands = getResourceIdentifierNames().size();
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  unsigned int e;
  for( e=0; e<engagementNames.size(); ++e ) 
    computePegging3(engagementName(engagementNames[e].c_str()));
}


void ECCovptProblem::computePegging(std::string demandName) 
{
  int np = getNPeriods();
  // (2) For each demand, loop through all the BOMs for that demand
  // (3) For each BOM, get the consuming part and the consRate vector (i.e., the desired quantity)
  // (4) Call the pegging function, for all the periods, to get the amount of "gap" or acquisition and net this from the consRate vector
  // (5) Loop through the subBOMS of this BOM arc
  // (6) Get the subVol vector of the substitute part and net this from the consRate vector
  // (7) Whatever is left in the consRate can be pegged to the original supply of the base part.

  int bomIndex, nBomArcs;
  checkWitRC(witGetOperationNBomEntries(witRun(),demandName.c_str(),&nBomArcs));
  for (bomIndex = 0; bomIndex < nBomArcs; bomIndex++)
    {
      char * consumedPartName;
      float * consRate;
      float * offset;
      std::vector<float> cumTotal(np);
      std::vector<float> localConsRate(np);
      int theOffset;

      int i;
      for(i=0; i<np; i++){
        cumTotal[i] = 0.f;
        localConsRate[i] = 0.f;
      }

      checkWitRC(witGetBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,&consumedPartName));
      checkWitRC(witGetBomEntryConsRate(witRun(),demandName.c_str(),bomIndex,&consRate));
      checkWitRC(witGetBomEntryOffset(witRun(),demandName.c_str(),bomIndex,&offset));
      std::string acquireOpName = getAcquireOperationFromWorkingName(consumedPartName);

      theOffset = - (int) offset[0];
      localConsRate[theOffset] = consRate[0];

      int lenLists;
      char ** operationNameList;
      int * execPeriodList;
      float * peggedExecVolList;
      int theIdx;
      
      checkWitRC(witGetDemandExecVolPegging ( witRun(),
                                   demandName.c_str(),
                                   demandName.c_str(),
                                   0,
                                   & lenLists,
                                   & operationNameList,
                                   & execPeriodList,
                                   & peggedExecVolList));

      //look for the acquireOperation in the returned operationNameList
      for (theIdx = 0; theIdx < lenLists; theIdx++)
        {
          if(acquireOpName == operationNameList[theIdx])
            { //found it
              if (execPeriodList[theIdx] == theOffset){
                cumTotal[execPeriodList[theIdx]] += peggedExecVolList[theIdx];
                //                std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << 
                //                  " GAP: " << peggedExecVolList[theIdx] << std::endl;
              }
            }
        }

      for (theIdx = 0; theIdx < lenLists; theIdx++)
        checkWitRC(witFree(operationNameList[theIdx]));
      
      checkWitRC(witFree (operationNameList));
      checkWitRC(witFree (execPeriodList));
      checkWitRC(witFree (peggedExecVolList));
      
      // Now take care of the subVols
      int nSubBomArcs, subBomIndex;
      checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),demandName.c_str(),bomIndex,&nSubBomArcs));
      for(subBomIndex = 0; subBomIndex<nSubBomArcs; subBomIndex++)
        {
          char * subPartConsumed;
          float * subVol;
          checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subPartConsumed));
          checkWitRC(witGetSubsBomEntrySubVol(witRun(),demandName.c_str(),bomIndex,subBomIndex,&subVol));
          if (subVol[theOffset]>0)
                {
                  float subQtyUsed = subVol[theOffset] * localConsRate[theOffset];
                  cumTotal[theOffset] += subQtyUsed;
                  //                                  std::cout << "  Demand:" << demandName << "  Period:" << execPeriodList[theIdx] << " Sub Resource:" 
                  //                                            << subPartConsumed << " Quantity: " << subQtyUsed << std::endl;
                }
          checkWitRC(witFree (subVol));
          checkWitRC(witFree (subPartConsumed));
        }

      for (i=0; i<np; i++)
        {
          float supplyQtyUsed = localConsRate[i] - cumTotal[i];
          //          if (supplyQtyUsed > 0)
            //                    std::cout << "  Demand:" << demandName << "  Period:" << i << " Supply Used:" 
            //                                    << supplyQtyUsed << std::endl;
        }
      
      checkWitRC(witFree (consRate));
      checkWitRC(witFree (consumedPartName));
      checkWitRC(witFree (offset));
    }
}


void ECCovptProblem::computePegging3(std::string demandName) 
{
  int np = getNPeriods();
  // (1) Call pegging on the demand 
  // (2) For the demand, loop through all the BOMs for that demand.  These will be "sort-layer" parts.
  // (2.5) For each "sort-layer" operation, loop through all the BOMs of that sort-layer operation, skipping the index 0 BOM entry, which is there for modeling tricks.
  // (3) For each BOM, get the consuming part and the consRate vector (i.e., the desired quantity) (Note:  There could be demand in different periods for the same resource)
  // (4) The execVol of the acquireOperation for a resource is the gap associated to the BOM arc that is in effect at offset t (or -t)
  // (5) Loop through the subBOMS of this BOM arc
  // (6) Get the subVol vector of the substitute part and net this from the consRate vector
  // (7) Whatever is left in the consRate can be pegged to the original supply of the base part.

  // (1) Call Wit's pegging function for this demand;  and get the appData for the engagement

  int lenLists;
  char ** operationNameList;
  int * execPeriodList;
  float * peggedExecVolList;
  int theIdx;

  int reqStartPer = getEngagementRequestedStartPeriod(textAfter(demandName,"engagement: "));  

  checkWitRC(witGetDemandExecVolPegging ( witRun(),
                                          demandName.c_str(),
                                          demandName.c_str(),
                                          reqStartPer,
                                          & lenLists,
                                          & operationNameList,
                                          & execPeriodList,
                                          & peggedExecVolList));

  RCPengagementAppData * appData;
  checkWitRC(witGetPartAppData(witRun(),demandName.c_str(),(void**)&appData));
  appData->clearPegging();

  int sortLayerBomIndex, nSortLayerBomArcs;
  checkWitRC(witGetOperationNBomEntries(witRun(),demandName.c_str(),&nSortLayerBomArcs));
  for (sortLayerBomIndex = 0; sortLayerBomIndex < nSortLayerBomArcs; sortLayerBomIndex++)
    {
      char * sortLayerConsumedPartName;

      checkWitRC(witGetBomEntryConsumedPart(witRun(),demandName.c_str(),sortLayerBomIndex,&sortLayerConsumedPartName));

      // make sure the consumed part is a sort layer part;  otherwise skip it


      if (beginsWith(sortLayerConsumedPartName, "sortLayer:")) {

        
        int nBomArcs, bomIndex;
        checkWitRC(witGetOperationNBomEntries(witRun(),sortLayerConsumedPartName,&nBomArcs));
        //(2.5)
        //can skip BomIndex:0 because it's just there as a modeling trick
        for (bomIndex = 1; bomIndex < nBomArcs; bomIndex ++){

          float localConsRate;  //This holds the BOM usage quantity
          float cumTotal = 0.f;  //
          char * consumedPartName;
          float * consRate;
          float * offset;
          int theOffset;
          
          // (3)
          checkWitRC(witGetBomEntryConsumedPart(witRun(),sortLayerConsumedPartName,bomIndex,&consumedPartName));
          checkWitRC(witGetBomEntryConsRate(witRun(),sortLayerConsumedPartName,bomIndex,&consRate));
          checkWitRC(witGetBomEntryOffset(witRun(),sortLayerConsumedPartName,bomIndex,&offset));
          
          std::string acquireOpName = getAcquireOperationFromWorkingName(consumedPartName);

          theOffset = - (int) offset[0];
          localConsRate = consRate[0];
          
          checkWitRC(witFree(offset));
          checkWitRC(witFree(consRate));

          // (4)  Now go find the pegged acquireOp's execution volume in period 'theOffset' from Wit's pegging computation.

          //look for the acquireOperation in the returned operationNameList
          for (theIdx = 0; theIdx < lenLists; theIdx++)
            {
              if(acquireOpName == operationNameList[theIdx])
                { //found it -- now see if it is in the right time period
                  if (execPeriodList[theIdx] == theOffset+reqStartPer){
                    cumTotal = peggedExecVolList[theIdx];
                    //                    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset+reqStartPer <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " GAP: " << cumTotal << std::endl;
                                  appData->addPeggedQuantityFromAcquisition(theOffset+reqStartPer,
       resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)),cumTotal);
                  }
                }
            }

          // (5) Now take care of the subVols  
          
          int nSubBomArcs, subBomIndex;
          checkWitRC(witGetBomEntryNSubsBomEntries(witRun(),sortLayerConsumedPartName,bomIndex,&nSubBomArcs));
          for(subBomIndex = 0; subBomIndex<nSubBomArcs; subBomIndex++)
            {
              char * subPartConsumed;
              float * subVol;
              float * subOffset;
              int theSubOffset;

              checkWitRC(witGetSubsBomEntryConsumedPart(witRun(),sortLayerConsumedPartName,bomIndex,subBomIndex,&subPartConsumed));
              checkWitRC(witGetSubsBomEntrySubVol(witRun(),sortLayerConsumedPartName,bomIndex,subBomIndex,&subVol));    
              checkWitRC(witGetSubsBomEntryOffset(witRun(),sortLayerConsumedPartName,bomIndex,subBomIndex,&subOffset));
              theSubOffset = - (int) subOffset[0];
              if (theSubOffset == theOffset + reqStartPer){
                
                if (subVol[reqStartPer]>0)
                  {
                    float subQtyUsed = subVol[reqStartPer] * localConsRate;
                    cumTotal += subQtyUsed;
                    //                    std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  PERIOD:" << theOffset + reqStartPer 
                    //                              << " RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUB RESOURCE:" 
                                   //                              << baseNameFromWorkingResourceName(subPartConsumed) << " QUANTITY SUBBED: " << subQtyUsed << std::endl;
                    appData->addPeggedQuantityFromSubstitution(theOffset+reqStartPer,resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)),subQtyUsed,resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(subPartConsumed)));
                  }
              }
              checkWitRC(witFree (subOffset));
              checkWitRC(witFree (subVol));
              checkWitRC(witFree (subPartConsumed));
            }

          float supplyQtyUsed = localConsRate - cumTotal;
          if (supplyQtyUsed > 0){
            //            std::cout << "  DEMAND:" << textAfter(demandName, "engagement: ") << "  Period:" << theOffset+reqStartPer <<" RESOURCE: " << baseNameFromWorkingResourceName(consumedPartName) << " SUPPLY USED: " 
            //                          << supplyQtyUsed << std::endl;
            appData->addPeggedQuantityFromSupply(theOffset+reqStartPer,
                                                 resourceIdentifierValuesFromResourceName(baseNameFromWorkingResourceName(consumedPartName)), supplyQtyUsed);
          }
          checkWitRC(witFree (consumedPartName));
        }
      }
      checkWitRC(witFree (sortLayerConsumedPartName));
    }

  for (theIdx = 0; theIdx < lenLists; theIdx++)
    checkWitRC(witFree(operationNameList[theIdx]));
    
  checkWitRC(witFree (operationNameList));
  checkWitRC(witFree (execPeriodList));
  checkWitRC(witFree (peggedExecVolList));

}

void ECCovptProblem::optimalGapGlut(){
  
  // (1) Run witOptImplode
  // (2) gap = negative part of (exogQty - workingQty); glut = positive part of (exogQty - workingQty)
  checkWitRC(witWriteData(witRun(),"witOGG.dat"));
  checkWitRC(witOptImplode(witRun()));
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  
  // loop once for each resource
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::vector<float> gapQty;    
    std::vector<float> glutQty;    
    std::string workingRes;
    std::vector<float> exogSup;
    std::vector<float> workingQty;
    workingRes = workingResourceName(names[r]);
    exogSup = getResourceSupplyQuantity(names[r]);
    //    workingQty = getResourceWorkingQuantity(names[r]);
    // NOTE:  The workingAppData isn't being used here for the workingQty.  The workingQty is being set to the execVol of the working resource.  
    workingQty = getOptimalWorkingQuantity(names[r]);
    
    unsigned int t;
    for (t=0; t<exogSup.size(); t++){
      float delta = exogSup[t] - workingQty[t];
      //      printf("%d %f %f %f\n", t, delta, exogSup[t], workingQty[t]);
      if (delta>=0) {
        gapQty.push_back(0.0f);
        glutQty.push_back(delta);
      }
      else {
        gapQty.push_back(-delta);
        glutQty.push_back(0.0f);
      }
      setResourceGapQuantity(names[r],t,gapQty[t]);      
      setResourceGlutQuantity(names[r],t,glutQty[t]);
    }
  }
}

void ECCovptProblem::optimalResourceAction()
{
  checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
  checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
  checkWitRC(witWriteData(witRun(),"wit3opt.dat"));
  checkWitRC(witOptImplode(witRun()));
  saveOptimalResourceActionResults();
}


void ECCovptProblem::priorityResourceAction()
{
  // (1) Get the offset (leadtime) from the acquire BOP; set the productRate of this operation to zero
  // (2) Create a bunch of BOPs from the acquire operation up to the working
  // part, one for each period, setting the offset and the lastestPeriod on each; mark SelForDel
  // (3) Set the supply for period zero on the working part to the exogenous supply at period zero
  // (4) Delete the enable operation and the bench part.  ***** don't need this now
  // (5) Run witHeurImplode
  // (6) Do some post processing and pick off the answers
  // (7) reset productRate of acquire operation to 1; set the supply for period zero of the working part to zero; 
  // do a WitPurge to remove the BOPs added in (2)
  
  int np=getNPeriods();
  std::vector<RCPvectorString> names;
  
  int numResources;
  getResourceNames(names);
  numResources = names.size();
  
  
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::string acquireOp,workingRes;
    
    acquireOp = acquireResourceOperationName(names[r]);
    workingRes = workingResourceName(names[r]);
    
    float * aov;
    checkWitRC(witGetBopEntryOffset(mutableWitRun(),acquireOp.c_str(),0,&aov));
    int acqOffset = (int) floor(aov[0]);
    checkWitRC(witFree(aov));
    
    int t;
    float * zeroVec = floatToFloatStar(0.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,zeroVec));
    delete [] zeroVec;
    
    
    // (2) Add the new BOPs from the acquire operation directly to the working resource part
    // and set the offset and latestPeriod  NOTE: acqOffset is non-positive 
    int i;
    for (i=0; i<np+acqOffset; i++)
    {
      checkWitRC(witAddBopEntry(witRun(),acquireOp.c_str(),workingRes.c_str()));
      float * vecOffset = floatToFloatStar((float) -i+acqOffset);
      checkWitRC(witSetBopEntryOffset(witRun(),acquireOp.c_str(),i+1,vecOffset));
      checkWitRC(witSetBopEntryLatestPeriod(witRun(),acquireOp.c_str(),i+1,np-i-1+acqOffset));
      checkWitRC(witSetBopEntrySelForDel(witRun(),acquireOp.c_str(),i+1,WitTRUE));
      delete [] vecOffset;
    }
    
    // (3) Set the supply for period zero on the working part to the exogenous supply at period zero
    std::vector<float> exogSup;
    
    exogSup = getResourceSupplyQuantity(names[r]);
    
    for (t=0; t<np; t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,exogSup[0]);
  }
  
  // (4) Delete the enable operation and the bench part. ***DPC  mark the parts for purging
  //  checkWitRC(witPurgeData(witRun()));
  
  // (5) Run witHeurImplode
  checkWitRC(witHeurImplode(witRun()));
  
  // (6) Do some post processing 
  // Loop through each working resource and
  // (a) compute the minToGo(i) = min over { i <= t <= np} of residualVol(t)
  // (b) releaseQty(t) = minToGo(t) - minToGo(t-1)
  // (c) cumulativeReleaseQty(t) = cumulativeReleaseQty(t-1) + releaseQty(t)
  // (d) benchQty(t) = residualVol(t) - cumulativeReleaseQty(t)
  // (e) workingQty = consVol
  // Store the releaseQty, benchQty and workingQty in the appData
  
  for ( r=0; r<numResources; ++r ) {
    std::string workingRes, acquireRes;
    workingRes = workingResourceName(names[r]);
    acquireRes = acquireResourceOperationName(names[r]);
    std::vector<float> minToGo(np), residualQty, releaseQty(np), cumulativeReleaseQty(np), benchQty(np), workingQty(np), acquireQty;
    workingQty = witGetNameAttribute(witGetPartConsVol, workingRes);
    residualQty = witGetNameAttribute(witGetPartResidualVol, workingRes);
    acquireQty = witGetNameAttribute(witGetOperationExecVol, acquireRes);
    minToGo[np-1] = residualQty[np-1];
    int i;
    for (i=np-2; i>=0; i--){
      if (residualQty[i] <= minToGo[i+1])
        minToGo[i] = residualQty[i];
      else
        minToGo[i] = minToGo[i+1];
    }
    releaseQty[0] = minToGo[0];
    for (i=1; i<np; i++)
      releaseQty[i] = minToGo[i] - minToGo[i-1];
    cumulativeReleaseQty[0] = releaseQty[0];
    for (i=1; i<np; i++)
      cumulativeReleaseQty[i] = releaseQty[i] + cumulativeReleaseQty[i-1];
    for (i=0; i<np; i++)
      benchQty[i] = residualQty[i] - cumulativeReleaseQty[i];
    //write the answer into appData
    for (i=0; i<np; i++){
      setResourceWorkingQuantity(names[r],i,workingQty[i]);
      setResourceReleaseQuantity(names[r],i,releaseQty[i]);
      setResourceAcquireQuantity(names[r],i,acquireQty[i]);
      setResourceBenchQuantity(names[r],i,benchQty[i]);
    }
  }
  
  // (7) Reset productRate of acquireOp to one;  reset supplyVol of working resource in period zero to zero; purge
  // the wit model of the added BOP arcs
  for ( r=0; r<numResources; ++r ) {
    std::string acquireOp,workingRes;
    
    acquireOp = acquireResourceOperationName(names[r]);
    workingRes = workingResourceName(names[r]);
    
    int t;
    float * oneVec = floatToFloatStar(1.0f);
    checkWitRC(witSetBopEntryProductRate(witRun(),acquireOp.c_str(),0,oneVec));
    delete [] oneVec;
    
    for (t=0; t<np; t++)
      witSetNameAttribute(witGetPartSupplyVol,witSetPartSupplyVol,workingRes,t,0.0f);
  }
  checkWitRC(witPurgeData(witRun()));
}

void ECCovptProblem::saveMrpResults()
{
  // Save the MRP gross requirements away in the app data for the working resource
  // Get list of all resources
  std::vector<RCPvectorString> names;
  
  getResourceNames(names);
  int numResources = names.size();
  
  // loop once for each resource
  int r;
  for ( r=0; r<numResources; ++r ) {
    std::vector<float> grossQty;
    grossQty = getResourceMRPGrossQuantity(names[r]);
    
    for (unsigned int t=0; t<grossQty.size(); t++ ){
             setResourceMrpQuantity(names[r],t,grossQty[t]);
    }
  }
}


void ECCovptProblem::saveOptimalResourceActionResults()
{
  // Save the working, release, acquire and bench results from the Optimal Resource Action plan in the app data for the working resource
  // Get list of all resources
  std::vector<RCPvectorString> resNames;
  int numResources;
  
  getResourceNames(resNames);
  numResources = resNames.size();
  
  // loop once for each resource
  int r;
  for ( r=0; r<numResources; ++r ) 
  {
    std::string enableOpName, benchResName, acquireOpName, scrapResName, enableScrapResName;
    std::vector<float> workingQty, releaseQty, acquireQty, benchQty, workingScrapQty, benchScrapQty;
    
    enableOpName=enableResourceOperationName(resNames[r]);
    benchResName=benchResourceName(resNames[r]);
    acquireOpName=acquireResourceOperationName(resNames[r]);
    scrapResName=scrapResourceName(resNames[r]);
    enableScrapResName=enableScrapResourceName(resNames[r]);

    workingQty = witGetNameAttribute(witGetOperationExecVol,enableOpName);
    workingScrapQty = witGetNameAttribute(witGetOperationExecVol,enableScrapResName);

    releaseQty = witGetNameAttribute(witGetOperationExecVol,scrapResName);  

    acquireQty = witGetNameAttribute(witGetOperationExecVol,acquireOpName);

    benchQty = witGetNameAttribute(witGetPartStockVol,benchResName);
    benchScrapQty = witGetNameAttribute(witGetPartScrapVol, scrapResName);
    
    //    int relLT = (int) getResourceReleaseTime(resNames[r]);
    for (unsigned int t=0; t<workingQty.size(); t++ ){
      setResourceWorkingQuantity(resNames[r],t,workingQty[t]+workingScrapQty[t]);
      //      if (t < relLT)
      //      setResourceReleaseQuantity(resNames[r],t,0.f);
      // else
      //setResourceReleaseQuantity(resNames[r],t,releaseQty[t-relLT]);
      setResourceReleaseQuantity(resNames[r],t,releaseQty[t]);
      setResourceAcquireQuantity(resNames[r],t,acquireQty[t]);
      setResourceBenchQuantity(resNames[r],t,benchQty[t]+benchScrapQty[t]);
    }
  }
}


void ECCovptProblem::gapGlut()
{
  //getTimer().printElapsedTime("in gapGlut");
  RCPoperationBomSubBomIndices subBomsAdded;

  checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
  checkWitRC(witWriteData(witRun(),"wit0.dat"));

  presolve04Feb(subBomsAdded);
  getTimer().printElapsedTime("after presolve in gapGlut");

  //  presolveForGapGlut();
  checkWitRC(witMrp(witRun()));
  getTimer().printElapsedTime("after witMrp");

  checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
  checkWitRC(witWriteData(witRun(),"wit1.dat"));
  getTimer().printElapsedTime("after witWriteData in gapGlut");

  saveMrpResults();
  getTimer().printElapsedTime("after saveMrpResults in gapGlut");

  if (getAlgorithmName() == "priorityPlan"){
    if (getFormatName() == "04Feb")
      priorityGapGlut1(); //$$$$$ 
    else if (getFormatName() == "03Dec")
      priorityGapGlut2();
    else
      priorityGapGlut();
  }
  else
    {
      // assume this is the optimalGapGlut
      presolveForOptimalGapGlut();
      checkWitRC(witSetOptWithLotSizes(witRun(),WitFALSE));
      optimalGapGlut();
      postsolveForOptimalGapGlut();
    }
    postsolve(subBomsAdded);

    // Reset the revenue and demand for each engagement back to zero
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    float * zeroQty = floatToFloatStar(0.0f);
    for( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      checkWitRC(witSetDemandObj1ShipReward(witRun(),theEngagement.c_str(),theEngagement.c_str(),zeroQty));
      checkWitRC(witSetDemandDemandVol(witRun(),theEngagement.c_str(),theEngagement.c_str(),zeroQty));
    }
    
    delete[] zeroQty;

    checkWitRC(witWriteData(witRun(),"wit2.dat"));
    getTimer().printElapsedTime("done solving in gapGlut");

}

void ECCovptProblem::resourceAction()
{
  checkWitRC(witSetMesgFileAccessMode(witRun(),WitTRUE,"w"));
  
  RCPoperationBomSubBomIndices subBomsAdded;
  presolve04Feb(subBomsAdded);
  
  checkWitRC(witMrp(witRun()));
  saveMrpResults();
  //  checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
  if (getAlgorithmName() == "priorityPlan")
  {
    //checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
    priorityResourceAction();
  }
  else
  {
    //    checkWitRC(witSetOptWithLotSizes(witRun(),WitTRUE)); 
    optimalResourceAction();
  }
  checkWitRC(witWriteData(witRun(),"wit4.dat"));
  
  postsolve(subBomsAdded);
}
#endif


#if 0
//-------------------------------------------------------------------------
// algorithm and problem Methods
//-------------------------------------------------------------------------
void ECCovptProblem::setAlgorithmName(const std::string & algName){
  algorithmName_ = algName;
}

void ECCovptProblem::setProblemName(const std::string & probName){
  problemName_=probName;
}

void ECCovptProblem::setFormatName(const std::string & forName){
  formatName_=forName;
}

std::string ECCovptProblem::getAlgorithmName(){
  return algorithmName_;
}

std::string ECCovptProblem::getProblemName(){
  return problemName_;
}

std::string ECCovptProblem::getFormatName(){
  return formatName_;
}

bool ECCovptProblem::isLongFormat(){
  if (resourceIdentifierNames_.size()!=0) return true;
  if (getFormatName() == "04Feb")
    return true;
  else
    return false;
}
#endif


#if 0
//-------------------------------------------------------------------------
// Engagement Name Methods
//-------------------------------------------------------------------------
std::string ECCovptProblem::engagementName(const std::string & engagementName )
{
  return "engagement: "+engagementName;
}

std::string ECCovptProblem::engagementFromEngagementName(const std::string & engName)
{
  return textAfter(engName,"engagement: ");
}

std::string ECCovptProblem::demandTypeFromEngagementName(const std::string & engName)
{
  std::string demandType;
  demandType = textBetween(engName,"*","*");
  
  return demandType;
}

std::string ECCovptProblem::sortLayerEngagementName(const std::string & engagementName, const std::string & orderName)
{
  return "sortLayer: " + engagementName + " order: " + orderName;
}


//-------------------------------------------------------------------------
// Resource Name Methods
//-------------------------------------------------------------------------
std::string ECCovptProblem::acquireResourceOperationName(const std::vector<std::string> &resourceAttributeVector )const
{
  return "acquire: "+baseResourceName(resourceAttributeVector);
}


std::string ECCovptProblem::benchResourceName(const std::vector<std::string> &resourceAttributeVector )const
{
  return "bench: " + baseResourceName(resourceAttributeVector);
}

std::string ECCovptProblem::getBenchFromWorkingName(const std::string &workingName){
  return "bench: " + textAfter(workingName,"working: ");
}

std::string ECCovptProblem::getScrapFromWorkingName(const std::string &workingName){
  return "scrap: " + textAfter(workingName,"working: ");
}

std::string ECCovptProblem::getEnableScrapFromWorkingName(const std::string &workingName){
  return "enableScrap: " + textAfter(workingName,"working: ");
}

std::string ECCovptProblem::getAcquireOperationFromWorkingName(const std::string &workingName){
  return "acquire: " + textAfter(workingName,"working: ");
}


std::string ECCovptProblem::enableResourceOperationName(const std::vector<std::string> &resourceAttributeVector )const
{
  return "enable: "+baseResourceName(resourceAttributeVector);
}

std::string ECCovptProblem::workingResourceName(const std::vector<std::string> &resourceIdentifierValues )const
{
  return "working: "+baseResourceName(resourceIdentifierValues);
}

std::string ECCovptProblem::scrapResourceName(const std::vector<std::string> &resourceIdentifierValues )const
{
  return "scrap: "+baseResourceName(resourceIdentifierValues);
}

std::string ECCovptProblem::enableScrapResourceName(const std::vector<std::string> &resourceIdentifierValues )const
{
  return "enableScrap: "+baseResourceName(resourceIdentifierValues);
}

std::string ECCovptProblem::baseResourceName(const std::vector<std::string> &resourceAttributeVector )const
{ 
  std::string retVal;
  int numAttributes = resourceAttributeVector.size();
  //int x = getResourceIdentifierNames().size();
  //assert( getResourceIdentifierNames().size() ==  numAttributes );
  for (int i=0; i<numAttributes-1; i++) {
    std::string attributeName = getResourceIdentifierNames()[i];
    std::string attributeValue = resourceAttributeVector.at(i);
    retVal = retVal + attributeName + ": " + attributeValue + " ";
  }
  std::string attributeName = getResourceIdentifierNames()[numAttributes-1];
  std::string attributeValue = resourceAttributeVector.at(numAttributes-1);
  retVal = retVal + attributeName + ": " + attributeValue;
  return retVal;
}


std::string ECCovptProblem::baseNameFromWorkingResourceName(const std::string & workingName)
{
  return textAfter(workingName,"working: ");
}


//-------------------------------------------------------------------------
// Bom Name Methods
//------------------------------------------------------------------------- 
std::string ECCovptProblem::bomName(const std::string & engagementName, const std::vector<std::string> &resourceIdentifierValues)const
{
  std::string retVal="bom op: "+engagementName + " ";
  for (unsigned int i=0; i<resourceIdentifierValues.size()-1; i++) {
    retVal = retVal+getResourceIdentifierNames()[i] + ": " + resourceIdentifierValues.at(i) + " ";
  }
  retVal = retVal + getResourceIdentifierNames()[resourceIdentifierValues.size()-1] + ": " + resourceIdentifierValues.at(resourceIdentifierValues.size()-1);
  return retVal;
}


std::string ECCovptProblem::engagementFromBomName(const std::string & bomName)const
{
  std::string nextToken = " "+getResourceIdentifierNames()[0];
  return textBetween(bomName,"bom op: ",nextToken);
}
#endif




#if 0
//--------------------------------------------------------
// Get Bom Entry Index
// Return the bom entry index that matches input parms
// -1 returned if bomEntryIndex does not exist
int ECCovptProblem::getBomEntryIndex( 
                                 const std::string & opName, 
                                 const std::string & partName,
                                 int period
                                 ) const
{
  int retVal = -1;
  
  //int nP = getNPeriods();
  
  // Get current number of boms connected to operation
  int nBoms;
  checkWitRC(witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms));
  
  int bei;
  for ( bei=0; bei<nBoms; bei++ ) {
    char * consPartFromWit;
    checkWitRC(witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bei,&consPartFromWit));
    if(partName==consPartFromWit) {
      // Operation and Part match, now see if bomEntry has correct period    
      RCPbomAppData * appData;
      checkWitRC(witGetBomEntryAppData(mutableWitRun(),opName.c_str(),bei,(void**)&appData));
      int bomEntryPeriod = appData->getPeriod();
      if ( bomEntryPeriod == period ) {      
        retVal=bei;
      }
      if(retVal!=-1) {        
        checkWitRC(witFree(consPartFromWit));
        break;
      }
    } 
    checkWitRC(witFree(consPartFromWit));
  }
  
  return retVal;
}

//--------------------------------------------------------
// Get Bom Entry Indices
// Return the bom entry indices that matches input parms
std::vector<int> ECCovptProblem::getBomEntryIndex( 
                                              const std::string & opName, 
                                              const std::string & partName
                                              ) const
{
  std::vector<int> retVal;
  
  //int nP = getNPeriods();
  
  // Get current number of boms connected to operation
  assert(witOperationExists(opName) );
  int nBoms;
  checkWitRC(witGetOperationNBomEntries(mutableWitRun(),opName.c_str(),&nBoms));
  
  int bei;
  for ( bei=0; bei<nBoms; bei++ ) {
    char * consPartFromWit;
    checkWitRC(witGetBomEntryConsumedPart(mutableWitRun(),opName.c_str(),bei,&consPartFromWit));
    if(partName==consPartFromWit) {
      // Operation and Part match     
      retVal.push_back(bei);
    }
    checkWitRC(witFree(consPartFromWit));
  }
  return retVal;
}
#endif

d64 8
a71 1292
// default constructor
ECCovptProblem::ECCovptProblem()
:
SCOproblemBase(),
materialNames_()
{
  //checkWitRC(witSetExecEmptyBom(witRun(),WitTRUE));
}

// destructor
ECCovptProblem::~ECCovptProblem()
{
  gutsOfDestructor();
}

// copy constructor
ECCovptProblem::ECCovptProblem( const ECCovptProblem& source ):
SCOproblemBase(source),
materialNames_()
{
  gutsOfCopy(source);
}

// assignment operator
ECCovptProblem&
ECCovptProblem::operator=(const ECCovptProblem& rhs)
{  
  if (this != &rhs) { 
    SCOproblemBase::operator=(rhs);
    gutsOfCopy(rhs);
  }
  return *this;
}

// copy object
void ECCovptProblem::gutsOfCopy( const ECCovptProblem& source )
{
  materialNames_ = source.materialNames_;
  
#if 0
  // copy engagement appData
  unsigned int e;
  std::vector<std::string> engagementNames;
  std::vector<std::string> engagementLocs;
  getEngagementNames(engagementNames);
  for ( e=0; e<engagementNames.size(); ++e ) { 
    std::string theEngagement = engagementName(engagementNames[e]);
    RCPengagementAppData * srcAppData;    
    RCPengagementAppData * sinkAppData;
    checkWitRC(witGetPartAppData(source.mutableWitRun(),theEngagement.c_str(),(void**)&srcAppData));
    sinkAppData = new RCPengagementAppData(*srcAppData);    
    checkWitRC(witSetPartAppData(witRun(),theEngagement.c_str(),sinkAppData));
  }
  
  // copy rcp bom appData
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries));
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        RCPbomAppData * srcAppData;    
        RCPbomAppData * sinkAppData;
        checkWitRC(witGetBomEntryAppData(source.mutableWitRun(),theEngagement.c_str(),b,(void**)&srcAppData));
        sinkAppData = new RCPbomAppData(*srcAppData);    
        checkWitRC(witSetBomEntryAppData(witRun(),theEngagement.c_str(),b,sinkAppData));
        
      } // end of b loop
    } // end of e loop
  } // finished copying rcp bom appData
  
  // copy resource appData
  {
    unsigned int r;
    //std::vector<std::string> jobRoles,skillSets,LOBs,sources,locNames;
    std::vector<RCPvectorString> names;
    getResourceNames(names);
    for ( r=0; r<names.size(); ++r ) { 
      std::string resourceName = workingResourceName(names[r]);
      RCPresourceAppData * srcAppData;  
      RCPresourceAppData * sinkAppData;  
      checkWitRC(witGetPartAppData(mutableWitRun(),resourceName.c_str(),(void**)&srcAppData));
      sinkAppData = new RCPresourceAppData(*srcAppData);   
      checkWitRC(witSetPartAppData(witRun(),resourceName.c_str(),sinkAppData)); 
    }
  }
#endif
  
  
}

// destructor
void ECCovptProblem::gutsOfDestructor()
{
#if 0
  // delete engagement appData
  unsigned int e;
  std::vector<std::string> engagementNames;
  getEngagementNames(engagementNames);
  for ( e=0; e<engagementNames.size(); ++e ) { 
    std::string theEngagement = engagementName(engagementNames[e]);
    RCPengagementAppData * srcAppData;  
    checkWitRC(witGetPartAppData(mutableWitRun(),theEngagement.c_str(),(void**)&srcAppData));
    delete srcAppData;
  }
  
  // delete rcp bom appData
  {
    // Loop over all engagements
    std::vector<std::string> engagementNames;
    getEngagementNames(engagementNames);
    unsigned int e;
    for ( e=0; e<engagementNames.size(); ++e ) {
      std::string theEngagement = engagementName(engagementNames[e]);
      // Loop once for each bomEntry connected to engagement operation
      int nBomEntries;
      checkWitRC(witGetOperationNBomEntries(mutableWitRun(),theEngagement.c_str(),&nBomEntries));
      int b;
      for ( b=0; b<nBomEntries; ++b ) {
        
        RCPengagementAppData * srcAppData;
        checkWitRC(witGetBomEntryAppData(mutableWitRun(),theEngagement.c_str(),b,(void**)&srcAppData));
        delete srcAppData;
        
      } // end of b loop
    } // end of e loop
  } // finished deleting rcp bom appData
  
  // delete resource appData
  {
    int r;
    
    std::vector<RCPvectorString> names;
    getResourceNames(names);
    int numResources = names.size();
    
    for ( r=0; r<numResources; ++r ) { 
      RCPresourceAppData * srcAppData;
      std::string workingResWitName = workingResourceName(names[r]);
      checkWitRC(witGetPartAppData(mutableWitRun(),workingResWitName.c_str(),(void**)&srcAppData));
      delete srcAppData;
    }
  }
#endif
  
}



#ifdef NDEBUG
#undef NDEBUG
#endif
//------------------------------------------------------------------------------
// Test function
//------------------------------------------------------------------------------
void
ECCovptProblem::test()
{
  CoinRelFltEq eq;
  
  {
    ECCovptProblem prob;
    
    prob.setNPeriods(12);
    assert( prob.getNPeriods() == 12 );
    
    
  }
  
  
#if 0  
  // Test engagements for throwing internal exception
  {
    
    ECCovptProblem prob;
    
    prob.setNPeriods(2);
    
    prob.addEngagement("e1");  
    prob.addEngagement("e2");
    
    assert(  prob.engagementExists("e1") );
    assert(  prob.engagementExists("e2") );
    assert( !prob.engagementExists("e3") );
    
    assert( prob.getEngagementRevenue("e1") == 0.0f );
    prob.setEngagementRevenue("e1",1.234f);
    assert( prob.getEngagementRevenue("e1") == 1.234f );
    {
      bool except = false;
      try {
        float revenue;
        // The following line should throw an RCPOptIntException
        revenue = prob.getEngagementRevenue("e4");
        // shouldn't go to the next line
        assert( revenue == -1234.0);
      }
      catch ( RCPOptIntException e ) {
        except = true;
      }
      assert( except );
    }
  }
#endif

  {
    ECCovptProblem prob;
    
    prob.setNPeriods(2);

    assert(  !prob.materialExists("e1") );
    
    prob.addMaterial("e1");  
    prob.addMaterial("e2");
    
    assert(  prob.materialExists("e1") );
    assert(  prob.materialExists("e2") );
    assert( !prob.materialExists("e3") );
    
    assert( prob.getMaterialSupply("e1").size() == 2 );
    assert( prob.getMaterialSupply("e1")[0] == 0.0f );
    assert( prob.getMaterialSupply("e1")[1] == 0.0f );
    prob.setMaterialSupply("e1",0,1.234f);
    assert( prob.getMaterialSupply("e1").size() == 2 );
    assert( prob.getMaterialSupply("e1")[0] == 1.234f );
    assert( prob.getMaterialSupply("e1")[1] == 0.0f );
    prob.setMaterialSupply("e1",1,2.234f);
    assert( prob.getMaterialSupply("e1").size() == 2 );
    assert( prob.getMaterialSupply("e1")[0] == 1.234f );
    assert( prob.getMaterialSupply("e1")[1] == 2.234f );
    
        
    std::vector<std::string> names;
    prob.getMaterialNames(names);
    assert( names.size()==2 );
    assert( names[0]=="e1" || names[1]=="e1" );
    assert( names[0]=="e2" || names[1]=="e2" );
    
    
  }
  
#if 0
  // Test resources
  {
    ECCovptProblem prob;
    prob.setNPeriods(4);
    
    prob.addResourceIdentifierName("jobRole");
    prob.addResourceIdentifierName("skillSet");
    prob.addResourceIdentifierName("LOB");
    prob.addResourceIdentifierName("source");
    prob.addResourceIdentifierName("locName");
    
    assert( prob.resourceIdentifierNameExists("jobRole") );
    assert( !prob.resourceIdentifierNameExists("jobRoleXX") );
    
    assert( prob.getResourceIdentifierPriority("jobRole") == 0 );
    prob.setResourceIdentifierPriority("jobRole",123);
    assert( prob.getResourceIdentifierPriority("jobRole") == 123 );

    prob.setResourceIdentifierPriority("skillSet",456);
    assert( prob.getResourceIdentifierPriority("skillSet") == 456 );

    // test getResourceIdentifiersSortedByPriority is returning sorted list
    {
      std::vector<std::string> resIdsSortByPriority = prob.getResourceIdentifiersSortedByPriority();
      std::vector<std::string> resIds = prob.getResourceIdentifierNames();
      int sortedSize = resIdsSortByPriority.size();
      int unsortedSize = resIds.size();
      assert( sortedSize == unsortedSize );
      assert (resIdsSortByPriority[0] == "jobRole");
      assert (resIdsSortByPriority[1] == "skillSet");
      assert (resIdsSortByPriority[2] == "LOB");
      assert (resIdsSortByPriority[3] == "locName");
      assert (resIdsSortByPriority[4] == "source");

      //      int r;
      //      for ( r=1; r<resIdsSortByPriority.size(); ++r ) {
      //        int p0 = prob.getResourceIdentifierPriority(resIdsSortByPriority[r-1]);
      //        int p1 = prob.getResourceIdentifierPriority(resIdsSortByPriority[r  ]);
      //        assert( p0 <= p1 );
      //}
    }

    
    RCPvectorString res1;
    res1.push_back("r1");
    res1.push_back("s1");
    res1.push_back("LOB1");
    res1.push_back("src1");
    res1.push_back("l1");
    prob.addResource(res1);
    //prob.addResource("r1","s1", "LOB1","src1","l1");  
    
    RCPvectorString res2;
    res2.push_back("r2");
    res2.push_back("s2");
    res2.push_back("LOB2");
    res2.push_back("src2");
    res2.push_back("l2");
    prob.addResource(res2);
    //rob.addResource("r2","s2","LOB2","src2","l2");
    
    float time = prob.getResourceAcquireTime(res1);
    //float time = prob.getResourceAcquireTime("r1","s1","LOB1","src1","l1");
    assert( time == 0.f);
    prob.setResourceAcquireTime(res1, 2.f);
    assert ( prob.getResourceAcquireTime(res1) == -2.f ); //note that we negate the
    //acquire time inside setResourceAcquireTime
    //so that logically it can be positive
    
    assert( prob.getResourceAcquireCost(res1) == 0 );
    prob.setResourceAcquireCost(res1, 100.f);
    assert ( prob.getResourceAcquireCost(res1) == 100.f );
    
    std::vector<RCPvectorString> resNames;
    prob.getResourceNames(resNames);
    assert(resNames.size()==2);
    assert( resNames[0][0]=="r1" || resNames[1][0]=="r1" );
    assert( resNames[0][0]=="r2" || resNames[1][0]=="r2" );
    
    assert( resNames[0][1]=="s1" || resNames[1][1]=="s1" );
    assert( resNames[0][1]=="s2" || resNames[1][1]=="s2" );
    
    assert( resNames[0][2]=="LOB1" || resNames[1][2]=="LOB1" );
    assert( resNames[0][2]=="LOB2" || resNames[1][2]=="LOB2" );
    
    assert( resNames[0][3]=="src1" || resNames[1][3]=="src1" );
    assert( resNames[0][3]=="src2" || resNames[1][3]=="src2" );
    
    assert( resNames[0][4]=="l1" || resNames[1][4]=="l1" );
    assert( resNames[0][4]=="l2" || resNames[1][4]=="l2" );
    
    // Test to ensure SupplyQuantity defaults to 0
    std::vector<float> sq = prob.getResourceSupplyQuantity(res2);
    assert( sq.size() == 4);
    int t;
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==0.0f );
    
    std::vector<float> sqOrig = sq;
    
    // Test SupplyQuantity Set/Get
    sqOrig[2]=5.0f;
    prob.setResourceSupplyQuantity(res2,2,sqOrig[2]);
    sq = prob.getResourceSupplyQuantity(res2);
    
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==sqOrig[t] );
    
    // Test again SupplyQuantity Set/Get
    sqOrig[0]=2.0f;
    prob.setResourceSupplyQuantity(res2,0,sqOrig[0]);
    sq = prob.getResourceSupplyQuantity(res2);
    
    for ( t=0; t<4; ++t ) 
      assert( sq[t]==sqOrig[t] );
    
    prob.setResourceFixedCost(res1, 0, 1.0f);
    prob.setResourceFixedCost(res1, 1, 2.0f);
    prob.setResourceFixedCost(res1, 2, 3.0f);
    prob.setResourceFixedCost(res1, 3, 2.0f);
    
    std::vector<float> resourceCost = prob.getResourceFixedCost(res1);
    assert( resourceCost.size() == 4);
    assert( resourceCost[0]==1.0f );
    assert( resourceCost[1]==2.0f );
    assert( resourceCost[2]==3.0f );
    assert( resourceCost[3]==2.0f );
    

  }
  
  
  // Test bom
  {
    ECCovptProblem prob;
    prob.setNPeriods(4);
    
    prob.addResourceIdentifierName("jobRole");
    prob.addResourceIdentifierName("skillSet");
    prob.addResourceIdentifierName("LOB");
    prob.addResourceIdentifierName("source");
    prob.addResourceIdentifierName("locName");
    
    RCPvectorString res1;
    res1.push_back("r1");
    res1.push_back("s1");
    res1.push_back("LOB1");
    res1.push_back("src1");
    res1.push_back("l1");
    prob.addResource(res1);  
    
    RCPvectorString res2;
    res2.push_back("r2");
    res2.push_back("s2");
    res2.push_back("LOB2");
    res2.push_back("src2");
    res2.push_back("l1");
    prob.addResource(res2);
    
    prob.addEngagement("e1");
    
    std::vector<std::string> engagementNames;
    std::vector<RCPvectorString> resNames;
    prob.getBomNames(engagementNames,resNames);
    assert( resNames.size()==0 );
    assert( engagementNames.size()==0);
    
    // test add bom
    assert( !prob.bomExists("e1",res1) );
    assert( prob.getEngagementConsumedResources("e1").size() == 0 );
    prob.addBom("e1",res1);
    assert( prob.bomExists("e1",res1) );
    assert( prob.getEngagementConsumedResources("e1").size() == 1 );
    assert( prob.getEngagementConsumedResources("e1")[0][0]=="r1" );
    assert( prob.getEngagementConsumedResources("e1")[0][1]=="s1" );
    assert( prob.getEngagementConsumedResources("e1")[0][2]=="LOB1" );
    assert( prob.getEngagementConsumedResources("e1")[0][3]=="src1" );
    assert( prob.getEngagementConsumedResources("e1")[0][4]=="l1" );
    
    // test add another bom
    assert( !prob.bomExists("e1",res2) );
    prob.addBom("e1",res2);
    assert( prob.bomExists("e1",res2) );
    assert( prob.getEngagementConsumedResources("e1").size() == 2 );
    assert( prob.getEngagementConsumedResources("e1")[0][0]=="r1" );
    assert( prob.getEngagementConsumedResources("e1")[0][1]=="s1" );
    assert( prob.getEngagementConsumedResources("e1")[0][2]=="LOB1" );
    assert( prob.getEngagementConsumedResources("e1")[0][3]=="src1" );
    assert( prob.getEngagementConsumedResources("e1")[0][4]=="l1" );
    assert( prob.getEngagementConsumedResources("e1")[1][0]=="r2" );
    assert( prob.getEngagementConsumedResources("e1")[1][1]=="s2" );
    assert( prob.getEngagementConsumedResources("e1")[1][2]=="LOB2" );
    assert( prob.getEngagementConsumedResources("e1")[1][3]=="src2" );
    assert( prob.getEngagementConsumedResources("e1")[1][4]=="l1" );
    
    
    prob.getBomNames(engagementNames,resNames);
    assert( engagementNames.size()==2);
    assert( engagementNames[0]=="e1");
    assert( engagementNames[1]=="e1");
    
    assert( resNames[0][0]=="r1" || resNames[1][0]=="r1" );
    assert( resNames[0][0]=="r2" || resNames[1][0]=="r2" );
    
    assert( resNames[0][1]=="s1" || resNames[1][1]=="s1" );
    assert( resNames[0][1]=="s2" || resNames[1][1]=="s2" );
    
    assert( resNames[0][2]=="LOB1" || resNames[1][2]=="LOB1" );
    assert( resNames[0][2]=="LOB2" || resNames[1][2]=="LOB2" );
    
    assert( resNames[0][3]=="src1" || resNames[1][3]=="src1" );
    assert( resNames[0][3]=="src2" || resNames[1][3]=="src2" );
    
    assert( resNames[0][4]=="l1");
    std::string x = resNames[1][4];
    assert( resNames[1][4]=="l1");
    std::vector<std::string> jobRoles,skillSets,LOBs,sources,resourceLocNames;
    
    
    // Test to ensure usageQuantity defaults to 1
    std::vector<float> uq = prob.getBomUsageQuantity("e1",res2);
    assert( uq.size() == 4);
    int t;
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==0.0f );
    
    std::vector<float> uqOrig = uq;
    
    // Test SupplyQuantity Set/Get
    uqOrig[2]=5.0f;
    prob.setBomUsageQuantity("e1",res2,2,uqOrig[2]);
    assert( prob.getBomUsageQuantity("e1",res2,2) == 5.0f );
    uq = prob.getBomUsageQuantity("e1",res2);
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==uqOrig[t] );
    
    // Test again SupplyQuantity Set/Get
    uqOrig[0]=2.0f;
    prob.setBomUsageQuantity("e1",res2,0,uqOrig[0]);
    assert( prob.getBomUsageQuantity("e1",res2,0) == 2.0f );
    uq = prob.getBomUsageQuantity("e1",res2);
    for ( t=0; t<4; ++t ) 
      assert( uq[t]==uqOrig[t] );
    
    // test set/getting match usage
    assert( prob.getBomMatch("e1",res2,0,"jobRole")==0 );
    assert( prob.getBomMatch("e1",res2,0,"skillSet")==0 );
    assert( prob.getBomMatch("e1",res2,0,"locName")==0 );
    assert( prob.getBomMatch("e1",res2,0,"LOB")==0 );
    assert( prob.getBomMatch("e1",res2,0,"source")==0 );
    
    prob.setBomMatch("e1",res2,0,"jobRole",1);
    prob.setBomMatch("e1",res2,0,"skillSet",1);
    prob.setBomMatch("e1",res2,0,"locName",1);
    prob.setBomMatch("e1",res2,0,"LOB",1);
    prob.setBomMatch("e1",res2,0,"source",1);
    
    assert( prob.getBomMatch("e1",res2,0,"jobRole")==1 );
    assert( prob.getBomMatch("e1",res2,0,"skillSet")==1 );
    assert( prob.getBomMatch("e1",res2,0,"locName")==1 );
    assert( prob.getBomMatch("e1",res2,0,"LOB")==1 );
    assert( prob.getBomMatch("e1",res2,0,"source")==1 );
    
    // test set/getting subs usage
    assert( prob.getBomSub("e1",res2,0,"jobRole")==0 );
    assert( prob.getBomSub("e1",res2,0,"skillSet")==0 );
    assert( prob.getBomSub("e1",res2,0,"locName")==0 );
    assert( prob.getBomSub("e1",res2,0,"LOB")==0 );
    assert( prob.getBomSub("e1",res2,0,"source")==0 );
    
    prob.setBomSub("e1",res2,0,"jobRole",1);
    prob.setBomSub("e1",res2,0,"skillSet",1);
    prob.setBomSub("e1",res2,0,"locName",1);
    prob.setBomSub("e1",res2,0,"LOB",1);
    prob.setBomSub("e1",res2,0,"source",1);
    
    assert( prob.getBomSub("e1",res2,0,"jobRole")==1 );
    assert( prob.getBomSub("e1",res2,0,"skillSet")==1 );
    assert( prob.getBomSub("e1",res2,0,"locName")==1 );
    assert( prob.getBomSub("e1",res2,0,"LOB")==1 );
    assert( prob.getBomSub("e1",res2,0,"source")==1 );
  }
  // Test skillSubs
  {
    ECCovptProblem prob;
    std::vector<std::string> fromSkills, toSkills;
    prob.getSubsNames("skillSet",fromSkills,toSkills);
    assert(fromSkills.size()==0);
    assert(toSkills.size()==0);
    const std::string resIdName = "skillSet";
    
    
    assert( !prob.subsExists(resIdName,"s1","s2") );
    prob.addSubs(resIdName,"s1","s2");
    assert( prob.subsExists(resIdName,"s1","s2") );
    prob.getSubsNames(resIdName,fromSkills,toSkills);
    assert(fromSkills.size()==1);
    assert(toSkills.size()==1);
    assert(fromSkills[0]=="s1");
    assert(toSkills[0]=="s2");
    
    prob.setSubsCost(resIdName,"s1","s2",2.0f);
    assert( eq(prob.getSubsCost(resIdName,"s1","s2"),2.0f) );
    
    prob.setSubsLeadTime(resIdName,"s1","s2",3.0f);
    assert( eq(prob.getSubsLeadTime(resIdName,"s1","s2"),3.0f) );
    
    prob.addSubs(resIdName,"sA","sB");
    prob.getSubsNames(resIdName,fromSkills,toSkills);
    assert(fromSkills.size()==2);
    assert(toSkills.size()==2);
    assert(fromSkills[1]=="sA");
    assert(toSkills[1]=="sB");
    
    assert(  prob.subsExists(resIdName,"sA","sB") );
    assert( !prob.subsExists(resIdName,"sB","sA") );
    
  } // end test skillSubs
  
  // Test assignment operator
  {
    ECCovptProblem prob0;
    {
      ECCovptProblem prob1;
      prob1.setNPeriods(2);
      
      prob1.addEngagement("e1");
      
      prob1.setEngagementRevenue("e1",1.0f);
      prob1.setEngagementStartPeriod("e1",1);
      //prob1.setEngagementDuration("e1",3);
      
      assert(prob1.getEngagementRevenue("e1")==1.0f);
      assert(prob1.getEngagementRequestedStartPeriod("e1")==1);
      //assert(prob1.getEngagementDuration("e1")==3);
      
      prob0=prob1;
    }
    
    assert(prob0.getEngagementRevenue("e1")==1.0f);
    assert(prob0.getEngagementRequestedStartPeriod("e1")==1);
    //assert(prob0.getEngagementDuration("e1")==3);    
  }
  
  RcpOptCalendar rcpcal;

  // Test gapGlut priorityPlan
  {
    ECCovptProblem prob_subs;
    std::string inputDirectory, outputDirectory;
    std::cout << "example_prioritysubstitute" << std::endl;
    inputDirectory = outputDirectory = "../data/example_prioritysubstitute";
    //this problem must use priority substitute skills to satisfy demand
    populate(prob_subs, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob_subs.getProblemName() == "gapGlut");
    assert(prob_subs.getAlgorithmName() == "priorityPlan");
    
    
    // do solve in loop to make sure resolving works
    int r;
    for (r=0; r<2; ++r ) {
      prob_subs.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1,r2,r3,r4,r5,r6,r7;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("s1");r1.push_back("IBM");r1.push_back("global");
      r2.push_back("j1");r2.push_back("s2");r2.push_back("Cont");r2.push_back("non-global");
      r3.push_back("j2");r3.push_back("s1");r3.push_back("IBM");r3.push_back("non-global");
      r4.push_back("j2");r4.push_back("s2");r4.push_back("PRIORITY");r4.push_back("global");

      //the following are the supplied resources (not demanded). These are used for gap glut checks
       r5.push_back("j2");r5.push_back("s2");r5.push_back("Cont");r5.push_back("global");
       r6.push_back("j2");r6.push_back("s2");r6.push_back("Supp");r6.push_back("global");
       r7.push_back("j2");r7.push_back("s2");r7.push_back("IBM");r7.push_back("global");

      
      //check that appropriate substitute arcs are there
      {
        std::string r1str   = prob_subs.baseResourceName(r1);
        std::string r2str   = prob_subs.baseResourceName(r2);
        std::string r3str   = prob_subs.baseResourceName(r3);
        std::string r4str   = prob_subs.baseResourceName(r4);
        std::string r5str   = prob_subs.baseResourceName(r5);
        std::string r6str   = prob_subs.baseResourceName(r6);
        std::string r7str   = prob_subs.baseResourceName(r7);
        
        
        // Get resources that are substituting for r1
        RCPcollectionOfStrings subsRes;
        
        prob_subs.getSubsResources(
          createEngagementName(r1),
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( r7str )   == subsRes.end() );  
        assert( subsRes.size() == 0 );
        
        prob_subs.getSubsResources(
          createEngagementName(r2),
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( r7str )   == subsRes.end() );  
        assert( subsRes.size() == 0 );
        
        prob_subs.getSubsResources(
          createEngagementName(r3),
          r3,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   == subsRes.end() );  
        assert( subsRes.find( r6str )   == subsRes.end() ); 
        assert( subsRes.find( r7str )   == subsRes.end() );  
        assert( subsRes.size() == 0 );

        prob_subs.getSubsResources(
          createEngagementName(r4),
          r4,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r1str )   == subsRes.end() );  
        assert( subsRes.find( r2str )   == subsRes.end() );  
        assert( subsRes.find( r3str )   == subsRes.end() );  
        assert( subsRes.find( r4str )   == subsRes.end() );  
        assert( subsRes.find( r5str )   != subsRes.end() );  
        assert( subsRes.find( r6str )   != subsRes.end() ); 
        assert( subsRes.find( r7str )   != subsRes.end() );  
        assert( subsRes.size() == 3 );

       }
    
      //check that the gaps and gluts are correct
      //because of the priority aversion, the IBM and Cont substitutes for
      //prioritySubstitutes should get used first. The Supp substititute won't be
      //needed, so there will be a glut of that
      {
        std::vector<float> gapQty = prob_subs.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob_subs.getResourceGlutQuantity(r1);
        float foo = gapQty[0];
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r2);
        glutQty = prob_subs.getResourceGlutQuantity(r2);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r3);
        glutQty = prob_subs.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob_subs.getResourceGapQuantity(r4);
        glutQty = prob_subs.getResourceGlutQuantity(r4);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r5);
        glutQty = prob_subs.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r6);
        glutQty = prob_subs.getResourceGlutQuantity(r6);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob_subs.getResourceGapQuantity(r7);
        glutQty = prob_subs.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
      }
    } // end of for r loop
  }
  
  // gapGlut priority
  {
    ECCovptProblem prob_subs;
    //a more complex example with levels of priority of substitution
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_ron";
    //this problem must use priority substitute skills to satisfy demand
    populate(prob_subs, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob_subs.getProblemName() == "gapGlut");
    assert(prob_subs.getAlgorithmName() == "priorityPlan");
    
    // solve in loop to ensure resolving is working
    int r;
    for ( r=0; r<2; ++r ) {
      
      prob_subs.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15;
      
      r1.push_back("j1");r1.push_back("s1");r1.push_back("IBM");r1.push_back("global");r1.push_back("chicago");r1.push_back("US");
      r2.push_back("j2");r2.push_back("s2");r2.push_back("IBM");r2.push_back("global");r2.push_back("chicago");r2.push_back("US");
      r3.push_back("j2");r3.push_back("s2");r3.push_back("IBM");r3.push_back("global");r3.push_back("akron");r3.push_back("US");
      r4.push_back("j1");r4.push_back("s1");r4.push_back("Cont");r4.push_back("non-global");r4.push_back("akron");r4.push_back("US");
      r5.push_back("j1");r5.push_back("s1");r5.push_back("Supp");r5.push_back("non-global");r5.push_back("akron");r5.push_back("US");
      r6.push_back("j1");r6.push_back("s1");r6.push_back("WOS");r6.push_back("non-global");r6.push_back("akron");r6.push_back("US");
      r7.push_back("j3");r7.push_back("s3");r7.push_back("IBM");r7.push_back("non-global");r7.push_back("london");r7.push_back("GB");
      r8.push_back("j3");r8.push_back("s3");r8.push_back("IBM");r8.push_back("non-global");r8.push_back("akron");r8.push_back("US");
      r9.push_back("j3");r9.push_back("s3");r9.push_back("Cont");r9.push_back("global");r9.push_back("newyork");r9.push_back("US");
      r10.push_back("j3");r10.push_back("s3");r10.push_back("Cont");r10.push_back("non-global");r10.push_back("newyork");r10.push_back("US");
      r11.push_back("j2");r11.push_back("s2");r11.push_back("IBM");r11.push_back("global");r11.push_back("UNSPECIFIED");r11.push_back("US");
      r12.push_back("j1");r12.push_back("s1");r12.push_back("PRIORITY");r12.push_back("non-global");r12.push_back("akron");r12.push_back("US");
      r13.push_back("j3");r13.push_back("s3");r13.push_back("IBM");r13.push_back("non-global");r13.push_back("UNSPECIFIED");r13.push_back("PRIORITY");
      r14.push_back("j3");r14.push_back("s3");r14.push_back("Cont");r14.push_back("PRIORITY");r14.push_back("newyork");r14.push_back("US");
      r15.push_back("j3");r15.push_back("UNSPECIFIED");r15.push_back("Cont");r15.push_back("non-global");r15.push_back("newyork");r15.push_back("US");   
      
      //check that the gaps and gluts are correct
      {       
        std::vector<float> gapQty = prob_subs.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob_subs.getResourceGlutQuantity(r1);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r2);
        glutQty = prob_subs.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );  //uncomment this line when substitute order is implemented
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r3);
        glutQty = prob_subs.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r4);
        glutQty = prob_subs.getResourceGlutQuantity(r4);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r5);
        glutQty = prob_subs.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r6);
        glutQty = prob_subs.getResourceGlutQuantity(r6);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob_subs.getResourceGapQuantity(r7);
        glutQty = prob_subs.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r8);
        glutQty = prob_subs.getResourceGlutQuantity(r8);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r9);
        glutQty = prob_subs.getResourceGlutQuantity(r9);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r10);
        glutQty = prob_subs.getResourceGlutQuantity(r10);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r11);
        glutQty = prob_subs.getResourceGlutQuantity(r11);
        assert(gapQty[0]==1.0 ); //uncomment this line when priority subtitution is implemented
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r12);
        glutQty = prob_subs.getResourceGlutQuantity(r12);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r13);
        glutQty = prob_subs.getResourceGlutQuantity(r13);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r14);
        glutQty = prob_subs.getResourceGlutQuantity(r14);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob_subs.getResourceGapQuantity(r15);
        glutQty = prob_subs.getResourceGlutQuantity(r15);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
      }
    } // end of for r loop (resolve loop)   
  }
  
  // ResourceAction OptimalPlan
  {
    ECCovptProblem prob_subs;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example4";
    //this problem must use substitute skills to satisfy engagements
    populate(prob_subs, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob_subs.getProblemName() == "resourceAction");
    assert(prob_subs.getAlgorithmName() == "optimalPlan");
    
    prob_subs.resourceAction(); 
    double expectedObjValue = 4778.0;
    double obj = prob_subs.getObjValue();
    assert( eq(obj,expectedObjValue) );
    
    // Resolve
    // Does not work because resolving is does not yet work
    prob_subs.resourceAction(); 
    obj = prob_subs.getObjValue();
    assert( eq(obj,expectedObjValue) );
    
    //check that appropriate substitute arcs are there
    {
      // Create base name for each resource
      RCPvectorString r1s1ResVal,r1s2ResVal,r2s1ResVal,r2s2ResVal,r1as1ResVal,r1as2ResVal,r1s1aResVal,r2s1aResVal,r1as1aResVal;
      
      r1s1ResVal.push_back("r1");r1s1ResVal.push_back("s1");r1s1ResVal.push_back("LOB1");r1s1ResVal.push_back("src1");r1s1ResVal.push_back("l1");
      r1s2ResVal.push_back("r1");r1s2ResVal.push_back("s2");r1s2ResVal.push_back("LOB1");r1s2ResVal.push_back("src1");r1s2ResVal.push_back("l1");
      r2s1ResVal.push_back("r2");r2s1ResVal.push_back("s1");r2s1ResVal.push_back("LOB1");r2s1ResVal.push_back("src1");r2s1ResVal.push_back("l1");
      r2s2ResVal.push_back("r2");r2s2ResVal.push_back("s2");r2s2ResVal.push_back("LOB1");r2s2ResVal.push_back("src1");r2s2ResVal.push_back("l1");
      
      r1as1ResVal.push_back("r1a");r1as1ResVal.push_back("s1"); r1as1ResVal.push_back("LOB1");r1as1ResVal.push_back("src1");r1as1ResVal.push_back("l1");
      r1as2ResVal.push_back("r1a");r1as2ResVal.push_back("s2"); r1as2ResVal.push_back("LOB1");r1as2ResVal.push_back("src1");r1as2ResVal.push_back("l1");
      r1s1aResVal.push_back("r1"); r1s1aResVal.push_back("s1a");r1s1aResVal.push_back("LOB1");r1s1aResVal.push_back("src1");r1s1aResVal.push_back("l1");
      r2s1aResVal.push_back("r2"); r2s1aResVal.push_back("s1a");r2s1aResVal.push_back("LOB1");r2s1aResVal.push_back("src1");r2s1aResVal.push_back("l1");
      
      r1as1aResVal.push_back("r1a");r1as1aResVal.push_back("s1a");r1as1aResVal.push_back("LOB1");r1as1aResVal.push_back("src1");r1as1aResVal.push_back("l1");
      
      std::string r1s1   = prob_subs.baseResourceName(r1s1ResVal);
      std::string r1s2   = prob_subs.baseResourceName(r1s2ResVal);
      std::string r2s1   = prob_subs.baseResourceName(r2s1ResVal);
      std::string r2s2   = prob_subs.baseResourceName(r2s2ResVal);
      std::string r1as1  = prob_subs.baseResourceName(r1as1ResVal);
      std::string r1as2  = prob_subs.baseResourceName(r1as2ResVal);
      std::string r1s1a  = prob_subs.baseResourceName(r1s1aResVal);
      std::string r2s1a  = prob_subs.baseResourceName(r2s1aResVal);
      std::string r1as1a = prob_subs.baseResourceName(r1as1aResVal);
      
      // Get resources that are substituting for engagement: e1
      // and resource: "r1","s1","l1","LOB1","src1"
      RCPcollectionOfStrings subsRes;
      
      prob_subs.getSubsResources(
        "e1",r1s1ResVal,subsRes);
      
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  != subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  != subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) != subsRes.end() ); 
      assert( subsRes.size() == 3 );
      
      // Get resources that are substituting for engagement: e1
      // and resource: "r2","s1","l1","LOB1","src1"
      prob_subs.getSubsResources(
        "e1",r2s1ResVal,
        //"r2","s1","l1","LOB1","src1",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  != subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() );        
      assert( subsRes.size() == 1 );
      
      // Get resources that are substituting for engagement: e1
      // and resource: "r1","s2","l1","LOB1","src1"
      prob_subs.getSubsResources(
        "e1",r1s2ResVal,
        //"r1","s2","l1","LOB1","src1",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  != subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() ); 
      assert( subsRes.size() == 1 );  
      
      
      // Get resources that are substituting for engagement: e1
      // and resource: "r2","s2","l1","LOB1","src1"
      prob_subs.getSubsResources(
        "e1",r2s2ResVal,
        //"r2","s2","l1","LOB1","src1",
        subsRes);
      
      // Assert substitutes are correct for bom
      assert( subsRes.find( r1s1 )   == subsRes.end() );  
      assert( subsRes.find( r1s2 )   == subsRes.end() );  
      assert( subsRes.find( r2s1 )   == subsRes.end() );  
      assert( subsRes.find( r2s2 )   == subsRes.end() );  
      assert( subsRes.find( r1as1 )  == subsRes.end() );  
      assert( subsRes.find( r1as2 )  == subsRes.end() ); 
      assert( subsRes.find( r1s1a )  == subsRes.end() );  
      assert( subsRes.find( r2s1a )  == subsRes.end() ); 
      assert( subsRes.find( r1as1a ) == subsRes.end() );   
      assert( subsRes.size() == 0 );
      
    }
    
    // resolve again
    prob_subs.resourceAction(); 
    obj = prob_subs.getObjValue();
    assert( eq(obj,expectedObjValue) );
    
  }
  {
    ECCovptProblem prob_subs;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example4";
    //this problem must use substitute skills to satisfy engagements
    populate(prob_subs, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob_subs.getProblemName() == "resourceAction");
    assert(prob_subs.getAlgorithmName() == "optimalPlan");
    
    
    prob_subs.resourceAction(); 
  }
  
  
  //now do some meaningful tests with various test directories.
  {
    ECCovptProblem prob_baseline;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_baseline";
    populate(prob_baseline, inputDirectory, outputDirectory, rcpcal);
    
    // solve a few times making sure resolve works
    int r;
    for ( r=0; r<3; ++r ) {
      prob_baseline.gapGlut(); 
      
      RCPvectorString DetailA;
      DetailA.push_back("DetailA");DetailA.push_back("s1");DetailA.push_back("LOB1");DetailA.push_back("src1");DetailA.push_back("l1");
      std::vector<float> gapQty = prob_baseline.getResourceGapQuantity(DetailA);
      std::vector<float> glutQty = prob_baseline.getResourceGlutQuantity(DetailA);
      assert(gapQty[0]==10.0 );
      assert(glutQty[0]==0.0 );
      
      RCPvectorString DetailB;
      DetailB.push_back("DetailB");DetailB.push_back("s1");DetailB.push_back("LOB1");DetailB.push_back("src1");DetailB.push_back("l1");
      gapQty = prob_baseline.getResourceGapQuantity(DetailB);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailB);
      assert(gapQty[0]==10.0 );
      assert(glutQty[0]==0.0 );
      
      RCPvectorString DetailC;
      DetailC.push_back("DetailC");DetailC.push_back("s1");DetailC.push_back("LOB1");DetailC.push_back("src1");DetailC.push_back("l1");
      gapQty = prob_baseline.getResourceGapQuantity(DetailC);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailC);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==10.0 ); //or -10?
      
      DetailA.clear();
      DetailA.push_back("DetailA");DetailA.push_back("s1");DetailA.push_back("LOB1");DetailA.push_back("src1");DetailA.push_back("l2");
      gapQty = prob_baseline.getResourceGapQuantity(DetailA);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailA);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==30.0 ); //or -30?
      
      DetailB.clear();
      DetailB.push_back("DetailB");DetailB.push_back("s1");DetailB.push_back("LOB1");DetailB.push_back("src1");DetailB.push_back("l2");
      gapQty = prob_baseline.getResourceGapQuantity(DetailB);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailB);
      assert(gapQty[0]==0.0 );
      assert(glutQty[0]==10.0 ); //or -10?
      
      DetailC.clear();
      DetailC.push_back("DetailC");DetailC.push_back("s1");DetailC.push_back("LOB1");DetailC.push_back("src1");DetailC.push_back("l2");
      gapQty = prob_baseline.getResourceGapQuantity(DetailC);
      glutQty = prob_baseline.getResourceGlutQuantity(DetailC);
      assert(gapQty[0]==10.0 );
      assert(glutQty[0]==0.0 ); 
    }    
  }
  
  {
    ECCovptProblem prob_acquire;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_acquire";
    //this problem has a short time horizon, and revenue is set so that
    //acquiring new resources is worthwhile
    populate(prob_acquire, inputDirectory, outputDirectory, rcpcal);
    prob_acquire.resourceAction(); 
    double obj = prob_acquire.getObjValue();
    assert( eq(obj,4925.0) );
    
    //test that resources got acquired; 2 of r1 and 3 of r2, both in period 1
    //std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
    
    RCPvectorString r1;
    r1.push_back("r1");r1.push_back("s1");r1.push_back("LOB1");r1.push_back("src1");r1.push_back("l1");
    std::vector<float> acquireQty =prob_acquire.getResourceAcquireQuantity(r1);
    float aq=acquireQty[1];
    assert(acquireQty[1]==2);
    
    //acquireQty =prob_acquire.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
    RCPvectorString r2;
    r2.push_back("r2");r2.push_back("s2");r2.push_back("LOB2");r2.push_back("src2");r2.push_back("l1");
    acquireQty =prob_acquire.getResourceAcquireQuantity(r2);
    aq=acquireQty[1];
    assert(acquireQty[1]==3);
    
    //test that one engagement gets executed starting in period 1 (it has to wait one period to acquire the resources)
    assert(prob_acquire.getEngagementExecuted("e1"));
    assert(prob_acquire.getEngagementExecuted("e2"));
    assert(prob_acquire.getEngagementStartPeriod("e1")==0);
    assert(prob_acquire.getEngagementStartPeriod("e2")==2);
  }
  
  {
    ECCovptProblem prob_delay;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_delay";
    //this problem has a longer time horizon, and revenue is set so that
    //delaying the execution of jobs is worthwhile
    populate(prob_delay, inputDirectory, outputDirectory, rcpcal);
    prob_delay.resourceAction(); 
    double obj = prob_delay.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,4935.0) );
    //test that no resources were acquired, and that a job was done late
    assert(
      prob_delay.getEngagementStartPeriod("e2")==0 && prob_delay.getEngagementStartPeriod("e1")==3
      ||
      prob_delay.getEngagementStartPeriod("e2")==3 && prob_delay.getEngagementStartPeriod("e1")==0
      );
    
    RCPvectorString r1;
    r1.push_back("r1");r1.push_back("s1");r1.push_back("LOB1");r1.push_back("src1");r1.push_back("l1");
    std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity(r1);
    //std::vector<float> acquireQty =prob_delay.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
    
    unsigned int i;
    for (i=0; i<acquireQty.size(); i++)
      assert(acquireQty[i]==0);
    RCPvectorString r2;
    r2.push_back("r2");r2.push_back("s2");r2.push_back("LOB2");r2.push_back("src2");r2.push_back("l1");
    acquireQty =prob_delay.getResourceAcquireQuantity(r2);
    //acquireQty =prob_delay.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
    for (i=0; i<acquireQty.size(); i++)
      assert(acquireQty[i]==0);
  }

  {
    ECCovptProblem prob_decline;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_decline";
    //this problem has a short time horizon, but revenue and acquire costs are such that
    //it is better to decline an engagement
    populate(prob_decline, inputDirectory, outputDirectory, rcpcal);
    prob_decline.resourceAction(); 
    double obj = prob_decline.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,265.0) );
    //test that resources were not acquired and that a job was declined
    assert(prob_decline.getEngagementExecuted("e1")==false);
    
    RCPvectorString r1;
    r1.push_back("r1");r1.push_back("s1");r1.push_back("LOB1");r1.push_back("src1");r1.push_back("l1");
    std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity(r1);
    //std::vector<float> acquireQty =prob_decline.getResourceAcquireQuantity("r1","s1","LOB1","src1","l1");
    unsigned int i;
    for (i=0; i<acquireQty.size(); i++)
      assert(eq(acquireQty[i],0));
    RCPvectorString r2;
    r2.push_back("r2");r2.push_back("s2");r2.push_back("LOB2");r2.push_back("src2");r2.push_back("l1");
    acquireQty =prob_decline.getResourceAcquireQuantity(r2);;
    //acquireQty =prob_decline.getResourceAcquireQuantity("r2","s2","LOB2","src2","l1");
    for (i=0; i<acquireQty.size(); i++)
      assert(eq(acquireQty[i],0));
  }

  {
    ECCovptProblem prob_IGS;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/IGS";
    //Verify that the lateAllowance implementation is working
    populate(prob_IGS, inputDirectory, outputDirectory, rcpcal);
    
    prob_IGS.resourceAction(); 
    double obj = prob_IGS.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,39775.0f) );
    //test that the shipReward is set in periods 6 and 7
    std::vector<float> shipRewardQty = prob_IGS.getDemandShipReward("e1");
    int i;
    for(i=0; i<6; i++)
      assert(eq(shipRewardQty[i],0.0f));
    assert(eq(shipRewardQty[6],40000.0f));
    assert(eq(shipRewardQty[7],40000.0f));
    for(i=8; i<16; i++)
      assert(eq(shipRewardQty[i],0.0f));
    
    //int ed = prob_IGS.getEngagementDuration("e1");
    //assert(ed==2);
    int ela = prob_IGS.getEngagementLateAllowance("e1");
    assert( ela == 1 );
    int ersp = prob_IGS.getEngagementRequestedStartPeriod("e1");
    assert( ersp == 6 );
    int esp = prob_IGS.getEngagementStartPeriod("e1");
    assert( esp == 6 || esp == 7 );
  }
  
  {
    ECCovptProblem prob_IGS;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/IGS";
    //Verify that the lateAllowance implementation is working
    populate(prob_IGS, inputDirectory, outputDirectory, rcpcal);
    
    // don't let the engagement be done a period late
    prob_IGS.setEngagementLateAllowance("e1",0);
    
    prob_IGS.resourceAction(); 
    double obj = prob_IGS.getObjValue();
    CoinRelFltEq eq;
    assert( eq(obj,39775.0f) );
    int esp = prob_IGS.getEngagementStartPeriod("e1");
    assert( esp == 6 );
  }
  
 // Test ER5 format (gap glut/format 03Dec) examples
  {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "er5_test2" << std::endl;
    inputDirectory = outputDirectory = "../data/er5_test2";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob.getProblemName() == "gapGlut");
    assert(prob.getAlgorithmName() == "priorityPlan");
      
    // do solve in loop to make sure resolving works


    prob.gapGlut();
      
    // Create base name for each resource
    RCPvectorString r1, r2;
      
    //the following are the demanded resources. These are the only ones which
    //we should look for substitute arcs on.
    r1.push_back("j1");r1.push_back("PRIORITY");r1.push_back("G");
    //the following are the supplied resources (not demanded). These are used for gap glut checks
    r2.push_back("j1");r2.push_back("IBM");r2.push_back("G");
      
    //check that appropriate substitute arcs are there
    {
        std::string r2str   = prob.baseResourceName(r2);
        
        // Get resources that are substituting for r1
        RCPcollectionOfStrings subsRes;
        
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r2str )   != subsRes.end() );  
        assert( subsRes.size() == 1 );
        
     }
    
     //check that the gaps and gluts are correct
     {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        float foo = gapQty[0];
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
     }
  }
 // Test ER5 format (gap glut/format 03Dec) examples
  {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "er5_test1" << std::endl;
    inputDirectory = outputDirectory = "../data/er5_test1";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob.getProblemName() == "gapGlut");
    assert(prob.getAlgorithmName() == "priorityPlan");
      
    // do solve in loop to make sure resolving works
    prob.gapGlut();
      
    // Create base name for each resource
    RCPvectorString r1, r2, r3, r4, r5, r6;
    RCPvectorString r7, r8, r9, r10;
      
    //the following are the demanded resources. These are the only ones which
    //we should look for substitute arcs on.
    r1.push_back("j1");r1.push_back("IBM");r1.push_back("G");
    r2.push_back("j1");r2.push_back("PRIORITY");r2.push_back("G");
    r3.push_back("j1");r3.push_back("CONT");r3.push_back("PRIORITY");
    r4.push_back("j1");r4.push_back("CONT");r4.push_back("N");
    r5.push_back("j2");r5.push_back("CONT");r5.push_back("PRIORITY");
    r6.push_back("j2");r6.push_back("CONT");r6.push_back("N");

    //the following are the supplied resources (not demanded). These are used for gap glut checks
    r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
    r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
    r9.push_back("j1");r9.push_back("CONT");r9.push_back("N");
    r10.push_back("j2");r10.push_back("CONT");r10.push_back("N");
      
    //check that appropriate substitute arcs are there
    {
        std::string r7str   = prob.baseResourceName(r7);
        std::string r8str   = prob.baseResourceName(r8);
        std::string r9str   = prob.baseResourceName(r9);
        std::string r10str   = prob.baseResourceName(r10);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.size() == 0 );
d73 5
a77 113
        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r7str )   != subsRes.end() );
        assert( subsRes.find( r8str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );
   
       // Get resources that are substituting for r3:firm
       prob.getSubsResources(
          "firm",
          r3,subsRes);
       // Assert substitutes are correct for bom
       assert( subsRes.find( r8str )   != subsRes.end() );
       assert( subsRes.find( r9str )   != subsRes.end() );  
       assert( subsRes.size() == 2 );
       
       // Get resources that are substituting for r4:opportunity
       prob.getSubsResources(
          "opportunity",
          r4,subsRes);
       // Assert substitutes are correct for bom
       assert( subsRes.size() == 0 );
       
       // Get resources that are substituting for r5:opportunity
       prob.getSubsResources(
          "opportunity",
          r5,subsRes);
       // Assert substitutes are correct for bom
       assert( subsRes.find( r10str )   != subsRes.end() );  
       assert( subsRes.size() == 1 );
       
       // Get resources that are substituting for r6:forecast
       prob.getSubsResources(
          "forecast",
          r5,subsRes);
       // Assert substitutes are correct for bom
       assert( subsRes.size() == 0 );       
     }  
       
     //check that the gaps and gluts are correct
     {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r3);
        glutQty = prob.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r4);
        glutQty = prob.getResourceGlutQuantity(r4);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r5);
        glutQty = prob.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6);
        glutQty = prob.getResourceGlutQuantity(r6);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
    }
  }  
 // Test ER5 format (gap glut/format 03Dec) examples
  {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "er5_test3" << std::endl;
    inputDirectory = outputDirectory = "../data/er5_test3";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob.getProblemName() == "gapGlut");
    assert(prob.getAlgorithmName() == "priorityPlan");
      
    // do solve in loop to make sure resolving works
    int r;
    for (r=0; r<2; ++r ) {
      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1, r2;
      RCPvectorString r7, r8;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("PRIORITY");r1.push_back("G");
      r2.push_back("j2");r2.push_back("CONT");r2.push_back("G");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
      r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
      
      //check that appropriate substitute arcs are there
      {
        std::string r7str   = prob.baseResourceName(r7);
        std::string r8str   = prob.baseResourceName(r8);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r7str )   != subsRes.end() );
        assert( subsRes.find( r8str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );
d79 7
a85 8
        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.size() == 0 );
      }
       
d87 10
a96 32
      //check that the gaps and gluts are correct
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r7);
        glutQty = prob.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r8);
        glutQty = prob.getResourceGlutQuantity(r8);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
       }
    } // end of for r loop
  }    
 // Test ER5 format (gap glut/format 03Dec) examples
  {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "er5_test4" << std::endl;
    inputDirectory = outputDirectory = "../data/er5_test4";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    
    assert(prob.getProblemName() == "gapGlut");
    assert(prob.getAlgorithmName() == "priorityPlan");
      
d98 5
a102 30
      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1, r2;
      RCPvectorString r7, r8;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("PRIORITY");r1.push_back("G");
      r2.push_back("j2");r2.push_back("CONT");r2.push_back("G");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
      r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
      
      //check that appropriate substitute arcs are there
      {
        std::string r7str   = prob.baseResourceName(r7);
        std::string r8str   = prob.baseResourceName(r8);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r7str )   != subsRes.end() );
        assert( subsRes.find( r8str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );
d104 5
a108 9
        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r8str )   != subsRes.end() );  
        assert( subsRes.size() == 1 );
     }
       
a109 31
      //check that the gaps and gluts are correct
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r7);
        glutQty = prob.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r8);
        glutQty = prob.getResourceGlutQuantity(r8);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
       }
  }    
 // Test ER5 format (gap glut/format 03Dec) examples
  {
      ECCovptProblem prob;
      std::string inputDirectory, outputDirectory;
      std::cout << "er5_test5" << std::endl;
      inputDirectory = outputDirectory = "../data/er5_test5";
      populate(prob, inputDirectory, outputDirectory, rcpcal);
    
      assert(prob.getProblemName() == "gapGlut");
      assert(prob.getAlgorithmName() == "priorityPlan");
      
a110 55
      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1, r2, r3, r4, r5, r6, r6a, r6b;
      RCPvectorString r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("IBM");r1.push_back("G");
      r2.push_back("j2");r2.push_back("PRIORITY");r2.push_back("G");
      r3.push_back("j2");r3.push_back("PRIORITY");r3.push_back("N");
      r4.push_back("j1");r4.push_back("CONT");r4.push_back("G");
      r5.push_back("j1");r5.push_back("IBM");r5.push_back("G");
      r6.push_back("j1");r6.push_back("CONT");r6.push_back("N");
      r6a.push_back("j3");r6a.push_back("IBM");r6a.push_back("G");
      r6b.push_back("j2");r6b.push_back("PRIORITY");r6b.push_back("PRIORITY");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r7.push_back("j1");r7.push_back("IBM");r7.push_back("G");
      r8.push_back("j1");r8.push_back("CONT");r8.push_back("G");
      r9.push_back("j1");r9.push_back("CONT");r9.push_back("N");
      r10.push_back("j2");r10.push_back("IBM");r10.push_back("G");
      r11.push_back("j2");r11.push_back("CONT");r11.push_back("G");
      r12.push_back("j2");r12.push_back("CONT");r12.push_back("N");
      r13.push_back("j3");r13.push_back("IBM");r13.push_back("G");
      r14.push_back("j3");r14.push_back("CONT");r14.push_back("G");
      r15.push_back("j3");r15.push_back("CONT");r15.push_back("N");
      r16.push_back("j4");r16.push_back("CONT");r16.push_back("N");
      r17.push_back("j4");r17.push_back("IBM");r17.push_back("G");
      
      //check that appropriate substitute arcs are there
      {
        std::string r7str   = prob.baseResourceName(r7);
        std::string r8str   = prob.baseResourceName(r8);
        std::string r9str   = prob.baseResourceName(r9);
        std::string r10str   = prob.baseResourceName(r10);
        std::string r11str   = prob.baseResourceName(r11);
        std::string r12str   = prob.baseResourceName(r12);
        std::string r13str   = prob.baseResourceName(r13);
        std::string r14str   = prob.baseResourceName(r14);
        std::string r15str   = prob.baseResourceName(r15);
        std::string r16str   = prob.baseResourceName(r16);
        std::string r17str   = prob.baseResourceName(r17);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r10str )   != subsRes.end() ); 
        assert( subsRes.find( r13str )   != subsRes.end() ); 
        assert( subsRes.find( r17str )   != subsRes.end() ); 
        assert( subsRes.size() == 3 );
d112 11
a122 429
        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r11str )   != subsRes.end() );  
        assert( subsRes.find( r10str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );
        
        // Get resources that are substituting for r3:firm
        prob.getSubsResources(
          "firm",
          r3,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r12str )   != subsRes.end() );  
        assert( subsRes.size() == 1 );
        
        // Get resources that are substituting for r4:opportunity
        prob.getSubsResources(
          "opportunity",
          r4,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r11str )   != subsRes.end() );  
        assert( subsRes.find( r14str )   != subsRes.end() );  
        assert( subsRes.size() == 2 );
        
        // Get resources that are substituting for r5:opportunity
        prob.getSubsResources(
          "opportunity",
          r5,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r10str )   != subsRes.end() );  
        assert( subsRes.find( r13str )   != subsRes.end() );  
        assert( subsRes.find( r17str )   != subsRes.end() );  
        assert( subsRes.size() == 3 );
        
        // Get resources that are substituting for r6:forecast
        prob.getSubsResources(
          "forecast",
          r6,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r12str )   != subsRes.end() );  
        assert( subsRes.find( r15str )   != subsRes.end() );
        assert( subsRes.find( r16str )   != subsRes.end() );  
        assert( subsRes.size() == 3 );
        
        // Get resources that are substituting for r6a:forecast
        prob.getSubsResources(
          "forecast",
          r6a,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.size() == 0 );
        
        // Get resources that are substituting for r6b:firm
        prob.getSubsResources(
          "firm",
          r6b,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r10str )   != subsRes.end() );  
        assert( subsRes.find( r11str )   != subsRes.end() );  
        assert( subsRes.find( r12str )   != subsRes.end() );  
        assert( subsRes.size() == 5 ); //this includes two "supplies" added with 0 quantity from the demand
        
        
        
     }
       

      //check that the gaps and gluts are correct
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r3);
        glutQty = prob.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r4);
        glutQty = prob.getResourceGlutQuantity(r4);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r5);
        glutQty = prob.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6);
        glutQty = prob.getResourceGlutQuantity(r6);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6a);
        glutQty = prob.getResourceGlutQuantity(r6a);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6b);
        glutQty = prob.getResourceGlutQuantity(r6b);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r7);
        glutQty = prob.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r8);
        glutQty = prob.getResourceGlutQuantity(r8);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r9);
        glutQty = prob.getResourceGlutQuantity(r9);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r10);
        glutQty = prob.getResourceGlutQuantity(r10);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r11);
        glutQty = prob.getResourceGlutQuantity(r11);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r12);
        glutQty = prob.getResourceGlutQuantity(r12);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r13);
        glutQty = prob.getResourceGlutQuantity(r13);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r14);
        glutQty = prob.getResourceGlutQuantity(r14);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob.getResourceGapQuantity(r15);
        glutQty = prob.getResourceGlutQuantity(r15);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r16);
        glutQty = prob.getResourceGlutQuantity(r16);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        gapQty = prob.getResourceGapQuantity(r17);
        glutQty = prob.getResourceGlutQuantity(r17);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
      }
 
      //now check that the pegging is correct
      {
      float qSup,qAq;
      std::vector<float> qSub;
      std::vector<RCPvectorString> subsResources;
      
      //r1 should be satisfied by r7(supply) and r10(sub)
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r1);
      assert(qSup==1);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r1);
      assert(qAq==0);
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r1,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r10);
      //r2 should be satisfied by r11(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r2,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r11);
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r2);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r2);
      assert(qAq==0);
      // r3 should be satisfied by r12(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r3,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r12);
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r3);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r3);
      assert(qAq==0);
      //r4 should be satisfied by r8(supply)
      prob.getEngagementPeggedQuantitiesFromSubstitution("opportunity",0,r4,qSub,subsResources);
      assert(qSub.size()==0);
      qSup = prob.getEngagementPeggedQuantityFromSupply("opportunity",0,r4);
      assert(qSup==1);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("opportunity",0,r4);
      assert(qAq==0);
      //r5 should be satsified by r13(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("opportunity",0,r5,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r13);
      qSup = prob.getEngagementPeggedQuantityFromSupply("opportunity",0,r5);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("opportunity",0,r5);
      assert(qAq==0);
      //r6 should be satisfied by r9(supply) and r15(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("forecast",0,r6,qSub,subsResources);
      assert(qSub.size()==1);
      assert(subsResources[0]==r15);
      qSup = prob.getEngagementPeggedQuantityFromSupply("forecast",0,r6);
      assert(qSup==1);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("forecast",0,r6);
      assert(qAq==0);
      //r6a should be a gap
      prob.getEngagementPeggedQuantitiesFromSubstitution("forecast",0,r6a,qSub,subsResources);
      assert(qSub.size()==0);
      qSup = prob.getEngagementPeggedQuantityFromSupply("forecast",0,r6a);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("forecast",0,r6a);
      assert(qAq==1);
      //r6b should be a gap
      prob.getEngagementPeggedQuantitiesFromSubstitution("forecast",0,r6b,qSub,subsResources);
      assert(qSub.size()==0);
      qSup = prob.getEngagementPeggedQuantityFromSupply("forecast",0,r6b);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r6b);
      assert(qAq==1);
      }
  } 
 // Test ER5 format (gap glut/format 03Dec) examples
  {
      ECCovptProblem prob;
      std::string inputDirectory, outputDirectory;
      std::cout << "er5_test6" << std::endl;
      inputDirectory = outputDirectory = "../data/er5_test6";
      populate(prob, inputDirectory, outputDirectory, rcpcal);
    
      assert(prob.getProblemName() == "gapGlut");
      assert(prob.getAlgorithmName() == "priorityPlan");
      

      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString r1, r2;
      RCPvectorString r3, r4, r5, r6, r7;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      r1.push_back("j1");r1.push_back("IBM");r1.push_back("G");
      r2.push_back("j1");r2.push_back("PRIORITY");r2.push_back("G");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r3.push_back("j1");r3.push_back("IBM");r3.push_back("G");
      r4.push_back("j1");r4.push_back("CONT");r4.push_back("G");
      r5.push_back("j1");r5.push_back("WOS");r5.push_back("G");
      r6.push_back("j2");r6.push_back("CONT");r6.push_back("G");
      r7.push_back("j1");r7.push_back("JV");r7.push_back("G");
      
      //check that appropriate substitute arcs are there
      {
        std::string r3str   = prob.baseResourceName(r3);
        std::string r4str   = prob.baseResourceName(r4);
        std::string r5str   = prob.baseResourceName(r5);
        std::string r6str   = prob.baseResourceName(r6);
        std::string r7str   = prob.baseResourceName(r7);
        
        RCPcollectionOfStrings subsRes;
        
        // Get resources that are substituting for r1:firm
        prob.getSubsResources(
          "firm",
          r1,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.size() == 0 );

        // Get resources that are substituting for r2:firm
        prob.getSubsResources(
          "firm",
          r2,subsRes);
        // Assert substitutes are correct for bom
        assert( subsRes.find( r3str )   != subsRes.end() );  
        assert( subsRes.find( r4str )   != subsRes.end() );  
        assert( subsRes.find( r5str )   != subsRes.end() );  
        assert( subsRes.find( r6str )   != subsRes.end() );  
        assert( subsRes.size() == 4 );
        
      }
       

      //check that the gaps and gluts are correct
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(r1);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(r1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r2);
        glutQty = prob.getResourceGlutQuantity(r2);
        assert(gapQty[0]==1.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r3);
        glutQty = prob.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r4);
        glutQty = prob.getResourceGlutQuantity(r4);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r5);
        glutQty = prob.getResourceGlutQuantity(r5);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r6);
        glutQty = prob.getResourceGlutQuantity(r6);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r7);
        glutQty = prob.getResourceGlutQuantity(r7);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
      }
 
      //now check that the pegging is correct
      {
      float qSup,qAq;
      std::vector<float> qSub;
      std::vector<RCPvectorString> subsResources;
      
      //r1 should be satisfied by r3(supply)
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r1);
      assert(qSup==1);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r1);
      assert(qAq==0);
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r1,qSub,subsResources);
      assert(qSub.size()==0);
      //r2 should be satisfied by r4(sub), r5(sub), r6(sub) and 1 gap
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,r2,qSub,subsResources);
      assert(qSub.size()==3);
      assert((subsResources[0]==r4)||(subsResources[0]==r5)||(subsResources[0]==r6));
      assert((subsResources[1]==r4)||(subsResources[1]==r5)||(subsResources[1]==r6));
      assert((subsResources[2]==r4)||(subsResources[2]==r5)||(subsResources[2]==r6));
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",0,r2);
      assert(qSup==0);
      qAq = prob.getEngagementPeggedQuantityFromAcquisition("firm",0,r2);
      assert(qAq==1);
      // r3 should be satisfied by r12(sub)
      }
  } 
// Test ER5 format (gap glut/format 03Dec) examples
  {
      ECCovptProblem prob;
      std::string inputDirectory, outputDirectory;
      std::cout << "er5_test7" << std::endl;
      inputDirectory = outputDirectory = "../data/er5_test7";
      populate(prob, inputDirectory, outputDirectory, rcpcal);
    
      assert(prob.getProblemName() == "gapGlut");
      assert(prob.getAlgorithmName() == "priorityPlan");
      

      prob.gapGlut();
      
      // Create base name for each resource
      RCPvectorString d1, d3, d4, d5, d6, d7;
      RCPvectorString r1, r2, r3, r4, r5, r6, r7;
      
      //the following are the demanded resources. These are the only ones which
      //we should look for substitute arcs on.
      d1.push_back("j1");d1.push_back("IBM");d1.push_back("G");
      d3.push_back("j1");d3.push_back("WOS");d3.push_back("N");
      d4.push_back("j1");d4.push_back("CONT");d4.push_back("N");
      d5.push_back("j2");d5.push_back("IBM");d5.push_back("PRIORITY");
      d6.push_back("j2");d6.push_back("PRIORITY");d6.push_back("PRIORITY");
      d7.push_back("j1");d7.push_back("IBM");d7.push_back("PRIORITY");
 
      //the following are the supplied resources (not demanded). These are used for gap glut checks
      r1.push_back("j2");r1.push_back("IBM");r1.push_back("G");
      r2.push_back("j1");r2.push_back("IBM");r2.push_back("G");
      r3.push_back("j1");r3.push_back("CONT");r3.push_back("G");
      r4.push_back("j1");r4.push_back("IBM");r4.push_back("N");
      r5.push_back("j2");r5.push_back("CONT");r5.push_back("N");
      r6.push_back("j2");r6.push_back("IBM");r6.push_back("G");
      r7.push_back("j2");r7.push_back("CONT");r7.push_back("N");
      

      //check that the gaps and gluts are correct (just checking a couple)
      {
        std::vector<float> gapQty = prob.getResourceGapQuantity(d3);
        std::vector<float> glutQty = prob.getResourceGlutQuantity(d3);
        assert(gapQty[2]==1.0 );
        assert(glutQty[2]==0.0 );
        gapQty = prob.getResourceGapQuantity(d1);
        glutQty = prob.getResourceGlutQuantity(d1);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==0.0 );
        gapQty = prob.getResourceGapQuantity(r3);
        glutQty = prob.getResourceGlutQuantity(r3);
        assert(gapQty[0]==0.0 );
        assert(glutQty[0]==1.0 );
        
        //DLG the following seems to depend on platform
        glutQty = prob.getResourceGlutQuantity(r3);
        // assert((prob.getResourceGlutQuantity(r3)[1]==0.0 && prob.getResourceGlutQuantity(r7)[1]==1.0)||
        //(prob.getResourceGlutQuantity(r3)[1]==1.0 && prob.getResourceGlutQuantity(r7)[1]==0.0));
 
        // One of these will stay
        assert(prob.getResourceGlutQuantity(r3)[1]==0.0 && prob.getResourceGlutQuantity(r7)[1]==1.0);
        //assert(prob.getResourceGlutQuantity(r3)[1]==1.0 && prob.getResourceGlutQuantity(r7)[1]==0.0);

        
        gapQty = prob.getResourceGapQuantity(r4);
        glutQty = prob.getResourceGlutQuantity(r4);
        assert(gapQty[2]==0.0 );
        assert(glutQty[2]==1.0 );
        }
 
      //now check that the pegging is correct (just a couple)
      {
      float qSup;
      std::vector<float> qSub;
      std::vector<RCPvectorString> subsResources;
      
      //d1 (period 0) should be satisfied by r1(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",0,d1,qSub,subsResources);
      assert(qSub.size()==1);
      assert((subsResources[0]==r1));
      //d1 (period 1) should be satisfied by r2(supply)
      qSup = prob.getEngagementPeggedQuantityFromSupply("firm",1,d1);
      assert(qSup==1);
      // d4 should be satisfied by r5(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",2,d4,qSub,subsResources);
      assert(qSub.size()==1);
      assert((subsResources[0]==r5));
      // d6 should be satisfied by r6(sub)
      prob.getEngagementPeggedQuantitiesFromSubstitution("firm",2,d6,qSub,subsResources);
      assert(qSub.size()==1);
      assert((subsResources[0]==r6));
      }
  } 

  //tests using new "vector" format, testing matching (no substitution yet)
a124 5
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_match1";
    //this one matches everything, and has 2 gaps and 2 gluts
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
d126 2
a127 2
    std::vector<RCPvectorString> names;
    prob.getResourceNames(names);
a128 36
    std::vector<float> gapQty = prob.getResourceGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names[0]);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[1]);
    glutQty = prob.getResourceGlutQuantity(names[1]);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[2]);
    glutQty = prob.getResourceGlutQuantity(names[2]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    gapQty = prob.getResourceGapQuantity(names[3]);
    glutQty = prob.getResourceGlutQuantity(names[3]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
  }
  {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_match2";
    //this one matches on jobrole, but not skillset, and has 2 gaps and 2 gluts
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    std::vector<RCPvectorString> names;
    prob.getResourceNames(names);
    
    std::vector<float> gapQty = prob.getResourceGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names[0]);
    assert(gapQty[0]==2);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[1]);
    glutQty = prob.getResourceGlutQuantity(names[1]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==2);
d131 3
a135 5
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_match3";
    //this one matches on skillset but not jobrole, and has no gaps or gluts
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
d137 3
a139 2
    std::vector<RCPvectorString> names;
    prob.getResourceNames(names);
d141 2
a142 16
    std::vector<float> gapQty = prob.getResourceGapQuantity(names[0]);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names[0]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    gapQty = prob.getResourceGapQuantity(names[1]);
    glutQty = prob.getResourceGlutQuantity(names[1]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
  }
  //"expanded" 04Feb style 
  {
    ECCovptProblem prob_04Feb;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example04Feb";
    populate(prob_04Feb, inputDirectory, outputDirectory, rcpcal);
    prob_04Feb.gapGlut();
d144 3
d148 11
a158 22
    std::vector<RCPvectorString> names;
    prob_04Feb.getResourceNames(names);
    
    std::vector<float> gapQty = prob_04Feb.getResourceGapQuantity(names[0]);
    std::vector<float> glutQty = prob_04Feb.getResourceGlutQuantity(names[0]);
    assert(gapQty[0]==0);
    assert(glutQty[0]==2);
    gapQty = prob_04Feb.getResourceGapQuantity(names[9]);
    glutQty = prob_04Feb.getResourceGlutQuantity(names[9]);
    assert(gapQty[0]==2);
    assert(glutQty[0]==0);
    
    
    
  }
  {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_tucson";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
d160 1
d162 4
a166 47
    names.push_back("j1");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j1");names.push_back("s2");names.push_back("Cont");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j2");names.push_back("s1");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j2");names.push_back("s2");names.push_back("Cont");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    
    names.clear();
    names.push_back("j2");names.push_back("s2");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("j2");names.push_back("s2");names.push_back("Supp");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    
    names.clear();
    names.push_back("j2");names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1); //this should be uncommented when column priority is working
    assert(glutQty[0]==0);
a167 6
    names.clear();
    names.push_back("j2");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1); //this should be uncommented when column priority is working
d169 2
d172 11
a182 16
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_tucson1";
    //this one differs from example_tucson in that jobRoleMatch=0. This allows a gap
    //and glut to satisfy one another
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
d184 2
a185 55
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); //uncomment when priority columns are implemented
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); //uncomment when priority columns are implemented
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Supp");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    
    names.clear();
    names.push_back("unmatched");names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1); //this should be uncommented when column priority is working
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
d187 3
d192 3
a194 104
    std::string inputDirectory, outputDirectory;
    std::cout << "tucson2" << std::endl;
    inputDirectory = outputDirectory = "../data/example_tucson2";
    //this one tests that more than one "indeterminate" will get done LAST
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("s1");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("s1");names.push_back("PRIORITY");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("s1");names.push_back("IBM");names.push_back("PRIORITY");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    
    names.clear();
    names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("global");names.push_back("UNSPECIFIED");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0); 
    
    names.clear();
    names.push_back("s2");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    
    names.clear();
    names.push_back("s1");names.push_back("Cont");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    
    names.clear();
    names.push_back("s1");names.push_back("IBM");names.push_back("non-global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0); 
    assert(glutQty[0]==0);
    
    
  }
    {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_tucson3";
    //this one is exactly the same as tucson1, except that there are two identical periods.
    //this is just to test that more than one period works as expected
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1);
    assert(glutQty[0]==0);
    assert(gapQty[1]==1);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
d196 2
a197 53
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Cont");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[1]==0);
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s2");names.push_back("Supp");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==1);
    assert(gapQty[1]==0);
    assert(glutQty[1]==1);
    
    names.clear();
    names.push_back("unmatched");names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("non-global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==1); 
    assert(glutQty[0]==0);
    assert(gapQty[1]==1); 
    assert(glutQty[1]==0);
    
    names.clear();
    names.push_back("unmatched");names.push_back("s1");names.push_back("IBM");names.push_back("global");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[1]==0);
    assert(glutQty[1]==0); 
a198 88
 {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    inputDirectory = outputDirectory = "../data/example_startperiod";
    std::cout << "startperiod" << std::endl;
    //this one is just like tucson3, except there are 12 periods in the horizon,
    //but only 11 and 12 given.
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();
    
    
    std::vector<std::string> names;
    
    names.push_back("s1");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    std::vector<float> gapQty = prob.getResourceGapQuantity(names);
    std::vector<float> glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==0);
    assert(gapQty[11]==0);
    assert(glutQty[11]==0);
    
    names.clear();
    names.push_back("s1");names.push_back("PRIORITY");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==0);
    assert(gapQty[11]==0);
    assert(glutQty[11]==0);
    
    names.clear();
    names.push_back("s1");names.push_back("IBM");names.push_back("PRIORITY");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==0);
    assert(gapQty[11]==0);
    assert(glutQty[11]==0);
    
    names.clear();
    names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[10]==0);
    assert(glutQty[10]==0); 
    assert(gapQty[11]==0);
    assert(glutQty[11]==0); 
    
    names.clear();
    names.push_back("UNSPECIFIED");names.push_back("IBM");names.push_back("global");names.push_back("UNSPECIFIED");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0); 
    assert(gapQty[10]==1);
    assert(glutQty[10]==0); 
    assert(gapQty[11]==1);
    assert(glutQty[11]==0); 
    
    names.clear();
    names.push_back("s2");names.push_back("IBM");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==0);
    assert(gapQty[11]==0);
    assert(glutQty[11]==0);
    
    names.clear();
    names.push_back("s1");names.push_back("Cont");names.push_back("global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0);
    assert(glutQty[0]==0);
    assert(gapQty[10]==0);
    assert(glutQty[10]==1);
    assert(gapQty[11]==0);
    assert(glutQty[11]==1);
a199 53
    names.clear();
    names.push_back("s1");names.push_back("IBM");names.push_back("non-global");names.push_back("lob");
    gapQty = prob.getResourceGapQuantity(names);
    glutQty = prob.getResourceGlutQuantity(names);
    assert(gapQty[0]==0); 
    assert(glutQty[0]==0);
    assert(gapQty[10]==0); 
    assert(glutQty[10]==0);
    assert(gapQty[11]==0); 
    assert(glutQty[11]==0);
    
    
  }

  {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "startperiod1" << std::endl;
    inputDirectory = outputDirectory = "../data/example_startperiod1";
    //just make sure this doesn't crash.
    bool exceptionCaught=false;
    try {
        populate(prob, inputDirectory, outputDirectory, rcpcal);    }
    catch ( RcpOptException e ) {
        exceptionCaught = true;
    }
    assert (exceptionCaught);
  }
  {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    std::cout << "interleave_crash" << std::endl;
    inputDirectory = outputDirectory = "../data/interleave_crash";
    //just make sure this doesn't crash.
    bool exceptionCaught=false;
    try {
        populate(prob, inputDirectory, outputDirectory, rcpcal);
    }
    catch ( RcpOptException e ) {
        exceptionCaught = true;
    }
    assert (exceptionCaught);
  }

   {
    ECCovptProblem prob;
    std::string inputDirectory, outputDirectory;
    //just a simple to test to see if it runs
    inputDirectory = outputDirectory = "../data/example_finalformat";
    populate(prob, inputDirectory, outputDirectory, rcpcal);
    prob.gapGlut();  
  } 
#endif
@


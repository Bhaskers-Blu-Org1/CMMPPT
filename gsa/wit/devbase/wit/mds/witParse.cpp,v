head	1.21;
access;
symbols
	sce_5_01_20080919:1.21
	latest_sce_4_20_20060523:1.21.0.4
	sce_4_20_20060523:1.21
	latest_sce4_20_OSL:1.21.0.2
	sce_4_20_OSL:1.21
	sce_410_withVa:1.18
	sce_4_05_20040511:1.9
	sce_4_00_20040201:1.7
	nextGenBranch:1.6.0.2
	nextGenRoot:1.6
	sce_3_30_20030627:1.6
	EndRw-branch:1.3.0.4
	Root-of-EndRw:1.3
	rwToStl:1.3.0.2
	latest_sce_3_10_20010924:1.2.0.2
	sce_3_10_20010924:1.2;
locks; strict;
comment	@// @;


1.21
date	2005.11.22.14.02.32;	author fasano;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.18.20.56.21;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.19.15.01.13;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.23.19.45.19;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.13.21.18.46;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.08.01.21.59;	author fasano;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.07.18.18.10;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.07.15.19.54;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.07.15.16.23;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.23.15.40.16;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.10.23.56.56;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.05.15.43.58;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.14.18.37.34;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.13.20.28.41;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.12.19.39.06;	author fasano;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.09.13.10.03;	author rwToStl;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.06.17.46.16;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.25.15.15.23;	author rwToStl;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.08.01.03.55;	author fasano;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.08.10.21.14.37;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.10.19.07.04;	author fasano;	state Exp;
branches;
next	;

1.3.2.1
date	2002.11.10.17.14.14;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Changes to have wit build with witParse.C, witLexer.C and ytab.h moved from mds directory to src directory
@
text
@/* This file has been moved from the mds to src directory. */@


1.20
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d1 1
a1 2804
/* yacc -dl d:\implode\wit\src\witParse.y */

#if defined(_MSC_VER)
  #pragma warning(disable:4786)
  #pragma warning(disable:4503)
#endif

#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#endif
/*
 * Portable way of defining ANSI C prototypes
 */
#ifndef YY_ARGS
#if __STDDC__
#define YY_ARGS(x)	x
#else
#define YY_ARGS(x)	()
#endif
#endif

#ifdef YACC_WINDOWS

#include <windows.h>

/*
 * the following is the handle to the current
 * instance of a windows program. The user
 * program calling yyparse must supply this!
 */

extern HANDLE hInst;	

#endif	/* YACC_WINDOWS */

#if YYDEBUG
typedef struct yyNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} yyTypedRules;

#endif


/*------------------------------------------------------------------------------
 *
 *     (c) Copyright IBM Corp. 1993,1994,1996.
 *     (Unpublished)
 *     OCO Source Modules
 *     IBM Confidential
 *
 *------------------------------------------------------------------------------

 *------------------------------------------------------------------------------
 *
 *     Source file:    witParse.y
 *
 *     Parser for WIT 4.0 Input Data File Format
 *
 *     To create an executable parser file:
 *
 *           yacc -d  witParse.y             (creates y.tab.c and y.tab.h)
 *           mv -f y.tab.c ytab.C
 *           mv -f y.tab.h ytab.h
 *           lex  witLexer.l                 (creates lex.yy.c)    
 *           mv -f lex.yy.c witParse.C
 *           xlC witParse.C ytab.C -o witParse -ly -ll
 *    
 *           Notes:
 *           
 *              -d   causes y.tab.h to be created.  This is the token
 *                   name definition file.
 *
 *              -ly  causes the yacc library to be included. This 
 *                   library is in /usr/lib/liby.a
 *
 *              -ll  causes the lex library to be included. This
 *                   library is in /usr/lib/libl.a      
 *
 *------------------------------------------------------------------------------
 *
 */

#include <wit/src/Parser.h>
#include <wit/src/Problem.h>
#include <wit/src/ApiMgr.h>
#include <wit/src/InputID.h>
#include <wit/src/VecBS.h>
#include <wit/src/Entity.h>
#include <wit/src/MsgFac.h>

#include <errno.h>

extern  FILE *yyin;

extern "C" void yyerror(char *)
{
}

#if defined (WIN32) || defined (__OS2__)
extern void yy_reset(void);
extern char yytext[];
#else
extern  unsigned char yytext[];
#endif

void prterror();                     /* print line number and filename */ 

    /* variables used by the parser */
WitSymTabEntry        *entryPtr;     /* ptr to current symbol table entry */
WitEntity::argVecDef  *argPtr;
WitVectorSpec         *vecPtr;       /* pointer to current vector format */
WitBoundSetSpec       *bndPtr;
WitParseRC            retcode;
WitEntity::eType      entityType;    /* type of the current entity */
WitAttribute::aType   attrType;      /* type of the current attribute */  
WitParser::PS         commandState;  /* current command state */
char                  *s1, *s2, *s3; /* temporary strings     */

    /* valid "release" numbers (i.e,, the version of the software) */
char      *relnum[] = {"4.0", "5.0", "6.0" };
#define   NRELS     (sizeof relnum / sizeof relnum[0])

char      *checkrel(char *);         /* check for a valid release number */   

typedef union {
    int    intval;
    double doubleval;
    char * strval;
    bool   boolval;
    int    cval;
    int    pval;
    int    btype;
} YYSTYPE;
#define RELEASE	257
#define ADD	258
#define SET	259
#define READ	260
#define PROBLEM	261
#define PART	262
#define OPERATION	263
#define BOM_ENTRY	264
#define SUB_ENTRY	265
#define BOP_ENTRY	266
#define DEMAND	267
#define PART_WITH_OPERATION	268
#define SINGLE	269
#define SPARSE	270
#define DENSE	271
#define END_BOUNDS	272
#define HARDLB	273
#define SOFTLB	274
#define HARDUB	275
#define CAPACITY	276
#define MATERIAL	277
#define IDENTIFIER	278
#define STRING	279
#define DOUBLE	280
#define INTEGER	281
#define BOOLEAN	282
#define CATEGORY	283
#define EXEC_BOUNDS	284
#define STOCK_BOUNDS	285
#define CUM_SHIP_BOUNDS	286
extern int yychar, yyerrflag;
extern YYSTYPE yylval;
#if YYDEBUG
enum YY_Types { YY_t_NoneDefined, YY_t_strval, YY_t_doubleval, YY_t_intval, YY_t_boolval, YY_t_cval, YY_t_pval, YY_t_btype
};
#endif
#if YYDEBUG
yyTypedRules yyRules[] = {
	{ "&00: %14 &00",  0},
	{ "%14: %15 %16",  0},
	{ "%16:",  0},
	{ "%16: %16 %17",  0},
	{ "%17: %18",  0},
	{ "%17: %19",  0},
	{ "%17: %20",  0},
	{ "%21:",  0},
	{ "%23:",  0},
	{ "%15: &02 %21 %22 %23 &32",  0},
	{ "%22: &24",  0},
	{ "%24:",  0},
	{ "%26:",  0},
	{ "%18: &03 %24 %25 %26 %27 &32",  0},
	{ "%25: %05",  0},
	{ "%25: &13",  0},
	{ "%28:",  0},
	{ "%19: &04 &06 %28 %29 &32",  0},
	{ "%30:",  0},
	{ "%19: &04 %30 %31 %27 &32",  0},
	{ "%31: %05",  0},
	{ "%05: &07",  1},
	{ "%05: &08",  1},
	{ "%05: &09",  1},
	{ "%05: &10",  1},
	{ "%05: &11",  1},
	{ "%05: &12",  1},
	{ "%29: %32",  0},
	{ "%34:",  0},
	{ "%27: %33 %34 %32",  0},
	{ "%04: &28",  5},
	{ "%32:",  0},
	{ "%32: %32 %35",  0},
	{ "%33: %10",  0},
	{ "%33: %33 %10",  0},
	{ "%10: %06",  6},
	{ "%10: %04",  6},
	{ "%35: %36",  0},
	{ "%35: %03",  0},
	{ "%36: %01 %08",  0},
	{ "%01: &23",  1},
	{ "%08: %06",  6},
	{ "%08: %37",  6},
	{ "%06: &24",  6},
	{ "%06: &26",  6},
	{ "%06: &25",  6},
	{ "%06: &27",  6},
	{ "%38:",  0},
	{ "%39:",  0},
	{ "%40:",  0},
	{ "%37: &14 %38 &33 %39 %09 %40 &34",  0},
	{ "%41:",  0},
	{ "%42:",  0},
	{ "%37: &15 %41 &33 %42 %43 &34",  0},
	{ "%44:",  0},
	{ "%45:",  0},
	{ "%37: &16 %44 &33 %45 %46 &34",  0},
	{ "%43:",  0},
	{ "%43: %43 %07",  0},
	{ "%47:",  0},
	{ "%07: %13 &35 %47 %09",  6},
	{ "%46: %09",  0},
	{ "%46: %46 %09",  0},
	{ "%09: %06",  6},
	{ "%13: &26",  3},
	{ "%48:",  0},
	{ "%03: %02 %48 %49 &17",  1},
	{ "%02: &29",  1},
	{ "%02: &30",  1},
	{ "%02: &31",  1},
	{ "%49:",  0},
	{ "%49: %49 %12",  0},
	{ "%50:",  0},
	{ "%12: %11 %50 %37",  7},
	{ "%11: &18",  7},
	{ "%11: &19",  7},
	{ "%11: &20",  7},
	{ "%51:",  0},
	{ "%53:",  0},
	{ "%54:",  0},
	{ "%20: &05 %51 %52 %53 &32 %54 %15",  0},
	{ "%52: &24",  0},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "RELEASE",  257,  0},
	{ "ADD",  258,  0},
	{ "SET",  259,  0},
	{ "READ",  260,  0},
	{ "PROBLEM",  261,  0},
	{ "PART",  262,  0},
	{ "OPERATION",  263,  0},
	{ "BOM_ENTRY",  264,  0},
	{ "SUB_ENTRY",  265,  0},
	{ "BOP_ENTRY",  266,  0},
	{ "DEMAND",  267,  0},
	{ "PART_WITH_OPERATION",  268,  0},
	{ "SINGLE",  269,  0},
	{ "SPARSE",  270,  0},
	{ "DENSE",  271,  0},
	{ "END_BOUNDS",  272,  0},
	{ "HARDLB",  273,  0},
	{ "SOFTLB",  274,  0},
	{ "HARDUB",  275,  0},
	{ "CAPACITY",  276,  0},
	{ "MATERIAL",  277,  0},
	{ "IDENTIFIER",  278,  1},
	{ "STRING",  279,  1},
	{ "DOUBLE",  280,  2},
	{ "INTEGER",  281,  3},
	{ "BOOLEAN",  282,  4},
	{ "CATEGORY",  283,  5},
	{ "EXEC_BOUNDS",  284,  1},
	{ "STOCK_BOUNDS",  285,  1},
	{ "CUM_SHIP_BOUNDS",  286,  1},
	{ "';'",  59,  0},
	{ "'('",  40,  0},
	{ "')'",  41,  0},
	{ "':'",  58,  0}

};
#endif
static short yydef[] = {

	  -1,   83,    3,    4,   82,   69,   81
};
static short yyex[] = {

	   0,    0,   -1,    1
};
static short yyact[] = {

	 -92,  257,  -89,  279,  -88,   -3,  -36,  260,  259,  258, 
	 -83,  261,  -90,   59, -109,  279,  -79,  -78,  -77,  -76, 
	 -75,  -74,  267,  266,  265,  264,  263,  262,  -79,  -78, 
	 -77,  -76,  -75,  -74,  -84,  268,  267,  266,  265,  264, 
	 263,  262,  -66,  -64,  -65,  -63,  -73,  283,  282,  281, 
	 280,  279,  -34,   59,  -81,   59,  -69,  -45,  -44,  -43, 
	 286,  285,  284,  278,  -82,   59,  -62,  -58,  -55,  -66, 
	 -64,  -65,  -63,  282,  281,  280,  279,  271,  270,  269, 
	 -86,   59,  -46,  -39,  -38,  -37,  275,  274,  273,  272, 
	 -54,   40,  -57,   40,  -61,   40,  -62,  -58,  -55,  271, 
	 270,  269,  -66,  -64,  -65,  -63,  282,  281,  280,  279, 
	 -53,  -66,  -64,  -65,  -63,  282,  281,  280,  279,   41, 
	 -56,  -48,  281,   41,  -51,   58,  -59,   41,   -1
};
static short yypact[] = {

	   2,    7,   11,   47,   60,   66,   60,  106,  127,  125, 
	 122,  115,  106,  106,   99,   95,   93,   91,   86,    1, 
	  81,   73,   47,   65,   55,   53,   47,   35,   22,   15, 
	  13,    3,    1
};
static short yygo[] = {

	 -22,  -47, -102,  -70,  -85,  -80,   27,  -71,  -68,  -71, 
	 -71,  -49,   26,   22,   21,    3,  -52, -103,  -50, -106, 
	 -60, -105,   12,   11,    7, -100,  -99,    3,  -41,  -42, 
	 -10,   -1, -108,  -96,   19,   -2,  -97,  -95,  -94,  -93, 
	 -32,  -91,  -31,  -28,  -87,  -23,  -21,  -25,   22,  -98, 
	 -24,  -29,  -27,   -7,   -5,    5,   -4,   -6,  -72, -101, 
	 -40,  -67,   14,  -16,  -13,   -9,  -17, -104,  -11,  -18, 
	 -14,  -12,   -8, -107,  -19,  -15,  -30,  -35,  -26,  -20,   -1
};
static short yypgo[] = {

	   0,    0,    0,   51,   57,   79,   78,   76,   28,   28, 
	  28,   29,   75,   74,    1,    1,    1,    2,   73,   30, 
	  21,   16,   72,   68,   61,   70,   69,   61,   67,   66, 
	  61,   65,   64,   63,   11,   11,   11,   11,   17,   17, 
	   0,   26,   26,   54,    3,    5,    5,    5,    5,    5, 
	   5,   52,   38,   38,   49,   44,   44,   37,   45,   43, 
	  41,   33,   42,   40,   36,   36,   36,   35,   35,   54, 
	  56,   56,   58,   58,   59,   68,   71,   71,   74,   39, 
	  77,   47,   50,   31,    0
};
static short yyrlen[] = {

	   0,    0,    0,    0,    0,    0,    0,    0,    1,    1, 
	   1,    3,    0,    2,    1,    1,    1,    4,    0,    1, 
	   1,    4,    0,    2,    6,    0,    0,    6,    0,    0, 
	   7,    0,    0,    0,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    2,    1,    1,    1,    1,    1,    1, 
	   1,    1,    5,    5,    0,    1,    1,    6,    0,    0, 
	   1,    5,    0,    0,    1,    1,    1,    0,    2,    0, 
	   1,    2,    1,    1,    2,    0,    1,    2,    0,    7, 
	   1,    3,    1,    2,    2
};
#define YYS0	32
#define YYDELTA	28
#define YYNPACT	33
#define YYNDEF	7

#define YYr82	0
#define YYr83	1
#define YYr84	2
#define YYr18	3
#define YYr28	4
#define YYr79	5
#define YYr78	6
#define YYr77	7
#define YYr76	8
#define YYr75	9
#define YYr74	10
#define YYr73	11
#define YYr72	12
#define YYr71	13
#define YYr69	14
#define YYr68	15
#define YYr67	16
#define YYr66	17
#define YYr65	18
#define YYr64	19
#define YYr63	20
#define YYr60	21
#define YYr59	22
#define YYr58	23
#define YYr56	24
#define YYr55	25
#define YYr54	26
#define YYr53	27
#define YYr52	28
#define YYr51	29
#define YYr50	30
#define YYr49	31
#define YYr48	32
#define YYr47	33
#define YYr46	34
#define YYr45	35
#define YYr44	36
#define YYr43	37
#define YYr42	38
#define YYr41	39
#define YYr40	40
#define YYr36	41
#define YYr35	42
#define YYr32	43
#define YYr30	44
#define YYr26	45
#define YYr25	46
#define YYr24	47
#define YYr23	48
#define YYr22	49
#define YYr21	50
#define YYr20	51
#define YYr19	52
#define YYr17	53
#define YYr16	54
#define YYr15	55
#define YYr14	56
#define YYr13	57
#define YYr12	58
#define YYr11	59
#define YYr10	60
#define YYr9	61
#define YYr8	62
#define YYr7	63
#define YYr6	64
#define YYr5	65
#define YYr4	66
#define YYrACCEPT	YYr82
#define YYrERROR	YYr83
#define YYrLR2	YYr84
#if YYDEBUG
char * yysvar[] = {
	"$accept",
	"attribute_name",
	"bound_set_type",
	"bound_set_attribute",
	"category",
	"entity_name",
	"simple_value",
	"period_value",
	"attribute_value",
	"vector_value",
	"argument",
	"bound_type",
	"bound_item",
	"period",
	"data_specification",
	"release_specification",
	"command_list",
	"command",
	"add_command",
	"set_command",
	"read_command",
	"$7",
	"release_num",
	"$8",
	"$11",
	"add_clause",
	"$12",
	"entity_specification",
	"$16",
	"global_specification",
	"$18",
	"set_clause",
	"attribute_list",
	"argument_list",
	"$28",
	"attribute",
	"simple_attribute",
	"vector_format",
	"$47",
	"$48",
	"$49",
	"$51",
	"$52",
	"sparse_list",
	"$54",
	"$55",
	"value_list",
	"$59",
	"$65",
	"bounds_specification",
	"$72",
	"$77",
	"file_name",
	"$78",
	"$79",
	0
};
short yyrmap[] = {

	  82,   83,   84,   18,   28,   79,   78,   77,   76,   75, 
	  74,   73,   72,   71,   69,   68,   67,   66,   65,   64, 
	  63,   60,   59,   58,   56,   55,   54,   53,   52,   51, 
	  50,   49,   48,   47,   46,   45,   44,   43,   42,   41, 
	  40,   36,   35,   32,   30,   26,   25,   24,   23,   22, 
	  21,   20,   19,   17,   16,   15,   14,   13,   12,   11, 
	  10,    9,    8,    7,    6,    5,    4,    2,    3,   31, 
	  33,   34,   37,   38,   39,   57,   61,   62,   70,   80, 
	  81,   29,   27,    1,    0
};
short yysmap[] = {

	   3,    5,    9,   44,   46,   51,   65,  107,  104,  101, 
	  96,   95,   91,   89,   88,   78,   77,   76,   75,   64, 
	  63,   58,   48,   47,   45,   35,   30,   19,   17,   16, 
	  15,    4,    0,   49,   22,    8,   79,   80,   81,   92, 
	  82,   83,   53,   54,   55,   84,   56,  100,   93,  108, 
	 105,  102,   99,   85,   67,  103,   86,   68,  106,   97, 
	  87,   69,   36,   37,   38,   39,   70,   71,   57,   40, 
	  41,   61,   43,   23,   24,   25,   26,   27,   28,   29, 
	  52,   62,   18,   32,   33,   73,   34,   10,    6,   20, 
	   7,    1,   11,   12,   13,    2,   14,   31,   42,   50, 
	  60,   59,   72,   90,   94,   98,   66,   74,   21
};
int yyntoken = 36;
int yynvar = 55;
int yynstate = 109;
int yynrule = 85;
#endif

#if YYDEBUG
/*
 * Package up YACC context for tracing
 */
typedef struct yyTraceItems_tag {
	int	state, lookahead, errflag, done;
	int	rule, npop;
	short	* states;
	int	nstates;
	YYSTYPE * values;
	int	nvalues;
	short	* types;
} yyTraceItems;
#endif


/*
 * Copyright 1985, 1990 by Mortice Kern Systems Inc.  All rights reserved.
 * 
 * Automaton to interpret LALR(1) tables.
 *
 * Macros:
 *	yyclearin - clear the lookahead token.
 *	yyerrok - forgive a pending error
 *	YYERROR - simulate an error
 *	YYACCEPT - halt and return 0
 *	YYABORT - halt and return 1
 *	YYRETURN(value) - halt and return value.  You should use this
 *		instead of return(value).
 *	YYREAD - ensure yychar contains a lookahead token by reading
 *		one if it does not.  See also YYSYNC.
 *	YYRECOVERING - 1 if syntax error detected and not recovered
 *		yet; otherwise, 0.
 *
 * Preprocessor flags:
 *	YYDEBUG - includes debug code if 1.  The parser will print
 *		 a travelogue of the parse if this is defined as 1
 *		 and yydebug is non-zero.
 *		yacc -t sets YYDEBUG to 1, but not yydebug.
 *	YYTRACE - turn on YYDEBUG, and undefine default trace functions
 *		so that the interactive functions in 'ytrack.c' will
 *		be used.
 *	YYSSIZE - size of state and value stacks (default 150).
 *	YYSTATIC - By default, the state stack is an automatic array.
 *		If this is defined, the stack will be static.
 *		In either case, the value stack is static.
 *	YYALLOC - Dynamically allocate both the state and value stacks
 *		by calling malloc() and free().
 *	YYDYNAMIC - Dynamically allocate (and reallocate, if necessary)
 *		both the state and value stacks by calling malloc(),
 *		realloc(), and free().
 *	YYSYNC - if defined, yacc guarantees to fetch a lookahead token
 *		before any action, even if it doesnt need it for a decision.
 *		If YYSYNC is defined, YYREAD will never be necessary unless
 *		the user explicitly sets yychar = -1
 *
 * Copyright (c) 1983, by the University of Waterloo
 */
/*
 * Prototypes
 */

extern int yylex YY_ARGS((void));

#if YYDEBUG

#include <stdlib.h>		/* common prototypes */
#include <string.h>

extern char *	yyValue YY_ARGS((YYSTYPE, int));	/* print yylval */
extern void yyShowState YY_ARGS((yyTraceItems *));
extern void yyShowReduce YY_ARGS((yyTraceItems *));
extern void yyShowGoto YY_ARGS((yyTraceItems *));
extern void yyShowShift YY_ARGS((yyTraceItems *));
extern void yyShowErrRecovery YY_ARGS((yyTraceItems *));
extern void yyShowErrDiscard YY_ARGS((yyTraceItems *));

extern void yyShowRead YY_ARGS((int));
#endif

/*
 * If YYDEBUG defined and yydebug set,
 * tracing functions will be called at appropriate times in yyparse()
 * Pass state of YACC parse, as filled into yyTraceItems yyx
 * If yyx.done is set by the tracing function, yyparse() will terminate
 * with a return value of -1
 */
#define YY_TRACE(fn) { \
	yyx.state = yystate; yyx.lookahead = yychar; yyx.errflag =yyerrflag; \
	yyx.states = yys+1; yyx.nstates = yyps-yys; \
	yyx.values = yyv+1; yyx.nvalues = yypv-yyv; \
	yyx.types = yytypev+1; yyx.done = 0; \
	yyx.rule = yyi; yyx.npop = yyj; \
	fn(&yyx); \
	if (yyx.done) YYRETURN(-1); }

#ifndef I18N
#define m_textmsg(id, str, cls)	(str)
#else /*I18N*/
#include <m_nls.h>
#endif/*I18N*/

#ifndef YYSSIZE
# define YYSSIZE	150
#endif

#ifdef YYDYNAMIC
#define YYALLOC
char *getenv();
int atoi();
int yysinc = -1; /* stack size increment, <0 = double, 0 = none, >0 = fixed */
#endif

#ifdef YYALLOC
int yyssize = YYSSIZE;
#endif

#define YYERROR		goto yyerrlabel
#define yyerrok		yyerrflag = 0
#if YYDEBUG
#define yyclearin	{ if (yydebug) yyShowRead(-1); yychar = -1; }
#else
#define yyclearin	yychar = -1
#endif
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#define YYRECOVERING()	(yyerrflag != 0)
#ifdef YYALLOC
#define YYRETURN(val)	{ retval = (val); goto yyReturn; }
#else
#define YYRETURN(val)	return(val);
#endif
#if YYDEBUG
/* The if..else makes this macro behave exactly like a statement */
# define YYREAD	if (yychar < 0) {					\
			if ((yychar = yylex()) < 0)	{		\
				if (yychar == -2) YYABORT; \
				yychar = 0;				\
			}	/* endif */			\
			if (yydebug)					\
				yyShowRead(yychar);			\
		} else
#else
# define YYREAD	if (yychar < 0) {					\
			if ((yychar = yylex()) < 0) {			\
				if (yychar == -2) YYABORT; \
				yychar = 0;				\
			}	/* endif */			\
		} else
#endif

#define YYERRCODE	256		/* value of `error' */
#define	YYQYYP	yyq[yyq-yyp]

YYSTYPE	yyval;				/* $ */
YYSTYPE	*yypvt;				/* $n */
YYSTYPE	yylval;				/* yylex() sets this */

int	yychar,				/* current token */
	yyerrflag,			/* error flag */
	yynerrs;			/* error count */

#if YYDEBUG
int yydebug = 0;		/* debug if this flag is set */
extern char	*yysvar[];	/* table of non-terminals (aka 'variables') */
extern yyNamedType yyTokenTypes[];	/* table of terminals & their types */
extern short	yyrmap[], yysmap[];	/* map internal rule/states */
extern int	yynstate, yynvar, yyntoken, yynrule;

extern int	yyGetType YY_ARGS((int));	/* token type */
extern char	*yyptok YY_ARGS((int));	/* printable token string */
extern int	yyExpandName YY_ARGS((int, int, char *, int));
				  /* expand yyRules[] or yyStates[] */
static char *	yygetState YY_ARGS((int));

#define yyassert(condition, msg, arg) \
	if (!(condition)) { \
		printf(m_textmsg(2824, "\nyacc bug: ", "E")); \
		printf(msg, arg); \
		YYABORT; }
#else /* !YYDEBUG */
#define yyassert(condition, msg, arg)
#endif

//------------------------------------------------------------------------------

WitParser * WitParser::instance_ = NULL;

//------------------------------------------------------------------------------

void WitParser::parse (WitProblem * theProblem, const char * fileName, FILE * f)
   {
   witAssert (instance_ == NULL);

   instance_ = new WitParser;

   instance ()->parseIt (theProblem, fileName, f);

   delete instance ();

   instance_ = NULL;
   }

//------------------------------------------------------------------------------

// accessors

WitParser::PS    WitParser::parseState() const
{ return parseState_; }

WitEntity     *WitParser::currentEntity() const
{ return currentEntity_; }

WitAttribute  *WitParser::currentAttr() const
{ return currentAttr_; }

WitMsgFacility & WitParser::myMsgFac () const
   {
   return myProblem ()->myMsgFac ();
   }

void WitParser::setParseState(PS st)
{ parseState_ = st; }


void prterror()
{
  WitParser::instance ()->myMsgFac () ("lineNumberMsg", (const char *) yytext,
    WitParlex::lineno(), WitParlex::fileName());
}

//  check for a valid release number     
char     *checkrel(char *s)       /* s = char. string, in quotes */
{
  if (strlen(s) <= 2) return NULL;
  for (int i = 0; i < NRELS; i++)
    if (strncmp(s+1, relnum[i], strlen(s)-2) == 0)
      return relnum[i];
  return NULL;
}

//-----------------------------------------------------------------------------
// WitParser::prtSyntaxError
//
//     Implementation of syntax checker
//
//     Contains function to check the state of the parser and generate
//     a meaninful error message when a syntax error occurs.
//
// The parse states are defined in Parser.h:
//
//  PS_initial               // initial state, looking for "release"
//  PS_add                   // found "add", looking for <entity_name>
//  PS_set                   // found "set", looking for <entity_name>
//  PS_read                  // found "read", looking for <data_file>
//  PS_release               // found "release", looking for release_spec
//  PS_part                  // found "part", looking for <category>
//  PS_operation             // found "operation", looking for <arg>
//  PS_bomEntry              // found "bomEntry", looking for <arg>
//  PS_subEntry              // found "subEntry", looking for <arg>
//  PS_bopEntry              // found "bopEntry", looking for <arg>
//  PS_demand                // found "demand", looking for <arg>
//  PS_partOperation         // found "partWithOperation, looking for <arg>
//  PS_nextArg               // looking for another <arg> or a ";"
//  PS_attr                  // found <attr_name>, looking for <attr_value>
//  PS_single                // found "single", looking for "("
//  PS_dense                 // found "dense", looking for "("
//  PS_sparse                // found "sparse", looking for "("
//  PS_singleParen           // found "single (", looking for <vector_value>
//  PS_denseParen            // found "dense (", looking for <vector_value>
//  PS_sparseParen           // found "sparse (", looking for <period>
//  PS_singleValue           // found single value, looking for ")"
//  PS_denseValue            // found <value>, looking for <value> or ")"
//  PS_sparseValue           // found <period_val>, looking for <period> or ")"
//  PS_nextAttr              // looking for <attr_name> or ";"
//  PS_nextCommand           // found ";" and looking for <command>
//  PS_commandEnd            // looking for ";"
//  PS_period                // found <period>, looking for ":"
//  PS_periodColon	     // found ":", looking for <vector_value>
//  PS_nextBound             // found <bound_set_type>, looking for <bounds>
//  PS_boundType             // found <bound_type>, looking for <vector>
//  PS_endBounds             // found "endBounds", looking for ";" or next attr
//  PS_setProblem            // found "set problem", looking for
//                           //        <attribute name>
//-----------------------------------------------------------------------------

void WitParser::prtSyntaxError(WitSymTabEntry *pEntry,
                WitParser::PS parseState, const char * yytext) const
{
  char  *s1;

  // Print syntax error message, depending on current parser state
  switch (parseState) {
    case WitParser::PS_initial:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
         "\"release\"", yytext);
      break;
    case WitParser::PS_commandEnd:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg", "a \";\"", yytext);
      break;
    case WitParser::PS_nextCommand:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
      "a command name (e.g., set, add, read)", yytext);
      break;
    case WitParser::PS_add:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an addable object type after \"add\"", yytext);
      break;
    case WitParser::PS_set:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of a settable object type after \"set\"", yytext);
      break;
    case WitParser::PS_setProblem:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an attribute after \"set problem\"", yytext);
      break;
    case WitParser::PS_read:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a string (the name of a file) after \"read\"", yytext);
      break;
    case WitParser::PS_release:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a quoted string (the release number) after \"release\"", yytext);
      break;
    case WitParser::PS_part:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "part", yytext);
      break;
    case WitParser::PS_operation:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "operation", yytext);
      break;
    case WitParser::PS_bomEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "bomEntry", yytext);
      break;
    case WitParser::PS_subEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "subEntry", yytext);
      break;
    case WitParser::PS_bopEntry:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "bopEntry", yytext);
      break;
    case WitParser::PS_demand:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "demand", yytext);
      break;
    case WitParser::PS_partOperation:
      if (pEntry->nparms() == 1)
        s1 = "argument";
      else
        s1 = "arguments";
      WitParser::instance ()->myMsgFac () ("noArgsMsg", pEntry->nparms(), s1,
        "partWithOperation", yytext);
      break;
    case WitParser::PS_nextArg:

      // Check to see if we have the correct number of argumenta.
      // If so, we are looking for an attribute or a semicolon
      if (WitParser::instance ()->currentEntity()->argc() >= pEntry->nparms()) {
        WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
          "the name of an attribute or a \";\"", yytext);
        break;
      };

      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
         "another argument",
         yytext);
      break;
    case WitParser::PS_attr:
      switch (pEntry->parmTypes()[0]) {   // what the value should be
        case WitDRParmType::intScalar:
          s1 = "integer";	
          break;
        case WitDRParmType::doubleScalar:
          s1 = "double";
          break;
        case WitDRParmType::string:
          s1 = "string";
          break;
        case WitDRParmType::boolScalar:
          s1 = "boolean";
          break;
        case WitDRParmType::partCat:
          s1 = "\"category\"";
          break;
        case WitDRParmType::boolVector:
          s1 = "\"boolean vector\"";
          break;
        case WitDRParmType::intVector:
          s1 = "\"integer vector\"";
          break;
        case WitDRParmType::doubleVector:
          s1 = "\"double vector\"";
          break;
        case WitDRParmType::boundSet:
          s1 = "\"bound set\"";
          break;
        default:
          s1 = "unknown";
          break;
      };
      WitParser::instance ()->myMsgFac () ("attrValueNotFound",
        s1, WitParser::instance ()->currentAttr()->attrID(), yytext);
      break;
    case WitParser::PS_nextAttr:
    case WitParser::PS_endBounds:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "the name of an attribute or a \";\"", yytext);
      break;
    case WitParser::PS_nextBound:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a bound set attribute (e.g., softLB, hardLB, hardUB)"
        " or \"endBounds\"", yytext);
      break;
    case WitParser::PS_boundType:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector format (e.g, single, dense, sparse)", yytext);
      break;
    case WitParser::PS_single:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"single\"", yytext);
      break;
    case WitParser::PS_dense:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"dense\"", yytext);
      break;
    case WitParser::PS_sparse:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \"(\" after \"sparse\"", yytext);
      break;
    case WitParser::PS_singleParen:
    case WitParser::PS_denseParen:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector value (a number) for a \"single\" vector specification",
        yytext);
      break;
    case WitParser::PS_sparseParen:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a period (an integer) in \"sparse\" vector specification", yytext);
      break;
    case WitParser::PS_singleValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \")\" after the one vector value in a \"single\" vector "
        "specification", yytext);
      break;
    case WitParser::PS_denseValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector value or a \")\"", yytext);
      break;
    case WitParser::PS_sparseValue:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a period (an integer) or a \")\"", yytext);
      break;
    case WitParser::PS_period:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a \":\" in \"sparse\" vector specification", yytext);
      break;
    case WitParser::PS_periodColon:
      WitParser::instance ()->myMsgFac () ("syntaxErrorMsg",
        "a vector value (a number) after the \":\"", yytext);
      break;
  }
}

//------------------------------------------------------------------------------

void WitParser::setDataFileName () const
   {
   myProblem ()->myApiMgr ()->myInputID ()->setDataFileName (fileName ());
   }

//------------------------------------------------------------------------------

void WitParser::setDataFileLineNo () const
   {
   myProblem ()->myApiMgr ()->myInputID ()->setDataFileLineNo (lineno ());
   }

//-----------------------------------------------------------------------------

// Constructor and destructor

WitParser::WitParser ():
      theSymTable_   (NULL),
      currentRule_   (),
      previousRule_  (),
      currentEntity_ (NULL),
      currentAttr_   (NULL),
      parseState_    (PS_initial),
      myProblem_     (NULL)
   {
   commandState = PS_initial;
   }

WitParser::~WitParser ()
   {
   }

//------------------------------------------------------------------------------

// Parse the input stream
int WitParser::parseIt(WitProblem * theProblem, const char* fileName, FILE* f)
{
  int   rc;

  WitParlex::setFileName (fileName);   // save current file name
  yyin = f;                            // save pointer to FILE

  myProblem_   = theProblem;
  theSymTable_ = new WitSymTable (theProblem->myWitRun ());
  rc           = theSymTable_->registerRules ();

  if (rc)
     return rc;

#if defined (WIN32) || defined (__OS2__)

  yy_reset();

#endif

  rc = yyparse();

  if (rc)
  {
    WitParser::instance ()->prtSyntaxError(entryPtr,
       WitParser::instance ()->parseState(),
      (const char *) yytext);
    WitParser::instance ()->myMsgFac () ("lineNumberMsg", (const char *) yytext,
      WitParlex::lineno(), WitParlex::fileName());
    WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
  }

  delete theSymTable_;
  return rc;
}


#ifdef YACC_WINDOWS

/*
 * the following is the yyparse() function that will be
 * callable by a windows type program. It in turn will
 * load all needed resources, obtain pointers to these
 * resources, and call a statically defined function
 * win_yyparse(), which is the original yyparse() fn
 * When win_yyparse() is complete, it will return a
 * value to the new yyparse(), where it will be stored
 * away temporarily, all resources will be freed, and
 * that return value will be given back to the caller
 * yyparse(), as expected.
 */

static int win_yyparse();			/* prototype */

yyparse() 
{
	int wReturnValue;
	HANDLE hRes_table;		/* handle of resource after loading */
	short *old_yydef;		/* the following are used for saving */
	short *old_yyex;		/* the current pointers */
	short *old_yyact;
	short *old_yypact;
	short *old_yygo;
	short *old_yypgo;
	short *old_yyrlen;

	/*
	 * the following code will load the required
	 * resources for a Windows based parser.
	 */

	hRes_table = LoadResource (hInst, 
		FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));
	
	/*
	 * return an error code if any
	 * of the resources did not load
	 */

	if (hRes_table == NULL)
		return (1);
	
	/*
	 * the following code will lock the resources
	 * into fixed memory locations for the parser
	 * (also, save the current pointer values first)
	 */

	old_yydef = yydef;
	old_yyex = yyex;
	old_yyact = yyact;
	old_yypact = yypact;
	old_yygo = yygo;
	old_yypgo = yypgo;
	old_yyrlen = yyrlen;

	yydef = (short *)LockResource (hRes_table);
	yyex = (short *)(yydef + Sizeof_yydef);
	yyact = (short *)(yyex + Sizeof_yyex);
	yypact = (short *)(yyact + Sizeof_yyact);
	yygo = (short *)(yypact + Sizeof_yypact);
	yypgo = (short *)(yygo + Sizeof_yygo);
	yyrlen = (short *)(yypgo + Sizeof_yypgo);

	/*
	 * call the official yyparse() function
	 */

	wReturnValue = win_yyparse();

	/*
	 * unlock the resources
	 */

	UnlockResource (hRes_table);

	/*
	 * and now free the resource
	 */

	FreeResource (hRes_table);

	/*
	 * restore previous pointer values
	 */

	yydef = old_yydef;
	yyex = old_yyex;
	yyact = old_yyact;
	yypact = old_yypact;
	yygo = old_yygo;
	yypgo = old_yypgo;
	yyrlen = old_yyrlen;

	return (wReturnValue);
}	/* end yyparse */

static int win_yyparse() 

#else /* YACC_WINDOWS */

/*
 * we are not compiling a windows resource
 * based parser, so call yyparse() the old
 * standard way.
 */

yyparse() 

#endif /* YACC_WINDOWS */

{
	register short		yyi, *yyp;	/* for table lookup */
	register short		*yyps;		/* top of state stack */
	register short		yystate;	/* current state */
	register YYSTYPE	*yypv;		/* top of value stack */
	register short		*yyq;
	register int		yyj;
#if YYDEBUG
	yyTraceItems	yyx;			/* trace block */
	short	* yytp;
	int	yyruletype = 0;
#endif
#ifdef YYSTATIC
	static short	yys[YYSSIZE + 1];
	static YYSTYPE	yyv[YYSSIZE + 1];
#if YYDEBUG
	static short	yytypev[YYSSIZE+1];	/* type assignments */
#endif
#else /* ! YYSTATIC */
#ifdef YYALLOC
	YYSTYPE *yyv;
	short	*yys;
#if YYDEBUG
	short	*yytypev;
#endif
	YYSTYPE save_yylval;
	YYSTYPE save_yyval;
	YYSTYPE *save_yypvt;
	int save_yychar, save_yyerrflag, save_yynerrs;
	int retval; 			/* return value holder */
#else
	short		yys[YYSSIZE + 1];
	static YYSTYPE	yyv[YYSSIZE + 1];	/* historically static */
#if YYDEBUG
	short	yytypev[YYSSIZE+1];		/* mirror type table */
#endif
#endif /* ! YYALLOC */
#endif /* ! YYSTATIC */
#ifdef YYDYNAMIC
	char *envp;
#endif


#ifdef YYDYNAMIC
	if ((envp = getenv("YYSTACKSIZE")) != (char *)0) {
		yyssize = atoi(envp);
		if (yyssize <= 0)
			yyssize = YYSSIZE;
	}
	if ((envp = getenv("YYSTACKINC")) != (char *)0)
		yysinc = atoi(envp);
#endif
#ifdef YYALLOC
	yys = (short *) malloc((yyssize + 1) * sizeof(short));
	yyv = (YYSTYPE *) malloc((yyssize + 1) * sizeof(YYSTYPE));
#if YYDEBUG
	yytypev = (short *) malloc((yyssize + 1) * sizeof(short));
#endif
	if (yys == (short *)0 || yyv == (YYSTYPE *)0
#if YYDEBUG
		|| yytypev == (short *) 0
#endif
	) {
		yyerror("Not enough space for parser stacks");
		return 1;
	}
	save_yylval = yylval;
	save_yyval = yyval;
	save_yypvt = yypvt;
	save_yychar = yychar;
	save_yyerrflag = yyerrflag;
	save_yynerrs = yynerrs;
#endif

	yynerrs = 0;
	yyerrflag = 0;
	yyclearin;
	yyps = yys;
	yypv = yyv;
	*yyps = yystate = YYS0;		/* start state */
#if YYDEBUG
	yytp = yytypev;
	yyi = yyj = 0;			/* silence compiler warnings */
#endif

yyStack:
	yyassert((unsigned)yystate < yynstate, m_textmsg(587, "state %d\n", ""), yystate);
#ifdef YYDYNAMIC
	if (++yyps > &yys[yyssize]) {
		int yynewsize;
		int yysindex = yyps - yys;
		int yyvindex = yypv - yyv;
#if YYDEBUG
		int yytindex = yytp - yytypev;
#endif
		if (yysinc == 0) {		/* no increment */
			yyerror("Parser stack overflow");
			YYABORT;
		} else if (yysinc < 0)		/* binary-exponential */
			yynewsize = yyssize * 2;
		else				/* fixed increment */
			yynewsize = yyssize + yysinc;
		if (yynewsize < yyssize) {
			yyerror("Not enough space for parser stacks");
			YYABORT;
		}
		yyssize = yynewsize;
		yys = (short *) realloc(yys, (yyssize + 1) * sizeof(short));
		yyps = yys + yysindex;
		yyv = (YYSTYPE *) realloc(yyv, (yyssize + 1) * sizeof(YYSTYPE));
		yypv = yyv + yyvindex;
#if YYDEBUG
		yytypev = (short *)realloc(yytypev,(yyssize + 1)*sizeof(short));
		yytp = yytypev + yytindex;
#endif
		if (yys == (short *)0 || yyv == (YYSTYPE *)0
#if YYDEBUG
			|| yytypev == (short *) 0
#endif
		) {
			yyerror("Not enough space for parser stacks");
			YYABORT;
		}
	}
#else
	if (++yyps > &yys[YYSSIZE]) {
		yyerror("Parser stack overflow");
		YYABORT;
	}
#endif /* !YYDYNAMIC */
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	*++yytp = yyruletype;	/* ... and type */

	if (yydebug)
		YY_TRACE(yyShowState)
#endif

	/*
	 *	Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	YYREAD;
#endif

#ifdef YACC_WINDOWS
	if (yystate >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			YYREAD;
#endif
			yyq = yyp;
			yyi = yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~YYQYYP;
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;	/* stack what yylex() set */
				yyclearin;		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (yystate >= Sizeof_yydef)
#else /* YACC_WINDOWS */
		if (yystate >= sizeof yydef /sizeof yydef[0])
#endif /* YACC_WINDOWS */
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */
			/* Search exception table */
#ifdef YACC_WINDOWS
			yyassert((unsigned)~yyi < Sizeof_yyex,
				m_textmsg(2825, "exception %d\n", "I num"), yystate);
#else /* YACC_WINDOWS */
			yyassert((unsigned)~yyi < sizeof yyex/sizeof yyex[0],
				m_textmsg(2825, "exception %d\n", "I num"), yystate);
#endif /* YACC_WINDOWS */
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			YYREAD;
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
			yyassert(yyi >= 0,
				 m_textmsg(2826, "Ex table not reduce %d\n", "I num"), yyi);
		}
	}

	yyassert((unsigned)yyi < yynrule, m_textmsg(2827, "reduce %d\n", "I num"), yyi);
	yyj = yyrlen[yyi];
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowReduce)
	yytp -= yyj;
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $ = $1 */
#if YYDEBUG
	yyruletype = yyRules[yyrmap[yyi]].type;
#endif

	switch (yyi) {		/* perform semantic action */
		
case YYr4: {	/* command :  add_command */

      delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    
} break;

case YYr5: {	/* command :  set_command */
 
      delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    
} break;

case YYr6: {	/* command :  read_command */

      if (WitParser::instance ()->currentEntity_ != NULL)
        delete WitParser::instance ()->currentEntity_;
      WitParser::instance ()->currentEntity_ = NULL;
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ = NULL;
    
} break;

case YYr7: {	/* release_specification :  RELEASE */
 WitParser::instance ()->setParseState(WitParser::PS_release); 
} break;

case YYr8: {	/* release_specification :  RELEASE $7 release_num */

      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    
} break;

case YYr9: {	/* release_specification :  RELEASE $7 release_num $8 ';' */

      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
      free (yylval.strval);     
    
} break;

case YYr10: {	/* release_num :  STRING */
 if (!checkrel(yylval.strval)) {    
         WitParser::instance ()->myMsgFac () ("invalidRelMsg", yylval.strval);

         int i;

         for (i = 0; i < NRELS; ++ i)
            WitParser::instance ()->myMsgFac () ("validRelSmsg", relnum[i]);

         prterror();
         WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    
} break;

case YYr11: {	/* add_command :  ADD */
 
      WitParser::instance ()->setParseState(WitParser::PS_add);
      commandState = WitParser::PS_add;     
      WitParser::instance ()->currentRule_ = "add";
    
} break;

case YYr12: {	/* add_command :  ADD $11 add_clause */

      
      entryPtr = WitParser::instance ()->currentEntity_->
        lookupRule(
           WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      
      if (entryPtr == NULL) {
        switch (commandState) {
          case WitParser::PS_add:
            WitParser::instance ()->myMsgFac () ("noParamAddMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
          case WitParser::PS_set:
            WitParser::instance ()->myMsgFac () ("noParamSetMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
        };
        WitParser::instance ()->currentEntity_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    
} break;

case YYr13: {	/* add_command :  ADD $11 add_clause $12 entity_specification ';' */

      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    
} break;

case YYr14: {	/* add_clause :  entity_name */

      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            entityType);
      free (yylval.strval); 
      WitParser::instance ()->currentAttr_ = NULL;
    
} break;

case YYr15: {	/* add_clause :  PART_WITH_OPERATION */

      WitParser::instance ()->setParseState(WitParser::PS_partOperation);
      WitParser::instance ()->currentRule_ = "add_partWithOperation";

      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitEntity::partWithOperation);

      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;
      entityType = WitEntity::partWithOperation;
    
} break;

case YYr16: {	/* set_command :  SET PROBLEM */

      WitParser::instance ()->setParseState(WitParser::PS_setProblem);
      commandState = WitParser::PS_set;     

      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitEntity::problem);
      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;

      WitParser::instance ()->currentRule_ = "set_problem";
    
} break;

case YYr17: {	/* set_command :  SET PROBLEM $16 global_specification ';' */

      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    
} break;

case YYr18: {	/* set_command :  SET */
 
      WitParser::instance ()->setParseState(WitParser::PS_set);
      commandState = WitParser::PS_set;     
      WitParser::instance ()->currentRule_ = "set";
    
} break;

case YYr19: {	/* set_command :  SET $18 set_clause entity_specification ';' */

      WitParser::instance ()->setParseState(WitParser::PS_nextCommand);
    
} break;

case YYr20: {	/* set_clause :  entity_name */

      // create a WitEntity object
      WitParser::instance ()->currentEntity_ =
         new WitEntity (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            entityType);
      free (yylval.strval);
      WitParser::instance ()->currentAttr_ = NULL;

      
      entryPtr = WitParser::instance ()->currentEntity_->
        lookupRule (
           WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      
      if (entryPtr == NULL) {
        switch (commandState) {
          case WitParser::PS_add:
            WitParser::instance ()->myMsgFac () ("noParamAddMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
          case WitParser::PS_set:
            WitParser::instance ()->myMsgFac () ("noParamSetMsg",
              WitParser::instance ()->currentEntity_->entityID());
            break;
        };
        WitParser::instance ()->currentEntity_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    
} break;

case YYr21: {	/* entity_name :  PART */

      WitParser::instance ()->setParseState(WitParser::PS_part);
      WitParser::instance ()->currentRule_ += "_part";
      entityType = WitEntity::part;
    
} break;

case YYr22: {	/* entity_name :  OPERATION */

      WitParser::instance ()->setParseState(WitParser::PS_operation);
      WitParser::instance ()->currentRule_ += "_operation";
      entityType = WitEntity::operation;
    
} break;

case YYr23: {	/* entity_name :  BOM_ENTRY */

      WitParser::instance ()->setParseState(WitParser::PS_bomEntry);
      WitParser::instance ()->currentRule_ += "_bomEntry";
      entityType = WitEntity::bomEntry;
    
} break;

case YYr24: {	/* entity_name :  SUB_ENTRY */

      WitParser::instance ()->setParseState(WitParser::PS_subEntry);
      WitParser::instance ()->currentRule_ += "_subEntry";
      entityType = WitEntity::subEntry;
    
} break;

case YYr25: {	/* entity_name :  BOP_ENTRY */

      WitParser::instance ()->setParseState(WitParser::PS_bopEntry);
      WitParser::instance ()->currentRule_ += "_bopEntry";
      entityType = WitEntity::bopEntry;
    
} break;

case YYr26: {	/* entity_name :  DEMAND */

      WitParser::instance ()->setParseState(WitParser::PS_demand);
      WitParser::instance ()->currentRule_ += "_demand";
      entityType = WitEntity::demand;
    
} break;

case YYr28: {	/* entity_specification :  argument_list */

      

      if (entryPtr != NULL) {
        
        

        retcode = WitParser::instance ()->currentEntity_->checkArgs(entryPtr);
        if (retcode == BAD_NUM_ARGS) {
          if (entryPtr->nparms() == 1)
            s2 = "argument";
          else s2 = "arguments";
          if (WitParser::instance ()->currentEntity()->argc() == 1)
            s3 = "was found";
          else s3 = "were found";

          s1 = "";
          if (commandState == WitParser::PS_add)
            s1 = "add "; 
          if (commandState == WitParser::PS_set)
            s1 = "set ";

          WitParser::instance ()->myMsgFac () ("incorrectNumberArgMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2,
             WitParser::instance ()->currentEntity()->argc(),
             s3);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
        else
        if (retcode) {
          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }

        else                                    
        if (entryPtr->func() != NULL) {         

          
          
          if (!WitParser::instance ()->currentEntity_->invalid())
            (entryPtr->func())();               
        }
      };  

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
    
} break;

case YYr30: {	/* category :  CATEGORY */
 
      if (WitParser::instance ()->parseState() == WitParser::PS_part)
      yyval.cval = yypvt[0].cval;
    
} break;

case YYr32: {	/* attribute_list :  attribute_list attribute */

      WitParser::instance ()->setParseState(WitParser::PS_nextAttr);

      
      

      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      else
      {
        retcode = WitParser::instance ()->currentAttr_->checkArgs(entryPtr);
        if (retcode == PERIOD_ERROR) {
           WitParser::instance ()->currentAttr_->setInvalid(true);
           prterror();
        }            
        else
        if (retcode) {
          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
        else 
        if (entryPtr->func() != NULL) {        

          
          
          if (!WitParser::instance ()->currentEntity_->invalid() &&
            !WitParser::instance ()->currentAttr_->invalid())
            retcode = (entryPtr->func())();    
            if (retcode) {
              WitParser::instance ()->currentAttr_->setInvalid(true);
              prterror();
            }; 
        } 
      };                   

      WitParser::instance ()->currentRule_ =
         WitParser::instance ()->previousRule_;
    
} break;

case YYr35: {	/* argument :  simple_value */

      WitParser::instance ()->setParseState(WitParser::PS_nextArg);
      switch(yypvt[0].pval) {
        case WitDRParmType::intScalar:
          argPtr =
             WitParser::instance ()->currentEntity_->setIntArg(yylval.intval);
          break;
        case WitDRParmType::doubleScalar:
          argPtr =
             WitParser::instance ()->currentEntity_->
                setDoubleArg(yylval.doubleval);
          break;
        case WitDRParmType::boolScalar:
          argPtr = WitParser::instance ()->currentEntity_->
            setBoolArg(yylval.boolval);
          break;
        case WitDRParmType::string:
          argPtr =
             WitParser::instance ()->currentEntity_->
                setStringArg(yylval.strval);

          
          free (yylval.strval);
          break;
        default:
          return 0;
      };
      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        
        
        

        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
      }
    
} break;

case YYr36: {	/* argument :  category */

      WitParser::instance ()->setParseState(WitParser::PS_nextArg);
      argPtr = WitParser::instance ()->currentEntity_->
        setCatArg (static_cast <WitDRPartCat::Tag> (yylval.cval));
      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        
        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentEntity_->entityID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentEntity_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
     }
    
} break;

case YYr40: {	/* attribute_name :  IDENTIFIER */

      WitParser::instance ()->setParseState(WitParser::PS_attr);
      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");

      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (WitParser::instance ()->myProblem (), yylval.strval);

      free (yylval.strval);

      
      
      entryPtr = WitParser::instance ()->currentAttr_->
        lookupRule(WitParser::instance ()->theSymTable_,
           WitParser::instance ()->currentRule_);

      
      
      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }

      yyval.strval = yypvt[0].strval;
    
} break;

case YYr41: {	/* attribute_value :  simple_value */

      switch(yypvt[0].pval) {
        case WitDRParmType::intScalar:
          argPtr =
             WitParser::instance ()->currentAttr_->setIntArg(yylval.intval);
          break;
        case WitDRParmType::doubleScalar:
          argPtr =
             WitParser::instance ()->currentAttr_->setDoubleArg(yylval.doubleval);
          break;
        case WitDRParmType::boolScalar:
          argPtr = WitParser::instance ()->currentAttr_->
            setBoolArg(yylval.boolval);
          break;
        case WitDRParmType::string:
          argPtr =
             WitParser::instance ()->currentAttr_->setStringArg(yylval.strval);

          
          free (yylval.strval);
          break;
        default:
          return 0;
      };

      if (argPtr == NULL) {
        s1 = "";
        if (commandState == WitParser::PS_add)
          s1 = "add ";
        if (commandState == WitParser::PS_set)
          s1 = "set ";

        if (entryPtr != NULL) {
          if (entryPtr->nparms() == 1)
            s2 = "argument is";
          else s2 = "arguments are";

          WitParser::instance ()->myMsgFac () ("tooManyArgsMsg",
             s1,
             WitParser::instance ()->currentAttr_->attrID(),
             entryPtr->nparms(),
             s2);

          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
        }
      }
    
} break;

case YYr42: {	/* attribute_value :  vector_format */
 yyval.pval = WitDRParmType::undefined; 
} break;

case YYr43: {	/* simple_value :  STRING */
 yyval.pval = WitDRParmType::string; 
} break;

case YYr44: {	/* simple_value :  INTEGER */
 yyval.pval = WitDRParmType::intScalar; 
} break;

case YYr45: {	/* simple_value :  DOUBLE */
 yyval.pval = WitDRParmType::doubleScalar; 
} break;

case YYr46: {	/* simple_value :  BOOLEAN */
 yyval.pval = WitDRParmType::boolScalar; 
} break;

case YYr47: {	/* vector_format :  SINGLE */

      WitParser::instance ()->setParseState(WitParser::PS_single);

      // Construct a VectorSpec object
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (
                WitParser::instance ()->myProblem (),
                WitVectorSpec::single_,
                entryPtr->parmTypes()[0]);

          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else 
        vecPtr =
           new WitVectorSpec (
              WitParser::instance ()->myProblem (),
              WitVectorSpec::single_,
              WitDRParmType::doubleVector);
    
} break;

case YYr48: {	/* vector_format :  SINGLE $47 '(' */

      WitParser::instance ()->setParseState(WitParser::PS_singleParen);
    
} break;

case YYr49: {	/* vector_format :  SINGLE $47 '(' $48 vector_value */

      WitParser::instance ()->setParseState(WitParser::PS_singleValue);
    
} break;

case YYr50: {	/* vector_format :  SINGLE $47 '(' $48 vector_value $49 ')' */

      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    
} break;

case YYr51: {	/* vector_format :  SPARSE */

      WitParser::instance ()->setParseState(WitParser::PS_sparse);

      
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (
                WitParser::instance ()->myProblem (),
                WitVectorSpec::sparse_,
                entryPtr->parmTypes()[0]);
          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else
         vecPtr =
            new WitVectorSpec (
               WitParser::instance ()->myProblem (),
               WitVectorSpec::sparse_,
               WitDRParmType::doubleVector);
    
} break;

case YYr52: {	/* vector_format :  SPARSE $51 '(' */

      WitParser::instance ()->setParseState(WitParser::PS_sparseParen);
    
} break;

case YYr53: {	/* vector_format :  SPARSE $51 '(' $52 sparse_list ')' */

      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    
} break;

case YYr54: {	/* vector_format :  DENSE */

      WitParser::instance ()->setParseState(WitParser::PS_dense);

      // Construct a VectorSpec object
      if (WitParser::instance ()->currentAttr_->attrType() ==
          WitAttribute::simple) {
        if (entryPtr != NULL) {
          vecPtr =
             new WitVectorSpec (WitParser::instance ()->myProblem (),
                WitVectorSpec::dense_,
                entryPtr->parmTypes()[0]);
          argPtr = WitParser::instance ()->currentAttr_->setVectorArg(vecPtr);
        }
      }
      else
         vecPtr =
            new WitVectorSpec (
               WitParser::instance ()->myProblem (),
               WitVectorSpec::dense_,
               WitDRParmType::doubleVector);
    
} break;

case YYr55: {	/* vector_format :  DENSE $54 '(' */

      WitParser::instance ()->setParseState(WitParser::PS_denseParen);
    
} break;

case YYr56: {	/* vector_format :  DENSE $54 '(' $55 value_list ')' */

      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    
} break;

case YYr58: {	/* sparse_list :  sparse_list period_value */

      WitParser::instance ()->setParseState(WitParser::PS_sparseValue);
    
} break;

case YYr59: {	/* period_value :  period ':' */

      WitParser::instance ()->setParseState(WitParser::PS_periodColon);
    
} break;

case YYr60: {	/* period_value :  period ':' $59 vector_value */
 
      WitParser::instance ()->setParseState(WitParser::PS_sparseParen);
      yyval.pval = yypvt[0].pval; 
    
} break;

case YYr63: {	/* vector_value :  simple_value */

      WitParser::instance ()->setParseState(WitParser::PS_denseValue);

      if (entryPtr != NULL) {
      switch(yypvt[0].pval) {

        case WitDRParmType::intScalar:
          if (entryPtr->parmTypes()[0] == WitDRParmType::doubleVector) {
            retcode =
               vecPtr->addDoubleVal(static_cast <double> (yylval.intval));
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::intVector) {
            retcode = vecPtr->addIntVal(yylval.intval);
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::boundSet) {
            retcode =
               vecPtr->addDoubleVal(static_cast <double> (yylval.intval));
            break;
          }
          else {
            retcode = WRONG_TYPE;
            break;
          };
          
        case WitDRParmType::doubleScalar:
         if (entryPtr->parmTypes()[0] == WitDRParmType::intVector) {
            vecPtr->addIntVal(static_cast <int> (yylval.doubleval));
            retcode = SHOULD_BE_INT;
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::doubleVector) {
            retcode = vecPtr->addDoubleVal(yylval.doubleval);
            break;
          };
          if (entryPtr->parmTypes()[0] == WitDRParmType::boundSet) {
            retcode = vecPtr->addDoubleVal(yylval.doubleval);
            break;
          }
          else {
            retcode = WRONG_TYPE;
            break;
          };

        case WitDRParmType::boolScalar:
           {
           if (entryPtr->parmTypes()[0] == WitDRParmType::boolVector)
              {
              retcode = vecPtr->addBoolVal (yylval.boolval);

              break;
              };

           WitParser::instance ()->myMsgFac () ("booleanVectorMsg",
              WitParser::instance ()->currentAttr_->attrID ());

           WitParser::instance ()->currentAttr_->setInvalid (true);

           prterror ();

           retcode = 0;

           WitParser::instance ()->myMsgFac () ("parsingStopsMsg");

           break;
           }

        case WitDRParmType::string:
          WitParser::instance ()->myMsgFac () ("stringVectorMsg",
             WitParser::instance ()->currentAttr_->attrID());
          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          free (yylval.strval);
          retcode = 0;
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
          break;
      }

      if (retcode == WRONG_TYPE) {
        WitParser::instance ()->myMsgFac () ("vecTypeNotValidMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        retcode = 0;
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      if (retcode == SHOULD_BE_INT) {
        WitParser::instance ()->myMsgFac () ("vecValueNotIntMsg",
           WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        retcode = 0;
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
      }
    
} break;

case YYr64: {	/* period :  INTEGER */

      WitParser::instance ()->setParseState(WitParser::PS_period);

      retcode = vecPtr->addPeriodVal(yylval.intval);
      if (retcode == PERIOD_ERROR) {
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      }
      if (retcode == PERIOD_DUP) {
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      }
    
} break;

case YYr65: {	/* bound_set_attribute :  bound_set_type */
  
      
      entryPtr = WitParser::instance ()->currentAttr_->
         lookupRule (
            WitParser::instance ()->theSymTable_,
            WitParser::instance ()->currentRule_);

      if (entryPtr == NULL) {
        WitParser::instance ()->myMsgFac () ("noAttributeDefMsg",
          WitParser::instance ()->currentAttr_->attrID(),
          WitParser::instance ()->currentEntity_->entityID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }
    
} break;

case YYr66: {	/* bound_set_attribute :  bound_set_type $65 bounds_specification END_BOUNDS */

      bndPtr = NULL;
      WitParser::instance ()->setParseState(WitParser::PS_endBounds);
    
} break;

case YYr67: {	/* bound_set_type :  EXEC_BOUNDS */

      WitParser::instance ()->setParseState(WitParser::PS_nextBound);

      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::exec);

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);

      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      yyval.strval = yypvt[0].strval;
    
} break;

case YYr68: {	/* bound_set_type :  STOCK_BOUNDS */
 
      WitParser::instance ()->setParseState(WitParser::PS_nextBound);

      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::stock);

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);

      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      yyval.strval = yypvt[0].strval;
    
} break;

case YYr69: {	/* bound_set_type :  CUM_SHIP_BOUNDS */

      WitParser::instance ()->setParseState(WitParser::PS_nextBound);

      // Construct a BoundSetSpec object
      bndPtr = new WitBoundSetSpec(WitBoundSetSpec::cumShip);

      WitParser::instance ()->previousRule_ =
         WitParser::instance ()->currentRule_.replace(0, 3, "set");
      WitParser::instance ()->currentRule_ += "_";
      WitParser::instance ()->currentRule_ += yylval.strval;

      
      if (WitParser::instance ()->currentAttr_ != NULL)
        delete WitParser::instance ()->currentAttr_;
      WitParser::instance ()->currentAttr_ =
         new WitAttribute (
            WitParser::instance ()->myProblem (),
            yylval.strval,
            WitAttribute::boundSet);
      argPtr = WitParser::instance ()->currentAttr_->setBoundSetArg(bndPtr);

      free (yylval.strval);
      yyval.strval = yypvt[0].strval;
    
} break;

case YYr71: {	/* bounds_specification :  bounds_specification bound_item */

      WitParser::instance ()->setParseState(WitParser::PS_nextBound);
    
} break;

case YYr72: {	/* bound_item :  bound_type */

      WitParser::instance ()->setParseState(WitParser::PS_boundType);
    
} break;

case YYr73: {	/* bound_item :  bound_type $72 vector_format */

       switch (yypvt[-2].btype) {
         case WitBoundSetSpec::hardlb:
           bndPtr->setHardLBVec(vecPtr);
           break;

         case WitBoundSetSpec::softlb:
           bndPtr->setSoftLBVec(vecPtr);
           break;

         case WitBoundSetSpec::hardub:
           bndPtr->setHardUBVec(vecPtr);
           break;
       }
    
} break;

case YYr74: {	/* bound_type :  HARDLB */

      if (bndPtr->hardLBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateHardLBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      yyval.btype = WitBoundSetSpec::hardlb;
    
} break;

case YYr75: {	/* bound_type :  SOFTLB */

      if (bndPtr->softLBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateSoftLBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      yyval.btype = WitBoundSetSpec::softlb;
    
} break;

case YYr76: {	/* bound_type :  HARDUB */

      if (bndPtr->hardUBVec() != NULL) {
        WitParser::instance ()->myMsgFac () ("duplicateHardUBMsg",
          WitParser::instance ()->currentAttr_->attrID());
        WitParser::instance ()->currentAttr_->setInvalid(true);
        prterror();
      };
      yyval.btype = WitBoundSetSpec::hardub;
    
} break;

case YYr77: {	/* read_command :  READ */

      WitParser::instance ()->setParseState(WitParser::PS_read);
      commandState = WitParser::PS_read;
      WitParser::instance ()->currentRule_ = "read";
      // printf("Current rule is: %s\n", WitParser::instance ()->currentRule_);
    
} break;

case YYr78: {	/* read_command :  READ $77 file_name */

      WitParser::instance ()->setParseState(WitParser::PS_commandEnd);
    
} break;

case YYr79: {	/* read_command :  READ $77 file_name $78 ';' */

      
      errno   = 0;
      retcode = WitParlex::saveFile(yylval.strval);
      if (retcode == FOPEN_ERROR) {
        yylval.strval[strlen(yylval.strval)-1] = '\0';
        WitParser::instance ()->myMsgFac () ("fopenSmsg",
           yylval.strval+1,
          "r",
          errno,
          strerror(errno));
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }

      if (retcode == STACK_OVERFLOW) {
        WitParser::instance ()->myMsgFac () ("stackOverflowMsg", STACKSIZE);
        prterror();
        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
      }

//    printf("Lexer is now reading from file %s\n", WitParlex::fileName());

      WitParser::instance ()->setDataFileName   ();
      WitParser::instance ()->setDataFileLineNo ();

      WitParser::instance ()->setParseState(WitParser::PS_initial);
      free (yylval.strval);
    
} break;
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}

	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)
		;

	yystate = ~(yyi == *--yyp? YYQYYP: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
/*
#pragma used yyerrlabel
 */
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--;
		yypv--;
#if YYDEBUG
		yytp--;
#endif
	}

yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = yychar;
		yyerror("Syntax error");
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > yys; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*yyps >= Sizeof_yypact)
#else /* YACC_WINDOWS */
			if (*yyps >= sizeof yypact/sizeof yypact[0])
#endif /* YACC_WINDOWS */
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);

			if (YYERRCODE == yyp[-1]) {
				yystate = ~YYQYYP;
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > yys+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin;
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

#ifdef YYALLOC
yyReturn:
	yylval = save_yylval;
	yyval = save_yyval;
	yypvt = save_yypvt;
	yychar = save_yychar;
	yyerrflag = save_yyerrflag;
	yynerrs = save_yynerrs;
	free((char *)yys);
	free((char *)yyv);
#if YYDEBUG
	free((char *)yytypev);
#endif
	return(retval);
#endif
}

		
#if YYDEBUG
/*
 * Return type of token
 */
int
yyGetType(tok)
int tok;
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}
/*
 * Print a token legibly.
 */
char *
yyptok(tok)
int tok;
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}

/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

static char *
yygetState(num)
int num;
{
	int	size;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(yyStates[num+1] - yyStates[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - yyStates[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, yyStates[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
yyExpandName(num, isrule, buf, len)
int num, isrule;
char * buf;
int len;
{
	int	i, n, cnt, type;
	char	* endp, * cp;
	char	*s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
yyShowState(tp)
yyTraceItems * tp;
{
	short * p;
	YYSTYPE * q;

	printf(
	    m_textmsg(2828, "state %d (%d), char %s (%d)\n", "I num1 num2 char num3"),
	      yysmap[tp->state], tp->state,
	      yyptok(tp->lookahead), tp->lookahead);
}
/*
 * show results of reduction
 */
void
yyShowReduce(tp)
yyTraceItems * tp;
{
	printf("reduce %d (%d), pops %d (%d)\n",
		yyrmap[tp->rule], tp->rule,
		tp->states[tp->nstates - tp->npop],
		yysmap[tp->states[tp->nstates - tp->npop]]);
}
void
yyShowRead(val)
int val;
{
	printf(m_textmsg(2829, "read %s (%d)\n", "I token num"), yyptok(val), val);
}
void
yyShowGoto(tp)
yyTraceItems * tp;
{
	printf(m_textmsg(2830, "goto %d (%d)\n", "I num1 num2"), yysmap[tp->state], tp->state);
}
void
yyShowShift(tp)
yyTraceItems * tp;
{
	printf(m_textmsg(2831, "shift %d (%d)\n", "I num1 num2"), yysmap[tp->state], tp->state);
}
void
yyShowErrRecovery(tp)
yyTraceItems * tp;
{
	short	* top = tp->states + tp->nstates - 1;

	printf(
	m_textmsg(2832, "Error recovery pops state %d (%d), uncovers %d (%d)\n", "I num1 num2 num3 num4"),
		yysmap[*top], *top, yysmap[*(top-1)], *(top-1));
}
void
yyShowErrDiscard(tp)
yyTraceItems * tp;
{
	printf(m_textmsg(2833, "Error recovery discards %s (%d), ", "I token num"),
		yyptok(tp->lookahead), tp->lookahead);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */
@


1.19
log
@Changed WitNonClass::strerror to strerror.
@
text
@d2457 1
@


1.18
log
@[multi-thread]
@
text
@d2464 1
a2464 1
          WitNonClass::strerror(errno));
@


1.17
log
@[exceptions]
@
text
@a100 3
#include <stdio.h>
//#include <iostream.h>
#include <stdlib.h>
a101 1
#include <string.h>
@


1.16
log
@Removed include of deleted header file.
@
text
@d93 1
d96 1
a96 2
#include <wit/src/Parlex.h>
#include <wit/src/SymTable.h>
a98 1
#include <wit/src/Parser.h>
d1036 1
a1036 1
   myProblem ()->myApiMgr ()->myInputId ()->setDataFileName (fileName ());
d1043 1
a1043 1
   myProblem ()->myApiMgr ()->myInputId ()->setDataFileLineNo (lineno ());
@


1.15
log
@[exceptions]
@
text
@a95 1
#include <wit/src/witLexer.h>
@


1.14
log
@[exceptions]
@
text
@d100 1
a100 1
#include <wit/src/witParse.h>
d793 1
a793 1
// The parse states are defined in witParse.h:
@


1.13
log
@[exceptions]
@
text
@a1052 1
      theLexer_      (NULL),
a1060 1
   theLexer_    = new WitLexer;
a1065 1
   delete theLexer_;
@


1.12
log
@Vector Prop-Rt.
@
text
@d1053 1
a1053 1
      theLexer       (NULL),
d1055 2
a1056 2
      currentRule    (),
      previousRule   (),
d1062 1
a1062 1
   theLexer     = new WitLexer;
d1068 1
a1068 1
   delete theLexer;
d1519 1
a1519 1
      WitParser::instance ()->currentRule = "add";
d1529 1
a1529 1
           WitParser::instance ()->currentRule);
d1572 1
a1572 1
      WitParser::instance ()->currentRule = "add_partWithOperation";
d1601 1
a1601 1
      WitParser::instance ()->currentRule = "set_problem";
d1615 1
a1615 1
      WitParser::instance ()->currentRule = "set";
d1640 1
a1640 1
           WitParser::instance ()->currentRule);
d1664 1
a1664 1
      WitParser::instance ()->currentRule += "_part";
d1672 1
a1672 1
      WitParser::instance ()->currentRule += "_operation";
d1680 1
a1680 1
      WitParser::instance ()->currentRule += "_bomEntry";
d1688 1
a1688 1
      WitParser::instance ()->currentRule += "_subEntry";
d1696 1
a1696 1
      WitParser::instance ()->currentRule += "_bopEntry";
d1704 1
a1704 1
      WitParser::instance ()->currentRule += "_demand";
d1761 2
a1762 2
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
d1816 2
a1817 2
      WitParser::instance ()->currentRule =
         WitParser::instance ()->previousRule;
d1914 2
a1915 2
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
d1917 2
a1918 2
      WitParser::instance ()->currentRule += "_";
      WitParser::instance ()->currentRule += yylval.strval;
d1932 1
a1932 1
           WitParser::instance ()->currentRule);
d2279 1
a2279 1
            WitParser::instance ()->currentRule);
d2306 4
a2309 4
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
      WitParser::instance ()->currentRule += "_";
      WitParser::instance ()->currentRule += yylval.strval;
d2334 4
a2337 4
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
      WitParser::instance ()->currentRule += "_";
      WitParser::instance ()->currentRule += yylval.strval;
d2362 4
a2365 4
      WitParser::instance ()->previousRule =
         WitParser::instance ()->currentRule.replace(0, 3, "set");
      WitParser::instance ()->currentRule += "_";
      WitParser::instance ()->currentRule += yylval.strval;
d2452 2
a2453 2
      WitParser::instance ()->currentRule = "read";
      // printf("Current rule is: %s\n", WitParser::instance ()->currentRule);
d2469 5
a2473 2
        WitParser::instance ()->myMsgFac () ("fopenErrorMsg", yylval.strval+1,
          "r", errno, WitNonClass::strerror(errno));
@


1.11
log
@Vector PropRt.
@
text
@d2033 1
a2033 1
                static_cast <WitDRParmType::Tag> (entryPtr->parmTypes()[0]));
d2077 1
a2077 1
                static_cast <WitDRParmType::Tag> (entryPtr->parmTypes()[0]));
d2113 1
a2113 1
                static_cast <WitDRParmType::Tag> (entryPtr->parmTypes()[0]));
d2207 1
a2207 1
              retcode = vecPtr->addIntVal (yylval.boolval);
@


1.10
log
@Removed portableFree.
@
text
@d955 3
d2204 21
a2224 7
          WitParser::instance ()->myMsgFac () ("booleanVectorMsg",
            WitParser::instance ()->currentAttr_->attrID());
          WitParser::instance ()->currentAttr_->setInvalid(true);
          prterror();
          retcode = 0;
          WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
          break;
@


1.9
log
@Double Precision.
@
text
@d1493 1
a1493 1
      WitNonClass::portableFree(yylval.strval);     
d1561 1
a1561 1
      WitNonClass::portableFree(yylval.strval); 
d1578 1
a1578 1
      WitNonClass::portableFree(yylval.strval);
d1595 1
a1595 1
      WitNonClass::portableFree(yylval.strval);
d1630 1
a1630 1
      WitNonClass::portableFree(yylval.strval);
d1841 1
a1841 1
          WitNonClass::portableFree(yylval.strval);
d1923 1
a1923 1
      WitNonClass::portableFree(yylval.strval);
d1966 1
a1966 1
          WitNonClass::portableFree(yylval.strval);
d2214 1
a2214 1
          WitNonClass::portableFree(yylval.strval);
d2305 1
a2305 1
      WitNonClass::portableFree(yylval.strval);
d2333 1
a2333 1
      WitNonClass::portableFree(yylval.strval);
d2360 1
a2360 1
      WitNonClass::portableFree(yylval.strval);
d2470 1
a2470 1
      WitNonClass::portableFree(yylval.strval);
@


1.8
log
@Double Precision.
@
text
@d142 7
a148 9
    int      intval;
    double   doubleval;
    char     *strval;
    int      boolval;
    int      subtok;
    int      cval;
    int      eval;
    int      pval;
    int      btype;
d1833 1
a1833 1
            setBoolArg((bool) yylval.boolval);
d1959 1
a1959 1
            setBoolArg((bool) yylval.boolval);
@


1.7
log
@Modified to compile with Bob's latest changes.  WitUtil was changed to WitNonClass.
@
text
@d143 1
a143 1
    float    floatval;
d175 1
a175 1
#define FLOAT	280
d185 1
a185 1
enum YY_Types { YY_t_NoneDefined, YY_t_strval, YY_t_floatval, YY_t_intval, YY_t_boolval, YY_t_cval, YY_t_pval, YY_t_btype
d300 1
a300 1
	{ "FLOAT",  280,  2},
d942 1
a942 1
        case Integer:
d945 2
a946 2
        case Float:
          s1 = "float";
d948 1
a948 1
        case String:
d951 1
a951 1
        case Boolean:
d954 1
a954 1
        case Category:
d957 1
a957 1
        case IntVector:
d960 2
a961 2
        case FloatVector:
          s1 = "\"float vector\"";
d963 1
a963 1
        case BoundSet:
d1824 1
a1824 1
        case Integer:
d1828 1
a1828 1
        case Float:
d1831 1
a1831 1
                setFloatArg(yylval.floatval);
d1833 1
a1833 1
        case Boolean:
d1837 1
a1837 1
        case String:
d1882 1
a1882 1
        setCatArg((category) yylval.cval);
d1951 1
a1951 1
        case Integer:
d1955 1
a1955 1
        case Float:
d1957 1
a1957 1
             WitParser::instance ()->currentAttr_->setFloatArg(yylval.floatval);
d1959 1
a1959 1
        case Boolean:
d1963 1
a1963 1
        case String:
d2001 1
a2001 1
 yyval.pval = Undefined; 
d2005 1
a2005 1
 yyval.pval = String; 
d2009 1
a2009 1
 yyval.pval = Integer; 
d2012 2
a2013 2
case YYr45: {	/* simple_value :  FLOAT */
 yyval.pval = Float; 
d2017 1
a2017 1
 yyval.pval = Boolean; 
d2032 1
a2032 1
               (pType) entryPtr->parmTypes()[0]);
d2042 1
a2042 1
              FloatVector);
d2076 1
a2076 1
                (pType) entryPtr->parmTypes()[0]);
d2085 1
a2085 1
               FloatVector);
d2112 1
a2112 1
                (pType) entryPtr->parmTypes()[0]);
d2121 1
a2121 1
               FloatVector);
d2163 4
a2166 3
        case Integer:
          if (entryPtr->parmTypes()[0] == FloatVector) {
            retcode = vecPtr->addFloatVal((float) yylval.intval);
d2169 1
a2169 1
          if (entryPtr->parmTypes()[0] == IntVector) {
d2173 3
a2175 2
          if (entryPtr->parmTypes()[0] == BoundSet) {
            retcode = vecPtr->addFloatVal((float) yylval.intval);
d2183 3
a2185 3
        case Float:
         if (entryPtr->parmTypes()[0] == IntVector) {
            vecPtr->addIntVal((int) yylval.floatval);
d2189 2
a2190 2
          if (entryPtr->parmTypes()[0] == FloatVector) {
            retcode = vecPtr->addFloatVal(yylval.floatval);
d2193 2
a2194 2
          if (entryPtr->parmTypes()[0] == BoundSet) {
            retcode = vecPtr->addFloatVal(yylval.floatval);
d2202 1
a2202 1
        case Boolean:
d2211 1
a2211 1
        case String:
@


1.6
log
@Removed includes for iostream.h
@
text
@d1495 1
a1495 1
      WitUtil::portableFree(yylval.strval);     
d1563 1
a1563 1
      WitUtil::portableFree(yylval.strval); 
d1580 1
a1580 1
      WitUtil::portableFree(yylval.strval);
d1597 1
a1597 1
      WitUtil::portableFree(yylval.strval);
d1632 1
a1632 1
      WitUtil::portableFree(yylval.strval);
d1843 1
a1843 1
          WitUtil::portableFree(yylval.strval);
d1925 1
a1925 1
      WitUtil::portableFree(yylval.strval);
d1968 1
a1968 1
          WitUtil::portableFree(yylval.strval);
d2214 1
a2214 1
          WitUtil::portableFree(yylval.strval);
d2305 1
a2305 1
      WitUtil::portableFree(yylval.strval);
d2333 1
a2333 1
      WitUtil::portableFree(yylval.strval);
d2360 1
a2360 1
      WitUtil::portableFree(yylval.strval);
d2453 1
a2453 1
          "r", errno, WitUtil::strerror(errno));
d2470 1
a2470 1
      WitUtil::portableFree(yylval.strval);
@


1.5
log
@updated to compile on windows
@
text
@d104 1
a104 1
#include <iostream.h>
@


1.4
log
@modications to change rogueWave tools.h++ to STL
@
text
@d1542 1
a1542 1
        WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d1653 1
a1653 1
        WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d1739 1
a1739 1
          WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d1745 1
a1745 1
          WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d1783 1
a1783 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d1791 1
a1791 1
           WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d1796 1
a1796 1
          WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d1809 1
a1809 1
              WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d1835 1
a1835 1
            setBoolArg((WitBoolean) yylval.boolval);
d1870 1
a1870 1
          WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d1902 1
a1902 1
          WitParser::instance ()->currentEntity_->setInvalid(witTRUE);
d1939 1
a1939 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d1961 1
a1961 1
            setBoolArg((WitBoolean) yylval.boolval);
d1992 1
a1992 1
          WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2203 1
a2203 1
          WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2212 1
a2212 1
          WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2223 1
a2223 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2231 1
a2231 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2246 1
a2246 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2250 1
a2250 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2268 1
a2268 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2400 1
a2400 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2412 1
a2412 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
d2424 1
a2424 1
        WitParser::instance ()->currentAttr_->setInvalid(witTRUE);
@


1.3
log
@Updated to match changes Bob made in April to witParse.y and witLexer.l in the src directory
@
text
@d2 6
a124 1
RWCollectableString   *rulePtr;
@


1.3.2.1
log
@Removed RWcollectable
@
text
@a1 6

#if defined(_MSC_VER)
  #pragma warning(disable:4786)
  #pragma warning(disable:4503)
#endif

d119 1
@


1.2
log
@Updated to allow 6.0 to be a valid release number in wit data file
@
text
@d95 1
@


1.1
log
@Adding build of diner to wit/mds
(building of diner on windows platform)
@
text
@d130 1
a130 1
char      *relnum[] = {"4.0", "5.0"};
@


head	1.11;
access;
symbols
	sce_5_01_20080919:1.11
	latest_sce_4_20_20060523:1.11.0.4
	sce_4_20_20060523:1.11
	latest_sce4_20_OSL:1.11.0.2
	sce_4_20_OSL:1.11
	sce_410_withVa:1.10
	sce_4_05_20040511:1.7
	sce_4_00_20040201:1.5
	nextGenBranch:1.4.0.2
	nextGenRoot:1.4
	sce_3_30_20030627:1.4
	EndRw-branch:1.2.0.4
	Root-of-EndRw:1.2
	rwToStl:1.2.0.2
	latest_sce_3_10_20010924:1.1.0.2
	sce_3_10_20010924:1.1;
locks; strict;
comment	@// @;


1.11
date	2005.11.22.14.02.32;	author fasano;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.07.18.18.10;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.07.16.00.58;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.05.15.43.58;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.13.20.28.41;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.31.20.01.58;	author gresh;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.12.19.39.06;	author fasano;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.09.13.10.03;	author rwToStl;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.06.17.46.16;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.08.01.03.55;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.10.19.07.03;	author fasano;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Changes to have wit build with witParse.C, witLexer.C and ytab.h moved from mds directory to src directory
@
text
@/* This file has been moved from the mds to src directory. */@


1.10
log
@[exceptions]
@
text
@d1 1
a1 1091
/* lex -l d:\implode\wit\src\witLexer.l */
#define YYNEWLINE 10
#define INITIAL 0
#define yy_endst 196
#define yy_nxtmax 692
#define YY_LA_SIZE 25

static unsigned short yy_la_act[] = {
 33, 37, 33, 37, 33, 37, 33, 37, 33, 37, 33, 37, 33, 37, 33, 37,
 33, 37, 33, 37, 33, 37, 24, 37, 37, 25, 37, 37, 33, 37, 33, 37,
 37, 33, 37, 34, 35, 37, 37, 37, 36, 36, 35, 33, 31, 544, 33, 33,
 33, 30, 33, 33, 33, 29, 33, 26, 26, 25, 27, 28, 27, 33, 33, 33,
 33, 33, 33, 23, 33, 33, 33, 33, 33, 33, 21, 33, 19, 33, 33, 33,
 33, 33, 33, 33, 33, 22, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
 33, 17, 33, 33, 33, 33, 33, 33, 33, 33, 33, 18, 33, 33, 33, 33,
 33, 33, 33, 33, 15, 33, 33, 33, 33, 33, 14, 33, 33, 33, 10, 33,
 33, 33, 33, 33, 33, 33, 33, 9, 33, 33, 33, 33, 33, 7, 33, 33,
 33, 33, 33, 33, 33, 33, 6, 33, 33, 33, 33, 5, 33, 33, 33, 33,
 33, 33, 33, 33, 33, 33, 33, 33, 33, 11, 33, 33, 33, 33, 33, 4,
 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 20, 33, 33, 33, 33, 33,
 33, 33, 33, 33, 16, 33, 33, 33, 33, 13, 33, 33, 33, 33, 12, 33,
 33, 33, 33, 33, 33, 8, 33, 2, 33, 33, 1, 33, 33, 33, 33, 3,
 33, 33, 33, 33, 0, 33, 0
};

static unsigned char yy_look[] = {
 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0
};

static short yy_final[] = {
 0, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 25, 27,
 28, 30, 32, 33, 35, 36, 38, 39, 40, 41, 42, 43, 44, 44, 45, 46,
 47, 48, 49, 51, 52, 53, 55, 56, 56, 56, 57, 58, 59, 59, 59, 60,
 60, 60, 61, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74,
 76, 78, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 93,
 94, 95, 96, 97, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111,
 112, 113, 114, 115, 116, 118, 119, 120, 121, 122, 124, 125, 126, 128, 129, 130,
 131, 132, 133, 134, 135, 137, 138, 139, 140, 141, 143, 144, 145, 146, 147, 148,
 149, 150, 152, 153, 154, 155, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166,
 167, 168, 169, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184,
 185, 186, 188, 189, 190, 191, 192, 193, 194, 195, 196, 198, 199, 200, 201, 203,
 204, 205, 206, 208, 209, 210, 211, 212, 213, 215, 217, 218, 220, 221, 222, 223,
 225, 226, 227, 228, 230
};
#ifndef yy_state_t
#define yy_state_t unsigned char
#endif

static yy_state_t yy_begin[] = {
 0, 0, 0
};

static yy_state_t yy_next[] = {
 23, 23, 23, 23, 23, 23, 23, 23, 23, 21, 20, 23, 23, 21, 23, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 21, 23, 18, 23, 23, 23, 23, 23, 12, 12, 23, 23, 23, 13, 15, 22,
 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12, 23, 23, 23, 23,
 23, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 23, 23, 23, 23, 23,
 23, 2, 6, 9, 7, 8, 17, 19, 10, 19, 19, 19, 19, 11, 19, 5,
 4, 19, 1, 3, 16, 19, 19, 19, 19, 19, 19, 23, 23, 23, 23, 23,
 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 31, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 26, 32, 33, 34, 26, 35, 36, 27, 27, 27, 27, 27, 27, 27, 27,
 27, 27, 37, 39, 196, 196, 196, 196, 26, 27, 27, 27, 27, 27, 27, 27,
 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
 27, 27, 27, 39, 196, 51, 196, 27, 52, 27, 27, 27, 27, 27, 27, 27,
 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 30, 28, 28,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
 28, 28, 28, 28, 28, 29, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
 28, 28, 28, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 40, 196, 40,
 196, 53, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 43, 54, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 47, 196, 196, 196, 196, 55, 56, 45,
 57, 45, 58, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 59, 60,
 63, 64, 67, 68, 48, 69, 48, 70, 47, 49, 49, 49, 49, 49, 49, 49,
 49, 49, 49, 44, 50, 71, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
 61, 66, 72, 73, 74, 75, 76, 77, 78, 62, 79, 80, 81, 82, 83, 85,
 86, 87, 88, 89, 90, 65, 91, 92, 93, 84, 94, 95, 96, 97, 98, 99,
 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 111, 114, 115,
 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 131, 132,
 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 130,
 148, 149, 150, 151, 152, 158, 159, 160, 154, 161, 162, 163, 164, 165, 157, 155,
 166, 167, 168, 156, 153, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 196,
 196, 196, 196, 196, 189, 0
};

static yy_state_t yy_check[] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 22, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 17, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 21, 31, 32, 33, 21, 16, 35, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 36, 38, 41, 40, 41, 40, 21, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 38, 46, 11, 46, 19, 51, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 39, 45, 39,
 45, 52, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 14, 53, 14, 14,
 14, 14, 14, 14, 14, 14, 14, 14, 43, 49, 48, 49, 48, 54, 55, 44,
 56, 44, 10, 14, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 58, 59,
 62, 61, 66, 67, 47, 68, 47, 69, 43, 47, 47, 47, 47, 47, 47, 47,
 47, 47, 47, 14, 13, 70, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
 60, 9, 71, 65, 73, 74, 75, 76, 77, 60, 78, 79, 80, 81, 82, 8,
 85, 86, 87, 88, 89, 9, 90, 91, 84, 8, 93, 94, 95, 96, 97, 98,
 99, 7, 101, 101, 103, 104, 102, 106, 107, 6, 109, 111, 112, 109, 113, 114,
 115, 110, 117, 118, 119, 120, 5, 122, 123, 124, 125, 126, 127, 128, 4, 131,
 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 130, 4,
 147, 148, 149, 150, 3, 157, 158, 159, 3, 160, 156, 162, 163, 164, 3, 3,
 165, 166, 167, 3, 3, 168, 169, 155, 171, 172, 173, 154, 175, 176, 177, 153,
 179, 180, 181, 182, 183, 152, 2, 186, 1, 188, 190, 189, 192, 193, 194, ~0,
 ~0, ~0, ~0, ~0, 188, 0
};

static yy_state_t yy_default[] = {
 196, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 196, 196, 196, 196,
 19, 19, 196, 196, 196, 196, 196, 196, 196, 24, 21, 19, 18, 196, 196, 19,
 19, 19, 19, 19, 19, 19, 15, 196, 39, 39, 14, 15, 196, 44, 44, 196,
 47, 47, 15, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 0
};

static short yy_base[] = {
 0, 579, 578, 543, 525, 502, 490, 492, 465, 464, 417, 212, 693, 502, 446, 419,
 148, 42, 339, 216, 693, 248, 81, 693, 129, 693, 693, 693, 693, 693, 693, 150,
 144, 159, 693, 146, 173, 693, 206, 434, 234, 233, 693, 435, 468, 435, 265, 489,
 463, 462, 693, 196, 380, 379, 404, 413, 404, 693, 412, 427, 484, 463, 462, 693,
 693, 454, 418, 434, 434, 430, 433, 441, 693, 481, 461, 461, 455, 502, 459, 454,
 462, 473, 459, 693, 483, 476, 511, 467, 462, 470, 482, 468, 693, 487, 521, 477,
 472, 480, 491, 477, 693, 485, 501, 481, 496, 693, 489, 500, 693, 493, 540, 534,
 494, 490, 493, 487, 693, 500, 495, 498, 492, 693, 514, 502, 520, 502, 514, 509,
 511, 693, 527, 509, 508, 538, 521, 511, 524, 550, 518, 530, 518, 536, 518, 530,
 525, 527, 693, 542, 533, 541, 534, 693, 561, 573, 557, 566, 539, 543, 530, 571,
 583, 693, 552, 545, 587, 545, 540, 548, 561, 547, 693, 550, 550, 565, 693, 565,
 561, 569, 693, 603, 563, 558, 561, 555, 693, 693, 579, 693, 584, 582, 582, 693,
 587, 570, 585, 693, 693
};


/*
 * Copyright 1988, 1992 by Mortice Kern Systems Inc.  All rights reserved.
 * All rights reserved.
 *
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.9 2005/07/07 16:00:58 rjw Exp $
 *
 */
#include <stdlib.h>
#include <stdio.h>
//#if     __STDDC__
#define YY_ARGS(args)   args
//#else
//#define YY_ARGS(args)   ()
//#endif

#ifdef LEX_WINDOWS
#include <windows.h>

/*
 * define, if not already defined
 * the flag YYEXIT, which will allow
 * graceful exits from yylex()
 * without resorting to calling exit();
 */

#ifndef YYEXIT
#define YYEXIT  1
#endif

/*
 * the following is the handle to the current
 * instance of a windows program. The user
 * program calling yylex must supply this!
 */

extern HANDLE hInst;    

#endif  /* LEX_WINDOWS */

/*
 * Define m_textmsg() to an appropriate function for internationalized messages
 * or custom processing.
 */
#ifndef I18N
#define m_textmsg(id, str, cls) (str)
#else /*I18N*/
extern  char* m_textmsg YY_ARGS((int id, const char* str, char* cls));
#endif/*I18N*/

/*
 * Include string.h to get definition of memmove() and size_t.
 * If you do not have string.h or it does not declare memmove
 * or size_t, you will have to declare them here.
 */
#include <string.h>
/* Uncomment next line if memmove() is not declared in string.h */
/*extern char * memmove();*/
/* Uncomment next line if size_t is not available in stdio.h or string.h */
/*typedef unsigned size_t;*/
/* Drop this when LATTICE provides memmove */
#ifdef LATTICE
#define memmove memcopy
#endif

/*
 * YY_STATIC determines the scope of variables and functions
 * declared by the lex scanner. It must be set with a -DYY_STATIC
 * option to the compiler (it cannot be defined in the lex program).
 */
#ifdef  YY_STATIC
/* define all variables as static to allow more than one lex scanner */
#define YY_DECL static
#else
/* define all variables as global to allow other modules to access them */
#define YY_DECL 
#endif

/*
 * You can redefine yygetc. For YACC Tracing, compile this code
 * with -DYYTRACE to get input from yt_getc
 */
#ifdef YYTRACE
extern int      yt_getc YY_ARGS((void));
#define yygetc()        yt_getc()
#else
#define yygetc()        getc(yyin)      /* yylex input source */
#endif

/*
 * the following can be redefined by the user.
 */
#ifdef YYEXIT
#define YY_FATAL(msg)   { fprintf(yyout, "yylex: %s\n", msg); yyLexFatal = 1; }
#else /* YYEXIT */
#define YY_FATAL(msg)   { fprintf(stderr, "yylex: %s\n", msg); exit(1); }
#endif /* YYEXIT */

#define ECHO            fputs(yytext, yyout)
#define output(c)       putc((c), yyout) /* yylex sink for unmatched chars */
#define YY_INTERACTIVE  1               /* save micro-seconds if 0 */
#define YYLMAX          8000             /* token and pushback buffer size */

/*
 * If %array is used (or defaulted), yytext[] contains the token.
 * If %pointer is used, yytext is a pointer to yy_tbuf[].
 */
YY_DECL char  yytext[YYLMAX+1];

#define BEGIN           yy_start =
#define REJECT          goto yy_reject
#define NLSTATE         (yy_lastc = YYNEWLINE)
#define YY_INIT \
        (yy_start = yyleng = yy_end = 0, yy_lastc = YYNEWLINE)
#define yymore()        goto yy_more
#define yyless(n)       if ((n) < 0 || (n) > yy_end) ; \
                        else { YY_SCANNER; yyleng = (n); YY_USER; }

YY_DECL void    yy_reset YY_ARGS((void));
YY_DECL int     input   YY_ARGS((void));
YY_DECL int     unput   YY_ARGS((int c));

/* functions defined in libl.lib */
extern  int     yywrap  YY_ARGS((void));
extern  void    yyerror YY_ARGS((char *fmt, ...));
extern  void    yycomment       YY_ARGS((char *term));
extern  int     yymapch YY_ARGS((int delim, int escape));


/*------------------------------------------------------------------------------
 *
 *     (c) Copyright IBM Corp. 1993,1994,1996.
 *     (Unpublished)
 *     OCO Source Modules
 *     IBM Confidential
 *
 *------------------------------------------------------------------------------

 *------------------------------------------------------------------------------
 *
 *     Source file:    witLexer.l
 *
 *     Lexer for WIT 4.0 Input Data File Format
 *
 *     To create an executable lexer file:
 *
 *             lex witLexer.l                (creates lex.yy.c)
 *             mv -f lex.yy.c lex.yy.C
 *             mv y.tab.h ytab.h
 *             xlC lex.yy.C -o filename -ll  
 *
 *     Notes:  ytab.h is the token name definition file created by yacc.
 *             -ll causes the lex library to be included.
 *
 *------------------------------------------------------------------------------
 */

#define  LINESIZE 128

#include <wit/mds/ytab.h>                     /* token name definition file */
#include <wit/src/Parlex.h>
#include <wit/src/MsgFac.h>
#include <SymTable.h>
#include <VecBS.h>
#include <Entity.h>
#include <Parser.h>
#include <ApiMgr.h>


int    newstr = 1;                     /* new-string state       */
int    extraquote = 0;                 
char   *strbuf;                        /* current-string buffer  */         
int    bufsize = 0;                    /* allocated size of string buffer */

char   *yytext_;                       /* local copy of yytext   */
int    yyleng_;                        /* local copy of yyleng   */

static void  yyerror(const char *);
char*  stradd(char *s);                /* adds a string to the str buffer */


/* yywrap() is redefined as a macro in order to compile on the sun4 platform */
/* note: yywrap is defined using the -D option in appl.mk                    */
/* #define  yywrap() 1 */
#undef yywrap

int yywrap()
{
  WitParseRC retcode;

  retcode = WitParlex::restoreFile();
  if (retcode == 1) return 1;

//printf("Lexer is now reading from file %s\n", WitParlex::fileName());

  WitParser::instance ()->setDataFileName   ();
  WitParser::instance ()->setDataFileLineNo ();

  return 0;
}




#ifdef  YY_DEBUG
#undef  YY_DEBUG
#define YY_DEBUG(fmt, a1, a2)   fprintf(stderr, fmt, a1, a2)
#else
#define YY_DEBUG(fmt, a1, a2)
#endif

/*
 * The declaration for the lex scanner can be changed by
 * redefining YYLEX or YYDECL. This must be done if you have
 * more than one scanner in a program.
 */
#ifndef YYLEX
#define YYLEX yylex                     /* name of lex scanner */
#endif

#ifndef YYDECL
#define YYDECL  int YYLEX YY_ARGS((void))       /* declaration for lex scanner */
#endif

/*
 * stdin and stdout may not neccessarily be constants.
 * If stdin and stdout are constant, and you want to save a few cycles, then
 * #define YY_STATIC_STDIO 1 in this file or on the commandline when
 * compiling this file
 */
#ifndef YY_STATIC_STDIO
#define YY_STATIC_STDIO 0
#endif

#if YY_STATIC_STDIO
YY_DECL FILE   *yyin = stdin;
YY_DECL FILE   *yyout = stdout;
#else
YY_DECL FILE   *yyin = (FILE *)0;
YY_DECL FILE   *yyout = (FILE *)0;
#endif
YY_DECL int     yylineno = 1;           /* line number */

/* yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
 * yytext[0:yyleng-1] contains the current token.
 * yytext[yyleng:yy_end-1] contains pushed-back characters.
 * When the user action routine is active,
 * yy_save contains yytext[yyleng], which is set to '\0'.
 * Things are different when YY_PRESERVE is defined. 
 */
static  yy_state_t yy_sbuf [YYLMAX+1];  /* state buffer */
static  int     yy_end = 0;             /* end of pushback */
static  int     yy_start = 0;           /* start state */
static  int     yy_lastc = YYNEWLINE;   /* previous char */
YY_DECL int     yyleng = 0;             /* yytext token length */
#ifdef YYEXIT
static  int yyLexFatal;
#endif /* YYEXIT */

#ifndef YY_PRESERVE     /* the efficient default push-back scheme */

static  char yy_save;   /* saved yytext[yyleng] */

#define YY_USER { /* set up yytext for user */ \
                yy_save = yytext[yyleng]; \
                yytext[yyleng] = 0; \
        }
#define YY_SCANNER { /* set up yytext for scanner */ \
                yytext[yyleng] = yy_save; \
        }

#else           /* not-so efficient push-back for yytext mungers */

static  char yy_save [YYLMAX];
static  char *yy_push = yy_save+YYLMAX;

#define YY_USER { \
                size_t n = yy_end - yyleng; \
                yy_push = yy_save+YYLMAX - n; \
                if (n > 0) \
                        memmove(yy_push, yytext+yyleng, n); \
                yytext[yyleng] = 0; \
        }
#define YY_SCANNER { \
                size_t n = yy_save+YYLMAX - yy_push; \
                if (n > 0) \
                        memmove(yytext+yyleng, yy_push, n); \
                yy_end = yyleng + n; \
        }

#endif


#ifdef LEX_WINDOWS

/*
 * When using the windows features of lex,
 * it is necessary to load in the resources being
 * used, and when done with them, the resources must
 * be freed up, otherwise we have a windows app that
 * is not following the rules. Thus, to make yylex()
 * behave in a windows environment, create a new
 * yylex() which will call the original yylex() as
 * another function call. Observe ...
 */

/*
 * The actual lex scanner (usually yylex(void)).
 * NOTE: you should invoke yy_init() if you are calling yylex()
 * with new input; otherwise old lookaside will get in your way
 * and yylex() will die horribly.
 */
static int win_yylex();                 /* prototype for windows yylex handler */

YYDECL {
        int wReturnValue;
        HANDLE hRes_table;
        unsigned short *old_yy_la_act;  /* remember previous pointer values */
        short *old_yy_final;
        yy_state_t *old_yy_begin;
        yy_state_t *old_yy_next;
        yy_state_t *old_yy_check;
        yy_state_t *old_yy_default;
        short *old_yy_base;

        /*
         * the following code will load the required
         * resources for a Windows based parser.
         */

        hRes_table = LoadResource (hInst,
                FindResource (hInst, "UD_RES_yyLEX", "yyLEXTBL"));
        
        /*
         * return an error code if any
         * of the resources did not load
         */

        if (hRes_table == NULL)
                return (0);
        
        /*
         * the following code will lock the resources
         * into fixed memory locations for the scanner
         * (and remember previous pointer locations)
         */

        old_yy_la_act = yy_la_act;
        old_yy_final = yy_final;
        old_yy_begin = yy_begin;
        old_yy_next = yy_next;
        old_yy_check = yy_check;
        old_yy_default = yy_default;
        old_yy_base = yy_base;

        yy_la_act = (unsigned short *)LockResource (hRes_table);
        yy_final = (short *)(yy_la_act + Sizeof_yy_la_act);
        yy_begin = (yy_state_t *)(yy_final + Sizeof_yy_final);
        yy_next = (yy_state_t *)(yy_begin + Sizeof_yy_begin);
        yy_check = (yy_state_t *)(yy_next + Sizeof_yy_next);
        yy_default = (yy_state_t *)(yy_check + Sizeof_yy_check);
        yy_base = (yy_state_t *)(yy_default + Sizeof_yy_default);


        /*
         * call the standard yylex() code
         */

        wReturnValue = win_yylex();

        /*
         * unlock the resources
         */

        UnlockResource (hRes_table);

        /*
         * and now free the resource
         */

        FreeResource (hRes_table);

        /*
         * restore previously saved pointers
         */

        yy_la_act = old_yy_la_act;
        yy_final = old_yy_final;
        yy_begin = old_yy_begin;
        yy_next = old_yy_next;
        yy_check = old_yy_check;
        yy_default = old_yy_default;
        yy_base = old_yy_base;

        return (wReturnValue);
}       /* end function */

static int win_yylex() {

#else /* LEX_WINDOWS */

/*
 * The actual lex scanner (usually yylex(void)).
 * NOTE: you should invoke yy_init() if you are calling yylex()
 * with new input; otherwise old lookaside will get in your way
 * and yylex() will die horribly.
 */
YYDECL {

#endif /* LEX_WINDOWS */

        register int c, i, yybase;
        unsigned        yyst;   /* state */
        int yyfmin, yyfmax;     /* yy_la_act indices of final states */
        int yyoldi, yyoleng;    /* base i, yyleng before look-ahead */
        int yyeof;              /* 1 if eof has already been read */




#if !YY_STATIC_STDIO
        if (yyin == (FILE *)0)
                yyin = stdin;
        if (yyout == (FILE *)0)
                yyout = stdout;
#endif

#ifdef YYEXIT
        yyLexFatal = 0;
#endif /* YYEXIT */

        yyeof = 0;
        i = yyleng;
        YY_SCANNER;

  yy_again:
        yyleng = i;
        /* determine previous char. */
        if (i > 0)
                yy_lastc = yytext[i-1];
        /* scan previously accepted token adjusting yylineno */
        while (i > 0)
                if (yytext[--i] == YYNEWLINE)
                        yylineno++;
        /* adjust pushback */
        yy_end -= yyleng;
        memmove(yytext, yytext+yyleng, (size_t) yy_end);
        i = 0;

  yy_contin:
        yyoldi = i;

        /* run the state machine until it jams */
        yyst = yy_begin[yy_start + (yy_lastc == YYNEWLINE)];
        yy_sbuf[i] = (yy_state_t) yyst;
        do {
                YY_DEBUG(m_textmsg(1547, "<state %d, i = %d>\n", "I num1 num2"), yyst, i);
                if (i >= YYLMAX) {
                        YY_FATAL(m_textmsg(1548, "Token buffer overflow", "E"));
#ifdef YYEXIT
                        if (yyLexFatal)
                                return -2;
#endif /* YYEXIT */
                }       /* endif */

                /* get input char */
                if (i < yy_end)
                        c = yytext[i];          /* get pushback char */
                else if (!yyeof && (c = yygetc()) != EOF) {
                        yy_end = i+1;
                        yytext[i] = (char) c;
                } else /* c == EOF */ {
                        c = EOF;                /* just to make sure... */
                        if (i == yyoldi) {      /* no token */
                                yyeof = 0;
                                if (yywrap())
                                        return 0;
                                else
                                        goto yy_again;
                        } else {
                                yyeof = 1;      /* don't re-read EOF */
                                break;
                        }
                }
                YY_DEBUG(m_textmsg(1549, "<input %d = 0x%02x>\n", "I num hexnum"), c, c);

                /* look up next state */
                while ((yybase = yy_base[yyst]+(unsigned char)c) > yy_nxtmax
                    || yy_check[yybase] != (yy_state_t) yyst) {
                        if (yyst == yy_endst)
                                goto yy_jammed;
                        yyst = yy_default[yyst];
                }
                yyst = yy_next[yybase];
          yy_jammed: ;
          yy_sbuf[++i] = (yy_state_t) yyst;
        } while (!(yyst == yy_endst || YY_INTERACTIVE && yy_base[yyst] > yy_nxtmax && yy_default[yyst] == yy_endst));
        YY_DEBUG(m_textmsg(1550, "<stopped %d, i = %d>\n", "I num1 num2"), yyst, i);
        if (yyst != yy_endst)
                ++i;

  yy_search:
        /* search backward for a final state */
        while (--i > yyoldi) {
                yyst = yy_sbuf[i];
                if ((yyfmin = yy_final[yyst]) < (yyfmax = yy_final[yyst+1]))
                        goto yy_found;  /* found final state(s) */
        }
        /* no match, default action */
        i = yyoldi + 1;
        output(yytext[yyoldi]);
        goto yy_again;

  yy_found:
        YY_DEBUG(m_textmsg(1551, "<final state %d, i = %d>\n", "I num1 num2"), yyst, i);
        yyoleng = i;            /* save length for REJECT */
        
        /* pushback look-ahead RHS */
        if ((c = (int)(yy_la_act[yyfmin]>>9) - 1) >= 0) { /* trailing context? */
                unsigned char *bv = yy_look + c*YY_LA_SIZE;
                static unsigned char bits [8] = {
                        1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
                };
                while (1) {
                        if (--i < yyoldi) {     /* no / */
                                i = yyoleng;
                                break;
                        }
                        yyst = yy_sbuf[i];
                        if (bv[(unsigned)yyst/8] & bits[(unsigned)yyst%8])
                                break;
                }
        }

        /* perform action */
        yyleng = i;
        YY_USER;
        switch (yy_la_act[yyfmin] & 0777) {
	case 0:
	{ return RELEASE; }
	break;
	case 1:
	{ return ADD; }
	break;
	case 2:
	{ return SET; }
	break;
	case 3:
	{ return READ; }
	break;
	case 4:
	{ yylval.strval = strdup((const char *) &yytext[0]);
                    return PROBLEM; }
	break;
	case 5:
	{ yylval.strval = strdup((const char *) &yytext[0]); 
                    return PART; }
	break;
	case 6:
	{ yylval.strval = strdup((const char *) &yytext[0]);
                    return OPERATION; }
	break;
	case 7:
	{ yylval.strval = strdup((const char *) &yytext[0]); 
                    return BOM_ENTRY; }
	break;
	case 8:
	{ yylval.strval = strdup((const char *) &yytext[0]); 
                    return SUB_ENTRY; }
	break;
	case 9:
	{ yylval.strval = strdup((const char *) &yytext[0]); 
                    return BOP_ENTRY; }
	break;
	case 10:
	{ yylval.strval = strdup((const char *) &yytext[0]); 
                    return DEMAND; }
	break;
	case 11:
	{ yylval.strval = strdup((const char *) &yytext[0]);
                    return PART_WITH_OPERATION; }      
	break;
	case 12:
	{ return SINGLE; }
	break;
	case 13:
	{ return SPARSE; }
	break;
	case 14:
	{ return DENSE; }
	break;
	case 15:
	{ yylval.strval = strdup((const char *) &yytext[0]);
                    return EXEC_BOUNDS; }
	break;
	case 16:
	{ yylval.strval = strdup((const char *) &yytext[0]);
                    return STOCK_BOUNDS; }
	break;
	case 17:
	{ yylval.strval = strdup((const char *) &yytext[0]);
                    return CUM_SHIP_BOUNDS; }
	break;
	case 18:
	{ return END_BOUNDS; }
	break;
	case 19:
	{ return HARDLB; }
	break;
	case 20:
	{ return SOFTLB; }
	break;
	case 21:
	{ return HARDUB; }
	break;
	case 22:
	{ yylval.cval = static_cast <int> (WitDRPartCat::capacity);
                    return CATEGORY; }
	break;
	case 23:
	{ yylval.cval = static_cast <int> (WitDRPartCat::material);
                    return CATEGORY; }
	break;
	case 24:
	{ return yytext[0]; }
	break;
	case 25:
	{ yylval.intval = atoi((const char *) &yytext[0]); 
                    return INTEGER; }
	break;
	case 26:
	case 27:
	case 28:
	{
                    yylval.doubleval = atof((const char *) &yytext[0]);
                    return DOUBLE; }
	break;
	case 29:
	{ yylval.boolval = true;
                    return BOOLEAN; }
	break;
	case 30:
	{ yylval.boolval = false;
                    return BOOLEAN; }
	break;
	case 31:
	{ yytext_ = (char*) yytext;
                    yyleng_ = yyleng;
                    if (newstr) {
                      strbuf = (char *) malloc(LINESIZE + 1);
                      bufsize = LINESIZE + 1;
                      strbuf[0] = '\0';
                      newstr = 0;
                    };
            
                    char c1 = yytext[yyleng-1];  /* last character read */
                    char c2 = input();           /* peek at next char   */  
                    unput(c2); 

                    if (extraquote) {
                      yytext_++;                 /* get rid of extra quote */
                      yyleng_--;
                      extraquote = 0;
                    };
  
                    if (c1 == '\\') {
                      if (c2 == '\"') {
                        stradd(yytext_);         /* get rid of extra \ */
                        strbuf[strlen(strbuf)-1] = '\0';
                      }  
                      else
                      if (c2 == '\\') {
                        stradd((char *) yytext_);
                        input();                 /* get rid of extra \ */
                        unput('\"');             /* and fake a "       */
                        extraquote = 1;          /* then continue scan */
                      }
                      else {
                        WitParser::instance ()->myMsgFac () ("invalidStringMsg",
                           c2);
                        WitParser::instance ()->myMsgFac () ("lineNumberMsg",
                          yytext, WitParlex::lineno(), WitParlex::fileName());
                        WitParser::instance ()->myMsgFac () ("parsingStopsMsg");
                      }
                    }  
                     
                    else 
                    {
                      yylval.strval = stradd((char *) yytext_);
                      bufsize = 0;
                      newstr = 1;                /* return string and     */
                      return STRING;             /* get ready for another */
                    }
                  }
	break;
	case 32:
	{ yytext_ = (char*) yytext;
                    yyleng_ = yyleng; 
                    if (newstr) {
                      strbuf = (char *) malloc(LINESIZE + 1);
                      bufsize = LINESIZE + 1;
                      strbuf[0] = '\0';
                      newstr = 0;
                    };

                    if (extraquote) {
                      yytext_++;                 /* get rid of extra quote */
                      yyleng_--;
                      extraquote = 0;
                    };

                    WitParser::instance ()->myMsgFac () (
                       "unterminatedStringMsg");
                    stradd(yytext_);
                    WitParser::instance ()->myMsgFac () ("lineNumberMsg",
                      strbuf, WitParlex::lineno(), WitParlex::fileName());
                    stradd("\"");
                    yylval.strval = strbuf;
                    bufsize = 0;
                    newstr = 1;
                    return STRING; 
                  } 
	break;
	case 33:
	{
                    yylval.strval = strdup((const char *) &yytext[0]);
                    const int jpf = IDENTIFIER;
                    return IDENTIFIER; }
	break;
	case 34:
	{ WitParlex::setLineno(WitParlex::lineno()+1);
                    WitParser::instance ()->setDataFileLineNo ();
                             /* set lineno for API functions */
                  }
	break;
	case 35:
	;                      /* white space */
	break;
	case 36:
	;                      /* comments */
	break;
	case 37:
	{ WitParser::instance ()->myMsgFac () ("invalidCharacterMsg");
                    WitParser::instance ()->myMsgFac () ("lineNumberMsg",
                      yytext, WitParlex::lineno(), WitParlex::fileName());
                  }                      /* anything else */
	break;


        }
        YY_SCANNER;
        i = yyleng;
        goto yy_again;                  /* action fell though */

  yy_reject:
        YY_SCANNER;
        i = yyoleng;                    /* restore original yytext */
        if (++yyfmin < yyfmax)
                goto yy_found;          /* another final state, same length */
        else
                goto yy_search;         /* try shorter yytext */

  yy_more:
        YY_SCANNER;
        i = yyleng;
        if (i > 0)
                yy_lastc = yytext[i-1];
        goto yy_contin;
}
/*
 * Safely switch input stream underneath LEX
 */
typedef struct yy_save_block_tag {
        FILE    * oldfp;
        int     oldline;
        int     oldend;
        int     oldstart;
        int     oldlastc;
        int     oldleng;
        char    savetext[YYLMAX+1];
        yy_state_t      savestate[YYLMAX+1];
} YY_SAVED;

YY_SAVED * yySaveScan(FILE *fp)
{
        YY_SAVED * p;

        if ((p = (YY_SAVED *) malloc(sizeof(*p))) == NULL)
                return p;

        p->oldfp = yyin;
        p->oldline = yylineno;
        p->oldend = yy_end;
        p->oldstart = yy_start;
        p->oldlastc = yy_lastc;
        p->oldleng = yyleng;
        (void) memcpy(p->savetext, yytext, sizeof yytext);
        (void) memcpy((char *) p->savestate, (char *) yy_sbuf,
                sizeof yy_sbuf);

        yyin = fp;
        yylineno = 1;
        YY_INIT;

        return p;
}
/*f
 * Restore previous LEX state
 */
void
yyRestoreScan(YY_SAVED * p)
{
        if (p == NULL)
                return;
        yyin = p->oldfp;
        yylineno = p->oldline;
        yy_end = p->oldend;
        yy_start = p->oldstart;
        yy_lastc = p->oldlastc;
        yyleng = p->oldleng;

        (void) memcpy(yytext, p->savetext, sizeof yytext);
        (void) memcpy((char *) yy_sbuf, (char *) p->savestate,
                sizeof yy_sbuf);
        free (p);
}
/*
 * User-callable re-initialization of yylex()
 */
void
yy_reset()
{
        YY_INIT;
        yylineno = 1;           /* line number */
}
/* get input char with pushback */
YY_DECL int
input()
{
        int c;
#ifndef YY_PRESERVE
        if (yy_end > yyleng) {
                yy_end--;
                memmove(yytext+yyleng, yytext+yyleng+1,
                        (size_t) (yy_end-yyleng));
                c = yy_save;
                YY_USER;
#else
        if (yy_push < yy_save+YYLMAX) {
                c = *yy_push++;
#endif
        } else
                c = yygetc();
        yy_lastc = c;
        if (c == YYNEWLINE)
                yylineno++;
        return c;
}

/*f
 * pushback char
 */
YY_DECL int unput(int c)
{
#ifndef YY_PRESERVE
        if (yy_end >= YYLMAX) {
                YY_FATAL(m_textmsg(1552, "Push-back buffer overflow", "E"));
        } else {
                if (yy_end > yyleng) {
                        yytext[yyleng] = yy_save;
                        memmove(yytext+yyleng+1, yytext+yyleng,
                                (size_t) (yy_end-yyleng));
                        yytext[yyleng] = 0;
                }
                yy_end++;
                yy_save = (char) c;
#else
        if (yy_push <= yy_save) {
                YY_FATAL(m_textmsg(1552, "Push-back buffer overflow", "E"));
        } else {
                *--yy_push = c;
#endif
                if (c == YYNEWLINE)
                        yylineno--;
        }       /* endif */
        return c;
}


void yyerror(const char *s)
{
  printf("%s (%c) at line number %-d in file \n%s\n",
    s, yytext[0], WitParlex::lineno(), WitParlex::fileName());
}

char*  stradd(char *s)	
{
  char  *newbuf;
 
  // reallocate the string buffer if necessary
  if (strlen(strbuf) + strlen(s) + 1 > bufsize) {
    newbuf = (char *) malloc(strlen(strbuf) + strlen(s) + 1);
    strcpy(newbuf, strbuf);
    strcat(newbuf, s);
    bufsize = strlen(newbuf) + 1;
    free (strbuf);
    strbuf = newbuf;
  }
  else
    strcat(strbuf, s);
  return (strbuf);
}
@


1.9
log
@[exceptions]
@
text
@d185 1
a185 1
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.8 2004/05/05 15:43:58 rjw Exp $
d345 1
a345 2
#include <witParse.h>
//#include <iostream.h>
@


1.8
log
@Removed portableFree.
@
text
@d185 1
a185 1
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.7 2004/04/13 20:28:41 rjw Exp $
a340 1
#include <wit/src/witLexer.h>
d371 1
a371 1
  retcode = WitLexer::restoreFile();
a1069 10
// Constructor and destructor

WitLexer::WitLexer()
{
}

WitLexer::~WitLexer()
{
}

@


1.7
log
@Double Precision.
@
text
@d185 1
a185 1
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.6 2004/03/31 20:01:58 gresh Exp $
d1006 1
a1006 1
        WitNonClass::portableFree(p);
d1097 1
a1097 1
    WitNonClass::portableFree(strbuf);
@


1.6
log
@increased length of names
@
text
@d185 1
a185 1
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.5 2003/12/12 19:39:06 fasano Exp $
d798 1
a798 1
	{ yylval.cval = capacity;
d802 1
a802 1
	{ yylval.cval = material;
d816 2
a817 2
                    yylval.floatval = atof((const char *) &yytext[0]);
                    return FLOAT; }
@


1.5
log
@Modified to compile with Bob's latest changes.  WitUtil was changed to WitNonClass.
@
text
@d185 1
a185 1
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.4 2003/01/09 13:10:03 rwToStl Exp $
d281 1
a281 1
#define YYLMAX          100             /* token and pushback buffer size */
@


1.4
log
@Removed includes for iostream.h
@
text
@d185 1
a185 1
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.3 2003/01/06 17:46:16 fasano Exp $
d1006 1
a1006 1
        WitUtil::portableFree(p);
d1097 1
a1097 1
    WitUtil::portableFree(strbuf);
@


1.3
log
@updated to compile on windows
@
text
@d185 1
a185 1
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.2 2002/05/08 01:03:55 fasano Exp $
d347 1
a347 1
#include <iostream.h>
@


1.2
log
@Updated to match changes Bob made in April to witParse.y and witLexer.l in the src directory
@
text
@d185 1
a185 1
 * $Header: /u/wit/devbase/wit/mds/witLexer.cpp,v 1.1 2001/08/10 19:07:03 fasano Exp $
d820 1
a820 1
	{ yylval.boolval = witTRUE;
d824 1
a824 1
	{ yylval.boolval = witFALSE;
@


1.1
log
@Adding build of diner to wit/mds
(building of diner on windows platform)
@
text
@d185 1
a185 1
 * $Header: /u/rd/src/lex/RCS/yylex.c,v 1.44 1993/05/26 14:47:37 ignac Exp $
d342 1
@


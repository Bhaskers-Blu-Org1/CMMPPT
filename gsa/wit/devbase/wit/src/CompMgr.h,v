head	1.47;
access;
symbols
	sce_5_01_20080919:1.43
	latest_sce_4_20_20060523:1.28.0.2
	sce_4_20_20060523:1.28
	latest_sce4_20_OSL:1.27.0.2
	sce_4_20_OSL:1.27
	sce_410_withVa:1.24
	sce_4_05_20040511:1.24
	sce_4_00_20040201:1.24
	nextGenBranch:1.22.0.2
	nextGenRoot:1.22
	sce_3_30_20030627:1.22
	EndRw-branch:1.18.0.4
	Root-of-EndRw:1.18
	rwToStl:1.18.0.2
	latest_sce_3_10_20010924:1.11.0.2
	sce_3_10_20010924:1.11
	latest_sce_3_00_20010601:1.10.0.4
	sce_3_00_20010601:1.10
	latest_sce_2_31_20010308:1.10.0.2
	sce_2_31_20010308:1.10
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2011.09.28.23.49.08;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2011.09.24.00.27.26;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.08.30.20.17.20;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.21.23.09.55;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.25.16.36.33;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.22.23.55.49;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.22.23.18.19;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.22.21.36.10;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.02.21.23.58.46;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.11.22.00.27;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.06.22.53.00;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.12.06.22.01.21;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.15.17.15.32;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.05.21.06.00;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.05.16.15.22;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.30.16.01.18;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.28.20.04.55;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.27.21.03.03;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.19.19.17.06;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.02.17.33.56;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.03.15.19.33;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.30.21.57.54;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.26.23.02.18;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.01.21.05.03;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.11.18.29.12;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.11.19.08.24;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.19.16.48.14;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.13.23.06.26;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.02.22.18.21;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.04.23.07.18;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.03.16.01.46;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.30.20.08.57;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.01.14.25.53;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.22.14.32.04;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.18.14.02.28;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.28.00.12.57;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.19.18.50.56;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.02.19.24.06;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.20.00.44.15;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.04.22.27.49;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.06.19.58.36;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.04.22.07.34;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.23.11.38;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.19;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.14.22.38.33;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.27;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef CompMgrH
#define CompMgrH

//------------------------------------------------------------------------------
// Header file: "CompMgr.h"
//
// Contains the declaration of class CompMgr.
//------------------------------------------------------------------------------

#include <List.h>

//------------------------------------------------------------------------------
// Class CompMgr
//
// "Component Manager"
// Responsible for maintaining structural relationships between the Components
// of a Problem, without regard to the content of the Components.
//------------------------------------------------------------------------------

class WitCompMgr
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitCompMgr (WitProblem * theProblem);
         //
         // myProblem_ <-- theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitCompMgr ();

      //------------------------------------------------------------------------
      // Component inserting functions.
      // Each of these functions inserts its argument Component into this
      // CompMgr.
      // Checks that the argument has not previously been inserted.
      //------------------------------------------------------------------------

      void insert (WitGlobalComp *);
      void insert (WitOptComp *);
      void insert (WitMaterial *);
      void insert (WitCapacity *);
      void insert (WitOperation *);
      void insert (WitBomEntry *);
      void insert (WitSubEntry *);
      void insert (WitBopEntry *);
      void insert (WitDemand *);

      //------------------------------------------------------------------------
      // Component matching functions.
      // Each of these functions finds and returns the Component in this CompMgr
      // that belongs to the same class and has the same ID as the argument
      // Component. Checks that such a Component exists.
      //------------------------------------------------------------------------

      WitPart *      myMatchFor (WitPart *);
      WitMaterial *  myMatchFor (WitMaterial *);
      WitDemand *    myMatchFor (WitDemand *);
      WitOperation * myMatchFor (WitOperation *);
      WitSubEntry *  myMatchFor (WitSubEntry *);
      WitBoundSet *  myMatchFor (WitBoundSet *);

      //------------------------------------------------------------------------
      // find<Component> functions.
      // Each of these functions corresponds to a Component class. The function
      // finds and returns the Component class instance in this CompMgr
      // identified by the arguments, or NULL if no such Component exists.
      // Asserts that the Component argument (if any) belongs to this CompMgr.
      //------------------------------------------------------------------------

      WitPart *      findPart      (const char *   theName) const;
      WitOperation * findOperation (const char *   theName) const;
      WitBomEntry *  findBomEntry  (WitOperation * theOpn,    int theIndex);
      WitSubEntry *  findSubEntry  (WitBomEntry *  theBomEnt, int theIndex);
      WitBopEntry *  findBopEntry  (WitOperation * theOpn,    int theIndex);
      WitDemand *    findDemand    (WitPart *      thePart, 
                                    const char *   theName);

      //------------------------------------------------------------------------
      // Component recount functions for concrete classes.
      // Each of these functions counts its argument at the end of a purge.
      // Valid only the this CompMgr is calling recount on the arguement.
      // and only valid once for each such call.
      //------------------------------------------------------------------------

      void recountGlobalComp (WitGlobalComp *);
      void recountOptComp    (WitOptComp    *);
      void recountMaterial   (WitMaterial   *);
      void recountCapacity   (WitCapacity   *);
      void recountOperation  (WitOperation  *);
      void recountBomEntry   (WitBomEntry   *);
      void recountSubEntry   (WitSubEntry   *);
      void recountBopEntry   (WitBopEntry   *);
      void recountDemand     (WitDemand     *);

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void setPartName      (WitPart *      thePart, const char * theName);
      void setOperationName (WitOperation * theOpn,  const char * theName);
         //
         // Sets the partName      of thePart to theName.
         // Sets the operationName of theOpn  to theName.

      inline bool hasSubEntries () const
         {
         return (nSubEntries () > 0);
         }

      int nBoundSetsSpecified () const;
         //
         // Counts and returns the # of BoundSets in this CompMgr that are
         // specified.

      void purgeData ();
         //
         // Deletes all Components that are selected for deletion.

      bool isReindexing (WitBoundSet * theBoundSet) const;
         //
         // Returns true, iff this CompMgr is currently reindexing theBoundSet.

      bool isDeleting (WitComponent * theComp) const;
         //
         // Returns true, iff this CompMgr is currently deleting theComp.

      void storePreSortedNodes (const WitList <WitNode> & theNodes);
         //
         // Replaces allParts_ and allOperations_ with the contents of theNodes,
         // which is to be a sorted List.
         // Valid only when preprocessing is being performed.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitProblem *,                   myProblem)
      accessFunc (WitMsgFacility &,               myMsgFac)
      accessFunc (WitGlobalComp *,                myGlobalComp)
      accessFunc (WitOptComp *,                   myOptComp)
      accessFunc (const WitList <WitPart> &,      allParts)
      accessFunc (const WitList <WitOperation> &, allOperations)
      accessFunc (const WitList <WitComponent> &, allComponents)
      accessFunc (int,                            nParts)
      accessFunc (int,                            nMaterials)
      accessFunc (int,                            nOperations)
      accessFunc (int,                            nBomEntries)
      accessFunc (int,                            nSubEntries)
      accessFunc (int,                            nBopEntries)
      accessFunc (int,                            nDemands)
      accessFunc (int,                            nBoundSets)
      accessFunc (bool,                           clearingDepLists)
      accessFunc (bool,                           settingNodeName)
      accessFunc (WitDelCompItr *,                myDelCompItr)
      accessFunc (bool,                           purging)

      inline int nNodes () const
         {
         return nParts () + nOperations ();
         }

      inline int nConsEntries () const
         {
         return nBomEntries () + nSubEntries ();
         }

      inline int nBillEntries () const
         {
         return nConsEntries () + nBopEntries ();
         }

      inline int nDelComps () const
         {
         return allComponents ().nElements () - 2;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitCompMgr);

      //------------------------------------------------------------------------
      // Component recount functions for base classes.
      //------------------------------------------------------------------------

      void recountComponent (WitComponent *);
      void recountPart      (WitPart      *);
      void recountBillEntry (WitBillEntry *);
      void recountConsEntry (WitConsEntry *);

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

      void insertPart (WitPart * thePart);
         //
         // Inserts thePart into this CompMgr.

      void insertComp (WitComponent * theComp);
         //
         // Inserts theComp into this CompMgr.

      void setNodeName (WitNode * theNode, const char * theName);
         //
         // Sets the nodeName of theNode to theName, except for NodeTable
         // maintenance.

      int nSelForDel () const;
         //
         // Computes and returns the # of DelComps owned by this CompMgr that
         // are selected for deletion.

      void purgeCompLists ();
         //
         // Removes all selForDel Components from this CompMgr's Derived
         // Component Lists.

      void clearCaches ();
         //
         // Sets all the Component caches of the CompMgr to NULL.

      void recountComps ();
         //
         // Counts the instances of the Component classes and re-computes thier
         // mappingIndexes at the end of a purge.

      void deleteComps ();
         //
         // Clears allComponents_ and deletes all the Components.
         // The Components are deletes in reverse order so that each Component
         // will be deleted before any Component that it refers to.

      void deleteComp (WitComponent * theComp);
         //
         // Deletes theComp.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // General purpose associations.
      //------------------------------------------------------------------------

      WitProblem * const myProblem_;
         //
         // The Problem that owns this CompMgr.

      WitMsgFacility & myMsgFac_;
         //
         // The MsgFacility for this CompMgr.

      //------------------------------------------------------------------------
      // Component ownership.
      //------------------------------------------------------------------------

      WitGlobalComp * myGlobalComp_;
         //
         // The GlobalComp owned by this CompMgr.

      WitOptComp    * myOptComp_;
         //
         // The OptComp owned by this CompMgr.

      WitList <WitPart> allParts_;
         //
         // The List of all Parts owned by this CompMgr.

      WitList <WitOperation> allOperations_;
         //
         // The List of all Operations owned by this CompMgr.

      //------------------------------------------------------------------------
      // Associations with Components.
      //------------------------------------------------------------------------

      WitList <WitComponent> allComponents_;
         //
         // The List of all Components for this CompMgr.

      WitDerNodeTable <WitPart> *      myPartTable_;
      WitDerNodeTable <WitOperation> * myOpnTable_;
         //
         // The DerNodeTables for finding the Parts and Operations of this
         // CompMgr.

      //------------------------------------------------------------------------
      // Counts of the various Components.
      //------------------------------------------------------------------------

      int nParts_;
      int nMaterials_;
      int nOperations_;
      int nBomEntries_;
      int nSubEntries_;
      int nBopEntries_;
      int nDemands_;
      int nBoundSets_;

      //------------------------------------------------------------------------
      // Caches of Components.
      //------------------------------------------------------------------------

      WitDemand * cachedDemand_;
         //
         // The Demand most recently constructed or found via findDemand.

      WitBomEntry * cachedBomEntry_;
         //
         // The BomEntry most recently constructed or found via findBomEntry

      WitSubEntry * cachedSubEntry_;
         //
         // The SubEntry most recently constructed or found via findSubEntry

      WitBopEntry * cachedBopEntry_;
         //
         // The BopEntry most recently constructed or found via findBopEntry

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitDelCompItr * myDelCompItr_;
         //
         // The DelCompItr owned by this CompMgr.

      bool purging_;
         //
         // true, iff this CompMgr is currently doing a purgeData.

      WitComponent * recountingComp_;
         //
         // The Component currently being re-counted by this CompMgr, if any,
         // else NULL.

      WitComponent * deletingComp_;
         //
         // The Component currently being deleted by this CompMgr, if any,
         // else NULL.

      bool clearingDepLists_;
         //
         // true, iff the dependent Lists of the Components are being cleared.

      WitNode * nameChangeNode_;
         //
         // The Node whose nodeName is currently being changed if any;
         // otherwise NULL.

      bool settingNodeName_;
         //
         // True, iff this CompMgr is currently setting the nodeName of a Node.
   };

//------------------------------------------------------------------------------
// Component iteration macros.
//
// Each of the following macros is associated with some Component class and
// facilitates iterating thru all of the class's instances belonging to a
// Problem.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Iterator name macros.
// Each of these macros expands to the name of a local AbsItr variable whose
// name is unique to the line on which the macro is invoked.
//------------------------------------------------------------------------------

#define localItr1  name2 (localItr1OnLine, __LINE__)
#define localItr2  name2 (localItr2OnLine, __LINE__)

//------------------------------------------------------------------------------
// forEachBomEntry
// Expands to the header of a double nested "for" loop causing theBomEnt to
// iterate thru all the BomEntries in theProblem.
//------------------------------------------------------------------------------

#define forEachBomEntry(theBomEnt, theProblem)                                 \
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());  \
         localItr1.advance ();)                                                \
      forEachEl (theBomEnt, WitOperation::key (localItr1)->bom ())             \

//------------------------------------------------------------------------------
// forEachBopEntry
// Expands to the header of a double nested "for" loop causing theBopEnt to
// iterate thru all the BopEntries in theProblem
//------------------------------------------------------------------------------

#define forEachBopEntry(theBopEnt, theProblem)                                 \
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());  \
         localItr1.advance ();)                                                \
      forEachEl (theBopEnt, WitOperation::key (localItr1)->bop ())             \

//------------------------------------------------------------------------------
// forEachSubEntry
// Expands to the header of a triple nested "for" loop causing theSub to
// iterate thru all the SubEntries in theProblem.
//------------------------------------------------------------------------------

#define forEachSubEntry(theSub, theProblem)                                    \
                                                                               \
   if ((theProblem)->myCompMgr ()->hasSubEntries ())                           \
      for (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());\
            localItr1.advance ();)                                             \
         for  (WitListItr localItr2 (WitOperation::key (localItr1)->bom ());   \
               localItr2.advance ();)                                          \
            forEachEl (theSub, WitBomEntry::key (localItr2)->mySubEntries ())  \

//------------------------------------------------------------------------------
// forEachDemand
// Expands to the header of a double nested "for" loop causing theDemand to
// iterate thru all the Demands in theProblem.
//------------------------------------------------------------------------------

#define forEachDemand(theDemand, theProblem)                                   \
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allParts ());       \
         localItr1.advance ();)                                                \
      forEachEl (theDemand, WitPart::key (localItr1)->myDemands ())            \

//------------------------------------------------------------------------------
// forEachOperation
// Expands to the header of a "for" loop causing theOpn to
// iterate thru all the Operations in theProblem.
//------------------------------------------------------------------------------

#define forEachOperation(theOpn, theProblem)                                   \
                                                                               \
   forEachEl (theOpn, (theProblem)->myCompMgr ()->allOperations ())            \

//------------------------------------------------------------------------------
// forEachPart
// Expands to the header of a "for" loop causing thePart to
// iterate thru all the Parts in theProblem.
//------------------------------------------------------------------------------

#define forEachPart(thePart, theProblem)                                       \
                                                                               \
   forEachEl (thePart, (theProblem)->myCompMgr ()->allParts ())                \

//------------------------------------------------------------------------------
// forEachMaterial
// Expands to the header of a "for" loop causing theMat to
// iterate thru all the Materials in theProblem.
//------------------------------------------------------------------------------

#define forEachMaterial(theMat, theProblem)                                    \
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allParts ());       \
         localItr1.advance ();)                                                \
      if (theMat = WitPart::key (localItr1)->thisMat (), (theMat != NULL))     \

#endif
@


1.46
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.45
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d30 2
a31 237
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitCompMgr (WitProblem * theProblem);
//
// myProblem_ <-- theProblem.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

virtual ~WitCompMgr ();

//------------------------------------------------------------------------
// Component inserting functions.
// Each of these functions inserts its argument Component into this
// CompMgr.
// Checks that the argument has not previously been inserted.
//------------------------------------------------------------------------

void insert (WitGlobalComp *);
void insert (WitOptComp *);
void insert (WitMaterial *);
void insert (WitCapacity *);
void insert (WitOperation *);
void insert (WitBomEntry *);
void insert (WitSubEntry *);
void insert (WitBopEntry *);
void insert (WitDemand *);

//------------------------------------------------------------------------
// Component matching functions.
// Each of these functions finds and returns the Component in this CompMgr
// that belongs to the same class and has the same ID as the argument
// Component. Checks that such a Component exists.
//------------------------------------------------------------------------

WitPart *      myMatchFor (WitPart *);
WitMaterial *  myMatchFor (WitMaterial *);
WitDemand *    myMatchFor (WitDemand *);
WitOperation * myMatchFor (WitOperation *);
WitSubEntry *  myMatchFor (WitSubEntry *);
WitBoundSet *  myMatchFor (WitBoundSet *);

//------------------------------------------------------------------------
// find<Component> functions.
// Each of these functions corresponds to a Component class. The function
// finds and returns the Component class instance in this CompMgr
// identified by the arguments, or NULL if no such Component exists.
// Asserts that the Component argument (if any) belongs to this CompMgr.
//------------------------------------------------------------------------

WitPart *      findPart      (const char *   theName) const;
WitOperation * findOperation (const char *   theName) const;
WitBomEntry *  findBomEntry  (WitOperation * theOpn,    int theIndex);
WitSubEntry *  findSubEntry  (WitBomEntry *  theBomEnt, int theIndex);
WitBopEntry *  findBopEntry  (WitOperation * theOpn,    int theIndex);
WitDemand *    findDemand    (WitPart *      thePart,
const char *   theName);

//------------------------------------------------------------------------
// Component recount functions for concrete classes.
// Each of these functions counts its argument at the end of a purge.
// Valid only the this CompMgr is calling recount on the arguement.
// and only valid once for each such call.
//------------------------------------------------------------------------

void recountGlobalComp (WitGlobalComp *);
void recountOptComp    (WitOptComp    *);
void recountMaterial   (WitMaterial   *);
void recountCapacity   (WitCapacity   *);
void recountOperation  (WitOperation  *);
void recountBomEntry   (WitBomEntry   *);
void recountSubEntry   (WitSubEntry   *);
void recountBopEntry   (WitBopEntry   *);
void recountDemand     (WitDemand     *);

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void setPartName      (WitPart *      thePart, const char * theName);
void setOperationName (WitOperation * theOpn,  const char * theName);
//
// Sets the partName      of thePart to theName.
// Sets the operationName of theOpn  to theName.

inline bool hasSubEntries () const
{
return (nSubEntries () > 0);
}

int nBoundSetsSpecified () const;
//
// Counts and returns the # of BoundSets in this CompMgr that are
// specified.

void purgeData ();
//
// Deletes all Components that are selected for deletion.

bool isReindexing (WitBoundSet * theBoundSet) const;
//
// Returns true, iff this CompMgr is currently reindexing theBoundSet.

bool isDeleting (WitComponent * theComp) const;
//
// Returns true, iff this CompMgr is currently deleting theComp.

void storePreSortedNodes (const WitList <WitNode> & theNodes);
//
// Replaces allParts_ and allOperations_ with the contents of theNodes,
// which is to be a sorted List.
// Valid only when preprocessing is being performed.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (WitProblem *,                   myProblem)
accessFunc (WitMsgFacility &,               myMsgFac)
accessFunc (WitGlobalComp *,                myGlobalComp)
accessFunc (WitOptComp *,                   myOptComp)
accessFunc (const WitList <WitPart> &,      allParts)
accessFunc (const WitList <WitOperation> &, allOperations)
accessFunc (const WitList <WitComponent> &, allComponents)
accessFunc (int,                            nParts)
accessFunc (int,                            nMaterials)
accessFunc (int,                            nOperations)
accessFunc (int,                            nBomEntries)
accessFunc (int,                            nSubEntries)
accessFunc (int,                            nBopEntries)
accessFunc (int,                            nDemands)
accessFunc (int,                            nBoundSets)
accessFunc (bool,                           clearingDepLists)
accessFunc (bool,                           settingNodeName)
accessFunc (WitDelCompItr *,                myDelCompItr)
accessFunc (bool,                           purging)

inline int nNodes () const
{
return nParts () + nOperations ();
}

inline int nConsEntries () const
{
return nBomEntries () + nSubEntries ();
}

inline int nBillEntries () const
{
return nConsEntries () + nBopEntries ();
}

inline int nDelComps () const
{
return allComponents ().nElements () - 2;
}

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitCompMgr);

//------------------------------------------------------------------------
// Component recount functions for base classes.
//------------------------------------------------------------------------

void recountComponent (WitComponent *);
void recountPart      (WitPart      *);
void recountBillEntry (WitBillEntry *);
void recountConsEntry (WitConsEntry *);

//------------------------------------------------------------------------
// Other private member functions.
//------------------------------------------------------------------------

void insertPart (WitPart * thePart);
//
// Inserts thePart into this CompMgr.

void insertComp (WitComponent * theComp);
//
// Inserts theComp into this CompMgr.

void setNodeName (WitNode * theNode, const char * theName);
//
// Sets the nodeName of theNode to theName, except for NodeTable
// maintenance.

int nSelForDel () const;
//
// Computes and returns the # of DelComps owned by this CompMgr that
// are selected for deletion.

void purgeCompLists ();
//
// Removes all selForDel Components from this CompMgr's Derived
// Component Lists.

void clearCaches ();
//
// Sets all the Component caches of the CompMgr to NULL.

void recountComps ();
//
// Counts the instances of the Component classes and re-computes thier
// mappingIndexes at the end of a purge.

void deleteComps ();
//
// Clears allComponents_ and deletes all the Components.
// The Components are deletes in reverse order so that each Component
// will be deleted before any Component that it refers to.

void deleteComp (WitComponent * theComp);
//
// Deletes theComp.

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// General purpose associations.
//------------------------------------------------------------------------

WitProblem * const myProblem_;
//
// The Problem that owns this CompMgr.
d33 341
a373 106
WitMsgFacility & myMsgFac_;
//
// The MsgFacility for this CompMgr.

//------------------------------------------------------------------------
// Component ownership.
//------------------------------------------------------------------------

WitGlobalComp * myGlobalComp_;
//
// The GlobalComp owned by this CompMgr.

WitOptComp    * myOptComp_;
//
// The OptComp owned by this CompMgr.

WitList <WitPart> allParts_;
//
// The List of all Parts owned by this CompMgr.

WitList <WitOperation> allOperations_;
//
// The List of all Operations owned by this CompMgr.

//------------------------------------------------------------------------
// Associations with Components.
//------------------------------------------------------------------------

WitList <WitComponent> allComponents_;
//
// The List of all Components for this CompMgr.

WitDerNodeTable <WitPart> *      myPartTable_;
WitDerNodeTable <WitOperation> * myOpnTable_;
//
// The DerNodeTables for finding the Parts and Operations of this
// CompMgr.

//------------------------------------------------------------------------
// Counts of the various Components.
//------------------------------------------------------------------------

int nParts_;
int nMaterials_;
int nOperations_;
int nBomEntries_;
int nSubEntries_;
int nBopEntries_;
int nDemands_;
int nBoundSets_;

//------------------------------------------------------------------------
// Caches of Components.
//------------------------------------------------------------------------

WitDemand * cachedDemand_;
//
// The Demand most recently constructed or found via findDemand.

WitBomEntry * cachedBomEntry_;
//
// The BomEntry most recently constructed or found via findBomEntry

WitSubEntry * cachedSubEntry_;
//
// The SubEntry most recently constructed or found via findSubEntry

WitBopEntry * cachedBopEntry_;
//
// The BopEntry most recently constructed or found via findBopEntry

//------------------------------------------------------------------------
// Other private member data.
//------------------------------------------------------------------------

WitDelCompItr * myDelCompItr_;
//
// The DelCompItr owned by this CompMgr.

bool purging_;
//
// true, iff this CompMgr is currently doing a purgeData.

WitComponent * recountingComp_;
//
// The Component currently being re-counted by this CompMgr, if any,
// else NULL.

WitComponent * deletingComp_;
//
// The Component currently being deleted by this CompMgr, if any,
// else NULL.

bool clearingDepLists_;
//
// true, iff the dependent Lists of the Components are being cleared.

WitNode * nameChangeNode_;
//
// The Node whose nodeName is currently being changed if any;
// otherwise NULL.

bool settingNodeName_;
//
// True, iff this CompMgr is currently setting the nodeName of a Node.
};
d399 4
a402 4
\
for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());  \
localItr1.advance ();)                                                \
forEachEl (theBomEnt, WitOperation::key (localItr1)->bom ())             \
d411 4
a414 4
\
for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());  \
localItr1.advance ();)                                                \
forEachEl (theBopEnt, WitOperation::key (localItr1)->bop ())             \
d423 7
a429 7
\
if ((theProblem)->myCompMgr ()->hasSubEntries ())                           \
for (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());\
localItr1.advance ();)                                             \
for  (WitListItr localItr2 (WitOperation::key (localItr1)->bom ());   \
localItr2.advance ();)                                          \
forEachEl (theSub, WitBomEntry::key (localItr2)->mySubEntries ())  \
d438 4
a441 4
\
for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allParts ());       \
localItr1.advance ();)                                                \
forEachEl (theDemand, WitPart::key (localItr1)->myDemands ())            \
d450 2
a451 2
\
forEachEl (theOpn, (theProblem)->myCompMgr ()->allOperations ())            \
d460 2
a461 2
\
forEachEl (thePart, (theProblem)->myCompMgr ()->allParts ())                \
d470 4
a473 4
\
for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allParts ());       \
localItr1.advance ();)                                                \
if (theMat = WitPart::key (localItr1)->thisMat (), (theMat != NULL))     \
@


1.44
log
@Multi-Objective Mode
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d30 237
a266 2
   {
   public:
d268 106
a373 341
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitCompMgr (WitProblem * theProblem);
         //
         // myProblem_ <-- theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitCompMgr ();

      //------------------------------------------------------------------------
      // Component inserting functions.
      // Each of these functions inserts its argument Component into this
      // CompMgr.
      // Checks that the argument has not previously been inserted.
      //------------------------------------------------------------------------

      void insert (WitGlobalComp *);
      void insert (WitOptComp *);
      void insert (WitMaterial *);
      void insert (WitCapacity *);
      void insert (WitOperation *);
      void insert (WitBomEntry *);
      void insert (WitSubEntry *);
      void insert (WitBopEntry *);
      void insert (WitDemand *);

      //------------------------------------------------------------------------
      // Component matching functions.
      // Each of these functions finds and returns the Component in this CompMgr
      // that belongs to the same class and has the same ID as the argument
      // Component. Checks that such a Component exists.
      //------------------------------------------------------------------------

      WitPart *      myMatchFor (WitPart *);
      WitMaterial *  myMatchFor (WitMaterial *);
      WitDemand *    myMatchFor (WitDemand *);
      WitOperation * myMatchFor (WitOperation *);
      WitSubEntry *  myMatchFor (WitSubEntry *);
      WitBoundSet *  myMatchFor (WitBoundSet *);

      //------------------------------------------------------------------------
      // find<Component> functions.
      // Each of these functions corresponds to a Component class. The function
      // finds and returns the Component class instance in this CompMgr
      // identified by the arguments, or NULL if no such Component exists.
      // Asserts that the Component argument (if any) belongs to this CompMgr.
      //------------------------------------------------------------------------

      WitPart *      findPart      (const char *   theName) const;
      WitOperation * findOperation (const char *   theName) const;
      WitBomEntry *  findBomEntry  (WitOperation * theOpn,    int theIndex);
      WitSubEntry *  findSubEntry  (WitBomEntry *  theBomEnt, int theIndex);
      WitBopEntry *  findBopEntry  (WitOperation * theOpn,    int theIndex);
      WitDemand *    findDemand    (WitPart *      thePart, 
                                    const char *   theName);

      //------------------------------------------------------------------------
      // Component recount functions for concrete classes.
      // Each of these functions counts its argument at the end of a purge.
      // Valid only the this CompMgr is calling recount on the arguement.
      // and only valid once for each such call.
      //------------------------------------------------------------------------

      void recountGlobalComp (WitGlobalComp *);
      void recountOptComp    (WitOptComp    *);
      void recountMaterial   (WitMaterial   *);
      void recountCapacity   (WitCapacity   *);
      void recountOperation  (WitOperation  *);
      void recountBomEntry   (WitBomEntry   *);
      void recountSubEntry   (WitSubEntry   *);
      void recountBopEntry   (WitBopEntry   *);
      void recountDemand     (WitDemand     *);

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void setPartName      (WitPart *      thePart, const char * theName);
      void setOperationName (WitOperation * theOpn,  const char * theName);
         //
         // Sets the partName      of thePart to theName.
         // Sets the operationName of theOpn  to theName.

      inline bool hasSubEntries () const
         {
         return (nSubEntries () > 0);
         }

      int nBoundSetsSpecified () const;
         //
         // Counts and returns the # of BoundSets in this CompMgr that are
         // specified.

      void purgeData ();
         //
         // Deletes all Components that are selected for deletion.

      bool isReindexing (WitBoundSet * theBoundSet) const;
         //
         // Returns true, iff this CompMgr is currently reindexing theBoundSet.

      bool isDeleting (WitComponent * theComp) const;
         //
         // Returns true, iff this CompMgr is currently deleting theComp.

      void storePreSortedNodes (const WitList <WitNode> & theNodes);
         //
         // Replaces allParts_ and allOperations_ with the contents of theNodes,
         // which is to be a sorted List.
         // Valid only when preprocessing is being performed.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitProblem *,                   myProblem)
      accessFunc (WitMsgFacility &,               myMsgFac)
      accessFunc (WitGlobalComp *,                myGlobalComp)
      accessFunc (WitOptComp *,                   myOptComp)
      accessFunc (const WitList <WitPart> &,      allParts)
      accessFunc (const WitList <WitOperation> &, allOperations)
      accessFunc (const WitList <WitComponent> &, allComponents)
      accessFunc (int,                            nParts)
      accessFunc (int,                            nMaterials)
      accessFunc (int,                            nOperations)
      accessFunc (int,                            nBomEntries)
      accessFunc (int,                            nSubEntries)
      accessFunc (int,                            nBopEntries)
      accessFunc (int,                            nDemands)
      accessFunc (int,                            nBoundSets)
      accessFunc (bool,                           clearingDepLists)
      accessFunc (bool,                           settingNodeName)
      accessFunc (WitDelCompItr *,                myDelCompItr)
      accessFunc (bool,                           purging)

      inline int nNodes () const
         {
         return nParts () + nOperations ();
         }

      inline int nConsEntries () const
         {
         return nBomEntries () + nSubEntries ();
         }

      inline int nBillEntries () const
         {
         return nConsEntries () + nBopEntries ();
         }

      inline int nDelComps () const
         {
         return allComponents ().nElements () - 2;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitCompMgr);

      //------------------------------------------------------------------------
      // Component recount functions for base classes.
      //------------------------------------------------------------------------

      void recountComponent (WitComponent *);
      void recountPart      (WitPart      *);
      void recountBillEntry (WitBillEntry *);
      void recountConsEntry (WitConsEntry *);

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

      void insertPart (WitPart * thePart);
         //
         // Inserts thePart into this CompMgr.

      void insertComp (WitComponent * theComp);
         //
         // Inserts theComp into this CompMgr.

      void setNodeName (WitNode * theNode, const char * theName);
         //
         // Sets the nodeName of theNode to theName, except for NodeTable
         // maintenance.

      int nSelForDel () const;
         //
         // Computes and returns the # of DelComps owned by this CompMgr that
         // are selected for deletion.

      void purgeCompLists ();
         //
         // Removes all selForDel Components from this CompMgr's Derived
         // Component Lists.

      void clearCaches ();
         //
         // Sets all the Component caches of the CompMgr to NULL.

      void recountComps ();
         //
         // Counts the instances of the Component classes and re-computes thier
         // mappingIndexes at the end of a purge.

      void deleteComps ();
         //
         // Clears allComponents_ and deletes all the Components.
         // The Components are deletes in reverse order so that each Component
         // will be deleted before any Component that it refers to.

      void deleteComp (WitComponent * theComp);
         //
         // Deletes theComp.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // General purpose associations.
      //------------------------------------------------------------------------

      WitProblem * const myProblem_;
         //
         // The Problem that owns this CompMgr.

      WitMsgFacility & myMsgFac_;
         //
         // The MsgFacility for this CompMgr.

      //------------------------------------------------------------------------
      // Component ownership.
      //------------------------------------------------------------------------

      WitGlobalComp * myGlobalComp_;
         //
         // The GlobalComp owned by this CompMgr.

      WitOptComp    * myOptComp_;
         //
         // The OptComp owned by this CompMgr.

      WitList <WitPart> allParts_;
         //
         // The List of all Parts owned by this CompMgr.

      WitList <WitOperation> allOperations_;
         //
         // The List of all Operations owned by this CompMgr.

      //------------------------------------------------------------------------
      // Associations with Components.
      //------------------------------------------------------------------------

      WitList <WitComponent> allComponents_;
         //
         // The List of all Components for this CompMgr.

      WitDerNodeTable <WitPart> *      myPartTable_;
      WitDerNodeTable <WitOperation> * myOpnTable_;
         //
         // The DerNodeTables for finding the Parts and Operations of this
         // CompMgr.

      //------------------------------------------------------------------------
      // Counts of the various Components.
      //------------------------------------------------------------------------

      int nParts_;
      int nMaterials_;
      int nOperations_;
      int nBomEntries_;
      int nSubEntries_;
      int nBopEntries_;
      int nDemands_;
      int nBoundSets_;

      //------------------------------------------------------------------------
      // Caches of Components.
      //------------------------------------------------------------------------

      WitDemand * cachedDemand_;
         //
         // The Demand most recently constructed or found via findDemand.

      WitBomEntry * cachedBomEntry_;
         //
         // The BomEntry most recently constructed or found via findBomEntry

      WitSubEntry * cachedSubEntry_;
         //
         // The SubEntry most recently constructed or found via findSubEntry

      WitBopEntry * cachedBopEntry_;
         //
         // The BopEntry most recently constructed or found via findBopEntry

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitDelCompItr * myDelCompItr_;
         //
         // The DelCompItr owned by this CompMgr.

      bool purging_;
         //
         // true, iff this CompMgr is currently doing a purgeData.

      WitComponent * recountingComp_;
         //
         // The Component currently being re-counted by this CompMgr, if any,
         // else NULL.

      WitComponent * deletingComp_;
         //
         // The Component currently being deleted by this CompMgr, if any,
         // else NULL.

      bool clearingDepLists_;
         //
         // true, iff the dependent Lists of the Components are being cleared.

      WitNode * nameChangeNode_;
         //
         // The Node whose nodeName is currently being changed if any;
         // otherwise NULL.

      bool settingNodeName_;
         //
         // True, iff this CompMgr is currently setting the nodeName of a Node.
   };
d399 4
a402 4
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());  \
         localItr1.advance ();)                                                \
      forEachEl (theBomEnt, WitOperation::key (localItr1)->bom ())             \
d411 4
a414 4
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());  \
         localItr1.advance ();)                                                \
      forEachEl (theBopEnt, WitOperation::key (localItr1)->bop ())             \
d423 7
a429 7
                                                                               \
   if ((theProblem)->myCompMgr ()->hasSubEntries ())                           \
      for (WitListItr localItr1 ((theProblem)->myCompMgr ()->allOperations ());\
            localItr1.advance ();)                                             \
         for  (WitListItr localItr2 (WitOperation::key (localItr1)->bom ());   \
               localItr2.advance ();)                                          \
            forEachEl (theSub, WitBomEntry::key (localItr2)->mySubEntries ())  \
d438 4
a441 4
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allParts ());       \
         localItr1.advance ();)                                                \
      forEachEl (theDemand, WitPart::key (localItr1)->myDemands ())            \
d450 2
a451 2
                                                                               \
   forEachEl (theOpn, (theProblem)->myCompMgr ()->allOperations ())            \
d460 2
a461 2
                                                                               \
   forEachEl (thePart, (theProblem)->myCompMgr ()->allParts ())                \
d470 4
a473 4
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allParts ());       \
         localItr1.advance ();)                                                \
      if (theMat = WitPart::key (localItr1)->thisMat (), (theMat != NULL))     \
@


1.43
log
@Object name change.
@
text
@d66 1
a66 1
      // Each of these functions finds and returns the object in this CompMgr
d68 1
a68 1
      // object. Checks that such a object exists.
@


1.42
log
@Object Name Changing.
@
text
@d169 1
a169 1
      accessFunc (WitNode *,                      nameChangeNode)
d369 4
@


1.41
log
@Object name changing.
@
text
@a167 4
      accessFunc (WitDemand *,                    cachedDemand)
      accessFunc (WitBomEntry *,                  cachedBomEntry)
      accessFunc (WitSubEntry *,                  cachedSubEntry)
      accessFunc (WitBopEntry *,                  cachedBopEntry)
a201 11
      // Caching functions.
      // Each of the following functions records the fact that its argument
      // had just been constructed or looked up.
      //------------------------------------------------------------------------

      WitDemand *   cache (WitDemand *);
      WitBomEntry * cache (WitBomEntry *);
      WitSubEntry * cache (WitSubEntry *);
      WitBopEntry * cache (WitBopEntry *);

      //------------------------------------------------------------------------
@


1.40
log
@Object name changing.
@
text
@d115 2
a116 1
      void setPartName (WitPart * thePart, const char * theName);
d118 2
a119 1
         // Sets the partName of thePart to theName.
d237 5
@


1.39
log
@Object name change.
@
text
@d115 4
d171 1
d372 5
@


1.38
log
@Stochastic Implosion
@
text
@d303 2
a304 1
      WitNodeTable * myPartTable_;
d306 2
a307 5
         // The NodeTable for finding the Parts of this CompMgr.

      WitNodeTable * myOperationTable_;
         //
         // The NodeTable for finding the Operations of this CompMgr.
@


1.37
log
@Stochastic Implosion
@
text
@d72 1
d75 1
@


1.36
log
@Stochastic Implosion
@
text
@d127 1
a127 1
      bool isReindexing (const WitBoundSet * theBoundSet) const;
@


1.35
log
@Stochastic Implosion
@
text
@d66 3
a68 3
      // Each of these functions finds and returns the derived Component class
      // instance in this CompMgr that has the same ID as the argument
      // Component. Checks that such a Component exists.
d71 4
a74 2
      WitPart *      match (WitPart *);
      WitOperation * match (WitOperation *);
@


1.34
log
@Stochastic Implosion
@
text
@d133 1
a133 1
      void passPreRefs ();
d135 3
a137 2
         // Passes references to the preprocessing  data of this CompMgr to the
         // Preprocessor.
@


1.33
log
@Stochastic Implosion
@
text
@a137 4
      void importPreData ();
         //
         // Imports this CompMgr's preprocessing data from myPreprocessor ().

@


1.32
log
@Stochastic Implosion
@
text
@d133 5
@


1.31
log
@[disallowed backlog]
@
text
@a30 2
      friend class WitPreAccess;

d133 4
@


1.30
log
@[disallowed backlog]
@
text
@a112 57
      static void transmitAllDMPs ();
         //
         // "Transmit all data member pointers."
         //
         // This function carries out the "data member pointer transmition
         // process". 
         // In this process, the pointers to some of the data members of the
         // primary data-owning classes of WIT are transmitted to the classes
         // that are responsible for computing the values of these data members.
         // By this process, the data-owning classes delegate responsiblity for
         // computing values for their data to specifically selected
         // data-computing classes.
         //               
         // The process proceeds as follows:
         // * The first time the WitRun ctor is called, this function is called,
         //   and the data member pointer transmition process begins.
         // * (On subsequent calls to the WitRun ctor, this function takes no
         //   action.)
         // * This function calls the static member function tranmitDMPs for
         //   each of the primary data-owning classes of WIT.
         // * Each tranmitDMPs calls a static receiveDMPs function for each
         //   class to which it is delegating responsibility for computing its
         //   data and passes as an argument a pointer to each data member for
         //   which computation responsibility is being delegated.
         // * Most receiveDMPs functions set a static data member of the 
         //   receiving class to the data member pointer that is being passed
         //   in.
         // * Some receiveDMPs functions further transmit the data member to yet
         //   another class by calling one of its receiveDMPs functions.
         //
         // After the data member pointer transmition process has been
         // completed, the computing classes are then able to use their data
         // member pointers to set the values of the corrsponding data members
         // at any time for the rest of the program process.
         //
         // Example:
         // * CompMgr::transmitAllDMPs () calls Part::transmitDMPs ().
         // * Part::transmitDMPs () calls Postprocessor::receiveDMPs (...) with
         //   several arguments, including a pointer to the consVol_ data
         //   member of class Part, which is passed as the consVolArg
         //   argument.
         // * Class Postprocessor has a static data member called consVol_ whose
         //   type is a pointer to a data member of class Part.
         //   Postprocessor::receiveDMPs (...) sets this consVol_ pointer to
         //   the value of the consVolArg argument.
         // * As a result, upon completion of the data member pointer
         //   transmition process, for any Part, thePart, whenever class
         //   Postprocessor refers to thePart->*consVol_, it is really referring
         //   to thePart->consVol_, which is otherwise an inaccessible private
         //   data meber of class Part.
         //   This enables each instance of class Postprocessor to compute the
         //   consVol_ of each Part in its WitRun, without allowing any other
         //   class to set the value of consVol_.
         //   In this sense, class Part has delegated responsibiliy for
         //   computing the value of its consVol_ data member to class
         //   Postprocessor.

a360 4

      static bool transAllDMPsDone_;
         //
         // true, iff transmitAllDMPs () has been called.
@


1.29
log
@Replaced WIT's hash tables with std:maps.
@
text
@d31 2
a307 4
      static void transmitDMPs ();
         //
         // See comment on transmitAllDMPs in CompMgr.h.

@


1.28
log
@Updated the copyright date on all source files.
@
text
@d354 1
a354 1
      WitHashTable * myPartTable_;
d356 1
a356 1
         // The hash table for finding the Parts of this CompMgr.
d358 1
a358 1
      WitHashTable * myOperationTable_;
d360 1
a360 1
         // The hash table for finding the Operations of this CompMgr.
d423 1
a423 1
         // ...
@


1.27
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.26
log
@[multi-thread]
@
text
@d148 3
a150 3
         // * Part::transmitDMPs () calls Preprocessor::receiveDMPs (...) with
         //   several arguments, including a pointer to the belowList_ data
         //   member of class Part, which is passed as the belowListArg
d152 1
a152 4
         // * Preprocessor::receiveDMPs (...) calls
         //   BelowLister::receiveDMPs (...), passing the belowListArg argument
         //   to it.
         // * Class BelowLister has a static data member called belowList_ whose
d154 2
a155 2
         //   BelowLister::receiveDMPs (...) sets this belowList_ pointer to
         //   the belowListArg.
d158 9
a166 6
         //   BelowLister refers to thePart->*belowList_, it is really referring
         //   to thePart->belowList_ (which is otherwise a private data meber of
         //   class Part). 
         //   This enables each instance of class BelowLister to compute the
         //   below list of each Part in its WitRun, without allowing other
         //   classes to update the value of the below list.
@


1.25
log
@[multi-thread]
@
text
@d111 1
a111 1
      static void transmitData ();
d113 1
a113 3
         // ...

      void loadPre ();
d115 52
a166 1
         // Data loading function.
d306 4
d421 1
a421 1
      static bool dataTransmitted_;
@


1.24
log
@Continued implementation of PIP.
@
text
@a47 47
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitProblem *,                   myProblem)
      accessFunc (WitMsgFacility &,               myMsgFac)
      accessFunc (WitGlobalComp *,                myGlobalComp)
      accessFunc (WitOptComp *,                   myOptComp)
      accessFunc (const WitList <WitPart> &,      allParts)
      accessFunc (const WitList <WitOperation> &, allOperations)
      accessFunc (const WitList <WitComponent> &, allComponents)
      accessFunc (int,                            nParts)
      accessFunc (int,                            nMaterials)
      accessFunc (int,                            nOperations)
      accessFunc (int,                            nBomEntries)
      accessFunc (int,                            nSubEntries)
      accessFunc (int,                            nBopEntries)
      accessFunc (int,                            nDemands)
      accessFunc (int,                            nBoundSets)
      accessFunc (WitDemand *,                    cachedDemand)
      accessFunc (WitBomEntry *,                  cachedBomEntry)
      accessFunc (WitSubEntry *,                  cachedSubEntry)
      accessFunc (WitBopEntry *,                  cachedBopEntry)
      accessFunc (bool,                           clearingDepLists)
      accessFunc (WitDelCompItr *,                myDelCompItr)
      accessFunc (bool,                           purging)

      inline int nNodes () const
         {
         return nParts () + nOperations ();
         }

      inline int nConsEntries () const
         {
         return nBomEntries () + nSubEntries ();
         }

      inline int nBillEntries () const
         {
         return nConsEntries () + nBopEntries ();
         }

      inline int nDelComps () const
         {
         return allComponents ().nElements () - 2;
         }

      //------------------------------------------------------------------------
d111 4
d141 47
d367 4
@


1.23
log
@Removed a bad function overload.
@
text
@d29 1
a29 1
class WitCompMgr: public WitUtil
@


1.22
log
@Continued implementation of proportionate routing.
@
text
@d463 1
a463 1
      if (theMat = WitPart::key (localItr1)->myMat (), (theMat != NULL))       \
@


1.21
log
@Continued implementation of proportionate routing.
@
text
@d22 1
a22 1
// class CompMgr
@


1.20
log
@Continued implementation of proportionate routing.
@
text
@d463 1
a463 1
      if (WitPart::key (localItr1)->getMaterial (theMat), (theMat != NULL))    \
@


1.19
log
@Internal changes.
@
text
@a94 21
      // nInstances function.
      // Each function returns # instances of the class indicated by the
      // argument that are managed by this CompMgr.
      // The value of the argument is ignored; the argument is only used to
      // facilitate overloading.
      // Used by by mapping classes.
      //------------------------------------------------------------------------

      int nInstances (WitNode *     ) const;
      int nInstances (WitPart *     ) const;
      int nInstances (WitOperation *) const;
      int nInstances (WitMaterial * ) const;
      int nInstances (WitBillEntry *) const;
      int nInstances (WitBomEntry * ) const;
      int nInstances (WitSubEntry * ) const;
      int nInstances (WitBopEntry * ) const;
      int nInstances (WitDemand *   ) const;

      int nInstances (const WitBoundSet * ) const;

      //------------------------------------------------------------------------
@


1.18
log
@Continued implementation of single-source.
@
text
@d70 1
a70 1
      accessFunc (WitBoolean,                     clearingDepLists)
d72 1
a72 1
      accessFunc (WitBoolean,                     purging)
d183 1
a183 1
      inline WitBoolean hasSubEntries () const
d197 1
a197 1
      WitBoolean isReindexing (const WitBoundSet * theBoundSet) const;
d199 1
a199 1
         // Returns TRUE, iff this CompMgr is currently reindexing theBoundSet.
d201 1
a201 1
      WitBoolean isDeleting (WitComponent * theComp) const;
d203 1
a203 1
         // Returns TRUE, iff this CompMgr is currently deleting theComp.
d367 1
a367 1
      WitBoolean purging_;
d369 1
a369 1
         // TRUE, iff this CompMgr is currently doing a purgeData.
d381 1
a381 1
      WitBoolean clearingDepLists_;
d383 1
a383 1
         // TRUE, iff the dependent Lists of the Components are being cleared.
@


1.17
log
@Continued implementation of single-source.
@
text
@d176 1
a176 1
      // Conditional reference access functions.
d179 3
a181 6
      conditionalRef (WitList <WitPart>,      allParts,      preprocAcc ())
      conditionalRef (WitList <WitOperation>, allOperations, preprocAcc ())

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------
a272 6

      WitBoolean preprocAcc () const;
         //
         // Returns TRUE, iff the Preprocessor is currently accessing this
         // CompMgr's data.
         // Returns TRUE, in non-DEBUG mode.
@


1.16
log
@Continued implementation of single-source.
@
text
@d176 7
a184 5

      void importSortedNodes ();
         //
         // Re-orders the elements of allParts_ and allOperations_ according to
         // the sorted Nodes of the Preprocessor.
@


1.15
log
@Preliminary work on single source.
@
text
@d176 1
a176 1
      // Conditional reference access functions.
d179 4
a182 6
      conditionalRef (WitList <WitPart>,      allParts,      preprocAcc ())
      conditionalRef (WitList <WitOperation>, allOperations, preprocAcc ())

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------
@


1.14
log
@Continued implementation of object iteration.
@
text
@d55 3
a57 3
      accessFunc (const WitList (WitPart) &,      allParts)
      accessFunc (const WitList (WitOperation) &, allOperations)
      accessFunc (const WitList (WitComponent) &, allComponents)
d179 2
a180 2
      conditionalRef (WitList (WitPart),      allParts,      preprocAcc ())
      conditionalRef (WitList (WitOperation), allOperations, preprocAcc ())
d311 1
a311 1
      WitList (WitPart) allParts_;
d315 1
a315 1
      WitList (WitOperation) allOperations_;
d323 1
a323 1
      WitList (WitComponent) allComponents_;
@


1.13
log
@Began implementation of object iteration.
@
text
@d71 1
d372 4
d493 1
a493 1
      if ((theMat = WitPart::key (localItr1)->myMat ()) != NULL)               \
@


1.12
log
@Continued development of Selective Stock Reallocation.
@
text
@a16 38
//
// This file is at the top of the following chain of header files:
//
// CompMgr.h,  which includes:
// Demand.h,   which includes:
// BopEntry.h, which includes:
// SubEntry.h, which includes:
// BomEntry.h, which includes:
// ConsEnt.h,  which includes:
// Entry.h,    which includes:
// Capacity.h, which includes:
// Material.h, which includes:
// Part.h,     which includes:
// Opn.h,      which includes:
// Node.h      which includes:
// Global.h,   which includes:
// DelComp.h   which includes:
// Compo.h,    which includes:
// BoundSet.h, which includes:
// FlexVec.h,  which includes:
// FlexVecR.h, which includes:
// Assoc.h,    which includes:
// Problem.h,  which includes:
// TVec.h,     which includes:
// Str.h,      which includes:
// List.h,     which includes:
// Vector.h,   which includes:
// MsgFac.h,   which includes:
// Util.h,     which includes:
// typedefs.h, which includes:
// macs.h,     which includes:
// defines.h,  which includes:
// includes.h
//
// Thus a file only needs to include one of these file, because doing so
// automatically causes all files below it in the list to be included.
// Generally, a file should at least include Util.h, because it and the
// files it includes define the basic convensions of WIT.
d19 1
a19 1
#include <Demand.h>
@


1.11
log
@Continued implementation of selective stock reallocation.
@
text
@a516 12
// forEachCapacity
// Expands to the header of a "for" loop causing theCap to
// iterate thru all the Capacities in theProblem.
//------------------------------------------------------------------------------

#define forEachCapacity(theCap, theProblem)                                    \
                                                                               \
   for  (WitListItr localItr1 ((theProblem)->myCompMgr ()->allParts ());       \
         localItr1.advance ();)                                                \
      if (WitPart::key (localItr1)->getMyCapacity (theCap))                    \

//------------------------------------------------------------------------------
d526 1
a526 1
      if (WitPart::key (localItr1)->getMyMaterial (theMat))                    \
@


1.10
log
@Changed name of String.h to be Str.h to avoid windows build problems
@
text
@d526 1
a526 1
      if (WitPart::key (localItr1)->isaCapacity (theCap))                      \
d538 1
a538 1
      if (WitPart::key (localItr1)->isaMaterial (theMat))                      \
@


1.9
log
@Implemented and used class SelMgr.
@
text
@d41 1
a41 1
// String.h,   which includes:
@


1.8
log
@Coarse selection splitting.
@
text
@d42 2
a43 1
// RWClient.h, which includes:
@


1.7
log
@Some minor changes.
@
text
@d195 1
a195 1
      // Component recount functions.
d201 9
a209 8
      void recount (WitComponent *);
      void recount (WitMaterial  *);
      void recount (WitCapacity  *);
      void recount (WitOperation *);
      void recount (WitBomEntry  *);
      void recount (WitSubEntry  *);
      void recount (WitBopEntry  *);
      void recount (WitDemand    *);
d264 9
a301 11

      inline void recountComp (WitComponent * theComp)
         {
         recount (theComp);
         }
         //
         // Unhides recount (Comp *).

      void recountPart (WitPart * thePart);
         //
         // Recount for thePart.
@


1.6
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d40 2
a41 1
// Vector.h,   which includes:
@


1.5
log
@Refactoring for selection splitting.
@
text
@d196 1
a196 1
      // Only valid the this CompMgr is calling recount on the arguement.
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d248 1
a248 3
      copyCtorAndAssignment (WitCompMgr);
         //
         // Prevents unintentional copying and assignment.
a318 5
      inline WitComponent * & indexedComp (int i)
         {
         return (WitComponent * &) indexedCompTl_[i];
         }

a406 5

      WitVector (WitTypelessPtr) indexedCompTl_;
         //
         // Vector of all Components.
         // Used by dtor.
@


1.3
log
@Replaced WitPart.[Ch] with Part.[Ch].
@
text
@d51 1
a51 1
// Generally, a file should at least include typedefs.h, because it and the
d65 1
a65 1
class WitCompMgr
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d29 1
a29 1
// WitPart.h,  which includes:
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

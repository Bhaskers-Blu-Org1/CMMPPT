head	1.102;
access;
symbols;
locks; strict;
comment	@ * @;


1.102
date	2011.09.28.23.49.10;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2011.09.24.00.27.28;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2011.08.30.20.17.22;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2011.08.30.18.14.49;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2011.08.29.18.06.24;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2011.08.26.22.54.43;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2011.02.16.17.02.40;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2011.02.15.23.25.59;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2011.02.15.21.20.12;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2011.02.10.17.13.24;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2011.02.10.00.46.30;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2011.02.09.20.24.12;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2011.02.09.19.13.21;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2011.02.08.23.21.06;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2011.02.08.21.49.01;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2011.02.08.17.17.09;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2011.02.08.00.46.53;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2011.02.08.00.28.04;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2011.02.07.22.05.11;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2011.02.07.21.18.33;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2011.02.07.15.45.52;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2011.02.04.17.24.18;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2011.02.03.19.02.10;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2011.02.02.00.37.03;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2011.01.31.21.21.51;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2011.01.31.19.57.15;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2011.01.29.00.16.25;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2011.01.28.23.42.55;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2011.01.28.20.22.04;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2011.01.28.19.38.14;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2011.01.28.00.13.48;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.28.00.06.36;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2011.01.27.23.43.04;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.27.23.16.37;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2011.01.27.19.55.45;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2011.01.25.00.22.56;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2011.01.21.23.23.50;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2011.01.21.00.34.33;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2011.01.04.21.39.21;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2010.12.13.21.36.32;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2010.12.10.19.28.44;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.10.15.40.26;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2010.12.10.00.40.25;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2010.12.09.22.42.38;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2010.12.09.16.57.01;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2010.12.09.00.34.40;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2010.12.08.23.42.58;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2010.12.08.23.04.37;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.08.00.32.31;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2010.12.07.00.29.45;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2010.12.06.19.58.19;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2010.12.04.00.29.43;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.03.20.05.02;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2010.12.03.16.21.39;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2010.12.03.16.06.16;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.03.00.36.43;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.19.21.28.21;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2010.11.17.20.20.52;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2010.11.12.22.03.04;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2010.11.11.19.37.31;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2010.11.08.22.14.33;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2010.11.08.21.38.18;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2010.11.08.20.38.03;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2010.11.05.21.32.25;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.05.19.00.45;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.11.03.20.45.03;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2010.11.03.20.25.33;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2010.10.07.15.41.00;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2010.10.06.20.49.57;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.31.23.43.59;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.31.23.27.47;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.31.23.12.52;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.27.21.06.49;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.24.22.49.25;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.24.22.06.43;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2010.08.24.18.17.55;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.24.16.30.29;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.20.22.05.52;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.20.21.07.36;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.20.19.42.21;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.20.16.43.58;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.19.21.05.00;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.19.20.09.50;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2010.08.19.18.00.11;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.19.14.22.14;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.18.20.58.23;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.17.22.22.55;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.09.21.53.39;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.04.23.24.56;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.04.21.13.13;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.04.20.23.31;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.02.18.38.41;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.27.23.27.55;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.27.23.06.03;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.24.22.35.58;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.24.21.58.00;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.24.20.32.07;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.21.23.46.13;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.21.22.52.01;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.21.18.17.56;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.21.15.28.01;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.20.23.18.42;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.102
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "CplexMgr.C"
//
// Contains the implementation of class CplexGateway.
//    The implementation of class CplexGateway is conditional on whether or not
//    CPLEX_EMBEDDED is defined.
//
// Contains the implementation of class CplexMgr.
//    The implementation of class CplexMgr is compiled only if CPLEX_EMBEDDED is
//    defined.
//------------------------------------------------------------------------------

#include <CplexGateway.h>
#include <CplexMgr.h>

//------------------------------------------------------------------------------
// CPLEX-embedded Implementation of class CplexGateway.
//------------------------------------------------------------------------------

#ifdef CPLEX_EMBEDDED

WitCplexGateway::WitCplexGateway (WitOptProblem * theOptProblem):
      myCplexMgr_ (NULL)
   {
   myCplexMgr_ = new WitCplexMgr (theOptProblem);
   }

//------------------------------------------------------------------------------

WitCplexGateway::~WitCplexGateway ()
   {
   delete myCplexMgr_;
   }

//------------------------------------------------------------------------------

bool WitCplexGateway::cplexEmbedded ()
   {
   return true;
   }

//------------------------------------------------------------------------------

void WitCplexGateway::solveOptProb ()
   {
   myCplexMgr_->solveOptProb ();
   }

#endif // CPLEX_EMBEDDED

//------------------------------------------------------------------------------
// Non-CPLEX-embedded Implementation of class CplexGateway.
//------------------------------------------------------------------------------

#ifndef CPLEX_EMBEDDED

WitCplexGateway::WitCplexGateway (WitOptProblem *):
      myCplexMgr_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitCplexGateway::~WitCplexGateway ()
   {
   }

//------------------------------------------------------------------------------

bool WitCplexGateway::cplexEmbedded ()
   {
   return false;
   }

//------------------------------------------------------------------------------

void WitCplexGateway::solveOptProb ()
   {
   stronglyAssert (false);
   }

#endif // not CPLEX_EMBEDDED

//------------------------------------------------------------------------------
// Implementation of class CplexMgr.
//------------------------------------------------------------------------------

#ifdef CPLEX_EMBEDDED

//------------------------------------------------------------------------------

#include <OptComp.h>
#include <CpxParSpecMgr.h>
#include <CpxParSpec.h>
#include <MultiObjMgr.h>
#include <SaeMgr.h>
#include <OptProblem.h>
#include <OptVar.h>
#include <OptCon.h>
#include <OptStarter.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <Timing.h>

#include <float.h>

//------------------------------------------------------------------------------

WitCplexMgr::WitCplexMgr (WitOptProblem * theOptProblem):

      WitProbAssoc  (theOptProblem),
      myOptProblem_ (theOptProblem),
      myCpxEnv_     (NULL),
      myCpxLp_      (NULL)
   {
   setUpCplex ();
   }

//------------------------------------------------------------------------------

WitCplexMgr::~WitCplexMgr ()
   {
   shutDownCplex ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveOptProb ()
   {
   WitTimer::enterSection ("cplex");

   if      (myOptComp ()->multiObjMode ())
      {
      solveOptProbAsLexOpt ();
      }
   else if (myOptProblem_->reSolveMode ())
      {
      reSolveOptProbAsLp ();
      }
   else if (mipMode ())
      {
      solveOptProbAsMip ();
      }
   else
      {
      solveOptProbAsLp ();
      }

   WitTimer::leaveSection ("cplex");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setUpCplex ()
   {
   int theErrCode;

   myCpxEnv_ = CPXopenCPLEX (& theErrCode);

   checkErrCode (theErrCode, "openCPLEX");

   stronglyAssert (myCpxEnv_ != NULL);

   //...........................................................................

   setUpLogFile ();

   //...........................................................................

   myCpxLp_ = CPXcreateprob (myCpxEnv_, & theErrCode, "Implosion");

   checkErrCode (theErrCode, "createprob");

   stronglyAssert (myCpxLp_ != NULL);
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setUpLogFile ()
   {
   const char * theFileName;
   CPXFILEptr   theCpxFile;

   theFileName = myOptComp ()->solverLogFileName ().myCstring ();

   theCpxFile  = CPXfopen (theFileName, "w");

   if (theCpxFile == NULL)
      {
      myMsgFac () ("cpxfopenSmsg", theFileName, "w");
      }

   //...........................................................................

   callCplex (
     "CPXsetlogfile",
      CPXsetlogfile (
         myCpxEnv_,
         theCpxFile));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::shutDownCplex ()
   {
   callCplex (
     "CPXfreeprob",
      CPXfreeprob (
         myCpxEnv_,
       & myCpxLp_));

   //...........................................................................

   shutDownLogFile ();

   //...........................................................................

   callCplex (
     "CPXcloseCPLEX",
      CPXcloseCPLEX (
       & myCpxEnv_));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::shutDownLogFile ()
   {
   CPXFILEptr theCpxFile;

   callCplex (
     "CPXgetlogfile",
      CPXgetlogfile (
         myCpxEnv_,
       & theCpxFile));

   //...........................................................................

   callCplex (
     "CPXsetlogfile",
      CPXsetlogfile (
         myCpxEnv_,
         NULL));

   //...........................................................................

   callCplex (
     "CPXfclose",
      CPXfclose (
         theCpxFile));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveOptProbAsLp ()
   {
   myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("lpFrag"), "CPLEX");

   loadLp ();

   writeMps ();

   setLpMethodByOptStarter ();

   loadInitSoln ();

   solveLp (myOptProblem_->needDual ());

   storePrimalSoln ();

   if (myOptProblem_->needDual ())
      storeDualSoln ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::reSolveOptProbAsLp ()
   {
   myMsgFac () ("reSolveLpMsg", "CPLEX");

   reviseLp ();

   writeMps ();

   setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_DUAL);

   solveLp (myOptProblem_->needDual ());

   storePrimalSoln ();

   if (myOptProblem_->needDual ())
      storeDualSoln ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveOptProbAsMip ()
   {
   myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("mipFrag"), "CPLEX");

   loadLp ();

   loadIntData ();

   writeMps ();

   solveMip (false);

   storePrimalSoln ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveOptProbAsLexOpt ()
   {
   myMsgFac () ("solveOptProblemMsg",
      myMsgFac ().myFrag (mipMode ()? "mipFrag": "lpFrag"),
      "CPLEX");

   myMsgFac () ("lexOptMsg");

   loadLp ();

   if (mipMode ())
      loadIntData ();

   writeMps ();

   solveLexOpt ();

   storePrimalSoln ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::loadLp ()
   {
   WitVector <double> objective;
   WitVector <double> rhs;
   WitVector <char>   sense;
   WitVector <int>    matbeg;
   WitVector <int>    matcnt;
   WitVector <int>    matind;
   WitVector <double> matval;
   WitVector <double> lb;
   WitVector <double> ub;

   getRowData    (rhs,       sense);
   getColumnData (objective, matbeg, matcnt, matind, matval, lb, ub);

   callCplex (
     "CPXcopylp",
      CPXcopylp (
         myCpxEnv_,
         myCpxLp_,
         myOptProblem_->nOptVars (),
         myOptProblem_->nOptCons (),
         -1,
         objective.myCVec (),
         rhs      .myCVec (),
         sense    .myCVec (),
         matbeg   .myCVec (),
         matcnt   .myCVec (),
         matind   .myCVec (),
         matval   .myCVec (),
         lb       .myCVec (),
         ub       .myCVec (),
         NULL));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::getRowData (
      WitVector <double> & rhs,
      WitVector <char> &   sense)
   {
   WitOptCon * theOptCon;
   int         theIdx;

   WitTimer::enterSection ("opt-prob");

   rhs  .resize (myOptProblem_->nOptCons ());
   sense.resize (myOptProblem_->nOptCons ());

   forEachEl (theOptCon, myOptProblem_->myOptCons ())
      {
      theIdx = theOptCon->index ();

      getConData (rhs[theIdx], sense[theIdx], theOptCon);
      }

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::getColumnData (
      WitVector <double> & objective,
      WitVector <int> &    matbeg,
      WitVector <int> &    matcnt,
      WitVector <int> &    matind,
      WitVector <double> & matval,
      WitVector <double> & lb,
      WitVector <double> & ub)
   {
   int         ncols;
   WitOptVar * theOptVar;
   int         theIdx;

   WitTimer::enterSection ("opt-prob");

   ncols = myOptProblem_->nOptVars ();

   objective.resize (ncols);
   matcnt   .resize (ncols);
   lb       .resize (ncols);
   ub       .resize (ncols);

   myOptProblem_->getMatrixByCols (matbeg, matind, matval);

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      theIdx            = theOptVar->index ();

      objective[theIdx] = theOptVar->objCoeff ();

      matcnt[theIdx]    = matbeg[theIdx + 1] - matbeg[theIdx];

      lb[theIdx]        = theOptVar->bounds ().lower ();
      ub[theIdx]        = theOptVar->bounds ().upper ();
      }

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::reviseLp ()
   {
   reviseBounds    ();
   reviseRHS       ();
   reviseObjCoeffs ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::reviseBounds ()
   {
   int                cnt;
   WitVector <int>    indices;
   WitVector <char>   lu;
   WitVector <double> bd;
   WitOptVar *        theOptVar;
   int                theColIdx;

   WitTimer::enterSection ("opt-prob");

   cnt = myOptProblem_->nOptVars ();

   indices.resize (cnt);
   lu     .resize (cnt);
   bd     .resize (cnt);

   theColIdx = -1;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      theColIdx ++;

      witAssert (theColIdx == theOptVar->index ());

      indices[theColIdx] = theColIdx;
      lu     [theColIdx] = 'L';
      bd     [theColIdx] = theOptVar->bounds ().lower ();
      }

   callCplex (
     "CPXchgobj",
      CPXchgbds (
         myCpxEnv_,
         myCpxLp_,
         cnt,
         indices.myCVec (),
         lu     .myCVec (),
         bd     .myCVec ()));

   theColIdx = -1;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      theColIdx ++;

      lu[theColIdx] = 'U';
      bd[theColIdx] = theOptVar->bounds ().upper ();
      }

   callCplex (
     "CPXchgobj",
      CPXchgbds (
         myCpxEnv_,
         myCpxLp_,
         cnt,
         indices.myCVec (),
         lu     .myCVec (),
         bd     .myCVec ()));

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::reviseRHS ()
   {
   int                cnt;
   WitVector <int>    indices;
   WitVector <double> values;
   WitOptCon *        theOptCon;
   int                theRowIdx;
   char               sense;

   WitTimer::enterSection ("opt-prob");

   cnt = myOptProblem_->nOptCons ();

   indices.resize (cnt);
   values .resize (cnt);

   theRowIdx = -1;

   forEachEl (theOptCon, myOptProblem_->myOptCons ())
      {
      theRowIdx ++;

      witAssert (theRowIdx == theOptCon->index ());

      indices[theRowIdx] = theRowIdx;

      getConData (values[theRowIdx], sense, theOptCon);
      }

   callCplex (
     "CPXchgrhs",
      CPXchgrhs (
         myCpxEnv_,
         myCpxLp_,
         cnt,
         indices.myCVec (),
         values .myCVec ()));

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::getConData (double & rhs, char & sense, WitOptCon * theOptCon)
   {
   double theLB;
   double theUB;

   theLB  = theOptCon->bounds ().lower ();
   theUB  = theOptCon->bounds ().upper ();

   if (theLB == theUB)
      {
      rhs   = theLB;
      sense = 'E';
      }
   else if (theUB == + DBL_MAX)
      {
      rhs   = theLB;
      sense = 'G';
      }
   else if (theLB == - DBL_MAX)
      {
      rhs   = theUB;
      sense = 'L';
      }
   else
      {
      stronglyAssert (false);
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::reviseObjCoeffs ()
   {
   int                cnt;
   WitVector <int>    indices;
   WitVector <double> values;
   WitOptVar *        theOptVar;
   int                theColIdx;

   WitTimer::enterSection ("opt-prob");

   cnt = myOptProblem_->nOptVars ();

   indices.resize (cnt);
   values .resize (cnt);

   theColIdx = -1;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      theColIdx ++;

      witAssert (theColIdx == theOptVar->index ());

      indices[theColIdx] = theColIdx;
      values [theColIdx] = theOptVar->objCoeff ();
      }

   callCplex (
     "CPXchgobj",
      CPXchgobj (
         myCpxEnv_,
         myCpxLp_,
         cnt,
         indices.myCVec (),
         values .myCVec ()));

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::loadIntData ()
   {
   int              nIntVars;
   WitVector <int>  theIndices;
   WitVector <char> theTypeChars;
   int              theIdx;
   WitOptVar *      theOptVar;

   WitTimer::enterSection ("opt-prob");

   nIntVars = countIntVars ();

   theIndices  .resize (nIntVars);
   theTypeChars.resize (nIntVars, 'I');

   theIdx = -1;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      if (theOptVar->isAnIntVar ())
         {
         theIdx ++;

         theIndices[theIdx] = theOptVar->index ();
         }
      }

   WitTimer::leaveSection ("opt-prob");

   callCplex (
     "CPXchgctype",
      CPXchgctype (
         myCpxEnv_,
         myCpxLp_,
         nIntVars,
         theIndices  .myCVec (),
         theTypeChars.myCVec ()));
   }

//------------------------------------------------------------------------------

int WitCplexMgr::countIntVars ()
   {
   int         nIntVars;
   WitOptVar * theOptVar;

   WitTimer::enterSection ("opt-prob");

   nIntVars = 0;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      if (theOptVar->isAnIntVar ())
         nIntVars ++;
      }

   WitTimer::leaveSection ("opt-prob");

   return nIntVars;
   }

//------------------------------------------------------------------------------

void WitCplexMgr::writeMps ()
   {
   if (myOptComp ()->printMps ())
      {
      myMsgFac () ("mpsFileMsg");

      callCplex (
        "CPXwriteprob",
         CPXwriteprob (
            myCpxEnv_,
            myCpxLp_,
            "opt-prob.mps",
            NULL));
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveLexOpt ()
   {
   WitOptVar *              prevOptVar;
   WitPtrVecItr <WitOptVar> theOptVarItr;
   WitOptVar *              theOptVar;

   if (DEVELOPMENT)
      WitTimer::getTimeAndChargeToCurrent ();

   if (not mipMode ())
      loadInitSoln ();

   prevOptVar = NULL;

   myOptProblem_->myLexOptVarSeq ().attachItr (theOptVarItr);

   while (theOptVarItr.advance (theOptVar))
      {
      myMsgFac () ("optLexObjElemMsg", theOptVar->lexObjElemName ());

      if (prevOptVar != NULL)
         {
         lockLexObjElemVal (prevOptVar);

         setObjCoef (prevOptVar, 0.0);
         }

      setObjCoef (theOptVar, 1.0);

      if (mipMode ())
         {
         solveMip (true);
         }
      else
         {
         if (prevOptVar != NULL)
            setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
         else
            setLpMethodByOptStarter ();

         solveLp (true);
         }

      if (DEVELOPMENT)
         if (WitSaeMgr::standAloneMode ())
            myMsgFac () ("lexObjElemCpuTimeMsg",
               WitTimer::getTimeAndChargeToCurrent ());

      prevOptVar = theOptVar;
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setObjCoef (WitOptVar * theOptVar, double theVal)
   {
   int    indices[1];
   double values [1];

   indices[0]  = theOptVar->index ();
   values [0]  = theVal;

   callCplex (
     "CPXchgobj",
      CPXchgobj (
         myCpxEnv_,
         myCpxLp_,
         1,
         indices,
         values));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::lockLexObjElemVal (WitOptVar * theOptVar)
   {
   int    theColIdx;
   double primalSoln[1];
   double optObjVal;
   double moTol;
   double theTol;
   int    indices[1];
   char   lu     [1];
   double bd     [1];

   theColIdx     = theOptVar->index ();

   callCplex (
     "CPXgetx",
      CPXgetx (
         myCpxEnv_,
         myCpxLp_,
         primalSoln,
         theColIdx, theColIdx));

   optObjVal     = primalSoln[0];

   moTol         = myOptComp ()->myMultiObjMgr ()->multiObjTol ();

   theTol        = WitNonClass::max (moTol * fabs (optObjVal), moTol);

   indices[0]    = theColIdx;
   lu     [0]    = 'L';
   bd     [0]    = optObjVal - theTol;

   callCplex (
     "CPXchgobj",
      CPXchgbds (
         myCpxEnv_,
         myCpxLp_,
         1,
         indices,
         lu,
         bd));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setLpMethodByOptStarter ()
   {
   if (myOptComp ()->crashOptStarter ()->isChosen ())
      {
      setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_DUAL);
      }
   else
      {
      setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveLp (bool optNeeded)
   {
   setSpecCpxPars ();

   callCplex (
     "CPXlpopt",
      CPXlpopt (
         myCpxEnv_,
         myCpxLp_));

   checkLpSolnStatus (optNeeded);

   printLpSolveInfo ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::loadInitSoln ()
   {
   WitVector <double> initSoln;
   WitOptVar *        theVar;
      
   if (not myOptComp ()->optInitMethod ()->external ())
      return;

   WitTimer::enterSection ("opt-prob");

   initSoln.resize (myOptProblem_->nOptVars (), 0.0);

   forEachEl (theVar, myOptProblem_->myOptVars ())
      initSoln[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("opt-prob");

   callCplex (
     "CPXcopystart",
      CPXcopystart (
         myCpxEnv_,
         myCpxLp_,
         NULL,
         NULL,
         initSoln.myCVec (),
         NULL,
         NULL,
         NULL));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::printLpSolveInfo ()
   {
   int nSimpItns;
   int nPh1Itns;

   nSimpItns = CPXgetitcnt     (myCpxEnv_, myCpxLp_);
   nPh1Itns  = CPXgetphase1cnt (myCpxEnv_, myCpxLp_);

   myMsgFac () ("lpSolveInfoMsg", nSimpItns, nPh1Itns);
   }

//------------------------------------------------------------------------------

void WitCplexMgr::checkLpSolnStatus (bool optNeeded)
   {
   storeCplexStatus ();

   switch (myOptComp ()->cplexStatusCode ())
      {
      case CPX_STAT_OPTIMAL:
         {
         myMsgFac () ("optSolnFoundMsg");

         return;
         }

      case CPX_STAT_INFEASIBLE:
         myMsgFac () ("infeasSmsg");

      case CPX_STAT_UNBOUNDED:
      case CPX_STAT_INForUNBD:
         myMsgFac () ("unboundedOrInfeasSmsg");

      case CPX_STAT_ABORT_IT_LIM:
      case CPX_STAT_ABORT_OBJ_LIM:
      case CPX_STAT_ABORT_TIME_LIM:
      case CPX_STAT_NUM_BEST:
      case CPX_STAT_OPTIMAL_INFEAS:
         {
         repEarlyTermLpSolnStatus (optNeeded);

         return;
         }

      default:
         issueStatusMsg ("unexpCpxStatSmsg");
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::repEarlyTermLpSolnStatus (bool optNeeded)
   {
   int primalFeas;

   callCplex (
     "CPXsolninfo",
      CPXsolninfo (
         myCpxEnv_,
         myCpxLp_,
         NULL,
         NULL,
       & primalFeas,
         NULL));

   if (not primalFeas)
      issueStatusMsg ("inFeasLpCpxStatSmsg");

   else if (optNeeded)
      issueStatusMsg ("nonOptLpCpxStatSmsg");

   else
      issueStatusMsg ("nonOptButFeasLpCpxStatWmsg");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveMip (bool optNeeded)
   {
   if (countIntVars () == 0)
      myMsgFac () ("mipModeNoIntVarsSmsg");

   setSpecCpxPars ();

   callCplex (
     "CPXmipopt",
      CPXmipopt (
         myCpxEnv_,
         myCpxLp_));

   checkMipSolnStatus (optNeeded);

   storeObjBoundInfo ();

   printMipSolveInfo ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::printMipSolveInfo ()
   {
   int    nSimpItns;
   int    nNodes;
   double percentGap;

   nSimpItns  = CPXgetmipitcnt (myCpxEnv_, myCpxLp_);
   nNodes     = CPXgetnodecnt  (myCpxEnv_, myCpxLp_);

   percentGap = myOptComp ()->cplexMipRelGap () * 100.0;

   myMsgFac () ("mipSolveInfoMsg",
      nSimpItns,
      nNodes,
      percentGap,
      myOptComp ()->cplexMipBound ());
   }

//------------------------------------------------------------------------------

void WitCplexMgr::checkMipSolnStatus (bool optNeeded)
   {
   storeCplexStatus ();

   switch (myOptComp ()->cplexStatusCode ())
      {
      case CPXMIP_OPTIMAL:
      case CPXMIP_OPTIMAL_TOL:
         {
         myMsgFac () ("optSolnFoundMsg");

         return;
         }

      case CPXMIP_INFEASIBLE:
         myMsgFac () ("infeasSmsg");

      case CPXMIP_UNBOUNDED:
      case CPXMIP_INForUNBD:
         myMsgFac () ("unboundedOrInfeasSmsg");

      case CPXMIP_ABORT_FEAS:
      case CPXMIP_FAIL_FEAS:
      case CPXMIP_FAIL_FEAS_NO_TREE:
      case CPXMIP_MEM_LIM_FEAS:
      case CPXMIP_NODE_LIM_FEAS:
      case CPXMIP_SOL_LIM:
      case CPXMIP_TIME_LIM_FEAS:
         {
         if (optNeeded)
            issueStatusMsg ("nonOptMipCpxStatSmsg");
         else
            issueStatusMsg ("nonOptButFeasMipCpxStatWmsg");

         return;
         }

      case CPXMIP_ABORT_INFEAS:
      case CPXMIP_FAIL_INFEAS:
      case CPXMIP_FAIL_INFEAS_NO_TREE:
      case CPXMIP_MEM_LIM_INFEAS:
      case CPXMIP_NODE_LIM_INFEAS:
      case CPXMIP_OPTIMAL_INFEAS:
      case CPXMIP_TIME_LIM_INFEAS:
         issueStatusMsg ("inFeasMipCpxStatSmsg");

      default:
         issueStatusMsg ("unexpCpxStatSmsg");
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::issueStatusMsg (WitMsgID theMsgID)
   {
   myMsgFac () (theMsgID,
      myOptComp ()->cplexStatusCode (),
      myOptComp ()->cplexStatusText ());
   }

//------------------------------------------------------------------------------

void WitCplexMgr::storePrimalSoln ()
   {
   WitVector <double> primalSoln;
   WitOptVar *        theVar;
   int                theIdx;

   primalSoln.resize (myOptProblem_->nOptVars ());

   callCplex (
     "CPXgetx",
      CPXgetx (
         myCpxEnv_,
         myCpxLp_,
         primalSoln.myCVecForUpdate (),
         0,
         myOptProblem_->nOptVars () - 1));


   WitTimer::enterSection ("opt-prob");

   forEachEl (theVar, myOptProblem_->myOptVars ())
      {
      theIdx = theVar->index ();

      theVar->setPrimalValue (primalSoln[theIdx]);
      }

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::storeDualSoln ()
   {
   WitVector <double> dualSoln;
   WitOptCon *        theCon;
   int                theIdx;

   dualSoln.resize (myOptProblem_->nOptCons ());

   callCplex (
     "CPXgetpi",
      CPXgetpi (
         myCpxEnv_,
         myCpxLp_,
         dualSoln.myCVecForUpdate (),
         0,
         myOptProblem_->nOptCons () - 1));

   WitTimer::enterSection ("opt-prob");

   forEachEl (theCon, myOptProblem_->myOptCons ())
      {
      theIdx = theCon->index ();

      theCon->setDualValue (dualSoln[theIdx]);
      }

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setSpecCpxPars ()
   {
   WitCpxParSpec * theCpxParSpec;

   forEachEl (theCpxParSpec, myOptComp ()->myCpxParSpecMgr ()->myCpxParSpecs ())
      {
      if (theCpxParSpec->valTypeIsInt ())
         setSpecIntCpxPar (theCpxParSpec);
      else
         setSpecDblCpxPar (theCpxParSpec);
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setSpecIntCpxPar (WitCpxParSpec * theCpxParSpec)
   {
   int theParamNum;

   theParamNum = findCpxParamNum (theCpxParSpec);

   checkCpxParamType (theCpxParSpec);

   callCplex (
     "CPXsetintparam",
      CPXsetintparam (
         myCpxEnv_,
         theParamNum,
         theCpxParSpec->myIntVal ()));

   myMsgFac () ("intCpxParSetMsg",
      theCpxParSpec->myName   (),
      theCpxParSpec->myIntVal ());
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setSpecDblCpxPar (WitCpxParSpec * theCpxParSpec)
   {
   int theParamNum;

   theParamNum = findCpxParamNum (theCpxParSpec);

   checkCpxParamType (theCpxParSpec);

   callCplex (
     "CPXsetdblparam",
      CPXsetdblparam (
         myCpxEnv_,
         theParamNum,
         theCpxParSpec->myDblVal ()));

   myMsgFac () ("dblCpxParSetMsg",
      theCpxParSpec->myName   (),
      theCpxParSpec->myDblVal ());
   }

//------------------------------------------------------------------------------

void WitCplexMgr::checkCpxParamType (WitCpxParSpec * theCpxParSpec)
   {
   int          theSpecType;
   const char * theSpecTypeText;
   int          theParamNum;
   int          theParamType;

   if (theCpxParSpec->valTypeIsInt ())
      {
      theSpecType     = CPX_PARAMTYPE_INT;
      theSpecTypeText = "Int";
      }
   else
      {
      theSpecType     = CPX_PARAMTYPE_DOUBLE;
      theSpecTypeText = "Double";
      }

   theParamNum = findCpxParamNum (theCpxParSpec);

   callCplex (
     "CPXgetparamtype",
      CPXgetparamtype (
         myCpxEnv_,
         theParamNum,
       & theParamType));

   if (theParamType != theSpecType)
      myMsgFac () ("wrongCpxParamTypeSmsg",
         theCpxParSpec->myName (),
         theSpecTypeText,
         theParamNum);
   }

//------------------------------------------------------------------------------

int WitCplexMgr::findCpxParamNum (WitCpxParSpec * theCpxParSpec)
   {
   int       theParamNameLen;
   WitString theParamName;
   int       theErrCode;
   int       theParamNum;

   theParamNameLen = theCpxParSpec->myName ().length () + 10;

   theParamName.resize (theParamNameLen);

   sprintf (
      theParamName.myCstringForUpdate (),
      "CPX_PARAM_%s",
      theCpxParSpec->myName ().myCstring ());

   theErrCode      =
      CPXgetparamnum (
         myCpxEnv_,
         theParamName.myCstring (),
       & theParamNum);

   if (theErrCode == CPXERR_BAD_PARAM_NAME)
      myMsgFac () ("badCpxParamNameSmsg", theCpxParSpec->myName ());

   checkErrCode (theErrCode, "getparamnum");

   return theParamNum;
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setIntParam (int theCpxParam, int theValue)
   {
   callCplex (
     "CPXsetintparam",
      CPXsetintparam (
         myCpxEnv_,
         theCpxParam,
         theValue));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::storeCplexStatus ()
   {
   int  theStatCode;
   char theStatText[57];

   theStatCode = CPXgetstat (myCpxEnv_, myCpxLp_);

   CPXgetstatstring (myCpxEnv_, theStatCode, theStatText);

   myOptComp ()->storeCplexStatusCode (theStatCode);
   myOptComp ()->storeCplexStatusText (theStatText);
   }

//------------------------------------------------------------------------------

void WitCplexMgr::storeObjBoundInfo ()
   {
   double theMipBound;
   double theMipRelGap;

   callCplex (
     "CPXgetbestobjval",
      CPXgetbestobjval (
         myCpxEnv_,
         myCpxLp_,
       & theMipBound));

   callCplex (
     "CPXgetmiprelgap",
      CPXgetmiprelgap (
         myCpxEnv_,
         myCpxLp_,
       & theMipRelGap));

   myOptComp ()->storeCplexMipBound  (theMipBound);
   myOptComp ()->storeCplexMipRelGap (theMipRelGap);
   }

//------------------------------------------------------------------------------

void WitCplexMgr::callCplex (const char * theFuncName, int theErrCode)
   {
   checkErrCode (theErrCode, theFuncName);
   }

//------------------------------------------------------------------------------

void WitCplexMgr::checkErrCode (int theErrCode, const char * theFuncName)
   {
   if (theErrCode == 0)
      return;

   char theErrStr[4096] = "                   Unknown CPLEX error\n";

   CPXgeterrorstring (myCpxEnv_, theErrCode, theErrStr);

   myMsgFac () ("nonZeroCplexErrCodeSmsg", theErrStr, theFuncName);
   }

//------------------------------------------------------------------------------

bool WitCplexMgr::mipMode ()
   {
   return myOptComp ()->mipMode ();
   }

//------------------------------------------------------------------------------

#endif // CPLEX_EMBEDDED
@


1.101
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.100
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d32 4
a35 4
myCplexMgr_ (NULL)
{
myCplexMgr_ = new WitCplexMgr (theOptProblem);
}
d40 3
a42 3
{
delete myCplexMgr_;
}
d47 3
a49 3
{
return true;
}
d54 3
a56 3
{
myCplexMgr_->solveOptProb ();
}
d67 3
a69 3
myCplexMgr_ (NULL)
{
}
d74 2
a75 2
{
}
d80 3
a82 3
{
return false;
}
d87 3
a89 3
{
stronglyAssert (false);
}
d120 7
a126 7
WitProbAssoc  (theOptProblem),
myOptProblem_ (theOptProblem),
myCpxEnv_     (NULL),
myCpxLp_      (NULL)
{
setUpCplex ();
}
d131 3
a133 3
{
shutDownCplex ();
}
d138 2
a139 2
{
WitTimer::enterSection ("cplex");
d141 16
a156 16
if      (myOptComp ()->multiObjMode ())
{
solveOptProbAsLexOpt ();
}
else if (myOptProblem_->reSolveMode ())
{
reSolveOptProbAsLp ();
}
else if (mipMode ())
{
solveOptProbAsMip ();
}
else
{
solveOptProbAsLp ();
}
d158 2
a159 2
WitTimer::leaveSection ("cplex");
}
d164 2
a165 2
{
int theErrCode;
d167 1
a167 1
myCpxEnv_ = CPXopenCPLEX (& theErrCode);
d169 1
a169 1
checkErrCode (theErrCode, "openCPLEX");
d171 1
a171 1
stronglyAssert (myCpxEnv_ != NULL);
d173 1
a173 1
//...........................................................................
d175 1
a175 1
setUpLogFile ();
d177 1
a177 1
//...........................................................................
d179 1
a179 1
myCpxLp_ = CPXcreateprob (myCpxEnv_, & theErrCode, "Implosion");
d181 1
a181 1
checkErrCode (theErrCode, "createprob");
d183 2
a184 2
stronglyAssert (myCpxLp_ != NULL);
}
d189 21
a209 21
{
const char * theFileName;
CPXFILEptr   theCpxFile;

theFileName = myOptComp ()->solverLogFileName ().myCstring ();

theCpxFile  = CPXfopen (theFileName, "w");

if (theCpxFile == NULL)
{
myMsgFac () ("cpxfopenSmsg", theFileName, "w");
}

//...........................................................................

callCplex (
"CPXsetlogfile",
CPXsetlogfile (
myCpxEnv_,
theCpxFile));
}
d214 18
a231 18
{
callCplex (
"CPXfreeprob",
CPXfreeprob (
myCpxEnv_,
& myCpxLp_));

//...........................................................................

shutDownLogFile ();

//...........................................................................

callCplex (
"CPXcloseCPLEX",
CPXcloseCPLEX (
& myCpxEnv_));
}
d236 2
a237 2
{
CPXFILEptr theCpxFile;
d239 21
a259 21
callCplex (
"CPXgetlogfile",
CPXgetlogfile (
myCpxEnv_,
& theCpxFile));

//...........................................................................

callCplex (
"CPXsetlogfile",
CPXsetlogfile (
myCpxEnv_,
NULL));

//...........................................................................

callCplex (
"CPXfclose",
CPXfclose (
theCpxFile));
}
d264 2
a265 2
{
myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("lpFrag"), "CPLEX");
d267 1
a267 1
loadLp ();
d269 1
a269 1
writeMps ();
d271 1
a271 1
setLpMethodByOptStarter ();
d273 1
a273 1
loadInitSoln ();
d275 1
a275 1
solveLp (myOptProblem_->needDual ());
d277 1
a277 1
storePrimalSoln ();
d279 3
a281 3
if (myOptProblem_->needDual ())
storeDualSoln ();
}
d286 2
a287 2
{
myMsgFac () ("reSolveLpMsg", "CPLEX");
d289 1
a289 1
reviseLp ();
d291 1
a291 1
writeMps ();
d293 1
a293 1
setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_DUAL);
d295 1
a295 1
solveLp (myOptProblem_->needDual ());
d297 1
a297 1
storePrimalSoln ();
d299 3
a301 3
if (myOptProblem_->needDual ())
storeDualSoln ();
}
d306 2
a307 2
{
myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("mipFrag"), "CPLEX");
d309 1
a309 1
loadLp ();
d311 1
a311 1
loadIntData ();
d313 1
a313 1
writeMps ();
d315 1
a315 1
solveMip (false);
d317 2
a318 2
storePrimalSoln ();
}
d323 4
a326 4
{
myMsgFac () ("solveOptProblemMsg",
myMsgFac ().myFrag (mipMode ()? "mipFrag": "lpFrag"),
"CPLEX");
d328 1
a328 1
myMsgFac () ("lexOptMsg");
d330 1
a330 1
loadLp ();
d332 2
a333 2
if (mipMode ())
loadIntData ();
d335 1
a335 1
writeMps ();
d337 1
a337 1
solveLexOpt ();
d339 2
a340 2
storePrimalSoln ();
}
d345 33
a377 33
{
WitVector <double> objective;
WitVector <double> rhs;
WitVector <char>   sense;
WitVector <int>    matbeg;
WitVector <int>    matcnt;
WitVector <int>    matind;
WitVector <double> matval;
WitVector <double> lb;
WitVector <double> ub;

getRowData    (rhs,       sense);
getColumnData (objective, matbeg, matcnt, matind, matval, lb, ub);

callCplex (
"CPXcopylp",
CPXcopylp (
myCpxEnv_,
myCpxLp_,
myOptProblem_->nOptVars (),
myOptProblem_->nOptCons (),
-1,
objective.myCVec (),
rhs      .myCVec (),
sense    .myCVec (),
matbeg   .myCVec (),
matcnt   .myCVec (),
matind   .myCVec (),
matval   .myCVec (),
lb       .myCVec (),
ub       .myCVec (),
NULL));
}
d382 14
a395 14
WitVector <double> & rhs,
WitVector <char> &   sense)
{
WitOptCon * theOptCon;
int         theIdx;

WitTimer::enterSection ("opt-prob");

rhs  .resize (myOptProblem_->nOptCons ());
sense.resize (myOptProblem_->nOptCons ());

forEachEl (theOptCon, myOptProblem_->myOptCons ())
{
theIdx = theOptCon->index ();
d397 2
a398 2
getConData (rhs[theIdx], sense[theIdx], theOptCon);
}
d400 2
a401 2
WitTimer::leaveSection ("opt-prob");
}
d406 34
a439 34
WitVector <double> & objective,
WitVector <int> &    matbeg,
WitVector <int> &    matcnt,
WitVector <int> &    matind,
WitVector <double> & matval,
WitVector <double> & lb,
WitVector <double> & ub)
{
int         ncols;
WitOptVar * theOptVar;
int         theIdx;

WitTimer::enterSection ("opt-prob");

ncols = myOptProblem_->nOptVars ();

objective.resize (ncols);
matcnt   .resize (ncols);
lb       .resize (ncols);
ub       .resize (ncols);

myOptProblem_->getMatrixByCols (matbeg, matind, matval);

forEachEl (theOptVar, myOptProblem_->myOptVars ())
{
theIdx            = theOptVar->index ();

objective[theIdx] = theOptVar->objCoeff ();

matcnt[theIdx]    = matbeg[theIdx + 1] - matbeg[theIdx];

lb[theIdx]        = theOptVar->bounds ().lower ();
ub[theIdx]        = theOptVar->bounds ().upper ();
}
d441 2
a442 2
WitTimer::leaveSection ("opt-prob");
}
d447 5
a451 5
{
reviseBounds    ();
reviseRHS       ();
reviseObjCoeffs ();
}
d456 58
a513 58
{
int                cnt;
WitVector <int>    indices;
WitVector <char>   lu;
WitVector <double> bd;
WitOptVar *        theOptVar;
int                theColIdx;

WitTimer::enterSection ("opt-prob");

cnt = myOptProblem_->nOptVars ();

indices.resize (cnt);
lu     .resize (cnt);
bd     .resize (cnt);

theColIdx = -1;

forEachEl (theOptVar, myOptProblem_->myOptVars ())
{
theColIdx ++;

witAssert (theColIdx == theOptVar->index ());

indices[theColIdx] = theColIdx;
lu     [theColIdx] = 'L';
bd     [theColIdx] = theOptVar->bounds ().lower ();
}

callCplex (
"CPXchgobj",
CPXchgbds (
myCpxEnv_,
myCpxLp_,
cnt,
indices.myCVec (),
lu     .myCVec (),
bd     .myCVec ()));

theColIdx = -1;

forEachEl (theOptVar, myOptProblem_->myOptVars ())
{
theColIdx ++;

lu[theColIdx] = 'U';
bd[theColIdx] = theOptVar->bounds ().upper ();
}

callCplex (
"CPXchgobj",
CPXchgbds (
myCpxEnv_,
myCpxLp_,
cnt,
indices.myCVec (),
lu     .myCVec (),
bd     .myCVec ()));
d515 2
a516 2
WitTimer::leaveSection ("opt-prob");
}
d521 7
a527 7
{
int                cnt;
WitVector <int>    indices;
WitVector <double> values;
WitOptCon *        theOptCon;
int                theRowIdx;
char               sense;
d529 1
a529 1
WitTimer::enterSection ("opt-prob");
d531 1
a531 1
cnt = myOptProblem_->nOptCons ();
d533 2
a534 2
indices.resize (cnt);
values .resize (cnt);
d536 1
a536 1
theRowIdx = -1;
d538 3
a540 3
forEachEl (theOptCon, myOptProblem_->myOptCons ())
{
theRowIdx ++;
d542 1
a542 1
witAssert (theRowIdx == theOptCon->index ());
d544 1
a544 1
indices[theRowIdx] = theRowIdx;
d546 2
a547 2
getConData (values[theRowIdx], sense, theOptCon);
}
d549 8
a556 8
callCplex (
"CPXchgrhs",
CPXchgrhs (
myCpxEnv_,
myCpxLp_,
cnt,
indices.myCVec (),
values .myCVec ()));
d558 2
a559 2
WitTimer::leaveSection ("opt-prob");
}
d564 27
a590 27
{
double theLB;
double theUB;

theLB  = theOptCon->bounds ().lower ();
theUB  = theOptCon->bounds ().upper ();

if (theLB == theUB)
{
rhs   = theLB;
sense = 'E';
}
else if (theUB == + DBL_MAX)
{
rhs   = theLB;
sense = 'G';
}
else if (theLB == - DBL_MAX)
{
rhs   = theUB;
sense = 'L';
}
else
{
stronglyAssert (false);
}
}
d595 34
a628 34
{
int                cnt;
WitVector <int>    indices;
WitVector <double> values;
WitOptVar *        theOptVar;
int                theColIdx;

WitTimer::enterSection ("opt-prob");

cnt = myOptProblem_->nOptVars ();

indices.resize (cnt);
values .resize (cnt);

theColIdx = -1;

forEachEl (theOptVar, myOptProblem_->myOptVars ())
{
theColIdx ++;

witAssert (theColIdx == theOptVar->index ());

indices[theColIdx] = theColIdx;
values [theColIdx] = theOptVar->objCoeff ();
}

callCplex (
"CPXchgobj",
CPXchgobj (
myCpxEnv_,
myCpxLp_,
cnt,
indices.myCVec (),
values .myCVec ()));
d630 2
a631 2
WitTimer::leaveSection ("opt-prob");
}
d636 37
a672 37
{
int              nIntVars;
WitVector <int>  theIndices;
WitVector <char> theTypeChars;
int              theIdx;
WitOptVar *      theOptVar;

WitTimer::enterSection ("opt-prob");

nIntVars = countIntVars ();

theIndices  .resize (nIntVars);
theTypeChars.resize (nIntVars, 'I');

theIdx = -1;

forEachEl (theOptVar, myOptProblem_->myOptVars ())
{
if (theOptVar->isAnIntVar ())
{
theIdx ++;

theIndices[theIdx] = theOptVar->index ();
}
}

WitTimer::leaveSection ("opt-prob");

callCplex (
"CPXchgctype",
CPXchgctype (
myCpxEnv_,
myCpxLp_,
nIntVars,
theIndices  .myCVec (),
theTypeChars.myCVec ()));
}
d677 3
a679 3
{
int         nIntVars;
WitOptVar * theOptVar;
d681 1
a681 1
WitTimer::enterSection ("opt-prob");
d683 1
a683 1
nIntVars = 0;
d685 5
a689 5
forEachEl (theOptVar, myOptProblem_->myOptVars ())
{
if (theOptVar->isAnIntVar ())
nIntVars ++;
}
d691 1
a691 1
WitTimer::leaveSection ("opt-prob");
d693 2
a694 2
return nIntVars;
}
d699 14
a712 14
{
if (myOptComp ()->printMps ())
{
myMsgFac () ("mpsFileMsg");

callCplex (
"CPXwriteprob",
CPXwriteprob (
myCpxEnv_,
myCpxLp_,
"opt-prob.mps",
NULL));
}
}
d717 50
a766 50
{
WitOptVar *              prevOptVar;
WitPtrVecItr <WitOptVar> theOptVarItr;
WitOptVar *              theOptVar;

if (DEVELOPMENT)
WitTimer::getTimeAndChargeToCurrent ();

if (not mipMode ())
loadInitSoln ();

prevOptVar = NULL;

myOptProblem_->myLexOptVarSeq ().attachItr (theOptVarItr);

while (theOptVarItr.advance (theOptVar))
{
myMsgFac () ("optLexObjElemMsg", theOptVar->lexObjElemName ());

if (prevOptVar != NULL)
{
lockLexObjElemVal (prevOptVar);

setObjCoef (prevOptVar, 0.0);
}

setObjCoef (theOptVar, 1.0);

if (mipMode ())
{
solveMip (true);
}
else
{
if (prevOptVar != NULL)
setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
else
setLpMethodByOptStarter ();

solveLp (true);
}

if (DEVELOPMENT)
if (WitSaeMgr::standAloneMode ())
myMsgFac () ("lexObjElemCpuTimeMsg",
WitTimer::getTimeAndChargeToCurrent ());

prevOptVar = theOptVar;
}
}
d771 16
a786 16
{
int    indices[1];
double values [1];

indices[0]  = theOptVar->index ();
values [0]  = theVal;

callCplex (
"CPXchgobj",
CPXchgobj (
myCpxEnv_,
myCpxLp_,
1,
indices,
values));
}
d791 40
a830 40
{
int    theColIdx;
double primalSoln[1];
double optObjVal;
double moTol;
double theTol;
int    indices[1];
char   lu     [1];
double bd     [1];

theColIdx     = theOptVar->index ();

callCplex (
"CPXgetx",
CPXgetx (
myCpxEnv_,
myCpxLp_,
primalSoln,
theColIdx, theColIdx));

optObjVal     = primalSoln[0];

moTol         = myOptComp ()->myMultiObjMgr ()->multiObjTol ();

theTol        = WitNonClass::max (moTol * fabs (optObjVal), moTol);

indices[0]    = theColIdx;
lu     [0]    = 'L';
bd     [0]    = optObjVal - theTol;

callCplex (
"CPXchgobj",
CPXchgbds (
myCpxEnv_,
myCpxLp_,
1,
indices,
lu,
bd));
}
d835 10
a844 10
{
if (myOptComp ()->crashOptStarter ()->isChosen ())
{
setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_DUAL);
}
else
{
setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
}
}
d849 2
a850 2
{
setSpecCpxPars ();
d852 5
a856 5
callCplex (
"CPXlpopt",
CPXlpopt (
myCpxEnv_,
myCpxLp_));
d858 1
a858 1
checkLpSolnStatus (optNeeded);
d860 2
a861 2
printLpSolveInfo ();
}
d866 28
a893 28
{
WitVector <double> initSoln;
WitOptVar *        theVar;

if (not myOptComp ()->optInitMethod ()->external ())
return;

WitTimer::enterSection ("opt-prob");

initSoln.resize (myOptProblem_->nOptVars (), 0.0);

forEachEl (theVar, myOptProblem_->myOptVars ())
initSoln[theVar->index ()] = theVar->primalValue ();

WitTimer::leaveSection ("opt-prob");

callCplex (
"CPXcopystart",
CPXcopystart (
myCpxEnv_,
myCpxLp_,
NULL,
NULL,
initSoln.myCVec (),
NULL,
NULL,
NULL));
}
d898 3
a900 3
{
int nSimpItns;
int nPh1Itns;
d902 2
a903 2
nSimpItns = CPXgetitcnt     (myCpxEnv_, myCpxLp_);
nPh1Itns  = CPXgetphase1cnt (myCpxEnv_, myCpxLp_);
d905 2
a906 2
myMsgFac () ("lpSolveInfoMsg", nSimpItns, nPh1Itns);
}
d911 2
a912 2
{
storeCplexStatus ();
d914 31
a944 31
switch (myOptComp ()->cplexStatusCode ())
{
case CPX_STAT_OPTIMAL:
{
myMsgFac () ("optSolnFoundMsg");

return;
}

case CPX_STAT_INFEASIBLE:
myMsgFac () ("infeasSmsg");

case CPX_STAT_UNBOUNDED:
case CPX_STAT_INForUNBD:
myMsgFac () ("unboundedOrInfeasSmsg");

case CPX_STAT_ABORT_IT_LIM:
case CPX_STAT_ABORT_OBJ_LIM:
case CPX_STAT_ABORT_TIME_LIM:
case CPX_STAT_NUM_BEST:
case CPX_STAT_OPTIMAL_INFEAS:
{
repEarlyTermLpSolnStatus (optNeeded);

return;
}

default:
issueStatusMsg ("unexpCpxStatSmsg");
}
}
d949 2
a950 2
{
int primalFeas;
d952 19
a970 19
callCplex (
"CPXsolninfo",
CPXsolninfo (
myCpxEnv_,
myCpxLp_,
NULL,
NULL,
& primalFeas,
NULL));

if (not primalFeas)
issueStatusMsg ("inFeasLpCpxStatSmsg");

else if (optNeeded)
issueStatusMsg ("nonOptLpCpxStatSmsg");

else
issueStatusMsg ("nonOptButFeasLpCpxStatWmsg");
}
d975 3
a977 3
{
if (countIntVars () == 0)
myMsgFac () ("mipModeNoIntVarsSmsg");
d979 1
a979 1
setSpecCpxPars ();
d981 5
a985 5
callCplex (
"CPXmipopt",
CPXmipopt (
myCpxEnv_,
myCpxLp_));
d987 1
a987 1
checkMipSolnStatus (optNeeded);
d989 1
a989 1
storeObjBoundInfo ();
d991 2
a992 2
printMipSolveInfo ();
}
d997 16
a1012 16
{
int    nSimpItns;
int    nNodes;
double percentGap;

nSimpItns  = CPXgetmipitcnt (myCpxEnv_, myCpxLp_);
nNodes     = CPXgetnodecnt  (myCpxEnv_, myCpxLp_);

percentGap = myOptComp ()->cplexMipRelGap () * 100.0;

myMsgFac () ("mipSolveInfoMsg",
nSimpItns,
nNodes,
percentGap,
myOptComp ()->cplexMipBound ());
}
d1017 2
a1018 2
{
storeCplexStatus ();
d1020 46
a1065 46
switch (myOptComp ()->cplexStatusCode ())
{
case CPXMIP_OPTIMAL:
case CPXMIP_OPTIMAL_TOL:
{
myMsgFac () ("optSolnFoundMsg");

return;
}

case CPXMIP_INFEASIBLE:
myMsgFac () ("infeasSmsg");

case CPXMIP_UNBOUNDED:
case CPXMIP_INForUNBD:
myMsgFac () ("unboundedOrInfeasSmsg");

case CPXMIP_ABORT_FEAS:
case CPXMIP_FAIL_FEAS:
case CPXMIP_FAIL_FEAS_NO_TREE:
case CPXMIP_MEM_LIM_FEAS:
case CPXMIP_NODE_LIM_FEAS:
case CPXMIP_SOL_LIM:
case CPXMIP_TIME_LIM_FEAS:
{
if (optNeeded)
issueStatusMsg ("nonOptMipCpxStatSmsg");
else
issueStatusMsg ("nonOptButFeasMipCpxStatWmsg");

return;
}

case CPXMIP_ABORT_INFEAS:
case CPXMIP_FAIL_INFEAS:
case CPXMIP_FAIL_INFEAS_NO_TREE:
case CPXMIP_MEM_LIM_INFEAS:
case CPXMIP_NODE_LIM_INFEAS:
case CPXMIP_OPTIMAL_INFEAS:
case CPXMIP_TIME_LIM_INFEAS:
issueStatusMsg ("inFeasMipCpxStatSmsg");

default:
issueStatusMsg ("unexpCpxStatSmsg");
}
}
d1070 5
a1074 5
{
myMsgFac () (theMsgID,
myOptComp ()->cplexStatusCode (),
myOptComp ()->cplexStatusText ());
}
d1079 22
a1100 22
{
WitVector <double> primalSoln;
WitOptVar *        theVar;
int                theIdx;

primalSoln.resize (myOptProblem_->nOptVars ());

callCplex (
"CPXgetx",
CPXgetx (
myCpxEnv_,
myCpxLp_,
primalSoln.myCVecForUpdate (),
0,
myOptProblem_->nOptVars () - 1));


WitTimer::enterSection ("opt-prob");

forEachEl (theVar, myOptProblem_->myOptVars ())
{
theIdx = theVar->index ();
d1102 2
a1103 2
theVar->setPrimalValue (primalSoln[theIdx]);
}
d1105 2
a1106 2
WitTimer::leaveSection ("opt-prob");
}
d1111 21
a1131 21
{
WitVector <double> dualSoln;
WitOptCon *        theCon;
int                theIdx;

dualSoln.resize (myOptProblem_->nOptCons ());

callCplex (
"CPXgetpi",
CPXgetpi (
myCpxEnv_,
myCpxLp_,
dualSoln.myCVecForUpdate (),
0,
myOptProblem_->nOptCons () - 1));

WitTimer::enterSection ("opt-prob");

forEachEl (theCon, myOptProblem_->myOptCons ())
{
theIdx = theCon->index ();
d1133 2
a1134 2
theCon->setDualValue (dualSoln[theIdx]);
}
d1136 2
a1137 2
WitTimer::leaveSection ("opt-prob");
}
d1142 2
a1143 2
{
WitCpxParSpec * theCpxParSpec;
d1145 8
a1152 8
forEachEl (theCpxParSpec, myOptComp ()->myCpxParSpecMgr ()->myCpxParSpecs ())
{
if (theCpxParSpec->valTypeIsInt ())
setSpecIntCpxPar (theCpxParSpec);
else
setSpecDblCpxPar (theCpxParSpec);
}
}
d1157 2
a1158 2
{
int theParamNum;
d1160 1
a1160 1
theParamNum = findCpxParamNum (theCpxParSpec);
d1162 1
a1162 1
checkCpxParamType (theCpxParSpec);
d1164 11
a1174 11
callCplex (
"CPXsetintparam",
CPXsetintparam (
myCpxEnv_,
theParamNum,
theCpxParSpec->myIntVal ()));

myMsgFac () ("intCpxParSetMsg",
theCpxParSpec->myName   (),
theCpxParSpec->myIntVal ());
}
d1179 2
a1180 2
{
int theParamNum;
d1182 1
a1182 1
theParamNum = findCpxParamNum (theCpxParSpec);
d1184 1
a1184 1
checkCpxParamType (theCpxParSpec);
d1186 11
a1196 11
callCplex (
"CPXsetdblparam",
CPXsetdblparam (
myCpxEnv_,
theParamNum,
theCpxParSpec->myDblVal ()));

myMsgFac () ("dblCpxParSetMsg",
theCpxParSpec->myName   (),
theCpxParSpec->myDblVal ());
}
d1201 32
a1232 32
{
int          theSpecType;
const char * theSpecTypeText;
int          theParamNum;
int          theParamType;

if (theCpxParSpec->valTypeIsInt ())
{
theSpecType     = CPX_PARAMTYPE_INT;
theSpecTypeText = "Int";
}
else
{
theSpecType     = CPX_PARAMTYPE_DOUBLE;
theSpecTypeText = "Double";
}

theParamNum = findCpxParamNum (theCpxParSpec);

callCplex (
"CPXgetparamtype",
CPXgetparamtype (
myCpxEnv_,
theParamNum,
& theParamType));

if (theParamType != theSpecType)
myMsgFac () ("wrongCpxParamTypeSmsg",
theCpxParSpec->myName (),
theSpecTypeText,
theParamNum);
}
d1237 20
a1256 20
{
int       theParamNameLen;
WitString theParamName;
int       theErrCode;
int       theParamNum;

theParamNameLen = theCpxParSpec->myName ().length () + 10;

theParamName.resize (theParamNameLen);

sprintf (
theParamName.myCstringForUpdate (),
"CPX_PARAM_%s",
theCpxParSpec->myName ().myCstring ());

theErrCode      =
CPXgetparamnum (
myCpxEnv_,
theParamName.myCstring (),
& theParamNum);
d1258 2
a1259 2
if (theErrCode == CPXERR_BAD_PARAM_NAME)
myMsgFac () ("badCpxParamNameSmsg", theCpxParSpec->myName ());
d1261 1
a1261 1
checkErrCode (theErrCode, "getparamnum");
d1263 2
a1264 2
return theParamNum;
}
d1269 8
a1276 8
{
callCplex (
"CPXsetintparam",
CPXsetintparam (
myCpxEnv_,
theCpxParam,
theValue));
}
d1281 3
a1283 3
{
int  theStatCode;
char theStatText[57];
d1285 1
a1285 1
theStatCode = CPXgetstat (myCpxEnv_, myCpxLp_);
d1287 1
a1287 1
CPXgetstatstring (myCpxEnv_, theStatCode, theStatText);
d1289 3
a1291 3
myOptComp ()->storeCplexStatusCode (theStatCode);
myOptComp ()->storeCplexStatusText (theStatText);
}
d1296 21
a1316 21
{
double theMipBound;
double theMipRelGap;

callCplex (
"CPXgetbestobjval",
CPXgetbestobjval (
myCpxEnv_,
myCpxLp_,
& theMipBound));

callCplex (
"CPXgetmiprelgap",
CPXgetmiprelgap (
myCpxEnv_,
myCpxLp_,
& theMipRelGap));

myOptComp ()->storeCplexMipBound  (theMipBound);
myOptComp ()->storeCplexMipRelGap (theMipRelGap);
}
d1321 3
a1323 3
{
checkErrCode (theErrCode, theFuncName);
}
d1328 3
a1330 3
{
if (theErrCode == 0)
return;
d1332 1
a1332 1
char theErrStr[4096] = "                   Unknown CPLEX error\n";
d1334 1
a1334 1
CPXgeterrorstring (myCpxEnv_, theErrCode, theErrStr);
d1336 2
a1337 2
myMsgFac () ("nonZeroCplexErrCodeSmsg", theErrStr, theFuncName);
}
d1342 3
a1344 3
{
return myOptComp ()->mipMode ();
}
@


1.99
log
@Replaced class SolverMgr with class CplexGateway.
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d32 4
a35 4
      myCplexMgr_ (NULL)
   {
   myCplexMgr_ = new WitCplexMgr (theOptProblem);
   }
d40 3
a42 3
   {
   delete myCplexMgr_;
   }
d47 3
a49 3
   {
   return true;
   }
d54 3
a56 3
   {
   myCplexMgr_->solveOptProb ();
   }
d67 3
a69 3
      myCplexMgr_ (NULL)
   {
   }
d74 2
a75 2
   {
   }
d80 3
a82 3
   {
   return false;
   }
d87 3
a89 3
   {
   stronglyAssert (false);
   }
d120 7
a126 7
      WitProbAssoc  (theOptProblem),
      myOptProblem_ (theOptProblem),
      myCpxEnv_     (NULL),
      myCpxLp_      (NULL)
   {
   setUpCplex ();
   }
d131 3
a133 3
   {
   shutDownCplex ();
   }
d138 2
a139 2
   {
   WitTimer::enterSection ("cplex");
d141 16
a156 16
   if      (myOptComp ()->multiObjMode ())
      {
      solveOptProbAsLexOpt ();
      }
   else if (myOptProblem_->reSolveMode ())
      {
      reSolveOptProbAsLp ();
      }
   else if (mipMode ())
      {
      solveOptProbAsMip ();
      }
   else
      {
      solveOptProbAsLp ();
      }
d158 2
a159 2
   WitTimer::leaveSection ("cplex");
   }
d164 2
a165 2
   {
   int theErrCode;
d167 1
a167 1
   myCpxEnv_ = CPXopenCPLEX (& theErrCode);
d169 1
a169 1
   checkErrCode (theErrCode, "openCPLEX");
d171 1
a171 1
   stronglyAssert (myCpxEnv_ != NULL);
d173 1
a173 1
   //...........................................................................
d175 1
a175 1
   setUpLogFile ();
d177 1
a177 1
   //...........................................................................
d179 1
a179 1
   myCpxLp_ = CPXcreateprob (myCpxEnv_, & theErrCode, "Implosion");
d181 1
a181 1
   checkErrCode (theErrCode, "createprob");
d183 2
a184 2
   stronglyAssert (myCpxLp_ != NULL);
   }
d189 21
a209 21
   {
   const char * theFileName;
   CPXFILEptr   theCpxFile;

   theFileName = myOptComp ()->solverLogFileName ().myCstring ();

   theCpxFile  = CPXfopen (theFileName, "w");

   if (theCpxFile == NULL)
      {
      myMsgFac () ("cpxfopenSmsg", theFileName, "w");
      }

   //...........................................................................

   callCplex (
     "CPXsetlogfile",
      CPXsetlogfile (
         myCpxEnv_,
         theCpxFile));
   }
d214 18
a231 18
   {
   callCplex (
     "CPXfreeprob",
      CPXfreeprob (
         myCpxEnv_,
       & myCpxLp_));

   //...........................................................................

   shutDownLogFile ();

   //...........................................................................

   callCplex (
     "CPXcloseCPLEX",
      CPXcloseCPLEX (
       & myCpxEnv_));
   }
d236 2
a237 2
   {
   CPXFILEptr theCpxFile;
d239 21
a259 21
   callCplex (
     "CPXgetlogfile",
      CPXgetlogfile (
         myCpxEnv_,
       & theCpxFile));

   //...........................................................................

   callCplex (
     "CPXsetlogfile",
      CPXsetlogfile (
         myCpxEnv_,
         NULL));

   //...........................................................................

   callCplex (
     "CPXfclose",
      CPXfclose (
         theCpxFile));
   }
d264 2
a265 2
   {
   myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("lpFrag"), "CPLEX");
d267 1
a267 1
   loadLp ();
d269 1
a269 1
   writeMps ();
d271 1
a271 1
   setLpMethodByOptStarter ();
d273 1
a273 1
   loadInitSoln ();
d275 1
a275 1
   solveLp (myOptProblem_->needDual ());
d277 1
a277 1
   storePrimalSoln ();
d279 3
a281 3
   if (myOptProblem_->needDual ())
      storeDualSoln ();
   }
d286 2
a287 2
   {
   myMsgFac () ("reSolveLpMsg", "CPLEX");
d289 1
a289 1
   reviseLp ();
d291 1
a291 1
   writeMps ();
d293 1
a293 1
   setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_DUAL);
d295 1
a295 1
   solveLp (myOptProblem_->needDual ());
d297 1
a297 1
   storePrimalSoln ();
d299 3
a301 3
   if (myOptProblem_->needDual ())
      storeDualSoln ();
   }
d306 2
a307 2
   {
   myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("mipFrag"), "CPLEX");
d309 1
a309 1
   loadLp ();
d311 1
a311 1
   loadIntData ();
d313 1
a313 1
   writeMps ();
d315 1
a315 1
   solveMip (false);
d317 2
a318 2
   storePrimalSoln ();
   }
d323 4
a326 4
   {
   myMsgFac () ("solveOptProblemMsg",
      myMsgFac ().myFrag (mipMode ()? "mipFrag": "lpFrag"),
      "CPLEX");
d328 1
a328 1
   myMsgFac () ("lexOptMsg");
d330 1
a330 1
   loadLp ();
d332 2
a333 2
   if (mipMode ())
      loadIntData ();
d335 1
a335 1
   writeMps ();
d337 1
a337 1
   solveLexOpt ();
d339 2
a340 2
   storePrimalSoln ();
   }
d345 33
a377 33
   {
   WitVector <double> objective;
   WitVector <double> rhs;
   WitVector <char>   sense;
   WitVector <int>    matbeg;
   WitVector <int>    matcnt;
   WitVector <int>    matind;
   WitVector <double> matval;
   WitVector <double> lb;
   WitVector <double> ub;

   getRowData    (rhs,       sense);
   getColumnData (objective, matbeg, matcnt, matind, matval, lb, ub);

   callCplex (
     "CPXcopylp",
      CPXcopylp (
         myCpxEnv_,
         myCpxLp_,
         myOptProblem_->nOptVars (),
         myOptProblem_->nOptCons (),
         -1,
         objective.myCVec (),
         rhs      .myCVec (),
         sense    .myCVec (),
         matbeg   .myCVec (),
         matcnt   .myCVec (),
         matind   .myCVec (),
         matval   .myCVec (),
         lb       .myCVec (),
         ub       .myCVec (),
         NULL));
   }
d382 14
a395 14
      WitVector <double> & rhs,
      WitVector <char> &   sense)
   {
   WitOptCon * theOptCon;
   int         theIdx;

   WitTimer::enterSection ("opt-prob");

   rhs  .resize (myOptProblem_->nOptCons ());
   sense.resize (myOptProblem_->nOptCons ());

   forEachEl (theOptCon, myOptProblem_->myOptCons ())
      {
      theIdx = theOptCon->index ();
d397 2
a398 2
      getConData (rhs[theIdx], sense[theIdx], theOptCon);
      }
d400 2
a401 2
   WitTimer::leaveSection ("opt-prob");
   }
d406 34
a439 34
      WitVector <double> & objective,
      WitVector <int> &    matbeg,
      WitVector <int> &    matcnt,
      WitVector <int> &    matind,
      WitVector <double> & matval,
      WitVector <double> & lb,
      WitVector <double> & ub)
   {
   int         ncols;
   WitOptVar * theOptVar;
   int         theIdx;

   WitTimer::enterSection ("opt-prob");

   ncols = myOptProblem_->nOptVars ();

   objective.resize (ncols);
   matcnt   .resize (ncols);
   lb       .resize (ncols);
   ub       .resize (ncols);

   myOptProblem_->getMatrixByCols (matbeg, matind, matval);

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      theIdx            = theOptVar->index ();

      objective[theIdx] = theOptVar->objCoeff ();

      matcnt[theIdx]    = matbeg[theIdx + 1] - matbeg[theIdx];

      lb[theIdx]        = theOptVar->bounds ().lower ();
      ub[theIdx]        = theOptVar->bounds ().upper ();
      }
d441 2
a442 2
   WitTimer::leaveSection ("opt-prob");
   }
d447 5
a451 5
   {
   reviseBounds    ();
   reviseRHS       ();
   reviseObjCoeffs ();
   }
d456 58
a513 58
   {
   int                cnt;
   WitVector <int>    indices;
   WitVector <char>   lu;
   WitVector <double> bd;
   WitOptVar *        theOptVar;
   int                theColIdx;

   WitTimer::enterSection ("opt-prob");

   cnt = myOptProblem_->nOptVars ();

   indices.resize (cnt);
   lu     .resize (cnt);
   bd     .resize (cnt);

   theColIdx = -1;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      theColIdx ++;

      witAssert (theColIdx == theOptVar->index ());

      indices[theColIdx] = theColIdx;
      lu     [theColIdx] = 'L';
      bd     [theColIdx] = theOptVar->bounds ().lower ();
      }

   callCplex (
     "CPXchgobj",
      CPXchgbds (
         myCpxEnv_,
         myCpxLp_,
         cnt,
         indices.myCVec (),
         lu     .myCVec (),
         bd     .myCVec ()));

   theColIdx = -1;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      theColIdx ++;

      lu[theColIdx] = 'U';
      bd[theColIdx] = theOptVar->bounds ().upper ();
      }

   callCplex (
     "CPXchgobj",
      CPXchgbds (
         myCpxEnv_,
         myCpxLp_,
         cnt,
         indices.myCVec (),
         lu     .myCVec (),
         bd     .myCVec ()));
d515 2
a516 2
   WitTimer::leaveSection ("opt-prob");
   }
d521 7
a527 7
   {
   int                cnt;
   WitVector <int>    indices;
   WitVector <double> values;
   WitOptCon *        theOptCon;
   int                theRowIdx;
   char               sense;
d529 1
a529 1
   WitTimer::enterSection ("opt-prob");
d531 1
a531 1
   cnt = myOptProblem_->nOptCons ();
d533 2
a534 2
   indices.resize (cnt);
   values .resize (cnt);
d536 1
a536 1
   theRowIdx = -1;
d538 3
a540 3
   forEachEl (theOptCon, myOptProblem_->myOptCons ())
      {
      theRowIdx ++;
d542 1
a542 1
      witAssert (theRowIdx == theOptCon->index ());
d544 1
a544 1
      indices[theRowIdx] = theRowIdx;
d546 2
a547 2
      getConData (values[theRowIdx], sense, theOptCon);
      }
d549 8
a556 8
   callCplex (
     "CPXchgrhs",
      CPXchgrhs (
         myCpxEnv_,
         myCpxLp_,
         cnt,
         indices.myCVec (),
         values .myCVec ()));
d558 2
a559 2
   WitTimer::leaveSection ("opt-prob");
   }
d564 27
a590 27
   {
   double theLB;
   double theUB;

   theLB  = theOptCon->bounds ().lower ();
   theUB  = theOptCon->bounds ().upper ();

   if (theLB == theUB)
      {
      rhs   = theLB;
      sense = 'E';
      }
   else if (theUB == + DBL_MAX)
      {
      rhs   = theLB;
      sense = 'G';
      }
   else if (theLB == - DBL_MAX)
      {
      rhs   = theUB;
      sense = 'L';
      }
   else
      {
      stronglyAssert (false);
      }
   }
d595 34
a628 34
   {
   int                cnt;
   WitVector <int>    indices;
   WitVector <double> values;
   WitOptVar *        theOptVar;
   int                theColIdx;

   WitTimer::enterSection ("opt-prob");

   cnt = myOptProblem_->nOptVars ();

   indices.resize (cnt);
   values .resize (cnt);

   theColIdx = -1;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      theColIdx ++;

      witAssert (theColIdx == theOptVar->index ());

      indices[theColIdx] = theColIdx;
      values [theColIdx] = theOptVar->objCoeff ();
      }

   callCplex (
     "CPXchgobj",
      CPXchgobj (
         myCpxEnv_,
         myCpxLp_,
         cnt,
         indices.myCVec (),
         values .myCVec ()));
d630 2
a631 2
   WitTimer::leaveSection ("opt-prob");
   }
d636 37
a672 37
   {
   int              nIntVars;
   WitVector <int>  theIndices;
   WitVector <char> theTypeChars;
   int              theIdx;
   WitOptVar *      theOptVar;

   WitTimer::enterSection ("opt-prob");

   nIntVars = countIntVars ();

   theIndices  .resize (nIntVars);
   theTypeChars.resize (nIntVars, 'I');

   theIdx = -1;

   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      if (theOptVar->isAnIntVar ())
         {
         theIdx ++;

         theIndices[theIdx] = theOptVar->index ();
         }
      }

   WitTimer::leaveSection ("opt-prob");

   callCplex (
     "CPXchgctype",
      CPXchgctype (
         myCpxEnv_,
         myCpxLp_,
         nIntVars,
         theIndices  .myCVec (),
         theTypeChars.myCVec ()));
   }
d677 3
a679 3
   {
   int         nIntVars;
   WitOptVar * theOptVar;
d681 1
a681 1
   WitTimer::enterSection ("opt-prob");
d683 1
a683 1
   nIntVars = 0;
d685 5
a689 5
   forEachEl (theOptVar, myOptProblem_->myOptVars ())
      {
      if (theOptVar->isAnIntVar ())
         nIntVars ++;
      }
d691 1
a691 1
   WitTimer::leaveSection ("opt-prob");
d693 2
a694 2
   return nIntVars;
   }
d699 14
a712 14
   {
   if (myOptComp ()->printMps ())
      {
      myMsgFac () ("mpsFileMsg");

      callCplex (
        "CPXwriteprob",
         CPXwriteprob (
            myCpxEnv_,
            myCpxLp_,
            "opt-prob.mps",
            NULL));
      }
   }
d717 50
a766 50
   {
   WitOptVar *              prevOptVar;
   WitPtrVecItr <WitOptVar> theOptVarItr;
   WitOptVar *              theOptVar;

   if (DEVELOPMENT)
      WitTimer::getTimeAndChargeToCurrent ();

   if (not mipMode ())
      loadInitSoln ();

   prevOptVar = NULL;

   myOptProblem_->myLexOptVarSeq ().attachItr (theOptVarItr);

   while (theOptVarItr.advance (theOptVar))
      {
      myMsgFac () ("optLexObjElemMsg", theOptVar->lexObjElemName ());

      if (prevOptVar != NULL)
         {
         lockLexObjElemVal (prevOptVar);

         setObjCoef (prevOptVar, 0.0);
         }

      setObjCoef (theOptVar, 1.0);

      if (mipMode ())
         {
         solveMip (true);
         }
      else
         {
         if (prevOptVar != NULL)
            setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
         else
            setLpMethodByOptStarter ();

         solveLp (true);
         }

      if (DEVELOPMENT)
         if (WitSaeMgr::standAloneMode ())
            myMsgFac () ("lexObjElemCpuTimeMsg",
               WitTimer::getTimeAndChargeToCurrent ());

      prevOptVar = theOptVar;
      }
   }
d771 16
a786 16
   {
   int    indices[1];
   double values [1];

   indices[0]  = theOptVar->index ();
   values [0]  = theVal;

   callCplex (
     "CPXchgobj",
      CPXchgobj (
         myCpxEnv_,
         myCpxLp_,
         1,
         indices,
         values));
   }
d791 40
a830 40
   {
   int    theColIdx;
   double primalSoln[1];
   double optObjVal;
   double moTol;
   double theTol;
   int    indices[1];
   char   lu     [1];
   double bd     [1];

   theColIdx     = theOptVar->index ();

   callCplex (
     "CPXgetx",
      CPXgetx (
         myCpxEnv_,
         myCpxLp_,
         primalSoln,
         theColIdx, theColIdx));

   optObjVal     = primalSoln[0];

   moTol         = myOptComp ()->myMultiObjMgr ()->multiObjTol ();

   theTol        = WitNonClass::max (moTol * fabs (optObjVal), moTol);

   indices[0]    = theColIdx;
   lu     [0]    = 'L';
   bd     [0]    = optObjVal - theTol;

   callCplex (
     "CPXchgobj",
      CPXchgbds (
         myCpxEnv_,
         myCpxLp_,
         1,
         indices,
         lu,
         bd));
   }
d835 10
a844 10
   {
   if (myOptComp ()->crashOptStarter ()->isChosen ())
      {
      setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_DUAL);
      }
   else
      {
      setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
      }
   }
d849 2
a850 2
   {
   setSpecCpxPars ();
d852 5
a856 5
   callCplex (
     "CPXlpopt",
      CPXlpopt (
         myCpxEnv_,
         myCpxLp_));
d858 1
a858 1
   checkLpSolnStatus (optNeeded);
d860 2
a861 2
   printLpSolveInfo ();
   }
d866 28
a893 28
   {
   WitVector <double> initSoln;
   WitOptVar *        theVar;
      
   if (not myOptComp ()->optInitMethod ()->external ())
      return;

   WitTimer::enterSection ("opt-prob");

   initSoln.resize (myOptProblem_->nOptVars (), 0.0);

   forEachEl (theVar, myOptProblem_->myOptVars ())
      initSoln[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("opt-prob");

   callCplex (
     "CPXcopystart",
      CPXcopystart (
         myCpxEnv_,
         myCpxLp_,
         NULL,
         NULL,
         initSoln.myCVec (),
         NULL,
         NULL,
         NULL));
   }
d898 3
a900 3
   {
   int nSimpItns;
   int nPh1Itns;
d902 2
a903 2
   nSimpItns = CPXgetitcnt     (myCpxEnv_, myCpxLp_);
   nPh1Itns  = CPXgetphase1cnt (myCpxEnv_, myCpxLp_);
d905 2
a906 2
   myMsgFac () ("lpSolveInfoMsg", nSimpItns, nPh1Itns);
   }
d911 2
a912 2
   {
   storeCplexStatus ();
d914 31
a944 31
   switch (myOptComp ()->cplexStatusCode ())
      {
      case CPX_STAT_OPTIMAL:
         {
         myMsgFac () ("optSolnFoundMsg");

         return;
         }

      case CPX_STAT_INFEASIBLE:
         myMsgFac () ("infeasSmsg");

      case CPX_STAT_UNBOUNDED:
      case CPX_STAT_INForUNBD:
         myMsgFac () ("unboundedOrInfeasSmsg");

      case CPX_STAT_ABORT_IT_LIM:
      case CPX_STAT_ABORT_OBJ_LIM:
      case CPX_STAT_ABORT_TIME_LIM:
      case CPX_STAT_NUM_BEST:
      case CPX_STAT_OPTIMAL_INFEAS:
         {
         repEarlyTermLpSolnStatus (optNeeded);

         return;
         }

      default:
         issueStatusMsg ("unexpCpxStatSmsg");
      }
   }
d949 2
a950 2
   {
   int primalFeas;
d952 19
a970 19
   callCplex (
     "CPXsolninfo",
      CPXsolninfo (
         myCpxEnv_,
         myCpxLp_,
         NULL,
         NULL,
       & primalFeas,
         NULL));

   if (not primalFeas)
      issueStatusMsg ("inFeasLpCpxStatSmsg");

   else if (optNeeded)
      issueStatusMsg ("nonOptLpCpxStatSmsg");

   else
      issueStatusMsg ("nonOptButFeasLpCpxStatWmsg");
   }
d975 3
a977 3
   {
   if (countIntVars () == 0)
      myMsgFac () ("mipModeNoIntVarsSmsg");
d979 1
a979 1
   setSpecCpxPars ();
d981 5
a985 5
   callCplex (
     "CPXmipopt",
      CPXmipopt (
         myCpxEnv_,
         myCpxLp_));
d987 1
a987 1
   checkMipSolnStatus (optNeeded);
d989 1
a989 1
   storeObjBoundInfo ();
d991 2
a992 2
   printMipSolveInfo ();
   }
d997 16
a1012 16
   {
   int    nSimpItns;
   int    nNodes;
   double percentGap;

   nSimpItns  = CPXgetmipitcnt (myCpxEnv_, myCpxLp_);
   nNodes     = CPXgetnodecnt  (myCpxEnv_, myCpxLp_);

   percentGap = myOptComp ()->cplexMipRelGap () * 100.0;

   myMsgFac () ("mipSolveInfoMsg",
      nSimpItns,
      nNodes,
      percentGap,
      myOptComp ()->cplexMipBound ());
   }
d1017 2
a1018 2
   {
   storeCplexStatus ();
d1020 46
a1065 46
   switch (myOptComp ()->cplexStatusCode ())
      {
      case CPXMIP_OPTIMAL:
      case CPXMIP_OPTIMAL_TOL:
         {
         myMsgFac () ("optSolnFoundMsg");

         return;
         }

      case CPXMIP_INFEASIBLE:
         myMsgFac () ("infeasSmsg");

      case CPXMIP_UNBOUNDED:
      case CPXMIP_INForUNBD:
         myMsgFac () ("unboundedOrInfeasSmsg");

      case CPXMIP_ABORT_FEAS:
      case CPXMIP_FAIL_FEAS:
      case CPXMIP_FAIL_FEAS_NO_TREE:
      case CPXMIP_MEM_LIM_FEAS:
      case CPXMIP_NODE_LIM_FEAS:
      case CPXMIP_SOL_LIM:
      case CPXMIP_TIME_LIM_FEAS:
         {
         if (optNeeded)
            issueStatusMsg ("nonOptMipCpxStatSmsg");
         else
            issueStatusMsg ("nonOptButFeasMipCpxStatWmsg");

         return;
         }

      case CPXMIP_ABORT_INFEAS:
      case CPXMIP_FAIL_INFEAS:
      case CPXMIP_FAIL_INFEAS_NO_TREE:
      case CPXMIP_MEM_LIM_INFEAS:
      case CPXMIP_NODE_LIM_INFEAS:
      case CPXMIP_OPTIMAL_INFEAS:
      case CPXMIP_TIME_LIM_INFEAS:
         issueStatusMsg ("inFeasMipCpxStatSmsg");

      default:
         issueStatusMsg ("unexpCpxStatSmsg");
      }
   }
d1070 5
a1074 5
   {
   myMsgFac () (theMsgID,
      myOptComp ()->cplexStatusCode (),
      myOptComp ()->cplexStatusText ());
   }
d1079 22
a1100 22
   {
   WitVector <double> primalSoln;
   WitOptVar *        theVar;
   int                theIdx;

   primalSoln.resize (myOptProblem_->nOptVars ());

   callCplex (
     "CPXgetx",
      CPXgetx (
         myCpxEnv_,
         myCpxLp_,
         primalSoln.myCVecForUpdate (),
         0,
         myOptProblem_->nOptVars () - 1));


   WitTimer::enterSection ("opt-prob");

   forEachEl (theVar, myOptProblem_->myOptVars ())
      {
      theIdx = theVar->index ();
d1102 2
a1103 2
      theVar->setPrimalValue (primalSoln[theIdx]);
      }
d1105 2
a1106 2
   WitTimer::leaveSection ("opt-prob");
   }
d1111 21
a1131 21
   {
   WitVector <double> dualSoln;
   WitOptCon *        theCon;
   int                theIdx;

   dualSoln.resize (myOptProblem_->nOptCons ());

   callCplex (
     "CPXgetpi",
      CPXgetpi (
         myCpxEnv_,
         myCpxLp_,
         dualSoln.myCVecForUpdate (),
         0,
         myOptProblem_->nOptCons () - 1));

   WitTimer::enterSection ("opt-prob");

   forEachEl (theCon, myOptProblem_->myOptCons ())
      {
      theIdx = theCon->index ();
d1133 2
a1134 2
      theCon->setDualValue (dualSoln[theIdx]);
      }
d1136 2
a1137 2
   WitTimer::leaveSection ("opt-prob");
   }
d1142 2
a1143 2
   {
   WitCpxParSpec * theCpxParSpec;
d1145 8
a1152 8
   forEachEl (theCpxParSpec, myOptComp ()->myCpxParSpecMgr ()->myCpxParSpecs ())
      {
      if (theCpxParSpec->valTypeIsInt ())
         setSpecIntCpxPar (theCpxParSpec);
      else
         setSpecDblCpxPar (theCpxParSpec);
      }
   }
d1157 2
a1158 2
   {
   int theParamNum;
d1160 1
a1160 1
   theParamNum = findCpxParamNum (theCpxParSpec);
d1162 1
a1162 1
   checkCpxParamType (theCpxParSpec);
d1164 11
a1174 11
   callCplex (
     "CPXsetintparam",
      CPXsetintparam (
         myCpxEnv_,
         theParamNum,
         theCpxParSpec->myIntVal ()));

   myMsgFac () ("intCpxParSetMsg",
      theCpxParSpec->myName   (),
      theCpxParSpec->myIntVal ());
   }
d1179 2
a1180 2
   {
   int theParamNum;
d1182 1
a1182 1
   theParamNum = findCpxParamNum (theCpxParSpec);
d1184 1
a1184 1
   checkCpxParamType (theCpxParSpec);
d1186 11
a1196 11
   callCplex (
     "CPXsetdblparam",
      CPXsetdblparam (
         myCpxEnv_,
         theParamNum,
         theCpxParSpec->myDblVal ()));

   myMsgFac () ("dblCpxParSetMsg",
      theCpxParSpec->myName   (),
      theCpxParSpec->myDblVal ());
   }
d1201 32
a1232 32
   {
   int          theSpecType;
   const char * theSpecTypeText;
   int          theParamNum;
   int          theParamType;

   if (theCpxParSpec->valTypeIsInt ())
      {
      theSpecType     = CPX_PARAMTYPE_INT;
      theSpecTypeText = "Int";
      }
   else
      {
      theSpecType     = CPX_PARAMTYPE_DOUBLE;
      theSpecTypeText = "Double";
      }

   theParamNum = findCpxParamNum (theCpxParSpec);

   callCplex (
     "CPXgetparamtype",
      CPXgetparamtype (
         myCpxEnv_,
         theParamNum,
       & theParamType));

   if (theParamType != theSpecType)
      myMsgFac () ("wrongCpxParamTypeSmsg",
         theCpxParSpec->myName (),
         theSpecTypeText,
         theParamNum);
   }
d1237 20
a1256 20
   {
   int       theParamNameLen;
   WitString theParamName;
   int       theErrCode;
   int       theParamNum;

   theParamNameLen = theCpxParSpec->myName ().length () + 10;

   theParamName.resize (theParamNameLen);

   sprintf (
      theParamName.myCstringForUpdate (),
      "CPX_PARAM_%s",
      theCpxParSpec->myName ().myCstring ());

   theErrCode      =
      CPXgetparamnum (
         myCpxEnv_,
         theParamName.myCstring (),
       & theParamNum);
d1258 2
a1259 2
   if (theErrCode == CPXERR_BAD_PARAM_NAME)
      myMsgFac () ("badCpxParamNameSmsg", theCpxParSpec->myName ());
d1261 1
a1261 1
   checkErrCode (theErrCode, "getparamnum");
d1263 2
a1264 2
   return theParamNum;
   }
d1269 8
a1276 8
   {
   callCplex (
     "CPXsetintparam",
      CPXsetintparam (
         myCpxEnv_,
         theCpxParam,
         theValue));
   }
d1281 3
a1283 3
   {
   int  theStatCode;
   char theStatText[57];
d1285 1
a1285 1
   theStatCode = CPXgetstat (myCpxEnv_, myCpxLp_);
d1287 1
a1287 1
   CPXgetstatstring (myCpxEnv_, theStatCode, theStatText);
d1289 3
a1291 3
   myOptComp ()->storeCplexStatusCode (theStatCode);
   myOptComp ()->storeCplexStatusText (theStatText);
   }
d1296 21
a1316 21
   {
   double theMipBound;
   double theMipRelGap;

   callCplex (
     "CPXgetbestobjval",
      CPXgetbestobjval (
         myCpxEnv_,
         myCpxLp_,
       & theMipBound));

   callCplex (
     "CPXgetmiprelgap",
      CPXgetmiprelgap (
         myCpxEnv_,
         myCpxLp_,
       & theMipRelGap));

   myOptComp ()->storeCplexMipBound  (theMipBound);
   myOptComp ()->storeCplexMipRelGap (theMipRelGap);
   }
d1321 3
a1323 3
   {
   checkErrCode (theErrCode, theFuncName);
   }
d1328 3
a1330 3
   {
   if (theErrCode == 0)
      return;
d1332 1
a1332 1
   char theErrStr[4096] = "                   Unknown CPLEX error\n";
d1334 1
a1334 1
   CPXgeterrorstring (myCpxEnv_, theErrCode, theErrStr);
d1336 2
a1337 2
   myMsgFac () ("nonZeroCplexErrCodeSmsg", theErrStr, theFuncName);
   }
d1342 3
a1344 3
   {
   return myOptComp ()->mipMode ();
   }
@


1.98
log
@COIN removal.
@
text
@d13 4
d18 2
a19 1
//    The implementation compiled only if CPLEX_EMBEDDED is defined.
d22 70
a91 4
bool dummyBool = false;
   //
   // This declaration keeps the object file from being empty in
   // non-CPLEX_EMBEDDED mode, which avoids a link-time warning on AIX.
a100 1
#include <CplexMgr.h>
d120 1
a120 1
      WitSolverMgr  (theOptProblem),
@


1.97
log
@Revisions for the removal of COIN.
@
text
@d907 1
a907 1
      myMsgFac () ("cplexMipModeNoIntVarsSmsg");
@


1.96
log
@CPLEX
@
text
@d50 4
a53 3
      WitSolverMgr (theOptProblem),
      myCpxEnv_    (NULL),
      myCpxLp_     (NULL)
d75 1
a75 1
   else if (myOptProblem ()->reSolveMode ())
d205 1
a205 1
   solveLp (myOptProblem ()->needDual ());
d209 1
a209 1
   if (myOptProblem ()->needDual ())
d225 1
a225 1
   solveLp (myOptProblem ()->needDual ());
d229 1
a229 1
   if (myOptProblem ()->needDual ())
d294 2
a295 2
         myOptProblem ()->nOptVars (),
         myOptProblem ()->nOptCons (),
d320 2
a321 2
   rhs  .resize (myOptProblem ()->nOptCons ());
   sense.resize (myOptProblem ()->nOptCons ());
d323 1
a323 1
   forEachEl (theOptCon, myOptProblem ()->myOptCons ())
d350 1
a350 1
   ncols = myOptProblem ()->nOptVars ();
d357 1
a357 1
   myOptProblem ()->getMatrixByCols (matbeg, matind, matval);
d359 1
a359 1
   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
d396 1
a396 1
   cnt = myOptProblem ()->nOptVars ();
d404 1
a404 1
   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
d427 1
a427 1
   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
d461 1
a461 1
   cnt = myOptProblem ()->nOptCons ();
d468 1
a468 1
   forEachEl (theOptCon, myOptProblem ()->myOptCons ())
d534 1
a534 1
   cnt = myOptProblem ()->nOptVars ();
d541 1
a541 1
   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
d582 1
a582 1
   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
d615 1
a615 1
   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
d660 1
a660 1
   myOptProblem ()->myLexOptVarSeq ().attachItr (theOptVarItr);
d798 1
d803 8
a810 1
   getInitSoln (initSoln);
d1011 2
d1014 1
a1014 1
   primalSoln.resize (myOptProblem ()->nOptVars ());
d1023 2
a1024 1
         myOptProblem ()->nOptVars () - 1));
d1026 10
a1035 1
   WitSolverMgr::storePrimalSoln (primalSoln.myCVec ());
d1043 2
d1046 1
a1046 1
   dualSoln.resize (myOptProblem ()->nOptCons ());
d1055 1
a1055 1
         myOptProblem ()->nOptCons () - 1));
d1057 10
a1066 1
   WitSolverMgr::storeDualSoln (dualSoln.myCVec ());
d1271 7
@


1.95
log
@CPLEX
@
text
@a920 1
   double relGap;
d923 2
a924 2
   nSimpItns = CPXgetmipitcnt (myCpxEnv_, myCpxLp_);
   nNodes    = CPXgetnodecnt  (myCpxEnv_, myCpxLp_);
d926 1
a926 8
   callCplex (
     "CPXgetmiprelgap",
      CPXgetmiprelgap (
         myCpxEnv_,
         myCpxLp_,
       & relGap));

   percentGap = relGap * 100.0;
d932 1
a932 1
      myOptComp ()->cplexObjBound ());
d1195 2
a1196 2
   double theObjBound;
   double theObjRelGap;
d1203 1
a1203 1
       & theObjBound));
d1210 1
a1210 1
       & theObjRelGap));
d1212 2
a1213 2
   myOptComp ()->storeCplexObjBound  (theObjBound);
   myOptComp ()->storeCplexObjRelGap (theObjRelGap);
@


1.94
log
@CPLEX
@
text
@d1204 1
a1204 1
   double theMipRelGap;
d1218 1
a1218 1
       & theMipRelGap));
d1221 1
a1221 1
   myOptComp ()->storeCplexMipRelGap (theMipRelGap);
@


1.93
log
@CPLEX
@
text
@d910 1
a910 1
   storeObjBound ();
d1195 2
a1196 1
   myOptComp ()->storeCplexStatus (theStatCode, theStatText);
d1201 1
a1201 1
void WitCplexMgr::storeObjBound ()
d1204 1
d1213 9
a1221 1
   myOptComp ()->storeCplexObjBound (theObjBound);
@


1.92
log
@CPLEX
@
text
@d939 2
a940 2
      myOptComp ()->cplexObjBound (),
      percentGap);
@


1.91
log
@CPLEX
@
text
@d910 2
d936 5
a940 1
   myMsgFac () ("mipSolveInfoMsg", nSimpItns, nNodes, percentGap);
d1200 16
@


1.90
log
@CPLEX
@
text
@d17 5
@


1.89
log
@CPLEX
@
text
@a12 3
// Contains the implementation NonClass function cplexEmbedded ().
// Contains the implementation NonClass function newSolverMgrForCplex (...).
//
a16 45
#include <CplexMgr.h>
#include <OptComp.h>
#include <CpxParSpecMgr.h>
#include <CpxParSpec.h>

//------------------------------------------------------------------------------
// Implementation NonClass function cplexEmbedded ().
//
// Declared in OptComp.h.
//------------------------------------------------------------------------------

bool WitNonClass::cplexEmbedded ()
   {
#ifdef CPLEX_EMBEDDED

   return true;

#else

   return false;

#endif
   }

//------------------------------------------------------------------------------
// Implementation NonClass function newSolverMgrForCplex (...).
//
// Declared in SolverMgr.h.
//------------------------------------------------------------------------------

WitSolverMgr * WitNonClass::newSolverMgrForCplex (WitOptProblem * theOptProblem)
   {
#ifdef CPLEX_EMBEDDED

   return new WitCplexMgr (theOptProblem);

#else

   stronglyAssert (false);

   return NULL;

#endif
   }

d25 1
d27 2
@


1.88
log
@CPLEX
@
text
@d873 1
a873 1
   int theStatCode;
d875 1
a875 5
   theStatCode = CPXgetstat (myCpxEnv_, myCpxLp_);

   myOptComp ()->storeCplexStatusCode (theStatCode);

   switch (theStatCode)
d897 1
a897 1
         repEarlyTermLpSolnStatus (theStatCode, optNeeded);
d903 1
a903 7
         {
         char statText[57];

         CPXgetstatstring (myCpxEnv_, theStatCode, statText);

         myMsgFac () ("unexpCpxStatSmsg", theStatCode, statText);
         }
d909 1
a909 1
void WitCplexMgr::repEarlyTermLpSolnStatus (int theStatCode, bool optNeeded)
d911 1
a911 4
   char statText[57];
   int  primalFeas;

   CPXgetstatstring (myCpxEnv_, theStatCode, statText);
d924 1
a924 1
      myMsgFac () ("inFeasLpCpxStatSmsg",        theStatCode, statText);
d927 1
a927 1
      myMsgFac () ("nonOptLpCpxStatSmsg",        theStatCode, statText);
d930 1
a930 1
      myMsgFac () ("nonOptButFeasLpCpxStatWmsg", theStatCode, statText);
d981 1
a981 4
   int  theStatCode;
   char statText[57];

   theStatCode = CPXgetstat (myCpxEnv_, myCpxLp_);
d983 1
a983 5
   myOptComp ()->storeCplexStatusCode (theStatCode);

   CPXgetstatstring (myCpxEnv_, theStatCode, statText);

   switch (theStatCode)
d1009 1
a1009 1
            myMsgFac () ("nonOptMipCpxStatSmsg",        theStatCode, statText);
d1011 1
a1011 1
            myMsgFac () ("nonOptButFeasMipCpxStatWmsg", theStatCode, statText);
d1023 1
a1023 1
         myMsgFac ()    ("inFeasMipCpxStatSmsg",        theStatCode, statText);
d1026 1
a1026 1
         myMsgFac ()    ("unexpCpxStatSmsg",            theStatCode, statText);
d1032 9
d1220 14
@


1.87
log
@CPLEX
@
text
@d873 1
a873 1
   int theStatus;
d875 1
a875 1
   theStatus = CPXgetstat (myCpxEnv_, myCpxLp_);
d877 1
a877 1
   myOptComp ()->storeCplexSolnStatus (theStatus);
d879 1
a879 1
   switch (theStatus)
d901 1
a901 1
         repEarlyTermLpSolnStatus (theStatus, optNeeded);
d910 1
a910 1
         CPXgetstatstring (myCpxEnv_, theStatus, statText);
d912 1
a912 1
         myMsgFac () ("unexpCpxStatSmsg", theStatus, statText);
d919 1
a919 1
void WitCplexMgr::repEarlyTermLpSolnStatus (int theStatus, bool optNeeded)
d924 1
a924 1
   CPXgetstatstring (myCpxEnv_, theStatus, statText);
d937 1
a937 1
      myMsgFac () ("inFeasLpCpxStatSmsg",        theStatus, statText);
d940 1
a940 1
      myMsgFac () ("nonOptLpCpxStatSmsg",        theStatus, statText);
d943 1
a943 1
      myMsgFac () ("nonOptButFeasLpCpxStatWmsg", theStatus, statText);
d994 1
a994 1
   int  theStatus;
d997 1
a997 1
   theStatus = CPXgetstat (myCpxEnv_, myCpxLp_);
d999 1
a999 1
   myOptComp ()->storeCplexSolnStatus (theStatus);
d1001 1
a1001 1
   CPXgetstatstring (myCpxEnv_, theStatus, statText);
d1003 1
a1003 1
   switch (theStatus)
d1029 1
a1029 1
            myMsgFac () ("nonOptMipCpxStatSmsg",        theStatus, statText);
d1031 1
a1031 1
            myMsgFac () ("nonOptButFeasMipCpxStatWmsg", theStatus, statText);
d1043 1
a1043 1
         myMsgFac ()    ("inFeasMipCpxStatSmsg",        theStatus, statText);
d1046 1
a1046 1
         myMsgFac ()    ("unexpCpxStatSmsg",            theStatus, statText);
@


1.86
log
@CPLEX
@
text
@d138 1
a138 1
   checkErrCode (theErrCode, "openCPLEX", false);
d150 1
a150 1
   checkErrCode (theErrCode, "createprob", false);
a818 2
   int theErrCode;

d821 5
a825 3
   theErrCode = CPXlpopt (myCpxEnv_, myCpxLp_);

   checkErrCode (theErrCode, "CPXlpopt", true);
a949 2
   int theErrCode;

d955 5
a959 3
   theErrCode = CPXmipopt (myCpxEnv_, myCpxLp_);

   checkErrCode (theErrCode, "CPXmipopt", true);
d1212 1
a1212 1
   checkErrCode (theErrCode, "getparamnum", false);
d1233 1
a1233 1
   checkErrCode (theErrCode, theFuncName, false);
d1238 1
a1238 4
void WitCplexMgr::checkErrCode (
      int          theErrCode,
      const char * theFuncName,
      bool         funcIsSolver)
d1247 1
a1247 4
   if (funcIsSolver)
      myMsgFac () ("nonZeroCplexErrCodeSmsg", theErrStr, theFuncName);
   else
      myMsgFac () ("nonZeroCplexErrCodeFmsg", theErrStr, theFuncName);
@


1.85
log
@CPLEX
@
text
@d138 1
a138 1
   checkErrCode (theErrCode, "openCPLEX");
d150 1
a150 1
   checkErrCode (theErrCode, "createprob");
d819 2
d823 3
a825 5
   callSolveFunc (
     "CPXlpopt",
      CPXlpopt (
         myCpxEnv_,
         myCpxLp_));
d950 2
d957 3
a959 5
   callSolveFunc (
     "CPXmipopt",
      CPXmipopt (
         myCpxEnv_,
         myCpxLp_));
d1212 1
a1212 1
   checkErrCode (theErrCode, "getparamnum");
d1233 1
a1233 1
   checkErrCode (theErrCode, theFuncName);
d1238 4
a1241 1
void WitCplexMgr::checkErrCode (int theErrCode, const char * theFuncName)
d1250 4
a1253 15
   myMsgFac () ("nonZeroCplexErrCodeFmsg", theErrStr, theFuncName);
   }

//------------------------------------------------------------------------------

void WitCplexMgr::callSolveFunc (const char * theFuncName, int theErrCode)
   {
   if (theErrCode == 0)
      return;

   char theErrStr[4096] = "                   Unknown CPLEX error\n";

   CPXgeterrorstring (myCpxEnv_, theErrCode, theErrStr);

   myMsgFac () ("nonZeroCplexErrCodeSmsg", theErrStr, theFuncName);
@


1.84
log
@CPLEX
@
text
@d821 1
a821 1
   callCplex (
d955 1
a955 1
   callCplex (
d1247 15
a1261 1
   myMsgFac () ("nonZeroCplexErrCodeFmsg", theErrStr, theErrCode, theFuncName);
@


1.83
log
@CPLEX
@
text
@d92 1
a92 2
      myCpxLp_     (NULL),
      mipMode_     (false)
a109 10
   mipMode_ = myOptComp ()->mipMode ();

   if (mipMode_)
      if (countIntVars () == 0)
         {
         myMsgFac () ("cplexMipModeNoIntVarsWmsg");

         mipMode_ = false;
         }

d118 1
a118 1
   else if (mipMode_)
d294 1
a294 1
      myMsgFac ().myFrag (mipMode_? "mipFrag": "lpFrag"),
d301 1
a301 1
   if (mipMode_)
d694 1
a694 1
   if (not mipMode_)
d714 1
a714 1
      if (mipMode_)
d950 3
@


1.82
log
@CPLEX Parameters
@
text
@d185 1
a185 1
        "setlogfile",
d196 1
a196 1
        "freeprob",
d208 1
a208 1
        "closeCPLEX",
d220 1
a220 1
        "getlogfile",
d228 1
a228 1
        "setlogfile",
d236 1
a236 1
        "fclose",
d340 1
a340 1
        "copylp",
d466 1
a466 1
        "chgobj",
d486 1
a486 1
        "chgobj",
d530 1
a530 1
        "chgrhs",
d602 1
a602 1
        "chgobj",
d645 1
a645 1
        "chgctype",
d685 1
a685 1
           "writeprob",
d759 1
a759 1
        "chgobj",
d784 1
a784 1
        "getx",
d802 1
a802 1
        "chgobj",
d833 1
a833 1
        "lpopt",
d855 1
a855 1
        "copystart",
d938 1
a938 1
        "solninfo",
d964 1
a964 1
        "mipopt",
d987 1
a987 1
        "getmiprelgap",
d1067 1
a1067 1
        "getx",
d1087 1
a1087 1
        "getpi",
d1124 1
a1124 1
        "setintparam",
d1146 1
a1146 1
        "setdblparam",
d1180 1
a1180 1
        "getparamtype",
d1230 1
a1230 1
        "setintparam",
@


1.81
log
@CPLEX Parameters
@
text
@d888 1
a888 1
   myOptComp ()->storeCpxSolnStatus (theStatus);
d1007 1
a1007 1
   myOptComp ()->storeCpxSolnStatus (theStatus);
@


1.80
log
@CPLEX Parameters
@
text
@a1117 1
   int theErrCode;
d1121 1
a1121 2
   theErrCode =
      CPXsetintparam (myCpxEnv_, theParamNum, theCpxParSpec->myIntVal ());
d1123 6
a1128 7
   if (theErrCode == CPXERR_BAD_PARAM_NUM)
      myMsgFac () ("wrongCpxParamTypeSmsg",
         theCpxParSpec->myName (),
         "Int",
         theParamNum);

   checkErrCode (theErrCode, "setintparam");
a1139 1
   int theErrCode;
d1143 4
a1146 1
   theErrCode =
d1150 6
a1155 1
         theCpxParSpec->myDblVal ());
d1157 30
a1186 1
   if (theErrCode == CPXERR_BAD_PARAM_NUM)
d1189 1
a1189 1
         "Double",
a1190 6

   checkErrCode (theErrCode, "setdblparam");

   myMsgFac () ("dblCpxParSetMsg",
      theCpxParSpec->myName   (),
      theCpxParSpec->myDblVal ());
@


1.79
log
@CPLEX Parameters
@
text
@d1170 4
a1173 2
   int theErrCode;
   int theParamNum;
d1175 10
a1184 1
   theErrCode =
d1187 1
a1187 1
         theCpxParSpec->myName ().myCstring (),
@


1.78
log
@CPLEX solution status
@
text
@d907 1
d910 1
d981 1
d993 3
a995 1
   myMsgFac () ("mipSolveInfoMsg", nSimpItns, nNodes, relGap);
@


1.77
log
@CPLEX solution status
@
text
@d888 1
a888 1
   myOptComp ()->storeCpxStat (theStatus);
d1002 1
a1002 1
   myOptComp ()->storeCpxStat (theStatus);
@


1.76
log
@CPLEX Solution Status
@
text
@d884 1
a884 1
   int stat;
d886 1
a886 1
   stat = CPXgetstat (myCpxEnv_, myCpxLp_);
d888 1
a888 1
   myOptComp ()->storeCpxStat (stat);
d890 1
a890 1
   switch (stat)
a899 1
         {
a900 1
         }
a903 1
         {
a904 1
         }
d910 1
a910 1
         checkNonOptLpSolnStatus (stat, optNeeded);
d919 1
a919 1
         CPXgetstatstring (myCpxEnv_, stat, statText);
d921 1
a921 1
         myMsgFac () ("unexpCpxStatSmsg", stat, statText);
d928 1
a928 1
void WitCplexMgr::checkNonOptLpSolnStatus (int stat, bool optNeeded)
d933 1
a933 1
   CPXgetstatstring (myCpxEnv_, stat, statText);
d946 1
a946 1
      myMsgFac () ("inFeasLpCpxStatSmsg",        stat, statText);
d949 1
a949 1
      myMsgFac () ("nonOptLpCpxStatSmsg",        stat, statText);
d952 1
a952 1
      myMsgFac () ("nonOptButFeasLpCpxStatWmsg", stat, statText);
d997 2
a998 3
   int    stat;
   double theGap;
   char   statText[57];
d1000 1
a1000 1
   stat = CPXgetstat (myCpxEnv_, myCpxLp_);
d1002 1
a1002 1
   myOptComp ()->storeCpxStat (stat);
d1004 1
a1004 1
   CPXgetstatstring (myCpxEnv_, stat, statText);
d1006 1
a1006 1
   switch (stat)
a1016 1
         {
a1017 1
         }
a1020 1
         {
a1021 1
         }
d1023 6
a1029 1
      case CPXMIP_SOL_LIM:
d1032 1
a1032 1
            myMsgFac () ("nonOptMipCpxStatSmsg",        stat, statText);
d1034 1
a1034 2
            {
            myMsgFac () ("nonOptButFeasMipCpxStatWmsg", stat, statText);
d1036 1
a1036 2
            return;
            }
d1039 6
d1046 1
a1046 3
         {
         myMsgFac ()    ("inFeasMipCpxStatSmsg",        stat, statText);
         }
d1049 1
a1049 3
         {
         myMsgFac ()    ("unexpCpxStatSmsg",            stat, statText);
         }
@


1.75
log
@CPLEX Solution Status
@
text
@d980 3
a982 2
   int nSimpItns;
   int nNodes;
d987 8
a994 1
   myMsgFac () ("mipSolveInfoMsg", nSimpItns, nNodes);
d1001 3
a1003 2
   int  stat;
   char statText[57];
@


1.74
log
@CPLEX (bug fix)
@
text
@d900 10
a918 6
      case CPX_STAT_UNBOUNDED:
      case CPX_STAT_INForUNBD:
         {
         myMsgFac () ("unboundedOrInfeasSmsg");
         }

a972 2
   myMsgFac () ("optSolnFoundMsg");

d993 2
a994 1
   int stat;
d1000 2
d1007 2
d1023 2
a1024 1
      default:
d1026 9
a1034 1
         char statText[57];
d1036 4
a1039 1
         CPXgetstatstring (myCpxEnv_, stat, statText);
d1041 3
a1043 1
         myMsgFac () ("unexpCpxStatSmsg", stat, statText);
@


1.73
log
@CPLEX Solution Status
@
text
@d92 2
a93 1
      myCpxLp_     (NULL)
d111 10
d129 1
a129 1
   else if (mipMode ())
d305 1
a305 1
      myMsgFac ().myFrag (mipMode ()? "mipFrag": "lpFrag"),
d312 1
a312 1
   if (mipMode ())
a617 1
   WitOptVar *      theOptVar;
d621 1
d625 1
a625 7
   nIntVars = 0;

   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
      {
      if (theOptVar->isAnIntVar ())
         nIntVars ++;
      }
d656 22
d705 1
a705 1
   if (not mipMode ())
d725 1
a725 1
      if (mipMode ())
@


1.72
log
@CPLEX Solution Status
@
text
@d284 1
a284 1
   solveMip ();
d700 1
a700 1
         solveMip ();
d872 1
a881 5
      case CPX_STAT_INFEASIBLE:
         {
         myMsgFac () ("infeasSmsg");
         }

a907 3
   if (optNeeded)
      myMsgFac () ("nonOptLpCpxStatSmsg", stat, statText);

d918 7
a924 1
   if (primalFeas)
a925 2
   else
      myMsgFac () ("inFeasLpCpxStatSmsg",        stat, statText);
d930 1
a930 1
void WitCplexMgr::solveMip ()
d940 1
a940 1
   checkMipSolnStatus ();
d962 1
a962 1
void WitCplexMgr::checkMipSolnStatus ()
d1155 1
a1155 1
   char theErrStr[4096] = "(Unknown CPLEX error)";
d1159 1
a1159 4
   myMsgFac () ("nonZeroCplexErrCodeFmsg",
      theFuncName,
      theErrCode,
      theErrStr);
@


1.71
log
@CPLEX Solution Status
@
text
@d874 1
@


1.70
log
@CPLEX Solution Status
@
text
@d925 1
a925 1
      myMsgFac () ("nonOptButFeasLpCpxStatMsg", stat, statText);
d927 1
a927 1
      myMsgFac () ("inFeasLpCpxStatSmsg",       stat, statText);
@


1.69
log
@CPLEX Solution Status
@
text
@d872 8
a890 7
      case CPX_STAT_ABORT_IT_LIM:
         {
         checkNonOptLpSolnStatus (stat, optNeeded);

         return;
         }

@


1.68
log
@CPLEX Solution Status
@
text
@d244 1
a244 1
   solveLp ();
d264 1
a264 1
   solveLp ();
d709 1
a709 1
         solveLp ();
d801 1
a801 1
void WitCplexMgr::solveLp ()
d811 1
a811 1
   checkLpSolnStatus ();
d813 1
a813 3
   myMsgFac () ("optSolnFoundMsg");

   printLpStats ();
d842 1
a842 1
void WitCplexMgr::printLpStats ()
d850 1
a850 1
   myMsgFac () ("lpStatsMsg", nSimpItns, nPh1Itns);
d855 1
a855 1
void WitCplexMgr::checkLpSolnStatus ()
d867 2
d883 7
d903 28
d945 1
a945 1
   printMipStats ();
d950 1
a950 1
void WitCplexMgr::printMipStats ()
d958 1
a958 1
   myMsgFac () ("mipStatsMsg", nSimpItns, nNodes);
@


1.67
log
@CPLEX Parameters
@
text
@d859 1
a859 1
   int solnStatus;
d861 1
a861 1
   solnStatus = CPXgetstat (myCpxEnv_, myCpxLp_);
d863 3
a865 1
   switch (solnStatus)
d887 1
a887 1
         CPXgetstatstring (myCpxEnv_, solnStatus, statText);
d889 1
a889 1
         myMsgFac () ("unexpCpxSolnStatSmsg", solnStatus, statText);
d930 3
a932 1
   int solnStatus;
d934 1
a934 1
   solnStatus = CPXgetstat (myCpxEnv_, myCpxLp_);
d936 1
a936 1
   switch (solnStatus)
d959 1
a959 1
         CPXgetstatstring (myCpxEnv_, solnStatus, statText);
d961 1
a961 1
         myMsgFac () ("unexpCpxSolnStatSmsg", solnStatus, statText);
@


1.66
log
@CPLEX Parameters
@
text
@a145 2
   setIntParam (CPX_PARAM_SIMDISPLAY, myOptComp ()->cpxSimDisplay ());

@


1.65
log
@CPLEX Parameters
@
text
@a1008 2
   int             theErrCode;
   int             theCpxParam;
d1012 13
a1024 5
      theErrCode =
         CPXgetparamnum (
            myCpxEnv_,
            theCpxParSpec->myName ().myCstring (),
          & theCpxParam);
d1026 1
a1026 2
      if (theErrCode == 1028)
         myMsgFac () ("badCpxParamNameSmsg", theCpxParSpec->myName ());
d1028 22
a1049 1
      checkErrCode (theErrCode, "getparamnum");
d1051 1
a1051 1
      stronglyAssert (false);
d1053 38
a1090 7
      if (theCpxParSpec->valTypeIsInt ())
         {
         }
      else
         {
         }
      }
@


1.64
log
@CPLEX
@
text
@d22 2
d175 2
a176 1
   callCplex ("setlogfile",
d186 2
a187 1
   callCplex ("freeprob",
d198 2
a199 1
   callCplex ("closeCPLEX",
d210 2
a211 1
   callCplex ("getlogfile",
d218 2
a219 1
   callCplex ("setlogfile",
d226 2
a227 1
   callCplex ("fclose",
d330 2
a331 1
   callCplex ("copylp",
d456 2
a457 1
   callCplex ("chgobj",
d476 2
a477 1
   callCplex ("chgobj",
d520 2
a521 1
   callCplex ("chgrhs",
d592 2
a593 1
   callCplex ("chgobj",
d641 2
a642 1
   callCplex ("chgctype",
d659 2
a660 1
      callCplex ("writeprob",
d733 2
a734 1
   callCplex ("chgobj",
d758 2
a759 1
   callCplex ("getx",
d776 2
a777 1
   callCplex ("chgobj",
d805 4
a808 1
   callCplex ("lpopt",
d831 2
a832 1
   callCplex ("copystart",
d898 4
a901 1
   callCplex ("mipopt",
d972 2
a973 1
   callCplex ("getx",
d992 2
a993 1
   callCplex ("getpi",
d1006 32
d1040 2
a1041 1
   callCplex ("setintparam",
@


1.63
log
@CPLEX
@
text
@a791 2
   printLpStats ();

d795 2
a880 2
   printMipStats ();

d884 2
@


1.62
log
@CPLEX
@
text
@d522 31
a592 31
void WitCplexMgr::getConData (double & rhs, char & sense, WitOptCon * theOptCon)
   {
   double theLB;
   double theUB;

   theLB  = theOptCon->bounds ().lower ();
   theUB  = theOptCon->bounds ().upper ();

   if (theLB == theUB)
      {
      rhs   = theLB;
      sense = 'E';
      }
   else if (theUB == + DBL_MAX)
      {
      rhs   = theLB;
      sense = 'G';
      }
   else if (theLB == - DBL_MAX)
      {
      rhs   = theUB;
      sense = 'L';
      }
   else
      {
      stronglyAssert (false);
      }
   }

//------------------------------------------------------------------------------

d656 129
a940 129
void WitCplexMgr::solveLexOpt ()
   {
   WitOptVar *              prevOptVar;
   WitPtrVecItr <WitOptVar> theOptVarItr;
   WitOptVar *              theOptVar;

   if (DEVELOPMENT)
      WitTimer::getTimeAndChargeToCurrent ();

   if (not mipMode ())
      loadInitSoln ();

   prevOptVar = NULL;

   myOptProblem ()->myLexOptVarSeq ().attachItr (theOptVarItr);

   while (theOptVarItr.advance (theOptVar))
      {
      myMsgFac () ("optLexObjElemMsg", theOptVar->lexObjElemName ());

      if (prevOptVar != NULL)
         {
         lockLexObjElemVal (prevOptVar);

         setObjCoef (prevOptVar, 0.0);
         }

      setObjCoef (theOptVar, 1.0);

      if (mipMode ())
         {
         solveMip ();
         }
      else
         {
         if (prevOptVar != NULL)
            setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
         else
            setLpMethodByOptStarter ();

         solveLp ();
         }

      if (DEVELOPMENT)
         if (WitSaeMgr::standAloneMode ())
            myMsgFac () ("lexObjElemCpuTimeMsg",
               WitTimer::getTimeAndChargeToCurrent ());

      prevOptVar = theOptVar;
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setObjCoef (WitOptVar * theOptVar, double theVal)
   {
   int    indices[1];
   double values [1];

   indices[0]  = theOptVar->index ();
   values [0]  = theVal;

   callCplex ("chgobj",
      CPXchgobj (
         myCpxEnv_,
         myCpxLp_,
         1,
         indices,
         values));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::lockLexObjElemVal (WitOptVar * theOptVar)
   {
   int    theColIdx;
   double primalSoln[1];
   double optObjVal;
   double moTol;
   double theTol;
   int    indices[1];
   char   lu     [1];
   double bd     [1];

   theColIdx     = theOptVar->index ();

   callCplex ("getx",
      CPXgetx (
         myCpxEnv_,
         myCpxLp_,
         primalSoln,
         theColIdx, theColIdx));

   optObjVal     = primalSoln[0];

   moTol         = myOptComp ()->myMultiObjMgr ()->multiObjTol ();

   theTol        = WitNonClass::max (moTol * fabs (optObjVal), moTol);

   indices[0]    = theColIdx;
   lu     [0]    = 'L';
   bd     [0]    = optObjVal - theTol;

   callCplex ("chgobj",
      CPXchgbds (
         myCpxEnv_,
         myCpxLp_,
         1,
         indices,
         lu,
         bd));
   }

//------------------------------------------------------------------------------

void WitCplexMgr::setLpMethodByOptStarter ()
   {
   if (myOptComp ()->crashOptStarter ()->isChosen ())
      {
      setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_DUAL);
      }
   else
      {
      setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
      }
   }

//------------------------------------------------------------------------------

@


1.61
log
@CPLEX
@
text
@d108 1
a108 1
   if      (myOptComp ()->multiObjMode () and mipMode ())
d110 1
a110 5
      solveOptProbAsLexMip ();
      }
   else if (myOptComp ()->multiObjMode ())
      {
      solveOptProbAsLexLp ();
d285 1
a285 1
void WitCplexMgr::solveOptProbAsLexLp ()
d287 3
a289 1
   myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("lpFrag"), "CPLEX");
d295 2
a296 18
   writeMps ();

   solveLexLp ();

   storePrimalSoln ();
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveOptProbAsLexMip ()
   {
   myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("mipFrag"), "CPLEX");

   myMsgFac () ("lexOptMsg");

   loadLp ();

   loadIntData ();
d300 1
a300 1
   solveLexMip ();
d812 1
a812 1
void WitCplexMgr::solveLexLp ()
d821 2
a822 1
   loadInitSoln ();
d841 1
a841 1
      if (prevOptVar != NULL)
d843 1
a843 1
         setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
d847 4
a850 2
         setLpMethodByOptStarter ();
         }
d852 1
a852 35
      solveLp ();

      if (DEVELOPMENT)
         if (WitSaeMgr::standAloneMode ())
            myMsgFac () ("lexObjElemCpuTimeMsg",
               WitTimer::getTimeAndChargeToCurrent ());

      prevOptVar = theOptVar;
      }
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveLexMip ()
   {
   WitOptVar *              prevOptVar;
   WitPtrVecItr <WitOptVar> theOptVarItr;
   WitOptVar *              theOptVar;

   if (DEVELOPMENT)
      WitTimer::getTimeAndChargeToCurrent ();

   prevOptVar = NULL;

   myOptProblem ()->myLexOptVarSeq ().attachItr (theOptVarItr);

   while (theOptVarItr.advance (theOptVar))
      {
      myMsgFac () ("optLexObjElemMsg", theOptVar->lexObjElemName ());

      if (prevOptVar != NULL)
         {
         lockLexObjElemVal (prevOptVar);

         setObjCoef (prevOptVar, 0.0);
a854 4
      setObjCoef (theOptVar, 1.0);

      solveMip ();
                 
@


1.60
log
@CPLEX
@
text
@d240 2
a675 2
   loadInitSoln ();

d867 1
a867 10
      callCplex ("lpopt",
         CPXlpopt (
            myCpxEnv_,
            myCpxLp_));

      printLpStats ();

      checkLpSolnStatus ();

      myMsgFac () ("optSolnFoundMsg");
@


1.59
log
@CPLEX
@
text
@d108 1
a108 1
   if      (myOptComp ()->multiObjMode () and myOptComp ()->mipMode ())
d120 1
a120 1
   else if (myOptComp ()->mipMode ())
d238 2
d258 2
a673 2
   int theLpMethod;

a675 7
   theLpMethod =
      myOptProblem ()->reSolveMode ()?                  CPX_ALG_DUAL:
      myOptComp    ()->crashOptStarter ()->isChosen ()? CPX_ALG_DUAL:
                                                        CPX_ALG_PRIMAL;

   setIntParam (CPX_PARAM_LPMETHOD, theLpMethod);

a834 1
   int                      theLpMethod;
d858 8
a865 6
      theLpMethod =
         (prevOptVar != NULL)?                          CPX_ALG_PRIMAL:
         myOptComp ()->crashOptStarter ()->isChosen ()? CPX_ALG_DUAL:
                                                        CPX_ALG_PRIMAL;

      setIntParam (CPX_PARAM_LPMETHOD, theLpMethod);
d915 2
a916 11
      callCplex ("mipopt",
         CPXmipopt (
            myCpxEnv_,
            myCpxLp_));

      printMipStats ();

      checkMipSolnStatus ();

      myMsgFac () ("optSolnFoundMsg");

d989 14
@


1.58
log
@CPLEX
@
text
@d313 2
d895 42
a936 1
   myMsgFac () ("cplexSolveTermSmsg");
@


1.57
log
@CPLEX
@
text
@d306 7
a312 1
   myMsgFac () ("cplexSolveTermSmsg");
d891 7
@


1.56
log
@CPLEX
@
text
@d108 5
a112 1
   if (myOptComp ()->multiObjMode ())
d285 1
a285 3
   myMsgFac () ("solveOptProblemMsg",
      myMsgFac ().myFrag (myOptComp ()->mipMode ()? "mipFrag": "lpFrag"),
      "CPLEX");
d300 11
@


1.55
log
@CPLEX
@
text
@a292 2
   myMsgFac () ("cplexSolveTermSmsg");

d816 1
a816 1
   bool                     isFirstLexElem;
d826 1
a826 1
   isFirstLexElem = true;
d834 7
d844 1
a844 1
         (not isFirstLexElem)?                          CPX_ALG_PRIMAL:
a858 4
      lockLexObjElemVal (theOptVar);

      setObjCoef (theOptVar, 0.0);

d866 1
a866 1
      isFirstLexElem = false;
@


1.54
log
@CPLEX
@
text
@a88 1
      curErrCode_  (0),
d132 1
a132 1
   myCpxEnv_ =   CPXopenCPLEX (& curErrCode_);
d134 3
a136 1
   checkErrCode ("CPXopenCPLEX");
d148 1
a148 1
   myCpxLp_ =    CPXcreateprob (myCpxEnv_, & curErrCode_, "Implosion");
d150 1
a150 1
   checkErrCode ("CPXcreateprob");
d173 4
a176 3
   curErrCode_ = CPXsetlogfile (myCpxEnv_, theCpxFile);

   checkErrCode ("CPXsetlogfile");
d183 4
a186 3
   curErrCode_ = CPXfreeprob (myCpxEnv_, & myCpxLp_);

   checkErrCode ("CPXfreeprob");
d194 3
a196 3
   curErrCode_ = CPXcloseCPLEX (& myCpxEnv_);

   checkErrCode ("CPXcloseCPLEX");
d205 4
a208 3
   curErrCode_ = CPXgetlogfile (myCpxEnv_, & theCpxFile);

   checkErrCode ("CPXgetlogfile");
d212 4
a215 3
   curErrCode_ = CPXsetlogfile (myCpxEnv_, NULL);

   checkErrCode ("CPXsetlogfile");
d219 3
a221 3
   curErrCode_ = CPXfclose (theCpxFile);

   checkErrCode ("CPXfclose");
d315 1
a315 1
   curErrCode_ =
d331 1
a331 3
         NULL);

   checkErrCode ("CPXcopylp");
d440 1
a440 1
   curErrCode_ =
d447 1
a447 3
         bd     .myCVec ());

   checkErrCode ("CPXchgobj");
d459 1
a459 1
   curErrCode_ =
d466 1
a466 3
         bd     .myCVec ());

   checkErrCode ("CPXchgobj");
d502 1
a502 1
   curErrCode_ =
d508 1
a508 3
         values .myCVec ());

   checkErrCode ("CPXchgrhs");
d542 1
a542 1
   curErrCode_ =
d548 1
a548 3
         values .myCVec ());

   checkErrCode ("CPXchgobj");
d621 1
a621 1
   curErrCode_ =
d627 1
a627 3
         theTypeChars.myCVec ());

   checkErrCode ("CPXchgctype");
d638 6
a643 3
      curErrCode_ = CPXwriteprob (myCpxEnv_, myCpxLp_, "opt-prob.mps", NULL);

      checkErrCode  ("CPXwriteprob");
d662 4
a665 3
   curErrCode_ = CPXlpopt (myCpxEnv_, myCpxLp_);

   checkErrCode ("CPXlpopt");
d685 1
a685 1
   curErrCode_ =
d694 1
a694 3
         NULL);

   checkErrCode ("CPXcopystart");
d751 4
a754 3
   curErrCode_ = CPXmipopt (myCpxEnv_, myCpxLp_);

   checkErrCode ("CPXmipopt");
d845 4
a848 3
      curErrCode_ = CPXlpopt (myCpxEnv_, myCpxLp_);

      checkErrCode ("CPXlpopt");
d879 7
a885 3
   curErrCode_ = CPXchgobj (myCpxEnv_, myCpxLp_, 1, indices, values);

   checkErrCode ("CPXchgobj");
d903 6
a908 4
   curErrCode_   =
      CPXgetx (myCpxEnv_, myCpxLp_, primalSoln, theColIdx, theColIdx);

   checkErrCode ("CPXgetx");
d920 8
a927 4
   curErrCode_   =
      CPXchgbds (myCpxEnv_, myCpxLp_, 1, indices, lu, bd);

   checkErrCode ("CPXchgobj");
d938 1
a938 1
   curErrCode_ =
d944 1
a944 3
         myOptProblem ()->nOptVars () - 1);

   checkErrCode ("CPXgetx");
d957 1
a957 1
   curErrCode_ =
d963 1
a963 3
         myOptProblem ()->nOptCons () - 1);

   checkErrCode ("CPXgetpi");
d972 6
a977 1
   curErrCode_ = CPXsetintparam (myCpxEnv_, theCpxParam, theValue);
d979 5
a983 1
   checkErrCode ("CPXsetintparam");
d988 1
a988 1
void WitCplexMgr::checkErrCode (const char * theFuncName)
d990 1
a990 1
   if (curErrCode_ == 0)
d995 1
a995 1
   CPXgeterrorstring (myCpxEnv_, curErrCode_, theErrStr);
d999 1
a999 1
      curErrCode_,
@


1.53
log
@CPLEX
@
text
@d89 1
a89 1
      myCpxStatus_ (0),
d133 1
a133 1
   myCpxEnv_ =   CPXopenCPLEX (& myCpxStatus_);
d135 1
a135 1
   checkStatus ("CPXopenCPLEX");
d147 1
a147 1
   myCpxLp_ =    CPXcreateprob (myCpxEnv_, & myCpxStatus_, "Implosion");
d149 1
a149 1
   checkStatus ("CPXcreateprob");
d172 1
a172 1
   myCpxStatus_ = CPXsetlogfile (myCpxEnv_, theCpxFile);
d174 1
a174 1
   checkStatus  ("CPXsetlogfile");
d181 1
a181 1
   myCpxStatus_ = CPXfreeprob (myCpxEnv_, & myCpxLp_);
d183 1
a183 1
   checkStatus  ("CPXfreeprob");
d191 1
a191 1
   myCpxStatus_ = CPXcloseCPLEX (& myCpxEnv_);
d193 1
a193 1
   checkStatus  ("CPXcloseCPLEX");
d202 1
a202 1
   myCpxStatus_ = CPXgetlogfile (myCpxEnv_, & theCpxFile);
d204 1
a204 1
   checkStatus  ("CPXgetlogfile");
d208 1
a208 1
   myCpxStatus_ = CPXsetlogfile (myCpxEnv_, NULL);
d210 1
a210 1
   checkStatus  ("CPXsetlogfile");
d214 1
a214 1
   myCpxStatus_ = CPXfclose (theCpxFile);
d216 1
a216 1
   checkStatus  ("CPXfclose");
d289 2
d310 1
a310 1
   myCpxStatus_ =
d328 1
a328 1
   checkStatus ("CPXcopylp");
d437 1
a437 1
   myCpxStatus_ =
d446 1
a446 1
   checkStatus ("CPXchgobj");
d458 1
a458 1
   myCpxStatus_ =
d467 1
a467 1
   checkStatus ("CPXchgobj");
d503 1
a503 1
   myCpxStatus_ =
d511 1
a511 1
   checkStatus ("CPXchgrhs");
d545 1
a545 1
   myCpxStatus_ =
d553 1
a553 1
   checkStatus ("CPXchgobj");
d626 1
a626 1
   myCpxStatus_ =
d634 1
a634 1
   checkStatus ("CPXchgctype");
d645 1
a645 1
      myCpxStatus_ = CPXwriteprob (myCpxEnv_, myCpxLp_, "opt-prob.mps", NULL);
d647 1
a647 1
      checkStatus  ("CPXwriteprob");
d666 1
a666 1
   myCpxStatus_ = CPXlpopt (myCpxEnv_, myCpxLp_);
d668 1
a668 1
   checkStatus  ("CPXlpopt");
d688 1
a688 1
   myCpxStatus_ =
d699 1
a699 1
   checkStatus ("CPXcopystart");
d756 1
a756 1
   myCpxStatus_ = CPXmipopt (myCpxEnv_, myCpxLp_);
d758 1
a758 1
   checkStatus  ("CPXmipopt");
d849 1
a849 1
      myCpxStatus_ = CPXlpopt (myCpxEnv_, myCpxLp_);
d851 1
a851 1
      checkStatus  ("CPXlpopt");
d879 2
a880 2
   indices[0]   = theOptVar->index ();
   values [0]   = theVal;
d882 1
a882 1
   myCpxStatus_ = CPXchgobj (myCpxEnv_, myCpxLp_, 1, indices, values);
d884 1
a884 1
   checkStatus ("CPXchgobj");
d900 1
a900 1
   theColIdx = theOptVar->index ();
d902 1
a902 1
   myCpxStatus_ =
d905 1
a905 1
   checkStatus ("CPXgetx");
d907 1
a907 1
   optObjVal    = primalSoln[0];
d909 1
a909 1
   moTol        = myOptComp ()->myMultiObjMgr ()->multiObjTol ();
d911 1
a911 1
   theTol       = WitNonClass::max (moTol * fabs (optObjVal), moTol);
d913 3
a915 3
   indices[0]   = theColIdx;
   lu     [0]   = 'L';
   bd     [0]   = optObjVal - theTol;
d917 2
a918 1
   myCpxStatus_ = CPXchgbds (myCpxEnv_, myCpxLp_, 1, indices, lu, bd);
d920 1
a920 1
   checkStatus ("CPXchgobj");
d931 1
a931 1
   myCpxStatus_ =
d939 1
a939 1
   checkStatus ("CPXgetx");
d952 1
a952 1
   myCpxStatus_ =
d960 1
a960 1
   checkStatus ("CPXgetpi");
d969 1
a969 1
   myCpxStatus_ = CPXsetintparam (myCpxEnv_, theCpxParam, theValue);
d971 1
a971 1
   checkStatus ("CPXsetintparam");
d976 1
a976 1
void WitCplexMgr::checkStatus (const char * theFuncName)
d978 11
a988 2
   if (myCpxStatus_ != 0)
      myMsgFac () ("nonZeroCplexStatusFmsg",theFuncName, myCpxStatus_);
@


1.52
log
@CPLEX
@
text
@d72 2
d287 2
d823 1
a823 1
   int                      theColIdx;
d838 20
a857 1
      theColIdx = theOptVar->index ();
d859 8
a866 1
      myMsgFac () ("cplexSolveTermSmsg");
d872 50
@


1.51
log
@CPLEX
@
text
@d816 22
a837 1
   myMsgFac () ("cplexSolveTermSmsg");
@


1.50
log
@CPLEX
@
text
@d107 5
a111 1
   if (myOptProblem ()->reSolveMode ())
d272 17
d814 7
@


1.49
log
@CPLEX
@
text
@d764 1
@


1.48
log
@CPLEX
@
text
@d773 1
@


1.47
log
@CPLEX
@
text
@d773 5
@


1.46
log
@CPLEX
@
text
@d744 2
a745 3
   int    nSimpItns;
   int    nNodes;
   double relGap;
d747 2
a748 3
   nSimpItns    = CPXgetmipitcnt  (myCpxEnv_, myCpxLp_);
   nNodes       = CPXgetnodecnt   (myCpxEnv_, myCpxLp_);
   myCpxStatus_ = CPXgetmiprelgap (myCpxEnv_, myCpxLp_, & relGap);
d750 1
a750 3
   checkStatus  ("CPXgetmiprelgap");

   myMsgFac () ("mipStatsMsg", nSimpItns, nNodes, relGap);
d768 5
@


1.45
log
@CPLEX
@
text
@d262 2
d735 3
a737 3
   myMsgFac () ("genericSmsg",
      "The partial implementation of optimizing implosion in MIP mode "
      "with CPLEX terminates here: K");
d759 26
@


1.44
log
@CPLEX
@
text
@d103 1
a103 1
void WitCplexMgr::solve ()
d109 5
a113 3
      myMsgFac () ("reSolveLpMsg", "CPLEX");

      reviseLp ();
d117 1
a117 5
      myMsgFac () ("solveOptProblemMsg",
         myMsgFac ().myFrag ("lpFrag"),
         "CPLEX");

      loadLp ();
a119 13
   writeMps ();

   solveLp ();

   checkLpSolnStatus ();

   myMsgFac () ("optSolnFoundMsg");

   storePrimalSoln ();

   if (myOptProblem ()->needDual ())
      storeDualSoln ();

d141 1
a141 1
   myCpxLp_ =    CPXcreateprob (myCpxEnv_, & myCpxStatus_, "Implosion LP");
d215 51
d562 48
a626 2
   int nSimpItns;
   int nPh1Itns;
d641 3
a643 2
   nSimpItns = CPXgetitcnt     (myCpxEnv_, myCpxLp_);
   nPh1Itns  = CPXgetphase1cnt (myCpxEnv_, myCpxLp_);
d645 1
a645 1
   myMsgFac () ("simplexIterationsMsg", nSimpItns, nPh1Itns);
d675 13
d725 32
@


1.43
log
@CPLEX
@
text
@a71 1
#include <DetOptImpMgr.h>
d107 1
a107 1
   if (myDetOptImpMgr ()->accelerated ())
d549 3
a551 3
      myDetOptImpMgr ()->accelerated ()?             CPX_ALG_DUAL:
      myOptComp ()->crashOptStarter ()->isChosen ()? CPX_ALG_DUAL:
                                                     CPX_ALG_PRIMAL;
@


1.42
log
@CPLEX
@
text
@a540 2
#include <StochImpMgr.h>

d543 1
d549 6
a554 12
   if (myDetOptImpMgr ()->accelerated ())
      {
      setIntParam (CPX_PARAM_LPMETHOD, myStochImpMgr ()->nScenarios ());
      }
   else if (myOptComp ()->crashOptStarter ()->isChosen ())
      {
      setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_DUAL);
      }
   else
      {
      setIntParam (CPX_PARAM_LPMETHOD, CPX_ALG_PRIMAL);
      }
@


1.41
log
@CPLEX
@
text
@d541 2
d550 5
a554 1
   if (myOptComp ()->crashOptStarter ()->isChosen ())
@


1.40
log
@CPLEX
@
text
@d543 2
a544 1
   int nItns;
d561 2
a562 1
   nItns = CPXgetitcnt (myCpxEnv_, myCpxLp_);
d564 1
a564 1
   myMsgFac () ("simplexIterationsMsg", nItns);
@


1.39
log
@CPLEX
@
text
@d125 1
a125 4
   if (myDetOptImpMgr ()->accelerated ())
      solveLpAcc ();
   else
      solveLpUnacc ();
d153 1
a153 1
   setParams ();
a188 13
void WitCplexMgr::setParams ()
   {
   myCpxStatus_ =
      CPXsetintparam (
         myCpxEnv_,
         CPX_PARAM_SIMDISPLAY,
         myOptComp ()->cpxSimDisplay ());

   checkStatus ("CPXsetintparam");
   }

//------------------------------------------------------------------------------

d541 1
a541 1
void WitCplexMgr::solveLpUnacc ()
d549 1
a549 3
      myCpxStatus_ = CPXdualopt (myCpxEnv_, myCpxLp_);

      checkStatus  ("CPXdualopt");
d553 4
a556 1
      myCpxStatus_ = CPXprimopt (myCpxEnv_, myCpxLp_);
d558 1
a558 2
      checkStatus  ("CPXprimopt");
      }
a591 26
void WitCplexMgr::solveLpAcc ()
   {
   int nItns;

   loadInitSoln ();

   if (myOptComp ()->crashOptStarter ()->isChosen ())
      {
      myCpxStatus_ = CPXdualopt (myCpxEnv_, myCpxLp_);

      checkStatus  ("CPXdualopt");
      }
   else
      {
      myCpxStatus_ = CPXprimopt (myCpxEnv_, myCpxLp_);

      checkStatus  ("CPXprimopt");
      }

   nItns = CPXgetitcnt (myCpxEnv_, myCpxLp_);

   myMsgFac () ("simplexIterationsMsg", nItns);
   }

//------------------------------------------------------------------------------

d664 1
a664 1
   checkStatus (" PXgetx");
d671 9
@


1.38
log
@CPLEX
@
text
@d125 4
a128 1
   solveLp ();
d146 1
a146 1
   myCpxEnv_ = CPXopenCPLEX (& myCpxStatus_);
d160 1
a160 1
   myCpxLp_ = CPXcreateprob (myCpxEnv_, & myCpxStatus_, "Implosion LP");
d187 1
a187 1
   checkStatus ("CPXsetlogfile");
d209 1
a209 1
   checkStatus ("CPXfreeprob");
d219 1
a219 1
   checkStatus ("CPXcloseCPLEX");
d230 1
a230 1
   checkStatus ("CPXgetlogfile");
d236 1
a236 1
   checkStatus ("CPXsetlogfile");
d242 1
a242 1
   checkStatus ("CPXfclose");
d398 1
a398 1
   checkStatus  ("CPXchgobj");
d406 2
a407 3
      indices[theColIdx] = theColIdx;
      lu     [theColIdx] = 'U';
      bd     [theColIdx] = theOptVar->bounds ().upper ();
d419 1
a419 1
   checkStatus  ("CPXchgobj");
d463 1
a463 1
   checkStatus  ("CPXchgrhs");
d505 1
a505 1
   checkStatus  ("CPXchgobj");
d557 1
a557 1
void WitCplexMgr::solveLp ()
d608 26
d706 1
a706 1
   checkStatus ("CPXgetx");
@


1.37
log
@CPLEX
@
text
@d111 2
d119 2
a122 2
   loadLp ();

a287 2
   double      theLB;
   double      theUB;
d298 1
a298 22
      theLB  = theOptCon->bounds ().lower ();
      theUB  = theOptCon->bounds ().upper ();

      if (theLB == theUB)
         {
         rhs  [theIdx] = theLB;
         sense[theIdx] = 'E';
         }
      else if (theUB == + DBL_MAX)
         {
         rhs  [theIdx] = theLB;
         sense[theIdx] = 'G';
         }
      else if (theLB == - DBL_MAX)
         {
         rhs  [theIdx] = theUB;
         sense[theIdx] = 'L';
         }
      else
         {
         stronglyAssert (false);
         }
d347 194
@


1.36
log
@CPLEX
@
text
@d92 1
d99 1
a118 2
   setUpCplex ();

a133 2
   shutDownCplex ();

d200 42
a511 42
void WitCplexMgr::shutDownCplex ()
   {
   myCpxStatus_ = CPXfreeprob (myCpxEnv_, & myCpxLp_);

   checkStatus ("CPXfreeprob");

   //...........................................................................

   shutDownLogFile ();

   //...........................................................................

   myCpxStatus_ = CPXcloseCPLEX (& myCpxEnv_);

   checkStatus ("CPXcloseCPLEX");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::shutDownLogFile ()
   {
   CPXFILEptr theCpxFile;

   myCpxStatus_ = CPXgetlogfile (myCpxEnv_, & theCpxFile);

   checkStatus ("CPXgetlogfile");

   //...........................................................................

   myCpxStatus_ = CPXsetlogfile (myCpxEnv_, NULL);

   checkStatus ("CPXsetlogfile");

   //...........................................................................

   myCpxStatus_ = CPXfclose (theCpxFile);

   checkStatus ("CPXfclose");
   }

//------------------------------------------------------------------------------

@


1.35
log
@CPLEX
@
text
@d72 1
d106 10
a115 1
   myMsgFac () ("solveOptProblemMsg", myMsgFac ().myFrag ("lpFrag"), "CPLEX");
@


1.34
log
@CPLEX
@
text
@a90 1
   stronglyAssert (myOptComp ()->cplexAllowed ());
@


1.33
log
@CPLEX
@
text
@d339 3
a341 1
   myCpxStatus_ = CPXprimopt (myCpxEnv_, myCpxLp_);
d343 8
a350 1
   checkStatus  ("CPXprimopt");
d352 1
a352 1
   nItns        = CPXgetitcnt (myCpxEnv_, myCpxLp_);
@


1.32
log
@CPLEX
@
text
@d335 2
d342 4
@


1.31
log
@CPLEX
@
text
@d395 5
a399 1
         myMsgFac () ("unexpCpxSolnStatSmsg", solnStatus);
@


1.30
log
@CPLEX
@
text
@d337 1
a337 3
   if (myOptComp ()->crashOptStarter ()->isChosen ())
      {
      myCpxStatus_ = CPXdualopt (myCpxEnv_, myCpxLp_);
d339 1
a339 8
      checkStatus  ("CPXdualopt");
      }
   else
      {
      myCpxStatus_ = CPXprimopt (myCpxEnv_, myCpxLp_);

      checkStatus  ("CPXprimopt");
      }
@


1.29
log
@CPLEX
@
text
@d387 1
d389 1
d393 1
a393 3
         myOptProblem ()->reportInfeasible ();

         break;
d397 1
d399 1
a399 3
         myOptProblem ()->reportUnbounded ();

         break;
d402 1
a402 1
      case CPX_STAT_INForUNBD:
d404 1
a404 3
         myOptProblem ()->reportInfOrUnbdd ();

         break;
a406 2

   myMsgFac () ("unexpCpxSolnStatSmsg", solnStatus);
@


1.28
log
@CPLEX
@
text
@d411 1
a411 1
   myMsgFac () ("unexpCpxSolnStatFmsg", solnStatus);
@


1.27
log
@CPLEX
@
text
@d387 10
d398 3
a400 1
         return;
d403 1
a403 1
      default:
d405 3
a407 1
         myMsgFac () ("unexpCpxSolnStatFmsg", solnStatus);
d410 2
@


1.26
log
@CPLEX
@
text
@d112 2
d319 14
@


1.25
log
@CPLEX
@
text
@d142 2
d178 13
@


1.24
log
@CPLEX
@
text
@d304 1
a304 1
   stronglyAssert (myOptComp ()->crashOptStarter ()->isChosen ());
d306 3
a308 1
   myCpxStatus_ = CPXdualopt (myCpxEnv_, myCpxLp_);
d310 8
a317 1
   checkStatus ("CPXdualopt");
@


1.23
log
@CPLEX
@
text
@d80 2
d188 2
a189 15
   WitTimer::enterSection ("opt-prob");

   myOptProblem ()->
      getLpProbForCplex (
         objective,
         rhs,
         sense,
         matbeg,
         matcnt,
         matind,
         matval,
         lb,
         ub);

   WitTimer::leaveSection ("opt-prob");
d214 88
a315 1
   WitOptVar *        theVar;
d320 1
a320 8
   WitTimer::enterSection ("opt-prob");

   initSoln.resize (myOptProblem ()->nOptVars (), 0.0);

   forEachEl (theVar, myOptProblem ()->myOptVars ())
      initSoln[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("opt-prob");
a362 4
   WitOptVar *        theVar;
   double             thePrimalVal;

   WitTimer::enterSection ("opt-prob");
a365 2
   WitTimer::leaveSection ("opt-prob");

d376 1
a376 10
   WitTimer::enterSection ("opt-prob");

   forEachEl (theVar, myOptProblem ()->myOptVars ())
      {
      thePrimalVal = primalSoln[theVar->index ()];

      theVar->setPrimalValue (thePrimalVal);
      }

   WitTimer::leaveSection ("opt-prob");
a383 4
   WitOptCon *        theCon;
   double             theDualVal;

   WitTimer::enterSection ("opt-prob");
a386 2
   WitTimer::leaveSection ("opt-prob");

d397 1
a397 10
   WitTimer::enterSection ("opt-prob");

   forEachEl (theCon, myOptProblem ()->myOptCons ())
      {
      theDualVal = dualSoln[theCon->index ()];

      theCon->setDualValue (theDualVal);
      }

   WitTimer::leaveSection ("opt-prob");
@


1.22
log
@CPLEX
@
text
@d75 1
d227 2
d236 33
@


1.21
log
@CPLEX
@
text
@d74 1
d117 2
a118 1
   stronglyAssert (not myOptProblem ()->needDual ());
d291 36
@


1.20
log
@CPLEX
@
text
@a21 1
#include <Timing.h>
d183 2
d197 2
@


1.19
log
@CPLEX
@
text
@d22 1
d74 1
d117 2
d252 30
a281 1
   myMsgFac () ("cplexSolveTermSmsg");
@


1.18
log
@CPLEX
@
text
@d48 1
a48 1
WitSolverMgr * WitNonClass::newSolverMgrForCplex (WitOptModel * theOptModel)
d52 1
a52 1
   return new WitCplexMgr (theOptModel);
d72 1
a72 1
#include <OptModel.h>
d79 1
a79 1
WitCplexMgr::WitCplexMgr (WitOptModel * theOptModel):
d81 1
a81 1
      WitSolverMgr (theOptModel),
d101 1
a101 1
   myMsgFac () ("solveOptModelMsg", myMsgFac ().myFrag ("lpFrag"), "CPLEX");
d180 1
a180 1
   myOptModel ()->
d196 2
a197 2
         myOptModel ()->nOptVars (),
         myOptModel ()->nOptCons (),
@


1.17
log
@CPLEX
@
text
@d105 1
a105 1
   loadLP ();
d107 7
a113 1
   solveLpUnacc ();
d168 1
a168 1
void WitCplexMgr::loadLP ()
a169 3
   int                numcols;
   int                numrows;
   int                objsense;
a178 1
   WitVector <double> rngval;
a181 3
         numcols,
         numrows,
         objsense,
d190 1
a190 2
         ub,
         rngval);
d196 3
a198 3
         numcols,
         numrows,
         objsense,
d208 1
a208 1
         rngval   .myCVec ());
d215 1
a215 12
void WitCplexMgr::solveLpUnacc ()
   {
   solveLpAsUsual ();

   checkLpSolnStatus ();

   myMsgFac () ("cplexSolveTermSmsg");
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solveLpAsUsual ()
d246 7
@


1.16
log
@CPLEX
@
text
@d107 1
a107 1
   myMsgFac () ("cplexSolveTermSmsg");
d217 42
@


1.15
log
@Upgraded to CPLEX 12.2, (with no license manager).
@
text
@d72 1
d105 1
a105 1
   shutDownCplex ();
d109 2
d162 55
@


1.14
log
@CPLEX
@
text
@a77 4
#include <cplex_runtime_lic.h>

//------------------------------------------------------------------------------

a114 7
   myCpxStatus_ =
      CPXRegisterLicense (ilm_CPLEX_license, ilm_CPLEX_license_signature);

   checkStatus ("CPXRegisterLicense");

   //...........................................................................

@


1.13
log
@CPLEX
@
text
@d72 1
d74 1
d102 4
d111 2
@


1.12
log
@CPLEX
@
text
@d141 4
a144 1
   CPXFILEptr theCpxFile;
d146 1
a146 1
   theCpxFile = CPXfopen (myOptComp ()->solverLogFileName ().myCstring (), "w");
d148 4
a151 1
   stronglyAssert (theCpxFile != NULL);
@


1.11
log
@CPLEX
@
text
@d126 4
d139 17
d164 4
d175 23
@


1.10
log
@CPLEX
@
text
@d26 1
a26 1
// Declared in SolverMgr.h.
d74 3
a76 1
#include <cplex.h>
d82 4
a85 1
      WitSolverMgr (theOptModel)
a87 4

   tryCplex ();

   myMsgFac () ("cplexSolveTermSmsg");
d100 5
d109 1
a109 1
void WitCplexMgr::tryCplex ()
d111 10
a120 2
   CPXENVptr theCpxEnv;
   int       status;
d122 1
a122 1
#if 0
d124 1
a124 1
   theCpxEnv = CPXopenCPLEX (& status);
d126 1
a126 2
   stronglyAssert (theCpxEnv != NULL);
   stronglyAssert (status    == 0);
d128 1
a128 1
   status = CPXcloseCPLEX (& theCpxEnv);
d130 12
a141 1
   stronglyAssert (status == 0);
d143 1
a143 3
   fprintf (myMsgFac ().myFile (),
      "\n"
      "tryCplex () finished OK.\n");
d145 9
a153 1
#endif
@


1.9
log
@CPLEX
@
text
@d17 1
a17 1
//    The implementation compiled only if CPLEX_EMBEDDED == 1.
a23 13
// The following code verifies that CPLEX_EMBEDDED is defined as either 0 or 1.
//------------------------------------------------------------------------------

#if (CPLEX_EMBEDDED != 0) && (CPLEX_EMBEDDED != 1)

Invalid_Code;
   //
   // The above code results in a syntax error, when CPLEX_EMBEDDED is not
   // defined as either 0 or 1.

#endif

//------------------------------------------------------------------------------
d31 9
a39 1
   return (CPLEX_EMBEDDED == 1);
d50 1
a50 1
#if CPLEX_EMBEDDED == 1
d67 1
a67 1
#if CPLEX_EMBEDDED == 1
d128 1
a128 1
#endif // CPLEX_EMBEDDED == 1
@


1.8
log
@CPLEX
@
text
@d13 1
d21 1
d37 11
@


1.7
log
@CPLEX
@
text
@d100 1
a100 1
/*
d111 5
a115 1
*/
@


1.6
log
@CPLEX
@
text
@d98 14
@


1.5
log
@CPLEX
@
text
@d13 1
a13 1
// Contains the implementations of class CplexMgr.
d15 2
a16 10
// This file contains two implementations of class CplexMgr, only one of which
// gets compiled:
//
// * When CPLEX_EMBEDDED == 1, the main implementation is compiled.
//   The main implementation of class CplexMgr invokes CPLEX to fulfill the
//   responsibilities of class SolverMgr.
// 
// * When CPLEX_EMBEDDED == 0, the dummy implementation is compiled.
//   The dummy implementation of class CplexMgr does not invoke CPLEX 
//   It generates a fatal error if any of its member functions is invoked.
a19 2
#include <OptComp.h>
#include <MsgFac.h>
d35 3
a37 1
// Main implementation of class CplexMgr.
d40 2
d44 11
d56 9
a97 1

a102 33

//------------------------------------------------------------------------------
// Dummy implementation of class CplexMgr.
//------------------------------------------------------------------------------

#if CPLEX_EMBEDDED == 0

//------------------------------------------------------------------------------

WitCplexMgr::WitCplexMgr (WitOptModel *):

      WitSolverMgr (NULL)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

WitCplexMgr::~WitCplexMgr ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitCplexMgr::solve ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

#endif // CPLEX_EMBEDDED == 0
@


1.4
log
@CPLEX
@
text
@a24 2
//
// Note that this file is to be the only file that uses CPLEX_EMBEDDED.
d60 1
a60 1
   CPXENVptr theCpxEnv;
d62 1
a62 1
   stronglyAssert (myOptComp ()->cplexAllowed ());
d81 8
@


1.3
log
@CPLEX
@
text
@d54 4
d62 2
@


1.2
log
@CPLEX
@
text
@d30 2
d58 3
a60 1
   stronglyAssert (false);
a66 1
   stronglyAssert (false);
a72 1
   stronglyAssert (false);
@


1.1
log
@CPLEX
@
text
@a31 8
// The following code makes 0 the default value of  CPLEX_EMBEDDED.
//------------------------------------------------------------------------------

#ifndef CPLEX_EMBEDDED
#define CPLEX_EMBEDDED 0
#endif

//------------------------------------------------------------------------------
a51 7
bool WitCplexMgr::cplexEmbedded ()
   {
   return true;
   }

//------------------------------------------------------------------------------

a84 7
bool WitCplexMgr::cplexEmbedded ()
   {
   return false;
   }

//------------------------------------------------------------------------------

@


head	1.157;
access;
symbols
	sce_5_01_20080919:1.150
	latest_sce_4_20_20060523:1.138.0.2
	sce_4_20_20060523:1.138
	latest_sce4_20_OSL:1.132.0.2
	sce_4_20_OSL:1.132
	sce_410_withVa:1.84
	sce_4_05_20040511:1.71
	sce_4_00_20040201:1.64;
locks; strict;
comment	@ * @;


1.157
date	2011.09.28.23.49.48;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2011.09.24.00.28.09;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2011.08.30.20.17.49;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2011.01.19.00.20.52;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2010.09.10.22.10.40;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2010.09.01.16.28.24;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2007.07.10.15.57.23;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2007.06.29.15.25.49;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2006.09.19.17.50.55;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2006.08.09.22.04.57;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2006.08.09.18.36.39;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2006.08.08.18.31.19;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2006.08.07.22.24.28;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2006.08.04.16.21.17;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2006.08.02.22.23.40;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2006.08.02.19.03.01;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2006.05.30.22.36.00;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2006.05.26.20.40.10;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2006.05.22.16.02.41;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2006.05.19.22.39.43;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2006.05.18.20.58.01;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2006.05.11.20.20.30;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2006.05.10.23.05.02;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2006.05.02.17.34.06;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2006.03.27.22.28.51;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2006.03.24.16.53.26;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2006.03.21.20.47.35;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2006.03.20.21.54.31;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2006.03.17.22.52.22;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2006.03.17.17.27.49;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2006.03.16.19.30.57;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2006.03.16.17.11.33;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2006.03.15.23.44.52;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2006.03.15.23.13.55;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2006.03.15.21.57.53;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2006.03.14.21.10.13;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2006.03.13.20.31.56;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2006.03.13.19.26.34;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2006.03.13.17.02.22;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2006.03.11.00.03.45;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2006.03.10.23.23.30;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2006.03.10.17.14.19;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2006.03.10.16.19.57;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2006.03.09.23.07.06;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2006.03.09.22.01.26;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2006.03.09.19.58.23;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2006.03.09.18.25.10;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2006.03.09.17.23.13;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2006.03.08.23.57.11;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2006.03.06.19.59.46;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2006.03.03.23.16.29;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2006.03.03.22.22.04;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2006.03.03.21.01.02;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2006.03.03.20.46.56;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2006.03.02.23.29.02;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2006.02.28.19.43.05;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2006.02.27.22.02.32;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2006.02.27.21.19.54;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2006.01.12.22.09.24;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2006.01.12.20.23.29;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2006.01.12.20.07.43;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2006.01.12.16.28.33;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2006.01.09.23.42.39;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2005.11.29.16.28.15;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2005.11.22.22.20.27;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2005.11.18.21.44.12;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2005.11.18.21.12.10;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2005.11.17.22.33.33;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2005.11.17.22.04.41;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2005.11.15.17.08.19;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.11.14.22.29.02;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2005.11.11.23.29.13;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2005.06.16.19.19.12;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2005.06.15.23.07.41;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2005.06.14.20.35.12;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2005.03.28.20.14.36;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.01.28.19.34.26;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.01.11.20.28.37;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2004.10.13.15.27.40;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.17.22.15.18;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.05.17.15.36.07;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.14.22.03.19;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.14.15.08.49;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.05.14.15.05.32;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.12.15.25.56;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.05.05.15.26.31;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.02.07.00.12.10;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.02.04.18.57.49;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.16.18.48.25;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.06.21.13.28;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2003.12.31.23.18.57;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2003.12.31.21.44.53;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2003.12.30.21.47.02;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.30.18.52.17;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.12.29.19.13.42;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.29.16.25.32;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.24.23.25.55;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.24.21.09.47;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.23.22.24.31;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.23.19.02.52;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.23.17.56.20;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.23.16.18.47;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.12.19.19.01.01;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.17.22.29.59;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.17.21.23.00;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.17.17.04.50;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.17.16.53.52;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.15.23.22.32;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.15.19.35.59;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.12.21.20.15;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.12.19.49.43;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.11.21.56.32;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.10.23.45.57;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.10.23.20.42;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.04.22.44.56;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.04.16.45.16;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.04.16.20.41;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.11.20.42.46;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.31.15.37.54;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.29.17.03.58;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.29.16.29.38;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.29.00.15.50;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.28.22.49.11;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.28.22.38.58;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.28.19.45.33;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.24.15.37.46;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.23.21.00.08;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.23.19.33.12;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.22.22.42.52;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.22.22.30.10;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.22.22.11.15;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.22.20.37.29;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.21.20.45.42;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.21.19.28.45;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.16.22.29.39;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.16.18.13.04;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.16.16.20.32;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.16.16.18.03;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.09.21.31.51;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.08.23.26.45;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.08.19.27.49;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.07.18.37.39;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.06.20.33.30;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.06.20.14.59;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.03.23.34.08;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.03.21.52.20;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.02.23.14.10;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.01.17.22.22;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.01.15.59.26;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.01.14.17.43;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.30.15.40.54;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.157
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "PIP.C"
//
// Contains the implementation of the following classes and templates:
//
//    PipMgr
//    PipSeqMgr
//    PipPgg
//    PipAttPgg <SrcComp>, with explicit instantiation
//------------------------------------------------------------------------------

#include <PipMgr.h>
#include <PipSeqMgr.h>
#include <PipPgg.h>
#include <PipAttPgg.h>
#include <PipBldr.h>
#include <Post.h>
#include <Demand.h>
#include <Material.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <GlobalComp.h>
#include <DataWrit.h>
#include <Timing.h>
#include <Schedule.h>
#include <PairStack.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class PipMgr.
//------------------------------------------------------------------------------

WitPipMgr::WitPipMgr (WitProblem * theProblem):

      WitProbAssoc (theProblem),

      mySeqMgr_    (NULL),
      myPgg_       (NULL)
   {
   WitTimer::enterSection ("pip");

   mySeqMgr_ = new WitPipSeqMgr (myProblem ());

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

WitPipMgr::~WitPipMgr ()
   {
   WitTimer::enterSection ("pip");

   delete myPgg_;
   delete mySeqMgr_;

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::clearShipSeq ()
   {
   WitTimer::enterSection ("pip");

   clearPegging ();

   mySeqMgr_->clear ();

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::appendToShipSeq (
      WitDemand * theDemand,
      WitPeriod   shipPer,
      double      incShipVol)
   {
   WitTimer::enterSection ("pip");

   clearPegging ();

   mySeqMgr_->append (theDemand, shipPer, incShipVol);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::getShipSeq (WitDemTripStack & theShipSeq)
   {
   WitTimer::enterSection ("pip");

   mySeqMgr_->get (theShipSeq);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::displayShipSeq ()
   {
   mySeqMgr_->display ();
   }

//------------------------------------------------------------------------------

void WitPipMgr::copyShipSeq (WitPipMgr * thePipMgr)
   {
   WitTimer::enterSection ("pip");

   mySeqMgr_->copy (thePipMgr->mySeqMgr_);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------
 
void WitPipMgr::writeShipSeqData ()
   {
   mySeqMgr_->writeData ();
   }

//------------------------------------------------------------------------------

void WitPipMgr::setShipSeqShipPer (WitPeriod shipPer)
   {
   mySeqMgr_->setShipPerForRead (shipPer);
   }

//------------------------------------------------------------------------------

WitPeriod WitPipMgr::shipSeqShipPer ()
   {
   return mySeqMgr_->shipPerForRead ();
   }

//------------------------------------------------------------------------------

void WitPipMgr::buildPegging ()
   {
   WitTimer::enterSection ("pip");

   myMsgFac () ("pipMsg");

   if (not myGlobalComp ()->newPipPggOrder ())
      myMsgFac () ("oldPipPggOrderMsg");

   checkRestrictions ();

   mySeqMgr_->reduce ();

   clearPegging ();

   myPgg_ = new WitPipPgg (myProblem ());

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::clearPegging ()
   {
   if (not peggingExists ())
      return;

   WitTimer::enterSection ("pip");

   delete myPgg ();
   
   myPgg_ = NULL;

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::printPegging ()
   {
   if (peggingExists ())
      myPgg ()->print ();
   }

//------------------------------------------------------------------------------

void WitPipMgr::getExecVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitOpnTripStack & execVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      execVolPgg ()->
         getPegTrips (theDemand, shipPer, execVolTrips);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::getCoExecVolTrips (
      WitDemand *          theDemand,
      WitPeriod            shipPer,
      WitBopEntTripStack & coExecVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      coExecVolPgg ()->
         getPegTrips (theDemand, shipPer, coExecVolTrips);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::getSubVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitSubTripStack & subVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      subVolPgg ()->
         getPegTrips (theDemand, shipPer, subVolTrips);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::getSupplyVolTrips (
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPartTripStack & supplyVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      supplyVolPgg ()->
         getPegTrips (theDemand, shipPer, supplyVolTrips);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::getProdVolTrips (
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPartTripStack & prodVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      prodVolPgg ()->
         getPegTrips (theDemand, shipPer, prodVolTrips);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::getConsVolTrips (
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPartTripStack & consVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      consVolPgg ()->
         getPegTrips (theDemand, shipPer, consVolTrips);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::getSideVolTrips (
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPartTripStack & sideVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      sideVolPgg ()->
         getPegTrips (theDemand, shipPer, sideVolTrips);

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipMgr::checkRestrictions ()
   {
   WitSubEntry * theSub;
   WitPeriod     execPer;

   if (not myPostprocessor ()->postprocessed ())
      myMsgFac () ("unpostPipSmsg");

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theSub->consRate ()[execPer] < 0.0)
            myMsgFac () ("pipNegSubConsRateSmsg",
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               execPer,
               theSub->consRate ()[execPer]);
   }

//------------------------------------------------------------------------------
// Implementation of class PipSeqMgr.
//------------------------------------------------------------------------------

WitPipSeqMgr::WitPipSeqMgr (WitProblem * theProblem):

      WitProbAssoc    (theProblem),
      revShipSeq_     (theProblem),
      shipPerForRead_ (-1)
   {
   }

//------------------------------------------------------------------------------

WitPipSeqMgr::~WitPipSeqMgr ()
   {
   clear ();
   }

//------------------------------------------------------------------------------

void WitPipSeqMgr::clear ()
   {
   revShipSeq_.clear ();
   }

//------------------------------------------------------------------------------

void WitPipSeqMgr::append (
      WitDemand * theDemand,
      WitPeriod   shipPer,
      double      incShipVol)
   {
   witAssert (incShipVol >= 0.0);

   if (incShipVol >= NET_TOL)
      revShipSeq_.push (theDemand, shipPer, incShipVol);
   }

//------------------------------------------------------------------------------

void WitPipSeqMgr::get (WitDemTripStack & theShipSeq)
   {
   theShipSeq.revCopyFrom (revShipSeq_);
   }

//------------------------------------------------------------------------------

void WitPipSeqMgr::reduce ()
   {
   WitSchedule <WitDemand, double> availShipVol  (myProblem (), 0.0);
   WitDemTripStack                 theShipSeq    (myProblem ());

   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      incShipVol;
   double      reduc;
   double      maxRed;
   WitDemand * maxRedDemand;
   WitPeriod   maxRedPer;

   maxRed = 0.0;

   forEachDemand (theDemand, myProblem ())
      availShipVol (theDemand) = theDemand->shipVol ();

   theShipSeq.takeContentsFrom (revShipSeq_);

   theShipSeq.reverse ();

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      if (incShipVol > availShipVol (theDemand)[shipPer])
         {
         reduc = incShipVol - availShipVol (theDemand)[shipPer];

         if (reduc > maxRed)
            {
            maxRed       = reduc;
            maxRedDemand = theDemand;
            maxRedPer    = shipPer;
            }

         incShipVol = availShipVol (theDemand)[shipPer];
         }

      availShipVol (theDemand)[shipPer] -= incShipVol;

      if (incShipVol > NET_TOL)
         append (theDemand, shipPer, incShipVol);
      }

   if (maxRed > 0.001)
      myMsgFac () ("pipSeqReducWmsg",
         maxRedDemand->demandedPartName (),
         maxRedDemand->demandName (),
         maxRedPer,
         maxRed);
   }

//------------------------------------------------------------------------------

void WitPipSeqMgr::display ()
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   myMsgFac () ("pipSeqHeadingDdMsg");

   if (revShipSeq_.isEmpty ())
      {
      myMsgFac () ("EmptyPipSeqDdMsg");

      return;
      }

   get (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      myMsgFac () ("pipShipTripDdMsg",
         theDemand->demandedPartName (),
         theDemand->demandName (),
         shipPer,
         incShipVol);
   }

//------------------------------------------------------------------------------

void WitPipSeqMgr::copy (WitPipSeqMgr * theSeqMgr)
   {
   WitDemTripStack theShipSeq (myProblem ());

   theSeqMgr->get (theShipSeq);

   theShipSeq.reverse ();

   revShipSeq_.takeContentsFrom (theShipSeq);
   }

//------------------------------------------------------------------------------

void WitPipSeqMgr::writeData ()
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   if (revShipSeq_.isEmpty ())
      return;

   myMsgFac () ("pipSeqPreCommentWdMsg");

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

   myDataWriter ()->writeBool         ("pipSeqClearsNow", true);

   myDataWriter ()->writeEndCommand ();

   get (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      myDataWriter ()->writeFirstKeyWord ("set");
      myDataWriter ()->writeKeyWord      ("demand");
      myDataWriter ()->writeStringValue  (theDemand->demandedPartName ());
      myDataWriter ()->writeStringValue  (theDemand->demandName       ());

      myDataWriter ()->writeInt          ("pipSeqShipPeriod", shipPer);

      myDataWriter ()->writeDouble       ("pipSeqIncShipVol", incShipVol);

      myDataWriter ()->writeEndCommand ();
      }

   myMsgFac () ("pipSeqPostCommentWdMsg");
   }

//------------------------------------------------------------------------------

void WitPipSeqMgr::setShipPerForRead (WitPeriod shipPer)
   {
   shipPerForRead_ = shipPer;
   }

//------------------------------------------------------------------------------
// Implementation of class PipPgg.
//------------------------------------------------------------------------------

WitPipPgg::WitPipPgg (WitProblem * theProblem):

      WitProbAssoc  (theProblem),
        execVolPgg_ (NULL),
      coExecVolPgg_ (NULL),
         subVolPgg_ (NULL),
      supplyVolPgg_ (NULL),
        prodVolPgg_ (NULL),
        consVolPgg_ (NULL),
        sideVolPgg_ (NULL)
   {
     execVolPgg_ = new WitPipAttPgg <WitOperation> (  "ExecVol", myProblem ());
   coExecVolPgg_ = new WitPipAttPgg <WitBopEntry>  ("CoExecVol", myProblem ());
      subVolPgg_ = new WitPipAttPgg <WitSubEntry>  (   "SubVol", myProblem ());
   supplyVolPgg_ = new WitPipAttPgg <WitPart>      ("SupplyVol", myProblem ());
     prodVolPgg_ = new WitPipAttPgg <WitPart>      (  "ProdVol", myProblem ());
     consVolPgg_ = new WitPipAttPgg <WitPart>      (  "ConsVol", myProblem ());
     sideVolPgg_ = new WitPipAttPgg <WitPart>      (  "SideVol", myProblem ());

   WitPipBldr::buildPegging (this);

   if (DEVELOPMENT)
      countTrips ();

   if (myProblem ()->myGlobalComp ()->inputPauses ())
      myProblem ()->pauseForInput ("at the conclusion of building PIP");
   }

//------------------------------------------------------------------------------

WitPipPgg::~WitPipPgg ()
   {
   delete   sideVolPgg_;
   delete   consVolPgg_;
   delete   prodVolPgg_;
   delete supplyVolPgg_;
   delete    subVolPgg_;
   delete coExecVolPgg_;
   delete   execVolPgg_;
   }

//------------------------------------------------------------------------------

void WitPipPgg::print ()
   {
   fprintf (solnFile (),
      "\n\n"
      "Post-Implosion Pegging:\n");

     execVolPgg_->print ();
   coExecVolPgg_->print ();
      subVolPgg_->print ();
   supplyVolPgg_->print ();
     prodVolPgg_->print ();
     consVolPgg_->print ();
     sideVolPgg_->print ();
   }

//------------------------------------------------------------------------------

void WitPipPgg::countTrips ()
   {
   int nTrips;

   nTrips =
          execVolPgg_->totTrips ()
      + coExecVolPgg_->totTrips ()
      +    subVolPgg_->totTrips ()
      + supplyVolPgg_->totTrips ()
      +   prodVolPgg_->totTrips ()
      +   consVolPgg_->totTrips ()
      +   sideVolPgg_->totTrips ();

   myMsgFac () ("totPegTripsMsg", nTrips);
   }

//------------------------------------------------------------------------------
// Implementation of class template PipAttPgg <SrcComp>.
//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPipAttPgg <SrcComp>::WitPipAttPgg (
            const char * theAttName,
            WitProblem * theProblem):

         WitProbAssoc (theProblem),

         myPegTrips_  (theProblem),
         myAttName_   (theAttName)
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      if (myPegTrips_.myPtrAt (theDemand, shipPer) == NULL)
         {
         myPegTrips_.myPtrAt (theDemand, shipPer) =
            new WitTripStack <SrcComp> (myProblem ());
         }
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPipAttPgg <SrcComp>::~WitPipAttPgg ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myPegTrips_.myPtrAt (theDemand, thePer);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::multiAppend (
         WitDemPerStack &                  theDemPers,
         SrcComp *                         theSrcComp,
         WitPeriod                         pegPer,
         WitSchedule <WitDemand, double> & pegVolSched)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      pegVol;

   while (theDemPers.pop (theDemand, shipPer))
      {
      pegVol = pegVolSched (theDemand)[shipPer];

      pegVolSched (theDemand)[shipPer] = 0.0;

      myPegTrips_.
         myElemAt (theDemand, shipPer).
            push (theSrcComp, pegPer, pegVol);
      }
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::consolidate ()
   {
   WitSchedule  <SrcComp, double>    totPegVol;
   WitDemand *                       theDemand;
   WitPeriod                         shipPer;
   WitTripStack <SrcComp> *          thePegTripsPtr;
   SrcComp *                         theSrcComp;
   WitPeriod                         thePer;
   double                            pegVol;
   WitPairStack <SrcComp, WitPeriod> pegPairs (myProblem ());

   totPegVol.allocate1D (myProblem ());

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         thePegTripsPtr = myPegTrips_.myPtrAt (theDemand, shipPer);

         if (thePegTripsPtr == NULL)
            continue;

         while (thePegTripsPtr->pop (theSrcComp, thePer, pegVol))
            {
            if (not totPegVol (theSrcComp).isAllocated ())
               totPegVol (theSrcComp).allocate (myProblem (), 0.0);

            totPegVol (theSrcComp)[thePer] += pegVol;

            pegPairs.push (theSrcComp, thePer);
            }

         while (pegPairs.pop (theSrcComp, thePer))
            {
            pegVol = totPegVol (theSrcComp)[thePer];

            if (pegVol == 0.0)
               continue;

            totPegVol (theSrcComp)[thePer] = 0.0;

            thePegTripsPtr->push (theSrcComp, thePer, pegVol);
            }
         }
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::getPegTrips (
         WitDemand *              theDemand,
         WitPeriod                shipPer,
         WitTripStack <SrcComp> & thePegTrips)
   {
   if (myPegTrips_.myPtrAt (theDemand, shipPer) != NULL)
      thePegTrips.
         revCopyFrom (
            myPegTrips_.
               myElemAt (theDemand, shipPer));
   else
      thePegTrips.clear ();
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::print ()
   {
   fprintf (solnFile (),
      "\n"
      "%s Pegging:\n"
      "\n",
      myAttName_.myCstring ());

   prtInner ();
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      double WitPipAttPgg <SrcComp>::pegVolFor (
         WitDemand * theDemand,
         WitPeriod   shipPer,
         SrcComp *   theSrcComp,
         WitPeriod   pegPer)
   {
   WitTripStack <SrcComp> thePegTrips (myProblem ());
   SrcComp *              tripSrcComp;
   WitPeriod              tripPer;
   double                 pegVol;

   getPegTrips (theDemand, shipPer, thePegTrips);

   while (thePegTrips.pop (tripSrcComp, tripPer, pegVol))
      if (tripSrcComp == theSrcComp)
         if (tripPer == pegPer)
            return pegVol;

   return 0.0;
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      int WitPipAttPgg <SrcComp>::totTrips ()
   {
   int         nTrips;
   WitDemand * theDemand;
   WitPeriod   shipPer;

   nTrips = 0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         if (myPegTrips_.myPtrAt (theDemand, shipPer) != NULL)
            nTrips += myPegTrips_.myElemAt (theDemand, shipPer).nElements ();

   return nTrips;
   }

//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitOperation>::prtInner ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   bool           pegVolPrinted;

   fprintf (solnFile (),
      "   -----------------------------\n"
      "   Opn  Per  Dem  Per    %7s\n"
      "   -----------------------------\n",
      myAttName_.myCstring ());

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         prtSrcCompPgg (theOpn, execPer, pegVolPrinted);

         if (pegVolPrinted)
            fprintf (solnFile (),
               "   -----------------------------\n");
         }
   }

//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitBopEntry>::prtInner ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   bool          pegVolPrinted;

   fprintf (solnFile (),
      "   ----------------------------------\n"
      "   Opn  Idx  Per  Dem  Per  %9s\n"
      "   ----------------------------------\n",
      myAttName_.myCstring ());

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         prtSrcCompPgg (theBopEnt, execPer, pegVolPrinted);

         if (pegVolPrinted)
            fprintf (solnFile (),
               "   ----------------------------------\n");
         }
   }

//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitSubEntry>::prtInner ()
   {
   WitSubEntry * theSub;
   WitPeriod     execPer;
   bool          pegVolPrinted;

   fprintf (solnFile (),
      "   ---------------------------------------\n"
      "   Opn  Idx  Idx  Per  Dem  Per     %6s\n"
      "   ---------------------------------------\n",
      myAttName_.myCstring ());

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         prtSrcCompPgg (theSub, execPer, pegVolPrinted);

         if (pegVolPrinted)
            fprintf (solnFile (),
               "   ---------------------------------------\n");
         }
   }

//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitPart>::prtInner ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   bool      pegVolPrinted;

   fprintf (solnFile (),
      "   ------------------------------\n"
      "   Part  Per  Dem  Per  %9s\n"
      "   ------------------------------\n",
      myAttName_.myCstring ());

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         prtSrcCompPgg (thePart, thePer, pegVolPrinted);

         if (pegVolPrinted)
            fprintf (solnFile (),
               "   ------------------------------\n");
         }
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::prtSrcCompPgg (
         SrcComp * theSrcComp,
         WitPeriod thePer,
         bool &    pegVolPrinted)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      pegVol;

   pegVolPrinted = false;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         pegVol = pegVolFor (theDemand, shipPer, theSrcComp, thePer);

         if (pegVol == 0.0)
            continue;

         prtSrcComp (pegVolPrinted? NULL: theSrcComp);

         if (pegVolPrinted)
            fprintf (solnFile (), "     ");
         else
            fprintf (solnFile (),
               "  %3d",
               thePer);

         fprintf (solnFile (),
            "  %3s  %3d  %9.3f\n",
            theDemand->demandName ().myCstring (),
            shipPer,
            pegVol);

         pegVolPrinted = true;
         }
   }

//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitOperation>::prtSrcComp (WitOperation * theOpn)
   {
   if (theOpn == NULL)
      fprintf (solnFile (), "      ");
   else
      fprintf (solnFile (),
         "   %3s",
         theOpn->operationName ().myCstring ());
   }

//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitBopEntry>::prtSrcComp (WitBopEntry * theBopEnt)
   {
   if (theBopEnt == NULL)
      fprintf (solnFile (), "           ");
   else
      fprintf (solnFile (),
         "   %3s  %3d",
         theBopEnt->myOperationName ().myCstring (),
         theBopEnt->localIndex ());
   }

//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitSubEntry>::prtSrcComp (WitSubEntry * theSub)
   {
   if (theSub == NULL)
      fprintf (solnFile (), "                ");
   else
      fprintf (solnFile (),
         "   %3s  %3d  %3d",
         theSub->myOperationName ().myCstring (),
         theSub->myBomEntIndex (),
         theSub->localIndex ());
   }

//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitPart>::prtSrcComp (WitPart * thePart)
   {
   if (thePart == NULL)
      fprintf (solnFile (), "       ");
   else
      fprintf (solnFile (),
         "   %4s",
         thePart->partName ().myCstring ());
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template PipAttPgg <SrcComp>.
//------------------------------------------------------------------------------

template class WitPipAttPgg <WitOperation>;
template class WitPipAttPgg <WitBopEntry>;
template class WitPipAttPgg <WitSubEntry>;
template class WitPipAttPgg <WitPart>;
@


1.156
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.155
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d45 1
a45 1
WitProbAssoc (theProblem),
d47 4
a50 4
mySeqMgr_    (NULL),
myPgg_       (NULL)
{
WitTimer::enterSection ("pip");
d52 1
a52 1
mySeqMgr_ = new WitPipSeqMgr (myProblem ());
d54 2
a55 2
WitTimer::leaveSection ("pip");
}
d60 2
a61 2
{
WitTimer::enterSection ("pip");
d63 2
a64 2
delete myPgg_;
delete mySeqMgr_;
d66 2
a67 2
WitTimer::leaveSection ("pip");
}
d72 2
a73 2
{
WitTimer::enterSection ("pip");
d75 1
a75 1
clearPegging ();
d77 1
a77 1
mySeqMgr_->clear ();
d79 2
a80 2
WitTimer::leaveSection ("pip");
}
d85 5
a89 5
WitDemand * theDemand,
WitPeriod   shipPer,
double      incShipVol)
{
WitTimer::enterSection ("pip");
d91 1
a91 1
clearPegging ();
d93 1
a93 1
mySeqMgr_->append (theDemand, shipPer, incShipVol);
d95 2
a96 2
WitTimer::leaveSection ("pip");
}
d101 2
a102 2
{
WitTimer::enterSection ("pip");
d104 1
a104 1
mySeqMgr_->get (theShipSeq);
d106 2
a107 2
WitTimer::leaveSection ("pip");
}
d112 3
a114 3
{
mySeqMgr_->display ();
}
d119 2
a120 2
{
WitTimer::enterSection ("pip");
d122 1
a122 1
mySeqMgr_->copy (thePipMgr->mySeqMgr_);
d124 2
a125 2
WitTimer::leaveSection ("pip");
}
d128 1
a128 1

d130 3
a132 3
{
mySeqMgr_->writeData ();
}
d137 3
a139 3
{
mySeqMgr_->setShipPerForRead (shipPer);
}
d144 3
a146 3
{
return mySeqMgr_->shipPerForRead ();
}
d151 2
a152 2
{
WitTimer::enterSection ("pip");
d154 1
a154 1
myMsgFac () ("pipMsg");
d156 2
a157 2
if (not myGlobalComp ()->newPipPggOrder ())
myMsgFac () ("oldPipPggOrderMsg");
d159 1
a159 1
checkRestrictions ();
d161 1
a161 1
mySeqMgr_->reduce ();
d163 1
a163 1
clearPegging ();
d165 1
a165 1
myPgg_ = new WitPipPgg (myProblem ());
d167 2
a168 2
WitTimer::leaveSection ("pip");
}
d173 9
a181 9
{
if (not peggingExists ())
return;

WitTimer::enterSection ("pip");

delete myPgg ();

myPgg_ = NULL;
d183 2
a184 2
WitTimer::leaveSection ("pip");
}
d189 4
a192 4
{
if (peggingExists ())
myPgg ()->print ();
}
d197 9
a205 9
WitDemand *       theDemand,
WitPeriod         shipPer,
WitOpnTripStack & execVolTrips)
{
WitTimer::enterSection ("pip");

myPgg ()->
execVolPgg ()->
getPegTrips (theDemand, shipPer, execVolTrips);
d207 2
a208 2
WitTimer::leaveSection ("pip");
}
d213 9
a221 9
WitDemand *          theDemand,
WitPeriod            shipPer,
WitBopEntTripStack & coExecVolTrips)
{
WitTimer::enterSection ("pip");

myPgg ()->
coExecVolPgg ()->
getPegTrips (theDemand, shipPer, coExecVolTrips);
d223 2
a224 2
WitTimer::leaveSection ("pip");
}
d229 9
a237 9
WitDemand *       theDemand,
WitPeriod         shipPer,
WitSubTripStack & subVolTrips)
{
WitTimer::enterSection ("pip");

myPgg ()->
subVolPgg ()->
getPegTrips (theDemand, shipPer, subVolTrips);
d239 2
a240 2
WitTimer::leaveSection ("pip");
}
d245 9
a253 9
WitDemand *        theDemand,
WitPeriod          shipPer,
WitPartTripStack & supplyVolTrips)
{
WitTimer::enterSection ("pip");

myPgg ()->
supplyVolPgg ()->
getPegTrips (theDemand, shipPer, supplyVolTrips);
d255 2
a256 2
WitTimer::leaveSection ("pip");
}
d261 9
a269 9
WitDemand *        theDemand,
WitPeriod          shipPer,
WitPartTripStack & prodVolTrips)
{
WitTimer::enterSection ("pip");

myPgg ()->
prodVolPgg ()->
getPegTrips (theDemand, shipPer, prodVolTrips);
d271 2
a272 2
WitTimer::leaveSection ("pip");
}
d277 9
a285 9
WitDemand *        theDemand,
WitPeriod          shipPer,
WitPartTripStack & consVolTrips)
{
WitTimer::enterSection ("pip");

myPgg ()->
consVolPgg ()->
getPegTrips (theDemand, shipPer, consVolTrips);
d287 2
a288 2
WitTimer::leaveSection ("pip");
}
d293 9
a301 9
WitDemand *        theDemand,
WitPeriod          shipPer,
WitPartTripStack & sideVolTrips)
{
WitTimer::enterSection ("pip");

myPgg ()->
sideVolPgg ()->
getPegTrips (theDemand, shipPer, sideVolTrips);
d303 2
a304 2
WitTimer::leaveSection ("pip");
}
d309 17
a325 17
{
WitSubEntry * theSub;
WitPeriod     execPer;

if (not myPostprocessor ()->postprocessed ())
myMsgFac () ("unpostPipSmsg");

forEachSubEntry (theSub, myProblem ())
forEachPeriod (execPer, myProblem ())
if (theSub->consRate ()[execPer] < 0.0)
myMsgFac () ("pipNegSubConsRateSmsg",
theSub->myOperationName (),
theSub->myBomEntIndex (),
theSub->localIndex (),
execPer,
theSub->consRate ()[execPer]);
}
d333 5
a337 5
WitProbAssoc    (theProblem),
revShipSeq_     (theProblem),
shipPerForRead_ (-1)
{
}
d342 3
a344 3
{
clear ();
}
d349 3
a351 3
{
revShipSeq_.clear ();
}
d356 9
a364 9
WitDemand * theDemand,
WitPeriod   shipPer,
double      incShipVol)
{
witAssert (incShipVol >= 0.0);

if (incShipVol >= NET_TOL)
revShipSeq_.push (theDemand, shipPer, incShipVol);
}
d369 3
a371 3
{
theShipSeq.revCopyFrom (revShipSeq_);
}
d376 50
a425 50
{
WitSchedule <WitDemand, double> availShipVol  (myProblem (), 0.0);
WitDemTripStack                 theShipSeq    (myProblem ());

WitDemand * theDemand;
WitPeriod   shipPer;
double      incShipVol;
double      reduc;
double      maxRed;
WitDemand * maxRedDemand;
WitPeriod   maxRedPer;

maxRed = 0.0;

forEachDemand (theDemand, myProblem ())
availShipVol (theDemand) = theDemand->shipVol ();

theShipSeq.takeContentsFrom (revShipSeq_);

theShipSeq.reverse ();

while (theShipSeq.pop (theDemand, shipPer, incShipVol))
{
if (incShipVol > availShipVol (theDemand)[shipPer])
{
reduc = incShipVol - availShipVol (theDemand)[shipPer];

if (reduc > maxRed)
{
maxRed       = reduc;
maxRedDemand = theDemand;
maxRedPer    = shipPer;
}

incShipVol = availShipVol (theDemand)[shipPer];
}

availShipVol (theDemand)[shipPer] -= incShipVol;

if (incShipVol > NET_TOL)
append (theDemand, shipPer, incShipVol);
}

if (maxRed > 0.001)
myMsgFac () ("pipSeqReducWmsg",
maxRedDemand->demandedPartName (),
maxRedDemand->demandName (),
maxRedPer,
maxRed);
}
d430 24
a453 24
{
WitDemTripStack theShipSeq (myProblem ());
WitDemand *     theDemand;
WitPeriod       shipPer;
double          incShipVol;

myMsgFac () ("pipSeqHeadingDdMsg");

if (revShipSeq_.isEmpty ())
{
myMsgFac () ("EmptyPipSeqDdMsg");

return;
}

get (theShipSeq);

while (theShipSeq.pop (theDemand, shipPer, incShipVol))
myMsgFac () ("pipShipTripDdMsg",
theDemand->demandedPartName (),
theDemand->demandName (),
shipPer,
incShipVol);
}
d458 2
a459 2
{
WitDemTripStack theShipSeq (myProblem ());
d461 1
a461 1
theSeqMgr->get (theShipSeq);
d463 1
a463 1
theShipSeq.reverse ();
d465 2
a466 2
revShipSeq_.takeContentsFrom (theShipSeq);
}
d471 5
a475 5
{
WitDemTripStack theShipSeq (myProblem ());
WitDemand *     theDemand;
WitPeriod       shipPer;
double          incShipVol;
d477 2
a478 2
if (revShipSeq_.isEmpty ())
return;
d480 1
a480 1
myMsgFac () ("pipSeqPreCommentWdMsg");
d482 2
a483 2
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("problem");
d485 1
a485 1
myDataWriter ()->writeBool         ("pipSeqClearsNow", true);
d487 1
a487 1
myDataWriter ()->writeEndCommand ();
d489 1
a489 1
get (theShipSeq);
d491 6
a496 6
while (theShipSeq.pop (theDemand, shipPer, incShipVol))
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("demand");
myDataWriter ()->writeStringValue  (theDemand->demandedPartName ());
myDataWriter ()->writeStringValue  (theDemand->demandName       ());
d498 1
a498 1
myDataWriter ()->writeInt          ("pipSeqShipPeriod", shipPer);
d500 1
a500 1
myDataWriter ()->writeDouble       ("pipSeqIncShipVol", incShipVol);
d502 2
a503 2
myDataWriter ()->writeEndCommand ();
}
d505 2
a506 2
myMsgFac () ("pipSeqPostCommentWdMsg");
}
d511 3
a513 3
{
shipPerForRead_ = shipPer;
}
d521 25
a545 25
WitProbAssoc  (theProblem),
execVolPgg_ (NULL),
coExecVolPgg_ (NULL),
subVolPgg_ (NULL),
supplyVolPgg_ (NULL),
prodVolPgg_ (NULL),
consVolPgg_ (NULL),
sideVolPgg_ (NULL)
{
execVolPgg_ = new WitPipAttPgg <WitOperation> (  "ExecVol", myProblem ());
coExecVolPgg_ = new WitPipAttPgg <WitBopEntry>  ("CoExecVol", myProblem ());
subVolPgg_ = new WitPipAttPgg <WitSubEntry>  (   "SubVol", myProblem ());
supplyVolPgg_ = new WitPipAttPgg <WitPart>      ("SupplyVol", myProblem ());
prodVolPgg_ = new WitPipAttPgg <WitPart>      (  "ProdVol", myProblem ());
consVolPgg_ = new WitPipAttPgg <WitPart>      (  "ConsVol", myProblem ());
sideVolPgg_ = new WitPipAttPgg <WitPart>      (  "SideVol", myProblem ());

WitPipBldr::buildPegging (this);

if (DEVELOPMENT)
countTrips ();

if (myProblem ()->myGlobalComp ()->inputPauses ())
myProblem ()->pauseForInput ("at the conclusion of building PIP");
}
d550 9
a558 9
{
delete   sideVolPgg_;
delete   consVolPgg_;
delete   prodVolPgg_;
delete supplyVolPgg_;
delete    subVolPgg_;
delete coExecVolPgg_;
delete   execVolPgg_;
}
d563 13
a575 13
{
fprintf (solnFile (),
"\n\n"
"Post-Implosion Pegging:\n");

execVolPgg_->print ();
coExecVolPgg_->print ();
subVolPgg_->print ();
supplyVolPgg_->print ();
prodVolPgg_->print ();
consVolPgg_->print ();
sideVolPgg_->print ();
}
d580 2
a581 2
{
int nTrips;
d583 8
a590 8
nTrips =
execVolPgg_->totTrips ()
+ coExecVolPgg_->totTrips ()
+    subVolPgg_->totTrips ()
+ supplyVolPgg_->totTrips ()
+   prodVolPgg_->totTrips ()
+   consVolPgg_->totTrips ()
+   sideVolPgg_->totTrips ();
d592 2
a593 2
myMsgFac () ("totPegTripsMsg", nTrips);
}
d599 181
a779 181
template <typename SrcComp>
WitPipAttPgg <SrcComp>::WitPipAttPgg (
const char * theAttName,
WitProblem * theProblem):

WitProbAssoc (theProblem),

myPegTrips_  (theProblem),
myAttName_   (theAttName)
{
WitDemTripStack theShipSeq (myProblem ());
WitDemand *     theDemand;
WitPeriod       shipPer;
double          incShipVol;

myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

while (theShipSeq.pop (theDemand, shipPer, incShipVol))
if (myPegTrips_.myPtrAt (theDemand, shipPer) == NULL)
{
myPegTrips_.myPtrAt (theDemand, shipPer) =
new WitTripStack <SrcComp> (myProblem ());
}
}

//------------------------------------------------------------------------------

template <typename SrcComp>
WitPipAttPgg <SrcComp>::~WitPipAttPgg ()
{
WitDemand * theDemand;
WitPeriod   thePer;

forEachDemand (theDemand, myProblem ())
forEachPeriod (thePer, myProblem ())
delete myPegTrips_.myPtrAt (theDemand, thePer);
}

//------------------------------------------------------------------------------

template <typename SrcComp>
void WitPipAttPgg <SrcComp>::multiAppend (
WitDemPerStack &                  theDemPers,
SrcComp *                         theSrcComp,
WitPeriod                         pegPer,
WitSchedule <WitDemand, double> & pegVolSched)
{
WitDemand * theDemand;
WitPeriod   shipPer;
double      pegVol;

while (theDemPers.pop (theDemand, shipPer))
{
pegVol = pegVolSched (theDemand)[shipPer];

pegVolSched (theDemand)[shipPer] = 0.0;

myPegTrips_.
myElemAt (theDemand, shipPer).
push (theSrcComp, pegPer, pegVol);
}
}

//------------------------------------------------------------------------------

template <typename SrcComp>
void WitPipAttPgg <SrcComp>::consolidate ()
{
WitSchedule  <SrcComp, double>    totPegVol;
WitDemand *                       theDemand;
WitPeriod                         shipPer;
WitTripStack <SrcComp> *          thePegTripsPtr;
SrcComp *                         theSrcComp;
WitPeriod                         thePer;
double                            pegVol;
WitPairStack <SrcComp, WitPeriod> pegPairs (myProblem ());

totPegVol.allocate1D (myProblem ());

forEachDemand (theDemand, myProblem ())
forEachPeriod (shipPer, myProblem ())
{
thePegTripsPtr = myPegTrips_.myPtrAt (theDemand, shipPer);

if (thePegTripsPtr == NULL)
continue;

while (thePegTripsPtr->pop (theSrcComp, thePer, pegVol))
{
if (not totPegVol (theSrcComp).isAllocated ())
totPegVol (theSrcComp).allocate (myProblem (), 0.0);

totPegVol (theSrcComp)[thePer] += pegVol;

pegPairs.push (theSrcComp, thePer);
}

while (pegPairs.pop (theSrcComp, thePer))
{
pegVol = totPegVol (theSrcComp)[thePer];

if (pegVol == 0.0)
continue;

totPegVol (theSrcComp)[thePer] = 0.0;

thePegTripsPtr->push (theSrcComp, thePer, pegVol);
}
}
}

//------------------------------------------------------------------------------

template <typename SrcComp>
void WitPipAttPgg <SrcComp>::getPegTrips (
WitDemand *              theDemand,
WitPeriod                shipPer,
WitTripStack <SrcComp> & thePegTrips)
{
if (myPegTrips_.myPtrAt (theDemand, shipPer) != NULL)
thePegTrips.
revCopyFrom (
myPegTrips_.
myElemAt (theDemand, shipPer));
else
thePegTrips.clear ();
}

//------------------------------------------------------------------------------

template <typename SrcComp>
void WitPipAttPgg <SrcComp>::print ()
{
fprintf (solnFile (),
"\n"
"%s Pegging:\n"
"\n",
myAttName_.myCstring ());

prtInner ();
}

//------------------------------------------------------------------------------

template <typename SrcComp>
double WitPipAttPgg <SrcComp>::pegVolFor (
WitDemand * theDemand,
WitPeriod   shipPer,
SrcComp *   theSrcComp,
WitPeriod   pegPer)
{
WitTripStack <SrcComp> thePegTrips (myProblem ());
SrcComp *              tripSrcComp;
WitPeriod              tripPer;
double                 pegVol;

getPegTrips (theDemand, shipPer, thePegTrips);

while (thePegTrips.pop (tripSrcComp, tripPer, pegVol))
if (tripSrcComp == theSrcComp)
if (tripPer == pegPer)
return pegVol;

return 0.0;
}

//------------------------------------------------------------------------------

template <typename SrcComp>
int WitPipAttPgg <SrcComp>::totTrips ()
{
int         nTrips;
WitDemand * theDemand;
WitPeriod   shipPer;

nTrips = 0;

forEachDemand (theDemand, myProblem ())
forEachPeriod (shipPer, myProblem ())
if (myPegTrips_.myPtrAt (theDemand, shipPer) != NULL)
nTrips += myPegTrips_.myElemAt (theDemand, shipPer).nElements ();
d781 2
a782 2
return nTrips;
}
d787 22
a808 22
void WitPipAttPgg <WitOperation>::prtInner ()
{
WitOperation * theOpn;
WitPeriod      execPer;
bool           pegVolPrinted;

fprintf (solnFile (),
"   -----------------------------\n"
"   Opn  Per  Dem  Per    %7s\n"
"   -----------------------------\n",
myAttName_.myCstring ());

forEachOperation (theOpn, myProblem ())
forEachPeriod (execPer, myProblem ())
{
prtSrcCompPgg (theOpn, execPer, pegVolPrinted);

if (pegVolPrinted)
fprintf (solnFile (),
"   -----------------------------\n");
}
}
d813 22
a834 22
void WitPipAttPgg <WitBopEntry>::prtInner ()
{
WitBopEntry * theBopEnt;
WitPeriod     execPer;
bool          pegVolPrinted;

fprintf (solnFile (),
"   ----------------------------------\n"
"   Opn  Idx  Per  Dem  Per  %9s\n"
"   ----------------------------------\n",
myAttName_.myCstring ());

forEachBopEntry (theBopEnt, myProblem ())
forEachPeriod (execPer, myProblem ())
{
prtSrcCompPgg (theBopEnt, execPer, pegVolPrinted);

if (pegVolPrinted)
fprintf (solnFile (),
"   ----------------------------------\n");
}
}
d839 22
a860 22
void WitPipAttPgg <WitSubEntry>::prtInner ()
{
WitSubEntry * theSub;
WitPeriod     execPer;
bool          pegVolPrinted;

fprintf (solnFile (),
"   ---------------------------------------\n"
"   Opn  Idx  Idx  Per  Dem  Per     %6s\n"
"   ---------------------------------------\n",
myAttName_.myCstring ());

forEachSubEntry (theSub, myProblem ())
forEachPeriod (execPer, myProblem ())
{
prtSrcCompPgg (theSub, execPer, pegVolPrinted);

if (pegVolPrinted)
fprintf (solnFile (),
"   ---------------------------------------\n");
}
}
d865 22
a886 22
void WitPipAttPgg <WitPart>::prtInner ()
{
WitPart * thePart;
WitPeriod thePer;
bool      pegVolPrinted;

fprintf (solnFile (),
"   ------------------------------\n"
"   Part  Per  Dem  Per  %9s\n"
"   ------------------------------\n",
myAttName_.myCstring ());

forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
{
prtSrcCompPgg (thePart, thePer, pegVolPrinted);

if (pegVolPrinted)
fprintf (solnFile (),
"   ------------------------------\n");
}
}
d890 38
a927 38
template <typename SrcComp>
void WitPipAttPgg <SrcComp>::prtSrcCompPgg (
SrcComp * theSrcComp,
WitPeriod thePer,
bool &    pegVolPrinted)
{
WitDemand * theDemand;
WitPeriod   shipPer;
double      pegVol;

pegVolPrinted = false;

forEachDemand (theDemand, myProblem ())
forEachPeriod (shipPer, myProblem ())
{
pegVol = pegVolFor (theDemand, shipPer, theSrcComp, thePer);

if (pegVol == 0.0)
continue;

prtSrcComp (pegVolPrinted? NULL: theSrcComp);

if (pegVolPrinted)
fprintf (solnFile (), "     ");
else
fprintf (solnFile (),
"  %3d",
thePer);

fprintf (solnFile (),
"  %3s  %3d  %9.3f\n",
theDemand->demandName ().myCstring (),
shipPer,
pegVol);

pegVolPrinted = true;
}
}
d932 9
a940 9
void WitPipAttPgg <WitOperation>::prtSrcComp (WitOperation * theOpn)
{
if (theOpn == NULL)
fprintf (solnFile (), "      ");
else
fprintf (solnFile (),
"   %3s",
theOpn->operationName ().myCstring ());
}
d945 10
a954 10
void WitPipAttPgg <WitBopEntry>::prtSrcComp (WitBopEntry * theBopEnt)
{
if (theBopEnt == NULL)
fprintf (solnFile (), "           ");
else
fprintf (solnFile (),
"   %3s  %3d",
theBopEnt->myOperationName ().myCstring (),
theBopEnt->localIndex ());
}
d959 11
a969 11
void WitPipAttPgg <WitSubEntry>::prtSrcComp (WitSubEntry * theSub)
{
if (theSub == NULL)
fprintf (solnFile (), "                ");
else
fprintf (solnFile (),
"   %3s  %3d  %3d",
theSub->myOperationName ().myCstring (),
theSub->myBomEntIndex (),
theSub->localIndex ());
}
d974 9
a982 9
void WitPipAttPgg <WitPart>::prtSrcComp (WitPart * thePart)
{
if (thePart == NULL)
fprintf (solnFile (), "       ");
else
fprintf (solnFile (),
"   %4s",
thePart->partName ().myCstring ());
}
@


1.154
log
@CPLEX Parameters
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d45 1
a45 1
      WitProbAssoc (theProblem),
d47 4
a50 4
      mySeqMgr_    (NULL),
      myPgg_       (NULL)
   {
   WitTimer::enterSection ("pip");
d52 1
a52 1
   mySeqMgr_ = new WitPipSeqMgr (myProblem ());
d54 2
a55 2
   WitTimer::leaveSection ("pip");
   }
d60 2
a61 2
   {
   WitTimer::enterSection ("pip");
d63 2
a64 2
   delete myPgg_;
   delete mySeqMgr_;
d66 2
a67 2
   WitTimer::leaveSection ("pip");
   }
d72 2
a73 2
   {
   WitTimer::enterSection ("pip");
d75 1
a75 1
   clearPegging ();
d77 1
a77 1
   mySeqMgr_->clear ();
d79 2
a80 2
   WitTimer::leaveSection ("pip");
   }
d85 5
a89 5
      WitDemand * theDemand,
      WitPeriod   shipPer,
      double      incShipVol)
   {
   WitTimer::enterSection ("pip");
d91 1
a91 1
   clearPegging ();
d93 1
a93 1
   mySeqMgr_->append (theDemand, shipPer, incShipVol);
d95 2
a96 2
   WitTimer::leaveSection ("pip");
   }
d101 2
a102 2
   {
   WitTimer::enterSection ("pip");
d104 1
a104 1
   mySeqMgr_->get (theShipSeq);
d106 2
a107 2
   WitTimer::leaveSection ("pip");
   }
d112 3
a114 3
   {
   mySeqMgr_->display ();
   }
d119 2
a120 2
   {
   WitTimer::enterSection ("pip");
d122 1
a122 1
   mySeqMgr_->copy (thePipMgr->mySeqMgr_);
d124 2
a125 2
   WitTimer::leaveSection ("pip");
   }
d128 1
a128 1
 
d130 3
a132 3
   {
   mySeqMgr_->writeData ();
   }
d137 3
a139 3
   {
   mySeqMgr_->setShipPerForRead (shipPer);
   }
d144 3
a146 3
   {
   return mySeqMgr_->shipPerForRead ();
   }
d151 2
a152 2
   {
   WitTimer::enterSection ("pip");
d154 1
a154 1
   myMsgFac () ("pipMsg");
d156 2
a157 2
   if (not myGlobalComp ()->newPipPggOrder ())
      myMsgFac () ("oldPipPggOrderMsg");
d159 1
a159 1
   checkRestrictions ();
d161 1
a161 1
   mySeqMgr_->reduce ();
d163 1
a163 1
   clearPegging ();
d165 1
a165 1
   myPgg_ = new WitPipPgg (myProblem ());
d167 2
a168 2
   WitTimer::leaveSection ("pip");
   }
d173 9
a181 9
   {
   if (not peggingExists ())
      return;

   WitTimer::enterSection ("pip");

   delete myPgg ();
   
   myPgg_ = NULL;
d183 2
a184 2
   WitTimer::leaveSection ("pip");
   }
d189 4
a192 4
   {
   if (peggingExists ())
      myPgg ()->print ();
   }
d197 9
a205 9
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitOpnTripStack & execVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      execVolPgg ()->
         getPegTrips (theDemand, shipPer, execVolTrips);
d207 2
a208 2
   WitTimer::leaveSection ("pip");
   }
d213 9
a221 9
      WitDemand *          theDemand,
      WitPeriod            shipPer,
      WitBopEntTripStack & coExecVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      coExecVolPgg ()->
         getPegTrips (theDemand, shipPer, coExecVolTrips);
d223 2
a224 2
   WitTimer::leaveSection ("pip");
   }
d229 9
a237 9
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitSubTripStack & subVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      subVolPgg ()->
         getPegTrips (theDemand, shipPer, subVolTrips);
d239 2
a240 2
   WitTimer::leaveSection ("pip");
   }
d245 9
a253 9
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPartTripStack & supplyVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      supplyVolPgg ()->
         getPegTrips (theDemand, shipPer, supplyVolTrips);
d255 2
a256 2
   WitTimer::leaveSection ("pip");
   }
d261 9
a269 9
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPartTripStack & prodVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      prodVolPgg ()->
         getPegTrips (theDemand, shipPer, prodVolTrips);
d271 2
a272 2
   WitTimer::leaveSection ("pip");
   }
d277 9
a285 9
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPartTripStack & consVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      consVolPgg ()->
         getPegTrips (theDemand, shipPer, consVolTrips);
d287 2
a288 2
   WitTimer::leaveSection ("pip");
   }
d293 9
a301 9
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPartTripStack & sideVolTrips)
   {
   WitTimer::enterSection ("pip");

   myPgg ()->
      sideVolPgg ()->
         getPegTrips (theDemand, shipPer, sideVolTrips);
d303 2
a304 2
   WitTimer::leaveSection ("pip");
   }
d309 17
a325 17
   {
   WitSubEntry * theSub;
   WitPeriod     execPer;

   if (not myPostprocessor ()->postprocessed ())
      myMsgFac () ("unpostPipSmsg");

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theSub->consRate ()[execPer] < 0.0)
            myMsgFac () ("pipNegSubConsRateSmsg",
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               execPer,
               theSub->consRate ()[execPer]);
   }
d333 5
a337 5
      WitProbAssoc    (theProblem),
      revShipSeq_     (theProblem),
      shipPerForRead_ (-1)
   {
   }
d342 3
a344 3
   {
   clear ();
   }
d349 3
a351 3
   {
   revShipSeq_.clear ();
   }
d356 9
a364 9
      WitDemand * theDemand,
      WitPeriod   shipPer,
      double      incShipVol)
   {
   witAssert (incShipVol >= 0.0);

   if (incShipVol >= NET_TOL)
      revShipSeq_.push (theDemand, shipPer, incShipVol);
   }
d369 3
a371 3
   {
   theShipSeq.revCopyFrom (revShipSeq_);
   }
d376 50
a425 50
   {
   WitSchedule <WitDemand, double> availShipVol  (myProblem (), 0.0);
   WitDemTripStack                 theShipSeq    (myProblem ());

   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      incShipVol;
   double      reduc;
   double      maxRed;
   WitDemand * maxRedDemand;
   WitPeriod   maxRedPer;

   maxRed = 0.0;

   forEachDemand (theDemand, myProblem ())
      availShipVol (theDemand) = theDemand->shipVol ();

   theShipSeq.takeContentsFrom (revShipSeq_);

   theShipSeq.reverse ();

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      if (incShipVol > availShipVol (theDemand)[shipPer])
         {
         reduc = incShipVol - availShipVol (theDemand)[shipPer];

         if (reduc > maxRed)
            {
            maxRed       = reduc;
            maxRedDemand = theDemand;
            maxRedPer    = shipPer;
            }

         incShipVol = availShipVol (theDemand)[shipPer];
         }

      availShipVol (theDemand)[shipPer] -= incShipVol;

      if (incShipVol > NET_TOL)
         append (theDemand, shipPer, incShipVol);
      }

   if (maxRed > 0.001)
      myMsgFac () ("pipSeqReducWmsg",
         maxRedDemand->demandedPartName (),
         maxRedDemand->demandName (),
         maxRedPer,
         maxRed);
   }
d430 24
a453 24
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   myMsgFac () ("pipSeqHeadingDdMsg");

   if (revShipSeq_.isEmpty ())
      {
      myMsgFac () ("EmptyPipSeqDdMsg");

      return;
      }

   get (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      myMsgFac () ("pipShipTripDdMsg",
         theDemand->demandedPartName (),
         theDemand->demandName (),
         shipPer,
         incShipVol);
   }
d458 2
a459 2
   {
   WitDemTripStack theShipSeq (myProblem ());
d461 1
a461 1
   theSeqMgr->get (theShipSeq);
d463 1
a463 1
   theShipSeq.reverse ();
d465 2
a466 2
   revShipSeq_.takeContentsFrom (theShipSeq);
   }
d471 5
a475 5
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;
d477 2
a478 2
   if (revShipSeq_.isEmpty ())
      return;
d480 1
a480 1
   myMsgFac () ("pipSeqPreCommentWdMsg");
d482 2
a483 2
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
d485 1
a485 1
   myDataWriter ()->writeBool         ("pipSeqClearsNow", true);
d487 1
a487 1
   myDataWriter ()->writeEndCommand ();
d489 1
a489 1
   get (theShipSeq);
d491 6
a496 6
   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      myDataWriter ()->writeFirstKeyWord ("set");
      myDataWriter ()->writeKeyWord      ("demand");
      myDataWriter ()->writeStringValue  (theDemand->demandedPartName ());
      myDataWriter ()->writeStringValue  (theDemand->demandName       ());
d498 1
a498 1
      myDataWriter ()->writeInt          ("pipSeqShipPeriod", shipPer);
d500 1
a500 1
      myDataWriter ()->writeDouble       ("pipSeqIncShipVol", incShipVol);
d502 2
a503 2
      myDataWriter ()->writeEndCommand ();
      }
d505 2
a506 2
   myMsgFac () ("pipSeqPostCommentWdMsg");
   }
d511 3
a513 3
   {
   shipPerForRead_ = shipPer;
   }
d521 25
a545 25
      WitProbAssoc  (theProblem),
        execVolPgg_ (NULL),
      coExecVolPgg_ (NULL),
         subVolPgg_ (NULL),
      supplyVolPgg_ (NULL),
        prodVolPgg_ (NULL),
        consVolPgg_ (NULL),
        sideVolPgg_ (NULL)
   {
     execVolPgg_ = new WitPipAttPgg <WitOperation> (  "ExecVol", myProblem ());
   coExecVolPgg_ = new WitPipAttPgg <WitBopEntry>  ("CoExecVol", myProblem ());
      subVolPgg_ = new WitPipAttPgg <WitSubEntry>  (   "SubVol", myProblem ());
   supplyVolPgg_ = new WitPipAttPgg <WitPart>      ("SupplyVol", myProblem ());
     prodVolPgg_ = new WitPipAttPgg <WitPart>      (  "ProdVol", myProblem ());
     consVolPgg_ = new WitPipAttPgg <WitPart>      (  "ConsVol", myProblem ());
     sideVolPgg_ = new WitPipAttPgg <WitPart>      (  "SideVol", myProblem ());

   WitPipBldr::buildPegging (this);

   if (DEVELOPMENT)
      countTrips ();

   if (myProblem ()->myGlobalComp ()->inputPauses ())
      myProblem ()->pauseForInput ("at the conclusion of building PIP");
   }
d550 9
a558 9
   {
   delete   sideVolPgg_;
   delete   consVolPgg_;
   delete   prodVolPgg_;
   delete supplyVolPgg_;
   delete    subVolPgg_;
   delete coExecVolPgg_;
   delete   execVolPgg_;
   }
d563 13
a575 13
   {
   fprintf (solnFile (),
      "\n\n"
      "Post-Implosion Pegging:\n");

     execVolPgg_->print ();
   coExecVolPgg_->print ();
      subVolPgg_->print ();
   supplyVolPgg_->print ();
     prodVolPgg_->print ();
     consVolPgg_->print ();
     sideVolPgg_->print ();
   }
d580 2
a581 2
   {
   int nTrips;
d583 8
a590 8
   nTrips =
          execVolPgg_->totTrips ()
      + coExecVolPgg_->totTrips ()
      +    subVolPgg_->totTrips ()
      + supplyVolPgg_->totTrips ()
      +   prodVolPgg_->totTrips ()
      +   consVolPgg_->totTrips ()
      +   sideVolPgg_->totTrips ();
d592 2
a593 2
   myMsgFac () ("totPegTripsMsg", nTrips);
   }
d599 181
a779 181
template <typename SrcComp> 
      WitPipAttPgg <SrcComp>::WitPipAttPgg (
            const char * theAttName,
            WitProblem * theProblem):

         WitProbAssoc (theProblem),

         myPegTrips_  (theProblem),
         myAttName_   (theAttName)
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      if (myPegTrips_.myPtrAt (theDemand, shipPer) == NULL)
         {
         myPegTrips_.myPtrAt (theDemand, shipPer) =
            new WitTripStack <SrcComp> (myProblem ());
         }
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPipAttPgg <SrcComp>::~WitPipAttPgg ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myPegTrips_.myPtrAt (theDemand, thePer);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::multiAppend (
         WitDemPerStack &                  theDemPers,
         SrcComp *                         theSrcComp,
         WitPeriod                         pegPer,
         WitSchedule <WitDemand, double> & pegVolSched)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      pegVol;

   while (theDemPers.pop (theDemand, shipPer))
      {
      pegVol = pegVolSched (theDemand)[shipPer];

      pegVolSched (theDemand)[shipPer] = 0.0;

      myPegTrips_.
         myElemAt (theDemand, shipPer).
            push (theSrcComp, pegPer, pegVol);
      }
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::consolidate ()
   {
   WitSchedule  <SrcComp, double>    totPegVol;
   WitDemand *                       theDemand;
   WitPeriod                         shipPer;
   WitTripStack <SrcComp> *          thePegTripsPtr;
   SrcComp *                         theSrcComp;
   WitPeriod                         thePer;
   double                            pegVol;
   WitPairStack <SrcComp, WitPeriod> pegPairs (myProblem ());

   totPegVol.allocate1D (myProblem ());

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         thePegTripsPtr = myPegTrips_.myPtrAt (theDemand, shipPer);

         if (thePegTripsPtr == NULL)
            continue;

         while (thePegTripsPtr->pop (theSrcComp, thePer, pegVol))
            {
            if (not totPegVol (theSrcComp).isAllocated ())
               totPegVol (theSrcComp).allocate (myProblem (), 0.0);

            totPegVol (theSrcComp)[thePer] += pegVol;

            pegPairs.push (theSrcComp, thePer);
            }

         while (pegPairs.pop (theSrcComp, thePer))
            {
            pegVol = totPegVol (theSrcComp)[thePer];

            if (pegVol == 0.0)
               continue;

            totPegVol (theSrcComp)[thePer] = 0.0;

            thePegTripsPtr->push (theSrcComp, thePer, pegVol);
            }
         }
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::getPegTrips (
         WitDemand *              theDemand,
         WitPeriod                shipPer,
         WitTripStack <SrcComp> & thePegTrips)
   {
   if (myPegTrips_.myPtrAt (theDemand, shipPer) != NULL)
      thePegTrips.
         revCopyFrom (
            myPegTrips_.
               myElemAt (theDemand, shipPer));
   else
      thePegTrips.clear ();
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::print ()
   {
   fprintf (solnFile (),
      "\n"
      "%s Pegging:\n"
      "\n",
      myAttName_.myCstring ());

   prtInner ();
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      double WitPipAttPgg <SrcComp>::pegVolFor (
         WitDemand * theDemand,
         WitPeriod   shipPer,
         SrcComp *   theSrcComp,
         WitPeriod   pegPer)
   {
   WitTripStack <SrcComp> thePegTrips (myProblem ());
   SrcComp *              tripSrcComp;
   WitPeriod              tripPer;
   double                 pegVol;

   getPegTrips (theDemand, shipPer, thePegTrips);

   while (thePegTrips.pop (tripSrcComp, tripPer, pegVol))
      if (tripSrcComp == theSrcComp)
         if (tripPer == pegPer)
            return pegVol;

   return 0.0;
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      int WitPipAttPgg <SrcComp>::totTrips ()
   {
   int         nTrips;
   WitDemand * theDemand;
   WitPeriod   shipPer;

   nTrips = 0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         if (myPegTrips_.myPtrAt (theDemand, shipPer) != NULL)
            nTrips += myPegTrips_.myElemAt (theDemand, shipPer).nElements ();
d781 2
a782 2
   return nTrips;
   }
d787 22
a808 22
      void WitPipAttPgg <WitOperation>::prtInner ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   bool           pegVolPrinted;

   fprintf (solnFile (),
      "   -----------------------------\n"
      "   Opn  Per  Dem  Per    %7s\n"
      "   -----------------------------\n",
      myAttName_.myCstring ());

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         prtSrcCompPgg (theOpn, execPer, pegVolPrinted);

         if (pegVolPrinted)
            fprintf (solnFile (),
               "   -----------------------------\n");
         }
   }
d813 22
a834 22
      void WitPipAttPgg <WitBopEntry>::prtInner ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   bool          pegVolPrinted;

   fprintf (solnFile (),
      "   ----------------------------------\n"
      "   Opn  Idx  Per  Dem  Per  %9s\n"
      "   ----------------------------------\n",
      myAttName_.myCstring ());

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         prtSrcCompPgg (theBopEnt, execPer, pegVolPrinted);

         if (pegVolPrinted)
            fprintf (solnFile (),
               "   ----------------------------------\n");
         }
   }
d839 22
a860 22
      void WitPipAttPgg <WitSubEntry>::prtInner ()
   {
   WitSubEntry * theSub;
   WitPeriod     execPer;
   bool          pegVolPrinted;

   fprintf (solnFile (),
      "   ---------------------------------------\n"
      "   Opn  Idx  Idx  Per  Dem  Per     %6s\n"
      "   ---------------------------------------\n",
      myAttName_.myCstring ());

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         prtSrcCompPgg (theSub, execPer, pegVolPrinted);

         if (pegVolPrinted)
            fprintf (solnFile (),
               "   ---------------------------------------\n");
         }
   }
d865 22
a886 22
      void WitPipAttPgg <WitPart>::prtInner ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   bool      pegVolPrinted;

   fprintf (solnFile (),
      "   ------------------------------\n"
      "   Part  Per  Dem  Per  %9s\n"
      "   ------------------------------\n",
      myAttName_.myCstring ());

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         prtSrcCompPgg (thePart, thePer, pegVolPrinted);

         if (pegVolPrinted)
            fprintf (solnFile (),
               "   ------------------------------\n");
         }
   }
d890 38
a927 38
template <typename SrcComp> 
      void WitPipAttPgg <SrcComp>::prtSrcCompPgg (
         SrcComp * theSrcComp,
         WitPeriod thePer,
         bool &    pegVolPrinted)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      pegVol;

   pegVolPrinted = false;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         pegVol = pegVolFor (theDemand, shipPer, theSrcComp, thePer);

         if (pegVol == 0.0)
            continue;

         prtSrcComp (pegVolPrinted? NULL: theSrcComp);

         if (pegVolPrinted)
            fprintf (solnFile (), "     ");
         else
            fprintf (solnFile (),
               "  %3d",
               thePer);

         fprintf (solnFile (),
            "  %3s  %3d  %9.3f\n",
            theDemand->demandName ().myCstring (),
            shipPer,
            pegVol);

         pegVolPrinted = true;
         }
   }
d932 9
a940 9
      void WitPipAttPgg <WitOperation>::prtSrcComp (WitOperation * theOpn)
   {
   if (theOpn == NULL)
      fprintf (solnFile (), "      ");
   else
      fprintf (solnFile (),
         "   %3s",
         theOpn->operationName ().myCstring ());
   }
d945 10
a954 10
      void WitPipAttPgg <WitBopEntry>::prtSrcComp (WitBopEntry * theBopEnt)
   {
   if (theBopEnt == NULL)
      fprintf (solnFile (), "           ");
   else
      fprintf (solnFile (),
         "   %3s  %3d",
         theBopEnt->myOperationName ().myCstring (),
         theBopEnt->localIndex ());
   }
d959 11
a969 11
      void WitPipAttPgg <WitSubEntry>::prtSrcComp (WitSubEntry * theSub)
   {
   if (theSub == NULL)
      fprintf (solnFile (), "                ");
   else
      fprintf (solnFile (),
         "   %3s  %3d  %3d",
         theSub->myOperationName ().myCstring (),
         theSub->myBomEntIndex (),
         theSub->localIndex ());
   }
d974 9
a982 9
      void WitPipAttPgg <WitPart>::prtSrcComp (WitPart * thePart)
   {
   if (thePart == NULL)
      fprintf (solnFile (), "       ");
   else
      fprintf (solnFile (),
         "   %4s",
         thePart->partName ().myCstring ());
   }
@


1.153
log
@Heuristic Adjustment
@
text
@d485 1
a485 1
   myDataWriter ()->writeBool         ("pipSeqClearsNow", true, false);
d498 1
a498 1
      myDataWriter ()->writeInt          ("pipSeqShipPeriod", shipPer,    -1);
d500 1
a500 1
      myDataWriter ()->writeDouble       ("pipSeqIncShipVol", incShipVol, -1.0);
@


1.152
log
@pause/resume
@
text
@d29 1
a29 1
#include <Opn.h>
@


1.151
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d543 1
a543 1
   if (myProblem ()->myGlobalComp ()->pauses ())
@


1.150
log
@ASAP Pegging Order
@
text
@d32 1
a32 1
#include <Global.h>
@


1.149
log
@ASAP Pegging Order
@
text
@d393 1
a393 1
   revShipSeq_.passContentsTo (theShipSeq);
d465 1
a465 1
   theShipSeq.passContentsTo (revShipSeq_);
@


1.148
log
@App controlled opt implosion.
@
text
@a529 2
   WitPipBldr * theBldr;

d538 1
a538 3
   theBldr = new WitPipBldr (this);

   theBldr->buildPegging ();
a544 2

   delete theBldr;
@


1.147
log
@Updated a message.
@
text
@d26 1
d313 1
a313 1
   if (not myProblem ()->postprocessed ())
@


1.146
log
@ExecVol pegging for BOP entries.
@
text
@d155 2
a156 2
   if (myGlobalComp ()->newPipPggOrder ())
      myMsgFac () ("newPipPggOrderMsg");
@


1.145
log
@BOP entry execVol pegging.
@
text
@d211 1
a211 1
void WitPipMgr::getCoexVolTrips (
d214 1
a214 1
      WitBopEntTripStack & coexVolTrips)
d219 2
a220 2
      coexVolPgg ()->
         getPegTrips (theDemand, shipPer, coexVolTrips);
d522 1
a522 1
        coexVolPgg_ (NULL),
d532 1
a532 1
     coexVolPgg_ = new WitPipAttPgg <WitBopEntry>  (  "CoexVol", myProblem ());
d561 1
a561 1
   delete   coexVolPgg_;
d574 1
a574 1
     coexVolPgg_->print ();
d590 1
a590 1
      +   coexVolPgg_->totTrips ()
d826 1
a826 1
      "   Opn  Idx  Per  Dem  Per    %7s\n"
@


1.144
log
@execVol pegging for BOP entries.
@
text
@d211 16
@


1.143
log
@Minor update.
@
text
@a25 1
#include <ExecPerSch.h>
d506 1
d516 1
d545 1
d558 1
d574 1
d802 26
d934 14
d978 1
@


1.142
log
@GPIP migration.
@
text
@a624 15
      void WitPipAttPgg <SrcComp>::append (
            WitDemand * theDemand,
            WitPeriod   shipPer,
            SrcComp *   theSrcComp,
            WitPeriod   pegPer,
            double      pegVol)
   {
   myPegTrips_.
      myElemAt (theDemand, shipPer).
         push (theSrcComp, pegPer, pegVol);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
d626 4
a629 4
            WitDemPerStack &                  theDemPers,
            SrcComp *                         theSrcComp,
            WitPeriod                         pegPer,
            WitSchedule <WitDemand, double> & pegVolSched)
d641 3
a643 1
      append (theDemand, shipPer, theSrcComp, pegPer, pegVol);
d721 1
a721 1
      myAttName_);
d730 4
a733 4
            WitDemand * theDemand,
            WitPeriod   shipPer,
            SrcComp *   theSrcComp,
            WitPeriod   pegPer)
d782 1
a782 1
      myAttName_);
d808 1
a808 1
      myAttName_);
d834 1
a834 1
      myAttName_);
@


1.141
log
@GPIP migration.
@
text
@a18 1
//    PipBldr
d25 1
a25 1
#include <GpipBldr.h>
d522 1
a522 1
   theBldr = WitPipBldr::newInstance (this);
a948 264

//------------------------------------------------------------------------------
// Implementation of class PipBldr.
//------------------------------------------------------------------------------

WitPipBldr::~WitPipBldr ()
   {
   delete myExecPerSched_;
   }

//------------------------------------------------------------------------------

WitPipBldr * WitPipBldr::newInstance (WitPipPgg * thePgg)
   {
   return new WitGpipBldr (thePgg);
   }

//------------------------------------------------------------------------------

void WitPipBldr::buildPegging ()
   {
   stronglyAssert (not pggBuilt_);

   buildPggSpec ();

   consolidatePegging ();

   prtInfeas ();

   pggBuilt_ = true;
   }

//------------------------------------------------------------------------------

WitPipBldr::WitPipBldr (WitPipPgg * thePgg):

      WitProbAssoc       (thePgg->myProblem ()),

      myPgg_             (thePgg),
      pggBuilt_          (false),
      myExecPerSched_    (NULL),
      maxInfeas_         (0.0),
      maxInfeasPart_     (NULL),
      maxInfeasPer_      (-1),
      npoMaxUnmatchVol_  (0.0),
      npoMaxUnmatchPart_ (NULL)
   {
   myExecPerSched_ = new WitExecPerSched (myProblem ());
   }

//------------------------------------------------------------------------------

double WitPipBldr::compExcessVol (WitPart * thePart, WitPeriod thePer)
   {
   return
      min (
         positivePart (thePart->residualVol ()[thePer]),
         thePart->supplyVol ()[thePer]);
   }

//------------------------------------------------------------------------------

void WitPipBldr::compNonExcStockVol (
      WitMaterial *      theMat,
      WitTVec <double> & nonExcStockVol)
   {
   double    excStockVol;
   WitPeriod thePer;

   excStockVol = 0.0;

   forEachPeriod (thePer, myProblem ())
      {
      excStockVol += compExcessVol (theMat, thePer);

      excStockVol -= theMat->scrapVol ()[thePer];

      setToMax (excStockVol, 0.0);

      setToMin (excStockVol, theMat->stockVol ()[thePer]);

      nonExcStockVol[thePer] = theMat->stockVol ()[thePer] - excStockVol;
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::compSideVols (WitSchedule <WitPart, double> & sideVolSched)
   {
   compBopSideVols (sideVolSched);
   compBomSideVols (sideVolSched);

   if (myGlobalComp ()->selPrintLevel () >= 3)
      prtSideVols (sideVolSched);
   }

//------------------------------------------------------------------------------

void WitPipBldr::recInfeas (
      WitPart * thePart,
      WitPeriod thePer,
      double    infeasVol)
   {
   if (infeasVol > maxInfeas_)
      {
      maxInfeas_     = infeasVol;
      maxInfeasPart_ = thePart;
      maxInfeasPer_  = thePer;
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::recUnmatched (WitPart * thePart, double unmatchVol)
   {
   if (unmatchVol > npoMaxUnmatchVol_)
      {
      npoMaxUnmatchVol_  = unmatchVol;
      npoMaxUnmatchPart_ = thePart;
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::compBopSideVols (WitSchedule <WitPart, double> & sideVolSched)
   {
   WitBopEntry * theBopEnt;
   WitPart *     thePart;
   WitPeriod     execPer;
   double        execVolVal;
   WitPeriod     prodPer;

   forEachBopEntry (theBopEnt, myProblem ())
      {
      thePart = theBopEnt->myPart ();

      forEachPeriod (execPer, myProblem ())
         {
         if (not theBopEnt->inEffect (execPer))
            continue;

         if (theBopEnt->expAllowed ())
            if (theBopEnt->execPerOKForExp (execPer))
               continue;

         execVolVal = theBopEnt->myOperation ()->execVol ()[execPer];

         if (execVolVal <= 0.0)
            continue;

         prodPer = theBopEnt->impactPeriod ()[execPer];

         sideVolSched (thePart)[prodPer] +=
            execVolVal * theBopEnt->effProdRate ()[execPer];
         }
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::compBomSideVols (WitSchedule <WitPart, double> & sideVolSched)
   {
   WitBomEntry * theBomEnt;
   WitPeriod     execPer;
   double        effConsRateVal;
   double        execVolVal;
   WitPart *     thePart;
   WitPeriod     consPer;
   double        incConsVol;

   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         if (not theBomEnt->inEffect (execPer))
            continue;

         effConsRateVal = theBomEnt->effConsRate ()[execPer];

         if (effConsRateVal >= 0.0)
            continue;

         execVolVal = theBomEnt->myOperation ()->execVol ()[execPer];

         if (execVolVal <= 0.0)
            continue;

         thePart    = theBomEnt->myPart ();

         consPer    = theBomEnt->impactPeriod ()[execPer];

         incConsVol = execVolVal * effConsRateVal;

         sideVolSched (thePart)[consPer] -= incConsVol;
         }
   }

//------------------------------------------------------------------------------

void WitPipBldr::prtSideVols (
      const WitSchedule <WitPart, double> & sideVolSched)
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    sideVolVal;

   stronglyAssert (myGlobalComp ()->selPrintLevel () >= 3);

   fprintf (msgFile (),
      "\n"
      "Side Effect Volumes:\n"
      "\n"
      "   Part Per SideVol\n");

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         sideVolVal = sideVolSched (thePart)[thePer];

         if (sideVolVal == 0.0)
            continue;

         fprintf (msgFile (),
            "   %4s %3d %7.2f\n",
            thePart->partName ().myCstring (),
            thePer,
            sideVolVal);
         }

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitPipBldr::consolidatePegging ()
   {
   myPgg_->  execVolPgg ()->consolidate ();
   myPgg_->   subVolPgg ()->consolidate ();
   myPgg_->supplyVolPgg ()->consolidate ();
   myPgg_->  prodVolPgg ()->consolidate ();
   myPgg_->  consVolPgg ()->consolidate ();
   myPgg_->  sideVolPgg ()->consolidate ();
   }

//------------------------------------------------------------------------------

void WitPipBldr::prtInfeas ()
   {
   myMsgFac () ("pipMaxInfeasMsg", maxInfeas_);

   if (maxInfeas_ > 0.0)
      myMsgFac () ("pipMaxInfDataMsg",
         maxInfeasPart_->partName (),
         maxInfeasPer_);

   if (DEVELOPMENT)
      if (myGlobalComp ()->newPipPggOrder ())
         {
         myMsgFac () ("pipNpoMaxUnmatchMsg", npoMaxUnmatchVol_);

         if (npoMaxUnmatchVol_ > 0.0)
            myMsgFac () ("pipNpoMaxUnmatchDataMsg",
               npoMaxUnmatchPart_->partName ());
         }
   }
@


1.140
log
@New PIP pegging order.
@
text
@a25 1
#include <IpipBldr.h>
d964 1
a964 4
   if (thePgg->myGlobalComp ()->groupPipMode ())
      return new WitGpipBldr (thePgg);
   else
      return new WitIpipBldr (thePgg);
@


1.139
log
@New PIP pegging order.
@
text
@d990 1
a990 1
      WitProbAssoc    (thePgg->myProblem ()),
d992 8
a999 6
      myPgg_          (thePgg),
      pggBuilt_       (false),
      myExecPerSched_ (NULL),
      maxInfeas_      (0.0),
      maxInfeasPart_  (NULL),
      maxInfeasPer_   (-1)
d1067 11
d1207 10
@


1.138
log
@New PIP pegging order.
@
text
@d379 1
a379 1
   theShipSeq.takeContents (revShipSeq_);
d451 1
a451 1
   revShipSeq_.takeContents (theShipSeq);
@


1.137
log
@New PIP pegging order.
@
text
@d158 3
@


1.136
log
@Fixed a bug in IPIP and GPIP.
@
text
@a26 1
#include <IpipBldrV2.h>
d964 1
a964 2

   else if (not thePgg->tempParIsSet (1))
a965 3

   else
      return new WitIpipBldrV2 (thePgg);
@


1.135
log
@New PIP pegging order.
@
text
@d31 1
a31 1
#include <Part.h>
d1006 35
@


1.134
log
@New PIP pegging order.
@
text
@d27 1
d577 1
a577 3
   fprintf (msgFile (),
      "Total # of pegging triples: %d\n",
      nTrips);
d965 4
d970 1
a970 1
      return new WitIpipBldr (thePgg);
@


1.133
log
@Updated the copyright date on all source files.
@
text
@d525 3
d563 19
d766 19
@


1.132
log
@GPIP.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.131
log
@GPIP
@
text
@d77 2
d93 2
@


1.130
log
@GPIP
@
text
@d339 1
a339 1
   witAssert (incShipVol >= NET_TOL);
d341 2
a342 1
   revShipSeq_.push (theDemand, shipPer, incShipVol);
@


1.129
log
@GPIP
@
text
@d521 1
a521 1
      myProblem ()->pauseForInput ();
@


1.128
log
@GPIP
@
text
@d520 3
d715 24
a897 24

template <typename SrcComp> 
      double WitPipAttPgg <SrcComp>::pegVolFor (
            WitDemand * theDemand,
            WitPeriod   shipPer,
            SrcComp *   theSrcComp,
            WitPeriod   pegPer)
   {
   WitTripStack <SrcComp> thePegTrips (myProblem ());
   SrcComp *              tripSrcComp;
   WitPeriod              tripPer;
   double                 pegVol;

   getPegTrips (theDemand, shipPer, thePegTrips);

   while (thePegTrips.pop (tripSrcComp, tripPer, pegVol))
      if (tripSrcComp == theSrcComp)
         if (tripPer == pegPer)
            return pegVol;

   return 0.0;
   }

//------------------------------------------------------------------------------
@


1.127
log
@GPIP
@
text
@d152 1
a152 4
   if (myGlobalComp ()->groupPipMode ())
      myMsgFac () ("gpipMsg");
   else
      myMsgFac () ("pipMsg");
a542 5
   if (myGlobalComp ()->groupPipMode ())
      fprintf (solnFile (),
         "\n"
         "(Group Post-Implosion Pegging Mode)\n");

@


1.126
log
@GPIP
@
text
@a708 8
   WitDemand *            theDemand;
   WitPeriod              shipPer;
   WitTripStack <SrcComp> thePegTrips (myProblem ());
   SrcComp *              theSrcComp;
   WitPeriod              pegPer;
   double                 pegVol;
   bool                   firstTrip;

d715 1
a715 29
   prtHeading ();

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         getPegTrips (theDemand, shipPer, thePegTrips);

         if (thePegTrips.isEmpty ())
            continue;

         firstTrip = true;

         while (thePegTrips.pop (theSrcComp, pegPer, pegVol))
            {
            if (firstTrip)
               fprintf (solnFile (),
                  "   %3s  %3d",
                  theDemand->demandName ().myCstring (),
                  shipPer);
            else
               fprintf (solnFile (), "           ");

            firstTrip = false;

            prtPegTrip (theSrcComp,pegPer, pegVol);
            }

         prtDivider ();
         }
a718 2
// Specialized implementation of template class PipAttPgg <Operation>.
//------------------------------------------------------------------------------
d721 1
a721 1
      void WitPipAttPgg <WitOperation>::prtHeading ()
d723 4
d729 1
a729 1
      "   Dem  Per  Opn  Per    %7s\n"
d732 10
d747 1
a747 4
      void WitPipAttPgg <WitOperation>::prtPegTrip (
         WitOperation * theOpn,
         WitPeriod      pegPer,
         double         pegVol)
d749 4
d754 4
a757 5
      "  %3s  %3d  %9.3f\n",
      theOpn->operationName ().myCstring (),
      pegPer,
      pegVol);
   }
d759 4
a762 1
//------------------------------------------------------------------------------
d764 4
a767 5
template <>
      void WitPipAttPgg <WitOperation>::prtDivider ()
   {
   fprintf (solnFile (),
      "   -----------------------------\n");
a770 2
// Specialized implementation of template class PipAttPgg <SubEntry>.
//------------------------------------------------------------------------------
d773 1
a773 1
      void WitPipAttPgg <WitSubEntry>::prtHeading ()
d775 4
d780 3
a782 3
      "   ---------------------------------------\n"
      "   Dem  Per  Opn  Idx  Idx  Per     %6s\n"
      "   ---------------------------------------\n",
d784 10
d798 37
a834 13
template <>
      void WitPipAttPgg <WitSubEntry>::prtPegTrip (
         WitSubEntry * theSub,
         WitPeriod     pegPer,
         double        pegVol)
   {
   fprintf (solnFile (),
      "  %3s  %3d  %3d  %3d  %9.3f\n",
      theSub->myOperationName ().myCstring (),
      theSub->myBomEntIndex (),
      theSub->localIndex (),
      pegPer,
      pegVol);
d840 1
a840 1
      void WitPipAttPgg <WitSubEntry>::prtDivider ()
d842 6
a847 2
   fprintf (solnFile (),
      "   ---------------------------------------\n");
a850 2
// Specialized implementation of template class PipAttPgg <Part>.
//------------------------------------------------------------------------------
d853 1
a853 1
      void WitPipAttPgg <WitPart>::prtHeading ()
d855 8
a862 5
   fprintf (solnFile (),
      "   ------------------------------\n"
      "   Dem  Per  Part  Per  %9s\n"
      "   ------------------------------\n",
      myAttName_);
d868 1
a868 4
      void WitPipAttPgg <WitPart>::prtPegTrip (
         WitPart * thePart,
         WitPeriod pegPer,
         double    pegVol)
d870 6
a875 5
   fprintf (solnFile (),
      "  %3s  %4d  %9.3f\n",
      thePart->partName ().myCstring (),
      pegPer,
      pegVol);
d880 6
a885 2
template <>
      void WitPipAttPgg <WitPart>::prtDivider ()
d887 13
a899 2
   fprintf (solnFile (),
      "   ------------------------------\n");
@


1.125
log
@GPIP
@
text
@a555 4

   if (myGlobalComp ()->groupPipMode ())
      return;

d930 11
d956 109
@


1.124
log
@GPIP
@
text
@d911 2
d924 4
a927 1
      myExecPerSched_ (NULL)
d934 15
d958 12
@


1.123
log
@GPIP
@
text
@a539 12
void WitPipPgg::consolidatePegging ()
   {
     execVolPgg_->consolidate ();
      subVolPgg_->consolidate ();
   supplyVolPgg_->consolidate ();
     prodVolPgg_->consolidate ();
     consVolPgg_->consolidate ();
     sideVolPgg_->consolidate ();
   }

//------------------------------------------------------------------------------

d909 2
d926 12
@


1.122
log
@GPIP
@
text
@d636 4
a639 3
            SrcComp *         theSrcComp,
            WitPeriod         pegPer,
            WitDemTripStack & theDemTrips)
d645 6
a650 1
   while (theDemTrips.pop (theDemand, shipPer, pegVol))
d652 1
@


1.121
log
@GPIP
@
text
@d19 1
d28 1
d510 2
d519 5
a523 4
   if (myGlobalComp ()->groupPipMode ())
      buildGroupPip ();
   else
      BuildIndivPip ();
d542 2
a543 2
   execVolPgg_  ->consolidate ();
   subVolPgg_   ->consolidate ();
d545 3
a547 3
   prodVolPgg_  ->consolidate ();
   consVolPgg_  ->consolidate ();
   sideVolPgg_  ->consolidate ();
a565 4

   if (not myGlobalComp ()->groupPipMode ())
      sideVolPgg_->print ();

a567 1
   }
d569 2
a570 1
//------------------------------------------------------------------------------
d572 1
a572 14
void WitPipPgg::BuildIndivPip ()
   {
   WitIpipBldr theBldr (this);

   theBldr.buildPegging ();
   }

//------------------------------------------------------------------------------

void WitPipPgg::buildGroupPip ()
   {
   WitGpipBldr theBldr (this);

   theBldr.buildPegging ();
d886 43
@


1.120
log
@GPIP
@
text
@d636 1
a636 1
            WitPeriod   thePer,
d641 17
a657 1
         push (theSrcComp, thePer, pegVol);
@


1.119
log
@GPIP
@
text
@d573 3
a575 1
   WitIpipBldr::buildPegging (this);
d582 1
a582 5
   WitGpipBldr * theBldr;

   theBldr = new WitGpipBldr (this);

   theBldr->buildPegging ();
d584 1
a584 1
   delete theBldr;
@


1.118
log
@GPIP
@
text
@d25 1
a26 1
#include <UrpBldr.h>
d518 1
a518 1
      buildPeggingByUrp ();
d571 1
a571 1
void WitPipPgg::buildPeggingByUrp ()
d573 1
a573 1
   WitUrpBldr::buildPegging (this);
@


1.117
log
@GPIP
@
text
@d25 1
a25 1
#include <SrpBuilder.h>
d516 1
a516 1
      buildPeggingBySrp ();
d578 1
a578 1
void WitPipPgg::buildPeggingBySrp ()
@


1.116
log
@GPIP
@
text
@d580 1
a580 1
   WitSrpBuilder * theBuilder;
d582 1
a582 1
   theBuilder = new WitSrpBuilder (this);
d584 1
a584 1
   theBuilder->buildPegging ();
d586 1
a586 1
   delete theBuilder;
@


1.115
log
@[shared-resource pegging]
@
text
@d150 2
a151 2
   if (myGlobalComp ()->srpMode ())
      myMsgFac () ("srpMsg");
d515 1
a515 1
   if (myGlobalComp ()->srpMode ())
d553 1
a553 1
   if (myGlobalComp ()->srpMode ())
d556 1
a556 1
         "(Shared-Resource Pegging Mode)\n");
d562 1
a562 1
   if (not myGlobalComp ()->srpMode ())
@


1.114
log
@[shared-resource pegging]
@
text
@d565 2
a566 4
   prodVolPgg_->print ();

   if (not myGlobalComp ()->srpMode ())
      consVolPgg_->print ();
@


1.113
log
@[shared-resource pegging]
@
text
@d562 2
a563 2
   if (myGlobalComp ()->srpMode ())
      return;
d565 4
a568 3
     sideVolPgg_->print ();
     prodVolPgg_->print ();
     consVolPgg_->print ();
@


1.112
log
@[shared-resource pegging]
@
text
@d560 1
a564 1
   supplyVolPgg_->print ();
@


1.111
log
@[shared-resource pegging]
@
text
@a17 1
//    PipAbsAttPgg
a590 16
// Implementation of class PipAbsAttPgg.
//------------------------------------------------------------------------------

WitPipAbsAttPgg::WitPipAbsAttPgg (WitProblem * theProblem):

      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitPipAbsAttPgg::~WitPipAbsAttPgg ()
   {
   }

//------------------------------------------------------------------------------
d599 4
a602 3
         WitPipAbsAttPgg (theProblem),
         myPegTrips_     (theProblem),
         myAttName_      (theAttName)
@


1.110
log
@[shared-resource pegging]
@
text
@d188 1
a188 1
      myPgg ()->printPegging ();
d548 1
a548 1
void WitPipPgg::printPegging ()
d559 2
a560 2
     execVolPgg ()->print ();
      subVolPgg ()->print ();
d565 4
a568 4
   supplyVolPgg ()->print ();
     sideVolPgg ()->print ();
     prodVolPgg ()->print ();
     consVolPgg ()->print ();
d608 1
a608 1
// Implementation of class PipAttPgg.
d733 7
a739 17
   prtSpecial ();
   }

//------------------------------------------------------------------------------
// Specialized implementations of PipAttPgg <SrcComp>::prtSpecial ().
//------------------------------------------------------------------------------

template <>
      void WitPipAttPgg <WitOperation>::prtSpecial ()
   {
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   WitOpnTripStack thePegTrips (myProblem ());
   WitOperation *  theOpn;
   WitPeriod       pegPer;
   double          pegVol;
   bool            firstTrip;
d744 1
a744 5
      "\n"
      "   -----------------------------\n"
      "   Dem  Per  Opn  Per    %7s\n"
      "   -----------------------------\n",
      myAttName_,
d747 2
d759 1
a759 1
         while (thePegTrips.pop (theOpn, pegPer, pegVol))
d771 1
a771 5
            fprintf (solnFile (),
               "  %3s  %3d  %9.3f\n",
               theOpn->operationName ().myCstring (),
               pegPer,
               pegVol);
d774 1
a774 2
         fprintf (solnFile (),
            "   -----------------------------\n");
d779 29
d810 1
a810 1
      void WitPipAttPgg <WitSubEntry>::prtSpecial ()
d812 7
a818 7
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   WitSubTripStack thePegTrips (myProblem ());
   WitSubEntry *   theSub;
   WitPeriod       pegPer;
   double          pegVol;
   bool            firstTrip;
d820 3
a823 3
      "\n"
      "%s Pegging:\n"
      "\n"
a826 1
      myAttName_,
d828 1
a828 5
      
   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         getPegTrips (theDemand, shipPer, thePegTrips);
d830 1
a830 2
         if (thePegTrips.isEmpty ())
            continue;
d832 14
a845 1
         firstTrip = true;
d847 1
a847 9
         while (thePegTrips.pop (theSub, pegPer, pegVol))
            {
            if (firstTrip)
               fprintf (solnFile (),
                  "   %3s  %3d",
                  theDemand->demandName ().myCstring (),
                  shipPer);
            else
               fprintf (solnFile (), "           ");
d849 5
a853 14
            firstTrip = false;

            fprintf (solnFile (),
               "  %3s  %3d  %3d  %3d  %9.3f\n",
               theSub->myOperationName ().myCstring (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               pegPer,
               pegVol);
            }

         fprintf (solnFile (),
            "   ---------------------------------------\n");
         }
d857 2
d861 1
a861 1
      void WitPipAttPgg <WitPart>::prtSpecial ()
a862 8
   WitDemand *      theDemand;
   WitPeriod        shipPer;
   WitPartTripStack thePegTrips (myProblem ());
   WitPart *        thePart;
   WitPeriod        pegPer;
   double           pegVol;
   bool             firstTrip;

a863 3
      "\n"
      "%s Pegging:\n"
      "\n"
a866 1
      myAttName_,
d868 1
d870 1
a870 4
   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         getPegTrips (theDemand, shipPer, thePegTrips);
d872 12
a883 2
         if (thePegTrips.isEmpty ())
            continue;
d885 1
a885 1
         firstTrip = true;
d887 5
a891 22
         while (thePegTrips.pop (thePart, pegPer, pegVol))
            {
            if (firstTrip)
               fprintf (solnFile (),
                  "   %3s  %3d",
                  theDemand->demandName ().myCstring (),
                  shipPer);
            else
               fprintf (solnFile (), "           ");

            firstTrip = false;

            fprintf (solnFile (),
               "  %3s  %4d  %9.3f\n",
               thePart->partName ().myCstring (),
               pegPer,
               pegVol);
            }

         fprintf (solnFile (),
            "   ------------------------------\n");
         }
a897 1
template class WitPipAttPgg <WitPart>;
d900 1
@


1.109
log
@[shared-resource pegging]
@
text
@d733 1
a733 1
   printInner ();
d737 1
a737 1
// Non-parametric implementations of PipAttPgg <SrcComp>::printInner ().
d740 2
a741 1
void WitPipAttPgg <WitOperation>::printInner ()
d797 2
a798 1
void WitPipAttPgg <WitSubEntry>::printInner ()
d856 2
a857 1
void WitPipAttPgg <WitPart>::printInner ()
@


1.108
log
@[shared-resource pegging]
@
text
@a19 1
//    PipPrtr
a25 1
#include <PipPrtr.h>
d502 2
a503 2
      execVolPgg_   (NULL),
      subVolPgg_    (NULL),
d505 10
a514 10
      prodVolPgg_   (NULL),
      consVolPgg_   (NULL),
      sideVolPgg_   (NULL)
   {
   execVolPgg_   = new WitPipAttPgg <WitOperation> (myProblem ());
   subVolPgg_    = new WitPipAttPgg <WitSubEntry>  (myProblem ());
   supplyVolPgg_ = new WitPipAttPgg <WitPart>      (myProblem ());
   prodVolPgg_   = new WitPipAttPgg <WitPart>      (myProblem ());
   consVolPgg_   = new WitPipAttPgg <WitPart>      (myProblem ());
   sideVolPgg_   = new WitPipAttPgg <WitPart>      (myProblem ());
d526 3
a528 3
   delete sideVolPgg_;
   delete consVolPgg_;
   delete prodVolPgg_;
d530 2
a531 2
   delete subVolPgg_;
   delete execVolPgg_;
d550 8
a557 1
   WitPipPrtr thePipPrtr (this);
d559 10
a568 1
   thePipPrtr.printPegging ();
d612 3
a614 1
      WitPipAttPgg <SrcComp>::WitPipAttPgg (WitProblem * theProblem):
d617 2
a618 1
         myPegTrips_     (theProblem)
a728 2
// Explicit instantiation of class template PipAttPgg <SrcComp>.
//------------------------------------------------------------------------------
d730 2
a731 19
template class WitPipAttPgg <WitPart>;
template class WitPipAttPgg <WitOperation>;
template class WitPipAttPgg <WitSubEntry>;

//------------------------------------------------------------------------------
// Implementation of class PipPrtr.
//------------------------------------------------------------------------------

WitPipPrtr::WitPipPrtr (WitPipPgg * thePgg):

      WitProbAssoc (thePgg->myProblem ()),

      myPgg_       (thePgg)
   {  
   }

//------------------------------------------------------------------------------

WitPipPrtr::~WitPipPrtr ()
d733 1
d737 1
a737 25

void WitPipPrtr::printPegging ()
   {
   fprintf (solnFile (),
      "\n\n"
      "Post-Implosion Pegging:\n");

   if (myGlobalComp ()->srpMode ())
      fprintf (solnFile (),
         "\n"
         "(Shared-Resource Pegging Mode)\n");

   prtExecVolPgg ();

   prtSubVolPgg ();

   if (myGlobalComp ()->srpMode ())
      return;

   prtPartPgg (myPgg_->supplyVolPgg (), "SupplyVol");
   prtPartPgg (myPgg_->  sideVolPgg (),   "SideVol");
   prtPartPgg (myPgg_->  prodVolPgg (),   "ProdVol");
   prtPartPgg (myPgg_->  consVolPgg (),   "ConsVol");
   }

d740 1
a740 1
void WitPipPrtr::prtExecVolPgg ()
d744 1
a744 1
   WitOpnTripStack execVolTrips (myProblem ());
d746 2
a747 2
   WitPeriod       execPer;
   double          pgdExecVol;
d752 1
a752 1
      "ExecVol Pegging:\n"
d755 4
a758 2
      "   Dem  Per  Opn  Per    ExecVol\n"
      "   -----------------------------\n");
d763 1
a763 3
         myPgg_->
            execVolPgg ()->
               getPegTrips (theDemand, shipPer, execVolTrips);
d765 1
a765 1
         if (execVolTrips.isEmpty ())
d770 1
a770 1
         while (execVolTrips.pop (theOpn, execPer, pgdExecVol))
d785 2
a786 2
               execPer,
               pgdExecVol);
d796 1
a796 1
void WitPipPrtr::prtSubVolPgg ()
d800 1
a800 1
   WitSubTripStack subVolTrips (myProblem ());
d802 2
a803 2
   WitPeriod       execPer;
   double          pgdSubVol;
d808 1
a808 1
      "SubVol Pegging:\n"
d811 5
a815 3
      "   Dem  Per  Opn  Idx  Idx  Per     SubVol\n"
      "   ---------------------------------------\n");

d819 1
a819 3
         myPgg_->
            subVolPgg ()->
               getPegTrips (theDemand, shipPer, subVolTrips);
d821 1
a821 1
         if (subVolTrips.isEmpty ())
d826 1
a826 1
         while (subVolTrips.pop (theSub, execPer, pgdSubVol))
d843 2
a844 2
               execPer,
               pgdSubVol);
d854 1
a854 3
void WitPipPrtr::prtPartPgg (
      WitPipAttPgg <WitPart> * thePartAttPgg,
      const char *             theAttName)
d860 1
a860 1
   WitPeriod        thePer;
d871 2
a872 2
      theAttName,
      theAttName);
d877 1
a877 1
         thePartAttPgg->getPegTrips (theDemand, shipPer, thePegTrips);
d884 1
a884 1
         while (thePegTrips.pop (thePart, thePer, pegVol))
d899 1
a899 1
               thePer,
d907 8
@


1.107
log
@[shared-resource pegging]
@
text
@a15 1
//    PipPrtr
d18 3
a20 2
//    PipTarg
//    PipPegList <SrcComp>, with explicit instantiation.
a23 1
#include <PipPrtr.h>
d26 2
a27 2
#include <PipTarg.h>
#include <PipPegList.h>
d39 1
d189 2
a190 4
   if (not peggingExists ())
      return;

   WitPipPrtr::printPegging (this);
d202 3
a204 1
   myPgg ()->getExecVolTrips (theDemand, shipPer, execVolTrips);
d218 3
a220 1
   myPgg ()->getSubVolTrips (theDemand, shipPer, subVolTrips);
d227 1
a227 1
void WitPipMgr::getPartPegTrips (
d230 1
a230 2
      WitPipPartAtt::Tag theAttTag,
      WitPartTripStack & thePegTrips)
d234 3
a236 1
   myPgg ()->getPartPegTrips (theDemand, shipPer, theAttTag, thePegTrips);
d243 4
a246 1
void WitPipMgr::checkRestrictions ()
d248 1
a248 2
   WitSubEntry * theSub;
   WitPeriod     execPer;
d250 3
a252 2
   if (not myProblem ()->postprocessed ())
      myMsgFac () ("unpostPipSmsg");
d254 1
a254 9
   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theSub->consRate ()[execPer] < 0.0)
            myMsgFac () ("pipNegSubConsRateSmsg",
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               execPer,
               theSub->consRate ()[execPer]);
a257 2
// Implementation of class PipPrtr.
//------------------------------------------------------------------------------
d259 4
a262 1
void WitPipPrtr::printPegging (WitPipMgr * thePipMgr)
d264 1
a264 1
   witAssert (thePipMgr->peggingExists ());
d266 3
a268 1
   WitPipPrtr thePipPrtr (thePipMgr);
d270 1
a270 1
   thePipPrtr.print ();
d275 4
a278 5
WitPipPrtr::WitPipPrtr (WitPipMgr * thePipMgr):

      WitProbAssoc (thePipMgr->myProblem ()),

      myPipMgr_    (thePipMgr)
d280 1
a280 1
   }
d282 3
a284 1
//------------------------------------------------------------------------------
d286 1
a286 2
WitPipPrtr::~WitPipPrtr ()
   {
d291 1
a291 1
void WitPipPrtr::print ()
d293 2
a294 3
   fprintf (solnFile (),
      "\n\n"
      "Post-Implosion Pegging:\n");
d296 2
a297 4
   if (myGlobalComp ()->srpMode ())
      fprintf (solnFile (),
         "\n"
         "(Shared-Resource Pegging Mode)\n");
d299 5
a303 112
   prtExecVolPgg ();

   prtSubVolPgg ();

   if (myGlobalComp ()->srpMode ())
      return;

   prtPartPgg (WitPipPartAtt::supplyVol, "SupplyVol");
   prtPartPgg (WitPipPartAtt::sideVol,   "SideVol");
   prtPartPgg (WitPipPartAtt::prodVol,   "ProdVol");
   prtPartPgg (WitPipPartAtt::consVol,   "ConsVol");
   }

//------------------------------------------------------------------------------

void WitPipPrtr::prtExecVolPgg ()
   {
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   WitOpnTripStack execVolTrips (myProblem ());
   WitOperation *  theOpn;
   WitPeriod       execPer;
   double          pgdExecVol;
   bool            firstTrip;

   fprintf (solnFile (),
      "\n"
      "ExecVol Pegging:\n"
      "\n"
      "   -----------------------------\n"
      "   Dem  Per  Opn  Per    ExecVol\n"
      "   -----------------------------\n");

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         myPipMgr_->getExecVolTrips (theDemand, shipPer, execVolTrips);

         if (execVolTrips.isEmpty ())
            continue;

         firstTrip = true;

         while (execVolTrips.pop (theOpn, execPer, pgdExecVol))
            {
            if (firstTrip)
               fprintf (solnFile (),
                  "   %3s  %3d",
                  theDemand->demandName ().myCstring (),
                  shipPer);
            else
               fprintf (solnFile (), "           ");

            firstTrip = false;

            fprintf (solnFile (),
               "  %3s  %3d  %9.3f\n",
               theOpn->operationName ().myCstring (),
               execPer,
               pgdExecVol);
            }

         fprintf (solnFile (),
            "   -----------------------------\n");
         }
   }

//------------------------------------------------------------------------------

void WitPipPrtr::prtSubVolPgg ()
   {
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   WitSubTripStack subVolTrips (myProblem ());
   WitSubEntry *   theSub;
   WitPeriod       execPer;
   double          pgdSubVol;
   bool            firstTrip;

   fprintf (solnFile (),
      "\n"
      "SubVol Pegging:\n"
      "\n"
      "   ---------------------------------------\n"
      "   Dem  Per  Opn  Idx  Idx  Per     SubVol\n"
      "   ---------------------------------------\n");

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         myPipMgr_->getSubVolTrips (theDemand, shipPer, subVolTrips);

         if (subVolTrips.isEmpty ())
            continue;

         firstTrip = true;

         while (subVolTrips.pop (theSub, execPer, pgdSubVol))
            {
            if (firstTrip)
               fprintf (solnFile (),
                  "   %3s  %3d",
                  theDemand->demandName ().myCstring (),
                  shipPer);
            else
               fprintf (solnFile (), "           ");

            firstTrip = false;

            fprintf (solnFile (),
               "  %3s  %3d  %3d  %3d  %9.3f\n",
               theSub->myOperationName ().myCstring (),
d307 1
a307 65
               pgdSubVol);
            }

         fprintf (solnFile (),
            "   ---------------------------------------\n");
         }
   }

//------------------------------------------------------------------------------

void WitPipPrtr::prtPartPgg (
      WitPipPartAtt::Tag theAttTag,
      const char *       theAttName)
   {
   WitDemand *      theDemand;
   WitPeriod        shipPer;
   WitPartTripStack thePegTrips (myProblem ());
   WitPart *        thePart;
   WitPeriod        thePer;
   double           pegVol;
   bool             firstTrip;

   fprintf (solnFile (),
      "\n"
      "%s Pegging:\n"
      "\n"
      "   ------------------------------\n"
      "   Dem  Per  Part  Per  %9s\n"
      "   ------------------------------\n",
      theAttName,
      theAttName);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         myPipMgr_->
            getPartPegTrips (theDemand, shipPer, theAttTag, thePegTrips);

         if (thePegTrips.isEmpty ())
            continue;

         firstTrip = true;

         while (thePegTrips.pop (thePart, thePer, pegVol))
            {
            if (firstTrip)
               fprintf (solnFile (),
                  "   %3s  %3d",
                  theDemand->demandName ().myCstring (),
                  shipPer);
            else
               fprintf (solnFile (), "           ");

            firstTrip = false;

            fprintf (solnFile (),
               "  %3s  %4d  %9.3f\n",
               thePart->partName ().myCstring (),
               thePer,
               pegVol);
            }

         fprintf (solnFile (),
            "   ------------------------------\n");
         }
d503 14
a516 4
      WitProbAssoc (theProblem),
      myTargs_     (theProblem)
   {
   buildTargs ();
d528 6
a533 10
   WitDemand * theDemand;
   WitPeriod   thePer;

   WitTimer::enterSection ("pip");

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myTargs_.myPtrAt (theDemand, thePer);
 
   WitTimer::leaveSection ("pip");
d538 1
a538 4
void WitPipPgg::getExecVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitOpnTripStack & execVolTrips)
d540 6
a545 8
   WitPipTarg * theTarg;

   theTarg = myTargFor (theDemand, shipPer);

   if (theTarg != NULL)
      theTarg->execVolPegList ()->getPegTrips (execVolTrips);
   else
      execVolTrips.clear ();
d550 1
a550 4
void WitPipPgg::getSubVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitSubTripStack & subVolTrips)
d552 1
a552 3
   WitPipTarg * theTarg;

   theTarg = myTargFor (theDemand, shipPer);
d554 1
a554 4
   if (theTarg != NULL)
      theTarg->subVolPegList ()->getPegTrips (subVolTrips);
   else
      subVolTrips.clear ();
d559 1
a559 5
void WitPipPgg::getPartPegTrips (
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPipPartAtt::Tag theAttTag,
      WitPartTripStack & thePegTrips)
d561 1
a561 10
   WitPipTarg * theTarg;

   witAssert (not myGlobalComp ()->srpMode ());

   theTarg = myTargFor (theDemand, shipPer);

   if (theTarg != NULL)
      theTarg->myPartPegList ()[theAttTag]->getPegTrips (thePegTrips);
   else
      thePegTrips.clear ();
d566 1
a566 1
void WitPipPgg::consolidatePegging ()
d568 1
a568 11
   WitDemand *  theDemand;
   WitPeriod    shipPer;
   WitPipTarg * theTarg;

   WitSchedule <WitOperation, double> workOpnSched;
   WitSchedule <WitSubEntry,  double> workSubSched; 
   WitSchedule <WitPart,      double> workPartSched;

   workOpnSched .allocate1D (myProblem ());
   workSubSched .allocate1D (myProblem ());
   workPartSched.allocate1D (myProblem ());
d570 1
a570 4
   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theTarg = myTargFor (theDemand, shipPer);
d572 1
a572 2
         if (theTarg == NULL)
            continue;
d574 2
a575 2
         theTarg->execVolPegList ()->
            consolidate (workOpnSched);
d577 3
a579 2
         theTarg->subVolPegList ()->
            consolidate (workSubSched);
d581 1
a581 2
         theTarg->myPartPegList ()[WitPipPartAtt::supplyVol]->
            consolidate (workPartSched);
d583 2
a584 9
         theTarg->myPartPegList ()[WitPipPartAtt::sideVol]->
            consolidate (workPartSched);

         theTarg->myPartPegList ()[WitPipPartAtt::prodVol]->
            consolidate (workPartSched);

         theTarg->myPartPegList ()[WitPipPartAtt::consVol]->
            consolidate (workPartSched);
         }
d589 1
a589 1
WitPipTarg * WitPipPgg::myTargFor (WitDemand * theDemand, WitPeriod shipPer)
a590 1
   return myTargs_.myPtrAt (theDemand, shipPer);
d594 2
d597 5
a601 1
void WitPipPgg::buildTargs ()
a606 1
   WitPipTarg *    theTarg;
d611 1
a611 4
      {
      theTarg = myTargs_.myPtrAt (theDemand, shipPer);

      if (theTarg == NULL)
d613 2
a614 3
         theTarg = new WitPipTarg (theDemand, shipPer);

         myTargs_.myPtrAt (theDemand, shipPer) = theTarg;
a615 1
      }
d620 2
a621 1
void WitPipPgg::buildPeggingByUrp ()
d623 6
a628 1
   WitUrpBldr::buildPegging (this);
d633 12
a644 3
void WitPipPgg::buildPeggingBySrp ()
   {
   WitSrpBuilder * theBuilder;
d646 1
a646 1
   theBuilder = new WitSrpBuilder (this);
d648 11
a658 1
   theBuilder->buildPegging ();
d660 1
a660 2
   delete theBuilder;
   }
d662 4
a665 3
//------------------------------------------------------------------------------
// Implementation of class WitPipTarg.
//------------------------------------------------------------------------------
d667 2
a668 1
WitPipTarg::WitPipTarg (WitDemand * theDemand, WitPeriod shipPer):
d670 4
a673 5
      myDemand_      (theDemand),
      myShipPer_     (shipPer),
      myPartPegList_ (WitPipPartAtt::nTags)
   {
   WitProblem * theProblem;
d675 1
a675 1
   theProblem = myDemand_->myProblem ();
d677 2
a678 2
   execVolPegList_ =
      new WitPipPegList <WitOperation> (theProblem);
d680 3
a682 2
   subVolPegList_ =
      new WitPipPegList <WitSubEntry> (theProblem);
d684 2
a685 2
   myPartPegList_[WitPipPartAtt::supplyVol] =
      new WitPipPegList <WitPart> (theProblem);
d687 1
a687 2
   myPartPegList_[WitPipPartAtt::sideVol] =
      new WitPipPegList <WitPart> (theProblem);
d689 3
a691 5
   myPartPegList_[WitPipPartAtt::prodVol] =
      new WitPipPegList <WitPart> (theProblem);

   myPartPegList_[WitPipPartAtt::consVol] =
      new WitPipPegList <WitPart> (theProblem);
d696 5
a700 1
WitPipTarg::~WitPipTarg ()
d702 7
a708 6
   delete myPartPegList_[WitPipPartAtt::consVol];
   delete myPartPegList_[WitPipPartAtt::prodVol];
   delete myPartPegList_[WitPipPartAtt::sideVol];
   delete myPartPegList_[WitPipPartAtt::supplyVol];
   delete subVolPegList_;
   delete execVolPegList_;
d712 9
a720 1
// Implementation of class template PipPegList <SrcComp>.
d723 3
a725 2
template <typename SrcComp> 
      WitPipPegList <SrcComp>::WitPipPegList (WitProblem * theProblem):
d727 2
a728 3
         WitProbAssoc (theProblem),
         myPegTrips_  (theProblem)
   {
d733 1
a733 2
template <typename SrcComp> 
      WitPipPegList <SrcComp>::~WitPipPegList ()
d739 1
a739 5
template <typename SrcComp> 
      void WitPipPegList <SrcComp>::append (
         SrcComp * theSrcComp,
         WitPeriod thePer,
         double    pegVol)
d741 20
a760 1
   myPegTrips_.push (theSrcComp, thePer, pegVol);
d765 1
a765 3
template <typename SrcComp> 
      void WitPipPegList <SrcComp>::consolidate (
         WitSchedule <SrcComp, double> & workSched)
d767 7
a773 3
   SrcComp * theSrcComp;
   WitPeriod thePer;
   double    pegVol;
d775 7
a781 1
   WitPairStack <SrcComp, WitPeriod> thePairs (myProblem ());
d783 6
a788 4
   while (myPegTrips_.pop (theSrcComp, thePer, pegVol))
      {
      if (not workSched (theSrcComp).isAllocated ())
         workSched (theSrcComp).allocate (myProblem (), 0.0);
d790 2
a791 1
      workSched (theSrcComp)[thePer] += pegVol;
d793 1
a793 2
      thePairs.push (theSrcComp, thePer);
      }
d795 9
a803 3
   while (thePairs.pop (theSrcComp, thePer))
      {
      pegVol = workSched (theSrcComp)[thePer];
d805 1
a805 2
      if (pegVol == 0.0)
         continue;
d807 6
a812 1
      workSched (theSrcComp)[thePer] = 0.0;
d814 3
a816 2
      append (theSrcComp, thePer, pegVol);
      }
d821 1
a821 3
template <typename SrcComp> 
      void WitPipPegList <SrcComp>::getPegTrips (
         WitTripStack <SrcComp> & thePegTrips)
d823 52
a874 1
   thePegTrips.revCopyFrom (myPegTrips_);
a877 2
// Explicit instantiation of class template PipPegList <SrcComp>.
//------------------------------------------------------------------------------
d879 55
a933 3
template class WitPipPegList <WitPart>;
template class WitPipPegList <WitOperation>;
template class WitPipPegList <WitSubEntry>;
@


1.106
log
@[shared-resource pegging]
@
text
@d18 1
a18 1
//    PipOwner
d26 1
a26 1
#include <PipOwner.h>
d50 2
a51 2
      myPipSeqMgr_ (NULL),
      myPipOwner_  (NULL)
d55 1
a55 1
   myPipSeqMgr_ = new WitPipSeqMgr (myProblem ());
d66 2
a67 2
   delete myPipOwner_;
   delete myPipSeqMgr_;
d78 1
a78 1
   myPipSeqMgr_->clear ();
d92 1
a92 1
   myPipSeqMgr_->append (theDemand, shipPer, incShipVol);
d103 1
a103 1
   myPipSeqMgr_->get (theShipSeq);
d112 1
a112 1
   myPipSeqMgr_->display ();
d121 1
a121 1
   myPipSeqMgr_->copy (thePipMgr->myPipSeqMgr_);
d130 1
a130 1
   myPipSeqMgr_->writeData ();
d137 1
a137 1
   myPipSeqMgr_->setShipPerForRead (shipPer);
d144 1
a144 1
   return myPipSeqMgr_->shipPerForRead ();
d160 1
a160 1
   myPipSeqMgr_->reduce ();
d164 1
a164 1
   myPipOwner_ = new WitPipOwner (myProblem ());
d178 1
a178 1
   delete myPipOwner ();
d180 1
a180 1
   myPipOwner_ = NULL;
d204 1
a204 1
   myPipOwner ()->getExecVolTrips (theDemand, shipPer, execVolTrips);
d218 1
a218 1
   myPipOwner ()->getSubVolTrips (theDemand, shipPer, subVolTrips);
d233 1
a233 1
   myPipOwner ()->getPartPegTrips (theDemand, shipPer, theAttTag, thePegTrips);
d671 1
a671 1
// Implementation of class PipOwner.
d674 1
a674 1
WitPipOwner::WitPipOwner (WitProblem * theProblem):
d682 1
a682 9
      {
      WitSrpBuilder * theBuilder;

      theBuilder = new WitSrpBuilder (this);

      theBuilder->buildPegging ();

      delete theBuilder;
      }
d684 1
a684 1
      WitUrpBldr::buildPegging (this);
d689 1
a689 1
WitPipOwner::~WitPipOwner ()
d705 1
a705 1
void WitPipOwner::getExecVolTrips (
d722 1
a722 1
void WitPipOwner::getSubVolTrips (
d739 1
a739 1
void WitPipOwner::getPartPegTrips (
d759 1
a759 1
void WitPipOwner::consolidatePegging ()
d803 1
a803 1
WitPipTarg * WitPipOwner::myTargFor (WitDemand * theDemand, WitPeriod shipPer)
d810 1
a810 1
void WitPipOwner::buildTargs ()
d834 20
@


1.105
log
@[shared-resource pegging]
@
text
@d303 2
a307 2
   prtSubVolPgg ();

a736 2
   witAssert (not myGlobalComp ()->srpMode ());

@


1.104
log
@[shared-resource pegging]
@
text
@d29 2
a30 2
#include <SrpOwner.h>
#include <UrpOwner.h>
d164 1
a164 4
   if (myGlobalComp ()->srpMode ())
      myPipOwner_ = new WitSrpOwner (myProblem ());
   else
      myPipOwner_ = new WitUrpOwner (myProblem ());
d674 23
d713 56
a819 11
WitPipOwner::WitPipOwner (WitProblem * theProblem):

      WitProbAssoc (theProblem),
      myTargs_     (theProblem)
   {
   buildTargs ();
   }


//------------------------------------------------------------------------------

@


1.103
log
@[shared-resource pegging]
@
text
@d693 44
@


1.102
log
@[shared-resource pegging]
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d19 2
d27 2
d679 17
d702 103
a804 1
      WitProbAssoc (theProblem)
d806 1
d808 52
@


1.101
log
@[shared-resource pegging]
@
text
@d154 2
d238 21
@


1.100
log
@[shared-resource pegging]
@
text
@a18 1
//    ExecPerSched
a24 1
#include <ExecPerSched.h>
a660 76

//------------------------------------------------------------------------------
// Implementation of class ExecPerSched.
//------------------------------------------------------------------------------

WitExecPerSched::WitExecPerSched (WitProblem * theProblem):

      WitProbAssoc  (theProblem),

      firstExecPer_ (theProblem, -1),
      lastExecPer_  (theProblem, -2)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   bool          multiExecPers;
   WitPeriod     expPer;

   forEachBopEntry (theBopEnt, myProblem ())
      {
      multiExecPers = false;

      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            {
            if (not theBopEnt->execPerOKForExp (execPer))
               continue;

            expPer = theBopEnt->impactPeriod ()[execPer];

            if (firstExecPer_ (theBopEnt)[expPer] == -1)
               firstExecPer_ (theBopEnt)[expPer] = execPer;
            else
               multiExecPers = true;

            lastExecPer_ (theBopEnt)[expPer] = execPer;
            }

      if (not multiExecPers)
         {
         firstExecPer_ (theBopEnt).clear ();
         lastExecPer_  (theBopEnt).clear ();
         }
      }
   }

//------------------------------------------------------------------------------

WitExecPerSched::~WitExecPerSched ()
   {
   }

//------------------------------------------------------------------------------

void WitExecPerSched::getData (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      WitPeriod &   execPerFirst,
      WitPeriod &   execPerLast)
   {
   if (firstExecPer_ (theBopEnt).isAllocated ())
      {
      execPerFirst = firstExecPer_ (theBopEnt)[expPer];
      execPerLast  = lastExecPer_  (theBopEnt)[expPer];
      }
   else if (theBopEnt->expEligible (expPer))
      {
      execPerFirst = theBopEnt->expExecPeriod ()[expPer];

      execPerLast  = execPerFirst;
      }
   else
      {
      execPerFirst = -1;
      execPerLast  = -2;
      }
   }
@


1.99
log
@[shared-resource pegging]
@
text
@d677 1
d682 1
a682 2
      if (not theBopEnt->expAllowed ())
         continue;
d684 7
a690 4
      forEachPeriod (execPer, myProblem ())
         {
         if (not theBopEnt->execPerOKForExp (execPer))
            continue;
d692 4
a695 1
         expPer = theBopEnt->impactPeriod ()[execPer];
d697 2
a698 2
         if (firstExecPer_ (theBopEnt)[expPer] == -1)
            firstExecPer_ (theBopEnt)[expPer] = execPer;
d700 4
a703 1
         lastExecPer_ (theBopEnt)[expPer] = execPer;
d713 26
@


1.98
log
@[shared-resource pegging]
@
text
@d19 1
d26 1
d33 1
d663 41
@


1.97
log
@[shared-resource pegging]
@
text
@d158 1
a158 1
      myPipOwner_ = new WitSrpOwner (myPipSeqMgr_);
d160 1
a160 1
      myPipOwner_ = new WitUrpOwner (myPipSeqMgr_);
d655 1
a655 1
WitPipOwner::WitPipOwner (WitPipSeqMgr * thePipSeqMgr):
d657 1
a657 3
      WitProbAssoc (thePipSeqMgr->myProblem ()),

      myPipSeqMgr_ (thePipSeqMgr)
@


1.96
log
@[shared-resource pegging]
@
text
@d26 1
a26 1
#include <UrpCoord.h>
d160 1
a160 1
      myPipOwner_ = new WitUrpCoord (myPipSeqMgr_);
@


1.95
log
@[shared-resource pegging]
@
text
@d18 1
a18 1
//    PipCoord
d24 1
a24 1
#include <PipCoord.h>
d46 1
a46 1
      myPipCoord_  (NULL)
d61 1
a61 1
   delete myPipCoord_;
d158 1
a158 1
      myPipCoord_ = new WitSrpOwner (myPipSeqMgr_);
d160 1
a160 1
      myPipCoord_ = new WitUrpCoord (myPipSeqMgr_);
d174 1
a174 1
   delete myPipCoord ();
d176 1
a176 1
   myPipCoord_ = NULL;
d200 1
a200 1
   myPipCoord ()->getExecVolTrips (theDemand, shipPer, execVolTrips);
d214 1
a214 1
   myPipCoord ()->getSubVolTrips (theDemand, shipPer, subVolTrips);
d229 1
a229 1
   myPipCoord ()->getPartPegTrips (theDemand, shipPer, theAttTag, thePegTrips);
d646 1
a646 1
// Implementation of class PipCoord.
d649 1
a649 1
WitPipCoord::~WitPipCoord ()
d655 1
a655 1
WitPipCoord::WitPipCoord (WitPipSeqMgr * thePipSeqMgr):
@


1.94
log
@[shared-resource pegging]
@
text
@d25 1
a25 1
#include <SrpCoord.h>
d158 1
a158 1
      myPipCoord_ = new WitSrpCoord (myPipSeqMgr_);
@


1.93
log
@Minor update.
@
text
@a188 2

   myPipCoord ()->printInternal ();
a654 6
void WitPipCoord::printInternal ()
   {
   }

//------------------------------------------------------------------------------

@


1.92
log
@[shared-resource pegging]
@
text
@d273 5
@


1.91
log
@[shared-resource pegging]
@
text
@d185 3
d189 2
d242 1
a242 2
   if (not thePipMgr->peggingExists ())
      return;
d652 6
@


1.90
log
@[shared-resource pegging]
@
text
@d185 1
a185 6
   if (not peggingExists ())
      return;

   WitPipPrtr thePipPrtr (this);

   thePipPrtr.print ();
d235 12
@


1.89
log
@[shared-resource pegging]
@
text
@d17 1
a18 1
//    PipSeqMgr
a444 18
// Implementation of class PipCoord.
//------------------------------------------------------------------------------

WitPipCoord::~WitPipCoord ()
   {
   }

//------------------------------------------------------------------------------

WitPipCoord::WitPipCoord (WitPipSeqMgr * thePipSeqMgr):

      WitProbAssoc (thePipSeqMgr->myProblem ()),

      myPipSeqMgr_ (thePipSeqMgr)
   {
   }

//------------------------------------------------------------------------------
d630 18
@


1.88
log
@[shared-resource pegging]
@
text
@d262 2
d267 1
a267 2
   prtExecVolPgg ();
   prtSubVolPgg  ();
d269 4
a272 4
   prtPartPgg    (WitPipPartAtt::supplyVol, "SupplyVol");
   prtPartPgg    (WitPipPartAtt::sideVol,   "SideVol");
   prtPartPgg    (WitPipPartAtt::prodVol,   "ProdVol");
   prtPartPgg    (WitPipPartAtt::consVol,   "ConsVol");
@


1.87
log
@[shared-resource pegging]
@
text
@d16 1
d22 2
a24 1
#include <PipSeqMgr.h>
d29 2
d44 2
d185 6
a190 2
   if (peggingExists ())
      myPipCoord ()->print ();
d237 207
@


1.86
log
@[shared-resource pegging]
@
text
@d142 4
a145 1
   myMsgFac () ("pipMsg");
@


1.85
log
@[shared-resource pegging]
@
text
@d23 1
d27 1
d148 4
a151 1
   myPipCoord_ = new WitUrpCoord (myPipSeqMgr_);
@


1.84
log
@Cut-over to the new interpretation of pipShare.
@
text
@d13 1
a13 1
// Contains the implementation of the following classes and templates:
d16 1
a17 4
//    PipPegMgr
//    PipPrtr
//    PipTarg
//    PipPegList <SrcComp>, with explicit instantiation.
d20 2
a21 5
#include <PipPegList.h>
#include <PipTarg.h>
#include <PipBldr.h>
#include <PipPrtr.h>
#include <PipPegMgr.h>
d23 1
a23 2
#include <PipMgr.h>
#include <Global.h>
a25 3
#include <Opn.h>
#include <SubEntry.h>
#include <BopEntry.h>
d28 1
d38 1
a38 1
      myPegMgr_    (NULL)
d42 1
a42 1
   mySeqMgr_ = new WitPipSeqMgr (myProblem ());
d53 2
a54 2
   delete myPegMgr_;
   delete mySeqMgr_;
d65 1
a65 1
   mySeqMgr_->clear ();
d79 1
a79 1
   mySeqMgr_->append (theDemand, shipPer, incShipVol);
d90 1
a90 1
   mySeqMgr_->get (theShipSeq);
d99 1
a99 1
   mySeqMgr_->display ();
d108 1
a108 1
   mySeqMgr_->copy (thePipMgr->mySeqMgr_);
d117 1
a117 1
   mySeqMgr_->writeData ();
d124 1
a124 1
   mySeqMgr_->setShipPerForRead (shipPer);
d131 1
a131 1
   return mySeqMgr_->shipPerForRead ();
d142 1
a142 1
   mySeqMgr_->reduce ();
d146 1
a146 1
   myPegMgr_ = new WitPipPegMgr (mySeqMgr_);
d160 1
a160 1
   delete myPegMgr ();
d162 1
a162 1
   myPegMgr_ = NULL;
d172 1
a172 1
      myPegMgr ()->print ();
d184 1
a184 1
   myPegMgr ()->getExecVolTrips (theDemand, shipPer, execVolTrips);
d198 1
a198 1
   myPegMgr ()->getSubVolTrips (theDemand, shipPer, subVolTrips);
d213 1
a213 1
   myPegMgr ()->getPartPegTrips (theDemand, shipPer, theAttTag, thePegTrips);
d219 18
a421 556

//------------------------------------------------------------------------------
// Implementation of class PipPegMgr.
//------------------------------------------------------------------------------

WitPipPegMgr::WitPipPegMgr (WitPipSeqMgr * theSeqMgr):

      WitProbAssoc (theSeqMgr->myProblem ()),

      myTargs_     (myProblem ()),
      mySeqMgr_    (theSeqMgr)
   {
   WitPipBldr * theBldr;

   checkRestrictions ();

   buildTargs ();

   theBldr = new WitPipBldr (this);

   theBldr->buildPegging ();

   delete theBldr;
   }

//------------------------------------------------------------------------------

WitPipPegMgr::~WitPipPegMgr ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;

   WitTimer::enterSection ("pip");

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myTargs_.myPtrAt (theDemand, thePer);
 
   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPipPegMgr::print ()
   {
   WitPipPrtr thePrtr (this);

   thePrtr.print ();
   }

//------------------------------------------------------------------------------

void WitPipPegMgr::getExecVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitOpnTripStack & execVolTrips)
   {
   WitPipTarg * theTarg;

   theTarg = myTargs_.myPtrAt (theDemand, shipPer);

   if (theTarg != NULL)
      theTarg->execVolPegList ()->getPegTrips (execVolTrips);
   else
      execVolTrips.clear ();
   }

//------------------------------------------------------------------------------

void WitPipPegMgr::getSubVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitSubTripStack & subVolTrips)
   {
   WitPipTarg * theTarg;

   theTarg = myTargs_.myPtrAt (theDemand, shipPer);

   if (theTarg != NULL)
      theTarg->subVolPegList ()->getPegTrips (subVolTrips);
   else
      subVolTrips.clear ();
   }

//------------------------------------------------------------------------------

void WitPipPegMgr::getPartPegTrips (
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPipPartAtt::Tag theAttTag,
      WitPartTripStack & thePegTrips)
   {
   WitPipTarg * theTarg;

   theTarg = myTargs_.myPtrAt (theDemand, shipPer);

   if (theTarg != NULL)
      theTarg->myPartPegList ()[theAttTag]->getPegTrips (thePegTrips);
   else
      thePegTrips.clear ();
   }

//------------------------------------------------------------------------------

WitPipTarg * WitPipPegMgr::myTargFor (WitDemand * theDemand, WitPeriod shipPer)
   {
   WitPipTarg * theTarg;

   theTarg = myTargs_.myPtrAt (theDemand, shipPer);

   witAssert (theTarg != NULL);

   return theTarg;
   }

//------------------------------------------------------------------------------

void WitPipPegMgr::checkRestrictions ()
   {
   WitSubEntry *  theSub;
   WitPeriod      execPer;
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;
   bool           expFound;

   if (not myProblem ()->postprocessed ())
      myMsgFac () ("unpostPipSmsg");

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theSub->consRate ()[execPer] < 0.0)
            myMsgFac () ("pipNegSubConsRateSmsg",
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               execPer,
               theSub->consRate ()[execPer]);
   }

//------------------------------------------------------------------------------

void WitPipPegMgr::buildTargs ()
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;
   WitPipTarg *    theTarg;

   mySeqMgr_->get (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      theTarg = myTargs_.myPtrAt (theDemand, shipPer);

      if (theTarg == NULL)
         {
         theTarg = new WitPipTarg (theDemand, shipPer, this);

         myTargs_.myPtrAt (theDemand, shipPer) = theTarg;
         }
      }
   }

//------------------------------------------------------------------------------
// Implementation of class PipPrtr.
//------------------------------------------------------------------------------

WitPipPrtr::WitPipPrtr (WitPipPegMgr * thePegMgr):

      WitProbAssoc (thePegMgr->myProblem ()),
      myPegMgr_    (thePegMgr),
      myTargSeq_   (myProblem ())
   {
   }

//------------------------------------------------------------------------------

WitPipPrtr::~WitPipPrtr ()
   {
   }

//------------------------------------------------------------------------------

void WitPipPrtr::print ()
   {
   fprintf (solnFile (), "\n\n");

   findTargSeq ();

   prtExecVolPip ();
   prtSubVolPip  ();

   prtPartPip    (WitPipPartAtt::supplyVol, "SupplyVol");
   prtPartPip    (WitPipPartAtt::sideVol,   "SideVol");
   prtPartPip    (WitPipPartAtt::prodVol,   "ProdVol");
   prtPartPip    (WitPipPartAtt::consVol,   "ConsVol");
   }

//------------------------------------------------------------------------------

void WitPipPrtr::findTargSeq ()
   {
   WitDemTripStack               theShipSeq (myProblem ());
   WitSchedule <WitDemand, bool> inSeqTargs (myProblem (), false);
   WitDemand *                   theDemand;
   WitPeriod                     shipPer;
   double                        incShipVol;

   myTargSeq_.clear ();

   myPegMgr_->mySeqMgr ()->get (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      if (inSeqTargs (theDemand)[shipPer])
         continue;

      myTargSeq_.push (myPegMgr_->myTargFor (theDemand, shipPer));
      
      inSeqTargs (theDemand)[shipPer] = true;
      }

   myTargSeq_.reverse ();
   }

//------------------------------------------------------------------------------

void WitPipPrtr::prtExecVolPip ()
   {
   WitOperation *           theOpn;
   WitPeriod                execPer;
   bool                     pegVolFound;
   WitObjStItr <WitPipTarg> theItr;
   WitPipTarg *             theTarg;
   double                   pegVol;

   fprintf (solnFile (),
      "\n"
      "ExecVol PIP:\n"
      "\n"
      "   -----------------------------\n"
      "   Opn  Per  Dem  Per    ExecVol\n"
      "   -----------------------------\n");

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         pegVolFound = false;

         theItr.attachTo (myTargSeq_); 

         while (theItr.advance (theTarg))
            {
            pegVol = theTarg->execVolPegList ()->pegVolFor (theOpn, execPer);

            if (pegVol == 0.0)
               continue;

            if (not pegVolFound)
               {
               fprintf (solnFile (),
                  "   %3s  %3d",
                  theOpn->operationName ().myCstring (),
                  execPer);

               pegVolFound = true;
               }
            else
               fprintf (solnFile (), "           ");

            printTargAndVol (theTarg, pegVol);
            }

         if (pegVolFound)
            fprintf (solnFile (), "   -----------------------------\n");
         }
   }

//------------------------------------------------------------------------------

void WitPipPrtr::prtSubVolPip ()
   {
   WitSubEntry *            theSub;
   WitPeriod                execPer;
   bool                     pegVolFound;
   WitObjStItr <WitPipTarg> theItr;
   WitPipTarg *             theTarg;
   double                   pegVol;

   fprintf (solnFile (),
      "\n"
      "Subvol PIP:\n"
      "\n"
      "   ---------------------------------------\n"
      "   Opn  Idx  Idx  Per  Dem  Per     SubVol\n"
      "   ---------------------------------------\n");

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         pegVolFound = false;

         theItr.attachTo (myTargSeq_); 

         while (theItr.advance (theTarg))
            {
            pegVol = theTarg->subVolPegList ()->pegVolFor (theSub, execPer);

            if (pegVol == 0.0)
               continue;

            if (not pegVolFound)
               {
               fprintf (solnFile (),
                  "   %3s  %3d  %3d  %3d",
                  theSub->myOperationName ().myCstring (),
                  theSub->myBomEntIndex (),
                  theSub->localIndex (),
                  execPer);

               pegVolFound = true;
               }
            else
               fprintf (solnFile (), "                     ");

            printTargAndVol (theTarg, pegVol);
            }

         if (pegVolFound)
            fprintf (solnFile (),
               "   ---------------------------------------\n");
         }
   }

//------------------------------------------------------------------------------

void WitPipPrtr::prtPartPip (
      WitPipPartAtt::Tag theAttTag,
      const char *       theAttName)
   {
   WitPart *                thePart;
   WitPeriod                thePer;
   bool                     pegVolFound;
   WitObjStItr <WitPipTarg> theItr;
   WitPipTarg *             theTarg;
   double                   pegVol;

   fprintf (solnFile (),
      "\n"
      "%s PIP:\n"
      "\n"
      "   ------------------------------\n"
      "   Part  Per  Dem  Per  %9s\n"
      "   ------------------------------\n",
      theAttName,
      theAttName);

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         pegVolFound = false;

         theItr.attachTo (myTargSeq_); 

         while (theItr.advance (theTarg))
            {
            pegVol =
               theTarg->myPartPegList ()[theAttTag]->
                  pegVolFor (thePart, thePer );

            if (pegVol == 0.0)
               continue;

            if (not pegVolFound)
               {
               fprintf (solnFile (),
                  "   %4s  %3d",
                  thePart->partName ().myCstring (),
                  thePer);

               pegVolFound = true;
               }
            else
               fprintf (solnFile (), "            ");

            printTargAndVol (theTarg, pegVol);
            }

         if (pegVolFound)
            fprintf (solnFile (), "   ------------------------------\n");
         }
   }

//------------------------------------------------------------------------------

void WitPipPrtr::printTargAndVol (WitPipTarg * theTarg, double pegVol)
   {
   fprintf (solnFile (),
      "  %3s  %3d  %9.3f\n",
      theTarg->myDemand ()->demandName ().myCstring (),
      theTarg->myShipPer (),
      pegVol);
   }

//------------------------------------------------------------------------------
// Implementation of class WitPipTarg.
//------------------------------------------------------------------------------

WitPipTarg::WitPipTarg (
         WitDemand *    theDemand, 
         WitPeriod      shipPer, 
         WitPipPegMgr * thePegMgr):

      myDemand_      (theDemand),
      myShipPer_     (shipPer),
      myPartPegList_ (WitPipPartAtt::nTags)
   {
   WitProblem * theProblem;

   theProblem = myDemand_->myProblem ();

   execVolPegList_ =
      new WitPipPegList <WitOperation> (theProblem);

   subVolPegList_ =
      new WitPipPegList <WitSubEntry> (theProblem);

   myPartPegList_[WitPipPartAtt::supplyVol] =
      new WitPipPegList <WitPart> (theProblem);

   myPartPegList_[WitPipPartAtt::sideVol] =
      new WitPipPegList <WitPart> (theProblem);

   myPartPegList_[WitPipPartAtt::prodVol] =
      new WitPipPegList <WitPart> (theProblem);

   myPartPegList_[WitPipPartAtt::consVol] =
      new WitPipPegList <WitPart> (theProblem);
   }

//------------------------------------------------------------------------------

WitPipTarg::~WitPipTarg ()
   {
   delete myPartPegList_[WitPipPartAtt::consVol];
   delete myPartPegList_[WitPipPartAtt::prodVol];
   delete myPartPegList_[WitPipPartAtt::sideVol];
   delete myPartPegList_[WitPipPartAtt::supplyVol];
   delete subVolPegList_;
   delete execVolPegList_;
   }

//------------------------------------------------------------------------------
// Implementation of class template PipPegList <SrcComp>.
//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPipPegList <SrcComp>::WitPipPegList (WitProblem * theProblem):

         WitProbAssoc (theProblem),
         myPegTrips_  (theProblem)
   {
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPipPegList <SrcComp>::~WitPipPegList ()
   {
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipPegList <SrcComp>::append (
         SrcComp * theSrcComp,
         WitPeriod thePer,
         double    pegVol)
   {
   myPegTrips_.push (theSrcComp, thePer, pegVol);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipPegList <SrcComp>::consolidate (
         WitSchedule <SrcComp, double> & workSched)
   {
   SrcComp * theSrcComp;
   WitPeriod thePer;
   double    pegVol;

   WitPairStack <SrcComp, WitPeriod> thePairs (myProblem ());

   while (myPegTrips_.pop (theSrcComp, thePer, pegVol))
      {
      if (not workSched (theSrcComp).isAllocated ())
         workSched (theSrcComp).allocate (myProblem (), 0.0);

      workSched (theSrcComp)[thePer] += pegVol;

      thePairs.push (theSrcComp, thePer);
      }

   while (thePairs.pop (theSrcComp, thePer))
      {
      pegVol = workSched (theSrcComp)[thePer];

      if (pegVol == 0.0)
         continue;

      workSched (theSrcComp)[thePer] = 0.0;

      append (theSrcComp, thePer, pegVol);
      }
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipPegList <SrcComp>::getPegTrips (
         WitTripStack <SrcComp> & thePegTrips)
   {
   thePegTrips.revCopyFrom (myPegTrips_);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      double WitPipPegList <SrcComp>::pegVolFor (
         SrcComp * theSrcComp,
         WitPeriod thePer)
   {
   WitTripStack <SrcComp> thePegTrips (myProblem ());
   SrcComp *              pgdSrcComp;
   WitPeriod              pgdPer;
   double                 pegVol;

   getPegTrips (thePegTrips);

   while (thePegTrips.pop (pgdSrcComp, pgdPer, pegVol))
      if (pgdSrcComp == theSrcComp)
         if (pgdPer == thePer)
            return pegVol;

   return 0.0;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template PipPegList <SrcComp>.
//------------------------------------------------------------------------------

template class WitPipPegList <WitPart>;
template class WitPipPegList <WitOperation>;
template class WitPipPegList <WitSubEntry>;
@


1.83
log
@New pipShare.
@
text
@a25 1
#include <PipBold.h>
a425 1
   WitPipBold * theBold;
d431 1
a431 11
   if (myGlobalComp ()->newPipShare ())
      {
      theBldr = new WitPipBldr (this);

      theBldr->buildPegging ();

      delete theBldr;
      }
   else
      {
      theBold = new WitPipBold (this);
d433 1
a433 1
      theBold->buildPegging ();
d435 1
a435 2
      delete theBold;
      }
a549 21

#if 0

   if (myGlobalComp ()->newPipShare ())
      forEachOperation (theOpn, myProblem ())
         {
         expFound = false;

         forEachEl (theBopEnt, theOpn->bop ())
            if (theBopEnt->expAllowed ())
               {
               if (expFound)
                  myMsgFac () ("genericSmsg",
                     "Multiple explodeable BOP entries found "
                     "in newPipShare mode.");
               
               expFound = true;
               }
         }

#endif
@


1.82
log
@Began work on the new interpretation of pipShare.
@
text
@d564 2
d582 2
d677 6
a682 6
   WitObjStItr <WitPipTarg>    theItr;
   WitPipTarg *                theTarg;
   WitTripStack <WitOperation> thePegTrips (myProblem ());
   WitOperation *              theOpn;
   WitPeriod                   execPer;
   double                      pegVol;
d688 8
a695 3
      "   ---------------------------\n"
      "   Dem  Per  Opn  Per  ExecVol\n"
      "   ---------------------------\n");
d697 1
a697 1
   theItr.attachTo (myTargSeq_); 
d699 13
a711 3
   while (theItr.advance (theTarg))
      {
      theTarg->execVolPegList ()->getPegTrips (thePegTrips);
d713 4
a716 2
      if (thePegTrips.isEmpty ())
         continue;
d718 2
a719 3
      while (thePegTrips.pop (theOpn, execPer, pegVol))
         {
         printTargID (theTarg);
d721 2
a722 5
         fprintf (solnFile (),
            "  %3s  %3d  %7.3f\n",
            theOpn->operationName ().myCstring (),
            execPer,
            pegVol);
a723 4

      fprintf (solnFile (),
         "   ---------------------------\n");
      }
d730 6
a735 6
   WitObjStItr <WitPipTarg>   theItr;
   WitPipTarg *               theTarg;
   WitTripStack <WitSubEntry> thePegTrips (myProblem ());
   WitSubEntry *              theSub;
   WitPeriod                  execPer;
   double                     pegVol;
d741 3
a743 3
      "   -------------------------------------\n"
      "   Dem  Per  Opn  Idx  Idx  Per   SubVol\n"
      "   -------------------------------------\n");
d745 13
a757 1
   theItr.attachTo (myTargSeq_); 
d759 8
a766 3
   while (theItr.advance (theTarg))
      {
      theTarg->subVolPegList ()->getPegTrips (thePegTrips);
d768 4
a771 2
      if (thePegTrips.isEmpty ())
         continue;
d773 2
a774 3
      while (thePegTrips.pop (theSub, execPer, pegVol))
         {
         printTargID (theTarg);
d776 3
a778 7
         fprintf (solnFile (),
            "  %3s  %3d  %3d  %3d  %7.3f\n",
            theSub->myOperationName ().myCstring (),
            theSub->myBomEntIndex (),
            theSub->localIndex (),
            execPer,
            pegVol);
a779 4

      fprintf (solnFile (),
         "   -------------------------------------\n");
      }
d788 6
a793 6
   WitObjStItr <WitPipTarg>  theItr;
   WitPipTarg *              theTarg;
   WitTripStack <WitPart> thePegTrips (myProblem ());
   WitPart *              thePart;
   WitPeriod              thePer;
   double                 pegVol;
d800 1
a800 1
      "   Dem  Per  Part  Per  %9s\n"
d805 4
a808 1
   theItr.attachTo (myTargSeq_); 
d810 17
a826 3
   while (theItr.advance (theTarg))
      {
      theTarg->myPartPegList ()[theAttTag]->getPegTrips (thePegTrips);
d828 4
a831 2
      if (thePegTrips.isEmpty ())
         continue;
d833 2
a834 3
      while (thePegTrips.pop (thePart, thePer, pegVol))
         {
         printTargID (theTarg);
d836 2
a837 5
         fprintf (solnFile (),
            "  %4s  %3d  %9.3f\n",
            thePart->partName ().myCstring (),
            thePer,
            pegVol);
a838 4

      fprintf (solnFile (),
         "   ------------------------------\n");
      }
d843 1
a843 1
void WitPipPrtr::printTargID (WitPipTarg * & theTarg)
d845 5
a849 11
   if (theTarg != NULL)
      {
      fprintf (solnFile (),
         "   %3s  %3d",
         theTarg->myDemand ()->demandName ().myCstring (),
         theTarg->myShipPer ());

      theTarg = NULL;
      }
   else
      fprintf (solnFile (), "           ");
d975 22
@


1.81
log
@Revised mappingIndex code.
@
text
@d26 1
d427 1
d433 11
a443 1
   theBldr = new WitPipBldr (this);
d445 1
a445 1
   theBldr->buildPegging ();
d447 2
a448 1
   delete theBldr;
d545 5
a549 2
   WitSubEntry * theSub;
   WitPeriod     execPer;
d563 17
@


1.80
log
@Tie Breaking Prop-Rt.
@
text
@a38 1
#include <MapIdxI.h>
@


1.79
log
@Low-Pri Prop-Rt.
@
text
@d15 6
a20 6
//    Pip::SysMgr
//    Pip::SeqMgr
//    Pip::PegMgr
//    Pip::Printer
//    Pip::Targ
//    Pip::PegList <SrcComp>, with explicit instantiation.
d25 2
a26 2
#include <PipBuilder.h>
#include <PipPrinter.h>
d29 1
a29 1
#include <PipSysMgr.h>
d42 1
a42 1
// Implementation of class Pip::SysMgr.
d45 1
a45 1
WitPip::SysMgr::SysMgr (WitProblem * theProblem):
d52 1
a52 1
   mySeqMgr_ = new SeqMgr (myProblem ());
d59 1
a59 1
WitPip::SysMgr::~SysMgr ()
d71 1
a71 1
void WitPip::SysMgr::clearShipSeq ()
d82 1
a82 1
void WitPip::SysMgr::appendToShipSeq (
d96 1
a96 1
void WitPip::SysMgr::getShipSeq (WitDemTripStack & theShipSeq)
d107 1
a107 1
void WitPip::SysMgr::displayShipSeq ()
d114 1
a114 1
void WitPip::SysMgr::copyShipSeq (SysMgr * theSubSysMgr)
d118 1
a118 1
   mySeqMgr_->copy (theSubSysMgr->mySeqMgr_);
d125 1
a125 1
void WitPip::SysMgr::writeShipSeqData ()
d132 1
a132 1
void WitPip::SysMgr::setShipSeqShipPer (WitPeriod shipPer)
d139 1
a139 1
WitPeriod WitPip::SysMgr::shipSeqShipPer ()
d146 1
a146 1
void WitPip::SysMgr::buildPegging ()
d156 1
a156 1
   myPegMgr_ = new PegMgr (mySeqMgr_);
d163 1
a163 1
void WitPip::SysMgr::clearPegging ()
d179 1
a179 1
void WitPip::SysMgr::printPegging ()
d187 1
a187 1
void WitPip::SysMgr::getExecVolTrips (
d201 1
a201 1
void WitPip::SysMgr::getSubVolTrips (
d215 1
a215 1
void WitPip::SysMgr::getPartPegTrips (
d218 1
a218 1
      PartAtt            thePartAtt,
d223 1
a223 1
   myPegMgr ()->getPartPegTrips (theDemand, shipPer, thePartAtt, thePegTrips);
d229 1
a229 1
// Implementation of class Pip::SeqMgr.
d232 1
a232 1
WitPip::SeqMgr::SeqMgr (WitProblem * theProblem):
d242 1
a242 1
WitPip::SeqMgr::~SeqMgr ()
d249 1
a249 1
void WitPip::SeqMgr::clear ()
d256 1
a256 1
void WitPip::SeqMgr::append (
d268 1
a268 1
void WitPip::SeqMgr::get (WitDemTripStack & theShipSeq)
d275 1
a275 1
void WitPip::SeqMgr::reduce ()
d329 1
a329 1
void WitPip::SeqMgr::display ()
d357 1
a357 1
void WitPip::SeqMgr::copy (SeqMgr * theSeqMgr)
d370 1
a370 1
void WitPip::SeqMgr::writeData ()
d410 1
a410 1
void WitPip::SeqMgr::setShipPerForRead (WitPeriod shipPer)
d416 1
a416 1
// Implementation of class Pip::PegMgr.
d419 1
a419 1
WitPip::PegMgr::PegMgr (SeqMgr * theSeqMgr):
d426 2
d432 3
a434 2
      {
      Builder theBuilder (this);
d436 1
a436 2
      theBuilder.buildPegging ();
      }
d441 1
a441 1
WitPip::PegMgr::~PegMgr ()
d457 1
a457 1
void WitPip::PegMgr::print ()
d459 1
a459 1
   Printer thePrinter (this);
d461 1
a461 1
   thePrinter.print ();
d466 1
a466 1
void WitPip::PegMgr::getExecVolTrips (
d471 1
a471 1
   Targ * theTarg;
d483 1
a483 1
void WitPip::PegMgr::getSubVolTrips (
d488 1
a488 1
   Targ * theTarg;
d500 1
a500 1
void WitPip::PegMgr::getPartPegTrips (
d503 1
a503 1
      PartAtt            thePartAtt,
d506 1
a506 1
   Targ * theTarg;
d511 1
a511 1
      theTarg->myPartPegList ()[thePartAtt]->getPegTrips (thePegTrips);
d518 1
a518 3
WitPip::Targ * WitPip::PegMgr::myTargFor (
      WitDemand * theDemand,
      WitPeriod   shipPer)
d520 1
a520 1
   Targ * theTarg;
d531 1
a531 1
void WitPip::PegMgr::checkRestrictions ()
d552 1
a552 1
void WitPip::PegMgr::buildTargs ()
d558 1
a558 1
   Targ *          theTarg;
d568 1
a568 1
         theTarg = new Targ (theDemand, shipPer, this);
d576 1
a576 1
// Implementation of class Pip::Printer.
d579 1
a579 1
WitPip::Printer::Printer (PegMgr * thePegMgr):
d589 1
a589 1
WitPip::Printer::~Printer ()
d595 1
a595 1
void WitPip::Printer::print ()
d604 4
a607 4
   prtPartPip    (supplyVolAtt, "SupplyVol");
   prtPartPip    (  sideVolAtt,   "SideVol");
   prtPartPip    (  prodVolAtt,   "ProdVol");
   prtPartPip    (  consVolAtt,   "ConsVol");
d612 1
a612 1
void WitPip::Printer::findTargSeq ()
d639 1
a639 1
void WitPip::Printer::prtExecVolPip ()
d641 2
a642 2
   WitObjStItr <Targ>          theItr;
   Targ *                      theTarg;
d683 1
a683 1
void WitPip::Printer::prtSubVolPip ()
d685 2
a686 2
   WitObjStItr <Targ>         theItr;
   Targ *                     theTarg;
d729 3
a731 1
void WitPip::Printer::prtPartPip (PartAtt thePartAtt, const char * theAttName)
d733 2
a734 2
   WitObjStItr <Targ>     theItr;
   Targ *                 theTarg;
d754 1
a754 1
      theTarg->myPartPegList ()[thePartAtt]->getPegTrips (thePegTrips);
d777 1
a777 1
void WitPip::Printer::printTargID (Targ * & theTarg)
d793 1
a793 1
// Implementation of class Pip::Targ.
d796 4
a799 4
WitPip::Targ::Targ (
         WitDemand * theDemand, 
         WitPeriod   shipPer, 
         PegMgr *    thePegMgr):
d803 1
a803 1
      myPartPegList_ (nPartAtts)
d807 16
a822 1
   theProblem                   = myDemand_->myProblem ();
d824 2
a825 6
   execVolPegList_              = new PegList <WitOperation> (theProblem);
   subVolPegList_               = new PegList <WitSubEntry>  (theProblem);
   myPartPegList_[supplyVolAtt] = new PegList <WitPart>      (theProblem);
   myPartPegList_[  sideVolAtt] = new PegList <WitPart>      (theProblem);
   myPartPegList_[  prodVolAtt] = new PegList <WitPart>      (theProblem);
   myPartPegList_[  consVolAtt] = new PegList <WitPart>      (theProblem);
d830 1
a830 1
WitPip::Targ::~Targ ()
d832 4
a835 4
   delete myPartPegList_[  consVolAtt];
   delete myPartPegList_[  prodVolAtt];
   delete myPartPegList_[  sideVolAtt];
   delete myPartPegList_[supplyVolAtt];
d841 1
a841 1
// Implementation of class template Pip::PegList <SrcComp>.
d845 1
a845 1
      WitPip::PegList <SrcComp>::PegList (WitProblem * theProblem):
d855 1
a855 1
      WitPip::PegList <SrcComp>::~PegList ()
d862 1
a862 1
      void WitPip::PegList <SrcComp>::append (
d873 1
a873 1
      void WitPip::PegList <SrcComp>::consolidate (
d908 1
a908 1
      void WitPip::PegList <SrcComp>::getPegTrips (
d915 1
a915 1
// Explicit instantiation of class template Pip::PegList <SrcComp>.
d918 3
a920 3
template class WitPip::PegList <WitPart>;
template class WitPip::PegList <WitOperation>;
template class WitPip::PegList <WitSubEntry>;
@


1.78
log
@Made a PIP warning message issue less frequently.
@
text
@d641 1
a641 1
   WitObjStItr <Targ>          theTargItr;
d656 1
a656 1
   theTargItr.attachTo (myTargSeq_); 
d658 1
a658 1
   while (theTargItr.advance (theTarg))
d685 1
a685 1
   WitObjStItr <Targ>         theTargItr;
d700 1
a700 1
   theTargItr.attachTo (myTargSeq_); 
d702 1
a702 1
   while (theTargItr.advance (theTarg))
d731 1
a731 1
   WitObjStItr <Targ>     theTargItr;
d748 1
a748 1
   theTargItr.attachTo (myTargSeq_); 
d750 1
a750 1
   while (theTargItr.advance (theTarg))
@


1.77
log
@PIP.
@
text
@d319 1
a319 1
   if (maxRed > 0.0)
@


1.76
log
@PIP.
@
text
@d533 2
a534 5
   WitOperation * theOpn;
   int            nExpBopEnts;
   WitBopEntry *  theBopEnt;
   WitSubEntry *  theSub;
   WitPeriod      execPer;
a537 16

   if (not myGlobalComp ()->allowMultiPip ())
      forEachOperation (theOpn, myProblem ())
         {
         nExpBopEnts = 0;

         forEachEl (theBopEnt, theOpn->bop ())
            if (theBopEnt->expAllowed ())
               {
               nExpBopEnts ++;

               if (nExpBopEnts > 1)
                  myMsgFac () ("nyiForPIPSmsg",
                     "multiple explodable BOP entries for a single operation");
               }
         }
@


1.75
log
@PIP.
@
text
@d561 6
a566 1
            myMsgFac () ("nyiForPIPSmsg", "negative consRates on substitutes");
@


1.74
log
@PIP.
@
text
@d18 1
a18 1
//    Pip::OldPrtr
d457 1
a457 7
   WitDemand * theDemand;
   WitPeriod   shipPer;
   Targ *      theTarg;

   fprintf (myProblem ()->solnFile (),
      "\n\n"
      "Post-Implosion Pegging:\n");
d459 1
a459 8
   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theTarg = myTargs_.myPtrAt (theDemand, shipPer);

         if (theTarg != NULL)
            theTarg->print ();
         }
d590 1
a590 1
// Implementation of class Pip::OldPrtr.
d593 1
a593 1
WitPip::OldPrtr::OldPrtr (PegMgr * thePegMgr):
d603 1
a603 1
WitPip::OldPrtr::~OldPrtr ()
d609 1
a609 1
void WitPip::OldPrtr::print ()
d611 2
d616 1
a616 1
   prtSubVolPip ();
d618 4
a621 4
   prtPartPip (supplyVolAtt);
   prtPartPip   (sideVolAtt);
   prtPartPip   (prodVolAtt);
   prtPartPip   (consVolAtt);
d626 1
a626 1
void WitPip::OldPrtr::findTargSeq ()
d653 1
a653 1
void WitPip::OldPrtr::prtExecVolPip ()
d655 3
a659 2
   WitPairStack <Targ, double> theTargPairs (myProblem ());
   Targ *                      theTarg;
d664 1
a664 1
      "ExecVol Pegging:\n"
d667 1
a667 1
      "   Opn  Per  Dem  Per  ExecVol\n"
d670 5
a674 5
   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         if (theOpn->execVol ()[execPer] == 0.0)
            continue;
d676 2
a677 1
         getExecVolTargPairs (theOpn, execPer, theTargPairs);
d679 3
a681 8
         while (theTargPairs.pop (theTarg, pegVol))
            fprintf (solnFile (),
               "   %3s  %3d  %3s  %3d  %7.3f\n",
               theOpn->operationName ().myCstring (),
               execPer,
               theTarg->myDemand ()->demandName ().myCstring (),
               theTarg->myShipPer (),
               pegVol);
d684 1
a684 2
            "   %3s  %3d            %7.3f\n"
            "   ---------------------------\n",
d687 1
a687 1
            theOpn->execVol ()[execPer]);
d689 4
d697 1
a697 1
void WitPip::OldPrtr::prtSubVolPip ()
d699 6
a704 5
   WitSubEntry *               theSub;
   WitPeriod                   execPer;
   WitPairStack <Targ, double> theTargPairs (myProblem ());
   Targ *                      theTarg;
   double                      pegVol;
d708 1
a708 1
      "SubVol Pegging:\n"
d711 1
a711 1
      "   Opn   BE  Sub  Per  Dem  Per  ExecVol\n"
d714 5
a718 5
   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         if (theSub->subVol ()[execPer] == 0.0)
            continue;
d720 2
a721 1
         getSubVolTargPairs (theSub, execPer, theTargPairs);
d723 3
a725 10
         while (theTargPairs.pop (theTarg, pegVol))
            fprintf (solnFile (),
               "   %3s  %3d  %3d  %3d  %3s  %3d  %7.3f\n",
               theSub->myOperationName ().myCstring (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               execPer,
               theTarg->myDemand ()->demandName ().myCstring (),
               theTarg->myShipPer (),
               pegVol);
d728 1
a728 2
            "   %3s  %3d  %3d  %3d            %7.3f\n"
            "   -------------------------------------\n",
d733 1
a733 1
            theSub->subVol ()[execPer]);
d735 4
d743 1
a743 1
void WitPip::OldPrtr::prtPartPip (PartAtt thePartAtt)
d745 6
a750 7
   const char *                theAttName;
   WitPart *                   thePart;
   WitPeriod                   thePer;
   double                      thePartVol;
   WitPairStack <Targ, double> theTargPairs (myProblem ());
   Targ *                      theTarg;
   double                      pegVol;
a751 7
   theAttName =
      (thePartAtt == supplyVolAtt)? "SuppVol":
      (thePartAtt ==   sideVolAtt)? "SideVol":
      (thePartAtt ==   prodVolAtt)? "ProdVol":
      (thePartAtt ==   consVolAtt)? "ConsVol":
                                    "ERROR";
   
d754 1
a754 1
      "%7s Pegging:\n"
d756 3
a758 3
      "   ----------------------------\n"
      "   Part  Per  Dem  Per  %7s\n"
      "   ----------------------------\n",
d762 10
a771 2
   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
d773 1
a773 20
         thePartVol =
            (thePartAtt == supplyVolAtt)? thePart->supplyVol ()[thePer]:
            (thePartAtt ==   sideVolAtt)? -2.0:
            (thePartAtt ==   prodVolAtt)? thePart->  prodVol ()[thePer]:
            (thePartAtt ==   consVolAtt)? thePart->  consVol ()[thePer]:
                                          -1.0;

         if (thePartVol == 0.0)
            continue;

         getPartTargPairs (thePart, thePer, thePartAtt, theTargPairs);

         while (theTargPairs.pop (theTarg, pegVol))
            fprintf (solnFile (),
               "   %4s  %3d  %3s  %3d  %7.3f\n",
               thePart->partName ().myCstring (),
               thePer,
               theTarg->myDemand ()->demandName ().myCstring (),
               theTarg->myShipPer (),
               pegVol);
d776 1
a776 2
            "   %4s  %3d            %7.3f\n"
            "   ----------------------------\n",
d779 1
a779 1
            thePartVol);
a780 1
   }
d782 2
a783 20
//------------------------------------------------------------------------------

void WitPip::OldPrtr::getExecVolTargPairs (
      WitOperation *                theOpn, 
      WitPeriod                     execPer, 
      WitPairStack <Targ, double> & theTargPairs)
   {
   WitObjStItr <Targ> theTargItr;
   double             pegVol;

   theTargPairs.clear ();

   theTargItr.attachTo (myTargSeq_); 

   while (theTargItr.advance ())
      {
      pegVol = theTargItr->execVolPegList ()->pegVolFor (theOpn, execPer);

      if (pegVol > 0.0)
         theTargPairs.push (theTargItr.myObject (), pegVol);
a784 2

   theTargPairs.reverse ();
d789 1
a789 4
void WitPip::OldPrtr::getSubVolTargPairs (
      WitSubEntry *                 theSub,
      WitPeriod                     execPer,
      WitPairStack <Targ, double> & theTargPairs)
d791 1
a791 8
   WitObjStItr <Targ> theTargItr;
   double             pegVol;

   theTargPairs.clear ();

   theTargItr.attachTo (myTargSeq_); 

   while (theTargItr.advance ())
d793 4
a796 1
      pegVol = theTargItr->subVolPegList ()->pegVolFor (theSub, execPer);
d798 1
a798 2
      if (pegVol > 0.0)
         theTargPairs.push (theTargItr.myObject (), pegVol);
d800 2
a801 29

   theTargPairs.reverse ();
   }

//------------------------------------------------------------------------------

void WitPip::OldPrtr::getPartTargPairs (
      WitPart *                     thePart,
      WitPeriod                     thePer,
      PartAtt                       thePartAtt,
      WitPairStack <Targ, double> & theTargPairs)
   {
   WitObjStItr <Targ> theTargItr;
   double             pegVol;

   theTargPairs.clear ();

   theTargItr.attachTo (myTargSeq_); 

   while (theTargItr.advance ())
      {
      pegVol =
         theTargItr->myPartPegList ()[thePartAtt]->pegVolFor (thePart, thePer);

      if (pegVol > 0.0)
         theTargPairs.push (theTargItr.myObject (), pegVol);
      }

   theTargPairs.reverse ();
a841 110

void WitPip::Targ::print ()
   {
   if (execVolPegList_->isEmpty ())
      if (subVolPegList_->isEmpty ())
         if (myPartPegList_[supplyVolAtt]->isEmpty ())
            if (myPartPegList_[sideVolAtt]->isEmpty ())
               if (myPartPegList_[prodVolAtt]->isEmpty ())
                  if (myPartPegList_[consVolAtt]->isEmpty ())
                     return;

   fprintf (solnFile (),
      "\n\n"
      "Part %s, Demand %s, Ship Per %d:\n",
      myDemand_->demandedPartName ().myCstring (),
      myDemand_->demandName ().myCstring (),
      myShipPer_);

   printExecVolPegging ();
   printSubVolPegging  ();

   printPartPegging (supplyVolAtt,  "SupVol");
   printPartPegging (  sideVolAtt, "SideVol");
   printPartPegging (  prodVolAtt, "ProdVol");
   printPartPegging (  consVolAtt, "ConsVol");
   }

//------------------------------------------------------------------------------

void WitPip::Targ::printExecVolPegging ()
   {
   WitOpnTripStack execVolTrips (myDemand ()->myProblem ());
   WitOperation *  theOpn;
   WitPeriod       execPer;
   double          pdgExecVol;

   if (execVolPegList_->isEmpty ())
      return;

   execVolPegList_->getPegTrips (execVolTrips);

   fprintf (solnFile (), "\n   Opn   Per  ExecVol\n");

   while (execVolTrips.pop (theOpn, execPer, pdgExecVol))
      fprintf (solnFile (),
         "   %-3s   %3d %8.3f\n",
         theOpn->operationName ().myCstring (),
         execPer,
         pdgExecVol);
   }

//------------------------------------------------------------------------------

void WitPip::Targ::printSubVolPegging ()
   {
   WitSubTripStack subVolTrips (myDemand ()->myProblem ());
   WitSubEntry *   theSub;
   WitPeriod       execPer;
   double          pdgSubVol;

   if (subVolPegList_->isEmpty ())
      return;

   subVolPegList_->getPegTrips (subVolTrips);

   fprintf (solnFile (), "\n   Opn   Part   Per   SubVol\n");

   while (subVolTrips.pop (theSub, execPer, pdgSubVol))
      fprintf (solnFile (),
         "   %-3s   %-4s   %3d %8.3f\n",
         theSub->myOperationName ().myCstring (),
         theSub->myPartName      ().myCstring (),
         execPer,
         pdgSubVol);
   }

//------------------------------------------------------------------------------

void WitPip::Targ::printPartPegging (
      PartAtt      thePartAtt,
      const char * pegVolName)
   {
   WitPartTripStack thePegTrips (myDemand ()->myProblem ());
   WitPart *        thePart;
   WitPeriod        pegPer;
   double           pegVol;

   if (myPartPegList_[thePartAtt]->isEmpty ())
      return;

   myPartPegList_[thePartAtt]->getPegTrips (thePegTrips);

   fprintf (solnFile (), "\n   Part  Per %8s\n", pegVolName);

   while (thePegTrips.pop (thePart, pegPer, pegVol))
      fprintf (solnFile (),
         "   %-3s   %3d %8.3f\n",
         thePart->partName ().myCstring (),
         pegPer,
         pegVol);
   }

//------------------------------------------------------------------------------

FILE * WitPip::Targ::solnFile ()
   {
   return myDemand ()->myProblem ()->solnFile ();
   }

//------------------------------------------------------------------------------
a908 22
      double WitPip::PegList <SrcComp>::pegVolFor (
         SrcComp * theSrcComp,
         WitPeriod thePer)
   {
   WitTripStack <SrcComp> thePegTrips (myProblem ());
   SrcComp *              pegSrcComp;
   WitPeriod              pegPer;
   double                 pegVol;

   getPegTrips (thePegTrips);

   while (thePegTrips.pop (pegSrcComp, pegPer, pegVol))
      if (pegSrcComp == theSrcComp)
         if (pegPer == thePer)
            return pegVol;

   return 0.0;
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
a912 8
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      bool WitPip::PegList <SrcComp>::isEmpty ()
   {
   return myPegTrips_.isEmpty ();
@


1.73
log
@PIP.
@
text
@d18 1
a18 1
//    Pip::Printer
d603 1
a603 1
// Implementation of class Pip::Printer.
d606 1
a606 1
WitPip::Printer::Printer (PegMgr * thePegMgr):
d616 1
a616 1
WitPip::Printer::~Printer ()
d622 1
a622 1
void WitPip::Printer::print ()
d637 1
a637 1
void WitPip::Printer::findTargSeq ()
d664 1
a664 1
void WitPip::Printer::prtExecVolPip ()
d708 1
a708 1
void WitPip::Printer::prtSubVolPip ()
d756 1
a756 1
void WitPip::Printer::prtPartPip (PartAtt thePartAtt)
d818 1
a818 1
void WitPip::Printer::getExecVolTargPairs (
d843 1
a843 1
void WitPip::Printer::getSubVolTargPairs (
d868 1
a868 1
void WitPip::Printer::getPartTargPairs (
@


1.72
log
@PIP.
@
text
@a456 1
   Printer     thePrinter (this);
a472 2

   thePrinter.print ();
d628 5
d756 62
d823 2
a824 6
   WitObjStItr <Targ>          theTargItr;
   Targ *                      theTarg;
   WitTripStack <WitOperation> thePegTrips (myProblem ());
   WitOperation *              pegOpn;
   WitPeriod                   pegPer;
   double                      pegVol;
d830 1
a830 1
   while (theTargItr.advance (theTarg))
d832 1
a832 1
      theTarg->execVolPegList ()->getPegTrips (thePegTrips);
d834 2
a835 4
      while (thePegTrips.pop (pegOpn, pegPer, pegVol))
         if (pegOpn == theOpn)
            if (pegPer == execPer)
               theTargPairs.push (theTarg, pegVol);
d848 28
a875 6
   WitObjStItr <Targ>         theTargItr;
   Targ *                     theTarg;
   WitTripStack <WitSubEntry> thePegTrips (myProblem ());
   WitSubEntry *              pegSub;
   WitPeriod                  pegPer;
   double                     pegVol;
d881 1
a881 1
   while (theTargItr.advance (theTarg))
d883 2
a884 1
      theTarg->subVolPegList ()->getPegTrips (thePegTrips);
d886 2
a887 4
      while (thePegTrips.pop (pegSub, pegPer, pegVol))
         if (pegSub == theSub)
            if (pegPer == execPer)
               theTargPairs.push (theTarg, pegVol);
d1103 22
@


1.71
log
@PIP.
@
text
@d18 1
d26 1
a36 1
#include <ObjStack.h>
d457 1
d474 2
d603 209
@


1.70
log
@PIP.
@
text
@d554 4
a557 3
   forEachOperation (theOpn, myProblem ())
      {
      nExpBopEnts = 0;
d559 4
a562 4
      forEachEl (theBopEnt, theOpn->bop ())
         if (theBopEnt->expAllowed ())
            {
            nExpBopEnts ++;
d564 5
a568 5
            if (nExpBopEnts > 1)
               myMsgFac () ("nyiForPIPSmsg",
                  "multiple explodable BOP entries for a single operation");
            }
      }
@


1.69
log
@Double Precision.
@
text
@d290 1
a290 1
      theDemand->shipVol ().copyInto (availShipVol (theDemand));
@


1.68
log
@Double Precision.
@
text
@d290 1
a290 1
      theDemand->shipVol ().convCopyInto (availShipVol (theDemand));
@


1.67
log
@Continued double precision.
@
text
@d290 1
a290 1
      theDemand->shipVol ().copyIntoTVec (availShipVol (theDemand));
@


1.66
log
@Continued double precision.
@
text
@d399 1
a399 1
      myDataWriter ()->writeStrDbl       ("pipSeqIncShipVol", incShipVol, -1.0);
@


1.65
log
@Continued double precision.
@
text
@d397 1
a397 1
      myDataWriter ()->writeInt          ("pipSeqShipPeriod", shipPer, -1);
d399 1
a399 4
      myDataWriter ()->writeFloat        (
         "pipSeqIncShipVol",
         static_cast <float> (incShipVol),
         -1.0f);
@


1.64
log
@Continued implementation of PIP.
@
text
@d397 6
a402 2
      myDataWriter ()->writeInt          ("pipSeqShipPeriod", shipPer,    -1);
      myDataWriter ()->writeFloat        ("pipSeqIncShipVol", incShipVol, -1.0);
@


1.63
log
@Continued implementation of PIP.
@
text
@d131 14
d233 3
a235 2
      WitProbAssoc (theProblem),
      revShipSeq_  (theProblem)
d393 3
a395 1
      myDataWriter ()->writeKeyWord      ("problem");
d397 1
a397 9
      myDataWriter ()->writeString       ("pipSeqPartName",
         theDemand->demandedPartName (),
         "");

      myDataWriter ()->writeString       ("pipSeqDemandName",
         theDemand->demandName (),
         "");

      myDataWriter ()->writeInt          ("pipSeqShipPeriod", shipPer, -1);
a399 2
      myDataWriter ()->writeBool         ("pipSeqAppendsNow", true, false);

d404 7
@


1.62
log
@Added the PIP shipment sequence to the output of displayData.
@
text
@d34 1
d123 7
d350 47
@


1.61
log
@Continued implementation of PIP.
@
text
@d105 7
a157 2
   mySeqMgr_->print ();

d159 1
a159 1
      myPegMgr ()->printPegging ();
d305 1
a305 1
void WitPip::SeqMgr::print ()
d312 2
d315 3
d319 1
a319 4

   fprintf (myProblem ()->solnFile (),
      "\n\n"
      "PIP Shipment Sequence:\n\n");
d324 3
a326 5
      {
      fprintf (myProblem ()->solnFile (),
         "   Part %s, Demand %s, ShipPer %2d, IncShipVol %3.0f\n",
         theDemand->demandedPartName ().myCstring (),
         theDemand->demandName       ().myCstring (),
a328 1
      }
d384 1
a384 1
void WitPip::PegMgr::printPegging ()
d400 1
a400 1
            theTarg->printPegging ();
d569 1
a569 1
void WitPip::Targ::printPegging ()
@


1.60
log
@Implemented copying of the PIP shipment sequence.
@
text
@d15 1
a15 1
//    Pip::SubsysMgr
d27 1
a27 1
#include <PipMgr.h>
d40 1
a40 1
// Implementation of class Pip::SubsysMgr.
d43 1
a43 1
WitPip::SubsysMgr::SubsysMgr (WitProblem * theProblem):
d57 1
a57 1
WitPip::SubsysMgr::~SubsysMgr ()
d69 1
a69 1
void WitPip::SubsysMgr::clearShipSeq ()
d80 1
a80 1
void WitPip::SubsysMgr::appendToShipSeq (
d94 1
a94 1
void WitPip::SubsysMgr::getShipSeq (WitDemTripStack & theShipSeq)
d105 1
a105 1
void WitPip::SubsysMgr::copyShipSeq (SubsysMgr * theSubSysMgr)
d116 1
a116 1
void WitPip::SubsysMgr::buildPegging ()
d133 1
a133 1
void WitPip::SubsysMgr::clearPegging ()
d149 1
a149 1
void WitPip::SubsysMgr::printPegging ()
d159 1
a159 1
void WitPip::SubsysMgr::getExecVolTrips (
d173 1
a173 1
void WitPip::SubsysMgr::getSubVolTrips (
d187 1
a187 1
void WitPip::SubsysMgr::getPartPegTrips (
@


1.59
log
@Continued implementation of PIP.
@
text
@d105 11
d325 13
@


1.58
log
@Continued implementation of PIP.
@
text
@d155 1
a155 4
   if (peggingExists ())
      myPegMgr ()->getExecVolTrips (theDemand, shipPer, execVolTrips);
   else
      execVolTrips.clear ();
d169 1
a169 4
   if (peggingExists ())
      myPegMgr ()->getSubVolTrips (theDemand, shipPer, subVolTrips);
   else
      subVolTrips.clear ();
d184 1
a184 8
   if (peggingExists ())
      myPegMgr ()->getPartPegTrips (
         theDemand,
         shipPer,
         thePartAtt,
         thePegTrips);
   else
      thePegTrips.clear ();
@


1.57
log
@Continued implementation of PIP.
@
text
@d16 1
d26 1
d46 1
a46 2
      myPegMgr_    (NULL),
      revShipSeq_  (theProblem)
d48 5
a60 2
   clearShipSeq ();

d62 1
d73 1
a73 1
   revShipSeq_.clear ();
d87 1
a87 3
   witAssert (incShipVol >= NET_TOL);

   revShipSeq_.push (theDemand, shipPer, incShipVol);
d98 1
a98 1
   theShipSeq.revCopyFrom (revShipSeq_);
d111 1
a111 1
   reduceShipSeq ();
d115 1
a115 1
   myPegMgr_ = new PegMgr (this);
d140 1
a140 1
   printShipSeq ();
d203 44
d248 1
a248 1
void WitPip::SubsysMgr::reduceShipSeq ()
d289 1
a289 1
         appendToShipSeq (theDemand, shipPer, incShipVol);
d302 1
a302 1
void WitPip::SubsysMgr::printShipSeq ()
d316 1
a316 1
   getShipSeq (theShipSeq);
d333 1
a333 1
WitPip::PegMgr::PegMgr (SubsysMgr * theSubsysMgr):
d335 1
a335 1
      WitProbAssoc (theSubsysMgr->myProblem ()),
d337 2
a338 2
      mySubsysMgr_ (theSubsysMgr),
      myTargs_     (myProblem ())
d500 1
a500 1
   mySubsysMgr_->getShipSeq (theShipSeq);
@


1.56
log
@Continued implementation of PIP.
@
text
@d15 2
a16 2
//    Pip::Mgr
//    Pip::Coord
d24 1
a24 1
#include <PipCoord.h>
d38 1
a38 1
// Implementation of class Pip::Mgr.
d41 1
a41 1
WitPip::Mgr::Mgr (WitProblem * theProblem):
d44 1
a44 1
      myCoord_     (NULL),
d51 1
a51 1
WitPip::Mgr::~Mgr ()
d57 1
a57 1
   delete myCoord_;
d64 1
a64 1
void WitPip::Mgr::clearShipSeq ()
d75 1
a75 1
void WitPip::Mgr::appendToShipSeq (
d91 1
a91 1
void WitPip::Mgr::getShipSeq (WitDemTripStack & theShipSeq)
d102 1
a102 1
void WitPip::Mgr::buildPegging ()
d112 1
a112 1
   myCoord_ = new Coord (this);
d119 1
a119 1
void WitPip::Mgr::clearPegging ()
d126 1
a126 1
   delete myCoord ();
d128 1
a128 1
   myCoord_ = NULL;
d135 1
a135 1
void WitPip::Mgr::printPegging ()
d140 1
a140 1
      myCoord ()->printPegging ();
d145 1
a145 1
void WitPip::Mgr::getExecVolTrips (
d153 1
a153 1
      myCoord ()->getExecVolTrips (theDemand, shipPer, execVolTrips);
d162 1
a162 1
void WitPip::Mgr::getSubVolTrips (
d170 1
a170 1
      myCoord ()->getSubVolTrips (theDemand, shipPer, subVolTrips);
d179 1
a179 1
void WitPip::Mgr::getPartPegTrips (
d188 1
a188 1
      myCoord ()->getPartPegTrips (
d201 1
a201 1
void WitPip::Mgr::reduceShipSeq ()
d227 1
a227 3
         reduc      = incShipVol - availShipVol (theDemand)[shipPer];

         incShipVol = availShipVol (theDemand)[shipPer];
d235 2
d255 1
a255 1
void WitPip::Mgr::printShipSeq ()
d283 1
a283 1
// Implementation of class Pip::Coord.
d286 1
a286 1
WitPip::Coord::Coord (Mgr * theMgr):
d288 1
a288 1
      WitProbAssoc (theMgr->myProblem ()),
d290 1
a290 1
      myMgr_       (theMgr),
d306 1
a306 1
WitPip::Coord::~Coord ()
d322 1
a322 1
void WitPip::Coord::printPegging ()
d344 1
a344 1
void WitPip::Coord::getExecVolTrips (
d361 1
a361 1
void WitPip::Coord::getSubVolTrips (
d378 1
a378 1
void WitPip::Coord::getPartPegTrips (
d396 1
a396 1
WitPip::Targ * WitPip::Coord::myTargFor (
d411 1
a411 1
void WitPip::Coord::checkRestrictions ()
d445 1
a445 1
void WitPip::Coord::buildTargs ()
d453 1
a453 1
   myMgr_->getShipSeq (theShipSeq);
d472 4
a475 1
WitPip::Targ::Targ (WitDemand * theDemand, WitPeriod shipPer, Coord * theCoord):
@


1.55
log
@Continued implementation of PIP.
@
text
@a31 2
#include <PerPair.h>
#include <PerPairMgr.h>
d148 1
a148 1
      WitOpnTripStOld & execVolTrips)
d165 1
a165 1
      WitSubTripStOld & subVolTrips)
d183 1
a183 1
      WitPartTripStOld & thePegTrips)
a294 4
   myOpnPairMgr_  = new WitPerPairMgr <WitOperation> (myProblem ());
   mySubPairMgr_  = new WitPerPairMgr <WitSubEntry>  (myProblem ());
   myPartPairMgr_ = new WitPerPairMgr <WitPart>      (myProblem ());

a316 4
   delete myPartPairMgr_;
   delete mySubPairMgr_;
   delete myOpnPairMgr_;

d347 1
a347 1
      WitOpnTripStOld & execVolTrips)
d364 1
a364 1
      WitSubTripStOld & subVolTrips)
d382 1
a382 1
      WitPartTripStOld & thePegTrips)
d478 1
a478 3
   WitPerPairMgr <WitPart> * thePartPairMgr;

   thePartPairMgr  = theCoord->myPartPairMgr ();
d480 1
a480 2
   execVolPegList_ = new PegList <WitOperation> (theCoord->myOpnPairMgr ());
   subVolPegList_  = new PegList <WitSubEntry>  (theCoord->mySubPairMgr ());
d482 6
a487 4
   myPartPegList_[supplyVolAtt] = new PegList <WitPart> (thePartPairMgr);
   myPartPegList_[  sideVolAtt] = new PegList <WitPart> (thePartPairMgr);
   myPartPegList_[  prodVolAtt] = new PegList <WitPart> (thePartPairMgr);
   myPartPegList_[  consVolAtt] = new PegList <WitPart> (thePartPairMgr);
d534 1
a534 1
   WitOpnTripStOld execVolTrips (myDemand ()->myProblem ());
d546 1
a546 1
   while (popTriple (execVolTrips, theOpn, execPer, pdgExecVol))
d558 1
a558 1
   WitSubTripStOld subVolTrips (myDemand ()->myProblem ());
d570 1
a570 1
   while (popTriple (subVolTrips, theSub, execPer, pdgSubVol))
d585 1
a585 1
   WitPartTripStOld thePegTrips (myDemand ()->myProblem ());
d597 1
a597 1
   while (popTriple (thePegTrips, thePart, pegPer, pegVol))
d617 1
a617 2
      WitPip::PegList <SrcComp>::PegList (
            WitPerPairMgr <SrcComp> * thePerPairMgr):
d619 2
a620 2
         myPegTrips_   (thePerPairMgr->myProblem ()),
         myPerPairMgr_ (thePerPairMgr)
d639 1
a639 5
   WitPerPair <SrcComp> * thePerPair;

   thePerPair = myPerPairMgr_->myPerPairFor (theSrcComp, thePer);

   myPegTrips_.push (thePerPair, pegVol);
d652 1
a652 1
   WitPairStack <SrcComp, WitPeriod> thePairs (myPerPairMgr_->myProblem ());
d654 1
a654 1
   while (popTriple (myPegTrips_, theSrcComp, thePer, pegVol))
d657 1
a657 1
         workSched (theSrcComp).allocate (myPerPairMgr_->myProblem (), 0.0);
d681 1
a681 1
            WitPairStack <WitPerPair <SrcComp>, double> & thePegTrips)
@


1.54
log
@Continued implementation of PIP.
@
text
@a67 3
   WitDemPer * theDemPer;
   double      incShipVol;

d70 1
a70 2
   while (revShipSeq_.pop (theDemPer, incShipVol))
      delete theDemPer;
a81 2
   WitDemPer * theDemPer;

d86 1
a86 3
   theDemPer = new WitDemPer (theDemand, shipPer);

   revShipSeq_.push (theDemPer, incShipVol);
d150 1
a150 1
      WitOpnTripStack & execVolTrips)
d167 1
a167 1
      WitSubTripStack & subVolTrips)
d185 1
a185 1
      WitPartTripStack & thePegTrips)
a207 2
   WitDemPer * theDemPer;
   double      incShipVol;
d210 1
d225 1
a225 1
   while (theShipSeq.pop (theDemPer, incShipVol))
a226 4
      theDemPer->getElems (theDemand, shipPer);

      delete theDemPer;

d273 1
a273 1
   while (popTriple (theShipSeq, theDemand, shipPer, incShipVol))
d285 1
a285 1
// Implementation of class Pip::Mgr.
d357 1
a357 1
      WitOpnTripStack & execVolTrips)
d374 1
a374 1
      WitSubTripStack & subVolTrips)
d392 1
a392 1
      WitPartTripStack & thePegTrips)
d465 1
a465 1
   while (popTriple (theShipSeq, theDemand, shipPer, incShipVol))
d545 1
a545 1
   WitOpnTripStack execVolTrips (myDemand ()->myProblem ());
d569 1
a569 1
   WitSubTripStack subVolTrips (myDemand ()->myProblem ());
d596 1
a596 1
   WitPartTripStack thePegTrips (myDemand ()->myProblem ());
@


1.53
log
@Continued implementation of PIP.
@
text
@d116 4
a146 2
   WitTimer::enterSection ("pip");

a150 2

   WitTimer::leaveSection ("pip");
d207 59
@


1.52
log
@Continued implementation of PIP.
@
text
@d145 2
d207 29
@


1.51
log
@Continued implementation of PIP.
@
text
@d388 1
a388 1
   while (pop (theShipSeq, theDemand, shipPer, incShipVol))
d480 1
a480 1
   while (pop (execVolTrips, theOpn, execPer, pdgExecVol))
d504 1
a504 1
   while (pop (subVolTrips, theSub, execPer, pdgSubVol))
d531 1
a531 1
   while (pop (thePegTrips, thePart, pegPer, pegVol))
d593 1
a593 1
   while (pop (myPegTrips_, theSrcComp, thePer, pegVol))
@


1.50
log
@Continued implementation of PIP.
@
text
@d55 2
d60 2
d81 1
a81 1
void WitPip::Mgr::recIncShipVol (
d88 2
d95 2
d103 2
d106 2
d114 3
a116 1
   witAssert (myGlobalComp ()->pip ());
d119 2
d127 5
d135 2
d143 6
a148 1
   myCoord ()->printPegging ();
d158 2
d164 2
d175 2
d181 2
d193 2
d203 2
a217 2
   WitTimer::enterSection ("pip");

a230 2

   WitTimer::leaveSection ("pip");
d351 3
@


1.49
log
@Continued implementation of PIP.
@
text
@d18 1
a18 9
//    Pip::PegList <SrcComp>
//    Pip::SrcMgr  <SrcComp>
//    Pip::Src     <SrcComp>
// 
// Contains the explicit instantiation of the following templates:
//
//    Pip::PegList <SrcComp>
//    Pip::SrcMgr  <SrcComp>
//    Pip::Src     <SrcComp>
a20 2
#include <PipSrc.h>
#include <PipSrcMgr.h>
d33 1
d93 1
a93 1
void WitPip::Mgr::getShipSeq (ShipSeq & theShipSeq)
d125 4
a128 4
void WitPip::Mgr::getExecVolPairs (
      WitDemand *    theDemand,
      WitPeriod      shipPer,
      OpnPairStack & execVolPairs)
d131 1
a131 1
      myCoord ()->getExecVolPairs (theDemand, shipPer, execVolPairs);
d133 1
a133 1
      execVolPairs.clear ();
d138 4
a141 4
void WitPip::Mgr::getSubVolPairs (
      WitDemand *    theDemand,
      WitPeriod      shipPer,
      SubPairStack & subVolPairs)
d144 1
a144 1
      myCoord ()->getSubVolPairs (theDemand, shipPer, subVolPairs);
d146 1
a146 1
      subVolPairs.clear ();
d151 5
a155 5
void WitPip::Mgr::getPartPegPairs (
      WitDemand *     theDemand,
      WitPeriod       shipPer,
      PartAtt         thePartAtt,
      PartPairStack & thePartPairs)
d158 1
a158 1
      myCoord ()->getPartPegPairs (
d162 1
a162 1
         thePartPairs);
d164 1
a164 1
      thePartPairs.clear ();
d182 3
a184 3
   myOpnSrcMgr_  = new SrcMgr <WitOperation> (myProblem ());
   mySubSrcMgr_  = new SrcMgr <WitSubEntry>  (myProblem ());
   myPartSrcMgr_ = new SrcMgr <WitPart>      (myProblem ());
a193 4
   myOpnSrcMgr_ ->postBuild ();
   mySubSrcMgr_ ->postBuild ();
   myPartSrcMgr_->postBuild ();

d210 3
a212 3
   delete myPartSrcMgr_;
   delete mySubSrcMgr_;
   delete myOpnSrcMgr_;
d241 4
a244 4
void WitPip::Coord::getExecVolPairs (
      WitDemand *    theDemand,
      WitPeriod      shipPer,
      OpnPairStack & execVolPairs)
d251 1
a251 1
      theTarg->execVolPegList ()->getPegPairs (execVolPairs);
d253 1
a253 1
      execVolPairs.clear ();
d258 4
a261 4
void WitPip::Coord::getSubVolPairs (
      WitDemand *    theDemand,
      WitPeriod      shipPer,
      SubPairStack & subVolPairs)
d268 1
a268 1
      theTarg->subVolPegList ()->getPegPairs (subVolPairs);
d270 1
a270 1
      subVolPairs.clear ();
d275 5
a279 5
void WitPip::Coord::getPartPegPairs (
      WitDemand *     theDemand,
      WitPeriod       shipPer,
      PartAtt         thePartAtt,
      PartPairStack & thePartPairs)
d286 1
a286 1
      theTarg->myPartPegList ()[thePartAtt]->getPegPairs (thePartPairs);
d288 1
a288 1
      thePartPairs.clear ();
d293 3
a295 1
WitPip::Targ * WitPip::Coord::myTargFor (WitDemPer * theDemPer)
d297 1
a297 5
   WitDemand * theDemand;
   WitPeriod   shipPer;
   Targ *      theTarg;

   theDemPer->getElems (theDemand, shipPer);
d341 5
a345 6
   ShipSeq     theShipSeq (myProblem ());
   WitDemPer * theDemPer;
   double      incShipVol;
   WitDemand * theDemand;
   WitPeriod   shipPer;
   Targ *      theTarg;
d349 1
a349 1
   while (theShipSeq.pop (theDemPer, incShipVol))
a350 2
      theDemPer->getElems (theDemand, shipPer);

d372 11
a382 6
   execVolPegList_              = theCoord->myOpnSrcMgr  ()->newPegList ();
   subVolPegList_               = theCoord->mySubSrcMgr  ()->newPegList ();
   myPartPegList_[supplyVolAtt] = theCoord->myPartSrcMgr ()->newPegList ();
   myPartPegList_[  sideVolAtt] = theCoord->myPartSrcMgr ()->newPegList ();
   myPartPegList_[  prodVolAtt] = theCoord->myPartSrcMgr ()->newPegList ();
   myPartPegList_[  consVolAtt] = theCoord->myPartSrcMgr ()->newPegList ();
a426 12
void WitPip::Targ::consolidatePegging ()
   {
   execVolPegList_             ->consolidate ();
   subVolPegList_              ->consolidate ();
   myPartPegList_[supplyVolAtt]->consolidate ();
   myPartPegList_[  sideVolAtt]->consolidate ();
   myPartPegList_[  prodVolAtt]->consolidate ();
   myPartPegList_[  consVolAtt]->consolidate ();
   }

//------------------------------------------------------------------------------

d429 4
a432 3
   OpnPairStack         execVolPairs (myDemand ()->myProblem ());
   Src <WitOperation> * theOpnSrc;
   double               pdgExecVol;
d437 1
a437 1
   execVolPegList_->getPegPairs (execVolPairs);
d441 1
a441 1
   while (execVolPairs.pop (theOpnSrc, pdgExecVol))
d444 2
a445 2
         theOpnSrc->mySrcComp ()->operationName ().myCstring (),
         theOpnSrc->myPer (),
d453 4
a456 3
   SubPairStack        subVolPairs (myDemand ()->myProblem ());
   Src <WitSubEntry> * theSubSrc;
   double              pdgSubVol;
d461 1
a461 1
   subVolPegList_->getPegPairs (subVolPairs);
d465 1
a465 1
   while (subVolPairs.pop (theSubSrc, pdgSubVol))
d468 3
a470 3
         theSubSrc->mySrcComp ()->myOperationName ().myCstring (),
         theSubSrc->mySrcComp ()->myPartName      ().myCstring (),
         theSubSrc->myPer (),
d480 4
a483 3
   PartPairStack   thePartPairs (myDemand ()->myProblem ());
   Src <WitPart> * thePartSrc;
   double          pegVol;
d488 1
a488 1
   myPartPegList_[thePartAtt]->getPegPairs (thePartPairs);
d492 1
a492 1
   while (thePartPairs.pop (thePartSrc, pegVol))
d495 2
a496 2
         thePartSrc->mySrcComp ()->partName ().myCstring (),
         thePartSrc->myPer (),
d512 2
a513 1
      WitPip::PegList <SrcComp>::PegList (SrcMgr <SrcComp> * theSrcMgr):
d515 2
a516 2
         myPegPairs_  (theSrcMgr->myProblem ()),
         mySrcMgr_    (theSrcMgr)
a530 10
         Src <SrcComp> * theSrc,
         double          pegVol)
   {
   myPegPairs_.push (theSrc, pegVol);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPip::PegList <SrcComp>::append (
d535 1
a535 14
   Src <SrcComp> * theSrc;

   theSrc = mySrcMgr_->mySrcFor (theSrcComp, thePer);

   myPegPairs_.push (theSrc, pegVol);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPip::PegList <SrcComp>::consolidate ()
   {
   mySrcMgr_->consolidate (myPegPairs_);
   }
d537 1
a537 1
//------------------------------------------------------------------------------
d539 1
a539 5
template <typename SrcComp> 
      void WitPip::PegList <SrcComp>::getPegPairs (
            WitPairStack <Src <SrcComp>, double> & thePegPairs)
   {
   thePegPairs.revCopyFrom (myPegPairs_);
d545 2
a546 1
      bool WitPip::PegList <SrcComp>::isEmpty ()
d548 3
a550 2
   return myPegPairs_.isEmpty ();
   }
d552 1
a552 6
//------------------------------------------------------------------------------
// Implementation of class template Pip::SrcMgr <SrcComp>.
//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPip::SrcMgr <SrcComp>::SrcMgr (WitProblem * theProblem):
d554 1
a554 40
         WitProbAssoc (theProblem),
         mySrcs_      (theProblem)
   {
   mySrcSched_ .allocate1D (theProblem);
   consolSched_.allocate1D (theProblem);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPip::SrcMgr <SrcComp>::~SrcMgr ()
   {
   mySrcSched_.clear ();

   deleteContents (mySrcs_);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPip::PegList <SrcComp> * WitPip::SrcMgr <SrcComp>::newPegList ()
   {
   return new PegList <SrcComp> (this);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPip::Src <SrcComp> * WitPip::SrcMgr <SrcComp>::mySrcFor (
         SrcComp * theSrcComp,
         WitPeriod thePer)
   {
   Src <SrcComp> * theSrc;

   if (not mySrcSched_.myPtrTVecAt (theSrcComp).isAllocated ())
      mySrcSched_.myPtrTVecAt (theSrcComp).allocate (myProblem ());

   theSrc = mySrcSched_.myPtrAt (theSrcComp, thePer);

   if (theSrc == NULL)
d556 2
a557 1
      theSrc = new Src <SrcComp> (theSrcComp, thePer);
d559 1
a559 1
      mySrcs_.push (theSrc);
d561 1
a561 1
      mySrcSched_.myPtrAt (theSrcComp, thePer) = theSrc;
d564 1
a564 30
   return theSrc;
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPip::SrcMgr <SrcComp>::consolidate (
            WitPairStack <Src <SrcComp>, double> & thePegPairs)
   {
   Src <SrcComp> * theSrc;
   double          pegVol;
   SrcComp *       theSrcComp;
   WitPeriod       thePer;

   WitObjStack <Src <SrcComp> > theSrcs (myProblem ());

   while (thePegPairs.pop (theSrc, pegVol))
      {
      theSrcComp = theSrc->mySrcComp ();
      thePer     = theSrc->myPer ();

      if (not consolSched_ (theSrcComp).isAllocated ())
         consolSched_ (theSrcComp).allocate (myProblem (), 0.0);

      consolSched_ (theSrcComp)[thePer] += pegVol;

      theSrcs.push (theSrc);
      }

   while (theSrcs.pop (theSrc))
d566 1
a566 4
      theSrcComp = theSrc->mySrcComp ();
      thePer     = theSrc->myPer ();

      pegVol     = consolSched_ (theSrcComp)[thePer];
d571 1
a571 1
      consolSched_ (theSrcComp)[thePer] = 0.0;
d573 1
a573 1
      thePegPairs.push (theSrc, pegVol);
d580 2
a581 15
      void WitPip::SrcMgr <SrcComp>::postBuild ()
   {
   consolSched_.clear      ();
   consolSched_.allocate1D (myProblem ());
   } 

//------------------------------------------------------------------------------
// Implementation of class template Pip::Src <SrcComp>.
//------------------------------------------------------------------------------

template <typename SrcComp> 
      WitPip::Src <SrcComp>::Src (SrcComp * theSrcComp, WitPeriod thePer):

      mySrcComp_ (theSrcComp),
      myPer_     (thePer)
d583 1
d589 1
a589 1
      WitPip::Src <SrcComp>::~Src ()
d591 1
d595 1
a595 1
// Explicit instantiation of class templates.
a598 3
template class WitPip::SrcMgr  <WitPart>;
template class WitPip::Src     <WitPart>;

a599 3
template class WitPip::SrcMgr  <WitOperation>;
template class WitPip::Src     <WitOperation>;

a600 2
template class WitPip::SrcMgr  <WitSubEntry>;
template class WitPip::Src     <WitSubEntry>;
@


1.48
log
@Continued implementation of PIP.
@
text
@a14 1
//    Pip::Int
d16 1
d34 1
a35 1
#include <PipInt.h>
d49 1
a49 1
// Implementation of class Pip::Int.
d52 1
a52 1
WitPip::Int::Int (WitProblem * theProblem):
d55 1
a55 1
      myMgr_       (NULL),
d62 1
a62 1
WitPip::Int::~Int ()
d66 1
a66 1
   delete myMgr_;
d71 1
a71 1
void WitPip::Int::clearShipSeq ()
d86 1
a86 1
void WitPip::Int::recIncShipVol (
d102 1
a102 1
void WitPip::Int::getShipSeq (ShipSeq & theShipSeq)
d109 1
a109 1
void WitPip::Int::buildPegging ()
d113 1
a113 1
   myMgr_ = new Mgr (this);
d118 1
a118 1
void WitPip::Int::clearPegging ()
d120 1
a120 1
   delete myMgr ();
d122 1
a122 1
   myMgr_ = NULL;
d127 1
a127 1
void WitPip::Int::printPegging ()
d129 1
a129 1
   myMgr ()->printPegging ();
d134 1
a134 1
void WitPip::Int::getExecVolPairs (
d140 1
a140 1
      myMgr ()->getExecVolPairs (theDemand, shipPer, execVolPairs);
d147 1
a147 1
void WitPip::Int::getSubVolPairs (
d153 1
a153 1
      myMgr ()->getSubVolPairs (theDemand, shipPer, subVolPairs);
d160 1
a160 1
void WitPip::Int::getPartPegPairs (
d167 5
a171 1
      myMgr ()->getPartPegPairs (theDemand, shipPer, thePartAtt, thePartPairs);
d180 1
a180 1
WitPip::Mgr::Mgr (Int * theInt):
d182 1
a182 1
      WitProbAssoc (theInt->myProblem ()),
d184 1
a184 1
      myInt_       (theInt),
d212 1
a212 1
WitPip::Mgr::~Mgr ()
d232 1
a232 1
void WitPip::Mgr::printPegging ()
d254 1
a254 1
void WitPip::Mgr::getExecVolPairs (
d271 1
a271 1
void WitPip::Mgr::getSubVolPairs (
d288 1
a288 1
void WitPip::Mgr::getPartPegPairs (
d306 1
a306 1
WitPip::Targ * WitPip::Mgr::myTargFor (WitDemPer * theDemPer)
d323 1
a323 1
void WitPip::Mgr::checkRestrictions ()
d354 1
a354 1
void WitPip::Mgr::buildTargs ()
d363 1
a363 1
   myInt_->getShipSeq (theShipSeq);
d384 1
a384 1
WitPip::Targ::Targ (WitDemand * theDemand, WitPeriod shipPer, Mgr * theMgr):
d390 6
a395 6
   execVolPegList_              = theMgr->myOpnSrcMgr  ()->newPegList ();
   subVolPegList_               = theMgr->mySubSrcMgr  ()->newPegList ();
   myPartPegList_[supplyVolAtt] = theMgr->myPartSrcMgr ()->newPegList ();
   myPartPegList_[  sideVolAtt] = theMgr->myPartSrcMgr ()->newPegList ();
   myPartPegList_[  prodVolAtt] = theMgr->myPartSrcMgr ()->newPegList ();
   myPartPegList_[  consVolAtt] = theMgr->myPartSrcMgr ()->newPegList ();
@


1.47
log
@Continued implementation of PIP.
@
text
@a70 22
void WitPip::Int::preprocess ()
   {
   witAssert (myGlobalComp ()->pip ());

   myMgr_ = new Mgr (this);
   }

//------------------------------------------------------------------------------

void WitPip::Int::unpreprocess ()
   {
   witAssert (myGlobalComp ()->pip ());

   clearShipSeq ();

   delete myMgr_;
   
   myMgr_ = NULL;
   }

//------------------------------------------------------------------------------

d111 1
a111 1
   myMgr ()->buildPegging ();
d113 1
a113 1
   clearShipSeq ();
d120 3
a122 1
   myMgr ()->clearPegging ();
d139 4
a142 1
   myMgr ()->getExecVolPairs (theDemand, shipPer, execVolPairs);
d152 4
a155 1
   myMgr ()->getSubVolPairs (theDemand, shipPer, subVolPairs);
d166 4
a169 1
   myMgr ()->getPartPegPairs (theDemand, shipPer, thePartAtt, thePartPairs);
d181 1
a181 2
      myTargs_     (myProblem ()),
      pegged_      (false)
d185 2
d191 1
a191 1
   checkRestrictions ();
d193 2
a194 2
   WitTimer::leaveSection ("pip");
   }
d196 2
a197 28
//------------------------------------------------------------------------------

WitPip::Mgr::~Mgr ()
   {
   WitTimer::enterSection ("pip");

   clearPegging ();

   delete myPartSrcMgr_;
   delete mySubSrcMgr_;
   delete myOpnSrcMgr_;

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

void WitPip::Mgr::buildPegging ()
   {
   WitTimer::enterSection ("pip");

   Builder theBuilder (this);

   clearPegging ();

   buildTargs ();

   theBuilder.buildPegging ();
a202 2
   pegged_ = true;

d208 1
a208 1
void WitPip::Mgr::clearPegging ()
a211 4
   Targ *      theTarg;

   if (not pegged_)
      return;
a214 2
   pegged_ = false;

d217 1
a217 10
         {
         theTarg = myTargs_.myPtrAt (theDemand, thePer);

         if (theTarg == NULL)
            continue;

         delete theTarg;

         myTargs_.myPtrAt (theDemand, thePer) = NULL;
         }
d219 3
a221 3
   myOpnSrcMgr_ ->clear ();
   mySubSrcMgr_ ->clear ();
   myPartSrcMgr_->clear ();
a649 11
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPip::SrcMgr <SrcComp>::clear ()
   {
   mySrcSched_.clear      ();
   mySrcSched_.allocate1D (myProblem ());

   deleteContents (mySrcs_);
@


1.46
log
@Continued implementation of PIP.
@
text
@d135 1
a135 1
   revShipSeq_.clear ();
@


1.45
log
@Continued implementation of PIP.
@
text
@d42 1
d55 2
a56 1
      myMgr_       (NULL)
d64 2
d75 1
a75 1
   myMgr_ = new Mgr (myProblem ());
d84 2
d93 1
a93 1
void WitPip::Int::clearTargs ()
d95 9
a103 1
   myMgr ()->clearTargs ();
d113 14
a126 1
   myMgr ()->recIncShipVol (theDemand, shipPer, incShipVol);
d134 2
d187 3
a189 1
WitPip::Mgr::Mgr (WitProblem * theProblem):
d191 2
a192 3
      WitProbAssoc (theProblem),
      myTargs_     (theProblem),
      revShipSeq_  (theProblem),
a213 2
   clearTargs ();

a222 46
void WitPip::Mgr::recIncShipVol (
      WitDemand * theDemand,
      WitPeriod   shipPer,
      double      incShipVol)
   {
   Targ * theTarg;

   witAssert (incShipVol >= NET_TOL);

   theTarg = myTargs_.myPtrAt (theDemand, shipPer);

   if (theTarg == NULL)
      {
      theTarg = new Targ (theDemand, shipPer, this);

      myTargs_.myPtrAt (theDemand, shipPer) = theTarg;
      }

   revShipSeq_.push (theTarg, incShipVol);
   }

//------------------------------------------------------------------------------

void WitPip::Mgr::clearTargs ()
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;

   WitTimer::enterSection ("pip");

   revShipSeq_.clear ();

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         if (myTargs_.myPtrAt (theDemand, shipPer) != NULL)
            {
            delete myTargs_.myPtrAt (theDemand, shipPer);

            myTargs_.myPtrAt (theDemand, shipPer) = NULL;
            }

   WitTimer::leaveSection ("pip");
   }

//------------------------------------------------------------------------------

d227 1
a227 2
   Builder                     theBuilder (myProblem ());
   WitPairStack <Targ, double> fwdShipSeq (myProblem ());
d231 1
a231 4
   fwdShipSeq.takeContents (revShipSeq_);

   if (not myGlobalComp ()->revPipSeq ())
      fwdShipSeq.reverse ();
d233 1
a233 1
   theBuilder.buildPegging (fwdShipSeq);
d264 6
a269 2
         if (theTarg != NULL)
            theTarg->clearPegging ();
d355 17
d402 28
a460 12
void WitPip::Targ::clearPegging ()
   {
   execVolPegList_             ->clear ();
   subVolPegList_              ->clear ();
   myPartPegList_[supplyVolAtt]->clear ();
   myPartPegList_[  sideVolAtt]->clear ();
   myPartPegList_[  prodVolAtt]->clear ();
   myPartPegList_[  consVolAtt]->clear ();
   }

//------------------------------------------------------------------------------

a619 8
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPip::PegList <SrcComp>::clear ()
   {
   myPegPairs_.clear ();
@


1.44
log
@Continued implementation of PIP.
@
text
@d160 4
a163 7
      WitProbAssoc  (theProblem),
      myTargs_      (theProblem),
      revShipSeq_   (theProblem),
      myOpnSrcMgr_  (NULL),
      mySubSrcMgr_  (NULL),
      myPartSrcMgr_ (NULL),
      pegged_       (false)
d408 3
a410 5
      myDemand_       (theDemand),
      myShipPer_      (shipPer),
      execVolPegList_ (NULL),
      subVolPegList_  (NULL),
      myPartPegList_  (nPartAtts)
d648 1
a648 3
         mySrcs_      (theProblem),
         mySrcSched_  (),
         consolSched_ ()
@


1.43
log
@Continued implementation of PIP.
@
text
@d18 1
a18 1
//    Pip::Pegging <SrcComp>
d24 1
a24 1
//    Pip::Pegging <SrcComp>
d31 1
a31 1
#include <PipPeg.h>
d126 3
a128 3
      WitDemand *      theDemand,
      WitPeriod        shipPer,
      WitOpnPipStack & thePegPairs)
d130 1
a130 1
   myMgr ()->getExecVolPairs (theDemand, shipPer, thePegPairs);
d136 3
a138 3
      WitDemand *      theDemand,
      WitPeriod        shipPer,
      WitSubPipStack & thePegPairs)
d140 1
a140 1
   myMgr ()->getSubVolPairs (theDemand, shipPer, thePegPairs);
d146 4
a149 4
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      PartAtt           thePartAtt,
      WitPartPipStack & thePegPairs)
d151 1
a151 1
   myMgr ()->getPartPegPairs (theDemand, shipPer, thePartAtt, thePegPairs);
d325 3
a327 3
      WitDemand *      theDemand,
      WitPeriod        shipPer,
      WitOpnPipStack & thePegPairs)
d334 1
a334 1
      theTarg->execVolPegging ()->getPegPairs (thePegPairs);
d336 1
a336 1
      thePegPairs.clear ();
d342 3
a344 3
      WitDemand *      theDemand,
      WitPeriod        shipPer,
      WitSubPipStack & thePegPairs)
d351 1
a351 1
      theTarg->subVolPegging ()->getPegPairs (thePegPairs);
d353 1
a353 1
      thePegPairs.clear ();
d359 4
a362 4
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      PartAtt           thePartAtt,
      WitPartPipStack & thePegPairs)
d369 1
a369 1
      theTarg->myPartPegging ()[thePartAtt]->getPegPairs (thePegPairs);
d371 1
a371 1
      thePegPairs.clear ();
d413 10
a422 10
      execVolPegging_ (NULL),
      subVolPegging_  (NULL),
      myPartPegging_  (nPartAtts)
   {
   execVolPegging_              = theMgr->myOpnSrcMgr  ()->newPegging ();
   subVolPegging_               = theMgr->mySubSrcMgr  ()->newPegging ();
   myPartPegging_[supplyVolAtt] = theMgr->myPartSrcMgr ()->newPegging ();
   myPartPegging_[  sideVolAtt] = theMgr->myPartSrcMgr ()->newPegging ();
   myPartPegging_[  prodVolAtt] = theMgr->myPartSrcMgr ()->newPegging ();
   myPartPegging_[  consVolAtt] = theMgr->myPartSrcMgr ()->newPegging ();
d429 6
a434 6
   delete myPartPegging_[  consVolAtt];
   delete myPartPegging_[  prodVolAtt];
   delete myPartPegging_[  sideVolAtt];
   delete myPartPegging_[supplyVolAtt];
   delete subVolPegging_;
   delete execVolPegging_;
d441 6
a446 6
   execVolPegging_             ->clear ();
   subVolPegging_              ->clear ();
   myPartPegging_[supplyVolAtt]->clear ();
   myPartPegging_[  sideVolAtt]->clear ();
   myPartPegging_[  prodVolAtt]->clear ();
   myPartPegging_[  consVolAtt]->clear ();
d453 6
a458 6
   if (execVolPegging_->isEmpty ())
      if (subVolPegging_->isEmpty ())
         if (myPartPegging_[supplyVolAtt]->isEmpty ())
            if (myPartPegging_[sideVolAtt]->isEmpty ())
               if (myPartPegging_[prodVolAtt]->isEmpty ())
                  if (myPartPegging_[consVolAtt]->isEmpty ())
d481 6
a486 6
   execVolPegging_             ->consolidate ();
   subVolPegging_              ->consolidate ();
   myPartPegging_[supplyVolAtt]->consolidate ();
   myPartPegging_[  sideVolAtt]->consolidate ();
   myPartPegging_[  prodVolAtt]->consolidate ();
   myPartPegging_[  consVolAtt]->consolidate ();
d493 1
a493 1
   WitOpnPipStack       execVolPairs (myDemand ()->myProblem ());
d497 1
a497 1
   if (execVolPegging_->isEmpty ())
d500 1
a500 1
   execVolPegging_->getPegPairs (execVolPairs);
d516 1
a516 1
   WitSubPipStack      subVolPairs (myDemand ()->myProblem ());
d520 1
a520 1
   if (subVolPegging_->isEmpty ())
d523 1
a523 1
   subVolPegging_->getPegPairs (subVolPairs);
d542 1
a542 1
   WitPartPipStack thePegPairs (myDemand ()->myProblem ());
d546 1
a546 1
   if (myPartPegging_[thePartAtt]->isEmpty ())
d549 1
a549 1
   myPartPegging_[thePartAtt]->getPegPairs (thePegPairs);
d553 1
a553 1
   while (thePegPairs.pop (thePartSrc, pegVol))
d569 1
a569 1
// Implementation of class template Pip::Pegging <SrcComp>.
d573 1
a573 1
      WitPip::Pegging <SrcComp>::Pegging (SrcMgr <SrcComp> * theSrcMgr):
d583 1
a583 1
      WitPip::Pegging <SrcComp>::~Pegging ()
d590 1
a590 1
      void WitPip::Pegging <SrcComp>::append (
d600 1
a600 1
      void WitPip::Pegging <SrcComp>::append (
d615 1
a615 1
      void WitPip::Pegging <SrcComp>::clear ()
d623 1
a623 1
      void WitPip::Pegging <SrcComp>::consolidate ()
d631 1
a631 1
      void WitPip::Pegging <SrcComp>::getPegPairs (
d640 1
a640 1
      bool WitPip::Pegging <SrcComp>::isEmpty ()
d674 1
a674 1
      WitPip::Pegging <SrcComp> * WitPip::SrcMgr <SrcComp>::newPegging ()
d676 1
a676 1
   return new Pegging <SrcComp> (this);
d790 1
a790 1
template class WitPip::Pegging <WitPart>;
d794 1
a794 1
template class WitPip::Pegging <WitOperation>;
d798 1
a798 1
template class WitPip::Pegging <WitSubEntry>;
@


1.42
log
@Continued implementation of PIP.
@
text
@d18 3
a20 3
//    Pip::Peg    <SrcComp>
//    Pip::SrcMgr <SrcComp>
//    Pip::Src    <SrcComp>
d24 3
a26 3
//    Pip::Peg    <SrcComp>
//    Pip::SrcMgr <SrcComp>
//    Pip::Src    <SrcComp>
d334 1
a334 1
      theTarg->execVolPeg ()->getPegPairs (thePegPairs);
d351 1
a351 1
      theTarg->subVolPeg ()->getPegPairs (thePegPairs);
d369 1
a369 1
      theTarg->myPartPeg ()[thePartAtt]->getPegPairs (thePegPairs);
d411 12
a422 12
      myDemand_   (theDemand),
      myShipPer_  (shipPer),
      execVolPeg_ (NULL),
      subVolPeg_  (NULL),
      myPartPeg_  (nPartAtts)
   {
   execVolPeg_              = theMgr->myOpnSrcMgr  ()->newPeg ();
   subVolPeg_               = theMgr->mySubSrcMgr  ()->newPeg ();
   myPartPeg_[supplyVolAtt] = theMgr->myPartSrcMgr ()->newPeg ();
   myPartPeg_[  sideVolAtt] = theMgr->myPartSrcMgr ()->newPeg ();
   myPartPeg_[  prodVolAtt] = theMgr->myPartSrcMgr ()->newPeg ();
   myPartPeg_[  consVolAtt] = theMgr->myPartSrcMgr ()->newPeg ();
d429 6
a434 6
   delete myPartPeg_[  consVolAtt];
   delete myPartPeg_[  prodVolAtt];
   delete myPartPeg_[  sideVolAtt];
   delete myPartPeg_[supplyVolAtt];
   delete subVolPeg_;
   delete execVolPeg_;
d441 6
a446 6
   execVolPeg_             ->clear ();
   subVolPeg_              ->clear ();
   myPartPeg_[supplyVolAtt]->clear ();
   myPartPeg_[  sideVolAtt]->clear ();
   myPartPeg_[  prodVolAtt]->clear ();
   myPartPeg_[  consVolAtt]->clear ();
d453 6
a458 6
   if (execVolPeg_->isEmpty ())
      if (subVolPeg_->isEmpty ())
         if (myPartPeg_[supplyVolAtt]->isEmpty ())
            if (myPartPeg_[sideVolAtt]->isEmpty ())
               if (myPartPeg_[prodVolAtt]->isEmpty ())
                  if (myPartPeg_[consVolAtt]->isEmpty ())
d481 6
a486 6
   execVolPeg_             ->consolidate ();
   subVolPeg_              ->consolidate ();
   myPartPeg_[supplyVolAtt]->consolidate ();
   myPartPeg_[  sideVolAtt]->consolidate ();
   myPartPeg_[  prodVolAtt]->consolidate ();
   myPartPeg_[  consVolAtt]->consolidate ();
d497 1
a497 1
   if (execVolPeg_->isEmpty ())
d500 1
a500 1
   execVolPeg_->getPegPairs (execVolPairs);
d520 1
a520 1
   if (subVolPeg_->isEmpty ())
d523 1
a523 1
   subVolPeg_->getPegPairs (subVolPairs);
d546 1
a546 1
   if (myPartPeg_[thePartAtt]->isEmpty ())
d549 1
a549 1
   myPartPeg_[thePartAtt]->getPegPairs (thePegPairs);
d569 1
a569 1
// Implementation of class template Pip::Peg <SrcComp>.
d573 1
a573 1
      WitPip::Peg <SrcComp>::Peg (SrcMgr <SrcComp> * theSrcMgr):
d583 1
a583 1
      WitPip::Peg <SrcComp>::~Peg ()
d590 1
a590 1
      void WitPip::Peg <SrcComp>::append (
d600 1
a600 1
      void WitPip::Peg <SrcComp>::append (
d615 1
a615 1
      void WitPip::Peg <SrcComp>::clear ()
d623 1
a623 1
      void WitPip::Peg <SrcComp>::consolidate ()
d631 1
a631 1
      void WitPip::Peg <SrcComp>::getPegPairs (
d640 1
a640 1
      bool WitPip::Peg <SrcComp>::isEmpty ()
d674 1
a674 1
      WitPip::Peg <SrcComp> * WitPip::SrcMgr <SrcComp>::newPeg ()
d676 1
a676 1
   return new Peg <SrcComp> (this);
d790 11
a800 11
template class WitPip::Peg    <WitPart>;
template class WitPip::SrcMgr <WitPart>;
template class WitPip::Src    <WitPart>;

template class WitPip::Peg    <WitOperation>;
template class WitPip::SrcMgr <WitOperation>;
template class WitPip::Src    <WitOperation>;

template class WitPip::Peg    <WitSubEntry>;
template class WitPip::SrcMgr <WitSubEntry>;
template class WitPip::Src    <WitSubEntry>;
@


1.41
log
@Continued implementation of PIP.
@
text
@d15 6
a20 6
//    PipInt
//    PipMgr
//    PipTarg
//    PipPeg      <SrcComp>
//    PipSrcMgr   <SrcComp>
//    PIP::PipSrc <SrcComp>
d24 3
a26 3
//    PipPeg      <SrcComp>
//    PipSrcMgr   <SrcComp>
//    PIP::PipSrc <SrcComp>
d48 1
a48 1
// Implementation of class PipInt.
d51 1
a51 1
WitPIP::WitPipInt::WitPipInt (WitProblem * theProblem):
d54 1
a54 1
      myPipMgr_    (NULL)
d60 1
a60 1
WitPIP::WitPipInt::~WitPipInt ()
d62 1
a62 1
   delete myPipMgr_;
d67 1
a67 1
void WitPIP::WitPipInt::preprocess ()
d71 1
a71 1
   myPipMgr_ = new WitPipMgr (myProblem ());
d76 1
a76 1
void WitPIP::WitPipInt::unpreprocess ()
d80 1
a80 1
   delete myPipMgr_;
d82 1
a82 1
   myPipMgr_ = NULL;
d87 1
a87 1
void WitPIP::WitPipInt::clearTargs ()
d89 1
a89 1
   myPipMgr ()->clearTargs ();
d94 1
a94 1
void WitPIP::WitPipInt::recIncShipVol (
d99 1
a99 1
   myPipMgr ()->recIncShipVol (theDemand, shipPer, incShipVol);
d104 1
a104 1
void WitPIP::WitPipInt::buildPegging ()
d106 1
a106 1
   myPipMgr ()->buildPegging ();
d111 1
a111 1
void WitPIP::WitPipInt::clearPegging ()
d113 1
a113 1
   myPipMgr ()->clearPegging ();
d118 1
a118 1
void WitPIP::WitPipInt::printPegging ()
d120 1
a120 1
   myPipMgr ()->printPegging ();
d125 1
a125 1
void WitPIP::WitPipInt::getExecVolPairs (
d130 1
a130 1
   myPipMgr ()->getExecVolPairs (theDemand, shipPer, thePegPairs);
d135 1
a135 1
void WitPIP::WitPipInt::getSubVolPairs (
d140 1
a140 1
   myPipMgr ()->getSubVolPairs (theDemand, shipPer, thePegPairs);
d145 1
a145 1
void WitPIP::WitPipInt::getPartPegPairs (
d151 1
a151 1
   myPipMgr ()->getPartPegPairs (theDemand, shipPer, thePartAtt, thePegPairs);
d155 1
a155 1
// Implementation of class PipMgr.
d158 1
a158 1
WitPIP::WitPipMgr::WitPipMgr (WitProblem * theProblem):
d160 7
a166 7
      WitProbAssoc     (theProblem),
      myPipTargs_      (theProblem),
      revShipSeq_      (theProblem),
      myOpnPipSrcMgr_  (NULL),
      mySubPipSrcMgr_  (NULL),
      myPartPipSrcMgr_ (NULL),
      pegged_          (false)
d170 3
a172 3
   myOpnPipSrcMgr_  = new WitPipSrcMgr <WitOperation> (myProblem ());
   mySubPipSrcMgr_  = new WitPipSrcMgr <WitSubEntry>  (myProblem ());
   myPartPipSrcMgr_ = new WitPipSrcMgr <WitPart>      (myProblem ());
d181 1
a181 1
WitPIP::WitPipMgr::~WitPipMgr ()
d189 3
a191 3
   delete myPartPipSrcMgr_;
   delete mySubPipSrcMgr_;
   delete myOpnPipSrcMgr_;
d198 1
a198 1
void WitPIP::WitPipMgr::recIncShipVol (
d203 1
a203 1
   WitPipTarg * thePipTarg;
d207 1
a207 1
   thePipTarg = myPipTargs_.myPtrAt (theDemand, shipPer);
d209 1
a209 1
   if (thePipTarg == NULL)
d211 1
a211 1
      thePipTarg = new WitPipTarg (theDemand, shipPer, this);
d213 1
a213 1
      myPipTargs_.myPtrAt (theDemand, shipPer) = thePipTarg;
d216 1
a216 1
   revShipSeq_.push (thePipTarg, incShipVol);
d221 1
a221 1
void WitPIP::WitPipMgr::clearTargs ()
d232 1
a232 1
         if (myPipTargs_.myPtrAt (theDemand, shipPer) != NULL)
d234 1
a234 1
            delete myPipTargs_.myPtrAt (theDemand, shipPer);
d236 1
a236 1
            myPipTargs_.myPtrAt (theDemand, shipPer) = NULL;
d244 1
a244 1
void WitPIP::WitPipMgr::buildPegging ()
d248 2
a249 2
   WitPipBuilder                     thePipBuilder (myProblem ());
   WitPairStack <WitPipTarg, double> fwdShipSeq    (myProblem ());
d258 1
a258 1
   thePipBuilder.buildPegging (fwdShipSeq);
d260 3
a262 3
   myOpnPipSrcMgr_ ->postBuild ();
   mySubPipSrcMgr_ ->postBuild ();
   myPartPipSrcMgr_->postBuild ();
d271 1
a271 1
void WitPIP::WitPipMgr::clearPegging ()
d273 3
a275 3
   WitDemand *  theDemand;
   WitPeriod    thePer;
   WitPipTarg * thePipTarg;
d287 1
a287 1
         thePipTarg = myPipTargs_.myPtrAt (theDemand, thePer);
d289 2
a290 2
         if (thePipTarg != NULL)
            thePipTarg->clearPegging ();
d293 3
a295 3
   myOpnPipSrcMgr_ ->clear ();
   mySubPipSrcMgr_ ->clear ();
   myPartPipSrcMgr_->clear ();
d302 1
a302 1
void WitPIP::WitPipMgr::printPegging ()
d304 3
a306 3
   WitDemand *  theDemand;
   WitPeriod    shipPer;
   WitPipTarg * thePipTarg;
d315 1
a315 1
         thePipTarg = myPipTargs_.myPtrAt (theDemand, shipPer);
d317 2
a318 2
         if (thePipTarg != NULL)
            thePipTarg->printPegging ();
d324 1
a324 1
void WitPIP::WitPipMgr::getExecVolPairs (
d329 1
a329 1
   WitPipTarg * thePipTarg;
d331 1
a331 1
   thePipTarg = myPipTargs_.myPtrAt (theDemand, shipPer);
d333 2
a334 2
   if (thePipTarg != NULL)
      thePipTarg->execVolPeg ()->getPegPairs (thePegPairs);
d341 1
a341 1
void WitPIP::WitPipMgr::getSubVolPairs (
d346 1
a346 1
   WitPipTarg * thePipTarg;
d348 1
a348 1
   thePipTarg = myPipTargs_.myPtrAt (theDemand, shipPer);
d350 2
a351 2
   if (thePipTarg != NULL)
      thePipTarg->subVolPeg ()->getPegPairs (thePegPairs);
d358 1
a358 1
void WitPIP::WitPipMgr::getPartPegPairs (
d364 1
a364 1
   WitPipTarg * thePipTarg;
d366 1
a366 1
   thePipTarg = myPipTargs_.myPtrAt (theDemand, shipPer);
d368 2
a369 2
   if (thePipTarg != NULL)
      thePipTarg->myPartPeg ()[thePartAtt]->getPegPairs (thePegPairs);
d376 1
a376 1
void WitPIP::WitPipMgr::checkRestrictions ()
d406 1
a406 1
// Implementation of class PipTarg.
d409 1
a409 4
WitPIP::WitPipTarg::WitPipTarg (
         WitDemand * theDemand,
         WitPeriod   shipPer,
         WitPipMgr * thePipMgr):
d417 6
a422 6
   execVolPeg_              = thePipMgr->myOpnPipSrcMgr  ()->newPipPeg ();
   subVolPeg_               = thePipMgr->mySubPipSrcMgr  ()->newPipPeg ();
   myPartPeg_[supplyVolAtt] = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
   myPartPeg_[  sideVolAtt] = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
   myPartPeg_[  prodVolAtt] = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
   myPartPeg_[  consVolAtt] = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
d427 1
a427 1
WitPIP::WitPipTarg::~WitPipTarg ()
d439 1
a439 1
void WitPIP::WitPipTarg::clearPegging ()
d451 1
a451 1
void WitPIP::WitPipTarg::printPegging ()
d479 1
a479 1
void WitPIP::WitPipTarg::consolidatePegging ()
d491 1
a491 1
void WitPIP::WitPipTarg::printExecVolPegging ()
d493 3
a495 3
   WitOpnPipStack             execVolPairs (myDemand ()->myProblem ());
   WitPipSrc <WitOperation> * theOpnPipSrc;
   double                     pdgExecVol;
d504 1
a504 1
   while (execVolPairs.pop (theOpnPipSrc, pdgExecVol))
d507 2
a508 2
         theOpnPipSrc->mySrcComp ()->operationName ().myCstring (),
         theOpnPipSrc->myPer (),
d514 1
a514 1
void WitPIP::WitPipTarg::printSubVolPegging ()
d516 3
a518 3
   WitSubPipStack            subVolPairs (myDemand ()->myProblem ());
   WitPipSrc <WitSubEntry> * theSubPipSrc;
   double                    pdgSubVol;
d527 1
a527 1
   while (subVolPairs.pop (theSubPipSrc, pdgSubVol))
d530 3
a532 3
         theSubPipSrc->mySrcComp ()->myOperationName ().myCstring (),
         theSubPipSrc->mySrcComp ()->myPartName      ().myCstring (),
         theSubPipSrc->myPer (),
d538 1
a538 1
void WitPIP::WitPipTarg::printPartPegging (
d542 3
a544 3
   WitPartPipStack       thePegPairs (myDemand ()->myProblem ());
   WitPipSrc <WitPart> * thePartPipSrc;
   double                pegVol;
d553 1
a553 1
   while (thePegPairs.pop (thePartPipSrc, pegVol))
d556 2
a557 2
         thePartPipSrc->mySrcComp ()->partName ().myCstring (),
         thePartPipSrc->myPer (),
d563 1
a563 1
FILE * WitPIP::WitPipTarg::solnFile ()
d569 1
a569 1
// Implementation of class template PipPeg <SrcComp>.
d573 1
a573 2
      WitPIP::WitPipPeg <SrcComp>::WitPipPeg (
            WitPipSrcMgr <SrcComp> * thePipSrcMgr):
d575 2
a576 2
         myPegPairs_  (thePipSrcMgr->myProblem ()),
         myPipSrcMgr_ (thePipSrcMgr)
d583 1
a583 1
      WitPIP::WitPipPeg <SrcComp>::~WitPipPeg ()
d590 3
a592 3
      void WitPIP::WitPipPeg <SrcComp>::append (
         WitPipSrc <SrcComp> * thePipSrc,
         double                pegVol)
d594 1
a594 1
   myPegPairs_.push (thePipSrc, pegVol);
d600 1
a600 1
      void WitPIP::WitPipPeg <SrcComp>::append (
d605 1
a605 1
   WitPipSrc <SrcComp> * thePipSrc;
d607 1
a607 1
   thePipSrc = myPipSrcMgr_->myPipSrcFor (theSrcComp, thePer);
d609 1
a609 1
   myPegPairs_.push (thePipSrc, pegVol);
d615 1
a615 1
      void WitPIP::WitPipPeg <SrcComp>::clear ()
d623 1
a623 1
      void WitPIP::WitPipPeg <SrcComp>::consolidate ()
d625 1
a625 1
   myPipSrcMgr_->consolidate (myPegPairs_);
d631 2
a632 2
      void WitPIP::WitPipPeg <SrcComp>::getPegPairs (
            WitPairStack <WitPipSrc <SrcComp>, double> & thePegPairs)
d640 1
a640 1
      bool WitPIP::WitPipPeg <SrcComp>::isEmpty ()
d646 1
a646 1
// Implementation of class template PipSrcMgr <SrcComp>.
d650 1
a650 1
      WitPIP::WitPipSrcMgr <SrcComp>::WitPipSrcMgr (WitProblem * theProblem):
d652 4
a655 4
         WitProbAssoc   (theProblem),
         myPipSrcs_     (theProblem),
         myPipSrcSched_ (),
         consolSched_   ()
d657 2
a658 2
   myPipSrcSched_.allocate1D (theProblem);
   consolSched_  .allocate1D (theProblem);
d664 1
a664 1
      WitPIP::WitPipSrcMgr <SrcComp>::~WitPipSrcMgr ()
d666 1
a666 1
   myPipSrcSched_.clear ();
d668 1
a668 1
   deleteContents (myPipSrcs_);
d674 1
a674 1
      WitPIP::WitPipPeg <SrcComp> * WitPIP::WitPipSrcMgr <SrcComp>::newPipPeg ()
d676 1
a676 1
   return new WitPipPeg <SrcComp> (this);
d682 3
a684 4
       WitPIP::WitPipSrc <SrcComp> * 
         WitPIP::WitPipSrcMgr <SrcComp>::myPipSrcFor (
            SrcComp * theSrcComp,
            WitPeriod thePer)
d686 1
a686 1
   WitPipSrc <SrcComp> * thePipSrc;
d688 2
a689 2
   if (not myPipSrcSched_.myPtrTVecAt (theSrcComp).isAllocated ())
      myPipSrcSched_.myPtrTVecAt (theSrcComp).allocate (myProblem ());
d691 1
a691 1
   thePipSrc = myPipSrcSched_.myPtrAt (theSrcComp, thePer);
d693 1
a693 1
   if (thePipSrc == NULL)
d695 1
a695 1
      thePipSrc = new WitPipSrc <SrcComp> (theSrcComp, thePer);
d697 1
a697 1
      myPipSrcs_.push (thePipSrc);
d699 1
a699 1
      myPipSrcSched_.myPtrAt (theSrcComp, thePer) = thePipSrc;
d702 1
a702 1
   return thePipSrc;
d708 1
a708 1
      void WitPIP::WitPipSrcMgr <SrcComp>::clear ()
d710 2
a711 2
   myPipSrcSched_.clear      ();
   myPipSrcSched_.allocate1D (myProblem ());
d713 1
a713 1
   deleteContents (myPipSrcs_);
d719 2
a720 2
      void WitPIP::WitPipSrcMgr <SrcComp>::consolidate (
            WitPairStack <WitPipSrc <SrcComp>, double> & thePegPairs)
d722 4
a725 4
   WitPipSrc <SrcComp> * thePipSrc;
   double                pegVol;
   SrcComp *             theSrcComp;
   WitPeriod             thePer;
d727 1
a727 1
   WitObjStack <WitPipSrc <SrcComp> > thePipSrcs (myProblem ());
d729 1
a729 1
   while (thePegPairs.pop (thePipSrc, pegVol))
d731 2
a732 2
      theSrcComp = thePipSrc->mySrcComp ();
      thePer     = thePipSrc->myPer ();
d739 1
a739 1
      thePipSrcs.push (thePipSrc);
d742 1
a742 1
   while (thePipSrcs.pop (thePipSrc))
d744 2
a745 2
      theSrcComp = thePipSrc->mySrcComp ();
      thePer     = thePipSrc->myPer ();
d754 1
a754 1
      thePegPairs.push (thePipSrc, pegVol);
d761 1
a761 1
      void WitPIP::WitPipSrcMgr <SrcComp>::postBuild ()
d768 1
a768 1
// Implementation of class template PIP::PipSrc <SrcComp>.
d772 1
a772 3
      WitPIP::WitPipSrc <SrcComp>::WitPipSrc (
         SrcComp * theSrcComp,
         WitPeriod thePer):
d782 1
a782 1
      WitPIP::WitPipSrc <SrcComp>::~WitPipSrc ()
d790 11
a800 11
template class WitPIP::WitPipPeg    <WitPart>;
template class WitPIP::WitPipSrcMgr <WitPart>;
template class WitPIP::WitPipSrc    <WitPart>;

template class WitPIP::WitPipPeg    <WitOperation>;
template class WitPIP::WitPipSrcMgr <WitOperation>;
template class WitPIP::WitPipSrc    <WitOperation>;

template class WitPIP::WitPipPeg    <WitSubEntry>;
template class WitPIP::WitPipSrcMgr <WitSubEntry>;
template class WitPIP::WitPipSrc    <WitSubEntry>;
@


1.40
log
@Continued implementation of PIP.
@
text
@d18 3
a20 3
//    PipPeg    <SrcComp>
//    PipSrcMgr <SrcComp>
//    PipSrc    <SrcComp>
d24 3
a26 3
//    PipPeg    <SrcComp>
//    PipSrcMgr <SrcComp>
//    PipSrc    <SrcComp>
a46 2
using namespace WitPip;

d51 1
a51 1
WitPipInt::WitPipInt (WitProblem * theProblem):
d60 1
a60 1
WitPipInt::~WitPipInt ()
d67 1
a67 1
void WitPipInt::preprocess ()
d76 1
a76 1
void WitPipInt::unpreprocess ()
d87 1
a87 1
void WitPipInt::clearTargs ()
d94 1
a94 1
void WitPipInt::recIncShipVol (
d104 1
a104 1
void WitPipInt::buildPegging ()
d111 1
a111 1
void WitPipInt::clearPegging ()
d118 1
a118 1
void WitPipInt::printPegging ()
d125 1
a125 1
void WitPipInt::getExecVolPairs (
d135 1
a135 1
void WitPipInt::getSubVolPairs (
d145 1
a145 1
void WitPipInt::getPartPegPairs (
d158 1
a158 1
WitPipMgr::WitPipMgr (WitProblem * theProblem):
d181 1
a181 1
WitPipMgr::~WitPipMgr ()
d198 1
a198 1
void WitPipMgr::recIncShipVol (
d221 1
a221 1
void WitPipMgr::clearTargs ()
d244 1
a244 1
void WitPipMgr::buildPegging ()
d271 1
a271 1
void WitPipMgr::clearPegging ()
d302 1
a302 1
void WitPipMgr::printPegging ()
d324 1
a324 1
void WitPipMgr::getExecVolPairs (
d341 1
a341 1
void WitPipMgr::getSubVolPairs (
d358 1
a358 1
void WitPipMgr::getPartPegPairs (
d376 1
a376 1
void WitPipMgr::checkRestrictions ()
d409 1
a409 1
WitPipTarg::WitPipTarg (
d430 1
a430 1
WitPipTarg::~WitPipTarg ()
d442 1
a442 1
void WitPipTarg::clearPegging ()
d454 1
a454 1
void WitPipTarg::printPegging ()
d482 1
a482 1
void WitPipTarg::consolidatePegging ()
d494 1
a494 1
void WitPipTarg::printExecVolPegging ()
d517 1
a517 1
void WitPipTarg::printSubVolPegging ()
d541 3
a543 1
void WitPipTarg::printPartPegging (PartAtt thePartAtt, const char * pegVolName)
d566 1
a566 1
FILE * WitPipTarg::solnFile ()
d576 2
a577 1
      WitPipPeg <SrcComp>::WitPipPeg (WitPipSrcMgr <SrcComp> * thePipSrcMgr):
d587 1
a587 1
      WitPipPeg <SrcComp>::~WitPipPeg ()
d594 1
a594 1
      void WitPipPeg <SrcComp>::append (
d604 1
a604 1
      void WitPipPeg <SrcComp>::append (
d619 1
a619 1
      void WitPipPeg <SrcComp>::clear ()
d627 1
a627 1
      void WitPipPeg <SrcComp>::consolidate ()
d635 1
a635 1
      void WitPipPeg <SrcComp>::getPegPairs (
d644 1
a644 1
      bool WitPipPeg <SrcComp>::isEmpty ()
d654 1
a654 1
      WitPipSrcMgr <SrcComp>::WitPipSrcMgr (WitProblem * theProblem):
d668 1
a668 1
      WitPipSrcMgr <SrcComp>::~WitPipSrcMgr ()
d678 1
a678 1
      WitPipPeg <SrcComp> * WitPipSrcMgr <SrcComp>::newPipPeg ()
d686 4
a689 3
      WitPipSrc <SrcComp> * WitPipSrcMgr <SrcComp>::myPipSrcFor (
         SrcComp * theSrcComp,
         WitPeriod thePer)
d713 1
a713 1
      void WitPipSrcMgr <SrcComp>::clear ()
d724 1
a724 1
      void WitPipSrcMgr <SrcComp>::consolidate (
d766 1
a766 1
      void WitPipSrcMgr <SrcComp>::postBuild ()
d773 1
a773 1
// Implementation of class template PipSrc <SrcComp>.
d777 3
a779 1
      WitPipSrc <SrcComp>::WitPipSrc (SrcComp * theSrcComp, WitPeriod thePer):
d789 1
a789 1
      WitPipSrc <SrcComp>::~WitPipSrc ()
d797 11
a807 11
template class WitPipPeg    <WitPart>;
template class WitPipSrcMgr <WitPart>;
template class WitPipSrc    <WitPart>;

template class WitPipPeg    <WitOperation>;
template class WitPipSrcMgr <WitOperation>;
template class WitPipSrc    <WitOperation>;

template class WitPipPeg    <WitSubEntry>;
template class WitPipSrcMgr <WitSubEntry>;
template class WitPipSrc    <WitSubEntry>;
@


1.39
log
@Continued implementation of PIP.
@
text
@d147 1
a147 1
void WitPipInt::getPegPairs (
d153 1
a153 1
   myPipMgr ()->getPegPairs (theDemand, shipPer, thePartAtt, thePegPairs);
d360 1
a360 1
void WitPipMgr::getPegPairs (
@


1.38
log
@Continued implementation of PIP.
@
text
@d47 2
d147 1
a147 11
void WitPipInt::getSupplyVolPairs (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitPartPipStack & thePegPairs)
   {
   myPipMgr ()->getSupplyVolPairs (theDemand, shipPer, thePegPairs);
   }

//------------------------------------------------------------------------------

void WitPipInt::getSideVolPairs (
d150 1
d153 1
a153 21
   myPipMgr ()->getSideVolPairs (theDemand, shipPer, thePegPairs);
   }

//------------------------------------------------------------------------------

void WitPipInt::getProdVolPairs (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitPartPipStack & thePegPairs)
   {
   myPipMgr ()->getProdVolPairs (theDemand, shipPer, thePegPairs);
   }

//------------------------------------------------------------------------------

void WitPipInt::getConsVolPairs (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitPartPipStack & thePegPairs)
   {
   myPipMgr ()->getConsVolPairs (theDemand, shipPer, thePegPairs);
d360 1
a360 52
void WitPipMgr::getSupplyVolPairs (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitPartPipStack & thePegPairs)
   {
   WitPipTarg * thePipTarg;

   thePipTarg = myPipTargs_.myPtrAt (theDemand, shipPer);

   if (thePipTarg != NULL)
      thePipTarg->supplyVolPeg ()->getPegPairs (thePegPairs);
   else
      thePegPairs.clear ();
   }

//------------------------------------------------------------------------------

void WitPipMgr::getSideVolPairs (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitPartPipStack & thePegPairs)
   {
   WitPipTarg * thePipTarg;

   thePipTarg = myPipTargs_.myPtrAt (theDemand, shipPer);

   if (thePipTarg != NULL)
      thePipTarg->sideVolPeg ()->getPegPairs (thePegPairs);
   else
      thePegPairs.clear ();
   }

//------------------------------------------------------------------------------

void WitPipMgr::getProdVolPairs (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitPartPipStack & thePegPairs)
   {
   WitPipTarg * thePipTarg;

   thePipTarg = myPipTargs_.myPtrAt (theDemand, shipPer);

   if (thePipTarg != NULL)
      thePipTarg->prodVolPeg ()->getPegPairs (thePegPairs);
   else
      thePegPairs.clear ();
   }

//------------------------------------------------------------------------------

void WitPipMgr::getConsVolPairs (
d363 1
d371 1
a371 1
      thePipTarg->consVolPeg ()->getPegPairs (thePegPairs);
d416 12
a427 15
      myDemand_     (theDemand),
      myShipPer_    (shipPer),
      execVolPeg_   (NULL),
      subVolPeg_    (NULL),
      supplyVolPeg_ (NULL),
      sideVolPeg_   (NULL),
      prodVolPeg_   (NULL),
      consVolPeg_   (NULL)
   {
   execVolPeg_   = thePipMgr->myOpnPipSrcMgr  ()->newPipPeg ();
   subVolPeg_    = thePipMgr->mySubPipSrcMgr  ()->newPipPeg ();
   supplyVolPeg_ = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
   sideVolPeg_   = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
   prodVolPeg_   = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
   consVolPeg_   = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
d434 4
a437 4
   delete consVolPeg_;
   delete prodVolPeg_;
   delete sideVolPeg_;
   delete supplyVolPeg_;
d446 6
a451 6
   execVolPeg_  ->clear ();
   subVolPeg_   ->clear ();
   supplyVolPeg_->clear ();
   sideVolPeg_  ->clear ();
   prodVolPeg_  ->clear ();
   consVolPeg_  ->clear ();
d460 4
a463 4
         if (supplyVolPeg_->isEmpty ())
            if (sideVolPeg_->isEmpty ())
               if (prodVolPeg_->isEmpty ())
                  if (consVolPeg_->isEmpty ())
d476 4
a479 4
   printPartPegging (supplyVolPeg_, "SupVol");
   printPartPegging (sideVolPeg_,   "SideVol");
   printPartPegging (prodVolPeg_,   "ProdVol");
   printPartPegging (consVolPeg_,   "ConsVol");
d486 6
a491 6
   execVolPeg_  ->consolidate ();
   subVolPeg_   ->consolidate ();
   supplyVolPeg_->consolidate ();
   sideVolPeg_  ->consolidate ();
   prodVolPeg_  ->consolidate ();
   consVolPeg_  ->consolidate ();
d543 1
a543 3
void WitPipTarg::printPartPegging (
      WitPipPeg <WitPart> * thePipPeg,
      const char *          pegVolName)
d549 1
a549 1
   if (thePipPeg->isEmpty ())
d552 1
a552 1
   thePipPeg->getPegPairs (thePegPairs);
@


1.37
log
@Continued implementation of PIP.
@
text
@d203 1
a203 4
   if (myGlobalComp ()->allowSideEffs ())
      checkRestrictions ();
   else
      checkNoSideRest ();
a462 2
   stronglyAssert (myGlobalComp ()->allowSideEffs ());

a481 40
   }

//------------------------------------------------------------------------------

void WitPipMgr::checkNoSideRest ()
   {
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitPeriod      execPer;

   stronglyAssert (not myGlobalComp ()->allowSideEffs ());

   forEachOperation (theOpn, myProblem ())
      if (theOpn->bop ().nElements () > 1)
         myMsgFac () ("nyiForPIPSmsg",
            "multiple BOP entries for a single operation");

   forEachBopEntry (theBopEnt, myProblem ())
      {
      if (not theBopEnt->expAllowed ())
         myMsgFac () ("nyiForPIPSmsg", "unexplodeable BOP entries");

      forEachPeriod (execPer, myProblem ())
         if (theBopEnt->effProdRate ()[execPer] > 0.0)
            if (not theBopEnt->execPerOKForExp (execPer))
               myMsgFac () ("nyiForPIPSmsg",
                  "BOP entries with effective production rate < expCutOff");
      }

   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theBomEnt->consRate ()[execPer] < 0.0)
            myMsgFac () ("nyiForPIPSmsg", "negative consRates");

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theSub->consRate ()[execPer] < 0.0)
            myMsgFac () ("nyiForPIPSmsg", "negative consRates");
@


1.36
log
@Continued implementation of PIP.
@
text
@d155 10
d401 17
@


1.35
log
@Minor corrections.
@
text
@d193 4
a196 1
   checkRestrictions ();
d434 33
d472 2
d516 1
d523 1
d534 1
d547 1
d559 4
a562 3
            if (prodVolPeg_->isEmpty ())
               if (consVolPeg_->isEmpty ())
                  return;
d571 7
a577 5
   printExecVolPegging   ();
   printSubVolPegging    ();
   printSupplyVolPegging ();
   printProdVolPegging   ();
   printConsVolPegging   ();
d587 1
d641 3
a643 47
void WitPipTarg::printSupplyVolPegging ()
   {
   WitPartPipStack       supplyVolPairs (myDemand ()->myProblem ());
   WitPipSrc <WitPart> * thePartPipSrc;
   double                pdgSupplyVol;

   if (supplyVolPeg_->isEmpty ())
      return;

   supplyVolPeg_->getPegPairs (supplyVolPairs);

   fprintf (solnFile (), "\n   Part  Per   SupVol\n");

   while (supplyVolPairs.pop (thePartPipSrc, pdgSupplyVol))
      fprintf (solnFile (),
         "   %-3s   %3d %8.3f\n",
         thePartPipSrc->mySrcComp ()->partName ().myCstring (),
         thePartPipSrc->myPer (),
         pdgSupplyVol);
   }

//------------------------------------------------------------------------------

void WitPipTarg::printProdVolPegging ()
   {
   WitPartPipStack       prodVolPairs (myDemand ()->myProblem ());
   WitPipSrc <WitPart> * thePartPipSrc;
   double                pdgProdVol;

   if (prodVolPeg_->isEmpty ())
      return;

   prodVolPeg_->getPegPairs (prodVolPairs);

   fprintf (solnFile (), "\n   Part  Per  ProdVol\n");

   while (prodVolPairs.pop (thePartPipSrc, pdgProdVol))
      fprintf (solnFile (),
         "   %-3s   %3d %8.3f\n",
         thePartPipSrc->mySrcComp ()->partName ().myCstring (),
         thePartPipSrc->myPer (),
         pdgProdVol);
   }

//------------------------------------------------------------------------------

void WitPipTarg::printConsVolPegging ()
d645 1
a645 1
   WitPartPipStack       consVolPairs (myDemand ()->myProblem ());
d647 1
a647 1
   double                pdgConsVol;
d649 1
a649 1
   if (consVolPeg_->isEmpty ())
d652 1
a652 1
   consVolPeg_->getPegPairs (consVolPairs);
d654 1
a654 1
   fprintf (solnFile (), "\n   Part  Per  ConsVol\n");
d656 1
a656 1
   while (consVolPairs.pop (thePartPipSrc, pdgConsVol))
d661 1
a661 1
         pdgConsVol);
@


1.34
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d242 2
a243 3
   WitDemand *  theDemand;
   WitPeriod    shipPer;
   WitPipTarg * thePipTarg;
a431 1
   WitPart *      thePart;
a434 1
   WitPeriod      expPer;
@


1.33
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d69 1
a69 1
   witAssert (myGlobalComp ()->perfPIPegging ());
d78 1
a78 1
   witAssert (myGlobalComp ()->perfPIPegging ());
d125 1
a125 1
void WitPipInt::getExecPegPairs (
d130 1
a130 1
   myPipMgr ()->getExecPegPairs (theDemand, shipPer, thePegPairs);
d135 1
a135 1
void WitPipInt::getSubPegPairs (
d140 1
a140 1
   myPipMgr ()->getSubPegPairs (theDemand, shipPer, thePegPairs);
d145 1
a145 1
void WitPipInt::getSupplyPegPairs (
d150 21
a170 1
   myPipMgr ()->getSupplyPegPairs (theDemand, shipPer, thePegPairs);
d344 1
a344 1
void WitPipMgr::getExecPegPairs (
d361 1
a361 1
void WitPipMgr::getSubPegPairs (
d378 1
a378 1
void WitPipMgr::getSupplyPegPairs (
d395 1
a395 1
void WitPipMgr::getProdPegPairs (
d406 17
@


1.32
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d444 2
a445 1
      prodVolPeg_   (NULL)
d451 1
d458 1
d473 1
d484 2
a485 1
               return;
d498 1
d509 1
d518 1
a518 1
   double                     pegVol;
d527 1
a527 1
   while (execVolPairs.pop (theOpnPipSrc, pegVol))
d532 1
a532 1
         pegVol);
d541 1
a541 1
   double                    pegVol;
d550 1
a550 1
   while (subVolPairs.pop (theSubPipSrc, pegVol))
d556 1
a556 1
         pegVol);
d565 1
a565 1
   double                pegVol;
d574 1
a574 1
   while (supplyVolPairs.pop (thePartPipSrc, pegVol))
d579 1
a579 1
         pegVol);
d588 1
a588 1
   double                pegVol;
d597 1
a597 1
   while (prodVolPairs.pop (thePartPipSrc, pegVol))
d602 24
a625 1
         pegVol);
@


1.31
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d260 4
d385 1
a385 1
      thePipTarg->getProdPegPairs (thePegPairs);
d443 2
a444 1
      supplyVolPeg_ (NULL)
d449 1
d456 1
d469 1
d479 2
a480 1
            return;
d502 1
a502 46
   }

//------------------------------------------------------------------------------

void WitPipTarg::getProdPegPairs (WitPartPipStack & prodPegPairs)
   {
   WitPipPeg <WitPart> *      prodVolPeg;
   WitOpnPipStack             execPegPairs (myDemand ()->myProblem ());
   WitPipSrc <WitOperation> * theOpnSrc;
   double                     pgdExecVol;
   WitOperation *             theOpn;
   WitPeriod                  execPer;
   WitBopEntry *              theBopEnt;
   WitPart *                  prodPart;
   WitPeriod                  prodPer;
   double                     pgdProdVol;

   prodVolPeg = new WitPipPeg <WitPart> (supplyVolPeg_->myPipSrcMgr ());

   execVolPeg_->getPegPairs (execPegPairs);

   while (execPegPairs.pop (theOpnSrc, pgdExecVol))
      {
      theOpn     = theOpnSrc->mySrcComp ();
      execPer    = theOpnSrc->myPer ();

      witAssert (theOpn->bop ().nElements () == 1);

      theBopEnt  = theOpn->bop ().first ();

      prodPart   = theBopEnt->myPart ();

      prodPer    = theBopEnt->impactPeriod ()[execPer];

      witAssert (prodPer >= 0);

      pgdProdVol = pgdExecVol * theBopEnt->effProdRate ()[execPer];

      prodVolPeg->append (prodPart, prodPer, pgdProdVol);
      }

   prodVolPeg->consolidate ();

   prodVolPeg->getPegPairs (prodPegPairs);

   delete prodVolPeg;
d509 1
a509 1
   WitOpnPipStack             execPegPairs (myDemand ()->myProblem ());
d516 1
a516 1
   execVolPeg_->getPegPairs (execPegPairs);
d520 1
a520 1
   while (execPegPairs.pop (theOpnPipSrc, pegVol))
d532 1
a532 1
   WitSubPipStack            subPegPairs (myDemand ()->myProblem ());
d539 1
a539 1
   subVolPeg_->getPegPairs (subPegPairs);
d543 1
a543 1
   while (subPegPairs.pop (theSubPipSrc, pegVol))
d556 1
a556 1
   WitPartPipStack       supplyPegPairs (myDemand ()->myProblem ());
d563 1
a563 1
   supplyVolPeg_->getPegPairs (supplyPegPairs);
d567 1
a567 1
   while (supplyPegPairs.pop (thePartPipSrc, pegVol))
d579 1
a579 1
   WitPartPipStack       prodPegPairs (myDemand ()->myProblem ());
d583 2
a584 1
   getProdPegPairs (prodPegPairs);
d586 1
a586 2
   if (prodPegPairs.isEmpty ())
      return;
d590 1
a590 1
   while (prodPegPairs.pop (thePartPipSrc, pegVol))
d692 1
a692 1
         consSched_     ()
d695 1
a695 1
   consSched_    .allocate1D (theProblem);
d771 2
a772 2
      if (not consSched_ (theSrcComp).isAllocated ())
         consSched_ (theSrcComp).allocate (myProblem (), 0.0);
d774 1
a774 1
      consSched_ (theSrcComp)[thePer] += pegVol;
d784 1
a784 1
      pegVol     = consSched_ (theSrcComp)[thePer];
d789 1
a789 1
      consSched_ (theSrcComp)[thePer] = 0.0;
d794 9
@


1.30
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d165 1
a165 2
      pegged_          (false),
      consPartSched_   ()
a259 2
   consPartSched_.allocate (myProblem (), 0.0);

a279 2
   consPartSched_.clear ();

d314 1
a314 1
            thePipTarg->printPegging (this);
d376 1
a376 10
   WitPipPeg <WitPart> *      prodVolPeg;
   WitOpnPipStack             execPegPairs (myProblem ());
   WitPipSrc <WitOperation> * theOpnSrc;
   double                     pgdExecVol;
   WitOperation *             theOpn;
   WitPeriod                  execPer;
   WitBopEntry *              theBopEnt;
   WitPart *                  prodPart;
   WitPeriod                  prodPer;
   double                     pgdProdVol;
d378 1
a378 1
   prodVolPeg = new WitPipPeg <WitPart> (myPartPipSrcMgr_);
d380 4
a383 27
   getExecPegPairs (theDemand, shipPer, execPegPairs);
   
   while (execPegPairs.pop (theOpnSrc, pgdExecVol))
      {
      theOpn     = theOpnSrc->mySrcComp ();
      execPer    = theOpnSrc->myPer ();

      witAssert (theOpn->bop ().nElements () == 1);

      theBopEnt  = theOpn->bop ().first ();

      prodPart   = theBopEnt->myPart ();

      prodPer    = theBopEnt->impactPeriod ()[execPer];

      witAssert (prodPer >= 0);

      pgdProdVol = pgdExecVol * theBopEnt->effProdRate ()[execPer];

      prodVolPeg->append (prodPart, prodPer, pgdProdVol);
      }

   prodVolPeg->consolidate (consPartSched_);

   prodVolPeg->getPegPairs (thePegPairs);

   delete prodVolPeg;
d483 10
d497 1
a497 1
void WitPipTarg::printPegging (WitPipMgr * thePipMgr)
d499 36
a534 4
   if (execVolPeg_->isEmpty ())
      if (subVolPeg_->isEmpty ())
         if (supplyVolPeg_->isEmpty ())
            return;
d536 1
a536 6
   fprintf (solnFile (),
      "\n\n"
      "Part %s, Demand %s, Ship Per %d:\n",
      myDemand_->demandedPartName ().myCstring (),
      myDemand_->demandName ().myCstring (),
      myShipPer_);
d538 1
a538 4
   printExecVolPegging   ();
   printSubVolPegging    ();
   printSupplyVolPegging ();
   printProdVolPegging   (thePipMgr);
d545 1
a545 1
   WitOpnPipStack             execVolPairs (myDemand ()->myProblem ());
d552 1
a552 1
   execVolPeg_->getPegPairs (execVolPairs);
d556 1
a556 1
   while (execVolPairs.pop (theOpnPipSrc, pegVol))
d568 1
a568 1
   WitSubPipStack            subVolPairs (myDemand ()->myProblem ());
d575 1
a575 1
   subVolPeg_->getPegPairs (subVolPairs);
d579 1
a579 1
   while (subVolPairs.pop (theSubPipSrc, pegVol))
d592 1
a592 1
   WitPartPipStack       supplyVolPairs (myDemand ()->myProblem ());
d599 1
a599 1
   supplyVolPeg_->getPegPairs (supplyVolPairs);
d603 1
a603 1
   while (supplyVolPairs.pop (thePartPipSrc, pegVol))
d613 1
a613 1
void WitPipTarg::printProdVolPegging (WitPipMgr * thePipMgr)
d615 1
a615 1
   WitPartPipStack       prodVolPairs (myDemand ()->myProblem ());
d619 1
a619 1
   thePipMgr->getProdPegPairs (myDemand (), myShipPer (), prodVolPairs);
d621 1
a621 1
   if (prodVolPairs.isEmpty ())
d626 1
a626 1
   while (prodVolPairs.pop (thePartPipSrc, pegVol))
d696 1
a696 2
      void WitPipPeg <SrcComp>::consolidate (
         WitSchedule <SrcComp, double> & thePegSched)
d698 1
a698 31
   WitPipSrc <SrcComp> * thePipSrc;
   double                pegVol;
   SrcComp *             theSrcComp;
   WitPeriod             thePer;

   WitObjStack <WitPipSrc <SrcComp> > thePipSrcs (myPipSrcMgr_->myProblem ());

   while (myPegPairs_.pop (thePipSrc, pegVol))
      {
      theSrcComp = thePipSrc->mySrcComp ();
      thePer     = thePipSrc->myPer ();

      thePegSched (theSrcComp)[thePer] += pegVol;

      thePipSrcs.push (thePipSrc);
      }

   while (thePipSrcs.pop (thePipSrc))
      {
      theSrcComp = thePipSrc->mySrcComp ();
      thePer     = thePipSrc->myPer ();

      pegVol     = thePegSched (theSrcComp)[thePer];

      if (pegVol == 0.0)
         continue;

      thePegSched (theSrcComp)[thePer] = 0.0;

      myPegPairs_.push (thePipSrc, pegVol);
      }
d727 2
a728 1
         myPipSrcSched_ ()
d731 1
d787 42
@


1.29
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d165 2
a166 1
      pegged_          (false)
d261 2
d283 2
d415 2
@


1.28
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d126 3
a128 3
      WitDemand *                                       theDemand,
      WitPeriod                                         shipPer,
      WitPairStack <WitPipSrc <WitOperation>, double> & thePegPairs)
d136 3
a138 3
      WitDemand *                                      theDemand,
      WitPeriod                                        shipPer,
      WitPairStack <WitPipSrc <WitSubEntry>, double> & thePegPairs)
d146 3
a148 3
      WitDemand *                                  theDemand,
      WitPeriod                                    shipPer,
      WitPairStack <WitPipSrc <WitPart>, double> & thePegPairs)
d300 3
a302 10
   WitDemand *                theDemand;
   WitPeriod                  shipPer;
   WitPipSrc <WitOperation> * theOpnPipSrc;
   WitPipSrc <WitSubEntry>  * theSubPipSrc;
   WitPipSrc <WitPart> *      thePartPipSrc;
   double                     pegVol;

   WitPairStack <WitPipSrc <WitOperation>,double> theExecPairs   (myProblem ());
   WitPairStack <WitPipSrc <WitSubEntry>, double> theSubPairs    (myProblem ());
   WitPairStack <WitPipSrc <WitPart>,     double> theSupplyPairs (myProblem ());
d311 1
a311 15
         getExecPegPairs   (theDemand, shipPer, theExecPairs);
         getSubPegPairs    (theDemand, shipPer, theSubPairs);
         getSupplyPegPairs (theDemand, shipPer, theSupplyPairs);

         if (theExecPairs.isEmpty ())
            if (theSubPairs.isEmpty ())
               if (theSupplyPairs.isEmpty ())
                  continue;

         fprintf (myProblem ()->solnFile (),
            "\n\n"
            "Part %s, Demand %s, Ship Per %d:\n",
            theDemand->demandedPartName ().myCstring (),
            theDemand->demandName ().myCstring (),
            shipPer);
d313 2
a314 37
         if (theExecPairs.isNonEmpty ())
            {
            fprintf (myProblem ()->solnFile (), "\n   Opn   Per  ExecVol\n");

            while (theExecPairs.pop (theOpnPipSrc, pegVol))
               fprintf (myProblem ()->solnFile (),
                  "   %-3s   %3d %8.3f\n",
                  theOpnPipSrc->mySrcComp ()->operationName ().myCstring (),
                  theOpnPipSrc->myPer (),
                  pegVol);
            }

         if (theSubPairs.isNonEmpty ())
            {
            fprintf (myProblem ()->solnFile (),
               "\n   Opn   Part   Per   SubVol\n");

            while (theSubPairs.pop (theSubPipSrc, pegVol))
               fprintf (myProblem ()->solnFile (),
                  "   %-3s   %-4s   %3d %8.3f\n",
                  theSubPipSrc->mySrcComp ()->myOperationName ().myCstring (),
                  theSubPipSrc->mySrcComp ()->myPartName      ().myCstring (),
                  theSubPipSrc->myPer (),
                  pegVol);
            }

         if (theSupplyPairs.isNonEmpty ())
            {
            fprintf (myProblem ()->solnFile (), "\n   Part  Per   SupVol\n");

            while (theSupplyPairs.pop (thePartPipSrc, pegVol))
               fprintf (myProblem ()->solnFile (),
                  "   %-3s   %3d %8.3f\n",
                  thePartPipSrc->mySrcComp ()->partName ().myCstring (),
                  thePartPipSrc->myPer (),
                  pegVol);
            }
d321 3
a323 3
      WitDemand *                                       theDemand,
      WitPeriod                                         shipPer,
      WitPairStack <WitPipSrc <WitOperation>, double> & thePegPairs)
d338 3
a340 3
      WitDemand *                                      theDemand,
      WitPeriod                                        shipPer,
      WitPairStack <WitPipSrc <WitSubEntry>, double> & thePegPairs)
d355 3
a357 3
      WitDemand *                                  theDemand,
      WitPeriod                                    shipPer,
      WitPairStack <WitPipSrc <WitPart>, double> & thePegPairs)
d371 47
d495 143
d735 8
@


1.27
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d340 1
a340 1
                  "   %-3s   %-3d %8.3f\n",
d353 1
a353 1
                  "   %-3s   %-4s   %-3d %8.3f\n",
d366 1
a366 1
                  "   %-3s   %-3d %8.3f\n",
@


1.26
log
@Continued implementation of Post-Implosion Pegging.
@
text
@a124 10
void WitPipInt::getSupplyPegPairs (
      WitDemand *                                  theDemand,
      WitPeriod                                    shipPer,
      WitPairStack <WitPipSrc <WitPart>, double> & thePegPairs)
   {
   myPipMgr ()->getSupplyPegPairs (theDemand, shipPer, thePegPairs);
   }

//------------------------------------------------------------------------------

d144 10
a161 1
      myPartPipSrcMgr_ (NULL),
d164 1
a168 1
   myPartPipSrcMgr_ = new WitPipSrcMgr <WitPart>      (myProblem ());
d171 1
d188 1
a190 1
   delete myPartPipSrcMgr_;
d289 1
a290 1
   myOpnPipSrcMgr_ ->clear ();
a301 1
   WitPipSrc <WitPart> *      thePartPipSrc;
d304 1
a306 1
   WitPairStack <WitPipSrc <WitPart>,     double> theSupplyPairs (myProblem ());
d309 1
a317 1
         getSupplyPegPairs (theDemand, shipPer, theSupplyPairs);
d320 1
d322 3
a324 3
         if (theSupplyPairs.isEmpty ())
            if (theExecPairs.isEmpty ())
               if (theSubPairs.isEmpty ())
a333 12
         if (theSupplyPairs.isNonEmpty ())
            {
            fprintf (myProblem ()->solnFile (), "\n   Part  Per   SupVol\n");

            while (theSupplyPairs.pop (thePartPipSrc, pegVol))
               fprintf (myProblem ()->solnFile (),
                  "   %-3s   %-3d %8.3f\n",
                  thePartPipSrc->mySrcComp ()->partName ().myCstring (),
                  thePartPipSrc->myPer (),
                  pegVol);
            }

d359 12
d376 4
a379 4
void WitPipMgr::getSupplyPegPairs (
      WitDemand *                                  theDemand,
      WitPeriod                                    shipPer,
      WitPairStack <WitPipSrc <WitPart>, double> & thePegPairs)
d386 1
a386 1
      thePipTarg->supplyVolPeg ()->getPegPairs (thePegPairs);
d393 4
a396 4
void WitPipMgr::getExecPegPairs (
      WitDemand *                                       theDemand,
      WitPeriod                                         shipPer,
      WitPairStack <WitPipSrc <WitOperation>, double> & thePegPairs)
d403 1
a403 1
      thePipTarg->execVolPeg ()->getPegPairs (thePegPairs);
d410 4
a413 4
void WitPipMgr::getSubPegPairs (
      WitDemand *                                      theDemand,
      WitPeriod                                        shipPer,
      WitPairStack <WitPipSrc <WitSubEntry>, double> & thePegPairs)
d420 1
a420 1
      thePipTarg->subVolPeg ()->getPegPairs (thePegPairs);
a475 1
      supplyVolPeg_ (NULL),
d477 2
a478 1
      subVolPeg_    (NULL)
a479 1
   supplyVolPeg_ = thePipMgr->myPartPipSrcMgr ()->newPipPeg ();
d482 1
d489 1
a491 1
   delete supplyVolPeg_;
d498 1
a499 1
   execVolPeg_  ->clear ();
@


1.25
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d43 1
d167 2
d174 2
d182 2
d191 2
d226 2
d238 2
d246 2
d261 2
d276 2
d292 2
@


1.24
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d124 4
a127 4
void WitPipInt::getSupPegPairs (
      WitDemand *                            theDemand,
      WitPeriod                              shipPer,
      WitPairStack <WitPartPipSrc, double> & thePegPairs)
d129 1
a129 1
   myPipMgr ()->getSupPegPairs (theDemand, shipPer, thePegPairs);
d135 3
a137 3
      WitDemand *                           theDemand,
      WitPeriod                             shipPer,
      WitPairStack <WitOpnPipSrc, double> & thePegPairs)
d143 10
d163 1
d168 1
d181 1
d269 2
a270 1

d279 10
a288 9
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   WitPartPipSrc * thePartPipSrc;
   WitOpnPipSrc *  theOpnPipSrc;
   double          pegVol;
   WitPart *       thePart;

   WitPairStack <WitPartPipSrc, double> theSupPegPairs  (myProblem ());
   WitPairStack <WitOpnPipSrc,  double> theExecPegPairs (myProblem ());
d297 8
a304 6
         getSupPegPairs  (theDemand, shipPer, theSupPegPairs);
         getExecPegPairs (theDemand, shipPer, theExecPegPairs);

         if (theSupPegPairs.isEmpty ())
            if (theExecPegPairs.isEmpty ())
               continue;
d313 1
a313 1
         if (theSupPegPairs.isNonEmpty ())
d317 1
a317 1
            while (theSupPegPairs.pop (thePartPipSrc, pegVol))
d325 1
a325 1
         if (theExecPegPairs.isNonEmpty ())
d329 1
a329 1
            while (theExecPegPairs.pop (theOpnPipSrc, pegVol))
d336 14
d355 4
a358 4
void WitPipMgr::getSupPegPairs (
      WitDemand *                            theDemand,
      WitPeriod                              shipPer,
      WitPairStack <WitPartPipSrc, double> & thePegPairs)
d365 1
a365 1
      thePipTarg->supVolPeg ()->getPegPairs (thePegPairs);
d373 3
a375 3
      WitDemand *                           theDemand,
      WitPeriod                             shipPer,
      WitPairStack <WitOpnPipSrc, double> & thePegPairs)
d389 17
d453 9
a461 10
      myDemand_   (theDemand),
      myShipPer_  (shipPer),
      supVolPeg_  (NULL),
      execVolPeg_ (NULL)
   {
   supVolPeg_  =
      new WitPipPeg <WitPart>      (thePipMgr->myPartPipSrcMgr ());

   execVolPeg_ =
      new WitPipPeg <WitOperation> (thePipMgr->myOpnPipSrcMgr ());
d468 1
d470 1
a470 1
   delete supVolPeg_;
d477 3
a479 2
   execVolPeg_->clear ();
   supVolPeg_ ->clear ();
d609 8
d681 4
@


1.23
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d148 6
a153 6
      WitProbAssoc  (theProblem),
      myPipTargs_   (theProblem),
      revShipSeq_   (theProblem),
      myPartSrcMgr_ (NULL),
      myOpnSrcMgr_  (NULL),
      pegged_       (false)
d155 2
a156 2
   myPartSrcMgr_ = new WitPipSrcMgr <WitPart>      (myProblem ());
   myOpnSrcMgr_  = new WitPipSrcMgr <WitOperation> (myProblem ());
d169 2
a170 2
   delete myOpnSrcMgr_;
   delete myPartSrcMgr_;
d257 2
a258 2
   myOpnSrcMgr_ ->clear ();
   myPartSrcMgr_->clear ();
d411 1
a411 1
      new WitPipPeg <WitPart>      (thePipMgr->myPartSrcMgr ());
d414 1
a414 1
      new WitPipPeg <WitOperation> (thePipMgr->myOpnSrcMgr ());
@


1.22
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d40 2
d43 1
d157 2
d354 40
@


1.21
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d152 2
d163 3
d183 1
a183 1
      thePipTarg = new WitPipTarg (theDemand, shipPer);
d215 3
d220 4
a223 2
   myPartSrcMgr_ = new WitPipSrcMgr <WitPart>      (myProblem ());
   myOpnSrcMgr_  = new WitPipSrcMgr <WitOperation> (myProblem ());
d225 1
a225 1
   innerBuildPegging ();
d252 2
a253 5
   delete myOpnSrcMgr_;
   delete myPartSrcMgr_;
   
   myOpnSrcMgr_  = NULL;
   myPartSrcMgr_ = NULL;
a351 16

void WitPipMgr::innerBuildPegging ()
   {
   WitPipBuilder thePipBuilder (this);

   WitPairStack <WitPipTarg, double> fwdShipSeq (myProblem ());

   fwdShipSeq.takeContents (revShipSeq_);

   if (not myGlobalComp ()->revPipSeq ())
      fwdShipSeq.reverse ();

   thePipBuilder.buildPegging (fwdShipSeq);
   }

//------------------------------------------------------------------------------
d355 4
a358 1
WitPipTarg::WitPipTarg (WitDemand * theDemand, WitPeriod shipPer):
d365 5
a369 2
   supVolPeg_  = new WitPipPeg <WitPart>      (theDemand->myProblem ());
   execVolPeg_ = new WitPipPeg <WitOperation> (theDemand->myProblem ());
d393 1
a393 1
      WitPipPeg <SrcComp>::WitPipPeg (WitProblem * theProblem):
d395 2
a396 2
         WitProbAssoc (theProblem),
         myPegPairs_  (theProblem)
d420 15
d451 1
a451 1
   WitObjStack <WitPipSrc <SrcComp> > thePipSrcs (myProblem ());
d536 11
@


1.20
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d18 9
a26 2
//    PipPeg <SrcComp>, with explicit instantiation
//    PipSrc <SrcComp>, with explicit instantiation
d30 1
d145 6
a150 6
      WitProbAssoc   (theProblem),
      myPipTargs_    (theProblem),
      revShipSeq_    (theProblem),
      myPartPipSrcs_ (),
      myOpnPipSrcs_  (),
      pegged_        (false)
d212 2
a213 2
   myPartPipSrcs_.allocate (myProblem ());
   myOpnPipSrcs_ .allocate (myProblem ());
d224 3
a226 5
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitPart *      thePart;
   WitPeriod      thePer;
   WitPipTarg *   thePipTarg;
d242 5
a246 10
   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myOpnPipSrcs_.myPtrAt (theOpn, thePer);

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myPartPipSrcs_.myPtrAt (thePart, thePer);

   myOpnPipSrcs_ .clear ();
   myPartPipSrcs_.clear ();
a345 38
WitPartPipSrc * WitPipMgr::myPartPipSrcFor (WitPart * thePart, WitPeriod thePer)
   {
   WitPartPipSrc * thePartPipSrc;

   thePartPipSrc = myPartPipSrcs_.myPtrAt (thePart, thePer);

   if (thePartPipSrc == NULL)
      {
      thePartPipSrc = new WitPartPipSrc (thePart, thePer);

      myPartPipSrcs_.myPtrAt (thePart, thePer) = thePartPipSrc;
      }

   return thePartPipSrc;
   }

//------------------------------------------------------------------------------

WitOpnPipSrc * WitPipMgr::myOpnPipSrcFor (
      WitOperation * theOpn,
      WitPeriod      thePer)
   {
   WitOpnPipSrc * theOpnPipSrc;

   theOpnPipSrc = myOpnPipSrcs_.myPtrAt (theOpn, thePer);

   if (theOpnPipSrc == NULL)
      {
      theOpnPipSrc = new WitOpnPipSrc (theOpn, thePer);

      myOpnPipSrcs_.myPtrAt (theOpn, thePer) = theOpnPipSrc;
      }

   return theOpnPipSrc;
   }

//------------------------------------------------------------------------------

d371 2
a372 2
   supVolPeg_  = new WitPartPipPeg (theDemand->myProblem ());
   execVolPeg_ = new WitOpnPipPeg  (theDemand->myProblem ());
d477 23
a499 1
// Explicit instantiation of class template PipPeg <SrcComp>.
d502 23
a524 2
template class WitPipPeg <WitPart>;
template class WitPipPeg <WitOperation>;
d546 1
a546 1
// Explicit instantiation of class template PipSrc <SrcComp>.
d549 7
a555 2
template class WitPipSrc <WitPart>;
template class WitPipSrc <WitOperation>;
@


1.19
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d32 1
d468 1
a468 28
      void WitPipPeg <SrcComp>::mergeWith (
            WitPipPeg   <SrcComp> *         thePipPeg,
            WitSchedule <SrcComp, double> & workPegSched)
   {
   WitPairStack <WitPipSrc <SrcComp>, double> thePegPairs (myProblem ());

              loadIntoSched (workPegSched);
   thePipPeg->loadIntoSched (workPegSched);

              loadIntoPairs (thePegPairs, workPegSched);
   thePipPeg->loadIntoPairs (thePegPairs, workPegSched);

   myPegPairs_.takeContents (thePegPairs);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipPeg <SrcComp>::getPegPairs (
            WitPairStack <WitPipSrc <SrcComp>, double> & thePegPairs)
   {
   thePegPairs.revCopyFrom (myPegPairs_);
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipPeg <SrcComp>::loadIntoSched (
d476 1
a476 1
   WitPairStItr <WitPipSrc <SrcComp>, double> theItr;
d478 1
a478 3
   theItr.attachTo (myPegPairs_);

   while (theItr.advance (thePipSrc, pegVol))
d484 2
a486 15
   }

//------------------------------------------------------------------------------

template <typename SrcComp> 
      void WitPipPeg <SrcComp>::loadIntoPairs (
         WitPairStack <WitPipSrc <SrcComp>, double> & thePegPairs,
         WitSchedule  <           SrcComp,  double> & thePegSched)
   {
   WitPipSrc <SrcComp> * thePipSrc;
   double                pegVol;
   SrcComp *             theSrcComp;
   WitPeriod             thePer;

   myPegPairs_.reverse ();
d488 1
a488 1
   while (myPegPairs_.pop (thePipSrc, pegVol))
d500 1
a500 1
      thePegPairs.push (thePipSrc, pegVol);
d502 9
@


1.18
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d18 1
d23 1
d112 1
a112 1
void WitPipInt::getSupVolPegging (
d115 1
a115 1
      WitPairStack <WitPartPipSrc, double> & thePegging)
d117 1
a117 1
   myPipMgr ()->getSupVolPegging (theDemand, shipPer, thePegging);
d122 1
a122 1
void WitPipInt::getExecVolPegging (
d125 1
a125 1
      WitPairStack <WitOpnPipSrc, double> & thePegging)
d127 1
a127 1
   myPipMgr ()->getExecVolPegging (theDemand, shipPer, thePegging);
d258 2
a259 2
   WitPairStack <WitPartPipSrc, double> theSupVolPeg  (myProblem ());
   WitPairStack <WitOpnPipSrc,  double> theExecVolPeg (myProblem ());
d268 2
a269 2
         getSupVolPegging  (theDemand, shipPer, theSupVolPeg);
         getExecVolPegging (theDemand, shipPer, theExecVolPeg);
d271 2
a272 2
         if (theSupVolPeg.isEmpty ())
            if (theExecVolPeg.isEmpty ())
d282 1
a282 1
         if (theSupVolPeg.isNonEmpty ())
d286 1
a286 1
            while (theSupVolPeg.pop (thePartPipSrc, pegVol))
d294 1
a294 1
         if (theExecVolPeg.isNonEmpty ())
d298 1
a298 1
            while (theExecVolPeg.pop (theOpnPipSrc, pegVol))
d310 1
a310 1
void WitPipMgr::getSupVolPegging (
d313 1
a313 1
      WitPairStack <WitPartPipSrc, double> & thePegging)
d320 1
a320 1
      thePegging.revCopyFrom (thePipTarg->supVolPeg ());
d322 1
a322 1
      thePegging.clear ();
d327 1
a327 1
void WitPipMgr::getExecVolPegging (
d330 1
a330 1
      WitPairStack <WitOpnPipSrc, double> & thePegging)
d337 1
a337 1
      thePegging.revCopyFrom (thePipTarg->execVolPeg ());
d339 1
a339 1
      thePegging.clear ();
d404 2
a405 2
      supVolPeg_  (theDemand->myProblem ()),
      execVolPeg_ (theDemand->myProblem ())
d407 2
d415 2
d421 1
a421 3
void WitPipTarg::mergeToSupVolPeg (
      WitPairStack <WitPartPipSrc, double> & thePegging,
      WitSchedule  <WitPart,       double> & workPegSched)
d423 3
a425 1
   WitPairStack <WitPartPipSrc, double> oldPegging (myDemand_->myProblem ());
d427 3
a429 1
   oldPegging.takeContents (supVolPeg_);
d431 2
a432 2
   loadPegSched  (oldPegging, workPegSched);
   loadPegSched  (thePegging, workPegSched);
d434 3
a436 2
   loadSupVolPeg (oldPegging, workPegSched);
   loadSupVolPeg (thePegging, workPegSched);
d441 2
a442 3
void WitPipTarg::mergeToExecVolPeg (
      WitPairStack <WitOpnPipSrc, double> & thePegging,
      WitSchedule  <WitOperation, double> & workPegSched)
d444 1
a444 1
   WitPairStack <WitOpnPipSrc, double> oldPegging (myDemand_->myProblem ());
d446 1
a446 1
   oldPegging.takeContents (execVolPeg_);
d448 6
a453 5
   loadPegSched   (oldPegging, workPegSched);
   loadPegSched   (thePegging, workPegSched);

   loadExecVolPeg (oldPegging, workPegSched);
   loadExecVolPeg (thePegging, workPegSched);
d458 2
a459 3
void WitPipTarg::loadPegSched (
      const WitPairStack <WitPartPipSrc, double> & thePegging,
            WitSchedule  <WitPart,       double> & workPegSched)
d461 1
a461 16
   WitPartPipSrc * thePartPipSrc;
   double          pegVol;
   WitPart *       thePart;
   WitPeriod       thePer;

   WitPairStItr <WitPartPipSrc, double> theItr;

   theItr.attachTo (thePegging);

   while (theItr.advance (thePartPipSrc, pegVol))
      {
      thePart = thePartPipSrc->mySrcComp ();
      thePer  = thePartPipSrc->myPer ();

      workPegSched (thePart)[thePer] += pegVol;
      }
d466 4
a469 3
void WitPipTarg::loadPegSched (
      const WitPairStack <WitOpnPipSrc, double> & thePegging,
            WitSchedule  <WitOperation, double> & workPegSched)
d471 1
a471 4
   WitOpnPipSrc * theOpnPipSrc;
   double         pegVol;
   WitOperation * theOpn;
   WitPeriod      thePer;
d473 2
a474 1
   WitPairStItr <WitOpnPipSrc, double> theItr;
d476 2
a477 1
   theItr.attachTo (thePegging);
d479 1
a479 7
   while (theItr.advance (theOpnPipSrc, pegVol))
      {
      theOpn = theOpnPipSrc->mySrcComp ();
      thePer  = theOpnPipSrc->myPer ();

      workPegSched (theOpn)[thePer] += pegVol;
      }
d484 3
a486 3
void WitPipTarg::loadSupVolPeg (
      WitPairStack <WitPartPipSrc, double> & thePegging,
      WitSchedule  <WitPart,       double> & thePegSched)
d488 2
a489 4
   WitPartPipSrc * thePartPipSrc;
   WitPart *       thePart;
   WitPeriod       thePer;
   double          pegVol;
d491 1
a491 1
   thePegging.reverse ();
d493 8
a500 4
   while (thePegging.pop (thePartPipSrc, pegVol))
      {
      thePart = thePartPipSrc->mySrcComp ();
      thePer  = thePartPipSrc->myPer ();
d502 1
a502 1
      pegVol  = thePegSched (thePart)[thePer];
d504 1
a504 2
      if (pegVol == 0.0)
         continue;
d506 4
a509 1
      supVolPeg_.push (thePartPipSrc, pegVol);
d511 1
a511 1
      thePegSched (thePart)[thePer] = 0.0;
d517 9
a525 8
void WitPipTarg::loadExecVolPeg (
      WitPairStack <WitOpnPipSrc, double> & thePegging,
      WitSchedule  <WitOperation, double> & thePegSched)
   {
   WitOpnPipSrc * theOpnPipSrc;
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         pegVol;
d527 1
a527 1
   thePegging.reverse ();
d529 1
a529 1
   while (thePegging.pop (theOpnPipSrc, pegVol))
d531 2
a532 2
      theOpn = theOpnPipSrc->mySrcComp ();
      thePer = theOpnPipSrc->myPer ();
d534 1
a534 1
      pegVol = thePegSched (theOpn)[thePer];
d539 1
a539 1
      execVolPeg_.push (theOpnPipSrc, pegVol);
d541 1
a541 1
      thePegSched (theOpn)[thePer] = 0.0;
d546 2
d549 2
a550 5
void WitPipTarg::clearPegging ()
   {
   execVolPeg_.clear ();
   supVolPeg_ .clear ();
   }
@


1.17
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d29 1
d119 10
d138 1
d202 1
d213 5
a217 4
   WitDemand *  theDemand;
   WitPart *    thePart;
   WitPeriod    thePer;
   WitPipTarg * thePipTarg;
d233 4
d241 1
d252 2
a253 1
   double          peggedVol;
d256 2
a257 2
   WitPairStack <WitPartPipSrc, double> thePegging (myProblem ());

d266 2
a267 1
         getSupVolPegging (theDemand, shipPer, thePegging);
d269 3
a271 2
         if (thePegging.isEmpty ())
            continue;
d280 3
a282 1
         fprintf (myProblem ()->solnFile (), "\n   Part  Per   SupVol\n");
d284 19
a302 6
         while (thePegging.pop (thePartPipSrc, peggedVol))
            fprintf (myProblem ()->solnFile (),
               "   %-3s   %-3d %8.3f\n",
               thePartPipSrc->mySrcComp ()->partName ().myCstring (),
               thePartPipSrc->myPer (),
               peggedVol);
d318 18
a335 1
      thePegging.revCopyFrom (thePipTarg->pgdSupVols ());
d360 20
d402 2
a403 1
      pgdSupVols_ (theDemand->myProblem ())
d415 1
a415 1
void WitPipTarg::mergeIntoPegging (
d417 1
a417 1
      WitSchedule <WitPart, double> &    workPegSched)
d421 1
a421 1
   oldPegging.takeContents (pgdSupVols_);
d426 19
a444 2
   loadMyPegging (oldPegging, workPegSched);
   loadMyPegging (thePegging, workPegSched);
d451 1
a451 1
      WitSchedule <WitPart, double> &              workPegSched)
d473 25
a497 1
void WitPipTarg::loadMyPegging (
d499 1
a499 1
      WitSchedule <WitPart, double> &    thePegSched)
d513 1
a513 1
      pegVol = thePegSched (thePart)[thePer];
d518 1
a518 1
      pgdSupVols_.push (thePartPipSrc, pegVol);
d526 29
d557 2
a558 1
   pgdSupVols_.clear ();
d562 1
a562 1
// Implementation of class template PipSrc.
d581 1
a581 1
// Explicit instantiation of class template PipSrc.
d585 1
@


1.16
log
@Continued implementation of post-implosion pegging.
@
text
@d281 1
a281 1
      thePegging.revCopyFrom (thePipTarg->myPegging ());
d326 3
a328 3
      myDemand_  (theDemand),
      myShipPer_ (shipPer),
      myPegging_ (theDemand->myProblem ())
d346 1
a346 1
   oldPegging.takeContents (myPegging_);
d402 1
a402 1
      myPegging_.push (thePartPipSrc, pegVol);
d412 1
a412 1
   myPegging_.clear ();
@


1.15
log
@Continued implementation of post-implosion pegging.
@
text
@d29 1
@


1.14
log
@Continued implementation of post-implosion pegging.
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d18 1
a18 1
//    PipSrc
d109 3
a111 3
      WitDemand *                        theDemand,
      WitPeriod                          shipPer,
      WitPairStack <WitPipSrc, double> & thePegging)
d122 5
a126 5
      WitProbAssoc (theProblem),
      myPipTargs_  (theProblem),
      revShipSeq_  (theProblem),
      myPipSrcs_   (),
      pegged_      (false)
d188 1
a188 1
   myPipSrcs_.allocate (myProblem ());
d220 1
a220 1
         delete myPipSrcs_.myPtrAt (thePart, thePer);
d222 1
a222 1
   myPipSrcs_.clear ();
d229 5
a233 5
   WitDemand * theDemand;
   WitPeriod   shipPer;
   WitPipSrc * thePipSrc;
   double      peggedVol;
   WitPart *   thePart;
d235 1
a235 1
   WitPairStack <WitPipSrc, double> thePegging (myProblem ());
d259 1
a259 1
         while (thePegging.pop (thePipSrc, peggedVol))
d262 2
a263 2
               thePipSrc->myPart ()->partName ().myCstring (),
               thePipSrc->myPer (),
d271 3
a273 3
      WitDemand *                        theDemand,
      WitPeriod                          shipPer,
      WitPairStack <WitPipSrc, double> & thePegging)
d287 1
a287 1
WitPipSrc * WitPipMgr::myPipSrcFor (WitPart * thePart, WitPeriod thePer)
d289 1
a289 1
   WitPipSrc * thePipSrc;
d291 1
a291 1
   thePipSrc = myPipSrcs_.myPtrAt (thePart, thePer);
d293 1
a293 1
   if (thePipSrc == NULL)
d295 1
a295 1
      thePipSrc = new WitPipSrc (thePart, thePer);
d297 1
a297 1
      myPipSrcs_.myPtrAt (thePart, thePer) = thePipSrc;
d300 1
a300 1
   return thePipSrc;
d340 1
a340 1
      WitPairStack <WitPipSrc, double> & thePegging,
d343 1
a343 1
   WitPairStack <WitPipSrc, double> oldPegging (myDemand_->myProblem ());
d357 2
a358 2
      const WitPairStack <WitPipSrc, double> & thePegging,
      WitSchedule <WitPart, double> &          workPegSched)
d360 4
a363 4
   WitPipSrc * thePipSrc;
   double      pegVol;
   WitPart *   thePart;
   WitPeriod   thePer;
d365 1
a365 1
   WitPairStItr <WitPipSrc, double> theItr;
d369 1
a369 1
   while (theItr.advance (thePipSrc, pegVol))
d371 2
a372 2
      thePart = thePipSrc->myPart ();
      thePer  = thePipSrc->myPer  ();
d381 1
a381 1
      WitPairStack <WitPipSrc, double> & thePegging,
d384 4
a387 4
   WitPipSrc * thePipSrc;
   WitPart *   thePart;
   WitPeriod   thePer;
   double      pegVol;
d391 1
a391 1
   while (thePegging.pop (thePipSrc, pegVol))
d393 2
a394 2
      thePart = thePipSrc->myPart ();
      thePer  = thePipSrc->myPer  ();
d401 1
a401 1
      myPegging_.push (thePipSrc, pegVol);
d415 1
a415 1
// Implementation of class PipSrc.
d418 2
a419 1
WitPipSrc::WitPipSrc (WitPart * thePart, WitPeriod thePer):
d421 2
a422 2
      myPart_ (thePart),
      myPer_  (thePer)
d428 2
a429 1
WitPipSrc::~WitPipSrc ()
d432 6
@


1.13
log
@Continued implementation of post-implosion pegging.
@
text
@a16 1
//    PipBuilder
d28 1
a28 6
#include <Material.h>
#include <Capacity.h>
#include <Opn.h>
#include <BopEntry.h>
#include <MsgFac.h>
#include <MapIdxI.h>
a233 1
   WitPeriod   supPer;
d313 2
a314 1
   fwdShipSeq.reverse ();
a316 308
   }

//------------------------------------------------------------------------------
// Implementation of class PipBuilder.
//------------------------------------------------------------------------------

WitPipBuilder::WitPipBuilder (WitPipMgr * thePipMgr):

      WitProbAssoc  (thePipMgr->myProblem ()),
      myPipMgr_     (thePipMgr),
      upSupVol_     (myProblem (), 0.0),
      upStockVol_   (myProblem (), 0.0),
      upExecVol_    (myProblem (), 0.0),
      maxUpReqVol_  (0.0),
      curPegging_   (myProblem ()),
      curPegSupVol_ (myProblem (), 0.0)
   {              
   }

//------------------------------------------------------------------------------

WitPipBuilder::~WitPipBuilder ()
   {
   }

//------------------------------------------------------------------------------

void WitPipBuilder::buildPegging (
      WitPairStack <WitPipTarg, double> & theShipSeq)
   {
   WitPipTarg * thePipTarg;
   double       incShipVol;
   WitDemand *  theDemand;
   WitPeriod    shipPer;

   WitSchedule <WitPart, double> workPegSched (myProblem (), 0.0);
      //
      // Working Schedule for PipTarg::mergeIntoPegging.

   myMsgFac () ("pipMsg");

   setUpPegging ();

   while (theShipSeq.pop (thePipTarg, incShipVol))
      {
      theDemand = thePipTarg->myDemand ();

      shipPer   = thePipTarg->myShipPer ();

      peg (theDemand, shipPer, incShipVol);

      thePipTarg->mergeIntoPegging (curPegging_, workPegSched);
      }

   if (DEVELOPMENT)
      myMsgFac () ("maxUpReqVolMsg", maxUpReqVol_);
   }

//------------------------------------------------------------------------------

void WitPipBuilder::setUpPegging ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;

   checkRestrictions ();

   forEachPart (thePart, myProblem ())
      copyInto (upSupVol_ (thePart), thePart->supplyVol ());

   forEachMaterial (theMat, myProblem ())
      copyInto (upStockVol_ (theMat), theMat->stockVol ());

   forEachOperation (theOpn, myProblem ())
      theOpn->execVol ().copyIntoTVec (upExecVol_ (theOpn));
   }

//------------------------------------------------------------------------------

void WitPipBuilder::checkRestrictions ()
   {
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;
   WitPart *      thePart;

   if (myCompMgr ()->nBomEntries () > 0)
      myMsgFac () ("nyiForPIPSmsg", "BOM entries");

   forEachOperation (theOpn, myProblem ())
      if (theOpn->bop ().nElements () > 1)
         myMsgFac () ("nyiForPIPSmsg", "multiple BOP entries for an operation");

   forEachPart (thePart, myProblem ())
      if (thePart->producingBopEntries ().nElements () > 1)
         myMsgFac () ("nyiForPIPSmsg", "multiple BOP entries for a part");

   forEachBopEntry (theBopEnt, myProblem ())
      {
      if (not theBopEnt->expAllowed ())
         myMsgFac () ("nyiForPIPSmsg", "unexplodeable BOP entries");

      if (not (theBopEnt->offset () == 0.0))
         myMsgFac () ("nyiForPIPSmsg", "BOP entry offsets");
      }

   if (myCompMgr ()->nOperations () > 0)
      if (myCompMgr ()->nMaterials () > 0)
         myMsgFac () ("nyiForPIPSmsg", "both operations and materials");
   }

//------------------------------------------------------------------------------

void WitPipBuilder::peg (
      WitDemand * theDemand, 
      WitPeriod   shipPer, 
      double      incShipVol)
   {
   WitPart *     thePart;
   WitPeriod     reqPer;
   double        netReqVol;

   witAssert (incShipVol >= NET_TOL);

   thePart   = theDemand->demandedPart ();

   reqPer    = shipPer;

   netReqVol = incShipVol;

   if (thePart->isaCapacity ())
      pegCapacity (thePart->myCap (), reqPer, netReqVol);
   else
      pegMaterial (thePart->myMat (), reqPer, netReqVol);

   setToMax (maxUpReqVol_, netReqVol);
   }

//------------------------------------------------------------------------------

void WitPipBuilder::pegCapacity (
      WitCapacity * theCap,
      WitPeriod     reqPer,
      double &      netReqVol)
   {
   pegSupVol (theCap, reqPer, netReqVol);

   if (netReqVol >= NET_TOL)
      if (theCap->prodVol ()[reqPer] >= NET_TOL)
         pegByExp (theCap, reqPer, netReqVol);
   }

//------------------------------------------------------------------------------

void WitPipBuilder::pegMaterial (
      WitMaterial * theMat,
      WitPeriod     reqPer,
      double &      netReqVol)
   {
   double    unstockedVol;
   double    upStock;
   WitPeriod startPer;
   WitPeriod supPer;
   double    pegVol;

   witAssert (netReqVol >= NET_TOL);

   unstockedVol = 0.0;

   startPer     = reqPer;

   for (supPer = reqPer; supPer >= 0; supPer --)
      {
      if (supPer < reqPer)
         {
         if (theMat->mandEC ()[supPer])
            break;

         upStock = upStockVol_ (theMat)[supPer];

         if (upStock < netReqVol)
            {
            unstockedVol += netReqVol - upStock;

            netReqVol     = upStock;

            if (netReqVol < NET_TOL)
               break;
            }
         }

      pegVol = pegSupVol (theMat, supPer, netReqVol);

      if (pegVol > 0.0)
         {
         startPer = supPer;

         if (supPer < reqPer)
            curPegSupVol_[supPer] = pegVol;

         if (netReqVol < NET_TOL)
            break;
         }
      }

   netReqVol += unstockedVol;

   pegStockVols (theMat, startPer, reqPer);
   }

//------------------------------------------------------------------------------

double WitPipBuilder::pegSupVol (
      WitPart * thePart,
      WitPeriod supPer,
      double &  netReqVol)
   {
   double      upVol;
   double      pegVol;
   WitPipSrc * thePipSrc;

   witAssert (netReqVol >= NET_TOL);

   upVol = upSupVol_ (thePart)[supPer];

   if (upVol < NET_TOL)
      return 0.0;

   pegVol = min (netReqVol, upVol);
   
   upSupVol_ (thePart)[supPer] -= pegVol;

   netReqVol                   -= pegVol;

   thePipSrc = myPipMgr_->myPipSrcFor (thePart, supPer);

   curPegging_.push (thePipSrc, pegVol);

   return pegVol;
   }

//------------------------------------------------------------------------------

void WitPipBuilder::pegStockVols (
      WitMaterial * theMat,
      WitPeriod     startPer,
      WitPeriod     reqPer)
   {
   double    totPegVol;
   WitPeriod supPer;

   totPegVol = 0.0;

   for (supPer = startPer; supPer < reqPer; supPer ++)
      {
      totPegVol += curPegSupVol_[supPer];

      curPegSupVol_[supPer] = 0.0;

      upStockVol_ (theMat)[supPer] -= totPegVol;
      }
   }

//------------------------------------------------------------------------------

void WitPipBuilder::pegByExp (
      WitPart * thePart,
      WitPeriod expPer,
      double &  netReqVol)
   {
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         theProdRate;
   double         reqExecVol;

   witAssert (netReqVol >= NET_TOL);

   witAssert (thePart->prodVol ()[expPer] >= NET_TOL);

   if (not thePart->explodeable (expPer))
      return;

   theBopEnt  = thePart->expBopEntry (expPer);

   theOpn     = theBopEnt->myOperation ();

   execPer    = expPer;

   if (upExecVol_ (theOpn)[execPer] < NET_TOL)
      return;

   theProdRate = theBopEnt->effProdRate ()[execPer];

   reqExecVol  = netReqVol / theProdRate;

   if (reqExecVol <= upExecVol_ (theOpn)[execPer])
      {
      netReqVol = 0.0;

      upExecVol_ (theOpn)[execPer] -= reqExecVol;
      }
   else
      {
      netReqVol = upExecVol_ (theOpn)[execPer] * theProdRate;

      upExecVol_ (theOpn)[execPer] = 0.0;
      }
@


1.12
log
@Continued implementation of post-implosion pegging.
@
text
@d31 2
d335 2
a336 1
      maxResReqVol_ (0.0),
d378 1
a378 1
      myMsgFac () ("maxResReqVolMsg", maxResReqVol_);
d385 3
a387 2
   WitPart *     thePart;
   WitMaterial * theMat;
d396 3
d405 23
a427 1
   WitMaterial * theMat;
d430 2
a431 5
      myMsgFac () ("nyiForPIPSmsg", "operations");

   forEachMaterial (theMat, myProblem ())
      if (not (theMat->mandEC () == false))
         myMsgFac () ("nyiForPIPSmsg", "Mand ECs");
d454 1
a454 1
      pegSupVol   (thePart,           reqPer, netReqVol);
d458 15
a472 1
   setToMax (maxResReqVol_, netReqVol);
d583 47
@


1.11
log
@Continued implementation of post-implosion pegging.
@
text
@d30 1
d332 1
d334 2
a335 1
      curPegging_   (myProblem ())
a336 1
   checkRestrictions ();
a346 14
void WitPipBuilder::checkRestrictions ()
   {
   WitMaterial * theMat;

   if (myCompMgr ()->nOperations () > 0)
      myMsgFac () ("nyiForPIPSmsg", "operations");

   forEachMaterial (theMat, myProblem ())
      if (not (theMat->mandEC () == false))
         myMsgFac () ("nyiForPIPSmsg", "Mand ECs");
   }

//------------------------------------------------------------------------------

a349 1
   WitPart *    thePart;
d361 1
a361 2
   forEachPart (thePart, myProblem ())
      copyInto (upSupVol_ (thePart), thePart->supplyVol ());
d380 30
d427 4
a430 1
   pegPart (thePart, reqPer, netReqVol);
d437 8
a444 5
void WitPipBuilder::pegPart (
      WitPart * thePart,
      WitPeriod reqPer,
      double &  netReqVol)
   {
a445 1
   double    upVol;
d448 6
d457 2
a458 1
         if (not thePart->canStock (supPer))
d461 7
a467 1
      upVol = upSupVol_ (thePart)[supPer];
d469 4
a472 2
      if (upVol < NET_TOL)
         continue;
d474 1
a474 3
      pegVol = min (netReqVol, upVol);
      
      pegSupVol (thePart, supPer, pegVol);
d476 3
a478 1
      netReqVol -= pegVol;
d480 6
a485 2
      if (netReqVol < NET_TOL)
         break;
d487 4
d495 1
a495 1
void WitPipBuilder::pegSupVol (
d498 1
a498 1
      double    pegVol)
d500 2
d504 3
a506 1
   witAssert (pegVol >= NET_TOL);
d508 5
d515 1
a515 1
   witAssert (upSupVol_ (thePart)[supPer] >= 0.0);
d520 24
@


1.10
log
@Continued implementation of post-implosion pegging.
@
text
@d151 1
a151 1
   witAssert (incShipVol > NET_TOL);
a401 1
   WitMaterial * theMat;
d411 1
a411 6
   theMat    = thePart->myMat ();

   if (theMat != NULL)
      pegMaterial (theMat,  reqPer, netReqVol);
   else
      pegCapacity (thePart, reqPer, netReqVol);
d418 4
a421 4
void WitPipBuilder::pegMaterial (
      WitMaterial * theMat,
      WitPeriod     reqPer,
      double &      netReqVol)
d429 5
a433 1
      upVol = upSupVol_ (theMat)[supPer];
d440 1
a440 1
      pegSupVol (theMat, supPer, pegVol);
a445 24
      }
   }

//------------------------------------------------------------------------------

void WitPipBuilder::pegCapacity (
      WitPart * thePart,
      WitPeriod reqPer,
      double &  netReqVol)
   {
   WitPeriod supPer;
   double    pegVol;

   witAssert (thePart->myMat () == NULL);

   supPer = reqPer;

   pegVol = min (netReqVol, upSupVol_ (thePart)[supPer]);

   if (pegVol >= NET_TOL)
      {
      pegSupVol (thePart, supPer, pegVol);

      netReqVol -= pegVol;
@


1.9
log
@Continued implementation of post-implosion pegging.
@
text
@d523 1
a524 1
   loadPegSched  (oldPegging, workPegSched);
d526 1
a527 3
   loadMyPegging (oldPegging, workPegSched);

   myPegging_.reverse ();
d564 2
@


1.8
log
@Continued implementation of post-implosion pegging.
@
text
@d284 1
a284 1
      thePegging.revCopyFrom (thePipTarg->supVolPegging ());
d332 1
a332 2
      pegSupVol_    (myProblem (), 0.0),
      curPipSrcs_   (myProblem ())
d368 4
a378 2
      thePipTarg->extractPegging (pegSupVol_, curPipSrcs_);

d385 1
a385 1
      thePipTarg->loadPegging    (pegSupVol_, curPipSrcs_);
d492 1
a492 4
   if (pegSupVol_ (thePart)[supPer] == 0.0)
      curPipSrcs_.push (thePipSrc);

   pegSupVol_ (thePart)[supPer] += pegVol;
d501 3
a503 3
      myDemand_      (theDemand),
      myShipPer_     (shipPer),
      supVolPegging_ (theDemand->myProblem ())
d515 22
a536 3
void WitPipTarg::extractPegging (
      WitSchedule <WitPart, double> & pegSupVolSched,
      WitObjStack <WitPipSrc> &       thePipSrcs)
d541 3
a543 1
   WitPeriod   supPer;
d545 1
a545 1
   witAssert (thePipSrcs.isEmpty ());
d547 1
a547 1
   while (supVolPegging_.pop (thePipSrc, pegVol))
d550 1
a550 1
      supPer  = thePipSrc->myPer  ();
d552 1
a552 5
      witAssert (pegSupVolSched (thePart)[supPer] == 0.0);

      pegSupVolSched (thePart)[supPer] = pegVol;

      thePipSrcs.push (thePipSrc);
d558 3
a560 3
void WitPipTarg::loadPegging (
      WitSchedule <WitPart, double> & pegSupVolSched,
      WitObjStack <WitPipSrc> &       thePipSrcs)
d564 1
a564 1
   WitPeriod   supPer;
d567 1
a567 3
   witAssert (supVolPegging_.isEmpty ());

   while (thePipSrcs.pop (thePipSrc))
d570 1
a570 1
      supPer  = thePipSrc->myPer  ();
d572 1
a572 1
      pegVol  = pegSupVolSched (thePart)[supPer];
d574 2
a575 1
      witAssert (pegVol > 0.0);
d577 1
a577 1
      supVolPegging_.push (thePipSrc, pegVol);
d579 1
a579 1
      pegSupVolSched (thePart)[supPer] = 0.0;
d587 1
@


1.7
log
@Continued implementation of post-implosion pegging.
@
text
@d29 1
a29 1
#include <Part.h>
d335 1
d346 14
a370 6
   if (myCompMgr ()->nOperations () > 0)
      myMsgFac () ("nyiForPIPSmsg", "operations");

   if (myCompMgr ()->nMaterials () > 0)
      myMsgFac () ("nyiForPIPSmsg", "material parts");

d398 30
a427 1
   WitPart * thePart;
d429 1
a429 1
   double    netReqVol;
d432 27
a458 1
   thePart   = theDemand->demandedPart ();
d460 1
a460 1
   supPer    = shipPer;
d462 1
a462 1
   netReqVol = incShipVol;
d464 1
a464 1
   pegVol    = min (netReqVol, upSupVol_ (thePart)[supPer]);
a471 2

   setToMax (maxResReqVol_, netReqVol);
@


1.6
log
@Continued implementation of post-implosion pegging.
@
text
@d218 1
a218 1
            thePipTarg->supVolPegging ().clear ();
a331 1
      curPipTarg_   (NULL),
a348 1
   WitPeriod    thePer;
d351 2
d367 1
a367 1
      prePeg (thePipTarg);
d369 1
a369 1
      peg (incShipVol);
d371 5
a375 1
      postPeg ();
d384 9
a392 71
void WitPipBuilder::prePeg (WitPipTarg * thePipTarg)
   {
   WitPipSrc * thePipSrc;
   double      pegVol;
   WitPart *   thePart;
   WitPeriod   supPer;

   witAssert (thePipTarg  != NULL);
   witAssert (curPipTarg_ == NULL);
   witAssert (curPipSrcs_.isEmpty ());

   curPipTarg_ = thePipTarg;

   while (curPipTarg_->supVolPegging ().pop (thePipSrc, pegVol))
      {
      thePart = thePipSrc->myPart ();
      supPer  = thePipSrc->myPer  ();

      witAssert (pegSupVol_ (thePart)[supPer] == 0.0);

      pegSupVol_ (thePart)[supPer] = pegVol;

      curPipSrcs_.push (thePipSrc);
      }
   }

//------------------------------------------------------------------------------

void WitPipBuilder::postPeg ()
   {
   WitPipSrc * thePipSrc;
   WitPart *   thePart;
   WitPeriod   supPer;
   double      pegVol;

   witAssert (curPipTarg_ != NULL);
   witAssert (curPipTarg_->supVolPegging ().isEmpty ());

   while (curPipSrcs_.pop (thePipSrc))
      {
      thePart = thePipSrc->myPart ();
      supPer  = thePipSrc->myPer  ();

      pegVol  = pegSupVol_ (thePart)[supPer];

      witAssert (pegVol > 0.0);

      curPipTarg_->supVolPegging ().push (thePipSrc, pegVol);

      pegSupVol_ (thePart)[supPer] = 0.0;
      }

   curPipTarg_ = NULL;
   }

//------------------------------------------------------------------------------

void WitPipBuilder::peg (double incShipVol)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   WitPart *   thePart;
   WitPeriod   supPer;
   double      netReqVol;
   double      pegVol;

   witAssert (curPipTarg_ != NULL);

   theDemand = curPipTarg_->myDemand ();

   shipPer   = curPipTarg_->myShipPer ();
d450 60
@


1.5
log
@Continued implementation of post-implosion pegging.
@
text
@a160 3
   else
      myMsgFac () ("nyiForPIPSmsg",
         "multiple shipment increments for the same target");
d218 1
a218 1
            thePipTarg->clearPegging ();
d332 3
a334 1
      curPipTarg_   (NULL)
d366 7
a372 1
      peg (thePipTarg, incShipVol);
d380 58
a437 1
void WitPipBuilder::peg (WitPipTarg * thePipTarg, double incShipVol)
d446 1
a446 1
   curPipTarg_ = thePipTarg;
d448 1
a448 1
   theDemand   = thePipTarg->myDemand ();
d450 1
a450 1
   shipPer     = thePipTarg->myShipPer ();
d452 1
a452 1
   thePart     = theDemand->demandedPart ();
d454 1
a454 1
   supPer      = shipPer;
d456 1
a456 1
   netReqVol   = incShipVol;
d458 1
a458 1
   pegVol      = min (netReqVol, upSupVol_ (thePart)[supPer]);
d460 1
a460 1
   if (pegVol > NET_TOL)
a467 2

   curPipTarg_ = NULL;
d474 1
a474 1
      WitPeriod thePer,
d479 3
a481 1
   upSupVol_ (thePart)[thePer] -= pegVol;
d483 1
a483 1
   witAssert (upSupVol_ (thePart)[thePer] >= 0.0);
d485 1
a485 1
   thePipSrc = myPipMgr_->myPipSrcFor (thePart, thePer);
d487 4
a490 1
   curPipTarg_->peg (thePipSrc, pegVol);
a508 17
   }

//------------------------------------------------------------------------------

void WitPipTarg::peg (WitPipSrc * thePipSrc, double pegVol)
   {
   witAssert (thePipSrc != NULL);
   witAssert (pegVol > 0.0);

   supVolPegging_.push (thePipSrc, pegVol);
   }

//------------------------------------------------------------------------------

void WitPipTarg::clearPegging ()
   {
   supVolPegging_.clear ();
@


1.4
log
@Continued implementation of post-implosion pegging.
@
text
@a31 1
#include <ScheduleI.h>
@


1.3
log
@Continued implementation of post-implosion pegging.
@
text
@d332 5
a336 4
      WitProbAssoc (thePipMgr->myProblem ()),
      myPipMgr_    (thePipMgr),
      upSupVol_    (myProblem (), 0.0),
      curPipTarg_  (NULL)
d369 3
d405 2
@


1.2
log
@Continued implementation of post-implosion pegging.
@
text
@d104 17
d230 61
@


1.1
log
@Continued implementation of post-implosion pegging.
@
text
@d17 1
d19 1
a19 1
//    PipBuilder
d22 2
a24 1
#include <PipTarg.h>
d29 1
d32 1
d84 1
a84 1
      double      incVol)
d86 1
a86 1
   myPipMgr ()->recIncShipVol (theDemand, shipPer, incVol);
d111 2
a112 2
      eachPipTarg_ (theProblem),
      myShipIncs_  (theProblem),
d131 1
a131 1
      double      incVol)
d135 1
a135 1
   witAssert (incVol > NET_TOL);
d137 1
a137 1
   thePipTarg = eachPipTarg_.myPtrAt (theDemand, shipPer);
d143 1
a143 3
      myPipTargs_.push (thePipTarg);

      eachPipTarg_.myPtrAt (theDemand, shipPer) = thePipTarg;
d145 3
d149 1
a149 1
   myShipIncs_.push (thePipTarg, incVol);
a155 1
   WitPipTarg * thePipTarg;
d158 1
d160 1
a160 1
   myShipIncs_.clear ();
d162 5
a166 6
   while (myPipTargs_.pop (thePipTarg))
      {
      theDemand = thePipTarg->myDemand ();
      shipPer   = thePipTarg->myShipPer ();

      eachPipTarg_.myPtrAt (theDemand,shipPer) = NULL;
d168 2
a169 2
      delete thePipTarg;
      }
d178 2
d189 5
d198 33
d239 104
a342 1
   thePipBuilder.buildPegging ();
d351 3
a353 2
      myDemand_  (theDemand),
      myShipPer_ (shipPer)
d364 9
a372 1
// Implementation of class PipBuilder.
d375 3
a377 5
WitPipBuilder::WitPipBuilder (WitPipMgr * thePipMgr):

      WitProbAssoc (thePipMgr->myProblem ()),
      myPipMgr_    (thePipMgr)
   {              
d381 2
d384 4
a387 1
WitPipBuilder::~WitPipBuilder ()
d393 1
a393 1
void WitPipBuilder::buildPegging ()
a394 1
   myMsgFac () ("pipMsg");
@


head	1.47;
access;
symbols
	sce_5_01_20080919:1.41
	latest_sce_4_20_20060523:1.39.0.2
	sce_4_20_20060523:1.39
	latest_sce4_20_OSL:1.38.0.2
	sce_4_20_OSL:1.38
	sce_410_withVa:1.35
	sce_4_05_20040511:1.31
	sce_4_00_20040201:1.23
	nextGenBranch:1.15.0.2
	nextGenRoot:1.15
	sce_3_30_20030627:1.14
	EndRw-branch:1.10.0.4
	Root-of-EndRw:1.10
	rwToStl:1.10.0.2
	latest_sce_3_10_20010924:1.7.0.2
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.6.0.4
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2011.09.28.23.50.38;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2011.09.24.00.28.53;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.08.30.20.18.21;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.02.18.18.50.55;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.28.20.10.12;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2009.06.09.18.13.39;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.25.19.37.57;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2006.10.11.16.19.12;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.02.17.34.15;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.15.18.57.52;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.14.21.54.45;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.13.19.31.57;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.06.21.30.28;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.06.20.43.27;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.06.19.47.58;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.22.20.38.59;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.05.15.43.58;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.06.15.42.17;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.12.15.09.24;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.20.22.46.03;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.20.16.38.01;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.20.15.37.36;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.12.20.47.43;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.11.18.37.27;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.08.19.27.44;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.04.16.20.41;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.02.16.39.32;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.01.22.38.13;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.01.21.05.06;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.06.23.31.50;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.08.22.57.26;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.23.19.13.25;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.16.16.34.32;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.02.23.40.53;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.02.22.18.54;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.24.18.26.09;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.18.14.02.47;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.29.23.47.12;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.11.20.47.38;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.22.23.11.50;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.24.19.55.28;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.19.22.35.35;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.16.57.05;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.29.21.55.59;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.31;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.31;	author wit;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef UtilH
#define UtilH

//------------------------------------------------------------------------------
// Header file: "Util.h"
//
// Contains:
//    The declaration various utility functions.
//    Some macros that refer to these functions.
//------------------------------------------------------------------------------

#include <typedefs.h>

namespace WitNonClass
   {
   //---------------------------------------------------------------------------
   // Max/Min function templates.
   //---------------------------------------------------------------------------

   template <typename Number> 
      inline Number max (Number num1, Number num2);
         //
         // Returns the maximum of num1 and num2.

   template <typename Number> 
      inline Number min (Number num1, Number num2);
         //
         // Returns the minimum of num1 and num2.

   template <typename Number> 
      inline void setToMax (Number & num1, Number num2);
         //
         // Updates num1 to be the max of num1 and num2.

   template <typename Number> 
      inline void setToMin (Number & num1, Number num2);
         //
         // Updates num1 to be the min of num1 and num2.

   //---------------------------------------------------------------------------
   // Explicit conversions between float and double.
   // Conversions from the wrong type are disallowed by declaring functions here
   // that are not implemented.
   //---------------------------------------------------------------------------

   inline double dblFromFlt (float theFloat)
      {
      return static_cast <double> (theFloat);
      }

   inline float fltFromDbl (double theDouble)
      {
      return static_cast <float> (theDouble);
      }

   double dblFromFlt (double);
   float  fltFromDbl (float);
      //
      // Not implemented.

   //---------------------------------------------------------------------------

   bool equalCstrings (const char * lhs, const char * rhs);
      //
      // String equality.

   inline double positivePart (double theVal)
      {
      return max (0.0, theVal);
      }

   void net (double & theVal1, double & theVal2);
      //
      // Subtracts min (theVal1, theVal2) from theVal1 and from theVal2.

   int sign (int theVal);
      //
      // Returns 1, 0, or -1.

   int sign (double theVal);
      //
      // Returns 1, 0, or -1.

   void assertFunc (
         bool         assertion,
         const char * srcFileName,
         int          lineNo,
         const char * assertionString);
      //
      // Issues a fatal error, if assertion is false.
      // Invoked thru witAssert macro.

   inline void doNothing ()
      {
      }

   void nonMsgAssertFunc (
         bool         assertion,
         const char * srcFileName,
         int          lineNo,
         const char * assertionString);
      //
      // If assertion is false, issues a fatal error without using the
      // MsgFacility.
      // Invoked thru nonMsgAssert macro.

   void forbidNullArg (
         const void * theArg,
         const char * argName,
         const char * funcName);
      //
      // theArg:   A pointer that was passed to WIT as an argument to an
      //           API function.
      // argName:  The name of the argument
      // funcName: The name of the API function.
      // If theArg is NULL, this function prints an error message to
      // stderr and exists the process.
      // This function should only be used when there is no WitRun
      // available, since it does not use the message facility.

   bool isNullCstring (const char * theCstring);
      //
      // Returns true iff theCstring is the null string.

   double percentToFrac (int thePercent);
      //
      // Returns thePercent, converted to a fraction.

   int fracToPercent (double theFrac);
      //
      // Returns theFrac, converted to a percent.

   void startNonMsgSevereError ();
      //
      // Starts issuing a severe error, without the Msg Facility.

   void finishNonMsgSevereError ();
      //
      // Finishes issuing a severe error, without the Msg Facility.

   void issueNonMsgFatalError (const char * funcName);
      //
      // Issues a fatal error message without the Msg Facility.
      // funcName is the name of the WIT function in which the error occurred.

   void exitWitNonMsg (int theRc);
      //
      // Exits WIT without using the Msg Facility.
      // Uses theRc as the return code.
   };

//------------------------------------------------------------------------------
// Implementation of inlines.
//------------------------------------------------------------------------------

template <typename Number> 
      inline Number WitNonClass::max (Number num1, Number num2)
   {
   return
      (num1 > num2)?
         num1:
         num2;
   }

//------------------------------------------------------------------------------

template <typename Number> 
      inline Number WitNonClass::min (Number num1, Number num2)
   {
   return
      (num1 < num2)?
         num1:
         num2;
   }

//------------------------------------------------------------------------------

template <typename Number> 
      inline void WitNonClass::setToMax (Number & num1, Number num2)
   {
   if (num2 > num1)
      num1 = num2;
   }

//------------------------------------------------------------------------------

template <typename Number> 
      inline void WitNonClass::setToMin (Number & num1, Number num2)
   {
   if (num2 < num1)
      num1 = num2;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of max/min function templates.
// (Needed on Windows.)
//------------------------------------------------------------------------------

template inline int    WitNonClass::max      <int>    (int,      int);
template inline double WitNonClass::max      <double> (double,   double);

template inline int    WitNonClass::min      <int>    (int,      int);
template inline double WitNonClass::min      <double> (double,   double);

template inline void   WitNonClass::setToMax <int>    (int    &, int);
template inline void   WitNonClass::setToMax <double> (double &, double);

template inline void   WitNonClass::setToMin <int>    (int    &, int);
template inline void   WitNonClass::setToMin <double> (double &, double);

//------------------------------------------------------------------------------
// witAssert
//
// Issues a fatal error, if assertion is false.
// No-op, if not in DEBUG mode.
//------------------------------------------------------------------------------

#ifdef DEBUG

#define witAssert(assertion)                                                   \
                                                                               \
   assertFunc ((assertion), __FILE__, __LINE__, #assertion)                    \

#else

#define witAssert(assertion)                                                   \
                                                                               \
   doNothing ()                                                                \

#endif

//------------------------------------------------------------------------------
// stronglyAssert
//
// Issues a fatal error indicating the source file name and line #, if assertion
// is false.
//------------------------------------------------------------------------------

#define stronglyAssert(assertion)                                              \
                                                                               \
   assertFunc ((assertion), __FILE__, __LINE__, #assertion)                    \

//------------------------------------------------------------------------------
// nonMsgAssert
//
// Issues a non-message fatal error, if assertion is false.
// No-op, if not in DEBUG mode.
//------------------------------------------------------------------------------

#ifdef DEBUG

#define nonMsgAssert(assertion)                                                \
                                                                               \
   nonMsgAssertFunc ((assertion), __FILE__, __LINE__, #assertion)              \

#else

#define nonMsgAssert(assertion)                                                \
                                                                               \
   doNothing ()                                                                \

#endif

#endif
@


1.46
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.45
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d24 136
a159 136
{
//---------------------------------------------------------------------------
// Max/Min function templates.
//---------------------------------------------------------------------------

template <typename Number>
inline Number max (Number num1, Number num2);
//
// Returns the maximum of num1 and num2.

template <typename Number>
inline Number min (Number num1, Number num2);
//
// Returns the minimum of num1 and num2.

template <typename Number>
inline void setToMax (Number & num1, Number num2);
//
// Updates num1 to be the max of num1 and num2.

template <typename Number>
inline void setToMin (Number & num1, Number num2);
//
// Updates num1 to be the min of num1 and num2.

//---------------------------------------------------------------------------
// Explicit conversions between float and double.
// Conversions from the wrong type are disallowed by declaring functions here
// that are not implemented.
//---------------------------------------------------------------------------

inline double dblFromFlt (float theFloat)
{
return static_cast <double> (theFloat);
}

inline float fltFromDbl (double theDouble)
{
return static_cast <float> (theDouble);
}

double dblFromFlt (double);
float  fltFromDbl (float);
//
// Not implemented.

//---------------------------------------------------------------------------

bool equalCstrings (const char * lhs, const char * rhs);
//
// String equality.

inline double positivePart (double theVal)
{
return max (0.0, theVal);
}

void net (double & theVal1, double & theVal2);
//
// Subtracts min (theVal1, theVal2) from theVal1 and from theVal2.

int sign (int theVal);
//
// Returns 1, 0, or -1.

int sign (double theVal);
//
// Returns 1, 0, or -1.

void assertFunc (
bool         assertion,
const char * srcFileName,
int          lineNo,
const char * assertionString);
//
// Issues a fatal error, if assertion is false.
// Invoked thru witAssert macro.

inline void doNothing ()
{
}

void nonMsgAssertFunc (
bool         assertion,
const char * srcFileName,
int          lineNo,
const char * assertionString);
//
// If assertion is false, issues a fatal error without using the
// MsgFacility.
// Invoked thru nonMsgAssert macro.

void forbidNullArg (
const void * theArg,
const char * argName,
const char * funcName);
//
// theArg:   A pointer that was passed to WIT as an argument to an
//           API function.
// argName:  The name of the argument
// funcName: The name of the API function.
// If theArg is NULL, this function prints an error message to
// stderr and exists the process.
// This function should only be used when there is no WitRun
// available, since it does not use the message facility.

bool isNullCstring (const char * theCstring);
//
// Returns true iff theCstring is the null string.

double percentToFrac (int thePercent);
//
// Returns thePercent, converted to a fraction.

int fracToPercent (double theFrac);
//
// Returns theFrac, converted to a percent.

void startNonMsgSevereError ();
//
// Starts issuing a severe error, without the Msg Facility.

void finishNonMsgSevereError ();
//
// Finishes issuing a severe error, without the Msg Facility.

void issueNonMsgFatalError (const char * funcName);
//
// Issues a fatal error message without the Msg Facility.
// funcName is the name of the WIT function in which the error occurred.

void exitWitNonMsg (int theRc);
//
// Exits WIT without using the Msg Facility.
// Uses theRc as the return code.
};
d165 8
a172 8
template <typename Number>
inline Number WitNonClass::max (Number num1, Number num2)
{
return
(num1 > num2)?
num1:
num2;
}
d176 8
a183 8
template <typename Number>
inline Number WitNonClass::min (Number num1, Number num2)
{
return
(num1 < num2)?
num1:
num2;
}
d187 6
a192 6
template <typename Number>
inline void WitNonClass::setToMax (Number & num1, Number num2)
{
if (num2 > num1)
num1 = num2;
}
d196 6
a201 6
template <typename Number>
inline void WitNonClass::setToMin (Number & num1, Number num2)
{
if (num2 < num1)
num1 = num2;
}
d230 2
a231 2
\
assertFunc ((assertion), __FILE__, __LINE__, #assertion)                    \
d236 2
a237 2
\
doNothing ()                                                                \
d249 2
a250 2
\
assertFunc ((assertion), __FILE__, __LINE__, #assertion)                    \
d262 2
a263 2
\
nonMsgAssertFunc ((assertion), __FILE__, __LINE__, #assertion)              \
d268 2
a269 2
\
doNothing ()                                                                \
@


1.44
log
@Fixed a bug in the assertion code.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d24 136
a159 136
   {
   //---------------------------------------------------------------------------
   // Max/Min function templates.
   //---------------------------------------------------------------------------

   template <typename Number> 
      inline Number max (Number num1, Number num2);
         //
         // Returns the maximum of num1 and num2.

   template <typename Number> 
      inline Number min (Number num1, Number num2);
         //
         // Returns the minimum of num1 and num2.

   template <typename Number> 
      inline void setToMax (Number & num1, Number num2);
         //
         // Updates num1 to be the max of num1 and num2.

   template <typename Number> 
      inline void setToMin (Number & num1, Number num2);
         //
         // Updates num1 to be the min of num1 and num2.

   //---------------------------------------------------------------------------
   // Explicit conversions between float and double.
   // Conversions from the wrong type are disallowed by declaring functions here
   // that are not implemented.
   //---------------------------------------------------------------------------

   inline double dblFromFlt (float theFloat)
      {
      return static_cast <double> (theFloat);
      }

   inline float fltFromDbl (double theDouble)
      {
      return static_cast <float> (theDouble);
      }

   double dblFromFlt (double);
   float  fltFromDbl (float);
      //
      // Not implemented.

   //---------------------------------------------------------------------------

   bool equalCstrings (const char * lhs, const char * rhs);
      //
      // String equality.

   inline double positivePart (double theVal)
      {
      return max (0.0, theVal);
      }

   void net (double & theVal1, double & theVal2);
      //
      // Subtracts min (theVal1, theVal2) from theVal1 and from theVal2.

   int sign (int theVal);
      //
      // Returns 1, 0, or -1.

   int sign (double theVal);
      //
      // Returns 1, 0, or -1.

   void assertFunc (
         bool         assertion,
         const char * srcFileName,
         int          lineNo,
         const char * assertionString);
      //
      // Issues a fatal error, if assertion is false.
      // Invoked thru witAssert macro.

   inline void doNothing ()
      {
      }

   void nonMsgAssertFunc (
         bool         assertion,
         const char * srcFileName,
         int          lineNo,
         const char * assertionString);
      //
      // If assertion is false, issues a fatal error without using the
      // MsgFacility.
      // Invoked thru nonMsgAssert macro.

   void forbidNullArg (
         const void * theArg,
         const char * argName,
         const char * funcName);
      //
      // theArg:   A pointer that was passed to WIT as an argument to an
      //           API function.
      // argName:  The name of the argument
      // funcName: The name of the API function.
      // If theArg is NULL, this function prints an error message to
      // stderr and exists the process.
      // This function should only be used when there is no WitRun
      // available, since it does not use the message facility.

   bool isNullCstring (const char * theCstring);
      //
      // Returns true iff theCstring is the null string.

   double percentToFrac (int thePercent);
      //
      // Returns thePercent, converted to a fraction.

   int fracToPercent (double theFrac);
      //
      // Returns theFrac, converted to a percent.

   void startNonMsgSevereError ();
      //
      // Starts issuing a severe error, without the Msg Facility.

   void finishNonMsgSevereError ();
      //
      // Finishes issuing a severe error, without the Msg Facility.

   void issueNonMsgFatalError (const char * funcName);
      //
      // Issues a fatal error message without the Msg Facility.
      // funcName is the name of the WIT function in which the error occurred.

   void exitWitNonMsg (int theRc);
      //
      // Exits WIT without using the Msg Facility.
      // Uses theRc as the return code.
   };
d165 8
a172 8
template <typename Number> 
      inline Number WitNonClass::max (Number num1, Number num2)
   {
   return
      (num1 > num2)?
         num1:
         num2;
   }
d176 8
a183 8
template <typename Number> 
      inline Number WitNonClass::min (Number num1, Number num2)
   {
   return
      (num1 < num2)?
         num1:
         num2;
   }
d187 6
a192 6
template <typename Number> 
      inline void WitNonClass::setToMax (Number & num1, Number num2)
   {
   if (num2 > num1)
      num1 = num2;
   }
d196 6
a201 6
template <typename Number> 
      inline void WitNonClass::setToMin (Number & num1, Number num2)
   {
   if (num2 < num1)
      num1 = num2;
   }
d230 2
a231 2
                                                                               \
   assertFunc ((assertion), __FILE__, __LINE__, #assertion)                    \
d236 2
a237 2
                                                                               \
   doNothing ()                                                                \
d249 2
a250 2
                                                                               \
   assertFunc ((assertion), __FILE__, __LINE__, #assertion)                    \
d262 2
a263 2
                                                                               \
   nonMsgAssertFunc ((assertion), __FILE__, __LINE__, #assertion)              \
d268 2
a269 2
                                                                               \
   doNothing ()                                                                \
@


1.43
log
@Multi-objective mode.
@
text
@d93 1
a93 1
   void debugAssert (
d102 3
a104 4
   void strongAssertFailure (const char * srcFileName, int lineNo);
      //
      // Issues a fatal error.
      // Invoked thru stronglyAssert macro.
d231 1
a231 1
   debugAssert ((assertion), __FILE__, __LINE__, #assertion)                   \
d235 3
a237 1
#define witAssert(assertion)
d244 2
a245 1
// Issues a fatal error, if assertion is false.
d250 1
a250 2
   if (not (assertion))                                                        \
      strongAssertFailure (__FILE__, __LINE__)                                 \
d267 3
a269 1
#define nonMsgAssert(assertion)
@


1.42
log
@When comparing a file name to WitSTDOUT, changed from pointer equality
to string equality.
@
text
@d249 1
a249 1
      strongAssertFailure (__FILE__, __LINE__);                                \
@


1.41
log
@Object name change.
@
text
@d72 4
@


1.40
log
@Assisted opt implosion.
@
text
@d127 1
a127 1
   bool isNullString (const char * theCstring);
d129 1
a129 1
      // Returns true iff theString is the null string.
@


1.39
log
@Updated the copyright date on all source files.
@
text
@d151 5
@


1.38
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.37
log
@[multi-thread]
@
text
@d103 10
d242 19
@


1.36
log
@[multi-thread]
@
text
@a140 4

   WitMsgFacility & curMsgFac ();
      //
      // Returns the MsgFacility for the current WitRun.
@


1.35
log
@[multi-thread]
@
text
@a22 6
typedef void (* WitSimpleFuncPtr) ();
   //
   // A pointer to a function taking no arguments and returning no value.

//------------------------------------------------------------------------------

a102 5
   FILE * openFile (const WitString & fileName, const WitString & mode);
      //
      // Opens and returns a file with name filename in mode mode, with
      // error checking.

a141 5
   const char * strerror (int errnum);
      //
      // WIT's version of the standard function strerror.
      // If the real one exists on the platform, this function wraps it.

@


1.34
log
@[multi-thread]
@
text
@a131 4
   WitSimpleFuncPtr set_new_handler (WitSimpleFuncPtr theHandler);
      //
      // Wrapper for C++ standard set_new_handler.

@


1.33
log
@[multi-thread]
@
text
@a108 6
   void newError ();
      //
      // This function will be called when "new" is unable to satisfy a
      // request for more storage. It is used as the argument to
      // set_new_handler.

@


1.32
log
@[multi-threads]
@
text
@d30 84
a113 4
{
//------------------------------------------------------------------------------
// Max/Min function templates.
//------------------------------------------------------------------------------
d115 1
a115 2
template <typename Number> 
   inline Number max (Number num1, Number num2);
d117 2
a118 1
      // Returns the maximum of num1 and num2.
d120 4
a123 2
template <typename Number> 
   inline Number min (Number num1, Number num2);
d125 8
a132 1
      // Returns the minimum of num1 and num2.
d134 1
a134 2
template <typename Number> 
   inline void setToMax (Number & num1, Number num2);
d136 1
a136 1
      // Updates num1 to be the max of num1 and num2.
d138 1
a138 2
template <typename Number> 
   inline void setToMin (Number & num1, Number num2);
d140 1
a140 1
      // Updates num1 to be the min of num1 and num2.
d142 3
a144 5
//------------------------------------------------------------------------------
// Explicit conversions between float and double.
// Conversions from the wrong type are disallowed by declaring functions here
// that are not implemented.
//------------------------------------------------------------------------------
d146 3
a148 4
inline double dblFromFlt (float theFloat)
   {
   return static_cast <double> (theFloat);
   }
d150 3
a152 4
inline float fltFromDbl (double theDouble)
   {
   return static_cast <float> (theDouble);
   }
d154 3
a156 4
double dblFromFlt (double);
float  fltFromDbl (float);
   //
   // Not implemented.
d158 4
a161 1
//------------------------------------------------------------------------------
d163 4
a166 4
inline double positivePart (double theVal)
   {
   return max (0.0, theVal);
   }
d168 4
a171 92
void net (double & theVal1, double & theVal2);
   //
   // Subtracts min (theVal1, theVal2) from theVal1 and from theVal2.

int sign (int theVal);
   //
   // Returns 1, 0, or -1.

int sign (double theVal);
   //
   // Returns 1, 0, or -1.

void debugAssert (
      bool         assertion,
      const char * srcFileName,
      int          lineNo,
      const char * assertionString);
   //
   // Issues a fatal error, if assertion is false.
   // Invoked thru witAssert macro.

void strongAssertFailure (const char * srcFileName, int lineNo);
   //
   // Issues a fatal error.
   // Invoked thru stronglyAssert macro.

void newError ();
   //
   // This function will be called when "new" is unable to satisfy a
   // request for more storage. It is used as the argument to
   // set_new_handler.

FILE * openFile (const WitString & fileName, const WitString & mode);
   //
   // Opens and returns a file with name filename in mode mode, with
   // error checking.

void forbidNullArg (
      const void * theArg,
      const char * argName,
      const char * funcName);
   //
   // theArg:   A pointer that was passed to WIT as an argument to an
   //           API function.
   // argName:  The name of the argument
   // funcName: The name of the API function.
   // If theArg is NULL, this function prints an error message to
   // stderr and exists the process.
   // This function should only be used when there is no WitRun
   // available, since it does not use the message facility.

bool isNullString (const char * theCstring);
   //
   // Returns true iff theString is the null string.

WitSimpleFuncPtr set_new_handler (WitSimpleFuncPtr theHandler);
   //
   // Wrapper for C++ standard set_new_handler.

double percentToFrac (int thePercent);
   //
   // Returns thePercent, converted to a fraction.

int fracToPercent (double theFrac);
   //
   // Returns theFrac, converted to a percent.

void startNonMsgSevereError ();
   //
   // Starts issuing a severe error, without the Msg Facility.

void finishNonMsgSevereError ();
   //
   // Finishes issuing a severe error, without the Msg Facility.

void issueNonMsgFatalError (const char * funcName);
   //
   // Issues a fatal error message without the Msg Facility.
   // funcName is the name of the WIT function in which the error occurred.

const char * strerror (int errnum);
   //
   // WIT's version of the standard function strerror.
   // If the real one exists on the platform, this function wraps it.

WitMsgFacility & curMsgFac ();
   //
   // Returns the MsgFacility for the current WitRun.

};
   //
   // Leaving namespace NonClass.
@


1.31
log
@Removed portableFree.
@
text
@a171 1
// Leaving namespace NonClass.
d173 2
@


1.30
log
@Double Precision.
@
text
@a114 5
inline void portableFree (void * mem);
   //
   // This function hides the incompatibilities between the various
   // versions of free.

a176 18
//------------------------------------------------------------------------------

#ifdef OLD_STYLE_MALLOC_FREE

inline void WitNonClass::portableFree (void * mem)
   {
   free (static_cast <char *> (mem));
   }

#else

inline void WitNonClass::portableFree (void * mem)
   {
   free (mem);
   }

#endif

@


1.29
log
@Double Precision.
@
text
@a77 5
inline float  positivePart (float  theVal)
   {
   return max (0.0F, theVal);
   }

d87 5
a91 1
int sign (float theVal);
a245 1
template inline float  WitNonClass::max      <float>  (float,    float);
a248 1
template inline float  WitNonClass::min      <float>  (float,    float);
a251 1
template inline void   WitNonClass::setToMax <float>  (float  &, float);
a254 1
template inline void   WitNonClass::setToMin <float>  (float  &, float);
@


1.28
log
@Double Precision.
@
text
@d57 1
a57 1
// Conversions from the wrong type afre disallowed by declaring functions here
@


1.27
log
@Double Precision.
@
text
@d164 5
d173 4
@


1.26
log
@Continued double precision.
@
text
@d61 1
a61 1
inline double doubleFromFloat (float theFloat)
d66 1
a66 1
inline float floatFromDouble (double theDouble)
d71 2
a72 2
double doubleFromFloat (double);
float  floatFromDouble (float);
@


1.25
log
@Continued double precision.
@
text
@d148 1
a148 1
float percentToFrac (int thePercent);
d152 1
a152 1
int fracToPercent (float theFrac);
@


1.24
log
@Continued double precision.
@
text
@a125 10
void forbidNullWitRun (WitRun * theWitRun, const char * funcName);
   //
   // theWitRun: A WitRun pointer that was passed to WIT as the
   //            "theWitRun" argument to an API function.
   // funcName:  The name of the API function.
   // If theWitRun is NULL, this function prints an error message to
   // stderr and exists the process.
   // This function should only be used when there is no WitRun
   // available, since it does not use the message facility.

@


1.23
log
@An attempt to fix a syntax error in Windows.
@
text
@d56 21
@


1.22
log
@Continued implementation of PIP.
@
text
@d223 1
a223 1
// (Needed for Windows.)
@


1.21
log
@Continued implementation of PIP.
@
text
@d30 4
a33 36
   {
   //---------------------------------------------------------------------------
   // Max/Min function templates.
   //---------------------------------------------------------------------------

   template <typename Number> 
      inline Number max (Number num1, Number num2);
         //
         // Returns the maximum of num1 and num2.

   template <typename Number> 
      inline Number min (Number num1, Number num2);
         //
         // Returns the minimum of num1 and num2.

   template <typename Number> 
      inline void setToMax (Number & num1, Number num2);
         //
         // Updates num1 to be the max of num1 and num2.

   template <typename Number> 
      inline void setToMin (Number & num1, Number num2);
         //
         // Updates num1 to be the min of num1 and num2.

   //---------------------------------------------------------------------------

   inline float  positivePart (float  theVal)
      {
      return max (0.0F, theVal);
      }

   inline double positivePart (double theVal)
      {
      return max (0.0, theVal);
      }
d35 2
a36 1
   void net (double & theVal1, double & theVal2);
d38 1
a38 1
      // Subtracts min (theVal1, theVal2) from theVal1 and from theVal2.
d40 2
a41 1
   int sign (float theVal);
d43 1
a43 1
      // Returns 1, 0, or -1.
d45 2
a46 5
   void debugAssert (
         bool         assertion,
         const char * srcFileName,
         int          lineNo,
         const char * assertionString);
d48 1
a48 2
      // Issues a fatal error, if assertion is false.
      // Invoked thru witAssert macro.
d50 2
a51 1
   void strongAssertFailure (const char * srcFileName, int lineNo);
d53 1
a53 2
      // Issues a fatal error.
      // Invoked thru stronglyAssert macro.
d55 1
a55 5
   void newError ();
      //
      // This function will be called when "new" is unable to satisfy a
      // request for more storage. It is used as the argument to
      // set_new_handler.
d57 4
a60 4
   inline void portableFree (void * mem);
      //
      // This function hides the incompatibilities between the various
      // versions of free.
d62 4
a65 6
   FILE * openFile (
         const WitString & fileName,
         const WitString & mode);
      //
      // Opens and returns a file with name filename in mode mode, with
      // error checking.
d67 90
a156 23
   void forbidNullWitRun (WitRun * theWitRun, const char * funcName);
      //
      // theWitRun: A WitRun pointer that was passed to WIT as the
      //            "theWitRun" argument to an API function.
      // funcName:  The name of the API function.
      // If theWitRun is NULL, this function prints an error message to
      // stderr and exists the process.
      // This function should only be used when there is no WitRun
      // available, since it does not use the message facility.

   void forbidNullArg (
         const void * theArg,
         const char * argName,
         const char * funcName);
      //
      // theArg:   A pointer that was passed to WIT as an argument to an
      //           API function.
      // argName:  The name of the argument
      // funcName: The name of the API function.
      // If theArg is NULL, this function prints an error message to
      // stderr and exists the process.
      // This function should only be used when there is no WitRun
      // available, since it does not use the message facility.
d158 2
a159 29
   bool isNullString (const char * theCstring);
      //
      // Returns true iff theString is the null string.

   WitSimpleFuncPtr set_new_handler (WitSimpleFuncPtr theHandler);
      //
      // Wrapper for C++ standard set_new_handler.

   float percentToFrac (int thePercent);
      //
      // Returns thePercent, converted to a fraction.

   int fracToPercent (float theFrac);
      //
      // Returns theFrac, converted to a percent.

   void startNonMsgSevereError ();
      //
      // Starts issuing a severe error, without the Msg Facility.

   void finishNonMsgSevereError ();
      //
      // Finishes issuing a severe error, without the Msg Facility.

   const char * strerror (int errnum);
      //
      // WIT's version of the standard function strerror.
      // If the real one exists on the platform, this function wraps it.
   };
@


1.20
log
@Continued implementation of PIP.
@
text
@d17 2
a18 2
//    The declaration of namespace Util.
//    Some macros that use namespace Util.
a27 4
// Namespace Util.
//
// General purpose utility functions for WIT.
//------------------------------------------------------------------------------
d29 1
a29 1
namespace WitUtil
d167 1
a167 1
inline void WitUtil::portableFree (void * mem)
d174 1
a174 1
inline void WitUtil::portableFree (void * mem)
d184 1
a184 1
      inline Number WitUtil::max (Number num1, Number num2)
d195 1
a195 1
      inline Number WitUtil::min (Number num1, Number num2)
d206 1
a206 1
      inline void WitUtil::setToMax (Number & num1, Number num2)
d215 1
a215 1
      inline void WitUtil::setToMin (Number & num1, Number num2)
d226 15
a240 15
template inline int    WitUtil::max      <int>    (int,      int);
template inline float  WitUtil::max      <float>  (float,    float);
template inline double WitUtil::max      <double> (double,   double);

template inline int    WitUtil::min      <int>    (int,      int);
template inline float  WitUtil::min      <float>  (float,    float);
template inline double WitUtil::min      <double> (double,   double);

template inline void   WitUtil::setToMax <int>    (int    &, int);
template inline void   WitUtil::setToMax <float>  (float  &, float);
template inline void   WitUtil::setToMax <double> (double &, double);

template inline void   WitUtil::setToMin <int>    (int    &, int);
template inline void   WitUtil::setToMin <float>  (float  &, float);
template inline void   WitUtil::setToMin <double> (double &, double);
a270 4

//------------------------------------------------------------------------------

using namespace WitUtil;
@


1.19
log
@An attempt to fix some syntax errors on Windows.
@
text
@d227 1
@


1.18
log
@Continued implementation of PIP.
@
text
@d35 6
a40 2
   template <typename Value> 
      inline Value max (Value val1, Value val2);
d42 1
a42 1
         // Returns the maximum of val1 and val2.
d44 2
a45 2
   template <typename Value> 
      inline Value min (Value val1, Value val2);
d47 1
a47 1
         // Returns the minimum of val1 and val2.
d49 2
a50 2
   template <typename Value> 
      inline void setToMax (Value & val1, Value val2);
d52 1
a52 1
         // Updates val1 to be the max of val1 and val2.
d54 2
a55 2
   template <typename Value> 
      inline void setToMin (Value & val1, Value val2);
d57 3
a59 1
         // Updates val1 to be the min of val1 and val2.
d187 2
a188 2
template <typename Value> 
      inline Value WitUtil::max (Value val1, Value val2)
d190 4
a193 1
   return (val1 > val2)? val1: val2;
d198 2
a199 2
template <typename Value> 
      inline Value WitUtil::min (Value val1, Value val2)
d201 4
a204 1
   return (val1 < val2)? val1: val2;
d209 2
a210 2
template <typename Value> 
      inline void WitUtil::setToMax (Value & val1, Value val2)
d212 2
a213 2
   if (val2 > val1)
      val1 = val2;
d218 2
a219 2
template <typename Value> 
      inline void WitUtil::setToMin (Value & val1, Value val2)
d221 2
a222 2
   if (val2 < val1)
      val1 = val2;
d224 20
@


1.17
log
@Continued implementation of PIP.
@
text
@a27 39
// Macro maxMinFuncs.
//
// Declares and implements the functions max, min, setToMax, and setToMin for 
// TheType.
//------------------------------------------------------------------------------

#define maxMinFuncs(TheType)                                                   \
                                                                               \
   inline TheType max (TheType val1, TheType val2)                             \
         /*                                                                  */\
         /* Returns the maximum of val1 and val2.                            */\
      {                                                                        \
      return (val1 > val2)? val1: val2;                                        \
      }                                                                        \
                                                                               \
   inline TheType min (TheType val1, TheType val2)                             \
         /*                                                                  */\
         /* Returns the minimum of val1 and val2.                            */\
      {                                                                        \
      return (val1 < val2)? val1: val2;                                        \
      }                                                                        \
                                                                               \
   inline void setToMax (TheType & val1, TheType val2)                         \
         /*                                                                  */\
         /* Updates val1 to be the max of val1 and val2.                     */\
      {                                                                        \
      if (val2 > val1)                                                         \
         val1 = val2;                                                          \
      }                                                                        \
                                                                               \
   inline void setToMin (TheType & val1, TheType val2)                         \
         /*                                                                  */\
         /* Updates val1 to be the min of val1 and val2.                     */\
      {                                                                        \
      if (val2 < val1)                                                         \
         val1 = val2;                                                          \
      }                                                                        \

//------------------------------------------------------------------------------
d35 2
a36 91
      maxMinFuncs (int)
      maxMinFuncs (float)
      maxMinFuncs (double)

      inline float  positivePart (float  theVal)
         {
         return max (0.0F, theVal);
         }

      inline double positivePart (double theVal)
         {
         return max (0.0, theVal);
         }

      void net (double & theVal1, double & theVal2);
         //
         // Subtracts min (theVal1, theVal2) from theVal1 and from theVal2.

      int sign (float theVal);
         //
         // Returns 1, 0, or -1.

      void debugAssert (
            bool         assertion,
            const char * srcFileName,
            int          lineNo,
            const char * assertionString);
         //
         // Issues a fatal error, if assertion is false.
         // Invoked thru witAssert macro.

      void strongAssertFailure (const char * srcFileName, int lineNo);
         //
         // Issues a fatal error.
         // Invoked thru stronglyAssert macro.

      void newError ();
         //
         // This function will be called when "new" is unable to satisfy a
         // request for more storage. It is used as the argument to
         // set_new_handler.

      inline void portableFree (void * mem);
         //
         // This function hides the incompatibilities between the various
         // versions of free.

      FILE * openFile (
            const WitString & fileName,
            const WitString & mode);
         //
         // Opens and returns a file with name filename in mode mode, with
         // error checking.

      void forbidNullWitRun (WitRun * theWitRun, const char * funcName);
         //
         // theWitRun: A WitRun pointer that was passed to WIT as the
         //            "theWitRun" argument to an API function.
         // funcName:  The name of the API function.
         // If theWitRun is NULL, this function prints an error message to
         // stderr and exists the process.
         // This function should only be used when there is no WitRun
         // available, since it does not use the message facility.

      void forbidNullArg (
            const void * theArg,
            const char * argName,
            const char * funcName);
         //
         // theArg:   A pointer that was passed to WIT as an argument to an
         //           API function.
         // argName:  The name of the argument
         // funcName: The name of the API function.
         // If theArg is NULL, this function prints an error message to
         // stderr and exists the process.
         // This function should only be used when there is no WitRun
         // available, since it does not use the message facility.

      bool isNullString (const char * theCstring);
         //
         // Returns true iff theString is the null string.

      WitSimpleFuncPtr set_new_handler (WitSimpleFuncPtr theHandler);
         //
         // Wrapper for C++ standard set_new_handler.

      float percentToFrac (int thePercent);
         //
         // Returns thePercent, converted to a fraction.

      int fracToPercent (float theFrac);
d38 1
a38 1
         // Returns theFrac, converted to a percent.
d40 2
a41 1
      void startNonMsgSevereError ();
d43 114
a156 10
         // Starts issuing a severe error, without the Msg Facility.

      void finishNonMsgSevereError ();
         //
         // Finishes issuing a severe error, without the Msg Facility.

      const char * strerror (int errnum);
         //
         // WIT's version of the standard function strerror.
         // If the real one exists on the platform, this function wraps it.
a159 4

using namespace WitUtil;

//------------------------------------------------------------------------------
d180 34
d242 4
@


1.16
log
@Eliminated the "tempnam" linker warning on Linux.
@
text
@d17 2
a18 2
//    The declaration of class Util.
//    Some macros that use class Util.
d36 1
a36 1
   inline static TheType max (TheType val1, TheType val2)                      \
d43 1
a43 1
   inline static TheType min (TheType val1, TheType val2)                      \
d50 1
a50 1
   inline static void setToMax (TheType & val1, TheType val2)                  \
d58 1
a58 1
   inline static void setToMin (TheType & val1, TheType val2)                  \
d67 1
a67 1
// Class Util
d69 1
a69 11
// This is the general purpose utility class for WIT. It contains no data. With
// the exception of the ctor and dtor, all its member functions are static.
//
// Every class in WIT (except this one) that does not inherit from another class
// is to inherit from this class.
//
// The member functions of this class are utility functions, available to be
// used by any WIT object. The intent is that they should be as easy to use in
// WIT as if they were global functions, but since they are member functions of
// this class, they do not occupy the global name space and are thus kept safely
// out of the way of any application code.
d72 1
a72 1
class WitUtil
a73 6
   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

d78 1
a78 1
      inline static float  positivePart (float  theVal)
d83 1
a83 1
      inline static double positivePart (double theVal)
d88 1
a88 1
      static void net (double & theVal1, double & theVal2);
d92 1
a92 1
      static int sign (float theVal);
d96 1
a96 1
      static void debugAssert (
d105 1
a105 1
      static void strongAssertFailure (const char * srcFileName, int lineNo);
d110 1
a110 1
      static void newError ();
d116 1
a116 1
      inline static void portableFree (void * mem);
d121 1
a121 1
      static FILE * openFile (
d128 1
a128 1
      static void forbidNullWitRun (WitRun * theWitRun, const char * funcName);
d138 1
a138 1
      static void forbidNullArg (
d152 1
a152 1
      static bool isNullString (const char * theCstring);
d156 1
a156 1
      static WitSimpleFuncPtr set_new_handler (WitSimpleFuncPtr theHandler);
d160 1
a160 1
      static float percentToFrac (int thePercent);
d164 1
a164 1
      static int   fracToPercent (float theFrac);
d168 1
a168 1
      static void startNonMsgSevereError ();
d172 1
a172 1
      static void finishNonMsgSevereError ();
d176 1
a176 1
      static const char * strerror (int errnum);
d180 1
d182 1
a182 5
   protected:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------
d184 1
a184 25
      inline WitUtil ()
         {
         }

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      inline ~WitUtil ()
         {
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitUtil);
         //
         // Nullifies the default copy ctor and assignment operator.
         // Copy ctors of derived classes should just use the 0-arg ctor, above.
         // The lack of a real copy ctor for this class is an enforcement of the
         // fact that, by design, instances of this class have nothing to copy.
   };
d217 1
a217 1
   WitUtil::debugAssert ((assertion), __FILE__, __LINE__, #assertion)          \
d234 1
a234 2
      WitUtil::strongAssertFailure (__FILE__, __LINE__);                       \

@


1.15
log
@Eliminated warnings from make depend regarding WIT code.
@
text
@a136 5
      static char * tempFileName (char * stemName);
         //
         // Allocates and returns a string giving a unique name for a temporary
         // file. stemName will appear as part of the name returned.

@


1.14
log
@Replaced some C style casts with C++ style casts.
@
text
@d238 2
d242 2
a243 1
   #ifdef OLD_STYLE_MALLOC_FREE
d245 1
a245 1
      free (static_cast <char *> (mem));
d247 4
a250 1
   #else
d252 1
a252 4
      free (mem);

   #endif
   }
d263 1
a263 1
   #define witAssert(assertion)                                                \
d265 1
a265 1
      WitUtil::debugAssert ((assertion), __FILE__, __LINE__, #assertion)       \
d269 1
a269 1
   #define witAssert(assertion)
@


1.13
log
@Attempt to fix a syntax error from the MS compiler in Pre.C.
@
text
@d242 1
a242 1
      free ((char *) mem);
@


1.12
log
@Internal changes.
@
text
@d96 1
a96 1
         return max (0.0f, theVal);
@


1.11
log
@Internal changes.
@
text
@d278 1
a278 1
   if (! (assertion))                                                          \
@


1.10
log
@Continued implementation of object iteration.
@
text
@d113 1
a113 1
            WitBoolean   assertion,
d118 1
a118 1
         // Issues a fatal error, if assertion is FALSE.
d173 1
a173 1
      static WitBoolean isNullString (const char * theCstring);
d175 1
a175 1
         // Returns TRUE iff theString is the null string.
d254 1
a254 1
// Issues a fatal error, if assertion is FALSE.
d273 1
a273 1
// Issues a fatal error, if assertion is FALSE.
@


1.9
log
@Began implementation of object iteration.
@
text
@a176 12
      inline static streq (const char * x, const char * y)
            //
            // Returns TRUE, iff x and y are equal strings.
         {
         return (strcmp (x, y) == 0);
         }

      static WitBoolean streqn (const char * x, const char * y, int n);
         //
         // Returns TRUE, iff x and y are equal strings for the first n
         // characters.

@


1.8
log
@Continued implementation of sel-split for pen-exec.
@
text
@d121 5
d291 2
a292 1
      WitMsgFacility::current () ("stronglyAssertFmsg", __FILE__, __LINE__)    \
@


1.7
log
@Continued refactoring.
@
text
@d112 1
a112 1
      static void utilAssert (
d269 1
a269 1
      WitUtil::utilAssert ((assertion), __FILE__, __LINE__, #assertion)        \
d276 11
@


1.6
log
@Refactoring for selection splitting.
@
text
@d36 1
a36 1
   static inline TheType max (TheType val1, TheType val2)                      \
d43 1
a43 1
   static inline TheType min (TheType val1, TheType val2)                      \
d50 1
a50 1
   static inline void setToMax (TheType & val1, TheType val2)                  \
d58 1
a58 1
   static inline void setToMin (TheType & val1, TheType val2)                  \
d127 1
a127 1
      static inline void portableFree (void * mem);
@


1.5
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d233 1
a233 1
      copyCtorAndAssignment (WitUtil);
@


1.4
log
@Continued implementation of stock re-allocation.
@
text
@a22 2
//------------------------------------------------------------------------------

d36 1
a36 1
   static inline TheType max (TheType x, TheType y)                            \
d38 1
a38 1
         /* Returns the maximum of x and y.                                  */\
d40 1
a40 1
      return (x > y)? x: y;                                                    \
d43 1
a43 1
   static inline TheType min (TheType x, TheType y)                            \
d45 1
a45 1
         /* Returns the minimum of x and y.                                  */\
d47 1
a47 1
      return (x < y)? x: y;                                                    \
d50 1
a50 1
   static inline void setToMax (TheType & x, TheType y)                        \
d52 1
a52 1
         /* Updates x to be the max of x and y.                              */\
d54 2
a55 2
      if (y > x)                                                               \
         x = y;                                                                \
d58 1
a58 1
   static inline void setToMin (TheType & x, TheType y)                        \
d60 1
a60 1
         /* Updates x to be the min of x and y.                              */\
d62 2
a63 2
      if (y < x)                                                               \
         x = y;                                                                \
d67 7
a73 1
// class Util.
d75 5
a79 4
// This class consists of static public member functions which are general
// purpose utilities for WIT. In particular, they are functions that are not
// associated with a specific WitRun. They are collected here to avoid global
// scope. It is an error to create an instance of this class.
d87 1
a87 1
      // Public static member functions.
d94 9
a102 4
      static float  positivePart (float  x);
      static double positivePart (double x);
         //
         // Returns the positive part of x.
d104 1
a104 1
      static void net (double & x, double & y);
d106 1
a106 1
         // Subtracts min (x, y) from x and from y.
d108 1
a108 1
      static int sign (float x);
d209 18
d230 1
a230 1
      // Constructor functions.
d233 1
a233 1
      WitUtil ();
d235 4
a238 1
         // Not Implemented: This prevents construction of WitUtil instances.
@


1.3
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d32 2
a33 2
// Declares and implements the functions max, min, updateToMax, and updateToMin
// for TheType.
d52 1
a52 1
   static inline void updateToMax (TheType & x, TheType y)                     \
d60 1
a60 1
   static inline void updateToMin (TheType & x, TheType y)                     \
@


1.2
log
@Bob's changes to
-fix Aix V4.1.5 compiler warning
-remove WitUtil::nonPortableFree macro which was causing problems in the
 lexx and yacc generated calls to free
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1
log
@Initial revision
@
text
@a227 14
// Macros that use class Util.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// free
//
// This macro forces the rest of the code to use portableFree, by
// mapping "free" to a non-existing function (WitUtil::nonPortableFree),
// resulting in a syntax error that would lead the programmer to this file.
//------------------------------------------------------------------------------

#define free(arg) WitUtil::nonPortableFree (arg)

//------------------------------------------------------------------------------
@


1.1.1.1
log
@Import wit
@
text
@@

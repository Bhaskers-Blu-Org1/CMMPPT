head	1.70;
access;
symbols
	sce_5_01_20080919:1.64
	latest_sce_4_20_20060523:1.51.0.2
	sce_4_20_20060523:1.51
	latest_sce4_20_OSL:1.50.0.2
	sce_4_20_OSL:1.50
	sce_410_withVa:1.49
	sce_4_05_20040511:1.48
	sce_4_00_20040201:1.39
	nextGenBranch:1.35.0.2
	nextGenRoot:1.35
	sce_3_30_20030627:1.34
	EndRw-branch:1.29.0.4
	Root-of-EndRw:1.29
	rwToStl:1.29.0.2
	latest_sce_3_10_20010924:1.14.0.2
	sce_3_10_20010924:1.14
	latest_sce_3_00_20010601:1.12.0.4
	sce_3_00_20010601:1.12
	latest_sce_2_31_20010308:1.12.0.2
	sce_2_31_20010308:1.12
	latest_sce_2_31_20001003:1.7.0.2
	sce_2_31_20001003:1.7
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.70
date	2011.09.28.23.49.35;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2011.09.24.00.27.55;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2011.08.30.20.17.40;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2010.09.17.22.20.53;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2010.09.10.22.10.38;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.13.23.02.16;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.13.21.18.30;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.08.18.26.08;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.24.18.52.21;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.22.20.58.37;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.14.19.05.39;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.11.20.43.56;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.28.20.04.57;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.10.00.08.14;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.08.22.47.35;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.08.00.14.25;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.02.17.34.03;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.28.20.14.36;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.24.22.21.31;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.05.22.19.58;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.04.16.44.29;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.03.19.07.27;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.15.18.12.02;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.01.20.53.59;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.23.21.23.20;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.23.18.12.36;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.15.23.13.14;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.15.21.01.22;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.02.23.40.43;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.02.22.18.34;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.07.21.46.36;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.11.18.53.10;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.06.18.53.39;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.05.21.19.59;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.05.19.31.34;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.04.23.07.21;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.03.22.35.19;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.03.16.01.49;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.29.14.32.40;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.28.19.44.56;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.08.19.21.52;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.07.20.14.59;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.03.23.16.39;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.01.14.25.57;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.18.14.02.36;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.20.20.07.04;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.01.19.23.33;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.15.19.01.50;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.28.22.13.37;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.22.16.18.26;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.05.19.05.30;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.21.20.03.25;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.25.20.12.32;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.29.21.22.45;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.18.00.16.00;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.25.19.17.45;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.24;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.18;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.25;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.25;	author wit;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "MrpExp.C"
//
// Contains the implementation of the following classes:
//
// MrpExp
// OrigMrpExp.
//------------------------------------------------------------------------------

#include <OrigMrp.h>
#include <Pre.h>
#include <GlobalComp.h>
#include <Part.h>
#include <Demand.h>
#include <Operation.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Timing.h>
#include <MsgFac.h>
#include <ObjStack.h>

//------------------------------------------------------------------------------
// Implementation of class MrpExp.
//------------------------------------------------------------------------------

WitMrpExp::WitMrpExp (WitProblem * theProblem):
      WitProbAssoc (theProblem),

      netSubsMode_ (false)
   {
   }

//------------------------------------------------------------------------------

WitMrpExp::~WitMrpExp ()
   {
   }

//------------------------------------------------------------------------------

void WitMrpExp::mrp ()
   {
   WitTimer::enterSection ("mrp");

   myPreprocessor ()->preprocess ();

   init ();

   explodeAllParts ();

   finish ();

   WitTimer::leaveSection ("mrp");
   }

//------------------------------------------------------------------------------

void WitMrpExp::initDerived ()
   {
   }

//------------------------------------------------------------------------------

void WitMrpExp::init ()
   {
   WitPart *     thePart;
   WitPeriod     thePer;
   WitSubEntry * theSub;

   initDerived ();

   netSupplyVol_.allocate (myProblem (), 0.0);
   myReqVol_    .allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      myReqVol_ (thePart) = 0.0;

      forEachPeriod (thePer, myProblem ())
         netSupplyVol_ (thePart)[thePer] = supplyVol (thePart, thePer);
      }

   netSubsMode_ = false;

   hasSubsToNetVec_.resize (myCompMgr ()->nBomEntries (), false);

   forEachSubEntry (theSub, myProblem ())
      if (theSub->mrpNetAllowed ())
         {
         netSubsMode_                       = true;
         hasSubsToNet (theSub->myBomEnt ()) = true;
         }
   }

//------------------------------------------------------------------------------

void WitMrpExp::explodeAllParts ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   bool      success;

   WitObjStack <WitPart> reversedParts (myProblem ());

   revCopyInto (reversedParts, myCompMgr ()->allParts ());

   while (reversedParts.pop (thePart))
      forEachPeriod (thePer, myProblem ())
         {
         myReqVol_ (thePart)[thePer] += demandVol (thePart, thePer);

         myReqVol_ (thePart)[thePer] =
            thePart->net (
               thePer, 
               myReqVol_     (thePart)[thePer], 
               netSupplyVol_ (thePart));

         if (myReqVol_ (thePart)[thePer] > FLOAT_EPSILON)
            {
            success = explode (thePart, thePer);

            if (not success)
               if (myGlobalComp ()->roundReqVols ())
                  myReqVol_ (thePart)[thePer] = 
                     ceil (myReqVol_ (thePart)[thePer]);
            }
         else
            myReqVol_ (thePart)[thePer] = 0.0;
         }
   }

//------------------------------------------------------------------------------

bool WitMrpExp::explode (WitPart * thePart, WitPeriod fillPer)
   {
   WitPeriod      expPer;
   WitBopEntry *  theExpBopEntry;
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         qty;
   WitBomEntry *  theBomEnt;
   WitBopEntry *  theBopEnt;

   expPer = thePart->explosionPeriod (fillPer);

   if (not thePart->explodeable (expPer))
      return false;

   theExpBopEntry = thePart       ->expBopEntry   (expPer);
   theOpn         = theExpBopEntry->myOperation   ();
   execPer        = theExpBopEntry->expExecPeriod ()[expPer];

   qty = myReqVol_ (thePart)[fillPer] / theExpBopEntry->effProdRate ()[execPer];

   qty = theOpn->lotSizeDelta (execPer, execVol (theOpn, execPer), qty);

   if (qty <= FLOAT_EPSILON)
       return false;

   execVol (theOpn, execPer) += qty;

   forEachEl (theBomEnt, theOpn->bom ())
      explodeBomEntry (theBomEnt, execPer, qty);

   forEachEl (theBopEnt, theOpn->bop ())
      explodeBopEntry (theBopEnt, execPer, qty);

   thePart->net (
      fillPer,
      myReqVol_     (thePart)[fillPer],
      netSupplyVol_ (thePart));

   myReqVol_ (thePart)[fillPer]  = 0.0;

   return true;
   }

//------------------------------------------------------------------------------

void WitMrpExp::explodeBomEntry (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        qty)
   {
   double    reqQty;
   WitPart * thePart;
   WitPeriod consPer;


   if (not theBomEnt->inEffect (execPer))
      return;

   if (myCompMgr ()->hasSubEntries ())
      if (theBomEnt->hasSubsInEffect ()[execPer])
         if (hasSubsToNet (theBomEnt))
            netConsEntries (theBomEnt, execPer, qty);

   reqQty = qty * theBomEnt->effConsRate ()[execPer];

   if (fabs (reqQty) <= FLOAT_EPSILON)
      return;

   thePart = theBomEnt->myPart ();
   consPer = theBomEnt->impactPeriod ()[execPer];

   if (reqQty > 0.0)
      myReqVol_     (thePart)[consPer] += reqQty;
   else
      netSupplyVol_ (thePart)[consPer] -= reqQty;
   }

//------------------------------------------------------------------------------

void WitMrpExp::netConsEntries (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double &      qty)
   {
   WitSubEntry * theSub;
   double        oldQty;

   netConsEntry (theBomEnt, execPer, qty);

   if (qty < NET_TOL)
      return;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->mrpNetAllowed ())
         if (theSub->inEffect (execPer))
            {
            oldQty = qty;

            netConsEntry (theSub, execPer, qty);

            subVol (theSub, execPer) += positivePart (oldQty - qty);

            if (qty < NET_TOL)
               return;
            }
   }

//------------------------------------------------------------------------------

void WitMrpExp::netConsEntry (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double &       qty)
   {
   double    reqConsQty;
   WitPart * thePart;
   WitPeriod consPer;
   double    netConsQty;


   reqConsQty = theConsEnt->effConsRate ()[execPer] * qty;
   thePart    = theConsEnt->myPart ();
   consPer    = theConsEnt->impactPeriod ()[execPer];

   if (theConsEnt->effConsRate ()[execPer] >= FLOAT_EPSILON)
      {
      netConsQty = thePart->net (consPer, reqConsQty, netSupplyVol_ (thePart));

      qty = netConsQty / theConsEnt->effConsRate ()[execPer];

      if (qty <= NET_TOL)
         qty = 0.0;
      }
   else
      {
      if (theConsEnt->effConsRate ()[execPer] <= - FLOAT_EPSILON)
         netSupplyVol_ (thePart)[consPer] -= reqConsQty;

      qty = 0.0;
      }
   }

//------------------------------------------------------------------------------

void WitMrpExp::explodeBopEntry (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        qty)
   {
   WitPeriod prodPer;
   double    prodQty;

   if (not theBopEnt->inEffect (execPer))
      return;

   prodPer =       theBopEnt->impactPeriod ()[execPer];
   prodQty = qty * theBopEnt->effProdRate  ()[execPer];

   if (prodQty > FLOAT_EPSILON)
      netSupplyVol_ (theBopEnt->myPart ())[prodPer] += prodQty;
   }

//------------------------------------------------------------------------------

bool & WitMrpExp::hasSubsToNet (WitBomEntry * theBomEnt)
   {
   return hasSubsToNetVec_[theBomEnt->mappingIndex ()];
   }

//------------------------------------------------------------------------------

void WitMrpExp::finish ()
   {
   finishDerived ();

   hasSubsToNetVec_.clear ();
   myReqVol_       .clear ();
   netSupplyVol_   .clear ();
   }

//------------------------------------------------------------------------------
// Implementation of class OrigMrpExp.
//------------------------------------------------------------------------------

WitOrigMrpExp::WitOrigMrpExp (WitProblem * theProblem):
      WitMrpExp   (theProblem),

      exploding_     (false),
      uploadingSoln_ (false),
      mrpExecVol_    (),
      mrpSubVol_     ()
   {                  
   }

//------------------------------------------------------------------------------

WitOrigMrpExp::~WitOrigMrpExp ()
   {
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::initDerived ()
   {
   myMsgFac () ("mrpMsg");

   mrpExecVol_.allocate (myProblem (), 0.0);
   mrpSubVol_ .allocate (myProblem (), 0.0);

   exploding_ = true;
   }

//------------------------------------------------------------------------------

double WitOrigMrpExp::supplyVol (WitPart * thePart, WitPeriod thePer)
   {
   return thePart->supplyVol ()[thePer];
   }

//------------------------------------------------------------------------------

double WitOrigMrpExp::demandVol (WitPart * thePart, WitPeriod thePer)
   {
   WitDemand * theDemand;
   double      theDemandVol;

   theDemandVol = 0.0;

   forEachEl (theDemand, thePart->myDemands ())
      theDemandVol += theDemand->demandVol ()[thePer];

   return theDemandVol;
   }

//------------------------------------------------------------------------------

double & WitOrigMrpExp::execVol (WitOperation * theOpn, WitPeriod thePer)
   {
   return mrpExecVol_ (theOpn)[thePer];
   }

//------------------------------------------------------------------------------

double & WitOrigMrpExp::subVol (WitSubEntry * theSub, WitPeriod thePer)
   {
   return mrpSubVol_ (theSub)[thePer];
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::finishDerived ()
   {
   exploding_ = false;

   uploadSoln ();

   mrpExecVol_.clear ();
   mrpSubVol_ .clear ();
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::uploadSoln ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   uploadingSoln_ = true;

   forEachPart (thePart, myProblem ())
      {
      thePart->storeMrpReqVol         (myReqVol     () (thePart));
      thePart->storeMrpMrpResidualVol (netSupplyVol () (thePart));
      }

   forEachOperation (theOpn, myProblem ())
      theOpn->storeMrpMrpExecVol (mrpExecVol_ (theOpn));

   forEachSubEntry (theSub, myProblem ())
      theSub->storeMrpMrpSubVol (mrpSubVol_ (theSub));

   compMrpConsVols ();

   uploadingSoln_ = false;
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::compMrpConsVols ()
   {
   WitPart *        thePart;
   WitBomEntry *    theBomEnt;
   WitSubEntry *    theSub;
   WitPeriod        thePer;
   WitTVec <double> mrpNonSubVolVec (myProblem (), 0.0);
   WitTVec <double> mrpSubVolVec    (myProblem (), 0.0);
   WitTVec <double> mrpConsVolVec   (myProblem (), 0.0);
   double           totMrpSubVol;

   forEachPart (thePart, myProblem ())
      {
      mrpConsVolVec = 0.0;

      forEachEl (theBomEnt, thePart->consumingBomEntries ())
         {
         if (netSubsMode () and not theBomEnt->mySubEntries ().isEmpty ())
            forEachPeriod (thePer, myProblem ())
               {
               totMrpSubVol = 0.0;

               forEachEl (theSub, theBomEnt->mySubEntries ())
                  if (theSub->mrpNetAllowed ())
                     if (theSub->inEffect (thePer))
                        totMrpSubVol += theSub->mrpSubVol ()[thePer];

               mrpNonSubVolVec[thePer] =
                    mrpExecVol_ (theBomEnt->myOperation ())[thePer]
                  - totMrpSubVol;
               }
         else
            mrpNonSubVolVec = mrpExecVol_ (theBomEnt->myOperation ());

         theBomEnt->incConsVol (mrpConsVolVec, mrpNonSubVolVec);
         }

      if (netSubsMode ())
         forEachEl (theSub, thePart->consumingSubEntries ())
            if (theSub->mrpNetAllowed ())
               {
               mrpSubVolVec = theSub->mrpSubVol ();

               theSub->incConsVol (mrpConsVolVec, mrpSubVolVec);
               }

      thePart->storeMrpMrpConsVol (mrpConsVolVec);
      }
   }
@


1.69
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.68
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d37 1
a37 1
WitProbAssoc (theProblem),
d39 3
a41 3
netSubsMode_ (false)
{
}
d46 2
a47 2
{
}
d52 2
a53 2
{
WitTimer::enterSection ("mrp");
d55 1
a55 1
myPreprocessor ()->preprocess ();
d57 1
a57 1
init ();
d59 1
a59 1
explodeAllParts ();
d61 1
a61 1
finish ();
d63 2
a64 2
WitTimer::leaveSection ("mrp");
}
d69 2
a70 2
{
}
d75 29
a103 29
{
WitPart *     thePart;
WitPeriod     thePer;
WitSubEntry * theSub;

initDerived ();

netSupplyVol_.allocate (myProblem (), 0.0);
myReqVol_    .allocate (myProblem (), 0.0);

forEachPart (thePart, myProblem ())
{
myReqVol_ (thePart) = 0.0;

forEachPeriod (thePer, myProblem ())
netSupplyVol_ (thePart)[thePer] = supplyVol (thePart, thePer);
}

netSubsMode_ = false;

hasSubsToNetVec_.resize (myCompMgr ()->nBomEntries (), false);

forEachSubEntry (theSub, myProblem ())
if (theSub->mrpNetAllowed ())
{
netSubsMode_                       = true;
hasSubsToNet (theSub->myBomEnt ()) = true;
}
}
d108 33
a140 33
{
WitPart * thePart;
WitPeriod thePer;
bool      success;

WitObjStack <WitPart> reversedParts (myProblem ());

revCopyInto (reversedParts, myCompMgr ()->allParts ());

while (reversedParts.pop (thePart))
forEachPeriod (thePer, myProblem ())
{
myReqVol_ (thePart)[thePer] += demandVol (thePart, thePer);

myReqVol_ (thePart)[thePer] =
thePart->net (
thePer,
myReqVol_     (thePart)[thePer],
netSupplyVol_ (thePart));

if (myReqVol_ (thePart)[thePer] > FLOAT_EPSILON)
{
success = explode (thePart, thePer);

if (not success)
if (myGlobalComp ()->roundReqVols ())
myReqVol_ (thePart)[thePer] =
ceil (myReqVol_ (thePart)[thePer]);
}
else
myReqVol_ (thePart)[thePer] = 0.0;
}
}
d145 8
a152 8
{
WitPeriod      expPer;
WitBopEntry *  theExpBopEntry;
WitOperation * theOpn;
WitPeriod      execPer;
double         qty;
WitBomEntry *  theBomEnt;
WitBopEntry *  theBopEnt;
d154 1
a154 1
expPer = thePart->explosionPeriod (fillPer);
d156 2
a157 2
if (not thePart->explodeable (expPer))
return false;
d159 3
a161 3
theExpBopEntry = thePart       ->expBopEntry   (expPer);
theOpn         = theExpBopEntry->myOperation   ();
execPer        = theExpBopEntry->expExecPeriod ()[expPer];
d163 1
a163 1
qty = myReqVol_ (thePart)[fillPer] / theExpBopEntry->effProdRate ()[execPer];
d165 1
a165 1
qty = theOpn->lotSizeDelta (execPer, execVol (theOpn, execPer), qty);
d167 2
a168 2
if (qty <= FLOAT_EPSILON)
return false;
d170 1
a170 1
execVol (theOpn, execPer) += qty;
d172 2
a173 2
forEachEl (theBomEnt, theOpn->bom ())
explodeBomEntry (theBomEnt, execPer, qty);
d175 2
a176 2
forEachEl (theBopEnt, theOpn->bop ())
explodeBopEntry (theBopEnt, execPer, qty);
d178 4
a181 4
thePart->net (
fillPer,
myReqVol_     (thePart)[fillPer],
netSupplyVol_ (thePart));
d183 1
a183 1
myReqVol_ (thePart)[fillPer]  = 0.0;
d185 2
a186 2
return true;
}
d191 30
a220 30
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        qty)
{
double    reqQty;
WitPart * thePart;
WitPeriod consPer;


if (not theBomEnt->inEffect (execPer))
return;

if (myCompMgr ()->hasSubEntries ())
if (theBomEnt->hasSubsInEffect ()[execPer])
if (hasSubsToNet (theBomEnt))
netConsEntries (theBomEnt, execPer, qty);

reqQty = qty * theBomEnt->effConsRate ()[execPer];

if (fabs (reqQty) <= FLOAT_EPSILON)
return;

thePart = theBomEnt->myPart ();
consPer = theBomEnt->impactPeriod ()[execPer];

if (reqQty > 0.0)
myReqVol_     (thePart)[consPer] += reqQty;
else
netSupplyVol_ (thePart)[consPer] -= reqQty;
}
d225 26
a250 26
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double &      qty)
{
WitSubEntry * theSub;
double        oldQty;

netConsEntry (theBomEnt, execPer, qty);

if (qty < NET_TOL)
return;

forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->mrpNetAllowed ())
if (theSub->inEffect (execPer))
{
oldQty = qty;

netConsEntry (theSub, execPer, qty);

subVol (theSub, execPer) += positivePart (oldQty - qty);

if (qty < NET_TOL)
return;
}
}
d255 31
a285 31
WitConsEntry * theConsEnt,
WitPeriod      execPer,
double &       qty)
{
double    reqConsQty;
WitPart * thePart;
WitPeriod consPer;
double    netConsQty;


reqConsQty = theConsEnt->effConsRate ()[execPer] * qty;
thePart    = theConsEnt->myPart ();
consPer    = theConsEnt->impactPeriod ()[execPer];

if (theConsEnt->effConsRate ()[execPer] >= FLOAT_EPSILON)
{
netConsQty = thePart->net (consPer, reqConsQty, netSupplyVol_ (thePart));

qty = netConsQty / theConsEnt->effConsRate ()[execPer];

if (qty <= NET_TOL)
qty = 0.0;
}
else
{
if (theConsEnt->effConsRate ()[execPer] <= - FLOAT_EPSILON)
netSupplyVol_ (thePart)[consPer] -= reqConsQty;

qty = 0.0;
}
}
d290 16
a305 16
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        qty)
{
WitPeriod prodPer;
double    prodQty;

if (not theBopEnt->inEffect (execPer))
return;

prodPer =       theBopEnt->impactPeriod ()[execPer];
prodQty = qty * theBopEnt->effProdRate  ()[execPer];

if (prodQty > FLOAT_EPSILON)
netSupplyVol_ (theBopEnt->myPart ())[prodPer] += prodQty;
}
d310 3
a312 3
{
return hasSubsToNetVec_[theBomEnt->mappingIndex ()];
}
d317 2
a318 2
{
finishDerived ();
d320 4
a323 4
hasSubsToNetVec_.clear ();
myReqVol_       .clear ();
netSupplyVol_   .clear ();
}
d330 1
a330 1
WitMrpExp   (theProblem),
d332 6
a337 6
exploding_     (false),
uploadingSoln_ (false),
mrpExecVol_    (),
mrpSubVol_     ()
{
}
d342 2
a343 2
{
}
d348 2
a349 2
{
myMsgFac () ("mrpMsg");
d351 2
a352 2
mrpExecVol_.allocate (myProblem (), 0.0);
mrpSubVol_ .allocate (myProblem (), 0.0);
d354 2
a355 2
exploding_ = true;
}
d360 3
a362 3
{
return thePart->supplyVol ()[thePer];
}
d367 3
a369 3
{
WitDemand * theDemand;
double      theDemandVol;
d371 1
a371 1
theDemandVol = 0.0;
d373 2
a374 2
forEachEl (theDemand, thePart->myDemands ())
theDemandVol += theDemand->demandVol ()[thePer];
d376 2
a377 2
return theDemandVol;
}
d382 3
a384 3
{
return mrpExecVol_ (theOpn)[thePer];
}
d389 3
a391 3
{
return mrpSubVol_ (theSub)[thePer];
}
d396 2
a397 2
{
exploding_ = false;
d399 1
a399 1
uploadSoln ();
d401 3
a403 3
mrpExecVol_.clear ();
mrpSubVol_ .clear ();
}
d408 4
a411 4
{
WitPart *      thePart;
WitOperation * theOpn;
WitSubEntry *  theSub;
d413 1
a413 1
uploadingSoln_ = true;
d415 5
a419 5
forEachPart (thePart, myProblem ())
{
thePart->storeMrpReqVol         (myReqVol     () (thePart));
thePart->storeMrpMrpResidualVol (netSupplyVol () (thePart));
}
d421 2
a422 2
forEachOperation (theOpn, myProblem ())
theOpn->storeMrpMrpExecVol (mrpExecVol_ (theOpn));
d424 2
a425 2
forEachSubEntry (theSub, myProblem ())
theSub->storeMrpMrpSubVol (mrpSubVol_ (theSub));
d427 1
a427 1
compMrpConsVols ();
d429 2
a430 2
uploadingSoln_ = false;
}
d435 48
a482 48
{
WitPart *        thePart;
WitBomEntry *    theBomEnt;
WitSubEntry *    theSub;
WitPeriod        thePer;
WitTVec <double> mrpNonSubVolVec (myProblem (), 0.0);
WitTVec <double> mrpSubVolVec    (myProblem (), 0.0);
WitTVec <double> mrpConsVolVec   (myProblem (), 0.0);
double           totMrpSubVol;

forEachPart (thePart, myProblem ())
{
mrpConsVolVec = 0.0;

forEachEl (theBomEnt, thePart->consumingBomEntries ())
{
if (netSubsMode () and not theBomEnt->mySubEntries ().isEmpty ())
forEachPeriod (thePer, myProblem ())
{
totMrpSubVol = 0.0;

forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->mrpNetAllowed ())
if (theSub->inEffect (thePer))
totMrpSubVol += theSub->mrpSubVol ()[thePer];

mrpNonSubVolVec[thePer] =
mrpExecVol_ (theBomEnt->myOperation ())[thePer]
- totMrpSubVol;
}
else
mrpNonSubVolVec = mrpExecVol_ (theBomEnt->myOperation ());

theBomEnt->incConsVol (mrpConsVolVec, mrpNonSubVolVec);
}

if (netSubsMode ())
forEachEl (theSub, thePart->consumingSubEntries ())
if (theSub->mrpNetAllowed ())
{
mrpSubVolVec = theSub->mrpSubVol ();

theSub->incConsVol (mrpConsVolVec, mrpSubVolVec);
}

thePart->storeMrpMrpConsVol (mrpConsVolVec);
}
}
@


1.67
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d37 1
a37 1
      WitProbAssoc (theProblem),
d39 3
a41 3
      netSubsMode_ (false)
   {
   }
d46 2
a47 2
   {
   }
d52 2
a53 2
   {
   WitTimer::enterSection ("mrp");
d55 1
a55 1
   myPreprocessor ()->preprocess ();
d57 1
a57 1
   init ();
d59 1
a59 1
   explodeAllParts ();
d61 1
a61 1
   finish ();
d63 2
a64 2
   WitTimer::leaveSection ("mrp");
   }
d69 2
a70 2
   {
   }
d75 29
a103 29
   {
   WitPart *     thePart;
   WitPeriod     thePer;
   WitSubEntry * theSub;

   initDerived ();

   netSupplyVol_.allocate (myProblem (), 0.0);
   myReqVol_    .allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      myReqVol_ (thePart) = 0.0;

      forEachPeriod (thePer, myProblem ())
         netSupplyVol_ (thePart)[thePer] = supplyVol (thePart, thePer);
      }

   netSubsMode_ = false;

   hasSubsToNetVec_.resize (myCompMgr ()->nBomEntries (), false);

   forEachSubEntry (theSub, myProblem ())
      if (theSub->mrpNetAllowed ())
         {
         netSubsMode_                       = true;
         hasSubsToNet (theSub->myBomEnt ()) = true;
         }
   }
d108 33
a140 33
   {
   WitPart * thePart;
   WitPeriod thePer;
   bool      success;

   WitObjStack <WitPart> reversedParts (myProblem ());

   revCopyInto (reversedParts, myCompMgr ()->allParts ());

   while (reversedParts.pop (thePart))
      forEachPeriod (thePer, myProblem ())
         {
         myReqVol_ (thePart)[thePer] += demandVol (thePart, thePer);

         myReqVol_ (thePart)[thePer] =
            thePart->net (
               thePer, 
               myReqVol_     (thePart)[thePer], 
               netSupplyVol_ (thePart));

         if (myReqVol_ (thePart)[thePer] > FLOAT_EPSILON)
            {
            success = explode (thePart, thePer);

            if (not success)
               if (myGlobalComp ()->roundReqVols ())
                  myReqVol_ (thePart)[thePer] = 
                     ceil (myReqVol_ (thePart)[thePer]);
            }
         else
            myReqVol_ (thePart)[thePer] = 0.0;
         }
   }
d145 8
a152 8
   {
   WitPeriod      expPer;
   WitBopEntry *  theExpBopEntry;
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         qty;
   WitBomEntry *  theBomEnt;
   WitBopEntry *  theBopEnt;
d154 1
a154 1
   expPer = thePart->explosionPeriod (fillPer);
d156 2
a157 2
   if (not thePart->explodeable (expPer))
      return false;
d159 3
a161 3
   theExpBopEntry = thePart       ->expBopEntry   (expPer);
   theOpn         = theExpBopEntry->myOperation   ();
   execPer        = theExpBopEntry->expExecPeriod ()[expPer];
d163 1
a163 1
   qty = myReqVol_ (thePart)[fillPer] / theExpBopEntry->effProdRate ()[execPer];
d165 1
a165 1
   qty = theOpn->lotSizeDelta (execPer, execVol (theOpn, execPer), qty);
d167 2
a168 2
   if (qty <= FLOAT_EPSILON)
       return false;
d170 1
a170 1
   execVol (theOpn, execPer) += qty;
d172 2
a173 2
   forEachEl (theBomEnt, theOpn->bom ())
      explodeBomEntry (theBomEnt, execPer, qty);
d175 2
a176 2
   forEachEl (theBopEnt, theOpn->bop ())
      explodeBopEntry (theBopEnt, execPer, qty);
d178 4
a181 4
   thePart->net (
      fillPer,
      myReqVol_     (thePart)[fillPer],
      netSupplyVol_ (thePart));
d183 1
a183 1
   myReqVol_ (thePart)[fillPer]  = 0.0;
d185 2
a186 2
   return true;
   }
d191 30
a220 30
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        qty)
   {
   double    reqQty;
   WitPart * thePart;
   WitPeriod consPer;


   if (not theBomEnt->inEffect (execPer))
      return;

   if (myCompMgr ()->hasSubEntries ())
      if (theBomEnt->hasSubsInEffect ()[execPer])
         if (hasSubsToNet (theBomEnt))
            netConsEntries (theBomEnt, execPer, qty);

   reqQty = qty * theBomEnt->effConsRate ()[execPer];

   if (fabs (reqQty) <= FLOAT_EPSILON)
      return;

   thePart = theBomEnt->myPart ();
   consPer = theBomEnt->impactPeriod ()[execPer];

   if (reqQty > 0.0)
      myReqVol_     (thePart)[consPer] += reqQty;
   else
      netSupplyVol_ (thePart)[consPer] -= reqQty;
   }
d225 26
a250 26
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double &      qty)
   {
   WitSubEntry * theSub;
   double        oldQty;

   netConsEntry (theBomEnt, execPer, qty);

   if (qty < NET_TOL)
      return;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->mrpNetAllowed ())
         if (theSub->inEffect (execPer))
            {
            oldQty = qty;

            netConsEntry (theSub, execPer, qty);

            subVol (theSub, execPer) += positivePart (oldQty - qty);

            if (qty < NET_TOL)
               return;
            }
   }
d255 31
a285 31
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double &       qty)
   {
   double    reqConsQty;
   WitPart * thePart;
   WitPeriod consPer;
   double    netConsQty;


   reqConsQty = theConsEnt->effConsRate ()[execPer] * qty;
   thePart    = theConsEnt->myPart ();
   consPer    = theConsEnt->impactPeriod ()[execPer];

   if (theConsEnt->effConsRate ()[execPer] >= FLOAT_EPSILON)
      {
      netConsQty = thePart->net (consPer, reqConsQty, netSupplyVol_ (thePart));

      qty = netConsQty / theConsEnt->effConsRate ()[execPer];

      if (qty <= NET_TOL)
         qty = 0.0;
      }
   else
      {
      if (theConsEnt->effConsRate ()[execPer] <= - FLOAT_EPSILON)
         netSupplyVol_ (thePart)[consPer] -= reqConsQty;

      qty = 0.0;
      }
   }
d290 16
a305 16
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        qty)
   {
   WitPeriod prodPer;
   double    prodQty;

   if (not theBopEnt->inEffect (execPer))
      return;

   prodPer =       theBopEnt->impactPeriod ()[execPer];
   prodQty = qty * theBopEnt->effProdRate  ()[execPer];

   if (prodQty > FLOAT_EPSILON)
      netSupplyVol_ (theBopEnt->myPart ())[prodPer] += prodQty;
   }
d310 3
a312 3
   {
   return hasSubsToNetVec_[theBomEnt->mappingIndex ()];
   }
d317 2
a318 2
   {
   finishDerived ();
d320 4
a323 4
   hasSubsToNetVec_.clear ();
   myReqVol_       .clear ();
   netSupplyVol_   .clear ();
   }
d330 1
a330 1
      WitMrpExp   (theProblem),
d332 6
a337 6
      exploding_     (false),
      uploadingSoln_ (false),
      mrpExecVol_    (),
      mrpSubVol_     ()
   {                  
   }
d342 2
a343 2
   {
   }
d348 2
a349 2
   {
   myMsgFac () ("mrpMsg");
d351 2
a352 2
   mrpExecVol_.allocate (myProblem (), 0.0);
   mrpSubVol_ .allocate (myProblem (), 0.0);
d354 2
a355 2
   exploding_ = true;
   }
d360 3
a362 3
   {
   return thePart->supplyVol ()[thePer];
   }
d367 3
a369 3
   {
   WitDemand * theDemand;
   double      theDemandVol;
d371 1
a371 1
   theDemandVol = 0.0;
d373 2
a374 2
   forEachEl (theDemand, thePart->myDemands ())
      theDemandVol += theDemand->demandVol ()[thePer];
d376 2
a377 2
   return theDemandVol;
   }
d382 3
a384 3
   {
   return mrpExecVol_ (theOpn)[thePer];
   }
d389 3
a391 3
   {
   return mrpSubVol_ (theSub)[thePer];
   }
d396 2
a397 2
   {
   exploding_ = false;
d399 1
a399 1
   uploadSoln ();
d401 3
a403 3
   mrpExecVol_.clear ();
   mrpSubVol_ .clear ();
   }
d408 4
a411 4
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitSubEntry *  theSub;
d413 1
a413 1
   uploadingSoln_ = true;
d415 5
a419 5
   forEachPart (thePart, myProblem ())
      {
      thePart->storeMrpReqVol         (myReqVol     () (thePart));
      thePart->storeMrpMrpResidualVol (netSupplyVol () (thePart));
      }
d421 2
a422 2
   forEachOperation (theOpn, myProblem ())
      theOpn->storeMrpMrpExecVol (mrpExecVol_ (theOpn));
d424 2
a425 2
   forEachSubEntry (theSub, myProblem ())
      theSub->storeMrpMrpSubVol (mrpSubVol_ (theSub));
d427 1
a427 1
   compMrpConsVols ();
d429 2
a430 2
   uploadingSoln_ = false;
   }
d435 48
a482 48
   {
   WitPart *        thePart;
   WitBomEntry *    theBomEnt;
   WitSubEntry *    theSub;
   WitPeriod        thePer;
   WitTVec <double> mrpNonSubVolVec (myProblem (), 0.0);
   WitTVec <double> mrpSubVolVec    (myProblem (), 0.0);
   WitTVec <double> mrpConsVolVec   (myProblem (), 0.0);
   double           totMrpSubVol;

   forEachPart (thePart, myProblem ())
      {
      mrpConsVolVec = 0.0;

      forEachEl (theBomEnt, thePart->consumingBomEntries ())
         {
         if (netSubsMode () and not theBomEnt->mySubEntries ().isEmpty ())
            forEachPeriod (thePer, myProblem ())
               {
               totMrpSubVol = 0.0;

               forEachEl (theSub, theBomEnt->mySubEntries ())
                  if (theSub->mrpNetAllowed ())
                     if (theSub->inEffect (thePer))
                        totMrpSubVol += theSub->mrpSubVol ()[thePer];

               mrpNonSubVolVec[thePer] =
                    mrpExecVol_ (theBomEnt->myOperation ())[thePer]
                  - totMrpSubVol;
               }
         else
            mrpNonSubVolVec = mrpExecVol_ (theBomEnt->myOperation ());

         theBomEnt->incConsVol (mrpConsVolVec, mrpNonSubVolVec);
         }

      if (netSubsMode ())
         forEachEl (theSub, thePart->consumingSubEntries ())
            if (theSub->mrpNetAllowed ())
               {
               mrpSubVolVec = theSub->mrpSubVol ();

               theSub->incConsVol (mrpConsVolVec, mrpSubVolVec);
               }

      thePart->storeMrpMrpConsVol (mrpConsVolVec);
      }
   }
@


1.66
log
@Heuristic Adjustment
@
text
@d165 1
a165 6
   qty =
      theOpn->lotSizeDelta (
         execPer,
         execVol (theOpn, execPer),
         qty,
         true);
@


1.65
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d24 1
a24 1
#include <Opn.h>
@


1.64
log
@Stochastic Implosion
@
text
@d21 1
a21 1
#include <Global.h>
@


1.63
log
@Fixed bug:
   witMrp gave incorrect results when called a second time.
@
text
@d337 4
a340 7
      exploding_      (false),
      passRefsComp_   (NULL),
      reqVol_         (),
      mrpConsVol_     (),
      mrpResidualVol_ (),
      mrpExecVol_     (),
      mrpSubVol_      ()
a351 26
void WitOrigMrpExp::receivePartRefs (
      WitDblFlexVec & reqVolRef,
      WitDblFlexVec & mrpConsVolRef,
      WitDblFlexVec & mrpResidualVolRef)
   {
   reqVol_        .setMapFor (passRefsComp ()->thisPart (), reqVolRef);
   mrpConsVol_    .setMapFor (passRefsComp ()->thisPart (), mrpConsVolRef);
   mrpResidualVol_.setMapFor (passRefsComp ()->thisPart (), mrpResidualVolRef);
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::receiveOperationRefs (WitDblFlexVec & mrpExecVolRef)
   {
   mrpExecVol_.setMapFor (passRefsComp ()->thisOpn (), mrpExecVolRef);
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::receiveSubEntryRefs (WitDblFlexVec & mrpSubVolRef)
   {
   mrpSubVol_.setMapFor (passRefsComp ()->thisSub (), mrpSubVolRef);
   }

//------------------------------------------------------------------------------

a353 3
   WitOperation * theOpn;
   WitSubEntry *  theSub;

d356 2
a357 8
   reqVol_        .allocate (myProblem ());
   mrpConsVol_    .allocate (myProblem ());
   mrpResidualVol_.allocate (myProblem ());
   mrpExecVol_    .allocate (myProblem ());
   mrpSubVol_     .allocate (myProblem ());

   forEachEl (passRefsComp_, myCompMgr ()->allComponents ())
      passRefsComp_->passMrpRefs ();
d359 1
a359 9
   passRefsComp_ = NULL;

   forEachOperation (theOpn, myProblem ())
      mrpExecVol_ (theOpn) = 0.0;

   forEachSubEntry (theSub, myProblem ())
      mrpSubVol_  (theSub) = 0.0;

   exploding_    = true;
d388 1
a388 1
   return mrpExecVol_ (theOpn).elemRef (thePer);
d395 1
a395 1
   return mrpSubVol_ (theSub).elemRef (thePer);
d402 3
a404 1
   WitPart * thePart;
d406 11
a416 1
   exploding_ = false;
d418 1
a418 1
   compMrpConsVols ();
d422 2
a423 2
      reqVol_         (thePart) = myReqVol     () (thePart);
      mrpResidualVol_ (thePart) = netSupplyVol () (thePart);
d426 9
a434 5
   reqVol_        .clear ();
   mrpConsVol_    .clear ();
   mrpResidualVol_.clear ();
   mrpExecVol_    .clear ();
   mrpSubVol_     .clear ();
d467 1
a467 1
                    theBomEnt->myOperation ()->mrpExecVol ()[thePer]
d471 1
a471 1
            mrpNonSubVolVec = theBomEnt->myOperation ()->mrpExecVol ();
d485 1
a485 1
      mrpConsVol_ (thePart) = mrpConsVolVec;
@


1.62
log
@Stochastic Implosion
@
text
@d383 3
d399 6
@


1.61
log
@Stochastic Implosion
@
text
@d356 3
a358 3
      WitDblFlexVec & reqVolArg,
      WitDblFlexVec & mrpConsVolArg,
      WitDblFlexVec & mrpResidualVolArg)
d360 3
a362 3
   reqVol_        .setMapFor (passRefsComp ()->thisPart (), reqVolArg);
   mrpConsVol_    .setMapFor (passRefsComp ()->thisPart (), mrpConsVolArg);
   mrpResidualVol_.setMapFor (passRefsComp ()->thisPart (), mrpResidualVolArg);
d367 1
a367 1
void WitOrigMrpExp::receiveOperationRefs (WitDblFlexVec & mrpExecVolArg)
d369 1
a369 1
   mrpExecVol_.setMapFor (passRefsComp ()->thisOpn (), mrpExecVolArg);
d374 1
a374 1
void WitOrigMrpExp::receiveSubEntryRefs (WitDblFlexVec & mrpSubVolArg)
d376 1
a376 1
   mrpSubVol_.setMapFor (passRefsComp ()->thisSub (), mrpSubVolArg);
@


1.60
log
@Stochastic Implosion
@
text
@d338 1
a338 1
      passDataComp_   (NULL),
d355 1
a355 1
void WitOrigMrpExp::receivePartData (
d360 3
a362 3
   reqVol_        .setMapFor (passDataComp ()->thisPart (), reqVolArg);
   mrpConsVol_    .setMapFor (passDataComp ()->thisPart (), mrpConsVolArg);
   mrpResidualVol_.setMapFor (passDataComp ()->thisPart (), mrpResidualVolArg);
d367 1
a367 1
void WitOrigMrpExp::receiveOperationData (WitDblFlexVec & mrpExecVolArg)
d369 1
a369 1
   mrpExecVol_.setMapFor (passDataComp ()->thisOpn (), mrpExecVolArg);
d374 1
a374 1
void WitOrigMrpExp::receiveSubEntryData (WitDblFlexVec & mrpSubVolArg)
d376 1
a376 1
   mrpSubVol_.setMapFor (passDataComp ()->thisSub (), mrpSubVolArg);
d391 2
a392 2
   forEachEl (passDataComp_, myCompMgr ()->allComponents ())
      passDataComp_->passMrpData ();
d394 1
a394 1
   passDataComp_ = NULL;
d396 1
a396 1
   exploding_ = true;
@


1.59
log
@Stochastic Implosion
@
text
@d338 1
d355 1
a355 2
void WitOrigMrpExp::receiveData (
      WitPart *       thePart,
d360 3
a362 3
   reqVol_        .setMapFor (thePart, reqVolArg);
   mrpConsVol_    .setMapFor (thePart, mrpConsVolArg);
   mrpResidualVol_.setMapFor (thePart, mrpResidualVolArg);
d367 1
a367 3
void WitOrigMrpExp::receiveData (
      WitOperation *  theOpn,
      WitDblFlexVec & mrpExecVolArg)
d369 1
a369 1
   mrpExecVol_.setMapFor (theOpn, mrpExecVolArg);
d374 1
a374 3
void WitOrigMrpExp::receiveData (
      WitSubEntry *   theSub,
      WitDblFlexVec & mrpSubVolArg)
d376 1
a376 1
   mrpSubVol_.setMapFor (theSub, mrpSubVolArg);
a382 2
   WitComponent * theComp;

d391 4
a394 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->passMrpData ();
@


1.58
log
@Stochastic Implosion
@
text
@d337 7
a343 6
      exploding_  (false),
      exporting_  (false),
      mrpConsVol_ (),
      mrpExecVol_ (),
      mrpSubVol_  ()
   {
d354 5
a358 1
const WitTVec <double> & WitOrigMrpExp::reqVol (WitPart * thePart)
d360 3
a362 3
   witAssert (exporting_);

   return myReqVol () (thePart);
d367 3
a369 1
const WitTVec <double> & WitOrigMrpExp::mrpConsVol (WitPart * thePart)
d371 1
a371 3
   witAssert (exporting_);

   return mrpConsVol_ (thePart);
d376 3
a378 1
const WitTVec <double> & WitOrigMrpExp::mrpResidualVol (WitPart * thePart)
d380 1
a380 3
   witAssert (exporting_);

   return netSupplyVol () (thePart);
d385 1
a385 1
const WitTVec <double> & WitOrigMrpExp::mrpExecVol (WitOperation * theOpn)
d387 1
a387 1
   witAssert (exporting_);
d389 1
a389 2
   return mrpExecVol_ (theOpn);
   }
d391 5
a395 1
//------------------------------------------------------------------------------
d397 2
a398 15
const WitTVec <double> & WitOrigMrpExp::mrpSubVol (WitSubEntry * theSub)
   {
   witAssert (exporting_);

   return mrpSubVol_ (theSub);
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::initDerived ()
   {
   myMsgFac () ("mrpMsg");

   mrpExecVol_.allocate (myProblem (), 0.0);
   mrpSubVol_ .allocate (myProblem (), 0.0);
d429 1
a429 1
   return mrpExecVol_ (theOpn)[thePer];
d436 1
a436 1
   return mrpSubVol_ (theSub)[thePer];
d443 1
a443 1
   WitComponent * theComp;
d449 1
a449 3
   exporting_ = true;

   forEachEl (theComp, myCompMgr ()->allComponents ())
d451 2
a452 1
      theComp->importMrpSoln ();
d455 5
a459 5
   exporting_ = false;

   mrpConsVol_.clear ();
   mrpExecVol_.clear ();
   mrpSubVol_ .clear ();
d471 2
a474 2
   mrpConsVol_.allocate (myProblem (), 0.0);

d477 1
a477 1
      mrpConsVol_ (thePart) = 0.0;
d489 1
a489 1
                        totMrpSubVol += mrpSubVol_ (theSub)[thePer];
d492 1
a492 1
                    mrpExecVol_ (theBomEnt->myOperation ())[thePer]
d496 1
a496 1
            mrpNonSubVolVec = mrpExecVol_ (theBomEnt->myOperation ());
d498 1
a498 1
         theBomEnt->incConsVol (mrpConsVol_ (thePart), mrpNonSubVolVec);
d505 3
a507 1
               theSub->incConsVol (mrpConsVol_ (thePart), mrpSubVol_ (theSub));
d509 2
@


1.57
log
@[disallowed backlog]
@
text
@d22 1
d24 3
a27 1
#include <MrpAccess.h>
d168 1
a168 1
         execVol (theOpn)[execPer],
d175 1
a175 1
   execVol (theOpn).elemRef (execPer) += qty;
d250 1
a250 1
            subVol (theSub).elemRef (execPer) += positivePart (oldQty - qty);
d335 1
a335 1
      WitMrpExp  (theProblem),
d337 5
a341 1
      exploding_ (false)
d353 45
a399 3
   WitOperation * theOpn;
   WitSubEntry *  theSub;

d402 2
a403 6
   forEachOperation (theOpn, myProblem ())
      WitMrpAccess::mrpExecVol (theOpn) = 0.0;

   forEachSubEntry (theSub, myProblem ())
      if (theSub->mrpNetAllowed ())
         WitMrpAccess::mrpSubVol (theSub) = 0.0;
d432 1
a432 1
WitDblFlexVec & WitOrigMrpExp::execVol (WitOperation * theOpn)
d434 1
a434 1
   return WitMrpAccess::mrpExecVol (theOpn);
d439 1
a439 1
WitDblFlexVec & WitOrigMrpExp::subVol (WitSubEntry * theSub)
d441 1
a441 1
   return WitMrpAccess::mrpSubVol (theSub);
d448 1
a448 1
   WitPart * thePart;
d452 5
a456 1
   forEachPart (thePart, myProblem ())
d458 1
a458 2
      WitMrpAccess::reqVol         (thePart) = myReqVol     () (thePart);
      WitMrpAccess::mrpResidualVol (thePart) = netSupplyVol () (thePart);
d461 5
a465 1
   compMrpConsVols ();
a475 1
   WitTVec <double> mrpConsVolVec   (myProblem (), 0.0);
a476 1
   WitTVec <double> mrpSubVolVec    (myProblem (), 0.0);
d479 2
d483 1
a483 1
      mrpConsVolVec = 0.0;
d495 1
a495 1
                        totMrpSubVol += theSub->mrpSubVol ()[thePer];
d498 1
a498 1
                    theBomEnt->myOperation ()->mrpExecVol ()[thePer]
d502 1
a502 1
            mrpNonSubVolVec = theBomEnt->myOperation ()->mrpExecVol ();
d504 1
a504 1
         theBomEnt->incConsVol (mrpConsVolVec, mrpNonSubVolVec);
d511 1
a511 3
               mrpSubVolVec = theSub->mrpSubVol ();

               theSub->incConsVol (mrpConsVolVec, mrpSubVolVec);
a512 2

      WitMrpAccess::mrpConsVol (thePart) = mrpConsVolVec;
@


1.56
log
@Rescinded all changed made since 1/31/07.
@
text
@d24 1
a330 12
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec      WitPart::* WitOrigMrpExp::reqVol_         = NULL;
WitDblFlexVec      WitPart::* WitOrigMrpExp::mrpConsVol_     = NULL;
WitDblFlexVec      WitPart::* WitOrigMrpExp::mrpResidualVol_ = NULL;
WitDblFlexVec WitOperation::* WitOrigMrpExp::mrpExecVol_     = NULL;
WitDblFlexVec  WitSubEntry::* WitOrigMrpExp::mrpSubVol_      = NULL;

//------------------------------------------------------------------------------

a345 26
void WitOrigMrpExp::receiveDMPs (
      WitDblFlexVec WitPart::* reqVolArg,
      WitDblFlexVec WitPart::* mrpConsVolArg,
      WitDblFlexVec WitPart::* mrpResidualVolArg)
   {
   reqVol_         = reqVolArg;
   mrpConsVol_     = mrpConsVolArg;
   mrpResidualVol_ = mrpResidualVolArg;
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::receiveDMPs (WitDblFlexVec WitOperation::* mrpExecVolArg)
   {
   mrpExecVol_ = mrpExecVolArg;
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::receiveDMPs (WitDblFlexVec WitSubEntry::* mrpSubVolArg)
   {
   mrpSubVol_ = mrpSubVolArg;
   }

//------------------------------------------------------------------------------

d354 1
a354 1
      theOpn->*mrpExecVol_ = 0.0;
d358 1
a358 1
         theSub->*mrpSubVol_ = 0.0;
d389 1
a389 1
   return theOpn->*mrpExecVol_;
d396 1
a396 1
   return theSub->*mrpSubVol_;
d409 2
a410 2
      thePart->*reqVol_         = myReqVol     () (thePart);
      thePart->*mrpResidualVol_ = netSupplyVol () (thePart);
d464 1
a464 1
      thePart->*mrpConsVol_ = mrpConsVolVec;
@


1.55
log
@[disallowed backlog]
@
text
@d330 12
d357 26
d391 1
a391 1
      theOpn->mrpExecVol_ () = 0.0;
d395 1
a395 1
         theSub->mrpSubVol_ () = 0.0;
d426 1
a426 1
   return theOpn->mrpExecVol_ ();
d433 1
a433 1
   return theSub->mrpSubVol_ ();
d446 2
a447 2
      thePart->reqVol_         () = myReqVol     () (thePart);
      thePart->mrpResidualVol_ () = netSupplyVol () (thePart);
d501 1
a501 1
      thePart->mrpConsVol_ () = mrpConsVolVec;
@


1.54
log
@[disallowed backlog]
@
text
@a329 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec WitSubEntry::* WitOrigMrpExp::mrpSubVol_ = NULL;

//------------------------------------------------------------------------------

a344 7
void WitOrigMrpExp::receiveDMPs (WitDblFlexVec WitSubEntry::* mrpSubVolArg)
   {
   mrpSubVol_ = mrpSubVolArg;
   }

//------------------------------------------------------------------------------

d353 1
a353 1
      theOpn->mrpExecVol_.forUpdate () = 0.0;
d357 1
a357 1
         theSub->*mrpSubVol_ = 0.0;
d388 1
a388 1
   return theOpn->mrpExecVol_.forUpdate ();
d395 1
a395 1
   return theSub->*mrpSubVol_;
d408 2
a409 2
      thePart->reqVol_        .forUpdate () = myReqVol     () (thePart);
      thePart->mrpResidualVol_.forUpdate () = netSupplyVol () (thePart);
d463 1
a463 1
      thePart->mrpConsVol_.forUpdate () = mrpConsVolVec;
@


1.53
log
@[disallowed backlog]
@
text
@d334 1
a334 2
WitDblFlexVec WitOperation::* WitOrigMrpExp::mrpExecVol_ = NULL;
WitDblFlexVec  WitSubEntry::* WitOrigMrpExp::mrpSubVol_  = NULL;
a352 7
void WitOrigMrpExp::receiveDMPs (WitDblFlexVec WitOperation::* mrpExecVolArg)
   {
   mrpExecVol_ = mrpExecVolArg;
   }

//------------------------------------------------------------------------------

d368 1
a368 1
      theOpn->*mrpExecVol_ = 0.0;
d403 1
a403 1
   return theOpn->*mrpExecVol_;
@


1.52
log
@App controlled opt implosion.
@
text
@d334 2
a335 5
WitDblFlexVec      WitPart::* WitOrigMrpExp::reqVol_         = NULL;
WitDblFlexVec      WitPart::* WitOrigMrpExp::mrpConsVol_     = NULL;
WitDblFlexVec      WitPart::* WitOrigMrpExp::mrpResidualVol_ = NULL;
WitDblFlexVec WitOperation::* WitOrigMrpExp::mrpExecVol_     = NULL;
WitDblFlexVec  WitSubEntry::* WitOrigMrpExp::mrpSubVol_      = NULL;
a353 12
void WitOrigMrpExp::receiveDMPs (
      WitDblFlexVec WitPart::* reqVolArg,
      WitDblFlexVec WitPart::* mrpConsVolArg,
      WitDblFlexVec WitPart::* mrpResidualVolArg)
   {
   reqVol_         = reqVolArg;
   mrpConsVol_     = mrpConsVolArg;
   mrpResidualVol_ = mrpResidualVolArg;
   }

//------------------------------------------------------------------------------

d431 2
a432 2
      thePart->*reqVol_         = myReqVol     () (thePart);
      thePart->*mrpResidualVol_ = netSupplyVol () (thePart);
d486 1
a486 1
      thePart->*mrpConsVol_ = mrpConsVolVec;
@


1.51
log
@Updated the copyright date on all source files.
@
text
@d20 1
d51 1
a51 1
   myProblem ()->preprocess ();
@


1.50
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.49
log
@Revised mappingIndex code.
@
text
@d329 12
d356 4
a359 5
void WitOrigMrpExp::loadDataFrom (
      WitPart *       thePart,
      WitDblFlexVec & reqVolArg,
      WitDblFlexVec & mrpConsVolArg,
      WitDblFlexVec & mrpResidualVolArg)
d361 3
a363 3
   reqVol_        .setMapFor (thePart, reqVolArg);
   mrpConsVol_    .setMapFor (thePart, mrpConsVolArg);
   mrpResidualVol_.setMapFor (thePart, mrpResidualVolArg);
d368 1
a368 3
void WitOrigMrpExp::loadDataFrom (
      WitOperation *  theOpn, 
      WitDblFlexVec & mrpExecVolArg)
d370 1
a370 1
   mrpExecVol_.setMapFor (theOpn, mrpExecVolArg);
d375 1
a375 3
void WitOrigMrpExp::loadDataFrom (
      WitSubEntry *   theSub, 
      WitDblFlexVec & mrpSubVolArg)
d377 1
a377 1
   mrpSubVol_.setMapFor (theSub, mrpSubVolArg);
a388 2
   loadData ();

d390 1
a390 1
      mrpExecVol_ (theOpn) = 0.0;
d394 1
a394 1
         mrpSubVol_ (theSub) = 0.0;
d425 1
a425 1
   return mrpExecVol_ (theOpn);
d432 1
a432 1
   return mrpSubVol_ (theSub);
d445 2
a446 2
      reqVol_         (thePart) = myReqVol     () (thePart);
      mrpResidualVol_ (thePart) = netSupplyVol () (thePart);
a449 29

   clearLoadedData ();
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::loadData ()
   {
   WitComponent * theComp;

   reqVol_        .allocate (myProblem ());
   mrpConsVol_    .allocate (myProblem ());
   mrpResidualVol_.allocate (myProblem ());
   mrpExecVol_    .allocate (myProblem ());
   mrpSubVol_     .allocate (myProblem ());

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->loadMrp ();
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::clearLoadedData ()
   {
   reqVol_        .clear ();
   mrpConsVol_    .clear ();
   mrpResidualVol_.clear ();
   mrpExecVol_    .clear ();
   mrpSubVol_     .clear ();
d500 1
a500 1
      mrpConsVol_ (thePart) = mrpConsVolVec;
@


1.48
log
@PIP.
@
text
@a25 1
#include <MapIdxI.h>
@


1.47
log
@Double Precision.
@
text
@d511 1
a511 1
            theBomEnt->myOperation ()->mrpExecVol ().copyInto (mrpNonSubVolVec);
d520 1
a520 1
               theSub->mrpSubVol ().copyInto (mrpSubVolVec);
@


1.46
log
@Double Precision.
@
text
@d511 1
a511 2
            theBomEnt->myOperation ()->mrpExecVol ().convCopyInto (
               mrpNonSubVolVec);
d520 1
a520 1
               theSub->mrpSubVol ().convCopyInto (mrpSubVolVec);
@


1.45
log
@Double Precision.
@
text
@d83 1
a83 1
      myReqVol_ (thePart).setToScalar (0.0);
d386 1
a386 1
      mrpExecVol_ (theOpn).setToScalar (0.0);
d390 1
a390 1
         mrpSubVol_ (theSub).setToScalar (0.0);
d441 2
a442 2
      reqVol_         (thePart).convCopy (myReqVol     () (thePart));
      mrpResidualVol_ (thePart).convCopy (netSupplyVol () (thePart));
d492 1
a492 1
      mrpConsVolVec.setToScalar (0.0);
d526 1
a526 1
      mrpConsVol_ (thePart).convCopy (mrpConsVolVec);
@


1.44
log
@Double Precision.
@
text
@d346 4
a349 4
      WitPart *             thePart,
      WitFlexVec <double> & reqVolArg,
      WitFlexVec <double> & mrpConsVolArg,
      WitFlexVec <double> & mrpResidualVolArg)
d359 2
a360 2
      WitOperation *        theOpn, 
      WitFlexVec <double> & mrpExecVolArg)
d368 2
a369 2
      WitSubEntry *         theSub, 
      WitFlexVec <double> & mrpSubVolArg)
d419 1
a419 1
WitFlexVec <double> & WitOrigMrpExp::execVol (WitOperation * theOpn)
d426 1
a426 1
WitFlexVec <double> & WitOrigMrpExp::subVol (WitSubEntry * theSub)
@


1.43
log
@Double Precision.
@
text
@d171 1
a171 1
   execVol (theOpn).incElem (execPer, qty);
d246 1
a246 1
            subVol (theSub).incElem (execPer, positivePart (oldQty - qty));
d346 4
a349 4
      WitPart *    thePart,
      WitRealVec & reqVolArg,
      WitRealVec & mrpConsVolArg,
      WitRealVec & mrpResidualVolArg)
d359 2
a360 2
      WitOperation * theOpn, 
      WitRealVec &   mrpExecVolArg)
d368 2
a369 2
      WitSubEntry * theSub, 
      WitRealVec &  mrpSubVolArg)
d419 1
a419 1
WitRealVec & WitOrigMrpExp::execVol (WitOperation * theOpn)
d426 1
a426 1
WitRealVec & WitOrigMrpExp::subVol (WitSubEntry * theSub)
@


1.42
log
@Double Precision.
@
text
@d161 6
a166 1
   qty = theOpn->lotSizeDelta (execPer, execVol (theOpn, execPer), qty, true);
d171 1
a171 1
   execVol (theOpn, execPer) += qty;
d246 1
a246 1
            subVol (theSub, execPer) += positivePart (oldQty - qty);
d359 2
a360 2
      WitOperation *       theOpn, 
      WitFlexVec <float> & mrpExecVolArg)
d368 2
a369 2
      WitSubEntry *       theSub, 
      WitFlexVec <float> & mrpSubVolArg)
d419 1
a419 1
float & WitOrigMrpExp::execVol (WitOperation * theOpn, WitPeriod execPer)
d421 1
a421 1
   return mrpExecVol_ (theOpn).elemRef (execPer);
d426 1
a426 1
float & WitOrigMrpExp::subVol (WitSubEntry * theSub, WitPeriod execPer)
d428 1
a428 1
   return mrpSubVol_ (theSub).elemRef (execPer);
d511 2
a512 3
            convCopy (
               mrpNonSubVolVec,
               theBomEnt->myOperation ()->mrpExecVol ());
d521 1
a521 1
               convCopy (mrpSubVolVec, theSub->mrpSubVol ());
@


1.41
log
@Double Precision.
@
text
@d436 2
a437 2
      reqVol_         (thePart).copyDblTVec (myReqVol     () (thePart));
      mrpResidualVol_ (thePart).copyDblTVec (netSupplyVol () (thePart));
d522 1
a522 1
      mrpConsVol_ (thePart).copyDblTVec (mrpConsVolVec);
@


1.40
log
@Double Precision.
@
text
@d506 1
a506 1
            copyInto (
d517 1
a517 1
               copyInto (mrpSubVolVec, theSub->mrpSubVol ());
@


1.39
log
@Continued implementation of PIP.
@
text
@d341 4
a344 4
      WitPart *            thePart,
      WitFlexVec <float> & reqVolArg,
      WitFlexVec <float> & mrpConsVolArg,
      WitFlexVec <float> & mrpResidualVolArg)
d436 2
a437 2
      copyInto (reqVol_         (thePart), myReqVol     () (thePart));
      copyInto (mrpResidualVol_ (thePart), netSupplyVol () (thePart));
d522 1
a522 1
      copyInto (mrpConsVol_ (thePart), mrpConsVolVec);
@


1.38
log
@Continued implementation of post-implosion pegging.
@
text
@a19 1
#include <Post.h>
d480 3
a482 2
   WitTVec <double> theMrpConsVol   (myProblem (), 0.0);
   WitTVec <float>  theMrpNonSubVol (myProblem (), 0.0);
d487 1
a487 1
      theMrpConsVol.setToScalar (0.0);
d490 1
a491 1
            {
d501 1
a501 1
               theMrpNonSubVol[thePer] =
a504 3

            incConsVol (theBomEnt, theMrpConsVol, theMrpNonSubVol);
            }
d506 2
a507 3
            incConsVol (
               theBomEnt,
               theMrpConsVol,
d510 3
d516 5
a520 1
               incConsVol (theSub, theMrpConsVol, theSub->mrpSubVol ());
d522 1
a522 1
      copyInto (mrpConsVol_ (thePart), theMrpConsVol);
@


1.37
log
@Continued implementation of post-implosion pegging.
@
text
@a26 1
#include <RefMapI.h>
@


1.36
log
@Continued implementation of post-implosion pegging.
@
text
@a26 1
#include <ScheduleI.h>
d28 1
@


1.35
log
@An attempt to fix another link error from the Windows compiler.
@
text
@a28 1
#include <FlexVecI.h>
@


1.34
log
@Continued implementation of opt with COIN.
@
text
@d114 1
a114 1
   reversedParts.revCopyOf (myCompMgr ()->allParts ());
@


1.33
log
@Tried to fix some syntax errors from the MS compiler.
@
text
@d52 1
a52 1
   WitTimingEvent theEvent ("mrp");
d61 2
@


1.32
log
@Various internal changes.
@
text
@d506 1
a506 4
            myProblem ()->myPostprocessor ()->incConsVol (
               theBomEnt,
               theMrpConsVol,
               theMrpNonSubVol);
d509 1
a509 1
            myProblem ()->myPostprocessor ()->incConsVol (
d517 1
a517 4
               myProblem ()->myPostprocessor ()->incConsVol (
                  theSub,
                  theMrpConsVol,
                  theSub->mrpSubVol ());
@


1.31
log
@Internal changes.
@
text
@d506 4
a509 1
            incConsVol (theBomEnt, theMrpConsVol, theMrpNonSubVol);
d512 1
a512 1
            incConsVol (
d520 4
a523 1
               incConsVol (theSub, theMrpConsVol, theSub->mrpSubVol ());
@


1.30
log
@Internal changes.
@
text
@d129 1
a129 1
            if (! success)
d153 1
a153 1
   if (! thePart->explodeable (expPer))
d197 1
a197 1
   if (! theBomEnt->inEffect (execPer))
d294 1
a294 1
   if (! theBopEnt->inEffect (execPer))
d490 1
a490 1
         if (netSubsMode () && ! theBomEnt->mySubEntries ().isEmpty ())
@


1.29
log
@Continued implementation of 2-level lot sizes.
@
text
@d38 1
a38 1
      netSubsMode_ (witFALSE)
d90 1
a90 1
   netSubsMode_ = witFALSE;
d92 1
a92 1
   hasSubsToNetVec_.resize (myCompMgr ()->nBomEntries (), witFALSE);
d97 2
a98 2
         netSubsMode_                       = witTRUE;
         hasSubsToNet (theSub->myBomEnt ()) = witTRUE;
d106 3
a108 3
   WitPart *  thePart;
   WitPeriod  thePer;
   WitBoolean success;
d141 1
a141 1
WitBoolean WitMrpExp::explode (WitPart * thePart, WitPeriod fillPer)
d154 1
a154 1
      return witFALSE;
d162 1
a162 2
   qty =
      theOpn->lotSizeDelta (execPer, execVol (theOpn, execPer), qty, witTRUE);
d165 1
a165 1
       return witFALSE;
d182 1
a182 1
   return witTRUE;
d306 1
a306 1
WitBoolean & WitMrpExp::hasSubsToNet (WitBomEntry * theBomEnt)
d329 1
a329 1
      exploding_ (witFALSE)
d388 1
a388 1
   exploding_ = witTRUE;
d433 1
a433 1
   exploding_ = witFALSE;
@


1.28
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d162 2
a163 6
   theOpn->lotSizeDelta (
      execPer,
      execVol (theOpn, execPer),
      qty,
      witTRUE,
      witTRUE);
@


1.27
log
@Continued implementation of Single-Source.
@
text
@d29 1
@


1.26
log
@Continued implementation of single-source.
@
text
@d27 1
@


1.25
log
@Continued implementation of single-source.
@
text
@d20 1
d85 1
a85 1
         netSupplyVol_ (thePart, thePer) = supplyVol (thePart, thePer);
d115 1
a115 1
         myReqVol_ (thePart, thePer) += demandVol (thePart, thePer);
d117 1
a117 1
         myReqVol_ (thePart, thePer) =
d120 1
a120 1
               myReqVol_     (thePart, thePer), 
d123 1
a123 1
         if (myReqVol_ (thePart, thePer) > FLOAT_EPSILON)
d129 2
a130 2
                  myReqVol_ (thePart, thePer) = 
                     ceil (myReqVol_ (thePart, thePer));
d133 1
a133 1
            myReqVol_ (thePart, thePer) = 0.0;
d158 1
a158 1
   qty = myReqVol_ (thePart, fillPer) / theExpBopEntry->effProdRate ()[execPer];
d180 1
a180 1
      myReqVol_     (thePart, fillPer),
d183 1
a183 1
   myReqVol_ (thePart, fillPer)  = 0.0;
d217 1
a217 1
      myReqVol_     (thePart, consPer) += reqQty;
d219 1
a219 1
      netSupplyVol_ (thePart, consPer) -= reqQty;
d281 1
a281 1
         netSupplyVol_ (thePart, consPer) -= reqConsQty;
d509 1
a509 1
            theBomEnt->incConsVol (theMrpConsVol, theMrpNonSubVol);
d512 2
a513 1
            theBomEnt->incConsVol (
d520 1
a520 1
               theSub->incConsVol (theMrpConsVol, theSub->mrpSubVol ());
@


1.24
log
@Continued implementation of single-source.
@
text
@d33 1
a33 1
      WitProbAssoc     (theProblem),
d35 1
a35 4
      netSupplyVol_    (),
      myReqVol_        (),
      netSubsMode_     (witFALSE),
      hasSubsToNetVec_ ()
d329 1
a329 1
      WitMrpExp       (theProblem),
d331 1
a331 6
      reqVol_         (),
      mrpConsVol_     (),
      mrpResidualVol_ (),
      mrpExecVol_     (),
      mrpSubVol_      (),
      exploding_      (witFALSE)
@


1.23
log
@Continued implementation of single-source.
@
text
@d26 1
a26 1
#include <RefMap.h>
d334 5
a338 5
      reqVol_         (* new WitRefMap <WitPart,      WitFlexVec <float> >),
      mrpConsVol_     (* new WitRefMap <WitPart,      WitFlexVec <float> >),
      mrpResidualVol_ (* new WitRefMap <WitPart,      WitFlexVec <float> >),
      mrpExecVol_     (* new WitRefMap <WitOperation, WitFlexVec <float> >),
      mrpSubVol_      (* new WitRefMap <WitSubEntry,  WitFlexVec <float> >),
a346 5
   delete & reqVol_;
   delete & mrpConsVol_;
   delete & mrpResidualVol_;
   delete & mrpExecVol_;
   delete & mrpSubVol_;
@


1.22
log
@Continued implementation of single-source.
@
text
@d26 1
d328 1
a328 1
// Implementation of class MrpExp.
d332 1
a332 1
      WitMrpExp  (theProblem),
d334 6
a339 2
      myAccFlag_ (new WitAccFlag),
      exploding_ (witFALSE)
d347 36
a382 1
   delete myAccFlag_;
d392 1
a392 1
   exploding_ = witTRUE;
d394 1
a394 1
   myMsgFac () ("mrpMsg");
d397 1
a397 1
      mrpExecVol (theOpn).setToScalar (0.0);
d401 3
a403 1
         mrpSubVol (theSub).setToScalar (0.0);
d432 1
a432 1
   return mrpExecVol (theOpn).elemRef (execPer);
d439 1
a439 1
   return mrpSubVol (theSub).elemRef (execPer);
d448 2
d452 2
a453 2
      copyInto (reqVol         (thePart), myReqVol     () (thePart));
      copyInto (mrpResidualVol (thePart), netSupplyVol () (thePart));
d458 28
a485 1
   exploding_ = witFALSE;
d533 1
a533 1
      copyInto (mrpConsVol (thePart), theMrpConsVol);
@


1.21
log
@Continued implementation of single-source.
@
text
@d64 6
d331 1
a331 1
      WitMrpExp   (theProblem),
d333 2
a334 4
      mrpConsVol_ (),
      mrpExecVol_ (),
      mrpSubVol_  (),
      exploding_  (witFALSE)
d342 1
d347 1
a347 1
const WitTVec <double> & WitOrigMrpExp::reqVol (WitPart * thePart)
d349 2
a350 2
   return myReqVol () (thePart);
   }
d352 1
a352 1
//------------------------------------------------------------------------------
a353 9
const WitTVec <double> & WitOrigMrpExp::mrpResidualVol (WitPart * thePart)
   {
   return netSupplyVol () (thePart);
   }

//------------------------------------------------------------------------------

void WitOrigMrpExp::initDerived ()
   {
d356 2
a357 3
   mrpConsVol_    .allocate (myProblem (), 0.0);
   mrpExecVol_    .allocate (myProblem (), 0.0);
   mrpSubVol_     .allocate (myProblem (), 0.0);
d359 3
a361 1
   exploding_ = witTRUE;
d390 1
a390 1
   return mrpExecVol_ (theOpn, execPer);
d397 1
a397 1
   return mrpSubVol_ (theSub, execPer);
d404 7
a410 1
   WitComponent * theComp;
a414 7

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importMrpResults ();

   mrpConsVol_.clear ();
   mrpExecVol_.clear ();
   mrpSubVol_ .clear ();
d443 1
a443 1
                        totMrpSubVol += mrpSubVol_ (theSub, thePer);
d446 1
a446 1
                    mrpExecVol_ (theBomEnt->myOperation (), thePer)
d455 1
a455 1
               mrpExecVol_ (theBomEnt->myOperation ()));
d460 1
a460 1
               theSub->incConsVol (theMrpConsVol, mrpSubVol_ (theSub));
d462 1
a462 1
      copyInto (mrpConsVol_ (thePart), theMrpConsVol);
@


1.20
log
@Continued implementation of single-source.
@
text
@a63 6
void WitMrpExp::initDerived ()
   {
   }

//------------------------------------------------------------------------------

d338 14
@


1.19
log
@Preliminary work on single source.
@
text
@d331 1
a331 1
      WitMrpExp  (theProblem),
d333 4
a336 2
      myAccFlag_ (new WitAccFlag),
      exploding_ (witFALSE)
a343 1
   delete myAccFlag_;
a349 5
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   exploding_ = witTRUE;

d352 3
a354 2
   forEachOperation (theOpn, myProblem ())
      mrpExecVol (theOpn).setToScalar (0.0);
d356 1
a356 3
   forEachSubEntry (theSub, myProblem ())
      if (theSub->mrpNetAllowed ())
         mrpSubVol (theSub).setToScalar (0.0);
d385 1
a385 1
   return mrpExecVol (theOpn).elemRef (execPer);
d392 1
a392 1
   return mrpSubVol (theSub).elemRef (execPer);
d399 1
a399 7
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      {
      copyInto (reqVol         (thePart), myReqVol     () (thePart));
      copyInto (mrpResidualVol (thePart), netSupplyVol () (thePart));
      }
d404 7
d439 1
a439 1
                        totMrpSubVol += theSub->mrpSubVol ()[thePer];
d442 1
a442 1
                    theBomEnt->myOperation ()->mrpExecVol ()[thePer]
d451 1
a451 1
               theBomEnt->myOperation ()->mrpExecVol ());
d456 1
a456 1
               theSub->incConsVol (theMrpConsVol, theSub->mrpSubVol ());
d458 1
a458 1
      copyInto (mrpConsVol (thePart), theMrpConsVol);
@


1.18
log
@Continued preliminary work on single source.
@
text
@d83 1
a83 1
      myReqVol_ (thePart).setTo (0.0);
d357 1
a357 1
      mrpExecVol (theOpn) = 0.0;
d361 1
a361 1
         mrpSubVol (theSub) = 0.0;
d431 1
a431 1
      theMrpConsVol.setTo (0.0);
@


1.17
log
@Continued preliminary work on single source.
@
text
@d21 2
d306 7
@


1.16
log
@Preliminary work on single source.
@
text
@d81 1
a81 1
      myReqVol_ (thePart) = 0.0;
d416 2
a417 2
   WitTVec (double) theMrpConsVol   (myProblem (), 0.0);
   WitTVec (float)  theMrpNonSubVol (myProblem (), 0.0);
d422 1
a422 1
      theMrpConsVol = 0.0;
@


1.15
log
@Began implementation of object iteration.
@
text
@d109 1
a109 1
   reverseCopyInto (reversedParts, myCompMgr ()->allParts ());
@


1.14
log
@Converted several generic classes into class templates.
@
text
@d20 1
d22 1
@


1.13
log
@Continued development of selection splitting for multi=exec.
@
text
@d105 1
a105 1
   WitObjStack (WitPart) reversedParts (myProblem ());
@


1.12
log
@Fixed some bugs in coarse selection splitting.
@
text
@d92 2
a93 2
         netSubsMode_                         = witTRUE;
         hasSubsToNet (theSub->myBomEntry ()) = witTRUE;
@


1.11
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d109 1
a109 1
   while (reversedParts.get (thePart))
@


1.10
log
@Further development of coarse selection splitting.
@
text
@d109 1
a109 1
   while (reversedParts.pop (thePart))
@


1.9
log
@Some minor modifications.
@
text
@d21 1
a21 1
#include <Stack.h>
@


1.8
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d21 1
a21 1
#include <DynStack.h>
d105 1
a105 1
   WitObjDynStack (WitPart) reversedParts (myProblem ());
@


1.7
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d105 1
a105 1
   WitDynStack (WitPart) reversedParts (myProblem ());
d107 1
a107 1
   reversedParts.reverseCopyOf (myCompMgr ()->allParts ());
d397 2
a398 2
      copyTo (reqVol         (thePart), myReqVol     () (thePart));
      copyTo (mrpResidualVol (thePart), netSupplyVol () (thePart));
d451 1
a451 1
      copyTo (mrpConsVol (thePart), theMrpConsVol);
@


1.6
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d205 1
a205 1
   reqQty = qty * theBomEnt->effUsageRate ();
d262 1
a262 1
   reqConsQty = theConsEnt->effUsageRate () * qty;
d266 1
a266 1
   if (theConsEnt->effUsageRate () >= FLOAT_EPSILON)
d270 1
a270 1
      qty = netConsQty / theConsEnt->effUsageRate ();
d277 1
a277 1
      if (theConsEnt->effUsageRate () <= -FLOAT_EPSILON)
@


1.5
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d397 2
a398 2
      copy (reqVol         (thePart), myReqVol     () (thePart));
      copy (mrpResidualVol (thePart), netSupplyVol () (thePart));
d451 1
a451 1
      copy (mrpConsVol (thePart), theMrpConsVol);
@


1.4
log
@Changed some more of the FSS and MRP stuff from float to double to fix a
   numerical problem.
@
text
@d21 1
d105 1
a105 3
   WitDenseList (WitPart) allPartsDense (myCompMgr ()->nParts ());
      //
      // A DenseList of all the Parts.
d107 1
d109 1
a109 3
   copy (allPartsDense, myCompMgr ()->allParts ());

   forEachElDenseBackwards (thePart, allPartsDense)
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d357 1
a357 1
float WitOrigMrpExp::supplyVol (WitPart * thePart, WitPeriod thePer)
d364 1
a364 1
float WitOrigMrpExp::demandVol (WitPart * thePart, WitPeriod thePer)
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d244 1
a244 1
            subVol (theSub, execPer) += WitUtil::positivePart (oldQty - qty);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

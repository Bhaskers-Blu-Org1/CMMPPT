head	1.62;
access;
symbols
	sce_5_01_20080919:1.57;
locks; strict;
comment	@ * @;


1.62
date	2011.09.28.23.50.06;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2011.09.24.00.28.31;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2011.08.30.20.18.06;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2010.09.10.22.10.41;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.25.00.10.47;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2008.02.12.22.04.03;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.08.23.33.46;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.07.18.41.39;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.29.19.50.01;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.28.23.53.37;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2008.01.25.00.19.21;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.18.22.40.59;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.15.23.37.25;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2008.01.09.19.35.47;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.08.20.44.21;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.08.18.36.50;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.08.15.53.30;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.07.23.51.49;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.04.20.25.27;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.19.21.10.18;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.11.22.00.28;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.12.06.22.01.21;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.05.22.13.08;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.04.00.18.47;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.04.00.07.15;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.03.19.41.33;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.29.16.24.43;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.29.15.35.01;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.28.23.23.47;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.28.20.34.27;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.27.23.09.43;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.27.22.24.42;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.27.21.05.01;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.26.23.15.17;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.15.19.57.35;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.22.19.58.52;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.18.23.14.45;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.11.19.16.57;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.08.20.09.43;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.08.18.56.35;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.25.21.03.03;	author rjw;	state dead;
branches;
next	1.21;

1.21
date	2007.09.21.23.10.49;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.21.23.06.08;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.21.19.12.25;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.21.18.45.19;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.21.17.47.13;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.21.16.44.41;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.21.14.47.31;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.20.22.17.57;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.20.20.58.25;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.20.18.46.16;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.19.22.39.53;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.19.21.35.40;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.19.17.41.34;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.19.14.38.30;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.19.14.23.26;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.18.20.12.58;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.18.18.43.13;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.17.21.46.31;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.17.18.31.59;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.17.14.37.38;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.14.22.38.32;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "ScenAtt.C"
//
// Contains the implementation of the following classes and templates:
//
//    AbsScenInputAtt
//    ScenInputAtt <Owner>
//    AbsScenSolnAtt
//    ScenSolnAtt  <Owner>
//    ScenAtt      <Owner>
//------------------------------------------------------------------------------

#include <ScenAttMgr.h>
#include <ScenInputAtt.h>
#include <ScenSolnAtt.h>
#include <ScenAtt.h>
#include <StochImpMgr.h>
#include <ScenMgr.h>
#include <Scenario.h>
#include <StochAttMgr.h>
#include <Stage.h>
#include <StageMgr.h>
#include <StochOptMgr.h>
#include <DataWrit.h>
#include <CompMgr.h>
#include <Material.h>
#include <Demand.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BoundSet.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class AbsScenInputAtt.
//------------------------------------------------------------------------------

WitAbsScenInputAtt::~WitAbsScenInputAtt ()
   {
   }

//------------------------------------------------------------------------------

WitAbsScenInputAtt::WitAbsScenInputAtt (WitScenAttMgr * theScenAttMgr):

      WitStochAssoc (theScenAttMgr)
   {
   theScenAttMgr->store (this);
   }

//------------------------------------------------------------------------------
// Implementation of class ScenInputAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitScenInputAtt <Owner>::WitScenInputAtt (
         WitScenAttMgr *                     theScenAttMgr,
         const char *                        theAttName,
         double                              theDefaultVal,
         const WitDblFlexVec & (Owner::*     theAccFunc) () const,
         void (Owner::*                      theStoreFunc) (
                                                const WitDblFlexVec &),
         WitScenInputAtt * (WitScenAttMgr::* theInstFunc) () const):

         WitAbsScenInputAtt (theScenAttMgr),
         myScenAtt_         (NULL),
         myAttName_         (theAttName),
         myDefaultVal_      (theDefaultVal),
         myAccFunc_         (theAccFunc),
         myStoreFunc_       (theStoreFunc),
         myInstFunc_        (theInstFunc)
   {
   myStochModeMgr ()->
      myStochAttMgr ()->
         makeScenInputStochAtt (myAttName_, this);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      const WitDblFlexVec & WitScenInputAtt <Owner>::myValueFor (
         Owner *       theOwner,
         WitScenario * theScenario)
   {
   if (isDiffedAt (theOwner))
      return myScenAtt_->myValueFor (theOwner, theScenario);
   else
      return (theOwner->*myAccFunc_) ();
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitScenInputAtt <Owner>::~WitScenInputAtt ()
   {
   delete myScenAtt_;
   }

//------------------------------------------------------------------------------
// Function ScenInputAtt <Owner>::prepSet (WitDelComp *).
// Specialized to Owner = BoundSet vs. anything else.
//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::prepSet (WitDelComp * theDelComp)
   {
   Owner * theOwner;

   theOwner = theOwnerFor (theDelComp);

   witAssert (theOwner != NULL);

   prepSetForOwner (theOwner);
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::prepSet (WitDelComp *)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------
// Function ScenInputAtt <Owner>::prepSet (WitBoundSet *).
// Specialized to Owner = BoundSet vs. anything else.
//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::prepSet (WitBoundSet *)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::prepSet (WitBoundSet * theBoundSet)
   {
   prepSetForOwner (theBoundSet);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::downloadData (WitScenario * theScenario)
   {
   Owner * theOwner;

   if (myScenAtt_ != NULL)
      forEachEl (theOwner, myScenAtt_->allOwners ())
         if (myScenAtt_->isAllocatedFor (theOwner))
             myScenAtt_->myValueFor     (theOwner, theScenario) =
               (theOwner->*myAccFunc_) ();
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::uploadData (WitScenario * theScenario)
   {
   Owner * theOwner;

   if (myScenAtt_ != NULL)
      forEachEl (theOwner, myScenAtt_->allOwners ())
         if (myScenAtt_->isAllocatedFor (theOwner))
            (theOwner->*myStoreFunc_) (myValueFor (theOwner, theScenario));
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::copyDataFrom (WitScenAttMgr * srcScenAttMgr)
   {
   Owner *              dstOwner;
   WitScenario *        dstScenario;
   WitScenInputAtt *    srcScenInputAtt;
   WitScenAtt <Owner> * srcScenAtt;
   Owner *              srcOwner;
   WitScenario *        srcScenario;
   int                  theScenIdx;

   witAssert (myScenAtt_ == NULL);

   srcScenInputAtt = (srcScenAttMgr->*myInstFunc_) ();

   srcScenAtt      = srcScenInputAtt->myScenAtt_;

   if (srcScenAtt == NULL)
      return;

   myScenAtt_ = new WitScenAtt <Owner> (myScenAttMgr ());

   forEachEl (dstOwner, myScenAtt_->allOwners ())
      {
      srcOwner = srcScenAttMgr->myCompMgr ()->myMatchFor (dstOwner);

      if (not srcScenAtt->isAllocatedFor (srcOwner))
         continue;

      myScenAtt_->allocateFor (dstOwner);

      forEachEl (dstScenario, myScenMgr ()->myScenarios ())
         {
         theScenIdx  = dstScenario->myIndex ();

         srcScenario =
            srcScenInputAtt->myScenMgr ()->myScenarioFor (theScenIdx);

         myScenAtt_   ->myValueFor (dstOwner, dstScenario) =
            srcScenAtt->myValueFor (srcOwner, srcScenario);
         }
      }
   }

//------------------------------------------------------------------------------
// Function
//    ScenInputAtt <Owner>::writeData (Component *, Scenario *, bool, bool &).
// Specialized to Owner = BoundSet vs. anything else.
//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::writeData (
         WitComponent * theComp,
         WitScenario *  theScenario,
         bool           diffedSec,
         bool &         attWritten)
   {
   Owner * theOwner;

   theOwner = theOwnerFor (theComp);

   if (theOwner == NULL)
      return;

   writeDataForOwner (theOwner, theScenario, diffedSec, attWritten);
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::writeData (
         WitComponent *,
         WitScenario *,
         bool,
         bool &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------
// Function
//    ScenInputAtt <Owner>::writeData (BoundSet *, Scenario *, bool, bool &).
// Specialized to Owner = BoundSet vs. anything else.
//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::writeData (
         WitBoundSet *,
         WitScenario *,
         bool,
         bool &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::writeData (
         WitBoundSet * theBoundSet,
         WitScenario * theScenario,
         bool          diffedSec,
         bool &        attWritten)
   {
   writeDataForOwner (theBoundSet, theScenario, diffedSec, attWritten);
   }

//------------------------------------------------------------------------------
// Function ScenInputAtt <Owner>::ownedByBoundSet ().
// Specialized to Owner = BoundSet vs. anything else.
//------------------------------------------------------------------------------

template <typename Owner>
      bool WitScenInputAtt <Owner>::ownedByBoundSet ()
   {
   return false;
   }

//------------------------------------------------------------------------------

template <>
      bool WitScenInputAtt <WitBoundSet>::ownedByBoundSet ()
   {
   return true;
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::prepSetForOwner (Owner * theOwner)
   {
   WitScenario * theScenario;

   if (myScenAtt_ == NULL)
      myScenAtt_ = new WitScenAtt <Owner> (myScenAttMgr ());

   if (not myScenAtt_->isAllocatedFor (theOwner))
      {
      myScenAtt_->allocateFor (theOwner);

      forEachEl (theScenario, myScenMgr ()->myScenarios ())
         myScenAtt_->myValueFor (theOwner, theScenario) =
            (theOwner->*myAccFunc_) ();
      }
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::validateData ()
   {
   Owner *   theOwner;
   WitNode * theNode;
   WitPeriod thePer;

   if (myScenAtt_ == NULL)
      return;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      {
      if (not myScenAtt_->isAllocatedFor (theOwner))
         continue;

      theNode = stageNode (theOwner);

      forEachPeriod (thePer, myProblem ())
         if (myStageMgr ()->myStageOf (theNode, thePer)->isStage0 ())
            checkSameInAllScenarios (theOwner, thePer);
      }
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// ScenInputAtt <Owner>::theOwnerFor (...).
//------------------------------------------------------------------------------

template <>
      WitPart * WitScenInputAtt <WitPart>::theOwnerFor (WitComponent * theComp)
   {
   return theComp->thisPart ();
   }

//------------------------------------------------------------------------------

template <>
      WitMaterial * WitScenInputAtt <WitMaterial>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisMat ();
   }

//------------------------------------------------------------------------------

template <>
      WitDemand * WitScenInputAtt <WitDemand>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisDemand ();
   }

//------------------------------------------------------------------------------

template <>
      WitOperation * WitScenInputAtt <WitOperation>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisOpn ();
   }

//------------------------------------------------------------------------------

template <>
      WitSubEntry * WitScenInputAtt <WitSubEntry>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisSub ();
   }

//------------------------------------------------------------------------------

template <>
      WitBoundSet * WitScenInputAtt <WitBoundSet>::theOwnerFor (WitComponent *)
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::writeDataForOwner (
            Owner *        theOwner,
            WitScenario *  theScenario,
            bool           diffedSec,
            bool &         attWritten)
   {
   if (isDiffedAt (theOwner) != diffedSec)
      return;

   if (myValueFor (theOwner, theScenario) == myDefaultVal_)
      return;

   if (not attWritten)
      theOwner->writeSetClause ();

   myDataWriter ()->
      writeVector (
         myAttName_,
         myValueFor (theOwner, theScenario),
         myDefaultVal_);

   attWritten = true;
   }

//------------------------------------------------------------------------------

template <>
      WitNode * WitScenInputAtt <WitPart>::stageNode (WitPart * thePart)
   {
   return thePart;
   }

//------------------------------------------------------------------------------

template <>
      WitNode * WitScenInputAtt <WitMaterial>::stageNode (WitMaterial * theMat)
   {
   return theMat;
   }

//------------------------------------------------------------------------------

template <>
      WitNode * WitScenInputAtt <WitDemand>::stageNode (WitDemand * theDemand)
   {
   return theDemand->demandedPart ();
   }

//------------------------------------------------------------------------------

template <>
      WitNode * WitScenInputAtt <WitOperation>::stageNode (
         WitOperation * theOpn)
   {
   return theOpn;
   }

//------------------------------------------------------------------------------

template <>
      WitNode * WitScenInputAtt <WitSubEntry>::stageNode (WitSubEntry * theSub)
   {
   return theSub->myOperation ();
   }

//------------------------------------------------------------------------------

template <>
      WitNode * WitScenInputAtt <WitBoundSet>::stageNode (
         WitBoundSet * theBoundSet)
   {
   return theBoundSet->stageNode ();
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::checkSameInAllScenarios (
         Owner *   theOwner,
         WitPeriod thePer)
   {
   WitScenario * theScen0;
   double        attVal0;
   WitScenario * theScenX;
   double        attValX;

   theScen0 = myScenMgr ()->myScenarioFor (0);

   attVal0  = myScenAtt_->myValueFor (theOwner, theScen0)[thePer];

   forEachEl (theScenX, myScenMgr ()->myScenarios ())
      if (theScenX->myIndex () != 0)
         {
         attValX = myScenAtt_->myValueFor (theOwner, theScenX)[thePer];

         if (attValX != attVal0)
            {
            myStageMgr ()->issueAttMisMatchHeadMsg ();

            issueMisMatchOwnerMsg (theOwner);

            myMsgFac () ("stage0AttMisMatchTailSmsg",
               myAttName_,
               thePer,
               attVal0,
               theScenX->myIndex (),
               attValX);
            }
         }
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// ScenInputAtt <Owner>::issueMisMatchOwnerMsg (theOwner)
//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitPart>::issueMisMatchOwnerMsg (WitPart * thePart)
   {
   myMsgFac () ("stage0AttMisMatchPartSmsg", thePart->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitMaterial>::issueMisMatchOwnerMsg (
         WitMaterial * theMat)
   {
   myMsgFac () ("stage0AttMisMatchPartSmsg", theMat->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitDemand>::issueMisMatchOwnerMsg (
         WitDemand * theDemand)
   {
   myMsgFac () ("stage0AttMisMatchDemandSmsg",
      theDemand->demandedPartName (),
      theDemand->demandName       ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitOperation>::issueMisMatchOwnerMsg (
         WitOperation * theOpn)
   {
   myMsgFac () ("stage0AttMisMatchOpnSmsg", theOpn->operationName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitSubEntry>::issueMisMatchOwnerMsg (
         WitSubEntry * theSub)
   {
   myMsgFac () ("stage0AttMisMatchSubSmsg",
      theSub->myOperationName (),
      theSub->myBomEntIndex   (),
      theSub->localIndex      ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::issueMisMatchOwnerMsg (
         WitBoundSet * theBoundSet)
   {
   theBoundSet->issueStage0MMCompMsg ();

   myMsgFac () ("stage0AttMisMatchBoundSetSmsg", theBoundSet->myAttName ());
   }

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

template <typename Owner>
      bool WitScenInputAtt <Owner>::isDiffedAt (Owner * theOwner)
   {
   if (myScenAtt_ != NULL)
      if (myScenAtt_->isAllocatedFor (theOwner))
         return true;

   return false;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class ScenInputAtt <Owner>.
//------------------------------------------------------------------------------

template class WitScenInputAtt <WitPart>;
template class WitScenInputAtt <WitMaterial>;
template class WitScenInputAtt <WitDemand>;
template class WitScenInputAtt <WitOperation>;
template class WitScenInputAtt <WitSubEntry>;
template class WitScenInputAtt <WitBoundSet>;

//------------------------------------------------------------------------------
// Implementation of class AbsScenSolnAtt.
//------------------------------------------------------------------------------

WitAbsScenSolnAtt::~WitAbsScenSolnAtt ()
   {
   }

//------------------------------------------------------------------------------

WitAbsScenSolnAtt::WitAbsScenSolnAtt (WitScenAttMgr * theScenAttMgr):

      WitStochAssoc (theScenAttMgr)
   {
   theScenAttMgr->store (this);
   }

//------------------------------------------------------------------------------
// Implementation of class template ScenSolnAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitScenSolnAtt <Owner>::WitScenSolnAtt (
            WitScenAttMgr * theScenAttMgr,
            const char *    theAttName,
            void (Owner::*  theStoreFunc) (const WitDblFlexVec &)):

         WitAbsScenSolnAtt (theScenAttMgr),
         myScenAtt_        (NULL),
         myStoreFunc_      (theStoreFunc)
   {
   Owner * theOwner;

   myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr);

   forEachEl (theOwner, myScenAtt_->allOwners ())
      myScenAtt_->allocateFor (theOwner);

   myStochModeMgr ()->myStochAttMgr ()->makeScenSolnStochAtt (theAttName);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenSolnAtt <Owner>::storeValueFor (
         Owner *       theOwner,
         WitScenario * theScenario,
         WitPeriod     thePer,
         double        theValue)
   {
   witAssert (myStochModeMgr ()->myStochOptMgr ()->uploadingSoln ());

   if (theValue <= 0.0)
      return;

   myScenAtt_->myValueFor (theOwner, theScenario).elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitScenSolnAtt <Owner>::~WitScenSolnAtt ()
   {
   delete myScenAtt_;
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenSolnAtt <Owner>::uploadData (WitScenario * theScenario)
   {
   Owner * theOwner;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      (theOwner->*myStoreFunc_) (
         myScenAtt_->myValueFor (theOwner, theScenario));
   }

//------------------------------------------------------------------------------
  
template <typename Owner>
      void WitScenSolnAtt <Owner>::clearData ()
   {
   Owner *       theOwner;
   WitScenario * theScenario;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      forEachEl (theScenario, myScenMgr ()->myScenarios ())
         myScenAtt_->myValueFor (theOwner, theScenario) = 0.0;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class ScenSolnAtt <Owner>.
//------------------------------------------------------------------------------

template class WitScenSolnAtt <WitPart>;
template class WitScenSolnAtt <WitMaterial>;
template class WitScenSolnAtt <WitDemand>;
template class WitScenSolnAtt <WitOperation>;
template class WitScenSolnAtt <WitSubEntry>;

//------------------------------------------------------------------------------
// Implementation of class template ScenAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitScenAtt <Owner>::WitScenAtt (WitScenAttMgr * theScenAttMgr):

         WitStochAssoc (theScenAttMgr),
         myScenAttMgr_ (theScenAttMgr),
         myValue_      (myProblem ())
   {
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitScenAtt <Owner>::~WitScenAtt ()
   {
   Owner *       theOwner;
   WitScenario * theScenario;

   forEachEl (theOwner, allOwners ())
      if (isAllocatedFor (theOwner))
         {
         forEachEl (theScenario, myScenMgr ()->myScenarios ())
            delete myValue_.myElemAt (theOwner) (theScenario);

         delete myValue_ (theOwner);
         }
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// ScenAtt <Owner>::allOwners (...).
//------------------------------------------------------------------------------

template <> 
      const WitList <WitPart> & WitScenAtt <WitPart>::allOwners ()
   {
   return myScenAttMgr_->myCompMgr ()->allParts ();
   }

//------------------------------------------------------------------------------

template <>
      const WitList <WitMaterial> & WitScenAtt <WitMaterial>::allOwners ()
   {
   return myScenAttMgr_->allMats ();
   }

//------------------------------------------------------------------------------

template <>
      const WitList <WitDemand> & WitScenAtt <WitDemand>::allOwners ()
   {
   return myScenAttMgr_->allDemands ();
   }

//------------------------------------------------------------------------------

template <>
      const WitList <WitOperation> & WitScenAtt <WitOperation>::allOwners ()
   {
   return myScenAttMgr_->myCompMgr ()->allOperations ();
   }

//------------------------------------------------------------------------------

template <>
      const WitList <WitSubEntry> & WitScenAtt <WitSubEntry>::allOwners ()
   {
   return myScenAttMgr_->allSubs ();
   }

//------------------------------------------------------------------------------

template <> 
      const WitList <WitBoundSet> & WitScenAtt <WitBoundSet>::allOwners ()
   {
   return myScenAttMgr_->allBoundSets ();
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenAtt <Owner>::allocateFor (Owner * theOwner)
   {
   WitScenario * theScenario;

   witAssert (not isAllocatedFor (theOwner));

   myValue_ (theOwner) =
      new WitPtrMap <WitScenario, WitDblFlexVec> (myProblem ());

   forEachEl (theScenario, myScenMgr ()->myScenarios ())
      myValue_.myElemAt (theOwner) (theScenario) =
         new WitDblFlexVec (myProblem (), 0.0);
   }
@


1.61
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.60
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d47 2
a48 2
{
}
d54 4
a57 4
WitStochAssoc (theScenAttMgr)
{
theScenAttMgr->store (this);
}
d64 21
a84 21
WitScenInputAtt <Owner>::WitScenInputAtt (
WitScenAttMgr *                     theScenAttMgr,
const char *                        theAttName,
double                              theDefaultVal,
const WitDblFlexVec & (Owner::*     theAccFunc) () const,
void (Owner::*                      theStoreFunc) (
const WitDblFlexVec &),
WitScenInputAtt * (WitScenAttMgr::* theInstFunc) () const):

WitAbsScenInputAtt (theScenAttMgr),
myScenAtt_         (NULL),
myAttName_         (theAttName),
myDefaultVal_      (theDefaultVal),
myAccFunc_         (theAccFunc),
myStoreFunc_       (theStoreFunc),
myInstFunc_        (theInstFunc)
{
myStochModeMgr ()->
myStochAttMgr ()->
makeScenInputStochAtt (myAttName_, this);
}
d89 9
a97 9
const WitDblFlexVec & WitScenInputAtt <Owner>::myValueFor (
Owner *       theOwner,
WitScenario * theScenario)
{
if (isDiffedAt (theOwner))
return myScenAtt_->myValueFor (theOwner, theScenario);
else
return (theOwner->*myAccFunc_) ();
}
d102 4
a105 4
WitScenInputAtt <Owner>::~WitScenInputAtt ()
{
delete myScenAtt_;
}
d113 3
a115 3
void WitScenInputAtt <Owner>::prepSet (WitDelComp * theDelComp)
{
Owner * theOwner;
d117 1
a117 1
theOwner = theOwnerFor (theDelComp);
d119 1
a119 1
witAssert (theOwner != NULL);
d121 2
a122 2
prepSetForOwner (theOwner);
}
d127 4
a130 4
void WitScenInputAtt <WitBoundSet>::prepSet (WitDelComp *)
{
stronglyAssert (false);
}
d138 4
a141 4
void WitScenInputAtt <Owner>::prepSet (WitBoundSet *)
{
stronglyAssert (false);
}
d146 4
a149 4
void WitScenInputAtt <WitBoundSet>::prepSet (WitBoundSet * theBoundSet)
{
prepSetForOwner (theBoundSet);
}
d154 3
a156 3
void WitScenInputAtt <Owner>::downloadData (WitScenario * theScenario)
{
Owner * theOwner;
d158 6
a163 6
if (myScenAtt_ != NULL)
forEachEl (theOwner, myScenAtt_->allOwners ())
if (myScenAtt_->isAllocatedFor (theOwner))
myScenAtt_->myValueFor     (theOwner, theScenario) =
(theOwner->*myAccFunc_) ();
}
d168 3
a170 3
void WitScenInputAtt <Owner>::uploadData (WitScenario * theScenario)
{
Owner * theOwner;
d172 5
a176 5
if (myScenAtt_ != NULL)
forEachEl (theOwner, myScenAtt_->allOwners ())
if (myScenAtt_->isAllocatedFor (theOwner))
(theOwner->*myStoreFunc_) (myValueFor (theOwner, theScenario));
}
d181 9
a189 9
void WitScenInputAtt <Owner>::copyDataFrom (WitScenAttMgr * srcScenAttMgr)
{
Owner *              dstOwner;
WitScenario *        dstScenario;
WitScenInputAtt *    srcScenInputAtt;
WitScenAtt <Owner> * srcScenAtt;
Owner *              srcOwner;
WitScenario *        srcScenario;
int                  theScenIdx;
d191 1
a191 1
witAssert (myScenAtt_ == NULL);
d193 1
a193 1
srcScenInputAtt = (srcScenAttMgr->*myInstFunc_) ();
d195 1
a195 1
srcScenAtt      = srcScenInputAtt->myScenAtt_;
d197 2
a198 2
if (srcScenAtt == NULL)
return;
d200 1
a200 1
myScenAtt_ = new WitScenAtt <Owner> (myScenAttMgr ());
d202 3
a204 3
forEachEl (dstOwner, myScenAtt_->allOwners ())
{
srcOwner = srcScenAttMgr->myCompMgr ()->myMatchFor (dstOwner);
d206 2
a207 2
if (not srcScenAtt->isAllocatedFor (srcOwner))
continue;
d209 1
a209 1
myScenAtt_->allocateFor (dstOwner);
d211 3
a213 3
forEachEl (dstScenario, myScenMgr ()->myScenarios ())
{
theScenIdx  = dstScenario->myIndex ();
d215 2
a216 2
srcScenario =
srcScenInputAtt->myScenMgr ()->myScenarioFor (theScenIdx);
d218 5
a222 5
myScenAtt_   ->myValueFor (dstOwner, dstScenario) =
srcScenAtt->myValueFor (srcOwner, srcScenario);
}
}
}
d231 7
a237 7
void WitScenInputAtt <Owner>::writeData (
WitComponent * theComp,
WitScenario *  theScenario,
bool           diffedSec,
bool &         attWritten)
{
Owner * theOwner;
d239 1
a239 1
theOwner = theOwnerFor (theComp);
d241 2
a242 2
if (theOwner == NULL)
return;
d244 2
a245 2
writeDataForOwner (theOwner, theScenario, diffedSec, attWritten);
}
d250 8
a257 8
void WitScenInputAtt <WitBoundSet>::writeData (
WitComponent *,
WitScenario *,
bool,
bool &)
{
stronglyAssert (false);
}
d266 8
a273 8
void WitScenInputAtt <Owner>::writeData (
WitBoundSet *,
WitScenario *,
bool,
bool &)
{
stronglyAssert (false);
}
d278 8
a285 8
void WitScenInputAtt <WitBoundSet>::writeData (
WitBoundSet * theBoundSet,
WitScenario * theScenario,
bool          diffedSec,
bool &        attWritten)
{
writeDataForOwner (theBoundSet, theScenario, diffedSec, attWritten);
}
d293 4
a296 4
bool WitScenInputAtt <Owner>::ownedByBoundSet ()
{
return false;
}
d301 4
a304 4
bool WitScenInputAtt <WitBoundSet>::ownedByBoundSet ()
{
return true;
}
d309 3
a311 3
void WitScenInputAtt <Owner>::prepSetForOwner (Owner * theOwner)
{
WitScenario * theScenario;
d313 2
a314 2
if (myScenAtt_ == NULL)
myScenAtt_ = new WitScenAtt <Owner> (myScenAttMgr ());
d316 3
a318 3
if (not myScenAtt_->isAllocatedFor (theOwner))
{
myScenAtt_->allocateFor (theOwner);
d320 5
a324 5
forEachEl (theScenario, myScenMgr ()->myScenarios ())
myScenAtt_->myValueFor (theOwner, theScenario) =
(theOwner->*myAccFunc_) ();
}
}
d329 5
a333 5
void WitScenInputAtt <Owner>::validateData ()
{
Owner *   theOwner;
WitNode * theNode;
WitPeriod thePer;
d335 2
a336 2
if (myScenAtt_ == NULL)
return;
d338 4
a341 4
forEachEl (theOwner, myScenAtt_->allOwners ())
{
if (not myScenAtt_->isAllocatedFor (theOwner))
continue;
d343 1
a343 1
theNode = stageNode (theOwner);
d345 5
a349 5
forEachPeriod (thePer, myProblem ())
if (myStageMgr ()->myStageOf (theNode, thePer)->isStage0 ())
checkSameInAllScenarios (theOwner, thePer);
}
}
d357 4
a360 4
WitPart * WitScenInputAtt <WitPart>::theOwnerFor (WitComponent * theComp)
{
return theComp->thisPart ();
}
d365 5
a369 5
WitMaterial * WitScenInputAtt <WitMaterial>::theOwnerFor (
WitComponent * theComp)
{
return theComp->thisMat ();
}
d374 5
a378 5
WitDemand * WitScenInputAtt <WitDemand>::theOwnerFor (
WitComponent * theComp)
{
return theComp->thisDemand ();
}
d383 5
a387 5
WitOperation * WitScenInputAtt <WitOperation>::theOwnerFor (
WitComponent * theComp)
{
return theComp->thisOpn ();
}
d392 5
a396 5
WitSubEntry * WitScenInputAtt <WitSubEntry>::theOwnerFor (
WitComponent * theComp)
{
return theComp->thisSub ();
}
d401 3
a403 3
WitBoundSet * WitScenInputAtt <WitBoundSet>::theOwnerFor (WitComponent *)
{
stronglyAssert (false);
d405 2
a406 2
return NULL;
}
d411 8
a418 8
void WitScenInputAtt <Owner>::writeDataForOwner (
Owner *        theOwner,
WitScenario *  theScenario,
bool           diffedSec,
bool &         attWritten)
{
if (isDiffedAt (theOwner) != diffedSec)
return;
d420 2
a421 2
if (myValueFor (theOwner, theScenario) == myDefaultVal_)
return;
d423 2
a424 2
if (not attWritten)
theOwner->writeSetClause ();
d426 5
a430 5
myDataWriter ()->
writeVector (
myAttName_,
myValueFor (theOwner, theScenario),
myDefaultVal_);
d432 2
a433 2
attWritten = true;
}
d438 4
a441 4
WitNode * WitScenInputAtt <WitPart>::stageNode (WitPart * thePart)
{
return thePart;
}
d446 4
a449 4
WitNode * WitScenInputAtt <WitMaterial>::stageNode (WitMaterial * theMat)
{
return theMat;
}
d454 4
a457 4
WitNode * WitScenInputAtt <WitDemand>::stageNode (WitDemand * theDemand)
{
return theDemand->demandedPart ();
}
d462 5
a466 5
WitNode * WitScenInputAtt <WitOperation>::stageNode (
WitOperation * theOpn)
{
return theOpn;
}
d471 4
a474 4
WitNode * WitScenInputAtt <WitSubEntry>::stageNode (WitSubEntry * theSub)
{
return theSub->myOperation ();
}
d479 5
a483 5
WitNode * WitScenInputAtt <WitBoundSet>::stageNode (
WitBoundSet * theBoundSet)
{
return theBoundSet->stageNode ();
}
d488 8
a495 8
void WitScenInputAtt <Owner>::checkSameInAllScenarios (
Owner *   theOwner,
WitPeriod thePer)
{
WitScenario * theScen0;
double        attVal0;
WitScenario * theScenX;
double        attValX;
d497 1
a497 1
theScen0 = myScenMgr ()->myScenarioFor (0);
d499 1
a499 1
attVal0  = myScenAtt_->myValueFor (theOwner, theScen0)[thePer];
d501 4
a504 4
forEachEl (theScenX, myScenMgr ()->myScenarios ())
if (theScenX->myIndex () != 0)
{
attValX = myScenAtt_->myValueFor (theOwner, theScenX)[thePer];
d506 3
a508 3
if (attValX != attVal0)
{
myStageMgr ()->issueAttMisMatchHeadMsg ();
d510 1
a510 1
issueMisMatchOwnerMsg (theOwner);
d512 9
a520 9
myMsgFac () ("stage0AttMisMatchTailSmsg",
myAttName_,
thePer,
attVal0,
theScenX->myIndex (),
attValX);
}
}
}
d528 4
a531 4
void WitScenInputAtt <WitPart>::issueMisMatchOwnerMsg (WitPart * thePart)
{
myMsgFac () ("stage0AttMisMatchPartSmsg", thePart->partName ());
}
d536 5
a540 5
void WitScenInputAtt <WitMaterial>::issueMisMatchOwnerMsg (
WitMaterial * theMat)
{
myMsgFac () ("stage0AttMisMatchPartSmsg", theMat->partName ());
}
d545 7
a551 7
void WitScenInputAtt <WitDemand>::issueMisMatchOwnerMsg (
WitDemand * theDemand)
{
myMsgFac () ("stage0AttMisMatchDemandSmsg",
theDemand->demandedPartName (),
theDemand->demandName       ());
}
d556 5
a560 5
void WitScenInputAtt <WitOperation>::issueMisMatchOwnerMsg (
WitOperation * theOpn)
{
myMsgFac () ("stage0AttMisMatchOpnSmsg", theOpn->operationName ());
}
d565 8
a572 8
void WitScenInputAtt <WitSubEntry>::issueMisMatchOwnerMsg (
WitSubEntry * theSub)
{
myMsgFac () ("stage0AttMisMatchSubSmsg",
theSub->myOperationName (),
theSub->myBomEntIndex   (),
theSub->localIndex      ());
}
d577 4
a580 4
void WitScenInputAtt <WitBoundSet>::issueMisMatchOwnerMsg (
WitBoundSet * theBoundSet)
{
theBoundSet->issueStage0MMCompMsg ();
d582 2
a583 2
myMsgFac () ("stage0AttMisMatchBoundSetSmsg", theBoundSet->myAttName ());
}
d589 5
a593 5
bool WitScenInputAtt <Owner>::isDiffedAt (Owner * theOwner)
{
if (myScenAtt_ != NULL)
if (myScenAtt_->isAllocatedFor (theOwner))
return true;
d595 2
a596 2
return false;
}
d614 2
a615 2
{
}
d621 4
a624 4
WitStochAssoc (theScenAttMgr)
{
theScenAttMgr->store (this);
}
d631 4
a634 4
WitScenSolnAtt <Owner>::WitScenSolnAtt (
WitScenAttMgr * theScenAttMgr,
const char *    theAttName,
void (Owner::*  theStoreFunc) (const WitDblFlexVec &)):
d636 5
a640 5
WitAbsScenSolnAtt (theScenAttMgr),
myScenAtt_        (NULL),
myStoreFunc_      (theStoreFunc)
{
Owner * theOwner;
d642 1
a642 1
myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr);
d644 2
a645 2
forEachEl (theOwner, myScenAtt_->allOwners ())
myScenAtt_->allocateFor (theOwner);
d647 2
a648 2
myStochModeMgr ()->myStochAttMgr ()->makeScenSolnStochAtt (theAttName);
}
d653 7
a659 7
void WitScenSolnAtt <Owner>::storeValueFor (
Owner *       theOwner,
WitScenario * theScenario,
WitPeriod     thePer,
double        theValue)
{
witAssert (myStochModeMgr ()->myStochOptMgr ()->uploadingSoln ());
d661 2
a662 2
if (theValue <= 0.0)
return;
d664 2
a665 2
myScenAtt_->myValueFor (theOwner, theScenario).elemRef (thePer) = theValue;
}
d670 4
a673 4
WitScenSolnAtt <Owner>::~WitScenSolnAtt ()
{
delete myScenAtt_;
}
d678 3
a680 3
void WitScenSolnAtt <Owner>::uploadData (WitScenario * theScenario)
{
Owner * theOwner;
d682 4
a685 4
forEachEl (theOwner, myScenAtt_->allOwners ())
(theOwner->*myStoreFunc_) (
myScenAtt_->myValueFor (theOwner, theScenario));
}
d688 1
a688 1

d690 4
a693 4
void WitScenSolnAtt <Owner>::clearData ()
{
Owner *       theOwner;
WitScenario * theScenario;
d695 4
a698 4
forEachEl (theOwner, myScenAtt_->allOwners ())
forEachEl (theScenario, myScenMgr ()->myScenarios ())
myScenAtt_->myValueFor (theOwner, theScenario) = 0.0;
}
d715 1
a715 1
WitScenAtt <Owner>::WitScenAtt (WitScenAttMgr * theScenAttMgr):
d717 5
a721 5
WitStochAssoc (theScenAttMgr),
myScenAttMgr_ (theScenAttMgr),
myValue_      (myProblem ())
{
}
d726 4
a729 4
WitScenAtt <Owner>::~WitScenAtt ()
{
Owner *       theOwner;
WitScenario * theScenario;
d731 5
a735 5
forEachEl (theOwner, allOwners ())
if (isAllocatedFor (theOwner))
{
forEachEl (theScenario, myScenMgr ()->myScenarios ())
delete myValue_.myElemAt (theOwner) (theScenario);
d737 3
a739 3
delete myValue_ (theOwner);
}
}
d746 5
a750 5
template <>
const WitList <WitPart> & WitScenAtt <WitPart>::allOwners ()
{
return myScenAttMgr_->myCompMgr ()->allParts ();
}
d755 4
a758 4
const WitList <WitMaterial> & WitScenAtt <WitMaterial>::allOwners ()
{
return myScenAttMgr_->allMats ();
}
d763 4
a766 4
const WitList <WitDemand> & WitScenAtt <WitDemand>::allOwners ()
{
return myScenAttMgr_->allDemands ();
}
d771 4
a774 4
const WitList <WitOperation> & WitScenAtt <WitOperation>::allOwners ()
{
return myScenAttMgr_->myCompMgr ()->allOperations ();
}
d779 4
a782 4
const WitList <WitSubEntry> & WitScenAtt <WitSubEntry>::allOwners ()
{
return myScenAttMgr_->allSubs ();
}
d786 5
a790 5
template <>
const WitList <WitBoundSet> & WitScenAtt <WitBoundSet>::allOwners ()
{
return myScenAttMgr_->allBoundSets ();
}
d795 3
a797 3
void WitScenAtt <Owner>::allocateFor (Owner * theOwner)
{
WitScenario * theScenario;
d799 1
a799 1
witAssert (not isAllocatedFor (theOwner));
d801 2
a802 2
myValue_ (theOwner) =
new WitPtrMap <WitScenario, WitDblFlexVec> (myProblem ());
d804 4
a807 4
forEachEl (theScenario, myScenMgr ()->myScenarios ())
myValue_.myElemAt (theOwner) (theScenario) =
new WitDblFlexVec (myProblem (), 0.0);
}
@


1.59
log
@Heuristic Adjustment
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d47 2
a48 2
   {
   }
d54 4
a57 4
      WitStochAssoc (theScenAttMgr)
   {
   theScenAttMgr->store (this);
   }
d64 21
a84 21
      WitScenInputAtt <Owner>::WitScenInputAtt (
         WitScenAttMgr *                     theScenAttMgr,
         const char *                        theAttName,
         double                              theDefaultVal,
         const WitDblFlexVec & (Owner::*     theAccFunc) () const,
         void (Owner::*                      theStoreFunc) (
                                                const WitDblFlexVec &),
         WitScenInputAtt * (WitScenAttMgr::* theInstFunc) () const):

         WitAbsScenInputAtt (theScenAttMgr),
         myScenAtt_         (NULL),
         myAttName_         (theAttName),
         myDefaultVal_      (theDefaultVal),
         myAccFunc_         (theAccFunc),
         myStoreFunc_       (theStoreFunc),
         myInstFunc_        (theInstFunc)
   {
   myStochModeMgr ()->
      myStochAttMgr ()->
         makeScenInputStochAtt (myAttName_, this);
   }
d89 9
a97 9
      const WitDblFlexVec & WitScenInputAtt <Owner>::myValueFor (
         Owner *       theOwner,
         WitScenario * theScenario)
   {
   if (isDiffedAt (theOwner))
      return myScenAtt_->myValueFor (theOwner, theScenario);
   else
      return (theOwner->*myAccFunc_) ();
   }
d102 4
a105 4
      WitScenInputAtt <Owner>::~WitScenInputAtt ()
   {
   delete myScenAtt_;
   }
d113 3
a115 3
      void WitScenInputAtt <Owner>::prepSet (WitDelComp * theDelComp)
   {
   Owner * theOwner;
d117 1
a117 1
   theOwner = theOwnerFor (theDelComp);
d119 1
a119 1
   witAssert (theOwner != NULL);
d121 2
a122 2
   prepSetForOwner (theOwner);
   }
d127 4
a130 4
      void WitScenInputAtt <WitBoundSet>::prepSet (WitDelComp *)
   {
   stronglyAssert (false);
   }
d138 4
a141 4
      void WitScenInputAtt <Owner>::prepSet (WitBoundSet *)
   {
   stronglyAssert (false);
   }
d146 4
a149 4
      void WitScenInputAtt <WitBoundSet>::prepSet (WitBoundSet * theBoundSet)
   {
   prepSetForOwner (theBoundSet);
   }
d154 3
a156 3
      void WitScenInputAtt <Owner>::downloadData (WitScenario * theScenario)
   {
   Owner * theOwner;
d158 6
a163 6
   if (myScenAtt_ != NULL)
      forEachEl (theOwner, myScenAtt_->allOwners ())
         if (myScenAtt_->isAllocatedFor (theOwner))
             myScenAtt_->myValueFor     (theOwner, theScenario) =
               (theOwner->*myAccFunc_) ();
   }
d168 3
a170 3
      void WitScenInputAtt <Owner>::uploadData (WitScenario * theScenario)
   {
   Owner * theOwner;
d172 5
a176 5
   if (myScenAtt_ != NULL)
      forEachEl (theOwner, myScenAtt_->allOwners ())
         if (myScenAtt_->isAllocatedFor (theOwner))
            (theOwner->*myStoreFunc_) (myValueFor (theOwner, theScenario));
   }
d181 9
a189 9
      void WitScenInputAtt <Owner>::copyDataFrom (WitScenAttMgr * srcScenAttMgr)
   {
   Owner *              dstOwner;
   WitScenario *        dstScenario;
   WitScenInputAtt *    srcScenInputAtt;
   WitScenAtt <Owner> * srcScenAtt;
   Owner *              srcOwner;
   WitScenario *        srcScenario;
   int                  theScenIdx;
d191 1
a191 1
   witAssert (myScenAtt_ == NULL);
d193 1
a193 1
   srcScenInputAtt = (srcScenAttMgr->*myInstFunc_) ();
d195 1
a195 1
   srcScenAtt      = srcScenInputAtt->myScenAtt_;
d197 2
a198 2
   if (srcScenAtt == NULL)
      return;
d200 1
a200 1
   myScenAtt_ = new WitScenAtt <Owner> (myScenAttMgr ());
d202 3
a204 3
   forEachEl (dstOwner, myScenAtt_->allOwners ())
      {
      srcOwner = srcScenAttMgr->myCompMgr ()->myMatchFor (dstOwner);
d206 2
a207 2
      if (not srcScenAtt->isAllocatedFor (srcOwner))
         continue;
d209 1
a209 1
      myScenAtt_->allocateFor (dstOwner);
d211 3
a213 3
      forEachEl (dstScenario, myScenMgr ()->myScenarios ())
         {
         theScenIdx  = dstScenario->myIndex ();
d215 2
a216 2
         srcScenario =
            srcScenInputAtt->myScenMgr ()->myScenarioFor (theScenIdx);
d218 5
a222 5
         myScenAtt_   ->myValueFor (dstOwner, dstScenario) =
            srcScenAtt->myValueFor (srcOwner, srcScenario);
         }
      }
   }
d231 7
a237 7
      void WitScenInputAtt <Owner>::writeData (
         WitComponent * theComp,
         WitScenario *  theScenario,
         bool           diffedSec,
         bool &         attWritten)
   {
   Owner * theOwner;
d239 1
a239 1
   theOwner = theOwnerFor (theComp);
d241 2
a242 2
   if (theOwner == NULL)
      return;
d244 2
a245 2
   writeDataForOwner (theOwner, theScenario, diffedSec, attWritten);
   }
d250 8
a257 8
      void WitScenInputAtt <WitBoundSet>::writeData (
         WitComponent *,
         WitScenario *,
         bool,
         bool &)
   {
   stronglyAssert (false);
   }
d266 8
a273 8
      void WitScenInputAtt <Owner>::writeData (
         WitBoundSet *,
         WitScenario *,
         bool,
         bool &)
   {
   stronglyAssert (false);
   }
d278 8
a285 8
      void WitScenInputAtt <WitBoundSet>::writeData (
         WitBoundSet * theBoundSet,
         WitScenario * theScenario,
         bool          diffedSec,
         bool &        attWritten)
   {
   writeDataForOwner (theBoundSet, theScenario, diffedSec, attWritten);
   }
d293 4
a296 4
      bool WitScenInputAtt <Owner>::ownedByBoundSet ()
   {
   return false;
   }
d301 4
a304 4
      bool WitScenInputAtt <WitBoundSet>::ownedByBoundSet ()
   {
   return true;
   }
d309 3
a311 3
      void WitScenInputAtt <Owner>::prepSetForOwner (Owner * theOwner)
   {
   WitScenario * theScenario;
d313 2
a314 2
   if (myScenAtt_ == NULL)
      myScenAtt_ = new WitScenAtt <Owner> (myScenAttMgr ());
d316 3
a318 3
   if (not myScenAtt_->isAllocatedFor (theOwner))
      {
      myScenAtt_->allocateFor (theOwner);
d320 5
a324 5
      forEachEl (theScenario, myScenMgr ()->myScenarios ())
         myScenAtt_->myValueFor (theOwner, theScenario) =
            (theOwner->*myAccFunc_) ();
      }
   }
d329 5
a333 5
      void WitScenInputAtt <Owner>::validateData ()
   {
   Owner *   theOwner;
   WitNode * theNode;
   WitPeriod thePer;
d335 2
a336 2
   if (myScenAtt_ == NULL)
      return;
d338 4
a341 4
   forEachEl (theOwner, myScenAtt_->allOwners ())
      {
      if (not myScenAtt_->isAllocatedFor (theOwner))
         continue;
d343 1
a343 1
      theNode = stageNode (theOwner);
d345 5
a349 5
      forEachPeriod (thePer, myProblem ())
         if (myStageMgr ()->myStageOf (theNode, thePer)->isStage0 ())
            checkSameInAllScenarios (theOwner, thePer);
      }
   }
d357 4
a360 4
      WitPart * WitScenInputAtt <WitPart>::theOwnerFor (WitComponent * theComp)
   {
   return theComp->thisPart ();
   }
d365 5
a369 5
      WitMaterial * WitScenInputAtt <WitMaterial>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisMat ();
   }
d374 5
a378 5
      WitDemand * WitScenInputAtt <WitDemand>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisDemand ();
   }
d383 5
a387 5
      WitOperation * WitScenInputAtt <WitOperation>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisOpn ();
   }
d392 5
a396 5
      WitSubEntry * WitScenInputAtt <WitSubEntry>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisSub ();
   }
d401 3
a403 3
      WitBoundSet * WitScenInputAtt <WitBoundSet>::theOwnerFor (WitComponent *)
   {
   stronglyAssert (false);
d405 2
a406 2
   return NULL;
   }
d411 8
a418 8
      void WitScenInputAtt <Owner>::writeDataForOwner (
            Owner *        theOwner,
            WitScenario *  theScenario,
            bool           diffedSec,
            bool &         attWritten)
   {
   if (isDiffedAt (theOwner) != diffedSec)
      return;
d420 2
a421 2
   if (myValueFor (theOwner, theScenario) == myDefaultVal_)
      return;
d423 2
a424 2
   if (not attWritten)
      theOwner->writeSetClause ();
d426 5
a430 5
   myDataWriter ()->
      writeVector (
         myAttName_,
         myValueFor (theOwner, theScenario),
         myDefaultVal_);
d432 2
a433 2
   attWritten = true;
   }
d438 4
a441 4
      WitNode * WitScenInputAtt <WitPart>::stageNode (WitPart * thePart)
   {
   return thePart;
   }
d446 4
a449 4
      WitNode * WitScenInputAtt <WitMaterial>::stageNode (WitMaterial * theMat)
   {
   return theMat;
   }
d454 4
a457 4
      WitNode * WitScenInputAtt <WitDemand>::stageNode (WitDemand * theDemand)
   {
   return theDemand->demandedPart ();
   }
d462 5
a466 5
      WitNode * WitScenInputAtt <WitOperation>::stageNode (
         WitOperation * theOpn)
   {
   return theOpn;
   }
d471 4
a474 4
      WitNode * WitScenInputAtt <WitSubEntry>::stageNode (WitSubEntry * theSub)
   {
   return theSub->myOperation ();
   }
d479 5
a483 5
      WitNode * WitScenInputAtt <WitBoundSet>::stageNode (
         WitBoundSet * theBoundSet)
   {
   return theBoundSet->stageNode ();
   }
d488 8
a495 8
      void WitScenInputAtt <Owner>::checkSameInAllScenarios (
         Owner *   theOwner,
         WitPeriod thePer)
   {
   WitScenario * theScen0;
   double        attVal0;
   WitScenario * theScenX;
   double        attValX;
d497 1
a497 1
   theScen0 = myScenMgr ()->myScenarioFor (0);
d499 1
a499 1
   attVal0  = myScenAtt_->myValueFor (theOwner, theScen0)[thePer];
d501 4
a504 4
   forEachEl (theScenX, myScenMgr ()->myScenarios ())
      if (theScenX->myIndex () != 0)
         {
         attValX = myScenAtt_->myValueFor (theOwner, theScenX)[thePer];
d506 3
a508 3
         if (attValX != attVal0)
            {
            myStageMgr ()->issueAttMisMatchHeadMsg ();
d510 1
a510 1
            issueMisMatchOwnerMsg (theOwner);
d512 9
a520 9
            myMsgFac () ("stage0AttMisMatchTailSmsg",
               myAttName_,
               thePer,
               attVal0,
               theScenX->myIndex (),
               attValX);
            }
         }
   }
d528 4
a531 4
      void WitScenInputAtt <WitPart>::issueMisMatchOwnerMsg (WitPart * thePart)
   {
   myMsgFac () ("stage0AttMisMatchPartSmsg", thePart->partName ());
   }
d536 5
a540 5
      void WitScenInputAtt <WitMaterial>::issueMisMatchOwnerMsg (
         WitMaterial * theMat)
   {
   myMsgFac () ("stage0AttMisMatchPartSmsg", theMat->partName ());
   }
d545 7
a551 7
      void WitScenInputAtt <WitDemand>::issueMisMatchOwnerMsg (
         WitDemand * theDemand)
   {
   myMsgFac () ("stage0AttMisMatchDemandSmsg",
      theDemand->demandedPartName (),
      theDemand->demandName       ());
   }
d556 5
a560 5
      void WitScenInputAtt <WitOperation>::issueMisMatchOwnerMsg (
         WitOperation * theOpn)
   {
   myMsgFac () ("stage0AttMisMatchOpnSmsg", theOpn->operationName ());
   }
d565 8
a572 8
      void WitScenInputAtt <WitSubEntry>::issueMisMatchOwnerMsg (
         WitSubEntry * theSub)
   {
   myMsgFac () ("stage0AttMisMatchSubSmsg",
      theSub->myOperationName (),
      theSub->myBomEntIndex   (),
      theSub->localIndex      ());
   }
d577 4
a580 4
      void WitScenInputAtt <WitBoundSet>::issueMisMatchOwnerMsg (
         WitBoundSet * theBoundSet)
   {
   theBoundSet->issueStage0MMCompMsg ();
d582 2
a583 2
   myMsgFac () ("stage0AttMisMatchBoundSetSmsg", theBoundSet->myAttName ());
   }
d589 5
a593 5
      bool WitScenInputAtt <Owner>::isDiffedAt (Owner * theOwner)
   {
   if (myScenAtt_ != NULL)
      if (myScenAtt_->isAllocatedFor (theOwner))
         return true;
d595 2
a596 2
   return false;
   }
d614 2
a615 2
   {
   }
d621 4
a624 4
      WitStochAssoc (theScenAttMgr)
   {
   theScenAttMgr->store (this);
   }
d631 4
a634 4
      WitScenSolnAtt <Owner>::WitScenSolnAtt (
            WitScenAttMgr * theScenAttMgr,
            const char *    theAttName,
            void (Owner::*  theStoreFunc) (const WitDblFlexVec &)):
d636 5
a640 5
         WitAbsScenSolnAtt (theScenAttMgr),
         myScenAtt_        (NULL),
         myStoreFunc_      (theStoreFunc)
   {
   Owner * theOwner;
d642 1
a642 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr);
d644 2
a645 2
   forEachEl (theOwner, myScenAtt_->allOwners ())
      myScenAtt_->allocateFor (theOwner);
d647 2
a648 2
   myStochModeMgr ()->myStochAttMgr ()->makeScenSolnStochAtt (theAttName);
   }
d653 7
a659 7
      void WitScenSolnAtt <Owner>::storeValueFor (
         Owner *       theOwner,
         WitScenario * theScenario,
         WitPeriod     thePer,
         double        theValue)
   {
   witAssert (myStochModeMgr ()->myStochOptMgr ()->uploadingSoln ());
d661 2
a662 2
   if (theValue <= 0.0)
      return;
d664 2
a665 2
   myScenAtt_->myValueFor (theOwner, theScenario).elemRef (thePer) = theValue;
   }
d670 4
a673 4
      WitScenSolnAtt <Owner>::~WitScenSolnAtt ()
   {
   delete myScenAtt_;
   }
d678 3
a680 3
      void WitScenSolnAtt <Owner>::uploadData (WitScenario * theScenario)
   {
   Owner * theOwner;
d682 4
a685 4
   forEachEl (theOwner, myScenAtt_->allOwners ())
      (theOwner->*myStoreFunc_) (
         myScenAtt_->myValueFor (theOwner, theScenario));
   }
d688 1
a688 1
  
d690 4
a693 4
      void WitScenSolnAtt <Owner>::clearData ()
   {
   Owner *       theOwner;
   WitScenario * theScenario;
d695 4
a698 4
   forEachEl (theOwner, myScenAtt_->allOwners ())
      forEachEl (theScenario, myScenMgr ()->myScenarios ())
         myScenAtt_->myValueFor (theOwner, theScenario) = 0.0;
   }
d715 1
a715 1
      WitScenAtt <Owner>::WitScenAtt (WitScenAttMgr * theScenAttMgr):
d717 5
a721 5
         WitStochAssoc (theScenAttMgr),
         myScenAttMgr_ (theScenAttMgr),
         myValue_      (myProblem ())
   {
   }
d726 4
a729 4
      WitScenAtt <Owner>::~WitScenAtt ()
   {
   Owner *       theOwner;
   WitScenario * theScenario;
d731 5
a735 5
   forEachEl (theOwner, allOwners ())
      if (isAllocatedFor (theOwner))
         {
         forEachEl (theScenario, myScenMgr ()->myScenarios ())
            delete myValue_.myElemAt (theOwner) (theScenario);
d737 3
a739 3
         delete myValue_ (theOwner);
         }
   }
d746 5
a750 5
template <> 
      const WitList <WitPart> & WitScenAtt <WitPart>::allOwners ()
   {
   return myScenAttMgr_->myCompMgr ()->allParts ();
   }
d755 4
a758 4
      const WitList <WitMaterial> & WitScenAtt <WitMaterial>::allOwners ()
   {
   return myScenAttMgr_->allMats ();
   }
d763 4
a766 4
      const WitList <WitDemand> & WitScenAtt <WitDemand>::allOwners ()
   {
   return myScenAttMgr_->allDemands ();
   }
d771 4
a774 4
      const WitList <WitOperation> & WitScenAtt <WitOperation>::allOwners ()
   {
   return myScenAttMgr_->myCompMgr ()->allOperations ();
   }
d779 4
a782 4
      const WitList <WitSubEntry> & WitScenAtt <WitSubEntry>::allOwners ()
   {
   return myScenAttMgr_->allSubs ();
   }
d786 5
a790 5
template <> 
      const WitList <WitBoundSet> & WitScenAtt <WitBoundSet>::allOwners ()
   {
   return myScenAttMgr_->allBoundSets ();
   }
d795 3
a797 3
      void WitScenAtt <Owner>::allocateFor (Owner * theOwner)
   {
   WitScenario * theScenario;
d799 1
a799 1
   witAssert (not isAllocatedFor (theOwner));
d801 2
a802 2
   myValue_ (theOwner) =
      new WitPtrMap <WitScenario, WitDblFlexVec> (myProblem ());
d804 4
a807 4
   forEachEl (theScenario, myScenMgr ()->myScenarios ())
      myValue_.myElemAt (theOwner) (theScenario) =
         new WitDblFlexVec (myProblem (), 0.0);
   }
@


1.58
log
@Multi-Objective Mode
@
text
@d37 1
a37 1
#include <Opn.h>
@


1.57
log
@Stochastic Implosion
@
text
@d424 1
a424 1
      writeSetClause (theOwner);
a435 68
// Template specialized implementation of member function
// ScenInputAtt <Owner>::writeSetClause (theOwner)
//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitPart>::writeSetClause (WitPart * thePart)
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (thePart->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitMaterial>::writeSetClause (WitMaterial * theMat)
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (theMat->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitDemand>::writeSetClause (WitDemand * theDemand)
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (theDemand->demandedPartName ());
   myDataWriter ()->writeStringValue  (theDemand->demandName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitOperation>::writeSetClause (
         WitOperation * theOpn)
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("operation");
   myDataWriter ()->writeStringValue  (theOpn->operationName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitSubEntry>::writeSetClause (WitSubEntry * theSub)
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("subEntry");
   myDataWriter ()->writeStringValue  (theSub->myOperationName ());
   myDataWriter ()->writeIntValue     (theSub->myBomEntIndex   ());
   myDataWriter ()->writeIntValue     (theSub->localIndex      ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::writeSetClause (
         WitBoundSet * theBoundSet)
   {
   theBoundSet->writeCompSetClause ();

   myDataWriter ()->writeFirstKeyWord (theBoundSet->myAttName ());
   }

//------------------------------------------------------------------------------
@


1.56
log
@Srochastic Implosion
@
text
@d346 1
a346 1
         if (myStageMgr ()->myStageOf (theNode, thePer)->myIndex () == 0)
@


1.55
log
@Stochastic Implosion
@
text
@d346 1
a346 1
         if (myStageMgr ()->stageOf (theNode, thePer)->myIndex () == 0)
@


1.54
log
@Stochastic Implosion
@
text
@d30 1
d346 1
a346 1
         if (myStageMgr ()->stageOf (theNode, thePer) == 0)
@


1.53
log
@Stochastic Implosion
@
text
@d30 1
a30 2
#include <ObjStageMgr.h>
#include <PerStageMgr.h>
d331 1
d342 1
a342 2
      if (myStageMgr ()->nodeBelongsToStage (stageNode (theOwner), 1))
         continue;
d345 2
a346 6
         {
         if (myStageMgr ()->perBelongsToStage (thePer, 1))
            continue;

         checkSameInAllScenarios (theOwner, thePer);
         }
@


1.52
log
@Stochastic Implosion
@
text
@a332 1
   int       stageIdx;
d342 3
d347 2
a348 4
         stageIdx =
            myStochImpMgr ()->stageByObject ()?
               myStochModeMgr ()->myObjStageMgr ()->objectStage (theOwner):
               myStochModeMgr ()->myPerStageMgr ()->periodStage ()[thePer];
d350 1
a350 2
         if (stageIdx == 0)
            checkSameInAllScenarios (theOwner, thePer);
d509 50
@


1.51
log
@Stochastic Implosion
@
text
@a25 1
#include <StochModeMgr.h>
d54 1
a54 1
      WitProbAssoc (theScenAttMgr)
d79 1
a79 3
         myInstFunc_        (theInstFunc),
         myStochModeMgr_    (theScenAttMgr->myStochModeMgr ()),
         myScenMgr_         (theScenAttMgr->myScenMgr ())
d81 3
a83 1
   myStochModeMgr_->myStochAttMgr ()->makeScenInputStochAtt (myAttName_, this);
d200 1
a200 1
   myScenAtt_ = new WitScenAtt <Owner> (myStochModeMgr_->myScenAttMgr ());
d211 1
a211 1
      forEachEl (dstScenario, myScenMgr_->myScenarios ())
d215 2
a216 1
         srcScenario = srcScenAttMgr->myScenMgr ()->myScenarioFor (theScenIdx);
d314 1
a314 1
      myScenAtt_ = new WitScenAtt <Owner> (myStochModeMgr_->myScenAttMgr ());
d320 1
a320 1
      forEachEl (theScenario, myScenMgr_->myScenarios ())
d347 2
a348 2
               myStochModeMgr_->myObjStageMgr ()->objectStage (theOwner):
               myStochModeMgr_->myPerStageMgr ()->periodStage ()[thePer];
d520 1
a520 1
   theScen0 = myScenMgr_->myScenarioFor (0);
d524 1
a524 1
   forEachEl (theScenX, myScenMgr_->myScenarios ())
d531 1
a531 1
            myStochModeMgr_->myStageMgr ()->issueAttMisMatchHeadMsg ();
d644 1
a644 1
      WitProbAssoc (theScenAttMgr)
a659 1
         myStochModeMgr_   (theScenAttMgr->myStochModeMgr ()),
d670 1
a670 1
   myStochModeMgr_->myStochAttMgr ()->makeScenSolnStochAtt (theAttName);
d682 1
a682 1
   witAssert (myStochModeMgr_->myStochOptMgr ()->uploadingSoln ());
d719 1
a719 1
      forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
d740 1
a740 1
         WitProbAssoc  (theScenAttMgr),
a750 1
   WitScenMgr *  theScenMgr;
a753 2
   theScenMgr = myScenAttMgr_->myStochModeMgr ()->myScenMgr ();

d757 1
a757 1
         forEachEl (theScenario, theScenMgr->myScenarios ())
a819 1
   WitScenMgr *  theScenMgr;
d827 1
a827 3
   theScenMgr = myScenAttMgr_->myStochModeMgr ()->myScenMgr ();

   forEachEl (theScenario, theScenMgr->myScenarios ())
@


1.50
log
@Stochastic Implosion
@
text
@d347 2
a348 2
               myStochModeMgr_->myObjStageMgr ()->   stageIndex (theOwner):
               myStochModeMgr_->myPerStageMgr ()->perStageIndex ()[thePer];
@


1.49
log
@Stochastic Implosion
@
text
@d32 1
d81 1
a81 1
         myScenAttMgr_      (theScenAttMgr),
d84 1
a84 4
   myScenAttMgr_->
      myStochModeMgr ()->
         myStochAttMgr ()->
            makeScenInputStochAtt (myAttName_, this);
d201 1
a201 1
   myScenAtt_ = new WitScenAtt <Owner> (myScenAttMgr_);
d314 1
a314 1
      myScenAtt_ = new WitScenAtt <Owner> (myScenAttMgr_);
d331 3
a333 7
   WitObjStageMgr * theObjStageMgr;
   WitScenario *    theScenA;
   Owner *          theOwner;
   WitScenario *    theScenB;
   WitPeriod        thePer;
   double           attValA;
   double           attValB;
a337 7
   if (myStochImpMgr ()->stageByObject ())
      theObjStageMgr = myScenAttMgr_->myStochModeMgr ()->myObjStageMgr ();
   else
      myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

   theScenA       = myScenMgr_->myScenarioFor (0);

a339 3
      if (theObjStageMgr->stageIndex (theOwner) != 0)
         continue;

d343 1
a343 1
      forEachEl (theScenB, myScenMgr_->myScenarios ())
d345 4
a348 7
         if (theScenB == theScenA)
            continue;
   
         forEachPeriod (thePer, myProblem ())
            {
            attValA = myScenAtt_->myValueFor (theOwner, theScenA)[thePer];
            attValB = myScenAtt_->myValueFor (theOwner, theScenB)[thePer];
d350 2
a351 14
            if (attValB != attValA)
               {
               myMsgFac () ("stage0AttMisMatchHeadSmsg");

               issueMisMatchOwnerMsg (theOwner);

               myMsgFac () ("stage0AttMisMatchTailSmsg",
                  myAttName_,
                  thePer,
                  attValA,
                  theScenB->myIndex (),
                  attValB);
               }
            }
d509 37
@


1.48
log
@Stochastic Implosion
@
text
@d27 1
d344 4
a347 1
   theObjStageMgr = myScenAttMgr_->myStochModeMgr ()->myObjStageMgr ();
@


1.47
log
@Stochastic Implosion
@
text
@d30 1
a30 1
#include <StageMgr.h>
d332 7
a338 7
   WitStageMgr * theStageMgr;
   WitScenario * theScenA;
   Owner *       theOwner;
   WitScenario * theScenB;
   WitPeriod     thePer;
   double        attValA;
   double        attValB;
d343 1
a343 1
   theStageMgr = myScenAttMgr_->myStochModeMgr ()->myStageMgr ();
d345 1
a345 1
   theScenA    = myScenMgr_->myScenarioFor (0);
d349 1
a349 1
      if (theStageMgr->stageIndex (theOwner) != 0)
@


1.46
log
@Stochastic Implosion
@
text
@a14 1
//    ScenAttMgr
a41 348
// Implementation of class ScenAttMgr.
//------------------------------------------------------------------------------

WitScenAttMgr::WitScenAttMgr (WitStochModeMgr * theStochModeMgr):

      WitProbAssoc        (theStochModeMgr),
      myStochModeMgr_     (theStochModeMgr),
      myScenMgr_          (theStochModeMgr->myScenMgr ()),
      myAbsScenInputAtts_ (),
      myAbsScenSolnAtts_  (),
      buildingInputAtts_  (false),
      buildingSolnAtts_   (false),
      supplyVol_          (),
      scrapCost_          (),
      stockCost_          (),
      demandVol_          (),
      shipReward_         (),
      cumShipReward_      (),
      execCost_           (),
      subCost_            (),
      hardLB_             (),
      softLB_             (),
      hardUB_             (),
      scrapVol_           (),
      stockVol_           (),
      shipVol_            (),
      cumShipVol_         (),
      execVol_            (),
      subVol_             (),
      allMats_            (),
      allDemands_         (),
      allSubs_            (),
      allBoundSets_       ()
   {
   listOwners         ();
   buildScenInputAtts ();
   buildScenSolnAtts  ();
   }

//------------------------------------------------------------------------------

WitScenAttMgr::~WitScenAttMgr ()
   {
   while (not myAbsScenSolnAtts_.isEmpty ())
      delete myAbsScenSolnAtts_.get ();

   while (not myAbsScenInputAtts_.isEmpty ())
      delete myAbsScenInputAtts_.get ();
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::downloadInput ()
   {
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->downloadData (myScenMgr_->curScenario ());
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::uploadInput ()
   {
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->uploadData (myScenMgr_->curScenario ());
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::copyInputFrom (WitScenAttMgr * srcScenAttMgr)
   {
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->copyDataFrom (srcScenAttMgr);
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::writeCompData (WitScenario * theScenario, bool diffedSec)
   {
   WitComponent *       theComp;
   WitDelComp *         theDelComp;
   bool                 attWritten;
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      theDelComp = theComp->thisDelComp ();

      if (theDelComp == NULL)
         continue;

      attWritten = false;

      forEachEl (theInputAtt, myAbsScenInputAtts_)
         if (not theInputAtt->ownedByBoundSet ())
            theInputAtt->
               writeData (theComp, theScenario, diffedSec, attWritten);

      if (attWritten)
         myDataWriter ()->writeEndCommand ();
      }
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::writeBoundSetData (
      WitScenario * theScenario,
      bool          diffedSec)
   {
   WitBoundSet *        theBoundSet;
   bool                 attWritten;
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theBoundSet, allBoundSets_)
      {
      attWritten = false;

      forEachEl (theInputAtt, myAbsScenInputAtts_)
         if (theInputAtt->ownedByBoundSet ())
            theInputAtt->
               writeData (theBoundSet, theScenario, diffedSec, attWritten);

      if (attWritten)
         {
         myDataWriter ()->writeFirstKeyWord ("endBounds");
         myDataWriter ()->writeEndCommand ();
         }
      }
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::validateData ()
   {
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->validateData ();
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::uploadSoln ()
   {
   WitAbsScenSolnAtt * theSolnAtt;

   forEachEl (theSolnAtt, myAbsScenSolnAtts_)
      theSolnAtt->uploadData (myScenMgr_->curScenario ());
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::clearSoln ()
   {
   WitAbsScenSolnAtt * theSolnAtt;

   forEachEl (theSolnAtt, myAbsScenSolnAtts_)
      theSolnAtt->clearData ();
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::store (WitAbsScenInputAtt * theInputAtt)
   {
   stronglyAssert (buildingInputAtts_);

   myAbsScenInputAtts_.append (theInputAtt);
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::store (WitAbsScenSolnAtt * theSolnAtt)
   {
   stronglyAssert (buildingSolnAtts_);

   myAbsScenSolnAtts_.append (theSolnAtt);
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::listOwners ()
   {
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitSubEntry *  theSub;
   WitComponent * theComp;
   WitBoundSet *  theBoundSet;

   forEachMaterial (theMat, myProblem ())
      allMats_.append (theMat);

   forEachDemand (theDemand, myProblem ())
      allDemands_.append (theDemand);

   forEachSubEntry (theSub, myProblem ())
      allSubs_.append (theSub);

   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      theBoundSet = theComp->myBoundSet ();

      if (theBoundSet != NULL)
         allBoundSets_.append (theBoundSet);
      }
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::buildScenInputAtts ()
   {
   buildingInputAtts_ = true;

   supplyVol_ =
      new WitScenInputAtt      <WitPart> (this,
                                         "supplyVol",
                                 WitPart::defSupplyVol (),
                               & WitPart::supplyVol,
                               & WitPart::storeStochSupplyVol,
                         & WitScenAttMgr::supplyVol);

   scrapCost_ =
      new WitScenInputAtt      <WitPart> (this,
                                         "scrapCost",
                                 WitPart::defScrapCost (),
                               & WitPart::scrapCost,
                               & WitPart::storeStochScrapCost,
                         & WitScenAttMgr::scrapCost);

   stockCost_ =
      new WitScenInputAtt  <WitMaterial> (this,
                                         "stockCost",
                             WitMaterial::defStockCost (),
                           & WitMaterial::stockCost,
                           & WitMaterial::storeStochStockCost,
                         & WitScenAttMgr::stockCost);

   demandVol_ =
      new WitScenInputAtt    <WitDemand> (this,
                                         "demandVol",
                               WitDemand::defDemandVol (),
                             & WitDemand::demandVol,
                             & WitDemand::storeStochDemandVol,
                         & WitScenAttMgr::demandVol);

   shipReward_ =
      new WitScenInputAtt    <WitDemand> (this,
                                         "shipReward",
                               WitDemand::defShipReward (),
                             & WitDemand::shipReward,
                             & WitDemand::storeStochShipReward,
                         & WitScenAttMgr::shipReward);

   cumShipReward_ =
      new WitScenInputAtt    <WitDemand> (this,
                                         "cumShipReward",
                               WitDemand::defCumShipReward (),
                             & WitDemand::cumShipReward,
                             & WitDemand::storeStochCumShipReward,
                         & WitScenAttMgr::cumShipReward);

   execCost_ =
      new WitScenInputAtt <WitOperation> (this,
                                         "execCost",
                            WitOperation::defExecCost (),
                          & WitOperation::execCost,
                          & WitOperation::storeStochExecCost,
                         & WitScenAttMgr::execCost);

   subCost_ =
      new WitScenInputAtt  <WitSubEntry> (this,
                                         "subCost",
                             WitSubEntry::defSubCost (),
                           & WitSubEntry::subCost,
                           & WitSubEntry::storeStochSubCost,
                         & WitScenAttMgr::subCost);

   hardLB_ =
      new WitScenInputAtt <WitBoundSet> (this,
                                        "hardLB",
                            WitBoundSet::defHardLB (),
                          & WitBoundSet::hardLB,
                          & WitBoundSet::storeStochHardLB,
                        & WitScenAttMgr::hardLB);

   softLB_ =
      new WitScenInputAtt <WitBoundSet> (this,
                                        "softLB",
                            WitBoundSet::defSoftLB (),
                          & WitBoundSet::softLB,
                          & WitBoundSet::storeStochSoftLB,
                        & WitScenAttMgr::softLB);

   hardUB_ =
      new WitScenInputAtt <WitBoundSet> (this,
                                        "hardUB",
                            WitBoundSet::defHardUB (),
                          & WitBoundSet::hardUB,
                          & WitBoundSet::storeStochHardUB,
                        & WitScenAttMgr::hardUB);

   buildingInputAtts_ = false;
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::buildScenSolnAtts ()
   {
   buildingSolnAtts_ = true;

   scrapVol_   =
      new WitScenSolnAtt <WitPart>      (this,
                                        "scrapVol",
                        & WitPart::      storeStochScrapVol);

   stockVol_   =
      new WitScenSolnAtt <WitMaterial>  (this,
                                        "stockVol",
                        & WitMaterial::  storeStochStockVol);

   shipVol_    =
      new WitScenSolnAtt <WitDemand>    (this,
                                        "shipVol",
                        & WitDemand::    storeStochShipVol);

   cumShipVol_ =
      new WitScenSolnAtt <WitDemand>    (this,
                                        "cumShipVol",
                        & WitDemand::    storeStochCumShipVol);

   execVol_    =
      new WitScenSolnAtt <WitOperation> (this,
                                        "execVol",
                        & WitOperation:: storeStochExecVol);

   subVol_     =
      new WitScenSolnAtt <WitSubEntry>  (this,
                                        "subVol",
                        & WitSubEntry::  storeStochSubVol);

   buildingSolnAtts_ = false;
   }

//------------------------------------------------------------------------------
d612 11
@


1.45
log
@Stochastic Implosion
@
text
@d428 2
a429 1
         myStochModeMgr_    (theScenAttMgr->myStochModeMgr ())
d431 4
a434 3
   myStochModeMgr_->
      myStochAttMgr ()->
         makeScenInputStochAtt (myAttName_, this);
d551 1
a551 1
   myScenAtt_ = new WitScenAtt <Owner> (myStochModeMgr_->myScenAttMgr ());
d562 1
a562 1
      forEachEl (dstScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
d664 1
a664 1
      myScenAtt_ = new WitScenAtt <Owner> (myStochModeMgr_->myScenAttMgr ());
d670 1
a670 1
      forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
d681 1
a681 1
   WitScenMgr *  theScenMgr;
d692 1
a692 1
   theScenMgr = myStochModeMgr_->myScenMgr ();
d694 1
a694 1
   theScenA   = theScenMgr     ->myScenarioFor (0);
d698 1
a698 1
      if (myStochModeMgr_->myStageMgr ()->stageIndex (theOwner) != 0)
d704 1
a704 1
      forEachEl (theScenB, theScenMgr->myScenarios ())
@


1.44
log
@Stochastic Implosion
@
text
@d940 1
a940 1
   theBoundSet->issueStage0MisMatchDelCompMsg ();
@


1.43
log
@Allowing wit34Compatible in stochastic mode.
@
text
@d31 1
d180 10
d675 56
d883 64
@


1.42
log
@Stochastic Implosion
@
text
@a27 1
#include <StageMgr.h>
@


1.41
log
@Stochastic Implosion
@
text
@d56 2
d59 4
d251 22
a272 6
      new WitScenInputAtt     <WitPart> (this,
                                        "supplyVol",
                                WitPart::defSupplyVol (),
                              & WitPart::supplyVol,
                              & WitPart::storeStochSupplyVol,
                        & WitScenAttMgr::supplyVol);
d275 38
a312 6
      new WitScenInputAtt   <WitDemand> (this,
                                        "demandVol",
                              WitDemand::defDemandVol (),
                            & WitDemand::demandVol,
                            & WitDemand::storeStochDemandVol,
                        & WitScenAttMgr::demandVol);
d678 9
d696 18
d764 10
d785 23
@


1.40
log
@Stochastic Implosion
@
text
@d109 1
a109 1
void WitScenAttMgr::copyInputFrom (WitScenAttMgr * thatScenAttMgr)
d114 1
a114 1
      theInputAtt->copyDataFrom (thatScenAttMgr);
d379 1
a379 1
      return myScenAtt ()->myValueFor (theOwner, theScenario);
d444 3
a446 3
      forEachEl (theOwner, myScenAtt ()->allOwners ())
         if (myScenAtt ()->isAllocatedFor (theOwner))
             myScenAtt ()->myValueFor     (theOwner, theScenario) =
d458 2
a459 2
      forEachEl (theOwner, myScenAtt ()->allOwners ())
         if (myScenAtt ()->isAllocatedFor (theOwner))
d466 1
a466 2
      void WitScenInputAtt <Owner>::copyDataFrom (
         WitScenAttMgr * thatScenAttMgr)
d468 7
a474 5
   WitScenInputAtt *    thatScenInputAtt;
   WitScenAtt <Owner> * thatScenAtt;
   WitScenMgr *         theScenMgr;
   Owner *              theOwner;
   WitScenario *        theScenario;
d478 1
a478 1
   thatScenInputAtt = (thatScenAttMgr->*myInstFunc_) ();
d480 1
a480 1
   thatScenAtt      = thatScenInputAtt->myScenAtt_;
d482 1
a482 1
   if (thatScenAtt == NULL)
d487 6
a492 1
   theScenMgr = myStochModeMgr_->myScenMgr ();
d494 3
a496 2
   forEachEl (theOwner, myScenAtt ()->allOwners ())
      if (thatScenAtt->isAllocatedFor (theOwner))
d498 3
a500 1
         myScenAtt ()->allocateFor (theOwner);
d502 2
a503 3
         forEachEl (theScenario, theScenMgr->myScenarios ())
            myScenAtt ()->  myValueFor (theOwner, theScenario) =
               thatScenAtt->myValueFor (theOwner, theScenario);
d505 1
d600 1
a600 1
   if (not myScenAtt ()->isAllocatedFor (theOwner))
d602 1
a602 1
      myScenAtt ()->allocateFor (theOwner);
d605 1
a605 1
         myScenAtt ()->myValueFor (theOwner, theScenario) =
d708 1
a708 1
      if (myScenAtt ()->isAllocatedFor (theOwner))
d746 2
d750 2
a751 1
   myScenAtt_->allocate ();
a903 11
      void WitScenAtt <Owner>::allocate ()
   {
   Owner * theOwner;

   forEachEl (theOwner, allOwners ())
      allocateFor (theOwner);
   }

//------------------------------------------------------------------------------

template <typename Owner>
@


1.39
log
@Stochastic Implosion
@
text
@d364 1
a364 2
         myStochModeMgr_    (theScenAttMgr->myStochModeMgr ()),
         active_            (false)
a365 2
   myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr);

d378 4
a381 4
   return
      active_?
         myScenAtt_->myValueFor (theOwner, theScenario):
         (theOwner->*myAccFunc_) ();
d393 3
d398 15
a412 1
      void WitScenInputAtt <Owner>::prepSet ()
d414 2
a415 1
   WitScenario * theScenario;
d417 4
a420 2
   if (active_)
      return;
d422 5
a426 1
   myScenAtt_->allocate ();
d428 1
a428 1
   active_ = true;
d430 4
a433 2
   forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
      downloadData (theScenario);
d443 5
a447 6
   if (not active_)
      return;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      myScenAtt_->myValueFor (theOwner, theScenario) =
         (theOwner->*myAccFunc_) ();
d457 4
a460 5
   if (not active_)
      return;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      (theOwner->*myStoreFunc_) (myValueFor (theOwner, theScenario));
d469 5
a473 3
   WitScenInputAtt * thatScenInputAtt;
   Owner *           theOwner;
   WitScenario *     theScenario;
d475 1
a475 1
   witAssert (not active_);
d479 3
a481 1
   if (not thatScenInputAtt->active_)
d484 3
a486 1
   myScenAtt_->allocate ();
d488 4
a491 1
   active_ = true;
d493 4
a496 4
   forEachEl (theOwner, myScenAtt_->allOwners ())
      forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
         myScenAtt_->         myValueFor (theOwner, theScenario) =
            thatScenInputAtt->myValueFor (theOwner, theScenario);
d500 3
a502 3
// Implementation of member function
// ScenInputAtt <Owner>::writeData (Component *, Scenario *, bool, bool &)
// Template specialized for Owner = BoundSet; otherwise not specialized.
d512 1
a512 19
   WitDelComp * theDelComp;
   Owner *      theOwner;

   theDelComp = theComp->thisDelComp ();

   if (diffedSec)
      {
      if (theDelComp->stageIndex () == 0)
         return;

      if (not active_)
         return;
      }
   else
      {
      if (theDelComp->stageIndex () == 1)
         if (active_)
            return;
      }
d519 1
a519 13
   if (myValueFor (theOwner, theScenario) == myDefaultVal_)
      return;

   if (not attWritten)
      writeSetClause (theOwner);

   myDataWriter ()->
      writeVector (
         myAttName_,
         myValueFor (theOwner, theScenario),
         myDefaultVal_);

   attWritten = true;
d535 3
a537 3
// Implementation of member function
// ScenInputAtt <Owner>::writeData (BoundSet *, Scenario *, bool, bool &)
// Template specialized for Owner = BoundSet; otherwise not specialized.
d559 1
a559 32
   if (diffedSec)
      {
      if (theBoundSet->myDelComp ()->stageIndex () == 0)
         return;

      if (not active_)
         return;
      }
   else
      {
      if (theBoundSet->myDelComp ()->stageIndex () == 1)
         if (active_)
            return;
      }

   if (myValueFor (theBoundSet, theScenario) == myDefaultVal_)
      return;

   if (not attWritten)
      {
      theBoundSet->writeCompSetClause ();

      myDataWriter ()->writeFirstKeyWord (theBoundSet->myAttName ());
      }

   myDataWriter ()->
      writeVector (
         myAttName_,
         myValueFor (theBoundSet, theScenario),
         myDefaultVal_);

   attWritten = true;
d563 2
a564 2
// Implementation of member function ScenInputAtt <Owner>::ownedByBoundSet ().
// Template specialized for Owner = BoundSet; otherwise not specialized.
d582 20
d632 27
d685 2
a686 1
      void WitScenInputAtt <WitBoundSet>::writeSetClause (WitBoundSet *)
d688 15
a702 3
   stronglyAssert (false);
      //
      // writeSetClause is not to be called in the BoundSet case.
d813 1
a813 2
         myValue_      (),
         isAllocated_  (false)
a825 28
   if (not isAllocated_)
      return;

   theScenMgr = myScenAttMgr_->myStochModeMgr ()->myScenMgr ();

   forEachEl (theOwner, allOwners ())
      {
      forEachEl (theScenario, theScenMgr->myScenarios ())
         delete myValue_.myElemAt (theOwner) (theScenario);

      delete myValue_ (theOwner);
      }
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenAtt <Owner>::allocate ()
   {
   WitScenMgr *  theScenMgr;
   Owner *       theOwner;
   WitScenario * theScenario;

   if (isAllocated_)
      return;

   myValue_.allocate (myProblem ());

d829 4
a832 8
      {
      myValue_ (theOwner) =
         new WitPtrMap <WitScenario, WitDblFlexVec> (myProblem ());

      forEachEl (theScenario, theScenMgr->myScenarios ())
         myValue_.myElemAt (theOwner) (theScenario) =
            new WitDblFlexVec (myProblem (), 0.0);
      }
d834 2
a835 1
   isAllocated_ = true;
d888 31
@


1.38
log
@Stochastic Implosion
@
text
@d119 1
a119 1
void WitScenAttMgr::writeCompData (WitScenario * theScenario, bool diffedAtts)
d138 1
a138 1
               writeData (theComp, theScenario, diffedAtts, attWritten);
d149 1
a149 1
      bool          diffedAtts)
d162 1
a162 1
               writeData (theBoundSet, theScenario, diffedAtts, attWritten);
d479 1
a479 1
         bool           diffedAtt,
d487 1
a487 1
   if (diffedAtt)
d556 1
a556 1
         bool          diffedAtt,
d559 1
a559 1
   if (diffedAtt)
@


1.37
log
@Stochastic Implosion
@
text
@d119 1
a119 1
void WitScenAttMgr::writeCompData (WitScenario * theScenario, int stageToWrite)
a132 3
      if (theDelComp->stageIndex () != stageToWrite)
         continue;

d137 2
a138 1
            theInputAtt->writeData (theComp, theScenario, attWritten);
d149 1
a149 1
      int           stageToWrite)
a156 3
      if (theBoundSet->myDelComp ()->stageIndex () != stageToWrite)
         continue;

d161 2
a162 1
            theInputAtt->writeData (theBoundSet, theScenario, attWritten);
d471 1
a471 1
// ScenInputAtt <Owner>::writeData (Component *, Scenario *, int, bool &)
d479 1
d482 19
a500 1
   Owner * theOwner;
d528 1
d536 1
a536 1
// ScenInputAtt <Owner>::writeData (BoundSet *, Scenario *, bool &)
d544 1
d556 1
d559 15
@


1.36
log
@Stochastic Implosion
@
text
@d368 2
a369 1
         myStochModeMgr_    (theScenAttMgr->myStochModeMgr ())
a370 2
   WitScenario * theScenario;

a372 3
   forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
      downloadData (theScenario);

d385 4
a388 1
   return myScenAtt_->myValueFor (theOwner, theScenario);
d402 18
d424 3
d439 3
d455 3
a457 1
   
d460 7
d677 2
d751 9
a759 1
         myValue_      (myProblem ())
d765 3
d772 2
a773 2
      myValue_ (theOwner) =
         new WitPtrMap <WitScenario, WitDblFlexVec> (myProblem ());
d775 1
a775 3
      forEachEl (theScenario, theScenMgr->myScenarios ())
         myValue_.myElemAt (theOwner) (theScenario) =
            new WitDblFlexVec (myProblem (), 0.0);
d782 1
a782 1
      WitScenAtt <Owner>::~WitScenAtt ()
d788 5
d797 3
d801 3
a803 1
         delete myValue_.myElemAt (theOwner) (theScenario);
d805 1
a805 2
      delete myValue_ (theOwner);
      }
@


1.35
log
@Stochastic Implosion
@
text
@a122 1
   int                  theStageIdx;
d133 1
a133 3
      theStageIdx = myStochModeMgr_->myStageMgr ()->stageIndex (theDelComp);

      if (theStageIdx != stageToWrite)
a153 1
   int                  theStageIdx;
d159 1
a159 6
      theStageIdx =
         myStochModeMgr_->
            myStageMgr ()->
               stageIndex (theBoundSet->myDelComp ());

      if (theStageIdx != stageToWrite)
a578 30
// ScenInputAtt <Owner>::stageIndex (theOwner)
//------------------------------------------------------------------------------

template <>
      int WitScenInputAtt <WitPart>::stageIndex (WitPart * thePart)
   {
   return myStochModeMgr_->myStageMgr ()->stageIndex (thePart);
   }

//------------------------------------------------------------------------------

template <>
      int WitScenInputAtt <WitDemand>::stageIndex (WitDemand * theDemand)
   {
   return
      myStochModeMgr_->myStageMgr ()->stageIndex (theDemand->demandedPart ());
   }

//------------------------------------------------------------------------------

template <>
      int WitScenInputAtt <WitBoundSet>::stageIndex (WitBoundSet * theBoundSet)
   {
   stronglyAssert (false);

   return -1;
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
@


1.34
log
@Stochastic Implosion
@
text
@a32 1
#include <StBSMgr.h>
d523 1
a523 1
      myStochModeMgr_->myStBSMgr ()->writeCompSetClause (theBoundSet);
@


1.33
log
@Stochastic Implosion
@
text
@d120 1
a120 1
void WitScenAttMgr::writeData (WitScenario * theScenario, int stageToWrite)
d123 2
a124 2
   WitBoundSet *        theBoundSet;
   int                  theBsStageIdx;
d130 10
d144 1
a144 2
            theInputAtt->
               writeData (theComp, theScenario, stageToWrite, attWritten);
d149 12
d164 4
a167 1
      theBsStageIdx = myStochModeMgr_->myStBSMgr ()->stageIndex (theBoundSet);
d169 1
a169 1
      if (theBsStageIdx != stageToWrite)
a460 1
         int            stageToWrite,
a469 3
   if (stageIndex (theOwner) != stageToWrite)
      return;

a490 1
         int,
@


1.32
log
@Stochastic Implosion
@
text
@d120 1
a120 1
void WitScenAttMgr::writeData (WitScenario * theScenario)
d124 1
d134 2
a135 1
            theInputAtt->writeData (theComp, theScenario, attWritten);
d143 3
a145 1
      if (myStochModeMgr_->myStBSMgr ()->stageIndex (theBoundSet) == 0)
d429 1
a429 1
// ScenInputAtt <Owner>::writeData (Component *, Scenario *, bool &)
d437 1
d447 1
a447 1
   if (stageIndex (theOwner) == 0)
d471 1
@


1.31
log
@Stochastic Implosion
@
text
@d132 2
a133 1
         theInputAtt->writeData (theComp, theScenario, attWritten);
d147 2
a148 1
         theInputAtt->writeData (theBoundSet, theScenario, attWritten);
d424 4
d461 11
d483 1
d514 19
d557 2
d587 3
a589 1
   return myStochModeMgr_->myStBSMgr ()->stageIndex (theBoundSet);
@


1.30
log
@Stochastic Implosion
@
text
@d140 1
a140 1
      if (theBoundSet->myComp ()->stageIndex () == 0)
d436 1
a436 1
   if (theComp->stageIndex () == 0)
@


1.29
log
@Stochastic Implosion
@
text
@a23 1
#include <StochImpMgr.h>
d28 1
d33 1
d201 2
a202 1
   WitOperation * theOpn;
d205 1
a205 4
      {
      allMats_.     append (theMat);
      allBoundSets_.append (theMat->stockBounds ());
      }
d207 2
a208 5
   forEachDemand   (theDemand, myProblem ())
      {
      allDemands_  .append (theDemand);
      allBoundSets_.append (theDemand->cumShipBounds ());
      }
d211 1
a211 1
      allSubs_.   append (theSub);
d213 7
a219 2
   forEachOperation (theOpn, myProblem ())
      allBoundSets_.append (theOpn->execBounds ());
d348 1
a348 1
         myScenMgr_         (theScenAttMgr->myScenMgr ())
d354 1
a354 1
   forEachEl (theScenario, myScenMgr_->myScenarios ())
d357 3
a359 4
   theScenAttMgr->
      myStochModeMgr ()->
         myStochAttMgr ()->
            makeScenInputStochAtt (myAttName_, this);
d416 1
a416 1
      forEachEl (theScenario, myScenMgr_->myScenarios ())
d443 1
a443 1
      writeDataSetClause (theOwner);
d481 1
a481 1
      theBoundSet->writeStochDataSetClause ();
d531 1
a531 1
   return myStochImpMgr ()->stageIndex (thePart);
d539 2
a540 1
   return myStochImpMgr ()->stageIndex (theDemand->demandedPart ());
d548 1
a548 3
   stronglyAssert (false);

   return -1;
d553 1
a553 1
// ScenInputAtt <Owner>::writeDataSetClause (theOwner)
d557 1
a557 1
      void WitScenInputAtt <WitPart>::writeDataSetClause (WitPart * thePart)
d567 1
a567 2
      void WitScenInputAtt <WitDemand>::writeDataSetClause (
         WitDemand * theDemand)
d578 1
a578 1
      void WitScenInputAtt <WitBoundSet>::writeDataSetClause (WitBoundSet *)
d582 1
a582 1
      // writeDataSetClause is not to be called in the BoundSet case.
@


1.28
log
@Stochastic Implosion
@
text
@d24 1
d359 1
a359 1
            makeScenInputStochAtt (myAttName_);
d525 29
@


1.27
log
@Stochastic Implosion
@
text
@d33 1
a557 8
// Explicit instantiation of class ScenInputAtt <Owner>.
//------------------------------------------------------------------------------

template class WitScenInputAtt <WitPart>;
template class WitScenInputAtt <WitDemand>;
template class WitScenInputAtt <WitBoundSet>;

//------------------------------------------------------------------------------
d665 3
a667 5
   WitScenMgr *                             theScenMgr;
   Owner *                                  theOwner;
   WitRefMap <WitScenario, WitDblFlexVec> * theRefMapPtr;
   WitScenario *                            theScenario;
   WitDblFlexVec *                          theVecPtr;
d673 2
a674 3
      theRefMapPtr = new WitRefMap <WitScenario, WitDblFlexVec> (myProblem ());

      myValue_.setMapFor (theOwner, * theRefMapPtr);
d677 2
a678 5
         {
         theVecPtr = new WitDblFlexVec (myProblem (), 0.0);

         myValue_ (theOwner).setMapFor (theScenario, * theVecPtr);
         }
d696 1
a696 1
         delete & myValue_ (theOwner) (theScenario);
d698 1
a698 1
      delete & myValue_ (theOwner);
@


1.26
log
@Stochastic Implosion
@
text
@d137 1
a137 1
      if (theBoundSet->myComp ()->stageNo () == 0)
d434 1
a434 1
   if (theComp->stageNo () == 0)
@


1.25
log
@Stochastic Implosion
@
text
@a29 1
#include <StageMgr.h>
d137 3
d434 3
@


1.24
log
@Stochastic Implosion
@
text
@a152 10
void WitScenAttMgr::validateData ()
   {
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->checkValsInStage0 ();
   }

//------------------------------------------------------------------------------

a488 47

template <typename Owner>
      void WitScenInputAtt <Owner>::checkValsInStage0 ()
   {
   WitStageMgr * theStageMgr;
   Owner *       theOwner;
   WitPeriod     thePer;
   WitScenario * theScenarioA;
   WitScenario * theScenarioB;
   double        attValA;
   double        attValB;

   theStageMgr = myScenMgr_->myStochModeMgr ()->myStageMgr ();

   theScenarioA = myScenMgr_->myScenarios ().first ();

   forEachEl (theOwner, myScenAtt_->allOwners ())
      if (theStageMgr->stageNo (theOwner) == 0)
         forEachPeriod (thePer, myProblem ())
            {
            attValA = myValueFor (theOwner, theScenarioA)[thePer];

            forEachEl (theScenarioB, myScenMgr_->myScenarios ())
               if (theScenarioB != theScenarioA)
                  {
                  attValB = myValueFor (theOwner, theScenarioB)[thePer];

                  if (attValB != attValA)
                     {
                     myMsgFac () ("stage0AttMisMatchSmsg");

                     myMsgFac () ("stage0AttMisMatchAttSmsg", myAttName_);

                     issueMisMatchOwnerMsg (theOwner);
     
                     myMsgFac () ("stage0AttMisMatchValsSmsg",
                        thePer,
                        theScenarioA->myIndex (),
                        attValA,
                        theScenarioB->myIndex (),
                        attValB);
                     }
                  }
            }
   }

//------------------------------------------------------------------------------
a551 33
// Template specialized implementation of member function
// ScenInputAtt <Owner>::issueMisMatchOwnerMsg (...).
//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitPart>::issueMisMatchOwnerMsg (WitPart * thePart)
   {
   myMsgFac () ("stage0PartAttMisMatchSmsg", thePart->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitDemand>::issueMisMatchOwnerMsg (
         WitDemand * theDemand)
   {
   myMsgFac () ("stage0DemAttMisMatchSmsg",
      theDemand->demandedPartName (),
      theDemand->demandName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::issueMisMatchOwnerMsg (
         WitBoundSet * theBoundSet)
   {
   myMsgFac () ("stage0BoundSetAttMisMatchSmsg", theBoundSet->myAttName ());

   theBoundSet->issueStage0MisMatchMsg ();
   }

//------------------------------------------------------------------------------
@


1.23
log
@Stochastic Implosion
@
text
@d536 1
@


1.22
log
@Stochastic Implosion
@
text
@a27 1
#include <StageMgr.h>
d30 2
d33 1
d38 1
a38 1
#include <Schedule.h>
d49 1
d52 13
a64 12
      buildingInputAttrs_ (false),
      buildingSolnAttrs_  (false),

      supplyVol_          (NULL),
      demandVol_          (NULL),

      scrapVol_           (NULL),
      stockVol_           (NULL),
      shipVol_            (NULL),
      cumShipVol_         (NULL),
      execVol_            (NULL),
      subVol_             (NULL),
d67 2
a68 1
      allSubs_            ()
a78 3
   WitAbsScenSolnAtt *  theAbsScenSolnAtt;
   WitAbsScenInputAtt * theAbsScenInputAtt;

d88 1
a88 1
void WitScenAttMgr::store (WitAbsScenInputAtt * theAbsScenInputAtt)
d90 1
a90 1
   stronglyAssert (buildingInputAttrs_);
d92 2
a93 1
   myAbsScenInputAtts_.append (theAbsScenInputAtt);
d98 1
a98 1
void WitScenAttMgr::store (WitAbsScenSolnAtt * theAbsScenSolnAtt)
d100 1
a100 1
   stronglyAssert (buildingSolnAttrs_);
d102 2
a103 1
   myAbsScenSolnAtts_.append (theAbsScenSolnAtt);
d108 1
a108 1
void WitScenAttMgr::downloadInputToCurScen ()
d110 1
a110 1
   WitAbsScenInputAtt * theAbsScenInputAtt;
d112 2
a113 2
   forEachEl (theAbsScenInputAtt, myAbsScenInputAtts_)
      theAbsScenInputAtt->downloadDataToCurScen ();
d118 1
a118 1
void WitScenAttMgr::uploadInputFromCurScen ()
d120 11
a130 1
   WitAbsScenInputAtt * theAbsScenInputAtt;
d132 17
a148 2
   forEachEl (theAbsScenInputAtt, myAbsScenInputAtts_)
      theAbsScenInputAtt->uploadDataFromCurScen ();
d153 1
a153 1
void WitScenAttMgr::copyInputAttrsFrom (WitScenAttMgr * theScenAttMgr)
d155 1
a155 1
   WitAbsScenInputAtt * theAbsScenInputAtt;
d157 2
a158 2
   forEachEl (theAbsScenInputAtt, myAbsScenInputAtts_)
      theAbsScenInputAtt->copyContentsFrom (theScenAttMgr);
d163 1
a163 1
void WitScenAttMgr::checkInputInStage0 ()
d165 1
a165 1
   WitAbsScenInputAtt * theAbsScenInputAtt;
d167 2
a168 2
   forEachEl (theAbsScenInputAtt, myAbsScenInputAtts_)
      theAbsScenInputAtt->checkValsInStage0 ();
d173 11
a183 1
void WitScenAttMgr::uploadSolnFromCurScen ()
d185 1
a185 1
   WitAbsScenSolnAtt * theAbsScenSolnAtt;
d187 1
a187 2
   forEachEl (theAbsScenSolnAtt, myAbsScenSolnAtts_)
      theAbsScenSolnAtt->uploadDataFromCurScen ();
d192 1
a192 1
void WitScenAttMgr::clearSoln ()
d194 1
a194 1
   WitAbsScenSolnAtt * theAbsScenSolnAtt;
d196 1
a196 2
   forEachEl (theAbsScenSolnAtt, myAbsScenSolnAtts_)
      theAbsScenSolnAtt->clearData ();
d203 4
a206 3
   WitMaterial * theMat;
   WitDemand *   theDemand;
   WitSubEntry * theSub;
d209 4
a212 1
      allMats_.   append (theMat);
d215 4
a218 1
      allDemands_.append (theDemand);
d222 3
d231 1
a231 1
   buildingInputAttrs_ = true;
d234 7
a240 5
      new WitScenInputAtt   <WitPart> (this,
                                      "supplyVol",
                           & WitPart:: supplyVol,
                           & WitPart:: storeStochSupplyVol,
                     & WitScenAttMgr:: supplyVol);
d242 30
a271 5
      new WitScenInputAtt <WitDemand> (this,
                                      "demandVol",
                         & WitDemand:: demandVol,
                         & WitDemand:: storeStochDemandVol,
                     & WitScenAttMgr:: demandVol);
d273 1
a273 1
   buildingInputAttrs_ = false;
d280 1
a280 1
   buildingSolnAttrs_ = true;
d284 1
d289 1
d294 1
d299 1
d304 1
d309 1
d312 1
a312 1
   buildingInputAttrs_ = false;
d338 7
a344 6
            WitScenAttMgr *                    theScenAttMgr,
            const char *                       theAttName,
            const WitDblFlexVec & (Owner::*    theAccFunc) () const,
            void (Owner::*                     theStoreFunc) (
                                                  const WitTVec <double> &),
            WitScenInputAtt * (WitScenAttMgr::* theInstFunc) () const):
a347 1
         myStochModeMgr_    (theScenAttMgr->myStochModeMgr ()),
d349 1
d352 2
a353 1
         myInstFunc_        (theInstFunc)
d359 10
a368 1
   myScenAtt_->allocate ();
d370 6
a375 2
   forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
      myScenAtt_->downloadDataTo (theScenario, myAccFunc_);
d389 1
a389 1
      void WitScenInputAtt <Owner>::downloadDataToCurScen ()
d391 5
a395 4
   myScenAtt_->
      downloadDataTo (
         myStochModeMgr_->myScenMgr ()->curScenario (),
         myAccFunc_);
d401 1
a401 1
      void WitScenInputAtt <Owner>::uploadDataFromCurScen ()
d403 4
a406 4
   myScenAtt_->
      uploadDataFrom (
         myStochModeMgr_->myScenMgr ()->curScenario (),
         myStoreFunc_);
d412 2
a413 2
      void WitScenInputAtt <Owner>::copyContentsFrom (
         WitScenAttMgr * theScenAttMgr)
d415 3
a417 1
   WitScenInputAtt <Owner> * theScenInputAtt;
d419 1
a419 1
   theScenInputAtt = (theScenAttMgr->*myInstFunc_) ();
d421 4
a424 1
   myScenAtt_->copyContentsFrom (theScenInputAtt->myScenAtt_);
d430 4
a433 1
      void WitScenInputAtt <Owner>::checkValsInStage0 ()
d435 20
a454 1
   myScenAtt_->checkValsInStage0 (myAttName_);
d458 4
d464 4
a467 3
      const WitTVec <double> & WitScenInputAtt <Owner>::myValue (
            Owner *       theOwner,
            WitScenario * theScenario)
a468 1
   return myScenAtt_->myValue (theOwner, theScenario);
d472 26
a497 1
// Explicit instantiation of class ScenInputAtt <Owner>.
d500 43
a542 2
template class WitScenInputAtt <WitPart>;
template class WitScenInputAtt <WitDemand>;
d545 2
a546 1
// Implementation of class AbsScenSolnAtt.
d549 2
a550 1
WitAbsScenSolnAtt::~WitAbsScenSolnAtt ()
d552 1
d557 8
a564 1
WitAbsScenSolnAtt::WitAbsScenSolnAtt (WitScenAttMgr * theScenAttMgr):
d566 2
a567 1
      WitProbAssoc (theScenAttMgr)
d569 1
a569 1
   theScenAttMgr->store (this);
d573 2
a574 1
// Implementation of class ScenSolnAtt <Owner>.
d577 2
a578 9
template <typename Owner>
      WitScenSolnAtt <Owner>::WitScenSolnAtt (
            WitScenAttMgr * theScenAttMgr,
            void (Owner::*  theStoreFunc) (const WitTVec <double> &)):

         WitAbsScenSolnAtt (theScenAttMgr),
         myScenAtt_        (NULL),
         myStochModeMgr_   (theScenAttMgr->myStochModeMgr ()),
         myStoreFunc_      (theStoreFunc)
d580 3
a582 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr);
d587 3
a589 2
template <typename Owner>
      WitScenSolnAtt <Owner>::~WitScenSolnAtt ()
d591 4
a594 1
   delete myScenAtt_;
d598 3
a600 3
  
template <typename Owner>
      void WitScenSolnAtt <Owner>::uploadDataFromCurScen ()
d602 3
a604 3
   myScenAtt_->uploadDataFrom (
      myStochModeMgr_->myScenMgr ()->curScenario (),
      myStoreFunc_);
d608 6
a613 3
  
template <typename Owner>
      void WitScenSolnAtt <Owner>::clearData ()
d615 1
a615 1
   myScenAtt_->clear ();
d620 3
a622 6
template <typename Owner>
      void WitScenSolnAtt <Owner>::storeValue (
         Owner *                       theOwner,
         const WitList <WitScenario> & theScenarios,
         WitPeriod                     thePer,
         double                        theValue)
d624 4
a627 1
   WitScenario * theScenario;
d629 1
a629 1
   witAssert (myStochModeMgr_->myStochOptMgr ()->uploadingSoln ());
d631 5
a635 2
   if (theValue <= 0.0)
      return;
d637 1
a637 2
   forEachEl (theScenario, theScenarios)
      myScenAtt_->storeValue (theOwner, theScenario, thePer, theValue);
d641 1
a641 1
// Explicit instantiation of class ScenSolnAtt <Owner>.
d644 3
a646 5
template class WitScenSolnAtt <WitPart>;
template class WitScenSolnAtt <WitMaterial>;
template class WitScenSolnAtt <WitDemand>;
template class WitScenSolnAtt <WitOperation>;
template class WitScenSolnAtt <WitSubEntry>;
d649 1
a649 1
// Implementation of class ScenAtt <Owner>.
d652 3
a654 2
template <typename Owner>
      WitScenAtt <Owner>::WitScenAtt (WitScenAttMgr * theScenAttMgr):
d656 1
a656 5
         WitProbAssoc  (theScenAttMgr),
         myScenAttMgr_ (theScenAttMgr),
         myValue_      (myProblem ())
   {
   Owner * theOwner;
d658 1
a658 3
   forEachEl (theOwner, allOwners ())
      {
      myValue_.setMapFor (theOwner, * new WitSchedule <WitScenario, double>);
d660 3
a662 2
      myValue_ (theOwner).allocate1D (myProblem ());
      }
d666 2
d670 9
a678 1
      WitScenAtt <Owner>::~WitScenAtt ()
d680 1
a680 1
   Owner * theOwner;
d682 1
a682 2
   forEachEl (theOwner, allOwners ())
      delete & (myValue_ (theOwner));
d688 5
a692 1
      void WitScenAtt <Owner>::allocate ()
d694 4
a697 1
   Owner * theOwner;
d699 1
a699 2
   forEachEl (theOwner, allOwners ())
      myValue_ (theOwner).allocate (myProblem (), 0.0);
d705 1
a705 1
      void WitScenAtt <Owner>::clear ()
d707 1
a707 4
   Owner * theOwner;

   forEachEl (theOwner, allOwners ())
      myValue_ (theOwner).allocate1D (myProblem ());
d713 1
a713 3
      void WitScenAtt <Owner>::downloadDataTo (
         WitScenario *                   theScenario,
         const WitDblFlexVec & (Owner::* theAccFunc) () const)
d717 3
a719 2
   forEachEl (theOwner, allOwners ())
      myValue_ (theOwner) (theScenario) = (theOwner->*theAccFunc) ();
d723 1
a723 1

d725 1
a725 3
      void WitScenAtt <Owner>::uploadDataFrom (
         WitScenario *  theScenario,
         void (Owner::* theStoreFunc) (const WitTVec <double> &))
d727 2
a728 1
   Owner * theOwner;
d730 3
a732 2
   forEachEl (theOwner, allOwners ())
      (theOwner->*theStoreFunc) (myValue_ (theOwner) (theScenario));
d736 2
d739 5
a743 8
template <typename Owner>
      void WitScenAtt <Owner>::copyContentsFrom (WitScenAtt * theScenAtt)
   {
   Owner * theOwner;
   
   forEachEl (theOwner, allOwners ())
      myValue_ (theOwner) = theScenAtt->myValue_ (theOwner);
   }
d746 2
d750 5
a754 1
      void WitScenAtt <Owner>::checkValsInStage0 (const char * theAttName)
d756 5
a760 8
   WitScenMgr *  theScenMgr;
   WitScenario * theScenarioA;
   Owner *       theOwner;
   int           stageNoVal;
   WitScenario * theScenarioB;
   WitPeriod     thePer;
   double        theScenAval;
   double        theScenBval;
d762 1
a762 3
   theScenMgr   = myScenAttMgr_->myStochModeMgr ()->myScenMgr  ();

   theScenarioA = theScenMgr->myScenarios ().first ();
d766 1
a766 2
      stageNoVal = 
         myScenAttMgr_->myStochModeMgr ()->myStageMgr ()->stageNo (theOwner);
d768 1
a768 2
      if (stageNoVal > 0)
         continue;
d770 1
a770 1
      forEachEl (theScenarioB, theScenMgr->myScenarios ())
d772 1
a772 7
         if (theScenarioB == theScenarioA)
            continue;

         forEachPeriod (thePer, myProblem ())
            {
            theScenAval = myValue_ (theOwner) (theScenarioA)[thePer];
            theScenBval = myValue_ (theOwner) (theScenarioB)[thePer];
d774 1
a774 16
            if (theScenAval != theScenBval)
               {
               myMsgFac () ("stage0AttMisMatchSmsg");

               myMsgFac () ("stage0AttMisMatchAttSmsg", theAttName);

               issueMisMatchOwnerMsg (theOwner);

               myMsgFac () ("stage0AttMisMatchValsSmsg",
                  thePer,
                  theScenarioA->myIndex (),
                  theScenAval,
                  theScenarioB->myIndex (),
                  theScenBval);
               }
            }
d782 1
a782 5
      void WitScenAtt <Owner>::storeValue (
            Owner *       theOwner,
            WitScenario * theScenario,
            WitPeriod     thePer,
            double        theValue)
d784 10
a793 2
   if (not myValue_ (theOwner) (theScenario).isAllocated ())
           myValue_ (theOwner) (theScenario).allocate (myProblem (), 0.0);
d795 2
a796 1
   myValue_ (theOwner) (theScenario)[thePer] = theValue;
a842 3
// Template specialized implementation of member function
// WitScenAtt <Owner>::issueMisMatchOwnerMsg (...).
//------------------------------------------------------------------------------
d844 2
a845 2
template <>
      void WitScenAtt <WitPart>::issueMisMatchOwnerMsg (WitPart * thePart)
d847 1
a847 11
   myMsgFac () ("stage0PartAttMisMatchSmsg", thePart->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenAtt <WitDemand>::issueMisMatchOwnerMsg (WitDemand * theDemand)
   {
   myMsgFac () ("stage0DemAttMisMatchSmsg",
      theDemand->demandedPartName (),
      theDemand->demandName ());
@


1.21
log
@Stochastic Implosion
@
text
@@


1.20
log
@Stochastic Implosion
@
text
@d134 1
a134 1
void WitScenAttMgr::checkInputAttrsInStage0 ()
d538 1
a540 1
   WitScenario * theScenarioA;
@


1.19
log
@Stochastic Implosion
@
text
@d28 1
d37 1
d134 10
d188 1
d194 1
d259 1
d268 1
d329 8
d535 56
d645 21
@


1.18
log
@Stochastic Implosion
@
text
@d424 3
a426 3
         WitProbAssoc (theScenAttMgr),
         myValue_     (myProblem ()),
         allOwners_   (allOwnersFor (theScenAttMgr))
d430 1
a430 1
   forEachEl (theOwner, allOwners_)
d445 1
a445 1
   forEachEl (theOwner, allOwners_)
d456 1
a456 1
   forEachEl (theOwner, allOwners_)
d467 1
a467 1
   forEachEl (theOwner, allOwners_)
d480 1
a480 1
   forEachEl (theOwner, allOwners_)
d493 1
a493 1
   forEachEl (theOwner, allOwners_)
d504 1
a504 1
   forEachEl (theOwner, allOwners_)
d525 1
a525 1
// ScenAtt <Owner>::allOwnersFor (...).
d528 2
a529 3
template <>
const WitList <WitPart> & WitScenAtt <WitPart>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
d531 1
a531 1
   return theScenAttMgr->myCompMgr ()->allParts ();
d537 1
a537 2
const WitList <WitMaterial> & WitScenAtt <WitMaterial>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
d539 1
a539 1
   return theScenAttMgr->allMats ();
d545 1
a545 2
const WitList <WitDemand> & WitScenAtt <WitDemand>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
d547 1
a547 1
   return theScenAttMgr->allDemands ();
d553 1
a553 2
const WitList <WitOperation> & WitScenAtt <WitOperation>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
d555 1
a555 1
   return theScenAttMgr->myCompMgr ()->allOperations ();
d561 1
a561 2
const WitList <WitSubEntry> & WitScenAtt <WitSubEntry>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
d563 1
a563 1
   return theScenAttMgr->allSubs ();
@


1.17
log
@Stochastic Implosion
@
text
@d244 5
a248 4
            WitScenAttMgr * theScenAttMgr,
            AccFunc         theAccFunc,
            StoreFunc       theStoreFunc,
            InstFunc        theInstFunc):
d259 1
a259 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr, theStoreFunc);
d351 1
a351 1
            StoreFunc       theStoreFunc):
d358 1
a358 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr, theStoreFunc);
d422 1
a422 3
      WitScenAtt <Owner>::WitScenAtt (
            WitScenAttMgr * theScenAttMgr,
            StoreFunc       theStoreFunc):
d426 1
a426 2
         allOwners_   (allOwnersFor (theScenAttMgr)),
         myStoreFunc_ (theStoreFunc)
d475 2
a476 2
         WitScenario * theScenario,
         AccFunc       theAccFunc)
d488 2
a489 2
         WitScenario * theScenario,
         StoreFunc     theStoreFunc)
d500 1
a500 2
      void WitScenAtt <Owner>::copyContentsFrom (
         WitScenAtt <Owner> * theScenAtt)
@


1.16
log
@Stochastic Implosion
@
text
@d20 1
a20 1
//    ScenAttTable <Owner>
d26 1
a26 1
#include <ScenAttTable.h>
d250 1
a250 1
         myTable_           (NULL),
d258 1
a258 1
   myTable_ = new WitScenAttTable <Owner> (theScenAttMgr, theStoreFunc);
d260 1
a260 1
   myTable_->allocate ();
d263 1
a263 1
      myTable_->downloadDataTo (theScenario, myAccFunc_);
d271 1
a271 1
   delete myTable_;
d279 1
a279 1
   myTable_->
d290 1
a290 1
   myTable_->
d306 1
a306 1
   myTable_->copyContentsFrom (theScenInputAtt->myTable_);
d316 1
a316 1
   return myTable_->myValue (theOwner, theScenario);
d353 1
a353 1
         myTable_          (NULL),
d357 1
a357 1
   myTable_ = new WitScenAttTable <Owner> (theScenAttMgr, theStoreFunc);
d365 1
a365 1
   delete myTable_;
d373 1
a373 1
   myTable_->uploadDataFrom (
d383 1
a383 1
   myTable_->clear ();
d403 1
a403 1
      myTable_->storeValue (theOwner, theScenario, thePer, theValue);
d417 1
a417 1
// Implementation of class ScenAttTable <Owner>.
d421 1
a421 1
      WitScenAttTable <Owner>::WitScenAttTable (
d443 1
a443 1
      WitScenAttTable <Owner>::~WitScenAttTable ()
d454 1
a454 1
      void WitScenAttTable <Owner>::allocate ()
d465 1
a465 1
      void WitScenAttTable <Owner>::clear ()
d476 1
a476 1
      void WitScenAttTable <Owner>::downloadDataTo (
d489 1
a489 1
      void WitScenAttTable <Owner>::uploadDataFrom (
d502 2
a503 2
      void WitScenAttTable <Owner>::copyContentsFrom (
         WitScenAttTable <Owner> * theScenAttTable)
d508 1
a508 1
      myValue_ (theOwner) = theScenAttTable->myValue_ (theOwner);
d514 1
a514 1
      void WitScenAttTable <Owner>::storeValue (
d528 1
a528 1
// ScenAttTable <Owner>::allOwnersFor (...).
d532 1
a532 1
const WitList <WitPart> & WitScenAttTable <WitPart>::allOwnersFor (
d541 1
a541 1
const WitList <WitMaterial> & WitScenAttTable <WitMaterial>::allOwnersFor (
d550 1
a550 1
const WitList <WitDemand> & WitScenAttTable <WitDemand>::allOwnersFor (
d559 1
a559 1
const WitList <WitOperation> & WitScenAttTable <WitOperation>::allOwnersFor (
d568 1
a568 1
const WitList <WitSubEntry> & WitScenAttTable <WitSubEntry>::allOwnersFor (
@


1.15
log
@Stochastic Implosion
@
text
@d233 1
a233 2
      WitProbAssoc    (theScenAttMgr),
      myStochModeMgr_ (theScenAttMgr->myStochModeMgr ())
d251 1
d253 1
a255 1
   Owner *       theOwner;
d260 1
a260 3
   forEachEl (theOwner, myTable_->allOwners ())
      forEachEl (theScenario, myStochModeMgr ()->myScenMgr ()->myScenarios ())
         myTable_->myValue (theOwner, theScenario).allocate (myProblem (), 0.0);
d262 2
a263 2
   forEachEl (theScenario, myStochModeMgr ()->myScenMgr ()->myScenarios ())
      downloadDataTo (theScenario);
d279 4
a282 5
   WitScenario * theScenario;

   theScenario = myStochModeMgr ()->myScenMgr ()->curScenario ();

   downloadDataTo (theScenario);
d290 4
a293 1
   myTable_->uploadDataFromCurScen ();
d302 1
a302 3
   WitScenInputAtt <Owner> * theAtt;
   Owner *                   theOwner;
   WitScenario *             theScenario;
d304 1
a304 1
   theAtt = (theScenAttMgr->*myInstFunc_) ();
d306 1
a306 4
   forEachEl (theOwner, myTable_->allOwners ())
      forEachEl (theScenario, myStochModeMgr ()->myScenMgr ()->myScenarios ())
         myTable_           ->myValue (theOwner, theScenario) =
            theAtt->myTable_->myValue (theOwner, theScenario);
a319 12

template <typename Owner>
      void WitScenInputAtt <Owner>::downloadDataTo (WitScenario * theScenario)
   {
   Owner * theOwner;

   forEachEl (theOwner, myTable_->allOwners ())
      myTable_->myValue (theOwner, theScenario) =
         (theOwner->*myAccFunc_) ();
   }

//------------------------------------------------------------------------------
d338 1
a338 2
      WitProbAssoc    (theScenAttMgr),
      myStochModeMgr_ (theScenAttMgr->myStochModeMgr ())
d353 3
a355 1
         myTable_          (NULL)
d373 3
a375 1
   myTable_->uploadDataFromCurScen ();
d383 1
a383 6
   Owner *       theOwner;
   WitScenario * theScenario;

   forEachEl (theOwner, myTable_->allOwners ())
      forEachEl (theScenario, myStochModeMgr ()->myScenMgr ()->myScenarios ())
         myTable_->myValue (theOwner, theScenario).clear ();
d390 1
a391 1
         Owner *                       theOwner,
d397 1
a397 1
   witAssert (myStochModeMgr ()->myStochOptMgr ()->uploadingSoln ());
d403 1
a403 6
      {
      if (not myTable_->myValue (theOwner, theScenario).isAllocated ())
         myTable_->myValue (theOwner, theScenario).allocate (myProblem (), 0.0);

      myTable_->myValue (theOwner, theScenario)[thePer] = theValue;
      }
d425 4
a428 5
         WitProbAssoc    (theScenAttMgr),
         myStochModeMgr_ (theScenAttMgr->myStochModeMgr ()),
         myValue_        (myProblem ()),
         allOwners_      (allOwnersFor (theScenAttMgr)),
         myStoreFunc_    (theStoreFunc)
d454 38
a491 1
      void WitScenAttTable <Owner>::uploadDataFromCurScen ()
d493 5
a497 2
   WitScenario * theScenario;
   Owner *       theOwner;
d499 1
a499 1
   theScenario = myStochModeMgr_->myScenMgr ()->curScenario ();
d501 6
d508 16
a523 1
      (theOwner->*myStoreFunc_) (myValue_ (theOwner) (theScenario));
@


1.14
log
@Stochastic Implosion
@
text
@d16 5
a20 5
//    ScenInputAtt
//    ConcScenInputAtt <Owner>
//    ScenSolnAtt
//    ConcScenSolnAtt  <Owner>
//    ScenAttTable     <Owner>
d45 2
a46 2
      myScenInputAtts_    (),
      myScenSolnAtts_     (),
d72 2
a73 2
   WitScenSolnAtt *  theScenSolnAtt;
   WitScenInputAtt * theScenInputAtt;
d75 2
a76 2
   while (not myScenSolnAtts_.isEmpty ())
      delete myScenSolnAtts_.get ();
d78 2
a79 2
   while (not myScenInputAtts_.isEmpty ())
      delete myScenInputAtts_.get ();
d84 1
a84 1
void WitScenAttMgr::store (WitScenInputAtt * theScenInputAtt)
d88 1
a88 1
   myScenInputAtts_.append (theScenInputAtt);
d93 1
a93 1
void WitScenAttMgr::store (WitScenSolnAtt * theScenSolnAtt)
d97 1
a97 1
   myScenSolnAtts_.append (theScenSolnAtt);
d104 1
a104 1
   WitScenInputAtt * theScenInputAtt;
d106 2
a107 2
   forEachEl (theScenInputAtt, myScenInputAtts_)
      theScenInputAtt->downloadDataToCurScen ();
d114 1
a114 1
   WitScenInputAtt * theScenInputAtt;
d116 2
a117 2
   forEachEl (theScenInputAtt, myScenInputAtts_)
      theScenInputAtt->uploadDataFromCurScen ();
d124 1
a124 1
   WitScenInputAtt * theScenInputAtt;
d126 2
a127 2
   forEachEl (theScenInputAtt, myScenInputAtts_)
      theScenInputAtt->copyContentsFrom (theScenAttMgr);
d134 1
a134 1
   WitScenSolnAtt * theScenSolnAtt;
d136 2
a137 2
   forEachEl (theScenSolnAtt, myScenSolnAtts_)
      theScenSolnAtt->uploadDataFromCurScen ();
d144 1
a144 1
   WitScenSolnAtt * theScenSolnAtt;
d146 2
a147 2
   forEachEl (theScenSolnAtt, myScenSolnAtts_)
      theScenSolnAtt->clearData ();
d175 4
a178 4
      new WitConcScenInputAtt   <WitPart> (this,
                               & WitPart:: supplyVol,
                               & WitPart:: storeStochSupplyVol,
                         & WitScenAttMgr:: supplyVol);
d180 4
a183 4
      new WitConcScenInputAtt <WitDemand> (this,
                             & WitDemand:: demandVol,
                             & WitDemand:: storeStochDemandVol,
                         & WitScenAttMgr:: demandVol);
d195 2
a196 2
      new WitConcScenSolnAtt <WitPart>      (this,
                            & WitPart::      storeStochScrapVol);
d199 2
a200 2
      new WitConcScenSolnAtt <WitMaterial>  (this,
                            & WitMaterial::  storeStochStockVol);
d203 2
a204 2
      new WitConcScenSolnAtt <WitDemand>    (this,
                            & WitDemand::    storeStochShipVol);
d207 2
a208 2
      new WitConcScenSolnAtt <WitDemand>    (this,
                            & WitDemand::    storeStochCumShipVol);
d211 2
a212 2
      new WitConcScenSolnAtt <WitOperation> (this,
                            & WitOperation:: storeStochExecVol);
d215 2
a216 2
      new WitConcScenSolnAtt <WitSubEntry>  (this,
                            & WitSubEntry::  storeStochSubVol);
d222 1
a222 1
// Implementation of class ScenInputAtt.
d225 1
a225 1
WitScenInputAtt::~WitScenInputAtt ()
d231 1
a231 1
WitScenInputAtt::WitScenInputAtt (WitScenAttMgr * theScenAttMgr):
d240 1
a240 1
// Implementation of class ConcScenInputAtt <Owner>.
d244 1
a244 1
      WitConcScenInputAtt <Owner>::WitConcScenInputAtt (
d250 4
a253 4
         WitScenInputAtt (theScenAttMgr),
         myTable_        (NULL),
         myAccFunc_      (theAccFunc),
         myInstFunc_     (theInstFunc)
d271 1
a271 1
      WitConcScenInputAtt <Owner>::~WitConcScenInputAtt ()
d279 1
a279 1
      void WitConcScenInputAtt <Owner>::downloadDataToCurScen ()
d291 1
a291 1
      void WitConcScenInputAtt <Owner>::uploadDataFromCurScen ()
d299 1
a299 1
      void WitConcScenInputAtt <Owner>::copyContentsFrom (
d302 3
a304 3
   WitConcScenInputAtt <Owner> * theAtt;
   Owner *                       theOwner;
   WitScenario *                 theScenario;
d317 1
a317 1
      const WitTVec <double> & WitConcScenInputAtt <Owner>::myValue (
d327 1
a327 2
      void WitConcScenInputAtt <Owner>::downloadDataTo (
         WitScenario * theScenario)
d337 1
a337 1
// Explicit instantiation of class ConcScenInputAtt <Owner>.
d340 2
a341 2
template class WitConcScenInputAtt <WitPart>;
template class WitConcScenInputAtt <WitDemand>;
d344 1
a344 1
// Implementation of class ScenSolnAtt.
d347 1
a347 1
WitScenSolnAtt::~WitScenSolnAtt ()
d353 1
a353 1
WitScenSolnAtt::WitScenSolnAtt (WitScenAttMgr * theScenAttMgr):
d362 1
a362 1
// Implementation of class ConcScenSolnAtt <Owner>.
d366 1
a366 1
      WitConcScenSolnAtt <Owner>::WitConcScenSolnAtt (
d370 2
a371 2
         WitScenSolnAtt (theScenAttMgr),
         myTable_       (NULL)
d379 1
a379 1
      WitConcScenSolnAtt <Owner>::~WitConcScenSolnAtt ()
d387 1
a387 1
      void WitConcScenSolnAtt <Owner>::uploadDataFromCurScen ()
d395 1
a395 1
      void WitConcScenSolnAtt <Owner>::clearData ()
d408 1
a408 1
      void WitConcScenSolnAtt <Owner>::storeValue (
d431 1
a431 1
// Explicit instantiation of class ConcScenSolnAtt <Owner>.
d434 5
a438 5
template class WitConcScenSolnAtt <WitPart>;
template class WitConcScenSolnAtt <WitMaterial>;
template class WitConcScenSolnAtt <WitDemand>;
template class WitConcScenSolnAtt <WitOperation>;
template class WitConcScenSolnAtt <WitSubEntry>;
@


1.13
log
@Stochastic Implosion.
@
text
@d317 10
@


1.12
log
@Stochastic Implosion
@
text
@d122 10
d175 4
a178 3
      new WitConcScenInputAtt <WitPart>   (this,
                             & WitPart::   supplyVol,
                             & WitPart::   storeStochSupplyVol);
d182 2
a183 1
                             & WitDemand:: storeStochDemandVol);
d247 2
a248 1
            StoreFunc       theStoreFunc):
d252 2
a253 1
         myAccFunc_      (theAccFunc)
d299 18
@


1.11
log
@Stochastic Implosion
@
text
@d132 1
a132 1
void WitScenAttMgr::uploadZeroSoln ()
d137 1
a137 11
      theScenSolnAtt->uploadZero ();
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::clearScenSoln ()
   {
   WitScenSolnAtt * theScenSolnAtt;

   forEachEl (theScenSolnAtt, myScenSolnAtts_)
      theScenSolnAtt->clearScenData ();
d221 2
a222 1
      WitProbAssoc (theScenAttMgr)
d241 1
a241 1
   WitScenMgr *  theScenMgr;
d244 1
a244 1
   myTable_   = new WitScenAttTable <Owner> (theScenAttMgr, theStoreFunc);
d246 3
a248 1
   theScenMgr = theScenAttMgr->myStochModeMgr ()->myScenMgr ();
d250 1
a250 1
   forEachEl (theScenario, theScenMgr->myScenarios ())
d269 1
a269 1
   theScenario = myTable_->myStochModeMgr ()->myScenMgr ()->curScenario ();
d330 1
a330 2
         myTable_       (NULL),
         myStoreFunc_   (theStoreFunc)
d354 1
a354 15
      void WitConcScenSolnAtt <Owner>::uploadZero ()
   {
   WitTVec <double> zeroVec;
   Owner *          theOwner;

   zeroVec.allocate (myProblem (), 0.0);

   forEachEl (theOwner, myTable_->allOwners ())
      (theOwner->*myStoreFunc_) (zeroVec);
   }

//------------------------------------------------------------------------------
  
template <typename Owner>
      void WitConcScenSolnAtt <Owner>::clearScenData ()
d361 1
a361 1
         myTable_->myValue (theOwner, theScenario) = 0.0;
d377 3
d381 6
a386 1
      myTable_->myValue (theOwner, theScenario)[thePer] = max (0.0, theValue);
d420 1
a420 1
      myValue_ (theOwner).allocate (myProblem (), 0.0);
@


1.10
log
@Stochastic Implosion
@
text
@d132 10
d337 2
a338 1
         myTable_       (NULL)
d362 14
@


1.9
log
@Stochastic Implosion
@
text
@d132 10
d311 2
a312 1
      WitProbAssoc (theScenAttMgr)
d349 13
d372 1
a372 1
   witAssert (myTable_->myStochModeMgr ()->myStochOptMgr ()->uploadingSoln ());
@


1.8
log
@Stochastic Implosion
@
text
@d30 1
d341 4
a344 4
         Owner *       theOwner,
         WitScenario * theScenario,
         WitPeriod     thePer,
         double        theValue)
d346 7
a352 2
   stronglyAssert (false);
   }  
@


1.7
log
@Stochastic Implosion
@
text
@d409 1
a409 1
// Non-parametric implemenation of member function
d413 1
d422 1
d431 1
d440 1
d449 1
@


1.6
log
@Stochastic Implosion
@
text
@d27 1
d40 1
a40 1
WitScenAttMgr::WitScenAttMgr (WitScenMgr * theScenMgr):
d42 2
a43 2
      WitProbAssoc        (theScenMgr),
      myScenMgr_          (theScenMgr),
d229 1
d232 3
a234 1
   myTable_ = new WitScenAttTable <Owner> (theScenAttMgr, theStoreFunc);
d236 1
a236 1
   forEachEl (theScenario, myTable_->myScenMgr ()->myScenarios ())
d253 5
a257 1
   downloadDataTo (myTable_->myScenMgr ()->curScenario ());
d337 12
d367 5
a371 5
         WitProbAssoc (theScenAttMgr),
         myScenMgr_   (theScenAttMgr->myScenMgr ()),
         myValue_     (myProblem ()),
         allOwners_   (allOwnersFor (theScenAttMgr)),
         myStoreFunc_ (theStoreFunc)
d402 1
a402 1
   theScenario = myScenMgr_->curScenario ();
@


1.5
log
@Stochastic Implosion
@
text
@d41 23
a63 23
      WitProbAssoc     (theScenMgr),
      myScenMgr_       (theScenMgr),
      myScenInputAtts_ (),
      myScenSolnAtts_  (),

      supplyVol_       (NULL),
      demandVol_       (NULL),

      scrapVol_        (NULL),
      stockVol_        (NULL),
      shipVol_         (NULL),
      cumShipVol_      (NULL),
      execVol_         (NULL),
      subVol_          (NULL),
      allMats_         (),
      allDemands_      (),
      allSubs_         ()
   {
   listOwners             ();
   buildConcScenInputAtts ();
   buildConcScenSolnAtts  ();
   listScenInputAtts      ();
   listScenSolnAtts       ();
d82 18
d148 1
a148 1
void WitScenAttMgr::buildConcScenInputAtts ()
d150 2
d160 2
d166 1
a166 1
void WitScenAttMgr::buildConcScenSolnAtts ()
d168 2
a192 3
   }

//------------------------------------------------------------------------------
d194 1
a194 16
void WitScenAttMgr::listScenInputAtts ()
   {
   myScenInputAtts_.append (supplyVol_);
   myScenInputAtts_.append (demandVol_);
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::listScenSolnAtts ()
   {
   myScenSolnAtts_.append (scrapVol_  );
   myScenSolnAtts_.append (stockVol_  );
   myScenSolnAtts_.append (shipVol_   );
   myScenSolnAtts_.append (cumShipVol_);
   myScenSolnAtts_.append (execVol_   );
   myScenSolnAtts_.append (subVol_    );
d207 1
a207 1
WitScenInputAtt::WitScenInputAtt (WitProblem * theProblem):
d209 1
a209 1
      WitProbAssoc (theProblem)
d211 1
d224 1
a224 1
         WitScenInputAtt (theScenAttMgr->myProblem ()),
d290 1
a290 1
WitScenSolnAtt::WitScenSolnAtt (WitProblem * theProblem):
d292 1
a292 1
      WitProbAssoc (theProblem)
d294 1
d306 1
a306 1
         WitScenSolnAtt (theScenAttMgr->myProblem ()),
@


1.4
log
@Stochastic Implosion
@
text
@d20 1
a20 1
//    ScenAtt          <Owner>
d26 1
a26 1
#include <ScenAtt.h>
d218 1
a218 1
         myScenAtt_      (NULL),
d223 1
a223 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr, theStoreFunc);
d225 1
a225 1
   forEachEl (theScenario, myScenAtt_->myScenMgr ()->myScenarios ())
d234 1
a234 1
   delete myScenAtt_;
d242 1
a242 1
   downloadDataTo (myScenAtt_->myScenMgr ()->curScenario ());
d250 1
a250 1
   myScenAtt_->uploadDataFromCurScen ();
d261 2
a262 2
   forEachEl (theOwner, myScenAtt_->allOwners ())
      myScenAtt_->myValue (theOwner, theScenario) =
d299 1
a299 1
         myScenAtt_     (NULL)
d301 1
a301 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenAttMgr, theStoreFunc);
d309 1
a309 1
   delete myScenAtt_;
d317 1
a317 1
   myScenAtt_->uploadDataFromCurScen ();
d331 1
a331 1
// Implementation of class ScenAtt <Owner>.
d335 1
a335 1
      WitScenAtt <Owner>::WitScenAtt (
d358 1
a358 1
      WitScenAtt <Owner>::~WitScenAtt ()
d369 1
a369 1
      void WitScenAtt <Owner>::uploadDataFromCurScen ()
d382 1
a382 1
// ScenAtt <Owner>::allOwnersFor (...).
d385 1
a385 1
const WitList <WitPart> & WitScenAtt <WitPart>::allOwnersFor (
d393 1
a393 1
const WitList <WitMaterial> & WitScenAtt <WitMaterial>::allOwnersFor (
d401 1
a401 1
const WitList <WitDemand> & WitScenAtt <WitDemand>::allOwnersFor (
d409 1
a409 1
const WitList <WitOperation> & WitScenAtt <WitOperation>::allOwnersFor (
d417 1
a417 1
const WitList <WitSubEntry> & WitScenAtt <WitSubEntry>::allOwnersFor (
@


1.3
log
@Stochastic Implosion
@
text
@d16 1
a16 1
//    ScenTmp
d18 1
d24 2
a25 1
#include <ConcScenAtt.h>
d41 17
a57 16
      WitProbAssoc (theScenMgr),
      myScenMgr_   (theScenMgr),
      myScenTmps_  (),

      supplyVol_   (NULL),
      demandVol_   (NULL),

      scrapVol_    (NULL),
      stockVol_    (NULL),
      shipVol_     (NULL),
      cumShipVol_  (NULL),
      execVol_     (NULL),
      subVol_      (NULL),
      allMats_     (),
      allDemands_  (),
      allSubs_     ()
d62 2
a63 1
   listScenTmps           ();
d70 2
a71 1
   WitScenTmp * theScenTmp;
d73 5
a77 2
   while (not myScenTmps_.isEmpty ())
      delete myScenTmps_.get ();
d84 1
a84 1
   WitScenTmp * theScenTmp;
d86 2
a87 2
   forEachEl (theScenTmp, myScenTmps_)
      theScenTmp->downloadInputToCurScen ();
d94 1
a94 1
   WitScenTmp * theScenTmp;
d96 2
a97 2
   forEachEl (theScenTmp, myScenTmps_)
      theScenTmp->uploadInputFromCurScen ();
d104 1
a104 1
   WitScenTmp * theScenTmp;
d106 2
a107 2
   forEachEl (theScenTmp, myScenTmps_)
      theScenTmp->uploadSolnFromCurScen ();
d173 1
a173 18
void WitScenAttMgr::listScenTmps ()
   {
   myScenTmps_.append (supplyVol_ );
   myScenTmps_.append (demandVol_ );

   myScenTmps_.append (scrapVol_  );
   myScenTmps_.append (stockVol_  );
   myScenTmps_.append (shipVol_   );
   myScenTmps_.append (cumShipVol_);
   myScenTmps_.append (execVol_   );
   myScenTmps_.append (subVol_    );
   }

//------------------------------------------------------------------------------
// Implementation of class ScenTmp.
//------------------------------------------------------------------------------

WitScenTmp::~WitScenTmp ()
d175 2
d181 1
a181 1
void WitScenTmp::downloadInputToCurScen ()
d183 6
d192 1
a192 5

void WitScenTmp::uploadInputFromCurScen ()
   {
   }

d195 1
a195 1
void WitScenTmp::uploadSolnFromCurScen ()
d201 1
a201 1
WitScenTmp::WitScenTmp (WitScenAttMgr * theScenAttMgr):
d203 1
a203 2
      WitProbAssoc (theScenAttMgr),
      myScenMgr_   (theScenAttMgr->myScenMgr ())
d217 3
a219 3
         WitScenTmp (theScenAttMgr),
         myScenAtt_ (NULL),
         myAccFunc_ (theAccFunc)
d225 2
a226 2
   forEachEl (theScenario, myScenMgr ()->myScenarios ())
      downloadInputTo (theScenario);
d240 1
a240 1
      void WitConcScenInputAtt <Owner>::downloadInputToCurScen ()
d242 1
a242 1
   downloadInputTo (myScenMgr ()->curScenario ());
d248 1
a248 1
      void WitConcScenInputAtt <Owner>::uploadInputFromCurScen ()
d256 1
a256 1
      void WitConcScenInputAtt <Owner>::downloadInputTo (
d274 16
d298 2
a299 2
         WitScenTmp (theScenAttMgr),
         myScenAtt_ (NULL)
d315 1
a315 1
      void WitConcScenSolnAtt <Owner>::uploadSolnFromCurScen ()
@


1.2
log
@Stochastic Implosion
@
text
@d16 4
a19 4
//    ScenAtt
//    ConcScenAtt  <Owner>
//    InputScenAtt <Owner>
//    SolnScenAtt  <Owner>
d24 1
d41 1
a41 1
      myScenAtts_  (),
d56 4
a59 4
   listOwners         ();
   buildInputScenAtts ();
   buildSolnScenAtts  ();
   listScenAtts       ();
d66 1
a66 1
   WitScenAtt * theScenAtt;
d68 2
a69 2
   while (not myScenAtts_.isEmpty ())
      delete myScenAtts_.get ();
d76 1
a76 1
   WitScenAtt * theScenAtt;
d78 2
a79 2
   forEachEl (theScenAtt, myScenAtts_)
      theScenAtt->downloadInputToCurScen ();
d86 1
a86 1
   WitScenAtt * theScenAtt;
d88 2
a89 2
   forEachEl (theScenAtt, myScenAtts_)
      theScenAtt->uploadInputFromCurScen ();
d96 1
a96 1
   WitScenAtt * theScenAtt;
d98 2
a99 2
   forEachEl (theScenAtt, myScenAtts_)
      theScenAtt->uploadSolnFromCurScen ();
d122 1
a122 1
void WitScenAttMgr::buildInputScenAtts ()
d125 3
a127 3
      new WitInputScenAtt <WitPart>   (             this,
                                         & WitPart::supplyVol,
                                         & WitPart::storeStochSupplyVol);
d129 3
a131 3
      new WitInputScenAtt <WitDemand> (             this,
                                       & WitDemand::demandVol,
                                       & WitDemand::storeStochDemandVol);
d136 1
a136 1
void WitScenAttMgr::buildSolnScenAtts ()
d139 2
a140 2
      new WitSolnScenAtt <WitPart>      (               this,
                                             & WitPart::storeStochScrapVol);
d143 2
a144 2
      new WitSolnScenAtt <WitMaterial>  (               this,
                                         & WitMaterial::storeStochStockVol);
d147 2
a148 2
      new WitSolnScenAtt <WitDemand>    (               this,
                                           & WitDemand::storeStochShipVol);
d151 2
a152 2
      new WitSolnScenAtt <WitDemand>    (               this,
                                           & WitDemand::storeStochCumShipVol);
d155 2
a156 2
      new WitSolnScenAtt <WitOperation> (                this,
                                         & WitOperation::storeStochExecVol);
d159 2
a160 2
      new WitSolnScenAtt <WitSubEntry>  (                this,
                                          & WitSubEntry::storeStochSubVol);
d165 1
a165 1
void WitScenAttMgr::listScenAtts ()
d167 2
a168 2
   myScenAtts_.append (supplyVol_ );
   myScenAtts_.append (demandVol_ );
d170 6
a175 6
   myScenAtts_.append (scrapVol_  );
   myScenAtts_.append (stockVol_  );
   myScenAtts_.append (shipVol_   );
   myScenAtts_.append (cumShipVol_);
   myScenAtts_.append (execVol_   );
   myScenAtts_.append (subVol_    );
d179 1
a179 1
// Implementation of class ScenAtt.
d182 1
a182 1
WitScenAtt::~WitScenAtt ()
d188 1
a188 1
void WitScenAtt::downloadInputToCurScen ()
d194 1
a194 1
void WitScenAtt::uploadInputFromCurScen ()
d200 1
a200 1
void WitScenAtt::uploadSolnFromCurScen ()
d206 1
a206 1
WitScenAtt::WitScenAtt (WitScenAttMgr * theScenAttMgr):
d214 1
a214 1
// Implementation of class ConcScenAtt <Owner>.
d218 1
a218 1
      WitConcScenAtt <Owner>::WitConcScenAtt (
d220 1
d223 3
a225 4
         WitScenAtt   (theScenAttMgr),
         myValue_     (myProblem ()),
         allOwners_   (allOwnersFor (theScenAttMgr)),
         myStoreFunc_ (theStoreFunc)
d227 1
a227 1
   Owner * theOwner;
d229 1
a229 3
   forEachEl (theOwner, allOwners_)
      {
      myValue_.setMapFor (theOwner, * new WitSchedule <WitScenario, double>);
d231 2
a232 2
      myValue_ (theOwner).allocate (myProblem (), 0.0);
      }
d238 1
a238 1
      WitConcScenAtt <Owner>::~WitConcScenAtt ()
d240 1
a240 4
   Owner * theOwner;

   forEachEl (theOwner, allOwners_)
      delete & (myValue_ (theOwner));
d246 1
a246 1
      void WitConcScenAtt <Owner>::uploadDataFromCurScen ()
d248 1
a248 7
   WitScenario * theScenario;
   Owner *       theOwner;

   theScenario = myScenMgr ()->curScenario ();

   forEachEl (theOwner, allOwners ())
      (theOwner->*myStoreFunc_) (myValue (theOwner, theScenario));
a251 3
// Non-parametric implemenation of member function
// ConcScenAtt <Owner>::allOwnersFor (...).
//------------------------------------------------------------------------------
d253 2
a254 2
const WitList <WitPart> & WitConcScenAtt <WitPart>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
d256 1
a256 1
   return theScenAttMgr->myCompMgr ()->allParts ();
d261 3
a263 2
const WitList <WitMaterial> & WitConcScenAtt <WitMaterial>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
d265 1
a265 4
   return theScenAttMgr->allMats ();
   }

//------------------------------------------------------------------------------
d267 3
a269 4
const WitList <WitDemand> & WitConcScenAtt <WitDemand>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
   {
   return theScenAttMgr->allDemands ();
d273 1
a273 7

const WitList <WitOperation> & WitConcScenAtt <WitOperation>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
   {
   return theScenAttMgr->myCompMgr ()->allOperations ();
   }

d276 2
a277 5
const WitList <WitSubEntry> & WitConcScenAtt <WitSubEntry>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
   {
   return theScenAttMgr->allSubs ();
   }
d280 1
a280 1
// Implementation of class InputScenAtt <Owner>.
d284 1
a284 1
      WitInputScenAtt <Owner>::WitInputScenAtt (
a285 1
            AccFunc         theAccFunc,
d288 2
a289 2
         WitConcScenAtt <Owner> (theScenAttMgr, theStoreFunc),
         myAccFunc_             (theAccFunc)
d291 1
a291 4
   WitScenario * theScenario;

   forEachEl (theScenario, myScenMgr ()->myScenarios ())
      downloadInputTo (theScenario);
d297 1
a297 1
      WitInputScenAtt <Owner>::~WitInputScenAtt ()
d299 1
d303 1
a303 1

d305 1
a305 1
      void WitInputScenAtt <Owner>::downloadInputToCurScen ()
d307 1
a307 1
   downloadInputTo (myScenMgr ()->curScenario ());
d311 12
d325 9
a333 1
      void WitInputScenAtt <Owner>::uploadInputFromCurScen ()
d335 8
a342 1
   uploadDataFromCurScen ();
d348 1
a348 2
      void WitInputScenAtt <Owner>::downloadInputTo (
         WitScenario * theScenario)
d352 2
a353 2
   forEachEl (theOwner, allOwners ())
      myValue (theOwner, theScenario) = (theOwner->*myAccFunc_) ();
a356 2
// Explicit instantiation of class InputScenAtt <Owner>.
//------------------------------------------------------------------------------
d358 11
a368 2
template class WitInputScenAtt <WitPart>;
template class WitInputScenAtt <WitDemand>;
d371 2
a372 1
// Implementation of class SolnScenAtt <Owner>.
d375 7
a381 4
template <typename Owner>
      WitSolnScenAtt <Owner>::WitSolnScenAtt (
            WitScenAttMgr * theScenAttMgr,
            StoreFunc       theStoreFunc):
d383 2
a384 1
         WitConcScenAtt <Owner> (theScenAttMgr, theStoreFunc)
d386 1
d391 2
a392 2
template <typename Owner>
      WitSolnScenAtt <Owner>::~WitSolnScenAtt ()
d394 1
d399 2
a400 2
template <typename Owner>
      void WitSolnScenAtt <Owner>::uploadSolnFromCurScen ()
d402 1
a402 1
   uploadDataFromCurScen ();
a405 2
// Explicit instantiation of class SolnScenAtt <Owner>.
//------------------------------------------------------------------------------
d407 5
a411 5
template class WitSolnScenAtt <WitPart>;
template class WitSolnScenAtt <WitMaterial>;
template class WitSolnScenAtt <WitDemand>;
template class WitSolnScenAtt <WitOperation>;
template class WitSolnScenAtt <WitSubEntry>;
@


1.1
log
@Stochastic Implosion
@
text
@d55 1
a55 1
   buildOwnerLists    ();
d58 1
d83 21
a103 1
void WitScenAttMgr::buildOwnerLists ()
d123 25
a147 2
   supplyVol_ = new WitInputScenAtt <WitPart>   (this, &   WitPart::supplyVol);
   demandVol_ = new WitInputScenAtt <WitDemand> (this, & WitDemand::demandVol);
d149 11
a159 2
   myScenAtts_.append (supplyVol_);
   myScenAtts_.append (demandVol_);
d164 1
a164 1
void WitScenAttMgr::buildSolnScenAtts ()
d166 6
a171 10
   scrapVol_   = new WitSolnScenAtt <WitPart>      (this);
   stockVol_   = new WitSolnScenAtt <WitMaterial>  (this);
   shipVol_    = new WitSolnScenAtt <WitDemand>    (this);
   cumShipVol_ = new WitSolnScenAtt <WitDemand>    (this);
   execVol_    = new WitSolnScenAtt <WitOperation> (this);
   subVol_     = new WitSolnScenAtt <WitSubEntry>  (this);

   myScenAtts_.append (scrapVol_);
   myScenAtts_.append (stockVol_);
   myScenAtts_.append (shipVol_);
d173 2
a174 2
   myScenAtts_.append (execVol_);
   myScenAtts_.append (subVol_);
d193 12
d217 3
a219 1
      WitConcScenAtt <Owner>::WitConcScenAtt (WitScenAttMgr * theScenAttMgr):
d221 4
a224 3
         WitScenAtt (theScenAttMgr),
         myValue_   (myProblem ()),
         allOwners_ (allOwnersFor (theScenAttMgr))
d248 14
d311 2
a312 1
            AccFunc         theAccFunc):
d314 1
a314 1
         WitConcScenAtt <Owner> (theScenAttMgr),
d341 8
d370 3
a372 1
      WitSolnScenAtt <Owner>::WitSolnScenAtt (WitScenAttMgr * theScenAttMgr):
d374 1
a374 1
         WitConcScenAtt <Owner> (theScenAttMgr)
d386 8
@


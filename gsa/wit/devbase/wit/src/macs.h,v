head	1.65;
access;
symbols
	sce_5_01_20080919:1.61
	latest_sce_4_20_20060523:1.52.0.2
	sce_4_20_20060523:1.52
	latest_sce4_20_OSL:1.51.0.2
	sce_4_20_OSL:1.51
	sce_410_withVa:1.50
	sce_4_05_20040511:1.49
	sce_4_00_20040201:1.40
	nextGenBranch:1.38.0.2
	nextGenRoot:1.38
	sce_3_30_20030627:1.36
	EndRw-branch:1.34.0.4
	Root-of-EndRw:1.34
	rwToStl:1.34.0.2
	latest_sce_3_10_20010924:1.22.0.2
	sce_3_10_20010924:1.22
	latest_sce_3_00_20010601:1.16.0.2
	sce_3_00_20010601:1.16
	latest_sce_2_31_20010308:1.13.0.2
	sce_2_31_20010308:1.13
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.65
date	2011.09.28.23.50.46;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2011.09.24.00.29.02;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2011.08.30.20.18.27;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.28.22.06.49;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.07.24.21.22.04;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.11.21.04.27;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.30.16.01.20;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.21.18.18.46;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.27.21.03.05;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.27.19.59.33;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.07.22.14.55;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.07.17.30.33;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.06.23.10.33;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.02.17.34.17;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.02.28.21.38.00;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.23.19.45.20;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.13.22.08.15;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.13.21.56.18;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.22.16.37.19;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.20.00.12.12;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.19.22.55.23;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.18.16.49.52;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.17.16.07.35;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.16.23.29.50;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.10.22.53.22;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.08.19.27.44;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.01.21.05.06;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.10.22.58.17;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.08.22.57.26;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.15.21.01.27;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.13.22.22.15;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.26.19.05.32;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.05.19.31.37;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.03.16.01.53;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.29.14.32.42;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.28.19.44.59;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.08.21.58.59;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.08.19.21.59;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.07.20.15.07;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.03.23.16.45;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.03.19.58.31;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.02.20.53.18;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.01.14.26.03;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.17.18.56.29;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.24.22.03.24;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.27.21.45.13;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.21.18.24.33;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.20.20.07.09;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.18.21.38.39;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.25.14.53.29;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.17.15.11.19;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.21.21.55.49;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.11.16.35.12;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.22.16.18.28;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.20.20.08.39;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.15.23.45.59;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.13.19.57.27;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.06.19.58.42;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.05.19.05.33;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.22.23.11.51;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.29;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.12.21.20.05;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.10.23.17.49;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.21;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.33;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.33;	author wit;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef macs_h
#define macs_h

#include <defines.h>

//------------------------------------------------------------------------------
// Header file: "macs.h"
// Macro definitions.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// ifDebug
//
// Expands to debugCode, iff WIT was complied in DEBUG mode.
//------------------------------------------------------------------------------

#ifdef DEBUG

#define ifDebug(debugCode)  debugCode

#else

#define ifDebug(debugCode)

#endif

//------------------------------------------------------------------------------
// NumberElem
// Returns number of elements in an array
//------------------------------------------------------------------------------

#define NumberElem(arr) \
   (static_cast <unsigned int> (sizeof(arr) / sizeof(arr[0])))

//------------------------------------------------------------------------------
// noCopyCtorAssign
//
// The purpose of this macro is to prevent the compiler from generating a
// copy constructor and assignment operator for classes whose instances are
// not to be copied or assigned. This macro should be invoked in the private
// section of the declaration of class TheClass. Its effect is to declare a
// copy ctor and an assignment operator for TheClass. These two functions
// should not be implemented. If copying or assignment is then done
// inadvertantly, the result will be either a syntax error or a link-time
// error. See Meyers, Item 27.
//------------------------------------------------------------------------------

#define noCopyCtorAssign(TheClass)                                             \
                                                                               \
   TheClass              (const TheClass &);                                   \
   TheClass & operator = (const TheClass &)                                    \

//------------------------------------------------------------------------------
// noCopyCtor
//
// Same as noCopyCtorAssign, but only applies to the copy ctor.
//------------------------------------------------------------------------------

#define noCopyCtor(TheClass)                                                   \
                                                                               \
   TheClass (const TheClass &)                                                 \

//------------------------------------------------------------------------------
// defaultValue
//
// Declares and implements an inline default value function for an attribute.
// This macro is designed to be used within a class declaration.
// typedFunction is *two* tokens: the type of the default value function and
// the name of the function.
// theValue is the default value.
// Thus
//
//     defaultValue (double defOffset, 0.0)
//
// declares and implements a double-valued default value function, defOffset,
// returning 0.0 as the default value.
//------------------------------------------------------------------------------

#define defaultValue(typedFunction, theValue)                                  \
                                                                               \
   inline static typedFunction ()                                              \
      {                                                                        \
      return theValue;                                                         \
      }                                                                        \

//------------------------------------------------------------------------------
// accessFunc
//
// Declares and implements an access function for an attribute. This macro is
// designed to be used within a class declaration.
// theAttr is the name of the attribute. The name data member storing the
// attribute is given by appending "_" to the attribute name. ReturnType is the
// return type of the access function. If theAttr is of type "AttrType", then
// ReturnType should normally be either "AttrType" or "const AttrType &".
//------------------------------------------------------------------------------

#define accessFunc(ReturnType, theAttr)                                        \
                                                                               \
   inline ReturnType theAttr () const                                          \
      {                                                                        \
      return theAttr ## _;                                                     \
      }                                                                        \

//------------------------------------------------------------------------------
// accessFunc2
//
// Same as accessFunc, except that the return type is given by:
//    ReturnType1, ReturnType2
// In other words, the return type contains a comma.
// For example, the return type might be:
//    const WitSchedule <WitDemand, double> &
//------------------------------------------------------------------------------

#define accessFunc2(ReturnType1, ReturnType2, theAttr)                         \
                                                                               \
   inline ReturnType1, ReturnType2 theAttr () const                            \
      {                                                                        \
      return theAttr ## _;                                                     \
      }                                                                        \

//------------------------------------------------------------------------------
// accessFuncNonConst2
//
// Same as accessFunc2, except the function is not const.
//------------------------------------------------------------------------------

#define accessFuncNonConst2(ReturnType1, ReturnType2, theAttr)                 \
                                                                               \
   inline ReturnType1, ReturnType2 theAttr ()                                  \
      {                                                                        \
      return theAttr ## _;                                                     \
      }                                                                        \

//------------------------------------------------------------------------------
// accessNonNull
//
// Same as accessFunc, except that theAttr is a pointer which is requires
// (via witAssert) to be non-NULL.
//------------------------------------------------------------------------------

#define accessNonNull(ReturnType, theAttr)                                     \
                                                                               \
   inline ReturnType theAttr () const                                          \
      {                                                                        \
      witAssert (theAttr ## _ != NULL);                                        \
                                                                               \
      return theAttr ## _;                                                     \
      }                                                                        \

//------------------------------------------------------------------------------
// Macro accessWrapper
//
// This macro is designed to be used within a class declaration.
// Declares and implements an access function for an attribute as a wrapper
// around an access function with the same name from another class.
// theFunc is the name of the function.
// ReturnType its return type.
// theObject is the object whose function is being wrapped.
//------------------------------------------------------------------------------

#define accessWrapper(ReturnType, theFunc, theObject)                          \
                                                                               \
   inline ReturnType theFunc () const                                          \
      {                                                                        \
      return theObject->theFunc ();                                            \
      }                                                                        \

//------------------------------------------------------------------------------
// Macro updateAccess
//
// Declares and implements a static member function that provides update access
// to a data member of a class.
// Arguments:
//    DataType: The type of the data member
//    theData:  The name of the data member is given by theData followed by _.
//              The name of the function is given by theData.
//    Owner:    The name of the class that owns the data member.
//
// This macro should be used within the declaration of a class that is a friend
// of class Owner.
//------------------------------------------------------------------------------

#define updateAccess(DataType, theData, Owner)                                 \
                                                                               \
   inline static DataType & theData (Owner * theOwner)                         \
      {                                                                        \
      return theOwner->theData ## _;                                           \
      }                                                                        \

//------------------------------------------------------------------------------
// Macro decMappingIndex
//
// This macro is designed to be used within the declaration of class TheClass.
//
// Declares and implements the access function for TheClass's mapping index.
//
// Also declares and implements a function which
// verifies that TheClass has its own mapping index function, rather than just 
// inheriting one: When verifyMappingIndex is invoked on a pointer to an 
// instance of TheClass, if TheClass doesn't have its own version of 
// verifyMappingIndex, a syntax error will result.
//------------------------------------------------------------------------------

#define decMappingIndex(TheClass)                                              \
                                                                               \
   inline int mappingIndex () const                                            \
      {                                                                        \
      return mappingIndex_;                                                    \
      }                                                                        \
                                                                               \
   inline static void verifyMappingIndex (TheClass * &)                        \
      {                                                                        \
      }                                                                        \

//------------------------------------------------------------------------------
// name2 (a, b)
//
// Concatinates symbols a and b.
//------------------------------------------------------------------------------

#define  name2(a,b) _name2 (a,b)
   //
   // Forces the args to be evaluated here.

#define _name2(a,b) a##b

#endif
@


1.64
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.63
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d42 1
a42 1
(static_cast <unsigned int> (sizeof(arr) / sizeof(arr[0])))
d58 3
a60 3
\
TheClass              (const TheClass &);                                   \
TheClass & operator = (const TheClass &)                                    \
d69 2
a70 2
\
TheClass (const TheClass &)                                                 \
d89 5
a93 5
\
inline static typedFunction ()                                              \
{                                                                        \
return theValue;                                                         \
}                                                                        \
d107 5
a111 5
\
inline ReturnType theAttr () const                                          \
{                                                                        \
return theAttr ## _;                                                     \
}                                                                        \
d124 5
a128 5
\
inline ReturnType1, ReturnType2 theAttr () const                            \
{                                                                        \
return theAttr ## _;                                                     \
}                                                                        \
d137 5
a141 5
\
inline ReturnType1, ReturnType2 theAttr ()                                  \
{                                                                        \
return theAttr ## _;                                                     \
}                                                                        \
d151 7
a157 7
\
inline ReturnType theAttr () const                                          \
{                                                                        \
witAssert (theAttr ## _ != NULL);                                        \
\
return theAttr ## _;                                                     \
}                                                                        \
d171 5
a175 5
\
inline ReturnType theFunc () const                                          \
{                                                                        \
return theObject->theFunc ();                                            \
}                                                                        \
d193 5
a197 5
\
inline static DataType & theData (Owner * theOwner)                         \
{                                                                        \
return theOwner->theData ## _;                                           \
}                                                                        \
d207 3
a209 3
// verifies that TheClass has its own mapping index function, rather than just
// inheriting one: When verifyMappingIndex is invoked on a pointer to an
// instance of TheClass, if TheClass doesn't have its own version of
d214 9
a222 9
\
inline int mappingIndex () const                                            \
{                                                                        \
return mappingIndex_;                                                    \
}                                                                        \
\
inline static void verifyMappingIndex (TheClass * &)                        \
{                                                                        \
}                                                                        \
d231 2
a232 2
//
// Forces the args to be evaluated here.
@


1.62
log
@Removing the DISGUISE logic from WIT.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d42 1
a42 1
   (static_cast <unsigned int> (sizeof(arr) / sizeof(arr[0])))
d58 3
a60 3
                                                                               \
   TheClass              (const TheClass &);                                   \
   TheClass & operator = (const TheClass &)                                    \
d69 2
a70 2
                                                                               \
   TheClass (const TheClass &)                                                 \
d89 5
a93 5
                                                                               \
   inline static typedFunction ()                                              \
      {                                                                        \
      return theValue;                                                         \
      }                                                                        \
d107 5
a111 5
                                                                               \
   inline ReturnType theAttr () const                                          \
      {                                                                        \
      return theAttr ## _;                                                     \
      }                                                                        \
d124 5
a128 5
                                                                               \
   inline ReturnType1, ReturnType2 theAttr () const                            \
      {                                                                        \
      return theAttr ## _;                                                     \
      }                                                                        \
d137 5
a141 5
                                                                               \
   inline ReturnType1, ReturnType2 theAttr ()                                  \
      {                                                                        \
      return theAttr ## _;                                                     \
      }                                                                        \
d151 7
a157 7
                                                                               \
   inline ReturnType theAttr () const                                          \
      {                                                                        \
      witAssert (theAttr ## _ != NULL);                                        \
                                                                               \
      return theAttr ## _;                                                     \
      }                                                                        \
d171 5
a175 5
                                                                               \
   inline ReturnType theFunc () const                                          \
      {                                                                        \
      return theObject->theFunc ();                                            \
      }                                                                        \
d193 5
a197 5
                                                                               \
   inline static DataType & theData (Owner * theOwner)                         \
      {                                                                        \
      return theOwner->theData ## _;                                           \
      }                                                                        \
d207 3
a209 3
// verifies that TheClass has its own mapping index function, rather than just 
// inheriting one: When verifyMappingIndex is invoked on a pointer to an 
// instance of TheClass, if TheClass doesn't have its own version of 
d214 9
a222 9
                                                                               \
   inline int mappingIndex () const                                            \
      {                                                                        \
      return mappingIndex_;                                                    \
      }                                                                        \
                                                                               \
   inline static void verifyMappingIndex (TheClass * &)                        \
      {                                                                        \
      }                                                                        \
d231 2
a232 2
   //
   // Forces the args to be evaluated here.
@


1.61
log
@Stochastic Implosion
@
text
@a15 8

#if DISGUISE == 1

#   include <disguise.h>

#endif

//------------------------------------------------------------------------------
@


1.60
log
@Stochastic Implosion
@
text
@d214 1
a214 1
// Also, in debug mode, this macro declares and implements a function which
a220 2
#if DEBUG_MODE

a231 11
#else

#define decMappingIndex(TheClass)                                              \
                                                                               \
   inline int mappingIndex () const                                            \
      {                                                                        \
      return mappingIndex_;                                                    \
      }                                                                        \

#endif

@


1.59
log
@Stochastic Implosion
@
text
@a138 13
// accessFuncNonConst
//
// Same as accessFunc, except the function is not const.
//------------------------------------------------------------------------------

#define accessFuncNonConst(ReturnType, theAttr)                                \
                                                                               \
   inline ReturnType theAttr ()                                                \
      {                                                                        \
      return theAttr ## _;                                                     \
      }                                                                        \

//------------------------------------------------------------------------------
@


1.58
log
@Stochastic Implosion
@
text
@d124 1
a124 1
// Same as acessFunc, except that the return type is given by:
d139 26
@


1.57
log
@[disallowed backlog]
@
text
@d122 17
@


1.56
log
@Rescinded all changed made since 1/31/07.
@
text
@d156 22
@


1.55
log
@[disallowed backlog]
@
text
@a120 7
#define accessData(ReturnType, theFunc, theData)                               \
                                                                               \
   inline ReturnType theFunc () const                                          \
      {                                                                        \
      return theData;                                                          \
      }                                                                        \

@


1.54
log
@[disallowed backlog]
@
text
@d121 7
@


1.53
log
@[disallowed backlog]
@
text
@a121 13
// accessNonConst
//
// Same as accessFunc, but the function is non-const.
//------------------------------------------------------------------------------

#define accessNonConst(ReturnType, theAttr)                                    \
                                                                               \
   inline ReturnType theAttr ()                                                \
      {                                                                        \
      return theAttr ## _;                                                     \
      }                                                                        \

//------------------------------------------------------------------------------
a155 20
// Macro accessObjData
//
// This macro is designed to be used within a class declaration.
// Declares and implements an inline access function for a data member of a
// pre-specified object. The data member must be accessible from the current
// scope (probably via friendship).
// The name of the access function is given by theFunc.
// The name of the data member is given by theFunc with "_" appended to the end.
// ReturnType is the function's return type.
// theObject is the pre-specified object to which the data member belongs.
//------------------------------------------------------------------------------

#define accessObjData(ReturnType, theFunc, theObject)                          \
                                                                               \
   inline ReturnType theFunc ()                                                \
      {                                                                        \
      return theObject.theFunc ## _;                                           \
      }                                                                        \

//------------------------------------------------------------------------------
@


1.52
log
@Updated the copyright date on all source files.
@
text
@d122 13
d169 20
@


1.51
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.50
log
@[multi-thread]
@
text
@d193 12
@


1.49
log
@Double Precision.
@
text
@a28 11
// #undef of max and min:
//
// Some versions of stdlib define macros called "max" and "min", which are not
// used by WIT and conflict with the use of these names by namespace
// WitNonClass.
//------------------------------------------------------------------------------

#undef max
#undef min

//------------------------------------------------------------------------------
@


1.48
log
@Double Precision.
@
text
@d78 1
a78 1
   explicit TheClass     (const TheClass &);                                   \
d89 1
a89 1
   explicit TheClass (const TheClass &)                                        \
@


1.47
log
@Double Precision.
@
text
@d78 1
a78 1
   TheClass              (const TheClass &);                                   \
d89 1
a89 1
   explicit TheClass (const TheClass &);                                       \
@


1.46
log
@Double Precision.
@
text
@a203 9
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

#define WitRealVec WitDblRealVec
#define WitRealTVc WitDblRealVec

//------------------------------------------------------------------------------

@


1.45
log
@Double precision: Switched to the new vector storage techniques.
@
text
@a204 1
// Define USE_COMPACT_VECS.
a205 13

#define USE_COMPACT_VECS 1

#if USE_COMPACT_VECS

#define WitFlexVec WitNFlxVec

#else

#define WitFlexVec WitOFlxVec

#endif

a206 6
// Define USE_DBL_STORAGE.
//------------------------------------------------------------------------------

#define USE_DBL_STORAGE 1

#if USE_DBL_STORAGE
a209 7

#else

#define WitRealVec WitFltRealVec
#define WitRealTVc WitFltRealTVc

#endif
@


1.44
log
@Double Precision.
@
text
@d208 1
a208 1
#define USE_COMPACT_VECS 0
d224 1
a224 1
#define USE_DBL_STORAGE 0
@


1.43
log
@Double Precision.
@
text
@d212 1
a212 1
   #define WitFlexVec WitNFlxVec
d216 1
a216 1
   #define WitFlexVec WitOFlxVec
d228 2
a229 2
   #define WitRealVec WitDblRealVec
   #define WitRealTVc WitDblRealVec
d233 2
a234 2
   #define WitRealVec WitFltRealVec
   #define WitRealTVc WitFltRealTVc
@


1.42
log
@Double Precision.
@
text
@d221 18
@


1.41
log
@Double Precision.
@
text
@d204 18
@


1.40
log
@Continued implementation of PIP.
@
text
@d101 1
a101 1
//     defaultValue (float defOffset, 0.0)
d103 1
a103 1
// declares and implements a float-valued default value function, defOffset,
@


1.39
log
@Continued implementation of PIP.
@
text
@d32 2
a33 1
// used by WIT and conflict with the use of these names by namespace WitUtil.
@


1.38
log
@Added some optional warnings on Linux.
@
text
@d32 1
a32 2
// used by WIT and conflict with the use of these names by Rogue Wave and class
// WitUtil.
@


1.37
log
@Eliminated warnings from make depend regarding WIT code.
@
text
@d60 2
a61 1
#define NumberElem(arr)    ((unsigned int) (sizeof(arr) / sizeof(arr[0])))
@


1.36
log
@Various internal changes.
@
text
@d47 1
a47 1
   #define ifDebug(debugCode)  debugCode
d51 1
a51 1
   #define ifDebug(debugCode)
@


1.35
log
@Various internal changes.
@
text
@d88 1
a88 23
   TheClass (const TheClass &)                                                 \

//------------------------------------------------------------------------------
// noCopyCtorAssignTemp
//
// Same as noCopyCtorAssign, but for a class template.
//------------------------------------------------------------------------------

#define noCopyCtorAssignTemp(TheTemp, TheArgs)                                 \
                                                                               \
   TheTemp              (const TheTemp &);                                     \
   TheTemp & operator = (const TheTemp &)                                      \

//------------------------------------------------------------------------------

#if 0

#define noCopyCtorAssignTemp(TheTemp, TheArgs)                                 \
                                                                               \
   TheTemp                        (const TheTemp <TheArgs> &);                 \
   TheTemp <TheArgs> & operator = (const TheTemp <TheArgs> &)                  \

#endif
@


1.34
log
@Began implementation of multi-level lot sizes.
@
text
@d98 9
d109 2
@


1.33
log
@Continued implementation of single-source.
@
text
@a213 11
//------------------------------------------------------------------------------
// Template argument macros for multi-route.
//
// These macros are for code compactness and clarity.
//------------------------------------------------------------------------------

#define MrArgDecs  class SelComp,     class CandComp
#define MrArgs           SelComp,           CandComp
#define Pmr              WitPart,           WitBopEntry
#define Cmr              WitBomEntry,       WitConsEntry

@


1.32
log
@Continued implementation of single-source.
@
text
@a176 70
// Macro conditionalRef
//
// This macro is designed to be used within a class declaration.
// Declares and implements a non-const reference access function for an
// attribute. Asserts that some specified condition holds before access is
// granted.
// Args:
//    AttType:   The Type of the attribute.
//    theAttr:   The name of the attribute.
//               The name of the data member is this name with "_"   appended.
//               The name of the function    is this name with "Ref" appended.
//    condition: The boolean condition that (in DEBUG mode) is required to hold
//               when the function is called.
//------------------------------------------------------------------------------

#define conditionalRef(AttType, theAttr, condition)                            \
                                                                               \
   inline AttType & theAttr ## Ref ()                                          \
      {                                                                        \
      witAssert (condition);                                                   \
                                                                               \
      return theAttr ## _;                                                     \
      }                                                                        \

//------------------------------------------------------------------------------
// Macro refAccess.
//
// This macro is designed to be used within a class declaration.
// The class should have a data member myAccFlag_ of type AccFlag *.
//
// Declares and implements a non-const reference access function for an
// attribute of an object. Uses a conditional reference access
// function of the object to gain access.
// Args:
//    TheClass: The object's class.
//    AttType:  The Type of the attribute.
//    theAttr:  The name of the attribute.
//              The name of the function is this name.
//              The name of the conditional reference access function is this
//                  name with "Ref" appended.
// In DEBUG mode, myAccFlag_ is made to indicate the object being accessed.
//------------------------------------------------------------------------------

#if DEBUG_MODE

#define refAccess(TheClass, AttType, theAttr)                                  \
                                                                               \
   inline AttType & theAttr (TheClass * theObject) const                       \
      {                                                                        \
      myAccFlag_->access (theObject);                                          \
                                                                               \
      AttType & result = theObject->theAttr ## Ref ();                         \
                                                                               \
      myAccFlag_->reset ();                                                    \
                                                                               \
      return result;                                                           \
      }                                                                        \

#else

#define refAccess(TheClass, AttType, theAttr)                                  \
                                                                               \
   inline AttType & theAttr (TheClass * theObject) const                       \
      {                                                                        \
      return theObject->theAttr ## Ref ();                                     \
      }                                                                        \

#endif

//------------------------------------------------------------------------------
@


1.31
log
@Continued implementation of single-source.
@
text
@d145 2
a146 2
// Same as accessFunc, except that theAttr is a pointer which is required to be
// non-NULL.
a155 14
      }                                                                        \

//------------------------------------------------------------------------------
// accessMap
//
// Similar to accessFunc, except that theAttr_ must be a Schedule or Mapping
// and the function takes a domain element as its argument.
//------------------------------------------------------------------------------

#define accessMap(ReturnType, theAttr, ArgType)                                \
                                                                               \
   inline ReturnType theAttr (ArgType * theArg) const                          \
      {                                                                        \
      return theAttr ## _ (theArg);                                            \
@


1.30
log
@Continued implementation of single-source.
@
text
@d165 1
a165 1
#define accessMap(ReturnType, ArgType, theAttr)                                \
@


1.29
log
@Preliminary work on single source.
@
text
@d145 2
a146 2
// Same as accessFunc, except that theAttr is a pointer which is requires
// (via witAssert) to be non-NULL.
d156 14
@


1.28
log
@Preliminary work on single source.
@
text
@a294 16
//------------------------------------------------------------------------------
// declare2 and implement2.
// Used to declare and implement 2-argument generic classes.
//------------------------------------------------------------------------------

#undef declare2
#undef implement2

#define declare2(Class, Type1, Type2)                                          \
                                                                               \
        name2 (Class, declare2) (Type1, Type2)                                 \

#define implement2(Class, Type1, Type2)                                        \
                                                                               \
        name2 (Class, implement2) (Type1, Type2)                               \

@


1.27
log
@Continued preliminary work on single source.
@
text
@a310 14
//------------------------------------------------------------------------------
// Generic class name macros.
//------------------------------------------------------------------------------

#define WitFlexVec(TheType)                                                    \
                                                                               \
        name2 (WitFlexVec, TheType)                                            \

//------------------------------------------------------------------------------

#define WitFlexVecRep(TheType)                                                 \
                                                                               \
        name2 (WitFlexVecRep, TheType)                                         \

@


1.26
log
@Continued preliminary work on single source.
@
text
@a314 12
#define WitMapping(DomainType, RangeType)                                      \
                                                                               \
        name3 (WitMapping, DomainType, RangeType)                              \

//------------------------------------------------------------------------------

#define WitSchedule(Arg1Type, RangeType)                                       \
                                                                               \
        name3 (WitSchedule, Arg1Type, RangeType)                               \

//------------------------------------------------------------------------------

@


1.25
log
@More preliminary work on single source.
@
text
@a314 6
#define WitTVec(TheType)                                                       \
                                                                               \
        name2 (WitTVec, TheType)                                               \

//------------------------------------------------------------------------------

@


1.24
log
@Preliminary work on single source.
@
text
@a332 6
#define WitDenseList(TheType)                                                  \
                                                                               \
        name2 (WitDenseList, TheType)                                          \

//------------------------------------------------------------------------------

@


1.23
log
@Preliminary work on single source.
@
text
@a314 6
#define WitVector(TheType)                                                     \
                                                                               \
        name2 (WitVector, TheType)                                             \

//------------------------------------------------------------------------------

@


1.22
log
@Continued implmentation of selective stock reallocation.
@
text
@a338 6
#define WitList(TheType)                                                       \
                                                                               \
        name2 (WitList, TheType)                                               \

//------------------------------------------------------------------------------

@


1.21
log
@Refactoring for constrained stock reallocation.
@
text
@d285 11
@


1.20
log
@Initial implementation of multi-route class templates.
@
text
@a349 6
//------------------------------------------------------------------------------

#define WitDblSpSched(TheType)                                                 \
                                                                               \
        name2 (WitDblSpSched, TheType)                                         \

@


1.19
log
@More templates.
@
text
@d77 1
a77 2
   TheClass (const TheClass &);                                                \
                                                                               \
d89 11
@


1.18
log
@Converted several generic classes into class templates.
@
text
@a341 13
#define WitPtrVec(TheType)                                                     \
                                                                               \
        name2 (WitPtrVec, TheType)                                             \

//------------------------------------------------------------------------------

#define WitPtrTVec(TheType)                                                    \
                                                                               \
        name2 (WitPtrTVec, TheType)                                            \


//------------------------------------------------------------------------------

@


1.17
log
@Replaced generic class PairLink (ValType)
   with class template PairLink <ValType>.
@
text
@a341 43
#define WitObjStack(ObjType)                                                   \
                                                                               \
        name2 (WitObjStack, ObjType)                                           \

//------------------------------------------------------------------------------

#define WitObjStItr(ObjType)                                                   \
                                                                               \
        name2 (WitObjStItr, ObjType)                                           \

//------------------------------------------------------------------------------

#define WitAbsPairStack(ValType)                                               \
                                                                               \
        name2 (WitAbsPairStack, ValType)                                       \

//------------------------------------------------------------------------------

#define WitPairStack(ObjType, ValType)                                         \
                                                                               \
        name3 (WitPairStack, ObjType, ValType)                                 \

//------------------------------------------------------------------------------

#define WitPairStItr(ObjType, ValType)                                         \
                                                                               \
        name3 (WitPairStItr, ObjType, ValType)                                 \

//------------------------------------------------------------------------------

#define WitPairLinkMgr(ValType)                                                \
                                                                               \
        name2 (WitPairLinkMgr, ValType)                                        \

//------------------------------------------------------------------------------

#define WitOldPLink(ValType)                                                   \
                                                                               \
        name2 (WitOldPLink, ValType)                                           \


//------------------------------------------------------------------------------

@


1.16
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d378 1
a378 1
#define WitPairLink(ValType)                                                   \
d380 1
a380 1
        name2 (WitPairLink, ValType)                                           \
@


1.15
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a401 7

//------------------------------------------------------------------------------

#define WitStackSpSched(TheType)                                               \
                                                                               \
        name2 (WitStackSpSched, TheType)                                       \

@


1.14
log
@Continued implementation of selection splitting with the new design.
@
text
@d405 1
a405 1
#define WitStackSpSched(DomType, ObjType)                                      \
d407 1
a407 1
        name3 (WitStackSpSched, DomType, ObjType)                              \
@


1.13
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d133 16
@


1.12
log
@Further development of coarse selection splitting.
@
text
@d332 6
d350 1
a350 7
#define WitAbsPairStackItr(ValType)                                            \
                                                                               \
        name2 (WitAbsPairStackItr, ValType)                                    \

//------------------------------------------------------------------------------

#define WitPairStackItr(ObjType, ValType)                                      \
d352 1
a352 1
        name3 (WitPairStackItr, ObjType, ValType)                              \
@


1.11
log
@Further development of coarse selection splitting.
@
text
@d332 6
d341 6
@


1.10
log
@Futher development of selection splitting.
@
text
@d374 7
@


1.9
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@d367 7
@


1.8
log
@Some minor changes.
@
text
@d344 1
a344 1
#define WitPairStackLinkMgr(ValType)                                           \
d346 1
a346 1
        name2 (WitPairStackLinkMgr, ValType)                                   \
d350 1
a350 1
#define WitPairStackLink(ValType)                                              \
d352 1
a352 1
        name2 (WitPairStackLink, ValType)                                      \
@


1.7
log
@Some minor modifications.
@
text
@a283 6
#define WitRefVector(TheType)                                                  \
                                                                               \
        name2 (WitRefVector, TheType)                                          \

//------------------------------------------------------------------------------

@


1.6
log
@Refactoring for selection splitting.
@
text
@d332 1
a332 1
#define WitObjDynStack(ObjType)                                                \
d334 1
a334 1
        name2 (WitObjDynStack, ObjType)                                        \
d338 1
a338 1
#define WitPairDynStack(ObjType, ValType)                                      \
d340 1
a340 1
        name3 (WitPairDynStack, ObjType, ValType)                              \
d344 1
a344 1
#define WitPairDynItr(ObjType, ValType)                                        \
d346 1
a346 1
        name3 (WitPairDynItr, ObjType, ValType)                                \
d350 1
a350 1
#define WitPairDynLinkMgr(ValType)                                             \
d352 1
a352 1
        name2 (WitPairDynLinkMgr, ValType)                                     \
d356 1
a356 1
#define WitPairDynLink(ValType)                                                \
d358 1
a358 1
        name2 (WitPairDynLink, ValType)                                        \
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d63 1
a63 1
// copyCtorAndAssignment
d75 1
a75 1
#define copyCtorAndAssignment(TheClass)                                        \
d82 10
d359 13
@


1.4
log
@Trivial change.
@
text
@d310 7
a316 1
#define WitDynStack(TheType)                                                   \
d318 1
a318 1
        name2 (WitDynStack, TheType)                                           \
d322 1
a322 1
#define WitDynPerStack(TheType)                                                \
d324 1
a324 1
        name2 (WitDynPerStack, TheType)                                        \
d328 1
a328 1
#define WitDynPerItr(TheType)                                                  \
d330 1
a330 1
        name2 (WitDynPerItr, TheType)                                          \
d334 1
a334 1
#define WitFlexVec(TheType)                                                    \
d336 1
a336 1
        name2 (WitFlexVec, TheType)                                            \
d340 1
a340 1
#define WitFlexVecRep(TheType)                                                 \
d342 1
a342 1
        name2 (WitFlexVecRep, TheType)                                         \
d345 4
@


1.3
log
@Replaced "PRM" with "WIT".
Replaced "Production Resource Manager" with "Watson Implosion Technology".
Upgraded release # to 6.0.
@
text
@d10 2
a11 2
#ifndef witmacros_h
#define witmacros_h
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d32 1
a32 1
// used by PRM and conflict with the use of these names by Rogue Wave and class
d42 1
a42 1
// Expands to debugCode, iff PRM was complied in DEBUG mode.
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

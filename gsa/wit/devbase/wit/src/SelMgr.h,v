head	1.67;
access;
symbols
	sce_5_01_20080919:1.57
	latest_sce_4_20_20060523:1.57.0.2
	sce_4_20_20060523:1.57
	latest_sce4_20_OSL:1.56.0.2
	sce_4_20_OSL:1.56
	sce_410_withVa:1.56
	sce_4_05_20040511:1.46
	sce_4_00_20040201:1.46
	nextGenBranch:1.45.0.2
	nextGenRoot:1.45
	sce_3_30_20030627:1.45
	EndRw-branch:1.35.0.4
	Root-of-EndRw:1.35
	rwToStl:1.35.0.2
	latest_sce_3_10_20010924:1.30.0.2
	sce_3_10_20010924:1.30
	latest_sce_3_00_20010601:1.20.0.2
	sce_3_00_20010601:1.20
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5;
locks; strict;
comment	@ * @;


1.67
date	2011.09.28.23.50.10;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2011.09.24.00.28.36;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2011.08.30.20.18.09;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2010.07.26.21.47.12;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2010.07.26.17.48.44;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.16.22.26.41;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.02.18.53.10;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.29.19.56.42;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.24.23.37.33;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.18.23.11.15;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.02.17.34.12;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.01.10.22.34.49;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.12.28.19.21.19;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.12.24.00.02.27;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.12.21.22.13.49;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.12.17.21.53.01;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.12.16.21.22.13;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.12.15.20.20.50;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.14.22.37.10;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.13.23.35.48;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.10.16.49.44;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.24.17.11.17;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.04.18.20.30.58;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.11.19.08.29;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.01.20.34.31;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.21.23.36.55;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.19.16.48.27;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.03.21.07.33;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.28.20.47.39;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.27.17.21.26;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.07.23.29.11;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.02.22.18.47;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.26.19.05.31;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.24.23.00.06;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.15.21.21.37;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.12.21.02.03;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.22.21.23.23;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.04.15.44.39;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.24.22.03.22;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.23.21.13.55;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.22.20.41.53;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.12.17.57.02;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.11.20.47.38;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.03.20.07.31;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.28.17.35.20;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.14.17.41.55;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.01.19.23.35;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.30.21.16.49;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.29.22.11.28;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.25.22.59.14;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.25.14.53.27;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.17.15.11.17;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.10.22.31.14;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.25.20.54.36;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.10.21.59.35;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.06.19.22.10;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.03.19.23.06;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.30.18.54.47;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.21.21.55.48;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.20.21.03.59;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.12.19.48.08;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.16.37.07;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.01.16.24.44;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.31.23.17.46;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.19.26.11;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.24.20.05.57;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.20.00.44.22;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.67
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef SelMgrH
#define SelMgrH

//------------------------------------------------------------------------------
// Header file: "SelMgr.h"
//
// Contains the declaration of class SelMgr.
//------------------------------------------------------------------------------

#include <Assoc.h>

//------------------------------------------------------------------------------
// Class SelMgr
//
// Base class for classes that manage a particular kind of selection.
//
// Class Hierarchy:
//
// ProbAssoc
//    SelMgr
//       MrSelMgr
//          PmrSelMgr
//          CmrSelMgr
//       BaMgr
//       MeMgr
//       SsrMgr
//       PrSelMgr
//          PprSelMgr
//          CprSelMgr
//
// Implemented in Selection.C.
//------------------------------------------------------------------------------

class WitSelMgr: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitSelMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual WitAltPt * myAltPtFor (
            WitBopEntry *  theBopEnt,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitPeriod      fillPer) = 0;
         //
         // Finds the AltPt for this SelMgr that corresponds to an explosion
         // thru theBopEnt and theConsEnt in execution period execPer to fill
         // requirements in fillPer. If such a AltPt exists, it is returned;
         // otherwise NULL is returned.

      virtual WitAltPt * myAltPtFor (WitPart * thePart, WitPeriod fillPer);
         //
         // Finds the AltPt for this SelMgr that corresponds to an explosion
         // thru thePart to fill requirements in fillPer.
         // If such a AltPt exists and is well-defined, it is returned;
         // otherwise NULL is returned.
         // The default implementation returns NULL.

      virtual bool validForNetting () = 0;
         //
         // Returns true, iff the SelPts owned by this SelMgr apply to ConsEntry
         // netting.

      virtual bool validForExecBounds () = 0;
         //
         // Returns true, iff the SelPts owned by this SelMgr apply to 
         // execBound shortages.

      virtual bool validForLTBounds () = 0;
         //
         // Returns true, iff the SelPts owned by this SelMgr apply to 
         // lead time bound shortages.

      virtual const char * selCaseName () = 0;
         //
         // Returns a string naming which case of selection is managed by this
         // SelMgr.

      void setIndex ();
         //
         // Sets myIndex_.

      bool isLowerThan (WitSelMgr * theSelMgr);
         //
         // Returns true, iff this SelMgr represents a lower aspect of the
         // explosion logic than theSelMgr.

      //------------------------------------------------------------------------
      // Selection splitting functions.
      //------------------------------------------------------------------------

      virtual bool selSplitNeeded () = 0;
         //
         // Returns true, iff the input data associated with this SelMgr 
         // includes a request for selection splitting.

      void setUpSelSplit ();
         //
         // Sets up selection splitting for this SelMgr.

      void setBoundedSplit (bool);

      virtual void postSplitCommit ();
         //
         // Takes actions appropriate at the end of a split-commit, if any.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitSelector *, mySelector)
      accessFunc (bool,          selSplit)
      accessFunc (bool,          boundedSplit)
   
   protected:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSelMgr (WitSelector *);

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitSelMgr);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector that owns this SelMgr.

      int myIndex_;
         //
         // An index for sorting SelMgrs.
         // # of SelMgrs owned by mySelector_ constructed before this one, where
         // construction starts with the highest SelMgr and proceeds upward.
         // Thus higher index means lower in the explosion logic.

      bool selSplit_;
         //
         // true, iff selection splitting is be to performed.

      bool boundedSplit_;
         //
         // true, iff there is currently a bounded split explosion at this
         // SelMgr.
   };

#endif
@


1.66
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.65
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d44 2
a45 46
{
public:

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

virtual ~WitSelMgr ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

virtual WitAltPt * myAltPtFor (
WitBopEntry *  theBopEnt,
WitConsEntry * theConsEnt,
WitPeriod      execPer,
WitPeriod      fillPer) = 0;
//
// Finds the AltPt for this SelMgr that corresponds to an explosion
// thru theBopEnt and theConsEnt in execution period execPer to fill
// requirements in fillPer. If such a AltPt exists, it is returned;
// otherwise NULL is returned.

virtual WitAltPt * myAltPtFor (WitPart * thePart, WitPeriod fillPer);
//
// Finds the AltPt for this SelMgr that corresponds to an explosion
// thru thePart to fill requirements in fillPer.
// If such a AltPt exists and is well-defined, it is returned;
// otherwise NULL is returned.
// The default implementation returns NULL.

virtual bool validForNetting () = 0;
//
// Returns true, iff the SelPts owned by this SelMgr apply to ConsEntry
// netting.

virtual bool validForExecBounds () = 0;
//
// Returns true, iff the SelPts owned by this SelMgr apply to
// execBound shortages.

virtual bool validForLTBounds () = 0;
//
// Returns true, iff the SelPts owned by this SelMgr apply to
// lead time bound shortages.
d47 125
a171 81
virtual const char * selCaseName () = 0;
//
// Returns a string naming which case of selection is managed by this
// SelMgr.

void setIndex ();
//
// Sets myIndex_.

bool isLowerThan (WitSelMgr * theSelMgr);
//
// Returns true, iff this SelMgr represents a lower aspect of the
// explosion logic than theSelMgr.

//------------------------------------------------------------------------
// Selection splitting functions.
//------------------------------------------------------------------------

virtual bool selSplitNeeded () = 0;
//
// Returns true, iff the input data associated with this SelMgr
// includes a request for selection splitting.

void setUpSelSplit ();
//
// Sets up selection splitting for this SelMgr.

void setBoundedSplit (bool);

virtual void postSplitCommit ();
//
// Takes actions appropriate at the end of a split-commit, if any.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (WitSelector *, mySelector)
accessFunc (bool,          selSplit)
accessFunc (bool,          boundedSplit)

protected:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitSelMgr (WitSelector *);

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitSelMgr);

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

WitSelector * const mySelector_;
//
// The Selector that owns this SelMgr.

int myIndex_;
//
// An index for sorting SelMgrs.
// # of SelMgrs owned by mySelector_ constructed before this one, where
// construction starts with the highest SelMgr and proceeds upward.
// Thus higher index means lower in the explosion logic.

bool selSplit_;
//
// true, iff selection splitting is be to performed.

bool boundedSplit_;
//
// true, iff there is currently a bounded split explosion at this
// SelMgr.
};
@


1.64
log
@Selection Recovery
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d44 46
a89 2
   {
   public:
d91 81
a171 125
      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitSelMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual WitAltPt * myAltPtFor (
            WitBopEntry *  theBopEnt,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitPeriod      fillPer) = 0;
         //
         // Finds the AltPt for this SelMgr that corresponds to an explosion
         // thru theBopEnt and theConsEnt in execution period execPer to fill
         // requirements in fillPer. If such a AltPt exists, it is returned;
         // otherwise NULL is returned.

      virtual WitAltPt * myAltPtFor (WitPart * thePart, WitPeriod fillPer);
         //
         // Finds the AltPt for this SelMgr that corresponds to an explosion
         // thru thePart to fill requirements in fillPer.
         // If such a AltPt exists and is well-defined, it is returned;
         // otherwise NULL is returned.
         // The default implementation returns NULL.

      virtual bool validForNetting () = 0;
         //
         // Returns true, iff the SelPts owned by this SelMgr apply to ConsEntry
         // netting.

      virtual bool validForExecBounds () = 0;
         //
         // Returns true, iff the SelPts owned by this SelMgr apply to 
         // execBound shortages.

      virtual bool validForLTBounds () = 0;
         //
         // Returns true, iff the SelPts owned by this SelMgr apply to 
         // lead time bound shortages.

      virtual const char * selCaseName () = 0;
         //
         // Returns a string naming which case of selection is managed by this
         // SelMgr.

      void setIndex ();
         //
         // Sets myIndex_.

      bool isLowerThan (WitSelMgr * theSelMgr);
         //
         // Returns true, iff this SelMgr represents a lower aspect of the
         // explosion logic than theSelMgr.

      //------------------------------------------------------------------------
      // Selection splitting functions.
      //------------------------------------------------------------------------

      virtual bool selSplitNeeded () = 0;
         //
         // Returns true, iff the input data associated with this SelMgr 
         // includes a request for selection splitting.

      void setUpSelSplit ();
         //
         // Sets up selection splitting for this SelMgr.

      void setBoundedSplit (bool);

      virtual void postSplitCommit ();
         //
         // Takes actions appropriate at the end of a split-commit, if any.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitSelector *, mySelector)
      accessFunc (bool,          selSplit)
      accessFunc (bool,          boundedSplit)
   
   protected:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSelMgr (WitSelector *);

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitSelMgr);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector that owns this SelMgr.

      int myIndex_;
         //
         // An index for sorting SelMgrs.
         // # of SelMgrs owned by mySelector_ constructed before this one, where
         // construction starts with the highest SelMgr and proceeds upward.
         // Thus higher index means lower in the explosion logic.

      bool selSplit_;
         //
         // true, iff selection splitting is be to performed.

      bool boundedSplit_;
         //
         // true, iff there is currently a bounded split explosion at this
         // SelMgr.
   };
@


1.63
log
@Selection Recovery.
@
text
@a104 7
      virtual void specSelRecoverO ();
         //
         // Performs aspects of selection recovery that are specific to the
         // selection case.
         // (Old approach)
         // Default implementation: no-op.

@


1.62
log
@Selection Recovery
@
text
@a111 7
      virtual void recoverSelections () = 0;
         //
         // Restores the selection configuration for the selection case to its
         // original state, recovering all discarded selection candidates.
         // Valid only in selection recovery mode.
         // (New approach)

@


1.61
log
@Selection recovery.
@
text
@d105 1
a105 1
      virtual void specSelRecovery ();
d109 1
d112 7
@


1.60
log
@Selection Reuse.
@
text
@d105 1
a105 1
      virtual void restoreSpecConfig ();
d107 2
a108 2
         // Restores the aspects of the selection configuration that are
         // specific to the selection case.
@


1.59
log
@Selection reuse.
@
text
@d40 1
a40 1
// Implemented in MultiSel.C.
@


1.58
log
@Lead Time Bounds
@
text
@d105 6
@


1.57
log
@Updated the copyright date on all source files.
@
text
@d68 8
d84 6
a89 1
         // execBounds shortages.
@


1.56
log
@Low-Pri Prop-Rt.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.55
log
@Low-Pri Prop-Rt.
@
text
@a35 3
//       PoSelMgr
//          PpoSelMgr
//          CpoSelMgr
@


1.54
log
@Low-Pri Prop-Rt.
@
text
@d60 1
a60 1
      virtual WitSelAlt * mySelAltFor (
d66 1
a66 1
         // Finds the SelAlt for this SelMgr that corresponds to an explosion
d68 1
a68 1
         // requirements in fillPer. If such a SelAlt exists, it is returned;
@


1.53
log
@Low-Pri Prop-Rt.
@
text
@d39 3
@


1.52
log
@Low-Pri Prop-Rt.
@
text
@d57 1
a57 1
      virtual WitSelPt * mySelPtForAlt (
d63 4
a66 5
         // Finds the SelPt owned by this SelMgr that corresponds to an
         // explosion thru theBopEnt and theConsEnt in execution period execPer
         // to fill requirements in fillPer. If that SelPt exists and its
         // selection can be altered, the SelPt is returned; otherwise NULL is
         // returned.
@


1.51
log
@Low-Pri Prop-Rt.
@
text
@a19 1
#include <ObjStack.h>
a92 14
      WitSelCand * freshSelCand (WitSelPt * theSelPt);
         //
         // * Finds an inactive SelCand for this SelMgr, creating a new one, if
         //   necessary.
         // * Activates the SelCand.
         // * Sets the SelCand to represent the current selection at theSelPt.
         // * Returns the SelCand.
         // * Ownership of the SelCand is transfered to the calling function.

      void deactivate (WitSelCand * theSelCand);
         //
         // Makes theSelCand inactive.
         // Transfers ownership of the SelCand back to this SelMgr.

a133 8
      virtual WitSelCand * newSelCand () = 0;
         //
         // Constructs and returns a new instance of a class derived from
         // SelCand, associated with this SelMgr, where the derived class
         // corresponds to the derived class of which this SelMgr is an
         // instance.
         // This is an application of the "factory method" design pattern.

a158 11

      WitObjStack <WitSelCand> inactiveSelCands_;
         //
         // The set of SelCands for this SelMgr that are currently inactive.
         // These are the SelCands that are currently owned by this SelMgr.

      WitObjStack <WitSelCand> allSelCands_;
         //
         // In debug mode, allSelCands_ is the set of all SelCands for this
         // SelMgr.
         // In non-debug mode, allSelCands_ is empty.
@


1.50
log
@Low-Pri Prop-Rt.
@
text
@d94 1
a94 1
      WitSelCand * freshSelCand ();
d96 6
a101 3
         // Activates an inactive SelCand for this SelMgr (creating a new one,
         // necessary) and returns it.
         // Transfers ownership of the SelCand to the calling function.
@


1.49
log
@Low-Pri Prop-Rt.
@
text
@d94 1
a94 1
      WitSelCand * unusedSelCand ();
d96 3
a98 2
         // Returns a SelCand for this SelMgr, that's not currently in use.
         // The calling function is responsible for recycling the SelCand.
d100 1
a100 1
      void recycle (WitSelCand * theSelCand);
d102 2
a103 1
         // Stores theSelCand for later re-use.
d180 1
a180 1
      WitObjStack <WitSelCand> unusedSelCands_;
d182 2
a183 2
         // The set of SelCands owned by this SelMgr that are not currently in
         // use.
d185 1
a185 1
      WitObjStack <WitSelCand> mySelCands_;
d187 1
a187 1
         // In debug mode, mySelCands_ is the set of all SelCands owned by this
d189 1
a189 1
         // In non-debug mode, mySelCands_ is empty.
@


1.48
log
@Low-Pri Prop-Rt.
@
text
@d94 9
d144 8
d182 6
@


1.47
log
@Low-Pri Prop-Rt.
@
text
@a18 1
#include <PairStack.h>
d20 1
d160 5
@


1.46
log
@Continued implementation of PIP.
@
text
@a33 3
//       PrSelMgr
//          PprSelMgr
//          CprSelMgr
d37 3
@


1.45
log
@Continued implementation of proportionate routing.
@
text
@d20 1
@


1.44
log
@Continued implementation of proportionate routing.
@
text
@a105 4
      void finishSplitExp ();
         //
         // Concludes a split explosion for this SelMgr.

a127 17
      //------------------------------------------------------------------------
      // Other protected member functions.
      //------------------------------------------------------------------------

      void startSplitExpAbs (WitSelPt * theSelPt, double toSplitVol);
         // 
         // Initiates a split explosion for this SelMgr.
         // Valid only in sel-split mode.

      bool findNextSplitAbs (WitSelCand * & theSelCand, double & splitVol);
         //
         // If there is another split to be done on the current split explosion,
         // theSelCand and splitVol are set accordingly, and true is returned;
         // otherwise, theSelCand and splitVol are undefined, and false is
         // returned.
         // Valid only during a split explosion for this SelMgr.

a153 6

      WitSplitPt * splitExpPt_;
         //
         // If a split explosion for this SelMgr is currently underway,
         // splitExpPt_ is the SplitPt at which it is being done.
         // Otherwise NULL.
@


1.43
log
@Continued implementation of proportionate routing.
@
text
@a105 7
      bool boundedSplit ();
         //
         // true, iff:
         //    Sel-split is being performed, and
         //    there is currently a split explosion for this SelMgr, and
         //    it's a bounded split.

d110 2
d122 1
a148 4
      void recordFlowSS (WitSelPt * theSelPt, double incFlowVol);
         //
         // See WitFlowMonitor::recordFlow.

d181 5
@


1.42
log
@Continued implementation of propotionate routing.
@
text
@d30 6
a35 6
//       MrSecMgr
//          PmrMgr
//          CmrMgr
//       PrSecMgr
//          PprMgr
//          CprMgr
@


1.41
log
@Continued implementation of proportionate routing.
@
text
@d30 6
a35 5
//       MrSelMgr
//          PmrSelMgr
//          CmrSelMgr
//       PrSelMgr
//          PprSelMgr
@


1.40
log
@Continued implementation of proportionate routing.
@
text
@d30 3
a32 5
//       MrMgr
//          SpecMrMgr <Pmr>
//             PmrMgr
//          SpecMrMgr <Cmr>
//             CmrMgr
d34 1
@


1.39
log
@Continued implementation of proportionate routing.
@
text
@d35 1
a35 5
//       OpMgr
//          ProdOpMgr
//          ConsOpMgr
//       ProdPrSelMgr
//       ConsPrSelMgr
@


1.38
log
@Continued implementation of proportionate routing.
@
text
@d35 5
@


1.37
log
@Continued implementation of proportionate routing.
@
text
@d83 4
@


1.36
log
@Internal changes.
@
text
@d56 1
a56 1
      virtual WitSelPt * mySelPt (
d62 1
a62 1
         // Returns the SelPt owned by this SelMgr that corresponds to an
d64 3
a66 1
         // to fill requirements in fillPer, or NULL, if there is none.
@


1.35
log
@Began implementation of multi-level lot sizes.
@
text
@d66 1
a66 1
      virtual WitBoolean validForNetting () = 0;
d68 1
a68 1
         // Returns TRUE, iff the SelPts owned by this SelMgr apply to ConsEntry
d71 1
a71 1
      virtual WitBoolean validForExecBounds () = 0;
d73 1
a73 1
         // Returns TRUE, iff the SelPts owned by this SelMgr apply to 
d81 1
a81 1
      WitBoolean isLowerThan (WitSelMgr * theSelMgr);
d83 1
a83 1
         // Returns TRUE, iff this SelMgr represents a lower aspect of the
d90 1
a90 1
      virtual WitBoolean selSplitNeeded () = 0;
d92 1
a92 1
         // Returns TRUE, iff the input data associated with this SelMgr 
d99 1
a99 1
      WitBoolean boundedSplit ();
d101 1
a101 1
         // TRUE, iff:
d119 1
a119 1
      accessFunc (WitBoolean,    selSplit)
d138 1
a138 3
      WitBoolean findNextSplitAbs (
            WitSelCand * & theSelCand, 
            double &       splitVol);
d141 2
a142 2
         // theSelCand and splitVol are set accordingly, and TRUE is returned;
         // otherwise, theSelCand and splitVol are undefined, and FALSE is
d173 1
a173 1
      WitBoolean selSplit_;
d175 1
a175 1
         // TRUE, iff selection splitting is be to performed.
@


1.34
log
@Continued implementation of single-source.
@
text
@d30 5
a34 2
//       MrMgr <Pmr>
//       MrMgr <Cmr>
@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@d57 1
a57 2
            WitPeriod      fillPer,
            WitBoolean &   resFound) = 0;
d61 1
a61 3
         // to fill requirements in fillPer, or NULL, if there is none. On 
         // return, resFound indicates whether or not a resolving alteration was
         // found.
@


1.32
log
@Continued implementation of sel-split for pen-exec.
@
text
@d81 5
d150 1
a150 1
         // See Splitter::recordFlow.
d167 7
@


1.31
log
@Continued implementation of sel-split for pen-exec.
@
text
@a18 1
#include <Selector.h>
d113 2
a114 4
      accessFunc    (WitSelector *, mySelector)
      accessFunc    (WitBoolean,    selSplit)

      accessWrapper (WitSplitter *, mySplitter, mySelector_)
d142 4
@


1.30
log
@Continuing implementation of selective stock reallocation.
@
text
@d67 5
@


1.29
log
@Refactoring for constrained stock reallocation.
@
text
@d29 7
a35 7
// SelMgr
//    MrMgr <Pmr>
//       PmrMgr   [private]
//    MrMgr <Cmr>
//       CmrMgr   [private]
//    BaMgr
//    MeMgr
d101 1
a101 1
      virtual void postSplitCommit () = 0;
d103 1
a103 1
         // Takes actions appropriate at the end of a split-commit.
@


1.28
log
@Refactoring for constrained stock reallocation.
@
text
@a100 5
      virtual void postCommitSS () = 0;
         //
         // Performs the actions to be taken by this SelMgr for sel-split, just
         // after a commit. 

a125 5
      virtual void setUpDerivedSS () = 0;
         //
         // Sets up aspects of selection splitting for this SelMgr specific to
         // its derived class.

d136 3
a138 2
         // sets theSelCand and splitVol accordingly and returns TRUE;
         // otherwise returns false.
@


1.27
log
@Refactoring for constrained stock reallocation.
@
text
@a76 5
      virtual void prtSelCandID (WitTlObj * theTlObj) = 0;
         //
         // Prints info identifying this theTlObj, iterpreted as a selection
         // candidate for the selection case for this SelMgr.

d141 3
a143 1
      WitBoolean findNextSplitAbs (WitTlObj * & splitObj, double & splitVol);
d146 1
a146 1
         // sets splitObj and splitVol accordingly and returns TRUE;
@


1.26
log
@Templatized consumption multi-route.
@
text
@d30 4
a33 4
//    MrMgr <PmrArgs>
//       PmrMgr       [private]
//    MrMgr <CmrArgs>
//       CmrMgr       [private]
d119 1
a151 6

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitSelector *, mySelector)
@


1.25
log
@Continued refactoring.
@
text
@d32 2
a33 1
//    CmrMgr
@


1.24
log
@Moved Stack template implementations to header files.
@
text
@d31 1
a31 1
//       PmrMgr
@


1.23
log
@Replaced non-template based production multi-route with template based
production multi-route.
@
text
@d20 1
a20 1
#include <PairSt.h>
@


1.22
log
@Created class SelCand and classes derived from it.
@
text
@d30 2
a31 1
//    PmrMgr
@


1.21
log
@Continued development of selection splitting for multi=exec.
@
text
@d30 2
a32 1
//    PmrMgr
a33 1
//    CmrMgr
@


1.20
log
@Refactoring for sel-split for multi-exec.
@
text
@a58 1
         // Base class function.
a66 1
         // Base class function.
d70 10
a85 1
         // Base class function.
a105 1
         // Base class function.
a110 1
         // Base class function.
a134 1
         // Base class function.
@


1.19
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@d86 7
d95 1
a95 1
         // Concludes a sel-split explosion.
a112 1
      accessFunc    (WitBoolean,    boundedSplit)
d114 1
a114 1
      accessWrapper (WitSplitter *, mySplitter, mySelector ())
d136 1
a136 1
         // Sets up for a sel-split explosion for this SelMgr.
d144 1
a144 1
         // Valid only in sel-split mode.
a157 7
      void prtSplitExpIA (
            WitTlObj * splitObj, 
            double     splitVol, 
            double     splitBound);
         //
         // Prints data for a selection split, if appropriate.

a167 4
      //------------------------------------------------------------------------
      // Selection splitting data.
      //------------------------------------------------------------------------

a171 5
      WitBoolean boundedSplit_;
         //
         // TRUE, iff the current selection for this SelMgr is a bounded split
         // selection. FALSE, if not in sel-split mode.

a176 12

      WitPairStItr (WitTlObj, double) splitListItr_;
         //
         // An iterator for the split list for the currently active split 
         // explosion. It is associated with the current split pair.
         // Undefined, if split explosion is not currently active.

      double netToSplitVol_;
         //
         // The amount that remains to be split by the currently active split
         // explosion.
         // Undefined, if split explosion is not currently active.
@


1.18
log
@Various refactorings for sel-split for multi-exec.
@
text
@a139 9
      virtual void adjustSplitBound (
            WitTlObj * theTlObj, 
            double &   splitBound) = 0;
         //
         // Base class function.
         // Makes whatever adjustment to splitBound is appropriate for the 
         // currently active split explosion when split to theTlObj.
         // Valid only in sel-split mode.

@


1.17
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d128 1
a128 4
      void startSplitExpAbs (
            WitSelPt * theSelPt,
            WitTlObj * unbnddObj,
            double     toSplitVol);
a148 6
      virtual void prtSplitExp (WitTlObj * theTlObj) = 0;
         //
         // Base class function.
         // Prints data for a selection split.
         // Valid only in sel-split mode.

d184 1
a184 1
         // TRUE, iff this SelMgr is to perform selection splitting.
d191 1
a191 1
      WitBoolean splitExpActive_;
d193 3
a195 2
         // TRUE, iff the build was in DEBUG mode and a split explosion for this
         // SelMgr is currently underway.
a206 11
         // Undefined, if split explosion is not currently active.

      WitTlObj * unbnddSplitObj_;
         //
         // The unbounded split object, if any, for the currently active split
         // explosion, else NULL.
         // Undefined, if split explosion is not currently active.

      WitBoolean splitAtSearchPt_;
         //
         // TRUE, iff the currently active split explion is at the search point.
@


1.16
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a19 1
#include <StSpSch.h>
d129 3
a131 4
            const WitTlDblStack & splitList,
            WitTl *               unbnddObj,
            double                toSplitVol,
            WitSelPt *            theSelPt);
d136 1
a136 1
      WitBoolean findNextSplitAbs (WitTl * & splitObj, double & splitVol);
d143 3
a145 1
      virtual void adjustSplitBound (WitTl * theTlObj, double & splitBound) = 0;
d152 1
a152 1
      virtual void prtSelSplit (WitTl * theTlObj) = 0;
d170 4
a173 1
      void prtSelSplitIA (WitTl * splitObj, double splitVol, double splitBound);
d205 1
a205 1
      WitPairStItr (WitTl, double) splitListItr_;
d217 1
a217 1
      WitTl * unbnddSplitObj_;
@


1.15
log
@Renamed AltPt classes to SelPt classes.
@
text
@d77 10
d123 6
d188 1
a188 1
      const WitBoolean selSplit_;
@


1.14
log
@Refactoring for selection splitting.
@
text
@d53 1
a53 1
      virtual WitAltPt * myAltPt (
d61 1
a61 1
         // Returns the AltPt owned by this SelMgr that corresponds to an
d70 1
a70 1
         // Returns TRUE, iff the AltPts owned by this SelMgr apply to 
d117 1
a117 1
            WitAltPt *            theAltPt);
@


1.13
log
@Continuing development of selection splitting.
@
text
@d32 1
a32 1
//    ProdRtr
d34 1
a34 1
//    ConsRtr
@


1.12
log
@Re-worked the controls for selection splitting.
@
text
@d36 1
a36 1
// Implemented in Selector.C.
@


1.11
log
@Continued implementation of selection splitting.
@
text
@d107 1
a107 1
      WitSelMgr (WitSelector *, WitBoolean selSplitVal);
@


1.10
log
@Continued implementation of selection splitting.
@
text
@d87 1
a87 1
      virtual void clearSplitSched () = 0;
d90 1
a90 1
         // Clears the split sched for this SelMgr.
d96 2
a97 2
      accessFunc (WitBoolean, selSplit)
      accessFunc (WitBoolean, boundedSplit)
d99 2
d146 1
a146 1
      accessFunc    (WitSelector *, mySelector)
a147 2
      accessWrapper (WitSplitter *, mySplitter, mySelector ())
   
d202 5
@


1.9
log
@Continued implementation of selection splitting with the new design.
@
text
@a202 6

      WitBoolean atSearchPt_;
         //
         // TRUE, iff the currently active split explosion is on the searching
         // AltPt.
         // Undefined, if split explosion is not currently active.
@


1.8
log
@Continued implementation of selection splitting with the new design.
@
text
@d87 5
@


1.7
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d19 1
d109 2
a110 1
            double                toSplitVol);
d113 1
d120 1
d127 1
d133 1
d139 1
a139 1
      accessFunc (WitSelector *, mySelector)
d141 2
d178 1
a178 1
         // TRUE iff the build was in DEBUG mode and a split explosion for this
d197 6
@


1.6
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d129 6
@


1.5
log
@Further implementation of coarse selection splitting.
@
text
@d80 1
a80 1
      virtual void postCommitSS (WitBoolean tempSuccess) = 0;
d84 1
a84 20
         // after a commit. tempSuccess is to be TRUE, iff the commit was
         // successful and in temp mode.

      virtual void preAltAttSS () = 0;
         //
         // Base class function.
         // Performs the actions to be taken by this SelMgr for sel-split, just
         // before a selection alteration is attempted.

      virtual void postAltAttSS () = 0;
         //
         // Base class function.
         // Performs the actions to be taken by this SelMgr for sel-split, just
         // after selection alteration has been attempted.

      virtual void postPermCommitSS () = 0;
         //
         // Base class function.
         // Performs the actions to be taken by this SelMgr for sel-split, just
         // after a perm commit.
d90 1
d99 1
a99 1
      WitSelMgr (WitHeurAllPerf *);
a128 3
      accessFunc (WitHeurAllPerf *, myHeurAllPerf)
      accessFunc (WitBoolean,       selSplit)

d145 1
a145 1
      WitHeurAllPerf * const myHeurAllPerf_; 
d147 1
a147 1
         // The HeurAllPerf to which this SelMgr applies.
d155 1
a155 1
         // See GlobalComp.
@


1.4
log
@Further implementation of coarse selection splitting.
@
text
@d124 1
a124 1
            const WitTlDblStack & rawSplitList,
d188 1
a188 1
      WitTlDblStack splitList_;
d190 2
a191 1
         // The split list for the currently active split explosion.
@


1.3
log
@Continued development of coarse selection splitting.
@
text
@d136 1
a136 1
      virtual void adjustSplitVol (WitTl * theTlObj, double & splitVol) = 0;
d139 1
a139 1
         // Makes whatever adjustment to splitVol is appropriate for the 
d156 1
a156 1
      void prtSelSplitIA (WitTl * splitObj, double splitVol);
a188 2
      WitTl *       unbnddSplitObj_;
      double        unbnddSplitVol_;
d190 13
a202 2
         // The split list, unbounded split object, if any, and unbounded split
         // vol for the currently active split explosion.
@


1.2
log
@Further development of coarse selection splitting.
@
text
@d148 1
d173 4
@


1.1
log
@Implemented and used class SelMgr.
@
text
@d19 2
a20 1
#include <Assoc.h>
d76 4
d109 1
a109 1
      accessFunc (WitBoolean, hadFinSplit)
d123 23
a145 1
      void setHadFinSplit (WitBoolean);
d155 4
d169 17
a185 1
      WitBoolean hadFinSplit_;
d187 3
a189 2
         // TRUE, iff the current selection for this SelMgr had a finite
         // splitVol. FALSE, if not in sel-split mode.
@


head	1.25;
access;
symbols
	sce_5_01_20080919:1.21
	latest_sce_4_20_20060523:1.19.0.2
	sce_4_20_20060523:1.19
	latest_sce4_20_OSL:1.18.0.2
	sce_4_20_OSL:1.18
	sce_410_withVa:1.18
	sce_4_05_20040511:1.15
	sce_4_00_20040201:1.9
	nextGenBranch:1.8.0.2
	nextGenRoot:1.8
	sce_3_30_20030627:1.8
	EndRw-branch:1.4.0.4
	Root-of-EndRw:1.4
	rwToStl:1.4.0.2
	latest_sce_3_10_20010924:1.2.0.8
	sce_3_10_20010924:1.2
	latest_sce_3_00_20010601:1.2.0.6
	sce_3_00_20010601:1.2
	latest_sce_2_31_20010308:1.2.0.4
	sce_2_31_20010308:1.2
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2011.09.28.23.49.18;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2011.09.24.00.27.36;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2011.08.30.20.17.27;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.10.22.10.38;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.02.14.17.34;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.01.19.48.33;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.02.17.33.57;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.07.18.18.10;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.07.16.00.58;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.10.23.56.56;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.13.18.59.01;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.12.23.02.55;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.12.22.48.05;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.12.20.59.07;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.09.19.52.32;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.22.24.24;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.11.20.42.46;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.23.19.13.20;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.02.22.18.24;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.05.20.24.16;	author rwToStl;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.25.15.15.22;	author rwToStl;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.14.16.09.47;	author rjw;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.04.18.14.02.30;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.40;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.4.2.1
date	2002.11.08.16.11.34;	author rwToStl;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
//
//     Source file: WitEntit.C
//     Implementation of the following classes:
//
//        Entity
//           Attribute
//
//------------------------------------------------------------------------------

#include <defines.h>

// #if IMPLEMENT_READDATA

#include <Parlex.h>
#include <SymTable.h>
#include <VecBS.h>
#include <Entity.h>
#include <Parser.h>
#include <CompMgr.h>
#include <Operation.h>
#include <BomEntry.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
//
//     Implementation of class Entity
//
//------------------------------------------------------------------------------

extern WitParser::PS  commandState;   // defined in witParser.y

// Constructor and destructor

WitEntity::WitEntity (
         WitProblem * theProblem,
         const char * id,
         eType        type):

      argc_       (0),
      entityType_ (type),
      attrPtr_    (NULL),
      invalid_    (false),
      myProblem_  (theProblem)
   {
   entityID_ = new char[strlen (id) + 1];

   strcpy (entityID_, id);
   }

WitEntity::~WitEntity()
{ 
  WitDRParmType::Tag type;

  // delete all the strings that have been allocated
  // also, delete other composite objects
  for (int i = 0; i < argc_; i++) {
    type = argVector_[i].argType;

    switch (type) {
      case WitDRParmType::string:
        delete[] argVector_[i].argValue.sval;
        break;

      case WitDRParmType::boolVector:
      case WitDRParmType::intVector:
      case WitDRParmType::doubleVector:
         {
         delete argVector_[i].argValue.vval;

         break;
         }
  
      case WitDRParmType::boundSet:
        delete argVector_[i].argValue.bsval;
        break;

      default:                         
        break;
    };
  };

  delete[] entityID_;
}

// Operations

WitSymTabEntry *
WitEntity::lookupRule(WitSymTable *theSymTable, std::string theRule)
{
  WitSymTabEntry  *entryPtr = 0;

  // printf("Current rule is: %s\n", theRule);

  /* look up rule in hash dictionary */
  WitSymTable::WitSymTableDict::const_iterator it = theSymTable->theDictionary().find(theRule);
  if( it != theSymTable->theDictionary().end() )
    entryPtr = it->second;

  return entryPtr;
}

// Accessors

int WitEntity::argc() const
{ return argc_; }

WitEntity::eType WitEntity::entityType() const
{ return entityType_; }

const char * WitEntity::entityID() const
{ return entityID_; }

WitSymTabEntry *WitEntity::attrPtr() const
{ return attrPtr_; }

bool WitEntity::invalid() const
{ return invalid_; }

WitMsgFacility & WitEntity::myMsgFac () const
   {
   return myProblem ()->myMsgFac ();
   }

void WitEntity::setArgc(const int n)
{ argc_ = n; }

void WitEntity::setEntityType(const eType type)
{ entityType_ = type; }

void WitEntity::setEntityID(const char * const s)
{
  if (entityID_ != NULL)
    delete[] entityID_;
  entityID_ = new char[strlen(s)+1];  
  strcpy(entityID_, s);
}

void WitEntity::setAttrPtr(WitSymTabEntry * const pentry)
{ attrPtr_ = pentry; }
 
void WitEntity::setInvalid(bool flag)
{ invalid_ = flag; }

// get an argument value
int WitEntity::getIntArg(int index)
{
  return (argVector_[index].argValue.ival);
}

double WitEntity::getDoubleArg(int index)
{
  return argVector_[index].argValue.dval;
}

const char * WitEntity::getStringArg(int index)
{
  return (argVector_[index].argValue.sval);
}

bool WitEntity::getBoolArg(int index)
{
  return (argVector_[index].argValue.bval);
}

WitDRPartCat::Tag WitEntity::getCatArg(int index)
{
  return (argVector_[index].argValue.cval);
}

WitVectorSpec*  WitEntity::getVectorArg(int index)
{
  return (argVector_[index].argValue.vval);
}

WitBoundSetSpec*  WitEntity::getBoundSetArg(int index)
{
  return (argVector_[index].argValue.bsval);
}


// store the next argument value and set its type
WitEntity::argVecDef* WitEntity::setIntArg(int value)
{
  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL; 
  argVector_[argc_].argValue.ival = value;
  argVector_[argc_++].argType = WitDRParmType::intScalar;
  return &argVector_[argc_-1];
} 

WitEntity::argVecDef* WitEntity::setDoubleArg(double value)
{
  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  argVector_[argc_].argValue.dval = value;
  argVector_[argc_++].argType = WitDRParmType::doubleScalar;
  return &argVector_[argc_-1];
}

WitEntity::argVecDef*  WitEntity::setBoolArg(bool value)
{

  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  argVector_[argc_].argValue.bval = value;
  argVector_[argc_++].argType = WitDRParmType::boolScalar;
  return &argVector_[argc_-1];
}

WitEntity::argVecDef* WitEntity::setCatArg(WitDRPartCat::Tag value)
{

  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  argVector_[argc_].argValue.cval = value;
  argVector_[argc_++].argType = WitDRParmType::partCat;
  return &argVector_[argc_-1];
}

WitEntity::argVecDef* WitEntity::setStringArg(const char * value)
{
  char * s;

  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  s = new char[strlen(value)];
  strcpy(s, value+1);                   // get rid of leading quotes
  if (s[strlen(s)-1] == '\"')
    s[strlen(s)-1] = '\0';              // get rid of trailing quotes      
  argVector_[argc_].argValue.sval = s;
  argVector_[argc_++].argType = WitDRParmType::string;
  return &argVector_[argc_-1];
}

WitEntity::argVecDef*  WitEntity::setVectorArg(WitVectorSpec* vptr)
{
    // cout << "Argument: " << vptr->formatType() << endl;
    if (argc_ >= MAX_ARGS) return NULL;
    argVector_[argc_].argValue.vval = vptr;
    argVector_[argc_++].argType = vptr->dataType();
    return &argVector_[argc_-1];
}

WitEntity::argVecDef* WitEntity::setBoundSetArg(WitBoundSetSpec* bsptr)
{
  // cout << "Argument is a bound set " << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  argVector_[argc_].argValue.bsval = bsptr;
  argVector_[argc_++].argType = WitDRParmType::boundSet;
  return &argVector_[argc_-1];
}


// The following functions are used to obtain various values
// needed as arguments by the "set attribute" functions

const char * WitEntity::getPartName()
{
  switch (entityType_) {
    case part:
      return this->getStringArg(0);
    case bomEntry:
    case bopEntry:
      if (commandState == WitParser::PS_add)
        return this->getStringArg(1);
      else
        return NULL;
    case subEntry:
      if (commandState == WitParser::PS_add)
        return this->getStringArg(2);
      else
        return NULL;
    case demand:
      return this->getStringArg(0);
    case partWithOperation:
      if (commandState == WitParser::PS_add)
        return this->getStringArg(0);
      else
        return NULL;
    default:
      return NULL;
  }
}

const char * WitEntity::getDemandName()
{
  switch (entityType_) {
    case demand:
      return this->getStringArg(1);
    default:
      return NULL;
  }
}

const char * WitEntity::getOperationName()
{
  switch (entityType_) {
    case operation:
    case bomEntry:
    case subEntry:
    case bopEntry:
      return this->getStringArg(0);
    case partWithOperation:
      if (commandState == WitParser::PS_add)
        return this->getStringArg(0);
      else
        return NULL;
    default:
      return NULL;              
  }
}

int WitEntity::getBomEntryIndex()
{
  switch (entityType_) {
    case bomEntry:
      if (commandState == WitParser::PS_add)
        {
        WitOperation * theOpn;

        theOpn = myCompMgr ()->findOperation (getOperationName ());

        witAssert (theOpn != NULL);

        return theOpn->bom ().nElements () - 1;
        }
      else
        return this->getIntArg(1);
    case subEntry:
        return this->getIntArg(1);
    default:
      return 0;              
  }
}

int WitEntity::getSubEntryIndex()
{
  switch (entityType_) {
    case subEntry:
      if (commandState == WitParser::PS_add)
        {
        WitOperation * theOpn;
        WitBomEntry *  theBomEnt;

        theOpn = myCompMgr ()->findOperation (getOperationName ());

        witAssert (theOpn != NULL);

        theBomEnt = myCompMgr ()->findBomEntry (theOpn, getBomEntryIndex ());

        witAssert (theBomEnt != NULL);

        return theBomEnt->mySubEntries ().nElements () - 1;
        }
      else
        return this->getIntArg(2);
    default:
      return 0;
  }
}

int WitEntity::getBopEntryIndex()
{
  switch (entityType_) {
    case bopEntry:
      if (commandState == WitParser::PS_add)
        {
        WitOperation * theOpn;

        theOpn = myCompMgr ()->findOperation (getOperationName ());

        witAssert (theOpn != NULL);

        return theOpn->bop ().nElements () - 1;
        }
      else
        return this->getIntArg(1);
    default:
      return 0;
  }
}

// check entity arguments for validity
WitParseRC WitEntity::checkArgs(WitSymTabEntry * entryPtr)
{
  WitDRParmType::Tag aType;
  WitParseRC retcode = 0;
  int        n, np;

  // compare each argument type against types in symbol table entry
  np = entryPtr->nparms();                // number of params in table
  n = (argc_ < np) ? argc_ : np;          // number of args to be checked
  for (int i = 0; i < n; i++) {
    aType = argVector_[i].argType;        // the actual type 
    
    switch (entryPtr->parmTypes()[i]) {   // what it should be
      case WitDRParmType::intScalar:
        if (aType == WitDRParmType::intScalar) break;      // it matches
        prtInvalidMsg(i+1, "must be an integer");
        retcode = BAD_ARG;
        break;
      case WitDRParmType::doubleScalar:                      
        if (aType == WitDRParmType::doubleScalar) break;        // it matches
        if (aType == WitDRParmType::intScalar) {
          argVector_[i].argValue.dval = 
             static_cast <double> (argVector_[i].argValue.ival);
          argVector_[i].argType = WitDRParmType::doubleScalar;
          break;
        };
        prtInvalidMsg(i+1, "must be a double");
        retcode =  BAD_ARG;
        break;
      case WitDRParmType::string:
        if (aType == WitDRParmType::string) break;       // it matches
        prtInvalidMsg(i+1, "must be a string");
        retcode = BAD_ARG;
        break;
      case WitDRParmType::boolScalar:
        if (aType == WitDRParmType::boolScalar) break;      // it matches
        prtInvalidMsg(i+1, "must be a boolean");
        retcode = BAD_ARG;
        break;
      case WitDRParmType::partCat:
        if (aType == WitDRParmType::partCat) break;     // it matches
        prtInvalidMsg(i+1, "must be a \"category\"");
        retcode = BAD_ARG;
        break;

      case WitDRParmType::boolVector:
         {
         if (aType != WitDRParmType::boolVector)
            {
            prtInvalidMsg (i + 1, "must be a \"boolean vector\"");

            retcode = BAD_ARG;
            };

         break;
         }

      case WitDRParmType::intVector:
         {
         if (aType != WitDRParmType::intVector)
            {
            prtInvalidMsg (i + 1, "must be an \"integer vector\"");

            retcode = BAD_ARG;
            };

         break;  
         }

      case WitDRParmType::doubleVector:
        if (aType != WitDRParmType::doubleVector) {      // if it doesn't match	
          prtInvalidMsg(i+1, "must be a \"double vector\"");
          retcode = BAD_ARG;
        };
        break;

      case WitDRParmType::boundSet:
        if (aType == WitDRParmType::boundSet) break;       // it matches
        prtInvalidMsg(i+1, "must be a \"bound set\"");
        retcode = BAD_ARG;
        break;
      default:
        if (aType != entryPtr->parmTypes()[i]) {
          prtInvalidMsg(i+1, "is not of the proper type");
          retcode = BAD_ARG;
          break;
        };
    }   
  }

  // number of arguments must equal number of parameters
  if (argc_ != np)
    retcode = BAD_NUM_ARGS;

  return retcode;
}

// Print error message -- invalid entity argument or attribute value
void  WitEntity::prtInvalidMsg(int arg, const char * s)
{
  // Check whether we are parsing an entity or an attribute
  if (WitParser::instance ()->currentAttr() == NULL) {
    
    if (commandState == WitParser::PS_add)
      myMsgFac () ("invalidArgTypeMsg", arg, "add",
        WitParser::instance ()->currentEntity()->entityID(), s);
    else if (commandState == WitParser::PS_set)
      myMsgFac () ("invalidArgTypeMsg", arg, "set",
        WitParser::instance ()->currentEntity()->entityID(), s);
  }
  else
      myMsgFac () ("invalidValueTypeMsg",
        WitParser::instance ()->currentAttr()->attrID(), s);
  return;

}
//------------------------------------------------------------------------------
//
//     Implementation of class WitAttribute
//
//------------------------------------------------------------------------------

// Constructor and destructor

WitAttribute::WitAttribute (
         WitProblem * theProblem,
         const char * id,
         aType        type):

      WitEntity (theProblem, "unnamed"),

      attrType_ (type),
      attrPtr_  (NULL),
      invalid_  (false)
   {
   attrID_ = new char[strlen (id) + 1];

   strcpy (attrID_, id);
   }

WitAttribute::~WitAttribute()
{
  delete[] attrID_;
}


// Accessors

WitAttribute::aType WitAttribute::attrType() const
{ return attrType_; }

const char * WitAttribute::attrID() const
{ return attrID_; }

WitSymTabEntry *WitAttribute::attrPtr() const
{ return attrPtr_; }

bool WitAttribute::invalid() const
{ return invalid_; }

void WitAttribute::setAttrType(const aType type)
{ attrType_ = type; }

void WitAttribute::setAttrID(const char * const s)
{
  if (attrID_ != NULL)
    delete[] attrID_;
  attrID_ = new char[strlen(s)+1];
  strcpy(attrID_, s);
}

void WitAttribute::setAttrPtr(WitSymTabEntry * const pentry)
{ attrPtr_ = pentry; }

void WitAttribute::setInvalid(bool flag)
{ invalid_ = flag; }

// #endif
@


1.24
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.23
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d45 11
a55 11
WitProblem * theProblem,
const char * id,
eType        type):

argc_       (0),
entityType_ (type),
attrPtr_    (NULL),
invalid_    (false),
myProblem_  (theProblem)
{
entityID_ = new char[strlen (id) + 1];
d57 2
a58 2
strcpy (entityID_, id);
}
d61 2
a62 2
{
WitDRParmType::Tag type;
d64 27
a90 15
// delete all the strings that have been allocated
// also, delete other composite objects
for (int i = 0; i < argc_; i++) {
type = argVector_[i].argType;

switch (type) {
case WitDRParmType::string:
delete[] argVector_[i].argValue.sval;
break;

case WitDRParmType::boolVector:
case WitDRParmType::intVector:
case WitDRParmType::doubleVector:
{
delete argVector_[i].argValue.vval;
d92 1
a92 13
break;
}

case WitDRParmType::boundSet:
delete argVector_[i].argValue.bsval;
break;

default:
break;
};
};

delete[] entityID_;
d100 1
a100 1
WitSymTabEntry  *entryPtr = 0;
d102 1
a102 1
// printf("Current rule is: %s\n", theRule);
d104 4
a107 4
/* look up rule in hash dictionary */
WitSymTable::WitSymTableDict::const_iterator it = theSymTable->theDictionary().find(theRule);
if( it != theSymTable->theDictionary().end() )
entryPtr = it->second;
d109 1
a109 1
return entryPtr;
d130 3
a132 3
{
return myProblem ()->myMsgFac ();
}
d142 4
a145 4
if (entityID_ != NULL)
delete[] entityID_;
entityID_ = new char[strlen(s)+1];
strcpy(entityID_, s);
d150 1
a150 1

d157 1
a157 1
return (argVector_[index].argValue.ival);
d162 1
a162 1
return argVector_[index].argValue.dval;
d167 1
a167 1
return (argVector_[index].argValue.sval);
d172 1
a172 1
return (argVector_[index].argValue.bval);
d177 1
a177 1
return (argVector_[index].argValue.cval);
d182 1
a182 1
return (argVector_[index].argValue.vval);
d187 1
a187 1
return (argVector_[index].argValue.bsval);
d194 6
a199 6
// cout << "Argument: " << value << endl;
if (argc_ >= MAX_ARGS) return NULL;
argVector_[argc_].argValue.ival = value;
argVector_[argc_++].argType = WitDRParmType::intScalar;
return &argVector_[argc_-1];
}
d203 5
a207 5
// cout << "Argument: " << value << endl;
if (argc_ >= MAX_ARGS) return NULL;
argVector_[argc_].argValue.dval = value;
argVector_[argc_++].argType = WitDRParmType::doubleScalar;
return &argVector_[argc_-1];
d213 5
a217 5
// cout << "Argument: " << value << endl;
if (argc_ >= MAX_ARGS) return NULL;
argVector_[argc_].argValue.bval = value;
argVector_[argc_++].argType = WitDRParmType::boolScalar;
return &argVector_[argc_-1];
d223 5
a227 5
// cout << "Argument: " << value << endl;
if (argc_ >= MAX_ARGS) return NULL;
argVector_[argc_].argValue.cval = value;
argVector_[argc_++].argType = WitDRParmType::partCat;
return &argVector_[argc_-1];
d232 1
a232 1
char * s;
d234 9
a242 9
// cout << "Argument: " << value << endl;
if (argc_ >= MAX_ARGS) return NULL;
s = new char[strlen(value)];
strcpy(s, value+1);                   // get rid of leading quotes
if (s[strlen(s)-1] == '\"')
s[strlen(s)-1] = '\0';              // get rid of trailing quotes
argVector_[argc_].argValue.sval = s;
argVector_[argc_++].argType = WitDRParmType::string;
return &argVector_[argc_-1];
d247 5
a251 5
// cout << "Argument: " << vptr->formatType() << endl;
if (argc_ >= MAX_ARGS) return NULL;
argVector_[argc_].argValue.vval = vptr;
argVector_[argc_++].argType = vptr->dataType();
return &argVector_[argc_-1];
d256 5
a260 5
// cout << "Argument is a bound set " << endl;
if (argc_ >= MAX_ARGS) return NULL;
argVector_[argc_].argValue.bsval = bsptr;
argVector_[argc_++].argType = WitDRParmType::boundSet;
return &argVector_[argc_-1];
d269 24
a292 24
switch (entityType_) {
case part:
return this->getStringArg(0);
case bomEntry:
case bopEntry:
if (commandState == WitParser::PS_add)
return this->getStringArg(1);
else
return NULL;
case subEntry:
if (commandState == WitParser::PS_add)
return this->getStringArg(2);
else
return NULL;
case demand:
return this->getStringArg(0);
case partWithOperation:
if (commandState == WitParser::PS_add)
return this->getStringArg(0);
else
return NULL;
default:
return NULL;
}
d297 6
a302 6
switch (entityType_) {
case demand:
return this->getStringArg(1);
default:
return NULL;
}
d307 14
a320 14
switch (entityType_) {
case operation:
case bomEntry:
case subEntry:
case bopEntry:
return this->getStringArg(0);
case partWithOperation:
if (commandState == WitParser::PS_add)
return this->getStringArg(0);
else
return NULL;
default:
return NULL;
}
d325 19
a343 19
switch (entityType_) {
case bomEntry:
if (commandState == WitParser::PS_add)
{
WitOperation * theOpn;

theOpn = myCompMgr ()->findOperation (getOperationName ());

witAssert (theOpn != NULL);

return theOpn->bom ().nElements () - 1;
}
else
return this->getIntArg(1);
case subEntry:
return this->getIntArg(1);
default:
return 0;
}
d348 22
a369 22
switch (entityType_) {
case subEntry:
if (commandState == WitParser::PS_add)
{
WitOperation * theOpn;
WitBomEntry *  theBomEnt;

theOpn = myCompMgr ()->findOperation (getOperationName ());

witAssert (theOpn != NULL);

theBomEnt = myCompMgr ()->findBomEntry (theOpn, getBomEntryIndex ());

witAssert (theBomEnt != NULL);

return theBomEnt->mySubEntries ().nElements () - 1;
}
else
return this->getIntArg(2);
default:
return 0;
}
d374 17
a390 17
switch (entityType_) {
case bopEntry:
if (commandState == WitParser::PS_add)
{
WitOperation * theOpn;

theOpn = myCompMgr ()->findOperation (getOperationName ());

witAssert (theOpn != NULL);

return theOpn->bop ().nElements () - 1;
}
else
return this->getIntArg(1);
default:
return 0;
}
d396 91
a486 91
WitDRParmType::Tag aType;
WitParseRC retcode = 0;
int        n, np;

// compare each argument type against types in symbol table entry
np = entryPtr->nparms();                // number of params in table
n = (argc_ < np) ? argc_ : np;          // number of args to be checked
for (int i = 0; i < n; i++) {
aType = argVector_[i].argType;        // the actual type

switch (entryPtr->parmTypes()[i]) {   // what it should be
case WitDRParmType::intScalar:
if (aType == WitDRParmType::intScalar) break;      // it matches
prtInvalidMsg(i+1, "must be an integer");
retcode = BAD_ARG;
break;
case WitDRParmType::doubleScalar:
if (aType == WitDRParmType::doubleScalar) break;        // it matches
if (aType == WitDRParmType::intScalar) {
argVector_[i].argValue.dval =
static_cast <double> (argVector_[i].argValue.ival);
argVector_[i].argType = WitDRParmType::doubleScalar;
break;
};
prtInvalidMsg(i+1, "must be a double");
retcode =  BAD_ARG;
break;
case WitDRParmType::string:
if (aType == WitDRParmType::string) break;       // it matches
prtInvalidMsg(i+1, "must be a string");
retcode = BAD_ARG;
break;
case WitDRParmType::boolScalar:
if (aType == WitDRParmType::boolScalar) break;      // it matches
prtInvalidMsg(i+1, "must be a boolean");
retcode = BAD_ARG;
break;
case WitDRParmType::partCat:
if (aType == WitDRParmType::partCat) break;     // it matches
prtInvalidMsg(i+1, "must be a \"category\"");
retcode = BAD_ARG;
break;

case WitDRParmType::boolVector:
{
if (aType != WitDRParmType::boolVector)
{
prtInvalidMsg (i + 1, "must be a \"boolean vector\"");

retcode = BAD_ARG;
};

break;
}

case WitDRParmType::intVector:
{
if (aType != WitDRParmType::intVector)
{
prtInvalidMsg (i + 1, "must be an \"integer vector\"");

retcode = BAD_ARG;
};

break;
}

case WitDRParmType::doubleVector:
if (aType != WitDRParmType::doubleVector) {      // if it doesn't match
prtInvalidMsg(i+1, "must be a \"double vector\"");
retcode = BAD_ARG;
};
break;

case WitDRParmType::boundSet:
if (aType == WitDRParmType::boundSet) break;       // it matches
prtInvalidMsg(i+1, "must be a \"bound set\"");
retcode = BAD_ARG;
break;
default:
if (aType != entryPtr->parmTypes()[i]) {
prtInvalidMsg(i+1, "is not of the proper type");
retcode = BAD_ARG;
break;
};
}
}

// number of arguments must equal number of parameters
if (argc_ != np)
retcode = BAD_NUM_ARGS;
d488 1
a488 1
return retcode;
d494 14
a507 14
// Check whether we are parsing an entity or an attribute
if (WitParser::instance ()->currentAttr() == NULL) {

if (commandState == WitParser::PS_add)
myMsgFac () ("invalidArgTypeMsg", arg, "add",
WitParser::instance ()->currentEntity()->entityID(), s);
else if (commandState == WitParser::PS_set)
myMsgFac () ("invalidArgTypeMsg", arg, "set",
WitParser::instance ()->currentEntity()->entityID(), s);
}
else
myMsgFac () ("invalidValueTypeMsg",
WitParser::instance ()->currentAttr()->attrID(), s);
return;
d519 11
a529 5
WitProblem * theProblem,
const char * id,
aType        type):

WitEntity (theProblem, "unnamed"),
d531 2
a532 8
attrType_ (type),
attrPtr_  (NULL),
invalid_  (false)
{
attrID_ = new char[strlen (id) + 1];

strcpy (attrID_, id);
}
d536 1
a536 1
delete[] attrID_;
d559 4
a562 4
if (attrID_ != NULL)
delete[] attrID_;
attrID_ = new char[strlen(s)+1];
strcpy(attrID_, s);
@


1.22
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d45 11
a55 11
         WitProblem * theProblem,
         const char * id,
         eType        type):

      argc_       (0),
      entityType_ (type),
      attrPtr_    (NULL),
      invalid_    (false),
      myProblem_  (theProblem)
   {
   entityID_ = new char[strlen (id) + 1];
d57 2
a58 2
   strcpy (entityID_, id);
   }
d61 2
a62 2
{ 
  WitDRParmType::Tag type;
d64 15
a78 27
  // delete all the strings that have been allocated
  // also, delete other composite objects
  for (int i = 0; i < argc_; i++) {
    type = argVector_[i].argType;

    switch (type) {
      case WitDRParmType::string:
        delete[] argVector_[i].argValue.sval;
        break;

      case WitDRParmType::boolVector:
      case WitDRParmType::intVector:
      case WitDRParmType::doubleVector:
         {
         delete argVector_[i].argValue.vval;

         break;
         }
  
      case WitDRParmType::boundSet:
        delete argVector_[i].argValue.bsval;
        break;

      default:                         
        break;
    };
  };
d80 13
a92 1
  delete[] entityID_;
d100 1
a100 1
  WitSymTabEntry  *entryPtr = 0;
d102 1
a102 1
  // printf("Current rule is: %s\n", theRule);
d104 4
a107 4
  /* look up rule in hash dictionary */
  WitSymTable::WitSymTableDict::const_iterator it = theSymTable->theDictionary().find(theRule);
  if( it != theSymTable->theDictionary().end() )
    entryPtr = it->second;
d109 1
a109 1
  return entryPtr;
d130 3
a132 3
   {
   return myProblem ()->myMsgFac ();
   }
d142 4
a145 4
  if (entityID_ != NULL)
    delete[] entityID_;
  entityID_ = new char[strlen(s)+1];  
  strcpy(entityID_, s);
d150 1
a150 1
 
d157 1
a157 1
  return (argVector_[index].argValue.ival);
d162 1
a162 1
  return argVector_[index].argValue.dval;
d167 1
a167 1
  return (argVector_[index].argValue.sval);
d172 1
a172 1
  return (argVector_[index].argValue.bval);
d177 1
a177 1
  return (argVector_[index].argValue.cval);
d182 1
a182 1
  return (argVector_[index].argValue.vval);
d187 1
a187 1
  return (argVector_[index].argValue.bsval);
d194 6
a199 6
  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL; 
  argVector_[argc_].argValue.ival = value;
  argVector_[argc_++].argType = WitDRParmType::intScalar;
  return &argVector_[argc_-1];
} 
d203 5
a207 5
  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  argVector_[argc_].argValue.dval = value;
  argVector_[argc_++].argType = WitDRParmType::doubleScalar;
  return &argVector_[argc_-1];
d213 5
a217 5
  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  argVector_[argc_].argValue.bval = value;
  argVector_[argc_++].argType = WitDRParmType::boolScalar;
  return &argVector_[argc_-1];
d223 5
a227 5
  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  argVector_[argc_].argValue.cval = value;
  argVector_[argc_++].argType = WitDRParmType::partCat;
  return &argVector_[argc_-1];
d232 1
a232 1
  char * s;
d234 9
a242 9
  // cout << "Argument: " << value << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  s = new char[strlen(value)];
  strcpy(s, value+1);                   // get rid of leading quotes
  if (s[strlen(s)-1] == '\"')
    s[strlen(s)-1] = '\0';              // get rid of trailing quotes      
  argVector_[argc_].argValue.sval = s;
  argVector_[argc_++].argType = WitDRParmType::string;
  return &argVector_[argc_-1];
d247 5
a251 5
    // cout << "Argument: " << vptr->formatType() << endl;
    if (argc_ >= MAX_ARGS) return NULL;
    argVector_[argc_].argValue.vval = vptr;
    argVector_[argc_++].argType = vptr->dataType();
    return &argVector_[argc_-1];
d256 5
a260 5
  // cout << "Argument is a bound set " << endl;
  if (argc_ >= MAX_ARGS) return NULL;
  argVector_[argc_].argValue.bsval = bsptr;
  argVector_[argc_++].argType = WitDRParmType::boundSet;
  return &argVector_[argc_-1];
d269 24
a292 24
  switch (entityType_) {
    case part:
      return this->getStringArg(0);
    case bomEntry:
    case bopEntry:
      if (commandState == WitParser::PS_add)
        return this->getStringArg(1);
      else
        return NULL;
    case subEntry:
      if (commandState == WitParser::PS_add)
        return this->getStringArg(2);
      else
        return NULL;
    case demand:
      return this->getStringArg(0);
    case partWithOperation:
      if (commandState == WitParser::PS_add)
        return this->getStringArg(0);
      else
        return NULL;
    default:
      return NULL;
  }
d297 6
a302 6
  switch (entityType_) {
    case demand:
      return this->getStringArg(1);
    default:
      return NULL;
  }
d307 14
a320 14
  switch (entityType_) {
    case operation:
    case bomEntry:
    case subEntry:
    case bopEntry:
      return this->getStringArg(0);
    case partWithOperation:
      if (commandState == WitParser::PS_add)
        return this->getStringArg(0);
      else
        return NULL;
    default:
      return NULL;              
  }
d325 19
a343 19
  switch (entityType_) {
    case bomEntry:
      if (commandState == WitParser::PS_add)
        {
        WitOperation * theOpn;

        theOpn = myCompMgr ()->findOperation (getOperationName ());

        witAssert (theOpn != NULL);

        return theOpn->bom ().nElements () - 1;
        }
      else
        return this->getIntArg(1);
    case subEntry:
        return this->getIntArg(1);
    default:
      return 0;              
  }
d348 22
a369 22
  switch (entityType_) {
    case subEntry:
      if (commandState == WitParser::PS_add)
        {
        WitOperation * theOpn;
        WitBomEntry *  theBomEnt;

        theOpn = myCompMgr ()->findOperation (getOperationName ());

        witAssert (theOpn != NULL);

        theBomEnt = myCompMgr ()->findBomEntry (theOpn, getBomEntryIndex ());

        witAssert (theBomEnt != NULL);

        return theBomEnt->mySubEntries ().nElements () - 1;
        }
      else
        return this->getIntArg(2);
    default:
      return 0;
  }
d374 17
a390 17
  switch (entityType_) {
    case bopEntry:
      if (commandState == WitParser::PS_add)
        {
        WitOperation * theOpn;

        theOpn = myCompMgr ()->findOperation (getOperationName ());

        witAssert (theOpn != NULL);

        return theOpn->bop ().nElements () - 1;
        }
      else
        return this->getIntArg(1);
    default:
      return 0;
  }
d396 91
a486 91
  WitDRParmType::Tag aType;
  WitParseRC retcode = 0;
  int        n, np;

  // compare each argument type against types in symbol table entry
  np = entryPtr->nparms();                // number of params in table
  n = (argc_ < np) ? argc_ : np;          // number of args to be checked
  for (int i = 0; i < n; i++) {
    aType = argVector_[i].argType;        // the actual type 
    
    switch (entryPtr->parmTypes()[i]) {   // what it should be
      case WitDRParmType::intScalar:
        if (aType == WitDRParmType::intScalar) break;      // it matches
        prtInvalidMsg(i+1, "must be an integer");
        retcode = BAD_ARG;
        break;
      case WitDRParmType::doubleScalar:                      
        if (aType == WitDRParmType::doubleScalar) break;        // it matches
        if (aType == WitDRParmType::intScalar) {
          argVector_[i].argValue.dval = 
             static_cast <double> (argVector_[i].argValue.ival);
          argVector_[i].argType = WitDRParmType::doubleScalar;
          break;
        };
        prtInvalidMsg(i+1, "must be a double");
        retcode =  BAD_ARG;
        break;
      case WitDRParmType::string:
        if (aType == WitDRParmType::string) break;       // it matches
        prtInvalidMsg(i+1, "must be a string");
        retcode = BAD_ARG;
        break;
      case WitDRParmType::boolScalar:
        if (aType == WitDRParmType::boolScalar) break;      // it matches
        prtInvalidMsg(i+1, "must be a boolean");
        retcode = BAD_ARG;
        break;
      case WitDRParmType::partCat:
        if (aType == WitDRParmType::partCat) break;     // it matches
        prtInvalidMsg(i+1, "must be a \"category\"");
        retcode = BAD_ARG;
        break;

      case WitDRParmType::boolVector:
         {
         if (aType != WitDRParmType::boolVector)
            {
            prtInvalidMsg (i + 1, "must be a \"boolean vector\"");

            retcode = BAD_ARG;
            };

         break;
         }

      case WitDRParmType::intVector:
         {
         if (aType != WitDRParmType::intVector)
            {
            prtInvalidMsg (i + 1, "must be an \"integer vector\"");

            retcode = BAD_ARG;
            };

         break;  
         }

      case WitDRParmType::doubleVector:
        if (aType != WitDRParmType::doubleVector) {      // if it doesn't match	
          prtInvalidMsg(i+1, "must be a \"double vector\"");
          retcode = BAD_ARG;
        };
        break;

      case WitDRParmType::boundSet:
        if (aType == WitDRParmType::boundSet) break;       // it matches
        prtInvalidMsg(i+1, "must be a \"bound set\"");
        retcode = BAD_ARG;
        break;
      default:
        if (aType != entryPtr->parmTypes()[i]) {
          prtInvalidMsg(i+1, "is not of the proper type");
          retcode = BAD_ARG;
          break;
        };
    }   
  }

  // number of arguments must equal number of parameters
  if (argc_ != np)
    retcode = BAD_NUM_ARGS;
d488 1
a488 1
  return retcode;
d494 14
a507 14
  // Check whether we are parsing an entity or an attribute
  if (WitParser::instance ()->currentAttr() == NULL) {
    
    if (commandState == WitParser::PS_add)
      myMsgFac () ("invalidArgTypeMsg", arg, "add",
        WitParser::instance ()->currentEntity()->entityID(), s);
    else if (commandState == WitParser::PS_set)
      myMsgFac () ("invalidArgTypeMsg", arg, "set",
        WitParser::instance ()->currentEntity()->entityID(), s);
  }
  else
      myMsgFac () ("invalidValueTypeMsg",
        WitParser::instance ()->currentAttr()->attrID(), s);
  return;
d519 5
a523 11
         WitProblem * theProblem,
         const char * id,
         aType        type):

      WitEntity (theProblem, "unnamed"),

      attrType_ (type),
      attrPtr_  (NULL),
      invalid_  (false)
   {
   attrID_ = new char[strlen (id) + 1];
d525 8
a532 2
   strcpy (attrID_, id);
   }
d536 1
a536 1
  delete[] attrID_;
d559 4
a562 4
  if (attrID_ != NULL)
    delete[] attrID_;
  attrID_ = new char[strlen(s)+1];
  strcpy(attrID_, s);
@


1.21
log
@Removed some implicit conversions from string constant to char *.
@
text
@d30 1
a30 1
#include <Opn.h>
@


1.20
log
@Removed many instances of converting a string constant to a char *.
@
text
@d46 1
a46 1
         char *       id,
d120 1
a120 1
char *WitEntity::entityID() const
d140 1
a140 1
void WitEntity::setEntityID(char* const s)
d165 1
a165 1
char *WitEntity::getStringArg(int index)
d230 1
a230 1
WitEntity::argVecDef* WitEntity::setStringArg(char *value)
d232 1
a232 1
  char  *s;
d492 1
a492 1
void  WitEntity::prtInvalidMsg(int arg, char *s)
d518 5
a522 1
WitAttribute::WitAttribute (WitProblem * theProblem, char * id, aType type):
d545 1
a545 1
char *WitAttribute::attrID() const
d557 1
a557 1
void WitAttribute::setAttrID(char* const s)
@


1.19
log
@Updated the copyright date on all source files.
@
text
@a111 107

// Print the arguments of the invoked Wit API function
void WitEntity::printArgs(const char * const)
{
#if 0

  int           i, j;
  WitVectorSpec *vecPtr;

  cout << s;                           // print name of API function
  for (i = 0; i < argc_; i++)
    switch(argVector_[i].argType) {
      case WitDRParmType::intScalar:
        cout << argVector_[i].argValue.ival << " (integer) ";
        break;
      case WitDRParmType::doubleScalar:
        cout << argVector_[i].argValue.dval << " (double) ";
        break;
      case WitDRParmType::boolScalar:
        cout << (int)argVector_[i].argValue.bval << " (boolean) ";
        break;
      case WitDRParmType::string:
        cout << "\"" << argVector_[i].argValue.sval << "\"" << " (string) ";
        break;
      case WitDRParmType::partCat:
        cout << (int)argVector_[i].argValue.cval << " (category) ";
        break;

      case WitDRParmType::boolVector:
        stronglyAssert (false); // boolVector NYI
        break;

      case WitDRParmType::intVector:
        vecPtr = argVector_[i].argValue.vval;
        for (j = 0; j < vecPtr->nval(); j++)
          cout << vecPtr->getIntVal(j) << " ";
        cout << "(Integer Vector) ";
        if (vecPtr->formatType() == WitVectorSpec::sparse_) {
          cout << " Periods: ";
          for (j = 0; j < vecPtr->nval(); j++)
            cout << vecPtr->getPeriodVal(j) << " ";
        };
        break;

      case WitDRParmType::doubleVector:
        vecPtr = argVector_[i].argValue.vval;
        for (j = 0; j < vecPtr->nval(); j++)
          cout << vecPtr->getDoubleVal(j) << " ";
        cout << "(Double Vector) ";
        if (vecPtr->formatType() == WitVectorSpec::sparse_) {
          cout << " Periods: ";
          for (j = 0; j < vecPtr->nval(); j++)
            cout << vecPtr->getPeriodVal(j) << " ";
        };
        break;

      case WitDRParmType::boundSet:
        cout << "(bound set) ";

        vecPtr = argVector_[i].argValue.bsval->hardLBVec();
        if (vecPtr != NULL) {
          cout << "\n   (hardLB) ";
          for (j = 0; j < vecPtr->nval(); j++)
            cout << vecPtr->getDoubleVal(j) << " ";
          cout << "(Double Vector) ";
          if (vecPtr->formatType() == WitVectorSpec::sparse_) {
            cout << " Periods: ";
            for (j = 0; j < vecPtr->nval(); j++)
              cout << vecPtr->getPeriodVal(j) << " ";
          }
        };

        vecPtr = argVector_[i].argValue.bsval->softLBVec();
        if (vecPtr != NULL) {
          cout << "\n   (softLB) ";
          for (j = 0; j < vecPtr->nval(); j++)
            cout << vecPtr->getDoubleVal(j) << " ";
          cout << "(Double Vector) ";
          if (vecPtr->formatType() == WitVectorSpec::sparse_) {
            cout << " Periods: ";
            for (j = 0; j < vecPtr->nval(); j++)
              cout << vecPtr->getPeriodVal(j) << " ";
          }
        };

        vecPtr = argVector_[i].argValue.bsval->hardUBVec();
        if (vecPtr != NULL) {
          cout << "\n   (hardUB) ";
          for (j = 0; j < vecPtr->nval(); j++)
            cout << vecPtr->getDoubleVal(j) << " ";
          cout << "(Double Vector) ";
          if (vecPtr->formatType() == WitVectorSpec::sparse_) {
            cout << " Periods: ";
            for (j = 0; j < vecPtr->nval(); j++)
              cout << vecPtr->getPeriodVal(j) << " ";
          }
        };
        break;

      case WitDRParmType::undefined:
        break;  
    }                               // end of for loop
  cout << endl;

#endif
}

@


1.18
log
@[exceptions]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.17
log
@[exceptions]
@
text
@d28 1
a28 1
#include <witParse.h>
@


1.16
log
@Vector PropRt.
@
text
@a24 1
#include <witLexer.h>
@


1.15
log
@Double Precision.
@
text
@d75 1
d78 5
a82 2
        delete argVector_[i].argValue.vval;
        break;
d141 4
d546 13
d560 10
a569 5
        if (aType != WitDRParmType::intVector) {         // if it doesn't match
          prtInvalidMsg(i+1, "must be an \"integer vector\"");
          retcode = BAD_ARG;
        };
        break;  
@


1.14
log
@Double Precision.
@
text
@d125 1
a125 1
        cout << argVector_[i].argValue.fval << " (float) ";
d152 2
a153 2
          cout << vecPtr->getFloatVal(j) << " ";
        cout << "(Float Vector) ";
d168 2
a169 2
            cout << vecPtr->getFloatVal(j) << " ";
          cout << "(Float Vector) ";
d181 2
a182 2
            cout << vecPtr->getFloatVal(j) << " ";
          cout << "(Float Vector) ";
d194 2
a195 2
            cout << vecPtr->getFloatVal(j) << " ";
          cout << "(Float Vector) ";
d260 1
a260 1
double WitEntity::getFloatArg(int index)
d262 1
a262 1
  return argVector_[index].argValue.fval;
d301 1
a301 1
WitEntity::argVecDef* WitEntity::setFloatArg(double value)
d305 1
a305 1
  argVector_[argc_].argValue.fval = value;
d515 1
a515 1
          argVector_[i].argValue.fval = 
d520 1
a520 1
        prtInvalidMsg(i+1, "must be a float");
d547 1
a547 1
          prtInvalidMsg(i+1, "must be a \"float vector\"");
@


1.13
log
@Double Precision.
@
text
@d76 1
a76 1
      case WitDRParmType::floatVector:
d124 1
a124 1
      case WitDRParmType::floatScalar:
d149 1
a149 1
      case WitDRParmType::floatVector:
d306 1
a306 1
  argVector_[argc_++].argType = WitDRParmType::floatScalar;
d512 2
a513 2
      case WitDRParmType::floatScalar:                      
        if (aType == WitDRParmType::floatScalar) break;        // it matches
d517 1
a517 1
          argVector_[i].argType = WitDRParmType::floatScalar;
d545 2
a546 2
      case WitDRParmType::floatVector:
        if (aType != WitDRParmType::floatVector) {       // if it doesn't match	
@


1.12
log
@Double Precision.
@
text
@d63 1
a63 1
  pType type;
d71 1
a71 1
      case String:
d75 2
a76 2
      case IntVector:
      case FloatVector:
d80 1
a80 1
      case BoundSet:
d121 1
a121 1
      case Integer:
d124 1
a124 1
      case Float:
d127 1
a127 1
      case Boolean:
d130 1
a130 1
      case String:
d133 1
a133 1
      case Category:
d137 1
a137 1
      case IntVector:
d149 1
a149 1
      case FloatVector:
d161 1
a161 1
      case BoundSet:
d204 1
a204 1
      case Undefined:
d297 1
a297 1
  argVector_[argc_++].argType = Integer;
d306 1
a306 1
  argVector_[argc_++].argType = Float;
d316 1
a316 1
  argVector_[argc_++].argType = Boolean;
d326 1
a326 1
  argVector_[argc_++].argType = Category;
d341 1
a341 1
  argVector_[argc_++].argType = String;
d359 1
a359 1
  argVector_[argc_++].argType = BoundSet;
d496 1
a496 1
  pType      aType;
d507 2
a508 2
      case Integer:
        if (aType == Integer) break;      // it matches
d512 3
a514 3
      case Float:                      
        if (aType == Float) break;        // it matches
        if (aType == Integer) {
d517 1
a517 1
          argVector_[i].argType = Float;
d523 2
a524 2
      case String:
        if (aType == String) break;       // it matches
d528 2
a529 2
      case Boolean:
        if (aType == Boolean) break;      // it matches
d533 2
a534 2
      case Category:
        if (aType == Category) break;     // it matches
d538 2
a539 2
      case IntVector:
        if (aType != IntVector) {         // if it doesn't match
d545 2
a546 2
      case FloatVector:
        if (aType != FloatVector) {       // if it doesn't match	
d552 2
a553 2
      case BoundSet:
        if (aType == BoundSet) break;       // it matches
@


1.11
log
@Double Precision.
@
text
@d275 1
a275 1
category WitEntity::getCatArg(int index)
d320 1
a320 1
WitEntity::argVecDef* WitEntity::setCatArg(category value)
@


1.10
log
@Double Precision.
@
text
@a264 5
float WitEntity::getOldFloatArg (int index)
   {
   return fltFromDbl (getFloatArg (index));
   }

@


1.9
log
@Minor corrections.
@
text
@d260 1
a260 1
float WitEntity::getFloatArg(int index)
d262 1
a262 1
  return (argVector_[index].argValue.fval);
d265 5
d306 1
a306 1
WitEntity::argVecDef* WitEntity::setFloatArg(float value)
d521 1
a521 1
            argVector_[i].argValue.ival;  // coerse it to float
@


1.8
log
@Replaced some C style casts with C++ style casts.
@
text
@d367 1
a367 1
const char * const  WitEntity::getPartName()
d395 1
a395 1
const char * const  WitEntity::getDemandName()
d405 1
a405 1
const char * const  WitEntity::getOperationName()
@


1.7
log
@Internal changes.
@
text
@d104 1
a104 1
    entryPtr = (WitSymTabEntry *) it->second;
@


1.6
log
@Fixed bobo with WitEntity::lookupRule() that was returning non-NULL when the rule was not found
@
text
@d53 1
a53 1
      invalid_    (witFALSE),
d226 1
a226 1
WitBoolean WitEntity::invalid() const
d251 1
a251 1
void WitEntity::setInvalid(WitBoolean flag)
d270 1
a270 1
WitBoolean WitEntity::getBoolArg(int index)
d310 1
a310 1
WitEntity::argVecDef*  WitEntity::setBoolArg(WitBoolean value)
d605 1
a605 1
      invalid_  (witFALSE)
d629 1
a629 1
WitBoolean WitAttribute::invalid() const
d646 1
a646 1
void WitAttribute::setInvalid(WitBoolean flag)
@


1.5
log
@modications to change rogueWave tools.h++ to STL
@
text
@d97 1
a97 1
  WitSymTabEntry  *entryPtr;
d102 4
a105 2
  entryPtr =
     (WitSymTabEntry *) theSymTable->theDictionary().find(theRule)->second;
@


1.4
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d95 1
a95 1
  WitEntity::lookupRule(WitSymTable *theSymTable, RWCString theRule)
d97 1
a97 3

  RWCollectableString  *rulePtr;
  WitSymTabEntry       *entryPtr;
a101 1
  rulePtr = new RWCollectableString(theRule);
d103 1
a103 2
     (WitSymTabEntry *) theSymTable->theDictionary()->findValue(rulePtr);
  delete rulePtr;
@


1.4.2.1
log
@Migration from Roguewave tools.h++ to STL
@
text
@d95 1
a95 1
WitEntity::lookupRule(WitSymTable *theSymTable, std::string theRule)
d97 3
a99 1
  WitSymTabEntry  *entryPtr;
d104 1
d106 2
a107 1
     (WitSymTabEntry *) theSymTable->theDictionary().find(theRule)->second;
@


1.3
log
@Began implementation of object iteration.
@
text
@d72 1
a72 1
        delete argVector_[i].argValue.sval;
d89 1
a89 1
  delete entityID_;
d245 1
a245 1
    delete entityID_;
d616 1
a616 1
  delete attrID_;
d640 1
a640 1
    delete attrID_;
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d31 3
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

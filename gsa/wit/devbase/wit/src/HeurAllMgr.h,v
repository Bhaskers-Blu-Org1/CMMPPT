head	1.41;
access;
symbols
	sce_5_01_20080919:1.25
	latest_sce_4_20_20060523:1.20.0.2
	sce_4_20_20060523:1.20
	latest_sce4_20_OSL:1.19.0.2
	sce_4_20_OSL:1.19
	sce_410_withVa:1.17
	sce_4_05_20040511:1.14
	sce_4_00_20040201:1.13
	nextGenBranch:1.12.0.2
	nextGenRoot:1.12
	sce_3_30_20030627:1.12
	EndRw-branch:1.11.0.4
	Root-of-EndRw:1.11
	rwToStl:1.11.0.2
	latest_sce_3_10_20010924:1.8.0.2
	sce_3_10_20010924:1.8;
locks; strict;
comment	@ * @;


1.41
date	2011.09.28.23.49.24;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.24.00.27.43;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.08.30.20.17.32;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.24.18.17.21;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.24.15.46.14;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.24.00.16.25;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.22.20.21.52;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.13.21.13.19;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.10.23.22.43;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.10.23.17.46;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.10.20.12.07;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.10.16.03.49;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.07.23.50.33;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.02.18.58.24;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.01.20.25.24;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.17.22.04.44;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.08.19.16.39;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.28.20.04.57;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.27.19.59.31;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.10.00.08.14;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.08.22.47.34;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.02.17.34.00;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.30.22.50.00;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.03.21.20.29;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.02.17.26.53;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.31.23.59.29;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.24.22.21.30;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.15.23.22.31;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.02.22.18.28;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.12.20.09.38;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.11.22.48.27;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.05.19.31.32;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.21.22.36.30;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.06.17.31.07;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.03.18.40.41;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.14.55.30;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.30.15.12.09;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.28.00.48.34;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.27.21.28.38;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.25.16.08.15;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef HeurAllMgrH
#define HeurAllMgrH

//------------------------------------------------------------------------------
// Header file: "HeurAllMgr.h"
//
// Contains the declaration of class HeurAllMgr.
//------------------------------------------------------------------------------

#include <Assoc.h>

//------------------------------------------------------------------------------
// class HeurAllMgr
//
// This class provides the interface between heuristic allocation and the rest
// of WIT. An instance of this class exists of long as the Problem that owns it
// exists.
//
// Implemented in HeurAll.C.
//------------------------------------------------------------------------------

class WitHeurAllMgr: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitHeurAllMgr (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitHeurAllMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void setUpPegging ();
         //
         // Takes action appropriate for when myGlobalComp ()->perfPegging_
         // has just been set to true.

      void clearPegging ();
         //
         // Puts the pegging into its initial state.

      void shutDownPegging ();
         //
         // Takes action appropriate for when myGlobalComp ()->perfPegging_
         // has just been set to false.

      void start ();
         //
         // Begins heuristic allocation.

      void startForOpt ();
         //
         // Begins heuristic allocation for optimizing implosion.

      double incHeurAlloc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            double      desIncVol,
            bool        asapMultiExec);
         //
         // Increments the heuristic allocation.
         // Attempts to increase theDemand->shipVol ()[thePer] by as much as is
         // feasible up to desIncVol.
         // Issues an error if heuristic allocation is not active.
         // In two-way multi-exec mode, ASAP Multi-Exec will be used for
         // top-level JIT demand, iff asapMultiExec is true. When not in two-way
         // multi-exec mode, asapMultiExec must be false.

      void reset ();
         //
         // Terminates heuristic allocation.

      void finish ();
         //
         // Completes heuristic allocation.

      void printMeDir (bool asapMultiExec);
         //
         // Prints a multi-exec direction.

      void printPegging ();
         //
         // Prints the pegging.

      void printAvailSched ();
         //
         // Prints the availability schedule.

      bool modifiable ();
         //
         // Returns true, iff modifiable heuristic allocation is currently
         // active.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool, updatingSoln)

      inline bool active ()
         {
         return (myHeurAtor_ != NULL);
         }

      WitHeurModifier * myHeurModifier ();

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitHeurAllMgr);

      void start (bool forOpt);
         //
         // Begins heuristic allocation.
         // forOpt == true indicates heur allocation is for opt implosion.

      accessNonNull (WitHeurAtor *, myHeurAtor)

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitHeurAtor * myHeurAtor_;
         //
         // The HeurAtor that performs heuristic allocation for this HeurAllMgr,
         // if heuristic allocation is active; otherwise NULL.

      WitPegger * myPegger_;
         //
         // The Pegger owned by this HeurAllMgr, if
         // myGlobalComp ()->perfPegging_ is true; otherwise NULL.

      bool updatingSoln_;
         //
         // true, iff heuristic allocation is currently updating the implosion
         // solution.
   };

#endif
@


1.40
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.39
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d32 2
a33 2
{
public:
d35 130
a164 130
//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitHeurAllMgr (WitProblem * theProblem);
//
// ProbAssoc <<< theProblem.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitHeurAllMgr ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void setUpPegging ();
//
// Takes action appropriate for when myGlobalComp ()->perfPegging_
// has just been set to true.

void clearPegging ();
//
// Puts the pegging into its initial state.

void shutDownPegging ();
//
// Takes action appropriate for when myGlobalComp ()->perfPegging_
// has just been set to false.

void start ();
//
// Begins heuristic allocation.

void startForOpt ();
//
// Begins heuristic allocation for optimizing implosion.

double incHeurAlloc (
WitDemand * theDemand,
WitPeriod   thePer,
double      desIncVol,
bool        asapMultiExec);
//
// Increments the heuristic allocation.
// Attempts to increase theDemand->shipVol ()[thePer] by as much as is
// feasible up to desIncVol.
// Issues an error if heuristic allocation is not active.
// In two-way multi-exec mode, ASAP Multi-Exec will be used for
// top-level JIT demand, iff asapMultiExec is true. When not in two-way
// multi-exec mode, asapMultiExec must be false.

void reset ();
//
// Terminates heuristic allocation.

void finish ();
//
// Completes heuristic allocation.

void printMeDir (bool asapMultiExec);
//
// Prints a multi-exec direction.

void printPegging ();
//
// Prints the pegging.

void printAvailSched ();
//
// Prints the availability schedule.

bool modifiable ();
//
// Returns true, iff modifiable heuristic allocation is currently
// active.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (bool, updatingSoln)

inline bool active ()
{
return (myHeurAtor_ != NULL);
}

WitHeurModifier * myHeurModifier ();

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitHeurAllMgr);

void start (bool forOpt);
//
// Begins heuristic allocation.
// forOpt == true indicates heur allocation is for opt implosion.

accessNonNull (WitHeurAtor *, myHeurAtor)

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Other private member data.
//------------------------------------------------------------------------

WitHeurAtor * myHeurAtor_;
//
// The HeurAtor that performs heuristic allocation for this HeurAllMgr,
// if heuristic allocation is active; otherwise NULL.

WitPegger * myPegger_;
//
// The Pegger owned by this HeurAllMgr, if
// myGlobalComp ()->perfPegging_ is true; otherwise NULL.

bool updatingSoln_;
//
// true, iff heuristic allocation is currently updating the implosion
// solution.
};
@


1.38
log
@Modifiable heuristic allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d32 2
a33 2
   {
   public:
d35 130
a164 130
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitHeurAllMgr (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitHeurAllMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void setUpPegging ();
         //
         // Takes action appropriate for when myGlobalComp ()->perfPegging_
         // has just been set to true.

      void clearPegging ();
         //
         // Puts the pegging into its initial state.

      void shutDownPegging ();
         //
         // Takes action appropriate for when myGlobalComp ()->perfPegging_
         // has just been set to false.

      void start ();
         //
         // Begins heuristic allocation.

      void startForOpt ();
         //
         // Begins heuristic allocation for optimizing implosion.

      double incHeurAlloc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            double      desIncVol,
            bool        asapMultiExec);
         //
         // Increments the heuristic allocation.
         // Attempts to increase theDemand->shipVol ()[thePer] by as much as is
         // feasible up to desIncVol.
         // Issues an error if heuristic allocation is not active.
         // In two-way multi-exec mode, ASAP Multi-Exec will be used for
         // top-level JIT demand, iff asapMultiExec is true. When not in two-way
         // multi-exec mode, asapMultiExec must be false.

      void reset ();
         //
         // Terminates heuristic allocation.

      void finish ();
         //
         // Completes heuristic allocation.

      void printMeDir (bool asapMultiExec);
         //
         // Prints a multi-exec direction.

      void printPegging ();
         //
         // Prints the pegging.

      void printAvailSched ();
         //
         // Prints the availability schedule.

      bool modifiable ();
         //
         // Returns true, iff modifiable heuristic allocation is currently
         // active.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool, updatingSoln)

      inline bool active ()
         {
         return (myHeurAtor_ != NULL);
         }

      WitHeurModifier * myHeurModifier ();

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitHeurAllMgr);

      void start (bool forOpt);
         //
         // Begins heuristic allocation.
         // forOpt == true indicates heur allocation is for opt implosion.

      accessNonNull (WitHeurAtor *, myHeurAtor)

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitHeurAtor * myHeurAtor_;
         //
         // The HeurAtor that performs heuristic allocation for this HeurAllMgr,
         // if heuristic allocation is active; otherwise NULL.

      WitPegger * myPegger_;
         //
         // The Pegger owned by this HeurAllMgr, if
         // myGlobalComp ()->perfPegging_ is true; otherwise NULL.

      bool updatingSoln_;
         //
         // true, iff heuristic allocation is currently updating the implosion
         // solution.
   };
@


1.37
log
@Heuristic Adjustment
@
text
@d109 1
a109 1
      bool adjustMode ();
d111 2
a112 2
         // Returns true, iff heuristic allocation is currently in adjustment
         // mode.
d118 1
a118 1
      accessFunc    (bool,              updatingSoln)
d125 1
a125 1
      WitHeurAdjuster * myHeurAdjuster ();
@


1.36
log
@Heuristic Adjustment
@
text
@d109 1
a109 1
      bool heurAdjustActive ();
d111 2
a112 1
         // Returns true, iff heuristic adjustment is currently active.
@


1.35
log
@Heuristic Adjustment
@
text
@a88 8
      void adjustIncAvailVol (
            WitPart * thePart, 
            WitPeriod thePer, 
            double    deltaAvailVol);
         //
         // Adds deltaAvailVol to the incremental availability of thePart in
         // thePer for heuristic adjustment.

a118 2
      accessNonNull (WitHeurAdjuster *, myHeurAdjuster)

d124 2
a158 5
      WitHeurAdjuster * myHeurAdjuster_;
         //
         // The HeurAdjuster owned by this HeurAllMgr, if heuristic allocation
         // is active and heuristic adjustment is enabled; otherwise NULL.

@


1.34
log
@Heuristic Adjustment
@
text
@d117 4
d125 3
a127 1
      accessFunc (bool, updatingSoln)
d160 1
a160 2
         // if any; otherwise NULL.
         // Heuristic allocation is active, iff myHeurAtor is not NULL.
d167 5
@


1.33
log
@Heuristic Adjustment
@
text
@d113 4
@


1.32
log
@Heuristic Adjustment
@
text
@a88 4
      void updateForAdjust ();
         //
         // Updates heuristic allocation for a heuristic adjustment.

@


1.31
log
@Heuristic Adjustment
@
text
@d96 1
a96 1
            double    deltaVol);
d98 2
a99 2
         // Adds deltaVol to the incremental availability of thePart in thePer
         // for heuristic adjustment.
@


1.30
log
@Heuristic Adjustment
@
text
@d93 7
a99 8
      void adjustForShipVol (
            WitDemand * theDemand,
            WitPeriod   shipPer,
            double      deltaShipVol);
         //
         // Adjusts the state of heuristic allocation for a change to
         // theDemand->shipVol ()[shipPer] of deltaShipVol, which may be
         // positive or negative.
@


1.29
log
@Heuristic Adjustment
@
text
@d93 9
@


1.28
log
@Pause/Resume
@
text
@d89 4
@


1.27
log
@Pause / Resume
@
text
@d27 2
a115 4
      bool paused ();
         //
         // Returns true, iff heuristic allocation is currently paused.

@


1.26
log
@Lead Time Bounds
@
text
@a47 9
      // Data access functions.
      //------------------------------------------------------------------------

      inline bool active ()
         {
         return (myHeurAtor_ != NULL);
         }

      //------------------------------------------------------------------------
d109 9
@


1.25
log
@Stochastic Implosion
@
text
@d82 1
a82 1
      double inc (
@


1.24
log
@[disallowed backlog]
@
text
@d112 6
d151 5
@


1.23
log
@Rescinded all changed made since 1/31/07.
@
text
@a111 20
      //------------------------------------------------------------------------
      // Functions for receiving data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      //------------------------------------------------------------------------

      static void receiveDMPs (
         WitDblFlexVec                        WitDemand::* shipVolArg,
         WitPtrTVec <WitObjStack <WitPegEl> > WitDemand::* myPegElsForArg);

      static void receiveDMPs (
         WitDblFlexVec                     WitOperation::* execVolArg);

      static void receiveDMPs (
         WitDblFlexVec                      WitSubEntry::* subVolArg);

      static void receiveDMPs (
         WitList <WitPartPer>             WitGlobalComp::* criticalListArg,
         WitList <WitPclEl>               WitGlobalComp::* pgdCritListArg);

@


1.22
log
@[disallowed backlog]
@
text
@d123 6
@


1.21
log
@[disallowed backlog]
@
text
@a122 3
         WitDblFlexVec                      WitSubEntry::* subVolArg);

      static void receiveDMPs (
@


1.20
log
@Updated the copyright date on all source files.
@
text
@a122 3
         WitDblFlexVec                     WitOperation::* execVolArg);

      static void receiveDMPs (
@


1.19
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.18
log
@[multi-thread]
@
text
@a112 8
      // Data loading functions.
      //------------------------------------------------------------------------

      void loadPegDataFrom (
            WitDemand *                                  theDemand,
            const WitPtrTVec <WitObjStack <WitPegEl> > & thePegElStPtrTVec);

      //------------------------------------------------------------------------
d119 2
a120 1
         WitDblFlexVec            WitDemand::* shipVolArg);
d123 1
a123 1
         WitDblFlexVec         WitOperation::* execVolArg);
d126 1
a126 1
         WitDblFlexVec          WitSubEntry::* subVolArg);
d129 2
a130 2
         WitList <WitPartPer> WitGlobalComp::* criticalListArg,
         WitList <WitPclEl>   WitGlobalComp::* pgdCritListArg);
@


1.17
log
@pegged Critical List.
@
text
@a19 2
#include <RefMap.h>
#include <Ref.h>
a115 4
      void loadDataFrom (
            WitDemand *     theDemand,
            WitDblFlexVec & shipVolArg);

d120 18
a137 11
      void loadDataFrom (
            WitOperation *  theOpn,
            WitDblFlexVec & execVolArg);

      void loadDataFrom (
            WitSubEntry *   theSub,
            WitDblFlexVec & subVolArg);

      void loadDataFromGlobalComp (
            WitList <WitPartPer> & criticalListArg,
            WitList <WitPclEl> &   pgdCritListArg);
a151 8
      void loadData ();
         //
         // Loads the data to be loaded from the components.

      void clearLoadedData ();
         //
         // Clears the data that was loaded from the components.

a158 11
      // Mappings to data loaded in from Components.
      //------------------------------------------------------------------------

      WitRefMap <WitDemand,    WitDblFlexVec> shipVol_;
      WitRefMap <WitOperation, WitDblFlexVec> execVol_;
      WitRefMap <WitSubEntry,  WitDblFlexVec> subVol_;

      WitRef    <WitList <WitPartPer> >       criticalList_;
      WitRef    <WitList <WitPclEl> >         pgdCritList_;

      //------------------------------------------------------------------------
@


1.16
log
@Pegged Critical List
@
text
@a75 10
      void setUpPcl ();
         //
         // Takes action appropriate for when myGlobalComp ()->compPdgCritList_
         // has just been set to true.

      void shutDownPcl ();
         //
         // Takes action appropriate for when myGlobalComp ()->compPdgCritList_
         // has just been set to false.

d135 2
a136 7
            WitList <WitPartPer> & criticalListArg);

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------
                                  
      accessNonNull (WitPclMgr *, myPclMgr)
d173 2
a174 1
      WitRef    <WitList <WitPartPer> >              criticalList_;
a189 5

      WitPclMgr * myPclMgr_;
         //
         // The PclMgr owned by this HeurAllMgr, if
         // myGlobalComp ()->pgdCritListNeeded_ is true; otherwise NULL.
@


1.15
log
@Pegged Critical List.
@
text
@d208 1
a208 1
         // myGlobalComp ()->compPgdCritList_ is true; otherwise NULL.
@


1.14
log
@Double Precision.
@
text
@d76 10
d147 6
d196 3
a198 1
         // The HeurAtor that performs heuristic allocation for this HeurAllMgr.
d202 7
a208 2
         // The Pegger owned by this HeurAtor, if myGlobalComp ()->perfPegging_
         // is true; otherwise NULL.
@


1.13
log
@Continued implementation of PIP.
@
text
@d119 2
a120 2
            WitDemand *           theDemand,
            WitFlexVec <double> & shipVolArg);
d127 2
a128 2
            WitOperation *        theOpn,
            WitFlexVec <double> & execVolArg);
d131 2
a132 2
            WitSubEntry *         theSub,
            WitFlexVec <double> & subVolArg);
d168 3
a170 3
      WitRefMap <WitDemand,    WitFlexVec <double> > shipVol_;
      WitRefMap <WitOperation, WitFlexVec <double> > execVol_;
      WitRefMap <WitSubEntry,  WitFlexVec <double> > subVol_;
@


1.12
log
@Internal changes.
@
text
@d135 1
a135 1
            WitList <WitDatedPart> & criticalListArg);
d172 1
a172 1
      WitRef    <WitList <WitDatedPart> >            criticalList_;
@


1.11
log
@Continued implementation of Single-Source.
@
text
@d53 1
a53 1
      inline WitBoolean active ()
d65 1
a65 1
         // has just been set to TRUE.
d74 1
a74 1
         // has just been set to FALSE.
d88 1
a88 1
            WitBoolean  asapMultiExec);
d95 2
a96 2
         // top-level JIT demand, iff asapMultiExec is TRUE. When not in two-way
         // multi-exec mode, asapMultiExec must be FALSE.
d106 1
a106 1
      void printMeDir (WitBoolean asapMultiExec);
d145 1
a145 1
      void start (WitBoolean forOpt);
d148 1
a148 1
         // forOpt == TRUE indicates heur allocation is for opt implosion.
d185 1
a185 1
         // is TRUE; otherwise NULL.
@


1.10
log
@Continued implementation of Single-Source.
@
text
@d123 2
a124 2
            WitDemand *           theDemand,
            WitPegSite *          thePegSite);
@


1.9
log
@Continued implementation of single-source.
@
text
@d122 4
d182 1
a182 1
      WitPegMgr * myPegMgr_;
d184 1
a184 1
         // The PegMgr owned by this HeurAtor, if myGlobalComp ()->perfPegging_
@


1.8
log
@Moved pegging output to comprehensive implosion solution output.
Fixed bug: Pegging was being attempted during stock bounds enforcement.
@
text
@d20 2
a57 2
      accessFunc (const WitAccFlag *, myAccFlag)

d114 19
d146 10
d160 14
a176 4

      WitAccFlag * const myAccFlag_;
         //
         // The AccFlag for this HeurAllMgr.
@


1.7
log
@Minor change.
@
text
@d110 4
@


1.6
log
@Continued implementation of pegging.
@
text
@d64 1
a64 1
         // Takes action appropriate for when myGlobalComp ()->peggingNeeded_
d73 1
a73 1
         // Takes action appropriate for when myGlobalComp ()->peggingNeeded_
d137 2
a138 2
         // The PegMgr owned by this HeurAtor, if 
         // myGlobalComp ()->peggingNeeded_ is TRUE; otherwise NULL.
@


1.5
log
@Continued implementation of pegging.
@
text
@d64 2
a65 2
         // Takes action appropriate for when myGlobalComp ()->pegging_ has just
         // been set to TRUE.
d73 2
a74 2
         // Takes action appropriate for when myGlobalComp ()->pegging_ has just
         // been set to FALSE.
d137 2
a138 2
         // The PegMgr owned by this HeurAtor, if myGlobalComp ()->pegging_ is
         // TRUE; otherwise NULL.
@


1.4
log
@Continued implementation of pegging.
@
text
@d62 1
a62 1
      void startUpPegging ();
a97 6
      void setUpPeggedIncAlloc (WitObjStack <WitOpnPegEl> & thePegEls);
      void setUpPeggedIncAlloc (WitObjStack <WitSubPegEl> & thePegEls);
         //
         // Each of these functions sets up pegging for an incHeurAlloc by
         // updating thePegEls.

d135 1
a135 2
      WitPegMgr <WitOperation> * myOpnPegMgr_;
      WitPegMgr <WitSubEntry>  * mySubPegMgr_;
d137 1
a137 1
         // The PegMgrs owned by this HeurAtor, if myGlobalComp ()->pegging_ is
@


1.3
log
@Continued implementation of pegging.
@
text
@d64 2
a65 2
         // Takes action appropriate for when myGlobalComp ()->perfPegging_ has
         // just been set to TRUE.
d73 2
a74 2
         // Takes action appropriate for when myGlobalComp ()->perfPegging_ has
         // just been set to FALSE.
d144 2
a145 2
         // The PegMgrs owned by this HeurAtor, if myGlobalComp ()->perfPegging_
         // is TRUE; otherwise NULL.
@


1.2
log
@Continued implementation of pegging.
@
text
@d64 1
a64 1
         // Takes action appropriate for when myGlobalComp ()->doPegging_ has
d73 1
a73 1
         // Takes action appropriate for when myGlobalComp ()->doPegging_ has
d144 1
a144 1
         // The PegMgrs owned by this HeurAtor, if myGlobalComp ()->doPegging_
@


1.1
log
@Initial implementation of pegging.
@
text
@d56 1
a56 3
      accessFunc    (const WitAccFlag *, myAccFlag)

      accessNonNull (WitPegMgr *,        myPegMgr)
d67 4
d98 6
d141 2
a142 1
      WitPegMgr * myPegMgr_;
d144 1
a144 1
         // The PegMgr owned by this HeurAtor, if myGlobalComp ()->doPegging_
@


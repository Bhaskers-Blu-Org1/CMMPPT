head	1.88;
access;
symbols
	sce_5_01_20080919:1.82
	latest_sce_4_20_20060523:1.76.0.2
	sce_4_20_20060523:1.76
	latest_sce4_20_OSL:1.75.0.2
	sce_4_20_OSL:1.75
	sce_410_withVa:1.73
	sce_4_05_20040511:1.43
	sce_4_00_20040201:1.43
	nextGenBranch:1.43.0.2
	nextGenRoot:1.43
	sce_3_30_20030627:1.43
	EndRw-branch:1.36.0.4
	Root-of-EndRw:1.36
	rwToStl:1.36.0.2
	latest_sce_3_10_20010924:1.16.0.2
	sce_3_10_20010924:1.16
	latest_sce_3_00_20010601:1.3.0.2
	sce_3_00_20010601:1.3;
locks; strict;
comment	@ * @;


1.88
date	2011.09.28.23.50.10;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2011.09.24.00.28.36;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2011.08.30.20.18.10;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.29.23.25.15;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.29.22.32.32;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2010.03.16.22.42.28;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.08.01.21.28.05;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.07.10.15.57.23;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2006.09.27.20.10.17;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2006.09.26.19.11.47;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.26.21.14.30;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.26.20.40.10;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.02.17.34.12;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2006.02.03.16.48.13;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2005.12.05.22.24.09;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2005.03.28.20.14.38;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.03.21.31.35;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.02.17.26.53;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2005.01.31.23.59.30;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.01.27.23.13.45;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.01.19.23.50.58;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.01.17.23.43.10;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2005.01.14.16.20.05;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2005.01.13.17.24.21;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2005.01.12.22.48.38;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.11.21.07.58;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.01.07.19.22.17;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2005.01.06.20.34.10;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2005.01.05.19.32.45;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2005.01.04.20.09.36;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.01.01.00.43.14;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.12.31.18.28.28;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.12.28.19.21.19;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.12.23.20.30.08;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.12.23.17.24.20;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.12.22.19.57.26;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.12.21.22.13.49;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.12.17.21.53.01;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.12.16.23.35.17;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.16.21.22.13;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.15.23.50.11;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.15.20.20.51;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.14.22.37.11;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.13.21.25.17;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.09.21.34.12;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.29.14.27.50;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.18.20.30.58;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.04.11.19.08.29;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.07.21.34.18;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.14.20.13.01;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.02.23.40.49;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.02.22.18.47;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.02.19.04.13;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.07.20.15.04;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.18.14.02.43;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.15.21.21.37;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.12.21.02.03;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.11.17.57.03;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.09.16.05.53;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.05.20.43.58;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.02.19.20.37;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.29.23.47.11;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.12.18.01.08;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.08.21.18.00;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.26.15.17.18;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.20.22.28.07;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.09.00.43.49;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.07.16.57.29;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.11.19.17.28;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.10.22.06.58;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.20.00.00.18;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.17.16.25.42;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.28.19.19.01;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.27.21.12.13;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.24.22.03.23;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.23.21.13.55;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.21.17.31.46;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.20.15.16.35;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.17.22.00.12;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.14.20.43.55;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.25.16.08.19;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.20.49.20;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.20.20.07.06;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.13.20.30.24;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.01.19.23.35;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.30.21.16.49;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.25.22.59.14;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.14.53.27;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.88
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "SelSplit.C"
//
// Contains the implementation of the following classes:
//
//    Splitter
//    SplitPt
//    SelCand
//    FlowMonitor
//    SplitCntr
//------------------------------------------------------------------------------

#include <SplitCntr.h>
#include <SplitPt.h>
#include <FlowMon.h>
#include <Splitter.h>
#include <Selector.h>
#include <SelMgr.h>
#include <SelPt.h>
#include <AltPt.h>
#include <SelCand.h>
#include <RtCand.h>
#include <PenExMgr.h>
#include <MrMgr.h>
#include <HeurAtor.h>
#include <BopEntry.h>
#include <Part.h>
#include <GlobalComp.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class Splitter.
//------------------------------------------------------------------------------

WitSplitter::WitSplitter (WitSelector * theSelector):

      WitProbAssoc     (theSelector),
      mySelector_      (theSelector),
      myFlowMonitor_   (NULL),
      mySplitCntr_     (NULL),
      myPenExMgr_      (NULL),
      penExec_         (false),
      splitRes_        (myGlobalComp ()->splitRes ()),
      zeroPts_         (myProblem ()),
      splitCommActive_ (false),
      mySplitPts_      (myProblem ())
   {
   WitDemand * theDemand;
   WitSelMgr * theSelMgr;

   myMsgFac () ("selSplitMsg");

   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("critListSelSplitSmsg");

   if (myGlobalComp ()->pgdCritListMode ())
      myMsgFac () ("pgdCritListSelSplitSmsg");

   forEachDemand (theDemand, myProblem ())
      if (theDemand->searchInc () != 1.0)
         myMsgFac () ("searchIncSelSplitSmsg",
            theDemand->demandedPartName (),
            theDemand->demandName (),
            theDemand->searchInc ());

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->setUpSelSplit ();

   myFlowMonitor_ = new WitFlowMonitor (mySelector_->myHeurAtor ());

   mySplitCntr_   = new WitSplitCntr (mySelector_);

   penExec_       = mySelector_->penExec ();

   if (penExec_)
      myPenExMgr_ = theSelector->myPenExMgr ();
   }

//------------------------------------------------------------------------------

WitSplitter::~WitSplitter ()
   {
   delete mySplitCntr_;
   delete myFlowMonitor_;
   }

//------------------------------------------------------------------------------

void WitSplitter::commitMaxQty (double & netQty)
   {
   bool scNeeded;
   bool unresFound;

   while (true)
      {
      mySelector_->prepCmqSel ();

      myFlowMonitor_->activate ();

      mySelector_->myHeurAtor ()->commitMaxQtySel (netQty);

      if ((netQty <= 0.0) or not resAltOrRest ())
         {
         myFlowMonitor_->deactivate ();

         break;
         }

      scNeeded = splitCommitNeeded ();
      
      myFlowMonitor_->deactivate ();

      if (scNeeded)
         if (not mySelector_->myHeurAtor ()->failedOn1 ())
            if (mySelector_->myHeurAtor ()->tempCommit (1.0))
               scNeeded = false;

      if (scNeeded)
         {
         splitCommit (unresFound);

         if (unresFound)
            break;
         }
      else
         {
         if (penExec_)
            myPenExMgr ()->updatePsSup ();

         mySelector_->alterSelSS ();
         }
      }

   if (penExec_)
      myPenExMgr ()->updatePsSup ();
   }

//------------------------------------------------------------------------------

void WitSplitter::preCommit ()
   {
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theSplitPt;

   mySplitPts_.attachItr (theItr);

   while (theItr.advance (theSplitPt))
      theSplitPt->initNetSplitList ();
   }

//------------------------------------------------------------------------------

void WitSplitter::postTempCommit (bool success)
   {
   myFlowMonitor_->postTempCommit (success);
   }

//------------------------------------------------------------------------------

WitSelMgr * WitSplitter::lowestBddSelMgr ()
   {
   WitSelMgr * lbSelMgr;
   WitSelMgr * theSelMgr;

   lbSelMgr = NULL;

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      if (theSelMgr->boundedSplit ())
         lbSelMgr = theSelMgr;

   return lbSelMgr;
   }

//------------------------------------------------------------------------------

void WitSplitter::recordFlow (WitSelPt * theSelPt, double incFlowVol)
   {
   myFlowMonitor_->recordFlow (theSelPt, incFlowVol);
   }

//------------------------------------------------------------------------------

bool WitSplitter::splitCommitNeeded ()
   {
   WitSelPt * theSelPt;
   double     flowGap;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      if (myFlowMonitor_->splitIsNeeded (theSelPt, true, flowGap))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitSplitter::splitCommit (bool & unresFound)
   {
   int         nItrs;
   bool        tcOK;
   bool        splitFound;
   WitSelMgr * theSelMgr;

   splitCommActive_ = true;
   unresFound       = false;
   nItrs            = 0;
   tcOK             = false;

   mySplitCntr_->initCurSplits ();

   while (not tcOK)
      {
      nItrs ++;

      if (nItrs > myGlobalComp ()->splitItrUB ())
         break;

      buildZeroPts (unresFound, splitFound);

      if (unresFound)
         break;

      if (splitFound)
         splitSels ();

      clearSplitItr ();

      stronglyAssert (resAltOrRest ());

      mySelector_->alterSelSS ();

      if (penExec_)
         {
         myPenExMgr ()->updatePsSup   ();
         myPenExMgr ()->modifyRouting ();
         }

      tcOK = mySelector_->myHeurAtor ()->tempCommit (1.0);
      }

   if (tcOK)
      mySelector_->myHeurAtor ()->permCommit1SS ();

   if (selPrintLevelAt (1))
      mySplitCntr_->countSplits (tcOK);

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->postSplitCommit ();

   deleteContents (mySplitPts_);

   splitCommActive_ = false;
   }

//------------------------------------------------------------------------------

void WitSplitter::buildZeroPts (bool & unresFound, bool & splitFound)
   {
   bool addedZeroPts;

   stronglyAssert (zeroPts_.isEmpty ());

   unresFound = false;
   splitFound = false;

   while (not splitFound)
      {
      unresFound = not resAltOrRest ();

      if (unresFound)
         {
         clearSplitItr ();

         return;
         }

      addedZeroPts = addChgPtsToZeroPts ();

      if (not addedZeroPts)
         return;

      splitFound = tempCommDiscZeroPts ();
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::clearSplitItr ()
   {
   WitObjStack <WitSplitPt> revSplitPts (myProblem ());
   WitSplitPt *             theSplitPt;

   zeroPts_.clear ();

   revSplitPts.revCopyFrom (mySplitPts_);

   mySplitPts_.clear ();

   while (revSplitPts.pop (theSplitPt))
      if (theSplitPt->hasSplits ())
         mySplitPts_.push (theSplitPt);
      else
         delete theSplitPt;
   }

//------------------------------------------------------------------------------

bool WitSplitter::addChgPtsToZeroPts ()
   {
   bool       addedZeroPts;
   WitSelPt * theSelPt;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   addedZeroPts = false;

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      {
      if (not theSelPt->isSplit ())
         mySplitPts_.push (new WitSplitPt (this, theSelPt));

      else if (zeroPts_.contains (theSelPt->mySplitPt ()))
         continue;

      zeroPts_.push (theSelPt->mySplitPt ());

      addedZeroPts = true;
      }

   return addedZeroPts;
   }

//------------------------------------------------------------------------------

void WitSplitter::splitSels ()
   {
   bool         success;
   WitSplitPt * searchPt;
   bool         splitNeeded;
   double       flowGap;

   myFlowMonitor_->activate ();

   success = true;

   while (success)
      {
      stronglyAssert (zeroPts_.isNonEmpty ());

      searchPt = findLowestZeroPt ();

      zeroPts_.remove (searchPt);

      success = tempCommDiscZeroPts ();
      }

   splitNeeded =
      myFlowMonitor_->splitIsNeeded (searchPt->mySelPt (), false, flowGap);

   if (splitNeeded)
      searchForFlow (searchPt, flowGap);

   if (resAltOrRest ())
      splitChgPts ();
   else
      {
      success = mySelector_->myHeurAtor ()->tempCommit (1.0);

      stronglyAssert (not success);
      }

   myFlowMonitor_->deactivate ();
   }

//------------------------------------------------------------------------------

bool WitSplitter::resAltOrRest ()
   {
   if (mySelector_->failResAlt ())
      return true;

   else if (penExec_)
      return myPenExMgr ()->failRestShortOnly ();

   else
      return false;
   }

//------------------------------------------------------------------------------

WitSplitPt * WitSplitter::findLowestZeroPt ()
   {
   WitSplitPt * lowZeroPt;
   WitSplitPt * theZeroPt;

   WitObjStItr <WitSplitPt> theItr;

   stronglyAssert (zeroPts_.isNonEmpty ());

   zeroPts_.attachItr (theItr);

   theItr.advance (lowZeroPt);

   while (theItr.advance (theZeroPt))
      if (theZeroPt->isLowerThan (lowZeroPt))
         lowZeroPt = theZeroPt;

   return lowZeroPt;
   }

//------------------------------------------------------------------------------

void WitSplitter::searchForFlow (WitSplitPt * searchPt, double theFlowVol)
   {
   bool success;
   int  upperGP;
   int  lowerGP;
   int  midGP;

   success = tempCommForSearch (searchPt, splitRes_);

   mySplitCntr_->countBS (success);

   if (not success)
      return;

   lowerGP = 1;
   upperGP = static_cast <int> (ceil (theFlowVol / splitRes_));

   stronglyAssert (upperGP >= 2);

   while (upperGP - lowerGP > 1)
      {
      midGP   = (lowerGP + upperGP) / 2;

      success = tempCommForSearch (searchPt, midGP * splitRes_);

      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
      }
   }

//------------------------------------------------------------------------------

bool WitSplitter::tempCommForSearch (WitSplitPt * searchPt, double searchVol)
   {
   bool success;

   searchPt->setNetSearchVol (searchVol);

   success = tempCommDiscZeroPts ();

   searchPt->clearNetSearchVol ();

   return success;
   }

//------------------------------------------------------------------------------

bool WitSplitter::tempCommDiscZeroPts ()
   {
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theZeroPt;
   bool                     success;

   zeroPts_.attachItr (theItr);

   while (theItr.advance (theZeroPt))
      theZeroPt->setNetSearchVol (0.0);

   success = mySelector_->myHeurAtor ()->tempCommit (1.0);

   zeroPts_.attachItr (theItr);

   while (theItr.advance (theZeroPt))
      theZeroPt->clearNetSearchVol ();

   return success;
   }

//------------------------------------------------------------------------------

void WitSplitter::splitChgPts ()
   {
   WitSplitPt * theSplitPt;

   WitObjStack <WitSplitPt> chgSplitPts (myProblem ());
   WitObjStItr <WitSplitPt> theItr;

   mySplitCntr_->countBatch ();

   findChgSplitPts (chgSplitPts);

   chgSplitPts.attachItr (theItr);

   while (theItr.advance (theSplitPt))
      theSplitPt->activateTotFlowVol ();

   myFlowMonitor_->setTotFlowVols ();

   chgSplitPts.attachItr (theItr);

   while (theItr.advance (theSplitPt))
      {
      theSplitPt->splitSelAsNeeded ();

      theSplitPt->deactivateTotFlowVol ();
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::findChgSplitPts (WitObjStack <WitSplitPt> & chgSplitPts)
   {
   WitSelPt * theSelPt;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      {
      if (not theSelPt->isSplit ())
         mySplitPts_.push (new WitSplitPt (this, theSelPt));

      chgSplitPts.push (theSelPt->mySplitPt ());
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::findHypoChanges (WitObjStack <WitSelPt> & chgSelPts)
   {
   WitSelPt * theSelPt;

   if (penExec_)
      findHypoChangesPE (chgSelPts);
   else
      {
      chgSelPts.clear ();

      if (mySelector_->pendingAlts ().isNonEmpty ())
         {
         theSelPt = mySelector_->pendingAlts ().firstObject ()->mySelPt ();

         chgSelPts.push (theSelPt);
         }
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::findHypoChangesPE (WitObjStack <WitSelPt> & chgSelPts)
   {
   WitAltPt *             theAltPt;
   WitObjStack <WitSelPt> theModPts (myProblem ());
   WitSelPt *             altSelPt;
   WitSelPt *             modSelPt;

   stronglyAssert (penExec_);

   chgSelPts.clear ();

   if (mySelector_->pendingAlts ().isNonEmpty ())
      {
      theAltPt = mySelector_->pendingAlts ().firstObject ();

      theAltPt->tempAlterSel ();
      }
   else
      theAltPt = NULL;

   myPenExMgr ()->findHypoModPts (theModPts);

   if (theAltPt != NULL)
      {
      theAltPt->cancelTempAlt ();

      altSelPt = theAltPt->mySelPt ();

      chgSelPts.push (altSelPt);
      }
   else
      altSelPt = NULL;

   while (theModPts.pop (modSelPt))
      if (modSelPt != altSelPt)
         chgSelPts.push (modSelPt);
   }

//------------------------------------------------------------------------------
// Implementation of class SplitPt.
//------------------------------------------------------------------------------

WitSplitPt::WitSplitPt (WitSplitter * theSplitter, WitSelPt * theSelPt):

      WitProbAssoc  (theSplitter),
      mySplitter_   (theSplitter),
      mySelPt_      (theSelPt),
      netSearchVol_ (-1.0),
      revSplitList_ (myProblem ()),
      netSplitList_ (myProblem ()),
      totFlowVol_   (-1.0)
   {
   mySelPt_->attachSplitPt (this);
   }

//------------------------------------------------------------------------------

WitSplitPt::~WitSplitPt ()
   {
   WitSelCand * theSelCand;
   double       splitBound;

   while (revSplitList_.pop (theSelCand, splitBound))
      {
      delete theSelCand;

      theSelCand = NULL;
      }

   mySelPt_->detachSplitPt ();
   }

//------------------------------------------------------------------------------

bool WitSplitPt::isLowerThan (WitSplitPt * theSplitPt)
   {
   WitPart *   thePart1;
   WitPeriod   thePer1;
   WitSelMgr * theSelMgr1;

   WitPart *   thePart2;
   WitPeriod   thePer2;
   WitSelMgr * theSelMgr2;

   witAssert (theSplitPt != NULL);

               mySelPt_->getSortData (thePart1, thePer1);
   theSplitPt->mySelPt_->getSortData (thePart2, thePer2);

   if (thePart1->sortedPartIndex () < thePart2->sortedPartIndex ())
      return true;

   if (thePart1->sortedPartIndex () > thePart2->sortedPartIndex ())
      return false;

   theSelMgr1 =             mySelPt_->mySelMgr ();
   theSelMgr2 = theSplitPt->mySelPt_->mySelMgr ();

   if (theSelMgr1->isLowerThan (theSelMgr2))
      return true;

   if (theSelMgr2->isLowerThan (theSelMgr1))
      return false;

   if (thePer1 > thePer2)
      return true;

   if (thePer1 < thePer2)
      return false;

   return false;
   }

//------------------------------------------------------------------------------

void WitSplitPt::setNetSearchVol (double theVal)
   {
   witAssert (theVal        >= 0.0);
   witAssert (netSearchVol_ < -0.5);

   netSearchVol_ = theVal;
   }

//------------------------------------------------------------------------------

void WitSplitPt::clearNetSearchVol ()
   {
   witAssert (netSearchVol_ >= 0.0);

   netSearchVol_ = -1.0;
   }

//------------------------------------------------------------------------------

void WitSplitPt::initNetSplitList ()
   {
   netSplitList_.revCopyFrom (revSplitList_);
   }

//------------------------------------------------------------------------------

void WitSplitPt::splitSelAsNeeded ()
   {
   WitSelCand * theSelCand;

   if (totFlowVol_ <= NET_TOL)
      return;

   theSelCand = mySelPt_->newSelCand ();

   revSplitList_.push (theSelCand, totFlowVol_);

   mySplitter_->mySplitCntr ()->countCurSplits ();

   if (selPrintLevelAt (3))
      prtSplitting (theSelCand, totFlowVol_);
   }

//------------------------------------------------------------------------------

void WitSplitPt::defineSplit (
      double               totFlowVol,
      WitSelCandDblStack & theSplitPairs,
      double &             unbddVol)
   {
   double netFlowVol;

   witAssert (totFlowVol > 0.0);

   netFlowVol = totFlowVol;

   unbddVol = 0.0;

   theSplitPairs.clear ();

   while (netSplitList_.isNonEmpty ())
      {
      addNextPair (netFlowVol, theSplitPairs);

      if (netFlowVol == 0.0)
         return;
      }

   unbddVol = compUnbddVol (netFlowVol);
   }

//------------------------------------------------------------------------------

void WitSplitPt::activateTotFlowVol ()
   {
   stronglyAssert (totFlowVol_ < -0.5);

   totFlowVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitSplitPt::incTotFlowVol (double incFlowVol)
   {
   if (totFlowVol_ > -0.5)
       totFlowVol_ += incFlowVol;
   }

//------------------------------------------------------------------------------

void WitSplitPt::deactivateTotFlowVol ()
   {
   stronglyAssert (totFlowVol_ >= 0.0);

   totFlowVol_ = -1.0;
   }

//------------------------------------------------------------------------------

bool WitSplitPt::hasSplits ()
   {
   return (revSplitList_.isNonEmpty ());
   }

//------------------------------------------------------------------------------

void WitSplitPt::prtSplitting (WitSelCand * theSelCand, double splitBound)
   {
   fprintf (msgFile (),
      "\n"
      "Splitting the %s Selection:\n",
      mySelPt_->mySelMgr ()->selCaseName ());

   mySelPt_->prtID ();

   theSelCand->prtID ();
               
   fprintf (msgFile (), "   Split Bound:      %.3f\n", splitBound);
   }

//------------------------------------------------------------------------------

void WitSplitPt::addNextPair (
      double &             netFlowVol,
      WitSelCandDblStack & theSplitPairs)
   {
   WitSelCand * theSelCand;
   double       splitBound;
   double       splitVol;

   witAssert (netSplitList_.isNonEmpty ());

   netSplitList_.pop (theSelCand, splitBound);

   splitVol = min (splitBound, netFlowVol);
   
   if (selPrintLevelAt (3))
      prtSplitExp (theSelCand, splitVol, splitBound, true);

   netFlowVol -= splitVol;
   splitBound -= splitVol;

   if (netFlowVol <= NET_TOL)
      netFlowVol = 0.0;
   
   if (splitBound > NET_TOL)
      netSplitList_.push (theSelCand, splitBound);

   theSplitPairs.push (theSelCand, splitVol);
   }

//------------------------------------------------------------------------------

double WitSplitPt::compUnbddVol (double netFlowVol)
   {
   double unbddVol;

   witAssert (netFlowVol > 0.0);

   unbddVol = netFlowVol;

   if (netSearchVol_ >= 0.0)
      {
      if (netSearchVol_ < unbddVol)
         {
         unbddVol      = netSearchVol_;

         netSearchVol_ = 0.0;

         if (unbddVol <= NET_TOL)
            return 0.0;
         }
      else
         netSearchVol_ -= unbddVol;
      }

   if (selPrintLevelAt (3))
      prtUnbddSplitExp (unbddVol);

   return unbddVol;
   }

//------------------------------------------------------------------------------

void WitSplitPt::prtUnbddSplitExp (double unbddVol)
   {
   WitSelCand * theSelCand;

   theSelCand = mySelPt_->newSelCand ();

   if (selPrintLevelAt (3))
      prtSplitExp (theSelCand, unbddVol, 0.0, false);

   delete theSelCand;
   }

//------------------------------------------------------------------------------

void WitSplitPt::prtSplitExp (
      WitSelCand * theSelCand, 
      double       splitVol, 
      double       splitBound,
      bool         boundedSplit)
   {
   WitSelMgr * theSelMgr;

   if (not mySplitter_->mySelector ()->myHeurAtor ()->permCommActive ())
      return;

   theSelMgr = mySelPt_->mySelMgr ();

   fprintf (msgFile (),
      "\n"
      "Split Selection for %s:\n",
      theSelMgr->selCaseName ());

   mySelPt_->prtID ();

   theSelCand->prtID ();
               
   fprintf    (msgFile (), "   SplitVol:         %.3f\n", splitVol);
               
   if (boundedSplit)
      fprintf (msgFile (), "   Split Bound:      %.3f\n", splitBound);
   else
      fprintf (msgFile (), "   Split Bound:      None\n");
   }

//------------------------------------------------------------------------------
// Implementation of class SelCand.
//------------------------------------------------------------------------------

WitSelCand::~WitSelCand ()
   {
   }

//------------------------------------------------------------------------------

void WitSelCand::getMrData (WitRtCand * &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getBaData (WitPeriod &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getMeData (WitPeriod &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getSsrData (bool &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getPoData (bool &, bool &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getPrData (WitRtCandStack & theRtCands)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

WitSelCand::WitSelCand (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------
// Implementation of class FlowMonitor.
//------------------------------------------------------------------------------

WitFlowMonitor::WitFlowMonitor (WitHeurAtor * theHeurAtor):

      WitProbAssoc   (theHeurAtor),
      myHeurAtor_    (theHeurAtor),
      active_        (false),
       curFlowPairs_ (myProblem ()),
        okFlowPairs_ (myProblem ()),
      failFlowPairs_ (myProblem ())
   {
   }

//------------------------------------------------------------------------------

WitFlowMonitor::~WitFlowMonitor ()
   {
   }

//------------------------------------------------------------------------------

void WitFlowMonitor::activate ()
   {
   stronglyAssert (not active_);

   active_ = true;
   }

//------------------------------------------------------------------------------

void WitFlowMonitor::deactivate ()
   {
   stronglyAssert (active_);

    curFlowPairs_.clear ();
     okFlowPairs_.clear ();
   failFlowPairs_.clear ();

   active_ = false;
   }

//------------------------------------------------------------------------------

void WitFlowMonitor::recordFlow (WitSelPt * theSelPt, double incFlowVol)
   {
   witAssert (myHeurAtor_->tempCommActive ());

   if (not active_)
      return;

   if (not theSelPt->splittable ())
      return;

   if (theSelPt->mySelMgr ()->boundedSplit ())
      return;

   curFlowPairs_.push (theSelPt, incFlowVol);
   }

//------------------------------------------------------------------------------

void WitFlowMonitor::postTempCommit (bool success)
   {
   if (not active_)
      return;

   if (success)
      {
      okFlowPairs_.clear ();

      okFlowPairs_.takeContentsFrom (curFlowPairs_);
      }
   else
      {
      failFlowPairs_.clear ();

      failFlowPairs_.takeContentsFrom (curFlowPairs_);
      }
   }

//------------------------------------------------------------------------------

bool WitFlowMonitor::splitIsNeeded (
      WitSelPt * theSelPt, 
      bool       compToSuccess,
      double &   flowGap)
   {
   stronglyAssert (active_);

   if (not theSelPt->splittable ())
      return false;

   flowGap = flowThruSelPt (theSelPt, failFlowPairs_);

   if (compToSuccess)
      flowGap -= flowThruSelPt (theSelPt, okFlowPairs_);

   return (flowGap > myGlobalComp ()->splitTol () + SEARCH_TOL);
   }

//------------------------------------------------------------------------------

void WitFlowMonitor::setTotFlowVols ()
   {
   WitSelPt * theSelPt;
   double     incFlowVol;

   WitPairStItr <WitSelPt, double> theItr;

   stronglyAssert (active_);

   okFlowPairs_.attachItr (theItr);

   while (theItr.advance (theSelPt, incFlowVol))
      if (theSelPt->isSplit ())
         theSelPt->mySplitPt ()->incTotFlowVol (incFlowVol);
   }

//------------------------------------------------------------------------------

double WitFlowMonitor::flowThruSelPt (
      WitSelPt *               theSelPt,
      const WitSelPtDblStack & theFlowPairs)
   {
   double     flowVol;
   WitSelPt * curSelPt;
   double     incFlowVol;

   WitPairStItr <WitSelPt, double> theItr;

   stronglyAssert (theSelPt != NULL);

   flowVol = 0.0;

   theFlowPairs.attachItr (theItr);

   while (theItr.advance (curSelPt, incFlowVol))
      if (curSelPt == theSelPt)
         flowVol += incFlowVol;

   return flowVol;
   }

//------------------------------------------------------------------------------
// Implementation of class SplitCntr.
//------------------------------------------------------------------------------

WitSplitCntr::WitSplitCntr (WitSelector * theSelector):

      WitProbAssoc       (theSelector),
      mySelector_        (theSelector),
      nCurSplits_        (0),
      nSplitsDone_       (0),
      nSplitsDiscarded_  (0),
      nSplitSplitComs_   (0),
      nUnsplitSplitComs_ (0),
      nBSsDone_          (0),
      nBSsSkipped_       (0),
      nBatches_          (0)
   {
   }

//------------------------------------------------------------------------------

WitSplitCntr::~WitSplitCntr ()
   {
   if (selPrintLevelAt (1))
      print ();
   }

//------------------------------------------------------------------------------

void WitSplitCntr::initCurSplits ()
   {
   if (selPrintLevelAt (1))
      nCurSplits_ = 0;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countCurSplits ()
   {
   if (selPrintLevelAt (1))
      nCurSplits_ ++;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countSplits (bool tempCommOK)
   {
   if (tempCommOK)
      {
      nSplitsDone_          += nCurSplits_;

      if (nCurSplits_ > 0)
         nSplitSplitComs_   ++;
      else
         nUnsplitSplitComs_ ++;
      }
   else
      {
      nSplitsDiscarded_     += nCurSplits_;

      nUnsplitSplitComs_    ++;
      }
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countBS (bool bsDone)
   {
   if (bsDone)
      nBSsDone_ ++;
   else
      nBSsSkipped_ ++;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countBatch ()
   {
   nBatches_ ++;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::print ()
   {
   fprintf (msgFile (), 
      "# SS BS's Done:         %7d\n"
      "# SS BS's Skipped:      %7d\n"
      "# Split Batches:        %7d\n"
      "# Splits Performed:     %7d\n"
      "# Splits Discarded:     %7d\n"
      "# Alts, Total:          %7d\n\n"
      "#   Split Split-Coms:   %7d\n"
      "# Unsplit Split-Coms:   %7d\n\n\n",

      nBSsDone_,
      nBSsSkipped_,
      nBatches_,
      nSplitsDone_,
      nSplitsDiscarded_,
      mySelector_->nAlts (),
      nSplitSplitComs_,
      nUnsplitSplitComs_);
   }
@


1.87
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.86
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d46 41
a86 41
WitProbAssoc     (theSelector),
mySelector_      (theSelector),
myFlowMonitor_   (NULL),
mySplitCntr_     (NULL),
myPenExMgr_      (NULL),
penExec_         (false),
splitRes_        (myGlobalComp ()->splitRes ()),
zeroPts_         (myProblem ()),
splitCommActive_ (false),
mySplitPts_      (myProblem ())
{
WitDemand * theDemand;
WitSelMgr * theSelMgr;

myMsgFac () ("selSplitMsg");

if (myGlobalComp ()->computeCriticalList ())
myMsgFac () ("critListSelSplitSmsg");

if (myGlobalComp ()->pgdCritListMode ())
myMsgFac () ("pgdCritListSelSplitSmsg");

forEachDemand (theDemand, myProblem ())
if (theDemand->searchInc () != 1.0)
myMsgFac () ("searchIncSelSplitSmsg",
theDemand->demandedPartName (),
theDemand->demandName (),
theDemand->searchInc ());

forEachEl (theSelMgr, mySelector_->mySelMgrs ())
theSelMgr->setUpSelSplit ();

myFlowMonitor_ = new WitFlowMonitor (mySelector_->myHeurAtor ());

mySplitCntr_   = new WitSplitCntr (mySelector_);

penExec_       = mySelector_->penExec ();

if (penExec_)
myPenExMgr_ = theSelector->myPenExMgr ();
}
d91 4
a94 4
{
delete mySplitCntr_;
delete myFlowMonitor_;
}
d99 47
a145 47
{
bool scNeeded;
bool unresFound;

while (true)
{
mySelector_->prepCmqSel ();

myFlowMonitor_->activate ();

mySelector_->myHeurAtor ()->commitMaxQtySel (netQty);

if ((netQty <= 0.0) or not resAltOrRest ())
{
myFlowMonitor_->deactivate ();

break;
}

scNeeded = splitCommitNeeded ();

myFlowMonitor_->deactivate ();

if (scNeeded)
if (not mySelector_->myHeurAtor ()->failedOn1 ())
if (mySelector_->myHeurAtor ()->tempCommit (1.0))
scNeeded = false;

if (scNeeded)
{
splitCommit (unresFound);

if (unresFound)
break;
}
else
{
if (penExec_)
myPenExMgr ()->updatePsSup ();

mySelector_->alterSelSS ();
}
}

if (penExec_)
myPenExMgr ()->updatePsSup ();
}
d150 9
a158 9
{
WitObjStItr <WitSplitPt> theItr;
WitSplitPt *             theSplitPt;

mySplitPts_.attachItr (theItr);

while (theItr.advance (theSplitPt))
theSplitPt->initNetSplitList ();
}
d163 3
a165 3
{
myFlowMonitor_->postTempCommit (success);
}
d170 9
a178 9
{
WitSelMgr * lbSelMgr;
WitSelMgr * theSelMgr;

lbSelMgr = NULL;

forEachEl (theSelMgr, mySelector_->mySelMgrs ())
if (theSelMgr->boundedSplit ())
lbSelMgr = theSelMgr;
d180 2
a181 2
return lbSelMgr;
}
d186 3
a188 3
{
myFlowMonitor_->recordFlow (theSelPt, incFlowVol);
}
d193 3
a195 3
{
WitSelPt * theSelPt;
double     flowGap;
d197 1
a197 1
WitObjStack <WitSelPt> chgSelPts (myProblem ());
d199 1
a199 1
findHypoChanges (chgSelPts);
d201 3
a203 3
while (chgSelPts.pop (theSelPt))
if (myFlowMonitor_->splitIsNeeded (theSelPt, true, flowGap))
return true;
d205 2
a206 2
return false;
}
d211 5
a215 5
{
int         nItrs;
bool        tcOK;
bool        splitFound;
WitSelMgr * theSelMgr;
d217 4
a220 4
splitCommActive_ = true;
unresFound       = false;
nItrs            = 0;
tcOK             = false;
d222 1
a222 1
mySplitCntr_->initCurSplits ();
d224 3
a226 3
while (not tcOK)
{
nItrs ++;
d228 2
a229 2
if (nItrs > myGlobalComp ()->splitItrUB ())
break;
d231 1
a231 1
buildZeroPts (unresFound, splitFound);
d233 2
a234 2
if (unresFound)
break;
d236 2
a237 2
if (splitFound)
splitSels ();
d239 1
a239 1
clearSplitItr ();
d241 1
a241 1
stronglyAssert (resAltOrRest ());
d243 1
a243 1
mySelector_->alterSelSS ();
d245 5
a249 5
if (penExec_)
{
myPenExMgr ()->updatePsSup   ();
myPenExMgr ()->modifyRouting ();
}
d251 2
a252 2
tcOK = mySelector_->myHeurAtor ()->tempCommit (1.0);
}
d254 2
a255 2
if (tcOK)
mySelector_->myHeurAtor ()->permCommit1SS ();
d257 2
a258 2
if (selPrintLevelAt (1))
mySplitCntr_->countSplits (tcOK);
d260 2
a261 2
forEachEl (theSelMgr, mySelector_->mySelMgrs ())
theSelMgr->postSplitCommit ();
d263 1
a263 1
deleteContents (mySplitPts_);
d265 2
a266 2
splitCommActive_ = false;
}
d271 2
a272 2
{
bool addedZeroPts;
d274 1
a274 1
stronglyAssert (zeroPts_.isEmpty ());
d276 2
a277 2
unresFound = false;
splitFound = false;
d279 3
a281 3
while (not splitFound)
{
unresFound = not resAltOrRest ();
d283 3
a285 3
if (unresFound)
{
clearSplitItr ();
d287 2
a288 2
return;
}
d290 1
a290 1
addedZeroPts = addChgPtsToZeroPts ();
d292 2
a293 2
if (not addedZeroPts)
return;
d295 3
a297 3
splitFound = tempCommDiscZeroPts ();
}
}
d302 16
a317 16
{
WitObjStack <WitSplitPt> revSplitPts (myProblem ());
WitSplitPt *             theSplitPt;

zeroPts_.clear ();

revSplitPts.revCopyFrom (mySplitPts_);

mySplitPts_.clear ();

while (revSplitPts.pop (theSplitPt))
if (theSplitPt->hasSplits ())
mySplitPts_.push (theSplitPt);
else
delete theSplitPt;
}
d322 3
a324 3
{
bool       addedZeroPts;
WitSelPt * theSelPt;
d326 1
a326 1
WitObjStack <WitSelPt> chgSelPts (myProblem ());
d328 1
a328 1
addedZeroPts = false;
d330 1
a330 1
findHypoChanges (chgSelPts);
d332 4
a335 4
while (chgSelPts.pop (theSelPt))
{
if (not theSelPt->isSplit ())
mySplitPts_.push (new WitSplitPt (this, theSelPt));
d337 2
a338 2
else if (zeroPts_.contains (theSelPt->mySplitPt ()))
continue;
d340 1
a340 1
zeroPts_.push (theSelPt->mySplitPt ());
d342 2
a343 2
addedZeroPts = true;
}
d345 2
a346 2
return addedZeroPts;
}
d351 5
a355 5
{
bool         success;
WitSplitPt * searchPt;
bool         splitNeeded;
double       flowGap;
d357 1
a357 1
myFlowMonitor_->activate ();
d359 1
a359 1
success = true;
d361 3
a363 3
while (success)
{
stronglyAssert (zeroPts_.isNonEmpty ());
d365 1
a365 1
searchPt = findLowestZeroPt ();
d367 1
a367 1
zeroPts_.remove (searchPt);
d369 2
a370 2
success = tempCommDiscZeroPts ();
}
d372 2
a373 2
splitNeeded =
myFlowMonitor_->splitIsNeeded (searchPt->mySelPt (), false, flowGap);
d375 2
a376 2
if (splitNeeded)
searchForFlow (searchPt, flowGap);
d378 5
a382 5
if (resAltOrRest ())
splitChgPts ();
else
{
success = mySelector_->myHeurAtor ()->tempCommit (1.0);
d384 2
a385 2
stronglyAssert (not success);
}
d387 2
a388 2
myFlowMonitor_->deactivate ();
}
d393 10
a402 10
{
if (mySelector_->failResAlt ())
return true;

else if (penExec_)
return myPenExMgr ()->failRestShortOnly ();

else
return false;
}
d407 3
a409 3
{
WitSplitPt * lowZeroPt;
WitSplitPt * theZeroPt;
d411 1
a411 1
WitObjStItr <WitSplitPt> theItr;
d413 1
a413 1
stronglyAssert (zeroPts_.isNonEmpty ());
d415 1
a415 1
zeroPts_.attachItr (theItr);
d417 1
a417 1
theItr.advance (lowZeroPt);
d419 3
a421 3
while (theItr.advance (theZeroPt))
if (theZeroPt->isLowerThan (lowZeroPt))
lowZeroPt = theZeroPt;
d423 2
a424 2
return lowZeroPt;
}
d429 5
a433 5
{
bool success;
int  upperGP;
int  lowerGP;
int  midGP;
d435 1
a435 1
success = tempCommForSearch (searchPt, splitRes_);
d437 1
a437 1
mySplitCntr_->countBS (success);
d439 2
a440 2
if (not success)
return;
d442 2
a443 2
lowerGP = 1;
upperGP = static_cast <int> (ceil (theFlowVol / splitRes_));
d445 1
a445 1
stronglyAssert (upperGP >= 2);
d447 3
a449 3
while (upperGP - lowerGP > 1)
{
midGP   = (lowerGP + upperGP) / 2;
d451 1
a451 1
success = tempCommForSearch (searchPt, midGP * splitRes_);
d453 6
a458 6
if (success)
lowerGP = midGP;
else
upperGP = midGP;
}
}
d463 2
a464 2
{
bool success;
d466 1
a466 1
searchPt->setNetSearchVol (searchVol);
d468 1
a468 1
success = tempCommDiscZeroPts ();
d470 1
a470 1
searchPt->clearNetSearchVol ();
d472 2
a473 2
return success;
}
d478 4
a481 4
{
WitObjStItr <WitSplitPt> theItr;
WitSplitPt *             theZeroPt;
bool                     success;
d483 1
a483 1
zeroPts_.attachItr (theItr);
d485 2
a486 2
while (theItr.advance (theZeroPt))
theZeroPt->setNetSearchVol (0.0);
d488 1
a488 1
success = mySelector_->myHeurAtor ()->tempCommit (1.0);
d490 1
a490 1
zeroPts_.attachItr (theItr);
d492 2
a493 2
while (theItr.advance (theZeroPt))
theZeroPt->clearNetSearchVol ();
d495 2
a496 2
return success;
}
d501 2
a502 2
{
WitSplitPt * theSplitPt;
d504 2
a505 2
WitObjStack <WitSplitPt> chgSplitPts (myProblem ());
WitObjStItr <WitSplitPt> theItr;
d507 1
a507 1
mySplitCntr_->countBatch ();
d509 1
a509 1
findChgSplitPts (chgSplitPts);
d511 1
a511 1
chgSplitPts.attachItr (theItr);
d513 2
a514 2
while (theItr.advance (theSplitPt))
theSplitPt->activateTotFlowVol ();
d516 1
a516 1
myFlowMonitor_->setTotFlowVols ();
d518 1
a518 1
chgSplitPts.attachItr (theItr);
d520 3
a522 3
while (theItr.advance (theSplitPt))
{
theSplitPt->splitSelAsNeeded ();
d524 3
a526 3
theSplitPt->deactivateTotFlowVol ();
}
}
d531 2
a532 2
{
WitSelPt * theSelPt;
d534 1
a534 1
WitObjStack <WitSelPt> chgSelPts (myProblem ());
d536 1
a536 1
findHypoChanges (chgSelPts);
d538 4
a541 4
while (chgSelPts.pop (theSelPt))
{
if (not theSelPt->isSplit ())
mySplitPts_.push (new WitSplitPt (this, theSelPt));
d543 3
a545 3
chgSplitPts.push (theSelPt->mySplitPt ());
}
}
d550 2
a551 2
{
WitSelPt * theSelPt;
d553 14
a566 14
if (penExec_)
findHypoChangesPE (chgSelPts);
else
{
chgSelPts.clear ();

if (mySelector_->pendingAlts ().isNonEmpty ())
{
theSelPt = mySelector_->pendingAlts ().firstObject ()->mySelPt ();

chgSelPts.push (theSelPt);
}
}
}
d571 36
a606 36
{
WitAltPt *             theAltPt;
WitObjStack <WitSelPt> theModPts (myProblem ());
WitSelPt *             altSelPt;
WitSelPt *             modSelPt;

stronglyAssert (penExec_);

chgSelPts.clear ();

if (mySelector_->pendingAlts ().isNonEmpty ())
{
theAltPt = mySelector_->pendingAlts ().firstObject ();

theAltPt->tempAlterSel ();
}
else
theAltPt = NULL;

myPenExMgr ()->findHypoModPts (theModPts);

if (theAltPt != NULL)
{
theAltPt->cancelTempAlt ();

altSelPt = theAltPt->mySelPt ();

chgSelPts.push (altSelPt);
}
else
altSelPt = NULL;

while (theModPts.pop (modSelPt))
if (modSelPt != altSelPt)
chgSelPts.push (modSelPt);
}
d614 10
a623 10
WitProbAssoc  (theSplitter),
mySplitter_   (theSplitter),
mySelPt_      (theSelPt),
netSearchVol_ (-1.0),
revSplitList_ (myProblem ()),
netSplitList_ (myProblem ()),
totFlowVol_   (-1.0)
{
mySelPt_->attachSplitPt (this);
}
d628 7
a634 7
{
WitSelCand * theSelCand;
double       splitBound;

while (revSplitList_.pop (theSelCand, splitBound))
{
delete theSelCand;
d636 2
a637 2
theSelCand = NULL;
}
d639 2
a640 2
mySelPt_->detachSplitPt ();
}
d645 4
a648 4
{
WitPart *   thePart1;
WitPeriod   thePer1;
WitSelMgr * theSelMgr1;
d650 3
a652 3
WitPart *   thePart2;
WitPeriod   thePer2;
WitSelMgr * theSelMgr2;
d654 1
a654 1
witAssert (theSplitPt != NULL);
d656 2
a657 2
mySelPt_->getSortData (thePart1, thePer1);
theSplitPt->mySelPt_->getSortData (thePart2, thePer2);
d659 2
a660 2
if (thePart1->sortedPartIndex () < thePart2->sortedPartIndex ())
return true;
d662 2
a663 2
if (thePart1->sortedPartIndex () > thePart2->sortedPartIndex ())
return false;
d665 2
a666 2
theSelMgr1 =             mySelPt_->mySelMgr ();
theSelMgr2 = theSplitPt->mySelPt_->mySelMgr ();
d668 2
a669 2
if (theSelMgr1->isLowerThan (theSelMgr2))
return true;
d671 2
a672 2
if (theSelMgr2->isLowerThan (theSelMgr1))
return false;
d674 2
a675 2
if (thePer1 > thePer2)
return true;
d677 2
a678 2
if (thePer1 < thePer2)
return false;
d680 2
a681 2
return false;
}
d686 3
a688 3
{
witAssert (theVal        >= 0.0);
witAssert (netSearchVol_ < -0.5);
d690 2
a691 2
netSearchVol_ = theVal;
}
d696 2
a697 2
{
witAssert (netSearchVol_ >= 0.0);
d699 2
a700 2
netSearchVol_ = -1.0;
}
d705 3
a707 3
{
netSplitList_.revCopyFrom (revSplitList_);
}
d712 2
a713 2
{
WitSelCand * theSelCand;
d715 2
a716 2
if (totFlowVol_ <= NET_TOL)
return;
d718 1
a718 1
theSelCand = mySelPt_->newSelCand ();
d720 1
a720 1
revSplitList_.push (theSelCand, totFlowVol_);
d722 1
a722 1
mySplitter_->mySplitCntr ()->countCurSplits ();
d724 3
a726 3
if (selPrintLevelAt (3))
prtSplitting (theSelCand, totFlowVol_);
}
d731 5
a735 5
double               totFlowVol,
WitSelCandDblStack & theSplitPairs,
double &             unbddVol)
{
double netFlowVol;
d737 1
a737 1
witAssert (totFlowVol > 0.0);
d739 1
a739 1
netFlowVol = totFlowVol;
d741 1
a741 1
unbddVol = 0.0;
d743 1
a743 1
theSplitPairs.clear ();
d745 3
a747 3
while (netSplitList_.isNonEmpty ())
{
addNextPair (netFlowVol, theSplitPairs);
d749 3
a751 3
if (netFlowVol == 0.0)
return;
}
d753 2
a754 2
unbddVol = compUnbddVol (netFlowVol);
}
d759 2
a760 2
{
stronglyAssert (totFlowVol_ < -0.5);
d762 2
a763 2
totFlowVol_ = 0.0;
}
d768 4
a771 4
{
if (totFlowVol_ > -0.5)
totFlowVol_ += incFlowVol;
}
d776 2
a777 2
{
stronglyAssert (totFlowVol_ >= 0.0);
d779 2
a780 2
totFlowVol_ = -1.0;
}
d785 3
a787 3
{
return (revSplitList_.isNonEmpty ());
}
d792 12
a803 12
{
fprintf (msgFile (),
"\n"
"Splitting the %s Selection:\n",
mySelPt_->mySelMgr ()->selCaseName ());

mySelPt_->prtID ();

theSelCand->prtID ();

fprintf (msgFile (), "   Split Bound:      %.3f\n", splitBound);
}
d808 24
a831 24
double &             netFlowVol,
WitSelCandDblStack & theSplitPairs)
{
WitSelCand * theSelCand;
double       splitBound;
double       splitVol;

witAssert (netSplitList_.isNonEmpty ());

netSplitList_.pop (theSelCand, splitBound);

splitVol = min (splitBound, netFlowVol);

if (selPrintLevelAt (3))
prtSplitExp (theSelCand, splitVol, splitBound, true);

netFlowVol -= splitVol;
splitBound -= splitVol;

if (netFlowVol <= NET_TOL)
netFlowVol = 0.0;

if (splitBound > NET_TOL)
netSplitList_.push (theSelCand, splitBound);
d833 2
a834 2
theSplitPairs.push (theSelCand, splitVol);
}
d839 2
a840 2
{
double unbddVol;
d842 1
a842 1
witAssert (netFlowVol > 0.0);
d844 1
a844 1
unbddVol = netFlowVol;
d846 5
a850 5
if (netSearchVol_ >= 0.0)
{
if (netSearchVol_ < unbddVol)
{
unbddVol      = netSearchVol_;
d852 1
a852 1
netSearchVol_ = 0.0;
d854 6
a859 6
if (unbddVol <= NET_TOL)
return 0.0;
}
else
netSearchVol_ -= unbddVol;
}
d861 2
a862 2
if (selPrintLevelAt (3))
prtUnbddSplitExp (unbddVol);
d864 2
a865 2
return unbddVol;
}
d870 2
a871 2
{
WitSelCand * theSelCand;
d873 1
a873 1
theSelCand = mySelPt_->newSelCand ();
d875 2
a876 2
if (selPrintLevelAt (3))
prtSplitExp (theSelCand, unbddVol, 0.0, false);
d878 2
a879 2
delete theSelCand;
}
d884 28
a911 28
WitSelCand * theSelCand,
double       splitVol,
double       splitBound,
bool         boundedSplit)
{
WitSelMgr * theSelMgr;

if (not mySplitter_->mySelector ()->myHeurAtor ()->permCommActive ())
return;

theSelMgr = mySelPt_->mySelMgr ();

fprintf (msgFile (),
"\n"
"Split Selection for %s:\n",
theSelMgr->selCaseName ());

mySelPt_->prtID ();

theSelCand->prtID ();

fprintf    (msgFile (), "   SplitVol:         %.3f\n", splitVol);

if (boundedSplit)
fprintf (msgFile (), "   Split Bound:      %.3f\n", splitBound);
else
fprintf (msgFile (), "   Split Bound:      None\n");
}
d918 2
a919 2
{
}
d924 3
a926 3
{
stronglyAssert (false);
}
d931 3
a933 3
{
stronglyAssert (false);
}
d938 3
a940 3
{
stronglyAssert (false);
}
d945 3
a947 3
{
stronglyAssert (false);
}
d952 3
a954 3
{
stronglyAssert (false);
}
d959 3
a961 3
{
stronglyAssert (false);
}
d966 3
a968 3
WitProbAssoc (theProblem)
{
}
d976 8
a983 8
WitProbAssoc   (theHeurAtor),
myHeurAtor_    (theHeurAtor),
active_        (false),
curFlowPairs_ (myProblem ()),
okFlowPairs_ (myProblem ()),
failFlowPairs_ (myProblem ())
{
}
d988 2
a989 2
{
}
d994 2
a995 2
{
stronglyAssert (not active_);
d997 2
a998 2
active_ = true;
}
d1003 2
a1004 2
{
stronglyAssert (active_);
d1006 3
a1008 3
curFlowPairs_.clear ();
okFlowPairs_.clear ();
failFlowPairs_.clear ();
d1010 2
a1011 2
active_ = false;
}
d1016 2
a1017 2
{
witAssert (myHeurAtor_->tempCommActive ());
d1019 2
a1020 2
if (not active_)
return;
d1022 2
a1023 2
if (not theSelPt->splittable ())
return;
d1025 2
a1026 2
if (theSelPt->mySelMgr ()->boundedSplit ())
return;
d1028 2
a1029 2
curFlowPairs_.push (theSelPt, incFlowVol);
}
d1034 17
a1050 17
{
if (not active_)
return;

if (success)
{
okFlowPairs_.clear ();

okFlowPairs_.takeContentsFrom (curFlowPairs_);
}
else
{
failFlowPairs_.clear ();

failFlowPairs_.takeContentsFrom (curFlowPairs_);
}
}
d1055 8
a1062 8
WitSelPt * theSelPt,
bool       compToSuccess,
double &   flowGap)
{
stronglyAssert (active_);

if (not theSelPt->splittable ())
return false;
d1064 1
a1064 1
flowGap = flowThruSelPt (theSelPt, failFlowPairs_);
d1066 2
a1067 2
if (compToSuccess)
flowGap -= flowThruSelPt (theSelPt, okFlowPairs_);
d1069 2
a1070 2
return (flowGap > myGlobalComp ()->splitTol () + SEARCH_TOL);
}
d1075 3
a1077 3
{
WitSelPt * theSelPt;
double     incFlowVol;
d1079 1
a1079 1
WitPairStItr <WitSelPt, double> theItr;
d1081 1
a1081 1
stronglyAssert (active_);
d1083 1
a1083 1
okFlowPairs_.attachItr (theItr);
d1085 4
a1088 4
while (theItr.advance (theSelPt, incFlowVol))
if (theSelPt->isSplit ())
theSelPt->mySplitPt ()->incTotFlowVol (incFlowVol);
}
d1093 6
a1098 6
WitSelPt *               theSelPt,
const WitSelPtDblStack & theFlowPairs)
{
double     flowVol;
WitSelPt * curSelPt;
double     incFlowVol;
d1100 1
a1100 1
WitPairStItr <WitSelPt, double> theItr;
d1102 1
a1102 1
stronglyAssert (theSelPt != NULL);
d1104 1
a1104 1
flowVol = 0.0;
d1106 1
a1106 1
theFlowPairs.attachItr (theItr);
d1108 3
a1110 3
while (theItr.advance (curSelPt, incFlowVol))
if (curSelPt == theSelPt)
flowVol += incFlowVol;
d1112 2
a1113 2
return flowVol;
}
d1121 12
a1132 12
WitProbAssoc       (theSelector),
mySelector_        (theSelector),
nCurSplits_        (0),
nSplitsDone_       (0),
nSplitsDiscarded_  (0),
nSplitSplitComs_   (0),
nUnsplitSplitComs_ (0),
nBSsDone_          (0),
nBSsSkipped_       (0),
nBatches_          (0)
{
}
d1137 4
a1140 4
{
if (selPrintLevelAt (1))
print ();
}
d1145 4
a1148 4
{
if (selPrintLevelAt (1))
nCurSplits_ = 0;
}
d1153 4
a1156 4
{
if (selPrintLevelAt (1))
nCurSplits_ ++;
}
d1161 17
a1177 17
{
if (tempCommOK)
{
nSplitsDone_          += nCurSplits_;

if (nCurSplits_ > 0)
nSplitSplitComs_   ++;
else
nUnsplitSplitComs_ ++;
}
else
{
nSplitsDiscarded_     += nCurSplits_;

nUnsplitSplitComs_    ++;
}
}
d1182 6
a1187 6
{
if (bsDone)
nBSsDone_ ++;
else
nBSsSkipped_ ++;
}
d1192 3
a1194 3
{
nBatches_ ++;
}
d1199 20
a1218 20
{
fprintf (msgFile (),
"# SS BS's Done:         %7d\n"
"# SS BS's Skipped:      %7d\n"
"# Split Batches:        %7d\n"
"# Splits Performed:     %7d\n"
"# Splits Discarded:     %7d\n"
"# Alts, Total:          %7d\n\n"
"#   Split Split-Coms:   %7d\n"
"# Unsplit Split-Coms:   %7d\n\n\n",

nBSsDone_,
nBSsSkipped_,
nBatches_,
nSplitsDone_,
nSplitsDiscarded_,
mySelector_->nAlts (),
nSplitSplitComs_,
nUnsplitSplitComs_);
}
@


1.85
log
@Selection reuse.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d46 41
a86 41
      WitProbAssoc     (theSelector),
      mySelector_      (theSelector),
      myFlowMonitor_   (NULL),
      mySplitCntr_     (NULL),
      myPenExMgr_      (NULL),
      penExec_         (false),
      splitRes_        (myGlobalComp ()->splitRes ()),
      zeroPts_         (myProblem ()),
      splitCommActive_ (false),
      mySplitPts_      (myProblem ())
   {
   WitDemand * theDemand;
   WitSelMgr * theSelMgr;

   myMsgFac () ("selSplitMsg");

   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("critListSelSplitSmsg");

   if (myGlobalComp ()->pgdCritListMode ())
      myMsgFac () ("pgdCritListSelSplitSmsg");

   forEachDemand (theDemand, myProblem ())
      if (theDemand->searchInc () != 1.0)
         myMsgFac () ("searchIncSelSplitSmsg",
            theDemand->demandedPartName (),
            theDemand->demandName (),
            theDemand->searchInc ());

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->setUpSelSplit ();

   myFlowMonitor_ = new WitFlowMonitor (mySelector_->myHeurAtor ());

   mySplitCntr_   = new WitSplitCntr (mySelector_);

   penExec_       = mySelector_->penExec ();

   if (penExec_)
      myPenExMgr_ = theSelector->myPenExMgr ();
   }
d91 4
a94 4
   {
   delete mySplitCntr_;
   delete myFlowMonitor_;
   }
d99 47
a145 47
   {
   bool scNeeded;
   bool unresFound;

   while (true)
      {
      mySelector_->prepCmqSel ();

      myFlowMonitor_->activate ();

      mySelector_->myHeurAtor ()->commitMaxQtySel (netQty);

      if ((netQty <= 0.0) or not resAltOrRest ())
         {
         myFlowMonitor_->deactivate ();

         break;
         }

      scNeeded = splitCommitNeeded ();
      
      myFlowMonitor_->deactivate ();

      if (scNeeded)
         if (not mySelector_->myHeurAtor ()->failedOn1 ())
            if (mySelector_->myHeurAtor ()->tempCommit (1.0))
               scNeeded = false;

      if (scNeeded)
         {
         splitCommit (unresFound);

         if (unresFound)
            break;
         }
      else
         {
         if (penExec_)
            myPenExMgr ()->updatePsSup ();

         mySelector_->alterSelSS ();
         }
      }

   if (penExec_)
      myPenExMgr ()->updatePsSup ();
   }
d150 9
a158 9
   {
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theSplitPt;

   mySplitPts_.attachItr (theItr);

   while (theItr.advance (theSplitPt))
      theSplitPt->initNetSplitList ();
   }
d163 3
a165 3
   {
   myFlowMonitor_->postTempCommit (success);
   }
d170 9
a178 9
   {
   WitSelMgr * lbSelMgr;
   WitSelMgr * theSelMgr;

   lbSelMgr = NULL;

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      if (theSelMgr->boundedSplit ())
         lbSelMgr = theSelMgr;
d180 2
a181 2
   return lbSelMgr;
   }
d186 3
a188 3
   {
   myFlowMonitor_->recordFlow (theSelPt, incFlowVol);
   }
d193 3
a195 3
   {
   WitSelPt * theSelPt;
   double     flowGap;
d197 1
a197 1
   WitObjStack <WitSelPt> chgSelPts (myProblem ());
d199 1
a199 1
   findHypoChanges (chgSelPts);
d201 3
a203 3
   while (chgSelPts.pop (theSelPt))
      if (myFlowMonitor_->splitIsNeeded (theSelPt, true, flowGap))
         return true;
d205 2
a206 2
   return false;
   }
d211 5
a215 5
   {
   int         nItrs;
   bool        tcOK;
   bool        splitFound;
   WitSelMgr * theSelMgr;
d217 4
a220 4
   splitCommActive_ = true;
   unresFound       = false;
   nItrs            = 0;
   tcOK             = false;
d222 1
a222 1
   mySplitCntr_->initCurSplits ();
d224 3
a226 3
   while (not tcOK)
      {
      nItrs ++;
d228 2
a229 2
      if (nItrs > myGlobalComp ()->splitItrUB ())
         break;
d231 1
a231 1
      buildZeroPts (unresFound, splitFound);
d233 2
a234 2
      if (unresFound)
         break;
d236 2
a237 2
      if (splitFound)
         splitSels ();
d239 1
a239 1
      clearSplitItr ();
d241 1
a241 1
      stronglyAssert (resAltOrRest ());
d243 1
a243 1
      mySelector_->alterSelSS ();
d245 5
a249 5
      if (penExec_)
         {
         myPenExMgr ()->updatePsSup   ();
         myPenExMgr ()->modifyRouting ();
         }
d251 2
a252 2
      tcOK = mySelector_->myHeurAtor ()->tempCommit (1.0);
      }
d254 2
a255 2
   if (tcOK)
      mySelector_->myHeurAtor ()->permCommit1SS ();
d257 2
a258 2
   if (selPrintLevelAt (1))
      mySplitCntr_->countSplits (tcOK);
d260 2
a261 2
   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->postSplitCommit ();
d263 1
a263 1
   deleteContents (mySplitPts_);
d265 2
a266 2
   splitCommActive_ = false;
   }
d271 2
a272 2
   {
   bool addedZeroPts;
d274 1
a274 1
   stronglyAssert (zeroPts_.isEmpty ());
d276 2
a277 2
   unresFound = false;
   splitFound = false;
d279 3
a281 3
   while (not splitFound)
      {
      unresFound = not resAltOrRest ();
d283 3
a285 3
      if (unresFound)
         {
         clearSplitItr ();
d287 2
a288 2
         return;
         }
d290 1
a290 1
      addedZeroPts = addChgPtsToZeroPts ();
d292 2
a293 2
      if (not addedZeroPts)
         return;
d295 3
a297 3
      splitFound = tempCommDiscZeroPts ();
      }
   }
d302 16
a317 16
   {
   WitObjStack <WitSplitPt> revSplitPts (myProblem ());
   WitSplitPt *             theSplitPt;

   zeroPts_.clear ();

   revSplitPts.revCopyFrom (mySplitPts_);

   mySplitPts_.clear ();

   while (revSplitPts.pop (theSplitPt))
      if (theSplitPt->hasSplits ())
         mySplitPts_.push (theSplitPt);
      else
         delete theSplitPt;
   }
d322 3
a324 3
   {
   bool       addedZeroPts;
   WitSelPt * theSelPt;
d326 1
a326 1
   WitObjStack <WitSelPt> chgSelPts (myProblem ());
d328 1
a328 1
   addedZeroPts = false;
d330 1
a330 1
   findHypoChanges (chgSelPts);
d332 4
a335 4
   while (chgSelPts.pop (theSelPt))
      {
      if (not theSelPt->isSplit ())
         mySplitPts_.push (new WitSplitPt (this, theSelPt));
d337 2
a338 2
      else if (zeroPts_.contains (theSelPt->mySplitPt ()))
         continue;
d340 1
a340 1
      zeroPts_.push (theSelPt->mySplitPt ());
d342 2
a343 2
      addedZeroPts = true;
      }
d345 2
a346 2
   return addedZeroPts;
   }
d351 5
a355 5
   {
   bool         success;
   WitSplitPt * searchPt;
   bool         splitNeeded;
   double       flowGap;
d357 1
a357 1
   myFlowMonitor_->activate ();
d359 1
a359 1
   success = true;
d361 3
a363 3
   while (success)
      {
      stronglyAssert (zeroPts_.isNonEmpty ());
d365 1
a365 1
      searchPt = findLowestZeroPt ();
d367 1
a367 1
      zeroPts_.remove (searchPt);
d369 2
a370 2
      success = tempCommDiscZeroPts ();
      }
d372 2
a373 2
   splitNeeded =
      myFlowMonitor_->splitIsNeeded (searchPt->mySelPt (), false, flowGap);
d375 2
a376 2
   if (splitNeeded)
      searchForFlow (searchPt, flowGap);
d378 5
a382 5
   if (resAltOrRest ())
      splitChgPts ();
   else
      {
      success = mySelector_->myHeurAtor ()->tempCommit (1.0);
d384 2
a385 2
      stronglyAssert (not success);
      }
d387 2
a388 2
   myFlowMonitor_->deactivate ();
   }
d393 10
a402 10
   {
   if (mySelector_->failResAlt ())
      return true;

   else if (penExec_)
      return myPenExMgr ()->failRestShortOnly ();

   else
      return false;
   }
d407 3
a409 3
   {
   WitSplitPt * lowZeroPt;
   WitSplitPt * theZeroPt;
d411 1
a411 1
   WitObjStItr <WitSplitPt> theItr;
d413 1
a413 1
   stronglyAssert (zeroPts_.isNonEmpty ());
d415 1
a415 1
   zeroPts_.attachItr (theItr);
d417 1
a417 1
   theItr.advance (lowZeroPt);
d419 3
a421 3
   while (theItr.advance (theZeroPt))
      if (theZeroPt->isLowerThan (lowZeroPt))
         lowZeroPt = theZeroPt;
d423 2
a424 2
   return lowZeroPt;
   }
d429 5
a433 5
   {
   bool success;
   int  upperGP;
   int  lowerGP;
   int  midGP;
d435 1
a435 1
   success = tempCommForSearch (searchPt, splitRes_);
d437 1
a437 1
   mySplitCntr_->countBS (success);
d439 2
a440 2
   if (not success)
      return;
d442 2
a443 2
   lowerGP = 1;
   upperGP = static_cast <int> (ceil (theFlowVol / splitRes_));
d445 1
a445 1
   stronglyAssert (upperGP >= 2);
d447 3
a449 3
   while (upperGP - lowerGP > 1)
      {
      midGP   = (lowerGP + upperGP) / 2;
d451 1
a451 1
      success = tempCommForSearch (searchPt, midGP * splitRes_);
d453 6
a458 6
      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
      }
   }
d463 2
a464 2
   {
   bool success;
d466 1
a466 1
   searchPt->setNetSearchVol (searchVol);
d468 1
a468 1
   success = tempCommDiscZeroPts ();
d470 1
a470 1
   searchPt->clearNetSearchVol ();
d472 2
a473 2
   return success;
   }
d478 4
a481 4
   {
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theZeroPt;
   bool                     success;
d483 1
a483 1
   zeroPts_.attachItr (theItr);
d485 2
a486 2
   while (theItr.advance (theZeroPt))
      theZeroPt->setNetSearchVol (0.0);
d488 1
a488 1
   success = mySelector_->myHeurAtor ()->tempCommit (1.0);
d490 1
a490 1
   zeroPts_.attachItr (theItr);
d492 2
a493 2
   while (theItr.advance (theZeroPt))
      theZeroPt->clearNetSearchVol ();
d495 2
a496 2
   return success;
   }
d501 2
a502 2
   {
   WitSplitPt * theSplitPt;
d504 2
a505 2
   WitObjStack <WitSplitPt> chgSplitPts (myProblem ());
   WitObjStItr <WitSplitPt> theItr;
d507 1
a507 1
   mySplitCntr_->countBatch ();
d509 1
a509 1
   findChgSplitPts (chgSplitPts);
d511 1
a511 1
   chgSplitPts.attachItr (theItr);
d513 2
a514 2
   while (theItr.advance (theSplitPt))
      theSplitPt->activateTotFlowVol ();
d516 1
a516 1
   myFlowMonitor_->setTotFlowVols ();
d518 1
a518 1
   chgSplitPts.attachItr (theItr);
d520 3
a522 3
   while (theItr.advance (theSplitPt))
      {
      theSplitPt->splitSelAsNeeded ();
d524 3
a526 3
      theSplitPt->deactivateTotFlowVol ();
      }
   }
d531 2
a532 2
   {
   WitSelPt * theSelPt;
d534 1
a534 1
   WitObjStack <WitSelPt> chgSelPts (myProblem ());
d536 1
a536 1
   findHypoChanges (chgSelPts);
d538 4
a541 4
   while (chgSelPts.pop (theSelPt))
      {
      if (not theSelPt->isSplit ())
         mySplitPts_.push (new WitSplitPt (this, theSelPt));
d543 3
a545 3
      chgSplitPts.push (theSelPt->mySplitPt ());
      }
   }
d550 2
a551 2
   {
   WitSelPt * theSelPt;
d553 14
a566 14
   if (penExec_)
      findHypoChangesPE (chgSelPts);
   else
      {
      chgSelPts.clear ();

      if (mySelector_->pendingAlts ().isNonEmpty ())
         {
         theSelPt = mySelector_->pendingAlts ().firstObject ()->mySelPt ();

         chgSelPts.push (theSelPt);
         }
      }
   }
d571 36
a606 36
   {
   WitAltPt *             theAltPt;
   WitObjStack <WitSelPt> theModPts (myProblem ());
   WitSelPt *             altSelPt;
   WitSelPt *             modSelPt;

   stronglyAssert (penExec_);

   chgSelPts.clear ();

   if (mySelector_->pendingAlts ().isNonEmpty ())
      {
      theAltPt = mySelector_->pendingAlts ().firstObject ();

      theAltPt->tempAlterSel ();
      }
   else
      theAltPt = NULL;

   myPenExMgr ()->findHypoModPts (theModPts);

   if (theAltPt != NULL)
      {
      theAltPt->cancelTempAlt ();

      altSelPt = theAltPt->mySelPt ();

      chgSelPts.push (altSelPt);
      }
   else
      altSelPt = NULL;

   while (theModPts.pop (modSelPt))
      if (modSelPt != altSelPt)
         chgSelPts.push (modSelPt);
   }
d614 10
a623 10
      WitProbAssoc  (theSplitter),
      mySplitter_   (theSplitter),
      mySelPt_      (theSelPt),
      netSearchVol_ (-1.0),
      revSplitList_ (myProblem ()),
      netSplitList_ (myProblem ()),
      totFlowVol_   (-1.0)
   {
   mySelPt_->attachSplitPt (this);
   }
d628 7
a634 7
   {
   WitSelCand * theSelCand;
   double       splitBound;

   while (revSplitList_.pop (theSelCand, splitBound))
      {
      delete theSelCand;
d636 2
a637 2
      theSelCand = NULL;
      }
d639 2
a640 2
   mySelPt_->detachSplitPt ();
   }
d645 4
a648 4
   {
   WitPart *   thePart1;
   WitPeriod   thePer1;
   WitSelMgr * theSelMgr1;
d650 3
a652 3
   WitPart *   thePart2;
   WitPeriod   thePer2;
   WitSelMgr * theSelMgr2;
d654 1
a654 1
   witAssert (theSplitPt != NULL);
d656 2
a657 2
               mySelPt_->getSortData (thePart1, thePer1);
   theSplitPt->mySelPt_->getSortData (thePart2, thePer2);
d659 2
a660 2
   if (thePart1->sortedPartIndex () < thePart2->sortedPartIndex ())
      return true;
d662 2
a663 2
   if (thePart1->sortedPartIndex () > thePart2->sortedPartIndex ())
      return false;
d665 2
a666 2
   theSelMgr1 =             mySelPt_->mySelMgr ();
   theSelMgr2 = theSplitPt->mySelPt_->mySelMgr ();
d668 2
a669 2
   if (theSelMgr1->isLowerThan (theSelMgr2))
      return true;
d671 2
a672 2
   if (theSelMgr2->isLowerThan (theSelMgr1))
      return false;
d674 2
a675 2
   if (thePer1 > thePer2)
      return true;
d677 2
a678 2
   if (thePer1 < thePer2)
      return false;
d680 2
a681 2
   return false;
   }
d686 3
a688 3
   {
   witAssert (theVal        >= 0.0);
   witAssert (netSearchVol_ < -0.5);
d690 2
a691 2
   netSearchVol_ = theVal;
   }
d696 2
a697 2
   {
   witAssert (netSearchVol_ >= 0.0);
d699 2
a700 2
   netSearchVol_ = -1.0;
   }
d705 3
a707 3
   {
   netSplitList_.revCopyFrom (revSplitList_);
   }
d712 2
a713 2
   {
   WitSelCand * theSelCand;
d715 2
a716 2
   if (totFlowVol_ <= NET_TOL)
      return;
d718 1
a718 1
   theSelCand = mySelPt_->newSelCand ();
d720 1
a720 1
   revSplitList_.push (theSelCand, totFlowVol_);
d722 1
a722 1
   mySplitter_->mySplitCntr ()->countCurSplits ();
d724 3
a726 3
   if (selPrintLevelAt (3))
      prtSplitting (theSelCand, totFlowVol_);
   }
d731 5
a735 5
      double               totFlowVol,
      WitSelCandDblStack & theSplitPairs,
      double &             unbddVol)
   {
   double netFlowVol;
d737 1
a737 1
   witAssert (totFlowVol > 0.0);
d739 1
a739 1
   netFlowVol = totFlowVol;
d741 1
a741 1
   unbddVol = 0.0;
d743 1
a743 1
   theSplitPairs.clear ();
d745 3
a747 3
   while (netSplitList_.isNonEmpty ())
      {
      addNextPair (netFlowVol, theSplitPairs);
d749 3
a751 3
      if (netFlowVol == 0.0)
         return;
      }
d753 2
a754 2
   unbddVol = compUnbddVol (netFlowVol);
   }
d759 2
a760 2
   {
   stronglyAssert (totFlowVol_ < -0.5);
d762 2
a763 2
   totFlowVol_ = 0.0;
   }
d768 4
a771 4
   {
   if (totFlowVol_ > -0.5)
       totFlowVol_ += incFlowVol;
   }
d776 2
a777 2
   {
   stronglyAssert (totFlowVol_ >= 0.0);
d779 2
a780 2
   totFlowVol_ = -1.0;
   }
d785 3
a787 3
   {
   return (revSplitList_.isNonEmpty ());
   }
d792 12
a803 12
   {
   fprintf (msgFile (),
      "\n"
      "Splitting the %s Selection:\n",
      mySelPt_->mySelMgr ()->selCaseName ());

   mySelPt_->prtID ();

   theSelCand->prtID ();
               
   fprintf (msgFile (), "   Split Bound:      %.3f\n", splitBound);
   }
d808 24
a831 24
      double &             netFlowVol,
      WitSelCandDblStack & theSplitPairs)
   {
   WitSelCand * theSelCand;
   double       splitBound;
   double       splitVol;

   witAssert (netSplitList_.isNonEmpty ());

   netSplitList_.pop (theSelCand, splitBound);

   splitVol = min (splitBound, netFlowVol);
   
   if (selPrintLevelAt (3))
      prtSplitExp (theSelCand, splitVol, splitBound, true);

   netFlowVol -= splitVol;
   splitBound -= splitVol;

   if (netFlowVol <= NET_TOL)
      netFlowVol = 0.0;
   
   if (splitBound > NET_TOL)
      netSplitList_.push (theSelCand, splitBound);
d833 2
a834 2
   theSplitPairs.push (theSelCand, splitVol);
   }
d839 2
a840 2
   {
   double unbddVol;
d842 1
a842 1
   witAssert (netFlowVol > 0.0);
d844 1
a844 1
   unbddVol = netFlowVol;
d846 5
a850 5
   if (netSearchVol_ >= 0.0)
      {
      if (netSearchVol_ < unbddVol)
         {
         unbddVol      = netSearchVol_;
d852 1
a852 1
         netSearchVol_ = 0.0;
d854 6
a859 6
         if (unbddVol <= NET_TOL)
            return 0.0;
         }
      else
         netSearchVol_ -= unbddVol;
      }
d861 2
a862 2
   if (selPrintLevelAt (3))
      prtUnbddSplitExp (unbddVol);
d864 2
a865 2
   return unbddVol;
   }
d870 2
a871 2
   {
   WitSelCand * theSelCand;
d873 1
a873 1
   theSelCand = mySelPt_->newSelCand ();
d875 2
a876 2
   if (selPrintLevelAt (3))
      prtSplitExp (theSelCand, unbddVol, 0.0, false);
d878 2
a879 2
   delete theSelCand;
   }
d884 28
a911 28
      WitSelCand * theSelCand, 
      double       splitVol, 
      double       splitBound,
      bool         boundedSplit)
   {
   WitSelMgr * theSelMgr;

   if (not mySplitter_->mySelector ()->myHeurAtor ()->permCommActive ())
      return;

   theSelMgr = mySelPt_->mySelMgr ();

   fprintf (msgFile (),
      "\n"
      "Split Selection for %s:\n",
      theSelMgr->selCaseName ());

   mySelPt_->prtID ();

   theSelCand->prtID ();
               
   fprintf    (msgFile (), "   SplitVol:         %.3f\n", splitVol);
               
   if (boundedSplit)
      fprintf (msgFile (), "   Split Bound:      %.3f\n", splitBound);
   else
      fprintf (msgFile (), "   Split Bound:      None\n");
   }
d918 2
a919 2
   {
   }
d924 3
a926 3
   {
   stronglyAssert (false);
   }
d931 3
a933 3
   {
   stronglyAssert (false);
   }
d938 3
a940 3
   {
   stronglyAssert (false);
   }
d945 3
a947 3
   {
   stronglyAssert (false);
   }
d952 3
a954 3
   {
   stronglyAssert (false);
   }
d959 3
a961 3
   {
   stronglyAssert (false);
   }
d966 3
a968 3
      WitProbAssoc (theProblem)
   {
   }
d976 8
a983 8
      WitProbAssoc   (theHeurAtor),
      myHeurAtor_    (theHeurAtor),
      active_        (false),
       curFlowPairs_ (myProblem ()),
        okFlowPairs_ (myProblem ()),
      failFlowPairs_ (myProblem ())
   {
   }
d988 2
a989 2
   {
   }
d994 2
a995 2
   {
   stronglyAssert (not active_);
d997 2
a998 2
   active_ = true;
   }
d1003 2
a1004 2
   {
   stronglyAssert (active_);
d1006 3
a1008 3
    curFlowPairs_.clear ();
     okFlowPairs_.clear ();
   failFlowPairs_.clear ();
d1010 2
a1011 2
   active_ = false;
   }
d1016 2
a1017 2
   {
   witAssert (myHeurAtor_->tempCommActive ());
d1019 2
a1020 2
   if (not active_)
      return;
d1022 2
a1023 2
   if (not theSelPt->splittable ())
      return;
d1025 2
a1026 2
   if (theSelPt->mySelMgr ()->boundedSplit ())
      return;
d1028 2
a1029 2
   curFlowPairs_.push (theSelPt, incFlowVol);
   }
d1034 17
a1050 17
   {
   if (not active_)
      return;

   if (success)
      {
      okFlowPairs_.clear ();

      okFlowPairs_.takeContentsFrom (curFlowPairs_);
      }
   else
      {
      failFlowPairs_.clear ();

      failFlowPairs_.takeContentsFrom (curFlowPairs_);
      }
   }
d1055 8
a1062 8
      WitSelPt * theSelPt, 
      bool       compToSuccess,
      double &   flowGap)
   {
   stronglyAssert (active_);

   if (not theSelPt->splittable ())
      return false;
d1064 1
a1064 1
   flowGap = flowThruSelPt (theSelPt, failFlowPairs_);
d1066 2
a1067 2
   if (compToSuccess)
      flowGap -= flowThruSelPt (theSelPt, okFlowPairs_);
d1069 2
a1070 2
   return (flowGap > myGlobalComp ()->splitTol () + SEARCH_TOL);
   }
d1075 3
a1077 3
   {
   WitSelPt * theSelPt;
   double     incFlowVol;
d1079 1
a1079 1
   WitPairStItr <WitSelPt, double> theItr;
d1081 1
a1081 1
   stronglyAssert (active_);
d1083 1
a1083 1
   okFlowPairs_.attachItr (theItr);
d1085 4
a1088 4
   while (theItr.advance (theSelPt, incFlowVol))
      if (theSelPt->isSplit ())
         theSelPt->mySplitPt ()->incTotFlowVol (incFlowVol);
   }
d1093 6
a1098 6
      WitSelPt *               theSelPt,
      const WitSelPtDblStack & theFlowPairs)
   {
   double     flowVol;
   WitSelPt * curSelPt;
   double     incFlowVol;
d1100 1
a1100 1
   WitPairStItr <WitSelPt, double> theItr;
d1102 1
a1102 1
   stronglyAssert (theSelPt != NULL);
d1104 1
a1104 1
   flowVol = 0.0;
d1106 1
a1106 1
   theFlowPairs.attachItr (theItr);
d1108 3
a1110 3
   while (theItr.advance (curSelPt, incFlowVol))
      if (curSelPt == theSelPt)
         flowVol += incFlowVol;
d1112 2
a1113 2
   return flowVol;
   }
d1121 12
a1132 12
      WitProbAssoc       (theSelector),
      mySelector_        (theSelector),
      nCurSplits_        (0),
      nSplitsDone_       (0),
      nSplitsDiscarded_  (0),
      nSplitSplitComs_   (0),
      nUnsplitSplitComs_ (0),
      nBSsDone_          (0),
      nBSsSkipped_       (0),
      nBatches_          (0)
   {
   }
d1137 4
a1140 4
   {
   if (selPrintLevelAt (1))
      print ();
   }
d1145 4
a1148 4
   {
   if (selPrintLevelAt (1))
      nCurSplits_ = 0;
   }
d1153 4
a1156 4
   {
   if (selPrintLevelAt (1))
      nCurSplits_ ++;
   }
d1161 17
a1177 17
   {
   if (tempCommOK)
      {
      nSplitsDone_          += nCurSplits_;

      if (nCurSplits_ > 0)
         nSplitSplitComs_   ++;
      else
         nUnsplitSplitComs_ ++;
      }
   else
      {
      nSplitsDiscarded_     += nCurSplits_;

      nUnsplitSplitComs_    ++;
      }
   }
d1182 6
a1187 6
   {
   if (bsDone)
      nBSsDone_ ++;
   else
      nBSsSkipped_ ++;
   }
d1192 3
a1194 3
   {
   nBatches_ ++;
   }
d1199 20
a1218 20
   {
   fprintf (msgFile (), 
      "# SS BS's Done:         %7d\n"
      "# SS BS's Skipped:      %7d\n"
      "# Split Batches:        %7d\n"
      "# Splits Performed:     %7d\n"
      "# Splits Discarded:     %7d\n"
      "# Alts, Total:          %7d\n\n"
      "#   Split Split-Coms:   %7d\n"
      "# Unsplit Split-Coms:   %7d\n\n\n",

      nBSsDone_,
      nBSsSkipped_,
      nBatches_,
      nSplitsDone_,
      nSplitsDiscarded_,
      mySelector_->nAlts (),
      nSplitSplitComs_,
      nUnsplitSplitComs_);
   }
@


1.84
log
@Selection reuse.
@
text
@d257 2
a258 1
   mySplitCntr_->countSplits (tcOK);
d724 2
a725 1
   prtSplittingIA (theSelCand, totFlowVol_);
d791 1
a791 1
void WitSplitPt::prtSplittingIA (WitSelCand * theSelCand, double splitBound)
a792 3
   if (not selPrintLevelAt (3))
      return;

d821 2
a822 1
   prtSplitExpIA (theSelCand, splitVol, splitBound, true);
d861 2
a862 1
   prtUnbddSplitExpIA (unbddVol);
d869 1
a869 1
void WitSplitPt::prtUnbddSplitExpIA (double unbddVol)
a872 3
   if (not selPrintLevelAt (3))
      return;

d875 2
a876 1
   prtSplitExpIA (theSelCand, unbddVol, 0.0, false);
d883 1
a883 1
void WitSplitPt::prtSplitExpIA (
a890 3
   if (not selPrintLevelAt (3))
      return;

d1138 2
a1139 1
   print ();
a1161 3
   if (not selPrintLevelAt (1))
      return;

a1199 3
   if (not selPrintLevelAt (1))
      return;

@


1.83
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d791 1
a791 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d872 1
a872 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d892 1
a892 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d1149 1
a1149 1
   if (myGlobalComp ()->selPrintLevel () >= 1)
d1157 1
a1157 1
   if (myGlobalComp ()->selPrintLevel () >= 1)
d1165 1
a1165 1
   if (myGlobalComp ()->selPrintLevel () < 1)
d1206 1
a1206 1
   if (myGlobalComp ()->selPrintLevel () < 1)
@


1.82
log
@Stochastic Implosion
@
text
@d37 1
a37 1
#include <Global.h>
@


1.81
log
@ASAP Pegging Order
@
text
@a44 1
      WitProbAssoc     (theSelector->myProblem ()),
d46 1
a611 1
      WitProbAssoc  (theSplitter->myProblem ()),
d613 1
a978 1
      WitProbAssoc   (theHeurAtor->myProblem ()),
d980 1
a1123 1
      WitProbAssoc       (theSelector->myProblem ()),
d1125 1
@


1.80
log
@Heuristic search increment.
@
text
@d1046 1
a1046 1
      curFlowPairs_.passContentsTo (okFlowPairs_);
d1052 1
a1052 1
      curFlowPairs_.passContentsTo (failFlowPairs_);
@


1.79
log
@Heuristic search increment.
@
text
@d57 1
d68 6
a73 2
   if (myGlobalComp ()->heurSearchInc () != 1.0)
      myMsgFac () ("searchIncSelSplitSmsg");
@


1.78
log
@New PIP pegging order.
@
text
@d67 3
@


1.77
log
@New PIP pegging order.
@
text
@d1035 3
d1039 1
d1041 3
d1045 1
@


1.76
log
@Updated the copyright date on all source files.
@
text
@d1035 1
a1035 1
        okFlowPairs_.takeContents (curFlowPairs_);
d1037 1
a1037 1
      failFlowPairs_.takeContents (curFlowPairs_);
@


1.75
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.74
log
@[shared-resource pegging]
@
text
@d146 1
a146 1
   mySplitPts_.attach (theItr);
d406 1
a406 1
   zeroPts_.attach (theItr);
d474 1
a474 1
   zeroPts_.attach (theItr);
d481 1
a481 1
   zeroPts_.attach (theItr);
d502 1
a502 1
   chgSplitPts.attach (theItr);
d509 1
a509 1
   chgSplitPts.attach (theItr);
d1071 1
a1071 1
   okFlowPairs_.attach (theItr);
d1094 1
a1094 1
   theFlowPairs.attach (theItr);
@


1.73
log
@Revised mappingIndex code.
@
text
@d146 1
a146 1
   theItr.attachTo (mySplitPts_);
d406 1
a406 1
   theItr.attachTo (zeroPts_);
d474 1
a474 1
   theItr.attachTo (zeroPts_);
d481 1
a481 1
   theItr.attachTo (zeroPts_);
d502 1
a502 1
   theItr.attachTo (chgSplitPts);
d509 1
a509 1
   theItr.attachTo (chgSplitPts);
d1071 1
a1071 1
   theItr.attachTo (okFlowPairs_);
d1094 1
a1094 1
   theItr.attachTo (theFlowPairs);
@


1.72
log
@Pegged Critical List.
@
text
@a37 1
#include <MapIdxI.h>
@


1.71
log
@Pegged Critical List
@
text
@d65 1
a65 1
   if (myGlobalComp ()->pgdCritListNeeded ())
@


1.70
log
@Pegged Critical List.
@
text
@d65 1
a65 1
   if (myGlobalComp ()->compPgdCritList ())
@


1.69
log
@Tie breaking prop-rt.
@
text
@d62 6
@


1.68
log
@Low-Pri Prop-Rt.
@
text
@a32 1
#include <RtAn.h>
@


1.67
log
@Low-Pri Prop-Rt.
@
text
@d32 1
a32 1
#include <ExpRest.h>
d52 1
a52 2
      myExpRest_       (NULL),
      myRtAnalyzer_    (NULL),
d73 1
a73 4
      {
      myExpRest_    = theSelector->myExpRest ();
      myRtAnalyzer_ = theSelector->myRtAnalyzer ();
      }
d125 1
a125 1
            myExpRest ()->updatePsSup ();
d132 1
a132 1
      myExpRest ()->updatePsSup ();
d235 2
a236 3
         myExpRest ()   ->updatePsSup ();

         myRtAnalyzer ()->modifyRouting ();
d385 1
a385 1
      return myExpRest ()->failRestShortOnly ();
d577 1
a577 1
   myRtAnalyzer ()->findHypoModPts (theModPts);
@


1.66
log
@Low-Pri Prop-Rt.
@
text
@a63 7
#if 0

   if (myGlobalComp ()->lowPriPropRt ())
      myMsgFac () ("lpprWssNYISmsg");

#endif

@


1.65
log
@Low-Pri Prop-Rt.
@
text
@d64 2
d69 2
@


1.64
log
@Low-Pri Prop-Rt.
@
text
@d568 1
a569 2
   WitSelCand *           savedSelCand;
   WitObjStack <WitSelPt> theModPts (myProblem ());
a575 4
   theAltPt     = NULL;
   altSelPt     = NULL;
   savedSelCand = NULL;

a579 7
      altSelPt = theAltPt->mySelPt ();

      chgSelPts.push (altSelPt);

      if (theAltPt->cancelNeedsSelCand ())
         savedSelCand = altSelPt->newSelCand ();

d582 2
d589 3
a591 1
      theAltPt->cancelTempAlt (savedSelCand);
d593 1
a593 1
      delete savedSelCand;
d595 2
@


1.63
log
@Low-Pri Prop-Rt.
@
text
@d567 5
a571 9
   WitAltPt *   theAltPt;
   WitSelPt *   altSelPt;
   WitSelCand * savedSelCand;
   WitRtCand *  theRtCand;
   WitPeriod    thePer;
   WitRtSite *  theRtSite;
   WitSelPt *   modSelPt;

   WitRtCandPerStack theMrMods (myProblem ());
d595 1
a595 7
   myExpRest ()   ->startTempMode ();

   myExpRest ()   ->updatePsSup ();

   myRtAnalyzer ()->findRoutingMods (theMrMods);

   myExpRest ()   ->finishTempMode ();
d604 1
a604 6
   while (theMrMods.pop (theRtCand, thePer))
      {
      theRtSite = theRtCand->myRtSite ();

      modSelPt  = mySelector_->myMrMgr ()->mySelPtFor (theRtSite, thePer);

a606 1
      }
@


1.62
log
@Low-Pri Prop-Rt.
@
text
@d913 1
a913 1
   if (mySplitter_->mySelector ()->myHeurAtor ()->tempMode ())
d1039 1
a1039 1
   witAssert (myHeurAtor_->tempMode ());
@


1.61
log
@Low-Pri Prop-Rt.
@
text
@d821 1
a821 1
   fprintf (msgFile (), "      Split Bound:   %.3f\n", splitBound);
d927 1
a927 1
   fprintf    (msgFile (), "      SplitVol:      %.3f\n", splitVol);
d930 1
a930 1
      fprintf (msgFile (), "      Split Bound:   %.3f\n", splitBound);
d932 1
a932 1
      fprintf (msgFile (), "      Split Bound:   None\n");
@


1.60
log
@Low-Pri Prop-Rt.
@
text
@d579 6
d587 1
a587 1
      theAltPt     = mySelector_->pendingAlts ().firstObject ();
d589 1
a589 1
      altSelPt     = theAltPt->mySelPt ();
d591 4
a594 1
      savedSelCand = altSelPt->newSelCand ();
a597 2
   else
      altSelPt = NULL;
d607 6
a612 1
   chgSelPts.clear ();
d620 2
a621 13
      chgSelPts.push (modSelPt);
      }

   if (altSelPt != NULL)
      {
      altSelPt->restoreSelTo (savedSelCand);

      delete savedSelCand;

      savedSelCand = NULL;

      if (not chgSelPts.contains (altSelPt))
         chgSelPts.push (altSelPt);
@


1.59
log
@Low-Pri Prop-Rt.
@
text
@d979 7
@


1.58
log
@Low-Pri Prop-Rt.
@
text
@d17 1
d935 50
@


1.57
log
@Low-Pri Prop-Rt.
@
text
@d612 1
a612 1
      savedSelCand->restoreSelToThis ();
@


1.56
log
@Low-Pri Prop-Rt.
@
text
@d635 1
a635 2
      totFlowVol_   (-1.0),
      unbddCand_    (NULL)
a653 7
   if (unbddCand_ != NULL)
      {
      delete unbddCand_;

      unbddCand_ = NULL;
      }

d747 1
a747 1
      bool &               lastUnbdd)
d755 2
a763 3
         {
         lastUnbdd = false;

a764 1
         }
d767 1
a767 1
   defUnbddSplit (netFlowVol, theSplitPairs, lastUnbdd);
d854 1
a854 4
void WitSplitPt::defUnbddSplit (
      double               netFlowVol,
      WitSelCandDblStack & theSplitPairs,
      bool &               lastUnbdd)
d856 2
d860 2
d864 1
a864 1
      if (netSearchVol_ < netFlowVol)
d866 1
a866 1
         netFlowVol    = netSearchVol_;
d870 2
a871 6
         if (netFlowVol <= NET_TOL)
            {
            lastUnbdd = false;

            return;
            }
d874 1
a874 1
         netSearchVol_ -= netFlowVol;
d877 13
a889 4
   if (unbddCand_ == NULL)
      unbddCand_ = mySelPt_->newSelCand ();
   else
      unbddCand_->updateToCurSel ();
d891 1
a891 1
   theSplitPairs.push (unbddCand_, netFlowVol);
d893 1
a893 1
   lastUnbdd = true;
d895 1
a895 1
   prtSplitExpIA (unbddCand_, netFlowVol, 0.0, false);
@


1.55
log
@Low-Pri Prop-Rt.
@
text
@d28 1
a28 1
#include <SelAlt.h>
d566 1
a566 1
   WitSelAlt *  theSelAlt;
d580 1
a580 1
      theSelAlt    = mySelector_->pendingAlts ().firstObject ();
d582 1
a582 1
      altSelPt     = theSelAlt->mySelPt ();
d586 1
a586 1
      theSelAlt->tempAlterSel ();
@


1.54
log
@Low-Pri Prop-Rt.
@
text
@a33 2
#include <PoMgr.h>
#include <PrMgr.h>
d574 1
a574 2
   WitRtCandPerStack theMrMods   (myProblem ());
   WitRtCandPerStack theLpprMods (myProblem ());
d595 1
a595 1
   myRtAnalyzer ()->findRoutingMods (theMrMods, theLpprMods);
a609 11
   if (mySelector_->lpprMode ())
      while (theLpprMods.pop (theRtCand, thePer))
         {
         if (myGlobalComp ()->newPropRt ())
            modSelPt = mySelector_->myPrMgr ()->mySelPtFor (theRtCand, thePer);
         else
            modSelPt = mySelector_->myPoMgr ()->mySelPtFor (theRtCand, thePer);

         chgSelPts.push (modSelPt);
         }

@


1.53
log
@Low-Pri Prop-Rt.
@
text
@d35 1
d616 4
a619 1
         modSelPt = mySelector_->myPoMgr ()->mySelPtFor (theRtCand, thePer);
@


1.52
log
@Low-Pri Prop-Rt.
@
text
@d567 1
d582 3
a584 1
      altSelPt     = mySelector_->pendingAlts ().firstObject ()->mySelPt ();
d588 1
a588 1
      altSelPt->tempAlterSel ();
@


1.51
log
@Low-Pri Prop-Rt.
@
text
@d28 1
d546 2
d554 6
a559 2
      if (mySelector_->pendingPts ().isNonEmpty ())
         chgSelPts.push (mySelector_->pendingPts ().firstObject ());
d579 1
a579 1
   if (mySelector_->pendingPts ().isNonEmpty ())
d581 1
a581 1
      altSelPt     = mySelector_->pendingPts ().firstObject ();
@


1.50
log
@Low-Pri Prop-Rt.
@
text
@d576 1
a576 1
      savedSelCand = altSelPt->mySelMgr ()->freshSelCand (altSelPt);
d614 3
a616 1
      savedSelCand->deactivate ();
d649 5
a653 1
      theSelCand->deactivate ();
d656 5
a660 1
      unbddCand_->deactivate ();
d741 1
a741 1
   theSelCand = mySelPt_->mySelMgr ()->freshSelCand (mySelPt_);
d891 1
a891 1
      unbddCand_ = mySelPt_->mySelMgr ()->freshSelCand (mySelPt_);
d893 1
a893 1
      mySelPt_->setToMyCurSel (unbddCand_);
@


1.49
log
@Low-Pri Prop-Rt.
@
text
@d612 1
a612 1
      altSelPt->restoreSel (savedSelCand);
@


1.48
log
@Low-Pri Prop-Rt.
@
text
@d576 1
a576 3
      savedSelCand = altSelPt->mySelMgr ()->freshSelCand ();

      altSelPt->setToMyCurSel (savedSelCand);
a635 2
   unbddCand_ = mySelPt_->mySelMgr ()->freshSelCand ();

d649 2
a650 1
   unbddCand_->deactivate ();
d731 1
a731 3
   theSelCand = mySelPt_->mySelMgr ()->freshSelCand ();

   mySelPt_->setToMyCurSel (theSelCand);
d880 4
a883 1
   mySelPt_->setToMyCurSel (unbddCand_);
@


1.47
log
@Low-Pri Prop-Rt.
@
text
@d578 1
a578 1
      altSelPt->setToCurSel (savedSelCand);
d736 1
a736 1
   mySelPt_->setToCurSel (theSelCand);
d885 1
a885 1
   mySelPt_->setToCurSel (unbddCand_);
@


1.46
log
@Low-Pri Prop-Rt.
@
text
@d576 1
a576 1
      savedSelCand = altSelPt->mySelMgr ()->unusedSelCand ();
d616 1
a616 1
      savedSelCand->recycle ();
d638 1
a638 1
   unbddCand_ = mySelPt_->mySelMgr ()->unusedSelCand ();
d651 1
a651 1
      theSelCand->recycle ();
d653 1
a653 1
   unbddCand_->recycle ();
d734 1
a734 1
   theSelCand = mySelPt_->mySelMgr ()->unusedSelCand ();
@


1.45
log
@Low-Pri Prop-Rt.
@
text
@d576 3
a578 1
      savedSelCand = altSelPt->curSelCand ();
d616 2
d635 2
a636 1
      totFlowVol_   (-1.0)
d638 2
d647 8
d729 2
d734 5
a738 1
   revSplitList_.push (mySelPt_->curSelCand (), totFlowVol_);
d742 1
a742 1
   prtSplittingIA (totFlowVol_);
d810 1
a810 1
void WitSplitPt::prtSplittingIA (double splitBound)
d822 1
a822 1
   mySelPt_->curSelCand ()->prtID ();
d885 3
a887 1
   theSplitPairs.push (mySelPt_->curSelCand (), netFlowVol);
d891 1
a891 1
   prtSplitExpIA (mySelPt_->curSelCand (), netFlowVol, 0.0, false);
@


1.44
log
@Low-Pri Prop-Rt.
@
text
@d15 1
d21 1
a23 1
#include <SplitCntr.h>
d27 1
d29 5
a33 1
#include <SelPt.h>
d35 2
d38 580
a617 1
#include <Part.h>
@


1.43
log
@Continued implementation of proportionate routing.
@
text
@d130 1
a130 1
   revSplitList_.push (mySelPt_->selSelCand (), totFlowVol_);
d214 1
a214 1
   mySelPt_->selSelCand ()->prtID ();
d277 1
a277 1
   theSplitPairs.push (mySelPt_->selSelCand (), netFlowVol);
d281 1
a281 1
   prtSplitExpIA (mySelPt_->selSelCand (), netFlowVol, 0.0, false);
@


1.42
log
@Continued implementation of proportionate routing.
@
text
@d256 2
@


1.41
log
@Continued implementation of proportionate routing.
@
text
@d37 1
a37 1
      WitProbAssoc   (theSplitter->myProblem ()),
d39 6
a44 7
      mySplitter_    (theSplitter),
      mySelPt_       (theSelPt),
      netSearchVol_  (-1.0),
      revSplitList_  (myProblem ()),
      netSplitList_  (myProblem ()),
      netToSplitVol_ (0.0),
      totFlowVol_    (-1.0)
a138 42
void WitSplitPt::startSplitExp (double toSplitVol)
   {
   stronglyAssert (toSplitVol > NET_TOL);

   netToSplitVol_ = toSplitVol;
   }

//------------------------------------------------------------------------------

bool WitSplitPt::findNextSplit (
      WitSelCand * & theSelCand,
      double &       splitVol,
      bool &         boundedSplit)
   {
   double splitBound;

   if (netToSplitVol_ == 0.0)
      return false;

   boundedSplit = netSplitList_.pop (theSelCand, splitBound);

   if (not boundedSplit)
      return defUnboundedSplit (theSelCand, splitVol);

   splitVol = min (splitBound, netToSplitVol_);
   
   prtSplitExpIA (theSelCand, splitVol, splitBound, true);

   netToSplitVol_ -= splitVol;
   splitBound     -= splitVol;

   if (netToSplitVol_ <= NET_TOL)
      netToSplitVol_ = 0.0;
   
   if (splitBound > NET_TOL)
      netSplitList_.push (theSelCand, splitBound);
   
   return true;
   }

//------------------------------------------------------------------------------

a216 27
   }

//------------------------------------------------------------------------------

bool WitSplitPt::defUnboundedSplit (
      WitSelCand * & theSelCand, 
      double &       splitVol)
   {
   theSelCand     = mySelPt_->selSelCand ();
   splitVol       = netToSplitVol_;
   netToSplitVol_ = 0.0;

   if (netSearchVol_ >= 0.0)
      {
      if (netSearchVol_ < splitVol)
         {
         splitVol       = netSearchVol_;

         netSearchVol_  = 0.0;
         }
      else
         netSearchVol_ -= splitVol;
      }

   prtSplitExpIA (theSelCand, splitVol, 0.0, false);

   return (splitVol > 0.0);
@


1.40
log
@Continued implementation of proportionate routing.
@
text
@a44 1
      boundedSplit_  (false),
d149 4
a152 1
bool WitSplitPt::findNextSplit (WitSelCand * & theSelCand, double & splitVol)
d159 1
a159 1
   boundedSplit_ = netSplitList_.pop (theSelCand, splitBound);
d161 1
a161 1
   if (not boundedSplit_)
d166 1
a166 1
   prtSplitExpIA (theSelCand, splitVol, splitBound);
d174 1
a174 3
   if (splitBound <= NET_TOL)
      splitBound = 0.0;
   else 
d182 4
a185 1
void WitSplitPt::finishSplitExp ()
d187 21
a207 1
   boundedSplit_ = false;
d284 1
a284 1
   prtSplitExpIA (theSelCand, splitVol, 0.0);
d291 63
d357 2
a358 1
      double       splitBound)
d381 3
a383 1
   if (not boundedSplit_)
a384 2
   else
      fprintf (msgFile (), "      Split Bound:   %.3f\n", splitBound);
d442 2
a443 3
   if (theSelPt->isSplit ())
      if (theSelPt->mySplitPt ()->boundedSplit ())
         return;
@


1.39
log
@Continued implementation of proportionate routing.
@
text
@d236 1
a236 1
   fprintf (msgFile (), "   Split Bound: %.3f\n", splitBound);
d292 1
a292 1
   fprintf    (msgFile (), "   SplitVol:    %.3f\n", splitVol);
d295 1
a295 1
      fprintf (msgFile (), "   Split Bound: None\n");
d297 1
a297 1
      fprintf (msgFile (), "   Split Bound: %.3f\n", splitBound);
@


1.38
log
@Internal changes.
@
text
@d37 1
a37 1
      WitProbAssoc   (theSplitter),
d305 1
a305 1
      WitProbAssoc   (theHeurAtor),
d443 1
a443 1
      WitProbAssoc       (theSelector),
@


1.37
log
@Internal changes.
@
text
@d159 1
a159 1
   if (! boundedSplit_)
d294 1
a294 1
   if (! boundedSplit_)
d325 1
a325 1
   stronglyAssert (! active_);
d349 1
a349 1
   if (! active_)
d352 1
a352 1
   if (! theSelPt->splittable ())
d366 1
a366 1
   if (! active_)
d384 1
a384 1
   if (! theSelPt->splittable ())
@


1.36
log
@Fixed a bug in selection splitting discovered by Fukunaga.
@
text
@d45 1
a45 1
      boundedSplit_  (witFALSE),
d60 1
a60 1
WitBoolean WitSplitPt::isLowerThan (WitSplitPt * theSplitPt)
d76 1
a76 1
      return witTRUE;
d79 1
a79 1
      return witFALSE;
d85 1
a85 1
      return witTRUE;
d88 1
a88 1
      return witFALSE;
d91 1
a91 1
      return witTRUE;
d94 1
a94 1
      return witFALSE;
d96 1
a96 1
   return witFALSE;
d150 1
a150 3
WitBoolean WitSplitPt::findNextSplit (
      WitSelCand * & theSelCand, 
      double &       splitVol)
d155 1
a155 1
      return witFALSE;
d177 1
a177 1
   return witTRUE;
d184 1
a184 1
   boundedSplit_ = witFALSE;
d215 1
a215 1
WitBoolean WitSplitPt::hasSplits ()
d241 1
a241 1
WitBoolean WitSplitPt::defUnboundedSplit (
d308 1
a308 1
      active_        (witFALSE),
d327 1
a327 1
   active_ = witTRUE;
d340 1
a340 1
   active_ = witFALSE;
d364 1
a364 1
void WitFlowMonitor::postTempCommit (WitBoolean success)
d377 1
a377 1
WitBoolean WitFlowMonitor::splitIsNeeded (
d379 1
a379 1
      WitBoolean compToSuccess,
d385 1
a385 1
      return witFALSE;
d482 1
a482 1
void WitSplitCntr::countSplits (WitBoolean tempCommOK)
d506 1
a506 1
void WitSplitCntr::countBS (WitBoolean bsDone)
@


1.35
log
@Continued preliminary work on single source.
@
text
@d306 2
a307 2
WitFlowMonitor::WitFlowMonitor (WitProblem * theProblem):
      WitProbAssoc   (theProblem),
d309 1
d338 1
d349 2
@


1.34
log
@Began implementation of object iteration.
@
text
@d30 1
@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@d29 1
@


1.32
log
@Continued implementation of sel-split for pen-exec.
@
text
@d15 2
a16 1
//    Splitter
a17 769
//    SplitPt
//------------------------------------------------------------------------------

#include <SplitCntr.h>
#include <SplitPt.h>
#include <Splitter.h>
#include <Selector.h>
#include <SelMgr.h>
#include <SelCand.h>
#include <SelPt.h>
#include <ExpRest.h>
#include <RtAn.h>
#include <PmrMgr.h>
#include <CmrMgr.h>
#include <HeurAtor.h>
#include <Archive.h>

//------------------------------------------------------------------------------
// Implementation of class Splitter.
//------------------------------------------------------------------------------

WitSplitter::WitSplitter (WitSelector * theSelector):
      WitProbAssoc     (theSelector),

      mySelector_      (theSelector),
      mySplitCntr_     (NULL),
      myExpRest_       (NULL),
      myRtAnalyzer_    (NULL),
      penExec_         (witFALSE),
      splitRes_        (myGlobalComp ()->splitRes ()),
      zeroPts_         (myProblem ()),
      splitCommActive_ (witFALSE),
      flowMonMode_     (witFALSE),
       curFlowPairs_   (myProblem ()),
        okFlowPairs_   (myProblem ()),
      failFlowPairs_   (myProblem ()),
      mySplitPts_      (myProblem ())
   {
   WitSelMgr * theSelMgr;

   myMsgFac () ("selSplitMsg");

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->setUpSelSplit ();

   mySplitCntr_ = new WitSplitCntr (theSelector);

   penExec_ = mySelector_->penExec ();

   if (penExec_)
      {
      if (! myGlobalComp ()->allowSSPE ())
         myMsgFac () ("ssPeNotAllowedSMsg");

      myExpRest_    = theSelector->myExpRest ();
      myRtAnalyzer_ = theSelector->myRtAnalyzer ();
      }
   }

//------------------------------------------------------------------------------

WitSplitter::~WitSplitter ()
   {
   delete mySplitCntr_;
   }

//------------------------------------------------------------------------------

void WitSplitter::commitMaxQty (double & netQty)
   {
   WitBoolean scNeeded;
   WitBoolean unresFound;
   WitSelPt * theSelPt;

   while (witTRUE)
      {
      mySelector_->resetResAlt ();

      if (penExec_)
         myRtAnalyzer ()->modifyRouting ();

      startFlowMon ();

      mySelector_->myHeurAtor ()->commitMaxQtySel (netQty);

      if ((netQty <= 0.0) || ! resAltOrRest ())
         {
         finishFlowMon ();

         break;
         }

      scNeeded = splitCommitNeeded ();
      
      finishFlowMon ();

      if (scNeeded)
         if (! mySelector_->myHeurAtor ()->failedOn1 ())
            if (mySelector_->myHeurAtor ()->tempCommit (1.0))
               scNeeded = witFALSE;

      if (scNeeded)
         {
         splitCommit (unresFound);

         if (unresFound)
            break;
         }
      else
         {
         if (penExec_)
            myExpRest ()->updatePsSup ();

         if (mySelector_->getPendingPt (theSelPt))
            mySelector_->alterSelection (theSelPt);
         }
      }

   if (penExec_)
      myExpRest ()->updatePsSup ();
   }

//------------------------------------------------------------------------------

void WitSplitter::preCommit ()
   {
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theSplitPt;

   theItr.attachTo (mySplitPts_);

   while (theItr.advance (theSplitPt))
      theSplitPt->initNetSplitList ();
   }

//------------------------------------------------------------------------------

void WitSplitter::postTempCommit (WitBoolean success)
   {
   if (flowMonMode_)
      {
      if (success)
           okFlowPairs_.takeContents (curFlowPairs_);
      else
         failFlowPairs_.takeContents (curFlowPairs_);
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::recordFlow (WitSelPt * theSelPt, double incFlowVol)
   {
   if (! flowMonMode_)
      return;

   if (! theSelPt->splittable ())
      return;

   if (theSelPt->isSplit ())
      if (theSelPt->mySplitPt ()->boundedSplit ())
         return;

   curFlowPairs_.push (theSelPt, incFlowVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::splitCommitNeeded ()
   {
   WitSelPt * theSelPt;
   double     flowGap;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      if (splitIsNeeded (theSelPt, witTRUE, flowGap))
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitSplitter::splitCommit (WitBoolean & unresFound)
   {
   int         nItrs;
   WitBoolean  tcOK;
   WitBoolean  splitFound;
   WitSelPt *  theSelPt;
   WitSelMgr * theSelMgr;

   unresFound       = witFALSE;
   nItrs            = 0;
   tcOK             = witFALSE;
   splitCommActive_ = witTRUE;

   mySplitCntr_->initCurSplits ();

   while (! tcOK)
      {
      nItrs ++;

      if (nItrs > myGlobalComp ()->splitItrUB ())
         break;

      buildZeroPts (unresFound, splitFound);

      if (unresFound)
         break;

      if (splitFound)
         splitSels ();

      clearSplitItr ();

      stronglyAssert (resAltOrRest ());

      if (mySelector_->getPendingPt (theSelPt))
         mySelector_->alterSelection (theSelPt);

      if (penExec_)
         {
         myExpRest ()   ->updatePsSup ();

         myRtAnalyzer ()->modifyRouting ();
         }

      tcOK = mySelector_->myHeurAtor ()->tempCommit (1.0);
      }

   if (tcOK)
      mySelector_->myHeurAtor ()->permCommit1SS ();

   mySplitCntr_->countSplits (tcOK);

   splitCommActive_ = witFALSE;

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->postSplitCommit ();

   deleteContents (mySplitPts_);
   }

//------------------------------------------------------------------------------

void WitSplitter::buildZeroPts (
      WitBoolean & unresFound, 
      WitBoolean & splitFound)
   {
   WitBoolean addedZeroPts;

   stronglyAssert (zeroPts_.isEmpty ());

   unresFound = witFALSE;
   splitFound = witFALSE;

   while (! splitFound)
      {
      unresFound = ! resAltOrRest ();

      if (unresFound)
         {
         clearSplitItr ();

         return;
         }

      addedZeroPts = addChgPtsToZeroPts ();

      if (! addedZeroPts)
         return;

      splitFound = tempCommDiscZeroPts ();
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::clearSplitItr ()
   {
   WitObjStack <WitSplitPt> revSplitPts (myProblem ());
   WitSplitPt *             theSplitPt;

   zeroPts_.clear ();

   mySplitPts_.revCopyInto (revSplitPts);

   mySplitPts_.clear ();

   while (revSplitPts.pop (theSplitPt))
      if (theSplitPt->hasSplits ())
         mySplitPts_.push (theSplitPt);
      else
         delete theSplitPt;
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::addChgPtsToZeroPts ()
   {
   WitBoolean addedZeroPts;
   WitSelPt * theSelPt;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   addedZeroPts = witFALSE;

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      {
      if (! theSelPt->isSplit ())
         mySplitPts_.push (new WitSplitPt (this, theSelPt));

      else if (zeroPts_.contains (theSelPt->mySplitPt ()))
         continue;

      zeroPts_.push (theSelPt->mySplitPt ());

      addedZeroPts = witTRUE;
      }

   return addedZeroPts;
   }

//------------------------------------------------------------------------------

void WitSplitter::splitSels ()
   {
   WitBoolean   success;
   WitSplitPt * searchPt;
   WitBoolean   splitNeeded;
   double       flowGap;
   double       splitBound;

   startFlowMon ();

   success = witTRUE;

   while (success)
      {
      stronglyAssert (zeroPts_.isNonEmpty ());

      searchPt = findLowestZeroPt ();

      zeroPts_.remove (searchPt);

      success = tempCommDiscZeroPts ();
      }

   splitNeeded = splitIsNeeded (searchPt->mySelPt (), witFALSE, flowGap);

   if (splitNeeded)
      splitBound = findSplitBound (searchPt, flowGap);
   else
      splitBound = 0.0;

   if (resAltOrRest ())
      splitChgPts (searchPt, splitBound);
   else
      {
      success = mySelector_->myHeurAtor ()->tempCommit (1.0);

      stronglyAssert (! success);
      }

   finishFlowMon ();
   }

//------------------------------------------------------------------------------

void WitSplitter::startFlowMon ()
   {
   stronglyAssert (! flowMonMode_);

   flowMonMode_ = witTRUE;
   }

//------------------------------------------------------------------------------

void WitSplitter::finishFlowMon ()
   {
   stronglyAssert (flowMonMode_);

     okFlowPairs_.clear ();
   failFlowPairs_.clear ();

   flowMonMode_ = witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::splitIsNeeded (
      WitSelPt * theSelPt, 
      WitBoolean compToSuccess,
      double &   flowGap)
   {
   stronglyAssert (flowMonMode_);

   if (! theSelPt->splittable ())
      return witFALSE;

   flowGap = flowThruSelPt (theSelPt, failFlowPairs_);

   if (compToSuccess)
      flowGap -= flowThruSelPt (theSelPt, okFlowPairs_);

   return (flowGap > myGlobalComp ()->splitTol () + SEARCH_TOL);
   }

//------------------------------------------------------------------------------

double WitSplitter::flowThruSelPt (
      WitSelPt *               theSelPt,
      const WitSelPtDblStack & theFlowPairs)
   {
   double                          flowVol;
   WitPairStItr <WitSelPt, double> theItr;
   WitSelPt *                      curSelPt;
   double                          incFlowVol;

   stronglyAssert (theSelPt != NULL);

   flowVol = 0.0;

   theItr.attachTo (theFlowPairs);

   while (theItr.advance (curSelPt, incFlowVol))
      if (curSelPt == theSelPt)
         flowVol += incFlowVol;

   return flowVol;
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::resAltOrRest ()
   {
   if (mySelector_->failResAlt ())
      return witTRUE;

   else if (penExec_)
      return myExpRest ()->failRestShortOnly ();

   else
      return witFALSE;
   }

//------------------------------------------------------------------------------

WitSplitPt * WitSplitter::findLowestZeroPt ()
   {
   WitSplitPt * lowZeroPt;
   WitSplitPt * theZeroPt;

   WitObjStItr <WitSplitPt> theItr;

   stronglyAssert (zeroPts_.isNonEmpty ());

   theItr.attachTo (zeroPts_);

   theItr.advance (lowZeroPt);

   while (theItr.advance (theZeroPt))
      if (theZeroPt->isLowerThan (lowZeroPt))
         lowZeroPt = theZeroPt;

   return lowZeroPt;
   }

//------------------------------------------------------------------------------

double WitSplitter::findSplitBound (WitSplitPt * searchPt, double theFlowVol)
   {
   WitBoolean success;
   double     splitBound;

   success = tempCommForSearch (searchPt, splitRes_);

   if (success)
      splitBound = binarySearch (searchPt, theFlowVol);
   else
      splitBound = 0.0;

   mySplitCntr_->countBS (success);

   return splitBound;
   }

//------------------------------------------------------------------------------

double WitSplitter::binarySearch (WitSplitPt * searchPt, double theFlowVol)
   {
   int        upperGP;
   int        lowerGP;
   int        midGP;
   WitBoolean success;

   lowerGP  = 1;
   upperGP  = ceil (theFlowVol / splitRes_);

   stronglyAssert (upperGP >= 2);

   while (upperGP - lowerGP > 1)
      {
      midGP   = (lowerGP + upperGP) / 2;

      success = tempCommForSearch (searchPt, midGP * splitRes_);

      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
      }

   return (lowerGP * splitRes_);
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::tempCommForSearch (
      WitSplitPt * searchPt, 
      double       searchVol)
   {
   WitBoolean success;

   searchPt->setNetSearchVol (searchVol);

   success = tempCommDiscZeroPts ();

   searchPt->clearNetSearchVol ();

   return success;
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::tempCommDiscZeroPts ()
   {
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theZeroPt;
   WitBoolean               success;

   theItr.attachTo (zeroPts_);

   while (theItr.advance (theZeroPt))
      theZeroPt->setNetSearchVol (0.0);

   success = mySelector_->myHeurAtor ()->tempCommit (1.0);

   theItr.attachTo (zeroPts_);

   while (theItr.advance (theZeroPt))
      theZeroPt->clearNetSearchVol ();

   return success;
   }

//------------------------------------------------------------------------------

void WitSplitter::splitChgPts (WitSplitPt * searchPt, double splitBound)
   {
   WitSplitPt * theSplitPt;
   WitSelPt *   theSelPt;
   double       incFlowVol;

   WitObjStack  <WitSplitPt>       chgSplitPts (myProblem ());
   WitObjStItr  <WitSplitPt>       theSplitPtItr;
   WitPairStItr <WitSelPt, double> thePairItr;

   mySplitCntr_->countBatch ();

   findChgSplitPts (chgSplitPts);

   theSplitPtItr.attachTo (chgSplitPts);

   while (theSplitPtItr.advance (theSplitPt))
      theSplitPt->activateTotFlowVol ();

   thePairItr.attachTo (okFlowPairs_);

   while (thePairItr.advance (theSelPt, incFlowVol))
      if (theSelPt->isSplit ())
         theSelPt->mySplitPt ()->incTotFlowVol (incFlowVol);

   theSplitPtItr.attachTo (chgSplitPts);

   while (theSplitPtItr.advance (theSplitPt))
      {
      theSplitPt->splitSelAsNeeded ();

      theSplitPt->deactivateTotFlowVol ();
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::findChgSplitPts (WitObjStack <WitSplitPt> & chgSplitPts)
   {
   WitSelPt * theSelPt;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      {
      if (! theSelPt->isSplit ())
         mySplitPts_.push (new WitSplitPt (this, theSelPt));

      chgSplitPts.push (theSelPt->mySplitPt ());
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::findHypoChanges (WitObjStack <WitSelPt> & chgSelPts)
   {
   if (penExec_)
      findHypoChangesPE (chgSelPts);
   else
      {
      chgSelPts.clear ();

      if (mySelector_->pendingPts ().isNonEmpty ())
         chgSelPts.push (mySelector_->pendingPts ().firstObject ());
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::findHypoChangesPE (WitObjStack <WitSelPt> & chgSelPts)
   {
   WitSelPt *     altSelPt;
   WitSelCand *   savedSelCand;
   WitBopEntry *  theBopEnt;
   WitPeriod      thePer;
   WitConsEntry * theConsEnt;
   WitSelPt *     modSelPt;

   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());

   stronglyAssert (penExec_);

   if (mySelector_->pendingPts ().isNonEmpty ())
      {
      altSelPt     = mySelector_->pendingPts ().firstObject ();

      savedSelCand = altSelPt->selSelCand ();

      altSelPt->tempAlterSel ();
      }
   else
      altSelPt = NULL;

   myExpRest ()   ->startTempMode ();

   myExpRest ()   ->updatePsSup ();

   myRtAnalyzer ()->findRoutingMods (modBopEntPers, modConsEntPers);

   myExpRest ()   ->finishTempMode ();

   chgSelPts.clear ();

   while (modBopEntPers.pop (theBopEnt, thePer))
      {
      modSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);

      chgSelPts.push (modSelPt);
      }

   while (modConsEntPers.pop (theConsEnt, thePer))
      {
      modSelPt =
         mySelector_->myCmrMgr ()->mySelPt (theConsEnt->myBomEnt (), thePer);

      chgSelPts.push (modSelPt);
      }

   if (altSelPt != NULL)
      {
      altSelPt->restoreSel (savedSelCand);

      if (! chgSelPts.contains (altSelPt))
         chgSelPts.push (altSelPt);
      }
   }

//------------------------------------------------------------------------------
// Implementation of class SplitCntr.
//------------------------------------------------------------------------------

WitSplitCntr::WitSplitCntr (WitSelector * theSelector):
      WitProbAssoc       (theSelector),

      mySelector_        (theSelector),
      nCurSplits_        (0),
      nSplitsDone_       (0),
      nSplitsDiscarded_  (0),
      nSplitSplitComs_   (0),
      nUnsplitSplitComs_ (0),
      nBSsDone_          (0),
      nBSsSkipped_       (0),
      nBatches_          (0)
   {
   }

//------------------------------------------------------------------------------

WitSplitCntr::~WitSplitCntr ()
   {
   print ();
   }

//------------------------------------------------------------------------------

void WitSplitCntr::initCurSplits ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 1)
      nCurSplits_ = 0;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countCurSplits ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 1)
      nCurSplits_ ++;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countSplits (WitBoolean tempCommOK)
   {
   if (myGlobalComp ()->selPrintLevel () < 1)
      return;

   if (tempCommOK)
      {
      nSplitsDone_          += nCurSplits_;

      if (nCurSplits_ > 0)
         nSplitSplitComs_   ++;
      else
         nUnsplitSplitComs_ ++;
      }
   else
      {
      nSplitsDiscarded_     += nCurSplits_;

      nUnsplitSplitComs_    ++;
      }
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countBS (WitBoolean bsDone)
   {
   if (bsDone)
      nBSsDone_ ++;
   else
      nBSsSkipped_ ++;
   }

d20 9
a28 31
void WitSplitCntr::countBatch ()
   {
   nBatches_ ++;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::print ()
   {
   if (myGlobalComp ()->selPrintLevel () < 1)
      return;

   fprintf (msgFile (), 
      "# SS BS's Done:         %7d\n"
      "# SS BS's Skipped:      %7d\n"
      "# Split Batches:        %7d\n"
      "# Splits Performed:     %7d\n"
      "# Splits Discarded:     %7d\n"
      "# Alts, Total:          %7d\n\n"
      "#   Split Split-Coms:   %7d\n"
      "# Unsplit Split-Coms:   %7d\n\n\n",

      nBSsDone_,
      nBSsSkipped_,
      nBatches_,
      nSplitsDone_,
      nSplitsDiscarded_,
      mySelector_->nAlts (),
      nSplitSplitComs_,
      nUnsplitSplitComs_);
   }
d60 7
a66 7
   WitPart * thePart1;
   int       caseIdx1;
   WitPeriod thePer1;

   WitPart * thePart2;
   int       caseIdx2;
   WitPeriod thePer2;
d70 2
a71 2
               mySelPt_->getSortData (thePart1, caseIdx1, thePer1);
   theSplitPt->mySelPt_->getSortData (thePart2, caseIdx2, thePer2);
d79 4
a82 1
   if (caseIdx1 < caseIdx2)
d85 1
a85 1
   if (caseIdx1 > caseIdx2)
d298 244
@


1.31
log
@Continued implementation of sel-split for pen-exec.
@
text
@a19 1
#include <Splitter.h>
d22 1
d27 4
a31 1
#include <Timing.h>
d42 4
d47 1
a47 1
      fastMode_        (witFALSE),
d53 1
a53 9
      mySplitPts_      (myProblem ()),
      mySplitCntr_     (NULL),
      firstTCActive_   (witFALSE),
      nettedSplitPts_  (myProblem ()),
      nCurNettedPts_   (0),
      nSavedDbls_      (),
      nSavedPers_      (),
      nNettedPts_      (),
      searchPart_      (NULL)
d62 5
a66 1
   if (fastMode_)
d68 5
a72 3
      nSavedDbls_.allocate (myProblem (), 0);
      nSavedPers_.allocate (myProblem (), 0);
      nNettedPts_.allocate (myProblem (), 0);
a73 2

   mySplitCntr_ = new WitSplitCntr (theSelector);
d85 1
a85 1
void WitSplitter::preCommit ()
d87 5
a91 1
   if (fastMode_)
d93 32
a124 2
      if (searchPart_ != NULL)
         restoreToSearchPart ();
d126 7
a132 1
         initNetSplitLists ();
d134 3
a136 2
   else
      initNetSplitLists ();
d141 1
a141 1
void WitSplitter::postCommit ()
d143 7
a149 8
   if (fastMode_)
      {
      if (! firstTCActive_)
         if (searchPart_ == NULL)
            restoreAllVals ();
      }
   else
      restoreAllVals ();
d154 1
a154 1
void WitSplitter::startFlowMon ()
d156 7
a162 3
   stronglyAssert (! flowMonMode_);

   flowMonMode_ = witTRUE;
d184 1
a184 1
void WitSplitter::finishFlowMon ()
d186 6
a191 1
   stronglyAssert (flowMonMode_);
d193 3
a195 2
     okFlowPairs_.clear ();
   failFlowPairs_.clear ();
d197 1
a197 1
   flowMonMode_ = witFALSE;
d202 1
a202 1
void WitSplitter::recCommitItr (WitPart * thePart)
d204 10
a213 1
   stronglyAssert (fastMode_);
d215 38
a252 2
   if (! firstTCActive_)
      return;
d254 1
a254 2
   nSavedDbls_ (thePart) = 
      mySelector_->myHeurAtor ()->myDblArch ()->nSavedVals ();
d256 2
a257 2
   nSavedPers_ (thePart) = 
      mySelector_->myHeurAtor ()->myPerArch ()->nSavedVals ();
d259 1
a259 1
   nNettedPts_ (thePart) = nCurNettedPts_;
d264 3
a266 1
WitBoolean WitSplitter::skipCommitItr (WitPart * thePart)
d268 22
a289 1
   stronglyAssert (fastMode_);
d291 2
a292 4
   return
      (searchPart_ != NULL)?
         (thePart->sortedPartIndex () > searchPart_->sortedPartIndex ()):
         witFALSE;
d297 1
a297 1
void WitSplitter::recSplitExp (WitSplitPt * theSplitPt)
d299 2
a300 1
   stronglyAssert (fastMode_);
d302 1
a302 1
   nettedSplitPts_.push (theSplitPt);
d304 9
a312 1
   nCurNettedPts_ ++;
d317 1
a317 1
void WitSplitter::postTempCommit (WitBoolean success)
d319 10
a328 1
   if (flowMonMode_)
d330 9
a338 4
      if (success)
           okFlowPairs_.takeContents (curFlowPairs_);
      else
         failFlowPairs_.takeContents (curFlowPairs_);
d340 2
d346 1
a346 1
void WitSplitter::alterSelections ()
d348 9
a356 3
   WitSelPt * theSelPt;
   double     dummyFlowGap;
   WitBoolean splitNeeded;
d358 1
a358 1
   if (! mySelector_->getPendingPt (theSelPt))
d360 5
a364 1
      finishFlowMon ();
d366 1
a366 1
      return;
d369 15
a383 1
   splitNeeded = splitIsNeeded (theSelPt, witTRUE, dummyFlowGap);
d386 19
d406 1
a406 4
   if (splitNeeded)
      splitCommit (theSelPt);
   else
      mySelector_->alterSelection (theSelPt);
d416 2
a439 1
   stronglyAssert (flowMonMode_);
d455 1
a455 1
void WitSplitter::splitCommit (WitSelPt * theSelPt)
d457 31
a487 5
   int         nItrs;
   WitBoolean  tempCommOK;
   WitBoolean  resFound;
   WitBoolean  splitDone;
   WitSelMgr * theSelMgr;
d489 1
a489 1
   stronglyAssert (! splitCommActive_);
d491 4
a494 1
   splitCommActive_ = witTRUE;
d496 1
a496 1
   nItrs            = 0;
d498 4
a501 1
   mySplitCntr_->initCurSplits ();
d503 1
a503 1
   splitItr (tempCommOK, resFound, splitDone);
d505 2
a506 6
   if (splitDone)
      {
      while (resFound)
         {
         if (nItrs >= myGlobalComp ()->splitItrUB ())
            break;
d508 1
a508 1
         splitItr (tempCommOK, resFound, splitDone);
d510 6
a515 2
         nItrs ++;
         }
d517 2
a518 2
      if (tempCommOK)
         mySelector_->myHeurAtor ()->permCommit1SS ();
d520 3
a522 3
      mySplitCntr_->countSplits (tempCommOK);
      }
   else 
d524 3
a526 2
      if (tempCommOK || ! resFound)
         mySelector_->alterSelection (theSelPt);
d528 4
a531 1
      mySplitCntr_->countUnsplits ();
d534 1
a534 6
   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->postSplitCommit ();

   deleteContents (mySplitPts_);

   splitCommActive_ = witFALSE;
d539 3
a541 4
void WitSplitter::splitItr (
      WitBoolean & tempCommOK, 
      WitBoolean & resFound,
      WitBoolean & splitDone)
d543 1
a543 3
   WitSelPt * theSelPt;
   double     theFlowVol;
   WitBoolean splitNeeded;
d545 1
a545 2
   resFound    = witFALSE;
   splitNeeded = witFALSE;
d547 1
a547 1
   startFlowMon ();
d549 1
a549 2
   if (fastMode_)
      firstTCActive_ = witTRUE;
d551 2
a552 1
   tempCommOK        = mySelector_->myHeurAtor ()->tempCommit (1.0);
d554 1
a554 2
   if (fastMode_)
      firstTCActive_ = witFALSE;
d556 5
a560 3
   if (! tempCommOK)
      {
      resFound = mySelector_->getPendingPt (theSelPt);
d562 1
a562 3
      if (resFound)
         splitNeeded = splitIsNeeded (theSelPt, witFALSE, theFlowVol);
      }
d564 2
a565 1
   finishFlowMon ();
d567 1
a567 4
   if (resFound)
      {
      if (splitNeeded)
         splitSelection (theSelPt, theFlowVol);
d569 1
a569 2
      mySelector_->alterSelection (theSelPt);
      }
d571 2
a572 1
   splitDone = splitNeeded;
d574 1
a574 2
   if (fastMode_)
      restoreAllVals ();
d579 1
a579 1
void WitSplitter::splitSelection (WitSelPt * theSelPt, double theFlowVol)
a580 1
   WitBoolean   searchPtIsNew;
d582 2
a583 2
   WitBoolean   success;
   double       splitBound;
d585 3
a587 2
   if (fastMode_)
      stronglyAssert (searchPart_ == NULL);
d589 1
a589 1
   searchPtIsNew = ! theSelPt->isSplit ();
d591 1
a591 2
   if (searchPtIsNew)
      mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));
d593 1
a593 1
   theSplitPt     = theSelPt->mySplitPt ();
d595 2
a596 2
   if (fastMode_)
      searchPart_ = theSelPt->myFillPart ();
d598 1
a598 1
   success        = theSplitPt->tempCommForSearch (splitRes_);
d600 3
a602 3
   if (success)
      {
      splitBound = findSplitBound (theSplitPt, theFlowVol);
d604 1
a604 1
      theSplitPt->splitSelection (splitBound);
d606 1
a606 3
      mySplitCntr_->countCurSplits ();
      }
   else if (searchPtIsNew)
d608 1
a608 1
      mySplitPts_.pop (theSplitPt);
d610 1
a610 3
      stronglyAssert (theSplitPt == theSelPt->mySplitPt ());

      delete theSplitPt;
a611 3

   if (fastMode_)
      searchPart_ = NULL;
d616 1
a616 1
double WitSplitter::findSplitBound (WitSplitPt * theSplitPt, double theFlowVol)
d618 1
a618 4
   int        upperGP;
   int        lowerGP;
   int        midGP;
   WitBoolean success;
d620 1
a620 2
   lowerGP = 1;
   upperGP = ceil (theFlowVol / splitRes_);
d622 1
a622 1
   stronglyAssert (upperGP >= 2);
d624 1
a624 1
   while (upperGP - lowerGP > 1)
d626 8
a633 1
      midGP   = (lowerGP + upperGP) / 2;
d635 7
a641 1
      success = theSplitPt->tempCommForSearch (midGP * splitRes_);
d643 2
a644 4
      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
a645 2

   return (lowerGP * splitRes_);
d650 1
a650 1
void WitSplitter::initNetSplitLists ()
d652 11
a662 2
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theSplitPt;
d664 1
a664 1
   if (fastMode_)
d666 3
a668 1
      nettedSplitPts_.clear ();
d670 1
a670 1
      nCurNettedPts_ = 0;
d672 2
d675 3
a677 1
   theItr.attachTo (mySplitPts_);
d679 1
a679 3
   while (theItr.advance (theSplitPt))
      theSplitPt->initNetSplitList ();
   }
d681 1
a681 1
//------------------------------------------------------------------------------
d683 1
a683 3
void WitSplitter::restoreToSearchPart ()
   {
   WitSplitPt * theSplitPt;
d685 4
a688 1
   stronglyAssert (fastMode_);
d690 2
a691 9
   mySelector_->
      myHeurAtor ()->
         myDblArch ()->
            restoreAllExcept (nSavedDbls_ (searchPart_));
      
   mySelector_->
      myHeurAtor ()->
         myPerArch ()->
            restoreAllExcept (nSavedPers_ (searchPart_));
d693 1
a693 1
   while (nCurNettedPts_ > nNettedPts_ (searchPart_))
d695 2
a696 1
      nettedSplitPts_.pop (theSplitPt);
d698 1
a698 3
      theSplitPt->initNetSplitList ();

      nCurNettedPts_ --;
a699 1
   }
d701 3
a703 1
//------------------------------------------------------------------------------
d705 3
a707 4
void WitSplitter::restoreAllVals ()
   {
   mySelector_->myHeurAtor ()->myDblArch ()->restoreAllVals ();
   mySelector_->myHeurAtor ()->myPerArch ()->restoreAllVals ();
d722 4
a725 1
      nUnsplitSplitComs_ (0)
a753 10
void WitSplitCntr::countUnsplits ()
   {
   if (myGlobalComp ()->selPrintLevel () < 1)
      return;

   nUnsplitSplitComs_ ++;
   }

//------------------------------------------------------------------------------

d778 17
d800 4
a803 1
   fprintf (msgFile (),
d810 3
d824 2
a825 2
WitSplitPt::WitSplitPt (WitSelector * theSelector, WitSelPt * theSelPt):
      WitProbAssoc   (theSelector),
d827 1
a827 1
      mySelector_    (theSelector),
d848 1
a848 1
void WitSplitPt::initNetSplitList ()
d850 32
a881 1
   netSplitList_.revCopyFrom (revSplitList_);
d886 1
a886 1
WitBoolean WitSplitPt::tempCommForSearch (double searchVol)
d888 2
a889 2
   WitBoolean tempCommOK;
   WitSelPt * tracePt;
d891 2
a892 1
   stronglyAssert (searchVol >= 0.0);
d894 1
a894 1
   stronglyAssert (netSearchVol_ < -0.5);
d896 3
a898 3
   netSearchVol_ = searchVol;

   tempCommOK = mySelector_->myHeurAtor ()->tempCommit (1.0);
d901 1
d903 1
a903 2
   if (tempCommOK)
      return witTRUE;
d905 3
a907 7
   if (! mySelector_->getPendingPt (tracePt))
      return witTRUE;

   if (tracePt != mySelPt_)
      return witTRUE;

   return witFALSE;
d912 1
a912 1
void WitSplitPt::splitSelection (double splitBound)
d914 6
a919 1
   revSplitList_.push (mySelPt_->selSelCand (), splitBound);
d921 1
a921 1
   prtSplittingIA (splitBound);
a930 3

   if (mySelector_->mySplitter ()->fastMode ())
      mySelector_->mySplitter ()->recSplitExp (this);
d976 33
d1065 1
a1065 1
   if (mySelector_->myHeurAtor ()->tempMode ())
@


1.30
log
@Continued implementation of sel-split for pen-exec,
@
text
@d40 1
a40 1
      fastMode_        (witTRUE),
a58 2

   fastMode_ = ! mySelector_->penExec ();
@


1.29
log
@Continued implementation of sel-split for pen-exec.
@
text
@a140 9
   resetFlowMon ();

   flowMonMode_ = witFALSE;
   }

//------------------------------------------------------------------------------

void WitSplitter::resetFlowMon ()
   {
d145 2
d218 1
a218 1
   splitNeeded = splitIsNeeded (theSelPt, dummyFlowGap);
d230 4
a233 1
WitBoolean WitSplitter::splitIsNeeded (WitSelPt * theSelPt, double & flowGap)
d238 4
a241 3
   flowGap =
        flowThruSelPt (theSelPt, failFlowPairs_)
      - flowThruSelPt (theSelPt,   okFlowPairs_);
d353 1
a353 1
         splitNeeded = splitIsNeeded (theSelPt, theFlowVol);
a761 3

   if (totFlowVol_ > -0.5)
      totFlowVol_ += splitVol;
@


1.28
log
@Continued implementation of sel-split for pen-exec.
@
text
@d115 1
a115 1
   witAssert (! flowMonMode_);
d150 1
a150 1
   witAssert (flowMonMode_);
d158 1
a158 1
void WitSplitter::recCommitItr (WitPart * thePart, WitBoolean & skipItr)
d160 1
a160 1
   witAssert (fastMode_);
d162 11
a172 4
   if (firstTCActive_)
      {
      nSavedDbls_ (thePart) = 
         mySelector_->myHeurAtor ()->myDblArch ()->nSavedVals ();
d174 1
a174 2
      nSavedPers_ (thePart) = 
         mySelector_->myHeurAtor ()->myPerArch ()->nSavedVals ();
d176 3
a178 2
      nNettedPts_ (thePart) = nCurNettedPts_;
      }
d180 1
a180 1
   skipItr =
d190 1
a190 1
   witAssert (fastMode_);
d260 2
a261 2
   witAssert (flowMonMode_);
   witAssert (theSelPt != NULL);
d284 1
a284 1
   witAssert (! splitCommActive_);
d385 1
a385 1
      witAssert (searchPart_ == NULL);
d411 1
a411 1
      witAssert (theSplitPt == theSelPt->mySplitPt ());
d432 1
a432 1
   witAssert (upperGP >= 2);
d475 1
a475 1
   witAssert (fastMode_);
d639 1
a639 1
   witAssert (searchVol >= 0.0);
d641 1
a641 1
   witAssert (netSearchVol_ < -0.5);
d674 1
a674 1
   witAssert (toSplitVol > NET_TOL);
@


1.27
log
@Continued implementation of sel-split for pen-exec.
@
text
@d287 1
a287 7
   if (tempCommOK || ! resFound)
      {
      mySelector_->alterSelection (theSelPt);

      mySplitCntr_->countSplits1 ();
      }
   else if (splitDone)
d302 8
a309 1
      mySplitCntr_->countSplits2 (tempCommOK);
d539 1
a539 1
void WitSplitCntr::countSplits1 ()
d549 1
a549 1
void WitSplitCntr::countSplits2 (WitBoolean tempCommOK)
@


1.26
log
@Continued implementation of sel-split for pen-exec.
@
text
@a210 2
   mySelector_->printPreAltIA ();

@


1.25
log
@Continued implementation of sel-split for pen-exec.
@
text
@d141 9
a153 2

   flowMonMode_ = witFALSE;
@


1.24
log
@Continued implementation of sel-split for pen-exec.
@
text
@a420 2
   midGP = 1;

@


1.23
log
@Continued implementation of sel-split for pen-exec.
@
text
@a140 9
   resetFlowMon ();

   flowMonMode_ = witFALSE;
   }

//------------------------------------------------------------------------------

void WitSplitter::resetFlowMon ()
   {
d145 2
@


1.22
log
@Fixed a subtle bug in sel-split for stock reallocation.
Continued implementation of sel-split for pen-exec.
@
text
@d141 9
a153 2

   flowMonMode_ = witFALSE;
@


1.21
log
@Continued implementation of sel-split for pen-exec.
@
text
@d40 1
d47 1
d54 1
a54 2
      searchPart_      (NULL),
      mySplitCntr_     (NULL)
d60 2
d65 6
a70 3
   nSavedDbls_.allocate (myProblem (), 0);
   nSavedPers_.allocate (myProblem (), 0);
   nNettedPts_.allocate (myProblem (), 0);
d86 7
a92 2
   if (searchPart_ != NULL)
      restoreToSearchPart ();
d101 8
a108 3
   if (! firstTCActive_)
      if (searchPart_ == NULL)
         restoreAllVals ();
d153 2
d176 2
d330 2
a331 1
   firstTCActive_ = witTRUE;
d333 1
a333 1
   tempCommOK     = mySelector_->myHeurAtor ()->tempCommit (1.0);
d335 2
a336 1
   firstTCActive_ = witFALSE;
d358 2
a359 1
   restoreAllVals ();
d371 2
a372 1
   witAssert (searchPart_ == NULL);
d379 1
a379 1
   theSplitPt  = theSelPt->mySplitPt ();
d381 2
a382 1
   searchPart_ = theSelPt->myFillPart ();
d384 1
a384 1
   success     = theSplitPt->tempCommForSearch (splitRes_);
d403 2
a404 1
   searchPart_ = NULL;
d445 3
a447 1
   nettedSplitPts_.clear ();
d449 2
a450 1
   nCurNettedPts_ = 0;
d464 2
d667 2
a668 1
   mySelector_->mySplitter ()->recSplitExp (this);
@


1.20
log
@Continued implementation of sel-split for pen-exec.
@
text
@d570 2
a571 1
      boundedSplit_  (witFALSE)
d597 1
a597 1
   witAssert (searchVol > 0.0);
d722 3
@


1.19
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@a754 3

   else if (splitBound == splitVol)
      fprintf (msgFile (), "   Split Bound: Same\n");
@


1.18
log
@Fixed bug regarding booleans for sel-split for stock reallocation.
@
text
@d123 12
a291 12
   }

//------------------------------------------------------------------------------

void WitSplitter::finishFlowMon ()
   {
   witAssert (flowMonMode_);

     okFlowPairs_.clear ();
   failFlowPairs_.clear ();

   flowMonMode_ = witFALSE;
@


1.17
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d195 17
d219 1
a219 1
   flowGap = 0.0;
d221 1
a221 4
   if (! theSelPt->splittable ())
      return witFALSE;

   theItr.attachTo (failFlowPairs_);
d225 1
a225 1
         flowGap += incFlowVol;
d227 1
a227 7
   theItr.attachTo (okFlowPairs_);

   while (theItr.advance (curSelPt, incFlowVol))
      if (curSelPt == theSelPt)
         flowGap -= incFlowVol;

   return (flowGap > myGlobalComp ()->splitTol () + SEARCH_TOL);
@


1.16
log
@Refactoring for constrained stock reallocation.
@
text
@d36 1
a36 1
      WitProbAssoc       (theSelector),
d38 16
a53 16
      mySelector_        (theSelector),
      splitRes_          (myGlobalComp ()->splitRes ()),
      splitCommActive_   (witFALSE),
      flowMonMode_       (witFALSE),
       curFlowPairs_     (myProblem ()),
        okFlowPairs_     (myProblem ()),
      failFlowPairs_     (myProblem ()),
      mySplitPts_        (myProblem ()),
      firstTCActive_     (witFALSE),
      nettedSplitPts_    (myProblem ()),
      nCurNettedPts_     (0),
      nSavedDbls_        (),
      nSavedPers_        (),
      nNettedPts_        (),
      searchPart_        (NULL),
      mySplitCntr_       (NULL)
d90 3
a92 7
   if (firstTCActive_)
      return;

   if (searchPart_ != NULL)
      return;

   restoreAllVals ();
a187 1
      {
a188 3

      mySplitCntr_->countCaseA ();
      }
d246 1
a246 1
      mySplitCntr_->countSplits1 (tempCommOK);
a321 2
      else
         mySplitCntr_->countCaseE ();
d335 1
a335 1
   WitBoolean   theSplitPtIsNew;
d340 3
a342 1
   theSplitPtIsNew = ! theSelPt->isSplit ();
d344 1
a344 1
   if (theSplitPtIsNew)
d353 1
a353 1
   if (! success)
d355 1
a355 1
      mySplitCntr_->countCaseD ();
d357 1
a357 3
      if (theSplitPtIsNew)
         {
         mySplitPts_.pop (theSplitPt);
d359 1
a359 4
         witAssert (theSplitPt == theSelPt->mySplitPt ());

         delete theSplitPt;
         }
d361 1
a361 1
   else
d363 1
a363 1
      splitBound  = findSplitBound (theSplitPt, theFlowVol);
d365 1
a365 1
      theSplitPt->splitSelection (splitBound);
d367 1
a367 1
      mySplitCntr_->countCurSplits ();
a465 5
      nUnsplitCaseA_     (0),
      nUnsplitCaseB_     (0),
      nUnsplitCaseC_     (0),
      nUnsplitCaseD_     (0),
      nUnsplitCaseE_     (0),
d496 1
a496 25
void WitSplitCntr::countCaseA ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 1)
      nUnsplitCaseA_ ++;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countCaseD ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 1)
      nUnsplitCaseD_ ++;
   }

//------------------------------------------------------------------------------

void WitSplitCntr::countCaseE ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 1)
      nUnsplitCaseE_ ++;
   }

//------------------------------------------------------------------------------
 
void WitSplitCntr::countSplits1 (WitBoolean tempCommOK)
a501 5

   if (tempCommOK)
      nUnsplitCaseB_ ++;
   else
      nUnsplitCaseC_ ++;
a537 5
      "# Unsplit Alts, Case A: %7d\n"
      "# Unsplit Alts, Case B: %7d\n"
      "# Unsplit Alts, Case C: %7d\n"
      "# Unsplit Alts, Case D: %7d\n"
      "# Unsplit Alts, Case E: %7d\n"
d540 1
a540 1
      "# Unsplit Split-Coms:   %7d\n\n",
a543 5
      nUnsplitCaseA_,
      nUnsplitCaseB_,
      nUnsplitCaseC_,
      nUnsplitCaseD_,
      nUnsplitCaseE_,
a546 14

   if (
            nSplitsDone_
         +  nSplitsDiscarded_
         +  nUnsplitCaseA_
         +  nUnsplitCaseB_
         +  nUnsplitCaseC_
         +  nUnsplitCaseD_
         +  nUnsplitCaseE_
         != mySelector_->nAlts ())

      myMsgFac () ("internalErrorFmsg", "Splitter::~Splitter ");

   fprintf (msgFile (), "\n");
@


1.15
log
@Fixed a latent bug.
@
text
@d16 1
d21 1
d53 1
a53 14

      nCurSplits_        (0),
      nSplitsDone_       (0),
      nSplitsDiscarded_  (0),
      nUnsplitCaseA_     (0),
      nUnsplitCaseB_     (0),
      nUnsplitCaseC_     (0),
      nUnsplitCaseD_     (0),
      nUnsplitCaseE_     (0),
      nSplitSplitComs_   (0),
      nUnsplitSplitComs_ (0),
      maxNItrsForIdx_    (),
      nSplitSCforIdx_    (),
      nUnsplitSCforIdx_  ()
a61 3
   if (myGlobalComp ()->selPrintLevel () >= 1)
      initItrCounts ();

d65 2
d73 1
a73 2
   if (myGlobalComp ()->selPrintLevel () >= 1)
      printCounts ();
d195 1
a195 2
      if (myGlobalComp ()->selPrintLevel () >= 1)
         nUnsplitCaseA_ ++;
d234 5
a238 6
   int          nItrs;
   WitBoolean   success;
   WitBoolean   tempCommOK;
   WitBoolean   resFound;
   WitBoolean   splitDone;
   WitSelMgr *  theSelMgr;
d246 1
a246 6
   if (myGlobalComp ()->selPrintLevel () >= 1)
      {
      nCurSplits_ = 0;

      success     = witFALSE;
      }
d254 1
a254 1
      countSplits1 (tempCommOK);
a268 1
         {
d271 1
a271 5
         if (myGlobalComp ()->selPrintLevel () >= 1)
            success  = witTRUE;
         }

      countSplits2 (tempCommOK);
a279 3

   if (myGlobalComp ()->selPrintLevel () >= 1)
      countItrs (nItrs, success);
d330 2
a331 3

      else if (myGlobalComp ()->selPrintLevel () >= 1)
         nUnsplitCaseE_ ++;
d363 1
a363 2
      if (myGlobalComp ()->selPrintLevel () >= 1)
         nUnsplitCaseD_ ++;
d380 1
a380 2
      if (myGlobalComp ()->selPrintLevel () >= 1)
         nCurSplits_ ++;
d469 68
d538 1
a538 1
void WitSplitter::countSplits1 (WitBoolean tempCommOK)
d553 1
a553 1
void WitSplitter::countSplits2 (WitBoolean tempCommOK)
d577 1
a577 1
void WitSplitter::initItrCounts ()
d579 2
a580 46
   int minNItrs;
   int inc;
   int theIdx;

   maxNItrsForIdx_  .resize (100, 0);
   nSplitSCforIdx_  .resize (100, 0);
   nUnsplitSCforIdx_.resize (100, 0);

   minNItrs = 0;
   inc      = 1;

   for (theIdx = 0; theIdx < 100; theIdx ++)
      {
      maxNItrsForIdx_[theIdx] = minNItrs;

      if (minNItrs >= 10 * inc)
         inc *= 10;

      minNItrs += inc;
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::countItrs (int nItrs, WitBoolean success)
   {
   int theIdx;

   for (theIdx = 0; theIdx < 100; theIdx ++)
      if (nItrs <= maxNItrsForIdx_[theIdx])
         {
         if (success)
            nSplitSCforIdx_  [theIdx] ++;
         else
            nUnsplitSCforIdx_[theIdx] ++;

         return;
         }

   myMsgFac () ("internalErrorFmsg", "WitSplitter::countItrs");
   }
//------------------------------------------------------------------------------

void WitSplitter::printCounts ()
   {
   int theIdx;
a615 14

   fprintf (msgFile (), "\n");

   for (theIdx = 0; theIdx < 100; theIdx ++)
      if (nSplitSCforIdx_[theIdx] + nUnsplitSCforIdx_[theIdx] > 0 )
         fprintf (msgFile (),
            "#Itrs: %5d...%5d, #Split SCs: %5d, #Unsplit SCs: %5d, #SCs: %5d\n",
            theIdx > 0?
               maxNItrsForIdx_[theIdx - 1] + 1:
               0,
            maxNItrsForIdx_   [theIdx],
            nSplitSCforIdx_   [theIdx],
            nUnsplitSCforIdx_ [theIdx],
            nSplitSCforIdx_   [theIdx] + nUnsplitSCforIdx_[theIdx]);
@


1.14
log
@Refactoring for constrained stock reallocation.
@
text
@d45 2
d49 1
d78 1
d93 12
a104 2
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theSplitPt;
d106 2
a107 1
   theItr.attachTo (mySplitPts_);
d109 1
a109 2
   while (theItr.advance (theSplitPt))
      theSplitPt->preCommit ();
d140 1
a140 1
WitBoolean WitSplitter::skipCommitItr (WitPart * thePart)
d149 2
d153 4
a156 5
   if (searchPart_ != NULL)
      if (thePart->sortedPartIndex () > searchPart_->sortedPartIndex ())
         return witTRUE;

   return witFALSE;
d161 1
a161 1
WitBoolean WitSplitter::skipRestore ()
d163 1
a163 5
   if (firstTCActive_)
      return witTRUE;

   if (searchPart_ != NULL)
      return witTRUE;
d165 1
a165 1
   return witFALSE;
d367 1
a367 2
   mySelector_->myHeurAtor ()->myDblArch ()->restoreAllVals ();
   mySelector_->myHeurAtor ()->myPerArch ()->restoreAllVals ();
a373 2
   int          nDblsToLeave;
   int          nPersToLeave;
d377 1
a377 3
   int          upperGP;
   int          lowerGP;
   int          midGP;
d384 1
a384 6
   theSplitPt   = theSelPt->mySplitPt ();

   searchPart_  = theSelPt->myFillPart ();

   nDblsToLeave = nSavedDbls_ (searchPart_);
   nPersToLeave = nSavedPers_ (searchPart_);
d386 1
a386 1
   restoreAllExcept (nDblsToLeave, nPersToLeave);
d388 1
a388 1
   success    = theSplitPt->tempCommForSearch (splitRes_);
d403 4
d408 1
a408 1
      searchPart_ = NULL;
d410 2
a411 1
      return;
d414 12
d435 1
a435 3
      midGP = (lowerGP + upperGP) / 2;

      restoreAllExcept (nDblsToLeave, nPersToLeave);
d445 13
a457 1
   searchPart_ = NULL;
d459 1
a459 1
   theSplitPt->splitSelection (lowerGP * splitRes_);
d461 2
a462 2
   if (myGlobalComp ()->selPrintLevel () >= 1)
      nCurSplits_ ++;
d466 2
a467 2
 
void WitSplitter::restoreAllExcept (int nDblsToLeave, int nPersToLeave)
d469 20
a488 2
   mySelector_->myHeurAtor ()->myDblArch ()->restoreAllExcept (nDblsToLeave);
   mySelector_->myHeurAtor ()->myPerArch ()->restoreAllExcept (nPersToLeave);
d493 8
d668 1
a668 1
void WitSplitPt::preCommit ()
d670 1
a670 1
   netSplitList_.revCopyOf (revSplitList_);
a705 2
   WitSelMgr * theSelMgr;

d708 1
a708 15
   if (myGlobalComp ()->selPrintLevel () >= 3)
      {
      theSelMgr = mySelPt_->mySelMgr ();

      fprintf (msgFile (),
         "\n"
         "Splitting the %s Selection:\n",
         theSelMgr->selCaseName ());

      mySelPt_->prtID ();

      mySelPt_->selSelCand ()->prtID ();
               
      fprintf (msgFile (), "   Split Bound: %.3f\n", splitBound);
      }
d718 2
d761 19
@


1.13
log
@Refactoring for constrained stock reallocation.
@
text
@d87 13
d597 2
a598 2
      splitList_     (myProblem ()),
      splitListItr_  (),
d614 7
d654 1
a654 1
   splitList_.slowAppend (mySelPt_->selSelCand (), splitBound);
a679 2

   splitListItr_.attachTo (splitList_);
d690 1
a690 5
   if (netToSplitVol_ <=  NET_TOL)
      {
      theSelCand = mySelPt_->selSelCand ();
      splitVol   = netToSplitVol_;

a691 8
      }

   while (witTRUE)
      {
      boundedSplit_ = splitListItr_.advance (theSelCand, splitBound);

      if (! boundedSplit_)
         return defUnboundedSplit (theSelCand, splitVol);
d693 1
a693 1
      mySelPt_->adjustSplitBound (theSelCand, splitBound);
d695 2
a696 7
      if (splitBound > NET_TOL)
         {
         splitVol = min (splitBound, netToSplitVol_);

         netToSplitVol_ -= splitVol;

         prtSplitExpIA (theSelCand, splitVol, splitBound);
d698 16
a713 3
         return witTRUE;
         }
      }
@


1.12
log
@Refactoring for constrained stock reallocation.
@
text
@d23 1
d634 1
a634 1
   splitList_.slowAppend (mySelPt_->selectedObj (), splitBound);
d647 1
a647 1
      theSelMgr->prtSelCandID (mySelPt_->selectedObj ());
d666 3
a668 1
WitBoolean WitSplitPt::findNextSplit (WitTlObj * & splitObj, double & splitVol)
d674 2
a675 2
      splitObj = mySelPt_->selectedObj ();
      splitVol = netToSplitVol_;
d682 1
a682 1
      boundedSplit_ = splitListItr_.advance (splitObj, splitBound);
d685 1
a685 1
         return defUnboundedSplit (splitObj, splitVol);
d687 1
a687 1
      mySelPt_->adjustSplitBound (splitObj, splitBound);
d695 1
a695 1
         prtSplitExpIA (splitObj, splitVol, splitBound);
d712 2
a713 2
      WitTlObj * & splitObj, 
      double &     splitVol)
d715 1
a715 1
   splitObj       = mySelPt_->selectedObj ();
d731 1
a731 1
   prtSplitExpIA (splitObj, splitVol, 0.0);
d739 3
a741 3
      WitTlObj * splitObj, 
      double     splitVol, 
      double     splitBound)
d760 1
a760 1
   theSelMgr->prtSelCandID (splitObj);
@


1.11
log
@Removed special sel-split timing code.
@
text
@a228 1
   WitSplitPt * theSplitPt;
d277 1
a277 2
   while (mySplitPts_.pop (theSplitPt))
      delete theSplitPt;
@


1.10
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d244 1
a244 1
   splitItr (tempCommOK, resFound, splitDone, witFALSE);
d259 1
a259 1
         splitItr (tempCommOK, resFound, splitDone, witTRUE);
d304 1
a304 2
      WitBoolean & splitDone,
      WitBoolean   inLoop)
d306 3
a308 4
   WitTimingEvent * theEventPtr;
   WitSelPt *       theSelPt;
   double           theFlowVol;
   WitBoolean       splitNeeded;
a314 3
   if (myGlobalComp ()->selPrintLevel () >= 1)
      theEventPtr = new WitTimingEvent (inLoop? "loopSTC1": "initSTC1");

a320 3
   if (myGlobalComp ()->selPrintLevel () >= 1)
      delete theEventPtr;

a333 4
         {
         if (myGlobalComp ()->selPrintLevel () >= 1)
            theEventPtr = new WitTimingEvent (inLoop? "loopSS": "initSS");

a335 3
         if (myGlobalComp ()->selPrintLevel () >= 1)
            delete theEventPtr;
         }
@


1.9
log
@Created and used Archive template.
@
text
@d26 1
d43 5
d71 3
d112 33
d310 1
d312 2
a313 2
   resFound   = witFALSE;
   splitDone  = witFALSE;
d320 5
a324 1
   tempCommOK  = mySelector_->myHeurAtor ()->tempCommit (1.0);
d329 1
a329 1
   if (tempCommOK)
d331 1
a331 1
      finishFlowMon ();
d333 2
a334 1
      return;
d337 1
a337 1
   resFound = mySelector_->getPendingPt (theSelPt);
d339 1
a339 1
   if (! resFound)
d341 4
a344 1
      finishFlowMon ();
d346 1
a346 2
      return;
      }
d348 5
a352 1
   splitDone = splitIsNeeded (theSelPt, theFlowVol);
d354 1
a354 11
   finishFlowMon ();

   if (splitDone)
      {
      if (myGlobalComp ()->selPrintLevel () >= 1)
         theEventPtr = new WitTimingEvent (inLoop? "loopSS": "initSS");

      splitSelection (theSelPt, theFlowVol);

      if (myGlobalComp ()->selPrintLevel () >= 1)
         delete theEventPtr;
d357 1
a357 1
   mySelector_->alterSelection (theSelPt);
d359 2
a360 3
   if (myGlobalComp ()->selPrintLevel () >= 1)
      if (! splitDone)
         nUnsplitCaseE_ ++;
d367 2
d381 8
a388 1
   theSplitPt = theSelPt->mySplitPt ();
d406 2
d420 1
a420 1
      midGP      = (lowerGP + upperGP) / 2;
d422 3
a424 1
      success    = theSplitPt->tempCommForSearch (midGP * splitRes_);
d432 2
d438 8
@


1.8
log
@Initial implementation of pegging.
@
text
@a24 1
#include <AllMode.h>
d696 1
a696 1
   if (mySelector_->myHeurAtor ()->myAllocMode ()->temp ())
@


1.7
log
@Implemented an iteration upper bound for selection splitting.
@
text
@d24 1
a24 1
#include <HeurAllP.h>
d225 1
a225 1
         mySelector_->myHeurAllPerf ()->permCommit1SS ();
d278 1
a278 1
   tempCommOK  = mySelector_->myHeurAllPerf ()->tempCommit (1.0);
d563 1
a563 1
   tempCommOK = mySelector_->myHeurAllPerf ()->tempCommit (1.0);
d697 1
a697 1
   if (mySelector_->myHeurAllPerf ()->myAllocMode ()->temp ())
@


1.6
log
@Converted several generic classes into class templates.
@
text
@d26 1
d52 4
a55 1
      nUnsplitSplitComs_ (0)
d63 3
d73 1
a73 36
      {
      fprintf (msgFile (),
         "# Splits Performed:     %7d\n"
         "# Splits Discarded:     %7d\n"
         "# Unsplit Alts, Case A: %7d\n"
         "# Unsplit Alts, Case B: %7d\n"
         "# Unsplit Alts, Case C: %7d\n"
         "# Unsplit Alts, Case D: %7d\n"
         "# Unsplit Alts, Case E: %7d\n"
         "# Alts, Total:          %7d\n\n"
         "#   Split Split-Coms:   %7d\n"
         "# Unsplit Split-Coms:   %7d\n\n",

         nSplitsDone_,
         nSplitsDiscarded_,
         nUnsplitCaseA_,
         nUnsplitCaseB_,
         nUnsplitCaseC_,
         nUnsplitCaseD_,
         nUnsplitCaseE_,
         mySelector_->nAlts (),
         nSplitSplitComs_,
         nUnsplitSplitComs_);

      if (
               nSplitsDone_
            +  nSplitsDiscarded_
            +  nUnsplitCaseA_
            +  nUnsplitCaseB_
            +  nUnsplitCaseC_
            +  nUnsplitCaseD_
            +  nUnsplitCaseE_
            != mySelector_->nAlts ())

         myMsgFac () ("internalErrorFmsg", "Splitter::~Splitter ");
      }
d182 2
d194 2
d197 1
d200 4
a203 1
   splitItr (tempCommOK, resFound, splitDone);
d214 8
a221 1
         splitItr (tempCommOK, resFound, splitDone);
d224 1
d227 4
d241 3
d263 2
a264 1
      WitBoolean & splitDone)
d266 3
a268 2
   WitSelPt * theSelPt;
   double     theFlowVol;
d275 7
a281 1
   tempCommOK = mySelector_->myHeurAllPerf ()->tempCommit (1.0);
d304 4
d310 4
d420 103
@


1.5
log
@Fixed bug in two-way multi-exec:
   NSTN and ASAP multi-exec collisions were not being adequately detected.
@
text
@d179 1
a179 1
   WitPairStItr (WitSelPt, double) theItr;
@


1.4
log
@Continued development of selection splitting for multi=exec.
@
text
@d475 1
a475 1
      theSelMgr = mySelPt_->mySelMgr (mySelector_);
d586 1
a586 1
   theSelMgr = mySelPt_->mySelMgr (mySelector_);
@


1.3
log
@Refactoring for sel-split for multi-exec.
@
text
@d324 1
a324 1
      mySplitPts_.push (new WitSplitPt (this, theSelPt));
d415 2
a416 2
WitSplitPt::WitSplitPt (WitSplitter * theSplitter, WitSelPt * theSelPt):
      WitProbAssoc   (theSplitter),
d418 1
a418 1
      mySplitter_    (theSplitter),
d449 1
a449 1
   tempCommOK = mySplitter_->mySelector ()->myHeurAllPerf ()->tempCommit (1.0);
d456 1
a456 1
   if (! mySplitter_->mySelector ()->getPendingPt (tracePt))
d469 2
d474 14
a487 1
      mySelPt_->prtSplitting (splitBound);
d520 1
a520 5
         {
         defUnboundedSplit (splitObj, splitVol);

         return witTRUE;
         }
d546 3
a548 1
void WitSplitPt::defUnboundedSplit (WitTlObj * & splitObj, double & splitVol)
d554 1
a554 1
   if (netSearchVol_ >= -0.5)
d567 2
d578 2
d583 1
a583 1
   if (mySplitter_->mySelector ()->myHeurAllPerf ()->myAllocMode ()->temp ())
d586 10
a595 1
   mySelPt_->prtSplitExp (splitObj);
@


1.2
log
@Various refactorings for sel-split for multi-exec.
@
text
@d25 1
a40 2
      searchPt_          (NULL),
      netSearchVol_      (-1.0),
d117 11
a127 4
   if (flowMonMode_)
      if (theSelPt->splittable ())
         if (! theSelPt->mySelMgr (mySelector_)->boundedSplit ())
            curFlowPairs_.push (theSelPt, incFlowVol);
a176 21
void WitSplitter::applySearchVolAsNeeded (
      WitSplitPt * theSplitPt, 
      double &     splitVol)
   {
   witAssert (theSplitPt != NULL);

   if (theSplitPt != searchPt_)
      return;

   if (netSearchVol_ < splitVol)
      {
      splitVol       = netSearchVol_;

      netSearchVol_  = 0.0;
      }
   else
      netSearchVol_ -= splitVol;
   }

//------------------------------------------------------------------------------

d314 1
d321 4
a324 2
   if (! theSelPt->isSplit ())
      mySplitPts_.push (new WitSplitPt (myProblem (), theSelPt));
d328 1
a328 1
   success    = tempCommForSearch (theSplitPt, splitRes_);
d335 1
a335 1
      if (theSplitPt->splitList ().isEmpty ())
d358 1
a358 1
      success    = tempCommForSearch (theSplitPt, midGP * splitRes_);
a373 32
WitBoolean WitSplitter::tempCommForSearch (
      WitSplitPt * theSplitPt, 
      double       searchVol)
   {
   WitBoolean tempCommOK;
   WitSelPt * tracePt;

   witAssert (theSplitPt  != NULL);
   witAssert (searchPt_   == NULL);

   searchPt_     = theSplitPt;
   netSearchVol_ = searchVol;

   tempCommOK    = mySelector_->myHeurAllPerf ()->tempCommit (1.0);

   netSearchVol_ = -1.0;
   searchPt_     = NULL;

   if (tempCommOK)
      return witTRUE;

   if (! mySelector_->getPendingPt (tracePt))
      return witTRUE;

   if (tracePt != theSplitPt->mySelPt ())
      return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

d415 2
a416 2
WitSplitPt::WitSplitPt (WitProblem * theProblem, WitSelPt * theSelPt):
      WitProbAssoc (theProblem),
d418 7
a424 2
      mySelPt_     (theSelPt),
      splitList_   (myProblem ())
d438 29
d473 107
@


1.1
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d171 3
a173 1
void WitSplitter::applySearchVol (double & splitVol)
d175 5
d329 2
a333 2
   WitBoolean   success;
   WitSplitPt * theSplitPt;
d338 3
a340 1
   success = tempCommForSearch (theSelPt, splitRes_);
d347 1
a347 1
      if (mySplitPts_.firstObject ()->splitList ().isEmpty ())
d351 2
d370 1
a370 1
      success    = tempCommForSearch (theSelPt, midGP * splitRes_);
d378 1
a378 1
   theSelPt->mySplitPt ()->splitSelection (lowerGP * splitRes_);
d387 2
a388 2
      WitSelPt * theSelPt, 
      double     searchVol)
d393 2
a394 2
   witAssert (theSelPt  != NULL);
   witAssert (searchPt_ == NULL);
d396 1
a396 1
   searchPt_     = theSelPt;
d410 1
a410 1
   if (tracePt != theSelPt)
d479 1
a479 1
   splitList_.slowAppend (mySelPt_->selection (), splitBound);
@


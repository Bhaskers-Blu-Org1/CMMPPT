head	1.44;
access;
symbols
	sce_5_01_20080919:1.40
	latest_sce_4_20_20060523:1.40.0.2
	sce_4_20_20060523:1.40
	latest_sce4_20_OSL:1.39.0.2
	sce_4_20_OSL:1.39
	sce_410_withVa:1.38
	sce_4_05_20040511:1.34
	sce_4_00_20040201:1.13
	EndRw-branch:1.8.0.4
	Root-of-EndRw:1.8
	rwToStl:1.8.0.2
	latest_sce_3_10_20010924:1.5.0.6
	sce_3_10_20010924:1.5
	latest_sce_3_00_20010601:1.5.0.4
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2011.09.28.23.49.22;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.24.00.27.41;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.08.30.20.17.31;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2010.03.16.22.42.25;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.02.17.33.58;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.15.21.27.23;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.02.23.17.53;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.02.21.59.45;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.24.23.23.55;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.04.16.30.13;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.30.23.27.43;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.19.22.16.28;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.14.21.29.57;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.29.19.58.27;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.24.22.21.30;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.24.20.17.02;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.24.19.17.33;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.22.23.16.37;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.22.21.45.51;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.20.00.12.11;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.19.22.00.53;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.18.19.39.33;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.16.23.29.49;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.04.16.44.29;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.04.16.31.45;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.02.23.52.13;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.13.00.17.51;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.09.22.44.05;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.26.21.16.31;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.25.23.49.55;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.03.23.26.45;	author rjw;	state dead;
branches;
next	1.8;

1.8
date	2002.05.08.19.21.49;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.03.23.16.38;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.02.20.53.11;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.22;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.29.21.22.43;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.18.00.15.59;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.48;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "FlexVec.C"
//
// Contains the following:
//
//    The implementation         of class template FlexVec   <Elem>.
//    The explicit instantiation of class template FlexVec   <Elem>.
//    The implementation         of class          DblFlexVec.
//    The implementation         of class          FlexVAsst.
//    The implementation of NonClass functions with arguments belonging to
//        specific Vector classes.
//------------------------------------------------------------------------------

#include <FlexVec.h>
#include <GlobalComp.h>
#include <IVRealArg.h>
#include <ApiMgr.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class template FlexVec <Elem>.
//------------------------------------------------------------------------------

template <typename Elem> 
      WitFlexVec <Elem>::WitFlexVec (WitProblem * theProblem, Elem initValue):

         curAsst_ (NULL)
   {
   curAsst_    = theProblem->scalarFlexVAsst ();

   myScalar () = initValue;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      WitFlexVec <Elem>::~WitFlexVec ()
   {
   beInScalarMode ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::switchToVectorMode ()
   {
   Elem      theScalar;
   WitPeriod thePer;

   witAssert (scalarMode ());

   theScalar        = myScalar ();

   curAsst_         = curAsst_->myProblem ()->vectorFlexVAsst ();

   myCVecFromUnion_ = new Elem[nPeriods ()];

   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      myCVec ()[thePer] = theScalar;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::switchToScalarMode ()
   {
   Elem theScalar;

   witAssert (vectorMode ());

   theScalar   = myCVec ()[0];

   delete[]      myCVec ();

   curAsst_    = curAsst_->myProblem ()->scalarFlexVAsst ();

   myScalar () = theScalar;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::operator = (const WitFlexVec & theFlexVec)
   {
   witAssert (nPeriods () == theFlexVec.nPeriods ());

   if (theFlexVec.vectorMode ())
      (* this) = theFlexVec.myCVec ();
   else
      (* this) = theFlexVec.myScalar ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::operator = (Elem theScalar)
   {
   beInScalarMode ();

   myScalar () = theScalar;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::operator = (const WitTVec <Elem> & theTVec)
   {
   witAssert (nPeriods () == theTVec.length ());

   if (theTVec == theTVec[0])
      (* this) = theTVec[0];
   else
      {
      beInVectorMode ();

      theTVec.copyInto (myCVec ());
      }
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::operator = (const Elem * theCVec)
   {
   WitPeriod thePer;

   if (hasSingleValue (theCVec, nPeriods ()))
      (* this) = theCVec[0];
   else
      {
      beInVectorMode ();

      for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
         myCVec ()[thePer] = theCVec[thePer];
      }
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::copyInto (WitTVec <Elem> & theTVec) const
   {
   if (vectorMode ())
      theTVec = myCVec ();
   else
      theTVec = myScalar ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::copyInto (Elem * theCVec) const
   {
   WitPeriod thePer;

   witAssert (theCVec != NULL);

   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      theCVec[thePer] = (* this)[thePer];
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      bool WitFlexVec <Elem>::operator == (Elem theScalar) const
   {
   WitPeriod thePer;

   if (scalarMode ())
      return (myScalar () == theScalar);

   if (hasSingleValue (myCVec (), nPeriods ()))
      return (myCVec ()[0] == theScalar);
   else
      return false;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      bool WitFlexVec <Elem>::operator != (Elem theScalar) const
   {
   return not ((* this) == theScalar);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      bool WitFlexVec <Elem>::operator >= (Elem theScalar) const
   {
   WitPeriod thePer;

   if (scalarMode ())
      return (myScalar () >= theScalar);

   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      if (myCVec ()[thePer] < theScalar)
         return false;

   return true;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::checkBounds (WitPeriod thePer) const
   { 
   if (thePer < 0)
      curAsst_->myProblem ()->myMsgFac () ("negativeIndexFmsg", thePer);

   if (thePer >= nPeriods ())
      curAsst_->myProblem ()->myMsgFac () ("indexTooLargeFmsg",
         thePer,
         nPeriods () - 1);
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template FlexVec <Elem>.
//------------------------------------------------------------------------------

template class WitFlexVec <bool>;
template class WitFlexVec <int>;
template class WitFlexVec <double>;
template class WitFlexVec <void *>;

//------------------------------------------------------------------------------
// Implementation of class DblFlexVec.
//------------------------------------------------------------------------------

WitDblFlexVec::WitDblFlexVec (WitProblem * theProblem, double initValue):

      WitFlexVec <double> (theProblem, initValue)
   {
   }

//------------------------------------------------------------------------------

WitDblFlexVec::~WitDblFlexVec ()
   {
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::operator = (const WitDblFlexVec & theDblFlexVec)
   {
   thisFlexVec () = theDblFlexVec;
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::operator = (double theScalar)
   {
   thisFlexVec () = theScalar;
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::operator = (const WitTVec <double> & theDblTVec)
   {
   thisFlexVec () = theDblTVec;
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::operator = (const double * theDblCVec)
   {
   thisFlexVec () = theDblCVec;
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::operator = (const float * theFltCVec)
   {
   bool      scalMode;
   WitPeriod thePer;

   scalMode = hasSingleValue (theFltCVec, nPeriods ());

   if (scalMode)
      (* this) = dblFromFlt (theFltCVec[0]);
   else
      {
      beInVectorMode ();

      for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
         myCVec ()[thePer] = dblFromFlt (theFltCVec[thePer]);
      }
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::operator = (const WitIVRealArg & theIVRealArg)
   {
   theIVRealArg.copyInto (* this);
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::copyInto (double * theDblCVec) const
   {
   thisFlexVec ().copyInto (theDblCVec);
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::copyInto (float * theFltCVec) const
   {
   WitPeriod thePer;

   witAssert (theFltCVec != NULL);

   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      theFltCVec[thePer] = fltFromDbl ((* this)[thePer]);
   }

//------------------------------------------------------------------------------
// Implementation of class FlexVAsst.
//------------------------------------------------------------------------------

WitFlexVAsst::WitFlexVAsst (WitProblem * theProblem, bool vectorModeVal):

      WitProbAssoc (theProblem),
      vectorMode_  (vectorModeVal),
      nPeriods_    (WitGlobalComp::defNPeriods ())
   {
   }

//------------------------------------------------------------------------------

WitFlexVAsst::~WitFlexVAsst ()
   {
   }

//------------------------------------------------------------------------------

void WitFlexVAsst::updateNPeriods ()
   {
   nPeriods_ = myGlobalComp ()->nPeriods ();
   }

//------------------------------------------------------------------------------
// Implementation of NonClass functions with arguments belonging to specific
// Vector classes.
//------------------------------------------------------------------------------

void WitNonClass::copy (
      WitFlexVec <bool> & theFlexVec,
      const WitBoolean *  theCVec)
   {
   WitPeriod thePer;

   if (hasSingleValue (theCVec, theFlexVec.nPeriods ()))
      theFlexVec = asaBool (theCVec[0]);
   else
      for (thePer = theFlexVec.nPeriods () - 1; thePer >= 0; thePer --)
         theFlexVec.elemRef (thePer) = asaBool (theCVec[thePer]);
   }

//------------------------------------------------------------------------------

void WitNonClass::copy (
      WitBoolean *              theCVec,
      const WitFlexVec <bool> & theFlexVec)
   {
   WitPeriod thePer;

   for (thePer = theFlexVec.nPeriods () - 1; thePer >= 0; thePer --)
      theCVec[thePer] = theFlexVec[thePer];
   }
@


1.43
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.42
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d33 2
a34 2
template <typename Elem>
WitFlexVec <Elem>::WitFlexVec (WitProblem * theProblem, Elem initValue):
d36 3
a38 3
curAsst_ (NULL)
{
curAsst_    = theProblem->scalarFlexVAsst ();
d40 2
a41 2
myScalar () = initValue;
}
d45 5
a49 5
template <typename Elem>
WitFlexVec <Elem>::~WitFlexVec ()
{
beInScalarMode ();
}
d53 5
a57 5
template <typename Elem>
void WitFlexVec <Elem>::switchToVectorMode ()
{
Elem      theScalar;
WitPeriod thePer;
d59 1
a59 1
witAssert (scalarMode ());
d61 1
a61 1
theScalar        = myScalar ();
d63 1
a63 1
curAsst_         = curAsst_->myProblem ()->vectorFlexVAsst ();
d65 1
a65 1
myCVecFromUnion_ = new Elem[nPeriods ()];
d67 3
a69 3
for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
myCVec ()[thePer] = theScalar;
}
d73 4
a76 4
template <typename Elem>
void WitFlexVec <Elem>::switchToScalarMode ()
{
Elem theScalar;
d78 1
a78 1
witAssert (vectorMode ());
d80 1
a80 1
theScalar   = myCVec ()[0];
d82 1
a82 1
delete[]      myCVec ();
d84 1
a84 1
curAsst_    = curAsst_->myProblem ()->scalarFlexVAsst ();
d86 2
a87 2
myScalar () = theScalar;
}
d91 4
a94 4
template <typename Elem>
void WitFlexVec <Elem>::operator = (const WitFlexVec & theFlexVec)
{
witAssert (nPeriods () == theFlexVec.nPeriods ());
d96 5
a100 5
if (theFlexVec.vectorMode ())
(* this) = theFlexVec.myCVec ();
else
(* this) = theFlexVec.myScalar ();
}
d104 4
a107 4
template <typename Elem>
void WitFlexVec <Elem>::operator = (Elem theScalar)
{
beInScalarMode ();
d109 2
a110 2
myScalar () = theScalar;
}
d114 4
a117 4
template <typename Elem>
void WitFlexVec <Elem>::operator = (const WitTVec <Elem> & theTVec)
{
witAssert (nPeriods () == theTVec.length ());
d119 5
a123 5
if (theTVec == theTVec[0])
(* this) = theTVec[0];
else
{
beInVectorMode ();
d125 3
a127 3
theTVec.copyInto (myCVec ());
}
}
d131 4
a134 4
template <typename Elem>
void WitFlexVec <Elem>::operator = (const Elem * theCVec)
{
WitPeriod thePer;
d136 5
a140 5
if (hasSingleValue (theCVec, nPeriods ()))
(* this) = theCVec[0];
else
{
beInVectorMode ();
d142 4
a145 4
for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
myCVec ()[thePer] = theCVec[thePer];
}
}
d149 8
a156 8
template <typename Elem>
void WitFlexVec <Elem>::copyInto (WitTVec <Elem> & theTVec) const
{
if (vectorMode ())
theTVec = myCVec ();
else
theTVec = myScalar ();
}
d160 4
a163 4
template <typename Elem>
void WitFlexVec <Elem>::copyInto (Elem * theCVec) const
{
WitPeriod thePer;
d165 1
a165 1
witAssert (theCVec != NULL);
d167 3
a169 3
for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
theCVec[thePer] = (* this)[thePer];
}
d173 4
a176 4
template <typename Elem>
bool WitFlexVec <Elem>::operator == (Elem theScalar) const
{
WitPeriod thePer;
d178 2
a179 2
if (scalarMode ())
return (myScalar () == theScalar);
d181 5
a185 5
if (hasSingleValue (myCVec (), nPeriods ()))
return (myCVec ()[0] == theScalar);
else
return false;
}
d189 5
a193 5
template <typename Elem>
bool WitFlexVec <Elem>::operator != (Elem theScalar) const
{
return not ((* this) == theScalar);
}
d197 4
a200 4
template <typename Elem>
bool WitFlexVec <Elem>::operator >= (Elem theScalar) const
{
WitPeriod thePer;
d202 2
a203 2
if (scalarMode ())
return (myScalar () >= theScalar);
d205 3
a207 3
for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
if (myCVec ()[thePer] < theScalar)
return false;
d209 2
a210 2
return true;
}
d214 5
a218 5
template <typename Elem>
void WitFlexVec <Elem>::checkBounds (WitPeriod thePer) const
{
if (thePer < 0)
curAsst_->myProblem ()->myMsgFac () ("negativeIndexFmsg", thePer);
d220 5
a224 5
if (thePer >= nPeriods ())
curAsst_->myProblem ()->myMsgFac () ("indexTooLargeFmsg",
thePer,
nPeriods () - 1);
}
d241 3
a243 3
WitFlexVec <double> (theProblem, initValue)
{
}
d248 2
a249 2
{
}
d254 3
a256 3
{
thisFlexVec () = theDblFlexVec;
}
d261 3
a263 3
{
thisFlexVec () = theScalar;
}
d268 3
a270 3
{
thisFlexVec () = theDblTVec;
}
d275 3
a277 3
{
thisFlexVec () = theDblCVec;
}
d282 16
a297 16
{
bool      scalMode;
WitPeriod thePer;

scalMode = hasSingleValue (theFltCVec, nPeriods ());

if (scalMode)
(* this) = dblFromFlt (theFltCVec[0]);
else
{
beInVectorMode ();

for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
myCVec ()[thePer] = dblFromFlt (theFltCVec[thePer]);
}
}
d302 3
a304 3
{
theIVRealArg.copyInto (* this);
}
d309 3
a311 3
{
thisFlexVec ().copyInto (theDblCVec);
}
d316 2
a317 2
{
WitPeriod thePer;
d319 1
a319 1
witAssert (theFltCVec != NULL);
d321 3
a323 3
for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
theFltCVec[thePer] = fltFromDbl ((* this)[thePer]);
}
d331 5
a335 5
WitProbAssoc (theProblem),
vectorMode_  (vectorModeVal),
nPeriods_    (WitGlobalComp::defNPeriods ())
{
}
d340 2
a341 2
{
}
d346 3
a348 3
{
nPeriods_ = myGlobalComp ()->nPeriods ();
}
d356 11
a366 11
WitFlexVec <bool> & theFlexVec,
const WitBoolean *  theCVec)
{
WitPeriod thePer;

if (hasSingleValue (theCVec, theFlexVec.nPeriods ()))
theFlexVec = asaBool (theCVec[0]);
else
for (thePer = theFlexVec.nPeriods () - 1; thePer >= 0; thePer --)
theFlexVec.elemRef (thePer) = asaBool (theCVec[thePer]);
}
d371 8
a378 8
WitBoolean *              theCVec,
const WitFlexVec <bool> & theFlexVec)
{
WitPeriod thePer;

for (thePer = theFlexVec.nPeriods () - 1; thePer >= 0; thePer --)
theCVec[thePer] = theFlexVec[thePer];
}
@


1.41
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d33 2
a34 2
template <typename Elem> 
      WitFlexVec <Elem>::WitFlexVec (WitProblem * theProblem, Elem initValue):
d36 3
a38 3
         curAsst_ (NULL)
   {
   curAsst_    = theProblem->scalarFlexVAsst ();
d40 2
a41 2
   myScalar () = initValue;
   }
d45 5
a49 5
template <typename Elem> 
      WitFlexVec <Elem>::~WitFlexVec ()
   {
   beInScalarMode ();
   }
d53 5
a57 5
template <typename Elem> 
      void WitFlexVec <Elem>::switchToVectorMode ()
   {
   Elem      theScalar;
   WitPeriod thePer;
d59 1
a59 1
   witAssert (scalarMode ());
d61 1
a61 1
   theScalar        = myScalar ();
d63 1
a63 1
   curAsst_         = curAsst_->myProblem ()->vectorFlexVAsst ();
d65 1
a65 1
   myCVecFromUnion_ = new Elem[nPeriods ()];
d67 3
a69 3
   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      myCVec ()[thePer] = theScalar;
   }
d73 4
a76 4
template <typename Elem> 
      void WitFlexVec <Elem>::switchToScalarMode ()
   {
   Elem theScalar;
d78 1
a78 1
   witAssert (vectorMode ());
d80 1
a80 1
   theScalar   = myCVec ()[0];
d82 1
a82 1
   delete[]      myCVec ();
d84 1
a84 1
   curAsst_    = curAsst_->myProblem ()->scalarFlexVAsst ();
d86 2
a87 2
   myScalar () = theScalar;
   }
d91 4
a94 4
template <typename Elem> 
      void WitFlexVec <Elem>::operator = (const WitFlexVec & theFlexVec)
   {
   witAssert (nPeriods () == theFlexVec.nPeriods ());
d96 5
a100 5
   if (theFlexVec.vectorMode ())
      (* this) = theFlexVec.myCVec ();
   else
      (* this) = theFlexVec.myScalar ();
   }
d104 4
a107 4
template <typename Elem> 
      void WitFlexVec <Elem>::operator = (Elem theScalar)
   {
   beInScalarMode ();
d109 2
a110 2
   myScalar () = theScalar;
   }
d114 4
a117 4
template <typename Elem> 
      void WitFlexVec <Elem>::operator = (const WitTVec <Elem> & theTVec)
   {
   witAssert (nPeriods () == theTVec.length ());
d119 5
a123 5
   if (theTVec == theTVec[0])
      (* this) = theTVec[0];
   else
      {
      beInVectorMode ();
d125 3
a127 3
      theTVec.copyInto (myCVec ());
      }
   }
d131 4
a134 4
template <typename Elem> 
      void WitFlexVec <Elem>::operator = (const Elem * theCVec)
   {
   WitPeriod thePer;
d136 5
a140 5
   if (hasSingleValue (theCVec, nPeriods ()))
      (* this) = theCVec[0];
   else
      {
      beInVectorMode ();
d142 4
a145 4
      for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
         myCVec ()[thePer] = theCVec[thePer];
      }
   }
d149 8
a156 8
template <typename Elem> 
      void WitFlexVec <Elem>::copyInto (WitTVec <Elem> & theTVec) const
   {
   if (vectorMode ())
      theTVec = myCVec ();
   else
      theTVec = myScalar ();
   }
d160 4
a163 4
template <typename Elem> 
      void WitFlexVec <Elem>::copyInto (Elem * theCVec) const
   {
   WitPeriod thePer;
d165 1
a165 1
   witAssert (theCVec != NULL);
d167 3
a169 3
   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      theCVec[thePer] = (* this)[thePer];
   }
d173 4
a176 4
template <typename Elem> 
      bool WitFlexVec <Elem>::operator == (Elem theScalar) const
   {
   WitPeriod thePer;
d178 2
a179 2
   if (scalarMode ())
      return (myScalar () == theScalar);
d181 5
a185 5
   if (hasSingleValue (myCVec (), nPeriods ()))
      return (myCVec ()[0] == theScalar);
   else
      return false;
   }
d189 5
a193 5
template <typename Elem> 
      bool WitFlexVec <Elem>::operator != (Elem theScalar) const
   {
   return not ((* this) == theScalar);
   }
d197 4
a200 4
template <typename Elem> 
      bool WitFlexVec <Elem>::operator >= (Elem theScalar) const
   {
   WitPeriod thePer;
d202 2
a203 2
   if (scalarMode ())
      return (myScalar () >= theScalar);
d205 3
a207 3
   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      if (myCVec ()[thePer] < theScalar)
         return false;
d209 2
a210 2
   return true;
   }
d214 5
a218 5
template <typename Elem> 
      void WitFlexVec <Elem>::checkBounds (WitPeriod thePer) const
   { 
   if (thePer < 0)
      curAsst_->myProblem ()->myMsgFac () ("negativeIndexFmsg", thePer);
d220 5
a224 5
   if (thePer >= nPeriods ())
      curAsst_->myProblem ()->myMsgFac () ("indexTooLargeFmsg",
         thePer,
         nPeriods () - 1);
   }
d241 3
a243 3
      WitFlexVec <double> (theProblem, initValue)
   {
   }
d248 2
a249 2
   {
   }
d254 3
a256 3
   {
   thisFlexVec () = theDblFlexVec;
   }
d261 3
a263 3
   {
   thisFlexVec () = theScalar;
   }
d268 3
a270 3
   {
   thisFlexVec () = theDblTVec;
   }
d275 3
a277 3
   {
   thisFlexVec () = theDblCVec;
   }
d282 16
a297 16
   {
   bool      scalMode;
   WitPeriod thePer;

   scalMode = hasSingleValue (theFltCVec, nPeriods ());

   if (scalMode)
      (* this) = dblFromFlt (theFltCVec[0]);
   else
      {
      beInVectorMode ();

      for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
         myCVec ()[thePer] = dblFromFlt (theFltCVec[thePer]);
      }
   }
d302 3
a304 3
   {
   theIVRealArg.copyInto (* this);
   }
d309 3
a311 3
   {
   thisFlexVec ().copyInto (theDblCVec);
   }
d316 2
a317 2
   {
   WitPeriod thePer;
d319 1
a319 1
   witAssert (theFltCVec != NULL);
d321 3
a323 3
   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      theFltCVec[thePer] = fltFromDbl ((* this)[thePer]);
   }
d331 5
a335 5
      WitProbAssoc (theProblem),
      vectorMode_  (vectorModeVal),
      nPeriods_    (WitGlobalComp::defNPeriods ())
   {
   }
d340 2
a341 2
   {
   }
d346 3
a348 3
   {
   nPeriods_ = myGlobalComp ()->nPeriods ();
   }
d356 11
a366 11
      WitFlexVec <bool> & theFlexVec,
      const WitBoolean *  theCVec)
   {
   WitPeriod thePer;

   if (hasSingleValue (theCVec, theFlexVec.nPeriods ()))
      theFlexVec = asaBool (theCVec[0]);
   else
      for (thePer = theFlexVec.nPeriods () - 1; thePer >= 0; thePer --)
         theFlexVec.elemRef (thePer) = asaBool (theCVec[thePer]);
   }
d371 8
a378 8
      WitBoolean *              theCVec,
      const WitFlexVec <bool> & theFlexVec)
   {
   WitPeriod thePer;

   for (thePer = theFlexVec.nPeriods () - 1; thePer >= 0; thePer --)
      theCVec[thePer] = theFlexVec[thePer];
   }
@


1.40
log
@Updated the copyright date on all source files.
@
text
@d24 1
a24 1
#include <Global.h>
@


1.39
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.38
log
@Vector PropRtg.
@
text
@d233 1
a233 1
template class WitFlexVec <WitTlObj *>;
@


1.37
log
@Vector Prop-Rtg.
@
text
@d190 8
@


1.36
log
@Vector PropRt.
@
text
@d181 4
a184 5
   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      if (myCVec ()[thePer] != theScalar)
         return false;

   return true;
@


1.35
log
@Initial work on [vector propRouting attribute].
@
text
@d25 1
a25 1
#include <InVecRA.h>
d294 1
a294 1
void WitDblFlexVec::operator = (const WitInVecRA & theInVecRA)
d296 1
a296 1
   theInVecRA.copyInto (* this);
@


1.34
log
@PIP.
@
text
@d19 2
d26 1
d342 30
@


1.33
log
@Double Precision.
@
text
@d223 1
a293 7
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::copyInto (WitTVec <double> & theDblTVec) const
   {
   thisFlexVec ().copyInto (theDblTVec);
@


1.32
log
@Double Precision.
@
text
@d272 2
a273 1
   bool scalMode;
d283 2
a284 1
      copy (myCVec (), theFltCVec, nPeriods ());
a306 12
   }

//------------------------------------------------------------------------------

void WitDblFlexVec::copyInto (WitTVec <float> & theFltTVec) const
   {
   witAssert (theFltTVec.length () == nPeriods ());

   if (vectorMode ())
      copy (theFltTVec, myCVec ());
   else 
      theFltTVec = fltFromDbl (myScalar ());
@


1.31
log
@Double Precision.
@
text
@d282 1
a282 1
      WitNonClass::copy (myCVec (), theFltCVec, nPeriods ());
d314 1
a314 1
      WitNonClass::copy (theFltTVec, myCVec ());
@


1.30
log
@Double Precision.
@
text
@d122 1
a122 1
      theTVec.convCopyInto (myCVec ());
d147 1
a147 1
      void WitFlexVec <Elem>::convCopyInto (WitTVec <Elem> & theTVec) const
d158 1
a158 1
      void WitFlexVec <Elem>::convCopyInto (Elem * theCVec) const
d282 1
a282 1
      WitNonClass::convCopy (myCVec (), theFltCVec, nPeriods ());
d290 1
a290 1
   theInVecRA.convCopyInto (* this);
d295 1
a295 1
void WitDblFlexVec::convCopyInto (WitTVec <double> & theDblTVec) const
d297 1
a297 1
   thisFlexVec ().convCopyInto (theDblTVec);
d302 1
a302 1
void WitDblFlexVec::convCopyInto (double * theDblCVec) const
d304 1
a304 1
   thisFlexVec ().convCopyInto (theDblCVec);
d309 1
a309 1
void WitDblFlexVec::convCopyInto (WitTVec <float> & theFltTVec) const
d314 1
a314 1
      WitNonClass::convCopy (theFltTVec, myCVec ());
d321 1
a321 1
void WitDblFlexVec::convCopyInto (float * theFltCVec) const
@


1.29
log
@Double Precision.
@
text
@d53 1
a53 1
   Elem      theValue;
d58 1
a58 1
   theValue         = myScalar ();
d65 1
a65 1
      myCVec ()[thePer] = theValue;
d73 1
a73 1
   Elem theValue;
d77 1
a77 1
   theValue    = myCVec ()[0];
d83 1
a83 1
   myScalar () = theValue;
d94 1
a94 1
      convCopy (theFlexVec.myCVec ());
d96 1
a96 1
      setToScalar (theFlexVec.myScalar ());
d102 1
a102 1
      void WitFlexVec <Elem>::setToScalar (Elem theValue)
d106 1
a106 1
   myScalar () = theValue;
d112 1
a112 1
      void WitFlexVec <Elem>::convCopy (const WitTVec <Elem> & theTVec)
d117 1
a117 1
      setToScalar (theTVec[0]);
d129 1
a129 1
      void WitFlexVec <Elem>::convCopy (const Elem * theCVec)
d134 1
a134 1
      setToScalar (theCVec[0]);
d150 1
a150 1
      theTVec.convCopy    (myCVec ());
d152 1
a152 1
      theTVec.setToScalar (myScalar ());
d171 1
a171 1
      bool WitFlexVec <Elem>::operator == (Elem theValue) const
d176 1
a176 1
      return (myScalar () == theValue);
d179 1
a179 1
      if (myCVec ()[thePer] != theValue)
d188 1
a188 1
      bool WitFlexVec <Elem>::operator >= (Elem theValue) const
d193 1
a193 1
      return (myScalar () >= theValue);
d196 1
a196 1
      if (myCVec ()[thePer] < theValue)
d244 1
a244 1
   WitFlexVec <double>::operator = (theDblFlexVec);
d249 1
a249 1
void WitDblFlexVec::convCopy (const WitTVec <double> & theDblTVec)
d251 1
a251 1
   WitFlexVec <double>::convCopy (theDblTVec);
d256 1
a256 1
void WitDblFlexVec::convCopy (const double * theDblCVec)
d258 1
a258 1
   WitFlexVec <double>::convCopy (theDblCVec);
d263 8
a270 1
void WitDblFlexVec::convCopy (const float * theFltCVec)
d277 1
a277 1
      setToScalar (dblFromFlt (theFltCVec[0]));
d288 1
a288 1
void WitDblFlexVec::convCopy (const WitInVecRA & theInVecRA)
d297 1
a297 1
   WitFlexVec <double>::convCopyInto (theDblTVec);
d304 1
a304 1
   WitFlexVec <double>::convCopyInto (theDblCVec);
d316 1
a316 1
      theFltTVec.setToScalar (fltFromDbl (myScalar ()));
@


1.28
log
@Double Precision.
@
text
@d89 1
a89 1
      void WitFlexVec <Elem>::copy (const WitFlexVec & theFlexVec)
d238 7
@


1.27
log
@Double Precision.
@
text
@d23 1
d270 7
@


1.26
log
@Double Precision.
@
text
@a14 1
//    The implementation         of NonClass functions that have FlexVec args.
d17 2
a18 1
//    The implementation         of class FlexVAsst.
a25 61
// Implementation of NonClass functions that have FlexVec args.
//------------------------------------------------------------------------------

void WitNonClass::convCopy (
      WitFlexVec <double> & theDblFlexVec,
      const float *         theFltCVec)
   {
   bool scalMode;

   scalMode = hasSingleValue (theFltCVec, theDblFlexVec.nPeriods ());

   if (scalMode)
      theDblFlexVec.setToScalar (
         dblFromFlt (
            theFltCVec[0]));
   else
      {
      theDblFlexVec.beInVectorMode ();

      convCopy (
         theDblFlexVec.myCVec (),
         theFltCVec,
         theDblFlexVec.nPeriods ());
      }
   }

//------------------------------------------------------------------------------

void WitNonClass::convCopy (
      WitTVec <float> &           theFltTVec,
      const WitFlexVec <double> & theDblFlexVec)
   {
   witAssert (theFltTVec.length () == theDblFlexVec.nPeriods ());

   if (theDblFlexVec.vectorMode ())
      convCopy (
         theFltTVec,
         theDblFlexVec.myCVec ());
   else 
      theFltTVec.setToScalar (
         fltFromDbl (
            theDblFlexVec.myScalar ()));
   }

//------------------------------------------------------------------------------

void WitNonClass::convCopy (
      float *                     theFltCVec,
      const WitFlexVec <double> & theDblFlexVec)
   {
   WitPeriod thePer;

   witAssert (theFltCVec != NULL);

   for (thePer = theDblFlexVec.nPeriods () - 1; thePer >= 0; thePer --)
      theFltCVec[thePer] =
         fltFromDbl (
            theDblFlexVec[thePer]);
   }

//------------------------------------------------------------------------------
a87 24
      void WitFlexVec <Elem>::convCopyInto (WitTVec <Elem> & theTVec) const
   {
   if (vectorMode ())
      theTVec.convCopy    (myCVec ());
   else
      theTVec.setToScalar (myScalar ());
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVec <Elem>::convCopyInto (Elem * theCVec) const
   {
   WitPeriod thePer;

   witAssert (theCVec != NULL);

   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      theCVec[thePer] = (* this)[thePer];
   }

//------------------------------------------------------------------------------

template <typename Elem> 
d146 24
d222 86
@


1.25
log
@Double Precision.
@
text
@d30 2
a31 2
      WitFlexVec <double> &   theDblFlexVec,
      const WitTVec <float> & theFltTVec)
d33 3
a35 1
   witAssert (theDblFlexVec.nPeriods () == theFltTVec.length ());
d37 1
a37 1
   if (theFltTVec == theFltTVec[0])
d39 2
a40 1
         dblFromFlt (theFltTVec[0]));
d47 2
a48 1
         theFltTVec);
a83 25
   }

//------------------------------------------------------------------------------

void WitNonClass::convCopy (
      WitFlexVec <double> & theDblFlexVec,
      const float *         theFltCVec)
   {
   bool scalMode;

   scalMode = hasSingleValue (theFltCVec, theDblFlexVec.nPeriods ());

   if (scalMode)
      theDblFlexVec.setToScalar (
         dblFromFlt (
            theFltCVec[0]));
   else
      {
      theDblFlexVec.beInVectorMode ();

      convCopy (
         theDblFlexVec.myCVec (),
         theFltCVec,
         theDblFlexVec.nPeriods ());
      }
@


1.24
log
@Double Precision.
@
text
@a29 39
      WitTVec <double> &         theDblTVec,
      const WitFlexVec <float> & theFltFlexVec)
   {
   witAssert (theDblTVec.length () == theFltFlexVec.nPeriods ());

   if (theFltFlexVec.vectorMode ())
      convCopy (
         theDblTVec,
         theFltFlexVec.myCVec ());
   else
      theDblTVec.setToScalar (
         dblFromFlt (
            theFltFlexVec.myScalar ()));
   }

//------------------------------------------------------------------------------

void WitNonClass::convCopy (
      WitFlexVec <float>  &    theFltFlexVec,
      const WitTVec <double> & theDblTVec)
   {
   witAssert (theFltFlexVec.nPeriods () == theDblTVec.length ());

   if (theDblTVec == theDblTVec[0])
      theFltFlexVec.setToScalar (
         fltFromDbl (theDblTVec[0]));
   else
      {
      theFltFlexVec.beInVectorMode ();

      convCopy (
         theFltFlexVec.myCVec (),
         theDblTVec);
      }
   }

//------------------------------------------------------------------------------

void WitNonClass::convCopy (
a50 22
      WitFlexVec <float> &        theFltFlexVec,
      const WitFlexVec <double> & theDblFlexVec)
   {
   witAssert (theFltFlexVec.nPeriods () == theDblFlexVec.nPeriods ());

   if (theDblFlexVec.vectorMode ())
      {
      theFltFlexVec.beInVectorMode ();

      convCopy (
         theFltFlexVec.myCVec (),
         theDblFlexVec.myCVec (),
         theFltFlexVec.nPeriods ());
      }
   else
      theFltFlexVec.setToScalar (
         theDblFlexVec.myScalar ());
   }

//------------------------------------------------------------------------------

void WitNonClass::convCopy (
a302 1
template class WitFlexVec <float>;
@


1.23
log
@Double Precision.
@
text
@a17 1
//    The implementation         of class template FlexVData <Elem>.
d175 1
a175 1
         myData_ (theProblem, initValue)
d177 3
d187 39
d350 1
a350 1
      myData_.myProblem ()->myMsgFac () ("negativeIndexFmsg", thePer);
d353 1
a353 1
      myData_.myProblem ()->myMsgFac () ("indexTooLargeFmsg",
a365 63

//------------------------------------------------------------------------------
// Implementation of class template FlexVData <Elem>.
//------------------------------------------------------------------------------

template <typename Elem> 
      WitFlexVData <Elem>::WitFlexVData (
         WitProblem * theProblem,
         Elem         initValue):

      curAsst_ (NULL)
   {
   curAsst_    = theProblem->scalarFlexVAsst ();

   myScalar () = initValue;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      WitFlexVData <Elem>::~WitFlexVData ()
   {
   if (vectorMode ())
      switchToScalarMode ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVData <Elem>::switchToVectorMode ()
   {
   Elem      theValue;
   WitPeriod thePer;

   witAssert (scalarMode ());

   theValue   = myScalar ();

   curAsst_   = curAsst_->myProblem ()->vectorFlexVAsst ();

   myCVec_    = new Elem[nPeriods ()];

   for (thePer = nPeriods () - 1; thePer >= 0; thePer --)
      myCVec ()[thePer] = theValue;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitFlexVData <Elem>::switchToScalarMode ()
   {
   Elem theValue;

   witAssert (vectorMode ());

   theValue    = myCVec ()[0];

   delete[]      myCVec ();

   curAsst_    = curAsst_->myProblem ()->scalarFlexVAsst ();

   myScalar () = theValue;
   }
@


1.22
log
@Double Precision.
@
text
@d19 1
d23 1
a23 1
#include <Problem.h>
d309 1
a309 1
      curMsgFac () ("negativeIndexFmsg", thePer);
d312 1
a312 1
      curMsgFac () ("indexTooLargeFmsg",
d335 1
a335 1
      myIntData_ (- theProblem->nPeriods ())
d337 3
a339 1
   myScalar_ = initValue;
d348 1
a348 1
      delete[] myCVec ();
d363 1
a363 1
   myIntData_ = nPeriods ();
d380 8
a387 1
   theValue    =   myCVec ()[0];
d389 3
a391 1
   delete[]        myCVec ();
d393 1
a393 1
   myIntData_  = - nPeriods ();
d395 17
a411 1
   myScalar () =   theValue;
@


1.21
log
@Double Precision.
@
text
@d12 1
a12 1
//               
d15 4
a18 7
//    The implementation of class template OFlxVec <TheType>.
//    The implementation of NonClass functions with arguments belonging to
//       specific OFlxVec classes.
//    The implementation of class template FlexVecRep <TheType>.
//
//    The explicit instantiation of class template OFlxVec    <TheType>.
//    The explicit instantiation of class template FlexVecRep <TheType>.
d22 2
d26 1
a26 1
// Implementation of class template OFlxVec <TheType>
d29 5
a33 4
template <typename TheType> 
      WitOFlxVec <TheType>::WitOFlxVec (
         WitProblem * theProblem,
         TheType      initValue):
d35 8
a42 2
     WitFlexVecRep <TheType> (theProblem, initValue)
   {
d47 3
a49 2
template <typename TheType> 
      WitOFlxVec <TheType>::~WitOFlxVec ()
d51 13
d68 3
a70 4
template <typename TheType> 
      void WitOFlxVec <TheType>::convCopyInto (
         WitTVec <TheType> & theTVec)
         const
d72 5
a76 2
   if (repIsByVec ())
      theTVec.copy        (myVecRep ());
d78 7
a84 1
      theTVec.setToScalar (myScalRep ());
d89 3
a91 2
template <typename TheType> 
      void WitOFlxVec <TheType>::convCopyInto (TheType * theCVec) const
d93 3
a95 3
   if (repIsByVec ())
      myVecRep ().convCopyInto (theCVec);
   else
d97 1
a97 3
      WitPeriod thePer;

      witAssert (theCVec != NULL);
d99 4
a102 2
      forEachPeriod (thePer, myProblem ())
         theCVec[thePer] = myScalRep ();
d104 3
d111 3
a113 2
template <typename TheType> 
      void WitOFlxVec <TheType>::copy (const WitOFlxVec & theOFlxVec)
d115 1
a115 1
   witAssert (length () == theOFlxVec.length ());
d117 8
a124 4
   if (theOFlxVec.repIsByVec ())
      myRepMadeVec  ().copy (theOFlxVec.myVecRep  ());
   else
      myRepMadeScal () =     theOFlxVec.myScalRep ();
d129 3
a131 2
template <typename TheType> 
      void WitOFlxVec <TheType>::setToScalar (TheType theValue)
d133 8
a140 1
   myRepMadeScal () = theValue;
d145 3
a147 2
template <typename TheType> 
      void WitOFlxVec <TheType>::convCopy (const WitTVec <TheType> & theTVec)
d149 3
a151 1
   witAssert (length () == theTVec.length ());
d153 4
a156 2
   if (theTVec == theTVec[0])
      setToScalar          (theTVec[0]);
d158 8
a165 1
      myRepMadeVec ().copy (theTVec);
d169 5
d175 1
a175 2
template <typename TheType> 
      void WitOFlxVec <TheType>::convCopy (const TheType * theCVec)
a176 4
   if (hasSingleValue (theCVec, nPeriods ()))
      myRepMadeScal () = theCVec[0];
   else
      myRepMadeVec ().convCopy (theCVec);
d181 2
a182 2
template <typename TheType> 
      bool WitOFlxVec <TheType>::operator == (TheType theValue) const
a183 4
   return
      repIsByVec ()?
         (myVecRep  () == theValue):
         (myScalRep () == theValue);
d188 2
a189 2
template <typename TheType> 
      bool WitOFlxVec <TheType>::operator >= (TheType theValue) const
d191 4
a194 4
   return
      repIsByVec ()?
      myVecRepGE      (theValue):
      (myScalRep () >= theValue);
d199 2
a200 2
template <typename TheType> 
      bool WitOFlxVec <TheType>::myVecRepGE (TheType theValue) const
d204 1
a204 3
   forEachPeriod (thePer, myProblem ())
      if (myVecRep ()[thePer] < theValue)
         return false;
d206 2
a207 1
   return true;
a210 3
// Implementation of NonClass functions with arguments belonging to specific
//    OFlxVec classes.
//------------------------------------------------------------------------------
d212 2
a213 3
void WitNonClass::convCopy (
      WitTVec <double> &         theDblTVec,
      const WitOFlxVec <float> & theFltOFlxVec)
d215 1
a215 1
   witAssert (theDblTVec.length () == theFltOFlxVec.length ());
d217 2
a218 2
   if (theFltOFlxVec.repIsByVec ())
      convCopy (theDblTVec, theFltOFlxVec.myVecRep ());
d220 1
a220 1
      theDblTVec.setToScalar (theFltOFlxVec.myScalRep ());
d225 2
a226 3
void WitNonClass::convCopy (
      WitOFlxVec <float> &     theFltOFlxVec,
      const WitTVec <double> & theDblTVec)
d228 1
a228 1
   witAssert (theFltOFlxVec.length () == theDblTVec.length ());
d230 1
a230 4
   if (theDblTVec == theDblTVec[0])
      theFltOFlxVec.setToScalar (fltFromDbl (theDblTVec[0]));
   else
      convCopy (theFltOFlxVec.myRepMadeVec (), theDblTVec);
d235 2
a236 3
void WitNonClass::convCopy (
      WitOFlxVec <double> &   theDblOFlxVec,
      const WitTVec <float> & theFltTVec)
d238 1
a238 1
   witAssert (theDblOFlxVec.length () == theFltTVec.length ());
d240 2
a241 2
   if (theFltTVec == theFltTVec[0])
      theDblOFlxVec.setToScalar (dblFromFlt (theFltTVec[0]));
d243 5
a247 1
      convCopy (theDblOFlxVec.myRepMadeVec (), theFltTVec);
d252 2
a253 3
void WitNonClass::convCopy (
      WitOFlxVec <float> &        theFltOFlxVec,
      const WitOFlxVec <double> & theDblOFlxVec)
d255 1
a255 1
   witAssert (theFltOFlxVec.length () == theDblOFlxVec.length ());
d257 2
a258 2
   if (theDblOFlxVec.repIsByVec ())
      convCopy (theFltOFlxVec.myRepMadeVec (), theDblOFlxVec.myVecRep ());
d260 6
a265 1
      theFltOFlxVec.myRepMadeScal () = theDblOFlxVec.myScalRep ();
d270 2
a271 3
void WitNonClass::convCopy (
      WitTVec <float> &           theFltTVec,
      const WitOFlxVec <double> & theDblOFlxVec)
d273 1
a273 1
   witAssert (theFltTVec.length () == theDblOFlxVec.length ());
d275 8
a282 4
   if (theDblOFlxVec.repIsByVec ())
      convCopy (theFltTVec, theDblOFlxVec.myVecRep ());
   else 
      theFltTVec.setToScalar (theDblOFlxVec.myScalRep ());
d287 2
a288 3
void WitNonClass::convCopy (
      float *                     theFltCVec,
      const WitOFlxVec <double> & theDblOFlxVec)
d292 6
a297 1
   witAssert (theFltCVec != NULL);
d299 1
a299 2
   forEachPeriod (thePer, theDblOFlxVec.myProblem ())
      theFltCVec[thePer] = theDblOFlxVec[thePer];
d304 10
a313 8
void WitNonClass::convCopy (
      WitOFlxVec <double> & theDblOFlxVec,
      const float *         theFltCVec)
   {
   if (hasSingleValue (theFltCVec, theDblOFlxVec.nPeriods ()))
      theDblOFlxVec.myRepMadeScal () = theFltCVec[0];
   else
      convCopy (theDblOFlxVec.myRepMadeVec (), theFltCVec);
d317 10
a326 1
// Implementation of class template FlexVecRep <TheType>
d329 2
a330 2
template <typename TheType> 
      WitFlexVecRep <TheType>::WitFlexVecRep (
d332 1
a332 1
         TheType      initValue):
d334 1
a334 5
      WitProbAssoc (theProblem),

      repIsByVec_  (false),
      myVecRep_    (),
      myScalRep_   (initValue)
d336 1
d341 2
a342 2
template <typename TheType> 
      WitFlexVecRep <TheType>::~WitFlexVecRep ()
d344 2
d350 2
a351 2
template <typename TheType> 
      void WitFlexVecRep <TheType>::switchToVecRep ()
d353 6
a358 1
   witAssert (not repIsByVec ());
d360 1
a360 1
   myVecRep_.allocate (myProblem (), myScalRep_);
d362 4
a365 1
   repIsByVec_ = true;
d370 2
a371 2
template <typename TheType> 
      void WitFlexVecRep <TheType>::switchToScalRep ()
d373 1
a373 1
   witAssert (repIsByVec ());
d375 1
a375 1
   myScalRep_ = myVecRep_[0];
d377 1
a377 1
   myVecRep_.clear ();
d379 1
a379 2
   repIsByVec_ = false;
   }
d381 1
a381 3
//------------------------------------------------------------------------------
// Explicit instantiation of class template OFlxVec <TheType>.
//------------------------------------------------------------------------------
d383 2
a384 13
template class WitOFlxVec <bool>;
template class WitOFlxVec <int>;
template class WitOFlxVec <float>;
template class WitOFlxVec <double>;

//------------------------------------------------------------------------------
// Explicit instantiation of class template FlexVecRep <TheType>.
//------------------------------------------------------------------------------

template class WitFlexVecRep <bool>;
template class WitFlexVecRep <int>;
template class WitFlexVecRep <float>;
template class WitFlexVecRep <double>;
@


1.20
log
@Double Precision.
@
text
@d116 1
a116 1
   if (hasSingleValue (theCVec, myProblem ()))
a146 21
      bool WitOFlxVec <TheType>::hasSingleValue (
         const TheType * theCVec,
         WitProblem *    theProblem)
   {
   TheType   valAt0;
   WitPeriod thePer;

   witAssert (theCVec != NULL);

   valAt0 = theCVec[0];

   for (thePer = 1; thePer < theProblem->nPeriods (); ++ thePer)
      if (theCVec[thePer] != valAt0)
         return false;

   return true;
   }

//------------------------------------------------------------------------------

template <typename TheType> 
d164 2
a165 2
      WitTVec <double> &         theDoubleTVec,
      const WitOFlxVec <float> & theFloatOFlxVec)
d167 1
a167 1
   witAssert (theDoubleTVec.length () == theFloatOFlxVec.length ());
d169 2
a170 2
   if (theFloatOFlxVec.repIsByVec ())
      convCopy (theDoubleTVec, theFloatOFlxVec.myVecRep ());
d172 1
a172 1
      theDoubleTVec.setToScalar (theFloatOFlxVec.myScalRep ());
d178 2
a179 2
      WitOFlxVec <float> &     theFloatOFlxVec,
      const WitTVec <double> & theDoubleTVec)
d181 1
a181 1
   witAssert (theFloatOFlxVec.length () == theDoubleTVec.length ());
d183 2
a184 2
   if (theDoubleTVec == theDoubleTVec[0])
      theFloatOFlxVec.setToScalar (fltFromDbl (theDoubleTVec[0]));
d186 1
a186 1
      convCopy (theFloatOFlxVec.myRepMadeVec (), theDoubleTVec);
d192 2
a193 2
      WitOFlxVec <double> &   theDoubleOFlxVec,
      const WitTVec <float> & theFloatTVec)
d195 1
a195 1
   witAssert (theDoubleOFlxVec.length () == theFloatTVec.length ());
d197 2
a198 2
   if (theFloatTVec == theFloatTVec[0])
      theDoubleOFlxVec.setToScalar (dblFromFlt (theFloatTVec[0]));
d200 1
a200 1
      convCopy (theDoubleOFlxVec.myRepMadeVec (), theFloatTVec);
d206 2
a207 2
      WitOFlxVec <float> &        theFloatOFlxVec,
      const WitOFlxVec <double> & theDoubleOFlxVec)
d209 1
a209 1
   witAssert (theFloatOFlxVec.length () == theDoubleOFlxVec.length ());
d211 2
a212 2
   if (theDoubleOFlxVec.repIsByVec ())
      convCopy (theFloatOFlxVec.myRepMadeVec (), theDoubleOFlxVec.myVecRep ());
d214 1
a214 1
      theFloatOFlxVec.myRepMadeScal () = theDoubleOFlxVec.myScalRep ();
d220 2
a221 2
      WitTVec <float> &           theFloatTVec,
      const WitOFlxVec <double> & theDoubleOFlxVec)
d223 1
a223 1
   witAssert (theFloatTVec.length () == theDoubleOFlxVec.length ());
d225 2
a226 2
   if (theDoubleOFlxVec.repIsByVec ())
      convCopy (theFloatTVec, theDoubleOFlxVec.myVecRep ());
d228 1
a228 1
      theFloatTVec.setToScalar (theDoubleOFlxVec.myScalRep ());
d234 2
a235 2
      float *                     theFloatCVec,
      const WitOFlxVec <double> & theDoubleOFlxVec)
d239 1
a239 1
   witAssert (theFloatCVec != NULL);
d241 2
a242 2
   forEachPeriod (thePer, theDoubleOFlxVec.myProblem ())
      theFloatCVec[thePer] = theDoubleOFlxVec[thePer];
d248 2
a249 2
      WitOFlxVec <double> & theDoubleOFlxVec,
      const float *         theFloatCVec)
d251 2
a252 6
   WitProblem * theProblem;

   theProblem = theDoubleOFlxVec.myProblem ();

   if (WitOFlxVec <float>::hasSingleValue (theFloatCVec, theProblem))
      theDoubleOFlxVec.myRepMadeScal () = theFloatCVec[0];
d254 1
a254 1
      convCopy (theDoubleOFlxVec.myRepMadeVec (), theFloatCVec);
@


1.19
log
@Double Precision.
@
text
@d21 1
d340 9
@


1.18
log
@Double Precision.
@
text
@d15 1
a15 1
//    The implementation of class template FlexVec <TheType>.
d17 1
a17 1
//       specific FlexVec classes.
d20 1
a20 2
//    The explicit instantiation of class template FlexVec    <TheType>.
//    The explicit instantiation of class template FlexVecRep <TheType>.
d26 1
a26 1
// Implementation of class template FlexVec <TheType>
d30 1
a30 1
      WitFlexVec <TheType>::WitFlexVec (
d41 1
a41 1
      WitFlexVec <TheType>::~WitFlexVec ()
d48 1
a48 1
      void WitFlexVec <TheType>::convCopyInto (
d61 1
a61 1
      void WitFlexVec <TheType>::convCopyInto (TheType * theCVec) const
d79 1
a79 1
      void WitFlexVec <TheType>::copy (const WitFlexVec & theFlexVec)
d81 1
a81 1
   witAssert (length () == theFlexVec.length ());
d83 2
a84 2
   if (theFlexVec.repIsByVec ())
      myRepMadeVec  ().copy (theFlexVec.myVecRep  ());
d86 1
a86 1
      myRepMadeScal () =     theFlexVec.myScalRep ();
d92 1
a92 1
      void WitFlexVec <TheType>::setToScalar (TheType theValue)
d100 1
a100 1
      void WitFlexVec <TheType>::convCopy (const WitTVec <TheType> & theTVec)
d113 1
a113 1
      void WitFlexVec <TheType>::convCopy (const TheType * theCVec)
d124 1
a124 1
      bool WitFlexVec <TheType>::operator == (TheType theValue) const
d135 1
a135 1
      bool WitFlexVec <TheType>::operator >= (TheType theValue) const
d146 1
a146 1
      bool WitFlexVec <TheType>::hasSingleValue (
d167 1
a167 1
      bool WitFlexVec <TheType>::myVecRepGE (TheType theValue) const
d180 1
a180 1
//    FlexVec classes.
d185 1
a185 1
      const WitFlexVec <float> & theFloatFlexVec)
d187 1
a187 1
   witAssert (theDoubleTVec.length () == theFloatFlexVec.length ());
d189 2
a190 2
   if (theFloatFlexVec.repIsByVec ())
      convCopy (theDoubleTVec, theFloatFlexVec.myVecRep ());
d192 1
a192 1
      theDoubleTVec.setToScalar (theFloatFlexVec.myScalRep ());
d198 1
a198 1
      WitFlexVec <float> &     theFloatFlexVec,
d201 1
a201 1
   witAssert (theFloatFlexVec.length () == theDoubleTVec.length ());
d204 1
a204 1
      theFloatFlexVec.setToScalar (fltFromDbl (theDoubleTVec[0]));
d206 1
a206 1
      convCopy (theFloatFlexVec.myRepMadeVec (), theDoubleTVec);
d212 1
a212 1
      WitFlexVec <double> &   theDoubleFlexVec,
d215 1
a215 1
   witAssert (theDoubleFlexVec.length () == theFloatTVec.length ());
d218 1
a218 1
      theDoubleFlexVec.setToScalar (dblFromFlt (theFloatTVec[0]));
d220 1
a220 1
      convCopy (theDoubleFlexVec.myRepMadeVec (), theFloatTVec);
d226 2
a227 2
      WitFlexVec <float> &        theFloatFlexVec,
      const WitFlexVec <double> & theDoubleFlexVec)
d229 1
a229 1
   witAssert (theFloatFlexVec.length () == theDoubleFlexVec.length ());
d231 2
a232 2
   if (theDoubleFlexVec.repIsByVec ())
      convCopy (theFloatFlexVec.myRepMadeVec (), theDoubleFlexVec.myVecRep ());
d234 1
a234 1
      theFloatFlexVec.myRepMadeScal () = theDoubleFlexVec.myScalRep ();
d241 1
a241 1
      const WitFlexVec <double> & theDoubleFlexVec)
d243 1
a243 1
   witAssert (theFloatTVec.length () == theDoubleFlexVec.length ());
d245 2
a246 2
   if (theDoubleFlexVec.repIsByVec ())
      convCopy (theFloatTVec, theDoubleFlexVec.myVecRep ());
d248 1
a248 1
      theFloatTVec.setToScalar (theDoubleFlexVec.myScalRep ());
d255 1
a255 1
      const WitFlexVec <double> & theDoubleFlexVec)
d261 2
a262 2
   forEachPeriod (thePer, theDoubleFlexVec.myProblem ())
      theFloatCVec[thePer] = theDoubleFlexVec[thePer];
d268 1
a268 1
      WitFlexVec <double> & theDoubleFlexVec,
d273 1
a273 1
   theProblem = theDoubleFlexVec.myProblem ();
d275 2
a276 2
   if (WitFlexVec <float>::hasSingleValue (theFloatCVec, theProblem))
      theDoubleFlexVec.myRepMadeScal () = theFloatCVec[0];
d278 1
a278 1
      convCopy (theDoubleFlexVec.myRepMadeVec (), theFloatCVec);
d332 1
a332 1
// Explicit instantiation of class template FlexVec <TheType>.
d335 4
a338 13
template class WitFlexVec <bool>;
template class WitFlexVec <int>;
template class WitFlexVec <float>;
template class WitFlexVec <double>;

//------------------------------------------------------------------------------
// Explicit instantiation of class template FlexVecRep <TheType>.
//------------------------------------------------------------------------------

template class WitFlexVecRep <bool>;
template class WitFlexVecRep <int>;
template class WitFlexVecRep <float>;
template class WitFlexVecRep <double>;
@


1.17
log
@Double Precision.
@
text
@d49 1
a49 1
      void WitFlexVec <TheType>::copyIntoTVec (
d62 1
a62 1
      void WitFlexVec <TheType>::copyIntoCVec (TheType * theCVec) const
d65 1
a65 1
      myVecRep ().copyIntoCVec (theCVec);
d101 1
a101 2
      void WitFlexVec <TheType>::copyTVec (
         const WitTVec <TheType> & theTVec)
d114 1
a114 1
      void WitFlexVec <TheType>::copyCVec (const TheType * theCVec)
d119 1
a119 1
      myRepMadeVec ().copyCVec (theCVec);
@


1.16
log
@Double Precision.
@
text
@d185 1
a185 1
void WitNonClass::copyInto (
d192 1
a192 1
      copyInto (theDoubleTVec, theFloatFlexVec.myVecRep ());
d199 1
a199 1
void WitNonClass::copyInto (
d208 1
a208 1
      copyInto (theFloatFlexVec.myRepMadeVec (), theDoubleTVec);
d213 1
a213 1
void WitNonClass::copyInto (
d222 1
a222 1
      copyInto (theDoubleFlexVec.myRepMadeVec (), theFloatTVec);
d227 1
a227 1
void WitNonClass::copyInto (
d234 1
a234 1
      copyInto (theFloatFlexVec.myRepMadeVec (), theDoubleFlexVec.myVecRep ());
d241 1
a241 1
void WitNonClass::copyInto (
d248 1
a248 1
      copyInto (theFloatTVec, theDoubleFlexVec.myVecRep ());
d255 1
a255 1
void WitNonClass::copyInto (
d269 1
a269 1
void WitNonClass::copyInto (
d280 1
a280 1
      copyInto (theDoubleFlexVec.myRepMadeVec (), theFloatCVec);
@


1.15
log
@Double Precision.
@
text
@d206 1
a206 1
      theFloatFlexVec.setToScalar (floatFromDouble (theDoubleTVec[0]));
d220 1
a220 1
      theDoubleFlexVec.setToScalar (doubleFromFloat (theFloatTVec[0]));
@


1.14
log
@Double Precision.
@
text
@d62 1
a62 1
      void WitFlexVec <TheType>::copyIntoCvector (TheType * theCvector) const
d65 1
a65 1
      myVecRep ().copyIntoCvector (theCvector);
d70 1
a70 1
      witAssert (theCvector != NULL);
d73 1
a73 1
         theCvector[thePer] = myScalRep ();
d115 1
a115 1
      void WitFlexVec <TheType>::copyCvector (const TheType * theCvector)
d117 2
a118 2
   if (hasSingleValue (theCvector, myProblem ()))
      myRepMadeScal () = theCvector[0];
d120 1
a120 1
      myRepMadeVec ().copyCvector (theCvector);
d149 1
a149 1
         const TheType * theCvector,
d155 1
a155 1
   witAssert (theCvector != NULL);
d157 1
a157 1
   valAt0 = theCvector[0];
d160 1
a160 1
      if (theCvector[thePer] != valAt0)
d256 1
a256 1
      float *                     theFloatCvector,
d261 1
a261 1
   witAssert (theFloatCvector != NULL);
d264 1
a264 1
      theFloatCvector[thePer] = theDoubleFlexVec[thePer];
d271 1
a271 1
      const float *         theFloatCvector)
d277 2
a278 2
   if (WitFlexVec <float>::hasSingleValue (theFloatCvector, theProblem))
      theDoubleFlexVec.myRepMadeScal () = theFloatCvector[0];
d280 1
a280 1
      copyInto (theDoubleFlexVec.myRepMadeVec (), theFloatCvector);
@


1.13
log
@An attempt to fix more syntax errors from on Windows.
@
text
@d206 1
a206 1
      theFloatFlexVec.setToScalar (theDoubleTVec[0]);
d209 14
@


1.12
log
@Continued implementation of PIP.
@
text
@d117 1
a117 1
   if (WitFlexVecUtil::hasSingleValue (theCvector, myProblem ()))
d148 3
a150 1
      bool WitFlexVec <TheType>::myVecRepGE (TheType theValue) const
d152 1
d155 6
a160 2
   forEachPeriod (thePer, myProblem ())
      if (myVecRep ()[thePer] < theValue)
d169 1
a169 3
      bool WitFlexVecUtil::hasSingleValue (
         const TheType * theCvector,
         WitProblem *    theProblem)
a170 1
   TheType   valAt0;
d173 2
a174 6
   witAssert (theCvector != NULL);

   valAt0 = theCvector[0];

   for (thePer = 1; thePer < theProblem->nPeriods (); ++ thePer)
      if (theCvector[thePer] != valAt0)
d263 1
a263 1
   if (WitFlexVecUtil::hasSingleValue (theFloatCvector, theProblem))
@


1.11
log
@Continued implementation of post-implosion pegging.
@
text
@d16 1
a16 1
//    The implementation of global functions with arguments belonging to
d117 1
a117 1
   if (hasSingleValue (theCvector, myProblem ()))
d162 3
a164 1
      bool hasSingleValue (const TheType * theCvector, WitProblem * theProblem)
d181 1
a181 1
// Implementation of global functions with arguments belonging to specific
d185 1
a185 1
void copyInto (
d199 1
a199 1
void copyInto (
d213 1
a213 1
void copyInto (
d227 1
a227 1
void copyInto (
d241 1
a241 1
void copyInto (
d255 1
a255 1
void copyInto (
d259 5
a263 1
   if (hasSingleValue (theFloatCvector, theDoubleFlexVec.myProblem ()))
@


1.10
log
@Continued implementation of post-implosion pegging.
@
text
@d13 9
a21 5
// Contains the implementation         of class template FlexVec <TheType>.
// Contains the explicit instantiation of class template FlexVec <TheType>.
// Contains the implementation of global functions with arguments belonging to
//    specific FlexVec classes.
// Contains the implementation of class template FlexVecRep <TheType>.
a178 9
// Explicit instantiation of class template FlexVec <TheType>.
//------------------------------------------------------------------------------

template class WitFlexVec <bool>;
template class WitFlexVec <int>;
template class WitFlexVec <float>;
template class WitFlexVec <double>;

//------------------------------------------------------------------------------
d312 18
@


1.9
log
@Removed all empty files from WIT (64 of them).
@
text
@d1 316
@


1.8
log
@Preliminary work on single source.
@
text
@@


1.7
log
@Continued preliminary work on single source.
@
text
@a0 258
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "FlexVec.C"
//
// Contains the implementation of the following generic classes:
//
//    FlexVecRep (TheType)
//    FlexVec    (TheType)
//------------------------------------------------------------------------------

#include <FlexVec.h>

//------------------------------------------------------------------------------
// Implementation macro for generic class FlexVecRep (TheType).
// Invoked by the implementation macro for FlexVec (TheType) in this file.
//------------------------------------------------------------------------------

#define WitFlexVecRepimplement(TheType)                                        \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitFlexVecRep (TheType)::WitFlexVecRep (TheType) (                             \
         WitProblem * theProblem,                                              \
         TheType      initValue):                                              \
                                                                               \
      WitProbAssoc (theProblem),                                               \
                                                                               \
      repIsByVec_  (witFALSE),                                                 \
      myVecRep_    (),                                                         \
      myScalRep_   (initValue)                                                 \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitFlexVecRep (TheType)::~WitFlexVecRep (TheType) ()                           \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitFlexVecRep (TheType)::switchToVecRep ()                                \
   {                                                                           \
   witAssert (! repIsByVec ());                                                \
                                                                               \
   myVecRep_.allocate (myProblem (), myScalRep_);                              \
                                                                               \
   repIsByVec_ = witTRUE;                                                      \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitFlexVecRep (TheType)::switchToScalRep ()                               \
   {                                                                           \
   witAssert (repIsByVec ());                                                  \
                                                                               \
   myScalRep_ = myVecRep_[0];                                                  \
                                                                               \
   myVecRep_.clear ();                                                         \
                                                                               \
   repIsByVec_ = witFALSE;                                                     \
   }                                                                           \

//------------------------------------------------------------------------------
// Implementation macro for generic class FlexVec (TheType).
//------------------------------------------------------------------------------

#define WitFlexVecimplement(TheType)                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitFlexVecRepimplement (TheType)                                               \
   /*                                                                        */\
   /* Implements FlexVecRep (TheType)                                        */\
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitFlexVec (TheType)::WitFlexVec (TheType) (                                   \
         WitProblem * theProblem,                                              \
         TheType      initValue):                                              \
                                                                               \
     WitFlexVecRep (TheType) (theProblem, initValue)                           \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitFlexVec (TheType)::~WitFlexVec (TheType) ()                                 \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitFlexVec (TheType)::copySelfInto (WitTVec <TheType> & theTVec) const    \
   {                                                                           \
   if (repIsByVec ())                                                          \
      theTVec.copy  (myVecRep ());                                             \
   else                                                                        \
      theTVec.setTo (myScalRep ());                                            \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitFlexVec (TheType)::copySelfInto (TheType * theCvector) const           \
   {                                                                           \
   if (repIsByVec ())                                                          \
      myVecRep ().copySelfInto (theCvector);                                   \
   else                                                                        \
      {                                                                        \
      WitPeriod thePer;                                                        \
                                                                               \
      witAssert (theCvector != NULL);                                          \
                                                                               \
      forEachPeriod (thePer, myProblem ())                                     \
         theCvector[thePer] = myScalRep ();                                    \
      }                                                                        \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitFlexVec (TheType)::operator = (const WitTVec <TheType> & theTVec)      \
   {                                                                           \
   witAssert (length () == theTVec.length ());                                 \
                                                                               \
   if (theTVec == theTVec[0])                                                  \
      (* this)        = theTVec[0];                                            \
   else                                                                        \
      myRepMadeVec ().copy (theTVec);                                          \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitFlexVec (TheType)::operator = (const TheType * theCvector)             \
   {                                                                           \
   if (hasSingleValue (theCvector, myProblem ()))                              \
      myRepMadeScal () = theCvector[0];                                        \
   else                                                                        \
      myRepMadeVec ().copyFromCvector (theCvector);                            \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitBoolean WitFlexVec (TheType)::myVecRepGE (TheType theValue) const           \
   {                                                                           \
   WitPeriod thePer;                                                           \
                                                                               \
   forEachPeriod (thePer, myProblem ())                                        \
      if (myVecRep ()[thePer] < theValue)                                      \
         return witFALSE;                                                      \
                                                                               \
   return witTRUE;                                                             \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitBoolean hasSingleValue (                                                    \
      const TheType * theCvector,                                              \
      WitProblem *    theProblem)                                              \
   {                                                                           \
   TheType   valAt0;                                                           \
   WitPeriod thePer;                                                           \
                                                                               \
   witAssert (theCvector != NULL);                                             \
                                                                               \
   valAt0 = theCvector[0];                                                     \
                                                                               \
   for (thePer = 1; thePer < theProblem->nPeriods (); ++ thePer)               \
      if (theCvector[thePer] != valAt0)                                        \
         return witFALSE;                                                      \
                                                                               \
   return witTRUE;                                                             \
   }                                                                           \

//------------------------------------------------------------------------------
// Implementations of all specific cases of generic class FlexVec (TheType).
//------------------------------------------------------------------------------

implement (WitFlexVec, float)
implement (WitFlexVec, double)
implement (WitFlexVec, int)

//------------------------------------------------------------------------------
// Implementation of global functions with FlexVec arguments.
//------------------------------------------------------------------------------

void copyInto (
      WitTVec <double> &         theDoubleTVec,
      const WitFlexVec (float) & theFloatFlexVec)
   {
   witAssert (theDoubleTVec.length () == theFloatFlexVec.length ());

   if (theFloatFlexVec.repIsByVec ())
      copyInto (theDoubleTVec, theFloatFlexVec.myVecRep ());
   else
      theDoubleTVec.setTo (theFloatFlexVec.myScalRep ());
   }

//------------------------------------------------------------------------------

void copyInto (
      WitFlexVec (float) &     theFloatFlexVec,
      const WitTVec <double> & theDoubleTVec)
   {
   witAssert (theFloatFlexVec.length () == theDoubleTVec.length ());

   if (theDoubleTVec == theDoubleTVec[0])
      theFloatFlexVec = theDoubleTVec[0];
   else
      copyInto (theFloatFlexVec.myRepMadeVec (), theDoubleTVec);
   }

//------------------------------------------------------------------------------

void copyInto (
      WitTVec <float> &           theFloatTVec,
      const WitFlexVec (double) & theDoubleFlexVec)
   {
   witAssert (theFloatTVec.length () == theDoubleFlexVec.length ());

   if (theDoubleFlexVec.repIsByVec ())
      copyInto (theFloatTVec, theDoubleFlexVec.myVecRep ());
   else 
      theFloatTVec.setTo (theDoubleFlexVec.myScalRep ());
   }

//------------------------------------------------------------------------------

void copyInto (
      float *                     theFloatCvector,
      const WitFlexVec (double) & theDoubleFlexVec)
   {
   WitPeriod thePer;

   witAssert (theFloatCvector != NULL);

   forEachPeriod (thePer, theDoubleFlexVec.myProblem ())
      theFloatCvector[thePer] = theDoubleFlexVec[thePer];
   }

//------------------------------------------------------------------------------

void copyInto (
      WitFlexVec (double) & theDoubleFlexVec,
      const float *         theFloatCvector)
   {
   if (hasSingleValue (theFloatCvector, theDoubleFlexVec.myProblem ()))
      theDoubleFlexVec.myRepMadeScal () = theFloatCvector[0];
   else
      copyInto (theDoubleFlexVec.myRepMadeVec (), theFloatCvector);
   }
@


1.6
log
@Preliminary work on single source.
@
text
@d102 1
a102 1
void WitFlexVec (TheType)::copySelfInto (WitTVec (TheType) & theTVec) const    \
d105 1
a105 1
      theTVec = myVecRep ();                                                   \
d107 1
a107 1
      theTVec = myScalRep ();                                                  \
d129 1
a129 1
void WitFlexVec (TheType)::operator = (const WitTVec (TheType) & theTVec)      \
d136 1
a136 1
      myRepMadeVec () = theTVec;                                               \
d146 1
a146 1
      myRepMadeVec ()  = theCvector;                                           \
d195 1
a195 1
      WitTVec (double) &         theDoubleTVec,
d203 1
a203 1
      theDoubleTVec = theFloatFlexVec.myScalRep ();
d210 1
a210 1
      const WitTVec (double) & theDoubleTVec)
d223 1
a223 1
      WitTVec (float) &           theFloatTVec,
d231 1
a231 1
      theFloatTVec = theDoubleFlexVec.myScalRep ();
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@a150 17
WitBoolean WitFlexVec (TheType)::operator == (                                 \
      const WitFlexVec (TheType) & theFlexVec)                                 \
      const                                                                    \
   {                                                                           \
   if (length () != theFlexVec.length ())                                      \
      return witFALSE;                                                         \
                                                                               \
   return                                                                      \
      repIsByVec ()?                                                           \
         theFlexVec.repIsByVec ()?                                             \
            (myVecRep () == theFlexVec. myVecRep ()):                          \
            (myVecRep () == theFlexVec.myScalRep ()):                          \
         (theFlexVec == myScalRep ());                                         \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
@


1.4
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d102 1
a102 1
void WitFlexVec (TheType)::copyInto (WitTVec (TheType) & theTVec) const        \
d112 1
a112 1
void WitFlexVec (TheType)::copyInto (TheType * theCvector) const               \
d115 1
a115 1
      myVecRep ().copyInto (theCvector);                                       \
d211 1
a211 1
void copyTo (
d218 1
a218 1
      copyTo (theDoubleTVec, theFloatFlexVec.myVecRep ());
d225 1
a225 1
void copyTo (
d234 1
a234 1
      copyTo (theFloatFlexVec.myRepMadeVec (), theDoubleTVec);
d239 1
a239 1
void copyTo (
d246 1
a246 1
      copyTo (theFloatTVec, theDoubleFlexVec.myVecRep ());
d253 1
a253 1
void copyTo (
d267 1
a267 1
void copyTo (
d274 1
a274 1
      copyTo (theDoubleFlexVec.myRepMadeVec (), theFloatCvector);
@


1.3
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d143 4
a146 16
   TheType   valAt0;                                                           \
   WitPeriod thePer;                                                           \
                                                                               \
   witAssert (theCvector != NULL);                                             \
                                                                               \
   valAt0 = theCvector[0];                                                     \
                                                                               \
   for (thePer = 1; thePer < nPeriods (); ++ thePer)                           \
      if (theCvector[thePer] != valAt0)                                        \
         {                                                                     \
         myRepMadeVec () = theCvector;                                         \
                                                                               \
         return;                                                               \
         }                                                                     \
                                                                               \
   myRepMadeScal () = valAt0;                                                  \
d178 20
d204 1
d211 3
a213 3
void copy (
               WitTVec (double) & theDoubleTVec,
      const WitFlexVec (float)  & theFloatFlexVec)
d218 1
a218 1
      copy (theDoubleTVec, theFloatFlexVec.myVecRep ());
d225 2
a226 2
void copy (
         WitFlexVec (float)  & theFloatFlexVec,
d234 41
a274 1
      copy (theFloatFlexVec.myRepMadeVec (), theDoubleTVec);
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d163 17
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

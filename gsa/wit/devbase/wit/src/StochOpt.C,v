head	1.103;
access;
symbols
	sce_5_01_20080919:1.80;
locks; strict;
comment	@ * @;


1.103
date	2011.09.28.23.50.33;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2011.09.24.00.28.49;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2011.08.30.20.18.18;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2011.08.25.23.27.08;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2011.03.02.00.21.16;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.11.12.22.03.05;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.10.14.16.07.27;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.10.12.22.02.21;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2010.09.10.22.10.42;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2010.08.27.21.06.50;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2010.08.24.22.06.44;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2010.08.19.18.00.15;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2010.05.28.14.40.37;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2010.05.19.20.34.10;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2010.05.14.21.20.56;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.12.18.38.07;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2010.05.11.22.26.28;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2010.03.24.21.31.03;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2010.03.23.22.45.21;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2009.12.31.20.45.10;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.19.20.46.07;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.18.19.00.02;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.17.22.54.49;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.29.23.24.30;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2008.02.28.00.00.43;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2008.02.27.23.19.12;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2008.02.27.22.49.18;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2008.02.14.19.19.26;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2008.02.14.19.16.18;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.13.23.22.24;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.13.20.22.56;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.13.16.50.44;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.12.22.04.04;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.08.23.33.47;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2008.02.07.23.30.11;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2008.02.07.21.49.36;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.07.18.41.40;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2008.02.01.21.33.07;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2008.01.31.20.41.51;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2008.01.30.22.25.43;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.30.21.07.16;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.29.19.50.01;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2008.01.29.00.29.02;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2008.01.25.00.19.23;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2008.01.24.19.29.36;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2008.01.23.21.13.47;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.18.22.41.00;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.18.20.56.44;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.09.19.35.49;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.08.20.44.22;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.04.20.25.28;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.22.19.58.53;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.16.20.58.20;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.11.19.16.58;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.10.19.51.29;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.08.18.56.37;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.26.14.36.17;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.25.21.03.06;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.21.23.10.49;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.21.23.06.09;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.21.14.47.32;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.20.22.17.58;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.20.18.46.17;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.19.17.41.35;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.14.21.13.59;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.14.15.44.41;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.12.21.55.01;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.11.18.09.18;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.10.21.01.35;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.07.20.25.12;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.07.20.10.23;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.07.15.19.30;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.06.18.59.14;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.05.22.23.58;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.30.19.39.02;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.30.17.34.35;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.29.22.28.44;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.29.16.24.24;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.24.22.14.02;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.24.21.49.58;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.24.21.12.38;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.24.20.17.25;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.24.15.48.08;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.22.23.24.10;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.22.22.45.30;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.22.22.16.16;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.21.18.43.47;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.20.22.48.00;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.17.21.47.43;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.16.21.27.41;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.15.22.10.56;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.15.21.36.43;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.14.15.03.01;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.10.20.42.57;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.09.22.29.08;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.09.20.45.06;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.09.20.17.43;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.09.19.30.37;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.08.23.27.44;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.08.20.18.13;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.07.22.00.05;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.07.21.22.37;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.07.19.17.44;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.103
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "StochOpt.C"
//
// Contains the implementation of the following classes:
//
//    StochOptMgr
//    StochImpOP
//    ScenGroup
//    StochLoc
//    StochVar
//    StochCon
//------------------------------------------------------------------------------

#include <StochOptMgr.h>
#include <StochLoc.h>
#include <StVars.h>
#include <StCons.h>
#include <Stage.h>
#include <StageMgr.h>
#include <ScenMgr.h>
#include <Scenario.h>
#include <ScenAttMgr.h>
#include <ScenInputAtt.h>
#include <StochImpOP.h>
#include <StochImpMgr.h>
#include <OptStarter.h>
#include <Pre.h>
#include <Post.h>
#include <wit/src/Variant.h>
#include <OptComp.h>
#include <Material.h>
#include <Operation.h>
#include <Demand.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BoundSet.h>
#include <ExecPerSch.h>
#include <PtrMap.h>
#include <Timing.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class StochOptMgr.
//------------------------------------------------------------------------------

WitStochOptMgr::WitStochOptMgr (WitStochModeMgr * theStochModeMgr):

      WitStochAssoc  (theStochModeMgr),
      myStochImpOP_  (NULL),
      uploadingSoln_ (false)
   {
   }

//------------------------------------------------------------------------------

WitStochOptMgr::~WitStochOptMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitStochOptMgr::implode ()
   {
   WitTimer::enterSection ("opt-prob");

   startStochImp ();

   myStochImpOP_->solve ();

   finishStochImp ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitStochOptMgr::startStochImp ()
   {
   stronglyAssert (not stochSolnMode ());

   myMsgFac () ("stochImpMsg");

   myOptComp    ()->requireCplex  ();
   myScenAttMgr ()->downloadInput ();
   myStageMgr   ()->validateData  ();
   myScenMgr    ()->validateData  ();
   myScenAttMgr ()->validateData  ();

   myProblem      ()->resetSoln ();

   myPreprocessor ()->preprocess ();

   myOptComp      ()->optInitMethod ()->display ();

   myMsgFac () ("genLpMipProbMsg", myMsgFac ().myFrag ("stochLpFrag"));

   myStochImpOP_ = new WitStochImpOP (myStochModeMgr ());

   myStochImpOP_->generateFixed ();

   myStochImpOP_->generateFlexible ();
   }

//------------------------------------------------------------------------------

void WitStochOptMgr::finishStochImp ()
   {
   myProblem ()->optVariant ()->becomesCurrent ();

   uploadObjValues ();

   uploadScenSoln ();

   delete myStochImpOP_;

   myStochImpOP_ = NULL;

   myStochModeMgr ()->uploadSoln ();

   myPostprocessor ()->postprocess ();
   }

//------------------------------------------------------------------------------

void WitStochOptMgr::uploadObjValues ()
   {
   double        objValue;
   double        boundsValue;
   WitOptVar *   theOptVar;
   WitStochVar * theStochVar;

   uploadingSoln_ = true;

   objValue       = myStochImpOP_->compObjValue ();

   myStochModeMgr ()->passObjValue (objValue);

   boundsValue    = 0.0;

   forEachEl (theOptVar, myStochImpOP_->myOptVars ())
      {
      theStochVar = theOptVar->mandStochVar ();

      if (theStochVar->isStSlbvVar ())
         {
         boundsValue +=
            theStochVar->primalValue () *
            theStochVar->totalProb   ();
         }
      }

   myStochModeMgr ()->passBoundsValue (boundsValue);

   uploadingSoln_ = false;

   myOptComp ()->writeObjValue ();
   }

//------------------------------------------------------------------------------

void WitStochOptMgr::uploadScenSoln ()
   {
   WitOptVar *   theOptVar;
   WitStochVar * theStochVar;
   WitScenario * theScenario;

   uploadingSoln_ = true;

   forEachEl (theOptVar, myStochImpOP_->myOptVars ())
      {
      theStochVar = theOptVar->mandStochVar ();

      forEachEl (theScenario, theStochVar->myScenGroup ()->myScenarios ())
         theStochVar->uploadSolnTo (theScenario);
      }

   uploadingSoln_ = false;
   }

//------------------------------------------------------------------------------
// Implementation of class StochImpOP.
//------------------------------------------------------------------------------

WitStochImpOP::WitStochImpOP (WitStochModeMgr * theStochModeMgr):

      WitOptProblem         (theStochModeMgr->myProblem ()),
      myStochModeMgr_       (theStochModeMgr),
      myScenGroups_         (),
      myScenGroupForStage0_ (NULL),
      myExecPerSched_       (NULL)
   {
   buildScenGroups ();

   myExecPerSched_ = new WitExecPerSched <WitBillEntry> (myProblem ());
   }

//------------------------------------------------------------------------------

WitStochImpOP::~WitStochImpOP ()
   {
   delete myExecPerSched_;

   myScenGroupForStage0_ = NULL;

   while (not myScenGroups_.isEmpty ())
      delete myScenGroups_.get ();
   }

//------------------------------------------------------------------------------

bool WitStochImpOP::needDual ()
   {
   return false;
   }

//------------------------------------------------------------------------------

bool WitStochImpOP::reSolveMode ()
   {
   return false;
   }

//------------------------------------------------------------------------------

void WitStochImpOP::printItem (WitNode * theNode)
   {
   fprintf (optProbFile (),
      " %-11s                        ",
      theNode->nodeName ().myCstring ());
   }

//------------------------------------------------------------------------------

void WitStochImpOP::printItem (WitDemand * theDemand)
   {
   fprintf (optProbFile (),
      " %-11s %-11s            ", 
      theDemand->demandedPartName ().myCstring (),
      theDemand->demandName ()      .myCstring ());
   }

//------------------------------------------------------------------------------

void WitStochImpOP::printItem (WitBomEntry * theBomEnt)
   {
   fprintf (optProbFile (),
      " %-11s %-11d            ", 
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex ());
   }

//------------------------------------------------------------------------------

void WitStochImpOP::printItem (WitSubEntry * theSub)
   {
   fprintf (optProbFile (),
      " %-11s %-11d %-11d", 
      theSub->myOperationName ().myCstring (),
      theSub->myBomEntIndex (),
      theSub->localIndex ());
   }

//------------------------------------------------------------------------------

void WitStochImpOP::printItem (WitStBddVar * theStBddVar)
   {
   fprintf (optProbFile (),
      " Var #%-6d BS #%-7d            ",
      theStBddVar->index (),
      theStBddVar->myBoundSet ()->mappingIndex ());
   }

//------------------------------------------------------------------------------

void WitStochImpOP::generateVariables ()
   {
   WitScenGroup * theScenGroup;
   WitStochLoc *  theStochLoc;
   WitOptVar *    theOptVar;

   forEachEl (theScenGroup, myScenGroups_)
      forEachEl (theStochLoc, theScenGroup->myStochLocs ())
         theStochLoc->generateVariables ();

   forEachEl (theOptVar, myOptVars ())
      theOptVar->mandStochVar ()->genStSlbvVarIfNeeded ();
   }

//------------------------------------------------------------------------------

void WitStochImpOP::generateConstraints ()
   {
   WitScenGroup * theScenGroup;
   WitStochLoc *  theStochLoc;
   WitOptVar *    theOptVar;

   forEachEl (theScenGroup, myScenGroups_)
      forEachEl (theStochLoc, theScenGroup->myStochLocs ())
         theStochLoc->generateConstraints ();

   forEachEl (theOptVar, myOptVars ())
      theOptVar->mandStochVar ()->genStSlbConIfNeeded ();
   }

//------------------------------------------------------------------------------

void WitStochImpOP::postGenFixed ()
   {
   WitScenGroup * theScenGroup;
   WitStochLoc *  theStochLoc;

   forEachEl (theScenGroup, myScenGroups_)
      forEachEl (theStochLoc, theScenGroup->myStochLocs ())
         theStochLoc->clearStochVars ();

   delete myExecPerSched_;

   myExecPerSched_ = NULL;
   }

//------------------------------------------------------------------------------

void WitStochImpOP::postGenFlexible ()
   {
   WitScenGroup * theScenGroup;

   forEachEl (theScenGroup, myScenGroups_)
      theScenGroup->postGenFlexible ();
   }

//------------------------------------------------------------------------------

void WitStochImpOP::printOptVCHeading ()
   {
   fprintf (optProbFile (),
      "Index    Class        Item        Item        Item        Per Scn");
   }

//------------------------------------------------------------------------------

void WitStochImpOP::doScreening ()
   {
   if (myOptComp ()->printOptProblem ())
      saveBounds ();
   }

//------------------------------------------------------------------------------

void WitStochImpOP::buildScenGroups ()
   {
   WitScenario *         theScenario;
   WitList <WitScenario> theScenarioList;
   WitScenGroup *        theScenGroup;

   myScenGroupForStage0_ =
      new WitScenGroup (
         this,
         myStochModeMgr_->myStageMgr ()->myStageFor (0),
         myStochModeMgr_->myScenMgr  ()->myScenarios ());

   myScenGroups_.append (myScenGroupForStage0_);

   forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
      {
      theScenarioList.clear ();

      theScenarioList.append (theScenario);

      theScenGroup =
         new WitScenGroup (
            this,
            myStochModeMgr_->myStageMgr ()->myStageFor (1),
            theScenarioList);

      myScenGroups_.append (theScenGroup);
      }
   }

//------------------------------------------------------------------------------

bool WitStochImpOP::positiveHardLBsExist ()
   {
   WitScenInputAtt <WitBoundSet> * hardLBAtt;
   WitBoundSet *                   theBoundSet;
   WitScenario *                   theScenario;

   hardLBAtt = myStochModeMgr_->myScenAttMgr ()->hardLB ();

   forEachEl (theBoundSet, myStochModeMgr_->myScenAttMgr ()->allBoundSets ())
      forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
         if (hardLBAtt->myValueFor (theBoundSet, theScenario) != 0.0)
            return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitStochImpOP::disallowedScrapExists ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      if (not thePart->scrapAllowed ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------
// Implementation of class ScenGroup.
//------------------------------------------------------------------------------

WitScenGroup::WitScenGroup (
         WitStochImpOP *               theStochImpOP,
         WitStage *                    theStage,
         const WitList <WitScenario> & theScenarios):

      WitStochAssoc  (theStochImpOP->myStochModeMgr ()),
      myStochImpOP_  (theStochImpOP),
      myStage_       (theStage),
      myScenarios_   (),
      myStochLocVec_ (myProblem ()),
      myStochLocs_   (),
      cumDemandVol_  (myProblem (), 0.0)
   {
   WitScenario * theScenario;
   WitPeriod     thePer;
   WitStochLoc * theStochLoc;

   myScenarios_ = theScenarios;

   totalProb_   = 0.0;

   forEachEl (theScenario, myScenarios_)
      totalProb_ += theScenario->probability ();

   forEachPeriod (thePer, myProblem ())
      if (myStage_->includes (thePer))
         {
         theStochLoc = new WitStochLoc (this, thePer);

         myStochLocVec_[thePer] = theStochLoc;

         myStochLocs_.append (theStochLoc);
         }

   compCumDemandVol ();
   }

//------------------------------------------------------------------------------

WitScenGroup::~WitScenGroup ()
   {
   myStochLocs_.clear ();

   deleteContents (myStochLocVec_);
   }

//------------------------------------------------------------------------------

void WitScenGroup::postGenFlexible ()
   {
   cumDemandVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitScenGroup::print ()
   {
   if (myStage_->isStage0 ())
      fprintf (myStochImpOP_->optProbFile (),
         " All");
   else
      fprintf (myStochImpOP_->optProbFile (),
         " %3d",
         firstScenario ()->myIndex ());
   }

//------------------------------------------------------------------------------

void WitScenGroup::compCumDemandVol ()
   {
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;

   forEachDemand (theDemand, myProblem ())
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum +=
            myScenAttMgr ()->
               demandVol ()->
                  myValueFor (theDemand, firstScenario ())[thePer];

         cumDemandVol_ (theDemand)[thePer] = cumSum;
         }
      }
   }

//------------------------------------------------------------------------------
// Implementation of class StochLoc.
//------------------------------------------------------------------------------

WitStochLoc::WitStochLoc (WitScenGroup * theScenGroup, WitPeriod thePer):

      WitStochAssoc    (theScenGroup),
      myScenGroup_     (theScenGroup),
      myPer_           (thePer),
      myScrapVarFor_   (myProblem ()),
      myStockVarFor_   (myProblem ()),
      myExecVarFor_    (myProblem ()),
      myShipVarFor_    (myProblem ()),
      myCumShipVarFor_ (myProblem ()),
      myNonSubVarFor_  (myProblem ()),
      mySubVarFor_     (myProblem ())
   {                     
   }

//------------------------------------------------------------------------------

WitStochLoc::~WitStochLoc ()
   {
   }

//------------------------------------------------------------------------------

void WitStochLoc::generateVariables ()
   {
   genScrapVars   ();
   genStockVars   ();
   genShipVars    ();
   genCumShipVars ();
   genExecVars    ();
   genNonSubVars  ();
   genSubVars     ();
   }

//------------------------------------------------------------------------------

void WitStochLoc::generateConstraints ()
   {
   genResCons  ();
   genShipCons ();
   genSubCons  ();
   }

//------------------------------------------------------------------------------

void WitStochLoc::clearStochVars ()
   {
   myScrapVarFor_  .clear ();
   myStockVarFor_  .clear ();
   myExecVarFor_   .clear ();
   myShipVarFor_   .clear ();
   myCumShipVarFor_.clear ();
   myNonSubVarFor_ .clear ();
   mySubVarFor_    .clear ();
   }

//------------------------------------------------------------------------------

void WitStochLoc::print ()
   {
   fprintf (myStochImpOP ()->optProbFile (), " %3d", myPer_);

   myScenGroup_->print ();
   }

//------------------------------------------------------------------------------

WitStScrapVar * WitStochLoc::myScrapVarFor (WitPart * thePart)
   {
   return myScrapVarFor_ (thePart);
   }

//------------------------------------------------------------------------------

WitStStockVar * WitStochLoc::myStockVarFor (WitMaterial * theMat)
   {
   return myStockVarFor_ (theMat);
   }

//------------------------------------------------------------------------------

WitStExecVar * WitStochLoc::myExecVarFor (WitOperation * theOpn)
   {
   return myExecVarFor_ (theOpn);
   }

//------------------------------------------------------------------------------

WitStShipVar * WitStochLoc::myShipVarFor (WitDemand * theDemand)
   {
   return myShipVarFor_ (theDemand);
   }

//------------------------------------------------------------------------------

WitStCumShipVar * WitStochLoc::myCumShipVarFor (WitDemand * theDemand)
   {
   return myCumShipVarFor_ (theDemand);
   }

//------------------------------------------------------------------------------

WitStNonSubVar * WitStochLoc::myNonSubVarFor (WitBomEntry * theBomEnt)
   {
   return myNonSubVarFor_ (theBomEnt);
   }

//------------------------------------------------------------------------------

WitStSubVar * WitStochLoc::mySubVarFor (WitSubEntry * theSub)
   {
   return mySubVarFor_ (theSub);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genScrapVars ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      if (myStage ()->includes (thePart))
         if (thePart->scrapAllowed ())
            myScrapVarFor_ (thePart) = new WitStScrapVar (thePart, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genStockVars ()
   {
   WitMaterial * theMat;

   forEachMaterial (theMat, myProblem ())
      if (myStage ()->includes (theMat))
         myStockVarFor_ (theMat) = new WitStStockVar (theMat, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genShipVars ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      if (myStage ()->includes (theDemand->demandedPart ()))
         myShipVarFor_ (theDemand) = new WitStShipVar (theDemand, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genCumShipVars ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      if (myStage ()->includes (theDemand->demandedPart ()))
         if (theDemand->shipLateAllowed ())
            myCumShipVarFor_       (theDemand) =
               new WitStCumShipVar (theDemand, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genExecVars ()
   {
   WitOperation * theOpn;

   forEachOperation (theOpn, myProblem ())
      if (myStage ()->includes (theOpn))
         if (theOpn->executable ()[myPer_])
            myExecVarFor_ (theOpn) = new WitStExecVar (theOpn, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genNonSubVars ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      if (myStage ()->includes (theBomEnt->myOperation ()))
         if (theBomEnt->hasSubsInEffect ()[myPer_])
            myNonSubVarFor_       (theBomEnt) =
               new WitStNonSubVar (theBomEnt, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genSubVars ()
   {
   WitSubEntry * theSub;

   forEachSubEntry (theSub, myProblem ())
      if (myStage ()->includes (theSub->myOperation ()))
         if (theSub->inEffect (myPer_))
            mySubVarFor_ (theSub) = new WitStSubVar (theSub, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genResCons ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      if (myStage ()->includes (thePart))
         new WitStResCon (thePart, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genShipCons ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      if (myStage ()->includes (theDemand->demandedPart ()))
         new WitStShipCon (theDemand, this);
   }

//------------------------------------------------------------------------------

void WitStochLoc::genSubCons ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      if (myStage ()->includes (theBomEnt->myOperation ()))
         if (theBomEnt->hasSubsInEffect ()[myPer_])
            new WitStSubCon (theBomEnt, this);
   }

//------------------------------------------------------------------------------
// Implementation of class StochVar.
//------------------------------------------------------------------------------

WitStochVar::WitStochVar (WitStochLoc * theStochLoc):

      WitOptVar   (theStochLoc->myScenGroup ()->myStochImpOP ()),
      myStochLoc_ (theStochLoc)
   {
   }

//------------------------------------------------------------------------------

WitStochVar::~WitStochVar ()
   {
   }

//------------------------------------------------------------------------------

WitOptProblem * WitStochVar::myOptProblem ()
   {
   return myStochImpOP ();
   }

//------------------------------------------------------------------------------

WitStochVar * WitStochVar::mandStochVar ()
   {
   return this;
   }

//------------------------------------------------------------------------------

void WitStochVar::genStSlbvVarIfNeeded ()
   {
   }

//------------------------------------------------------------------------------

void WitStochVar::genStSlbConIfNeeded ()
   {
   }

//------------------------------------------------------------------------------

double WitStochVar::stBoundsCoeffVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

bool WitStochVar::isStSlbvVar ()
   {
   return false;
   }

//------------------------------------------------------------------------------

void WitStochVar::printSource ()
   {
   printItem ();

   myStochLoc_->print ();
   }

//------------------------------------------------------------------------------
// Implementation of class StochCon.
//------------------------------------------------------------------------------

WitStochCon::WitStochCon (WitStochLoc * theStochLoc):

      WitOptCon   (theStochLoc->myScenGroup ()->myStochImpOP ()),
      myStochLoc_ (theStochLoc)
   {
   }

//------------------------------------------------------------------------------

WitStochCon::~WitStochCon ()
   {
   }

//------------------------------------------------------------------------------

WitOptProblem * WitStochCon::myOptProblem ()
   {
   return myStochImpOP ();
   }

//------------------------------------------------------------------------------

WitStochLoc * WitStochCon::findVarStochLocFor (
      WitNode * theNode,
      WitPeriod thePer)
   {
   WitStage *     theStage;
   WitScenGroup * theScenGroup;

   theStage = myStochLoc_->myStageMgr ()->myStageOf (theNode, thePer);

   if (theStage == myStochLoc_->myStage ())
      theScenGroup = myScenGroup ();
   else
      {
      stronglyAssert (theStage->isStage0 ());

      theScenGroup = myStochImpOP ()->myScenGroupForStage0 ();
      }

   return theScenGroup->myStochLocFor (thePer);
   }

//------------------------------------------------------------------------------

void WitStochCon::printSource ()
   {
   printItem ();

   myStochLoc_->print ();
   }
@


1.102
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.101
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d58 5
a62 5
WitStochAssoc  (theStochModeMgr),
myStochImpOP_  (NULL),
uploadingSoln_ (false)
{
}
d67 2
a68 2
{
}
d73 2
a74 2
{
WitTimer::enterSection ("opt-prob");
d76 1
a76 1
startStochImp ();
d78 1
a78 1
myStochImpOP_->solve ();
d80 1
a80 1
finishStochImp ();
d82 2
a83 2
WitTimer::leaveSection ("opt-prob");
}
d88 2
a89 2
{
stronglyAssert (not stochSolnMode ());
d91 1
a91 1
myMsgFac () ("stochImpMsg");
d93 5
a97 5
myOptComp    ()->requireCplex  ();
myScenAttMgr ()->downloadInput ();
myStageMgr   ()->validateData  ();
myScenMgr    ()->validateData  ();
myScenAttMgr ()->validateData  ();
d99 1
a99 1
myProblem      ()->resetSoln ();
d101 1
a101 1
myPreprocessor ()->preprocess ();
d103 1
a103 1
myOptComp      ()->optInitMethod ()->display ();
d105 1
a105 1
myMsgFac () ("genLpMipProbMsg", myMsgFac ().myFrag ("stochLpFrag"));
d107 1
a107 1
myStochImpOP_ = new WitStochImpOP (myStochModeMgr ());
d109 1
a109 1
myStochImpOP_->generateFixed ();
d111 2
a112 2
myStochImpOP_->generateFlexible ();
}
d117 2
a118 2
{
myProblem ()->optVariant ()->becomesCurrent ();
d120 1
a120 1
uploadObjValues ();
d122 1
a122 1
uploadScenSoln ();
d124 1
a124 1
delete myStochImpOP_;
d126 1
a126 1
myStochImpOP_ = NULL;
d128 1
a128 1
myStochModeMgr ()->uploadSoln ();
d130 2
a131 2
myPostprocessor ()->postprocess ();
}
d136 5
a140 5
{
double        objValue;
double        boundsValue;
WitOptVar *   theOptVar;
WitStochVar * theStochVar;
d142 1
a142 1
uploadingSoln_ = true;
d144 1
a144 1
objValue       = myStochImpOP_->compObjValue ();
d146 1
a146 1
myStochModeMgr ()->passObjValue (objValue);
d148 1
a148 1
boundsValue    = 0.0;
d150 3
a152 3
forEachEl (theOptVar, myStochImpOP_->myOptVars ())
{
theStochVar = theOptVar->mandStochVar ();
d154 7
a160 7
if (theStochVar->isStSlbvVar ())
{
boundsValue +=
theStochVar->primalValue () *
theStochVar->totalProb   ();
}
}
d162 1
a162 1
myStochModeMgr ()->passBoundsValue (boundsValue);
d164 1
a164 1
uploadingSoln_ = false;
d166 2
a167 2
myOptComp ()->writeObjValue ();
}
d172 14
a185 14
{
WitOptVar *   theOptVar;
WitStochVar * theStochVar;
WitScenario * theScenario;

uploadingSoln_ = true;

forEachEl (theOptVar, myStochImpOP_->myOptVars ())
{
theStochVar = theOptVar->mandStochVar ();

forEachEl (theScenario, theStochVar->myScenGroup ()->myScenarios ())
theStochVar->uploadSolnTo (theScenario);
}
d187 2
a188 2
uploadingSoln_ = false;
}
d196 7
a202 7
WitOptProblem         (theStochModeMgr->myProblem ()),
myStochModeMgr_       (theStochModeMgr),
myScenGroups_         (),
myScenGroupForStage0_ (NULL),
myExecPerSched_       (NULL)
{
buildScenGroups ();
d204 2
a205 2
myExecPerSched_ = new WitExecPerSched <WitBillEntry> (myProblem ());
}
d210 2
a211 2
{
delete myExecPerSched_;
d213 1
a213 1
myScenGroupForStage0_ = NULL;
d215 3
a217 3
while (not myScenGroups_.isEmpty ())
delete myScenGroups_.get ();
}
d222 3
a224 3
{
return false;
}
d229 3
a231 3
{
return false;
}
d236 5
a240 5
{
fprintf (optProbFile (),
" %-11s                        ",
theNode->nodeName ().myCstring ());
}
d245 6
a250 6
{
fprintf (optProbFile (),
" %-11s %-11s            ",
theDemand->demandedPartName ().myCstring (),
theDemand->demandName ()      .myCstring ());
}
d255 6
a260 6
{
fprintf (optProbFile (),
" %-11s %-11d            ",
theBomEnt->myOperationName ().myCstring (),
theBomEnt->localIndex ());
}
d265 7
a271 7
{
fprintf (optProbFile (),
" %-11s %-11d %-11d",
theSub->myOperationName ().myCstring (),
theSub->myBomEntIndex (),
theSub->localIndex ());
}
d276 6
a281 6
{
fprintf (optProbFile (),
" Var #%-6d BS #%-7d            ",
theStBddVar->index (),
theStBddVar->myBoundSet ()->mappingIndex ());
}
d286 12
a297 12
{
WitScenGroup * theScenGroup;
WitStochLoc *  theStochLoc;
WitOptVar *    theOptVar;

forEachEl (theScenGroup, myScenGroups_)
forEachEl (theStochLoc, theScenGroup->myStochLocs ())
theStochLoc->generateVariables ();

forEachEl (theOptVar, myOptVars ())
theOptVar->mandStochVar ()->genStSlbvVarIfNeeded ();
}
d302 12
a313 12
{
WitScenGroup * theScenGroup;
WitStochLoc *  theStochLoc;
WitOptVar *    theOptVar;

forEachEl (theScenGroup, myScenGroups_)
forEachEl (theStochLoc, theScenGroup->myStochLocs ())
theStochLoc->generateConstraints ();

forEachEl (theOptVar, myOptVars ())
theOptVar->mandStochVar ()->genStSlbConIfNeeded ();
}
d318 7
a324 7
{
WitScenGroup * theScenGroup;
WitStochLoc *  theStochLoc;

forEachEl (theScenGroup, myScenGroups_)
forEachEl (theStochLoc, theScenGroup->myStochLocs ())
theStochLoc->clearStochVars ();
d326 1
a326 1
delete myExecPerSched_;
d328 2
a329 2
myExecPerSched_ = NULL;
}
d334 2
a335 2
{
WitScenGroup * theScenGroup;
d337 3
a339 3
forEachEl (theScenGroup, myScenGroups_)
theScenGroup->postGenFlexible ();
}
d344 4
a347 4
{
fprintf (optProbFile (),
"Index    Class        Item        Item        Item        Per Scn");
}
d352 4
a355 4
{
if (myOptComp ()->printOptProblem ())
saveBounds ();
}
d360 28
a387 28
{
WitScenario *         theScenario;
WitList <WitScenario> theScenarioList;
WitScenGroup *        theScenGroup;

myScenGroupForStage0_ =
new WitScenGroup (
this,
myStochModeMgr_->myStageMgr ()->myStageFor (0),
myStochModeMgr_->myScenMgr  ()->myScenarios ());

myScenGroups_.append (myScenGroupForStage0_);

forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
{
theScenarioList.clear ();

theScenarioList.append (theScenario);

theScenGroup =
new WitScenGroup (
this,
myStochModeMgr_->myStageMgr ()->myStageFor (1),
theScenarioList);

myScenGroups_.append (theScenGroup);
}
}
d392 11
a402 11
{
WitScenInputAtt <WitBoundSet> * hardLBAtt;
WitBoundSet *                   theBoundSet;
WitScenario *                   theScenario;

hardLBAtt = myStochModeMgr_->myScenAttMgr ()->hardLB ();

forEachEl (theBoundSet, myStochModeMgr_->myScenAttMgr ()->allBoundSets ())
forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
if (hardLBAtt->myValueFor (theBoundSet, theScenario) != 0.0)
return true;
d404 2
a405 2
return false;
}
d410 2
a411 2
{
WitPart * thePart;
d413 3
a415 3
forEachPart (thePart, myProblem ())
if (not thePart->scrapAllowed ())
return true;
d417 2
a418 2
return false;
}
d425 27
a451 27
WitStochImpOP *               theStochImpOP,
WitStage *                    theStage,
const WitList <WitScenario> & theScenarios):

WitStochAssoc  (theStochImpOP->myStochModeMgr ()),
myStochImpOP_  (theStochImpOP),
myStage_       (theStage),
myScenarios_   (),
myStochLocVec_ (myProblem ()),
myStochLocs_   (),
cumDemandVol_  (myProblem (), 0.0)
{
WitScenario * theScenario;
WitPeriod     thePer;
WitStochLoc * theStochLoc;

myScenarios_ = theScenarios;

totalProb_   = 0.0;

forEachEl (theScenario, myScenarios_)
totalProb_ += theScenario->probability ();

forEachPeriod (thePer, myProblem ())
if (myStage_->includes (thePer))
{
theStochLoc = new WitStochLoc (this, thePer);
d453 1
a453 1
myStochLocVec_[thePer] = theStochLoc;
d455 2
a456 2
myStochLocs_.append (theStochLoc);
}
d458 2
a459 2
compCumDemandVol ();
}
d464 2
a465 2
{
myStochLocs_.clear ();
d467 2
a468 2
deleteContents (myStochLocVec_);
}
d473 3
a475 3
{
cumDemandVol_.clear ();
}
d480 9
a488 9
{
if (myStage_->isStage0 ())
fprintf (myStochImpOP_->optProbFile (),
" All");
else
fprintf (myStochImpOP_->optProbFile (),
" %3d",
firstScenario ()->myIndex ());
}
d493 20
a512 20
{
WitDemand * theDemand;
double      cumSum;
WitPeriod   thePer;

forEachDemand (theDemand, myProblem ())
{
cumSum = 0.0;

forEachPeriod (thePer, myProblem ())
{
cumSum +=
myScenAttMgr ()->
demandVol ()->
myValueFor (theDemand, firstScenario ())[thePer];

cumDemandVol_ (theDemand)[thePer] = cumSum;
}
}
}
d520 12
a531 12
WitStochAssoc    (theScenGroup),
myScenGroup_     (theScenGroup),
myPer_           (thePer),
myScrapVarFor_   (myProblem ()),
myStockVarFor_   (myProblem ()),
myExecVarFor_    (myProblem ()),
myShipVarFor_    (myProblem ()),
myCumShipVarFor_ (myProblem ()),
myNonSubVarFor_  (myProblem ()),
mySubVarFor_     (myProblem ())
{
}
d536 2
a537 2
{
}
d542 9
a550 9
{
genScrapVars   ();
genStockVars   ();
genShipVars    ();
genCumShipVars ();
genExecVars    ();
genNonSubVars  ();
genSubVars     ();
}
d555 5
a559 5
{
genResCons  ();
genShipCons ();
genSubCons  ();
}
d564 9
a572 9
{
myScrapVarFor_  .clear ();
myStockVarFor_  .clear ();
myExecVarFor_   .clear ();
myShipVarFor_   .clear ();
myCumShipVarFor_.clear ();
myNonSubVarFor_ .clear ();
mySubVarFor_    .clear ();
}
d577 2
a578 2
{
fprintf (myStochImpOP ()->optProbFile (), " %3d", myPer_);
d580 2
a581 2
myScenGroup_->print ();
}
d586 3
a588 3
{
return myScrapVarFor_ (thePart);
}
d593 3
a595 3
{
return myStockVarFor_ (theMat);
}
d600 3
a602 3
{
return myExecVarFor_ (theOpn);
}
d607 3
a609 3
{
return myShipVarFor_ (theDemand);
}
d614 3
a616 3
{
return myCumShipVarFor_ (theDemand);
}
d621 3
a623 3
{
return myNonSubVarFor_ (theBomEnt);
}
d628 3
a630 3
{
return mySubVarFor_ (theSub);
}
d635 2
a636 2
{
WitPart * thePart;
d638 5
a642 5
forEachPart (thePart, myProblem ())
if (myStage ()->includes (thePart))
if (thePart->scrapAllowed ())
myScrapVarFor_ (thePart) = new WitStScrapVar (thePart, this);
}
d647 2
a648 2
{
WitMaterial * theMat;
d650 4
a653 4
forEachMaterial (theMat, myProblem ())
if (myStage ()->includes (theMat))
myStockVarFor_ (theMat) = new WitStStockVar (theMat, this);
}
d658 2
a659 2
{
WitDemand * theDemand;
d661 4
a664 4
forEachDemand (theDemand, myProblem ())
if (myStage ()->includes (theDemand->demandedPart ()))
myShipVarFor_ (theDemand) = new WitStShipVar (theDemand, this);
}
d669 2
a670 2
{
WitDemand * theDemand;
d672 6
a677 6
forEachDemand (theDemand, myProblem ())
if (myStage ()->includes (theDemand->demandedPart ()))
if (theDemand->shipLateAllowed ())
myCumShipVarFor_       (theDemand) =
new WitStCumShipVar (theDemand, this);
}
d682 2
a683 2
{
WitOperation * theOpn;
d685 5
a689 5
forEachOperation (theOpn, myProblem ())
if (myStage ()->includes (theOpn))
if (theOpn->executable ()[myPer_])
myExecVarFor_ (theOpn) = new WitStExecVar (theOpn, this);
}
d694 2
a695 2
{
WitBomEntry * theBomEnt;
d697 6
a702 6
forEachBomEntry (theBomEnt, myProblem ())
if (myStage ()->includes (theBomEnt->myOperation ()))
if (theBomEnt->hasSubsInEffect ()[myPer_])
myNonSubVarFor_       (theBomEnt) =
new WitStNonSubVar (theBomEnt, this);
}
d707 2
a708 2
{
WitSubEntry * theSub;
d710 5
a714 5
forEachSubEntry (theSub, myProblem ())
if (myStage ()->includes (theSub->myOperation ()))
if (theSub->inEffect (myPer_))
mySubVarFor_ (theSub) = new WitStSubVar (theSub, this);
}
d719 2
a720 2
{
WitPart * thePart;
d722 4
a725 4
forEachPart (thePart, myProblem ())
if (myStage ()->includes (thePart))
new WitStResCon (thePart, this);
}
d730 2
a731 2
{
WitDemand * theDemand;
d733 4
a736 4
forEachDemand (theDemand, myProblem ())
if (myStage ()->includes (theDemand->demandedPart ()))
new WitStShipCon (theDemand, this);
}
d741 2
a742 2
{
WitBomEntry * theBomEnt;
d744 5
a748 5
forEachBomEntry (theBomEnt, myProblem ())
if (myStage ()->includes (theBomEnt->myOperation ()))
if (theBomEnt->hasSubsInEffect ()[myPer_])
new WitStSubCon (theBomEnt, this);
}
d756 4
a759 4
WitOptVar   (theStochLoc->myScenGroup ()->myStochImpOP ()),
myStochLoc_ (theStochLoc)
{
}
d764 2
a765 2
{
}
d770 3
a772 3
{
return myStochImpOP ();
}
d777 3
a779 3
{
return this;
}
d784 2
a785 2
{
}
d790 2
a791 2
{
}
d796 3
a798 3
{
return 0.0;
}
d803 3
a805 3
{
return false;
}
d810 2
a811 2
{
printItem ();
d813 2
a814 2
myStochLoc_->print ();
}
d822 4
a825 4
WitOptCon   (theStochLoc->myScenGroup ()->myStochImpOP ()),
myStochLoc_ (theStochLoc)
{
}
d830 2
a831 2
{
}
d836 3
a838 3
{
return myStochImpOP ();
}
d843 13
a855 13
WitNode * theNode,
WitPeriod thePer)
{
WitStage *     theStage;
WitScenGroup * theScenGroup;

theStage = myStochLoc_->myStageMgr ()->myStageOf (theNode, thePer);

if (theStage == myStochLoc_->myStage ())
theScenGroup = myScenGroup ();
else
{
stronglyAssert (theStage->isStage0 ());
d857 2
a858 2
theScenGroup = myStochImpOP ()->myScenGroupForStage0 ();
}
d860 2
a861 2
return theScenGroup->myStochLocFor (thePer);
}
d866 2
a867 2
{
printItem ();
d869 2
a870 2
myStochLoc_->print ();
}
@


1.100
log
@Removed COIN from WIT.
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d58 5
a62 5
      WitStochAssoc  (theStochModeMgr),
      myStochImpOP_  (NULL),
      uploadingSoln_ (false)
   {
   }
d67 2
a68 2
   {
   }
d73 2
a74 2
   {
   WitTimer::enterSection ("opt-prob");
d76 1
a76 1
   startStochImp ();
d78 1
a78 1
   myStochImpOP_->solve ();
d80 1
a80 1
   finishStochImp ();
d82 2
a83 2
   WitTimer::leaveSection ("opt-prob");
   }
d88 2
a89 2
   {
   stronglyAssert (not stochSolnMode ());
d91 1
a91 1
   myMsgFac () ("stochImpMsg");
d93 5
a97 5
   myOptComp    ()->requireCplex  ();
   myScenAttMgr ()->downloadInput ();
   myStageMgr   ()->validateData  ();
   myScenMgr    ()->validateData  ();
   myScenAttMgr ()->validateData  ();
d99 1
a99 1
   myProblem      ()->resetSoln ();
d101 1
a101 1
   myPreprocessor ()->preprocess ();
d103 1
a103 1
   myOptComp      ()->optInitMethod ()->display ();
d105 1
a105 1
   myMsgFac () ("genLpMipProbMsg", myMsgFac ().myFrag ("stochLpFrag"));
d107 1
a107 1
   myStochImpOP_ = new WitStochImpOP (myStochModeMgr ());
d109 1
a109 1
   myStochImpOP_->generateFixed ();
d111 2
a112 2
   myStochImpOP_->generateFlexible ();
   }
d117 2
a118 2
   {
   myProblem ()->optVariant ()->becomesCurrent ();
d120 1
a120 1
   uploadObjValues ();
d122 1
a122 1
   uploadScenSoln ();
d124 1
a124 1
   delete myStochImpOP_;
d126 1
a126 1
   myStochImpOP_ = NULL;
d128 1
a128 1
   myStochModeMgr ()->uploadSoln ();
d130 2
a131 2
   myPostprocessor ()->postprocess ();
   }
d136 5
a140 5
   {
   double        objValue;
   double        boundsValue;
   WitOptVar *   theOptVar;
   WitStochVar * theStochVar;
d142 1
a142 1
   uploadingSoln_ = true;
d144 1
a144 1
   objValue       = myStochImpOP_->compObjValue ();
d146 1
a146 1
   myStochModeMgr ()->passObjValue (objValue);
d148 1
a148 1
   boundsValue    = 0.0;
d150 3
a152 3
   forEachEl (theOptVar, myStochImpOP_->myOptVars ())
      {
      theStochVar = theOptVar->mandStochVar ();
d154 7
a160 7
      if (theStochVar->isStSlbvVar ())
         {
         boundsValue +=
            theStochVar->primalValue () *
            theStochVar->totalProb   ();
         }
      }
d162 1
a162 1
   myStochModeMgr ()->passBoundsValue (boundsValue);
d164 1
a164 1
   uploadingSoln_ = false;
d166 2
a167 2
   myOptComp ()->writeObjValue ();
   }
d172 14
a185 14
   {
   WitOptVar *   theOptVar;
   WitStochVar * theStochVar;
   WitScenario * theScenario;

   uploadingSoln_ = true;

   forEachEl (theOptVar, myStochImpOP_->myOptVars ())
      {
      theStochVar = theOptVar->mandStochVar ();

      forEachEl (theScenario, theStochVar->myScenGroup ()->myScenarios ())
         theStochVar->uploadSolnTo (theScenario);
      }
d187 2
a188 2
   uploadingSoln_ = false;
   }
d196 7
a202 7
      WitOptProblem         (theStochModeMgr->myProblem ()),
      myStochModeMgr_       (theStochModeMgr),
      myScenGroups_         (),
      myScenGroupForStage0_ (NULL),
      myExecPerSched_       (NULL)
   {
   buildScenGroups ();
d204 2
a205 2
   myExecPerSched_ = new WitExecPerSched <WitBillEntry> (myProblem ());
   }
d210 2
a211 2
   {
   delete myExecPerSched_;
d213 1
a213 1
   myScenGroupForStage0_ = NULL;
d215 3
a217 3
   while (not myScenGroups_.isEmpty ())
      delete myScenGroups_.get ();
   }
d222 3
a224 3
   {
   return false;
   }
d229 3
a231 3
   {
   return false;
   }
d236 5
a240 5
   {
   fprintf (optProbFile (),
      " %-11s                        ",
      theNode->nodeName ().myCstring ());
   }
d245 6
a250 6
   {
   fprintf (optProbFile (),
      " %-11s %-11s            ", 
      theDemand->demandedPartName ().myCstring (),
      theDemand->demandName ()      .myCstring ());
   }
d255 6
a260 6
   {
   fprintf (optProbFile (),
      " %-11s %-11d            ", 
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex ());
   }
d265 7
a271 7
   {
   fprintf (optProbFile (),
      " %-11s %-11d %-11d", 
      theSub->myOperationName ().myCstring (),
      theSub->myBomEntIndex (),
      theSub->localIndex ());
   }
d276 6
a281 6
   {
   fprintf (optProbFile (),
      " Var #%-6d BS #%-7d            ",
      theStBddVar->index (),
      theStBddVar->myBoundSet ()->mappingIndex ());
   }
d286 12
a297 12
   {
   WitScenGroup * theScenGroup;
   WitStochLoc *  theStochLoc;
   WitOptVar *    theOptVar;

   forEachEl (theScenGroup, myScenGroups_)
      forEachEl (theStochLoc, theScenGroup->myStochLocs ())
         theStochLoc->generateVariables ();

   forEachEl (theOptVar, myOptVars ())
      theOptVar->mandStochVar ()->genStSlbvVarIfNeeded ();
   }
d302 12
a313 12
   {
   WitScenGroup * theScenGroup;
   WitStochLoc *  theStochLoc;
   WitOptVar *    theOptVar;

   forEachEl (theScenGroup, myScenGroups_)
      forEachEl (theStochLoc, theScenGroup->myStochLocs ())
         theStochLoc->generateConstraints ();

   forEachEl (theOptVar, myOptVars ())
      theOptVar->mandStochVar ()->genStSlbConIfNeeded ();
   }
d318 7
a324 7
   {
   WitScenGroup * theScenGroup;
   WitStochLoc *  theStochLoc;

   forEachEl (theScenGroup, myScenGroups_)
      forEachEl (theStochLoc, theScenGroup->myStochLocs ())
         theStochLoc->clearStochVars ();
d326 1
a326 1
   delete myExecPerSched_;
d328 2
a329 2
   myExecPerSched_ = NULL;
   }
d334 2
a335 2
   {
   WitScenGroup * theScenGroup;
d337 3
a339 3
   forEachEl (theScenGroup, myScenGroups_)
      theScenGroup->postGenFlexible ();
   }
d344 4
a347 4
   {
   fprintf (optProbFile (),
      "Index    Class        Item        Item        Item        Per Scn");
   }
d352 4
a355 4
   {
   if (myOptComp ()->printOptProblem ())
      saveBounds ();
   }
d360 28
a387 28
   {
   WitScenario *         theScenario;
   WitList <WitScenario> theScenarioList;
   WitScenGroup *        theScenGroup;

   myScenGroupForStage0_ =
      new WitScenGroup (
         this,
         myStochModeMgr_->myStageMgr ()->myStageFor (0),
         myStochModeMgr_->myScenMgr  ()->myScenarios ());

   myScenGroups_.append (myScenGroupForStage0_);

   forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
      {
      theScenarioList.clear ();

      theScenarioList.append (theScenario);

      theScenGroup =
         new WitScenGroup (
            this,
            myStochModeMgr_->myStageMgr ()->myStageFor (1),
            theScenarioList);

      myScenGroups_.append (theScenGroup);
      }
   }
d392 11
a402 11
   {
   WitScenInputAtt <WitBoundSet> * hardLBAtt;
   WitBoundSet *                   theBoundSet;
   WitScenario *                   theScenario;

   hardLBAtt = myStochModeMgr_->myScenAttMgr ()->hardLB ();

   forEachEl (theBoundSet, myStochModeMgr_->myScenAttMgr ()->allBoundSets ())
      forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
         if (hardLBAtt->myValueFor (theBoundSet, theScenario) != 0.0)
            return true;
d404 2
a405 2
   return false;
   }
d410 2
a411 2
   {
   WitPart * thePart;
d413 3
a415 3
   forEachPart (thePart, myProblem ())
      if (not thePart->scrapAllowed ())
         return true;
d417 2
a418 2
   return false;
   }
d425 27
a451 27
         WitStochImpOP *               theStochImpOP,
         WitStage *                    theStage,
         const WitList <WitScenario> & theScenarios):

      WitStochAssoc  (theStochImpOP->myStochModeMgr ()),
      myStochImpOP_  (theStochImpOP),
      myStage_       (theStage),
      myScenarios_   (),
      myStochLocVec_ (myProblem ()),
      myStochLocs_   (),
      cumDemandVol_  (myProblem (), 0.0)
   {
   WitScenario * theScenario;
   WitPeriod     thePer;
   WitStochLoc * theStochLoc;

   myScenarios_ = theScenarios;

   totalProb_   = 0.0;

   forEachEl (theScenario, myScenarios_)
      totalProb_ += theScenario->probability ();

   forEachPeriod (thePer, myProblem ())
      if (myStage_->includes (thePer))
         {
         theStochLoc = new WitStochLoc (this, thePer);
d453 1
a453 1
         myStochLocVec_[thePer] = theStochLoc;
d455 2
a456 2
         myStochLocs_.append (theStochLoc);
         }
d458 2
a459 2
   compCumDemandVol ();
   }
d464 2
a465 2
   {
   myStochLocs_.clear ();
d467 2
a468 2
   deleteContents (myStochLocVec_);
   }
d473 3
a475 3
   {
   cumDemandVol_.clear ();
   }
d480 9
a488 9
   {
   if (myStage_->isStage0 ())
      fprintf (myStochImpOP_->optProbFile (),
         " All");
   else
      fprintf (myStochImpOP_->optProbFile (),
         " %3d",
         firstScenario ()->myIndex ());
   }
d493 20
a512 20
   {
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;

   forEachDemand (theDemand, myProblem ())
      {
      cumSum = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumSum +=
            myScenAttMgr ()->
               demandVol ()->
                  myValueFor (theDemand, firstScenario ())[thePer];

         cumDemandVol_ (theDemand)[thePer] = cumSum;
         }
      }
   }
d520 12
a531 12
      WitStochAssoc    (theScenGroup),
      myScenGroup_     (theScenGroup),
      myPer_           (thePer),
      myScrapVarFor_   (myProblem ()),
      myStockVarFor_   (myProblem ()),
      myExecVarFor_    (myProblem ()),
      myShipVarFor_    (myProblem ()),
      myCumShipVarFor_ (myProblem ()),
      myNonSubVarFor_  (myProblem ()),
      mySubVarFor_     (myProblem ())
   {                     
   }
d536 2
a537 2
   {
   }
d542 9
a550 9
   {
   genScrapVars   ();
   genStockVars   ();
   genShipVars    ();
   genCumShipVars ();
   genExecVars    ();
   genNonSubVars  ();
   genSubVars     ();
   }
d555 5
a559 5
   {
   genResCons  ();
   genShipCons ();
   genSubCons  ();
   }
d564 9
a572 9
   {
   myScrapVarFor_  .clear ();
   myStockVarFor_  .clear ();
   myExecVarFor_   .clear ();
   myShipVarFor_   .clear ();
   myCumShipVarFor_.clear ();
   myNonSubVarFor_ .clear ();
   mySubVarFor_    .clear ();
   }
d577 2
a578 2
   {
   fprintf (myStochImpOP ()->optProbFile (), " %3d", myPer_);
d580 2
a581 2
   myScenGroup_->print ();
   }
d586 3
a588 3
   {
   return myScrapVarFor_ (thePart);
   }
d593 3
a595 3
   {
   return myStockVarFor_ (theMat);
   }
d600 3
a602 3
   {
   return myExecVarFor_ (theOpn);
   }
d607 3
a609 3
   {
   return myShipVarFor_ (theDemand);
   }
d614 3
a616 3
   {
   return myCumShipVarFor_ (theDemand);
   }
d621 3
a623 3
   {
   return myNonSubVarFor_ (theBomEnt);
   }
d628 3
a630 3
   {
   return mySubVarFor_ (theSub);
   }
d635 2
a636 2
   {
   WitPart * thePart;
d638 5
a642 5
   forEachPart (thePart, myProblem ())
      if (myStage ()->includes (thePart))
         if (thePart->scrapAllowed ())
            myScrapVarFor_ (thePart) = new WitStScrapVar (thePart, this);
   }
d647 2
a648 2
   {
   WitMaterial * theMat;
d650 4
a653 4
   forEachMaterial (theMat, myProblem ())
      if (myStage ()->includes (theMat))
         myStockVarFor_ (theMat) = new WitStStockVar (theMat, this);
   }
d658 2
a659 2
   {
   WitDemand * theDemand;
d661 4
a664 4
   forEachDemand (theDemand, myProblem ())
      if (myStage ()->includes (theDemand->demandedPart ()))
         myShipVarFor_ (theDemand) = new WitStShipVar (theDemand, this);
   }
d669 2
a670 2
   {
   WitDemand * theDemand;
d672 6
a677 6
   forEachDemand (theDemand, myProblem ())
      if (myStage ()->includes (theDemand->demandedPart ()))
         if (theDemand->shipLateAllowed ())
            myCumShipVarFor_       (theDemand) =
               new WitStCumShipVar (theDemand, this);
   }
d682 2
a683 2
   {
   WitOperation * theOpn;
d685 5
a689 5
   forEachOperation (theOpn, myProblem ())
      if (myStage ()->includes (theOpn))
         if (theOpn->executable ()[myPer_])
            myExecVarFor_ (theOpn) = new WitStExecVar (theOpn, this);
   }
d694 2
a695 2
   {
   WitBomEntry * theBomEnt;
d697 6
a702 6
   forEachBomEntry (theBomEnt, myProblem ())
      if (myStage ()->includes (theBomEnt->myOperation ()))
         if (theBomEnt->hasSubsInEffect ()[myPer_])
            myNonSubVarFor_       (theBomEnt) =
               new WitStNonSubVar (theBomEnt, this);
   }
d707 2
a708 2
   {
   WitSubEntry * theSub;
d710 5
a714 5
   forEachSubEntry (theSub, myProblem ())
      if (myStage ()->includes (theSub->myOperation ()))
         if (theSub->inEffect (myPer_))
            mySubVarFor_ (theSub) = new WitStSubVar (theSub, this);
   }
d719 2
a720 2
   {
   WitPart * thePart;
d722 4
a725 4
   forEachPart (thePart, myProblem ())
      if (myStage ()->includes (thePart))
         new WitStResCon (thePart, this);
   }
d730 2
a731 2
   {
   WitDemand * theDemand;
d733 4
a736 4
   forEachDemand (theDemand, myProblem ())
      if (myStage ()->includes (theDemand->demandedPart ()))
         new WitStShipCon (theDemand, this);
   }
d741 2
a742 2
   {
   WitBomEntry * theBomEnt;
d744 5
a748 5
   forEachBomEntry (theBomEnt, myProblem ())
      if (myStage ()->includes (theBomEnt->myOperation ()))
         if (theBomEnt->hasSubsInEffect ()[myPer_])
            new WitStSubCon (theBomEnt, this);
   }
d756 4
a759 4
      WitOptVar   (theStochLoc->myScenGroup ()->myStochImpOP ()),
      myStochLoc_ (theStochLoc)
   {
   }
d764 2
a765 2
   {
   }
d770 3
a772 3
   {
   return myStochImpOP ();
   }
d777 3
a779 3
   {
   return this;
   }
d784 2
a785 2
   {
   }
d790 2
a791 2
   {
   }
d796 3
a798 3
   {
   return 0.0;
   }
d803 3
a805 3
   {
   return false;
   }
d810 2
a811 2
   {
   printItem ();
d813 2
a814 2
   myStochLoc_->print ();
   }
d822 4
a825 4
      WitOptCon   (theStochLoc->myScenGroup ()->myStochImpOP ()),
      myStochLoc_ (theStochLoc)
   {
   }
d830 2
a831 2
   {
   }
d836 3
a838 3
   {
   return myStochImpOP ();
   }
d843 13
a855 13
      WitNode * theNode,
      WitPeriod thePer)
   {
   WitStage *     theStage;
   WitScenGroup * theScenGroup;

   theStage = myStochLoc_->myStageMgr ()->myStageOf (theNode, thePer);

   if (theStage == myStochLoc_->myStage ())
      theScenGroup = myScenGroup ();
   else
      {
      stronglyAssert (theStage->isStage0 ());
d857 2
a858 2
      theScenGroup = myStochImpOP ()->myScenGroupForStage0 ();
      }
d860 2
a861 2
   return theScenGroup->myStochLocFor (thePer);
   }
d866 2
a867 2
   {
   printItem ();
d869 2
a870 2
   myStochLoc_->print ();
   }
@


1.99
log
@Added severe error for selecting a solver that's not embedded.
@
text
@d93 1
a93 1
   myOptComp    ()->requireSolver ();
@


1.98
log
@CPLEX
@
text
@d93 5
a97 5
   myOptComp    ()->validateSolver ();
   myScenAttMgr ()->downloadInput  ();
   myStageMgr   ()->validateData   ();
   myScenMgr    ()->validateData   ();
   myScenAttMgr ()->validateData   ();
@


1.97
log
@CPLEX
@
text
@d228 7
@


1.96
log
@CPLEX
@
text
@a88 6
   if    (not myOptComp ()->coinSelected  ())
      if (not myOptComp ()->cplexSelected ())
         {
         myMsgFac () ("stochImpWoSolverSmsg");
         }

d93 5
a97 4
   myScenAttMgr ()->downloadInput ();
   myStageMgr   ()->validateData  ();
   myScenMgr    ()->validateData  ();
   myScenAttMgr ()->validateData  ();
@


1.95
log
@Heuristic Adjustment
@
text
@d89 5
a93 1
   stronglyAssert (solverEmbedded ());
@


1.94
log
@CPLEX
@
text
@d41 1
a41 1
#include <Opn.h>
@


1.93
log
@CPLEX
@
text
@a228 28
void WitStochImpOP::reportInfeasible ()
   {
   if (positiveHardLBsExist () or disallowedScrapExists ())
      myMsgFac () ("infeasSmsg");
   }

//------------------------------------------------------------------------------

void WitStochImpOP::reportUnbounded ()
   {
   if (myCompMgr ()->myOptComp ()->negativeCostsExist ())
      myMsgFac () ("unboundedSmsg");
   }

//------------------------------------------------------------------------------

void WitStochImpOP::reportInfOrUnbdd ()
   {
   if (  positiveHardLBsExist                           () or
         disallowedScrapExists                          () or
         myCompMgr ()->myOptComp ()->negativeCostsExist ())
      {
      myMsgFac () ("infeasOrUnboundedSmsg");
      }
   }

//------------------------------------------------------------------------------

@


1.92
log
@CPLEX
@
text
@d245 12
@


1.91
log
@CPLEX
@
text
@d16 1
a16 1
//    StochImpOM
d33 1
a33 1
#include <StochImpOM.h>
d59 1
a59 1
      myStochImpOM_  (NULL),
d78 1
a78 1
   myStochImpOM_->solve ();
d108 1
a108 1
   myStochImpOM_ = new WitStochImpOM (myStochModeMgr ());
d110 1
a110 1
   myStochImpOM_->generateFixed ();
d112 1
a112 1
   myStochImpOM_->generateFlexible ();
d125 1
a125 1
   delete myStochImpOM_;
d127 1
a127 1
   myStochImpOM_ = NULL;
d145 1
a145 1
   objValue       = myStochImpOM_->compObjValue ();
d151 1
a151 1
   forEachEl (theOptVar, myStochImpOM_->myOptVars ())
d180 1
a180 1
   forEachEl (theOptVar, myStochImpOM_->myOptVars ())
d192 1
a192 1
// Implementation of class StochImpOM.
d195 1
a195 1
WitStochImpOM::WitStochImpOM (WitStochModeMgr * theStochModeMgr):
d197 1
a197 1
      WitOptModel           (theStochModeMgr->myProblem ()),
d210 1
a210 1
WitStochImpOM::~WitStochImpOM ()
d222 1
a222 1
bool WitStochImpOM::needDual ()
d229 1
a229 1
void WitStochImpOM::reportInfeasible ()
d237 1
a237 1
void WitStochImpOM::reportUnbounded ()
d245 1
a245 1
void WitStochImpOM::printItem (WitNode * theNode)
d247 1
a247 1
   fprintf (modelFile (),
d254 1
a254 1
void WitStochImpOM::printItem (WitDemand * theDemand)
d256 1
a256 1
   fprintf (modelFile (),
d264 1
a264 1
void WitStochImpOM::printItem (WitBomEntry * theBomEnt)
d266 1
a266 1
   fprintf (modelFile (),
d274 1
a274 1
void WitStochImpOM::printItem (WitSubEntry * theSub)
d276 1
a276 1
   fprintf (modelFile (),
d285 1
a285 1
void WitStochImpOM::printItem (WitStBddVar * theStBddVar)
d287 1
a287 1
   fprintf (modelFile (),
d295 1
a295 1
void WitStochImpOM::generateVariables ()
d311 1
a311 1
void WitStochImpOM::generateConstraints ()
d327 1
a327 1
void WitStochImpOM::postGenFixed ()
d343 1
a343 1
void WitStochImpOM::postGenFlexible ()
d353 1
a353 1
void WitStochImpOM::printOptVCHeading ()
d355 1
a355 1
   fprintf (modelFile (),
d361 1
a361 1
void WitStochImpOM::doScreening ()
d363 1
a363 1
   if (myOptComp ()->printOptModel ())
d369 1
a369 1
void WitStochImpOM::buildScenGroups ()
d401 1
a401 1
bool WitStochImpOM::positiveHardLBsExist ()
d419 1
a419 1
bool WitStochImpOM::disallowedScrapExists ()
d435 1
a435 1
         WitStochImpOM *               theStochImpOM,
d439 2
a440 2
      WitStochAssoc  (theStochImpOM->myStochModeMgr ()),
      myStochImpOM_  (theStochImpOM),
d492 1
a492 1
      fprintf (myStochImpOM_->modelFile (),
d495 1
a495 1
      fprintf (myStochImpOM_->modelFile (),
d588 1
a588 1
   fprintf (myStochImpOM ()->modelFile (), " %3d", myPer_);
d766 1
a766 1
      WitOptVar   (theStochLoc->myScenGroup ()->myStochImpOM ()),
d779 1
a779 1
WitOptModel * WitStochVar::myOptModel ()
d781 1
a781 1
   return myStochImpOM ();
d832 1
a832 1
      WitOptCon   (theStochLoc->myScenGroup ()->myStochImpOM ()),
d845 1
a845 1
WitOptModel * WitStochCon::myOptModel ()
d847 1
a847 1
   return myStochImpOM ();
d867 1
a867 1
      theScenGroup = myStochImpOM ()->myScenGroupForStage0 ();
@


1.90
log
@Preparing for embedded CPLEX.
@
text
@d89 1
a89 1
   stronglyAssert (WitOptComp::solverEmbedded ());
@


1.89
log
@Revising the build procedure.
@
text
@d89 1
a89 1
   stronglyAssert (SOLVER_EMBEDDED);
@


1.88
log
@Revising the build procedure.
@
text
@d89 1
a89 1
   stronglyAssert (COIN_EMBEDDED);
@


1.87
log
@Revising the build process.
@
text
@d89 1
a89 1
   stronglyAssert (WIT_EMBEDS_COIN);
@


1.86
log
@Removed OptObj classes.
@
text
@d89 1
a89 1
   stronglyAssert (WitOptComp::optImpAllowed ());
@


1.85
log
@Removed class StBoundsObj.
@
text
@a18 1
//    StochObj
a24 1
#include <StObjs.h>
d138 2
a139 2
   double        objValueVal;
   double        boundsValueVal;
d145 1
a145 2
   objValueVal    = myStochImpOM_->myStochObj    ()->myValue ();
   myStochModeMgr ()->passObjValue    (objValueVal);
d147 3
a149 1
   boundsValueVal = 0.0;
d157 1
a157 1
         boundsValueVal +=
d163 1
a163 1
   myStochModeMgr ()->passBoundsValue (boundsValueVal);
d201 1
a201 2
      myExecPerSched_       (NULL),
      myStochObj_           (NULL)
a326 9
WitOptObj * WitStochImpOM::generateObjectives ()
   {
   myStochObj_ = new WitStochObj (this);

   return myStochObj_;
   }

//------------------------------------------------------------------------------

a760 22
// Implementation of class StochObj.
//------------------------------------------------------------------------------

WitStochObj::WitStochObj (WitStochImpOM * theStochImpOM):
      WitOptObj ("Stochastic Objective", theStochImpOM)
   {
   }

//------------------------------------------------------------------------------

WitStochObj::~WitStochObj ()
   {
   }

//------------------------------------------------------------------------------

double WitStochObj::coeffVal (WitOptVar * theVar)
   {
   return theVar->mandStochVar ()->stochCoeffVal ();
   }

//------------------------------------------------------------------------------
@


1.84
log
@Multi-objective mode
@
text
@a19 1
//    StBoundsObj
d140 4
a143 2
   double objValueVal;
   double boundsValueVal;
d148 15
a162 1
   boundsValueVal = myStochImpOM_->myStBoundsObj ()->myValue ();
a163 1
   myStochModeMgr ()->passObjValue    (objValueVal);
d203 1
a203 2
      myStochObj_           (NULL),
      myStBoundsObj_        (NULL)
d331 1
a331 2
   myStochObj_    = new WitStochObj    (this);
   myStBoundsObj_ = new WitStBoundsObj (this);
a793 22
// Implementation of class StBoundsObj.
//------------------------------------------------------------------------------

WitStBoundsObj::WitStBoundsObj (WitStochImpOM * theStochImpOM):
      WitOptObj ("Stochastic Bounds Objective", theStochImpOM)
   {
   }

//------------------------------------------------------------------------------

WitStBoundsObj::~WitStBoundsObj ()
   {
   }

//------------------------------------------------------------------------------

double WitStBoundsObj::coeffVal (WitOptVar * theVar)
   {
   return theVar->mandStochVar ()->stBoundsCoeffVal ();
   }

//------------------------------------------------------------------------------
d845 7
@


1.83
log
@Removing objective #2.
@
text
@d154 1
a154 1
   myMsgFac () ("objValueMsg", myOptComp ()->objValue ());
@


1.82
log
@Removing objective #2.
@
text
@d154 1
a154 1
   myMsgFac () ("obj1ValueMsg", myOptComp ()->objValue ());
@


1.81
log
@Removing objective #2.
@
text
@d141 2
a142 3
   WitObjFunc * theObjFunc;
   double       objValueVal;
   double       boundsValueVal;
@


1.80
log
@Stochastic Implosion
@
text
@a144 3
   forEachEl (theObjFunc, myOptComp ()->allObjFuncs ())
      theObjFunc->initValues ();

d229 1
a229 1
   if (myCompMgr ()->myOptComp ()->objChoice ()->negativeObj1CostsExist ())
@


1.79
log
@Stochastic Implosion
@
text
@d240 1
a240 1
   fprintf (optProbFile (),
d249 1
a249 1
   fprintf (optProbFile (),
d259 1
a259 1
   fprintf (optProbFile (),
d269 1
a269 1
   fprintf (optProbFile (),
d280 1
a280 1
   fprintf (optProbFile (),
d358 1
a358 1
   fprintf (optProbFile (),
d495 1
a495 1
      fprintf (myStochImpOM_->optProbFile (),
d498 1
a498 1
      fprintf (myStochImpOM_->optProbFile (),
d591 1
a591 1
   fprintf (myStochImpOM ()->optProbFile (), " %3d", myPer_);
@


1.78
log
@Stochastic Implosion
@
text
@d16 1
a16 1
//    StochImpOP.
d19 2
a20 2
//    StochObj.
//    StBoundsObj.
d36 1
a36 1
#include <StochImpOP.h>
d62 1
a62 1
      myStochImpOP_  (NULL),
d81 1
a81 1
   myStochImpOP_->solve ();
d111 1
a111 1
   myStochImpOP_ = new WitStochImpOP (myStochModeMgr ());
d113 1
a113 1
   myStochImpOP_->generateFixed ();
d115 1
a115 1
   myStochImpOP_->generateFlexible ();
d128 1
a128 1
   delete myStochImpOP_;
d130 1
a130 1
   myStochImpOP_ = NULL;
d150 2
a151 2
   objValueVal    = myStochImpOP_->myStochObj    ()->myValue ();
   boundsValueVal = myStochImpOP_->myStBoundsObj ()->myValue ();
d171 1
a171 1
   forEachEl (theOptVar, myStochImpOP_->myOptVars ())
d183 1
a183 1
// Implementation of class StochImpOP.
d186 1
a186 1
WitStochImpOP::WitStochImpOP (WitStochModeMgr * theStochModeMgr):
d203 1
a203 1
WitStochImpOP::~WitStochImpOP ()
d215 1
a215 1
bool WitStochImpOP::needDual ()
d222 1
a222 1
void WitStochImpOP::reportInfeasible ()
d230 1
a230 1
void WitStochImpOP::reportUnbounded ()
d238 1
a238 1
void WitStochImpOP::printItem (WitNode * theNode)
d247 1
a247 1
void WitStochImpOP::printItem (WitDemand * theDemand)
d257 1
a257 1
void WitStochImpOP::printItem (WitBomEntry * theBomEnt)
d267 1
a267 1
void WitStochImpOP::printItem (WitSubEntry * theSub)
d278 1
a278 1
void WitStochImpOP::printItem (WitStBddVar * theStBddVar)
d288 1
a288 1
void WitStochImpOP::generateVariables ()
d304 1
a304 1
void WitStochImpOP::generateConstraints ()
d320 1
a320 1
WitOptObj * WitStochImpOP::generateObjectives ()
d330 1
a330 1
void WitStochImpOP::postGenFixed ()
d346 1
a346 1
void WitStochImpOP::postGenFlexible ()
d356 1
a356 1
void WitStochImpOP::printOptVCHeading ()
d364 1
a364 1
void WitStochImpOP::doScreening ()
d372 1
a372 1
void WitStochImpOP::buildScenGroups ()
d404 1
a404 1
bool WitStochImpOP::positiveHardLBsExist ()
d422 1
a422 1
bool WitStochImpOP::disallowedScrapExists ()
d438 1
a438 1
         WitStochImpOP *               theStochImpOP,
d442 2
a443 2
      WitStochAssoc  (theStochImpOP->myStochModeMgr ()),
      myStochImpOP_  (theStochImpOP),
d495 1
a495 1
      fprintf (myStochImpOP_->optProbFile (),
d498 1
a498 1
      fprintf (myStochImpOP_->optProbFile (),
d591 1
a591 1
   fprintf (myStochImpOP ()->optProbFile (), " %3d", myPer_);
d767 2
a768 2
WitStochObj::WitStochObj (WitStochImpOP * theStochImpOP):
      WitOptObj ("Stochastic Objective", theStochImpOP)
d789 2
a790 2
WitStBoundsObj::WitStBoundsObj (WitStochImpOP * theStochImpOP):
      WitOptObj ("Stochastic Bounds Objective", theStochImpOP)
d813 1
a813 1
      WitOptVar   (theStochLoc->myScenGroup ()->myStochImpOP ()),
d828 1
a828 1
   return myStochImpOP ();
d872 1
a872 1
      WitOptCon   (theStochLoc->myScenGroup ()->myStochImpOP ()),
d887 1
a887 1
   return myStochImpOP ();
d907 1
a907 1
      theScenGroup = myStochImpOP ()->myScenGroupForStage0 ();
@


1.77
log
@Stochastic Implosion
@
text
@d188 1
a188 1
      WitOptProb            (theStochModeMgr->myProblem ()),
d366 1
a366 1
   if (myOptComp ()->printOptProb ())
d826 1
a826 1
WitOptProb * WitStochVar::myOptProb ()
d885 1
a885 1
WitOptProb * WitStochCon::myOptProb ()
@


1.76
log
@Stochastic Implosion
@
text
@d356 1
a356 1
void WitStochImpOP::printOptProbElHeading ()
@


1.75
log
@Stochastic Implosion
@
text
@a445 1
      firstScenario_ (theScenarios.first ()),
d500 1
a500 1
         firstScenario_->myIndex ());
d520 1
a520 1
                  myValueFor (theDemand, firstScenario_)[thePer];
@


1.74
log
@Stochastic Implosion
@
text
@d196 1
a196 13
   WitScenario *  theScenario;
   WitScenGroup * theScenGroup;

   myScenGroupForStage0_ = new WitScenGroup (this);

   myScenGroups_.append (myScenGroupForStage0_);

   forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
      {
      theScenGroup = new WitScenGroup (this, theScenario);

      myScenGroups_.append (theScenGroup);
      }
d372 32
d437 4
a440 1
WitScenGroup::WitScenGroup (WitStochImpOP * theStochImpOP):
d444 1
a444 1
      myStage_       (myStageMgr ()->myStageFor (0)),
d446 1
a446 1
      firstScenario_ (NULL),
d451 3
a453 1
   myScenarios_ = myScenMgr ()->myScenarios ();
d455 6
a460 2
   setUp ();
   }
d462 4
a465 1
//------------------------------------------------------------------------------
d467 1
a467 3
WitScenGroup::WitScenGroup (
         WitStochImpOP * theStochImpOP,
         WitScenario *   theScenario):
d469 2
a470 10
      WitStochAssoc  (theStochImpOP->myStochModeMgr ()),
      myStochImpOP_  (theStochImpOP),
      myStage_       (myStageMgr ()->myStageFor (1)),
      myScenarios_   (),
      firstScenario_ (NULL),
      myStochLocVec_ (myProblem ()),
      myStochLocs_   (),
      cumDemandVol_  (myProblem (), 0.0)
   {
   myScenarios_.append (theScenario);
d472 1
a472 1
   setUp ();
a505 28
void WitScenGroup::setUp ()
   {
   WitScenario * theScenario;
   WitPeriod     thePer;
   WitStochLoc * theStochLoc;

   firstScenario_ = myScenarios_.first ();

   totalProb_     = 0.0;

   forEachEl (theScenario, myScenarios_)
      totalProb_ += theScenario->probability ();

   forEachPeriod (thePer, myProblem ())
      if (myStage_->includes (thePer))
         {
         theStochLoc = new WitStochLoc (this, thePer);

         myStochLocVec_[thePer] = theStochLoc;

         myStochLocs_.append (theStochLoc);
         }

   compCumDemandVol ();
   }

//------------------------------------------------------------------------------

@


1.73
log
@Stochastic Implosion
@
text
@a114 3
   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

@


1.72
log
@Stochastic Implosion
@
text
@d543 10
a552 10
      WitStochAssoc      (theScenGroup),
      myScenGroup_       (theScenGroup),
      myPer_             (thePer),
      myStScrapVarFor_   (myProblem ()),
      myStStockVarFor_   (myProblem ()),
      myStExecVarFor_    (myProblem ()),
      myStShipVarFor_    (myProblem ()),
      myStCumShipVarFor_ (myProblem ()),
      myStNonSubVarFor_  (myProblem ()),
      myStSubVarFor_     (myProblem ())
d566 7
a572 5
   genPartVars   ();
   genDemandVars ();
   genOpnVars    ();
   genBomEntVars ();
   genSubVars    ();
d579 3
a581 3
   genPartCons   ();
   genDemandCons ();
   genBomEntCons ();
d588 7
a594 7
   myStScrapVarFor_  .clear ();
   myStStockVarFor_  .clear ();
   myStExecVarFor_   .clear ();
   myStShipVarFor_   .clear ();
   myStCumShipVarFor_.clear ();
   myStNonSubVarFor_ .clear ();
   myStSubVarFor_    .clear ();
d608 1
a608 1
WitStScrapVar * WitStochLoc::myStScrapVarFor (WitPart * thePart)
d610 1
a610 1
   return myStScrapVarFor_ (thePart);
d615 1
a615 1
WitStStockVar * WitStochLoc::myStStockVarFor (WitMaterial * theMat)
d617 1
a617 1
   return myStStockVarFor_ (theMat);
d622 1
a622 1
WitStExecVar * WitStochLoc::myStExecVarFor (WitOperation * theOpn)
d624 1
a624 1
   return myStExecVarFor_ (theOpn);
d629 1
a629 1
WitStShipVar * WitStochLoc::myStShipVarFor (WitDemand * theDemand)
d631 1
a631 1
   return myStShipVarFor_ (theDemand);
d636 1
a636 1
WitStCumShipVar * WitStochLoc::myStCumShipVarFor (WitDemand * theDemand)
d638 1
a638 1
   return myStCumShipVarFor_ (theDemand);
d643 1
a643 1
WitStNonSubVar * WitStochLoc::myStNonSubVarFor (WitBomEntry * theBomEnt)
d645 1
a645 1
   return myStNonSubVarFor_ (theBomEnt);
d650 1
a650 1
WitStSubVar * WitStochLoc::myStSubVarFor (WitSubEntry * theSub)
d652 1
a652 1
   return myStSubVarFor_ (theSub);
d657 1
a657 1
void WitStochLoc::genPartVars ()
d659 1
a659 2
   WitPart *     thePart;
   WitMaterial * theMat;
a662 1
         {
d664 4
a667 1
            myStScrapVarFor_ (thePart) = new WitStScrapVar (thePart, this);
d669 3
a671 3
         if (thePart->canStock (myPer_))
            {
            theMat = thePart->thisMat ();
d673 3
a675 3
            myStStockVarFor_ (theMat) = new WitStStockVar (theMat, this);
            }
         }
d680 1
a680 1
void WitStochLoc::genDemandVars ()
d686 2
a687 2
         {
         myStShipVarFor_ (theDemand) = new WitStShipVar (theDemand, this);
d689 8
d698 1
a698 1
            myStCumShipVarFor_     (theDemand) =
a699 1
         }
d704 1
a704 1
void WitStochLoc::genOpnVars ()
d711 1
a711 1
            myStExecVarFor_ (theOpn) = new WitStExecVar (theOpn, this);
d716 1
a716 1
void WitStochLoc::genBomEntVars ()
d723 1
a723 1
            myStNonSubVarFor_     (theBomEnt) =
d736 1
a736 1
            myStSubVarFor_ (theSub) = new WitStSubVar (theSub, this);
d741 1
a741 1
void WitStochLoc::genPartCons ()
d743 1
a743 2
   WitPart *     thePart;
   WitMaterial * theMat;
d752 1
a752 1
void WitStochLoc::genDemandCons ()
d763 1
a763 1
void WitStochLoc::genBomEntCons ()
@


1.71
log
@Stochastic Implosion
@
text
@d115 3
@


1.70
log
@Srochastic Implosion
@
text
@d188 7
a194 7
      WitOptProb       (theStochModeMgr->myProblem ()),
      myStochModeMgr_  (theStochModeMgr),
      myScenGroups_    (),
      stage0ScenGroup_ (NULL),
      myExecPerSched_  (NULL),
      myStochObj_      (NULL),
      myStBoundsObj_   (NULL)
d199 1
a199 1
   stage0ScenGroup_ = new WitScenGroup (this);
d201 1
a201 1
   myScenGroups_.append (stage0ScenGroup_);
d219 1
a219 1
   stage0ScenGroup_ = NULL;
a463 23
WitStochLoc * WitScenGroup::findStochLocForVar (
      WitNode * theNode,
      WitPeriod thePer)
   {
   WitStage *     theStage;
   WitScenGroup * theScenGroup;

   theStage = myStageMgr ()->myStageOf (theNode, thePer);

   if (theStage == myStage_)
      theScenGroup = this;
   else
      {
      stronglyAssert (theStage->myIndex () == 0);

      theScenGroup = myStochImpOP ()->stage0ScenGroup ();
      }

   return theScenGroup->myStochLocFor (thePer);
   }

//------------------------------------------------------------------------------

d473 1
a473 1
   if (myStage_->myIndex () == 0)
d890 23
@


1.69
log
@Stochastic Implosion
@
text
@d471 1
a471 1
   theStage = myStageMgr ()->stageOf (theNode, thePer);
@


1.68
log
@Stochastic Implosion
@
text
@d521 1
a521 1
      if (myStageMgr ()->stageIncludesPeriod (myStage_, thePer))
d681 1
a681 1
      if (myStageIncludes (thePart))
d702 1
a702 1
      if (myStageIncludes (theDemand->demandedPart ()))
d719 1
a719 1
      if (myStageIncludes (theOpn))
d731 1
a731 1
      if (myStageIncludes (theBomEnt->myOperation ()))
d744 1
a744 1
      if (myStageIncludes (theSub->myOperation ()))
d757 1
a757 1
      if (myStageIncludes (thePart))
d768 1
a768 1
      if (myStageIncludes (theDemand->demandedPart ()))
d779 1
a779 1
      if (myStageIncludes (theBomEnt->myOperation ()))
a784 7

bool WitStochLoc::myStageIncludes (WitNode * theNode)
   {
   return myStageMgr ()->stageIncludesNode (myScenGroup_->myStage (), theNode);
   }

//------------------------------------------------------------------------------
@


1.67
log
@Stochastic Implosion
@
text
@d199 1
a199 1
   stage0ScenGroup_ = WitScenGroup::newStage0ScenGroup (this);
d205 1
a205 1
      theScenGroup = WitScenGroup::newStage1ScenGroup (this, theScenario);
d417 10
a426 1
WitScenGroup * WitScenGroup::newStage0ScenGroup (WitStochImpOP * theStochImpOP)
d428 1
a428 3
   WitScenGroup * theScenGroup;

   theScenGroup = new WitScenGroup (theStochImpOP, 0);
d430 1
a430 5
   theScenGroup->myScenarios_ = theScenGroup->myScenMgr ()->myScenarios ();

   theScenGroup->setUp ();

   return theScenGroup;
d435 12
a446 3
WitScenGroup * WitScenGroup::newStage1ScenGroup (
      WitStochImpOP * theStochImpOP,
      WitScenario *   theScenario)
d448 1
a448 5
   WitScenGroup * theScenGroup;

   theScenGroup = new WitScenGroup (theStochImpOP, 1);

   theScenGroup->myScenarios_.append (theScenario);
d450 1
a450 3
   theScenGroup->setUp ();

   return theScenGroup;
d468 1
a468 1
   int            theStageIdx;
d471 1
a471 1
   theStageIdx = myStageMgr ()->stageOf (theNode, thePer)->myIndex ();
d473 1
a473 1
   if (theStageIdx == myStageIdx_)
d477 1
a477 1
      stronglyAssert (theStageIdx == 0);
d496 1
a496 1
   if (myStageIdx_ == 0)
a506 15
WitScenGroup::WitScenGroup (WitStochImpOP * theStochImpOP, int theStageIdx):

      WitStochAssoc  (theStochImpOP->myStochModeMgr ()),
      myStochImpOP_  (theStochImpOP),
      myStageIdx_    (theStageIdx),
      myScenarios_   (),
      firstScenario_ (NULL),
      myStochLocVec_ (myProblem ()),
      myStochLocs_   (),
      cumDemandVol_  (myProblem (), 0.0)
   {
   }

//------------------------------------------------------------------------------

a510 1
   WitStage *    theStage;
a519 2
   theStage = myStageMgr ()->myStageFor (myStageIdx_);

d521 1
a521 1
      if (myStageMgr ()->stageIncludesPeriod (theStage, thePer))
d788 1
a788 5
   WitStage * theStage;

   theStage = myStageMgr ()->myStageFor (myScenGroup_->myStageIdx ());

   return myStageMgr ()->stageIncludesNode (theStage, theNode);
@


1.66
log
@Stochastic Implosion
@
text
@d30 1
d462 1
a462 1
   int            theStage;
d465 1
a465 1
   theStage = myStageMgr ()->stageOf (theNode, thePer);
d467 1
a467 1
   if (theStage == myStage_)
d471 1
a471 1
      stronglyAssert (theStage == 0);
d490 1
a490 1
   if (myStage_ == 0)
d501 1
a501 1
WitScenGroup::WitScenGroup (WitStochImpOP * theStochImpOP, int theStage):
d505 1
a505 1
      myStage_       (theStage),
d520 1
d530 2
d533 1
a533 1
      if (myStageMgr ()->stageIncludesPeriod (myStage_, thePer))
d800 5
a804 3
   return
      myStageMgr ()->
         stageIncludesNode (myScenGroup_->myStage (), theNode);
@


1.65
log
@Stochastic Implosion
@
text
@a332 3
   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

d457 23
@


1.64
log
@Stochastic Implosion
@
text
@d302 1
a302 1
   WitPeriod      thePer;
a304 3
   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

d306 2
a307 2
      forEachPeriod (thePer, myProblem ())
         theScenGroup->myStochLocFor (thePer)->generateVariables ();
d318 1
a318 1
   WitPeriod      thePer;
a320 3
   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

d322 2
a323 2
      forEachPeriod (thePer, myProblem ())
         theScenGroup->myStochLocFor (thePer)->generateConstraints ();
d333 3
d347 1
a347 1
   WitPeriod      thePer;
d350 2
a351 2
      forEachPeriod (thePer, myProblem ())
         theScenGroup->myStochLocFor (thePer)->clearStochVars ();
d453 1
a453 1
   WitPeriod thePer;
d455 1
a455 2
   forEachPeriod (thePer, myProblem ())
      delete myStochLocs_[thePer];
d487 2
a488 1
      myStochLocs_   (myProblem ()),
d499 1
d510 7
a516 1
         myStochLocs_[thePer] = new WitStochLoc (this, thePer);
@


1.63
log
@Stochastic Implosion
@
text
@d511 2
a512 1
      myStochLocs_[thePer] = new WitStochLoc (this, thePer);
d665 1
a665 1
      if (matchesMyStage (thePart))
d686 1
a686 1
      if (matchesMyStage (theDemand->demandedPart ()))
d703 1
a703 1
      if (matchesMyStage (theOpn))
d715 1
a715 1
      if (matchesMyStage (theBomEnt->myOperation ()))
d728 1
a728 1
      if (matchesMyStage (theSub->myOperation ()))
d741 1
a741 1
      if (matchesMyStage (thePart))
d752 1
a752 1
      if (matchesMyStage (theDemand->demandedPart ()))
d763 1
a763 1
      if (matchesMyStage (theBomEnt->myOperation ()))
d770 1
a770 1
bool WitStochLoc::matchesMyStage (WitNode * theNode)
d772 3
a774 5
   int theStage;

   theStage = myStageMgr ()->stageOf (theNode, myPer_);

   return (theStage == myScenGroup_->myStage ());
@


1.62
log
@Stochastic Implosion
@
text
@d491 1
a491 1
      myStochLocs_   (),
a509 2
   myStochLocs_.allocate (myProblem ());

@


1.61
log
@Stochastic Implosion
@
text
@d666 1
a666 1
      if (notInOtherStage (thePart))
d687 1
a687 1
      if (notInOtherStage (theDemand->demandedPart ()))
d704 1
a704 1
      if (notInOtherStage (theOpn))
d716 1
a716 1
      if (notInOtherStage (theBomEnt->myOperation ()))
d729 1
a729 1
      if (notInOtherStage (theSub->myOperation ()))
d742 1
a742 1
      if (notInOtherStage (thePart))
d753 1
a753 1
      if (notInOtherStage (theDemand->demandedPart ()))
d764 1
a764 1
      if (notInOtherStage (theBomEnt->myOperation ()))
d771 1
a771 1
bool WitStochLoc::notInOtherStage (WitNode * theNode)
d773 1
a773 1
   int otherStage;
d775 1
a775 1
   otherStage = 1 - myScenGroup_->myStage ();
d777 1
a777 1
   return not myStageMgr ()->nodeBelongsToStage (theNode, otherStage);
@


1.60
log
@Stochastic Implosion
@
text
@d666 1
a666 1
      if (intersectsMyStage (thePart))
d687 1
a687 1
      if (intersectsMyStage (theDemand->demandedPart ()))
d704 1
a704 1
      if (intersectsMyStage (theOpn))
d716 1
a716 1
      if (intersectsMyStage (theBomEnt->myOperation ()))
d729 1
a729 1
      if (intersectsMyStage (theSub->myOperation ()))
d742 1
a742 1
      if (intersectsMyStage (thePart))
d753 1
a753 1
      if (intersectsMyStage (theDemand->demandedPart ()))
d764 1
a764 1
      if (intersectsMyStage (theBomEnt->myOperation ()))
d771 1
a771 1
bool WitStochLoc::intersectsMyStage (WitNode * theNode)
d773 5
a777 3
   return
      myStageMgr ()->
         nodeIntersectsStage (theNode, myScenGroup_->myStage ());
@


1.59
log
@Stochastic Implosion
@
text
@a25 1
#include <ScenGroup.h>
a29 1
#include <StochModeMgr.h>
d60 3
a62 4
      WitProbAssoc    (theStochModeMgr),
      myStochModeMgr_ (theStochModeMgr),
      myStochImpOP_   (NULL),
      uploadingSoln_  (false)
d93 1
a93 1
   stronglyAssert (not myStochModeMgr_->stochSolnMode ());
d97 4
a100 4
   myStochModeMgr_->myScenAttMgr ()->downloadInput ();
   myStochModeMgr_->myStageMgr   ()->validateData  ();
   myStochModeMgr_->myScenMgr    ()->validateData  ();
   myStochModeMgr_->myScenAttMgr ()->validateData  ();
d110 1
a110 1
   myStochImpOP_ = new WitStochImpOP (myStochModeMgr_);
d131 1
a131 1
   myStochModeMgr_->uploadSoln ();
d152 2
a153 2
   myStochModeMgr_->passObjValue    (objValueVal);
   myStochModeMgr_->passBoundsValue (boundsValueVal);
d428 1
a428 2
   theScenGroup->myScenarios_ =
      theStochImpOP->myStochModeMgr ()->myScenMgr ()->myScenarios ();
a463 7
bool WitScenGroup::myStageIntersects (WitNode * theNode)
   {
   return myStageMgr_->intersectsStage (myStage_, theNode);
   }

//------------------------------------------------------------------------------

d486 1
a486 1
      WitProbAssoc   (theStochImpOP),
a488 1
      myStageMgr_    (NULL),
a502 2
   myStageMgr_    = myStochImpOP_->myStochModeMgr ()->myStageMgr ();

d522 3
a524 7
   WitScenInputAtt <WitDemand> * demandVolAtt;
   WitDemand *                   theDemand;
   double                        cumSum;
   WitPeriod                     thePer;

   demandVolAtt =
      myStochImpOP_->myStochModeMgr ()->myScenAttMgr ()->demandVol ();
d532 4
a535 1
         cumSum += demandVolAtt->myValueFor (theDemand, firstScenario_)[thePer];
d548 1
a548 1
      WitProbAssoc       (theScenGroup),
a550 2
      myStochImpOP_      (NULL),
      myScenAttMgr_      (NULL),
a558 3
   myStochImpOP_ = theScenGroup->myStochImpOP ();

   myScenAttMgr_ = myStochImpOP_->myStochModeMgr ()->myScenAttMgr ();
d604 1
a604 1
   fprintf (myStochImpOP_->optProbFile (), " %3d", myPer_);
d666 1
a666 1
      if (myScenGroup_->myStageIntersects (thePart))
d687 1
a687 1
      if (myScenGroup_->myStageIntersects (theDemand->demandedPart ()))
d704 1
a704 1
      if (myScenGroup_->myStageIntersects (theOpn))
d716 1
a716 1
      if (myScenGroup_->myStageIntersects (theBomEnt->myOperation ()))
d729 1
a729 1
      if (myScenGroup_->myStageIntersects (theSub->myOperation ()))
d742 1
a742 1
      if (myScenGroup_->myStageIntersects (thePart))
d753 1
a753 1
      if (myScenGroup_->myStageIntersects (theDemand->demandedPart ()))
d764 1
a764 1
      if (myScenGroup_->myStageIntersects (theBomEnt->myOperation ()))
d770 9
@


1.58
log
@Stochastic Implosion
@
text
@d201 1
a201 1
   stage0ScenGroup_ = new WitScenGroup (0, NULL, this);
d207 1
a207 1
      theScenGroup = new WitScenGroup (1, theScenario, this);
d425 1
a425 13
WitScenGroup::WitScenGroup (
         int             theStage,
         WitScenario *   theScenario,
         WitStochImpOP * theStochImpOP):

      WitProbAssoc   (theStochImpOP),
      myStochImpOP_  (theStochImpOP),
      myStage_       (theStage),
      myStageMgr_    (NULL),
      myScenarios_   (),
      firstScenario_ (NULL),
      myStochLocs_   (),
      cumDemandVol_  (myProblem (), 0.0)
d427 1
a427 6
   WitScenario * othScenario;
   WitPeriod     thePer;

   if (myStage_ == 0)
      {
      witAssert (theScenario == NULL);
d429 1
a429 6
      myScenarios_ =
         myStochImpOP_->myStochModeMgr ()->myScenMgr ()->myScenarios ();
      }
   else
      {
      witAssert (myStage_ == 1);
d431 2
a432 1
      witAssert (theScenario != NULL);
d434 1
a434 2
      myScenarios_.append (theScenario);
      }
d436 2
a437 1
   myStageMgr_    = myStochImpOP_->myStochModeMgr ()->myStageMgr ();
d439 1
a439 1
   firstScenario_ = myScenarios_.first ();
d441 5
a445 1
   totalProb_     = 0.0;
d447 1
a447 2
   forEachEl (othScenario, myScenarios_)
      totalProb_ += othScenario->probability ();
d449 1
a449 1
   myStochLocs_.allocate (myProblem ());
d451 1
a451 2
   forEachPeriod (thePer, myProblem ())
      myStochLocs_[thePer] = new WitStochLoc (this, thePer);
d453 1
a453 1
   compCumDemandVol ();
d495 39
@


1.57
log
@Stochastic Implosion
@
text
@d433 1
d458 2
d487 7
a544 1
      myStage_           (theScenGroup->myStage ()),
d546 2
a547 2
      myStochImpOP_      (theScenGroup->myStochImpOP ()),
      myScenAttMgr_      (myStochImpOP_->myStochModeMgr ()->myScenAttMgr ()),
d556 3
d666 1
a666 1
      if (objectStage (thePart) == myStage_)
d687 1
a687 1
      if (objectStage (theDemand->demandedPart ()) == myStage_)
d704 1
a704 1
      if (objectStage (theOpn) == myStage_)
d716 1
a716 1
      if (objectStage (theBomEnt->myOperation ()) == myStage_)
d729 1
a729 1
      if (objectStage (theSub->myOperation ()) == myStage_)
d742 1
a742 1
      if (objectStage (thePart) == myStage_)
d753 1
a753 1
      if (objectStage (theDemand->demandedPart ()) == myStage_)
d764 1
a764 1
      if (objectStage (theBomEnt->myOperation ()) == myStage_)
a769 7

int WitStochLoc::objectStage (WitNode * theNode)
   {
   return myStochImpMgr ()->objectStage (theNode);
   }

//------------------------------------------------------------------------------
@


1.56
log
@Stochastic Implosion
@
text
@d426 1
a426 1
         int             stageIndexVal,
d432 1
a432 1
      myStageIndex_  (stageIndexVal),
d441 1
a441 1
   if (myStageIndex_ == 0)
d450 1
a450 1
      witAssert (myStageIndex_ == 1);
d493 1
a493 1
   if (myStageIndex_ == 0)
d535 1
a535 1
      myStageIndex_      (theScenGroup->myStageIndex ()),
d654 1
a654 1
      if (stageIndex (thePart) == myStageIndex_)
d675 1
a675 1
      if (stageIndex (theDemand->demandedPart ()) == myStageIndex_)
d692 1
a692 1
      if (stageIndex (theOpn) == myStageIndex_)
d704 1
a704 1
      if (stageIndex (theBomEnt->myOperation ()) == myStageIndex_)
d717 1
a717 1
      if (stageIndex (theSub->myOperation ()) == myStageIndex_)
d730 1
a730 1
      if (stageIndex (thePart) == myStageIndex_)
d741 1
a741 1
      if (stageIndex (theDemand->demandedPart ()) == myStageIndex_)
d752 1
a752 1
      if (stageIndex (theBomEnt->myOperation ()) == myStageIndex_)
d759 1
a759 1
int WitStochLoc::stageIndex (WitNode * theNode)
d761 1
a761 1
   return myStochImpMgr ()->stageIndex (theNode);
@


1.55
log
@Stochastic Implosion
@
text
@d308 3
d327 3
d432 1
a432 1
      stageIndex_    (stageIndexVal),
d441 1
a441 1
   if (stageIndex_ == 0)
a447 1

d450 1
a450 1
      witAssert (stageIndex_ == 1);
d493 1
a493 1
   if (stageIndex_ == 0)
d535 1
d559 5
a563 46
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitDemand *    theDemand;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;

   forEachPart (thePart, myProblem ())
      if (matchesMyStage (thePart))
         {
         if (thePart->scrapAllowed ())
            myStScrapVarFor_ (thePart) = new WitStScrapVar (thePart, this);

         if (thePart->canStock (myPer_))
            {
            theMat = thePart->thisMat ();

            myStStockVarFor_ (theMat) = new WitStStockVar (theMat, this);
            }
         }

   forEachOperation (theOpn, myProblem ())
      if (matchesMyStage (theOpn))
         if (theOpn->executable ()[myPer_])
            myStExecVarFor_ (theOpn) = new WitStExecVar (theOpn, this);

   forEachDemand (theDemand, myProblem ())
      if (matchesMyStage (theDemand->demandedPart ()))
         {
         myStShipVarFor_ (theDemand) = new WitStShipVar (theDemand, this);

         if (theDemand->shipLateAllowed ())
            myStCumShipVarFor_     (theDemand) =
               new WitStCumShipVar (theDemand, this);
         }

   forEachBomEntry (theBomEnt, myProblem ())
      if (matchesMyStage (theBomEnt->myOperation ()))
         if (theBomEnt->hasSubsInEffect ()[myPer_])
            myStNonSubVarFor_     (theBomEnt) =
               new WitStNonSubVar (theBomEnt, this);

   forEachSubEntry (theSub, myProblem ())
      if (matchesMyStage (theSub->myOperation ()))
         if (theSub->inEffect (myPer_))
            myStSubVarFor_ (theSub) = new WitStSubVar (theSub, this);
d570 3
a572 16
   WitPart *     thePart;
   WitDemand *   theDemand;
   WitBomEntry * theBomEnt;

   forEachPart (thePart, myProblem ())
      if (matchesMyStage (thePart))
         new WitStResCon (thePart, this);

   forEachDemand (theDemand, myProblem ())
      if (matchesMyStage (theDemand->demandedPart ()))
         new WitStShipCon (theDemand, this);

   forEachBomEntry (theBomEnt, myProblem ())
      if (matchesMyStage (theBomEnt->myOperation ()))
         if (theBomEnt->hasSubsInEffect ()[myPer_])
            new WitStSubCon (theBomEnt, this);
d648 23
a670 1
bool WitStochLoc::matchesMyStage (WitNode * theNode)
d672 86
a757 2
   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);
d759 3
a761 3
   return
         myStochImpMgr ()->stageIndex (theNode)
      == myScenGroup_    ->stageIndex ();
@


1.54
log
@Stochastic Implosion
@
text
@d32 1
a32 1
#include <ObjStageMgr.h>
d100 4
a103 4
   myStochModeMgr_->myScenAttMgr  ()->downloadInput ();
   myStochModeMgr_->myObjStageMgr ()->validateData  ();
   myStochModeMgr_->myScenMgr     ()->validateData  ();
   myStochModeMgr_->myScenAttMgr  ()->validateData  ();
d698 3
@


1.53
log
@Stochastic Implosion
@
text
@d32 1
a32 1
#include <StageMgr.h>
d100 4
a103 4
   myStochModeMgr_->myScenAttMgr ()->downloadInput ();
   myStochModeMgr_->myStageMgr   ()->validateData  ();
   myStochModeMgr_->myScenMgr    ()->validateData  ();
   myStochModeMgr_->myScenAttMgr ()->validateData  ();
@


1.52
log
@Stochastic Implosion
@
text
@a93 2
   WitScenario * theScenario;

a99 2
   theScenario = myStochModeMgr_->myScenMgr ()->curScenario ();

d103 1
a110 7
   setUpOptProb   ();
   }

//------------------------------------------------------------------------------

void WitStochOptMgr::setUpOptProb ()
   {
@


1.51
log
@Stochastic Implosion
@
text
@d430 1
a430 1
         int             stageNoVal,
d436 1
a436 1
      stageNo_       (stageNoVal),
d445 1
a445 1
   if (stageNo_ == 0)
d455 1
a455 1
      witAssert (stageNo_ == 1);
d498 1
a498 1
   if (stageNo_ == 0)
d709 2
a710 2
         myStochImpMgr ()->stageNo (theNode)
      == myScenGroup_    ->stageNo ();
@


1.50
log
@Stochastic Implosion
@
text
@a109 2
   myPreprocessor ()->verifyNoIntCons ();

@


1.49
log
@Stochastic Implosion
@
text
@a106 1
   myStochModeMgr_->myScenAttMgr ()->validateData  ();
@


1.48
log
@Stochastic Implosion
@
text
@d251 2
a252 1
   stronglyAssert (false);
d259 2
a260 1
   stronglyAssert (false);
d398 31
@


1.47
log
@Stochastic Implosion
@
text
@d35 1
d94 2
d102 6
a107 3
   myStochModeMgr_->myScenMgr  ()->curScenario ()->downloadInput ();
   myStochModeMgr_->myStageMgr ()->validateData                  ();
   myStochModeMgr_->myScenMgr  ()->validateData                  ();
d481 7
a487 3
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;
d495 1
a495 1
         cumSum += firstScenario_->demandVol ()->myValueFor (theDemand)[thePer];
d510 1
d512 1
a512 1
      myPer_             (thePer),
@


1.46
log
@Stochastic Implosion
@
text
@d35 1
d485 1
a485 1
         cumSum += firstScenario_->demandVol (theDemand, thePer);
@


1.45
log
@Stochastic Implosion
@
text
@a34 2
#include <ScenAttMgr.h>
#include <ScenInputAtt.h>
d98 3
a100 4
   myStochModeMgr_->myScenAttMgr ()->downloadInputToCurScen ();
   myStochModeMgr_->myStageMgr   ()->validateData           ();
   myStochModeMgr_->myScenMgr    ()->validateData           ();
   myStochModeMgr_->myScenAttMgr ()->checkInputInStage0     ();
d173 2
a175 1
   WitOptVar *   theOptVar;
d180 6
a185 1
      theOptVar->mandStochVar ()->uploadSoln ();
d474 3
a476 4
   WitScenInputAtt <WitDemand> * demandVolAtt;
   WitDemand *                   theDemand;
   double                        cumSum;
   WitPeriod                     thePer;
d478 3
a480 2
   demandVolAtt =
      myStochImpOP_->myStochModeMgr ()->myScenAttMgr ()->demandVol ();
d482 1
a482 4
   forEachDemand (theDemand, myProblem ())
      if (demandVolAtt->myValue (theDemand, firstScenario_) == 0.0)
         cumDemandVol_ (theDemand) = 0.0;
      else
d484 1
a484 1
         cumSum = 0.0;
d486 1
a486 6
         forEachPeriod (thePer, myProblem ())
            {
            cumSum += demandVolAtt->myValue (theDemand, firstScenario_)[thePer];

            cumDemandVol_ (theDemand)[thePer] = cumSum;
            }
d488 1
a766 7
WitScenAttMgr * WitStochVar::myScenAttMgr ()
   {
   return myStochImpOP ()->myStochModeMgr ()->myScenAttMgr ();
   }

//------------------------------------------------------------------------------

@


1.44
log
@Stochastic Implosion
@
text
@d101 3
a103 3
   myStochModeMgr_->myStageMgr   ()->validateData ();
   myStochModeMgr_->myScenMgr    ()->validateData ();
   myStochModeMgr_->myScenAttMgr ()->checkInputAttrsInStage0 ();
@


1.43
log
@Stochastic Implosion
@
text
@d100 1
d103 1
a103 1
   myStochModeMgr_->myScenAttMgr ()->downloadInputToCurScen ();
@


1.42
log
@Stochastic Implosion
@
text
@d470 4
a473 4
   WitConcScenInputAtt <WitDemand> * demandVolAtt;
   WitDemand *                       theDemand;
   double                            cumSum;
   WitPeriod                         thePer;
@


1.41
log
@Stochastic Implosion
@
text
@d36 1
d470 7
a476 3
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;
d479 1
a479 1
      if (firstScenario_->demandVolAcc (theDemand) == 0.0)
d487 1
a487 1
            cumSum += firstScenario_->demandVolAcc (theDemand)[thePer];
@


1.40
log
@Stochastic Implosion
@
text
@a178 3
   forEachEl (theScenario, myStochModeMgr_->myScenMgr ()->myScenarios ())
      theScenario->allocSoln ();

@


1.39
log
@Stochastic Implosion
@
text
@d120 1
a120 1
   myStochImpOP_ = new WitStochImpOP (this);
d141 1
a141 1
   myStochModeMgr ()->uploadSoln ();
d192 1
a192 1
WitStochImpOP::WitStochImpOP (WitStochOptMgr * theStochOptMgr):
d194 2
a195 3
      WitOptProb       (theStochOptMgr->myProblem ()),
      myStochOptMgr_   (theStochOptMgr),
      myScenMgr_       (myStochOptMgr_->myStochModeMgr ()->myScenMgr ()),
d209 1
a209 1
   forEachEl (theScenario, myScenMgr_->myScenarios ())
d410 2
a411 1
      myScenarios_ = myStochImpOP_->myScenMgr ()->myScenarios ();
d500 1
d609 1
a609 1
   fprintf (myScenGroup_->myStochImpOP ()->optProbFile (), " %3d", myPer_);
d768 7
@


1.38
log
@Stochastic Implosion
@
text
@d35 1
d99 3
a101 4
   myStochModeMgr_->myStageMgr ()->validateData ();
   myStochModeMgr_->myScenMgr  ()->validateData ();

   myStochModeMgr_->myScenMgr  ()->curScenario ()->downloadInputAttrs ();
@


1.37
log
@Stochastic Implosion
@
text
@d477 1
a477 1
      if (firstScenario_->demandVol () (theDemand) == 0.0)
d485 1
a485 1
            cumSum += firstScenario_->demandVol () (theDemand)[thePer];
@


1.36
log
@Stochastic Implosion
@
text
@d101 1
a101 1
   myStochModeMgr_->myScenMgr  ()->curScenario ()->saveInputAttrs ();
@


1.35
log
@Stochastic Implosion
@
text
@d141 1
a141 1
   myStochModeMgr ()->exportSoln ();
d151 2
a152 5
   double       theStochVal;
   double       theStBoundsVal;

   theStochVal    = myStochImpOP_->myStochObj    ()->myValue ();
   theStBoundsVal = myStochImpOP_->myStBoundsObj ()->myValue ();
d159 5
a163 1
   myOptComp ()->loadInObjVals (theStochVal, theStBoundsVal);
@


1.34
log
@Stochastic Implosion
@
text
@d362 10
d400 2
a401 1
      myStochLocs_   ()
d433 2
d449 7
d468 24
@


1.33
log
@Stochastic Implosion
@
text
@d19 1
a20 1
//    StochObj.
d199 2
a200 2
      myStBoundsObj_   (NULL),
      myStochObj_      (NULL)
d338 1
a339 1
   myStochObj_    = new WitStochObj    (this);
d627 1
a627 1
// Implementation of class StBoundsObj.
d630 2
a631 2
WitStBoundsObj::WitStBoundsObj (WitStochImpOP * theStochImpOP):
      WitOptObj ("Stochastic Bounds Objective", theStochImpOP)
d637 1
a637 1
WitStBoundsObj::~WitStBoundsObj ()
d643 1
a643 1
double WitStBoundsObj::coeffVal (WitOptVar * theVar)
d645 1
a645 1
   return theVar->mandStochVar ()->stBoundsCoeffVal ();
d649 1
a649 1
// Implementation of class StochObj.
d652 2
a653 2
WitStochObj::WitStochObj (WitStochImpOP * theStochImpOP):
      WitOptObj ("Stochastic Objective", theStochImpOP)
d659 1
a659 1
WitStochObj::~WitStochObj ()
d665 1
a665 1
double WitStochObj::coeffVal (WitOptVar * theVar)
d667 1
a667 1
   return theVar->mandStochVar ()->stochCoeffVal ();
@


1.32
log
@Stochastic Implosion
@
text
@a18 1
//    StPrimaryObj.
d151 2
a152 1
   double       theStochObjVal;
d154 2
a155 1
   theStochObjVal = myStochImpOP_->myStochObj ()->myValue ();
d162 1
a162 3
   myOptComp ()->loadInObjVals (theStochObjVal, 0.0);

   myOptComp ()->myObjFunc1 ()->loadInPrimaryValue (theStochObjVal);
d166 1
a166 1
   myMsgFac () ("mainObjValueMsg", 1, myOptComp ()->objValue ());
a198 1
      myStPrimaryObj_  (NULL),
d338 2
a339 3
   myStPrimaryObj_ = new WitStPrimaryObj (this);
   myStBoundsObj_  = new WitStBoundsObj  (this);
   myStochObj_     = new WitStochObj     (this);
a626 22
// Implementation of class StPrimaryObj.
//------------------------------------------------------------------------------

WitStPrimaryObj::WitStPrimaryObj (WitStochImpOP * theStochImpOP):
      WitOptObj ("Stochastic Primary Objective", theStochImpOP)
   {
   }

//------------------------------------------------------------------------------

WitStPrimaryObj::~WitStPrimaryObj ()
   {
   }

//------------------------------------------------------------------------------

double WitStPrimaryObj::coeffVal (WitOptVar * theVar)
   {
   return theVar->mandStochVar ()->stPrimaryCoeffVal ();
   }

//------------------------------------------------------------------------------
d667 1
a667 7
   WitStochVar * theStochVar;

   theStochVar = theVar->mandStochVar ();

   return
        theStochVar->stPrimaryCoeffVal ()
      - theStochVar->stBoundsCoeffVal  () * myOptComp ()->wbounds ();
@


1.31
log
@Stochastic Implosion
@
text
@d19 2
d29 1
a29 1
#include <StochObj.h>
d200 2
d340 3
a342 1
   myStochObj_ = new WitStochObj (this);
d630 44
a692 1
   double        theProb;
d696 3
a698 3
   theProb     = theStochVar->myStochLoc ()->myScenGroup ()->totalProb ();

   return theProb * theStochVar->stochCoeffVal ();
d746 7
@


1.30
log
@Stochastic Implosion
@
text
@d295 1
a295 1
      " Var #%-7d BS #%-8d %-12s",
d297 1
a297 2
      theStBddVar->myBoundSet ()->mappingIndex (),
      "");
d306 1
d311 3
d322 1
d327 3
a490 2

            myStStockVarFor_ (theMat)->genStSlbvVarIfNeeded ();
a496 1
            {
a498 3
            myStExecVarFor_ (theOpn)->genStSlbvVarIfNeeded ();
            }

a504 1
            {
a506 3

            myStCumShipVarFor_     (theDemand)->genStSlbvVarIfNeeded ();
            }
d685 12
@


1.29
log
@Stochastic Implosion
@
text
@d46 1
d292 11
d467 1
d477 1
a477 2
            myStScrapVarFor_     (thePart) =
               new WitStScrapVar (thePart, this);
d480 7
a486 2
            myStStockVarFor_     (thePart->thisMat ()) =
               new WitStStockVar (thePart->thisMat (), this);
d492 5
a496 2
            myStExecVarFor_     (theOpn) =
               new WitStExecVar (theOpn, this);
d501 1
a501 2
         myStShipVarFor_     (theDemand) =
            new WitStShipVar (theDemand, this);
d504 1
d507 3
d521 1
a521 2
            myStSubVarFor_     (theSub) =
               new WitStSubVar (theSub, this);
@


1.28
log
@Stochastic Implosion
@
text
@d96 2
a97 3
   myStochModeMgr_->myStageMgr ()->validateData    ();
   myStochModeMgr_->myScenMgr  ()->validateData    ();
// myStochModeMgr_->myStageMgr ()->verifyAllStage1 ();
d191 7
a197 6
      WitOptProb      (theStochOptMgr->myProblem ()),
      myStochOptMgr_  (theStochOptMgr),
      myScenMgr_      (myStochOptMgr_->myStochModeMgr ()->myScenMgr ()),
      myScenGroups_   (),
      myExecPerSched_ (NULL),
      myStochObj_     (NULL)
d199 4
a202 1
   WitScenario * theScenario;
d204 1
a204 1
   myScenGroups_.append (new WitScenGroup (0, NULL, this));
d207 5
a211 1
      myScenGroups_.append (new WitScenGroup (1, theScenario, this));
d222 2
a698 7
WitStochLoc * WitStochCon::myStochLocForPer (WitPeriod thePer)
   {
   return myScenGroup ()->myStochLocFor (thePer);
   }

//------------------------------------------------------------------------------

@


1.27
log
@Stochastic Implosion
@
text
@d35 1
d98 1
a98 1
   myStochModeMgr_->myStageMgr ()->verifyAllStage1 ();
d288 2
a289 3
      if (theScenGroup->stageNo () == 1)
         forEachPeriod (thePer, myProblem ())
            theScenGroup->myStochLocFor (thePer)->generateVariables ();
a297 4
   WitStochLoc *  theStochLoc;
   WitPart *      thePart;
   WitDemand *    theDemand;
   WitBomEntry *  theBomEnt;
d300 2
a301 15
      if (theScenGroup->stageNo () == 1)
         forEachPeriod (thePer, myProblem ())
            {
            theStochLoc = theScenGroup->myStochLocFor (thePer);

            forEachPart (thePart, myProblem ())
               new WitStResCon (thePart, theStochLoc);

            forEachDemand (theDemand, myProblem ())
               new WitStShipCon (theDemand, theStochLoc);

            forEachBomEntry (theBomEnt, myProblem ())
               if (theBomEnt->hasSubsInEffect ()[thePer])
                  new WitStSubCon (theBomEnt, theStochLoc);
            }
d452 10
a461 9
      {
      if (thePart->scrapAllowed ())
         myStScrapVarFor_     (thePart) =
            new WitStScrapVar (thePart, this);

      if (thePart->canStock (myPer_))
         myStStockVarFor_     (thePart->thisMat ()) =
            new WitStStockVar (thePart->thisMat (), this);
      }
d464 4
a467 3
      if (theOpn->executable ()[myPer_])
         myStExecVarFor_     (theOpn) =
            new WitStExecVar (theOpn, this);
d470 9
a478 8
      {
      myStShipVarFor_     (theDemand) =
         new WitStShipVar (theDemand, this);

      if (theDemand->shipLateAllowed ())
         myStCumShipVarFor_     (theDemand) =
            new WitStCumShipVar (theDemand, this);
      }
d481 4
a484 3
      if (theBomEnt->hasSubsInEffect ()[myPer_])
         myStNonSubVarFor_     (theBomEnt) =
            new WitStNonSubVar (theBomEnt, this);
d487 26
a512 3
      if (theSub->inEffect (myPer_))
         myStSubVarFor_     (theSub) =
            new WitStSubVar (theSub, this);
d587 9
@


1.26
log
@Stochastic Implosion
@
text
@d191 6
a196 7
      WitOptProb         (theStochOptMgr->myProblem ()),
      myStochOptMgr_     (theStochOptMgr),
      myScenMgr_         (myStochOptMgr_->myStochModeMgr ()->myScenMgr ()),
      myAllScenGroup_    (NULL),
      mySglScenGroupFor_ (),
      myExecPerSched_    (NULL),
      myStochObj_        (NULL)
d200 1
a200 3
   myAllScenGroup_ = new WitScenGroup (this);

   mySglScenGroupFor_.allocate (myProblem ());
d203 1
a203 1
      mySglScenGroupFor_ (theScenario) = new WitScenGroup (theScenario, this);
a211 2
   WitScenario * theScenario;

d214 2
a215 4
   forEachEl (theScenario, myScenMgr_->myScenarios ())
      delete mySglScenGroupFor_ (theScenario);

   delete myAllScenGroup_;
d283 2
a284 2
   WitScenario * theScenario;
   WitPeriod     thePer;
d286 4
a289 5
   forEachEl (theScenario, myScenMgr_->myScenarios ())
      forEachPeriod (thePer, myProblem ())
         mySglScenGroupFor_ (theScenario)->
            myStochLocFor (thePer)->
               generateVariables ();
d296 6
a301 17
   WitScenario * theScenario;
   WitPeriod     thePer;
   WitStochLoc * theStochLoc;
   WitPart *     thePart;
   WitDemand *   theDemand;
   WitBomEntry * theBomEnt;

   forEachEl (theScenario, myScenMgr_->myScenarios ())
      forEachPeriod (thePer, myProblem ())
         {
         theStochLoc = mySglScenGroupFor_ (theScenario)->myStochLocFor (thePer);

         forEachPart (thePart, myProblem ())
            new WitStResCon (thePart, theStochLoc);

         forEachDemand (theDemand, myProblem ())
            new WitStShipCon (theDemand, theStochLoc);
d303 16
a318 4
         forEachBomEntry (theBomEnt, myProblem ())
            if (theBomEnt->hasSubsInEffect ()[thePer])
               new WitStSubCon (theBomEnt, theStochLoc);
         }
d334 2
a335 2
   WitScenario * theScenario;
   WitPeriod     thePer;
d337 3
a339 11
   forEachPeriod (thePer, myProblem ())
      {
      myAllScenGroup_->
         myStochLocFor (thePer)->
            clearStochVars ();

      forEachEl (theScenario, myScenMgr_->myScenarios ())
         mySglScenGroupFor_ (theScenario)->
            myStochLocFor (thePer)->
               clearStochVars ();
      }
d366 4
a369 1
WitScenGroup::WitScenGroup (WitStochImpOP * theStochImpOP):
d373 1
a373 1
      stageNo_       (0),
a375 1
      totalProb_     (0.0),
d378 13
a390 1
   myScenarios_ = myStochImpOP_->myScenMgr ()->myScenarios ();
d392 6
a397 2
   setUp ();
   }
d399 1
a399 1
//------------------------------------------------------------------------------
d401 2
a402 3
WitScenGroup::WitScenGroup (
         WitScenario *   theScenario,
         WitStochImpOP * theStochImpOP):
d404 1
a404 8
      WitProbAssoc   (theStochImpOP),
      myStochImpOP_  (theStochImpOP),
      stageNo_       (1),
      myScenarios_   (),
      firstScenario_ (NULL),
      myStochLocs_   ()
   {
   myScenarios_.append (theScenario);
d406 2
a407 1
   setUp ();
a433 20

void WitScenGroup::setUp ()
   {
   WitScenario * theScenario;
   WitPeriod     thePer;

   firstScenario_ = myScenarios_.first ();

   totalProb_     = 0.0;

   forEachEl (theScenario, myScenarios_)
      totalProb_ += theScenario->probability ();

   myStochLocs_.allocate (myProblem ());

   forEachPeriod (thePer, myProblem ())
      myStochLocs_[thePer] = new WitStochLoc (this, thePer);
   }

//------------------------------------------------------------------------------
@


1.25
log
@Stochastic Implosion
@
text
@d95 3
a97 3
   myStochModeMgr_->myStageMgr ()->validateData      ();
   myStochModeMgr_->myScenMgr  ()->validateData      ();
   myStochModeMgr_->myStageMgr ()->verifyAllRecourse ();
d385 1
a385 1
      recourseStage_ (false),
d404 1
a404 1
      recourseStage_ (true),
d428 4
a431 1
   if (recourseStage_)
a434 2
   else
      fprintf (myStochImpOP_->optProbFile (), " All");
@


1.24
log
@Stochastic Implosion
@
text
@d17 1
a17 1
//    ScenSet
d25 1
a25 1
#include <ScenSet.h>
d191 7
a197 7
      WitOptProb       (theStochOptMgr->myProblem ()),
      myStochOptMgr_   (theStochOptMgr),
      myScenMgr_       (myStochOptMgr_->myStochModeMgr ()->myScenMgr ()),
      myAllScenSet_    (NULL),
      mySglScenSetFor_ (),
      myExecPerSched_  (NULL),
      myStochObj_      (NULL)
d201 1
a201 1
   myAllScenSet_ = new WitScenSet (this);
d203 1
a203 1
   mySglScenSetFor_.allocate (myProblem ());
d206 1
a206 1
      mySglScenSetFor_ (theScenario) = new WitScenSet (theScenario, this);
d220 1
a220 1
      delete mySglScenSetFor_ (theScenario);
d222 1
a222 1
   delete myAllScenSet_;
d295 1
a295 1
         mySglScenSetFor_ (theScenario)->
d314 1
a314 1
         theStochLoc = mySglScenSetFor_ (theScenario)->myStochLocFor (thePer);
d346 1
a346 1
      myAllScenSet_->
d351 1
a351 1
         mySglScenSetFor_ (theScenario)->
d378 1
a378 1
// Implementation of class ScenSet.
d381 1
a381 1
WitScenSet::WitScenSet (WitStochImpOP * theStochImpOP):
d398 1
a398 1
WitScenSet::WitScenSet (
d416 1
a416 1
WitScenSet::~WitScenSet ()
d426 1
a426 1
void WitScenSet::print ()
d438 1
a438 1
void WitScenSet::setUp ()
d460 1
a460 1
WitStochLoc::WitStochLoc (WitScenSet * theScenSet, WitPeriod thePer):
d462 2
a463 2
      WitProbAssoc       (theScenSet),
      myScenSet_         (theScenSet),
d545 1
a545 1
   fprintf (myScenSet_->myStochImpOP ()->optProbFile (), " %3d", myPer_);
d547 1
a547 1
   myScenSet_->print ();
d623 1
a623 1
   theProb     = theStochVar->myStochLoc ()->myScenSet ()->totalProb ();
d634 1
a634 1
      WitOptVar   (theStochLoc->myScenSet ()->myStochImpOP ()),
d674 1
a674 1
      WitOptCon   (theStochLoc->myScenSet ()->myStochImpOP ()),
d696 1
a696 1
   return myScenSet ()->myStochLocFor (thePer);
@


1.23
log
@Stochastic Implosion
@
text
@d13 9
a21 7
// Contains:
//    The implementation of class StochOptMgr
//    The implementation of class ScenSet
//    The implementation of class StochLoc
//    The implementation of class StochObj.
//    The implementation of class StochVar
//    The implementation of class StochCon
d45 1
d186 192
@


1.22
log
@Stochastic Implosion
@
text
@d253 1
a253 1
      totalProb_ += theScenario->scenarioProb ();
@


1.21
log
@Stochastic Implosion
@
text
@d191 3
a193 1
      myScenario_    (NULL),
d196 2
d210 2
a211 1
      myScenario_    (theScenario),
d214 2
d231 12
d245 9
a253 1
   WitPeriod thePer;
d350 3
a352 2
   myScenSet_->myStochImpOP ()->printPeriod   (myPer_);
   myScenSet_->myStochImpOP ()->printScenario (myScenSet_->myScenario ());
d428 1
a428 6
   theProb     =
     theStochVar->
         myStochLoc ()->
            myScenSet ()->
               myScenario ()->
                 scenarioProb ();
d454 1
a454 1
   return myStochLoc_->myScenSet ()->myStochImpOP ();
d494 1
a494 1
   return myStochLoc_->myScenSet ()->myStochImpOP ();
d501 1
a501 1
   return myStochLoc_->myScenSet ()->myStochLocFor (thePer);
@


1.20
log
@Stochastic Implosion
@
text
@a16 1
//    The implementation of class ScenPer
a24 1
#include <ScenPer.h>
d188 5
a192 4
      WitProbAssoc  (theStochImpOP),
      myStochImpOP_ (theStochImpOP),
      my1Scenario_  (NULL),
      myStochLocs_  ()
d203 5
a207 4
      WitProbAssoc  (theStochImpOP),
      myStochImpOP_ (theStochImpOP),
      my1Scenario_  (theScenario),
      myStochLocs_  ()
a262 1
   WitScenPer *   theScenPer;
a268 5
   theScenPer =
      myScenSet_->
         myStochImpOP ()->
            myScenPerSched ().myPtrAt (myScenSet_->my1Scenario (), myPer_);

d273 1
a273 1
            new WitStScrapVar (thePart, theScenPer);
d277 1
a277 1
            new WitStStockVar (thePart->thisMat (), theScenPer);
d283 1
a283 1
            new WitStExecVar (theOpn, theScenPer);
d288 1
a288 1
         new WitStShipVar (theDemand, theScenPer);
d292 1
a292 1
            new WitStCumShipVar (theDemand, theScenPer);
d298 1
a298 1
            new WitStNonSubVar (theBomEnt, theScenPer);
d303 1
a303 1
            new WitStSubVar (theSub, theScenPer);
d321 8
a376 33
// Implementation of class ScenPer.
//------------------------------------------------------------------------------

WitScenPer::WitScenPer (WitProblem * theProblem):

      WitProbAssoc  (theProblem),
      myStochImpOP_ (NULL),
      myScenario_   (NULL),
      myPer_        (-1)
   {
   }

//------------------------------------------------------------------------------

WitScenPer::WitScenPer (
         WitStochImpOP * theStochImpOP,
         WitScenario *   theScenario,
         WitPeriod       thePer):

      WitProbAssoc  (theStochImpOP),
      myStochImpOP_ (theStochImpOP),
      myScenario_   (theScenario),
      myPer_        (thePer)
   {
   }
 
//------------------------------------------------------------------------------

WitScenPer::~WitScenPer ()
   {
   }

//------------------------------------------------------------------------------
d396 1
d400 8
a407 3
   return
        theStochVar->myScenario ()->scenarioProb ()
      * theStochVar->stochCoeffVal ();
d414 1
a414 1
WitStochVar::WitStochVar (WitScenPer * theScenPer):
d416 2
a417 3
      WitOptVar   (theScenPer->myStochImpOP ()),
      myScenPer_  (theScenPer),
      myStochLoc_ (theStochLocFor (theScenPer))
d431 1
a431 1
   return myStochImpOP ();
d447 1
a447 19
   myStochImpOP ()->printPeriod   (myPer      ());
   myStochImpOP ()->printScenario (myScenario ());
   }

//------------------------------------------------------------------------------

WitStochLoc * WitStochVar::theStochLocFor (WitScenPer * theScenPer)
   {
   WitScenario * theScenario;
   WitPeriod     thePer;

   theScenario = theScenPer->myScenario ();
   thePer      = theScenPer->myPer ();

   return
      theScenPer->
         myStochImpOP ()->
            mySglScenSetFor (theScenario)->
               myStochLocFor (thePer);
d454 1
a454 1
WitStochCon::WitStochCon (WitScenPer * theScenPer):
d456 2
a457 3
      WitOptCon   (theScenPer->myStochImpOP ()),
      myScenPer_  (theScenPer),
      myStochLoc_ (theStochLocFor (theScenPer))
d471 1
a471 1
   return myScenPer_->myStochImpOP ();
d487 1
a487 19
   myStochImpOP ()->printPeriod   (myPer      ());
   myStochImpOP ()->printScenario (myScenario ());
   }

//------------------------------------------------------------------------------

WitStochLoc * WitStochCon::theStochLocFor (WitScenPer * theScenPer)
   {
   WitScenario * theScenario;
   WitPeriod     thePer;

   theScenario = theScenPer->myScenario ();
   thePer      = theScenPer->myPer ();

   return
      theScenPer->
         myStochImpOP ()->
            mySglScenSetFor (theScenario)->
               myStochLocFor (thePer);
@


1.19
log
@Stochastic Implosion
@
text
@d261 53
a326 63
void WitStochLoc::store (WitStScrapVar * theStScrapVar)
   {                     
   witAssert (theStScrapVar->myStochLoc () == this);

   myStScrapVarFor_ (theStScrapVar->myPart ()) = theStScrapVar;
   }

//------------------------------------------------------------------------------

void WitStochLoc::store (WitStStockVar * theStStockVar)
   {                     
   witAssert (theStStockVar->myStochLoc () == this);

   myStStockVarFor_ (theStStockVar->myMat ()) = theStStockVar;
   }

//------------------------------------------------------------------------------

void WitStochLoc::store (WitStExecVar * theStExecVar)
   {                     
   witAssert (theStExecVar->myStochLoc () == this);

   myStExecVarFor_ (theStExecVar->myOpn ()) = theStExecVar;
   }

//------------------------------------------------------------------------------

void WitStochLoc::store (WitStShipVar * theStShipVar)
   {                     
   witAssert (theStShipVar->myStochLoc () == this);

   myStShipVarFor_ (theStShipVar->myDemand ()) = theStShipVar;
   }

//------------------------------------------------------------------------------

void WitStochLoc::store (WitStCumShipVar * theStCumShipVar)
   {                     
   witAssert (theStCumShipVar->myStochLoc () == this);

   myStCumShipVarFor_ (theStCumShipVar->myDemand ()) = theStCumShipVar;
   }

//------------------------------------------------------------------------------

void WitStochLoc::store (WitStNonSubVar * theStNonSubVar)
   {                     
   witAssert (theStNonSubVar->myStochLoc () == this);

   myStNonSubVarFor_ (theStNonSubVar->myBomEnt ()) = theStNonSubVar;
   }

//------------------------------------------------------------------------------

void WitStochLoc::store (WitStSubVar * theStSubVar)
   {                     
   witAssert (theStSubVar->myStochLoc () == this);

   myStSubVarFor_ (theStSubVar->mySub ()) = theStSubVar;
   }

//------------------------------------------------------------------------------

@


1.18
log
@Stochastic Implosion
@
text
@d16 1
a16 1
//    The implementation of class ScenSetPer
d25 1
a25 1
#include <ScenSetPer.h>
d190 4
a193 4
      WitProbAssoc   (theStochImpOP),
      myStochImpOP_  (theStochImpOP),
      my1Scenario_   (NULL),
      myScenSetPers_ ()
d204 4
a207 4
      WitProbAssoc   (theStochImpOP),
      myStochImpOP_  (theStochImpOP),
      my1Scenario_   (theScenario),
      myScenSetPers_ ()
d219 1
a219 1
      delete myScenSetPers_[thePer];
d228 1
a228 1
   myScenSetPers_.allocate (myProblem ());
d231 1
a231 1
      myScenSetPers_[thePer] = new WitScenSetPer (this, thePer);
d235 1
a235 1
// Implementation of class ScenSetPer.
d238 1
a238 1
WitScenSetPer::WitScenSetPer (WitScenSet * theScenSet, WitPeriod thePer):
d255 1
a255 1
WitScenSetPer::~WitScenSetPer ()
d261 1
a261 1
void WitScenSetPer::clearStochVars ()
d274 1
a274 1
void WitScenSetPer::store (WitStScrapVar * theStScrapVar)
d276 1
a276 1
   witAssert (theStScrapVar->myScenSetPer () == this);
d283 1
a283 1
void WitScenSetPer::store (WitStStockVar * theStStockVar)
d285 1
a285 1
   witAssert (theStStockVar->myScenSetPer () == this);
d292 1
a292 1
void WitScenSetPer::store (WitStExecVar * theStExecVar)
d294 1
a294 1
   witAssert (theStExecVar->myScenSetPer () == this);
d301 1
a301 1
void WitScenSetPer::store (WitStShipVar * theStShipVar)
d303 1
a303 1
   witAssert (theStShipVar->myScenSetPer () == this);
d310 1
a310 1
void WitScenSetPer::store (WitStCumShipVar * theStCumShipVar)
d312 1
a312 1
   witAssert (theStCumShipVar->myScenSetPer () == this);
d319 1
a319 1
void WitScenSetPer::store (WitStNonSubVar * theStNonSubVar)
d321 1
a321 1
   witAssert (theStNonSubVar->myScenSetPer () == this);
d328 1
a328 1
void WitScenSetPer::store (WitStSubVar * theStSubVar)
d330 1
a330 1
   witAssert (theStSubVar->myScenSetPer () == this);
d337 1
a337 1
WitStScrapVar * WitScenSetPer::myStScrapVarFor (WitPart * thePart)
d344 1
a344 1
WitStStockVar * WitScenSetPer::myStStockVarFor (WitMaterial * theMat)
d351 1
a351 1
WitStExecVar * WitScenSetPer::myStExecVarFor (WitOperation * theOpn)
d358 1
a358 1
WitStShipVar * WitScenSetPer::myStShipVarFor (WitDemand * theDemand)
d365 1
a365 1
WitStCumShipVar * WitScenSetPer::myStCumShipVarFor (WitDemand * theDemand)
d372 1
a372 1
WitStNonSubVar * WitScenSetPer::myStNonSubVarFor (WitBomEntry * theBomEnt)
d379 1
a379 1
WitStSubVar * WitScenSetPer::myStSubVarFor (WitSubEntry * theSub)
d451 3
a453 3
      WitOptVar     (theScenPer->myStochImpOP ()),
      myScenPer_    (theScenPer),
      myScenSetPer_ (theScenSetPerFor (theScenPer))
d489 1
a489 1
WitScenSetPer * WitStochVar::theScenSetPerFor (WitScenPer * theScenPer)
d501 1
a501 1
               myScenSetPerFor (thePer);
d510 3
a512 3
      WitOptCon     (theScenPer->myStochImpOP ()),
      myScenPer_    (theScenPer),
      myScenSetPer_ (theScenSetPerFor (theScenPer))
d531 1
a531 1
WitScenSetPer * WitStochCon::myScenSetPerForPer (WitPeriod thePer)
d533 1
a533 1
   return myScenSetPer_->myScenSet ()->myScenSetPerFor (thePer);
d548 1
a548 1
WitScenSetPer * WitStochCon::theScenSetPerFor (WitScenPer * theScenPer)
d560 1
a560 1
               myScenSetPerFor (thePer);
@


1.17
log
@Stochastic Implosion
@
text
@a17 2
//    The implementation of class template StOptElMgr <DerComp, StOptEl>
//    The explicit instantiation of        StOptElMgr <DerComp, StOptEl>
a26 1
#include <StOptElMgr.h>
d240 16
a255 3
      WitProbAssoc (theScenSet),
      myScenSet_   (theScenSet),
      myPer_       (thePer)
d261 1
a261 1
WitScenSetPer::~WitScenSetPer ()
d263 16
d282 8
a289 1
// Implementation of class ScenPer.
d292 3
a294 1
WitScenPer::WitScenPer (WitProblem * theProblem):
d296 1
a296 5
      WitProbAssoc  (theProblem),
      myStochImpOP_ (NULL),
      myScenario_   (NULL),
      myPer_        (-1)
   {
d301 3
a303 4
WitScenPer::WitScenPer (
         WitStochImpOP * theStochImpOP,
         WitScenario *   theScenario,
         WitPeriod       thePer):
d305 1
a305 5
      WitProbAssoc  (theStochImpOP),
      myStochImpOP_ (theStochImpOP),
      myScenario_   (theScenario),
      myPer_        (thePer)
   {
d307 1
a307 1
 
d310 5
a314 2
WitScenPer::~WitScenPer ()
   {
d318 8
a325 1
// Implementation of class template StOptElMgr <DerComp, StOptEl>.
d328 3
a330 3
template <typename DerComp, typename StOptEl> 
         WitStOptElMgr <DerComp, StOptEl>::WitStOptElMgr (
            WitStochImpOP * theStochImpOP):
d332 6
a337 3
      WitProbAssoc  (theStochImpOP),
      myStochImpOP_ (theStochImpOP),
      mySched_      (myProblem ())
d339 1
d344 1
a344 2
template <typename DerComp, typename StOptEl> 
         WitStOptElMgr <DerComp, StOptEl>::~WitStOptElMgr ()
d346 4
a349 2
   int       theIdx;
   WitPeriod thePer;
d351 3
a353 3
   for (theIdx = 0; theIdx < mySched_.domainSize (); theIdx ++)
      forEachPeriod (thePer, myProblem ())
         delete mySched_.myPtrTVecAt (theIdx)[thePer];
d358 1
a358 5
template <typename DerComp, typename StOptEl> 
      void WitStOptElMgr <DerComp, StOptEl>::createMyElFor (
         DerComp *     theDerComp,
         WitPeriod     thePer,
         WitScenario * theScenario)
d360 4
a363 2
   WitScenPer * theScenPer;
   StOptEl *    theStOptEl;
d365 4
a368 1
   theScenPer = myStochImpOP_->myScenPerSched ().myPtrAt (theScenario, thePer);
d370 1
a370 1
   theStOptEl = new StOptEl (theDerComp, theScenPer);
d372 4
a375 3
   if (mySched_.myPtrAt (theDerComp, thePer) == NULL)
       mySched_.myPtrAt (theDerComp, thePer) =
         new WitPtrMap <WitScenario, StOptEl> (myProblem ());
d377 1
a377 1
   witAssert (mySched_.myElemAt (theDerComp, thePer) (theScenario) == NULL);
d379 3
a381 1
   mySched_.myElemAt (theDerComp, thePer) (theScenario) = theStOptEl;
d385 4
d390 4
a393 5
template <typename DerComp, typename StOptEl> 
      StOptEl * WitStOptElMgr <DerComp, StOptEl>::myElFor (
         DerComp *     theDerComp,
         WitPeriod     thePer,
         WitScenario * theScenario)
a394 4
   if (      mySched_.myPtrAt  (theDerComp, thePer) != NULL)
      return mySched_.myElemAt (theDerComp, thePer) (theScenario);
   else
      return NULL;
d398 13
a410 1
// Explicit instantiation of class template StOptElMgr <DerComp, StOptEl>.
d413 3
a415 10
template class WitStOptElMgr <WitPart,      WitStScrapVar>;
template class WitStOptElMgr <WitMaterial,  WitStStockVar>;
template class WitStOptElMgr <WitOperation, WitStExecVar>;
template class WitStOptElMgr <WitDemand,    WitStShipVar>;
template class WitStOptElMgr <WitDemand,    WitStCumShipVar>;
template class WitStOptElMgr <WitBomEntry,  WitStNonSubVar>;
template class WitStOptElMgr <WitSubEntry,  WitStSubVar>;
template class WitStOptElMgr <WitPart,      WitStResCon>;
template class WitStOptElMgr <WitDemand,    WitStShipCon>;
template class WitStOptElMgr <WitBomEntry,  WitStSubCon>;
d449 1
a449 1
WitStochVar::WitStochVar (WitScenPer *  theScenPer):
d451 3
a453 2
      WitOptVar  (theScenPer->myStochImpOP ()),
      myScenPer_ (theScenPer)
d488 17
d510 3
a512 2
      WitOptCon  (theScenPer->myStochImpOP ()),
      myScenPer_ (theScenPer)
d531 7
d545 17
@


1.16
log
@Stochastic Implosion
@
text
@d16 1
d27 1
d193 4
a196 3
      WitProbAssoc  (theStochImpOP),
      myStochImpOP_ (theStochImpOP),
      my1Scenario_  (NULL)
d198 1
d207 4
a210 3
      WitProbAssoc  (theStochImpOP),
      myStochImpOP_ (theStochImpOP),
      my1Scenario_  (theScenario)
d212 1
d219 34
@


1.15
log
@Stochastic Implosion
@
text
@d15 1
d25 1
d78 1
a78 1
   myStochImpOP ()->solve ();
d120 1
a120 1
   myStochImpOP ()->generateFixed ();
d122 1
a122 1
   myStochImpOP ()->generateFlexible ();
d151 1
a151 1
   theStochObjVal = myStochImpOP ()->myStochObj ()->myValue ();
d179 1
a179 1
   forEachEl (theOptVar, myStochImpOP ()->myOptVars ())
d186 30
@


1.14
log
@Stochastic Implosion
@
text
@a92 2
   myMsgFac () ("stochSingleLPMsg");

@


1.13
log
@Stochastic Implosion
@
text
@d42 2
a100 2
   verifyData     ();

a113 8
void WitStochOptMgr::verifyData ()
   {
   if (myCompMgr ()->nSubEntries () > 0)
      myMsgFac () ("singleStochLPwObjectNyiSmsg", "substitute BOM entries");
   }

//------------------------------------------------------------------------------

d292 2
d296 1
@


1.12
log
@Stochastic Implosion
@
text
@d322 7
a328 1
   return theVar->mandStochVar ()->stochCoeffVal ();
@


1.11
log
@Stochastic Implosion
@
text
@d39 1
a39 1
#include <Part.h>
a117 3

   if (myCompMgr ()->nMaterials () > 0)
      myMsgFac () ("singleStochLPwObjectNyiSmsg", "material parts");
d296 1
@


1.10
log
@Stochastic Implosion
@
text
@d41 1
a115 3
   if (myCompMgr ()->nDemands () > 0)
      myMsgFac () ("singleStochLPwObjectNyiSmsg", "demands");

d300 2
d303 1
@


1.9
log
@Stochastic Implosion
@
text
@a117 3
   if (myCompMgr ()->nBopEntries () > 0)
      myMsgFac () ("singleStochLPwObjectNyiSmsg", "BOP entries");

@


1.8
log
@Stochastic Implosion
@
text
@d36 1
a150 2
   myMsgFac () ("singleStochLPNyiSmsg", 20);

d154 4
a197 2
   myMsgFac () ("singleStochLPNyiSmsg", 23);

@


1.7
log
@Stochastic Implosion
@
text
@d185 1
d192 4
a195 1
   myMsgFac () ("singleStochLPNyiSmsg", 22);
@


1.6
log
@Stochastic Implosion
@
text
@d319 1
a319 1
double WitStochObj::coeffVal (WitOptVar * theVar) const
@


1.5
log
@Stochastic Implosion
@
text
@d319 1
a319 1
double WitStochObj::coeffVal (const WitOptVar * theVar) const
d343 1
a343 1
WitOptProb * WitStochVar::myOptProb () const
d350 1
a350 1
const WitStochVar * WitStochVar::mandStochVar () const
d357 1
a357 1
void WitStochVar::printSource () const
d384 1
a384 1
WitOptProb * WitStochCon::myOptProb () const
d391 1
a391 1
void WitStochCon::printSource () const
@


1.4
log
@Stochastic Implosion
@
text
@d321 1
a321 1
   return theVar->stochCoeffVal ();
d350 7
@


1.3
log
@Stochastic Implosion
@
text
@d148 2
d181 16
@


1.2
log
@Stochastic Implosion
@
text
@d148 1
a148 1
   myMsgFac () ("singleStochLPNyiSmsg", 18);
d174 2
@


1.1
log
@Stochastic Implosion
@
text
@d146 1
a146 1
   uploadSoln ();
d148 1
a148 1
   myMsgFac () ("singleStochLPNyiSmsg", 12);
d157 1
a157 1
void WitStochOptMgr::uploadSoln ()
d159 8
d169 3
a171 1
   myMsgFac () ("singleStochLPNyiSmsg", 13);
@


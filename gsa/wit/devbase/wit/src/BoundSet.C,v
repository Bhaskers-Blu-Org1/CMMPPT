head	1.55;
access;
symbols
	sce_5_01_20080919:1.50
	latest_sce_4_20_20060523:1.21.0.2
	sce_4_20_20060523:1.21
	latest_sce4_20_OSL:1.20.0.2
	sce_4_20_OSL:1.20
	sce_410_withVa:1.20
	sce_4_05_20040511:1.20
	sce_4_00_20040201:1.11
	nextGenBranch:1.10.0.2
	nextGenRoot:1.10
	sce_3_30_20030627:1.10
	EndRw-branch:1.7.0.4
	Root-of-EndRw:1.7
	rwToStl:1.7.0.2
	latest_sce_3_10_20010924:1.3.0.8
	sce_3_10_20010924:1.3
	latest_sce_3_00_20010601:1.3.0.6
	sce_3_00_20010601:1.3
	latest_sce_2_31_20010308:1.3.0.4
	sce_2_31_20010308:1.3
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.55
date	2011.09.28.23.49.06;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2011.09.24.00.27.24;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2011.08.30.20.17.19;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.10.22.10.37;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.25.00.10.46;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.02.17.48.36;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2008.01.28.23.53.36;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.18.22.40.58;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.07.23.51.48;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.04.20.25.27;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.06.22.53.00;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.06.22.01.21;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.05.22.13.08;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.03.19.41.33;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.29.21.12.31;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.29.16.24.42;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.29.15.35.01;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.28.23.23.44;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.28.20.34.27;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.27.22.24.42;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.27.21.05.00;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.22.19.58.51;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.18.23.14.43;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.11.19.16.56;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.02.18.32.42;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.01.20.44.54;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.01.19.52.16;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.28.23.32.57;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.28.22.08.25;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.10.14.44.06;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.01.22.41.56;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.25.19.56.53;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2006.09.21.15.42.25;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.02.17.33.55;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.20.18.25.21;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.13.21.50.12;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.26.22.29.41;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.24.22.21.28;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.23.19.14.23;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.10.22.53.18;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.04.19.53.25;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.04.16.31.45;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.03.20.05.06;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.25.23.49.54;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.13.23.06.25;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.02.23.40.36;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.02.22.18.20;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.11.18.53.05;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.23.18.09.10;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.08.19.21.47;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.18.14.02.27;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.19;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.23;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "BoundSet.C"
//
// Contains the implementation of the following classes:
//
//    BoundSet
//    StockBoundSet
//    CumShipBoundSet
//    ExecBoundSet
//------------------------------------------------------------------------------

#include <StockBS.h>
#include <CShipBS.h>
#include <ExecBS.h>
#include <Material.h>
#include <Demand.h>
#include <Operation.h>
#include <OptComp.h>
#include <DetOptImpMgr.h>
#include <StochImpMgr.h>
#include <DataWrit.h>
#include <Pre.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class BoundSet
//------------------------------------------------------------------------------

WitBoundSet::WitBoundSet (WitProblem * theProblem):
      WitProbAssoc  (theProblem),

      mappingIndex_ (myCompMgr ()->nBoundSets ()),
      hardLB_       (myProblem (), defHardLB ()),
      softLB_       (myProblem (), defSoftLB ()),
      hardUB_       (myProblem (), defHardUB ())
   {
   }

//------------------------------------------------------------------------------

WitBoundSet::~WitBoundSet ()
   {
   }

//------------------------------------------------------------------------------

int WitBoundSet::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nBoundSets ();
   }

//------------------------------------------------------------------------------

bool WitBoundSet::isAtDefault ()
   {
   if (hardLB_ == defHardLB ())
      if (softLB_ == defSoftLB ())
         if (hardUB_ == defHardUB ())
            return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitBoundSet::hardUBIsFinite (WitPeriod thePer)
   {
   return (hardUB_[thePer] >= 0.0);
   }

//------------------------------------------------------------------------------

bool WitBoundSet::hardUBisSatisfied (WitPeriod thePer, double theValue) 
   {
   return
      hardUBIsFinite (thePer)?
         (theValue <= hardUB_[thePer]):
         true;
   }

//------------------------------------------------------------------------------

void WitBoundSet::set (
      const WitDblFlexVec & hardLBArg,
      const WitDblFlexVec & softLBArg,
      const WitDblFlexVec & hardUBArg)
   {
   WitPeriod thePer;

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         witAssert (not seqError (hardLBArg, softLBArg, hardUBArg, thePer));

   if (myStochImpMgr ()->stochMode ())
      myStochImpMgr ()->prepSetBoundSet (this);

   myProblem ()->resetSoln ();

   if (unaccNeeded (hardLBArg, softLBArg))
      myDetOptImpMgr ()->shutDown ();

   hardLB_ = hardLBArg;
   softLB_ = softLBArg;
   hardUB_ = hardUBArg;
   }

//------------------------------------------------------------------------------

void WitBoundSet::storeStochHardLB (const WitDblFlexVec & theValue)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   hardLB_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBoundSet::storeStochSoftLB (const WitDblFlexVec & theValue)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   softLB_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBoundSet::storeStochHardUB (const WitDblFlexVec & theValue)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   hardUB_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBoundSet::copyAttrsFrom (WitBoundSet * theBoundSet)
   {
   hardLB_ = theBoundSet->hardLB_;
   softLB_ = theBoundSet->softLB_;
   hardUB_ = theBoundSet->hardUB_;
   }

//------------------------------------------------------------------------------

bool WitBoundSet::seqError (
      const WitDblFlexVec & hardLBArg,
      const WitDblFlexVec & softLBArg,
      const WitDblFlexVec & hardUBArg,
      WitPeriod             thePer)
   {
   if (hardLBArg[thePer] < 0.0)
      return true;

   if (hardLBArg[thePer] > softLBArg[thePer])
      return true;

   if (hardUBArg[thePer] >= 0.0)
      if (softLBArg[thePer] > hardUBArg[thePer])
         return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitBoundSet::hasPositiveHardLB ()
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      if (hardLB_[thePer] > 0.0)
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitBoundSet::writeData ()
   {
   if (isAtDefault ())
      return;

   if (myStochImpMgr ()->stochMode ())
      return;

   myDataWriter ()->writeFirstKeyWord (myAttName ());

   myDataWriter ()->writeVector ("hardLB", hardLB_, defHardLB ());
   myDataWriter ()->writeVector ("softLB", softLB_, defSoftLB ());
   myDataWriter ()->writeVector ("hardUB", hardUB_, defHardUB ());

   myDataWriter ()->writeFirstKeyWord ("endBounds");
   }

//------------------------------------------------------------------------------

void WitBoundSet::writeSetClause ()
   {
   myDelComp ()->writeSetClause ();

   myDataWriter ()->writeFirstKeyWord (myAttName ());
   }

//------------------------------------------------------------------------------

void WitBoundSet::display ()
   {
   if (isAtDefault ())
      return;

   myMsgFac () (headingMsgID ());

   myMsgFac () ("boundHeadingDdMsg", mappingIndex_);

   myProblem ()->displayBoundVec ("hardLBFrag", hardLB_);
   myProblem ()->displayBoundVec ("softLBFrag", softLB_);
   myProblem ()->displayBoundVec ("hardUBFrag", hardUB_);
   }

//------------------------------------------------------------------------------

void WitBoundSet::writeSoln ()
   {
   if (isAtDefault ())
      return;

   WitPeriod thePer;

   fprintf (solnFile (),
      "\n\nSolution for bounds on the %s of ", boundedVectorName ());

   idObjectForSoln ();

   fprintf (solnFile (),
      "\n%6s  %11s  %11s  %11s  %11s  %11s  %11s  %11s\n",
      "Period", boundedVectorName (),
      "Hard LB", "Soft LB", "Hard UB",
      "Hard LB", "Soft LB", "Hard UB");

   fprintf (solnFile (),
      "%6s  %11s  %11s  %11s  %11s  %11s  %11s  %11s\n",
      "", "", "", "", "", "Violation", "Violation", "Violation");

   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d", thePer);

      writeSolnValue (boundedVal (thePer));

      writeSolnValue (hardLB_[thePer]);
      writeSolnValue (softLB_[thePer]);

      if (hardUBIsFinite (thePer))
         writeSolnValue (hardUB_[thePer]);
      else
         fprintf (solnFile (), "    +Infinity");

      writeSolnValue (positivePart (hardLB_[thePer] - boundedVal (thePer)));

      writeSolnValue (positivePart (softLB_[thePer] - boundedVal (thePer)));

      writeSolnValue (
         hardUBIsFinite (thePer)?
            positivePart (boundedVal (thePer) - hardUB_[thePer]):
            0.0);

      fprintf (solnFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

void WitBoundSet::reindex ()
   {
   witAssert (myCompMgr ()->isReindexing (this));

   mappingIndex_ = myCompMgr ()->nBoundSets ();
   }

//------------------------------------------------------------------------------

bool WitBoundSet::unaccNeeded (
      const WitDblFlexVec & hardLBArg,
      const WitDblFlexVec & softLBArg)
   {
   WitPeriod thePer;

   if (not myDetOptImpMgr ()->accelerated ())
      return false;

   if (myOptComp ()->accAfterSoftLB ())
      return false;

   forEachPeriod (thePer, myProblem ())
      if (softLB_[thePer] == hardLB_[thePer])
         if (softLBArg[thePer] > hardLBArg[thePer])
            return true;

   return false;
   }

//------------------------------------------------------------------------------
// Implementation of class StockBoundSet.
//------------------------------------------------------------------------------

WitStockBoundSet::WitStockBoundSet (WitMaterial * theMat):
      WitBoundSet (theMat->myProblem ()),
      myMaterial_ (theMat)
   {
   }

//------------------------------------------------------------------------------

WitStockBoundSet::~WitStockBoundSet ()
   {
   }

//------------------------------------------------------------------------------

double WitStockBoundSet::boundedVal (WitPeriod thePer)
   {
   return myMaterial_->stockVol ()[thePer];
   }

//------------------------------------------------------------------------------

const char * WitStockBoundSet::myAttName ()
   {
   return "stockBounds";
   }

//------------------------------------------------------------------------------

WitDelComp * WitStockBoundSet::myDelComp ()
   {
   return myMaterial_;
   }

//------------------------------------------------------------------------------

WitBoundSet * WitStockBoundSet::myMatchIn (WitCompMgr * theCompMgr)
   {
   WitPart *     thePart;
   WitMaterial * theMat;

   thePart = theCompMgr->myMatchFor (myMaterial_);

   theMat  = thePart   ->thisMat  ();

   witAssert (theMat != NULL);

   return theMat->stockBounds ();
   }

//------------------------------------------------------------------------------

WitNode * WitStockBoundSet::stageNode ()
   {
   return myMaterial_;
   }

//------------------------------------------------------------------------------

void WitStockBoundSet::issueStage0MMCompMsg ()
   {
   myMsgFac () ("stage0AttMisMatchPartSmsg", myMaterial_->partName ());
   }

//------------------------------------------------------------------------------

WitMsgID WitStockBoundSet::headingMsgID ()
   {
   return "stockBoundsHeadingDdMsg";
   }

//------------------------------------------------------------------------------

const char * WitStockBoundSet::boundedVectorName ()
   {
   return "StockVol";
   }

//------------------------------------------------------------------------------

void WitStockBoundSet::idObjectForSoln ()
   {
   fprintf (myProblem ()->solnFile (),
      "material part \"%s\":\n",
      myMaterial_->partName ().myCstring ());
   }

//------------------------------------------------------------------------------
// Implementation of class CumShipBoundSet.
//------------------------------------------------------------------------------

WitCumShipBoundSet::WitCumShipBoundSet (WitDemand * theDemand):

      WitBoundSet (theDemand->myProblem ()),
      myDemand_   (theDemand)
   {
   }

//------------------------------------------------------------------------------

WitCumShipBoundSet::~WitCumShipBoundSet ()
   {
   }

//------------------------------------------------------------------------------

double WitCumShipBoundSet::boundedVal (WitPeriod thePer)
   {
   return myDemand_->cumShipVol ()[thePer];
   }

//------------------------------------------------------------------------------

const char * WitCumShipBoundSet::myAttName ()
   {
   return "cumShipBounds";
   }

//------------------------------------------------------------------------------

WitDelComp * WitCumShipBoundSet::myDelComp ()
   {
   return myDemand_;
   }

//------------------------------------------------------------------------------

WitBoundSet * WitCumShipBoundSet::myMatchIn (WitCompMgr * theCompMgr)
   {
   WitDemand * theDemand;

   theDemand = theCompMgr->myMatchFor (myDemand_);

   return theDemand->cumShipBounds ();
   }

//------------------------------------------------------------------------------

WitNode * WitCumShipBoundSet::stageNode ()
   {
   return myDemand_->demandedPart ();
   }

//------------------------------------------------------------------------------

void WitCumShipBoundSet::issueStage0MMCompMsg ()
   {
   myMsgFac () ("stage0AttMisMatchDemandSmsg",
      myDemand_->demandedPartName (),
      myDemand_->demandName       ());
   }

//------------------------------------------------------------------------------

WitMsgID WitCumShipBoundSet::headingMsgID ()
   {
   return "cumShipBoundsHeadingDdMsg";
   }

//------------------------------------------------------------------------------

const char * WitCumShipBoundSet::boundedVectorName ()
   {
   return "CumShipVol";
   }

//------------------------------------------------------------------------------

void WitCumShipBoundSet::idObjectForSoln ()
   {
   fprintf (myProblem ()->solnFile (),
      "demand \"%s\" for part \"%s\":\n",
      myDemand_->demandName ().myCstring (),
      myDemand_->demandedPartName ().myCstring ());
   }

//------------------------------------------------------------------------------
// Implementation of class ExecBoundSet.
//------------------------------------------------------------------------------

WitExecBoundSet::WitExecBoundSet (WitOperation * theOpn):
      WitBoundSet  (theOpn->myProblem ()),

      myOperation_ (theOpn)
   {
   }

//------------------------------------------------------------------------------

WitExecBoundSet::~WitExecBoundSet ()
   {
   }

//------------------------------------------------------------------------------

double WitExecBoundSet::boundedVal (WitPeriod thePer)
   {
   return myOperation_->execVol ()[thePer];
   }

//------------------------------------------------------------------------------

const char * WitExecBoundSet::myAttName ()
   {
   return "execBounds";
   }

//------------------------------------------------------------------------------

WitDelComp * WitExecBoundSet::myDelComp ()
   {
   return myOperation_;
   }

//------------------------------------------------------------------------------

WitBoundSet * WitExecBoundSet::myMatchIn (WitCompMgr * theCompMgr)
   {
   WitOperation * theOpn;

   theOpn = theCompMgr->myMatchFor (myOperation_);

   return theOpn->execBounds ();
   }

//------------------------------------------------------------------------------

WitNode * WitExecBoundSet::stageNode ()
   {
   return myOperation_;
   }

//------------------------------------------------------------------------------

void WitExecBoundSet::issueStage0MMCompMsg ()
   {
   myMsgFac () ("stage0AttMisMatchOpnSmsg", myOperation_->operationName ());
   }

//------------------------------------------------------------------------------

WitMsgID WitExecBoundSet::headingMsgID ()
   {
   return "execBoundsHeadingDdMsg";
   }

//------------------------------------------------------------------------------

const char * WitExecBoundSet::boundedVectorName ()
   {
   return "ExecVol";
   }

//------------------------------------------------------------------------------

void WitExecBoundSet::idObjectForSoln ()
   {
   fprintf (myProblem ()->solnFile (),
      "operation \"%s\":\n",
      myOperation_->operationName ().myCstring ());
   }
@


1.54
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.53
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d39 1
a39 1
WitProbAssoc  (theProblem),
d41 6
a46 6
mappingIndex_ (myCompMgr ()->nBoundSets ()),
hardLB_       (myProblem (), defHardLB ()),
softLB_       (myProblem (), defSoftLB ()),
hardUB_       (myProblem (), defHardUB ())
{
}
d51 2
a52 2
{
}
d57 3
a59 3
{
return theProblem->myCompMgr ()->nBoundSets ();
}
d64 5
a68 5
{
if (hardLB_ == defHardLB ())
if (softLB_ == defSoftLB ())
if (hardUB_ == defHardUB ())
return true;
d70 2
a71 2
return false;
}
d76 3
a78 3
{
return (hardUB_[thePer] >= 0.0);
}
d82 7
a88 7
bool WitBoundSet::hardUBisSatisfied (WitPeriod thePer, double theValue)
{
return
hardUBIsFinite (thePer)?
(theValue <= hardUB_[thePer]):
true;
}
d93 22
a114 22
const WitDblFlexVec & hardLBArg,
const WitDblFlexVec & softLBArg,
const WitDblFlexVec & hardUBArg)
{
WitPeriod thePer;

if (DEBUG_MODE)
forEachPeriod (thePer, myProblem ())
witAssert (not seqError (hardLBArg, softLBArg, hardUBArg, thePer));

if (myStochImpMgr ()->stochMode ())
myStochImpMgr ()->prepSetBoundSet (this);

myProblem ()->resetSoln ();

if (unaccNeeded (hardLBArg, softLBArg))
myDetOptImpMgr ()->shutDown ();

hardLB_ = hardLBArg;
softLB_ = softLBArg;
hardUB_ = hardUBArg;
}
d119 2
a120 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d122 2
a123 2
hardLB_ = theValue;
}
d128 2
a129 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d131 2
a132 2
softLB_ = theValue;
}
d137 2
a138 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d140 2
a141 2
hardUB_ = theValue;
}
d146 5
a150 5
{
hardLB_ = theBoundSet->hardLB_;
softLB_ = theBoundSet->softLB_;
hardUB_ = theBoundSet->hardUB_;
}
d155 14
a168 14
const WitDblFlexVec & hardLBArg,
const WitDblFlexVec & softLBArg,
const WitDblFlexVec & hardUBArg,
WitPeriod             thePer)
{
if (hardLBArg[thePer] < 0.0)
return true;

if (hardLBArg[thePer] > softLBArg[thePer])
return true;

if (hardUBArg[thePer] >= 0.0)
if (softLBArg[thePer] > hardUBArg[thePer])
return true;
d170 2
a171 2
return false;
}
d176 2
a177 2
{
WitPeriod thePer;
d179 3
a181 3
forEachPeriod (thePer, myProblem ())
if (hardLB_[thePer] > 0.0)
return true;
d183 2
a184 2
return false;
}
d189 3
a191 3
{
if (isAtDefault ())
return;
d193 2
a194 2
if (myStochImpMgr ()->stochMode ())
return;
d196 1
a196 1
myDataWriter ()->writeFirstKeyWord (myAttName ());
d198 3
a200 3
myDataWriter ()->writeVector ("hardLB", hardLB_, defHardLB ());
myDataWriter ()->writeVector ("softLB", softLB_, defSoftLB ());
myDataWriter ()->writeVector ("hardUB", hardUB_, defHardUB ());
d202 2
a203 2
myDataWriter ()->writeFirstKeyWord ("endBounds");
}
d208 2
a209 2
{
myDelComp ()->writeSetClause ();
d211 2
a212 2
myDataWriter ()->writeFirstKeyWord (myAttName ());
}
d217 12
a228 12
{
if (isAtDefault ())
return;

myMsgFac () (headingMsgID ());

myMsgFac () ("boundHeadingDdMsg", mappingIndex_);

myProblem ()->displayBoundVec ("hardLBFrag", hardLB_);
myProblem ()->displayBoundVec ("softLBFrag", softLB_);
myProblem ()->displayBoundVec ("hardUBFrag", hardUB_);
}
d233 3
a235 3
{
if (isAtDefault ())
return;
d237 1
a237 1
WitPeriod thePer;
d239 2
a240 2
fprintf (solnFile (),
"\n\nSolution for bounds on the %s of ", boundedVectorName ());
d242 1
a242 1
idObjectForSoln ();
d244 5
a248 5
fprintf (solnFile (),
"\n%6s  %11s  %11s  %11s  %11s  %11s  %11s  %11s\n",
"Period", boundedVectorName (),
"Hard LB", "Soft LB", "Hard UB",
"Hard LB", "Soft LB", "Hard UB");
d250 3
a252 3
fprintf (solnFile (),
"%6s  %11s  %11s  %11s  %11s  %11s  %11s  %11s\n",
"", "", "", "", "", "Violation", "Violation", "Violation");
d254 3
a256 3
forEachPeriod (thePer, myProblem ())
{
fprintf (solnFile (), "%6d", thePer);
d258 1
a258 1
writeSolnValue (boundedVal (thePer));
d260 2
a261 2
writeSolnValue (hardLB_[thePer]);
writeSolnValue (softLB_[thePer]);
d263 4
a266 4
if (hardUBIsFinite (thePer))
writeSolnValue (hardUB_[thePer]);
else
fprintf (solnFile (), "    +Infinity");
d268 1
a268 1
writeSolnValue (positivePart (hardLB_[thePer] - boundedVal (thePer)));
d270 1
a270 1
writeSolnValue (positivePart (softLB_[thePer] - boundedVal (thePer)));
d272 4
a275 4
writeSolnValue (
hardUBIsFinite (thePer)?
positivePart (boundedVal (thePer) - hardUB_[thePer]):
0.0);
d277 3
a279 3
fprintf (solnFile (), "\n");
}
}
d284 2
a285 2
{
witAssert (myCompMgr ()->isReindexing (this));
d287 2
a288 2
mappingIndex_ = myCompMgr ()->nBoundSets ();
}
d293 15
a307 15
const WitDblFlexVec & hardLBArg,
const WitDblFlexVec & softLBArg)
{
WitPeriod thePer;

if (not myDetOptImpMgr ()->accelerated ())
return false;

if (myOptComp ()->accAfterSoftLB ())
return false;

forEachPeriod (thePer, myProblem ())
if (softLB_[thePer] == hardLB_[thePer])
if (softLBArg[thePer] > hardLBArg[thePer])
return true;
d309 2
a310 2
return false;
}
d317 4
a320 4
WitBoundSet (theMat->myProblem ()),
myMaterial_ (theMat)
{
}
d325 2
a326 2
{
}
d331 3
a333 3
{
return myMaterial_->stockVol ()[thePer];
}
d338 3
a340 3
{
return "stockBounds";
}
d345 3
a347 3
{
return myMaterial_;
}
d352 3
a354 3
{
WitPart *     thePart;
WitMaterial * theMat;
d356 1
a356 1
thePart = theCompMgr->myMatchFor (myMaterial_);
d358 1
a358 1
theMat  = thePart   ->thisMat  ();
d360 1
a360 1
witAssert (theMat != NULL);
d362 2
a363 2
return theMat->stockBounds ();
}
d368 3
a370 3
{
return myMaterial_;
}
d375 3
a377 3
{
myMsgFac () ("stage0AttMisMatchPartSmsg", myMaterial_->partName ());
}
d382 3
a384 3
{
return "stockBoundsHeadingDdMsg";
}
d389 3
a391 3
{
return "StockVol";
}
d396 5
a400 5
{
fprintf (myProblem ()->solnFile (),
"material part \"%s\":\n",
myMaterial_->partName ().myCstring ());
}
d408 4
a411 4
WitBoundSet (theDemand->myProblem ()),
myDemand_   (theDemand)
{
}
d416 2
a417 2
{
}
d422 3
a424 3
{
return myDemand_->cumShipVol ()[thePer];
}
d429 3
a431 3
{
return "cumShipBounds";
}
d436 3
a438 3
{
return myDemand_;
}
d443 2
a444 2
{
WitDemand * theDemand;
d446 1
a446 1
theDemand = theCompMgr->myMatchFor (myDemand_);
d448 2
a449 2
return theDemand->cumShipBounds ();
}
d454 3
a456 3
{
return myDemand_->demandedPart ();
}
d461 5
a465 5
{
myMsgFac () ("stage0AttMisMatchDemandSmsg",
myDemand_->demandedPartName (),
myDemand_->demandName       ());
}
d470 3
a472 3
{
return "cumShipBoundsHeadingDdMsg";
}
d477 3
a479 3
{
return "CumShipVol";
}
d484 6
a489 6
{
fprintf (myProblem ()->solnFile (),
"demand \"%s\" for part \"%s\":\n",
myDemand_->demandName ().myCstring (),
myDemand_->demandedPartName ().myCstring ());
}
d496 1
a496 1
WitBoundSet  (theOpn->myProblem ()),
d498 3
a500 3
myOperation_ (theOpn)
{
}
d505 2
a506 2
{
}
d511 3
a513 3
{
return myOperation_->execVol ()[thePer];
}
d518 3
a520 3
{
return "execBounds";
}
d525 3
a527 3
{
return myOperation_;
}
d532 2
a533 2
{
WitOperation * theOpn;
d535 1
a535 1
theOpn = theCompMgr->myMatchFor (myOperation_);
d537 2
a538 2
return theOpn->execBounds ();
}
d543 3
a545 3
{
return myOperation_;
}
d550 3
a552 3
{
myMsgFac () ("stage0AttMisMatchOpnSmsg", myOperation_->operationName ());
}
d557 3
a559 3
{
return "execBoundsHeadingDdMsg";
}
d564 3
a566 3
{
return "ExecVol";
}
d571 5
a575 5
{
fprintf (myProblem ()->solnFile (),
"operation \"%s\":\n",
myOperation_->operationName ().myCstring ());
}
@


1.52
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d39 1
a39 1
      WitProbAssoc  (theProblem),
d41 6
a46 6
      mappingIndex_ (myCompMgr ()->nBoundSets ()),
      hardLB_       (myProblem (), defHardLB ()),
      softLB_       (myProblem (), defSoftLB ()),
      hardUB_       (myProblem (), defHardUB ())
   {
   }
d51 2
a52 2
   {
   }
d57 3
a59 3
   {
   return theProblem->myCompMgr ()->nBoundSets ();
   }
d64 5
a68 5
   {
   if (hardLB_ == defHardLB ())
      if (softLB_ == defSoftLB ())
         if (hardUB_ == defHardUB ())
            return true;
d70 2
a71 2
   return false;
   }
d76 3
a78 3
   {
   return (hardUB_[thePer] >= 0.0);
   }
d82 7
a88 7
bool WitBoundSet::hardUBisSatisfied (WitPeriod thePer, double theValue) 
   {
   return
      hardUBIsFinite (thePer)?
         (theValue <= hardUB_[thePer]):
         true;
   }
d93 22
a114 22
      const WitDblFlexVec & hardLBArg,
      const WitDblFlexVec & softLBArg,
      const WitDblFlexVec & hardUBArg)
   {
   WitPeriod thePer;

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         witAssert (not seqError (hardLBArg, softLBArg, hardUBArg, thePer));

   if (myStochImpMgr ()->stochMode ())
      myStochImpMgr ()->prepSetBoundSet (this);

   myProblem ()->resetSoln ();

   if (unaccNeeded (hardLBArg, softLBArg))
      myDetOptImpMgr ()->shutDown ();

   hardLB_ = hardLBArg;
   softLB_ = softLBArg;
   hardUB_ = hardUBArg;
   }
d119 2
a120 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d122 2
a123 2
   hardLB_ = theValue;
   }
d128 2
a129 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d131 2
a132 2
   softLB_ = theValue;
   }
d137 2
a138 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d140 2
a141 2
   hardUB_ = theValue;
   }
d146 5
a150 5
   {
   hardLB_ = theBoundSet->hardLB_;
   softLB_ = theBoundSet->softLB_;
   hardUB_ = theBoundSet->hardUB_;
   }
d155 14
a168 14
      const WitDblFlexVec & hardLBArg,
      const WitDblFlexVec & softLBArg,
      const WitDblFlexVec & hardUBArg,
      WitPeriod             thePer)
   {
   if (hardLBArg[thePer] < 0.0)
      return true;

   if (hardLBArg[thePer] > softLBArg[thePer])
      return true;

   if (hardUBArg[thePer] >= 0.0)
      if (softLBArg[thePer] > hardUBArg[thePer])
         return true;
d170 2
a171 2
   return false;
   }
d176 2
a177 2
   {
   WitPeriod thePer;
d179 3
a181 3
   forEachPeriod (thePer, myProblem ())
      if (hardLB_[thePer] > 0.0)
         return true;
d183 2
a184 2
   return false;
   }
d189 3
a191 3
   {
   if (isAtDefault ())
      return;
d193 2
a194 2
   if (myStochImpMgr ()->stochMode ())
      return;
d196 1
a196 1
   myDataWriter ()->writeFirstKeyWord (myAttName ());
d198 3
a200 3
   myDataWriter ()->writeVector ("hardLB", hardLB_, defHardLB ());
   myDataWriter ()->writeVector ("softLB", softLB_, defSoftLB ());
   myDataWriter ()->writeVector ("hardUB", hardUB_, defHardUB ());
d202 2
a203 2
   myDataWriter ()->writeFirstKeyWord ("endBounds");
   }
d208 2
a209 2
   {
   myDelComp ()->writeSetClause ();
d211 2
a212 2
   myDataWriter ()->writeFirstKeyWord (myAttName ());
   }
d217 12
a228 12
   {
   if (isAtDefault ())
      return;

   myMsgFac () (headingMsgID ());

   myMsgFac () ("boundHeadingDdMsg", mappingIndex_);

   myProblem ()->displayBoundVec ("hardLBFrag", hardLB_);
   myProblem ()->displayBoundVec ("softLBFrag", softLB_);
   myProblem ()->displayBoundVec ("hardUBFrag", hardUB_);
   }
d233 3
a235 3
   {
   if (isAtDefault ())
      return;
d237 1
a237 1
   WitPeriod thePer;
d239 2
a240 2
   fprintf (solnFile (),
      "\n\nSolution for bounds on the %s of ", boundedVectorName ());
d242 1
a242 1
   idObjectForSoln ();
d244 5
a248 5
   fprintf (solnFile (),
      "\n%6s  %11s  %11s  %11s  %11s  %11s  %11s  %11s\n",
      "Period", boundedVectorName (),
      "Hard LB", "Soft LB", "Hard UB",
      "Hard LB", "Soft LB", "Hard UB");
d250 3
a252 3
   fprintf (solnFile (),
      "%6s  %11s  %11s  %11s  %11s  %11s  %11s  %11s\n",
      "", "", "", "", "", "Violation", "Violation", "Violation");
d254 3
a256 3
   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d", thePer);
d258 1
a258 1
      writeSolnValue (boundedVal (thePer));
d260 2
a261 2
      writeSolnValue (hardLB_[thePer]);
      writeSolnValue (softLB_[thePer]);
d263 4
a266 4
      if (hardUBIsFinite (thePer))
         writeSolnValue (hardUB_[thePer]);
      else
         fprintf (solnFile (), "    +Infinity");
d268 1
a268 1
      writeSolnValue (positivePart (hardLB_[thePer] - boundedVal (thePer)));
d270 1
a270 1
      writeSolnValue (positivePart (softLB_[thePer] - boundedVal (thePer)));
d272 4
a275 4
      writeSolnValue (
         hardUBIsFinite (thePer)?
            positivePart (boundedVal (thePer) - hardUB_[thePer]):
            0.0);
d277 3
a279 3
      fprintf (solnFile (), "\n");
      }
   }
d284 2
a285 2
   {
   witAssert (myCompMgr ()->isReindexing (this));
d287 2
a288 2
   mappingIndex_ = myCompMgr ()->nBoundSets ();
   }
d293 15
a307 15
      const WitDblFlexVec & hardLBArg,
      const WitDblFlexVec & softLBArg)
   {
   WitPeriod thePer;

   if (not myDetOptImpMgr ()->accelerated ())
      return false;

   if (myOptComp ()->accAfterSoftLB ())
      return false;

   forEachPeriod (thePer, myProblem ())
      if (softLB_[thePer] == hardLB_[thePer])
         if (softLBArg[thePer] > hardLBArg[thePer])
            return true;
d309 2
a310 2
   return false;
   }
d317 4
a320 4
      WitBoundSet (theMat->myProblem ()),
      myMaterial_ (theMat)
   {
   }
d325 2
a326 2
   {
   }
d331 3
a333 3
   {
   return myMaterial_->stockVol ()[thePer];
   }
d338 3
a340 3
   {
   return "stockBounds";
   }
d345 3
a347 3
   {
   return myMaterial_;
   }
d352 3
a354 3
   {
   WitPart *     thePart;
   WitMaterial * theMat;
d356 1
a356 1
   thePart = theCompMgr->myMatchFor (myMaterial_);
d358 1
a358 1
   theMat  = thePart   ->thisMat  ();
d360 1
a360 1
   witAssert (theMat != NULL);
d362 2
a363 2
   return theMat->stockBounds ();
   }
d368 3
a370 3
   {
   return myMaterial_;
   }
d375 3
a377 3
   {
   myMsgFac () ("stage0AttMisMatchPartSmsg", myMaterial_->partName ());
   }
d382 3
a384 3
   {
   return "stockBoundsHeadingDdMsg";
   }
d389 3
a391 3
   {
   return "StockVol";
   }
d396 5
a400 5
   {
   fprintf (myProblem ()->solnFile (),
      "material part \"%s\":\n",
      myMaterial_->partName ().myCstring ());
   }
d408 4
a411 4
      WitBoundSet (theDemand->myProblem ()),
      myDemand_   (theDemand)
   {
   }
d416 2
a417 2
   {
   }
d422 3
a424 3
   {
   return myDemand_->cumShipVol ()[thePer];
   }
d429 3
a431 3
   {
   return "cumShipBounds";
   }
d436 3
a438 3
   {
   return myDemand_;
   }
d443 2
a444 2
   {
   WitDemand * theDemand;
d446 1
a446 1
   theDemand = theCompMgr->myMatchFor (myDemand_);
d448 2
a449 2
   return theDemand->cumShipBounds ();
   }
d454 3
a456 3
   {
   return myDemand_->demandedPart ();
   }
d461 5
a465 5
   {
   myMsgFac () ("stage0AttMisMatchDemandSmsg",
      myDemand_->demandedPartName (),
      myDemand_->demandName       ());
   }
d470 3
a472 3
   {
   return "cumShipBoundsHeadingDdMsg";
   }
d477 3
a479 3
   {
   return "CumShipVol";
   }
d484 6
a489 6
   {
   fprintf (myProblem ()->solnFile (),
      "demand \"%s\" for part \"%s\":\n",
      myDemand_->demandName ().myCstring (),
      myDemand_->demandedPartName ().myCstring ());
   }
d496 1
a496 1
      WitBoundSet  (theOpn->myProblem ()),
d498 3
a500 3
      myOperation_ (theOpn)
   {
   }
d505 2
a506 2
   {
   }
d511 3
a513 3
   {
   return myOperation_->execVol ()[thePer];
   }
d518 3
a520 3
   {
   return "execBounds";
   }
d525 3
a527 3
   {
   return myOperation_;
   }
d532 2
a533 2
   {
   WitOperation * theOpn;
d535 1
a535 1
   theOpn = theCompMgr->myMatchFor (myOperation_);
d537 2
a538 2
   return theOpn->execBounds ();
   }
d543 3
a545 3
   {
   return myOperation_;
   }
d550 3
a552 3
   {
   myMsgFac () ("stage0AttMisMatchOpnSmsg", myOperation_->operationName ());
   }
d557 3
a559 3
   {
   return "execBoundsHeadingDdMsg";
   }
d564 3
a566 3
   {
   return "ExecVol";
   }
d571 5
a575 5
   {
   fprintf (myProblem ()->solnFile (),
      "operation \"%s\":\n",
      myOperation_->operationName ().myCstring ());
   }
@


1.51
log
@Multi-Objective Mode
@
text
@d26 1
a26 1
#include <Opn.h>
@


1.50
log
@Removed many conversions of string constant to char *.
@
text
@d207 9
a350 9
void WitStockBoundSet::writeCompSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (myMaterial_->partName ());
   }

//------------------------------------------------------------------------------

a441 10
void WitCumShipBoundSet::writeCompSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (myDemand_->demandedPartName ());
   myDataWriter ()->writeStringValue  (myDemand_->demandName ());
   }

//------------------------------------------------------------------------------

a530 9
void WitExecBoundSet::writeCompSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("operation");
   myDataWriter ()->writeStringValue  (myOperation_->operationName ());
   }

//------------------------------------------------------------------------------

@


1.49
log
@Stochastic Implosion
@
text
@d328 1
a328 1
WitAttr WitStockBoundSet::myAttName ()
d388 1
a388 1
WitAttr WitStockBoundSet::boundedVectorName ()
d428 1
a428 1
WitAttr WitCumShipBoundSet::myAttName ()
d486 1
a486 1
WitAttr WitCumShipBoundSet::boundedVectorName ()
d527 1
a527 1
WitAttr WitExecBoundSet::myAttName ()
d582 1
a582 1
WitAttr WitExecBoundSet::boundedVectorName ()
@


1.48
log
@Stochastic Implosion
@
text
@d367 1
a367 1
int WitStockBoundSet::objectStage ()
d369 1
a369 1
   return myStochImpMgr ()->objectStage (myMaterial_);
d463 1
a463 1
int WitCumShipBoundSet::objectStage ()
d465 1
a465 1
   return myStochImpMgr ()->objectStage (myDemand_->demandedPart ());
d561 1
a561 1
int WitExecBoundSet::objectStage ()
d563 1
a563 1
   return myStochImpMgr ()->objectStage (myOperation_);
@


1.47
log
@Stochastic Implosion
@
text
@d367 1
a367 1
int WitStockBoundSet::stageIndex ()
d369 1
a369 1
   return myStochImpMgr ()->stageIndex (myMaterial_);
d463 1
a463 1
int WitCumShipBoundSet::stageIndex ()
d465 1
a465 1
   return myStochImpMgr ()->stageIndex (myDemand_->demandedPart ());
d561 1
a561 1
int WitExecBoundSet::stageIndex ()
d563 1
a563 1
   return myStochImpMgr ()->stageIndex (myOperation_);
@


1.46
log
@Stochastic Implosion
@
text
@d367 8
a374 1
void WitStockBoundSet::issueStage0MisMatchDelCompMsg ()
d463 8
a470 1
void WitCumShipBoundSet::issueStage0MisMatchDelCompMsg ()
d561 8
a568 1
void WitExecBoundSet::issueStage0MisMatchDelCompMsg ()
@


1.45
log
@Stochastic Implosion
@
text
@d367 7
d456 9
d547 7
@


1.44
log
@Stochastic Implosion
@
text
@d63 1
a63 1
bool WitBoundSet::isAtDefault () const
d75 1
a75 1
bool WitBoundSet::hardUBIsFinite (WitPeriod thePer) const
d82 1
a82 4
bool WitBoundSet::hardUBisSatisfied (
      WitPeriod thePer, 
      double    theValue) 
      const
d145 1
a145 1
void WitBoundSet::copyAttrsFrom (const WitBoundSet * theBoundSet)
d175 1
a175 1
bool WitBoundSet::hasPositiveHardLB () const
d207 1
a207 1
void WitBoundSet::display () const
d223 1
a223 1
void WitBoundSet::writeSoln () const
a285 1
      const
d321 1
a321 1
double WitStockBoundSet::boundedVal (WitPeriod thePer) const
d328 1
a328 1
WitAttr WitStockBoundSet::myAttName () const
d335 1
a335 1
WitDelComp * WitStockBoundSet::myDelComp () const
d342 1
a342 1
void WitStockBoundSet::writeCompSetClause () const
d367 1
a367 1
WitMsgID WitStockBoundSet::headingMsgID () const
d374 1
a374 1
WitAttr WitStockBoundSet::boundedVectorName () const
d381 1
a381 1
void WitStockBoundSet::idObjectForSoln () const
d407 1
a407 1
double WitCumShipBoundSet::boundedVal (WitPeriod thePer) const
d414 1
a414 1
WitAttr WitCumShipBoundSet::myAttName () const
d421 1
a421 1
WitDelComp * WitCumShipBoundSet::myDelComp () const
d428 1
a428 1
void WitCumShipBoundSet::writeCompSetClause () const
d449 1
a449 1
WitMsgID WitCumShipBoundSet::headingMsgID () const
d456 1
a456 1
WitAttr WitCumShipBoundSet::boundedVectorName () const
d463 1
a463 1
void WitCumShipBoundSet::idObjectForSoln () const
d490 1
a490 1
double WitExecBoundSet::boundedVal (WitPeriod thePer) const
d497 1
a497 1
WitAttr WitExecBoundSet::myAttName () const
d504 1
a504 1
WitDelComp * WitExecBoundSet::myDelComp () const
d511 1
a511 1
void WitExecBoundSet::writeCompSetClause () const
d531 1
a531 1
WitMsgID WitExecBoundSet::headingMsgID () const
d538 1
a538 1
WitAttr WitExecBoundSet::boundedVectorName () const
d545 1
a545 1
void WitExecBoundSet::idObjectForSoln () const
@


1.43
log
@Stochastic Implosion
@
text
@d355 16
d442 11
d524 11
@


1.42
log
@Stochastic Implosion
@
text
@d106 2
a107 1
   myDelComp ()->prepSetStochModeAttr (myAttName ());
d109 1
a109 3
   myProblem ()->prepSetStochModeAttr ("hardLB");
   myProblem ()->prepSetStochModeAttr ("softLB");
   myProblem ()->prepSetStochModeAttr ("hardUB");
@


1.41
log
@Stochastic Implosion
@
text
@d108 4
@


1.40
log
@Stochastic Implosion
@
text
@d106 1
a106 5
   myProblem ()->prepSetStochModeAttr (myAttName ());

   if (DEBUG_MODE)
      if (myStochImpMgr ()->stochMode ())
         witAssert (myDelComp ()->stageIndex () != 0);
@


1.39
log
@Stochastic Implosion
@
text
@d110 1
a110 1
         witAssert (myStochImpMgr ()->stageIndex (myDelComp ()) != 0);
@


1.38
log
@Stochastic Implosion
@
text
@d347 9
d417 10
d489 9
@


1.37
log
@Stochastic Implosion
@
text
@d110 1
a110 1
         witAssert (myStochImpMgr ()->stageIndex (this) != 0);
d340 1
a340 1
WitComponent * WitStockBoundSet::myComp () const
d401 1
a401 1
WitComponent * WitCumShipBoundSet::myComp () const
d463 1
a463 1
WitComponent * WitExecBoundSet::myComp () const
@


1.36
log
@Stochastic Implosion
@
text
@d192 1
a192 1
void WitBoundSet::writeData () const
d197 1
a197 1
   if (myStochImpMgr ()->skipWriteData (myAttName (), myComp ()))
@


1.35
log
@Stochastic Implosion
@
text
@d110 1
a110 1
         witAssert (myComp ()->stageIndex () != 0);
@


1.34
log
@Stochastic Implosion
@
text
@a346 9
void WitStockBoundSet::writeStochDataSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (myMaterial_->partName ());
   }

//------------------------------------------------------------------------------

a407 10
void WitCumShipBoundSet::writeStochDataSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (myDemand_->demandedPartName ());
   myDataWriter ()->writeStringValue  (myDemand_->demandName ());
   }

//------------------------------------------------------------------------------

a469 9
void WitExecBoundSet::writeStochDataSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("operation");
   myDataWriter ()->writeStringValue  (myOperation_->operationName ());
   }

//------------------------------------------------------------------------------

@


1.33
log
@Stochastic Implosion
@
text
@d110 1
a110 1
         witAssert (myComp ()->stageNo () != 0);
@


1.32
log
@Stochastic Implosion
@
text
@d110 1
a110 1
         witAssert (myStochImpMgr ()->stageNo (myNode ()) != 0);
d197 1
a197 1
   if (myStochImpMgr ()->stochMode ())
d340 1
a340 1
WitNode * WitStockBoundSet::myNode ()
d410 1
a410 1
WitNode * WitCumShipBoundSet::myNode ()
d412 1
a412 1
   return myDemand_->demandedPart ();
d482 1
a482 1
WitNode * WitExecBoundSet::myNode ()
@


1.31
log
@Stochastic Implosion
@
text
@d108 4
a355 7
void WitStockBoundSet::issueStage0MisMatchMsg ()
   {
   myMsgFac () ("stage0PartAttMisMatchSmsg", myMaterial_->partName ());
   }

//------------------------------------------------------------------------------

a426 9
void WitCumShipBoundSet::issueStage0MisMatchMsg ()
   {
   myMsgFac () ("stage0DemAttMisMatchSmsg",
      myDemand_->demandedPartName (),
      myDemand_->demandName ());
   }

//------------------------------------------------------------------------------

a497 7
void WitExecBoundSet::issueStage0MisMatchMsg ()
   {
   myMsgFac () ("stage0OpnAttMisMatchSmsg", myOperation_->operationName ());
   }

//------------------------------------------------------------------------------

@


1.30
log
@Stochastic Implosion
@
text
@d118 1
a118 1
void WitBoundSet::storeStochHardLB (const WitTVec <double> & theValue)
d127 1
a127 1
void WitBoundSet::storeStochSoftLB (const WitTVec <double> & theValue)
d136 1
a136 1
void WitBoundSet::storeStochHardUB (const WitTVec <double> & theValue)
@


1.29
log
@Stochastic Implosion
@
text
@d193 3
@


1.28
log
@Stochastic Implosion
@
text
@d340 9
d417 10
d498 9
@


1.27
log
@Stochastic Implosion
@
text
@d333 14
d401 16
d472 14
@


1.26
log
@Stochastic Implosion
@
text
@d29 1
d106 1
a106 1
   myProblem ()->prepSetUnpostAttr ();
d118 1
a118 1
void WitBoundSet::set (const WitBoundSet * theBoundSet)
d120 1
a120 3
   if (theBoundSet->isAtDefault ())
      if (isAtDefault ())
         return;
d122 22
a143 1
   myProblem ()->prepSetUnpostAttr ();
d145 2
d193 1
a193 1
   myDataWriter ()->writeFirstKeyWord (apiAttr ());
d326 1
a326 1
WitAttr WitStockBoundSet::apiAttr () const
d380 1
a380 1
WitAttr WitCumShipBoundSet::apiAttr () const
d435 1
a435 1
WitAttr WitExecBoundSet::apiAttr () const
@


1.25
log
@Stochastic Implosion
@
text
@d13 6
a18 1
// Contains the implementation of class BoundSet.
d21 6
a26 1
#include <BoundSet.h>
d34 2
d278 162
@


1.24
log
@Stochastic Implosion
@
text
@d18 1
a18 1
#include <OptImp.h>
d96 1
a96 1
      myOptImploder ()->shutDown ();
d253 1
a253 1
   if (not myOptImploder ()->accelerated ())
@


1.23
log
@Stochastic implosion.
@
text
@d93 1
a93 1
   myProblem ()->settingUnpostAttr ();
d111 1
a111 1
   myProblem ()->settingUnpostAttr ();
@


1.22
log
@App controlled opt implosion.
@
text
@d93 1
a93 1
   myProblem ()->resetSoln ();
d111 1
a111 1
   myProblem ()->resetSoln ();
@


1.21
log
@Updated the copyright date on all source files.
@
text
@a19 1
#include <DataAlt.h>
d93 1
a93 1
   postprocAlt ()->incur ();
d111 1
a111 1
   postprocAlt ()->incur ();
@


1.20
log
@Double Precision.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.19
log
@Double Precision.
@
text
@d77 1
a77 1
         (theValue <= fltFromDbl (hardUB_[thePer])):
@


1.18
log
@Double Precision.
@
text
@d99 3
a101 3
   hardLB_.copy (hardLBArg);
   softLB_.copy (softLBArg);
   hardUB_.copy (hardUBArg);
d114 3
a116 3
   hardLB_.copy (theBoundSet->hardLB_);
   softLB_.copy (theBoundSet->softLB_);
   hardUB_.copy (theBoundSet->hardUB_);
@


1.17
log
@Double Precision.
@
text
@d53 3
a55 3
   if (hardLB () == defHardLB ())
      if (softLB () == defSoftLB ())
         if (hardUB () == defHardUB ())
d65 1
a65 1
   return (hardUB ()[thePer] >= 0.0);
d77 1
a77 1
         (theValue <= fltFromDbl (hardUB ()[thePer])):
d84 3
a86 3
      const float * hardLBval,
      const float * softLBval,
      const float * hardUBval)
d92 1
a92 1
         witAssert (not seqError (hardLBval, softLBval, hardUBval, thePer));
d96 1
a96 1
   if (unaccNeeded (hardLBval, softLBval))
d99 3
a101 8
   if (hardLBval != NULL)
      hardLB_.convCopy (hardLBval);

   if (softLBval != NULL)
      softLB_.convCopy (softLBval);

   if (hardUBval != NULL)
      hardUB_.convCopy (hardUBval);
d122 4
a125 5
      const float * hardLBval,
      const float * softLBval,
      const float * hardUBval,
      WitPeriod     thePer)
      const
d127 1
a127 9
   float hardLBElem;
   float softLBElem;
   float hardUBElem;

   hardLBElem = elem (hardLB (), hardLBval, thePer);
   softLBElem = elem (softLB (), softLBval, thePer);
   hardUBElem = elem (hardUB (), hardUBval, thePer);

   if (hardLBElem < 0.0)
d130 1
a130 1
   if (hardLBElem > softLBElem)
d133 2
a134 2
   if (hardUBElem >= 0.0)
      if (softLBElem > hardUBElem)
d147 1
a147 1
      if (hardLB ()[thePer] > 0.0)
d162 3
a164 14
   myDataWriter ()->writeVector (
      "hardLB",
      hardLB (),
      defHardLB ());

   myDataWriter ()->writeVector (
      "softLB",
      softLB (),
      defSoftLB ());

   myDataWriter ()->writeVector (
      "hardUB",
      hardUB (),
      defHardUB ());
d180 3
a182 3
   myProblem ()->displayBoundVec ("hardLBFrag", hardLB ());
   myProblem ()->displayBoundVec ("softLBFrag", softLB ());
   myProblem ()->displayBoundVec ("hardUBFrag", hardUB ());
d215 2
a216 2
      writeSolnValue (hardLB ()[thePer]);
      writeSolnValue (softLB ()[thePer]);
d219 1
a219 1
         writeSolnValue (hardUB ()[thePer]);
d223 1
a223 1
      writeSolnValue (positivePart (hardLB ()[thePer] - boundedVal (thePer)));
d225 1
a225 1
      writeSolnValue (positivePart (softLB ()[thePer] - boundedVal (thePer)));
d229 1
a229 1
            positivePart (boundedVal (thePer) - hardUB ()[thePer]):
d248 2
a249 2
      const float * newHardLB,
      const float * newSoftLB)
a252 2
   float     newSoftLBElem;
   float     newHardLBElem;
d261 2
a262 6
      if (softLB ()[thePer] == hardLB ()[thePer])
         {
         newSoftLBElem = elem (softLB (), newSoftLB, thePer);
         newHardLBElem = elem (hardLB (), newHardLB, thePer);

         if (newSoftLBElem > newHardLBElem)
a263 1
         }
@


1.16
log
@Double Precision.
@
text
@d100 1
a100 1
      convCopy (hardLB_, hardLBval);
d103 1
a103 1
      convCopy (softLB_, softLBval);
d106 1
a106 1
      convCopy (hardUB_, hardUBval);
@


1.15
log
@Double Precision.
@
text
@d100 1
a100 1
      hardLB_.convCopy (hardLBval);
d103 1
a103 1
      softLB_.convCopy (softLBval);
d106 1
a106 1
      hardUB_.convCopy (hardUBval);
@


1.14
log
@Double Precision.
@
text
@d72 1
a72 1
      float     theValue) 
@


1.13
log
@Double Precision.
@
text
@d100 1
a100 1
      hardLB_.copyFltCVec (hardLBval);
d103 1
a103 1
      softLB_.copyFltCVec (softLBval);
d106 1
a106 1
      hardUB_.copyFltCVec (hardUBval);
@


1.12
log
@Double Precision.
@
text
@d77 1
a77 1
         (theValue <= floatFromDouble (hardUB ()[thePer])):
@


1.11
log
@Continued implementation of post-implosion pegging.
@
text
@d77 1
a77 1
         (theValue <= hardUB ()[thePer]):
d100 1
a100 1
      hardLB_.copyCvector (hardLBval);
d103 1
a103 1
      softLB_.copyCvector (softLBval);
d106 1
a106 1
      hardUB_.copyCvector (hardUBval);
d119 3
a121 3
   hardLB_.copy (theBoundSet->hardLB ());
   softLB_.copy (theBoundSet->softLB ());
   hardUB_.copy (theBoundSet->hardUB ());
@


1.10
log
@Continued implementation of proportionate routing.
@
text
@a22 1
#include <FlexVecI.h>
@


1.9
log
@Internal changes.
@
text
@d44 6
a49 1
// Other functions.
@


1.8
log
@Internal changes.
@
text
@d88 1
a88 1
         witAssert (! seqError (hardLBval, softLBval, hardUBval, thePer));
d277 1
a277 1
   if (! myOptImploder ()->accelerated ())
@


1.7
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d47 1
a47 1
WitBoolean WitBoundSet::isAtDefault () const
d52 1
a52 1
            return witTRUE;
d54 1
a54 1
   return witFALSE;
d59 1
a59 1
WitBoolean WitBoundSet::hardUBIsFinite (WitPeriod thePer) const
d66 1
a66 1
WitBoolean WitBoundSet::hardUBisSatisfied (
d74 1
a74 1
         witTRUE;
d122 1
a122 1
WitBoolean WitBoundSet::seqError (
d138 1
a138 1
      return witTRUE;
d141 1
a141 1
      return witTRUE;
d145 1
a145 1
         return witTRUE;
d147 1
a147 1
   return witFALSE;
d152 1
a152 1
WitBoolean WitBoundSet::hasPositiveHardLB () const
d158 1
a158 1
         return witTRUE;
d160 1
a160 1
   return witFALSE;
d268 1
a268 1
WitBoolean WitBoundSet::unaccNeeded (
d278 1
a278 1
      return witFALSE;
d281 1
a281 1
      return witFALSE;
d290 1
a290 1
            return witTRUE;
d293 1
a293 1
   return witFALSE;
@


1.6
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d23 1
d93 1
a93 1
      myOptImploder ()->unaccelerate ();
@


1.5
log
@Preliminary work on single source.
@
text
@d17 1
@


1.4
log
@Began implementation of object iteration.
@
text
@d94 1
a94 1
      hardLB_ = hardLBval;
d97 1
a97 1
      softLB_ = softLBval;
d100 1
a100 1
      hardUB_ = hardUBval;
d113 3
a115 3
   hardLB_ = theBoundSet->hardLB ();
   softLB_ = theBoundSet->softLB ();
   hardUB_ = theBoundSet->hardUB ();
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d21 1
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d241 1
a241 2
      writeSolnValue (
         WitUtil::positivePart (hardLB ()[thePer] - boundedVal (thePer)));
d243 1
a243 2
      writeSolnValue (
         WitUtil::positivePart (softLB ()[thePer] - boundedVal (thePer)));
d247 1
a247 1
            WitUtil::positivePart (boundedVal (thePer) - hardUB ()[thePer]):
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

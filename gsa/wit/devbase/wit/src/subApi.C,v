head	1.88;
access;
symbols
	sce_5_01_20080919:1.80
	latest_sce_4_20_20060523:1.57.0.2
	sce_4_20_20060523:1.57
	latest_sce4_20_OSL:1.56.0.2
	sce_4_20_OSL:1.56
	sce_410_withVa:1.55
	sce_4_05_20040511:1.44
	sce_4_00_20040201:1.24
	nextGenBranch:1.22.0.2
	nextGenRoot:1.22
	sce_3_30_20030627:1.22
	EndRw-branch:1.15.0.4
	Root-of-EndRw:1.15
	rwToStl:1.15.0.2
	latest_sce_3_10_20010924:1.7.0.2
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.5.0.6
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.4
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.88
date	2011.09.28.23.50.48;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2011.09.24.00.29.04;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2011.08.30.20.18.28;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2010.09.10.22.10.43;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2010.03.26.22.22.55;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.19.20.46.07;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.13.19.01.28;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2008.11.12.19.52.26;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.02.21.13.34;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.10.15.21.50.36;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.08.01.22.42.00;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.03.22.05.30;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.03.19.36.18;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.04.26.21.32.27;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.04.04.22.08.19;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.02.23.01.17;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.02.21.21.20;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.26.21.03.16;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.19.23.47.09;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2006.12.27.22.45.41;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.17.17.22.02;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.17.16.57.48;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.14.23.10.27;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.02.23.07.15;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.12.20.48.12;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2006.09.19.17.50.56;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.08.24.20.50.28;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.08.22.21.26.56;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2006.08.17.22.50.39;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2006.08.16.21.57.13;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.08.16.15.49.19;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.02.17.34.18;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.09.12.22.17.34;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.01.21.45.04;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.24.18.24.25;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.23.19.45.20;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.08.19.21.38.05;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.12.19.35.30;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.07.13.21.18.48;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.13.16.48.48;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.21.21.49.27;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.04.00.00.29;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.24.23.23.58;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.12.19.43.32;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.05.15.43.59;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.09.21.24.27;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.09.19.37.58;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.02.20.54.17;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.01.21.05.13;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.30.23.59.42;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.30.00.05.34;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.25.22.00.37;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.25.21.21.59;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.25.20.35.03;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.25.19.59.38;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.03.22.36.23;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.26.18.59.43;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.24.19.37.24;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.20.22.46.03;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.20.15.37.37;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.12.19.13.41;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.06.00.17.34;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.11.18.29.16;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.05.20.18.24;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.07.18.06.20;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.19.16.48.31;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.21.18.56.31;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.02.23.40.56;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.02.22.18.59;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.30.21.57.29;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.30.20.37.31;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.02.17.03.38;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.01.20.16.36;	author austel;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.17.21.45.09;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.19.22.00;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.03.23.16.45;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.25.19.14.56;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.24.18.26.13;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.14.02.50;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.31.00.26.28;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.01.19.23.36;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.20.12.38;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.29.21.22.48;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.30;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.25;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.34;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.34;	author wit;	state Exp;
branches;
next	;


desc
@@


1.88
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: subApi.C"
//
// Inner API functions relating to SubEntries.
//------------------------------------------------------------------------------

#include <WitRun.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <ApiCall.h>
#include <ISRealArg.h>
#include <OSRealArg.h>
#include <IVRealArg.h>
#include <OVRealArg.h>
#include <Pre.h>
#include <DetOptImpMgr.h>
#include <ExtOptMgr.h>
#include <CompMgr.h>
#include <Operation.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <MsgFrag.h>
#include <MsgFac.h>

#include <stdlib.h>

//------------------------------------------------------------------------------
// setGetSubBomEntryInit
// Initilization of wit[S|G]etSubBomEntry* functions.
//------------------------------------------------------------------------------

WitSubEntry * WitRun::setGetSubBomEntryInit (
      const char * operationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex)
   {
   forbidNullArg (operationName, "operationName");

   if (myMsgFac ().mayIssue ("operationNameMsg"))
      myMsgFac () ("operationNameMsg",      operationName );

   if (myMsgFac ().mayIssue ("bomEntryIndexMsg"))
      myMsgFac () ("bomEntryIndexMsg", bomEntryIndex );

   if (myMsgFac ().mayIssue ("subsBomEntryIndexMsg"))
      myMsgFac () ("subsBomEntryIndexMsg", subsBomEntryIndex );

   return getSubBomEntryP (operationName, bomEntryIndex, subsBomEntryIndex);
   }

//------------------------------------------------------------------------------

void WitRun::witAddSubsBomEntry (
      const char * operationName,
      int          bomIndex,
      const char * consumedPartName)
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;

   myApiMgr_->startInnerFunc ();

   forbidNullArg (operationName,    "operationName");
   forbidNullArg (consumedPartName, "consumedPartName");

   if (myMsgFac ().mayIssue ("parmsAsbeMsg"))
      myMsgFac () ("parmsAsbeMsg",
         operationName,
         bomIndex,
         consumedPartName);

   theOpn = myCompMgr ()->findOperation (operationName);

   if (theOpn == NULL)
      myMsgFac () ("undefinedOperationMsg", operationName);

   myInputID ()->setMyOperation (theOpn);

   if (theOpn->bom ().isEmpty ())
      myMsgFac () ("emptyBom");

   if (bomIndex < 0 or bomIndex >= theOpn->bom ().nElements())
      myMsgFac () ("bomEntryIndexRangeSmsg",
         bomIndex,
         0,
         theOpn->bom ().nElements ());

   theBomEnt = myCompMgr ()->findBomEntry (theOpn, bomIndex);

   witAssert (theBomEnt != NULL);

   myInputID ()->setMyBomEntry (theBomEnt);

   thePart = myCompMgr ()->findPart (consumedPartName);

   if (thePart == NULL)
      myMsgFac () ("undefinedPartMsg", consumedPartName);

   addingDelComp ("subEntryFrag");

   new WitSubEntry (theBomEnt, thePart);

   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBomEntry  (NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witCopySubsBomEntryData (
      const char * dupOperationName,
      int          dupBomEntryIndex,
      int          dupSubsBomEntryIndex,
      WitRun *     origWitRun,
      const char * origOperationName,
      int          origBomEntryIndex,
      int          origSubsBomEntryIndex)
   {
   startCopyObjData (origWitRun);

   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("subEntryFrag"));

   WitSubEntryApiCall dupCall  (
      this,
      dupOperationName,
      dupBomEntryIndex,
      dupSubsBomEntryIndex);

   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("subEntryFrag"));

   WitSubEntryApiCall origCall  (
      origWitRun,
      origOperationName,
      origBomEntryIndex,
      origSubsBomEntryIndex);

   if (dupCall.mySub () == origCall.mySub ())
      myMsgFac () ("copyObjectToSelfSmsg",
         myMsgFac ().myFrag ("subEntryFrag"));

   dupCall.mySub ()->copyAttrsFrom (origCall.mySub ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetObjItrSubsBomEntry (
      char * * consumingOperationName,
      int *    bomEntryIndex,
      int *    subsBomEntryIndex)
   {
   WitSubEntry * theSub;

   myApiMgr_->startInnerFunc ();

   theSub =
      curItrDelCompForGet (WitAT_SUB_ENTRY, "subEntryFrag")->
         thisSub ();

   stronglyAssert (theSub != NULL);

   apiGet (
      consumingOperationName, 
      "consumingOperationName", 
      theSub->myOperationName ());

   apiGet (bomEntryIndex,     "bomEntryIndex",     theSub->myBomEntIndex ());
   apiGet (subsBomEntryIndex, "subsBomEntryIndex", theSub->localIndex ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryAppData (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      void * *     appData)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (appData, "appData", theCall.mySub ()->appData ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryConsRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & consRate)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (consRate, "consRate", theCall.mySub ()->consRate ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryConsumedPart (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      char * *     consumedPartName )
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (
       consumedPartName, 
      "consumedPartName", 
      theCall.mySub ()->myPartName ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryEarliestPeriod (
     const char * consumingOperationName,
     int          bomEntryIndex,
     int          subsBomEntryIndex,
     int *        earliestPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (             earliestPeriod, 
                       "earliestPeriod", 
      theCall.mySub ()->earliestPeriod ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryExecPenalty (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOSRealArg & execPenalty)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (execPenalty, "execPenalty", theCall.mySub ()->execPenalty ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryExpAllowed (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * expAllowed)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (expAllowed, "expAllowed", theCall.mySub ()->expAllowed ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryExpNetAversion (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOSRealArg & expNetAversion)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (             expNetAversion, 
                       "expNetAversion", 
      theCall.mySub ()->expNetAversion ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryFallout (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int *        fallout)
   {
   double theFalloutRate;

   myApiMgr_->startInnerFunc ();

   myMsgFac () (
      "getPre50AttrMsg",
      apiFuncName (),
      "subEntry",
      "fallout",
      "falloutRate");

   witGetSubsBomEntryFalloutRate (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      & theFalloutRate);

   apiGet (fallout, "fallout", fracToPercent (theFalloutRate));
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryFalloutRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOSRealArg & falloutRate)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (falloutRate, "falloutRate", theCall.mySub ()->falloutRate ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryFssSubVol (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & fssSubVol)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   forbidStochMode ();

   myProblem ()->computeFssIfNeeded ();

   apiGet (fssSubVol, "fssSubVol", theCall.mySub ()->fssSubVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryImpactPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int **       impactPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   myProblem ()->myPreprocessor ()->preprocess ();

   apiGet (impactPeriod, "impactPeriod", theCall.mySub ()->impactPeriod ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryIntSubVols (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * intSubVols)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (intSubVols, "intSubVols", theCall.mySub ()->intSubVols ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryLatestPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int *        latestPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (latestPeriod, "latestPeriod", theCall.mySub ()->latestPeriod ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryMrpNetAllowed (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * mrpNetAllowed )
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (mrpNetAllowed, "mrpNetAllowed", theCall.mySub ()->mrpNetAllowed ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryMrpSubVol (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & mrpSubVol)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (mrpSubVol, "mrpSubVol", theCall.mySub ()->mrpSubVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryNetAllowed (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * netAllowed )
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (netAllowed, "netAllowed", theCall.mySub ()->netAllowed ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryObj1SubCost (
     const char *         consumingOperationName,
     int                  bomEntryIndex,
     int                  subsBomEntryIndex,
     const WitOVRealArg & obj1SubCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "substitute BOM entry",
         "obj1SubCost",
         "subCost");

   witGetSubsBomEntrySubCost (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      obj1SubCost);
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryOffset (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & offset)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (offset, "offset", theCall.mySub ()->offset ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryProdVol (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & prodVol)
   {
   myApiMgr_->startInnerFunc ();

   prepGet34Attr ("SubsBomEntry", "prodVol", "SubsBomEntry", "subVol");

   witGetSubsBomEntrySubVol (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      prodVol);
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryRoutingShare (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & routingShare)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (routingShare, "routingShare", theCall.mySub ()->routingShare ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntrySelForDel (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * selForDel)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (selForDel, "selForDel", theCall.mySub ()->selForDel ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntrySubCost (
     const char *         consumingOperationName,
     int                  bomEntryIndex,
     int                  subsBomEntryIndex,
     const WitOVRealArg & subCost)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (             subCost, 
                       "subCost", 
      theCall.mySub ()->subCost ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntrySubVarIndex (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      const int    thePer,
      int *        subVarIndex)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   prepGetIndex (thePer);

   apiGet (
       subVarIndex,
      "subVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            subVarIndex (theCall.mySub (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntrySubVol (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & subVol)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (subVol, "subVol", theCall.mySub ()->subVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetSubsBomEntryUsageRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOSRealArg & usageRate)
   {
   double * consRateCVec;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "substitute BOM entry",
         "usageRate",
         "consRate");

   witGetSubsBomEntryConsRate (
      consumingOperationName, 
      bomEntryIndex, 
      subsBomEntryIndex,
      & consRateCVec);

   forbidNullArg (usageRate, "usageRate");

   usageRate = consRateCVec[0];

   free (consRateCVec);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryAppData (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      void *       appData)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.setAppData (appData);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryConsRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & consRate)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepDblVec ("consRate", consRate);

   if (theCall.argsOK ())
      theCall.mySub ()->setConsRate (consRate);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryEarliestPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int          earliestPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.setEarliestPeriod (earliestPeriod);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryExecPenalty (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & execPenalty)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepNonNegDouble (
      "execPenalty", 
      theCall.mySub ()->execPenalty (),
      execPenalty);

   if (theCall.argsOK ())
      theCall.mySub ()->setExecPenalty (execPenalty);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryExpAllowed (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   expAllowed)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepBool (
                       "expAllowed", 
      theCall.mySub ()->expAllowed (), 
                        expAllowed);

   if (theCall.argsOK ())
      theCall.mySub ()->setExpAllowed (asaBool (expAllowed));
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryExpNetAversion (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & expNetAversion)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepDouble (
      "expNetAversion", 
      theCall.mySub ()->expNetAversion (), 
      expNetAversion);

   if (theCall.argsOK ())
      theCall.mySub ()->setExpNetAversion (expNetAversion);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryFallout (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int          fallout)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () (
      "setPre50AttrMsg",
      apiFuncName (),
      "subEntry",
      "fallout",
      "falloutRate");

   witSetSubsBomEntryFalloutRate (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      percentToFrac (fallout));
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryFalloutRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & falloutRate)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepNonNegUBDouble (
      "falloutRate", 
      theCall.mySub ()->falloutRate (), 
      falloutRate,
      0.99 + FLOAT_EPSILON,
      0.99);

   if (theCall.argsOK ())
      theCall.mySub ()->setFalloutRate (falloutRate);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryIntSubVols (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   intSubVols)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepBool (
                       "intSubVols", 
      theCall.mySub ()->intSubVols (), 
                        intSubVols);

   if (theCall.argsOK ())
      theCall.mySub ()->setIntSubVols (asaBool (intSubVols));
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryLatestPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int          latestPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.setLatestPeriod (latestPeriod);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryMrpNetAllowed (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   mrpNetAllowed)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepBool (
      "mrpNetAllowed", 
      theCall.mySub ()->mrpNetAllowed (), 
      mrpNetAllowed);

   if (theCall.argsOK ())
      theCall.mySub ()->setMrpNetAllowed (asaBool (mrpNetAllowed));
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryNetAllowed (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   netAllowed)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepBool (
                       "netAllowed", 
      theCall.mySub ()->netAllowed (),
                        netAllowed);

   if (theCall.argsOK ())
      theCall.mySub ()->setNetAllowed (asaBool (netAllowed));
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryObj1SubCost (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & obj1SubCost )
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "substitute BOM entry",
         "obj1SubCost",
         "subCost");

      witSetSubsBomEntrySubCost (
         consumingOperationName,
         bomEntryIndex,
         subsBomEntryIndex,
         obj1SubCost);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryOffset (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & offset)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.setOffset (offset);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryProdVol (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & prodVol)
   {
   myApiMgr_->startInnerFunc ();

   prepSet34Attr ("SubsBomEntry", "prodVol", "SubsBomEntry", "subVol");

   witSetSubsBomEntrySubVol (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      prodVol);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryRoutingShare (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & routingShare)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.setRoutingShare (routingShare);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntrySelForDel (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   selForDel)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.setSelForDel (selForDel);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntrySubCost (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & subCost )
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   WitPeriod thePer;

   theCall.prepDblVec ("subCost", subCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (subCost[thePer] < 0.0)
            myMsgFac () (
               "negSubCostWmsg",
               "subCost",
               consumingOperationName,
               bomEntryIndex,
               subsBomEntryIndex,
               theCall.mySub ()->myPartName (),
               subCost[thePer],
               thePer);

      theCall.mySub ()->setSubCost (subCost);
      }
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntrySubVol (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & subVol)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepNonNegDblVec ("subVol", subVol);

   if (theCall.argsOK ())
      theCall.mySub ()->setSubVol (subVol);
   }

//------------------------------------------------------------------------------

void WitRun::witSetSubsBomEntryUsageRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & usageRate)
   {
   WitTVec <double> & consRateVec = myApiMgr ()->reserveTempDblVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "substitute BOM entry",
         "usageRate",
         "consRate");

   consRateVec = usageRate;

   witSetSubsBomEntryConsRate (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      consRateVec.myCVec ());

   myApiMgr ()->releaseTempVecs ();
   }

//------------------------------------------------------------------------------
// getSubBomEntryP
// Get point to a substitute BOM entry
//------------------------------------------------------------------------------

WitSubEntry * WitRun::getSubBomEntryP (
      const char * operationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex)
   {
   WitSubEntry * retVal;
   WitBomEntry * entryP;

   entryP = getBomEntryP (operationName, bomEntryIndex);

   if (entryP->mySubEntries ().isEmpty ())
      myMsgFac () ("bomEntryWoSubsSmsg");

   if (  subsBomEntryIndex < 0 or
         subsBomEntryIndex >= entryP->mySubEntries ().nElements ())
      myMsgFac () ("subsBomEntryIndexRangeSmsg",
         subsBomEntryIndex,
         0,
         entryP->mySubEntries ().nElements ());

   retVal = myCompMgr ()->findSubEntry (entryP, subsBomEntryIndex);

   witAssert (retVal != NULL);

   myInputID ()->setMySubEntry (retVal);

   return retVal;
   }
@


1.87
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 13
a13 8
//-----------------------------------------------------------------------------
// 
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.86
log
@Revised the copyright date.
@
text
@d2 2
a3 2
//
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d42 8
a49 8
const char * operationName,
int          bomEntryIndex,
int          subsBomEntryIndex)
{
forbidNullArg (operationName, "operationName");

if (myMsgFac ().mayIssue ("operationNameMsg"))
myMsgFac () ("operationNameMsg",      operationName );
d51 2
a52 2
if (myMsgFac ().mayIssue ("bomEntryIndexMsg"))
myMsgFac () ("bomEntryIndexMsg", bomEntryIndex );
d54 2
a55 2
if (myMsgFac ().mayIssue ("subsBomEntryIndexMsg"))
myMsgFac () ("subsBomEntryIndexMsg", subsBomEntryIndex );
d57 2
a58 2
return getSubBomEntryP (operationName, bomEntryIndex, subsBomEntryIndex);
}
d63 7
a69 7
const char * operationName,
int          bomIndex,
const char * consumedPartName)
{
WitPart *      thePart;
WitOperation * theOpn;
WitBomEntry *  theBomEnt;
d71 1
a71 1
myApiMgr_->startInnerFunc ();
d73 2
a74 2
forbidNullArg (operationName,    "operationName");
forbidNullArg (consumedPartName, "consumedPartName");
d76 5
a80 5
if (myMsgFac ().mayIssue ("parmsAsbeMsg"))
myMsgFac () ("parmsAsbeMsg",
operationName,
bomIndex,
consumedPartName);
d82 1
a82 1
theOpn = myCompMgr ()->findOperation (operationName);
d84 2
a85 2
if (theOpn == NULL)
myMsgFac () ("undefinedOperationMsg", operationName);
d87 1
a87 1
myInputID ()->setMyOperation (theOpn);
d89 2
a90 2
if (theOpn->bom ().isEmpty ())
myMsgFac () ("emptyBom");
d92 5
a96 5
if (bomIndex < 0 or bomIndex >= theOpn->bom ().nElements())
myMsgFac () ("bomEntryIndexRangeSmsg",
bomIndex,
0,
theOpn->bom ().nElements ());
d98 1
a98 1
theBomEnt = myCompMgr ()->findBomEntry (theOpn, bomIndex);
d100 1
a100 1
witAssert (theBomEnt != NULL);
d102 1
a102 1
myInputID ()->setMyBomEntry (theBomEnt);
d104 1
a104 1
thePart = myCompMgr ()->findPart (consumedPartName);
d106 2
a107 2
if (thePart == NULL)
myMsgFac () ("undefinedPartMsg", consumedPartName);
d109 1
a109 1
addingDelComp ("subEntryFrag");
d111 1
a111 1
new WitSubEntry (theBomEnt, thePart);
d113 3
a115 3
myInputID ()->setMyOperation (NULL);
myInputID ()->setMyBomEntry  (NULL);
}
d120 29
a148 29
const char * dupOperationName,
int          dupBomEntryIndex,
int          dupSubsBomEntryIndex,
WitRun *     origWitRun,
const char * origOperationName,
int          origBomEntryIndex,
int          origSubsBomEntryIndex)
{
startCopyObjData (origWitRun);

myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("subEntryFrag"));

WitSubEntryApiCall dupCall  (
this,
dupOperationName,
dupBomEntryIndex,
dupSubsBomEntryIndex);

myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("subEntryFrag"));

WitSubEntryApiCall origCall  (
origWitRun,
origOperationName,
origBomEntryIndex,
origSubsBomEntryIndex);

if (dupCall.mySub () == origCall.mySub ())
myMsgFac () ("copyObjectToSelfSmsg",
myMsgFac ().myFrag ("subEntryFrag"));
d150 2
a151 2
dupCall.mySub ()->copyAttrsFrom (origCall.mySub ());
}
d156 22
a177 22
char * * consumingOperationName,
int *    bomEntryIndex,
int *    subsBomEntryIndex)
{
WitSubEntry * theSub;

myApiMgr_->startInnerFunc ();

theSub =
curItrDelCompForGet (WitAT_SUB_ENTRY, "subEntryFrag")->
thisSub ();

stronglyAssert (theSub != NULL);

apiGet (
consumingOperationName,
"consumingOperationName",
theSub->myOperationName ());

apiGet (bomEntryIndex,     "bomEntryIndex",     theSub->myBomEntIndex ());
apiGet (subsBomEntryIndex, "subsBomEntryIndex", theSub->localIndex ());
}
d182 10
a191 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
void * *     appData)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d193 2
a194 2
apiGet (appData, "appData", theCall.mySub ()->appData ());
}
d199 10
a208 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & consRate)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d210 2
a211 2
apiGet (consRate, "consRate", theCall.mySub ()->consRate ());
}
d216 16
a231 16
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
char * *     consumedPartName )
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

apiGet (
consumedPartName,
"consumedPartName",
theCall.mySub ()->myPartName ());
}
d236 15
a250 15
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
int *        earliestPeriod)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

apiGet (             earliestPeriod,
"earliestPeriod",
theCall.mySub ()->earliestPeriod ());
}
d255 10
a264 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOSRealArg & execPenalty)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d266 2
a267 2
apiGet (execPenalty, "execPenalty", theCall.mySub ()->execPenalty ());
}
d272 10
a281 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean * expAllowed)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d283 2
a284 2
apiGet (expAllowed, "expAllowed", theCall.mySub ()->expAllowed ());
}
d289 15
a303 15
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOSRealArg & expNetAversion)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

apiGet (             expNetAversion,
"expNetAversion",
theCall.mySub ()->expNetAversion ());
}
d308 21
a328 21
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
int *        fallout)
{
double theFalloutRate;

myApiMgr_->startInnerFunc ();

myMsgFac () (
"getPre50AttrMsg",
apiFuncName (),
"subEntry",
"fallout",
"falloutRate");

witGetSubsBomEntryFalloutRate (
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
& theFalloutRate);
d330 2
a331 2
apiGet (fallout, "fallout", fracToPercent (theFalloutRate));
}
d336 10
a345 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOSRealArg & falloutRate)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d347 2
a348 2
apiGet (falloutRate, "falloutRate", theCall.mySub ()->falloutRate ());
}
d353 10
a362 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & fssSubVol)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d364 1
a364 1
forbidStochMode ();
d366 1
a366 1
myProblem ()->computeFssIfNeeded ();
d368 2
a369 2
apiGet (fssSubVol, "fssSubVol", theCall.mySub ()->fssSubVol ());
}
d374 10
a383 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
int **       impactPeriod)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d385 1
a385 1
myProblem ()->myPreprocessor ()->preprocess ();
d387 2
a388 2
apiGet (impactPeriod, "impactPeriod", theCall.mySub ()->impactPeriod ());
}
d393 10
a402 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean * intSubVols)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d404 2
a405 2
apiGet (intSubVols, "intSubVols", theCall.mySub ()->intSubVols ());
}
d410 10
a419 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
int *        latestPeriod)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d421 2
a422 2
apiGet (latestPeriod, "latestPeriod", theCall.mySub ()->latestPeriod ());
}
d427 10
a436 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean * mrpNetAllowed )
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d438 2
a439 2
apiGet (mrpNetAllowed, "mrpNetAllowed", theCall.mySub ()->mrpNetAllowed ());
}
d444 10
a453 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & mrpSubVol)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d455 2
a456 2
apiGet (mrpSubVol, "mrpSubVol", theCall.mySub ()->mrpSubVol ());
}
d461 10
a470 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean * netAllowed )
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d472 2
a473 2
apiGet (netAllowed, "netAllowed", theCall.mySub ()->netAllowed ());
}
d478 21
a498 21
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & obj1SubCost)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
myMsgFac () (
"getAttrNewNameMsg",
apiFuncName (),
"substitute BOM entry",
"obj1SubCost",
"subCost");

witGetSubsBomEntrySubCost (
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
obj1SubCost);
}
d503 10
a512 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & offset)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d514 2
a515 2
apiGet (offset, "offset", theCall.mySub ()->offset ());
}
d520 15
a534 15
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & prodVol)
{
myApiMgr_->startInnerFunc ();

prepGet34Attr ("SubsBomEntry", "prodVol", "SubsBomEntry", "subVol");

witGetSubsBomEntrySubVol (
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
prodVol);
}
d539 10
a548 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & routingShare)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d550 2
a551 2
apiGet (routingShare, "routingShare", theCall.mySub ()->routingShare ());
}
d556 10
a565 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean * selForDel)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d567 2
a568 2
apiGet (selForDel, "selForDel", theCall.mySub ()->selForDel ());
}
d573 15
a587 15
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & subCost)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

apiGet (             subCost,
"subCost",
theCall.mySub ()->subCost ());
}
d592 21
a612 21
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
const int    thePer,
int *        subVarIndex)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

prepGetIndex (thePer);

apiGet (
subVarIndex,
"subVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
subVarIndex (theCall.mySub (), thePer));
}
d617 10
a626 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOVRealArg & subVol)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d628 2
a629 2
apiGet (subVol, "subVol", theCall.mySub ()->subVol ());
}
d634 22
a655 22
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitOSRealArg & usageRate)
{
double * consRateCVec;

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
myMsgFac () (
"getVecAttrAsScalMsg",
apiFuncName (),
"substitute BOM entry",
"usageRate",
"consRate");

witGetSubsBomEntryConsRate (
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
& consRateCVec);
d657 1
a657 1
forbidNullArg (usageRate, "usageRate");
d659 1
a659 1
usageRate = consRateCVec[0];
d661 2
a662 2
free (consRateCVec);
}
d667 10
a676 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
void *       appData)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d678 2
a679 2
theCall.setAppData (appData);
}
d684 16
a699 16
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitIVRealArg & consRate)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepDblVec ("consRate", consRate);

if (theCall.argsOK ())
theCall.mySub ()->setConsRate (consRate);
}
d704 10
a713 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
int          earliestPeriod)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d715 2
a716 2
theCall.setEarliestPeriod (earliestPeriod);
}
d721 19
a739 19
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitISRealArg & execPenalty)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepNonNegDouble (
"execPenalty",
theCall.mySub ()->execPenalty (),
execPenalty);

if (theCall.argsOK ())
theCall.mySub ()->setExecPenalty (execPenalty);
}
d744 19
a762 19
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean   expAllowed)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepBool (
"expAllowed",
theCall.mySub ()->expAllowed (),
expAllowed);

if (theCall.argsOK ())
theCall.mySub ()->setExpAllowed (asaBool (expAllowed));
}
d767 19
a785 19
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitISRealArg & expNetAversion)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepDouble (
"expNetAversion",
theCall.mySub ()->expNetAversion (),
expNetAversion);

if (theCall.argsOK ())
theCall.mySub ()->setExpNetAversion (expNetAversion);
}
d790 20
a809 20
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
int          fallout)
{
myApiMgr_->startInnerFunc ();

myMsgFac () (
"setPre50AttrMsg",
apiFuncName (),
"subEntry",
"fallout",
"falloutRate");

witSetSubsBomEntryFalloutRate (
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
percentToFrac (fallout));
}
d814 21
a834 21
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitISRealArg & falloutRate)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepNonNegUBDouble (
"falloutRate",
theCall.mySub ()->falloutRate (),
falloutRate,
0.99 + FLOAT_EPSILON,
0.99);

if (theCall.argsOK ())
theCall.mySub ()->setFalloutRate (falloutRate);
}
d839 19
a857 19
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean   intSubVols)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepBool (
"intSubVols",
theCall.mySub ()->intSubVols (),
intSubVols);

if (theCall.argsOK ())
theCall.mySub ()->setIntSubVols (asaBool (intSubVols));
}
d862 10
a871 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
int          latestPeriod)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d873 2
a874 2
theCall.setLatestPeriod (latestPeriod);
}
d879 19
a897 19
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean   mrpNetAllowed)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepBool (
"mrpNetAllowed",
theCall.mySub ()->mrpNetAllowed (),
mrpNetAllowed);

if (theCall.argsOK ())
theCall.mySub ()->setMrpNetAllowed (asaBool (mrpNetAllowed));
}
d902 19
a920 19
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean   netAllowed)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepBool (
"netAllowed",
theCall.mySub ()->netAllowed (),
netAllowed);

if (theCall.argsOK ())
theCall.mySub ()->setNetAllowed (asaBool (netAllowed));
}
d925 21
a945 21
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitIVRealArg & obj1SubCost )
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
myMsgFac () (
"setAttrNewNameMsg",
apiFuncName (),
"substitute BOM entry",
"obj1SubCost",
"subCost");

witSetSubsBomEntrySubCost (
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
obj1SubCost);
}
d950 10
a959 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitIVRealArg & offset)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d961 2
a962 2
theCall.setOffset (offset);
}
d967 15
a981 15
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitIVRealArg & prodVol)
{
myApiMgr_->startInnerFunc ();

prepSet34Attr ("SubsBomEntry", "prodVol", "SubsBomEntry", "subVol");

witSetSubsBomEntrySubVol (
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
prodVol);
}
d986 10
a995 10
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitIVRealArg & routingShare)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d997 2
a998 2
theCall.setRoutingShare (routingShare);
}
d1003 10
a1012 10
const char * consumingOperationName,
int          bomEntryIndex,
int          subsBomEntryIndex,
WitBoolean   selForDel)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);
d1014 2
a1015 2
theCall.setSelForDel (selForDel);
}
d1020 32
a1051 32
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitIVRealArg & subCost )
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

WitPeriod thePer;

theCall.prepDblVec ("subCost", subCost);

if (theCall.argsOK ())
{
forEachPeriod (thePer, myProblem ())
if (subCost[thePer] < 0.0)
myMsgFac () (
"negSubCostWmsg",
"subCost",
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
theCall.mySub ()->myPartName (),
subCost[thePer],
thePer);

theCall.mySub ()->setSubCost (subCost);
}
}
d1056 16
a1071 16
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitIVRealArg & subVol)
{
WitSubEntryApiCall theCall (
this,
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex);

theCall.prepNonNegDblVec ("subVol", subVol);

if (theCall.argsOK ())
theCall.mySub ()->setSubVol (subVol);
}
d1076 24
a1099 24
const char *         consumingOperationName,
int                  bomEntryIndex,
int                  subsBomEntryIndex,
const WitISRealArg & usageRate)
{
WitTVec <double> & consRateVec = myApiMgr ()->reserveTempDblVec ();

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
myMsgFac () (
"setVecAttrToScalMsg",
apiFuncName (),
"substitute BOM entry",
"usageRate",
"consRate");

consRateVec = usageRate;

witSetSubsBomEntryConsRate (
consumingOperationName,
bomEntryIndex,
subsBomEntryIndex,
consRateVec.myCVec ());
d1101 2
a1102 2
myApiMgr ()->releaseTempVecs ();
}
d1110 6
a1115 6
const char * operationName,
int          bomEntryIndex,
int          subsBomEntryIndex)
{
WitSubEntry * retVal;
WitBomEntry * entryP;
d1117 1
a1117 1
entryP = getBomEntryP (operationName, bomEntryIndex);
d1119 2
a1120 2
if (entryP->mySubEntries ().isEmpty ())
myMsgFac () ("bomEntryWoSubsSmsg");
d1122 6
a1127 6
if (  subsBomEntryIndex < 0 or
subsBomEntryIndex >= entryP->mySubEntries ().nElements ())
myMsgFac () ("subsBomEntryIndexRangeSmsg",
subsBomEntryIndex,
0,
entryP->mySubEntries ().nElements ());
d1129 1
a1129 1
retVal = myCompMgr ()->findSubEntry (entryP, subsBomEntryIndex);
d1131 1
a1131 1
witAssert (retVal != NULL);
d1133 1
a1133 1
myInputID ()->setMySubEntry (retVal);
d1135 2
a1136 2
return retVal;
}
@


1.85
log
@Heuristic Adjustment
@
text
@d2 2
a3 2
// 
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d42 8
a49 8
      const char * operationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex)
   {
   forbidNullArg (operationName, "operationName");

   if (myMsgFac ().mayIssue ("operationNameMsg"))
      myMsgFac () ("operationNameMsg",      operationName );
d51 2
a52 2
   if (myMsgFac ().mayIssue ("bomEntryIndexMsg"))
      myMsgFac () ("bomEntryIndexMsg", bomEntryIndex );
d54 2
a55 2
   if (myMsgFac ().mayIssue ("subsBomEntryIndexMsg"))
      myMsgFac () ("subsBomEntryIndexMsg", subsBomEntryIndex );
d57 2
a58 2
   return getSubBomEntryP (operationName, bomEntryIndex, subsBomEntryIndex);
   }
d63 7
a69 7
      const char * operationName,
      int          bomIndex,
      const char * consumedPartName)
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
d71 1
a71 1
   myApiMgr_->startInnerFunc ();
d73 2
a74 2
   forbidNullArg (operationName,    "operationName");
   forbidNullArg (consumedPartName, "consumedPartName");
d76 5
a80 5
   if (myMsgFac ().mayIssue ("parmsAsbeMsg"))
      myMsgFac () ("parmsAsbeMsg",
         operationName,
         bomIndex,
         consumedPartName);
d82 1
a82 1
   theOpn = myCompMgr ()->findOperation (operationName);
d84 2
a85 2
   if (theOpn == NULL)
      myMsgFac () ("undefinedOperationMsg", operationName);
d87 1
a87 1
   myInputID ()->setMyOperation (theOpn);
d89 2
a90 2
   if (theOpn->bom ().isEmpty ())
      myMsgFac () ("emptyBom");
d92 5
a96 5
   if (bomIndex < 0 or bomIndex >= theOpn->bom ().nElements())
      myMsgFac () ("bomEntryIndexRangeSmsg",
         bomIndex,
         0,
         theOpn->bom ().nElements ());
d98 1
a98 1
   theBomEnt = myCompMgr ()->findBomEntry (theOpn, bomIndex);
d100 1
a100 1
   witAssert (theBomEnt != NULL);
d102 1
a102 1
   myInputID ()->setMyBomEntry (theBomEnt);
d104 1
a104 1
   thePart = myCompMgr ()->findPart (consumedPartName);
d106 2
a107 2
   if (thePart == NULL)
      myMsgFac () ("undefinedPartMsg", consumedPartName);
d109 1
a109 1
   addingDelComp ("subEntryFrag");
d111 1
a111 1
   new WitSubEntry (theBomEnt, thePart);
d113 3
a115 3
   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBomEntry  (NULL);
   }
d120 29
a148 29
      const char * dupOperationName,
      int          dupBomEntryIndex,
      int          dupSubsBomEntryIndex,
      WitRun *     origWitRun,
      const char * origOperationName,
      int          origBomEntryIndex,
      int          origSubsBomEntryIndex)
   {
   startCopyObjData (origWitRun);

   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("subEntryFrag"));

   WitSubEntryApiCall dupCall  (
      this,
      dupOperationName,
      dupBomEntryIndex,
      dupSubsBomEntryIndex);

   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("subEntryFrag"));

   WitSubEntryApiCall origCall  (
      origWitRun,
      origOperationName,
      origBomEntryIndex,
      origSubsBomEntryIndex);

   if (dupCall.mySub () == origCall.mySub ())
      myMsgFac () ("copyObjectToSelfSmsg",
         myMsgFac ().myFrag ("subEntryFrag"));
d150 2
a151 2
   dupCall.mySub ()->copyAttrsFrom (origCall.mySub ());
   }
d156 22
a177 22
      char * * consumingOperationName,
      int *    bomEntryIndex,
      int *    subsBomEntryIndex)
   {
   WitSubEntry * theSub;

   myApiMgr_->startInnerFunc ();

   theSub =
      curItrDelCompForGet (WitAT_SUB_ENTRY, "subEntryFrag")->
         thisSub ();

   stronglyAssert (theSub != NULL);

   apiGet (
      consumingOperationName, 
      "consumingOperationName", 
      theSub->myOperationName ());

   apiGet (bomEntryIndex,     "bomEntryIndex",     theSub->myBomEntIndex ());
   apiGet (subsBomEntryIndex, "subsBomEntryIndex", theSub->localIndex ());
   }
d182 10
a191 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      void * *     appData)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d193 2
a194 2
   apiGet (appData, "appData", theCall.mySub ()->appData ());
   }
d199 10
a208 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & consRate)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d210 2
a211 2
   apiGet (consRate, "consRate", theCall.mySub ()->consRate ());
   }
d216 16
a231 16
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      char * *     consumedPartName )
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (
       consumedPartName, 
      "consumedPartName", 
      theCall.mySub ()->myPartName ());
   }
d236 15
a250 15
     const char * consumingOperationName,
     int          bomEntryIndex,
     int          subsBomEntryIndex,
     int *        earliestPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (             earliestPeriod, 
                       "earliestPeriod", 
      theCall.mySub ()->earliestPeriod ());
   }
d255 10
a264 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOSRealArg & execPenalty)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d266 2
a267 2
   apiGet (execPenalty, "execPenalty", theCall.mySub ()->execPenalty ());
   }
d272 10
a281 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * expAllowed)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d283 2
a284 2
   apiGet (expAllowed, "expAllowed", theCall.mySub ()->expAllowed ());
   }
d289 15
a303 15
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOSRealArg & expNetAversion)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (             expNetAversion, 
                       "expNetAversion", 
      theCall.mySub ()->expNetAversion ());
   }
d308 21
a328 21
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int *        fallout)
   {
   double theFalloutRate;

   myApiMgr_->startInnerFunc ();

   myMsgFac () (
      "getPre50AttrMsg",
      apiFuncName (),
      "subEntry",
      "fallout",
      "falloutRate");

   witGetSubsBomEntryFalloutRate (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      & theFalloutRate);
d330 2
a331 2
   apiGet (fallout, "fallout", fracToPercent (theFalloutRate));
   }
d336 10
a345 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOSRealArg & falloutRate)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d347 2
a348 2
   apiGet (falloutRate, "falloutRate", theCall.mySub ()->falloutRate ());
   }
d353 10
a362 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & fssSubVol)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d364 1
a364 1
   forbidStochMode ();
d366 1
a366 1
   myProblem ()->computeFssIfNeeded ();
d368 2
a369 2
   apiGet (fssSubVol, "fssSubVol", theCall.mySub ()->fssSubVol ());
   }
d374 10
a383 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int **       impactPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d385 1
a385 1
   myProblem ()->myPreprocessor ()->preprocess ();
d387 2
a388 2
   apiGet (impactPeriod, "impactPeriod", theCall.mySub ()->impactPeriod ());
   }
d393 10
a402 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * intSubVols)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d404 2
a405 2
   apiGet (intSubVols, "intSubVols", theCall.mySub ()->intSubVols ());
   }
d410 10
a419 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int *        latestPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d421 2
a422 2
   apiGet (latestPeriod, "latestPeriod", theCall.mySub ()->latestPeriod ());
   }
d427 10
a436 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * mrpNetAllowed )
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d438 2
a439 2
   apiGet (mrpNetAllowed, "mrpNetAllowed", theCall.mySub ()->mrpNetAllowed ());
   }
d444 10
a453 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & mrpSubVol)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d455 2
a456 2
   apiGet (mrpSubVol, "mrpSubVol", theCall.mySub ()->mrpSubVol ());
   }
d461 10
a470 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * netAllowed )
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d472 2
a473 2
   apiGet (netAllowed, "netAllowed", theCall.mySub ()->netAllowed ());
   }
d478 21
a498 21
     const char *         consumingOperationName,
     int                  bomEntryIndex,
     int                  subsBomEntryIndex,
     const WitOVRealArg & obj1SubCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "substitute BOM entry",
         "obj1SubCost",
         "subCost");

   witGetSubsBomEntrySubCost (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      obj1SubCost);
   }
d503 10
a512 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & offset)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d514 2
a515 2
   apiGet (offset, "offset", theCall.mySub ()->offset ());
   }
d520 15
a534 15
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & prodVol)
   {
   myApiMgr_->startInnerFunc ();

   prepGet34Attr ("SubsBomEntry", "prodVol", "SubsBomEntry", "subVol");

   witGetSubsBomEntrySubVol (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      prodVol);
   }
d539 10
a548 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & routingShare)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d550 2
a551 2
   apiGet (routingShare, "routingShare", theCall.mySub ()->routingShare ());
   }
d556 10
a565 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean * selForDel)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d567 2
a568 2
   apiGet (selForDel, "selForDel", theCall.mySub ()->selForDel ());
   }
d573 15
a587 15
     const char *         consumingOperationName,
     int                  bomEntryIndex,
     int                  subsBomEntryIndex,
     const WitOVRealArg & subCost)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (             subCost, 
                       "subCost", 
      theCall.mySub ()->subCost ());
   }
d592 21
a612 21
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      const int    thePer,
      int *        subVarIndex)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   prepGetIndex (thePer);

   apiGet (
       subVarIndex,
      "subVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            subVarIndex (theCall.mySub (), thePer));
   }
d617 10
a626 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOVRealArg & subVol)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d628 2
a629 2
   apiGet (subVol, "subVol", theCall.mySub ()->subVol ());
   }
d634 22
a655 22
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitOSRealArg & usageRate)
   {
   double * consRateCVec;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "substitute BOM entry",
         "usageRate",
         "consRate");

   witGetSubsBomEntryConsRate (
      consumingOperationName, 
      bomEntryIndex, 
      subsBomEntryIndex,
      & consRateCVec);
d657 1
a657 1
   forbidNullArg (usageRate, "usageRate");
d659 1
a659 1
   usageRate = consRateCVec[0];
d661 2
a662 2
   free (consRateCVec);
   }
d667 10
a676 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      void *       appData)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d678 2
a679 2
   theCall.setAppData (appData);
   }
d684 16
a699 16
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & consRate)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepDblVec ("consRate", consRate);

   if (theCall.argsOK ())
      theCall.mySub ()->setConsRate (consRate);
   }
d704 10
a713 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int          earliestPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d715 2
a716 2
   theCall.setEarliestPeriod (earliestPeriod);
   }
d721 19
a739 19
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & execPenalty)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepNonNegDouble (
      "execPenalty", 
      theCall.mySub ()->execPenalty (),
      execPenalty);

   if (theCall.argsOK ())
      theCall.mySub ()->setExecPenalty (execPenalty);
   }
d744 19
a762 19
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   expAllowed)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepBool (
                       "expAllowed", 
      theCall.mySub ()->expAllowed (), 
                        expAllowed);

   if (theCall.argsOK ())
      theCall.mySub ()->setExpAllowed (asaBool (expAllowed));
   }
d767 19
a785 19
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & expNetAversion)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepDouble (
      "expNetAversion", 
      theCall.mySub ()->expNetAversion (), 
      expNetAversion);

   if (theCall.argsOK ())
      theCall.mySub ()->setExpNetAversion (expNetAversion);
   }
d790 20
a809 20
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int          fallout)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () (
      "setPre50AttrMsg",
      apiFuncName (),
      "subEntry",
      "fallout",
      "falloutRate");

   witSetSubsBomEntryFalloutRate (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      percentToFrac (fallout));
   }
d814 21
a834 21
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & falloutRate)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepNonNegUBDouble (
      "falloutRate", 
      theCall.mySub ()->falloutRate (), 
      falloutRate,
      0.99 + FLOAT_EPSILON,
      0.99);

   if (theCall.argsOK ())
      theCall.mySub ()->setFalloutRate (falloutRate);
   }
d839 19
a857 19
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   intSubVols)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepBool (
                       "intSubVols", 
      theCall.mySub ()->intSubVols (), 
                        intSubVols);

   if (theCall.argsOK ())
      theCall.mySub ()->setIntSubVols (asaBool (intSubVols));
   }
d862 10
a871 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      int          latestPeriod)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d873 2
a874 2
   theCall.setLatestPeriod (latestPeriod);
   }
d879 19
a897 19
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   mrpNetAllowed)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepBool (
      "mrpNetAllowed", 
      theCall.mySub ()->mrpNetAllowed (), 
      mrpNetAllowed);

   if (theCall.argsOK ())
      theCall.mySub ()->setMrpNetAllowed (asaBool (mrpNetAllowed));
   }
d902 19
a920 19
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   netAllowed)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepBool (
                       "netAllowed", 
      theCall.mySub ()->netAllowed (),
                        netAllowed);

   if (theCall.argsOK ())
      theCall.mySub ()->setNetAllowed (asaBool (netAllowed));
   }
d925 21
a945 21
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & obj1SubCost )
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "substitute BOM entry",
         "obj1SubCost",
         "subCost");

      witSetSubsBomEntrySubCost (
         consumingOperationName,
         bomEntryIndex,
         subsBomEntryIndex,
         obj1SubCost);
   }
d950 10
a959 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & offset)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d961 2
a962 2
   theCall.setOffset (offset);
   }
d967 15
a981 15
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & prodVol)
   {
   myApiMgr_->startInnerFunc ();

   prepSet34Attr ("SubsBomEntry", "prodVol", "SubsBomEntry", "subVol");

   witSetSubsBomEntrySubVol (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      prodVol);
   }
d986 10
a995 10
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & routingShare)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d997 2
a998 2
   theCall.setRoutingShare (routingShare);
   }
d1003 10
a1012 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex,
      WitBoolean   selForDel)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);
d1014 2
a1015 2
   theCall.setSelForDel (selForDel);
   }
d1020 32
a1051 32
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & subCost )
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   WitPeriod thePer;

   theCall.prepDblVec ("subCost", subCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (subCost[thePer] < 0.0)
            myMsgFac () (
               "negSubCostWmsg",
               "subCost",
               consumingOperationName,
               bomEntryIndex,
               subsBomEntryIndex,
               theCall.mySub ()->myPartName (),
               subCost[thePer],
               thePer);

      theCall.mySub ()->setSubCost (subCost);
      }
   }
d1056 16
a1071 16
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitIVRealArg & subVol)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepNonNegDblVec ("subVol", subVol);

   if (theCall.argsOK ())
      theCall.mySub ()->setSubVol (subVol);
   }
d1076 24
a1099 24
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & usageRate)
   {
   WitTVec <double> & consRateVec = myApiMgr ()->reserveTempDblVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "substitute BOM entry",
         "usageRate",
         "consRate");

   consRateVec = usageRate;

   witSetSubsBomEntryConsRate (
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex,
      consRateVec.myCVec ());
d1101 2
a1102 2
   myApiMgr ()->releaseTempVecs ();
   }
d1110 6
a1115 6
      const char * operationName,
      int          bomEntryIndex,
      int          subsBomEntryIndex)
   {
   WitSubEntry * retVal;
   WitBomEntry * entryP;
d1117 1
a1117 1
   entryP = getBomEntryP (operationName, bomEntryIndex);
d1119 2
a1120 2
   if (entryP->mySubEntries ().isEmpty ())
      myMsgFac () ("bomEntryWoSubsSmsg");
d1122 6
a1127 6
   if (  subsBomEntryIndex < 0 or
         subsBomEntryIndex >= entryP->mySubEntries ().nElements ())
      myMsgFac () ("subsBomEntryIndexRangeSmsg",
         subsBomEntryIndex,
         0,
         entryP->mySubEntries ().nElements ());
d1129 1
a1129 1
   retVal = myCompMgr ()->findSubEntry (entryP, subsBomEntryIndex);
d1131 1
a1131 1
   witAssert (retVal != NULL);
d1133 1
a1133 1
   myInputID ()->setMySubEntry (retVal);
d1135 2
a1136 2
   return retVal;
   }
@


1.84
log
@Multi-Obj Mode
@
text
@d28 1
a28 1
#include <Opn.h>
@


1.83
log
@Removing objective #2.
@
text
@d825 9
a833 1
   theCall.setFalloutRate (falloutRate);
@


1.82
log
@Removing objective #2.
@
text
@d1032 1
a1032 1
               "negSubObj1CostCoef",
@


1.81
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@a501 19
void WitRun::witGetSubsBomEntryObj2SubPenalty (
     const char *         consumingOperationName,
     int                  bomEntryIndex,
     int                  subsBomEntryIndex,
     const WitOSRealArg & obj2SubPenalty)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   apiGet (             obj2SubPenalty, 
                       "obj2SubPenalty", 
      theCall.mySub ()->obj2SubPenalty ());
   }

//------------------------------------------------------------------------------

a940 23
void WitRun::witSetSubsBomEntryObj2SubPenalty (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      int                  subsBomEntryIndex,
      const WitISRealArg & obj2SubPenalty)
   {
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subsBomEntryIndex);

   theCall.prepNonNegDouble (
      "obj2SubPenalty", 
      theCall.mySub ()->obj2SubPenalty (), 
      obj2SubPenalty);

   if (theCall.argsOK ())
      theCall.mySub ()->setObj2SubPenalty (obj2SubPenalty);
   }

//------------------------------------------------------------------------------

@


1.80
log
@Stochastic Implosion
@
text
@d34 2
@


1.79
log
@Stochastic Implosion
@
text
@d362 2
@


1.78
log
@Stochastic Implosion
@
text
@a642 2
   theCall.prepGetStochSolnAttr ("subVol");

@


1.77
log
@Stochastic Implosion.
@
text
@d25 1
a25 1
#include <OptImp.h>
d624 1
a624 1
      myOptImploder ()->
@


1.76
log
@Stochastic Implosion
@
text
@d643 2
a645 2

   theCall.issueScenMsg ();
@


1.75
log
@Stochastic Implosion
@
text
@a1098 2
   theCall.prepStochAttr ();

@


1.74
log
@Stochastic Implosion.
@
text
@d644 2
d1099 2
@


1.73
log
@Stochastic implosion.
@
text
@d107 2
@


1.72
log
@Stochastic implosion.
@
text
@a106 2
   forbidAddStochAct ("subEntryFrag");

@


1.71
log
@witCopy<Object>Data
@
text
@d107 2
@


1.70
log
@witCopy<Object>Data
@
text
@d116 1
a116 1
      const char * dupConsumingOperationName,
d120 1
a120 1
      const char * origConsumingOperationName,
d130 1
a130 1
      dupConsumingOperationName,
d138 1
a138 1
      origConsumingOperationName,
@


1.69
log
@External opt implosion.
@
text
@d31 1
d115 36
@


1.68
log
@External opt implosion.
@
text
@d26 1
a26 1
#include <ExtOptHand.h>
d586 1
a586 1
         myExtOptHandler ()->
@


1.67
log
@External opt implosion.
@
text
@d572 1
a572 1
      int *        colIndex)
d583 2
a584 2
       colIndex,
      "colIndex",
@


1.66
log
@External opt implosion.
@
text
@d580 1
a580 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
@


1.65
log
@External opt implosion.
@
text
@d25 2
d41 1
a41 1
      int          subBomEntryIndex)
d52 1
a52 1
      myMsgFac () ("subsBomEntryIndexMsg", subBomEntryIndex );
d54 1
a54 1
   return getSubBomEntryP (operationName, bomEntryIndex, subBomEntryIndex);
d143 1
a143 1
      int          subBomEntryIndex,
d150 1
a150 1
      subBomEntryIndex);
d160 1
a160 1
      int                  subBomEntryIndex,
d167 1
a167 1
      subBomEntryIndex);
d177 1
a177 1
      int          subBomEntryIndex,
d184 1
a184 1
      subBomEntryIndex);
d197 1
a197 1
     int          subBomEntryIndex,
d204 1
a204 1
      subBomEntryIndex);
d216 1
a216 1
      int                  subBomEntryIndex,
d223 1
a223 1
      subBomEntryIndex);
d233 1
a233 1
      int          subBomEntryIndex,
d240 1
a240 1
      subBomEntryIndex);
d250 1
a250 1
      int                  subBomEntryIndex,
d257 1
a257 1
      subBomEntryIndex);
d269 1
a269 1
      int          subBomEntryIndex,
d286 1
a286 1
      subBomEntryIndex,
d297 1
a297 1
      int                  subBomEntryIndex,
d304 1
a304 1
      subBomEntryIndex);
d314 1
a314 1
      int                  subBomEntryIndex,
d321 1
a321 1
      subBomEntryIndex);
d333 1
a333 1
      int          subBomEntryIndex,
d340 1
a340 1
      subBomEntryIndex);
d352 1
a352 1
      int          subBomEntryIndex,
d359 1
a359 1
      subBomEntryIndex);
d369 1
a369 1
      int          subBomEntryIndex,
d376 1
a376 1
      subBomEntryIndex);
d386 1
a386 1
      int          subBomEntryIndex,
d393 1
a393 1
      subBomEntryIndex);
d403 1
a403 1
      int                  subBomEntryIndex,
d410 1
a410 1
      subBomEntryIndex);
d420 1
a420 1
      int          subBomEntryIndex,
d427 1
a427 1
      subBomEntryIndex);
d437 1
a437 1
     int                  subBomEntryIndex,
d453 1
a453 1
      subBomEntryIndex,
d462 1
a462 1
     int                  subBomEntryIndex,
d469 1
a469 1
      subBomEntryIndex);
d481 1
a481 1
      int                  subBomEntryIndex,
d488 1
a488 1
      subBomEntryIndex);
d498 1
a498 1
      int                  subBomEntryIndex,
d508 1
a508 1
      subBomEntryIndex,
d517 1
a517 1
      int                  subBomEntryIndex,
d524 1
a524 1
      subBomEntryIndex);
d534 1
a534 1
      int          subBomEntryIndex,
d541 1
a541 1
      subBomEntryIndex);
d551 1
a551 1
     int                  subBomEntryIndex,
d558 1
a558 1
      subBomEntryIndex);
d567 29
d599 1
a599 1
      int                  subBomEntryIndex,
d606 1
a606 1
      subBomEntryIndex);
d616 1
a616 1
      int                  subBomEntryIndex,
d634 1
a634 1
      subBomEntryIndex,
d649 1
a649 1
      int          subBomEntryIndex,
d656 1
a656 1
      subBomEntryIndex);
d666 1
a666 1
      int                  subBomEntryIndex,
d673 1
a673 1
      subBomEntryIndex);
d686 1
a686 1
      int          subBomEntryIndex,
d693 1
a693 1
      subBomEntryIndex);
d703 1
a703 1
      int                  subBomEntryIndex,
d710 1
a710 1
      subBomEntryIndex);
d726 1
a726 1
      int          subBomEntryIndex,
d733 1
a733 1
      subBomEntryIndex);
d749 1
a749 1
      int                  subBomEntryIndex,
d756 1
a756 1
      subBomEntryIndex);
d772 1
a772 1
      int          subBomEntryIndex,
d787 1
a787 1
      subBomEntryIndex,
d796 1
a796 1
      int                  subBomEntryIndex,
d803 1
a803 1
      subBomEntryIndex);
d813 1
a813 1
      int          subBomEntryIndex,
d820 1
a820 1
      subBomEntryIndex);
d836 1
a836 1
      int          subBomEntryIndex,
d843 1
a843 1
      subBomEntryIndex);
d853 1
a853 1
      int          subBomEntryIndex,
d860 1
a860 1
      subBomEntryIndex);
d876 1
a876 1
      int          subBomEntryIndex,
d883 1
a883 1
      subBomEntryIndex);
d899 1
a899 1
      int                  subBomEntryIndex,
d915 1
a915 1
         subBomEntryIndex,
d924 1
a924 1
      int                  subBomEntryIndex,
d931 1
a931 1
      subBomEntryIndex);
d947 1
a947 1
      int                  subBomEntryIndex,
d954 1
a954 1
      subBomEntryIndex);
d964 1
a964 1
      int                  subBomEntryIndex,
d974 1
a974 1
      subBomEntryIndex,
d983 1
a983 1
      int                  subBomEntryIndex,
d990 1
a990 1
      subBomEntryIndex);
d1000 1
a1000 1
      int          subBomEntryIndex,
d1007 1
a1007 1
      subBomEntryIndex);
d1017 1
a1017 1
      int                  subBomEntryIndex,
d1024 1
a1024 1
      subBomEntryIndex);
d1039 1
a1039 1
               subBomEntryIndex,
d1053 1
a1053 1
      int                  subBomEntryIndex,
d1060 1
a1060 1
      subBomEntryIndex);
d1073 1
a1073 1
      int                  subBomEntryIndex,
d1093 1
a1093 1
      subBomEntryIndex,
d1107 1
a1107 1
      int          subBomEntryIndex)
d1117 2
a1118 2
   if (  subBomEntryIndex < 0 or
         subBomEntryIndex >= entryP->mySubEntries ().nElements ())
d1120 1
a1120 1
         subBomEntryIndex,
d1124 1
a1124 1
   retVal = myCompMgr ()->findSubEntry (entryP, subBomEntryIndex);
@


1.64
log
@External opt implosion.
@
text
@d66 2
d119 5
a123 1
   theSub = curItrDelCompForGet (WitAT_SUB_ENTRY, "subEntryFrag")->thisSub ();
d272 2
d438 2
d499 2
d590 2
d744 2
d871 2
d936 2
d1047 2
@


1.63
log
@App controlled opt implosion.
@
text
@d339 1
a339 1
void WitRun::witGetSubsBomEntryIntConSubVols (
d343 1
a343 1
      WitBoolean * intConSubVols)
d351 1
a351 1
   apiGet (intConSubVols, "intConSubVols", theCall.mySub ()->intConSubVols ());
d763 1
a763 1
void WitRun::witSetSubsBomEntryIntConSubVols (
d767 1
a767 1
      WitBoolean   intConSubVols)
d776 3
a778 3
                       "intConSubVols", 
      theCall.mySub ()->intConSubVols (), 
                        intConSubVols);
d781 1
a781 1
      theCall.mySub ()->setIntConSubVols (asaBool (intConSubVols));
@


1.62
log
@App controlled opt implosion.
@
text
@d24 1
d332 1
a332 1
   myProblem ()->preprocess ();
@


1.61
log
@App controlled opt implosion.
@
text
@a60 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a113 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a136 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a153 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a170 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a190 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a209 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a226 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a243 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a262 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a288 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a305 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a324 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a343 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a360 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a377 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a394 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a411 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a428 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a451 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a470 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a487 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a504 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a521 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a538 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a557 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a574 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a605 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a622 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a642 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a659 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a682 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a705 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a728 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a750 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a767 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a790 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a807 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a830 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a853 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a876 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a899 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a916 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a933 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a950 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a967 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1003 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1023 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

@


1.60
log
@Integrality constraints.
@
text
@d61 4
d118 4
d145 4
d166 4
d187 4
d211 4
d234 4
d255 4
d276 4
d299 4
d329 4
d350 4
d373 4
d396 4
d417 4
d438 4
d459 4
d480 4
d501 4
d528 4
d551 4
d572 4
d593 4
d614 4
d635 4
d658 4
d679 4
d714 4
d735 4
d759 4
d780 4
d807 4
d834 4
d861 4
d887 4
d908 4
d935 4
d956 4
d983 4
d1010 4
d1037 4
d1064 4
d1085 4
d1106 4
d1127 4
d1148 4
d1188 4
d1212 4
@


1.59
log
@Integrality constraints.
@
text
@d338 1
a338 1
void WitRun::witGetSubsBomEntryIntSubVols (
d342 1
a342 1
      WitBoolean * intSubVols)
d350 1
a350 1
   apiGet (intSubVols, "intSubVols", theCall.mySub ()->intSubVols ());
d762 1
a762 1
void WitRun::witSetSubsBomEntryIntSubVols (
d766 1
a766 1
      WitBoolean   intSubVols)
d775 3
a777 3
                       "intSubVols", 
      theCall.mySub ()->intSubVols (), 
                        intSubVols);
d780 1
a780 1
      theCall.mySub ()->setIntSubVols (asaBool (intSubVols));
@


1.58
log
@Opt implosion with integrality constraints.
@
text
@a29 2
#include <Global.h>

a773 3
   if (not myGlobalComp ()->allowIntVars ())
      myMsgFac () ("attNYASmsg", "intSubVols");

@


1.57
log
@Updated the copyright date on all source files.
@
text
@d30 2
d340 17
d764 26
@


1.56
log
@Removed code supporting the variable-argument-list API functions.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.55
log
@[multi-thread]
@
text
@a108 78
void WitRun::witAddSubsBomEntryVa (
      const char * operationName,
      int          bomIndex,
      const char * consumedPartName,
      va_list      argp)
   {
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   int            theSubIdx;
   WitAttr        theAttr;

   witAddSubsBomEntry (operationName, bomIndex, consumedPartName);

   if (argp == NULL)
      return;

   theOpn    = myCompMgr ()->findOperation (operationName);

   theBomEnt = myCompMgr ()->findBomEntry (theOpn, bomIndex);

   theSubIdx = theBomEnt->mySubEntries ().nElements () - 1;
      
   //--------------------------------------------------
   // Loop once for each attribute in calling sequence.
   //--------------------------------------------------

   for ( theAttr =  va_arg (argp, WitAttr);
         theAttr != NULL;
         theAttr =  va_arg (argp, WitAttr))
      {
      if (theAttr == WitNusageRate)
         witSetSubsBomEntryUsageRate (
            operationName,
            bomIndex,
            theSubIdx,
            va_arg (argp, double));

      else if (theAttr == WitNfallout)
         witSetSubsBomEntryFallout (
            operationName,
            bomIndex,
            theSubIdx,
            va_arg (argp, int));

      else if (theAttr == WitNearliestPeriod)
         witSetSubsBomEntryEarliestPeriod (
            operationName,
            bomIndex,
            theSubIdx,
            va_arg (argp, int));

      else if (theAttr == WitNlatestPeriod)
         witSetSubsBomEntryLatestPeriod (
            operationName,
            bomIndex,
            theSubIdx,
            va_arg (argp, int));

      else if (theAttr == WitNobj1SubCost)
         witSetSubsBomEntryObj1SubCost (
            operationName,
            bomIndex,
            theSubIdx,
            va_arg (argp, float *));

      else if (theAttr == WitNobj2SubPenalty)
         witSetSubsBomEntryObj2SubPenalty (
            operationName,
            bomIndex,
            theSubIdx,
            va_arg (argp, double));

      else myMsgFac () ("undefinedAttrErrorMsg");
      }
   }

//------------------------------------------------------------------------------

@


1.54
log
@[multi-thread]
@
text
@a29 2
#include <stdarg.h>

@


1.53
log
@[multi-thread]
@
text
@d59 1
a59 1
      const char * operationNameParm,
d61 1
a61 1
      const char * consumedPartNameParm)
d63 1
a63 17
   witAddSubsBomEntryVa (
      operationNameParm,
      bomIndex,
      consumedPartNameParm,
      NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witAddSubsBomEntryVa (
      const char * operationNameParm,
      int          bomIndex,
      const char * consumedPartNameParm,
      va_list      argp)
   {
   WitAttr        attr;
   WitPart *      consumedP;
d65 1
a65 2
   WitBomEntry *  origEntry;
   WitSubEntry *  newSubs;
d67 2
a68 2
   forbidNullArg (operationNameParm,    "operationName");
   forbidNullArg (consumedPartNameParm, "consumedPartName");
d72 1
a72 1
         operationNameParm,
d74 1
a74 1
         consumedPartNameParm);
d76 1
a76 1
   theOpn = myCompMgr ()->findOperation (operationNameParm);
d79 1
a79 1
      myMsgFac () ("undefinedOperationMsg", operationNameParm);
d92 1
a92 1
   origEntry = myCompMgr ()->findBomEntry (theOpn, bomIndex);
d94 1
a94 1
   witAssert (origEntry != NULL);
d96 1
a96 1
   myInputID ()->setMyBomEntry (origEntry);
d98 1
a98 1
   consumedP = myCompMgr ()->findPart (consumedPartNameParm);
d100 2
a101 55
   if (consumedP == NULL)
      myMsgFac () ("undefinedPartMsg", consumedPartNameParm);

   newSubs = new WitSubEntry (origEntry, consumedP);

    //--------------------------------------------------
    // Loop once for each attribute in calling sequence.
    //--------------------------------------------------

   if (argp != NULL)
      for ( attr =  va_arg (argp, WitAttr);
            attr != NULL;
            attr =  va_arg (argp, WitAttr))
         {
         if (attr == WitNusageRate)
            witSetSubsBomEntryUsageRate (
               newSubs->myOperationName ().myCstring (),
               newSubs->myBomEntIndex (),
               newSubs->localIndex (),
               va_arg (argp, double));

         else if (attr == WitNfallout)
            witSetSubsBomEntryFallout (
               newSubs->myOperationName ().myCstring (),
               newSubs->myBomEntIndex (),
               newSubs->localIndex (),
               va_arg (argp, int));

         else if (attr == WitNearliestPeriod)
            witSetSubsBomEntryEarliestPeriod (
               newSubs->myOperationName ().myCstring (),
               newSubs->myBomEntIndex (),
               newSubs->localIndex (),
               va_arg (argp, int));

         else if (attr == WitNlatestPeriod)
            witSetSubsBomEntryLatestPeriod (
               newSubs->myOperationName ().myCstring (),
               newSubs->myBomEntIndex (),
               newSubs->localIndex (),
               va_arg (argp, int));

         else if (attr == WitNobj1SubCost)
            witSetSubsBomEntryObj1SubCost (
               newSubs->myOperationName ().myCstring (),
               newSubs->myBomEntIndex (),
               newSubs->localIndex (),
               va_arg (argp, float *));

         else if (attr == WitNobj2SubPenalty)
            witSetSubsBomEntryObj2SubPenalty (
               newSubs->myOperationName ().myCstring (),
               newSubs->myBomEntIndex (),
               newSubs->localIndex (),
               va_arg (argp, double));
d103 1
a103 2
         else myMsgFac () ("undefinedAttrErrorMsg");
      }
d107 78
a184 1
   myInputID ()->setMySubEntry  (NULL);
@


1.52
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d30 2
@


1.51
log
@[multi-threads]
@
text
@a16 1
#include <ProEpilog.h>
d56 1
a56 1
WitReturnCode WitRun::witAddSubsBomEntry (
a60 9
   PROLOG("witAddSubsBomEntry");

   if (myApiMgr ()->calledByApp ())
      if (myMsgFac ().mayIssue ("parmsAsbeMsg"))
         myMsgFac () ("parmsAsbeMsg",
            operationNameParm,
            bomIndex,
            consumedPartNameParm);

a65 2

   EPILOG;
d70 1
a70 1
WitReturnCode WitRun::witAddSubsBomEntryVa (
a81 2
   PROLOG ("witAddSubsBomEntryVa");

d85 5
a89 6
   if (myApiMgr ()->calledByApp ())
      if (myMsgFac ().mayIssue ("parmsAsbeMsg"))
         myMsgFac () ("parmsAsbeMsg",
            operationNameParm,
            bomIndex,
            consumedPartNameParm);
a176 2

   EPILOG;
d181 1
a181 1
WitReturnCode WitRun::witGetObjItrSubsBomEntry (
a187 2
   PROLOG ("witGetObjItrSubsBomEntry");

a198 2

   EPILOG;
d203 1
a203 1
WitReturnCode WitRun::witGetSubsBomEntryAppData (
a208 2
   PROLOG ("witGetSubsBomEntryAppData");

a215 2

   EPILOG;
d220 1
a220 1
WitReturnCode WitRun::witGetSubsBomEntryConsRate (
a225 2
   PROLOG ("witGetSubsBomEntryConsRate");

a232 2

   EPILOG;
d237 1
a237 1
WitReturnCode WitRun::witGetSubsBomEntryConsumedPart (
a242 2
   PROLOG ("witGetSubsBomEntryConsumedPart");

a252 2

   EPILOG;
d257 1
a257 1
WitReturnCode WitRun::witGetSubsBomEntryEarliestPeriod (
a262 2
   PROLOG ("witGetSubsBomEntryEarliestPeriod");

a271 2

   EPILOG;
d276 1
a276 1
WitReturnCode WitRun::witGetSubsBomEntryExecPenalty (
a281 2
   PROLOG ("witGetSubsBomEntryExecPenalty");

a288 2

   EPILOG;
d293 1
a293 1
WitReturnCode WitRun::witGetSubsBomEntryExpAllowed (
a298 2
   PROLOG ("witGetSubsBomEntryExpAllowed");

a305 2

   EPILOG;
d310 1
a310 1
WitReturnCode WitRun::witGetSubsBomEntryExpNetAversion (
a315 2
   PROLOG ("witGetSubsBomEntryExpNetAversion");

a324 2

   EPILOG;
d329 1
a329 1
WitReturnCode WitRun::witGetSubsBomEntryFallout (
a334 2
   PROLOG ("witGetSubsBomEntryFallout");

a350 2

   EPILOG;
d355 1
a355 1
WitReturnCode WitRun::witGetSubsBomEntryFalloutRate (
a360 2
   PROLOG ("witGetSubsBomEntryFalloutRate");

a367 2

   EPILOG;
d372 1
a372 1
WitReturnCode WitRun::witGetSubsBomEntryFssSubVol (
a377 2
   PROLOG ("witGetSubsBomEntryFssSubVol");

a386 2

   EPILOG;
d391 1
a391 1
WitReturnCode WitRun::witGetSubsBomEntryImpactPeriod (
a396 2
   PROLOG ("witGetSubsBomEntryImpactPeriod");

a405 2

   EPILOG;
d410 1
a410 1
WitReturnCode WitRun::witGetSubsBomEntryLatestPeriod (
a415 2
   PROLOG ("witGetSubsBomEntryLatestPeriod");

a422 2

   EPILOG;
d427 1
a427 1
WitReturnCode WitRun::witGetSubsBomEntryMrpNetAllowed (
a432 2
   PROLOG ("witGetSubsBomEntryMrpNetAllowed");

a439 2

   EPILOG;
d444 1
a444 1
WitReturnCode WitRun::witGetSubsBomEntryMrpSubVol (
a449 2
   PROLOG ("witGetSubsBomEntryMrpSubVol");

a456 2

   EPILOG;
d461 1
a461 1
WitReturnCode WitRun::witGetSubsBomEntryNetAllowed (
a466 2
   PROLOG ("witGetSubsBomEntryNetAllowed");

a473 2

   EPILOG;
d478 1
a478 1
WitReturnCode WitRun::witGetSubsBomEntryObj1SubCost (
a483 2
   PROLOG ("witGetSubsBomEntryObj1SubCost");

a496 2

   EPILOG;
d501 1
a501 1
WitReturnCode WitRun::witGetSubsBomEntryObj2SubPenalty (
a506 2
   PROLOG ("witGetSubsBomEntryObj2SubPenalty");

a515 2

   EPILOG;
d520 1
a520 1
WitReturnCode WitRun::witGetSubsBomEntryOffset (
a525 2
   PROLOG ("witGetSubsBomEntryOffset");

a532 2

   EPILOG;
d537 1
a537 1
WitReturnCode WitRun::witGetSubsBomEntryProdVol (
a542 2
   PROLOG ("witGetSubsBomEntryProdVol");

a549 2

   EPILOG;
d554 1
a554 1
WitReturnCode WitRun::witGetSubsBomEntryRoutingShare (
a559 2
   PROLOG ("witGetSubsBomEntryRoutingShare");

a566 2

   EPILOG;
d571 1
a571 1
WitReturnCode WitRun::witGetSubsBomEntrySelForDel (
a576 2
   PROLOG ("witGetSubsBomEntrySelForDel");

a583 2

   EPILOG;
d588 1
a588 1
WitReturnCode WitRun::witGetSubsBomEntrySubCost (
a593 2
   PROLOG ("witGetSubsBomEntrySubCost");

a602 2

   EPILOG;
d607 1
a607 1
WitReturnCode WitRun::witGetSubsBomEntrySubVol (
a612 2
   PROLOG ("witGetSubsBomEntrySubVol");

a619 2

   EPILOG;
d624 1
a624 1
WitReturnCode WitRun::witGetSubsBomEntryUsageRate (
a629 2
   PROLOG ("witGetSubsBomEntryUsageRate");

a650 2

   EPILOG;
d655 1
a655 1
WitReturnCode WitRun::witSetSubsBomEntryAppData (
a660 2
   PROLOG ("witSetSubsBomEntryAppData");

a667 2

   EPILOG;
d672 1
a672 1
WitReturnCode WitRun::witSetSubsBomEntryConsRate (
a677 2
   PROLOG ("witSetSubsBomEntryConsRate");

a687 2

   EPILOG;
d692 1
a692 1
WitReturnCode WitRun::witSetSubsBomEntryEarliestPeriod (
a697 2
   PROLOG ("witSetSubsBomEntryEarliestPeriod");

a704 2

   EPILOG;
d709 1
a709 1
WitReturnCode WitRun::witSetSubsBomEntryExecPenalty (
a714 2
   PROLOG ("witSetSubsBomEntryExecPenalty");

a727 2

   EPILOG;
d732 1
a732 1
WitReturnCode WitRun::witSetSubsBomEntryExpAllowed (
a737 2
   PROLOG ("witSetSubsBomEntryExpAllowed");

a750 2

   EPILOG;
d755 1
a755 1
WitReturnCode WitRun::witSetSubsBomEntryExpNetAversion (
a760 2
   PROLOG ("witSetSubsBomEntryExpNetAversion");

a773 2

   EPILOG;
d778 1
a778 1
WitReturnCode WitRun::witSetSubsBomEntryFallout (
a783 2
   PROLOG ("witSetSubsBomEntryFallout");

a795 2

   EPILOG;
d800 1
a800 1
WitReturnCode WitRun::witSetSubsBomEntryFalloutRate (
a805 2
   PROLOG ("witSetSubsBomEntryFalloutRate");

a812 2

   EPILOG;
d817 1
a817 1
WitReturnCode WitRun::witSetSubsBomEntryLatestPeriod (
a822 2
   PROLOG ("witSetSubsBomEntryLatestPeriod");

a829 2

   EPILOG;
d834 1
a834 1
WitReturnCode WitRun::witSetSubsBomEntryMrpNetAllowed (
a839 2
   PROLOG ("witSetSubsBomEntryMrpNetAllowed");

a852 2

   EPILOG;
d857 1
a857 1
WitReturnCode WitRun::witSetSubsBomEntryNetAllowed (
a862 2
   PROLOG ("witSetSubsBomEntryNetAllowed");

a875 2

   EPILOG;
d880 1
a880 1
WitReturnCode WitRun::witSetSubsBomEntryObj1SubCost (
a885 2
   PROLOG ("witSetSubsBomEntryObj1SubCost");

a898 2

   EPILOG;
d903 1
a903 1
WitReturnCode WitRun::witSetSubsBomEntryObj2SubPenalty (
a908 2
   PROLOG ("witSetSubsBomEntryObj2SubPenalty");

a921 2

   EPILOG;
d926 1
a926 1
WitReturnCode WitRun::witSetSubsBomEntryOffset (
a931 2
   PROLOG ("witSetSubsBomEntryOffset");

a938 2

   EPILOG;
d943 1
a943 1
WitReturnCode WitRun::witSetSubsBomEntryProdVol (
a948 2
   PROLOG ("witSetSubsBomEntryProdVol");

a955 2

   EPILOG;
d960 1
a960 1
WitReturnCode WitRun::witSetSubsBomEntryRoutingShare (
a965 2
   PROLOG ("witSetSubsBomEntryRoutingShare");

a972 2

   EPILOG;
d977 1
a977 1
WitReturnCode WitRun::witSetSubsBomEntrySelForDel (
a982 2
   PROLOG ("witSetSubsBomEntrySelForDel");

a989 2

   EPILOG;
d994 1
a994 1
WitReturnCode WitRun::witSetSubsBomEntrySubCost (
a999 2
   PROLOG ("witSetSubsBomEntrySubCost");

a1025 2

   EPILOG;
d1030 1
a1030 1
WitReturnCode WitRun::witSetSubsBomEntrySubVol (
a1035 2
   PROLOG ("witSetSubsBomEntrySubVol");

a1045 2

   EPILOG;
d1050 1
a1050 1
WitReturnCode WitRun::witSetSubsBomEntryUsageRate (
a1055 2
   PROLOG ("witSetSubsBomEntryUsageRate");

a1074 2

   EPILOG;
@


1.50
log
@[exceptions]
@
text
@d64 1
a64 1
   if (myApiMgr ()->applicationCalled ())
d99 1
a99 1
   if (myApiMgr ()->applicationCalled ())
@


1.49
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@d17 1
d19 1
d111 1
a111 1
   myInputId ()->setMyOperation (theOpn);
d126 1
a126 1
   myInputId ()->setMyBomEntry (origEntry);
d189 3
a191 3
   myInputId ()->setMyOperation (NULL);
   myInputId ()->setMyBomEntry  (NULL);
   myInputId ()->setMySubEntry  (NULL);
d1303 1
a1303 1
   myInputId ()->setMySubEntry (retVal);
@


1.48
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d565 9
a573 2
   WitSubEntryApiCall theCall (
      this,
d576 2
a577 5
      subBomEntryIndex);

   apiGet (             obj1SubCost, 
                       "obj1SubCost", 
      theCall.mySub ()->obj1SubCost ());
d691 23
d1047 7
a1053 5
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subBomEntryIndex);
d1055 5
a1059 20
   WitPeriod thePer;

   theCall.prepDblVec ("obj1SubCost", obj1SubCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (obj1SubCost[thePer] < 0.0)
            myMsgFac () (
               "negSubObj1CostCoef",
               "obj1SubCost",
               consumingOperationName,
               bomEntryIndex,
               subBomEntryIndex,
               theCall.mySub ()->myPartName (),
               obj1SubCost[thePer],
               thePer);

      theCall.mySub ()->setObj1SubCost (obj1SubCost);
      }
d1177 40
@


1.47
log
@Vector PropRtg.
@
text
@d571 1
a571 1
   apiGetObj1Vector (   obj1SubCost, 
d1028 1
a1028 1
   theCall.prepObj1Vec ("obj1SubCost", obj1SubCost);
@


1.46
log
@Vector PropRt.
@
text
@d716 1
a716 1
   double * consRateVal;
d730 1
a730 1
      & consRateVal);
d734 1
a734 1
   usageRate = consRateVal[0];
d736 1
a736 1
   free (consRateVal);
d1195 1
a1195 1
   WitTVec <double> & consRateVal = myApiMgr ()->reserveTempDblVec ();
d1205 1
a1205 1
   consRateVal = usageRate;
d1211 1
a1211 1
      consRateVal.myCVec ());
@


1.45
log
@Minor change.
@
text
@d19 4
a22 4
#include <InScalRA.h>
#include <OutScalRA.h>
#include <InVecRA.h>
#include <OutVecRA.h>
d244 4
a247 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitOutVecRA & consRate)
d315 1
a315 1
      const WitOutScalRA & execPenalty)
d357 1
a357 1
      const WitOutScalRA & expNetAversion)
d410 1
a410 1
      const WitOutScalRA & falloutRate)
d428 4
a431 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitOutVecRA & fssSubVol)
d516 4
a519 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitOutVecRA & mrpSubVol)
d558 4
a561 4
     const char *        consumingOperationName,
     int                 bomEntryIndex,
     int                 subBomEntryIndex,
     const WitOutVecRA & obj1SubCost)
d584 1
a584 1
     const WitOutScalRA & obj2SubPenalty)
d604 4
a607 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitOutVecRA & offset)
d625 4
a628 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitOutVecRA & prodVol)
d646 4
a649 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitOutVecRA & routingShare)
d688 4
a691 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitOutVecRA & subVol)
d712 1
a712 1
      const WitOutScalRA & usageRate)
d765 4
a768 4
      const char * consumingOperationName,
      int                bomEntryIndex,
      int                subBomEntryIndex,
      const WitInVecRA & consRate)
d810 4
a813 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitInScalRA & execPenalty)
d864 4
a867 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitInScalRA & expNetAversion)
d917 4
a920 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitInScalRA & falloutRate)
d1013 4
a1016 4
      const char *       consumingOperationName,
      int                bomEntryIndex,
      int                subBomEntryIndex,
      const WitInVecRA & obj1SubCost )
d1053 4
a1056 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitInScalRA & obj2SubPenalty)
d1080 4
a1083 4
      const char *       consumingOperationName,
      int                bomEntryIndex,
      int                subBomEntryIndex,
      const WitInVecRA & offset)
d1101 4
a1104 4
      const char *       consumingOperationName,
      int                bomEntryIndex,
      int                subBomEntryIndex,
      const WitInVecRA & prodVol)
d1122 4
a1125 4
      const char *       consumingOperationName,
      int                bomEntryIndex,
      int                subBomEntryIndex,
      const WitInVecRA & routingShare)
d1164 4
a1167 4
      const char *       consumingOperationName,
      int                bomEntryIndex,
      int                subBomEntryIndex,
      const WitInVecRA & subVol)
d1188 4
a1191 4
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      int                 subBomEntryIndex,
      const WitInScalRA & usageRate)
@


1.44
log
@Removed portableFree.
@
text
@a26 1
#include <wit.h>
@


1.43
log
@Double Precision.
@
text
@d737 1
a737 1
   portableFree (consRateVal);
@


1.42
log
@Double Precision.
@
text
@d735 1
a735 1
   usageRate.setTo (consRateVal[0]);
d1206 1
a1206 1
   consRateVal.setToScalar (usageRate);
@


1.41
log
@Double Precision.
@
text
@d626 4
a629 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float * *    prodVol)
d1102 4
a1105 4
      const char *  consumingOperationName,
      int           bomEntryIndex,
      int           subBomEntryIndex,
      const float * prodVol)
@


1.40
log
@Double Precision.
@
text
@d710 4
a713 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float *      usageRate)
d717 1
a717 1
   float * consRateVal;
d735 1
a735 1
   * usageRate = consRateVal[0];
d1189 4
a1192 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float        usageRate)
d1196 1
a1196 1
   WitTVec <float> & consRateVal = myApiMgr ()->reserveTempFloatVec ();
@


1.39
log
@Double Precision.
@
text
@d22 1
d245 4
a248 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float * *    consRate)
d429 4
a432 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float * *    fssSubVol)
d517 4
a520 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float * *    mrpSubVol)
d559 4
a562 4
     const char * consumingOperationName,
     int          bomEntryIndex,
     int          subBomEntryIndex,
     float * *    obj1SubCost)
d605 4
a608 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float * *    offset )
d647 4
a650 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float * *    routingShare)
d689 4
a692 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float * *    subVol)
@


1.38
log
@Double Precision.
@
text
@d21 1
d766 3
a768 3
      int           bomEntryIndex,
      int           subBomEntryIndex,
      const float * consRate)
d1013 4
a1016 4
      const char *  consumingOperationName,
      int           bomEntryIndex,
      int           subBomEntryIndex,
      const float * obj1SubCost )
d1080 4
a1083 4
      const char *  consumingOperationName,
      int           bomEntryIndex,
      int           subBomEntryIndex,
      const float * offset)
d1122 4
a1125 4
      const char *  consumingOperationName,
      int           bomEntryIndex,
      int           subBomEntryIndex,
      const float * routingShare)
d1164 4
a1167 4
      const char *  consumingOperationName,
      int           bomEntryIndex,
      int           subBomEntryIndex,
      const float * subVol )
@


1.37
log
@Double Precision.
@
text
@d629 11
a639 11
   return
      getSubBomEntry34Attribute (
         consumingOperationName,
         bomEntryIndex,
         subBomEntryIndex,
         "witGetSubsBomEntryProdVol",
         WitNprodVol,
         "SubsBomEntry",
         "subVol",
         & WitRun::witGetSubsBomEntrySubVol,
         prodVol);
d1105 11
a1115 11
   return
      setSubBomEntry34Attribute (
         consumingOperationName,
         bomEntryIndex,
         subBomEntryIndex,
         "witSetSubsBomEntryProdVol",
         WitNprodVol,
         "SubsBomEntry",
         "subVol",
         & WitRun::witSetSubsBomEntrySubVol,
         prodVol);
a1248 108
   }

//------------------------------------------------------------------------------
// getSubsBomEntry34Attribute
// Do the work of the witGetSubsBomEntry* functions for attributes that
// were renamed.
//------------------------------------------------------------------------------

WitReturnCode WitRun::getSubBomEntry34Attribute (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      const char * witApiName,
      const char * the34Attribute,
      const char * the40Object,
      const char * the40Attribute,
      WitReturnCode (WitRun::*equivalentMethod) (
         const char *,
         int,
         int,
         float * *),
      float * *    retVal)
   {
   PROLOG (witApiName);

   const char * the34Object;

   the34Object = "SubsBomEntry";

   if (wit34Compatible ())
      {
      myMsgFac () ("getting34AttributeWithCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);

      (this->*equivalentMethod) (
         consumingOperationName,
         bomEntryIndex,
         subBomEntryIndex,
         retVal);
      }
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);

   EPILOG;
   }

//------------------------------------------------------------------------------
// setSubsBomEntry34Attribute
// Do the work of the witSetSubsBomEntry* functions for attributes that
// were renamed.
//------------------------------------------------------------------------------

WitReturnCode WitRun::setSubBomEntry34Attribute (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      const char * witApiName,
      const char * the34Attribute,
      const char * the40Object,
      const char * the40Attribute,
      WitReturnCode (WitRun::*equivalentMethod) (
         const char *,
         int,
         int,
         const float *),
      const float * inpVal)
   {
   PROLOG (witApiName);

   const char * the34Object;

   the34Object = "SubsBomEntry";

   if (wit34Compatible ())
      {
      myMsgFac () ("setting34AttributeWithCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);

      (this->*equivalentMethod) (
         consumingOperationName,
         bomEntryIndex,
         subBomEntryIndex,
         inpVal);
      }
   else
      {
      myMsgFac () ("setting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         the34Object,
         the34Attribute,
         the40Object,
         the40Attribute);
      }

   EPILOG;
@


1.36
log
@Double Precision.
@
text
@d570 1
a570 1
   witGetObj1Vector (   obj1SubCost, 
@


1.35
log
@Double Precision.
@
text
@d777 1
a777 1
   theCall.prepFloatVec ("consRate", consRate);
d1176 1
a1176 1
   theCall.prepNonNegFloatVec ("subVol", subVol);
@


1.34
log
@Double Precision.
@
text
@d311 4
a314 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      WitOutScalRA execPenalty)
d353 4
a356 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      WitOutScalRA expNetAversion)
d406 4
a409 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      WitOutScalRA falloutRate)
d580 4
a583 4
     const char * consumingOperationName,
     int          bomEntryIndex,
     int          subBomEntryIndex,
     WitOutScalRA obj2SubPenalty)
@


1.33
log
@Double Precision.
@
text
@d809 4
a812 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      WitInScalRA  execPenalty)
d863 4
a866 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      WitInScalRA  expNetAversion)
d916 4
a919 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      WitInScalRA  falloutRate)
d1052 4
a1055 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      WitInScalRA  obj2SubPenalty)
@


1.32
log
@Double Precision.
@
text
@d855 1
a855 1
      theCall.mySub ()->setExpAllowed (expAllowed);
d977 1
a977 1
      theCall.mySub ()->setMrpNetAllowed (mrpNetAllowed);
d1004 1
a1004 1
      theCall.mySub ()->setNetAllowed (netAllowed);
@


1.31
log
@Double Precision.
@
text
@d335 1
a335 1
      witBoolean * expAllowed)
d497 1
a497 1
      witBoolean * mrpNetAllowed )
d539 1
a539 1
      witBoolean * netAllowed )
d669 1
a669 1
      witBoolean * selForDel)
d839 1
a839 1
      witBoolean   expAllowed)
d961 1
a961 1
      witBoolean   mrpNetAllowed)
d988 1
a988 1
      witBoolean   netAllowed)
d1145 1
a1145 1
      witBoolean   selForDel)
@


1.30
log
@Double Precision.
@
text
@d1210 1
a1210 1
      consRateVal.myCvector ());
@


1.29
log
@Continued double precision.
@
text
@d314 1
a314 1
      OutScalRA    execPenalty)
d356 1
a356 1
      OutScalRA    expNetAversion)
d409 1
a409 1
      OutScalRA    falloutRate)
d583 1
a583 1
     OutScalRA    obj2SubPenalty)
d812 1
a812 1
      InScalRA     execPenalty)
d866 1
a866 1
      InScalRA     expNetAversion)
d919 1
a919 1
      InScalRA     falloutRate)
d1055 1
a1055 1
      InScalRA     obj2SubPenalty)
@


1.28
log
@Continued double precision.
@
text
@d19 2
a20 2
#include <RealSInArg.h>
#include <RealSOutArg.h>
d314 1
a314 1
      RealSOutArg  execPenalty)
d356 1
a356 1
      RealSOutArg  expNetAversion)
d409 1
a409 1
      RealSOutArg  falloutRate)
d583 1
a583 1
     RealSOutArg  obj2SubPenalty)
d812 1
a812 1
      RealSInArg   execPenalty)
d866 1
a866 1
      RealSInArg   expNetAversion)
d919 1
a919 1
      RealSInArg   falloutRate)
d1055 1
a1055 1
      RealSInArg   obj2SubPenalty)
@


1.27
log
@Continued double precision.
@
text
@d19 2
d314 1
a314 1
      float *      execPenalty)
d356 1
a356 1
      float *      expNetAversion)
d383 1
a383 1
   float theFalloutRate;
d409 1
a409 1
      float *      falloutRate)
d583 1
a583 1
     float *      obj2SubPenalty)
d812 1
a812 1
      float        execPenalty)
d828 1
a828 1
      theCall.mySub ()->setExecPenalty (doubleFromFloat (execPenalty));
d866 1
a866 1
      float        expNetAversion)
d882 1
a882 1
      theCall.mySub ()->setExpNetAversion (doubleFromFloat (expNetAversion));
d919 1
a919 1
      float        falloutRate)
d1055 1
a1055 1
      float        obj2SubPenalty)
d1071 1
a1071 1
      theCall.mySub ()->setObj2SubPenalty (doubleFromFloat (obj2SubPenalty));
@


1.26
log
@Continued double precision.
@
text
@d826 1
a826 1
      theCall.mySub ()->setExecPenalty (static_cast <double> (execPenalty));
d880 1
a880 2
      theCall.mySub ()->setExpNetAversion (
         static_cast <double> (expNetAversion));
d1069 1
a1069 2
      theCall.mySub ()->setObj2SubPenalty (
         static_cast <double> (obj2SubPenalty));
@


1.25
log
@Continued double precision.
@
text
@d820 1
a820 1
   theCall.prepNonNegStrDbl (
d826 1
a826 1
      theCall.mySub ()->setExecPenalty (StrDbl::convFloat (execPenalty));
d874 1
a874 1
   theCall.prepStrDbl (
d880 2
a881 1
      theCall.mySub ()->setExpNetAversion (StrDbl::convFloat (expNetAversion));
d1064 1
a1064 1
   theCall.prepNonNegStrDbl (
d1070 2
a1071 1
      theCall.mySub ()->setObj2SubPenalty (StrDbl::convFloat (obj2SubPenalty));
@


1.24
log
@Removed a bad function overload.
@
text
@d820 1
a820 1
   theCall.prepNonNegFloat (
d826 1
a826 1
      theCall.mySub ()->setExecPenalty (execPenalty);
d874 1
a874 1
   theCall.prepFloat (
d880 1
a880 1
      theCall.mySub ()->setExpNetAversion (expNetAversion);
d1063 1
a1063 1
   theCall.prepNonNegFloat (
d1069 1
a1069 1
      theCall.mySub ()->setObj2SubPenalty (obj2SubPenalty);
@


1.23
log
@Changed the routingShare attributes from scalars to vectors.
@
text
@d202 1
a202 1
   theSub = curItrDelCompForGet (WitAT_SUB_ENTRY, "subEntryFrag")->mySub ();
@


1.22
log
@Continued implementation of proportionate routing.
@
text
@d646 1
a646 1
      float *      routingShare)
d1119 4
a1122 4
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float        routingShare)
@


1.21
log
@Continued implementation of proportionate routing.
@
text
@a372 21
WitReturnCode WitRun::witGetSubsBomEntryExpShare (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float *      expShare)
   {
   PROLOG ("witGetSubsBomEntryExpShare");

   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subBomEntryIndex);

   apiGet (expShare, "expShare", theCall.mySub ()->expShare ());

   EPILOG;
   }

//------------------------------------------------------------------------------

d642 21
a886 21
WitReturnCode WitRun::witSetSubsBomEntryExpShare (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float        expShare)
   {
   PROLOG ("witSetSubsBomEntryExpShare");

   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subBomEntryIndex);

   theCall.setExpShare (expShare);

   EPILOG;
   }

//------------------------------------------------------------------------------

d1114 21
@


1.20
log
@Continued implementation of proportionate routing.
@
text
@d202 1
a202 1
   curItrDelCompForGet (WitAT_SUB_ENTRY, "subEntryFrag")->getSubEntry (theSub);
@


1.19
log
@Internal changes.
@
text
@d373 21
d881 21
@


1.18
log
@Internal changes.
@
text
@d111 1
a111 1
   if (bomIndex < 0 || bomIndex >= theOpn->bom ().nElements())
d1191 1
a1191 1
   if (  subBomEntryIndex < 0 ||
@


1.17
log
@Continued implementation of execPenalties on BOM entries and subs.
@
text
@d333 1
a333 1
      WitBoolean * expAllowed)
d495 1
a495 1
      WitBoolean * mrpNetAllowed )
d537 1
a537 1
      WitBoolean * netAllowed )
d646 1
a646 1
      WitBoolean * selForDel)
d816 1
a816 1
      WitBoolean   expAllowed)
d826 1
a826 1
   theCall.prepBoolean (
d938 1
a938 1
      WitBoolean   mrpNetAllowed)
d948 1
a948 1
   theCall.prepBoolean (
d965 1
a965 1
      WitBoolean   netAllowed)
d975 1
a975 1
   theCall.prepBoolean (
d1101 1
a1101 1
      WitBoolean   selForDel)
@


1.16
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d308 21
a718 21
WitReturnCode WitRun::witGetSubsBomEntryUsePenalty (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float *      usePenalty)
   {
   PROLOG ("witGetSubsBomEntryUsePenalty");

   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subBomEntryIndex);

   apiGet (usePenalty, "usePenalty", theCall.mySub ()->usePenalty ());

   EPILOG;
   }

//------------------------------------------------------------------------------

d785 27
a1168 27

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witSetSubsBomEntryUsePenalty (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      float        usePenalty)
   {
   PROLOG ("witSetSubsBomEntryUsePenalty");

   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subBomEntryIndex);

   theCall.prepNonNegFloat (
      "usePenalty", 
      theCall.mySub ()->usePenalty (),
      usePenalty);

   if (theCall.argsOK ())
      theCall.mySub ()->setUsePenalty (usePenalty);
@


1.15
log
@Began implementation of optimizing implosion with OSL V3.
@
text
@d698 21
d1142 27
@


1.14
log
@More minor changes for vacpp.

The compiler complains if member functions are passed without an ampersand:

1589c1589
<          WitRun::witSetOperationYield,
---
>          &WitRun::witSetOperationYield,

It complains if "friend" declarations don't also have the word "class":
diff -r1.1 MsgFrag.h
39,40c39,40
<       friend WitMsgArg;
<       friend WitMsgFacility;
---
>       friend class WitMsgArg;
>       friend class WitMsgFacility;

It now can't figure out that a statement after a loop may not be executed!
diff -r1.70 BuildAhd.C
575a576
>    return NULL; // unreachable, but compiler complains


It also complained about missing "template<>" in many cases,
but since this seems odd, we are just suppressing the message for now
(see config/p_power64v5).  This is an example of a change that was NOT
made, but (presumably) would have to be to avoid the compiler warning.
diff -r1.47 ConsMR.C
180a181
> template<>
@
text
@d615 1
a615 1
         &WitRun::witGetSubsBomEntrySubVol,
d1043 1
a1043 1
         &WitRun::witSetSubsBomEntrySubVol,
@


1.13
log
@Continued implementation of single-source.
@
text
@d615 1
a615 1
         WitRun::witGetSubsBomEntrySubVol,
d1043 1
a1043 1
         WitRun::witSetSubsBomEntrySubVol,
@


1.12
log
@Preliminary work on single source.
@
text
@d621 1
a621 1
WitReturnCode WitRun::witGetSubsBomEntrySubVol (
d625 1
a625 1
      float * *    subVol)
d627 1
a627 1
   PROLOG ("witGetSubsBomEntrySubVol");
d635 1
a635 1
   apiGet (subVol, "subVol", theCall.mySub ()->subVol ());
d642 1
a642 1
WitReturnCode WitRun::witGetSubsBomEntrySelForDel (
d646 1
a646 1
      WitBoolean * selForDel)
d648 1
a648 1
   PROLOG ("witGetSubsBomEntrySelForDel");
d656 1
a656 1
   apiGet (selForDel, "selForDel", theCall.mySub ()->selForDel ());
d1049 5
a1053 5
WitReturnCode WitRun::witSetSubsBomEntrySubVol (
      const char *  consumingOperationName,
      int           bomEntryIndex,
      int           subBomEntryIndex,
      const float * subVol )
d1055 1
a1055 1
   PROLOG ("witSetSubsBomEntrySubVol");
d1063 1
a1063 4
   theCall.prepNonNegFloatVec ("subVol", subVol);

   if (theCall.argsOK ())
      theCall.mySub ()->setSubVol (subVol);
d1070 5
a1074 5
WitReturnCode WitRun::witSetSubsBomEntrySelForDel (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          subBomEntryIndex,
      WitBoolean   selForDel)
d1076 1
a1076 1
   PROLOG ("witSetSubsBomEntrySelForDel");
d1084 4
a1087 1
   theCall.setSelForDel (selForDel);
@


1.11
log
@Continued preliminary work on single source.
@
text
@d1112 1
a1112 1
   consRateVal.setTo (usageRate);
@


1.10
log
@Continued implementation of object iteration.
@
text
@d1102 1
a1102 1
   WitTVec (float) & consRateVal = myApiMgr ()->reserveTempFloatVec ();
d1112 1
a1112 1
   consRateVal = usageRate;
@


1.9
log
@Continued implementation of object iteration.
@
text
@d193 1
a193 1
WitReturnCode WitRun::witGetItrSubsBomEntry (
d200 1
a200 1
   PROLOG ("witGetItrSubsBomEntry");
@


1.8
log
@Began implementation of object iteration.
@
text
@d23 1
d187 26
@


1.7
log
@Refactoring for constrained stock reallocation.
@
text
@d11 1
a11 1
// Source file: subApi.c"
d18 1
d20 4
a23 1
#include <ApiCall.h>
@


1.6
log
@Continued development of selection splitting for multi=exec.
@
text
@d202 1
a202 1
   apiGet (appData, "appData", theCall ()->appData ());
d223 1
a223 1
   apiGet (consRate, "consRate", theCall ()->consRate ());
d244 4
a247 1
   apiGet (consumedPartName, "consumedPartName", theCall ()->myPartName ());
d268 3
a270 1
   apiGet (earliestPeriod, "earliestPeriod", theCall ()->earliestPeriod ());
d291 1
a291 1
   apiGet (expAllowed, "expAllowed", theCall ()->expAllowed ());
d312 3
a314 1
   apiGet (expNetAversion, "expNetAversion", theCall ()->expNetAversion ());
d365 1
a365 1
   apiGet (falloutRate, "falloutRate", theCall ()->falloutRate ());
d388 1
a388 1
   apiGet (fssSubVol, "fssSubVol", theCall ()->fssSubVol ());
d411 1
a411 1
   apiGet (impactPeriod, "impactPeriod", theCall ()->impactPeriod ());
d432 1
a432 1
   apiGet (latestPeriod, "latestPeriod", theCall ()->latestPeriod ());
d453 1
a453 1
   apiGet (mrpNetAllowed, "mrpNetAllowed", theCall ()->mrpNetAllowed ());
d474 1
a474 1
   apiGet (mrpSubVol, "mrpSubVol", theCall ()->mrpSubVol ());
d495 1
a495 1
   apiGet (netAllowed, "netAllowed", theCall ()->netAllowed ());
d516 3
a518 1
   witGetObj1Vector (obj1SubCost, "obj1SubCost", theCall ()->obj1SubCost ());
d539 3
a541 1
   apiGet (obj2SubPenalty, "obj2SubPenalty", theCall ()->obj2SubPenalty ());
d562 1
a562 1
   apiGet (offset, "offset", theCall ()->offset ());
d604 1
a604 1
   apiGet (subVol, "subVol", theCall ()->subVol ());
d625 1
a625 1
   apiGet (selForDel, "selForDel", theCall ()->selForDel ());
d705 1
a705 1
      theCall ()->setConsRate (consRate);
d747 4
a750 1
   theCall.prepBoolean ("expAllowed", theCall ()->expAllowed (), expAllowed);
d753 1
a753 1
      theCall ()->setExpAllowed (expAllowed);
d776 1
a776 1
      theCall ()->expNetAversion (), 
d780 1
a780 1
      theCall ()->setExpNetAversion (expNetAversion);
d871 1
a871 1
      theCall ()->mrpNetAllowed (), 
d875 1
a875 1
      theCall ()->setMrpNetAllowed (mrpNetAllowed);
d896 4
a899 1
   theCall.prepBoolean ("netAllowed", theCall ()->netAllowed (), netAllowed);
d902 1
a902 1
      theCall ()->setNetAllowed (netAllowed);
d937 1
a937 1
               theCall ()->myPartName (),
d941 1
a941 1
      theCall ()->setObj1SubCost (obj1SubCost);
d965 1
a965 1
      theCall ()->obj2SubPenalty (), 
d969 1
a969 1
      theCall ()->setObj2SubPenalty (obj2SubPenalty);
d1035 1
a1035 1
      theCall ()->setSubVol (subVol);
@


1.5
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d137 1
a137 1
               newSubs->myBomEntryIndex (),
d144 1
a144 1
               newSubs->myBomEntryIndex (),
d151 1
a151 1
               newSubs->myBomEntryIndex (),
d158 1
a158 1
               newSubs->myBomEntryIndex (),
d165 1
a165 1
               newSubs->myBomEntryIndex (),
d172 1
a172 1
               newSubs->myBomEntryIndex (),
@


1.4
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d27 3
a29 3
      const char *    operationName,
      int             bomEntryIndex,
      int             subBomEntryIndex)
d209 21
d629 19
a647 5
   WitSubEntryApiCall theCall (
      this,
      consumingOperationName,
      bomEntryIndex,
      subBomEntryIndex);
d649 1
a649 1
   apiGet (usageRate, "usageRate", theCall ()->usageRate ());
d677 24
d1054 13
a1066 2
   WitSubEntryApiCall theCall (
      this,
d1069 2
a1070 1
      subBomEntryIndex);
d1072 1
a1072 1
   theCall.setUsageRate (usageRate);
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d104 1
a104 1
      myMsgFac () ("emptyBom", theOpn->operationName ());
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d316 1
a316 1
   apiGet (fallout, "fallout", WitUtil::fracToPercent (theFalloutRate));
d733 1
a733 1
      WitUtil::percentToFrac (fallout));
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.130;
access;
symbols
	sce_5_01_20080919:1.112
	latest_sce_4_20_20060523:1.65.0.2
	sce_4_20_20060523:1.65
	latest_sce4_20_OSL:1.64.0.2
	sce_4_20_OSL:1.64
	sce_410_withVa:1.60
	sce_4_05_20040511:1.49
	sce_4_00_20040201:1.39
	nextGenBranch:1.38.0.2
	nextGenRoot:1.38
	sce_3_30_20030627:1.38
	EndRw-branch:1.30.0.4
	Root-of-EndRw:1.30
	rwToStl:1.30.0.2
	latest_sce_3_10_20010924:1.10.0.2
	sce_3_10_20010924:1.10
	latest_sce_3_00_20010601:1.5.0.4
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2;
locks; strict;
comment	@ * @;


1.130
date	2011.09.28.23.49.50;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2011.09.24.00.28.12;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2011.08.30.20.17.52;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.18.18.03.49;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2010.06.18.14.15.18;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2010.01.06.20.42.40;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2010.01.06.20.10.32;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2009.12.30.20.02.28;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2009.12.30.18.46.37;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2009.12.30.18.30.37;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2009.12.29.22.53.17;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2009.12.29.19.39.06;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2009.12.29.16.33.45;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2009.12.28.23.07.44;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2009.12.25.00.10.47;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2009.12.21.20.35.47;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2009.11.13.19.01.26;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2008.09.16.16.02.34;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2008.02.25.16.36.34;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2008.02.22.21.36.10;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2007.12.11.22.00.28;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2007.11.15.17.15.34;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2007.11.14.17.18.54;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2007.11.13.23.02.17;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2007.11.13.20.17.40;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2007.11.07.21.50.12;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.10.15.21.50.35;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.10.02.18.32.43;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.09.26.22.52.51;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.09.11.18.09.17;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.09.10.21.01.34;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.06.13.23.12.31;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.06.08.18.09.40;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.05.21.06.01;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.05.16.15.24;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.30.16.01.19;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.25.18.39.11;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.24.18.52.22;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.22.15.46.52;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.14.19.05.40;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.05.14.16.18.39;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.11.20.43.56;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.05.10.21.58.11;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.10.21.14.42;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.05.10.17.22.15;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.05.04.23.27.11;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.04.03.22.04.04;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.08.22.47.18;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.02.28.20.04.58;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.02.27.22.59.30;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.02.08.00.14.26;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.02.07.22.14.54;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.02.07.19.55.37;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.02.07.17.30.33;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.02.07.00.13.08;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.02.06.23.10.33;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.02.21.36.41;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.02.01.16.37.23;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.01.16.31.02;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.31.21.58.02;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.09.19.14.15;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.01.17.31.46;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2006.09.05.21.11.06;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.02.17.34.07;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.01.19.23.24;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2005.11.15.21.27.23;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.26.23.02.18;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2005.06.13.16.48.47;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.16.17.00.31;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.03.21.25.12;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.02.23.56.52;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.02.22.34.36;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.02.21.59.46;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.02.24.23.23.57;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.10.18.38.30;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.26.23.50.32;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.14.15.32.20;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.07.15.18.26;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.30.00.05.33;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.24.23.06.32;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.24.16.50.34;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.03.19.07.27;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.02.23.52.14;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.11.18.29.14;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.19.16.48.22;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.07.23.46.15;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.26.23.51.32;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.26.21.42.55;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.14.20.12.59;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.13.23.06.30;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.23.19.13.22;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.02.22.18.42;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.26.22.49.06;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.23.21.00.40;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.05.19.31.35;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.04.23.07.22;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.03.22.35.20;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.03.16.01.51;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.30.20.09.00;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.29.21.35.47;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.29.14.32.41;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.28.19.44.58;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.24.23.00.05;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.17.21.45.04;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.08.19.21.54;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.03.23.16.40;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.03.19.58.29;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.01.14.26.00;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.25.19.14.52;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.22.14.32.11;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.18.14.02.40;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.28.00.12.59;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.19.18.50.59;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.30.15.51.49;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.29.21.37.20;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.17.22.00.11;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.21.18.24.32;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.04.22.27.53;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.06.19.58.40;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.22.23.11.46;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.25.20.12.34;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.14.22.38.35;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.130
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef PartH
#define PartH

//------------------------------------------------------------------------------
// Header file: "Part.h"
//
// Contains the declaration of the following classes:
//
//    Part
//------------------------------------------------------------------------------

#include <Node.h>
#include <FlexVec.h>
#include <ObjVec.h>
#include <PtrTVec.h>
#include <PtrVec.h>

//------------------------------------------------------------------------------
// Class Part.
//
// Class Hierarchy:
//
// ProbAssoc
//    Component
//       DelComp
//          Node
//             Part
//                Material
//                Capacity
//------------------------------------------------------------------------------

class WitPart: public WitNode
   {
   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitPart ();

      //------------------------------------------------------------------------
      // Mapping functions
      //------------------------------------------------------------------------

      decMappingIndex (WitPart)

      static int nInstances (WitProblem *);

      //------------------------------------------------------------------------
      // Default value functions.
      //------------------------------------------------------------------------

      defaultValue (double defSupplyVol,        0.0)
      defaultValue (bool   defSingleSource,     false)
      defaultValue (bool   defPropRtg,          false)
      defaultValue (bool   defBoundedLeadTimes, false)
      defaultValue (bool   defScrapAllowed,     true)
      defaultValue (double defScrapCost,        0.0)

      //------------------------------------------------------------------------
      // "Set" functions.
      //------------------------------------------------------------------------

      void setPartName         (const char *);
      void setSupplyVol        (const WitIVRealArg &);
      void setSingleSource     (bool);
      void setPropRtg          (const WitBoolean *);
      void setBoundedLeadTimes (bool);
      void setScrapAllowed     (bool);
      void setScrapCost        (const WitIVRealArg &);

      //------------------------------------------------------------------------
      // store<Activity><Attr> functions.
      // Each of these functions sets the value of indicated attribute to the
      // value of the argument.
      // Each function is only valid when the indicated activity is being
      // performed.
      //------------------------------------------------------------------------

      void storePreSortedPartIndex     (int);
      void storePreBelowList           (const WitPtrVec <WitPart> &);
      void storePreExpPerGaps          (bool);
      void storePreProducingBopEntries (const WitList <WitBopEntry> &);
      void storePreExpBopEntry         (const WitPtrTVec <WitBopEntry> &);
         //
         // Valid only when preprocessing is being performed.

      void storePostConsVol     (const WitTVec <double> &);
      void storePostProdVol     (const WitTVec <double> &);
      void storePostScrapVol    (const WitTVec <double> &);
      void storePostResidualVol (const WitTVec <double> &);
         //
         // Valid only when postprocessing is being performed.

      void storeOptScrapVol    (WitPeriod, double);
      void storeOptShadowPrice (WitPeriod, double);
         //
         // Valid only when the optimizing implosion subsystem is uploading the
         // solution.

      void storeStochSupplyVol (const WitDblFlexVec &);
      void storeStochScrapCost (const WitDblFlexVec &);
      void storeStochScrapVol  (const WitDblFlexVec &);
         //
         // Valid only when the stochastic implosion subsystem is uploading
         // data.

      void storeMrpReqVol         (const WitTVec <double> &);
      void storeMrpMrpConsVol     (const WitTVec <double> &);
      void storeMrpMrpResidualVol (const WitTVec <double> &);
         //
         // Valid only when the MRP subsystem is uploading the MRP solution.

      void storeFssFocShortageVol (const WitTVec <double> &);
         //
         // Valid only when the FSS subsystem is uploading the FSS solution.

      //------------------------------------------------------------------------
      // Insert functions.
      // Each of these functions does an appendUniquely on the argument for the
      // appropriate List.
      //------------------------------------------------------------------------

      void insert (WitBomEntry *);
      void insert (WitSubEntry *);
      void insert (WitBopEntry *);
      void insert (WitDemand *);

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual bool      inserted          ();
      virtual void      writeMultiObjVecs (WitObjective *);
      virtual void      unpreprocess      ();
      virtual void      clearOptSoln      ();
      virtual void      clearStochSoln    ();
      virtual WitPart * thisPart          ();
         //
         // Overrides from class Component.

      virtual void       identifyInstance ();
      virtual void       writeSetClause   ();
      virtual WitMsgFrag objTypeMsgFrag   ();
      virtual WitAttr    apiObjItrState   ();
         //
         // Overrides from class DelComp.

      virtual WitMsgFrag categoryFrag () = 0;
         //
         // Returns a message fragment indicating category of this Part.

      virtual WitAttr apiCategory () = 0;
         //
         // Returns the category of this Part in api terms.

      virtual bool canStock (WitPeriod thePer) = 0;
         //
         // Returns true iff part this Part can be stocked in period thePer.

      virtual int nodeIndex () const;
         //
         // Override from class Node.

      virtual void display ();
         //
         // Displays the input and preprocessing data for this Part.

      inline static WitPart * key (WitListItr & theItr)
         {
         return reinterpret_cast <WitPart *> (theItr.key ());
         }
         //
         // Used by forEach<object> macros.

      inline WitPeriod explosionPeriod (WitPeriod fillPer)
         {
         return 
            expPerGaps_?
               findExplosionPeriod (fillPer):
               fillPer;
         }
         //
         // Returns the Period in which to explode this Part for filling
         // requirements in fillPer. 
         
      bool explodeable (WitPeriod thePer);
         //
         // Returns true iff this Part can be exploded in period thePer.
         // Note that this implies that the relevent effProdRate is 
         // significantly positive.

      double net (
            WitPeriod          reqPer,
            double             reqQty,
            WitTVec <double> & supply);
         //
         // Net the supply vector by reqQty and return 0 if reqQty is filled
         // or the amount remaining if the supply is exhausted.

      void writeSoln ();
         //
         // Prints the comprehensive implosion solution for this Part.

      void writeDualSoln ();
         //
         // Prints the dual optimization solution for this Part.

      void writeMrpSoln ();
         //
         // Prints the comprehensive MRP solution for this Part.

      void resetShadowPrice ();
         //
         // Sets shadowPrice_ to 0.0.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const WitList <WitDemand> &,   myDemands)
      accessFunc (const WitList <WitBomEntry> &, consumingBomEntries)
      accessFunc (const WitList <WitSubEntry> &, consumingSubEntries)
      accessFunc (const WitList <WitBopEntry> &, producingBopEntries)
      accessFunc (const WitDblFlexVec &,         supplyVol)
      accessFunc (bool,                          singleSource)
      accessFunc (const WitFlexVec <bool> &,     propRtg)
      accessFunc (bool,                          boundedLeadTimes)
      accessFunc (bool,                          scrapAllowed)
      accessFunc (int,                           sortedPartIndex)
      accessFunc (const WitPtrVec <WitPart> &,   belowList)
      accessFunc (const WitDblFlexVec &,         shadowPrice)
      accessFunc (const WitDblFlexVec &,         consVol)
      accessFunc (const WitDblFlexVec &,         prodVol)
      accessFunc (const WitDblFlexVec &,         scrapVol)
      accessFunc (const WitDblFlexVec &,         residualVol)
      accessFunc (const WitDblFlexVec &,         mrpConsVol)
      accessFunc (const WitDblFlexVec &,         mrpResidualVol)
      accessFunc (const WitDblFlexVec &,         reqVol)
      accessFunc (const WitDblFlexVec &,         focShortageVol)

      inline const WitDblFlexVec & scrapCost () const
         {
         return scrapCost_.curDblFlexVec ();
         }

      WitBopEntry * expBopEntry (WitPeriod thePer);

      inline const WitString & partName ()
         {
         return nodeName ();
         }

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPart (const char * theName, WitCompMgr * theCompMgr);
         //
         // Node <<< theName.
         // Node <<< theCompMgr.

      //------------------------------------------------------------------------
      // Other protected member functions.
      //------------------------------------------------------------------------

      void recountPart ();
         //
         // Recounts this Part.

      virtual const char * categoryKeyWord () = 0;
         //
         // Returns the key word for this Part's category for the input file
         // format.

      virtual void writeDataAttrs ();
         //
         // Override from class Component.

      void copyAttrsFrom (WitPart * thePart);
         //
         // Copies the input attributes of thePart into this Part.

      virtual WitPeriod findExplosionPeriod (WitPeriod fillPer) = 0;
         //
         // Computes and returns the Period in which to explode this Part for
         // filling requirements in fillPer. 
         
   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPart);

      virtual void writeDataID        ();
      virtual void purgeCompListsSpec ();
      virtual void clearDepListsSpec  ();
         //
         // Overrides from class Component.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Data maintained by myCompMgr ().
      //------------------------------------------------------------------------

      int mappingIndex_;
         //
         // Mapping index: see Mapping.h.
         // == # Parts constructed before this Part.

      WitList <WitDemand> myDemands_;
         //
         // The list of demands for this Part.

      WitList <WitBomEntry> consumingBomEntries_;
         //
         // A list of all BomEntries, theBomEnt, such that
         // theBomEnt->myPart_ == this Part.

      WitList <WitSubEntry> consumingSubEntries_;
         //
         // A list of all SubEntries,
         // theSub, such that theSub->myPart_ == this Part.

      WitList <WitBopEntry> producingBopEntries_;
         //
         // A list of all BopEntries, theBopEnt, such that
         // theBopEnt->myPart_ == this Part.
         // When myProblem () is preprocessed, this list is sorted in order of
         // of increasing expAversion.

      //------------------------------------------------------------------------
      // Input data.
      //------------------------------------------------------------------------

      WitDblFlexVec supplyVol_;
         //
         // Non-cumulative external supply volume in each period.
         // Range: [0.0, +inf).

      bool singleSource_;
         //
         // The single-source technique is to be applied to this Part, iff
         // singleSource_ is true.

      WitFlexVec <bool> propRtg_;
         //
         // The proportionate routing technique is to be applied to this Part
         // in thePer, iff propRtg_[thePer] is true.

      bool boundedLeadTimes_;
         //
         // true, iff lead time bounds apply to this Part.

      bool scrapAllowed_;
         //
         // Applies to optimizing implosion only.
         // If false, scrapVol is constrained to be zero in a feasible
         // optimizing implosion solution.

      WitObjVec scrapCost_;
         //
         // Stores the cost coefficients of the scrap variables for this Part.
         // Range: (-inf, +inf).

      //------------------------------------------------------------------------
      // Data set by preprocessing.
      //------------------------------------------------------------------------

      int sortedPartIndex_;
         //
         // # Parts before this Part in the sorted list of Parts.

      WitPtrTVec <WitBopEntry> expBopEntry_;
         //
         // expBopEntry_[thePer] is the preferred BopEntry to be used
         // for explosions in order to produce this Part in period thePer.
         // expBopEntry_[thePer] != NULL iff this Part can be exploded in 
         // thePer.

      WitPtrVec <WitPart> belowList_;
         //
         // The list of all parts in the multilevel BOM extending downward from
         // this Part, including this Part itself. The list is in
         // downward order, so this Part is always its first element.
         // Considers all BopEntries that produce this Part for which expAllowed
         // is true. The purpose of this data is for its use in heuristic
         // implosion/allocation.

      bool expPerGaps_;
         //
         // true, iff there is at least one period, fillPer, such that:
         // * this Part is not explodeable in fillPer, and
         // * there is an earlier period, expPer in which this Part is 
         //   explodeable and the result can be stocked thru fillPer.
         // explosionPeriod () will search for an earlier explosion period iff
         // expPerGaps_ is true.

      //------------------------------------------------------------------------
      // Data set by optimizing implosion.
      //------------------------------------------------------------------------

      WitDblFlexVec shadowPrice_;
         //
         // shadowPrice_[thePer] is the shadow price (dual variable value) for
         // the resource allocation constraint in this Part in thePer.
         // Valid only if myOptComp ()->compPrices () is true.

      //------------------------------------------------------------------------
      // Data set by postprocessing.
      //------------------------------------------------------------------------

      WitDblFlexVec consVol_;
         //
         // consVol[thePer] is the volume of this Part that was consumed in
         // thePer.

      WitDblFlexVec prodVol_;
         //
         // prodVol[thePer] is total volume of this Part that is produced in
         // thePer by all Operations.

      WitDblFlexVec scrapVol_;
         //
         // scrapVol_[thePer] is the volume of this part that was scrapped in
         // thePer.

      WitDblFlexVec residualVol_;
         //
         // residualVol_[thePer] is the amount by which consumption of this Part
         // could be increased in thePer, without making the current implosion
         // solution infeasible.

      //------------------------------------------------------------------------
      // Data set by MRP.
      //------------------------------------------------------------------------

      WitDblFlexVec reqVol_;
         //
         // reqVol[thePer] is the required volume of the part in thePer.
         // This field is the main output of mrp.

      WitDblFlexVec mrpConsVol_;
         //
         // Same as consVol, but for MRP.

      WitDblFlexVec mrpResidualVol_;
         //
         // Same as residualVol, but for MRP.

      //------------------------------------------------------------------------
      // Data set by FSS.
      //------------------------------------------------------------------------

      WitDblFlexVec focShortageVol_;
         //
         // The Focussed Shortage Volume for this Part.
   };

#endif
@


1.129
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.128
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d42 2
a43 266
{
public:

//------------------------------------------------------------------------
// Public member functions.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

virtual ~WitPart ();

//------------------------------------------------------------------------
// Mapping functions
//------------------------------------------------------------------------

decMappingIndex (WitPart)

static int nInstances (WitProblem *);

//------------------------------------------------------------------------
// Default value functions.
//------------------------------------------------------------------------

defaultValue (double defSupplyVol,        0.0)
defaultValue (bool   defSingleSource,     false)
defaultValue (bool   defPropRtg,          false)
defaultValue (bool   defBoundedLeadTimes, false)
defaultValue (bool   defScrapAllowed,     true)
defaultValue (double defScrapCost,        0.0)

//------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------

void setPartName         (const char *);
void setSupplyVol        (const WitIVRealArg &);
void setSingleSource     (bool);
void setPropRtg          (const WitBoolean *);
void setBoundedLeadTimes (bool);
void setScrapAllowed     (bool);
void setScrapCost        (const WitIVRealArg &);

//------------------------------------------------------------------------
// store<Activity><Attr> functions.
// Each of these functions sets the value of indicated attribute to the
// value of the argument.
// Each function is only valid when the indicated activity is being
// performed.
//------------------------------------------------------------------------

void storePreSortedPartIndex     (int);
void storePreBelowList           (const WitPtrVec <WitPart> &);
void storePreExpPerGaps          (bool);
void storePreProducingBopEntries (const WitList <WitBopEntry> &);
void storePreExpBopEntry         (const WitPtrTVec <WitBopEntry> &);
//
// Valid only when preprocessing is being performed.

void storePostConsVol     (const WitTVec <double> &);
void storePostProdVol     (const WitTVec <double> &);
void storePostScrapVol    (const WitTVec <double> &);
void storePostResidualVol (const WitTVec <double> &);
//
// Valid only when postprocessing is being performed.

void storeOptScrapVol    (WitPeriod, double);
void storeOptShadowPrice (WitPeriod, double);
//
// Valid only when the optimizing implosion subsystem is uploading the
// solution.

void storeStochSupplyVol (const WitDblFlexVec &);
void storeStochScrapCost (const WitDblFlexVec &);
void storeStochScrapVol  (const WitDblFlexVec &);
//
// Valid only when the stochastic implosion subsystem is uploading
// data.

void storeMrpReqVol         (const WitTVec <double> &);
void storeMrpMrpConsVol     (const WitTVec <double> &);
void storeMrpMrpResidualVol (const WitTVec <double> &);
//
// Valid only when the MRP subsystem is uploading the MRP solution.

void storeFssFocShortageVol (const WitTVec <double> &);
//
// Valid only when the FSS subsystem is uploading the FSS solution.

//------------------------------------------------------------------------
// Insert functions.
// Each of these functions does an appendUniquely on the argument for the
// appropriate List.
//------------------------------------------------------------------------

void insert (WitBomEntry *);
void insert (WitSubEntry *);
void insert (WitBopEntry *);
void insert (WitDemand *);

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

virtual bool      inserted          ();
virtual void      writeMultiObjVecs (WitObjective *);
virtual void      unpreprocess      ();
virtual void      clearOptSoln      ();
virtual void      clearStochSoln    ();
virtual WitPart * thisPart          ();
//
// Overrides from class Component.

virtual void       identifyInstance ();
virtual void       writeSetClause   ();
virtual WitMsgFrag objTypeMsgFrag   ();
virtual WitAttr    apiObjItrState   ();
//
// Overrides from class DelComp.

virtual WitMsgFrag categoryFrag () = 0;
//
// Returns a message fragment indicating category of this Part.

virtual WitAttr apiCategory () = 0;
//
// Returns the category of this Part in api terms.

virtual bool canStock (WitPeriod thePer) = 0;
//
// Returns true iff part this Part can be stocked in period thePer.

virtual int nodeIndex () const;
//
// Override from class Node.

virtual void display ();
//
// Displays the input and preprocessing data for this Part.

inline static WitPart * key (WitListItr & theItr)
{
return reinterpret_cast <WitPart *> (theItr.key ());
}
//
// Used by forEach<object> macros.

inline WitPeriod explosionPeriod (WitPeriod fillPer)
{
return
expPerGaps_?
findExplosionPeriod (fillPer):
fillPer;
}
//
// Returns the Period in which to explode this Part for filling
// requirements in fillPer.

bool explodeable (WitPeriod thePer);
//
// Returns true iff this Part can be exploded in period thePer.
// Note that this implies that the relevent effProdRate is
// significantly positive.

double net (
WitPeriod          reqPer,
double             reqQty,
WitTVec <double> & supply);
//
// Net the supply vector by reqQty and return 0 if reqQty is filled
// or the amount remaining if the supply is exhausted.

void writeSoln ();
//
// Prints the comprehensive implosion solution for this Part.

void writeDualSoln ();
//
// Prints the dual optimization solution for this Part.

void writeMrpSoln ();
//
// Prints the comprehensive MRP solution for this Part.

void resetShadowPrice ();
//
// Sets shadowPrice_ to 0.0.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (const WitList <WitDemand> &,   myDemands)
accessFunc (const WitList <WitBomEntry> &, consumingBomEntries)
accessFunc (const WitList <WitSubEntry> &, consumingSubEntries)
accessFunc (const WitList <WitBopEntry> &, producingBopEntries)
accessFunc (const WitDblFlexVec &,         supplyVol)
accessFunc (bool,                          singleSource)
accessFunc (const WitFlexVec <bool> &,     propRtg)
accessFunc (bool,                          boundedLeadTimes)
accessFunc (bool,                          scrapAllowed)
accessFunc (int,                           sortedPartIndex)
accessFunc (const WitPtrVec <WitPart> &,   belowList)
accessFunc (const WitDblFlexVec &,         shadowPrice)
accessFunc (const WitDblFlexVec &,         consVol)
accessFunc (const WitDblFlexVec &,         prodVol)
accessFunc (const WitDblFlexVec &,         scrapVol)
accessFunc (const WitDblFlexVec &,         residualVol)
accessFunc (const WitDblFlexVec &,         mrpConsVol)
accessFunc (const WitDblFlexVec &,         mrpResidualVol)
accessFunc (const WitDblFlexVec &,         reqVol)
accessFunc (const WitDblFlexVec &,         focShortageVol)

inline const WitDblFlexVec & scrapCost () const
{
return scrapCost_.curDblFlexVec ();
}

WitBopEntry * expBopEntry (WitPeriod thePer);

inline const WitString & partName ()
{
return nodeName ();
}

protected:

//------------------------------------------------------------------------
// Protected member functions.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitPart (const char * theName, WitCompMgr * theCompMgr);
//
// Node <<< theName.
// Node <<< theCompMgr.

//------------------------------------------------------------------------
// Other protected member functions.
//------------------------------------------------------------------------

void recountPart ();
//
// Recounts this Part.

virtual const char * categoryKeyWord () = 0;
//
// Returns the key word for this Part's category for the input file
// format.

virtual void writeDataAttrs ();
//
// Override from class Component.

void copyAttrsFrom (WitPart * thePart);
//
// Copies the input attributes of thePart into this Part.

virtual WitPeriod findExplosionPeriod (WitPeriod fillPer) = 0;
//
// Computes and returns the Period in which to explode this Part for
// filling requirements in fillPer.
d45 439
a483 175
private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitPart);

virtual void writeDataID        ();
virtual void purgeCompListsSpec ();
virtual void clearDepListsSpec  ();
//
// Overrides from class Component.

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Data maintained by myCompMgr ().
//------------------------------------------------------------------------

int mappingIndex_;
//
// Mapping index: see Mapping.h.
// == # Parts constructed before this Part.

WitList <WitDemand> myDemands_;
//
// The list of demands for this Part.

WitList <WitBomEntry> consumingBomEntries_;
//
// A list of all BomEntries, theBomEnt, such that
// theBomEnt->myPart_ == this Part.

WitList <WitSubEntry> consumingSubEntries_;
//
// A list of all SubEntries,
// theSub, such that theSub->myPart_ == this Part.

WitList <WitBopEntry> producingBopEntries_;
//
// A list of all BopEntries, theBopEnt, such that
// theBopEnt->myPart_ == this Part.
// When myProblem () is preprocessed, this list is sorted in order of
// of increasing expAversion.

//------------------------------------------------------------------------
// Input data.
//------------------------------------------------------------------------

WitDblFlexVec supplyVol_;
//
// Non-cumulative external supply volume in each period.
// Range: [0.0, +inf).

bool singleSource_;
//
// The single-source technique is to be applied to this Part, iff
// singleSource_ is true.

WitFlexVec <bool> propRtg_;
//
// The proportionate routing technique is to be applied to this Part
// in thePer, iff propRtg_[thePer] is true.

bool boundedLeadTimes_;
//
// true, iff lead time bounds apply to this Part.

bool scrapAllowed_;
//
// Applies to optimizing implosion only.
// If false, scrapVol is constrained to be zero in a feasible
// optimizing implosion solution.

WitObjVec scrapCost_;
//
// Stores the cost coefficients of the scrap variables for this Part.
// Range: (-inf, +inf).

//------------------------------------------------------------------------
// Data set by preprocessing.
//------------------------------------------------------------------------

int sortedPartIndex_;
//
// # Parts before this Part in the sorted list of Parts.

WitPtrTVec <WitBopEntry> expBopEntry_;
//
// expBopEntry_[thePer] is the preferred BopEntry to be used
// for explosions in order to produce this Part in period thePer.
// expBopEntry_[thePer] != NULL iff this Part can be exploded in
// thePer.

WitPtrVec <WitPart> belowList_;
//
// The list of all parts in the multilevel BOM extending downward from
// this Part, including this Part itself. The list is in
// downward order, so this Part is always its first element.
// Considers all BopEntries that produce this Part for which expAllowed
// is true. The purpose of this data is for its use in heuristic
// implosion/allocation.

bool expPerGaps_;
//
// true, iff there is at least one period, fillPer, such that:
// * this Part is not explodeable in fillPer, and
// * there is an earlier period, expPer in which this Part is
//   explodeable and the result can be stocked thru fillPer.
// explosionPeriod () will search for an earlier explosion period iff
// expPerGaps_ is true.

//------------------------------------------------------------------------
// Data set by optimizing implosion.
//------------------------------------------------------------------------

WitDblFlexVec shadowPrice_;
//
// shadowPrice_[thePer] is the shadow price (dual variable value) for
// the resource allocation constraint in this Part in thePer.
// Valid only if myOptComp ()->compPrices () is true.

//------------------------------------------------------------------------
// Data set by postprocessing.
//------------------------------------------------------------------------

WitDblFlexVec consVol_;
//
// consVol[thePer] is the volume of this Part that was consumed in
// thePer.

WitDblFlexVec prodVol_;
//
// prodVol[thePer] is total volume of this Part that is produced in
// thePer by all Operations.

WitDblFlexVec scrapVol_;
//
// scrapVol_[thePer] is the volume of this part that was scrapped in
// thePer.

WitDblFlexVec residualVol_;
//
// residualVol_[thePer] is the amount by which consumption of this Part
// could be increased in thePer, without making the current implosion
// solution infeasible.

//------------------------------------------------------------------------
// Data set by MRP.
//------------------------------------------------------------------------

WitDblFlexVec reqVol_;
//
// reqVol[thePer] is the required volume of the part in thePer.
// This field is the main output of mrp.

WitDblFlexVec mrpConsVol_;
//
// Same as consVol, but for MRP.

WitDblFlexVec mrpResidualVol_;
//
// Same as residualVol, but for MRP.

//------------------------------------------------------------------------
// Data set by FSS.
//------------------------------------------------------------------------

WitDblFlexVec focShortageVol_;
//
// The Focussed Shortage Volume for this Part.
};
@


1.127
log
@Lead Time Bounds.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d42 266
a307 2
   {
   public:
d309 175
a483 439
      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitPart ();

      //------------------------------------------------------------------------
      // Mapping functions
      //------------------------------------------------------------------------

      decMappingIndex (WitPart)

      static int nInstances (WitProblem *);

      //------------------------------------------------------------------------
      // Default value functions.
      //------------------------------------------------------------------------

      defaultValue (double defSupplyVol,        0.0)
      defaultValue (bool   defSingleSource,     false)
      defaultValue (bool   defPropRtg,          false)
      defaultValue (bool   defBoundedLeadTimes, false)
      defaultValue (bool   defScrapAllowed,     true)
      defaultValue (double defScrapCost,        0.0)

      //------------------------------------------------------------------------
      // "Set" functions.
      //------------------------------------------------------------------------

      void setPartName         (const char *);
      void setSupplyVol        (const WitIVRealArg &);
      void setSingleSource     (bool);
      void setPropRtg          (const WitBoolean *);
      void setBoundedLeadTimes (bool);
      void setScrapAllowed     (bool);
      void setScrapCost        (const WitIVRealArg &);

      //------------------------------------------------------------------------
      // store<Activity><Attr> functions.
      // Each of these functions sets the value of indicated attribute to the
      // value of the argument.
      // Each function is only valid when the indicated activity is being
      // performed.
      //------------------------------------------------------------------------

      void storePreSortedPartIndex     (int);
      void storePreBelowList           (const WitPtrVec <WitPart> &);
      void storePreExpPerGaps          (bool);
      void storePreProducingBopEntries (const WitList <WitBopEntry> &);
      void storePreExpBopEntry         (const WitPtrTVec <WitBopEntry> &);
         //
         // Valid only when preprocessing is being performed.

      void storePostConsVol     (const WitTVec <double> &);
      void storePostProdVol     (const WitTVec <double> &);
      void storePostScrapVol    (const WitTVec <double> &);
      void storePostResidualVol (const WitTVec <double> &);
         //
         // Valid only when postprocessing is being performed.

      void storeOptScrapVol    (WitPeriod, double);
      void storeOptShadowPrice (WitPeriod, double);
         //
         // Valid only when the optimizing implosion subsystem is uploading the
         // solution.

      void storeStochSupplyVol (const WitDblFlexVec &);
      void storeStochScrapCost (const WitDblFlexVec &);
      void storeStochScrapVol  (const WitDblFlexVec &);
         //
         // Valid only when the stochastic implosion subsystem is uploading
         // data.

      void storeMrpReqVol         (const WitTVec <double> &);
      void storeMrpMrpConsVol     (const WitTVec <double> &);
      void storeMrpMrpResidualVol (const WitTVec <double> &);
         //
         // Valid only when the MRP subsystem is uploading the MRP solution.

      void storeFssFocShortageVol (const WitTVec <double> &);
         //
         // Valid only when the FSS subsystem is uploading the FSS solution.

      //------------------------------------------------------------------------
      // Insert functions.
      // Each of these functions does an appendUniquely on the argument for the
      // appropriate List.
      //------------------------------------------------------------------------

      void insert (WitBomEntry *);
      void insert (WitSubEntry *);
      void insert (WitBopEntry *);
      void insert (WitDemand *);

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual bool      inserted          ();
      virtual void      writeMultiObjVecs (WitObjective *);
      virtual void      unpreprocess      ();
      virtual void      clearOptSoln      ();
      virtual void      clearStochSoln    ();
      virtual WitPart * thisPart          ();
         //
         // Overrides from class Component.

      virtual void       identifyInstance ();
      virtual void       writeSetClause   ();
      virtual WitMsgFrag objTypeMsgFrag   ();
      virtual WitAttr    apiObjItrState   ();
         //
         // Overrides from class DelComp.

      virtual WitMsgFrag categoryFrag () = 0;
         //
         // Returns a message fragment indicating category of this Part.

      virtual WitAttr apiCategory () = 0;
         //
         // Returns the category of this Part in api terms.

      virtual bool canStock (WitPeriod thePer) = 0;
         //
         // Returns true iff part this Part can be stocked in period thePer.

      virtual int nodeIndex () const;
         //
         // Override from class Node.

      virtual void display ();
         //
         // Displays the input and preprocessing data for this Part.

      inline static WitPart * key (WitListItr & theItr)
         {
         return reinterpret_cast <WitPart *> (theItr.key ());
         }
         //
         // Used by forEach<object> macros.

      inline WitPeriod explosionPeriod (WitPeriod fillPer)
         {
         return 
            expPerGaps_?
               findExplosionPeriod (fillPer):
               fillPer;
         }
         //
         // Returns the Period in which to explode this Part for filling
         // requirements in fillPer. 
         
      bool explodeable (WitPeriod thePer);
         //
         // Returns true iff this Part can be exploded in period thePer.
         // Note that this implies that the relevent effProdRate is 
         // significantly positive.

      double net (
            WitPeriod          reqPer,
            double             reqQty,
            WitTVec <double> & supply);
         //
         // Net the supply vector by reqQty and return 0 if reqQty is filled
         // or the amount remaining if the supply is exhausted.

      void writeSoln ();
         //
         // Prints the comprehensive implosion solution for this Part.

      void writeDualSoln ();
         //
         // Prints the dual optimization solution for this Part.

      void writeMrpSoln ();
         //
         // Prints the comprehensive MRP solution for this Part.

      void resetShadowPrice ();
         //
         // Sets shadowPrice_ to 0.0.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const WitList <WitDemand> &,   myDemands)
      accessFunc (const WitList <WitBomEntry> &, consumingBomEntries)
      accessFunc (const WitList <WitSubEntry> &, consumingSubEntries)
      accessFunc (const WitList <WitBopEntry> &, producingBopEntries)
      accessFunc (const WitDblFlexVec &,         supplyVol)
      accessFunc (bool,                          singleSource)
      accessFunc (const WitFlexVec <bool> &,     propRtg)
      accessFunc (bool,                          boundedLeadTimes)
      accessFunc (bool,                          scrapAllowed)
      accessFunc (int,                           sortedPartIndex)
      accessFunc (const WitPtrVec <WitPart> &,   belowList)
      accessFunc (const WitDblFlexVec &,         shadowPrice)
      accessFunc (const WitDblFlexVec &,         consVol)
      accessFunc (const WitDblFlexVec &,         prodVol)
      accessFunc (const WitDblFlexVec &,         scrapVol)
      accessFunc (const WitDblFlexVec &,         residualVol)
      accessFunc (const WitDblFlexVec &,         mrpConsVol)
      accessFunc (const WitDblFlexVec &,         mrpResidualVol)
      accessFunc (const WitDblFlexVec &,         reqVol)
      accessFunc (const WitDblFlexVec &,         focShortageVol)

      inline const WitDblFlexVec & scrapCost () const
         {
         return scrapCost_.curDblFlexVec ();
         }

      WitBopEntry * expBopEntry (WitPeriod thePer);

      inline const WitString & partName ()
         {
         return nodeName ();
         }

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPart (const char * theName, WitCompMgr * theCompMgr);
         //
         // Node <<< theName.
         // Node <<< theCompMgr.

      //------------------------------------------------------------------------
      // Other protected member functions.
      //------------------------------------------------------------------------

      void recountPart ();
         //
         // Recounts this Part.

      virtual const char * categoryKeyWord () = 0;
         //
         // Returns the key word for this Part's category for the input file
         // format.

      virtual void writeDataAttrs ();
         //
         // Override from class Component.

      void copyAttrsFrom (WitPart * thePart);
         //
         // Copies the input attributes of thePart into this Part.

      virtual WitPeriod findExplosionPeriod (WitPeriod fillPer) = 0;
         //
         // Computes and returns the Period in which to explode this Part for
         // filling requirements in fillPer. 
         
   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPart);

      virtual void writeDataID        ();
      virtual void purgeCompListsSpec ();
      virtual void clearDepListsSpec  ();
         //
         // Overrides from class Component.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Data maintained by myCompMgr ().
      //------------------------------------------------------------------------

      int mappingIndex_;
         //
         // Mapping index: see Mapping.h.
         // == # Parts constructed before this Part.

      WitList <WitDemand> myDemands_;
         //
         // The list of demands for this Part.

      WitList <WitBomEntry> consumingBomEntries_;
         //
         // A list of all BomEntries, theBomEnt, such that
         // theBomEnt->myPart_ == this Part.

      WitList <WitSubEntry> consumingSubEntries_;
         //
         // A list of all SubEntries,
         // theSub, such that theSub->myPart_ == this Part.

      WitList <WitBopEntry> producingBopEntries_;
         //
         // A list of all BopEntries, theBopEnt, such that
         // theBopEnt->myPart_ == this Part.
         // When myProblem () is preprocessed, this list is sorted in order of
         // of increasing expAversion.

      //------------------------------------------------------------------------
      // Input data.
      //------------------------------------------------------------------------

      WitDblFlexVec supplyVol_;
         //
         // Non-cumulative external supply volume in each period.
         // Range: [0.0, +inf).

      bool singleSource_;
         //
         // The single-source technique is to be applied to this Part, iff
         // singleSource_ is true.

      WitFlexVec <bool> propRtg_;
         //
         // The proportionate routing technique is to be applied to this Part
         // in thePer, iff propRtg_[thePer] is true.

      bool boundedLeadTimes_;
         //
         // true, iff lead time bounds apply to this Part.

      bool scrapAllowed_;
         //
         // Applies to optimizing implosion only.
         // If false, scrapVol is constrained to be zero in a feasible
         // optimizing implosion solution.

      WitObjVec scrapCost_;
         //
         // Stores the cost coefficients of the scrap variables for this Part.
         // Range: (-inf, +inf).

      //------------------------------------------------------------------------
      // Data set by preprocessing.
      //------------------------------------------------------------------------

      int sortedPartIndex_;
         //
         // # Parts before this Part in the sorted list of Parts.

      WitPtrTVec <WitBopEntry> expBopEntry_;
         //
         // expBopEntry_[thePer] is the preferred BopEntry to be used
         // for explosions in order to produce this Part in period thePer.
         // expBopEntry_[thePer] != NULL iff this Part can be exploded in 
         // thePer.

      WitPtrVec <WitPart> belowList_;
         //
         // The list of all parts in the multilevel BOM extending downward from
         // this Part, including this Part itself. The list is in
         // downward order, so this Part is always its first element.
         // Considers all BopEntries that produce this Part for which expAllowed
         // is true. The purpose of this data is for its use in heuristic
         // implosion/allocation.

      bool expPerGaps_;
         //
         // true, iff there is at least one period, fillPer, such that:
         // * this Part is not explodeable in fillPer, and
         // * there is an earlier period, expPer in which this Part is 
         //   explodeable and the result can be stocked thru fillPer.
         // explosionPeriod () will search for an earlier explosion period iff
         // expPerGaps_ is true.

      //------------------------------------------------------------------------
      // Data set by optimizing implosion.
      //------------------------------------------------------------------------

      WitDblFlexVec shadowPrice_;
         //
         // shadowPrice_[thePer] is the shadow price (dual variable value) for
         // the resource allocation constraint in this Part in thePer.
         // Valid only if myOptComp ()->compPrices () is true.

      //------------------------------------------------------------------------
      // Data set by postprocessing.
      //------------------------------------------------------------------------

      WitDblFlexVec consVol_;
         //
         // consVol[thePer] is the volume of this Part that was consumed in
         // thePer.

      WitDblFlexVec prodVol_;
         //
         // prodVol[thePer] is total volume of this Part that is produced in
         // thePer by all Operations.

      WitDblFlexVec scrapVol_;
         //
         // scrapVol_[thePer] is the volume of this part that was scrapped in
         // thePer.

      WitDblFlexVec residualVol_;
         //
         // residualVol_[thePer] is the amount by which consumption of this Part
         // could be increased in thePer, without making the current implosion
         // solution infeasible.

      //------------------------------------------------------------------------
      // Data set by MRP.
      //------------------------------------------------------------------------

      WitDblFlexVec reqVol_;
         //
         // reqVol[thePer] is the required volume of the part in thePer.
         // This field is the main output of mrp.

      WitDblFlexVec mrpConsVol_;
         //
         // Same as consVol, but for MRP.

      WitDblFlexVec mrpResidualVol_;
         //
         // Same as residualVol, but for MRP.

      //------------------------------------------------------------------------
      // Data set by FSS.
      //------------------------------------------------------------------------

      WitDblFlexVec focShortageVol_;
         //
         // The Focussed Shortage Volume for this Part.
   };
@


1.126
log
@Lead Time Bounds.
@
text
@d67 6
a72 6
      defaultValue (double defSupplyVol,       0.0)
      defaultValue (bool   defSingleSource,    false)
      defaultValue (bool   defPropRtg,         false)
      defaultValue (bool   defBoundedLeadTime, false)
      defaultValue (bool   defScrapAllowed,    true)
      defaultValue (double defScrapCost,       0.0)
d78 7
a84 7
      void setPartName        (const char *);
      void setSupplyVol       (const WitIVRealArg &);
      void setSingleSource    (bool);
      void setPropRtg         (const WitBoolean *);
      void setBoundedLeadTime (bool);
      void setScrapAllowed    (bool);
      void setScrapCost       (const WitIVRealArg &);
d242 1
a242 1
      accessFunc (bool,                          boundedLeadTime)
d376 1
a376 1
      bool boundedLeadTime_;
@


1.125
log
@Multi-objective mode
@
text
@d67 6
a72 5
      defaultValue (double defSupplyVol,    0.0)
      defaultValue (bool   defSingleSource, false)
      defaultValue (bool   defPropRtg,      false)
      defaultValue (bool   defScrapAllowed, true)
      defaultValue (double defScrapCost,    0.0)
d78 7
a84 6
      void setPartName     (const char *);
      void setSupplyVol    (const WitIVRealArg &);
      void setSingleSource (bool);
      void setPropRtg      (const WitBoolean *);
      void setScrapAllowed (bool);
      void setScrapCost    (const WitIVRealArg &);
d242 1
d376 4
@


1.124
log
@Multi-objective mode
@
text
@d255 1
a255 1
         return scrapCostObjVec_.curDblFlexVec ();
d379 1
a379 1
      WitObjVec scrapCostObjVec_;
@


1.123
log
@Multi-Objective Mode
@
text
@a240 1
      accessFunc (const WitObjVec &,             scrapCostObjVec)
@


1.122
log
@Multi-Objective Mode
@
text
@d241 1
@


1.121
log
@Multi-Objective Mode
@
text
@d381 1
a381 1
         // Stores the cost coefficients for the scrap variables for this Part.
@


1.120
log
@Multi-Objective Mode
@
text
@d255 1
a255 1
         return scrapCost_.curDblFlexVec ();
d379 1
a379 1
      WitObjVec scrapCost_;
d381 1
a381 2
         // scrapCost () is the cost coef. on the scrap variable for this Part
         // in thePer for the current objective.
@


1.119
log
@Multi-Objective Mode
@
text
@a240 1
      accessFunc (const WitDblFlexVec &,         scrapCost)
d253 5
@


1.118
log
@Multi-Objective Mode
@
text
@d241 1
a253 5
      inline const WitDblFlexVec & scrapCost () const
         {
         return scrapCost_.curDblFlexVec ();
         }

d377 2
a378 2
         // scrapCost_[thePer].curDblDlexVec () is the cost coef. on the scrap
         // variable for this Part in thePer for the current objective.
@


1.117
log
@Multi-Objective Mode
@
text
@d255 1
a255 1
         return scrapCost_->curDblFlexVec ();
d379 1
a379 1
      WitObjVec * scrapCost_;
d381 1
a381 1
         // scrapCost_[thePer]->curDblDlexVec () is the cost coef. on the scrap
@


1.116
log
@Multi-Objective Mode
@
text
@d23 1
d145 6
a150 5
      virtual bool      inserted       ();
      virtual void      unpreprocess   ();
      virtual void      clearOptSoln   ();
      virtual void      clearStochSoln ();
      virtual WitPart * thisPart       ();
a240 1
      accessFunc (const WitDblFlexVec &,         scrapCost)
d253 5
d379 1
a379 1
      WitDblFlexVec scrapCost_;
d381 2
a382 2
         // scrapCost_[thePer] is the cost coef. on the scrap variable for this
         // Part in thePer.
@


1.115
log
@Removed some references to objective #1.
@
text
@d153 1
@


1.114
log
@Removing objective #2.
@
text
@d374 2
a375 3
         // If objective #1 is being used, then thePart->scrapCost_[t] is
         // the user-specified cost coef. on the scrap variable for thePart in
         // period t.
@


1.113
log
@Trivial revision.
@
text
@a68 1
      defaultValue (double defUnitCost,     1.0)
a79 1
      void setUnitCost     (double);
a236 1
      accessFunc (double,                        unitCost)
a365 5
      double unitCost_;
         //
         // The standard unit cost of the part.
         // Range: [0.0, +inf).

@


1.112
log
@Object name change.
@
text
@d416 1
a416 1
         //   explodeable and the result can be stock thru fillPer.
@


1.111
log
@Object name changing.
@
text
@d77 1
@


1.110
log
@Stochastic Implosion
@
text
@d309 1
a309 4
      virtual void writeDataID ();
         //
         // Override from class Component.

d311 1
d313 1
a313 5
         // Override from class Component.

      virtual void clearDepListsSpec ();
         //
         // Override from class Component.
@


1.109
log
@Stochastic Implosion
@
text
@d114 1
@


1.108
log
@Stochastic Implosion
@
text
@d92 8
a144 1
      virtual void      passPreRefs    ();
@


1.107
log
@Stochastic Implosion
@
text
@d117 4
a139 1
      virtual void      passFssRefs    ();
@


1.106
log
@Stochastic Implosion
@
text
@d111 6
a135 1
      virtual void      passMrpRefs    ();
@


1.105
log
@Stochastic Implosion
@
text
@d99 6
d129 1
a129 1
      virtual void      importOptSoln  ();
@


1.104
log
@Stochastic Implosion
@
text
@a41 2
      friend class WitPostAccess;

d85 1
a85 1
      // storeStoch<Attr> functions.
d88 2
a89 1
      // Valid only when the stochastic implosion subsystem is uploading data.
d92 7
d101 3
@


1.103
log
@Stochastic Implosion
@
text
@d111 8
a118 7
      virtual bool      inserted      ();
      virtual void      passPreRefs   ();
      virtual void      unpreprocess  ();
      virtual void      importOptSoln ();
      virtual void      passMrpRefs   ();
      virtual void      passFssRefs   ();
      virtual WitPart * thisPart      ();
@


1.102
log
@Stochastic Implosion
@
text
@d93 2
a94 2
      void storeStochSupplyVol (const WitTVec <double> &);
      void storeStochScrapVol  (const WitTVec <double> &);
@


1.101
log
@Stochastic Implosion
@
text
@d121 3
a123 4
      virtual void       identifyInstance   ();
      virtual void       writeDataSetClause ();
      virtual WitMsgFrag objTypeMsgFrag     ();
      virtual WitAttr    apiObjItrState     ();
@


1.100
log
@Stochastic Implosion
@
text
@d87 1
a87 1
      // loadInStoch<Attr> functions.
d93 2
a94 2
      void loadInStochSupplyVol (const WitTVec <double> &);
      void loadInStochScrapVol  (const WitTVec <double> &);
@


1.99
log
@Stochastic Implosion
@
text
@d90 1
a90 1
      // Valid only when the stochastic implosion subsystem is uploading.
d94 1
d111 7
a117 8
      virtual bool      inserted         ();
      virtual void      passPreRefs      ();
      virtual void      unpreprocess     ();
      virtual void      importOptSoln    ();
      virtual void      importStochSoln  ();
      virtual void      passMrpRefs      ();
      virtual void      passFssRefs      ();
      virtual WitPart * thisPart         ();
@


1.98
log
@Stochastic Implosion
@
text
@d87 9
a113 1
      virtual void      importStochInput ();
@


1.97
log
@Stochastic Implosion
@
text
@d101 9
a109 8
      virtual bool      inserted        ();
      virtual void      passPreRefs     ();
      virtual void      unpreprocess    ();
      virtual void      importOptSoln   ();
      virtual void      importStochSoln ();
      virtual void      passMrpRefs     ();
      virtual void      passFssRefs     ();
      virtual WitPart * thisPart        ();
d113 4
a116 3
      virtual void       identifyInstance ();
      virtual WitMsgFrag objTypeMsgFrag   ();
      virtual WitAttr    apiObjItrState   ();
@


1.96
log
@Stochastic Implosion
@
text
@d101 8
a108 8
      virtual bool      inserted       ();
      virtual void      passPreRefs    ();
      virtual void      unpreprocess   ();
      virtual void      acquireOptSoln ();
      virtual void      passMrpRefs    ();
      virtual void      passFssRefs    ();
      virtual void      passStochRefs  ();
      virtual WitPart * thisPart       ();
@


1.95
log
@Stochastic Implosion
@
text
@a41 1
      friend class WitPreAccess;
a101 1
      virtual void      importPreData  ();
@


1.94
log
@Stochastic Implosion
@
text
@d104 1
@


1.93
log
@Stochastic Implosion
@
text
@d103 1
@


1.92
log
@Stochastic Implosion
@
text
@d102 7
a108 7
      virtual bool      inserted         ();
      virtual void      unpreprocess     ();
      virtual void      importOptImpSoln (WitPeriod);
      virtual void      passMrpRefs      ();
      virtual void      passFssRefs      ();
      virtual void      passStochRefs    ();
      virtual WitPart * thisPart         ();
@


1.91
log
@Stochastic Implosion
@
text
@d105 3
a107 3
      virtual void      passMrpData      ();
      virtual void      passFssData      ();
      virtual void      passStochData    ();
@


1.90
log
@Stochastic Implosion
@
text
@d107 1
a107 2
      virtual void      clearStochSoln   ();
      virtual void      restoreStochSoln ();
@


1.89
log
@Stochastic Implosion
@
text
@d105 1
a105 1
      virtual void      importMrpSoln    ();
@


1.88
log
@Stochastic Implosion
@
text
@a43 1
      friend class WitFssAccess;
d106 1
@


1.87
log
@Stochastic Implosion
@
text
@a43 1
      friend class WitMrpAccess;
d106 1
@


1.86
log
@Stochastic Implosion
@
text
@d104 12
a115 1
      virtual bool inserted ();
d117 1
a117 33
         // Override from class Component.

      virtual void identifyInstance ();
         //
         // Override from class DelComp.

      virtual WitMsgFrag objTypeMsgFrag ();
         //
         // Override from class DelComp.

      virtual WitAttr apiObjItrState ();
         //
         // Override from class DelComp.

      virtual void unpreprocess ();
         //
         // Override from class Component.

      virtual void importOptImpSoln (WitPeriod);
         //
         // Override from class Component.

      virtual void clearStochSoln ();
         //
         // Override from class Component.

      virtual void restoreStochSoln ();
         //
         // Override from class Component.

      virtual WitPart * thisPart ();
         //
         // Override from class Component.
@


1.85
log
@Stochastic Implosion
@
text
@a43 1
      friend class WitOptAccess;
@


1.84
log
@Stochastic Implosion
@
text
@d125 4
@


1.83
log
@Stochastic Implosion.
@
text
@d125 8
@


1.82
log
@[disallowing scrap]
@
text
@d109 1
a109 1
      virtual WitMsgFragID classFragID ();
d111 1
a111 1
         // Override from class Component.
d113 1
a113 1
      virtual void identifyInstance ();
@


1.81
log
@[disallowed backlog]
@
text
@d76 1
d87 1
d209 1
d349 6
@


1.80
log
@[disallowed backlog]
@
text
@d43 4
a194 4
      static void transmitDMPs ();
         //
         // See comment on transmitAllDMPs in CompMgr.h.

@


1.79
log
@Rescinded all changed made since 1/31/07.
@
text
@d42 2
@


1.78
log
@[disallowed backlog]
@
text
@d16 3
a18 1
// Contains the declaration of class Part.
a24 1
#include <Restricted.h>
d113 4
a140 5
      static void sortBopEntries (WitProblem * theProblem);
         //
         // For each Part, thePart, sorts thePart->producingBopEntries in order
         // of non-decreasing expAversion.

d185 8
a196 12
      accessFunc (int,                           sortedPartIndex)
      accessFunc (const WitPtrVec <WitPart> &,   belowList)
      accessFunc (const WitDblFlexVec &,         prodVol)
      accessFunc (const WitDblFlexVec &,         consVol)
      accessFunc (const WitDblFlexVec &,         residualVol)
      accessFunc (const WitDblFlexVec &,         scrapVol)
      accessFunc (const WitDblFlexVec &,         shadowPrice)
      accessFunc (const WitDblFlexVec &,         reqVol)
      accessFunc (const WitDblFlexVec &,         mrpConsVol)
      accessFunc (const WitDblFlexVec &,         mrpResidualVol)
      accessFunc (const WitDblFlexVec &,         focShortageVol)

d206 12
a217 1
                                                                
a224 77
      //------------------------------------------------------------------------
      // Restricted public member data.
      //------------------------------------------------------------------------

      WitPreRestricted <int> sortedPartIndex_;
         //
         // # Parts before this Part in the sorted list of Parts.

      WitPreRestricted <WitPtrTVec <WitBopEntry> > expBopEntry_;
         //
         // expBopEntry_[thePer] is the preferred BopEntry to be used
         // for explosions in order to produce this Part in period thePer.
         // expBopEntry_[thePer] != NULL iff this Part can be exploded in 
         // thePer.

      WitPreRestricted <WitPtrVec <WitPart> > belowList_;
         //
         // The list of all parts in the multilevel BOM extending downward from
         // this Part, including this Part itself. The list is in
         // downward order, so this Part is always its first element.
         // Considers all BopEntries that produce this Part for which expAllowed
         // is true. The purpose of this data is for its use in heuristic
         // implosion/allocation.

      WitPreRestricted <bool> expPerGaps_;
         //
         // true, iff there is at least one period, fillPer, such that:
         // * this Part is not explodeable in fillPer, and
         // * there is an earlier period, expPer in which this Part is 
         //   explodeable and the result can be stock thru fillPer.
         // explosionPeriod () will search for an earlier explosion period iff
         // expPerGaps_ is true.

      WitPostRestricted <WitDblFlexVec> prodVol_;
         //
         // prodVol_[thePer] is the total volume of this Part that was produced
         // in thePer by all Operations.

      WitPostRestricted <WitDblFlexVec> consVol_;
         //
         // consVol_[thePer] is total the volume of this Part that was consumed
         // in thePer by all Operations.

      WitPostRestricted <WitDblFlexVec> residualVol_;
         //
         // residualVol_[thePer] is the amount by which consumption of this Part
         // could be increased in thePer, without making the current implosion
         // solution infeasible.

      WitOptPostRestricted <WitDblFlexVec> scrapVol_;
         //
         // scrapVol_[thePer] is the volume of this Part that was scrapped in
         // thePer.

      WitImpRestricted <WitDblFlexVec> shadowPrice_;
         //
         // shadowPrice_[thePer] is the shadow price (dual variable value) for
         // the resource allocation constraint in this Part in thePer.
         // Valid only if myOptComp ()->compPrices () is true.

      WitMrpRestricted <WitDblFlexVec> reqVol_;
         //
         // reqVol[thePer] is the required volume of the part in thePer.
         // This field is the main output of mrp.

      WitMrpRestricted <WitDblFlexVec> mrpConsVol_;
         //
         // Same as consVol, but for MRP.

      WitMrpRestricted <WitDblFlexVec> mrpResidualVol_;
         //
         // Same as residualVol, but for MRP.

      WitFssRestricted <WitDblFlexVec> focShortageVol_;
         //
         // The Focussed Shortage Volume for this Part.

d350 93
@


1.77
log
@[disallowed backlog]
@
text
@d136 5
a184 8
      void resetShadowPrice ();
         //
         // Sets shadowPrice_ to 0.0.

      static void transmitDMPs ();
         //
         // See comment on transmitAllDMPs in CompMgr.h.

d195 6
d210 1
a210 6
      accessFunc (const WitDblFlexVec &,         shadowPrice)
      accessFunc (const WitDblFlexVec &,         mrpConsVol)
      accessFunc (const WitDblFlexVec &,         mrpResidualVol)
      accessFunc (const WitDblFlexVec &,         reqVol)
      accessFunc (const WitDblFlexVec &,         focShortageVol)

d272 23
a419 35

      //------------------------------------------------------------------------
      // Data set by optimizing implosion.
      //------------------------------------------------------------------------

      WitDblFlexVec shadowPrice_;
         //
         // shadowPrice_[thePer] is the shadow price (dual variable value) for
         // the resource allocation constraint in this Part in thePer.
         // Valid only if myOptComp ()->compPrices () is true.

      //------------------------------------------------------------------------
      // Data set by MRP.
      //------------------------------------------------------------------------

      WitDblFlexVec reqVol_;
         //
         // reqVol[thePer] is the required volume of the part in thePer.
         // This field is the main output of mrp.

      WitDblFlexVec mrpConsVol_;
         //
         // Same as consVol, but for MRP.

      WitDblFlexVec mrpResidualVol_;
         //
         // Same as residualVol, but for MRP.

      //------------------------------------------------------------------------
      // Data set by FSS.
      //------------------------------------------------------------------------

      WitDblFlexVec focShortageVol_;
         //
         // The Focussed Shortage Volume for this Part.
@


1.76
log
@[disallowed backlog]
@
text
@a111 4
      virtual void unpreprocess ();
         //
         // Override from class Component.

d193 1
a206 1
      accessFunc (const WitPtrVec <WitPart> &,   belowList)
d228 25
a400 29
      // Data set by preprocessing.
      //------------------------------------------------------------------------

      WitPtrTVec <WitBopEntry> expBopEntry_;
         //
         // expBopEntry_[thePer] is the preferred BopEntry to be used
         // for explosions in order to produce this Part in period thePer.
         // expBopEntry_[thePer] != NULL iff this Part can be exploded in 
         // thePer.

      WitPtrVec <WitPart> belowList_;
         //
         // The list of all parts in the multilevel BOM extending downward from
         // this Part, including this Part itself. The list is in
         // downward order, so this Part is always its first element.
         // Considers all BopEntries that produce this Part for which expAllowed
         // is true. The purpose of this data is for its use in heuristic
         // implosion/allocation.

      bool expPerGaps_;
         //
         // true, iff there is at least one period, fillPer, such that:
         // * this Part is not explodeable in fillPer, and
         // * there is an earlier period, expPer in which this Part is 
         //   explodeable and the result can be stock thru fillPer.
         // explosionPeriod () will search for an earlier explosion period iff
         // expPerGaps_ is true.

      //------------------------------------------------------------------------
@


1.75
log
@[disallowed backlog]
@
text
@d196 1
a209 1
      accessFunc (int,                           sortedPartIndex)
d228 4
a382 4
      int sortedPartIndex_;
         //
         // # Parts before this Part in the sorted list of Parts.

@


1.74
log
@[disallowed backlog]
@
text
@d16 1
a16 5
// Contains the declaration of the following classes:
//
//    PartPostData
//    PartOptPostData
//    Part
d23 1
a23 95

//------------------------------------------------------------------------------
// Class PartPostData
//
// Owns the data of a Part that is computed by postprocessing.
//------------------------------------------------------------------------------

class WitPartPostData
   {
      friend class WitPart;
      friend class WitPostprocessor;

   private:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPartPostData (WitProblem *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitPartPostData ();

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPartPostData);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitDblFlexVec prodVol_;
         //
         // prodVol_[thePer] is the total volume of the owning Part that was
         // produced in thePer by all Operations.

      WitDblFlexVec consVol_;
         //
         // consVol_[thePer] is total the volume of the owning Part that was
         // consumed in thePer by all Operations.

      WitDblFlexVec residualVol_;
         //
         // residualVol_[thePer] is the amount by which consumption of the 
         // owning Part could be increased in thePer, without making the current
         // implosion solution infeasible.
   };

//------------------------------------------------------------------------------
// Class PartOptPostData
//
// Owns the data of a Part that is computed by optimizing implosion and
// postprocessing.
//------------------------------------------------------------------------------

class WitPartOptPostData
   {
      friend class WitPart;
      friend class WitOptImploder;
      friend class WitPostprocessor;

   private:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPartOptPostData (WitProblem *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitPartOptPostData ();

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPartOptPostData);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitDblFlexVec scrapVol_;
         //
         // scrapVol_[thePer] is the volume of the owning part that was scrapped
         // in thePer.
   };
d196 4
a216 8
      accessNonConst (WitPartPostData &,    myPostData)
      accessNonConst (WitPartOptPostData &, myOptPostData)

      accessObjData (const WitDblFlexVec &, prodVol,     myPostData_)
      accessObjData (const WitDblFlexVec &, consVol,     myPostData_)
      accessObjData (const WitDblFlexVec &, residualVol, myPostData_)
      accessObjData (const WitDblFlexVec &, scrapVol,    myOptPostData_)

d224 25
a441 7

      //------------------------------------------------------------------------
      // Private member data computed by other classes.
      //------------------------------------------------------------------------

      WitPartPostData    myPostData_;
      WitPartOptPostData myOptPostData_;
@


1.73
log
@[disallowed backlog]
@
text
@d19 1
d65 56
a120 2
         // prodVol_[thePer] is total volume of the owning Part that is produced
         // in thePer by all Operations.
a305 3
      accessFunc (const WitDblFlexVec &,         consVol)
      accessFunc (const WitDblFlexVec &,         scrapVol)
      accessFunc (const WitDblFlexVec &,         residualVol)
d311 2
a312 1
      accessNonConst (WitPartPostData &, myPostData)
d314 4
a317 1
      accessObjData (const WitDblFlexVec &, prodVol, myPostData_)
a495 20
      // Data set by postprocessing.
      //------------------------------------------------------------------------

      WitDblFlexVec consVol_;
         //
         // consVol_[thePer] is the volume of this Part that was consumed in
         // thePer.

      WitDblFlexVec scrapVol_;
         //
         // scrapVol_[thePer] is the volume of this part that was scrapped in
         // thePer.

      WitDblFlexVec residualVol_;
         //
         // residualVol_[thePer] is the amount by which consumption of this Part
         // could be increased in thePer, without making the current implosion
         // solution infeasible.

      //------------------------------------------------------------------------
d524 2
a525 1
      WitPartPostData myPostData_;
@


1.72
log
@Disallowed backlog.
@
text
@d259 4
a269 10
      inline const WitDblFlexVec & prodVol ()
         {
         return myPostData_.prodVol_;
         }

      inline WitPartPostData & myPostData ()
         {
         return myPostData_;
         }

@


1.71
log
@[disallowed backlog]
@
text
@d18 1
d28 41
a250 1
      accessFunc (const WitDblFlexVec &,         prodVol)
d266 10
a448 5
      WitDblFlexVec prodVol_;
         //
         // prodVol_[thePer] is total volume of this Part that is produced in
         // thePer by all Operations.

d489 6
@


1.70
log
@[disAllowed backlog]
@
text
@a24 1
#include <Updated.h>
@


1.69
log
@[backlog avoidance]
@
text
@d210 1
a225 13
      //------------------------------------------------------------------------
      // Public member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Data set by postprocessing.
      //------------------------------------------------------------------------

      WitPostprocUpdated <WitDblFlexVec> prodVol;
         //
         // prodVol ()[thePer] is total volume of this Part that is produced in
         // thePer by all Operations.

d399 5
d406 1
a406 1
         // consVol[thePer] is the volume of this Part that was consumed in
@


1.68
log
@witCopy<Object>Data
@
text
@d25 1
a210 1
      accessFunc (const WitDblFlexVec &,         prodVol)
d225 13
a415 5
      WitDblFlexVec prodVol_;
         //
         // prodVol[thePer] is total volume of this Part that is produced in
         // thePer by all Operations.

@


1.67
log
@External opt implosion.
@
text
@d121 1
a121 1
      virtual WitMsgFragID categoryFragID () = 0;
d123 1
a123 1
         // Returns a message fragment ID indicating category of this Part.
a136 4
      bool isaCapacity ();
         //
         // Return true, iff this Part is actually a Capacity.

@


1.66
log
@NSTN residualVols
@
text
@d395 1
a395 1
         // the resource conservation constraint in this Part in thePer.
@


1.65
log
@Updated the copyright date on all source files.
@
text
@a176 6
      virtual const WitDblFlexVec & residualVol () = 0;
         //
         // After postprocessing, residualVol ()[thePer] is the amount by which
         // consumption of this Part could be increased in thePer, without
         // making the current implosion solution infeasible.

d216 1
d379 9
d417 1
a417 1
      bool expPerGaps_;
d419 3
a421 6
         // true, iff there is at least one period, fillPer, such that:
         // * this Part is not explodeable in fillPer, and
         // * there is an earlier period, expPer in which this Part is 
         //   explodeable and the result can be stock thru fillPer.
         // explosionPeriod () will search for an earlier explosion period iff
         // expPerGaps_ is true.
@


1.64
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.63
log
@[shared-resource pegging]
@
text
@d24 1
a24 1
#include <Dense.h>
d207 19
a225 19
      accessFunc (const WitList <WitDemand> &,    myDemands)
      accessFunc (const WitList <WitBomEntry> &,  consumingBomEntries)
      accessFunc (const WitList <WitSubEntry> &,  consumingSubEntries)
      accessFunc (const WitList <WitBopEntry> &,  producingBopEntries)
      accessFunc (const WitDblFlexVec &,          supplyVol)
      accessFunc (bool,                           singleSource)
      accessFunc (const WitFlexVec <bool> &,      propRtg)
      accessFunc (double,                         unitCost)
      accessFunc (const WitDblFlexVec &,          scrapCost)
      accessFunc (int,                            sortedPartIndex)
      accessFunc (const WitDenseList <WitPart> &, belowList)
      accessFunc (const WitDblFlexVec &,          shadowPrice)
      accessFunc (const WitDblFlexVec &,          consVol)
      accessFunc (const WitDblFlexVec &,          prodVol)
      accessFunc (const WitDblFlexVec &,          scrapVol)
      accessFunc (const WitDblFlexVec &,          mrpConsVol)
      accessFunc (const WitDblFlexVec &,          mrpResidualVol)
      accessFunc (const WitDblFlexVec &,          reqVol)
      accessFunc (const WitDblFlexVec &,          focShortageVol)
d375 1
a375 1
      WitDenseList <WitPart> belowList_;
@


1.62
log
@[multi-thread]
@
text
@d147 1
a147 1
         return fromTlObj_cast <WitPart> (theItr.key ());
@


1.61
log
@[multi-thread]
@
text
@d23 2
a47 2
      static void transmitData ();

a120 8
      virtual void loadPre  ();
      virtual void loadPost ();
      virtual void loadMrp  ();
      virtual void loadFss  ();
      virtual void loadOpt  ();
         //
         // Override from class Component.

d199 4
d368 1
a368 1
      WitPtrTVec <WitBopEntry> & expBopEntry_;
d375 1
a375 1
      WitDenseList <WitPart> & belowList_;
@


1.60
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@d46 2
a54 31
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const WitList <WitDemand> &,    myDemands)
      accessFunc (const WitList <WitBomEntry> &,  consumingBomEntries)
      accessFunc (const WitList <WitSubEntry> &,  consumingSubEntries)
      accessFunc (const WitList <WitBopEntry> &,  producingBopEntries)
      accessFunc (const WitDblFlexVec &,          supplyVol)
      accessFunc (bool,                           singleSource)
      accessFunc (const WitFlexVec <bool> &,      propRtg)
      accessFunc (double,                         unitCost)
      accessFunc (const WitDblFlexVec &,          scrapCost)
      accessFunc (int,                            sortedPartIndex)
      accessFunc (const WitDenseList <WitPart> &, belowList)
      accessFunc (const WitDblFlexVec &,          shadowPrice)
      accessFunc (const WitDblFlexVec &,          consVol)
      accessFunc (const WitDblFlexVec &,          prodVol)
      accessFunc (const WitDblFlexVec &,          scrapVol)
      accessFunc (const WitDblFlexVec &,          mrpConsVol)
      accessFunc (const WitDblFlexVec &,          mrpResidualVol)
      accessFunc (const WitDblFlexVec &,          reqVol)
      accessFunc (const WitDblFlexVec &,          focShortageVol)

      WitBopEntry * expBopEntry (WitPeriod thePer);

      inline const WitString & partName ()
         {
         return nodeName ();
         }

      //------------------------------------------------------------------------
d207 31
@


1.59
log
@Vector PropRtg.
@
text
@d64 1
a64 1
      accessFunc (const WitDblFlexVec &,          obj1ScrapCost)
d95 5
a99 5
      defaultValue (double defSupplyVol,     0.0)
      defaultValue (bool   defSingleSource,  false)
      defaultValue (bool   defPropRtg,       false)
      defaultValue (double defUnitCost,      1.0)
      defaultValue (double defObj1ScrapCost, 0.0)
d105 5
a109 5
      void setSupplyVol     (const WitIVRealArg &);
      void setSingleSource  (bool);
      void setPropRtg       (const WitBoolean *);
      void setUnitCost      (double);
      void setObj1ScrapCost (const WitIVRealArg &);
d355 1
a355 1
      WitDblFlexVec obj1ScrapCost_;
d357 1
a357 1
         // If objective #1 is being used, then thePart->obj1ScrapCost ()[t] is
@


1.58
log
@Vector PropRtg.
@
text
@a106 1
      void setPropRouting   (bool);
@


1.57
log
@Vector PropRtg.
@
text
@a61 1
      accessFunc (bool,                           propRouting)
a96 1
      defaultValue (bool   defPropRouting,   false)
a345 5
      bool propRouting_;
         //
         // Same as propRtg_[0].
         // To be removed.

d349 1
a349 1
         // in thePer, iff propRouting_[thePer] is true.
@


1.56
log
@Vector PropRtg.
@
text
@d350 2
a351 2
         // The proportionate routing technique is to be applied to this Part,
         // iff propRouting_ is true.
d355 2
a356 1
         // propRtg_[thePer] == propRouting_ in all periods.
@


1.55
log
@Vector Prop-Rtg.
@
text
@d63 1
a63 1
      accessFunc (const WitFlexVec <bool> &,      propRt)
d99 1
a99 1
      defaultValue (bool   defPropRt,        false)
d110 1
a110 1
      void setPropRt        (const WitBoolean *);
d353 1
a353 1
      WitFlexVec <bool> propRt_;
d355 1
a355 1
         // propRt_[thePer] == propRouting_ in all periods.
@


1.54
log
@Vector PropRt.
@
text
@d355 1
a355 1
         // Under construction.
@


1.53
log
@Vector propRt.
@
text
@d107 1
a107 1
      void setSupplyVol     (const WitInVecRA &);
d112 1
a112 1
      void setObj1ScrapCost (const WitInVecRA &);
@


1.52
log
@Pegged critical list.
@
text
@d63 1
d99 1
d110 1
d353 4
@


1.51
log
@Altered the below list to improve robustness.
@
text
@a75 2
      accessNonNull (WitRtSite *,                 myRtSite)

a235 5
      void attach       (WitRtSite *);
      void detachRtSite ();
         //
         // Sets and resets myRtSite_.

a386 9
      // Data set by heuristic allocation.
      //------------------------------------------------------------------------

      WitRtSite * myRtSite_;
         //
         // The RtSite that represents this Part, during heuristic allocation.
         // NULL, when heuristic allocation is inactive.

      //------------------------------------------------------------------------
@


1.50
log
@Fixed a bug in the screening of the optimization model.
@
text
@d390 2
a391 9
         // is true.
         // For each SubEntry for each Operation that produces this Part:
         //    If multiRoute is true and the Sub's expAllowed is true,
         //       belowList_ includes the below list of the consumed Part.
         //    else if the Sub's netAllowed is true,
         //       belowList_ includes only the consumed Part itself.
         //    else
         //       belowList_ includes nothing for the Sub.
         // This data is tailor made for heuristic implosion/allocation.
@


1.49
log
@Double Precision.
@
text
@a66 1
      accessFunc (const WitFlexVec <bool> &,      isCoproduced)
a398 18

      WitFlexVec <bool> isCoproduced_;
         //
         // isCoproduced_[thePer] is true, iff this Part is coproduced in 
         // thePer.
         // A Part is considered to be a broad product of an Operation, iff:
         //    It's a BopEntry for the Operation with a positive productRate, or
         //    it's a ConsEntry for the Operation with a negative consRate.
         // Thus when the Operation is executed, the Part is (in a broad sense)
         //    "produced".
         // A Operation is considered to be coproducing, iff it has more than 1
         //    broad product.
         // A Part is considered to be coproduced, iff it is a broad product
         //    of at least one coproducing Operation.
         // The significance of this is that, if a Part is coproduced, then
         // it may get (broadly) produced by an Operation that is being
         // executed in order to produce a different Part. If it is not
         // coproduced, this can't happen.
@


1.48
log
@Double Precision.
@
text
@d112 1
a112 1
      void setObj1ScrapCost (const float *);
@


1.47
log
@Double Precision.
@
text
@a107 1
      void setSupplyVol     (const float *);
@


1.46
log
@Double Precision.
@
text
@d60 1
a60 1
      accessFunc (const WitFlexVec <double> &,    supplyVol)
d64 1
a64 1
      accessFunc (const WitFlexVec <double> &,    obj1ScrapCost)
d68 8
a75 8
      accessFunc (const WitFlexVec <double> &,    shadowPrice)
      accessFunc (const WitFlexVec <double> &,    consVol)
      accessFunc (const WitFlexVec <double> &,    prodVol)
      accessFunc (const WitFlexVec <double> &,    scrapVol)
      accessFunc (const WitFlexVec <double> &,    mrpConsVol)
      accessFunc (const WitFlexVec <double> &,    mrpResidualVol)
      accessFunc (const WitFlexVec <double> &,    reqVol)
      accessFunc (const WitFlexVec <double> &,    focShortageVol)
d218 1
a218 1
      virtual const WitFlexVec <double> & residualVol () = 0;
d344 1
a344 1
      WitFlexVec <double> supplyVol_;
d364 1
a364 1
      WitFlexVec <double> obj1ScrapCost_;
d433 1
a433 1
      WitFlexVec <double> shadowPrice_;
d443 1
a443 1
      WitFlexVec <double> consVol_;
d448 1
a448 1
      WitFlexVec <double> prodVol_;
d453 1
a453 1
      WitFlexVec <double> scrapVol_;
d471 1
a471 1
      WitFlexVec <double> reqVol_;
d476 1
a476 1
      WitFlexVec <double> mrpConsVol_;
d480 1
a480 1
      WitFlexVec <double> mrpResidualVol_;
d488 1
a488 1
      WitFlexVec <double> focShortageVol_;
@


1.45
log
@Double Precision.
@
text
@d109 1
@


1.44
log
@Double Precision.
@
text
@d22 1
a22 1
#include <RealVec.h>
d60 1
a60 1
      accessFunc (const WitRealVec &,             supplyVol)
d64 1
a64 1
      accessFunc (const WitRealVec &,             obj1ScrapCost)
d68 8
a75 8
      accessFunc (const WitRealVec &,             shadowPrice)
      accessFunc (const WitRealVec &,             consVol)
      accessFunc (const WitRealVec &,             prodVol)
      accessFunc (const WitRealVec &,             scrapVol)
      accessFunc (const WitRealVec &,             mrpConsVol)
      accessFunc (const WitRealVec &,             mrpResidualVol)
      accessFunc (const WitRealVec &,             reqVol)
      accessFunc (const WitRealVec &,             focShortageVol)
d217 1
a217 1
      virtual const WitRealVec & residualVol () = 0;
d343 1
a343 1
      WitRealVec supplyVol_;
d363 1
a363 1
      WitRealVec obj1ScrapCost_;
d432 1
a432 1
      WitRealVec shadowPrice_;
d442 1
a442 1
      WitRealVec consVol_;
d447 1
a447 1
      WitRealVec prodVol_;
d452 1
a452 1
      WitRealVec scrapVol_;
d470 1
a470 1
      WitRealVec reqVol_;
d475 1
a475 1
      WitRealVec mrpConsVol_;
d479 1
a479 1
      WitRealVec mrpResidualVol_;
d487 1
a487 1
      WitRealVec focShortageVol_;
@


1.43
log
@Double Precision.
@
text
@d98 1
a98 1
      defaultValue (float  defSupplyVol,     0.0)
d102 1
a102 1
      defaultValue (float  defObj1ScrapCost, 0.0)
@


1.42
log
@Double Precision.
@
text
@d70 6
a75 6
      accessFunc (const WitFlexVec <float> &,     prodVol)
      accessFunc (const WitFlexVec <float> &,     scrapVol)
      accessFunc (const WitFlexVec <float> &,     mrpConsVol)
      accessFunc (const WitFlexVec <float> &,     mrpResidualVol)
      accessFunc (const WitFlexVec <float> &,     reqVol)
      accessFunc (const WitFlexVec <float> &,     focShortageVol)
d217 1
a217 1
      virtual const WitFlexVec <float> & residualVol () = 0;
d219 2
a220 2
         // After postprocessing, residualVol ()[t] is the amount by which
         // consumption of this Part could be increased in period t, without
d444 2
a445 1
         // consVol[t] is the volume of this Part that was consumed in period t
d447 1
a447 1
      WitFlexVec <float> prodVol_;
d449 2
a450 2
         // prodVol[t] is total volume of this Part that is produced in
         // period t by all Operations.
d452 1
a452 1
      WitFlexVec <float> scrapVol_;
d454 2
a455 2
         // scrapVol_[t] is the volume of this part that was scrapped in period
         // t.
d470 1
a470 1
      WitFlexVec <float> reqVol_;
d472 1
a472 1
         // reqVol[t] is the required volume of the part in period t.
d475 1
a475 1
      WitFlexVec <float> mrpConsVol_;
d479 1
a479 1
      WitFlexVec <float> mrpResidualVol_;
d487 1
a487 1
      WitFlexVec <float> focShortageVol_;
@


1.41
log
@Continued double precision.
@
text
@d22 1
a22 1
#include <FlexVec.h>
d60 1
a60 1
      accessFunc (const WitFlexVec <float> &,     supplyVol)
d64 1
a64 1
      accessFunc (const WitFlexVec <float> &,     obj1ScrapCost)
d68 2
a69 2
      accessFunc (const WitFlexVec <float> &,     shadowPrice)
      accessFunc (const WitFlexVec <float> &,     consVol)
d343 1
a343 1
      WitFlexVec <float> supplyVol_;
d363 1
a363 1
      WitFlexVec <float> obj1ScrapCost_;
d432 1
a432 1
      WitFlexVec <float> shadowPrice_;
d442 1
a442 1
      WitFlexVec <float> consVol_;
@


1.40
log
@Continued double precision.
@
text
@d63 1
a63 1
      accessFunc (StrDbl,                         unitCost)
d101 1
a101 1
      defaultValue (StrDbl defUnitCost,      1.0)
d111 1
a111 1
      void setUnitCost      (StrDbl);
d358 1
a358 1
      StrDbl unitCost_;
@


1.39
log
@Removed a bad function overload.
@
text
@d63 1
a63 1
      accessFunc (float,                          unitCost)
d98 5
a102 5
      defaultValue (float defSupplyVol,     0.0)
      defaultValue (bool  defSingleSource,  false)
      defaultValue (bool  defPropRouting,   false)
      defaultValue (float defUnitCost,      1.0)
      defaultValue (float defObj1ScrapCost, 0.0)
d111 1
a111 1
      void setUnitCost      (float);
d358 1
a358 1
      float unitCost_;
@


1.38
log
@Continued implementation of proportionate routing.
@
text
@d149 1
a149 1
      virtual WitPart * myPart ();
@


1.37
log
@Continued implementation of proportionate routing.
@
text
@d149 1
a149 1
      virtual void getPart (WitPart * &);
@


1.36
log
@Continued implementation of proportionate routing.
@
text
@a67 1
      accessFunc (WitRtSite *,                    myRtSite)
d76 2
@


1.35
log
@Continued implementation of proportionate routing.
@
text
@d68 1
a76 2

      accessNonNull (WitRtSite *, myRtSite)
@


1.34
log
@Continued implementation of proportionate routing.
@
text
@d77 2
d239 5
d418 9
@


1.33
log
@Continued implementation of proportionate routing.
@
text
@d62 1
d98 1
d108 1
d345 5
@


1.32
log
@Replaced some C style casts with C++ style casts.
@
text
@d76 1
a76 1
      decMappingIndex (WitPart)
d83 7
a89 1
      WitBopEntry * expBopEntry (WitPeriod thePer);
@


1.31
log
@Internal changes.
@
text
@d176 1
a176 1
         return (WitPart *) theItr.key ();
@


1.30
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d56 19
a74 19
      accessFunc (const WitList <WitDemand> &,     myDemands)
      accessFunc (const WitList <WitBomEntry> &,   consumingBomEntries)
      accessFunc (const WitList <WitSubEntry> &,   consumingSubEntries)
      accessFunc (const WitList <WitBopEntry> &,   producingBopEntries)
      accessFunc (const WitFlexVec <float> &,      supplyVol)
      accessFunc (WitBoolean,                      singleSource)
      accessFunc (float,                           unitCost)
      accessFunc (const WitFlexVec <float> &,      obj1ScrapCost)
      accessFunc (int,                             sortedPartIndex)
      accessFunc (const WitDenseList <WitPart> &,  belowList)
      accessFunc (const WitFlexVec <WitBoolean> &, isCoproduced)
      accessFunc (const WitFlexVec <float> &,      shadowPrice)
      accessFunc (const WitFlexVec <float> &,      consVol)
      accessFunc (const WitFlexVec <float> &,      prodVol)
      accessFunc (const WitFlexVec <float> &,      scrapVol)
      accessFunc (const WitFlexVec <float> &,      mrpConsVol)
      accessFunc (const WitFlexVec <float> &,      mrpResidualVol)
      accessFunc (const WitFlexVec <float> &,      reqVol)
      accessFunc (const WitFlexVec <float> &,      focShortageVol)
d89 4
a92 4
      defaultValue (float      defSupplyVol,     0.0)
      defaultValue (WitBoolean defSingleSource,  witFALSE)
      defaultValue (float      defUnitCost,      1.0)
      defaultValue (float      defObj1ScrapCost, 0.0)
d99 1
a99 1
      void setSingleSource  (WitBoolean);
d118 1
a118 1
      virtual WitBoolean inserted ();
d158 1
a158 1
      virtual WitBoolean canStock (WitPeriod thePer) = 0;
d160 1
a160 1
         // Returns TRUE iff part this Part can be stocked in period thePer.
d166 1
a166 1
      WitBoolean isaCapacity ();
d168 1
a168 1
         // Return TRUE, iff this Part is actually a Capacity.
d192 1
a192 1
      WitBoolean explodeable (WitPeriod thePer);
d194 1
a194 1
         // Returns TRUE iff this Part can be exploded in period thePer.
d332 1
a332 1
      WitBoolean singleSource_;
d335 1
a335 1
         // singleSource_ is TRUE.
d370 1
a370 1
         // is TRUE.
d372 1
a372 1
         //    If multiRoute is TRUE and the Sub's expAllowed is TRUE,
d374 1
a374 1
         //    else if the Sub's netAllowed is TRUE,
d380 1
a380 1
      WitFlexVec <WitBoolean> isCoproduced_;
d382 1
a382 1
         // isCoproduced_[thePer] is TRUE, iff this Part is coproduced in 
d406 1
a406 1
         // Valid only if myOptComp ()->compPrices () is TRUE.
d426 1
a426 1
      WitBoolean expPerGaps_;
d428 1
a428 1
         // TRUE, iff there is at least one period, fillPer, such that:
d433 1
a433 1
         // expPerGaps_ is TRUE.
@


1.29
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d218 1
a218 1
         // Prints the dual MP solution for this Part.
@


1.28
log
@Continued implementation of single-source.
@
text
@d218 1
a218 1
         // Prints the dual LP                 solution for this Part.
@


1.27
log
@Continued implementation of single-source.
@
text
@a103 7
      // Conditional reference access functions.
      //------------------------------------------------------------------------

      conditionalRef (WitFlexVec <float>, scrapVol,    optImpAcc ())
      conditionalRef (WitFlexVec <float>, shadowPrice, optImpAcc ())

      //------------------------------------------------------------------------
d146 1
@


1.26
log
@Continued implementation of single-source.
@
text
@d107 2
a108 10
      conditionalRef (WitList <WitBopEntry>,    producingBopEntries,
                                                              preprocAcc ())
      conditionalRef (int,                      sortedPartIndex, 
                                                              preprocAcc ())
      conditionalRef (WitDenseList <WitPart>,   belowList,    preprocAcc ())
      conditionalRef (WitFlexVec <WitBoolean>,  isCoproduced, preprocAcc ())
      conditionalRef (WitPtrTVec <WitBopEntry>, expBopEntry,  preprocAcc ())
      conditionalRef (WitFlexVec <float>,       scrapVol,      optImpAcc ())
      conditionalRef (WitFlexVec <float>,       shadowPrice,   optImpAcc ())
      conditionalRef (WitBoolean,               expPerGaps,   preprocAcc ())
d141 4
d149 1
@


1.25
log
@Continued implementation of single-source.
@
text
@d114 1
a114 2
      conditionalRef (WitFlexVec <float>,       scrapVol,      optImpAcc () ||
                                                             postprocAcc ())
a116 6
      conditionalRef (WitFlexVec <float>,       consVol,     postprocAcc ())
      conditionalRef (WitFlexVec <float>,       prodVol,     postprocAcc ())
      conditionalRef (WitFlexVec <float>,       focShortageVol,   fssAcc ())
      conditionalRef (WitFlexVec <float>,       reqVol,           mrpAcc ())
      conditionalRef (WitFlexVec <float>,       mrpConsVol,       mrpAcc ())
      conditionalRef (WitFlexVec <float>,       mrpResidualVol,   mrpAcc ())
d150 6
@


1.24
log
@Continued implementation of single-source.
@
text
@d114 2
a115 1
      conditionalRef (WitFlexVec <float>,       scrapVol,      optImpAcc ())
d118 6
a159 5
      virtual void importMrpResults ();
      virtual void importFssResults ();
         //
         // Override from class Component.

a237 16
      void compConsVol (WitTVec <double> & theDblTVec);
         //
         // Computes consVol_.
         // Uses theDblTVec as a working vector.

      void compProdVol (WitTVec <double> & theDblTVec);
         //
         // Computes prodVol_.
         // Uses theDblTVec as a working vector.

      virtual void compStockScrapVol (
            WitTVec <double> & theDblTVec1,
            WitTVec <double> & theDblTVec2) = 0;
         //
         // Computes scrapVol_ and, if this Part is a Material, stockVol_.

a278 10
      inline WitFlexVec <float> & scrapVolForUpdate ()
         {
         return scrapVol_;
         }

      double unstockedScrapVol (WitPeriod thePer);
         //
         // Computes and returns what scrapVol_[thePer] would be if stocking
         // were not allowed. (May return a negative number.)

@


1.23
log
@Continued implementation of single-source.
@
text
@d153 2
a154 3
      virtual void importPostprocResults ();
      virtual void importMrpResults      ();
      virtual void importFssResults      ();
d236 16
d293 10
@


1.22
log
@Continued implementation of single-source.
@
text
@d114 1
a114 2
      conditionalRef (WitFlexVec <float>,       scrapVol,      optImpAcc () ||
                                                             postprocAcc ())
a116 2
      conditionalRef (WitFlexVec <float>,       consVol,     postprocAcc ())
      conditionalRef (WitFlexVec <float>,       prodVol,     postprocAcc ())
d153 3
a155 2
      virtual void importMrpResults ();
      virtual void importFssResults ();
@


1.21
log
@Continued implementation of single-source.
@
text
@a119 1
      conditionalRef (WitFlexVec <float>,       focShortageVol,   fssAcc ())
d157 1
@


1.20
log
@Continued implementation of single-source.
@
text
@a120 3
      conditionalRef (WitFlexVec <float>,       reqVol,           mrpAcc ())
      conditionalRef (WitFlexVec <float>,       mrpConsVol,       mrpAcc ())
      conditionalRef (WitFlexVec <float>,       mrpResidualVol,   mrpAcc ())
d154 4
@


1.19
log
@Continued implementation of single-source.
@
text
@d329 1
a329 1
         // theBopEnt->myPart_ == this Material.
@


1.18
log
@Preliminary work on single source.
@
text
@d61 1
d89 4
a92 3
      defaultValue (float defSupplyVol,     0.0)
      defaultValue (float defUnitCost,      1.0)
      defaultValue (float defObj1ScrapCost, 0.0)
d99 1
d341 5
@


1.17
log
@Continued preliminary work on single source.
@
text
@d60 1
a60 1
      accessFunc (const WitFlexVec (float) &,      supplyVol)
d62 1
a62 1
      accessFunc (const WitFlexVec (float) &,      obj1ScrapCost)
d65 9
a73 9
      accessFunc (const WitFlexVec (WitBoolean) &, isCoproduced)
      accessFunc (const WitFlexVec (float) &,      shadowPrice)
      accessFunc (const WitFlexVec (float) &,      consVol)
      accessFunc (const WitFlexVec (float) &,      prodVol)
      accessFunc (const WitFlexVec (float) &,      scrapVol)
      accessFunc (const WitFlexVec (float) &,      mrpConsVol)
      accessFunc (const WitFlexVec (float) &,      mrpResidualVol)
      accessFunc (const WitFlexVec (float) &,      reqVol)
      accessFunc (const WitFlexVec (float) &,      focShortageVol)
d109 1
a109 1
      conditionalRef (WitFlexVec (WitBoolean),  isCoproduced, preprocAcc ())
d111 1
a111 1
      conditionalRef (WitFlexVec (float),       scrapVol,      optImpAcc () ||
d113 1
a113 1
      conditionalRef (WitFlexVec (float),       shadowPrice,   optImpAcc ())
d115 6
a120 6
      conditionalRef (WitFlexVec (float),       consVol,     postprocAcc ())
      conditionalRef (WitFlexVec (float),       prodVol,     postprocAcc ())
      conditionalRef (WitFlexVec (float),       focShortageVol,   fssAcc ())
      conditionalRef (WitFlexVec (float),       reqVol,           mrpAcc ())
      conditionalRef (WitFlexVec (float),       mrpConsVol,       mrpAcc ())
      conditionalRef (WitFlexVec (float),       mrpResidualVol,   mrpAcc ())
d213 1
a213 1
      virtual const WitFlexVec (float) & residualVol () = 0;
d334 1
a334 1
      WitFlexVec (float) supplyVol_;
d344 1
a344 1
      WitFlexVec (float) obj1ScrapCost_;
d382 1
a382 1
      WitFlexVec (WitBoolean) isCoproduced_;
d404 1
a404 1
      WitFlexVec (float) shadowPrice_;
d414 1
a414 1
      WitFlexVec (float) consVol_;
d418 1
a418 1
      WitFlexVec (float) prodVol_;
d423 1
a423 1
      WitFlexVec (float) scrapVol_;
d441 1
a441 1
      WitFlexVec (float) reqVol_;
d446 1
a446 1
      WitFlexVec (float) mrpConsVol_;
d450 1
a450 1
      WitFlexVec (float) mrpResidualVol_;
d458 1
a458 1
      WitFlexVec (float) focShortageVol_;
@


1.16
log
@More preliminary work on single source.
@
text
@d208 1
a208 1
            WitTVec (double) & supply);
@


1.15
log
@Preliminary work on single source.
@
text
@d64 1
a64 1
      accessFunc (const WitDenseList (WitPart) &,  belowList)
d108 1
a108 1
      conditionalRef (WitDenseList (WitPart),   belowList,    preprocAcc ())
d366 1
a366 1
      WitDenseList (WitPart) & belowList_;
@


1.14
log
@Continued implementation of object iteration.
@
text
@d56 4
a59 4
      accessFunc (const WitList (WitDemand) &,     myDemands)
      accessFunc (const WitList (WitBomEntry) &,   consumingBomEntries)
      accessFunc (const WitList (WitSubEntry) &,   consumingSubEntries)
      accessFunc (const WitList (WitBopEntry) &,   producingBopEntries)
d104 1
a104 1
      conditionalRef (WitList (WitBopEntry),    producingBopEntries,
d309 1
a309 1
      WitList (WitDemand) myDemands_;
d313 1
a313 1
      WitList (WitBomEntry) consumingBomEntries_;
d318 1
a318 1
      WitList (WitSubEntry) consumingSubEntries_;
d323 1
a323 1
      WitList (WitBopEntry) producingBopEntries_;
@


1.13
log
@Continued implementation of object iteration.
@
text
@d149 1
a149 1
      virtual WitAttr apiItrState ();
@


1.12
log
@Began implementation of object iteration.
@
text
@a46 9
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPart (const char * theName, WitCompMgr * theCompMgr);
         //
         // Node <<< theName.
         // Node <<< theCompMgr.

      //------------------------------------------------------------------------
d147 8
a158 1
         // Base class function.
a162 1
         // Base class function.
a166 1
         // Base class function.
d173 1
a173 1
      virtual WitMaterial * myMat ();
d175 1
a175 8
         // If this Part is a Material, returns the Material;
         // otherwise returns NULL.
         // The base class implementation does the NULL case.

      inline WitBoolean isaCapacity ()
         {
         return (myMat () == NULL);
         }
a178 1
         // Base class function.
a180 4
      virtual WitBoolean isaPart ();
         //
         // Override from class Node.

d241 13
a259 1
         // Base class function.
a272 1
         // Base class function.
@


1.11
log
@Continued development of Selective Stock Reallocation.
@
text
@d21 2
a22 1
#include <Opn.h>
@


1.10
log
@Continued implementation of selective stock reallocation.
@
text
@d176 1
a176 1
      virtual WitBoolean getMyMaterial (WitMaterial * & theMat);
d178 3
a180 3
         // If this Part is a Material, sets theMat to it and returns TRUE.
         // Otherwise sets theMat to NULL and returns FALSE.
         // The base class implementation does the FALSE case.
d182 4
a185 3
      virtual WitBoolean getMyCapacity (WitCapacity * & theCap);
         //
         // Same as getMyMaterial, but for Capacity.
@


1.9
log
@Minor change to shadow price code.
@
text
@d176 1
a176 1
      virtual WitBoolean isaMaterial (WitMaterial * & theMat);
d182 1
a182 1
      virtual WitBoolean isaCapacity (WitCapacity * & theCap);
d184 1
a184 1
         // Same as isaMaterial, but for Capacity.
@


1.8
log
@Added shadowPrice and compPrices attributes.
@
text
@d245 4
@


1.7
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d74 1
d121 1
d237 4
d398 10
@


1.6
log
@More templates.
@
text
@d71 1
d113 2
d347 4
@


1.5
log
@Coarse selection splitting.
@
text
@d114 1
a114 1
      conditionalRef (WitPtrTVec (WitBopEntry), expBopEntry,  preprocAcc ())
d345 1
a345 1
      WitPtrTVec (WitBopEntry) & expBopEntry_;
@


1.4
log
@Some minor changes.
@
text
@d242 4
a258 4

      void setPartIndex ();
         //
         // Sets mappingIndex_;
@


1.3
log
@Refactoring for selection splitting.
@
text
@d88 1
a88 6
      inline WitBopEntry * expBopEntry (WitPeriod thePer)
         {
         witAssert (explodeable (thePer));

         return expBopEntry_[thePer];
         }
d208 5
a212 8
      inline WitBoolean explodeable (WitPeriod thePer)
            //
            // Returns TRUE iff this Part can be exploded in period thePer.
            // Note that this implies that the relevent effProdRate is 
            // significantly positive.
         {
         return expBopEntry_.isAllocated () && expBopEntry_[thePer] != NULL;
         }
d345 1
a345 1
      WitPtrTVec (WitBopEntry) expBopEntry_;
d352 1
a352 1
      WitDenseList (WitPart) belowList_;
@


1.2
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d92 1
a92 1
         return (WitBopEntry *) expBopEntryTl_[thePer];
d115 1
a115 1
      conditionalRef (WitList (WitBopEntry),   producingBopEntries,
d117 4
a120 5
      conditionalRef (WitDenseList (WitPart),  belowList,     preprocAcc ())
      conditionalRef (WitFlexVec (WitBoolean), isCoproduced,  preprocAcc ())
      conditionalRef (WitTVec (WitTypelessPtr),
                                               expBopEntryTl, preprocAcc ())
      conditionalRef (WitFlexVec (float),      scrapVol,       optImpAcc () ||
d122 7
a128 7
      conditionalRef (WitBoolean,              expPerGaps,    preprocAcc ())
      conditionalRef (WitFlexVec (float),      consVol,      postprocAcc ())
      conditionalRef (WitFlexVec (float),      prodVol,      postprocAcc ())
      conditionalRef (WitFlexVec (float),      focShortageVol,    fssAcc ())
      conditionalRef (WitFlexVec (float),      reqVol,            mrpAcc ())
      conditionalRef (WitFlexVec (float),      mrpConsVol,        mrpAcc ())
      conditionalRef (WitFlexVec (float),      mrpResidualVol,    mrpAcc ())
d219 1
a219 1
         return expBopEntryTl_.isAllocated () && expBopEntryTl_[thePer] != NULL;
d280 1
a280 3
      copyCtorAndAssignment (WitPart);
         //
         // Prevents unintentional copying and assignment.
d353 1
a353 1
      WitTVec (WitTypelessPtr) expBopEntryTl_;
d355 4
a358 3
         // (BopEntry *) expBopEntryTl_[t] is the preferred BopEntry to be used
         // for explosions in order to produce this Part in period t.
         // expBopEntryTl_[t] != NULL iff this Part can be exploded in period t.
@


1.1
log
@Replaced WitPart.[Ch] with Part.[Ch].
@
text
@d64 16
a79 16
      accessFunc (const WitList (WitDemand) &,    myDemands)
      accessFunc (const WitList (WitBomEntry) &,  consumingBomEntries)
      accessFunc (const WitList (WitSubEntry) &,  consumingSubEntries)
      accessFunc (const WitList (WitBopEntry) &,  producingBopEntries)
      accessFunc (const WitFlexVec (float) &,     supplyVol)
      accessFunc (float,                          unitCost)
      accessFunc (const WitFlexVec (float) &,     obj1ScrapCost)
      accessFunc (const WitDenseList (WitPart) &, belowList)
      accessFunc (WitBoolean,                     isCoproduced)
      accessFunc (const WitFlexVec (float) &,     consVol)
      accessFunc (const WitFlexVec (float) &,     prodVol)
      accessFunc (const WitFlexVec (float) &,     scrapVol)
      accessFunc (const WitFlexVec (float) &,     mrpConsVol)
      accessFunc (const WitFlexVec (float) &,     mrpResidualVol)
      accessFunc (const WitFlexVec (float) &,     reqVol)
      accessFunc (const WitFlexVec (float) &,     focShortageVol)
d115 4
a118 4
      conditionalRef (WitList (WitBopEntry),  producingBopEntries,
                                                             preprocAcc ())
      conditionalRef (WitDenseList (WitPart), belowList,     preprocAcc ())
      conditionalRef (WitBoolean,             isCoproduced,  preprocAcc ())
d120 10
a129 10
                                              expBopEntryTl, preprocAcc ())
      conditionalRef (WitFlexVec (float),     scrapVol,       optImpAcc () ||
                                                            postprocAcc ())
      conditionalRef (WitBoolean,             expPerGaps,    preprocAcc ())
      conditionalRef (WitFlexVec (float),     consVol,      postprocAcc ())
      conditionalRef (WitFlexVec (float),     prodVol,      postprocAcc ())
      conditionalRef (WitFlexVec (float),     focShortageVol,    fssAcc ())
      conditionalRef (WitFlexVec (float),     reqVol,            mrpAcc ())
      conditionalRef (WitFlexVec (float),     mrpConsVol,        mrpAcc ())
      conditionalRef (WitFlexVec (float),     mrpResidualVol,    mrpAcc ())
d378 1
a378 1
      WitBoolean isCoproduced_;
d380 2
a381 1
         // TRUE, iff this Part is coproduced.
d383 2
a384 2
         //    It is a BopEntry  for the Operation with a positive  prodRate, or
         //    It is a ConsEntry for the Operation with a negative usageRate.
@


head	1.42;
access;
symbols
	sce_5_01_20080919:1.28
	latest_sce_4_20_20060523:1.10.0.2
	sce_4_20_20060523:1.10
	latest_sce4_20_OSL:1.9.0.2
	sce_4_20_OSL:1.9;
locks; strict;
comment	@ * @;


1.42
date	2011.09.28.23.50.06;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.24.00.28.30;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.08.30.20.18.06;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2010.10.19.20.13.47;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.10.22.10.41;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.01.16.28.24;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.16.22.42.28;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.31.20.45.10;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.21.20.35.47;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.19.20.46.06;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.17.23.45.48;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.17.22.54.49;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.07.22.08.38;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.07.22.05.35;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.01.22.41.58;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.30.22.05.51;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.21.15.20.10;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.14.20.25.17;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.14.19.48.41;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.09.22.44.27;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.08.23.21.20;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.04.18.43.47;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.30.21.52.09;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.23.21.03.20;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.20.21.57.33;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.20.20.51.14;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.20.19.44.49;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.05.20.54.53;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.19.17.50.55;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.18.22.29.02;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.02.15.57.06;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.27.23.02.47;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.02.17.34.11;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.21.20.47.35;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.20.21.54.31;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.04.19.30.22;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.10.15.30.28;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.21.14.53.00;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.20.21.47.58;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.20.21.15.11;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.08.21.16.37;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.08.19.29.45;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "SaeMgr.C"
//
// Contains the implementation of class SaeMgr.
//------------------------------------------------------------------------------

#include <SaeMgr.h>
#include <ParamMgr.h>
#include <Timing.h>
#include <DetOptImpMgr.h>
#include <StochImpMgr.h>
#include <PipMgr.h>
#include <Variant.h>
#include <OptStarter.h>
#include <FSS.h>
#include <DataWrit.h>
#include <Pre.h>
#include <Post.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Material.h>
#include <Demand.h>
#include <Operation.h>
#include <SubEntry.h>
#include <IVRealArg.h>
#include <WitRun.h>
#include <ApiMgr.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class WitSaeMgr.
//------------------------------------------------------------------------------

bool WitSaeMgr::standAloneMode_ = false;

//------------------------------------------------------------------------------

inline const WitString & WitSaeMgr::stringParamVal (const char * paramName)
   {
   return myParamMgr_->stringParamVal (paramName);
   }

//------------------------------------------------------------------------------

inline const char * WitSaeMgr::cStringParamVal (const char * paramName)
   {
   return stringParamVal (paramName).myCstring ();
   }

//------------------------------------------------------------------------------

inline int WitSaeMgr::intParamVal (const char * paramName)
   {
   return myParamMgr_->intParamVal (paramName);
   }

//------------------------------------------------------------------------------

inline const WitString & WitSaeMgr::choiceParamVal (const char * paramName)
   {
   return myParamMgr_->choiceParamVal (paramName);
   }

//------------------------------------------------------------------------------

inline bool WitSaeMgr::boolParamVal (const char * paramName)
   {
   return myParamMgr_->boolParamVal (paramName);
   }

//------------------------------------------------------------------------------

void WitSaeMgr::execute (WitRun * theWitRun, int argc, char * argv[])
   {
   stronglyAssert (not standAloneMode_);

   standAloneMode_ = true;

   WitSaeMgr theSaeMgr (theWitRun, argc, argv);

   theSaeMgr.execute ();

   stronglyAssert (standAloneMode_);

   standAloneMode_ = false;
   }

//------------------------------------------------------------------------------

WitSaeMgr::WitSaeMgr (WitRun * theWitRun, int argc, char * argv[]):

      myWitRun_   (theWitRun),
      mySession_  (theWitRun->mySession ()),
      myMsgFac_   (theWitRun->mySession ()->myMsgFac ()),
      myTimer_    (NULL),
      myParamMgr_ (NULL),
      myProblem_  (NULL)
   {
   myTimer_    = new WitTimer (myMsgFac_);

   myParamMgr_ = new WitParamMgr (myWitRun_, argc, argv);
   }

//------------------------------------------------------------------------------

WitSaeMgr::~WitSaeMgr ()
   {
   delete myParamMgr_;
   delete myTimer_;
   }

//------------------------------------------------------------------------------

void WitSaeMgr::execute ()
   {
   setUp ();

   if (WitMsgFacility::stopRunningWasSet ())
      myMsgFac_ ("standAloneAfterStopSmsg");

   WitTimer::enterSection ("other");

   readInput ();

   preprocess ();

   performAction ();

   if (choiceParamVal ("action") == "mrp")
      printMrp ();
   else
      printImplosion ();

   WitTimer::enterSection ("freeMemory");

   myProblem_ = NULL;

   mySession_->deactivate ();

   WitTimer::leaveSection ("freeMemory");

   WitTimer::leaveSection ("other");

   myTimer_->display ();

   myMsgFac_ ("normalTermMsg");
   }

//------------------------------------------------------------------------------

void WitSaeMgr::setUp ()
   {
   setUpMsg ();

   mySession_->activate ();

   myProblem_ = mySession_->myProblem ();
   }

//------------------------------------------------------------------------------

void WitSaeMgr::setUpMsg ()
   {
   myMsgFac_.setAccessMode ("w+");
      //
      // Overwrite existing files

   myMsgFac_.setDisplayExternalNumberByLevel (WitINFORMATIONAL_MESSAGES, false);

   myMsgFac_.setMaxTimesIssued ("witFuncCalled",     0);
   myMsgFac_.setMaxTimesIssued ("setStringAttrMsg",  0);
   myMsgFac_.setMaxTimesIssued ("witFileParam",      0);
   myMsgFac_.setMaxTimesIssued ("setIntAttrMsg",     0);
   myMsgFac_.setMaxTimesIssued ("setDblAttrMsg",     0);
   myMsgFac_.setMaxTimesIssued ("getAttrMsg",        0);
   myMsgFac_.setMaxTimesIssued ("setBooleanAttrMsg", 0);
   myMsgFac_.setMaxTimesIssued ("fileFormatMsg",     0);
   }

//------------------------------------------------------------------------------

void WitSaeMgr::readInput ()
   {
   WitOptStarter * theOptStarter;

   myParamMgr_->procParams ();

   myMsgFac_ ("readDataMsg");

   myWitRun_->witReadData (cStringParamVal ("data_ifname"));

   if (myProblem ()->myGlobalComp ()->inputPauses ())
      myProblem ()->pauseForInput ("just after reading the data");

   if (stringParamVal ("data_ifname2") != "")
      {
      myMsgFac_ ("genericMsg", "Reading the second input data file.");

      myWitRun_->witReadData (cStringParamVal ("data_ifname2"));
      }

   if (boolParamVal ("makeVolServ"))
      makeVolServObj ();

   if (boolParamVal ("print_echo"))
      {
      myMsgFac_ ("writeEchoMsg");

      myWitRun_->witDisplayData (cStringParamVal ("echo_ofname"));
      }

   if (myProblem ()->myStochImpMgr ()->stochMode ())
      if (     (choiceParamVal ("action") == "heur")
            or (choiceParamVal ("action") == "opt")
            or (choiceParamVal ("action") == "eval"))
         {
         myMsgFac_ ("actionInStochModeSmsg", choiceParamVal ("action"));
         }

   if (choiceParamVal ("optInitMethod") != "none")
      {
      theOptStarter =
         myProblem ()->
            myOptComp ()->
               allOptStarters ().
                  find (
                   & WitOptStarter::paramValue,
                     choiceParamVal ("optInitMethod").myCstring ());

      theOptStarter->beChosen ();
      }
   }

//------------------------------------------------------------------------------

void WitSaeMgr::preprocess ()
   {
   myWitRun_->witPreprocess ();

   if (   (choiceParamVal ("action") == "preproc")
       or (choiceParamVal ("action") == "opt")
       or (choiceParamVal ("action") == "stoch")
       or (choiceParamVal ("action") == "eval"))

      myProblem ()->myPreprocessor ()->preprocess ();

   if (boolParamVal ("writeData"))
      {
      myMsgFac_ ("genericMsg", "Writing the input data file.");

      myWitRun_->witWriteData (cStringParamVal ("data_ofname"));
      }

   if (boolParamVal ("print_pre"))
      {
      if (myProblem ()->myCompMgr ()->myGlobalComp ()->autoPriority ())
         WitDemand::genPriorities (myProblem ());

      myMsgFac_ ("writePreprocMsg");

      myWitRun_->witDisplayData (cStringParamVal ("pre_ofname"));
      }

   if (boolParamVal ("print_global"))
      {
      myMsgFac_ ("writeGlobalMsg");

      myProblem ()->displayGlobalData ();
      }
   }

//------------------------------------------------------------------------------

void WitSaeMgr::performAction ()
   {
   const WitString & actionString = choiceParamVal ("action");

   if      (actionString == "preproc")
      {
      if (boolParamVal ("print_soln"))
         myProblem ()->myPostprocessor ()->postprocess ();
      }

   else if (actionString == "mrp")
      myWitRun_->witMrp ();

   else if (actionString == "heur")
      myWitRun_->witHeurImplode ();

   else if (actionString == "opt")
      myProblem ()->myDetOptImpMgr ()->implode ();

   else if (actionString == "stoch")
      {
      if (not myProblem ()->myStochImpMgr ()->stochMode ())
         myMsgFac_ ("stochImpWoStochModeSmsg");

      myProblem ()->myStochImpMgr ()->implode ();
      }

   else if (actionString == "eval")
      {
      myProblem ()->myDetOptImpMgr ()->evalObjectives ();

      myProblem ()->myOptComp ()->writeObjValue ();
      }

   if (boolParamVal ("invokePip"))
      {
      if (boolParamVal ("print_echo"))
         myWitRun_->witDisplayData ("pipd.out");

      if (myProblem ()->myGlobalComp ()->inputPauses ())
         myProblem ()->pauseForInput ("just before building PIP");

      myProblem ()->myPipMgr ()->buildPegging ();

      if (myProblem ()->myGlobalComp ()->inputPauses ())
         myProblem ()->pauseForInput ("just after building PIP");
      }
   }

//------------------------------------------------------------------------------

void WitSaeMgr::printMrp ()
   {
   myMsgFac_ ("writeReqSchedMsg");

   myWitRun_->witWriteReqSched (cStringParamVal ("mrpsup_ofname"), WitBSV);

   if (boolParamVal ("print_soln"))
      {
      myMsgFac_ ("writeMrpSolnMsg");

      myProblem ()->writeMrpSoln (cStringParamVal ("soln_ofname"));
      }
   }

//------------------------------------------------------------------------------

void WitSaeMgr::printImplosion ()
   {
   if (boolParamVal ("compVolServ"))
      compVolServ ();

   if (boolParamVal ("print_exec"))
      {
      myMsgFac_ ("writeExecSchedMsg");

      myWitRun_->witWriteExecSched (cStringParamVal ("exec_ofname"), WitBSV);
      }

   if (boolParamVal ("print_ship"))
      {
      myMsgFac_ ("writeShipSchedMsg");

      myWitRun_->witWriteShipSched (cStringParamVal ("ship_ofname"), WitBSV);
      }

   if (boolParamVal ("print_soln"))
      {
      if (myProblem ()->currentVariant ()->internalSoln ())
         if (not myProblem ()->myStochImpMgr ()->stochMode ())
            doFss ();

      myMsgFac_ ("writeSolnMsg");

      myProblem ()->writeSoln (cStringParamVal ("soln_ofname"));
      }

   if (intParamVal ("n_critical") != 0)
      {
      myMsgFac_ ("writeCriticalListMsg");

      myWitRun_->
         witWriteCriticalList (
            cStringParamVal ("critical_ofname"),
            WitBSV,
            intParamVal ("n_critical"));
      }

   if (boolParamVal ("writeSolnData"))
      {
      myMsgFac_ ("genericMsg", "Writing the solution data file.");

      myProblem ()->
         myDataWriter ()->
            writeSolnData (cStringParamVal ("sdata_ofname"));
      }
   }

//------------------------------------------------------------------------------

void WitSaeMgr::doFss ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      theDemand->setFocusHorizon (myProblem ()->lastPeriod ());

   myProblem ()->myFSS ()->compute ();
   }

//------------------------------------------------------------------------------

void WitSaeMgr::makeVolServObj ()
   {
   WitDemand *      theDemand;
   WitPeriod        thePer;
   double           totCumDemandVol;
   WitTVec <double> theCumShipReward (myProblem (), 0.0);

   clearObj ();

   totCumDemandVol = 0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         totCumDemandVol += theDemand->cumDemandVol ()[thePer];

   stronglyAssert (totCumDemandVol >= .001);

   theCumShipReward = (100.0 / totCumDemandVol);

   forEachDemand (theDemand, myProblem ())
      theDemand->setCumShipReward (theCumShipReward.myCVec ());
   }

//------------------------------------------------------------------------------

void WitSaeMgr::clearObj ()
   {
   WitPart *        thePart;
   WitMaterial *    theMat;
   WitOperation *   theOpn;
   WitSubEntry *    theSub;
   WitDemand *      theDemand;
   WitTVec <double> the0Vector (myProblem (),  0.0);

   forEachPart (thePart, myProblem ())
      thePart->setScrapCost (the0Vector.myCVec ());

   forEachMaterial (theMat, myProblem ())
      theMat->setStockCost (the0Vector.myCVec ());

   forEachOperation (theOpn, myProblem ())
      theOpn->setExecCost (the0Vector.myCVec ());

   forEachSubEntry (theSub, myProblem ())
      theSub->setSubCost (the0Vector.myCVec ());

   forEachDemand (theDemand, myProblem ())
      theDemand->setShipReward (the0Vector.myCVec ());

   forEachDemand (theDemand, myProblem ())
      theDemand->setCumShipReward (the0Vector.myCVec ());
   }

//------------------------------------------------------------------------------

void WitSaeMgr::compVolServ ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      totCumDemandVol;
   double      totCumShipVol;

   totCumDemandVol = 0;
   totCumShipVol   = 0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         totCumDemandVol += theDemand->cumDemandVol ()[thePer];
         totCumShipVol   += theDemand->cumShipVol   ()[thePer];
         }

   if (totCumDemandVol < .001)
      fprintf (myMsgFac_.myFile (),
         "\n"
         "Volume Serviceability: undefined.\n\n");
   else
      fprintf (myMsgFac_.myFile (),
         "\n"
         "Volume Serviceability: %9.6f%%\n\n",
         100.0 * (totCumShipVol / totCumDemandVol));
   }

//------------------------------------------------------------------------------

bool WitSaeMgr::tempParIsSet (int index)
   {
   return myProblem ()->myGlobalComp ()->tempParIsSet (index);
   }
@


1.41
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.40
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d48 3
a50 3
{
return myParamMgr_->stringParamVal (paramName);
}
d55 3
a57 3
{
return stringParamVal (paramName).myCstring ();
}
d62 3
a64 3
{
return myParamMgr_->intParamVal (paramName);
}
d69 3
a71 3
{
return myParamMgr_->choiceParamVal (paramName);
}
d76 3
a78 3
{
return myParamMgr_->boolParamVal (paramName);
}
d83 2
a84 2
{
stronglyAssert (not standAloneMode_);
d86 1
a86 1
standAloneMode_ = true;
d88 1
a88 1
WitSaeMgr theSaeMgr (theWitRun, argc, argv);
d90 1
a90 1
theSaeMgr.execute ();
d92 1
a92 1
stronglyAssert (standAloneMode_);
d94 2
a95 2
standAloneMode_ = false;
}
d101 8
a108 8
myWitRun_   (theWitRun),
mySession_  (theWitRun->mySession ()),
myMsgFac_   (theWitRun->mySession ()->myMsgFac ()),
myTimer_    (NULL),
myParamMgr_ (NULL),
myProblem_  (NULL)
{
myTimer_    = new WitTimer (myMsgFac_);
d110 2
a111 2
myParamMgr_ = new WitParamMgr (myWitRun_, argc, argv);
}
d116 4
a119 4
{
delete myParamMgr_;
delete myTimer_;
}
d124 2
a125 2
{
setUp ();
d127 2
a128 2
if (WitMsgFacility::stopRunningWasSet ())
myMsgFac_ ("standAloneAfterStopSmsg");
d130 1
a130 1
WitTimer::enterSection ("other");
d132 1
a132 1
readInput ();
d134 1
a134 1
preprocess ();
d136 1
a136 1
performAction ();
d138 4
a141 4
if (choiceParamVal ("action") == "mrp")
printMrp ();
else
printImplosion ();
d143 1
a143 1
WitTimer::enterSection ("freeMemory");
d145 1
a145 1
myProblem_ = NULL;
d147 1
a147 1
mySession_->deactivate ();
d149 1
a149 1
WitTimer::leaveSection ("freeMemory");
d151 1
a151 1
WitTimer::leaveSection ("other");
d153 1
a153 1
myTimer_->display ();
d155 2
a156 2
myMsgFac_ ("normalTermMsg");
}
d161 2
a162 2
{
setUpMsg ();
d164 1
a164 1
mySession_->activate ();
d166 2
a167 2
myProblem_ = mySession_->myProblem ();
}
d172 16
a187 16
{
myMsgFac_.setAccessMode ("w+");
//
// Overwrite existing files

myMsgFac_.setDisplayExternalNumberByLevel (WitINFORMATIONAL_MESSAGES, false);

myMsgFac_.setMaxTimesIssued ("witFuncCalled",     0);
myMsgFac_.setMaxTimesIssued ("setStringAttrMsg",  0);
myMsgFac_.setMaxTimesIssued ("witFileParam",      0);
myMsgFac_.setMaxTimesIssued ("setIntAttrMsg",     0);
myMsgFac_.setMaxTimesIssued ("setDblAttrMsg",     0);
myMsgFac_.setMaxTimesIssued ("getAttrMsg",        0);
myMsgFac_.setMaxTimesIssued ("setBooleanAttrMsg", 0);
myMsgFac_.setMaxTimesIssued ("fileFormatMsg",     0);
}
d192 2
a193 2
{
WitOptStarter * theOptStarter;
d195 1
a195 1
myParamMgr_->procParams ();
d197 1
a197 1
myMsgFac_ ("readDataMsg");
d199 1
a199 1
myWitRun_->witReadData (cStringParamVal ("data_ifname"));
d201 41
a241 41
if (myProblem ()->myGlobalComp ()->inputPauses ())
myProblem ()->pauseForInput ("just after reading the data");

if (stringParamVal ("data_ifname2") != "")
{
myMsgFac_ ("genericMsg", "Reading the second input data file.");

myWitRun_->witReadData (cStringParamVal ("data_ifname2"));
}

if (boolParamVal ("makeVolServ"))
makeVolServObj ();

if (boolParamVal ("print_echo"))
{
myMsgFac_ ("writeEchoMsg");

myWitRun_->witDisplayData (cStringParamVal ("echo_ofname"));
}

if (myProblem ()->myStochImpMgr ()->stochMode ())
if (     (choiceParamVal ("action") == "heur")
or (choiceParamVal ("action") == "opt")
or (choiceParamVal ("action") == "eval"))
{
myMsgFac_ ("actionInStochModeSmsg", choiceParamVal ("action"));
}

if (choiceParamVal ("optInitMethod") != "none")
{
theOptStarter =
myProblem ()->
myOptComp ()->
allOptStarters ().
find (
& WitOptStarter::paramValue,
choiceParamVal ("optInitMethod").myCstring ());

theOptStarter->beChosen ();
}
}
d246 2
a247 2
{
myWitRun_->witPreprocess ();
d249 4
a252 4
if (   (choiceParamVal ("action") == "preproc")
or (choiceParamVal ("action") == "opt")
or (choiceParamVal ("action") == "stoch")
or (choiceParamVal ("action") == "eval"))
d254 1
a254 1
myProblem ()->myPreprocessor ()->preprocess ();
d256 3
a258 3
if (boolParamVal ("writeData"))
{
myMsgFac_ ("genericMsg", "Writing the input data file.");
d260 2
a261 2
myWitRun_->witWriteData (cStringParamVal ("data_ofname"));
}
d263 4
a266 4
if (boolParamVal ("print_pre"))
{
if (myProblem ()->myCompMgr ()->myGlobalComp ()->autoPriority ())
WitDemand::genPriorities (myProblem ());
d268 1
a268 1
myMsgFac_ ("writePreprocMsg");
d270 2
a271 2
myWitRun_->witDisplayData (cStringParamVal ("pre_ofname"));
}
d273 3
a275 3
if (boolParamVal ("print_global"))
{
myMsgFac_ ("writeGlobalMsg");
d277 3
a279 3
myProblem ()->displayGlobalData ();
}
}
d284 2
a285 2
{
const WitString & actionString = choiceParamVal ("action");
d287 5
a291 5
if      (actionString == "preproc")
{
if (boolParamVal ("print_soln"))
myProblem ()->myPostprocessor ()->postprocess ();
}
d293 2
a294 2
else if (actionString == "mrp")
myWitRun_->witMrp ();
d296 2
a297 2
else if (actionString == "heur")
myWitRun_->witHeurImplode ();
d299 2
a300 2
else if (actionString == "opt")
myProblem ()->myDetOptImpMgr ()->implode ();
d302 4
a305 4
else if (actionString == "stoch")
{
if (not myProblem ()->myStochImpMgr ()->stochMode ())
myMsgFac_ ("stochImpWoStochModeSmsg");
d307 2
a308 2
myProblem ()->myStochImpMgr ()->implode ();
}
d310 3
a312 3
else if (actionString == "eval")
{
myProblem ()->myDetOptImpMgr ()->evalObjectives ();
d314 2
a315 2
myProblem ()->myOptComp ()->writeObjValue ();
}
d317 4
a320 4
if (boolParamVal ("invokePip"))
{
if (boolParamVal ("print_echo"))
myWitRun_->witDisplayData ("pipd.out");
d322 2
a323 2
if (myProblem ()->myGlobalComp ()->inputPauses ())
myProblem ()->pauseForInput ("just before building PIP");
d325 1
a325 1
myProblem ()->myPipMgr ()->buildPegging ();
d327 4
a330 4
if (myProblem ()->myGlobalComp ()->inputPauses ())
myProblem ()->pauseForInput ("just after building PIP");
}
}
d335 2
a336 2
{
myMsgFac_ ("writeReqSchedMsg");
d338 1
a338 1
myWitRun_->witWriteReqSched (cStringParamVal ("mrpsup_ofname"), WitBSV);
d340 7
a346 7
if (boolParamVal ("print_soln"))
{
myMsgFac_ ("writeMrpSolnMsg");

myProblem ()->writeMrpSoln (cStringParamVal ("soln_ofname"));
}
}
d351 49
a399 49
{
if (boolParamVal ("compVolServ"))
compVolServ ();

if (boolParamVal ("print_exec"))
{
myMsgFac_ ("writeExecSchedMsg");

myWitRun_->witWriteExecSched (cStringParamVal ("exec_ofname"), WitBSV);
}

if (boolParamVal ("print_ship"))
{
myMsgFac_ ("writeShipSchedMsg");

myWitRun_->witWriteShipSched (cStringParamVal ("ship_ofname"), WitBSV);
}

if (boolParamVal ("print_soln"))
{
if (myProblem ()->currentVariant ()->internalSoln ())
if (not myProblem ()->myStochImpMgr ()->stochMode ())
doFss ();

myMsgFac_ ("writeSolnMsg");

myProblem ()->writeSoln (cStringParamVal ("soln_ofname"));
}

if (intParamVal ("n_critical") != 0)
{
myMsgFac_ ("writeCriticalListMsg");

myWitRun_->
witWriteCriticalList (
cStringParamVal ("critical_ofname"),
WitBSV,
intParamVal ("n_critical"));
}

if (boolParamVal ("writeSolnData"))
{
myMsgFac_ ("genericMsg", "Writing the solution data file.");

myProblem ()->
myDataWriter ()->
writeSolnData (cStringParamVal ("sdata_ofname"));
}
}
d404 2
a405 2
{
WitDemand * theDemand;
d407 2
a408 2
forEachDemand (theDemand, myProblem ())
theDemand->setFocusHorizon (myProblem ()->lastPeriod ());
d410 2
a411 2
myProblem ()->myFSS ()->compute ();
}
d416 5
a420 5
{
WitDemand *      theDemand;
WitPeriod        thePer;
double           totCumDemandVol;
WitTVec <double> theCumShipReward (myProblem (), 0.0);
d422 1
a422 1
clearObj ();
d424 1
a424 1
totCumDemandVol = 0;
d426 3
a428 3
forEachDemand (theDemand, myProblem ())
forEachPeriod (thePer, myProblem ())
totCumDemandVol += theDemand->cumDemandVol ()[thePer];
d430 1
a430 1
stronglyAssert (totCumDemandVol >= .001);
d432 1
a432 1
theCumShipReward = (100.0 / totCumDemandVol);
d434 3
a436 3
forEachDemand (theDemand, myProblem ())
theDemand->setCumShipReward (theCumShipReward.myCVec ());
}
d441 26
a466 26
{
WitPart *        thePart;
WitMaterial *    theMat;
WitOperation *   theOpn;
WitSubEntry *    theSub;
WitDemand *      theDemand;
WitTVec <double> the0Vector (myProblem (),  0.0);

forEachPart (thePart, myProblem ())
thePart->setScrapCost (the0Vector.myCVec ());

forEachMaterial (theMat, myProblem ())
theMat->setStockCost (the0Vector.myCVec ());

forEachOperation (theOpn, myProblem ())
theOpn->setExecCost (the0Vector.myCVec ());

forEachSubEntry (theSub, myProblem ())
theSub->setSubCost (the0Vector.myCVec ());

forEachDemand (theDemand, myProblem ())
theDemand->setShipReward (the0Vector.myCVec ());

forEachDemand (theDemand, myProblem ())
theDemand->setCumShipReward (the0Vector.myCVec ());
}
d471 26
a496 26
{
WitDemand * theDemand;
WitPeriod   thePer;
double      totCumDemandVol;
double      totCumShipVol;

totCumDemandVol = 0;
totCumShipVol   = 0;

forEachDemand (theDemand, myProblem ())
forEachPeriod (thePer, myProblem ())
{
totCumDemandVol += theDemand->cumDemandVol ()[thePer];
totCumShipVol   += theDemand->cumShipVol   ()[thePer];
}

if (totCumDemandVol < .001)
fprintf (myMsgFac_.myFile (),
"\n"
"Volume Serviceability: undefined.\n\n");
else
fprintf (myMsgFac_.myFile (),
"\n"
"Volume Serviceability: %9.6f%%\n\n",
100.0 * (totCumShipVol / totCumDemandVol));
}
d501 3
a503 3
{
return myProblem ()->myGlobalComp ()->tempParIsSet (index);
}
@


1.39
log
@CPLEX
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d48 3
a50 3
   {
   return myParamMgr_->stringParamVal (paramName);
   }
d55 3
a57 3
   {
   return stringParamVal (paramName).myCstring ();
   }
d62 3
a64 3
   {
   return myParamMgr_->intParamVal (paramName);
   }
d69 3
a71 3
   {
   return myParamMgr_->choiceParamVal (paramName);
   }
d76 3
a78 3
   {
   return myParamMgr_->boolParamVal (paramName);
   }
d83 2
a84 2
   {
   stronglyAssert (not standAloneMode_);
d86 1
a86 1
   standAloneMode_ = true;
d88 1
a88 1
   WitSaeMgr theSaeMgr (theWitRun, argc, argv);
d90 1
a90 1
   theSaeMgr.execute ();
d92 1
a92 1
   stronglyAssert (standAloneMode_);
d94 2
a95 2
   standAloneMode_ = false;
   }
d101 8
a108 8
      myWitRun_   (theWitRun),
      mySession_  (theWitRun->mySession ()),
      myMsgFac_   (theWitRun->mySession ()->myMsgFac ()),
      myTimer_    (NULL),
      myParamMgr_ (NULL),
      myProblem_  (NULL)
   {
   myTimer_    = new WitTimer (myMsgFac_);
d110 2
a111 2
   myParamMgr_ = new WitParamMgr (myWitRun_, argc, argv);
   }
d116 4
a119 4
   {
   delete myParamMgr_;
   delete myTimer_;
   }
d124 2
a125 2
   {
   setUp ();
d127 2
a128 2
   if (WitMsgFacility::stopRunningWasSet ())
      myMsgFac_ ("standAloneAfterStopSmsg");
d130 1
a130 1
   WitTimer::enterSection ("other");
d132 1
a132 1
   readInput ();
d134 1
a134 1
   preprocess ();
d136 1
a136 1
   performAction ();
d138 4
a141 4
   if (choiceParamVal ("action") == "mrp")
      printMrp ();
   else
      printImplosion ();
d143 1
a143 1
   WitTimer::enterSection ("freeMemory");
d145 1
a145 1
   myProblem_ = NULL;
d147 1
a147 1
   mySession_->deactivate ();
d149 1
a149 1
   WitTimer::leaveSection ("freeMemory");
d151 1
a151 1
   WitTimer::leaveSection ("other");
d153 1
a153 1
   myTimer_->display ();
d155 2
a156 2
   myMsgFac_ ("normalTermMsg");
   }
d161 2
a162 2
   {
   setUpMsg ();
d164 1
a164 1
   mySession_->activate ();
d166 2
a167 2
   myProblem_ = mySession_->myProblem ();
   }
d172 16
a187 16
   {
   myMsgFac_.setAccessMode ("w+");
      //
      // Overwrite existing files

   myMsgFac_.setDisplayExternalNumberByLevel (WitINFORMATIONAL_MESSAGES, false);

   myMsgFac_.setMaxTimesIssued ("witFuncCalled",     0);
   myMsgFac_.setMaxTimesIssued ("setStringAttrMsg",  0);
   myMsgFac_.setMaxTimesIssued ("witFileParam",      0);
   myMsgFac_.setMaxTimesIssued ("setIntAttrMsg",     0);
   myMsgFac_.setMaxTimesIssued ("setDblAttrMsg",     0);
   myMsgFac_.setMaxTimesIssued ("getAttrMsg",        0);
   myMsgFac_.setMaxTimesIssued ("setBooleanAttrMsg", 0);
   myMsgFac_.setMaxTimesIssued ("fileFormatMsg",     0);
   }
d192 2
a193 2
   {
   WitOptStarter * theOptStarter;
d195 1
a195 1
   myParamMgr_->procParams ();
d197 1
a197 1
   myMsgFac_ ("readDataMsg");
d199 1
a199 1
   myWitRun_->witReadData (cStringParamVal ("data_ifname"));
d201 41
a241 41
   if (myProblem ()->myGlobalComp ()->inputPauses ())
      myProblem ()->pauseForInput ("just after reading the data");

   if (stringParamVal ("data_ifname2") != "")
      {
      myMsgFac_ ("genericMsg", "Reading the second input data file.");

      myWitRun_->witReadData (cStringParamVal ("data_ifname2"));
      }

   if (boolParamVal ("makeVolServ"))
      makeVolServObj ();

   if (boolParamVal ("print_echo"))
      {
      myMsgFac_ ("writeEchoMsg");

      myWitRun_->witDisplayData (cStringParamVal ("echo_ofname"));
      }

   if (myProblem ()->myStochImpMgr ()->stochMode ())
      if (     (choiceParamVal ("action") == "heur")
            or (choiceParamVal ("action") == "opt")
            or (choiceParamVal ("action") == "eval"))
         {
         myMsgFac_ ("actionInStochModeSmsg", choiceParamVal ("action"));
         }

   if (choiceParamVal ("optInitMethod") != "none")
      {
      theOptStarter =
         myProblem ()->
            myOptComp ()->
               allOptStarters ().
                  find (
                   & WitOptStarter::paramValue,
                     choiceParamVal ("optInitMethod").myCstring ());

      theOptStarter->beChosen ();
      }
   }
d246 2
a247 2
   {
   myWitRun_->witPreprocess ();
d249 4
a252 4
   if (   (choiceParamVal ("action") == "preproc")
       or (choiceParamVal ("action") == "opt")
       or (choiceParamVal ("action") == "stoch")
       or (choiceParamVal ("action") == "eval"))
d254 1
a254 1
      myProblem ()->myPreprocessor ()->preprocess ();
d256 3
a258 3
   if (boolParamVal ("writeData"))
      {
      myMsgFac_ ("genericMsg", "Writing the input data file.");
d260 2
a261 2
      myWitRun_->witWriteData (cStringParamVal ("data_ofname"));
      }
d263 4
a266 4
   if (boolParamVal ("print_pre"))
      {
      if (myProblem ()->myCompMgr ()->myGlobalComp ()->autoPriority ())
         WitDemand::genPriorities (myProblem ());
d268 1
a268 1
      myMsgFac_ ("writePreprocMsg");
d270 2
a271 2
      myWitRun_->witDisplayData (cStringParamVal ("pre_ofname"));
      }
d273 3
a275 3
   if (boolParamVal ("print_global"))
      {
      myMsgFac_ ("writeGlobalMsg");
d277 3
a279 3
      myProblem ()->displayGlobalData ();
      }
   }
d284 2
a285 2
   {
   const WitString & actionString = choiceParamVal ("action");
d287 5
a291 5
   if      (actionString == "preproc")
      {
      if (boolParamVal ("print_soln"))
         myProblem ()->myPostprocessor ()->postprocess ();
      }
d293 2
a294 2
   else if (actionString == "mrp")
      myWitRun_->witMrp ();
d296 2
a297 2
   else if (actionString == "heur")
      myWitRun_->witHeurImplode ();
d299 2
a300 2
   else if (actionString == "opt")
      myProblem ()->myDetOptImpMgr ()->implode ();
d302 4
a305 4
   else if (actionString == "stoch")
      {
      if (not myProblem ()->myStochImpMgr ()->stochMode ())
         myMsgFac_ ("stochImpWoStochModeSmsg");
d307 2
a308 2
      myProblem ()->myStochImpMgr ()->implode ();
      }
d310 3
a312 3
   else if (actionString == "eval")
      {
      myProblem ()->myDetOptImpMgr ()->evalObjectives ();
d314 2
a315 2
      myProblem ()->myOptComp ()->writeObjValue ();
      }
d317 4
a320 4
   if (boolParamVal ("invokePip"))
      {
      if (boolParamVal ("print_echo"))
         myWitRun_->witDisplayData ("pipd.out");
d322 2
a323 2
      if (myProblem ()->myGlobalComp ()->inputPauses ())
         myProblem ()->pauseForInput ("just before building PIP");
d325 1
a325 1
      myProblem ()->myPipMgr ()->buildPegging ();
d327 4
a330 4
      if (myProblem ()->myGlobalComp ()->inputPauses ())
         myProblem ()->pauseForInput ("just after building PIP");
      }
   }
d335 2
a336 2
   {
   myMsgFac_ ("writeReqSchedMsg");
d338 1
a338 1
   myWitRun_->witWriteReqSched (cStringParamVal ("mrpsup_ofname"), WitBSV);
d340 7
a346 7
   if (boolParamVal ("print_soln"))
      {
      myMsgFac_ ("writeMrpSolnMsg");

      myProblem ()->writeMrpSoln (cStringParamVal ("soln_ofname"));
      }
   }
d351 49
a399 49
   {
   if (boolParamVal ("compVolServ"))
      compVolServ ();

   if (boolParamVal ("print_exec"))
      {
      myMsgFac_ ("writeExecSchedMsg");

      myWitRun_->witWriteExecSched (cStringParamVal ("exec_ofname"), WitBSV);
      }

   if (boolParamVal ("print_ship"))
      {
      myMsgFac_ ("writeShipSchedMsg");

      myWitRun_->witWriteShipSched (cStringParamVal ("ship_ofname"), WitBSV);
      }

   if (boolParamVal ("print_soln"))
      {
      if (myProblem ()->currentVariant ()->internalSoln ())
         if (not myProblem ()->myStochImpMgr ()->stochMode ())
            doFss ();

      myMsgFac_ ("writeSolnMsg");

      myProblem ()->writeSoln (cStringParamVal ("soln_ofname"));
      }

   if (intParamVal ("n_critical") != 0)
      {
      myMsgFac_ ("writeCriticalListMsg");

      myWitRun_->
         witWriteCriticalList (
            cStringParamVal ("critical_ofname"),
            WitBSV,
            intParamVal ("n_critical"));
      }

   if (boolParamVal ("writeSolnData"))
      {
      myMsgFac_ ("genericMsg", "Writing the solution data file.");

      myProblem ()->
         myDataWriter ()->
            writeSolnData (cStringParamVal ("sdata_ofname"));
      }
   }
d404 2
a405 2
   {
   WitDemand * theDemand;
d407 2
a408 2
   forEachDemand (theDemand, myProblem ())
      theDemand->setFocusHorizon (myProblem ()->lastPeriod ());
d410 2
a411 2
   myProblem ()->myFSS ()->compute ();
   }
d416 5
a420 5
   {
   WitDemand *      theDemand;
   WitPeriod        thePer;
   double           totCumDemandVol;
   WitTVec <double> theCumShipReward (myProblem (), 0.0);
d422 1
a422 1
   clearObj ();
d424 1
a424 1
   totCumDemandVol = 0;
d426 3
a428 3
   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         totCumDemandVol += theDemand->cumDemandVol ()[thePer];
d430 1
a430 1
   stronglyAssert (totCumDemandVol >= .001);
d432 1
a432 1
   theCumShipReward = (100.0 / totCumDemandVol);
d434 3
a436 3
   forEachDemand (theDemand, myProblem ())
      theDemand->setCumShipReward (theCumShipReward.myCVec ());
   }
d441 26
a466 26
   {
   WitPart *        thePart;
   WitMaterial *    theMat;
   WitOperation *   theOpn;
   WitSubEntry *    theSub;
   WitDemand *      theDemand;
   WitTVec <double> the0Vector (myProblem (),  0.0);

   forEachPart (thePart, myProblem ())
      thePart->setScrapCost (the0Vector.myCVec ());

   forEachMaterial (theMat, myProblem ())
      theMat->setStockCost (the0Vector.myCVec ());

   forEachOperation (theOpn, myProblem ())
      theOpn->setExecCost (the0Vector.myCVec ());

   forEachSubEntry (theSub, myProblem ())
      theSub->setSubCost (the0Vector.myCVec ());

   forEachDemand (theDemand, myProblem ())
      theDemand->setShipReward (the0Vector.myCVec ());

   forEachDemand (theDemand, myProblem ())
      theDemand->setCumShipReward (the0Vector.myCVec ());
   }
d471 26
a496 26
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      totCumDemandVol;
   double      totCumShipVol;

   totCumDemandVol = 0;
   totCumShipVol   = 0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         totCumDemandVol += theDemand->cumDemandVol ()[thePer];
         totCumShipVol   += theDemand->cumShipVol   ()[thePer];
         }

   if (totCumDemandVol < .001)
      fprintf (myMsgFac_.myFile (),
         "\n"
         "Volume Serviceability: undefined.\n\n");
   else
      fprintf (myMsgFac_.myFile (),
         "\n"
         "Volume Serviceability: %9.6f%%\n\n",
         100.0 * (totCumShipVol / totCumDemandVol));
   }
d501 3
a503 3
   {
   return myProblem ()->myGlobalComp ()->tempParIsSet (index);
   }
@


1.38
log
@Heuristic Adjustment
@
text
@d23 1
d193 2
d228 13
@


1.37
log
@pause/resume
@
text
@d31 1
a31 1
#include <Opn.h>
@


1.36
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d198 1
a198 1
   if (myProblem ()->myGlobalComp ()->pauses ())
d306 1
a306 1
      if (myProblem ()->myGlobalComp ()->pauses ())
d311 1
a311 1
      if (myProblem ()->myGlobalComp ()->pauses ())
@


1.35
log
@Multi-objective mode
@
text
@d27 1
a27 1
#include <Global.h>
@


1.34
log
@Removed some references to objective #1.
@
text
@d298 1
a298 2
      myMsgFac_ ("objValueMsg",
         myProblem ()->myCompMgr ()->myOptComp ()->objValue ());
@


1.33
log
@Removing objective #2.
@
text
@d407 1
a407 1
   clearObj1 ();
d425 1
a425 1
void WitSaeMgr::clearObj1 ()
@


1.32
log
@Removing objective #2.
@
text
@d298 1
a298 1
      myMsgFac_ ("obj1ValueMsg",
@


1.31
log
@Removing objective #2.
@
text
@a433 3
   stronglyAssert (
      myProblem ()->myCompMgr ()->myOptComp ()->myObjFunc1 ()->isChosen ());

@


1.30
log
@Made WIT operate in multi-thread mode unconditionally.
The multithread attribute in no longer meaningful.
@
text
@d250 1
a250 1
         myProblem ()->genPriorities ();
d298 2
a299 1
      myProblem ()->myCompMgr ()->myOptComp ()->objChoice ()->writeValues ();
@


1.29
log
@Attempt to accommodate a warning about the return value from scanf.
@
text
@a82 2
   stronglyAssert (not WitApiMgr::multiThread ());

@


1.28
log
@Stochastic Implosion
@
text
@a147 9
   if (mySession_->myProblem ()->myGlobalComp ()->pauses ())
      {
      mySession_->activate ();

      mySession_->deactivate ();

      myProblem ()->pauseForInput ("just after freeing memory");
      }

@


1.27
log
@Stochastic Implosion
@
text
@d19 1
a19 1
#include <OptImp.h>
d295 1
a295 1
      myProblem ()->myOptImploder ()->implode ();
d307 1
a307 1
      myProblem ()->myOptImploder ()->evalObjectives ();
@


1.26
log
@Stochastic Implosion
@
text
@d249 1
a249 1
      myProblem ()->myPreprocessor ()->optPreprocess ();
@


1.25
log
@Stochastic Implosion.
@
text
@d229 1
a229 1
   if (myProblem ()->myStochImpMgr ()->stochDataMode ())
d299 1
a299 1
      if (not myProblem ()->myStochImpMgr ()->stochDataMode ())
d367 1
a367 1
         if (not myProblem ()->myStochImpMgr ()->stochDataMode ())
@


1.24
log
@Stochastic Implosion
@
text
@a301 4
      myProblem ()->
         myStochImpMgr ()->
            setSglStochLP (boolParamVal ("sglStochLP"));

@


1.23
log
@Stochastic Implosion
@
text
@d302 4
@


1.22
log
@Stochastic Implosion
@
text
@a22 1
#include <AttMgr.h>
a204 3
   if (boolParamVal ("printAttData"))
      myProblem ()->myAttMgr ()->print ();

@


1.21
log
@Stochastic Implosion
@
text
@d23 1
d206 3
@


1.20
log
@Stochastic Implosion
@
text
@d228 8
@


1.19
log
@Stochastic Implosion
@
text
@d20 1
a20 1
#include <StochMgr.h>
d291 1
a291 1
      if (not myProblem ()->myStochMgr ()->stochDataMode ())
d294 1
a294 1
      myProblem ()->myStochMgr ()->implode ();
d359 1
a359 1
         if (not myProblem ()->myStochMgr ()->stochDataMode ())
@


1.18
log
@Stochastic Implosion
@
text
@d291 1
a291 1
      if (not myProblem ()->myStochMgr ()->stochasticMode ())
d359 1
a359 1
         if (not myProblem ()->myStochMgr ()->stochasticMode ())
@


1.17
log
@Stochastic Implosion
@
text
@d359 2
a360 1
         doFss ();
@


1.16
log
@Stochastic Implosion
@
text
@d291 1
a291 1
      if (not myProblem ()->myStochMgr ()->stochImpMode ())
@


1.15
log
@App controlled opt implosion.
@
text
@d20 1
d238 1
d289 8
@


1.14
log
@App controlled opt implosion.
@
text
@d235 3
a237 5
   if (OPT_IMP_MODE)
      if (
               (choiceParamVal ("action") == "preproc")
            or (choiceParamVal ("action") == "opt")
            or (choiceParamVal ("action") == "eval"))
d239 1
a239 1
         myProblem ()->myPreprocessor ()->optPreprocess ();
@


1.13
log
@App controlled opt implode.
@
text
@d24 2
d241 1
a241 1
         myProblem ()->optPreprocess ();
d277 1
a277 1
         myProblem ()->postprocess ();
@


1.12
log
@GPIP migration.
@
text
@d233 1
a233 1
   if (myProblem ()->myOptImploder ()->optImpMode ())
@


1.11
log
@Changed the default value of groupPipMode to true.
@
text
@a218 3
   if (boolParamVal ("groupPipMode"))
      myProblem ()->myCompMgr ()->myGlobalComp ()->setGroupPipMode (true);

@


1.10
log
@Updated the copyright date on all source files.
@
text
@d219 3
@


1.9
log
@GPIP
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.8
log
@GPIP
@
text
@d145 9
d207 1
a207 1
      myProblem ()->pauseForInput ();
d300 1
a300 1
         myProblem ()->pauseForInput ();
d305 1
a305 1
         myProblem ()->pauseForInput ();
@


1.7
log
@[error recovery]
@
text
@d290 3
@


1.6
log
@[multi-thread]
@
text
@d125 3
@


1.5
log
@Ran make depend.
@
text
@d80 2
@


1.4
log
@[multi-thread]
@
text
@d78 17
a147 2
   standAloneMode_ = false;

a154 2
   standAloneMode_ = true;

@


1.3
log
@[multi-thread]
@
text
@d39 4
d131 2
d140 1
a140 1
   myWitRun_->myApiMgr ()->setStandAloneMode (true);
@


1.2
log
@[multi-thread]
@
text
@d134 1
a134 3
   myWitRun_->myApiMgr ()->setApiMode (false);
      //
      // Set API Mode to false to indicate running in stand-alone mode.
@


1.1
log
@[multi-thread]
@
text
@d74 1
a74 1
WitSaeMgr::WitSaeMgr (WitRun * theWitRun):
d78 1
d80 2
a81 1
      myParamMgr_ (NULL)
d83 3
d98 1
a98 1
void WitSaeMgr::execute (int argc, char * argv[])
a99 4
   myTimer_    = new WitTimer (myMsgFac ());

   myParamMgr_ = new WitParamMgr (this, argc, argv);

d117 1
a117 1
   myMsgFac ().setMaxTimesIssued ("headingMsg", 0);
d119 1
a119 1
   myWitRun ()->witInitialize ();
d127 1
a127 5
   myMsgFac () ("normalTermMsg");

   delete myTimer_;

   myTimer_ = NULL;
d134 1
a134 1
   myWitRun ()->myApiMgr ()->setApiMode (false);
d140 3
a142 1
   myWitRun ()->witInitialize ();
d149 1
a149 1
   myMsgFac ().setAccessMode ("w+");
d153 1
a153 2
   myMsgFac ().
      setDisplayExternalNumberByLevel (WitINFORMATIONAL_MESSAGES, false);
d155 8
a162 8
   myMsgFac ().setMaxTimesIssued ("witFuncCalled",     0);
   myMsgFac ().setMaxTimesIssued ("setStringAttrMsg",  0);
   myMsgFac ().setMaxTimesIssued ("witFileParam",      0);
   myMsgFac ().setMaxTimesIssued ("setIntAttrMsg",     0);
   myMsgFac ().setMaxTimesIssued ("setDblAttrMsg",     0);
   myMsgFac ().setMaxTimesIssued ("getAttrMsg",        0);
   myMsgFac ().setMaxTimesIssued ("setBooleanAttrMsg", 0);
   myMsgFac ().setMaxTimesIssued ("fileFormatMsg",     0);
d171 1
a171 1
   myMsgFac () ("readDataMsg");
d173 1
a173 1
   myWitRun ()->witReadData (cStringParamVal ("data_ifname"));
d180 1
a180 1
      myMsgFac () ("genericMsg", "Reading the second input data file.");
d182 1
a182 1
      myWitRun ()->witReadData (cStringParamVal ("data_ifname2"));
d190 1
a190 1
      myMsgFac () ("writeEchoMsg");
d192 1
a192 1
      myWitRun ()->witDisplayData (cStringParamVal ("echo_ofname"));
d200 1
a200 1
   myWitRun ()->witPreprocess ();
d202 1
a202 1
   if (myOptImploder ()->optImpMode ())
d212 1
a212 1
      myMsgFac () ("genericMsg", "Writing the input data file.");
d214 1
a214 1
      myWitRun ()->witWriteData (cStringParamVal ("data_ofname"));
d219 1
a219 1
      if (myCompMgr ()->myGlobalComp ()->autoPriority ())
d222 1
a222 1
      myMsgFac () ("writePreprocMsg");
d224 1
a224 1
      myWitRun ()->witDisplayData (cStringParamVal ("pre_ofname"));
d229 1
a229 1
      myMsgFac () ("writeGlobalMsg");
d248 1
a248 1
      myWitRun ()->witMrp ();
d251 1
a251 1
      myWitRun ()->witHeurImplode ();
d254 1
a254 1
      myOptImploder ()->implode ();
d258 1
a258 1
      myOptImploder ()->evalObjectives ();
d260 1
a260 1
      myCompMgr ()->myOptComp ()->objChoice ()->writeValues ();
d266 1
a266 1
         myWitRun ()->witDisplayData ("pipd.out");
d279 1
a279 1
   myMsgFac () ("writeReqSchedMsg");
d281 1
a281 1
   myWitRun ()->witWriteReqSched (cStringParamVal ("mrpsup_ofname"), WitBSV);
d285 1
a285 1
      myMsgFac () ("writeMrpSolnMsg");
d300 1
a300 1
      myMsgFac () ("writeExecSchedMsg");
d302 1
a302 1
      myWitRun ()->witWriteExecSched (cStringParamVal ("exec_ofname"), WitBSV);
d307 1
a307 1
      myMsgFac () ("writeShipSchedMsg");
d309 1
a309 1
      myWitRun ()->witWriteShipSched (cStringParamVal ("ship_ofname"), WitBSV);
d317 1
a317 1
      myMsgFac () ("writeSolnMsg");
d324 1
a324 1
      myMsgFac () ("writeCriticalListMsg");
d326 1
a326 1
      myWitRun ()->
d335 1
a335 1
      myMsgFac () ("genericMsg", "Writing the solution data file.");
d391 2
a392 1
   stronglyAssert (myCompMgr ()->myOptComp ()->myObjFunc1 ()->isChosen ());
d433 1
a433 1
      fprintf (myMsgFac ().myFile (),
d437 1
a437 1
      fprintf (myMsgFac ().myFile (),
@


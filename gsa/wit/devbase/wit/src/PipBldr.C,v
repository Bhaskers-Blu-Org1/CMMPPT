head	1.43;
access;
symbols
	sce_5_01_20080919:1.36
	sce_410_withVa:1.7;
locks; strict;
comment	@ * @;


1.43
date	2011.09.28.23.49.53;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.24.00.28.15;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.08.30.20.17.54;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.10.22.10.40;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.29.23.25.14;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.29.22.32.31;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.16.22.42.27;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.01.21.28.05;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.31.20.39.46;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.16.21.00.49;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.16.20.15.00;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.16.19.09.40;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.13.21.23.19;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.07.13.19.44.40;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.13.18.36.27;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.13.18.22.53;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.12.21.27.47;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.12.20.41.39;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.12.19.33.49;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.11.19.29.59;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.11.16.27.17;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.10.22.09.02;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.10.20.55.23;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.05.21.51.36;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.05.18.37.55;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.05.16.20.30;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.29.21.57.50;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.29.15.25.50;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.05.21.11.06;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.09.18.36.40;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.07.22.24.28;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.03.18.59.32;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.03.17.38.33;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.02.22.23.40;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.14.20.51.23;	author rjw;	state dead;
branches;
next	1.8;

1.8
date	2005.11.11.23.29.13;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.16.19.19.12;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.16.00.46.25;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.15.23.07.41;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.14.20.35.13;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.28.20.14.37;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.18.17.02.57;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.19.34.26;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "PipBldr.C"
//
// Contains the implementation of class PipBldr.
//------------------------------------------------------------------------------

#include <PipBldr.h>
#include <PipReqMgr.h>
#include <PipPartReqMgr.h>
#include <PipReqSrc.h>
#include <PipSeqEl.h>
#include <PipMgr.h>
#include <PipPgg.h>
#include <PipAttPgg.h>
#include <ExecPerSch.h>
#include <GlobalComp.h>
#include <Material.h>
#include <Operation.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Demand.h>
#include <Post.h>
#include <Mapping.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class PipBldr.
//------------------------------------------------------------------------------

void WitPipBldr::buildPegging (WitPipPgg * thePipPgg)
   {
   WitPipBldr thePipBldr (thePipPgg);

   thePipBldr.buildPegging ();
   }

//------------------------------------------------------------------------------

WitPipBldr::WitPipBldr (WitPipPgg * thePgg):

      WitProbAssoc    (thePgg),
      myPgg_          (thePgg),
      myReqMgr_       (NULL),
      myPartReqMgr_   (NULL),
      myExecPerSched_ (NULL),
      sideVol_        (myProblem (), 0.0),
      addedTo_        (myProblem (), false),
      incPegVol_      (myProblem (), 0.0),
      posDemPers_     (myProblem ())
   {
   myReqMgr_       = new WitPipReqMgr                  (myProblem ());
   myPartReqMgr_   = new WitPipPartReqMgr              (myReqMgr_);
   myExecPerSched_ = new WitExecPerSched <WitBopEntry> (myProblem ());

   compSideVols (sideVol_);
   }

//------------------------------------------------------------------------------

WitPipBldr::~WitPipBldr ()
   {
   delete myExecPerSched_;
   delete myPartReqMgr_;
   delete myReqMgr_;
   }

//------------------------------------------------------------------------------

void WitPipBldr::buildPegging ()
   {
   validateData ();

   placeShipmentReqs ();

   explodeAllReqs ();

   if (DEVELOPMENT)
      myReqMgr_->prtSizes ();

   if (myGlobalComp ()->prtPipMaxRatio ())
      dispMaxPegRatio ();

   consolidatePegging ();

   myPartReqMgr_->prtInfeas ();
   }

//------------------------------------------------------------------------------

void WitPipBldr::validateData ()
   {
   WitMaterial * theMat;

   if (not myGlobalComp ()->newPipPggOrder ())
      forEachMaterial (theMat, myProblem ())
         if (theMat->asapPipOrder ())
            myMsgFac () ("asapPipOrderOpoSmsg", theMat->partName ());
   }

//------------------------------------------------------------------------------

void WitPipBldr::compSideVols (WitSchedule <WitPart, double> & sideVolSched)
   {
   compBopSideVols (sideVolSched);
   compBomSideVols (sideVolSched);

   if (selPrintLevelAt (3))
      prtSideVols (sideVolSched);
   }

//------------------------------------------------------------------------------

void WitPipBldr::compBopSideVols (WitSchedule <WitPart, double> & sideVolSched)
   {
   WitBopEntry * theBopEnt;
   WitPart *     thePart;
   WitPeriod     execPer;
   double        execVolVal;
   WitPeriod     prodPer;

   forEachBopEntry (theBopEnt, myProblem ())
      {
      thePart = theBopEnt->myPart ();

      forEachPeriod (execPer, myProblem ())
         {
         if (not theBopEnt->inEffect (execPer))
            continue;

         if (theBopEnt->expAllowed ())
            if (theBopEnt->execPerOKForExp (execPer))
               continue;

         execVolVal = theBopEnt->myOperation ()->execVol ()[execPer];

         if (execVolVal <= 0.0)
            continue;

         prodPer = theBopEnt->impactPeriod ()[execPer];

         sideVolSched (thePart)[prodPer] +=
            execVolVal * theBopEnt->effProdRate ()[execPer];
         }
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::compBomSideVols (WitSchedule <WitPart, double> & sideVolSched)
   {
   WitBomEntry * theBomEnt;
   WitPeriod     execPer;
   double        effConsRateVal;
   double        execVolVal;
   WitPart *     thePart;
   WitPeriod     consPer;
   double        incConsVol;

   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         if (not theBomEnt->inEffect (execPer))
            continue;

         effConsRateVal = theBomEnt->effConsRate ()[execPer];

         if (effConsRateVal >= 0.0)
            continue;

         execVolVal = theBomEnt->myOperation ()->execVol ()[execPer];

         if (execVolVal <= 0.0)
            continue;

         thePart    = theBomEnt->myPart ();

         consPer    = theBomEnt->impactPeriod ()[execPer];

         incConsVol = execVolVal * effConsRateVal;

         sideVolSched (thePart)[consPer] -= incConsVol;
         }
   }

//------------------------------------------------------------------------------

void WitPipBldr::prtSideVols (
      const WitSchedule <WitPart, double> & sideVolSched)
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    sideVolVal;

   fprintf (msgFile (),
      "\n"
      "Side Effect Volumes:\n"
      "\n"
      "   Part Per SideVol\n");

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         sideVolVal = sideVolSched (thePart)[thePer];

         if (sideVolVal == 0.0)
            continue;

         fprintf (msgFile (),
            "   %4s %3d %7.2f\n",
            thePart->partName ().myCstring (),
            thePer,
            sideVolVal);
         }

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitPipBldr::consolidatePegging ()
   {
   myPgg_->  execVolPgg ()->consolidate ();
   myPgg_->   subVolPgg ()->consolidate ();
   myPgg_->supplyVolPgg ()->consolidate ();
   myPgg_->  prodVolPgg ()->consolidate ();
   myPgg_->  consVolPgg ()->consolidate ();
   myPgg_->  sideVolPgg ()->consolidate ();
   }

//------------------------------------------------------------------------------

void WitPipBldr::placeShipmentReqs ()
   {
   WitDemTripStack theShipSeq (myProblem ());
   int             theSeqNo;
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;
   WitPipReqSrc *  theReqSrc;
   WitPart *       thePart;

   myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

   theSeqNo = -1;

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      theSeqNo ++;

      theReqSrc = myReqMgr_->newReqSrcForSeqNo (theSeqNo);

      thePart   = theDemand->demandedPart ();

      myReqMgr_->addReq (thePart, shipPer, theReqSrc, incShipVol);
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeAllReqs ()
   {
   WitObjStack <WitPart>          unexpParts (myProblem ());
   WitMapping <WitOperation, int> nUnexpBopEnts;
   WitPart *                      thePart;
   WitBopEntry *                  theBopEnt;
   WitOperation *                 theOpn;

   revCopyInto (unexpParts, myCompMgr ()->allParts ());

   nUnexpBopEnts.allocate (myProblem (), 0);

   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         nUnexpBopEnts (theBopEnt->myOperation ()) ++;

   while (unexpParts.pop (thePart))
      {
      fillPartReqs (thePart);

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         if (theBopEnt->expAllowed ())
            {
            theOpn = theBopEnt->myOperation ();

            nUnexpBopEnts (theOpn) --;

            if (nUnexpBopEnts (theOpn) == 0)
               fillOpnReqs (theOpn);
            }
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::fillPartReqs (WitPart * thePart)
   {
   myPartReqMgr_->setUpPartReqs (thePart);

   if (myGlobalComp ()->newPipPggOrder ())
      pegToAllAttsNpo (thePart);
   else
      pegToAllAttsOpo (thePart);

   myPartReqMgr_->recordInfeas (thePart);
   }

//------------------------------------------------------------------------------

void WitPipBldr::pegToAllAttsNpo (WitPart * thePart)
   {
   if (thePart->supplyVol () != 0.0)
      pegToAtt (thePart, & WitPipBldr::netWithSupply);

   if (thePart->prodVol () != 0.0)
      pegToAtt (thePart, & WitPipBldr::explodeToProd);

   if (not (sideVol_ (thePart) == 0.0))
      pegToAtt (thePart, & WitPipBldr::netWithSideVol);
   }

//------------------------------------------------------------------------------

void WitPipBldr::pegToAtt (
      WitPart *           thePart,
      void (WitPipBldr::* thePegFunc) (WitPart *, WitPeriod))
   {
   WitPeriod thePer;

   for (thePer = lastPeriod (); thePer >= 0; thePer --)
      {
      myPartReqMgr_->mergeCurPartReqsIntoWorkSeq (thePer);

      if (not asapPggOrder (thePart))
         (this->*thePegFunc) (thePart, thePer);

      if (thePer > 0)
         myPartReqMgr_->rollReqsBack (thePer);
      }

   forEachPeriod (thePer, myProblem ())
      {
      if (thePer > 0)
         myPartReqMgr_->rollReqsFwd (thePer);

      if (asapPggOrder (thePart))
         (this->*thePegFunc) (thePart, thePer);

      myPartReqMgr_->restoreUnfilledCurPartReqs (thePer);
      }
   }

//------------------------------------------------------------------------------

bool WitPipBldr::asapPggOrder (WitPart * thePart)
   {
   WitMaterial * theMat;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (theMat->asapPipOrder ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitPipBldr::pegToAllAttsOpo (WitPart * thePart)
   {
   WitPeriod thePer;

   for (thePer = lastPeriod (); thePer >= 0; thePer --)
      {
      myPartReqMgr_->mergeCurPartReqsIntoWorkSeq (thePer);

      netWithSupply (thePart, thePer);
      explodeToProd (thePart, thePer);

      if (thePer > 0)
         myPartReqMgr_->rollReqsBack (thePer);
      }

   forEachPeriod (thePer, myProblem ())
      {
      if (thePer > 0)
         myPartReqMgr_->rollReqsFwd (thePer);

      netWithSideVol (thePart, thePer);

      myPartReqMgr_->restoreUnfilledCurPartReqs (thePer);
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::netWithSupply (WitPart * thePart, WitPeriod thePer)
   {
   double nonExcSuppVol;

   if (myPartReqMgr_->workSeqIsEmpty ())
      return;

   if (myGlobalComp ()->printDebug ())
      myPartReqMgr_->prtWorkReqSeq ("SupplyVol", thePart, thePer);

   nonExcSuppVol =
        thePart->supplyVol ()[thePer]
      - myProblem ()->myPostprocessor ()->compExcessVol (thePart, thePer);

   pegWorkReqToAtt (
      nonExcSuppVol, 
      myPgg_->supplyVolPgg (),
      thePart,
      thePer,
      NULL);
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeToProd (WitPart * thePart, WitPeriod thePer)
   {
   WitBopEntry * theBopEnt;

   if (myPartReqMgr_->workSeqIsEmpty ())
      return;

   if (thePart->prodVol ()[thePer] <= 0.0)
      return;

   if (not thePart->explodeable (thePer))
      return;

   if (myGlobalComp ()->printDebug ())
      myPartReqMgr_->prtWorkReqSeq ("ProdVol", thePart, thePer);

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      if (theBopEnt->expEligible (thePer))
         {
         explodeBopEntry (theBopEnt, thePer);

         if (myPartReqMgr_->workSeqIsEmpty ())
            return;
         }
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeBopEntry (WitBopEntry * theBopEnt, WitPeriod thePer)
   {
   WitPeriod execPerFirst;
   WitPeriod execPerLast;
   WitPeriod execPer;

   witAssert (theBopEnt->expEligible (thePer));

   witAssert (not myPartReqMgr_->workSeqIsEmpty ());

   myExecPerSched_->
      getExecPerRange (theBopEnt, thePer, execPerFirst, execPerLast);

   for (execPer = execPerLast; execPer >= execPerFirst; execPer --)
      if (theBopEnt->execPerOKForExp (execPer))
         if (theBopEnt->impactPeriod ()[execPer] == thePer)
            {
            explodeToExecPer (theBopEnt, execPer);

            if (myPartReqMgr_->workSeqIsEmpty ())
               return;
            }
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeToExecPer (WitBopEntry * theBopEnt, WitPeriod execPer)
   {
   double         theProdVol;
   WitPipReqList  pgdReqList (myProblem ());
   WitPipReqSrc * theReqSrc;
   double         incProdVol;
   double         incExecVol;

   witAssert (not myPartReqMgr_->workSeqIsEmpty ());

   theProdVol =
        theBopEnt->myOperation ()->execVol ()[execPer]
      * theBopEnt->effProdRate ()            [execPer];

   pegWorkReqToAtt (
        theProdVol,
        myPgg_->prodVolPgg (),
        theBopEnt->myPart (),
        theBopEnt->impactPeriod ()[execPer],
      & pgdReqList);

   pgdReqList.reverse ();

   while (pgdReqList.pop (theReqSrc, incProdVol))
      {
      incExecVol = incProdVol / theBopEnt->effProdRate ()[execPer];

      addToIncPegVol (incExecVol, theReqSrc);

      myReqMgr_->addReq (theBopEnt, execPer, theReqSrc, incExecVol);
      }
   
   myPgg_->
      coExecVolPgg ()->
         multiAppend (posDemPers_, theBopEnt, execPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitPipBldr::netWithSideVol (WitPart * thePart, WitPeriod thePer)
   {
   if (myPartReqMgr_->workSeqIsEmpty ())
      return;

   if (myGlobalComp ()->printDebug ())
      myPartReqMgr_->prtWorkReqSeq ("SideVol", thePart, thePer);

   pegWorkReqToAtt (
      sideVol_ (thePart)[thePer],
      myPgg_->sideVolPgg (),
      thePart,
      thePer,
      NULL);
   }

//------------------------------------------------------------------------------

void WitPipBldr::pegWorkReqToAtt (
      double                   theAttVol,
      WitPipAttPgg <WitPart> * theAttPgg,
      WitPart *                thePart,
      WitPeriod                thePer,
      WitPipReqList *          pgdReqListPtr)
   {
   double         netAttVol;
   WitPipReqSrc * theReqSrc;
   WitPeriod      fillPer;
   double         incReqVol;
   double         incPegVol;

   witAssert (not myPartReqMgr_->workSeqIsEmpty ());

   netAttVol = theAttVol;

   if (pgdReqListPtr != NULL)
      pgdReqListPtr->clear ();

   while ((not myPartReqMgr_->workSeqIsEmpty ()) and (netAttVol > NET_TOL))
      {
      myPartReqMgr_->getNextReq (netAttVol, theReqSrc, incPegVol);

      addToIncPegVol (incPegVol, theReqSrc);

      if (pgdReqListPtr != NULL)
         pgdReqListPtr->push (theReqSrc, incPegVol);
      }

   theAttPgg->multiAppend (posDemPers_, thePart, thePer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitPipBldr::fillOpnReqs (WitOperation * theOpn)
   {
   WitPeriod      execPer;
   WitPipReqSrc * theReqSrc;
   double         incExecVol;
   WitBomEntry *  theBomEnt;

   for (execPer = lastPeriod (); execPer >= 0; execPer --)
      {
      if (not myReqMgr_->hasReqsFor (theOpn, execPer))
         continue;

      myReqMgr_->loadCurReqList (theOpn, execPer);

      myReqMgr_->initReqListItr ();

      while (not myReqMgr_->finishedReqListItr ())
         {
         myReqMgr_->advanceReqListItr (theReqSrc, incExecVol);

         addToIncPegVol (incExecVol, theReqSrc);
         }

      myPgg_->
         execVolPgg ()->
            multiAppend (posDemPers_, theOpn, execPer, incPegVol_);

      forEachEl (theBomEnt, theOpn->bom ())
         explodeBomEntry (theBomEnt, execPer);

      myReqMgr_->clearCurReqList ();
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeBomEntry (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitSubEntry * theSub;

   if (not theBomEnt->inEffect (execPer))
      return;

   pegSubVols (theBomEnt, execPer);

   myReqMgr_->initReqListItr ();

   explodeConsEntry (
      theBomEnt,
      execPer,
      theBomEnt->nonSubVol ()[execPer]);

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      if (myReqMgr_->finishedReqListItr ())
         return;

      explodeConsEntry (
         theSub,
         execPer,
         theSub->subVol ()[execPer]);
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::pegSubVols (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   double         netNonSubVol;
   WitPipReqSrc * theReqSrc;
   double         incNonSubVol;
   WitSubEntry *  theSub;
   double         netSubVol;
   double         incSubVol;

   if (not theBomEnt->hasSubsInEffect ()[execPer])
      return;

   myReqMgr_->initReqListItr ();

   netNonSubVol = theBomEnt->nonSubVol ()[execPer];

   while (netNonSubVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         return;

      myReqMgr_->advanceReqListItr (netNonSubVol, theReqSrc, incNonSubVol);
      }

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      netSubVol = theSub->subVol ()[execPer];

      while (netSubVol > NET_TOL)
         {
         if (myReqMgr_->finishedReqListItr ())
            break;

         myReqMgr_->advanceReqListItr (netSubVol, theReqSrc, incSubVol);

         addToIncPegVol (incSubVol, theReqSrc);
         }

      myPgg_->
         subVolPgg ()->
            multiAppend (posDemPers_, theSub, execPer, incPegVol_);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeConsEntry (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         totExecVol)
   {
   WitPart *      consPart;
   WitPeriod      consPer;
   double         netExecVol;
   WitPipReqSrc * theReqSrc;
   double         incExecVol;
   double         incConsVol;

   if (totExecVol <= NET_TOL)
      return;

   consPart   = theConsEnt->myPart ();

   consPer    = theConsEnt->impactPeriod ()[execPer];

   netExecVol = totExecVol;

   while (netExecVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netExecVol, theReqSrc, incExecVol);

      incConsVol = incExecVol * theConsEnt->effConsRate ()[execPer];

      if (incConsVol <= NET_TOL)
         continue;

      addToIncPegVol (incConsVol, theReqSrc);

      myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
      }

   myPgg_->
      consVolPgg ()->
         multiAppend (posDemPers_, consPart, consPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitPipBldr::addToIncPegVol (double pegVol, WitPipReqSrc * theReqSrc)
   {
   WitPipSeqElItr theItr;
   WitPipSeqEl *  theSeqEl;
   WitDemand *    theDemand;
   WitPeriod      shipPer;

   witAssert (pegVol > NET_TOL);

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         if (addedTo_ (theDemand)[shipPer])
            continue;

         if (incPegVol_ (theDemand)[shipPer] == 0.0)
            posDemPers_.push (theDemand, shipPer);

         incPegVol_ (theDemand)[shipPer] += pegVol;

         addedTo_ (theDemand)[shipPer] = true;
         }

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         addedTo_ (theDemand)[shipPer] = false;
         }
   }

//------------------------------------------------------------------------------

void WitPipBldr::dispMaxPegRatio ()
   {
   WitSchedule <WitOperation, double> totPgdExecVol;
   WitDemand *                        theDemand;
   WitPeriod                          shipPer;
   WitTripStack <WitOperation>        theOpnTrips (myProblem ());
   WitOperation *                     theOpn;
   WitPeriod                          execPer;
   double                             pgdExecVol;
   double                             ratio;
   double                             maxRatio;
   WitOperation *                     maxOpn;
   WitPeriod                          maxExecPer;

   totPgdExecVol.allocate (myProblem (), 0.0);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         myPgg_->
            execVolPgg ()->
               getPegTrips (theDemand, shipPer, theOpnTrips);

         while (theOpnTrips.pop (theOpn, execPer, pgdExecVol))
            totPgdExecVol (theOpn)[execPer] += pgdExecVol;
         }

   maxRatio = 0.0;

   maxOpn   = NULL;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theOpn->execVol ()[execPer] > NET_TOL)
            {
            ratio =
                 totPgdExecVol (theOpn)[execPer]
               / theOpn->execVol ()    [execPer];

            if (ratio > maxRatio)
               {
               maxRatio   = ratio;
               maxOpn     = theOpn;
               maxExecPer = execPer;
               }
            }

   prtMaxPegRatio (maxRatio, maxOpn, maxExecPer);
   }

//------------------------------------------------------------------------------

void WitPipBldr::prtMaxPegRatio (
      double         ratio,
      WitOperation * theOpn,
      WitPeriod      execPer)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      pgdExecVol;

   fprintf (msgFile (),
      "Max pegging ratio: %.3f\n",
      ratio);

   if (theOpn == NULL)
      return;

   fprintf (msgFile (),
      "\n"
      "Occurred at:\n"
      "   Operation:     %s\n"
      "   Exec Per:      %d\n"
      "   ExecVol:       %.3f\n\n",
      theOpn->operationName ().myCstring (),
      execPer,
      theOpn->execVol ()[execPer]);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         pgdExecVol =
            myPgg_->
               execVolPgg ()->
                  pegVolFor (theDemand, shipPer, theOpn, execPer);

         if (pgdExecVol > NET_TOL)
            fprintf (msgFile (),
               "      Demand:     %s\n"
               "      ShipPer:    %d\n"
               "      PgdExecVol: %.3f\n\n",
               theDemand->demandName ().myCstring (),
               shipPer,
               pgdExecVol);
         }
   }
@


1.42
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.41
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d41 2
a42 2
{
WitPipBldr thePipBldr (thePipPgg);
d44 2
a45 2
thePipBldr.buildPegging ();
}
d51 13
a63 13
WitProbAssoc    (thePgg),
myPgg_          (thePgg),
myReqMgr_       (NULL),
myPartReqMgr_   (NULL),
myExecPerSched_ (NULL),
sideVol_        (myProblem (), 0.0),
addedTo_        (myProblem (), false),
incPegVol_      (myProblem (), 0.0),
posDemPers_     (myProblem ())
{
myReqMgr_       = new WitPipReqMgr                  (myProblem ());
myPartReqMgr_   = new WitPipPartReqMgr              (myReqMgr_);
myExecPerSched_ = new WitExecPerSched <WitBopEntry> (myProblem ());
d65 2
a66 2
compSideVols (sideVol_);
}
d71 5
a75 5
{
delete myExecPerSched_;
delete myPartReqMgr_;
delete myReqMgr_;
}
d80 2
a81 2
{
validateData ();
d83 1
a83 1
placeShipmentReqs ();
d85 1
a85 1
explodeAllReqs ();
d87 2
a88 2
if (DEVELOPMENT)
myReqMgr_->prtSizes ();
d90 2
a91 2
if (myGlobalComp ()->prtPipMaxRatio ())
dispMaxPegRatio ();
d93 1
a93 1
consolidatePegging ();
d95 2
a96 2
myPartReqMgr_->prtInfeas ();
}
d101 2
a102 2
{
WitMaterial * theMat;
d104 5
a108 5
if (not myGlobalComp ()->newPipPggOrder ())
forEachMaterial (theMat, myProblem ())
if (theMat->asapPipOrder ())
myMsgFac () ("asapPipOrderOpoSmsg", theMat->partName ());
}
d113 7
a119 7
{
compBopSideVols (sideVolSched);
compBomSideVols (sideVolSched);

if (selPrintLevelAt (3))
prtSideVols (sideVolSched);
}
d124 32
a155 32
{
WitBopEntry * theBopEnt;
WitPart *     thePart;
WitPeriod     execPer;
double        execVolVal;
WitPeriod     prodPer;

forEachBopEntry (theBopEnt, myProblem ())
{
thePart = theBopEnt->myPart ();

forEachPeriod (execPer, myProblem ())
{
if (not theBopEnt->inEffect (execPer))
continue;

if (theBopEnt->expAllowed ())
if (theBopEnt->execPerOKForExp (execPer))
continue;

execVolVal = theBopEnt->myOperation ()->execVol ()[execPer];

if (execVolVal <= 0.0)
continue;

prodPer = theBopEnt->impactPeriod ()[execPer];

sideVolSched (thePart)[prodPer] +=
execVolVal * theBopEnt->effProdRate ()[execPer];
}
}
}
d160 8
a167 8
{
WitBomEntry * theBomEnt;
WitPeriod     execPer;
double        effConsRateVal;
double        execVolVal;
WitPart *     thePart;
WitPeriod     consPer;
double        incConsVol;
d169 5
a173 5
forEachBomEntry (theBomEnt, myProblem ())
forEachPeriod (execPer, myProblem ())
{
if (not theBomEnt->inEffect (execPer))
continue;
d175 1
a175 1
effConsRateVal = theBomEnt->effConsRate ()[execPer];
d177 2
a178 2
if (effConsRateVal >= 0.0)
continue;
d180 1
a180 1
execVolVal = theBomEnt->myOperation ()->execVol ()[execPer];
d182 2
a183 2
if (execVolVal <= 0.0)
continue;
d185 1
a185 1
thePart    = theBomEnt->myPart ();
d187 1
a187 1
consPer    = theBomEnt->impactPeriod ()[execPer];
d189 1
a189 1
incConsVol = execVolVal * effConsRateVal;
d191 3
a193 3
sideVolSched (thePart)[consPer] -= incConsVol;
}
}
d198 26
a223 26
const WitSchedule <WitPart, double> & sideVolSched)
{
WitPart * thePart;
WitPeriod thePer;
double    sideVolVal;

fprintf (msgFile (),
"\n"
"Side Effect Volumes:\n"
"\n"
"   Part Per SideVol\n");

forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
{
sideVolVal = sideVolSched (thePart)[thePer];

if (sideVolVal == 0.0)
continue;

fprintf (msgFile (),
"   %4s %3d %7.2f\n",
thePart->partName ().myCstring (),
thePer,
sideVolVal);
}
d225 2
a226 2
fprintf (msgFile (), "\n");
}
d231 8
a238 8
{
myPgg_->  execVolPgg ()->consolidate ();
myPgg_->   subVolPgg ()->consolidate ();
myPgg_->supplyVolPgg ()->consolidate ();
myPgg_->  prodVolPgg ()->consolidate ();
myPgg_->  consVolPgg ()->consolidate ();
myPgg_->  sideVolPgg ()->consolidate ();
}
d243 24
a266 24
{
WitDemTripStack theShipSeq (myProblem ());
int             theSeqNo;
WitDemand *     theDemand;
WitPeriod       shipPer;
double          incShipVol;
WitPipReqSrc *  theReqSrc;
WitPart *       thePart;

myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

theSeqNo = -1;

while (theShipSeq.pop (theDemand, shipPer, incShipVol))
{
theSeqNo ++;

theReqSrc = myReqMgr_->newReqSrcForSeqNo (theSeqNo);

thePart   = theDemand->demandedPart ();

myReqMgr_->addReq (thePart, shipPer, theReqSrc, incShipVol);
}
}
d271 31
a301 31
{
WitObjStack <WitPart>          unexpParts (myProblem ());
WitMapping <WitOperation, int> nUnexpBopEnts;
WitPart *                      thePart;
WitBopEntry *                  theBopEnt;
WitOperation *                 theOpn;

revCopyInto (unexpParts, myCompMgr ()->allParts ());

nUnexpBopEnts.allocate (myProblem (), 0);

forEachBopEntry (theBopEnt, myProblem ())
if (theBopEnt->expAllowed ())
nUnexpBopEnts (theBopEnt->myOperation ()) ++;

while (unexpParts.pop (thePart))
{
fillPartReqs (thePart);

forEachEl (theBopEnt, thePart->producingBopEntries ())
if (theBopEnt->expAllowed ())
{
theOpn = theBopEnt->myOperation ();

nUnexpBopEnts (theOpn) --;

if (nUnexpBopEnts (theOpn) == 0)
fillOpnReqs (theOpn);
}
}
}
d306 2
a307 2
{
myPartReqMgr_->setUpPartReqs (thePart);
d309 4
a312 4
if (myGlobalComp ()->newPipPggOrder ())
pegToAllAttsNpo (thePart);
else
pegToAllAttsOpo (thePart);
d314 2
a315 2
myPartReqMgr_->recordInfeas (thePart);
}
d320 10
a329 10
{
if (thePart->supplyVol () != 0.0)
pegToAtt (thePart, & WitPipBldr::netWithSupply);

if (thePart->prodVol () != 0.0)
pegToAtt (thePart, & WitPipBldr::explodeToProd);

if (not (sideVol_ (thePart) == 0.0))
pegToAtt (thePart, & WitPipBldr::netWithSideVol);
}
d334 27
a360 27
WitPart *           thePart,
void (WitPipBldr::* thePegFunc) (WitPart *, WitPeriod))
{
WitPeriod thePer;

for (thePer = lastPeriod (); thePer >= 0; thePer --)
{
myPartReqMgr_->mergeCurPartReqsIntoWorkSeq (thePer);

if (not asapPggOrder (thePart))
(this->*thePegFunc) (thePart, thePer);

if (thePer > 0)
myPartReqMgr_->rollReqsBack (thePer);
}

forEachPeriod (thePer, myProblem ())
{
if (thePer > 0)
myPartReqMgr_->rollReqsFwd (thePer);

if (asapPggOrder (thePart))
(this->*thePegFunc) (thePart, thePer);

myPartReqMgr_->restoreUnfilledCurPartReqs (thePer);
}
}
d365 2
a366 2
{
WitMaterial * theMat;
d368 1
a368 1
theMat = thePart->thisMat ();
d370 3
a372 3
if (theMat != NULL)
if (theMat->asapPipOrder ())
return true;
d374 2
a375 2
return false;
}
d380 2
a381 2
{
WitPeriod thePer;
d383 21
a403 21
for (thePer = lastPeriod (); thePer >= 0; thePer --)
{
myPartReqMgr_->mergeCurPartReqsIntoWorkSeq (thePer);

netWithSupply (thePart, thePer);
explodeToProd (thePart, thePer);

if (thePer > 0)
myPartReqMgr_->rollReqsBack (thePer);
}

forEachPeriod (thePer, myProblem ())
{
if (thePer > 0)
myPartReqMgr_->rollReqsFwd (thePer);

netWithSideVol (thePart, thePer);

myPartReqMgr_->restoreUnfilledCurPartReqs (thePer);
}
}
d408 2
a409 2
{
double nonExcSuppVol;
d411 2
a412 2
if (myPartReqMgr_->workSeqIsEmpty ())
return;
d414 2
a415 2
if (myGlobalComp ()->printDebug ())
myPartReqMgr_->prtWorkReqSeq ("SupplyVol", thePart, thePer);
d417 11
a427 11
nonExcSuppVol =
thePart->supplyVol ()[thePer]
- myProblem ()->myPostprocessor ()->compExcessVol (thePart, thePer);

pegWorkReqToAtt (
nonExcSuppVol,
myPgg_->supplyVolPgg (),
thePart,
thePer,
NULL);
}
d432 2
a433 2
{
WitBopEntry * theBopEnt;
d435 2
a436 2
if (myPartReqMgr_->workSeqIsEmpty ())
return;
d438 2
a439 2
if (thePart->prodVol ()[thePer] <= 0.0)
return;
d441 15
a455 15
if (not thePart->explodeable (thePer))
return;

if (myGlobalComp ()->printDebug ())
myPartReqMgr_->prtWorkReqSeq ("ProdVol", thePart, thePer);

forEachEl (theBopEnt, thePart->producingBopEntries ())
if (theBopEnt->expEligible (thePer))
{
explodeBopEntry (theBopEnt, thePer);

if (myPartReqMgr_->workSeqIsEmpty ())
return;
}
}
d460 22
a481 22
{
WitPeriod execPerFirst;
WitPeriod execPerLast;
WitPeriod execPer;

witAssert (theBopEnt->expEligible (thePer));

witAssert (not myPartReqMgr_->workSeqIsEmpty ());

myExecPerSched_->
getExecPerRange (theBopEnt, thePer, execPerFirst, execPerLast);

for (execPer = execPerLast; execPer >= execPerFirst; execPer --)
if (theBopEnt->execPerOKForExp (execPer))
if (theBopEnt->impactPeriod ()[execPer] == thePer)
{
explodeToExecPer (theBopEnt, execPer);

if (myPartReqMgr_->workSeqIsEmpty ())
return;
}
}
d486 35
a520 35
{
double         theProdVol;
WitPipReqList  pgdReqList (myProblem ());
WitPipReqSrc * theReqSrc;
double         incProdVol;
double         incExecVol;

witAssert (not myPartReqMgr_->workSeqIsEmpty ());

theProdVol =
theBopEnt->myOperation ()->execVol ()[execPer]
* theBopEnt->effProdRate ()            [execPer];

pegWorkReqToAtt (
theProdVol,
myPgg_->prodVolPgg (),
theBopEnt->myPart (),
theBopEnt->impactPeriod ()[execPer],
& pgdReqList);

pgdReqList.reverse ();

while (pgdReqList.pop (theReqSrc, incProdVol))
{
incExecVol = incProdVol / theBopEnt->effProdRate ()[execPer];

addToIncPegVol (incExecVol, theReqSrc);

myReqMgr_->addReq (theBopEnt, execPer, theReqSrc, incExecVol);
}

myPgg_->
coExecVolPgg ()->
multiAppend (posDemPers_, theBopEnt, execPer, incPegVol_);
}
d525 14
a538 14
{
if (myPartReqMgr_->workSeqIsEmpty ())
return;

if (myGlobalComp ()->printDebug ())
myPartReqMgr_->prtWorkReqSeq ("SideVol", thePart, thePer);

pegWorkReqToAtt (
sideVol_ (thePart)[thePer],
myPgg_->sideVolPgg (),
thePart,
thePer,
NULL);
}
d543 28
a570 28
double                   theAttVol,
WitPipAttPgg <WitPart> * theAttPgg,
WitPart *                thePart,
WitPeriod                thePer,
WitPipReqList *          pgdReqListPtr)
{
double         netAttVol;
WitPipReqSrc * theReqSrc;
WitPeriod      fillPer;
double         incReqVol;
double         incPegVol;

witAssert (not myPartReqMgr_->workSeqIsEmpty ());

netAttVol = theAttVol;

if (pgdReqListPtr != NULL)
pgdReqListPtr->clear ();

while ((not myPartReqMgr_->workSeqIsEmpty ()) and (netAttVol > NET_TOL))
{
myPartReqMgr_->getNextReq (netAttVol, theReqSrc, incPegVol);

addToIncPegVol (incPegVol, theReqSrc);

if (pgdReqListPtr != NULL)
pgdReqListPtr->push (theReqSrc, incPegVol);
}
d572 2
a573 2
theAttPgg->multiAppend (posDemPers_, thePart, thePer, incPegVol_);
}
d578 32
a609 32
{
WitPeriod      execPer;
WitPipReqSrc * theReqSrc;
double         incExecVol;
WitBomEntry *  theBomEnt;

for (execPer = lastPeriod (); execPer >= 0; execPer --)
{
if (not myReqMgr_->hasReqsFor (theOpn, execPer))
continue;

myReqMgr_->loadCurReqList (theOpn, execPer);

myReqMgr_->initReqListItr ();

while (not myReqMgr_->finishedReqListItr ())
{
myReqMgr_->advanceReqListItr (theReqSrc, incExecVol);

addToIncPegVol (incExecVol, theReqSrc);
}

myPgg_->
execVolPgg ()->
multiAppend (posDemPers_, theOpn, execPer, incPegVol_);

forEachEl (theBomEnt, theOpn->bom ())
explodeBomEntry (theBomEnt, execPer);

myReqMgr_->clearCurReqList ();
}
}
d614 28
a641 28
WitBomEntry * theBomEnt,
WitPeriod     execPer)
{
WitSubEntry * theSub;

if (not theBomEnt->inEffect (execPer))
return;

pegSubVols (theBomEnt, execPer);

myReqMgr_->initReqListItr ();

explodeConsEntry (
theBomEnt,
execPer,
theBomEnt->nonSubVol ()[execPer]);

forEachEl (theSub, theBomEnt->mySubEntries ())
{
if (myReqMgr_->finishedReqListItr ())
return;

explodeConsEntry (
theSub,
execPer,
theSub->subVol ()[execPer]);
}
}
d646 45
a690 45
{
double         netNonSubVol;
WitPipReqSrc * theReqSrc;
double         incNonSubVol;
WitSubEntry *  theSub;
double         netSubVol;
double         incSubVol;

if (not theBomEnt->hasSubsInEffect ()[execPer])
return;

myReqMgr_->initReqListItr ();

netNonSubVol = theBomEnt->nonSubVol ()[execPer];

while (netNonSubVol > NET_TOL)
{
if (myReqMgr_->finishedReqListItr ())
return;

myReqMgr_->advanceReqListItr (netNonSubVol, theReqSrc, incNonSubVol);
}

forEachEl (theSub, theBomEnt->mySubEntries ())
{
netSubVol = theSub->subVol ()[execPer];

while (netSubVol > NET_TOL)
{
if (myReqMgr_->finishedReqListItr ())
break;

myReqMgr_->advanceReqListItr (netSubVol, theReqSrc, incSubVol);

addToIncPegVol (incSubVol, theReqSrc);
}

myPgg_->
subVolPgg ()->
multiAppend (posDemPers_, theSub, execPer, incPegVol_);

if (myReqMgr_->finishedReqListItr ())
return;
}
}
d695 10
a704 10
WitConsEntry * theConsEnt,
WitPeriod      execPer,
double         totExecVol)
{
WitPart *      consPart;
WitPeriod      consPer;
double         netExecVol;
WitPipReqSrc * theReqSrc;
double         incExecVol;
double         incConsVol;
d706 2
a707 2
if (totExecVol <= NET_TOL)
return;
d709 1
a709 1
consPart   = theConsEnt->myPart ();
d711 1
a711 1
consPer    = theConsEnt->impactPeriod ()[execPer];
d713 1
a713 1
netExecVol = totExecVol;
d715 4
a718 4
while (netExecVol > NET_TOL)
{
if (myReqMgr_->finishedReqListItr ())
break;
d720 1
a720 1
myReqMgr_->advanceReqListItr (netExecVol, theReqSrc, incExecVol);
d722 1
a722 1
incConsVol = incExecVol * theConsEnt->effConsRate ()[execPer];
d724 2
a725 2
if (incConsVol <= NET_TOL)
continue;
d727 1
a727 1
addToIncPegVol (incConsVol, theReqSrc);
d729 2
a730 2
myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
}
d732 4
a735 4
myPgg_->
consVolPgg ()->
multiAppend (posDemPers_, consPart, consPer, incPegVol_);
}
d740 5
a744 5
{
WitPipSeqElItr theItr;
WitPipSeqEl *  theSeqEl;
WitDemand *    theDemand;
WitPeriod      shipPer;
d746 1
a746 1
witAssert (pegVol > NET_TOL);
d748 1
a748 1
theReqSrc->attachSeqElItr (theItr);
d750 4
a753 4
while (theItr.advance (theSeqEl))
if (theSeqEl->hasaShipment ())
{
theSeqEl->getData (theDemand, shipPer);
d755 2
a756 2
if (addedTo_ (theDemand)[shipPer])
continue;
d758 2
a759 2
if (incPegVol_ (theDemand)[shipPer] == 0.0)
posDemPers_.push (theDemand, shipPer);
d761 1
a761 1
incPegVol_ (theDemand)[shipPer] += pegVol;
d763 2
a764 2
addedTo_ (theDemand)[shipPer] = true;
}
d766 1
a766 1
theReqSrc->attachSeqElItr (theItr);
d768 4
a771 4
while (theItr.advance (theSeqEl))
if (theSeqEl->hasaShipment ())
{
theSeqEl->getData (theDemand, shipPer);
d773 3
a775 3
addedTo_ (theDemand)[shipPer] = false;
}
}
d780 45
a824 45
{
WitSchedule <WitOperation, double> totPgdExecVol;
WitDemand *                        theDemand;
WitPeriod                          shipPer;
WitTripStack <WitOperation>        theOpnTrips (myProblem ());
WitOperation *                     theOpn;
WitPeriod                          execPer;
double                             pgdExecVol;
double                             ratio;
double                             maxRatio;
WitOperation *                     maxOpn;
WitPeriod                          maxExecPer;

totPgdExecVol.allocate (myProblem (), 0.0);

forEachDemand (theDemand, myProblem ())
forEachPeriod (shipPer, myProblem ())
{
myPgg_->
execVolPgg ()->
getPegTrips (theDemand, shipPer, theOpnTrips);

while (theOpnTrips.pop (theOpn, execPer, pgdExecVol))
totPgdExecVol (theOpn)[execPer] += pgdExecVol;
}

maxRatio = 0.0;

maxOpn   = NULL;

forEachOperation (theOpn, myProblem ())
forEachPeriod (execPer, myProblem ())
if (theOpn->execVol ()[execPer] > NET_TOL)
{
ratio =
totPgdExecVol (theOpn)[execPer]
/ theOpn->execVol ()    [execPer];

if (ratio > maxRatio)
{
maxRatio   = ratio;
maxOpn     = theOpn;
maxExecPer = execPer;
}
}
d826 2
a827 2
prtMaxPegRatio (maxRatio, maxOpn, maxExecPer);
}
d832 43
a874 43
double         ratio,
WitOperation * theOpn,
WitPeriod      execPer)
{
WitDemand * theDemand;
WitPeriod   shipPer;
double      pgdExecVol;

fprintf (msgFile (),
"Max pegging ratio: %.3f\n",
ratio);

if (theOpn == NULL)
return;

fprintf (msgFile (),
"\n"
"Occurred at:\n"
"   Operation:     %s\n"
"   Exec Per:      %d\n"
"   ExecVol:       %.3f\n\n",
theOpn->operationName ().myCstring (),
execPer,
theOpn->execVol ()[execPer]);

forEachDemand (theDemand, myProblem ())
forEachPeriod (shipPer, myProblem ())
{
pgdExecVol =
myPgg_->
execVolPgg ()->
pegVolFor (theDemand, shipPer, theOpn, execPer);

if (pgdExecVol > NET_TOL)
fprintf (msgFile (),
"      Demand:     %s\n"
"      ShipPer:    %d\n"
"      PgdExecVol: %.3f\n\n",
theDemand->demandName ().myCstring (),
shipPer,
pgdExecVol);
}
}
@


1.40
log
@Heuristic Adjustment
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d41 2
a42 2
   {
   WitPipBldr thePipBldr (thePipPgg);
d44 2
a45 2
   thePipBldr.buildPegging ();
   }
d51 13
a63 13
      WitProbAssoc    (thePgg),
      myPgg_          (thePgg),
      myReqMgr_       (NULL),
      myPartReqMgr_   (NULL),
      myExecPerSched_ (NULL),
      sideVol_        (myProblem (), 0.0),
      addedTo_        (myProblem (), false),
      incPegVol_      (myProblem (), 0.0),
      posDemPers_     (myProblem ())
   {
   myReqMgr_       = new WitPipReqMgr                  (myProblem ());
   myPartReqMgr_   = new WitPipPartReqMgr              (myReqMgr_);
   myExecPerSched_ = new WitExecPerSched <WitBopEntry> (myProblem ());
d65 2
a66 2
   compSideVols (sideVol_);
   }
d71 5
a75 5
   {
   delete myExecPerSched_;
   delete myPartReqMgr_;
   delete myReqMgr_;
   }
d80 2
a81 2
   {
   validateData ();
d83 1
a83 1
   placeShipmentReqs ();
d85 1
a85 1
   explodeAllReqs ();
d87 2
a88 2
   if (DEVELOPMENT)
      myReqMgr_->prtSizes ();
d90 2
a91 2
   if (myGlobalComp ()->prtPipMaxRatio ())
      dispMaxPegRatio ();
d93 1
a93 1
   consolidatePegging ();
d95 2
a96 2
   myPartReqMgr_->prtInfeas ();
   }
d101 2
a102 2
   {
   WitMaterial * theMat;
d104 5
a108 5
   if (not myGlobalComp ()->newPipPggOrder ())
      forEachMaterial (theMat, myProblem ())
         if (theMat->asapPipOrder ())
            myMsgFac () ("asapPipOrderOpoSmsg", theMat->partName ());
   }
d113 7
a119 7
   {
   compBopSideVols (sideVolSched);
   compBomSideVols (sideVolSched);

   if (selPrintLevelAt (3))
      prtSideVols (sideVolSched);
   }
d124 32
a155 32
   {
   WitBopEntry * theBopEnt;
   WitPart *     thePart;
   WitPeriod     execPer;
   double        execVolVal;
   WitPeriod     prodPer;

   forEachBopEntry (theBopEnt, myProblem ())
      {
      thePart = theBopEnt->myPart ();

      forEachPeriod (execPer, myProblem ())
         {
         if (not theBopEnt->inEffect (execPer))
            continue;

         if (theBopEnt->expAllowed ())
            if (theBopEnt->execPerOKForExp (execPer))
               continue;

         execVolVal = theBopEnt->myOperation ()->execVol ()[execPer];

         if (execVolVal <= 0.0)
            continue;

         prodPer = theBopEnt->impactPeriod ()[execPer];

         sideVolSched (thePart)[prodPer] +=
            execVolVal * theBopEnt->effProdRate ()[execPer];
         }
      }
   }
d160 8
a167 8
   {
   WitBomEntry * theBomEnt;
   WitPeriod     execPer;
   double        effConsRateVal;
   double        execVolVal;
   WitPart *     thePart;
   WitPeriod     consPer;
   double        incConsVol;
d169 5
a173 5
   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         if (not theBomEnt->inEffect (execPer))
            continue;
d175 1
a175 1
         effConsRateVal = theBomEnt->effConsRate ()[execPer];
d177 2
a178 2
         if (effConsRateVal >= 0.0)
            continue;
d180 1
a180 1
         execVolVal = theBomEnt->myOperation ()->execVol ()[execPer];
d182 2
a183 2
         if (execVolVal <= 0.0)
            continue;
d185 1
a185 1
         thePart    = theBomEnt->myPart ();
d187 1
a187 1
         consPer    = theBomEnt->impactPeriod ()[execPer];
d189 1
a189 1
         incConsVol = execVolVal * effConsRateVal;
d191 3
a193 3
         sideVolSched (thePart)[consPer] -= incConsVol;
         }
   }
d198 26
a223 26
      const WitSchedule <WitPart, double> & sideVolSched)
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    sideVolVal;

   fprintf (msgFile (),
      "\n"
      "Side Effect Volumes:\n"
      "\n"
      "   Part Per SideVol\n");

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         sideVolVal = sideVolSched (thePart)[thePer];

         if (sideVolVal == 0.0)
            continue;

         fprintf (msgFile (),
            "   %4s %3d %7.2f\n",
            thePart->partName ().myCstring (),
            thePer,
            sideVolVal);
         }
d225 2
a226 2
   fprintf (msgFile (), "\n");
   }
d231 8
a238 8
   {
   myPgg_->  execVolPgg ()->consolidate ();
   myPgg_->   subVolPgg ()->consolidate ();
   myPgg_->supplyVolPgg ()->consolidate ();
   myPgg_->  prodVolPgg ()->consolidate ();
   myPgg_->  consVolPgg ()->consolidate ();
   myPgg_->  sideVolPgg ()->consolidate ();
   }
d243 24
a266 24
   {
   WitDemTripStack theShipSeq (myProblem ());
   int             theSeqNo;
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;
   WitPipReqSrc *  theReqSrc;
   WitPart *       thePart;

   myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

   theSeqNo = -1;

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      theSeqNo ++;

      theReqSrc = myReqMgr_->newReqSrcForSeqNo (theSeqNo);

      thePart   = theDemand->demandedPart ();

      myReqMgr_->addReq (thePart, shipPer, theReqSrc, incShipVol);
      }
   }
d271 31
a301 31
   {
   WitObjStack <WitPart>          unexpParts (myProblem ());
   WitMapping <WitOperation, int> nUnexpBopEnts;
   WitPart *                      thePart;
   WitBopEntry *                  theBopEnt;
   WitOperation *                 theOpn;

   revCopyInto (unexpParts, myCompMgr ()->allParts ());

   nUnexpBopEnts.allocate (myProblem (), 0);

   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         nUnexpBopEnts (theBopEnt->myOperation ()) ++;

   while (unexpParts.pop (thePart))
      {
      fillPartReqs (thePart);

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         if (theBopEnt->expAllowed ())
            {
            theOpn = theBopEnt->myOperation ();

            nUnexpBopEnts (theOpn) --;

            if (nUnexpBopEnts (theOpn) == 0)
               fillOpnReqs (theOpn);
            }
      }
   }
d306 2
a307 2
   {
   myPartReqMgr_->setUpPartReqs (thePart);
d309 4
a312 4
   if (myGlobalComp ()->newPipPggOrder ())
      pegToAllAttsNpo (thePart);
   else
      pegToAllAttsOpo (thePart);
d314 2
a315 2
   myPartReqMgr_->recordInfeas (thePart);
   }
d320 10
a329 10
   {
   if (thePart->supplyVol () != 0.0)
      pegToAtt (thePart, & WitPipBldr::netWithSupply);

   if (thePart->prodVol () != 0.0)
      pegToAtt (thePart, & WitPipBldr::explodeToProd);

   if (not (sideVol_ (thePart) == 0.0))
      pegToAtt (thePart, & WitPipBldr::netWithSideVol);
   }
d334 27
a360 27
      WitPart *           thePart,
      void (WitPipBldr::* thePegFunc) (WitPart *, WitPeriod))
   {
   WitPeriod thePer;

   for (thePer = lastPeriod (); thePer >= 0; thePer --)
      {
      myPartReqMgr_->mergeCurPartReqsIntoWorkSeq (thePer);

      if (not asapPggOrder (thePart))
         (this->*thePegFunc) (thePart, thePer);

      if (thePer > 0)
         myPartReqMgr_->rollReqsBack (thePer);
      }

   forEachPeriod (thePer, myProblem ())
      {
      if (thePer > 0)
         myPartReqMgr_->rollReqsFwd (thePer);

      if (asapPggOrder (thePart))
         (this->*thePegFunc) (thePart, thePer);

      myPartReqMgr_->restoreUnfilledCurPartReqs (thePer);
      }
   }
d365 2
a366 2
   {
   WitMaterial * theMat;
d368 1
a368 1
   theMat = thePart->thisMat ();
d370 3
a372 3
   if (theMat != NULL)
      if (theMat->asapPipOrder ())
         return true;
d374 2
a375 2
   return false;
   }
d380 2
a381 2
   {
   WitPeriod thePer;
d383 21
a403 21
   for (thePer = lastPeriod (); thePer >= 0; thePer --)
      {
      myPartReqMgr_->mergeCurPartReqsIntoWorkSeq (thePer);

      netWithSupply (thePart, thePer);
      explodeToProd (thePart, thePer);

      if (thePer > 0)
         myPartReqMgr_->rollReqsBack (thePer);
      }

   forEachPeriod (thePer, myProblem ())
      {
      if (thePer > 0)
         myPartReqMgr_->rollReqsFwd (thePer);

      netWithSideVol (thePart, thePer);

      myPartReqMgr_->restoreUnfilledCurPartReqs (thePer);
      }
   }
d408 2
a409 2
   {
   double nonExcSuppVol;
d411 2
a412 2
   if (myPartReqMgr_->workSeqIsEmpty ())
      return;
d414 2
a415 2
   if (myGlobalComp ()->printDebug ())
      myPartReqMgr_->prtWorkReqSeq ("SupplyVol", thePart, thePer);
d417 11
a427 11
   nonExcSuppVol =
        thePart->supplyVol ()[thePer]
      - myProblem ()->myPostprocessor ()->compExcessVol (thePart, thePer);

   pegWorkReqToAtt (
      nonExcSuppVol, 
      myPgg_->supplyVolPgg (),
      thePart,
      thePer,
      NULL);
   }
d432 2
a433 2
   {
   WitBopEntry * theBopEnt;
d435 2
a436 2
   if (myPartReqMgr_->workSeqIsEmpty ())
      return;
d438 2
a439 2
   if (thePart->prodVol ()[thePer] <= 0.0)
      return;
d441 15
a455 15
   if (not thePart->explodeable (thePer))
      return;

   if (myGlobalComp ()->printDebug ())
      myPartReqMgr_->prtWorkReqSeq ("ProdVol", thePart, thePer);

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      if (theBopEnt->expEligible (thePer))
         {
         explodeBopEntry (theBopEnt, thePer);

         if (myPartReqMgr_->workSeqIsEmpty ())
            return;
         }
   }
d460 22
a481 22
   {
   WitPeriod execPerFirst;
   WitPeriod execPerLast;
   WitPeriod execPer;

   witAssert (theBopEnt->expEligible (thePer));

   witAssert (not myPartReqMgr_->workSeqIsEmpty ());

   myExecPerSched_->
      getExecPerRange (theBopEnt, thePer, execPerFirst, execPerLast);

   for (execPer = execPerLast; execPer >= execPerFirst; execPer --)
      if (theBopEnt->execPerOKForExp (execPer))
         if (theBopEnt->impactPeriod ()[execPer] == thePer)
            {
            explodeToExecPer (theBopEnt, execPer);

            if (myPartReqMgr_->workSeqIsEmpty ())
               return;
            }
   }
d486 35
a520 35
   {
   double         theProdVol;
   WitPipReqList  pgdReqList (myProblem ());
   WitPipReqSrc * theReqSrc;
   double         incProdVol;
   double         incExecVol;

   witAssert (not myPartReqMgr_->workSeqIsEmpty ());

   theProdVol =
        theBopEnt->myOperation ()->execVol ()[execPer]
      * theBopEnt->effProdRate ()            [execPer];

   pegWorkReqToAtt (
        theProdVol,
        myPgg_->prodVolPgg (),
        theBopEnt->myPart (),
        theBopEnt->impactPeriod ()[execPer],
      & pgdReqList);

   pgdReqList.reverse ();

   while (pgdReqList.pop (theReqSrc, incProdVol))
      {
      incExecVol = incProdVol / theBopEnt->effProdRate ()[execPer];

      addToIncPegVol (incExecVol, theReqSrc);

      myReqMgr_->addReq (theBopEnt, execPer, theReqSrc, incExecVol);
      }
   
   myPgg_->
      coExecVolPgg ()->
         multiAppend (posDemPers_, theBopEnt, execPer, incPegVol_);
   }
d525 14
a538 14
   {
   if (myPartReqMgr_->workSeqIsEmpty ())
      return;

   if (myGlobalComp ()->printDebug ())
      myPartReqMgr_->prtWorkReqSeq ("SideVol", thePart, thePer);

   pegWorkReqToAtt (
      sideVol_ (thePart)[thePer],
      myPgg_->sideVolPgg (),
      thePart,
      thePer,
      NULL);
   }
d543 28
a570 28
      double                   theAttVol,
      WitPipAttPgg <WitPart> * theAttPgg,
      WitPart *                thePart,
      WitPeriod                thePer,
      WitPipReqList *          pgdReqListPtr)
   {
   double         netAttVol;
   WitPipReqSrc * theReqSrc;
   WitPeriod      fillPer;
   double         incReqVol;
   double         incPegVol;

   witAssert (not myPartReqMgr_->workSeqIsEmpty ());

   netAttVol = theAttVol;

   if (pgdReqListPtr != NULL)
      pgdReqListPtr->clear ();

   while ((not myPartReqMgr_->workSeqIsEmpty ()) and (netAttVol > NET_TOL))
      {
      myPartReqMgr_->getNextReq (netAttVol, theReqSrc, incPegVol);

      addToIncPegVol (incPegVol, theReqSrc);

      if (pgdReqListPtr != NULL)
         pgdReqListPtr->push (theReqSrc, incPegVol);
      }
d572 2
a573 2
   theAttPgg->multiAppend (posDemPers_, thePart, thePer, incPegVol_);
   }
d578 32
a609 32
   {
   WitPeriod      execPer;
   WitPipReqSrc * theReqSrc;
   double         incExecVol;
   WitBomEntry *  theBomEnt;

   for (execPer = lastPeriod (); execPer >= 0; execPer --)
      {
      if (not myReqMgr_->hasReqsFor (theOpn, execPer))
         continue;

      myReqMgr_->loadCurReqList (theOpn, execPer);

      myReqMgr_->initReqListItr ();

      while (not myReqMgr_->finishedReqListItr ())
         {
         myReqMgr_->advanceReqListItr (theReqSrc, incExecVol);

         addToIncPegVol (incExecVol, theReqSrc);
         }

      myPgg_->
         execVolPgg ()->
            multiAppend (posDemPers_, theOpn, execPer, incPegVol_);

      forEachEl (theBomEnt, theOpn->bom ())
         explodeBomEntry (theBomEnt, execPer);

      myReqMgr_->clearCurReqList ();
      }
   }
d614 28
a641 28
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitSubEntry * theSub;

   if (not theBomEnt->inEffect (execPer))
      return;

   pegSubVols (theBomEnt, execPer);

   myReqMgr_->initReqListItr ();

   explodeConsEntry (
      theBomEnt,
      execPer,
      theBomEnt->nonSubVol ()[execPer]);

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      if (myReqMgr_->finishedReqListItr ())
         return;

      explodeConsEntry (
         theSub,
         execPer,
         theSub->subVol ()[execPer]);
      }
   }
d646 45
a690 45
   {
   double         netNonSubVol;
   WitPipReqSrc * theReqSrc;
   double         incNonSubVol;
   WitSubEntry *  theSub;
   double         netSubVol;
   double         incSubVol;

   if (not theBomEnt->hasSubsInEffect ()[execPer])
      return;

   myReqMgr_->initReqListItr ();

   netNonSubVol = theBomEnt->nonSubVol ()[execPer];

   while (netNonSubVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         return;

      myReqMgr_->advanceReqListItr (netNonSubVol, theReqSrc, incNonSubVol);
      }

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      netSubVol = theSub->subVol ()[execPer];

      while (netSubVol > NET_TOL)
         {
         if (myReqMgr_->finishedReqListItr ())
            break;

         myReqMgr_->advanceReqListItr (netSubVol, theReqSrc, incSubVol);

         addToIncPegVol (incSubVol, theReqSrc);
         }

      myPgg_->
         subVolPgg ()->
            multiAppend (posDemPers_, theSub, execPer, incPegVol_);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }
d695 10
a704 10
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         totExecVol)
   {
   WitPart *      consPart;
   WitPeriod      consPer;
   double         netExecVol;
   WitPipReqSrc * theReqSrc;
   double         incExecVol;
   double         incConsVol;
d706 2
a707 2
   if (totExecVol <= NET_TOL)
      return;
d709 1
a709 1
   consPart   = theConsEnt->myPart ();
d711 1
a711 1
   consPer    = theConsEnt->impactPeriod ()[execPer];
d713 1
a713 1
   netExecVol = totExecVol;
d715 4
a718 4
   while (netExecVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;
d720 1
a720 1
      myReqMgr_->advanceReqListItr (netExecVol, theReqSrc, incExecVol);
d722 1
a722 1
      incConsVol = incExecVol * theConsEnt->effConsRate ()[execPer];
d724 2
a725 2
      if (incConsVol <= NET_TOL)
         continue;
d727 1
a727 1
      addToIncPegVol (incConsVol, theReqSrc);
d729 2
a730 2
      myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
      }
d732 4
a735 4
   myPgg_->
      consVolPgg ()->
         multiAppend (posDemPers_, consPart, consPer, incPegVol_);
   }
d740 5
a744 5
   {
   WitPipSeqElItr theItr;
   WitPipSeqEl *  theSeqEl;
   WitDemand *    theDemand;
   WitPeriod      shipPer;
d746 1
a746 1
   witAssert (pegVol > NET_TOL);
d748 1
a748 1
   theReqSrc->attachSeqElItr (theItr);
d750 4
a753 4
   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);
d755 2
a756 2
         if (addedTo_ (theDemand)[shipPer])
            continue;
d758 2
a759 2
         if (incPegVol_ (theDemand)[shipPer] == 0.0)
            posDemPers_.push (theDemand, shipPer);
d761 1
a761 1
         incPegVol_ (theDemand)[shipPer] += pegVol;
d763 2
a764 2
         addedTo_ (theDemand)[shipPer] = true;
         }
d766 1
a766 1
   theReqSrc->attachSeqElItr (theItr);
d768 4
a771 4
   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);
d773 3
a775 3
         addedTo_ (theDemand)[shipPer] = false;
         }
   }
d780 45
a824 45
   {
   WitSchedule <WitOperation, double> totPgdExecVol;
   WitDemand *                        theDemand;
   WitPeriod                          shipPer;
   WitTripStack <WitOperation>        theOpnTrips (myProblem ());
   WitOperation *                     theOpn;
   WitPeriod                          execPer;
   double                             pgdExecVol;
   double                             ratio;
   double                             maxRatio;
   WitOperation *                     maxOpn;
   WitPeriod                          maxExecPer;

   totPgdExecVol.allocate (myProblem (), 0.0);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         myPgg_->
            execVolPgg ()->
               getPegTrips (theDemand, shipPer, theOpnTrips);

         while (theOpnTrips.pop (theOpn, execPer, pgdExecVol))
            totPgdExecVol (theOpn)[execPer] += pgdExecVol;
         }

   maxRatio = 0.0;

   maxOpn   = NULL;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theOpn->execVol ()[execPer] > NET_TOL)
            {
            ratio =
                 totPgdExecVol (theOpn)[execPer]
               / theOpn->execVol ()    [execPer];

            if (ratio > maxRatio)
               {
               maxRatio   = ratio;
               maxOpn     = theOpn;
               maxExecPer = execPer;
               }
            }
d826 2
a827 2
   prtMaxPegRatio (maxRatio, maxOpn, maxExecPer);
   }
d832 43
a874 43
      double         ratio,
      WitOperation * theOpn,
      WitPeriod      execPer)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      pgdExecVol;

   fprintf (msgFile (),
      "Max pegging ratio: %.3f\n",
      ratio);

   if (theOpn == NULL)
      return;

   fprintf (msgFile (),
      "\n"
      "Occurred at:\n"
      "   Operation:     %s\n"
      "   Exec Per:      %d\n"
      "   ExecVol:       %.3f\n\n",
      theOpn->operationName ().myCstring (),
      execPer,
      theOpn->execVol ()[execPer]);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         pgdExecVol =
            myPgg_->
               execVolPgg ()->
                  pegVolFor (theDemand, shipPer, theOpn, execPer);

         if (pgdExecVol > NET_TOL)
            fprintf (msgFile (),
               "      Demand:     %s\n"
               "      ShipPer:    %d\n"
               "      PgdExecVol: %.3f\n\n",
               theDemand->demandName ().myCstring (),
               shipPer,
               pgdExecVol);
         }
   }
@


1.39
log
@Selection reuse.
@
text
@d27 1
a27 1
#include <Opn.h>
@


1.38
log
@Selection reuse.
@
text
@a203 2
   stronglyAssert (selPrintLevelAt (3));

@


1.37
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d117 1
a117 1
   if (myGlobalComp ()->selPrintLevel () >= 3)
d204 1
a204 1
   stronglyAssert (myGlobalComp ()->selPrintLevel () >= 3);
@


1.36
log
@Stochastic Implosion
@
text
@d25 1
a25 1
#include <Global.h>
@


1.35
log
@Stochastic Implosion
@
text
@d51 1
a51 2
      WitProbAssoc    (thePgg->myProblem ()),

@


1.34
log
@ASAP Pegging Order
@
text
@d62 3
a64 3
   myReqMgr_       = new WitPipReqMgr     (myProblem ());
   myPartReqMgr_   = new WitPipPartReqMgr (myReqMgr_);
   myExecPerSched_ = new WitExecPerSched  (myProblem ());
@


1.33
log
@ASAP Pegging Order
@
text
@d82 2
d101 12
@


1.32
log
@ASAP Pegging Order
@
text
@d360 1
a360 1
      if (theMat->asapPip ())
@


1.31
log
@ASAP pegging order
@
text
@d26 1
a26 1
#include <Part.h>
d332 1
a332 1
      if (not myPartReqMgr_->workSeqIsEmpty ())
d344 3
d353 15
d376 2
a377 5
      if (not myPartReqMgr_->workSeqIsEmpty ())
         netWithSupply (thePart, thePer);

      if (not myPartReqMgr_->workSeqIsEmpty ())
         explodeToProd (thePart, thePer);
d388 1
a388 2
      if (not myPartReqMgr_->workSeqIsEmpty ())
         netWithSideVol (thePart, thePer);
d400 3
d424 2
a425 1
   witAssert (not myPartReqMgr_->workSeqIsEmpty ());
d515 3
@


1.30
log
@ASAP Pegging Order
@
text
@d13 1
a13 3
// Contains the implementation of the following classes:
//
//    PipBldr
d17 1
a18 1
#include <PipReqMgr.h>
a24 1
#include <TripStack.h>
d26 1
a26 1
#include <Material.h>
d332 1
a332 1
      if (myPartReqMgr_->hasUnfilledReqs ())
d358 1
a358 1
      if (myPartReqMgr_->hasUnfilledReqs ())
d361 1
a361 1
      if (myPartReqMgr_->hasUnfilledReqs ())
d373 1
a373 1
      if (myPartReqMgr_->hasUnfilledReqs ())
d407 1
a407 1
   witAssert (myPartReqMgr_->hasUnfilledReqs ());
d423 1
a423 1
         if (not myPartReqMgr_->hasUnfilledReqs ())
d438 1
a438 1
   witAssert (myPartReqMgr_->hasUnfilledReqs ());
d449 1
a449 1
            if (not myPartReqMgr_->hasUnfilledReqs ())
d464 1
a464 1
   witAssert (myPartReqMgr_->hasUnfilledReqs ());
d523 1
a523 1
   witAssert (myPartReqMgr_->hasUnfilledReqs ());
d530 1
a530 1
   while (myPartReqMgr_->hasUnfilledReqs () and (netAttVol > NET_TOL))
@


1.29
log
@ASAP Pegging Order
@
text
@d335 1
a335 1
      if (myPartReqMgr_->workReqSeq ().isNonEmpty ())
d361 1
a361 1
      if (myPartReqMgr_->workReqSeq ().isNonEmpty ())
d364 1
a364 1
      if (myPartReqMgr_->workReqSeq ().isNonEmpty ())
d376 1
a376 1
      if (myPartReqMgr_->workReqSeq ().isNonEmpty ())
d410 1
a410 1
   witAssert (myPartReqMgr_->workReqSeq ().isNonEmpty ());
d426 1
a426 1
         if (myPartReqMgr_->workReqSeq ().isEmpty ())
d441 1
a441 1
   witAssert (myPartReqMgr_->workReqSeq ().isNonEmpty ());
d452 1
a452 1
            if (myPartReqMgr_->workReqSeq ().isEmpty ())
d467 1
a467 1
   witAssert (myPartReqMgr_->workReqSeq ().isNonEmpty ());
d526 1
a526 1
   witAssert (myPartReqMgr_->workReqSeq ().isNonEmpty ());
d533 1
a533 1
   while (myPartReqMgr_->workReqSeq ().isNonEmpty () and (netAttVol > NET_TOL))
d535 1
a535 12
      myPartReqMgr_->workReqSeq ().pop (theReqSrc, fillPer, incReqVol);

      incPegVol  = min (incReqVol, netAttVol);
      
      incReqVol -= incPegVol;
      netAttVol -= incPegVol;

      if (incReqVol > NET_TOL)
         myPartReqMgr_->workReqSeq ().push (theReqSrc, fillPer, incReqVol);

      if (myGlobalComp ()->printDebug ())
         myPartReqMgr_->prtPeg (incPegVol, fillPer, theReqSrc);
@


1.28
log
@ASAP Pegging Order
@
text
@d63 1
a63 4
      posDemPers_     (myProblem ()),
      maxInfeas_      (0.0),
      maxInfeasPart_  (NULL),
      maxInfeasPer_   (-1)
d97 1
a97 1
   prtInfeas ();
a233 12
void WitPipBldr::prtInfeas ()
   {
   myMsgFac () ("pipMaxInfeasMsg", maxInfeas_);

   if (maxInfeas_ > 0.0)
      myMsgFac () ("pipMaxInfDataMsg",
         maxInfeasPart_->partName (),
         maxInfeasPer_);
   }

//------------------------------------------------------------------------------

d306 1
a306 1
   recordInfeas (thePart);
a558 32
void WitPipBldr::recordInfeas (WitPart * thePart)
   {
   WitPeriod      thePer;
   double         totReqVol;
   WitPipReqSrc * theReqSrc;
   WitPeriod      fillPer;
   double         incReqVol;

   forEachPeriod (thePer, myProblem ())
      {
      totReqVol = 0.0;

      while (myPartReqMgr_->curPartReqSeq () (thePer).isNonEmpty ())
         {
         myPartReqMgr_->
            curPartReqSeq () (thePer).
               pop (theReqSrc, fillPer, incReqVol);

         totReqVol += incReqVol;
         }

      if (totReqVol > maxInfeas_)
         {
         maxInfeas_     = totReqVol;
         maxInfeasPart_ = thePart;
         maxInfeasPer_  = thePer;
         }
      }
   }

//------------------------------------------------------------------------------

@


1.27
log
@ASAP Pegging Order
@
text
@a104 26
void WitPipBldr::compNonExcStockVol (
      WitMaterial *      theMat,
      WitTVec <double> & nonExcStockVol)
   {
   double    excStockVol;
   WitPeriod thePer;

   excStockVol = 0.0;

   forEachPeriod (thePer, myProblem ())
      {
      excStockVol +=
         myProblem ()->myPostprocessor ()->compExcessVol (theMat, thePer);

      excStockVol -= theMat->scrapVol ()[thePer];

      setToMax (excStockVol, 0.0);

      setToMin (excStockVol, theMat->stockVol ()[thePer]);

      nonExcStockVol[thePer] = theMat->stockVol ()[thePer] - excStockVol;
      }
   }

//------------------------------------------------------------------------------

a115 15
void WitPipBldr::recInfeas (
      WitPart * thePart,
      WitPeriod thePer,
      double    infeasVol)
   {
   if (infeasVol > maxInfeas_)
      {
      maxInfeas_     = infeasVol;
      maxInfeasPart_ = thePart;
      maxInfeasPer_  = thePer;
      }
   }

//------------------------------------------------------------------------------

d314 1
a314 16
   WitMaterial * theMat;

   theMat                      = thePart->thisMat ();

   myPartReqMgr_->curPartHasStock_ = false;

   if (theMat != NULL)
      if (theMat->stockVol () != 0.0)
         myPartReqMgr_->curPartHasStock_ = true;

   if (myPartReqMgr_->curPartHasStock_)
      compNonExcStockVol (theMat, myPartReqMgr_->netStockVol_);
   else
      myPartReqMgr_->netStockVol_ = 0.0;

   myPartReqMgr_->loadCurPartReqSeqs (thePart);
a321 2

   myPartReqMgr_->curPartHasStock_ = false;
d350 1
a350 1
      if (myPartReqMgr_->workReqSeq_.isNonEmpty ())
d376 1
a376 1
      if (myPartReqMgr_->workReqSeq_.isNonEmpty ())
d379 1
a379 1
      if (myPartReqMgr_->workReqSeq_.isNonEmpty ())
d391 1
a391 1
      if (myPartReqMgr_->workReqSeq_.isNonEmpty ())
d425 1
a425 1
   witAssert (myPartReqMgr_->workReqSeq_.isNonEmpty ());
d441 1
a441 1
         if (myPartReqMgr_->workReqSeq_.isEmpty ())
d456 1
a456 1
   witAssert (myPartReqMgr_->workReqSeq_.isNonEmpty ());
d467 1
a467 1
            if (myPartReqMgr_->workReqSeq_.isEmpty ())
d482 1
a482 1
   witAssert (myPartReqMgr_->workReqSeq_.isNonEmpty ());
d541 1
a541 1
   witAssert (myPartReqMgr_->workReqSeq_.isNonEmpty ());
d548 1
a548 1
   while (myPartReqMgr_->workReqSeq_.isNonEmpty () and (netAttVol > NET_TOL))
d550 1
a550 1
      myPartReqMgr_->workReqSeq_.pop (theReqSrc, fillPer, incReqVol);
d558 1
a558 1
         myPartReqMgr_->workReqSeq_.push (theReqSrc, fillPer, incReqVol);
d561 1
a561 1
         myPartReqMgr_->prtPegMat (incPegVol, fillPer, theReqSrc);
d586 1
a586 1
      while (myPartReqMgr_->curPartReqSeq_ (thePer).isNonEmpty ())
d589 1
a589 1
            curPartReqSeq_ (thePer).
d595 6
a600 1
      recInfeas (thePart, thePer, totReqVol);
@


1.26
log
@ASAP Pegging Order
@
text
@d19 1
a19 1
#include <PipMatPgr.h>
d58 1
a58 1
      myMatPgr_       (NULL),
d68 3
a70 3
   myReqMgr_       = new WitPipReqMgr    (myProblem ());
   myMatPgr_       = new WitPipMatPgr    (myReqMgr_);
   myExecPerSched_ = new WitExecPerSched (myProblem ());
d80 1
a80 1
   delete myMatPgr_;
d359 1
a359 1
   myMatPgr_->curPartHasStock_ = false;
d363 1
a363 1
         myMatPgr_->curPartHasStock_ = true;
d365 2
a366 2
   if (myMatPgr_->curPartHasStock_)
      compNonExcStockVol (theMat, myMatPgr_->netStockVol_);
d368 1
a368 1
      myMatPgr_->netStockVol_ = 0.0;
d370 1
a370 1
   myMatPgr_->loadCurPartReqSeqs (thePart);
d379 1
a379 1
   myMatPgr_->curPartHasStock_ = false;
d406 1
a406 1
      myMatPgr_->mergeCurPartReqsIntoWorkSeq (thePer);
d408 1
a408 1
      if (myMatPgr_->workReqSeq_.isNonEmpty ())
d412 1
a412 1
         myMatPgr_->rollReqsBack (thePer);
d418 1
a418 1
         myMatPgr_->rollReqsFwd (thePer);
d420 1
a420 1
      myMatPgr_->restoreUnfilledCurPartReqs (thePer);
d432 1
a432 1
      myMatPgr_->mergeCurPartReqsIntoWorkSeq (thePer);
d434 1
a434 1
      if (myMatPgr_->workReqSeq_.isNonEmpty ())
d437 1
a437 1
      if (myMatPgr_->workReqSeq_.isNonEmpty ())
d441 1
a441 1
         myMatPgr_->rollReqsBack (thePer);
d447 1
a447 1
         myMatPgr_->rollReqsFwd (thePer);
d449 1
a449 1
      if (myMatPgr_->workReqSeq_.isNonEmpty ())
d452 1
a452 1
      myMatPgr_->restoreUnfilledCurPartReqs (thePer);
d463 1
a463 1
      myMatPgr_->prtWorkReqSeq ("SupplyVol", thePart, thePer);
d483 1
a483 1
   witAssert (myMatPgr_->workReqSeq_.isNonEmpty ());
d492 1
a492 1
      myMatPgr_->prtWorkReqSeq ("ProdVol", thePart, thePer);
d499 1
a499 1
         if (myMatPgr_->workReqSeq_.isEmpty ())
d514 1
a514 1
   witAssert (myMatPgr_->workReqSeq_.isNonEmpty ());
d525 1
a525 1
            if (myMatPgr_->workReqSeq_.isEmpty ())
d540 1
a540 1
   witAssert (myMatPgr_->workReqSeq_.isNonEmpty ());
d574 1
a574 1
      myMatPgr_->prtWorkReqSeq ("SideVol", thePart, thePer);
d599 1
a599 1
   witAssert (myMatPgr_->workReqSeq_.isNonEmpty ());
d606 1
a606 1
   while (myMatPgr_->workReqSeq_.isNonEmpty () and (netAttVol > NET_TOL))
d608 1
a608 1
      myMatPgr_->workReqSeq_.pop (theReqSrc, fillPer, incReqVol);
d616 1
a616 1
         myMatPgr_->workReqSeq_.push (theReqSrc, fillPer, incReqVol);
d619 1
a619 1
         myMatPgr_->prtPegMat (incPegVol, fillPer, theReqSrc);
d644 1
a644 1
      while (myMatPgr_->curPartReqSeq_ (thePer).isNonEmpty ())
d646 3
a648 1
         myMatPgr_->curPartReqSeq_ (thePer).pop (theReqSrc, fillPer, incReqVol);
@


1.25
log
@ASAP Pegging Order
@
text
@d69 1
a69 1
   myMatPgr_       = new WitPipMatPgr (this);
d377 1
a377 1
   myMatPgr_->recordInfeas (thePart);
d632 25
@


1.24
log
@ASAP Pegging Order
@
text
@d336 1
a336 1
      myMatPgr_->fillReqs (thePart);
d353 279
@


1.23
log
@ASAP Pegging Order
@
text
@a63 1
      nonExcStockVol_ (myProblem (), 0.0),
a352 274
void WitPipBldr::fillPartReqsOpo (WitPart * thePart)
   {
   WitMaterial * theMat;
   WitPeriod     fillPer;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      compNonExcStockVol (theMat, nonExcStockVol_);

   for (fillPer = lastPeriod (); fillPer >= 0; fillPer --)
      if (myReqMgr_->hasReqsFor (thePart, fillPer))
         {
         if (myGlobalComp ()->printDebug ())
            prtFillReqs (thePart, fillPer);

         myReqMgr_->loadCurReqList (thePart, fillPer);

         fillCurReqs (thePart, fillPer);

         myReqMgr_->clearCurReqList ();
         }
   }

//------------------------------------------------------------------------------

void WitPipBldr::fillCurReqs (WitPart * thePart, WitPeriod fillPer)
   {
   myReqMgr_->initReqListItr ();

   netWithSupply (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   explodeToProd (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   explodeToStock (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   netWithSideVol (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   recordInfeas (thePart, fillPer);
   }

//------------------------------------------------------------------------------

void WitPipBldr::netWithSupply (WitPart * thePart, WitPeriod fillPer)
   {
   double         netSuppVol;
   WitPipReqSrc * theReqSrc;
   double         incSuppVol;

   witAssert (not myReqMgr_->finishedReqListItr ());

   netSuppVol =
        thePart->supplyVol ()[fillPer]
      - myProblem ()->myPostprocessor ()->compExcessVol (thePart, fillPer);

   while (netSuppVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netSuppVol, theReqSrc, incSuppVol);

      if (myGlobalComp ()->printDebug ())
         prtNetToSupply (thePart, fillPer, incSuppVol, theReqSrc);

      addToIncPegVol (incSuppVol, theReqSrc);
      }

   myPgg_->
      supplyVolPgg ()->
         multiAppend (posDemPers_, thePart, fillPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeToProd (WitPart * thePart, WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;

   witAssert (not myReqMgr_->finishedReqListItr ());

   if (thePart->prodVol ()[fillPer] <= 0.0)
      return;

   if (not thePart->explodeable (fillPer))
      return;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      {
      if (not theBopEnt->expEligible (fillPer))
         continue;

      explodeBopEntry (theBopEnt, fillPer);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeBopEntry (
      WitBopEntry * theBopEnt,
      WitPeriod     fillPer)
   {
   WitPeriod execPerFirst;
   WitPeriod execPerLast;
   WitPeriod execPer;

   witAssert (theBopEnt->expEligible (fillPer));

   witAssert (not myReqMgr_->finishedReqListItr ());

   myExecPerSched_->
      getExecPerRange (theBopEnt, fillPer, execPerFirst, execPerLast);

   for (execPer = execPerLast; execPer >= execPerFirst; execPer --)
      {
      if (not theBopEnt->execPerOKForExp (execPer))
         continue;

      if (theBopEnt->impactPeriod ()[execPer] != fillPer)
         continue;

      explodeToExecPer (theBopEnt, execPer);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeToExecPer (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer)
   {
   WitPart *      thePart;
   WitPeriod      prodPer;
   double         netProdVol;
   WitPipReqSrc * theReqSrc;
   double         incProdVol;
   WitPipReqList  theReqList (myProblem ());
   double         incExecVol;

   thePart    = theBopEnt->myPart ();
   prodPer    = theBopEnt->impactPeriod ()[execPer];

   netProdVol =
        theBopEnt->myOperation ()->execVol ()[execPer]
      * theBopEnt->effProdRate ()            [execPer];

   while (netProdVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netProdVol, theReqSrc, incProdVol);

      addToIncPegVol (incProdVol, theReqSrc);

      incExecVol = incProdVol / theBopEnt->effProdRate ()[execPer];

      myReqMgr_->addReq (theBopEnt, execPer, theReqSrc, incExecVol);

      theReqList.push (theReqSrc, incExecVol);
      }

   myPgg_->
      prodVolPgg ()->
         multiAppend (posDemPers_, thePart, prodPer, incPegVol_);

   while (theReqList.pop (theReqSrc, incExecVol))
      addToIncPegVol (incExecVol, theReqSrc);

   myPgg_->
      coExecVolPgg ()->
         multiAppend (posDemPers_, theBopEnt, execPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitPipBldr::explodeToStock (WitPart * thePart, WitPeriod fillPer)
   {
   WitMaterial *  theMat;
   WitPeriod      stockPer;
   double         netStockVol;
   WitPipReqSrc * theReqSrc;
   double         incStockVol;

   witAssert (not myReqMgr_->finishedReqListItr ());

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return;

   if (fillPer == 0)
      return;

   stockPer    = fillPer - 1;

   netStockVol = nonExcStockVol_[stockPer];

   while (netStockVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netStockVol, theReqSrc, incStockVol);

      myReqMgr_->addReq (theMat, stockPer, theReqSrc, incStockVol);
      }
   }

//------------------------------------------------------------------------------

void WitPipBldr::netWithSideVol (WitPart * thePart, WitPeriod fillPer)
   {
   double         netSideVol;
   WitPipReqSrc * theReqSrc;
   double         incSideVol;

   netSideVol = sideVol_ (thePart)[fillPer];

   while (netSideVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netSideVol, theReqSrc, incSideVol);

      addToIncPegVol (incSideVol, theReqSrc);
      }

   myPgg_->
      sideVolPgg ()->
         multiAppend (posDemPers_, thePart, fillPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitPipBldr::recordInfeas (WitPart * thePart, WitPeriod thePer)
   {
   double         infeasVol;
   WitPipReqSrc * theReqSrc;
   double         incReqVol;

   infeasVol = 0.0;

   while (not myReqMgr_->finishedReqListItr ())
      {
      myReqMgr_->advanceReqListItr (theReqSrc, incReqVol);

      infeasVol += incReqVol;
      }

   recInfeas (thePart, thePer, infeasVol);
   }

//------------------------------------------------------------------------------

a606 36
void WitPipBldr::prtFillReqs (WitPart * thePart, WitPeriod fillPer)
   {
   witAssert (myGlobalComp ()->printDebug ());

   fprintf (msgFile (),
      "\n"
      "Filling requirements for Part %s in Period %d:\n",
      thePart->partName ().myCstring (),
      fillPer);
   }

//------------------------------------------------------------------------------

void WitPipBldr::prtNetToSupply (
      WitPart *      thePart,
      WitPeriod      thePer,
      double         incSuppVol,
      WitPipReqSrc * theReqSrc)
   {
   witAssert (myGlobalComp ()->printDebug ());

   fprintf (msgFile (),
      "\n"
      "Netting Against Supply:\n"
      "   Part:        %s\n"
      "   Period:      %d\n"
      "   Inc SuppVol: %.0f\n",
      thePart->partName ().myCstring (),
      thePer,
      incSuppVol);

   theReqSrc->print (msgFile (), "   ");
   }

//------------------------------------------------------------------------------

@


1.22
log
@ASAP Pegging Order
@
text
@d69 2
a71 4
   myReqMgr_       = new WitPipReqMgr    (myProblem ());

   if (myGlobalComp ()->newPipPggOrder ())
      myMatPgr_ = new WitPipMatPgr (this);
d80 1
a82 1
   delete myExecPerSched_;
d337 1
a337 4
      if (myGlobalComp ()->newPipPggOrder ())
         myMatPgr_->fillReqs (thePart);
      else
         fillPartReqsOpo (thePart);
@


1.21
log
@ASAP Pegging Order
@
text
@d364 1
a364 3
   if (not myGlobalComp ()->newPipPggOrder ())
      {
      theMat = thePart->thisMat ();
d366 2
a367 3
      if (theMat != NULL)
         compNonExcStockVol (theMat, nonExcStockVol_);
      }
d399 1
a399 3
   if (not myGlobalComp ()->newPipPggOrder ())
      {
      explodeToStock (thePart, fillPer);
d401 2
a402 3
      if (myReqMgr_->finishedReqListItr ())
         return;
      }
@


1.20
log
@ASAP Pegging Order
@
text
@a325 1
   WitMaterial *                  theMat;
d339 3
a341 4
      if (not myGlobalComp ()->newPipPggOrder ())
         fillPartReqsOpo (thePart);

      else if (nPeriods () == 1)
a343 14
      else
         {
         theMat = thePart->thisMat ();

         if (theMat == NULL)
            fillPartReqsOpo (thePart);

         else if (theMat->stockVol () == 0.0)
            fillPartReqsOpo (thePart);

         else
            myMatPgr_->fillReqs (theMat);
         }

@


1.19
log
@ASAP Pegging Order
@
text
@d54 1
a54 1
      WitProbAssoc       (thePgg->myProblem ()),
d56 12
a67 16
      myPgg_             (thePgg),
      myReqMgr_          (NULL),
      myMatPgr_          (NULL),
      myExecPerSched_    (NULL),
      sideVol_           (myProblem (), 0.0),
      addedTo_           (myProblem (), false),
      incPegVol_         (myProblem (), 0.0),
      posDemPers_        (myProblem ()),
      nonExcStockVol_    (myProblem (), 0.0),
      npoNetStockVol_    (myProblem (), 0.0),
      pggStMatNpo_       (false),
      maxInfeas_         (0.0),
      maxInfeasPart_     (NULL),
      maxInfeasPer_      (-1),
      npoMaxUnmatchVol_  (0.0),
      npoMaxUnmatchPart_ (NULL)
a159 11
void WitPipBldr::recUnmatched (WitPart * thePart, double unmatchVol)
   {
   if (unmatchVol > npoMaxUnmatchVol_)
      {
      npoMaxUnmatchVol_  = unmatchVol;
      npoMaxUnmatchPart_ = thePart;
      }
   }

//------------------------------------------------------------------------------

a288 10

   if (DEVELOPMENT)
      if (myGlobalComp ()->newPipPggOrder ())
         {
         myMsgFac () ("pipNpoMaxUnmatchMsg", npoMaxUnmatchVol_);

         if (npoMaxUnmatchVol_ > 0.0)
            myMsgFac () ("pipNpoMaxUnmatchDataMsg",
               npoMaxUnmatchPart_->partName ());
         }
d357 1
a357 1
            myMatPgr ()->fillReqs (theMat);
a458 3

      if (pggStMatNpo_)
         myReqMgr_->recPegMatPerNpo (fillPer, incSuppVol, theReqSrc);
a553 3
      if (pggStMatNpo_)
         myReqMgr_->recPegMatPerNpo (prodPer, incProdVol, theReqSrc);

a625 3

      if (pggStMatNpo_)
         myReqMgr_->recPegMatPerNpo (fillPer, incSideVol, theReqSrc);
a908 56
void WitPipBldr::fillStMatReqsNpo (WitMaterial * theMat)
   {
   WitPeriod reqPer;
   double    totReqVol;

   pggStMatNpo_ = true;

   compNonExcStockVol (theMat, npoNetStockVol_);

   myReqMgr_->npoSortReqLists (theMat);

   if (theMat->supplyVol () != 0.0)
      pegToAttNpo (& WitPipBldr::netWithSupply,  theMat);

   if (theMat->prodVol () != 0.0)
      pegToAttNpo (& WitPipBldr::explodeToProd,  theMat);

   if (not (sideVol_ (theMat) == 0.0))
      pegToAttNpo (& WitPipBldr::netWithSideVol, theMat);

   forEachPeriod (reqPer, myProblem ())
      {
      myReqMgr_->npoClearReqs (theMat, reqPer, totReqVol);

      recInfeas (theMat, reqPer, totReqVol);
      }

   pggStMatNpo_ = false;
   }

//------------------------------------------------------------------------------

void WitPipBldr::pegToAttNpo (
      void (WitPipBldr::* thePegFunc) (WitPart *, WitPeriod),
      WitMaterial *        theMat)
   {
   WitPeriod pegPer;
   double    unmatchVol;

   for (pegPer = lastPeriod (); pegPer >= 0; pegPer --)
      {
      myReqMgr_->prepPegMatPerNpo (theMat, pegPer, npoNetStockVol_[pegPer]);

      if (not myReqMgr_->finishedReqListItr ())
         (this->*thePegFunc) (theMat, pegPer);

      myReqMgr_->postPegMatPerNpo ();
      }

   myReqMgr_->postPegMatNpo (theMat, npoNetStockVol_, unmatchVol);

   recUnmatched (theMat, unmatchVol);
   }

//------------------------------------------------------------------------------

@


1.18
log
@ASAP Pegging Order
@
text
@d77 1
a77 2
      if (myGlobalComp ()->useNewMatPgg ())
         myMatPgr_ = new WitPipMatPgr (this);
d381 1
a381 1
         else if (myGlobalComp ()->useNewMatPgg ())
a382 3

         else
            fillStMatReqsNpo (theMat);
@


1.17
log
@ASAP Pegging Order.
@
text
@d76 3
a78 2
   if (myGlobalComp ()->useNewMatPgg ())
      myMatPgr_ = new WitPipMatPgr (this);
@


1.16
log
@ASAP Pegging Order
@
text
@a51 26
void WitPipBldr::compNonExcStockVol (
      WitMaterial *      theMat,
      WitTVec <double> & nonExcStockVol)
   {
   double    excStockVol;
   WitPeriod thePer;

   excStockVol = 0.0;

   forEachPeriod (thePer, myProblem ())
      {
      excStockVol +=
         myProblem ()->myPostprocessor ()->compExcessVol (theMat, thePer);

      excStockVol -= theMat->scrapVol ()[thePer];

      setToMax (excStockVol, 0.0);

      setToMin (excStockVol, theMat->stockVol ()[thePer]);

      nonExcStockVol[thePer] = theMat->stockVol ()[thePer] - excStockVol;
      }
   }

//------------------------------------------------------------------------------

d112 26
@


1.15
log
@NSTN residualVols
@
text
@d19 1
d43 35
a82 1
      pggBuilt_          (false),
d84 1
d102 3
d112 1
a120 2
   stronglyAssert (not pggBuilt_);

a133 28

   pggBuilt_ = true;
   }

//------------------------------------------------------------------------------

void WitPipBldr::compNonExcStockVol (
      WitMaterial *      theMat,
      WitTVec <double> & nonExcStockVol)
   {
   double    excStockVol;
   WitPeriod thePer;

   excStockVol = 0.0;

   forEachPeriod (thePer, myProblem ())
      {
      excStockVol +=
         myProblem ()->myPostprocessor ()->compExcessVol (theMat, thePer);

      excStockVol -= theMat->scrapVol ()[thePer];

      setToMax (excStockVol, 0.0);

      setToMin (excStockVol, theMat->stockVol ()[thePer]);

      nonExcStockVol[thePer] = theMat->stockVol ()[thePer] - excStockVol;
      }
d381 3
@


1.14
log
@ExecVol pegging for BOP entries.
@
text
@d34 1
a101 10
double WitPipBldr::compExcessVol (WitPart * thePart, WitPeriod thePer)
   {
   return
      min (
         positivePart (thePart->residualVol ()[thePer]),
         thePart->supplyVol ()[thePer]);
   }

//------------------------------------------------------------------------------

d113 2
a114 1
      excStockVol += compExcessVol (theMat, thePer);
d460 2
a461 1
      thePart->supplyVol ()[fillPer] - compExcessVol (thePart, fillPer);
@


1.13
log
@execVol pegging for BOP entries.
@
text
@d597 1
a597 1
      coexVolPgg ()->
@


1.12
log
@GPIP migration.
@
text
@d560 1
d585 2
d592 7
@


1.11
log
@GPIP migration.
@
text
@a61 2
   myMsgFac () ("gpipMsg");

d89 1
a89 1
   if (myGlobalComp ()->prtGpipMaxRatio ())
@


1.10
log
@GPIP migration.
@
text
@d19 3
a21 3
#include <GpipReqMgr.h>
#include <GpipReqSrc.h>
#include <GpipSeqEl.h>
d65 1
a65 1
   myReqMgr_       = new WitGpipReqMgr   (myProblem ());
d325 1
a325 1
   WitGpipReqSrc * theReqSrc;
d463 3
a465 3
   double          netSuppVol;
   WitGpipReqSrc * theReqSrc;
   double          incSuppVol;
d557 6
a562 6
   WitPart *       thePart;
   WitPeriod       prodPer;
   double          netProdVol;
   WitGpipReqSrc * theReqSrc;
   double          incProdVol;
   double          incExecVol;
d597 5
a601 5
   WitMaterial *   theMat;
   WitPeriod       stockPer;
   double          netStockVol;
   WitGpipReqSrc * theReqSrc;
   double          incStockVol;
d632 3
a634 3
   double          netSideVol;
   WitGpipReqSrc * theReqSrc;
   double          incSideVol;
d660 3
a662 3
   double          infeasVol;
   WitGpipReqSrc * theReqSrc;
   double          incReqVol;
d680 4
a683 4
   WitPeriod       execPer;
   WitGpipReqSrc * theReqSrc;
   double          incExecVol;
   WitBomEntry *   theBomEnt;
d748 6
a753 6
   double          netNonSubVol;
   WitGpipReqSrc * theReqSrc;
   double          incNonSubVol;
   WitSubEntry *   theSub;
   double          netSubVol;
   double          incSubVol;
d800 6
a805 6
   WitPart *       consPart;
   WitPeriod       consPer;
   double          netExecVol;
   WitGpipReqSrc * theReqSrc;
   double          incExecVol;
   double          incConsVol;
d840 1
a840 1
void WitPipBldr::addToIncPegVol (double pegVol, WitGpipReqSrc * theReqSrc)
d842 4
a845 4
   WitGpipSeqElItr theItr;
   WitGpipSeqEl *  theSeqEl;
   WitDemand *     theDemand;
   WitPeriod       shipPer;
d1002 4
a1005 4
      WitPart *       thePart,
      WitPeriod       thePer,
      double          incSuppVol,
      WitGpipReqSrc * theReqSrc)
@


1.9
log
@[shared-resource pegging]
@
text
@d13 3
a15 1
// Contains the implementation of class PipBldr.
d19 9
a27 6
#include <PipSeqMgr.h>
#include <UrpCoord.h>
#include <PipTarg.h>
#include <PipPegList.h>
#include <ReqSched.h>
#include <Demand.h>
a28 1
#include <Capacity.h>
d33 2
a34 2
#include <Global.h>
#include <Dense.h>
d41 3
a43 1
WitPipBldr::WitPipBldr (WitUrpCoord * theUrpCoord):
d45 18
a62 1
      WitProbAssoc    (theUrpCoord->myProblem ()),
d64 4
a67 22
      myUrpCoord_     (theUrpCoord),
      curTarg_        (NULL),
      expExecPers_    (myProblem ()),
      normShare_      (),

      unpgdCoexVol_   (myProblem (), 0.0),
      unpgdNonSubVol_ (myProblem (), 0.0),
      unpgdSubVol_    (myProblem (), 0.0),
      unpgdStockVol_  (myProblem (), 0.0),
      unpgdSupplyVol_ (myProblem (), 0.0),
      unpgdSideVol_   (myProblem (), 0.0),

      maxInfeas_      (0.0),
      maxInfeasTarg_  (NULL),
      maxInfeasPart_  (NULL),
      maxInfeasPer_   (-1)
   {              
   myReqSched_ = new WitReqSched (myProblem ());

   workOpnSched_ .allocate1D (myProblem ());
   workSubSched_ .allocate1D (myProblem ());
   workPartSched_.allocate1D (myProblem ());
d74 2
a75 8
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (expPer, myProblem ())
         delete expExecPers_.myPtrAt (theBopEnt, expPer);

   delete myReqSched_;
d82 1
a82 4
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;
d84 1
a84 1
   initUnpeggedScheds ();
d86 1
a86 1
   findExecPers ();
d88 2
a89 1
   myUrpCoord_->myPipSeqMgr ()->get (theShipSeq);
d91 2
a92 3
   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      curTarg_ = myUrpCoord_->myTargFor (theDemand, shipPer);
d94 1
a94 1
      pegShipment (incShipVol);
d96 1
a96 2
      consolidatePegLists ();
      }
d98 2
a99 1
   curTarg_ = NULL;
d101 8
a108 1
   prtInfeas ();
d113 3
a115 1
void WitPipBldr::initUnpeggedScheds ()
d117 2
a118 9
   WitBopEntry * theBopEnt;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitMaterial * theMat;
   WitPart *     thePart;
   WitPeriod     execPer;
   WitPeriod     thePer;

   normShare_.allocate (myProblem (), 0.0);
d120 1
a120 1
   normalizeShares ();
d122 1
a122 1
   forEachBopEntry (theBopEnt, myProblem ())
d124 1
a124 8
      unpgdCoexVol_ (theBopEnt) = 0.0;

      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->execPerOKForExp (execPer))
               unpgdCoexVol_ (theBopEnt)[execPer] =
                  theBopEnt->myOperation ()->execVol ()[execPer];
      }
d126 1
a126 2
   forEachBomEntry (theBomEnt, myProblem ())
      unpgdNonSubVol_ (theBomEnt) = theBomEnt->nonSubVol ();
d128 1
a128 2
   forEachSubEntry (theSub, myProblem ())
      unpgdSubVol_ (theSub) = theSub->subVol ();
d130 1
a130 2
   forEachMaterial (theMat, myProblem ())
      unpgdStockVol_ (theMat) = theMat->stockVol ();
d132 2
a133 8
   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         unpgdSupplyVol_ (thePart)[thePer] =
            positivePart (
                 thePart->supplyVol   ()[thePer]
               - thePart->residualVol ()[thePer]);

   compSideVols ();
d138 1
a138 1
void WitPipBldr::normalizeShares ()
d140 2
a141 24
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;
   WitPeriod      execPer;
   double         totShare;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         totShare = 0.0;

         forEachEl (theBopEnt, theOpn->bop ())
            if (theBopEnt->expAllowed ())
               if (theBopEnt->execPerOKForExp (execPer))
                  totShare += theBopEnt->pipShare ()[execPer];

         if (totShare == 0.0)
            continue;

         forEachEl (theBopEnt, theOpn->bop ())
            if (theBopEnt->expAllowed ())
               if (theBopEnt->execPerOKForExp (execPer))
                  normShare_ (theBopEnt)[execPer] =
                     theBopEnt->pipShare ()[execPer] / totShare;
         }
d144 1
a144 1
      prtNormShares ();
d149 4
a152 1
void WitPipBldr::prtNormShares ()
d154 6
a159 18
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   fprintf (msgFile (),
      "\n"
      "Normalized PIP Shares:\n"
      "\n"
      "   Opn  BopEnt  Part  ExecPer  Share\n");

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         fprintf (msgFile (),
            "   %3s  %6d  %4s  %7d  %5.3f\n",
            theBopEnt->myOperationName ().myCstring (),
            theBopEnt->localIndex (),
            theBopEnt->myPartName ().myCstring (),
            execPer,
            normShare_ (theBopEnt)[execPer]);
d164 1
a164 1
void WitPipBldr::compSideVols ()
d166 5
a170 5
   compBopSideVols ();
   compBomSideVols ();

   if (myGlobalComp ()->selPrintLevel () >= 3)
      prtSideVols ();
d175 1
a175 1
void WitPipBldr::compBopSideVols ()
d203 1
a203 1
         unpgdSideVol_ (thePart)[prodPer] +=
d211 1
a211 1
void WitPipBldr::compBomSideVols ()
d243 1
a243 1
         unpgdSideVol_ (thePart)[consPer] -= incConsVol;
d249 2
a250 1
void WitPipBldr::prtSideVols ()
d267 1
a267 1
         sideVolVal = unpgdSideVol_ (thePart)[thePer];
d284 35
a318 1
void WitPipBldr::findExecPers ()
d320 9
a328 4
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   WitPeriod     expPer;
   WitTVec <int> nExecPers;
d330 1
a330 1
   nExecPers.allocate (myProblem (), 0);
d332 1
a332 1
   forEachBopEntry (theBopEnt, myProblem ())
d334 9
a342 2
      if (not theBopEnt->expAllowed ())
         continue;
d344 1
a344 1
      nExecPers = 0;
d346 8
a353 4
      forEachPeriod (execPer, myProblem ())
         {
         if (not theBopEnt->execPerOKForExp (execPer))
            continue;
d355 1
a355 1
         expPer = theBopEnt->impactPeriod ()[execPer];
d357 1
a357 2
         nExecPers[expPer] ++;
         }
d359 3
a361 4
      forEachPeriod (expPer, myProblem ())
         {
         if (nExecPers[expPer] < 2)
            continue;
d363 4
a366 3
         expExecPers_.myPtrAt (theBopEnt, expPer) =
            new WitVector <WitPeriod> (nExecPers[expPer], -1);
         }
d368 2
a369 1
      nExecPers = 0;
d371 1
a371 1
      for (execPer = lastPeriod (); execPer >= 0; execPer --)
d373 7
a379 2
         if (not theBopEnt->execPerOKForExp (execPer))
            continue;
d381 3
a383 1
         expPer = theBopEnt->impactPeriod ()[execPer];
d385 4
a388 2
         if (expExecPers_.myPtrAt (theBopEnt, expPer) == NULL)
            continue;
d390 1
a390 1
         expExecPers_.myElemAt (theBopEnt, expPer)[nExecPers[expPer]] = execPer;
d392 3
a394 2
         nExecPers[expPer] ++;
         }
d400 1
a400 1
void WitPipBldr::pegShipment (double incShipVol)
d402 2
a403 4
   WitPart * topPart;
   WitPeriod shipPer;
   WitPart * thePart;
   WitPeriod pegPer;
d405 3
a407 1
   witAssert (incShipVol > 0.0);
d409 3
a411 1
   topPart = curTarg_->myDemand ()->demandedPart ();
d413 5
a417 1
   shipPer = curTarg_->myShipPer ();
d419 1
a419 1
   myReqSched_->addTo (topPart, shipPer, incShipVol);
d421 1
a421 5
   forEachElDense (thePart, topPart->belowList ())
      for (pegPer =  myReqSched_->lastPer  (thePart); 
           pegPer >= myReqSched_->firstPer (thePart);
           pegPer --)
         pegPart (thePart, pegPer);
d423 2
a424 1
   myReqSched_->clear ();
d429 1
a429 1
void WitPipBldr::pegPart (WitPart * thePart, WitPeriod pegPer)
d431 1
a431 1
   double netReqVol;
d433 1
a433 1
   netReqVol = myReqSched_->reqVol (thePart, pegPer);
d435 1
a435 1
   if (netReqVol <= 0.0)
d438 1
a438 1
   pegToSupply (thePart, pegPer, netReqVol);
d440 1
a440 1
   if (netReqVol <= 0.0)
d443 9
a451 1
   pegToProd (thePart, pegPer, netReqVol);
d453 1
a453 1
   if (netReqVol <= 0.0)
d456 4
a459 1
   pegToStock (thePart, pegPer, netReqVol);
d461 5
a465 2
   if (netReqVol <= 0.0)
      return;
d467 1
a467 1
   pegToSide (thePart, pegPer, netReqVol);
d469 2
a470 2
   if (netReqVol <= 0.0)
      return;
d472 1
a472 1
   if (netReqVol > maxInfeas_)
d474 12
a485 4
      maxInfeas_     = netReqVol;
      maxInfeasTarg_ = curTarg_;
      maxInfeasPart_ = thePart;
      maxInfeasPer_  = pegPer;
d487 4
d495 1
a495 4
void WitPipBldr::pegToStock (
      WitPart * thePart,
      WitPeriod pegPer,
      double &  netReqVol)
d497 1
a497 2
   WitMaterial * theMat;
   double        pegVol;
d499 1
a499 1
   witAssert (netReqVol > 0.0);
d501 1
a501 3
   theMat = thePart->thisMat ();

   if (theMat == NULL)
d504 1
a504 1
   if (pegPer == 0)
d507 4
a510 2
   if (unpgdStockVol_ (theMat)[pegPer - 1] <= 0.0)
      return;
d512 1
a512 1
   pegVol = minAndNet (netReqVol, unpgdStockVol_ (theMat)[pegPer - 1]);
d514 3
a516 1
   myReqSched_->addTo (theMat, pegPer - 1, pegVol);
d521 3
a523 4
void WitPipBldr::pegToSupply (
      WitPart * thePart,
      WitPeriod pegPer,
      double &  netReqVol)
d525 7
a531 1
   double pegVol;
d533 2
a534 1
   witAssert (netReqVol > 0.0);
d536 9
a544 2
   if (unpgdSupplyVol_ (thePart)[pegPer] <= 0.0)
      return;
d546 3
a548 5
   pegVol = minAndNet (netReqVol, unpgdSupplyVol_ (thePart)[pegPer]);
   
   curTarg_->
      myPartPegList ()[WitPipPartAtt::supplyVol]->
         append (thePart, pegPer, pegVol);
d553 3
a555 4
void WitPipBldr::pegToSide (
      WitPart * thePart,
      WitPeriod pegPer,
      double &  netReqVol)
d557 20
a576 1
   double pegVol;
d578 1
a578 1
   witAssert (netReqVol > 0.0);
d580 7
a586 2
   if (unpgdSideVol_ (thePart)[pegPer] <= 0.0)
      return;
d588 3
a590 5
   pegVol = minAndNet (netReqVol, unpgdSideVol_ (thePart)[pegPer]);
   
   curTarg_->
      myPartPegList ()[WitPipPartAtt::sideVol]->
         append (thePart, pegPer, pegVol);
d595 1
a595 4
void WitPipBldr::pegToProd (
      WitPart * thePart,
      WitPeriod expPer,
      double &  netReqVol)
d597 7
a603 4
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   int           nExecPers;
   int           theIdx;
d605 1
a605 1
   witAssert (netReqVol > 0.0);
d607 1
a607 1
   if (thePart->prodVol ()[expPer] <= 0.0)
d610 1
a610 1
   if (not thePart->explodeable (expPer))
d613 26
a638 1
   forEachEl (theBopEnt, thePart->producingBopEntries ())
d640 10
a649 2
      if (not theBopEnt->expEligible (expPer))
         continue;
d651 4
a654 3
      if (expExecPers_.myPtrAt (theBopEnt, expPer) == NULL)
         {
         execPer = theBopEnt->expExecPeriod ()[expPer];
d656 1
a656 1
         pegBopEnt (theBopEnt, execPer, netReqVol);
d658 5
a662 6
         if (netReqVol <= 0.0)
            return;
         }
      else
         {
         nExecPers = expExecPers_.myElemAt (theBopEnt, expPer).length ();
d664 1
a664 3
         for (theIdx = 0; theIdx < nExecPers; theIdx ++)
            {
            execPer = expExecPers_.myElemAt (theBopEnt, expPer)[theIdx];
d666 3
a668 1
            pegBopEnt (theBopEnt, execPer, netReqVol);
d670 1
a670 4
            if (netReqVol <= 0.0)
               return;
            }
         }
d672 2
d678 1
a678 4
void WitPipBldr::pegBopEnt (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double &      netReqVol)
d680 4
a683 9
   double         upCoexVolVal;
   double         theProdRate;
   double         reqCoexVol;
   double         pgdCoexVol;
   double         pgdProdVol;
   WitPart *      thePart;
   WitPeriod      prodPer;
   WitOperation * theOpn;
   double         pgdExecVol;
d685 4
a688 1
   witAssert (netReqVol > 0.0);
d690 1
a690 1
   upCoexVolVal = unpgdCoexVol_ (theBopEnt)[execPer];
d692 1
a692 2
   if (upCoexVolVal <= 0.0)
      return;
d694 3
a696 1
   theProdRate  = theBopEnt->effProdRate ()[execPer];
d698 2
a699 1
   reqCoexVol   = netReqVol / theProdRate;
d701 3
a703 1
   pgdCoexVol   = min (reqCoexVol, upCoexVolVal);
d705 2
a706 1
   unpgdCoexVol_ (theBopEnt)[execPer] -= pgdCoexVol;
d708 3
a710 1
   pgdProdVol   = pgdCoexVol * theProdRate;
d712 1
a712 1
   netReqVol   -= pgdProdVol;
d714 5
a718 1
   setToMax (netReqVol, 0.0);
d720 2
a721 1
   thePart      = theBopEnt->myPart ();
d723 1
a723 1
   prodPer      = theBopEnt->impactPeriod ()[execPer];
d725 1
a725 3
   curTarg_->
      myPartPegList ()[WitPipPartAtt::prodVol]->
         append (thePart, prodPer, pgdProdVol);
d727 4
a730 1
   theOpn       = theBopEnt->myOperation ();
d732 4
a735 1
   pgdExecVol   = pgdCoexVol * normShare_ (theBopEnt)[execPer];
d737 5
a741 1
   pegOpn (theOpn, execPer, pgdExecVol);
d746 1
a746 4
void WitPipBldr::pegOpn (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         pgdExecVol)
d748 6
a753 1
   WitBomEntry * theBomEnt;
d755 1
a755 1
   if (pgdExecVol == 0.0)
d758 1
a758 1
   witAssert (pgdExecVol > 0.0);
d760 1
a760 1
   curTarg_->execVolPegList ()->append (theOpn, execPer, pgdExecVol);
d762 13
a774 2
   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->inEffect (execPer))
d776 6
a781 4
         if (theBomEnt->hasSubsInEffect ()[execPer])
            pegBomEntWithSubs (theBomEnt, execPer, pgdExecVol);
         else
            pegConsEnt        (theBomEnt, execPer, pgdExecVol);
d783 8
d795 4
a798 4
void WitPipBldr::pegBomEntWithSubs (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        pgdExecVol)
d800 9
a808 4
   double        netExecVol;
   double        pgdNonSubVol;
   WitSubEntry * theSub;
   double        pgdSubVol;
d810 1
a810 2
   witAssert (pgdExecVol > 0.0);
   witAssert (theBomEnt->hasSubsInEffect ()[execPer]);
d812 1
a812 1
   netExecVol = pgdExecVol;
d814 3
a816 1
   if (unpgdNonSubVol_ (theBomEnt)[execPer] > 0.0)
d818 4
a821 2
      pgdNonSubVol =
         minAndNet (netExecVol, unpgdNonSubVol_ (theBomEnt)[execPer]);
d823 1
a823 1
      pegConsEnt (theBomEnt, execPer, pgdNonSubVol);
d825 6
a830 2
      if (netExecVol <= 0.0)
         return;
d833 20
a852 2
   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (unpgdSubVol_ (theSub)[execPer] > 0.0)
d854 4
a857 1
         pgdSubVol = minAndNet (netExecVol, unpgdSubVol_ (theSub)[execPer]);
d859 2
a860 1
         curTarg_->subVolPegList ()->append (theSub, execPer, pgdSubVol);
d862 11
a872 1
         pegConsEnt (theSub, execPer, pgdSubVol);
d874 1
a874 2
         if (netExecVol <= 0.0)
            return;
d880 1
a880 4
void WitPipBldr::pegConsEnt (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         pgdExecVol)
d882 11
a892 3
   double    pgdConsVol;
   WitPart * consPart;
   WitPeriod consPer;
d894 1
a894 1
   witAssert (pgdExecVol > 0.0);
d896 6
a901 1
   pgdConsVol = pgdExecVol * theConsEnt->effConsRate ()[execPer];
d903 3
a905 2
   if (pgdConsVol <= 0.0)
      return;
d907 1
a907 1
   consPart   = theConsEnt->myPart ();
d909 1
a909 1
   consPer    = theConsEnt->impactPeriod ()[execPer];
d911 15
a925 3
   curTarg_->
      myPartPegList ()[WitPipPartAtt::consVol]->
         append (consPart, consPer, pgdConsVol);
d927 1
a927 1
   myReqSched_->addTo (consPart, consPer, pgdConsVol);
d932 1
a932 1
double WitPipBldr::minAndNet (double & val1, double & val2)
d934 14
a947 1
   double minVal;
d949 4
a952 1
   if (val1 <= val2)
d954 3
a956 3
      minVal = val1;
      val1   = 0.0;
      val2  -= minVal;
d958 14
a971 1
   else
d973 6
a978 3
      minVal = val2;
      val1  -= minVal;
      val2   = 0.0;
d981 3
a983 1
   return minVal;
d988 1
a988 1
void WitPipBldr::consolidatePegLists ()
d990 1
a990 2
   curTarg_->execVolPegList ()->
      consolidate (workOpnSched_);
d992 6
a997 2
   curTarg_->subVolPegList ()->
      consolidate (workSubSched_);
d999 1
a999 2
   curTarg_->myPartPegList ()[WitPipPartAtt::supplyVol]->
      consolidate (workPartSched_);
d1001 7
a1007 2
   curTarg_->myPartPegList ()[WitPipPartAtt::sideVol]->
      consolidate (workPartSched_);
d1009 9
a1017 2
   curTarg_->myPartPegList ()[WitPipPartAtt::prodVol]->
      consolidate (workPartSched_);
d1019 1
a1019 2
   curTarg_->myPartPegList ()[WitPipPartAtt::consVol]->
      consolidate (workPartSched_);
d1024 4
a1027 1
void WitPipBldr::prtInfeas ()
d1029 10
a1038 3
   if (DEVELOPMENT)
      if (maxInfeas_ > 0.0)
         myMsgFac () ("blankMsg");
d1040 9
a1048 1
   myMsgFac () ("pipMaxInfeasMsg", maxInfeas_);
d1050 17
a1066 7
   if (maxInfeas_ > 0.0)
      myMsgFac () ("pipMaxInfDataMsg",
         maxInfeasTarg_->myDemand ()->demandName       (),
         maxInfeasTarg_->myDemand ()->demandedPartName (),
         maxInfeasTarg_->myShipPer (),
         maxInfeasPart_->partName (),
         maxInfeasPer_);
@


1.8
log
@[shared-resource pegging]
@
text
@@


1.7
log
@Cut-over to the new interpretation of pipShare.
@
text
@d18 1
a18 1
#include <PipPegMgr.h>
d37 1
a37 1
WitPipBldr::WitPipBldr (WitPipPegMgr * thePegMgr):
d39 1
a39 1
      WitProbAssoc    (thePegMgr->myProblem ()),
d41 1
a41 1
      myPegMgr_       (thePegMgr),
d92 1
a92 1
   myPegMgr_->mySeqMgr ()->get (theShipSeq);
d96 1
a96 1
      curTarg_ = myPegMgr_->myTargFor (theDemand, shipPer);
@


1.6
log
@New pipShare.
@
text
@a57 2
   stronglyAssert (myGlobalComp ()->newPipShare ());

@


1.5
log
@New pipShare.
@
text
@d637 3
@


1.4
log
@Began work on the new interpretation of pipShare.
@
text
@d46 1
a46 1
      unpgdExecVol_   (myProblem (), 0.0),
d114 7
a120 7
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitMaterial *  theMat;
   WitPart *      thePart;
   WitPeriod      execPer;
   WitPeriod      thePer;
d126 10
a135 2
   forEachOperation (theOpn, myProblem ())
      unpgdExecVol_ (theOpn) = theOpn->execVol ();
a153 2

   normShare_.clear ();
d582 1
a582 2
   WitOperation * theOpn;
   double         theUpExec;
d584 2
a585 2
   double         reqExecVol;
   double         pgdExecVol;
d589 2
d594 1
a594 3
   theOpn      = theBopEnt->myOperation ();

   theUpExec   = unpgdExecVol_ (theOpn)[execPer];
d596 1
a596 1
   if (theUpExec <= 0.0)
d599 1
a599 1
   theProdRate = theBopEnt->effProdRate ()[execPer];
d601 1
a601 1
   reqExecVol  = netReqVol / theProdRate;
d603 1
a603 1
   pgdExecVol  = min (reqExecVol, theUpExec);
d605 1
a605 1
   unpgdExecVol_ (theOpn)[execPer] -= pgdExecVol;
d607 1
a607 3
   curTarg_->execVolPegList ()->append (theOpn, execPer, pgdExecVol);

   pgdProdVol  = pgdExecVol * theProdRate;
d609 1
a609 1
   netReqVol  -= pgdProdVol;
d613 1
a613 1
   thePart     = theBopEnt->myPart ();
d615 1
a615 1
   prodPer     = theBopEnt->impactPeriod ()[execPer];
d621 5
a625 1
   pegBomEnts (theOpn, execPer, pgdExecVol);
d630 1
a630 1
void WitPipBldr::pegBomEnts (
d639 2
@


1.3
log
@Revised mappingIndex code.
@
text
@d58 2
d114 7
a120 7
   WitBopEntry * theBopEnt;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitMaterial * theMat;
   WitPart *     thePart;
   WitPeriod     execPer;
   WitPeriod     thePer;
d126 2
a127 11
   forEachBopEntry (theBopEnt, myProblem ())
      {
      unpgdExecVol_ (theBopEnt) = 0.0;

      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->execPerOKForExp (execPer))
               unpgdExecVol_ (theBopEnt)[execPer] =
                    normShare_ (theBopEnt)[execPer]
                  * theBopEnt->myOperation ()->execVol ()[execPer];
      }
a225 2
   double        normShareVal;
   double        effProd;
d237 4
a245 7
         normShareVal = normShare_ (theBopEnt)[execPer];

         if (normShareVal == 1.0)
            continue;

         effProd = theBopEnt->effProdRate ()[execPer];

d249 1
a249 1
            (1.0 - normShareVal) * execVolVal * effProd;
d587 3
a589 1
   theUpExec   = unpgdExecVol_ (theBopEnt)[execPer];
a593 2
   theOpn      = theBopEnt->myOperation ();

d600 1
a600 1
   unpgdExecVol_ (theBopEnt)[execPer] -= pgdExecVol;
@


1.2
log
@Made PIP avoid pegging supplyVol that's excessVol.
@
text
@a31 1
#include <MapIdxI.h>
@


1.1
log
@Tie Breaking Prop-Rt.
@
text
@a113 1
   WitPeriod     execPer;
d118 2
d147 5
a151 1
      unpgdSupplyVol_ (thePart) = thePart->supplyVol ();
@


head	1.28;
access;
symbols
	sce_5_01_20080919:1.25
	latest_sce_4_20_20060523:1.25.0.2
	sce_4_20_20060523:1.25
	latest_sce4_20_OSL:1.24.0.2
	sce_4_20_OSL:1.24
	sce_410_withVa:1.23
	sce_4_05_20040511:1.17
	sce_4_00_20040201:1.10
	nextGenBranch:1.10.0.2
	nextGenRoot:1.10
	sce_3_30_20030627:1.9
	EndRw-branch:1.5.0.4
	Root-of-EndRw:1.5
	rwToStl:1.5.0.2
	latest_sce_3_10_20010924:1.2.0.8
	sce_3_10_20010924:1.2
	latest_sce_3_00_20010601:1.2.0.6
	sce_3_00_20010601:1.2
	latest_sce_2_31_20010308:1.2.0.4
	sce_2_31_20010308:1.2
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2011.09.28.23.50.39;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.24.00.28.54;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2011.08.30.20.18.22;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.02.17.34.15;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.24.19.44.34;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.07.18.18.11;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.07.16.00.58;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.23.21.38.44;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.23.21.06.08;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.23.15.40.16;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.10.23.56.57;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.13.18.59.01;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.12.23.02.55;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.12.22.48.05;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.09.23.09.34;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.08.22.24.25;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.20.15.37.36;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.10.22.58.17;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.23.20.47.21;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.02.23.40.53;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.02.22.18.54;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.25.15.15.23;	author rwToStl;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.14.16.09.49;	author rjw;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.05.02.20.53.17;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.18.14.02.47;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.06;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.31;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2002.11.08.16.11.33;	author rwToStl;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.24.13.53.31;	author wit;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
//
//     Source file: VecBS.C
//     Implementation of classes VectorSpec and BoundSetSpec.
//
//------------------------------------------------------------------------------

#include <defines.h>

// #if IMPLEMENT_READDATA

#include <Parlex.h>
#include <SymTable.h>
#include <VecBS.h>
#include <Entity.h>
#include <Parser.h>
#include <Problem.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
//     Implementation of class VectorSpec (see VecBS.h)
//
//------------------------------------------------------------------------------

// Constructor and destructor

WitVectorSpec::WitVectorSpec (
         WitProblem *       theProblem,
         vType              type1,
         WitDRParmType::Tag type2):

      formatType_(type1),
      dataType_  (type2),
      nEntries_  (0),
      boolCVec_  (NULL),
      intCVec_   (NULL),
      dblCVec_   (NULL)
   {
   nPeriods_ = theProblem->nPeriods ();

   switch (dataType_)
      {
      case WitDRParmType::boolVector:
         {
         bvec_ = new std::vector <bool> (nPeriods_, false);
         pvec_ = new std::vector <int>  (nPeriods_, 0);

         break;
         }

      case WitDRParmType::intVector:
         {
         ivec_ = new std::vector <int> (nPeriods_, 0);
         pvec_ = new std::vector <int> (nPeriods_, 0);

         break;
         }

      case WitDRParmType::doubleVector:
         {
         dvec_ = new std::vector <double> (nPeriods_, 0.0);
         pvec_ = new std::vector <int>    (nPeriods_, 0);

         break;
         }

      default:
         {
         dataType_ = WitDRParmType::undefined;
            //
            // if the data type is invalid, set it to "DRParmType::undefined".
            // After the argument is parsed, the function WitEntity::checkArgs
            // will issue the appropriate error message and the API function
            // will not be called.
         }
      }
   }

WitVectorSpec::~WitVectorSpec ()
   {
   switch (dataType_)
      {
      case WitDRParmType::boolVector: 
         {
         delete   bvec_;
         delete   pvec_;
         delete[] boolCVec_;

         break;
         }

      case WitDRParmType::intVector: 
         {
         delete   ivec_;
         delete   pvec_;
         delete[] intCVec_;

         break;
         }

      case WitDRParmType::doubleVector:
         {
         delete   dvec_;
         delete   pvec_;
         delete[] dblCVec_;

         break;
         }
      }
   }

// Operations

// build and return pointer to WitBoolean time vector

WitBoolean * WitVectorSpec::getBoolVec (bool defVal)
   {
   witAssert (dataType_ == WitDRParmType::boolVector);

   if (boolCVec_ == NULL)
      boolCVec_ = new WitBoolean [nPeriods_];

   aSize_ = nPeriods_;
      //
      // save actual time-vector size

   switch (formatType_)
      {
      case single_:
         return getBoolVecSingle ();

      case dense_:
         return getBoolVecDense ();

      case sparse_:
         return getBoolVecSparse (defVal);

      default:
         return NULL;  
      }
   }

WitBoolean * WitVectorSpec::getBoolVecSingle ()
   {
   WitPeriod thePer;

   for (thePer = 0; thePer < nPeriods_; thePer ++)
      boolCVec_[thePer] = bvec ()[0];

   return boolCVec_;
   }

WitBoolean * WitVectorSpec::getBoolVecDense ()
   {
   WitPeriod thePer;

      // check to make sure that dense vector is well-formed
      //
   if (nval () != aSize_)
      {
      WitParser::instance ()->
         myMsgFac () ("valuesNotEqualPeriodsMsg",
            WitParser::instance ()->currentAttr ()->attrID (), 
            nval (),
            aSize_);

      WitParser::instance ()->currentAttr ()->setInvalid (true);

      return NULL;
      };  

   for (thePer = 0; thePer < nPeriods_; thePer ++)
      boolCVec_[thePer] = bvec ()[thePer];

   return boolCVec_;
   }

WitBoolean * WitVectorSpec::getBoolVecSparse (bool defVal)
   {
   WitPeriod thePer;
   int       theIdx;

      // check to make sure that sparse vector is well-formed
      //
   for (theIdx = 0; theIdx < nval (); theIdx ++)
      if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
         {
         WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
            WitParser::instance ()->currentAttr()->attrID (), aSize_);

         return NULL;
         };

   for (thePer = 0; thePer < nPeriods_; thePer ++)
      boolCVec_[thePer] = defVal;

   for (theIdx = 0; theIdx < nEntries_; theIdx ++)
      boolCVec_[pvec ()[theIdx]] = bvec ()[theIdx];

   return boolCVec_;
   }

// build and return pointer to integer time vector

int * WitVectorSpec::getIntVec (int defVal)
   {
   witAssert (dataType_ == WitDRParmType::intVector);

   if (intCVec_ == NULL)
      intCVec_ = new int [nPeriods_];

   aSize_ = nPeriods_;
      //
      // save actual time-vector size

   switch (formatType_)
      {
      case single_:
         return getIntVecSingle ();

      case dense_:
         return getIntVecDense ();

      case sparse_:
         return getIntVecSparse (defVal);

      default:
         return NULL;  
      }
   }

int * WitVectorSpec::getIntVecSingle ()
   {
   WitPeriod thePer;

   for (thePer = 0; thePer < nPeriods_; thePer ++)
      intCVec_[thePer] = ivec ()[0];

   return intCVec_;
   }

int * WitVectorSpec::getIntVecDense ()
   {
   WitPeriod thePer;

      // check to make sure that dense vector is well-formed
      //
   if (nval () != aSize_)
      {
      WitParser::instance ()->
         myMsgFac () ("valuesNotEqualPeriodsMsg",
            WitParser::instance ()->currentAttr ()->attrID (), 
            nval (),
            aSize_);

      WitParser::instance ()->currentAttr ()->setInvalid (true);

      return NULL;
      };  

   for (thePer = 0; thePer < nPeriods_; thePer ++)
      intCVec_[thePer] = ivec ()[thePer];

   return intCVec_;
   }

int * WitVectorSpec::getIntVecSparse (int defVal)
   {
   WitPeriod thePer;
   int       theIdx;

      // check to make sure that sparse vector is well-formed
      //
   for (theIdx = 0; theIdx < nval (); theIdx ++)
      if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
         {
         WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
            WitParser::instance ()->currentAttr()->attrID (), aSize_);

         return NULL;
         };

   for (thePer = 0; thePer < nPeriods_; thePer ++)
      intCVec_[thePer] = defVal;

   for (theIdx = 0; theIdx < nEntries_; theIdx ++)
      intCVec_[pvec ()[theIdx]] = ivec ()[theIdx];

   return intCVec_;
   }

   // build and return pointer to double time vector
   //
double * WitVectorSpec::getDblVec (double defVal)
   {  
   int       theIdx;
   WitPeriod thePer;

   witAssert (dataType_ == WitDRParmType::doubleVector);

   if (dblCVec_ == NULL)
      dblCVec_ = new double[nPeriods_];

   aSize_ = nPeriods_;                  // save actual time-vector size

   switch (formatType_)
      {
      case single_:
         {
         for (thePer = 0; thePer < nPeriods_; thePer ++)
            dblCVec_[thePer] = dvec ()[0];

         return dblCVec_;
         }

      case dense_:
         {
            // check to make sure that dense vector is well-formed
            //
         if (nval () != aSize_)
            {
            WitParser::instance ()->myMsgFac () ("valuesNotEqualPeriodsMsg",
               WitParser::instance ()->currentAttr()->attrID(), nval(), aSize_);

            WitParser::instance ()->currentAttr()->setInvalid (true);

            return NULL;
            };

         for (thePer = 0; thePer < nPeriods_; thePer ++)
            dblCVec_[thePer] = dvec ()[thePer];

         return dblCVec_;
         }

      case sparse_:
         {
            // check to make sure that sparse vector is well-formed
            //
         for (theIdx = 0; theIdx < nval (); theIdx ++)
            if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
               {
               WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
                  WitParser::instance ()->currentAttr ()->attrID (), aSize_);

               return NULL;
               };

         for (thePer = 0; thePer < nPeriods_; thePer ++)
            dblCVec_[thePer] = defVal;

         for (theIdx = 0; theIdx < nEntries_; theIdx ++)
            dblCVec_[pvec ()[theIdx]] = dvec ()[theIdx];

         return dblCVec_;
         }

      default:
         return NULL;  
      }
   }

// Accessors

WitVectorSpec::vType WitVectorSpec::formatType() const
{ return formatType_; }

WitDRParmType::Tag WitVectorSpec::dataType() const
{ return dataType_; }

int WitVectorSpec::nval() const
    {
    switch (dataType_)
       {
       case WitDRParmType::undefined:    return 0; 
       case WitDRParmType::boolVector:   return nEntries_; 
       case WitDRParmType::intVector:    return nEntries_; 
       case WitDRParmType::doubleVector: return nEntries_;
       default:                          return 0;
     }
   }

int WitVectorSpec::nPeriods() const
{ return nPeriods_; }

int WitVectorSpec::nEntries() const
{ return nEntries_; }

int WitVectorSpec::aSize() const
{ return aSize_; }

void WitVectorSpec::setFormatType(const vType type)
{ formatType_ = type; }

void WitVectorSpec::setDataType(const WitDRParmType::Tag type)
{ dataType_ = type; }

// operations

// get a value
int WitVectorSpec::getIntVal(int index)
{
  return (ivec ()[index]);
}

double WitVectorSpec::getDoubleVal(int index)
{
  return dvec ()[index];
}

int WitVectorSpec::getPeriodVal(int index)
{
  return (pvec ()[index]);
}

   // store the next value
   //
WitParseRC WitVectorSpec::addBoolVal (bool value)
   {
   witAssert (dataType_ == WitDRParmType::boolVector);

      // make the vector bigger, if necessary
      //
   if (nEntries_ >= bvec ().size ())
      bvec ().resize (bvec ().size () + VSIZE);

   bvec ()[nEntries_] = value;
      //
      // insert a boolean value

   nEntries_ ++;

   return 0;
   }

   // store the next value
   //
WitParseRC WitVectorSpec::addIntVal (int value)
   {
   witAssert (dataType_ == WitDRParmType::intVector);

      // make the vector bigger, if necessary
      //
   if (nEntries_ >= ivec ().size ())
      ivec ().resize (ivec ().size () + VSIZE);

   ivec ()[nEntries_++] = value;
      //
      // insert an integer value

   return 0;
   }

WitParseRC WitVectorSpec::addDoubleVal(double value)
{
  witAssert (dataType_ == WitDRParmType::doubleVector);

  // make the vector bigger, if necessary
  if (nEntries_ >= dvec ().size ())
    dvec ().resize (dvec ().size () + VSIZE);

  dvec ()[nEntries_++] = value; // insert a double value 
  return 0;
}

WitParseRC WitVectorSpec::addPeriodVal(int value)
{
  // make the vector bigger, if necessary
  if (nEntries_ >= pvec ().size ())
    pvec ().resize(pvec ().size () + VSIZE);

  // check for duplicate period
  for (int i = 0; i < nEntries_; i++)
    if (pvec ()[i] == value) {
      WitParser::instance ()->myMsgFac () ("duplicatePeriodMsg",
        WitParser::instance ()->currentAttr()->attrID());
      return PERIOD_DUP;
    }

   pvec ()[nEntries_] = value;
   return 0;
}

//------------------------------------------------------------------------------
//
//     Implementation of class BoundSetSpec (see VecBS.h)
//
//------------------------------------------------------------------------------

// Constructor and destructor

WitBoundSetSpec::WitBoundSetSpec(bsType type):
  boundSetType_(type),
  hardLBVec_(NULL),
  softLBVec_(NULL),
  hardUBVec_(NULL)
{
}

WitBoundSetSpec::~WitBoundSetSpec()
{
  if (hardLBVec_ != NULL) delete hardLBVec_;
  if (softLBVec_ != NULL) delete softLBVec_;
  if (hardUBVec_ != NULL) delete hardUBVec_;
}

// Operations

// Accessors

WitBoundSetSpec::bsType WitBoundSetSpec::boundSetType() const
{ return boundSetType_; }

WitVectorSpec* WitBoundSetSpec::hardLBVec() const
{ return hardLBVec_; }

WitVectorSpec* WitBoundSetSpec::softLBVec() const
{ return softLBVec_; }

WitVectorSpec* WitBoundSetSpec::hardUBVec() const
{ return hardUBVec_; }

void WitBoundSetSpec::setHardLBVec(WitVectorSpec* theVSpec)
{ hardLBVec_ = theVSpec; }

void WitBoundSetSpec::setSoftLBVec(WitVectorSpec* theVSpec)
{ softLBVec_ = theVSpec; }

void WitBoundSetSpec::setHardUBVec(WitVectorSpec* theVSpec)
{ hardUBVec_ = theVSpec; }

// #endif
@


1.27
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.26
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d40 50
a89 50
WitProblem *       theProblem,
vType              type1,
WitDRParmType::Tag type2):

formatType_(type1),
dataType_  (type2),
nEntries_  (0),
boolCVec_  (NULL),
intCVec_   (NULL),
dblCVec_   (NULL)
{
nPeriods_ = theProblem->nPeriods ();

switch (dataType_)
{
case WitDRParmType::boolVector:
{
bvec_ = new std::vector <bool> (nPeriods_, false);
pvec_ = new std::vector <int>  (nPeriods_, 0);

break;
}

case WitDRParmType::intVector:
{
ivec_ = new std::vector <int> (nPeriods_, 0);
pvec_ = new std::vector <int> (nPeriods_, 0);

break;
}

case WitDRParmType::doubleVector:
{
dvec_ = new std::vector <double> (nPeriods_, 0.0);
pvec_ = new std::vector <int>    (nPeriods_, 0);

break;
}

default:
{
dataType_ = WitDRParmType::undefined;
//
// if the data type is invalid, set it to "DRParmType::undefined".
// After the argument is parsed, the function WitEntity::checkArgs
// will issue the appropriate error message and the API function
// will not be called.
}
}
}
d92 31
a122 31
{
switch (dataType_)
{
case WitDRParmType::boolVector:
{
delete   bvec_;
delete   pvec_;
delete[] boolCVec_;

break;
}

case WitDRParmType::intVector:
{
delete   ivec_;
delete   pvec_;
delete[] intCVec_;

break;
}

case WitDRParmType::doubleVector:
{
delete   dvec_;
delete   pvec_;
delete[] dblCVec_;

break;
}
}
}
d129 2
a130 17
{
witAssert (dataType_ == WitDRParmType::boolVector);

if (boolCVec_ == NULL)
boolCVec_ = new WitBoolean [nPeriods_];

aSize_ = nPeriods_;
//
// save actual time-vector size

switch (formatType_)
{
case single_:
return getBoolVecSingle ();

case dense_:
return getBoolVecDense ();
d132 2
a133 2
case sparse_:
return getBoolVecSparse (defVal);
d135 19
a153 4
default:
return NULL;
}
}
d156 2
a157 2
{
WitPeriod thePer;
d159 2
a160 2
for (thePer = 0; thePer < nPeriods_; thePer ++)
boolCVec_[thePer] = bvec ()[0];
d162 2
a163 2
return boolCVec_;
}
d166 2
a167 12
{
WitPeriod thePer;

// check to make sure that dense vector is well-formed
//
if (nval () != aSize_)
{
WitParser::instance ()->
myMsgFac () ("valuesNotEqualPeriodsMsg",
WitParser::instance ()->currentAttr ()->attrID (),
nval (),
aSize_);
d169 11
a179 1
WitParser::instance ()->currentAttr ()->setInvalid (true);
d181 2
a182 2
return NULL;
};
d184 2
a185 2
for (thePer = 0; thePer < nPeriods_; thePer ++)
boolCVec_[thePer] = bvec ()[thePer];
d187 2
a188 2
return boolCVec_;
}
d191 14
a204 14
{
WitPeriod thePer;
int       theIdx;

// check to make sure that sparse vector is well-formed
//
for (theIdx = 0; theIdx < nval (); theIdx ++)
if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
{
WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
WitParser::instance ()->currentAttr()->attrID (), aSize_);

return NULL;
};
d206 2
a207 2
for (thePer = 0; thePer < nPeriods_; thePer ++)
boolCVec_[thePer] = defVal;
d209 2
a210 2
for (theIdx = 0; theIdx < nEntries_; theIdx ++)
boolCVec_[pvec ()[theIdx]] = bvec ()[theIdx];
d212 2
a213 2
return boolCVec_;
}
d218 2
a219 14
{
witAssert (dataType_ == WitDRParmType::intVector);

if (intCVec_ == NULL)
intCVec_ = new int [nPeriods_];

aSize_ = nPeriods_;
//
// save actual time-vector size

switch (formatType_)
{
case single_:
return getIntVecSingle ();
d221 2
a222 2
case dense_:
return getIntVecDense ();
d224 19
a242 7
case sparse_:
return getIntVecSparse (defVal);

default:
return NULL;
}
}
d245 2
a246 2
{
WitPeriod thePer;
d248 2
a249 2
for (thePer = 0; thePer < nPeriods_; thePer ++)
intCVec_[thePer] = ivec ()[0];
d251 2
a252 2
return intCVec_;
}
d255 2
a256 12
{
WitPeriod thePer;

// check to make sure that dense vector is well-formed
//
if (nval () != aSize_)
{
WitParser::instance ()->
myMsgFac () ("valuesNotEqualPeriodsMsg",
WitParser::instance ()->currentAttr ()->attrID (),
nval (),
aSize_);
d258 11
a268 1
WitParser::instance ()->currentAttr ()->setInvalid (true);
d270 2
a271 2
return NULL;
};
d273 2
a274 2
for (thePer = 0; thePer < nPeriods_; thePer ++)
intCVec_[thePer] = ivec ()[thePer];
d276 2
a277 2
return intCVec_;
}
d280 17
a296 14
{
WitPeriod thePer;
int       theIdx;

// check to make sure that sparse vector is well-formed
//
for (theIdx = 0; theIdx < nval (); theIdx ++)
if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
{
WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
WitParser::instance ()->currentAttr()->attrID (), aSize_);

return NULL;
};
d298 2
a299 2
for (thePer = 0; thePer < nPeriods_; thePer ++)
intCVec_[thePer] = defVal;
d301 2
a302 5
for (theIdx = 0; theIdx < nEntries_; theIdx ++)
intCVec_[pvec ()[theIdx]] = ivec ()[theIdx];

return intCVec_;
}
d304 2
a305 2
// build and return pointer to double time vector
//
d307 67
a373 67
{
int       theIdx;
WitPeriod thePer;

witAssert (dataType_ == WitDRParmType::doubleVector);

if (dblCVec_ == NULL)
dblCVec_ = new double[nPeriods_];

aSize_ = nPeriods_;                  // save actual time-vector size

switch (formatType_)
{
case single_:
{
for (thePer = 0; thePer < nPeriods_; thePer ++)
dblCVec_[thePer] = dvec ()[0];

return dblCVec_;
}

case dense_:
{
// check to make sure that dense vector is well-formed
//
if (nval () != aSize_)
{
WitParser::instance ()->myMsgFac () ("valuesNotEqualPeriodsMsg",
WitParser::instance ()->currentAttr()->attrID(), nval(), aSize_);

WitParser::instance ()->currentAttr()->setInvalid (true);

return NULL;
};

for (thePer = 0; thePer < nPeriods_; thePer ++)
dblCVec_[thePer] = dvec ()[thePer];

return dblCVec_;
}

case sparse_:
{
// check to make sure that sparse vector is well-formed
//
for (theIdx = 0; theIdx < nval (); theIdx ++)
if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
{
WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
WitParser::instance ()->currentAttr ()->attrID (), aSize_);

return NULL;
};

for (thePer = 0; thePer < nPeriods_; thePer ++)
dblCVec_[thePer] = defVal;

for (theIdx = 0; theIdx < nEntries_; theIdx ++)
dblCVec_[pvec ()[theIdx]] = dvec ()[theIdx];

return dblCVec_;
}

default:
return NULL;
}
}
d384 10
a393 10
{
switch (dataType_)
{
case WitDRParmType::undefined:    return 0;
case WitDRParmType::boolVector:   return nEntries_;
case WitDRParmType::intVector:    return nEntries_;
case WitDRParmType::doubleVector: return nEntries_;
default:                          return 0;
}
}
d415 1
a415 1
return (ivec ()[index]);
d420 1
a420 1
return dvec ()[index];
d425 1
a425 1
return (pvec ()[index]);
d428 2
a429 2
// store the next value
//
d431 2
a432 2
{
witAssert (dataType_ == WitDRParmType::boolVector);
d434 4
a437 4
// make the vector bigger, if necessary
//
if (nEntries_ >= bvec ().size ())
bvec ().resize (bvec ().size () + VSIZE);
d439 3
a441 3
bvec ()[nEntries_] = value;
//
// insert a boolean value
d443 1
a443 1
nEntries_ ++;
d445 2
a446 2
return 0;
}
d448 2
a449 2
// store the next value
//
d451 2
a452 2
{
witAssert (dataType_ == WitDRParmType::intVector);
d454 8
a461 4
// make the vector bigger, if necessary
//
if (nEntries_ >= ivec ().size ())
ivec ().resize (ivec ().size () + VSIZE);
d463 2
a464 6
ivec ()[nEntries_++] = value;
//
// insert an integer value

return 0;
}
d468 1
a468 1
witAssert (dataType_ == WitDRParmType::doubleVector);
d470 3
a472 3
// make the vector bigger, if necessary
if (nEntries_ >= dvec ().size ())
dvec ().resize (dvec ().size () + VSIZE);
d474 2
a475 2
dvec ()[nEntries_++] = value; // insert a double value
return 0;
d480 11
a490 11
// make the vector bigger, if necessary
if (nEntries_ >= pvec ().size ())
pvec ().resize(pvec ().size () + VSIZE);

// check for duplicate period
for (int i = 0; i < nEntries_; i++)
if (pvec ()[i] == value) {
WitParser::instance ()->myMsgFac () ("duplicatePeriodMsg",
WitParser::instance ()->currentAttr()->attrID());
return PERIOD_DUP;
}
d492 2
a493 2
pvec ()[nEntries_] = value;
return 0;
d505 4
a508 4
boundSetType_(type),
hardLBVec_(NULL),
softLBVec_(NULL),
hardUBVec_(NULL)
d514 3
a516 3
if (hardLBVec_ != NULL) delete hardLBVec_;
if (softLBVec_ != NULL) delete softLBVec_;
if (hardUBVec_ != NULL) delete hardUBVec_;
@


1.25
log
@Updated the copyright date on all source files.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d40 50
a89 50
         WitProblem *       theProblem,
         vType              type1,
         WitDRParmType::Tag type2):

      formatType_(type1),
      dataType_  (type2),
      nEntries_  (0),
      boolCVec_  (NULL),
      intCVec_   (NULL),
      dblCVec_   (NULL)
   {
   nPeriods_ = theProblem->nPeriods ();

   switch (dataType_)
      {
      case WitDRParmType::boolVector:
         {
         bvec_ = new std::vector <bool> (nPeriods_, false);
         pvec_ = new std::vector <int>  (nPeriods_, 0);

         break;
         }

      case WitDRParmType::intVector:
         {
         ivec_ = new std::vector <int> (nPeriods_, 0);
         pvec_ = new std::vector <int> (nPeriods_, 0);

         break;
         }

      case WitDRParmType::doubleVector:
         {
         dvec_ = new std::vector <double> (nPeriods_, 0.0);
         pvec_ = new std::vector <int>    (nPeriods_, 0);

         break;
         }

      default:
         {
         dataType_ = WitDRParmType::undefined;
            //
            // if the data type is invalid, set it to "DRParmType::undefined".
            // After the argument is parsed, the function WitEntity::checkArgs
            // will issue the appropriate error message and the API function
            // will not be called.
         }
      }
   }
d92 31
a122 31
   {
   switch (dataType_)
      {
      case WitDRParmType::boolVector: 
         {
         delete   bvec_;
         delete   pvec_;
         delete[] boolCVec_;

         break;
         }

      case WitDRParmType::intVector: 
         {
         delete   ivec_;
         delete   pvec_;
         delete[] intCVec_;

         break;
         }

      case WitDRParmType::doubleVector:
         {
         delete   dvec_;
         delete   pvec_;
         delete[] dblCVec_;

         break;
         }
      }
   }
d129 17
a145 2
   {
   witAssert (dataType_ == WitDRParmType::boolVector);
d147 2
a148 2
   if (boolCVec_ == NULL)
      boolCVec_ = new WitBoolean [nPeriods_];
d150 4
a153 19
   aSize_ = nPeriods_;
      //
      // save actual time-vector size

   switch (formatType_)
      {
      case single_:
         return getBoolVecSingle ();

      case dense_:
         return getBoolVecDense ();

      case sparse_:
         return getBoolVecSparse (defVal);

      default:
         return NULL;  
      }
   }
d156 2
a157 2
   {
   WitPeriod thePer;
d159 2
a160 2
   for (thePer = 0; thePer < nPeriods_; thePer ++)
      boolCVec_[thePer] = bvec ()[0];
d162 2
a163 2
   return boolCVec_;
   }
d166 12
a177 2
   {
   WitPeriod thePer;
d179 1
a179 11
      // check to make sure that dense vector is well-formed
      //
   if (nval () != aSize_)
      {
      WitParser::instance ()->
         myMsgFac () ("valuesNotEqualPeriodsMsg",
            WitParser::instance ()->currentAttr ()->attrID (), 
            nval (),
            aSize_);

      WitParser::instance ()->currentAttr ()->setInvalid (true);
d181 2
a182 2
      return NULL;
      };  
d184 2
a185 2
   for (thePer = 0; thePer < nPeriods_; thePer ++)
      boolCVec_[thePer] = bvec ()[thePer];
d187 2
a188 2
   return boolCVec_;
   }
d191 14
a204 14
   {
   WitPeriod thePer;
   int       theIdx;

      // check to make sure that sparse vector is well-formed
      //
   for (theIdx = 0; theIdx < nval (); theIdx ++)
      if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
         {
         WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
            WitParser::instance ()->currentAttr()->attrID (), aSize_);

         return NULL;
         };
d206 2
a207 2
   for (thePer = 0; thePer < nPeriods_; thePer ++)
      boolCVec_[thePer] = defVal;
d209 2
a210 2
   for (theIdx = 0; theIdx < nEntries_; theIdx ++)
      boolCVec_[pvec ()[theIdx]] = bvec ()[theIdx];
d212 2
a213 2
   return boolCVec_;
   }
d218 14
a231 2
   {
   witAssert (dataType_ == WitDRParmType::intVector);
d233 2
a234 2
   if (intCVec_ == NULL)
      intCVec_ = new int [nPeriods_];
d236 7
a242 19
   aSize_ = nPeriods_;
      //
      // save actual time-vector size

   switch (formatType_)
      {
      case single_:
         return getIntVecSingle ();

      case dense_:
         return getIntVecDense ();

      case sparse_:
         return getIntVecSparse (defVal);

      default:
         return NULL;  
      }
   }
d245 2
a246 2
   {
   WitPeriod thePer;
d248 2
a249 2
   for (thePer = 0; thePer < nPeriods_; thePer ++)
      intCVec_[thePer] = ivec ()[0];
d251 2
a252 2
   return intCVec_;
   }
d255 12
a266 2
   {
   WitPeriod thePer;
d268 1
a268 11
      // check to make sure that dense vector is well-formed
      //
   if (nval () != aSize_)
      {
      WitParser::instance ()->
         myMsgFac () ("valuesNotEqualPeriodsMsg",
            WitParser::instance ()->currentAttr ()->attrID (), 
            nval (),
            aSize_);

      WitParser::instance ()->currentAttr ()->setInvalid (true);
d270 2
a271 2
      return NULL;
      };  
d273 2
a274 2
   for (thePer = 0; thePer < nPeriods_; thePer ++)
      intCVec_[thePer] = ivec ()[thePer];
d276 2
a277 2
   return intCVec_;
   }
d280 14
a293 17
   {
   WitPeriod thePer;
   int       theIdx;

      // check to make sure that sparse vector is well-formed
      //
   for (theIdx = 0; theIdx < nval (); theIdx ++)
      if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
         {
         WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
            WitParser::instance ()->currentAttr()->attrID (), aSize_);

         return NULL;
         };

   for (thePer = 0; thePer < nPeriods_; thePer ++)
      intCVec_[thePer] = defVal;
d295 2
a296 2
   for (theIdx = 0; theIdx < nEntries_; theIdx ++)
      intCVec_[pvec ()[theIdx]] = ivec ()[theIdx];
d298 5
a302 2
   return intCVec_;
   }
d304 2
a305 2
   // build and return pointer to double time vector
   //
d307 67
a373 67
   {  
   int       theIdx;
   WitPeriod thePer;

   witAssert (dataType_ == WitDRParmType::doubleVector);

   if (dblCVec_ == NULL)
      dblCVec_ = new double[nPeriods_];

   aSize_ = nPeriods_;                  // save actual time-vector size

   switch (formatType_)
      {
      case single_:
         {
         for (thePer = 0; thePer < nPeriods_; thePer ++)
            dblCVec_[thePer] = dvec ()[0];

         return dblCVec_;
         }

      case dense_:
         {
            // check to make sure that dense vector is well-formed
            //
         if (nval () != aSize_)
            {
            WitParser::instance ()->myMsgFac () ("valuesNotEqualPeriodsMsg",
               WitParser::instance ()->currentAttr()->attrID(), nval(), aSize_);

            WitParser::instance ()->currentAttr()->setInvalid (true);

            return NULL;
            };

         for (thePer = 0; thePer < nPeriods_; thePer ++)
            dblCVec_[thePer] = dvec ()[thePer];

         return dblCVec_;
         }

      case sparse_:
         {
            // check to make sure that sparse vector is well-formed
            //
         for (theIdx = 0; theIdx < nval (); theIdx ++)
            if (getPeriodVal (theIdx) < 0 or getPeriodVal (theIdx) >= aSize_)
               {
               WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
                  WitParser::instance ()->currentAttr ()->attrID (), aSize_);

               return NULL;
               };

         for (thePer = 0; thePer < nPeriods_; thePer ++)
            dblCVec_[thePer] = defVal;

         for (theIdx = 0; theIdx < nEntries_; theIdx ++)
            dblCVec_[pvec ()[theIdx]] = dvec ()[theIdx];

         return dblCVec_;
         }

      default:
         return NULL;  
      }
   }
d384 10
a393 10
    {
    switch (dataType_)
       {
       case WitDRParmType::undefined:    return 0; 
       case WitDRParmType::boolVector:   return nEntries_; 
       case WitDRParmType::intVector:    return nEntries_; 
       case WitDRParmType::doubleVector: return nEntries_;
       default:                          return 0;
     }
   }
d415 1
a415 1
  return (ivec ()[index]);
d420 1
a420 1
  return dvec ()[index];
d425 1
a425 1
  return (pvec ()[index]);
d428 2
a429 2
   // store the next value
   //
d431 2
a432 2
   {
   witAssert (dataType_ == WitDRParmType::boolVector);
d434 4
a437 4
      // make the vector bigger, if necessary
      //
   if (nEntries_ >= bvec ().size ())
      bvec ().resize (bvec ().size () + VSIZE);
d439 3
a441 3
   bvec ()[nEntries_] = value;
      //
      // insert a boolean value
d443 1
a443 1
   nEntries_ ++;
d445 2
a446 2
   return 0;
   }
d448 2
a449 2
   // store the next value
   //
d451 2
a452 2
   {
   witAssert (dataType_ == WitDRParmType::intVector);
d454 4
a457 8
      // make the vector bigger, if necessary
      //
   if (nEntries_ >= ivec ().size ())
      ivec ().resize (ivec ().size () + VSIZE);

   ivec ()[nEntries_++] = value;
      //
      // insert an integer value
d459 6
a464 2
   return 0;
   }
d468 1
a468 1
  witAssert (dataType_ == WitDRParmType::doubleVector);
d470 3
a472 3
  // make the vector bigger, if necessary
  if (nEntries_ >= dvec ().size ())
    dvec ().resize (dvec ().size () + VSIZE);
d474 2
a475 2
  dvec ()[nEntries_++] = value; // insert a double value 
  return 0;
d480 11
a490 11
  // make the vector bigger, if necessary
  if (nEntries_ >= pvec ().size ())
    pvec ().resize(pvec ().size () + VSIZE);

  // check for duplicate period
  for (int i = 0; i < nEntries_; i++)
    if (pvec ()[i] == value) {
      WitParser::instance ()->myMsgFac () ("duplicatePeriodMsg",
        WitParser::instance ()->currentAttr()->attrID());
      return PERIOD_DUP;
    }
d492 2
a493 2
   pvec ()[nEntries_] = value;
   return 0;
d505 4
a508 4
  boundSetType_(type),
  hardLBVec_(NULL),
  softLBVec_(NULL),
  hardUBVec_(NULL)
d514 3
a516 3
  if (hardLBVec_ != NULL) delete hardLBVec_;
  if (softLBVec_ != NULL) delete softLBVec_;
  if (hardUBVec_ != NULL) delete hardUBVec_;
@


1.24
log
@Correction to a minor problem revealed by ZeroFault.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.23
log
@[exceptions]
@
text
@d57 1
a57 1
         bvec_ = new std::vector <bool> (nPeriods_, 0);
d73 1
a73 1
         dvec_ = new std::vector <double> (nPeriods_, 0);
@


1.22
log
@[exceptions]
@
text
@d25 1
a25 1
#include <witParse.h>
@


1.21
log
@Vector PropRt.
@
text
@a21 1
#include <witLexer.h>
@


1.20
log
@Vector Prop-Rt.
@
text
@a58 1
         ivec_ = new std::vector <int>  (nPeriods_, 0);
a98 1
         delete   ivec_;
a99 1
         delete[] intCVec_;
@


1.19
log
@Vector Prop-Rt.
@
text
@d48 1
d58 3
a60 2
         ivec_ = new std::vector <int> (nPeriods_, 0);
         pvec_ = new std::vector <int> (nPeriods_, 0);
d99 1
d103 1
d130 89
d223 2
d235 1
a235 1
         return getSingleIntVec ();
d238 1
a238 1
         return getDenseIntVec ();
d241 1
a241 1
         return getSparseIntVec (defVal);
d248 1
a248 1
int * WitVectorSpec::getSingleIntVec ()
d258 1
a258 1
int * WitVectorSpec::getDenseIntVec ()
d283 1
a283 1
int * WitVectorSpec::getSparseIntVec (int defVal)
d315 2
d440 2
a441 2
   if (nEntries_ >= ivec ().size ())
      ivec ().resize (ivec ().size () + VSIZE);
d443 1
a443 1
   ivec ()[nEntries_++] = value;
d447 2
@


1.18
log
@Vector PropRt.
@
text
@d91 27
a117 3
WitVectorSpec::~WitVectorSpec()
{
  switch (dataType_) {
d119 4
a122 16
    case WitDRParmType::boolVector: 
      stronglyAssert (false); // boolVector NYI
      break;

    case WitDRParmType::intVector: 
      delete ivec_;
      delete pvec_;
      delete[] intCVec_;
      break;
    case WitDRParmType::doubleVector:
      delete dvec_;
      delete pvec_;
      delete[] dblCVec_;
      break;
  }
}
a129 3
   int i;
   int j;

d133 3
a135 1
   aSize_  = nPeriods_;                  // save actual time-vector size
d140 26
a165 3
         {
         for (i = 0; i < nPeriods_; i++)
            intCVec_[i] = ivec ()[0];
d167 9
a175 2
         return intCVec_;
         }
d177 1
a177 8
      case dense_:
         {
            // check to make sure that dense vector is well-formed
            //
         if (nval() != aSize_)
            {
            WitParser::instance ()->myMsgFac () ("valuesNotEqualPeriodsMsg",
               WitParser::instance ()->currentAttr()->attrID(), nval(),aSize_);
d179 2
a180 1
            WitParser::instance ()->currentAttr()->setInvalid(true);
d182 2
a183 2
            return NULL;
            };  
d185 2
a186 2
         for (i = 0; i < nPeriods_; i++)
            intCVec_[i] = ivec ()[i];
d188 4
a191 2
         return intCVec_;
         }
d193 4
a196 1
      case sparse_:
d198 2
a199 10
            // check to make sure that sparse vector is well-formed
            //
         for (j = 0; j < nval(); j++)
            if (getPeriodVal(j) < 0 or getPeriodVal(j) >= aSize_)
               {
               WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
                  WitParser::instance ()->currentAttr()->attrID(), aSize_);

               return NULL;
               };
d201 2
a202 2
         for (i = 0; i < nPeriods_; i++)
            intCVec_[i] = defVal;
d204 2
a205 2
         for (i = 0; i < nEntries_; i++)
            intCVec_[pvec ()[i]] = ivec ()[i];
d207 2
a208 2
         return intCVec_;
         }
d210 1
a210 3
      default:
         return NULL;  
      }
d291 10
a300 13
{
  switch (dataType_) {
    case WitDRParmType::undefined: return 0; 

    case WitDRParmType::boolVector:
      stronglyAssert (false); // boolVector NYI
      return 0;

    case WitDRParmType::intVector: return nEntries_; 
    case WitDRParmType::doubleVector: return nEntries_;
    default: return 0;
  }
}
d335 32
a366 6
// store the next value
WitParseRC WitVectorSpec::addIntVal(int value)
{
  // make the vector bigger, if necessary
  if (nEntries_ >= ivec ().size ())
    ivec ().resize(ivec ().size () + VSIZE);
d368 2
a369 4
  ivec ()[nEntries_++] = value;        // insert an integer value
  dataType_ = WitDRParmType::intVector;
  return 0;
}
d373 2
a379 1
  dataType_ = WitDRParmType::doubleVector;  // will be double vector from now on
@


1.17
log
@Double Precision.
@
text
@d40 35
a74 11
WitVectorSpec::WitVectorSpec(
     WitProblem *       theProblem,
     vType              type1,
     WitDRParmType::Tag type2):
  formatType_(type1),
  dataType_(type2),
  nEntries_(0),
  intCVec_ (NULL),
  dblCVec_ (NULL)
{
  nPeriods_ = theProblem->nPeriods();
d76 2
a77 9
  switch (dataType_) {
    case WitDRParmType::intVector:
      ivec_ = new std::vector<int> (nPeriods_, 0);
      pvec_ = new std::vector<int> (nPeriods_, 0);
      break;
    case WitDRParmType::doubleVector:
      dvec_ = new std::vector<double> (nPeriods_, 0);
      pvec_ = new std::vector<int>    (nPeriods_, 0);
      break;
d79 11
a89 7
    default:
      // if the data type is invalid, set it to "DRParmType::undefined". After
      // the argument is parsed, the function WitEntity::checkArgs will issue 
      // the appropriate error message and the API function will not be called.
      dataType_ = WitDRParmType::undefined;
  }
}
d94 5
d264 5
@


1.16
log
@Double Precision.
@
text
@d48 1
a48 1
  fltCVec_ (NULL)
d58 1
a58 1
      fvec_ = new std::vector<double> (nPeriods_, 0);
d79 1
a79 1
      delete fvec_;
d81 1
a81 1
      delete[] fltCVec_;
d159 1
a159 1
double * WitVectorSpec::getFltVec (double defVal)
d164 2
a165 2
   if (fltCVec_ == NULL)
      fltCVec_ = new double[nPeriods_];
d174 1
a174 1
            fltCVec_[thePer] = fvec ()[0];
d176 1
a176 1
         return fltCVec_;
d194 1
a194 1
            fltCVec_[thePer] = fvec ()[thePer];
d196 1
a196 1
         return fltCVec_;
d213 1
a213 1
            fltCVec_[thePer] = defVal;
d216 1
a216 1
            fltCVec_[pvec ()[theIdx]] = fvec ()[theIdx];
d218 1
a218 1
         return fltCVec_;
d267 1
a267 1
double WitVectorSpec::getFloatVal(int index)
d269 1
a269 1
  return fvec ()[index];
d289 1
a289 1
WitParseRC WitVectorSpec::addFloatVal(double value)
d292 2
a293 2
  if (nEntries_ >= fvec ().size ())
    fvec ().resize (fvec ().size () + VSIZE);
d295 2
a296 2
  fvec ()[nEntries_++] = value; // insert a double value 
  dataType_ = WitDRParmType::doubleVector;   // will be Float Vector from now on
@


1.15
log
@Double Precision.
@
text
@d57 1
a57 1
    case WitDRParmType::floatVector:
d78 1
a78 1
    case WitDRParmType::floatVector:
d239 1
a239 1
    case WitDRParmType::floatVector: return nEntries_;
d296 1
a296 1
  dataType_ = WitDRParmType::floatVector;    // will be Float Vector from now on
@


1.14
log
@Double Precision.
@
text
@d40 4
a43 1
WitVectorSpec::WitVectorSpec(WitProblem * theProblem, vType type1, pType type2):
d53 1
a53 1
    case IntVector:
d57 1
a57 1
    case FloatVector:
d63 4
a66 4
      // if the data type is invalid, set it to "Undefined". After the
      // argument is parsed, the function WitEntity::checkArgs will issue the	
      // appropriate error message and the API function will not be called.
      dataType_ = Undefined;
d73 1
a73 1
    case IntVector: 
d78 1
a78 1
    case FloatVector:
d231 1
a231 1
pType WitVectorSpec::dataType() const
d237 3
a239 3
    case Undefined: return 0; 
    case IntVector: return nEntries_; 
    case FloatVector: return nEntries_;
d256 1
a256 1
void WitVectorSpec::setDataType(const pType type)
d285 1
a285 1
  dataType_ = IntVector;
d296 1
a296 1
  dataType_ = FloatVector;       // will be Float Vector from now on
@


1.13
log
@Double Precision.
@
text
@d44 2
a45 2
  fltCVec_ (NULL),
  intCVec_ (NULL)
d87 1
a87 1
int * WitVectorSpec::getVector (int defVal)
d154 1
a154 1
   // build and return pointer to float time vector
d156 1
a156 1
float * WitVectorSpec::getVector (double defVal)
d162 1
a162 1
      fltCVec_ = new float[nPeriods_];
d171 1
a171 1
            fltCVec_[thePer] = fltFromDbl (fvec ()[0]);
d191 1
a191 1
            fltCVec_[thePer] = fltFromDbl (fvec ()[thePer]);
d210 1
a210 1
            fltCVec_[thePer] = fltFromDbl (defVal);
d213 1
a213 1
            fltCVec_[pvec ()[theIdx]] = fltFromDbl (fvec ()[theIdx]);
d264 1
a264 1
float  WitVectorSpec::getFloatVal(int index)
d266 1
a266 1
  return fltFromDbl (fvec ()[index]);
d278 2
a279 2
  if (nEntries_ >= ivec_->size())
    ivec_->resize(ivec_->size() + VSIZE);
d289 2
a290 2
  if (nEntries_ >= fvec_->size())
    fvec_->resize(fvec_->size() + VSIZE);
d300 2
a301 2
  if (nEntries_ >= pvec_->size())
    pvec_->resize(pvec_->size() + VSIZE);
@


1.12
log
@Double Precision.
@
text
@d44 2
a45 2
  floatTVec (NULL),
  intTVec (NULL)
d51 2
a52 2
      ivec = new std::vector<int> (nPeriods_, 0);
      pvec = new std::vector<int> (nPeriods_, 0);
d55 2
a56 2
      fvec = new std::vector<float> (nPeriods_, 0);
      pvec = new std::vector<int> (nPeriods_, 0);
d71 3
a73 3
      delete ivec;
      delete pvec;
      delete[] intTVec;
d76 3
a78 3
      delete fvec;
      delete pvec;
      delete[] floatTVec;
a85 3
int*     WitVectorSpec::getVector (int defVal)
{
  int    i, j;
d87 28
a114 2
  intTVec = new int [nPeriods_];
  aSize_ = nPeriods_;                  // save actual time-vector size
d116 1
a116 1
  switch (formatType_) {
a117 26
    case single_:
      for (i = 0; i < nPeriods_; i++)
        intTVec[i] = (*ivec)[0];
      return intTVec;

    case dense_:
      // check to make sure that dense vector is well-formed
      if (nval() != aSize_) {
        WitParser::instance ()->myMsgFac () ("valuesNotEqualPeriodsMsg",
           WitParser::instance ()->currentAttr()->attrID(), nval(),aSize_);

        WitParser::instance ()->currentAttr()->setInvalid(true);
        return NULL;
      };  

      for (i = 0; i < nPeriods_; i++)
        intTVec[i] = (*ivec)[i];
      return intTVec;

    case sparse_:
      // check to make sure that sparse vector is well-formed
      for (j = 0; j < nval(); j++)
        if (getPeriodVal(j) < 0 or
          getPeriodVal(j) >= aSize_) {
            WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
              WitParser::instance ()->currentAttr()->attrID(), aSize_);
d119 1
a119 1
        };
d121 2
a122 5
      for (i = 0; i < nPeriods_; i++)
        intTVec[i] = defVal;
      for (i = 0; i < nEntries_; i++)
         intTVec[(*pvec)[i]] = (*ivec)[i];
      return intTVec;
d124 29
a152 4
    default:
      return NULL;  
  }
}
d154 2
d157 29
a185 3
   {
   return getVector (fltFromDbl (defVal));
   }
a186 37
// build and return pointer to float time vector
float*   WitVectorSpec::getVector (float defVal)
{  
  int    i, j;

  floatTVec = new float [nPeriods_];
  aSize_ = nPeriods_;                  // save actual time-vector size

  switch (formatType_) {

    case single_:
      for (i = 0; i < nPeriods_; i++) {
        floatTVec[i] = (*fvec)[0];
      };
      return floatTVec;

    case dense_:
      // check to make sure that dense vector is well-formed
      if (nval() != aSize_) {
        WitParser::instance ()->myMsgFac () ("valuesNotEqualPeriodsMsg",
           WitParser::instance ()->currentAttr()->attrID(), nval(), aSize_);

        WitParser::instance ()->currentAttr()->setInvalid(true);
        return NULL;
      };

      for (i = 0; i < nPeriods_; i++)
        floatTVec[i] = (*fvec)[i];
      return floatTVec;

    case sparse_:
      // check to make sure that sparse vector is well-formed
      for (j = 0; j < nval(); j++)
        if (getPeriodVal(j) < 0 or
          getPeriodVal(j) >= aSize_) {
            WitParser::instance ()->myMsgFac () ("invalidPeriodMsg",
              WitParser::instance ()->currentAttr()->attrID(), aSize_);
d188 1
a188 1
        };
d190 2
a191 5
      for (i = 0; i < nPeriods_; i++)
        floatTVec[i] = defVal;
      for (i = 0; i < nEntries_; i++)
          floatTVec[(*pvec)[i]] = (*fvec)[i];
      return floatTVec;
d193 2
a194 4
    default:
      return NULL;  
  }
}
d196 26
d261 1
a261 1
  return ((*ivec)[index]);
d266 1
a266 1
  return ((*fvec)[index]);
d271 1
a271 1
  return ((*pvec)[index]);
d278 2
a279 2
  if (nEntries_ >= ivec->size())
    ivec->resize(ivec->size() + VSIZE);
d281 1
a281 1
  (*ivec)[nEntries_++] = value;        // insert an integer value
d286 1
a286 1
WitParseRC WitVectorSpec::addFloatVal(float value)
d289 2
a290 2
  if (nEntries_ >= fvec->size())
    fvec->resize(fvec->size() + VSIZE);
d292 2
a293 2
  (*fvec)[nEntries_++] = value;        // insert a float value 
  dataType_ = FloatVector;             // will be Float Vector from now on
d300 2
a301 2
  if (nEntries_ >= pvec->size())
    pvec->resize(pvec->size() + VSIZE);
d305 1
a305 1
    if ((*pvec)[i] == value) {
d311 1
a311 1
   (*pvec)[nEntries_] = value;
@


1.11
log
@Continued double precision.
@
text
@d137 1
a137 1
   return getVector (floatFromDouble (defVal));
@


1.10
log
@Added some optional warnings on Linux.
@
text
@d137 1
a137 1
   return getVector (static_cast <float> (defVal));
@


1.9
log
@Changed some C style casts to C++ style.
@
text
@d43 1
a43 1
  intTVec (NULL),
d45 1
a45 1
  nEntries_(0)
@


1.8
log
@Internal changes.
@
text
@d137 1
a137 1
   return getVector ((float) defVal);
@


1.7
log
@Internal changes.
@
text
@d117 1
a117 1
        if (getPeriodVal(j) < 0 ||
d173 1
a173 1
        if (getPeriodVal(j) < 0 ||
@


1.6
log
@modications to change rogueWave tools.h++ to STL
@
text
@d106 1
a106 1
        WitParser::instance ()->currentAttr()->setInvalid(witTRUE);
d162 1
a162 1
        WitParser::instance ()->currentAttr()->setInvalid(witTRUE);
@


1.5
log
@Continued implementation of opt implosion with OSL V3.
@
text
@a31 3
implement (RWGVector, int)
implement (RWGVector, float)

d51 2
a52 2
      ivec = new RWGVector (int) (nPeriods_, 0);
      pvec = new RWGVector (int) (nPeriods_, 0);
d55 2
a56 2
      fvec = new RWGVector (float) (nPeriods_, 0);
      pvec = new RWGVector (int) (nPeriods_, 0);
d247 2
a248 2
  if (nEntries_ >= ivec->length())
    ivec->reshape(ivec->length() + VSIZE);
d258 2
a259 2
  if (nEntries_ >= fvec->length())
    fvec->reshape(fvec->length() + VSIZE);
d269 2
a270 2
  if (nEntries_ >= pvec->length())
    pvec->reshape(pvec->length() + VSIZE);
@


1.5.2.1
log
@Migration from Roguewave tools.h++ to STL
@
text
@d32 3
d54 2
a55 2
      ivec = new std::vector<int> (nPeriods_, 0);
      pvec = new std::vector<int> (nPeriods_, 0);
d58 2
a59 2
      fvec = new std::vector<float> (nPeriods_, 0);
      pvec = new std::vector<int> (nPeriods_, 0);
d250 2
a251 2
  if (nEntries_ >= ivec->size())
    ivec->resize(ivec->size() + VSIZE);
d261 2
a262 2
  if (nEntries_ >= fvec->size())
    fvec->resize(fvec->size() + VSIZE);
d272 2
a273 2
  if (nEntries_ >= pvec->size())
    pvec->resize(pvec->size() + VSIZE);
@


1.4
log
@Preliminary work on single source.
@
text
@d76 1
a76 1
      delete [] intTVec;
d81 1
a81 1
      delete [] floatTVec;
@


1.3
log
@Began implementation of object iteration.
@
text
@d18 1
d29 5
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d27 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

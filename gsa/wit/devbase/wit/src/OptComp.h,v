head	1.124;
access;
symbols
	sce_5_01_20080919:1.57
	latest_sce_4_20_20060523:1.37.0.2
	sce_4_20_20060523:1.37
	latest_sce4_20_OSL:1.34.0.2
	sce_4_20_OSL:1.34
	sce_410_withVa:1.33
	sce_4_05_20040511:1.31
	sce_4_00_20040201:1.29
	nextGenBranch:1.25.0.2
	nextGenRoot:1.25
	sce_3_30_20030627:1.21
	EndRw-branch:1.16.0.4
	Root-of-EndRw:1.16
	rwToStl:1.16.0.2
	latest_sce_3_10_20010924:1.7.0.2
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.6.0.2
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.124
date	2011.09.28.23.49.45;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2011.09.24.00.28.06;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2011.08.30.20.17.47;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2011.08.26.22.54.49;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2011.08.25.23.27.03;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2011.03.02.00.21.13;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2011.02.28.18.50.42;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2011.02.16.17.02.45;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2011.02.15.23.26.03;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2011.02.15.21.20.16;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2011.02.11.15.54.33;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2011.02.10.00.46.33;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2011.02.09.23.31.44;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2011.02.09.19.13.25;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2011.02.08.23.54.40;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2011.02.08.23.21.10;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2011.02.08.21.49.05;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2011.02.07.15.45.58;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2011.01.31.21.21.54;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2011.01.27.19.55.49;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2011.01.25.00.22.59;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2011.01.24.23.57.07;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2011.01.12.23.09.29;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2011.01.11.22.08.28;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.08.00.19.26;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.06.23.31.27;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.12.14.00.22.49;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.12.04.00.29.44;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.12.03.17.19.04;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2010.11.17.20.20.52;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2010.11.12.22.23.20;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2010.10.29.18.07.08;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2010.10.14.16.07.27;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2010.10.12.22.02.21;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2010.10.12.19.48.28;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2010.10.07.15.41.00;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.09.20.20.32;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2010.08.24.16.30.30;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2010.08.19.18.00.13;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.28.18.08.30;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.28.14.40.36;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.27.23.27.55;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2010.05.27.23.06.03;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.21.18.17.56;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.21.15.28.01;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.20.23.18.43;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2010.05.19.21.09.04;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.19.20.34.10;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.14.23.49.06;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.11.22.26.27;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.07.23.18.59;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2010.03.26.22.22.53;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2010.03.16.20.22.39;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2010.03.09.20.12.24;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2010.03.05.00.10.15;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2010.02.05.20.41.53;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2010.02.01.22.10.14;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.31.20.45.10;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2009.12.31.17.10.10;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2009.12.30.23.08.01;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2009.11.26.00.24.09;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2009.11.18.19.00.01;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2009.11.17.23.45.48;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2009.11.17.22.54.49;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2009.11.17.19.31.38;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2009.11.13.19.01.26;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2009.11.12.17.36.36;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2008.02.27.23.19.10;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.13.20.17.39;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.15.21.50.35;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.11.18.09.17;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.08.20.18.12;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.07.21.22.36;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.01.22.41.57;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.08.21.54.42;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.10.21.58.11;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.20.19.44.49;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.03.22.04.04;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.12.06.19.52.46;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.01.21.36.35;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.01.19.55.17;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2006.10.05.20.54.53;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2006.10.03.15.08.59;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2006.09.29.22.56.40;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2006.09.29.18.40.58;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.17.19.36.39;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.16.22.01.07;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.02.17.34.05;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.20.15.42.09;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.24.20.49.13;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.17.17.30.43;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.12.21.29.50;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.03.18.09.57;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.01.23.05.39;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.01.21.01.38;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.29.21.07.35;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.28.23.37.47;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.28.20.34.12;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.18.21.13.38;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.09.20.56.44;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.20.19.03.27;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.30.18.19.11;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.28.22.19.30;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.24.20.40.20;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.02.22.18.38;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.11.19.53.56;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.11.18.53.11;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.09.16.04.38;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.29.17.57.51;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.26.22.49.04;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.23.21.00.38;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.23.18.09.13;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.22.14.01.48;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.01.14.25.58;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.29.21.37.19;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.17.15.11.16;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.04.22.27.52;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.45;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.20.03.26;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.31;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches;
next	;


desc
@@


1.124
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef OptCompH
#define OptCompH

//------------------------------------------------------------------------------
// Header file: "OptComp.h"
//
// Contains the declaration of class OptComp.
//------------------------------------------------------------------------------

#include <Component.h>
#include <Str.h>

//------------------------------------------------------------------------------
// class OptComp
//
// Responsible for the global attributes of a Problem that are specific to
// optimizing implosion.
//
// Class Hierarchy:
//
// ProbAssoc
//    Component
//       OptComp
//------------------------------------------------------------------------------

class WitOptComp: public WitComponent
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitOptComp (WitCompMgr * theCompMgr);
         //
         // Component <<< theCompMgr.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitOptComp ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitOptStarter *,                heurOptStarter)
      accessFunc (WitOptStarter *,                 accOptStarter)
      accessFunc (WitOptStarter *,               schedOptStarter)
      accessFunc (WitOptStarter *,               crashOptStarter)
      accessFunc (const WitList <WitOptStarter> &, allOptStarters)
      accessFunc (WitCpxParSpecMgr *,            myCpxParSpecMgr)
      accessFunc (bool,                          compPrices)
      accessFunc (bool,                          accAfterOptImp)
      accessFunc (bool,                          accAfterSoftLB)
      accessFunc (bool,                          mipMode)
      accessFunc (bool,                          multiObjMode)
      accessFunc (int,                           objChoice)
      accessFunc (double,                        wbounds)
      accessFunc (WitOptStarter *,               optInitMethod)
      accessFunc (const WitString &,             solverLogFileName)
      accessFunc (double,                        boundsValue)
      accessFunc (bool,                          boundsValueValid)
      accessFunc (int,                           cplexStatusCode)
      accessFunc (const WitString &,             cplexStatusText)
      accessFunc (double,                        cplexMipBound)
      accessFunc (double,                        cplexMipRelGap)
      accessFunc (bool,                          printOptProblem)
      accessFunc (bool,                          printMatByCols)
      accessFunc (bool,                          printInitSoln)
      accessFunc (bool,                          printOptSoln)
      accessFunc (bool,                          printMps)
      accessFunc (bool,                          skipScreening)

      inline WitMultiObjMgr * myMultiObjMgr ()
         {
         witAssert (multiObjMode_);

         return myMultiObjMgr_;
         }

      //------------------------------------------------------------------------
      // Default value functions.
      //------------------------------------------------------------------------

      defaultValue (bool         defCompPrices,        false)
      defaultValue (bool         defAccAfterOptImp,    false)
      defaultValue (bool         defAccAfterSoftLB,    false)
      defaultValue (bool         defMipMode,           false)
      defaultValue (bool         defMultiObjMode,      false)
      defaultValue (double       defWbounds,           1.0e4)
      defaultValue (const char * defSolverLogFileName, "solver.log")
      defaultValue (int          defObjChoice,         1)

      WitOptStarter * defOptInitMethod () const;

      //------------------------------------------------------------------------
      // "Set" functions.
      //------------------------------------------------------------------------

      void setCompPrices        (bool);
      void setAccAfterOptImp    (bool);
      void setAccAfterSoftLB    (bool);
      void setMipMode           (bool);
      void setMultiObjMode      (bool);
      void setObjChoice         (int);
      void setWbounds           (double);
      void setSolverLogFileName (const char *);
      void setPrintOptProblem   (bool);
      void setPrintMatByCols    (bool);
      void setPrintInitSoln     (bool);
      void setPrintOptSoln      (bool);
      void setPrintMps          (bool);
      void setSkipScreening     (bool);

      //------------------------------------------------------------------------
      // store<Activity><Attr> functions.
      // Each of these functions sets the value of indicated attribute to the
      // value of the argument.
      // Each function is only valid when the indicated activity is being
      // performed.
      //------------------------------------------------------------------------

      void storeOptObjValue    (double);
      void storeOptBoundsValue (double);
         //
         // Valid only when the optimizing implosion subsystem is uploading the
         // solution.

      void storeStochObjValue    (double);
      void storeStochBoundsValue (double);
         //
         // Valid only when the stochastic implosion subsystem is uploading
         // data.

      void storeCplexStatusCode (int);
      void storeCplexStatusText (const char *);
      void storeCplexMipBound   (double);
      void storeCplexMipRelGap  (double);
         //
         // Valid only in cplexEmbedded mode.

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual bool inserted       ();
      virtual void copySelfInto   (WitCompMgr * theCompMgr);
      virtual void recount        ();
      virtual void clearStochSoln ();
         //
         // Overrides from class Component.

      double objValue () const;
         //
         // In single objective mode:
         //    Returns the objective function value.
         // In multiple objectives mode:
         //    Returns the objective function value of the current Objective.

      void unpostprocess ();
         //
         // Does unpostprocessing for this OptComp.

      void display ();
         //
         // Displays the input and preprocessing data for this OptComp.

      void choose (WitOptStarter * theOptStarter);
         //
         // Sets optInitMethod_ to theOptStarter.
         // No-op (with warning), if an accOptStarter is requested and
         // myDetOptImpMgr () is not accelerated.

      void store (WitOptStarter * theOptStarter);
         //
         // Stores theOptStarter in this OptComp.

      bool negativeCostsExist ();
         //
         // Returns true, iff there is at least one cost coefficient < 0.

      void requireCplex ();
         //
         // Verifies that CPLEX was embedded.

      void writeObjValue ();
         //
         // Writes the objValue attribute to the message file.

      static bool cplexEmbedded ();
         //
         // Returns true, iff CPLEX was embedded into the current build of WIT.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitOptComp);

      void setUpOptStarters ();
         //
         // Sets up the OptStarters for this OptComp.

      void checkAccAfter ();
         //
         // Issues a warning if accAfterSoftLB () is true and accAfterOptImp ()
         // is false.

      virtual void writeDataID    ();
      virtual void writeDataAttrs ();
         //
         // Overrides from class Component.

      void copyAttrsFrom (WitOptComp * theOptComp);
         //
         // Copies the input attributes of theOptComp into this OptComp.

      inline double & sglObjValue () const;
         //
         // Valid in single objective mode only.
         // Returns a reference to the main objective function value

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitOptStarter *  heurOptStarter_;
      WitOptStarter *   accOptStarter_;
      WitOptStarter * schedOptStarter_;
      WitOptStarter * crashOptStarter_;
         //
         // The OptStarters for this OptComp.

      WitList <WitOptStarter> allOptStarters_;
         //
         // The List of all possible OptStarters.
         // Specifically, this List contains one instance of each concrete
         // OptStarter class (stored abstractly as an OptStarter *).

      WitCpxParSpecMgr * myCpxParSpecMgr_;
         //
         // The CpxParSpecMgr owned by this OptComp.

      WitMultiObjMgr * myMultiObjMgr_;
         //
         // The MultiObjMgr owned by this OptComp in multiple objectives mode;
         // NULL, in single objective mode.

      //------------------------------------------------------------------------
      // Private input data.
      //------------------------------------------------------------------------

      bool compPrices_;
         //
         // true, iff shadow prices on parts are to be computed.

      bool accAfterOptImp_;
         //
         // true, iff opt implosion is to stay in an accelerated
         // state at the end of an implosion.
         // If false, opt implosion will shot down when it completes.

      bool accAfterSoftLB_;
         //
         // true, iff the Optimploder is in accelerated bounds mode.
         // If an DetOptImpMgr is in accelerated bounds mode, then arbitrary
         // changes can be made to a BoundSet without shutting down opt
         // implosion. If it is not in accelerated bounds mode, then whenever a
         // change is made to a BoundSet such that a lower bound that used to be
         // hard becomes soft, opt implosion is shut down. Other changes to a
         // BoundSet do not cause a shut down. The disadvantage of
         // accelerated bounds mode is that it causes a somewhat larger
         // optimization problem to be generated, which is somewhat slower to
         // solve.

      bool mipMode_;
         //
         // If true,  optimizing implosion will be solved as a MIP.
         // If false, optimizing implosion will be solved as an LP.

      bool multiObjMode_;
         //
         // True, iff WIT is in multiple objectives mode.

      int objChoice_;
         //
         // Obsolete attribute: has no effect.

      double wbounds_;
         //
         // Weight on the bounds objective.

      WitOptStarter * optInitMethod_;
         //
         // The OptStarter currently selected.

      WitString solverLogFileName_;
         //
         // Name of the solver log output file.

      //------------------------------------------------------------------------
      // Solution data.
      //------------------------------------------------------------------------

      double * sglObjValuePtr_;
         //
         // In single objective mode:
         //    Ptr to the main objective function value
         // In  multiple objectives mode:
         //    NULL

      double boundsValue_;
         //
         // Bounds objective function value.

      bool boundsValueValid_;
         //
         // true, iff the current value of boundsValue_ is valid.

      int cplexStatusCode_;
         //
         // If a CPLEX solve routine has been called, cplexStatusCode_ is the
         // solution status code resulting from the most recent call.
         // Otherwise cplexStatusCode_ is -1.

      WitString cplexStatusText_;
         //
         // If a CPLEX solve routine has been called, cplexStatusText_ is the
         // string indicating the solution status resulting from the most recent
         // call.

      double cplexMipBound_;
         //
         // If the CPLEX MIP solver has been invoked, cplexMipBound_ is the
         // tightest upper bound that it found on the optimal objective function
         // value.
         // If the CPLEX MIP solver has not been invoked, cplexMipBound_ is 0.0.

      double cplexMipRelGap_;
         //
         // If the CPLEX MIP solver has been invoked, cplexMipRelGap_ is the
         // relative objective function value gap for the solution:
         //    (cplexMipBound_ - objValue) / (1.e-10 + |cplexMipBound_|)
         // Otherwise cplexMipRelGap_ is -1.0.

      //------------------------------------------------------------------------
      // Development mode control parameters.
      //------------------------------------------------------------------------

      bool printOptProblem_;
         //
         // Print the optimization problem.

      bool printMatByCols_;
         //
         // Print the matrix by columns.

      bool printInitSoln_;
         //
         // Print the initial optimization solution.

      bool printOptSoln_;
         //
         // Print the final optimization solution.

      bool printMps_;
         //
         // Print an MPS file.

      bool skipScreening_;
         //
         // Skip screening of the opt problem.
   };

#endif
@


1.123
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 2
//------------------------------------------------------------------------------

d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.122
log
@Revised the copyright date.
@
text
@d4 1
a4 1
//     (c) Copyright IBM Corp. 2011.
d7 2
a8 2
//     IBM Confidential
//
d37 2
a38 156
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitOptComp (WitCompMgr * theCompMgr);
//
// Component <<< theCompMgr.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

virtual ~WitOptComp ();

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (WitOptStarter *,                heurOptStarter)
accessFunc (WitOptStarter *,                 accOptStarter)
accessFunc (WitOptStarter *,               schedOptStarter)
accessFunc (WitOptStarter *,               crashOptStarter)
accessFunc (const WitList <WitOptStarter> &, allOptStarters)
accessFunc (WitCpxParSpecMgr *,            myCpxParSpecMgr)
accessFunc (bool,                          compPrices)
accessFunc (bool,                          accAfterOptImp)
accessFunc (bool,                          accAfterSoftLB)
accessFunc (bool,                          mipMode)
accessFunc (bool,                          multiObjMode)
accessFunc (int,                           objChoice)
accessFunc (double,                        wbounds)
accessFunc (WitOptStarter *,               optInitMethod)
accessFunc (const WitString &,             solverLogFileName)
accessFunc (double,                        boundsValue)
accessFunc (bool,                          boundsValueValid)
accessFunc (int,                           cplexStatusCode)
accessFunc (const WitString &,             cplexStatusText)
accessFunc (double,                        cplexMipBound)
accessFunc (double,                        cplexMipRelGap)
accessFunc (bool,                          printOptProblem)
accessFunc (bool,                          printMatByCols)
accessFunc (bool,                          printInitSoln)
accessFunc (bool,                          printOptSoln)
accessFunc (bool,                          printMps)
accessFunc (bool,                          skipScreening)

inline WitMultiObjMgr * myMultiObjMgr ()
{
witAssert (multiObjMode_);

return myMultiObjMgr_;
}

//------------------------------------------------------------------------
// Default value functions.
//------------------------------------------------------------------------

defaultValue (bool         defCompPrices,        false)
defaultValue (bool         defAccAfterOptImp,    false)
defaultValue (bool         defAccAfterSoftLB,    false)
defaultValue (bool         defMipMode,           false)
defaultValue (bool         defMultiObjMode,      false)
defaultValue (double       defWbounds,           1.0e4)
defaultValue (const char * defSolverLogFileName, "solver.log")
defaultValue (int          defObjChoice,         1)

WitOptStarter * defOptInitMethod () const;

//------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------

void setCompPrices        (bool);
void setAccAfterOptImp    (bool);
void setAccAfterSoftLB    (bool);
void setMipMode           (bool);
void setMultiObjMode      (bool);
void setObjChoice         (int);
void setWbounds           (double);
void setSolverLogFileName (const char *);
void setPrintOptProblem   (bool);
void setPrintMatByCols    (bool);
void setPrintInitSoln     (bool);
void setPrintOptSoln      (bool);
void setPrintMps          (bool);
void setSkipScreening     (bool);

//------------------------------------------------------------------------
// store<Activity><Attr> functions.
// Each of these functions sets the value of indicated attribute to the
// value of the argument.
// Each function is only valid when the indicated activity is being
// performed.
//------------------------------------------------------------------------

void storeOptObjValue    (double);
void storeOptBoundsValue (double);
//
// Valid only when the optimizing implosion subsystem is uploading the
// solution.

void storeStochObjValue    (double);
void storeStochBoundsValue (double);
//
// Valid only when the stochastic implosion subsystem is uploading
// data.

void storeCplexStatusCode (int);
void storeCplexStatusText (const char *);
void storeCplexMipBound   (double);
void storeCplexMipRelGap  (double);
//
// Valid only in cplexEmbedded mode.

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

virtual bool inserted       ();
virtual void copySelfInto   (WitCompMgr * theCompMgr);
virtual void recount        ();
virtual void clearStochSoln ();
//
// Overrides from class Component.

double objValue () const;
//
// In single objective mode:
//    Returns the objective function value.
// In multiple objectives mode:
//    Returns the objective function value of the current Objective.

void unpostprocess ();
//
// Does unpostprocessing for this OptComp.

void display ();
//
// Displays the input and preprocessing data for this OptComp.

void choose (WitOptStarter * theOptStarter);
//
// Sets optInitMethod_ to theOptStarter.
// No-op (with warning), if an accOptStarter is requested and
// myDetOptImpMgr () is not accelerated.

void store (WitOptStarter * theOptStarter);
//
// Stores theOptStarter in this OptComp.

bool negativeCostsExist ();
//
// Returns true, iff there is at least one cost coefficient < 0.
d40 348
a387 194
void requireCplex ();
//
// Verifies that CPLEX was embedded.

void writeObjValue ();
//
// Writes the objValue attribute to the message file.

static bool cplexEmbedded ();
//
// Returns true, iff CPLEX was embedded into the current build of WIT.

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitOptComp);

void setUpOptStarters ();
//
// Sets up the OptStarters for this OptComp.

void checkAccAfter ();
//
// Issues a warning if accAfterSoftLB () is true and accAfterOptImp ()
// is false.

virtual void writeDataID    ();
virtual void writeDataAttrs ();
//
// Overrides from class Component.

void copyAttrsFrom (WitOptComp * theOptComp);
//
// Copies the input attributes of theOptComp into this OptComp.

inline double & sglObjValue () const;
//
// Valid in single objective mode only.
// Returns a reference to the main objective function value

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

WitOptStarter *  heurOptStarter_;
WitOptStarter *   accOptStarter_;
WitOptStarter * schedOptStarter_;
WitOptStarter * crashOptStarter_;
//
// The OptStarters for this OptComp.

WitList <WitOptStarter> allOptStarters_;
//
// The List of all possible OptStarters.
// Specifically, this List contains one instance of each concrete
// OptStarter class (stored abstractly as an OptStarter *).

WitCpxParSpecMgr * myCpxParSpecMgr_;
//
// The CpxParSpecMgr owned by this OptComp.

WitMultiObjMgr * myMultiObjMgr_;
//
// The MultiObjMgr owned by this OptComp in multiple objectives mode;
// NULL, in single objective mode.

//------------------------------------------------------------------------
// Private input data.
//------------------------------------------------------------------------

bool compPrices_;
//
// true, iff shadow prices on parts are to be computed.

bool accAfterOptImp_;
//
// true, iff opt implosion is to stay in an accelerated
// state at the end of an implosion.
// If false, opt implosion will shot down when it completes.

bool accAfterSoftLB_;
//
// true, iff the Optimploder is in accelerated bounds mode.
// If an DetOptImpMgr is in accelerated bounds mode, then arbitrary
// changes can be made to a BoundSet without shutting down opt
// implosion. If it is not in accelerated bounds mode, then whenever a
// change is made to a BoundSet such that a lower bound that used to be
// hard becomes soft, opt implosion is shut down. Other changes to a
// BoundSet do not cause a shut down. The disadvantage of
// accelerated bounds mode is that it causes a somewhat larger
// optimization problem to be generated, which is somewhat slower to
// solve.

bool mipMode_;
//
// If true,  optimizing implosion will be solved as a MIP.
// If false, optimizing implosion will be solved as an LP.

bool multiObjMode_;
//
// True, iff WIT is in multiple objectives mode.

int objChoice_;
//
// Obsolete attribute: has no effect.

double wbounds_;
//
// Weight on the bounds objective.

WitOptStarter * optInitMethod_;
//
// The OptStarter currently selected.

WitString solverLogFileName_;
//
// Name of the solver log output file.

//------------------------------------------------------------------------
// Solution data.
//------------------------------------------------------------------------

double * sglObjValuePtr_;
//
// In single objective mode:
//    Ptr to the main objective function value
// In  multiple objectives mode:
//    NULL

double boundsValue_;
//
// Bounds objective function value.

bool boundsValueValid_;
//
// true, iff the current value of boundsValue_ is valid.

int cplexStatusCode_;
//
// If a CPLEX solve routine has been called, cplexStatusCode_ is the
// solution status code resulting from the most recent call.
// Otherwise cplexStatusCode_ is -1.

WitString cplexStatusText_;
//
// If a CPLEX solve routine has been called, cplexStatusText_ is the
// string indicating the solution status resulting from the most recent
// call.

double cplexMipBound_;
//
// If the CPLEX MIP solver has been invoked, cplexMipBound_ is the
// tightest upper bound that it found on the optimal objective function
// value.
// If the CPLEX MIP solver has not been invoked, cplexMipBound_ is 0.0.

double cplexMipRelGap_;
//
// If the CPLEX MIP solver has been invoked, cplexMipRelGap_ is the
// relative objective function value gap for the solution:
//    (cplexMipBound_ - objValue) / (1.e-10 + |cplexMipBound_|)
// Otherwise cplexMipRelGap_ is -1.0.

//------------------------------------------------------------------------
// Development mode control parameters.
//------------------------------------------------------------------------

bool printOptProblem_;
//
// Print the optimization problem.

bool printMatByCols_;
//
// Print the matrix by columns.

bool printInitSoln_;
//
// Print the initial optimization solution.

bool printOptSoln_;
//
// Print the final optimization solution.

bool printMps_;
//
// Print an MPS file.

bool skipScreening_;
//
// Skip screening of the opt problem.
};
@


1.121
log
@Revisions for the removal of COIN.
@
text
@d4 1
a4 1
//     (c) Copyright IBM Corp. 2006.
d7 2
a8 2
//     IBM Confidential 
// 
d37 156
a192 2
   {
   public:
d194 194
a387 348
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitOptComp (WitCompMgr * theCompMgr);
         //
         // Component <<< theCompMgr.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitOptComp ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitOptStarter *,                heurOptStarter)
      accessFunc (WitOptStarter *,                 accOptStarter)
      accessFunc (WitOptStarter *,               schedOptStarter)
      accessFunc (WitOptStarter *,               crashOptStarter)
      accessFunc (const WitList <WitOptStarter> &, allOptStarters)
      accessFunc (WitCpxParSpecMgr *,            myCpxParSpecMgr)
      accessFunc (bool,                          compPrices)
      accessFunc (bool,                          accAfterOptImp)
      accessFunc (bool,                          accAfterSoftLB)
      accessFunc (bool,                          mipMode)
      accessFunc (bool,                          multiObjMode)
      accessFunc (int,                           objChoice)
      accessFunc (double,                        wbounds)
      accessFunc (WitOptStarter *,               optInitMethod)
      accessFunc (const WitString &,             solverLogFileName)
      accessFunc (double,                        boundsValue)
      accessFunc (bool,                          boundsValueValid)
      accessFunc (int,                           cplexStatusCode)
      accessFunc (const WitString &,             cplexStatusText)
      accessFunc (double,                        cplexMipBound)
      accessFunc (double,                        cplexMipRelGap)
      accessFunc (bool,                          printOptProblem)
      accessFunc (bool,                          printMatByCols)
      accessFunc (bool,                          printInitSoln)
      accessFunc (bool,                          printOptSoln)
      accessFunc (bool,                          printMps)
      accessFunc (bool,                          skipScreening)

      inline WitMultiObjMgr * myMultiObjMgr ()
         {
         witAssert (multiObjMode_);

         return myMultiObjMgr_;
         }

      //------------------------------------------------------------------------
      // Default value functions.
      //------------------------------------------------------------------------

      defaultValue (bool         defCompPrices,        false)
      defaultValue (bool         defAccAfterOptImp,    false)
      defaultValue (bool         defAccAfterSoftLB,    false)
      defaultValue (bool         defMipMode,           false)
      defaultValue (bool         defMultiObjMode,      false)
      defaultValue (double       defWbounds,           1.0e4)
      defaultValue (const char * defSolverLogFileName, "solver.log")
      defaultValue (int          defObjChoice,         1)

      WitOptStarter * defOptInitMethod () const;

      //------------------------------------------------------------------------
      // "Set" functions.
      //------------------------------------------------------------------------

      void setCompPrices        (bool);
      void setAccAfterOptImp    (bool);
      void setAccAfterSoftLB    (bool);
      void setMipMode           (bool);
      void setMultiObjMode      (bool);
      void setObjChoice         (int);
      void setWbounds           (double);
      void setSolverLogFileName (const char *);
      void setPrintOptProblem   (bool);
      void setPrintMatByCols    (bool);
      void setPrintInitSoln     (bool);
      void setPrintOptSoln      (bool);
      void setPrintMps          (bool);
      void setSkipScreening     (bool);

      //------------------------------------------------------------------------
      // store<Activity><Attr> functions.
      // Each of these functions sets the value of indicated attribute to the
      // value of the argument.
      // Each function is only valid when the indicated activity is being
      // performed.
      //------------------------------------------------------------------------

      void storeOptObjValue    (double);
      void storeOptBoundsValue (double);
         //
         // Valid only when the optimizing implosion subsystem is uploading the
         // solution.

      void storeStochObjValue    (double);
      void storeStochBoundsValue (double);
         //
         // Valid only when the stochastic implosion subsystem is uploading
         // data.

      void storeCplexStatusCode (int);
      void storeCplexStatusText (const char *);
      void storeCplexMipBound   (double);
      void storeCplexMipRelGap  (double);
         //
         // Valid only in cplexEmbedded mode.

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual bool inserted       ();
      virtual void copySelfInto   (WitCompMgr * theCompMgr);
      virtual void recount        ();
      virtual void clearStochSoln ();
         //
         // Overrides from class Component.

      double objValue () const;
         //
         // In single objective mode:
         //    Returns the objective function value.
         // In multiple objectives mode:
         //    Returns the objective function value of the current Objective.

      void unpostprocess ();
         //
         // Does unpostprocessing for this OptComp.

      void display ();
         //
         // Displays the input and preprocessing data for this OptComp.

      void choose (WitOptStarter * theOptStarter);
         //
         // Sets optInitMethod_ to theOptStarter.
         // No-op (with warning), if an accOptStarter is requested and
         // myDetOptImpMgr () is not accelerated.

      void store (WitOptStarter * theOptStarter);
         //
         // Stores theOptStarter in this OptComp.

      bool negativeCostsExist ();
         //
         // Returns true, iff there is at least one cost coefficient < 0.

      void requireCplex ();
         //
         // Verifies that CPLEX was embedded.

      void writeObjValue ();
         //
         // Writes the objValue attribute to the message file.

      static bool cplexEmbedded ();
         //
         // Returns true, iff CPLEX was embedded into the current build of WIT.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitOptComp);

      void setUpOptStarters ();
         //
         // Sets up the OptStarters for this OptComp.

      void checkAccAfter ();
         //
         // Issues a warning if accAfterSoftLB () is true and accAfterOptImp ()
         // is false.

      virtual void writeDataID    ();
      virtual void writeDataAttrs ();
         //
         // Overrides from class Component.

      void copyAttrsFrom (WitOptComp * theOptComp);
         //
         // Copies the input attributes of theOptComp into this OptComp.

      inline double & sglObjValue () const;
         //
         // Valid in single objective mode only.
         // Returns a reference to the main objective function value

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitOptStarter *  heurOptStarter_;
      WitOptStarter *   accOptStarter_;
      WitOptStarter * schedOptStarter_;
      WitOptStarter * crashOptStarter_;
         //
         // The OptStarters for this OptComp.

      WitList <WitOptStarter> allOptStarters_;
         //
         // The List of all possible OptStarters.
         // Specifically, this List contains one instance of each concrete
         // OptStarter class (stored abstractly as an OptStarter *).

      WitCpxParSpecMgr * myCpxParSpecMgr_;
         //
         // The CpxParSpecMgr owned by this OptComp.

      WitMultiObjMgr * myMultiObjMgr_;
         //
         // The MultiObjMgr owned by this OptComp in multiple objectives mode;
         // NULL, in single objective mode.

      //------------------------------------------------------------------------
      // Private input data.
      //------------------------------------------------------------------------

      bool compPrices_;
         //
         // true, iff shadow prices on parts are to be computed.

      bool accAfterOptImp_;
         //
         // true, iff opt implosion is to stay in an accelerated
         // state at the end of an implosion.
         // If false, opt implosion will shot down when it completes.

      bool accAfterSoftLB_;
         //
         // true, iff the Optimploder is in accelerated bounds mode.
         // If an DetOptImpMgr is in accelerated bounds mode, then arbitrary
         // changes can be made to a BoundSet without shutting down opt
         // implosion. If it is not in accelerated bounds mode, then whenever a
         // change is made to a BoundSet such that a lower bound that used to be
         // hard becomes soft, opt implosion is shut down. Other changes to a
         // BoundSet do not cause a shut down. The disadvantage of
         // accelerated bounds mode is that it causes a somewhat larger
         // optimization problem to be generated, which is somewhat slower to
         // solve.

      bool mipMode_;
         //
         // If true,  optimizing implosion will be solved as a MIP.
         // If false, optimizing implosion will be solved as an LP.

      bool multiObjMode_;
         //
         // True, iff WIT is in multiple objectives mode.

      int objChoice_;
         //
         // Obsolete attribute: has no effect.

      double wbounds_;
         //
         // Weight on the bounds objective.

      WitOptStarter * optInitMethod_;
         //
         // The OptStarter currently selected.

      WitString solverLogFileName_;
         //
         // Name of the solver log output file.

      //------------------------------------------------------------------------
      // Solution data.
      //------------------------------------------------------------------------

      double * sglObjValuePtr_;
         //
         // In single objective mode:
         //    Ptr to the main objective function value
         // In  multiple objectives mode:
         //    NULL

      double boundsValue_;
         //
         // Bounds objective function value.

      bool boundsValueValid_;
         //
         // true, iff the current value of boundsValue_ is valid.

      int cplexStatusCode_;
         //
         // If a CPLEX solve routine has been called, cplexStatusCode_ is the
         // solution status code resulting from the most recent call.
         // Otherwise cplexStatusCode_ is -1.

      WitString cplexStatusText_;
         //
         // If a CPLEX solve routine has been called, cplexStatusText_ is the
         // string indicating the solution status resulting from the most recent
         // call.

      double cplexMipBound_;
         //
         // If the CPLEX MIP solver has been invoked, cplexMipBound_ is the
         // tightest upper bound that it found on the optimal objective function
         // value.
         // If the CPLEX MIP solver has not been invoked, cplexMipBound_ is 0.0.

      double cplexMipRelGap_;
         //
         // If the CPLEX MIP solver has been invoked, cplexMipRelGap_ is the
         // relative objective function value gap for the solution:
         //    (cplexMipBound_ - objValue) / (1.e-10 + |cplexMipBound_|)
         // Otherwise cplexMipRelGap_ is -1.0.

      //------------------------------------------------------------------------
      // Development mode control parameters.
      //------------------------------------------------------------------------

      bool printOptProblem_;
         //
         // Print the optimization problem.

      bool printMatByCols_;
         //
         // Print the matrix by columns.

      bool printInitSoln_;
         //
         // Print the initial optimization solution.

      bool printOptSoln_;
         //
         // Print the final optimization solution.

      bool printMps_;
         //
         // Print an MPS file.

      bool skipScreening_;
         //
         // Skip screening of the opt problem.
   };
@


1.120
log
@Removed COIN from WIT.
@
text
@d202 4
@


1.119
log
@Added severe error for selecting a solver that's not embedded.
@
text
@a63 3
      accessFunc (int,                           coinLogLevel)
      accessFunc (bool,                          coinSelected)
      accessFunc (bool,                          cplexSelected)
a72 1
      accessFunc (int,                           accMethod)
a103 1
      defaultValue (int          defAccMethod,         0)
a107 3
      static bool     defCoinSelected  ();
      static bool     defCplexSelected ();

a111 3
      void setCoinLogLevel      (int);
      void setCoinSelected      (bool);
      void setCplexSelected     (bool);
a119 1
      void setAccMethod         (int);
d152 1
a152 1
         // Valid only in cplexSelected mode.
d194 1
a194 1
      void requireSolver ();
d196 1
a196 1
         // Verifies that a solver is selected.
a258 4
      int coinLogLevel_;
         //
         // Log level for COIN messages.

a262 8
      bool coinSelected_;
         //
         // true, iff COIN  is selected as the solver.

      bool cplexSelected_;
         //
         // true, iff CPLEX is selected as the solver.

d309 1
a309 10
         // Name of COIN log output file.

      int accMethod_;
         //
         // Determines how to solve the LP with COIN in acclerated mode.
         //
         // 0: No extra output; primal or dual simplex as needed.
         // 1     Extra output; primal or dual simplex as needed.
         // 2:    Extra output; primal simplex.
         // 3:    Extra output; dual   simplex.
@


1.118
log
@Revised the default values of coinSelected and cplexSelected.
@
text
@d206 1
a206 1
      void validateSolver ();
d208 1
a208 2
         // Verifies that an appropriate solver has been selected for
         // deterministic ot stochastic implosion.
@


1.117
log
@CPLEX
@
text
@a100 2
      defaultValue (bool         defCoinSelected,      true)
      defaultValue (bool         defCplexSelected,     false)
d113 3
@


1.116
log
@CPLEX
@
text
@d81 2
a82 2
      accessFunc (double,                        cplexObjBound)
      accessFunc (double,                        cplexObjRelGap)
d160 2
a161 2
      void storeCplexObjBound   (double);
      void storeCplexObjRelGap  (double);
d375 1
a375 1
      double cplexObjBound_;
d377 1
a377 1
         // If the CPLEX MIP solver has been invoked, cplexObjBound_ is the
d380 1
a380 1
         // If the CPLEX MIP solver has not been invoked, cplexObjBound_ is 0.0.
d382 1
a382 1
      double cplexObjRelGap_;
d384 1
a384 1
         // If the CPLEX MIP solver has been invoked, cplexObjRelGap_ is the
d386 2
a387 2
         //    (cplexObjBound_ - objValue) / (1.e-10 + |cplexObjBound_|)
         // Otherwise cplexObjRelGap_ is -1.0.
@


1.115
log
@CPLEX
@
text
@d82 1
a82 1
      accessFunc (double,                        cplexMipRelGap)
d161 1
a161 1
      void storeCplexMipRelGap  (double);
d382 1
a382 1
      double cplexMipRelGap_;
d384 2
a385 2
         // If the CPLEX MIP solver has been invoked, cplexMipRelGap_ is the
         // relative objective gap for the solution_:
d387 1
a387 1
         // Otherwise cplexMipRelGap_ is -1.0.
@


1.114
log
@CPLEX
@
text
@d82 1
d158 4
a161 6
      void storeCplexStatus (int theStatusCode, const char * theStatusText);
         //
         // Stores cplexStatusCode_ and cplexStatusText_.
         // Valid only in cplexSelected mode.

      void storeCplexObjBound (double);
d382 7
@


1.113
log
@CPLEX
@
text
@d379 2
a380 2
         // upper best bound on the optimal objective function value that it has
         // found.
@


1.112
log
@CPLEX
@
text
@d81 1
d162 4
d376 7
@


1.111
log
@CPLEX
@
text
@d165 4
a168 5
      virtual bool       inserted       ();
      virtual WitMsgFrag classMsgFrag   ();
      virtual void       copySelfInto   (WitCompMgr * theCompMgr);
      virtual void       recount        ();
      virtual void       clearStochSoln ();
@


1.110
log
@CPLEX
@
text
@a17 5
//
// Contains the declaration of the following NonClass functions:
//
//    coinEmbedded  ()
//    cplexEmbedded ()
a23 26
// NonClass function coinEmbedded ()
//------------------------------------------------------------------------------

namespace WitNonClass
   {
   bool coinEmbedded ();
      //
      // Returns true, iff COIN was embedded into the current build of WIT.
      //
      // Implemented in CoinSolver.C.
   };

//------------------------------------------------------------------------------
// NonClass function cplexEmbedded ()
//------------------------------------------------------------------------------

namespace WitNonClass
   {
   bool cplexEmbedded ();
      //
      // Returns true, iff CPLEX was embedded into the current build of WIT.
      //
      // Implemented in CplexSolver.C.
   };

//------------------------------------------------------------------------------
@


1.109
log
@CPLEX
@
text
@d401 1
a401 1
         // call. Otherwise cplexStatusText_ is "(undefined)".
@


1.108
log
@CPLEX
@
text
@d111 1
d187 1
a187 1
      void storeCplexStatusCode (int);
d189 1
d397 6
@


1.107
log
@CPLEX Parameters
@
text
@d110 1
a110 1
      accessFunc (int,                           cplexSolnStatus)
d186 1
a186 1
      void storeCplexSolnStatus (int);
d389 1
a389 1
      int cplexSolnStatus_;
d391 3
a393 3
         // If a CPLEX solve routine has been called, cplexSolnStatus_ is the
         // solution status resulting from the most recent call.
         // Otherwise cplexSolnStatus_ is -1.
@


1.106
log
@CPLEX solution status
@
text
@d110 1
a110 1
      accessFunc (int,                           cpxSolnStatus)
d186 1
a186 1
      void storeCpxSolnStatus (int);
d389 1
a389 1
      int cpxSolnStatus_;
d391 1
a391 1
         // If a CPLEX solve routine has been called, cpxSolnStatus_ is the
d393 1
a393 1
         // Otherwise cpxSolnStatus_ is -1.
@


1.105
log
@CPLEX Solution Status
@
text
@d110 1
a110 1
      accessFunc (int,                           cpxStat)
d186 1
a186 1
      void storeCpxStat (int);
d389 1
a389 1
      int cpxStat_;
d391 3
a393 3
         // If a CPLEX solve routine has been called, cpxStat_ is the solution
         // status resulting from the most recent call.
         // Otherwise cpxStat_ is -1.
@


1.104
log
@CPLEX Parameters
@
text
@d110 1
d186 4
d389 6
@


1.103
log
@CPLEX Parameters
@
text
@a115 1
      accessFunc (int,                           cpxSimDisplay)
a163 1
      void setCpxSimDisplay     (int);
a410 4

      int cpxSimDisplay_;
         //
         // The CPLEX paramater CPX_PARAM_SIMDISPLAY will be set to this value.
@


1.102
log
@CPX Param Specs
@
text
@a116 1
      accessFunc (bool,                          allowCpxParSpec)
a165 1
      void setAllowCpxParSpec   (bool);
a416 4

      bool allowCpxParSpec_;
         //
         // CPLEX parameter setting is allowed, iff allowCpxParSpec_ is true.
@


1.101
log
@CPX Params
@
text
@d94 1
a94 1
      accessFunc (WitCpxParamMgr *,              myCpxParamMgr)
d117 1
a117 1
      accessFunc (bool,                          allowCpxParams)
d167 1
a167 1
      void setAllowCpxParams    (bool);
d287 1
a287 1
      WitCpxParamMgr * myCpxParamMgr_;
d289 1
a289 1
         // The CpxParamMgr owned by this OptComp.
d420 1
a420 1
      bool allowCpxParams_;
d422 1
a422 1
         // CPLEX parameter control is allowed, iff allowCpxParams_ is true.
@


1.100
log
@CPX Params
@
text
@d94 1
@


1.99
log
@CPX Params
@
text
@d286 4
@


1.98
log
@CPLEX
@
text
@d116 1
d166 1
d414 4
@


1.97
log
@CPLEX
@
text
@a114 1
      accessFunc (bool,                          allowMultiCplex)
a163 1
      void setAllowMultiCplex   (bool);
a408 4
      bool allowMultiCplex_;
         //
         // Allow multi-objective mode with CPLEX as the solver.

@


1.96
log
@CPLEX
@
text
@d115 1
d165 1
d411 4
@


1.95
log
@CPLEX
@
text
@a115 1
      accessFunc (bool,                          allowMipCplex)
a164 1
      void setAllowMipCplex     (bool);
a411 4

      bool allowMipCplex_;
         //
         // MIP mode with CPLEX selected is allowed iff, allowMipCplex is true.
@


1.94
log
@CPLEX
@
text
@d2 1
d116 1
d166 1
d414 4
@


1.93
log
@CPLEX
@
text
@a114 1
      accessFunc (bool,                          accCplexAllowed)
a163 1
      void setAccCplexAllowed   (bool);
a410 8

      //------------------------------------------------------------------------
      // Development mode flag.
      //------------------------------------------------------------------------

      bool accCplexAllowed_;
         //
         // True, iff accelerated optimizing implosion with CPLEX is allowed.
@


1.92
log
@CPLEX
@
text
@d115 1
d165 1
d413 8
@


1.91
log
@CPLEX
@
text
@d127 2
a128 1
      defaultValue (bool         defCoinSelected,      coinEmbedded ())
a138 3
      defaultValue (
         bool defCplexSelected, cplexEmbedded () and not coinEmbedded ())

d226 5
@


1.90
log
@CPLEX
@
text
@d20 2
a21 3
//    solverEmbedded ()
//    coinEmbedded   ()
//    cplexEmbedded  ()
a27 13
// NonClass function solverEmbedded ()
//------------------------------------------------------------------------------

namespace WitNonClass
   {
   bool solverEmbedded ();
      //
      // Returns true, iff a solver was embedded into this build of WIT.
      //
      // Implemented in OptComp.C.
   };

//------------------------------------------------------------------------------
d148 2
a149 2
      void setCoinSelectedTrue  ();
      void setCplexSelectedTrue ();
@


1.89
log
@CPLEX
@
text
@d108 2
a109 2
      accessFunc (bool,                          solverIsCoin)
      accessFunc (bool,                          solverIsCplex)
d141 1
a141 1
      defaultValue (bool         defSolverIsCoin,      coinEmbedded ())
d153 1
a153 1
         bool defSolverIsCplex, cplexEmbedded () and not coinEmbedded ())
d162 2
a163 2
      void setSolverIsCoinTrue  ();
      void setSolverIsCplexTrue ();
d307 1
a307 1
      bool solverIsCoin_;
d309 1
a309 1
         // true, iff COIN is to be used as the solver.
d311 1
a311 1
      bool solverIsCplex_;
d313 1
a313 1
         // true, iff CPLEX is to be used as the solver.
@


1.88
log
@Heuristic Adjustment
@
text
@a121 1
      accessFunc (bool,                          cplexAllowed)
a172 1
      void setCplexAllowed      (bool);
a394 5
      bool cplexAllowed_;
         //
         // Optimizing implosion and stochastic implosion may be called when
         // the solver is CPLEX only if cplexAllowed_ is true.

@


1.87
log
@CPLEX
@
text
@d25 1
a25 1
#include <Compo.h>
@


1.86
log
@CPLEX
@
text
@d129 1
d181 1
d425 4
@


1.85
log
@CPLEX
@
text
@d123 1
a123 1
      accessFunc (bool,                          printOptModel)
d174 1
a174 1
      void setPrintOptModel     (bool);
d400 1
a400 1
      bool printOptModel_;
@


1.84
log
@CPLEX
@
text
@d21 1
d42 13
d141 1
a141 1
      defaultValue (bool         defSolverIsCoin,      COIN_EMBEDDED)
d153 1
a153 1
         bool defSolverIsCplex, cplexEmbedded () and not COIN_EMBEDDED)
@


1.83
log
@CPLEX
@
text
@d18 4
a21 1
// Contains the implementation NonClass function cplexEmbedded ().
d28 13
a198 4
      static bool solverEmbedded ();
         //
         // Returns true, iff a solver is embedded into this build of WIT.

@


1.82
log
@CPLEX
@
text
@d32 1
a32 1
      // Returns true, iff the current build of WIT contains embedded CPLEX.
@


1.81
log
@CPLEX
@
text
@d17 2
d25 13
d122 2
a123 1
      defaultValue (bool defSolverIsCplex, CPLEX_EMBEDDED and not COIN_EMBEDDED)
@


1.80
log
@CPLEX
@
text
@d64 1
d107 2
d116 2
a117 1
      void setSolverIsCoin      (bool);
a169 1
         // (Currently COIN is the only solver that may be embedded into WIT.)
d269 4
@


1.79
log
@CPLEX
@
text
@d95 1
a95 1
      defaultValue (bool         defSolverIsCoin,      coinEmbedded ())
a167 8
      static bool coinEmbedded ();
         //
         // Returns true, iff COIN is embedded into this build of WIT.

      static bool cplexEmbedded ();
         //
         // Returns true, iff CPLEX is embedded into this build of WIT.

@


1.78
log
@Preparing for embedded CPLEX.
@
text
@d76 1
d123 1
d172 4
d354 5
@


1.77
log
@Preparing for embedded CPLEX.
@
text
@d94 1
a94 1
      defaultValue (bool         defSolverIsCoin,      COIN_EMBEDDED)
d161 8
a168 4
      inline static bool solverEmbedded ()
         {
         return COIN_EMBEDDED;
         }
@


1.76
log
@Preparing for CPLEX.
@
text
@d161 5
@


1.75
log
@Revising the build process.
@
text
@d63 1
d94 1
d112 1
d255 4
@


1.74
log
@Revising the build procedure.
@
text
@a190 10
      //------------------------------------------------------------------------
      // optImpAllowed ()
      // Returns true, iff optimizing implosion is allowed.
      //------------------------------------------------------------------------

      inline static bool optImpAllowed ()
         {
         return WIT_EMBEDS_COIN;
         }

@


1.73
log
@Multi-Obj Mode
@
text
@a195 2
#ifdef OPT_IMPLODE

d198 1
a198 1
         return true;
a199 6
#else
      inline static bool optImpAllowed ()
         {
         return false;
         }
#endif
@


1.72
log
@Multi-Obj Mode
@
text
@a80 1
      accessFunc (double,                        multiObjTol)
d98 1
a98 1
      defaultValue (double       defWbounds,            1.0e4)
a124 1
      void setMultiObjTol       (double);
a372 7

      double multiObjTol_;
         //
         // In multiple objectives mode, each objective that has already been
         // optimized is constrained to achieve its maximum value minus the
         // max of a relative tolerance and absolute tolerance both defined by 
         // multiObjTol_.
@


1.71
log
@Multi-Obj Mode
@
text
@d74 1
d167 4
d344 4
@


1.70
log
@Multi-Obj Mode
@
text
@d370 3
a372 2
         // optimized is constrained to achieve its
         // maximum value - multiObjTol_.
@


1.69
log
@multi-obj mode
@
text
@d80 1
d125 1
d366 6
@


1.68
log
@Multi-objective mode
@
text
@d159 1
a159 1
         // In single-objective mode:
d161 1
a161 1
         // In multi-objective mode:
d232 1
a232 1
         // Valid in single-objective mode only.
d254 2
a255 2
         // The MultiObjMgr owned by this OptComp in multi-objective mode;
         // NULL, in single-objective mode.
d328 1
a328 1
         // In single-objective mode:
d330 1
a330 1
         // In  multi-objective mode:
@


1.67
log
@Multi-objective mode
@
text
@a79 1
      accessFunc (bool,                          allowMultiObj)
a123 1
      void setAllowMultiObj     (bool);
a363 4

      bool allowMultiObj_;
         //
         // True, iff the multiObjMode attribute is allowed to be set.
@


1.66
log
@Multi-objective mode
@
text
@d184 4
@


1.65
log
@Multi-Objective Mode
@
text
@d219 1
a219 4
      virtual void writeDataID ();
         //
         // Override from class Component.

d222 1
a222 1
         // Override from class Component.
d228 5
d324 1
a324 1
      double sglObjValue_;
d326 4
a329 2
         // Main objective function value.
         // Valid in single-objective mode only
@


1.64
log
@Multi-objective mode.
@
text
@a72 1
      accessFunc (double,                        objValue)
d159 7
d322 5
a326 1
      double objValue_;
d329 1
a329 1
         // Objective function values.
@


1.63
log
@Removing objective #2.
@
text
@d83 7
d242 5
@


1.62
log
@Removing objective #2.
@
text
@a19 1
#include <ObjFunc.h>
a56 3
      accessFunc (WitObjFunc0 *,                  myObjFunc0)
      accessFunc (WitObjFunc1 *,                  myObjFunc1)
      accessFunc (const WitList <WitObjFunc> &,   allObjFuncs)
a156 2
      void choose (WitObjFunc * theObjFunc);

a162 4
      void store (WitObjFunc * theObjFunc);
         //
         // Stores theObjFunc in this OptComp.

a196 4
      void setUpObjFuncs ();
         //
         // Sets up the ObjFuncs for this OptComp.

a205 4
      void chooseObjFunc (int theIndex);
         //
         // Chooses the ObjFunc whose index_ is theIndex.

a221 11
      WitObjFunc0 * myObjFunc0_;
      WitObjFunc1 * myObjFunc1_;
         //
         // The ObjFuncs for this DetOptImpMgr.

      WitList <WitObjFunc> allObjFuncs_;
         //
         // The List of all possible ObjFuncs.
         // Specifically, this List contains one instance of each concrete
         // ObjFunc class (stored abstractly as an ObjFunc *).

@


1.61
log
@Removing objective #2.
@
text
@d72 1
a72 1
      accessFunc (WitObjFunc *,                  objChoice)
d99 1
a100 1
      WitObjFunc    * defObjChoice     () const;
a161 2
         //
         // Sets objChoice to theObjFunc.
d304 1
a304 1
      WitObjFunc * objChoice_;
d306 1
a306 1
         // The ObjFunc currently selected.
@


1.60
log
@Removing objective #2.
@
text
@d179 4
@


1.59
log
@Removing objective #2.
@
text
@a73 1
      accessFunc (double,                        periodsPerYear)
a96 1
      defaultValue (double       defPeriodsPerYear,    52.0)
a114 1
      void setPeriodsPerYear    (double);
a309 4
      double periodsPerYear_;
         //
         // Parameters for Objective #2.

@


1.58
log
@Multi-obj mode.
@
text
@a59 1
      accessFunc (WitObjFunc2 *,                  myObjFunc2)
a73 4
      accessFunc (double,                        obj2Wrev)
      accessFunc (double,                        obj2Winv)
      accessFunc (double,                        obj2Wserv)
      accessFunc (double,                        obj2Wsub)
a74 2
      accessFunc (double,                        capCost)
      accessFunc (double,                        invCost)
a97 4
      defaultValue (double       defObj2Wrev,           1.0)
      defaultValue (double       defObj2Winv,           1.0)
      defaultValue (double       defObj2Wserv,          1.0)
      defaultValue (double       defObj2Wsub,           1.0)
a98 2
      defaultValue (double       defCapCost,            8.0)
      defaultValue (double       defInvCost,           10.0)
a116 4
      void setObj2Wrev          (double);
      void setObj2Winv          (double);
      void setObj2Wserv         (double);
      void setObj2Wsub          (double);
a117 2
      void setCapCost           (double);
      void setInvCost           (double);
a242 1
      WitObjFunc2 * myObjFunc2_;
a312 7
      double obj2Wrev_;
      double obj2Winv_;
      double obj2Wserv_;
      double obj2Wsub_;
         //
         // Weights for Objective #2.

a313 2
      double capCost_;
      double invCost_;
@


1.57
log
@Stochastic Implosion
@
text
@d72 1
d93 1
d103 1
d127 1
d145 1
d321 4
d399 4
@


1.56
log
@Stochastic Implosion
@
text
@d86 1
a86 1
      accessFunc (bool,                          printOptProb)
d135 1
a135 1
      void setPrintOptProb      (bool);
d367 1
a367 1
      bool printOptProb_;
@


1.55
log
@Stochastic Implosion
@
text
@d143 1
a143 1
      // storeStoch<Attr> functions.
d146 2
a147 1
      // Valid only when the stochastic implosion subsystem is uploading data.
d150 6
d158 3
a195 6
      void importObjs ();
         //
         // Imports the objective function values from myDetOptImpMgr ().
         // Valid only when the optimizing implosion subsystem is exporting the
         // objective function values.

@


1.54
log
@Stochastic Implosion
@
text
@d156 5
a160 4
      virtual bool       inserted     ();
      virtual WitMsgFrag classMsgFrag ();
      virtual void       copySelfInto (WitCompMgr * theCompMgr);
      virtual void       recount      ();
@


1.53
log
@Stochastic Implosion
@
text
@d143 1
a143 1
      // loadInStoch<Attr> functions.
d149 2
a150 2
      void loadInStochObjValue    (double);
      void loadInStochBoundsValue (double);
@


1.52
log
@Stochastic Implosion
@
text
@d143 10
d156 4
a159 5
      virtual bool       inserted        ();
      virtual WitMsgFrag classMsgFrag    ();
      virtual void       copySelfInto    (WitCompMgr * theCompMgr);
      virtual void       recount         ();
      virtual void       importStochSoln ();
a190 7
      void loadInObjVals (
            double objValueArg,
            double boundsValueArg);
         //
         // Loads in the objective function values.
         // Valid only when the stochastic implosion solution is being uploaded.

@


1.51
log
@Stochastic Implosion
@
text
@d187 1
a187 2
         // Valid only when myStochImpMgr () is currently uploading the
         // stochastic implosion solution.
@


1.50
log
@Stochastic Implosion
@
text
@d182 8
@


1.49
log
@Stochastic Implosion
@
text
@d166 1
a166 1
         // myOptImploder () is not accelerated.
d178 1
a178 1
         // Imports the objective function values from myOptImploder ().
d245 1
a245 1
         // The ObjFuncs for this OptImploder.
d287 1
a287 1
         // If an OptImploder is in accelerated bounds mode, then arbitrary
@


1.48
log
@Stochastic Implosion
@
text
@d84 2
d146 5
a150 4
      virtual bool       inserted     ();
      virtual WitMsgFrag classMsgFrag ();
      virtual void       copySelfInto (WitCompMgr * theCompMgr);
      virtual void       recount      ();
d176 6
d341 9
@


1.47
log
@Stochastic Implosion
@
text
@d144 1
a144 4
      virtual bool inserted ();
         //
         // Override from class Component.

d146 2
d149 1
a149 9
         // Override from class Component.

      virtual void copySelfInto (WitCompMgr * theCompMgr);
         //
         // Override from class Component.

      virtual void recount ();
         //
         // Override from class Component.
@


1.46
log
@Stochastic Implosion.
@
text
@d187 2
a189 2

#ifdef OPT_IMPLODE
d194 1
@


1.45
log
@External opt implosion.
@
text
@d148 4
@


1.44
log
@External opt implosion.
@
text
@d71 1
a71 1
      accessFunc (bool,                          allowIntCons)
d98 1
a98 1
      defaultValue (bool         defAllowIntCons,      false)
d121 1
a121 1
      void setAllowIntCons      (bool);
d292 1
a292 1
      bool allowIntCons_;
d294 2
a295 2
         // Integrality constraints in optimizing implosion are allowed only if
         // allowIntCons_ is true.
@


1.43
log
@External opt implosion.
@
text
@d71 1
a71 1
      accessFunc (bool,                          enforceIntCons)
d98 1
a98 1
      defaultValue (bool         defEnforceIntCons,    false)
d121 1
a121 1
      void setEnforceIntCons    (bool);
d292 1
a292 1
      bool enforceIntCons_;
d294 2
a295 2
         // Integrality constraints in optimizinf implosion will be enforced,
         // iff enforceIntCons_ is true.
@


1.42
log
@App controlled opt implosion.
@
text
@d26 2
a27 1
// Responsible for the global attributes of an OptImploder.
d71 1
d98 1
d121 1
d292 5
@


1.41
log
@App controlled opt implosion.
@
text
@d174 17
@


1.40
log
@App controlled opt implosion.
@
text
@d268 1
a268 1
         // optimization model to be generated, which is somewhat slower to
d315 1
a315 1
         // Print the optimization model.
@


1.39
log
@App controlled opt implosion.
@
text
@d87 1
d134 1
d332 4
@


1.38
log
@Removed optimizing implosion with lot sizes.
@
text
@d82 5
d128 5
d306 24
@


1.37
log
@Removed the postSolveRecovery attribute.
@
text
@a69 1
      accessFunc (bool,                          optWithLotSizes)
a89 1
      defaultValue (bool         defOptWithLotSizes,   false)
a111 1
      void setOptWithLotSizes   (bool);
a258 5
      bool optWithLotSizes_;
         //
         // Opt implosion will respect the minLotSize and IncLotSize attributes,
         // iff optWithLotSizes_ is true.

@


1.36
log
@Updated the copyright date on all source files.
@
text
@a70 1
      accessFunc (bool,                          postSolveRecovery)
a91 1
      defaultValue (bool         defPostSolveRecovery, false)
a114 1
      void setPostSolveRecovery (bool);
a266 5
      bool postSolveRecovery_;
         //
         // true, if the code to recover from an error in ekk_postSolve is to be
         // used.

@


1.35
log
@Removed some OSL items.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.34
log
@Fixed bugs:
   witWriteData didn't write problem.compPrices.
   witWriteData didn't write problem.accMethod.
   witCopyData  didn't copy  problem.solverLogFileName.
   witCopyData  didn't copy  problem.accMethod.
@
text
@a81 1
      accessFunc (const WitString &,             oslMesgFileName)
a101 1
      defaultValue (const char * defOslMesgFileName,   "osl.log")
a126 1
      void setOslMesgFileName   (const char *);
a299 4
      WitString oslMesgFileName_;
         //
         // Name of OSL log output file.

@


1.33
log
@Made opt implosion use COIN unconditionally when COIN_BUILD is defined.
@
text
@d105 1
@


1.32
log
@Added "solverIsCoin" attribute.
@
text
@a71 1
      accessFunc (bool,                          solverIsCoin)
a94 1
      defaultValue (bool         defSolverIsCoin,      false)
a118 1
      void setSolverIsCoin      (bool);
a276 5
      bool solverIsCoin_;
         //
         // If true, COIN is to be used to solve the optimization model.
         // If false, OSL is to be used to solve the optimization model.

@


1.31
log
@Continued double precision.
@
text
@d72 1
a84 1
      accessFunc (bool,                          optWithCoin)
d96 1
d121 1
a132 1
      void setOptWithCoin       (bool);
d280 5
a316 5

      bool optWithCoin_;
         //
         // If true, COIN is to be used to solve the optimization model.
         // If false, OSL is to be used to solve the optimization model.
@


1.30
log
@Continued double precision.
@
text
@d73 8
a80 8
      accessFunc (StrDbl,                        wbounds)
      accessFunc (StrDbl,                        obj2Wrev)
      accessFunc (StrDbl,                        obj2Winv)
      accessFunc (StrDbl,                        obj2Wserv)
      accessFunc (StrDbl,                        obj2Wsub)
      accessFunc (StrDbl,                        periodsPerYear)
      accessFunc (StrDbl,                        capCost)
      accessFunc (StrDbl,                        invCost)
d96 8
a103 8
      defaultValue (StrDbl       defWbounds,            1.0e4)
      defaultValue (StrDbl       defObj2Wrev,           1.0)
      defaultValue (StrDbl       defObj2Winv,           1.0)
      defaultValue (StrDbl       defObj2Wserv,          1.0)
      defaultValue (StrDbl       defObj2Wsub,           1.0)
      defaultValue (StrDbl       defPeriodsPerYear,    52.0)
      defaultValue (StrDbl       defCapCost,            8.0)
      defaultValue (StrDbl       defInvCost,           10.0)
d121 8
a128 8
      void setWbounds           (StrDbl);
      void setObj2Wrev          (StrDbl);
      void setObj2Winv          (StrDbl);
      void setObj2Wserv         (StrDbl);
      void setObj2Wsub          (StrDbl);
      void setPeriodsPerYear    (StrDbl);
      void setCapCost           (StrDbl);
      void setInvCost           (StrDbl);
d283 1
a283 1
      StrDbl wbounds_;
d287 4
a290 4
      StrDbl obj2Wrev_;
      StrDbl obj2Winv_;
      StrDbl obj2Wserv_;
      StrDbl obj2Wsub_;
d294 3
a296 3
      StrDbl periodsPerYear_;
      StrDbl capCost_;
      StrDbl invCost_;
@


1.29
log
@Continued implementation of opt with COIN.
@
text
@d73 8
a80 8
      accessFunc (float,                         wbounds)
      accessFunc (float,                         obj2Wrev)
      accessFunc (float,                         obj2Winv)
      accessFunc (float,                         obj2Wserv)
      accessFunc (float,                         obj2Wsub)
      accessFunc (float,                         periodsPerYear)
      accessFunc (float,                         capCost)
      accessFunc (float,                         invCost)
d96 8
a103 8
      defaultValue (float        defWbounds,            1.0e4)
      defaultValue (float        defObj2Wrev,           1.0)
      defaultValue (float        defObj2Winv,           1.0)
      defaultValue (float        defObj2Wserv,          1.0)
      defaultValue (float        defObj2Wsub,           1.0)
      defaultValue (float        defPeriodsPerYear,    52.0)
      defaultValue (float        defCapCost,            8.0)
      defaultValue (float        defInvCost,           10.0)
d121 8
a128 8
      void setWbounds           (float);
      void setObj2Wrev          (float);
      void setObj2Winv          (float);
      void setObj2Wserv         (float);
      void setObj2Wsub          (float);
      void setPeriodsPerYear    (float);
      void setCapCost           (float);
      void setInvCost           (float);
d283 1
a283 1
      float wbounds_;
d287 4
a290 4
      float obj2Wrev_;
      float obj2Winv_;
      float obj2Wserv_;
      float obj2Wsub_;
d294 3
a296 3
      float periodsPerYear_;
      float capCost_;
      float invCost_;
@


1.28
log
@Continued implementation of opt with COIN.
@
text
@d83 1
a83 1
      accessFunc (const WitString &,             coinLogFileName)
d85 1
d105 1
a105 1
      defaultValue (const char * defCoinLogFileName,   "coin.log")
d130 1
a130 1
      void setCoinLogFileName   (const char *);
d132 1
d308 1
a308 1
      WitString coinLogFileName_;
d316 9
@


1.27
log
@Continued implementation of opt with COIN.
@
text
@d66 1
d113 1
d235 4
@


1.26
log
@Continued implementation of opt with COIN.
@
text
@d82 1
a82 1
      accessFunc (const WitString &,             coinMesgFileName)
d103 1
a103 1
      defaultValue (const char * defCoinMesgFileName,  "coin.log")
d127 1
a127 1
      void setCoinMesgFileName  (const char *);
d300 1
a300 1
      WitString coinMesgFileName_;
@


1.25
log
@Continued implementation of opt with COIN.
@
text
@a15 1
// Contains the declaration of enum  OptSolveMethod.
a23 12
// Enum OptSolveMethod
//
// Designates a method for solving the optimization problem.
//------------------------------------------------------------------------------

enum WitOptSolveMethod
   {
   oslDirMethod, // Solve using OSL with direct calls.
   clpOsiMethod  // Solve using CLP with the OSI interface
   };

//------------------------------------------------------------------------------
d83 1
a83 1
      accessFunc (WitOptSolveMethod,             myOptSolveMethod)
d128 1
a128 1
      void setMyOptSolveMethod  (WitOptSolveMethod);
d304 1
a304 1
      WitOptSolveMethod myOptSolveMethod_;
d306 2
a307 1
         // The designates which class of OptSolver is to be used.
@


1.24
log
@Continued implementation of opt with COIN.
@
text
@a32 1
   oslOsiMethod, // Solve using OSL with the OSI interface
@


1.23
log
@Continued implementation of opt with COIN.
@
text
@d96 1
d117 1
d141 1
d313 4
@


1.22
log
@Removed temporary control parameter undoc1.
@
text
@d34 1
a34 1
   clpMethod     // Solve using CLP with the OSI interface
@


1.21
log
@Added a temporary undocumented control parameter to turn off ekk_preSolve.
@
text
@a96 1
      accessFunc (bool,                          skipPreSolve)
a139 1
      void setSkipPreSolve      (bool);
a313 4

      bool skipPreSolve_;
         //
         // ekk_preSolve will be skipped if skipPreSolve_ is true.
@


1.20
log
@Continued implementation of opt with COIN.
@
text
@d97 1
d141 1
d316 4
@


1.19
log
@Continued implementation of opt with COIN.
@
text
@d16 1
d23 13
@


1.18
log
@Implemented OSL postSolve error recovery.
@
text
@d82 1
d125 1
d296 4
@


1.17
log
@Internal changes.
@
text
@d70 1
d87 14
a100 13
      defaultValue (bool         defCompPrices,      false)
      defaultValue (bool         defAccAfterOptImp,  false)
      defaultValue (bool         defAccAfterSoftLB,  false)
      defaultValue (bool         defOptWithLotSizes, false)
      defaultValue (float        defWbounds,          1.0e4)
      defaultValue (float        defObj2Wrev,         1.0)
      defaultValue (float        defObj2Winv,         1.0)
      defaultValue (float        defObj2Wserv,        1.0)
      defaultValue (float        defObj2Wsub,         1.0)
      defaultValue (float        defPeriodsPerYear,  52.0)
      defaultValue (float        defCapCost,          8.0)
      defaultValue (float        defInvCost,         10.0)
      defaultValue (const char * defOslMesgFileName, "osl.log")
d109 15
a123 14
      void setCompPrices      (bool);
      void setAccAfterOptImp  (bool);
      void setAccAfterSoftLB  (bool);
      void setOptWithLotSizes (bool);
      void setObjChoice       (int);
      void setWbounds         (float);
      void setObj2Wrev        (float);
      void setObj2Winv        (float);
      void setObj2Wserv       (float);
      void setObj2Wsub        (float);
      void setPeriodsPerYear  (float);
      void setCapCost         (float);
      void setInvCost         (float);
      void setOslMesgFileName (const char *);
d260 5
@


1.16
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d66 4
a69 4
      accessFunc (WitBoolean,                    compPrices)
      accessFunc (WitBoolean,                    accAfterOptImp)
      accessFunc (WitBoolean,                    accAfterSoftLB)
      accessFunc (WitBoolean,                    optWithLotSizes)
d86 4
a89 4
      defaultValue (WitBoolean   defCompPrices,      witFALSE)
      defaultValue (WitBoolean   defAccAfterOptImp,  witFALSE)
      defaultValue (WitBoolean   defAccAfterSoftLB,  witFALSE)
      defaultValue (WitBoolean   defOptWithLotSizes, witFALSE)
d107 4
a110 4
      void setCompPrices      (WitBoolean);
      void setAccAfterOptImp  (WitBoolean);
      void setAccAfterSoftLB  (WitBoolean);
      void setOptWithLotSizes (WitBoolean);
d126 1
a126 1
      virtual WitBoolean inserted ();
d178 2
a179 2
         // Issues a warning if accAfterSoftLB () is TRUE and accAfterOptImp ()
         // is FALSE.
d230 1
a230 1
      WitBoolean compPrices_;
d232 1
a232 1
         // TRUE, iff shadow prices on parts are to be computed.
d234 1
a234 1
      WitBoolean accAfterOptImp_;
d236 1
a236 1
         // TRUE, iff opt implosion is to stay in an accelerated
d238 1
a238 1
         // If FALSE, opt implosion will shot down when it completes.
d240 1
a240 1
      WitBoolean accAfterSoftLB_;
d242 1
a242 1
         // TRUE, iff the Optimploder is in accelerated bounds mode.
d253 1
a253 1
      WitBoolean optWithLotSizes_;
d256 1
a256 1
         // iff optWithLotSizes_ is TRUE.
@


1.15
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a65 1
      accessFunc (WitBoolean,                    allowMLS)
a106 1
      void setAllowMLS        (WitBoolean);
a224 5

      WitBoolean allowMLS_;
         //
         // TRUE, iff non-trival values of minLotSize are to be allowed in
         // optWithLotSizes mode.
@


1.14
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d245 1
a245 1
         // If FALSE, opt implosion will unaccelerate when it completes.
d251 5
a255 5
         // changes can be made to a BoundSet without invoking unaccelerate.
         // If it is not in accelerated bounds mode, then whenever a change is
         // made to a BoundSet such that a lower bound that used to be hard
         // becomes soft, then unaccelerate invoked. Other changes to a
         // BoundSet do not invoke unaccelerate. The disadvantage of
@


1.13
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d66 1
d108 1
d227 5
@


1.12
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a69 1
      accessFunc (WitBoolean,                    allowOWLS)
a110 1
      void setAllowOWLS       (WitBoolean);
a256 4

      WitBoolean allowOWLS_;
         //
         // optWithLotSizes_ is allowed to be set iff allowOWLS_ is TRUE.
@


1.11
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d251 3
a253 2
         // accelerated bounds mode is that it causes a somewhat larger MP
         // model to be generated, which is somewhat slower to solve.
@


1.10
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d251 1
a251 1
         // accelerated bounds mode is that it causes a somewhat larger LP
@


1.9
log
@Began implementation of opt implosion with lot sizes.
@
text
@d21 1
@


1.8
log
@Preliminary work on single source.
@
text
@d68 2
d89 1
d110 2
d252 9
@


1.7
log
@Added shadowPrice and compPrices attributes.
@
text
@d59 1
a59 1
      accessFunc (const WitList (WitObjFunc) &,   allObjFuncs)
d64 1
a64 1
      accessFunc (const WitList (WitOptStarter) &, allOptStarters)
d203 1
a203 1
      WitList (WitObjFunc) allObjFuncs_;
d216 1
a216 1
      WitList (WitOptStarter) allOptStarters_;
@


1.6
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@d65 1
d84 1
d104 1
d225 4
@


1.5
log
@Coarse selection splitting.
@
text
@d161 1
a161 1
      void setupObjFuncs ();
d165 1
a165 1
      void setupOptStarters ();
@


1.4
log
@Refactoring for selection splitting.
@
text
@d127 4
@


1.3
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d155 1
a155 3
      copyCtorAndAssignment (WitOptComp);
         //
         // Prevents unintentional copying and assignment.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d123 1
a123 1
      virtual void copyInto (WitCompMgr * theCompMgr);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

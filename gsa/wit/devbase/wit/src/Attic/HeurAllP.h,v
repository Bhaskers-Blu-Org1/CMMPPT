head	1.41;
access;
symbols
	EndRw-branch:1.40.0.6
	Root-of-EndRw:1.40
	rwToStl:1.40.0.4
	latest_sce_3_10_20010924:1.40.0.2
	sce_3_10_20010924:1.40
	latest_sce_3_00_20010601:1.38.0.2
	sce_3_00_20010601:1.38
	latest_sce_2_31_20010308:1.25.0.2
	sce_2_31_20010308:1.25
	latest_sce_2_31_20001003:1.11.0.2
	sce_2_31_20001003:1.11
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2003.03.03.23.26.47;	author rjw;	state dead;
branches;
next	1.40;

1.40
date	2001.07.25.16.08.15;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.11.19.29.10;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.17.15.11.14;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.15.15.30.26;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.07.15.58.56;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.03.22.55.45;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.25.20.54.35;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.26.20.28.07;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.22.14.53.59;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.21.21.55.46;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.20.21.03.58;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.16.16.55.21;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.16.00.22.58;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.13.22.12.05;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.08.16.37.04;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.09.22.55.47;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.07.22.59.26;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.06.15.46.36;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.29.19.26.10;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.20.00.44.17;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.15.19.01.50;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.11.16.35.08;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.28.22.13.36;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.14.19.35.22;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.13.19.57.24;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.04.22.07.36;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.22.23.11.41;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.21.20.03.23;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.13.21.03.54;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.29.21.22.44;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.18.00.16.00;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.08.21.56.12;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.02.20.43.12;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.24.19.55.22;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.21.17.42.48;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.19.22.35.31;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.01.00.35.43;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.16.33.08;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.55;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Removed all empty files from WIT (64 of them).
@
text
@@


1.40
log
@Initial implementation of pegging.
@
text
@@


1.39
log
@Refactoring.
@
text
@a0 530
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
//
//------------------------------------------------------------------------------

#ifndef HeurAllPH
#define HeurAllPH

//------------------------------------------------------------------------------
// Header file: "HeurAllP.h"
//
// Contains the declaration of class HeurAllPerf.
//------------------------------------------------------------------------------

#include <Mapping.h>
#include <Schedule.h>
#include <AccFlag.h>

//------------------------------------------------------------------------------
// class HeurAllPerf
//
// This class is responsible for actually performing a heuristic allocation.
// An instance of this class exists only when heuristic allocation is active.
//------------------------------------------------------------------------------

class WitHeurAllPerf: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitHeurAllPerf (
            WitProblem * theProblem,
            WitAccFlag * theAccFlag,
            WitBoolean   forOpt);
         //
         // ProbAssoc  <<< theProblem.
         // myAccFlag_ <-- theAccFlag.
         // forOpt == TRUE indicates heur allocation is for opt implosion.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitHeurAllPerf ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      double inc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            double      desIncVol,
            WitBoolean  asapMultiExec);
         //
         // Performs a heuristic allocation.
         // See HeurAllocator::inc for argument meanings.

      void enforceStockSLBs ();
         //
         // Enforces stock soft lower bounds.

      void commitMaxQtySel (double & netQty);
         //
         // Commits the heuristically maximum possible quantity of topPart_ 
         // in topPer_, for a given selection scheme.

      WitBoolean tempCommit (double qty);
         //
         // Calls commit on temp data.
         // Returns TRUE iff the commit attempt succeeded.

      void permCommit1SS ();
         //
         // Does a perm-commit of 1 unit for selection splitting purposes.
         // Valid only in sel-split mode.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc    (const WitAllocMode *, myAllocMode)
      accessFunc    (WitBoolean,           buildAhead)
      accessNonNull (WitPart *,            topPart)

      inline WitPeriod topPer ()
         {
         witAssert (topPer_ >= 0);

         return topPer_;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Component data access functions.
      //------------------------------------------------------------------------

      refAccess (WitDemand,    WitFlexVec (double), shipVol)
      refAccess (WitOperation, WitFlexVec (double), execVol)
      refAccess (WitSubEntry,  WitFlexVec (double), subVol)

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitHeurAllPerf);

      inline WitExpRest * myExpRest ()
         {
         witAssert (penExec_);

         return myExpRest_;
         }

      void initBlocked ();
         //
         // Initializes blocked_.

      void initSoln ();
         //
         // Initializes the implosion solution.

      double cumShipVol (WitDemand * theDemand, WitPeriod thePer);
         //
         // Computes and returns the cumShipVol of theDemand in thePer.

      double resAlloc (
            WitPart *  thePart,
            WitPeriod  lastPer,
            double     qty,
            WitPeriod  firstPer,
            WitBoolean prefBA);
         //
         // Allocates resources by:
         //    determining what portion of a desired quantity of the requested
         //    part can  be provided in the requested period, commiting the
         //    required resources, and returning that quantity. Tries allocating
         //    in periods between firstPer and lastPer.
         // Preferential build-ahead is to be used iff prefBA is TRUE.

      void commitMaxQty (WitPart * thePart, WitPeriod thePer, double & netQty);
         //
         // Commits the heuristically maximum possible quantity of thePart in
         // thePer, considering multiple selections, if appropriate.

      void permCommit (double qty);
         //
         // Calls commit on perm data.
         // Verifies that the commit attempt succeeded.

      double findMaxQty (double desQty);
         //
         // Determines the heuristic maximum lotsize-feasible quantity of
         // topPart_ that is <= desQty and can be made in topPer_.
         // The search considers only lotsize feasible quantities.
         // If the minimum lot-sized quantity is not feasible, 0.0 is returned.
         // Otherwise, if the desired quantity is feasible, it is returned.
         // Otherwise the max quantity is found by a binary search.

      void defSearchGrid (double & minQty, double & incQty);
         //
         // Sets minQty and incQty to define the set of values to
         // be examined by the binary search. In lot size mode, this is the lot
         // size grid; otherwise it is the whole numbers.

      static WitBoolean isAnInteger (double theDbl);
         //
         // Returns TRUE, iff theDbl is an integer.

      double binarySearch (double desQty, double minQty, double incQty);
         //
         // Does the binary search aspect of findMaxQty, where minQty and incQty
         // define the search grid, minQty is assumed feasible and desQty is
         // assumed infeasible.

      WitBoolean commit (double qty);
         //
         // Attempts to commit qty units of topPart () to a shipment in 
         // topPer (). 
         // Returns TRUE iff the attempt succeeded.

      WitBoolean innerCommit (double qty);
         //
         // Does most of the work for commit.

      WitBoolean fillReq (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    theReqVol);
         //
         // Attempts to meet theReqVol units of requirement of thePart in
         // fillPer. Returns TRUE iff the attempt succeeded.

      WitBoolean fillNetReqNss (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    theReqVol);
         //
         // Attempts to meet theReqVol units of requirement of thePart in
         // fillPer by explosion. Returns TRUE iff the attempt succeeded.
         // Valid only in non-sel-split mode.

      WitBoolean fillNetReqSS (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    theReqVol);
         //
         // Similar to fillNetReqNss.
         // Valid only in sel-split mode.

      WitBoolean fillNetReqBASS (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    netReqVol);
         //
         // Similar to fillNetReq.
         // Valid only in sel-split mode.

      WitBoolean explodePartSS (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Performs selection-split explosions of netReqVol units of thePart 
         // in expPer in order to meet requirements in fillPer.
         // Valid only in sel-split mode.

      WitBoolean findExpPer (
            WitPart *   thePart, 
            WitPeriod   fillPer, 
            WitPeriod & expPer);
         //
         // Sets expPer to the period appropriate for exploding thePer to fill
         // reqs in fillPer. Returns TRUE, iff thePart is explodeable for
         // fillPer. In the FALSE case, takes the appropiate recording actions.

      WitBoolean explodeBopEntSS (
            WitBopEntry * theBopEnt,
            WitPeriod     expPer,
            double        expVol,
            WitPeriod     fillPer);
         //
         // Explodes theBopEnt in expPer.
         // Valid only in sel-split mode.

      WitBoolean explode (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        qty,
            WitPeriod     fillPer);
         //
         // Attempts to explode qty units thru theBopEnt by executing in period
         // execPer, to fill demand in fillPer. 
         // Returns TRUE iff the explosion was successful.

      WitBoolean checkExecBounds (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        theExecVol,
            WitPeriod     fillPer);
         //
         // Returns TRUE, iff exploding thru theBopEnt by increasing
         // the Operation's execVol in execPer to theExecVol, to fill demand in
         // fillPer would satisfy the appropriate upper bound on execVol.  
         // In the FALSE case, records the failure, if appropriate.

      WitBoolean innerExplode (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        qty,
            double        deltaExecVol,
            WitPeriod     fillPer);
         //
         // Explodes qty units thru theBopEnt by executing deltaExecVol units in
         // execPer, to fill demand in fillPer. 
         // Returns TRUE, iff the explosion was feasible.

      void netAndRollReq (
            WitPart * thePart,
            WitPeriod thePer,
            double &  netReqVol);
         //
         // Nets netReqVol for against the availability of thePart in thePer 
         // and rolls netted amount to the next period.
         // Valid only in stock reallocation mode.

      void explodeBomEntry (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theExpBopEntry,
            WitBoolean &  expOK);
         //
         // Explodes deltaExecVol units along theBomEnt in exec period execPer,
         // for filling demand in fillPer, exploding thru theExpBopEntry.
         // If the explosion is not feasible (which can only happen in pen-exec
         // mode) expOK gets set to FALSE.

      void explodeBomEntrySS (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theExpBopEntry);
         //
         // Performs actions of explodeBomEntry specific to selection splitting.
         // Valid only in sel-split mode.

      void netConsEntries (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double &      netExecQty,
            WitBoolean &  expOK);
         //
         // Nets the requirement for theBomEnt using both theBomEnt and
         // its subEntries. See explodeBomEntry for meaning of expOK.

      void netSubEntry (
            WitSubEntry * theSub,
            WitPeriod     execPer,
            double &      netExecQty,
            WitBoolean &  expOK);
         //
         // Nets the requirement of an Operation along a SubEntry.
         // See explodeBomEntry for meaning of expOK.

      void netConsEntry (
            WitConsEntry * theConsEnt,
            double &       netExecQty,
            WitPeriod      execPer,
            WitBoolean &   expOK);
         //
         // Nets the requirement of an Operation along a ConsEntry.

      void explodeConsEntry (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double         netExecQty,
            WitPeriod      fillPer,
            WitBopEntry *  theExpBopEntry);
         //
         // Explodes netExecQty units along theConsEnt in exec period execPer
         // for filling demand in fillPer, exploding thru theExpBopEntry.

      void enforceStockSLBs (WitPart * thePart);
         //
         // Enforces the stock soft lower bounds for thePart in all periods.

      void enforceStockSLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Enforces the stock soft lower bound for theMat in thePer.

      inline WitBoolean critListMode () 
         {
         return myHeurCritList_ != NULL;
         }

      inline WitHeurCritList * myHeurCritList () 
         {
         witAssert (critListMode ());

         return myHeurCritList_;
         }

      inline WitBoolean multiSel () 
         {
         return (mySelector_ != NULL);
         }

      inline WitPeriod expPerFor (WitPart * thePart, WitPeriod fillPer);
         //
         // Returns the explosion period to be used when filling requirements
         // for thePart in fillPer, or fillPer, if there is none.

      inline WitBopEntry * expBopEntry (WitPart * thePart, WitPeriod expPer);
         //
         // Returns the BopEntry to be used for explosions in order to produce
         // thePart in expPer.

      inline WitPeriod execPerFor (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Returns the execution period to be used when exploding through 
         // theBopEnt in expPer.

      //------------------------------------------------------------------------

      accessWrapper (WitBoolean,    skipFailures, myGlobalComp ())
      accessWrapper (WitBoolean,    stockRealloc, myGlobalComp ())

      accessNonNull (WitSelector *, mySelector)
      accessNonNull (WitPmrMgr *,   myPmrMgr)
      accessNonNull (WitCmrMgr *,   myCmrMgr)
      accessNonNull (WitBaMgr *,    myBaMgr)
      accessNonNull (WitMeMgr *,    myMeMgr)

      inline WitAvailSched * curAvailSched ();
         //
         // Wrapper for myAllocMode_->curAvailSched ().

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitAllocMode * myAllocMode_;
         //
         // The AllocMode owned by this HeurAllPerf.

      WitReqSched * myReqSched_;
         //
         // The requirement schedule for this HeurAllPerf.

      WitHeurCritList * myHeurCritList_;
         //
         // The HeurCritList owned by this HeurAllPerf.

      WitSelector * mySelector_;
         //
         // The Selector owned by this HeurAllPerf, if any; otherwise NULL.

      WitPmrMgr * myPmrMgr_;
         //
         // The PmrMgr associated with this HeurAllPerf, if any; otherwise NULL.
         // Non-null, iff multiRoute_ is TRUE.

      WitCmrMgr * myCmrMgr_;
         //
         // The CmrMgr associated with this HeurAllPerf, if any; otherwise NULL.
         // Non-null, iff multiRoute_ is TRUE.

      WitBaMgr * myBaMgr_;
         //
         // The BaMgr associated with this HeurAllPerf, if any; 
         // otherwise NULL.
         // Non-null, iff buildAhead_ is TRUE.

      WitMeMgr * myMeMgr_;
         //
         // The MeMgr associated with this HeurAllPerf, if any; 
         // otherwise NULL.
         // Non-null, iff MultiExec_ is TRUE.

      WitExpRest * myExpRest_;
         //
         // The ExpRest associated with this HeurAllPerf, if any; 
         // otherwise NULL.
         // Non-null, iff penExec_ is TRUE.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitAccFlag * const myAccFlag_;
         //
         // Ptr to HeurAllocator::myAccFlag_.

      WitBoolean multiRoute_;
         //
         // TRUE, iff the multiple routes periods technique is to be performed.

      WitBoolean buildAhead_;
         //
         // TRUE, iff build-ahead by Material is to be performed.

      WitBoolean multiExec_;
         //
         // TRUE, iff the multiple execution periods technique is to be 
         // performed.

      WitBoolean penExec_;
         //
         // TRUE, iff penalized execution is to be performed.

      WitBoolean selSplit_;
         //
         // TRUE, iff selection splitting is to be performed.

      WitBoolean finiteExecBounds_;
         //
         // TRUE, iff myProblem () includes any execBounds with finite hardUBs.

      WitSchedule (WitPart, WitPeriod) blocked_;
         //
         // blocked_ (thePart)[thePer] is TRUE, iff an attempt to meet external
         // demand for thePart in thePer has failed.
         // Only allocated for Parts with positive demand.

      WitPart * topPart_;
         //
         // The Part for which commitMaxQty was called, if any, else NULL.

      WitPeriod topPer_;
         //
         // The Period for which commitMaxQty was called, if any, else -1.

      WitBoolean committing_;
         //
         // TRUE, iff commit () is being executed.

      int nMaxCommits_;
         //
         // # calls to commitMaxQty.

      int nSelCommits_;
         //
         // # calls to commitMaxQtySel.

      int nBsearches_;
         //
         // # binary searches.
   };

#endif
@


1.38
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@d241 1
a241 1
      WitBoolean findExpPeriod (
d384 1
a384 1
      inline WitPeriod expPeriod (WitPart * thePart, WitPeriod fillPer);
d394 1
a394 3
      inline WitPeriod expExecPeriod (
            WitBopEntry * theBopEnt, 
            WitPeriod     expPer);
@


1.37
log
@Implemented timing wrap-around adjustment.
@
text
@a529 5

      int nIncsSinceCharge_;
         //
         // If heurTimingDelta > 0, nIncsSinceCharge_ is the # of calls to inc
         // since a timing charge was done.
@


1.36
log
@Implemented Ticker class.
Disallowed sel-split w multi-exec.
@
text
@d530 5
@


1.35
log
@Implemented incAlloc count.
@
text
@a529 8

      int nIncs_;
         //
         // # calls to incHeurAlloc (in incCount mode).

      int nextPrtInc_;
         //
         // nIncs_ is to printed when it reaches nextPrtInc_.
@


1.34
log
@Refactoring for selection splitting.
@
text
@d530 8
@


1.33
log
@Continued implementation of selection splitting.
@
text
@d407 2
a408 2
      accessNonNull (WitProdRtr *,  myProdRtr)
      accessNonNull (WitConsRtr *,  myConsRtr)
d440 1
a440 1
      WitProdRtr * myProdRtr_;
d442 1
a442 2
         // The ProdRtr associated with this HeurAllPerf, if any; 
         // otherwise NULL.
d445 1
a445 1
      WitConsRtr * myConsRtr_;
d447 1
a447 2
         // The ConsRtr associated with this HeurAllPerf, if any; 
         // otherwise NULL.
@


1.32
log
@Fixed a bug in selection splitting.
@
text
@d70 5
a156 5

      void commitMaxQtySel (double & netQty);
         //
         // Commits the heuristically maximum possible quantity of topPart_ 
         // in topPer_, for a given selection scheme.
@


1.31
log
@Continued implementation of selection splitting with the new design.
@
text
@d75 1
a75 1
      void permCommit (double qty);
d77 2
a78 2
         // Calls commit on perm data.
         // Verifies that the commit attempt succeeded.
d158 5
d428 4
a501 4

      WitReqSched * myReqSched_;
         //
         // The requirement schedule for this HeurAllPerf.
@


1.30
log
@Continued implementation of selection splitting with the new design.
@
text
@d70 1
a70 1
      WitBoolean tempCommit1SS (WitPart * thePart, WitPeriod thePer);
d72 1
a72 1
         // Calls commit for 1 top-level unit on temp data.
d74 5
a78 1
         // Valid only in sel-split mode.
d84 10
a93 2
      accessFunc (const WitAllocMode *, myAllocMode)
      accessFunc (WitBoolean,           buildAhead)
d153 1
a153 4
      void commitMaxQtyMultiSel (
            WitPart * thePart, 
            WitPeriod thePer,
            double &  netQty);
d155 2
a156 2
         // Commits the heuristically maximum possible quantity of thePart in
         // thePer, considering multiple selections.
d158 1
a158 9
      void commitMaxQtySel (
            WitPart * thePart,
            WitPeriod thePer,
            double &  netQty);
         //
         // Commits the heuristically maximum possible quantity of thePart in
         // thePer, for a given selection scheme.

      double findMaxQty (double desQty, WitPart * thePart, WitPeriod thePer);
d161 1
a161 1
         // thePart that is <= desQty and can be made in thePer.
d167 1
a167 5
      void defSearchGrid (
            WitPart * thePart,
            WitPeriod fillPer,
            double &  minQty,
            double &  incQty);
d177 1
a177 6
      double binarySearch (
            double    desQty,
            WitPart * thePart,
            WitPeriod thePer,
            double    minQty,
            double    incQty);
d183 1
a183 1
      WitBoolean tempCommit (WitPart * thePart, WitPeriod thePer, double qty);
d185 2
a186 6
         // Calls commit on temp data.
         // Returns TRUE iff the commit attempt succeeded.

      WitBoolean commit (WitPart * topPart, WitPeriod topPer, double qty);
         //
         // Attempts to commit qty units of topPart to a shipment in topPer. 
d189 1
a189 1
      WitBoolean innerCommit (WitPart * topPart, WitPeriod topPer, double qty);
a378 35
      inline WitSelector * mySelector ()
         {
         witAssert (multiSel ());

         return mySelector_;
         }

      inline WitProdRtr * myProdRtr ()
         {
         witAssert (myProdRtr_ != NULL);

         return myProdRtr_;
         }

      inline WitConsRtr * myConsRtr ()
         {
         witAssert (myConsRtr_ != NULL);

         return myConsRtr_;
         }

      inline WitBaMgr * myBaMgr ()
         {
         witAssert (myBaMgr_ != NULL);

         return myBaMgr_;
         }

      inline WitMeMgr * myMeMgr ()
         {
         witAssert (myMeMgr_ != NULL);

         return myMeMgr_;
         }

d398 8
a405 2
      accessWrapper (WitBoolean, skipFailures, myGlobalComp ())
      accessWrapper (WitBoolean, stockRealloc, myGlobalComp ())
d503 12
@


1.29
log
@Removed the possibility of a non-integer search grid from the heuristic.
@
text
@d70 6
a156 23
      void splitCommitSS (WitPart * thePart, WitPeriod thePer);
         //
         // Does a split-commit for one unit of top-level vol of thePart in
         // thePer.
         // Valid only in sel-split mode.

      void splitItrSS (
            WitPart *    thePart, 
            WitPeriod    thePer, 
            WitBoolean & tempCommOK,
            WitBoolean & resFound);
         //
         // Does one iteration of a split-commit for thePart in thePer.
         // On return, tempCommOK is TRUE, iff the initial temp-commit was
         //    successful.
         // On return, resFound is TRUE, iff a resolving alteration was found.
         // Valid only in sel-split mode.

      void splitSelSS ();
         //
         // Splits the selection.
         // Valid only in sel-split mode.

a425 7
      inline WitSplitter * mySplitter ()
         {
         witAssert (mySplitter_ != NULL);

         return mySplitter_;
         }

a500 6

      WitSplitter * mySplitter_;
         //
         // The Splitter associated with this HeurAllPerf, if any; 
         // otherwise NULL.
         // Non-null, iff selSplit_ is TRUE.
@


1.28
log
@Continued implementation of selection splitting.
@
text
@d174 1
a174 5
      double findMaxQty (
            double    desQty,
            double    knownQty,
            WitPart * thePart,
            WitPeriod thePer);
a181 1
         // It is assumed that knownQty is already known to be feasible.
a185 1
            double    knownQty,
d192 4
a195 1
         // It is assumed that knownQty is already known to be feasible.
@


1.27
log
@Continued implementation of selection splitting.
@
text
@d151 1
a151 1
      void splitCommitSS ();
d153 19
a171 1
         // Does a split-commit.
@


1.26
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d150 5
a154 1
         // Valid only in non-sel-split mode.
d428 7
d510 6
@


1.25
log
@Fixed a particularly difficult bug in coarse selection splitting.
@
text
@d143 1
a143 1
      void commitMaxQtySelNss (
a151 17
      void permCommit (
            WitPart * thePart, 
            WitPeriod thePer,
            double &  netQty,
            double    maxQty);
         //
         // Does a permanent commit of maxQty units of thePart in thePer,
         // netting against netQty.

      void appendCulpritIA ();
         //
         // Appends the culprit to the critical list, if appropriate.

      void netTopLevel (WitPart * thePart, WitPeriod thePer, double & netQty);
         //
         // Does netting at the top level for netQty units of thePart in thePer.

d549 1
a549 1
         // # calls to commitMaxQtySelNss.
@


1.24
log
@Further implementation of coarse selection splitting.
@
text
@d237 8
@


1.23
log
@Implemented coarse selection splitting for penalized execution.
@
text
@d130 1
a130 1
      void commitMaxQty (double & netQty, WitPart * thePart, WitPeriod thePer);
d135 1
a135 2
      void commitMaxQtyMultiSelNss (
            double &   netQty, 
d137 2
a138 1
            WitPeriod thePer);
a141 10
         // Valid only in non-sel-split mode.

      void commitMaxQtySS (
            double &   netQty, 
            WitPart * thePart, 
            WitPeriod thePer);
         //
         // Commits the heuristically maximum possible quantity of thePart in
         // thePer.
         // Valid only in sel-split mode.
a143 1
            double &  netQty,
d145 2
a146 1
            WitPeriod thePer);
d151 17
@


1.22
log
@Continued development of coarse selection splitting.
@
text
@d135 1
a135 1
      void commitMaxQtyMultiSel (
d141 2
a142 1
         // thePer, considering multiple selections, but not sel-split.
d150 2
a151 1
         // thePer, using sel-split.
d153 1
a153 1
      void commitMaxQtySel (
d160 1
d221 1
a221 1
      WitBoolean fillNetReq (
d230 1
a230 1
      WitBoolean fillNetReqSplitBAS (
d235 2
a236 1
         // Same as fillNetReq, but for a split build-ahead selection.
a243 1
         // Valid only in sel-split mode.
d246 1
d263 1
a264 1
         // Explodes theBopEnt in expPer.
d328 1
d551 1
a551 1
         // # calls to commitMaxQtySel.
@


1.21
log
@Implemented and used class SelMgr.
@
text
@d393 28
d466 24
@


1.20
log
@Fixed some bugs in coarse selection splitting.
@
text
@d70 7
a251 11

      WitBoolean explodePartPmrSS (
            WitPart * thePart, 
            WitPeriod expPer,
            double    netReqVol,
            WitPeriod fillPer);
         //
         // Valid only in multi-route sel-split mode.
         // Performs production multi-route selection-split explosions of
         // netReqVol units of thePart in expPer in order to meet requirements 
         // in fillPer.
@


1.19
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d218 1
d220 1
a220 1
      WitBoolean fillNetReqSS (
d225 8
d234 2
a235 1
         // See fillNetReq.
d237 4
a240 7
      WitBoolean defExpSplit (
            WitPart *        thePart, 
            WitPeriod        fillPer, 
            WitPerDblStack & splitList,
            double &         unExpVol,
            WitPeriod &      expPer,
            double &         expVol);
d242 3
a244 2
         // Defines the explosion period and volume in sel-split mode for 
         // thePart in fillPer, updating the state of splitList and unExpVol.
d246 1
a246 1
      WitBoolean explodePartSS (
d249 2
a250 2
            WitPeriod fillPer, 
            double    netReqVol);
d252 4
a255 3
         // Valid only in sel-split mode.
         // Performs selection-split explosions of netReqVol units of thePart
         // in expPer in order to meet requirements in fillPer.
@


1.18
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d211 7
a217 10
      WitBoolean defExpCoords (
            WitPart *       thePart, 
            WitPeriod       fillPer, 
            WitBopEntry * & theBopEnt,
            WitPeriod &     execPer);
         //
         // If an explosion period exists for filling internal demand for
         // thePart in fillPer, sets theBopEnt and execPer to the appropriate
         // BopEntry and execution period, and returns TRUE; 
         // otherwise returns FALSE.
d219 1
a219 1
      WitBoolean fillReqSsmrbop (
d222 12
a233 1
            double    theReqVol);
d235 2
a236 2
         // Valid only in sel-split for multi-route for BOP entries mode.
         // See fillReq.
d238 1
a238 1
      WitBoolean explodePartSsmrbop (
d244 1
a244 1
         // Valid only in sel-split for multi-route for BOP entries mode.
d248 1
a248 1
      WitBoolean explodeBopEntSsmrbop (
d254 1
a254 1
         // Valid only in sel-split for multi-route for BOP entries mode.
d376 1
a376 1
      inline WitBoolean selMode () 
d383 1
a383 1
         witAssert (selMode ());
d387 17
@


1.17
log
@Implemented EBS lower bound adjustment for sel-split.
@
text
@d222 28
a249 1
      void explode (
d253 1
a253 2
            WitPeriod     fillPer,
            WitBoolean &  expOK);
d259 1
a259 1
      void checkExecBounds (
d263 1
a263 2
            WitPeriod     fillPer,
            WitBoolean &  expOK);
d265 1
a265 1
         // Sets expOK to be TRUE, if exploding thru theBopEnt by increasing
d268 1
a268 2
         // Otherwise sets expOK to FALSE and records the failure, if 
         // appropriate.
d270 1
a270 1
      void innerExplode (
d275 1
a275 2
            WitPeriod     fillPer,
            WitBoolean &  expOK);
d279 1
a279 1
         // Sets expOK to be TRUE, if the explosion was feasible, else FALSE.
@


1.16
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@d154 1
d164 1
d169 1
d176 1
d178 1
a178 1
      double WitHeurAllPerf::binarySearch (
@


1.15
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d134 9
a142 1
         // thePer, considering multiple selections.
d194 4
@


1.14
log
@Refactoring for selection splitting.
@
text
@d249 1
a249 1
         // Only valid in stock reallocation mode.
d264 1
a264 1
      void explodeSplitBomEntry (
@


1.13
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d88 1
a88 3
      copyCtorAndAssignment (WitHeurAllPerf);
         //
         // Prevents unintentional copying and assignment.
@


1.12
log
@Implemented respectStockSLBs and prefHighStockSLBs global attributes.
@
text
@d256 1
a256 1
            double        netExecQty,
d261 1
a261 1
         // Explodes netExecQty units along theBomEnt in exec period execPer,
d266 9
d402 4
@


1.11
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d302 4
@


1.10
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@a18 1
#include <DupTVec.h>
a69 8
      inline WitDupTVec * & permExecVolDup (WitOperation * theOpn)
         {
         return (WitDupTVec * &) permExecVolDupTl_ (theOpn);
         }
         //
         // permExecVolDup (theOpn) is a ptr to a duplicate for
         // theOpn->execVol_.

d80 3
a82 3
      refAccess (WitDemand,    WitTVec (float), shipVol)
      refAccess (WitOperation, WitTVec (float), execVol)
      refAccess (WitSubEntry,  WitTVec (float), subVol)
a331 15
      inline WitDupTVec * & shipVolDup (WitDemand * theDemand)
         {
         return (WitDupTVec * &) shipVolDupTl_ (theDemand);
         }
         //
         // shipVolDup (theDemand) is a ptr to a duplicate for
         // theDemand->shipVol_.

      inline WitDupTVec * & subVolDup (WitSubEntry * theSub)
         {
         return (WitDupTVec * &) subVolDupTl_ (theSub);
         }
         //
         // subVolDup (theSub) is a ptr to a duplicate for theSub->subVol_.

d369 1
a369 1
      WitAccFlag * myAccFlag_;
a396 12

      WitMapping (WitDemand,    WitTypelessPtr) shipVolDupTl_;
         //
         // Data for shipVolDup (Demand *).

      WitMapping (WitOperation, WitTypelessPtr) permExecVolDupTl_;
         //
         // Data for permExecVolDup (Operation *).

      WitMapping (WitSubEntry,  WitTypelessPtr) subVolDupTl_;
         //
         // Data for subVolDup  (SubEntry *).
@


1.9
log
@Finished implementing stock reallocation.
@
text
@d67 4
d310 4
@


1.8
log
@Made HeurAllPerf::findMaxQty test desQty when it's < minQty.
   This fixed a "commit failed" error, by making the heuristic function
   properly in cases in which commit fails at a lower desQty than one in which
   it succeeds.
Moved top-level net into commitMaxQtySel.
@
text
@a349 1
      accessWrapper (WitBoolean, emulatedSF,   myGlobalComp ())
@


1.7
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d350 1
@


1.6
log
@Continued implementation of stock reallocation.
@
text
@d256 1
a256 1
         // Only valid in stock re-allocation mode.
d349 1
a349 1
      accessWrapper (WitBoolean, stockReAlloc, myGlobalComp ())
@


1.5
log
@Continued implementation of stock re-allocation.
@
text
@a19 1
#include <ReqSched.h>
d351 4
d410 1
a410 1
      WitReqSched myReqSched_;
@


1.4
log
@Minor update to stock re-allocation.
@
text
@d20 1
d190 1
a190 1
      WitBoolean commit (WitPart * thePart, WitPeriod thePer, double qty);
d192 1
a192 1
         // Attempts to commit qty units of thePart to a shipment in thePer. 
a194 5
      void initReqVol (WitPart * thePart, WitPeriod thePer, double qty);
         //
         // Initializes requirements for attempting to commit qty units of
         // thePart to a shipment in thePer.

d250 9
d278 1
a278 1
         // Nets the requirements for theBomEnt using both theBomEnt and
d287 1
a287 1
         // Nets the requirements of an Operation along a SubEntry.
d296 1
a296 1
         // Nets the requirements of an Operation along a ConsEntry.
d407 1
a407 1
      WitSchedule (WitPart, double) reqVol_;
d409 1
a409 1
         // Requirements Schedule.
@


1.3
log
@Initial implementation of stock re-allocation.
@
text
@d345 1
a345 2
      accessWrapper (WitBoolean, usingNetSupp, myGlobalComp ())
      accessWrapper (WitBoolean, usingSurplus, myGlobalComp ())
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d345 2
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

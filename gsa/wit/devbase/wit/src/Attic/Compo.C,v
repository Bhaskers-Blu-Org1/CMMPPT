head	1.109;
access;
symbols
	sce_5_01_20080919:1.105
	latest_sce_4_20_20060523:1.48.0.2
	sce_4_20_20060523:1.48
	latest_sce4_20_OSL:1.47.0.2
	sce_4_20_OSL:1.47
	sce_410_withVa:1.46
	sce_4_05_20040511:1.42
	sce_4_00_20040201:1.30
	nextGenBranch:1.28.0.2
	nextGenRoot:1.28
	sce_3_30_20030627:1.28
	EndRw-branch:1.22.0.4
	Root-of-EndRw:1.22
	rwToStl:1.22.0.2
	latest_sce_3_10_20010924:1.5.0.2
	sce_3_10_20010924:1.5
	latest_sce_3_00_20010601:1.4.0.4
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.4.0.2
	sce_2_31_20010308:1.4
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.109
date	2010.09.09.20.20.31;	author rjw;	state dead;
branches;
next	1.108;

1.108
date	2009.12.28.23.07.43;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2009.12.24.22.58.55;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2008.11.20.16.04.52;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2008.02.25.19.37.57;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2008.02.25.16.36.33;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.22.21.36.10;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2008.01.07.23.51.48;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.12.05.22.13.08;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.12.03.19.41.33;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.11.29.21.12.31;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.11.29.16.24.42;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.11.28.23.23.45;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.11.28.20.40.32;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.11.15.17.15.32;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.14.17.18.53;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.13.23.02.16;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.11.13.20.17.37;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.10.23.21.05.40;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.10.22.19.58.51;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.10.18.23.14.44;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.10.17.14.58.47;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.15.21.50.33;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.09.28.22.08.25;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.09.26.22.52.51;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.09.11.18.55.18;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.11.18.09.16;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.10.21.01.33;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.18.22.28.41;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.14.16.09.35;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.08.18.09.39;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.05.21.06.00;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.05.16.15.22;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.30.16.01.18;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.25.18.39.10;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.24.18.52.21;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.22.15.46.51;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.14.19.05.39;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.14.16.18.38;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.11.20.43.55;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.10.17.22.13;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.04.23.27.10;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.30.21.52.08;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.25.19.56.53;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.24.20.07.50;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.19.14.52.48;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.18.22.27.01;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.18.21.18.20;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.16.21.32.58;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.16.20.12.54;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.06.19.34.17;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.04.22.08.18;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.04.20.04.39;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.03.22.04.03;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.02.23.01.14;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.01.09.21.07.47;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.09.15.55.25;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.21.15.42.25;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.07.19.19.17.06;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.02.17.33.56;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.09.30.21.57.54;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.24.23.23.55;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.10.18.38.30;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.04.16.30.13;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.19.22.16.27;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.13.21.50.12;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.06.15.42.16;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.29.23.21.27;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.24.16.50.34;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.11.16.36.17;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.27.21.00.28;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.12.19.13.39;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.07.00.12.09;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.04.22.31.27;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.04.18.57.49;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.30.23.07.51;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.11.18.29.12;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.08.19.27.49;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.18.21.12.47;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.19.16.48.14;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.07.21.34.15;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.13.23.06.26;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.02.23.40.37;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.02.22.18.22;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.23.18.09.10;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.22.21.16.20;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.09.19.52.30;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.05.19.31.29;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.04.23.07.18;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.03.22.35.16;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.03.16.01.46;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.30.20.08.57;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.21.35.44;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.29.14.32.38;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.28.19.44.56;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.20.14.53;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.02.20.53.10;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.01.14.25.53;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.24.18.26.05;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.22.14.32.04;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.18.14.02.28;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.25.16.08.13;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.04.22.27.49;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.19;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.28;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches;
next	;


desc
@@


1.109
log
@Heuristic Adjustment
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "Compo.C"
//
// Contains the implementation of the following classes:
//
//    Component
//    DelComp
//    Node
//------------------------------------------------------------------------------

#include <Node.h>
#include <DelCompItr.h>
#include <OptComp.h>
#include <Part.h>
#include <Demand.h>
#include <Opn.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <DataWrit.h>
#include <Pre.h>
#include <HeurAllMgr.h>
#include <OptStarter.h>
#include <Post.h>
#include <FSS.h>
#include <BoundSet.h>
#include <OrigMrp.h>
#include <StochImpMgr.h>
#include <IVRealArg.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class Component.
//------------------------------------------------------------------------------

WitComponent::~WitComponent ()
   {
   witAssert (myCompMgr ()->isDeleting (this));
   }

//------------------------------------------------------------------------------

void WitComponent::setAppData (void * theData)
   {
   if (myStochImpMgr ()->stochMode ())
       myStochImpMgr ()->prepSetStochModeAttr ("appData");

   appData_ = theData;
   }

//------------------------------------------------------------------------------

void WitComponent::writeData ()
   {
   writeDataID ();

   writeDataAttrs ();

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitComponent::writeMultiObjVecs (WitObjective *)
   {
   }

//------------------------------------------------------------------------------

void WitComponent::writeSolnData ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::purgeCompLists ()
   {
   witAssert (myCompMgr ()->purging ());

   purgeCompListsSpec ();
   }

//------------------------------------------------------------------------------

void WitComponent::reindexBoundSet ()
   {
   witAssert (myBoundSet () != NULL);

   myBoundSet ()->reindex ();
   }

//------------------------------------------------------------------------------

WitComponent::WitComponent (WitCompMgr * theCompMgr):

      WitProbAssoc (theCompMgr->myProblem ()),
      appData_     (NULL)
   {
   myPreprocessor ()->unpreprocess ();
   }

//------------------------------------------------------------------------------

void WitComponent::prepSetUnpreAttr ()
   {
   myProblem ()->prepSetUnpreAttr ();
   }

//------------------------------------------------------------------------------

void WitComponent::prepSetUnpostAttr ()
   {
   myProblem ()->prepSetUnpostAttr ();
   }

//------------------------------------------------------------------------------

void WitComponent::prepSetNonUnpostAttr ()
   {
   myProblem ()->prepSetNonUnpostAttr ();
   }

//------------------------------------------------------------------------------

void WitComponent::clearDepLists ()
   {
   witAssert (myCompMgr ()->clearingDepLists ());

   clearDepListsSpec ();
   }

//------------------------------------------------------------------------------

WitBoundSet * WitComponent::myBoundSet ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

void WitComponent::unpreprocess ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::clearOptSoln ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::clearStochSoln ()
   {
   witAssert (myStochImpMgr ()->clearingSoln ());
   }

//------------------------------------------------------------------------------

WitDelComp * WitComponent::thisDelComp ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitNode * WitComponent::thisNode ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitPart * WitComponent::thisPart ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitMaterial * WitComponent::thisMat ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitCapacity * WitComponent::thisCap ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitOperation * WitComponent::thisOpn ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitConsEntry * WitComponent::thisConsEnt ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitBomEntry * WitComponent::thisBomEnt ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitSubEntry * WitComponent::thisSub ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitBopEntry * WitComponent::thisBopEnt ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitDemand * WitComponent::thisDemand ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

void WitComponent::writeDataAttrs ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::copyAttrsFrom (WitComponent * theComp)
   {
   witAssert (this != theComp);
   }

//------------------------------------------------------------------------------

void WitComponent::purgeCompListsSpec ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::clearDepListsSpec ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class DelComp.
//------------------------------------------------------------------------------

WitDelComp::~WitDelComp ()
   {
   }

//------------------------------------------------------------------------------

void WitDelComp::setSelForDel (bool theValue)
   {
   prepSetNonUnpostAttr ();

   selForDel_ = theValue;
   }

//------------------------------------------------------------------------------

void WitDelComp::identifyOrAutoSel ()
   {
   WitDelComp * prereq1;
   WitDelComp * prereq2;

   witAssert (myCompMgr ()->purging ());

   if (selForDel ())
      {
      if (myMsgFac ().mayIssue ("userSelForDelMsg"))
         myMsgFac () ("userSelForDelMsg");

      identify ();

      myMsgFac ().divide ();
      }
   else
      {
      findPrereqs   (prereq1, prereq2);
      autoSelForDel (prereq1);
      autoSelForDel (prereq2);
      }
   }

//------------------------------------------------------------------------------

void WitDelComp::identify ()
   {
   if (myMsgFac ().mayIssue ("objectTypeMsg"))
      myMsgFac () ("objectTypeMsg", objTypeMsgFrag ());

   identifyInstance ();
   }

//------------------------------------------------------------------------------

WitDelComp * WitDelComp::thisDelComp ()
   {
   return this;
   }

//------------------------------------------------------------------------------

void WitDelComp::display ()
   {
   if (selForDel ())
      if (myMsgFac ().mayIssue ("selForDelDdMsg"))
         myMsgFac () ("selForDelDdMsg");
   }

//------------------------------------------------------------------------------

void WitDelComp::prepSetScenSpecAttr (const char * theAttName)
   {
   if (myStochImpMgr ()->stochMode ())
      myStochImpMgr ()->prepSetScenSpecAttr (theAttName, this);

   myProblem ()->resetSoln ();
   }

//------------------------------------------------------------------------------
// Macro implementPurgeSelComps (CompClass)
//
// Implements DelComp::purgeSelComps (List <CompClass> &).
//
// CompClass must be derived from DelComp.
//------------------------------------------------------------------------------

#define implementPurgeSelComps(CompClass)                                      \
                                                                               \
void WitDelComp::purgeSelComps (WitList <CompClass> & theList)                 \
   {                                                                           \
   CompClass * theDerComp;                                                     \
   bool        selCompFound;                                                   \
                                                                               \
   selCompFound = false;                                                       \
                                                                               \
   forEachEl (theDerComp, theList)                                             \
      if (theDerComp->selForDel ())                                            \
         selCompFound = true;                                                  \
                                                                               \
   if (not selCompFound)                                                       \
      return;                                                                  \
                                                                               \
   WitList <CompClass> purgedList;                                             \
                                                                               \
   while (not theList.isEmpty ())                                              \
      {                                                                        \
      theDerComp = theList.get ();                                             \
                                                                               \
      if (not theDerComp->selForDel ())                                        \
         purgedList.append (theDerComp);                                       \
      }                                                                        \
                                                                               \
   theList = purgedList;                                                       \
   }                                                                           \

//------------------------------------------------------------------------------

implementPurgeSelComps (WitPart)
implementPurgeSelComps (WitDemand)
implementPurgeSelComps (WitOperation)
implementPurgeSelComps (WitBomEntry)
implementPurgeSelComps (WitSubEntry)
implementPurgeSelComps (WitBopEntry)

//------------------------------------------------------------------------------

WitDelComp::WitDelComp (WitCompMgr * theCompMgr):

      WitComponent (theCompMgr),

      selForDel_   (defSelForDel ())
   {
   if (myCompMgr ()->myDelCompItr ()->active ())
      myMsgFac () ("createWhileItrActSmsg");
   }

//------------------------------------------------------------------------------

void WitDelComp::writeDataAttrs ()
   {
   WitComponent::writeDataAttrs ();

   myDataWriter ()->writeBool (
        "selForDel",
         selForDel (),
      defSelForDel ());
   }

//------------------------------------------------------------------------------

void WitDelComp::copyAttrsFrom (WitDelComp * theDelComp)
   {
   WitComponent::copyAttrsFrom (theDelComp);

   selForDel_ = theDelComp->selForDel ();
   }

//------------------------------------------------------------------------------

void WitDelComp::findPrereqs (WitDelComp * & prereq1, WitDelComp * & prereq2)
   {
   prereq1 = NULL;
   prereq2 = NULL;
   }

//------------------------------------------------------------------------------

void WitDelComp::autoSelForDel (WitDelComp * prereq)
   {
   if (prereq != NULL)
      if (prereq->selForDel ())
         if (not selForDel ())
            {
            selForDel_ = true;

            if (myMsgFac ().mayIssue ("autoSelForDelMsg"))
               myMsgFac () ("autoSelForDelMsg");

            identify ();

            if (myMsgFac ().mayIssue ("selPrereqMsg"))
               myMsgFac () ("selPrereqMsg");

            prereq->identify ();

            myMsgFac ().divide ();
            }
   }

//------------------------------------------------------------------------------
// Implementation of class Node.
//------------------------------------------------------------------------------

WitNode::~WitNode ()
   {
   }

//------------------------------------------------------------------------------

int WitNode::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nNodes ();
   }

//------------------------------------------------------------------------------

void WitNode::storeCompMgrNodeName (const char * theName)
   {
   witAssert (myCompMgr ()->settingNodeName ());

   nodeName_ = theName;
   }

//------------------------------------------------------------------------------

WitNode * WitNode::thisNode ()
   {
   return this;
   }

//------------------------------------------------------------------------------

const WitString & WitNode::nodeName (const WitNode * theNode)
   {
   return theNode->nodeName ();
   }

//------------------------------------------------------------------------------

WitNode::WitNode (const char * theName, WitCompMgr * theCompMgr):

      WitDelComp (theCompMgr),

      nodeName_  (theName)
   {
   witAssert (not isNullCstring (theName));

   myProblem ()->allocTVecs ();
   }

//------------------------------------------------------------------------------

void WitNode::writeDataAttrs ()
   {
   WitDelComp::writeDataAttrs ();
   }

//------------------------------------------------------------------------------

void WitNode::copyAttrsFrom (WitNode * theNode)
   {
   WitDelComp::copyAttrsFrom (theNode);
   }
@


1.108
log
@Multi-Objective Mode
@
text
@@


1.107
log
@Multi-Objective Mode
@
text
@d74 1
a74 1
void WitComponent::writeObjVecs (WitObjective *)
@


1.106
log
@Allowed appData to be set in stochastic mode.
@
text
@d74 6
@


1.105
log
@Object name change.
@
text
@d55 2
a56 1
   prepSetNonUnpostAttr ();
@


1.104
log
@Object name change.
@
text
@d495 1
a495 1
      WitDelComp (preconstruct (theName, theCompMgr)),
d499 3
a516 17

//------------------------------------------------------------------------------

WitCompMgr * WitNode::preconstruct (
      const char * theName,
      WitCompMgr * theCompMgr)
   {
   witAssert (theName != NULL);

   witAssert (not isNullString (theName));

   witAssert (theCompMgr != NULL);

   theCompMgr->myProblem ()->allocTVecs ();

   return theCompMgr;
   }
@


1.103
log
@Object name changing.
@
text
@d470 1
a470 1
void WitNode::setNodeName (const char * theName)
d472 1
a472 5
   witAssert (theName != NULL);

   witAssert (not isNullString (theName));

   witAssert (myCompMgr ()->nameChangeNode () == this);
@


1.102
log
@Stochastic Implosion
@
text
@d470 13
@


1.101
log
@Stochastic Implosion
@
text
@a476 7
int WitNode::stageIndex ()
   {
   return myStochImpMgr ()->stageIndex (this);
   }

//------------------------------------------------------------------------------

@


1.100
log
@Stochastic Implosion
@
text
@d334 1
a334 1
void WitDelComp::prepSetStochModeAttr (const char * theAttName)
d337 1
a337 2
      if (myStochImpMgr ()->isScenSpec (theAttName))
         stronglyAssert (stageIndex () != 0);
d339 1
a339 1
   myProblem ()->prepSetStochModeAttr (theAttName);
@


1.99
log
@Stochastic Implosion
@
text
@d340 1
a340 1
   myStochImpMgr ()->prepSetStochModeAttr (theAttName);
@


1.98
log
@Stochastic Implosion
@
text
@a127 7
void WitComponent::prepSetStochModeAttr (const char * theAttName)
   {
   myProblem ()->prepSetStochModeAttr (theAttName);
   }

//------------------------------------------------------------------------------

d333 11
@


1.97
log
@Stochastic Implosion
@
text
@a211 7
WitBillEntry * WitComponent::thisBillEnt ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

d474 7
@


1.96
log
@Stochastic Implosion
@
text
@d212 7
@


1.95
log
@Stochastic Implosion
@
text
@a162 9
int WitComponent::stageIndex ()
   {
   stronglyAssert (false);

   return -1;
   }

//------------------------------------------------------------------------------

a466 7
int WitNode::stageIndex ()
   {
   return myStochImpMgr ()->stageIndex (this);
   }

//------------------------------------------------------------------------------

@


1.94
log
@Stochastic Implosion
@
text
@a150 6
void WitComponent::passPreRefs ()
   {
   }

//------------------------------------------------------------------------------

@


1.93
log
@Stochastic Implosion
@
text
@d23 5
a168 6
void WitComponent::passFssRefs ()
   {
   }

//------------------------------------------------------------------------------

d394 1
a398 1
implementPurgeSelComps (WitDemand)
@


1.92
log
@Stochastic Implosion
@
text
@a163 6
void WitComponent::passMrpRefs ()
   {
   }

//------------------------------------------------------------------------------

@


1.91
log
@Stochastic Implosion.
@
text
@d158 1
a158 1
void WitComponent::importOptSoln ()
@


1.90
log
@Stochastic Implosion
@
text
@d179 2
@


1.89
log
@Stochastic Implosion
@
text
@d176 1
a176 1
int WitComponent::stageNo ()
d487 1
a487 1
int WitNode::stageNo ()
d489 1
a489 1
   return myStochImpMgr ()->stageNo (this);
@


1.88
log
@Stochastic Implosion
@
text
@d176 7
d487 7
@


1.87
log
@Stochastic Implosion
@
text
@d190 7
d480 7
@


1.86
log
@Stochastic Implosion
@
text
@d176 7
@


1.85
log
@Stochastic Implosion
@
text
@d87 1
a87 1
   myBoundSetForUpdate ()->reindex ();
d139 7
a245 7
WitBoundSet * WitComponent::myBoundSetForUpdate ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

a269 23

void WitComponent::storeStochAttr (
            WitDblFlexVec &    theData,
      const WitTVec <double> & theValue)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   if (theValue.isAllocated ())
      theData = theValue;
   else
      theData = 0.0;
   }

//------------------------------------------------------------------------------

void WitComponent::storeStochAttr (double & theData, double theValue)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   theData = theValue;
   }

//------------------------------------------------------------------------------
@


1.84
log
@Stochastic Implosion
@
text
@a73 7
void WitComponent::writeDataSetClause ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

@


1.83
log
@Stochastic Implosion
@
text
@d278 1
a278 1
void WitComponent::loadInStochAttr (
d292 1
a292 1
void WitComponent::loadInStochAttr (double & theData, double theValue)
@


1.82
log
@Stochastic Implosion
@
text
@a136 11
void WitComponent::loadInStochAttr (
            WitDblFlexVec &    theData,
      const WitTVec <double> & theValue)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   theData = theValue;
   }

//------------------------------------------------------------------------------

a163 6
void WitComponent::importStochSoln ()
   {
   }

//------------------------------------------------------------------------------

d277 23
@


1.81
log
@Stochastic Implosion
@
text
@d137 11
a174 6
void WitComponent::importStochInput ()
   {
   }

//------------------------------------------------------------------------------

@


1.80
log
@Stochastic Implosion
@
text
@d100 1
a101 1

@


1.79
log
@Stochastic Implosion
@
text
@d130 1
a130 1
void WitComponent::prepSetStochModeAttr ()
d132 1
a132 1
   myProblem ()->prepSetStochModeAttr ();
@


1.78
log
@Stochastic Implosion
@
text
@d130 7
@


1.77
log
@Stochastic Implosion
@
text
@d151 1
a151 1
void WitComponent::acquireOptSoln ()
d157 7
a163 1
void WitComponent::passMrpRefs ()
d169 1
a169 1
void WitComponent::passFssRefs ()
d175 1
a175 1
void WitComponent::passStochRefs ()
@


1.76
log
@Stochastic Implosion
@
text
@a144 6
void WitComponent::importPreData ()
   {
   }

//------------------------------------------------------------------------------

a275 7

const WitPreData * WitComponent::expPreData ()
   {
   return myPreprocessor ()->expPreData ();
   }

//------------------------------------------------------------------------------
@


1.75
log
@Stochastic Implosion
@
text
@d139 6
@


1.74
log
@Stochastic Implosion
@
text
@d139 6
d276 7
@


1.73
log
@Stochastic Implosion
@
text
@d145 1
a145 1
void WitComponent::importOptImpSoln (WitPeriod)
@


1.72
log
@Stochastic Implosion
@
text
@d151 1
a151 1
void WitComponent::passMrpData ()
d157 1
a157 1
void WitComponent::passFssData ()
d163 1
a163 1
void WitComponent::passStochData ()
@


1.71
log
@Stochastic Implosion
@
text
@d163 1
a163 13
void WitComponent::restoreStochInputAttrs ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::clearStochSoln ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::restoreStochSoln ()
@


1.70
log
@Stochastic Implosion
@
text
@d151 1
a151 1
void WitComponent::importMrpSoln ()
@


1.69
log
@Stochastic Implosion
@
text
@d157 6
@


1.68
log
@Stochastic Implosion
@
text
@d151 6
@


1.67
log
@Stochastic Implosion
@
text
@d145 6
@


1.66
log
@Stochastic Implosion
@
text
@d145 18
@


1.65
log
@Stochastic Implosion
@
text
@d32 1
a32 1
#include <StochMgr.h>
@


1.64
log
@Stochastic Implosion
@
text
@d50 1
a50 1
   settingNonUnpostAttr ();
d109 1
a109 1
void WitComponent::settingUnpreAttr ()
d111 1
a111 1
   myProblem ()->settingUnpreAttr ();
d116 1
a116 1
void WitComponent::settingUnpostAttr ()
d118 1
a118 1
   myProblem ()->settingUnpostAttr ();
d123 1
a123 1
void WitComponent::settingNonUnpostAttr ()
d125 1
a125 1
   myProblem ()->settingNonUnpostAttr ();
d257 1
a257 1
   settingNonUnpostAttr ();
@


1.63
log
@Stochastic Implosion
@
text
@a122 7
void WitComponent::settingStochAttr ()
   {
   myProblem ()->settingStochAttr ();
   }

//------------------------------------------------------------------------------

@


1.62
log
@Stochastic Implosion
@
text
@a32 1
#include <StochMode.h>
a252 7

WitScenario * WitComponent::curScenario ()
   {
   return myStochMgr ()->myStochModeMgr ()->curScenario ();
   }

//------------------------------------------------------------------------------
@


1.61
log
@Stochastic Implosion
@
text
@a152 6
void WitComponent::retrieveStochAttrs ()
   {
   }

//------------------------------------------------------------------------------

@


1.60
log
@Stochastic Implosion
@
text
@d75 7
@


1.59
log
@Stochastic implosion
@
text
@d33 1
a33 1
#include <StochProb.h>
d256 1
a256 1
   return myStochMgr ()->myStochProb ()->curScenario ();
@


1.58
log
@Stochastic implosion.
@
text
@d32 2
d146 6
d253 7
@


1.57
log
@Stochastic implosion.
@
text
@d49 2
d122 7
d256 2
@


1.56
log
@Stochastic Implosion.
@
text
@a27 1
#include <StochMgr.h>
d98 20
a117 1
// Other functions.
@


1.55
log
@Stochastic implosion.
@
text
@a343 8
void WitDelComp::forbidAddStochAct ()
   {
   if (myStochMgr ()->active ())
      myMsgFac () ("addStochActSmsg", objTypeMsgFrag ());
   }

//------------------------------------------------------------------------------

@


1.54
log
@Stochastic Implosion.
@
text
@d347 1
a347 1
      myMsgFac () ("addWhileStochActiveSmsg", objTypeMsgFrag ());
@


1.53
log
@Stochastic implosion.
@
text
@d28 1
a32 1
#include <StochMgr.h>
a186 9
void WitComponent::forbidAddStochAct (WitMsgFragID theMsgFragID)
   {
   if (myStochMgr ()->active ())
      myMsgFac () ("addWhileStochActiveSmsg",
         myMsgFac ().myFrag (theMsgFragID));
   }

//------------------------------------------------------------------------------

d263 1
a263 1
      myMsgFac () ("objectTypeMsg", myMsgFac ().myFrag (classFragID ()));
d344 8
@


1.52
log
@witCopy<Object>Data
@
text
@d32 1
d187 9
@


1.51
log
@witCopy<Object>Data
@
text
@d201 1
a201 2
   witAssert (this         != theComp);
   witAssert (myProblem () == theComp->myProblem ()->copyingIntoProblem ());
@


1.50
log
@App controlled opt implosion.
@
text
@d201 1
@


1.49
log
@Replaced WIT's hash tables with std:maps.
@
text
@a20 1
#include <DataAlt.h>
d94 1
a94 155
   myProblem ()->preprocAlt ()->incur ();
   }

//------------------------------------------------------------------------------
// Attribute preparation utilities.
//------------------------------------------------------------------------------

bool WitComponent::prepBool (bool theValue, WitDataAlt * theDataAlt)
   {  
   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

int WitComponent::prepRangedInt (
      int          theValue,
      WitDataAlt * theDataAlt,
      int          lb,
      int          ub)
   {
   witAssert (theValue >= lb);

   witAssert (theValue <= ub or ub < 0);

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

double WitComponent::prepDouble (double theValue, WitDataAlt * theDataAlt)
   {
   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

double WitComponent::prepNonNegDouble (double theValue, WitDataAlt * theDataAlt)
   {
   witAssert (theValue >= 0.0);

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

const WitBoolean * WitComponent::prepBoolVec (
      const WitBoolean * theValue,
      WitDataAlt *       theDataAlt)
   {
   witAssert (theValue != NULL);

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

const WitIVRealArg & WitComponent::prepDblVec (
      const WitIVRealArg & theValue,
      WitDataAlt *         theDataAlt)
   {
   witAssert (theValue != NULL);

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

const WitIVRealArg & WitComponent::prepNonNegDblVec (
      const WitIVRealArg & theValue,
      WitDataAlt *         theDataAlt)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         witAssert (theValue[thePer] >= 0.0);

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

const WitIVRealArg & WitComponent::prepSchedVec (
      const WitIVRealArg & theValue,
      WitDataAlt *         theDataAlt)
   {
   myOptComp ()->schedOptStarter ()->beChosen ();

   return prepNonNegDblVec (theValue, theDataAlt);
   }

//------------------------------------------------------------------------------

const int * WitComponent::prepBuildAheadUB (const int * theValue)
   {
   WitPeriod thePer;

   prepPeriodIntVec (theValue, postprocAlt ());

   if (DEBUG_MODE)
      for (thePer = 1; thePer < nPeriods (); thePer ++)
         witAssert (theValue[thePer] <= theValue[thePer - 1] + 1);

   return theValue;
   }

//------------------------------------------------------------------------------

const int * WitComponent::prepPeriodIntVec (
      const int *  theValue, 
      WitDataAlt * theDataAlt)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         witAssert (theValue[thePer] >= 0);
         witAssert (theValue[thePer] < nPeriods ());
         }

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

const char * WitComponent::prepString (
      const char * theValue, 
      WitDataAlt * theDataAlt)
   {
   witAssert (theValue != NULL);

   theDataAlt->incur ();

   return theValue;
d228 1
a228 1
   selForDel_ = prepBool (theValue, noOpAlt ());
@


1.48
log
@Updated the copyright date on all source files.
@
text
@a476 1
implementPurgeSelComps (WitNode)
@


1.47
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.46
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@a340 42
void WitComponent::loadPre ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::loadOptPre ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::loadPost ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::loadMrp ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::loadFss ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::loadHeur ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::loadOpt ()
   {
   }

//------------------------------------------------------------------------------

@


1.45
log
@Vector PropRt.
@
text
@a192 15
const WitIVRealArg & WitComponent::prepObj1DblVec (
      const WitIVRealArg & theValue,
      WitDataAlt *         theDataAlt)
   {
   witAssert (theValue != NULL);

   witAssert (myOptComp ()->myObjFunc1 ()->isChosen ());

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

@


1.44
log
@Vector propRt.
@
text
@d33 1
a33 1
#include <InVecRA.h>
d161 3
a163 3
const WitInVecRA & WitComponent::prepDblVec (
      const WitInVecRA & theValue,
      WitDataAlt *       theDataAlt)
d174 3
a176 3
const WitInVecRA & WitComponent::prepNonNegDblVec (
      const WitInVecRA & theValue,
      WitDataAlt *       theDataAlt)
d193 3
a195 3
const WitInVecRA & WitComponent::prepObj1DblVec (
      const WitInVecRA & theValue,
      WitDataAlt *       theDataAlt)
d208 3
a210 3
const WitInVecRA & WitComponent::prepSchedVec (
      const WitInVecRA & theValue,
      WitDataAlt *       theDataAlt)
@


1.43
log
@Initial work on [vector propRouting attribute].
@
text
@d152 2
@


1.42
log
@Double Precision.
@
text
@d148 11
@


1.41
log
@Double Precision.
@
text
@a147 13
const float * WitComponent::prepDblVec (
      const float * theValue,
      WitDataAlt *  theDataAlt)
   {
   witAssert (theValue != NULL);

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

a160 19
const float * WitComponent::prepNonNegDblVec (
      const float * theValue,
      WitDataAlt *  theDataAlt)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         witAssert (theValue[thePer] >= 0.0);

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

a179 15
const float * WitComponent::prepObj1DblVec (
      const float * theValue,
      WitDataAlt *  theDataAlt)
   {
   witAssert (theValue != NULL);

   witAssert (myOptComp ()->myObjFunc1 ()->isChosen ());

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

a190 11
   }

//------------------------------------------------------------------------------

const float * WitComponent::prepSchedVec (
      const float * theValue,
      WitDataAlt *  theDataAlt)
   {
   myOptComp ()->schedOptStarter ()->beChosen ();

   return prepNonNegDblVec (theValue, theDataAlt);
@


1.40
log
@Double Precision.
@
text
@d574 1
a574 1
   theList.copy (purgedList);                                                  \
@


1.39
log
@Double Precision.
@
text
@d165 1
a165 1
   witAssert (theValue.asaTlPtr () != NULL);
d199 1
a199 1
   witAssert (theValue.asaTlPtr () != NULL);
d231 1
a231 1
   witAssert (theValue.asaTlPtr () != NULL);
@


1.38
log
@Double Precision.
@
text
@d148 1
a148 1
const float * WitComponent::prepFloatVec (
d161 14
a174 1
const float * WitComponent::prepNonNegFloatVec (
d199 2
d212 1
a212 1
const float * WitComponent::prepObj1FloatVec (
d227 15
d248 12
a259 1
   return prepNonNegFloatVec (theValue, theDataAlt);
@


1.37
log
@Double Precision.
@
text
@d33 1
d168 17
@


1.36
log
@Double Precision.
@
text
@a596 4
int WitNode::totNodes_ = 0;

//------------------------------------------------------------------------------

a598 1
   totNodes_ --;
a616 7
int WitNode::totNodes ()
   {
   return totNodes_;
   }

//------------------------------------------------------------------------------

a622 1
   totNodes_ ++;
@


1.35
log
@Continued double precision.
@
text
@d597 4
d603 1
d622 7
d635 1
@


1.34
log
@Continued double precision.
@
text
@d127 1
a127 1
StrDbl WitComponent::prepStrDbl (StrDbl theValue, WitDataAlt * theDataAlt)
d136 1
a136 1
StrDbl WitComponent::prepNonNegStrDbl (StrDbl theValue, WitDataAlt * theDataAlt)
@


1.33
log
@Continued double precision.
@
text
@a126 20
float WitComponent::prepFloat (float theValue, WitDataAlt * theDataAlt)
   {
   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

float WitComponent::prepNonNegFloat (float theValue, WitDataAlt * theDataAlt)
   {
   witAssert (theValue >= 0);

   theDataAlt->incur ();

   return theValue;
   }

//------------------------------------------------------------------------------

@


1.32
log
@Continued double precision.
@
text
@d147 1
a147 1
double WitComponent::prepDouble (double theValue, WitDataAlt * theDataAlt)
d156 1
a156 1
double WitComponent::prepNonNegDouble (double theValue, WitDataAlt * theDataAlt)
d158 1
a158 1
   witAssert (theValue >= 0);
@


1.31
log
@Continued double precision.
@
text
@d156 11
@


1.30
log
@Removed a bad function overload.
@
text
@d147 9
@


1.29
log
@Continued implementation of post-implosion pegging.
@
text
@d272 1
a272 1
WitDelComp * WitComponent::myDelComp ()
d279 1
a279 1
WitPart * WitComponent::myPart ()
d286 1
a286 1
WitMaterial * WitComponent::myMat ()
d293 1
a293 1
WitCapacity * WitComponent::myCap ()
d300 1
a300 1
WitOperation * WitComponent::myOpn ()
d307 1
a307 1
WitConsEntry * WitComponent::myConsEnt ()
d314 1
a314 1
WitBomEntry * WitComponent::myBomEnt ()
d321 1
a321 1
WitSubEntry * WitComponent::mySub ()
d328 1
a328 1
WitBopEntry * WitComponent::myBopEnt ()
d335 1
a335 1
WitDemand * WitComponent::myDemand ()
d467 1
a467 1
WitDelComp * WitDelComp::myDelComp ()
@


1.28
log
@Made modifications to improve the speed of witPurgeData.
@
text
@d293 7
@


1.27
log
@Continued implementation of proportionate routing.
@
text
@d433 2
a434 1
      myMsgFac () ("userSelForDelMsg");
d452 2
a453 1
   myMsgFac () ("objectTypeMsg", myMsgFac ().myFrag (classFragID ()));
d470 2
a471 1
      myMsgFac () ("selForDelDdMsg");
d572 2
a573 1
            myMsgFac () ("autoSelForDelMsg");
d577 2
a578 1
            myMsgFac () ("selPrereqMsg");
@


1.26
log
@Continued implementation of proportionate routing.
@
text
@d272 1
a272 1
void WitComponent::getDelComp (WitDelComp * & theDelComp)
d274 1
a274 1
   theDelComp = NULL;
d279 1
a279 1
void WitComponent::getPart (WitPart * & thePart)
d281 1
a281 1
   thePart = NULL;
d286 1
a286 1
void WitComponent::getMaterial (WitMaterial * & theMat)
d288 1
a288 1
   theMat = NULL;
d293 1
a293 1
void WitComponent::getOperation (WitOperation * & theOpn)
d295 1
a295 1
   theOpn = NULL;
d300 1
a300 1
void WitComponent::getConsEntry (WitConsEntry * & theConsEnt)
d302 1
a302 1
   theConsEnt = NULL;
d307 1
a307 1
void WitComponent::getBomEntry (WitBomEntry * & theBomEnt)
d309 1
a309 1
   theBomEnt = NULL;
d314 1
a314 1
void WitComponent::getSubEntry (WitSubEntry * & theSub)
d316 1
a316 1
   theSub = NULL;
d321 1
a321 1
void WitComponent::getBopEntry (WitBopEntry * & theBopEnt)
d323 1
a323 1
   theBopEnt = NULL;
d328 1
a328 1
void WitComponent::getDemand (WitDemand * & theDemand)
d330 1
a330 1
   theDemand = NULL;
d458 1
a458 1
void WitDelComp::getDelComp (WitDelComp * & theDelComp)
d460 1
a460 1
   theDelComp = this;
@


1.25
log
@Continued implementation of proportionate routing.
@
text
@d300 7
@


1.24
log
@Internal changes.
@
text
@d584 7
@


1.23
log
@Internal changes.
@
text
@d118 1
a118 1
   witAssert (theValue <= ub || ub < 0);
d485 1
a485 1
   if (! selCompFound)                                                         \
d490 1
a490 1
   while (! theList.isEmpty ())                                                \
d494 1
a494 1
      if (! theDerComp->selForDel ())                                          \
d558 1
a558 1
         if (! selForDel ())
d621 1
a621 1
   witAssert (! isNullString (theName));
@


1.22
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d101 1
a101 3
WitBoolean WitComponent::prepBoolean (
      WitBoolean   theValue,
      WitDataAlt * theDataAlt)
d410 1
a410 1
void WitDelComp::setSelForDel (WitBoolean theValue)
d412 1
a412 1
   selForDel_ = prepBoolean (theValue, noOpAlt ());
d477 1
a477 1
   WitBoolean  selCompFound;                                                   \
d479 1
a479 1
   selCompFound = witFALSE;                                                    \
d483 1
a483 1
         selCompFound = witTRUE;                                               \
d529 1
a529 1
   myDataWriter ()->writeBoolean (
d560 1
a560 1
            selForDel_ = witTRUE;
@


1.21
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d23 1
d28 1
a28 1
#include <OptImp.h>
@


1.20
log
@Continued implementation of single-source.
@
text
@d23 1
@


1.19
log
@Continued implementation of single-source.
@
text
@d31 1
d444 1
a444 1
   myMsgFac () ("objectTypeMsg", myMsgFac ()[classFragID ()]);
@


1.18
log
@Continued implementation of single-source.
@
text
@d357 1
a357 1
WitBoundSet * WitComponent::myBoundSetForUpdate ()
a358 1
   return NULL;
d363 1
a363 1
void WitComponent::writeDataAttrs ()
d369 1
a369 1
void WitComponent::copyAttrsFrom (WitComponent * theComp)
d371 1
a371 1
   witAssert (myProblem () == theComp->myProblem ()->copyingIntoProblem ());
d376 1
a376 1
void WitComponent::purgeCompListsSpec ()
d382 1
a382 1
void WitComponent::clearDepListsSpec ()
d384 1
d389 1
a389 1
WitBoolean WitComponent::heurAllAcc ()
a390 1
   return myHeurAllMgr ()->myAccFlag ()->accessing (this);
d395 1
a395 1
WitBoolean WitComponent::optImpAcc ()
a396 1
   return myOptImploder ()->myAccFlag ()->accessing (this);
@


1.17
log
@Continued implementation of single-source.
@
text
@d265 6
d327 12
a384 7
   }

//------------------------------------------------------------------------------
    
WitBoolean WitComponent::preprocAcc ()
   {
   return myPreprocessor ()->myAccFlag ()->accessing (this);
@


1.16
log
@Continued implementation of single-source.
@
text
@d321 18
a387 21
   }

//------------------------------------------------------------------------------

WitBoolean WitComponent::postprocAcc ()
   {
   return myPostprocessor ()->myAccFlag ()->accessing (this);
   }

//------------------------------------------------------------------------------

WitBoolean WitComponent::fssAcc ()
   {
   return myFSS ()->myAccFlag ()->accessing (this);
   }

//------------------------------------------------------------------------------

WitBoolean WitComponent::mrpAcc ()
   {
   return myOrigMrpExp ()->myAccFlag ()->accessing (this);
@


1.15
log
@Continued implementation of single-source.
@
text
@a320 12
void WitComponent::importMrpResults ()
   {
   }

//------------------------------------------------------------------------------

void WitComponent::importFssResults ()
   {
   }

//------------------------------------------------------------------------------

d370 21
@


1.14
log
@Continued implementation of single-source.
@
text
@a320 6
void WitComponent::importPostprocResults ()
   {
   }

//------------------------------------------------------------------------------

@


1.13
log
@Continued implementation of single-source.
@
text
@d321 6
a387 7
   }

//------------------------------------------------------------------------------

WitBoolean WitComponent::postprocAcc ()
   {
   return myPostprocessor ()->myAccFlag ()->accessing (this);
@


1.12
log
@Continued implementation of single-source.
@
text
@d327 6
a388 7
   }

//------------------------------------------------------------------------------

WitBoolean WitComponent::fssAcc ()
   {
   return myFSS ()->myAccFlag ()->accessing (this);
@


1.11
log
@Continued preliminary work on single source.
@
text
@d321 6
a389 7
   }

//------------------------------------------------------------------------------

WitBoolean WitComponent::mrpAcc ()
   {
   return myOrigMrpExp ()->myAccFlag ()->accessing (this);
@


1.10
log
@Preliminary work on single source.
@
text
@d29 1
@


1.9
log
@Preliminary work on single source.
@
text
@d490 1
a490 1
   theList.copyOf (purgedList);                                                \
@


1.8
log
@Continued implementation of object iteration.
@
text
@d459 2
a460 1
// Implements DelComp::purgeSelComps (List (CompClass) &)
d466 1
a466 1
void WitDelComp::purgeSelComps (WitList (CompClass) & theList)                 \
d480 1
a480 1
   WitList (CompClass) purgedList;                                             \
d490 1
a490 1
   theList = purgedList;                                                       \
@


1.7
log
@Continued implementation of object iteration.
@
text
@a397 1
   stronglyAssert (! myCompMgr ()->myDelCompItr ()->active ());
a438 2

   myMsgFac () ("lineFeedMsg");
d511 1
a511 1
      myMsgFac () ("createDuringItrSmsg");
@


1.6
log
@Began implementation of object iteration.
@
text
@d22 1
a35 10
WitComponent::WitComponent (WitCompMgr * theCompMgr):
      WitProbAssoc (theCompMgr->myProblem ()),

      appData_     (NULL)
   {
   myProblem ()->preprocAlt ()->incur ();
   }

//------------------------------------------------------------------------------

a49 9
WitBoolean WitComponent::isADelComp (WitDelComp * & theDelComp)
   {
   theDelComp = NULL;

   return witFALSE;
   }

//------------------------------------------------------------------------------

d84 10
d264 56
a395 10
WitDelComp::WitDelComp (WitCompMgr * theCompMgr):

      WitComponent (theCompMgr),

      selForDel_   (defSelForDel ())
   {
   }

//------------------------------------------------------------------------------

d398 1
d405 1
a405 10
   selForDel_ = prepBoolean (theValue, noopAlt ());
   }

//------------------------------------------------------------------------------

WitBoolean WitDelComp::isADelComp (WitDelComp * & theDelComp)
   {
   theDelComp = this;

   return witTRUE;
d446 7
d507 12
a571 10
WitNode::WitNode (const char * theName, WitCompMgr * theCompMgr):

      WitDelComp (preconstruct (theName, theCompMgr)),

      nodeName_  (theName)
   {
   }

//------------------------------------------------------------------------------

d585 1
a585 4
WitBoolean WitNode::isaPart ()
   {
   return witFALSE;
   }
d587 1
a587 1
//------------------------------------------------------------------------------
d589 1
a589 1
WitBoolean WitNode::isanOperation ()
a590 1
   return witFALSE;
@


1.5
log
@Initial implementation of pegging.
@
text
@d29 1
@


1.4
log
@Coarse selection splitting.
@
text
@d24 1
a24 1
#include <HeurAll.h>
d312 1
a312 1
   return myHeurAllocator ()->myAccFlag ()->accessing (this);
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@a100 7

void WitComponent::recount ()
   {
   myCompMgr ()->recount (this);
   }

//------------------------------------------------------------------------------
d302 1
a302 1

@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d586 1
a586 1
   witAssert (! WitUtil::isNullString (theName));
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

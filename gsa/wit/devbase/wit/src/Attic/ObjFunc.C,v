head	1.55;
access;
symbols
	sce_5_01_20080919:1.51
	latest_sce_4_20_20060523:1.46.0.2
	sce_4_20_20060523:1.46
	latest_sce4_20_OSL:1.45.0.2
	sce_4_20_OSL:1.45
	sce_410_withVa:1.37
	sce_4_05_20040511:1.33
	sce_4_00_20040201:1.23
	nextGenBranch:1.20.0.2
	nextGenRoot:1.20
	sce_3_30_20030627:1.20
	EndRw-branch:1.15.0.4
	Root-of-EndRw:1.15
	rwToStl:1.15.0.2
	latest_sce_3_10_20010924:1.6.0.2
	sce_3_10_20010924:1.6
	latest_sce_3_00_20010601:1.5.0.4
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.55
date	2009.11.18.19.00.01;	author rjw;	state dead;
branches;
next	1.54;

1.54
date	2009.11.17.23.45.47;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.17.22.54.49;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.13.19.01.25;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.07.20.10.22;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.07.21.22.36;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.01.22.41.57;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.08.21.54.41;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.02.17.34.04;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.02.20.00.43;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.01.21.49.25;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.09.27.21.50.18;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.27.20.31.00;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.27.17.56.33;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.26.23.02.18;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.26.21.44.32;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.26.18.47.56;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.13.16.48.47;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.30.20.23.31;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.28.20.14.36;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.19.22.16.28;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.24.19.17.33;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.02.23.52.13;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.20.15.37.35;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.12.19.13.39;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.06.23.27.09;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.06.20.14.14;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.11.18.29.13;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.19.16.48.21;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.14.20.12.58;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.23.20.47.17;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.02.23.40.44;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.22.18.37;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.11.18.53.10;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.23.18.09.12;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.06.18.53.40;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.19.21.52;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.20.15.00;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.03.19.58.28;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.22.14.32.10;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.14.02.37;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.28.00.12.59;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.18.50.58;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.20.00.44.20;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.06.19.58.39;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.24;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.27;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.26;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.26;	author wit;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Removing objective #2.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "ObjFunc.C"
//
// Contains the implementation of the following classes:
//
// ObjFunc
// ObjFunc0
// ObjFunc1
//------------------------------------------------------------------------------

#include <DetOptImpMgr.h>
#include <StochImpMgr.h>
#include <Material.h>
#include <Opn.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <Demand.h>
#include <OptComp.h>
#include <DataWrit.h>
#include <PtrVecSort.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class ObjFunc.
//------------------------------------------------------------------------------

WitObjFunc::WitObjFunc (WitOptComp * theOptComp, int indexVal):

      WitProbAssoc (theOptComp),
      index_       (indexVal)
   {
   }

//------------------------------------------------------------------------------

WitObjFunc::~WitObjFunc ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class ObjFunc0.
//------------------------------------------------------------------------------

WitObjFunc0::WitObjFunc0 (WitOptComp * theOptComp):
      WitObjFunc (theOptComp, 0)
   {
   }

//------------------------------------------------------------------------------

WitObjFunc0::~WitObjFunc0 ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class ObjFunc1.
//------------------------------------------------------------------------------

WitObjFunc1::WitObjFunc1 (WitOptComp * theOptComp):

      WitObjFunc (theOptComp, 1)
   {
   }

//------------------------------------------------------------------------------

WitObjFunc1::~WitObjFunc1 ()
   {
   }
@


1.54
log
@Removing objective #2.
@
text
@@


1.53
log
@Removing objective #2.
@
text
@a40 1
   theOptComp->store (this);
a49 14

void WitObjFunc::beChosen ()
   {
   myOptComp ()->choose (this);
   }

//------------------------------------------------------------------------------

bool WitObjFunc::isChosen ()
   {
   return (objChoice () == this);
   }

//------------------------------------------------------------------------------
@


1.52
log
@Removing objective #2.
@
text
@a17 1
// OptStarter
a19 1
#include <OptStarter.h>
d38 2
a39 3
      WitProbAssoc    (theOptComp),
      priorityPeriod_ (-1),
      index_          (indexVal)
a51 31
void WitObjFunc::validateForOptImp ()
   {
   }

//------------------------------------------------------------------------------

bool WitObjFunc::negativeObj1CostsExist ()
   {
   return false;
   }

//------------------------------------------------------------------------------

void WitObjFunc::displayForObj1 (WitMsgID, const WitDblFlexVec &)
   {
   }

//------------------------------------------------------------------------------

void WitObjFunc::displayForObj2 (WitMsgID, double)
   {
   }

//------------------------------------------------------------------------------

void WitObjFunc::finalPreprocess ()
   {
   }

//------------------------------------------------------------------------------

a64 39
// Automatically generates priorities from objective data.
// Stores the new priorities in newPriority.
// The priorities are generated as follows:
// The demands are sorted according to objective function data.
// Then the priorities are assigned according to the order in which the
// demands appear in the sorted list.
//------------------------------------------------------------------------------

void WitObjFunc::genPriorities (WitSchedule <WitDemand, int> & newPriority)
   {
   int         theIdx;
   WitDemand * theDemand;

   WitPtrVec    <WitDemand> theDemVec;
   WitPtrVecItr <WitDemand> theItr;

   theDemVec.resize (myCompMgr ()->nDemands ());

   theIdx = -1;

   forEachDemand (theDemand, myProblem ())
      {
      theIdx ++;

      theDemVec[theIdx] = theDemand;
      }

   forEachPeriod (priorityPeriod_, myProblem ())
      {
      sortDemands (theDemVec);

      theDemVec.attachItr (theItr);

      while (theItr.advance (theDemand))
         newPriority (theDemand)[priorityPeriod_] = theItr.myIdx () + 1;
      }
   }

//------------------------------------------------------------------------------
a79 31

void WitObjFunc0::validateForOptImp ()
   {
   myMsgFac () ("optImpObj0Smsg");
   }

//------------------------------------------------------------------------------

void WitObjFunc0::initValues ()
   {
   }

//------------------------------------------------------------------------------

void WitObjFunc0::compValues ()
   {
   }

//------------------------------------------------------------------------------

void WitObjFunc0::writeValues ()
   {
   }

//------------------------------------------------------------------------------

void WitObjFunc0::sortDemands (WitPtrVec <WitDemand> &)
   {
   }

//------------------------------------------------------------------------------
a93 177

//------------------------------------------------------------------------------

bool WitObjFunc1::negativeObj1CostsExist ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachPart (thePart, myProblem ())
      if (not (thePart->scrapCost () >= 0.0))
         return true;

   forEachMaterial (theMat, myProblem ())
      if (not (theMat->stockCost () >= 0.0))
         return true;

   forEachOperation (theOpn, myProblem ())
      if (not (theOpn->execCost () >= 0.0))
         return true;

   forEachSubEntry (theSub, myProblem ())
      if (not (theSub->subCost () >= 0.0))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitObjFunc1::displayForObj1 (
      WitMsgID              theMsgID,
      const WitDblFlexVec & theFlexVec)
   {
   myProblem ()->display (theMsgID, theFlexVec);
   }

//------------------------------------------------------------------------------

void WitObjFunc1::initValues ()
   {
   }

//------------------------------------------------------------------------------

void WitObjFunc1::compValues ()
   {
   }

//------------------------------------------------------------------------------

void WitObjFunc1::writeValues ()
   {
   myMsgFac () ("obj1ValueMsg", myOptComp ()->objValue ());
   }

//------------------------------------------------------------------------------

void WitObjFunc1::sortDemands (WitPtrVec <WitDemand> & theDemVec)
   {
   sort (
        theDemVec,
      & WitObjFunc1::compareDemands,
        this);
   }

//------------------------------------------------------------------------------

bool WitObjFunc1::compareDemands (
      WitDemand * theDemand1,
      WitDemand * theDemand2)
   {
   WitPeriod     thePer;
   double        theVal1;
   double        theVal2;
   WitMaterial * theMat1;
   WitMaterial * theMat2;
   int           theIdx1;
   int           theIdx2;

   thePer = priorityPeriod ();

   theVal1 = theDemand1->shipReward ()[thePer];
   theVal2 = theDemand2->shipReward ()[thePer];

   if (theVal1 > theVal2)
      return true;

   if (theVal1 < theVal2)
      return false;

   theVal1 = theDemand1->cumShipReward ()[thePer];
   theVal2 = theDemand2->cumShipReward ()[thePer];

   if (theVal1 > theVal2)
      return true;

   if (theVal1 < theVal2)
      return false;

   theMat1 = theDemand1->demandedPart ()->thisMat ();
   theMat2 = theDemand2->demandedPart ()->thisMat ();

   if (theMat1 != NULL)
      if (theMat2 != NULL)
         {
         theVal1 = theMat1->stockCost ()[thePer];
         theVal2 = theMat2->stockCost ()[thePer];

         if (theVal1 < theVal2)
            return true;

         if (theVal1 > theVal2)
            return false;
         }

   theIdx1 = theDemand1->mappingIndex ();
   theIdx2 = theDemand2->mappingIndex ();

   return (theIdx1 < theIdx2);
   }

//------------------------------------------------------------------------------
// Implementation of class OptStarter.
//------------------------------------------------------------------------------

WitOptStarter::WitOptStarter (
         WitOptComp * theOptComp,
         const char * theParamValue,
         WitAttr      theApiAttr,
         WitMsgID     theMsgID,
         bool         externalVal):

      myOptComp_  (theOptComp),
      paramValue_ (theParamValue),
      myApiAttr_  (theApiAttr),
      myMsgID_    (theMsgID),
      external_   (externalVal)
   {
   myOptComp ()->store (this);
   }

//------------------------------------------------------------------------------

WitOptStarter::~WitOptStarter ()
   {
   }

//------------------------------------------------------------------------------

void WitOptStarter::beChosen ()
   {
   myOptComp ()->choose (this);
   }

//------------------------------------------------------------------------------

bool WitOptStarter::isChosen ()
   {
   return (this == myOptComp ()->optInitMethod ());
   }

//------------------------------------------------------------------------------

const WitString & WitOptStarter::paramValue (
      const WitOptStarter * theOptStarter)
   {
   return theOptStarter->paramValue ();
   }

//------------------------------------------------------------------------------

void WitOptStarter::display ()
   {
   myOptComp ()->myMsgFac () (myMsgID_);
   }
@


1.51
log
@Stochastic Implosion
@
text
@a17 1
// ObjFunc2
a321 163
// Implementation of class ObjFunc2.
//------------------------------------------------------------------------------

WitObjFunc2::WitObjFunc2 (WitOptComp * theOptComp):
      WitObjFunc         (theOptComp, 2),

      totalServiceScale_ (0.0),
      revFactor_         (0.0),
      invFactor_         (0.0),
      servFactor_        (0.0),
      subFactor_         (0.0),

      revValue_          (0.0),
      invValue_          (0.0),
      servValue_         (0.0),
      subValue_          (0.0)
   {
   }

//------------------------------------------------------------------------------

WitObjFunc2::~WitObjFunc2 ()
   {
   }

//------------------------------------------------------------------------------

void WitObjFunc2::displayForObj2 (WitMsgID theMsgID, double theDouble)
   {
   myMsgFac () (theMsgID, theDouble);
   }

//------------------------------------------------------------------------------

void WitObjFunc2::finalPreprocess ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      obj2WrevVal;
   double      obj2WinvVal;
   double      obj2WservVal;
   double      obj2WsubVal;
   double      periodsPerYearVal;
   double      capCostVal;
   double      invCostVal;

   obj2WrevVal       = myOptComp ()->obj2Wrev       ();
   obj2WinvVal       = myOptComp ()->obj2Winv       ();
   obj2WservVal      = myOptComp ()->obj2Wserv      ();
   obj2WsubVal       = myOptComp ()->obj2Wsub       ();
   periodsPerYearVal = myOptComp ()->periodsPerYear ();
   capCostVal        = myOptComp ()->capCost        ();
   invCostVal        = myOptComp ()->invCost        ();

   totalServiceScale_ = 0.0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         totalServiceScale_ +=
            theDemand->netRev () * theDemand->cumDemandVol ()[thePer];

   revFactor_ = + obj2WrevVal;

   invFactor_ =
      -    obj2WinvVal
         * (static_cast <double> (nPeriods ()) / periodsPerYearVal)
         * (invCostVal / 100.0);

   servFactor_ =
      +    obj2WservVal
         * (capCostVal / 100.0 / periodsPerYearVal)
         * totalServiceScale ();

   subFactor_ = - obj2WsubVal;
   }

//------------------------------------------------------------------------------

void WitObjFunc2::initValues ()
   {
    revValue_ = 0.0;
    invValue_ = 0.0;
   servValue_ = 0.0;
    subValue_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitObjFunc2::compValues ()
   {
   myDetOptImpMgr ()->compObj2Values (
      revValue_,
      invValue_,
      servValue_,
      subValue_ );
   }

//------------------------------------------------------------------------------

void WitObjFunc2::writeValues ()
   {
   myMsgFac () ("obj2SectionValsMsg",
       revValue (),          revFactor (),  revValue ()  * revFactor (),
       invValue (),          invFactor (),  invValue ()  * invFactor (),
      servValue () * 100.0, servFactor (), servValue () * servFactor (),
       subValue (),          subFactor (),  subValue ()  * subFactor ());

   if (myDetOptImpMgr ()->boundsObjUsed ())
      myMsgFac () ("boundsObjValueMsg",
         myOptComp ()->boundsValue (),
         - myOptComp ()->wbounds (),
         myOptComp ()->boundsValue () * (- myOptComp ()->wbounds ()));

   myMsgFac () ("obj2ValueMsg", myOptComp ()->objValue ());
   }

//------------------------------------------------------------------------------

void WitObjFunc2::sortDemands (WitPtrVec <WitDemand> & theDemVec)
   {
   if (priorityPeriod () == 0)
      sort (
           theDemVec,
         & WitObjFunc2::compareDemands,
           this);
   }

//------------------------------------------------------------------------------

bool WitObjFunc2::compareDemands (
      WitDemand *   theDemand1,
      WitDemand *   theDemand2)
   {
   double theVal1;
   double theVal2;
   int    theIdx1;
   int    theIdx2;

   theVal1 = theDemand1->netRev ();
   theVal2 = theDemand2->netRev ();

   if (theVal1 > theVal2)
      return true;

   if (theVal1 < theVal2)
      return false;

   theVal1 = theDemand1->demandedPart ()->unitCost ();
   theVal2 = theDemand2->demandedPart ()->unitCost ();

   if (theVal1 < theVal2)
      return true;

   if (theVal1 > theVal2)
      return false;

   theIdx1 = theDemand1->mappingIndex ();
   theIdx2 = theDemand2->mappingIndex ();

   return (theIdx1 < theIdx2);
   }

//------------------------------------------------------------------------------
@


1.50
log
@Stochastic Implosion
@
text
@a138 15

void WitObjFunc::writeValues ()
   {
   writeValuesDerived ();

   if (myDetOptImpMgr ()->boundsObjUsed ())
      myMsgFac () ("boundsObjValueMsg",
         myOptComp ()->boundsValue (),
         - myOptComp ()->wbounds (),
         myOptComp ()->boundsValue () * (- myOptComp ()->wbounds ()));

   myMsgFac () ("mainObjValueMsg", index (), myOptComp ()->objValue ());
   }

//------------------------------------------------------------------------------
d174 1
a174 1
void WitObjFunc0::sortDemands (WitPtrVec <WitDemand> &)
d180 1
a180 1
void WitObjFunc0::writeValuesDerived ()
a188 1
      WitObjFunc    (theOptComp, 1),
d190 1
a190 1
      primaryValue_ (0.0)
a240 1
   primaryValue_ = 0.0;
a246 1
   myDetOptImpMgr ()->compObj1Values (primaryValue_);
d251 1
a251 1
void WitObjFunc1::loadInPrimaryValue (double primaryValueArg)
d253 1
a253 3
   witAssert (myStochImpMgr ()->uploadingSoln ());

   primaryValue_ = primaryValueArg;
a267 8
void WitObjFunc1::writeValuesDerived ()
   {
   if (myDetOptImpMgr ()->boundsObjUsed ())
      myMsgFac () ("obj1ValueMsg", primaryValue (), 1.0);
   }

//------------------------------------------------------------------------------

d422 19
a451 11
void WitObjFunc2::writeValuesDerived ()
   {
   myMsgFac () ("obj2ValueMsg",
       revValue (),          revFactor (),  revValue ()  * revFactor (),
       invValue (),          invFactor (),  invValue ()  * invFactor (),
      servValue () * 100.0, servFactor (), servValue () * servFactor (),
       subValue (),          subFactor (),  subValue ()  * subFactor ());
   }

//------------------------------------------------------------------------------

@


1.49
log
@Stochastic Implosion
@
text
@d24 1
d269 9
@


1.48
log
@Stochastic Implosion
@
text
@d23 1
a23 1
#include <OptImp.h>
d143 1
a143 1
   if (myOptImploder ()->boundsObjUsed ())
d263 1
a263 1
   myOptImploder ()->compObj1Values (primaryValue_);
d280 1
a280 1
   if (myOptImploder ()->boundsObjUsed ())
d431 1
a431 1
   myOptImploder ()->compObj2Values (
@


1.47
log
@Stochastic Implosion
@
text
@a38 1
      WitProbAssoc    (theOptComp->myProblem ()),
d40 1
@


1.46
log
@Updated the copyright date on all source files.
@
text
@a85 14
double WitObjFunc::objValue ()
   {
   return myOptImploder ()->objValue ();
   }

//------------------------------------------------------------------------------

double WitObjFunc::boundsValue ()
   {
   return myOptImploder ()->boundsValue ();
   }

//------------------------------------------------------------------------------

d145 1
a145 1
         boundsValue (),
d147 1
a147 1
         boundsValue () * (- myOptComp ()->wbounds ()));
d149 1
a149 1
   myMsgFac () ("mainObjValueMsg", index (), objValue ());
@


1.45
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.44
log
@[shared-resource pegging]
@
text
@d305 2
a306 1
   double        diff;
d309 2
d314 2
a315 10
   diff =
        theDemand1->shipReward ()[thePer] 
      - theDemand2->shipReward ()[thePer];

   if (diff != 0.0)
      return (diff > 0.0);

   diff =
        theDemand1->cumShipReward ()[thePer] 
      - theDemand2->cumShipReward ()[thePer];
d317 14
a330 2
   if (diff != 0.0)
      return (diff > 0.0);
d338 5
a342 3
         diff =
              theMat1->stockCost ()[thePer] 
            - theMat2->stockCost ()[thePer];
d344 2
a345 2
         if (diff != 0.0)
            return (diff < 0.0);
d348 4
a351 1
   return (theDemand1->mappingIndex () < theDemand2->mappingIndex ());
d480 13
a492 1
   double diff;
d494 2
a495 3
   diff =
        theDemand1->netRev () 
      - theDemand2->netRev ();
d497 2
a498 2
   if (diff != 0.0)
      return (diff > 0.0);
d500 2
a501 3
   diff =
        theDemand1->demandedPart ()->unitCost ()
      - theDemand2->demandedPart ()->unitCost ();
d503 2
a504 2
   if (diff != 0.0)
      return (diff < 0.0);
d506 1
a506 1
   return (theDemand1->mappingIndex () < theDemand2->mappingIndex ());
@


1.43
log
@[multi-thread]
@
text
@d31 1
a31 1
#include <Dense.h>
d123 7
a129 3
   WitDenseList <WitDemand> demandList (myCompMgr ()->nDemands ());
   WitDemand *  theDemand;
   int          pri;
d131 1
d134 5
a138 1
      demandList.append (theDemand);
d142 1
a142 1
      sortDemands (demandList);
d144 1
a144 1
      pri = 0;
d146 2
a147 2
      forEachElDense (theDemand, demandList)
         newPriority (theDemand)[priorityPeriod_] = ++ pri;
d202 1
a202 1
void WitObjFunc0::sortDemands (WitDenseList <WitDemand> &)
d282 1
a282 1
void WitObjFunc1::sortDemands (WitDenseList <WitDemand> & demandList)
d284 4
a287 1
   demandList.sort (compare, this);
d300 1
a300 1
int WitObjFunc1::compare (
d302 1
a302 2
      WitDemand * theDemand2,
      void *      theContext)
a303 1
   WitObjFunc1 * theObj1Func;
d305 1
a305 1
   int           cmp;
d309 1
a309 1
   theObj1Func = static_cast <WitObjFunc1 *> (theContext);
d311 3
a313 1
   thePer      = theObj1Func->priorityPeriod ();
d315 2
a316 4
   cmp         =
      sign (
           theDemand2->shipReward ()[thePer] 
         - theDemand1->shipReward ()[thePer]);
d318 3
a320 2
   if (cmp != 0)
      return cmp;
d322 2
a323 7
   cmp =
      sign (
           theDemand2->cumShipReward ()[thePer] 
         - theDemand1->cumShipReward ()[thePer]);

   if (cmp != 0)
      return cmp;
d331 3
a333 4
         cmp = 
            sign (
                 theMat1->stockCost ()[thePer] 
               - theMat2->stockCost ()[thePer]);
d335 2
a336 2
         if (cmp != 0)
            return cmp;
d339 1
a339 4
   return
      sign (
           theDemand1->mappingIndex ()
         - theDemand2->mappingIndex ());
d442 1
a442 1
void WitObjFunc2::sortDemands (WitDenseList <WitDemand> & demandList)
d445 4
a448 1
      demandList.sort (compare, NULL);
d464 1
a464 1
int WitObjFunc2::compare (
d466 1
a466 2
      WitDemand *   theDemand2,
      void *)
d468 15
a482 1
   int cmp;
d484 1
a484 20
   cmp =
      sign (
           theDemand2->netRev () 
         - theDemand1->netRev ());

   if (cmp != 0)
      return cmp;

   cmp =
      sign (
           theDemand2->demandedPart ()->unitCost ()
         - theDemand1->demandedPart ()->unitCost ());

   if (cmp != 0)
      return cmp;

   return
      sign (
           theDemand1->mappingIndex ()
         - theDemand2->mappingIndex ());
@


1.42
log
@[multi-thread]
@
text
@a31 1
#include <DLSort.h>
d275 1
a275 1
   WitDLSorter <WitDemand, WitObjFunc1>::sort (demandList, compare, this);
d289 3
a291 3
      WitDemand *   theDemand1,
      WitDemand *   theDemand2,
      WitObjFunc1 * theObj1Func)
d293 1
d299 3
a301 1
   thePer = theObj1Func->priorityPeriod ();
d303 1
a303 1
   cmp    =
d443 1
a443 1
      WitDLSorter <WitDemand, void>::sort (demandList, compare, NULL);
@


1.41
log
@[multi-thread]
@
text
@d441 1
a441 1
      WitDLSorter <WitDemand, WitObjFunc2>::sort (demandList, compare, NULL);
d460 1
a460 1
      WitObjFunc2 *)
@


1.40
log
@[multi-thread]
@
text
@d276 1
a276 4
   WitDLSorter <WitDemand, WitObjFunc1>::sort (
        demandList,
      & WitObjFunc1::compare,
        this);
d289 4
a292 1
int WitObjFunc1::compare (WitDemand * dem1, WitDemand * dem2)
d299 1
a299 1
   thePer = priorityPeriod ();
d303 2
a304 2
           dem2->shipReward ()[thePer] 
         - dem1->shipReward ()[thePer]);
d311 2
a312 2
           dem2->cumShipReward ()[thePer] 
         - dem1->cumShipReward ()[thePer]);
d317 2
a318 2
   theMat1 = dem1->demandedPart ()->thisMat ();
   theMat2 = dem2->demandedPart ()->thisMat ();
d334 2
a335 2
           dem1->mappingIndex ()
         - dem2->mappingIndex ());
d441 1
a441 4
      WitDLSorter <WitDemand, WitObjFunc2>::sort (
           demandList,
         & WitObjFunc2::compare,
           this);
d457 4
a460 1
int WitObjFunc2::compare (WitDemand * dem1, WitDemand * dem2)
d466 2
a467 2
           dem2->netRev () 
         - dem1->netRev ());
d474 2
a475 2
           dem2->demandedPart ()->unitCost ()
         - dem1->demandedPart ()->unitCost ());
d482 2
a483 2
           dem1->mappingIndex ()
         - dem2->mappingIndex ());
@


1.39
log
@[multi-thread]
@
text
@d279 1
a279 1
         this);
@


1.38
log
@[multi-thread]
@
text
@d32 1
d276 4
a279 1
   WitNonClass::sort (demandList, & WitObjFunc1::compare, this);
d441 4
a444 1
      WitNonClass::sort (demandList, & WitObjFunc2::compare, this);
@


1.37
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@a37 8
//------------------------------------------------------------------------------
// Static member data.
//------------------------------------------------------------------------------

WitPeriod WitObjFunc::priorityPeriod_ = -1;

//------------------------------------------------------------------------------

d39 1
a39 1
      WitProbAssoc (theOptComp->myProblem ()),
d41 2
a42 1
      index_       (indexVal)
d55 1
a55 1
void WitObjFunc::validateForOptImp () const
d61 1
a61 1
bool WitObjFunc::negativeObj1CostsExist () const
d68 1
a68 1
void WitObjFunc::displayForObj1 (WitMsgID, const WitDblFlexVec &) const
d74 1
a74 1
void WitObjFunc::displayForObj2 (WitMsgID, double) const
d86 1
a86 1
double WitObjFunc::objValue () const
d93 1
a93 1
double WitObjFunc::boundsValue () const
d107 1
a107 1
bool WitObjFunc::isChosen () const
d121 1
a121 3
void WitObjFunc::genPriorities (
      WitSchedule <WitDemand, int> & newPriority)
      const
d133 1
a133 1
      sort (demandList);
d144 1
a144 1
void WitObjFunc::writeValues () const
d174 1
a174 1
void WitObjFunc0::validateForOptImp () const
d193 1
a193 1
void WitObjFunc0::sort (WitDenseList <WitDemand> &) const
d199 1
a199 1
void WitObjFunc0::writeValuesDerived () const
d222 1
a222 1
bool WitObjFunc1::negativeObj1CostsExist () const
a252 1
      const
d273 1
a273 1
void WitObjFunc1::sort (WitDenseList <WitDemand> & demandList) const
d275 1
a275 1
   demandList.sort (compare);
d280 1
a280 1
void WitObjFunc1::writeValuesDerived () const
d362 1
a362 1
void WitObjFunc2::displayForObj2 (WitMsgID theMsgID, double theDouble) const
d434 1
a434 1
void WitObjFunc2::sort (WitDenseList <WitDemand> & demandList) const
d437 1
a437 1
      demandList.sort (compare);
d442 1
a442 1
void WitObjFunc2::writeValuesDerived () const
d514 1
a514 1
bool WitOptStarter::isChosen () const
d529 1
a529 1
void WitOptStarter::display () const
@


1.36
log
@Modified the behavior of setting optInitMethod:
   Setting it to "accelerated" is now a severe error.
   Setting it takes WIT out of an accelerated state.
@
text
@d239 1
a239 1
      if (not (thePart->obj1ScrapCost () >= 0.0))
d243 1
a243 1
      if (not (theMat->obj1StockCost () >= 0.0))
d247 1
a247 1
      if (not (theOpn->obj1ExecCost () >= 0.0))
d251 1
a251 1
      if (not (theSub->obj1SubCost () >= 0.0))
d309 2
a310 2
           dem2->obj1ShipReward ()[thePer] 
         - dem1->obj1ShipReward ()[thePer]);
d317 2
a318 2
           dem2->obj1CumShipReward ()[thePer] 
         - dem1->obj1CumShipReward ()[thePer]);
d331 2
a332 2
                 theMat1->obj1StockCost ()[thePer] 
               - theMat2->obj1StockCost ()[thePer]);
@


1.35
log
@Revised mappingIndex code.
@
text
@a542 11

//------------------------------------------------------------------------------

bool WitOptStarter::accConflict () const
   {
   if (this == myOptComp_->accOptStarter ())
      if (not myOptComp_->myProblem ()->myOptImploder ()->accelerated ())
         return true;

   return false;
   }
@


1.34
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@a32 1
#include <MapIdxI.h>
@


1.33
log
@Double Precision.
@
text
@a62 7
void WitObjFunc::reqObj1 () const
   {
   myMsgFac () ("reqObj1ImmSmsg", index ());
   }

//------------------------------------------------------------------------------

a231 6
void WitObjFunc1::reqObj1 () const
   {
   }

//------------------------------------------------------------------------------

@


1.32
log
@Double Precision.
@
text
@a88 6
void WitObjFunc::displayForObj2 (WitMsgID, float) const
   {
   }

//------------------------------------------------------------------------------

d314 1
a314 1
   WitPeriod     t;
d319 1
a319 1
   t   = priorityPeriod ();
d321 4
a324 1
   cmp = sign (dem2->obj1ShipReward ()[t] - dem1->obj1ShipReward ()[t]);
d329 4
a332 1
   cmp = sign (dem2->obj1CumShipReward ()[t] - dem1->obj1CumShipReward ()[t]);
d344 3
a346 1
            sign (theMat1->obj1StockCost ()[t] - theMat2->obj1StockCost ()[t]);
d352 4
a355 1
   return sign (dem1->mappingIndex () - dem2->mappingIndex ());
a385 7
void WitObjFunc2::displayForObj2 (WitMsgID theMsgID, float theFloat) const
   {
   myMsgFac () (theMsgID, theFloat);
   }

//------------------------------------------------------------------------------

d424 1
a424 1
         * (static_cast <float> (nPeriods ()) / periodsPerYearVal)
d481 4
a484 1
   cmp = sign (dem2->netRev () - dem1->netRev ());
d491 2
a492 2
         dem2->demandedPart ()->unitCost () -
         dem1->demandedPart ()->unitCost ());
d497 4
a500 1
   return sign (dem1->mappingIndex () - dem2->mappingIndex ());
@


1.31
log
@Double Precision.
@
text
@d83 1
a83 1
void WitObjFunc::displayForObj1 (WitMsgID, const WitFlexVec <double> &) const
d280 2
a281 2
      WitMsgID                    theMsgID,
      const WitFlexVec <double> & theFlexVec)
@


1.30
log
@Double Precision.
@
text
@a82 6
void WitObjFunc::displayForObj1 (WitMsgID, const WitFlexVec <float> &) const
   {
   }

//------------------------------------------------------------------------------

a274 10
   }

//------------------------------------------------------------------------------

void WitObjFunc1::displayForObj1 (
      WitMsgID                   theMsgID,
      const WitFlexVec <float> & theFlexVec)
      const
   {
   myProblem ()->display (theMsgID, theFlexVec);
@


1.29
log
@Double Precision.
@
text
@d89 1
a89 1
void WitObjFunc::displayForObj1 (WitMsgID, const WitRealVec &) const
d296 2
a297 2
      WitMsgID           theMsgID,
      const WitRealVec & theRealVec)
d300 1
a300 1
   myProblem ()->display (theMsgID, theRealVec);
@


1.28
log
@Continued double precision.
@
text
@d89 6
d291 10
@


1.27
log
@Continued double precision.
@
text
@d109 1
a109 1
   return static_cast <double> (myOptImploder ()->objValue ());
d116 1
a116 1
   return static_cast <double> (myOptImploder ()->boundsValue ());
@


1.26
log
@Continued double precision.
@
text
@d95 1
a95 1
void WitObjFunc::displayForObj2 (WitMsgID, StrDbl) const
d107 1
a107 1
StrDbl WitObjFunc::objValue () const
d109 1
a109 1
   return StrDbl::convFloat (myOptImploder ()->objValue ());
d114 1
a114 1
StrDbl WitObjFunc::boundsValue () const
d116 1
a116 1
   return StrDbl::convFloat (myOptImploder ()->boundsValue ());
d388 1
a388 1
void WitObjFunc2::displayForObj2 (WitMsgID theMsgID, StrDbl theStrDbl) const
d390 1
a390 1
   myMsgFac () (theMsgID, theStrDbl);
d452 4
a455 4
      revValue_ .myDouble (),
      invValue_ .myDouble (),
      servValue_.myDouble (),
      subValue_ .myDouble ());
@


1.25
log
@Continued double precision.
@
text
@d398 16
a413 9
   WitPeriod   t;

   const float obj2WrevVal       = myOptComp ()->obj2Wrev       ();
   const float obj2WinvVal       = myOptComp ()->obj2Winv       ();
   const float obj2WservVal      = myOptComp ()->obj2Wserv      ();
   const float obj2WsubVal       = myOptComp ()->obj2Wsub       ();
   const float periodsPerYearVal = myOptComp ()->periodsPerYear ();
   const float capCostVal        = myOptComp ()->capCost        ();
   const float invCostVal        = myOptComp ()->invCost        ();
d418 1
a418 1
      forEachPeriod (t, myProblem ())
d420 1
a420 1
            theDemand->netRev () * theDemand->cumDemandVol ()[t];
a450 5
   float revValFlt;
   float invValFlt;
   float servValFlt;
   float subValFlt;

d452 4
a455 9
      revValFlt,
      invValFlt,
      servValFlt,
      subValFlt);

   revValue_  = StrDbl::convFloat (revValFlt);
   invValue_  = StrDbl::convFloat (invValFlt);
   servValue_ = StrDbl::convFloat (servValFlt);
   subValue_  = StrDbl::convFloat (subValFlt);
@


1.24
log
@Continued double precision.
@
text
@d107 1
a107 1
float WitObjFunc::objValue () const
d109 1
a109 1
   return myOptImploder ()->objValue ();
d114 1
a114 1
float WitObjFunc::boundsValue () const
d116 1
a116 1
   return myOptImploder ()->boundsValue ();
d444 5
d450 9
a458 4
      revValue_,
      invValue_,
      servValue_,
      subValue_);
@


1.23
log
@Removed a bad function overload.
@
text
@d95 6
d384 7
@


1.22
log
@Continued implementation of post-implosion pegging.
@
text
@d331 2
a332 2
   theMat1 = dem1->demandedPart ()->myMat ();
   theMat2 = dem2->demandedPart ()->myMat ();
@


1.21
log
@Continued implementation of post-implosion pegging.
@
text
@a29 1
#include <ScheduleI.h>
d33 1
@


1.20
log
@Continued implementation of proportionate routing.
@
text
@a33 1
#include <FlexVecI.h>
@


1.19
log
@Continued implementation of proportionate routing.
@
text
@d332 2
a333 2
   dem1->demandedPart ()->getMaterial (theMat1);
   dem2->demandedPart ()->getMaterial (theMat2);
@


1.18
log
@Changed some C style casts to C++ style.
@
text
@d49 1
a49 1
      WitProbAssoc (theOptComp),
@


1.17
log
@Internal changes.
@
text
@d407 1
a407 1
         * ((float) nPeriods () / periodsPerYearVal)
@


1.16
log
@Internal changes.
@
text
@d254 1
a254 1
      if (! (thePart->obj1ScrapCost () >= 0.0))
d258 1
a258 1
      if (! (theMat->obj1StockCost () >= 0.0))
d262 1
a262 1
      if (! (theOpn->obj1ExecCost () >= 0.0))
d266 1
a266 1
      if (! (theSub->obj1SubCost () >= 0.0))
d540 1
a540 1
      if (! myOptComp_->myProblem ()->myOptImploder ()->accelerated ())
@


1.15
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d77 1
a77 1
WitBoolean WitObjFunc::negativeObj1CostsExist () const
d79 1
a79 1
   return witFALSE;
d123 1
a123 1
WitBoolean WitObjFunc::isChosen () const
d246 1
a246 1
WitBoolean WitObjFunc1::negativeObj1CostsExist () const
d255 1
a255 1
         return witTRUE;
d259 1
a259 1
         return witTRUE;
d263 1
a263 1
         return witTRUE;
d267 1
a267 1
         return witTRUE;
d269 1
a269 1
   return witFALSE;
d489 1
a489 1
         WitBoolean   externalVal):
d515 1
a515 1
WitBoolean WitOptStarter::isChosen () const
d537 1
a537 1
WitBoolean WitOptStarter::accConflict () const
d541 1
a541 1
         return witTRUE;
d543 1
a543 1
   return witFALSE;
@


1.14
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d16 4
a19 3
//    ObjFunc0
//    ObjFunc1
//    ObjFunc2
d22 1
d34 1
d478 66
@


1.13
log
@Continued implementation of Single-Source.
@
text
@d22 6
d95 14
@


1.12
log
@Preliminary work on single source.
@
text
@d22 1
a22 1
#include <Schedule.h>
@


1.11
log
@Continued preliminary work on single source.
@
text
@d75 1
a75 1
void WitObjFunc::displayForObj1 (WitMsgID, const WitFlexVec (float) &) const
d253 1
a253 1
      const WitFlexVec (float) & theFlexVec)
@


1.10
log
@More preliminary work on single source.
@
text
@d115 1
a115 1
      WitSchedule (WitDemand, int) & newPriority)
@


1.9
log
@Continued implementation of object iteration.
@
text
@d118 1
a118 1
   WitDenseList (WitDemand) demandList (myCompMgr ()->nDemands ());
d188 1
a188 1
void WitObjFunc0::sort (WitDenseList (WitDemand) &) const
d275 1
a275 1
void WitObjFunc1::sort (WitDenseList (WitDemand) & demandList) const
d418 1
a418 1
void WitObjFunc2::sort (WitDenseList (WitDemand) & demandList) const
@


1.8
log
@Began implementation of object iteration.
@
text
@d309 2
a310 2
   theMat1 = dem1->demandedPart ()->myMat ();
   theMat2 = dem2->demandedPart ()->myMat ();
@


1.7
log
@Continued development of Selective Stock Reallocation.
@
text
@d25 1
@


1.6
log
@Continued implementation of selective stock reallocation.
@
text
@d308 5
a312 2
   if (dem1->demandedPart ()->getMyMaterial (theMat1))
      if (dem2->demandedPart ()->getMyMaterial (theMat2))
@


1.5
log
@Implemented and used class SelMgr.
@
text
@d308 2
a309 2
   if (dem1->demandedPart ()->isaMaterial (theMat1))
      if (dem2->demandedPart ()->isaMaterial (theMat2))
@


1.4
log
@Some minor changes.
@
text
@a151 6

implementClearContents (WitObjFunc)
   //
   // See RWClient.h.

//------------------------------------------------------------------------------
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d24 1
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d303 1
a303 4
   cmp =
      WitUtil::sign (
         dem2->obj1ShipReward ()[t] -
         dem1->obj1ShipReward ()[t]);
d308 1
a308 4
   cmp =
      WitUtil::sign (
         dem2->obj1CumShipReward ()[t] -
         dem1->obj1CumShipReward ()[t]);
d316 2
a317 4
         cmp =
            WitUtil::sign (
               theMat1->obj1StockCost ()[t] -
               theMat2->obj1StockCost ()[t]);
d323 1
a323 4
   return 
      WitUtil::sign (
           dem1->mappingIndex ()
         - dem2->mappingIndex ());
d442 1
a442 1
   cmp = WitUtil::sign (dem2->netRev () - dem1->netRev ());
d448 1
a448 1
      WitUtil::sign (
d455 1
a455 4
   return 
      WitUtil::sign (
           dem1->mappingIndex ()
         - dem2->mappingIndex ());
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

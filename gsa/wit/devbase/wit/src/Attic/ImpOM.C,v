head	1.29;
access;
symbols
	latest_sce_4_20_20060523:1.27.0.2
	sce_4_20_20060523:1.27
	latest_sce4_20_OSL:1.25.0.2
	sce_4_20_OSL:1.25
	sce_410_withVa:1.22
	sce_4_05_20040511:1.20
	sce_4_00_20040201:1.16
	nextGenBranch:1.12.0.2
	nextGenRoot:1.12
	sce_3_30_20030627:1.12
	EndRw-branch:1.6.0.4
	Root-of-EndRw:1.6
	rwToStl:1.6.0.2;
locks; strict;
comment	@ * @;


1.29
date	2006.08.18.18.43.37;	author rjw;	state dead;
branches;
next	1.28;

1.28
date	2006.08.17.19.36.38;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.02.17.34.00;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.21.21.40.04;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.18.20.56.21;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.04.19.53.50;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.13.19.31.56;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.28.20.14.35;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.07.15.18.25;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.24.22.21.31;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.23.19.14.23;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.10.22.53.19;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.03.20.05.07;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.11.18.29.13;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.26.16.06.01;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.25.20.44.43;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.18.18.30.16;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.23.18.12.34;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.19.16.48.17;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.15.21.01.20;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.13.22.22.09;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.02.23.40.41;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.02.22.18.30;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.11.18.53.09;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.06.19.56.06;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.04.21.53.35;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.04.19.14.54;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.29.23.06.25;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.26.22.49.01;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.29
log
@App controlled opt implosion.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "ImpOM.C"
//
// Implementation of class ImpOM.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Please note: the following #includes are placed outside the
// #ifdef OPT_IMPLODE part of the file, because otherwise, make depend sometimes
// ignores them in OPT_IMPLODE mode.
//------------------------------------------------------------------------------

#include <ImpOM.h>
#include <OptImp.h>
#include <PerVar.h>
#include <PerCon.h>
#include <OptObjs.h>
#include <OptComp.h>
#include <Global.h>
#include <Material.h>
#include <Opn.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Demand.h>
#include <BoundSet.h>
#include <Timing.h>
#include <Session.h>
#include <MsgFac.h>

#include <float.h>

#ifdef OPT_IMPLODE

//------------------------------------------------------------------------------
// Definitions of static data members.
//------------------------------------------------------------------------------

const double WitImpOM::solnEpsilon = 0.0005;

WitImpOM::WitImpOM (WitOptImploder * theOptImploder):

      WitOptModel   (theOptImploder),

      myBoundsObj_  (NULL),
      myPrimaryObj_ (NULL),
      myObj1Obj_    (NULL),
      myRevObj_     (NULL),
      myInvObj_     (NULL),
      myServObj_    (NULL),
      mySubObj_     (NULL),
      myObj2Obj_    (NULL),

      nSlbvVars_    (0),
      solnFile_     (NULL)
   {
   }

//------------------------------------------------------------------------------

WitImpOM::~WitImpOM ()
   {
   }

//------------------------------------------------------------------------------

bool WitImpOM::needDual ()
   {
   if (myCompMgr ()->myOptComp ()->compPrices ())
      return true;

   if (myCompMgr ()->myGlobalComp ()->computeCriticalList ())
      return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitImpOM::reportInfeasible ()
   {
   if (positiveHardLBsExist ())
      myMsgFac () ("infeasBoundsSmsg");
   }

//------------------------------------------------------------------------------

void WitImpOM::reportUnbounded ()
   {
   if (myCompMgr ()->myOptComp ()->objChoice ()->negativeObj1CostsExist ())
      myMsgFac () ("unboundedSmsg");
   }

//------------------------------------------------------------------------------
// storeDerived functions.
//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitScrapVar * theScrapVar)
   {
   insertInto (myScrapVar_, theScrapVar->myPart (), theScrapVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitNonSubVar * theNonSubVar)
   {
   insertInto (myNonSubVar_, theNonSubVar->myBomEnt (), theNonSubVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitSubVar * theSubVar)
   {
   insertInto (mySubVar_, theSubVar->mySub (), theSubVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitShipVar * theShipVar)
   {
   insertInto (myShipVar_, theShipVar->myDemand (), theShipVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitSlbvVar * theSlbvVar)
   {
   insertInto (mySlbvVar_, theSlbvVar->myBoundSet (), theSlbvVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitExecVar * theExecVar)
   {
   insertInto (myExecVar_, theExecVar->myOperation (), theExecVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitStockVar * theStockVar)
   {
   insertInto (myStockVar_, theStockVar->myMaterial (), theStockVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitCumShipVar * theCumShipVar)
   {
   insertInto (myCumShipVar_, theCumShipVar->myDemand (), theCumShipVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitResourceCon * theResourceCon)
   {
   insertInto (myResourceCon_, theResourceCon->myPart (), theResourceCon);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitSubCon * theSubCon)
   {
   insertInto (mySubCon_, theSubCon->myBomEnt (), theSubCon);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitShipCon * theShipCon)
   {
   insertInto (myShipCon_, theShipCon->myDemand (), theShipCon);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitSlbCon * theSlbCon)
   {
   insertInto (mySlbCon_, theSlbCon->myBoundSet (), theSlbCon);
   }

//------------------------------------------------------------------------------
// ModelEl look-up functions.
//------------------------------------------------------------------------------

WitScrapVar * WitImpOM::myScrapVar (WitPart * thePart, WitPeriod thePer)
   {
   return lookUp (myScrapVar_, thePart, thePer);
   }

//------------------------------------------------------------------------------

WitNonSubVar * WitImpOM::myNonSubVar (WitBomEntry * theBomEnt, WitPeriod thePer)
   {
   return lookUp (myNonSubVar_, theBomEnt, thePer);
   }

//------------------------------------------------------------------------------

WitSubVar * WitImpOM::mySubVar (WitSubEntry * theSub, WitPeriod thePer)
   {
   return lookUp (mySubVar_, theSub, thePer);
   }

//------------------------------------------------------------------------------

WitShipVar * WitImpOM::myShipVar (WitDemand * theDemand, WitPeriod thePer)
   {
   return lookUp (myShipVar_, theDemand, thePer);
   }

//------------------------------------------------------------------------------

WitExecVar * WitImpOM::myExecVar (WitOperation * theOpn, WitPeriod thePer)
   {
   return lookUp (myExecVar_, theOpn, thePer);
   }

//------------------------------------------------------------------------------

WitStockVar * WitImpOM::myStockVar (WitMaterial * theMat, WitPeriod thePer)
   {
   return lookUp (myStockVar_, theMat, thePer);
   }

//------------------------------------------------------------------------------

WitCumShipVar * WitImpOM::myCumShipVar (WitDemand * theDemand, WitPeriod thePer)
   {
   return lookUp (myCumShipVar_, theDemand, thePer);
   }

//------------------------------------------------------------------------------

WitResourceCon * WitImpOM::myResourceCon (WitPart * thePart, WitPeriod thePer)
   {
   return lookUp (myResourceCon_, thePart, thePer);
   }

//------------------------------------------------------------------------------

WitSubCon * WitImpOM::mySubCon (WitBomEntry * theBomEnt, WitPeriod thePer)
   {
   return lookUp (mySubCon_, theBomEnt, thePer);
   }

//------------------------------------------------------------------------------

WitShipCon * WitImpOM::myShipCon (WitDemand * theDemand, WitPeriod thePer)
   {
   return lookUp (myShipCon_, theDemand, thePer);
   }

//------------------------------------------------------------------------------

WitSlbvVar * WitImpOM::mySlbvVar (const WitBoundedVar * theBoundedVar)
   {
   return
      lookUp (
         mySlbvVar_,
         theBoundedVar->myBoundSet (),
         theBoundedVar->myPeriod ());
   }

//------------------------------------------------------------------------------

WitSlbCon * WitImpOM::mySlbCon (const WitBoundedVar * theBoundedVar)
   {
   return
      lookUp (
         mySlbCon_,
         theBoundedVar->myBoundSet (),
         theBoundedVar->myPeriod ());
   }

//------------------------------------------------------------------------------

void WitImpOM::printItem (WitNode * theNode)
   {
   fprintf (
      modelFile (),
      itemFormat (),
      theNode->nodeName ().myCstring (),
      "",
      "");
   }

//------------------------------------------------------------------------------

void WitImpOM::printItem (WitBomEntry * theBomEnt)
   {
   fprintf (modelFile (), itemFormat (),
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->myPartName ().myCstring (),
      "");
   }

//------------------------------------------------------------------------------

void WitImpOM::printItem (WitSubEntry * theSub)
   {
   fprintf (modelFile (), itemFormat (),
      theSub->myOperationName ().myCstring (),
      theSub->myBomEnt ()->myPartName ().myCstring (),
      theSub->myPartName ().myCstring ());
   }

//------------------------------------------------------------------------------

void WitImpOM::printItem (WitDemand * theDemand)
   {
   fprintf (modelFile (), itemFormat (),
      theDemand->demandedPartName ().myCstring (),
      theDemand->demandName ().myCstring (),
      "");
   }

//------------------------------------------------------------------------------

void WitImpOM::printItem (const WitBoundedVar * theBoundedVar)
   {
   fprintf (modelFile (),
      " Var #%-7d BS #%-8d %-12s",
      theBoundedVar->index (),
      theBoundedVar->myBoundSet ()->mappingIndex (),
      "");
   }

//------------------------------------------------------------------------------

void WitImpOM::storeBoundedVar (WitBoundedVar * theBoundedVar)
   {
   myBoundedVars_.append (theBoundedVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::screenModel ()
   {
   if (myOptImploder ()->printOptModel ())
      saveBounds ();

   screenImpCons ();

   relaxCumShipNonNeg ();

   screenSlbModelEls ();
   }

//------------------------------------------------------------------------------

bool WitImpOM::slbvVarsExist ()
   {
   return (nSlbvVars_ > 0);
   }

//------------------------------------------------------------------------------

void WitImpOM::printPeriod (WitPeriod t)
   {
   fprintf (modelFile (), periodDFormat (), t);
   }

//------------------------------------------------------------------------------
// writeSoln prints out the primal solution from wit data structures.
// Optionally prints the dual solution for resource allocation constraints.
//------------------------------------------------------------------------------

void WitImpOM::writeSoln (const WitString & fName)
   {
   WitTimer::enterSection ("extra");

   myMsgFac () ("writeOptSolnMsg");

   solnFile_ = openFile (fName.myCstring (), "w");

   myProblem ()->mySession ()->writeHeading (solnFile ());

   writePartSoln       ();
   writeOperationSoln  ();
   writeSubEntrySoln   ();
   writeDemandSoln     ();
   writeBoundedVarSoln ();

   fclose (solnFile ());

   solnFile_ = NULL;

   WitTimer::leaveSection ("extra");
   }

//------------------------------------------------------------------------------

void WitImpOM::generateVariables ()
   {
   WitPart *       thePart;
   WitMaterial *   theMat;
   WitOperation *  theOpn;
   WitBomEntry *   theBomEnt;
   WitSubEntry *   theSub;
   WitDemand *     theDemand;
   WitBoundedVar * theBoundedVar;
   WitPeriod       thePer;

   forEachMaterial (theMat, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theMat->canStock (thePer))
            new WitStockVar (theMat, thePer, this);

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         new WitScrapVar (thePart, thePer, this);

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theOpn->executable ()[thePer])
            new WitExecVar (theOpn, thePer, this);

   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theBomEnt->hasSubsInEffect ()[thePer])
            new WitNonSubVar (theBomEnt, thePer, this);

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theSub->inEffect (thePer))
            new WitSubVar (theSub, thePer, this);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         new WitShipVar (theDemand, thePer, this);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         new WitCumShipVar (theDemand, thePer, this);

   forEachEl (theBoundedVar, myBoundedVars_)
      if (theBoundedVar->needsAnSlbvVar ())
         {
         new WitSlbvVar (theBoundedVar, this);

         ++ nSlbvVars_;
         }
   }

//------------------------------------------------------------------------------

void WitImpOM::generateConstraints ()
   {
   WitPart *       thePart;
   WitBomEntry *   theBomEnt;
   WitDemand *     theDemand;
   WitPeriod       thePer;
   WitBoundedVar * theBoundedVar;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         new WitResourceCon (thePart, thePer, this);

   if (myCompMgr ()->hasSubEntries ())
      forEachBomEntry (theBomEnt, myProblem ())
         forEachPeriod (thePer, myProblem ())
            if (theBomEnt->hasSubsInEffect ()[thePer])
               new WitSubCon (theBomEnt, thePer, this);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         new WitShipCon (theDemand, thePer, this);

   forEachEl (theBoundedVar, myBoundedVars_)
      if (mySlbvVar (theBoundedVar) != NULL)
         new WitSlbCon (theBoundedVar, this);
   }

//------------------------------------------------------------------------------

WitOptObj * WitImpOM::generateObjectives ()
   {
   if (slbvVarsExist ())
      myBoundsObj_ = new WitBoundsObj (this);

   if (myCompMgr ()->myOptComp ()->myObjFunc1 ()->isChosen ())
      {
      myPrimaryObj_ = new WitPrimaryObj (this);
         myObj1Obj_ = new    WitObj1Obj (this);

      return myObj1Obj ();
      }

   if (myCompMgr ()->myOptComp ()->myObjFunc2 ()->isChosen ())
      {
       myRevObj_ = new  WitRevObj (this);
       myInvObj_ = new  WitInvObj (this);
      myServObj_ = new WitServObj (this);
       mySubObj_ = new  WitSubObj (this);
      myObj2Obj_ = new WitObj2Obj (this);

      return myObj2Obj ();
      }

   return NULL;
   }

//------------------------------------------------------------------------------

void WitImpOM::printModelElHeading ()
   {
   fprintf (modelFile (), "Index    Class       ");

   fprintf (modelFile (), itemFormat (),   "Item", "Item", "Item");
   fprintf (modelFile (), periodSFormat (), "Per");
   }

//------------------------------------------------------------------------------

void WitImpOM::displayDerived ()
   {
   int nBSSpec;

   nBSSpec = myCompMgr ()->nBoundSetsSpecified ();

   if (nBSSpec > 0)
      myMsgFac () ("boundCountsMsg",
         nBSSpec,
         myBoundedVars_.nElements (),
         nSlbvVars_);
   }

//------------------------------------------------------------------------------

void WitImpOM::printDerived ()
   {
   printBoundedVars ();
   }

//------------------------------------------------------------------------------

void WitImpOM::initDepVars ()
   {
   WitSlbvVar *    theSlbvVar;
   WitBoundedVar * theBoundedVar;
   double          newPrimalVal;

   forEachEl (theBoundedVar, myBoundedVars_)
      {
      theSlbvVar = mySlbvVar (theBoundedVar);

      if (theSlbvVar != NULL)
         {
         newPrimalVal = 
            positivePart (
               theBoundedVar->softLB () - theBoundedVar->primalValue ());

         theSlbvVar->setPrimalValue (newPrimalVal);
         }
      }
   }

//------------------------------------------------------------------------------

void WitImpOM::writeMeSoln (const WitModelEl * theModelEl)
   {
   const double valJ =
      (theModelEl == NULL)?
         0.0:
         theModelEl->solnValue ();

   if (fabs (valJ) > solnEpsilon)
      fprintf (solnFile (), "%13.3f  ", valJ);
   else
      fprintf (solnFile (), "               ");
   }

//------------------------------------------------------------------------------

void WitImpOM::writePartSoln ()
   {
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     t;

   forEachPart (thePart, myProblem ())
      {
      fprintf (
         solnFile (),
         "\nPart %s:\n",
         thePart->partName ().myCstring ());

      fprintf (solnFile (),
          "Period      Inventory          Scrap");

      if (needDual ())
         fprintf (solnFile (), "   Shadow Price");

      fprintf (solnFile (), "\n");

      forEachPeriod (t, myProblem ())
         {
         fprintf (solnFile (), "%6d  ", t);

         theMat = thePart->thisMat ();

         writeMeSoln (
            (theMat != NULL)?
               myStockVar (theMat, t):
               NULL);

         writeMeSoln (myScrapVar (thePart, t));

         if (needDual ())
            writeMeSoln (myResourceCon (thePart, t));

         fprintf (solnFile (), "\n");
         }
      }
   }

//------------------------------------------------------------------------------

void WitImpOM::writeOperationSoln ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   forEachOperation (theOpn, myProblem ())
      {
      fprintf (solnFile (),
         "\nOperation %s:\n",
         theOpn->operationName ().myCstring ());

      fprintf (solnFile (), "Period      Execution\n");

      forEachPeriod (thePer, myProblem ())
         {
         fprintf (solnFile (), "%6d  ", thePer);

         writeMeSoln (myExecVar (theOpn, thePer));

         fprintf (solnFile (), "\n");
         }
      }
   }

//------------------------------------------------------------------------------

void WitImpOM::writeSubEntrySoln ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitPeriod t;

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         {
         fprintf (solnFile (),
            "\n"
            "Consuming Operation: %s,  Part Replaced: %s,  BOM Entry #%d:\n"
            "\n",
            theBomEnt->myOperationName ().myCstring (),
            theBomEnt->myPartName ().myCstring (),
            theBomEnt->localIndex ());

         fprintf (solnFile (), "Period        Non-Sub\n");

         forEachPeriod (t, myProblem ())
            if (theBomEnt->inEffect (t))
               {
               fprintf (solnFile (), "   %3d  ", t);

               writeMeSoln (myNonSubVar (theBomEnt, t));

               fprintf (solnFile (), "\n");
               }

         fprintf (solnFile (),
            "\n"
            "Period  Substitute       Sub #   Substitution\n");

         forEachPeriod (t, myProblem ())
            forEachEl (theSub, theBomEnt->mySubEntries ())
               if (theSub->inEffect (t))
                  {
                  fprintf (solnFile (),
                     "   %3d  %-12s  %8d  ",
                     t,
                     theSub->myPartName ().myCstring (),
                     theSub->localIndex ());

                  writeMeSoln (mySubVar (theSub, t));

                  fprintf (solnFile (), "\n");
                  }
         }
   }

//------------------------------------------------------------------------------

void WitImpOM::writeDemandSoln ()
   {
   WitDemand * theDemand;
   WitPeriod t;

   forEachDemand (theDemand, myProblem ())
      {
      fprintf (solnFile (),
         "\nPart %s,  Demand %s:\n",
         theDemand->demandedPartName ().myCstring (),
         theDemand->demandName ().myCstring ());

      fprintf (solnFile (),
          "Period       Shipment       Cum Ship\n");

      forEachPeriod (t, myProblem ())
         {
         fprintf (solnFile (), "%6d  ", t);

         writeMeSoln (myShipVar    (theDemand, t));
         writeMeSoln (myCumShipVar (theDemand, t));

         fprintf (solnFile (), "\n");
         }
      }
   }

//------------------------------------------------------------------------------

void WitImpOM::writeBoundedVarSoln ()
   {
   WitBoundedVar * theBoundedVar;

   fprintf (solnFile (),
      "\n\nVar Index"
      "   Hard LB"
      "   Soft LB"
      " Violation"
      "     Value"
      "   Hard UB"
      "\n");

   forEachEl (theBoundedVar, myBoundedVars_)
      theBoundedVar->printSoln ();
   }

//------------------------------------------------------------------------------

template <typename Item, typename DerModelEl>
      void WitImpOM::insertInto (
         WitPtrSched <Item, DerModelEl> & thePtrSched,
         const Item *                     theItem,
         DerModelEl *                     theDerModelEl)
   {
   if (thePtrSched.domainSize () == 0)
      thePtrSched.allocate1D (myProblem ());

   if (thePtrSched.myPtrTVecAt (theItem).length () == 0)
       thePtrSched.myPtrTVecAt (theItem).allocate (myProblem ());

   witAssert (
      thePtrSched.myPtrAt (theItem, theDerModelEl->myPeriod ()) == NULL);

   thePtrSched.myPtrAt (theItem, theDerModelEl->myPeriod ()) = theDerModelEl;
   }

//------------------------------------------------------------------------------

template <typename Item, typename DerModelEl>
      DerModelEl * WitImpOM::lookUp (
         WitPtrSched <Item, DerModelEl> & thePtrSched,
         const Item *                     theItem,
         WitPeriod                        thePer)
   {
   if (thePtrSched.domainSize () == 0)
      return NULL;

   if (thePtrSched.myPtrTVecAt (theItem).length () == 0)
      return NULL;

   return thePtrSched.myPtrAt (theItem, thePer);
   }

//------------------------------------------------------------------------------

void WitImpOM::screenImpCons ()
   {
   WitPart * thePart;
   WitDemand * theDemand;
   WitPeriod t;
   int nVarsFixed = 0; // # variables fixed.

   forEachPart (thePart, myProblem ())
      forEachPeriod (t, myProblem ())
         nVarsFixed += screen (myResourceCon (thePart, t));

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (t, myProblem ())
         nVarsFixed += screen (myShipCon (theDemand, t));

   if (DEVELOPMENT)
      myMsgFac () ("nVarsFixedMsg", nVarsFixed);
   }

//------------------------------------------------------------------------------

void WitImpOM::relaxCumShipNonNeg ()
   {
   WitDemand * theDemand;
   WitPeriod t;
   WitCumShipVar * theCumShipVar;
   int nRelaxed = 0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (t, myProblem ())
         {
         theCumShipVar = myCumShipVar (theDemand, t);

         if (theCumShipVar->bounds ().upper () > 0.0)
            if (theCumShipVar->bounds ().lower () == 0.0)
               {
               theCumShipVar->bounds ().lower () = - DBL_MAX;

               ++ nRelaxed;
               }
         }

   if (DEVELOPMENT)
      myMsgFac () ("nCshipRelaxedMsg", nRelaxed);
   }

//------------------------------------------------------------------------------

void WitImpOM::screenSlbModelEls ()
   {
   WitBoundedVar * theBoundedVar;
   WitSlbCon *     theSlbCon;
   int             nScreened = 0;

   forEachEl (theBoundedVar, myBoundedVars_)
      {
      theSlbCon = mySlbCon (theBoundedVar);

      if (theSlbCon != NULL)
         if (theBoundedVar->softLB () <=
             theBoundedVar->hardLB () + FLOAT_EPSILON)
            {
            theSlbCon->bounds ().lower () = - DBL_MAX;

            mySlbvVar (theBoundedVar)->bounds ().upper () = 0.0;

            ++ nScreened;
            }
      }

   if (DEVELOPMENT)
      myMsgFac () ("nSlbScreenedMsg", nScreened);
   }

//------------------------------------------------------------------------------

bool WitImpOM::positiveHardLBsExist ()
   {
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;

   forEachMaterial (theMat, myProblem ())
      if (theMat->stockBounds ()->hasPositiveHardLB ())
         return true;

   forEachDemand (theDemand, myProblem ())
      if (theDemand->cumShipBounds ()->hasPositiveHardLB ())
         return true;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->execBounds ()->hasPositiveHardLB ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitImpOM::printBoundedVars ()
   {
   WitBoundedVar * theBoundedVar;

   fprintf (modelFile (),
      "\n\n"
      "Bound Data\n"
      "===== ====\n\n\n");

   fprintf (modelFile (),
      "# Bounded Variables: %8d\n",   myBoundedVars_.nElements ());

   fprintf (modelFile (), "# Slbv Variables:    %8d\n\n", nSlbvVars_);

   fprintf (modelFile (),
        "Variable"
      "   Hard LB"
      "   Soft LB"
      "   Hard UB"
      "\n");

   forEachEl (theBoundedVar, myBoundedVars_)
      theBoundedVar->printBoundInfo ();
   }

#endif
@


1.28
log
@Removed optimizing implosion with lot sizes.
@
text
@@


1.27
log
@Updated the copyright date on all source files.
@
text
@a141 14
void WitImpOM::storeDerived (WitIlsMultVar * theIlsMultVar)
   {
   insertInto (myIlsMultVar_, theIlsMultVar->myOpn (), theIlsMultVar);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitMlsMultVar * theMlsMultVar)
   {
   insertInto (myMlsMultVar_, theMlsMultVar->myOpn (), theMlsMultVar);
   }

//------------------------------------------------------------------------------

a189 14

void WitImpOM::storeDerived (WitLotSizeCon * theLotSizeCon)
   {
   insertInto (myLotSizeCon_, theLotSizeCon->myOpn (), theLotSizeCon);
   }

//------------------------------------------------------------------------------

void WitImpOM::storeDerived (WitMlsCon * theMlsCon)
   {
   insertInto (myMlsCon_, theMlsCon->myOpn (), theMlsCon);
   }

//------------------------------------------------------------------------------
a220 14
WitIlsMultVar * WitImpOM::myIlsMultVar (WitOperation * theOpn, WitPeriod thePer)
   {
   return lookUp (myIlsMultVar_, theOpn, thePer);
   }

//------------------------------------------------------------------------------

WitMlsMultVar * WitImpOM::myMlsMultVar (WitOperation * theOpn, WitPeriod thePer)
   {
   return lookUp (myMlsMultVar_, theOpn, thePer);
   }

//------------------------------------------------------------------------------

a262 14
WitLotSizeCon * WitImpOM::myLotSizeCon (WitOperation * theOpn, WitPeriod thePer)
   {
   return lookUp (myLotSizeCon_, theOpn, thePer);
   }

//------------------------------------------------------------------------------

WitMlsCon * WitImpOM::myMlsCon (WitOperation * theOpn, WitPeriod thePer)
   {
   return lookUp (myMlsCon_, theOpn, thePer);
   }

//------------------------------------------------------------------------------

a344 40
bool WitImpOM::genLsMode (WitOperation * theOpn, WitPeriod thePer)
   {
   if (ls1Mode (theOpn, thePer))
      return false;

   if (myOptComp ()->optWithLotSizes ())
      if (theOpn->executable ()[thePer])
         if (myOptImploder ()->incLotSize (theOpn, thePer) > 0)
            return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitImpOM::mlsMode (WitOperation * theOpn, WitPeriod thePer)
   {
   if (myOptComp ()->optWithLotSizes ())
      if (theOpn->executable ()[thePer])
         if (myOptImploder ()->minLotSize (theOpn, thePer) > 0)
            return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitImpOM::ls1Mode (WitOperation * theOpn, WitPeriod thePer)
   {
   if (theOpn->myOptComp ()->optWithLotSizes ())
      if (theOpn->executable ()[thePer])
         if    (myOptImploder ()->incLotSize (theOpn, thePer) == 1)
            if (myOptImploder ()->minLotSize (theOpn, thePer) == 0)
               return true;

   return false;
   }

//------------------------------------------------------------------------------

a425 12
   if (myOptComp ()->optWithLotSizes ())
      forEachOperation (theOpn, myProblem ())
         forEachPeriod (thePer, myProblem ())
            if (genLsMode (theOpn, thePer))
               new WitIlsMultVar (theOpn, thePer, this);

   if (myOptComp ()->optWithLotSizes ())
      forEachOperation (theOpn, myProblem ())
         forEachPeriod (thePer, myProblem ())
            if (mlsMode (theOpn, thePer))
               new WitMlsMultVar (theOpn, thePer, this);

a459 1
   WitOperation *  theOpn;
a476 12
   if (myOptComp ()->optWithLotSizes ())
      forEachOperation (theOpn, myProblem ())
         forEachPeriod (thePer, myProblem ())
            if (genLsMode (theOpn, thePer))
               new WitLotSizeCon (theOpn, thePer, this);

   if (myOptComp ()->optWithLotSizes ())
      forEachOperation (theOpn, myProblem ())
         forEachPeriod (thePer, myProblem ())
            if (mlsMode (theOpn, thePer))
               new WitMlsCon (theOpn, thePer, this);

d638 1
a638 9
      fprintf (solnFile (), "Period      Execution");

      if (myOptComp ()->optWithLotSizes ())
         {
         fprintf (solnFile (), "       MLS Mult");
         fprintf (solnFile (), "       ILS Mult");
         }

      fprintf (solnFile (), "\n");
a645 6
         if (myOptComp ()->optWithLotSizes ())
            {
            writeMeSoln (myMlsMultVar (theOpn, thePer));
            writeMeSoln (myIlsMultVar (theOpn, thePer));
            }

@


1.26
log
@Removed some more OSL items.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.25
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d40 2
d961 1
a961 1
               theCumShipVar->bounds ().lower () = - OSL_INFTY;
d987 1
a987 1
            theSlbCon->bounds ().lower () = - OSL_INFTY;
@


1.24
log
@[multi-thread]
@
text
@d476 1
a476 1
   solnFile_ = openFile (fName, "w");
@


1.23
log
@[multi-thread]
@
text
@d383 1
a383 1
   fprintf (WitOptModel::modelFile (),
@


1.22
log
@Revised mappingIndex code.
@
text
@d404 1
a404 1
   if (myProblem ()->myOptComp ()->optWithLotSizes ())
d416 1
a416 1
   if (myProblem ()->myOptComp ()->optWithLotSizes ())
d467 1
a467 1
// Optionally prints the dual solution for material balance constraints.
d520 1
a520 1
   if (myProblem ()->myOptComp ()->optWithLotSizes ())
d526 1
a526 1
   if (myProblem ()->myOptComp ()->optWithLotSizes ())
d584 1
a584 1
   if (myProblem ()->myOptComp ()->optWithLotSizes ())
d590 1
a590 1
   if (myProblem ()->myOptComp ()->optWithLotSizes ())
d759 1
a759 1
      if (myProblem ()->myOptComp ()->optWithLotSizes ())
d773 1
a773 1
         if (myProblem ()->myOptComp ()->optWithLotSizes ())
@


1.21
log
@Fixed a bug in the screening of the optimization model.
@
text
@a38 1
#include <MapIdxI.h>
@


1.20
log
@Double Precision.
@
text
@a446 2
   fixScrapVars ();

a922 45
// scrapVarNeeded
// Returns true iff a scrap variable is needed for thePart in
// period thePer. This is true iff there is any way for there to be forced
// additional availability of thePart in period thePer.
//------------------------------------------------------------------------------

bool WitImpOM::scrapVarNeeded (WitPart * thePart, WitPeriod thePer)
   {
   WitMaterial * theMat;
   WitBopEntry * theBopEnt;
   WitExecPerItr theExecPerItr;
   double        softLBval;

   if (thePart->supplyVol ()[thePer] > 0.0)
      return true;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (thePer > 0)
         {
         const WitDblFlexVec & stockSoftLB = theMat->stockBounds ()->softLB ();

         if (stockSoftLB[thePer] < stockSoftLB[thePer - 1])
            return true;
         }

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      for (theExecPerItr (theBopEnt, thePer); ++ theExecPerItr;)
         {
         softLBval = 
            theBopEnt->
               myOperation ()->execBounds ()->softLB ()[theExecPerItr ()];

         if (softLBval > 0.0)
            return true;
         }

   if (thePart->isCoproduced ()[thePer])
      return true;

   return false;
   }

//------------------------------------------------------------------------------
a940 21
   }

//------------------------------------------------------------------------------

void WitImpOM::fixScrapVars ()
   {
   WitPart * thePart;
   WitPeriod t;
   int nFixed = 0;

   forEachPart (thePart, myProblem ())
      forEachPeriod (t, myProblem ())
         if (not scrapVarNeeded (thePart, t))
            {
            myScrapVar (thePart, t)->bounds ().upper () = 0.0;

            ++ nFixed;
            }

   if (DEVELOPMENT)
      myMsgFac () ("nScrapFixedMsg", nFixed);
@


1.19
log
@Double Precision.
@
text
@d946 1
a946 2
         const WitFlexVec <double> & stockSoftLB =
            theMat->stockBounds ()->softLB ();
@


1.18
log
@Double Precision.
@
text
@d946 2
a947 1
         const WitRealVec & stockSoftLB = theMat->stockBounds ()->softLB ();
@


1.17
log
@Double Precision.
@
text
@d936 1
a936 1
   float         softLBval;
@


1.16
log
@Removed a bad function overload.
@
text
@d946 1
a946 2
         const WitFlexVec <float> & stockSoftLB = 
            theMat->stockBounds ()->softLB ();
@


1.15
log
@Corrected a file inclusion AIX porting bug.
@
text
@d730 1
a730 1
         theMat = thePart->myMat ();
d941 1
a941 1
   theMat = thePart->myMat ();
@


1.14
log
@Continued implementation of post-implosion pegging.
@
text
@d39 1
@


1.13
log
@Continued implementation of opt with COIN.
@
text
@a38 1
#include <PtrSchedI.h>
@


1.12
log
@Continued implementation of opt with COIN.
@
text
@a15 5
int compiledImpOM = 1;
   //
   // WATCOM's strict compatibility mode requires every file to
   // have at least one external definition.

@


1.11
log
@Continued implementation of proportionate routing.
@
text
@d480 1
a480 1
   WitTimingEvent theEvent ("extra");
d497 2
d676 1
d683 2
a684 1
         theSlbvVar->primalValue () =
d687 3
@


1.10
log
@Various internal changes.
@
text
@d728 1
a728 1
         thePart->getMaterial (theMat);
d939 1
a939 1
   thePart->getMaterial (theMat);
@


1.9
log
@Various internal changes.
@
text
@a107 22
// Global template function insertInto.
//------------------------------------------------------------------------------

template <typename Item, typename DerModelEl>
      void insertInto (
         WitPtrSched <Item, DerModelEl> & thePtrSched,
         const Item *                     theItem,
         DerModelEl *                     theDerModelEl)
   {
   if (thePtrSched.domainSize () == 0)
      thePtrSched.allocate1D (theItem->myProblem ());

   if (thePtrSched.myPtrTVecAt (theItem).length () == 0)
       thePtrSched.myPtrTVecAt (theItem).allocate (theItem->myProblem ());

   witAssert (
      thePtrSched.myPtrAt (theItem, theDerModelEl->myPeriod ()) == NULL);

   thePtrSched.myPtrAt (theItem, theDerModelEl->myPeriod ()) = theDerModelEl;
   }

//------------------------------------------------------------------------------
a221 19
// Global template function lookUp.
//------------------------------------------------------------------------------

template <typename Item, typename DerModelEl>
      DerModelEl * lookUp (
         WitPtrSched <Item, DerModelEl> & thePtrSched,
         const Item *                     theItem,
         WitPeriod                        thePer)
   {
   if (thePtrSched.domainSize () == 0)
      return (DerModelEl *) NULL;

   if (thePtrSched.myPtrTVecAt (theItem).length () == 0)
      return (DerModelEl *) NULL;

   return thePtrSched.myPtrAt (theItem, thePer);
   }

//------------------------------------------------------------------------------
d883 37
@


1.8
log
@Internal changes.
@
text
@d111 1
a111 1
template <class Item, class DerModelEl>
d247 1
a247 1
template <class Item, class DerModelEl>
@


1.7
log
@Internal changes.
@
text
@d835 1
a835 1
      if (! theBomEnt->mySubEntries ().isEmpty ())
d1003 1
a1003 1
         if (! scrapVarNeeded (thePart, t))
@


1.6
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d80 1
a80 1
WitBoolean WitImpOM::needDual ()
d83 1
a83 1
      return witTRUE;
d86 1
a86 1
      return witTRUE;
d88 1
a88 1
   return witFALSE;
d446 1
a446 1
WitBoolean WitImpOM::genLsMode (WitOperation * theOpn, WitPeriod thePer)
d449 1
a449 1
      return witFALSE;
d454 1
a454 1
            return witTRUE;
d456 1
a456 1
   return witFALSE;
d461 1
a461 1
WitBoolean WitImpOM::mlsMode (WitOperation * theOpn, WitPeriod thePer)
d466 1
a466 1
            return witTRUE;
d468 1
a468 1
   return witFALSE;
d473 1
a473 1
WitBoolean WitImpOM::ls1Mode (WitOperation * theOpn, WitPeriod thePer)
d479 1
a479 1
               return witTRUE;
d481 1
a481 1
   return witFALSE;
d502 1
a502 1
WitBoolean WitImpOM::slbvVarsExist ()
d928 1
a928 1
// Returns TRUE iff a scrap variable is needed for thePart in
d933 1
a933 1
WitBoolean WitImpOM::scrapVarNeeded (WitPart * thePart, WitPeriod thePer)
d941 1
a941 1
      return witTRUE;
d952 1
a952 1
            return witTRUE;
d963 1
a963 1
            return witTRUE;
d967 1
a967 1
      return witTRUE;
d969 1
a969 1
   return witFALSE;
d1071 1
a1071 1
WitBoolean WitImpOM::positiveHardLBsExist ()
d1079 1
a1079 1
         return witTRUE;
d1083 1
a1083 1
         return witTRUE;
d1087 1
a1087 1
         return witTRUE;
d1089 1
a1089 1
   return witFALSE;
@


1.5
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d22 1
a22 1
// Please note: the following #includes are placed outside the 
d175 7
d231 8
a238 1
void WitImpOM::storeDerived (WitIncLotSizeCon * theIncLotSizeCon)
d240 1
a240 1
   insertInto (myIncLotSizeCon_, theIncLotSizeCon->myOpn (), theIncLotSizeCon);
d301 7
d350 8
a357 3
WitIncLotSizeCon * WitImpOM::myIncLotSizeCon (
      WitOperation * theOpn,
      WitPeriod      thePer)
d359 1
a359 1
   return lookUp (myIncLotSizeCon_, theOpn, thePer);
d446 40
d530 1
a530 1
   writeOperationSoln    ();
d570 1
a570 1
            if (ilsConNeeded (theOpn, thePer))
d573 6
d634 8
a641 2
            if (ilsConNeeded (theOpn, thePer))
               new WitIncLotSizeCon (theOpn, thePer, this);
d802 2
d805 1
d816 2
d819 1
a967 17

   return witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitImpOM::ilsConNeeded (WitOperation * theOpn, WitPeriod thePer)
   {
   float ils;

   ils = theOpn->incLotSize ()[thePer];

   if (myProblem ()->myOptComp ()->optWithLotSizes ())
      if (theOpn->executable ()[thePer])
         if (ils > 0.0)
            if (fabs (ils - 1.0) > .001)
               return witTRUE;
@


1.4
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d123 3
d168 7
d223 7
d280 7
d329 9
d485 1
a485 1
   WitPeriod       t;
d488 3
a490 3
      forEachPeriod (t, myProblem ())
         if (theMat->canStock (t))
            new WitStockVar (theMat, t, this);
d493 2
a494 2
      forEachPeriod (t, myProblem ())
         new WitScrapVar (thePart, t, this);
d497 9
a505 3
      forEachPeriod (t, myProblem ())
         if (theOpn->executable ()[t])
            new WitExecVar (theOpn, t, this);
d508 3
a510 3
      forEachPeriod (t, myProblem ())
         if (theBomEnt->hasSubsInEffect ()[t])
            new WitNonSubVar (theBomEnt, t, this);
d513 3
a515 3
      forEachPeriod (t, myProblem ())
         if (theSub->inEffect (t))
            new WitSubVar (theSub, t, this);
d518 2
a519 2
      forEachPeriod (t, myProblem ())
         new WitShipVar (theDemand, t, this);
d522 2
a523 2
      forEachPeriod (t, myProblem ())
         new WitCumShipVar (theDemand, t, this);
d538 5
a542 4
   WitPart * thePart;
   WitBomEntry * theBomEnt;
   WitDemand * theDemand;
   WitPeriod t;
d546 2
a547 2
      forEachPeriod (t, myProblem ())
         new WitResourceCon (thePart, t, this);
d551 3
a553 3
         forEachPeriod (t, myProblem ())
            if (theBomEnt->hasSubsInEffect ()[t])
               new WitSubCon (theBomEnt, t, this);
d556 8
a563 2
      forEachPeriod (t, myProblem ())
         new WitShipCon (theDemand, t, this);
d713 1
a713 1
   WitPeriod t;
d721 4
a724 1
      fprintf (solnFile (), "Period      Execution\n");
d726 3
a728 1
      forEachPeriod (t, myProblem ())
d730 3
a732 1
         fprintf (solnFile (), "%6d  ", t);
d734 2
a735 1
         writeMeSoln (myExecVar (theOpn, t));
d809 1
a809 1
          "Period       Shipment     Cum. Ship.\n");
d884 17
@


1.3
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a41 1
#include <ScheduleI.h>
d44 1
d56 1
a56 1
      WitOptModel    (theOptImploder),
d58 8
a65 8
      myBoundsObj_   (NULL),
      myPrimaryObj_  (NULL),
      myObj1Obj_     (NULL),
      myRevObj_      (NULL),
      myInvObj_      (NULL),
      myServObj_     (NULL),
      mySubObj_      (NULL),
      myObj2Obj_     (NULL),
d67 2
a68 2
      nSlbvVars_     (0),
      solnFile_      (NULL)
d113 3
a115 3
         WitSchedule <Item, DerModelEl *> & theSched,
         const Item *                       theItem,
         DerModelEl *                       theDerModelEl)
d117 2
a118 2
   if (theSched.domainSize () == 0)
      theSched.allocate1D (theItem->myProblem ());
d120 2
a121 2
   if (theSched (theItem).length () == 0)
      theSched (theItem).allocate (theItem->myProblem (), (DerModelEl *) NULL);
d123 1
a123 1
   theSched (theItem)[theDerModelEl->myPeriod ()] = theDerModelEl;
d213 1
a213 1
// Global template function blob.
d218 3
a220 3
         WitSchedule <Item, DerModelEl *> & theSched,
         const Item *                       theItem,
         WitPeriod                          thePer)
d222 1
a222 1
   if (theSched.domainSize () == 0)
d225 1
a225 1
   if (theSched (theItem).length () == 0)
d228 1
a228 1
   return theSched (theItem)[thePer];
d888 1
a888 1
         theCumShipVar = myCumShipVar_ (theDemand)[t];
@


1.2
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d108 17
a124 16
// Macro implementStoreDerived.
//
// Implements a storeDerived function for class ModelElClass, whose Schedule
// is theSchedule, and whose source item is returned by
// ModelElClass::itemFunc ().
//------------------------------------------------------------------------------

#define implementStoreDerived(ModelElClass, theSchedule, itemFunc)             \
                                                                               \
   void WitImpOM::storeDerived (ModelElClass * theModelEl)                     \
      {                                                                        \
      theSchedule.insert (                                                     \
         theModelEl,                                                           \
         theModelEl->itemFunc (),                                              \
         theModelEl->myPeriod ());                                             \
      }                                                                        \
d130 100
a229 29
implementStoreDerived (WitScrapVar,    myScrapVar_,    myPart)
implementStoreDerived (WitNonSubVar,   myNonSubVar_,   myBomEnt)
implementStoreDerived (WitSubVar,      mySubVar_,      mySub)
implementStoreDerived (WitShipVar,     myShipVar_,     myDemand)
implementStoreDerived (WitSlbvVar,     mySlbvVar_,     myBoundSet)
implementStoreDerived (WitExecVar,     myExecVar_,     myOperation)
implementStoreDerived (WitStockVar,    myStockVar_,    myMaterial)
implementStoreDerived (WitCumShipVar,  myCumShipVar_,  myDemand)

implementStoreDerived (WitResourceCon, myResourceCon_, myPart)
implementStoreDerived (WitSubCon,      mySubCon_,      myBomEnt)
implementStoreDerived (WitShipCon,     myShipCon_,     myDemand)
implementStoreDerived (WitSlbCon,      mySlbCon_,      myBoundSet)

//------------------------------------------------------------------------------
// Macro implementLookUp.
//
// Implements a look-up function for the ModelEls of class ModelElClass that
// belong to this ImpOM. The function name is given by func and the
// instances of class ModelElClass correspond to instances of implosion object
// class ImpClass.
//------------------------------------------------------------------------------

#define implementLookUp(ModelElClass, func, ImpClass)                          \
                                                                               \
   ModelElClass * WitImpOM::func (ImpClass * theObject, WitPeriod t)           \
      {                                                                        \
      return func ## _.ifAny (theObject, t);                                   \
      }                                                                        \
d235 67
a301 11
implementLookUp (WitScrapVar,    myScrapVar,    WitPart)
implementLookUp (WitNonSubVar,   myNonSubVar,   WitBomEntry)
implementLookUp (WitSubVar,      mySubVar,      WitSubEntry)
implementLookUp (WitShipVar,     myShipVar,     WitDemand)
implementLookUp (WitExecVar,     myExecVar,     WitOperation)
implementLookUp (WitStockVar,    myStockVar,    WitMaterial)
implementLookUp (WitCumShipVar,  myCumShipVar,  WitDemand)

implementLookUp (WitResourceCon, myResourceCon, WitPart)
implementLookUp (WitSubCon,      mySubCon,      WitBomEntry)
implementLookUp (WitShipCon,     myShipCon,     WitDemand)
d308 2
a309 1
      (WitSlbvVar *) mySlbvVar_.ifAny (
d319 2
a320 1
      (WitSlbCon *) mySlbCon_.ifAny (
d867 1
a867 1
            myScrapVar_ (thePart)[t]->bounds ().upper () = 0.0;
@


1.1
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a26 1
#include <Session.h>
d29 3
d43 1
@


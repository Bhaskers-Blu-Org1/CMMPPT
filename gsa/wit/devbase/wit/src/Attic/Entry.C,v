head	1.70;
access;
symbols
	sce_5_01_20080919:1.67
	latest_sce_4_20_20060523:1.50.0.2
	sce_4_20_20060523:1.50
	latest_sce4_20_OSL:1.49.0.2
	sce_4_20_OSL:1.49
	sce_410_withVa:1.47
	sce_4_05_20040511:1.45
	sce_4_00_20040201:1.32
	nextGenBranch:1.28.0.2
	nextGenRoot:1.28
	sce_3_30_20030627:1.28
	EndRw-branch:1.18.0.4
	Root-of-EndRw:1.18
	rwToStl:1.18.0.2
	latest_sce_3_10_20010924:1.6.0.6
	sce_3_10_20010924:1.6
	latest_sce_3_00_20010601:1.6.0.4
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.70
date	2010.09.10.22.45.33;	author rjw;	state dead;
branches;
next	1.69;

1.69
date	2010.09.10.22.10.38;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.13.19.01.25;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.07.23.51.49;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.29.16.24.42;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.28.23.23.45;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.15.17.15.33;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.07.31.20.39.45;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.05.21.06.00;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.05.16.15.23;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.01.16.22.10;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.30.21.02.10;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.30.16.01.18;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.27.22.59.29;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.27.19.59.30;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.08.22.47.33;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.09.21.15.42.25;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.02.17.33.57;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.24.22.28.52;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.09.30.21.57.54;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.24.23.23.55;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.27.21.03.27;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.01.21.05.12;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.31.22.56.07;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.29.23.21.27;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.24.22.21.29;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.23.19.14.23;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.05.22.19.57;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.12.19.13.39;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.06.23.27.09;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.06.00.17.32;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.15.18.12.02;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.11.18.29.12;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.25.23.49.55;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.05.20.18.23;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.07.18.06.14;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.19.16.48.16;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.07.21.34.16;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.26.21.42.52;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.21.18.56.23;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.13.23.06.27;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.02.23.40.39;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.02.22.18.24;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.30.21.57.24;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.30.20.37.24;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.11.18.53.07;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.22.21.16.20;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.05.21.19.57;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.04.23.07.19;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.03.16.01.47;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.29.21.35.45;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.19.21.49;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.20.14.54;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.03.23.16.36;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.01.14.25.54;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.22.14.32.06;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.14.02.30;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.04.22.27.50;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.20.12.30;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.29.21.22.43;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.21;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.41;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Heuristic Adjustment
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "Entry.C"
//
// Contains the implementation of the following classes:
//
//    BillEntry
//    ConsEntry
//------------------------------------------------------------------------------

#include <StochImpMgr.h>
#include <CompMgr.h>
#include <Part.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <DataWrit.h>
#include <Pre.h>
#include <ObjStack.h>
#include <IVRealArg.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class BillEntry.
//------------------------------------------------------------------------------

WitBillEntry::~WitBillEntry ()
   {
   }

//------------------------------------------------------------------------------

const WitString & WitBillEntry::myPartName ()
   {
   return myPart ()->partName ();
   }

//------------------------------------------------------------------------------

const WitString & WitBillEntry::myOperationName ()
   {
   return myOperation ()->operationName ();
   }

//------------------------------------------------------------------------------

const WitDblFlexVec & WitBillEntry::offset ()
   {
   return offset_;
   }

//------------------------------------------------------------------------------

int WitBillEntry::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nBillEntries ();
   }

//------------------------------------------------------------------------------

WitPeriod WitBillEntry::defLatestPeriod (WitProblem * theProblem)
   {
   return theProblem->lastPeriod ();
   }

//------------------------------------------------------------------------------

void WitBillEntry::storePreImpactPeriod (WitPeriod thePer, WitPeriod theValue)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   impactPeriod_[thePer] = theValue;
   }

//------------------------------------------------------------------------------

void WitBillEntry::unpreprocess ()
   {
   impactPeriod_ = -1;

   firstEPIndex_.clear ();
   execPeriod_  .clear ();
   }

//------------------------------------------------------------------------------

bool WitBillEntry::storesOffset ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitBillEntry::withinInterval (WitPeriod thePer)
   {
   return (thePer >= earliestPeriod ()) and (thePer <= latestPeriod ());
   }

//------------------------------------------------------------------------------

WitBillEntry::WitBillEntry (WitPart * thePart, int theLocalIndex):

      WitDelComp      (thePart->myCompMgr ()),

      mappingIndex_   (myCompMgr ()->nBillEntries ()),
      myPart_         (thePart),
      localIndex_     (theLocalIndex),

      offset_         (myProblem (), defOffset ()),
      earliestPeriod_ (defEarliestPeriod ()),
      latestPeriod_   (defLatestPeriod (myProblem ())),
      routingShare_   (myProblem (), defRoutingShare ()),

      impactPeriod_   (myProblem (), -1),

      firstEPIndex_   (),
      execPeriod_     ()
   {
   }

//------------------------------------------------------------------------------

void WitBillEntry::writeOffset ()
   {
   myDataWriter ()->writeVector (
      "offset",
      offset (),
      defOffset ());
   }

//------------------------------------------------------------------------------

void WitBillEntry::preConstruct (WitOperation * theOpn, WitPart * thePart)
   {
   witAssert (theOpn  != NULL);
   witAssert (thePart != NULL);

   witAssert (theOpn->myProblem () == thePart->myProblem ());
   }

//------------------------------------------------------------------------------

void WitBillEntry::recountBillEntry ()
   {
   mappingIndex_ = myCompMgr ()->nBillEntries ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitBillEntry::setEarliestPeriod (int theValue)
   {
   witAssert (theValue >= 0);
   witAssert (theValue <= nPeriods ());

   prepSetUnpreAttr ();

   earliestPeriod_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBillEntry::setLatestPeriod (int theValue)
   {
   witAssert (theValue >= 0);
   witAssert (theValue <= lastPeriod ());

   prepSetUnpreAttr ();

   latestPeriod_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBillEntry::setRoutingShare (const WitIVRealArg & theValue)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         witAssert (theValue[thePer] >= 1.0 - FLOAT_EPSILON);

   prepSetUnpostAttr ();

   routingShare_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBillEntry::setOffset (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (storesOffset ());

   prepSetUnpreAttr ();

   offset_ = theValue;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitBillEntry::getAllInstances (
      WitProblem *                 theProblem,
      WitObjStack <WitBillEntry> & theBillEntries)
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;

   theBillEntries.clear ();

   forEachBomEntry (theBomEnt, theProblem)
      theBillEntries.push (theBomEnt);
      
   forEachSubEntry (theSub, theProblem)
      theBillEntries.push (theSub);
      
   forEachBopEntry (theBopEnt, theProblem)
      theBillEntries.push (theBopEnt);

   theBillEntries.reverse ();
   }

//------------------------------------------------------------------------------

void WitBillEntry::reLocalIndex (WitProblem * theProblem)
   {
   WitOperation * theOpn;
   WitBomEntry  * theBomEnt;

   forEachOperation (theOpn, theProblem)
      {
      reLocalIndex (theOpn->bom ());
      reLocalIndex (theOpn->bop ());

      forEachEl (theBomEnt, theOpn->bom ())
         reLocalIndex (theBomEnt->mySubEntries ());
      }
   }

//------------------------------------------------------------------------------

void WitBillEntry::displayMandEC ()
   {
   }

//------------------------------------------------------------------------------

void WitBillEntry::writeDataAttrs ()
   {
   WitDelComp::writeDataAttrs ();

   myDataWriter ()->writeInt (
      "earliestPeriod",
      earliestPeriod (),
      defEarliestPeriod ());

   myDataWriter ()->writeInt (
      "latestPeriod",
      latestPeriod (),
      defLatestPeriod (myProblem ()));

   myDataWriter ()->writeVector (
      "routingShare",
      routingShare_,
      defRoutingShare ());
   }

//------------------------------------------------------------------------------

void WitBillEntry::copyAttrsFrom (WitBillEntry * theBillEnt)
   {
   WitDelComp::copyAttrsFrom (theBillEnt);

   if (storesOffset ())
      offset_      = theBillEnt->offset_;
   earliestPeriod_ = theBillEnt->earliestPeriod_;
   latestPeriod_   = theBillEnt->latestPeriod_;
   routingShare_   = theBillEnt->routingShare_;

   }

//------------------------------------------------------------------------------

void WitBillEntry::display ()
   {
   myMsgFac () ("billEntryDdMsg",
      mappingIndex_,
      earliestPeriod (),
      latestPeriod ());

   myProblem ()->display ("routingShareDdMsg", routingShare ());

   myProblem ()->display ("offsetDdMsg", offset ());

   displayMandEC ();

   if (myPreprocessor ()->preprocessed ())
      myMsgFac () ("impactPeriodDdMsg", impactPeriod ());

   WitDelComp::display ();
   }

//------------------------------------------------------------------------------
// Macro implementReLocalIndex (BillEntryClass)
//
// Implements WitBillEntry::reLocalIndex (const WitList <BillEntryClass> &)
// BillEntryClass must be derived from BillEntry.
//------------------------------------------------------------------------------

#define implementReLocalIndex(BillEntryClass)                                  \
                                                                               \
void WitBillEntry::reLocalIndex (const WitList <BillEntryClass> & theList)     \
   {                                                                           \
   BillEntryClass * theDerBillEntry;                                           \
   WitBillEntry *   theBillEnt;                                                \
   int              theIndex;                                                  \
                                                                               \
   if (theList.isEmpty ())                                                     \
      return;                                                                  \
                                                                               \
   if (theList.last ()->localIndex () == theList.nElements () - 1)             \
      return;                                                                  \
                                                                               \
   theIndex = 0;                                                               \
                                                                               \
   forEachEl (theDerBillEntry, theList)                                        \
      {                                                                        \
      theBillEnt              = theDerBillEntry;                               \
      theBillEnt->localIndex_ = theIndex ++;                                   \
      }                                                                        \
   }                                                                           \

//------------------------------------------------------------------------------

implementReLocalIndex (WitBomEntry)
implementReLocalIndex (WitSubEntry)
implementReLocalIndex (WitBopEntry)

//------------------------------------------------------------------------------
// Implementation of class ConsEntry.
//------------------------------------------------------------------------------

WitConsEntry::~WitConsEntry ()
   {
   }

//------------------------------------------------------------------------------

int WitConsEntry::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nConsEntries ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitConsEntry::setConsRate (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   prepSetUnpreAttr ();

   consRate_ = theValue;
   }

//------------------------------------------------------------------------------

void WitConsEntry::setFalloutRate (double theValue)
   {
   witAssert (theValue >= 0.0);
   witAssert (theValue <= 0.99 + FLOAT_EPSILON);

   prepSetUnpreAttr ();

   falloutRate_ = theValue;
   }

//------------------------------------------------------------------------------

void WitConsEntry::setExecPenalty (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   execPenalty_ = theValue;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitConsEntry::storePreEffConsRate (const WitTVec <double> & theTVec)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   effConsRate_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitConsEntry::storePreEffConsRate (double theValue)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   effConsRate_ = theValue;
   }

//------------------------------------------------------------------------------

void WitConsEntry::unpreprocess ()
   {
   effConsRate_ = 0.0;

   WitBillEntry::unpreprocess ();
   }

//------------------------------------------------------------------------------

WitConsEntry * WitConsEntry::thisConsEnt ()
   {
   return this;
   }

//------------------------------------------------------------------------------

void WitConsEntry::incConsVol (
            WitTVec <double> & consVolArg,
      const WitTVec <double> & execVolArg)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      if (inEffect (thePer))
         consVolArg[impactPeriod ()[thePer]] += 
            effConsRate ()[thePer] * execVolArg[thePer];
   }

//------------------------------------------------------------------------------

double WitConsEntry::effCost (WitPeriod thePer)
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

WitConsEntry::WitConsEntry (WitPart * thePart, int theLocalIndex):

      WitBillEntry  (thePart, theLocalIndex),

      mappingIndex_ (myCompMgr ()->nConsEntries ()),
      consRate_     (myProblem (), defConsRate ()),
      falloutRate_  (defFalloutRate ()),
      execPenalty_  (defExecPenalty ()),
      effConsRate_  (myProblem (), 0.0)
   {
   }

//------------------------------------------------------------------------------

void WitConsEntry::recountConsEntry ()
   {
   recountBillEntry ();

   mappingIndex_ = myCompMgr ()->nConsEntries ();
   }

//------------------------------------------------------------------------------

void WitConsEntry::writeDataAttrs ()
   {
   WitBillEntry::writeDataAttrs ();

   myDataWriter ()->writeVector (
      "consRate",
      consRate_,
      defConsRate ());

   myDataWriter ()->writeDouble (
      "falloutRate",
      falloutRate_,
      defFalloutRate ());

   myDataWriter ()->writeDouble (
      "execPenalty",
      execPenalty_,
      defExecPenalty ());
   }

//------------------------------------------------------------------------------

void WitConsEntry::copyAttrsFrom (WitConsEntry * theConsEnt)
   {
   WitBillEntry::copyAttrsFrom (theConsEnt);

   consRate_    = theConsEnt->consRate_;
   falloutRate_ = theConsEnt->falloutRate_;
   execPenalty_ = theConsEnt->execPenalty_;
   }

//------------------------------------------------------------------------------

void WitConsEntry::display ()
   {
   myMsgFac () ("consEntryDdMsg", 
      mappingIndex_,
      falloutRate_,
      execPenalty_);

   myProblem ()->display ("consRateDdMsg", consRate_);

   if (myPreprocessor ()->preprocessed ())
      myProblem ()->display ("effConsRateDdMsg", effConsRate_);

   WitBillEntry::display ();
   }
@


1.69
log
@Heuristic Adjustment
@
text
@@


1.68
log
@Removing objective #2.
@
text
@d22 1
a22 1
#include <Opn.h>
@


1.67
log
@Stochastic Implosion
@
text
@d459 1
a459 1
   return effConsRate ()[thePer] * myPart ()->unitCost ();
@


1.66
log
@Stochastic Implosion
@
text
@a94 7
int WitBillEntry::stageIndex ()
   {
   return myStochImpMgr ()->stageIndex (this);
   }

//------------------------------------------------------------------------------

@


1.65
log
@Stochastic Implosion
@
text
@d19 1
d95 1
a95 1
WitBillEntry * WitBillEntry::thisBillEnt ()
d97 1
a97 1
   return this;
@


1.64
log
@Stochastic Implosion
@
text
@d94 1
a94 1
WitConsEntry * WitConsEntry::thisConsEnt ()
d442 7
@


1.63
log
@Stochastic Implosion
@
text
@d75 1
a75 1
void WitBillEntry::passPreRefs ()
d77 3
a79 1
   myPreprocessor ()->receiveRefs (this, impactPeriod_);
d415 10
a424 1
void WitConsEntry::passPreRefs ()
d426 1
a426 1
   WitBillEntry::passPreRefs ();
d428 1
a428 1
   myPreprocessor ()->receiveRefs (this, effConsRate_);
@


1.62
log
@Stochastic Implosion
@
text
@d26 1
d220 24
@


1.61
log
@Stochastic Implosion
@
text
@a25 1
#include <PreData.h>
a80 7
void WitBillEntry::importPreData ()
   {
   impactPeriod_ = expPreData ()->impactPeriod () (this);
   }

//------------------------------------------------------------------------------

a396 9
void WitConsEntry::importPreData ()
   {
   WitBillEntry::importPreData ();

   effConsRate_ = expPreData ()->effConsRate () (this);
   }

//------------------------------------------------------------------------------

@


1.60
log
@Stochastic Implosion
@
text
@d75 7
d396 9
@


1.59
log
@Stochastic Implosion
@
text
@d392 2
@


1.58
log
@Stochastic Implosion
@
text
@a15 1
//    ExecPerItr
a219 9
int WitBillEntry::nExecPeriods (WitPeriod thePer)
   {
   return 
      firstEPIndex_[thePer + 1] - 
      firstEPIndex_[thePer];
   }

//------------------------------------------------------------------------------

a236 24
bool WitBillEntry::hasNextExecPer (
      WitPeriod   impactPer,
      int &       theIndex,
      WitPeriod & execPer)
   {
   bool execPerFound;

   if (theIndex < 0)
      theIndex = firstEPIndex_[impactPer];
   else
      theIndex ++;

   execPerFound = (theIndex < firstEPIndex_[impactPer + 1]);

   execPer = 
      execPerFound?
         execPeriod_[theIndex]:
         -1;

   return execPerFound;
   }

//------------------------------------------------------------------------------

a280 3
   WitPeriod     impactPer;
   WitExecPerItr theExecPerItr;

a294 9
   if (myPreprocessor ()->optPreprocessed ())
      {
      myMsgFac () ("execPeriodHeadingDdMsg");

      forEachPeriod (impactPer, myProblem ())
         for (theExecPerItr (this, impactPer); ++ theExecPerItr;)
            myMsgFac () ("execPeriodDataDdMsg", impactPer, theExecPerItr ());
      }

a334 28
// Implementation of class ExecPerItr.
//------------------------------------------------------------------------------

WitExecPerItr::WitExecPerItr ():
      myBillEntry_  (NULL),
      impactPeriod_ (-1),
      myIndex_      (-1),
      execPeriod_   (-1)
   {
   }

//------------------------------------------------------------------------------

WitExecPerItr::~WitExecPerItr ()
   {
   }

//------------------------------------------------------------------------------

void WitExecPerItr::operator () (WitBillEntry * theBillEnt, WitPeriod impactPer)
   {
   myBillEntry_  = theBillEnt;
   impactPeriod_ = impactPer;
   myIndex_      = -1;
   execPeriod_   = -1;
   }

//------------------------------------------------------------------------------
@


1.57
log
@Stochastic Implosion
@
text
@d27 1
d76 7
d463 7
@


1.56
log
@Stochastic implosion.
@
text
@d162 1
a162 1
   settingUnpreAttr ();
d174 1
a174 1
   settingUnpreAttr ();
d191 1
a191 1
   settingUnpostAttr ();
d204 1
a204 1
   settingUnpreAttr ();
d423 1
a423 1
   settingUnpreAttr ();
d435 1
a435 1
   settingUnpreAttr ();
d446 1
a446 1
   settingUnpostAttr ();
@


1.55
log
@[disallowed backlog]
@
text
@d162 1
a162 1
   myPreprocessor ()->unpreprocess ();
d174 1
a174 1
   myPreprocessor ()->unpreprocess ();
d191 1
a191 1
   myProblem ()->resetSoln ();
d204 1
a204 1
   myPreprocessor ()->unpreprocess ();
d423 1
a423 1
   myPreprocessor ()->unpreprocess ();
d435 1
a435 1
   myPreprocessor ()->unpreprocess ();
d446 1
a446 1
   myProblem ()->resetSoln ();
@


1.54
log
@Rescinded all changed made since 1/31/07.
@
text
@a262 9
void WitBillEntry::transmitDMPs ()
   {
   WitPreprocessor::receiveDMPs (& WitBillEntry::firstEPIndex_,
                                 & WitBillEntry::execPeriod_,
                                 & WitBillEntry::impactPeriod_);
   }

//------------------------------------------------------------------------------

a484 7
void WitConsEntry::transmitDMPs ()
   {
   WitPreprocessor::receiveDMPs (& WitConsEntry::effConsRate_);
   }

//------------------------------------------------------------------------------

@


1.53
log
@[disallowed backlog]
@
text
@d75 10
a109 4
      impactPeriod_   (),
      firstEPIndex_   (),
      execPeriod_     (),

d117 6
a122 1
      routingShare_   (myProblem (), defRoutingShare ())
d216 2
a217 2
      firstEPIndex_.myValue ()[thePer + 1] - 
      firstEPIndex_.myValue ()[thePer];
d247 1
a247 1
      theIndex = firstEPIndex_.myValue ()[impactPer];
d251 1
a251 1
   execPerFound = (theIndex < firstEPIndex_.myValue ()[impactPer + 1]);
d255 1
a255 1
         execPeriod_.myValue ()[theIndex]:
d263 9
d464 9
d494 7
a504 1
      effConsRate_  (myProblem ()),
d508 2
a509 1
      execPenalty_  (defExecPenalty ())
d567 1
a567 1
      myProblem ()->display ("effConsRateDdMsg", effConsRate ());
@


1.52
log
@App controlled opt implosion.
@
text
@a74 10
void WitBillEntry::unpreprocess ()
   {
   impactPeriod_ = -1;

   firstEPIndex_.clear ();
   execPeriod_  .clear ();
   }

//------------------------------------------------------------------------------

d100 4
d111 1
a111 6
      routingShare_   (myProblem (), defRoutingShare ()),

      impactPeriod_   (myProblem (), -1),

      firstEPIndex_   (),
      execPeriod_     ()
d205 2
a206 2
      firstEPIndex_[thePer + 1] - 
      firstEPIndex_[thePer];
d236 1
a236 1
      theIndex = firstEPIndex_[impactPer];
d240 1
a240 1
   execPerFound = (theIndex < firstEPIndex_[impactPer + 1]);
d244 1
a244 1
         execPeriod_[theIndex]:
a251 9
void WitBillEntry::transmitDMPs ()
   {
   WitPreprocessor::receiveDMPs (& WitBillEntry::firstEPIndex_,
                                 & WitBillEntry::execPeriod_,
                                 & WitBillEntry::impactPeriod_);
   }

//------------------------------------------------------------------------------

a443 9
void WitConsEntry::unpreprocess ()
   {
   effConsRate_ = 0.0;

   WitBillEntry::unpreprocess ();
   }

//------------------------------------------------------------------------------

a464 7
void WitConsEntry::transmitDMPs ()
   {
   WitPreprocessor::receiveDMPs (& WitConsEntry::effConsRate_);
   }

//------------------------------------------------------------------------------

d469 1
d473 1
a473 2
      execPenalty_  (defExecPenalty ()),
      effConsRate_  (myProblem (), 0.0)
d531 1
a531 1
      myProblem ()->display ("effConsRateDdMsg", effConsRate_);
@


1.51
log
@App controlled opt implosion.
@
text
@a25 1
#include <DataAlt.h>
a143 2

   theOpn->preprocAlt ()->incur ();
d159 6
a164 1
   earliestPeriod_ = prepRangedInt (theValue, preprocAlt (), 0, nPeriods ());
d171 6
a176 1
   latestPeriod_ = prepRangedInt (theValue, preprocAlt (), 0, lastPeriod ());
d185 2
d191 3
a193 1
   routingShare_ = prepDblVec (theValue, postprocAlt ());
d200 2
d204 3
a206 1
   offset_ = prepDblVec (theValue, preprocAlt ());
d430 5
a434 1
   consRate_ = prepDblVec (theValue, preprocAlt ());
d444 3
a446 1
   falloutRate_ = prepDouble (theValue, preprocAlt ());
d453 5
a457 1
   execPenalty_ = prepNonNegDouble (theValue, postprocAlt ());
@


1.50
log
@Updated the copyright date on all source files.
@
text
@d315 1
a315 1
   if (myProblem ()->preprocessed ())
d318 1
a318 1
   if (myProblem ()->optPreprocessed ())
d541 1
a541 1
   if (myProblem ()->preprocessed ())
@


1.49
log
@Minor changes.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.48
log
@[multi-thread]
@
text
@d289 2
a294 2
   if (storesOffset ())
      offset_ = theBillEnt->offset_;
@


1.47
log
@Vector PropRt.
@
text
@d20 1
a75 14
void WitBillEntry::loadPre ()
   {
   myPreprocessor ()->loadDataFrom (this, impactPeriod_);
   }

//------------------------------------------------------------------------------

void WitBillEntry::loadOptPre ()
   {
   myPreprocessor ()->loadOptPreDataFrom (this, firstEPIndex_, execPeriod_);
   }

//------------------------------------------------------------------------------

d248 9
a438 9
void WitConsEntry::loadPre ()
   {
   WitBillEntry::loadPre ();

   myPreprocessor ()->loadDataFrom (this, effConsRate_);
   }

//------------------------------------------------------------------------------

d469 7
@


1.46
log
@Pegged critical list.
@
text
@d27 1
a27 1
#include <InVecRA.h>
d187 1
a187 1
void WitBillEntry::setRoutingShare (const WitInVecRA & theValue)
d200 1
a200 1
void WitBillEntry::setOffset (const WitInVecRA & theValue)
d417 1
a417 1
void WitConsEntry::setConsRate (const WitInVecRA & theValue)
@


1.45
log
@Double Precision.
@
text
@d136 1
a136 2
      execPeriod_     (),
      myRtCand_       (NULL)
a260 18
void WitBillEntry::attach (WitRtCand * theRtCand)
   {
   witAssert (myRtCand_ == NULL);

   myRtCand_ = theRtCand;
   }

//------------------------------------------------------------------------------

void WitBillEntry::detachRtCand ()
   {
   witAssert (myRtCand_ != NULL);

   myRtCand_ = NULL;
   }

//------------------------------------------------------------------------------

@


1.44
log
@Double Precision.
@
text
@d91 1
a91 1
   impactPeriod_.setToScalar (-1);
d196 1
a196 1
   routingShare_.convCopy (prepDblVec (theValue, postprocAlt ()));
d205 1
a205 1
   offset_.convCopy (prepDblVec (theValue, preprocAlt ()));
d438 1
a438 1
   consRate_.convCopy (prepDblVec (theValue, preprocAlt ()));
d473 1
a473 1
   effConsRate_.setToScalar (0.0);
@


1.43
log
@Double Precision.
@
text
@d314 1
a314 2

   routingShare_.copy (theBillEnt->routingShare_);
d317 1
a317 1
      offset_.copy (theBillEnt->offset_);
d550 1
a550 2
   consRate_.copy (theConsEnt->consRate_);

@


1.42
log
@Double Precision.
@
text
@a187 13
void WitBillEntry::setRoutingShare (const float * theValue)
   {
   WitPeriod thePer;

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         witAssert (theValue[thePer] >= 1.0 - FLOAT_EPSILON);

   routingShare_.convCopy (prepDblVec (theValue, postprocAlt ()));
   }

//------------------------------------------------------------------------------

a200 9
void WitBillEntry::setOffset (const float * theValue)
   {
   witAssert (storesOffset ());

   offset_.convCopy (prepDblVec (theValue, preprocAlt ()));
   }

//------------------------------------------------------------------------------

a434 7
//------------------------------------------------------------------------------

void WitConsEntry::setConsRate (const float * theValue)
   {
   consRate_.convCopy (prepDblVec (theValue, preprocAlt ()));
   }

@


1.41
log
@Double Precision.
@
text
@d27 1
d201 13
d222 9
d460 7
@


1.40
log
@Double Precision.
@
text
@d195 1
a195 1
   routingShare_.convCopy (prepFloatVec (theValue, postprocAlt ()));
d204 1
a204 1
   offset_.convCopy (prepFloatVec (theValue, preprocAlt ()));
d438 1
a438 1
   consRate_.convCopy (prepFloatVec (theValue, preprocAlt ()));
@


1.39
log
@Double Precision.
@
text
@d53 1
a53 1
const WitFlexVec <double> & WitBillEntry::offset ()
d195 1
a195 1
   convCopy (routingShare_, prepFloatVec (theValue, postprocAlt ()));
d204 1
a204 1
   convCopy (offset_, prepFloatVec (theValue, preprocAlt ()));
d438 1
a438 1
   convCopy (consRate_, prepFloatVec (theValue, preprocAlt ()));
@


1.38
log
@Double Precision.
@
text
@d53 1
a53 1
const WitRealVec & WitBillEntry::offset ()
d195 1
a195 1
   routingShare_.convCopy (prepFloatVec (theValue, postprocAlt ()));
d204 1
a204 1
   offset_.convCopy (prepFloatVec (theValue, preprocAlt ()));
d438 1
a438 1
   consRate_.convCopy (prepFloatVec (theValue, preprocAlt ()));
@


1.37
log
@Double Precision.
@
text
@d53 1
a53 1
const WitFlexVec <float> & WitBillEntry::offset ()
d311 2
a312 2
   earliestPeriod_ = theBillEnt->earliestPeriod ();
   latestPeriod_   = theBillEnt->latestPeriod   ();
d314 1
a314 1
   routingShare_.copy (theBillEnt->routingShare ());
d317 1
a317 1
      offset_.copy (theBillEnt->offset ());
@


1.36
log
@Double Precision.
@
text
@d195 1
a195 1
   routingShare_.copyCVec (prepFloatVec (theValue, postprocAlt ()));
d204 1
a204 1
   offset_.copyCVec (prepFloatVec (theValue, preprocAlt ()));
d438 1
a438 1
   consRate_.copyCVec (prepFloatVec (theValue, preprocAlt ()));
@


1.35
log
@Continued double precision.
@
text
@d195 1
a195 1
   routingShare_.copyCvector (prepFloatVec (theValue, postprocAlt ()));
d204 1
a204 1
   offset_.copyCvector (prepFloatVec (theValue, preprocAlt ()));
d438 1
a438 1
   consRate_.copyCvector (prepFloatVec (theValue, preprocAlt ()));
@


1.34
log
@Continued double precision.
@
text
@d443 1
a443 1
void WitConsEntry::setFalloutRate (StrDbl theValue)
d448 1
a448 1
   falloutRate_ = prepStrDbl (theValue, preprocAlt ());
d453 1
a453 1
void WitConsEntry::setExecPenalty (StrDbl theValue)
d455 1
a455 1
   execPenalty_ = prepNonNegStrDbl (theValue, postprocAlt ());
d533 1
a533 1
   myDataWriter ()->writeStrDbl (
d538 1
a538 1
   myDataWriter ()->writeStrDbl (
@


1.33
log
@Continued double precision.
@
text
@d494 1
a494 1
float WitConsEntry::effCost (WitPeriod thePer)
@


1.32
log
@Continued implementation of PIP.
@
text
@d443 1
a443 1
void WitConsEntry::setFalloutRate (float theValue)
d448 1
a448 1
   falloutRate_ = prepFloat (theValue, preprocAlt ());
d453 1
a453 1
void WitConsEntry::setExecPenalty (float theValue)
d455 1
a455 1
   execPenalty_ = prepNonNegFloat (theValue, postprocAlt ());
d533 1
a533 1
   myDataWriter ()->writeFloat (
d538 1
a538 1
   myDataWriter ()->writeFloat (
@


1.31
log
@Removed a bad function overload.
@
text
@d480 14
@


1.30
log
@Continued implementation of post-implosion pegging.
@
text
@d98 1
a98 1
WitConsEntry * WitConsEntry::myConsEnt ()
@


1.29
log
@Changed the routingShare attributes from scalars to vectors.
@
text
@a27 1
#include <FlexVecI.h>
@


1.28
log
@Continued implementation of proportionate routing.
@
text
@d131 1
a131 1
      routingShare_   (defRoutingShare ()),
d188 1
a188 1
void WitBillEntry::setRoutingShare (float theValue)
d190 2
d193 2
a194 1
      witAssert (theValue >= 1.0 - FLOAT_EPSILON);
d196 1
a196 1
   routingShare_ = prepFloat (theValue, postprocAlt ());
d300 1
a300 1
   myDataWriter ()->writeFloat (
d302 1
a302 1
      routingShare (),
d314 2
a315 1
   routingShare_   = theBillEnt->routingShare   ();
d331 3
a333 2
      latestPeriod (),
      routingShare ());
@


1.27
log
@Continued implementation of proportionate routing.
@
text
@d131 1
a131 1
      expShare_       (defExpShare ()),
d188 1
a188 1
void WitBillEntry::setExpShare (float theValue)
d193 1
a193 1
   expShare_ = prepFloat (theValue, postprocAlt ());
d298 3
a300 3
      "expShare",
      expShare (),
      defExpShare ());
d311 1
a311 1
   expShare_       = theBillEnt->expShare       ();
d328 1
a328 1
      expShare ());
@


1.26
log
@Continued implementation of proportionate routing.
@
text
@d99 1
a99 1
void WitConsEntry::getConsEntry (WitConsEntry * & theConsEnt)
d101 1
a101 1
   theConsEnt = this;
@


1.25
log
@Continued implementation of proportionate routing.
@
text
@d99 7
@


1.24
log
@Continued implementation of proportionate routing.
@
text
@d129 2
a130 1
      execPeriod_     ()
d248 18
@


1.23
log
@Continued implementation of proportionate routing.
@
text
@d124 1
d180 10
d270 5
d284 2
a285 1
     latestPeriod_ = theBillEnt->  latestPeriod ();
d301 2
a302 1
      latestPeriod ());
d516 4
a519 1
   myMsgFac () ("consEntryDdMsg", mappingIndex_, falloutRate_, execPenalty_);
@


1.22
log
@Internal changes.
@
text
@d61 7
d375 7
@


1.21
log
@Internal changes.
@
text
@d101 1
a101 1
   return (thePer >= earliestPeriod ()) && (thePer <= latestPeriod ());
@


1.20
log
@Continued implementation of execPenalties on BOM entries and subs.
@
text
@d92 1
a92 1
WitBoolean WitBillEntry::storesOffset ()
d94 1
a94 1
   return witTRUE;
d99 1
a99 1
WitBoolean WitBillEntry::withinInterval (WitPeriod thePer)
d209 1
a209 1
WitBoolean WitBillEntry::hasNextExecPer (
d214 1
a214 1
   WitBoolean execPerFound;
@


1.19
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d391 1
a391 1
void WitConsEntry::setUsePenalty (float theValue)
d393 1
a393 1
   usePenalty_ = prepNonNegFloat (theValue, postprocAlt ());
d432 1
a432 1
      usePenalty_   (defUsePenalty ()),
d463 3
a465 3
      "usePenalty",
      usePenalty_,
      defUsePenalty ());
d477 1
a477 1
   usePenalty_  = theConsEnt->usePenalty_;
d484 1
a484 1
   myMsgFac () ("consEntryDdMsg", mappingIndex_, falloutRate_, usePenalty_);
@


1.18
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d390 7
d432 1
d454 1
a454 1
      consRate (),
d459 1
a459 1
      falloutRate (),
d461 5
d474 1
a474 1
   consRate_.copy (theConsEnt->consRate ());
d476 2
a477 1
   falloutRate_ = theConsEnt->falloutRate ();
d484 1
a484 1
   myMsgFac () ("consEntryDdMsg", mappingIndex_, falloutRate ());
d486 1
a486 1
   myProblem ()->display ("consRateDdMsg", consRate ());
d489 1
a489 1
      myProblem ()->display ("effConsRateDdMsg", effConsRate ());
@


1.17
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d28 1
@


1.16
log
@Continued implementation of single-source.
@
text
@d20 2
a21 1
#include <ConsEnt.h>
d23 1
@


1.15
log
@Continued implementation of single-source.
@
text
@a414 42
void WitConsEntry::incConsVol (
            WitTVec <double> & consVolArg,
      const WitTVec <float> &  execVolArg)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      if (inEffect (thePer))
         consVolArg[impactPeriod ()[thePer]] += 
            effConsRate ()[thePer] * execVolArg[thePer];
   }

//------------------------------------------------------------------------------

void WitConsEntry::incConsVol (
      WitTVec <double> &         consVolArg,
      const WitFlexVec <float> & execVolArg)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      if (inEffect (thePer))
         consVolArg[impactPeriod ()[thePer]] += 
            effConsRate ()[thePer] * execVolArg[thePer];
   }

//------------------------------------------------------------------------------

void WitConsEntry::incConsVol (
      WitTVec <double> &          consVolArg,
      const WitFlexVec <double> & execVolArg)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      if (inEffect (thePer))
         consVolArg[impactPeriod ()[thePer]] += 
            effConsRate ()[thePer] * execVolArg[thePer];
   }

//------------------------------------------------------------------------------

@


1.14
log
@Continued implementation of single-source.
@
text
@d65 24
d388 18
@


1.13
log
@Continued implementation of single-source.
@
text
@a387 14
            WitTVec <double> & consVolArg,
      const WitTVec <double> & execVolArg)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      if (inEffect (thePer))
         consVolArg[impactPeriod ()[thePer]] += 
            effConsRate ()[thePer] * execVolArg[thePer];
   }

//------------------------------------------------------------------------------

void WitConsEntry::incConsVol (
@


1.12
log
@Preliminary work on single source.
@
text
@d388 14
@


1.11
log
@Continued preliminary work on single source.
@
text
@d51 1
a51 1
const WitFlexVec (float) & WitBillEntry::offset ()
d149 1
a149 1
   offset_ = prepFloatVec (theValue, preprocAlt ());
d237 1
a237 1
      offset_      = theBillEnt->offset ();
d349 1
a349 1
   consRate_ = prepFloatVec (theValue, preprocAlt ());
d389 1
a389 1
      const WitFlexVec (float) & execVolArg)
d403 1
a403 1
      const WitFlexVec (double) & execVolArg)
d458 2
a459 1
   consRate_    = theConsEnt->consRate ();
@


1.10
log
@Continued preliminary work on single source.
@
text
@d21 1
@


1.9
log
@Preliminary work on single source.
@
text
@d373 2
a374 2
            WitTVec (double) & consVolArg,
      const WitTVec (float) &  execVolArg)
d387 1
a387 1
      WitTVec (double) &         consVolArg,
d401 1
a401 1
      WitTVec (double) &          consVolArg,
@


1.8
log
@Continued implementation of object iteration.
@
text
@d273 1
a273 1
// Implements WitBillEntry::reLocalIndex (const WitList (BillEntryClass) &)
d279 1
a279 1
void WitBillEntry::reLocalIndex (const WitList (BillEntryClass) & theList)     \
@


1.7
log
@Began implementation of object iteration.
@
text
@a29 21
WitBillEntry::WitBillEntry (WitPart * thePart, int theLocalIndex):

      WitDelComp      (thePart->myCompMgr ()),

      mappingIndex_   (myCompMgr ()->nBillEntries ()),
      myPart_         (thePart),
      localIndex_     (theLocalIndex),

      offset_         (myProblem (), defOffset ()),
      earliestPeriod_ (defEarliestPeriod ()),
      latestPeriod_   (defLatestPeriod (myProblem ())),

      impactPeriod_   (myProblem (), -1),

      firstEPIndex_   (),
      execPeriod_     ()
   {
   }

//------------------------------------------------------------------------------

d78 21
a337 13
WitConsEntry::WitConsEntry (WitPart * thePart, int theLocalIndex):

      WitBillEntry  (thePart, theLocalIndex),

      mappingIndex_ (myCompMgr ()->nConsEntries ()),
      consRate_     (myProblem (), defConsRate ()),
      falloutRate_  (defFalloutRate ()),
      effConsRate_  (myProblem (), 0.0)
   {
   }

//------------------------------------------------------------------------------

a364 7
WitBoolean WitConsEntry::isaSubEntry ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

d410 13
@


1.6
log
@Coarse selection splitting.
@
text
@d24 1
d53 14
@


1.5
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d106 1
a106 1
void WitBillEntry::setBillEntryIndex ()
d327 1
d419 9
d457 1
a457 1
   myMsgFac () ("consEntryDdMsg", falloutRate ());
@


1.4
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d327 1
a327 1
      usageRate_    (defUsageRate ()),
d329 1
a329 2

      effUsageRate_ (0.0)
d343 1
a343 1
void WitConsEntry::setUsageRate (float theValue)
d345 1
a345 1
   usageRate_ = prepFloat (theValue, preprocAlt ());
d369 1
a369 1
float WitConsEntry::effCost ()
d371 1
a371 1
   return effUsageRate () * myPart ()->unitCost ();
d385 1
a385 1
            effUsageRate () * execVolArg[thePer];
d399 1
a399 1
            effUsageRate () * execVolArg[thePer];
d413 1
a413 1
            effUsageRate () * execVolArg[thePer];
d422 4
a425 4
   myDataWriter ()->writeFloat (
      "usageRate",
      usageRate (),
      defUsageRate ());
d439 1
a439 1
   usageRate_   = theConsEnt->usageRate ();
d447 3
a449 1
   myMsgFac () ("consEntryDdMsg", usageRate (), falloutRate ());
d452 1
a452 1
      myMsgFac () ("consEntryPreprocDdMsg", effUsageRate ());
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d392 16
a407 2
      WitTVec (double) & consVolArg,
      const WitFlexVec (float) &  execVolArg)
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d65 1
a65 1
   return theProblem->nPeriods () - 1;
d124 1
a124 1
   latestPeriod_ = prepRangedInt (theValue, preprocAlt (), 0, nPeriods () - 1);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.71;
access;
symbols
	sce_4_05_20040511:1.69
	sce_4_00_20040201:1.69
	nextGenBranch:1.66.0.2
	nextGenRoot:1.66
	sce_3_30_20030627:1.66
	EndRw-branch:1.56.0.4
	Root-of-EndRw:1.56
	rwToStl:1.56.0.2
	latest_sce_3_10_20010924:1.47.0.2
	sce_3_10_20010924:1.47
	latest_sce_3_00_20010601:1.31.0.2
	sce_3_00_20010601:1.31
	latest_sce_2_31_20010308:1.14.0.2
	sce_2_31_20010308:1.14
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2004.12.10.22.09.03;	author rjw;	state dead;
branches;
next	1.70;

1.70
date	2004.12.10.16.49.43;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2003.11.11.18.29.13;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2003.09.26.16.06.02;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2003.09.25.20.44.43;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2003.04.29.14.27.46;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2003.04.14.23.31.39;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2003.04.11.19.08.26;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2003.04.01.20.34.26;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2003.03.19.16.48.18;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2003.02.13.23.06.29;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2003.02.07.23.29.08;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2003.01.29.19.16.46;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.02.23.40.42;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.01.02.22.18.31;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2002.09.04.19.14.55;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.24.23.00.03;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2002.05.08.21.58.54;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.22.14.32.09;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.18.14.02.35;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2002.04.12.21.02.00;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2002.03.22.21.23.21;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.19.16.17.10;	author bobw;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.28.00.12.58;	author bobw;	state Exp;
branches;
next	1.47;

1.47
date	2001.09.19.18.50.58;	author bobw;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.17.18.56.28;	author bobw;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.04.15.44.37;	author bobw;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.30.20.29.23;	author bobw;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.24.22.03.20;	author bobw;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.23.21.13.53;	author bobw;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.22.20.41.48;	author bobw;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.21.17.31.45;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.25.16.08.16;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.18.21.44.44;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.19.14.42.52;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.15.20.53.35;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.13.20.30.23;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.13.15.02.50;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.11.19.29.11;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.01.19.23.33;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.30.21.16.49;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.29.22.11.26;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.25.22.59.12;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.25.14.53.24;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.17.15.11.15;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.10.22.31.12;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.10.17.58.18;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.08.21.35.43;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.03.15.28.38;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.30.21.29.41;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.06.19.22.09;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.03.19.23.04;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.23.19.43.24;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.21.21.55.46;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.20.21.03.59;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.12.19.48.07;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.08.16.37.05;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.01.16.24.43;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.31.23.17.45;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.29.19.26.10;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.27.00.24.38;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.26.21.46.01;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.24.20.05.56;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.20.00.44.18;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.11.16.35.09;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.28.22.13.37;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.06.19.58.38;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.42;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.14.20.27.31;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.09;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.24;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.24;	author wit;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Low-Pri Prop-Rt.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "MeMgr.C"
//
// Contains the implementation of class MeMgr.
//------------------------------------------------------------------------------

#include <MeMgr.h>
#include <MeDir.h>
#include <MeCand.h>
#include <MePt.h>
#include <SplitPt.h>
#include <Selector.h>
#include <Global.h>
#include <Material.h>
#include <Opn.h>
#include <BopEntry.h>
#include <MsgFac.h>
#include <PtrTVec.h>
#include <MapIdxI.h>

//------------------------------------------------------------------------------
// Implementation of class MeMgr.
//------------------------------------------------------------------------------

inline bool WitMeMgr::hasMeCoordPts (WitBopEntry * theBopEnt)
   {
   return myMeCoordPts_.myPtrTVecAt (theBopEnt).isAllocated ();
   }

//------------------------------------------------------------------------------

WitMeMgr::WitMeMgr (WitSelector * theSelector):
      WitSelMgr       (theSelector),

      myMeCands_      (myProblem ()),
      myMeDirForNstn_ (NULL),
      myMeDirForAsap_ (NULL),
      myMeCoordPts_   (),
      initDirIsAsap_  (false)
   {
   WitMeCand * theMeCand;
   WitPeriod   execPer;

   myMsgFac () ("multiExecMsg");

   theMeCand = NULL;

   forEachPeriod (execPer, myProblem ())
      {
      theMeCand = new WitMeCand (execPer, theMeCand, this);

      myMeCands_.push (theMeCand);
      }

   myMeCands_.reverse ();

   myMeDirForNstn_ = new WitNstnMeDir (this);
   myMeDirForAsap_ = new WitAsapMeDir (this);
   
   myMeCoordPts_.allocate1D (myProblem ());

   buildMeCoordPts ();

   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("twmeMsg");
   }

//------------------------------------------------------------------------------

WitMeMgr::~WitMeMgr ()
   {
   WitBopEntry *  theBopEnt;
   WitPeriod      expPer;
   WitMeCoordPt * theMeCoordPt;

   forEachBopEntry (theBopEnt, myProblem ())
      if (hasMeCoordPts (theBopEnt))
         {
         expPer = -1;

         while (findNextMeCoordPt (theBopEnt, expPer, theMeCoordPt))
            delete theMeCoordPt;
         }

   delete myMeDirForAsap_;
   delete myMeDirForNstn_;

   deleteContents (myMeCands_);
   }

//------------------------------------------------------------------------------

bool WitMeMgr::instNeededFor (WitProblem * theProblem)
   {
   return theProblem->myGlobalComp ()->multiExecNeeded ();
   }

//------------------------------------------------------------------------------

void WitMeMgr::setInitDirIsAsap (bool theValue)
   {
   initDirIsAsap_ = theValue;
   }

//------------------------------------------------------------------------------

WitPeriod WitMeMgr::selExecPer (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitMePt * theMePt;

   theMePt = myMePtWithSel (theBopEnt, expPer);

   return
      (theMePt != NULL)?
         theMePt->selMeCand ()->myExecPer ():
         theBopEnt ->expExecPeriod ()[expPer];
   }

//------------------------------------------------------------------------------

void WitMeMgr::print ()
   {
   WitBopEntry *  theBopEnt;
   WitPeriod      expPer;
   WitMeCoordPt * theMeCoordPt;

   fprintf (msgFile (),
      "\n"
      "Multi-Exec Selection Points:\n");

   forEachBopEntry (theBopEnt, myProblem ())
      if (hasMeCoordPts (theBopEnt))
         {
         expPer = -1;

         while (findNextMeCoordPt (theBopEnt, expPer, theMeCoordPt))
            {
            theMeCoordPt->myMePtForNstn ()->print ();

            if (myGlobalComp ()->twoWayMultiExec ())
               theMeCoordPt->myMePtForAsap ()->print ();
            }
         }

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

bool WitMeMgr::selSplitNeeded ()
   {
   WitBopEntry * theBopEnt;

   if (myGlobalComp ()->selSplit ())
      return true;

   if (myGlobalComp ()->nonMrSelSplit ())
      return true;

   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         if (theBopEnt->meSelSplit ())
            return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::selIsSplit (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitMePt * theMePt;

   if (not selSplit ())
      return false;

   theMePt = myMePtWithSel (theBopEnt, expPer);

   if (theMePt == NULL)
      return false;

   return theMePt->isSplit ();
   }

//------------------------------------------------------------------------------

void WitMeMgr::defineSplit (
      WitBopEntry *    theBopEnt,
      WitPeriod        expPer,
      double           expVol,
      WitPerDblStack & theSplitPairs,
      bool &           lastUnbdd)
   {
   WitSplitPt *       theSplitPt;
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitPeriod          execPer;
   WitFixedPer *      theFixedPer;

   witAssert (selIsSplit (theBopEnt, expPer));

   theSplitPt = myMePtWithSel (theBopEnt, expPer)->mySplitPt ();

   theSplitPt->defineSplit (expVol, theAbsSplitPairs, lastUnbdd);

   theSplitPairs.clear ();

   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      execPer     = theSelCand->myMeCand ()->myExecPer ();

      theFixedPer = mySelector ()->myFixedPer ()[execPer];

      theSplitPairs.push (theFixedPer, splitVol);
      }
   }

//------------------------------------------------------------------------------

void WitMeMgr::recBopEntExecPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod     execPer, 
      double        expVol)
   {
   WitPeriod      expPer;
   WitMeCoordPt * theMeCoordPt;
   WitMeDir *     theMeDir;

   witAssert (selSplit ());

   if (not hasMeCoordPts (theBopEnt))
      return;

   expPer       = theBopEnt->impactPeriod ()[execPer];

   theMeCoordPt = myMeCoordPts_.myPtrAt (theBopEnt, expPer);

   if (theMeCoordPt == NULL)
      return;

   theMeDir = chooseMeDir (theBopEnt->myPart ());

   theMeDir->myMePt (theMeCoordPt)->recordFlowSS (expVol);
   }

//------------------------------------------------------------------------------

WitSelPt * WitMeMgr::mySelPtForAlt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
   {
   WitPeriod expPer;

   expPer = theBopEnt->impactPeriod ()[execPer];

   return myMePtWithSel (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

bool WitMeMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

const char * WitMeMgr::selCaseName ()
   {
   return "Multi-Exec";
   }

//------------------------------------------------------------------------------

void WitMeMgr::buildMeCoordPts ()
   {
   WitPtrTVec <WitMeCand>  firstMeCand;
   WitPtrTVec <WitMeCand>  lastMeCand;
   bool                    multiExecFound;
   WitBopEntry *           theBopEnt;
   WitObjStItr <WitMeCand> theMeCandItr;
   WitPeriod               execPer;
   WitPeriod               expPer;

   firstMeCand.allocate (myProblem ());
   lastMeCand .allocate (myProblem ());

   multiExecFound = false;

   forEachBopEntry (theBopEnt, myProblem ())
      {  
      if (not theBopEnt->expAllowed ())
         continue;

      theMeCandItr.attachTo (myMeCands_);

      while (theMeCandItr.advance ())
         {
         execPer = theMeCandItr->myExecPer ();

         if (not theBopEnt->execPerOKForExp (execPer))
            continue;

         expPer = theBopEnt->impactPeriod ()[execPer];

         if (firstMeCand[expPer] == NULL)
            firstMeCand [expPer] = theMeCandItr.myObject ();
         else
            multiExecFound       = true;

         lastMeCand [expPer]     = theMeCandItr.myObject ();
         }

      if (multiExecFound)
         {
         myMeCoordPts_.myPtrTVecAt (theBopEnt).allocate (myProblem ());

         forEachPeriod (expPer, myProblem ())
            if (firstMeCand[expPer] != lastMeCand[expPer])
               myMeCoordPts_.myPtrAt (theBopEnt, expPer) = 
                  new WitMeCoordPt (
                     theBopEnt,
                     firstMeCand[expPer],
                     lastMeCand [expPer],
                     this);
         }
            
      firstMeCand.setToNull ();
      lastMeCand .setToNull ();

      multiExecFound = false;
      }
   }

//------------------------------------------------------------------------------

WitMePt * WitMeMgr::myMePtWithSel (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitMeCoordPt * theMeCoordPt;
   WitMeDir *     theMeDir;
   WitMePt *      theMePt;

   if (not hasMeCoordPts (theBopEnt))
      return NULL;

   theMeCoordPt = myMeCoordPts_.myPtrAt (theBopEnt, expPer);

   if (theMeCoordPt == NULL)
      return NULL;

   theMeDir = chooseMeDir (theBopEnt->myPart ());

   theMePt  = theMeDir->myMePt (theMeCoordPt);

   return
      (theMePt->selMeCand () != NULL)?
         theMePt:
         NULL;
   }

//------------------------------------------------------------------------------

WitMeDir * WitMeMgr::chooseMeDir (WitPart * thePart)
   {
   WitMaterial * theMat;

   if (not myGlobalComp ()->twoWayMultiExec ())
      return myMeDirForNstn_;

   if (initDirIsAsap_)
      return myMeDirForAsap_;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (theMat->buildAsap ())
         return myMeDirForAsap_;

   return myMeDirForNstn_;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::findNextMeCoordPt (
      WitBopEntry *    theBopEnt,
      WitPeriod &      expPer,
      WitMeCoordPt * & theMeCoordPt)
   {
   while (++ expPer < nPeriods ())
      {
      theMeCoordPt = myMeCoordPts_.myPtrAt (theBopEnt, expPer);
   
      if (theMeCoordPt != NULL)
         return true;
      }

   return false;
   }
@


1.70
log
@Low-Pri Prop-Rt.
@
text
@@


1.69
log
@Removed a bad function overload.
@
text
@a129 36
WitSelPt * WitMeMgr::mySelPtForAlt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
   {
   WitPeriod expPer;

   expPer = theBopEnt->impactPeriod ()[execPer];

   return myMePtWithSel (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

bool WitMeMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

const char * WitMeMgr::selCaseName ()
   {
   return "Multi-Exec";
   }

//------------------------------------------------------------------------------

d258 36
@


1.68
log
@Corrected a file inclusion AIX porting bug.
@
text
@d392 1
a392 1
   theMat = thePart->myMat ();
@


1.67
log
@Continued implementation of post-implosion pegging.
@
text
@d28 1
@


1.66
log
@Continued implementation of proportionate routing.
@
text
@a27 1
#include <PtrSchedI.h>
@


1.65
log
@Continued implementation of proportionate routing.
@
text
@a273 1
   WitMePt *      theMePt;
d289 1
a289 3
   theMePt  = theMeDir->myMePt (theMeCoordPt);

   mySelector ()->recordFlowSS (theMePt, expVol);
@


1.64
log
@Continued implementation of proportionate routing.
@
text
@d20 1
d232 13
a244 6
void WitMeMgr::startSplitExp (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol)
   {
   WitMePt * theMePt;
d248 1
a248 1
   theMePt = myMePtWithSel (theBopEnt, expPer);
d250 1
a250 2
   startSplitExpAbs (theMePt, expVol);
   }
d252 1
a252 1
//------------------------------------------------------------------------------
d254 3
a256 4
bool WitMeMgr::findNextSplit (WitPeriod & execPer, double & splitExpVol)
   {
   WitSelCand * theSelCand;
   bool         splitFound;
d258 1
a258 1
   witAssert (selSplit ());
d260 2
a261 8
   splitFound = findNextSplitAbs (theSelCand, splitExpVol);

   execPer    =
      splitFound?
         theSelCand->myMeCand ()->myExecPer ():
         -1;

   return splitFound;
@


1.63
log
@Continued implementation of proportionate routing.
@
text
@d20 1
d214 1
a214 4
void WitMeMgr::startSplitExp (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol)
d218 2
a219 1
   witAssert (selIsSplit (theBopEnt, expPer));
d223 4
a226 1
   startSplitExpAbs (theMePt, expVol);
d231 4
a234 1
bool WitMeMgr::selIsSplit (WitBopEntry * theBopEnt, WitPeriod expPer)
d238 1
a238 2
   if (not selSplit ())
      return false;
d242 1
a242 4
   if (theMePt == NULL)
      return false;

   return theMePt->isSplit ();
d292 1
a292 1
   recordFlowSS (theMePt, expVol);
@


1.62
log
@Continued implementation of proportionate routing.
@
text
@d213 4
a216 1
bool WitMeMgr::selIsSplit (WitBopEntry * theBopEnt, WitPeriod expPer)
d220 1
a220 2
   if (not selSplit ())
      return false;
d224 1
a224 4
   if (theMePt == NULL)
      return false;

   return theMePt->isSplit ();
d229 1
a229 4
void WitMeMgr::startSplitExp (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol)
d233 2
a234 1
   witAssert (selIsSplit (theBopEnt, expPer));
d238 4
a241 1
   startSplitExpAbs (theMePt, expVol);
@


1.61
log
@Continued implementation of proportionate routing.
@
text
@d328 1
a328 1
            firstMeCand [expPer] = theMeCandItr ();
d332 1
a332 1
         lastMeCand [expPer]     = theMeCandItr ();
d394 1
a394 1
   thePart->getMaterial (theMat);
@


1.60
log
@Continued implementation of proportionate routing.
@
text
@d302 1
a302 2
   WitObjStItr <WitMeCand> theItr;
   WitMeCand *             theMeCand;
d316 1
a316 1
      theItr.attachTo (myMeCands_);
d318 1
a318 1
      while (theItr.advance (theMeCand))
d320 1
a320 1
         execPer = theMeCand->myExecPer ();
d328 1
a328 1
            firstMeCand [expPer] = theMeCand;
d332 1
a332 1
         lastMeCand [expPer]     = theMeCand;
@


1.59
log
@Continued implementation of Proportionate Routing.
@
text
@d128 1
a128 1
WitSelPt * WitMeMgr::mySelPt (
d134 1
a134 1
   WitPeriod prodPer;
d136 1
a136 1
   prodPer = theBopEnt->impactPeriod ()[execPer];
d138 1
a138 1
   return myMePtWithSel (theBopEnt, prodPer);
@


1.58
log
@Internal changes.
@
text
@d100 7
@


1.57
log
@Internal changes.
@
text
@d210 1
a210 1
   if (! selSplit ())
d270 1
a270 1
   if (! hasMeCoordPts (theBopEnt))
d307 1
a307 1
      if (! theBopEnt->expAllowed ())
d316 1
a316 1
         if (! theBopEnt->execPerOKForExp (execPer))
d358 1
a358 1
   if (! hasMeCoordPts (theBopEnt))
d382 1
a382 1
   if (! myGlobalComp ()->twoWayMultiExec ())
@


1.56
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d32 1
a32 1
inline WitBoolean WitMeMgr::hasMeCoordPts (WitBopEntry * theBopEnt)
d46 1
a46 1
      initDirIsAsap_  (witFALSE)
d100 1
a100 1
void WitMeMgr::setInitDirIsAsap (WitBoolean theValue)
d136 1
a136 1
WitBoolean WitMeMgr::validForNetting ()
d138 1
a138 1
   return witTRUE;
d143 1
a143 1
WitBoolean WitMeMgr::validForExecBounds ()
d145 1
a145 1
   return witTRUE;
d186 1
a186 1
WitBoolean WitMeMgr::selSplitNeeded ()
d191 1
a191 1
      return witTRUE;
d194 1
a194 1
      return witTRUE;
d199 1
a199 1
            return witTRUE;
d201 1
a201 1
   return witFALSE;
d206 1
a206 1
WitBoolean WitMeMgr::selIsSplit (WitBopEntry * theBopEnt, WitPeriod expPer)
d211 1
a211 1
      return witFALSE;
d216 1
a216 1
      return witFALSE;
d239 1
a239 1
WitBoolean WitMeMgr::findNextSplit (WitPeriod & execPer, double & splitExpVol)
d242 1
a242 1
   WitBoolean   splitFound;
d293 1
a293 1
   WitBoolean              multiExecFound;
d303 1
a303 1
   multiExecFound = witFALSE;
d324 1
a324 1
            multiExecFound       = witTRUE;
d346 1
a346 1
      multiExecFound = witFALSE;
d399 1
a399 1
WitBoolean WitMeMgr::findNextMeCoordPt (
d409 1
a409 1
         return witTRUE;
d412 1
a412 1
   return witFALSE;
@


1.55
log
@Continued implementation of single-source.
@
text
@d26 1
@


1.54
log
@Preliminary work on single source.
@
text
@d124 1
a124 2
      WitPeriod,
      WitBoolean &  resFound)
a126 1
   WitMePt * theMePt;
d130 1
a130 8
   theMePt = myMePtWithSel (theBopEnt, prodPer);

   if (theMePt != NULL)
      resFound = theMePt->hasResAlt ();
   else
      resFound = witFALSE;

   return theMePt;
@


1.53
log
@Continued implementation of object iteration.
@
text
@d351 3
a353 2
      firstMeCand    = NULL;
      lastMeCand     = NULL;
@


1.52
log
@Began implementation of object iteration.
@
text
@d395 1
a395 1
   theMat = thePart->myMat ();
@


1.51
log
@Continued implementation of sel-split for pen-exec.
@
text
@d20 3
d24 1
@


1.50
log
@Continued implementation of sel-split for pen-exec.
@
text
@a19 1
#include <Splitter.h>
d288 1
a288 1
   mySplitter ()->recordFlow (theMePt, expVol);
@


1.49
log
@Initial implementation of selection splitting for multi-route.
@
text
@d141 7
@


1.48
log
@Continued development of Selective Stock Reallocation.
@
text
@d188 6
@


1.47
log
@Continued implementation of selective stock reallocation.
@
text
@d379 3
a381 1
   if (thePart->getMyMaterial (theMat))
@


1.46
log
@Continued implmentation of selective stock reallocation.
@
text
@d18 1
d379 1
a379 1
   if (thePart->isaMaterial (theMat))
@


1.45
log
@Continuing implementation of selective stock reallocation.
@
text
@d241 1
a241 1
         WitMeCand::safeCast (theSelCand)->myExecPer ():
@


1.44
log
@Refactoring for constrained stock reallocation.
@
text
@a279 6
void WitMeMgr::postSplitCommit ()
   {
   }

//------------------------------------------------------------------------------

@


1.43
log
@Refactoring for constrained stock reallocation.
@
text
@d18 1
a18 1
#include <MeSelPt.h>
d104 1
a104 1
   WitMeSelPt * theMeSelPt;
d106 1
a106 1
   theMeSelPt = myMeSelPtWithSel (theBopEnt, expPer);
d109 2
a110 2
      (theMeSelPt != NULL)?
         theMeSelPt->selMeCand ()->myExecPer ():
d123 2
a124 2
   WitPeriod    prodPer;
   WitMeSelPt * theMeSelPt;
d126 1
a126 1
   prodPer    = theBopEnt->impactPeriod ()[execPer];
d128 1
a128 1
   theMeSelPt = myMeSelPtWithSel (theBopEnt, prodPer);
d130 2
a131 2
   if (theMeSelPt != NULL)
      resFound = theMeSelPt->hasResAlt ();
d135 1
a135 1
   return theMeSelPt;
d171 1
a171 1
            theMeCoordPt->myMeSelPtForNstn ()->print ();
d174 1
a174 1
               theMeCoordPt->myMeSelPtForAsap ()->print ();
d199 1
a199 1
   WitMeSelPt * theMeSelPt;
d204 1
a204 1
   theMeSelPt = myMeSelPtWithSel (theBopEnt, expPer);
d206 1
a206 1
   if (theMeSelPt == NULL)
d209 1
a209 1
   return theMeSelPt->isSplit ();
d219 1
a219 1
   WitMeSelPt * theMeSelPt;
d223 1
a223 1
   theMeSelPt = myMeSelPtWithSel (theBopEnt, expPer);
d225 1
a225 1
   startSplitExpAbs (theMeSelPt, expVol);
d257 1
a257 1
   WitMeSelPt *   theMeSelPt;
d271 1
a271 1
   theMeDir   = chooseMeDir (theBopEnt->myPart ());
d273 1
a273 1
   theMeSelPt = theMeDir->myMeSelPt (theMeCoordPt);
d275 1
a275 1
   mySplitter ()->recordFlow (theMeSelPt, expVol);
d348 1
a348 3
WitMeSelPt * WitMeMgr::myMeSelPtWithSel (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer)
d352 1
a352 1
   WitMeSelPt *   theMeSelPt;
d362 1
a362 1
   theMeDir   = chooseMeDir (theBopEnt->myPart ());
d364 1
a364 1
   theMeSelPt = theMeDir->myMeSelPt (theMeCoordPt);
d367 2
a368 2
      (theMeSelPt->selMeCand () != NULL)?
         theMeSelPt:
@


1.42
log
@Refactoring for constrained stock reallocation.
@
text
@d41 1
a41 2
      initDirIsAsap_  (witFALSE),
      totExpVol_      (myProblem ())
a248 12
void WitMeMgr::adjustSplitBound (
      WitBopEntry * theBopEnt, 
      WitPeriod     execPer, 
      double &      splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExpVol_ (theBopEnt, execPer);
   }

//------------------------------------------------------------------------------

a274 2
   totExpVol_.incCell (theBopEnt, execPer, expVol);

a279 9
void WitMeMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExpVol_.clear ();
   }

//------------------------------------------------------------------------------

a408 15
   }

//------------------------------------------------------------------------------

void WitMeMgr::setUpDerivedSS ()
   {
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   totExpVol_ .allocate1D ();
   
   forEachBopEntry (theBopEnt, myProblem ())
      if (hasMeCoordPts (theBopEnt))
         totExpVol_ .allocateRow (theBopEnt);
@


1.41
log
@Refactoring for constrained stock reallocation.
@
text
@a154 11
void WitMeMgr::prtSelCandID (WitTlObj * theTlObj)
   {
   WitFixedPer * theFixedPer;

   theFixedPer = (WitFixedPer *) theTlObj;

   fprintf (msgFile (), "   Exec Per:    %d\n", theFixedPer->myPeriod ());
   }

//------------------------------------------------------------------------------

d233 2
a234 2
   WitTlObj * theTlObj;
   WitBoolean splitFound;
d238 1
a238 3
   execPer    = -1;

   splitFound = findNextSplitAbs (theTlObj, splitExpVol);
d240 4
a243 2
   if (splitFound)
      execPer = ((WitFixedPer *) theTlObj)->myPeriod ();
@


1.40
log
@Refactoring for constrained stock reallocation.
@
text
@a18 1
#include <MeCand.h>
@


1.39
log
@Initial implementation of pegging.
@
text
@d20 1
d22 1
a22 1
#include <Splitter.h>
d28 7
d38 1
a38 1
      myMeCand_       (myProblem ()),
d45 2
a46 1
   WitPeriod execPer;
d50 2
d53 7
a59 1
      myMeCand_[execPer] = new WitMeCand (execPer, this);
a78 1
   WitPeriod      execPer;
d92 1
a92 2
   forEachPeriod (execPer, myProblem ())
      delete myMeCand_[execPer];
d112 1
a112 1
         theMeSelPt->selExecPer ():
d324 8
a331 6
   WitTVec (WitPeriod) firstExecPer;
   WitTVec (WitPeriod)  lastExecPer;
   WitBoolean          multiExecFound;
   WitBopEntry *       theBopEnt;
   WitPeriod           execPer;
   WitPeriod           expPer;
d333 2
a334 2
   firstExecPer.allocate (myProblem (), -1);
    lastExecPer.allocate (myProblem (), -1);
d339 19
a357 11
      if (theBopEnt->expAllowed ())
         {  
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->execPerOKForExp (execPer))
               {  
               expPer = theBopEnt->impactPeriod ()[execPer];

               if (firstExecPer[expPer] == -1)
                  firstExecPer[expPer] = execPer;
               else
                  multiExecFound       = witTRUE;
d359 2
a360 2
               lastExecPer[expPer]     = execPer;
               }
d362 3
a364 3
         if (multiExecFound)
            {
            myMeCoordPts_.myPtrTVecAt (theBopEnt).allocate (myProblem ());
d366 9
a374 9
            forEachPeriod (expPer, myProblem ())
               if (firstExecPer[expPer] < lastExecPer[expPer])
                  myMeCoordPts_.myPtrAt (theBopEnt, expPer) = 
                     new WitMeCoordPt (
                        theBopEnt,
                        firstExecPer[expPer],
                        lastExecPer[expPer],
                        this);
            }
d376 4
a379 4
         firstExecPer   = -1;
          lastExecPer   = -1;
         multiExecFound = witFALSE;
         }
d405 1
a405 1
      (theMeSelPt->selExecPer () >= 0)?
@


1.38
log
@Implemented class template PtrSched <*, *>.
@
text
@d28 1
a28 1
      WitSelMgr         (theSelector),
d30 6
a35 6
      myMeCand_         (myProblem ()),
      myMeDirForNstn_   (NULL),
      myMeDirForAsap_   (NULL),
      myMeCoordPtSched_ (),
      initDirIsAsap_    (witFALSE),
      totExpVol_        (myProblem ())
d47 1
a47 1
   myMeCoordPtSched_.allocate1D (myProblem ());
d276 1
a276 1
   theMeCoordPt = myMeCoordPtSched_.ptrAt (theBopEnt, expPer);
d339 1
a339 1
            myMeCoordPtSched_.vecAt (theBopEnt).allocate (myProblem ());
d343 1
a343 1
                  myMeCoordPtSched_.ptrAt (theBopEnt, expPer) = 
d370 1
a370 1
   theMeCoordPt = myMeCoordPtSched_.ptrAt (theBopEnt, expPer);
d413 1
a413 1
      theMeCoordPt = myMeCoordPtSched_.ptrAt (theBopEnt, expPer);
@


1.37
log
@Minor changes.
@
text
@d28 1
a28 1
      WitSelMgr       (theSelector),
d30 6
a35 6
      myMeCand_       (myProblem ()),
      myMeDirForNstn_ (NULL),
      myMeDirForAsap_ (NULL),
      myMeCoordPtTl_  (),
      initDirIsAsap_  (witFALSE),
      totExpVol_      (myProblem ())
d47 1
a47 1
   myMeCoordPtTl_.allocate1D (myProblem ());
d276 1
a276 1
   theMeCoordPt = myMeCoordPt (theBopEnt, expPer);
d339 1
a339 1
            myMeCoordPtTl_ (theBopEnt).allocate (myProblem (), NULL);
d343 1
a343 1
                  myMeCoordPt (theBopEnt, expPer) = 
d370 1
a370 1
   theMeCoordPt = myMeCoordPt (theBopEnt, expPer);
d413 1
a413 1
      theMeCoordPt = myMeCoordPt (theBopEnt, expPer);
@


1.36
log
@Removed indexes from production multi-route.
Other refactoring.
@
text
@a91 1
   WitPeriod    execPer;
@


1.35
log
@Fixed bug in two-way multi-exec:
   NSTN and ASAP multi-exec collisions were not being adequately detected.
@
text
@d19 1
d30 1
d37 2
d41 3
d62 1
d75 3
@


1.34
log
@Refactoring of Multi-Exec: Removed alt-indices.
@
text
@d37 2
a38 2
   myMeDirForNstn_ = new WitNstnMeDir;
   myMeDirForAsap_ = new WitAsapMeDir;
@


1.33
log
@Refactoring.
@
text
@a34 6
   WitOperation * theOpn;
   WitPeriod      expPer;

   WitTVec (int)                      nExecPers;
   WitPtrTVec (WitVector (WitPeriod)) expExecPer;

a39 2
   nExecPers     .allocate   (myProblem (), 0);
   expExecPer    .allocate   (myProblem ());
d42 1
a42 10
   forEachPeriod (expPer, myProblem ())
      expExecPer [expPer] = new WitVector (WitPeriod) (nPeriods (), -1);

   forEachOperation (theOpn, myProblem ())
      buildMeCoordPts (theOpn, nExecPers, expExecPer);

   forEachPeriod (expPer, myProblem ())
      delete expExecPer [expPer];

   expExecPer.clear ();
d297 1
a297 4
void WitMeMgr::buildMeCoordPts (
      WitOperation *                       theOpn,
      WitTVec (int) &                      nExecPers,
      WitPtrTVec (WitVector (WitPeriod)) & expExecPer)
d299 6
a304 2
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
d306 2
a307 15
  forEachEl (theBopEnt, theOpn->bop ())
      if (findExecPers (theBopEnt, nExecPers, expExecPer))
         {        
         myMeCoordPtTl_ (theBopEnt).allocate (myProblem (), NULL);
      
         forEachPeriod (expPer, myProblem ())
            if (nExecPers[expPer] > 1)
               myMeCoordPt (theBopEnt, expPer) = 
                  new WitMeCoordPt (
                     theBopEnt,
                     nExecPers  [expPer], 
                     expExecPer (expPer), 
                     this);
         }
   }
d309 1
a309 1
//------------------------------------------------------------------------------
d311 12
a322 8
WitBoolean WitMeMgr::findExecPers (
      WitBopEntry *                        theBopEnt,
      WitTVec (int) &                      nExecPers,
      WitPtrTVec (WitVector (WitPeriod)) & expExecPer)
   {
   WitBoolean hasMultiExec;
   WitPeriod  execPer;
   WitPeriod  expPer;
d324 2
a325 2
   if (! theBopEnt->expAllowed ())
      return witFALSE;
d327 3
a329 11
   hasMultiExec = witFALSE;
   nExecPers    = 0;
   
   forEachPeriod (execPer, myProblem ())
      {
      if (! theBopEnt->execPerOKForExp (execPer))
         continue;
   
      expPer = theBopEnt->impactPeriod ()[execPer];
   
      expExecPer (expPer)[nExecPers[expPer]] = execPer;
d331 14
a344 7
      nExecPers[expPer] ++;
   
      if (nExecPers[expPer] == 2)
         hasMultiExec = witTRUE;
      }

   return hasMultiExec;
d370 1
a370 1
      theMeSelPt->hasSelExecPer ()?
@


1.32
log
@Continued development of selection splitting for multi=exec.
@
text
@d95 1
a95 1
WitPeriod WitMeMgr::selExecPeriod (WitBopEntry * theBopEnt, WitPeriod expPer)
@


1.31
log
@Refactoring for sel-split for multi-exec.
@
text
@d20 1
d141 18
d190 7
d271 11
a281 1
   WitPeriod expPer;
d283 10
a292 4
   if (selSplit ())
      if (hasMeCoordPts (theBopEnt))
         {
         expPer = theBopEnt->impactPeriod ()[execPer];
d294 1
a294 3
         if (myMeCoordPt (theBopEnt, expPer) != NULL)
            totExpVol_.incCell (theBopEnt, execPer, expVol);
         }
@


1.30
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@d221 1
a221 1
      execPer = asaPer (theTlObj);
@


1.29
log
@Various refactorings for sel-split for multi-exec.
@
text
@d32 1
a32 2
      totExpVol_      (myProblem ()),
      splitBopEntry_  (NULL)
a204 2

   splitBopEntry_ = theBopEnt;
d228 12
a410 9
   }

//------------------------------------------------------------------------------

void WitMeMgr::adjustSplitBound (WitTlObj * theTlObj, double & splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExpVol_ (splitBopEntry_, asaPer (theTlObj));
@


1.28
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@a199 1
   WitPeriod    execPer;
d205 1
a205 5
   witAssert (theMeSelPt != NULL);

   execPer = selExecPeriod (theBopEnt, expPer);
                                                
   startSplitExpAbs (theMeSelPt, asaTlObj (execPer), expVol);
a410 21
   }

//------------------------------------------------------------------------------

void WitMeMgr::prtSplitExp (WitTlObj * theTlObj)
   {
   WitPeriod execPer;

   execPer = asaPer (theTlObj);

   fprintf (msgFile (),
      "\n"
      "Split Selection for Multiple Execution Periods:\n"
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n"
      "   Exp Per:     %d\n"
      "   Exec Per:    %d\n",
      splitBopEntry_->myOperationName ().myCstring (),
      splitBopEntry_->localIndex (),
      splitBopEntry_->impactPeriod ()[execPer],
      execPer);
@


1.27
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a32 1
      splitSched_     (myProblem ()),
d179 9
a187 4
   if (selSplit ())
      if (hasMeCoordPts (theBopEnt))
         if (! splitSched_ (theBopEnt, expPer).isEmpty ())
            return witTRUE;
d189 1
a189 1
   return witFALSE;
d199 3
d204 8
a212 6

   startSplitExpAbs (
      splitSched_             (theBopEnt, expPer),
      asaTlObj (selExecPeriod (theBopEnt, expPer)),
      expVol,
      NULL);
d219 1
a219 1
   WitTl *    theTlObj;
a265 3
   witAssert (selSplit ());

   splitSched_.clear ();
a402 1
   splitSched_.allocate1D ();
a405 1
         {
a406 2
         splitSched_.allocateRow (theBopEnt);
         }
d411 1
a411 1
void WitMeMgr::adjustSplitBound (WitTl * theTlObj, double & splitBound)
d420 1
a420 1
void WitMeMgr::prtSelSplit (WitTl * theTlObj)
@


1.26
log
@Renamed AltPt classes to SelPt classes.
@
text
@a61 3
   if (selSplit ())
      setupSelSplit ();

d171 7
a324 19
void WitMeMgr::setupSelSplit ()
   {
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   totExpVol_ .allocate1D ();
   splitSched_.allocate1D ();
   
   forEachBopEntry (theBopEnt, myProblem ())
      if (hasMeCoordPts (theBopEnt))
         {
         totExpVol_ .allocateRow (theBopEnt);
         splitSched_.allocateRow (theBopEnt);
         }
   }

//------------------------------------------------------------------------------

d386 19
@


1.25
log
@Removed class MePrinter.
@
text
@d18 1
a18 1
#include <MeAltPt.h>
d101 1
a101 1
   WitMeAltPt * theMeAltPt;
d104 1
a104 1
   theMeAltPt = myMeAltPtWithSel (theBopEnt, expPer);
d107 2
a108 2
      (theMeAltPt != NULL)?
         theMeAltPt->selExecPer ():
d114 1
a114 1
WitAltPt * WitMeMgr::myAltPt (
d122 1
a122 1
   WitMeAltPt * theMeAltPt;
d126 1
a126 1
   theMeAltPt = myMeAltPtWithSel (theBopEnt, prodPer);
d128 2
a129 2
   if (theMeAltPt != NULL)
      resFound = theMeAltPt->hasResAlt ();
d133 1
a133 1
   return theMeAltPt;
d153 1
a153 1
      "Multi-Exec Alteration Points:\n");
d162 1
a162 1
            theMeCoordPt->myMeAltPtForNstn ()->print ();
d165 1
a165 1
               theMeCoordPt->myMeAltPtForAsap ()->print ();
d340 1
a340 1
WitMeAltPt * WitMeMgr::myMeAltPtWithSel (
d346 1
a346 1
   WitMeAltPt *   theMeAltPt;
d358 1
a358 1
   theMeAltPt = theMeDir->myMeAltPt (theMeCoordPt);
d361 2
a362 2
      theMeAltPt->hasSelExecPer ()?
         theMeAltPt:
@


1.24
log
@Removed class MeAltPt.
Changed name of class MeSelPt to MeAltPt.
Implemented de-selection of colliding MeAltPts.
@
text
@a16 1
#include <MePtr.h>
a31 1
      myMePrinter_    (NULL),
a66 3

   if (myGlobalComp ()->selPrintLevel () >= 1)
      myMePrinter_ = new WitMePrinter (this);
a76 2
   delete myMePrinter_;

d145 1
a145 4
WitBoolean WitMeMgr::findNextMeCoordPt (
      WitBopEntry *    theBopEnt,
      WitPeriod &      expPer,
      WitMeCoordPt * & theMeCoordPt)
d147 21
a167 7
   while (++ expPer < nPeriods ())
      {
      theMeCoordPt = myMeCoordPt (theBopEnt, expPer);
   
      if (theMeCoordPt != NULL)
         return witTRUE;
      }
d169 1
a169 1
   return witFALSE;
d275 1
a275 1
               myMeCoordPtForUpdate (theBopEnt, expPer) = 
d383 18
@


1.23
log
@Fixed a bug on multi-exec.
@
text
@a18 1
#include <MeSelPt.h>
a30 1
      myMeAltPts_     (),
a31 2
      curMeAltPt_     (myProblem ()),
      toReject_       (myProblem ()),
d57 1
a57 1
      buildMeAltCandPts (theOpn, nExecPers, expExecPer);
a63 2
   curMeAltPt_.clear ();

a92 3
   while (!  myMeAltPts_.isEmpty ())
      delete myMeAltPts_.get ();

a107 1
   WitMeSelPt * theMeSelPt;
d109 1
d111 1
a111 1
   theMeSelPt = myMeSelPt (theBopEnt, expPer);
d113 4
a116 9
   if (theMeSelPt != NULL)
      {
      theMeAltPt = theMeSelPt->selMeAltPt ();

      if (theMeAltPt != NULL)
         return theMeAltPt->execPeriod ();
      }

   return theBopEnt->expExecPeriod ()[expPer];
d129 1
a129 1
   WitMeSelPt * theMeSelPt;
d133 1
a133 1
   theMeSelPt = myMeSelPt (theBopEnt, prodPer);
d135 2
a136 2
   if (theMeSelPt != NULL)
      resFound = theMeSelPt->hasResAlt ();
d140 1
a140 1
   return theMeSelPt;
a169 17
void WitMeMgr::preReject (WitMeAltPt * theMeAltPt)
   {
   toReject_.push (theMeAltPt);
   }

//------------------------------------------------------------------------------

void WitMeMgr::finishAlteration ()
   {
   WitMeAltPt * theMeAltPt;

   while (toReject_.pop (theMeAltPt))
      theMeAltPt->reject ();
   }

//------------------------------------------------------------------------------

d256 1
a256 1
void WitMeMgr::buildMeAltCandPts (
a260 1
   WitBoolean    foundExecPers;
d264 1
a264 3
   foundExecPers = witFALSE;

   forEachEl (theBopEnt, theOpn->bop ())
a266 2
         foundExecPers = witTRUE;
   
a270 3
               {
               buildMeAltPts (nExecPers [expPer], expExecPer (expPer));
                  
a276 1
               }
a277 3

   if (foundExecPers)
      curMeAltPt_ = NULL;
a316 22
void WitMeMgr::buildMeAltPts (
      int                           nExecPers, 
      const WitVector (WitPeriod) & execPerByIdx)
   {
   int       theIdx;
   WitPeriod execPer;

   for (theIdx = 0; theIdx < nExecPers; theIdx ++)
      {
      execPer = execPerByIdx[theIdx];

      if (curMeAltPt_[execPer] == NULL)
         {
         curMeAltPt_[execPer] = new WitMeAltPt (execPer, myProblem ());

         myMeAltPts_.append (curMeAltPt_[execPer]);
         }
      }
   }

//------------------------------------------------------------------------------

d336 3
a338 1
WitMeSelPt * WitMeMgr::myMeSelPt (WitBopEntry * theBopEnt, WitPeriod expPer)
d342 1
d352 1
a352 1
   theMeDir = chooseMeDir (theBopEnt->myPart ());
d354 1
a354 2
   if (myGlobalComp ()->selPrintLevel () >= 3)
      myMePrinter ()->printSelMeAltPt (theBopEnt, theMeDir);
d356 4
a359 1
   return theMeDir->myMeSelPt (theMeCoordPt);
@


1.22
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@d35 1
d120 1
a120 1
   theMeAltPt = selMeAltPt (theBopEnt, expPer, theMeSelPt);
d122 9
a130 4
   return
      (theMeAltPt != NULL)?
         theMeAltPt->execPeriod ():
         theBopEnt->expExecPeriod ()[expPer];
a143 1
   WitMeAltPt * theMeAltPt;
d147 1
a147 1
   theMeAltPt = selMeAltPt (theBopEnt, prodPer, theMeSelPt);
d149 1
a149 1
   if (theMeAltPt != NULL)
d184 17
d401 1
a401 4
WitMeAltPt * WitMeMgr::selMeAltPt (
      WitBopEntry *  theBopEnt, 
      WitPeriod      expPer,
      WitMeSelPt * & theMeSelPt)
a405 2
   theMeSelPt = NULL;

d419 1
a419 3
   theMeSelPt = theMeDir->myMeSelPt (theMeCoordPt);

   return theMeSelPt->selMeAltPt ();
@


1.21
log
@Re-worked the controls for selection splitting.
@
text
@d149 1
a149 1
   return theMeAltPt;
d202 1
a202 1
      itsTlPtr (selExecPeriod (theBopEnt, expPer)),
d216 2
d220 2
a221 1
   execPer    = itsPer (theTlObj);
d387 2
d432 1
a432 1
   splitBound -= totExpVol_ (splitBopEntry_, itsPer (theTlObj));
d441 1
a441 1
   execPer = itsPer (theTlObj);
@


1.20
log
@Continued implementation of selection splitting.
@
text
@d28 1
a28 1
      WitSelMgr       (theSelector, witFALSE),
@


1.19
log
@Continued implementation of selection splitting with the new design.
@
text
@d253 1
a253 1
void WitMeMgr::clearSplitSched ()
@


1.18
log
@Continued implementation of selection splitting with the new design.
@
text
@d441 4
a444 5
      "   Operation:      %s\n"
      "   BOP Entry #:    %d\n"
      "   Exp Per:        %d\n"
      "   Selection:\n"
      "      Exec Per:    %d\n",
@


1.17
log
@Continued implementation of selection splitting with the new design.
@
text
@d253 9
@


1.16
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d203 2
a204 1
      expVol);
@


1.15
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d181 4
a184 5
   witAssert (selSplit ());

   if (hasMeCoordPts (theBopEnt))
      if (! splitSched_ (theBopEnt, expPer).isEmpty ())
         return witTRUE;
d231 8
a238 11
   witAssert (selSplit ());

   if (! hasMeCoordPts (theBopEnt))
      return;

   expPer = theBopEnt->impactPeriod ()[execPer];

   if (myMeCoordPt (theBopEnt, expPer) == NULL)
      return;

   totExpVol_.incCell (theBopEnt, execPer, expVol);
@


1.14
log
@Further implementation of coarse selection splitting.
@
text
@d27 2
a28 2
WitMeMgr::WitMeMgr (WitHeurAllPerf * theHeurAllPerf):
      WitSelMgr       (theHeurAllPerf),
d247 1
a247 22
void WitMeMgr::postCommitSS (WitBoolean tempSuccess)
   {
   witAssert (selSplit ());

   if (tempSuccess)
      totExpVol_.saveAndClear ();
   else
      totExpVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitMeMgr::preAltAttSS ()
   {
   witAssert (selSplit ());

   totExpVol_.restore ();
   }

//------------------------------------------------------------------------------

void WitMeMgr::postAltAttSS ()
a251 32
   }

//------------------------------------------------------------------------------

void WitMeMgr::postPermCommitSS ()
   {
   witAssert (selSplit ());

   totExpVol_ .clear ();
   totExpVol_ .saveAndClear ();
   splitSched_.clear ();
   }

//------------------------------------------------------------------------------

void WitMeMgr::splitSel (WitBopEntry * theBopEnt, WitPeriod execPer)
   {
   WitPeriod expPer;
   double    totExpVolVal;

   witAssert (selSplit ());

   expPer       = theBopEnt->impactPeriod ()[execPer];

   totExpVolVal = totExpVol_ (theBopEnt, execPer);

   if (totExpVolVal > 0.0)
      splitSched_.slowAppend (
         theBopEnt, 
         expPer, 
         itsTlPtr (execPer), 
         totExpVolVal);
@


1.13
log
@Further implementation of coarse selection splitting.
@
text
@d300 5
a304 1
      splitSched_.push (theBopEnt, expPer, itsTlPtr (execPer), totExpVolVal);
@


1.12
log
@Continued development of coarse selection splitting.
@
text
@d466 1
a466 1
void WitMeMgr::adjustSplitVol (WitTl * theTlObj, double & splitVol)
d470 1
a470 1
   splitVol -= totExpVol_ (splitBopEntry_, itsPer (theTlObj));
@


1.11
log
@Further implementation of coarse selection splitting.
@
text
@d69 1
a69 1
   if (myGlobalComp ()->selSplit ())
d179 30
d214 2
d232 2
d249 2
d261 2
d270 2
d279 2
a287 28
WitBoolean WitMeMgr::selIsSplit (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   if (hasMeCoordPts (theBopEnt))
      if (! splitSched_ (theBopEnt, expPer).isEmpty ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitMeMgr::startSplitExp (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol)
   {
   witAssert (selIsSplit (theBopEnt, expPer));

   splitBopEntry_ = theBopEnt;

   startSplitExpAbs (
      splitSched_             (theBopEnt, expPer),
      itsTlPtr (selExecPeriod (theBopEnt, expPer)),
      expVol);
   }

//------------------------------------------------------------------------------

d293 2
d404 2
d468 2
@


1.10
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d198 11
a208 2
   if (hasMeCoordPts (theBopEnt))
      totExpVol_.incCell (theBopEnt, execPer, expVol);
@


1.9
log
@Further development of coarse selection splitting.
@
text
@d36 4
a39 1
      myMePrinter_    (NULL)
d69 3
d179 18
a196 1
void WitMeMgr::postCommitSS (WitBoolean)
d198 12
a209 1
   myMsgFac () ("internalErrorFmsg", "WitMeMgr::postCommitSS");
d216 1
a216 1
   myMsgFac () ("internalErrorFmsg", "WitMeMgr::preAltAttSS");
d223 1
a223 1
   myMsgFac () ("internalErrorFmsg", "WitMeMgr::postAltAttSS");
d230 46
a275 1
   myMsgFac () ("internalErrorFmsg", "WitMeMgr::postPermCommitSS");
d305 2
a306 1
                     nExecPers[expPer], 
d375 17
d441 1
a441 1
   myMsgFac () ("internalErrorFmsg", "WitMeMgr::adjustSplitVol");
d446 1
a446 1
void WitMeMgr::prtSelSplit (WitTl *)
d448 16
a463 1
   myMsgFac () ("internalErrorFmsg", "WitMeMgr::prtSelSplit");
@


1.8
log
@Implemented and used class SelMgr.
@
text
@d339 14
@


1.7
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d27 2
a28 2
WitMeMgr::WitMeMgr (WitProblem * theProblem):
      WitProbAssoc    (theProblem),
d92 2
a93 1
   myMeAltPts_.clearContents ();
d124 4
a127 2
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
d130 1
d134 3
a136 1
   theMeAltPt = selMeAltPt (theBopEnt, expPer, theMeSelPt);
d148 7
d169 28
@


1.6
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d49 3
a51 3
   nExecPers     .allocate          (myProblem (), 0);
   expExecPer    .allocate          (myProblem ());
   myMeCoordPtTl_.partiallyAllocate (myProblem ());
@


1.5
log
@Some minor changes.
@
text
@d107 1
a107 4
WitPeriod WitMeMgr::selExecPeriod (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer,
      WitPeriod     fillPer)
d112 1
a112 1
   theMeAltPt = selMeAltPt (theBopEnt, expPer, fillPer, theMeSelPt);
a124 1
      WitPeriod     fillPer,
d130 1
a130 1
   theMeAltPt = selMeAltPt (theBopEnt, expPer, fillPer, theMeSelPt);
a256 1
      WitPeriod      fillPer,
@


1.4
log
@Refactoring for selection splitting.
@
text
@d41 2
a42 2
   WitTVec (int)                        nExecPers;
   WitRefVector (WitVector (WitPeriod)) expExecPer;
d49 2
a50 2
   nExecPers.     allocate          (myProblem (), 0);
   expExecPer.    resize            (nPeriods ());
d54 1
a54 1
      expExecPer[expPer].resize (nPeriods (), -1);
d59 5
d165 3
a167 3
      WitOperation *                         theOpn,
      WitTVec (int) &                        nExecPers,
      WitRefVector (WitVector (WitPeriod)) & expExecPer)
d185 1
a185 1
               buildMeAltPts (nExecPers [expPer], expExecPer[expPer]);
d188 4
a191 2
                  new 
                     WitMeCoordPt (nExecPers[expPer], expExecPer[expPer], this);
d202 3
a204 3
      WitBopEntry *                          theBopEnt,
      WitTVec (int) &                        nExecPers,
      WitRefVector (WitVector (WitPeriod)) & expExecPer)
d223 1
a223 1
      expExecPer[expPer][nExecPers[expPer]] = execPer;
@


1.3
log
@Outer API: Merged all no-longer-documented functions into one section.
Outer API: Moved build-ahead by demand functions into the no-longer-documented
   section.
Simplified the rules for two-way multiple execution periods.
@
text
@d11 1
a11 1
// Source file: "Skeleton.C"
d34 1
a34 1
      curMeAltPtTl_   (myProblem (), NULL),
d59 1
a59 1
   curMeAltPtTl_.clear ();
d189 1
a189 1
      curMeAltPtTl_ = (WitTypelessPtr) NULL;
d240 1
a240 1
      if (curMeAltPt (execPer) == NULL)
d242 1
a242 1
         curMeAltPtForUpdate (execPer) = new WitMeAltPt (execPer, myProblem ());
d244 1
a244 1
         myMeAltPts_.append (curMeAltPt (execPer));
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@a17 1
#include <MeDirMgr.h>
d28 1
a28 1
      WitProbAssoc   (theProblem),
d30 7
a36 5
      myMeDirMgr_    (NULL),
      myMeAltPts_    (),
      myMeCoordPtTl_ (),
      curMeAltPtTl_  (myProblem (), NULL),
      myMePrinter_   (NULL)
d46 2
a47 1
   myMeDirMgr_ = new WitMeDirMgr (myProblem ());
d88 10
a97 2
   
   delete myMeDirMgr_;
d268 1
a268 1
   theMeDir = myMeDirMgr ()->chooseMeDir (theBopEnt, expPer, fillPer);
d276 19
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

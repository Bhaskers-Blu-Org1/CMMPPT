head	1.57;
access;
symbols
	sce_5_01_20080919:1.50
	latest_sce_4_20_20060523:1.48.0.2
	sce_4_20_20060523:1.48
	latest_sce4_20_OSL:1.47.0.2
	sce_4_20_OSL:1.47
	sce_410_withVa:1.46
	sce_4_05_20040511:1.44
	sce_4_00_20040201:1.36
	nextGenBranch:1.31.0.2
	nextGenRoot:1.31
	sce_3_30_20030627:1.31
	EndRw-branch:1.19.0.4
	Root-of-EndRw:1.19
	rwToStl:1.19.0.2;
locks; strict;
comment	@ * @;


1.57
date	2010.09.10.20.30.56;	author rjw;	state dead;
branches;
next	1.56;

1.56
date	2010.09.10.20.12.06;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.10.16.03.49;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.10.14.59.26;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2010.09.07.23.50.33;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.16.18.58.25;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2010.03.16.22.42.23;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.07.21.50.11;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.01.21.28.03;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.02.17.33.54;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.24.20.49.13;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.28.20.14.34;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.09.16.38.38;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.30.23.27.43;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.24.22.21.28;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.04.19.53.25;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.02.23.52.13;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.18.21.53.51;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.29.22.06.17;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.15.18.12.01;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.09.22.44.05;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.11.18.29.11;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.01.19.41.09;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.25.23.49.54;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.17.23.34.18;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.19.16.48.12;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.14.20.12.54;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.15.23.13.14;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.15.21.01.18;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.02.23.40.36;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.02.22.18.18;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.26.18.35.00;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.24.22.50.45;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.23.20.44.44;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.20.22.47.58;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.19.17.15.19;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.18.22.23.53;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.16.22.30.18;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.11.18.53.04;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.19.16.10.48;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.06.18.53.35;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.05.21.19.56;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.13.21.31.38;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.10.18.02.09;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.20.14.52;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.22.14.32.02;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.18.14.02.26;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.20.22.51.15;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.17.16.25.40;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.07.23.03.53;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.05.20.53.56;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.05.18.55.26;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.03.18.55.09;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.28.00.12.56;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.24.22.45.19;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Heuristic Adjustment
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "AvSched.C"
//
// Contains the implementation of class AvailSched.
//------------------------------------------------------------------------------

#include <AvSched.h>
#include <HeurAtor.h>
#include <SsrMgr.h>
#include <GlobalComp.h>
#include <Material.h>
#include <BoundSet.h>
#include <Post.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class AvailSched.
//------------------------------------------------------------------------------

WitAvailSched::WitAvailSched (WitHeurAtor * theHeurAtor):

      WitProbAssoc (theHeurAtor),

      myHeurAtor_  (theHeurAtor),
      mySsrMgr_    (NULL),
      incAvailVol_ (myProblem (), 0.0),
      lastDecPer_  (myProblem (), -1),
      uncondSR_    (myProblem (), false),
      selectiveSR_ (myProblem (), false)
   {
   WitPart * thePart;

   if (myHeurAtor_->userHeurStart ())
      {
      myMsgFac () ("userHeurStartMsg");

      initForUHS ();

      verifyUhsNNScrapCon ();
      }
   else
      forEachPart (thePart, myProblem ())
         incAvailVol_ (thePart) = thePart->supplyVol ();

   initStockRealloc ();
   }

//------------------------------------------------------------------------------

WitAvailSched::~WitAvailSched ()
   {
   }

//------------------------------------------------------------------------------

void WitAvailSched::updateForAdjust ()
   {
   incAvailVol_.allocate (myProblem (), 0.0);
   lastDecPer_ .allocate (myProblem (), -1);

   initForUHS ();
   }

//------------------------------------------------------------------------------

void WitAvailSched::attachSsrMgr ()
   {
   mySsrMgr_ = myHeurAtor_->mySsrMgr ();
   }

//------------------------------------------------------------------------------

void WitAvailSched::netWoSR (
      WitPart * thePart,
      WitPeriod reqPer,
      double &  theReqVol)
   {
   WitMaterial * theMat;

   witAssert (theReqVol >= NET_TOL);

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      netMatWoSR      (theMat,  reqPer, theReqVol);
   else
      netWithIncAvail (thePart, reqPer, theReqVol);
   }

//------------------------------------------------------------------------------

void WitAvailSched::netWithIncAvail (
      WitPart * thePart,
      WitPeriod thePer,
      double &  theReqVol)
   {
   double deltaVol;

   deltaVol = min (theReqVol, incAvailVol_ (thePart)[thePer]);

   if (deltaVol < NET_TOL)
      return;

   theReqVol -= deltaVol;

   addToIncAvailVol (thePart, thePer, - deltaVol);
   }

//------------------------------------------------------------------------------

void WitAvailSched::netMatWoSR (
      WitMaterial * theMat,
      WitPeriod     reqPer,
      double &      theReqVol)
   {
   double allVol;
   double totReqVol;
   double availVol;
   double deltaVol;

   allVol    = allocedVol (theMat, reqPer, false);

   totReqVol = theReqVol + allVol;

   availVol  = availToNet (theMat, reqPer, totReqVol, 0.0);

   deltaVol  = 
      (availVol == totReqVol)?
         theReqVol:
         availVol - allVol;

   if (deltaVol < NET_TOL)
      return;

   theReqVol -= deltaVol;

   addToIncAvailVol (theMat, reqPer, - deltaVol);
   }

//------------------------------------------------------------------------------

WitPeriod WitAvailSched::netAndRoll (
      WitMaterial * theMat, 
      WitPeriod     reqPer,
      double &      theReqVol,
      double &      rollVol,
      bool &        bddSsrSplit)
   {
   double    allVol;
   WitPeriod rollPer;

   witAssert (eitherSR (theMat));

   witAssert (theReqVol >= NET_TOL);

   if (selectiveSR_ (theMat))
      allVol = allocedVol (theMat, reqPer, true);
   else
      allVol = 0.0;

   rollVol = availToNet (theMat, reqPer, theReqVol, allVol);

   if (rollVol < NET_TOL)
      return -1;

   theReqVol -= rollVol;

   rollPer    = rollPeriod (theMat, reqPer);

   if (selectiveSR_ (theMat))
      {
      mySsrMgr_->adjReqAndRollForSS (
         theMat,
         rollPer,
         theReqVol,
         rollVol,
         bddSsrSplit);

      if (rollVol < NET_TOL)
         return -1;
      }

   addToIncAvailVol (theMat, reqPer, - rollVol);

   if (rollPer >= 0)
      addToIncAvailVol (theMat, rollPer, rollVol);

   return rollPer;
   }

//------------------------------------------------------------------------------

void WitAvailSched::reserveAchStSLB (
      WitMaterial * theMat, 
      WitPeriod     thePer,
      double &      unachVol)
   {
   double resVol;

   witAssert (myGlobalComp ()->respectStockSLBs ());

   witAssert (not theMat->mandEC ()[thePer]);

   unachVol = theMat->stockBounds ()->softLB ()[thePer];

   witAssert (unachVol >= NET_TOL);

   resVol   = availToNet (theMat, thePer, unachVol, 0.0);

   if (resVol <= NET_TOL)
      return;

   addToIncAvailVol    (theMat, thePer,     - resVol);

   if (thePer < lastPeriod ())
      addToIncAvailVol (theMat, thePer + 1, + resVol);

   unachVol -= resVol;
   }

//------------------------------------------------------------------------------

void WitAvailSched::addToIncAvailVol (
      WitPart * thePart, 
      WitPeriod thePer, 
      double    deltaVol)
   {
   WitMaterial * theMat;

   double & incAvailVolRef = incAvailVol_ (thePart)[thePer];

   myHeurAtor_->saveVal (incAvailVolRef);

   incAvailVolRef += deltaVol;

   if (incAvailVolRef >= - NET_TOL)
      return;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (thePer > lastDecPer_ (theMat))
         {
         myHeurAtor_->saveVal (lastDecPer_ (theMat));

         lastDecPer_ (theMat) = thePer;
         }
   }

//------------------------------------------------------------------------------

void WitAvailSched::initForUHS ()
   {
   WitTVec <double> prodVolVec;
   WitTVec <double> consVolVec;
   WitTVec <double> nonSubVolVec;
   WitTVec <double> subVolVec;
   WitPart *        thePart;
   WitBomEntry *    theBomEnt;
   WitSubEntry *    theSub;
   WitPeriod        thePer;
   double           incAvVol;
   WitDemand *      theDemand;

   prodVolVec  .allocate (myProblem (), 0.0);
   consVolVec  .allocate (myProblem (), 0.0);
   nonSubVolVec.allocate (myProblem (), 0.0);
   subVolVec   .allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      myProblem ()->myPostprocessor ()->compProdVol (thePart, prodVolVec);

      consVolVec = 0.0;

      forEachEl (theBomEnt, thePart->consumingBomEntries ())
         {
         myProblem ()->
            myPostprocessor ()->
               compNonSubVol (theBomEnt, nonSubVolVec);

         theBomEnt->incConsVol (consVolVec, nonSubVolVec);
         }

      forEachEl (theSub, thePart->consumingSubEntries ())
         {
         subVolVec = theSub->subVol ();

         theSub->incConsVol (consVolVec, subVolVec);
         }

      forEachPeriod (thePer, myProblem ())
         {
         incAvVol =
              thePart->supplyVol ()[thePer]
            + prodVolVec           [thePer]
            - consVolVec           [thePer];

         forEachEl (theDemand, thePart->myDemands ())
            incAvVol -= theDemand->shipVol ()[thePer];

         addToIncAvailVol (thePart, thePer, incAvVol);
         }
      }
   }

//------------------------------------------------------------------------------

void WitAvailSched::verifyUhsNNScrapCon ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    availVol;
   double    maxViol;
   WitPart * mvPart;
   WitPeriod mvPer;

   maxViol = FEAS_TOL;
   mvPart  = NULL;
   mvPer   = -1;

   forEachPart (thePart, myProblem ())
      {
      availVol = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         availVol += incAvailVol_ (thePart)[thePer];

         if (- availVol > maxViol)
            {
            maxViol = - availVol;
            mvPart  =   thePart;
            mvPer   =   thePer;
            }

         setToMax (availVol, 0.0);

         if (not thePart->canStock (thePer))
            availVol = 0.0;
         }
      }

   if (mvPart != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsNNScrapConViolWmsg",
         maxViol,
         mvPart->partName (),
         mvPer,
         - maxViol);
      }
   }

//------------------------------------------------------------------------------

void WitAvailSched::initStockRealloc ()
   {
   WitMaterial * theMat;

   if (myGlobalComp ()->oldSR ())
      {
      myMsgFac () ("oldSRMsg");

      forEachMaterial (theMat, myProblem ())
         if (not theMat->producingBopEntries ().isEmpty ())
            uncondSR_ (theMat) = true; 
      }
   else if (myGlobalComp ()->stockReallocation ())
      {
      myMsgFac () ("stockReMsg");

      forEachMaterial (theMat, myProblem ())
         {
         if (theMat->producingBopEntries ().isEmpty ())
            continue;

         if (unlimitedBuildAhead (theMat))
            uncondSR_    (theMat) = true; 
         else
            selectiveSR_ (theMat) = true;
         }
      }
   }

//------------------------------------------------------------------------------

bool WitAvailSched::unlimitedBuildAhead (WitMaterial * theMat)
   {
   WitPeriod thePer;

   if    (not theMat->buildNstn ())
      if (not theMat->buildAsap ())
         return false;

   forEachPeriod (thePer, myProblem ())
      if (theMat->buildAheadUB ()[thePer] < thePer)
         return false;

   return true;
   }

//------------------------------------------------------------------------------
// allocedVol
//
// Note that mandECs can be ignored: When one occurs, the allocated volume will
// have to be zero anyway.
//------------------------------------------------------------------------------

double WitAvailSched::allocedVol (
      WitMaterial * theMat,
      WitPeriod     reqPer,
      bool          forSR)
   {
   WitPeriod thePer;
   double    allVol;
   double    incAvVol;

   allVol = 0.0;

   for (thePer = lastDecPer_ (theMat); thePer > reqPer; thePer --)
      {
      incAvVol = incAvailVol_ (theMat)[thePer];

      if (incAvVol < - NET_TOL)
         {
         if (forSR)
            if (srAllowedFrom (theMat, thePer))
               continue;

         allVol += - incAvVol;
         }
      else if (incAvVol > NET_TOL)
         {
         allVol -= incAvVol;

         setToMax (allVol, 0.0);
         }
      }

   return allVol;
   }

//------------------------------------------------------------------------------

double WitAvailSched::availToNet (
      WitMaterial * theMat, 
      WitPeriod     reqPer,
      double        theReqVol,
      double        allVol)
   {
   double    availVol;
   WitPeriod thePer;
   double    theIncAvailVol;

   witAssert (theReqVol >= NET_TOL);

   availVol = - allVol;

   for (thePer = reqPer; thePer >= 0; thePer --)
      {
      if (thePer < reqPer)
         if (theMat->mandEC ()[thePer])
            return availVol;

      theIncAvailVol = incAvailVol_ (theMat)[thePer];

      if (theIncAvailVol == 0.0)
         continue;

      availVol += theIncAvailVol;

      if (availVol >= theReqVol - NET_TOL)
         return theReqVol;
      }

   return availVol;
   }

//------------------------------------------------------------------------------

WitPeriod WitAvailSched::rollPeriod (WitMaterial * theMat, WitPeriod fromPer)
   {
   WitPeriod thePer;

   if (fromPer < lastDecPer_ (theMat))
      for (thePer = fromPer + 1; thePer < nPeriods (); thePer ++)
         {
         if (theMat->mandEC ()[thePer - 1])
            break;

         if (srAllowedFrom (theMat, thePer))
            if (incAvailVol_ (theMat)[thePer] < - NET_TOL)
               return thePer;
         }

   return -1;
   }

//------------------------------------------------------------------------------

bool WitAvailSched::srAllowedFrom (WitMaterial * theMat, WitPeriod thePer)
   {
   return
      uncondSR_    (theMat)? true:
      selectiveSR_ (theMat)? mySsrMgr_->srAllowedFrom (theMat, thePer):
                             false;
   }
@


1.56
log
@Heuristic Adjustment
@
text
@@


1.55
log
@Heuristic Adjustment
@
text
@a201 13
void WitAvailSched::adjustForShipVol (
      WitDemand * theDemand,
      WitPeriod   shipPer,
      double      deltaShipVol)
   {
   addToIncAvailVol (
      theDemand->demandedPart (),
      shipPer,
    - deltaShipVol);
   }

//------------------------------------------------------------------------------

@


1.54
log
@Heuristic Adjustment
@
text
@d202 13
@


1.53
log
@Heuristic Adjustment
@
text
@d38 1
a38 2
      selectiveSR_ (myProblem (), false),
      initUHSMode_ (false)
d241 1
a241 2
   if (not initUHSMode_)
      myHeurAtor_->saveVal (incAvailVolRef);
d253 1
a253 2
         if (not initUHSMode_)
            myHeurAtor_->saveVal (lastDecPer_ (theMat));
a278 2
   initUHSMode_ = true;

a313 2

   initUHSMode_ = false;
@


1.52
log
@Revised the criteria for using selective stock reallocation.
@
text
@d45 2
d66 10
a281 2
   myMsgFac () ("userHeurStartMsg");

@


1.51
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d385 7
a391 4
         if (theMat->buildNstn () or theMat->buildAsap ())
            if (theMat->buildAheadUB () == myProblem ()->lastPeriod ())
               {
               uncondSR_ (theMat) = true; 
d393 13
a405 2
               continue;
               }
d407 1
a407 3
         selectiveSR_ (theMat) = true;
         }
      }
@


1.50
log
@Stochastic Implosion
@
text
@d19 1
a19 1
#include <Global.h>
@


1.49
log
@Stochastic Implosion
@
text
@d254 15
a268 11
   WitPart *     thePart;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitPeriod     thePer;
   double        incAvVol;
   WitDemand *   theDemand;

   WitTVec <double> prodVolVec   (myProblem (), 0.0);
   WitTVec <double> consVolVec   (myProblem (), 0.0);
   WitDblFlexVec    nonSubVolVec (myProblem (), 0.0);
   WitTVec <double> execVolVec   (myProblem (), 0.0);
d282 3
a284 3
         myProblem ()->myPostprocessor ()->compNonSubVol (
            theBomEnt,
            nonSubVolVec);
d286 1
a286 3
         execVolVec = nonSubVolVec;

         theBomEnt->incConsVol (consVolVec, execVolVec);
d291 1
a291 1
         execVolVec = theSub->subVol ();
d293 1
a293 1
         theSub->incConsVol (consVolVec, execVolVec);
@


1.48
log
@Updated the copyright date on all source files.
@
text
@d31 1
a31 1
      WitProbAssoc (theHeurAtor->myProblem ()),
@


1.47
log
@Fixed bugs:
   witWriteData didn't write problem.compPrices.
   witWriteData didn't write problem.accMethod.
   witCopyData  didn't copy  problem.solverLogFileName.
   witCopyData  didn't copy  problem.accMethod.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.46
log
@Revised mappingIndex code.
@
text
@d213 1
a213 1
   if (thePer < nPeriods () - 1)
@


1.45
log
@Corrected a numberical problem in netting.
@
text
@a23 1
#include <MapIdxI.h>
@


1.44
log
@PIP.
@
text
@d124 1
a124 1
   availVol  = availToNet (theMat, reqPer, totReqVol);
d156 3
a158 2
      {  
      allVol  = allocedVol (theMat, reqPer, true);
d160 1
a160 4
      rollVol = availToNet (theMat, reqPer, theReqVol + allVol) - allVol;
      }
   else
      rollVol = availToNet (theMat, reqPer, theReqVol);
d207 1
a207 1
   resVol   = availToNet (theMat, thePer, unachVol);
d443 2
a444 1
      double        theReqVol)
d452 1
a452 1
   availVol = 0.0;
@


1.43
log
@Double Precision.
@
text
@d52 1
a52 1
         thePart->supplyVol ().copyInto (incAvailVol_ (thePart));
d285 1
a285 1
         nonSubVolVec.copyInto (execVolVec);
d292 1
a292 1
         theSub->subVol ().copyInto (execVolVec);
@


1.42
log
@Double Precision.
@
text
@d52 1
a52 1
         thePart->supplyVol ().convCopyInto (incAvailVol_ (thePart));
d285 1
a285 1
         nonSubVolVec.convCopyInto (execVolVec);
d292 1
a292 1
         theSub->subVol ().convCopyInto (execVolVec);
@


1.41
log
@Double Precision.
@
text
@d277 1
a277 1
      consVolVec.setToScalar (0.0);
@


1.40
log
@Double Precision.
@
text
@d264 4
a267 4
   WitTVec    <double> prodVolVec   (myProblem (), 0.0);
   WitTVec    <double> consVolVec   (myProblem (), 0.0);
   WitFlexVec <double> nonSubVolVec (myProblem (), 0.0);
   WitTVec    <double> execVolVec   (myProblem (), 0.0);
@


1.39
log
@Double Precision.
@
text
@d52 1
a52 1
         thePart->supplyVol ().copyIntoDblTVec (incAvailVol_ (thePart));
d285 1
a285 1
         nonSubVolVec.copyIntoTVec (execVolVec);
d292 1
a292 1
         theSub->subVol ().copyIntoTVec (execVolVec);
@


1.38
log
@Replaced the severe error for most constraint violations in the
   user-specified heuristic starting solution with a warning.
@
text
@d52 1
a52 1
         copyInto (incAvailVol_ (thePart), thePart->supplyVol ());
@


1.37
log
@Fixed a bug in stock reallocation that surfaced as a problem with build-ahead.
@
text
@d321 7
d337 1
a337 1
         if (availVol < - FEAS_TOL)
d339 3
a341 6
            myMsgFac () ("uhsConViolIntroSmsg");

            myMsgFac () ("uhsNNScrapConViolSmsg",
               thePart->partName (),
               thePer,
               availVol);
d349 11
@


1.36
log
@Continued implementation of PIP.
@
text
@d148 1
d155 3
a157 1
   rollVol = availToNet (theMat, reqPer, theReqVol);
d159 4
a162 2
   if (selectiveSR_ (theMat))
      rollVol -= allocedVol (theMat, reqPer, true);
@


1.35
log
@Continued implementation of PIP.
@
text
@d262 1
d280 3
a282 1
         incConsVol (theBomEnt, consVolVec, nonSubVolVec);
d286 5
a290 1
         incConsVol (theSub, consVolVec, theSub->subVol ());
@


1.34
log
@Removed a bad function overload.
@
text
@d19 1
@


1.33
log
@Continued implementation of post-implosion pegging.
@
text
@d80 1
a80 1
   theMat = thePart->myMat ();
d235 1
a235 1
   theMat = thePart->myMat ();
@


1.32
log
@Continued implementation of post-implosion pegging.
@
text
@a21 1
#include <ScheduleI.h>
d23 1
@


1.31
log
@Continued implementation of proportionate routing.
Fixed a bug in selection splitting for selective stock reallocation.
@
text
@a23 1
#include <FlexVecI.h>
@


1.30
log
@Continued implementation of proportionate routing.
@
text
@d145 2
a146 1
      double &      rollVol)
d168 6
a173 1
      mySsrMgr_->adjReqAndRollForSS (theMat, rollPer, theReqVol, rollVol);
@


1.29
log
@Continued implementation of proportionate routing.
@
text
@d81 1
a81 1
   thePart->getMaterial (theMat);
d230 1
a230 1
   thePart->getMaterial (theMat);
@


1.28
log
@Tried to fix some syntax errors from the MS compiler.
@
text
@d32 1
a32 1
      WitProbAssoc (theHeurAtor),
@


1.27
log
@Various internal changes.
@
text
@d273 1
a273 4
         myProblem ()->myPostprocessor ()->incConsVol (
            theBomEnt,
            consVolVec,
            nonSubVolVec);
d277 1
a277 4
         myProblem ()->myPostprocessor ()->incConsVol (
            theSub, 
            consVolVec, 
            theSub->subVol ());
@


1.26
log
@Internal changes.
@
text
@d273 4
a276 1
         incConsVol (theBomEnt, consVolVec, nonSubVolVec);
d280 4
a283 1
         incConsVol (theSub, consVolVec, theSub->subVol ());
@


1.25
log
@Internal changes.
@
text
@d192 1
a192 1
   witAssert (! theMat->mandEC ()[thePer]);
d222 1
a222 1
   if (! initUHSMode_)
d235 1
a235 1
         if (! initUHSMode_)
d324 1
a324 1
         if (! thePart->canStock (thePer))
d341 1
a341 1
         if (! theMat->producingBopEntries ().isEmpty ())
d353 1
a353 1
         if (theMat->buildNstn () || theMat->buildAsap ())
@


1.24
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d38 3
a40 3
      uncondSR_    (myProblem (), witFALSE),
      selectiveSR_ (myProblem (), witFALSE),
      initUHSMode_ (witFALSE)
d120 1
a120 1
   allVol    = allocedVol (theMat, reqPer, witFALSE);
d156 1
a156 1
      rollVol -= allocedVol (theMat, reqPer, witTRUE);
d259 1
a259 1
   initUHSMode_ = witTRUE;
d293 1
a293 1
   initUHSMode_ = witFALSE;
d342 1
a342 1
            uncondSR_ (theMat) = witTRUE; 
d356 1
a356 1
               uncondSR_ (theMat) = witTRUE; 
d361 1
a361 1
         selectiveSR_ (theMat) = witTRUE;
d376 1
a376 1
      WitBoolean    forSR)
d464 1
a464 1
WitBoolean WitAvailSched::srAllowedFrom (WitMaterial * theMat, WitPeriod thePer)
d467 1
a467 1
      uncondSR_    (theMat)? witTRUE:
d469 1
a469 1
                             witFALSE;
@


1.23
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@a302 7
   double    maxViol;
   WitPart * maxPart;
   WitPeriod maxPer;

   maxViol = 0.0;
   maxPart = NULL;
   maxPer  = -1;
d312 1
a312 1
         if (- availVol > maxViol)
d314 6
a319 3
            maxViol = - availVol;
            maxPart = thePart;
            maxPer  = thePer;
a327 6

   if (maxViol > FEAS_TOL)
      myMsgFac () ("uhsNNScrapConViolWmsg",
         maxPart->partName (),
         maxPer,
         - maxViol);
@


1.22
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@a18 1
#include <Global.h>
d40 1
a40 1
      initMode_    (witFALSE)
d42 5
a46 2
   WitPart *     thePart;
   WitMaterial * theMat;
d48 2
a49 2
   if (myGlobalComp ()->userHeurStart ())
      initFromSoln ();
d54 1
a54 28
   if (myGlobalComp ()->oldSR ())
      {
      myMsgFac () ("oldSRMsg");

      forEachMaterial (theMat, myProblem ())
         if (! theMat->producingBopEntries ().isEmpty ())
            uncondSR_ (theMat) = witTRUE; 
      }
   else if (myGlobalComp ()->stockReallocation ())
      {
      myMsgFac () ("stockReMsg");

      forEachMaterial (theMat, myProblem ())
         {
         if (theMat->producingBopEntries ().isEmpty ())
            continue;

         if (theMat->buildNstn () || theMat->buildAsap ())
            if (theMat->buildAheadUB () == myProblem ()->lastPeriod ())
               {
               uncondSR_ (theMat) = witTRUE; 

               continue;
               }

         selectiveSR_ (theMat) = witTRUE;
         }
      }
d222 1
a222 1
   if (! initMode_)
d235 1
a235 1
         if (! initMode_)
d244 1
a244 1
void WitAvailSched::initFromSoln ()
d259 1
a259 1
   initMode_ = witTRUE;
d293 81
a373 1
   initMode_ = witFALSE;
@


1.21
log
@Continued implementation of heuristic implosion from an initial solution.
Fixed a bug in build-ahead by demand.
Removed RWClient.C.
@
text
@d46 1
a46 1
   if (myGlobalComp ()->heurInitSoln ())
d282 1
a282 1
   myMsgFac () ("heurInitSolnMsg");
@


1.20
log
@Continued implementation of heuristic initial solution.
@
text
@d294 3
a296 2
         myProblem ()->myPostprocessor ()->
            compNonSubVol (theBomEnt, nonSubVolVec);
@


1.19
log
@Continued implementation of heuristic implosion from an initial solution.
Added some debugging code to Single-Source.
@
text
@d46 1
a46 1
   if (myGlobalComp ()->initHeurSoln ())
d282 1
a282 1
   myMsgFac () ("initHeurSolnMsg");
@


1.18
log
@Began implementation of heuristic implosion from an initial solution.
@
text
@d46 1
a46 1
   if (myGlobalComp ()->heurInitSoln ())
d282 1
a282 1
   myMsgFac () ("heurInitSolnMsg");
@


1.17
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d22 1
d40 2
a41 1
      selectiveSR_ (myProblem (), witFALSE)
d46 5
a50 2
   forEachPart (thePart, myProblem ())
      copyInto (incAvailVol_ (thePart), thePart->supplyVol ());
a58 1

d247 2
a248 1
   myHeurAtor_->saveVal (incAvailVolRef);
d260 2
a261 1
         myHeurAtor_->saveVal (lastDecPer_ (theMat));
d265 53
@


1.16
log
@Continued implementation of Single-Source.
@
text
@d24 1
@


1.15
log
@Continued implementation of Single-Source.
@
text
@d31 1
a31 1
      WitProbAssoc      (theHeurAtor),
d33 6
a38 10
      myHeurAtor_       (theHeurAtor),
      mySsrMgr_         (NULL),
      incAvailVol_      (myProblem (), 0.0),
      lastDecPer_       (myProblem (), -1),
      incResStockVol_   (),
      uncondSR_         (myProblem (), witFALSE),
      selectiveSR_      (myProblem (), witFALSE),
      sssMat_           (NULL),
      sssPer_           (-1),
      sssSavedIncAvVol_ (0.0)
a45 3
   if (myGlobalComp ()->respectStockSLBs ())
      incResStockVol_.allocate (myProblem (), 0.0);

d85 1
a85 1
void WitAvailSched::assocSsrMgr ()
d92 1
a92 1
void WitAvailSched::netWithIncAvail (
d94 1
a94 1
      WitPeriod thePer,
d97 1
a97 1
   double deltaVol;
d99 1
a99 1
   deltaVol = min (theReqVol, incAvailVol_ (thePart)[thePer]);
d101 1
a101 2
   if (deltaVol < NET_TOL)
      return;
d103 4
a106 3
   theReqVol -= deltaVol;

   addToIncAvailVol (thePart, thePer, - deltaVol);
d111 1
a111 1
void WitAvailSched::netWoSR (
d113 1
a113 1
      WitPeriod reqPer,
d116 3
a118 1
   WitMaterial * theMat;
d120 2
a121 1
   thePart->getMaterial (theMat);
d123 1
a123 2
   if (theMat == NULL)
      netWithIncAvail (thePart, reqPer, theReqVol);
d125 1
a125 4
   else if (srAllowedFrom (theMat, reqPer))
      netWoSRWoRes    (theMat,  reqPer, theReqVol);
   else
      netWoSRAndRes   (theMat,  reqPer, theReqVol);
d130 1
a130 1
void WitAvailSched::netWoSRAndRes (
d135 4
a138 3
   WitPeriod thePer;
   double    cumIncAv;
   double    deltaVol;
d140 1
a140 1
   witAssert (theReqVol >= NET_TOL);
d142 1
a142 1
   witAssert (! uncondSR_ (theMat));
d144 1
a144 4
   cumIncAv =
      selectiveSR_ (theMat)?
         - allocedVol (theMat, reqPer):
         0.0;
d146 4
a149 5
   for (thePer = reqPer; thePer >= 0; thePer --)
      {
      if (thePer < reqPer)
         if (theMat->mandEC ()[thePer])
            return;
d151 2
a152 1
      cumIncAv += incAvailVol_ (theMat)[thePer];
d154 1
a154 2
      if (cumIncAv < NET_TOL)
         continue;
d156 1
a156 11
      deltaVol   = min (theReqVol, cumIncAv);

      theReqVol -= deltaVol;

      allocWithRes (theMat, thePer, reqPer, deltaVol);

      if (theReqVol < NET_TOL)
         return;

      cumIncAv = 0.0;
      }
d169 1
a169 1
   witAssert (uncondSR_ (theMat) || selectiveSR_ (theMat));
d175 3
d186 1
d189 3
a191 2
   if (rollVol < NET_TOL)
      return -1;
a197 4
   if (incAvailVol_ (theMat)[reqPer] < - NET_TOL)
      if (! srAllowedFrom (theMat, reqPer))
         resConsStock (theMat, reqPer);

d203 4
a206 5
void WitAvailSched::alloc (
      WitPart * thePart,
      WitPeriod resPer,
      WitPeriod allocPer,
      double    allocVol)
d208 1
a208 1
   WitMaterial * theMat;
d210 1
a210 17
   thePart->getMaterial (theMat);

   if (theMat == NULL)
      addToIncAvailVol (thePart, allocPer, - allocVol);

   else if (srAllowedFrom (theMat, allocPer))
      addToIncAvailVol (theMat, allocPer, - allocVol);

   else
      allocWithRes (
         theMat,
         resPer,
         allocPer,
         allocVol);
   }

//------------------------------------------------------------------------------
d212 1
a212 8
void WitAvailSched::resConsStock (WitMaterial * theMat, WitPeriod consPer)
   {
   WitPeriod resPer;
   double    resVol;

   witAssert (selectiveSR_ (theMat));

   resPer = consPer;
d214 1
a214 3
   while (incAvailVol_ (theMat)[consPer] < - NET_TOL)
      {
      resPer --;
d216 1
a216 8
      if ((resPer < 0) || theMat->mandEC ()[resPer])
         {
         if (DEVELOPMENT)
            if (incAvailVol_ (theMat)[consPer] < -1.0E-5)
               myMsgFac () ("unmatchedRedWmsg",
                  theMat->partName (),
                  consPer,
                  - incAvailVol_ (theMat)[consPer]);
d218 1
a218 2
         return;
         }
d220 1
a220 28
      if (incAvailVol_ (theMat)[resPer] < NET_TOL)
         continue;

      resVol =
         min (
              incAvailVol_ (theMat)[resPer],
            - incAvailVol_ (theMat)[consPer]);

      reserveStock (theMat, resPer, consPer, resVol);
      }
   }

//------------------------------------------------------------------------------

void WitAvailSched::reserveStock (
      WitMaterial * theMat,
      WitPeriod     resPer,
      WitPeriod     relPer,
      double        resVol)
   {
   witAssert (resPer < relPer);

   addToIncAvailVol    (theMat, resPer, - resVol);

   if (relPer < nPeriods ())
      addToIncAvailVol (theMat, relPer,   resVol);

   if (! myGlobalComp ()->respectStockSLBs ())
d223 1
a223 2
   if (myHeurAtor_->tempMode ())
      return;
d225 2
a226 1
   incResStockVol_     (theMat)[resPer] += resVol;
d228 1
a228 2
   if (relPer < nPeriods ())
      incResStockVol_  (theMat)[relPer] -= resVol;
d261 4
a264 50

void WitAvailSched::reserveAllocedStSLB (WitMaterial * theMat, WitPeriod thePer)
   {
   double allVol;
   double unresVol;

   witAssert (myGlobalComp ()->respectStockSLBs ());

   if (! uncondSR_ (theMat))
      return;

   allVol = allocedVol (theMat, thePer);

   if (allVol < NET_TOL)
      return;

   unresVol = unresStSLB (theMat, thePer);

   if (unresVol < NET_TOL)
      return;

   reserveStock (theMat, thePer, thePer + 1,  min (allVol, unresVol));
   }

//------------------------------------------------------------------------------

double WitAvailSched::unresStSLB (WitMaterial * theMat, WitPeriod thePer)
   {
   double    unresVol;
   WitPeriod incPer;

   witAssert (myGlobalComp ()->respectStockSLBs ());

   unresVol = theMat->stockBounds ()->softLB ()[thePer];

   for (incPer = thePer; incPer >= 0; incPer --)
      {
      if (incPer < thePer)
         if (theMat->mandEC ()[incPer])
            break;

      unresVol -= incResStockVol_ (theMat)[incPer];

      if (unresVol < NET_TOL)
         return 0.0;
      }

   return unresVol;
   }

d267 1
a267 1
void WitAvailSched::netWoSRWoRes (
d270 1
a270 1
      double &      theReqVol)
d272 3
a274 4
   double allVol;
   double totReqVol;
   double availVol;
   double deltaVol;
d276 1
a276 1
   witAssert (theReqVol >= NET_TOL);
d278 3
a280 1
   allVol    = allocedVol (theMat, reqPer);
d282 5
a286 1
   totReqVol = theReqVol + allVol;
d288 5
a292 1
   availVol  = availToNet (theMat, reqPer, totReqVol);
d294 3
a296 14
   deltaVol  = 
      (availVol == totReqVol)?
         theReqVol:
         availVol - allVol;

   if (deltaVol < NET_TOL)
      return;

   theReqVol -= deltaVol;

   addToIncAvailVol (theMat, reqPer, - deltaVol);
   }

//------------------------------------------------------------------------------
d298 1
a298 14
void WitAvailSched::allocWithRes (
      WitMaterial * theMat,
      WitPeriod     resPer,
      WitPeriod     allocPer,
      double        allocVol)
   {
   witAssert (resPer <= allocPer);

   witAssert (! uncondSR_ (theMat));

   addToIncAvailVol (theMat, allocPer, - allocVol);

   if (resPer < allocPer)
      reserveStock (theMat, resPer, allocPer,  allocVol);
a337 24
double WitAvailSched::allocedVol (WitMaterial * theMat, WitPeriod reqPer)
   {
   double    curPreAllVol;
   double    maxPreAllVol;
   WitPeriod thePer;

   curPreAllVol = 0.0;
   maxPreAllVol = 0.0;

   for (thePer = reqPer + 1; thePer <= lastDecPer_ (theMat); thePer ++)
      {
      if (theMat->mandEC ()[thePer - 1])
         break;

      curPreAllVol -= incAvailVol_ (theMat)[thePer];

      setToMax (maxPreAllVol, curPreAllVol);
      }

   return maxPreAllVol;
   }

//------------------------------------------------------------------------------

d348 3
a350 2
         if (incAvailVol_ (theMat)[thePer] < - NET_TOL)
            return thePer;
@


1.14
log
@Continued implementation of single-source.
@
text
@d22 1
@


1.13
log
@Continued implementation of single source.
@
text
@d105 1
a105 1
   deltaVol = min (theReqVol, incAvailVol_ (thePart, thePer));
d161 1
a161 1
      cumIncAv += incAvailVol_ (theMat, thePer);
d213 1
a213 1
   if (incAvailVol_ (theMat, reqPer) < - NET_TOL)
d257 1
a257 1
   while (incAvailVol_ (theMat, consPer) < - NET_TOL)
d264 1
a264 1
            if (incAvailVol_ (theMat, consPer) < -1.0E-5)
d268 1
a268 1
                  - incAvailVol_ (theMat, consPer));
d273 1
a273 1
      if (incAvailVol_ (theMat, resPer) < NET_TOL)
d278 2
a279 2
              incAvailVol_ (theMat, resPer),
            - incAvailVol_ (theMat, consPer));
d306 1
a306 1
   incResStockVol_     (theMat, resPer) += resVol;
d309 1
a309 1
      incResStockVol_  (theMat, relPer) -= resVol;
d321 1
a321 1
   double & incAvailVolRef = incAvailVol_ (thePart, thePer);
d383 1
a383 1
      unresVol -= incResStockVol_ (theMat, incPer);
d464 1
a464 1
      theIncAvailVol = incAvailVol_ (theMat, thePer);
d494 1
a494 1
      curPreAllVol -= incAvailVol_ (theMat, thePer);
d514 1
a514 1
         if (incAvailVol_ (theMat, thePer) < - NET_TOL)
@


1.12
log
@Continued implementation of single source.
@
text
@a21 1
#include <Repos.h>
a35 1
      myDataRepos_      (* new WitDataRepos (myProblem ())),
a86 1
   delete & myDataRepos_;
d323 1
a323 2
   if (myHeurAtor_->tempMode ())
      myDataRepos_.saveVal (incAvailVolRef);
d335 1
a335 2
         if (myHeurAtor_->tempMode ())
            myDataRepos_.saveVal (lastDecPer_ (theMat));
a389 7
   }

//------------------------------------------------------------------------------

void WitAvailSched::restore ()
   {
   myDataRepos_.restore ();
@


1.11
log
@Continued preliminary work on single source.
@
text
@d22 1
a22 1
#include <Archive.h>
d37 1
d89 1
d327 1
a327 1
      myHeurAtor_->myDblArch ()->saveVal (incAvailVolRef);
d340 1
a340 1
            myHeurAtor_->myPerArch ()->saveVal (lastDecPer_ (theMat));
d395 7
@


1.10
log
@Continued implementation of object iteration.
@
text
@d20 2
@


1.9
log
@Began implementation of object iteration.
@
text
@d123 1
a123 1
   theMat = thePart->myMat ();
d229 1
a229 1
   theMat = thePart->myMat ();
d330 1
a330 1
   theMat = thePart->myMat ();
@


1.8
log
@Continued implementation of sel-split for pen-exec.
@
text
@d19 1
d21 1
d48 1
a48 1
   if (respectStockSLBs ())
d299 1
a299 1
   if (! respectStockSLBs ())
d349 1
a349 1
   witAssert (respectStockSLBs ());
d374 1
a374 1
   witAssert (respectStockSLBs ());
@


1.7
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d202 3
@


1.6
log
@Made stock reallocation use ssr vs. usr on a part-by-part basis.
@
text
@d27 1
a27 1
      WitProbAssoc    (theHeurAtor),
d29 10
a38 6
      myHeurAtor_     (theHeurAtor),
      incAvailVol_    (myProblem (), 0.0),
      lastDecPer_     (myProblem (), -1),
      incResStockVol_ (),
      uncondSR_       (myProblem (), witFALSE),
      selectiveSR_    (myProblem (), witFALSE)
d88 7
d197 5
a203 2
   rollPer = rollPeriod (theMat, reqPer);

d315 1
a315 1
   double & incAvailVolVar = incAvailVol_ (thePart, thePer);
d318 1
a318 1
      myHeurAtor_->myDblArch ()->saveVal (incAvailVolVar);
d320 1
a320 1
   incAvailVolVar += deltaVol;
d322 1
a322 1
   if (incAvailVolVar >= - NET_TOL)
d523 1
a523 2
      selectiveSR_ (theMat)? myHeurAtor_->
                                mySsrMgr ()->srAllowedFrom (theMat, thePer):
@


1.5
log
@Changed selStockRe attribute to stockReallocation (fullSR, internally).
@
text
@d33 2
a34 2
      pureUncondSR_   (myGlobalComp ()->pureUncondSR ()),
      fullSR_         (myGlobalComp ()-> fullSR ())
d36 2
a37 1
   WitPart * thePart;
d44 30
d134 1
a134 1
   witAssert (! pureUncondSR_);
d137 1
a137 1
      fullSR_?
d175 1
a175 1
   witAssert (pureUncondSR_ || fullSR_);
d233 1
a233 1
   witAssert (fullSR_);
d332 1
a332 1
   if (! pureUncondSR_)
d417 1
a417 1
   witAssert (! pureUncondSR_);
d508 4
a511 3
      pureUncondSR_? witTRUE:
      fullSR_?       myHeurAtor_->mySsrMgr ()->srAllowedFrom (theMat, thePer):
                     witFALSE;
@


1.4
log
@Replaced uncondStockRe attribute with the old stockRealloc attribute.
@
text
@d34 1
a34 1
      selStockRe_     (myGlobalComp ()-> selStockRe ())
d106 1
a106 1
      selStockRe_?
d144 1
a144 1
   witAssert (pureUncondSR_ || selStockRe_);
d202 1
a202 1
   witAssert (selStockRe_);
d478 1
a478 1
      selStockRe_?   myHeurAtor_->mySsrMgr ()->srAllowedFrom (theMat, thePer):
@


1.3
log
@Renamed mandatory stock reallocation to unconditional stock reallocation.
@
text
@d33 2
a34 2
      uncondStockRe_  (myGlobalComp ()->uncondStockRe ()),
       selStockRe_    (myGlobalComp ()-> selStockRe ())
d103 1
a103 1
   witAssert (! uncondStockRe_);
d144 1
a144 1
   witAssert (uncondStockRe_ || selStockRe_);
d301 1
a301 1
   if (! uncondStockRe_)
d386 1
a386 1
   witAssert (! uncondStockRe_);
d477 3
a479 3
      uncondStockRe_? witTRUE:
         selStockRe_? myHeurAtor_->mySsrMgr ()->srAllowedFrom (theMat, thePer):
                      witFALSE;
@


1.2
log
@Continued development of Selective Stock Reallocation.
@
text
@d33 1
a33 1
      mandStockRe_    (myGlobalComp ()->mandStockRe ()),
d103 1
a103 1
   witAssert (! mandStockRe_);
d144 1
a144 1
   witAssert (mandStockRe_ || selStockRe_);
d301 1
a301 1
   if (! mandStockRe_)
d386 1
a386 1
   witAssert (! mandStockRe_);
d477 3
a479 3
      mandStockRe_? witTRUE:
       selStockRe_? myHeurAtor_->mySsrMgr ()->srAllowedFrom (theMat, thePer):
                    witFALSE;
@


1.1
log
@Fixed bug in SSR:
   Needed to reserve stock when it was getting consumed in a period where
   stock reallocation was disallowed.

Fixed bug in SSR:
   Failed to create SsrPt in periods where explosion was not allowed, but
   requirements could still be filled by exploding in an earlier period.

Put implementation of class AvailSched into its own .C file.
@
text
@d53 19
d77 9
a85 2
   if (srAllowedFrom (thePart, reqPer))
      netWoSRWoRes  (thePart, reqPer, theReqVol);
d87 1
a87 1
      netWoSRAndRes (thePart, reqPer, theReqVol);
d93 3
a95 3
      WitPart * thePart,
      WitPeriod reqPer,
      double &  theReqVol)
d107 1
a107 1
         - allocedVol (thePart, reqPer):
d113 1
a113 1
         if (! thePart->canStock (thePer))
d116 1
a116 1
      cumIncAv += incAvailVol_ (thePart, thePer);
d125 1
a125 1
      allocWithRes (thePart, thePer, reqPer, deltaVol);
d137 4
a140 4
      WitPart * thePart, 
      WitPeriod reqPer,
      double &  theReqVol,
      double &  rollVol)
d142 1
a142 2
   WitPeriod     rollPer;
   WitMaterial * theMat;
d148 1
a148 1
   rollVol = availToNet (thePart, reqPer, theReqVol);
d155 1
a155 1
   addToIncAvailVol (thePart, reqPer, - rollVol);
d157 1
a157 1
   rollPer = rollPeriod (thePart, reqPer);
d160 1
a160 8
      addToIncAvailVol (thePart, rollPer, rollVol);

   if (incAvailVol_ (thePart, reqPer) < - NET_TOL)
      if (! srAllowedFrom (thePart, reqPer))
         {
         thePart->getMyMaterial (theMat);

         witAssert (theMat != NULL);
d162 2
a164 1
         }
d177 5
a181 1
   if (srAllowedFrom (thePart, allocPer))
d183 4
d189 1
a189 1
         thePart,
d277 10
a286 6
   if (incAvailVolVar < - NET_TOL)
      if (thePart->getMyMaterial (theMat))
         if (thePer > lastDecPer_ (theMat))
            {
            if (myHeurAtor_->tempMode ())
               myHeurAtor_->myPerArch ()->saveVal (lastDecPer_ (theMat));
d288 2
a289 2
            lastDecPer_ (theMat) = thePer;
            }
d346 3
a348 3
      WitPart * thePart,
      WitPeriod reqPer,
      double &  theReqVol)
d357 1
a357 1
   allVol    = allocedVol (thePart, reqPer);
d361 1
a361 1
   availVol  = availToNet (thePart, reqPer, totReqVol);
d373 1
a373 1
   addToIncAvailVol (thePart, reqPer, - deltaVol);
d379 4
a382 4
      WitPart * thePart,
      WitPeriod resPer,
      WitPeriod allocPer,
      double    allocVol)
a383 2
   WitMaterial * theMat;

d388 1
a388 8
   addToIncAvailVol (thePart, allocPer, - allocVol);

   if (resPer == allocPer)
      return;

   thePart->getMyMaterial (theMat);

   witAssert (theMat != NULL);
d390 2
a391 1
   reserveStock (theMat, resPer, allocPer,  allocVol);
d397 3
a399 3
      WitPart * thePart, 
      WitPeriod reqPer,
      double    theReqVol)
d412 1
a412 1
         if (! thePart->canStock (thePer))
d415 1
a415 1
      theIncAvailVol = incAvailVol_ (thePart, thePer);
d431 1
a431 1
double WitAvailSched::allocedVol (WitPart * thePart, WitPeriod reqPer)
d433 3
a435 7
   WitMaterial * theMat;
   double        curPreAllVol;
   double        maxPreAllVol;
   WitPeriod     thePer;

   if (! thePart->getMyMaterial (theMat))
      return 0.0;
d455 1
a455 1
WitPeriod WitAvailSched::rollPeriod (WitPart * thePart, WitPeriod fromPer)
d457 7
a463 2
   WitMaterial * theMat;
   WitPeriod     thePer;
d465 3
a467 10
   if (thePart->getMyMaterial (theMat))
      if (fromPer < lastDecPer_ (theMat))
         for (thePer = fromPer + 1; thePer < nPeriods (); thePer ++)
            {
            if (theMat->mandEC ()[thePer - 1])
               break;

            if (incAvailVol_ (theMat, thePer) < - NET_TOL)
               return thePer;
            }
d474 1
a474 1
WitBoolean WitAvailSched::srAllowedFrom (WitPart * thePart, WitPeriod thePer)
d476 4
a479 12
   WitMaterial * theMat;

   if (mandStockRe_)
      return witTRUE;

   if (! selStockRe_)
      return witFALSE;

   if (! thePart->getMyMaterial (theMat))
      return witFALSE;

   return myHeurAtor_->mySsrMgr ()->srAllowedFrom (theMat, thePer);
@


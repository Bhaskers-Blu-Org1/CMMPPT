head	1.45;
access;
symbols
	latest_sce_4_20_20060523:1.29.0.2
	sce_4_20_20060523:1.29
	latest_sce4_20_OSL:1.27.0.2
	sce_4_20_OSL:1.27
	sce_410_withVa:1.26
	sce_4_05_20040511:1.25
	sce_4_00_20040201:1.19
	nextGenBranch:1.18.0.2
	nextGenRoot:1.18
	sce_3_30_20030627:1.18
	EndRw-branch:1.15.0.4
	Root-of-EndRw:1.15
	rwToStl:1.15.0.2
	latest_sce_3_10_20010924:1.6.0.2
	sce_3_10_20010924:1.6
	latest_sce_3_00_20010601:1.5.0.6
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.4
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2007.06.26.19.06.21;	author rjw;	state dead;
branches;
next	1.44;

1.44
date	2007.06.22.19.04.04;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.08.17.02.54;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.02.22.11.02;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.28.22.15.48;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.29.23.35.16;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.29.22.34.12;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.01.21.36.36;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.01.19.55.17;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.12.20.48.11;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.10.03.15.09.00;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2006.08.18.22.29.01;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.18.18.43.39;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.17.22.50.37;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.17.19.36.40;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.16.19.51.22;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.02.17.34.08;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.21.21.40.04;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.04.19.53.50;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.13.16.48.47;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.05.00.06.54;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.03.20.05.07;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.03.19.07.27;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.20.15.37.36;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.06.23.27.10;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.18.18.30.17;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.23.20.47.18;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.02.23.40.47;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.22.18.42;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.11.18.53.13;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.06.19.56.10;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.04.19.14.58;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.29.23.06.29;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.26.22.49.07;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.26.20.16.09;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.23.21.00.40;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.23.18.09.15;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.20.15.01;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.01.19.23.34;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.20.12.34;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.25;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.33;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.42;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.28;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.28;	author wit;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Stochastic Implosion
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "PerVar.C"
//
// Implementation the following classes:
//
//    PeriodVar
//    ScrapVar
//    NonSubVar
//    SubVar
//    ShipVar
//    SlbvVar
//    BoundedVar
//    ExecVar
//    StockVar
//    CumShipVar
//------------------------------------------------------------------------------

#include <PerVar.h>
#include <DetImpOP.h>
#include <OptImp.h>
#include <OptComp.h>
#include <Material.h>
#include <Opn.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Demand.h>
#include <BoundSet.h>

#include <float.h>

//------------------------------------------------------------------------------
// Implementation of class PeriodVar.
//------------------------------------------------------------------------------

WitPeriodVar::WitPeriodVar (WitDetImpOP * theDetImpOP, WitPeriod t):

      WitOptVar (theDetImpOP),

      myPeriod_ (t)
   {
   }

//------------------------------------------------------------------------------

WitPeriodVar::~WitPeriodVar ()
   {
   }

//------------------------------------------------------------------------------

void WitPeriodVar::printSource () const
   {
   printItem ();

   myDetImpOP ()->printPeriod (myPeriod ());
   }

//------------------------------------------------------------------------------
// Implementation of class ScrapVar.
//------------------------------------------------------------------------------

WitScrapVar::WitScrapVar (
         WitPart *     thePart,
         WitPeriod     t,
         WitDetImpOP * theDetImpOP):

      WitPeriodVar (theDetImpOP, t),

      myPart_      (thePart)
   {
   myDetImpOP ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitScrapVar::~WitScrapVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitScrapVar::classText () const
   {
   return "Scrap";
   }

//------------------------------------------------------------------------------

void WitScrapVar::printItem () const
   {
   myDetImpOP ()->printItem (myPart ());
   }

//------------------------------------------------------------------------------

double WitScrapVar::indepInitValue () const
   {
   return myPart ()->scrapVol ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitScrapVar::primaryCoeffVal () const
   {
   return - myPart ()->scrapCost ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitScrapVar::revCoeffVal () const
   {
   return - myPart ()->unitCost ();
   }

//------------------------------------------------------------------------------
// Implementation of class NonSubVar.
//------------------------------------------------------------------------------

WitNonSubVar::WitNonSubVar (
          WitBomEntry * theBomEnt,
          WitPeriod     t,
          WitDetImpOP * theDetImpOP):

      WitPeriodVar (theDetImpOP, t),

      myBomEnt_    (theBomEnt)
   {
   myDetImpOP ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitNonSubVar::~WitNonSubVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitNonSubVar::classText () const
   {
   return "Non-Sub";
   }

//------------------------------------------------------------------------------

void WitNonSubVar::printItem () const
   {
   myDetImpOP ()->printItem (myBomEnt ());
   }

//------------------------------------------------------------------------------

double WitNonSubVar::indepInitValue () const
   {
   return myBomEnt ()->nonSubVol ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitNonSubVar::invCoeffVal () const
   {
   return
      myBomEnt ()->effCost (myPeriod ())                        *
      (myPeriod () - myBomEnt ()->impactPeriod ()[myPeriod ()]) /
      static_cast <double> (myOptImploder ()->nPeriods ());
   }

//------------------------------------------------------------------------------
// Implementation of class SubVar.
//------------------------------------------------------------------------------

WitSubVar::WitSubVar (
          WitSubEntry * theSub,
          WitPeriod     t,
          WitDetImpOP * theDetImpOP):

      WitPeriodVar (theDetImpOP, t),

      mySub_       (theSub)
   {
   myDetImpOP ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitSubVar::~WitSubVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitSubVar::classText () const
   {
   return "Substitute";
   }

//------------------------------------------------------------------------------

void WitSubVar::printItem () const
   {
   myDetImpOP ()->printItem (mySub ());
   }

//------------------------------------------------------------------------------

double WitSubVar::indepInitValue () const
   {
   return mySub ()->subVol ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitSubVar::primaryCoeffVal () const
   {
   return - mySub ()->subCost ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitSubVar::revCoeffVal () const
   {
   return + mySub ()->myBomEnt ()->effCost (myPeriod ())
          - mySub ()             ->effCost (myPeriod ());
   }

//------------------------------------------------------------------------------

double WitSubVar::invCoeffVal () const
   {
   return
      mySub ()->effCost (myPeriod ())                        *
      (myPeriod () - mySub ()->impactPeriod ()[myPeriod ()]) /
      static_cast <double> (myOptImploder ()->nPeriods ());
   }

//------------------------------------------------------------------------------

double WitSubVar::subCoeffVal () const
   {
   return mySub ()->obj2SubPenalty ();
   }

//------------------------------------------------------------------------------

bool WitSubVar::isAnIntVar () const
   {
   return mySub ()->intSubVols ();
   }

//------------------------------------------------------------------------------
// Implementation of class ShipVar.
//------------------------------------------------------------------------------

WitShipVar::WitShipVar (
         WitDemand *   theDemand,
         WitPeriod     t,
         WitDetImpOP * theDetImpOP):

      WitPeriodVar (theDetImpOP, t),

      myDemand_    (theDemand)
   {
   myDetImpOP ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitShipVar::~WitShipVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitShipVar::classText () const
   {
   return "Shipment";
   }

//------------------------------------------------------------------------------

void WitShipVar::printItem () const
   {
   myDetImpOP ()->printItem (myDemand ());
   }

//------------------------------------------------------------------------------

void WitShipVar::compBounds ()
   {
   if (myDemand ()->shipLateAllowed ())
      WitPeriodVar::compBounds ();
   else
      setBoundsTo (0.0, myDemand ()->demandVol ()[myPeriod ()]);
   }

//------------------------------------------------------------------------------

double WitShipVar::indepInitValue () const
   {
   return myDemand ()->shipVol ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitShipVar::primaryCoeffVal () const
   {
   return + myDemand ()->shipReward ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitShipVar::revCoeffVal () const
   {
   return + myDemand ()->netRev ();
   }

//------------------------------------------------------------------------------

bool WitShipVar::isAnIntVar () const
   {
   return myDemand ()->intShipVols ();
   }

//------------------------------------------------------------------------------
// Implementation of class SlbvVar.
//------------------------------------------------------------------------------

WitSlbvVar::WitSlbvVar (
         WitBoundedVar * theBoundedVar,
         WitDetImpOP *   theDetImpOP):

      WitPeriodVar  (theDetImpOP, theBoundedVar->myPeriod ()),

      myBoundedVar_ (theBoundedVar)
   {
   myDetImpOP ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitSlbvVar::~WitSlbvVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitSlbvVar::classText () const
   {
   return "S. L. B. V.";
   }

//------------------------------------------------------------------------------

void WitSlbvVar::printItem () const
   {
   myDetImpOP ()->printItem (myBoundedVar_);
   }

//------------------------------------------------------------------------------

double WitSlbvVar::boundsCoeffVal () const
   {
   return 1.0;
   }

//------------------------------------------------------------------------------
// Implementation of class BoundedVar.
//------------------------------------------------------------------------------

WitBoundedVar::WitBoundedVar (WitDetImpOP * theDetImpOP, WitPeriod t):

      WitPeriodVar (theDetImpOP, t)
   {
   myDetImpOP ()->storeBoundedVar (this);
   }

//------------------------------------------------------------------------------

WitBoundedVar::~WitBoundedVar ()
   {
   }

//------------------------------------------------------------------------------

void WitBoundedVar::compBounds ()
   {
   compSpecBounds ();

   setToMax (bounds ().lower (), hardLB ());
   setToMin (bounds ().upper (), hardUB ());
   }

//------------------------------------------------------------------------------

double WitBoundedVar::hardLB () const
   {
   return myBoundSet ()->hardLB () [myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitBoundedVar::softLB () const
   {
   return myBoundSet ()->softLB () [myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitBoundedVar::hardUB () const
   {
   return
      (myBoundSet ()->hardUBIsFinite (myPeriod ()))?
         myBoundSet ()->hardUB () [myPeriod ()]:
         + DBL_MAX;
   }

//------------------------------------------------------------------------------

bool WitBoundedVar::needsAnSlbvVar () const
   {
   if (myOptImploder ()->myOptComp ()->accAfterSoftLB ())
      return true;

   if (softLB () > hardLB () + FLOAT_EPSILON)
      return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitBoundedVar::printBoundInfo ()
   {
   fprintf      (myOptProb ()->optProbFile (), "%8d",            index ());
   fprintf      (myOptProb ()->optProbFile (), " %9.1f",         hardLB ());
   fprintf      (myOptProb ()->optProbFile (), " %9.1f",         softLB ());
   writeExtReal (myOptProb ()->optProbFile (), " %9.1f", " %9s", hardUB ());
   fprintf      (myOptProb ()->optProbFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitBoundedVar::printSoln ()
   {
   WitSlbvVar * theSlbvVar;
   double       slbvVal;

   theSlbvVar = myDetImpOP ()->mySlbvVar (this);

   slbvVal =
      (theSlbvVar == NULL)?
         0.0:
         theSlbvVar->primalValue ();

   fprintf      (myDetImpOP ()->solnFile (), " %8d",   index ());
   fprintf      (myDetImpOP ()->solnFile (), " %9.1f", hardLB ());
   fprintf      (myDetImpOP ()->solnFile (), " %9.1f", softLB ());
   fprintf      (myDetImpOP ()->solnFile (), " %9.1f", slbvVal);
   fprintf      (myDetImpOP ()->solnFile (), " %9.1f", primalValue ());
   writeExtReal (myDetImpOP ()->solnFile (), " %9.1f", " %9s",   hardUB ());
   fprintf      (myDetImpOP ()->solnFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitBoundedVar::compSpecBounds ()
   {
   setBoundsTo (0.0, + DBL_MAX);
   }

//------------------------------------------------------------------------------
// Implementation of class ExecVar.
//------------------------------------------------------------------------------

WitExecVar::WitExecVar (
         WitOperation * theOpn,
         WitPeriod      thePer,
         WitDetImpOP *  theDetImpOP):

      WitBoundedVar (theDetImpOP, thePer),

      myOperation_  (theOpn)
   {
   myDetImpOP ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitExecVar::~WitExecVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitExecVar::classText () const
   {
   return "Execution";
   }

//------------------------------------------------------------------------------

void WitExecVar::printItem () const
   {
   myDetImpOP ()->printItem (myOperation ());
   }

//------------------------------------------------------------------------------

double WitExecVar::indepInitValue () const
   {
   return myOperation ()->execVol ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitExecVar::primaryCoeffVal () const
   {
   return - myOperation ()->execCost ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitExecVar::revCoeffVal () const
   {
   return - myOperation ()->obj2AuxCost ();
   }

//------------------------------------------------------------------------------

double WitExecVar::invCoeffVal () const
   {
   WitBomEntry * theBomEnt;
   WitBopEntry * theBopEnt;
   double        sum;

   sum = 0.0;

   forEachEl (theBomEnt, myOperation ()->bom ())
      if (theBomEnt->inEffect (myPeriod ()))
         if (not theBomEnt->hasSubsInEffect ()[myPeriod ()])
            sum +=
               (myPeriod () - theBomEnt->impactPeriod ()[myPeriod ()]) *
               theBomEnt->effCost (myPeriod ());

   forEachEl (theBopEnt, myOperation ()->bop ())
      if (theBopEnt->inEffect (myPeriod ()))
         sum -=
            (myPeriod () - theBopEnt->impactPeriod ()[myPeriod ()]) *
            theBopEnt->effProdRate ()[myPeriod ()] *
            theBopEnt->myPart ()->unitCost ();

   return sum / static_cast <double> (myOptImploder ()->nPeriods ());
   }

//------------------------------------------------------------------------------

bool WitExecVar::isAnIntVar () const
   {
   return myOperation ()->intExecVols ();
   }

//------------------------------------------------------------------------------

const WitBoundSet * WitExecVar::myBoundSet () const
   {
   return myOperation ()->execBounds ();
   }

//------------------------------------------------------------------------------
// Implementation of class StockVar.
//------------------------------------------------------------------------------

WitStockVar::WitStockVar (
         WitMaterial * theMat,
         WitPeriod     t,
         WitDetImpOP * theDetImpOP):

      WitBoundedVar (theDetImpOP, t),

      myMaterial_   (theMat)
   {
   myDetImpOP ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitStockVar::~WitStockVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitStockVar::classText () const
   {
   return "Stock";
   }

//------------------------------------------------------------------------------

void WitStockVar::printItem () const
   {
   myDetImpOP ()->printItem (myMaterial ());
   }

//------------------------------------------------------------------------------

double WitStockVar::indepInitValue () const
   {
   return myMaterial ()->stockVol ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitStockVar::primaryCoeffVal () const
   {
   return - myMaterial ()->stockCost ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitStockVar::invCoeffVal () const
   {
   return
        myMaterial ()->unitCost ()
      / static_cast <double> (myOptImploder ()->nPeriods ());
   }

//------------------------------------------------------------------------------

const WitBoundSet * WitStockVar::myBoundSet () const
   {
   return myMaterial ()->stockBounds ();
   }

//------------------------------------------------------------------------------
// Implementation of class CumShipVar.
//------------------------------------------------------------------------------

WitCumShipVar::WitCumShipVar (
         WitDemand *   theDemand,
         WitPeriod     t,
         WitDetImpOP * theDetImpOP):

      WitBoundedVar (theDetImpOP, t),

      myDemand_     (theDemand)
   {
   myDetImpOP ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitCumShipVar::~WitCumShipVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitCumShipVar::classText () const
   {
   return "Cum. Ship";
   }

//------------------------------------------------------------------------------

void WitCumShipVar::printItem () const
   {
   myDetImpOP ()->printItem (myDemand ());
   }

//------------------------------------------------------------------------------

double WitCumShipVar::indepInitValue () const
   {
   return myDemand ()->cumShipVol ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

const WitBoundSet * WitCumShipVar::myBoundSet () const
   {
   return myDemand ()->cumShipBounds ();
   }

//------------------------------------------------------------------------------

double WitCumShipVar::primaryCoeffVal () const
   {
   return + myDemand ()->cumShipReward ()[myPeriod ()];
   }

//------------------------------------------------------------------------------

double WitCumShipVar::servCoeffVal () const
   {
   if (   myOptImploder ()->myOptComp ()->myObjFunc2 ()->totalServiceScale ()
       <= FLOAT_EPSILON)
      return 0.0;

   return
      myDemand ()->netRev () /
      myOptImploder ()->myOptComp ()->myObjFunc2 ()->totalServiceScale ();
   }

//------------------------------------------------------------------------------

void WitCumShipVar::compSpecBounds ()
   {
   setBoundsTo (0.0, myDemand ()->cumDemandVol ()[myPeriod ()]);
   }
@


1.44
log
@Stochastic Implosion
@
text
@@


1.43
log
@[disallowed backlog]
@
text
@d28 1
a28 1
#include <ImpOptProb.h>
d45 1
a45 1
WitPeriodVar::WitPeriodVar (WitImpOptProb * theImpOptProb, WitPeriod t):
d47 1
a47 1
      WitOptVar (theImpOptProb),
d65 1
a65 1
   myImpOptProb ()->printPeriod (myPeriod ());
d73 3
a75 3
         WitPart *       thePart,
         WitPeriod       t,
         WitImpOptProb * theImpOptProb):
d77 1
a77 1
      WitPeriodVar (theImpOptProb, t),
d81 1
a81 1
   myImpOptProb ()->storeDerived (this);
d101 1
a101 1
   myImpOptProb ()->printItem (myPart ());
d130 3
a132 3
          WitBomEntry *   theBomEnt,
          WitPeriod       t,
          WitImpOptProb * theImpOptProb):
d134 1
a134 1
      WitPeriodVar (theImpOptProb, t),
d138 1
a138 1
   myImpOptProb ()->storeDerived (this);
d158 1
a158 1
   myImpOptProb ()->printItem (myBomEnt ());
d183 3
a185 3
          WitSubEntry *   theSub,
          WitPeriod       t,
          WitImpOptProb * theImpOptProb):
d187 1
a187 1
      WitPeriodVar (theImpOptProb, t),
d191 1
a191 1
   myImpOptProb ()->storeDerived (this);
d211 1
a211 1
   myImpOptProb ()->printItem (mySub ());
d265 3
a267 3
         WitDemand *     theDemand,
         WitPeriod       t,
         WitImpOptProb * theImpOptProb):
d269 1
a269 1
      WitPeriodVar (theImpOptProb, t),
d273 1
a273 1
   myImpOptProb ()->storeDerived (this);
d293 1
a293 1
   myImpOptProb ()->printItem (myDemand ());
d340 1
a340 1
         WitImpOptProb * theImpOptProb):
d342 1
a342 1
      WitPeriodVar  (theImpOptProb, theBoundedVar->myPeriod ()),
d346 1
a346 1
   myImpOptProb ()->storeDerived (this);
d366 1
a366 1
   myImpOptProb ()->printItem (myBoundedVar_);
d380 1
a380 1
WitBoundedVar::WitBoundedVar (WitImpOptProb * theImpOptProb, WitPeriod t):
d382 1
a382 1
      WitPeriodVar (theImpOptProb, t)
d384 1
a384 1
   myImpOptProb ()->storeBoundedVar (this);
d458 1
a458 1
   theSlbvVar = myImpOptProb ()->mySlbvVar (this);
d465 7
a471 7
   fprintf      (myImpOptProb ()->solnFile (), " %8d",   index ());
   fprintf      (myImpOptProb ()->solnFile (), " %9.1f", hardLB ());
   fprintf      (myImpOptProb ()->solnFile (), " %9.1f", softLB ());
   fprintf      (myImpOptProb ()->solnFile (), " %9.1f", slbvVal);
   fprintf      (myImpOptProb ()->solnFile (), " %9.1f", primalValue ());
   writeExtReal (myImpOptProb ()->solnFile (), " %9.1f", " %9s",   hardUB ());
   fprintf      (myImpOptProb ()->solnFile (), "\n");
d486 3
a488 3
         WitOperation *  theOpn,
         WitPeriod       thePer,
         WitImpOptProb * theImpOptProb):
d490 1
a490 1
      WitBoundedVar (theImpOptProb, thePer),
d494 1
a494 1
   myImpOptProb ()->storeDerived (this);
d514 1
a514 1
   myImpOptProb ()->printItem (myOperation ());
d584 3
a586 3
         WitMaterial *   theMat,
         WitPeriod       t,
         WitImpOptProb * theImpOptProb):
d588 1
a588 1
      WitBoundedVar (theImpOptProb, t),
d592 1
a592 1
   myImpOptProb ()->storeDerived (this);
d612 1
a612 1
   myImpOptProb ()->printItem (myMaterial ());
d650 3
a652 3
         WitDemand *     theDemand,
         WitPeriod       t,
         WitImpOptProb * theImpOptProb):
d654 1
a654 1
      WitBoundedVar (theImpOptProb, t),
d658 1
a658 1
   myImpOptProb ()->storeDerived (this);
d678 1
a678 1
   myImpOptProb ()->printItem (myDemand ());
@


1.42
log
@[disallowed backlog]
@
text
@d300 1
a300 1
   if (myDemand ()->backlogAllowed ())
@


1.41
log
@[disallowed backlog]
@
text
@d300 3
a302 1
   if (myDemand ()->disallowBacklog ())
a303 2
   else
      WitPeriodVar::compBounds ();
@


1.40
log
@{backlog avoidance]
@
text
@d300 3
a302 1
   if (myDemand ()->backlogAllowed ())
a303 2
   else
      setBoundsTo (0.0, myDemand ()->demandVol ()[myPeriod ()]);
@


1.39
log
@[backlog avoidance]
@
text
@a297 2
#if 0

a305 2
#endif

@


1.38
log
@External opt implosion.
@
text
@d298 14
@


1.37
log
@External opt implosion.
@
text
@d257 1
a257 4
   return
      mySub ()->myOptComp ()->enforceIntCons ()
      and
      mySub ()->intSubVols ();
d321 1
a321 4
   return
      myDemand ()->myOptComp ()->enforceIntCons ()
      and
      myDemand ()->intShipVols ();
d559 1
a559 4
   return
      myOperation ()->myOptComp ()->enforceIntCons ()
      and
      myOperation ()->intExecVols ();
@


1.36
log
@External opt implosion.
@
text
@d257 4
a260 1
   return mySub ()->intSubVols ();
d324 4
a327 1
   return myDemand ()->intShipVols ();
d565 4
a568 1
   return myOperation ()->intExecVols ();
@


1.35
log
@App controlled opt implosion.
@
text
@d257 1
a257 1
   return mySub ()->intConSubVols ();
d321 1
a321 1
   return myDemand ()->intConShipVols ();
d559 1
a559 1
   return myOperation ()->intConExecVols ();
@


1.34
log
@App controlled opt implode.
@
text
@d387 1
a387 1
   compModelBounds ();
d434 5
a438 5
   fprintf      (myOptProb ()->modelFile (), "%8d",            index ());
   fprintf      (myOptProb ()->modelFile (), " %9.1f",         hardLB ());
   fprintf      (myOptProb ()->modelFile (), " %9.1f",         softLB ());
   writeExtReal (myOptProb ()->modelFile (), " %9.1f", " %9s", hardUB ());
   fprintf      (myOptProb ()->modelFile (), "\n");
d466 1
a466 1
void WitBoundedVar::compModelBounds ()
d707 1
a707 1
void WitCumShipVar::compModelBounds ()
@


1.33
log
@App controlled opt implosion.
@
text
@a40 2
#ifdef OPT_IMPLODE

a710 2

#endif
@


1.32
log
@Integrality constraints.
@
text
@d28 1
a28 1
#include <ImpOM.h>
d47 1
a47 1
WitPeriodVar::WitPeriodVar (WitImpOM * theImpOM, WitPeriod t):
d49 1
a49 1
      WitOptVar (theImpOM),
d67 1
a67 1
   myImpOM ()->printPeriod (myPeriod ());
d74 4
a77 1
WitScrapVar::WitScrapVar (WitPart * thePart, WitPeriod t, WitImpOM * theImpOM):
d79 1
a79 1
      WitPeriodVar (theImpOM, t),
d83 1
a83 1
   myImpOM ()->storeDerived (this);
d103 1
a103 1
   myImpOM ()->printItem (myPart ());
d132 3
a134 3
          WitBomEntry * theBomEnt,
          WitPeriod t,
          WitImpOM * theImpOM):
d136 1
a136 1
      WitPeriodVar (theImpOM, t),
d140 1
a140 1
   myImpOM ()->storeDerived (this);
d160 1
a160 1
   myImpOM ()->printItem (myBomEnt ());
d185 3
a187 3
          WitSubEntry * theSub,
          WitPeriod t,
          WitImpOM * theImpOM):
d189 1
a189 1
      WitPeriodVar (theImpOM, t),
d193 1
a193 1
   myImpOM ()->storeDerived (this);
d213 1
a213 1
   myImpOM ()->printItem (mySub ());
d267 3
a269 3
         WitDemand * theDemand,
         WitPeriod t,
         WitImpOM * theImpOM):
d271 1
a271 1
      WitPeriodVar (theImpOM, t),
d275 1
a275 1
   myImpOM ()->storeDerived (this);
d295 1
a295 1
   myImpOM ()->printItem (myDemand ());
d330 3
a332 1
WitSlbvVar::WitSlbvVar (WitBoundedVar * theBoundedVar, WitImpOM * theImpOM):
d334 1
a334 1
      WitPeriodVar  (theImpOM, theBoundedVar->myPeriod ()),
d338 1
a338 1
   myImpOM ()->storeDerived (this);
d358 1
a358 1
   myImpOM ()->printItem (myBoundedVar_);
d372 1
a372 1
WitBoundedVar::WitBoundedVar (WitImpOM * theImpOM, WitPeriod t):
d374 1
a374 1
      WitPeriodVar (theImpOM, t)
d376 1
a376 1
   myImpOM ()->storeBoundedVar (this);
d436 5
a440 6
   fprintf (myOptModel ()->modelFile (), "%8d",            index ());
   fprintf (myOptModel ()->modelFile (), " %9.1f",         hardLB ());
   fprintf (myOptModel ()->modelFile (), " %9.1f",         softLB ());
   writeExtReal
           (myOptModel ()->modelFile (), " %9.1f", " %9s", hardUB ());
   fprintf (myOptModel ()->modelFile (), "\n");
d450 1
a450 1
   theSlbvVar = myImpOM ()->mySlbvVar (this);
d457 7
a463 8
   fprintf (myImpOM ()->solnFile (), " %8d",   index ());
   fprintf (myImpOM ()->solnFile (), " %9.1f", hardLB ());
   fprintf (myImpOM ()->solnFile (), " %9.1f", softLB ());
   fprintf (myImpOM ()->solnFile (), " %9.1f", slbvVal);
   fprintf (myImpOM ()->solnFile (), " %9.1f", primalValue ());
   writeExtReal
           (myImpOM ()->solnFile (), " %9.1f", " %9s",   hardUB ());
   fprintf (myImpOM ()->solnFile (), "\n");
d478 3
a480 3
         WitOperation * theOpn,
         WitPeriod      thePer,
         WitImpOM *     theImpOM):
d482 1
a482 1
      WitBoundedVar (theImpOM, thePer),
d486 1
a486 1
   myImpOM ()->storeDerived (this);
d506 1
a506 1
   myImpOM ()->printItem (myOperation ());
d576 3
a578 3
         WitMaterial * theMat,
         WitPeriod t,
         WitImpOM * theImpOM):
d580 1
a580 1
      WitBoundedVar (theImpOM, t),
d584 1
a584 1
   myImpOM ()->storeDerived (this);
d604 1
a604 1
   myImpOM ()->printItem (myMaterial ());
d642 3
a644 3
         WitDemand * theDemand,
         WitPeriod t,
         WitImpOM * theImpOM):
d646 1
a646 1
      WitBoundedVar (theImpOM, t),
d650 1
a650 1
   myImpOM ()->storeDerived (this);
d670 1
a670 1
   myImpOM ()->printItem (myDemand ());
@


1.31
log
@Removed optimizing implosion with lot sizes.
@
text
@d256 1
a256 1
   return mySub ()->intSubVols ();
d320 1
a320 1
   return myDemand ()->intShipVols ();
d558 1
a558 1
   return myOperation ()->intExecVols ();
@


1.30
log
@Integrality constraints.
@
text
@a20 2
//    IlsMultVar
//    MlsMultVar
a363 129
// Implementation of class IlsMultVar.
//------------------------------------------------------------------------------

WitIlsMultVar::WitIlsMultVar (
         WitOperation * theOpn, 
         WitPeriod      thePer, 
         WitImpOM *     theImpOM):

      WitPeriodVar (theImpOM, thePer),

      myOpn_       (theOpn)
   {
   witAssert (myOpn_->myOptComp ()->optWithLotSizes ());

   myImpOM ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitIlsMultVar::~WitIlsMultVar ()
   {
   }

//------------------------------------------------------------------------------

void WitIlsMultVar::compBounds ()
   {
   int lsr;

   if (myImpOM ()->mlsMode (myOpn (), myPeriod ()))
      {
      lsr = myImpOM ()->myOptImploder ()->lotSizeRatio (myOpn (), myPeriod ());

      setBoundsTo (0.0, lsr - 1);
      }
   else
      setBoundsTo (0.0, + DBL_MAX);
   }

//------------------------------------------------------------------------------

const char * WitIlsMultVar::classText () const
   {
   return "ILS Mult.";
   }

//------------------------------------------------------------------------------

void WitIlsMultVar::printItem () const
   {
   myImpOM ()->printItem (myOpn ());
   }

//------------------------------------------------------------------------------

double WitIlsMultVar::indepInitValue () const
   {
   if (myImpOM ()->mlsMode (myOpn (), myPeriod ()))
      return 0.0;
   else
      return 
           myOpn ()->execVol ()[myPeriod ()]
         / static_cast <double> (
              myOptImploder ()->incLotSize (myOpn (), myPeriod ()));
   }

//------------------------------------------------------------------------------

bool WitIlsMultVar::isAnIntVar () const
   {
   return true;
   }

//------------------------------------------------------------------------------
// Implementation of class MlsMultVar.
//------------------------------------------------------------------------------

WitMlsMultVar::WitMlsMultVar (
         WitOperation * theOpn, 
         WitPeriod      thePer, 
         WitImpOM *     theImpOM):

      WitPeriodVar (theImpOM, thePer),

      myOpn_       (theOpn)
   {
   witAssert (myOpn_->myOptComp ()->optWithLotSizes ());

   myImpOM ()->storeDerived (this);
   }

//------------------------------------------------------------------------------

WitMlsMultVar::~WitMlsMultVar ()
   {
   }

//------------------------------------------------------------------------------

const char * WitMlsMultVar::classText () const
   {
   return "MLS Mult.";
   }

//------------------------------------------------------------------------------

void WitMlsMultVar::printItem () const
   {
   myImpOM ()->printItem (myOpn ());
   }

//------------------------------------------------------------------------------

double WitMlsMultVar::indepInitValue () const
   {
   return 
        myOpn ()->execVol ()[myPeriod ()]
      / static_cast <double> (
           myOptImploder ()->minLotSize (myOpn (), myPeriod ()));
   }

//------------------------------------------------------------------------------

bool WitMlsMultVar::isAnIntVar () const
   {
   return true;
   }

//------------------------------------------------------------------------------
d481 1
a481 2
      myOperation_  (theOpn),
      isAnIntVar_   (false)
a482 4
   isAnIntVar_ =
         theOpn->intExecVols ()
      or myImpOM ()->ls1Mode (theOpn, thePer);

d558 1
a558 1
   return isAnIntVar_;
@


1.29
log
@Updated the copyright date on all source files.
@
text
@d255 7
d319 7
d615 3
a617 1
   isAnIntVar_ = myImpOM ()->ls1Mode (theOpn, thePer);
@


1.28
log
@Removed some more OSL items.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.27
log
@[multi-thread]
@
text
@d41 2
d388 1
a388 1
      setBoundsTo (0.0, + OSL_INFTY);
d528 1
a528 1
         + OSL_INFTY;
d584 1
a584 1
   setBoundsTo (0.0, + OSL_INFTY);
@


1.26
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@d546 3
a548 3
   fprintf (WitOptModel::modelFile (), "%8d",            index ());
   fprintf (WitOptModel::modelFile (), " %9.1f",         hardLB ());
   fprintf (WitOptModel::modelFile (), " %9.1f",         softLB ());
d550 2
a551 2
           (WitOptModel::modelFile (), " %9.1f", " %9s", hardUB ());
   fprintf (WitOptModel::modelFile (), "\n");
@


1.25
log
@Double Precision.
@
text
@d114 1
a114 1
   return - myPart ()->obj1ScrapCost ()[myPeriod ()];
d224 1
a224 1
   return - mySub ()->obj1SubCost ()[myPeriod ()];
d299 1
a299 1
   return + myDemand ()->obj1ShipReward ()[myPeriod ()];
d635 1
a635 1
   return - myOperation ()->obj1ExecCost ()[myPeriod ()];
d733 1
a733 1
   return - myMaterial ()->obj1StockCost ()[myPeriod ()];
d806 1
a806 1
   return + myDemand ()->obj1CumShipReward ()[myPeriod ()];
@


1.24
log
@Double Precision.
@
text
@d792 1
a792 1
   return dblFromFlt (myDemand ()->cumShipVol ()[myPeriod ()]);
@


1.23
log
@Double Precision.
@
text
@d792 1
a792 1
   return doubleFromFloat (myDemand ()->cumShipVol ()[myPeriod ()]);
@


1.22
log
@Double Precision.
@
text
@d509 1
a509 1
   return doubleFromFloat (myBoundSet ()->hardLB () [myPeriod ()]);
d516 1
a516 1
   return doubleFromFloat (myBoundSet ()->softLB () [myPeriod ()]);
d525 1
a525 1
         doubleFromFloat (myBoundSet ()->hardUB () [myPeriod ()]):
@


1.21
log
@Continued double precision.
@
text
@d107 1
a107 1
   return doubleFromFloat (myPart ()->scrapVol ()[myPeriod ()]);
d726 1
a726 1
   return doubleFromFloat (myMaterial ()->stockVol ()[myPeriod ()]);
@


1.20
log
@Continued double precision.
@
text
@d107 1
a107 1
   return static_cast <double> (myPart ()->scrapVol ()[myPeriod ()]);
d164 1
a164 1
   return static_cast <double> (myBomEnt ()->nonSubVol ()[myPeriod ()]);
d217 1
a217 1
   return static_cast <double> (mySub ()->subVol ()[myPeriod ()]);
d411 1
a411 1
           static_cast <double> (myOpn ()->execVol ()[myPeriod ()])
d466 1
a466 1
        static_cast <double> (myOpn ()->execVol ()[myPeriod ()])
d509 1
a509 1
   return static_cast <double> (myBoundSet ()->hardLB () [myPeriod ()]);
d516 1
a516 1
   return static_cast <double> (myBoundSet ()->softLB () [myPeriod ()]);
d525 1
a525 1
         static_cast <double> (myBoundSet ()->hardUB () [myPeriod ()]):
d566 1
a566 1
         static_cast <double> (theSlbvVar->primalValue ());
d628 1
a628 1
   return static_cast <double> (myOperation ()->execVol ()[myPeriod ()]);
d726 1
a726 1
   return static_cast <double> (myMaterial ()->stockVol ()[myPeriod ()]);
d792 1
a792 1
   return static_cast <double> (myDemand ()->cumShipVol ()[myPeriod ()]);
@


1.19
log
@Continued implementation of opt with COIN.
@
text
@d112 1
a112 1
float WitScrapVar::primaryCoeffVal () const
d119 1
a119 1
float WitScrapVar::revCoeffVal () const
d169 1
a169 1
float WitNonSubVar::invCoeffVal () const
d174 1
a174 1
      static_cast <float> (myOptImploder ()->nPeriods ());
d222 1
a222 1
float WitSubVar::primaryCoeffVal () const
d229 1
a229 1
float WitSubVar::revCoeffVal () const
d237 1
a237 1
float WitSubVar::invCoeffVal () const
d242 1
a242 1
      static_cast <float> (myOptImploder ()->nPeriods ());
d247 1
a247 1
float WitSubVar::subCoeffVal () const
d297 1
a297 1
float WitShipVar::primaryCoeffVal () const
d304 1
a304 1
float WitShipVar::revCoeffVal () const
d344 1
a344 1
float WitSlbvVar::boundsCoeffVal () const
d558 2
a559 1
   WitSlbvVar * theSlbvVar = myImpOM ()->mySlbvVar (this);
d561 3
a563 1
   float slbvVal =
d566 1
a566 1
         static_cast <float> (theSlbvVar->primalValue ());
d633 1
a633 1
float WitExecVar::primaryCoeffVal () const
d640 1
a640 1
float WitExecVar::revCoeffVal () const
d647 1
a647 1
float WitExecVar::invCoeffVal () const
d651 1
d653 1
a653 1
   float sum = 0.0;
d669 1
a669 1
   return sum / static_cast <float> (myOptImploder ()->nPeriods ());
d731 1
a731 1
float WitStockVar::primaryCoeffVal () const
d738 1
a738 1
float WitStockVar::invCoeffVal () const
d742 1
a742 1
      / static_cast <float> (myOptImploder ()->nPeriods ());
d804 1
a804 1
float WitCumShipVar::primaryCoeffVal () const
d811 1
a811 1
float WitCumShipVar::servCoeffVal () const
@


1.18
log
@Changed some C style casts to C++ style.
@
text
@a28 5
int compiledPerVar = 1;
   //
   // WATCOM's strict compatibility mode requires every file to
   // have at least one external definition.

@


1.17
log
@Internal changes.
@
text
@d112 1
a112 1
   return (double) myPart ()->scrapVol ()[myPeriod ()];
d169 1
a169 1
   return (double) myBomEnt ()->nonSubVol ()[myPeriod ()];
d179 1
a179 1
      (float) myOptImploder ()->nPeriods ();
d222 1
a222 1
   return (double) mySub ()->subVol ()[myPeriod ()];
d247 1
a247 1
      (float) myOptImploder ()->nPeriods ();
d416 3
a418 2
           (double) myOpn ()->execVol ()[myPeriod ()]
         / (double) myOptImploder ()->incLotSize (myOpn (), myPeriod ());
d471 3
a473 2
        (double) myOpn ()->execVol ()[myPeriod ()]
      / (double) myOptImploder ()->minLotSize (myOpn (), myPeriod ());
d514 1
a514 1
   return (double) myBoundSet ()->hardLB () [myPeriod ()];
d521 1
a521 1
   return (double) myBoundSet ()->softLB () [myPeriod ()];
d530 1
a530 1
         (double) myBoundSet ()->hardUB () [myPeriod ()]:
d568 1
a568 1
         (float) theSlbvVar->primalValue ();
d630 1
a630 1
   return (double) myOperation ()->execVol ()[myPeriod ()];
d670 1
a670 1
   return sum / (float) myOptImploder ()->nPeriods ();
d727 1
a727 1
   return (double) myMaterial ()->stockVol ()[myPeriod ()];
d741 3
a743 1
   return myMaterial ()->unitCost () / (float) myOptImploder ()->nPeriods ();
d793 1
a793 1
   return (double) myDemand ()->cumShipVol ()[myPeriod ()];
@


1.16
log
@Internal changes.
@
text
@d656 1
a656 1
         if (! theBomEnt->hasSubsInEffect ()[myPeriod ()])
@


1.15
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d422 1
a422 1
WitBoolean WitIlsMultVar::isAnIntVar () const
d424 1
a424 1
   return witTRUE;
d476 1
a476 1
WitBoolean WitMlsMultVar::isAnIntVar () const
d478 1
a478 1
   return witTRUE;
d534 1
a534 1
WitBoolean WitBoundedVar::needsAnSlbvVar () const
d537 1
a537 1
      return witTRUE;
d540 1
a540 1
      return witTRUE;
d542 1
a542 1
   return witFALSE;
d597 1
a597 1
      isAnIntVar_   (witFALSE)
d673 1
a673 1
WitBoolean WitExecVar::isAnIntVar () const
@


1.14
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d22 1
d380 16
d412 57
d470 2
a471 2
        (double) myOpn ()->execVol    ()[myPeriod ()]
      / (double) myOpn ()->incLotSize ()[myPeriod ()];
d476 1
a476 1
WitBoolean WitIlsMultVar::isAnIntVar () const
d591 2
a592 2
         WitPeriod t,
         WitImpOM * theImpOM):
d594 1
a594 1
      WitBoundedVar (theImpOM, t),
d599 1
a599 9
   float ils;

   if (myOperation_->myOptComp ()->optWithLotSizes ())
      {
      ils = myOperation_->incLotSize ()[myPeriod ()];

      if (fabs (ils - 1.0) <= .001)
         isAnIntVar_ = witTRUE;
      }
@


1.13
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d13 1
a13 1
// Implementation the following hierarchy of classes:
d16 10
a25 9
//       ScrapVar
//       NonSubVar
//       SubVar
//       ShipVar
//       SlbvVar
//       BoundedVar
//          ExecVar
//          StockVar
//          CumShipVar
d354 54
d508 1
a508 1
   bounds (0.0, + OSL_INFTY);
d525 2
d528 4
a531 1
      if (myOperation_->incLotSize ()[myPeriod ()] > 0.0)
d533 1
d757 1
a757 1
   bounds (0.0, myDemand ()->cumDemandVol ()[myPeriod ()]);
@


1.12
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d94 6
a99 1
implementClassText (WitScrapVar, "Scrap")
d101 4
a104 1
implementPrintItem (WitScrapVar, myPart ())
d151 6
a156 1
implementClassText (WitNonSubVar, "Non-Sub")
d158 4
a161 1
implementPrintItem (WitNonSubVar, myBomEnt ())
d204 6
a209 1
implementClassText (WitSubVar, "Substitute")
d211 4
a214 1
implementPrintItem (WitSubVar, mySub ())
d279 6
a284 1
implementClassText (WitShipVar, "Shipment")
d286 4
a289 1
implementPrintItem (WitShipVar, myDemand ())
d333 6
a338 1
implementClassText (WitSlbvVar, "S. L. B. V.")
d340 4
a343 1
implementPrintItem (WitSlbvVar, myBoundedVar_)
d485 6
a490 1
implementClassText (WitExecVar, "Execution")
d492 4
a495 1
implementPrintItem (WitExecVar, myOperation ())
d582 6
a587 1
implementClassText (WitStockVar, "Stock")
d589 4
a592 1
implementPrintItem (WitStockVar, myMaterial ())
d646 6
a651 1
implementClassText (WitCumShipVar, "Cum. Ship")
d653 4
a656 1
implementPrintItem (WitCumShipVar, myDemand ())
@


1.11
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d32 1
@


1.10
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d32 1
a32 1
#include <ImpMp.h>
d49 1
a49 1
WitPeriodVar::WitPeriodVar (WitImpMp * theImpMp, WitPeriod t):
d51 1
a51 1
      WitMpVar  (theImpMp),
d69 1
a69 1
   myImpMp ()->printPeriod (myPeriod ());
d76 1
a76 1
WitScrapVar::WitScrapVar (WitPart * thePart, WitPeriod t, WitImpMp * theImpMp):
d78 1
a78 1
      WitPeriodVar (theImpMp, t),
d82 1
a82 1
   myImpMp ()->storeDerived (this);
d125 1
a125 1
          WitImpMp * theImpMp):
d127 1
a127 1
      WitPeriodVar (theImpMp, t),
d131 1
a131 1
   myImpMp ()->storeDerived (this);
d170 1
a170 1
          WitImpMp * theImpMp):
d172 1
a172 1
      WitPeriodVar (theImpMp, t),
d176 1
a176 1
   myImpMp ()->storeDerived (this);
d237 1
a237 1
         WitImpMp * theImpMp):
d239 1
a239 1
      WitPeriodVar (theImpMp, t),
d243 1
a243 1
   myImpMp ()->storeDerived (this);
d283 1
a283 1
WitSlbvVar::WitSlbvVar (WitBoundedVar * theBoundedVar, WitImpMp * theImpMp):
d285 1
a285 1
      WitPeriodVar  (theImpMp, theBoundedVar->myPeriod ()),
d289 1
a289 1
   myImpMp ()->storeDerived (this);
d315 1
a315 1
WitBoundedVar::WitBoundedVar (WitImpMp * theImpMp, WitPeriod t):
d317 1
a317 1
      WitPeriodVar (theImpMp, t)
d319 1
a319 1
   myImpMp ()->storeBoundedVar (this);
d379 3
a381 3
   fprintf (WitMpModel::modelFile (), "%8d",            index ());
   fprintf (WitMpModel::modelFile (), " %9.1f",         hardLB ());
   fprintf (WitMpModel::modelFile (), " %9.1f",         softLB ());
d383 2
a384 2
           (WitMpModel::modelFile (), " %9.1f", " %9s", hardUB ());
   fprintf (WitMpModel::modelFile (), "\n");
d391 1
a391 1
   WitSlbvVar * theSlbvVar = myImpMp ()->mySlbvVar (this);
d398 5
a402 5
   fprintf (myImpMp ()->solnFile (), " %8d",   index ());
   fprintf (myImpMp ()->solnFile (), " %9.1f", hardLB ());
   fprintf (myImpMp ()->solnFile (), " %9.1f", softLB ());
   fprintf (myImpMp ()->solnFile (), " %9.1f", slbvVal);
   fprintf (myImpMp ()->solnFile (), " %9.1f", primalValue ());
d404 2
a405 2
           (myImpMp ()->solnFile (), " %9.1f", " %9s",   hardUB ());
   fprintf (myImpMp ()->solnFile (), "\n");
d422 1
a422 1
         WitImpMp * theImpMp):
d424 1
a424 1
      WitBoundedVar (theImpMp, t),
d433 1
a433 1
   myImpMp ()->storeDerived (this);
d516 1
a516 1
         WitImpMp * theImpMp):
d518 1
a518 1
      WitBoundedVar (theImpMp, t),
d522 1
a522 1
   myImpMp ()->storeDerived (this);
d572 1
a572 1
         WitImpMp * theImpMp):
d574 1
a574 1
      WitBoundedVar (theImpMp, t),
d578 1
a578 1
   myImpMp ()->storeDerived (this);
@


1.9
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d426 2
a427 1
      myOperation_  (theOpn)
d429 4
d493 7
@


1.8
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d32 1
a32 1
#include <ImpLp.h>
d49 1
a49 1
WitPeriodVar::WitPeriodVar (WitImpLp * theImpLp, WitPeriod t):
d51 1
a51 1
      WitLpVar  (theImpLp),
d69 1
a69 1
   myImpLp ()->printPeriod (myPeriod ());
d76 1
a76 1
WitScrapVar::WitScrapVar (WitPart * thePart, WitPeriod t, WitImpLp * theImpLp):
d78 1
a78 1
      WitPeriodVar (theImpLp, t),
d82 1
a82 1
   myImpLp ()->storeDerived (this);
d125 1
a125 1
          WitImpLp * theImpLp):
d127 1
a127 1
      WitPeriodVar (theImpLp, t),
d131 1
a131 1
   myImpLp ()->storeDerived (this);
d170 1
a170 1
          WitImpLp * theImpLp):
d172 1
a172 1
      WitPeriodVar (theImpLp, t),
d176 1
a176 1
   myImpLp ()->storeDerived (this);
d237 1
a237 1
         WitImpLp * theImpLp):
d239 1
a239 1
      WitPeriodVar (theImpLp, t),
d243 1
a243 1
   myImpLp ()->storeDerived (this);
d283 1
a283 1
WitSlbvVar::WitSlbvVar (WitBoundedVar * theBoundedVar, WitImpLp * theImpLp):
d285 1
a285 1
      WitPeriodVar  (theImpLp, theBoundedVar->myPeriod ()),
d289 1
a289 1
   myImpLp ()->storeDerived (this);
d315 1
a315 1
WitBoundedVar::WitBoundedVar (WitImpLp * theImpLp, WitPeriod t):
d317 1
a317 1
      WitPeriodVar (theImpLp, t)
d319 1
a319 1
   myImpLp ()->storeBoundedVar (this);
d379 3
a381 3
   fprintf (WitLpModel::modelFile (), "%8d",            index ());
   fprintf (WitLpModel::modelFile (), " %9.1f",         hardLB ());
   fprintf (WitLpModel::modelFile (), " %9.1f",         softLB ());
d383 2
a384 2
           (WitLpModel::modelFile (), " %9.1f", " %9s", hardUB ());
   fprintf (WitLpModel::modelFile (), "\n");
d391 1
a391 1
   WitSlbvVar * theSlbvVar = myImpLp ()->mySlbvVar (this);
d398 5
a402 5
   fprintf (myImpLp ()->solnFile (), " %8d",   index ());
   fprintf (myImpLp ()->solnFile (), " %9.1f", hardLB ());
   fprintf (myImpLp ()->solnFile (), " %9.1f", softLB ());
   fprintf (myImpLp ()->solnFile (), " %9.1f", slbvVal);
   fprintf (myImpLp ()->solnFile (), " %9.1f", primalValue ());
d404 2
a405 2
           (myImpLp ()->solnFile (), " %9.1f", " %9s",   hardUB ());
   fprintf (myImpLp ()->solnFile (), "\n");
d422 1
a422 1
         WitImpLp * theImpLp):
d424 1
a424 1
      WitBoundedVar (theImpLp, t),
d428 1
a428 1
   myImpLp ()->storeDerived (this);
d504 1
a504 1
         WitImpLp * theImpLp):
d506 1
a506 1
      WitBoundedVar (theImpLp, t),
d510 1
a510 1
   myImpLp ()->storeDerived (this);
d560 1
a560 1
         WitImpLp * theImpLp):
d562 1
a562 1
      WitBoundedVar (theImpLp, t),
d566 1
a566 1
   myImpLp ()->storeDerived (this);
@


1.7
log
@Continued preliminary work on single source.
@
text
@d34 6
a40 1
#include <BopEntry.h>
@


1.6
log
@Continued development of selection splitting for multi=exec.
@
text
@d35 2
@


1.5
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d122 1
a122 1
      myBomEntry_  (theBomEnt)
d137 1
a137 1
implementPrintItem (WitNonSubVar, myBomEntry ())
d143 1
a143 1
   return (double) myBomEntry ()->nonSubVol ()[myPeriod ()];
d151 2
a152 2
      myBomEntry ()->effCost (myPeriod ())                        *
      (myPeriod () - myBomEntry ()->impactPeriod ()[myPeriod ()]) /
d167 1
a167 1
      mySubEntry_  (theSub)
d182 1
a182 1
implementPrintItem (WitSubVar, mySubEntry ())
d188 1
a188 1
   return (double) mySubEntry ()->subVol ()[myPeriod ()];
d195 1
a195 1
   return - mySubEntry ()->obj1SubCost ()[myPeriod ()];
d202 2
a203 2
   return + mySubEntry ()->myBomEntry ()->effCost (myPeriod ())
          - mySubEntry ()               ->effCost (myPeriod ());
d211 2
a212 2
      mySubEntry ()->effCost (myPeriod ())                        *
      (myPeriod () - mySubEntry ()->impactPeriod ()[myPeriod ()]) /
d220 1
a220 1
   return mySubEntry ()->obj2SubPenalty ();
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d151 1
a151 1
      myBomEntry ()->effCost ()                                 *
d202 2
a203 2
   return + mySubEntry ()->myBomEntry ()->effCost ()
          - mySubEntry ()               ->effCost ();
d211 1
a211 1
      mySubEntry ()->effCost ()                                 *
d471 1
a471 1
               theBomEnt->effCost ();
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d327 2
a328 2
   WitUtil::setToMax (bounds ().lower (), hardLB ());
   WitUtil::setToMin (bounds ().upper (), hardUB ());
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d327 2
a328 2
   WitUtil::updateToMax (bounds ().lower (), hardLB ());
   WitUtil::updateToMin (bounds ().upper (), hardUB ());
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

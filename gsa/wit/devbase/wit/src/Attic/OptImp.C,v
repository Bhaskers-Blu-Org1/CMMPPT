head	1.166;
access;
symbols
	latest_sce_4_20_20060523:1.73.0.2
	sce_4_20_20060523:1.73
	latest_sce4_20_OSL:1.69.0.2
	sce_4_20_OSL:1.69
	sce_410_withVa:1.59
	sce_4_05_20040511:1.55
	sce_4_00_20040201:1.43
	nextGenBranch:1.39.0.2
	nextGenRoot:1.39
	sce_3_30_20030627:1.38
	EndRw-branch:1.33.0.4
	Root-of-EndRw:1.33
	rwToStl:1.33.0.2
	latest_sce_3_10_20010924:1.7.0.2
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.6.0.4
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.166
date	2007.08.01.22.41.57;	author rjw;	state dead;
branches;
next	1.165;

1.165
date	2007.08.01.21.50.40;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2007.06.26.19.06.21;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2007.06.22.19.04.04;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2007.06.12.21.56.45;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2007.06.11.21.54.57;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2007.06.08.21.54.42;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2007.06.08.18.26.09;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2007.06.08.18.09.40;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2007.06.07.17.08.58;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2007.06.06.16.28.02;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2007.06.06.15.57.25;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2007.05.30.22.05.51;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2007.05.30.21.02.11;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2007.05.25.23.26.52;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2007.05.25.18.39.11;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2007.05.24.21.57.10;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2007.05.24.18.52.22;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2007.05.23.22.32.29;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2007.05.11.22.49.32;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2007.05.10.21.37.22;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2007.05.10.21.14.41;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2007.05.10.20.08.50;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2007.05.10.17.22.14;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2007.05.10.14.23.39;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2007.03.05.21.32.09;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2007.03.02.22.11.01;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2007.03.02.15.51.46;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2007.02.28.22.15.48;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2007.02.28.20.04.58;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2007.02.27.21.03.04;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2007.02.10.00.08.14;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2007.02.08.22.47.35;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2007.02.08.00.14.25;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2007.02.07.17.30.33;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2007.02.07.00.13.07;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2007.02.06.22.48.57;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2007.01.30.21.43.09;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2006.12.29.21.45.15;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2006.12.29.20.17.19;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2006.12.28.23.11.05;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2006.12.28.22.05.44;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2006.12.28.21.03.21;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2006.12.28.20.40.37;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2006.12.28.16.39.35;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2006.12.27.22.45.40;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2006.12.27.20.19.30;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2006.12.27.19.55.08;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2006.12.26.22.24.06;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2006.12.19.19.26.46;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2006.12.06.19.52.46;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2006.12.01.21.36.35;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2006.12.01.19.55.17;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2006.11.20.17.04.52;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2006.11.18.00.09.22;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2006.11.14.23.10.26;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2006.11.01.17.31.46;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2006.10.31.22.58.32;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2006.10.26.20.53.47;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2006.10.26.19.03.15;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2006.10.19.21.54.29;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2006.10.13.21.42.11;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2006.10.13.20.47.02;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2006.10.12.20.48.11;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2006.10.12.19.43.44;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2006.10.12.18.43.51;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2006.10.12.16.22.12;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2006.10.11.22.37.21;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2006.10.11.18.08.12;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2006.10.10.19.10.46;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2006.10.09.23.25.23;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2006.10.05.21.25.06;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2006.10.05.20.54.53;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2006.10.04.18.45.06;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2006.10.03.15.32.25;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2006.10.03.15.08.59;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2006.10.02.22.11.35;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2006.10.02.19.27.35;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2006.09.29.22.56.40;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2006.09.29.18.40.58;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2006.09.19.17.50.55;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2006.09.15.23.09.41;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2006.08.29.15.01.46;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2006.08.21.16.00.20;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2006.08.18.23.32.16;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2006.08.18.22.29.01;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2006.08.18.18.43.38;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2006.08.17.22.50.37;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2006.08.17.21.21.32;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2006.08.17.20.29.40;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2006.08.17.19.36.39;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.02.17.34.05;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2006.04.21.21.02.49;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.21.20.37.10;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.21.20.06.32;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.21.20.47.35;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.01.21.49.25;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.01.20.35.54;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2006.01.18.21.42.59;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.03.22.09.12;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2005.09.27.21.50.18;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.09.27.17.56.33;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.26.21.44.32;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2005.09.26.18.47.56;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.30.18.13.59;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.28.20.14.36;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.03.21.20.29;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.12.22.19.25.56;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.22.16.37.18;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.17.20.57.24;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.05.00.06.54;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.03.19.07.27;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.02.23.52.13;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.06.23.27.10;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.15.23.22.32;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.01.20.53.59;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.08.20.59.29;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.23.18.12.36;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.25.21.07.41;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.23.20.47.18;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.02.23.40.45;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.02.22.18.39;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.10.19.21.17;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.30.21.36.37;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.11.19.53.56;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.11.18.53.11;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.09.16.04.38;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.06.19.56.09;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.29.23.06.27;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.26.22.49.04;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.26.20.16.08;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.23.21.00.38;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.23.19.08.49;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.23.18.09.13;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.19.23.25.06;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.15.20.03.45;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.08.17.33.33;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.02.17.03.35;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.26.18.28.37;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.06.18.53.40;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.05.21.20.00;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.05.19.31.35;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.08.21.58.56;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.19.21.53;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.20.15.00;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.03.23.16.39;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.03.19.58.28;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.14.02.38;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.29.21.37.20;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.20.00.44.20;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.06.19.58.39;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.29.21.22.45;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.24;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.32;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches;
next	;


desc
@@


1.166
log
@Stochastic Implosion
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "OptImp.C"
//
// Contains the implementation of class OptImploder.
//------------------------------------------------------------------------------

#include <OptImp.h>
#include <ExtOptMgr.h>
#include <StochImpMgr.h>
#include <OptStarter.h>
#include <DetImpOP.h>
#include <DetVars.h>
#include <DetCons.h>
#include <DetObjs.h>
#include <HeurImp.h>
#include <wit/src/Variant.h>
#include <Pre.h>
#include <Post.h>
#include <Part.h>
#include <Demand.h>
#include <Opn.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Global.h>
#include <OptComp.h>
#include <BoundSet.h>
#include <PtrVecSort.h>
#include <Timing.h>
#include <MsgFrag.h>
#include <MsgFac.h>

typedef struct std::pair <WitPart *, WitPeriod> WitPartPer;

//------------------------------------------------------------------------------
// Implementation of class OptImploder.
//------------------------------------------------------------------------------

WitOptImploder::WitOptImploder (WitProblem * theProblem):

      WitProbAssoc   (theProblem),

      myDetImpOP_    (NULL),
      extOptActive_  (false),
      myExtOptMgr_   (NULL),
      accelerated_   (false),
      exportingSoln_ (false),
      exportTVec_    (),
      exportingObjs_ (false),
      criticalList_  (myProblem ()),
      potential_     ()
   {                
   }

//------------------------------------------------------------------------------

WitOptImploder::~WitOptImploder ()
   {
   shutDown ();

   delete myExtOptMgr_;
   }

//------------------------------------------------------------------------------

void WitOptImploder::shutDown ()
   {
   if (myDetImpOP_ != NULL)
      {
      delete myDetImpOP_;

      myDetImpOP_ = NULL;
      }

   if (accelerated ())
      {
      if (myOptComp ()->accOptStarter ()->isChosen ())
         myOptComp ()->heurOptStarter ()->beChosen ();

      accelerated_ =
         myMsgFac ().displayStateChange (
            "unaccStateMsg",
            accelerated (),
            false);
      }
   }

//------------------------------------------------------------------------------

void WitOptImploder::implode ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (WitOptComp::optImpAllowed ());

   myMsgFac () ("optImpMsg");

   startOptImp  ();

   myDetImpOP ()->solve ();

   myProblem ()->optVariant ()->becomesCurrent ();

   finishOptImp ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitOptImploder::verifyNoIntCons ()
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;
   WitDemand *    theDemand;

   stronglyAssert (not myOptComp ()->mipMode ());

   forEachOperation (theOpn, myProblem ())
      if (theOpn->intExecVols ())
         myMsgFac () ("intExecVolsWoMipModeSmsg",
            theOpn->operationName ());

   forEachSubEntry (theSub, myProblem ())
      if (theSub->intSubVols ())
         myMsgFac () ("intSubVolsWoMipModeSmsg",
            theSub->myOperationName (),
            theSub->myBomEnt ()->localIndex (),
            theSub->             localIndex ());

   forEachDemand (theDemand, myProblem ())
      if (theDemand->intShipVols ())
         myMsgFac () ("intShipVolsWoMipModeSmsg",
            theDemand->demandedPartName (),
            theDemand->demandName ());
   }

//------------------------------------------------------------------------------

void WitOptImploder::evalObjectives ()
   {
   WitTimer::enterSection ("opt-prob");

   myProblem ()->inputVariant ()->becomesCurrent ();

   myPreprocessor ()->preprocess ();

   setUpOptProb ();

   if (myOptComp ()->printOptProb ())
      myDetImpOP ()->print ();

   myPostprocessor ()->postprocess ();

   if (not myGlobalComp ()->feasible ())
      myMsgFac () ("infeasObjWmsg");

   myDetImpOP ()->calcInitSoln ();

   compObjectives ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitOptImploder::compObj1Values (double & primaryValue) const
   {
   primaryValue = myDetImpOP ()->myPrimaryObj ()->myValue ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::compObj2Values (
      double & revValue,
      double & invValue,
      double & servValue,
      double & subValue)
      const
   {
   revValue  = myDetImpOP ()-> myRevObj ()->myValue ();
   invValue  = myDetImpOP ()-> myInvObj ()->myValue ();
   servValue = myDetImpOP ()->myServObj ()->myValue ();
   subValue  = myDetImpOP ()-> mySubObj ()->myValue ();
   }

//------------------------------------------------------------------------------

bool WitOptImploder::boundsObjUsed () const
   {
   return myDetImpOP ()->slbvVarsExist ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::startExtOpt ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (not myGlobalComp ()->computeCriticalList ());
   stronglyAssert (not myOptComp    ()->compPrices ());
   stronglyAssert (not myOptComp    ()->accAfterOptImp ());
   stronglyAssert (not extOptActive_);

   myMsgFac () ("startExtOptMsg");

   extOptActive_ = true;

   startOptImp ();

   myExtOptMgr_ = new WitExtOptMgr (myDetImpOP ());

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitOptImploder::finishExtOpt ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (extOptActive_);

   stronglyAssert (myExtOptMgr_->solnProvided ());

   myMsgFac () ("finishExtOptMsg");

   delete myExtOptMgr_;

   myExtOptMgr_ = NULL;

   myProblem ()->extOptVariant ()->becomesCurrent ();

   finishOptImp ();

   extOptActive_ = false;

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitOptImploder::shutDownExtOpt ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (extOptActive_);

   myMsgFac () ("shutDownExtOptMsg");

   delete myExtOptMgr_;

   myExtOptMgr_ = NULL;

   shutDown ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitOptImploder::exportObjs (double & objValueRef, double & boundsValueRef)
   {
   stronglyAssert (exportingObjs_);

   objValueRef    = myDetImpOP ()->mainObj ()->myValue ();

   boundsValueRef = 
      myDetImpOP ()->slbvVarsExist ()?
         myDetImpOP ()->myBoundsObj ()->myValue ():
         0.0;
   }

//------------------------------------------------------------------------------

void WitOptImploder::exportSoln (
      WitGlobalComp *,
      WitPartPerStack & revCritListRef)
   {
   stronglyAssert (exportingSoln_);

   revCritListRef.revCopyFrom (criticalList_);
   }

//------------------------------------------------------------------------------

void WitOptImploder::exportSoln (
      WitPart *       thePart,
      WitDblFlexVec & scrapVolRef,
      WitDblFlexVec & shadowPriceRef)
   {
   WitPeriod        thePer;
   WitResourceCon * theResCon;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->myScrapVar (thePart, thePer));

   scrapVolRef = exportTVec_;

   if (myOptComp ()->compPrices ())
      {
      forEachPeriod (thePer, myProblem ())
         {
         theResCon = myDetImpOP ()->myResourceCon (thePart, thePer);

         exportTVec_[thePer] =
            (theResCon != NULL)?
                theResCon->dualValue ():
                0.0;
         }

      shadowPriceRef = exportTVec_;
      }
   else
      shadowPriceRef = 0.0;
   }

//------------------------------------------------------------------------------

void WitOptImploder::exportSoln (
      WitMaterial *   theMat,
      WitDblFlexVec & stockVolRef)
   {
   WitPeriod thePer;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
          solnValue (myDetImpOP ()->myStockVar (theMat, thePer));

   stockVolRef = exportTVec_;
   }

//------------------------------------------------------------------------------

void WitOptImploder::exportSoln (
      WitDemand *      theDemand,
      WitDblFlexVec &     shipVolRef,
      WitDblFlexVec &  cumShipVolRef)
   {
   WitPeriod thePer;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->myShipVar (theDemand, thePer));

   shipVolRef = exportTVec_;

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->myCumShipVar (theDemand, thePer));

   cumShipVolRef = exportTVec_;
   }

//------------------------------------------------------------------------------

void WitOptImploder::exportSoln (
      WitOperation *  theOpn,
      WitDblFlexVec & execVolRef)
   {
   WitPeriod thePer;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->myExecVar (theOpn, thePer));

   execVolRef = exportTVec_;
   }

//------------------------------------------------------------------------------

void WitOptImploder::exportSoln (
      WitSubEntry *   theSub,
      WitDblFlexVec & subVolRef)
   {
   WitPeriod thePer;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->mySubVar (theSub, thePer));

   subVolRef = exportTVec_;
   }

//------------------------------------------------------------------------------

void WitOptImploder::startOptImp ()
   {
   myProblem ()->resetSoln ();

   if (myCompMgr ()->nParts () == 0)
      myMsgFac () ("noPartsSmsg");

   objChoice ()->validateForOptImp ();

   if (myOptComp ()->mipMode ())
      validateMipMode ();
   else
      verifyNoIntCons ();

   myPreprocessor ()->preprocess ();

   if (not extOptActive_)
      compInitSoln ();

   setUpOptProb ();

   if (not extOptActive_)
      if (myOptComp ()->optInitMethod ()->external ())
         compInitOptSoln ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::finishOptImp ()
   {
   if (myOptComp ()->printOptSoln ())
      myDetImpOP ()->writeSoln ("opSoln.out");

   compObjectives ();

   objChoice ()->writeValues ();

   buildCritList ();

   exportSoln ();

   criticalList_.clear ();

   if (myGlobalComp ()->pauses ())
      myProblem ()->pauseForInput ("at the conclusion of opt implosion");

   if (myOptComp ()->accAfterOptImp ())
      {
      accelerated_ =
         myMsgFac ().displayStateChange (
            "accStateMsg",
            accelerated (),
            true);

      myOptComp ()->accOptStarter ()->beChosen ();
      }
   else
      shutDown ();

   myPostprocessor ()->postprocess ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::validateMipMode ()
   {
   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "computeCriticalList");

   if (myOptComp ()->compPrices ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "compPrices");

   if (myOptComp ()->accAfterOptImp ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "accAfterOptImp");
   }

//------------------------------------------------------------------------------

void WitOptImploder::compInitSoln () const
   {
   myOptComp ()->optInitMethod ()->display ();

   if (myOptComp ()->heurOptStarter ()->isChosen ())
      myProblem ()->myHeurImploder ()->implodeForOpt ();

   if (myOptComp ()->accOptStarter ()->isChosen ())
      witAssert (accelerated ());

   if (myOptComp ()->schedOptStarter ()->isChosen ())
      myPostprocessor ()->postprocess ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::setUpOptProb ()
   {
   if (myDetImpOP_ == NULL)
      {
      myMsgFac () ("genLpMipProbMsg",
         myMsgFac ().myFrag (
            myOptComp ()->mipMode ()?
               "mipFrag":
               "lpFrag"));

      myDetImpOP_ = new WitDetImpOP (myProblem ());

      myDetImpOP ()->generateFixed ();
      }
   else
      myMsgFac () ("updateOptProbMsg");

   objChoice ()->finalPreprocess ();

   myDetImpOP ()->generateFlexible ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::compInitOptSoln ()
   {
   myDetImpOP ()->calcInitSoln ();

   if (DEVELOPMENT)
      {
      compObjectives ();

      myMsgFac () ("initObjMsg");

      objChoice ()->writeValues ();
      }

   if (myOptComp ()->printInitSoln ())
      myDetImpOP ()->writeSoln ("initSoln.out");
   }

//------------------------------------------------------------------------------

void WitOptImploder::compObjectives ()
   {
   WitObjFunc * theObjFunc;

   exportingObjs_ = true;

   myOptComp ()->importObjs ();

   exportingObjs_ = false;

   forEachEl (theObjFunc, myOptComp ()->allObjFuncs ())
      theObjFunc->initValues ();

   objChoice ()->compValues ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::exportSoln ()
   {
   WitComponent * theComp;

   exportTVec_.allocate (myProblem (), 0.0);

   exportingSoln_ = true;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importOptSoln ();

   exportingSoln_ = false;

   exportTVec_.clear ();
   }

//------------------------------------------------------------------------------

double WitOptImploder::solnValue (const WitOptVar * theOptVar)
   {
   if (theOptVar == NULL)
      return 0.0;

   else if (extOptActive_)
      return theOptVar->primalValue ();

   else
      return positivePart (theOptVar->primalValue ());
   }

//------------------------------------------------------------------------------

void WitOptImploder::buildCritList ()
   {
   double                    criticalEpsilon;
   WitPart *                 thePart;
   WitTVec <bool>            producible (myProblem (), false);
   WitPeriod                 execPer;
   WitPeriod                 thePer;
   WitBopEntry *             theBopEnt;
   int                       theIdx;
   WitPartPer *              thePartPer;
   WitPtrVec    <WitPartPer> criticalVec;
   WitPtrVecItr <WitPartPer> theItr;

   stronglyAssert (criticalList_.isEmpty ());

   if (not myGlobalComp ()->computeCriticalList ())
      return;

   myMsgFac () ("formCriticalListMsg");

   criticalEpsilon = .001;

   potential_.allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      producible = false;

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->inEffect (execPer))
               producible[theBopEnt->impactPeriod ()[execPer]] = true;

      forEachPeriod (thePer, myProblem ())
         {
         if (producible[thePer])
            continue;

         potential_ (thePart)[thePer] =
            myDetImpOP ()->myResourceCon (thePart, thePer)->dualValue ();

         if (potential_ (thePart)[thePer] <= criticalEpsilon)
            continue;

         criticalList_.push (thePart, thePer);
         }
      }

   criticalVec.resize (criticalList_.nElements ());

   theIdx = -1;

   while (criticalList_.pop (thePart, thePer))
      {
      theIdx ++;

      criticalVec[theIdx] = new WitPartPer (thePart, thePer);
      }

   sort (
        criticalVec,
      & WitOptImploder::comparePotential,
        this);

   criticalVec.attachItr (theItr);

   while (theItr.advance (thePartPer))
      {
      criticalList_.push (thePartPer->first, thePartPer->second);

      delete thePartPer;
      }

   criticalVec  .clear   ();
   potential_   .clear   ();
   criticalList_.reverse ();
   }

//------------------------------------------------------------------------------

bool WitOptImploder::comparePotential (
      WitPartPer * thePartPer1,
      WitPartPer * thePartPer2)
   {
   WitPart * thePart1;
   WitPart * thePart2;
   WitPeriod thePer1;
   WitPeriod thePer2;
   double    thePot1;
   double    thePot2;

   thePart1  = thePartPer1->first;
   thePart2  = thePartPer2->first;

   thePer1   = thePartPer1->second;
   thePer2   = thePartPer2->second;

   thePot1   = potential_ (thePart1)[thePer1];
   thePot2   = potential_ (thePart2)[thePer2];

   return (thePot1 > thePot2);
   }
@


1.165
log
@Stochastic Implosion
@
text
@@


1.164
log
@Stochastic Implosion
@
text
@d23 1
a23 1
#include <OptObjs.h>
@


1.163
log
@Stochastic Implosion
@
text
@d21 2
a22 2
#include <PerVar.h>
#include <PerCon.h>
@


1.162
log
@Stochastic Implosion
@
text
@d20 1
a20 1
#include <ImpOptProb.h>
d51 1
a51 1
      myImpOptProb_  (NULL),
d76 1
a76 1
   if (myImpOptProb_ != NULL)
d78 1
a78 1
      delete myImpOptProb_;
d80 1
a80 1
      myImpOptProb_ = NULL;
d108 1
a108 1
   myImpOptProb ()->solve ();
d159 1
a159 1
      myImpOptProb ()->print ();
d166 1
a166 1
   myImpOptProb ()->calcInitSoln ();
d177 1
a177 1
   primaryValue = myImpOptProb ()->myPrimaryObj ()->myValue ();
d189 4
a192 4
   revValue  = myImpOptProb ()-> myRevObj ()->myValue ();
   invValue  = myImpOptProb ()-> myInvObj ()->myValue ();
   servValue = myImpOptProb ()->myServObj ()->myValue ();
   subValue  = myImpOptProb ()-> mySubObj ()->myValue ();
d199 1
a199 1
   return myImpOptProb ()->slbvVarsExist ();
d219 1
a219 1
   myExtOptMgr_ = new WitExtOptMgr (myImpOptProb ());
d274 1
a274 1
   objValueRef    = myImpOptProb ()->mainObj ()->myValue ();
d277 2
a278 2
      myImpOptProb ()->slbvVarsExist ()?
         myImpOptProb ()->myBoundsObj ()->myValue ():
d307 1
a307 1
         solnValue (myImpOptProb ()->myScrapVar (thePart, thePer));
d315 1
a315 1
         theResCon = myImpOptProb ()->myResourceCon (thePart, thePer);
d341 1
a341 1
          solnValue (myImpOptProb ()->myStockVar (theMat, thePer));
d359 1
a359 1
         solnValue (myImpOptProb ()->myShipVar (theDemand, thePer));
d365 1
a365 1
         solnValue (myImpOptProb ()->myCumShipVar (theDemand, thePer));
d382 1
a382 1
         solnValue (myImpOptProb ()->myExecVar (theOpn, thePer));
d399 1
a399 1
         solnValue (myImpOptProb ()->mySubVar (theSub, thePer));
d437 1
a437 1
      myImpOptProb ()->writeSoln ("opSoln.out");
d502 1
a502 1
   if (myImpOptProb_ == NULL)
d510 1
a510 1
      myImpOptProb_ = new WitImpOptProb (myProblem ());
d512 1
a512 1
      myImpOptProb ()->generateFixed ();
d519 1
a519 1
   myImpOptProb ()->generateFlexible ();
d526 1
a526 1
   myImpOptProb ()->calcInitSoln ();
d538 1
a538 1
      myImpOptProb ()->writeSoln ("initSoln.out");
d632 1
a632 1
            myImpOptProb ()->myResourceCon (thePart, thePer)->dualValue ();
@


1.161
log
@Stochastic Implosion
@
text
@d119 29
a483 27
void WitOptImploder::verifyNoIntCons ()
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;
   WitDemand *    theDemand;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->intExecVols ())
         myMsgFac () ("intExecVolsWoMipModeSmsg",
            theOpn->operationName ());

   forEachSubEntry (theSub, myProblem ())
      if (theSub->intSubVols ())
         myMsgFac () ("intSubVolsWoMipModeSmsg",
            theSub->myOperationName (),
            theSub->myBomEnt ()->localIndex (),
            theSub->             localIndex ());

   forEachDemand (theDemand, myProblem ())
      if (theDemand->intShipVols ())
         myMsgFac () ("intShipVolsWoMipModeSmsg",
            theDemand->demandedPartName (),
            theDemand->demandName ());
   }

//------------------------------------------------------------------------------

@


1.160
log
@Stochastic Implosion
@
text
@a118 15
void WitOptImploder::stochImplode ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (myStochImpMgr ()->stochMode ());

   stronglyAssert (WitOptComp::optImpAllowed ());

   startStochImp ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

a440 15
void WitOptImploder::startStochImp ()
   {
   myProblem ()->resetSoln ();

   verifyNoIntCons ();

   myPreprocessor ()->preprocess ();

   compInitSoln ();

   setUpStochOptProb ();
   }

//------------------------------------------------------------------------------

a521 9
void WitOptImploder::setUpStochOptProb ()
   {
   myMsgFac () ("genLpMipProbMsg", myMsgFac ().myFrag ("stochLpFrag"));

   myMsgFac () ("singleStochLPNyiSmsg");
   }

//------------------------------------------------------------------------------

@


1.159
log
@Stochastic Implosion
@
text
@d49 1
a49 1
      WitProbAssoc  (theProblem),
d51 9
a59 10
      myImpOptProb_ (NULL),
      extOptActive_ (false),
      myExtOptMgr_  (NULL),
      accelerated_  (false),
      exporting_    (false),
      exportTVec_   (),
      objValue_     (0.0),
      boundsValue_  (0.0),
      criticalList_ (myProblem ()),
      potential_    ()
d256 1
a256 1
void WitOptImploder::importStochSoln ()
d258 8
a265 1
   myStochImpMgr ()->exportSoln (this, objValue_,boundsValue_);
d274 1
a274 1
   stronglyAssert (exporting_);
d289 1
a289 1
   stronglyAssert (exporting_);
d323 1
a323 1
   stronglyAssert (exporting_);
d341 1
a341 1
   stronglyAssert (exporting_);
d364 1
a364 1
   stronglyAssert (exporting_);
d381 1
a381 1
   stronglyAssert (exporting_);
d584 1
a584 1
   objValue_ = myImpOptProb ()->mainObj ()->myValue ();
d586 3
a588 4
   boundsValue_ =
      myImpOptProb ()->slbvVarsExist ()?
         myImpOptProb ()->myBoundsObj ()->myValue ():
         0.0;
d604 1
a604 1
   exporting_ = true;
d609 1
a609 1
   exporting_ = false;
@


1.158
log
@Stochastic Implosion
@
text
@d266 1
a266 1
      WitPartPerStack & revCritListArg)
d270 1
a270 1
   revCritListArg.revCopyFrom (criticalList_);
d277 2
a278 2
      WitDblFlexVec & scrapVolArg,
      WitDblFlexVec & shadowPriceArg)
d289 1
a289 1
   scrapVolArg = exportTVec_;
d303 1
a303 1
      shadowPriceArg = exportTVec_;
d306 1
a306 1
      shadowPriceArg = 0.0;
d313 1
a313 1
      WitDblFlexVec & stockVolArg)
d323 1
a323 1
   stockVolArg = exportTVec_;
d330 2
a331 2
      WitDblFlexVec &     shipVolArg,
      WitDblFlexVec &  cumShipVolArg)
d341 1
a341 1
   shipVolArg = exportTVec_;
d347 1
a347 1
   cumShipVolArg = exportTVec_;
d354 1
a354 1
      WitDblFlexVec & execVolArg)
d364 1
a364 1
   execVolArg = exportTVec_;
d371 1
a371 1
      WitDblFlexVec & subVolArg)
d381 1
a381 1
   subVolArg = exportTVec_;
@


1.157
log
@Stochastic Implosion
@
text
@d55 2
a56 1
      curSolnTVec_  (),
d257 1
a257 1
void WitOptImploder::passStochRefs ()
d259 1
a259 4
   myStochImpMgr ()->
      receiveOptImpData (
         objValue_,
         boundsValue_);
d264 1
a264 1
void WitOptImploder::provideSoln (
d268 1
a268 1
   witAssert (curSolnTVec_.isAllocated ());
d275 1
a275 1
void WitOptImploder::provideSoln (
d283 2
d286 1
a286 1
      curSolnTVec_[thePer] =
d289 1
a289 1
   scrapVolArg = curSolnTVec_;
d297 1
a297 1
         curSolnTVec_[thePer] =
d303 1
a303 1
      shadowPriceArg = curSolnTVec_;
d311 1
a311 1
void WitOptImploder::provideSoln (
d317 2
d320 1
a320 1
      curSolnTVec_[thePer] =
d323 1
a323 1
   stockVolArg = curSolnTVec_;
d328 1
a328 1
void WitOptImploder::provideSoln (
d335 2
d338 1
a338 1
      curSolnTVec_[thePer] =
d341 1
a341 1
   shipVolArg = curSolnTVec_;
d344 1
a344 1
      curSolnTVec_[thePer] =
d347 1
a347 1
   cumShipVolArg = curSolnTVec_;
d352 1
a352 1
void WitOptImploder::provideSoln (
d358 2
d361 1
a361 1
      curSolnTVec_[thePer] =
d364 1
a364 1
   execVolArg = curSolnTVec_;
d369 1
a369 1
void WitOptImploder::provideSoln (
d375 2
d378 1
a378 1
      curSolnTVec_[thePer] =
d381 1
a381 1
   subVolArg = curSolnTVec_;
d425 1
a425 1
   provideSoln ();
d593 1
a593 1
void WitOptImploder::provideSoln ()
d597 3
a599 1
   curSolnTVec_.allocate (myProblem (), 0.0);
d602 3
a604 1
      theComp->acquireOptSoln ();
d606 1
a606 1
   curSolnTVec_.clear ();
@


1.156
log
@Stochastic Implosion
@
text
@d524 1
a524 1
      myImpOptProb_ = new WitImpOptProb (this);
@


1.155
log
@Stochastic Implosion
@
text
@a54 1
      acquireComp_  (NULL),
d266 3
a268 1
void WitOptImploder::provideGlobalSoln (WitPartPerStack & revCritListArg)
d270 1
a270 1
   acquireComp  ();
d277 4
a280 2
void WitOptImploder::providePartSoln (WitDblFlexVec &    scrapVolArg,
                                      WitDblFlexVec & shadowPriceArg)
a281 1
   WitPart *        thePart;
a284 2
   thePart = acquireComp ()->thisPart ();

d311 3
a313 1
void WitOptImploder::provideMaterialSoln (WitDblFlexVec & stockVolArg)
d315 1
a315 4
   WitMaterial * theMat;
   WitPeriod     thePer;

   theMat = acquireComp ()->thisMat ();
d326 4
a329 2
void WitOptImploder::provideDemandSoln (WitDblFlexVec &    shipVolArg,
                                        WitDblFlexVec & cumShipVolArg)
d331 1
a331 4
   WitDemand * theDemand;
   WitPeriod   thePer;

   theDemand = acquireComp  ()->thisDemand ();
d348 3
a350 1
void WitOptImploder::provideOperationSoln (WitDblFlexVec & execVolArg)
d352 1
a352 4
   WitOperation * theOpn;
   WitPeriod      thePer;

   theOpn = acquireComp ()->thisOpn ();
d363 3
a365 1
void WitOptImploder::provideSubEntrySoln  (WitDblFlexVec & subVolArg)
d367 1
a367 4
   WitSubEntry * theSub;
   WitPeriod     thePer;

   theSub = acquireComp ()->thisSub ();
d587 2
d591 2
a592 2
   forEachEl (acquireComp_, myCompMgr ()->allComponents ())
      acquireComp_->acquireOptSoln ();
a594 2

   acquireComp_ = NULL;
@


1.154
log
@Stochastic Implosion
@
text
@d56 1
a280 1
   WitScrapVar *    theScrapVar;
d286 2
a287 2
      {
      theScrapVar = myImpOptProb ()->myScrapVar (thePart, thePer);
d289 1
a289 2
      scrapVolArg.elemRef (thePer) = solnValue (theScrapVar);
      }
d292 1
d297 1
a297 1
         shadowPriceArg.elemRef (thePer) =
d302 5
a314 1
   WitOptVar *   theOptVar;
d319 2
a320 2
      {
      theOptVar = myImpOptProb ()->myStockVar (theMat, thePer);
d322 1
a322 2
      stockVolArg.elemRef (thePer) = solnValue (theOptVar);
      }
d330 2
a331 4
   WitDemand *     theDemand;
   WitPeriod       thePer;
   WitShipVar *    theShipVar;
   WitCumShipVar * theCumShipVar;
d336 8
a343 3
      {
      theShipVar    = myImpOptProb ()->myShipVar    (theDemand, thePer);
      theCumShipVar = myImpOptProb ()->myCumShipVar (theDemand, thePer);
d345 1
a345 3
      shipVolArg   .elemRef (thePer) = solnValue (theShipVar);
      cumShipVolArg.elemRef (thePer) = solnValue (theCumShipVar);
      }
a353 1
   WitExecVar *   theExecVar;
d358 2
a359 2
      {
      theExecVar = myImpOptProb ()->myExecVar (theOpn, thePer);
d361 1
a361 2
      execVolArg.elemRef (thePer) = solnValue (theExecVar);
      }
a369 1
   WitSubVar *   theSubVar;
d374 2
a375 2
      {
      theSubVar = myImpOptProb ()->mySubVar (theSub, thePer);
d377 1
a377 2
      subVolArg.elemRef (thePer) = solnValue (theSubVar);
      }
d591 2
d596 2
@


1.153
log
@Stochastic Implosion
@
text
@d140 1
a140 1
   myPreprocessor ()->optPreprocess ();
d386 3
d396 1
a396 1
   myPreprocessor ()->optPreprocess ();
d452 1
a452 1
   myPreprocessor ()->optPreprocess ();
@


1.152
log
@Stochastic Implosion
@
text
@d614 2
a617 1
   bool                      producible;
d635 8
d645 1
a645 7
         producible = false;

         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->nExecPeriods (thePer) > 0)
               producible = true;

         if (producible)
d656 1
@


1.151
log
@Stochastic Implosion
@
text
@d119 15
a381 1

d443 15
d539 9
@


1.150
log
@Stochastic Implosion
@
text
@d55 1
a55 1
      exporting_    (false),
d251 1
a251 1
double WitOptImploder::scrapVol (WitPart * thePart, WitPeriod thePer)
d253 1
a253 1
   witAssert (exporting_);
d255 1
a255 1
   return solnValue (myImpOptProb ()->myScrapVar (thePart, thePer));
d260 2
a261 1
double WitOptImploder::shadowPrice (WitPart * thePart, WitPeriod thePer)
d263 4
a266 1
   const WitOptCon * theResCon;
d268 1
a268 1
   witAssert (exporting_);
d270 6
a275 1
   witAssert (myOptComp ()->compPrices ());
d277 4
a280 1
   theResCon = myImpOptProb ()->myResourceCon (thePart, thePer);
d282 5
a286 4
   return
      (theResCon != NULL)?
          theResCon->dualValue ():
          0.0;
d291 1
a291 1
double WitOptImploder::stockVol (WitMaterial * theMat, WitPeriod thePer)
d293 9
a301 1
   witAssert (exporting_);
d303 2
a304 1
   return solnValue (myImpOptProb ()->myStockVar (theMat, thePer));
d309 2
a310 1
double WitOptImploder::shipVol (WitDemand * theDemand, WitPeriod thePer)
d312 6
a317 1
   witAssert (exporting_);
d319 8
a326 1
   return solnValue (myImpOptProb ()->myShipVar (theDemand, thePer));
d331 1
a331 1
double WitOptImploder::cumShipVol (WitDemand * theDemand, WitPeriod thePer)
d333 3
a335 1
   witAssert (exporting_);
d337 1
a337 2
   return solnValue (myImpOptProb ()->myCumShipVar (theDemand, thePer));
   }
d339 3
a341 1
//------------------------------------------------------------------------------
d343 2
a344 5
double WitOptImploder::execVol (WitOperation * theOpn, WitPeriod thePer)
   {
   witAssert (exporting_);

   return solnValue (myImpOptProb ()->myExecVar (theOpn, thePer));
d349 1
a349 1
double WitOptImploder::subVol (WitSubEntry * theSub, WitPeriod thePer)
d351 3
a353 1
   witAssert (exporting_);
d355 1
a355 2
   return solnValue (myImpOptProb ()->mySubVar (theSub, thePer));
   }
d357 3
a359 1
//------------------------------------------------------------------------------
d361 2
a362 5
const WitPartPerStack & WitOptImploder::criticalList ()
   {
   witAssert (exporting_);

   return criticalList_;
d367 1
d404 1
a404 1
   exportSoln ();
d548 1
a548 1
void WitOptImploder::exportSoln ()
d550 2
a551 12
   WitComponent * theComp;
   WitPeriod      thePer;

   exporting_ = true;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      forEachPeriod (thePer, myProblem ())
         {
         theComp->importOptImpSoln (thePer);
         }

   myGlobalComp ()->importOptImpSoln ();
d553 1
a553 1
   exporting_ = false;
@


1.149
log
@Stochastic Implosion
@
text
@a55 1
      passRefsComp_ (false),
@


1.148
log
@Stochastic Implosion
@
text
@d56 1
d242 1
a242 1
void WitOptImploder::passStochData ()
@


1.147
log
@Stochastic Implosion
@
text
@d241 1
a241 1
void WitOptImploder::importStochObjValues ()
d243 4
a246 2
   objValue_    = myStochImpMgr ()->objValue    ();
   boundsValue_ = myStochImpMgr ()->boundsValue ();
@


1.146
log
@Stochastic Implosion
@
text
@d18 1
d239 7
d499 1
a499 1
        myImpOptProb ()->myBoundsObj ()->myValue ():
@


1.145
log
@Stochastic Implosion
@
text
@d538 7
a544 9
   double        criticalEpsilon;
   WitPart *     thePart;
   WitPeriod     thePer;
   WitBopEntry * theBopEnt;
   bool          producible;
   int           theIdx;
   WitPartPer *  thePartPer;

   WitObjStack  <WitPartPer> criticalStack (myProblem ());
d577 1
a577 1
         criticalStack.push (new WitPartPer (thePart, thePer));
d580 1
a580 1
   criticalVec.resize (criticalStack.nElements ());
d584 1
a584 1
   while (criticalStack.pop (thePartPer))
d588 1
a588 1
      criticalVec[theIdx] = thePartPer;
@


1.144
log
@Stochastic Implosion
@
text
@d27 4
d32 1
a34 1
#include <OptAccess.h>
d40 2
d57 1
d313 9
d356 2
d360 1
a360 1
   formCriticalList ();
d515 2
d536 1
a536 1
void WitOptImploder::formCriticalList ()
d538 1
a540 2
   double        criticalEpsilon;
   WitPartPer *  thePartPer;
d544 1
d550 1
a550 1
   WitOptAccess::revCritList (myGlobalComp ()).clear ();
d602 3
a604 4
      WitOptAccess::revCritList (myGlobalComp ()).
         push (
            thePartPer->first,
            thePartPer->second);
d607 3
a609 1
   potential_.clear ();
@


1.143
log
@Stochastic Implosion
@
text
@d530 1
a530 2
   while (not WitOptAccess::criticalList (myGlobalComp ()).isEmpty ())
      delete WitOptAccess::criticalList (myGlobalComp ()).get ();
d581 6
a586 1
      WitOptAccess::criticalList (myGlobalComp ()).append (thePartPer);
@


1.142
log
@Stochastic Implosion
@
text
@d48 1
d50 3
a52 2
      boundsValue_  (0.0)
   {
d231 73
d486 2
a487 14
   WitOperation *    theOpn;
   WitSubEntry *     theSub;
   WitDemand *       theDemand;
   WitPart *         thePart;
   WitMaterial *     theMat;
   WitPeriod         thePer;
   const WitOptCon * theResCon;
   WitTVec <double>  execVolVec     (myProblem (), 0.0);
   WitTVec <double>  subVolVec      (myProblem (), 0.0);
   WitTVec <double>  cumShipVolVec  (myProblem (), 0.0);
   WitTVec <double>  shipVolVec     (myProblem (), 0.0);
   WitTVec <double>  scrapVolVec    (myProblem (), 0.0);
   WitTVec <double>  stockVolVec    (myProblem (), 0.0);
   WitTVec <double>  shadowPriceVec (myProblem (), 0.0);
d489 1
a489 5
   forEachOperation (theOpn, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         execVolVec[thePer] =
            solnValue (myImpOptProb ()->myExecVar (theOpn, thePer));
d491 1
a491 14
      WitOptAccess::execVol (theOpn) = execVolVec;
      }

   forEachSubEntry (theSub, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         subVolVec[thePer] =
            solnValue (myImpOptProb ()->mySubVar (theSub, thePer));

      WitOptAccess::subVol (theSub) = subVolVec;
      }

   forEachDemand (theDemand, myProblem ())
      {
d494 1
a494 5
         shipVolVec[thePer]    = 
            solnValue (myImpOptProb ()->myShipVar    (theDemand, thePer));

         cumShipVolVec[thePer] =
            solnValue (myImpOptProb ()->myCumShipVar (theDemand, thePer));
d497 1
a497 37
      WitOptAccess::shipVol    (theDemand) = shipVolVec;
      WitOptAccess::cumShipVol (theDemand) = cumShipVolVec;
      }

   forEachPart (thePart, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         scrapVolVec[thePer] = 
            solnValue (myImpOptProb ()->myScrapVar (thePart, thePer));

      WitOptAccess::scrapVol (thePart) = scrapVolVec;
      }

   forEachMaterial (theMat, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         stockVolVec[thePer] =
            solnValue (myImpOptProb ()->myStockVar (theMat, thePer));

      WitOptAccess::stockVol (theMat) = stockVolVec;
      }

   if (myOptComp ()->compPrices ())
      forEachPart (thePart, myProblem ())
         {
         shadowPriceVec = 0.0;

         forEachPeriod (thePer, myProblem ())
            {
            theResCon = myImpOptProb ()->myResourceCon (thePart, thePer);

            if (theResCon != NULL)
               shadowPriceVec[thePer] = theResCon->dualValue ();
            }

         WitOptAccess::shadowPrice (thePart) = shadowPriceVec;
         }
@


1.141
log
@[disallowed backlog]
@
text
@d13 1
a13 4
// Contains the implementation of the following classes:
//
//    OptImploder.
//    ExtOptMgr
a23 1
#include <DataWrit.h>
a26 4
#include <Global.h>
#include <Material.h>
#include <Opn.h>
#include <SubEntry.h>
a27 1
#include <Demand.h>
a30 1
#include <ObjStack.h>
a31 1
#include <IVRealArg.h>
a604 294

//------------------------------------------------------------------------------
// Implementation of class ExtOptMgr.
//------------------------------------------------------------------------------

WitExtOptMgr::WitExtOptMgr (WitImpOptProb * theImpOptProb):

      WitProbAssoc  (theImpOptProb->myProblem ()),

      myImpOptProb_ (theImpOptProb),
      solnProvided_ (false)
   {
   }

//------------------------------------------------------------------------------

WitExtOptMgr::~WitExtOptMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitExtOptMgr::getLpProb (
      WitVector <int> &    start,
      WitVector <int> &    index,
      WitVector <double> & value,
      WitVector <double> & collb,
      WitVector <double> & colub,
      WitVector <double> & obj,
      WitVector <double> & rowlb,
      WitVector <double> & rowub)
   {
   WitTimer::enterSection ("opt-prob");

   myImpOptProb_->
      getMatrixByCols (start, index, value);

   getColData (collb, colub, obj);
   getRowData (rowlb, rowub);

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitExtOptMgr::getIntVarIndices (WitVector <int> & indices)
   {
   WitOptVar * theOptVar;
   int         nIntVars;
   int         vecIdx;

   WitTimer::enterSection ("opt-prob");

   nIntVars = 0;

   forEachEl (theOptVar, myImpOptProb_->myOptVars ())
      if (theOptVar->isAnIntVar ())
         nIntVars ++;

   indices.resize (nIntVars);

   vecIdx = -1;

   forEachEl (theOptVar, myImpOptProb_->myOptVars ())
      if (theOptVar->isAnIntVar ())
         {
         vecIdx ++;

         indices[vecIdx] = theOptVar->index ();
         }

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitExtOptMgr::setSoln (const WitIVRealArg & theVector)
   {
   WitOptVar * theOptVar;
   int         theIdx;

   WitTimer::enterSection ("opt-prob");

   forEachEl (theOptVar, myImpOptProb_->myOptVars ())
      {
      theIdx = theOptVar->index ();

      theOptVar->setPrimalValue (theVector[theIdx]);
      }

   solnProvided_ = true;

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::scrapVarIndex (WitPart * thePart, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->myScrapVar (thePart, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::nonSubVarIndex (WitBomEntry * theBomEnt, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->myNonSubVar (theBomEnt, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::subVarIndex (WitSubEntry * theSub, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->mySubVar (theSub, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::shipVarIndex (WitDemand * theDemand, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->myShipVar (theDemand, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::execVarIndex (WitOperation * theOpn, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->myExecVar (theOpn, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::stockVarIndex (WitMaterial * theMat, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->myStockVar (theMat, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::cumShipVarIndex (WitDemand * theDemand, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->myCumShipVar (theDemand, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::execSlbvVarIndex (WitOperation * theOpn, WitPeriod thePer)
   {
   return slbvVarIndexOf (myImpOptProb_->myExecVar (theOpn, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::stockSlbvVarIndex (WitMaterial * theMat, WitPeriod thePer)
   {
   return slbvVarIndexOf (myImpOptProb_->myStockVar (theMat, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::cumShipSlbvVarIndex (
      WitDemand * theDemand,
      WitPeriod   thePer)
   {
   return slbvVarIndexOf (myImpOptProb_->myCumShipVar (theDemand, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::resourceConIndex (WitPart * thePart, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->myResourceCon (thePart, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::subConIndex (WitBomEntry * theBomEnt, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->mySubCon (theBomEnt, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::shipConIndex (WitDemand * theDemand, WitPeriod thePer)
   {
   return indexOf (myImpOptProb_->myShipCon (theDemand, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::execSlbConIndex (WitOperation * theOpn, WitPeriod thePer)
   {
   return slbConIndexOf (myImpOptProb_->myExecVar (theOpn, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::stockSlbConIndex (WitMaterial * theMat, WitPeriod thePer)
   {
   return slbConIndexOf (myImpOptProb_->myStockVar (theMat, thePer));
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::cumShipSlbConIndex (
      WitDemand * theDemand,
      WitPeriod   thePer)
   {
   return slbConIndexOf (myImpOptProb_->myCumShipVar (theDemand, thePer));
   }

//------------------------------------------------------------------------------

void WitExtOptMgr::getColData (
      WitVector <double> & collb,
      WitVector <double> & colub,
      WitVector <double> & obj)
   {
   WitOptVar * theOptVar;
   int         theIdx;

   collb.resize (myImpOptProb_->nOptVars ());
   colub.resize (myImpOptProb_->nOptVars ());
   obj  .resize (myImpOptProb_->nOptVars ());

   forEachEl (theOptVar, myImpOptProb_->myOptVars ())
      {
      theIdx        = theOptVar->index ();

      collb[theIdx] = theOptVar->bounds ().lower ();
      colub[theIdx] = theOptVar->bounds ().upper ();

      obj  [theIdx] = theOptVar->mainObjCoeffVal ();
      }
   }

//------------------------------------------------------------------------------

void WitExtOptMgr::getRowData (
      WitVector <double> & rowlb,
      WitVector <double> & rowub)
   {
   WitOptCon * theOptCon;
   int         theIdx;

   rowlb.resize (myImpOptProb_->nOptCons ());
   rowub.resize (myImpOptProb_->nOptCons ());

   forEachEl (theOptCon, myImpOptProb_->myOptCons ())
      {
      theIdx        = theOptCon->index ();

      rowlb[theIdx] = theOptCon->bounds ().lower ();
      rowub[theIdx] = theOptCon->bounds ().upper ();
      }
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::slbvVarIndexOf (WitBoundedVar * theBoundedVar)
   {
   WitSlbvVar * theSlbvVar;

   if (theBoundedVar == NULL)
      return -1;

   theSlbvVar = myImpOptProb_->mySlbvVar (theBoundedVar);

   return indexOf (theSlbvVar);
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::slbConIndexOf (WitBoundedVar * theBoundedVar)
   {
   WitSlbCon * theSlbCon;

   if (theBoundedVar == NULL)
      return -1;

   theSlbCon = myImpOptProb_->mySlbCon (theBoundedVar);

   return indexOf (theSlbCon);
   }

//------------------------------------------------------------------------------

int WitExtOptMgr::indexOf (WitOptProbEl * theOptProbEl)
   {
   if (theOptProbEl == NULL)
      return -1;

   return theOptProbEl->index ();
   }
@


1.140
log
@[disallowed backlog]
@
text
@a252 2
   validateNonBacklog ();

a341 33
void WitOptImploder::validateNonBacklog ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;

   forEachDemand (theDemand, myProblem ())
      if (not theDemand->backlogAllowed ())
         {
         if (theDemand->cumShipReward () != 0.0)
            myMsgFac () ("cumShipRewardDisBacklogSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName ());

         if (theDemand->cumShipBounds ()->softLB () != 0.0)
            myMsgFac () ("cumShipSLBDisBacklogSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName ());

         forEachPeriod (thePer, myProblem ())
            if (theDemand->cumShipBounds ()->hardUBIsFinite (thePer))
               myMsgFac () ("cumShipHUBDisBacklogSmsg",
                  theDemand->demandedPartName (),
                  theDemand->demandName ());

         if (myCompMgr ()->myOptComp ()->myObjFunc2 ()->isChosen ())
            myMsgFac () ("obj2DisBacklogSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName ());
         }
   }

//------------------------------------------------------------------------------

@


1.139
log
@[disallowed backlog]
@
text
@d350 1
a350 1
      if (theDemand->disallowBacklog ())
@


1.138
log
@[disallowed backlog]
@
text
@d367 5
@


1.137
log
@[disallowed backlog]
@
text
@d350 1
a350 1
      if (not theDemand->backlogAllowed ())
d353 1
a353 1
            myMsgFac () ("cumShipRewardNoBacklogSmsg",
d358 1
a358 1
            myMsgFac () ("cumShipSLBNoBacklogSmsg",
d364 1
a364 1
               myMsgFac () ("cumShipHUBNoBacklogSmsg",
@


1.136
log
@[disallowed backlog]
@
text
@a50 14
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec      WitPart::* WitOptImploder::scrapVol_     = NULL;
WitDblFlexVec      WitPart::* WitOptImploder::shadowPrice_  = NULL;
WitDblFlexVec  WitMaterial::* WitOptImploder::stockVol_     = NULL;
WitDblFlexVec    WitDemand::* WitOptImploder::shipVol_      = NULL;
WitDblFlexVec    WitDemand::* WitOptImploder::cumShipVol_   = NULL;
WitDblFlexVec WitOperation::* WitOptImploder::execVol_      = NULL;
WitDblFlexVec  WitSubEntry::* WitOptImploder::subVol_       = NULL;

//------------------------------------------------------------------------------

a241 41
void WitOptImploder::receiveDMPs (
      WitDblFlexVec WitPart::* scrapVolArg,
      WitDblFlexVec WitPart::* shadowPriceArg)
   {
   scrapVol_    = scrapVolArg;
   shadowPrice_ = shadowPriceArg;
   }

//------------------------------------------------------------------------------

void WitOptImploder::receiveDMPs (WitDblFlexVec WitMaterial::* stockVolArg)
   {
   stockVol_ = stockVolArg;
   }

//------------------------------------------------------------------------------

void WitOptImploder::receiveDMPs (
      WitDblFlexVec WitDemand::* shipVolArg,
      WitDblFlexVec WitDemand::* cumShipVolArg)
   {
   shipVol_    = shipVolArg;
   cumShipVol_ = cumShipVolArg;
   }

//------------------------------------------------------------------------------

void WitOptImploder::receiveDMPs (WitDblFlexVec WitOperation::* execVolArg)
   {
   execVol_ = execVolArg;
   }

//------------------------------------------------------------------------------

void WitOptImploder::receiveDMPs (WitDblFlexVec WitSubEntry::* subVolArg)
   {
   subVol_ = subVolArg;
   }

//------------------------------------------------------------------------------

d473 1
a473 1
      theOpn->*execVol_ = execVolVec;
d482 1
a482 1
      theSub->*subVol_ = subVolVec;
d496 2
a497 2
      theDemand->*shipVol_    = shipVolVec;
      theDemand->*cumShipVol_ = cumShipVolVec;
d506 1
a506 1
      thePart->*scrapVol_ = scrapVolVec;
d515 1
a515 1
      theMat->*stockVol_ = stockVolVec;
d531 1
a531 1
         thePart->*shadowPrice_ = shadowPriceVec;
@


1.135
log
@Rescinded all changed made since 1/31/07.
@
text
@d39 1
d55 7
a61 8
WitDblFlexVec              WitPart::* WitOptImploder::scrapVol_     = NULL;
WitDblFlexVec              WitPart::* WitOptImploder::shadowPrice_  = NULL;
WitDblFlexVec          WitMaterial::* WitOptImploder::stockVol_     = NULL;
WitDblFlexVec            WitDemand::* WitOptImploder::shipVol_      = NULL;
WitDblFlexVec            WitDemand::* WitOptImploder::cumShipVol_   = NULL;
WitDblFlexVec         WitOperation::* WitOptImploder::execVol_      = NULL;
WitDblFlexVec          WitSubEntry::* WitOptImploder::subVol_       = NULL;
WitList <WitPartPer> WitGlobalComp::* WitOptImploder::criticalList_ = NULL;
a296 8
void WitOptImploder::receiveDMPs (
      WitList <WitPartPer> WitGlobalComp::* criticalListArg)
   {
   criticalList_ = criticalListArg;
   }

//------------------------------------------------------------------------------

d620 2
a621 2
   while (not (myGlobalComp ()->*criticalList_).isEmpty ())
      delete (myGlobalComp ()->*criticalList_).get ();
d672 1
a672 1
      (myGlobalComp ()->*criticalList_).append (thePartPer);
@


1.134
log
@[disallowed backlog]
@
text
@d54 7
a88 53
void WitOptImploder::setExecVol (
      WitOperation *       theOpn,
      const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   myOptComp ()->schedOptStarter ()->beChosen ();

   myProblem ()->resetSoln ();

   theOpn->execVol_ () = theValue;
   }

//------------------------------------------------------------------------------

void WitOptImploder::setShipVol (
      WitDemand *          theDemand,
      const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   myOptComp ()->schedOptStarter ()->beChosen ();

   myProblem ()->resetSoln ();

   theDemand->shipVol_ () = theValue;
   }



//------------------------------------------------------------------------------

void WitOptImploder::setSubVol (
      WitSubEntry *        theSub,
      const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   myOptComp ()->schedOptStarter ()->beChosen ();

   myProblem ()->resetSoln ();

   theSub->subVol_ () = theValue;
   }

//------------------------------------------------------------------------------

a189 10
void WitOptImploder::resetShadowPrices ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      thePart->shadowPrice_ () = 0.0;
   }

//------------------------------------------------------------------------------

d247 1
a247 2
   myExtOptMgr_  = NULL;
   extOptActive_ = false;
d257 41
d536 1
a536 1
      theOpn->execVol_ () = execVolVec;
d545 1
a545 1
      theSub->subVol_ () = subVolVec;
d559 2
a560 2
      theDemand->shipVol_    () = shipVolVec;
      theDemand->cumShipVol_ () = cumShipVolVec;
d569 1
a569 1
      thePart->scrapVol_ () = scrapVolVec;
d578 1
a578 1
      theMat->stockVol_ () = stockVolVec;
d594 1
a594 1
         thePart->shadowPrice_ () = shadowPriceVec;
@


1.133
log
@[disallowed backlog]
@
text
@a53 1
WitDblFlexVec          WitSubEntry::* WitOptImploder::subVol_       = NULL;
d94 1
a94 1
   theOpn->execVol_.forUpdate () = theValue;
d111 1
a111 1
   theDemand->shipVol_.forUpdate () = theValue;
d115 18
d241 1
a241 1
      thePart->shadowPrice_.forUpdate () = 0.0;
a312 7
void WitOptImploder::receiveDMPs (WitDblFlexVec WitSubEntry::* subVolArg)
   {
   subVol_ = subVolArg;
   }

//------------------------------------------------------------------------------

d552 1
a552 1
      theOpn->execVol_.forUpdate () = execVolVec;
d561 1
a561 1
      theSub->*subVol_ = subVolVec;
d575 2
a576 2
      theDemand->shipVol_   .forUpdate () = shipVolVec;
      theDemand->cumShipVol_.forUpdate () = cumShipVolVec;
d585 1
a585 1
      thePart->scrapVol_.forUpdate () = scrapVolVec;
d594 1
a594 1
      theMat->stockVol_.forUpdate () = stockVolVec;
d610 1
a610 1
         thePart->shadowPrice_.forUpdate () = shadowPriceVec;
@


1.132
log
@[disallowed backlog]
@
text
@a53 4
WitDblFlexVec          WitMaterial::* WitOptImploder::stockVol_     = NULL;
WitDblFlexVec            WitDemand::* WitOptImploder::shipVol_      = NULL;
WitDblFlexVec            WitDemand::* WitOptImploder::cumShipVol_   = NULL;
WitDblFlexVec         WitOperation::* WitOptImploder::execVol_      = NULL;
d83 35
a295 24
void WitOptImploder::receiveDMPs (WitDblFlexVec WitMaterial::* stockVolArg)
   {
   stockVol_ = stockVolArg;
   }

//------------------------------------------------------------------------------

void WitOptImploder::receiveDMPs (
      WitDblFlexVec WitDemand::* shipVolArg,
      WitDblFlexVec WitDemand::* cumShipVolArg)
   {
   shipVol_    = shipVolArg;
   cumShipVol_ = cumShipVolArg;
   }

//------------------------------------------------------------------------------

void WitOptImploder::receiveDMPs (WitDblFlexVec WitOperation::* execVolArg)
   {
   execVol_ = execVolArg;
   }

//------------------------------------------------------------------------------

d542 1
a542 1
      theOpn->*execVol_ = execVolVec;
d565 2
a566 2
      theDemand->*shipVol_    = shipVolVec;
      theDemand->*cumShipVol_ = cumShipVolVec;
d584 1
a584 1
      theMat->*stockVol_ = stockVolVec;
@


1.131
log
@[disallowed backlog]
@
text
@a53 1
WitDblFlexVec              WitPart::* WitOptImploder::shadowPrice_  = NULL;
d188 10
a264 9
void WitOptImploder::receiveDMPs (
      WitDblFlexVec WitPart::*,
      WitDblFlexVec WitPart::* shadowPriceArg)
   {
   shadowPrice_ = shadowPriceArg;
   }

//------------------------------------------------------------------------------

d593 1
a593 1
         thePart->*shadowPrice_ = shadowPriceVec;
@


1.130
log
@[disallowed backlog]
@
text
@d568 1
a568 1
      thePart->myOptPostData ().scrapVol_ = scrapVolVec;
@


1.129
log
@[disallowed backlog]
@
text
@a53 1
WitDblFlexVec              WitPart::* WitOptImploder::scrapVol_     = NULL;
d257 1
a257 1
      WitDblFlexVec WitPart::* scrapVolArg,
a259 1
   scrapVol_    = scrapVolArg;
d568 1
a568 1
      thePart->*scrapVol_ = scrapVolVec;
@


1.128
log
@[backlog avoidance]
@
text
@d247 2
a248 1
   myExtOptMgr_ = NULL;
@


1.127
log
@External opt implosion.
@
text
@d316 2
d407 28
@


1.126
log
@External opt implosion.
@
text
@d43 1
d425 5
a429 1
      myMsgFac () ("genOptProbMsg");
@


1.125
log
@External opt implosion.
@
text
@d69 1
d120 1
a120 1
   startIntOpt  ();
d196 1
a196 2

   stronglyAssert (not extOptActive ());
d200 1
a200 1
   prepOptImp ();
d202 1
a202 1
   setUpOptProb ();
d215 1
a215 1
   stronglyAssert (extOptActive ());
d229 2
d240 1
a240 1
   stronglyAssert (extOptActive ());
d304 1
a304 15
void WitOptImploder::startIntOpt ()
   {
   prepOptImp ();

   compInitSoln ();

   setUpOptProb ();

   if (myOptComp ()->optInitMethod ()->external ())
      compInitOptSoln ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::prepOptImp ()
d316 9
d567 8
a574 4
   return
      (theOptVar == NULL)?
         0.0:
         theOptVar->primalValue ();
@


1.124
log
@External opt implosion.
@
text
@d119 1
a119 1
   start  ();
d125 1
a125 1
   finish ();
d200 3
a202 1
   start ();
d227 1
a227 1
   finish ();
d302 15
a316 1
void WitOptImploder::start ()
a327 7

   compInitSoln ();

   setUpOptProb ();

   if (myOptComp ()->optInitMethod ()->external ())
      compInitOptSoln ();
d332 1
a332 1
void WitOptImploder::finish ()
@


1.123
log
@External opt implosion.
@
text
@d215 2
d673 2
a674 1
      myImpOptProb_ (theImpOptProb)
d754 2
@


1.122
log
@External opt implosion.
@
text
@d706 1
a706 1
void WitExtOptMgr::getIntVars (WitVector <int> & indices)
@


1.121
log
@External opt implosion.
@
text
@a241 2
   myProblem ()->inputVariant ()->becomesCurrent ();

@


1.120
log
@External opt implosion.
@
text
@d230 21
@


1.119
log
@External opt implosion.
@
text
@d16 1
a16 1
//    ExtOptHandler
d20 1
a20 1
#include <ExtOptHand.h>
d66 1
a66 1
      WitProbAssoc     (theProblem),
d68 5
a72 5
      myImpOptProb_    (NULL),
      myExtOptHandler_ (NULL),
      accelerated_     (false),
      objValue_        (0.0),
      boundsValue_     (0.0)
d82 1
a82 1
   delete myExtOptHandler_;
d202 1
a202 1
   myExtOptHandler_ = new WitExtOptHandler (myImpOptProb ());
d217 1
a217 1
   delete myExtOptHandler_;
d219 1
a219 1
   myExtOptHandler_ = NULL;
d645 1
a645 1
// Implementation of class ExtOptHandler.
d648 1
a648 1
WitExtOptHandler::WitExtOptHandler (WitImpOptProb * theImpOptProb):
d658 1
a658 1
WitExtOptHandler::~WitExtOptHandler ()
d664 1
a664 1
void WitExtOptHandler::getLpProb (
d687 1
a687 1
void WitExtOptHandler::getIntVars (WitVector <int> & indices)
d718 1
a718 1
void WitExtOptHandler::setSoln (const WitIVRealArg & theVector)
d737 1
a737 1
int WitExtOptHandler::scrapVarIndex (WitPart * thePart, WitPeriod thePer)
d744 1
a744 1
int WitExtOptHandler::nonSubVarIndex (WitBomEntry * theBomEnt, WitPeriod thePer)
d751 1
a751 1
int WitExtOptHandler::subVarIndex (WitSubEntry * theSub, WitPeriod thePer)
d758 1
a758 1
int WitExtOptHandler::shipVarIndex (WitDemand * theDemand, WitPeriod thePer)
d765 1
a765 1
int WitExtOptHandler::execVarIndex (WitOperation * theOpn, WitPeriod thePer)
d772 1
a772 1
int WitExtOptHandler::stockVarIndex (WitMaterial * theMat, WitPeriod thePer)
d779 1
a779 1
int WitExtOptHandler::cumShipVarIndex (WitDemand * theDemand, WitPeriod thePer)
d786 1
a786 1
int WitExtOptHandler::execSlbvVarIndex (WitOperation * theOpn, WitPeriod thePer)
d793 1
a793 1
int WitExtOptHandler::stockSlbvVarIndex (WitMaterial * theMat, WitPeriod thePer)
d800 1
a800 1
int WitExtOptHandler::cumShipSlbvVarIndex (
d809 1
a809 1
int WitExtOptHandler::resourceConIndex (WitPart * thePart, WitPeriod thePer)
d816 1
a816 1
int WitExtOptHandler::subConIndex (WitBomEntry * theBomEnt, WitPeriod thePer)
d823 1
a823 1
int WitExtOptHandler::shipConIndex (WitDemand * theDemand, WitPeriod thePer)
d830 1
a830 1
int WitExtOptHandler::execSlbConIndex (WitOperation * theOpn, WitPeriod thePer)
d837 1
a837 1
int WitExtOptHandler::stockSlbConIndex (WitMaterial * theMat, WitPeriod thePer)
d844 1
a844 1
int WitExtOptHandler::cumShipSlbConIndex (
d853 1
a853 1
void WitExtOptHandler::getColData (
d878 1
a878 1
void WitExtOptHandler::getRowData (
d899 1
a899 1
int WitExtOptHandler::slbvVarIndexOf (WitBoundedVar * theBoundedVar)
d913 1
a913 1
int WitExtOptHandler::slbConIndexOf (WitBoundedVar * theBoundedVar)
d927 1
a927 1
int WitExtOptHandler::indexOf (WitOptProbEl * theOptProbEl)
@


1.118
log
@External optimizing implosion.
@
text
@d123 1
a123 1
   myProblem ()->myOptVariant ()->becomesCurrent ();
d136 1
a136 1
   myProblem ()->myInputVariant ()->becomesCurrent ();
d221 1
a221 1
   myProblem ()->myExtOptVariant ()->becomesCurrent ();
@


1.117
log
@External opt implosion.
@
text
@d123 2
d221 2
a310 2
   myProblem ()->myOptVariant ()->becomesCurrent ();

d543 1
a543 1
         positivePart (theOptVar->primalValue ());
@


1.116
log
@external optimzing implosion.
@
text
@d685 1
a685 1
void WitExtOptHandler::getIntIndices (WitVector <int> & intIndices)
d699 1
a699 1
   intIndices.resize (nIntVars);
d708 1
a708 1
         intIndices[vecIdx] = theOptVar->index ();
d716 1
a716 1
void WitExtOptHandler::setColSol (const WitIVRealArg & theVector)
@


1.115
log
@External opt implosion.
@
text
@d662 1
a662 1
void WitExtOptHandler::getProb (
d670 1
a670 3
      WitVector <double> & rowub,
      WitVector <int> &    intIndices,
      double &             objSense)
d677 30
a706 3
   getColData    (collb, colub, obj);
   getRowData    (rowlb, rowub);
   getIntIndices (intIndices);
d708 2
a709 1
   objSense = -1.0;
a896 27
void WitExtOptHandler::getIntIndices (WitVector <int> & intIndices)
   {
   WitOptVar * theOptVar;
   int         nIntVars;
   int         vecIdx;

   nIntVars = 0;

   forEachEl (theOptVar, myImpOptProb_->myOptVars ())
      if (theOptVar->isAnIntVar ())
         nIntVars ++;

   intIndices.resize (nIntVars);

   vecIdx = -1;

   forEachEl (theOptVar, myImpOptProb_->myOptVars ())
      if (theOptVar->isAnIntVar ())
         {
         vecIdx ++;

         intIndices[vecIdx] = theOptVar->index ();
         }
   }

//------------------------------------------------------------------------------

@


1.114
log
@External opt implosion.
@
text
@d281 2
a282 2
   if (myOptComp ()->allowIntCons ())
      validateIntConsMode ();
d334 1
a334 1
void WitOptImploder::validateIntConsMode ()
d337 1
a337 1
      myMsgFac () ("invalidAttrForIntConsSmsg", "computeCriticalList");
d340 1
a340 1
      myMsgFac () ("invalidAttrForIntConsSmsg", "compPrices");
d343 1
a343 1
      myMsgFac () ("invalidAttrForIntConsSmsg", "accAfterOptImp");
d356 1
a356 1
         myMsgFac () ("intExecVolsWoAllowSmsg",
d361 1
a361 1
         myMsgFac () ("intSubVolsWoAllowSmsg",
d368 1
a368 1
         myMsgFac () ("intShipVolsWoAllowSmsg",
@


1.113
log
@External opt implosion.
@
text
@d281 1
a281 1
   if (myOptComp ()->enforceIntCons ())
d283 2
d348 27
@


1.112
log
@External opt implosion.
@
text
@d281 1
a281 1
   if (hasIntCons ())
a331 23
bool WitOptImploder::hasIntCons ()
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;
   WitDemand *    theDemand;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->intExecVols ())
         return true;

   forEachSubEntry (theSub, myProblem ())
      if (theSub->intSubVols ())
         return true;

   forEachDemand (theDemand, myProblem ())
      if (theDemand->intShipVols ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

@


1.111
log
@External opt implosion.
@
text
@d759 16
d796 23
d906 14
@


1.110
log
@External opt implosion.
@
text
@d752 7
d853 14
d869 4
a872 4
   return
      (theOptProbEl != NULL)?
         theOptProbEl->index ():
         -1;
@


1.109
log
@External opt implosion.
@
text
@d703 49
d759 14
@


1.108
log
@External opt implosion.
@
text
@d703 7
d780 10
@


1.107
log
@External opt implosion.
@
text
@d16 1
a16 1
//    ExtOptPerf
d20 1
a20 1
#include <ExtOptPerf.h>
d66 1
a66 1
      WitProbAssoc  (theProblem),
d68 5
a72 5
      myImpOptProb_ (NULL),
      myExtOptPerf_ (NULL),
      accelerated_  (false),
      objValue_     (0.0),
      boundsValue_  (0.0)
d82 1
a82 1
   delete myExtOptPerf_;
d200 1
a200 1
   myExtOptPerf_ = new WitExtOptPerf (myImpOptProb ());
d215 1
a215 1
   delete myExtOptPerf_;
d217 1
a217 1
   myExtOptPerf_ = NULL;
d637 1
a637 1
// Implementation of class ExtOptPerf.
d640 1
a640 1
WitExtOptPerf::WitExtOptPerf (WitImpOptProb * theImpOptProb):
d650 1
a650 1
WitExtOptPerf::~WitExtOptPerf ()
d656 1
a656 1
void WitExtOptPerf::getProb (
d684 1
a684 1
void WitExtOptPerf::setColSol (const WitIVRealArg & theVector)
d703 1
a703 1
void WitExtOptPerf::getColData (
d728 1
a728 1
void WitExtOptPerf::getRowData (
d749 1
a749 1
void WitExtOptPerf::getIntIndices (WitVector <int> & intIndices)
@


1.106
log
@External opt implosion.
@
text
@d41 1
a206 13
void WitOptImploder::setExtOptColSol (const WitIVRealArg & theVector)
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (extOptActive ());

   myImpOptProb ()->setExtOptColSol (theVector);

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

d684 19
@


1.105
log
@External opt implosion.
@
text
@d67 2
a68 1
      extOptActive_ (false),
d71 1
a71 3
      boundsValue_  (0.0),

      myImpOptProb_ (NULL)
d80 2
d90 1
a90 1
      delete myImpOptProb ();
d193 1
a193 3
   stronglyAssert (not extOptActive_);

   extOptActive_ = true;
d199 1
a199 33
   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitOptImploder::getExtOptProb (
      WitVector <int> &    start,
      WitVector <int> &    index,
      WitVector <double> & value,
      WitVector <double> & collb,
      WitVector <double> & colub,
      WitVector <double> & obj,
      WitVector <double> & rowlb,
      WitVector <double> & rowub,
      WitVector <int> &    intIndices,
      double &             objSense)
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (extOptActive_);

   myImpOptProb ()->
      getExtOptProb (
         start,
         index,
         value,
         collb,
         colub,
         obj,
         rowlb,
         rowub,
         intIndices,
         objSense);
d210 1
a210 1
   stronglyAssert (extOptActive_);
d223 1
a223 1
   stronglyAssert (extOptActive_);
d227 4
a232 2
   extOptActive_ = false;

d399 1
a399 1
   if (myImpOptProb () == NULL)
d652 3
a654 1
WitExtOptPerf::WitExtOptPerf (WitProblem * theProblem):
d656 1
a656 1
      WitProbAssoc (theProblem)
d665 101
@


1.104
log
@External opt implosion.
@
text
@d13 4
a16 1
// Contains the implementation of class OptImploder.
d20 1
d205 1
a205 1
void WitOptImploder::getExtOptProblem (
d222 1
a222 1
      getExtOptProblem (
d239 1
a239 1
void WitOptImploder::setExtOptColSolution (const WitIVRealArg & theVector)
d245 1
a245 1
   myImpOptProb ()->setExtOptColSolution (theVector);
d678 16
@


1.103
log
@External opt implosion.
@
text
@d184 3
a186 1
   stronglyAssert (not myOptComp ()->accAfterOptImp ());
@


1.102
log
@External opt implosion.
@
text
@d199 1
a199 1
void WitOptImploder::getOptProbData (
d216 1
a216 1
      getOptProbData (
d233 13
@


1.101
log
@External opt implosion.
@
text
@d363 1
a363 1
      if (theOpn->intConExecVols ())
d367 1
a367 1
      if (theSub->intConSubVols ())
d371 1
a371 1
      if (theDemand->intConShipVols ())
@


1.100
log
@External opt implosion.
@
text
@d61 1
a61 1
      WitProbAssoc   (theProblem),
d63 4
a66 4
      asstOptActive_ (false),
      accelerated_   (false),
      objValue_      (0.0),
      boundsValue_   (0.0),
d68 1
a68 1
      myImpOptProb_  (NULL)
d180 1
a180 1
void WitOptImploder::startAsstOpt ()
d186 1
a186 1
   stronglyAssert (not asstOptActive_);
d188 1
a188 1
   asstOptActive_ = true;
d190 1
a190 1
   myMsgFac () ("startAsstOptMsg");
d213 1
a213 1
   stronglyAssert (asstOptActive_);
d233 1
a233 1
void WitOptImploder::finishAsstOpt ()
d237 1
a237 1
   stronglyAssert (asstOptActive_);
d239 1
a239 1
   myMsgFac () ("finishAsstOptMsg");
d243 1
a243 1
   asstOptActive_ = false;
@


1.99
log
@External opt implosion.
@
text
@d134 3
a313 2
   myImpOptProb ()->checkVarBounds ();

a321 3
   if (myImpOptProb ()->needDual ())
      myImpOptProb ()->reconstructDual ();

a424 7

   if (not asstOptActive_)
      if (not myOptComp ()->skipScreening ())
         myImpOptProb ()->doScreening ();

   if (myOptComp ()->printOptProb ())
      myImpOptProb ()->print ();
@


1.98
log
@Assisted opt implosion.
@
text
@d109 2
a229 13
void WitOptImploder::solveOptProbAsst ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (asstOptActive_);

   myImpOptProb ()->solve ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

@


1.97
log
@Assisted opt implosion.
@
text
@a194 2
      int &                numcols,
      int &                numrows,
d202 3
a204 1
      WitVector <double> & rowub)
a211 2
         numcols,
         numrows,
d219 3
a221 1
         rowub);
@


1.96
log
@Assisted opt implosion.
@
text
@d179 2
@


1.95
log
@Custom opt implosion.
@
text
@d61 1
a61 1
      WitProbAssoc  (theProblem),
d63 4
a66 4
      custActive_   (false),
      accelerated_  (false),
      objValue_     (0.0),
      boundsValue_  (0.0),
d68 1
a68 1
      myImpOptProb_ (NULL)
d175 1
a175 1
void WitOptImploder::startCust ()
d179 1
a179 1
   stronglyAssert (not custActive_);
d181 1
a181 1
   custActive_ = true;
d183 1
a183 1
   myMsgFac () ("startCustOptImpMsg");
d206 1
a206 1
   stronglyAssert (custActive_);
d226 1
a226 1
void WitOptImploder::solveOptProbCust ()
d230 1
a230 1
   stronglyAssert (custActive_);
d239 1
a239 1
void WitOptImploder::finishCust ()
d243 1
a243 1
   stronglyAssert (custActive_);
d245 1
a245 1
   myMsgFac () ("finishCustOptImpMsg");
d249 1
a249 1
   custActive_ = false;
d437 1
a437 1
   if (not custActive_)
@


1.94
log
@App controlled opt implosion.
@
text
@d61 1
a61 1
      WitProbAssoc    (theProblem),
d63 4
a66 5
      active_         (false),
      stdImplosion_   (false),
      accelerated_    (false),
      objValue_       (0.0),
      boundsValue_    (0.0),
d68 1
a68 1
      myImpOptProb_   (NULL)
d107 7
a113 1
   stdImplosion_ = true;
d115 1
a115 3
   start        ();
   solveOptProb ();
   finish       ();
d117 1
a117 1
   stdImplosion_ = false;
d175 1
a175 1
void WitOptImploder::start ()
d179 1
a179 8
   stronglyAssert (not active_);

   if (stdImplosion_)
      myMsgFac () ("optImpMsg");
   else
      myMsgFac () ("startOptImpMsg");

   myProblem ()->resetSoln ();
d181 1
a181 1
   objChoice ()->validateForOptImp ();
d183 1
a183 2
   if (hasIntCons ())
      validateIntConsMode ();
d185 1
a185 12
   myPreprocessor ()->optPreprocess ();

   compInitSoln ();

   setUpOptProb ();

   myImpOptProb ()->checkVarBounds ();

   if (myOptComp ()->optInitMethod ()->external ())
      compInitOptSoln ();

   active_ = true;
d206 1
a206 1
   stronglyAssert (active_);
d226 1
a226 1
void WitOptImploder::solveOptProb ()
d230 1
a230 2
   stronglyAssert (WitOptComp::optImpAllowed ());
   stronglyAssert (active_);
d239 1
a239 1
void WitOptImploder::finish ()
d243 1
a243 1
   stronglyAssert (active_);
d245 1
a245 1
   active_ = false;
d247 1
a247 2
   if (not stdImplosion_)
      myMsgFac () ("finishOptImpMsg");
d249 1
a249 33
   if (myImpOptProb ()->needDual ())
      myImpOptProb ()->reconstructDual ();

   if (myOptComp ()->printOptSoln ())
      myImpOptProb ()->writeSoln ("opSoln.out");

   compObjectives ();

   objChoice ()->writeValues ();

   myProblem ()->myOptVariant ()->becomesCurrent ();

   exportSoln ();

   formCriticalList ();

   if (myGlobalComp ()->pauses ())
      myProblem ()->pauseForInput ("at the conclusion of opt implosion");

   if (myOptComp ()->accAfterOptImp ())
      {
      accelerated_ =
         myMsgFac ().displayStateChange (
            "accStateMsg",
            accelerated (),
            true);

      myOptComp ()->accOptStarter ()->beChosen ();
      }
   else
      shutDown ();

   myPostprocessor ()->postprocess ();
d305 62
d437 1
a437 1
   if (stdImplosion_)
@


1.93
log
@App controlled opt implosion.
@
text
@a175 1
   stronglyAssert (WitOptComp::optImpAllowed ());
a221 1
   stronglyAssert (WitOptComp::optImpAllowed ());
a259 1
   stronglyAssert (WitOptComp::optImpAllowed ());
@


1.92
log
@App controlled opt implosion.
@
text
@d176 1
a176 1
   stronglyAssert (OPT_IMP_MODE);
d223 1
a223 1
   stronglyAssert (OPT_IMP_MODE);
d248 1
a248 1
   stronglyAssert (OPT_IMP_MODE);
d262 1
a262 1
   stronglyAssert (OPT_IMP_MODE);
@


1.91
log
@App controlled opt implosion.
@
text
@d119 53
d176 1
a176 3
   if (not OPT_IMP_MODE)
      myMsgFac () ("optImplodeOnlyFmsg", "WitOptImploder::start");

d209 35
d248 1
a248 3
   if (not OPT_IMP_MODE)
      myMsgFac () ("optImplodeOnlyFmsg", "WitOptImploder::solveOptProb");

d262 1
a262 3
   if (not OPT_IMP_MODE)
      myMsgFac () ("optImplodeOnlyFmsg", "WitOptImploder::finish");

a308 53
void WitOptImploder::evalObjectives ()
   {
   WitTimer::enterSection ("opt-prob");

   myProblem ()->myInputVariant ()->becomesCurrent ();

   myPreprocessor ()->optPreprocess ();

   setUpOptProb ();

   myPostprocessor ()->postprocess ();

   if (not myGlobalComp ()->feasible ())
      myMsgFac () ("infeasObjWmsg");

   myImpOptProb ()->calcInitSoln ();

   compObjectives ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitOptImploder::compObj1Values (double & primaryValue) const
   {
   primaryValue = myImpOptProb ()->myPrimaryObj ()->myValue ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::compObj2Values (
      double & revValue,
      double & invValue,
      double & servValue,
      double & subValue)
      const
   {
   revValue  = myImpOptProb ()-> myRevObj ()->myValue ();
   invValue  = myImpOptProb ()-> myInvObj ()->myValue ();
   servValue = myImpOptProb ()->myServObj ()->myValue ();
   subValue  = myImpOptProb ()-> mySubObj ()->myValue ();
   }

//------------------------------------------------------------------------------

bool WitOptImploder::boundsObjUsed () const
   {
   return myImpOptProb ()->slbvVarsExist ();
   }

//------------------------------------------------------------------------------

@


1.90
log
@App controlled opt implosion.
@
text
@d399 3
a401 2
   if (not myOptComp ()->skipScreening ())
      myImpOptProb ()->doScreening ();
@


1.89
log
@App controlled opt implosion.
@
text
@d121 1
a121 1
   WitTimer::enterSection ("model");
d153 1
a153 1
   WitTimer::leaveSection ("model");
d160 1
a160 1
   WitTimer::enterSection ("model");
d169 1
a169 1
   WitTimer::leaveSection ("model");
d176 1
a176 1
   WitTimer::enterSection ("model");
d222 1
a222 1
   WitTimer::leaveSection ("model");
d229 1
a229 1
   WitTimer::enterSection ("model");
d246 1
a246 1
   WitTimer::leaveSection ("model");
@


1.88
log
@App controlled opt implosion.
@
text
@d64 1
d108 2
d113 2
d128 4
a131 1
   myMsgFac () ("optImpMsg");
d185 3
@


1.87
log
@App controlled opt implosion.
@
text
@a80 9
void WitOptImploder::setActive (bool theValue)
   {
   stronglyAssert (DEVELOPMENT);

   active_ = theValue;
   }

//------------------------------------------------------------------------------

d107 3
a109 3
   start  ();
   solve  ();
   finish ();
d150 1
a150 1
void WitOptImploder::solve ()
d155 1
a155 1
      myMsgFac () ("optImplodeOnlyFmsg", "WitOptImploder::solve");
@


1.86
log
@App controlled opt implosion.
@
text
@d116 9
d128 1
a128 1
      myMsgFac () ("optImplodeOnlyFmsg", "WitOptImploder::implode");
d130 1
a130 1
   active_ = true;
d147 2
d152 16
d170 19
a219 2
   active_ = false;

d397 2
a398 1
   myImpOptProb ()->doScreening ();
@


1.85
log
@App controlled opt implosion.
@
text
@a67 10
      modelOFName_    ("model.out"),
      initSolnOFName_ ("initSoln.out"),
      omSolnOFName_   ("omSoln.out"),

      printOptProb_   (false),
      printMatByCols_ (false),
      printInitSoln_  (false),
      printOptSoln_   (false),
      printMps_       (false),

a79 2
// Data assignment functions.
//------------------------------------------------------------------------------
a87 35
void WitOptImploder::setPrintOptProb (bool theValue)
   {
   printOptProb_ = theValue;
   }

void WitOptImploder::setPrintMatByCols (bool theValue)
   {
   printMatByCols_ = theValue;
   }

void WitOptImploder::setPrintInitSoln (bool theValue)
   {
   printInitSoln_ = theValue;
   }

void WitOptImploder::setPrintOptSoln (bool theValue)
   {
   printOptSoln_ = theValue;
   }

void WitOptImploder::setPrintMps (bool theValue)
   {
   printMps_ = theValue;
   }

void WitOptImploder::setModelOFName (const char * theValue)
   {
   modelOFName_.copyCstring (theValue);
   }

void WitOptImploder::setOmSolnOFName (const char * theValue)
   {
   omSolnOFName_.copyCstring (theValue);
   }

d143 2
a144 2
   if (printOptSoln ())
      myImpOptProb ()->writeSoln (omSolnOFName ());
d353 1
a353 1
   myImpOptProb ()->screenModel ();
d355 1
a355 1
   if (printOptProb ())
d374 2
a375 2
   if (printInitSoln ())
      myImpOptProb ()->writeSoln (initSolnOFName ());
@


1.84
log
@App controlled opt implosion.
@
text
@a24 1
#include <DataAlt.h>
d172 1
a172 1
   postprocAlt ()->incur ();
@


1.83
log
@App controlled opt implosion.
@
text
@d26 2
d180 1
a180 1
   myProblem ()->optPreprocess ();
d220 1
a220 1
   myProblem ()->postprocess ();
d235 1
a235 1
   myProblem ()->optPreprocess ();
d239 1
a239 2
   if (not myProblem ()->postprocessed ())
      myProblem ()->postprocess ();
d379 1
a379 1
      myProblem ()->postprocess ();
@


1.82
log
@App controlled opt implosion.
@
text
@d94 2
@


1.81
log
@App controlled opt implode.
@
text
@d92 5
a278 11
void WitOptImploder::recTitleUpdate ()
   {
   if (myGlobalComp ()->title () == "57625: optImpActive = TRUE")
      active_ = true;

   if (myGlobalComp ()->title () == "57625: optImpActive = FALSE")
      active_ = false;
   }

//------------------------------------------------------------------------------

@


1.80
log
@App controlled opt implosion.
@
text
@d274 11
@


1.79
log
@App controlled opt implode.
@
text
@d62 1
d160 2
d213 2
@


1.78
log
@App controlled opt implosion.
@
text
@d18 1
d36 1
a126 9
// OPT_IMPLODE implementation.
//------------------------------------------------------------------------------

#ifdef OPT_IMPLODE

#include <ImpOptProb.h>
#include <Timing.h>

//------------------------------------------------------------------------------
d156 3
a268 11
bool WitOptImploder::optImpMode () const
   {
   return true;
   }

#endif

//------------------------------------------------------------------------------
// More OPT_IMPLODE-independent implementation.
//------------------------------------------------------------------------------

a316 78
// Non-OPT_IMPLODE implementation.
//------------------------------------------------------------------------------

#ifndef OPT_IMPLODE

//------------------------------------------------------------------------------

void WitOptImploder::shutDown ()
   {
   }

//------------------------------------------------------------------------------

void WitOptImploder::implode ()
   {
   notAllowed ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::evalObjectives ()
   {
   notAllowed ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::compObj1Values (double &) const
   {
   notAllowed ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::compObj2Values (
      double &,
      double &,
      double &,
      double &)
      const 
   {
   notAllowed ();
   }

//------------------------------------------------------------------------------

bool WitOptImploder::boundsObjUsed () const
   {
   notAllowed ();

   return false;
   }

//------------------------------------------------------------------------------

bool WitOptImploder::optImpMode () const
   {
   return false;
   }

#endif

//------------------------------------------------------------------------------
// More OPT_IMPLODE-independent implementation.
//------------------------------------------------------------------------------

void WitOptImploder::notAllowed () const
   {
   myMsgFac () ("optImplodeOnlyFmsg");
   }

//------------------------------------------------------------------------------
// Functions only implemented in OPT_IMPLODE mode.
//------------------------------------------------------------------------------

#ifdef OPT_IMPLODE

//------------------------------------------------------------------------------
a625 2

#endif
@


1.77
log
@Integrality constraints.
@
text
@d68 1
a68 1
      printOptModel_  (false),
d74 1
a74 1
      myImpOM_        (NULL)
d89 1
a89 1
void WitOptImploder::setPrintOptModel (bool theValue)
d91 1
a91 1
   printOptModel_ = theValue;
d130 1
a130 1
#include <ImpOM.h>
d137 1
a137 1
   if (myImpOM_ != NULL)
d139 1
a139 1
      delete myImpOM ();
d141 1
a141 1
      myImpOM_ = NULL;
d176 1
a176 1
   setUpOptModel ();
d181 1
a181 1
   myImpOM ()->solve ();
d184 1
a184 1
      myImpOM ()->writeSoln (omSolnOFName ());
d227 1
a227 1
   setUpOptModel ();
d235 1
a235 1
   myImpOM ()->calcInitSoln ();
d246 1
a246 1
   primaryValue = myImpOM ()->myPrimaryObj ()->myValue ();
d258 4
a261 4
   revValue  = myImpOM ()-> myRevObj ()->myValue ();
   invValue  = myImpOM ()-> myInvObj ()->myValue ();
   servValue = myImpOM ()->myServObj ()->myValue ();
   subValue  = myImpOM ()-> mySubObj ()->myValue ();
d268 1
a268 1
   return myImpOM ()->slbvVarsExist ();
d464 1
a464 1
void WitOptImploder::setUpOptModel ()
d466 1
a466 1
   if (myImpOM () == NULL)
d468 1
a468 1
      myMsgFac () ("genOptModelMsg");
d470 1
a470 1
      myImpOM_ = new WitImpOM (this);
d472 1
a472 1
      myImpOM ()->generateFixed ();
d475 1
a475 1
      myMsgFac () ("updateOptModelMsg");
d479 1
a479 1
   myImpOM ()->generateFlexible ();
d481 1
a481 1
   myImpOM ()->screenModel ();
d483 2
a484 2
   if (printOptModel ())
      myImpOM ()->print ();
d491 1
a491 1
   myImpOM ()->calcInitSoln ();
d503 1
a503 1
      myImpOM ()->writeSoln (initSolnOFName ());
d512 1
a512 1
   objValue_ = myImpOM ()->mainObj ()->myValue ();
d515 2
a516 2
      myImpOM ()->slbvVarsExist ()?
        myImpOM ()->myBoundsObj ()->myValue ():
d548 1
a548 1
            solnValue (myImpOM ()->myExecVar (theOpn, thePer));
d556 2
a557 1
         subVolVec[thePer] = solnValue (myImpOM ()->mySubVar (theSub, thePer));
d567 1
a567 1
            solnValue (myImpOM ()->myShipVar    (theDemand, thePer));
d570 1
a570 1
            solnValue (myImpOM ()->myCumShipVar (theDemand, thePer));
d581 1
a581 1
            solnValue (myImpOM ()->myScrapVar (thePart, thePer));
d590 1
a590 1
            solnValue (myImpOM ()->myStockVar (theMat, thePer));
d602 1
a602 1
            theResCon = myImpOM ()->myResourceCon (thePart, thePer);
d663 1
a663 1
            myImpOM ()->myResourceCon (thePart, thePer)->dualValue ();
@


1.76
log
@Integrality constraints.
@
text
@d418 1
a418 1
      if (theOpn->intExecVols ())
d422 1
a422 1
      if (theSub->intSubVols ())
d426 1
a426 1
      if (theDemand->intShipVols ())
@


1.75
log
@Integrality constraints.
@
text
@a72 1
      stopOpt_        (0),
a113 8
void WitOptImploder::setStopOpt (int theValue)
   {
   witAssert (theValue >= 0);
   witAssert (theValue <= 2);

   stopOpt_ = theValue;
   }

a180 9
   if (stopOpt () == 1)
      {
      shutDown ();

      WitTimer::leaveSection ("model");

      return;
      }

a182 9
   if (stopOpt () == 2)
      {
      shutDown ();

      WitTimer::leaveSection ("model");

      return;
      }

@


1.74
log
@Removed optimizing implosion with lot sizes.
@
text
@d178 3
d438 37
@


1.73
log
@Updated the copyright date on all source files.
@
text
@a86 14

int WitOptImploder::incLotSize (WitOperation * theOpn, WitPeriod thePer)
   {
   return incLotSize_ (theOpn)[thePer];
   }

//------------------------------------------------------------------------------

int WitOptImploder::minLotSize (WitOperation * theOpn, WitPeriod thePer)
   {
   return minLotSize_ (theOpn)[thePer];
   }

//------------------------------------------------------------------------------
a150 3

      if (myOptComp ()->optWithLotSizes ())
         shutDownLotSizes ();
a179 2
   validateOWLS ();

a434 9
int WitOptImploder::lotSizeRatio (WitOperation * theOpn, WitPeriod thePer)
   {
   return
        minLotSize_ (theOpn)[thePer]
      / incLotSize_ (theOpn)[thePer];
   }

//------------------------------------------------------------------------------

a456 3
      if (myOptComp ()->optWithLotSizes ())
         setupLotSizes ();

a705 146
//------------------------------------------------------------------------------

void WitOptImploder::validateOWLS ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         mls;
   double         ils;
   double         lsr;

   if (not myOptComp ()->optWithLotSizes ())
      return;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->twoLevelLotSizes ())
         myMsgFac () ("tllsOwlsSmsg", theOpn->operationName ().myCstring ());

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         mls = theOpn->minLotSize ()[execPer];
         ils = theOpn->incLotSize ()[execPer];

         if (fabs (ils - floor (ils + .001)) > .001)
            myMsgFac () ("fractIlsSmsg",
               theOpn->operationName ().myCstring (),
               execPer,
               ils);

         if (ils < .5)
            continue;

         lsr = mls / ils;

         if (fabs (lsr - floor (lsr + .001)) > .001)
            myMsgFac () ("fractLsrSmsg",
               theOpn->operationName ().myCstring (),
               execPer,
               mls,
               ils,
               lsr);
         }
      
   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("invalidAttrForOwlsSmsg", "computeCriticalList");

   if (myOptComp ()->compPrices ())
      myMsgFac () ("invalidAttrForOwlsSmsg", "compPrices");
      
   if (myOptComp ()->accAfterOptImp ())
      myMsgFac () ("invalidAttrForOwlsSmsg", "accAfterOptImp");
   }

//------------------------------------------------------------------------------

void WitOptImploder::setupLotSizes ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   int            ils;
   int            mls;

   witAssert (myOptComp ()->optWithLotSizes ());

   incLotSize_.allocate (myProblem ());
   minLotSize_.allocate (myProblem ());

   forEachOperation (theOpn, myProblem ())
      {
      incLotSize_.setMapFor (theOpn, * new WitFlexVec <int> (myProblem (), 0));
      minLotSize_.setMapFor (theOpn, * new WitFlexVec <int> (myProblem (), 0));

      forEachPeriod (thePer, myProblem ())
         {
         ils = static_cast <int> (floor (theOpn->incLotSize ()[thePer] + 0.5));
         mls = static_cast <int> (floor (theOpn->minLotSize ()[thePer] + 0.5));

         if (ils == 0)
            mls = 0;
         else if (mls == ils)
            mls = 0;

         incLotSize_ (theOpn).elemRef (thePer) = ils;
         minLotSize_ (theOpn).elemRef (thePer) = mls;
         }

      if (incLotSize_ (theOpn) == incLotSize_ (theOpn)[0])
          incLotSize_ (theOpn) =  incLotSize_ (theOpn)[0];

      if (minLotSize_ (theOpn) == minLotSize_ (theOpn)[0])
          minLotSize_ (theOpn) =  minLotSize_ (theOpn)[0];
      }

   if (printOptModel ())
      printLotSizes ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::printLotSizes ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   witAssert (myOptComp ()->optWithLotSizes ());

   fprintf (msgFile (),
      "\n\n"
      "Working Lot Sizes for Optimizing implosion.\n"
      "-------------------------------------------\n");

   forEachOperation (theOpn, myProblem ())
      {
      fprintf (msgFile (),
         "\n"
         "Operation %s:\n\n",
         theOpn->operationName ().myCstring ());
      
      fprintf (msgFile (), "   Per    MLS    ILS\n");

      forEachPeriod (thePer, myProblem ())
         {
         fprintf (msgFile (),
            "   %3d  %5d  %5d\n",
            thePer,
            minLotSize_ (theOpn)[thePer],
            incLotSize_ (theOpn)[thePer]);
         }
      }
   }

//------------------------------------------------------------------------------

void WitOptImploder::shutDownLotSizes ()
   {
   WitOperation * theOpn;

   witAssert (myOptComp ()->optWithLotSizes ());

   forEachOperation (theOpn, myProblem ())
      {
      delete & (minLotSize_ (theOpn));
      delete & (incLotSize_ (theOpn));
      }
   }

@


1.72
log
@Removed class OptSolver.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.71
log
@Removed some more OSL items.
@
text
@a153 1
#include <OptSolver.h>
@


1.70
log
@Removed some more OSL items.
@
text
@a53 2
bool WitOptImploder::errorHasOccurred_ = false;

d190 13
a202 3
   if (not coinMode ())
      if (errorHasOccurred_)
         myMsgFac () ("postErrOptImpSmsg");
d204 4
a207 1
   try
d209 5
a213 1
      protectedImplode ();
d216 28
a243 1
   catch (...)
d245 5
a249 2
      if (not coinMode ())
         errorHasOccurred_ = true;
d251 1
a251 1
      throw;
d253 4
a316 7
bool WitOptImploder::coinMode ()
   {
   return WitOptSolver::coinMode ();
   }

//------------------------------------------------------------------------------

a430 9
bool WitOptImploder::coinMode ()
   {
   notAllowed ();

   return false;
   }

//------------------------------------------------------------------------------

a463 69
void WitOptImploder::protectedImplode ()
   {
   myMsgFac () ("optImpMsg");

   postprocAlt ()->incur ();

   objChoice ()->validateForOptImp ();

   myProblem ()->optPreprocess ();

   validateOWLS ();

   compInitSoln ();

   setUpOptModel ();

   if (myOptComp ()->optInitMethod ()->external ())
      compInitOptSoln ();

   if (stopOpt () == 1)
      {
      shutDown ();

      return;
      }

   myImpOM ()->solve ();

   if (stopOpt () == 2)
      {
      shutDown ();

      return;
      }

   if (printOptSoln ())
      myImpOM ()->writeSoln (omSolnOFName ());

   compObjectives ();

   objChoice ()->writeValues ();

   myProblem ()->myOptVariant ()->becomesCurrent ();

   exportSoln ();

   formCriticalList ();

   if (myGlobalComp ()->pauses ())
      myProblem ()->pauseForInput ("at the conclusion of opt implosion");

   if (myOptComp ()->accAfterOptImp ())
      {
      accelerated_ =
         myMsgFac ().displayStateChange (
            "accStateMsg",
            accelerated (),
            true);

      myOptComp ()->accOptStarter ()->beChosen ();
      }
   else
      shutDown ();

   myProblem ()->postprocess ();
   }

//------------------------------------------------------------------------------

@


1.69
log
@GPIP
@
text
@d71 1
a71 1
      printOslVecs_   (false),
a74 1
      printMask_      (0),
d111 1
a111 1
void WitOptImploder::setPrintOslVecs (bool theValue)
d113 1
a113 1
   printOslVecs_ = theValue;
a130 8
void WitOptImploder::setPrintMask (int theValue)
   {
   witAssert (theValue >= 0);
   witAssert (theValue <= 1023);

   printMask_ = theValue;
   }

d539 1
a539 1
      myImpOM ()->print (printOslVecs ());
@


1.68
log
@[shared-resource pegging]
@
text
@d489 1
a489 1
      myProblem ()->pauseForInput ();
@


1.67
log
@[shared-resource pegging]
@
text
@a33 1
#include <PtrVec.h>
@


1.66
log
@[shared-resource pegging]
@
text
@d33 3
a35 1
#include <Dense.h>
d696 1
d698 3
a700 1
   WitDenseList <WitPartPer> criticalListDense;
a711 2
   criticalListDense.resize (myCompMgr ()->nParts () * nPeriods ());

d732 1
a732 1
         criticalListDense.append (new WitPartPer (thePart, thePer));
d735 3
a737 1
   criticalListDense.sort (comparePotential, this);
d739 15
a753 1
   forEachElDense (thePartPer, criticalListDense)
d761 1
a761 1
int WitOptImploder::comparePotential (
d763 1
a763 2
      WitPartPer * thePartPer2,
      void *       theContext)
d765 6
a770 9
   WitOptImploder * theOptImp;
   WitPart *        thePart1;
   WitPart *        thePart2;
   WitPeriod        thePer1;
   WitPeriod        thePer2;
   double           pot1;
   double           pot2;

   theOptImp = static_cast <WitOptImploder *> (theContext);
d778 2
a779 2
   pot1      = theOptImp  ->potential_ (thePart1)[thePer1];
   pot2      = theOptImp  ->potential_ (thePart2)[thePer2];
d781 1
a781 1
   return sign (pot2 - pot1);
@


1.65
log
@[error recovery]
@
text
@a22 1
#include <PerPair.h>
d757 2
a758 2
   thePartPer1->getElems (thePart1, thePer1);
   thePartPer2->getElems (thePart2, thePer2);
d760 5
a764 2
   pot1 = theOptImp->potential_ (thePart1) [thePer1];
   pot2 = theOptImp->potential_ (thePart2) [thePer2];
@


1.64
log
@[multi-thread]
@
text
@d54 2
d201 16
a216 1
   innerImplode ();
d440 1
a440 1
void WitOptImploder::innerImplode ()
@


1.63
log
@[multi-thread]
@
text
@d41 15
d278 3
a280 4
void WitOptImploder::loadDataFrom (
      WitPart *       thePart,
      WitDblFlexVec & scrapVolArg,
      WitDblFlexVec & shadowPriceArg)
d282 2
a283 2
   scrapVol_   .setMapFor (thePart, scrapVolArg);
   shadowPrice_.setMapFor (thePart, shadowPriceArg);
d288 1
a288 3
void WitOptImploder::loadDataFrom (
      WitMaterial *   theMat,
      WitDblFlexVec & stockVolArg)
d290 1
a290 1
   stockVol_.setMapFor (theMat, stockVolArg);
d295 3
a297 4
void WitOptImploder::loadDataFrom (
      WitDemand *     theDemand,
      WitDblFlexVec & shipVolArg,
      WitDblFlexVec & cumShipVolArg)
d299 2
a300 2
   shipVol_   .setMapFor (theDemand, shipVolArg);
   cumShipVol_.setMapFor (theDemand, cumShipVolArg);
d305 1
a305 3
void WitOptImploder::loadDataFrom (
      WitOperation *  theOpn,
      WitDblFlexVec & execVolArg)
d307 1
a307 1
   execVol_.setMapFor (theOpn, execVolArg);
d312 1
a312 3
void WitOptImploder::loadDataFrom (
      WitSubEntry *   theSub,
      WitDblFlexVec & subVolArg)
d314 1
a314 1
   subVol_.setMapFor (theSub, subVolArg);
d319 2
a320 2
void WitOptImploder::loadDataFromGlobalComp (
      WitList <WitPartPer> & criticalListArg)
d322 1
a322 1
   criticalList_.attachTo (criticalListArg);
a466 2
   loadData ();

a473 2
   clearLoadedData ();

a573 32
void WitOptImploder::loadData ()
   {
   WitComponent * theComp;
                 
   scrapVol_   .allocate (myProblem ());
   shadowPrice_.allocate (myProblem ());
   stockVol_   .allocate (myProblem ());
   shipVol_    .allocate (myProblem ());
   cumShipVol_ .allocate (myProblem ());
   execVol_    .allocate (myProblem ());
   subVol_     .allocate (myProblem ());

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->loadOpt ();
   }

//------------------------------------------------------------------------------

void WitOptImploder::clearLoadedData ()
   {
   scrapVol_    .clear ();
   shadowPrice_ .clear ();
   stockVol_    .clear ();
   shipVol_     .clear ();
   cumShipVol_  .clear ();
   execVol_     .clear ();
   subVol_      .clear ();
   criticalList_.clear ();
   }

//------------------------------------------------------------------------------

d597 1
a597 1
      execVol_ (theOpn) = execVolVec;
d605 1
a605 1
      subVol_ (theSub) = subVolVec;
d619 2
a620 2
      shipVol_    (theDemand) = shipVolVec;
      cumShipVol_ (theDemand) = cumShipVolVec;
d629 1
a629 1
      scrapVol_ (thePart) = scrapVolVec;
d638 1
a638 1
      stockVol_ (theMat) = stockVolVec;
d654 1
a654 1
         shadowPrice_ (thePart) = shadowPriceVec;
d681 2
a682 2
   while (not  criticalList_ ().isEmpty ())
      delete criticalList_ ().get ();
d719 1
a719 1
      criticalList_ ().append (thePartPer);
@


1.62
log
@[multi-thread]
@
text
@a34 1
#include <DLSort.h>
d745 1
a745 5

   WitDLSorter <WitPartPer, WitOptImploder>::sort (
      criticalListDense,
      comparePotential,
      this);
d756 11
a766 9
      WitPartPer *     thePartPer1,
      WitPartPer *     thePartPer2,
      WitOptImploder * theOptImp)
   {
   WitPart * thePart1;
   WitPart * thePart2;

   WitPeriod thePer1;
   WitPeriod thePer2;
d768 1
a768 2
   double    pot1;
   double    pot2;
@


1.61
log
@[multi-thread]
@
text
@d748 3
a750 3
        criticalListDense,
      & WitOptImploder::comparePotential,
        this);
d761 3
a763 2
      WitPartPer * thePartPer1,
      WitPartPer * thePartPer2)
d777 2
a778 2
   pot1 = potential_ (thePart1) [thePer1];
   pot2 = potential_ (thePart2) [thePer2];
@


1.60
log
@[multi-thread]
@
text
@d34 2
a36 1
#include <Dense.h>
d747 1
a747 1
   WitNonClass::sort (
@


1.59
log
@[multi-thread]
@
text
@a40 4
WitOptImploder * WitOptImploder::curOptImploder_ = NULL;

//------------------------------------------------------------------------------

d746 4
a749 5
   curOptImploder_ = this;

   criticalListDense.sort (comparePotential);

   curOptImploder_ = NULL;
a771 2
   witAssert (curOptImploder_ != NULL);

d775 2
a776 2
   pot1 = curOptImploder_->potential_ (thePart1) [thePer1];
   pot2 = curOptImploder_->potential_ (thePart2) [thePer2];
@


1.58
log
@Revised mappingIndex code.
@
text
@d152 1
d249 7
d378 9
@


1.57
log
@pegged Critical List.
@
text
@a35 1
#include <MapIdxI.h>
@


1.56
log
@An attempt to fix warnings from the gcc 3.3.3 compiler.
@
text
@d312 1
a312 1
   criticalList_.refTo (criticalListArg);
@


1.55
log
@Double Precision.
@
text
@d841 2
a842 2
      incLotSize_.myPtrAt (theOpn) = new WitFlexVec <int> (myProblem (), 0);
      minLotSize_.myPtrAt (theOpn) = new WitFlexVec <int> (myProblem (), 0);
d913 2
a914 2
      delete minLotSize_.myPtrAt (theOpn);
      delete incLotSize_.myPtrAt (theOpn);
@


1.54
log
@Double Precision.
@
text
@d614 1
a614 1
      execVol_ (theOpn).convCopy (execVolVec);
d622 1
a622 1
      subVol_ (theSub).convCopy (subVolVec);
d636 2
a637 2
      shipVol_    (theDemand).convCopy (shipVolVec);
      cumShipVol_ (theDemand).convCopy (cumShipVolVec);
d646 1
a646 1
      scrapVol_ (thePart).convCopy (scrapVolVec);
d655 1
a655 1
      stockVol_ (theMat).convCopy (stockVolVec);
d661 1
a661 1
         shadowPriceVec.setToScalar (0.0);
d671 1
a671 1
         shadowPrice_ (thePart).convCopy (shadowPriceVec);
d859 1
a859 1
         incLotSize_ (theOpn).setToScalar (incLotSize_ (theOpn)[0]);
d862 1
a862 1
         minLotSize_ (theOpn).setToScalar (minLotSize_ (theOpn)[0]);
@


1.53
log
@Double Precision.
@
text
@d261 3
a263 3
      WitPart *             thePart,
      WitFlexVec <double> & scrapVolArg,
      WitFlexVec <double> & shadowPriceArg)
d272 2
a273 2
      WitMaterial *         theMat,
      WitFlexVec <double> & stockVolArg)
d281 3
a283 3
      WitDemand *           theDemand,
      WitFlexVec <double> & shipVolArg,
      WitFlexVec <double> & cumShipVolArg)
d292 2
a293 2
      WitOperation *        theOpn,
      WitFlexVec <double> & execVolArg)
d301 2
a302 2
      WitSubEntry *         theSub,
      WitFlexVec <double> & subVolArg)
@


1.52
log
@Double Precision.
@
text
@d261 3
a263 3
      WitPart *    thePart,
      WitRealVec & scrapVolArg,
      WitRealVec & shadowPriceArg)
d272 2
a273 2
      WitMaterial * theMat,
      WitRealVec &  stockVolArg)
d283 1
a283 1
      WitRealVec  &         cumShipVolArg)
@


1.51
log
@Double Precision.
@
text
@d273 1
a273 1
      WitRealTVc &  stockVolArg)
@


1.50
log
@Double Precision.
@
text
@d454 3
@


1.49
log
@Double Precision.
@
text
@d273 1
a273 1
      WitRealVec &  stockVolArg)
@


1.48
log
@Double Precision.
@
text
@d343 1
a343 1
void WitOptImploder::compObj1Values (float &) const
d350 6
a355 1
void WitOptImploder::compObj2Values (float &, float &, float &, float &) const
d599 1
a599 1
   WitTVec <float>   cumShipVolVec  (myProblem (), 0.0);
d601 3
a603 3
   WitTVec <float>   scrapVolVec    (myProblem (), 0.0);
   WitTVec <float>   stockVolVec    (myProblem (), 0.0);
   WitTVec <float>   shadowPriceVec (myProblem (), 0.0);
d674 1
a674 1
float WitOptImploder::solnValue (const WitOptVar * theOptVar)
d688 1
a688 1
   float         criticalEpsilon;
d755 2
a756 2
   float     pot1;
   float     pot2;
d775 3
a777 3
   float          mls;
   float          ils;
   float          lsr;
@


1.47
log
@Double Precision.
@
text
@d283 1
a283 1
      WitFlexVec <float>  & cumShipVolArg)
@


1.46
log
@Double Precision.
@
text
@d606 1
a606 1
      execVol_ (theOpn).copyTVec (execVolVec);
d614 1
a614 1
      subVol_ (theSub).copyTVec (subVolVec);
d628 2
a629 2
      shipVol_    (theDemand).copyTVec (shipVolVec);
      cumShipVol_ (theDemand).copyTVec (cumShipVolVec);
d638 1
a638 1
      scrapVol_ (thePart).copyFltTVec (scrapVolVec);
d647 1
a647 1
      stockVol_ (theMat).copyFltTVec (stockVolVec);
d663 1
a663 1
         shadowPrice_ (thePart).copyFltTVec (shadowPriceVec);
@


1.45
log
@Double Precision.
@
text
@d261 3
a263 3
      WitPart *             thePart,
      WitFlexVec <float>  & scrapVolArg,
      WitRealVec &          shadowPriceArg)
d272 2
a273 2
      WitMaterial *         theMat,
      WitTVec    <float>  & stockVolArg)
d597 1
d638 1
a638 1
      scrapVol_ (thePart).copyTVec (scrapVolVec);
d642 1
d644 1
a644 1
         stockVol_ (theMat)[thePer] = 
d646 3
@


1.44
log
@Continued double precision.
@
text
@d263 1
a263 1
      WitFlexVec <float>  & shadowPriceArg)
d658 1
a658 1
         shadowPrice_ (thePart).copyTVec (shadowPriceVec);
@


1.43
log
@Continued implementation of PIP.
@
text
@d220 1
a220 1
void WitOptImploder::compObj1Values (float & primaryValue) const
d228 4
a231 4
      float & revValue,
      float & invValue,
      float & servValue,
      float & subValue)
@


1.42
log
@Continued implementation of post-implosion pegging.
@
text
@d23 1
a23 1
#include <Dated.h>
d310 1
a310 1
      WitList <WitDatedPart> & criticalListArg)
d676 6
a681 6
   WitPart *      thePart;
   WitPeriod      thePer;
   float          criticalEpsilon;
   WitDatedPart * theDP;
   WitBopEntry *  theBopEnt;
   bool           producible;
d683 1
a683 1
   WitDenseList <WitDatedPart> criticalListDense;
d717 1
a717 1
         criticalListDense.append (new WitDatedPart (thePart, thePer));
d727 2
a728 2
   forEachElDense (theDP, criticalListDense)
      criticalList_ ().append (theDP);
d736 2
a737 2
      WitDatedPart * partPeriod1,
      WitDatedPart * partPeriod2)
d750 2
a751 2
   thePart1 = partPeriod1->myPart ();
   thePart2 = partPeriod2->myPart ();
d753 2
a754 5
   thePer1  = partPeriod1->myPeriod ();
   thePer2  = partPeriod2->myPeriod ();

   pot1     = curOptImploder_->potential_ (thePart1) [thePer1];
   pot2     = curOptImploder_->potential_ (thePart2) [thePer2];
@


1.41
log
@Continued implementation of post-implosion pegging.
@
text
@a35 1
#include <RefMapI.h>
@


1.40
log
@Continued implementation of post-implosion pegging.
@
text
@a35 1
#include <ScheduleI.h>
d37 1
@


1.39
log
@Fixed a bug with the stopOpt parameter.
Fixed a timing bug.
@
text
@a37 1
#include <FlexVecI.h>
@


1.38
log
@Continued implementation of opt with COIN.
@
text
@d133 1
a133 1
   witAssert (theValue <= 1);
d190 1
a190 68
   myMsgFac () ("optImpMsg");

   postprocAlt ()->incur ();

   objChoice ()->validateForOptImp ();

   myProblem ()->optPreprocess ();

   validateOWLS ();

   compInitSoln ();

   setUpOptModel ();

   if (myOptComp ()->optInitMethod ()->external ())
      compInitOptSoln ();

   if (stopOpt () == 1)
      {
      shutDown ();

      WitTimer::leaveSection ("model");

      return;
      }

   myImpOM ()->solve ();

   if (stopOpt () == 2)
      {
      shutDown ();

      WitTimer::leaveSection ("model");

      return;
      }

   if (printOptSoln ())
      myImpOM ()->writeSoln (omSolnOFName ());

   compObjectives ();

   objChoice ()->writeValues ();

   myProblem ()->myOptVariant ()->becomesCurrent ();

   loadData ();

   exportSoln ();

   formCriticalList ();

   clearLoadedData ();

   if (myOptComp ()->accAfterOptImp ())
      {
      accelerated_ =
         myMsgFac ().displayStateChange (
            "accStateMsg",
            accelerated (),
            true);

      myOptComp ()->accOptStarter ()->beChosen ();
      }
   else
      shutDown ();

   myProblem ()->postprocess ();
d397 70
@


1.37
log
@Continued implementation of proportionate routing.
@
text
@d188 1
a188 1
   WitTimingEvent theEvent ("model");
d211 2
d222 2
d258 2
d266 1
a266 1
   WitTimingEvent theEvent ("model");
d283 2
@


1.36
log
@Changed some C style casts to C++ style.
@
text
@a37 1
#include <RefI.h>
@


1.35
log
@Internal changes.
@
text
@d828 2
a829 2
         ils = (int) floor (theOpn->incLotSize ()[thePer] + 0.5);
         mls = (int) floor (theOpn->minLotSize ()[thePer] + 0.5);
@


1.34
log
@Internal changes.
@
text
@d269 1
a269 1
   if (! myProblem ()->postprocessed ())
d272 1
a272 1
   if (! myGlobalComp ()->feasible ())
d677 1
a677 1
   while (!  criticalList_ ().isEmpty ())
d680 1
a680 1
   if (! myGlobalComp ()->computeCriticalList ())
d764 1
a764 1
   if (! myOptComp ()->optWithLotSizes ())
@


1.33
log
@Continued implementation of two-level lot sizes.
@
text
@d53 1
a53 1
      accelerated_    (witFALSE),
d61 5
a65 5
      printOptModel_  (witFALSE),
      printOslVecs_   (witFALSE),
      printInitSoln_  (witFALSE),
      printOptSoln_   (witFALSE),
      printMps_       (witFALSE),
d98 1
a98 1
void WitOptImploder::setPrintOptModel (WitBoolean theValue)
d103 1
a103 1
void WitOptImploder::setPrintOslVecs (WitBoolean theValue)
d108 1
a108 1
void WitOptImploder::setPrintInitSoln (WitBoolean theValue)
d113 1
a113 1
void WitOptImploder::setPrintOptSoln (WitBoolean theValue)
d118 1
a118 1
void WitOptImploder::setPrintMps (WitBoolean theValue)
d181 1
a181 1
            witFALSE);
d247 1
a247 1
            witTRUE);
d304 1
a304 1
WitBoolean WitOptImploder::boundsObjUsed () const
d311 1
a311 1
WitBoolean WitOptImploder::optImpMode () const
d313 1
a313 1
   return witTRUE;
d419 1
a419 1
WitBoolean WitOptImploder::boundsObjUsed () const
d423 1
a423 1
   return witFALSE;
d428 1
a428 1
WitBoolean WitOptImploder::optImpMode () const
d430 1
a430 1
   return witFALSE;
d673 1
a673 1
   WitBoolean     producible;
d694 1
a694 1
         producible = witFALSE;
d698 1
a698 1
               producible = witTRUE;
@


1.32
log
@Continued implementation of two-level lot sizes.
@
text
@d768 4
a794 6

         if (theOpn->lotSize2Thresh ()[execPer] >= 0.0)
            myMsgFac () ("nNegLotSize2ThreshOwlsSmsg",
               theOpn->operationName ().myCstring (),
               execPer,
               theOpn->lotSize2Thresh ()[execPer]);
@


1.31
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d791 6
@


1.30
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a790 9

         if (! myOptComp ()->allowMLS ())
            if (mls != 0.0)
               if (fabs (mls - ils) > 0.001)
                  myMsgFac () ("invalidMlsSmsg",
                     theOpn->operationName ().myCstring (),
                     execPer,
                     mls,
                     ils);
@


1.29
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d13 1
a13 4
// Contains the implementation of the following classes:
//
// OptImploder
// OptStarter
d34 1
d39 1
a39 1
#include <MsgFac.h>
d77 15
a91 1
   unaccelerate ();
d160 1
a160 1
void WitOptImploder::unaccelerate ()
d162 3
a164 1
   delete myImpOM ();
d166 1
a166 1
   myImpOM_ = NULL;
d168 3
a170 2
   if (! accelerated ())
      return;
d172 4
a175 2
   if (myOptComp ()->accOptStarter ()->isChosen ())
      myOptComp ()->heurOptStarter ()->beChosen ();
d177 6
a182 5
   accelerated_ =
      myMsgFac ().displayStateChange (
         "unaccStateMsg",
         accelerated (),
         witFALSE);
d210 2
a211 1
      unaccelerate ();
d219 1
a219 1
      unaccelerate ();
d252 1
a252 1
      unaccelerate ();
d385 1
a385 1
void WitOptImploder::unaccelerate ()
d452 1
a452 1
void WitOptImploder::validateOWLS ()
d454 3
a456 52
   WitOperation * theOpn;
   WitPeriod      execPer;
   float          mls;
   float          ils;
   float          lsr;

   if (! myOptComp ()->optWithLotSizes ())
      return;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         mls = theOpn->minLotSize ()[execPer];
         ils = theOpn->incLotSize ()[execPer];

         if (fabs (ils - floor (ils + .001)) > .001)
            myMsgFac () ("fractIlsSmsg",
               theOpn->operationName ().myCstring (),
               execPer,
               ils);

         if (ils < .5)
            continue;

         lsr = mls / ils;

         if (fabs (lsr - floor (lsr + .001)) > .001)
            myMsgFac () ("fractLsrSmsg",
               theOpn->operationName ().myCstring (),
               execPer,
               mls,
               ils,
               lsr);

         if (! myOptComp ()->allowMLS ())
            if (mls != 0.0)
               if (fabs (mls - ils) > 0.001)
                  myMsgFac () ("invalidMlsSmsg",
                     theOpn->operationName ().myCstring (),
                     execPer,
                     mls,
                     ils);
         }
      
   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("invalidAttrForOwlsSmsg", "computeCriticalList");

   if (myOptComp ()->compPrices ())
      myMsgFac () ("invalidAttrForOwlsSmsg", "compPrices");
      
   if (myOptComp ()->accAfterOptImp ())
      myMsgFac () ("invalidAttrForOwlsSmsg", "accAfterOptImp");
d483 3
d754 29
a782 1
#endif
d784 7
a790 3
//------------------------------------------------------------------------------
// Implementation of class OptStarter.
//------------------------------------------------------------------------------
d792 12
a803 6
WitOptStarter::WitOptStarter (
         WitOptComp * theOptComp,
         const char * theParamValue,
         WitAttr      theApiAttr,
         WitMsgID     theMsgID,
         WitBoolean   externalVal):
d805 5
a809 7
      myOptComp_  (theOptComp),
      paramValue_ (theParamValue),
      myApiAttr_  (theApiAttr),
      myMsgID_    (theMsgID),
      external_   (externalVal)
   {
   myOptComp ()->store (this);
d814 1
a814 1
WitOptStarter::~WitOptStarter ()
d816 31
a846 1
   }
d848 3
a850 1
//------------------------------------------------------------------------------
d852 2
a853 3
void WitOptStarter::beChosen ()
   {
   myOptComp ()->choose (this);
d858 1
a858 1
WitBoolean WitOptStarter::isChosen () const
d860 2
a861 2
   return (this == myOptComp ()->optInitMethod ());
   }
d863 1
a863 1
//------------------------------------------------------------------------------
d865 4
a868 5
const WitString & WitOptStarter::paramValue (
      const WitOptStarter * theOptStarter)
   {
   return theOptStarter->paramValue ();
   }
d870 8
a877 1
//------------------------------------------------------------------------------
d879 9
a887 3
void WitOptStarter::display () const
   {
   myOptComp ()->myMsgFac () (myMsgID_);
d892 1
a892 1
WitBoolean WitOptStarter::accConflict () const
d894 3
a896 3
   if (this == myOptComp_->accOptStarter ())
      if (! myOptComp_->myProblem ()->myOptImploder ()->accelerated ())
         return witTRUE;
d898 5
a902 1
   return witFALSE;
d904 2
@


1.28
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d439 1
d456 21
a476 7
         if (mls != 0.0)
            if (fabs (mls - ils) > 0.001)
               myMsgFac () ("invalidMlsSmsg",
                  theOpn->operationName ().myCstring (),
                  execPer,
                  mls,
                  ils);
@


1.27
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d15 1
a16 1
// OptImploder
d19 1
a20 1
#include <OptImp.h>
a43 66
// Implementation of class OptStarter.
//------------------------------------------------------------------------------

WitOptStarter::WitOptStarter (
         WitOptComp * theOptComp,
         const char * theParamValue,
         WitAttr      theApiAttr,
         WitMsgID     theMsgID,
         WitBoolean   externalVal):

      myOptComp_  (theOptComp),
      paramValue_ (theParamValue),
      myApiAttr_  (theApiAttr),
      myMsgID_    (theMsgID),
      external_   (externalVal)
   {
   myOptComp ()->store (this);
   }

//------------------------------------------------------------------------------

WitOptStarter::~WitOptStarter ()
   {
   }

//------------------------------------------------------------------------------

void WitOptStarter::beChosen ()
   {
   myOptComp ()->choose (this);
   }

//------------------------------------------------------------------------------

WitBoolean WitOptStarter::isChosen () const
   {
   return (this == myOptComp ()->optInitMethod ());
   }

//------------------------------------------------------------------------------

const WitString & WitOptStarter::paramValue (
      const WitOptStarter * theOptStarter)
   {
   return theOptStarter->paramValue ();
   }

//------------------------------------------------------------------------------

void WitOptStarter::display () const
   {
   myOptComp ()->myMsgFac () (myMsgID_);
   }

//------------------------------------------------------------------------------

WitBoolean WitOptStarter::accConflict () const
   {
   if (this == myOptComp_->accOptStarter ())
      if (! myOptComp_->myProblem ()->myOptImploder ()->accelerated ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------
d61 1
a61 1
      mpSolnOFName_   ("mpSoln.out"),
d132 1
a132 1
void WitOptImploder::setOptSolnOFName (const char * theValue)
d134 1
a134 1
   mpSolnOFName_.copyCstring (theValue);
d206 1
a206 1
      myImpOM ()->writeSoln (mpSolnOFName ());
a426 1

d447 7
d456 2
a457 13
            if (fabs (mls - 1.0) > 0.001)
               myMsgFac () ("invalidLSforOptSmsg",
                  "minLotSize",
                  theOpn->operationName ().myCstring (),
                  execPer,
                  mls);

         ils = theOpn->incLotSize ()[execPer];

         if (ils != 0.0)
            if (fabs (ils - 1.0) > 0.001)
               myMsgFac () ("invalidLSforOptSmsg",
                  "incLotSize",
d460 1
d767 66
@


1.26
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d21 3
@


1.25
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d126 1
a126 1
      printMpModel_   (witFALSE),
d129 1
a129 1
      printMpSoln_    (witFALSE),
d134 1
a134 1
      myImpMp_        (NULL)
d149 1
a149 1
void WitOptImploder::setPrintMpModel (WitBoolean theValue)
d151 1
a151 1
   printMpModel_ = theValue;
d164 1
a164 1
void WitOptImploder::setPrintMpSoln (WitBoolean theValue)
d166 1
a166 1
   printMpSoln_ = theValue;
d195 1
a195 1
void WitOptImploder::setMpSolnOFName (const char * theValue)
d206 1
a206 1
#include <ImpMp.h>
d213 1
a213 1
   delete myImpMp ();
d215 1
a215 1
   myImpMp_ = NULL;
d234 1
a234 1
   WitTimingEvent theEvent ("mp");
d248 1
a248 1
   setUpMpModel ();
d251 1
a251 1
      compInitMpSoln ();
d259 1
a259 1
   myImpMp ()->solve ();
d268 2
a269 2
   if (printMpSoln ())
      myImpMp ()->writeSoln (mpSolnOFName ());
d305 1
a305 1
   WitTimingEvent theEvent ("mp");
d311 1
a311 1
   setUpMpModel ();
d319 1
a319 1
   myImpMp ()->calcInitSoln ();
d328 1
a328 1
   primaryValue = myImpMp ()->myPrimaryObj ()->myValue ();
d340 4
a343 4
   revValue  = myImpMp ()-> myRevObj ()->myValue ();
   invValue  = myImpMp ()-> myInvObj ()->myValue ();
   servValue = myImpMp ()->myServObj ()->myValue ();
   subValue  = myImpMp ()-> mySubObj ()->myValue ();
d350 1
a350 1
   return myImpMp ()->slbvVarsExist ();
d559 1
a559 1
void WitOptImploder::setUpMpModel ()
d561 1
a561 1
   if (myImpMp () == NULL)
d563 1
a563 1
      myMsgFac () ("genMpModelMsg");
d565 1
a565 1
      myImpMp_ = new WitImpMp (this);
d567 1
a567 1
      myImpMp ()->generateFixed ();
d570 1
a570 1
      myMsgFac () ("updateMpModelMsg");
d574 1
a574 1
   myImpMp ()->generateFlexible ();
d576 1
a576 1
   myImpMp ()->screenModel ();
d578 2
a579 2
   if (printMpModel ())
      myImpMp ()->print (printOslVecs ());
d584 1
a584 1
void WitOptImploder::compInitMpSoln ()
d586 1
a586 1
   myImpMp ()->calcInitSoln ();
d598 1
a598 1
      myImpMp ()->writeSoln (initSolnOFName ());
d607 1
a607 1
   objValue_ = myImpMp ()->mainObj ()->myValue ();
d610 2
a611 2
      myImpMp ()->slbvVarsExist ()?
        myImpMp ()->myBoundsObj ()->myValue ():
d656 13
a668 13
   WitOperation *   theOpn;
   WitSubEntry *    theSub;
   WitDemand *      theDemand;
   WitPart *        thePart;
   WitMaterial *    theMat;
   WitPeriod        thePer;
   const WitMpCon * theResCon;
   WitTVec <double> execVolVec     (myProblem (), 0.0);
   WitTVec <double> subVolVec      (myProblem (), 0.0);
   WitTVec <float>  cumShipVolVec  (myProblem (), 0.0);
   WitTVec <double> shipVolVec     (myProblem (), 0.0);
   WitTVec <float>  scrapVolVec    (myProblem (), 0.0);
   WitTVec <float>  shadowPriceVec (myProblem (), 0.0);
d674 1
a674 1
            solnValue (myImpMp ()->myExecVar (theOpn, thePer));
d682 1
a682 1
         subVolVec[thePer] = solnValue (myImpMp ()->mySubVar (theSub, thePer));
d692 1
a692 1
            solnValue (myImpMp ()->myShipVar    (theDemand, thePer));
d695 1
a695 1
            solnValue (myImpMp ()->myCumShipVar (theDemand, thePer));
d706 1
a706 1
            solnValue (myImpMp ()->myScrapVar (thePart, thePer));
d714 1
a714 1
            solnValue (myImpMp ()->myStockVar (theMat, thePer));
d723 1
a723 1
            theResCon = myImpMp ()->myResourceCon (thePart, thePer);
d735 1
a735 1
float WitOptImploder::solnValue (const WitMpVar * theMpVar)
d738 1
a738 1
      (theMpVar == NULL)?
d740 1
a740 1
         positivePart (theMpVar->primalValue ());
d783 1
a783 1
            myImpMp ()->myResourceCon (thePart, thePer)->dualValue ();
@


1.24
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d244 1
a244 1
   validateLS ();
d497 1
a497 1
void WitOptImploder::validateLS ()
d530 9
@


1.23
log
@Continued implementation opt implosion with lot sizes.
@
text
@d124 1
a124 1
      lpSolnOFName_   ("lpSoln.out"),
d126 1
a126 1
      printLpModel_   (witFALSE),
d129 1
a129 1
      printLpSoln_    (witFALSE),
d134 1
a134 1
      myImpLp_        (NULL)
d149 1
a149 1
void WitOptImploder::setPrintLpModel (WitBoolean theValue)
d151 1
a151 1
   printLpModel_ = theValue;
d164 1
a164 1
void WitOptImploder::setPrintLpSoln (WitBoolean theValue)
d166 1
a166 1
   printLpSoln_ = theValue;
d195 1
a195 1
void WitOptImploder::setLpSolnOFName (const char * theValue)
d197 1
a197 1
   lpSolnOFName_.copyCstring (theValue);
d206 1
a206 1
#include <ImpLp.h>
d213 1
a213 1
   delete myImpLp ();
d215 1
a215 1
   myImpLp_ = NULL;
d234 1
a234 1
   WitTimingEvent theEvent ("lp");
d248 1
a248 1
   setUpLpModel ();
d251 1
a251 1
      compInitLpSoln ();
d259 1
a259 1
   myImpLp ()->solve ();
d268 2
a269 2
   if (printLpSoln ())
      myImpLp ()->writeSoln (lpSolnOFName ());
d305 1
a305 1
   WitTimingEvent theEvent ("lp");
d311 1
a311 1
   setUpLpModel ();
d319 1
a319 1
   myImpLp ()->calcInitSoln ();
d328 1
a328 1
   primaryValue = myImpLp ()->myPrimaryObj ()->myValue ();
d340 4
a343 4
   revValue  = myImpLp ()-> myRevObj ()->myValue ();
   invValue  = myImpLp ()-> myInvObj ()->myValue ();
   servValue = myImpLp ()->myServObj ()->myValue ();
   subValue  = myImpLp ()-> mySubObj ()->myValue ();
d350 1
a350 1
   return myImpLp ()->slbvVarsExist ();
d550 1
a550 1
void WitOptImploder::setUpLpModel ()
d552 1
a552 1
   if (myImpLp () == NULL)
d554 1
a554 1
      myMsgFac () ("genLpModelMsg");
d556 1
a556 1
      myImpLp_ = new WitImpLp (this);
d558 1
a558 1
      myImpLp ()->generateFixed ();
d561 1
a561 1
      myMsgFac () ("updateLpModelMsg");
d565 1
a565 1
   myImpLp ()->generateFlexible ();
d567 1
a567 1
   myImpLp ()->screenModel ();
d569 2
a570 2
   if (printLpModel ())
      myImpLp ()->print (printOslVecs ());
d575 1
a575 1
void WitOptImploder::compInitLpSoln ()
d577 1
a577 1
   myImpLp ()->calcInitSoln ();
d589 1
a589 1
      myImpLp ()->writeSoln (initSolnOFName ());
d598 1
a598 1
   objValue_ = myImpLp ()->mainObj ()->myValue ();
d601 2
a602 2
      myImpLp ()->slbvVarsExist ()?
        myImpLp ()->myBoundsObj ()->myValue ():
d653 1
a653 1
   const WitLpCon * theResCon;
d665 1
a665 1
            solnValue (myImpLp ()->myExecVar (theOpn, thePer));
d673 1
a673 1
         subVolVec[thePer] = solnValue (myImpLp ()->mySubVar (theSub, thePer));
d683 1
a683 1
            solnValue (myImpLp ()->myShipVar    (theDemand, thePer));
d686 1
a686 1
            solnValue (myImpLp ()->myCumShipVar (theDemand, thePer));
d697 1
a697 1
            solnValue (myImpLp ()->myScrapVar (thePart, thePer));
d705 1
a705 1
            solnValue (myImpLp ()->myStockVar (theMat, thePer));
d714 1
a714 1
            theResCon = myImpLp ()->myResourceCon (thePart, thePer);
d726 1
a726 1
float WitOptImploder::solnValue (const WitLpVar * theLpVar)
d729 1
a729 1
      (theLpVar == NULL)?
d731 1
a731 1
         positivePart (theLpVar->primalValue ());
d774 1
a774 1
            myImpLp ()->myResourceCon (thePart, thePer)->dualValue ();
@


1.22
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d244 2
d494 39
@


1.21
log
@Fixed a CPU time problem in opt implosion with OSL V3.
@
text
@d19 1
d26 4
d31 2
@


1.20
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d252 7
@


1.19
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d178 1
a178 1
   witAssert (theValue <= 2);
a224 8
void WitOptImploder::closeFilesAtExit ()
   {
   if (myImpLp () != NULL)
      myImpLp ()->closeFilesAtExit ();
   }

//------------------------------------------------------------------------------

a254 6
   if (stopOpt () == 2)
      {
      unaccelerate ();
      return;
      }

a418 6
void WitOptImploder::closeFilesAtExit ()
   {
   }

//------------------------------------------------------------------------------

a512 2

   myImpLp ()->setIsTrivial ();
@


1.18
log
@Began implementation of optimizing implosion with OSL V3.
@
text
@d123 1
a123 1
      dumpMps_        (witFALSE),
d162 1
a162 1
void WitOptImploder::setDumpMps (WitBoolean theValue)
d164 1
a164 1
   dumpMps_ = theValue;
@


1.17
log
@Continued implementation of Single-Source.
@
text
@d494 1
@


1.16
log
@Continued implementation of Single-Source.
@
text
@a82 7
const char * WitOptStarter::myApiAttr (const WitOptStarter * theOptStarter)
   {
   return theOptStarter->myApiAttr ();
   }

//------------------------------------------------------------------------------

@


1.15
log
@Continued implementation of single-source.
@
text
@a19 1
#include <Schedule.h>
d26 1
d28 1
a28 1
#include <MsgFac.h>
d31 1
d134 1
a134 2
      myImpLp_        (NULL),
      potential_      (* new WitSchedule <WitPart, float>)
a142 2

   delete & potential_;
@


1.14
log
@Continued implementation of single-source.
@
text
@d748 1
a748 1
         potential_ (thePart, thePer) =
d751 1
a751 1
         if (potential_ (thePart, thePer) <= criticalEpsilon)
@


1.13
log
@Preliminary work on single source.
@
text
@d29 2
a116 1
      myAccFlag_      (new WitAccFlag),
a117 1

d284 2
d290 2
d370 59
d493 1
a493 1
// Continuation of OPT_IMPLODE-independent implementation.
d588 32
d642 1
a642 1
      execVol (theOpn).copyTVec (execVolVec);
d650 1
a650 1
      subVol (theSub).copyTVec (subVolVec);
d664 2
a665 2
      shipVol    (theDemand).copyTVec (shipVolVec);
      cumShipVol (theDemand).copyTVec (cumShipVolVec);
d674 1
a674 1
      scrapVol (thePart).copyTVec (scrapVolVec);
d679 1
a679 1
         stockVol (theMat)[thePer] = 
d695 1
a695 1
         shadowPrice (thePart).copyTVec (shadowPriceVec);
d722 2
a723 2
   while (!  criticalList (myGlobalComp ()).isEmpty ())
      delete criticalList (myGlobalComp ()).get ();
d765 1
a765 1
      criticalList (myGlobalComp ()).append (theDP);
@


1.12
log
@Preliminary work on single source.
@
text
@d194 1
a194 1
   modelOFName_ = theValue;
d199 1
a199 1
   lpSolnOFName_ = theValue;
@


1.11
log
@Continued preliminary work on single source.
@
text
@d547 1
a547 1
      execVol (theOpn) = execVolVec;
d555 1
a555 1
      subVol (theSub) = subVolVec;
d569 2
a570 2
      shipVol    (theDemand) = shipVolVec;
      cumShipVol (theDemand) = cumShipVolVec;
d579 1
a579 1
      scrapVol (thePart) = scrapVolVec;
d590 1
a590 1
         shadowPriceVec.setTo (0.0);
d600 1
a600 1
         shadowPrice (thePart) = shadowPriceVec;
@


1.10
log
@Continued preliminary work on single source.
@
text
@d26 1
d107 1
a107 1
WitSchedule (WitPart, float) WitOptImploder::potential_;
d133 2
a134 1
      myImpLp_        (NULL)
d143 2
d662 3
d667 2
d681 21
a701 4
   return
      sign (
         potential_ (partPeriod2->myPart ()) [partPeriod2->myPeriod ()] -
         potential_ (partPeriod1->myPart ()) [partPeriod1->myPeriod ()]);
@


1.9
log
@More preliminary work on single source.
@
text
@d530 6
a535 6
   WitTVec (double) execVolVec     (myProblem (), 0.0);
   WitTVec (double) subVolVec      (myProblem (), 0.0);
   WitTVec (float)  cumShipVolVec  (myProblem (), 0.0);
   WitTVec (double) shipVolVec     (myProblem (), 0.0);
   WitTVec (float)  scrapVolVec    (myProblem (), 0.0);
   WitTVec (float)  shadowPriceVec (myProblem (), 0.0);
d586 1
a586 1
         shadowPriceVec = 0.0;
@


1.8
log
@Began implementation of object iteration.
@
text
@d621 1
a621 1
   WitDenseList (WitDatedPart) criticalListDense;
@


1.7
log
@Added shadowPrice and compPrices attributes.
@
text
@d27 1
@


1.6
log
@Implemented and used class SelMgr.
@
text
@d522 13
a534 11
   WitOperation *  theOpn;
   WitSubEntry *   theSub;
   WitDemand *     theDemand;
   WitPart *       thePart;
   WitMaterial *   theMat;
   WitPeriod       thePer;
   WitTVec (double) theExecVol    (myProblem (), 0.0);
   WitTVec (double) theSubVol     (myProblem (), 0.0);
   WitTVec (float)  theCumShipVol (myProblem (), 0.0);
   WitTVec (double) theShipVol    (myProblem (), 0.0);
   WitTVec (float)  theScrapVol   (myProblem (), 0.0);
d539 1
a539 1
         theExecVol[thePer] =
d542 1
a542 1
      execVol (theOpn) = theExecVol;
d548 1
a548 1
         theSubVol[thePer] = solnValue (myImpLp ()->mySubVar (theSub, thePer));
d550 1
a550 1
      subVol (theSub) = theSubVol;
d557 1
a557 1
         theShipVol[thePer]    = 
d560 1
a560 1
         theCumShipVol[thePer] =
d564 2
a565 2
      shipVol    (theDemand) = theShipVol;
      cumShipVol (theDemand) = theCumShipVol;
d571 1
a571 1
         theScrapVol[thePer] = 
d574 1
a574 1
      scrapVol (thePart) = theScrapVol;
d581 16
@


1.5
log
@Some minor changes.
@
text
@a101 6

implementClearContents (WitOptStarter)
   //
   // See RWClient.h.

//------------------------------------------------------------------------------
d604 2
a605 2

   criticalList (myGlobalComp ()).clearContents ();
@


1.4
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d26 1
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d532 6
a537 3
   WitPeriod       t;
   WitTVec (float) theCumShipVol (myProblem (), 0.0);
   WitTVec (float) theScrapVol   (myProblem (), 0.0);
d540 7
a546 3
      forEachPeriod (t, myProblem ())
         execVol (theOpn)[t] =
            solnValue (myImpLp ()->myExecVar (theOpn, t));
d549 6
a554 2
      forEachPeriod (t, myProblem ())
         subVol (theSub)[t] = solnValue (myImpLp ()->mySubVar (theSub, t));
d558 1
a558 1
      forEachPeriod (t, myProblem ())
d560 2
a561 2
         shipVol (theDemand)[t] =
            solnValue (myImpLp ()->myShipVar (theDemand, t));
d563 2
a564 1
         theCumShipVol[t] = solnValue (myImpLp ()->myCumShipVar (theDemand, t));
d567 1
d573 3
a575 2
      forEachPeriod (t, myProblem ())
         theScrapVol[t] = solnValue (myImpLp ()->myScrapVar (thePart, t));
d581 3
a583 2
      forEachPeriod (t, myProblem ())
         stockVol (theMat)[t] = solnValue (myImpLp ()->myStockVar (theMat, t));
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d578 1
a578 1
         WitUtil::positivePart (theLpVar->primalValue ());
d644 1
a644 1
      WitUtil::sign (
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

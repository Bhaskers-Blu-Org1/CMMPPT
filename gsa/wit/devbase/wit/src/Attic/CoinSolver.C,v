head	1.63;
access;
symbols
	sce_5_01_20080919:1.62
	latest_sce_4_20_20060523:1.48.0.2
	sce_4_20_20060523:1.48
	latest_sce4_20_OSL:1.44.0.2
	sce_4_20_OSL:1.44
	sce_410_withVa:1.43
	sce_4_05_20040511:1.29
	sce_4_00_20040201:1.25;
locks; strict;
comment	@ * @;


1.63
date	2010.01.13.19.52.08;	author rjw;	state dead;
branches;
next	1.62;

1.62
date	2008.02.27.23.19.09;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.08.01.22.41.56;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2006.12.29.22.02.47;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.12.06.19.52.45;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.01.21.36.34;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.01.19.55.16;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.20.20.13.46;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2006.10.04.18.45.06;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2006.10.03.15.08.58;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.09.29.22.56.39;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.09.29.18.40.58;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.08.18.18.43.36;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.17.21.21.32;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.02.17.33.55;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.21.21.02.49;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.18.19.06.55;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.14.18.09.24;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.03.15.10.30;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.07.15.16.23;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.17.17.30.43;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.20.20.00.28;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.15.22.42.04;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.15.20.46.03;	author grzes;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.12.19.14.40;	author fasano;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.28.23.28.49;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.29.21.26.23;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.12.21.29.49;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.11.20.39.03;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.10.11.20.01.18;	author grzes;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.08.19.42.51;	author grzes;	state Exp;
branches;
next	1.31;

1.31
date	2004.08.11.15.34.24;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.30.20.25.26;	author grzes;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.20.18.25.21;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.04.16.31.45;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.20.15.37.35;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.18.23.17.28;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.15.23.06.11;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.10.21.57.29;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.10.16.17.50;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.09.15.34.13;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.03.18.09.57;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.06.21.37.20;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.06.17.52.44;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.01.23.05.39;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.01.21.01.38;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.01.20.44.28;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.31.20.04.44;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.31.16.23.29;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.05.20.31.51;	author rjw;	state dead;
branches;
next	1.11;

1.11
date	2003.06.05.19.48.19;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.30.18.19.10;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.28.22.19.27;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.28.15.10.15;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.27.20.34.33;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.27.17.53.21;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.23.18.12.32;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.21.17.37.01;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.20.19.38.31;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.13.22.00.01;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.09.22.42.06;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Multi-objective mode
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "CoinSolver.C"
//
// Contains the implementation of class CoinSolver.
//------------------------------------------------------------------------------

#include <CoinSolver.h>
#include <OptCon.h>
#include <OptVar.h>
#include <OptModel.h>
#include <DetOptImpMgr.h>
#include <OptStarter.h>
#include <OptComp.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <Timing.h>

#ifdef OPT_IMPLODE

#include <coin/OsiClpSolverInterface.hpp>
#include <coin/ClpPresolve.hpp>
#include <coin/ClpFactorization.hpp>
#include <coin/CbcModel.hpp>

//------------------------------------------------------------------------------
// Inlines.
//------------------------------------------------------------------------------

inline bool WitCoinSolver::mipMode ()
   {
   return myOptComp ()->mipMode ();
   }

//------------------------------------------------------------------------------
// Non-inlines.
//------------------------------------------------------------------------------

WitCoinSolver::WitCoinSolver (WitOptModel * theOptModel):

      WitProbAssoc    (theOptModel),
      myOptModel_     (theOptModel),
      lpModeOsiClpSI_ (NULL),
      myCbcModel_     (NULL),
      coinIsSetUp_    (false)
   {
   }

//------------------------------------------------------------------------------

WitCoinSolver::~WitCoinSolver ()
   {
   WitTimer::enterSection ("coin");

   shutDownCoin ();

   WitTimer::leaveSection ("coin");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solve ()
   {
   WitTimer::enterSection ("coin");

   if (myDetOptImpMgr ()->accelerated ())
      myMsgFac () ("reSolveLpMsg");
   else
      {
      myMsgFac () ("solveLpMipMsg",
         myMsgFac ().myFrag (mipMode ()? "mipFrag": "lpFrag"));

      setUpCoin ();

      passFixedProb ();
      }

   passFlexibleProb ();

   writeMps ();

   if (mipMode ())
      solveMIP ();

   else if (myDetOptImpMgr ()->accelerated ())
      solveLpAcc ();

   else
      solveLpUnAcc ();

   myMsgFac () ("optSolnFoundMsg");

   storePrimalSoln ();

   if (myOptModel_->needDual ())
      storeDualSoln ();

   WitTimer::leaveSection ("coin");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::setUpCoin ()
   {
   if (coinIsSetUp_)
      return;

   if (mipMode ())
      {
      OsiClpSolverInterface * theOsiClpSI;

      theOsiClpSI = new OsiClpSolverInterface;

      myCbcModel_ = new CbcModel (* theOsiClpSI);

      delete theOsiClpSI;
      }
   else
      lpModeOsiClpSI_ = new OsiClpSolverInterface;

   setUpMH ();

   coinIsSetUp_ = true;
   }

//------------------------------------------------------------------------------

void WitCoinSolver::setUpMH ()
   {
   FILE *               theFile;
   CoinMessageHandler * theCMH;
   CoinMessageHandler * theCbcCMH;

   theFile = openFile (myOptComp ()->solverLogFileName ().myCstring (), "w");

   theCMH  = new CoinMessageHandler (theFile);

   theCMH->setLogLevel (myOptComp ()->coinLogLevel ());

   myOsiSI ()     ->passInMessageHandler (theCMH);
   myClpSimplex ()->passInMessageHandler (theCMH);

   if (mipMode ())
      {
      theCbcCMH  = new CoinMessageHandler (theFile);

      theCbcCMH->setLogLevel (2);

      myCbcModel ()->passInMessageHandler (theCbcCMH);
      }
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passFixedProb ()
   {
   WitVector <int>    firstCoeffIdx;
   WitVector <int>    rowIdx;
   WitVector <double> coeffVal;

   WitTimer::enterSection ("opt-prob");

   myOptModel_->getMatrixByCols (firstCoeffIdx, rowIdx, coeffVal);

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->loadProblem (
      myOptModel_->nOptVars (),
      myOptModel_->nOptCons (),
      firstCoeffIdx.myCVec (),
      rowIdx.myCVec (),
      coeffVal.myCVec (),
      NULL,
      NULL,
      NULL,
      NULL,
      NULL);
     
   myOsiSI ()->setObjSense (-1.0);
 
   if (mipMode ())
      markIntVars ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::markIntVars ()
   {
   WitOptVar * theOptVar;

   forEachEl (theOptVar, myOptModel_->myOptVars ())
      if (theOptVar->isAnIntVar ())
         myOsiSI ()->setInteger (theOptVar->index ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passFlexibleProb ()
   {
   passConBounds ();
   passVarBounds ();
   passObjCoeffs ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passConBounds ()
   {
   int                nCons;
   WitVector <int>    indexVec;
   WitVector <double> boundVec;
   WitOptCon *        theOptCon;
   int                conIdx;
   int                bndIdx;

   WitTimer::enterSection ("opt-prob");

   nCons = myOptModel_->nOptCons ();

   indexVec.resize (nCons + 1);
   boundVec.resize (nCons * 2);

   bndIdx = 0;

   forEachEl (theOptCon, myOptModel_->myOptCons ())
      {
      conIdx = theOptCon->index ();

      witAssert (bndIdx == conIdx * 2);

      indexVec[conIdx]     = conIdx;

      boundVec[bndIdx]     = theOptCon->bounds ().lower ();
      boundVec[bndIdx + 1] = theOptCon->bounds ().upper ();

      bndIdx += 2;
      }

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->setRowSetBounds (
      indexVec.myCVec (),
      indexVec.myCVec () + nCons,
      boundVec.myCVec ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passVarBounds ()
   {
   int                nVars;
   WitVector <int>    indexVec;
   WitVector <double> boundVec;
   WitOptVar *        theOptVar;
   int                varIdx;
   int                bndIdx;

   WitTimer::enterSection ("opt-prob");

   nVars = myOptModel_->nOptVars ();

   indexVec.resize (nVars + 1);
   boundVec.resize (nVars * 2);

   bndIdx = 0;

   forEachEl (theOptVar, myOptModel_->myOptVars ())
      {
      varIdx = theOptVar->index ();

      witAssert (bndIdx == varIdx * 2);

      indexVec[varIdx]     = varIdx;

      boundVec[bndIdx]     = theOptVar->bounds ().lower ();
      boundVec[bndIdx + 1] = theOptVar->bounds ().upper ();

      bndIdx += 2;
      }

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->setColSetBounds (
      indexVec.myCVec (),
      indexVec.myCVec () + nVars,
      boundVec.myCVec ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passObjCoeffs ()
   {
   int                nVars;
   WitVector <int>    indexVec;
   WitVector <double> objVec;
   WitOptVar *        theOptVar;
   int                theIdx;

   WitTimer::enterSection ("opt-prob");

   nVars = myOptModel_->nOptVars ();

   indexVec.resize (nVars + 1);
   objVec  .resize (nVars);

   forEachEl (theOptVar, myOptModel_->myOptVars ())
      {
      theIdx           = theOptVar->index ();

      indexVec[theIdx] = theIdx;

      objVec  [theIdx] = theOptVar->mainObjCoeffVal ();
      }

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->setObjCoeffSet (
      indexVec.myCVec (),
      indexVec.myCVec () + nVars,
      objVec.myCVec ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::writeMps ()
   {
   if (myOptComp ()->printMps ())
      {
      myMsgFac () ("mpsFileMsg");
      myOsiSI ()->writeMps ("opt-prob", "mps");
      }
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solveMIP ()
   {
   stronglyAssert (mipMode ());

   solveLpUnAcc ();

   myCbcModel ()->branchAndBound ();

   checkMipSolnStatus ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solveLpUnAcc ()
   {
   ClpPresolve thePresolve;

   passInitSoln ();

   if (not myOptComp ()->crashOptStarter ()->isChosen ())
      thePresolve.setDoDual (false);

   thePresolve.presolvedModel (* myClpSimplex (), 1.0e-8, false, 5, true);

   if (thePresolve.model () != NULL)
      {
      invokeSimplex (thePresolve.model ());

      thePresolve.postsolve (true);
	  
      delete thePresolve.model ();

      cleanUpSimplex ();
      }
   else
      {
      if (DEVELOPMENT)
         myMsgFac () ("presolveNullMsg");

      invokeSimplex (myClpSimplex ());
      }

   checkLpSolnStatus ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::invokeSimplex (ClpSimplex * theClpSimplex)
   {
   theClpSimplex->
      setFactorizationFrequency (100 + theClpSimplex->numberRows () / 50);

   if (myOptComp ()->crashOptStarter ()->isChosen ())
      {
      theClpSimplex->tightenPrimalBounds ();

      theClpSimplex->dual ();
      }
   else
      theClpSimplex->primal (1);
   }

//------------------------------------------------------------------------------

void WitCoinSolver::cleanUpSimplex ()
   {
   myClpSimplex ()->factorization ()->areaFactor (0.5);

   myClpSimplex ()->primal (1);
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passInitSoln ()
   {
   WitVector <double> initSoln;
   WitOptVar *        theVar;
      
   if (not myOptComp ()->optInitMethod ()->external ())
      return;

   initSoln.resize (myOptModel_->nOptVars (), 0.0);

   WitTimer::enterSection ("opt-prob");

   forEachEl (theVar, myOptModel_->myOptVars ())
      initSoln[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->setColSolution (initSoln.myCVec ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solveLpAcc ()
   {
   double totPrimalInf;
   double totDualInf;
   bool   useDual;

   myClpSimplex ()->checkSolution ();

   totPrimalInf = myClpSimplex ()->sumPrimalInfeasibilities ();
   totDualInf   = myClpSimplex ()->sumDualInfeasibilities ();

   if (myOptComp ()->accMethod () >= 1)
      fprintf (msgFile (),
         "\n"
         "# Primal Infeasibilities: %d\n"
         "Tot Primal Infeasibility: %g\n"
         "# Dual Infeasibilities:   %d\n"
         "Tot Dual Infeasibility:   %g\n",
         myClpSimplex ()->numberPrimalInfeasibilities (),
         totPrimalInf,
         myClpSimplex ()->numberDualInfeasibilities (),
         totDualInf);

   useDual =
      (myOptComp ()->accMethod () == 2)? false:
      (myOptComp ()->accMethod () == 3)? true:
      (totPrimalInf > totDualInf)?       true:
                                         false;

   if (useDual)
      {
      if (myOptComp ()->accMethod () >= 1)
         fprintf (msgFile (), "Dual Simplex invoked.\n\n");
      
      myClpSimplex ()->dual (0);
      }
   else
      {
      if (myOptComp ()->accMethod () >= 1)
         fprintf (msgFile (), "Primal Simplex invoked.\n\n");

      myClpSimplex ()->primal (0);
      }

   checkLpSolnStatus ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::checkLpSolnStatus ()
   {
   if (myOsiSI ()->isProvenOptimal ())
      return;

   if (myOsiSI ()->isProvenPrimalInfeasible ())
      myOptModel_->reportInfeasible ();

   if (myOsiSI ()->isProvenDualInfeasible ())
      myOptModel_->reportUnbounded ();

   myMsgFac () ("clpOptimalNotFoundSmsg");

   if (myOsiSI ()->isProvenPrimalInfeasible ())
      myMsgFac () ("primalInfeasFmsg");

   if (myOsiSI ()->isProvenDualInfeasible ())
      myMsgFac () ("dualInfeasFmsg");

   if (myOsiSI ()->isAbandoned ())
      myMsgFac () ("abandonedFmsg");

   myMsgFac () ("unknownNonOptReasonFmsg");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::checkMipSolnStatus ()
   {
   if (myCbcModel ()->isProvenOptimal ())
      return;

   if (myCbcModel ()->isProvenInfeasible ())
      myOptModel_->reportInfeasible ();

   myMsgFac () ("clpOptimalNotFoundSmsg");

   if (myCbcModel ()->isProvenInfeasible ())
      myMsgFac () ("primalInfeasFmsg");

   if (myCbcModel ()->isAbandoned ())
      myMsgFac () ("abandonedFmsg");

   myMsgFac () ("unknownNonOptReasonFmsg");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::storePrimalSoln ()
   {
   const double * primalSoln;
   WitOptVar *    theVar;

   primalSoln = myOsiSI ()->getColSolution ();

   WitTimer::enterSection ("opt-prob");

   forEachEl (theVar, myOptModel_->myOptVars ())
      theVar->setPrimalValue (primalSoln[theVar->index ()]);

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::storeDualSoln ()
   {
   const double * dualSoln;
   WitOptCon *    theCon;

   dualSoln = myOsiSI ()->getRowPrice ();

   WitTimer::enterSection ("opt-prob");

   forEachEl (theCon, myOptModel_->myOptCons ())
      theCon->setDualValue (dualSoln[theCon->index ()]);

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::shutDownCoin ()
   {
   CoinMessageHandler * theCMH;
   CoinMessageHandler * theCbcCMH;

   if (not coinIsSetUp_)
      return;

   theCMH = myOsiSI ()->messageHandler ();

   if (mipMode ())
      {
      theCbcCMH = myCbcModel_->messageHandler ();

      delete myCbcModel_;

      myCbcModel_ = NULL;

      delete theCbcCMH;

      theCbcCMH = NULL;
      }
   else
      {
      delete lpModeOsiClpSI_;

      lpModeOsiClpSI_ = NULL;
      }

   shutDownCMH (theCMH);

   coinIsSetUp_ = false;
   }

//------------------------------------------------------------------------------

void WitCoinSolver::shutDownCMH (CoinMessageHandler * & theCMH)
   {
   FILE * theFile;
   int    fcloseRes;

   theFile = theCMH->filePointer ();

   delete theCMH;

   theCMH    = NULL;

   fcloseRes = fclose (theFile);

   if (fcloseRes != 0)
      myMsgFac () ("fcloseSmsg", myOptComp ()->solverLogFileName ());
   }

//------------------------------------------------------------------------------

OsiSolverInterface * WitCoinSolver::myOsiSI ()
   {
   return
      mipMode ()?
         myCbcModel ()->solver ():
         lpModeOsiClpSI_;
   }

//------------------------------------------------------------------------------

ClpSimplex * WitCoinSolver::myClpSimplex ()
   {
   if (mipMode ())
      {
      OsiClpSolverInterface * theOsiClpSI;

      theOsiClpSI =
         static_cast <OsiClpSolverInterface *> (myCbcModel ()->solver ());

      return theOsiClpSI->getModelPtr ();
      }
   else
      return lpModeOsiClpSI_->getModelPtr ();
   }

//------------------------------------------------------------------------------

#endif // OPT_IMPLODE
@


1.62
log
@Stochastic Implosion
@
text
@@


1.61
log
@Stochastic Implosion
@
text
@d19 1
a19 1
#include <OptProb.h>
d47 1
a47 1
WitCoinSolver::WitCoinSolver (WitOptProb * theOptProb):
d49 2
a50 2
      WitProbAssoc    (theOptProb),
      myOptProb_      (theOptProb),
d103 1
a103 1
   if (myOptProb_->needDual ())
d171 1
a171 1
   myOptProb_->getMatrixByCols (firstCoeffIdx, rowIdx, coeffVal);
d176 2
a177 2
      myOptProb_->nOptVars (),
      myOptProb_->nOptCons (),
d199 1
a199 1
   forEachEl (theOptVar, myOptProb_->myOptVars ())
d226 1
a226 1
   nCons = myOptProb_->nOptCons ();
d233 1
a233 1
   forEachEl (theOptCon, myOptProb_->myOptCons ())
d268 1
a268 1
   nVars = myOptProb_->nOptVars ();
d275 1
a275 1
   forEachEl (theOptVar, myOptProb_->myOptVars ())
d309 1
a309 1
   nVars = myOptProb_->nOptVars ();
d314 1
a314 1
   forEachEl (theOptVar, myOptProb_->myOptVars ())
d425 1
a425 1
   initSoln.resize (myOptProb_->nOptVars (), 0.0);
d429 1
a429 1
   forEachEl (theVar, myOptProb_->myOptVars ())
d494 1
a494 1
      myOptProb_->reportInfeasible ();
d497 1
a497 1
      myOptProb_->reportUnbounded ();
d521 1
a521 1
      myOptProb_->reportInfeasible ();
d545 1
a545 1
   forEachEl (theVar, myOptProb_->myOptVars ())
d562 1
a562 1
   forEachEl (theCon, myOptProb_->myOptCons ())
@


1.60
log
@Stochastic Implosion
@
text
@d20 1
a20 1
#include <OptImp.h>
d74 1
a74 1
   if (myOptImploder ()->accelerated ())
d93 1
a93 1
   else if (myOptImploder ()->accelerated ())
@


1.59
log
@External opt implosion.
@
text
@d49 1
a49 2
      WitProbAssoc    (theOptProb->myProblem ()),

@


1.58
log
@External opt implosion.
@
text
@d23 1
d79 2
a80 4
      if (mipMode ())
         myMsgFac () ("solveMipMsg");
      else
         myMsgFac () ("solveLpMsg");
@


1.57
log
@External opt implosion.
@
text
@d39 1
a39 1
   return myOptComp ()->allowIntCons ();
d353 2
d388 1
a388 1
   checkSolnStatus ();
d485 1
a485 1
   checkSolnStatus ();
d490 1
a490 1
void WitCoinSolver::checkSolnStatus ()
d517 21
@


1.56
log
@External opt implosion.
@
text
@d39 1
a39 1
   return myOptComp ()->enforceIntCons ();
@


1.55
log
@External opt implosion.
@
text
@d39 1
a39 1
   return myOptProb_->isaMIP ();
@


1.54
log
@App controlled opt implosion.
@
text
@d61 1
a61 1
   WitTimer::enterSection ("coin-other");
d65 1
a65 1
   WitTimer::leaveSection ("coin-other");
d72 1
a72 1
   WitTimer::enterSection ("coin-other");
d108 1
a108 1
   WitTimer::leaveSection ("coin-other");
a362 2
   WitTimer::enterSection ("coin-pre-post");

a367 2
   WitTimer::leaveSection ("coin-pre-post");

a371 2
      WitTimer::enterSection ("coin-pre-post");

a375 2
      WitTimer::leaveSection ("coin-pre-post");

a392 2
   WitTimer::enterSection ("coin-simplex");

a403 2

   WitTimer::leaveSection ("coin-simplex");
a409 2
   WitTimer::enterSection ("coin-clean-up");

a412 2

   WitTimer::leaveSection ("coin-clean-up");
@


1.53
log
@App controlled opt implosion.
@
text
@d167 3
a169 3
   WitVector <int>    indexRow;
   WitVector <int>    startOfEachColumn;
   WitVector <double> elements;
d173 1
a173 1
   myOptProb_->defMatrixByCols (indexRow, startOfEachColumn, elements);
d180 3
a182 3
      startOfEachColumn.myCVec (),
      indexRow.myCVec (),
      elements.myCVec (),
@


1.52
log
@App controlled opt implosion.
@
text
@d85 1
a85 1
      passFixedModel ();
d88 1
a88 1
   passFlexibleModel ();
d165 1
a165 1
void WitCoinSolver::passFixedModel ()
d171 1
a171 1
   WitTimer::enterSection ("model");
d175 1
a175 1
   WitTimer::leaveSection ("model");
d208 1
a208 1
void WitCoinSolver::passFlexibleModel ()
d226 1
a226 1
   WitTimer::enterSection ("model");
d249 1
a249 1
   WitTimer::leaveSection ("model");
d268 1
a268 1
   WitTimer::enterSection ("model");
d291 1
a291 1
   WitTimer::leaveSection ("model");
d309 1
a309 1
   WitTimer::enterSection ("model");
d325 1
a325 1
   WitTimer::leaveSection ("model");
d340 1
a340 1
      myOsiSI ()->writeMps ("model", "mps");
d443 1
a443 1
   WitTimer::enterSection ("model");
d448 1
a448 1
   WitTimer::leaveSection ("model");
d538 1
a538 1
   WitTimer::enterSection ("model");
d543 1
a543 1
   WitTimer::leaveSection ("model");
d555 1
a555 1
   WitTimer::enterSection ("model");
d560 1
a560 1
   WitTimer::leaveSection ("model");
@


1.51
log
@App controlled opt implosion.
@
text
@d75 1
a75 1
      myMsgFac () ("reSolveLpMsg", "COIN");
d79 1
a79 1
         myMsgFac () ("solveMipMsg", "COIN");
d81 1
a81 1
         myMsgFac () ("solveLpMsg", "COIN");
@


1.50
log
@App controlled opt implosion.
@
text
@d337 1
a337 1
   if (myOptImploder ()->printMps ())
@


1.49
log
@Integrality constraints.
@
text
@d13 1
a13 1
// Contains the main and dummy implementations of class CoinSolver.
d19 1
a19 1
#include <OptModel.h>
d39 1
a39 1
   return myOptModel_->isaMIP ();
d46 1
a46 1
WitCoinSolver::WitCoinSolver (WitOptModel * theOptModel):
d48 1
a48 1
      WitProbAssoc    (theOptModel->myProblem ()),
d50 1
a50 1
      myOptModel_     (theOptModel),
d105 1
a105 1
   if (myOptModel_->needDual ())
d173 1
a173 1
   myOptModel_->defMatrixByCols (indexRow, startOfEachColumn, elements);
d178 2
a179 2
      myOptModel_->nOptVars (),
      myOptModel_->nOptCons (),
d201 1
a201 1
   forEachEl (theOptVar, myOptModel_->myOptVars ())
d228 1
a228 1
   nCons = myOptModel_->nOptCons ();
d235 1
a235 1
   forEachEl (theOptCon, myOptModel_->myOptCons ())
d270 1
a270 1
   nVars = myOptModel_->nOptVars ();
d277 1
a277 1
   forEachEl (theOptVar, myOptModel_->myOptVars ())
d311 1
a311 1
   nVars = myOptModel_->nOptVars ();
d316 1
a316 1
   forEachEl (theOptVar, myOptModel_->myOptVars ())
d441 1
a441 1
   initSoln.resize (myOptModel_->nOptVars (), 0.0);
d445 1
a445 1
   forEachEl (theVar, myOptModel_->myOptVars ())
d510 1
a510 1
      myOptModel_->reportInfeasible ();
d513 1
a513 1
      myOptModel_->reportUnbounded ();
d540 1
a540 1
   forEachEl (theVar, myOptModel_->myOptVars ())
d557 1
a557 1
   forEachEl (theCon, myOptModel_->myOptCons ())
@


1.48
log
@Updated the copyright date on all source files.
@
text
@a73 9
   innerSolve ();

   WitTimer::leaveSection ("coin-other");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::innerSolve ()
   {
a91 3
   if (myOptImploder ()->stopOpt () == 2)
      return;

d107 2
@


1.47
log
@Removed class OptSolver.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.46
log
@Removed class OslSolver.
@
text
@d39 1
a39 1
   return myOptModel ()->isaMIP ();
d48 3
a50 1
      WitOptSolver    (theOptModel),
d117 1
a117 1
   if (myOptModel ()->needDual ())
d183 1
a183 1
   myOptModel ()->defMatrixByCols (indexRow, startOfEachColumn, elements);
d188 2
a189 2
      myOptModel ()->nOptVars (),
      myOptModel ()->nOptCons (),
d211 1
a211 1
   forEachEl (theOptVar, myOptModel ()->myOptVars ())
d238 1
a238 1
   nCons = myOptModel ()->nOptCons ();
d245 1
a245 1
   forEachEl (theOptCon, myOptModel ()->myOptCons ())
d280 1
a280 1
   nVars = myOptModel ()->nOptVars ();
d287 1
a287 1
   forEachEl (theOptVar, myOptModel ()->myOptVars ())
d321 1
a321 1
   nVars = myOptModel ()->nOptVars ();
d326 1
a326 1
   forEachEl (theOptVar, myOptModel ()->myOptVars ())
d451 1
a451 1
   initSoln.resize (myOptModel ()->nOptVars (), 0.0);
d455 1
a455 1
   forEachEl (theVar, myOptModel ()->myOptVars ())
d520 1
a520 1
      myOptModel ()->reportInfeasible ();
d523 1
a523 1
      myOptModel ()->reportUnbounded ();
d550 1
a550 1
   forEachEl (theVar, myOptModel ()->myOptVars ())
d567 1
a567 1
   forEachEl (theCon, myOptModel ()->myOptCons ())
@


1.45
log
@Fixed a bug in witEvalObjectives in COIN mode.
@
text
@a27 12
//------------------------------------------------------------------------------
// COIN_BUILD
//
// Determines whether or not the implementation of class CoinSolver is to be
// compiled.
//
// By default, COIN_BUILD is undefined; to build WIT with class CoinSolver
// implemented, use the compiler flag -DCOIN_BUILD.
//------------------------------------------------------------------------------

#ifdef COIN_BUILD

a654 2
#endif // COIN_BUILD

@


1.44
log
@Fixed a non-portable #include.
@
text
@d62 2
a63 1
      myCbcModel_     (NULL)
d135 3
d152 2
d590 3
d615 2
@


1.43
log
@[exceptions]
@
text
@d42 1
a42 1
#include <ClpFactorization.hpp>
@


1.42
log
@Made opt implosion use COIN unconditionally when COIN_BUILD is defined.
@
text
@d624 1
a624 1
      myMsgFac () ("fcloseError", myOptComp ()->solverLogFileName ());
@


1.41
log
@Modified calls to COIN for unaccelerated mode.
@
text
@d31 2
a32 1
// Determines which implementation of class CoinSolver is to be compiled.
d34 2
a35 13
// If COIN_BUILD is defined, the main implementation of class CoinSolver is to
// be compiled. The main implementation makes calls to COIN functions.
//
// If COIN_BUILD is undefined, the dummy implementation of class CoinSolver is
// to be compiled. The dummy implementation does not make calls to COIN
// functions.
//
// By default, COIN_BUILD is undefined; to build WIT with the main
// implementation of class CoinSolver, use the compiler flag -DCOIN_BUILD.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Main implementation of class CoinSolver.
d656 1
a656 36
#endif // COIN_BUILD defined

//------------------------------------------------------------------------------
// Dummy implementation of class CoinSolver.
//------------------------------------------------------------------------------

#ifndef COIN_BUILD

//------------------------------------------------------------------------------

WitCoinSolver::WitCoinSolver (WitOptModel * theOptModel):

      WitOptSolver    (theOptModel),
      lpModeOsiClpSI_ (NULL),
      myCbcModel_     (NULL)
   {
   myMsgFac () ("coinNotSuppSmsg");
   }

//------------------------------------------------------------------------------

WitCoinSolver::~WitCoinSolver ()
   {
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solve ()
   {
   }

//------------------------------------------------------------------------------

#endif // COIN_BUILD undefined

//------------------------------------------------------------------------------
@


1.40
log
@Minor modifications.
@
text
@d80 1
a80 1
   WitTimer::enterSection ("coin");
d84 1
a84 1
   WitTimer::leaveSection ("coin");
d91 1
a91 1
   WitTimer::enterSection ("coin");
d95 1
a95 1
   WitTimer::leaveSection ("coin");
d383 1
a383 4
   ClpPresolve  thePresolve1;
   ClpPresolve  thePresolve2;
   ClpSimplex * thePsSimplex1;
   ClpSimplex * thePsSimplex2;
d385 1
a385 1
   myClpSimplex ()->dropNames ();
d387 1
a387 1
   passInitSoln ();
d390 5
a394 1
      thePresolve1.setDoDual (false);
d396 5
a400 1
   thePresolve1.setPresolveActions (511);
d402 3
a404 2
   thePsSimplex1 =
      thePresolve1.presolvedModel (* myClpSimplex () , 1.0e-8, false, 1, true);
d406 1
a406 2
   if (thePsSimplex1 == NULL)
      myMsgFac () ("presolveNullSmsg");
d408 6
a413 2
   if (not myOptComp ()->crashOptStarter ()->isChosen ())
      thePresolve2.setDoDual (false);
d415 2
a416 2
   thePsSimplex2 =
      thePresolve2.presolvedModel (* thePsSimplex1, 1.0e-8, false, 5, true);
d418 2
a419 2
   if (thePsSimplex2 == NULL)
      myMsgFac () ("presolveNullSmsg");
d421 8
a428 2
   thePsSimplex2->
      setFactorizationFrequency (100 + thePsSimplex2->numberRows () / 50);
d432 3
a434 2
      thePsSimplex2->tightenPrimalBounds ();
      thePsSimplex2->dual ();
d437 1
a437 1
      thePsSimplex2->primal (1);
d439 2
a440 3
   thePresolve2.postsolve (true);
	  
   delete thePsSimplex2;
d442 1
a442 1
   thePsSimplex2 = NULL;
d444 3
a446 9
   thePsSimplex1->primal (1);
      
   thePresolve1.postsolve (true);
	  
   delete thePsSimplex1;
      
   thePsSimplex1 = NULL;
	 
   myClpSimplex ()->checkSolution ();
d448 1
a448 3
   if (myClpSimplex ()->problemStatus ())
      {
      myClpSimplex ()->factorization ()->areaFactor (0.5);
d450 1
a450 2
      myClpSimplex ()->primal (1);
      }
d452 1
a452 1
   checkSolnStatus ();
a474 1

@


1.39
log
@*** empty log message ***
@
text
@d213 1
a213 1
   myOsiSI ()-> setObjSense (-1.0);
d383 4
a386 3
   ClpPresolve  thePresolve, theSecondPresolve;
   ClpSimplex * presolvedCS;
   ClpSimplex * workCS;
d388 1
a388 1
   myClpSimplex () -> dropNames ();
d393 1
a393 1
      thePresolve.setDoDual (false);
d395 1
a395 1
    thePresolve.setPresolveActions(511);
d397 2
a398 1
    presolvedCS = thePresolve.presolvedModel (* myClpSimplex () , 1.0e-8, false,1,true);
d400 24
a423 24
    if (!presolvedCS) 
    {
       printf("infeasible after first presolve!\n");
       exit(1);
    }
    // Now second
    if (not myOptComp ()->crashOptStarter ()->isChosen ())
	  theSecondPresolve.setDoDual(false); // clobbers feasible solution
    workCS = theSecondPresolve.presolvedModel (* presolvedCS, 1.0e-8, false,5,true);

	if (!workCS) 
    {
       printf("infeasible after second presolve!\n");
       exit(1);
    }
    workCS->setFactorizationFrequency (100 + workCS->numberRows () / 50);
    if (myOptComp ()->crashOptStarter ()->isChosen ())
	{
      workCS->tightenPrimalBounds();
      workCS->dual();
    }
    else
      workCS->primal (1);
    theSecondPresolve.postsolve (true);
d425 3
a427 2
    delete workCS;
    workCS = NULL;
d429 1
a429 1
    presolvedCS ->primal (1);
d431 1
a431 1
    thePresolve.postsolve (true);
d433 1
a433 1
    delete presolvedCS;
d435 1
a435 1
    presolvedCS = NULL;
d437 9
a445 7
    // Check if we need to
    myClpSimplex () -> checkSolution ();
    if (myClpSimplex () -> problemStatus ())
    {
       myClpSimplex ()-> factorization () ->areaFactor(0.5);
       myClpSimplex ()->primal (1);
    }
@


1.38
log
@Updated to use COIN Cbc instead of Sbb
@
text
@d52 1
d212 3
a214 3
      
   myOsiSI ()->setObjSense (-1.0);

d383 1
a383 1
   ClpPresolve  thePresolve;
d387 2
d394 1
a394 1
   presolvedCS = thePresolve.presolvedModel (* myClpSimplex (), 1.0e-8);
d396 1
a396 6
   workCS =
      (presolvedCS != NULL)?
         presolvedCS:
         myClpSimplex ();
         
   workCS->setFactorizationFrequency (100 + workCS->numberRows () / 50);
d398 22
a419 3
   if (myOptComp ()->crashOptStarter ()->isChosen ())
      workCS->dual ();
   else
d421 4
d426 15
a440 13
   workCS = NULL;

   if (presolvedCS != NULL)
      {
      thePresolve.postsolve (true);

      delete presolvedCS;

      presolvedCS = NULL;

      myClpSimplex ()->primal (1);
      }

@


1.37
log
@FIxed a bug in extracting the dual solution from COIN.
@
text
@d52 1
a52 1
#include <coin/SbbModel.hpp>
d71 1
a71 1
      mySbbModel_     (NULL)
d149 1
a149 1
      mySbbModel_ = new SbbModel (* theOsiClpSI);
d165 1
a165 1
   CoinMessageHandler * theSbbCMH;
d178 1
a178 1
      theSbbCMH  = new CoinMessageHandler (theFile);
d180 1
a180 1
      theSbbCMH->setLogLevel (2);
d182 1
a182 1
      mySbbModel ()->passInMessageHandler (theSbbCMH);
d375 1
a375 1
   mySbbModel ()->branchAndBound ();
d559 1
a559 1
   CoinMessageHandler * theSbbCMH;
d565 1
a565 1
      theSbbCMH = mySbbModel_->messageHandler ();
d567 1
a567 1
      delete mySbbModel_;
d569 1
a569 1
      mySbbModel_ = NULL;
d571 1
a571 1
      delete theSbbCMH;
d573 1
a573 1
      theSbbCMH = NULL;
d610 1
a610 1
         mySbbModel ()->solver ():
d623 1
a623 1
         static_cast <OsiClpSolverInterface *> (mySbbModel ()->solver ());
d647 1
a647 1
      mySbbModel_     (NULL)
@


1.36
log
@Low-Pri Prop-Rt.
@
text
@d549 1
a549 1
      theCon->setDualValue (- dualSoln[theCon->index ()]);
@


1.35
log
@Added "solverIsCoin" attribute.
@
text
@d396 1
a396 1
         myClpSimplex();
@


1.34
log
@Minor modifications.
@
text
@d649 1
a649 1
   myMsgFac () ("coinNYAvailSmsg");
@


1.33
log
@Minor bugfix.
@
text
@d218 1
a218 1
//-----------------------------------------------------------------------------
d383 2
a384 1
   ClpSimplex * presolvedCS=NULL;
d389 1
a389 3
     {
       thePresolve.setDoDual(false);
     }
d392 15
a406 1
   
a408 6
      presolvedCS->setFactorizationFrequency(100+presolvedCS->numberRows()/50);
      if (myOptComp ()->crashOptStarter ()->isChosen ())
         presolvedCS->dual();
      else
         presolvedCS->primal (1);

a415 8
      }
   else
      {
      myClpSimplex()->setFactorizationFrequency(100+myClpSimplex()->numberRows()/50);
      if (myOptComp ()->crashOptStarter ()->isChosen ())
         myClpSimplex ()->dual( );
      else  
         myClpSimplex ()->primal (1);
@


1.32
log
@*** empty log message ***
@
text
@d412 1
a412 1
      myClpSimplex()->setFactorizationFrequency(100+presolvedCS->numberRows()/50);
@


1.31
log
@Trivial change.
@
text
@d218 1
a218 1
//------------------------------------------------------------------------------
a362 1

d383 1
a383 1
   ClpSimplex * presolvedCS;
d387 5
d393 1
a393 1

d396 1
d398 3
a400 3
         presolvedCS->crash (0.0, 2);

      presolvedCS->primal (1);
d412 1
d414 3
a416 3
         myClpSimplex ()->crash (0.0, 2);

      myClpSimplex ()->primal (1);
d428 1
a428 1
   
d442 1
@


1.30
log
@modifications to build with current COIN code
@
text
@d383 1
a383 1
   ClpPresolve     thePresolve;
@


1.29
log
@Double Precision.
@
text
@d51 1
a51 1
#include <coin/Presolve.hpp>
d383 1
a383 1
   Presolve     thePresolve;
@


1.28
log
@Double Precision.
@
text
@d345 1
a345 1
      objVec  [theIdx] = dblFromFlt (theOptVar->mainObjCoeffVal ());
@


1.27
log
@Double Precision.
@
text
@d345 1
a345 1
      objVec  [theIdx] = doubleFromFloat (theOptVar->mainObjCoeffVal ());
@


1.26
log
@Continued double precision.
@
text
@d203 3
a205 3
      startOfEachColumn.myCvector (),
      indexRow.myCvector (),
      elements.myCvector (),
d275 3
a277 3
      indexVec.myCvector (),
      indexVec.myCvector () + nCons,
      boundVec.myCvector ());
d317 3
a319 3
      indexVec.myCvector (),
      indexVec.myCvector () + nVars,
      boundVec.myCvector ());
d351 3
a353 3
      indexVec.myCvector (),
      indexVec.myCvector () + nVars,
      objVec.myCvector ());
d435 1
a435 1
   myOsiSI ()->setColSolution (initSoln.myCvector ());
@


1.25
log
@Continued implementation of opt with COIN.
@
text
@d345 1
a345 1
      objVec  [theIdx] = static_cast <double> (theOptVar->mainObjCoeffVal ());
@


1.24
log
@Continued implementation of opt with COIN.
@
text
@d392 3
d402 2
d405 4
d410 2
a411 1
   myClpSimplex ()->primal (1);
@


1.23
log
@Continued implementation of opt with COIN.
@
text
@d164 2
a165 1
   CoinMessageHandler * theCoinMessageHandler;
d169 1
a169 1
   theCoinMessageHandler = new CoinMessageHandler (theFile);
d171 1
a171 1
   theCoinMessageHandler->setLogLevel (myOptComp ()->coinLogLevel ());
d173 2
a174 2
   myOsiSI ()     ->passInMessageHandler (theCoinMessageHandler);
   myClpSimplex ()->passInMessageHandler (theCoinMessageHandler);
d177 7
a183 1
      mySbbModel ()->passInMessageHandler (theCoinMessageHandler);
d542 2
a543 1
   CoinMessageHandler * theCoinMessageHandler;
d545 1
a545 1
   theCoinMessageHandler = myOsiSI ()->messageHandler ();
d549 2
d554 4
d566 1
a566 1
   shutDownMH (theCoinMessageHandler);
d571 1
a571 1
void WitCoinSolver::shutDownMH (CoinMessageHandler * theCoinMessageHandler)
d576 3
a578 1
   theFile = theCoinMessageHandler->filePointer ();
d580 1
a580 1
   delete theCoinMessageHandler;
@


1.22
log
@Continued implementation of opt with COIN.
@
text
@d591 1
a591 1
         dynamic_cast <OsiClpSolverInterface *> (mySbbModel ()->solver ());
a592 2
      stronglyAssert (theOsiClpSI != NULL);
      
@


1.21
log
@Continued implementation of Opt with COIN.
rjw
@
text
@d55 11
d69 3
a71 5
      WitOptSolver   (theOptModel),
      ownedOsiClpSI_ (NULL),
      mySbbModel_    (NULL),
      myOsiClpSI_    (NULL),
      myClpSimplex_  (NULL)
d105 1
a105 1
      if (myOptModel ()->isaMIP ())
d122 1
a122 1
   if (myOptModel ()->isaMIP ())
d143 1
a143 1
   if (myOptModel ()->isaMIP ())
a150 5
      myOsiClpSI_ =
         dynamic_cast <OsiClpSolverInterface *> (mySbbModel ()->solver ());

      stronglyAssert (myOsiClpSI_ != NULL);

d154 1
a154 7
      {
      ownedOsiClpSI_ = new OsiClpSolverInterface;

      myOsiClpSI_    = ownedOsiClpSI_;
      }

   myClpSimplex_ = myOsiClpSI_->getModelPtr ();
d172 2
a173 2
   myOsiClpSI_  ->passInMessageHandler (theCoinMessageHandler);
   myClpSimplex_->passInMessageHandler (theCoinMessageHandler);
d175 1
a175 1
   if (myOptModel ()->isaMIP ())
d193 1
a193 1
   myOsiClpSI_->loadProblem (
d205 1
a205 1
   myOsiClpSI_->setObjSense (-1.0);
d207 1
a207 1
   if (myOptModel ()->isaMIP ())
d219 1
a219 1
         myOsiClpSI_->setInteger (theOptVar->index ());
d267 1
a267 1
   myOsiClpSI_->setRowSetBounds (
d309 1
a309 1
   myOsiClpSI_->setColSetBounds (
d343 1
a343 1
   myOsiClpSI_->setObjCoeffSet (
d357 1
a357 1
      myOsiClpSI_->writeMps ("model", "mps");
d365 1
a365 1
   stronglyAssert (myOptModel ()->isaMIP ());
d381 1
a381 1
   presolvedCS = thePresolve.presolvedModel (* myClpSimplex_, 1.0e-8);
d394 1
a394 1
   myClpSimplex_->primal (1);
d418 1
a418 1
   myOsiClpSI_->setColSolution (initSoln.myCvector ());
d429 1
a429 1
   myClpSimplex_->checkSolution ();
d431 2
a432 2
   totPrimalInf = myClpSimplex_->sumPrimalInfeasibilities ();
   totDualInf   = myClpSimplex_->sumDualInfeasibilities ();
d441 1
a441 1
         myClpSimplex_->numberPrimalInfeasibilities (),
d443 1
a443 1
         myClpSimplex_->numberDualInfeasibilities (),
d457 1
a457 1
      myClpSimplex_->dual (0);
d464 1
a464 1
      myClpSimplex_->primal (0);
d474 1
a474 1
   if (myOsiClpSI_->isProvenOptimal ())
d477 1
a477 1
   if (myOsiClpSI_->isProvenPrimalInfeasible ())
d480 1
a480 1
   if (myOsiClpSI_->isProvenDualInfeasible ())
d485 1
a485 1
   if (myOsiClpSI_->isProvenPrimalInfeasible ())
d488 1
a488 1
   if (myOsiClpSI_->isProvenDualInfeasible ())
d491 1
a491 1
   if (myOsiClpSI_->isAbandoned ())
d504 1
a504 1
   primalSoln = myOsiClpSI_->getColSolution ();
d521 1
a521 1
   dualSoln = myOsiClpSI_->getRowPrice ();
d537 1
a537 5
   theCoinMessageHandler = myOsiClpSI_->messageHandler ();

   myClpSimplex_ = NULL;
   myOsiClpSI_   = NULL;
   myOsiClpSI_   = NULL;
d539 1
a539 1
   if (myOptModel ()->isaMIP ())
d547 1
a547 1
      delete ownedOsiClpSI_;
d549 1
a549 1
      ownedOsiClpSI_ = NULL;
d574 29
d615 3
a617 5
      WitOptSolver   (theOptModel),
      ownedOsiClpSI_ (NULL),
      mySbbModel_    (NULL),
      myOsiClpSI_    (NULL),
      myClpSimplex_  (NULL)
@


1.20
log
@Continued implementation of opt with COIN.
@
text
@d52 1
d58 5
a62 3
      WitOptSolver  (theOptModel),
      myOsiClpSI_   (NULL),
      myClpSimplex_ (NULL)
a91 2
   stronglyAssert (not myOptModel ()->isaMIP ());

d96 4
a99 1
      myMsgFac () ("solveLpMsg", "COIN");
d113 7
a119 1
   if (not myOptImploder ()->accelerated ())
a120 2
   else
      solveLpAcc ();
d134 18
a151 2
   FILE *               theFile;
   CoinMessageHandler * theCoinMessageHandler;
d153 2
a154 1
   myOsiClpSI_   = new OsiClpSolverInterface;
d158 10
d176 3
d208 14
d365 11
a537 2
   FILE *               theFile;
   int                  fcloseRes;
d539 18
a556 1
   myClpSimplex_         = NULL;
d558 2
a559 1
   theCoinMessageHandler = myOsiClpSI_->messageHandler ();
d561 1
a561 1
   delete myOsiClpSI_;
d563 4
a566 1
   myOsiClpSI_           = NULL;
d568 1
a568 1
   theFile               = theCoinMessageHandler->filePointer ();
d592 5
a596 3
      WitOptSolver  (theOptModel),
      myOsiClpSI_   (NULL),
      myClpSimplex_ (NULL)
@


1.19
log
@Continued implementation of opt with COIN.
@
text
@d133 1
a133 1
   theFile = openFile (myOptComp ()->coinLogFileName ().myCstring (), "w");
d364 4
d370 4
a373 1
   if (myOptComp ()->coinLogLevel () >= 4)
d376 4
a379 4
         "# Primal Infeasibilties: %d\n"
         "Tot Primal Infeasibilty: %g\n"
         "# Dual Infeasibilties:   %d\n"
         "Tot Dual Infeasibilty:   %g\n",
d381 1
a381 1
         myClpSimplex_->sumPrimalInfeasibilities (),
d383 7
a389 1
         myClpSimplex_->sumDualInfeasibilities ());
d391 1
a391 1
   if (myClpSimplex_->dualFeasible ())
d393 1
a393 1
      if (myOptComp ()->coinLogLevel () >= 4)
d400 1
a400 1
      if (myOptComp ()->coinLogLevel () >= 4)
d493 1
a493 1
      myMsgFac () ("fcloseError", myOptComp ()->coinLogFileName ());
@


1.18
log
@Fixed a bug when building WIT in non-COIN mode.
@
text
@d364 28
a391 1
   myClpSimplex_->primal (0);
@


1.17
log
@Continued implementation of opt with COIN.
@
text
@d33 2
a34 2
// If COIN_BUILD == 1, the main implementation of class CoinSolver is to
// be compiled. The main implementations make calls to COIN functions.
d36 3
a38 2
// If COIN_BUILD == 0, the dummy implementation of class CoinSolver is to
// be compiled. The dummy implementations do not make calls to COIN functions.
d40 2
a41 6
// For now, until we are ready to link WIT to the COIN code an all platforms
// that WIT supports, the CVS repository version of WIT should always have
// COIN_BUILD == 0.
//
// The default value of COIN_BUILD is 0; it can be set to 1 from the makefile,
// by using the compile option -DCOIN_BUILD=1.
a43 6
#ifndef COIN_BUILD

#define COIN_BUILD 0

#endif

d48 1
a48 1
#if COIN_BUILD
d458 1
a458 1
#endif // COIN_BUILD
d464 1
a464 1
#if ! COIN_BUILD
d491 1
a491 1
#endif // Not COIN_BUILD
@


1.16
log
@Continued implementation of opt with COIN.
@
text
@d146 1
a146 1
   theCoinMessageHandler->setLogLevel (2);
a372 2
   myClpSimplex_->messageHandler ()->setLogLevel (4);

@


1.15
log
@Continued implementation of opt with COIN.
@
text
@d142 1
a142 1
   theFile = openFile (myOptComp ()->coinMesgFileName ().myCstring (), "w");
d464 1
a464 1
      myMsgFac () ("fcloseError", myOptComp ()->coinMesgFileName ());
@


1.14
log
@Continued implementation of opt with COIN.
@
text
@d78 1
a78 1
   shutDownClpOsi ();
d89 1
a89 1
   stronglyAssert (not myOptImploder ()->accelerated ());
d91 7
d100 5
a104 1
   myMsgFac () ("solveLpMsg", "COIN");
d106 1
a106 1
   setUpClpOsi ();
d108 2
a109 1
   passFixedModel ();
a115 3
      {
      WitTimer::leaveSection ("coin");

a116 1
      }
d118 4
a121 1
   solveLpUnAcc ();
a128 2

   WitTimer::leaveSection ("coin");
d133 1
a133 1
void WitCoinSolver::setUpClpOsi ()
d138 4
d148 1
a148 4
   myOsiClpSI_   = new OsiClpSolverInterface;

   myClpSimplex_ = myOsiClpSI_->getModelPtr ();

d371 11
d443 1
a443 1
void WitCoinSolver::shutDownClpOsi ()
d449 1
a449 3
   theCoinMessageHandler = myClpSimplex_->messageHandler ();

   theFile               = theCoinMessageHandler->filePointer ();
d451 1
a451 1
   myClpSimplex_         = NULL;
d456 2
@


1.13
log
@Continued implementation of opt with COIN.
@
text
@d29 1
a29 1
// USE_COIN
d33 1
a33 1
// If USE_COIN == 1, the main implementation of class CoinSolver is to
d36 1
a36 1
// If USE_COIN == 0, the dummy implementation of class CoinSolver is to
d41 1
a41 1
// USE_COIN == 0.
d43 2
a44 2
// The default value of USE_COIN is 0; it can be set to 1 from the makefile, by
// using the compile option -DUSE_COIN=1.
d47 1
a47 1
#ifndef USE_COIN
d49 1
a49 1
#define USE_COIN 0
d57 1
a57 1
#if USE_COIN
d66 3
a68 2
      WitOptSolver (theOptModel),
      myOsiClpSI_  (NULL)
d135 1
a135 1
   myOsiClpSI_ = new OsiClpSolverInterface;
d137 3
a139 1
   myClpSimplex ()->passInMessageHandler (theCoinMessageHandler);
d319 1
a319 1
   presolvedCS = thePresolve.presolvedModel (* myClpSimplex (), 1.0e-8);
d332 1
a332 1
   myClpSimplex ()->primal (1);
d428 1
a428 1
   theCoinMessageHandler = myClpSimplex ()->messageHandler ();
d432 2
d436 2
d448 1
a448 10
ClpSimplex * WitCoinSolver::myClpSimplex ()
   {
   witAssert (myOsiClpSI_ != NULL);

   return myOsiClpSI_->getModelPtr ();
   }

//------------------------------------------------------------------------------

#endif // USE_COIN
d454 1
a454 1
#if ! USE_COIN
d460 3
a462 2
      WitOptSolver (theOptModel),
      myOsiClpSI_  (NULL)
d481 1
a481 1
#endif // Not USE_COIN
@


1.12
log
@Changed name of CoinSolver to CoinLink.
@
text
@d13 1
a13 3
// The purpose of this file is to allow the Makefiles to create the
// "extra_prelinked_lib_object" CoinSolver, which links the COIN libraries into
// WIT.
d15 472
@


1.11
log
@Continued implementation of opt with COIN.
@
text
@@


1.10
log
@Continued implementation of opt with COIN.
@
text
@d13 3
a15 2
// Contains (by inclusion) the implementation of all functions that invoke COIN
// functions.
a16 27

#define USE_COIN 0

//------------------------------------------------------------------------------
// USE_COIN
//
// Determines which implementation of the COIN-client classes is to be compiled.
// The COIN-client classes are:
//
//    OsiSolver
//    OslOsiSolver
//    ClpSolver
//
// If USE_COIN == 1, the main implementations of the COIN-client classes are to
// be compiled. The main implementations make calls to COIN functions.
//
// If USE_COIN == 0, the dummy implementations of the COIN-client classes are to
// be compiled. The dummy implementations do not make calls to COIN functions.
//
// For now, until we are ready to link WIT to the COIN code an all platforms
// that WIT supports, the CVS repository version of WIT should always have
// USE_COIN == 0.
//------------------------------------------------------------------------------

#include <OsiSolverI.h>
#include <ClpSolverI.h>
#include <OslOsiSolverI.h>
@


1.9
log
@Continued implementation of opt with COIN.
@
text
@d22 2
a23 3
// If USE_COIN == 1, the main implementation of classes ClpSolver and
// OsiOslSolver will be compiled. The main implementations make calls to COIN
// functions.
d25 9
a33 3
// If USE_COIN == 0, the dummy implementation of classes ClpSolver and
// OsiOslSolver will be compiled. The main implementations do not make calls to
// COIN functions.
d40 1
a40 1
#include <OsiOslSolverI.h>
d42 1
@


1.8
log
@Continued implementation of opt with COIN.
@
text
@d17 18
d36 1
@


1.7
log
@Continued implementation of opt with COIN.
@
text
@d13 2
a14 1
// Contains the main implementation of class CoinSolver.
d17 1
a17 694
#include <CoinSolver.h>
#include <OptComp.h>
#include <OptModel.h>
#include <OptVar.h>
#include <OptCon.h>
#include <OptImp.h>
#include <OptStarter.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <Timing.h>

//------------------------------------------------------------------------------
// Main implementation of class CoinSolver.
//
// See OptModel.C for the dummy implementation.
//------------------------------------------------------------------------------

#ifdef OPT_IMPLODE

#if USE_COIN

#include <coin/OsiOslSolverInterface.hpp>

#define INVALID_RET_VAL -444555

//------------------------------------------------------------------------------

WitCoinSolver::WitCoinSolver (WitOptModel * theOptModel):

      WitOptSolver      (theOptModel),

      mySolverInter_    (NULL),
      retVal_           (INVALID_RET_VAL),
      presolveFileName_ ()
   {
   }

//------------------------------------------------------------------------------

WitCoinSolver::~WitCoinSolver ()
   {
   WitTimer::enterSection ("osl");

   deleteSolverInter ();

   WitTimer::leaveSection ("osl");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solve ()
   {
   WitTimer::enterSection ("osl");

   if (myOptImploder ()->accelerated ())
      myMsgFac () ("reSolveLpMsg", "OSI/OSL");
   else
      {
      if (myOptModel ()->isaMIP ())
         myMsgFac () ("solveMipMsg", "OSI/OSL");
      else
         myMsgFac () ("solveLpMsg", "OSI/OSL");

      createSolverInter ();

      passFixedModel ();
      }

   passFlexibleModel ();

   if (myOptImploder ()->printMps ())
      {
      myMsgFac () ("mpsFileMsg");

      mySolverInter_->writeMps ("model", "mps");
      }

   if (myOptImploder ()->stopOpt () == 2)
      {
      WitTimer::leaveSection ("osl");

      return;
      }

   if (myOptModel ()->isaMIP ())
      solveMIP ();
   else if (myOptImploder ()->accelerated ())
      solveLpAcc ();
   else
      solveLpUnAcc ();

   myMsgFac () ("optSolnFoundMsg");

   storePrimalSoln ();

   if (myOptModel ()->needDual ())
      storeDualSoln ();

   if (myOptImploder ()->printMask () > 0)
      printSoln ();

   WitTimer::leaveSection ("osl");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::createSolverInter ()
   {
   mySolverInter_ = new OsiOslSolverInterface;

   retVal_ =
      ekk_setLogfileName (
         myOslModel (), 
         myOptImploder ()->myOptComp ()->oslMesgFileName ().myCstring ());

   checkRetVal ("ekk_setLogfileName");

   retVal_ = ekk_mset (myOslModel (), 1, 256, 0, 0, 9999, 0);
      
   checkRetVal ("ekk_mset");

   retVal_ = ekk_setIlinelen (myOslModel (), 90);
   
   checkRetVal ("ekk_setIlinelen");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::deleteSolverInter ()
   {
   if (mySolverInter_ == NULL)
      return;

   delete mySolverInter_;

   mySolverInter_ = NULL;
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passFixedModel ()
   {
   WitVector <int>    indexRow;
   WitVector <int>    startOfEachColumn;
   WitVector <double> elements;

   myOptModel ()->defMatrixByCols (indexRow, startOfEachColumn, elements);

   mySolverInter_->loadProblem (
      myOptModel ()->nOptVars (),
      myOptModel ()->nOptCons (),
      startOfEachColumn.myCvector (),
      indexRow.myCvector (),
      elements.myCvector (),
      NULL,
      NULL,
      NULL,
      NULL,
      NULL);
      
   mySolverInter_->setObjSense (-1.0);

   retVal_ = ekk_setImaxfactor (myOslModel (), 500);

   checkRetVal ("ekk_setImaxfactor");

   if (myOptModel ()->isaMIP ())
      markIntVars ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::markIntVars ()
   {
   WitOptVar *     theOptVar;
   int             nIntVars;
   WitVector <int> theIndices;
   int             theIdx;

   nIntVars = 0;

   forEachEl (theOptVar, myOptModel ()->myOptVars ())
      if (theOptVar->isAnIntVar ())
         nIntVars ++;

   theIndices.resize (nIntVars, -1);

   theIdx = -1;

   forEachEl (theOptVar, myOptModel ()->myOptVars ())
      if (theOptVar->isAnIntVar ())
         {
         theIdx ++;

         theIndices[theIdx] = theOptVar->index ();
         }

   mySolverInter_->setInteger (theIndices.myCvector (), theIndices.length ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passFlexibleModel ()
   {
   passConBounds ();
   passVarBounds ();
   passObjCoeffs ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passConBounds ()
   {
   int                nCons;
   WitVector <int>    indexVec;
   WitVector <double> boundVec;
   WitOptCon *        theOptCon;
   int                conIdx;
   int                bndIdx;

   WitTimer::enterSection ("model");

   nCons = myOptModel ()->nOptCons ();

   indexVec.resize (nCons + 1);
   boundVec.resize (nCons * 2);

   bndIdx = 0;

   forEachEl (theOptCon, myOptModel ()->myOptCons ())
      {
      conIdx = theOptCon->index ();

      witAssert (bndIdx == conIdx * 2);

      indexVec[conIdx]     = conIdx;

      boundVec[bndIdx]     = theOptCon->bounds ().lower ();
      boundVec[bndIdx + 1] = theOptCon->bounds ().upper ();

      bndIdx += 2;
      }

   WitTimer::leaveSection ("model");

   mySolverInter_->setRowSetBounds (
      indexVec.myCvector (),
      indexVec.myCvector () + nCons,
      boundVec.myCvector ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passVarBounds ()
   {
   int                nVars;
   WitVector <int>    indexVec;
   WitVector <double> boundVec;
   WitOptVar *        theOptVar;
   int                varIdx;
   int                bndIdx;

   WitTimer::enterSection ("model");

   nVars = myOptModel ()->nOptVars ();

   indexVec.resize (nVars + 1);
   boundVec.resize (nVars * 2);

   bndIdx = 0;

   forEachEl (theOptVar, myOptModel ()->myOptVars ())
      {
      varIdx = theOptVar->index ();

      witAssert (bndIdx == varIdx * 2);

      indexVec[varIdx]     = varIdx;

      boundVec[bndIdx]     = theOptVar->bounds ().lower ();
      boundVec[bndIdx + 1] = theOptVar->bounds ().upper ();

      bndIdx += 2;
      }

   WitTimer::leaveSection ("model");

   mySolverInter_->setColSetBounds (
      indexVec.myCvector (),
      indexVec.myCvector () + nVars,
      boundVec.myCvector ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passObjCoeffs ()
   {
   int                nVars;
   WitVector <int>    indexVec;
   WitVector <double> objVec;
   WitOptVar *        theOptVar;
   int                theIdx;

   WitTimer::enterSection ("model");

   nVars = myOptModel ()->nOptVars ();

   indexVec.resize (nVars + 1);
   objVec  .resize (nVars);

   forEachEl (theOptVar, myOptModel ()->myOptVars ())
      {
      theIdx           = theOptVar->index ();

      indexVec[theIdx] = theIdx;

      objVec  [theIdx] = static_cast <double> (theOptVar->mainObjCoeffVal ());
      }

   WitTimer::leaveSection ("model");

   mySolverInter_->setObjCoeffSet (
      indexVec.myCvector (),
      indexVec.myCvector () + nVars,
      objVec.myCvector ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solveMIP ()
   {
   solveLpUnAcc ();

   retVal_ = ekk_messagePrintOff (myOslModel (), 105);

   checkRetVal ("ekk_messagePrintOff");

   retVal_ = ekk_messagePrintOff (myOslModel (), 114);

   checkRetVal ("ekk_messagePrintOff");

   retVal_ = ekk_branchAndBound (myOslModel (), NULL, NULL);

   checkRetVal ("ekk_branchAndBound");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solveLpUnAcc ()
   {
   passInitSoln ();

   scale ();

   preSolve ();

   crash ();

   primalSimplex ();

   postSolve ();

   primalSimplex ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solveLpAcc ()
   {
   ekk_primalSimplex (myOslModel (), 0);

   checkProbStat ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::passInitSoln ()
   {
   WitVector <double> initSoln;
   WitOptVar *        theVar;
   
   if (not myOptImploder ()->myOptComp ()->optInitMethod ()->external ())
      return;

   initSoln.resize (myOptModel ()->nOptVars (), 0.0);

   WitTimer::enterSection ("model");

   forEachEl (theVar, myOptModel ()->myOptVars ())
      initSoln[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("model");

   mySolverInter_->setColSolution (initSoln.myCvector ());
   }

//------------------------------------------------------------------------------

void WitCoinSolver::scale ()
   {
   retVal_ = ekk_scale (myOslModel ());

   checkRetVal ("ekk_scale");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::preSolve ()
   {
   char * theFileName;

   if (myOptModel ()->isaMIP ())
      retVal_ = ekk_preSolve (myOslModel (), 3, NULL);
   else
      {
      theFileName = tempFileName ("witpr");

      presolveFileName_.copyCstring (theFileName);

      portableFree (theFileName);

      retVal_ = ekk_preSolve (myOslModel (), 3, presolveFileName_.myCstring ());
      }

   if (retVal_ == 1)
      myOptModel ()->reportInfeasible ();

   checkRetVal ("ekk_preSolve");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::crash ()
   {
   if (not myOptImploder ()->myOptComp ()->crashOptStarter ()->isChosen ())
      return;

   retVal_ = ekk_crash (myOslModel (), 3);

   checkRetVal ("ekk_crash");
   }

//------------------------------------------------------------------------------
    
void WitCoinSolver::primalSimplex ()
   {
   ekk_primalSimplex (myOslModel (), 3);
      //
      // The return value is ignored; it seems to be the same as probstat.

   checkProbStat ();
   }

//------------------------------------------------------------------------------

void WitCoinSolver::postSolve ()
   {
   const char * fileName;

   fileName =
      myOptModel ()->isaMIP ()?
         NULL:
         presolveFileName_.myCstring ();

   if (myOptImploder ()->myOptComp ()->postSolveRecovery ())
      postSolveWithRec (fileName);
   else
      retVal_ = ekk_postSolve (myOslModel (), fileName);

   if (not myOptModel ()->isaMIP ())
      remove (presolveFileName_.myCstring ());

   checkRetVal ("ekk_postSolve");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::postSolveWithRec (const char * saveFile)
   {
   int i,nrow=ekk_getInumrows(myOslModel ()),
      ncol=ekk_getInumcols(myOslModel ());
   int * cstat = const_cast <int *> (ekk_colstat(myOslModel ()));
   int * rstat = const_cast <int *> (ekk_rowstat(myOslModel ()));
   double * csol = const_cast <double *> (ekk_colsol(myOslModel ()));
   double * rsol = const_cast <double *> (ekk_rowacts(myOslModel ()));
   int * cstatx=ekk_int(ncol);
   int * rstatx=ekk_int(nrow);
   double * csolx=ekk_double(ncol);
   double * rsolx=ekk_double(nrow);
   const double * rowlower = ekk_rowlower(myOslModel ());
   const double * rowupper = ekk_rowupper(myOslModel ());
   double * collower = const_cast <double *> (ekk_collower(myOslModel ()));
   double * colupper = const_cast <double *> (ekk_colupper(myOslModel ()));

   for (i=0;i<nrow;i++) {
     if(rowupper[i]-rowlower[i]>1.0e-7) {
       rstatx[i]=rstat[i];
       rsolx[i]=rsol[i];
     } else {
       rstatx[i]=-1;
       rsolx[i]=rowlower[i];
     }
   }

   for (i=0;i<ncol;i++) {
     if(colupper[i]-collower[i]>1.0e-7) {
       cstatx[i]=cstat[i];
       csolx[i]=csol[i];
     } else {
       cstatx[i]=-1;
       csolx[i]=collower[i];
     }
   }

   retVal_ = ekk_postSolve(myOslModel (),saveFile);

   if (retVal_ != 0) {
     double * cup=ekk_double(ncol);
     double * clo=ekk_double(ncol);

     if (DEVELOPMENT)
        myMsgFac () ("postSolveRecMsg");

     memcpy(cup,colupper,ncol*sizeof(double));
     memcpy(clo,collower,ncol*sizeof(double));

     for (i=0;i<ncol;i++) {
       if(colupper[i]-collower[i]>1.0e-7) {
         if (cstatx[i]!=-1) {
           csol[i]=csolx[i];
           if (colupper[i]>csol[i])
             colupper[i] = csol[i];
           if (collower[i]<csol[i])
             collower[i] = csol[i];
         }
       } else {
         csol[i]=collower[i];
       }
     }

     ekk_preSolve(myOslModel (),16,saveFile);
     ekk_setImaxiter(myOslModel (),ekk_getIiternum(myOslModel ())+1000000);
     ekk_primalSimplex(myOslModel (),3);
     retVal_=ekk_postSolve(myOslModel (),saveFile);
     memcpy(colupper,cup,ncol*sizeof(double));
     memcpy(collower,clo,ncol*sizeof(double));
     ekk_free(cup);
     ekk_free(clo);
   }

   ekk_free(csolx);
   ekk_free(cstatx);
   ekk_free(rsolx);
   ekk_free(rstatx);
   }

//------------------------------------------------------------------------------

void WitCoinSolver::storePrimalSoln ()
   {
   const double * primalSoln;
   WitOptVar *    theVar;

   primalSoln = mySolverInter_->getColSolution ();

   WitTimer::enterSection ("model");

   forEachEl (theVar, myOptModel ()->myOptVars ())
      theVar->setPrimalValue (primalSoln[theVar->index ()]);

   WitTimer::leaveSection ("model");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::storeDualSoln ()
   {
   const double * dualSoln;
   WitOptCon *    theCon;

   dualSoln = mySolverInter_->getRowPrice ();

   WitTimer::enterSection ("model");

   forEachEl (theCon, myOptModel ()->myOptCons ())
      theCon->setDualValue (- dualSoln[theCon->index ()]);

   WitTimer::leaveSection ("model");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::printSoln ()
   {
   retVal_ =
      ekk_setIprtinfomask (myOslModel (), myOptImploder ()->printMask ());

   checkRetVal ("ekk_setIprtinfomask");

   retVal_ = ekk_printSolution (myOslModel ());

   checkRetVal ("ekk_printSolution");
   }

//------------------------------------------------------------------------------

void WitCoinSolver::checkProbStat ()
   {
   int probStat;

   const WitMsgFragID statFragID [] =
      {
      "iprobstat0Frag",
      "iprobstat1Frag",
      "iprobstat2Frag",
      "iprobstat3Frag",
      "iprobstat4Frag",
      "iprobstat5Frag",
      "iprobstat6Frag",
      };

   probStat = ekk_getIprobstat (myOslModel ());

   if (probStat == 0)
      return;

   if (probStat == 1)
      myOptModel ()->reportInfeasible ();

   if (probStat == 2)
      myOptModel ()->reportUnbounded ();

   if ((probStat < 0) or (probStat >= NumberElem (statFragID)))
      myMsgFac () ("oslOptimalNotFoundFmsg",
         probStat,
         myMsgFac ().myFrag ("iprobstatRangeErrorFrag"));
   else
      myMsgFac () ("oslOptimalNotFoundFmsg",
         probStat,
         myMsgFac ().myFrag (statFragID[probStat]));
   }

//------------------------------------------------------------------------------

void WitCoinSolver::checkRetPtr (const void * thePtr, const char * funcName)
   {
   if (thePtr == NULL)
      {
      if (mySolverInter_ != NULL)
         {
         delete mySolverInter_;

         mySolverInter_ = NULL;
         }

      myMsgFac () ("oslErrorSmsg", funcName);
      }
   }

//------------------------------------------------------------------------------

void WitCoinSolver::checkRetVal (const char * funcName)
   {
   stronglyAssert (retVal_ != INVALID_RET_VAL);

   if (retVal_ != 0)
      {
      if (mySolverInter_ != NULL)
         {
         delete mySolverInter_;

         mySolverInter_ = NULL;
         }

      myMsgFac () ("oslErrorSmsg", funcName);
      }

   retVal_ = INVALID_RET_VAL;
   }

//------------------------------------------------------------------------------

EKKModel * WitCoinSolver::myOslModel ()
   {
   witAssert (mySolverInter_ != NULL);

   return mySolverInter_->getModelPtr ();
   }

//------------------------------------------------------------------------------

#endif // USE_COIN

#endif // OPT_IMPLODE
@


1.6
log
@Continued implementation of opt with COIN.
@
text
@d190 4
a193 1
   WitOptVar * theOptVar;
d195 1
a195 1
   retVal_ = ekk_messagePrintOff (myOslModel (), 317);
d197 7
a203 1
   checkRetVal ("ekk_messagePrintOff");
d208 3
a210 3
         retVal_ = ekk_markAsInteger (myOslModel (), theOptVar->index ());
         
         checkRetVal ("ekk_markAsInteger");
d213 1
a213 3
   retVal_ = ekk_messagePrintOn (myOslModel (), 317);

   checkRetVal ("ekk_messagePrintOn");
d259 2
a264 2

   WitTimer::leaveSection ("model");
d301 2
a306 2

   WitTimer::leaveSection ("model");
d335 2
a340 2

   WitTimer::leaveSection ("model");
d394 2
a395 1
   double * colsol;
d400 1
a400 1
   colsol = ekk_getColsol (myOslModel ());
d402 1
a402 1
   checkRetPtr (colsol, "ekk_getColsol");
d404 2
a405 1
   myOptModel ()->getInitSoln (colsol);
d407 1
a407 3
   retVal_ = ekk_setColsol (myOslModel (), colsol);

   checkRetVal ("ekk_setColsol");
d409 1
a409 1
   ekk_free (colsol);
@


1.5
log
@Continued implementation of opt with COIN.
@
text
@d569 1
a569 1
   const double * colsol;
d572 1
a572 3
   colsol = ekk_colsol (myOslModel ());

   checkRetPtr (colsol, "ekk_colsol");
d577 1
a577 1
      theVar->setPrimalValue (colsol[theVar->index ()]);
d586 1
a586 1
   const double * rowduals;
d589 1
a589 3
   rowduals = ekk_rowduals (myOslModel ());

   checkRetPtr (rowduals, "ekk_rowduals");
d594 1
a594 1
      theCon->setDualValue (- rowduals[theCon->index ()]);
@


1.4
log
@Continued implementation of opt with COIN.
Modified appl.mk to facilitate linking WIT to COIN.
@
text
@d57 1
a57 1
   WitTimingEvent theEvent ("osl");
d60 2
d68 1
a68 1
   WitTimingEvent theEvent ("osl");
d94 3
d98 1
d116 2
a221 1
   WitTimingEvent     theEvent ("model");
d229 2
d256 2
a263 1
   WitTimingEvent     theEvent ("model");
d271 2
d298 2
a305 1
   WitTimingEvent     theEvent ("model");
d312 2
d332 2
d570 1
d576 6
a581 1
   myOptModel ()->storePrimalSoln (colsol);
d589 1
d595 6
a600 1
   myOptModel ()->storeDualSoln (rowduals);
@


1.3
log
@Continued implementation of opt with Coin.
@
text
@d13 1
a13 1
// Contains the implementation of class CoinSolver.
a26 4
#ifdef OPT_IMPLODE

// #define USE_COIN

d28 3
a30 1
// USE_COIN Implementation of class CoinSolver.
d33 3
a35 1
#ifdef USE_COIN
d37 1
a37 1
#include <OsiOslSolverInterface.hpp>
d593 11
a603 1
   int index;
d616 8
a623 22
   index = probStat + 1;

   const WitMsgFragID statFragID [] =
      {
      "iprobstatM1Frag",
      "iprobstat0Frag",
      "iprobstat1Frag",
      "iprobstat2Frag",
      "iprobstat3Frag",
      "iprobstat4Frag",
      "iprobstat5Frag",
      "iprobstat6Frag",
      };

   if ((index < 0) or (index >= NumberElem (statFragID)))
      index = 0;
         //
         // Ensure index is in range.

   myMsgFac () ("oslOptimalNotFoundFmsg",
      probStat,
      myMsgFac ().myFrag (statFragID[index]));
a675 35

//------------------------------------------------------------------------------
// Non-USE_COIN Implementation of class CoinSolver.
//------------------------------------------------------------------------------

#ifndef USE_COIN

//------------------------------------------------------------------------------

WitCoinSolver::WitCoinSolver (WitOptModel * theOptModel):

      WitOptSolver      (theOptModel),

      mySolverInter_    (NULL),
      retVal_           (0),
      presolveFileName_ ()
   {
   myMsgFac () ("coinNYAvailSmsg");
   }

//------------------------------------------------------------------------------

WitCoinSolver::~WitCoinSolver ()
   {
   }

//------------------------------------------------------------------------------

void WitCoinSolver::solve ()
   {
   }

//------------------------------------------------------------------------------

#endif // Not USE_COIN
@


1.2
log
@Continued implementation of opt with COIN.
@
text
@d17 7
d25 522
d550 136
a685 1
#ifdef OPT_IMPLODE
d691 5
a695 1
      WitOptSolver (theOptModel)
d697 1
a697 1
   myMsgFac () ("coinNyiSmsg");
d714 3
a716 1
#endif
@


1.1
log
@Continued implementation of opt with COIN.
@
text
@d12 2
d15 32
@


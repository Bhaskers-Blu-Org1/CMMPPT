head	1.62;
access;
symbols
	sce_4_05_20040511:1.61
	sce_4_00_20040201:1.50;
locks; strict;
comment	@ * @;


1.62
date	2005.01.28.19.34.26;	author rjw;	state dead;
branches;
next	1.61;

1.61
date	2004.05.07.22.15.15;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.05.21.16.50;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.05.05.15.26.31;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.04.19.23.02.18;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.04.19.22.16.28;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.04.19.53.27;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.03.19.07.28;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.02.23.52.14;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.19.21.15.43;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.29.19.13.43;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.29.16.25.32;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.24.23.25.56;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.24.21.09.47;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.23.22.24.31;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.23.17.56.20;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.23.16.18.47;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.19.19.01.02;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.17.22.29.59;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.17.16.53.52;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.15.23.22.32;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.15.19.35.59;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.12.21.20.15;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.12.19.49.44;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.11.21.56.33;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.10.23.20.42;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.05.19.34.01;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.04.22.44.56;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.04.21.30.09;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.04.16.20.41;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.11.18.29.14;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.29.17.03.58;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.29.16.29.38;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.29.00.15.50;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.28.19.45.34;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.27.23.40.13;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.27.22.16.01;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.24.15.37.46;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.23.19.33.12;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.22.22.30.10;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.22.22.11.15;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.22.20.37.29;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.21.20.45.42;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.21.19.28.45;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.16.22.29.39;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.16.18.13.05;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.16.16.18.03;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.15.21.29.24;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.15.21.12.12;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.14.21.19.17;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.14.18.25.09;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.14.14.51.37;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.13.22.37.13;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.13.22.28.26;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.13.21.36.17;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.10.22.35.38;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.10.20.55.47;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.10.18.20.02;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.09.21.31.51;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Tie Breaking Prop-Rt.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "PipBuilder.C"
//
// Contains the implementation of class Pip::Builder.
//------------------------------------------------------------------------------

#include <PipBuilder.h>
#include <PipSeqMgr.h>
#include <PipPegMgr.h>
#include <PipTarg.h>
#include <PipPegList.h>
#include <ReqSched.h>
#include <Demand.h>
#include <Material.h>
#include <Capacity.h>
#include <Opn.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Global.h>
#include <Dense.h>
#include <MsgFac.h>
#include <MapIdxI.h>

//------------------------------------------------------------------------------
// Implementation of class Pip::Builder.
//------------------------------------------------------------------------------

WitPip::Builder::Builder (PegMgr * thePegMgr):

      WitProbAssoc    (thePegMgr->myProblem ()),

      myPegMgr_       (thePegMgr),
      curTarg_        (NULL),
      expExecPers_    (myProblem ()),
      normShare_      (),

      unpgdExecVol_   (myProblem (), 0.0),
      unpgdNonSubVol_ (myProblem (), 0.0),
      unpgdSubVol_    (myProblem (), 0.0),
      unpgdStockVol_  (myProblem (), 0.0),
      unpgdSupplyVol_ (myProblem (), 0.0),
      unpgdSideVol_   (myProblem (), 0.0),

      maxInfeas_      (0.0),
      maxInfeasTarg_  (NULL),
      maxInfeasPart_  (NULL),
      maxInfeasPer_   (-1)
   {              
   myReqSched_ = new WitReqSched (myProblem ());

   workOpnSched_ .allocate1D (myProblem ());
   workSubSched_ .allocate1D (myProblem ());
   workPartSched_.allocate1D (myProblem ());
   }

//------------------------------------------------------------------------------

WitPip::Builder::~Builder ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (expPer, myProblem ())
         delete expExecPers_.myPtrAt (theBopEnt, expPer);

   delete myReqSched_;
   }

//------------------------------------------------------------------------------

void WitPip::Builder::buildPegging ()
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   initUnpeggedScheds ();

   findExecPers ();

   myPegMgr_->mySeqMgr ()->get (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      curTarg_ = myPegMgr_->myTargFor (theDemand, shipPer);

      pegShipment (incShipVol);

      consolidatePegLists ();
      }

   curTarg_ = NULL;

   prtInfeas ();
   }

//------------------------------------------------------------------------------

void WitPip::Builder::initUnpeggedScheds ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitMaterial * theMat;
   WitPart *     thePart;

   normShare_.allocate (myProblem (), 0.0);

   normalizeShares ();

   forEachBopEntry (theBopEnt, myProblem ())
      {
      unpgdExecVol_ (theBopEnt) = 0.0;

      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->execPerOKForExp (execPer))
               unpgdExecVol_ (theBopEnt)[execPer] =
                    normShare_ (theBopEnt)[execPer]
                  * theBopEnt->myOperation ()->execVol ()[execPer];
      }

   forEachBomEntry (theBomEnt, myProblem ())
      unpgdNonSubVol_ (theBomEnt) = theBomEnt->nonSubVol ();

   forEachSubEntry (theSub, myProblem ())
      unpgdSubVol_ (theSub) = theSub->subVol ();

   forEachMaterial (theMat, myProblem ())
      unpgdStockVol_ (theMat) = theMat->stockVol ();

   forEachPart (thePart, myProblem ())
      unpgdSupplyVol_ (thePart) = thePart->supplyVol ();

   compSideVols ();

   normShare_.clear ();
   }

//------------------------------------------------------------------------------

void WitPip::Builder::normalizeShares ()
   {
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;
   WitPeriod      execPer;
   double         totShare;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         totShare = 0.0;

         forEachEl (theBopEnt, theOpn->bop ())
            if (theBopEnt->expAllowed ())
               if (theBopEnt->execPerOKForExp (execPer))
                  totShare += theBopEnt->pipShare ()[execPer];

         if (totShare == 0.0)
            continue;

         forEachEl (theBopEnt, theOpn->bop ())
            if (theBopEnt->expAllowed ())
               if (theBopEnt->execPerOKForExp (execPer))
                  normShare_ (theBopEnt)[execPer] =
                     theBopEnt->pipShare ()[execPer] / totShare;
         }

   if (myGlobalComp ()->selPrintLevel () >= 3)
      prtNormShares ();
   }

//------------------------------------------------------------------------------

void WitPip::Builder::prtNormShares ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   fprintf (msgFile (),
      "\n"
      "Normalized PIP Shares:\n"
      "\n"
      "   Opn  BopEnt  Part  ExecPer  Share\n");

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         fprintf (msgFile (),
            "   %3s  %6d  %4s  %7d  %5.3f\n",
            theBopEnt->myOperationName ().myCstring (),
            theBopEnt->localIndex (),
            theBopEnt->myPartName ().myCstring (),
            execPer,
            normShare_ (theBopEnt)[execPer]);
   }

//------------------------------------------------------------------------------

void WitPip::Builder::compSideVols ()
   {
   compBopSideVols ();
   compBomSideVols ();

   if (myGlobalComp ()->selPrintLevel () >= 3)
      prtSideVols ();
   }

//------------------------------------------------------------------------------

void WitPip::Builder::compBopSideVols ()
   {
   WitBopEntry * theBopEnt;
   WitPart *     thePart;
   WitPeriod     execPer;
   double        execVolVal;
   double        normShareVal;
   double        effProd;
   WitPeriod     prodPer;

   forEachBopEntry (theBopEnt, myProblem ())
      {
      thePart = theBopEnt->myPart ();

      forEachPeriod (execPer, myProblem ())
         {
         if (not theBopEnt->inEffect (execPer))
            continue;

         execVolVal = theBopEnt->myOperation ()->execVol ()[execPer];

         if (execVolVal <= 0.0)
            continue;

         normShareVal = normShare_ (theBopEnt)[execPer];

         if (normShareVal == 1.0)
            continue;

         effProd = theBopEnt->effProdRate ()[execPer];

         prodPer = theBopEnt->impactPeriod ()[execPer];

         unpgdSideVol_ (thePart)[prodPer] +=
            (1.0 - normShareVal) * execVolVal * effProd;
         }
      }
   }

//------------------------------------------------------------------------------

void WitPip::Builder::compBomSideVols ()
   {
   WitBomEntry * theBomEnt;
   WitPeriod     execPer;
   double        effConsRateVal;
   double        execVolVal;
   WitPart *     thePart;
   WitPeriod     consPer;
   double        incConsVol;

   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         if (not theBomEnt->inEffect (execPer))
            continue;

         effConsRateVal = theBomEnt->effConsRate ()[execPer];

         if (effConsRateVal >= 0.0)
            continue;

         execVolVal = theBomEnt->myOperation ()->execVol ()[execPer];

         if (execVolVal <= 0.0)
            continue;

         thePart    = theBomEnt->myPart ();

         consPer    = theBomEnt->impactPeriod ()[execPer];

         incConsVol = execVolVal * effConsRateVal;

         unpgdSideVol_ (thePart)[consPer] -= incConsVol;
         }
   }

//------------------------------------------------------------------------------

void WitPip::Builder::prtSideVols ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    sideVolVal;

   stronglyAssert (myGlobalComp ()->selPrintLevel () >= 3);

   fprintf (msgFile (),
      "\n"
      "Side Effect Volumes:\n"
      "\n"
      "   Part Per SideVol\n");

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         sideVolVal = unpgdSideVol_ (thePart)[thePer];

         if (sideVolVal == 0.0)
            continue;

         fprintf (msgFile (),
            "   %4s %3d %7.2f\n",
            thePart->partName ().myCstring (),
            thePer,
            sideVolVal);
         }

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitPip::Builder::findExecPers ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   WitPeriod     expPer;
   WitTVec <int> nExecPers;

   nExecPers.allocate (myProblem (), 0);

   forEachBopEntry (theBopEnt, myProblem ())
      {
      if (not theBopEnt->expAllowed ())
         continue;

      nExecPers = 0;

      forEachPeriod (execPer, myProblem ())
         {
         if (not theBopEnt->execPerOKForExp (execPer))
            continue;

         expPer = theBopEnt->impactPeriod ()[execPer];

         nExecPers[expPer] ++;
         }

      forEachPeriod (expPer, myProblem ())
         {
         if (nExecPers[expPer] < 2)
            continue;

         expExecPers_.myPtrAt (theBopEnt, expPer) =
            new WitVector <WitPeriod> (nExecPers[expPer], -1);
         }

      nExecPers = 0;

      for (execPer = lastPeriod (); execPer >= 0; execPer --)
         {
         if (not theBopEnt->execPerOKForExp (execPer))
            continue;

         expPer = theBopEnt->impactPeriod ()[execPer];

         if (expExecPers_.myPtrAt (theBopEnt, expPer) == NULL)
            continue;

         expExecPers_.myElemAt (theBopEnt, expPer)[nExecPers[expPer]] = execPer;

         nExecPers[expPer] ++;
         }
      }
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegShipment (double incShipVol)
   {
   WitPart * topPart;
   WitPeriod shipPer;
   WitPart * thePart;
   WitPeriod pegPer;

   witAssert (incShipVol > 0.0);

   topPart = curTarg_->myDemand ()->demandedPart ();

   shipPer = curTarg_->myShipPer ();

   myReqSched_->addTo (topPart, shipPer, incShipVol);

   forEachElDense (thePart, topPart->belowList ())
      for (pegPer =  myReqSched_->lastPer  (thePart); 
           pegPer >= myReqSched_->firstPer (thePart);
           pegPer --)
         pegPart (thePart, pegPer);

   myReqSched_->clear ();
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegPart (WitPart * thePart, WitPeriod pegPer)
   {
   double netReqVol;

   netReqVol = myReqSched_->reqVol (thePart, pegPer);

   if (netReqVol <= 0.0)
      return;

   pegToSupply (thePart, pegPer, netReqVol);

   if (netReqVol <= 0.0)
      return;

   pegToProd (thePart, pegPer, netReqVol);

   if (netReqVol <= 0.0)
      return;

   pegToStock (thePart, pegPer, netReqVol);

   if (netReqVol <= 0.0)
      return;

   pegToSide (thePart, pegPer, netReqVol);

   if (netReqVol <= 0.0)
      return;

   if (netReqVol > maxInfeas_)
      {
      maxInfeas_     = netReqVol;
      maxInfeasTarg_ = curTarg_;
      maxInfeasPart_ = thePart;
      maxInfeasPer_  = pegPer;
      }
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegToStock (
      WitPart * thePart,
      WitPeriod pegPer,
      double &  netReqVol)
   {
   WitMaterial * theMat;
   double        pegVol;

   witAssert (netReqVol > 0.0);

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return;

   if (pegPer == 0)
      return;

   if (unpgdStockVol_ (theMat)[pegPer - 1] <= 0.0)
      return;

   pegVol = minAndNet (netReqVol, unpgdStockVol_ (theMat)[pegPer - 1]);

   myReqSched_->addTo (theMat, pegPer - 1, pegVol);
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegToSupply (
      WitPart * thePart,
      WitPeriod pegPer,
      double &  netReqVol)
   {
   double pegVol;

   witAssert (netReqVol > 0.0);

   if (unpgdSupplyVol_ (thePart)[pegPer] <= 0.0)
      return;

   pegVol = minAndNet (netReqVol, unpgdSupplyVol_ (thePart)[pegPer]);
   
   curTarg_->myPartPegList ()[supplyVolAtt]->append (thePart, pegPer, pegVol);
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegToSide (
      WitPart * thePart,
      WitPeriod pegPer,
      double &  netReqVol)
   {
   double pegVol;

   witAssert (netReqVol > 0.0);

   if (unpgdSideVol_ (thePart)[pegPer] <= 0.0)
      return;

   pegVol = minAndNet (netReqVol, unpgdSideVol_ (thePart)[pegPer]);
   
   curTarg_->myPartPegList ()[sideVolAtt]->append (thePart, pegPer, pegVol);
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegToProd (
      WitPart * thePart,
      WitPeriod expPer,
      double &  netReqVol)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   int           nExecPers;
   int           theIdx;

   witAssert (netReqVol > 0.0);

   if (thePart->prodVol ()[expPer] <= 0.0)
      return;

   if (not thePart->explodeable (expPer))
      return;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      {
      if (not theBopEnt->expEligible (expPer))
         continue;

      if (expExecPers_.myPtrAt (theBopEnt, expPer) == NULL)
         {
         execPer = theBopEnt->expExecPeriod ()[expPer];

         pegBopEnt (theBopEnt, execPer, netReqVol);

         if (netReqVol <= 0.0)
            return;
         }
      else
         {
         nExecPers = expExecPers_.myElemAt (theBopEnt, expPer).length ();

         for (theIdx = 0; theIdx < nExecPers; theIdx ++)
            {
            execPer = expExecPers_.myElemAt (theBopEnt, expPer)[theIdx];

            pegBopEnt (theBopEnt, execPer, netReqVol);

            if (netReqVol <= 0.0)
               return;
            }
         }
      }
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegBopEnt (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double &      netReqVol)
   {
   WitOperation * theOpn;
   double         theUpExec;
   double         theProdRate;
   double         reqExecVol;
   double         pgdExecVol;
   double         pgdProdVol;
   WitPart *      thePart;
   WitPeriod      prodPer;

   witAssert (netReqVol > 0.0);

   theUpExec   = unpgdExecVol_ (theBopEnt)[execPer];

   if (theUpExec <= 0.0)
      return;

   theOpn      = theBopEnt->myOperation ();

   theProdRate = theBopEnt->effProdRate ()[execPer];

   reqExecVol  = netReqVol / theProdRate;

   pgdExecVol  = min (reqExecVol, theUpExec);

   unpgdExecVol_ (theBopEnt)[execPer] -= pgdExecVol;

   curTarg_->execVolPegList ()->append (theOpn, execPer, pgdExecVol);

   pgdProdVol  = pgdExecVol * theProdRate;

   netReqVol  -= pgdProdVol;

   setToMax (netReqVol, 0.0);

   thePart     = theBopEnt->myPart ();

   prodPer     = theBopEnt->impactPeriod ()[execPer];

   curTarg_->myPartPegList ()[prodVolAtt]->append (
      thePart,
      prodPer,
      pgdProdVol);

   pegBomEnts (theOpn, execPer, pgdExecVol);
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegBomEnts (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         pgdExecVol)
   {
   WitBomEntry * theBomEnt;

   witAssert (pgdExecVol > 0.0);

   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->inEffect (execPer))
         {
         if (theBomEnt->hasSubsInEffect ()[execPer])
            pegBomEntWithSubs (theBomEnt, execPer, pgdExecVol);
         else
            pegConsEnt        (theBomEnt, execPer, pgdExecVol);
         }
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegBomEntWithSubs (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        pgdExecVol)
   {
   double        netExecVol;
   double        pgdNonSubVol;
   WitSubEntry * theSub;
   double        pgdSubVol;

   witAssert (pgdExecVol > 0.0);
   witAssert (theBomEnt->hasSubsInEffect ()[execPer]);

   netExecVol = pgdExecVol;

   if (unpgdNonSubVol_ (theBomEnt)[execPer] > 0.0)
      {
      pgdNonSubVol =
         minAndNet (netExecVol, unpgdNonSubVol_ (theBomEnt)[execPer]);

      pegConsEnt (theBomEnt, execPer, pgdNonSubVol);

      if (netExecVol <= 0.0)
         return;
      }

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (unpgdSubVol_ (theSub)[execPer] > 0.0)
         {
         pgdSubVol = minAndNet (netExecVol, unpgdSubVol_ (theSub)[execPer]);

         curTarg_->subVolPegList ()->append (theSub, execPer, pgdSubVol);

         pegConsEnt (theSub, execPer, pgdSubVol);

         if (netExecVol <= 0.0)
            return;
         }
   }

//------------------------------------------------------------------------------

void WitPip::Builder::pegConsEnt (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         pgdExecVol)
   {
   double    pgdConsVol;
   WitPart * consPart;
   WitPeriod consPer;

   witAssert (pgdExecVol > 0.0);

   pgdConsVol = pgdExecVol * theConsEnt->effConsRate ()[execPer];

   if (pgdConsVol <= 0.0)
      return;

   consPart   = theConsEnt->myPart ();

   consPer    = theConsEnt->impactPeriod ()[execPer];

   curTarg_->myPartPegList ()[consVolAtt]->append (
      consPart,
      consPer,
      pgdConsVol);

   myReqSched_->addTo (consPart, consPer, pgdConsVol);
   }

//------------------------------------------------------------------------------

double WitPip::Builder::minAndNet (double & val1, double & val2)
   {
   double minVal;

   if (val1 <= val2)
      {
      minVal = val1;
      val1   = 0.0;
      val2  -= minVal;
      }
   else
      {
      minVal = val2;
      val1  -= minVal;
      val2   = 0.0;
      }

   return minVal;
   }

//------------------------------------------------------------------------------

void WitPip::Builder::consolidatePegLists ()
   {
   curTarg_->execVolPegList ()              ->consolidate (workOpnSched_);
   curTarg_->subVolPegList  ()              ->consolidate (workSubSched_);
   curTarg_->myPartPegList  ()[supplyVolAtt]->consolidate (workPartSched_);
   curTarg_->myPartPegList  ()[  sideVolAtt]->consolidate (workPartSched_);
   curTarg_->myPartPegList  ()[  prodVolAtt]->consolidate (workPartSched_);
   curTarg_->myPartPegList  ()[  consVolAtt]->consolidate (workPartSched_);
   }

//------------------------------------------------------------------------------

void WitPip::Builder::prtInfeas ()
   {
   if (DEVELOPMENT)
      if (maxInfeas_ > 0.0)
         myMsgFac () ("blankMsg");

   myMsgFac () ("pipMaxInfeasMsg", maxInfeas_);

   if (maxInfeas_ > 0.0)
      myMsgFac () ("pipMaxInfDataMsg",
         maxInfeasTarg_->myDemand ()->demandName       (),
         maxInfeasTarg_->myDemand ()->demandedPartName (),
         maxInfeasTarg_->myShipPer (),
         maxInfeasPart_->partName (),
         maxInfeasPer_);
   }
@


1.61
log
@PIP.
@
text
@@


1.60
log
@PIP.
@
text
@d170 1
a170 1
                  totShare += theBopEnt->pipShare ();
d179 1
a179 1
                     theBopEnt->pipShare () / totShare;
d201 7
a207 8
         if (normShare_ (theBopEnt)[execPer] > 0.0)
            fprintf (msgFile (),
               "   %3s  %6d  %4s  %7d  %5.3f\n",
               theBopEnt->myOperationName ().myCstring (),
               theBopEnt->localIndex (),
               theBopEnt->myPartName ().myCstring (),
               execPer,
               normShare_ (theBopEnt)[execPer]);
@


1.59
log
@PIP.
@
text
@d45 1
a45 1
      multiExp_       (myProblem (), false),
d113 6
a118 7
   WitOperation * theOpn;
   int            nExpBopEnts;
   WitBopEntry *  theBopEnt;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitMaterial *  theMat;
   WitPart *      thePart;
d120 1
a120 7
   forEachOperation (theOpn, myProblem ())
      {
      nExpBopEnts = 0;

      forEachEl (theBopEnt, theOpn->bop ())
         if (theBopEnt->expAllowed ())
            nExpBopEnts ++;
d122 1
a122 2
      multiExp_ (theOpn) = (nExpBopEnts > 1);
      }
d129 5
a133 2
         if (not multiExp_ (theBopEnt->myOperation ()))
            unpgdExecVol_ (theBopEnt) = theBopEnt->myOperation ()->execVol ();
d149 60
d229 3
a232 2
   double        execVolVal;
   double        incProdVol;
d243 1
a243 1
         prodPer    = theBopEnt->impactPeriod ()[execPer];
d245 2
a246 3
         if (theBopEnt->expEligible (prodPer))
            if (not multiExp_ (theBopEnt->myOperation ()))
               continue;
d248 1
a248 1
         execVolVal = theBopEnt->myOperation ()->execVol ()[execPer];
d250 1
a250 1
         if (execVolVal <= 0.0)
d253 3
a255 1
         incProdVol = execVolVal * theBopEnt->effProdRate ()[execPer];
d257 2
a258 1
         unpgdSideVol_ (thePart)[prodPer] += incProdVol;
d348 3
@


1.58
log
@PIP.
@
text
@d45 1
d113 18
a130 5
   WitPart *     thePart;
   WitMaterial * theMat;
   WitBopEntry * theBopEnt;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
d133 3
d137 3
a139 3
         unpgdExecVol_ (theBopEnt) = theBopEnt->myOperation ()->execVol ();
      else
         unpgdExecVol_ (theBopEnt) = 0.0;
d190 2
a191 1
            continue;
@


1.57
log
@Fixed a bug in PIP that was revealed by testing double precision.
@
text
@d112 5
a116 5
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
d118 5
a122 2
   forEachOperation (theOpn, myProblem ())
      theOpn->execVol ().copyInto (unpgdExecVol_ (theOpn));
d125 1
a125 1
      theBomEnt->nonSubVol ().copyInto (unpgdNonSubVol_ (theBomEnt));
d128 1
a128 1
      theSub->subVol ().copyInto (unpgdSubVol_ (theSub));
d131 1
a131 1
      theMat->stockVol ().copyInto (unpgdStockVol_ (theMat));
d134 1
a134 1
      thePart->supplyVol ().copyInto (unpgdSupplyVol_ (thePart));
d513 1
a513 3
   theOpn      = theBopEnt->myOperation ();

   theUpExec   = unpgdExecVol_ (theOpn)[execPer];
d518 2
d526 1
a526 1
   unpgdExecVol_ (theOpn)[execPer] -= pgdExecVol;
@


1.56
log
@Double Precision.
@
text
@a399 3
   if (pegVol < NET_TOL)
      return;

@


1.55
log
@Double Precision.
@
text
@d400 3
@


1.54
log
@Double Precision.
@
text
@d119 1
a119 1
      theOpn->execVol ().convCopyInto (unpgdExecVol_ (theOpn));
d122 1
a122 1
      theBomEnt->nonSubVol ().convCopyInto (unpgdNonSubVol_ (theBomEnt));
d125 1
a125 1
      theSub->subVol ().convCopyInto (unpgdSubVol_ (theSub));
d128 1
a128 1
      theMat->stockVol ().convCopyInto (unpgdStockVol_ (theMat));
d131 1
a131 1
      thePart->supplyVol ().convCopyInto (unpgdSupplyVol_ (thePart));
@


1.53
log
@Double Precision.
@
text
@d269 1
a269 1
      nExecPers.setToScalar (0);
d290 1
a290 1
      nExecPers.setToScalar (0);
@


1.52
log
@Double Precision.
@
text
@d119 1
a119 1
      theOpn->execVol ().copyIntoTVec (unpgdExecVol_ (theOpn));
d122 1
a122 1
      theBomEnt->nonSubVol ().copyIntoTVec (unpgdNonSubVol_ (theBomEnt));
d125 1
a125 1
      theSub->subVol ().copyIntoTVec (unpgdSubVol_ (theSub));
d128 1
a128 1
      theMat->stockVol ().copyIntoDblTVec (unpgdStockVol_ (theMat));
d131 1
a131 1
      thePart->supplyVol ().copyIntoDblTVec (unpgdSupplyVol_ (thePart));
@


1.51
log
@Double Precision.
@
text
@d128 1
a128 1
      copyInto (unpgdStockVol_ (theMat), theMat->stockVol ());
@


1.50
log
@Continued implementation of PIP.
@
text
@d131 1
a131 1
      copyInto (unpgdSupplyVol_ (thePart), thePart->supplyVol ());
@


1.49
log
@Continued implementation of PIP.
@
text
@d682 7
a688 8
   if (DEVELOPMENT)
      if (maxInfeas_ > 0.0)
         myMsgFac () ("pipMaxInfDataMsg",
            maxInfeasTarg_->myDemand ()->demandName       (),
            maxInfeasTarg_->myDemand ()->demandedPartName (),
            maxInfeasTarg_->myShipPer (),
            maxInfeasPart_->partName (),
            maxInfeasPer_);
@


1.48
log
@Continued implementation of PIP.
@
text
@d17 1
a17 1
#include <PipMgr.h>
d92 1
a92 1
   myPegMgr_->mySubsysMgr ()->getShipSeq (theShipSeq);
@


1.47
log
@Continued implementation of PIP.
@
text
@d18 1
a18 1
#include <PipCoord.h>
d38 1
a38 1
WitPip::Builder::Builder (Coord * theCoord):
d40 1
a40 1
      WitProbAssoc    (theCoord->myProblem ()),
d42 1
a42 1
      myCoord_        (theCoord),
d92 1
a92 1
   myCoord_->myMgr ()->getShipSeq (theShipSeq);
d96 1
a96 1
      curTarg_ = myCoord_->myTargFor (theDemand, shipPer);
@


1.46
log
@Continued implementation of PIP.
@
text
@a30 2
#include <PerPair.h>
#include <PerPairMgr.h>
@


1.45
log
@Continued implementation of PIP.
@
text
@d96 1
a96 1
   while (popTriple (theShipSeq, theDemand, shipPer, incShipVol))
@


1.44
log
@Continued implementation of PIP.
@
text
@a89 2
   myMsgFac () ("pipMsg");

@


1.43
log
@Continued implementation of PIP.
@
text
@d98 1
a98 1
   while (pop (theShipSeq, theDemand, shipPer, incShipVol))
@


1.42
log
@Continued implementation of PIP.
@
text
@a97 3
   if (myGlobalComp ()->revPipSeq ())
      theShipSeq.reverse ();

@


1.41
log
@Continued implementation of PIP.
@
text
@a20 1
#include <PipSrcMgr.h>
d32 1
d61 4
d85 4
a88 3
   ShipSeq     theShipSeq (myProblem ());
   WitDemPer * theDemPer;
   double      incShipVol;
d101 1
a101 1
   while (theShipSeq.pop (theDemPer, incShipVol))
d103 1
a103 1
      curTarg_ = myCoord_->myTargFor (theDemPer);
d107 1
a107 1
      curTarg_->consolidatePegging ();
d665 12
@


1.40
log
@Continued implementation of PIP.
@
text
@a16 1
#include <PipInt.h>
d18 1
d40 1
a40 1
WitPip::Builder::Builder (Mgr * theMgr):
d42 1
a42 1
      WitProbAssoc    (theMgr->myProblem ()),
d44 1
a44 1
      myMgr_          (theMgr),
d91 1
a91 1
   myMgr_->myInt ()->getShipSeq (theShipSeq);
d98 1
a98 1
      curTarg_ = myMgr_->myTargFor (theDemPer);
@


1.39
log
@Continued implementation of PIP.
@
text
@d17 1
d32 1
d40 1
a40 1
WitPip::Builder::Builder (WitProblem * theProblem):
d42 3
a44 1
      WitProbAssoc    (theProblem),
d79 1
a79 1
void WitPip::Builder::buildPegging (WitPairStack <Targ, double> & theShipSeq)
d81 3
a83 1
   double incShipVol;
d91 6
a96 1
   while (theShipSeq.pop (curTarg_, incShipVol))
d98 2
d107 1
a107 14
   if (DEVELOPMENT)
      if (maxInfeas_ > 0.0)
         myMsgFac () ("blankMsg");

   myMsgFac () ("pipMaxInfeasMsg", maxInfeas_);

   if (DEVELOPMENT)
      if (maxInfeas_ > 0.0)
         myMsgFac () ("pipMaxInfDataMsg",
            maxInfeasTarg_->myDemand ()->demandName       (),
            maxInfeasTarg_->myDemand ()->demandedPartName (),
            maxInfeasTarg_->myShipPer (),
            maxInfeasPart_->partName (),
            maxInfeasPer_);
d660 20
@


1.38
log
@Continued implementation of PIP.
@
text
@a41 1
      myReqSched_     (NULL),
@


1.37
log
@Continued implementation of PIP.
@
text
@d19 1
a19 1
#include <PipPeg.h>
d422 1
a422 1
   curTarg_->myPartPegging ()[supplyVolAtt]->append (thePart, pegPer, pegVol);
d441 1
a441 1
   curTarg_->myPartPegging ()[sideVolAtt]->append (thePart, pegPer, pegVol);
d528 1
a528 1
   curTarg_->execVolPegging ()->append (theOpn, execPer, pgdExecVol);
d540 1
a540 1
   curTarg_->myPartPegging ()[prodVolAtt]->append (
d602 1
a602 1
         curTarg_->subVolPegging ()->append (theSub, execPer, pgdSubVol);
d633 1
a633 1
   curTarg_->myPartPegging ()[consVolAtt]->append (
@


1.36
log
@Continued implementation of PIP.
@
text
@d422 1
a422 1
   curTarg_->myPartPeg ()[supplyVolAtt]->append (thePart, pegPer, pegVol);
d441 1
a441 1
   curTarg_->myPartPeg ()[sideVolAtt]->append (thePart, pegPer, pegVol);
d528 1
a528 1
   curTarg_->execVolPeg ()->append (theOpn, execPer, pgdExecVol);
d540 4
a543 1
   curTarg_->myPartPeg ()[prodVolAtt]->append (thePart, prodPer, pgdProdVol);
d602 1
a602 1
         curTarg_->subVolPeg ()->append (theSub, execPer, pgdSubVol);
d633 4
a636 1
   curTarg_->myPartPeg ()[consVolAtt]->append (consPart, consPer, pgdConsVol);
@


1.35
log
@Continued implementation of PIP.
@
text
@d13 1
a13 1
// Contains the implementation of class PipBuilder.
d35 1
a35 1
// Implementation of class PipBuilder.
d38 1
a38 1
WitPIP::WitPipBuilder::WitPipBuilder (WitProblem * theProblem):
d41 1
a41 1
      curPipTarg_     (NULL),
d62 1
a62 1
WitPIP::WitPipBuilder::~WitPipBuilder ()
d76 1
a76 2
void WitPIP::WitPipBuilder::buildPegging (
      WitPairStack <WitPipTarg, double> & theShipSeq)
d86 1
a86 1
   while (theShipSeq.pop (curPipTarg_, incShipVol))
d90 1
a90 1
      curPipTarg_->consolidatePegging ();
d93 1
a93 1
   curPipTarg_ = NULL;
d113 1
a113 1
void WitPIP::WitPipBuilder::initUnpeggedScheds ()
d141 1
a141 1
void WitPIP::WitPipBuilder::compSideVols ()
d152 1
a152 1
void WitPIP::WitPipBuilder::compBopSideVols ()
d189 1
a189 1
void WitPIP::WitPipBuilder::compBomSideVols ()
d227 1
a227 1
void WitPIP::WitPipBuilder::prtSideVols ()
d261 1
a261 1
void WitPIP::WitPipBuilder::findExecPers ()
d314 1
a314 1
void WitPIP::WitPipBuilder::pegShipment (double incShipVol)
d323 1
a323 1
   topPart = curPipTarg_->myDemand ()->demandedPart ();
d325 1
a325 1
   shipPer = curPipTarg_->myShipPer ();
d340 1
a340 1
void WitPIP::WitPipBuilder::pegPart (WitPart * thePart, WitPeriod pegPer)
d372 1
a372 1
      maxInfeasTarg_ = curPipTarg_;
d380 1
a380 1
void WitPIP::WitPipBuilder::pegToStock (
d408 1
a408 1
void WitPIP::WitPipBuilder::pegToSupply (
d422 1
a422 1
   curPipTarg_->myPartPeg ()[supplyVolAtt]->append (thePart, pegPer, pegVol);
d427 1
a427 1
void WitPIP::WitPipBuilder::pegToSide (
d441 1
a441 1
   curPipTarg_->myPartPeg ()[sideVolAtt]->append (thePart, pegPer, pegVol);
d446 1
a446 1
void WitPIP::WitPipBuilder::pegToProd (
d497 1
a497 1
void WitPIP::WitPipBuilder::pegBopEnt (
d528 1
a528 1
   curPipTarg_->execVolPeg ()->append (theOpn, execPer, pgdExecVol);
d540 1
a540 1
   curPipTarg_->myPartPeg ()[prodVolAtt]->append (thePart, prodPer, pgdProdVol);
d547 1
a547 1
void WitPIP::WitPipBuilder::pegBomEnts (
d568 1
a568 1
void WitPIP::WitPipBuilder::pegBomEntWithSubs (
d599 1
a599 1
         curPipTarg_->subVolPeg ()->append (theSub, execPer, pgdSubVol);
d610 1
a610 1
void WitPIP::WitPipBuilder::pegConsEnt (
d630 1
a630 4
   curPipTarg_->myPartPeg ()[consVolAtt]->append (
      consPart,
      consPer,
      pgdConsVol);
d637 1
a637 1
double WitPIP::WitPipBuilder::minAndNet (double & val1, double & val2)
@


1.34
log
@Continued implementation of PIP.
@
text
@a33 2
using namespace WitPip;

d38 1
a38 1
WitPipBuilder::WitPipBuilder (WitProblem * theProblem):
d62 1
a62 1
WitPipBuilder::~WitPipBuilder ()
d76 1
a76 1
void WitPipBuilder::buildPegging (
d114 1
a114 1
void WitPipBuilder::initUnpeggedScheds ()
d142 1
a142 1
void WitPipBuilder::compSideVols ()
d153 1
a153 1
void WitPipBuilder::compBopSideVols ()
d190 1
a190 1
void WitPipBuilder::compBomSideVols ()
d228 1
a228 1
void WitPipBuilder::prtSideVols ()
d262 1
a262 1
void WitPipBuilder::findExecPers ()
d315 1
a315 1
void WitPipBuilder::pegShipment (double incShipVol)
d341 1
a341 1
void WitPipBuilder::pegPart (WitPart * thePart, WitPeriod pegPer)
d381 1
a381 1
void WitPipBuilder::pegToStock (
d409 1
a409 1
void WitPipBuilder::pegToSupply (
d428 1
a428 1
void WitPipBuilder::pegToSide (
d447 1
a447 1
void WitPipBuilder::pegToProd (
d498 1
a498 1
void WitPipBuilder::pegBopEnt (
d548 1
a548 1
void WitPipBuilder::pegBomEnts (
d569 1
a569 1
void WitPipBuilder::pegBomEntWithSubs (
d611 1
a611 1
void WitPipBuilder::pegConsEnt (
d641 1
a641 1
double WitPipBuilder::minAndNet (double & val1, double & val2)
@


1.33
log
@Continued implementation of PIP.
@
text
@d34 2
d425 1
a425 1
   curPipTarg_->supplyVolPeg ()->append (thePart, pegPer, pegVol);
d444 1
a444 1
   curPipTarg_->sideVolPeg ()->append (thePart, pegPer, pegVol);
d543 1
a543 1
   curPipTarg_->prodVolPeg ()->append (thePart, prodPer, pgdProdVol);
d633 4
a636 1
   curPipTarg_->consVolPeg ()->append (consPart, consPer, pgdConsVol);
d638 1
a638 1
   myReqSched_->addTo                 (consPart, consPer, pgdConsVol);
@


1.32
log
@Continued implementation of PIP.
@
text
@d50 1
a50 1
      unpgdSideVol_   (),
a143 2
   unpgdSideVol_.allocate (myProblem (), 0.0);

d158 1
a159 1
   WitPeriod     prodPer;
a163 3
      if (theBopEnt->expAllowed ())
         continue;

d171 5
a179 2

         prodPer    = theBopEnt->impactPeriod ()[execPer];
@


1.31
log
@Continued implementation of PIP.
@
text
@d137 1
a137 2
   if (myGlobalComp ()->allowSideEffs ())
      compSideVols ();
a143 2
   stronglyAssert (myGlobalComp ()->allowSideEffs ());

a163 2
   stronglyAssert (myGlobalComp ()->allowSideEffs ());

a201 2
   stronglyAssert (myGlobalComp ()->allowSideEffs ());

a235 1
   stronglyAssert (myGlobalComp ()->allowSideEffs ());
d367 1
a367 3
   if (myGlobalComp ()->allowSideEffs ())
      {
      pegToSide (thePart, pegPer, netReqVol);
d369 2
a370 3
      if (netReqVol <= 0.0)
         return;
      }
a437 2

   witAssert (myGlobalComp ()->allowSideEffs ());
@


1.30
log
@Continued implementation of PIP.
@
text
@a364 8
   if (myGlobalComp ()->allowSideEffs ())
      {
      pegToSide (thePart, pegPer, netReqVol);

      if (netReqVol <= 0.0)
         return;
      }

d375 8
d482 3
@


1.29
log
@Removed a bad function overload.
@
text
@d29 1
d50 1
d136 132
d365 8
d437 21
@


1.28
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d262 1
a262 1
   theMat = thePart->myMat ();
@


1.27
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d480 3
a482 1
   myReqSched_->addTo (consPart, consPer, pgdConsVol);
@


1.26
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d357 3
d363 1
a363 1
   theOpn    = theBopEnt->myOperation ();
d365 1
a365 1
   theUpExec = unpgdExecVol_ (theOpn)[execPer];
d378 5
a382 1
   netReqVol -= pgdExecVol * theProdRate;
d386 5
a390 1
   curPipTarg_->execVolPeg ()->append (theOpn, execPer, pgdExecVol);
@


1.25
log
@Continued implementation of Post-Implosion Pegging.
@
text
@a78 6
   WitSchedule <WitPart,      double> thePartSched (myProblem (), 0.0);
   WitSchedule <WitOperation, double> theOpnSched  (myProblem (), 0.0);
   WitSchedule <WitSubEntry,  double> theSubSched  (myProblem (), 0.0);
      //
      // Working Schedules for PipPeg::consolidate.

d89 1
a89 3
      curPipTarg_->execVolPeg   ()->consolidate (theOpnSched);
      curPipTarg_->subVolPeg    ()->consolidate (theSubSched);
      curPipTarg_->supplyVolPeg ()->consolidate (thePartSched);
@


1.24
log
@Continued implementation of Post-Implosion Pegging.
@
text
@a40 1
      maxUpReqVol_    (0.0),
d48 6
a53 1
      unpgdSupplyVol_ (myProblem (), 0.0)
d103 13
a115 1
      myMsgFac () ("maxUpReqVolMsg", maxUpReqVol_);
d249 7
a255 22
#if 0

   if (netReqVol > maxUpReqVol_)
      fprintf (msgFile (),
         "\n"
         "Increased Constraint Violation:\n"
         "   Demand:  %s\n"
         "   Part:    %s\n"
         "   ShipPer: %d\n"
         "   Part:    %s\n"
         "   Peg Per: %d\n"
         "   Viol:    %f\n\n",
         curPipTarg_->myDemand ()->demandName       ().myCstring (),
         curPipTarg_->myDemand ()->demandedPartName ().myCstring (),
         curPipTarg_->myShipPer (),
         thePart->partName ()                          .myCstring (),
         pegPer,
         netReqVol);

#endif

   setToMax (maxUpReqVol_, netReqVol);
@


1.23
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d164 1
a164 1
      forEachPeriod (execPer, myProblem ())
d218 1
a218 1
   pegToStock (thePart, pegPer, netReqVol);
d223 1
a223 1
   pegToSupply (thePart, pegPer, netReqVol);
d228 1
a228 1
   pegToProd (thePart, pegPer, netReqVol);
@


1.22
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d83 3
a85 1
   setUpPegging ();
a103 11
void WitPipBuilder::setUpPegging ()
   {
   initUnpeggedScheds ();

   reserveExcess ();

   findExecPers ();
   }

//------------------------------------------------------------------------------

a129 36
void WitPipBuilder::reserveExcess ()
   {
   WitMaterial * theMat;
   double        exStockVol;
   WitPeriod     thePer;
   double        exSupVol;

   forEachMaterial (theMat, myProblem ())
      {
      exStockVol = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         if (theMat->residualVol ()[thePer] > 0.0)
            {
            exSupVol =
               min (
                  unpgdSupplyVol_ (theMat)[thePer],
                  static_cast <double> (theMat->residualVol ()[thePer]));

            unpgdSupplyVol_ (theMat)[thePer] -= exSupVol;

            exStockVol += exSupVol;
            }

         if (theMat->mandEC ()[thePer])
            exStockVol = 0.0;

         if (exStockVol > 0.0)
            unpgdStockVol_ (theMat)[thePer] -= exStockVol;
         }
      }
   }

//------------------------------------------------------------------------------

d232 21
@


1.21
log
@Continued implementation of Post-Implosion Pegging.
@
text
@a44 2
      unpgdSupplyVol_ (myProblem (), 0.0),
      unpgdStockVol_  (myProblem (), 0.0),
d47 3
a49 1
      unpgdSubVol_    (myProblem (), 0.0)
a88 1
      curPipTarg_->supplyVolPeg ()->consolidate (thePartSched);
d91 1
a120 6
   forEachPart (thePart, myProblem ())
      copyInto (unpgdSupplyVol_ (thePart), thePart->supplyVol ());

   forEachMaterial (theMat, myProblem ())
      copyInto (unpgdStockVol_ (theMat), theMat->stockVol ());

d129 6
@


1.20
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d45 1
a45 1
      unpgdSupVol_    (myProblem (), 0.0),
d77 1
d89 3
a91 2
      curPipTarg_-> supVolPeg ()->consolidate (thePartSched);
      curPipTarg_->execVolPeg ()->consolidate (theOpnSched);
d122 1
a122 1
      copyInto (unpgdSupVol_ (thePart), thePart->supplyVol ());
d156 1
a156 1
                  unpgdSupVol_ (theMat)[thePer],
d159 1
a159 1
            unpgdSupVol_ (theMat)[thePer] -= exSupVol;
d320 1
a320 1
   if (unpgdSupVol_ (thePart)[pegPer] <= 0.0)
d323 1
a323 1
   pegVol = minAndNet (netReqVol, unpgdSupVol_ (thePart)[pegPer]);
d325 1
a325 1
   curPipTarg_->supVolPeg ()->append (thePart, pegPer, pegVol);
d468 2
@


1.19
log
@Continued implementation of Post-Implosion Pegging.
@
text
@a101 2
   checkRestrictions ();

a106 39
   }

//------------------------------------------------------------------------------

void WitPipBuilder::checkRestrictions ()
   {
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;
   WitPart *      thePart;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitPeriod      execPer;
   WitPeriod      expPer;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->bop ().nElements () > 1)
         myMsgFac () ("nyiForPIPSmsg", "multiple BOP entries for an operation");

   forEachBopEntry (theBopEnt, myProblem ())
      {
      if (not theBopEnt->expAllowed ())
         myMsgFac () ("nyiForPIPSmsg", "unexplodeable BOP entries");

      forEachPeriod (execPer, myProblem ())
         if (theBopEnt->effProdRate ()[execPer] > 0.0)
            if (not theBopEnt->execPerOKForExp (execPer))
               myMsgFac () ("nyiForPIPSmsg",
                  "BOP entries with effective production rate < expCutOff");
      }

   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theBomEnt->consRate ()[execPer] < 0.0)
            myMsgFac () ("nyiForPIPSmsg", "negative consRates");

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theSub->consRate ()[execPer] < 0.0)
            myMsgFac () ("nyiForPIPSmsg", "negative consRates");
@


1.18
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d37 1
a37 1
WitPipBuilder::WitPipBuilder (WitPipMgr * thePipMgr):
d39 1
a39 2
      WitProbAssoc    (thePipMgr->myProblem ()),
      myPipMgr_       (thePipMgr),
d355 1
a355 2
   double          pegVol;
   WitPartPipSrc * thePartPipSrc;
d364 1
a364 3
   thePartPipSrc = myPipMgr_->myPartSrcMgr ()->myPipSrcFor (thePart, pegPer);

   curPipTarg_->supVolPeg ()->append (thePartPipSrc, pegVol);
a426 1
   WitOpnPipSrc * theOpnPipSrc;
d449 1
a449 3
   theOpnPipSrc = myPipMgr_->myOpnSrcMgr ()->myPipSrcFor (theOpn, execPer);

   curPipTarg_->execVolPeg ()->append (theOpnPipSrc, pgdExecVol);
@


1.17
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d20 1
d366 1
a366 1
   thePartPipSrc = myPipMgr_->myPartPipSrcFor (thePart, pegPer);
d454 1
a454 1
   theOpnPipSrc = myPipMgr_->myOpnPipSrcFor (theOpn, execPer);
@


1.16
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d40 1
a41 2
      supVolPeg_      (NULL),
      execVolPeg_     (NULL),
d51 1
a51 3
   myReqSched_ = new WitReqSched   (myProblem ());
   supVolPeg_  = new WitPartPipPeg (myProblem ());
   execVolPeg_ = new WitOpnPipPeg  (myProblem ());
a64 2
   delete execVolPeg_;
   delete supVolPeg_;
d73 1
a73 4
   WitPipTarg * thePipTarg;
   double       incShipVol;
   WitDemand *  theDemand;
   WitPeriod    shipPer;
d75 2
a76 2
   WitSchedule <WitPart,      double> supVolMergeSched  (myProblem (), 0.0);
   WitSchedule <WitOperation, double> execVolMergeSched (myProblem (), 0.0);
d78 1
a78 1
      // Working Schedules for PipPeg::mergeWith.
d84 1
a84 1
   while (theShipSeq.pop (thePipTarg, incShipVol))
d86 1
a86 1
      theDemand = thePipTarg->myDemand ();
d88 3
a90 3
      shipPer   = thePipTarg->myShipPer ();

      pegShipment (theDemand, shipPer, incShipVol);
d92 1
a92 3
      thePipTarg->supVolPeg  ()->mergeWith (supVolPeg_,  supVolMergeSched);
      thePipTarg->execVolPeg ()->mergeWith (execVolPeg_, execVolMergeSched);
      }
d267 1
a267 4
void WitPipBuilder::pegShipment (
      WitDemand * theDemand, 
      WitPeriod   shipPer, 
      double      incShipVol)
d270 1
d276 3
a278 1
   topPart = theDemand->demandedPart ();
d367 1
a367 1
   supVolPeg_->append (thePartPipSrc, pegVol);
d455 1
a455 1
   execVolPeg_->append (theOpnPipSrc, pgdExecVol);
@


1.15
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d19 1
d41 2
a42 2
      curSupVolPeg_   (myProblem ()),
      curExecVolPeg_  (myProblem ()),
d52 3
a54 1
   myReqSched_ = new WitReqSched (myProblem ());
d68 2
d86 1
a86 3
      // Working Schedule for:
      //    PipTarg::mergeToSupVolPeg and
      //    PipTarg::mergeToExecVolPeg.
d100 2
a101 2
      thePipTarg->mergeToSupVolPeg  (curSupVolPeg_,  supVolMergeSched);
      thePipTarg->mergeToExecVolPeg (curExecVolPeg_, execVolMergeSched);
d377 1
a377 1
   curSupVolPeg_.push (thePartPipSrc, pegVol);
d465 1
a465 1
   curExecVolPeg_.push (theOpnPipSrc, pgdExecVol);
@


1.14
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d41 1
d78 2
a79 1
   WitSchedule <WitPart, double> workPegSched (myProblem (), 0.0);
d81 3
a83 1
      // Working Schedule for PipTarg::mergeIntoPegging.
d97 2
a98 1
      thePipTarg->mergeIntoPegging (curSupVolPeg_, workPegSched);
d437 1
d460 5
a464 2
   if (pgdExecVol > 0.0)
      pegBomEnts (theOpn, execPer, pgdExecVol);
@


1.13
log
@Continued implementation of post-implosion pegging.
@
text
@d40 1
a40 1
      curPegging_     (myProblem ()),
d93 1
a93 1
      thePipTarg->mergeIntoPegging (curPegging_, workPegSched);
d369 1
a369 1
   curPegging_.push (thePartPipSrc, pegVol);
@


1.12
log
@Continued implementation of post-implosion pegging.
@
text
@d357 2
a358 2
   double      pegVol;
   WitPipSrc * thePipSrc;
d367 1
a367 1
   thePipSrc = myPipMgr_->myPipSrcFor (thePart, pegPer);
d369 1
a369 1
   curPegging_.push (thePipSrc, pegVol);
@


1.11
log
@Continued implementation of post-implosion pegging.
@
text
@d193 1
a193 1
         if (theMat->residualVol ()[thePer] >= NET_TOL)
d278 1
a278 1
   witAssert (incShipVol >= NET_TOL);
d301 1
a301 1
   if (netReqVol < NET_TOL)
d306 1
a306 1
   if (netReqVol < NET_TOL)
d311 1
a311 1
   if (netReqVol < NET_TOL)
d316 1
a316 1
   if (netReqVol < NET_TOL)
d332 1
a332 1
   witAssert (netReqVol >= NET_TOL);
d342 1
a342 1
   if (unpgdStockVol_ (theMat)[pegPer - 1] < NET_TOL)
d360 1
a360 1
   witAssert (netReqVol >= NET_TOL);
d362 1
a362 1
   if (unpgdSupVol_ (thePart)[pegPer] < NET_TOL)
d384 1
a384 1
   witAssert (netReqVol >= NET_TOL);
d386 1
a386 1
   if (thePart->prodVol ()[expPer] < NET_TOL)
d400 1
a400 1
         if (netReqVol < NET_TOL)
d413 1
a413 1
            if (netReqVol < NET_TOL)
d433 1
a433 1
   witAssert (netReqVol >= NET_TOL);
d439 1
a439 1
   if (theUpExec < NET_TOL)
d454 1
a454 1
   if (pgdExecVol >= NET_TOL)
d467 1
a467 1
   witAssert (pgdExecVol >= NET_TOL);
d491 1
a491 1
   witAssert (pgdExecVol >= NET_TOL);
d496 1
a496 1
   if (unpgdNonSubVol_ (theBomEnt)[execPer] >= NET_TOL)
d503 1
a503 1
      if (netExecVol < NET_TOL)
d508 1
a508 1
      if (unpgdSubVol_ (theSub)[execPer] >= NET_TOL)
d514 1
a514 1
         if (netExecVol < NET_TOL)
d530 1
a530 1
   witAssert (pgdExecVol >= NET_TOL);
d534 1
a534 1
   if (pgdConsVol < NET_TOL)
@


1.10
log
@Continued implementation of post-implosion pegging.
@
text
@d25 1
d37 12
a48 9
      WitProbAssoc   (thePipMgr->myProblem ()),
      myPipMgr_      (thePipMgr),
      unpgdSupVol_   (myProblem (), 0.0),
      unpgdStockVol_ (myProblem (), 0.0),
      unpgdExecVol_  (myProblem (), 0.0),
      maxUpReqVol_   (0.0),
      curPegging_    (myProblem ()),
      myReqSched_    (NULL),
      expExecPers_   (myProblem ())
a103 4
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;

d106 1
a106 8
   forEachPart (thePart, myProblem ())
      copyInto (unpgdSupVol_ (thePart), thePart->supplyVol ());

   forEachMaterial (theMat, myProblem ())
      copyInto (unpgdStockVol_ (theMat), theMat->stockVol ());

   forEachOperation (theOpn, myProblem ())
      theOpn->execVol ().copyIntoTVec (unpgdExecVol_ (theOpn));
d121 1
a124 3
   if (myCompMgr ()->nSubEntries () > 0)
      myMsgFac () ("nyiForPIPSmsg", "substitutes");

d145 31
a329 1
   double        upStVol;
d342 1
a342 3
   upStVol = unpgdStockVol_ (theMat)[pegPer - 1];

   if (upStVol < NET_TOL)
d345 1
a345 1
   pegVol = min (netReqVol, upStVol);
a347 4

   unpgdStockVol_ (theMat)[pegPer - 1] -= pegVol;

   netReqVol                           -= pegVol;
a356 1
   double      upVol;
d362 1
a362 3
   upVol = unpgdSupVol_ (thePart)[pegPer];

   if (upVol < NET_TOL)
d365 1
a365 1
   pegVol = min (netReqVol, upVol);
a366 4
   unpgdSupVol_ (thePart)[pegPer] -= pegVol;

   netReqVol                      -= pegVol;

d454 2
a455 1
   pegBomEnts (theOpn, execPer, pgdExecVol);
d466 2
a467 4
   double        theConsRate;
   WitPart *     consPart;
   WitPeriod     consPer;
   double        pgdConsVol;
d470 27
d498 2
a499 2
      if (not theBomEnt->inEffect (execPer))
         continue;
d501 5
a505 1
      theConsRate = theBomEnt->effConsRate ()[execPer];
d507 4
a510 2
      if (theConsRate < NET_TOL)
         continue;
d512 1
a512 1
      consPart   = theBomEnt->myPart ();
d514 4
a517 1
      consPer    = theBomEnt->impactPeriod ()[execPer];
d519 1
a519 1
      pgdConsVol = pgdExecVol * theConsRate;
d521 34
a554 1
      myReqSched_->addTo (consPart, consPer, pgdConsVol);
d556 8
@


1.9
log
@Continued implementation of post-implosion pegging.
@
text
@d43 2
a44 1
      myReqSched_    (NULL)
d53 7
d116 2
d194 53
d373 2
d385 25
a409 9
      forEachPeriod (execPer, myProblem ())
         if (theBopEnt->execPerOKForExp (execPer))
            if (theBopEnt->impactPeriod ()[execPer] == expPer)
               {
               pegBopEnt (theBopEnt, execPer, netReqVol);

               if (netReqVol < NET_TOL)
                  return;
               }
@


1.8
log
@Continued implementation of post-implosion pegging.
@
text
@d134 4
a137 9
         {
         expPer = theBopEnt->impactPeriod ()[execPer];

         if (expPer >= 0)
            if (theBopEnt->expEligible (expPer))
               if (theBopEnt->expExecPeriod ()[expPer] != execPer)
                  myMsgFac () ("nyiForPIPSmsg",
                     "BOP entries with multiple execution periods");
         }
d320 9
a328 11
      {
      execPer = theBopEnt->expExecPeriod ()[expPer];

      if (execPer < 0)
         continue;

      pegBopEnt (theBopEnt, execPer, netReqVol);

      if (netReqVol < NET_TOL)
         return;
      }
@


1.7
log
@Continued implementation of post-implosion pegging.
@
text
@d119 1
d133 10
a142 2
      if (not (theBopEnt->offset () == 0.0))
         myMsgFac () ("nyiForPIPSmsg", "BOP entry offsets");
d314 1
d325 7
a331 3
      if (theBopEnt->expEligible (expPer))
         {
         pegBopEnt (theBopEnt, expPer, netReqVol);
d333 3
a335 3
         if (netReqVol < NET_TOL)
            return;
         }
@


1.6
log
@Continued implementation of post-implosion pegging.
@
text
@a131 3
      if (theBopEnt->expAversion () != 0.0)
         myMsgFac () ("nyiForPIPSmsg", "non-zero BOP entry expAversions");

@


1.5
log
@Continued implementation of post-implosion pegging.
@
text
@a126 4
   forEachPart (thePart, myProblem ())
      if (thePart->producingBopEntries ().nElements () > 1)
         myMsgFac () ("nyiForPIPSmsg", "multiple BOP entries for a part");

d132 3
d317 4
a320 1
   theBopEnt = thePart->expBopEntry (expPer);
d322 3
a324 1
   pegBopEnt (theBopEnt, expPer, netReqVol);
@


1.4
log
@Continued implementation of post-implosion pegging.
@
text
@d36 8
a43 8
      WitProbAssoc (thePipMgr->myProblem ()),
      myPipMgr_    (thePipMgr),
      upSupVol_    (myProblem (), 0.0),
      upStockVol_  (myProblem (), 0.0),
      upExecVol_   (myProblem (), 0.0),
      maxUpReqVol_ (0.0),
      curPegging_  (myProblem ()),
      myReqSched_  (NULL)
d99 1
a99 1
      copyInto (upSupVol_ (thePart), thePart->supplyVol ());
d102 1
a102 1
      copyInto (upStockVol_ (theMat), theMat->stockVol ());
d105 1
a105 1
      theOpn->execVol ().copyIntoTVec (upExecVol_ (theOpn));
d165 1
a165 1
                  upSupVol_ (theMat)[thePer],
d168 1
a168 1
            upSupVol_ (theMat)[thePer] -= exSupVol;
d177 1
a177 1
            upStockVol_ (theMat)[thePer] -= exStockVol;
d189 3
a191 4
   WitPart *     topPart;
   WitPart *     thePart;
   WitPeriod     thePer;
   double        netReqVol;
d200 13
a212 5
      for (thePer =  myReqSched_->lastPer  (thePart); 
           thePer >= myReqSched_->firstPer (thePart);
           thePer --)
         {
         netReqVol = myReqSched_->reqVol (thePart, thePer);
d214 1
a214 2
         if (netReqVol < NET_TOL)
            continue;
d216 2
a217 1
         pegToStock (thePart, thePer, netReqVol);
d219 1
a219 2
         if (netReqVol < NET_TOL)
            continue;
d221 2
a222 1
         pegToSupply (thePart, thePer, netReqVol);
d224 1
a224 2
         if (netReqVol < NET_TOL)
            continue;
d226 2
a227 1
         pegToProd (thePart, thePer, netReqVol);
d229 4
a232 2
         setToMax (maxUpReqVol_, netReqVol);
         }
d234 1
a234 1
   myReqSched_->clear ();
d258 1
a258 1
   upStVol = upStockVol_ (theMat)[pegPer - 1];
d267 1
a267 1
   upStockVol_ (theMat)[pegPer - 1] -= pegVol;
d269 1
a269 1
   netReqVol                        -= pegVol;
d274 1
a274 1
double WitPipBuilder::pegToSupply (
d285 1
a285 1
   upVol = upSupVol_ (thePart)[pegPer];
d288 1
a288 1
      return 0.0;
d292 1
a292 1
   upSupVol_ (thePart)[pegPer] -= pegVol;
d294 1
a294 1
   netReqVol                   -= pegVol;
a298 2

   return pegVol;
d334 1
a334 1
   double         pegExecVol;
d340 1
a340 1
   theUpExec = upExecVol_ (theOpn)[execPer];
d349 1
a349 3
   if (reqExecVol <= theUpExec)
      {
      pegExecVol = reqExecVol;
d351 1
a351 1
      upExecVol_ (theOpn)[execPer] -= reqExecVol;
d353 1
a353 5
      netReqVol  = 0.0;
      }
   else
      {
      pegExecVol = theUpExec;
d355 1
a355 4
      upExecVol_ (theOpn)[execPer] = 0.0;

      netReqVol -= theUpExec * theProdRate;
      }
d357 1
a357 1
   pegBomEnts (theOpn, execPer, pegExecVol);
d365 1
a365 1
      double         pegExecVol)
d371 1
a371 1
   double        pegConsVol;
d387 1
a387 1
      pegConsVol = pegExecVol * theConsRate;
d389 1
a389 1
      myReqSched_->addTo (consPart, consPer, pegConsVol);
@


1.3
log
@Continued implementation of post-implosion pegging.
@
text
@d106 2
d144 36
@


1.2
log
@Continued implementation of post-implosion pegging.
@
text
@a42 1
      curPegVol_   (myProblem (), 0.0),
d151 4
a154 4
   WitPart * topPart;
   WitPart * thePart;
   WitPeriod thePer;
   double    netReqVol;
d163 3
a165 3
      for (thePer =  myReqSched_->firstPer (thePart); 
           thePer <= myReqSched_->lastPer  (thePart);
           thePer ++)
d169 1
a169 1
         if (netReqVol <= NET_TOL)
d172 11
a182 4
         if (thePart->isaCapacity ())
            pegAvailVol (thePart,           thePer, netReqVol);
         else
            pegMaterial (thePart->myMat (), thePer, netReqVol);
d192 4
a195 4
void WitPipBuilder::pegMaterial (
      WitMaterial * theMat,
      WitPeriod     reqPer,
      double &      netReqVol)
d197 3
a199 5
   double    unstockedVol;
   double    upStock;
   WitPeriod startPer;
   WitPeriod pegPer;
   double    pegVol;
d203 1
a203 32
   unstockedVol = 0.0;

   startPer     = reqPer;

   for (pegPer = reqPer; pegPer >= 0; pegPer --)
      {
      if (pegPer < reqPer)
         {
         if (theMat->mandEC ()[pegPer])
            break;

         upStock = upStockVol_ (theMat)[pegPer];

         if (upStock < netReqVol)
            {
            unstockedVol += netReqVol - upStock;

            netReqVol     = upStock;

            if (netReqVol < NET_TOL)
               break;
            }
         }

      pegVol = pegAvailVol (theMat, pegPer, netReqVol);

      if (pegVol > 0.0)
         {
         startPer = pegPer;

         if (pegPer < reqPer)
            curPegVol_[pegPer] = pegVol;
d205 2
a206 4
         if (netReqVol < NET_TOL)
            break;
         }
      }
d208 2
a209 1
   netReqVol += unstockedVol;
d211 1
a211 2
   pegStockVols (theMat, startPer, reqPer);
   }
d213 2
a214 1
//------------------------------------------------------------------------------
d216 1
a216 6
double WitPipBuilder::pegAvailVol (
      WitPart * thePart,
      WitPeriod pegPer,
      double &  netReqVol)
   {
   double pegVol;
d218 1
a218 1
   pegVol = pegSupVol (thePart, pegPer, netReqVol);
d220 1
a220 3
   if (netReqVol >= NET_TOL)
      if (thePart->prodVol ()[pegPer] >= NET_TOL)
         pegVol += expPart (thePart, pegPer, netReqVol);
d222 1
a222 1
   return pegVol;
d227 1
a227 1
double WitPipBuilder::pegSupVol (
d258 1
a258 23
void WitPipBuilder::pegStockVols (
      WitMaterial * theMat,
      WitPeriod     startPer,
      WitPeriod     reqPer)
   {
   double    totPegVol;
   WitPeriod pegPer;

   totPegVol = 0.0;

   for (pegPer = startPer; pegPer < reqPer; pegPer ++)
      {
      totPegVol += curPegVol_[pegPer];

      curPegVol_[pegPer] = 0.0;

      upStockVol_ (theMat)[pegPer] -= totPegVol;
      }
   }

//------------------------------------------------------------------------------

double WitPipBuilder::expPart (
a263 1
   WitPeriod     execPer;
d267 2
a268 1
   witAssert (thePart->prodVol ()[expPer] >= NET_TOL);
d271 1
a271 1
      return 0.0;
d275 1
a275 1
   return expBopEntry (theBopEnt, expPer, netReqVol);
d280 1
a280 1
double WitPipBuilder::expBopEntry (
a289 1
   double         pegProdVol;
d298 1
a298 1
      return 0.0;
a309 2
      pegProdVol = netReqVol;

d318 1
a318 3
      pegProdVol = theUpExec * theProdRate;

      netReqVol -= pegProdVol;
d321 1
a321 3
   expBomEntries (theOpn, execPer, pegExecVol);

   return pegProdVol;
d326 1
a326 1
void WitPipBuilder::expBomEntries (
@


1.1
log
@Continued implementation of post-implosion pegging.
@
text
@d19 1
d24 1
d26 1
d43 2
a44 1
      curPegVol_   (myProblem (), 0.0)
d46 1
d53 1
d80 1
a80 1
      peg (theDemand, shipPer, incShipVol);
d116 2
d119 2
a120 2
   if (myCompMgr ()->nBomEntries () > 0)
      myMsgFac () ("nyiForPIPSmsg", "BOM entries");
d138 5
d147 1
a147 1
void WitPipBuilder::peg (
d152 4
a155 3
   WitPart *     thePart;
   WitPeriod     reqPer;
   double        netReqVol;
d159 3
a161 1
   thePart   = theDemand->demandedPart ();
d163 9
a171 1
   reqPer    = shipPer;
d173 4
a176 1
   netReqVol = incShipVol;
d178 2
a179 4
   if (thePart->isaCapacity ())
      pegAvailVol (thePart,           reqPer, netReqVol);
   else
      pegMaterial (thePart->myMat (), reqPer, netReqVol);
d181 1
a181 1
   setToMax (maxUpReqVol_, netReqVol);
d255 1
a255 1
         pegVol += pegByExp (thePart, pegPer, netReqVol);
d315 1
a315 1
double WitPipBuilder::pegByExp (
d320 2
a321 6
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         theProdRate;
   double         theUpProd;
   double         pegProdVol;
d330 1
a330 1
   theBopEnt  = thePart->expBopEntry (expPer);
d332 18
a349 1
   theOpn     = theBopEnt->myOperation ();
d351 1
a351 1
   execPer    = expPer;
d353 3
a355 1
   if (upExecVol_ (theOpn)[execPer] < NET_TOL)
d360 1
a360 1
   theUpProd   = upExecVol_ (theOpn)[execPer] * theProdRate;
d362 1
a362 1
   if (netReqVol <= theUpProd)
d364 4
a370 2

      upExecVol_ (theOpn)[execPer] -= pegProdVol / theProdRate;
d374 3
a376 1
      pegProdVol = theUpProd;
d378 1
a378 1
      netReqVol -= theUpProd;
d380 1
a380 1
      upExecVol_ (theOpn)[execPer] = 0.0;
d383 2
d386 33
@


head	1.39;
access;
symbols
	sce_410_withVa:1.30
	sce_4_05_20040511:1.28
	sce_4_00_20040201:1.28
	nextGenBranch:1.22.0.2
	nextGenRoot:1.22
	sce_3_30_20030627:1.21
	EndRw-branch:1.13.0.4
	Root-of-EndRw:1.13
	rwToStl:1.13.0.2
	latest_sce_3_10_20010924:1.5.0.2
	sce_3_10_20010924:1.5
	latest_sce_3_00_20010601:1.4.0.2
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.3.0.2
	sce_2_31_20010308:1.3;
locks; strict;
comment	@ * @;


1.39
date	2006.03.02.21.55.49;	author rjw;	state dead;
branches;
next	1.38;

1.38
date	2006.02.21.15.44.14;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.02.17.17.07.17;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.15.21.45.26;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.15.21.27.22;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.27.21.50.18;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.26.21.44.32;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.26.18.47.56;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.22.14.59.50;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.06.19.47.58;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.22.20.38.59;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.11.18.37.26;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.10.17.27.37;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.09.23.26.23;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.09.23.20.58;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.09.22.44.05;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.01.21.05.03;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.10.22.58.16;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.23.20.47.15;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.23.19.13.19;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.22.19.32.11;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.15.21.01.19;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.13.22.22.07;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.09.23.29.45;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.02.23.40.38;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.02.22.18.24;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.10.18.02.09;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.21.58.52;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.20.14.54;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.06.20.04.14;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.03.19.58.26;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.02.20.53.10;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.01.14.25.54;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.18.14.02.30;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.06.17.30.57;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.25.14.53.23;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.20.00.44.16;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.20.20.08.35;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.06.19.58.36;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.39
log
@[shared-resource pegging]
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

#ifndef DenseH
#define DenseH

//------------------------------------------------------------------------------
// Header file: "Dense.h"
//
// Contains the declaration of the following classes:
//
//    AbsDenseList
//    DenseList <Elem>
//------------------------------------------------------------------------------

#include <Vector.h>

//------------------------------------------------------------------------------
// class WitAbsDenseList (Abstract Dense List)
//
// An AbsDenseList is a dense list whose elements are void pointers.
// In other words, it's a Vector with a list-like interface.
// Implemented in terms of Vector <void *>.
// This class functions as a base class for the generic class
//    DenseList <Elem>.
// Its purpose is to implement all type-independent aspects of
//    DenseList <Elem>.
// Since this function is intended to be used only as a base class, its
//    ctors and dtor are protected.
//
// Class Hierarchy:
//
//    AbsDenseList
//       DenseList <Elem>
//
// Implemented in Vecs.C.
//------------------------------------------------------------------------------

class WitAbsDenseList
   {
      friend class WitAbsDLSorter;

   public:

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (int, nElements)

      inline int storageCapacity () const
         {
         return myVector_.length ();
         }
         //
         // The maximum # elements this DenseList can hold.

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      inline void clear ()
         {
         nElements_ = 0;
         }
         //
         // Removes all of the elements from this DenseList.

      inline bool isEmpty () const
         {
         return (nElements_ == 0);
         }
         //
         // Returns true iff this DenseList is empty.

      void resize (int newStorageCapacity);
         //
         // Resizes this AbsDenseList to allow it to hold newStorageCapacity
         // elements.
         // The list will be empty.

   protected:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAbsDenseList (int theStorageCapacity);
         //
         // Constructs an empty list.
         // The list cannot be expanded to more than theStorageCapacity
         // elements.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitAbsDenseList ();

      //------------------------------------------------------------------------
      // Other protected member functions.
      //------------------------------------------------------------------------

      void appendAbs (void * theObject);
         //
         // Adds theObject to the end of this List.

      inline void * firstAbs () const
         {
         witAssert (not isEmpty ());

         return myVector_[0];
         }
         //
         // Returns the first element in this List.

      inline void * lastAbs () const
         {
         witAssert (not isEmpty ());

         return myVector_[static_cast <int> (nElements_) - 1];
         }
         //
         // Returns the last element in this List.

      bool advanceAbs (int & theIndex, void * & theElement) const;
         //
         // Advances theIndex. If theIndex is still valid for this DenseList
         // after the advance, this function sets theElement to the indexed
         // element and returns true. Otherwise, this function sets theElement
         // to NULL and returns false. TheIndex is required to be >= -1.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitAbsDenseList);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitVector <void *> myVector_;
         //
         // The Vector thru which this AbsDenseList is implemented.

      int nElements_;
         //
         // # elements in this list.
         // Must be <= storageCapacity ().
   };

//------------------------------------------------------------------------------
// Class Template DenseList <Elem>
//
// A DenseList <Elem> is a dense list whose elements are instances of Elem.
//
// Class Hierarchy:
//
//    AbsDenseList
//       DenseList <Elem>
//
// Implemented in Vecs.C.
//------------------------------------------------------------------------------

template <typename Elem> 
      class WitDenseList: public WitAbsDenseList
   {
      typedef int (* WitCompFunc) (Elem *, Elem *, void *);
         //
         // A pointer to a sorting comparison function.

   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitDenseList (int newStorageCapacity = 0);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitDenseList ();

      //------------------------------------------------------------------------
      // Wrappers around AbsDenseList member functions.
      //------------------------------------------------------------------------

      inline void append (Elem * theObject)
         {
         appendAbs (theObject);
         }

      inline Elem * first () const
         {
         return reinterpret_cast <Elem *> (firstAbs ());
         }

      inline Elem * last () const
         {
         return reinterpret_cast <Elem *> (lastAbs ());
         }

      inline bool advance (int & theIndex, Elem * & theElement) const
         {
         return advanceAbs (theIndex, reinterpret_cast <void * &> (theElement));
         }

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void sort (WitCompFunc theCompFunc, void * theContext);
         //
         // Sorts the elements in this DenseList according to theCompFunc, which
         // is to be called with theContext.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitDenseList);
   };

//------------------------------------------------------------------------------
// NonClass function template copyIntoDense.
//------------------------------------------------------------------------------

namespace WitNonClass
   {
   template <typename Elem> 
         void copyIntoDense (
            WitDenseList <Elem>  & theDenseList,
            const WitList <Elem> & theList);
      //
      // Makes theDenseList a shallow copy of theList.
      // Assumes that theDenseList already has sufficient storage.
   }; 

//------------------------------------------------------------------------------
// macro forEachElDense (theElement, theDenseList)
//
// Expands to a header of a for loop that iterates thru each element in
// theDenseList.
//
// Arguments:
//
//    theDenseList: Type: const DenseList <Elem>, for some type, Elem.
//                  The dense list being iterated.
//
//    theElement:   Type: Elem *
//                  A pointer that will be set to each element of theDenseList,
//                  in sequence. The body of the for loop should normally make
//                  use of this pointer.
//
// Note: If theDenseList is empty, the forEachElDense loop does nothing (which
// is to be expected).
//
// Example:
//
// WitDenseList <WitDemand> theDemands;
//
// ...Fill up theDemands with Demands.
//
// WitDemand * theDemand;
//
// forEachElDense (theDemand, theDemands)
//    {
//    ...statements using theDemand...
//    }
//
// The implementation of this macro calls the macro forEachElDenseIndex
// (defined below), which expands to a name unique to the line of source code
// from which the forEachElDenseIndex macro was called. This name is used as
// the name of an int, which is used to implement the forEachElDense macro. It
// is necessary for the forEachElDense macro to use a different name for its
// index each time it is called, because it might get called more than once
// from within the same scope.
//------------------------------------------------------------------------------

#define forEachElDenseIndex name2 (forEachElDenseIndexOnLine, __LINE__)

//------------------------------------------------------------------------------

#define forEachElDense(theElement, theDenseList)                               \
                                                                               \
   for (                                                                       \
      int forEachElDenseIndex = -1;                                            \
      (theDenseList).advance (forEachElDenseIndex, theElement);                \
      )                                                                        \

#endif
@


1.38
log
@[shared-resource pegging]
@
text
@@


1.37
log
@[shared-resource pegging]
@
text
@d55 1
a55 1
      accessFunc (WitSiz, nElements)
d57 1
a57 1
      inline WitSiz storageCapacity () const
d82 1
a82 1
      void resize (WitSiz newStorageCapacity);
d94 1
a94 1
      WitAbsDenseList (WitSiz theStorageCapacity);
d155 1
a155 1
      WitSiz nElements_;
d187 1
a187 1
      WitDenseList (WitSiz newStorageCapacity = 0);
@


1.36
log
@[shared-resource pegging]
@
text
@d55 1
a55 1
      accessFunc (size_t, nElements)
d57 1
a57 1
      inline size_t storageCapacity () const
d82 1
a82 1
      void resize (size_t newStorageCapacity);
d94 1
a94 1
      WitAbsDenseList (size_t theStorageCapacity);
d155 1
a155 1
      size_t nElements_;
d187 1
a187 1
      WitDenseList (size_t newStorageCapacity = 0);
@


1.35
log
@[shared-resource pegging]
@
text
@d27 1
a27 1
// An AbsDenseList is a dense list whose elements are TlPtrs.
d29 1
a29 1
// Implemented in terms of Vector (TlPtr).
@


1.34
log
@[multi-thread]
@
text
@a22 1
#include <TlObj.h>
d110 1
a110 1
      void appendAbs (WitTlObj * theObject);
d114 1
a114 1
      inline WitTlObj * firstAbs () const
d123 1
a123 1
      inline WitTlObj * lastAbs () const
d132 1
a132 1
      bool advanceAbs (int & theIndex, WitTlObj * & theElement) const;
d151 1
a151 1
      WitVector <WitTlObj *> myVector_;
d201 1
a201 1
         appendAbs (toTlObj_cast (theObject));
d206 1
a206 1
         return fromTlObj_cast <Elem> (firstAbs ());
d211 1
a211 1
         return fromTlObj_cast <Elem> (lastAbs ());
d216 1
a216 1
         return advanceAbs (theIndex, toTlObjRef_cast (theElement));
@


1.33
log
@[multi-thread]
@
text
@d178 3
a180 1
      typedef int (* WitCompareFunc) (Elem *, Elem *);
d220 9
@


1.32
log
@[multi-thread]
@
text
@d48 2
a139 5
      void sortAbs (WitAbsDLSortCrit * theAbsDLSortCrit);
         //
         // Sorts this AbsDenseList, using theAbsDLSortCrit as the sorting
         // criterion.

a145 4
      static int compareForQsort (const void *, const void *);
         //
         // The compare function that sortAbs will pass to qsort.

a217 6
      void sort (WitGenDLSortCrit <Elem> * theGenDLSortCrit);
         //
         // Sorts this DenseList, using theGenDLSortCrit as the sorting
         // criterion.
         // Called by NonClass::sort (...).

a242 16
// NonClass function template sort.
//------------------------------------------------------------------------------

namespace WitNonClass
   {
   template <typename Elem, typename Context>
         void sort (
            WitDenseList <Elem> & theDenseList,
            int (Context::*       theCompFunc) (Elem *, Elem *),
            Context *             theContext);
      //
      // Sorts the elements in theDenseList according to theCompFunc, which is
      // to be called with theContext.
   }; 

//------------------------------------------------------------------------------
@


1.31
log
@[multi-thread]
@
text
@a19 3
//    AbsSortRule
//    SortRule <Elem>
//    SortEl
d138 1
a138 1
      void sortAbs (WitAbsSortRule * theAbsSortRule);
d140 1
a140 1
         // Sorts this AbsDenseList, using theAbsSortRule as its sorting
d149 1
a149 3
      static int compareForQsort (
            const void * elemPtr1,
            const void * elemPtr2);
d151 1
a151 1
         // The compare function to be passed to qsort.
d156 1
a156 1
      // Private static member data.
d225 1
a225 1
      void sort (WitCompareFunc theCompFunc);
d227 3
a229 14
         // Sorts this DenseList.
         // theFunc is a pointer to the compare function that will be used
         // in the sort. It should be declared as follows:
         //
         // int theFunc (
         //    const Elem * element1,
         //    const Elem * element2);
         //
         // and should return -1, 0, or +1, depending whether element1 is
         // considered to be <, =, or > element2, complying with the qsort
         // convention.
         //
         // This function is implemented by calling AbsDenseList::sortAbs,
         // which calls qsort.
d256 16
a322 174
//------------------------------------------------------------------------------
// Class AbsSortRule
//
// Specifies a criterion for sorting an AbsDenseList.
//
// Class Hierarchy:
//
//    AbsSortRule
//       SortRule <Elem>
//
// Implemented in Vecs.C.
//------------------------------------------------------------------------------

class WitAbsSortRule
   {
   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      virtual int compare (WitTlObj * theTlObj1, WitTlObj * theTlObj2) = 0;
         //
         // Compares theTlObj1 and theTlObj2 for sorting.

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAbsSortRule ();

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitAbsSortRule ();

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitAbsSortRule);
   };

//------------------------------------------------------------------------------
// Class Template SortRule <Elem>
//
// Specifies a criterion for sorting a DenseList <Elem>.
//
// Class Hierarchy:
//
//    AbsSortRule
//       SortRule <Elem>
//
// Implemented in Vecs.C.
//------------------------------------------------------------------------------

template <typename Elem> 
      class WitSortRule: public WitAbsSortRule
   {
      typedef int (* WitCompareFunc) (Elem *, Elem *);

   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSortRule (WitCompareFunc);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitSortRule ();

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      virtual int compare (WitTlObj * theTlObj1, WitTlObj * theTlObj2);
         //
         // Compares theTlObj1 and theTlObj2 for sorting.
         // theTlObj1 and theTlObj2 are assumed to actually be pointers to Elem.
         // Override from class AbsSortRule.

      noCopyCtorAssign (WitSortRule);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      const WitCompareFunc myCompareFunc_;
   };

//------------------------------------------------------------------------------
// Class SortEl
//
// "Sorting Element"
// Used by AbsDenseList::sortAbs ().
// Each SortEl is associated with an element of the AbsDenseList and with an
// AbsSortRule.
// A vector of SortEls is passed to qsort to implement the sort.
//
// Implemented in Vecs.C.
//------------------------------------------------------------------------------

class WitSortEl
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSortEl ();

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitSortEl ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void setData (WitTlObj *, WitAbsSortRule *);

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      inline WitTlObj * myTlObj () const
         {
         return myTlObj_;
         }

      inline WitAbsSortRule * myAbsSortRule () const
         {
         return myAbsSortRule_;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitSortEl);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitTlObj * myTlObj_;
         //
         // The element of the AbsDenseList correwsponding to this SortEl.

      WitAbsSortRule * myAbsSortRule_;
         //
         // The AbsSortRule to be used as the sorting criterion.
   };

@


1.30
log
@[multi-thread]
@
text
@d19 4
a22 1
//    DenseList (TheType)
d35 1
a35 1
//    DenseList (TheType).
d37 1
a37 1
//    DenseList (TheType).
d44 1
a44 1
//       DenseList <TheType>
d106 1
a106 1
      virtual ~WitAbsDenseList ();
d141 1
a141 1
      void sortAbs ();
d143 2
a144 8
         // Sorts this AbsDenseList, using "compare" is its compare function.

      virtual int compare (
            const void * elemPtr1,
            const void * elemPtr2)
            const = 0;
         //
         // Compares elemPtr1 and elemPtr2 for qsort, when called by sortAbs.
d152 1
a152 1
      static int qsortCompFunc (
a163 5
      static const WitAbsDenseList * curAbsDenseList_;
         //
         // During a call to sortAbs, curAbsDenseList_ is this AbsDenseList.
         // otherwise NULL.

d175 1
a175 1
// Class Template DenseList <TheType>
d177 1
a177 2
// A DenseList <TheType> is a dense list whose elements are instances of
// TheType. Derived from class AbsDenseList.
d179 6
a184 1
// All implementation is inline.
d187 1
a187 1
template <typename TheType> 
d190 1
a190 1
      typedef int (* WitCompareFunc) (TheType *, TheType *);
d198 1
a198 4
      WitDenseList (size_t newStorageCapacity = 0):
            WitAbsDenseList (newStorageCapacity)
         {
         }
d204 1
a204 3
      inline virtual ~WitDenseList ()
         {
         }
d210 1
a210 1
      inline void append (TheType * theObject)
d215 1
a215 1
      inline TheType * first () const
d217 1
a217 1
         return fromTlObj_cast <TheType> (firstAbs ());
d220 1
a220 1
      inline TheType * last () const
d222 1
a222 1
         return fromTlObj_cast <TheType> (lastAbs ());
d225 1
a225 1
      inline bool advance (int & theIndex, TheType * & theElement) const
d237 2
a238 2
         //    const TheType * element1,
         //    const TheType * element2);
a243 5
         // This function makes use of static data members. Consequently,
         // it cannot be used recursively. I.e., "theFunc" must not
         // (directly or indirectly) invoke DenseList (TheType)::sort, for
         // any type. If it does, a fatal error is generated.
         //
a253 13

      virtual int compare (const void *, const void *) const;
         //
         // Override from class AbsDenseList.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      static WitCompareFunc curCompFunc_;
         //
         // During a call to sort, curCompFunc_ is the CompareFunc arg;
         // otherwise NULL.
d262 1
a262 1
   template <typename TheType> 
d264 2
a265 2
            WitDenseList <TheType>  & theDenseList,
            const WitList <TheType> & theList);
d279 1
a279 1
//    theDenseList: Type: const DenseList (TheType), for some type, TheType.
d282 1
a282 1
//    theElement:   Type: TheType *
d323 174
@


1.29
log
@[multi-threads]
@
text
@d288 9
a296 13
{

template <typename TheType> 
      void copyIntoDense (
         WitDenseList <TheType>  & theDenseList,
         const WitList <TheType> & theList);
   //
   // Makes theDenseList a shallow copy of theList.
   // Assumes that theDenseList already has sufficient storage.

}; 
   //
   // Leaving namespace NonClass.
@


1.28
log
@Continued implementation of PIP.
@
text
@a297 1
// Leaving namespace NonClass.
d299 2
@


1.27
log
@Continued implementation of PIP.
@
text
@d288 12
a299 9
   {
   template <typename TheType> 
         void copyIntoDense (
            WitDenseList <TheType>  & theDenseList,
            const WitList <TheType> & theList);
      //
      // Makes theDenseList a shallow copy of theList.
      // Assumes that theDenseList already has sufficient storage.
   };
@


1.26
log
@Fixed syntax error found on AIX.
@
text
@d284 1
a284 1
// NonClass function template copyIntoD.
d290 1
a290 1
         void copyIntoD (
@


1.25
log
@Continued implementation of PIP.
@
text
@d290 1
a290 1
         inline void copyIntoD (
@


1.24
log
@Continued implementation of PIP.
@
text
@d284 1
a284 1
// NonClass function template copyInto.
d290 1
a290 1
         inline void copyInto (
@


1.23
log
@Continued implementation of PIP.
@
text
@a22 1
#include <List.h>
d284 1
a284 1
// Implementation of Class Template DenseList <TheType>
d287 1
a287 8
template <typename TheType> 
      typename WitDenseList <TheType>::WitCompareFunc
      WitDenseList <TheType>::curCompFunc_ = NULL;

//------------------------------------------------------------------------------

template <typename TheType> 
      void WitDenseList <TheType>::sort (WitCompareFunc theCompFunc)
d289 8
a296 48
   stronglyAssert (curCompFunc_  == NULL);
   stronglyAssert (theCompFunc  != NULL);

   curCompFunc_ = theCompFunc;

   sortAbs ();

   curCompFunc_ = NULL;
   }

//------------------------------------------------------------------------------

template <typename TheType> 
      int WitDenseList <TheType>::compare (
         const void * elemPtr1, 
         const void * elemPtr2) 
         const
   {
   TheType * elem1;
   TheType * elem2;

   witAssert (curCompFunc_ != NULL);

   elem1 = * static_cast <TheType * const *> (elemPtr1);
   elem2 = * static_cast <TheType * const *> (elemPtr2);

   return curCompFunc_ (elem1, elem2);
   }

//------------------------------------------------------------------------------
// Global function template copyInto (DenseList, List).
//
// Makes theDenseList a shallow copy of theList.
// Assumes that theDenseList already has sufficient storage.
//------------------------------------------------------------------------------

template <typename TheType> 
   inline void copyInto (
      WitDenseList <TheType>  & theDenseList,
      const WitList <TheType> & theList)
   {
   TheType * theObject;

   theDenseList.clear ();

   forEachEl (theObject, theList)
      theDenseList.append (theObject);
   }
@


1.22
log
@Added some optional warnings on Linux.
@
text
@d47 1
a47 1
class WitAbsDenseList: public WitUtil
@


1.21
log
@Changed some C style casts to C++ style.
@
text
@d104 1
a104 1
      ~WitAbsDenseList ();
d212 1
a212 1
      inline ~WitDenseList ()
@


1.20
log
@Replaced some C style casts with C++ style casts.
@
text
@d127 1
a127 1
         return myVector_[((int) nElements_) - 1];
@


1.19
log
@Replaced some C-style casts with C++ style casts.
@
text
@d320 2
a321 2
   elem1 = * (TheType * const *) elemPtr1;
   elem2 = * (TheType * const *) elemPtr2;
@


1.18
log
@Various internal changes.
@
text
@d24 1
d110 1
a110 1
      WitTlObj * appendAbs (WitTlObj * theObject);
d112 1
a112 1
         // Adds theObject to the end of this List and returns it.
d220 1
a220 1
      inline TheType * append (TheType * theObject)
d222 1
a222 1
         return (TheType *) appendAbs ((WitTlObj *) theObject);
d227 1
a227 1
         return (TheType *) firstAbs ();
d232 1
a232 1
         return (TheType *) lastAbs ();
d237 1
a237 1
         return advanceAbs (theIndex, (WitTlObj * &) theElement);
@


1.17
log
@Various internal changes.
@
text
@d267 1
a267 1
      noCopyCtorAssignTemp (WitDenseList, TheType);
@


1.16
log
@Updated the code to accomodate the following two VAC compiler warning messages:
   1540-0152
   1540-0080
@
text
@d191 1
a191 1
template <class TheType> 
d287 1
a287 1
template <class TheType> 
d293 1
a293 1
template <class TheType> 
d308 1
a308 1
template <class TheType> 
d332 1
a332 1
template <class TheType> 
@


1.15
log
@Internal changes.
@
text
@d288 1
a288 1
      WitDenseList <TheType>::WitCompareFunc
@


1.14
log
@Internal changes.
@
text
@d115 1
a115 1
         witAssert (! isEmpty ());
d124 1
a124 1
         witAssert (! isEmpty ());
@


1.13
log
@Continued implementation of single source.
@
text
@d74 1
a74 1
      inline WitBoolean isEmpty () const
d79 1
a79 1
         // Returns TRUE iff this DenseList is empty.
d131 1
a131 1
      WitBoolean advanceAbs (int & theIndex, WitTlObj * & theElement) const;
d135 2
a136 2
         // element and returns TRUE. Otherwise, this function sets theElement
         // to NULL and returns FALSE. TheIndex is required to be >= -1.
d234 1
a234 4
      inline WitBoolean advance (
            int &       theIndex,
            TheType * & theElement)
            const
@


1.12
log
@Preliminary work on single source.
@
text
@d242 1
a242 1
      inline void sort (WitCompareFunc theCompFunc);
d272 1
a272 4
      virtual inline int compare (
            const void * elemPtr1,
            const void * elemPtr2)
            const;
d297 1
a297 1
      inline void WitDenseList <TheType>::sort (WitCompareFunc theCompFunc)
d312 1
a312 1
      inline int WitDenseList <TheType>::compare (
@


1.11
log
@Continued preliminary work on single source.
@
text
@d172 1
a172 1
      WitVector <WitTlObjPtr> myVector_;
@


1.10
log
@Continued preliminary work on single source.
@
text
@d203 1
a203 3
            WitAbsDenseList (newStorageCapacity),

            curCompFunc_    (NULL)
d280 1
a280 1
      // Private static member data.
d283 1
a283 1
      WitCompareFunc curCompFunc_;
d291 6
@


1.9
log
@More preliminary work on single source.
@
text
@a25 11

extern "C"
   {
   typedef int (* WitQsortCompareFunc) (const void *, const void *);
   }
   //
   // The type of compare function pointer that qsort requires.
   // (Used by AbsDenseList.)
   // The extern "C" linkage is necessary on C Set/2.

//------------------------------------------------------------------------------
a62 7
      inline static WitTlObj * compareFuncForSort ()
         {
         witAssert (compareFuncForSort_ != NULL);

         return compareFuncForSort_;
         }

d138 10
a147 9
      void sortAbs (
            WitTlObj *          theCompareFunc,
            WitQsortCompareFunc theQsortCompareFunc);
         //
         // Sorts this AbsDenseList.
         // theCompareFunc is a pointer to the compare function that will be
         // used in the sort. See DenseList (TheType)::sort for details.
         // theQsortCompareFunc is the function pointer that will be passed to
         // qsort.
d155 6
d167 1
a167 1
      static WitTlObj * compareFuncForSort_;
d169 2
a170 7
         // When a sort is in progress, this is the compare function that
         // was passed as an argument to DenseList (TheType)::sort.
         // NULL, when a sort in not in progress.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------
d203 3
a205 1
            WitAbsDenseList (newStorageCapacity)
d244 1
a244 4
      inline void sort (WitCompareFunc theCompFunc)
         {
         sortAbs ((WitTlObj *) theCompFunc, compareForQsort);
         }
d263 1
a263 1
         // This function is implemented by calling AbsDenseList::sort,
d274 1
a274 1
      inline static int compareForQsort (
d276 13
a288 1
            const void * elemPtr2);
d296 4
a299 7
   inline int WitDenseList <TheType>::compareForQsort (
         const void * elemPtr1,
         const void * elemPtr2)
      {
      WitCompareFunc compare;
      TheType *      elem1;
      TheType *      elem2;
d301 1
a301 1
      compare =   (WitCompareFunc)    compareFuncForSort ();
d303 1
a303 2
      elem1   = * (TheType * const *) elemPtr1;
      elem2   = * (TheType * const *) elemPtr2;
d305 21
a325 2
      return compare (elem1, elem2);
      }
@


1.8
log
@Preliminary work on single source.
@
text
@d48 6
d101 1
a101 1
         // Resizes this WitDenseList to allow it to hold newStorageCapacity
d199 1
a199 1
// generic class DenseList (TheType)
d201 1
a201 1
// A DenseList (TheType) is a dense list whose elements are instances of
d204 1
a204 4
// This is a pointer-based collection class: its methods do not use the copy
// constructor for TheType.
//
// Implemented in Vecs.C.
d207 89
d297 1
a297 3
// macro WitCompareFunc(TheType)
//
// Used as the name of a generic typedef.
d300 16
a315 3
#define WitCompareFunc(TheType)                                                \
                                                                               \
   name2 (WitCompareFunc, TheType)                                             \
d318 4
a321 1
// Declaration macro for generic class DenseList (TheType).
d324 12
a335 89
#define WitDenseListdeclare(TheType)                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Typedef WitCompareFunc(TheType).                                          */\
/*                                                                           */\
/* Used by "sort" to declare a compare function.                             */\
/*---------------------------------------------------------------------------*/\
                                                                               \
typedef int (* WitCompareFunc(TheType)) (TheType *, TheType *);                \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Declaration of class DenseList (TheType).                                 */\
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitDenseList (TheType): public WitAbsDenseList                           \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitDenseList (TheType) (size_t newStorageCapacity = 0);                  \
         /*                                                                  */\
         /* See AbsDenseList ctor.                                           */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitDenseList (TheType) ();                                              \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Wrappers around AbsDenseList member functions.                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline TheType * append (TheType * theObject)                            \
         {                                                                     \
         return (TheType *) appendAbs ((WitTlObj *) theObject);                \
         }                                                                     \
                                                                               \
      inline TheType * first () const                                          \
         {                                                                     \
         return (TheType *) firstAbs ();                                       \
         }                                                                     \
                                                                               \
      inline TheType * last () const                                           \
         {                                                                     \
         return (TheType *) lastAbs ();                                        \
         }                                                                     \
                                                                               \
      inline WitBoolean advance (                                              \
            int &       theIndex,                                              \
            TheType * & theElement)                                            \
            const                                                              \
         {                                                                     \
         return advanceAbs (theIndex, (WitTlObj * &) theElement);              \
         }                                                                     \
                                                                               \
      void sort (WitCompareFunc(TheType) theFunc);                             \
         /*                                                                  */\
         /* Sorts this DenseList.                                            */\
         /* theFunc is a pointer to the compare function that will be used   */\
         /* in the sort. It should be declared as follows:                   */\
         /*                                                                  */\
         /* int theFunc (                                                    */\
         /*    const TheType * element1,                                     */\
         /*    const TheType * element2);                                    */\
         /*                                                                  */\
         /* and should return -1, 0, or +1, depending whether element1 is    */\
         /* considered to be <, =, or > element2, complying with the qsort   */\
         /* convention.                                                      */\
         /*                                                                  */\
         /* This function makes use of static data members. Consequently,    */\
         /* it cannot be used recursively. I.e., "theFunc" must not          */\
         /* (directly or indirectly) invoke DenseList (TheType)::sort, for   */\
         /* any type. If it does, a fatal error is generated.                */\
         /*                                                                  */\
         /* This function is implemented by calling AbsDenseList::sort,      */\
         /* which calls qsort.                                               */\
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtorAssign (WitDenseList (TheType));                               \
   };                                                                          \
d358 1
a358 1
// WitDenseList (WitDemand) theDemands;
a387 34

//------------------------------------------------------------------------------
// Global generic function copyInto-DenseList-List (TheType).
//
// Makes theDenseList a shallow copy of theList.
// Assumes that theDenseList already has sufficient storage.
//------------------------------------------------------------------------------

#define copyIntoDenseListFromListdeclare(TheType)                              \
                                                                               \
void copyInto (                                                                \
      WitDenseList (TheType)  & theDenseList,                                  \
      const WitList <TheType> & theList);                                      \

//------------------------------------------------------------------------------
// Declarations of all specific cases of the generic classes and functions
// declared in this file.
//------------------------------------------------------------------------------

declare (WitDenseList,              WitComponent)
declare (WitDenseList,              WitNode)
declare (WitDenseList,              WitPart)
declare (WitDenseList,              WitMaterial)
declare (WitDenseList,              WitOperation)
declare (WitDenseList,              WitSubEntry)
declare (WitDenseList,              WitBopEntry)
declare (WitDenseList,              WitDemand)
declare (WitDenseList,              WitDatedPart)
declare (WitDenseList,              WitCoeff)

declare (copyIntoDenseListFromList, WitBopEntry)
declare (copyIntoDenseListFromList, WitOperation)
declare (copyIntoDenseListFromList, WitPart)
declare (copyIntoDenseListFromList, WitSubEntry)
@


1.7
log
@Preliminary work on single source.
@
text
@d182 1
a182 1
      WitVector (WitTlObjPtr) myVector_;
@


1.6
log
@Began implementation of object iteration.
@
text
@d371 1
a371 1
      const WitList (TheType) & theList);                                      \
@


1.5
log
@Minor change.
@
text
@d22 1
@


1.4
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@a376 2
declare (WitDenseList,              WitBopEntry)
declare (WitDenseList,              WitCoeff)
d378 2
a379 2
declare (WitDenseList,              WitDatedPart)
declare (WitDenseList,              WitDemand)
a380 1
declare (WitDenseList,              WitNode)
a381 1
declare (WitDenseList,              WitPart)
d383 4
@


1.3
log
@Implemented and used class SelMgr.
@
text
@d67 1
a67 1
      inline static WitTl * compareFuncForSort ()
d120 1
a120 1
      WitTl * appendAbs (WitTl * theObject);
d124 1
a124 1
      inline WitTl * firstAbs () const
d133 1
a133 1
      inline WitTl * lastAbs () const
d142 1
a142 1
      WitBoolean advanceAbs (int & theIndex, WitTl * & theElement) const;
d150 1
a150 1
            WitTl *             theCompareFunc,
d171 1
a171 1
      static WitTl * compareFuncForSort_;
d181 1
a181 1
      WitVector (WitTlPtr) myVector_;
d255 1
a255 1
         return (TheType *) appendAbs ((WitTl *) theObject);                   \
d273 1
a273 1
         return advanceAbs (theIndex, (WitTl * &) theElement);                 \
@


1.2
log
@Further development of coarse selection splitting.
@
text
@d22 1
a22 1
#include <RWClient.h>
d47 1
a47 1
// Implemented in Vector.C.
d200 1
a200 1
// Implemented in Vector.C.
@


1.1
log
@Some minor changes.
@
text
@d38 1
a38 1
// An AbsDenseList is a dense list whose elements are TypelessPtrs.
d40 1
a40 1
// Implemented in terms of Vector (TypelessPtr).
d67 1
a67 1
      inline static WitTypelessPtr compareFuncForSort ()
d120 1
a120 1
      WitTypelessPtr appendAbs (WitTypelessPtr theObject);
d124 1
a124 1
      inline WitTypelessPtr firstAbs () const
d133 1
a133 1
      inline WitTypelessPtr lastAbs () const
d142 1
a142 4
      WitBoolean advanceAbs (
            int &            theIndex, 
            WitTypelessPtr & theElement) 
            const;
d150 1
a150 1
            WitTypelessPtr      theCompareFunc,
d171 1
a171 1
      static WitTypelessPtr compareFuncForSort_;
d181 1
a181 1
      WitVector (WitTypelessPtr) myVector_;
d255 1
a255 1
         return (TheType *) appendAbs ((WitTypelessPtr) theObject);            \
d273 1
a273 1
         return advanceAbs (theIndex, (WitTypelessPtr &) theElement);          \
@


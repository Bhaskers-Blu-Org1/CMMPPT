head	1.108;
access;
symbols
	latest_sce_4_20_20060523:1.47.0.2
	sce_4_20_20060523:1.47
	latest_sce4_20_OSL:1.44.0.2
	sce_4_20_OSL:1.44
	sce_410_withVa:1.38
	sce_4_05_20040511:1.37
	sce_4_00_20040201:1.27
	nextGenBranch:1.26.0.2
	nextGenRoot:1.26
	sce_3_30_20030627:1.25
	EndRw-branch:1.24.0.4
	Root-of-EndRw:1.24
	rwToStl:1.24.0.2
	latest_sce_3_10_20010924:1.6.0.2
	sce_3_10_20010924:1.6
	latest_sce_3_00_20010601:1.5.0.4
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.108
date	2007.08.01.22.41.58;	author rjw;	state dead;
branches;
next	1.107;

1.107
date	2007.06.22.19.04.04;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2007.06.12.21.56.45;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2007.06.11.21.54.57;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.06.08.21.54.42;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.06.08.18.26.09;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.06.08.18.09.40;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.06.06.16.28.02;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.06.06.15.57.25;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.05.25.23.26.52;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.05.25.18.39.11;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.05.24.21.57.10;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.05.24.18.52.22;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.05.23.22.32.29;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.11.22.49.32;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.10.21.14.42;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.10.17.22.15;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.03.05.21.32.10;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.03.02.22.11.01;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.28.22.15.48;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.02.28.20.04.58;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.27.22.59.30;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.27.21.03.04;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.02.10.00.08.14;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.02.08.22.47.35;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.02.08.00.14.25;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.02.07.00.13.08;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.02.06.22.48.57;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.01.30.21.43.09;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2006.12.29.20.17.19;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2006.12.28.23.11.05;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2006.12.28.16.39.35;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2006.12.27.22.45.40;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2006.12.06.19.52.46;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2006.12.01.21.36.35;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2006.12.01.19.55.17;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2006.10.31.22.58.32;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2006.10.26.20.53.47;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2006.10.26.19.03.15;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2006.10.19.21.54.29;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2006.10.13.20.47.02;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2006.10.12.19.43.44;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2006.10.12.16.22.12;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.11.22.37.21;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2006.10.10.19.10.46;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.10.09.23.25.23;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.10.04.18.45.07;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.03.15.08.59;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.02.22.11.35;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.02.19.27.35;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.09.29.22.56.40;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2006.09.29.18.40.58;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2006.08.29.15.01.46;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2006.08.21.16.00.21;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2006.08.18.23.32.16;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.08.18.22.29.01;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.08.18.18.43.38;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.08.17.21.21.32;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.17.20.29.41;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.17.19.36.39;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.02.17.34.05;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.21.20.37.11;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.21.20.06.32;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.01.20.35.54;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.03.22.09.13;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.27.21.50.19;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.27.17.56.33;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.26.18.47.56;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.30.18.13.59;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.22.16.37.18;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.05.00.06.54;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.03.19.07.27;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.02.23.52.13;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.20.15.37.35;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.06.23.27.10;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.15.23.22.32;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.08.20.59.29;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.02.22.18.39;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.11.18.53.12;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.06.19.56.09;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.26.22.49.04;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.26.20.16.09;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.23.21.00.39;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.23.19.08.49;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.23.18.09.14;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.19.23.25.06;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.15.20.03.45;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.08.17.33.33;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.26.18.28.37;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.06.18.53.40;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.05.19.31.35;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.08.19.21.54;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.07.20.15.00;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.03.23.16.40;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.01.14.25.58;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.14.02.38;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.29.21.37.20;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.23.11.45;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.29.21.22.46;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.25;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.33;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches;
next	;


desc
@@


1.108
log
@Stochastic Implosion
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

#ifndef OptImpH
#define OptImpH

//------------------------------------------------------------------------------
// Header file: "OptImp.h"
//
// Contains the declaration of class OptImploder.
//------------------------------------------------------------------------------

#include <Assoc.h>
#include <Str.h>
#include <Schedule.h>
#include <PairStack.h>

//------------------------------------------------------------------------------
// Class OptImploder
// Responsible for performing an optimizing implosion.
//------------------------------------------------------------------------------

class WitOptImploder: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitOptImploder (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitOptImploder ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool, extOptActive)
      accessFunc (bool, accelerated)

      accessNonNull (WitExtOptMgr *, myExtOptMgr)

      accessWrapper (WitOptComp *, myOptComp, myProblem ())

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void shutDown ();
         //
         // Shuts down optimizing implosion.
         // If accelerated () is true, this OptImploder is restored to an
         // unaccelerated state.

      void implode ();
         //
         // Performs an optimizing implosion.

      void verifyNoIntCons ();
         //
         // Verifies that no integrality constraints have been specified.
         // (Non-MIP mode)

      void evalObjectives ();
         //
         // Sets the optimization problem solution to the production and
         // shipment schedules and evaluates the objective functions for this
         // solution.

      void compObj1Values (double & primaryValue) const;
         //
         // Computes and passes back values for objective #1.

      void compObj2Values (
            double & revValue,
            double & invValue,
            double & servValue,
            double & subValue)
            const;
         //
         // Computes and passes back values for objective #2.

      bool boundsObjUsed () const;
         //
         // Returns true, iff the bounds objective was used.

      inline bool extOptActive ()
         {
         return (myExtOptMgr_ != NULL);
         }

      void startExtOpt ();
         //
         // Initiates external optimizing implosion.

      void finishExtOpt ();
         //
         // Concludes external optimizing implosion.

      void shutDownExtOpt ();
         //
         // Terminates external optimizing implosion without constructing the
         // implosion solution.

      void exportObjs (double & objValueRef, double & boundsValueRef);
         //
         // Computes the objective function values and sets the values of the
         // reference arguments to them.
         // Valid only when the optimizing implosion subsystem is exporting the
         // objective function values.

      //------------------------------------------------------------------------
      // Solution exporting functions.
      // 
      // Each of these functions sets the values of its reference arguments to
      // the portion of the implosion solution corresponding to the first
      // argument.
      // Valid only when the optimizing implosion subsystem is exporting the
      // optimizing implosion solution.
      //------------------------------------------------------------------------

      void exportSoln (WitGlobalComp *, WitPartPerStack & revCritListRef);
      void exportSoln (WitPart *,       WitDblFlexVec   &    scrapVolRef,
                                        WitDblFlexVec   & shadowPriceRef);
      void exportSoln (WitMaterial *,   WitDblFlexVec   &    stockVolRef);
      void exportSoln (WitDemand *,     WitDblFlexVec   &     shipVolRef,
                                        WitDblFlexVec   &  cumShipVolRef);
      void exportSoln (WitOperation *,  WitDblFlexVec   &     execVolRef);
      void exportSoln (WitSubEntry *,   WitDblFlexVec   &      subVolRef);

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      accessNonNull (WitDetImpOP *, myDetImpOP)

      void startOptImp ();
         //
         // Initiates optimizing implosion.

      void finishOptImp ();
         //
         // Concludes optimizing implosion.

      void validateMipMode ();
         //
         // Verifies that the data is valid for MIP mode.

      void compInitSoln () const;
         //
         // Computes the initial implosion solution, if any.

      void setUpOptProb ();
         //
         // Sets up myDetImpOP_

      void compInitOptSoln ();
         //
         // Computes an initial solution to myDetImpOP_.

      void compObjectives ();
         //
         // Computes the values of all the objective functions.

      void exportSoln ();
         //
         // Exports the implosion solution to the Components of myProblem ().

      double solnValue (const WitOptVar * theOptVar);
         //
         // Returns the primal solution value of theOptVar, modified as
         // appropriate for passing to myProblem ().

      void buildCritList ();
         //
         // Uses the dual solution to the optimization problem to form the
         // critical parts list.

      bool comparePotential (
            std::pair <WitPart *, WitPeriod> *,
            std::pair <WitPart *, WitPeriod> *);
         //
         // Compare function for sorting the critical part list.

      noCopyCtorAssign (WitOptImploder);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitDetImpOP * myDetImpOP_;
         //
         // The DetImpOP owned by this OptImploder, in any.

      bool extOptActive_;
         //
         // True, iff external optimizing implosion is currently active.

      WitExtOptMgr * myExtOptMgr_;
         //
         // The ExtOptMgr owned by this OptImploder, when external
         // optimizing implosion is active; otherwise NULL.
         // External optimizing implosion is currently active,
         // iff myExtOptMgr_ is not NULL.

      bool accelerated_;
         //
         // true, iff this OptImploder is eligible for an accelerated
         // implosion.

      bool exportingSoln_;
         //
         // True, iff exportSoln () is currently executing.

      WitTVec <double> exportTVec_;
         //
         // TVec used by the exportSoln (...) functions.
         // Allocated only during exportSoln ().

      bool exportingObjs_;
         //
         // True, iff exportObjs () is currently executing.

      WitPartPerStack criticalList_;
         //
         // The critical part list for optimizing implosion.
         // Stored in forward order.

      WitSchedule <WitPart, double> potential_;
         //
         // potential_(thePart)[thePer] is the estimated "potential for
         // improvement" that would result from increasing the supply of thePart
         // in period thePer. Specifically, it is the shadow price on the
         // material balance constraint for thePart in period thePer.
   };

#endif
@


1.107
log
@Stochastic Implosion
@
text
@@


1.106
log
@Stochastic Implosion
@
text
@d150 1
a150 1
      accessNonNull (WitImpOptProb *, myImpOptProb)
d170 1
a170 1
         // Sets up myImpOptProb_
d174 1
a174 1
         // Computes an initial solution to myImpOptProb_.
d206 1
a206 1
      WitImpOptProb * myImpOptProb_;
d208 1
a208 2
         // The Implosion Optimization Problem owned by this OptImploder,
         // in any.
@


1.105
log
@Stochastic Implosion
@
text
@a30 2
   friend class WitStochImploder;

d72 5
a163 4
      void verifyNoIntCons ();
         //
         // Verifies that no integrality constraints have been specified.

@


1.104
log
@Stochastic Implosion
@
text
@d31 2
a73 4
      void stochImplode ();
         //
         // Performs an optimizing implosion for stochastic implosion.

a156 4
      void startStochImp ();
         //
         // Initiates stochastic optimizing implosion.

a172 4
      void setUpStochOptProb ();
         //
         // Sets up ???

@


1.103
log
@Stochastic Implosion
@
text
@d51 2
a52 4
      accessFunc (bool,   extOptActive)
      accessFunc (bool,   accelerated)
      accessFunc (double, objValue)
      accessFunc (double, boundsValue)
d117 1
a117 1
      void importStochSoln ();
d119 4
a122 4
         // Imports this OptImploder's portion of the stochastic implosion
         // solution from myStochImpMgr ().
         // Valid only when the stochastic implosion subsystem is either
         // exporting or clearing the stochastic implosion solution.
d238 1
a238 1
      bool exporting_;
d247 1
a247 2
      double objValue_;
      double boundsValue_;
d249 1
a249 1
         // Objective function values.
@


1.102
log
@Stochastic Implosion
@
text
@d136 8
a143 8
      void exportSoln (WitGlobalComp *, WitPartPerStack & revCritListArg);
      void exportSoln (WitPart *,       WitDblFlexVec   &    scrapVolArg,
                                        WitDblFlexVec   & shadowPriceArg);
      void exportSoln (WitMaterial *,   WitDblFlexVec   &    stockVolArg);
      void exportSoln (WitDemand *,     WitDblFlexVec   &     shipVolArg,
                                        WitDblFlexVec   &  cumShipVolArg);
      void exportSoln (WitOperation *,  WitDblFlexVec   &     execVolArg);
      void exportSoln (WitSubEntry *,   WitDblFlexVec   &      subVolArg);
@


1.101
log
@Stochastic Implosion
@
text
@d119 1
a119 1
      void passStochRefs ();
d121 4
a124 2
         // Passes references to the stochastic data of this OptImploder to
         // myStochImpMgr ().
d127 1
a127 1
      // Solution providing functions.
d132 2
a133 2
      // Invalid if this OptImploder is not currently calling
      // Component::acquireOptSoln ().
d136 8
a143 19
      void provideSoln (WitGlobalComp *,
                        WitPartPerStack & revCritListArg);

      void provideSoln (WitPart *,
                        WitDblFlexVec   &    scrapVolArg,
                        WitDblFlexVec   & shadowPriceArg);

      void provideSoln (WitMaterial *,
                        WitDblFlexVec   &    stockVolArg);

      void provideSoln (WitDemand *,
                        WitDblFlexVec   &     shipVolArg,
                        WitDblFlexVec   &  cumShipVolArg);

      void provideSoln (WitOperation *,
                        WitDblFlexVec   &     execVolArg);

      void provideSoln (WitSubEntry *,
                        WitDblFlexVec   &      subVolArg);
d193 1
a193 1
      void provideSoln ();
d195 1
a195 1
         // Provides the implosion solution to the Components of myProblem ().
d240 5
a244 1
      WitTVec <double> curSolnTVec_;
d246 2
a247 2
         // TVec used by the provideSoln (...) functions.
         // Allocated only during provideSoln ().
@


1.100
log
@Stochastic Implosion
@
text
@d128 4
a131 4
      // the portion of the implosion solution indicated by the argument name
      // and corresponding to the Component and Period for which
      // this OptImploder is currently calling acquireOptSoln ().
      // Invalid if this OptImploder is not currently calling acquireOptSoln ().
d134 19
a152 8
      void provideGlobalSoln    (WitPartPerStack & revCritListArg);
      void providePartSoln      (WitDblFlexVec   &    scrapVolArg,
                                 WitDblFlexVec   & shadowPriceArg);
      void provideMaterialSoln  (WitDblFlexVec   &    stockVolArg);
      void provideDemandSoln    (WitDblFlexVec   &     shipVolArg,
                                 WitDblFlexVec   &  cumShipVolArg);
      void provideOperationSoln (WitDblFlexVec   &     execVolArg);
      void provideSubEntrySoln  (WitDblFlexVec   &      subVolArg);
a160 1
      accessNonNull (WitComponent *,  acquireComp)
a248 5
      WitComponent * acquireComp_;
         //
         // The Component for which acquireOptSoln is currently being called, if
         // any; otherwise NULL.

d251 2
a252 2
         // TVec used by the provide<Comp>Soln functions.
         // Alloocated only during provideSoln ().
@


1.99
log
@Stochastic Implosion
@
text
@d244 5
@


1.98
log
@Stochastic Implosion
@
text
@d74 4
d160 4
d180 4
@


1.97
log
@Stochastic Implosion
@
text
@d121 7
a127 2
      // Implosion solution export functions.
      // Only valid when the implosion solution is being exported.
d130 8
a137 9
      double scrapVol    (WitPart      *, WitPeriod);
      double shadowPrice (WitPart      *, WitPeriod);
      double stockVol    (WitMaterial  *, WitPeriod);
      double shipVol     (WitDemand    *, WitPeriod);
      double cumShipVol  (WitDemand    *, WitPeriod);
      double execVol     (WitOperation *, WitPeriod);
      double subVol      (WitSubEntry  *, WitPeriod);

      const WitPartPerStack & criticalList ();
d146 1
d180 1
a180 1
      void exportSoln ();
d182 1
a182 1
         // Passes the implosion solution to myProblem ().
d227 1
a227 1
      bool exporting_;
d229 2
a230 1
         // True, iff the implosion solution is currently being exported.
@


1.96
log
@Stochastic Implosion
@
text
@a134 15
      //------------------------------------------------------------------------
      // Reference receiving functions.
      // Each of these functions stores its arguments on the assumption that
      // they are references to the similarly named data members of the
      // Component for which passOptRefs () is currently being called.
      //------------------------------------------------------------------------

      void receivePartRefs      (WitDblFlexVec &    scrapVolArg,
                                 WitDblFlexVec & shadowPriceArg);
      void receiveMaterialRefs  (WitDblFlexVec &    stockVolArg);
      void receiveDemandRefs    (WitDblFlexVec &     shipVolArg,
                                 WitDblFlexVec &  cumShipVolArg);
      void receiveOperationRefs (WitDblFlexVec &     execVolArg);
      void receiveSubEntryRefs  (WitDblFlexVec &      subVolArg);

a225 5
      WitComponent * passRefsComp_;
         //
         // The Component for which passOptRefs is currently being called, if
         // any; otherwise NULL.

@


1.95
log
@Stochastic Implosion
@
text
@d115 1
a115 1
      void passStochData ();
d117 2
a118 1
         // Passes the stochastic data of this OptImploder to myStochImpMgr ().
d135 15
d241 5
@


1.94
log
@Stochastic Implosion
@
text
@d115 1
a115 1
      void importStochObjValues ();
d117 1
a117 1
         // Imports objective function values from stochastic implosion.
@


1.93
log
@Stochastic Implosion
@
text
@d115 4
@


1.92
log
@Stochastic Implosion
@
text
@d128 2
d179 1
a179 1
      void formCriticalList ();
d182 1
a182 1
         // criticalList.
d184 3
a186 1
      bool comparePotential (WitPartPer *, WitPartPer *);
d226 5
@


1.91
log
@[disallowed backlog]
@
text
@d22 1
d115 13
d213 4
@


1.90
log
@[disallowed backlog]
@
text
@a137 4
      void validateNonBacklog ();
         //
         // Verifies data for Demands with backlogAllowed_ == false.
                                                     
@


1.89
log
@[disallowed backlog]
@
text
@d140 1
a140 1
         // Verifies data for Demands with disallowBacklog_ == true.
@


1.88
log
@[disallowed backlog]
@
text
@d140 1
a140 1
         // Verifies data for Demands with backlogAllowed_ == false.
@


1.87
log
@[disallowed backlog]
@
text
@a113 14
      //------------------------------------------------------------------------
      // Functions for receiving data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      //------------------------------------------------------------------------

      static void receiveDMPs (WitDblFlexVec      WitPart::* scrapVolArg,
                               WitDblFlexVec      WitPart::* shadowPriceArg);
      static void receiveDMPs (WitDblFlexVec  WitMaterial::* stockVolArg);
      static void receiveDMPs (WitDblFlexVec    WitDemand::* shipVolArg,
                               WitDblFlexVec    WitDemand::* cumShipVolArg);
      static void receiveDMPs (WitDblFlexVec WitOperation::* execVolArg);
      static void receiveDMPs (WitDblFlexVec  WitSubEntry::* subVolArg);

a181 19
      //------------------------------------------------------------------------
      // Data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      // E.g., theOpn->*execVol_ == theOpn->execVol_.
      //------------------------------------------------------------------------

      static WitDblFlexVec      WitPart::* scrapVol_;
      static WitDblFlexVec      WitPart::* shadowPrice_;
      static WitDblFlexVec  WitMaterial::* stockVol_;
      static WitDblFlexVec    WitDemand::* shipVol_;
      static WitDblFlexVec    WitDemand::* cumShipVol_;
      static WitDblFlexVec WitOperation::* execVol_;
      static WitDblFlexVec  WitSubEntry::* subVol_;

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

@


1.86
log
@[disallowed backlog]
@
text
@a59 13
      // Set functions.
      //
      // Each of these functions sets the value of the corresponding data
      // member to the value of the argument.
      //------------------------------------------------------------------------

      void setPrintOptProb   (bool);
      void setPrintMatByCols (bool);
      void setPrintInitSoln  (bool);
      void setPrintOptSoln   (bool);
      void setPrintMps       (bool);

      //------------------------------------------------------------------------
@


1.85
log
@Rescinded all changed made since 1/31/07.
@
text
@a140 3
      static void receiveDMPs (
                       WitList <WitPartPer> WitGlobalComp::* criticalListArg);

d216 7
a222 8
      static WitDblFlexVec              WitPart::* scrapVol_;
      static WitDblFlexVec              WitPart::* shadowPrice_;
      static WitDblFlexVec          WitMaterial::* stockVol_;
      static WitDblFlexVec            WitDemand::* shipVol_;
      static WitDblFlexVec            WitDemand::* cumShipVol_;
      static WitDblFlexVec         WitOperation::* execVol_;
      static WitDblFlexVec          WitSubEntry::* subVol_;
      static WitList <WitPartPer> WitGlobalComp::* criticalList_;
@


1.84
log
@[disallowed backlog]
@
text
@d61 3
d66 5
a70 3
      void setExecVol (WitOperation *, const WitIVRealArg &);
      void setShipVol (WitDemand *,    const WitIVRealArg &);
      void setSubVol  (WitSubEntry *,  const WitIVRealArg &);
d109 4
a112 3
      void resetShadowPrices ();
         //
         // Sets thePart->shadowPrice to 0 for all Parts.
d133 8
d219 7
d245 2
@


1.83
log
@[disallowed backlog]
@
text
@d65 1
a126 2
      static void receiveDMPs (WitDblFlexVec  WitSubEntry::* subVolArg);

a204 1
      static WitDblFlexVec          WitSubEntry::* subVol_;
@


1.82
log
@[disallowed backlog]
@
text
@a60 3
      //
      // Each of these functions sets the value of the corresponding data
      // member to the value of the argument.
d63 2
a64 5
      void setPrintOptProb   (bool);
      void setPrintMatByCols (bool);
      void setPrintInitSoln  (bool);
      void setPrintOptSoln   (bool);
      void setPrintMps       (bool);
a125 4
      static void receiveDMPs (WitDblFlexVec  WitMaterial::* stockVolArg);
      static void receiveDMPs (WitDblFlexVec    WitDemand::* shipVolArg,
                               WitDblFlexVec    WitDemand::* cumShipVolArg);
      static void receiveDMPs (WitDblFlexVec WitOperation::* execVolArg);
a205 4
      static WitDblFlexVec          WitMaterial::* stockVol_;
      static WitDblFlexVec            WitDemand::* shipVol_;
      static WitDblFlexVec            WitDemand::* cumShipVol_;
      static WitDblFlexVec         WitOperation::* execVol_;
@


1.81
log
@[disallowed backlog]
@
text
@d109 4
a131 2
      static void receiveDMPs (WitDblFlexVec      WitPart::*,
                               WitDblFlexVec      WitPart::* shadowPriceArg);
a215 1
      static WitDblFlexVec              WitPart::* shadowPrice_;
@


1.80
log
@[disallowed backlog]
@
text
@d128 1
a128 1
      static void receiveDMPs (WitDblFlexVec      WitPart::* scrapVolArg,
a213 1
      static WitDblFlexVec              WitPart::* scrapVol_;
@


1.79
log
@[backlog avoidance]
@
text
@a108 5
      inline bool extOptActive ()
         {
         return (myExtOptMgr_ != NULL);
         }

a239 2
         // External optimizing implosion is currently active,
         // iff myExtOptMgr_ is not NULL.
@


1.78
log
@External opt implosion.
@
text
@d167 4
@


1.77
log
@External opt implosion.
@
text
@d50 1
d152 1
a152 1
      void startIntOpt ();
d154 1
a154 5
         // Initiates internal optimizing implosion.

      void prepOptImp ();
         //
         // Prepares optimizing implosion.
d188 1
a188 1
      static double solnValue (const WitOptVar * theOptVar);
d190 2
a191 2
         // Returns the positive part of the primal solution value of theOptVar,
         // or 0.0, if NULL.
d233 4
@


1.76
log
@External opt implosion.
@
text
@d151 1
a151 1
      void start ();
d153 1
a153 1
         // Initiates optimizing implosion.
d155 5
a159 1
      void finish ();
@


1.75
log
@External opt implosion.
@
text
@d121 5
@


1.74
log
@External opt implosion.
@
text
@d54 1
a54 1
      accessNonNull (WitExtOptHandler *, myExtOptHandler)
d110 1
a110 1
         return (myExtOptHandler_ != NULL);
d227 1
a227 1
      WitExtOptHandler * myExtOptHandler_;
d229 1
a229 1
         // The ExtOptHandler owned by this OptImploder, when external
d232 1
a232 1
         // iff myExtOptHandler_ is not NULL.
@


1.73
log
@External opt implosion.
@
text
@d154 1
a154 1
      void validateIntConsMode ();
d156 1
a156 2
         // Verifies that the data is valid for a problem with integrality
         // constraints.
@


1.72
log
@External opt implosion.
@
text
@d159 4
@


1.71
log
@External opt implosion.
@
text
@a153 4
      bool hasIntCons ();
         //
         // Returns true, iff any integrality constraints have been specified.

@


1.70
log
@External opt implosion.
@
text
@d54 1
a54 1
      accessNonNull (WitExtOptPerf *, myExtOptPerf)
d110 1
a110 1
         return (myExtOptPerf_ != NULL);
d228 1
a228 1
      WitExtOptPerf * myExtOptPerf_;
d230 4
a233 4
         // The ExtOptPerf owned by this OptImploder, when external optimizing
         // implosion is active; otherwise NULL.
         // External optimizing implosion is currently active, iff myExtOptPerf_
         // is not NULL.
@


1.69
log
@External opt implosion.
@
text
@a116 8
      //------------------------------------------------------------------------
      // Functions valid only when external optimizing implosion is active.
      //------------------------------------------------------------------------

      void setExtOptColSol (const WitIVRealArg & theVector);
         //
         // Sets the primal solution to theVector.

@


1.68
log
@External opt implosion.
@
text
@d50 5
a54 5
      accessFunc (bool,            extOptActive)
      accessFunc (bool,            accelerated)
      accessFunc (double,          objValue)
      accessFunc (double,          boundsValue)
      accessFunc (WitImpOptProb *, myImpOptProb)
d108 5
a120 19
      void getExtOptProb (
            WitVector <int> &    start,
            WitVector <int> &    index,
            WitVector <double> & value,
            WitVector <double> & collb,
            WitVector <double> & colub,
            WitVector <double> & obj,
            WitVector <double> & rowlb,
            WitVector <double> & rowub,
            WitVector <int> &    intIndices,
            double &             objSense);
         //
         // Retrieves data specifying the optimization problem, using
         // "standard column major ordered format". On return, the args can be
         // passed to the following COIN functions:
         //    OsiSolverInterface::loadProblem (...).
         //    OsiSolverInterface::setInteger  (...).
         //    OsiSolverInterface::setObjSense (...).

d152 1
a152 1
      noCopyCtorAssign (WitOptImploder);
d205 2
d231 6
a236 1
      bool extOptActive_;
d238 4
a241 1
         // true, iff external optimizing implosion is currently active.
a252 4
      WitImpOptProb * myImpOptProb_;
         //
         // The Implosion Optimization Problem for this OptImploder.

@


1.67
log
@External opt implosion.
@
text
@d65 5
a69 5
      void setPrintOptProb   (bool         theValue);
      void setPrintMatByCols (bool         theValue);
      void setPrintInitSoln  (bool         theValue);
      void setPrintOptSoln   (bool         theValue);
      void setPrintMps       (bool         theValue);
d116 1
a116 1
      void getExtOptProblem (
d135 1
a135 1
      void setExtOptColSolution (const WitIVRealArg & theVector);
@


1.66
log
@External opt implosion.
@
text
@d116 1
a116 1
      void getOptProbData (
d135 4
@


1.65
log
@External opt implosion.
@
text
@d50 1
a50 1
      accessFunc (bool,            asstOptActive)
d108 1
a108 1
      void startAsstOpt ();
d110 1
a110 1
         // Initiates assisted optimizing implosion.
d113 1
a113 1
      // Functions valid only when assisted optimizing implosion is active.
d135 1
a135 1
      void finishAsstOpt ();
d137 1
a137 1
         // Concludes assisted optimizing implosion.
d239 1
a239 1
      bool asstOptActive_;
d241 1
a241 1
         // true, iff assisted optimizing implosion is currently active.
@


1.64
log
@Assisted opt implosion.
@
text
@a134 4
      void solveOptProbAsst ();
         //
         // Solves the optimization problem in assisted mode.

@


1.63
log
@Assisted opt implosion.
@
text
@a116 2
            int &                numcols,
            int &                numrows,
d124 3
a126 1
            WitVector <double> & rowub);
d130 4
a133 1
         // passed to the COIN function OsiSolverInterface::loadProblem (...).
@


1.62
log
@Custom opt implosion.
@
text
@d50 1
a50 1
      accessFunc (bool,            custActive)
d108 1
a108 1
      void startCust ();
d110 1
a110 1
         // Initiates custom optimizing implosion.
d113 1
a113 1
      // Functions valid only when custom optimizing implosion is active.
d132 1
a132 1
      void solveOptProbCust ();
d134 1
a134 1
         // Solves the optimization problem in custom mode.
d136 1
a136 1
      void finishCust ();
d138 1
a138 1
         // Concludes custom optimizing implosion.
d240 1
a240 1
      bool custActive_;
d242 1
a242 1
         // true, iff custom optimizing implosion is currently active.
@


1.61
log
@App controlled opt implosion.
@
text
@d50 1
a50 1
      accessFunc (bool,            active)
d108 1
a108 1
      void start ();
d110 1
a110 1
         // Initiates optimizing implosion.
d113 1
a113 1
      // Functions valid only when optimizing implosion is active.
d132 1
a132 1
      void solveOptProb ();
d134 1
a134 1
         // Solves the optimization problem.
d136 1
a136 1
      void finish ();
d138 1
a138 1
         // Concludes optimizing implosion.
d165 8
d240 1
a240 5
      bool active_;
         //
         // true, iff optimizing implosion is currently active.

      bool stdImplosion_;
d242 1
a242 2
         // true, iff optimizing implosion is currently active and "standard",
         // i.e., running under the implode function.
@


1.60
log
@App controlled opt implosion.
@
text
@a84 12
      void start ();
         //
         // Initiates optimizing implosion.

      void solveOptProb ();
         //
         // Solves the optimization problem.

      void finish ();
         //
         // Concludes optimizing implosion.

d108 32
@


1.59
log
@App controlled opt implosion.
@
text
@d99 3
a101 2
         // Sets the optimization model solution to the production and shipment
         // schedules and evaluates the objective functions for this solution.
d181 1
a181 1
         // Uses the dual solution from the optimization model to form the
@


1.58
log
@App controlled opt implosion.
@
text
@d213 6
a218 1
         // true, iff this OptImploder is currently in an active state.
@


1.57
log
@App controlled opt implosion.
@
text
@a64 1
      void setActive         (bool         theValue);
d89 1
a89 1
      void solve ();
@


1.56
log
@App controlled opt implosion.
@
text
@d86 12
@


1.55
log
@App controlled opt implosion.
@
text
@d50 5
a54 13
      accessFunc (bool,              active)
      accessFunc (bool,              accelerated)
      accessFunc (double,            objValue)
      accessFunc (double,            boundsValue)
      accessFunc (const WitString &, modelOFName)
      accessFunc (const WitString &, initSolnOFName)
      accessFunc (const WitString &, omSolnOFName)
      accessFunc (bool,              printOptProb)
      accessFunc (bool,              printMatByCols)
      accessFunc (bool,              printInitSoln)
      accessFunc (bool,              printOptSoln)
      accessFunc (bool,              printMps)
      accessFunc (WitImpOptProb *,   myImpOptProb)
a70 2
      void setModelOFName    (const char * theValue);
      void setOmSolnOFName   (const char * theValue);
a213 40
      WitString modelOFName_;
         //
         // Name of model output file.

      WitString initSolnOFName_;
         //
         // Name of initial optimization solution output file.

      WitString omSolnOFName_;
         //
         // Name of optimization model solution output file.

      //------------------------------------------------------------------------
      // Development mode control parameters.
      //------------------------------------------------------------------------

      bool printOptProb_;
         //
         // Print the optimization model.

      bool printMatByCols_;
         //
         // Print the matrix by columns.

      bool printInitSoln_;
         //
         // Print the initial optimization solution.

      bool printOptSoln_;
         //
         // Print the final optimization solution.

      bool printMps_;
         //
         // Print an MPS file.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

@


1.54
log
@App controlled opt implode.
@
text
@d73 1
a117 4
      void recTitleUpdate ();
         //
         // To be called when the title attribute is updated.

@


1.53
log
@App controlled opt implosion.
@
text
@d117 4
@


1.52
log
@App controlled opt implode.
@
text
@d50 1
d209 4
@


1.51
log
@App controlled opt implosion.
@
text
@d81 1
a81 1
      // These functions are implemented as no-ops in non-OPT_IMPLODE mode.
a89 4
      //------------------------------------------------------------------------
      // These functions issue a fatal error in non-OPT_IMPLODE mode.
      //------------------------------------------------------------------------

a116 8
      // Other public member functions.
      //------------------------------------------------------------------------

      bool optImpMode () const;
         //
         // Returns true, iff OPT_IMPLODE is in effect.

      //------------------------------------------------------------------------
a140 9
      void notAllowed () const;
         //
         // Issues the fatal error message for functions that must not be
         // called in non-OPT_IMPLODE mode.

      //------------------------------------------------------------------------
      // Functions only implemented in OPT_IMPLODE mode.
      //------------------------------------------------------------------------

@


1.50
log
@Integrality constraints.
@
text
@d56 1
a56 1
      accessFunc (bool,              printOptModel)
d61 1
a61 1
      accessFunc (WitImpOM *,        myImpOM)
d72 1
a72 1
      void setPrintOptModel  (bool         theValue);
d175 1
a175 1
      void setUpOptModel ();
d177 1
a177 1
         // Sets up myImpOM_
d181 1
a181 1
         // Computes an initial solution to myImpOM_.
d255 1
a255 1
      bool printOptModel_;
d279 1
a279 1
      WitImpOM * myImpOM_;
d281 1
a281 1
         // The Implosion Optimization Model.
@


1.49
log
@Integrality constraints.
@
text
@a60 1
      accessFunc (int,               stopOpt)
a76 1
      void setStopOpt        (int          theValue);
a274 6
      int stopOpt_;
         //
         // 0 --> normal.
         // 1 --> stop after computing initial optimization solution.
         // 2 --> stop after printing an MPS file.

@


1.48
log
@Removed optimizing implosion with lot sizes.
@
text
@d164 9
@


1.47
log
@Updated the copyright date on all source files.
@
text
@a21 1
#include <RefMap.h>
a65 3
      int incLotSize (WitOperation *, WitPeriod);
      int minLotSize (WitOperation *, WitPeriod);

a129 4
      int lotSizeRatio (WitOperation *, WitPeriod);
         //
         // Returns minLotSize / incLotSize.

a197 16
      void validateOWLS ();
         //
         // Checks data validity for opt with lot sizes, if appropriate.

      void setupLotSizes ();
         //
         // Sets up incLotSize_ and minLotSize_.

      void printLotSizes ();
         //
         // Prints incLotSize_ and minLotSize_.

      void shutDownLotSizes ();
         //
         // Shuts down incLotSize_ and minLotSize_.

a281 5
      WitRefMap <WitOperation, WitFlexVec <int> > incLotSize_;
      WitRefMap <WitOperation, WitFlexVec <int> > minLotSize_;
         //
         // incLotSize and minLotSize for each Operation, stored as integers.

@


1.46
log
@Removed some more OSL items.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.45
log
@Removed some more OSL items.
@
text
@a125 4
      static bool coinMode ();
         //
         // Returns true, iff WIT was built in COIN mode.

a171 5
      void protectedImplode ();
         //
         // Performs the aspects of implode () that are to be protected by a try
         // block.

a242 10
      // Static private member data.
      //------------------------------------------------------------------------

      static bool errorHasOccurred_;
         //
         // In OSL mode, true, iff an error has occurred during implode for any
         // instance of this class during the program process.
         // False, in COIN mode.

      //------------------------------------------------------------------------
@


1.44
log
@[shared-resource pegging]
@
text
@d58 1
a58 1
      accessFunc (bool,              printOslVecs)
a61 1
      accessFunc (int,               printMask)
d77 8
a84 9
      void setPrintOptModel (bool         theValue);
      void setPrintOslVecs  (bool         theValue);
      void setPrintInitSoln (bool         theValue);
      void setPrintOptSoln  (bool         theValue);
      void setPrintMps      (bool         theValue);
      void setPrintMask     (int          theValue);
      void setStopOpt       (int          theValue);
      void setModelOFName   (const char * theValue);
      void setOmSolnOFName  (const char * theValue);
d295 1
a295 1
      bool printOslVecs_;
d297 1
a297 1
         // Print the vector passed to OSL ekklmdl.
a310 5
      int printMask_;
         //
         // If > 0, have OSL print the optimization solution and use this value
         // for iprtinfomask.

@


1.43
log
@[error recovery]
@
text
@d213 1
a213 1
      static int comparePotential (WitPartPer *, WitPartPer *, void *);
d217 1
a217 1
     void validateOWLS ();
@


1.42
log
@[multi-thread]
@
text
@d178 1
a178 1
      void innerImplode ();
d180 2
a181 1
         // Does the main work of implode ().
d254 10
@


1.41
log
@[multi-thread]
@
text
@a22 1
#include <Ref.h>
d145 3
a147 1
      // Data loading functions.
d150 7
a156 13
      void loadDataFrom (
            WitPart *       thePart,
            WitDblFlexVec & scrapVolArg,
            WitDblFlexVec & shadowPriceArg);

      void loadDataFrom (
            WitMaterial *   theMat,
            WitDblFlexVec & stockVolArg);

      void loadDataFrom (
            WitDemand *     theDemand,
            WitDblFlexVec & shipVolArg,
            WitDblFlexVec & cumShipVolArg);
d158 2
a159 10
      void loadDataFrom (
            WitOperation *  theOpn,
            WitDblFlexVec & execVolArg);

      void loadDataFrom (
            WitSubEntry *   theSub,
            WitDblFlexVec & subVolArg);

      void loadDataFromGlobalComp (
            WitList <WitPartPer> & criticalListArg);
a197 8
      void loadData ();
         //
         // Loads the data to be loaded from the components.

      void clearLoadedData ();
         //
         // Clears the data that was loaded from the components.

d237 4
a240 1
      // Mappings to data loaded in from Components.
d243 8
a250 9
      WitRefMap <WitPart,      WitDblFlexVec> scrapVol_;
      WitRefMap <WitPart,      WitDblFlexVec> shadowPrice_;
      WitRefMap <WitMaterial,  WitDblFlexVec> stockVol_;
      WitRefMap <WitDemand,    WitDblFlexVec> shipVol_;
      WitRefMap <WitDemand,    WitDblFlexVec> cumShipVol_;
      WitRefMap <WitOperation, WitDblFlexVec> execVol_;
      WitRefMap <WitSubEntry,  WitDblFlexVec> subVol_;

      WitRef    <WitList <WitPartPer> >              criticalList_;
@


1.40
log
@[multi-thread]
@
text
@d233 1
a233 4
      static int comparePotential (
            WitPartPer *,
            WitPartPer *,
            WitOptImploder *);
d237 1
a237 1
      void validateOWLS ();
@


1.39
log
@[multi-thread]
@
text
@d233 4
a236 3
      int comparePotential (
            WitPartPer * thePartPer1,
            WitPartPer * thePartPer2);
@


1.38
log
@[multi-thread]
@
text
@d233 1
a233 1
      static int comparePotential (
a346 5
      static WitOptImploder * curOptImploder_;
         //
         // The OptImploder for which formCriticalList is currenlty being 
         // called, if any, else NULL.

@


1.37
log
@Double Precision.
@
text
@d129 4
@


1.36
log
@Double Precision.
@
text
@d146 3
a148 3
            WitPart *             thePart,
            WitFlexVec <double> & scrapVolArg,
            WitFlexVec <double> & shadowPriceArg);
d151 2
a152 2
            WitMaterial *         theMat,
            WitFlexVec <double> & stockVolArg);
d155 3
a157 3
            WitDemand *           theDemand,
            WitFlexVec <double> & shipVolArg,
            WitFlexVec <double> & cumShipVolArg);
d160 2
a161 2
            WitOperation *        theOpn,
            WitFlexVec <double> & execVolArg);
d164 2
a165 2
            WitSubEntry *         theSub,
            WitFlexVec <double> & subVolArg);
d259 7
a265 7
      WitRefMap <WitPart,      WitFlexVec <double> > scrapVol_;
      WitRefMap <WitPart,      WitFlexVec <double> > shadowPrice_;
      WitRefMap <WitMaterial,  WitFlexVec <double> > stockVol_;
      WitRefMap <WitDemand,    WitFlexVec <double> > shipVol_;
      WitRefMap <WitDemand,    WitFlexVec <double> > cumShipVol_;
      WitRefMap <WitOperation, WitFlexVec <double> > execVol_;
      WitRefMap <WitSubEntry,  WitFlexVec <double> > subVol_;
@


1.35
log
@Double Precision.
@
text
@d147 2
a148 2
            WitRealVec &          scrapVolArg,
            WitRealVec &          shadowPriceArg);
d152 1
a152 1
            WitRealVec &          stockVolArg);
d157 1
a157 1
            WitRealVec  &         cumShipVolArg);
d259 3
a261 3
      WitRefMap <WitPart,      WitRealVec          > scrapVol_;
      WitRefMap <WitPart,      WitRealVec          > shadowPrice_;
      WitRefMap <WitMaterial,  WitRealVec          > stockVol_;
d263 1
a263 1
      WitRefMap <WitDemand,    WitRealVec          > cumShipVol_;
@


1.34
log
@Double Precision.
@
text
@d152 1
a152 1
            WitRealTVc &          stockVolArg);
d261 1
a261 1
      WitRefMap <WitMaterial,  WitRealTVc          > stockVol_;
@


1.33
log
@Double Precision.
@
text
@d152 1
a152 1
            WitRealVec &          stockVolArg);
d261 1
a261 1
      WitRefMap <WitMaterial,  WitRealVec          > stockVol_;
@


1.32
log
@Double Precision.
@
text
@d219 1
a219 1
      static float solnValue (const WitOptVar * theOptVar);
d348 1
a348 1
      WitSchedule <WitPart, float> potential_;
d350 4
a353 4
         // potential_(thePart)[t] is the estimated "potential for improvement"
         // that would result from increasing the supply of thePart in period
         // t. Specifically, it is the shadow price on the material balance
         // constraint for thePart in period t.
@


1.31
log
@Double Precision.
@
text
@d157 1
a157 1
            WitFlexVec <float>  & cumShipVolArg);
d263 1
a263 1
      WitRefMap <WitDemand,    WitFlexVec <float>  > cumShipVol_;
@


1.30
log
@Double Precision.
@
text
@d147 1
a147 1
            WitFlexVec <float>  & scrapVolArg,
d152 1
a152 1
            WitTVec    <float>  & stockVolArg);
d259 1
a259 1
      WitRefMap <WitPart,      WitFlexVec <float>  > scrapVol_;
d261 1
a261 1
      WitRefMap <WitMaterial,  WitTVec    <float>  > stockVol_;
@


1.29
log
@Continued double precision.
@
text
@d148 1
a148 1
            WitFlexVec <float>  & shadowPriceArg);
d260 1
a260 1
      WitRefMap <WitPart,      WitFlexVec <float>  > shadowPrice_;
@


1.28
log
@Continued double precision.
@
text
@d336 1
a336 1
         // The Implosion Math Programming model.
@


1.27
log
@Continued implementation of PIP.
@
text
@d53 2
a54 2
      accessFunc (float,             objValue)
      accessFunc (float,             boundsValue)
d112 1
a112 1
      void compObj1Values (float & primaryValue) const;
d117 4
a120 4
            float & revValue,
            float & invValue,
            float & servValue,
            float & subValue)
d278 2
a279 2
      float objValue_;
      float boundsValue_;
@


1.26
log
@Fixed a bug with the stopOpt parameter.
Fixed a timing bug.
@
text
@d168 1
a168 1
            WitList <WitDatedPart> & criticalListArg);
d230 2
a231 2
            WitDatedPart * partPeriod1,
            WitDatedPart * partPeriod2);
d267 1
a267 1
      WitRef    <WitList <WitDatedPart> >            criticalList_;
@


1.25
log
@Internal changes.
@
text
@d187 4
@


1.24
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d52 1
a52 1
      accessFunc (WitBoolean,        accelerated)
d58 5
a62 5
      accessFunc (WitBoolean,        printOptModel)
      accessFunc (WitBoolean,        printOslVecs)
      accessFunc (WitBoolean,        printInitSoln)
      accessFunc (WitBoolean,        printOptSoln)
      accessFunc (WitBoolean,        printMps)
d79 5
a83 5
      void setPrintOptModel (WitBoolean   theValue);
      void setPrintOslVecs  (WitBoolean   theValue);
      void setPrintInitSoln (WitBoolean   theValue);
      void setPrintOptSoln  (WitBoolean   theValue);
      void setPrintMps      (WitBoolean   theValue);
d96 1
a96 1
         // If accelerated () is TRUE, this OptImploder is restored to an
d125 1
a125 1
      WitBoolean boundsObjUsed () const;
d127 1
a127 1
         // Returns TRUE, iff the bounds objective was used.
d133 1
a133 1
      WitBoolean optImpMode () const;
d135 1
a135 1
         // Returns TRUE, iff OPT_IMPLODE is in effect.
d269 1
a269 1
      WitBoolean accelerated_;
d271 1
a271 1
         // TRUE, iff this OptImploder is eligible for an accelerated
d295 1
a295 1
      WitBoolean printOptModel_;
d299 1
a299 1
      WitBoolean printOslVecs_;
d303 1
a303 1
      WitBoolean printInitSoln_;
d307 1
a307 1
      WitBoolean printOptSoln_;
d311 1
a311 1
      WitBoolean printMps_;
@


1.23
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d69 3
d93 1
a93 1
      void unaccelerate ();
d95 1
d137 4
a186 4
      void validateOWLS ();
         //
         // Checks data validity for opt with lot sizes, if appropriate.

d231 16
d333 5
@


1.22
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d57 1
a57 1
      accessFunc (const WitString &, mpSolnOFName)
d84 1
a84 1
      void setOptSolnOFName (const char * theValue);
d267 1
a267 1
      WitString mpSolnOFName_;
d269 1
a269 1
         // Name of optimization solution output file.
@


1.21
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d58 1
a58 1
      accessFunc (WitBoolean,        printMpModel)
d61 1
a61 1
      accessFunc (WitBoolean,        printMpSoln)
d65 1
a65 1
      accessFunc (WitImpMp *,        myImpMp)
d76 1
a76 1
      void setPrintMpModel  (WitBoolean   theValue);
d79 1
a79 1
      void setPrintMpSoln   (WitBoolean   theValue);
d84 1
a84 1
      void setMpSolnOFName  (const char * theValue);
d105 2
a106 2
         // Sets the MP solution to the production and shipment schedules
         // and evaluates the objective functions for this solution.
d187 1
a187 1
      void setUpMpModel ();
d189 1
a189 1
         // Sets up myImpMp_
d191 1
a191 1
      void compInitMpSoln ();
d193 1
a193 1
         // Computes an initial solution to myImpMp_.
d211 1
a211 1
      static float solnValue (const WitMpVar * theMpVar);
d213 1
a213 1
         // Returns the positive part of the primal solution value of theMpVar,
d218 2
a219 1
         // Uses the dual solution from the MP to form the criticalList.
d265 1
a265 1
         // Name of initial MP solution output file.
d269 1
a269 1
         // Name of MP solution output file.
d275 1
a275 1
      WitBoolean printMpModel_;
d277 1
a277 1
         // Print the MP model.
d285 1
a285 1
         // Print the initial MP solution.
d287 1
a287 1
      WitBoolean printMpSoln_;
d289 1
a289 1
         // Print the final MP solution.
d297 2
a298 2
         // If > 0, have OSL print the MP solution and use this value for
         // iprtinfomask.
d303 1
a303 1
         // 1 --> stop after computing initial MP solution.
d310 1
a310 1
      WitImpMp * myImpMp_;
@


1.20
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d179 1
a179 1
      void validateLS ();
d181 1
a181 2
         // Verifies that the lot sizes are valid for optimizing implosion, as
         // appropriate.
@


1.19
log
@Continued implementation opt implosion with lot sizes.
@
text
@d57 2
a58 2
      accessFunc (const WitString &, lpSolnOFName)
      accessFunc (WitBoolean,        printLpModel)
d61 1
a61 1
      accessFunc (WitBoolean,        printLpSoln)
d65 1
a65 1
      accessFunc (WitImpLp *,        myImpLp)
d76 1
a76 1
      void setPrintLpModel  (WitBoolean   theValue);
d79 1
a79 1
      void setPrintLpSoln   (WitBoolean   theValue);
d84 1
a84 1
      void setLpSolnOFName  (const char * theValue);
d105 1
a105 1
         // Sets the LP solution to the production and shipment schedules
d188 1
a188 1
      void setUpLpModel ();
d190 1
a190 1
         // Sets up myImpLp_
d192 1
a192 1
      void compInitLpSoln ();
d194 1
a194 1
         // Computes an initial solution to myImpLp_.
d212 1
a212 1
      static float solnValue (const WitLpVar * theLpVar);
d214 1
a214 1
         // Returns the positive part of the primal solution value of theLpVar,
d219 1
a219 1
         // Uses the dual solution from the LP to form the criticalList.
d265 1
a265 1
         // Name of initial LP solution output file.
d267 1
a267 1
      WitString lpSolnOFName_;
d269 1
a269 1
         // Name of LP solution output file.
d275 1
a275 1
      WitBoolean printLpModel_;
d277 1
a277 1
         // Print the LP model.
d285 1
a285 1
         // Print the initial LP solution.
d287 1
a287 1
      WitBoolean printLpSoln_;
d289 1
a289 1
         // Print the final LP solution.
d297 1
a297 1
         // If > 0, have OSL print the LP solution and use this value for
d303 1
a303 1
         // 1 --> stop after computing initial LP solution.
d310 1
a310 1
      WitImpLp * myImpLp_;
d312 1
a312 1
         // The Implosion Linear Programming model.
@


1.18
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d179 5
@


1.17
log
@Fixed a CPU time problem in opt implosion with OSL V3.
@
text
@d16 1
a16 4
// Contains the declaration of the following classes:
//
// OptStarter
// OptImploder
d19 2
a20 6
#include <Global.h>
#include <Material.h>
#include <Opn.h>
#include <SubEntry.h>
#include <Demand.h>
#include <OptComp.h>
a25 105
// class OptStarter
//
// Responsible for determining the means by which an initial solution for opt
// implosion is to be generated.
//------------------------------------------------------------------------------

class WitOptStarter: public WitUtil
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitOptStarter (
            WitOptComp * theOptComp,
            const char * theParamValue,
            WitAttr      theApiAttr,
            WitMsgID     theMsgID,
            WitBoolean   externalVal);
         //
         // paramValue     <-- theParamValue.
         // myApiAttr_     <-- theApiAttr.
         // myMsgID_       <-- theMsgID.
         // external_      <-- externalVal.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitOptStarter ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitOptComp *,      myOptComp)
      accessFunc (const WitString &, paramValue)
      accessFunc (WitAttr,           myApiAttr)
      accessFunc (WitBoolean,        external)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void beChosen ();
         //
         // Sets myProblem ()->myOptComp ()->optInitMethod_ to this
         // OptStarter.

      WitBoolean isChosen () const;
         //
         // Returns TRUE, iff
         // this == myProblem ()->myOptComp ()->optInitMethod_ ().

      static const WitString & paramValue (const WitOptStarter * theOptStarter);
         //
         // Returns theOptStarter->paramValue ();

      void display () const;
         //
         // Issues myMsgID_.

      WitBoolean accConflict () const;
         //
         // Returns TRUE, iff this OptStarter needs accelerated mode, which is
         // not currently in effect.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitOptStarter);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitOptComp * const myOptComp_;
         //
         // The OptComp that owns this OptStarter.

      const WitString paramValue_;
         //
         // String identifying this OptStarter as a stand-alone control
         // parameter value.

      const WitAttr myApiAttr_;
         //
         // The API attribute for this OptStarter.

      WitMsgID const myMsgID_;
         //
         // The Msg ID of the informational message identifying this OptStarter.
         // This Msg will be issued at the beginning of opt implosion.

      const WitBoolean external_;
         //
         // TRUE, iff the initial solution for opt implosion is to generated
         // externally (i.e. from implosion schedules).
   };

//------------------------------------------------------------------------------
a320 14

//------------------------------------------------------------------------------
// Implementation of inlines that refer to class OptImploder.
//------------------------------------------------------------------------------

inline float WitObjFunc::objValue () const
   {
   return myOptImploder ()->objValue ();
   }

inline float WitObjFunc::boundsValue () const
   {
   return myOptImploder ()->boundsValue ();
   }
@


1.16
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d409 3
a411 2
         // 0 == normal.
         // 1 == stop after computing initial LP solution.
@


1.15
log
@Continued implementation of opt implosion with OSL V3.
@
text
@a206 4
      void closeFilesAtExit ();
         //
         // Closes files for an error exit.

a410 1
         // 2 == stop after dump MPS deck.
@


1.14
log
@Continued implementation of Single-Source.
@
text
@d174 1
a174 1
      accessFunc (WitBoolean,        dumpMps)
d192 1
a192 1
      void setDumpMps       (WitBoolean   theValue);
d402 1
a402 1
      WitBoolean dumpMps_;
d404 1
a404 1
         // Output an MPS deck.
@


1.13
log
@Continued implementation of Single-Source.
@
text
@a91 4
      static const char * myApiAttr (const WitOptStarter * theOptStarter);
         //
         // Returns theOptStarter->myApiAttr ();

@


1.12
log
@Continued implementation of single-source.
@
text
@d28 1
d434 1
a434 1
      WitSchedule <WitPart, float> & potential_;
@


1.11
log
@Preliminary work on single source.
@
text
@d28 2
a29 1
#include <AccFlag.h>
d167 14
a180 15
      accessFunc (const WitAccFlag *, myAccFlag)
      accessFunc (WitBoolean,         accelerated)
      accessFunc (float,              objValue)
      accessFunc (float,              boundsValue)
      accessFunc (const WitString &,  modelOFName)
      accessFunc (const WitString &,  initSolnOFName)
      accessFunc (const WitString &,  lpSolnOFName)
      accessFunc (WitBoolean,         printLpModel)
      accessFunc (WitBoolean,         printOslVecs)
      accessFunc (WitBoolean,         printInitSoln)
      accessFunc (WitBoolean,         printLpSoln)
      accessFunc (WitBoolean,         dumpMps)
      accessFunc (int,                printMask)
      accessFunc (int,                stopOpt)
      accessFunc (WitImpLp *,         myImpLp)
a251 2
   private:

d253 1
a253 1
      // Private member functions.
d256 24
a279 3
      //------------------------------------------------------------------------
      // Component data access functions.
      //------------------------------------------------------------------------
d281 1
a281 8
      refAccess (WitGlobalComp, WitList    <WitDatedPart>, criticalList)
      refAccess (WitPart,       WitFlexVec <float>,        scrapVol)
      refAccess (WitPart,       WitFlexVec <float>,        shadowPrice)
      refAccess (WitMaterial,   WitTVec    <float>,        stockVol)
      refAccess (WitDemand,     WitFlexVec <double>,       shipVol)
      refAccess (WitDemand,     WitFlexVec <float>,        cumShipVol)
      refAccess (WitOperation,  WitFlexVec <double>,       execVol)
      refAccess (WitSubEntry,   WitFlexVec <double>,       subVol)
d284 1
a284 1
      // Other private member functions.
d314 8
d345 17
a361 3
      WitAccFlag * const myAccFlag_;
         //
         // The AccFlag for this OptImploder.
@


1.10
log
@Continued preliminary work on single source.
@
text
@d263 2
a264 2
      refAccess (WitPart,       WitFlexVec (float),        scrapVol)
      refAccess (WitPart,       WitFlexVec (float),        shadowPrice)
d266 4
a269 4
      refAccess (WitDemand,     WitFlexVec (double),       shipVol)
      refAccess (WitDemand,     WitFlexVec (float),        cumShipVol)
      refAccess (WitOperation,  WitFlexVec (double),       execVol)
      refAccess (WitSubEntry,   WitFlexVec (double),       subVol)
@


1.9
log
@Continued preliminary work on single source.
@
text
@a29 2
class WitSchedule (WitPart, float);

d394 6
a399 1
      static WitSchedule (WitPart, float) potential_;
@


1.8
log
@Preliminary work on single source.
@
text
@d267 1
a267 1
      refAccess (WitMaterial,   WitTVec    (float),        stockVol)
@


1.7
log
@Began implementation of object iteration.
@
text
@d264 8
a271 8
      refAccess (WitGlobalComp, WitList (WitDatedPart), criticalList)
      refAccess (WitPart,       WitFlexVec (float),     scrapVol)
      refAccess (WitPart,       WitFlexVec (float),     shadowPrice)
      refAccess (WitMaterial,   WitTVec    (float),     stockVol)
      refAccess (WitDemand,     WitFlexVec (double),    shipVol)
      refAccess (WitDemand,     WitFlexVec (float),     cumShipVol)
      refAccess (WitOperation,  WitFlexVec (double),    execVol)
      refAccess (WitSubEntry,   WitFlexVec (double),    subVol)
@


1.6
log
@Added shadowPrice and compPrices attributes.
@
text
@d22 4
@


1.5
log
@Refactoring for selection splitting.
@
text
@d262 2
a263 1
      refAccess (WitMaterial,   WitTVec (float),        stockVol)
@


1.4
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d107 1
a107 3
      copyCtorAndAssignment (WitOptStarter);
         //
         // Prevents unintentional copying and assignment.
d272 1
a272 3
      copyCtorAndAssignment (WitOptImploder);
         //
         // Prevents unintentional copying and assignment.
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d265 1
a265 1
      refAccess (WitDemand,     WitTVec (float),        shipVol)
d267 2
a268 2
      refAccess (WitOperation,  WitTVec (float),        execVol)
      refAccess (WitSubEntry,   WitTVec (float),        subVol)
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d35 1
a35 1
class WitOptStarter
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.102;
access;
symbols
	sce_5_01_20080919:1.85
	latest_sce_4_20_20060523:1.46.0.2
	sce_4_20_20060523:1.46
	latest_sce4_20_OSL:1.45.0.2
	sce_4_20_OSL:1.45
	sce_410_withVa:1.43
	sce_4_05_20040511:1.41
	sce_4_00_20040201:1.30
	nextGenBranch:1.29.0.2
	nextGenRoot:1.29
	sce_3_30_20030627:1.29
	EndRw-branch:1.23.0.4
	Root-of-EndRw:1.23
	rwToStl:1.23.0.2
	latest_sce_3_10_20010924:1.6.0.6
	sce_3_10_20010924:1.6
	latest_sce_3_00_20010601:1.6.0.4
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.102
date	2010.09.10.22.10.39;	author rjw;	state dead;
branches;
next	1.101;

1.101
date	2010.01.06.20.42.40;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.01.06.20.10.32;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2009.12.30.20.02.27;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2009.12.30.18.46.37;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2009.12.30.18.30.37;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2009.12.29.22.53.17;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2009.12.29.19.39.05;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.29.16.33.45;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.28.23.07.44;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2009.12.25.00.10.47;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2009.12.24.22.58.56;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2009.12.23.22.39.55;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2009.12.22.23.44.52;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2009.12.21.23.09.55;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2009.12.21.20.35.47;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.13.19.01.25;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.25.16.36.34;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.22.21.36.10;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.12.11.22.00.28;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.15.17.15.34;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.14.17.18.54;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.13.23.02.17;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.13.20.17.39;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.12.20.27.37;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.09.00.40.47;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.10.15.21.50.35;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.10.02.18.32.43;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.09.28.22.08.26;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.09.11.18.09.17;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.06.08.18.09.40;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.05.21.06.01;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.05.16.15.24;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.30.16.01.19;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.25.18.39.11;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.24.18.52.22;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.22.15.46.52;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.14.19.05.39;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.14.16.18.39;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.11.20.43.56;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.10.21.58.11;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.10.21.14.41;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.10.17.22.14;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.04.23.27.11;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.26.20.45.30;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.03.22.04.04;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.28.20.04.58;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.27.22.59.30;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.08.22.47.35;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.15.22.25.30;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.15.21.15.15;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.10.12.20.48.10;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.17.22.50.37;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.16.15.49.18;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.02.17.34.05;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.15.21.27.23;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.13.16.48.47;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.24.23.23.56;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.09.21.24.27;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.02.23.45.20;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.01.21.05.12;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.31.22.56.08;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.05.22.19.58;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.05.00.06.54;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.11.18.29.13;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.19.16.48.22;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.13.23.06.30;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.23.19.13.21;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.08.19.22.37;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.02.22.18.38;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.30.20.37.27;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.10.19.21.16;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.09.18.42.12;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.07.21.46.37;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.04.21.26.28;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.30.21.36.37;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.05.19.31.34;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.04.23.07.22;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.03.22.35.20;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.03.16.01.50;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.14.32.40;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.28.19.44.57;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.19.21.53;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.03.23.16.39;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.01.14.25.58;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.25.19.14.51;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.22.14.32.10;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.14.02.38;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.22.23.11.45;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.25;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.12.33;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.21.22.45;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.29;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches;
next	;


desc
@@


1.102
log
@Heuristic Adjustment
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

#ifndef OpnH
#define OpnH

//------------------------------------------------------------------------------
// Header file: "Opn.h"
//
// Contains the declaration of class Operation.
//
// Class Hierarchy:
//
// ProbAssoc
//    Component
//       DelComp
//          Node
//             Operation
//------------------------------------------------------------------------------

#include <Node.h>
#include <FlexVec.h>
#include <ObjVec.h>

//------------------------------------------------------------------------------
// Class Operation.
//------------------------------------------------------------------------------

class WitOperation: public WitNode
   {
   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitOperation (const char * theName, WitCompMgr * theCompMgr);
         //
         // Node <<< theName.
         // Node <<< theCompMgr.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitOperation ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const WitList <WitBomEntry> &, bom)
      accessFunc (const WitList <WitBopEntry> &, bop)
      accessFunc (const WitDblFlexVec &,         yieldRate)
      accessFunc (const WitDblFlexVec &,         minLotSize)
      accessFunc (const WitDblFlexVec &,         incLotSize)
      accessFunc (bool,                          twoLevelLotSizes)
      accessFunc (const WitDblFlexVec &,         lotSize2Thresh)
      accessFunc (const WitDblFlexVec &,         minLotSize2)
      accessFunc (const WitDblFlexVec &,         incLotSize2)
      accessFunc (double,                        execPenalty)
      accessFunc (bool,                          intExecVols)
      accessFunc (const WitDblFlexVec &,         execVol)
      accessFunc (WitBoundSet *,                 execBounds)
      accessFunc (const WitTVec <bool> &,        executable)
      accessFunc (const WitDblFlexVec &,         mrpExecVol)
      accessFunc (const WitDblFlexVec &,         fssExecVol)

      inline const WitDblFlexVec & execCost () const
         {
         return execCost_.curDblFlexVec ();
         }

      inline const WitString & operationName () const
         {
         return nodeName ();
         }

      inline const WitDblFlexVec & cycleTime34 () const
         {
         witAssert (wit34Compatible ());

         return cycleTime34_;
         }

      //------------------------------------------------------------------------
      // Mapping functions
      //------------------------------------------------------------------------

      decMappingIndex (WitOperation)

      static int nInstances (WitProblem *);

      //------------------------------------------------------------------------
      // Default value functions.
      //------------------------------------------------------------------------

      defaultValue (double defYieldRate,        1.0)
      defaultValue (double defMinLotSize,       0.0)
      defaultValue (double defIncLotSize,       0.0)
      defaultValue (bool   defTwoLevelLotSizes, false)
      defaultValue (double defLotSize2Thresh,   0.0)
      defaultValue (double defMinLotSize2,      0.0)
      defaultValue (double defIncLotSize2,      0.0)
      defaultValue (double defExecPenalty,      0.0)
      defaultValue (double defExecCost,         0.0)
      defaultValue (bool   defIntExecVols,      false)
      defaultValue (double defCycleTime34,      0.0)
      defaultValue (double defExecVol,          0.0)

      defaultValue (int    defYield,          100) 
         //
         // Used only by readData.

      //------------------------------------------------------------------------
      // "Set" functions.
      //------------------------------------------------------------------------

      void setOperationName    (const char *);
      void setYieldRate        (const WitIVRealArg &);
      void setMinLotSize       (const WitIVRealArg &);
      void setIncLotSize       (const WitIVRealArg &);
      void setTwoLevelLotSizes (bool);
      void setLotSize2Thresh   (const WitIVRealArg &);
      void setMinLotSize2      (const WitIVRealArg &);
      void setIncLotSize2      (const WitIVRealArg &);
      void setExecPenalty      (double);
      void setExecCost         (const WitIVRealArg &);
      void setIntExecVols      (bool);
      void setExecVol          (const WitIVRealArg &);
      void setCycleTime34      (const WitIVRealArg &);

      //------------------------------------------------------------------------
      // store<Activity><Attr> functions.
      // Each of these functions sets the value of indicated attribute to the
      // value of the argument.
      // Each function is only valid when the indicated activity is being
      // performed.
      //------------------------------------------------------------------------

      void storePreExecutable (WitPeriod, bool);
         //
         // Valid only when preprocessing is being performed.

      void storeHeurExecVol (WitPeriod, double);
         //
         // Valid only when heuristic allocation is updating the solution.

      void storeOptExecVol (WitPeriod, double);
         //
         // Valid only when the optimizing implosion subsystem is uploading the
         // solution.

      void storeStochExecCost (const WitDblFlexVec &);
      void storeStochExecVol  (const WitDblFlexVec &);
         //
         // Valid only when the stochastic implosion subsystem is uploading
         // data.

      void storeMrpMrpExecVol (const WitTVec <double> &);
         //
         // Valid only when the MRP subsystem is uploading the MRP solution.

      void storeFssFssExecVol (const WitTVec <double> &);
         //
         // Valid only when the FSS subsystem is uploading the FSS solution.

      //------------------------------------------------------------------------
      // Insert functions.
      // Each of these functions does an appendUniquely on the argument for the
      // appropriate List.
      //------------------------------------------------------------------------

      void insert (WitBomEntry *);
      void insert (WitBopEntry *);

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual bool           inserted          ();
      virtual void           writeMultiObjVecs (WitObjective *);
      virtual void           writeSolnData     ();
      virtual void           copySelfInto      (WitCompMgr * theCompMgr);
      virtual void           recount           ();
      virtual void           unpreprocess      ();
      virtual void           clearOptSoln      ();
      virtual void           clearStochSoln    ();
      virtual WitOperation * thisOpn           ();
         //
         // Overrides from class Component.

      virtual void       identifyInstance ();
      virtual void       writeSetClause   ();
      virtual WitMsgFrag objTypeMsgFrag   ();
      virtual WitAttr    apiObjItrState   ();
         //
         // Overrides from class DelComp.

      virtual int nodeIndex () const;
         //
         // Override from class Node.

      inline static WitOperation * key (WitListItr & theItr)
         {
         return reinterpret_cast <WitOperation *> (theItr.key ());
         }
         //
         // Used by forEach<object> macros.

      static bool validYieldRate (double theValue);
         //
         // Returns true, iff theValue is valid as a yieldRate.

      bool cycleTime34PreventsExec (WitPeriod t);
         //
         // Returns true, iff cycleTime34 is such has to prevent execution of
         // this operation in period t.
         // Requires that wit34Compatible is true.

      void setWit34Compatible (bool newValue);
         //
         // Makes the changes to this Operation appropriate to a change in the
         // value of wit34Compatible to newValue.

      void copyAttrsFrom (WitOperation * theOpn);
         //
         // Copies the input attributes of theOpn into this Operation.

      bool isCoproducing (WitPeriod execPer);
         //
         // Return true, iff this Operation is coproducing in execPer.
         // For more info, see Part::coproduced_.

      void display ();
         //
         // Displays the input and preprocessing data for this Operation.

      void clearExecVolForHeur ();
         //
         // Clears execVol_.
         // Valid only when heuristic allocation is updating the solution.

      double lotSizeDelta (
            WitPeriod thePer,
            double    theExecVol,
            double    delta,
            bool      useTol);
         //
         // Returns delta, adjusted so that theExecVol + delta is lot-size 
         // feasible. See lotSizeGridPoint for meaning of useTol.

      void writeSoln ();
         //
         // Prints the comprehensive implosion solution for this Operation.

      void writeMrpSoln ();
         //
         // Prints the comprehensive MRP solution for this Operation.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitOperation);

      virtual WitBoundSet * myBoundSet         ();
      virtual void          writeDataID        ();
      virtual void          writeDataAttrs     ();
      virtual void          purgeCompListsSpec ();
      virtual void          clearDepListsSpec  ();
         //
         // Overrides from class Component.

      bool lotSizeMode (WitPeriod thePer);
         //
         // Returns true, iff lot sizing is to be done for this Operation in
         // period thePer.

      double tllsExecVol (WitPeriod thePer, double theExecVol, bool useTol);
         //
         // Returns the lowest amount >= theExecVol that's lot-size feasible
         // with respect to two-level lot sizes.
         // A tolerance will be used iff useTol is true.

      double lotSizedExecVol (
            WitPeriod             thePer,
            double                theExecVol,
            const WitDblFlexVec & mlsVec,
            const WitDblFlexVec & ilsVec,
            bool                  useTol);
         //
         // Returns the lowest amount >= theExecVol that's lot-size feasible
         // with respect to mls & ils.
         // A tolerance will be used iff useTol is true.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Data maintained by myCompMgr ().
      //------------------------------------------------------------------------

      int mappingIndex_;
         //
         // Mapping index: see Mapping.h.
         // == # Operations constructed before this Operation.

      WitList <WitBomEntry> bom_;
         //
         // Bill Of Manufacturing stored as list of BomEntries.

      WitList <WitBopEntry> bop_;
         //
         // Bill Of Products stored as list of BopEntries.

      //------------------------------------------------------------------------
      // Input data.
      //------------------------------------------------------------------------

      WitDblFlexVec yieldRate_;
         //
         // yieldRate_[thePer] is the yield incurred when executing this
         //    Operation in thePer.
         // If yieldRate_[thePer] == 0.0, then execution is prohibited in 
         //    thePer.
         // Range: [0.01, 1.00] union {0.0}.

      WitDblFlexVec minLotSize_;
         //
         // minLotSize ()[thePer] is the minimum allowable value of
         // execVol ()[thePer], if execVol ()[thePer] > 0.0.
         // Range: [0.0, +inf).

      WitDblFlexVec incLotSize_;
         //
         // If execVol ()[thePer] > 0.0, then 
         // execVol ()[thePer] - minLotSize_[thePer]
         // will be a multiple of incLotSize ()[thePer].
         // Range: [0.0, +inf).

      bool twoLevelLotSizes_;
         //
         // true, iff two-level lot sizes are to be used for this Operation.

      WitDblFlexVec lotSize2Thresh_;
         //
         // If lotSize2Thresh_[thePer] <  0.0: minLotSize and incLotSize apply.
         // If lotSize2Thresh_[thePer] >= 0.0:
         //    If execVol_[thePer] <  lotSize2Thresh_[thePer]:
         //       minLotSize and incLotSize apply.
         //    If execVol_[thePer] >= lotSize2Thresh_[thePer]:
         //       minLotSize2 and incLotSize2 apply.
         // Range: [0.0, +inf).

      WitDblFlexVec minLotSize2_;
         //
         // Same as minLotSize, but applies when 
         // 0.0 < lotSize2Thresh_[thePer] <= execVol_[thePer]
         // Range: [0.0, +inf).

      WitDblFlexVec incLotSize2_;
         //
         // Same as incLotSize, but applies when 
         // 0.0 < lotSize2Thresh_[thePer] <= execVol_[thePer]
         // Range: [0.0, +inf).

      double execPenalty_;
         //
         // If heuristic implosion / allocation is using the penalized 
         // execution technique, execPenalty_ is the penalty that the heuristic
         // will apply to executing this Operation.
         // Range: [0.0, +inf).

      WitObjVec execCost_;
         //
         // Stores the cost coefficients of the execution variables for this
         // Operation.
         // Range: (-inf, +inf).

      bool intExecVols_;
         //
         // If true, then in optimizing implosion, execVol_ will be constrained
         // to take on integer values in all periods.

      WitDblFlexVec cycleTime34_;
         //
         // Production cycle time, expressed as a
         // function of execution (completion) period.
         // Only allocated in wit34Compatible mode.
         // Range: (-inf, +inf).

      WitDblFlexVec execVol_;
         //
         // execVol_[thePer] is the execution volume in period thePer
         //    (for implosion).
         // Normally, this is set by implosion, but it can also be set as
         // input.
         // Range: [0.0, +inf).

      WitBoundSet * execBounds_;
         //
         // Bounds on execution volumes.

      //------------------------------------------------------------------------
      // Data set by general preprocessing
      //------------------------------------------------------------------------

      WitTVec <bool> executable_;
         //
         // executable_[t] is true iff this Operation can be executed in
         // period t.

      //------------------------------------------------------------------------
      // Data set by mrp
      //------------------------------------------------------------------------

      WitDblFlexVec mrpExecVol_;
         //
         // mrpExecVol_[thePer] is the execution volume in thePer, as computed
         // by MRP.

      //------------------------------------------------------------------------
      // Data set by FSS.
      //------------------------------------------------------------------------

      WitDblFlexVec fssExecVol_;
         //
         // fssExecVol_[thePer] is the execution volume in thePer, as computed
         // by FSS.
   };

#endif
@


1.101
log
@Multi-objective mode
@
text
@@


1.100
log
@Multi-objective mode
@
text
@d81 1
a81 1
         return execCostObjVec_.curDblFlexVec ();
d388 1
a388 1
      WitObjVec execCostObjVec_;
@


1.99
log
@Multi-Objective Mode
@
text
@a71 1
      accessFunc (const WitObjVec &,             execCostObjVec)
@


1.98
log
@Multi-Objective Mode
@
text
@d72 1
@


1.97
log
@Multi-Objective Mode
@
text
@d390 1
a390 1
         // Stores the cost coefficients for the execution variables for this
@


1.96
log
@Multi-Objective Mode
@
text
@d81 1
a81 1
         return execCost_.curDblFlexVec ();
d388 1
a388 1
      WitObjVec execCost_;
d390 2
a391 2
         // execCost ()[thePer] is the cost coef. on the execution variable on
         // for this Operation in thePer for the current objective.
@


1.95
log
@Multi-Objective Mode
@
text
@a71 1
      accessFunc (const WitDblFlexVec &,         execCost)
d79 5
@


1.94
log
@Multi-Objective Mode
@
text
@d72 1
a91 5
      inline const WitDblFlexVec & execCost () const
         {
         return execCost_.curDblFlexVec ();
         }

d386 2
a387 3
         // execCost_.curDblFlexVec ()[thePer] is the cost coef. on the
         // execution variable on for this Operation in thePer for the current
         // objective.
@


1.93
log
@Multi-Objective Mode
@
text
@d93 1
a93 1
         return execCost_->curDblFlexVec ();
d388 1
a388 1
      WitObjVec * execCost_;
d390 1
a390 1
         // execCost_->curDblFlexVec ()[thePer] is the cost coef. on the
@


1.92
log
@Multi-Objective Mode
@
text
@d191 9
a199 9
      virtual void           copySelfInto     (WitCompMgr * theCompMgr);
      virtual void           recount          ();
      virtual void           unpreprocess     ();
      virtual void           clearOptSoln     ();
      virtual void           clearStochSoln   ();
      virtual WitOperation * thisOpn          ();
      virtual bool           inserted         ();
      virtual void           identifyInstance ();
      virtual void           writeSetClause   ();
d203 4
a206 2
      virtual WitMsgFrag objTypeMsgFrag ();
      virtual WitAttr    apiObjItrState ();
d208 1
a208 1
         // Override from class DelComp.
a244 5
      virtual void writeObjVecs  (WitObjective *);
      virtual void writeSolnData ();
         //
         // Overrides from class Component.

@


1.91
log
@Multi-Objective Mode
@
text
@d199 1
@


1.90
log
@Multi-Objective Mode
@
text
@d242 1
d245 1
a245 2
         // Override from class Component.
         // Writes the section of the solution data file for this Operation.
@


1.89
log
@Multi-Objective Mode
@
text
@d93 1
a93 1
         return execCostObjVec_->curDblFlexVec ();
d390 1
a390 1
      WitObjVec * execCostObjVec_;
d392 2
a393 2
         // execCostObjVec_->curDblFlexVec ()[thePer] is the cost coef. on the
         // execuction variable on for this Operation in thePer for the current
@


1.88
log
@Multi-Objective Mode
@
text
@d93 1
a93 1
         return execCostObjVec_.curDblFlexVec ();
d390 1
a390 1
      WitObjVec & execCostObjVec_;
d392 1
a392 1
         // execCostObjVec_.curDblFlexVec ()[thePer] is the cost coef. on the
@


1.87
log
@Removed some references to objective #1.
@
text
@d29 1
a71 1
      accessFunc (const WitDblFlexVec &,         execCost)
d91 5
d390 1
a390 1
      WitDblFlexVec execCost_;
d392 3
a394 2
         // execCost_[thePer] is the cost coef. on the execuction variable on
         // for this Operation in thePer.
@


1.86
log
@Removing objective #2.
@
text
@d387 2
a388 3
         // If objective #1 is being used, then execCost_[thePer] is the
         // user-specified cost coef. on the production variable on for this
         // Operation in thePer.
@


1.85
log
@Object name change.
@
text
@a70 1
      accessFunc (double,                        obj2AuxCost)
a110 1
      defaultValue (double defObj2AuxCost,      0.0)
a132 1
      void setObj2AuxCost      (double);
a384 8
      double obj2AuxCost_;
         //
         // If objective #2 is being used, then obj2AuxCost_ is the auxiliary
         // cost of executing this operation, i.e., the per-unit cost of
         // executing this operation that is not otherwise reflected in the
         // unitCosts of its inputs and outputs.
         // Range: [0.0, +inf).

@


1.84
log
@Object name changing.
@
text
@d126 1
@


1.83
log
@Stochastic Implosion
@
text
@d278 5
a282 1
      virtual WitBoundSet * myBoundSet ();
d284 1
a284 17
         // Override from class Component.

      virtual void writeDataID ();
         //
         // Override from class Component.

      virtual void writeDataAttrs ();
         //
         // Override from class Component.

      virtual void purgeCompListsSpec ();
         //
         // Override from class Component.

      virtual void clearDepListsSpec ();
         //
         // Override from class Component.
@


1.82
log
@Stochastic Implosion
@
text
@d161 2
a162 1
      void storeStochExecVol (const WitDblFlexVec &);
@


1.81
log
@Stochastic Implosion
@
text
@d148 4
a188 1
      virtual void           passPreRefs      ();
@


1.80
log
@Stochastic Implosion
@
text
@d166 4
a187 1
      virtual void           passFssRefs      ();
@


1.79
log
@Stochastic Implosion
@
text
@d162 4
a183 1
      virtual void           passMrpRefs      ();
@


1.78
log
@Stochastic Implosion
@
text
@d152 5
d179 1
a179 1
      virtual void           importOptSoln    ();
@


1.77
log
@Stochastic Implosion
@
text
@a35 2
      friend class WitHeurAccess;

@


1.76
log
@Stochastic Implosion
@
text
@d143 1
a143 1
      // storeStoch<Attr> functions.
d146 2
a147 1
      // Valid only when the stochastic implosion subsystem is uploading data.
d150 4
d155 3
d235 5
@


1.75
log
@Stochastic Implosion
@
text
@d171 1
@


1.74
log
@Stochastic Implosion
@
text
@d149 1
a149 1
      void storeStochExecVol (const WitTVec <double> &);
@


1.73
log
@Stochastic Implosion
@
text
@d251 1
a251 1
      virtual WitBoundSet * myBoundSetForUpdate ();
@


1.72
log
@Stochastic Implosion
@
text
@d143 1
a143 1
      // loadInStoch<Attr> functions.
d149 1
a149 1
      void loadInStochExecVol (const WitTVec <double> &);
@


1.71
log
@Stochastic Implosion
@
text
@d143 9
a168 1
      virtual void           importStochSoln  ();
@


1.70
log
@Stochastic Implosion
@
text
@d159 2
a160 1
      virtual void           acquireOptSoln   ();
a162 1
      virtual void           passStochRefs    ();
@


1.69
log
@Stochastic Implosion
@
text
@a157 1
      virtual void           importPreData    ();
@


1.68
log
@Stochastic Implosion
@
text
@d157 1
@


1.67
log
@Stochastic Implosion
@
text
@a35 1
      friend class WitPreAccess;
d157 1
a203 5
      bool hasBomEntryInEffect (WitPeriod t);
         //
         // Returns true, iff this Operation has at least one BomEntry in
         // effect in period t.

a208 5
      bool hasNegRateConsEntry (WitPeriod thePer);
         //
         // Returns true, iff this Operation has at least one ConsEntry in
         // effect in thePer whose effConsRate is negative.

@


1.66
log
@Stochastic Implosion
@
text
@d159 1
a159 1
      virtual void           importOptImpSoln (WitPeriod);
@


1.65
log
@Stochastic Implosion
@
text
@d160 3
a162 3
      virtual void           passMrpData      ();
      virtual void           passFssData      ();
      virtual void           passStochData    ();
@


1.64
log
@Stochastic Implosion
@
text
@d162 1
a162 2
      virtual void           clearStochSoln   ();
      virtual void           restoreStochSoln ();
@


1.63
log
@Stochastic Implosion
@
text
@d160 1
a160 1
      virtual void           importMrpSoln    ();
@


1.62
log
@Stochastic Implosion
@
text
@a37 1
      friend class WitFssAccess;
d161 1
@


1.61
log
@Stochastic Implosion
@
text
@a37 1
      friend class WitMrpAccess;
d161 1
@


1.60
log
@Stochastic Implosion
@
text
@d158 9
a166 1
      virtual bool inserted ();
d168 1
a168 5
         // Override from class Component.

      virtual void identifyInstance ();
         //
         // Override from class Component.
d171 1
a171 4
         //
         // Override from class DelComp.

      virtual WitAttr apiObjItrState ();
a200 10
      virtual void           copySelfInto     (WitCompMgr * theCompMgr);
      virtual void           recount          ();
      virtual void           unpreprocess     ();
      virtual void           importOptImpSoln (WitPeriod);
      virtual void           clearStochSoln   ();
      virtual void           restoreStochSoln ();
      virtual WitOperation * thisOpn          ();
         //
         // Overrides from class Component.

@


1.59
log
@Stochastic Implosion
@
text
@a37 1
      friend class WitOptAccess;
@


1.58
log
@Stochastic Implosion
@
text
@d204 1
@


1.57
log
@Stochastic Implosion
@
text
@a38 1
      friend class WitStochAccess;
d201 6
a206 4
      virtual void           copySelfInto (WitCompMgr * theCompMgr);
      virtual void           recount      ();
      virtual void           unpreprocess ();
      virtual WitOperation * thisOpn      ();
@


1.56
log
@Stochastic Implosion.
@
text
@d39 1
@


1.55
log
@[disallowed backlog]
@
text
@d163 1
a163 1
      virtual WitMsgFragID classFragID ();
d167 1
a167 1
      virtual void identifyInstance ();
d169 1
a169 1
         // Override from class Component.
@


1.54
log
@[disallowed backlog]
@
text
@d37 4
a252 4
      static void transmitDMPs ();
         //
         // See comment on transmitAllDMPs in CompMgr.h.

@


1.53
log
@Rescinded all changed made since 1/31/07.
@
text
@d36 2
@


1.52
log
@[disallowed backlog]
@
text
@a28 1
#include <Restricted.h>
a60 5
      accessFunc (const WitTVec <bool> &,        executable)
      accessFunc (const WitDblFlexVec &,         execVol)
      accessFunc (const WitDblFlexVec &,         mrpExecVol)
      accessFunc (const WitDblFlexVec &,         fssExecVol)

d74 1
d76 3
d197 1
d247 1
a247 5
      //------------------------------------------------------------------------
      // Restricted public member data.
      //------------------------------------------------------------------------

      WitPreRestricted <WitTVec <bool> > executable_;
d249 1
a249 20
         // executable_[thePer] is true iff this Operation can be executed in
         // period thePer.

      WitImpRestricted <WitDblFlexVec> execVol_;
         //
         // execVol_[thePer] is the execution volume in period thePer
         //    (for implosion).
         // Normally, this is set by implosion, but it can also be set as
         // input.
         // Range: [0.0, +inf).

      WitMrpRestricted <WitDblFlexVec> mrpExecVol_;
         //
         // mrpExecVol_[thePer] is the execution volume in thePer, as computed
         // by MRP.

      WitFssRestricted <WitDblFlexVec> fssExecVol_;
         //
         // fssExecVol_[thePer] is the execution volume in thePer, as computed
         // by FSS.
d407 8
d418 27
@


1.51
log
@witCopy<Object>Data
@
text
@d29 1
d62 5
a79 1
      accessFunc (const WitDblFlexVec &,         execVol)
a80 3
      accessFunc (const WitTVec <bool> &,        executable)
      accessFunc (const WitDblFlexVec &,         mrpExecVol)
      accessFunc (const WitDblFlexVec &,         fssExecVol)
a198 1
      virtual void           unpreprocess ();
d248 5
a252 1
      static void transmitDMPs ();
d254 20
a273 1
         // See comment on transmitAllDMPs in CompMgr.h.
a430 8
      WitDblFlexVec execVol_;
         //
         // execVol_[thePer] is the execution volume in period thePer
         //    (for implosion).
         // Normally, this is set by implosion, but it can also be set as
         // input.
         // Range: [0.0, +inf).

a433 27

      //------------------------------------------------------------------------
      // Data set by general preprocessing
      //------------------------------------------------------------------------

      WitTVec <bool> executable_;
         //
         // executable_[t] is true iff this Operation can be executed in
         // period t.

      //------------------------------------------------------------------------
      // Data set by mrp
      //------------------------------------------------------------------------

      WitDblFlexVec mrpExecVol_;
         //
         // mrpExecVol_[thePer] is the execution volume in thePer, as computed
         // by MRP.

      //------------------------------------------------------------------------
      // Data set by FSS.
      //------------------------------------------------------------------------

      WitDblFlexVec fssExecVol_;
         //
         // fssExecVol_[thePer] is the execution volume in thePer, as computed
         // by FSS.
@


1.50
log
@witCopy<Object>Data.
@
text
@d202 4
a238 4
      void copyAttrsFrom (WitOperation * theOpn);
         //
         // Copies the input attributes of theOpn into this Operation.

@


1.49
log
@External opt implosion.
@
text
@d235 4
a270 4
      void copyAttrsFrom (WitOperation * theOpn);
         //
         // Copies the input attributes of theOpn into this Operation.

@


1.48
log
@Integrality constraints.
@
text
@d73 1
a73 1
      accessFunc (bool,                          intConExecVols)
d114 1
a114 1
      defaultValue (bool   defIntConExecVols,   false)
d136 1
a136 1
      void setIntConExecVols   (bool);
d395 1
a395 1
      bool intConExecVols_;
@


1.47
log
@Opt implosion with integrality constraints.
@
text
@d73 1
a73 1
      accessFunc (bool,                          intExecVols)
d114 1
a114 1
      defaultValue (bool   defIntExecVols,      false)
d136 1
a136 1
      void setIntExecVols      (bool);
d395 1
a395 1
      bool intExecVols_;
@


1.46
log
@Updated the copyright date on all source files.
@
text
@d73 1
d114 1
d136 1
d395 5
@


1.45
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.44
log
@[multi-thread]
@
text
@d172 1
a172 1
         return fromTlObj_cast <WitOperation> (theItr.key ());
@


1.43
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@a195 5
      virtual void           loadPre      ();
      virtual void           loadMrp      ();
      virtual void           loadFss      ();
      virtual void           loadHeur     ();
      virtual void           loadOpt      ();
d240 4
@


1.42
log
@Vector PropRt.
@
text
@d72 1
a72 1
      accessFunc (const WitDblFlexVec &,         obj1ExecCost)
d112 1
a112 1
      defaultValue (double defObj1ExecCost,     0.0)
d133 1
a133 1
      void setObj1ExecCost     (const WitIVRealArg &);
d386 1
a386 1
      WitDblFlexVec obj1ExecCost_;
d388 1
a388 1
         // If objective #1 is being used, then obj1ExecCost_[thePer] is the
@


1.41
log
@Double Precision.
@
text
@d124 3
a126 3
      void setYieldRate        (const WitInVecRA &);
      void setMinLotSize       (const WitInVecRA &);
      void setIncLotSize       (const WitInVecRA &);
d128 3
a130 3
      void setLotSize2Thresh   (const WitInVecRA &);
      void setMinLotSize2      (const WitInVecRA &);
      void setIncLotSize2      (const WitInVecRA &);
d133 3
a135 3
      void setObj1ExecCost     (const WitInVecRA &);
      void setExecVol          (const WitInVecRA &);
      void setCycleTime34      (const WitInVecRA &);
@


1.40
log
@Double Precision.
@
text
@d135 1
a135 1
      void setCycleTime34      (const float *);
@


1.39
log
@Double Precision.
@
text
@d135 1
a135 1
      void setCycleTime34      (const WitInVecRA &);
@


1.38
log
@Double Precision.
@
text
@a123 1
      void setYieldRate        (const float *);
a124 1
      void setMinLotSize       (const float *);
a125 1
      void setIncLotSize       (const float *);
a127 1
      void setLotSize2Thresh   (const float *);
a128 1
      void setMinLotSize2      (const float *);
a129 1
      void setIncLotSize2      (const float *);
a132 1
      void setObj1ExecCost     (const float *);
a134 1
      void setCycleTime34      (const float *);
@


1.37
log
@Double Precision.
@
text
@d125 1
d127 1
d129 1
d132 1
d134 1
d136 1
d140 2
a141 1
      void setExecVol          (const float *);
d143 1
@


1.36
log
@Double Precision.
@
text
@d63 3
a65 3
      accessFunc (const WitFlexVec <double> &,   yieldRate)
      accessFunc (const WitFlexVec <double> &,   minLotSize)
      accessFunc (const WitFlexVec <double> &,   incLotSize)
d67 3
a69 3
      accessFunc (const WitFlexVec <double> &,   lotSize2Thresh)
      accessFunc (const WitFlexVec <double> &,   minLotSize2)
      accessFunc (const WitFlexVec <double> &,   incLotSize2)
d72 2
a73 2
      accessFunc (const WitFlexVec <double> &,   obj1ExecCost)
      accessFunc (const WitFlexVec <double> &,   execVol)
d76 2
a77 2
      accessFunc (const WitFlexVec <double> &,   mrpExecVol)
      accessFunc (const WitFlexVec <double> &,   fssExecVol)
d84 1
a84 1
      inline const WitFlexVec <double> & cycleTime34 () const
d289 5
a293 5
            WitPeriod                   thePer,
            double                      theExecVol,
            const WitFlexVec <double> & mlsVec,
            const WitFlexVec <double> & ilsVec,
            bool                        useTol);
d324 1
a324 1
      WitFlexVec <double> yieldRate_;
d332 1
a332 1
      WitFlexVec <double> minLotSize_;
d338 1
a338 1
      WitFlexVec <double> incLotSize_;
d349 1
a349 1
      WitFlexVec <double> lotSize2Thresh_;
d359 1
a359 1
      WitFlexVec <double> minLotSize2_;
d365 1
a365 1
      WitFlexVec <double> incLotSize2_;
d386 1
a386 1
      WitFlexVec <double> obj1ExecCost_;
d393 1
a393 1
      WitFlexVec <double> cycleTime34_;
d400 1
a400 1
      WitFlexVec <double> execVol_;
d425 1
a425 1
      WitFlexVec <double> mrpExecVol_;
d434 1
a434 1
      WitFlexVec <double> fssExecVol_;
@


1.35
log
@Double Precision.
@
text
@d28 1
a28 1
#include <RealVec.h>
d63 3
a65 3
      accessFunc (const WitRealVec &,            yieldRate)
      accessFunc (const WitRealVec &,            minLotSize)
      accessFunc (const WitRealVec &,            incLotSize)
d67 3
a69 3
      accessFunc (const WitRealVec &,            lotSize2Thresh)
      accessFunc (const WitRealVec &,            minLotSize2)
      accessFunc (const WitRealVec &,            incLotSize2)
d72 1
a72 1
      accessFunc (const WitRealVec &,            obj1ExecCost)
d76 2
a77 2
      accessFunc (const WitRealVec &,            mrpExecVol)
      accessFunc (const WitRealVec &,            fssExecVol)
d84 1
a84 1
      inline const WitRealVec & cycleTime34 () const
d289 5
a293 5
            WitPeriod          thePer,
            double             theExecVol,
            const WitRealVec & mlsVec,
            const WitRealVec & ilsVec,
            bool               useTol);
d324 1
a324 1
      WitRealVec yieldRate_;
d332 1
a332 1
      WitRealVec minLotSize_;
d338 1
a338 1
      WitRealVec incLotSize_;
d349 1
a349 1
      WitRealVec lotSize2Thresh_;
d359 1
a359 1
      WitRealVec minLotSize2_;
d365 1
a365 1
      WitRealVec incLotSize2_;
d386 1
a386 1
      WitRealVec obj1ExecCost_;
d393 1
a393 1
      WitRealVec cycleTime34_;
d425 1
a425 1
      WitRealVec mrpExecVol_;
d434 1
a434 1
      WitRealVec fssExecVol_;
@


1.34
log
@Double Precision.
@
text
@d103 3
a105 3
      defaultValue (float  defYieldRate,        1.0)
      defaultValue (float  defMinLotSize,       0.0)
      defaultValue (float  defIncLotSize,       0.0)
d107 3
a109 3
      defaultValue (float  defLotSize2Thresh,   0.0)
      defaultValue (float  defMinLotSize2,      0.0)
      defaultValue (float  defIncLotSize2,      0.0)
d112 2
a113 2
      defaultValue (float  defObj1ExecCost,     0.0)
      defaultValue (float  defCycleTime34,      0.0)
d177 1
a177 1
      static bool validYieldRate (float theValue);
a396 2
         // This is a float because it may be the result
         // of converting from, e.g., days to weeks.
@


1.33
log
@Double Precision.
@
text
@d76 2
a77 2
      accessFunc (const WitFlexVec <float> &,    mrpExecVol)
      accessFunc (const WitFlexVec <float> &,    fssExecVol)
d427 1
a427 1
      WitFlexVec <float> mrpExecVol_;
d436 1
a436 1
      WitFlexVec <float> fssExecVol_;
d438 2
a439 2
         // fssExecVol_[t] is the execution volume in period t, as computed by
         // FSS.
@


1.32
log
@Continued double precision.
@
text
@d28 1
a28 1
#include <FlexVec.h>
d63 3
a65 3
      accessFunc (const WitFlexVec <float> &,    yieldRate)
      accessFunc (const WitFlexVec <float> &,    minLotSize)
      accessFunc (const WitFlexVec <float> &,    incLotSize)
d67 3
a69 3
      accessFunc (const WitFlexVec <float> &,    lotSize2Thresh)
      accessFunc (const WitFlexVec <float> &,    minLotSize2)
      accessFunc (const WitFlexVec <float> &,    incLotSize2)
d72 1
a72 1
      accessFunc (const WitFlexVec <float> &,    obj1ExecCost)
d84 1
a84 1
      inline const WitFlexVec <float> & cycleTime34 () const
d289 5
a293 5
            WitPeriod                  thePer,
            double                     theExecVol,
            const WitFlexVec <float> & mlsVec,
            const WitFlexVec <float> & ilsVec,
            bool                       useTol);
d324 1
a324 1
      WitFlexVec <float> yieldRate_;
d326 1
a326 1
         // yieldRate ()[thePer] is the yield incurred when executing this
d328 1
a328 1
         // If yieldRate ()[thePer] == 0.0, then execution is prohibited in 
d332 1
a332 1
      WitFlexVec <float> minLotSize_;
d338 1
a338 1
      WitFlexVec <float> incLotSize_;
d349 1
a349 1
      WitFlexVec <float> lotSize2Thresh_;
d359 1
a359 1
      WitFlexVec <float> minLotSize2_;
d365 1
a365 1
      WitFlexVec <float> incLotSize2_;
d386 1
a386 1
      WitFlexVec <float> obj1ExecCost_;
d388 1
a388 1
         // If objective #1 is being used, then obj1ExecCost_[t] is the
d390 1
a390 1
         // Operation in period t.
d393 1
a393 1
      WitFlexVec <float> cycleTime34_;
d429 2
a430 2
         // mrpExecVol_[t] is the execution volume in period t, as computed by
         // MRP.
@


1.31
log
@Continued double precision.
@
text
@d70 2
a71 2
      accessFunc (StrDbl,                        execPenalty)
      accessFunc (StrDbl,                        obj2AuxCost)
d110 2
a111 2
      defaultValue (StrDbl defExecPenalty,      0.0)
      defaultValue (StrDbl defObj2AuxCost,      0.0)
d131 2
a132 2
      void setExecPenalty      (StrDbl);
      void setObj2AuxCost      (StrDbl);
d371 1
a371 1
      StrDbl execPenalty_;
d378 1
a378 1
      StrDbl obj2AuxCost_;
@


1.30
log
@Removed a bad function overload.
@
text
@d70 2
a71 2
      accessFunc (float,                         execPenalty)
      accessFunc (float,                         obj2AuxCost)
d110 2
a111 2
      defaultValue (float  defExecPenalty,      0.0)
      defaultValue (float  defObj2AuxCost,      0.0)
d131 2
a132 2
      void setExecPenalty      (float);
      void setObj2AuxCost      (float);
d371 1
a371 1
      float execPenalty_;
d378 1
a378 1
      float obj2AuxCost_;
@


1.29
log
@Continued implementation of proportionate routing.
@
text
@d195 1
a195 1
      virtual WitOperation * myOpn        ();
@


1.28
log
@Continued implementation of proportionate routing.
@
text
@d192 9
a200 1
      virtual void copySelfInto (WitCompMgr * theCompMgr);
d202 1
a202 21
         // Override from class Component.

      virtual void recount ();
         //
         // Override from class Component.

      virtual void unpreprocess ();
         //
         // Override from class Component.

      virtual void getOperation (WitOperation * &);
         //
         // Override from class Component.

      virtual void loadPre  ();
      virtual void loadMrp  ();
      virtual void loadFss  ();
      virtual void loadHeur ();
      virtual void loadOpt  ();
         //
         // Override from class Component.
@


1.27
log
@Replaced some C style casts with C++ style casts.
@
text
@a78 2
      decMappingIndex (WitOperation)

d90 8
@


1.26
log
@Fixed the "twoLevelLotSizes" bug that was discovered on windows.
@
text
@d166 1
a166 1
         return (WitOperation *) theItr.key ();
@


1.25
log
@Internal changes.
@
text
@d100 1
a100 1
      defaultValue (bool   defTwoLevelLotSizes, 0.0)
@


1.24
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d66 1
a66 1
      accessFunc (WitBoolean,                    twoLevelLotSizes)
d75 1
a75 1
      accessFunc (const WitTVec <WitBoolean> &,  executable)
d97 12
a108 12
      defaultValue (float      defYieldRate,        1.0)
      defaultValue (float      defMinLotSize,       0.0)
      defaultValue (float      defIncLotSize,       0.0)
      defaultValue (WitBoolean defTwoLevelLotSizes, 0.0)
      defaultValue (float      defLotSize2Thresh,   0.0)
      defaultValue (float      defMinLotSize2,      0.0)
      defaultValue (float      defIncLotSize2,      0.0)
      defaultValue (float      defExecPenalty,      0.0)
      defaultValue (float      defObj2AuxCost,      0.0)
      defaultValue (float      defObj1ExecCost,     0.0)
      defaultValue (float      defCycleTime34,      0.0)
      defaultValue (double     defExecVol,          0.0)
d110 1
a110 1
      defaultValue (int        defYield,          100) 
d121 1
a121 1
      void setTwoLevelLotSizes (WitBoolean);
d144 1
a144 1
      virtual WitBoolean inserted ();
d171 1
a171 1
      static WitBoolean validYieldRate (float theValue);
d173 1
a173 1
         // Returns TRUE, iff theValue is valid as a yieldRate.
d175 1
a175 1
      WitBoolean cycleTime34PreventsExec (WitPeriod t);
d177 1
a177 1
         // Returns TRUE, iff cycleTime34 is such has to prevent execution of
d179 1
a179 1
         // Requires that wit34Compatible is TRUE.
d181 1
a181 1
      void setWit34Compatible (WitBoolean newValue);
d210 1
a210 1
      WitBoolean hasBomEntryInEffect (WitPeriod t);
d212 1
a212 1
         // Returns TRUE, iff this Operation has at least one BomEntry in
d215 1
a215 1
      WitBoolean isCoproducing (WitPeriod execPer);
d217 1
a217 1
         // Return TRUE, iff this Operation is coproducing in execPer.
d220 1
a220 1
      WitBoolean hasNegRateConsEntry (WitPeriod thePer);
d222 1
a222 1
         // Returns TRUE, iff this Operation has at least one ConsEntry in
d235 4
a238 4
            WitPeriod  thePer,
            double     theExecVol,
            double     delta,
            WitBoolean useTol);
d283 1
a283 1
      WitBoolean lotSizeMode (WitPeriod thePer);
d285 1
a285 1
         // Returns TRUE, iff lot sizing is to be done for this Operation in
d288 1
a288 4
      double tllsExecVol (
            WitPeriod  thePer,
            double     theExecVol,
            WitBoolean useTol);
d292 1
a292 1
         // A tolerance will be used iff useTol is TRUE.
d299 1
a299 1
            WitBoolean                 useTol);
d303 1
a303 1
         // A tolerance will be used iff useTol is TRUE.
d351 1
a351 1
      WitBoolean twoLevelLotSizes_;
d353 1
a353 1
         // TRUE, iff two-level lot sizes are to be used for this Operation.
d424 1
a424 1
      WitTVec <WitBoolean> executable_;
d426 1
a426 1
         // executable_[t] is TRUE iff this Operation can be executed in
@


1.23
log
@Continued implementation of two-level lot sizes.
@
text
@d383 2
a384 2
         // execution technique, execPenalty_ is the per unit penalty that
         // the heuristic will apply to the execVol of this Operation.
@


1.22
log
@Continued implementation of 2-level lot sizes.
@
text
@d66 1
d97 12
a108 11
      defaultValue (float  defYieldRate,       1.0)
      defaultValue (float  defMinLotSize,      0.0)
      defaultValue (float  defIncLotSize,      0.0)
      defaultValue (float  defLotSize2Thresh, -1.0)
      defaultValue (float  defMinLotSize2,     0.0)
      defaultValue (float  defIncLotSize2,     0.0)
      defaultValue (float  defExecPenalty,     0.0)
      defaultValue (float  defObj2AuxCost,     0.0)
      defaultValue (float  defObj1ExecCost,    0.0)
      defaultValue (float  defCycleTime34,     0.0)
      defaultValue (double defExecVol,         0.0)
d110 1
a110 1
      defaultValue (int    defYield,           100) 
d118 12
a129 11
      void setYieldRate      (const float *);
      void setMinLotSize     (const float *);
      void setIncLotSize     (const float *);
      void setLotSize2Thresh (const float *);
      void setMinLotSize2    (const float *);
      void setIncLotSize2    (const float *);
      void setExecPenalty    (float);
      void setObj2AuxCost    (float);
      void setObj1ExecCost   (const float *);
      void setExecVol        (const float *);
      void setCycleTime34    (const float *);
d288 9
d354 4
d366 1
a366 1
         // Range: (-inf, +inf).
@


1.21
log
@Continued implementation of 2-level lot sizes.
@
text
@d285 10
a294 5
      int lotSizeGridPoint (WitPeriod thePer, double  qty, WitBoolean useTol);
        //
        // Computes and returns the location for qty on the lot size grid for
        // this Operation in thePer. The grid point is found by moving up.
        // A tolerance will be used iff useTol is TRUE.
@


1.20
log
@Continued implementation of 2-level lot sizes.
@
text
@d231 2
a232 2
      void lotSizeDelta (
            WitPeriod  t,
d234 1
a234 2
            double &   delta,
            WitBoolean upwards,
d237 2
a238 3
         // Adjusts delta, so that theExecVol + delta is lot-size feasible.
         // See WitGlobalComp::lotSizeGridPoint for meaning of upwards and
         // useTol.
d280 1
a280 1
      WitBoolean lotSizeMode (WitPeriod t);
d283 1
a283 1
         // period t.
d285 1
a285 5
      int lotSizeGridPoint (
            WitPeriod  thePer,
            double     qty,
            WitBoolean upwards,
            WitBoolean useTol);
d288 1
a288 2
        // this Operation in thePer. If upwards is TRUE, the grid point
        // will be found by moving up; otherwise moving down.
@


1.19
log
@Continued implementation of two-level lot sizes.
@
text
@a241 10
      WitBoolean lotSizeMode (WitPeriod t);
         //
         // Returns TRUE, iff lot sizing is to be done for this Operation in
         // period t.

      static double compLotSizeQty (double minQty, double incQty, int theGP);
        //
        // Returns the lot size quantity corresponding to theGP on the
        // lot size grid defined by minQty and incQty.

d281 16
@


1.18
log
@Continued implementation of single-source.
@
text
@d66 3
d96 11
a106 8
      defaultValue (float  defYieldRate,    1.0)
      defaultValue (float  defMinLotSize,   0.0)
      defaultValue (float  defIncLotSize,   0.0)
      defaultValue (float  defExecPenalty,  0.0)
      defaultValue (float  defObj2AuxCost,  0.0)
      defaultValue (float  defObj1ExecCost, 0.0)
      defaultValue (float  defCycleTime34,  0.0)
      defaultValue (double defExecVol,      0.0)
d108 1
a108 1
      defaultValue (int    defYield,        100) 
d116 11
a126 8
      void setYieldRate    (const float *);
      void setMinLotSize   (const float *);
      void setIncLotSize   (const float *);
      void setExecPenalty  (float);
      void setObj2AuxCost  (float);
      void setObj1ExecCost (const float *);
      void setExecVol      (const float *);
      void setCycleTime34  (const float *);
d336 22
@


1.17
log
@Continued implementation of single-source.
@
text
@a119 7
      // Conditional reference access functions.
      //------------------------------------------------------------------------

      conditionalRef (WitFlexVec <double>,  execVol, heurAllAcc () ||
                                                      optImpAcc ())

      //------------------------------------------------------------------------
d190 5
a194 3
      virtual void loadPre ();
      virtual void loadMrp ();
      virtual void loadFss ();
@


1.16
log
@Continued implementation of single-source.
@
text
@d123 2
a124 3
      conditionalRef (WitTVec <WitBoolean>, executable, preprocAcc ())
      conditionalRef (WitFlexVec <double>,  execVol,    heurAllAcc () ||
                                                         optImpAcc ())
d189 4
d197 1
@


1.15
log
@Continued implementation of single-source.
@
text
@d123 3
a125 5
      conditionalRef (WitTVec <WitBoolean>,  executable, preprocAcc ())
      conditionalRef (WitFlexVec <double>,   execVol,    heurAllAcc () ||
                                                          optImpAcc ())
      conditionalRef (WitFlexVec <float>,    mrpExecVol,     mrpAcc ())
      conditionalRef (WitFlexVec <float>,    fssExecVol,     fssAcc ())
d191 5
@


1.14
log
@Continued implementation of single-source.
@
text
@d126 2
a192 5
         //
         // Override from class Component.

      virtual void importMrpResults ();
      virtual void importFssResults ();
@


1.13
log
@Continued implementation of single-source.
@
text
@a125 1
      conditionalRef (WitFlexVec <float>,    fssExecVol,     fssAcc ())
d195 1
@


1.12
log
@Preliminary work on single source.
@
text
@a125 1
      conditionalRef (WitFlexVec <float>,    mrpExecVol,     mrpAcc ())
d192 4
@


1.11
log
@Continued preliminary work on single source.
@
text
@d63 3
a65 3
      accessFunc (const WitFlexVec (float) &,    yieldRate)
      accessFunc (const WitFlexVec (float) &,    minLotSize)
      accessFunc (const WitFlexVec (float) &,    incLotSize)
d68 2
a69 2
      accessFunc (const WitFlexVec (float) &,    obj1ExecCost)
      accessFunc (const WitFlexVec (double) &,   execVol)
d72 2
a73 2
      accessFunc (const WitFlexVec (float) &,    mrpExecVol)
      accessFunc (const WitFlexVec (float) &,    fssExecVol)
d82 1
a82 1
      inline const WitFlexVec (float) & cycleTime34 () const
d124 1
a124 1
      conditionalRef (WitFlexVec (double),   execVol,    heurAllAcc () ||
d126 2
a127 2
      conditionalRef (WitFlexVec (float),    mrpExecVol,     mrpAcc ())
      conditionalRef (WitFlexVec (float),    fssExecVol,     fssAcc ())
d306 1
a306 1
      WitFlexVec (float) yieldRate_;
d314 1
a314 1
      WitFlexVec (float) minLotSize_;
d320 1
a320 1
      WitFlexVec (float) incLotSize_;
d342 1
a342 1
      WitFlexVec (float) obj1ExecCost_;
d349 1
a349 1
      WitFlexVec (float) cycleTime34_;
d358 1
a358 1
      WitFlexVec (double) execVol_;
d383 1
a383 1
      WitFlexVec (float) mrpExecVol_;
d392 1
a392 1
      WitFlexVec (float) fssExecVol_;
@


1.10
log
@Preliminary work on single source.
@
text
@d71 1
a71 1
      accessFunc (const WitTVec (WitBoolean) &,  executable)
d123 1
a123 1
      conditionalRef (WitTVec (WitBoolean),  executable, preprocAcc ())
d374 1
a374 1
      WitTVec (WitBoolean) executable_;
@


1.9
log
@Continued implementation of object iteration.
@
text
@d61 2
a62 2
      accessFunc (const WitList (WitBomEntry) &, bom)
      accessFunc (const WitList (WitBopEntry) &, bop)
d294 1
a294 1
      WitList (WitBomEntry) bom_;
d298 1
a298 1
      WitList (WitBopEntry) bop_;
@


1.8
log
@Continued implementation of object iteration.
@
text
@d154 1
a154 1
      virtual WitAttr apiItrState ();
@


1.7
log
@Began implementation of object iteration.
@
text
@d154 1
a154 1
      virtual WitBoolean isanOperation ();
d156 1
a156 1
         // Override from class Node.
d189 4
@


1.6
log
@Refactoring for selection splitting.
@
text
@d28 1
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d250 1
a250 3
      copyCtorAndAssignment (WitOperation);
         //
         // Prevents unintentional copying and assignment.
@


1.4
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d183 1
a183 1
      virtual void copyInto (WitCompMgr * theCompMgr);
@


1.3
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d196 1
a196 1
      WitBoolean isCoproducing ();
d198 1
a198 1
         // Return TRUE, iff this Operation is coproducing.
d201 1
a201 1
      WitBoolean hasNegRateConsEntry (WitPeriod t);
d204 1
a204 1
         // effect in period t whose effUsageRate is negative.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d68 1
a68 1
      accessFunc (const WitTVec (float) &,       execVol)
d123 1
a123 1
      conditionalRef (WitTVec (float),       execVol,    heurAllAcc () ||
d305 4
a308 3
         // yieldRate ()[t] is the yield incurred when executing this Operation
         // in period t.
         // If yieldRate ()[t] == 0.0, then execution is prohibited in period t.
d313 2
a314 2
         // minLotSize ()[t] is the minimum allowable value of execVol ()[t],
         // if execVol ()[t] > 0.0.
d319 3
a321 2
         // If execVol ()[t] > 0.0, then execVol ()[t] - minLotSize_[t]
         // will be a multiple of incLotSize ()[t].
d355 1
a355 1
      WitTVec (float) execVol_;
d357 2
a358 1
         // execVol_[t] is the execution volume in period t (for implosion).
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.40;
access;
symbols
	EndRw-branch:1.39.0.6
	Root-of-EndRw:1.39
	rwToStl:1.39.0.4
	latest_sce_3_10_20010924:1.39.0.2
	sce_3_10_20010924:1.39
	latest_sce_3_00_20010601:1.31.0.2
	sce_3_00_20010601:1.31
	latest_sce_2_31_20010308:1.21.0.2
	sce_2_31_20010308:1.21
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2003.03.03.23.26.57;	author rjw;	state dead;
branches;
next	1.39;

1.39
date	2001.07.06.16.13.38;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.03.22.50.41;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.02.17.33.17;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.28.23.11.16;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.28.17.35.19;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.27.21.45.11;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.21.15.40.04;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.20.20.07.04;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.26.21.25.45;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.25.20.54.35;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.06.23.23.52;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.06.19.22.10;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.03.19.23.05;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.23.19.43.24;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.21.21.55.47;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.20.21.03.59;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.12.19.48.08;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.08.16.37.06;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.06.15.46.37;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.01.16.24.44;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.31.23.17.45;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.29.19.26.10;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.26.21.46.02;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.24.20.05.57;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.20.00.44.19;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.15.19.01.51;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.11.16.35.09;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.04.22.27.52;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.03.15.56.49;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.28.22.13.38;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.20.20.08.36;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.15.23.45.58;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.13.19.57.25;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.05.19.05.30;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.04.22.07.38;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.44;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.20.03.25;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.26;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.26;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.26;	author wit;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Removed all empty files from WIT (64 of them).
@
text
@@


1.39
log
@Minor modification.
@
text
@@


1.38
log
@An attempt to fix the link trouble on Windows for the multi-route templates.
@
text
@a0 778
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "MultiRt.C"
//
// Contains the implementation of the following classes and class templates:
//
//    PmrMgr 
//    MrMgr     <MrArgs>
//    MrSelSite <MrArgs>
//    MrCand    <MrArgs>
//    MrSelPt   <MrArgs>
//------------------------------------------------------------------------------

#include <MrSelPt.h>
#include <MrCand.h>
#include <MrSelSite.h>
#include <PmrMgr.h>
#include <BopEntry.h>

//------------------------------------------------------------------------------
// Implementation of class PmrMgr.
//------------------------------------------------------------------------------

WitPmrMgr::WitPmrMgr (WitSelector * theSelector):
      WitMrMgr <PmrArgs> (theSelector)
   {
   }

//------------------------------------------------------------------------------

WitPmrMgr::~WitPmrMgr ()
   {
   }

//------------------------------------------------------------------------------

WitBopEntry * WitPmrMgr::selBopEntry (WitPart * thePart, WitPeriod expPer)
   {
   return WitMrMgr <PmrArgs>::selBopEntry (thePart, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::printHasAlt ()
   {
   WitMrMgr <PmrArgs>::printHasAlt ();
   }

//------------------------------------------------------------------------------

void WitPmrMgr::modifyRouting (WitBopEntPerStack & theBopEntPers)
   {
   WitMrMgr <PmrArgs>::modifyRouting (theBopEntPers);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::findExpBopEnts (
      WitPart *        thePart, 
      WitPeriod        expPer,
      WitBopEntStack & theBopEnts)
   {
   WitMrMgr <PmrArgs>::findExpBopEnts (thePart, expPer, theBopEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   return WitMrMgr <PmrArgs>::selIsSplit (thePart, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::startSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol)
   {
   WitMrMgr <PmrArgs>::startSplitExp (thePart, expPer, expVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::findNextSplit (
      WitBopEntry * & theBopEnt, 
      double &        splitExpVol)
   {
   return WitMrMgr <PmrArgs>::findNextSplit (theBopEnt, splitExpVol);
   }
 
//------------------------------------------------------------------------------

void WitPmrMgr::adjustSplitBound (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double &      splitBound)
   {
   WitMrMgr <PmrArgs>::adjustSplitBound (theBopEnt, expPer, splitBound);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::recBopEntExpPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double        expVol)
   {
   WitMrMgr <PmrArgs>::recBopEntExpPerSS (theBopEnt, expPer, expVol);
   }

//------------------------------------------------------------------------------
// Implementation of class template MrMgr <MrArgs>.
//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBopEntry * WitMrMgr <MrArgs>::selBopEntry (
         WitPart * thePart, 
         WitPeriod expPer)
   {
   return myMrSelSite (thePart)->selCandComp (expPer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitSelPt * WitMrMgr <MrArgs>::mySelPt (
         WitBopEntry * theBopEnt,
         WitConsEntry *,
         WitPeriod     execPer,
         WitPeriod,
         WitBoolean &  resFound)
   {
   WitPeriod             expPer;
   WitMrSelPt <MrArgs> * theMrSelPt;

   expPer     = theBopEnt->impactPeriod ()[execPer];

   theMrSelPt = myMrSelSite (theBopEnt->myPart ())->myMrSelPtWithAlt (expPer);

   resFound   =
      (theMrSelPt != NULL)?
         theMrSelPt->hasResAlt ():
         witFALSE;

   return theMrSelPt;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrMgr <MrArgs>::validForExecBounds ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      const char * WitMrMgr <MrArgs>::selCaseName ()
   {
   return "Production Multi-Route";
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::prtSelCandID (WitTlObj * theTlObj)
   {
   WitBopEntry * theBopEnt;

   theBopEnt = (WitBopEntry *) theTlObj;

   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::printHasAlt ()
   {
   WitPart * thePart;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Production Multi-Route Selection Points with Alternative(s):\n\n");

   forEachPart (thePart, myProblem ())
      myMrSelSite (thePart)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::modifyRouting (WitBopEntPerStack & theBopEntPers)
   {
   WitBopEntry *           theBopEnt;
   WitPeriod               expPer;
   WitMrSelSite <MrArgs> * theMrSelSite;

   while (theBopEntPers.pop (theBopEnt, expPer))
      {
      theMrSelSite = myMrSelSite (theBopEnt->myPart ());

      theMrSelSite->myMrSelPt ()[expPer]->select (theBopEnt);
      }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::findExpBopEnts (
         WitPart *        thePart, 
         WitPeriod        expPer,
         WitBopEntStack & theBopEnts)
   {
   myMrSelSite (thePart)->findCandComps (expPer, theBopEnts);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrMgr <MrArgs>::selSplitNeeded ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrMgr <MrArgs>::selIsSplit (
         WitPart * thePart, 
         WitPeriod expPer)
   {
   WitMrSelSite <MrArgs> * theMrSelSite;

   if (! selSplit ())
      return witFALSE;

   theMrSelSite = myMrSelSite (thePart);
      
   if (! theMrSelSite->multiChoice ())
      return witFALSE;

   return theMrSelSite->myMrSelPt ()[expPer]->isSplit ();
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::startSplitExp (
         WitPart * thePart, 
         WitPeriod expPer,
         double    expVol)
   {
   WitMrSelPt <MrArgs> * theMrSelPt;

   witAssert (selIsSplit (thePart, expPer));

   theMrSelPt = myMrSelSite (thePart)->myMrSelPt ()[expPer];

   startSplitExpAbs (theMrSelPt, expVol);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::adjustSplitBound (
         WitBopEntry * theBopEnt, 
         WitPeriod     expPer, 
         double &      splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExpVol_ (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::recBopEntExpPerSS (
         WitBopEntry * theBopEnt,
         WitPeriod     expPer,
         double        expVol)
   {
   if (selSplit ())
      if (myMrSelSite (theBopEnt->myPart ())->multiChoice ())
         totExpVol_.incCell (theBopEnt, expPer, expVol);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::postCommitSS ()
   {
   witAssert (selSplit ());

   totExpVol_.clear ();
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::postSplitCommit ()
   {
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrMgr <MrArgs>::WitMrMgr (WitSelector * theSelector):
         WitSelMgr      (theSelector),

         myMrSelSiteTl_ (),
         totExpVol_     (myProblem ())
   {
   WitPart * thePart;

   myMrSelSiteTl_.allocate (myProblem (), NULL);

   forEachPart (thePart, myProblem ())
      myMrSelSite (thePart) = new WitMrSelSite <MrArgs> (thePart, this);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrMgr <MrArgs>::~WitMrMgr ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      delete myMrSelSite (thePart);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrMgr <MrArgs>::setUpDerivedSS ()
   {
   WitPart *     thePart;
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   totExpVol_.allocate1D ();

   forEachPart (thePart, myProblem ())
      if (myMrSelSite (thePart)->multiChoice ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expAllowed ())
               totExpVol_.allocateRow (theBopEnt);
   }

//------------------------------------------------------------------------------
// Implementation of class template MrSelSite <MrArgs>.
//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelSite <MrArgs>::WitMrSelSite (
            SelComp *           theSelComp, 
            WitMrMgr <MrArgs> * theMrMgr):

         WitProbAssoc (theMrMgr),

         myMrMgr_     (theMrMgr),
         mySelComp_   (theSelComp),
         myMrCands_   (myProblem ()),
         multiChoice_ (witFALSE),
         myMrSelPt_   ()
   {
   if (! myGlobalComp ()->multiRoute ())
      return;

   buildMrCands ();

   buildMrSelPts ();
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelSite <MrArgs>::~WitMrSelSite ()
   {
   WitPeriod            thePer;
   WitMrCand <MrArgs> * theMrCand;

   if (multiChoice_)
      forEachPeriod (thePer, myProblem ())
         delete myMrSelPt_[thePer];

   while (myMrCands_.pop (theMrCand))
      delete theMrCand;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::printHasAlt ()
   {
   WitPeriod             thePer;
   WitMrSelPt <MrArgs> * theMrSelPt;

   if (! multiChoice_)
      return;

   forEachPeriod (thePer, myProblem ())
      {
      theMrSelPt = myMrSelPt_[thePer];

      if (theMrSelPt != NULL)
         if (theMrSelPt->selMrCand () != NULL)
            theMrSelPt->printID ();
      }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::findCandComps (
         WitPeriod                   thePer, 
         WitObjStack <WitBopEntry> & theCandComps)
   {
   WitMrCandItr         theMrCandItr;
   WitMrCand <MrArgs> * theMrCand;

   theCandComps.clear ();

   if (multiChoice ())
      {
      theMrCandItr.attachTo (myMrCands_);

      while (theMrCandItr.advance (theMrCand))
         if (theMrCand->isEligible (thePer))
            if (! theMrCand->prevSel ()[thePer])
               theCandComps.push (theMrCand->myCandComp ());

      theCandComps.reverse ();
      }

   if (theCandComps.isEmpty ())
      if (mySelComp_->explodeable (thePer))
         theCandComps.push (mySelComp_->expBopEntry (thePer));
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrCand <MrArgs> * WitMrSelSite <MrArgs>::myMrCandFor (
         CandComp * theCandComp)
   {
   WitMrCandItr         theMrCandItr;
   WitMrCand <MrArgs> * theMrCand;

   theMrCandItr.attachTo (myMrCands_);

   while (theMrCandItr.advance (theMrCand))
      if (theMrCand->myCandComp () == theCandComp)
         return theMrCand;

   myMsgFac () ("internalErrorFmsg", "WitMrSelSite <MrArgs>::myMrCandFor");

   return NULL;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      CandComp * WitMrSelSite <MrArgs>::selCandComp (WitPeriod thePer)
   {
   WitMrCand <MrArgs> * theMrCand;

   witAssert (mySelComp_->explodeable (thePer));

   if (multiChoice_)
      {
      theMrCand = myMrSelPt_[thePer]->selMrCand ();

      if (theMrCand != NULL)
         return theMrCand->myCandComp ();
      }

   return mySelComp_->expBopEntry (thePer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::buildMrSelPts ()
   {
   WitPeriod thePer;

   if (! multiChoice_)
      return;

   myMrSelPt_.allocate (myProblem ());

   forEachPeriod (thePer, myProblem ())
      if (mySelComp_->explodeable (thePer))
         myMrSelPt_[thePer] = new WitMrSelPt <MrArgs> (this, thePer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelPt <MrArgs> * WitMrSelSite <MrArgs>::multiChoiceMrSelPtWithAlt (
         WitPeriod thePer)
   {
   WitMrSelPt <MrArgs> * theMrSelPt;

   witAssert (multiChoice_);

   theMrSelPt = myMrSelPt_[thePer];

   witAssert (theMrSelPt != NULL);

   return
      (theMrSelPt->selMrCand () != NULL)?
         theMrSelPt:
         NULL;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::buildMrCands ()
   {
   CandComp * theCandComp;

   if (mySelComp_->producingBopEntries ().isEmpty ())
      return;

   forEachEl (theCandComp, mySelComp_->producingBopEntries ())
      if (theCandComp->expAllowed ())
         myMrCands_.push (new WitMrCand <MrArgs> (theCandComp));

   myMrCands_.reverse ();

   multiChoice_ = (myMrCands_.nElements () > 1);
   }

//------------------------------------------------------------------------------
// Implementation of class template MrCand <MrArgs>.
//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrCand <MrArgs>::WitMrCand (CandComp * theCandComp):

         WitSelCand  (theCandComp),

         myCandComp_ (theCandComp),
         prevSel_    (myProblem (), witFALSE)
   {
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrCand <MrArgs>::~WitMrCand ()
   {
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrCand <MrArgs>::isEligible (WitPeriod thePer)
   {
   return myCandComp_->expEligible (thePer);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrCand <MrArgs>::setPrevSel (WitPeriod thePer)
   {
   prevSel_.elemRef (thePer) = witTRUE;
   }

//------------------------------------------------------------------------------
// Implementation of class template MrSelPt <MrArgs>.
//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelPt <MrArgs>::WitMrSelPt (
            WitMrSelSite <MrArgs> * theMrSelSite, 
            WitPeriod               thePer):

         WitSelPt     (),

         myMrSelSite_ (theMrSelSite),
         myPer_       (thePer),
         selMrCand_   (NULL),
         hasResAlt_   (witFALSE)
   {
   CandComp *           theCandComp;
   WitMrCandItr         theMrCandItr;
   WitMrCand <MrArgs> * theMrCand;

   witAssert (myMrSelSite_->mySelComp ()->explodeable (myPer_));

   theCandComp  = myMrSelSite_->mySelComp ()->expBopEntry (myPer_);

   selMrCand_   = myMrSelSite_->myMrCandFor (theCandComp);

   theMrCandItr.attachTo (myMrSelSite_->myMrCands ());

   while (theMrCandItr.advance (theMrCand))
      if (theMrCand->isEligible (myPer_))
         if (theMrCand != selMrCand_)
            {
            hasResAlt_ = witTRUE;

            break;
            }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitMrSelPt <MrArgs>::~WitMrSelPt ()
   {
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitTlObj * WitMrSelPt <MrArgs>::selectedObj ()
   {
   CandComp * theCandComp;

   witAssert (selMrCand_ != NULL);

   theCandComp = selMrCand_->myCandComp ();

   return (WitTlObj *) theCandComp;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::alterSelection ()
   {
   WitMrCandItr         theMrCandItr;
   WitMrCand <MrArgs> * theMrCand;

   witAssert (selMrCand_ != NULL);

   selMrCand_->setPrevSel (myPer_);

   selMrCand_ = NULL;
   hasResAlt_  = witFALSE;

   theMrCandItr.attachTo (myMrSelSite_->myMrCands ());

   while (theMrCandItr.advance (theMrCand))
      if (theMrCand->isEligible (myPer_))
         if (! theMrCand->prevSel ()[myPer_])
            if (selMrCand_ == NULL)
               selMrCand_ = theMrCand;
            else
               {
               hasResAlt_ = witTRUE;

               return;
               }
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::printSelection ()
   {
   fprintf (msgFile (), "\n");

   printID ();

   fprintf (msgFile (), "   Selected BopEntry: ");

   if (selMrCand_ == NULL)
      fprintf (msgFile (), "None\n");
   else
      fprintf (msgFile (),
         "%s #%d\n",
         selMrCand_->myCandComp ()->myOperationName ().myCstring (),
         selMrCand_->myCandComp ()->localIndex ());
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitSelMgr * WitMrSelPt <MrArgs>::mySelMgr ()
   {
   return myMrSelSite_->myMrMgr ();
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::prtID ()
   {
   fprintf (msgFile (),
      "   Part:        %s\n"
      "   Exp Per:     %d\n",
      myMrSelSite_->mySelComp ()->partName ().myCstring (),
      myPer_);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      WitBoolean WitMrSelPt <MrArgs>::splittable ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::adjustSplitBound (
         WitTlObj * theTlObj, 
         double & splitBound)
   {
   CandComp * theCandComp;

   theCandComp = (CandComp *) theTlObj;

   myMrSelSite_->myMrMgr ()->adjustSplitBound (theCandComp, myPer_, splitBound);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::printID ()
   {
   fprintf (msgFile (), 
      "   Part %s, Exp Per %d\n", 
      myMrSelSite_->mySelComp ()->partName ().myCstring (),
      myPer_);
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      void WitMrSelPt <MrArgs>::select (CandComp * theCandComp)
   {
   WitMrCand <MrArgs> * theMrCand;

   theMrCand = myMrSelSite_->myMrCandFor (theCandComp);

   witAssert (theMrCand != selMrCand_);

   witAssert (! theMrCand->prevSel ()[myPer_]);

   selMrCand_ = theMrCand;
   }

//------------------------------------------------------------------------------

template <MrArgDecs>
      FILE * WitMrSelPt <MrArgs>::msgFile ()
   {
   return myMrSelSite_->msgFile ();
   }
@


1.37
log
@Some more template stuff.
@
text
@d24 1
a24 1
#include <MrSelSt.h>
d41 77
@


1.36
log
@Refactoring.
@
text
@d407 1
a407 1
      WitBopEntry * WitMrSelSite <MrArgs>::selCandComp (WitPeriod thePer)
@


1.35
log
@Replaced non-template based production multi-route with template based
production multi-route.
@
text
@d52 1
a52 1
   return myMrSelSite (thePart)->selBopEntry (expPer);
d155 1
a155 1
   myMrSelSite (thePart)->findExpBopEnts (expPer, theBopEnts);
d299 1
a299 1
            WitPart *           thePart, 
d305 1
a305 1
         myPart_      (thePart),
d323 1
a323 1
   WitPeriod            expPer;
d327 2
a328 2
      forEachPeriod (expPer, myProblem ())
         delete myMrSelPt_[expPer];
d339 1
a339 1
   WitPeriod             expPer;
d345 1
a345 1
   forEachPeriod (expPer, myProblem ())
d347 1
a347 1
      theMrSelPt = myMrSelPt_[expPer];
d358 3
a360 3
      void WitMrSelSite <MrArgs>::findExpBopEnts (
         WitPeriod        expPer, 
         WitBopEntStack & theBopEnts)
d365 1
a365 1
   theBopEnts.clear ();
d372 3
a374 3
         if (theMrCand->isEligible (expPer))
            if (! theMrCand->prevSel ()[expPer])
               theBopEnts.push (theMrCand->myBopEnt ());
d376 1
a376 1
      theBopEnts.reverse ();
d379 3
a381 3
   if (theBopEnts.isEmpty ())
      if (myPart_->explodeable (expPer))
         theBopEnts.push (myPart_->expBopEntry (expPer));
d388 1
a388 1
         WitBopEntry * theBopEnt)
d396 1
a396 1
      if (theMrCand->myBopEnt () == theBopEnt)
d407 1
a407 1
      WitBopEntry * WitMrSelSite <MrArgs>::selBopEntry (WitPeriod expPer)
d411 1
a411 1
   witAssert (myPart_->explodeable (expPer));
d415 1
a415 1
      theMrCand = myMrSelPt_[expPer]->selMrCand ();
d418 1
a418 1
         return theMrCand->myBopEnt ();
d421 1
a421 1
   return myPart_->expBopEntry (expPer);
d429 1
a429 1
   WitPeriod expPer;
d436 3
a438 3
   forEachPeriod (expPer, myProblem ())
      if (myPart_->explodeable (expPer))
         myMrSelPt_[expPer] = new WitMrSelPt <MrArgs> (this, expPer);
d445 1
a445 1
         WitPeriod expPer)
d451 1
a451 1
   theMrSelPt = myMrSelPt_[expPer];
d466 1
a466 1
   WitBopEntry * theBopEnt;
d468 1
a468 1
   if (myPart_->producingBopEntries ().isEmpty ())
d471 3
a473 3
   forEachEl (theBopEnt, myPart_->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         myMrCands_.push (new WitMrCand <MrArgs> (theBopEnt));
a480 10

template <MrArgDecs>
      void WitMrSelSite <MrArgs>::addPrereq (
         WitObjStack <WitPart> & prereqs, 
         WitBopEntry *           theBopEnt)
   {
   prereqs.push (theBopEnt->myOperation ()->bom ().first ()->myPart ());
   }

//------------------------------------------------------------------------------
d485 1
a485 1
      WitMrCand <MrArgs>::WitMrCand (WitBopEntry * theBopEnt):
d487 1
a487 1
         WitSelCand (theBopEnt),
d489 2
a490 2
         myBopEnt_  (theBopEnt),
         prevSel_   (myProblem (), witFALSE)
d504 1
a504 1
      WitBoolean WitMrCand <MrArgs>::isEligible (WitPeriod expPer)
d506 1
a506 1
   return myBopEnt_->expEligible (expPer);
d512 1
a512 1
      void WitMrCand <MrArgs>::setPrevSel (WitPeriod expPer)
d514 1
a514 1
   prevSel_.elemRef (expPer) = witTRUE;
d518 2
d524 1
a524 1
            WitPeriod               expPer):
d529 1
a529 1
         myExpPer_    (expPer),
d533 1
a533 1
   WitBopEntry *        theBopEnt;
d537 1
a537 1
   witAssert (myMrSelSite_->myPart ()->explodeable (myExpPer_));
d539 1
a539 1
   theBopEnt  = myMrSelSite_->myPart ()->expBopEntry (myExpPer_);
d541 1
a541 1
   selMrCand_ = myMrSelSite_->myMrCandFor (theBopEnt);
d546 1
a546 1
      if (theMrCand->isEligible (myExpPer_))
d567 1
a567 1
   WitBopEntry * theBopEnt;
d571 1
a571 1
   theBopEnt = selMrCand_->myBopEnt ();
d573 1
a573 1
   return (WitTlObj *) theBopEnt;
d586 1
a586 1
   selMrCand_->setPrevSel (myExpPer_);
d594 2
a595 2
      if (theMrCand->isEligible (myExpPer_))
         if (! theMrCand->prevSel ()[myExpPer_])
d622 2
a623 2
         selMrCand_->myBopEnt ()->myOperationName ().myCstring (),
         selMrCand_->myBopEnt ()->localIndex ());
d642 2
a643 2
      myMrSelSite_->myPart ()->partName ().myCstring (),
      myExpPer_);
d661 1
a661 1
   WitBopEntry * theBopEnt;
d663 1
a663 1
   theBopEnt = (WitBopEntry *) theTlObj;
d665 1
a665 4
   myMrSelSite_->myMrMgr ()->adjustSplitBound (
      theBopEnt, 
      myExpPer_, 
      splitBound);
d675 2
a676 2
      myMrSelSite_->myPart ()->partName ().myCstring (),
      myExpPer_);
d682 1
a682 1
      void WitMrSelPt <MrArgs>::select (WitBopEntry * theBopEnt)
d686 1
a686 1
   theMrCand = myMrSelSite_->myMrCandFor (theBopEnt);
d690 1
a690 1
   witAssert (! theMrCand->prevSel ()[myExpPer_]);
@


1.34
log
@Initial implementation of multi-route class templates.
@
text
@d15 1
a16 1
//    PmrMgN 
d25 1
d29 15
a290 15
   }

//------------------------------------------------------------------------------
// Implementation of class PmrMgN.
//------------------------------------------------------------------------------

WitPmrMgN::WitPmrMgN (WitSelector * theSelector):
      WitMrMgr <PmrArgs> (theSelector)
   {
   }

//------------------------------------------------------------------------------

WitPmrMgN::~WitPmrMgN ()
   {
@


1.33
log
@Some template stuff.
@
text
@d13 1
a13 1
// Contains the implementation of the following templates:
d15 5
a19 1
//    MrCand <SelComp, CandComp>
d22 1
d24 1
a24 1
#include <PmrPart.h>
d28 1
a28 1
// Implementation of class template MrCand <SelComp, CandComp>.
d31 82
a112 4
template <class SelComp, class CandComp>
      WitMrCand <SelComp, CandComp>::WitMrCand (
            CandComp *   theBopEnt, 
            WitPmrPart * thePmrPart):
d114 383
a496 1
         WitSelCand (thePmrPart),
a498 1
         myPmrPart_ (thePmrPart),
d505 2
a506 2
template <class SelComp, class CandComp>
      WitMrCand <SelComp, CandComp>::~WitMrCand ()
d512 2
a513 2
template <class SelComp, class CandComp>
      WitBoolean WitMrCand <SelComp, CandComp>::isEligible (WitPeriod expPer)
d520 2
a521 2
template <class SelComp, class CandComp>
      void WitMrCand <SelComp, CandComp>::setPrevSel (WitPeriod expPer)
d528 132
a659 1
#if 0
d661 6
a666 1
void witCallMRfuncs ()
d668 1
a668 1
   WitMrCand <WitPart, WitBopEntry> * theCand = NULL;
d670 6
a675 1
   delete theCand;
d678 34
a711 1
#endif
@


1.32
log
@Converted several generic classes into class templates.
@
text
@d13 3
a15 1
// Contains the implementation of the following classes:
d19 55
@


1.31
log
@Refactoring for selection splitting.
@
text
@d1 16
@


1.30
log
@Refactoring for selection splitting.
@
text
@a0 1114
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "MultiRt.C"
//
// Contains the implementation of the following classes:
//
//    PmrMgr.
//    CmrMgr.
//    MrPart.
//    MrBomEnt.
//    MrComp.
//    MrAltPt.
//------------------------------------------------------------------------------

#include <PmrMgr.h>
#include <CmrMgr.h>
#include <MrPart.h>
#include <MrBomEnt.h>
#include <HeurAllP.h>
#include <AllMode.h>
#include <ObjStack.h>

//------------------------------------------------------------------------------
// Implementation of class PmrMgr.
//------------------------------------------------------------------------------

WitPmrMgr::WitPmrMgr (WitSelector * theSelector):
      WitSelMgr    (theSelector),

      myMrPartTl_  (),
      totExpVol_   (myProblem ()),
      splitSched_  (myProblem ()),
      splitExpPer_ (-1)
   {
   WitPart * thePart;

   myMrPartTl_.allocate (myProblem (), NULL);

   forEachPart (thePart, myProblem ())
      myMrPart (thePart) = new WitMrPart (thePart, this);

   if (selSplit ())
      setupSelSplit ();
   }

//------------------------------------------------------------------------------

WitPmrMgr::~WitPmrMgr ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      delete myMrPart (thePart);
   }

//------------------------------------------------------------------------------

WitBopEntry * WitPmrMgr::selBopEntry (WitPart * thePart, WitPeriod thePer)
   {
   return myMrPart (thePart)->selBopEntry (thePer);
   }

//------------------------------------------------------------------------------

WitAltPt * WitPmrMgr::myAltPt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod,
      WitBoolean &  resFound)
   {
   WitPeriod    prodPer;
   WitMrAltPt * theMrAltPt;

   prodPer    = theBopEnt->impactPeriod ()[execPer];

   theMrAltPt = myMrPart (theBopEnt->myPart ())->myMrAltPtWithAlt (prodPer);

   resFound = 
      (theMrAltPt != NULL)?
         theMrAltPt->hasResAlt ():
         witFALSE;

   return theMrAltPt;
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::validForExecBounds ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

void WitPmrMgr::printHasAlt ()
   {
   WitPart * thePart;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Production Multi-Route Alt Points with Alternative(s):\n\n");

   forEachPart (thePart, myProblem ())
      myMrPart (thePart)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitPmrMgr::printMultiChoices ()
   {
   WitPart * thePart;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Multi-Route Parts with multi-choice:\n"
      "\n");

   forEachPart (thePart, myProblem ())
      myMrPart (thePart)->printIfMultiChoice ();
   }

//------------------------------------------------------------------------------

void WitPmrMgr::modifyRouting (WitBopEntPerStack & theBopEntPers)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;

   while (theBopEntPers.pop (theBopEnt, expPer))
      myMrPart (theBopEnt->myPart ())->select (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::findExpBopEnts (
      WitPart *        thePart, 
      WitPeriod        expPer,
      WitBopEntStack & theBopEnts)
   {
   myMrPart (thePart)->findExpBopEnts (expPer, theBopEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   if (selSplit ())
      if (myMrPart (thePart)->multiChoice ())
         if (! splitSched_ (thePart, expPer).isEmpty ())
            return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitPmrMgr::startSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol)
   {
   witAssert (selIsSplit (thePart, expPer));

   splitExpPer_ = expPer;

   startSplitExpAbs (
      splitSched_           (thePart, expPer),
      asaTlPtr (selBopEntry (thePart, expPer)),
      expVol,
      NULL);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::recBopEntExpPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod      expPer, 
      double         expVol)
   {
   if (selSplit ())
      if (myMrPart (theBopEnt->myPart ())->multiChoice ())
         totExpVol_.incCell (theBopEnt, expPer, expVol);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExpVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitPmrMgr::postSplitCommit ()
   {
   witAssert (selSplit ());

   splitSched_.clear ();
   }

//------------------------------------------------------------------------------

void WitPmrMgr::setupSelSplit ()
   {
   WitPart *     thePart;
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   totExpVol_ .allocate1D ();
   splitSched_.allocate1D ();

   forEachPart (thePart, myProblem ())
      if (myMrPart (thePart)->multiChoice ())
         {
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expAllowed ())
               totExpVol_.allocateRow (theBopEnt);

         splitSched_.allocateRow (thePart);
         }
   }

//------------------------------------------------------------------------------

void WitPmrMgr::adjustSplitBound (WitTl * theTlObj, double & splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExpVol_ (asaBopEntry (theTlObj), splitExpPer_);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::prtSelSplit (WitTl * theTlObj)
   {
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   theBopEnt = asaBopEntry (theTlObj);

   fprintf (msgFile (),
      "\n"
      "Split Selection for Production Multi-Route:\n"
      "   Part:        %s\n"
      "   Exp Per:     %d\n"
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEnt->myPartName ().myCstring (),
      splitExpPer_,
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
   }

//------------------------------------------------------------------------------
// Implementation of class CmrMgr.
//------------------------------------------------------------------------------

WitCmrMgr::WitCmrMgr (WitSelector * theSelector):
      WitSelMgr     (theSelector),

      myMrBomEntTl_ (),
      totExecVol_   (myProblem ()),
      splitSched_   (myProblem ()),
      splitExecPer_ (-1)
   {
   WitBomEntry * theBomEnt;

   myMsgFac () ("multiRouteMsg");

   myMrBomEntTl_.allocate (myProblem (), NULL);

   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt) = new WitMrBomEnt (theBomEnt, this);

   if (selSplit ())
      setupSelSplit ();
   }

//------------------------------------------------------------------------------

WitCmrMgr::~WitCmrMgr ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      delete myMrBomEnt (theBomEnt);
   }

//------------------------------------------------------------------------------

WitConsEntry * WitCmrMgr::selConsEntry (
      WitBomEntry * theBomEnt, 
      WitPeriod     thePer)
   {
   return myMrBomEnt (theBomEnt)->selConsEntry (thePer);
   }

//------------------------------------------------------------------------------

WitAltPt * WitCmrMgr::myAltPt (
      WitBopEntry *,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod,
      WitBoolean &   resFound)
   {
   WitMrAltPt * theMrAltPt;

   theMrAltPt = 
      myMrBomEnt (theConsEnt->myBomEntry ())->myMrAltPtWithAlt (execPer);

   resFound = 
      (theMrAltPt != NULL)?
         theMrAltPt->hasResAlt ():
         witFALSE;

   return theMrAltPt;
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::validForExecBounds ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitCmrMgr::printHasAlt ()
   {
   WitBomEntry * theBomEnt;

   fprintf (msgFile (),
      "\n"
      "Consumption Multi-Route Alt Points with Alternative(s):\n\n");

   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitCmrMgr::printMultiChoices ()
   {
   WitBomEntry * theBomEnt;

   fprintf (msgFile (),
      "\n"
      "Multi-Route BOM entries with multi-choice:\n"
      "\n");

   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt)->printIfMultiChoice ();
   }

//------------------------------------------------------------------------------

void WitCmrMgr::modifyRouting (WitConsEntPerStack & theConsEntPers)
   {
   WitConsEntry * theConsEnt;
   WitPeriod      execPer;

   while (theConsEntPers.pop (theConsEnt, execPer))
      myMrBomEnt (theConsEnt->myBomEntry ())->select (theConsEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::findExpConsEnts (
      WitBomEntry *     theBomEnt,
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   myMrBomEnt (theBomEnt)->findExpConsEnts (execPer, theConsEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   if (selSplit ())
      if (myMrBomEnt (theBomEnt)->multiChoice ())
         if (! splitSched_ (theBomEnt, execPer).isEmpty ())
            return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitCmrMgr::startSplitExp (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer,
      double        theExecVol)
   {
   witAssert (selIsSplit (theBomEnt, execPer));

   splitExecPer_ = execPer;

   startSplitExpAbs (
      splitSched_            (theBomEnt, execPer),
      asaTlPtr (selConsEntry (theBomEnt, execPer)),
      theExecVol,
      NULL);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::recExpConsEntSS (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer, 
      double         deltaExecVol)
   {
   if (selSplit ())
      if (myMrBomEnt (theConsEnt->myBomEntry ())->multiChoice ())
         totExecVol_.incCell (theConsEnt, execPer, deltaExecVol);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExecVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitCmrMgr::postSplitCommit ()
   {
   witAssert (selSplit ());

   splitSched_.clear ();
   }

//------------------------------------------------------------------------------

void WitCmrMgr::setupSelSplit ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   witAssert (selSplit ());

   totExecVol_.allocate1D ();
   splitSched_.allocate1D ();

   forEachBomEntry (theBomEnt, myProblem ())
      if (myMrBomEnt (theBomEnt)->multiChoice ())
         {
         totExecVol_.allocateRow (theBomEnt);

         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->expAllowed ())
               totExecVol_.allocateRow (theSub);

         splitSched_.allocateRow (theBomEnt);
         }
   }

//------------------------------------------------------------------------------

void WitCmrMgr::adjustSplitBound (WitTl * theTlObj, double & splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExecVol_ (asaConsEntry (theTlObj), splitExecPer_);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::prtSelSplit (WitTl * theTlObj)
   {
   WitConsEntry * theConsEnt;

   witAssert (selSplit ());

   theConsEnt = asaConsEntry (theTlObj);

   fprintf (msgFile (),
      "\n"
      "Split Selection for Consumption Multi-Route:\n"
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Part:        %s\n"
      "   Exec Per:    %d\n",
      theConsEnt->myOperationName ().myCstring (),
      theConsEnt->myBomEntry ()->localIndex (),
      theConsEnt->myBomEntry ()->myPartName ().myCstring (),
      splitExecPer_);

   if (theConsEnt == theConsEnt->myBomEntry ())
      fprintf (msgFile (), 
         "   Self\n");
   else
      fprintf (msgFile (), 
         "   Sub #:       %d\n", 
         theConsEnt->localIndex ());
                  
   fprintf (msgFile (),
      "   Part:        %s\n",
      theConsEnt->myPartName ().myCstring ());
   }

//------------------------------------------------------------------------------
// Implementation of class MrPart.
//------------------------------------------------------------------------------

WitMrPart::WitMrPart (WitPart * thePart, WitPmrMgr * thePmrMgr):
      WitMrComp  (thePmrMgr->myProblem ()),

      myPmrMgr_  (thePmrMgr),
      myPart_    (thePart),
      candidate_ ()
   {
   setUp ();
   }

//------------------------------------------------------------------------------

WitMrPart::~WitMrPart ()
   {
   }

//------------------------------------------------------------------------------

WitBoolean WitMrPart::candIsDefault (WitCandIndex theIdx, WitPeriod thePer)
   {
   return (candidate_[theIdx] == myPart_->expBopEntry (thePer));
   }

//------------------------------------------------------------------------------

WitCandIndex WitMrPart::nCandidates ()
   {
   return candidate_.length ();
   }

//------------------------------------------------------------------------------

WitBoolean WitMrPart::compIsEligible (WitPeriod thePer)
   {
   return myPart_->explodeable (thePer);
   }

//------------------------------------------------------------------------------

WitBoolean WitMrPart::candIsEligible (WitCandIndex theIdx, WitPeriod thePer)
   {
   return candidate_[theIdx]->expEligible (thePer);
   }

//------------------------------------------------------------------------------

void WitMrPart::printID ()
   {
   fprintf (msgFile (), "   Part %s", myPart_->partName ().myCstring ());
   }

//------------------------------------------------------------------------------

void WitMrPart::printCandidate (WitCandIndex theIdx)
   {
   fprintf (msgFile (),
      "BopEntry: %s #%d",
      candidate_[theIdx]->myOperationName ().myCstring (),
      candidate_[theIdx]->localIndex ());
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrPart::mySelMgr (WitSelector * theSelector)
   {
   return theSelector->myPmrMgr ();
   }

//------------------------------------------------------------------------------

void WitMrPart::findExpBopEnts (WitPeriod expPer, WitBopEntStack & theBopEnts)
   {
   WitCandIndex theIdx;
   WitMrAltPt * theMrAltPt;

   theBopEnts.clear ();

   if (multiChoice ())
      {
      theMrAltPt = myMrAltPt ()[expPer];

      for (theIdx = nCandidates () - 1; theIdx >= 0; theIdx --)
         if (candIsEligible (theIdx, expPer))
            if (! theMrAltPt->prevSel ()[theIdx])
               theBopEnts.push (candidate_[theIdx]);
      }

   if (theBopEnts.isEmpty ())
      if (myPart_->explodeable (expPer))
         theBopEnts.push (myPart_->expBopEntry (expPer));
   }

//------------------------------------------------------------------------------

void WitMrPart::select (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitCandIndex nCands;
   WitCandIndex theIdx;
   WitCandIndex theSelIdx;

   nCands = nCandidates ();

   if (DEBUG_MODE)
      theSelIdx = -1;
   
   for (theIdx = 0; theIdx < nCands; theIdx ++)
      if (candidate_[theIdx] == theBopEnt)
         {
         theSelIdx = theIdx;

         break;
         }

   witAssert (theSelIdx >= 0);

   myMrAltPt ()[expPer]->select (theSelIdx);
   }

//------------------------------------------------------------------------------

void WitMrPart::initCandidate ()
   {
   if (myPart_->producingBopEntries ().isEmpty ())
      return;

   WitBopEntry *  theBopEnt;
   int            nCands;
   WitCandIndex   theIdx;
   WitBopEntStack theCands (myProblem ());

   nCands = 0;

   forEachEl (theBopEnt, myPart_->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         {
         nCands ++;

         theCands.push (theBopEnt);
         }

   candidate_.resize (nCands);

   theIdx = nCands - 1;

   while (theCands.pop (theBopEnt))
      candidate_[theIdx --] = theBopEnt;
   }

//------------------------------------------------------------------------------

void WitMrPart::addPrereq (
      WitObjStack (WitPart) & prereqs, 
      WitBopEntry *           theBopEnt)
   {
   prereqs.push (theBopEnt->myOperation ()->bom ().first ()->myPart ());
   }

//------------------------------------------------------------------------------
// Implementation of class MrBomEnt.
//------------------------------------------------------------------------------

WitMrBomEnt::WitMrBomEnt (WitBomEntry * theBomEnt, WitCmrMgr * theCmrMgr):
      WitMrComp   (theCmrMgr->myProblem ()),

      myCmrMgr_   (theCmrMgr),
      myBomEntry_ (theBomEnt),
      candidate_  ()
   {
   setUp ();
   }

//------------------------------------------------------------------------------

WitMrBomEnt::~WitMrBomEnt ()
   {
   }

//------------------------------------------------------------------------------

WitBoolean WitMrBomEnt::candIsDefault (WitCandIndex theIdx, WitPeriod)
   {
   return (candidate_[theIdx] == myBomEntry_);
   }

//------------------------------------------------------------------------------

WitCandIndex WitMrBomEnt::nCandidates ()
   {
   return candidate_.length ();
   }

//------------------------------------------------------------------------------

WitBoolean WitMrBomEnt::compIsEligible (WitPeriod thePer)
   {
   return myBomEntry_->inEffect (thePer);
   }

//------------------------------------------------------------------------------

WitBoolean WitMrBomEnt::candIsEligible (WitCandIndex theIdx, WitPeriod thePer)
   {
   return candidate_[theIdx]->inEffect (thePer);
   }

//------------------------------------------------------------------------------

void WitMrBomEnt::printID ()
   {
   fprintf (msgFile (),
      "   BomEntry %s, #%d",
      myBomEntry_->myOperationName ().myCstring (),
      myBomEntry_->localIndex ());
   }

//------------------------------------------------------------------------------

void WitMrBomEnt::printCandidate (WitCandIndex theIdx)
   {
   if (candidate_[theIdx]->isaSubEntry ())
      fprintf (msgFile (),
         "SubEntry: #%d",
         candidate_[theIdx]->localIndex ());
   else
      fprintf (msgFile (), "Original BomEntry");
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrBomEnt::mySelMgr (WitSelector * theSelector)
   {
   return theSelector->myCmrMgr ();
   }

//------------------------------------------------------------------------------

void WitMrBomEnt::findExpConsEnts (
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   WitCandIndex theIdx;
   WitMrAltPt * theMrAltPt;

   witAssert (myBomEntry_->inEffect (execPer));

   theConsEnts.clear ();

   if (multiChoice ())
      {
      theMrAltPt = myMrAltPt ()[execPer];

      for (theIdx = nCandidates () - 1; theIdx >= 0; theIdx --)
         if (candIsEligible (theIdx, execPer))
            if (! theMrAltPt->prevSel ()[theIdx])
               theConsEnts.push (candidate_[theIdx]);
      }

   if (theConsEnts.isEmpty ())
      theConsEnts.push (myBomEntry_);
   }

//------------------------------------------------------------------------------

void WitMrBomEnt::select (WitConsEntry * theConsEnt, WitPeriod execPer)
   {
   WitCandIndex nCands;
   WitCandIndex theIdx;
   WitCandIndex theSelIdx;

   nCands = nCandidates ();

   if (DEBUG_MODE)
      theSelIdx = -1;
   
   for (theIdx = 0; theIdx < nCands; theIdx ++)
      if (candidate_[theIdx] == theConsEnt)
         {
         theSelIdx = theIdx;

         break;
         }

   witAssert (theSelIdx >= 0);

   myMrAltPt ()[execPer]->select (theSelIdx);
   }

//------------------------------------------------------------------------------

void WitMrBomEnt::initCandidate ()
   {
   WitSubEntry * theSub;
   int           nCands;
   WitCandIndex  theIdx;

   WitObjStack (WitSubEntry) theCands (myProblem ());

   nCands = 1;

   forEachEl (theSub, myBomEntry_->mySubEntries ())
      {
      if (theSub->myPart ()->producingBopEntries ().isEmpty ())
         if (theSub->netAllowed ())
            continue;

      if (! theSub->expAllowed ())
         continue;

      nCands ++;

      theCands.push (theSub);
      }

   candidate_.resize (nCands);

   theIdx = nCands - 1;

   while (theCands.pop (theSub))
      candidate_[theIdx --] = theSub;

   candidate_[0] = myBomEntry_;
   }

//------------------------------------------------------------------------------
// Implementation of class MrComp.
//------------------------------------------------------------------------------

WitMrComp::~WitMrComp ()
   {
   WitPeriod thePer;

   if (multiChoice_)
      forEachPeriod (thePer, myProblem ())
         delete myMrAltPt_[thePer];
   }

//------------------------------------------------------------------------------

WitMrComp::WitMrComp (WitProblem * theProblem):
      WitProbAssoc (theProblem),

      multiChoice_ (witFALSE),
      myMrAltPt_   ()
   {
   }

//------------------------------------------------------------------------------

void WitMrComp::printIfMultiChoice ()
   {
   if (multiChoice_)
      {
      printID ();

      fprintf (msgFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

void WitMrComp::printHasAlt ()
   {
   WitPeriod    thePer;
   WitMrAltPt * theMrAltPt;

   if (! multiChoice_)
      return;

   forEachPeriod (thePer, myProblem ())
      {
      theMrAltPt = myMrAltPt_[thePer];

      if (theMrAltPt->hasAlt ())
         theMrAltPt->printID ();
      }
   }

//------------------------------------------------------------------------------

void WitMrComp::setUp ()
   {
   if (! myGlobalComp ()->multiRoute ())
      return;

   initCandidate ();

   multiChoice_ = (nCandidates () > 1);

   buildMrAltPts ();
   }

//------------------------------------------------------------------------------

void WitMrComp::buildMrAltPts ()
   {
   WitPeriod thePer;

   if (! multiChoice_)
      return;

   myMrAltPt_.allocate (myProblem ());

   forEachPeriod (thePer, myProblem ())
      myMrAltPt_[thePer] = new WitMrAltPt (this, thePer);
   }

//------------------------------------------------------------------------------

WitMrAltPt * WitMrComp::multiChoiceMrAltPtWithAlt (WitPeriod thePer)
   {
   WitMrAltPt * theMrAltPt;

   witAssert (multiChoice_);

   theMrAltPt = myMrAltPt_[thePer];

   return
      theMrAltPt->hasAlt ()?
         theMrAltPt:
         NULL;
   }

//------------------------------------------------------------------------------
// Implementation of class MrAltPt.
//------------------------------------------------------------------------------

WitMrAltPt::WitMrAltPt (WitMrComp * theMrComp, WitPeriod thePer):

      WitAltPt   (),

      myPeriod_  (thePer),
      myMrComp_  (theMrComp),
      selIndex_  (-1),
      hasResAlt_ (witFALSE),
      prevSel_   (theMrComp->nCandidates (), witFALSE)
   {
   WitCandIndex theIdx;

   if (! myMrComp_->compIsEligible (myPeriod_))
      return;

   selectDefault ();

   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myMrComp_->candIsEligible (theIdx, myPeriod_))
         if (theIdx != selIndex_)
            {
            hasResAlt_ = witTRUE;

            break;
            }
   }

//------------------------------------------------------------------------------

WitMrAltPt::~WitMrAltPt ()
   {
   }

//------------------------------------------------------------------------------

WitBoolean WitMrAltPt::hasAlt ()
   {
   if (hasResAlt_)
      return witTRUE;

   if (selIndex_ == -1)
      return witFALSE;

   return ! myMrComp_->candIsDefault (selIndex_, myPeriod_);
   }

//------------------------------------------------------------------------------

void WitMrAltPt::alterSelection ()
   {
   WitCandIndex theIdx;

   witAssert (hasAlt ());

   prevSel_[selIndex_] = witTRUE;
   selIndex_           = -1;
   hasResAlt_          = witFALSE;

   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myMrComp_->candIsEligible (theIdx, myPeriod_))
         if (! prevSel_[theIdx])
            if (selIndex_ == -1)
               selIndex_ = theIdx;
            else
               {
               hasResAlt_ = witTRUE;

               break;
               }

   if (selIndex_ == -1)
      selectDefault ();
   }

//------------------------------------------------------------------------------

void WitMrAltPt::splitSelection (double)
   {
   myMrComp_->myMsgFac () ("internalErrorFmsg", "MrAltPt::splitSelection");
   }

//------------------------------------------------------------------------------

void WitMrAltPt::printSelection ()
   {
   witAssert (selIndex_ >= 0);

   fprintf (msgFile (), "\n");

   printID ();

   fprintf (msgFile (), "   Selected ");

   myMrComp_->printCandidate (selIndex_);

   fprintf (msgFile (),
      ", Has Alt? %s\n",
      myMrComp_->myMsgFac ().booleanText (hasAlt ()));
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrAltPt::mySelMgr (WitSelector * theSelector)
   {
   return myMrComp_->mySelMgr (theSelector);
   }

//------------------------------------------------------------------------------

WitBoolean WitMrAltPt::splittable ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitMrAltPt::printID ()
   {
   myMrComp_->printID ();

   fprintf (msgFile (), ", Period %d\n", myPeriod_);
   }

//------------------------------------------------------------------------------

void WitMrAltPt::select (WitCandIndex theIdx)
   {
   witAssert (theIdx >= 0);

   witAssert (! prevSel_[theIdx]);
 
   witAssert (theIdx != selIndex_);

   selIndex_ = theIdx;
   }

//------------------------------------------------------------------------------

void WitMrAltPt::selectDefault ()
   {
   WitCandIndex theIdx;

   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myMrComp_->candIsDefault (theIdx, myPeriod_))
         {
         selIndex_ = theIdx;

         return;
         }

   myMrComp_->myMsgFac () ("internalErrorFmsg", "WitMrAltPt::selectDefault");
   }

//------------------------------------------------------------------------------

FILE * WitMrAltPt::msgFile ()
   {
   return myMrComp_->msgFile ();
   }

@


1.29
log
@Continuing development of selection splitting.
@
text
@d15 2
a16 2
//    ProdRtr.
//    ConsRtr.
d23 2
a24 2
#include <ProdRtr.h>
#include <ConsRtr.h>
d32 1
a32 1
// Implementation of class ProdRtr.
d35 1
a35 1
WitProdRtr::WitProdRtr (WitSelector * theSelector):
d56 1
a56 1
WitProdRtr::~WitProdRtr ()
d66 1
a66 1
WitBopEntry * WitProdRtr::selBopEntry (WitPart * thePart, WitPeriod thePer)
d73 1
a73 1
WitAltPt * WitProdRtr::myAltPt (
d97 1
a97 1
WitBoolean WitProdRtr::validForExecBounds ()
d104 1
a104 1
void WitProdRtr::printHasAlt ()
d121 1
a121 1
void WitProdRtr::printMultiChoices ()
d137 1
a137 1
void WitProdRtr::modifyRouting (WitBopEntPerStack & theBopEntPers)
d148 1
a148 1
void WitProdRtr::findExpBopEnts (
d158 1
a158 1
WitBoolean WitProdRtr::selIsSplit (WitPart * thePart, WitPeriod expPer)
d170 1
a170 1
void WitProdRtr::startSplitExp (
d188 1
a188 1
void WitProdRtr::recBopEntExpPerSS (
d200 1
a200 1
void WitProdRtr::postCommitSS ()
d209 1
a209 1
void WitProdRtr::postSplitCommit ()
d218 1
a218 1
void WitProdRtr::setupSelSplit ()
d241 1
a241 1
void WitProdRtr::adjustSplitBound (WitTl * theTlObj, double & splitBound)
d250 1
a250 1
void WitProdRtr::prtSelSplit (WitTl * theTlObj)
d272 1
a272 1
// Implementation of class ConsRtr.
d275 1
a275 1
WitConsRtr::WitConsRtr (WitSelector * theSelector):
d298 1
a298 1
WitConsRtr::~WitConsRtr ()
d308 1
a308 1
WitConsEntry * WitConsRtr::selConsEntry (
d317 1
a317 1
WitAltPt * WitConsRtr::myAltPt (
d339 1
a339 1
WitBoolean WitConsRtr::validForExecBounds ()
d346 1
a346 1
void WitConsRtr::printHasAlt ()
d362 1
a362 1
void WitConsRtr::printMultiChoices ()
d377 1
a377 1
void WitConsRtr::modifyRouting (WitConsEntPerStack & theConsEntPers)
d388 1
a388 1
void WitConsRtr::findExpConsEnts (
d398 1
a398 1
WitBoolean WitConsRtr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
d410 1
a410 1
void WitConsRtr::startSplitExp (
d428 1
a428 1
void WitConsRtr::recExpConsEntSS (
d440 1
a440 1
void WitConsRtr::postCommitSS ()
d449 1
a449 1
void WitConsRtr::postSplitCommit ()
d458 1
a458 1
void WitConsRtr::setupSelSplit ()
d483 1
a483 1
void WitConsRtr::adjustSplitBound (WitTl * theTlObj, double & splitBound)
d492 1
a492 1
void WitConsRtr::prtSelSplit (WitTl * theTlObj)
d529 2
a530 2
WitMrPart::WitMrPart (WitPart * thePart, WitProdRtr * theProdRtr):
      WitMrComp  (theProdRtr->myProblem ()),
d532 1
a532 1
      myProdRtr_ (theProdRtr),
d594 1
a594 1
   return theSelector->myProdRtr ();
d690 2
a691 2
WitMrBomEnt::WitMrBomEnt (WitBomEntry * theBomEnt, WitConsRtr * theConsRtr):
      WitMrComp   (theConsRtr->myProblem ()),
d693 1
a693 1
      myConsRtr_  (theConsRtr),
d760 1
a760 1
   return theSelector->myConsRtr ();
@


1.28
log
@Re-worked the controls for selection splitting.
@
text
@d1064 7
@


1.27
log
@Continued implementation of selection splitting.
@
text
@d36 1
a36 1
      WitSelMgr    (theSelector, witFALSE),
d276 1
a276 1
      WitSelMgr     (theSelector, witFALSE),
a1059 7
   }

//------------------------------------------------------------------------------

float WitMrAltPt::splitRes ()
   {
   return 0.0;
@


1.26
log
@Continued implementation of selection splitting with the new design.
@
text
@d209 1
a209 1
void WitProdRtr::clearSplitSched ()
d449 1
a449 1
void WitConsRtr::clearSplitSched ()
d592 7
d758 7
d1053 7
@


1.25
log
@Continued implementation of selection splitting with the new design.
@
text
@d261 4
a264 5
      "   Part:           %s\n"
      "   Exp Per:        %d\n"
      "   Selection:\n"
      "      Operation:   %s\n"
      "      BOP Entry #: %d\n",
d503 4
a506 5
      "   Operation:      %s\n"
      "   BOM Entry #:    %d\n"
      "   Part:           %s\n"
      "   Exec Per:       %d\n"
      "   Selection:\n",
d514 1
a514 1
         "      Self\n");
d517 1
a517 1
         "      Sub #:       %d\n", 
d521 1
a521 1
      "      Part:        %s\n",
d1024 1
a1024 1
void WitMrAltPt::printSelection (WitSelector *)
@


1.24
log
@Continued implementation of selection splitting with the new design.
@
text
@d209 9
d446 9
@


1.23
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d182 2
a183 1
      expVol);
d414 2
a415 1
      theExecVol);
d997 7
@


1.22
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d160 4
a163 5
   witAssert (selSplit ());

   if (myMrPart (thePart)->multiChoice ())
      if (! splitSched_ (thePart, expPer).isEmpty ())
         return witTRUE;
d192 3
a194 4
   witAssert (selSplit ());

   if (myMrPart (theBopEnt->myPart ())->multiChoice ())
      totExpVol_.incCell (theBopEnt, expPer, expVol);
d391 4
a394 5
   witAssert (selSplit ());

   if (myMrBomEnt (theBomEnt)->multiChoice ())
      if (! splitSched_ (theBomEnt, execPer).isEmpty ())
         return witTRUE;
d423 3
a425 4
   witAssert (selSplit ());

   if (myMrBomEnt (theConsEnt->myBomEntry ())->multiChoice ())
      totExecVol_.incCell (theConsEnt, execPer, deltaExecVol);
d1014 7
@


1.21
log
@Implemented coarse selection splitting for penalized execution.
@
text
@a26 1
#include <Selector.h>
d29 1
d35 2
a36 2
WitProdRtr::WitProdRtr (WitHeurAllPerf * theHeurAllPerf):
      WitSelMgr    (theHeurAllPerf),
a140 4
   WitPart *     thePart;

   if (selSplit ())
      preAltAttSS ();
d143 1
a143 11
      {
      thePart = theBopEnt->myPart ();

      if (selSplit ())
         splitSel (selBopEntry (thePart, expPer), expPer);

      myMrPart (thePart)->select (theBopEnt, expPer);
      }

   if (selSplit ())
      postAltAttSS ();
d201 1
a201 22
void WitProdRtr::postCommitSS (WitBoolean tempSuccess)
   {
   witAssert (selSplit ());

   if (tempSuccess)
      totExpVol_.saveAndClear ();
   else
      totExpVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitProdRtr::preAltAttSS ()
   {
   witAssert (selSplit ());

   totExpVol_.restore ();
   }

//------------------------------------------------------------------------------

void WitProdRtr::postAltAttSS ()
a209 29
void WitProdRtr::postPermCommitSS ()
   {
   witAssert (selSplit ());

   totExpVol_ .clear ();
   totExpVol_ .saveAndClear ();
   splitSched_.clear ();
   }

//------------------------------------------------------------------------------

void WitProdRtr::splitSel (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   double totExpVolVal;

   witAssert (selSplit ());

   totExpVolVal = totExpVol_ (theBopEnt, expPer);

   if (totExpVolVal > 0.0)
      splitSched_.slowAppend (
         theBopEnt->myPart (),
         expPer, 
         asaTlPtr (theBopEnt),
         totExpVolVal);
   }

//------------------------------------------------------------------------------

d268 2
a269 2
WitConsRtr::WitConsRtr (WitHeurAllPerf * theHeurAllPerf):
      WitSelMgr     (theHeurAllPerf),
a373 4
   WitBomEntry *  theBomEnt;

   if (selSplit ())
      preAltAttSS ();
d376 1
a376 11
      {
      theBomEnt = theConsEnt->myBomEntry ();

      if (selSplit ())
         splitSel (selConsEntry (theBomEnt, execPer), execPer);

      myMrBomEnt (theBomEnt)->select (theConsEnt, execPer);
      }

   if (selSplit ())
      postAltAttSS ();
d434 1
a434 22
void WitConsRtr::postCommitSS (WitBoolean tempSuccess)
   {
   witAssert (selSplit ());

   if (tempSuccess)
      totExecVol_.saveAndClear ();
   else
      totExecVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitConsRtr::preAltAttSS ()
   {
   witAssert (selSplit ());

   totExecVol_.restore ();
   }

//------------------------------------------------------------------------------

void WitConsRtr::postAltAttSS ()
a442 29
void WitConsRtr::postPermCommitSS ()
   {
   witAssert (selSplit ());

   totExecVol_.clear ();
   totExecVol_.saveAndClear ();
   splitSched_.clear ();
   }

//------------------------------------------------------------------------------

void WitConsRtr::splitSel (WitConsEntry * theConsEnt, WitPeriod execPer)
   {
   double totExecVolVal;

   witAssert (selSplit ());

   totExecVolVal = totExecVol_ (theConsEnt, execPer);

   if (totExecVolVal > 0.0)
      splitSched_.slowAppend (
         theConsEnt->myBomEntry (),
         execPer, 
         asaTlPtr (theConsEnt),
         totExecVolVal);
   }

//------------------------------------------------------------------------------

a532 7
void WitMrPart::splitSel (WitPeriod thePer)
   {
   myProdRtr_->splitSel (selBopEntry (thePer), thePer);
   }

//------------------------------------------------------------------------------

a789 7
void WitMrBomEnt::splitSel (WitPeriod thePer)
   {
   myConsRtr_->splitSel (selConsEntry (thePer), thePer);
   }

//------------------------------------------------------------------------------

a979 3

   if (myMrComp_->myGlobalComp ()->selSplit ())
      myMrComp_->splitSel (myPeriod_);
@


1.20
log
@Further implementation of coarse selection splitting.
@
text
@d141 4
d147 11
a157 1
      myMrPart (theBopEnt->myPart ())->select (theBopEnt, expPer);
d438 4
d444 11
a454 1
      myMrBomEnt (theConsEnt->myBomEntry ())->select (theConsEnt, execPer);
d663 1
a663 2
   if (multiChoice ())
      myProdRtr_->splitSel (selBopEntry (thePer), thePer);
d927 1
a927 2
   if (multiChoice ())
      myConsRtr_->splitSel (selConsEntry (thePer), thePer);
@


1.19
log
@Further implementation of coarse selection splitting.
@
text
@d251 1
a251 1
      splitSched_.push (
d534 1
a534 1
      splitSched_.push (
@


1.18
log
@Continued development of coarse selection splitting.
@
text
@d283 1
a283 1
void WitProdRtr::adjustSplitVol (WitTl * theTlObj, double & splitVol)
d287 1
a287 1
   splitVol -= totExpVol_ (asaBopEntry (theTlObj), splitExpPer_);
d568 1
a568 1
void WitConsRtr::adjustSplitVol (WitTl * theTlObj, double & splitVol)
d572 1
a572 1
   splitVol -= totExecVol_ (asaConsEntry (theTlObj), splitExecPer_);
@


1.17
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d50 1
a50 1
   if (myGlobalComp ()->selSplit ())
d160 2
d193 2
d203 2
d215 2
d224 2
d233 2
d246 2
d265 2
d285 2
d296 2
d335 1
a335 1
   if (myGlobalComp ()->selSplit ())
d443 2
d476 2
d486 2
d498 2
d507 2
d516 2
d529 2
d548 2
d570 2
d580 2
@


1.16
log
@Further development of coarse selection splitting.
@
text
@d158 11
d179 1
a179 1
      splitSched_ (thePart, expPer),
d186 1
a186 1
void WitProdRtr::recExpBopEntSS (
d230 1
a230 12
WitBoolean WitProdRtr::selIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   if (myMrPart (thePart)->multiChoice ())
      if (! splitSched_ (thePart, expPer).isEmpty ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitProdRtr::splitSel (WitBopEntry * theBopEnt, WitPeriod thePer)
d234 1
a234 1
   totExpVolVal = totExpVol_ (theBopEnt, thePer);
d239 1
a239 1
         thePer, 
d421 11
d433 1
a433 1
      WitBomEntry * theBomEntry, 
d437 1
a437 1
   witAssert (selIsSplit (theBomEntry, execPer));
d442 2
a443 2
      splitSched_ (theBomEntry, execPer),
      asaTlPtr (selConsEntry (theBomEntry, execPer)),
d493 1
a493 12
WitBoolean WitConsRtr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   if (myMrBomEnt (theBomEnt)->multiChoice ())
      if (! splitSched_ (theBomEnt, execPer).isEmpty ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitConsRtr::splitSel (WitConsEntry * theConsEnt, WitPeriod thePer)
d495 1
a495 1
   double totExpVolVal;
d497 1
a497 1
   totExpVolVal = totExecVol_ (theConsEnt, thePer);
d499 1
a499 1
   if (totExpVolVal > 0.0)
d502 1
a502 1
         thePer, 
d504 1
a504 1
         totExpVolVal);
@


1.15
log
@Implemented and used class SelMgr.
@
text
@d36 1
a36 1
      WitSelMgr       (theHeurAllPerf),
d38 4
a41 8
      myMrPartTl_     (),
      splitSched_     (myProblem ()),
      totExpVol_      (myProblem ()),
      splitExpActive_ (witFALSE),
      splitExpPart_   (NULL),
      splitExpPer_    (-1),
      splitNetExpVol_ (0.0),
      splitList_      (myProblem ())
a162 8
   WitPairStItr (WitBopEntry, double) theItr;
   WitBopEntry *                      theBopEnt;
   double                             splitVol;

   witAssert (! splitExpActive_);

   witAssert (! hadFinSplit ());

d165 1
a165 8
   if (DEBUG_MODE)
      splitExpActive_ = witTRUE;

   splitExpPart_   = thePart;
   splitExpPer_    = expPer;
   splitNetExpVol_ = expVol;

   splitList_.clear ();
d167 4
a170 57
   theItr.attachTo (splitSched_ (thePart, expPer));

   while (theItr.advance (theBopEnt, splitVol))
      {
      splitVol -= totExpVol_ (theBopEnt, expPer);

      if (splitVol > NET_TOL)
         splitList_.push (theBopEnt, splitVol);
      }
   }

//------------------------------------------------------------------------------

WitBoolean WitProdRtr::findNextSplit (
      WitBopEntry * & theBopEnt, 
      double &        splitExpVol)
   {
   WitBoolean finSplit;
   double     splitVol;

   if (splitNetExpVol_ <= NET_TOL)
      return witFALSE;

   finSplit = splitList_.pop (theBopEnt, splitVol);

   if (! finSplit)
      theBopEnt = selBopEntry (splitExpPart_, splitExpPer_);

   if (finSplit && (splitVol < splitNetExpVol_))
      {
      splitExpVol      = splitVol;
      splitNetExpVol_ -= splitVol;
      }
   else
      {
      splitExpVol     = splitNetExpVol_;
      splitNetExpVol_ = 0.0;
      }

   if (myGlobalComp ()->selPrintLevel () >= 4)
      prtSelSplit (theBopEnt, finSplit, splitVol);

   setHadFinSplit (finSplit);

   return witTRUE;
   }

//------------------------------------------------------------------------------

void WitProdRtr::finishSplitExp ()
   {
   witAssert (splitExpActive_);

   setHadFinSplit (witFALSE);

   if (DEBUG_MODE)
      splitExpActive_ = witFALSE;
d240 1
a240 1
         theBopEnt,
d267 8
a274 4
void WitProdRtr::prtSelSplit (
      WitBopEntry * theBopEnt,
      WitBoolean    finSplit,
      double        splitVol)
d276 1
a276 1
   witAssert (myGlobalComp ()->selPrintLevel () >= 4);
d278 1
a278 2
   if (myHeurAllPerf ()->myAllocMode ()->temp ())
      return;
a291 7
               
   if (finSplit)
      fprintf (msgFile (),
         "      SplitVol:    %.3f\n", splitVol);
   else
      fprintf (msgFile (),
         "      SplitVol:    Infinity\n");
d299 1
a299 1
      WitSelMgr         (theHeurAllPerf),
d301 4
a304 8
      myMrBomEntTl_     (),
      totExecVol_       (myProblem ()),
      splitSched_       (myProblem ()),
      splitExpActive_   (witFALSE),
      splitExpBomEntry_ (NULL),
      splitExecPer_     (-1),
      splitNetExecVol_  (0.0),
      splitList_        (myProblem ())
a425 8
   WitPairStItr (WitConsEntry, double) theItr;
   WitConsEntry *                      theConsEnt;
   double                              splitVol;

   witAssert (! splitExpActive_);

   witAssert (! hadFinSplit ());

d428 1
a428 10
   if (DEBUG_MODE)
      splitExpActive_ = witTRUE;

   splitExpBomEntry_ = theBomEntry;
   splitExecPer_     = execPer;
   splitNetExecVol_  = theExecVol;

   splitList_.clear ();

   theItr.attachTo (splitSched_ (theBomEntry, execPer));
d430 4
a433 55
   while (theItr.advance (theConsEnt, splitVol))
      {
      splitVol -= totExecVol_ (theConsEnt, execPer);

      if (splitVol > NET_TOL)
         splitList_.push (theConsEnt, splitVol);
      }
   }

//------------------------------------------------------------------------------

WitBoolean WitConsRtr::findNextSplit (
      WitConsEntry * & theConsEnt, 
      double &         splitExecVol)
   {
   WitBoolean finSplit;
   double     splitVol;

   if (splitNetExecVol_ <= NET_TOL)
      return witFALSE;

   finSplit = splitList_.pop (theConsEnt, splitVol);

   if (! finSplit)
      theConsEnt = selConsEntry (splitExpBomEntry_, splitExecPer_);

   if (finSplit && (splitVol < splitNetExecVol_))
      {
      splitExecVol      = splitVol;
      splitNetExecVol_ -= splitVol;
      }
   else
      {
      splitExecVol     = splitNetExecVol_;
      splitNetExecVol_ = 0.0;
      }

   if (myGlobalComp ()->selPrintLevel () >= 4)
      prtSelSplit (theConsEnt, finSplit, splitVol);

   setHadFinSplit (finSplit);

   return witTRUE;
   }

//------------------------------------------------------------------------------

void WitConsRtr::finishSplitExp ()
   {
   witAssert (splitExpActive_);

   setHadFinSplit (witFALSE);

   if (DEBUG_MODE)
      splitExpActive_ = witFALSE;
d503 1
a503 1
         theConsEnt,
d532 8
a539 4
void WitConsRtr::prtSelSplit (
      WitConsEntry * theConsEnt,
      WitBoolean     finSplit,
      double         splitVol)
d541 1
a541 1
   witAssert (myGlobalComp ()->selPrintLevel () >= 4);
d543 1
a543 2
   if (myHeurAllPerf ()->myAllocMode ()->temp ())
      return;
d548 4
a551 4
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Part:        %s\n"
      "   Exec Per:    %d\n"
d563 1
a563 1
         "      Sub #:    %d\n", 
d567 1
a567 1
      "      Part:     %s\n",
a568 8

   if (finSplit)
      fprintf (msgFile (),
         "      SplitVol: %.3f\n", 
         splitVol);
   else
      fprintf (msgFile (),
         "      SplitVol: Infinity\n");
@


1.14
log
@Fixed some bugs in coarse selection splitting.
@
text
@d28 2
a29 1
#include <PairSt.h>
d35 2
a36 2
WitProdRtr::WitProdRtr (WitProblem * theProblem):
      WitProbAssoc  (theProblem),
d38 8
a45 3
      myMrPartTl_   (),
      mySplitSched_ (myProblem ()),
      totExpVol_    (myProblem ())
d78 5
a82 3
      WitPart *    thePart,
      WitPeriod    prodPer,
      WitBoolean & resFound)
d84 1
d87 3
a89 1
   theMrAltPt = myMrPart (thePart)->myMrAltPtWithAlt (prodPer);
d101 7
d162 85
d284 3
a286 3
   totExpVol_   .clear ();
   totExpVol_   .saveAndClear ();
   mySplitSched_.clear ();
d294 1
a294 1
      if (! mySplitSched_ (thePart, expPer).isEmpty ())
d309 1
a309 1
      mySplitSched_.push (
a317 27
void WitProdRtr::getSplitList (
      WitPart *           thePart,
      WitPeriod           expPer,
      WitBopEntDblStack & splitList)
   {
   WitPairStItr (WitBopEntry, double) theItr;
   WitBopEntry *                      theBopEnt;
   double                             splitVol;

   splitList.clear ();

   if (! myMrPart (thePart)->multiChoice ())
      return;

   theItr.attachTo (mySplitSched_ (thePart, expPer));

   while (theItr.advance (theBopEnt, splitVol))
      {
      splitVol -= totExpVol_ (theBopEnt, expPer);

      if (splitVol > NET_TOL)
         splitList.push (theBopEnt, splitVol);
      }
   }

//------------------------------------------------------------------------------

d323 2
a324 2
   totExpVol_   .allocate1D ();
   mySplitSched_.allocate1D ();
d333 1
a333 1
         mySplitSched_.allocateRow (thePart);
a340 1
      WitPeriod     expPer,
d346 3
d358 1
a358 1
      expPer,
d374 2
a375 2
WitConsRtr::WitConsRtr (WitProblem * theProblem):
      WitProbAssoc  (theProblem),
d377 8
a384 3
      myMrBomEntTl_ (),
      totExecVol_   (myProblem ()),
      mySplitSched_ (myProblem ())
d421 5
a425 3
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      WitBoolean &  resFound)
d429 2
a430 1
   theMrAltPt = myMrBomEnt (theBomEnt)->myMrAltPtWithAlt (execPer);
d442 7
d501 85
d623 3
a625 3
   totExecVol_  .clear ();
   totExecVol_  .saveAndClear ();
   mySplitSched_.clear ();
d633 1
a633 1
      if (! mySplitSched_ (theBomEnt, execPer).isEmpty ())
d648 1
a648 1
      mySplitSched_.push (
a656 26
void WitConsRtr::getSplitList (
      WitBomEntry *        theBomEnt, 
      WitPeriod            execPer,
      WitConsEntDblStack & splitList)
   {
   WitPairStItr (WitConsEntry, double) theItr;
   WitConsEntry *                      theConsEnt;
   double                              splitVol;

   witAssert (myMrBomEnt (theBomEnt)->multiChoice ());

   splitList.clear ();

   theItr.attachTo (mySplitSched_ (theBomEnt, execPer));

   while (theItr.advance (theConsEnt, splitVol))
      {
      splitVol -= totExecVol_ (theConsEnt, execPer);

      if (splitVol > NET_TOL)
         splitList.push (theConsEnt, splitVol);
      }
   }

//------------------------------------------------------------------------------

d662 2
a663 2
   totExecVol_  .allocate1D ();
   mySplitSched_.allocate1D ();
d674 1
a674 1
         mySplitSched_.allocateRow (theBomEnt);
a681 1
      WitPeriod      execPer,
d687 3
d701 1
a701 1
      execPer);
@


1.13
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d35 1
a35 1
      WitProbAssoc      (theProblem),
d37 3
a39 4
      myMrPartTl_       (),
      mySplitSched_     (myProblem ()),
      totExpVol_        (myProblem ()),
      expBopEntIsSplit_ (witFALSE)
d78 1
a78 4
   theMrAltPt = 
      expBopEntIsSplit_?
         NULL:
         myMrPart (thePart)->myMrAltPtWithAlt (prodPer);
d128 1
a128 1
   while (theBopEntPers.get (theBopEnt, expPer))
d188 1
a188 1
WitBoolean WitProdRtr::routingIsSplit (WitPart * thePart, WitPeriod expPer)
d206 1
a206 1
      mySplitSched_.put (
d236 1
a236 1
         splitList.put (theBopEnt, splitVol);
a241 7
void WitProdRtr::setExpBopEntIsSplit (WitBoolean theValue)
   {
   expBopEntIsSplit_ = theValue;
   }

//------------------------------------------------------------------------------

d263 1
a263 16
void WitProdRtr::prtRtSplitAtPart (WitPart * thePart, WitPeriod expPer)
   {
   witAssert (myGlobalComp ()->selPrintLevel () >= 4);

   fprintf (msgFile (),
      "\n"
      "Routing Split at a Part:\n"
      "   Part:    %s\n"
      "   Exp Per: %d\n",
      thePart->partName ().myCstring (),
      expPer);
   }

//------------------------------------------------------------------------------

void WitProdRtr::prtRtSplitToBopEnt (
d265 2
a266 1
      WitBoolean    splitFound,
d273 4
a276 1
      "   Routing:\n"
d279 2
d284 1
a284 1
   if (splitFound)
d297 1
a297 1
      WitProbAssoc       (theProblem),
d299 3
a301 4
      myMrBomEntTl_      (),
      totExecVol_        (myProblem ()),
      mySplitSched_      (myProblem ()),
      expConsEntIsSplit_ (witFALSE)
d344 1
a344 4
   theMrAltPt = 
      expConsEntIsSplit_?
         NULL:
         myMrBomEnt (theBomEnt)->myMrAltPtWithAlt (execPer);
d392 1
a392 1
   while (theConsEntPers.get (theConsEnt, execPer))
d452 1
a452 3
WitBoolean WitConsRtr::routingIsSplit (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer)
d470 1
a470 1
      mySplitSched_.put (
d499 1
a499 1
         splitList.put (theConsEnt, splitVol);
a504 7
void WitConsRtr::setExpConsEntIsSplit (WitBoolean theValue)
   {
   expConsEntIsSplit_ = theValue;
   }

//------------------------------------------------------------------------------

d528 5
a532 1
void WitConsRtr::prtRtSplitAtBomEnt (WitBomEntry * theBomEnt, WitPeriod execPer)
d538 1
a538 1
      "Routing Split at a BOM Entry:\n"
d541 6
a546 3
      "   Exec Per:    %d\n",
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex (),
a547 3
   }

//------------------------------------------------------------------------------
a548 11
void WitConsRtr::prtRtSplitToConsEnt (
      WitConsEntry * theConsEnt,
      WitBoolean     splitFound,
      double         splitVol)
   {
   witAssert (myGlobalComp ()->selPrintLevel () >= 4);

   fprintf (msgFile (), 
      "\n"
      "   Routing:\n");
                  
d557 5
a561 1
   if (splitFound)
d659 1
a659 1
               theBopEnts.put (candidate_[theIdx]);
d664 1
a664 1
         theBopEnts.put (myPart_->expBopEntry (expPer));
d712 1
a712 1
         theCands.put (theBopEnt);
d719 1
a719 1
   while (theCands.get (theBopEnt))
d729 1
a729 1
   prereqs.put (theBopEnt->myOperation ()->bom ().first ()->myPart ());
d822 1
a822 1
               theConsEnts.put (candidate_[theIdx]);
d826 1
a826 1
      theConsEnts.put (myBomEntry_);
d886 1
a886 1
      theCands.put (theSub);
d893 1
a893 1
   while (theCands.get (theSub))
@


1.12
log
@Coarse selection splitting.
@
text
@d28 1
a28 1
#include <StackItr.h>
a184 1
   mySplitSched_.clear ();
d187 1
d222 1
a222 1
      WitBopEntDblStack & theSplitList)
d224 3
a226 3
   WitPairStackItr (WitBopEntry, double) theItr;
   WitBopEntry *                         theBopEnt;
   double                                splitVol;
d228 1
a228 1
   theSplitList.clear ();
d240 1
a240 1
         theSplitList.put (theBopEnt, splitVol);
d258 3
d266 1
a266 1
               totExpVol_.allocate (theBopEnt);
d268 1
a268 1
         mySplitSched_.allocate (thePart);
d273 40
a468 1
   mySplitSched_.clear ();
d471 1
d508 1
a508 1
      WitConsEntDblStack & theSplitList)
d510 3
a512 3
   WitPairStackItr (WitConsEntry, double) theItr;
   WitConsEntry *                         theConsEnt;
   double                                 splitVol;
d516 1
a516 1
   theSplitList.clear ();
d525 1
a525 1
         theSplitList.put (theConsEnt, splitVol);
d543 3
d549 1
a549 1
         totExecVol_.allocate (theBomEnt);
d553 1
a553 1
               totExecVol_.allocate (theSub);
d555 1
a555 1
         mySplitSched_.allocate (theBomEnt);
d557 47
@


1.11
log
@Fixed some bugs in coarse selection splitting.
@
text
@d15 2
a16 1
//    MrMgr.
d23 2
a24 1
#include <MrMgr.h>
a26 2
#include <ExpRest.h>
#include <RtAn.h>
d31 1
a31 1
// Implementation of class MrMgr.
d34 2
a35 2
WitMrMgr::WitMrMgr (WitSelector * theSelector):
      WitProbAssoc        (theSelector),
d37 4
a40 11
      myExpRest_          (NULL),
      myRtAnalyzer_       (NULL),
      myMrPartTl_         (),
      myMrBomEntTl_       (),
      penExec_            (witFALSE),
      myPartSplitSched_   (myProblem ()),
      totExpVol_          (myProblem ()),
      myBomEntSplitSched_ (myProblem ()),
      ssmrForBopEnts_     (witFALSE),
      expBopEntIsSplit_   (witFALSE),
      expConsEntIsSplit_  (witFALSE)
d42 1
a42 2
   WitPart *     thePart;
   WitBomEntry * theBomEnt;
d44 1
a44 4
   myMsgFac () ("multiRouteMsg");

   myMrPartTl_  .allocate (myProblem (), NULL);
   myMrBomEntTl_.allocate (myProblem (), NULL);
a48 3
   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt) = new WitMrBomEnt (theBomEnt, this);

a50 2

   setupPenExec (theSelector);
d55 1
a55 1
WitMrMgr::~WitMrMgr ()
d57 1
a57 8
   WitPart *     thePart;
   WitBomEntry * theBomEnt;

   if (penExec_)
      {
      delete myRtAnalyzer_;
      delete myExpRest_;
      }
a60 3

   forEachBomEntry (theBomEnt, myProblem ())
      delete myMrBomEnt (theBomEnt);
d65 1
a65 1
WitBopEntry * WitMrMgr::selBopEntry (WitPart * thePart, WitPeriod thePer)
d72 1
a72 32
WitConsEntry * WitMrMgr::selConsEntry (
      WitBomEntry * theBomEnt, 
      WitPeriod     thePer)
   {
   return myMrBomEnt (theBomEnt)->selConsEntry (thePer);
   }

//------------------------------------------------------------------------------

WitAltPt * WitMrMgr::myAltPt (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      WitBoolean &  resFound)
   {
   WitMrAltPt * theMrAltPt;

   theMrAltPt = 
      expConsEntIsSplit_?
         NULL:
         myMrBomEnt (theBomEnt)->myMrAltPtWithAlt (execPer);

   resFound = 
      (theMrAltPt != NULL)?
         theMrAltPt->hasResAlt ():
         witFALSE;

   return theMrAltPt;
   }

//------------------------------------------------------------------------------

WitAltPt * WitMrMgr::myAltPt (
d94 1
a94 1
void WitMrMgr::printHasAlt ()
d96 1
a96 2
   WitPart *     thePart;
   WitBomEntry * theBomEnt;
d101 1
a101 1
      "Multi-Route Alt Points with Alternative(s):\n\n");
a105 3
   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt)->printHasAlt ();

d111 1
a111 1
void WitMrMgr::printMultiChoices ()
d113 1
a113 2
   WitPart *     thePart;
   WitBomEntry * theBomEnt;
d118 1
a118 1
      "Multi-Route Components with multi-choice:\n"
a122 3

   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt)->printIfMultiChoice ();
d127 1
a127 1
void WitMrMgr::modifyRouting (WitPart * thePart, WitPeriod thePer)
d129 2
a130 7
   WitBopEntry *  theBopEnt;
   WitPeriod      expPer;
   WitConsEntry * theConsEnt;
   WitPeriod      execPer;

   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());
d132 1
a132 9
   witAssert (penExec_);

   myRtAnalyzer_->analyzeRoutings (
      thePart, 
      thePer, 
      modBopEntPers,
      modConsEntPers);

   while (modBopEntPers.get (theBopEnt, expPer))
a133 10

   while (modConsEntPers.get (theConsEnt, execPer))
      myMrBomEnt (theConsEnt->myBomEntry ())->select (theConsEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitMrMgr::recCommitVol (double commitVol, WitBoolean byExp)
   {
   myRtAnalyzer_->recCommitVol (commitVol, byExp);
d138 1
a138 1
void WitMrMgr::findExpBopEnts (
d148 1
a148 11
void WitMrMgr::findExpConsEnts (
      WitBomEntry *     theBomEnt,
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   myMrBomEnt (theBomEnt)->findExpConsEnts (execPer, theConsEnts);
   }

//------------------------------------------------------------------------------

void WitMrMgr::recExpBopEntSS (
d159 1
a159 12
void WitMrMgr::recExpConsEntSS (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer, 
      double         deltaExecVol)
   {
   if (myMrBomEnt (theConsEnt->myBomEntry ())->multiChoice ())
      totExpVol_.incCell (theConsEnt, execPer, deltaExecVol);
   }

//------------------------------------------------------------------------------

void WitMrMgr::postCommitSS (WitBoolean tempSuccess)
d169 1
a169 1
void WitMrMgr::preAltAttSS ()
d176 1
a176 1
void WitMrMgr::postAltAttSS ()
d183 1
a183 1
void WitMrMgr::postPermCommitSS ()
d185 3
a187 4
   myPartSplitSched_  .clear ();
   myBomEntSplitSched_.clear ();
   totExpVol_         .clear ();
   totExpVol_         .saveAndClear ();
d192 1
a192 1
WitBoolean WitMrMgr::routingIsSplit (WitPart * thePart, WitPeriod expPer)
d195 1
a195 1
      if (! myPartSplitSched_ (thePart, expPer).isEmpty ())
d203 1
a203 12
WitBoolean WitMrMgr::routingIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   if (myMrBomEnt (theBomEnt)->multiChoice ())
      if (! myBomEntSplitSched_ (theBomEnt, execPer).isEmpty ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitMrMgr::splitSel (WitBopEntry * theBopEnt, WitPeriod thePer)
d210 1
a210 1
      myPartSplitSched_.put (
d219 1
a219 1
void WitMrMgr::getSplitList (
d233 1
a233 1
   theItr.attachTo (myPartSplitSched_ (thePart, expPer));
d246 1
a246 1
void WitMrMgr::setExpBopEntIsSplit (WitBoolean theValue)
d253 194
a446 1
void WitMrMgr::splitSel (WitConsEntry * theConsEnt, WitPeriod thePer)
d450 1
a450 1
   totExpVolVal = totExpVol_ (theConsEnt, thePer);
d453 1
a453 1
      myBomEntSplitSched_.put (
d462 1
a462 1
void WitMrMgr::getSplitList (
d475 1
a475 1
   theItr.attachTo (myBomEntSplitSched_ (theBomEnt, execPer));
d479 1
a479 1
      splitVol -= totExpVol_ (theConsEnt, execPer);
d488 1
a488 1
void WitMrMgr::setExpConsEntIsSplit (WitBoolean theValue)
d495 1
a495 17
void WitMrMgr::setupPenExec (WitSelector * theSelector)
   {
   penExec_ = myGlobalComp ()->penExec ();

   if (! penExec_)
      return;

   myMsgFac () ("penExecMsg");

   myExpRest_    = new WitExpRest    (myProblem ());

   myRtAnalyzer_ = new WitRtAnalyzer (this, theSelector);
   }

//------------------------------------------------------------------------------

void WitMrMgr::setupSelSplit ()
a496 2
   WitPart *     thePart;
   WitBopEntry * theBopEnt;
a499 12
   forEachPart (thePart, myProblem ())
      if (myMrPart (thePart)->multiChoice ())
         {
         ssmrForBopEnts_ = witTRUE;

         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expAllowed ())
               totExpVol_ .allocate (theBopEnt);

         myPartSplitSched_.allocate (thePart);
         }

d503 1
a503 1
         totExpVol_         .allocate (theBomEnt);
d507 1
a507 1
               totExpVol_   .allocate (theSub);
d509 1
a509 1
         myBomEntSplitSched_.allocate (theBomEnt);
d517 2
a518 2
WitMrPart::WitMrPart (WitPart * thePart, WitMrMgr * theMrMgr):
      WitMrComp  (theMrMgr),
d520 1
d538 1
a538 1
      myMrMgr ()->splitSel (selBopEntry (thePer), thePer);
d679 2
a680 2
WitMrBomEnt::WitMrBomEnt (WitBomEntry * theBomEnt, WitMrMgr * theMrMgr):
      WitMrComp   (theMrMgr),
d682 1
d803 1
a803 1
      myMrMgr ()->splitSel (selConsEntry (thePer), thePer);
d857 2
a858 2
WitMrComp::WitMrComp (WitMrMgr * theMrMgr):
      WitProbAssoc (theMrMgr),
a859 1
      myMrMgr_     (theMrMgr),
@


1.10
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d45 3
a47 1
      ssmrForBopEnts_     (witFALSE)
d114 4
a117 1
   theMrAltPt = myMrBomEnt (theBomEnt)->myMrAltPtWithAlt (execPer);
d136 4
a139 1
   theMrAltPt = myMrPart (thePart)->myMrAltPtWithAlt (prodPer);
d271 1
a271 1
      totExpVol_.save ();
a286 1
   totExpVol_.unsave ();
d296 2
d367 7
d412 7
@


1.9
log
@Further development of coarse selection splitting.
@
text
@d28 1
d35 1
a35 1
      WitProbAssoc    (theSelector),
d37 9
a45 7
      myExpRest_      (NULL),
      myRtAnalyzer_   (NULL),
      myMrPartTl_     (),
      myMrBomEntTl_   (),
      penExec_        (witFALSE),
      totExecVol_     (myProblem ()),
      splitListSched_ (myProblem ())
d56 1
a56 1
      myMrPart (thePart) = new WitMrPart (thePart);
a58 1
      {
d61 2
a62 6
      if (myMrBomEnt (theBomEnt)->multiChoice ())
         {
         totExecVol_    .allocate (theBomEnt);
         splitListSched_.allocate (theBomEnt);
         }
      }
d202 1
a202 1
   while (modBopEntPers.pop (theBopEnt, expPer))
d205 1
a205 1
   while (modConsEntPers.pop (theConsEnt, execPer))
d238 11
d251 1
a251 1
      WitPeriod      thePer, 
d254 2
a255 6
   WitBomEntry * theBomEnt;

   theBomEnt = theConsEnt->myBomEntry ();

   if (myMrBomEnt (theBomEnt)->multiChoice ())
      totExecVol_.incCell (theBomEnt, thePer, deltaExecVol);
d263 1
a263 1
      totExecVol_.save ();
d265 1
a265 1
      totExecVol_.clear ();
d272 1
a272 1
   totExecVol_.restore ();
d279 2
a280 2
   totExecVol_.unsave ();
   totExecVol_.clear ();
d287 2
a288 1
   splitListSched_.clear ();
d293 23
a315 4
void WitMrMgr::getSplitList (
      WitBomEntry *        theBomEnt, 
      WitPeriod            execPer,
      WitConsEntDblStack & theSplitList)
d317 3
a319 3
   double         netExecVol;
   WitConsEntry * theConsEnt;
   double         splitVol;
d321 7
a327 3
   if (! myMrBomEnt (theBomEnt)->multiChoice ())
      {
      theSplitList.clear ();
d329 1
a329 2
      return;
      }
d331 8
a338 1
   theSplitList.reverseCopyOf (splitListSched_ (theBomEnt, execPer));
d340 1
a340 1
   netExecVol = totExecVol_ (theBomEnt, execPer);
d342 1
a342 1
   if (netExecVol == 0.0)
d345 3
a347 1
   while (theSplitList.pop (theConsEnt, splitVol))
d349 1
a349 5
      net (netExecVol, splitVol);

      if (splitVol >= NET_TOL)
         {
         theSplitList.push (theConsEnt, splitVol);
d351 2
a352 5
         return;
         }

      if (netExecVol < NET_TOL)
         return;
d358 9
a366 12
void WitMrMgr::splitSel (
      WitBomEntry *  theBomEnt, 
      WitPeriod      thePer, 
      WitConsEntry * theConsEnt)
   {
   double totExecVolVal;

   totExecVolVal = totExecVol_ (theBomEnt, thePer);

   if (totExecVolVal > 0.0)
      splitListSched_.push (
         theBomEnt, 
d369 27
a395 1
         totExecVolVal);
d415 34
d452 2
a453 2
WitMrPart::WitMrPart (WitPart * thePart):
      WitMrComp  (thePart->myProblem ()),
d469 1
a469 1
void WitMrPart::splitSel (WitPeriod)
d471 2
d536 1
a536 1
               theBopEnts.push (candidate_[theIdx]);
d541 1
a541 1
         theBopEnts.push (myPart_->expBopEntry (expPer));
d589 1
a589 1
         theCands.push (theBopEnt);
d596 1
a596 1
   while (theCands.pop (theBopEnt))
a597 4

   if (myGlobalComp ()->selSplit ())
      if (nCands > 1)
         myMsgFac () ("selSplitBopMrSmsg");
d606 1
a606 1
   prereqs.push (theBopEnt->myOperation ()->bom ().first ()->myPart ());
d614 1
a614 1
      WitMrComp   (theBomEnt->myProblem ()),
a616 1
      myMrMgr_    (theMrMgr),
d698 1
a698 1
               theConsEnts.push (candidate_[theIdx]);
d702 1
a702 1
      theConsEnts.push (myBomEntry_);
d736 1
a736 1
      myMrMgr_->splitSel (myBomEntry_, thePer, selConsEntry (thePer));
d762 1
a762 1
      theCands.push (theSub);
d769 1
a769 1
   while (theCands.pop (theSub))
d790 2
a791 2
WitMrComp::WitMrComp (WitProblem * theProblem):
      WitProbAssoc (theProblem),
d793 1
@


1.8
log
@Futher development of selection splitting.
@
text
@d34 1
a34 1
      WitProbAssoc   (theSelector),
d36 7
a42 7
      myExpRest_     (NULL),
      myRtAnalyzer_  (NULL),
      myMrPartTl_    (),
      myMrBomEntTl_  (),
      penExec_       (witFALSE),
      nonEmpSplits_  (myProblem ()),
      totExecVol_    (myProblem ())
d60 4
a63 1
         totExecVol_.allocate (theBomEnt);
d282 1
a282 7
   WitMrBomEnt * theMrBomEnt;
   WitPeriod     thePer;

   witAssert (myGlobalComp ()->selSplit ());

   while (nonEmpSplits_.pop (theMrBomEnt, thePer))
      theMrBomEnt->clearSplitList (thePer);
d292 32
a323 1
   myMrBomEnt (theBomEnt)->getSplitList (execPer, theSplitList);
d328 4
a331 1
void WitMrMgr::firstSplit (WitMrBomEnt * theMrBomEnt, WitPeriod thePer)
d333 10
a342 1
   nonEmpSplits_.push (theMrBomEnt, thePer);
d533 1
a533 2
      candidate_  (),
      splitList_  ()
a534 2
   WitPeriod thePer;

a535 9

   if (myGlobalComp ()->selSplit ())
      if (multiChoice ())
         {
         splitList_ .allocate (myProblem ());

         forEachPeriod (thePer, myProblem ())
            splitList_[thePer] = new WitConsEntDblStack (myProblem ());
         }
a541 6
   WitPeriod thePer;

   if (myGlobalComp ()->selSplit ())
      if (multiChoice ())
         forEachPeriod (thePer, myProblem ())
            delete splitList_[thePer];
a648 47
void WitMrBomEnt::clearSplitList (WitPeriod thePer)
   {
   splitList_ (thePer).clear ();
   }

//------------------------------------------------------------------------------

void WitMrBomEnt::getSplitList (
      WitPeriod            execPer, 
      WitConsEntDblStack & theSplitList)
   {
   double         netExecVol;
   WitConsEntry * theConsEnt;
   double         splitVol;

   if (! multiChoice ())
      {
      theSplitList.clear ();

      return;
      }

   theSplitList.reverseCopyOf (splitList_ (execPer));

   netExecVol = myMrMgr_->totExecVol (myBomEntry_, execPer);

   if (netExecVol == 0.0)
      return;

   while (theSplitList.pop (theConsEnt, splitVol))
      {
      net (netExecVol, splitVol);

      if (splitVol >= NET_TOL)
         {
         theSplitList.push (theConsEnt, splitVol);

         return;
         }

      if (netExecVol < NET_TOL)
         return;
      }
   }

//------------------------------------------------------------------------------

d651 2
a652 14
   double totExecVolVal;

   if (! multiChoice ())
      return;

   totExecVolVal = myMrMgr_->totExecVol (myBomEntry_, thePer);

   if (totExecVolVal == 0.0)
      return;

   if (splitList_ (thePer).isEmpty ())
      myMrMgr_->firstSplit (this, thePer);

   splitList_ (thePer).push (selConsEntry (thePer), totExecVolVal);
@


1.7
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@d41 2
a42 3
      nzExecVols_    (myProblem ()),
      savedExecVols_ (myProblem ()),
      nonEmpSplits_  (myProblem ())
d56 1
d59 4
d242 1
a242 6
   WitMrBomEnt * theMrBomEnt;

   theMrBomEnt = myMrBomEnt (theConsEnt->myBomEntry ());

   if (! theMrBomEnt->multiChoice ())
      return;
d244 1
a244 1
   theMrBomEnt->incTotExecVol (thePer, deltaExecVol);
d246 2
a247 1
   nzExecVols_.push (theMrBomEnt, thePer);
a253 6
   WitMrBomEnt * theMrBomEnt;
   WitPeriod     thePer;
   double        theExecVol;

   witAssert (myGlobalComp ()->selSplit ());

d255 1
a255 12
      {
      savedExecVols_.clear ();

      while (nzExecVols_.pop (theMrBomEnt, thePer))
         {
         theExecVol = theMrBomEnt->totExecVol ()[thePer];

         savedExecVols_.push (theMrBomEnt, thePer, theExecVol);

         theMrBomEnt->setTotExecVol (thePer, 0.0);
         }
      }
d257 1
a257 1
      clearExecVols ();
d264 1
a264 10
   WitMrBomEnt * theMrBomEnt;
   WitPeriod     thePer;
   double        theValue;

   while (savedExecVols_.pop (theMrBomEnt, thePer, theValue))
      {
      theMrBomEnt->setTotExecVol (thePer, theValue);

      nzExecVols_.push (theMrBomEnt, thePer);
      }
d271 2
a272 5
   witAssert (myGlobalComp ()->selSplit ());

   clearExecVols ();

   savedExecVols_.clear ();
a321 11

void WitMrMgr::clearExecVols ()
   {
   WitMrBomEnt * theMrBomEnt;
   WitPeriod     thePer;

   while (nzExecVols_.pop (theMrBomEnt, thePer))
      theMrBomEnt->setTotExecVol (thePer, 0.0);
   }

//------------------------------------------------------------------------------
a493 1
      totExecVol_ (),
a502 1
         totExecVol_.allocate (myProblem (), 0.0);
a626 14
void WitMrBomEnt::incTotExecVol (WitPeriod thePer, double deltaExecVol)
   {
   totExecVol_[thePer] += deltaExecVol;
   }

//------------------------------------------------------------------------------

void WitMrBomEnt::setTotExecVol (WitPeriod thePer, double theValue)
   {
   totExecVol_[thePer] = theValue;
   }

//------------------------------------------------------------------------------

d651 1
a651 1
   netExecVol = totExecVol_[execPer];
d676 12
a687 5
   if (multiChoice ())
      if (totExecVol_[thePer] > 0.0)
         {
         if (splitList_ (thePer).isEmpty ())
            myMrMgr_->firstSplit (this, thePer);
d689 1
a689 2
         splitList_ (thePer).push (selConsEntry (thePer), totExecVol_[thePer]);
         }
@


1.6
log
@Some minor modifications.
@
text
@d40 4
a43 1
      penExec_       (witFALSE)
d57 1
a57 1
      myMrBomEnt (theBomEnt) = new WitMrBomEnt (theBomEnt);
a99 10
void WitMrMgr::getSplitList (
      WitBomEntry *        theBomEnt, 
      WitPeriod            execPer,
      WitConsEntDblStack & theSplitList)
   {
   myMrBomEnt (theBomEnt)->getSplitList (execPer, theSplitList);
   }

//------------------------------------------------------------------------------

a137 44
void WitMrMgr::setSplitVol (
      WitBomEntry * theBomEnt, 
      WitPeriod     thePer, 
      double        theValue)
   {
   myMrBomEnt (theBomEnt)->setSplitVol (thePer, theValue);
   }

//------------------------------------------------------------------------------

void WitMrMgr::postTempCommitSS (WitBoolean success)
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt)->postTempCommitSS (success);
   }

//------------------------------------------------------------------------------

void WitMrMgr::postAltAttSS ()
   {
   WitBomEntry * theBomEnt;

   witAssert (myGlobalComp ()->selSplit ());

   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt)->postAltAttSS ();
   }

//------------------------------------------------------------------------------

void WitMrMgr::postPermCommitSS ()
   {
   WitBomEntry * theBomEnt;

   witAssert (myGlobalComp ()->selSplit ());

   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt)->postPermCommitSS ();
   }

//------------------------------------------------------------------------------

d233 103
d351 11
d528 2
a529 2
WitMrBomEnt::WitMrBomEnt (WitBomEntry * theBomEnt):
      WitMrComp    (theBomEnt->myProblem ()),
d531 5
a535 5
      myBomEntry_  (theBomEnt),
      candidate_   (),
      curSplitVol_ (),
      okSplitVol_  (),
      splitList_   ()
d544 2
a545 3
         curSplitVol_.allocate (myProblem (), 0.0);
         okSplitVol_ .allocate (myProblem (), 0.0);
         splitList_  .allocate (myProblem ());
a565 9
void WitMrBomEnt::splitSel (WitPeriod thePer)
   {
   if (multiChoice ())
      if (okSplitVol_[thePer] > 0.0)
         splitList_ (thePer).push (selConsEntry (thePer), okSplitVol_[thePer]);
   }

//------------------------------------------------------------------------------

d669 1
a669 1
void WitMrBomEnt::postTempCommitSS (WitBoolean success)
d671 2
a672 2
   if (! multiChoice ())
      return;
d674 1
a674 2
   if (success)
      okSplitVol_ = curSplitVol_;
d676 3
a678 1
   curSplitVol_ = 0.0;
d683 1
a683 1
void WitMrBomEnt::setSplitVol (WitPeriod thePer, double theValue)
d685 1
a685 2
   if (multiChoice ())
      curSplitVol_[thePer] = theValue;
d694 6
a699 3
   if (multiChoice ())
      theSplitList.reverseCopyOf (splitList_ (execPer));
   else
a700 1
   }
d702 20
a721 1
//------------------------------------------------------------------------------
d723 3
a725 4
void WitMrBomEnt::postAltAttSS ()
   {
   if (multiChoice ())
      okSplitVol_ = 0.0;
d730 1
a730 1
void WitMrBomEnt::postPermCommitSS ()
d732 5
a736 1
   WitPeriod thePer;
d738 2
a739 5
   witAssert (myGlobalComp ()->selSplit ());

   if (multiChoice ())
      forEachPeriod (thePer, myProblem ())
         splitList_ (thePer).clear ();
@


1.5
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d265 3
a267 3
      WitPart *                      thePart, 
      WitPeriod                      expPer,
      WitObjDynStack (WitBopEntry) & theBopEnts)
d275 3
a277 3
      WitBomEntry *                   theBomEnt,
      WitPeriod                       execPer,
      WitObjDynStack (WitConsEntry) & theConsEnts)
d370 1
a370 3
void WitMrPart::findExpBopEnts (
      WitPeriod                      expPer,
      WitObjDynStack (WitBopEntry) & theBopEnts)
d425 4
a428 5
   WitBopEntry * theBopEnt;
   int           nCands;
   WitCandIndex  theIdx;

   WitObjDynStack (WitBopEntry) theCands (myProblem ());
d455 2
a456 2
      WitObjDynStack (WitPart) & prereqs, 
      WitBopEntry *              theBopEnt)
d564 2
a565 2
      WitPeriod                       execPer,
      WitObjDynStack (WitConsEntry) & theConsEnts)
d676 1
a676 1
   WitObjDynStack (WitSubEntry) theCands (myProblem ());
@


1.4
log
@Refactoring for selection splitting.
@
text
@d34 1
a34 1
      WitProbAssoc  (theSelector),
d36 5
a40 6
      myExpRest_    (NULL),
      myRtAnalyzer_ (NULL),
      ssConsEnt_    (NULL),
      myMrPartTl_   (),
      myMrBomEntTl_ (),
      penExec_      (witFALSE)
a80 9
WitBoolean WitMrMgr::splitting ()
   {
   witAssert (myGlobalComp ()->selSplit ());

   return witFALSE;
   }

//------------------------------------------------------------------------------

d97 4
a100 1
void WitMrMgr::findSelConsEntries (WitBomEntry * theBomEnt, WitPeriod execPer)
d102 1
a102 3
   witAssert (myGlobalComp ()->selSplit ());

   ssConsEnt_ = selConsEntry (theBomEnt, execPer);
a106 16
void WitMrMgr::findNextConsEntry (
      WitConsEntry * & theConsEnt,
      WitBoolean &     splitVolFinite,
      double &         splitVolVal)
   {
   witAssert (myGlobalComp ()->selSplit ());

   witAssert (ssConsEnt_ != NULL);

   theConsEnt     = ssConsEnt_;
   splitVolFinite = witFALSE;
   ssConsEnt_     = NULL;
   }
 
//------------------------------------------------------------------------------

d145 44
d237 2
a238 2
   WitBopEntPerDynStack  modBopEntPers  (myProblem ());
   WitConsEntPerDynStack modConsEntPers (myProblem ());
d319 6
d449 4
d469 1
a469 1
      WitMrComp   (theBomEnt->myProblem ()),
d471 5
a475 2
      myBomEntry_ (theBomEnt),
      candidate_  ()
d477 2
d480 11
d497 15
d619 54
d863 3
@


1.3
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d126 2
a127 11

   if (tempParIsSet (1))
      {
      splitVolFinite = witTRUE;
      splitVolVal    = myGlobalComp ()->tempParAsFloat (1);
      }
   else
      {
      splitVolFinite = witFALSE;
      ssConsEnt_     = NULL;
      }
d284 1
a284 1
      WitMrComp    (thePart->myProblem ()),
d286 2
a287 2
      myPart_      (thePart),
      candidateTl_ ()
d302 1
a302 1
   return (candidate (theIdx) == myPart_->expBopEntry (thePer));
d309 1
a309 1
   return candidateTl_.length ();
d323 1
a323 1
   return candidate (theIdx)->expEligible (thePer);
d339 2
a340 2
      candidate (theIdx)->myOperationName ().myCstring (),
      candidate (theIdx)->localIndex ());
d356 1
a356 1
      theMrAltPt = myMrAltPt (expPer);
d361 1
a361 1
               theBopEnts.push (candidate (theIdx));
d383 1
a383 1
      if (candidate (theIdx) == theBopEnt)
d392 1
a392 1
   myMrAltPt (expPer)->select (theSelIdx);
d418 1
a418 1
   candidateTl_.resize (nCands);
d423 1
a423 1
      candidate (theIdx --) = theBopEnt;
d440 1
a440 1
      WitMrComp    (theBomEnt->myProblem ()),
d442 2
a443 2
      myBomEntry_  (theBomEnt),
      candidateTl_ ()
d458 1
a458 1
   return (candidate (theIdx) == myBomEntry_);
d465 1
a465 1
   return candidateTl_.length ();
d479 1
a479 1
   return candidate (theIdx)->inEffect (thePer);
d496 1
a496 1
   if (candidate (theIdx)->isaSubEntry ())
d499 1
a499 1
         candidate (theIdx)->localIndex ());
d519 1
a519 1
      theMrAltPt = myMrAltPt (execPer);
d524 1
a524 1
               theConsEnts.push (candidate (theIdx));
d545 1
a545 1
      if (candidate (theIdx) == theConsEnt)
d554 1
a554 1
   myMrAltPt (execPer)->select (theSelIdx);
d583 1
a583 1
   candidateTl_.resize (nCands);
d588 1
a588 1
      candidate (theIdx --) = theSub;
d590 1
a590 1
   candidate (0) = myBomEntry_;
d603 1
a603 1
         delete myMrAltPt (thePer);
d612 1
a612 1
      myMrAltPtTl_ ()
d640 1
a640 1
      theMrAltPt = myMrAltPt (thePer);
d670 1
a670 1
   myMrAltPtTl_.allocate (myProblem (), NULL);
d673 1
a673 1
      (WitMrAltPt * &) myMrAltPtTl_[thePer] = new WitMrAltPt (this, thePer);
d684 1
a684 1
   theMrAltPt = myMrAltPt (thePer);
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@a27 2
#include <DynStack.h>
#include <DynPer.h>
d38 1
d82 9
d107 34
d227 2
a228 2
   WitDynPerStack (WitBopEntry)  modBopEntPers  (myProblem ());
   WitDynPerStack (WitConsEntry) modConsEntPers (myProblem ());
d255 3
a257 3
      WitPart *                   thePart, 
      WitPeriod                   expPer,
      WitDynStack (WitBopEntry) & theBopEnts)
d265 3
a267 3
      WitBomEntry *                theBomEnt,
      WitPeriod                    execPer,
      WitDynStack (WitConsEntry) & theConsEnts)
d355 2
a356 2
      WitPeriod                   expPer,
      WitDynStack (WitBopEntry) & theBopEnts)
d415 1
a415 1
   WitDynStack (WitBopEntry) theCands (myProblem ());
d438 2
a439 2
      WitDynStack (WitPart) & prereqs, 
      WitBopEntry *           theBopEnt)
d516 2
a517 2
      WitPeriod                    execPer,
      WitDynStack (WitConsEntry) & theConsEnts)
d574 1
a574 1
   WitDynStack (WitSubEntry) theCands (myProblem ());
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

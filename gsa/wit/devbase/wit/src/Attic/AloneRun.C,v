head	1.79;
access;
symbols
	sce_410_withVa:1.78
	sce_4_05_20040511:1.66
	sce_4_00_20040201:1.53
	nextGenBranch:1.42.0.2
	nextGenRoot:1.42
	sce_3_30_20030627:1.42
	EndRw-branch:1.39.0.4
	Root-of-EndRw:1.39
	rwToStl:1.39.0.2
	latest_sce_3_10_20010924:1.23.0.2
	sce_3_10_20010924:1.23
	latest_sce_3_00_20010601:1.13.0.2
	sce_3_00_20010601:1.13
	latest_sce_2_31_20010308:1.11.0.2
	sce_2_31_20010308:1.11
	latest_sce_2_31_20001003:1.8.0.2
	sce_2_31_20001003:1.8
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.79
date	2005.09.08.19.29.44;	author rjw;	state dead;
branches;
next	1.78;

1.78
date	2005.09.07.19.29.51;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2005.09.06.20.43.26;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2005.08.31.22.11.00;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2005.08.31.19.00.36;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2005.08.24.19.26.42;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2005.08.23.17.38.57;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2005.08.22.20.38.58;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2005.08.19.23.24.11;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2005.08.19.21.38.02;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.06.13.16.48.46;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.02.24.23.23.54;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.01.28.19.34.25;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.20.18.42.08;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.20.18.25.21;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.19.22.16.27;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.08.22.24.24;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.30.00.05.33;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.26.22.29.41;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.18.19.25.56;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.12.15.09.23;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.10.22.53.18;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.08.16.54.29;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.30.20.09.48;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.16.20.23.24;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.05.23.37.33;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.31.23.18.57;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.12.31.21.44.52;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.23.22.24.31;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.23.16.18.46;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.08.19.27.43;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.02.16.39.32;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.03.18.09.57;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.01.21.01.38;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.01.20.44.28;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.23.18.12.32;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.02.23.40.35;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.02.22.18.16;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.09.06.19.56.06;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.26.22.48.59;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.08.23.21.00.31;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.23.18.09.09;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.08.14.16.09.46;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.24.23.15.15;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.24.18.38.09;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.08.19.21.46;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.07.20.14.52;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.03.23.16.34;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.24.20.05.28;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.24.18.26.03;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.18.14.02.25;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.29.23.47.06;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.12.18.01.07;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.11.23.31.10;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.21.22.36.29;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.06.17.31.06;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.03.18.40.39;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.01.17.55.07;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.01.14.55.29;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.30.15.12.08;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.28.00.48.32;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.27.21.28.37;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.25.16.08.12;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.02.02.11.26;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.17.20.02.18;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.17.15.11.12;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.04.22.07.34;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.21.20.03.19;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.06.18.45.06;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.02.20.43.10;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.24.19.55.17;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.31.16.16.11;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.31.15.42.24;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.10.21.57.09;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.10.19.56.41;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.12;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.17;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.17;	author wit;	state Exp;
branches;
next	;


desc
@@


1.79
log
@[multi-thread]
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "AloneRun.C"
//
// Contains the implementation of class AloneRun.
//------------------------------------------------------------------------------

#include <AloneRun.h>
#include <ParamMgr.h>
#include <WitRun.h>
#include <ApiMgr.h>
#include <CompMgr.h>
#include <wit/src/Variant.h>
#include <OptImp.h>
#include <FSS.h>
#include <DataWrit.h>
#include <Global.h>
#include <OptComp.h>
#include <Material.h>
#include <BopEntry.h>
#include <BoundSet.h>
#include <PipMgr.h>
#include <ObjStack.h>
#include <IVRealArg.h>
#include <Timing.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class AloneRun.
//------------------------------------------------------------------------------

inline const WitString & WitAloneRun::stringParamVal (const char * paramName)
   {
   return myParamMgr_->stringParamVal (paramName);
   }

//------------------------------------------------------------------------------

inline const char * WitAloneRun::cStringParamVal (const char * paramName)
   {
   return stringParamVal (paramName).myCstring ();
   }

//------------------------------------------------------------------------------

inline int WitAloneRun::intParamVal (const char * paramName)
   {
   return myParamMgr_->intParamVal (paramName);
   }

//------------------------------------------------------------------------------

inline const WitString & WitAloneRun::choiceParamVal (const char * paramName)
   {
   return myParamMgr_->choiceParamVal (paramName);
   }

//------------------------------------------------------------------------------

inline bool WitAloneRun::boolParamVal (const char * paramName)
   {
   return myParamMgr_->boolParamVal (paramName);
   }

//------------------------------------------------------------------------------

WitAloneRun::WitAloneRun ():
      myWitRun_   (NULL),
      myTimer_    (NULL),
      mySession_  (NULL),
      myParamMgr_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitAloneRun::~WitAloneRun ()
   {
   delete myParamMgr_;
   delete myTimer_;
   delete myWitRun ();
   }

//------------------------------------------------------------------------------

void WitAloneRun::execute (int argc, char * argv[])
   {
   myWitRun_ = WitRun::newInstance ();

   try
      {
      myWitRun_->myApiMgr ()->startApiFunc ("witStandAlone", true, true);
         //
         // Note: "witStandAlone" is not a real API function.
         // This call causes myWitRun ()->mySession () to be the current
         // Session.

      mySession_  = myWitRun ()->mySession ();

      myTimer_    = new WitTimer (myMsgFac ());
      myParamMgr_ = new WitParamMgr (this, argc, argv);

      setUp ();

      WitTimer::enterSection ("other");

      readInput ();

      preprocess ();

      performAction ();

      if (choiceParamVal ("action") == "mrp")
         printMrp ();
      else
         printImplosion ();

      WitTimer::enterSection ("freeMemory");

      myMsgFac ().setMaxTimesIssued ("headingMsg", 0);

      myWitRun ()->witInitialize ();

      WitTimer::leaveSection ("freeMemory");

      WitTimer::leaveSection ("other");

      myTimer_->display ();

      myMsgFac () ("normalTermMsg");

      delete myTimer_;

      myTimer_ = NULL;

      myWitRun ()->myApiMgr ()->finishApiFunc ();
      }

   catch (std::bad_alloc)
      {
      myWitRun_->myApiMgr ()->handleBadAllocExc ();
      }

   delete myWitRun ();

   myWitRun_ = NULL;
   }

//------------------------------------------------------------------------------

void WitAloneRun::setUp ()
   {
   myWitRun ()->myApiMgr ()->setApiMode (false);
      //
      // Set API Mode to false to indicate running in stand-alone mode.

   setUpMsg ();

   myWitRun ()->witInitialize ();
   }

//------------------------------------------------------------------------------

void WitAloneRun::setUpMsg ()
   {
   myMsgFac ().setAccessMode ("w+");
      //
      // Overwrite existing files

   myMsgFac ().setDisplayExternalNumberByLevel (
      WitINFORMATIONAL_MESSAGES,
      false);

   myMsgFac ().setMaxTimesIssued ("witFuncCalled",     0);
   myMsgFac ().setMaxTimesIssued ("setStringAttrMsg",  0);
   myMsgFac ().setMaxTimesIssued ("witFileParam",      0);
   myMsgFac ().setMaxTimesIssued ("setIntAttrMsg",     0);
   myMsgFac ().setMaxTimesIssued ("setDblAttrMsg",     0);
   myMsgFac ().setMaxTimesIssued ("getAttrMsg",        0);
   myMsgFac ().setMaxTimesIssued ("setBooleanAttrMsg", 0);
   myMsgFac ().setMaxTimesIssued ("fileFormatMsg",     0);
   }

//------------------------------------------------------------------------------

void WitAloneRun::readInput ()
   {
   myParamMgr_->procParams ();

   myMsgFac () ("readDataMsg");

   myWitRun ()->witReadData (cStringParamVal ("data_ifname"));

   if (myProblem ()->myGlobalComp ()->pauses ())
      myProblem ()->pauseForInput ();

   if (stringParamVal ("data_ifname2") != "")
      {
      myMsgFac () ("genericMsg", "Reading the second input data file.");

      myWitRun ()->witReadData (cStringParamVal ("data_ifname2"));
      }

   if (boolParamVal ("makeVolServ"))
      makeVolServObj ();

   if (boolParamVal ("print_echo"))
      {
      myMsgFac () ("writeEchoMsg");

      myWitRun ()->witDisplayData (cStringParamVal ("echo_ofname"));
      }
   }

//------------------------------------------------------------------------------

void WitAloneRun::preprocess ()
   {
   myWitRun ()->witPreprocess ();

   if (myOptImploder ()->optImpMode ())
      if (
               (choiceParamVal ("action") == "preproc")
            or (choiceParamVal ("action") == "opt")
            or (choiceParamVal ("action") == "eval"))

         myProblem ()->optPreprocess ();

   if (boolParamVal ("writeData"))
      {
      myMsgFac () ("genericMsg", "Writing the input data file.");

      myWitRun ()->witWriteData (cStringParamVal ("data_ofname"));
      }

   if (boolParamVal ("print_pre"))
      {
      if (myCompMgr ()->myGlobalComp ()->autoPriority ())
         myProblem ()->genPriorities ();

      myMsgFac () ("writePreprocMsg");

      myWitRun ()->witDisplayData (cStringParamVal ("pre_ofname"));
      }

   if (boolParamVal ("print_global"))
      {
      myMsgFac () ("writeGlobalMsg");

      myProblem ()->displayGlobalData ();
      }
   }

//------------------------------------------------------------------------------

void WitAloneRun::performAction ()
   {
   const WitString & actionString = choiceParamVal ("action");

   if      (actionString == "preproc")
      {
      if (boolParamVal ("print_soln"))
         myProblem ()->postprocess ();
      }

   else if (actionString == "mrp")
      myWitRun ()->witMrp ();

   else if (actionString == "heur")
      myWitRun ()->witHeurImplode ();

   else if (actionString == "opt")
      myOptImploder ()->implode ();

   else if (actionString == "eval")
      {
      myOptImploder ()->evalObjectives ();

      myCompMgr ()->myOptComp ()->objChoice ()->writeValues ();
      }

   if (boolParamVal ("invokePip"))
      {
      if (boolParamVal ("print_echo"))
         myWitRun ()->witDisplayData ("pipd.out");

      myProblem ()->myPipMgr ()->buildPegging ();

      if (myProblem ()->myGlobalComp ()->pauses ())
         myProblem ()->pauseForInput ();
      }
   }

//------------------------------------------------------------------------------

void WitAloneRun::printMrp ()
   {
   myMsgFac () ("writeReqSchedMsg");

   myWitRun ()->witWriteReqSched (cStringParamVal ("mrpsup_ofname"), WitBSV);

   if (boolParamVal ("print_soln"))
      {
      myMsgFac () ("writeMrpSolnMsg");

      myProblem ()->writeMrpSoln (cStringParamVal ("soln_ofname"));
      }
   }

//------------------------------------------------------------------------------

void WitAloneRun::printImplosion ()
   {
   if (boolParamVal ("compVolServ"))
      compVolServ ();

   if (boolParamVal ("print_exec"))
      {
      myMsgFac () ("writeExecSchedMsg");

      myWitRun ()->witWriteExecSched (cStringParamVal ("exec_ofname"), WitBSV);
      }

   if (boolParamVal ("print_ship"))
      {
      myMsgFac () ("writeShipSchedMsg");

      myWitRun ()->witWriteShipSched (cStringParamVal ("ship_ofname"), WitBSV);
      }

   if (boolParamVal ("print_soln"))
      {
      if (myProblem ()->currentVariant ()->internalSoln ())
         doFss ();

      myMsgFac () ("writeSolnMsg");

      myProblem ()->writeSoln (cStringParamVal ("soln_ofname"));
      }

   if (intParamVal ("n_critical") != 0)
      {
      myMsgFac () ("writeCriticalListMsg");

      myWitRun ()->witWriteCriticalList (
         cStringParamVal ("critical_ofname"),
         WitBSV,
         intParamVal ("n_critical"));
      }

   if (boolParamVal ("writeSolnData"))
      {
      myMsgFac () ("genericMsg", "Writing the solution data file.");

      myProblem ()->myDataWriter ()->writeSolnData (
         cStringParamVal ("sdata_ofname"));
      }
   }

//------------------------------------------------------------------------------

void WitAloneRun::doFss ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      theDemand->setFocusHorizon (myProblem ()->lastPeriod ());

   myProblem ()->myFSS ()->compute ();
   }

//------------------------------------------------------------------------------

void WitAloneRun::makeVolServObj ()
   {
   WitDemand *      theDemand;
   WitPeriod        thePer;
   double           totCumDemandVol;
   WitTVec <double> theCumShipReward (myProblem (), 0.0);

   clearObj1 ();

   totCumDemandVol = 0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         totCumDemandVol += theDemand->cumDemandVol ()[thePer];

   stronglyAssert (totCumDemandVol >= .001);

   theCumShipReward = (100.0 / totCumDemandVol);

   forEachDemand (theDemand, myProblem ())
      theDemand->setCumShipReward (theCumShipReward.myCVec ());
   }

//------------------------------------------------------------------------------

void WitAloneRun::clearObj1 ()
   {
   WitPart *        thePart;
   WitMaterial *    theMat;
   WitOperation *   theOpn;
   WitSubEntry *    theSub;
   WitDemand *      theDemand;
   WitTVec <double> the0Vector (myProblem (),  0.0);

   stronglyAssert (myCompMgr ()->myOptComp ()->myObjFunc1 ()->isChosen ());

   forEachPart (thePart, myProblem ())
      thePart->setScrapCost (the0Vector.myCVec ());

   forEachMaterial (theMat, myProblem ())
      theMat->setStockCost (the0Vector.myCVec ());

   forEachOperation (theOpn, myProblem ())
      theOpn->setExecCost (the0Vector.myCVec ());

   forEachSubEntry (theSub, myProblem ())
      theSub->setSubCost (the0Vector.myCVec ());

   forEachDemand (theDemand, myProblem ())
      theDemand->setShipReward (the0Vector.myCVec ());

   forEachDemand (theDemand, myProblem ())
      theDemand->setCumShipReward (the0Vector.myCVec ());
   }

//------------------------------------------------------------------------------

void WitAloneRun::compVolServ ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      totCumDemandVol;
   double      totCumShipVol;

   totCumDemandVol = 0;
   totCumShipVol   = 0;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         totCumDemandVol += theDemand->cumDemandVol ()[thePer];
         totCumShipVol   += theDemand->cumShipVol   ()[thePer];
         }

   if (totCumDemandVol < .001)
      fprintf (myMsgFac ().myFile (),
         "\n"
         "Volume Serviceability: undefined.\n\n");
   else
      fprintf (myMsgFac ().myFile (),
         "\n"
         "Volume Serviceability: %9.6f%%\n\n",
         100.0 * (totCumShipVol / totCumDemandVol));
   }

//------------------------------------------------------------------------------

bool WitAloneRun::tempParIsSet (int index)
   {
   return myProblem ()->myGlobalComp ()->tempParIsSet (index);
   }
@


1.78
log
@[multi-thread]
@
text
@@


1.77
log
@[multi-thread]
@
text
@d117 1
a117 3
      if (boolParamVal ("doAction"))
         {
         preprocess ();
d119 1
a119 1
         performAction ();
d121 4
a124 5
         if (choiceParamVal ("action") == "mrp")
            printMrp ();
         else
            printImplosion ();
         }
d126 1
a126 3
      if (not boolParamVal ("reOpt"))
         {
         WitTimer::enterSection ("freeMemory");
d128 1
a128 1
         myMsgFac ().setMaxTimesIssued ("headingMsg", 0);
d130 1
a130 1
         myWitRun ()->witInitialize ();
d132 1
a132 2
         WitTimer::leaveSection ("freeMemory");
         }
a137 4
      if (myOptImploder ()->optImpMode ())
         if (boolParamVal ("reOpt"))
            testReOpt ();

a204 9
   if (boolParamVal ("allNstn"))
      applyNstn ();

   if (boolParamVal ("selSplitAll"))
      setAllSelSplits ();

   if (boolParamVal ("copy"))
      testCopyData ();

a214 9
   if (boolParamVal ("resetBounds"))
      resetBoundSets ();

   if (boolParamVal ("clearLS"))
      clearLotSizes ();

   if (boolParamVal ("purge"))
      myCompMgr ()->purgeData ();

a224 25
void WitAloneRun::resetBoundSets ()
   {
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitDemand *    theDemand;

   WitDblFlexVec zeroVec (myProblem (),  0.0);
   WitDblFlexVec neg1Vec (myProblem (), -1.0);

   stronglyAssert (false);

   myMsgFac ().setMaxTimesIssued ("setBoundVecAttrMsg", 0);

   forEachMaterial (theMat, myProblem ())
      theMat->stockBounds      ()->set (zeroVec, zeroVec, neg1Vec);

   forEachOperation (theOpn, myProblem ())
      theOpn->execBounds       ()->set (zeroVec, zeroVec, neg1Vec);

   forEachDemand (theDemand, myProblem ())
      theDemand->cumShipBounds ()->set (zeroVec, zeroVec, neg1Vec);
   }

//------------------------------------------------------------------------------

a303 14
void WitAloneRun::clearLotSizes ()
   {
   WitTVec <double> the0Vector (myProblem (),  0.0);
   WitOperation *   theOpn;

   forEachOperation (theOpn, myProblem ())
      {
      theOpn->setMinLotSize (the0Vector.myCVec ());
      theOpn->setIncLotSize (the0Vector.myCVec ());
      }
   }

//------------------------------------------------------------------------------

a338 7
   if (boolParamVal ("sparseFss"))
      {
      doFss ();

      printSparseFss ();
      }

d346 1
a346 3
      myProblem ()->writeSoln (
         cStringParamVal  ("soln_ofname"), 
         boolParamVal ("fssFromInput"));
d374 2
a375 3
   if (not boolParamVal ("fssFromInput"))
      forEachDemand (theDemand, myProblem ())
         theDemand->setFocusHorizon (myProblem ()->lastPeriod ());
a381 72
void WitAloneRun::printSparseFss ()
   {
   WitPart * thePart;
   WitPeriod thePer;

   myMsgFac () ("sparseFssHeadMsg");

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (thePart->focShortageVol ()[thePer] > FLOAT_EPSILON)
            myMsgFac () ("sparseFssDataMsg",
               thePart->partName (),
               thePer,
               thePart->focShortageVol ()[thePer]);
   }

//------------------------------------------------------------------------------

void WitAloneRun::testReOpt ()
   {
   myTimer_->reset ();

   WitTimer::enterSection ("other");

   myWitRun ()->witReadData ("../re-opt.data");

   myOptImploder ()->setModelOFName   ("model-ro.out");
   myOptImploder ()->setOmSolnOFName ("omSoln-ro.out");

   myWitRun ()->witSetOslMesgFileName   ("osl-ro.log");
   myWitRun ()->witSetSolverLogFileName ("coin-ro.log");

   myOptImploder ()->implode ();

   WitTimer::leaveSection ("other");

   WitTimer::enterSection ("freeMemory");

   myWitRun ()->witInitialize ();

   WitTimer::leaveSection ("freeMemory");

   fprintf (myMsgFac ().myFile (), "\nTimings for re-opt-implosion:\n");

   myTimer_->display ();

   fprintf (myMsgFac ().myFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitAloneRun::testCopyData ()
   {
   WitRun * copyRun;

   copyRun = WitRun::newInstance ();

   copyRun->myMsgFac ().setDisplayExternalNumberByLevel (
      WitINFORMATIONAL_MESSAGES,
      false);

   copyRun->witInitialize ();

   copyRun->witCopyData (myWitRun ());

   copyRun->witDisplayData ("copy.out");

   delete copyRun;
   }

//------------------------------------------------------------------------------

a468 29
void WitAloneRun::applyNstn ()
   {
   WitMaterial * theMat;

   forEachMaterial (theMat, myProblem ())
      if (not theMat->buildNstn ())
         if (not theMat->buildAsap ())
            theMat->setBuildNstn (true);
   }

//------------------------------------------------------------------------------

void WitAloneRun::setAllSelSplits ()
   {
   WitMaterial * theMat;
   WitBopEntry * theBopEnt;

   forEachMaterial (theMat, myProblem ())
      if (theMat->nstnBaNeeded () or theMat->buildAsap ())
         theMat->setBaSelSplit (true);

   if (myProblem ()->myGlobalComp ()->multiExec ())
      forEachBopEntry (theBopEnt, myProblem ())
         if (theBopEnt->expAllowed ())
            theBopEnt->setMeSelSplit (true);
   }

//------------------------------------------------------------------------------

@


1.76
log
@[multi-thread]
@
text
@d98 9
a106 4
   myWitRun_->myApiMgr ()->startApiFunc ("witStandAlone", true, true);
      //
      // Note: "witStandAlone" is not a real API function.
      // This call causes myWitRun ()->mySession () to be the current Session.
d108 2
a109 1
   mySession_  = myWitRun ()->mySession ();
d111 1
a111 2
   myTimer_    = new WitTimer (myMsgFac ());
   myParamMgr_ = new WitParamMgr (this, argc, argv);
d113 1
a113 1
   setUp ();
d115 1
a115 1
   WitTimer::enterSection ("other");
d117 3
a119 1
   readInput ();
d121 1
a121 3
   if (boolParamVal ("doAction"))
      {
      preprocess ();
d123 5
a127 1
      performAction ();
d129 3
a131 5
      if (choiceParamVal ("action") == "mrp")
         printMrp ();
      else
         printImplosion ();
      }
d133 1
a133 3
   if (not boolParamVal ("reOpt"))
      {
      WitTimer::enterSection ("freeMemory");
d135 1
a135 1
      myMsgFac ().setMaxTimesIssued ("headingMsg", 0);
d137 2
a138 1
      myWitRun ()->witInitialize ();
d140 1
a140 2
      WitTimer::leaveSection ("freeMemory");
      }
d142 1
a142 1
   WitTimer::leaveSection ("other");
d144 3
a146 1
   myTimer_->display ();
d148 1
a148 3
   if (myOptImploder ()->optImpMode ())
      if (boolParamVal ("reOpt"))
         testReOpt ();
d150 1
a150 1
   myMsgFac () ("normalTermMsg");
d152 1
a152 1
   delete myTimer_;
d154 2
a155 1
   myTimer_ = NULL;
d157 4
a160 1
   myWitRun ()->myApiMgr ()->finishApiFunc ();
a174 4
   WitNonClass::set_new_handler (newError);
      //
      // Set the C++ "new" handler to the one we have defined for WIT.

@


1.75
log
@[multi-thread]
@
text
@d96 1
a96 1
   myWitRun_   = WitRun::newInstance ();
d98 1
a98 6
   myWitRun ()->
      myApiMgr ()->
         startApiFunc (
            "witStandAlone",
            myWitRun ()->
               myApiMgr ()->quietGroup ());
@


1.74
log
@[multi-thread]
@
text
@d103 1
a103 1
               myApiMgr ()->quietPreInGroup ());
@


1.73
log
@[multi-thread]
@
text
@d103 1
a103 1
               myApiMgr ()->preInQuietGroup ());
@


1.72
log
@[multi-threads]
@
text
@d103 1
a103 1
               myApiMgr ()->preInitGroup ());
@


1.71
log
@[multi-threads]
@
text
@d98 6
a103 3
   myWitRun ()->myApiMgr ()->setQuietCall ();

   myWitRun ()->myApiMgr ()->startApiFunc ("witStandAlone");
@


1.70
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d98 3
a100 1
   myWitRun ()->myApiMgr ()->startApiFunc ("witStandAlone", true);
@


1.69
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@d98 1
a98 1
   myWitRun ()->myApiMgr ()->enteringApiFunction ("witStandAlone", true);
d151 1
a151 1
   myWitRun ()->myApiMgr ()->leavingApiFunction ();
@


1.68
log
@Vector PropRt.
@
text
@d531 1
a531 1
   WitTVec <double> theObj1CumShipReward (myProblem (), 0.0);
d543 1
a543 1
   theObj1CumShipReward = (100.0 / totCumDemandVol);
d546 1
a546 1
      theDemand->setObj1CumShipReward (theObj1CumShipReward.myCVec ());
d563 1
a563 1
      thePart->setObj1ScrapCost (the0Vector.myCVec ());
d566 1
a566 1
      theMat->setObj1StockCost (the0Vector.myCVec ());
d569 1
a569 1
      theOpn->setObj1ExecCost (the0Vector.myCVec ());
d572 1
a572 1
      theSub->setObj1SubCost (the0Vector.myCVec ());
d575 1
a575 1
      theDemand->setObj1ShipReward (the0Vector.myCVec ());
d578 1
a578 1
      theDemand->setObj1CumShipReward (the0Vector.myCVec ());
@


1.67
log
@Tie Breaking Prop-Rt.
@
text
@d32 1
a32 1
#include <InVecRA.h>
@


1.66
log
@Double Precision.
@
text
@d30 1
a30 1
#include <PipSysMgr.h>
d343 1
a343 1
      myProblem ()->myPipSysMgr ()->buildPegging ();
@


1.65
log
@Double Precision.
@
text
@a206 12
   if (tempParIsSet (1))
      printf (
         "\n"
         "unitCost     = %14.6f\n"
         "supplyVol[1] = %14.6f\n"
         "usageRate    = %14.6f\n\n",
         myCompMgr ()->allParts      ().first ()->unitCost (),
         myCompMgr ()->allParts      ().first ()->supplyVol ()[1],
         myCompMgr ()->allOperations ().first ()->bom ().first ()->
            consRate ()[0]);
         

@


1.64
log
@Double Precision.
@
text
@d191 1
a191 1
   myMsgFac ().setMaxTimesIssued ("setFltAttrMsg",     0);
d271 1
a271 1
   myMsgFac ().setMaxTimesIssued ("setBoundVecFltAttrMsg", 0);
@


1.63
log
@Double Precision.
@
text
@d366 2
a367 2
   WitTVec <float> float0Vector (myProblem (),  0.0);
   WitOperation *  theOpn;
d371 2
a372 2
      theOpn->setMinLotSize (float0Vector.myCVec ());
      theOpn->setIncLotSize (float0Vector.myCVec ());
d540 4
a543 4
   WitDemand *     theDemand;
   WitPeriod       t;
   float           totCumDemandVol;
   WitTVec <float> theObj1CumShipReward (myProblem (), 0.0);
d550 2
a551 2
      forEachPeriod (t, myProblem ())
         totCumDemandVol += theDemand->cumDemandVol ()[t];
d565 6
a570 6
   WitPart *       thePart;
   WitMaterial *   theMat;
   WitOperation *  theOpn;
   WitSubEntry *   theSub;
   WitDemand *     theDemand;
   WitTVec <float> float0Vector (myProblem (),  0.0);
d575 1
a575 1
      thePart->setObj1ScrapCost (float0Vector.myCVec ());
d578 1
a578 1
      theMat->setObj1StockCost (float0Vector.myCVec ());
d581 1
a581 1
      theOpn->setObj1ExecCost (float0Vector.myCVec ());
d584 1
a584 1
      theSub->setObj1SubCost (float0Vector.myCVec ());
d587 1
a587 1
      theDemand->setObj1ShipReward (float0Vector.myCVec ());
d590 1
a590 1
      theDemand->setObj1CumShipReward (float0Vector.myCVec ());
d598 3
a600 3
   WitPeriod   t;
   float       totCumDemandVol;
   float       totCumShipVol;
d606 1
a606 1
      forEachPeriod (t, myProblem ())
d608 2
a609 2
         totCumDemandVol += theDemand->cumDemandVol ()[t];
         totCumShipVol   += theDemand->cumShipVol   ()[t];
@


1.62
log
@Double Precision.
@
text
@d555 1
a555 1
   theObj1CumShipReward.setToScalar (100.0 / totCumDemandVol);
@


1.61
log
@Double Precision.
@
text
@d207 12
@


1.60
log
@Double Precision.
@
text
@d32 1
@


1.59
log
@Double Precision.
@
text
@d253 4
a256 2
   WitTVec <float> float0Vector    (myProblem (),  0.0);
   WitTVec <float> floatNeg1Vector (myProblem (), -1.0);
d261 1
a261 4
      theMat->stockBounds ()->set (
         float0Vector.myCVec (),
         float0Vector.myCVec (),
         floatNeg1Vector.myCVec ());
d264 1
a264 4
      theOpn->execBounds ()->set (
         float0Vector.myCVec (),
         float0Vector.myCVec (),
         floatNeg1Vector.myCVec ());
d267 1
a267 4
      theDemand->cumShipBounds ()->set (
         float0Vector.myCVec (),
         float0Vector.myCVec (),
         floatNeg1Vector.myCVec ());
@


1.58
log
@Double Precision.
@
text
@d346 2
a347 1
      myWitRun ()->witDisplayData ("pipd.out");
d350 3
@


1.57
log
@Double Precision.
@
text
@d96 6
a103 2
   myMsgFac ().becomesCurrent ();

d150 1
a150 1
   WitMsgFacility::setCurrentPtr (NULL);
@


1.56
log
@Double Precision.
@
text
@a114 3
      if (myProblem ()->myGlobalComp ()->pauses ())
         myProblem ()->pauseForInput ();

@


1.55
log
@Double Precision.
@
text
@d115 3
@


1.54
log
@Began implementation of double precision.
@
text
@d256 3
a258 3
         float0Vector.myCvector (),
         float0Vector.myCvector (),
         floatNeg1Vector.myCvector ());
d262 3
a264 3
         float0Vector.myCvector (),
         float0Vector.myCvector (),
         floatNeg1Vector.myCvector ());
d268 3
a270 3
         float0Vector.myCvector (),
         float0Vector.myCvector (),
         floatNeg1Vector.myCvector ());
d357 2
a358 2
      theOpn->setMinLotSize (float0Vector.myCvector ());
      theOpn->setIncLotSize (float0Vector.myCvector ());
d544 1
a544 1
      theDemand->setObj1CumShipReward (theObj1CumShipReward.myCvector ());
d561 1
a561 1
      thePart->setObj1ScrapCost (float0Vector.myCvector ());
d564 1
a564 1
      theMat->setObj1StockCost (float0Vector.myCvector ());
d567 1
a567 1
      theOpn->setObj1ExecCost (float0Vector.myCvector ());
d570 1
a570 1
      theSub->setObj1SubCost (float0Vector.myCvector ());
d573 1
a573 1
      theDemand->setObj1ShipReward (float0Vector.myCvector ());
d576 1
a576 1
      theDemand->setObj1CumShipReward (float0Vector.myCvector ());
@


1.53
log
@Continued implementation of PIP.
@
text
@d202 3
@


1.52
log
@Continued implementation of PIP.
@
text
@a324 1
      {
a326 8
      if (boolParamVal ("invokePip"))
         {
         myWitRun ()->witDisplayData ("pipd.out");

         myProblem ()->myPipSysMgr ()->buildPegging ();
         }
      }

d335 7
@


1.51
log
@Added the PIP shipment sequence to the output of displayData.
@
text
@a327 3
      if (boolParamVal ("testPipSeq"))
         buildTestPipSeq ();

a641 29
   }

//------------------------------------------------------------------------------

void WitAloneRun::buildTestPipSeq ()
   {
   WitObjStack <WitDemand> revDemands (myProblem ());
   WitDemand *             theDemand;
   WitPeriod               shipPer;
   double                  incShipVol;

   myProblem ()->myPipSysMgr ()->clearShipSeq ();

   forEachDemand (theDemand, myProblem ())
      revDemands.push (theDemand);

   while (revDemands.pop (theDemand))
      for (shipPer = myProblem ()->nPeriods () - 1; shipPer >= 0; shipPer --)
         {
         incShipVol = theDemand->demandVol ()[shipPer];

         if (incShipVol <= 0.0)
            continue;

         myProblem ()->myPipSysMgr ()->appendToShipSeq (
            theDemand,
            shipPer,
            incShipVol);
         }
@


1.50
log
@Continued implementation of PIP.
@
text
@d332 3
d336 1
@


1.49
log
@Continued implementation of PIP.
@
text
@d30 1
a30 1
#include <PipMgr.h>
d332 1
a332 1
         myProblem ()->myPipMgr ()->buildPegging ();
d652 1
a652 1
   myProblem ()->myPipMgr ()->clearShipSeq ();
d665 1
a665 1
         myProblem ()->myPipMgr ()->appendToShipSeq (
@


1.48
log
@Continued implementation of PIP.
@
text
@d660 1
a660 1
         incShipVol = theDemand->shipVol ()[shipPer];
@


1.47
log
@Continued implementation of PIP.
@
text
@d30 2
d325 1
d328 7
d641 29
@


1.46
log
@An attempt to fix some syntax errors on Windows.
@
text
@d159 1
a159 1
   WitUtil::set_new_handler (newError);
@


1.45
log
@Continued implementation of opt with COIN.
@
text
@d159 1
a159 1
   set_new_handler (newError);
@


1.44
log
@Continued implementation of opt with COIN.
@
text
@d470 1
a470 1
   myWitRun ()->witSetCoinLogFileName  ("coin-ro.log");
@


1.43
log
@Continued implementation of opt with COIN.
@
text
@d470 1
a470 1
   myWitRun ()->witSetCoinMesgFileName ("coin-ro.log");
@


1.42
log
@Continued implementation of opt with COIN.
@
text
@d466 2
a467 2
   myOptImploder ()->setModelOFName  ("model.ro.out");
   myOptImploder ()->setOmSolnOFName ("omSoln.ro.out");
d469 2
a470 1
   myWitRun ()->witSetOslMesgFileName ("osl.ro.log");
@


1.41
log
@Internal changes.
@
text
@d103 5
d109 1
a109 1
      WitTimingEvent theEvent ("other");
d111 1
a111 1
      readInput ();
d113 5
a117 3
      if (boolParamVal ("doAction"))
         {
         preprocess ();
d119 3
a121 1
         performAction ();
d123 1
a123 5
         if (choiceParamVal ("action") == "mrp")
            printMrp ();
         else
            printImplosion ();
         }
d125 1
a125 3
      if (not boolParamVal ("reOpt"))
         {
         WitTimingEvent theEvent ("freeMemory");
d127 2
a128 1
         myMsgFac ().setMaxTimesIssued ("headingMsg", 0);
d130 1
a130 3
         myWitRun ()->witInitialize ();
         }
      }
d462 6
a467 2
      {
      WitTimingEvent theEvent ("other");
d469 1
a469 1
      myWitRun ()->witReadData ("../re-opt.data");
d471 1
a471 2
      myOptImploder ()->setModelOFName  ("model.ro.out");
      myOptImploder ()->setOmSolnOFName ("omSoln.ro.out");
d473 1
a473 1
      myWitRun ()->witSetOslMesgFileName ("osl.ro.log");
d475 1
a475 2
      myOptImploder ()->implode ();
      }
d477 1
a477 2
      {
      WitTimingEvent theEvent ("freeMemory");
d479 1
a479 2
      myWitRun ()->witInitialize ();
      }
@


1.40
log
@Internal changes.
@
text
@d120 1
a120 1
      if (! boolParamVal ("reOpt"))
d274 3
a276 3
            (choiceParamVal ("action") == "preproc") ||
            (choiceParamVal ("action") == "opt")     ||
            (choiceParamVal ("action") == "eval"))
d429 1
a429 1
   if (! boolParamVal ("fssFromInput"))
d601 2
a602 2
      if (! theMat->buildNstn ())
         if (! theMat->buildAsap ())
d614 1
a614 1
      if (theMat->nstnBaNeeded () || theMat->buildAsap ())
@


1.39
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d65 1
a65 1
inline WitBoolean WitAloneRun::booleanParamVal (const char * paramName)
d67 1
a67 1
   return myParamMgr_->booleanParamVal (paramName);
d108 1
a108 1
      if (booleanParamVal ("doAction"))
d120 1
a120 1
      if (! booleanParamVal ("reOpt"))
d133 1
a133 1
      if (booleanParamVal ("reOpt"))
d153 1
a153 1
   myWitRun ()->myApiMgr ()->setApiMode (witFALSE);
d176 1
a176 1
      witFALSE);
d198 1
a198 1
   if (booleanParamVal ("allNstn"))
d201 1
a201 1
   if (booleanParamVal ("selSplitAll"))
d204 1
a204 1
   if (booleanParamVal ("copy"))
d214 1
a214 1
   if (booleanParamVal ("makeVolServ"))
d217 1
a217 1
   if (booleanParamVal ("resetBounds"))
d220 1
a220 1
   if (booleanParamVal ("clearLS"))
d223 1
a223 1
   if (booleanParamVal ("purge"))
d226 1
a226 1
   if (booleanParamVal ("print_echo"))
d280 1
a280 1
   if (booleanParamVal ("writeData"))
d287 1
a287 1
   if (booleanParamVal ("print_pre"))
d297 1
a297 1
   if (booleanParamVal ("print_global"))
d313 1
a313 1
      if (booleanParamVal ("print_soln"))
d356 1
a356 1
   if (booleanParamVal ("print_soln"))
d368 1
a368 1
   if (booleanParamVal ("compVolServ"))
d371 1
a371 1
   if (booleanParamVal ("print_exec"))
d378 1
a378 1
   if (booleanParamVal ("print_ship"))
d385 1
a385 1
   if (booleanParamVal ("sparseFss"))
d392 1
a392 1
   if (booleanParamVal ("print_soln"))
d401 1
a401 1
         booleanParamVal ("fssFromInput"));
d414 1
a414 1
   if (booleanParamVal ("writeSolnData"))
d429 1
a429 1
   if (! booleanParamVal ("fssFromInput"))
d496 1
a496 1
      witFALSE);
d603 1
a603 1
            theMat->setBuildNstn (witTRUE);
d615 1
a615 1
         theMat->setBaSelSplit (witTRUE);
d620 1
a620 1
            theBopEnt->setMeSelSplit (witTRUE);
d625 1
a625 1
WitBoolean WitAloneRun::tempParIsSet (int index)
@


1.38
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d465 2
a466 2
      myOptImploder ()->setModelOFName   ("model.ro.out");
      myOptImploder ()->setOptSolnOFName ("mpSoln.ro.out");
@


1.37
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d465 2
a466 2
      myOptImploder ()->setModelOFName  ("model.ro.out");
      myOptImploder ()->setMpSolnOFName ("mpSoln.ro.out");
@


1.36
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d466 1
a466 1
      myOptImploder ()->setLpSolnOFName ("lpSoln.ro.out");
@


1.35
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d25 3
@


1.34
log
@Continued implementation of single-source.
@
text
@d460 1
a460 2
      myOptImploder ()->setModelOFName  ("model.re");
      myOptImploder ()->setLpSolnOFName ("lpSoln.re");
d462 2
a463 1
      myWitRun ()->witSetOslMesgFileName ("osl.re");
d465 1
a465 8
      if (intParamVal ("alteredAttr") == 1)
         alterSupplyVol ();

      if (intParamVal ("alteredAttr") == 2)
         alterGrossRev ();

      if (intParamVal ("alteredAttr") == 3)
         alterCumShipSLB ();
d476 1
a476 1
    (myMsgFac ().myFile (), "\nTimings for re-opt-implosion:\n");
a480 60
   }

//------------------------------------------------------------------------------

void WitAloneRun::alterSupplyVol ()
   {
   float * theSupplyVol;

   myWitRun ()->witGetPartSupplyVol (
      cStringParamVal ("alteredPart"),
      & theSupplyVol);

   theSupplyVol[intParamVal ("alteredPeriod")] =
      (float)   intParamVal ("alteredValue");

   myWitRun ()->witSetPartSupplyVol (
      cStringParamVal ("alteredPart"),
      theSupplyVol);

   portableFree (theSupplyVol);
   }

//------------------------------------------------------------------------------

void WitAloneRun::alterGrossRev ()
   {
   myWitRun ()->witSetDemandGrossRev (
      cStringParamVal ("alteredPart"),
      cStringParamVal ("alteredDemand"),
      (float) intParamVal ("alteredValue"));
   }

//------------------------------------------------------------------------------

void WitAloneRun::alterCumShipSLB ()
   {
   WitPart *       thePart;
   WitDemand *     theDemand;
   WitTVec <float> softLB (myProblem (), 0.0);

   thePart = myCompMgr ()->findPart (cStringParamVal ("alteredPart"));

   stronglyAssert (thePart != NULL);

   theDemand =
      myCompMgr ()->findDemand (thePart, cStringParamVal ("alteredDemand"));

   stronglyAssert (theDemand != NULL);

   theDemand->cumShipBounds ()->softLB ().copyIntoTVec (softLB);

   softLB[intParamVal ("alteredPeriod")] =
      (float) intParamVal ("alteredValue");

   myWitRun ()->witSetDemandCumShipBounds (
      cStringParamVal ("alteredPart"),
      cStringParamVal ("alteredDemand"),
      NULL,
      softLB.myCvector (),
      NULL);
@


1.33
log
@Continued implementation of Single-Source.
@
text
@a222 3
   if (tempParIsSet (1))
      chooseSglSrcSites ();

a684 63
   }

//------------------------------------------------------------------------------

void WitAloneRun::chooseSglSrcSites ()
   {
   int           sparsity;
   int           nSkipped;
   int           nExpBopEnts;
   int           nExpSubs;
   WitPart *     thePart;
   WitBopEntry * theBopEnt;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   sparsity = myProblem ()->myGlobalComp ()->tempParAsInt (1);

   stronglyAssert (sparsity >= 1);

   nSkipped = 0;

   forEachPart (thePart, myProblem ())
      {
      nExpBopEnts = 0;

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         if (theBopEnt->expAllowed ())
            nExpBopEnts ++;

      if (nExpBopEnts < 2)
         continue;

      nSkipped ++;

      if (nSkipped < sparsity)
         continue;

      thePart->setSingleSource (witTRUE);

      nSkipped = 0;
      }

   forEachBomEntry (theBomEnt, myProblem ())
      {
      nExpSubs = 0;

      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (theSub->expAllowed ())
            if (! theSub->myPart ()->producingBopEntries ().isEmpty ())
               nExpSubs ++;

      if (nExpSubs < 1)
         continue;

      nSkipped ++;

      if (nSkipped < sparsity)
         continue;

      theBomEnt->setSingleSource (witTRUE);

      nSkipped = 0;
      }
@


1.32
log
@Preliminary work on single source.
@
text
@d223 3
d688 63
@


1.31
log
@Continued preliminary work on single source.
@
text
@d537 1
a537 1
   theDemand->cumShipBounds ()->softLB ().copySelfInto (softLB);
d590 1
a590 1
   theObj1CumShipReward.setTo (100.0 / totCumDemandVol);
@


1.30
log
@Continued preliminary work on single source.
@
text
@d20 1
d25 2
@


1.29
log
@Continued implementation of object iteration.
@
text
@d236 2
a237 2
   WitTVec (float) float0Vector    (myProblem (),  0.0);
   WitTVec (float) floatNeg1Vector (myProblem (), -1.0);
d332 1
a332 1
   WitTVec (float) float0Vector (myProblem (),  0.0);
d523 1
a523 1
   WitTVec (float) softLB (myProblem (), 0.0);
d575 1
a575 1
   WitTVec (float) theObj1CumShipReward (myProblem (), 0.0);
d587 1
a587 1
   theObj1CumShipReward = 100.0 / totCumDemandVol;
d602 1
a602 1
   WitTVec (float) float0Vector (myProblem (),  0.0);
@


1.28
log
@Continued implementation of object iteration.
@
text
@a187 3
   if (tempParIsSet (1))
      testObjItr ();

a681 54
   }

//------------------------------------------------------------------------------

void WitAloneRun::testObjItr ()
   {
   WitRun * theWitRun;
   FILE *   itrMsgFile;
   WitAttr  theItrState;
   char *   thePartName;

   theWitRun = WitRun::newInstance ();

   theWitRun->witSetMesgFileName (witTRUE, "itr-test.out");

   theWitRun->witInitialize ();
   
   theWitRun->witGetMesgFile (& itrMsgFile);

   theWitRun->mySession ()->myProblem ()->myGlobalComp ()->
      setAllowObjItr (witTRUE);

   theWitRun->witReadData ("wit.data");

   theWitRun->witResetItr ();

   while (witTRUE)
      {
      theWitRun->witAdvanceItr (& theItrState);

      theWitRun->witGetCurItrState (& theItrState);

      fprintf (itrMsgFile,
         "\n"
         "-------> Current iteration state: %s\n", 
         theItrState);

      if (theItrState == WitINACTIVE)
         break;

      if (theItrState == WitAT_PART)
         {
         theWitRun->witGetItrPart (& thePartName);

         fprintf (itrMsgFile,
            "\n"
            "-------> Part at current iteration location: %s\n", 
            thePartName);

         portableFree (thePartName);
         }
      }

   delete theWitRun;
@


1.27
log
@Began implementation of object iteration.
@
text
@d188 3
d685 54
@


1.26
log
@Continued implementation of sel-split for pen-exec.
@
text
@d25 1
a25 1
#include <Demand.h>
@


1.25
log
@Continued implementation of sel-split for pen-exec.
@
text
@d527 1
a527 2
   if (thePart == NULL)
      myMsgFac () ("internalErrorFmsg", "WitAloneRun::testReOpt");
d532 1
a532 2
   if (theDemand == NULL)
      myMsgFac () ("internalErrorFmsg", "WitAloneRun::testReOpt");
d585 1
a585 2
   if (totCumDemandVol < .001)
      myMsgFac () ("internalErrorFmsg", "WitAloneRun::makeVolServObj");
d604 1
a604 2
   if (! myCompMgr ()->myOptComp ()->myObjFunc1 ()->isChosen ())
      myMsgFac () ("internalErrorFmsg", "WitAloneRun::clearObj1");
@


1.24
log
@Testing cvs commit from user rjw.
@
text
@a13 3
//
// Test of CVS commit.
//
@


1.23
log
@Moved pegging output to comprehensive implosion solution output.
Fixed bug: Pegging was being attempted during stock bounds enforcement.
@
text
@d14 3
@


1.22
log
@Minor change.
@
text
@a22 1
#include <HeurAllMgr.h>
a24 3
#include <ObjStack.h>
#include <PegSite.h>
#include <PegEl.h>
a314 1
      {
a316 5
      if (booleanParamVal ("prtPegging"))
         if (myCompMgr ()->myGlobalComp ()->perfPegging ())
            printPegging ();
      }

a685 83
   }

//------------------------------------------------------------------------------

void WitAloneRun::printPegging ()
   {
   WitDemand *                     theDemand;
   WitPeriod                       shipPer;
   WitObjStack <const WitOpnPegEl> theOpnPegEls (myProblem ());
   WitObjStack <const WitSubPegEl> theSubPegEls (myProblem ());

   fprintf (myMsgFac ().myFile (),
      "\n"
      "Pegging:\n");

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theDemand->myPegSite ()->getMyOpnPegEls (shipPer, theOpnPegEls);
         theDemand->myPegSite ()->getMySubPegEls (shipPer, theSubPegEls);

         if (theOpnPegEls.isEmpty ())
            if (theSubPegEls.isEmpty ())
               continue;

         fprintf (myMsgFac ().myFile (),
            "\n"
            "Part %s, Demand %s, Ship Per %d:\n",
            theDemand->demandedPartName ().myCstring (),
            theDemand->demandName ().myCstring (),
            shipPer);

         print (theOpnPegEls);
         print (theSubPegEls);
         }

   fprintf (myMsgFac ().myFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitAloneRun::print (WitObjStack <const WitOpnPegEl> & thePegEls)
   {
   const WitOpnPegEl * thePegEl;

   if (thePegEls.isEmpty ())
      return;

   fprintf (myMsgFac ().myFile (), "\n   Opn Per ExecVol\n");

   while (thePegEls.pop (thePegEl))
      fprintf (myMsgFac ().myFile (),
         "   %-3s %-3d %7.0f\n",
         thePegEl->myAllocComp ()->operationName ().myCstring (),
         thePegEl->myExecPer (),
         thePegEl->peggedVol ());
   }

//------------------------------------------------------------------------------

void WitAloneRun::print (WitObjStack <const WitSubPegEl> & thePegEls)
   {
   const WitSubPegEl * thePegEl;
   WitSubEntry *       theSub;

   if (thePegEls.isEmpty ())
      return;

   fprintf (myMsgFac ().myFile (), "\n   Opn B-E Sub Part Per ExecVol\n");

   while (thePegEls.pop (thePegEl))
      {
      theSub = thePegEl->myAllocComp ();

      fprintf (myMsgFac ().myFile (),
         "   %-3s %-3d %-3d %-4s %-3d %7.0f\n",
         theSub  ->myOperationName ().myCstring (),
         theSub  ->myBomEntIndex (),
         theSub  ->localIndex (),
         theSub  ->myPart ()->partName ().myCstring (),
         thePegEl->myExecPer (),
         thePegEl->peggedVol ());
      }
@


1.21
log
@Continued implementation of pegging.
@
text
@d323 1
a323 1
         if (myCompMgr ()->myGlobalComp ()->peggingNeeded ())
@


1.20
log
@Minor changes.
@
text
@d323 1
a323 1
         if (myCompMgr ()->myGlobalComp ()->pegging ())
@


1.19
log
@Continued implementation of pegging.
@
text
@d764 1
a764 1
   fprintf (myMsgFac ().myFile (), "\n   Opn B-E Sub Per ExecVol\n");
d771 1
a771 1
         "   %-3s %-3d %-3d %-3d %7.0f\n",
d775 1
@


1.18
log
@Continued implementation of pegging.
@
text
@d714 2
a715 2
         theDemand->myOpnPegSite ()->getMyPegEls (shipPer, theOpnPegEls);
         theDemand->mySubPegSite ()->getMyPegEls (shipPer, theSubPegEls);
@


1.17
log
@Continued implementation of pegging.
@
text
@d323 1
a323 1
         if (myCompMgr ()->myGlobalComp ()->perfPegging ())
@


1.16
log
@Continued implementation of pegging.
@
text
@d322 2
a323 2
      if (booleanParamVal ("allowPegging"))
         if (myCompMgr ()->myGlobalComp ()->doPegging ())
@


1.15
log
@Initial implementation of pegging.
@
text
@d702 4
a705 6
   WitDemand *      theDemand;
   WitPeriod        shipPer;
   const WitPegEl * thePegEl;

   WitObjStack <const WitPegEl> thePegEls (myProblem ());
   WitObjStItr <const WitPegEl> theItr;
d714 2
a715 1
         theDemand->myPegSite ()->getMyPegEls (shipPer, thePegEls);
d717 3
a719 2
         if (thePegEls.isEmpty ())
            continue;
d723 1
a723 1
            "Part %s, Demand %s, Ship Per %d:\n\n",
d728 2
a729 8
         theItr.attachTo (thePegEls);

         while (theItr.advance (thePegEl))
            fprintf (myMsgFac ().myFile (),
               "   Operation %s, Exec Per %2d, Delta ExecVol: %2.0f\n",
               thePegEl->myOpn ()->operationName ().myCstring (),
               thePegEl->myExecPer (),
               thePegEl->deltaExecVol ());
d733 45
@


1.14
log
@Continued development of selection splitting for multi-exec.
@
text
@d23 1
d26 3
d319 1
d322 5
d490 1
a490 1
   fprintf (myMsgFac ().myFile (), "\nTimings for re-opt-implosion:\n");
d696 43
@


1.13
log
@Removed allowSS development parameter.
@
text
@d676 1
d681 5
@


1.12
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a676 3
   if (! myProblem ()->myGlobalComp ()->allowSS ())
      myMsgFac () ("ssaNotAllowedSmsg");

@


1.11
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d195 3
d669 14
@


1.10
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d287 7
@


1.9
log
@

Revised stand-alone FSS capabilties in development mode.
Modified some stock soft-lower bound controls.
Fixed bug: BOP entry productRate attribute could not be read.
@
text
@d526 1
a526 1
   theDemand->cumShipBounds ()->softLB ().copyInto (softLB);
@


1.8
log
@Made HeurAllPerf::findMaxQty test desQty when it's < minQty.
   This fixed a "commit failed" error, by making the heuristic function
   properly in cases in which commit fails at a lower desQty than one in which
   it succeeds.
Moved top-level net into commitMaxQtySel.
@
text
@d384 2
a385 2
         cStringParamVal  ("soln_ofname"),
         ! isNullString (cStringParamVal ("fss_ifname")));
d413 1
a413 6
   if (booleanParamVal ("emptyFss"))
      forEachDemand (theDemand, myProblem ())
         theDemand->setFocusHorizon (-1);
   else if (! isNullString (cStringParamVal ("fss_ifname")))
      readFss ();
   else
a417 38

   if (booleanParamVal ("fssTest"))
      testFss ();
   }

//------------------------------------------------------------------------------

void WitAloneRun::readFss ()
   {
   WitRun     *    readWitRun;  // A WitRun  for reading in fssShipVols.
   WitProblem *    readProblem; // A Problem for reading in fssShipVols.
   WitDemand  *    theDemand;
   WitTVec (float) float0Vector (myProblem (),  0.0);

   readWitRun = WitRun::newInstance ();

   WitMsgFacility & readMsgFac = readWitRun->myMsgFac ();

   readMsgFac.setMaxTimesIssued ("headingMsg", 0);

   readWitRun->witCopyData (myWitRun ());

   readProblem = readWitRun->myProblem ();

   forEachDemand (theDemand, readProblem)
      theDemand->setDemandVol (float0Vector.myCvector ());

   readWitRun->witReadData (cStringParamVal ("fss_ifname"));

   myWitRun ()->witSetUseFocusHorizons (witFALSE);

   forEachDemand (theDemand, readProblem)
      myWitRun ()->witSetDemandFssShipVol (
         theDemand->demandedPartName ().myCstring (),
         theDemand->demandName       ().myCstring (),
         theDemand->demandVol        ().myCvector ());

   delete readWitRun;
a435 68
   }

//------------------------------------------------------------------------------

void WitAloneRun::testFss ()
   {
   WitRun *        fssWitRun;
   WitTVec (float) theVector (myProblem (), 0.0);
   WitPart *       thePart;
   WitDemand *     theDemand;
   WitOperation *  theOpn;
   WitSubEntry *   theSub;
   WitPeriod       t;

   fssWitRun = WitRun::newInstance ();

   fssWitRun->witCopyData (myWitRun ());

   forEachPart (thePart, myProblem ())
      {
      thePart->supplyVol ().copyInto (theVector);

      forEachPeriod (t, myProblem ())
         theVector[t] += thePart->focShortageVol ()[t];

      fssWitRun->witSetPartSupplyVol (
         thePart->partName ().myCstring (), 
         theVector           .myCvector ());
      }

   forEachDemand (theDemand, myProblem ())
      {
      fssWitRun->witSetDemandDemandVol (
         theDemand->demandedPartName ().myCstring (),
         theDemand->demandName       ().myCstring (),
         theDemand->fssShipVol       ().myCvector ());

      fssWitRun->witSetDemandShipVol (
         theDemand->demandedPartName ().myCstring (),
         theDemand->demandName       ().myCstring (),
         theDemand->fssShipVol       ().myCvector ());
      }

   forEachOperation (theOpn, myProblem ())
      {
      theOpn->fssExecVol ().copyInto (theVector);

      fssWitRun->witSetOperationExecVol (
         theOpn->operationName ().myCstring (), 
         theVector               .myCvector ());
      }

   forEachSubEntry (theSub, myProblem ())
      {
      theSub->fssSubVol ().copyInto (theVector);

      fssWitRun->witSetSubsBomEntrySubVol (
         theSub->myOperationName ().myCstring (),
         theSub->myBomEntryIndex (),
         theSub->localIndex (),
         theVector.myCvector ());
      }

   fssWitRun->witPostprocess ();

   fssWitRun->myProblem ()->writeSoln ("fss.out", witFALSE);

   delete fssWitRun;
@


1.7
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d192 3
d758 12
@


1.6
log
@Removed CVS test comment.
@
text
@d151 1
a151 1
   WitUtil::set_new_handler (WitUtil::newError);
d382 1
a382 1
         ! WitUtil::isNullString (cStringParamVal ("fss_ifname")));
d410 4
a413 1
   if (! WitUtil::isNullString (cStringParamVal ("fss_ifname")))
d417 1
a417 1
         theDemand->setFocusHorizon (myProblem ()->lPeriod ());
d602 1
a602 1
   WitUtil::portableFree (theSupplyVol);
@


1.5
log
@Testing CVS.
@
text
@a15 5
//------------------------------------------------------------------------------
// Temporary comment for CVS test.
// BW 3/31/00
//------------------------------------------------------------------------------

@


1.4
log
@Testing the /u/wit installation.
@
text
@d16 5
@


1.3
log
@*** empty log message ***
@
text
@a15 5
//------------------------------------------------------------------------------
// Testing the /u/wit cvs installation.
// 3/10/00 
//------------------------------------------------------------------------------

@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d16 5
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

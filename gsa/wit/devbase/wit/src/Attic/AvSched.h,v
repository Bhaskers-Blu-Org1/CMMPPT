head	1.48;
access;
symbols
	sce_5_01_20080919:1.42
	latest_sce_4_20_20060523:1.42.0.2
	sce_4_20_20060523:1.42
	latest_sce4_20_OSL:1.41.0.2
	sce_4_20_OSL:1.41
	sce_410_withVa:1.41
	sce_4_05_20040511:1.38
	sce_4_00_20040201:1.36
	nextGenBranch:1.36.0.2
	nextGenRoot:1.36
	sce_3_30_20030627:1.36
	EndRw-branch:1.32.0.4
	Root-of-EndRw:1.32
	rwToStl:1.32.0.2
	latest_sce_3_10_20010924:1.17.0.2
	sce_3_10_20010924:1.17
	latest_sce_3_00_20010601:1.10.0.4
	sce_3_00_20010601:1.10
	latest_sce_2_31_20010308:1.10.0.2
	sce_2_31_20010308:1.10
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3;
locks; strict;
comment	@ * @;


1.48
date	2010.09.10.20.30.56;	author rjw;	state dead;
branches;
next	1.47;

1.47
date	2010.09.10.20.12.06;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2010.09.10.16.03.49;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2010.09.10.14.59.26;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2010.09.07.23.50.33;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.16.18.58.25;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.02.17.33.54;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.24.19.18.29;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.24.18.42.04;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.09.16.38.38;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.18.21.53.52;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.29.22.06.17;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.17.23.34.18;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.02.23.40.36;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.02.22.18.18;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.12.24.22.50.45;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.16.22.30.18;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.19.16.10.48;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.10.19.06.01;	author austel;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.05.21.19.57;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.13.21.31.38;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.10.18.02.09;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.07.20.14.52;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.18.14.02.26;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.17.16.25.41;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.07.23.03.54;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.05.20.53.56;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.05.18.55.26;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.03.18.55.10;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.28.00.12.56;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.24.22.45.19;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.19.18.50.55;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.16.21.42.29;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.12.21.19.50;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.17.22.00.08;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.14.20.43.53;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.25.16.08.12;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.03.20.07.29;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.20.00.44.15;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.22.16.18.25;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.05.19.05.28;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.04.22.07.34;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.22.23.11.36;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.20;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.06.18.45.07;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.18.00.15.57;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.24.19.55.18;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.21.17.42.48;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Heuristic Adjustment
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

#ifndef AvSchedH
#define AvSchedH

//------------------------------------------------------------------------------
// Header file: "AvSched.h"
//
// Contains the declaration of class AvailSched.
//------------------------------------------------------------------------------

#include <Schedule.h>
#include <Mapping.h>
#include <Material.h>

//------------------------------------------------------------------------------
// Class AvailSched
//
// The availability schedule for heuristic allocation.
//------------------------------------------------------------------------------

class WitAvailSched: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAvailSched (WitHeurAtor *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitAvailSched ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void updateForAdjust ();
         //
         // Updates this AvailSched for a heuristic adjustment.

      void attachSsrMgr ();
         //
         // Sets mySsrMgr_.

      void netWoSR (
            WitPart * thePart,
            WitPeriod reqPer,
            double &  theReqVol);
         //
         // Nets theReqVol in reqPer against the availability of thePart without
         // stock reallocation.

      void netWithIncAvail (
            WitPart * thePart,
            WitPeriod thePer,
            double &  theReqVol);
         //
         // Nets theReqVol against the incremental availability of thePart in
         // thePer.

      void netMatWoSR (
            WitMaterial * theMat,
            WitPeriod     reqPer,
            double &      theReqVol);
         //
         // Nets theReqVol in reqPer against the availability of theMat without
         // stock reallocation.

      WitPeriod netAndRoll (
            WitMaterial * theMat, 
            WitPeriod     reqPer,
            double &      theReqVol,
            double &      rollVol,
            bool &        bddSsrSplit);
         //
         // Nets theReqVol against the availability of theMat in reqPer,
         // ignoring preallocation in later periods. Returns the period to
         // which some of theReqVol is to be rolled over, if any; else -1. In
         // the roll-over case, sets rollVol to the amount to roll-over. If the
         // rollVol is for a bounded split of SSR, sets bddSsrSplit to true.

      void reserveAchStSLB (
            WitMaterial * theMat, 
            WitPeriod     thePer,
            double &      unachVol);
         //
         // Reserves the portion of the stock soft LB for theMat in thePer
         // that's currently achieved. On return, unachVol is the amount of 
         // stock soft LB for theMat in thePer that remains unachieved.

      void addToIncAvailVol (
            WitPart * thePart, 
            WitPeriod thePer, 
            double    deltaVol);
         //
         // Adds deltaVol to the incremental availability of thePart in thePer.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      inline double incAvailVol (WitPart * thePart, WitPeriod thePer)
         {
         return incAvailVol_ (thePart)[thePer];
         }

      inline bool selectiveSR (WitMaterial * theMat)
         {
         return selectiveSR_ (theMat);
         }

      inline bool eitherSR (WitMaterial * theMat)
         {
         return uncondSR_ (theMat) or selectiveSR_ (theMat);
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      void initForUHS ();
         //
         // Puts this AvailSched into its initial state for a user-specified
         // heuristic starting solution.

      void verifyUhsNNScrapCon ();
         //
         // Assumes that the current solution is the user-specified heuristic
         // starting solution and verifies scrapVol >= 0.0 and issues a
         // warning, if not.

      void initStockRealloc ();
         //
         // Does initialization for stock reallocation, as needed.

      bool unlimitedBuildAhead (WitMaterial * theMat);
         //
         // Returns true, iff:
         //    theMat has build-ahead and
         //    buildAheadUB[t] >= t for all t.

      double allocedVol (
            WitMaterial * theMat,
            WitPeriod     reqPer,
            bool          forSR);
         //
         // Computes and returns the amount of availability of theMat in reqPer
         // that has been allocated to periods later than reqPer.
         // If forSR is true, then availability allocated to periods eligible
         // for stock reallocation is ignored.

      double availToNet (
            WitMaterial * theMat, 
            WitPeriod     reqPer, 
            double        theReqVol,
            double        allVol);
         //
         // Returns the amount of theMat that's available to be netted against
         // theReqVol in reqPer.
         // allVol is the amount, if any, that has been pre-allocated.

      WitPeriod rollPeriod (WitMaterial * theMat, WitPeriod fromPer);
         //
         // Returns the period in which to roll requirements from reqPer, if
         // any, else -1.

      bool srAllowedFrom (WitMaterial * theMat, WitPeriod thePer);
         //
         // Returns true, iff stock reallocation for theMat from thePer is
         // allowed.

      noCopyCtorAssign (WitAvailSched);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitHeurAtor * const myHeurAtor_;
         //
         // The HeurAtor that owns this AvailSched.

      WitSsrMgr * mySsrMgr_;
         //
         // The SsrMgr associated with this AvailSched, in SSR mode; else NULL.

      WitSchedule <WitPart, double> incAvailVol_;
         //
         // incremental availability schedule.
         // incAvailVol[thePer] == 
         //   supplyVol[thePer] 
         //  +  prodVol[thePer] 
         //  -  consVol[thePer] 
         //  -  shipVol[thePer]
         //  - (  stockVol reserved for softLB in thePer
         //     - stockVol reserved for softLB in thePer - 1)
         //
         // Note that incAvailVol[t] can be negative.

      WitMapping <WitMaterial, WitPeriod> lastDecPer_;
         //
         // Last availability decrement period.
         // lastDecPer_ (theMat) == max {t | incAvailVol_[t] <  0}
         //                         -1, if   incAvailVol_[t] >= 0 for all t.

      WitMapping <WitMaterial, bool> uncondSR_;
         //
         // uncondSR_ (theMat) is true, iff unconditional stock reallocation is
         // to be performed on theMat.

      WitMapping <WitMaterial, bool> selectiveSR_;
         //
         // selectiveSR_ (theMat) is true, iff selective stock reallocation is
         // to be performed on theMat.
   };

#endif
@


1.47
log
@Heuristic Adjustment
@
text
@@


1.46
log
@Heuristic Adjustment
@
text
@a97 9
      void adjustForShipVol (
            WitDemand * theDemand,
            WitPeriod   shipPer,
            double      deltaShipVol);
         //
         // Adjusts this AvailSched for a change to
         // theDemand->shipVol ()[shipPer] of deltaShipVol, which may be
         // positive or negative.

d112 1
a112 1
         // incAvailVol_ (thePart)[thePer] += deltaVol
@


1.45
log
@Heuristic Adjustment
@
text
@d98 9
@


1.44
log
@Heuristic Adjustment
@
text
@a231 4

      bool initUHSMode_;
         //
         // true only during a call to initForUHS.
@


1.43
log
@Revised the criteria for using selective stock reallocation.
@
text
@d53 4
@


1.42
log
@Updated the copyright date on all source files.
@
text
@d150 6
@


1.41
log
@mappingIndex revision.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.40
log
@Revised mappingIndex code.
@
text
@d21 1
a21 1
#include <Assoc.h>
@


1.39
log
@Corrected a numberical problem in netting.
@
text
@a22 2
#include <Material.h>

@


1.38
log
@Replaced the severe error for most constraint violations in the
   user-specified heuristic starting solution with a warning.
@
text
@d165 2
a166 1
            double        theReqVol);
d170 1
@


1.37
log
@Fixed a bug in stock reallocation that surfaced as a problem with build-ahead.
@
text
@d145 2
a146 1
         // starting solution and verifies scrapVol >= 0.0.
@


1.36
log
@Continued implementation of proportionate routing.
Fixed a bug in selection splitting for selective stock reallocation.
@
text
@d159 1
a159 1
         // for stock reallocation is considered is ignored.
@


1.35
log
@Internal changes.
@
text
@d87 2
a88 1
            double &      rollVol);
d93 2
a94 1
         // the roll-over case, sets rollVol to the amount to roll-over.
@


1.34
log
@Internal changes.
@
text
@d126 1
a126 1
         return uncondSR_ (theMat) || selectiveSR_ (theMat);
@


1.33
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d119 1
a119 1
      inline WitBoolean selectiveSR (WitMaterial * theMat)
d124 1
a124 1
      inline WitBoolean eitherSR (WitMaterial * theMat)
d152 1
a152 1
            WitBoolean    forSR);
d156 1
a156 1
         // If forSR is TRUE, then availability allocated to periods eligible
d172 1
a172 1
      WitBoolean srAllowedFrom (WitMaterial * theMat, WitPeriod thePer);
d174 1
a174 1
         // Returns TRUE, iff stock reallocation for theMat from thePer is
d210 1
a210 1
      WitMapping <WitMaterial, WitBoolean> uncondSR_;
d212 1
a212 1
         // uncondSR_ (theMat) is TRUE, iff unconditional stock reallocation is
d215 1
a215 1
      WitMapping <WitMaterial, WitBoolean> selectiveSR_;
d217 1
a217 1
         // selectiveSR_ (theMat) is TRUE, iff selective stock reallocation is
d220 1
a220 1
      WitBoolean initUHSMode_;
d222 1
a222 1
         // TRUE only during a call to initForUHS.
@


1.32
log
@Began implementation of heuristic implosion from an initial solution.
@
text
@d135 1
a135 1
      void initFromSoln ();
d137 11
a147 2
         // Puts this AvailSched into its initial state for a non-zero initial
         // solution.
d220 1
a220 1
      WitBoolean initMode_;
d222 1
a222 1
         // TRUE only during a call to initFromSoln.
@


1.31
log
@Continued implementation of Single-Source.
@
text
@d135 5
d210 4
@


1.30
log
@Made minor changes in order for wit to compile with the vacpp compiler.
@
text
@d55 1
a55 1
      void assocSsrMgr ();
d59 8
d75 1
a75 9
      void netWoSR (
            WitPart * thePart,
            WitPeriod reqPer,
            double &  theReqVol);
         //
         // Nets theReqVol in reqPer against the availability of thePart without
         // stock reallocation.

      void netWoSRAndRes (
d81 1
a81 1
         // stock reallocation and reserves the stock.
d94 4
a97 11
      void alloc (
            WitPart * thePart,
            WitPeriod resPer,
            WitPeriod allocPer,
            double    allocVol);
         //
         // Allocates allocVol units of thePart to be used in allocPer.
         // If stock reservation is appropriate, the reservation will start in
         // resPer, with resPer <= allocPer.

      void resConsStock (WitMaterial * theMat, WitPeriod consPer);
d99 3
a101 9
         // Reserves all stock of theMat that is consumed in consPer.

      void reserveStock (
            WitMaterial * theMat,
            WitPeriod     resPer,
            WitPeriod     relPer,
            double        resVol);
         //
         // Reserves resVol units of stockVol of theMat from resPer to relPer.
a109 11
      void reserveAllocedStSLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Determines how much of stock soft lower bound SLB on theMat in
         // thePer has been met by stock allocated in later periods and reserves
         // this stock.

      double unresStSLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Computes and returns the amount of the stock SLB on theMat in thePer
         // that is not currently satisfied wuth reserved stock.

d119 1
a119 1
      inline WitBoolean uncondSR (WitMaterial * theMat)
d121 1
a121 1
         return uncondSR_ (theMat);
d124 1
a124 1
      inline WitBoolean selectiveSR (WitMaterial * theMat)
d126 1
a126 1
         return selectiveSR_ (theMat);
d135 1
a135 5
      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

      void netWoSRWoRes (
d138 1
a138 1
            double &      theReqVol);
d140 4
a143 11
         // Nets theReqVol against the availability of theMat in reqPer, 
         // without stock reallocation.

      void allocWithRes (
            WitMaterial * theMat,
            WitPeriod     resPer,
            WitPeriod     allocPer,
            double        allocVol);
         //
         // Allocates allocVol units of theMat to be used in allocPer, but
         // reserved starting in resPer, with resPer <= allocPer.
a152 5
      double allocedVol (WitMaterial * theMat, WitPeriod reqPer);
         //
         // Computes and returns the amount of availability of theMat in reqPer
         // that has been allocated to periods later than reqPer.

d185 2
a186 2
         //  - stockVol that is being reserved in thePer
         //  + stockVol that is being released in thePer
a195 9
      WitSchedule <WitMaterial, double> incResStockVol_;
         //
         // Incremental reserved stockVol
         // If incResStockVol_ (theMat)[thePer] > 0, it is the amount of
         //    stockVol for theMat that is being reserved in thePer.
         // If it is < 0, it is the amount of stockVol for theMat that is being
         //    released in thePer.
         // Allocated only in respectStockSLBs mode.

a204 14

      WitMaterial * sssMat_;
         //
         // See sssSavedIncAvVol_.

      WitPeriod sssPer_;
         //
         // See sssSavedIncAvVol_.

      double sssSavedIncAvVol_;
         //
         // During temp-commit for sel-split search, the real value of the
         // incAvailVol_ (sssMat_, sssPer_) is saved in sssSavedIncAvVol_;
         // otherwise sssMat_ == NULL.
@


1.29
log
@Continued implementation of single-source.
@
text
@d23 2
@


1.28
log
@Continued implementation of single source.
@
text
@d119 1
a119 1
         // incAvailVol_ (thePart, thePer) += deltaVol
d138 1
a138 1
         return incAvailVol_ (thePart, thePer);
d237 1
a237 1
         // If incResStockVol_ (theMat, thePer) > 0, it is the amount of
@


1.27
log
@Continued implementation of single source.
@
text
@a131 5
      void restore ();
         //
         // Restores this AvailSched to its state just prior to entering temp
         // mode.

a232 4

      WitDataRepos & myDataRepos_;
         //
         // The DataRepos owned by this AvailSched.
@


1.26
log
@Continued preliminary work on single source.
@
text
@d132 5
d238 4
@


1.25
log
@Began implementation of object iteration.
@
text
@d21 1
d215 1
a215 1
      WitSchedule (WitPart, double) incAvailVol_;
d228 1
a228 1
      WitMapping (WitMaterial, WitPeriod) lastDecPer_;
d234 1
a234 1
      WitSchedule (WitMaterial, double) incResStockVol_;
d243 1
a243 1
      WitMapping (WitMaterial, WitBoolean) uncondSR_;
d248 1
a248 1
      WitMapping (WitMaterial, WitBoolean) selectiveSR_;
@


1.24
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@a199 4
      //------------------------------------------------------------------------

      accessWrapper (WitBoolean, respectStockSLBs, myGlobalComp ())

@


1.23
log
@Made stock reallocation use ssr vs. usr on a part-by-part basis.
@
text
@d52 4
d103 1
a103 1
         // Reserves all stock of theMat that is consumed in consPer;
d214 4
d253 1
a253 1
         // uncondSR_ (theMat) is TRUE, iff selective     stock reallocation is
d255 14
@


1.22
log
@Changed selStockRe attribute to stockReallocation (fullSR, internally).
@
text
@d136 10
d238 6
a243 2
      const WitBoolean pureUncondSR_;
      const WitBoolean fullSR_;
d245 2
a246 1
         // Same as for GlobalComp.
@


1.21
log
@Replaced uncondStockRe attribute with the old stockRealloc attribute.
@
text
@d229 1
a229 1
      const WitBoolean selStockRe_;
@


1.20
log
@Renamed mandatory stock reallocation to unconditional stock reallocation.
@
text
@d228 1
a228 1
      const WitBoolean uncondStockRe_;
@


1.19
log
@Continued development of Selective Stock Reallocation.
@
text
@d228 1
a228 1
      const WitBoolean mandStockRe_;
@


1.18
log
@Fixed bug in SSR:
   Needed to reserve stock when it was getting consumed in a period where
   stock reallocation was disallowed.

Fixed bug in SSR:
   Failed to create SsrPt in periods where explosion was not allowed, but
   requirements could still be filled by exploding in an earlier period.

Put implementation of class AvailSched into its own .C file.
@
text
@d52 8
d69 3
a71 3
            WitPart * thePart,
            WitPeriod reqPer,
            double &  theReqVol);
d73 1
a73 1
         // Nets theReqVol in reqPer against the availability of thePart without
d77 4
a80 4
            WitPart * thePart, 
            WitPeriod reqPer,
            double &  theReqVol,
            double &  rollVol);
d82 1
a82 1
         // Nets theReqVol against the availability of thePart in reqPer,
d147 3
a149 3
            WitPart * thePart,
            WitPeriod reqPer,
            double &  theReqVol);
d151 1
a151 1
         // Nets theReqVol against the availability of thePart in reqPer, 
d155 4
a158 4
            WitPart * thePart,
            WitPeriod resPer,
            WitPeriod allocPer,
            double    allocVol);
d160 1
a160 1
         // Allocates allocVol units of thePart to be used in allocPer, but
d163 4
a166 1
      double availToNet (WitPart * thePart, WitPeriod reqPer, double theReqVol);
d168 1
a168 1
         // Returns the amount of thePart that's available to be netted against
d171 1
a171 1
      double allocedVol (WitPart * thePart, WitPeriod reqPer);
d173 1
a173 1
         // Computes and returns the amount of availability of thePart in reqPer
d176 1
a176 1
      WitPeriod rollPeriod (WitPart * thePart, WitPeriod fromPer);
d181 1
a181 1
      WitBoolean srAllowedFrom (WitPart * thePart, WitPeriod thePer);
d183 1
a183 1
         // Returns TRUE, iff stock reallocation for thePart from thePer is
@


1.17
log
@Continued implementation of selective stock reallocation.
@
text
@a25 2
//
// Implemented in HeurAll.C.
@


1.16
log
@Continued implementation of selective stock reallocation.
@
text
@d91 4
d125 1
a125 1
      inline double incAvailVol (WitPart * thePart, WitPeriod thePer) const
d172 1
a172 1
      WitBoolean srAllowed (WitPart * thePart, WitPeriod fromPer);
d174 1
a174 1
         // Returns TRUE, iff stock reallocation for thePart from fromPer is
@


1.15
log
@Tightly integrated stock reallocation and stock non-reallocation in preparation
for selective stock reallocation.
@
text
@d54 1
a54 1
      void net (
d59 2
a60 1
         // Nets theReqVol in reqPer against the availability of thePart.
d62 1
a62 1
      void netWithPrealloc (
d67 2
a68 10
         // Nets theReqVol in reqPer against the availability of thePart, using
         // preallocation.

      void netWithPreallocWoRealloc (
            WitPart * thePart,
            WitPeriod reqPer,
            double &  theReqVol);
         //
         // Nets theReqVol in reqPer against the availability of thePart, using
         // preallocation and without stock reallocation.
d81 9
a89 13
      double availToNet (WitPart * thePart, WitPeriod reqPer, double theReqVol);
         //
         // Returns the amount of thePart that's available to be netted against
         // theReqVol in reqPer.

      void allocWithRes (
            WitPart *     thePart,
            WitPeriod     resPer,
            WitPeriod     allocPer,
            double        allocVol);
         //
         // Allocates allocVol units of thePart to be used in allocPer, but
         // reserved starting in resPer, with resPer <= allocPer.
d136 1
a136 1
      void netWoRealloc (
d144 14
d168 5
d214 5
@


1.14
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d54 1
a54 1
      void netWithPreAll (
d59 17
a75 2
         // Nets theReqVol against the availability of thePart in reqPer, 
         // respecting preallocation in later periods.
d90 1
a90 1
         // Returns the amount a thePart that's available to be netted against
d93 25
a117 4
      void addToNextIncAvail (
            WitMaterial * theMat, 
            WitPeriod     thePer, 
            double        deltaVol);
d119 3
a121 2
         // addToIncAvail in thePer + 1, if stock of theMat can be carried from
         // thePer to thePer + 1.
d123 1
a123 1
      void addToIncAvail (WitPart * thePart, WitPeriod thePer, double deltaVol);
d125 2
a126 1
         // incAvail_ (thePart, thePer) += deltaVol
d132 1
a132 1
      inline double incAvail (WitPart * thePart, WitPeriod thePer) const
d134 1
a134 1
         return incAvail_ (thePart, thePer);
d147 9
a155 1
      double preallocVol (WitPart * thePart, WitPeriod reqPer);
d158 1
a158 1
         // that has been pre-allocated to periods later than reqPer.
d165 4
d179 1
a179 1
      WitSchedule (WitPart, double) incAvail_;
d182 9
a190 4
         // incAvail[t] == supplyVol[t] + prodVol[t] - consVol[t] - shipVol[t]
         // Note that:
         //    --> stockVol[t] + scrapVol[t] = stockVol[t-1] + incAvail[t]
         //    --> incAvail[t] can be negative.
d195 11
a205 2
         // lastDecPer_ (theMat) == max {t | incAvail_[t] < 0}
         //                         -1, if incAvail_[t] >= 0 for all t.
@


1.13
log
@Created and used Archive template.
@
text
@a18 1
#include <Archive.h>
a53 4
      void restore ();
         //
         // Restores this AvailSched to its saved state.

a141 5

      WitArchive <double>    incAvailArch_;
      WitArchive <WitPeriod> lastDecPerArch_;
         //
         // These Archives save and restore values of incAvail_ and lastDecPer_.
@


1.12
log
@Initial implementation of pegging.
@
text
@d19 1
a19 1
#include <PairStack.h>
d39 11
a49 7
      static void construct (
            WitAvailSched * & firstAvailSched,
            WitAvailSched * & secondAvailSched,
            WitProblem *      theProblem);
         //
         // Constructs two companion AvailScheds for theProblem and sets the
         // arguments to their pointers.
d51 3
a53 6
      static void destruct (
            WitAvailSched * & firstAvailSched,
            WitAvailSched * & secondAvailSched);
         //
         // Destructs the two AvailScheds, which must be companions, and sets
         // the pointers to NULL.
d55 1
a55 1
      void reset ();
d57 1
a57 2
         // Sets this AvailSched to match companion_ on the AlpPPs_ of this
         // AvailSched and of companion_, while exhausting these two lists.
a110 17
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAvailSched (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.
         // Called through construct ().

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitAvailSched ();
         //
         // Called through destruct ().

      //------------------------------------------------------------------------
a113 5
      void resetOn (WitPartPerStack & thePPs);
         //
         // Sets this AvailSched to match companion_ on theAlpPPs, while 
         // exhausting thePPs.

d130 1
a130 1
      WitAvailSched * companion_;
d132 1
a132 2
         // The companion AvailSched for this AvailSched.
         // (One is temporary and the other permanent.)
d148 2
a149 1
      WitPartPerStack altPPs_;
d151 1
a151 3
         // The values of (thePart, thePer) for which
         // incAvail_ (thePart)[thePer] has been altered since the last reset.
         // May include duplicates.
@


1.11
log
@Moved Stack template implementations to header files.
@
text
@d28 1
a28 1
// Implemented in HeurAllS.C.
@


1.10
log
@Implemented and used class SelMgr.
@
text
@d19 1
a19 1
#include <PairSt.h>
@


1.9
log
@Further development of coarse selection splitting.
@
text
@d99 1
a99 1
      inline double incAvail (WitPart * thePart, WitPeriod thePer)
@


1.8
log
@Some minor modifications.
@
text
@d19 1
a19 1
#include <Stack.h>
@


1.7
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d19 1
a19 1
#include <DynStack.h>
@


1.6
log
@Refactoring for selection splitting.
@
text
@d131 1
a131 1
      void resetOn (WitPartPerDynStack & thePPs);
d171 1
a171 1
      WitPartPerDynStack altPPs_;
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d146 1
a146 3
      copyCtorAndAssignment (WitAvailSched);
         //
         // Prevents unintentional copying and assignment.
@


1.4
log
@

Revised stand-alone FSS capabilties in development mode.
Modified some stock soft-lower bound controls.
Fixed bug: BOP entry productRate attribute could not be read.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
d19 1
a19 1
#include <DynPer.h>
d131 1
a131 1
      void resetOn (WitDynPerStack (WitPart) & thePPs);
d173 1
a173 1
      WitDynPerStack (WitPart) altPPs_;
@


1.3
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d27 2
@


1.2
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d76 13
a132 5

      double availToNet (WitPart * thePart, WitPeriod reqPer, double theReqVol);
         //
         // Returns the amount a thePart that's available to be netted against
         // theReqVol in reqPer.
@


1.1
log
@Continued implementation of stock reallocation.
@
text
@d63 1
a63 1
         // respecting pre-allocation in later periods.
d72 1
a72 1
         // ignoring pre-allocation in later periods. Returns the period to
d126 1
a126 1
      double preAllocVol (WitPart * thePart, WitPeriod reqPer);
@


head	1.96;
access;
symbols
	sce_5_01_20080919:1.91
	latest_sce_4_20_20060523:1.90.0.2
	sce_4_20_20060523:1.90
	latest_sce4_20_OSL:1.89.0.2
	sce_4_20_OSL:1.89
	sce_410_withVa:1.89
	sce_4_05_20040511:1.65
	sce_4_00_20040201:1.65
	nextGenBranch:1.62.0.2
	nextGenRoot:1.62
	sce_3_30_20030627:1.62
	EndRw-branch:1.46.0.2
	Root-of-EndRw:1.46
	rwToStl:1.44.0.2
	latest_sce_3_10_20010924:1.22.0.2
	sce_3_10_20010924:1.22
	latest_sce_3_00_20010601:1.9.0.2
	sce_3_00_20010601:1.9;
locks; strict;
comment	@ * @;


1.96
date	2010.06.29.19.56.42;	author rjw;	state dead;
branches;
next	1.95;

1.95
date	2010.06.24.23.37.33;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.18.23.11.15;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2010.06.18.20.42.53;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2010.06.18.20.04.11;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2006.05.02.17.34.04;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2005.03.28.20.14.36;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2005.01.15.00.20.08;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2005.01.13.17.24.21;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.01.10.22.53.07;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2005.01.06.20.34.09;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2005.01.04.20.09.36;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2004.12.28.22.34.27;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2004.12.28.19.21.18;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2004.12.22.19.57.26;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2004.12.21.22.13.49;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2004.12.20.22.39.36;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2004.12.20.21.47.36;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.12.20.21.13.10;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.12.20.18.36.24;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.12.17.21.53.01;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.12.16.21.22.13;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.12.15.23.50.11;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.12.15.20.20.50;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.12.14.22.37.10;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.12.13.23.35.48;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.12.13.20.42.09;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.12.10.16.49.44;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.12.09.23.57.02;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.12.06.22.38.15;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2003.12.24.20.12.34;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.26.16.06.03;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.25.20.44.43;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.05.16.10.01;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2003.04.29.14.27.47;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2003.04.18.20.30.57;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2003.04.17.23.34.20;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.11.19.08.27;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.03.19.16.48.21;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.03.03.21.07.28;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.28.20.47.35;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.02.27.19.20.19;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.02.27.17.21.25;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.02.14.20.12.58;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.01.31.21.28.56;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.01.02.23.40.44;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.01.02.22.18.36;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2002.12.17.21.32.47;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.26.23.28.49;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2002.11.21.22.53.57;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.15.20.27.10;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.26.19.05.29;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.09.04.19.14.56;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.19.16.10.50;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.02.21.53.04;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.02.19.20.57;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.24.23.00.05;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.21.19.10.26;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.17.21.45.03;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.16.23.32.07;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.15.21.21.36;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.12.21.02.01;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.08.17.28.22;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.05.20.43.57;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.29.23.47.09;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.26.15.10.31;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.20.22.51.18;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.19.16.20.57;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.15.23.17.30;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.15.05.48;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.13.19.27.19;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.07.23.24.28;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.09.00.43.48;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.17.18.56.29;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.16.21.42.31;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.04.15.44.39;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.24.22.03.21;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.23.21.13.54;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.22.20.41.52;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.21.17.31.45;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.14.20.43.54;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.25.16.08.17;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.21.44.45;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.20.20.07.04;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.15.20.53.36;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.14.17.41.54;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.30.21.16.49;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.29.22.11.27;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.25.22.59.13;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.25.14.53.25;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.17.15.11.15;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.10.22.31.13;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.30.21.29.42;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.24.23.09.58;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.10.21.59.34;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.96
log
@Selection Reuse.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "MultiSel.C"
//
// Contains the implementation of the following classes:
//
//    SelMgr
//    SelPt
//    DetSelPt
//    AltPt
//    DetAltPt
//    ReqPtMgr
//    ReqPt
//------------------------------------------------------------------------------

#include <SelMgr.h>
#include <DetSelPt.h>
#include <DetAltPt.h>
#include <ReqPtMgr.h>
#include <ReqPt.h>
#include <Selector.h>
#include <Part.h>

//------------------------------------------------------------------------------
// Implementation of class SelMgr.
//------------------------------------------------------------------------------

WitSelMgr::~WitSelMgr ()
   {
   }

//------------------------------------------------------------------------------

WitAltPt * WitSelMgr::myAltPtFor (WitPart *, WitPeriod)
   {
   return NULL;
   }

//------------------------------------------------------------------------------

void WitSelMgr::setIndex ()
   {
   myIndex_ = mySelector_->mySelMgrs ().nElements ();
   }

//------------------------------------------------------------------------------

bool WitSelMgr::isLowerThan (WitSelMgr * theSelMgr)
   {
   return (myIndex_ > theSelMgr->myIndex_);
   }

//------------------------------------------------------------------------------

void WitSelMgr::restoreSpecConfig ()
   {
   }

//------------------------------------------------------------------------------

void WitSelMgr::setUpSelSplit ()
   {
   stronglyAssert (not selSplit_);

   selSplit_ = true;
   }

//------------------------------------------------------------------------------

void WitSelMgr::setBoundedSplit (bool theVal)
   {
   boundedSplit_ = theVal;
   }

//------------------------------------------------------------------------------

void WitSelMgr::postSplitCommit () 
   {
   }

//------------------------------------------------------------------------------

WitSelMgr::WitSelMgr (WitSelector * theSelector):

      WitProbAssoc  (theSelector),
      mySelector_   (theSelector),
      myIndex_      (-1),
      selSplit_     (false),
      boundedSplit_ (false)
   {
   }

//------------------------------------------------------------------------------
// Implementation of class SelPt.
//------------------------------------------------------------------------------

void WitSelPt::attachSplitPt (WitSplitPt * theSplitPt)
   {
   stronglyAssert ( mySplitPt_ == NULL);
   stronglyAssert (theSplitPt  != NULL);

   mySplitPt_ = theSplitPt;

   recSplit ();
   }

//------------------------------------------------------------------------------

void WitSelPt::detachSplitPt ()
   {
   stronglyAssert (mySplitPt_ != NULL);

   mySplitPt_ = NULL;

   recUnsplit ();
   }

//------------------------------------------------------------------------------

void WitSelPt::recordFlowSS (double incFlowVol)
   {
   mySelMgr ()->mySelector ()->recordFlowSS (this, incFlowVol);
   }

//------------------------------------------------------------------------------

bool WitSelPt::sglSrcMode ()
   {
   return false;
   }

//------------------------------------------------------------------------------

void WitSelPt::restoreInitSel ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

WitSelPt::WitSelPt ():
      mySplitPt_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitSelPt::~WitSelPt ()
   {
   }

//------------------------------------------------------------------------------

void WitSelPt::recSplit ()
   {
   }

//------------------------------------------------------------------------------

void WitSelPt::recUnsplit ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class DetSelPt.
//------------------------------------------------------------------------------

WitDetSelPt::WitDetSelPt ():

      WitSelPt    (),
      myDetAltPt_ (NULL)
   {
   myDetAltPt_ = new WitDetAltPt (this);
   }

//------------------------------------------------------------------------------

WitDetSelPt::~WitDetSelPt ()
   {
   delete myDetAltPt_;
   }

//------------------------------------------------------------------------------
// Implementation of class AltPt.
//------------------------------------------------------------------------------

WitAltPt::~WitAltPt ()
   {
   }

//------------------------------------------------------------------------------

void WitAltPt::setPending (bool theValue)
   {
   pending_ = theValue;
   }

//------------------------------------------------------------------------------

WitAltPt::WitAltPt ():
      pending_ (false)
   {
   }

//------------------------------------------------------------------------------
// Implementation of class DetAltPt.
//------------------------------------------------------------------------------

WitDetAltPt::WitDetAltPt (WitDetSelPt * theDetSelPt):

      WitAltPt    (),
      myDetSelPt_ (theDetSelPt)
   {
   }

//------------------------------------------------------------------------------

WitDetAltPt::~WitDetAltPt ()
   {
   }

//------------------------------------------------------------------------------

bool WitDetAltPt::hasResAlt ()
   {
   return myDetSelPt_->hasResAlt ();
   }

//------------------------------------------------------------------------------

void WitDetAltPt::alterSelection ()
   {
   myDetSelPt_->alterSelection ();
   }

//------------------------------------------------------------------------------

void WitDetAltPt::tempAlterSel ()
   {
   myDetSelPt_->tempAlterSel ();
   }

//------------------------------------------------------------------------------

void WitDetAltPt::cancelTempAlt ()
   {
   myDetSelPt_->cancelTempAlt ();
   }

//------------------------------------------------------------------------------

WitSelPt * WitDetAltPt::mySelPt ()
   {
   return myDetSelPt_;
   }

//------------------------------------------------------------------------------

void WitDetAltPt::printAlteration ()
   {
   myDetSelPt_->printAlteration ();
   }

//------------------------------------------------------------------------------
// Implementation of class ReqPtMgr.
//------------------------------------------------------------------------------

WitReqPtMgr::WitReqPtMgr (WitProblem * theProblem):
      WitProbAssoc  (theProblem),

      myReqPts_     (myProblem ()),
      allocedSlots_ (myProblem ()),
      unusedPoints_ (myProblem ())
   {
   }

//------------------------------------------------------------------------------

WitReqPtMgr::~WitReqPtMgr ()
   {
   reset ();

   deleteContents (unusedPoints_);
   }

//------------------------------------------------------------------------------

WitReqPt * WitReqPtMgr::myReqPt (WitPart * thePart, WitPeriod thePer)
   {
   WitReqPt * & theReqPtRef = myReqPts_.myPtrAt (thePart, thePer);

   if (theReqPtRef == NULL)
      {
      if (not unusedPoints_.pop (theReqPtRef))
         theReqPtRef = new WitReqPt (myProblem ());

      if (DEBUG_MODE)
         theReqPtRef->set (thePart, thePer);

      allocedSlots_.push (& theReqPtRef);
      }

   return theReqPtRef;
   }

//------------------------------------------------------------------------------

void WitReqPtMgr::reset ()
   {
   WitReqPt * * theReqPtPtr;

   while (allocedSlots_.pop (theReqPtPtr))
      {
      WitReqPt * & theReqPtRef = * theReqPtPtr;

      theReqPtRef->reset ();

      if (DEBUG_MODE)
         theReqPtRef->set (NULL, -1);

      unusedPoints_.push (theReqPtRef);

      theReqPtRef = NULL;
      }
   }

//------------------------------------------------------------------------------
// Implementation of class ReqPt.
//------------------------------------------------------------------------------

WitReqPt::WitReqPt (WitProblem * theProblem):

      myPart_     (NULL),
      myPer_      (-1),
      directAlts_ (theProblem),
      source_     (NULL),
      hasResAlt_  (false)
   {
   }

//------------------------------------------------------------------------------

WitReqPt::~WitReqPt ()
   {
   }

//------------------------------------------------------------------------------

void WitReqPt::set (WitPart * thePart, WitPeriod thePer)
   {
   myPart_ = thePart;
   myPer_  = thePer;
   }

//------------------------------------------------------------------------------

bool WitReqPt::hasAlt ()
   {
   return (source_ != NULL) or (directAlts_.isNonEmpty ());
   }

//------------------------------------------------------------------------------

void WitReqPt::setSource (WitReqPt * theSource)
   {
   stronglyAssert (theSource != NULL);

   if (not theSource->hasAlt ())
      return;

   if (theSource->hasResAlt ())
      {
      reset ();
            
      hasResAlt_ = true;
      }        

   source_ = theSource;
   }

//------------------------------------------------------------------------------

void WitReqPt::putDirectAlt (WitAltPt * theAltPt)
   {
   witAssert (theAltPt != NULL);

   if (theAltPt->hasResAlt ())
      {
      reset ();
            
      hasResAlt_ = true;
      }        

   directAlts_.push (theAltPt);
   }

//------------------------------------------------------------------------------

void WitReqPt::copyStateOf (WitReqPt * theReqPt)
   {
   directAlts_.revCopyFrom (theReqPt->directAlts_);

   directAlts_.reverse ();

   source_    = theReqPt->source ();

   hasResAlt_ = theReqPt->hasResAlt ();
   }

//------------------------------------------------------------------------------

void WitReqPt::reset ()
   {
   directAlts_.clear ();

   source_    = NULL;
   hasResAlt_ = false;
   }

//------------------------------------------------------------------------------

bool WitReqPt::getDirectAlt (WitAltPt * & theAltPt)
   {
   return directAlts_.pop (theAltPt);
   }
@


1.95
log
@Selection reuse.
@
text
@@


1.94
log
@Lead Time Bounds
@
text
@d63 6
d142 7
@


1.93
log
@Lead Time Bounds
@
text
@d42 7
@


1.92
log
@Lead Time Bounds
@
text
@d352 1
a352 1
void WitReqPt::setSource (WitReqPt * theSource, bool & priorAlt)
a363 1
      priorAlt   = false;
a364 3
   else 
      if (priorAlt)
         return;
@


1.91
log
@Stochastic Implosion
@
text
@d375 1
a375 21
void WitReqPt::putDirectAlt (WitAltPt * theAltPt, bool & priorAlt)
   {
   witAssert (theAltPt != NULL);

   if (theAltPt->hasResAlt ())
      {
      reset ();
            
      hasResAlt_ = true;
      priorAlt   = false;
      }        
   else
      if (priorAlt)
         return;

   directAlts_.push (theAltPt);
   }

//------------------------------------------------------------------------------

void WitReqPt::putDirectAltExecBounds (WitAltPt * theAltPt)
@


1.90
log
@Updated the copyright date on all source files.
@
text
@a78 1
      WitProbAssoc  (theSelector->myProblem ()),
d80 1
@


1.89
log
@Revised mappingIndex code.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.88
log
@Low-Pri Prop-Rt.
@
text
@a30 1
#include <MapIdxI.h>
@


1.87
log
@Low-Pri Prop-Rt.
@
text
@d247 7
@


1.86
log
@Low-Pri Prop-Rt.
@
text
@d234 1
a234 1
void WitDetAltPt::cancelTempAlt (WitSelCand * theSelCand)
d236 1
a236 8
   myDetSelPt_->cancelTempAlt (theSelCand);
   }

//------------------------------------------------------------------------------

bool WitDetAltPt::cancelNeedsSelCand ()
   {
   return myDetSelPt_->cancelNeedsSelCand ();
@


1.85
log
@Low-Pri Prop-Rt.
@
text
@d215 1
a215 1
   myDetSelPt_->hasResAlt ();
@


1.84
log
@Low-Pri Prop-Rt.
@
text
@d234 14
@


1.83
log
@Low-Pri Prop-Rt.
@
text
@a19 1
//    SelCand
d24 1
a24 2
#include <HeurAtor.h>
#include <Selector.h>
d27 1
d29 1
a29 6
#include <ReqPtMgr.h>
#include <SelMgr.h>
#include <SelCand.h>
#include <SplitPt.h>
#include <SglSrcMgr.h>
#include <Global.h>
a239 50
// Implementation of class SelCand.
//------------------------------------------------------------------------------

WitSelCand::~WitSelCand ()
   {
   }

//------------------------------------------------------------------------------

void WitSelCand::getMrData (WitRtCand * &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getBaData (WitPeriod &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getMeData (WitPeriod &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getSsrData (bool &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::getPoData (bool &, bool &)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

WitSelCand::WitSelCand (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------
@


1.82
log
@Low-Pri Prop-Rt.
@
text
@d165 2
a166 2
      WitSelPt (),
      myAltPt_ (NULL)
d168 1
a168 1
   myAltPt_ = new WitDetAltPt (this);
d175 1
a175 1
   delete myAltPt_;
d219 7
d422 1
a422 1
   if (theAltPt->mySelPt ()->hasResAlt ())
d442 1
a442 1
   if (theAltPt->mySelPt ()->hasResAlt ())
@


1.81
log
@Low-Pri Prop-Rt.
@
text
@d18 2
a19 2
//    SelAlt
//    DetSelAlt
d28 1
a28 1
#include <DetSelAlt.h>
d165 2
a166 2
      WitSelPt  (),
      mySelAlt_ (NULL)
d168 1
a168 1
   mySelAlt_ = new WitDetSelAlt (this);
d175 1
a175 1
   delete mySelAlt_;
d179 1
a179 1
// Implementation of class SelAlt.
d182 1
a182 1
WitSelAlt::~WitSelAlt ()
d188 1
a188 1
void WitSelAlt::setPending (bool theValue)
d195 1
a195 1
WitSelAlt::WitSelAlt ():
d201 1
a201 1
// Implementation of class DetSelAlt.
d204 1
a204 1
WitDetSelAlt::WitDetSelAlt (WitDetSelPt * theDetSelPt):
d206 1
a206 1
      WitSelAlt   (),
d213 1
a213 1
WitDetSelAlt::~WitDetSelAlt ()
d219 1
a219 1
void WitDetSelAlt::alterSelection ()
d226 1
a226 1
void WitDetSelAlt::tempAlterSel ()
d233 1
a233 1
WitSelPt * WitDetSelAlt::mySelPt ()
d411 1
a411 1
void WitReqPt::putDirectAlt (WitSelAlt * theSelAlt, bool & priorAlt)
d413 1
a413 1
   witAssert (theSelAlt != NULL);
d415 1
a415 1
   if (theSelAlt->mySelPt ()->hasResAlt ())
d426 1
a426 1
   directAlts_.push (theSelAlt);
d431 1
a431 1
void WitReqPt::putDirectAltExecBounds (WitSelAlt * theSelAlt)
d433 1
a433 1
   witAssert (theSelAlt != NULL);
d435 1
a435 1
   if (theSelAlt->mySelPt ()->hasResAlt ())
d442 1
a442 1
   directAlts_.push (theSelAlt);
d470 1
a470 1
bool WitReqPt::getDirectAlt (WitSelAlt * & theSelAlt)
d472 1
a472 1
   return directAlts_.pop (theSelAlt);
@


1.80
log
@Low-Pri Prop-Rt.
@
text
@d226 7
@


1.79
log
@Low-Pri Prop-Rt.
@
text
@a98 7
void WitSelPt::setPending (bool theValue)
   {
   pending_ = theValue;
   }

//------------------------------------------------------------------------------

a136 1
      pending_   (false),
d188 9
a196 1
WitSelAlt::WitSelAlt ()
d218 14
d350 5
a354 5
      myPart_    (NULL),
      myPer_     (-1),
      directPts_ (theProblem),
      source_    (NULL),
      hasResAlt_ (false)
d376 1
a376 1
   return (source_ != NULL) or (directPts_.isNonEmpty ());
d404 1
a404 1
void WitReqPt::putDirectPoint (WitSelPt * theSelPt, bool & priorAlt)
d406 1
a406 1
   witAssert (theSelPt != NULL);
d408 1
a408 1
   if (theSelPt->hasResAlt ())
d419 1
a419 1
   directPts_.push (theSelPt);
d424 1
a424 1
void WitReqPt::putDirectPointExecBounds (WitSelPt * theSelPt)
d426 1
a426 1
   witAssert (theSelPt != NULL);
d428 1
a428 1
   if (theSelPt->hasResAlt ())
d435 1
a435 1
   directPts_.push (theSelPt);
d442 1
a442 1
   directPts_.revCopyFrom (theReqPt->directPts_);
d444 1
a444 1
   directPts_.reverse ();
d455 1
a455 1
   directPts_.clear ();
d463 1
a463 1
bool WitReqPt::getDirectPoint (WitSelPt * & theSelPt)
d465 1
a465 1
   return directPts_.pop (theSelPt);
@


1.78
log
@Low-Pri Prop-Rt.
@
text
@d19 1
d28 1
a28 1
#include <SelAlt.h>
d173 2
a174 1
      WitSelPt ()
d176 1
d183 1
d190 6
d201 11
d213 1
a213 1
WitSelAlt::~WitSelAlt ()
@


1.77
log
@Low-Pri Prop-Rt.
@
text
@d18 1
d27 1
d183 14
@


1.76
log
@Low-Pri Prop-Rt.
@
text
@d17 1
d25 1
a25 1
#include <SelPt.h>
d165 16
@


1.75
log
@Low-Pri Prop-Rt.
@
text
@d173 1
a173 1
WitMrCand * WitSelCand::myMrCand ()
a175 2

   return NULL;
d180 1
a180 1
WitBaCand * WitSelCand::myBaCand  ()
a182 2

   return NULL;
d187 1
a187 1
WitMeCand * WitSelCand::myMeCand  ()
a189 2

   return NULL;
d194 1
a194 1
WitSsrCand * WitSelCand::mySsrCand ()
a196 2

   return NULL;
d201 1
a201 1
WitPoCand * WitSelCand::myPoCand  ()
a203 2

   return NULL;
@


1.74
log
@Low-Pri Prop-Rt.
@
text
@a40 7
   WitSelCand * theSelCand;

   if (DEBUG_MODE)
      while (allSelCands_.pop (theSelCand))
         theSelCand->verifyAsInactive ();

   deleteContents (inactiveSelCands_);
a58 32
WitSelCand * WitSelMgr::freshSelCand (WitSelPt * theSelPt)
   {
   WitSelCand * theSelCand;

   if (inactiveSelCands_.isNonEmpty ())
      inactiveSelCands_.pop (theSelCand);
   else
      {
      theSelCand = newSelCand ();

      if (DEBUG_MODE)
         allSelCands_.push (theSelCand);
      }

   theSelCand->activate ();

   theSelPt->setToMyCurSel (theSelCand);

   return theSelCand;
   }

//------------------------------------------------------------------------------

void WitSelMgr::deactivate (WitSelCand * theSelCand)
   {
   witAssert (theSelCand->mySelMgr () == this);
   
   inactiveSelCands_.push (theSelCand);
   }

//------------------------------------------------------------------------------

d82 1
a82 1
      WitProbAssoc      (theSelector->myProblem ()),
d84 4
a87 6
      mySelector_       (theSelector),
      myIndex_          (-1),
      selSplit_         (false),
      boundedSplit_     (false),
      inactiveSelCands_ (myProblem ()),
      allSelCands_      (myProblem ())
a168 28
   witAssert (not active_);
   }

//------------------------------------------------------------------------------

void WitSelCand::activate ()
   {
   witAssert (not active_);

   active_ = true;
   }

//------------------------------------------------------------------------------

void WitSelCand::deactivate ()
   {
   witAssert (active_);

   active_ = false;

   mySelMgr_->deactivate (this);
   }

//------------------------------------------------------------------------------

void WitSelCand::verifyAsInactive ()
   {
   stronglyAssert (not active_);
d218 2
a219 40
void WitSelCand::setToCurSelOf (WitMrPt *)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::setToCurSelOf (WitBaPt *)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::setToCurSelOf (WitMePt *)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::setToCurSelOf (WitSsrPt *)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitSelCand::setToCurSelOf (WitPoPt *)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

WitSelCand::WitSelCand (WitSelMgr * theSelMgr):
      WitProbAssoc (theSelMgr->myProblem ()),

      mySelMgr_    (theSelMgr),
      active_      (false)
@


1.73
log
@Low-Pri Prop-Rt.
@
text
@d66 1
a66 1
WitSelCand * WitSelMgr::freshSelCand ()
d82 2
@


1.72
log
@Low-Pri Prop-Rt.
@
text
@d285 35
@


1.71
log
@Low-Pri Prop-Rt.
@
text
@d44 2
a45 2
      while (mySelCands_.pop (theSelCand))
         witAssert (not theSelCand->inUse ());
d47 1
a47 1
   deleteContents (unusedSelCands_);
d66 1
a66 1
WitSelCand * WitSelMgr::unusedSelCand ()
d70 2
a71 2
   if (unusedSelCands_.isNonEmpty ())
      unusedSelCands_.pop (theSelCand);
d77 1
a77 1
         mySelCands_.push (theSelCand);
d80 1
a80 1
   theSelCand->use ();
d87 1
a87 1
void WitSelMgr::recycle (WitSelCand * theSelCand)
d91 1
a91 1
   unusedSelCands_.push (theSelCand);
d119 1
a119 1
      WitProbAssoc    (theSelector->myProblem ()),
d121 6
a126 6
      mySelector_     (theSelector),
      myIndex_        (-1),
      selSplit_       (false),
      boundedSplit_   (false),
      unusedSelCands_ (myProblem ()),
      mySelCands_     (myProblem ())
d208 1
d213 1
a213 1
void WitSelCand::use ()
d215 1
a215 1
   witAssert (not inUse_);
d217 1
a217 1
   inUse_ = true;
d222 1
a222 1
void WitSelCand::recycle ()
d224 1
a224 1
   witAssert (inUse_);
d226 1
a226 1
   inUse_ = false;
d228 8
a235 1
   mySelMgr_->recycle (this);
d289 1
a289 1
      inUse_       (false)
@


1.70
log
@Low-Pri Prop-Rt.
@
text
@d41 7
d66 30
d125 2
a126 1
      unusedSelCands_ (myProblem ())
d206 26
d268 3
a270 2
WitSelCand::WitSelCand (WitSelMgr * theSelMgr):
      WitProbAssoc (theSelMgr->myProblem ()),
d272 1
a272 2
      mySelMgr_    (theSelMgr)
   {
d277 5
a281 1
WitSelCand::~WitSelCand ()
@


1.69
log
@Low-Pri Prop-Rt.
@
text
@d82 1
a82 1
      WitProbAssoc  (theSelector->myProblem ()),
d84 5
a88 4
      mySelector_   (theSelector),
      myIndex_      (-1),
      selSplit_     (false),
      boundedSplit_ (false)
d204 4
a207 2
WitSelCand::WitSelCand (WitProblem * theProblem):
      WitProbAssoc (theProblem)
@


1.68
log
@Low-Pri Prop-Rt.
@
text
@d140 2
a141 3
      selSelCand_ (NULL),
      pending_    (false),
      mySplitPt_  (NULL)
a152 14
void WitSelPt::select (WitSelCand * theSelCand)
   {
   WitSelector * theSelector;

   theSelector = mySelMgr ()->mySelector ();

   if (theSelector->sglSrc ())
      theSelector->mySglSrcMgr ()->saveConfigVal (selSelCand_);

   selSelCand_ = theSelCand;
   }

//------------------------------------------------------------------------------

@


1.67
log
@Low-Pri Prop-Rt.
@
text
@d16 1
a17 1
//    SelPt
a91 51
// Implementation of class SelCand.
//------------------------------------------------------------------------------

WitMrCand * WitSelCand::myMrCand ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

WitBaCand * WitSelCand::myBaCand  ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

WitMeCand * WitSelCand::myMeCand  ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

WitSsrCand * WitSelCand::mySsrCand ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

WitSelCand::WitSelCand (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitSelCand::~WitSelCand ()
   {
   }

//------------------------------------------------------------------------------
d179 51
@


1.66
log
@Low-Pri Prop-Rt.
@
text
@a103 9
WitPoCand * WitSelCand::myPoCand ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

@


1.65
log
@Continued implementation of PIP.
@
text
@d104 1
a104 1
WitPrCand * WitSelCand::myPrCand ()
@


1.64
log
@Corrected a file inclusion AIX porting bug.
@
text
@d399 1
a399 1
   theReqPt->directPts_.revCopyInto (directPts_);
@


1.63
log
@Continued implementation of post-implosion pegging.
@
text
@d33 1
@


1.62
log
@Continued implementation of proportionate routing.
@
text
@a32 1
#include <PtrSchedI.h>
@


1.61
log
@Continued implementation of proportionate routing.
@
text
@a191 9
WitPeriod WitSelPt::myPeriod ()
   {
   stronglyAssert (1 == 2);

   return -1;
   }

//------------------------------------------------------------------------------

@


1.60
log
@Continued implementation of proportionate routing.
@
text
@d168 2
d179 9
d233 12
@


1.59
log
@Continued implementation of proportionate routing.
Fixed a bug in selection splitting for selective stock reallocation.
@
text
@a67 11
void WitSelMgr::finishSplitExp ()
   {
   stronglyAssert (splitExpPt_ != NULL);

   splitExpPt_   = NULL;

   boundedSplit_ = false;
   }

//------------------------------------------------------------------------------

a86 1
      splitExpPt_   (NULL),
a88 23
   }

//------------------------------------------------------------------------------

void WitSelMgr::startSplitExpAbs (WitSelPt * theSelPt, double toSplitVol)
   {
   stronglyAssert (selSplit_);
   stronglyAssert (splitExpPt_ == NULL);
   stronglyAssert (theSelPt != NULL);
   stronglyAssert (theSelPt->isSplit ());

   splitExpPt_ = theSelPt->mySplitPt ();

   splitExpPt_->startSplitExp (toSplitVol);
   }

//------------------------------------------------------------------------------

bool WitSelMgr::findNextSplitAbs (WitSelCand * & theSelCand, double & splitVol)
   {
   stronglyAssert (splitExpPt_ != NULL);

   return splitExpPt_->findNextSplit (theSelCand, splitVol, boundedSplit_);
@


1.58
log
@Continued implementation of proportionate routing.
@
text
@d292 3
d313 3
d327 3
d340 8
@


1.57
log
@Continued implementation of proportionate routing.
@
text
@d72 1
a72 1
   splitExpPt_->finishSplitExp ();
d74 1
a74 1
   splitExpPt_ = NULL;
d79 1
a79 1
void WitSelMgr::postSplitCommit () 
d81 1
d86 1
a86 1
bool WitSelMgr::boundedSplit ()
a87 6
   if (selSplit_)
      if (splitExpPt_ != NULL)
         if (splitExpPt_->boundedSplit ())
            return true;

   return false;
d93 1
a93 1
      WitProbAssoc (theSelector->myProblem ()),
d95 5
a99 4
      mySelector_  (theSelector),
      myIndex_     (-1),
      selSplit_    (false),
      splitExpPt_  (NULL)
d119 1
a119 3
bool WitSelMgr::findNextSplitAbs (
      WitSelCand * & theSelCand, 
      double &       splitVol)
d123 1
a123 8
   return splitExpPt_->findNextSplit (theSelCand, splitVol);
   }

//------------------------------------------------------------------------------

void WitSelMgr::recordFlowSS (WitSelPt * theSelPt, double incFlowVol)
   {
   mySelector_->recordFlowSS (theSelPt, incFlowVol);
@


1.56
log
@Continued implementation of proportionate routing.
@
text
@a244 14
WitPart * WitSelPt::myPmrPart ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitBomEntry * WitSelPt::myCmrBomEnt ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

@


1.55
log
@Continued implementation of proportionate routing.
@
text
@a151 9
WitOpCand * WitSelCand::myOpCand ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

@


1.54
log
@Continued implementation of proportionate routing.
@
text
@d161 9
@


1.53
log
@Continued implementation of proportionate routing.
@
text
@d152 1
a152 1
WitPrCand * WitSelCand::myPrCand ()
@


1.52
log
@Continued implementation of proportionate routing.
@
text
@d45 7
d101 1
a101 1
      myIndex_     (0),
a104 1
   myIndex_ = mySelector_->mySelMgrs ().nElements ();
@


1.51
log
@Continued implementation of proportionate routing.
@
text
@d91 1
a91 1
      WitProbAssoc (theSelector),
d182 2
a183 2
WitSelCand::WitSelCand (WitProbAssoc * theAssoc):
      WitProbAssoc (theAssoc)
@


1.50
log
@Internal changes.
@
text
@d146 9
@


1.49
log
@Internal changes.
@
text
@d54 1
a54 1
   stronglyAssert (! selSplit_);
d301 1
a301 1
      if (! unusedPoints_.pop (theReqPtRef))
d349 1
a349 1
   return (source_ != NULL) || (directPts_.isNonEmpty ());
d358 1
a358 1
   if (! theSource->hasAlt ())
@


1.48
log
@Removed implementation of single-source by the old algorithm.
@
text
@d45 1
a45 1
WitBoolean WitSelMgr::isLowerThan (WitSelMgr * theSelMgr)
d56 1
a56 1
   selSplit_ = witTRUE;
d78 1
a78 1
WitBoolean WitSelMgr::boundedSplit ()
d83 1
a83 1
            return witTRUE;
d85 1
a85 1
   return witFALSE;
d95 1
a95 1
      selSplit_    (witFALSE),
d117 1
a117 1
WitBoolean WitSelMgr::findNextSplitAbs (
d139 1
a139 1
   stronglyAssert (witFALSE);
d148 1
a148 1
   stronglyAssert (witFALSE);
d157 1
a157 1
   stronglyAssert (witFALSE);
d166 1
a166 1
   stronglyAssert (witFALSE);
d188 1
a188 1
void WitSelPt::setPending (WitBoolean theValue)
d223 1
a223 1
WitBoolean WitSelPt::sglSrcMode ()
d225 1
a225 1
   return witFALSE;
d246 1
a246 1
      pending_    (witFALSE),
d335 1
a335 1
      hasResAlt_ (witFALSE)
d347 1
a347 1
WitBoolean WitReqPt::hasAlt ()
d354 1
a354 1
void WitReqPt::setSource (WitReqPt * theSource, WitBoolean & priorAlt)
d365 2
a366 2
      hasResAlt_ = witTRUE;
      priorAlt   = witFALSE;
d377 1
a377 1
void WitReqPt::putDirectPoint (WitSelPt * theSelPt, WitBoolean & priorAlt)
d385 2
a386 2
      hasResAlt_ = witTRUE;
      priorAlt   = witFALSE;
d405 1
a405 1
      hasResAlt_ = witTRUE;
d431 1
a431 1
   hasResAlt_ = witFALSE;
d436 1
a436 1
WitBoolean WitReqPt::getDirectPoint (WitSelPt * & theSelPt)
@


1.47
log
@Continued implementation of single-source by the new algorithm.
@
text
@a29 1
#include <OldSglMgr.h>
a263 3

   if (theSelector->oldSglSrc ())
      theSelector->myOldSglMgr ()->saveConfigVal (selSelCand_);
@


1.46
log
@Continued implementation of single-source with the new algorithm.
@
text
@d224 7
@


1.45
log
@Began implementation of the new single-source algorithm.
@
text
@d31 1
d261 3
@


1.44
log
@Began implementation of multi-level lot sizes.
@
text
@d30 1
a30 1
#include <SglSrcMgr.h>
d258 2
a259 2
   if (theSelector->singleSource ())
      theSelector->mySglSrcMgr ()->saveConfigVal (selSelCand_);
@


1.43
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d137 1
a137 10
WitMrCand <Pmr> * WitSelCand::myPmrCand ()
   {
   stronglyAssert (witFALSE);

   return NULL;
   }

//------------------------------------------------------------------------------

WitMrCand <Cmr> * WitSelCand::myCmrCand ()
@


1.42
log
@Continued implementation of Single-Source.
@
text
@d32 2
@


1.41
log
@Continued implementation of Single-Source.
@
text
@a216 2

   postSplit ();
a268 6
   }

//------------------------------------------------------------------------------

void WitSelPt::postSplit ()
   {
@


1.40
log
@Continued implementation of Single-Source.
@
text
@d223 9
@


1.39
log
@Continued implementation of single-source.
@
text
@d230 7
@


1.38
log
@Continued implementation of single-source.
@
text
@d223 1
a223 1
WitBoolean WitSelPt::sglSrcMode ()
d225 1
a225 3
   witAssert (mySelMgr ()->mySelector ()->singleSource ());

   return witFALSE;
d252 1
a252 1
      theSelector->mySglSrcMgr ()->saveSelectVal (selSelCand_);
d369 1
a369 4
void WitReqPt::putDirectPoint (
      WitSelPt *   theSelPt,
      WitBoolean   resFound,
      WitBoolean & priorAlt)
d373 1
a373 1
   if (resFound)
d389 1
a389 3
void WitReqPt::putDirectPointExecBounds (
      WitSelPt * theSelPt,
      WitBoolean resFound)
d393 1
a393 1
   if (resFound)
@


1.37
log
@Continued implementation of single-source.
@
text
@d223 9
@


1.36
log
@Continued implementation of single source.
@
text
@d244 1
a244 1
   if (theSelector->sglSrc ())
@


1.35
log
@Continued implementation of sel-split for pen-exec.
@
text
@d30 2
d240 7
@


1.34
log
@Continued implementation of sel-split for pen-exec.
@
text
@d41 7
d90 1
d94 1
d358 1
a358 2
   if (theSelPt == NULL)
      return;
d380 1
a380 2
   if (theSelPt == NULL)
      return;
@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@d22 2
a28 1
#include <Splitter.h>
a29 1
#include <HeurAtor.h>
d114 7
d316 1
a316 1
   return (source_ != NULL) || (! directPts_.isEmpty ());
@


1.32
log
@Continued implementation of sel-split for pen-exec.
@
text
@a28 1
#include <SsPeMgr1.h>
d99 1
a99 4
   if (mySelector_->penExec ())
      mySelector_->mySsPeMgr ()->startSplitExp (splitExpPt_, toSplitVol);
   else
      splitExpPt_->startSplitExp (toSplitVol);
@


1.31
log
@Continued implementation of sel-split for pen-exec.
@
text
@d29 1
d44 1
a44 1
   witAssert (! selSplit_);
d53 1
a53 1
   witAssert (splitExpPt_ != NULL);
d93 4
a96 4
   witAssert (selSplit_);
   witAssert (splitExpPt_ == NULL);
   witAssert (theSelPt != NULL);
   witAssert (theSelPt->isSplit ());
d100 4
a103 1
   splitExpPt_->startSplitExp (toSplitVol);
d112 1
a112 1
   witAssert (splitExpPt_ != NULL);
d190 2
a191 2
   witAssert ( mySplitPt_ == NULL);
   witAssert (theSplitPt  != NULL);
d200 1
a200 1
   witAssert (mySplitPt_ != NULL);
d320 1
a320 1
   witAssert (theSource != NULL);
@


1.30
log
@Continued implementation sel-split for pen-exec.
@
text
@d119 1
a119 1
   myMsgFac () ("internalErrorFmsg", "WitSelCand::myPmrCand");
d128 1
a128 1
   myMsgFac () ("internalErrorFmsg", "WitSelCand::myCmrCand");
d137 1
a137 1
   myMsgFac () ("internalErrorFmsg", "WitSelCand::myBaCand");
d146 1
a146 1
   myMsgFac () ("internalErrorFmsg", "WitSelCand::myMeCand");
d155 1
a155 1
   myMsgFac () ("internalErrorFmsg", "WitSelCand::mySsrCand");
@


1.29
log
@Continued implementation of sel-split for pen-exec.
@
text
@d380 13
@


1.28
log
@Continued implementation of sel-split for pen-exec.
@
text
@a204 14
void WitSelPt::tempAlterSel ()
   {
   mySelMgr ()->myMsgFac () ("internalErrorFmsg", "WitSelPt::tempAlterSel");
   }

//------------------------------------------------------------------------------

void WitSelPt::restoreSel (WitSelCand *)
   {
   mySelMgr ()->myMsgFac () ("internalErrorFmsg", "WitSelPt::restoreSel");
   }

//------------------------------------------------------------------------------

@


1.27
log
@Continued implementation of sel-split for pen-exec.
@
text
@a204 9
int WitSelPt::sspeIndex ()
   {
   mySelMgr ()->myMsgFac () ("internalErrorFmsg", "WitSelPt::sspeIndex");

   return 0;
   }

//------------------------------------------------------------------------------

@


1.26
log
@Continued implementation of sel-split for pen-exec.
@
text
@d207 1
a207 1
   WitMsgFacility::current () ("internalErrorFmsg", "WitSelPt::sspeIndex");
d214 1
a214 1
void WitSelPt::setMrSelPrevSel (WitBoolean)
d216 8
a223 2
   WitMsgFacility::current () ("internalErrorFmsg",
      "WitSelPt::setMrSelPrevSel");
@


1.25
log
@Continued implementation of sel-split for pen-exec.
@
text
@d214 1
a214 1
WitMrPt <Pmr> * WitSelPt::myPmrPtIfAny ()
d216 2
a217 8
   return NULL;
   }

//------------------------------------------------------------------------------

WitMrPt <Cmr> * WitSelPt::myCmrPtIfAny ()
   {
   return NULL;
@


1.24
log
@Continued implementation of sel-split fpr pen-exec.
@
text
@d117 1
a117 1
WitMrCand <Pmr> * WitSelCand::myMrCandPmr ()
d119 1
a119 1
   myMsgFac () ("internalErrorFmsg", "WitSelCand::myMrCandPmr");
d126 1
a126 1
WitMrCand <Cmr> * WitSelCand::myMrCandCmr ()
d128 1
a128 1
   myMsgFac () ("internalErrorFmsg", "WitSelCand::myMrCandCmr");
d205 17
a221 1
WitMrPt <Pmr> * WitSelPt::myMrPtPmrIfAny ()
@


1.23
log
@Fixed a subtle bug in sel-split for stock reallocation.
Continued implementation of sel-split for pen-exec.
@
text
@d205 7
@


1.22
log
@Continued implmentation of selective stock reallocation.
@
text
@d199 2
d223 6
@


1.21
log
@Continued implementation of selective stock reallocation.
@
text
@d117 1
a117 1
WitBoolean WitSelCand::isaPmrCand ()
d119 3
a121 1
   return witFALSE;
d126 1
a126 1
WitBoolean WitSelCand::isaCmrCand ()
d128 3
a130 1
   return witFALSE;
d135 1
a135 1
WitBoolean WitSelCand::isaBaCand ()
d137 3
a139 1
   return witFALSE;
d144 1
a144 1
WitBoolean WitSelCand::isanMeCand ()
d146 3
a148 1
   return witFALSE;
d153 1
a153 1
WitBoolean WitSelCand::isanSsrCand ()
d155 3
a157 1
   return witFALSE;
@


1.20
log
@Continuing implementation of selective stock reallocation.
@
text
@d145 7
@


1.19
log
@Refactoring for constrained stock reallocation.
@
text
@d61 6
@


1.18
log
@Refactoring for constrained stock reallocation.
@
text
@a45 2

   setUpDerivedSS ();
@


1.17
log
@Refactoring for constrained stock reallocation.
@
text
@d101 2
a102 2
      WitTlObj * & splitObj, 
      double &     splitVol)
d106 1
a106 1
   return splitExpPt_->findNextSplit (splitObj, splitVol);
@


1.16
log
@Refactoring for constrained stock reallocation.
@
text
@d113 28
d183 3
a185 2
      pending_   (witFALSE),
      mySplitPt_ (NULL)
d193 7
@


1.15
log
@Created and used Archive template.
@
text
@a182 2
   WitReqPt * thePoint;

d185 1
a185 2
   while (unusedPoints_.pop (thePoint))
      delete thePoint;
@


1.14
log
@Initial implementation of pegging.
@
text
@a28 1
#include <AllMode.h>
@


1.13
log
@Implemented class template PtrSched <*, *>.
@
text
@d30 1
a30 1
#include <HeurAllP.h>
d174 1
a174 1
      myReqPtSched_ (myProblem ()),
d196 1
a196 1
   WitReqPt * & theReqPtRef = myReqPtSched_.ptrAt (thePart, thePer);
@


1.12
log
@Converted several generic classes into class templates.
@
text
@d174 1
a174 1
      myReqPtTl_    (),
a177 1
   myReqPtTl_.allocate (myProblem (), NULL);
d196 1
a196 1
   WitReqPt * & thePointRef = myReqPtRef (thePart, thePer);
d198 1
a198 1
   if (thePointRef == NULL)
d200 2
a201 2
      if (! unusedPoints_.pop (thePointRef))
         thePointRef = new WitReqPt (myProblem ());
d203 1
a203 1
      allocedSlots_.push (& thePointRef);
d206 1
a206 1
   return thePointRef;
d217 1
a217 1
      WitReqPt * & thePointRef = * theReqPtPtr;
d219 1
a219 1
      thePointRef->reset ();
d221 1
a221 1
      unusedPoints_.push (thePointRef);
d223 1
a223 1
      thePointRef = NULL;
@


1.11
log
@Removed indexes from production multi-route.
Other refactoring.
@
text
@d214 1
a214 1
   WitReqPtPtr * thePtr;
d216 1
a216 1
   while (allocedSlots_.pop (thePtr))
d218 1
a218 1
      WitReqPt * & thePointRef = * thePtr;
@


1.10
log
@Created class SelCand and classes derived from it.
@
text
@d16 1
a17 1
//    SelCand
a21 1
#include <SelCand.h>
d26 1
d111 15
a163 15
   {
   }

//------------------------------------------------------------------------------
// Implementation of class SelCand.
//------------------------------------------------------------------------------

WitSelCand::WitSelCand (WitProbAssoc * theAssoc):
      WitProbAssoc (theAssoc)
   {
   }

//------------------------------------------------------------------------------

WitSelCand::~WitSelCand ()
@


1.9
log
@Refactoring for sel-split for multi-exec.
@
text
@d17 1
d22 1
d114 1
a114 3
WitSelPt::WitSelPt ():
      pending_   (witFALSE),
      mySplitPt_ (NULL)
d116 1
d121 1
a121 1
WitSelPt::~WitSelPt ()
d123 4
d131 1
a131 1
void WitSelPt::setPending (WitBoolean theValue)
d133 3
a135 1
   pending_ = theValue;
d140 3
a142 1
void WitSelPt::attachSplitPt (WitSplitPt * theSplitPt)
d144 3
a146 2
   witAssert ( mySplitPt_ == NULL);
   witAssert (theSplitPt  != NULL);
d148 2
a149 1
   mySplitPt_ = theSplitPt;
d153 2
d156 2
a157 1
void WitSelPt::detachSplitPt ()
d159 3
a161 1
   witAssert (mySplitPt_ != NULL);
d163 2
a164 1
   mySplitPt_ = NULL;
@


1.8
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@d55 15
a69 2
   boundedSplit_ = witFALSE;
   splitExpPt_   = NULL;
d75 1
a75 1
      WitProbAssoc   (theSelector),
d77 3
a79 6
      mySelector_    (theSelector),
      selSplit_      (witFALSE),
      boundedSplit_  (witFALSE),
      splitExpPt_    (NULL),
      splitListItr_  (),
      netToSplitVol_ (0.0)
a88 1
   witAssert (! boundedSplit ());
a90 1
   witAssert (toSplitVol > NET_TOL);
d92 1
a92 2
   splitExpPt_    = theSelPt->mySplitPt ();
   netToSplitVol_ = toSplitVol;
d94 1
a94 1
   splitListItr_.attachTo (splitExpPt_->splitList ());
a102 2
   double splitBound;

d105 1
a105 67
   if (netToSplitVol_ <=  NET_TOL)
      {
      splitObj = splitExpPt_->mySelPt ()->selectedObj ();
      splitVol = netToSplitVol_;

      return witFALSE;
      }

   while (witTRUE)
      {
      boundedSplit_ = splitListItr_.advance (splitObj, splitBound);

      if (! boundedSplit_)
         {
         splitObj       = splitExpPt_->mySelPt ()->selectedObj ();
         splitBound     = 0.0;
         splitVol       = netToSplitVol_;
         netToSplitVol_ = 0.0;

         mySplitter ()->applySearchVolAsNeeded (splitExpPt_, splitVol);

         break;
         }

      splitExpPt_->mySelPt ()->adjustSplitBound (splitObj, splitBound);

      if (splitBound > NET_TOL)
         {
         splitVol        = min (splitBound, netToSplitVol_);

         netToSplitVol_ -= splitVol;

         break;
         }
      }

   prtSplitExpIA (splitObj, splitVol, splitBound);

   return witTRUE;
   }

//------------------------------------------------------------------------------

void WitSelMgr::prtSplitExpIA (
      WitTlObj * splitObj, 
      double     splitVol, 
      double     splitBound)
   {
   witAssert (selSplit_);

   if (myGlobalComp ()->selPrintLevel () < 3)
      return;

   if (mySelector_->myHeurAllPerf ()->myAllocMode ()->temp ())
      return;

   splitExpPt_->mySelPt ()->prtSplitExp (splitObj);
               
   fprintf    (msgFile (), "   SplitVol:    %.3f\n", splitVol);
               
   if (! boundedSplit_)
      fprintf (msgFile (), "   Split Bound: None\n");

   else if (splitBound == splitVol)
      fprintf (msgFile (), "   Split Bound: Same\n");
   else
      fprintf (msgFile (), "   Split Bound: %.3f\n", splitBound);
d135 2
a136 3
   witAssert ( mySplitPt_            == NULL);
   witAssert (theSplitPt             != NULL);
   witAssert (theSplitPt->mySelPt () == this);
@


1.7
log
@Various refactorings for sel-split for multi-exec.
@
text
@d124 1
a124 1
      adjustSplitBound (splitObj, splitBound);
@


1.6
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d53 1
a53 1
   witAssert (splitExpActive_);
d56 1
a56 3
                            
   if (DEBUG_MODE)
      splitExpActive_ = witFALSE;
d62 1
a62 1
      WitProbAssoc     (theSelector),
d64 6
a69 8
      mySelector_      (theSelector),
      selSplit_        (witFALSE),
      boundedSplit_    (witFALSE),
      splitExpActive_  (witFALSE),
      splitListItr_    (),
      netToSplitVol_   (0.0),
      unbnddSplitObj_  (NULL),
      splitAtSearchPt_ (witFALSE)
d75 1
a75 4
void WitSelMgr::startSplitExpAbs (
      WitSelPt * theSelPt,
      WitTlObj * unbnddObj,
      double     toSplitVol)
d78 1
a78 1
   witAssert (! splitExpActive_);
d80 1
a81 1
   witAssert (unbnddObj != NULL);
d84 2
a85 2
   if (DEBUG_MODE)
      splitExpActive_ = witTRUE;
d87 1
a87 6
   splitListItr_.attachTo (theSelPt->mySplitPt ()->splitList ());

   netToSplitVol_   = toSplitVol;
   unbnddSplitObj_  = unbnddObj;

   splitAtSearchPt_ = mySplitter ()->isSearchingAt (theSelPt);
d98 1
a98 2
   witAssert (selSplit_);
   witAssert (splitExpActive_);
d100 4
a103 3
   splitObj   = unbnddSplitObj_;
   splitVol   = netToSplitVol_;
   splitBound = 0.0;
a104 1
   if (netToSplitVol_ <=  NET_TOL)
d106 1
d114 2
a115 1
         splitObj       = unbnddSplitObj_;
d119 1
a119 2
         if (splitAtSearchPt_)
            mySplitter ()->applySearchVol (splitVol);
d156 1
a156 1
   prtSplitExp (splitObj);
@


1.5
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@d26 1
d80 3
a82 4
      const WitTlDblStack & splitList,
      WitTl *               unbnddObj,
      double                toSplitVol,
      WitSelPt *            theSelPt)
d87 1
d94 1
a94 1
   splitListItr_.attachTo (splitList);
d104 3
a106 1
WitBoolean WitSelMgr::findNextSplitAbs (WitTl * & splitObj, double & splitVol)
d148 1
a148 1
   prtSelSplitIA (splitObj, splitVol, splitBound);
d155 4
a158 4
void WitSelMgr::prtSelSplitIA (
      WitTl * splitObj, 
      double  splitVol, 
      double  splitBound)
d168 1
a168 1
   prtSelSplit (splitObj);
d186 2
a187 1
      pending_ (witFALSE)
d202 20
@


1.4
log
@Renamed AltPt classes to SelPt classes.
@
text
@d16 1
a18 1
//    SelPt
d39 11
d66 1
a66 1
      selSplit_        (myGlobalComp ()->selSplit ()),
d179 22
a365 22
   }

//------------------------------------------------------------------------------
// Implementation of class SelPt.
//------------------------------------------------------------------------------

WitSelPt::WitSelPt ():
      pending_ (witFALSE)
   {
   }

//------------------------------------------------------------------------------

WitSelPt::~WitSelPt ()
   {
   }

//------------------------------------------------------------------------------

void WitSelPt::setPending (WitBoolean theValue)
   {
   pending_ = theValue;
@


1.3
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@d18 1
a18 1
//    AltPt
d21 1
a21 1
#include <AltPt.h>
d71 1
a71 1
      WitAltPt *            theAltPt)
d87 1
a87 1
   splitAtSearchPt_ = mySplitter ()->isSearchingAt (theAltPt);
d278 1
a278 1
      WitAltPt *   theAltPt,
d282 1
a282 1
   if (theAltPt == NULL)
d296 1
a296 1
   directPts_.push (theAltPt);
d302 1
a302 1
      WitAltPt * theAltPt,
d305 1
a305 1
   if (theAltPt == NULL)
d315 1
a315 1
   directPts_.push (theAltPt);
d330 1
a330 1
WitBoolean WitReqPt::getDirectPoint (WitAltPt * & theAltPt)
d332 1
a332 1
   return directPts_.pop (theAltPt);
d336 1
a336 1
// Implementation of class AltPt.
d339 1
a339 1
WitAltPt::WitAltPt ():
d346 1
a346 1
WitAltPt::~WitAltPt ()
d352 1
a352 1
void WitAltPt::setPending (WitBoolean theValue)
@


1.2
log
@Added various counts to the debugging output of selection splitting.
@
text
@d99 4
@


1.1
log
@Continuing development of selection splitting.
@
text
@d144 1
a144 1
   if (myGlobalComp ()->selPrintLevel () < 4)
@


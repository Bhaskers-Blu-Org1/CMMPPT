head	1.135;
access;
symbols
	sce_5_01_20080919:1.113
	latest_sce_4_20_20060523:1.62.0.2
	sce_4_20_20060523:1.62
	latest_sce4_20_OSL:1.61.0.2
	sce_4_20_OSL:1.61
	sce_410_withVa:1.59
	sce_4_05_20040511:1.54
	sce_4_00_20040201:1.35
	nextGenBranch:1.33.0.2
	nextGenRoot:1.33
	sce_3_30_20030627:1.33
	EndRw-branch:1.27.0.4
	Root-of-EndRw:1.27
	rwToStl:1.27.0.2
	latest_sce_3_10_20010924:1.7.0.6
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.7.0.4
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.7.0.2
	sce_2_31_20010308:1.7
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.135
date	2010.09.10.22.10.39;	author rjw;	state dead;
branches;
next	1.134;

1.134
date	2010.09.09.16.33.47;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2010.01.06.20.42.40;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2009.12.30.18.30.37;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2009.12.29.23.24.32;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2009.12.29.20.42.58;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2009.12.29.20.17.18;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2009.12.29.19.39.05;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2009.12.29.16.33.45;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2009.12.28.23.07.44;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2009.12.25.00.34.51;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2009.12.25.00.10.47;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2009.12.24.22.58.56;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2009.12.24.21.00.04;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2009.12.23.22.39.55;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2009.12.23.00.21.49;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2009.12.22.23.44.51;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2009.12.21.23.09.55;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2009.11.18.19.00.01;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2009.11.17.22.54.49;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2009.11.13.19.01.25;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2008.02.25.16.36.34;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2007.12.11.22.00.28;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2007.11.15.17.15.34;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2007.11.14.17.18.54;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2007.11.13.23.02.17;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2007.11.13.20.17.39;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2007.11.09.00.40.47;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2007.10.15.21.50.34;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2007.10.02.18.32.43;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.09.28.22.08.26;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.09.11.18.09.17;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.09.10.14.44.07;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.08.01.22.41.57;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.06.20.22.41.38;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.06.08.18.09.40;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.06.06.16.28.02;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.05.21.06.01;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.05.16.15.23;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.30.16.01.19;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.25.18.39.11;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.24.18.52.21;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.22.20.58.38;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.22.20.44.26;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.05.22.15.46.52;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.15.19.45.43;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.05.14.19.05.39;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.14.16.18.38;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.05.11.20.43.56;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.05.10.21.58.11;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.05.10.17.22.14;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.05.04.23.27.11;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.05.03.20.05.14;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.04.30.21.52.09;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.04.26.20.45.30;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.04.04.22.08.18;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.04.03.22.04.04;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.04.02.23.01.15;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.02.28.20.04.58;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.27.22.59.29;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.08.22.47.35;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.15.22.25.30;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.15.21.15.15;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2006.10.12.20.48.10;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2006.08.17.22.50.37;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2006.08.16.15.49.18;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.02.17.34.05;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.24.22.28.52;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2005.06.13.16.48.47;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.24.23.23.56;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.02.24.19.46.27;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.02.10.19.46.47;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.30.16.26.23;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.09.21.24.27;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.02.23.45.20;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.01.21.05.12;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.31.22.56.08;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.05.22.19.58;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.05.00.06.54;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.04.16.44.29;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.03.22.36.22;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.06.23.27.09;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.11.18.29.13;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.18.21.12.48;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.19.16.48.21;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.13.23.06.29;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.23.20.47.17;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.02.23.40.44;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.02.22.18.38;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.10.19.21.16;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.09.18.42.11;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.10.07.21.46.36;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.04.21.26.28;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.30.21.36.36;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.11.18.53.10;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.09.16.04.37;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.23.18.09.13;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.22.21.16.21;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.05.19.31.34;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.04.23.07.21;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.03.22.35.20;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.03.16.01.50;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.14.32.40;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.28.19.44.57;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.19.21.53;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.25.19.14.51;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.24.18.26.07;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.22.14.32.10;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.14.02.37;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.20.00.44.20;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.04.22.27.52;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.25;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.12.33;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.21.22.45;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.29;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches;
next	;


desc
@@


1.135
log
@Heuristic Adjustment
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "Opn.C"
//
// Contains the implementation of class Operation.
//------------------------------------------------------------------------------

#include <Opn.h>
#include <GlobalComp.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <OptComp.h>
#include <ExecBS.h>
#include <CompMgr.h>
#include <OrigMrp.h>
#include <DataWrit.h>
#include <wit/src/Variant.h>
#include <Pre.h>
#include <FSS.h>
#include <HeurAllMgr.h>
#include <HeurAdjMgr.h>
#include <OptStarter.h>
#include <DetOptImpMgr.h>
#include <StochImpMgr.h>
#include <IVRealArg.h>
#include <wit.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class Operation.
//------------------------------------------------------------------------------

WitOperation::WitOperation (const char * theName, WitCompMgr * theCompMgr):

      WitNode           (theName, theCompMgr),
      mappingIndex_     (myCompMgr ()->nOperations ()),
      bom_              (),
      bop_              (),
      yieldRate_        (myProblem (), defYieldRate ()),
      minLotSize_       (myProblem (), defMinLotSize ()),
      incLotSize_       (myProblem (), defIncLotSize ()),
      twoLevelLotSizes_ (defTwoLevelLotSizes ()),
      lotSize2Thresh_   (myProblem (), defLotSize2Thresh ()),
      minLotSize2_      (myProblem (), defMinLotSize2 ()),
      incLotSize2_      (myProblem (), defIncLotSize2 ()),
      execPenalty_      (defExecPenalty ()),
      execCost_         (myProblem (), defExecCost ()),
      intExecVols_      (defIntExecVols ()),
      cycleTime34_      (myProblem (), defCycleTime34 ()),
      execVol_          (myProblem (), 0.0),
      execBounds_       (NULL),
      executable_       (myProblem (), false),
      mrpExecVol_       (myProblem (), 0.0),
      fssExecVol_       (myProblem (), 0.0)
   {
   execBounds_ = new WitExecBoundSet (this);

   myCompMgr ()->insert (this);
   }

//------------------------------------------------------------------------------

WitOperation::~WitOperation ()
   {
   delete execBounds_;
   }

//------------------------------------------------------------------------------

int WitOperation::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nOperations ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitOperation::setOperationName (const char * theName)
   {
   myCompMgr ()->setOperationName (this, theName);
   }

//------------------------------------------------------------------------------

void WitOperation::setYieldRate (const WitIVRealArg & theValue)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         witAssert (validYieldRate (theValue[thePer]));

   prepSetUnpreAttr ();

   yieldRate_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setMinLotSize (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetUnpreAttr ();

   minLotSize_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setIncLotSize (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetUnpreAttr ();

   incLotSize_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setTwoLevelLotSizes (bool theValue)
   {
   prepSetUnpreAttr ();

   twoLevelLotSizes_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setLotSize2Thresh (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetUnpreAttr ();

   lotSize2Thresh_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setMinLotSize2 (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetUnpreAttr ();

   minLotSize2_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setIncLotSize2 (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetUnpreAttr ();

   incLotSize2_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setExecPenalty (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   execPenalty_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setExecCost (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   prepSetScenSpecAttr ("execCost");

   execCost_.curDblFlexVec () = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setIntExecVols (bool theValue)
   {
   prepSetUnpreAttr ();

   intExecVols_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setExecVol (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   if (myProblem ()->myHeurAdjMgr ()->active ())
      {
      prepSetNonUnpostAttr ();
      }
   else
      {
      myOptComp ()->schedOptStarter ()->beChosen ();

      prepSetUnpostAttr ();
      }

   execVol_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::setCycleTime34 (const WitIVRealArg & theValue)
   {
   WitBomEntry * theBomEnt;

   witAssert (theValue != NULL);

   witAssert (wit34Compatible ());

   prepSetUnpreAttr ();

   forEachEl (theBomEnt, bom ())
      theBomEnt->adjustOffset (theValue);

   cycleTime34_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::storePreExecutable (WitPeriod thePer, bool theValue)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   executable_[thePer] = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::storeHeurExecVol (WitPeriod thePer, double theValue)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   execVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::storeOptExecVol (WitPeriod thePer, double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   execVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitOperation::storeStochExecCost (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   execCost_.curDblFlexVec () = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitOperation::storeStochExecVol (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   execVol_ = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitOperation::storeMrpMrpExecVol (const WitTVec <double> & theTVec)
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());

   mrpExecVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitOperation::storeFssFssExecVol (const WitTVec <double> & theTVec)
   {
   witAssert (myFSS ()->uploadingSoln ());

   fssExecVol_ = theTVec;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitOperation::insert (WitBomEntry * theBomEnt)
   {
   bom_.appendUniquely (theBomEnt);
   }

//------------------------------------------------------------------------------

void WitOperation::insert (WitBopEntry * theBopEnt)
   {
   bop_.appendUniquely (theBopEnt);
   }

//------------------------------------------------------------------------------

bool WitOperation::inserted ()
   {
   return (myCompMgr ()->findOperation (operationName ().myCstring ()) == this);
   }

//------------------------------------------------------------------------------

void WitOperation::writeMultiObjVecs (WitObjective * theObj)
   {
   execCost_.writeDataMulti ("execCost", this, theObj);
   }

//------------------------------------------------------------------------------

void WitOperation::writeSolnData ()
   {
   if (execVol () == defExecVol ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("operation");
   myDataWriter ()->writeStringValue  (operationName ());

   myDataWriter ()->writeVector ("execVol", execVol (), defExecVol ());

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitOperation::copySelfInto (WitCompMgr * theCompMgr)
   {
   WitOperation * theOpn;

   theOpn = new WitOperation (operationName ().myCstring (), theCompMgr);

   theOpn->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitOperation::recount ()
   {
   mappingIndex_ = myCompMgr ()->nOperations ();

   myCompMgr ()->recountOperation (this);
   }

//------------------------------------------------------------------------------

void WitOperation::unpreprocess ()
   {
   executable_ = false;
   }

//------------------------------------------------------------------------------

void WitOperation::clearOptSoln  ()
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());

   execVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitOperation::clearStochSoln ()
   {
   WitComponent::clearStochSoln ();

   execVol_ = 0.0;
   }

//------------------------------------------------------------------------------

WitOperation * WitOperation::thisOpn ()
   {
   return this;
   }

//------------------------------------------------------------------------------

void WitOperation::identifyInstance ()
   {
   if (myMsgFac ().mayIssue ("operationInstIDMsg"))
      myMsgFac () ("operationInstIDMsg", operationName ());
   }

//------------------------------------------------------------------------------

void WitOperation::writeSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("operation");
   myDataWriter ()->writeStringValue  (operationName ());
   }

//------------------------------------------------------------------------------

WitMsgFrag WitOperation::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("operationFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitOperation::apiObjItrState ()
   {
   return WitAT_OPERATION;
   }

//------------------------------------------------------------------------------

int WitOperation::nodeIndex () const
   {
   return myCompMgr ()->nParts () + mappingIndex_;
   }

//------------------------------------------------------------------------------

bool WitOperation::validYieldRate (double theValue)
   {
   if    (theValue >= 0.01 - FLOAT_EPSILON)
      if (theValue <= 1.0  + FLOAT_EPSILON)
         return true;

   return (theValue == 0.0);
   }

//------------------------------------------------------------------------------

bool WitOperation::cycleTime34PreventsExec (WitPeriod thePer)
   {
   witAssert (wit34Compatible ());

   if (cycleTime34 ()[thePer] < 0.0)
      return true;

   if (static_cast <int> (cycleTime34 ()[thePer]) > thePer)
      return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitOperation::setWit34Compatible (bool newValue)
   {
   WitPeriod thePer;

   if (wit34Compatible ())
      if (not newValue)
         {
         forEachPeriod (thePer, myProblem ())
            if (cycleTime34PreventsExec (thePer))
               if (yieldRate_[thePer] != 0.0)
                  yieldRate_.elemRef (thePer) = 0.0;

         cycleTime34_ = 0.0;
         }
   }

//------------------------------------------------------------------------------

void WitOperation::copyAttrsFrom (WitOperation * theOpn)
   {
   WitNode::copyAttrsFrom (theOpn);

   yieldRate_         = theOpn->yieldRate_;
   minLotSize_        = theOpn->minLotSize_;
   incLotSize_        = theOpn->incLotSize_;
   twoLevelLotSizes_  = theOpn->twoLevelLotSizes_;
   lotSize2Thresh_    = theOpn->lotSize2Thresh_;
   minLotSize2_       = theOpn->minLotSize2_;
   incLotSize2_       = theOpn->incLotSize2_;
   execPenalty_       = theOpn->execPenalty_;
   execCost_          = theOpn->execCost_;
   intExecVols_       = theOpn->intExecVols_;

   if (wit34Compatible ())
      cycleTime34_    = theOpn->cycleTime34_;

   execBounds_->
      copyAttrsFrom    (theOpn->execBounds_);
   }

//------------------------------------------------------------------------------

bool WitOperation::isCoproducing (WitPeriod execPer)
   {
   int           nBroadProduced;
   WitBopEntry * theBopEnt;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   nBroadProduced = 0;

   forEachEl (theBopEnt, bop ())
      if (theBopEnt->productRate ()[execPer] > 0.0)
         ++ nBroadProduced;

   forEachEl (theBomEnt, bom ())
      {
      if (theBomEnt->consRate ()[execPer] < 0.0)
         ++ nBroadProduced;

      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (theSub->consRate ()[execPer] < 0.0)
            ++ nBroadProduced;
      }

   return (nBroadProduced > 1);
   }

//------------------------------------------------------------------------------

void WitOperation::display ()
   {
   WitBomEntry * theBomEnt;
   WitBopEntry * theBopEnt;

   myMsgFac () ("opnIdDdMsg", operationName ());

   myMsgFac () ("opnScalarsDdMsg", 
      mappingIndex_,
      twoLevelLotSizes_,
      execPenalty_,
      intExecVols_);

   if (wit34Compatible ())
      myProblem ()->display ("cycleTime34DdMsg", cycleTime34_);

   myProblem ()->display ("yieldRateDdMsg",  yieldRate_);
   myProblem ()->display ("minLotSizeDdMsg", minLotSize_);
   myProblem ()->display ("incLotSizeDdMsg", incLotSize_);

   if (twoLevelLotSizes_)
      {
      myProblem ()->display ("lotSize2ThreshDdMsg", lotSize2Thresh_);
      myProblem ()->display ("minLotSize2DdMsg",    minLotSize2_);
      myProblem ()->display ("incLotSize2DdMsg",    incLotSize2_);
      }

   myProblem ()->display ("execCostDdMsg", execCost_);

   execBounds_->display ();

   if (myPreprocessor ()->preprocessed ())
      myMsgFac () ("executableDdMsg", executable_);

   myMsgFac () ("procBomHeadingDdMsg");

   if (bom_.isEmpty ())
      myMsgFac () ("noneDdMsg");
   else
      {
      myMsgFac () ("procBomHeading2DdMsg");

      forEachEl (theBomEnt, bom_)
         myMsgFac () ("procBomDataDdMsg",
            theBomEnt->myPartName (),
            theBomEnt->localIndex ());
      }

   myMsgFac () ("procBopHeadingDdMsg");

   if (bop_.isEmpty ())
      myMsgFac () ("noneDdMsg");
   else
      {
      myMsgFac () ("procBopHeading2DdMsg");

      forEachEl (theBopEnt, bop_)
         myMsgFac () ("procBopDataDdMsg",
            theBopEnt->myPartName (),
            theBopEnt->localIndex ());
      }

   WitDelComp::display ();
   }

//------------------------------------------------------------------------------

void WitOperation::clearExecVolForHeur ()
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   execVol_ = 0.0;
   }

//------------------------------------------------------------------------------

double WitOperation::lotSizeDelta (
      WitPeriod thePer,
      double    theExecVol,
      double    delta,
      bool      useTol)
   {
   double preLsVol;
   double lsVol;

   if (not lotSizeMode (thePer))
      return delta;

   preLsVol = theExecVol + delta;

   if (preLsVol < FLOAT_EPSILON)
      return delta;

   if (not twoLevelLotSizes_)
      lsVol =
         lotSizedExecVol (
            thePer, 
            preLsVol,
            minLotSize_, 
            incLotSize_, 
            useTol);
   else
      lsVol = tllsExecVol (thePer, preLsVol, useTol);

   return lsVol - theExecVol;
   }

//------------------------------------------------------------------------------

void WitOperation::writeSoln ()
   {
   WitPeriod thePer;

   fprintf (solnFile (),
      "\nOperation %s:\n",
      operationName ().myCstring ());

   fprintf (solnFile (), "Period      ExecVol");

   if (fssComputed ())
      fprintf (solnFile (), "   FssExecVol");

   fprintf (solnFile (), "\n");

   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d", thePer);

      writeSolnValue (execVol ()[thePer]);

      if (fssComputed ())
         writeSolnValue (fssExecVol ()[thePer]);

      fprintf (solnFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

void WitOperation::writeMrpSoln ()
   {
   WitPeriod thePer;

   fprintf (solnFile (), "\nOperation %s:\n", operationName ().myCstring ());

   fprintf (solnFile (), "Period   MrpExecVol\n");

   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d", thePer);

      writeSolnValue (mrpExecVol_[thePer]);

      fprintf (solnFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

WitBoundSet * WitOperation::myBoundSet ()
   {
   return execBounds_;
   }

//------------------------------------------------------------------------------

void WitOperation::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("operation");
   myDataWriter ()->writeStringValue  (operationName ());
   }

//------------------------------------------------------------------------------

void WitOperation::writeDataAttrs ()
   {
   WitNode::writeDataAttrs ();

   myDataWriter ()->writeVector (
      "yieldRate",
      yieldRate_,
      defYieldRate ());

   myDataWriter ()->writeVector (
      "minLotSize",
      minLotSize_,
      defMinLotSize ());

   myDataWriter ()->writeVector (
      "incLotSize",
      incLotSize_,
      defIncLotSize ());

   myDataWriter ()->writeBool (
      "twoLevelLotSizes",
      twoLevelLotSizes_,
      defTwoLevelLotSizes ());

   myDataWriter ()->writeVector (
      "lotSize2Thresh",
      lotSize2Thresh_,
      defLotSize2Thresh ());

   myDataWriter ()->writeVector (
      "minLotSize2",
      minLotSize2_,
      defMinLotSize2 ());

   myDataWriter ()->writeVector (
      "incLotSize2",
      incLotSize2_,
      defIncLotSize2 ());

   myDataWriter ()->writeDouble (
      "execPenalty",
      execPenalty_,
      defExecPenalty ());

   myDataWriter ()->writeObjVec (
        "execCost",
         execCost_,
      defExecCost ());

   myDataWriter ()->writeBool (
      "intExecVols",
      intExecVols_,
      defIntExecVols ());

   if (wit34Compatible ())
      myDataWriter ()->writeVector (
         "cycleTime34",
         cycleTime34_,
         defCycleTime34 ());

   execBounds_->writeData ();
   }

//------------------------------------------------------------------------------

void WitOperation::purgeCompListsSpec ()
   {
   purgeSelComps (bom_);
   purgeSelComps (bop_);
   }

//------------------------------------------------------------------------------

void WitOperation::clearDepListsSpec ()
   {
   bom_.clear ();
   bop_.clear ();
   }

//------------------------------------------------------------------------------

bool WitOperation::lotSizeMode (WitPeriod thePer)
   {
   if (not myGlobalComp ()->lotSizesExist ())
      return false;

   if (not myProblem ()->myOrigMrpExp ()->exploding ())
      if (not myProblem ()->currentVariant ()->respectsLotSizes ())
         return false;

   if (incLotSize_[thePer] < 0.0009)
      return false;

   return true;
   }

//------------------------------------------------------------------------------

double WitOperation::tllsExecVol (
      WitPeriod thePer,
      double    theExecVol,
      bool      useTol)
   {
   double ls2t;
   double ls1Vol;

   ls2t = lotSize2Thresh_[thePer];

   if (theExecVol >= ls2t - myGlobalComp ()->lotSizeTol ())
      return
         lotSizedExecVol (
            thePer, 
            theExecVol,
            minLotSize2_, 
            incLotSize2_, 
            useTol);

   ls1Vol =
      lotSizedExecVol (
         thePer, 
         theExecVol,
         minLotSize_, 
         incLotSize_, 
         useTol);

   if (ls1Vol >= ls2t - myGlobalComp ()->lotSizeTol ())
      return
         lotSizedExecVol (
            thePer, 
            ls2t,
            minLotSize2_, 
            incLotSize2_, 
            useTol);
   else
      return ls1Vol;
   }

//------------------------------------------------------------------------------

double WitOperation::lotSizedExecVol (
      WitPeriod             thePer,
      double                theExecVol,
      const WitDblFlexVec & mlsVec,
      const WitDblFlexVec & ilsVec,
      bool                  useTol)
   {
   double mls;
   double ils;
   double gridCoord;

   witAssert (theExecVol >= NET_TOL);

   mls       = mlsVec[thePer];
   ils       = ilsVec[thePer];

   gridCoord = (theExecVol - mls) / ils;

   if (useTol)
      gridCoord -= myGlobalComp ()->lotSizeTol ();

   gridCoord = ceil (gridCoord);

   if (gridCoord < 0.0)
      gridCoord = 0.0;

   return mls + gridCoord * ils;
   }
@


1.134
log
@Heuristic Adjustment
@
text
@@


1.133
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d30 1
d224 7
a230 1
   myOptComp ()->schedOptStarter ()->beChosen ();
d232 2
a233 1
   prepSetUnpostAttr ();
@


1.132
log
@Multi-objective mode
@
text
@d17 1
a17 1
#include <Global.h>
@


1.131
log
@Multi-Objective Mode
@
text
@d56 1
a56 1
      execCostObjVec_   (myProblem (), defExecCost ()),
d203 1
a203 1
   execCostObjVec_ = theValue;
d281 1
a281 1
   execCostObjVec_ = theFlexVec;
d338 1
a338 1
   execCostObjVec_.writeDataMulti ("execCost", this, theObj);
d505 1
a505 1
   execCostObjVec_    = theOpn->execCostObjVec_;
d572 1
a572 1
   myProblem ()->display ("execCostDdMsg", execCostObjVec_);
d765 2
a766 2
      "execCost",
      execCostObjVec_,
@


1.130
log
@Multi-Objective Mode
@
text
@d56 1
a56 1
      execCost_         (myProblem (), defExecCost ()),
d203 1
a203 1
   execCost_ = theValue;
d281 1
a281 1
   execCost_ = theFlexVec;
d338 1
a338 1
   execCost_.writeDataMulti ("execCost", this, theObj);
d505 1
a505 1
   execCost_          = theOpn->execCost_;
d572 1
a572 1
   myProblem ()->display ("execCostDdMsg", execCost_);
d766 1
a766 1
      execCost_,
@


1.129
log
@Multi-Objective Mode
@
text
@d56 1
a56 1
      execCost_         (myProblem ()),
@


1.128
log
@Multi-Objective Mode
@
text
@d764 4
a767 1
   execCost_.writeDataSingle ("execCost");
@


1.127
log
@Multi-Objective Mode
@
text
@d572 1
a572 1
   execCost_.display ("execCostDdMsg");
@


1.126
log
@Multi-Objective Mode
@
text
@d203 1
a203 1
   execCost_.curDblFlexVec () = theValue;
d281 1
a281 1
   execCost_.curDblFlexVec () = theFlexVec;
d505 1
a507 2
   execCost_.copyFrom (theOpn->execCost_);

@


1.125
log
@Multi-Objective Mode
@
text
@d56 1
a56 1
      execCost_         (NULL),
a64 1
   execCost_   = newObjVec           (myProblem ());
a74 1
   delete execCost_;
d203 1
a203 1
   execCost_->curDblFlexVec () = theValue;
d281 1
a281 1
   execCost_->curDblFlexVec () = theFlexVec;
d338 1
a338 1
   execCost_->writeDataMulti ("execCost", this, theObj);
d507 1
a507 1
   execCost_->copyFrom (theOpn->execCost_);
d573 1
a573 1
   execCost_->display ("execCostDdMsg");
d765 1
a765 1
   execCost_->writeDataSingle ("execCost");
@


1.124
log
@Multi-Objective Mode
@
text
@d331 30
a412 7
bool WitOperation::inserted ()
   {
   return (myCompMgr ()->findOperation (operationName ().myCstring ()) == this);
   }

//------------------------------------------------------------------------------

a547 23
void WitOperation::writeObjVecs (WitObjective * theObj)
   {
   execCost_->writeDataMulti ("execCost", this, theObj);
   }

//------------------------------------------------------------------------------

void WitOperation::writeSolnData ()
   {
   if (execVol () == defExecVol ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("operation");
   myDataWriter ()->writeStringValue  (operationName ());

   myDataWriter ()->writeVector ("execVol", execVol (), defExecVol ());

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

@


1.123
log
@Multi-Objective Mode
@
text
@d527 1
a527 6
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("operation");

   execCost_      ->writeDataMulti    ("execCost", theObj);

   myDataWriter ()->writeEndCommand   ();
@


1.122
log
@Multi-Objective Mode
@
text
@d398 9
@


1.121
log
@Multi-Objective Mode
@
text
@d516 12
d763 1
a763 1
   execCost_->writeData ("execCost");
@


1.120
log
@Multi-Objective Mode
@
text
@d751 1
a751 4
   myDataWriter ()->writeVector (
      "execCost",
      execCost (),
      defExecCost ());
@


1.119
log
@Multi-Objective Mode
@
text
@d56 1
a56 1
      execCostObjVec_   (NULL),
d65 2
a66 2
   execCostObjVec_ = newObjVec           (myProblem ());
   execBounds_     = new WitExecBoundSet (this);
d76 1
a76 1
   delete execCostObjVec_;
d205 1
a205 1
   execCostObjVec_->curDblFlexVec () = theValue;
d283 1
a283 1
   execCostObjVec_->curDblFlexVec () = theFlexVec;
d467 9
a475 9
   yieldRate_        = theOpn->yieldRate_;
   minLotSize_       = theOpn->minLotSize_;
   incLotSize_       = theOpn->incLotSize_;
   twoLevelLotSizes_ = theOpn->twoLevelLotSizes_;
   lotSize2Thresh_   = theOpn->lotSize2Thresh_;
   minLotSize2_      = theOpn->minLotSize2_;
   incLotSize2_      = theOpn->incLotSize2_;
   execPenalty_      = theOpn->execPenalty_;
   intExecVols_      = theOpn->intExecVols_;
d477 1
a477 1
   execCostObjVec_->copyFrom (theOpn->execCostObjVec_);
d480 1
a480 1
      cycleTime34_   = theOpn->cycleTime34_;
d483 1
a483 1
      copyAttrsFrom   (theOpn->execBounds_);
d559 1
a559 1
   myProblem ()->display ("execCostDdMsg", execCost ());
@


1.118
log
@Multi-Objective Mode
@
text
@d477 1
a477 1
   execCostObjVec_->curDblFlexVec () = theOpn->execCost ();
@


1.117
log
@Multi-Objective Mode
@
text
@d43 1
a44 1

a47 1

d56 1
a56 1
      execCostObjVec_   (newObjVecRef (myProblem ())),
d65 2
a66 1
   execBounds_ = new WitExecBoundSet (this);
d76 1
d205 1
a205 1
   execCostObjVec_.curDblFlexVec () = theValue;
d283 1
a283 1
   execCostObjVec_.curDblFlexVec () = theFlexVec;
d477 1
a477 1
   execCostObjVec_.curDblFlexVec () = theOpn->execCost ();
@


1.116
log
@Removing objective #2.
@
text
@d57 1
a57 1
      execCost_         (myProblem (), defExecCost ()),
d204 1
a204 1
   execCost_ = theValue;
d282 1
a282 1
   execCost_ = theFlexVec;
a473 1
   execCost_         = theOpn->execCost_;
d476 2
d558 1
a558 1
   myProblem ()->display ("execCostDdMsg", execCost_);
d752 1
a752 1
      execCost_,
@


1.115
log
@Removing objective #2.
@
text
@a23 1
#include <ObjFunc.h>
@


1.114
log
@Removing objective #2.
@
text
@d558 1
a558 1
   objChoice ()->displayForObj1 ("execCostDdMsg", execCost_);
@


1.113
log
@Object name change.
@
text
@a57 1
      obj2AuxCost_      (defObj2AuxCost ()),
a198 11
void WitOperation::setObj2AuxCost (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   obj2AuxCost_ = theValue;
   }

//------------------------------------------------------------------------------

a474 1
   obj2AuxCost_      = theOpn->obj2AuxCost_;
a543 2
   objChoice ()->displayForObj2 ("obj2AuxCostDdMsg", obj2AuxCost_);

a749 5
   myDataWriter ()->writeDouble (
      "obj2AuxCost",
      obj2AuxCost_,
      defObj2AuxCost ());

@


1.112
log
@Stochastic Implosion
@
text
@d91 7
@


1.111
log
@Stochastic Implosion
@
text
@d208 1
a208 1
   prepSetUnpostAttr ();
d284 9
@


1.110
log
@Stochastic Implosion
@
text
@d257 9
d284 1
a284 1
void WitOperation::storeStochExecVol (const WitDblFlexVec & theValue)
d288 1
a288 1
   execVol_ = theValue;
d293 1
a293 1
void WitOperation::storeMrpMrpExecVol (const WitTVec <double> & theValue)
d297 1
a297 1
   mrpExecVol_ = theValue;
d302 1
a302 1
void WitOperation::storeFssFssExecVol (const WitTVec <double> & theValue)
d306 1
a306 1
   fssExecVol_ = theValue;
a346 7
void WitOperation::passPreRefs ()
   {
   myPreprocessor ()->receiveRefs (this, executable_);
   }

//------------------------------------------------------------------------------

@


1.109
log
@Stochastic Implosion
@
text
@d292 9
a360 7
void WitOperation::passFssRefs ()
   {
   myFSS ()->receiveOperationRefs (fssExecVol_);
   }

//------------------------------------------------------------------------------

@


1.108
log
@Stochastic Implosion
@
text
@d283 9
a351 7
void WitOperation::passMrpRefs ()
   {
   myOrigMrpExp ()->receiveOperationRefs (mrpExecVol_);
   }

//------------------------------------------------------------------------------

@


1.107
log
@Stochastic Implosion
@
text
@d266 9
d334 5
a338 3
void WitOperation::importOptSoln ()
   {
   myDetOptImpMgr ()->exportSoln (this, execVol_);
@


1.106
log
@Stochastic Implosion
@
text
@d30 1
d257 9
d580 9
@


1.105
log
@Stochastic Implosion
@
text
@d336 9
@


1.104
log
@Stochastic Implosion
@
text
@d256 1
a256 1
void WitOperation::storeStochExecVol (const WitTVec <double> & theValue)
@


1.103
log
@Stochastic Implosion
@
text
@d258 3
a260 1
   storeStochAttr (execVol_, theValue);
d442 2
a443 1
   execBounds_->  set (theOpn->execBounds_);
d644 1
a644 1
WitBoundSet * WitOperation::myBoundSetForUpdate ()
d725 1
a725 1
   execBounds ()->writeData ();
@


1.102
log
@Stochastic Implosion
@
text
@d256 1
a256 1
void WitOperation::loadInStochExecVol (const WitTVec <double> & theValue)
d258 1
a258 1
   loadInStochAttr (execVol_, theValue);
@


1.101
log
@Stochastic Implosion
@
text
@d255 7
a319 7
void WitOperation::importStochSoln ()
   {
   myStochImpMgr ()->exportSoln (this, execVol_);
   }

//------------------------------------------------------------------------------

@


1.100
log
@Stochastic Implosion
@
text
@d13 1
a13 8
// Contains the declaration of the following class:
//
//    ExecBoundSet.
//
// Contains the implementation of the following classes:
//
//    Opn
//    ExecBoundSet
a828 54

//------------------------------------------------------------------------------
// Implementation of class ExecBoundSet.
//------------------------------------------------------------------------------

WitExecBoundSet::WitExecBoundSet (WitOperation * theOpn):
      WitBoundSet  (theOpn->myProblem ()),

      myOperation_ (theOpn)
   {
   }

//------------------------------------------------------------------------------

WitExecBoundSet::~WitExecBoundSet ()
   {
   }

//------------------------------------------------------------------------------

double WitExecBoundSet::boundedVal (WitPeriod thePer) const
   {
   return myOperation_->execVol ()[thePer];
   }

//------------------------------------------------------------------------------

WitAttr WitExecBoundSet::apiAttr () const
   {
   return "execBounds";
   }

//------------------------------------------------------------------------------

WitMsgID WitExecBoundSet::headingMsgID () const
   {
   return "execBoundsHeadingDdMsg";
   }

//------------------------------------------------------------------------------

WitAttr WitExecBoundSet::boundedVectorName () const
   {
   return "ExecVol";
   }

//------------------------------------------------------------------------------

void WitExecBoundSet::idObjectForSoln () const
   {
   fprintf (myProblem ()->solnFile (),
      "operation \"%s\":\n",
      myOperation_->operationName ().myCstring ());
   }
@


1.99
log
@Stochastic Implosion
@
text
@d38 1
a38 1
#include <OptImp.h>
d315 1
a315 1
   myOptImploder ()->exportSoln (this, execVol_);
@


1.98
log
@Stochastic Implosion
@
text
@d501 3
a503 2
   myMsgFac () ("operationDdMsg", 
      operationName (), 
a508 2
   myStochImpMgr ()->display (this);

@


1.97
log
@Stochastic Implosion
@
text
@d313 1
a313 1
void WitOperation::acquireOptSoln ()
d315 1
a315 1
   myOptImploder ()->provideSoln (this, execVol_);
d320 1
a320 1
void WitOperation::passMrpRefs ()
d322 1
a322 1
   myOrigMrpExp ()->receiveOperationRefs (mrpExecVol_);
d327 1
a327 1
void WitOperation::passFssRefs ()
d329 1
a329 1
   myFSS ()->receiveOperationRefs (fssExecVol_);
d334 1
a334 1
void WitOperation::passStochRefs ()
d336 1
a336 1
   myStochImpMgr ()->receiveOperationRefs (execVol_);
@


1.96
log
@Stochastic Implosion
@
text
@d315 1
a315 1
   myOptImploder ()->provideOperationSoln (execVol_);
@


1.95
log
@Stochastic Implosion
@
text
@a35 1
#include <PreData.h>
a305 7
void WitOperation::importPreData ()
   {
   executable_ = expPreData ()->executable () (this);
   }

//------------------------------------------------------------------------------

@


1.94
log
@Stochastic Implosion
@
text
@d300 7
@


1.93
log
@Stochastic Implosion
@
text
@d36 1
d300 7
a452 13
bool WitOperation::hasBomEntryInEffect (WitPeriod t)
   {
   WitBomEntry * theBomEnt;

   forEachEl (theBomEnt, bom ())
      if (theBomEnt->inEffect (t))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

a480 22
bool WitOperation::hasNegRateConsEntry (WitPeriod thePer)
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   forEachEl (theBomEnt, bom ())
      {
      if (theBomEnt->inEffect (thePer))
         if (theBomEnt->effConsRate ()[thePer] < 0.0)
            return true;

      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (theSub->inEffect (thePer))
            if (theSub->effConsRate ()[thePer] < 0.0)
               return true;
      }

   return false;
   }

//------------------------------------------------------------------------------

@


1.92
log
@Stochastic Implosion
@
text
@d306 1
a306 1
void WitOperation::importOptImpSoln (WitPeriod thePer)
d308 1
a308 1
   execVol_.elemRef (thePer) = myOptImploder ()->execVol (this, thePer);
@


1.91
log
@Stochastic Implosion
@
text
@d313 1
a313 1
void WitOperation::passMrpData ()
d315 1
a315 1
   myOrigMrpExp ()->receiveOperationData (mrpExecVol_);
d320 1
a320 1
void WitOperation::passFssData ()
d322 1
a322 1
   myFSS ()->receiveOperationData (fssExecVol_);
d327 1
a327 1
void WitOperation::passStochData ()
d329 1
a329 2
   myStochImpMgr ()->
      receiveOperationData (execVol_);
@


1.90
log
@Stochastic Implosion
@
text
@d315 1
a315 1
   myOrigMrpExp ()->receiveData (this, mrpExecVol_);
@


1.89
log
@Stochastic Implosion
@
text
@d322 1
a322 1
   myFSS ()->receiveData (this, fssExecVol_);
@


1.88
log
@Stochastic Implosion
@
text
@d327 1
a327 1
void WitOperation::clearStochSoln ()
d329 2
a330 8
   execVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitOperation::restoreStochSoln ()
   {
   execVol_ = myStochImpMgr ()->execVol (this);
@


1.87
log
@Stochastic Implosion
@
text
@d543 2
@


1.86
log
@Stochastic Implosion
@
text
@d313 1
a313 1
void WitOperation::importMrpSoln ()
d315 1
a315 1
   mrpExecVol_ = myOrigMrpExp ()->mrpExecVol (this);
@


1.85
log
@Stochastic Implosion
@
text
@d36 1
d320 7
@


1.84
log
@Stochastic Implosion
@
text
@d312 7
@


1.83
log
@Stochastic Implosion
@
text
@d278 55
a412 55
void WitOperation::copySelfInto (WitCompMgr * theCompMgr)
   {
   WitOperation * theOpn;

   theOpn = new WitOperation (operationName ().myCstring (), theCompMgr);

   theOpn->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitOperation::recount ()
   {
   mappingIndex_ = myCompMgr ()->nOperations ();

   myCompMgr ()->recountOperation (this);
   }

//------------------------------------------------------------------------------

void WitOperation::unpreprocess ()
   {
   executable_ = false;
   }

//------------------------------------------------------------------------------

void WitOperation::importOptImpSoln (WitPeriod thePer)
   {
   execVol_.elemRef (thePer) = myOptImploder ()->execVol (this, thePer);
   }

//------------------------------------------------------------------------------

void WitOperation::clearStochSoln ()
   {
   execVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitOperation::restoreStochSoln ()
   {
   execVol_ = myStochImpMgr ()->execVol (this);
   }

//------------------------------------------------------------------------------

WitOperation * WitOperation::thisOpn ()
   {
   return this;
   }

//------------------------------------------------------------------------------

@


1.82
log
@Stochastic Implosion
@
text
@d37 1
d385 7
@


1.81
log
@Stochastic Implosion
@
text
@d37 1
d384 14
@


1.80
log
@Stochastic Implosion
@
text
@a36 1
#include <StochImpMgr.h>
a234 2
   myStochImpMgr ()->prepSetStochAttr ();

@


1.79
log
@Stochastic Implosion
@
text
@d37 1
a37 1
#include <StochMgr.h>
d236 1
a236 1
   myStochMgr ()->prepSetStochAttr ();
@


1.78
log
@Stochastic Implosion
@
text
@d37 1
d236 2
@


1.77
log
@Stochastic implosion.
@
text
@d104 1
a104 1
   settingUnpreAttr ();
d117 1
a117 1
   settingUnpreAttr ();
d130 1
a130 1
   settingUnpreAttr ();
d139 1
a139 1
   settingUnpreAttr ();
d152 1
a152 1
   settingUnpreAttr ();
d165 1
a165 1
   settingUnpreAttr ();
d178 1
a178 1
   settingUnpreAttr ();
d189 1
a189 1
   settingUnpostAttr ();
d200 1
a200 1
   settingUnpostAttr ();
d211 1
a211 1
   settingUnpostAttr ();
d220 1
a220 1
   settingUnpreAttr ();
d235 1
a235 1
   settingUnpostAttr ();
d250 1
a250 1
   settingUnpreAttr ();
@


1.76
log
@Stochastic Implosion.
@
text
@d104 1
a104 1
   myPreprocessor ()->unpreprocess ();
d117 1
a117 1
   myPreprocessor ()->unpreprocess ();
d130 1
a130 1
   myPreprocessor ()->unpreprocess ();
d139 1
a139 1
   myPreprocessor ()->unpreprocess ();
d152 1
a152 1
   myPreprocessor ()->unpreprocess ();
d165 1
a165 1
   myPreprocessor ()->unpreprocess ();
d178 1
a178 1
   myPreprocessor ()->unpreprocess ();
d189 1
a189 1
   myProblem ()->resetSoln ();
d200 1
a200 1
   myProblem ()->resetSoln ();
d211 1
a211 1
   myProblem ()->resetSoln ();
d220 1
a220 1
   myPreprocessor ()->unpreprocess ();
d235 1
a235 1
   myProblem ()->resetSoln ();
d250 1
a250 1
   myPreprocessor ()->unpreprocess ();
@


1.75
log
@Stochastic Implosion.
@
text
@a70 2
   forbidAddStochAct ();

@


1.74
log
@Stochastic implosion.
@
text
@d39 1
d71 1
a71 1
   forbidAddStochAct ("operationFrag");
d285 1
a285 1
WitMsgFragID WitOperation::classFragID ()
d287 2
a288 1
   return "operationFrag";
d293 1
a293 1
void WitOperation::identifyInstance ()
d295 1
a295 2
   if (myMsgFac ().mayIssue ("operationInstIDMsg"))
      myMsgFac () ("operationInstIDMsg", operationName ());
@


1.73
log
@[disallowed backlog]
@
text
@d70 2
@


1.72
log
@[disallowed backlog]
@
text
@d23 1
d25 2
d30 1
a35 3
#include <FSS.h>
#include <HeurAllMgr.h>
#include <OptImp.h>
a642 10
void WitOperation::transmitDMPs ()
   {
   WitHeurAllMgr ::receiveDMPs (& WitOperation::execVol_);
   WitOptImploder::receiveDMPs (& WitOperation::execVol_);
   WitOrigMrpExp ::receiveDMPs (& WitOperation::mrpExecVol_);
   WitFSS        ::receiveDMPs (& WitOperation::fssExecVol_);
   }

//------------------------------------------------------------------------------

@


1.71
log
@Rescinded all changed made since 1/31/07.
@
text
@d644 4
a647 5
   WitPreprocessor::receiveDMPs (& WitOperation::executable_);
   WitHeurAllMgr  ::receiveDMPs (& WitOperation::execVol_);
   WitOptImploder ::receiveDMPs (& WitOperation::execVol_);
   WitOrigMrpExp  ::receiveDMPs (& WitOperation::mrpExecVol_);
   WitFSS         ::receiveDMPs (& WitOperation::fssExecVol_);
@


1.70
log
@[disallowed backlog]
@
text
@a46 5
      executable_       (myProblem ()),
      execVol_          (myProblem ()),
      mrpExecVol_       (myProblem ()),
      fssExecVol_       (myProblem ()),

d63 5
a67 1
      execBounds_       (NULL)
d227 9
a235 1
   myOptImploder ()->setExecVol (this, theValue);
d374 7
d524 1
a524 1
      myMsgFac () ("executableDdMsg", executable ());
d634 1
a634 1
      writeSolnValue (mrpExecVol ()[thePer]);
d642 11
@


1.69
log
@witCopy<Object>Data
@
text
@d47 5
d68 1
a68 5
      execVol_          (myProblem (), 0.0),
      execBounds_       (NULL),
      executable_       (myProblem (), false),
      mrpExecVol_       (myProblem (), 0.0),
      fssExecVol_       (myProblem (), 0.0)
d228 1
a228 9
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   myOptComp ()->schedOptStarter ()->beChosen ();

   myProblem ()->resetSoln ();

   execVol_ = theValue;
a366 7
void WitOperation::unpreprocess ()
   {
   executable_ = false;
   }

//------------------------------------------------------------------------------

d510 1
a510 1
      myMsgFac () ("executableDdMsg", executable_);
d620 1
a620 1
      writeSolnValue (mrpExecVol_[thePer]);
a627 11
void WitOperation::transmitDMPs ()
   {
   WitPreprocessor::receiveDMPs (& WitOperation::executable_);
   WitHeurAllMgr  ::receiveDMPs (& WitOperation::execVol_);
   WitOptImploder ::receiveDMPs (& WitOperation::execVol_);
   WitOrigMrpExp  ::receiveDMPs (& WitOperation::mrpExecVol_);
   WitFSS         ::receiveDMPs (& WitOperation::fssExecVol_);
   }

//------------------------------------------------------------------------------

@


1.68
log
@witCopy<Object>Data.
@
text
@d388 24
a591 24
void WitOperation::copyAttrsFrom (WitOperation * theOpn)
   {
   WitNode::copyAttrsFrom (theOpn);

   yieldRate_        = theOpn->yieldRate_;
   minLotSize_       = theOpn->minLotSize_;
   incLotSize_       = theOpn->incLotSize_;
   twoLevelLotSizes_ = theOpn->twoLevelLotSizes_;
   lotSize2Thresh_   = theOpn->lotSize2Thresh_;
   minLotSize2_      = theOpn->minLotSize2_;
   incLotSize2_      = theOpn->incLotSize2_;
   execPenalty_      = theOpn->execPenalty_;
   obj2AuxCost_      = theOpn->obj2AuxCost_;
   execCost_         = theOpn->execCost_;
   intExecVols_      = theOpn->intExecVols_;

   if (wit34Compatible ())
      cycleTime34_   = theOpn->cycleTime34_;

   execBounds_->  set (theOpn->execBounds_);
   }

//------------------------------------------------------------------------------

@


1.67
log
@External opt implosion.
@
text
@d568 24
a738 22
void WitOperation::copyAttrsFrom (WitOperation * theOpn)
   {
   WitNode::copyAttrsFrom (theOpn);

   yieldRate_        = theOpn->yieldRate_;
   minLotSize_       = theOpn->minLotSize_;
   incLotSize_       = theOpn->incLotSize_;
   twoLevelLotSizes_ = theOpn->twoLevelLotSizes_;
   lotSize2Thresh_   = theOpn->lotSize2Thresh_;
   minLotSize2_      = theOpn->minLotSize2_;
   incLotSize2_      = theOpn->incLotSize2_;
   execPenalty_      = theOpn->execPenalty_;
   obj2AuxCost_      = theOpn->obj2AuxCost_;
   execCost_         = theOpn->execCost_;
   intExecVols_      = theOpn->intExecVols_;
   if (wit34Compatible ())
      cycleTime34_   = theOpn->cycleTime34_;
   execBounds_->  set (theOpn->execBounds_);
   }

//------------------------------------------------------------------------------

@


1.66
log
@App controlled opt implosion.
@
text
@d61 1
a61 1
      intConExecVols_   (defIntConExecVols ()),
d216 1
a216 1
void WitOperation::setIntConExecVols (bool theValue)
d220 1
a220 1
   intConExecVols_ = theValue;
d477 1
a477 1
      intConExecVols_);
d700 3
a702 3
      "intConExecVols",
      intConExecVols_,
      defIntConExecVols ());
d729 1
a729 1
   intConExecVols_   = theOpn->intConExecVols_;
@


1.65
log
@App controlled opt implosion.
@
text
@d25 1
a30 1
#include <DataAlt.h>
d35 1
d96 1
a96 1
   prepDblVec (theValue, preprocAlt ());
d102 2
d111 7
a117 1
   minLotSize_ = prepNonNegDblVec (theValue, preprocAlt ());
d124 7
a130 1
   incLotSize_ = prepNonNegDblVec (theValue, preprocAlt ());
d137 3
a139 1
   twoLevelLotSizes_ = prepBool (theValue, preprocAlt ());
d146 7
a152 1
   lotSize2Thresh_ = prepNonNegDblVec (theValue, preprocAlt ());
d159 7
a165 1
   minLotSize2_ = prepNonNegDblVec (theValue, preprocAlt ());
d172 7
a178 1
   incLotSize2_ = prepNonNegDblVec (theValue, preprocAlt ());
d185 5
a189 1
   execPenalty_ = prepNonNegDouble (theValue, postprocAlt ());
d196 5
a200 1
   obj2AuxCost_ = prepNonNegDouble (theValue, postprocAlt ());
d207 5
a211 1
   execCost_ = prepDblVec (theValue, postprocAlt ());
d218 3
a220 1
   intConExecVols_ = prepBool (theValue, preprocAlt ());
d227 9
a235 1
   execVol_ = prepSchedVec (theValue, postprocAlt ());
d244 2
d248 2
d253 1
a253 1
   cycleTime34_ = prepDblVec (theValue, preprocAlt ());
@


1.64
log
@Integrality constraints.
@
text
@d438 1
a438 1
   if (myProblem ()->preprocessed ())
@


1.63
log
@Opt implosion with integrality constraints.
@
text
@d60 1
a60 1
      intExecVols_      (defIntExecVols ()),
d169 1
a169 1
void WitOperation::setIntExecVols (bool theValue)
d171 1
a171 1
   intExecVols_ = prepBool (theValue, preprocAlt ());
d416 1
a416 1
      intExecVols_);
d639 3
a641 3
      "intExecVols",
      intExecVols_,
      defIntExecVols ());
d668 1
a668 1
   intExecVols_      = theOpn->intExecVols_;
@


1.62
log
@Updated the copyright date on all source files.
@
text
@d60 1
d169 7
d415 2
a416 1
      execPenalty_);
d590 1
a590 1
      yieldRate (),
d595 1
a595 1
      minLotSize (),
d600 1
a600 1
      incLotSize (),
d605 1
a605 1
      twoLevelLotSizes (),
d610 1
a610 1
      lotSize2Thresh (),
d615 1
a615 1
      minLotSize2 (),
d620 1
a620 1
      incLotSize2 (),
d625 1
a625 1
      execPenalty (),
d630 1
a630 1
      obj2AuxCost (),
d635 1
a635 1
      execCost (),
d638 5
d646 1
a646 1
         cycleTime34 (),
d668 1
@


1.61
log
@Minor changes.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.60
log
@[multi-thread]
@
text
@a583 2
   execBounds ()->writeData ();

d634 2
a643 3
   twoLevelLotSizes_ = theOpn->twoLevelLotSizes_;
   execPenalty_      = theOpn->execPenalty_;
   obj2AuxCost_      = theOpn->obj2AuxCost_;
d647 1
d651 2
a653 3

   execBounds_->set (theOpn->execBounds_);

d655 2
a656 1
      cycleTime34_ = theOpn->cycleTime34_;
@


1.59
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@a318 35
void WitOperation::loadPre ()
   {
   myPreprocessor ()->loadDataFrom (this, executable_);
   }

//------------------------------------------------------------------------------

void WitOperation::loadMrp ()
   {
   myOrigMrpExp ()->loadDataFrom (this, mrpExecVol_);
   }

//------------------------------------------------------------------------------

void WitOperation::loadFss ()
   {
   myFSS ()->loadDataFrom (this, fssExecVol_);
   }

//------------------------------------------------------------------------------

void WitOperation::loadHeur ()
   {
   myHeurAllMgr ()->loadDataFrom (this, execVol_);
   }

//------------------------------------------------------------------------------

void WitOperation::loadOpt ()
   {
   myOptImploder ()->loadDataFrom (this, execVol_);
   }

//------------------------------------------------------------------------------

d548 11
@


1.58
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d59 1
a59 1
      obj1ExecCost_     (myProblem (), defObj1ExecCost ()),
d161 1
a161 1
void WitOperation::setObj1ExecCost (const WitIVRealArg & theValue)
d163 1
a163 1
   obj1ExecCost_ = prepDblVec (theValue, postprocAlt ());
d460 1
a460 1
   objChoice ()->displayForObj1 ("obj1ExecDdMsg", obj1ExecCost_);
d651 3
a653 3
      "obj1ExecCost",
      obj1ExecCost (),
      defObj1ExecCost ());
d677 1
a677 1
   obj1ExecCost_     = theOpn->obj1ExecCost_;
@


1.57
log
@Vector PropRt.
@
text
@d163 1
a163 1
   obj1ExecCost_ = prepObj1DblVec (theValue, postprocAlt ());
@


1.56
log
@Vector Prop-Rt.
@
text
@d35 1
a35 1
#include <InVecRA.h>
d90 1
a90 1
void WitOperation::setYieldRate (const WitInVecRA & theValue)
d105 1
a105 1
void WitOperation::setMinLotSize (const WitInVecRA & theValue)
d112 1
a112 1
void WitOperation::setIncLotSize (const WitInVecRA & theValue)
d126 1
a126 1
void WitOperation::setLotSize2Thresh (const WitInVecRA & theValue)
d133 1
a133 1
void WitOperation::setMinLotSize2 (const WitInVecRA & theValue)
d140 1
a140 1
void WitOperation::setIncLotSize2 (const WitInVecRA & theValue)
d161 1
a161 1
void WitOperation::setObj1ExecCost (const WitInVecRA & theValue)
d168 1
a168 1
void WitOperation::setExecVol (const WitInVecRA & theValue)
d175 1
a175 1
void WitOperation::setCycleTime34 (const WitInVecRA & theValue)
@


1.55
log
@Vector PropRt.
@
text
@d465 1
a465 1
       myProblem ()->display ("executableDdMsg", executable_);
@


1.54
log
@Fixed a numerical problem in the lot size logic.
@
text
@d465 1
a465 1
       myProblem ()->displayBoolVec ("executableDdMsg", executable_);
@


1.53
log
@Double Precision.
@
text
@d770 1
a770 2
   double doubleGP;
   int    intGP;
d774 2
a775 2
   mls      = mlsVec[thePer];
   ils      = ilsVec[thePer];
d777 1
a777 1
   doubleGP = (theExecVol - mls) / ils;
d780 1
a780 1
      doubleGP -= myGlobalComp ()->lotSizeTol ();
d782 1
a782 1
   intGP = static_cast <int> (ceil (doubleGP));
d784 2
a785 2
   if (intGP < 0)
      intGP = 0;
d787 1
a787 1
   return mls + intGP * ils;
@


1.52
log
@Double Precision.
@
text
@d100 1
a100 1
   yieldRate_.convCopy (theValue);
d107 1
a107 1
   minLotSize_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
d114 1
a114 1
   incLotSize_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
d128 1
a128 1
   lotSize2Thresh_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
d135 1
a135 1
   minLotSize2_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
d142 1
a142 1
   incLotSize2_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
d163 1
a163 1
   obj1ExecCost_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
d170 1
a170 1
   execVol_.convCopy (prepSchedVec (theValue, postprocAlt ()));
d184 1
a184 1
   cycleTime34_.convCopy (prepDblVec (theValue, preprocAlt ()));
d279 1
a279 1
         cycleTime34_.setToScalar (0.0);
d307 1
a307 1
   executable_.setToScalar (false);
@


1.51
log
@Double Precision.
@
text
@d671 7
a677 8

   yieldRate_     .copy (theOpn->yieldRate_);
   minLotSize_    .copy (theOpn->minLotSize_);
   incLotSize_    .copy (theOpn->incLotSize_);
   lotSize2Thresh_.copy (theOpn->lotSize2Thresh_);
   minLotSize2_   .copy (theOpn->minLotSize2_);
   incLotSize2_   .copy (theOpn->incLotSize2_);
   obj1ExecCost_  .copy (theOpn->obj1ExecCost_);
d682 1
a682 1
      cycleTime34_.copy (theOpn->cycleTime34_);
@


1.50
log
@Double Precision.
@
text
@d175 1
a175 1
void WitOperation::setCycleTime34 (const float * theValue)
@


1.49
log
@Double Precision.
@
text
@d175 1
a175 1
void WitOperation::setCycleTime34 (const WitInVecRA & theValue)
@


1.48
log
@Double Precision.
@
text
@a89 15
void WitOperation::setYieldRate (const float * theValue)
   {
   WitPeriod thePer;

   prepDblVec (theValue, preprocAlt ());

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         witAssert (validYieldRate (dblFromFlt (theValue[thePer])));

   yieldRate_.convCopy (theValue);
   }

//------------------------------------------------------------------------------

a104 7
void WitOperation::setMinLotSize (const float * theValue)
   {
   minLotSize_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
   }

//------------------------------------------------------------------------------

a111 7
void WitOperation::setIncLotSize (const float * theValue)
   {
   incLotSize_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
   }

//------------------------------------------------------------------------------

a125 7
void WitOperation::setLotSize2Thresh (const float * theValue)
   {
   lotSize2Thresh_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
   }

//------------------------------------------------------------------------------

a132 7
void WitOperation::setMinLotSize2 (const float * theValue)
   {
   minLotSize2_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
   }

//------------------------------------------------------------------------------

a139 7
void WitOperation::setIncLotSize2 (const float * theValue)
   {
   incLotSize2_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
   }

//------------------------------------------------------------------------------

a160 7
void WitOperation::setObj1ExecCost (const float * theValue)
   {
   obj1ExecCost_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
   }

//------------------------------------------------------------------------------

a170 14
   }

//------------------------------------------------------------------------------

void WitOperation::setCycleTime34 (const float * theValue)
   {
   WitBomEntry * theBomEnt;

   witAssert (wit34Compatible ());

   forEachEl (theBomEnt, bom ())
      theBomEnt->adjustOffset (theValue);

   cycleTime34_.convCopy (prepDblVec (theValue, preprocAlt ()));
@


1.47
log
@Double Precision.
@
text
@d35 1
d105 15
d127 7
d141 7
d162 7
d176 7
d190 7
d218 8
a225 1
void WitOperation::setExecVol (const float * theValue)
d233 14
@


1.46
log
@Double Precision.
@
text
@d93 1
a93 1
   prepFloatVec (theValue, preprocAlt ());
d106 1
a106 1
   minLotSize_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d113 1
a113 1
   incLotSize_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d127 1
a127 1
   lotSize2Thresh_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d134 1
a134 1
   minLotSize2_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d141 1
a141 1
   incLotSize2_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d162 1
a162 1
   obj1ExecCost_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
d183 1
a183 1
   cycleTime34_.convCopy (prepFloatVec (theValue, preprocAlt ()));
@


1.45
log
@Double Precision.
@
text
@d99 1
a99 1
   convCopy (yieldRate_, theValue);
d106 1
a106 1
   convCopy (minLotSize_, prepNonNegFloatVec (theValue, preprocAlt ()));
d113 1
a113 1
   convCopy (incLotSize_, prepNonNegFloatVec (theValue, preprocAlt ()));
d127 1
a127 1
   convCopy (lotSize2Thresh_, prepNonNegFloatVec (theValue, preprocAlt ()));
d134 1
a134 1
   convCopy (minLotSize2_, prepNonNegFloatVec (theValue, preprocAlt ()));
d141 1
a141 1
   convCopy (incLotSize2_, prepNonNegFloatVec (theValue, preprocAlt ()));
d162 1
a162 1
   convCopy (obj1ExecCost_, prepObj1FloatVec (theValue, postprocAlt ()));
d169 1
a169 1
   convCopy (execVol_, prepSchedVec (theValue, postprocAlt ()));
d183 1
a183 1
   convCopy (cycleTime34_, prepFloatVec (theValue, preprocAlt ()));
d762 5
a766 5
      WitPeriod                   thePer,
      double                      theExecVol,
      const WitFlexVec <double> & mlsVec,
      const WitFlexVec <double> & ilsVec,
      bool                        useTol)
@


1.44
log
@Double Precision.
@
text
@d99 1
a99 1
   yieldRate_.convCopy (theValue);
d106 1
a106 1
   minLotSize_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d113 1
a113 1
   incLotSize_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d127 1
a127 1
   lotSize2Thresh_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d134 1
a134 1
   minLotSize2_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d141 1
a141 1
   incLotSize2_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
d162 1
a162 1
   obj1ExecCost_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
d183 1
a183 1
   cycleTime34_.convCopy (prepFloatVec (theValue, preprocAlt ()));
d276 1
a276 1
                  yieldRate_.setElem (thePer, 0.0);
d762 5
a766 5
      WitPeriod          thePer,
      double             theExecVol,
      const WitRealVec & mlsVec,
      const WitRealVec & ilsVec,
      bool               useTol)
@


1.43
log
@Double Precision.
@
text
@d97 1
a97 1
         witAssert (validYieldRate (theValue[thePer]));
d240 1
a240 1
bool WitOperation::validYieldRate (float theValue)
d810 1
a810 1
float WitExecBoundSet::boundedVal (WitPeriod t) const
d812 1
a812 1
   return myOperation_->execVol ()[t];
@


1.42
log
@Double Precision.
@
text
@d534 1
a534 1
   WitPeriod t;
d547 1
a547 1
   forEachPeriod (t, myProblem ())
d549 1
a549 1
      fprintf (solnFile (), "%6d", t);
d551 1
a551 1
      writeSolnValue (execVol ()[t]);
d554 1
a554 1
         writeSolnValue (fssExecVol ()[t]);
@


1.41
log
@Double Precision.
@
text
@d276 1
a276 1
                  yieldRate_.elemRef (thePer) = 0.0;
d564 1
a564 1
   WitPeriod t;
d570 1
a570 1
   forEachPeriod (t, myProblem ())
d572 1
a572 1
      fprintf (solnFile (), "%6d", t);
d574 1
a574 1
      writeSolnValue (mrpExecVol_[t]);
d667 11
a677 11
   twoLevelLotSizes_ = theOpn->twoLevelLotSizes ();
   execPenalty_      = theOpn->execPenalty ();
   obj2AuxCost_      = theOpn->obj2AuxCost ();

   yieldRate_     .copy (theOpn->yieldRate ());
   minLotSize_    .copy (theOpn->minLotSize ());
   incLotSize_    .copy (theOpn->incLotSize ());
   lotSize2Thresh_.copy (theOpn->lotSize2Thresh ());
   minLotSize2_   .copy (theOpn->minLotSize2 ());
   incLotSize2_   .copy (theOpn->incLotSize2 ());
   obj1ExecCost_  .copy (theOpn->obj1ExecCost ());
d679 1
a679 1
   execBounds_->set (theOpn->execBounds ());
d682 1
a682 1
      cycleTime34_.copy (theOpn->cycleTime34 ());
d762 5
a766 5
      WitPeriod                  thePer,
      double                     theExecVol,
      const WitFlexVec <float> & mlsVec,
      const WitFlexVec <float> & ilsVec,
      bool                       useTol)
@


1.40
log
@Double Precision.
@
text
@d99 1
a99 1
   yieldRate_.copyCVec (theValue);
d106 1
a106 1
   minLotSize_.copyCVec (prepNonNegFloatVec (theValue, preprocAlt ()));
d113 1
a113 1
   incLotSize_.copyCVec (prepNonNegFloatVec (theValue, preprocAlt ()));
d127 1
a127 1
   lotSize2Thresh_.copyCVec (prepNonNegFloatVec (theValue, preprocAlt ()));
d134 1
a134 1
   minLotSize2_.copyCVec (prepNonNegFloatVec (theValue, preprocAlt ()));
d141 1
a141 1
   incLotSize2_.copyCVec (prepNonNegFloatVec (theValue, preprocAlt ()));
d162 1
a162 1
   obj1ExecCost_.copyCVec (prepObj1FloatVec (theValue, postprocAlt ()));
d183 1
a183 1
   cycleTime34_.copyCVec (prepFloatVec (theValue, preprocAlt ()));
@


1.39
log
@Double Precision.
@
text
@d169 1
a169 1
   copyInto (execVol_, prepSchedVec (theValue, postprocAlt ()));
@


1.38
log
@Continued double precision.
@
text
@d99 1
a99 1
   yieldRate_.copyCvector (theValue);
d106 1
a106 1
   minLotSize_.copyCvector (prepNonNegFloatVec (theValue, preprocAlt ()));
d113 1
a113 1
   incLotSize_.copyCvector (prepNonNegFloatVec (theValue, preprocAlt ()));
d127 1
a127 1
   lotSize2Thresh_.copyCvector (prepNonNegFloatVec (theValue, preprocAlt ()));
d134 1
a134 1
   minLotSize2_.copyCvector (prepNonNegFloatVec (theValue, preprocAlt ()));
d141 1
a141 1
   incLotSize2_.copyCvector (prepNonNegFloatVec (theValue, preprocAlt ()));
d162 1
a162 1
   obj1ExecCost_.copyCvector (prepObj1FloatVec (theValue, postprocAlt ()));
d183 1
a183 1
   cycleTime34_.copyCvector (prepFloatVec (theValue, preprocAlt ()));
@


1.37
log
@Continued double precision.
@
text
@d146 1
a146 1
void WitOperation::setExecPenalty (StrDbl theValue)
d148 1
a148 1
   execPenalty_ = prepNonNegStrDbl (theValue, postprocAlt ());
d153 1
a153 1
void WitOperation::setObj2AuxCost (StrDbl theValue)
d155 1
a155 1
   obj2AuxCost_ = prepNonNegStrDbl (theValue, postprocAlt ());
d639 1
a639 1
   myDataWriter ()->writeStrDbl (
d644 1
a644 1
   myDataWriter ()->writeStrDbl (
@


1.36
log
@Continued double precision.
@
text
@d725 1
a725 1
   float  ls2t;
@


1.35
log
@Removed a bad function overload.
@
text
@d146 1
a146 1
void WitOperation::setExecPenalty (float theValue)
d148 1
a148 1
   execPenalty_ = prepNonNegFloat (theValue, postprocAlt ());
d153 1
a153 1
void WitOperation::setObj2AuxCost (float theValue)
d155 1
a155 1
   obj2AuxCost_ = prepNonNegFloat (theValue, postprocAlt ());
d639 1
a639 1
   myDataWriter ()->writeFloat (
d644 1
a644 1
   myDataWriter ()->writeFloat (
@


1.34
log
@Continued implementation of post-implosion pegging.
@
text
@d311 1
a311 1
WitOperation * WitOperation::myOpn ()
@


1.33
log
@Made modifications to improve the speed of witPurgeData.
@
text
@a36 1
#include <FlexVecI.h>
@


1.32
log
@Continued implementation of proportionate routing.
@
text
@d221 2
a222 1
   myMsgFac () ("operationInstIDMsg", operationName ());
@


1.31
log
@Continued implementation of proportionate routing.
@
text
@d311 1
a311 1
void WitOperation::getOperation (WitOperation * & theOpn)
d313 1
a313 1
   theOpn = this;
@


1.30
log
@Changed some C style casts to C++ style.
@
text
@d80 7
@


1.29
log
@Internal changes.
@
text
@d251 1
a251 1
   if ((int) cycleTime34 ()[thePer] > thePer)
d776 1
a776 1
   intGP = (int) ceil (doubleGP);
@


1.28
log
@Internal changes.
@
text
@d264 1
a264 1
      if (! newValue)
d501 1
a501 1
   if (! lotSizeMode (thePer))
d509 1
a509 1
   if (! twoLevelLotSizes_)
d698 1
a698 1
   if (! myGlobalComp ()->lotSizesExist ())
d701 2
a702 2
   if (! myProblem ()->myOrigMrpExp ()->exploding ())
      if (! myProblem ()->currentVariant ()->respectsLotSizes ())
@


1.27
log
@Continued implementation of two-level lot sizes.
@
text
@d63 1
a63 1
      executable_       (myProblem (), witFALSE),
d112 1
a112 1
void WitOperation::setTwoLevelLotSizes (WitBoolean theValue)
d114 1
a114 1
   twoLevelLotSizes_ = prepBoolean (theValue, preprocAlt ());
d198 1
a198 1
WitBoolean WitOperation::inserted ()
d233 1
a233 1
WitBoolean WitOperation::validYieldRate (float theValue)
d237 1
a237 1
         return witTRUE;
d244 1
a244 1
WitBoolean WitOperation::cycleTime34PreventsExec (WitPeriod thePer)
d249 1
a249 1
      return witTRUE;
d252 1
a252 1
      return witTRUE;
d254 1
a254 1
   return witFALSE;
d259 1
a259 1
void WitOperation::setWit34Compatible (WitBoolean newValue)
d299 1
a299 1
   executable_.setToScalar (witFALSE);
d346 1
a346 1
WitBoolean WitOperation::hasBomEntryInEffect (WitPeriod t)
d352 1
a352 1
         return witTRUE;
d354 1
a354 1
   return witFALSE;
d359 1
a359 1
WitBoolean WitOperation::isCoproducing (WitPeriod execPer)
d387 1
a387 1
WitBoolean WitOperation::hasNegRateConsEntry (WitPeriod thePer)
d396 1
a396 1
            return witTRUE;
d401 1
a401 1
               return witTRUE;
d404 1
a404 1
   return witFALSE;
d457 1
a457 1
       myMsgFac () ("executableDdMsg", executable_);
d493 4
a496 4
      WitPeriod  thePer,
      double     theExecVol,
      double     delta,
      WitBoolean useTol)
d612 1
a612 1
   myDataWriter ()->writeBoolean (
d696 1
a696 1
WitBoolean WitOperation::lotSizeMode (WitPeriod thePer)
d699 1
a699 1
      return witFALSE;
d703 1
a703 1
         return witFALSE;
d706 1
a706 1
      return witFALSE;
d708 1
a708 1
   return witTRUE;
d714 3
a716 3
      WitPeriod  thePer,
      double     theExecVol,
      WitBoolean useTol)
d759 1
a759 1
      WitBoolean                 useTol)
@


1.26
log
@Continued implementation of 2-level lot sizes.
@
text
@d44 1
a44 1
      WitNode         (theName, theCompMgr),
d46 20
a65 19
      mappingIndex_   (myCompMgr ()->nOperations ()),
      bom_            (),
      bop_            (),

      yieldRate_      (myProblem (), defYieldRate ()),
      minLotSize_     (myProblem (), defMinLotSize ()),
      incLotSize_     (myProblem (), defIncLotSize ()),
      lotSize2Thresh_ (myProblem (), defLotSize2Thresh ()),
      minLotSize2_    (myProblem (), defMinLotSize2 ()),
      incLotSize2_    (myProblem (), defIncLotSize2 ()),
      execPenalty_    (defExecPenalty ()),
      obj2AuxCost_    (defObj2AuxCost ()),
      obj1ExecCost_   (myProblem (), defObj1ExecCost ()),
      cycleTime34_    (myProblem (), defCycleTime34 ()),
      execVol_        (myProblem (), 0.0),
      execBounds_     (NULL),
      executable_     (myProblem (), witFALSE),
      mrpExecVol_     (myProblem (), 0.0),
      fssExecVol_     (myProblem (), 0.0)
d112 7
d121 1
a121 1
   lotSize2Thresh_.copyCvector (prepFloatVec (theValue, preprocAlt ()));
d433 2
a434 1
      execPenalty ());
d436 1
a436 1
   objChoice ()->displayForObj2 ("obj2AuxCostDdMsg", obj2AuxCost ());
d439 5
a443 1
      myProblem ()->display ("cycleTime34DdMsg", cycleTime34 ());
d445 6
a450 6
   myProblem ()->display ("yieldRateDdMsg",      yieldRate  ());
   myProblem ()->display ("minLotSizeDdMsg",     minLotSize ());
   myProblem ()->display ("incLotSizeDdMsg",     incLotSize ());
   myProblem ()->display ("lotSize2ThreshDdMsg", lotSize2Thresh ());
   myProblem ()->display ("minLotSize2DdMsg",    minLotSize2 ());
   myProblem ()->display ("incLotSize2DdMsg",    incLotSize2 ());
d452 1
a452 1
   objChoice ()->displayForObj1 ("obj1ExecDdMsg", obj1ExecCost ());
d454 1
a454 1
   execBounds ()->display ();
d461 1
a461 1
   if (bom ().isEmpty ())
d467 1
a467 1
      forEachEl (theBomEnt, bom ())
d475 1
a475 1
   if (bop ().isEmpty ())
d481 1
a481 1
      forEachEl (theBopEnt, bop ())
a498 1
   float  ls2t;
d509 1
a509 3
   ls2t = lotSize2Thresh_[thePer];

   if (ls2t < 0.0)
a516 9

   else if (preLsVol >= ls2t - myGlobalComp ()->lotSizeTol ())
      lsVol =
         lotSizedExecVol (
            thePer, 
            preLsVol,
            minLotSize2_, 
            incLotSize2_, 
            useTol);
d518 1
a518 18
      {
      lsVol =
         lotSizedExecVol (
            thePer, 
            preLsVol,
            minLotSize_, 
            incLotSize_, 
            useTol);

      if (lsVol >= ls2t - myGlobalComp ()->lotSizeTol ())
         lsVol =
            lotSizedExecVol (
               thePer, 
               ls2t,
               minLotSize2_, 
               incLotSize2_, 
               useTol);
      }
d612 5
d660 3
a662 2
   execPenalty_ = theOpn->execPenalty ();
   obj2AuxCost_ = theOpn->obj2AuxCost ();
d709 41
@


1.25
log
@Continued implementation of 2-level lot sizes.
@
text
@a112 3
   if (! myGlobalComp ()->allowTlls ())
      myMsgFac () ("lotSize2ThreshNYISmsg");

d485 3
a487 3
   double newExecVol;
   int    theGP;
   double lsQty;
d492 1
a492 1
   newExecVol = theExecVol + delta;
d494 1
a494 1
   if (newExecVol < FLOAT_EPSILON)
d497 1
a497 1
   theGP = lotSizeGridPoint (thePer, newExecVol, useTol);
d499 36
a534 4
   lsQty =
      (theGP < 0)?
         0.0:
         minLotSize_[thePer] + theGP * incLotSize_[thePer];
d536 1
a536 1
   return lsQty - theExecVol;
d723 6
a728 4
int WitOperation::lotSizeGridPoint (
      WitPeriod  thePer,
      double     qty,
      WitBoolean useTol)
d730 2
d735 4
a738 1
   witAssert (qty >= NET_TOL);
d740 1
a740 1
   doubleGP = (qty - minLotSize ()[thePer]) / incLotSize ()[thePer];
d750 1
a750 1
   return intGP;
@


1.24
log
@Continued implementation of 2-level lot sizes.
@
text
@d482 1
a482 1
void WitOperation::lotSizeDelta (
d485 1
a485 2
      double &   delta,
      WitBoolean upwards,
d493 1
a493 1
      return;
d498 1
a498 1
      return;
d500 1
a500 1
   theGP = lotSizeGridPoint (thePer, newExecVol, upwards, useTol);
d507 1
a507 1
   delta = lsQty - theExecVol;
a696 1
      WitBoolean upwards,
a698 1
   double adjustment;
d704 6
a709 15
   adjustment =
      useTol?
         (upwards?
            - myGlobalComp ()->lotSizeTol ():
            + myGlobalComp ()->lotSizeTol ()):
         0.0;

   doubleGP =
      (qty - minLotSize ()[thePer]) / incLotSize ()[thePer] + adjustment;

   intGP    =
      (int)
         (upwards?
            ceil  (doubleGP):
            floor (doubleGP));
d712 1
a712 4
      intGP =
         upwards?
             0:
            -1;
@


1.23
log
@Continued implementation of two-level lot sizes.
@
text
@d491 1
d501 1
a501 23
   theGP =
      myGlobalComp ()->lotSizeGridPoint (
         minLotSize ()[thePer],
         incLotSize ()[thePer],
         newExecVol,
         upwards,
         useTol);

   delta =
        compLotSizeQty (minLotSize ()[thePer], incLotSize ()[thePer], theGP) 
      - theExecVol;
   }

//------------------------------------------------------------------------------

WitBoolean WitOperation::lotSizeMode (WitPeriod thePer)
   {
   if (! myGlobalComp ()->lotSizesExist ())
      return witFALSE;

   if (! myProblem ()->myOrigMrpExp ()->exploding ())
      if (! myProblem ()->currentVariant ()->respectsLotSizes ())
         return witFALSE;
d503 4
a506 2
   if (incLotSize ()[thePer] < LOT_SIZE_TOL)
      return witFALSE;
d508 1
a508 11
   return witTRUE;
   }

//------------------------------------------------------------------------------

double WitOperation::compLotSizeQty (double minQty, double incQty, int theGP)
   {
   return 
      (theGP >= 0)?
         minQty + theGP * incQty:
         0.0;
d674 56
@


1.22
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d44 1
a44 1
      WitNode       (theName, theCompMgr),
d46 19
a64 16
      mappingIndex_ (myCompMgr ()->nOperations ()),
      bom_          (),
      bop_          (),

      yieldRate_    (myProblem (), defYieldRate ()),
      minLotSize_   (myProblem (), defMinLotSize ()),
      incLotSize_   (myProblem (), defIncLotSize ()),
      execPenalty_  (defExecPenalty ()),
      obj2AuxCost_  (defObj2AuxCost ()),
      obj1ExecCost_ (myProblem (), defObj1ExecCost ()),
      cycleTime34_  (myProblem (), defCycleTime34 ()),
      execVol_      (myProblem (), 0.0),
      execBounds_   (NULL),
      executable_   (myProblem (), witFALSE),
      mrpExecVol_   (myProblem (), 0.0),
      fssExecVol_   (myProblem (), 0.0)
d99 1
a99 1
   minLotSize_.copyCvector (prepNonNegFloatVec (theValue, postprocAlt ()));
d106 25
a130 1
   incLotSize_.copyCvector (prepNonNegFloatVec (theValue, postprocAlt ()));
d435 6
a440 3
   myProblem ()->display ("yieldRateDdMsg",  yieldRate  ());
   myProblem ()->display ("minLotSizeDdMsg", minLotSize ());
   myProblem ()->display ("incLotSizeDdMsg", incLotSize ());
d524 1
a524 1
   if (incLotSize ()[thePer] == 0.0)
d629 15
d675 7
a681 4
   yieldRate_   .copy (theOpn->yieldRate ());
   minLotSize_  .copy (theOpn->minLotSize ());
   incLotSize_  .copy (theOpn->incLotSize ());
   obj1ExecCost_.copy (theOpn->obj1ExecCost ());
@


1.21
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d37 1
@


1.20
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d503 4
a506 1
   return minQty + theGP * incQty;
@


1.19
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d23 1
@


1.18
log
@Continued implementation of single-source.
@
text
@d23 1
@


1.17
log
@Continued implementation of single-source.
@
text
@d31 1
d293 14
@


1.16
log
@Continued implementation of single-source.
@
text
@d261 7
d271 7
@


1.15
log
@Continued implementation of single-source.
@
text
@d30 1
d264 14
@


1.14
log
@Continued implementation of single-source.
@
text
@d25 1
a29 2
#include <OrigMrp.h>
#include <FSS.h>
a262 14
   }

//------------------------------------------------------------------------------

void WitOperation::importMrpResults ()
   {
   mrpExecVol_.copyTVec (myOrigMrpExp ()->mrpExecVol (this));
   }

//------------------------------------------------------------------------------

void WitOperation::importFssResults ()
   {
   fssExecVol_.copyTVec (myFSS ()->fssExecVol (this));
@


1.13
log
@Continued implementation of single-source.
@
text
@a24 1
#include <OrigMrp.h>
d29 2
d271 7
@


1.12
log
@Preliminary work on single source.
@
text
@d267 7
@


1.11
log
@Continued implementation of object iteration.
@
text
@d84 1
a84 1
   yieldRate_ = theValue;
d91 1
a91 1
   minLotSize_ = prepNonNegFloatVec (theValue, postprocAlt ());
d98 1
a98 1
   incLotSize_ = prepNonNegFloatVec (theValue, postprocAlt ());
d119 1
a119 1
   obj1ExecCost_ = prepObj1FloatVec (theValue, postprocAlt ());
d140 1
a140 1
   cycleTime34_ = prepFloatVec (theValue, preprocAlt ());
d234 1
a234 1
         cycleTime34_ = 0.0;
d577 7
a583 6
   yieldRate_    = theOpn->yieldRate ();
   minLotSize_   = theOpn->minLotSize ();
   incLotSize_   = theOpn->incLotSize ();
   execPenalty_  = theOpn->execPenalty ();
   obj2AuxCost_  = theOpn->obj2AuxCost ();
   obj1ExecCost_ = theOpn->obj1ExecCost ();
d588 1
a588 1
      cycleTime34_ = theOpn->cycleTime34 ();
@


1.10
log
@Continued implementation of object iteration.
@
text
@d182 1
a182 1
WitAttr WitOperation::apiItrState ()
@


1.9
log
@Continued implementation of object iteration.
@
text
@d184 1
a184 1
   return WitITR_AT_OPERATION;
@


1.8
log
@Began implementation of object iteration.
@
text
@d31 1
d182 1
a182 1
WitBoolean WitOperation::isanOperation ()
d184 1
a184 1
   return witTRUE;
d256 7
@


1.7
log
@Implemented and used class SelMgr.
@
text
@d31 1
@


1.6
log
@Coarse selection splitting.
@
text
@a597 6

implementClearContents (WitOperation)
   //
   // See RWClient.h.

//------------------------------------------------------------------------------
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d253 1
a253 1
   myCompMgr ()->recount (this);
@


1.4
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d124 1
a124 1
   copyTo (execVol_, prepSchedVec (theValue, postprocAlt ()));
d238 1
a238 1
void WitOperation::copyInto (WitCompMgr * theCompMgr)
@


1.3
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d271 1
a271 1
WitBoolean WitOperation::isCoproducing ()
d273 1
d278 1
a278 1
   int nBroadProduced = 0;
d281 1
a281 1
      if (theBopEnt->prodRate () > 0.0)
d286 1
a286 1
      if (theBomEnt->usageRate () < 0.0)
d290 1
a290 1
         if (theSub->usageRate () < 0.0)
d299 1
a299 1
WitBoolean WitOperation::hasNegRateConsEntry (WitPeriod t)
d306 2
a307 2
      if (theBomEnt->inEffect (t))
         if (theBomEnt->effUsageRate () < 0.0)
d311 2
a312 2
         if (theSub->inEffect (t))
            if (theSub->effUsageRate () < 0.0)
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d124 1
a124 1
   execVol_ = prepSchedVec (theValue, postprocAlt ());
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

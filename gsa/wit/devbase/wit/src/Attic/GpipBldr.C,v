head	1.32;
access;
symbols
	latest_sce_4_20_20060523:1.23.0.2
	sce_4_20_20060523:1.23
	latest_sce4_20_OSL:1.19.0.2
	sce_4_20_OSL:1.19;
locks; strict;
comment	@ * @;


1.32
date	2006.08.02.22.23.40;	author rjw;	state dead;
branches;
next	1.31;

1.31
date	2006.08.02.19.03.01;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.09.19.53.36;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.09.15.23.20;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.08.21.43.34;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.07.22.29.02;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.30.22.35.59;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.26.23.06.49;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.26.20.40.09;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.22.16.02.41;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.18.20.58.00;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.09.14.58.30;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.02.17.33.59;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.10.20.58.16;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.07.19.10.51;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.07.15.34.55;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.24.20.49.13;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.20.21.54.31;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.17.22.52.22;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.17.21.22.40;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.16.19.30.57;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.16.17.11.32;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.15.23.44.52;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.15.23.13.55;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.15.21.57.53;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.15.16.24.37;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.15.16.21.06;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.14.23.06.13;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.14.22.34.21;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.14.21.10.13;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.13.20.31.56;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.13.17.02.22;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.32
log
@GPIP migration.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "GpipBldr.C"
//
// Contains the implementation of the following classes:
//
//    GpipBldr
//------------------------------------------------------------------------------

#include <GpipBldr.h>
#include <GpipReqMgr.h>
#include <GpipReqSrc.h>
#include <GpipSeqEl.h>
#include <PipMgr.h>
#include <PipPgg.h>
#include <PipAttPgg.h>
#include <ExecPerSch.h>
#include <TripStack.h>
#include <Global.h>
#include <Material.h>
#include <Opn.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Demand.h>
#include <Mapping.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class GpipBldr.
//------------------------------------------------------------------------------

WitGpipBldr::WitGpipBldr (WitPipPgg * thePgg):

      WitPipBldr      (thePgg),

      myReqMgr_       (NULL),
      sideVol_        (myProblem (), 0.0),
      addedTo_        (myProblem (), false),
      incPegVol_      (myProblem (), 0.0),
      posDemPers_     (myProblem ()),
      nonExcStockVol_ (myProblem (), 0.0),
      npoNetStockVol_ (myProblem (), 0.0),
      pggStMatNpo_    (false)
   {
   myMsgFac () ("gpipMsg");

   myReqMgr_ = new WitGpipReqMgr (myProblem ());

   compSideVols (sideVol_);
   }

//------------------------------------------------------------------------------

WitGpipBldr::~WitGpipBldr ()
   {
   delete myReqMgr_;
   }

//------------------------------------------------------------------------------

void WitGpipBldr::buildPggSpec ()
   {
   placeShipmentReqs ();

   explodeAllReqs ();

   if (DEVELOPMENT)
      myReqMgr_->prtSizes ();

   if (myGlobalComp ()->prtGpipMaxRatio ())
      dispMaxPegRatio ();
   }

//------------------------------------------------------------------------------

void WitGpipBldr::placeShipmentReqs ()
   {
   WitDemTripStack theShipSeq (myProblem ());
   int             theSeqNo;
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;
   WitGpipReqSrc * theReqSrc;
   WitPart *       thePart;

   myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

   theSeqNo = -1;

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      theSeqNo ++;

      theReqSrc = myReqMgr_->newReqSrcForSeqNo (theSeqNo);

      thePart   = theDemand->demandedPart ();

      myReqMgr_->addReq (thePart, shipPer, theReqSrc, incShipVol);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeAllReqs ()
   {
   WitObjStack <WitPart>          unexpParts (myProblem ());
   WitMapping <WitOperation, int> nUnexpBopEnts;
   WitPart *                      thePart;
   WitMaterial *                  theMat;
   WitBopEntry *                  theBopEnt;
   WitOperation *                 theOpn;

   revCopyInto (unexpParts, myCompMgr ()->allParts ());

   nUnexpBopEnts.allocate (myProblem (), 0);

   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         nUnexpBopEnts (theBopEnt->myOperation ()) ++;

   while (unexpParts.pop (thePart))
      {
      if (not myGlobalComp ()->newPipPggOrder ())
         fillPartReqsOpo (thePart);

      else if (nPeriods () == 1)
         fillPartReqsOpo (thePart);

      else
         {
         theMat = thePart->thisMat ();

         if (theMat == NULL)
            fillPartReqsOpo (thePart);

         else if (theMat->stockVol () == 0.0)
            fillPartReqsOpo (thePart);

         else
            fillStMatReqsNpo (theMat);
         }

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         if (theBopEnt->expAllowed ())
            {
            theOpn = theBopEnt->myOperation ();

            nUnexpBopEnts (theOpn) --;

            if (nUnexpBopEnts (theOpn) == 0)
               fillOpnReqs (theOpn);
            }
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::fillPartReqsOpo (WitPart * thePart)
   {
   WitMaterial * theMat;
   WitPeriod     fillPer;

   if (not myGlobalComp ()->newPipPggOrder ())
      {
      theMat = thePart->thisMat ();

      if (theMat != NULL)
         compNonExcStockVol (theMat, nonExcStockVol_);
      }

   for (fillPer = lastPeriod (); fillPer >= 0; fillPer --)
      if (myReqMgr_->hasReqsFor (thePart, fillPer))
         {
         if (myGlobalComp ()->printDebug ())
            prtFillReqs (thePart, fillPer);

         myReqMgr_->loadCurReqList (thePart, fillPer);

         fillCurReqs (thePart, fillPer);

         myReqMgr_->clearCurReqList ();
         }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::fillCurReqs (WitPart * thePart, WitPeriod fillPer)
   {
   myReqMgr_->initReqListItr ();

   netWithSupply (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   explodeToProd (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   if (not myGlobalComp ()->newPipPggOrder ())
      {
      explodeToStock (thePart, fillPer);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }

   netWithSideVol (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   recordInfeas (thePart, fillPer);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::netWithSupply (WitPart * thePart, WitPeriod fillPer)
   {
   double          netSuppVol;
   WitGpipReqSrc * theReqSrc;
   double          incSuppVol;

   witAssert (not myReqMgr_->finishedReqListItr ());

   netSuppVol =
      thePart->supplyVol ()[fillPer] - compExcessVol (thePart, fillPer);

   while (netSuppVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netSuppVol, theReqSrc, incSuppVol);

      if (myGlobalComp ()->printDebug ())
         prtNetToSupply (thePart, fillPer, incSuppVol, theReqSrc);

      addToIncPegVol (incSuppVol, theReqSrc);

      if (pggStMatNpo_)
         myReqMgr_->recPegMatPerNpo (fillPer, incSuppVol, theReqSrc);
      }

   myPgg ()->
      supplyVolPgg ()->
         multiAppend (posDemPers_, thePart, fillPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeToProd (WitPart * thePart, WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;

   witAssert (not myReqMgr_->finishedReqListItr ());

   if (thePart->prodVol ()[fillPer] <= 0.0)
      return;

   if (not thePart->explodeable (fillPer))
      return;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      {
      if (not theBopEnt->expEligible (fillPer))
         continue;

      explodeBopEntry (theBopEnt, fillPer);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeBopEntry (
      WitBopEntry * theBopEnt,
      WitPeriod     fillPer)
   {
   WitPeriod execPerFirst;
   WitPeriod execPerLast;
   WitPeriod execPer;

   witAssert (theBopEnt->expEligible (fillPer));

   witAssert (not myReqMgr_->finishedReqListItr ());

   myExecPerSched ()->
      getExecPerRange (theBopEnt, fillPer, execPerFirst, execPerLast);

   for (execPer = execPerLast; execPer >= execPerFirst; execPer --)
      {
      if (not theBopEnt->execPerOKForExp (execPer))
         continue;

      if (theBopEnt->impactPeriod ()[execPer] != fillPer)
         continue;

      explodeToExecPer (theBopEnt, execPer);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeToExecPer (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer)
   {
   WitPart *       thePart;
   WitPeriod       prodPer;
   double          netProdVol;
   WitGpipReqSrc * theReqSrc;
   double          incProdVol;
   double          incExecVol;

   thePart    = theBopEnt->myPart ();
   prodPer    = theBopEnt->impactPeriod ()[execPer];

   netProdVol =
        theBopEnt->myOperation ()->execVol ()[execPer]
      * theBopEnt->effProdRate ()            [execPer];

   while (netProdVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netProdVol, theReqSrc, incProdVol);

      addToIncPegVol (incProdVol, theReqSrc);

      if (pggStMatNpo_)
         myReqMgr_->recPegMatPerNpo (prodPer, incProdVol, theReqSrc);

      incExecVol = incProdVol / theBopEnt->effProdRate ()[execPer];

      myReqMgr_->addReq (theBopEnt, execPer, theReqSrc, incExecVol);
      }

   myPgg ()->
      prodVolPgg ()->
         multiAppend (posDemPers_, thePart, prodPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeToStock (WitPart * thePart, WitPeriod fillPer)
   {
   WitMaterial *   theMat;
   WitPeriod       stockPer;
   double          netStockVol;
   WitGpipReqSrc * theReqSrc;
   double          incStockVol;

   witAssert (not myReqMgr_->finishedReqListItr ());

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return;

   if (fillPer == 0)
      return;

   stockPer    = fillPer - 1;

   netStockVol = nonExcStockVol_[stockPer];

   while (netStockVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netStockVol, theReqSrc, incStockVol);

      myReqMgr_->addReq (theMat, stockPer, theReqSrc, incStockVol);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::netWithSideVol (WitPart * thePart, WitPeriod fillPer)
   {
   double          netSideVol;
   WitGpipReqSrc * theReqSrc;
   double          incSideVol;

   netSideVol = sideVol_ (thePart)[fillPer];

   while (netSideVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netSideVol, theReqSrc, incSideVol);

      addToIncPegVol (incSideVol, theReqSrc);

      if (pggStMatNpo_)
         myReqMgr_->recPegMatPerNpo (fillPer, incSideVol, theReqSrc);
      }

   myPgg ()->
      sideVolPgg ()->
         multiAppend (posDemPers_, thePart, fillPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::recordInfeas (WitPart * thePart, WitPeriod thePer)
   {
   double          infeasVol;
   WitGpipReqSrc * theReqSrc;
   double          incReqVol;

   infeasVol = 0.0;

   while (not myReqMgr_->finishedReqListItr ())
      {
      myReqMgr_->advanceReqListItr (theReqSrc, incReqVol);

      infeasVol += incReqVol;
      }

   recInfeas (thePart, thePer, infeasVol);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::fillOpnReqs (WitOperation * theOpn)
   {
   WitPeriod       execPer;
   WitGpipReqSrc * theReqSrc;
   double          incExecVol;
   WitBomEntry *   theBomEnt;

   for (execPer = lastPeriod (); execPer >= 0; execPer --)
      {
      if (not myReqMgr_->hasReqsFor (theOpn, execPer))
         continue;

      myReqMgr_->loadCurReqList (theOpn, execPer);

      myReqMgr_->initReqListItr ();

      while (not myReqMgr_->finishedReqListItr ())
         {
         myReqMgr_->advanceReqListItr (theReqSrc, incExecVol);

         addToIncPegVol (incExecVol, theReqSrc);
         }

      myPgg ()->
         execVolPgg ()->
            multiAppend (posDemPers_, theOpn, execPer, incPegVol_);

      forEachEl (theBomEnt, theOpn->bom ())
         explodeBomEntry (theBomEnt, execPer);

      myReqMgr_->clearCurReqList ();
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeBomEntry (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitSubEntry * theSub;

   if (not theBomEnt->inEffect (execPer))
      return;

   pegSubVols (theBomEnt, execPer);

   myReqMgr_->initReqListItr ();

   explodeConsEntry (
      theBomEnt,
      execPer,
      theBomEnt->nonSubVol ()[execPer]);

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      if (myReqMgr_->finishedReqListItr ())
         return;

      explodeConsEntry (
         theSub,
         execPer,
         theSub->subVol ()[execPer]);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::pegSubVols (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   double          netNonSubVol;
   WitGpipReqSrc * theReqSrc;
   double          incNonSubVol;
   WitSubEntry *   theSub;
   double          netSubVol;
   double          incSubVol;

   if (not theBomEnt->hasSubsInEffect ()[execPer])
      return;

   myReqMgr_->initReqListItr ();

   netNonSubVol = theBomEnt->nonSubVol ()[execPer];

   while (netNonSubVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         return;

      myReqMgr_->advanceReqListItr (netNonSubVol, theReqSrc, incNonSubVol);
      }

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      netSubVol = theSub->subVol ()[execPer];

      while (netSubVol > NET_TOL)
         {
         if (myReqMgr_->finishedReqListItr ())
            break;

         myReqMgr_->advanceReqListItr (netSubVol, theReqSrc, incSubVol);

         addToIncPegVol (incSubVol, theReqSrc);
         }

      myPgg ()->
         subVolPgg ()->
            multiAppend (posDemPers_, theSub, execPer, incPegVol_);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeConsEntry (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         totExecVol)
   {
   WitPart *       consPart;
   WitPeriod       consPer;
   double          netExecVol;
   WitGpipReqSrc * theReqSrc;
   double          incExecVol;
   double          incConsVol;

   if (totExecVol <= NET_TOL)
      return;

   consPart   = theConsEnt->myPart ();

   consPer    = theConsEnt->impactPeriod ()[execPer];

   netExecVol = totExecVol;

   while (netExecVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netExecVol, theReqSrc, incExecVol);

      incConsVol = incExecVol * theConsEnt->effConsRate ()[execPer];

      if (incConsVol <= NET_TOL)
         continue;

      addToIncPegVol (incConsVol, theReqSrc);

      myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
      }

   myPgg ()->
      consVolPgg ()->
         multiAppend (posDemPers_, consPart, consPer, incPegVol_);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::addToIncPegVol (double pegVol, WitGpipReqSrc * theReqSrc)
   {
   WitGpipSeqElItr theItr;
   WitGpipSeqEl *  theSeqEl;
   WitDemand *     theDemand;
   WitPeriod       shipPer;

   witAssert (pegVol > NET_TOL);

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         if (addedTo_ (theDemand)[shipPer])
            continue;

         if (incPegVol_ (theDemand)[shipPer] == 0.0)
            posDemPers_.push (theDemand, shipPer);

         incPegVol_ (theDemand)[shipPer] += pegVol;

         addedTo_ (theDemand)[shipPer] = true;
         }

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         addedTo_ (theDemand)[shipPer] = false;
         }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::dispMaxPegRatio ()
   {
   WitSchedule <WitOperation, double> totPgdExecVol;
   WitDemand *                        theDemand;
   WitPeriod                          shipPer;
   WitTripStack <WitOperation>        theOpnTrips (myProblem ());
   WitOperation *                     theOpn;
   WitPeriod                          execPer;
   double                             pgdExecVol;
   double                             ratio;
   double                             maxRatio;
   WitOperation *                     maxOpn;
   WitPeriod                          maxExecPer;

   totPgdExecVol.allocate (myProblem (), 0.0);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         myPgg ()->
            execVolPgg ()->
               getPegTrips (theDemand, shipPer, theOpnTrips);

         while (theOpnTrips.pop (theOpn, execPer, pgdExecVol))
            totPgdExecVol (theOpn)[execPer] += pgdExecVol;
         }

   maxRatio = 0.0;

   maxOpn   = NULL;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (theOpn->execVol ()[execPer] > NET_TOL)
            {
            ratio =
                 totPgdExecVol (theOpn)[execPer]
               / theOpn->execVol ()    [execPer];

            if (ratio > maxRatio)
               {
               maxRatio   = ratio;
               maxOpn     = theOpn;
               maxExecPer = execPer;
               }
            }

   prtMaxPegRatio (maxRatio, maxOpn, maxExecPer);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::fillStMatReqsNpo (WitMaterial * theMat)
   {
   WitPeriod reqPer;
   double    totReqVol;

   pggStMatNpo_ = true;

   compNonExcStockVol (theMat, npoNetStockVol_);

   myReqMgr_->npoSortReqLists (theMat);

   if (theMat->supplyVol () != 0.0)
      pegToAttNpo (& WitGpipBldr::netWithSupply,  theMat);

   if (theMat->prodVol () != 0.0)
      pegToAttNpo (& WitGpipBldr::explodeToProd,  theMat);

   if (not (sideVol_ (theMat) == 0.0))
      pegToAttNpo (& WitGpipBldr::netWithSideVol, theMat);

   forEachPeriod (reqPer, myProblem ())
      {
      myReqMgr_->npoClearReqs (theMat, reqPer, totReqVol);

      recInfeas (theMat, reqPer, totReqVol);
      }

   pggStMatNpo_ = false;
   }

//------------------------------------------------------------------------------

void WitGpipBldr::pegToAttNpo (
      void (WitGpipBldr::* thePegFunc) (WitPart *, WitPeriod),
      WitMaterial *        theMat)
   {
   WitPeriod pegPer;
   double    unmatchVol;

   for (pegPer = lastPeriod (); pegPer >= 0; pegPer --)
      {
      myReqMgr_->prepPegMatPerNpo (theMat, pegPer, npoNetStockVol_[pegPer]);

      if (not myReqMgr_->finishedReqListItr ())
         (this->*thePegFunc) (theMat, pegPer);

      myReqMgr_->postPegMatPerNpo ();
      }

   myReqMgr_->postPegMatNpo (theMat, npoNetStockVol_, unmatchVol);

   recUnmatched (theMat, unmatchVol);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::prtFillReqs (WitPart * thePart, WitPeriod fillPer)
   {
   witAssert (myGlobalComp ()->printDebug ());

   fprintf (msgFile (),
      "\n"
      "Filling requirements for Part %s in Period %d:\n",
      thePart->partName ().myCstring (),
      fillPer);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::prtNetToSupply (
      WitPart *       thePart,
      WitPeriod       thePer,
      double          incSuppVol,
      WitGpipReqSrc * theReqSrc)
   {
   witAssert (myGlobalComp ()->printDebug ());

   fprintf (msgFile (),
      "\n"
      "Netting Against Supply:\n"
      "   Part:        %s\n"
      "   Period:      %d\n"
      "   Inc SuppVol: %.0f\n",
      thePart->partName ().myCstring (),
      thePer,
      incSuppVol);

   theReqSrc->print (msgFile (), "   ");
   }

//------------------------------------------------------------------------------

void WitGpipBldr::prtMaxPegRatio (
      double         ratio,
      WitOperation * theOpn,
      WitPeriod      execPer)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      pgdExecVol;

   fprintf (msgFile (),
      "Max pegging ratio: %.3f\n",
      ratio);

   if (theOpn == NULL)
      return;

   fprintf (msgFile (),
      "\n"
      "Occurred at:\n"
      "   Operation:     %s\n"
      "   Exec Per:      %d\n"
      "   ExecVol:       %.3f\n\n",
      theOpn->operationName ().myCstring (),
      execPer,
      theOpn->execVol ()[execPer]);

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         pgdExecVol =
            myPgg ()->
               execVolPgg ()->
                  pegVolFor (theDemand, shipPer, theOpn, execPer);

         if (pgdExecVol > NET_TOL)
            fprintf (msgFile (),
               "      Demand:     %s\n"
               "      ShipPer:    %d\n"
               "      PgdExecVol: %.3f\n\n",
               theDemand->demandName ().myCstring (),
               shipPer,
               pgdExecVol);
         }
   }
@


1.31
log
@GPIP migration.
@
text
@@


1.30
log
@New PIP pegging order.
@
text
@a53 2
   stronglyAssert (myGlobalComp ()->groupPipMode ());

@


1.29
log
@New PIP pegging order.
@
text
@d136 4
@


1.28
log
@New PIP pegging order.
@
text
@a57 4
   if (myGlobalComp ()->newPipPggOrder ())
      if (not myGlobalComp ()->allowGpipNpo ())
         myMsgFac () ("newPipOrdGpipNYASmsg");

@


1.27
log
@New PIP pegging order.
@
text
@d712 8
a719 3
   pegToAttNpo (& WitGpipBldr::netWithSupply,  theMat);
   pegToAttNpo (& WitGpipBldr::explodeToProd,  theMat);
   pegToAttNpo (& WitGpipBldr::netWithSideVol, theMat);
@


1.26
log
@New PIP pegging order.
@
text
@d51 2
a52 1
      npoNetStockVol_ (myProblem (), 0.0)
d124 1
d141 12
a152 1
         fillPartReqsNpo (thePart);
d174 3
a176 1
   theMat = thePart->thisMat ();
d178 3
a180 2
   if (theMat != NULL)
      compNonExcStockVol (theMat, nonExcStockVol_);
d212 3
a214 1
   explodeToStock (thePart, fillPer);
d216 3
a218 2
   if (myReqMgr_->finishedReqListItr ())
      return;
d253 2
a254 2
      if (myGlobalComp ()->newPipPggOrder ())
         myReqMgr_->recPegPartPerNpo (fillPer, incSuppVol, theReqSrc);
d349 2
a350 2
      if (myGlobalComp ()->newPipPggOrder ())
         myReqMgr_->recPegPartPerNpo (prodPer, incProdVol, theReqSrc);
d416 2
a417 2
      if (myGlobalComp ()->newPipPggOrder ())
         myReqMgr_->recPegPartPerNpo (fillPer, incSideVol, theReqSrc);
d701 1
a701 1
void WitGpipBldr::fillPartReqsNpo (WitPart * thePart)
d703 6
a708 3
   WitMaterial * theMat;
   WitPeriod     reqPer;
   double        totReqVol;
d710 1
a710 1
   theMat = thePart->thisMat ();
d712 3
a714 10
   if (theMat != NULL)
      compNonExcStockVol (theMat, npoNetStockVol_);
   else
      npoNetStockVol_ = 0.0;

   myReqMgr_->npoSortReqLists (thePart);

   pegToAttNpo (& WitGpipBldr::netWithSupply,  thePart);
   pegToAttNpo (& WitGpipBldr::explodeToProd,  thePart);
   pegToAttNpo (& WitGpipBldr::netWithSideVol, thePart);
d718 1
a718 1
      myReqMgr_->clearReqs (thePart, reqPer, totReqVol);
d720 1
a720 1
      recInfeas (thePart, reqPer, totReqVol);
d722 2
d730 1
a730 1
      WitPart *            thePart)
d737 1
a737 1
      myReqMgr_->prepPegPartPerNpo (thePart, pegPer, npoNetStockVol_[pegPer]);
d740 1
a740 1
         (this->*thePegFunc) (thePart, pegPer);
d742 1
a742 1
      myReqMgr_->postPegPartPerNpo ();
d745 1
a745 1
   myReqMgr_->postPegPartNpo (thePart, npoNetStockVol_, unmatchVol);
d747 1
a747 1
   recUnmatched (thePart, unmatchVol);
@


1.25
log
@New PIP pegging order.
@
text
@d686 1
a686 1
   double        infeasVol;
d703 1
a703 1
      infeasVol = myReqMgr_->npoTotReqVol (thePart, reqPer);
d705 1
a705 1
      recInfeas (thePart, reqPer, infeasVol);
d716 1
d728 3
a730 1
   myReqMgr_->postPegPartNpo (thePart, npoNetStockVol_);
@


1.24
log
@New PIP pegging order.
@
text
@d307 2
d313 3
a315 2
   WitPart *       thePart;
   WitPeriod       prodPer;
d330 3
a337 3
   thePart = theBopEnt->myPart ();
   prodPer = theBopEnt->impactPeriod ()[execPer];

d396 3
@


1.23
log
@New PIP pegging order.
@
text
@d50 2
a51 1
      nonExcStockVol_ (myProblem (), 0.0)
d136 4
a139 1
      fillPartReqs (thePart);
d156 1
a156 1
void WitGpipBldr::fillPartReqs (WitPart * thePart)
d233 3
d676 50
@


1.22
log
@Fixed a bug in IPIP and GPIP.
@
text
@d57 2
a58 1
      myMsgFac () ("newPipOrdGpipNYASmsg");
@


1.21
log
@New PIP pegging order.
@
text
@d43 1
a43 1
      WitPipBldr  (thePgg),
d45 6
a50 5
      myReqMgr_   (NULL),
      sideVol_    (myProblem (), 0.0),
      addedTo_    (myProblem (), false),
      incPegVol_  (myProblem (), 0.0),
      posDemPers_ (myProblem ())
d153 7
a159 1
   WitPeriod fillPer;
a207 1
   double          residVol;
d214 2
a215 3
   residVol   = positivePart (thePart->residualVol ()[fillPer]);

   netSuppVol = positivePart (thePart->supplyVol ()[fillPer] - residVol);
d354 1
a354 1
   netStockVol = theMat->stockVol ()[stockPer];
@


1.20
log
@Updated the copyright date on all source files.
@
text
@d55 3
d157 1
a157 1
         if (myGlobalComp ()->printGpip ())
d219 1
a219 1
      if (myGlobalComp ()->printGpip ())
d665 1
a665 1
   witAssert (myGlobalComp ()->printGpip ());
d682 1
a682 1
   witAssert (myGlobalComp ()->printGpip ());
@


1.19
log
@Minor update to GPIP.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.18
log
@Fixed a bug in GPIP.
@
text
@d34 1
d43 1
a43 1
      WitPipBldr         (thePgg),
d45 5
a49 6
      myReqMgr_          (NULL),
      sideVol_           (myProblem (), 0.0),
      nUnscannedBopEnts_ (myProblem (), 0),
      addedTo_           (myProblem (), false),
      incPegVol_         (myProblem (), 0.0),
      posDemPers_        (myProblem ())
a50 2
   WitBopEntry * theBopEnt;

a56 4
   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         nUnscannedBopEnts_ (theBopEnt->myOperation ()) ++;

d114 5
a118 1
   WitPart * thePart;
d120 1
a120 1
   WitObjStack <WitPart> reversedParts (myProblem ());
d122 1
a122 1
   revCopyInto (reversedParts, myCompMgr ()->allParts ());
d124 5
a128 1
   while (reversedParts.pop (thePart))
d132 10
a141 1
      fillOpnReqsAfter (thePart);
d406 1
a406 24
void WitGpipBldr::fillOpnReqsAfter (WitPart * thePart)
   {
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitPeriod      execPer;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         {
         theOpn = theBopEnt->myOperation ();

         nUnscannedBopEnts_ (theOpn) --;

         witAssert (nUnscannedBopEnts_ (theOpn) >= 0);

         if (nUnscannedBopEnts_ (theOpn) == 0)
            for (execPer = lastPeriod (); execPer >= 0; execPer --)
               fillOpnReqs (theOpn, execPer);
         }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::fillOpnReqs (WitOperation * theOpn, WitPeriod execPer)
d408 1
d413 4
a416 2
   if (not myReqMgr_->hasReqsFor (theOpn, execPer))
      return;
d418 1
a418 1
   myReqMgr_->loadCurReqList (theOpn, execPer);
d420 1
a420 1
   myReqMgr_->initReqListItr ();
d422 3
a424 3
   while (not myReqMgr_->finishedReqListItr ())
      {
      myReqMgr_->advanceReqListItr (theReqSrc, incExecVol);
d426 2
a427 2
      addToIncPegVol (incExecVol, theReqSrc);
      }
d429 3
a431 3
   myPgg ()->
      execVolPgg ()->
         multiAppend (posDemPers_, theOpn, execPer, incPegVol_);
d433 2
a434 2
   forEachEl (theBomEnt, theOpn->bom ())
      explodeBomEntry (theBomEnt, execPer);
d436 2
a437 1
   myReqMgr_->clearCurReqList ();
@


1.17
log
@Fixed a bug in GPIP.
@
text
@d60 2
a61 1
      nUnscannedBopEnts_ (theBopEnt->myOperation ()) ++;
d402 3
a404 2
      {
      theOpn = theBopEnt->myOperation ();
d406 1
a406 1
      nUnscannedBopEnts_ (theOpn) --;
d408 1
a408 1
      witAssert (nUnscannedBopEnts_ (theOpn) >= 0);
d410 4
a413 4
      if (nUnscannedBopEnts_ (theOpn) == 0)
         for (execPer = lastPeriod (); execPer >= 0; execPer --)
            fillOpnReqs (theOpn, execPer);
      }
@


1.16
log
@Fixed bugs:
   witWriteData didn't write problem.compPrices.
   witWriteData didn't write problem.accMethod.
   witCopyData  didn't copy  problem.solverLogFileName.
   witCopyData  didn't copy  problem.accMethod.
@
text
@a119 1
   WitPeriod fillPer;
d127 1
a127 2
      for (fillPer = lastPeriod (); fillPer >= 0; fillPer --)
         fillPartReqs (thePart, fillPer);
d129 1
a129 1
      fillNextOpnsReqs (thePart);
d135 1
a135 1
void WitGpipBldr::fillPartReqs (WitPart * thePart, WitPeriod fillPer)
d137 1
a137 2
   if (not myReqMgr_->hasReqsFor (thePart, fillPer))
      return;
d139 5
a143 2
   if (myGlobalComp ()->printGpip ())
      prtFillReqs (thePart, fillPer);
d145 1
a145 1
   myReqMgr_->loadCurReqList (thePart, fillPer);
d147 1
a147 1
   fillCurReqs (thePart, fillPer);
d149 2
a150 1
   myReqMgr_->clearCurReqList ();
d394 1
a394 1
void WitGpipBldr::fillNextOpnsReqs (WitPart * thePart)
@


1.15
log
@GPIP
@
text
@d408 1
a408 1
         for (execPer = nPeriods () - 1; execPer >= 0; execPer --)
@


1.14
log
@GPIP
@
text
@d82 3
d613 52
d698 47
@


1.13
log
@GPIP
@
text
@d55 2
@


1.12
log
@GPIP
@
text
@d47 2
a48 2
      preppedToPeg_      (myProblem (), false),
      totPegVol_         (myProblem (), 0.0),
d124 1
a124 1
         fillReqs (thePart, fillPer);
d126 1
a126 1
      explodeOperations (thePart);
d132 1
a132 1
void WitGpipBldr::fillReqs (WitPart * thePart, WitPeriod fillPer)
d201 1
a201 1
      prepToPeg (incSuppVol, theReqSrc);
d206 1
a206 1
         multiAppend (posDemPers_, thePart, fillPer, totPegVol_);
d211 1
a211 1
void WitGpipBldr::explodeToStock (WitPart * thePart, WitPeriod fillPer)
d213 1
a213 5
   WitMaterial *   theMat;
   WitPeriod       stockPer;
   double          netStockVol;
   WitGpipReqSrc * theReqSrc;
   double          incStockVol;
d217 1
a217 3
   theMat = thePart->thisMat ();

   if (theMat == NULL)
d220 1
a220 1
   if (fillPer == 0)
a222 23
   stockPer    = fillPer - 1;

   netStockVol = theMat->stockVol ()[stockPer];

   while (netStockVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netStockVol, theReqSrc, incStockVol);

      myReqMgr_->addReq (theMat, stockPer, theReqSrc, incStockVol);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeToProd (WitPart * thePart, WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;

   witAssert (not myReqMgr_->finishedReqListItr ());

d291 1
a291 1
      prepToPeg (incProdVol, theReqSrc);
d303 61
a363 1
         multiAppend (posDemPers_, thePart, prodPer, totPegVol_);
d368 21
a388 1
void WitGpipBldr::explodeOperations (WitPart * thePart)
d404 1
a404 1
            explodeOperation (theOpn, execPer);
d410 1
a410 1
void WitGpipBldr::explodeOperation (WitOperation * theOpn, WitPeriod execPer)
d427 1
a427 1
      prepToPeg (incExecVol, theReqSrc);
d432 1
a432 1
         multiAppend (posDemPers_, theOpn, execPer, totPegVol_);
d476 3
d480 2
a481 3
   double          netExecVol;
   WitGpipReqSrc * theReqSrc;
   double          incExecVol;
d488 1
a488 1
   netExecVol = theBomEnt->nonSubVol ()[execPer];
d490 1
a490 1
   while (netExecVol > NET_TOL)
d495 1
a495 1
      myReqMgr_->advanceReqListItr (netExecVol, theReqSrc, incExecVol);
d500 1
a500 1
      netExecVol = theSub->subVol ()[execPer];
d502 1
a502 1
      while (netExecVol > NET_TOL)
d507 1
a507 1
         myReqMgr_->advanceReqListItr (netExecVol, theReqSrc, incExecVol);
d509 1
a509 1
         prepToPeg (incExecVol, theReqSrc);
d514 1
a514 1
            multiAppend (posDemPers_, theSub, execPer, totPegVol_);
d535 3
d556 1
a556 1
      prepToPeg (incConsVol, theReqSrc);
d563 1
a563 26
         multiAppend (posDemPers_, consPart, consPer, totPegVol_);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::netWithSideVol (WitPart * thePart, WitPeriod fillPer)
   {
   double          netSideVol;
   WitGpipReqSrc * theReqSrc;
   double          incSideVol;

   netSideVol = sideVol_ (thePart)[fillPer];

   while (netSideVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         break;

      myReqMgr_->advanceReqListItr (netSideVol, theReqSrc, incSideVol);

      prepToPeg (incSideVol, theReqSrc);
      }

   myPgg ()->
      sideVolPgg ()->
         multiAppend (posDemPers_, thePart, fillPer, totPegVol_);
d568 1
a568 1
void WitGpipBldr::prepToPeg (double pegVol, WitGpipReqSrc * theReqSrc)
d584 1
a584 1
         if (preppedToPeg_ (theDemand)[shipPer])
d587 1
a587 1
         if (totPegVol_ (theDemand)[shipPer] == 0.0)
d590 1
a590 1
         totPegVol_ (theDemand)[shipPer] += pegVol;
d592 1
a592 1
         preppedToPeg_ (theDemand)[shipPer] = true;
d602 1
a602 1
         preppedToPeg_ (theDemand)[shipPer] = false;
a607 20
void WitGpipBldr::recordInfeas (WitPart * thePart, WitPeriod thePer)
   {
   double          infeasVol;
   WitGpipReqSrc * theReqSrc;
   double          incReqVol;

   infeasVol = 0.0;

   while (not myReqMgr_->finishedReqListItr ())
      {
      myReqMgr_->advanceReqListItr (theReqSrc, incReqVol);

      infeasVol += incReqVol;
      }

   recInfeas (thePart, thePer, infeasVol);
   }

//------------------------------------------------------------------------------

@


1.11
log
@GPIP
@
text
@d45 1
d59 2
a73 2
   checkRestrictions ();

a83 20
void WitGpipBldr::checkRestrictions ()
   {
   WitBopEntry * theBopEnt;
   WitBomEntry * theBomEnt;
   WitPeriod     thePer;

   forEachBopEntry (theBopEnt, myProblem ())
      if (not theBopEnt->expAllowed ())
         myMsgFac () ("gpipCaseNyiSmsg",
            "The problem contains an unexplodeable BOP entry.");

   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theBomEnt->consRate ()[thePer] < 0.0)
            myMsgFac () ("gpipCaseNyiSmsg",
               "The problem contains an cons rate < 0.");
   }

//------------------------------------------------------------------------------

d153 1
a153 1
   netAgainstSupply (thePart, fillPer);
d165 1
a165 1
   if (not DEBUG_MODE)
d168 2
d178 1
a178 1
void WitGpipBldr::netAgainstSupply (WitPart * thePart, WitPeriod fillPer)
d512 25
@


1.10
log
@GPIP
@
text
@d48 1
a48 4
      posDemPers_        (myProblem ()),
      maxInfeas_         (0.0),
      maxInfeasPart_     (NULL),
      maxInfeasPer_      (-1)
a78 2

   prtInfeas ();
d190 1
a190 1
   recInfeas (thePart, fillPer);
d569 1
a569 1
void WitGpipBldr::recInfeas (WitPart * thePart, WitPeriod thePer)
d584 1
a584 18
   if (infeasVol > maxInfeas_)
      {
      maxInfeas_     = infeasVol;
      maxInfeasPart_ = thePart;
      maxInfeasPer_  = thePer;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::prtInfeas ()
   {
   myMsgFac () ("pipMaxInfeasMsg", maxInfeas_);

   if (maxInfeas_ > 0.0)
      myMsgFac () ("gpipMaxInfDataMsg",
         maxInfeasPart_->partName (),
         maxInfeasPer_);
@


1.9
log
@GPIP
@
text
@a79 2
   myPgg ()->consolidatePegging ();

@


1.8
log
@GPIP
@
text
@d26 1
a48 1
      myDemTrips_        (myProblem ()),
d228 3
a230 3
   formDemTrips ();

   myPgg ()->supplyVolPgg ()->multiAppend (thePart, fillPer, myDemTrips_);
d330 2
d351 2
a352 1
   formDemTrips ();
d356 1
a356 4
         multiAppend (
            theBopEnt->myPart (),
            theBopEnt->impactPeriod ()[execPer],
            myDemTrips_);
d403 3
a405 3
   formDemTrips ();

   myPgg ()->execVolPgg ()->multiAppend (theOpn, execPer, myDemTrips_);
d483 3
a485 3
      formDemTrips ();

      myPgg ()->subVolPgg ()->multiAppend (theSub, execPer, myDemTrips_);
d529 3
a531 3
   formDemTrips ();

   myPgg ()->consVolPgg ()->multiAppend (consPart, consPer, myDemTrips_);
a575 18
void WitGpipBldr::formDemTrips ()
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      pegVol;

   while (posDemPers_.pop (theDemand, shipPer))
      {
      pegVol = totPegVol_ (theDemand)[shipPer];

      totPegVol_ (theDemand)[shipPer] = 0.0;

      myDemTrips_.push (theDemand, shipPer, pegVol);
      }
   }

//------------------------------------------------------------------------------

@


1.7
log
@GPIP
@
text
@d41 1
a41 1
      WitProbAssoc       (thePgg->myProblem ()),
a42 1
      myPgg_             (thePgg),
a43 1
      myExecPerSched_    (NULL),
a48 1
      pggBuilt_          (false),
d57 1
a57 2
   myReqMgr_       = new WitGpipReqMgr   (myProblem ());
   myExecPerSched_ = new WitExecPerSched (myProblem ());
a66 1
   delete myExecPerSched_;
d72 1
a72 1
void WitGpipBldr::buildPegging ()
a73 2
   stronglyAssert (not pggBuilt_);

d80 1
a80 1
   myPgg_->consolidatePegging ();
a85 2

   pggBuilt_ = true;
d230 1
a230 1
   myPgg_->supplyVolPgg ()->multiAppend (thePart, fillPer, myDemTrips_);
d302 1
a302 1
   myExecPerSched_->
d351 1
a351 1
   myPgg_->
d405 1
a405 1
   myPgg_->execVolPgg ()->multiAppend (theOpn, execPer, myDemTrips_);
d485 1
a485 1
      myPgg_->subVolPgg ()->multiAppend (theSub, execPer, myDemTrips_);
d531 1
a531 1
   myPgg_->consVolPgg ()->multiAppend (consPart, consPer, myDemTrips_);
@


1.6
log
@GPIP
@
text
@d87 2
a93 2
   myPgg_->consolidatePegging ();

@


1.5
log
@GPIP
@
text
@d87 2
a88 1
   myPgg_->consolidatePegging ();
d92 2
a629 2
   myMsgFac () ("blankMsg");

@


1.4
log
@GPIP
@
text
@a101 4
   if (not myGlobalComp ()->feasible ())
      myMsgFac () ("gpipCaseNyiSmsg",
         "The solution is infeasible.");

@


1.3
log
@GPIP
@
text
@a25 2
#include <PairStack.h>
#include <TripStack.h>
d51 4
a54 1
      pggBuilt_          (false)
d89 2
a186 3
   WitGpipReqSrc * theReqSrc;
   double          incReqVol;

d207 1
a207 5
   myReqMgr_->advanceReqListItr (theReqSrc, incReqVol);

   witAssert (incReqVol <= 2 * FEAS_TOL);

   witAssert (myReqMgr_->finishedReqListItr ());
d227 3
a235 3

      if (myReqMgr_->finishedReqListItr ())
         break;
d269 3
a274 3

      if (myReqMgr_->finishedReqListItr ())
         break;
d347 3
a356 3

      if (myReqMgr_->finishedReqListItr ())
         break;
a480 3
      if (myReqMgr_->finishedReqListItr ())
         return;

d496 3
d604 39
@


1.2
log
@GPIP
@
text
@d49 4
a52 1
      prevPgdSched_      (myProblem (), false),
d57 1
a57 1
   witAssert (myGlobalComp ()->groupPipMode ());
d236 1
a236 7
      pegReqSrc (
         myPgg_->supplyVolPgg (),
         thePart,
         fillPer,
         incSuppVol,
         theReqSrc,
         prevPgdSched_);
d241 4
a339 2
   WitPart *       thePart;
   WitPeriod       prodPer;
a344 3
   thePart    = theBopEnt->myPart ();
   prodPer    = theBopEnt->impactPeriod ()[execPer];

d353 1
a353 7
      pegReqSrc (
         myPgg_->prodVolPgg (),
         thePart,
         prodPer,
         incProdVol,
         theReqSrc,
         prevPgdSched_);
d360 1
a360 1
         return;
d362 9
d414 1
a414 7
      pegReqSrc (
         myPgg_->execVolPgg (),
         theOpn,
         execPer,
         incExecVol,
         theReqSrc,
         prevPgdSched_);
d417 4
d438 2
d461 47
d513 2
d518 5
a522 1
   WitSubEntry *   theSub;
d529 1
a529 1
         return;
d533 4
a536 1
      theSub     = theConsEnt->thisSub ();
d538 1
a538 8
      if (theSub != NULL)
         pegReqSrc (
            myPgg_->subVolPgg (),
            theSub,
            execPer,
            incExecVol,
            theReqSrc,
            prevPgdSched_);
d540 1
a540 1
      explodeToConsumption (theConsEnt, execPer, incExecVol, theReqSrc);
d542 4
d550 1
a550 5
void WitGpipBldr::explodeToConsumption (
      WitConsEntry *  theConsEnt,
      WitPeriod       execPer,
      double          incExecVol,
      WitGpipReqSrc * theReqSrc)
d552 4
a555 3
   WitPart * consPart;
   WitPeriod consPer;
   double    incConsVol;
d557 30
a586 1
   consPart   = theConsEnt->myPart ();
d588 1
a588 1
   consPer    = theConsEnt->impactPeriod ()[execPer];
d590 5
a594 1
   incConsVol = incExecVol * theConsEnt->effConsRate ()[execPer];
d596 3
a598 2
   if (incConsVol <= NET_TOL)
      return;
d600 1
a600 7
   pegReqSrc (
      myPgg_->consVolPgg (),
      consPart,
      consPer,
      incConsVol,
      theReqSrc,
      prevPgdSched_);
d602 2
a603 1
   myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
a640 46

//------------------------------------------------------------------------------
// Implementation of NonClass function template pegReqSrc.
//------------------------------------------------------------------------------

template <typename SrcComp>
      void WitNonClass::pegReqSrc (
         WitPipAttPgg <SrcComp> *        theAttPgg,
         SrcComp *                       theSrcComp,
         WitPeriod                       pegPer,
         double                          pegVol,
         WitGpipReqSrc *                 theReqSrc,
         WitSchedule <WitDemand, bool> & prevPgd)
   {
   WitGpipSeqElItr theItr;
   WitGpipSeqEl *  theSeqEl;
   WitDemand *     theDemand;
   WitPeriod       shipPer;

   witAssert (pegVol > NET_TOL);

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         if (prevPgd (theDemand)[shipPer])
            continue;

         theAttPgg->append (theDemand, shipPer, theSrcComp, pegPer, pegVol);

         prevPgd (theDemand)[shipPer] = true;
         }

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         prevPgd (theDemand)[shipPer] = false;
         }
   }
@


1.1
log
@GPIP
@
text
@d48 3
a50 2
      nUnscannedBopEnts_ (),
      prevPgdSched_      (myProblem (), false)
d52 2
d55 6
d67 2
d75 2
a78 2
   setUpBuild ();

d83 1
a83 1
   shutDownBuild ();
d85 1
a85 1
   myPgg_->consolidatePegging ();
a113 26
void WitGpipBldr::setUpBuild ()
   {
   WitBopEntry * theBopEnt;

   myReqMgr_       = new WitGpipReqMgr   (myProblem ());
   myExecPerSched_ = new WitExecPerSched (myProblem ());

   nUnscannedBopEnts_.allocate (myProblem (), 0);

   forEachBopEntry (theBopEnt, myProblem ())
      nUnscannedBopEnts_ (theBopEnt->myOperation ()) ++;
   }

//------------------------------------------------------------------------------

void WitGpipBldr::shutDownBuild ()
   {
   delete myExecPerSched_;
   delete myReqMgr_;

   myExecPerSched_ = NULL;
   myReqMgr_       = NULL;
   }

//------------------------------------------------------------------------------

@


head	1.53;
access;
symbols
	EndRw-branch:1.52.0.4
	Root-of-EndRw:1.52
	rwToStl:1.52.0.2
	latest_sce_3_10_20010924:1.26.0.2
	sce_3_10_20010924:1.26
	latest_sce_3_00_20010601:1.7.0.2
	sce_3_00_20010601:1.7;
locks; strict;
comment	@ * @;


1.53
date	2003.03.03.23.27.03;	author rjw;	state dead;
branches;
next	1.52;

1.52
date	2002.09.26.19.05.30;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2002.09.11.18.53.15;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2002.07.02.21.53.04;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.02.19.20.58;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.28.19.40.15;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.18.17.54.45;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.17.22.08.18;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.17.17.29.26;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.24.23.00.06;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.21.19.10.26;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.16.23.32.08;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.04.18.14.02.42;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.04.15.21.21.37;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.04.12.21.02.02;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.04.11.15.36.29;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.29.23.47.10;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.22.21.23.22;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.20.22.51.19;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.19.16.20.57;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.15.23.17.30;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.15.05.48;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.13.19.27.20;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.07.23.24.29;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.10.22.06.55;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.19.16.17.12;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.17.18.56.29;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.30.20.29.24;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.28.20.30.27;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.24.22.03.22;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.23.21.13.54;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.22.20.41.53;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.17.22.00.11;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.12.19.58.26;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.28.17.35.20;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.27.21.45.12;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.20.20.07.05;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.18.18.42.23;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.15.20.53.37;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.14.17.41.54;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.13.20.30.24;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.11.19.29.12;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.08.22.34.47;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.08.18.00.28;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.01.19.23.35;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.29.22.11.28;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.25.22.59.14;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.25.14.53.26;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.17.15.11.16;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.10.22.31.14;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.30.21.29.42;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.26.21.25.45;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Removed all empty files from WIT (64 of them).
@
text
@@


1.52
log
@Began implementation of multi-level lot sizes.
@
text
@@


1.51
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a0 361
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "ProdMR.C"
//
// Contains the implementation of the following classes:
//
//    PmrMgr
//    MrMgr     <Pmr> [non-param]
//    MrSelSite <Pmr> [non-param]
//    MrCand    <Pmr> [non-param]
//    MrPt      <Pmr> [non-param]
//------------------------------------------------------------------------------

#include <PmrMgr.h>
#include <MultiRoute_TI.h>
#include <Selector.h>
#include <MsgFac.h>
#include <PtrMapI.h>

//------------------------------------------------------------------------------
// Implementation of class PmrMgr.
//------------------------------------------------------------------------------

WitPmrMgr::WitPmrMgr (WitSelector * theSelector):
      WitProbAssoc (theSelector),

      myMrMgr_     (NULL)
   {
   myMsgFac () ("multiRouteMsg");

   myMrMgr_ = new WitMrMgr <Pmr> (theSelector);
   }

//------------------------------------------------------------------------------

WitPmrMgr::~WitPmrMgr ()
   {
   delete myMrMgr_;
   }

//------------------------------------------------------------------------------

WitBopEntry * WitPmrMgr::selBopEntry (WitPart * thePart, WitPeriod expPer)
   {
   return myMrMgr_->selCandComp (thePart, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::modifyRouting (WitBopEntPerStack & theBopEntPers)
   {
   myMrMgr_->modifyRouting (theBopEntPers);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::findExpBopEnts (
      WitPart *        thePart, 
      WitPeriod        expPer,
      WitBopEntStack & theBopEnts)
   {
   myMrMgr_->findCandComps (thePart, expPer, theBopEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   return myMrMgr_->selIsSplit (thePart, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::startSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol)
   {
   myMrMgr_->startSplitExp (thePart, expPer, expVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::findNextSplit (
      WitBopEntry * & theBopEnt, 
      double &        splitExpVol)
   {
   return myMrMgr_->findNextSplit (theBopEnt, splitExpVol);
   }
 
//------------------------------------------------------------------------------

void WitPmrMgr::getCandBopEnts (WitPart * thePart, WitBopEntStack & theBopEnts)
   {
   myMrMgr_->getCandComps (thePart, theBopEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::valid (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   return myMrMgr_->valid (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::recPartExpPerSS (
      WitPart * thePart, 
      WitPeriod expPer, 
      double    expVol)
   {
   myMrMgr_->recordFlowSS (thePart, expPer, expVol);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::printHasAlt ()
   {
   WitPart * thePart;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Production Multi-Route Selection Points with Alternative(s):\n\n");

   forEachPart (thePart, myProblem ())
      myMrMgr_->myMrSelSiteFor (thePart)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

WitSelMgr * WitPmrMgr::mySelMgr ()
   {
   return myMrMgr_;
   }

//------------------------------------------------------------------------------

WitSelPt * WitPmrMgr::mySelPt (WitPart * thePart, WitPeriod thePer)
   {
   return myMrMgr_->myMrPt (thePart, thePer);

   return NULL;
   }

//------------------------------------------------------------------------------

void WitPmrMgr::select (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitMrPt <Pmr> * thePmrPt;

   thePmrPt = myMrMgr_->myMrPt (theBopEnt->myPart (), expPer);

   thePmrPt->select (theBopEnt);
   }

//------------------------------------------------------------------------------

WitBopEntry * WitPmrMgr::theBopEntFor (WitMrCand <Pmr> * thePmrCand)
   {
   return thePmrCand->myCandComp ();
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrMgr <Pmr>.
//------------------------------------------------------------------------------

WitMrMgr <Pmr>::~WitMrMgr ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      delete myMrSelSiteFor_ (thePart);
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrMgr <Pmr>::mySelPt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
   {
   WitPeriod expPer;

   expPer = theBopEnt->impactPeriod ()[execPer];

   return myMrPt (theBopEnt->myPart (), expPer);
   }

//------------------------------------------------------------------------------

WitBoolean WitMrMgr <Pmr>::validForNetting ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

WitBoolean WitMrMgr <Pmr>::validForExecBounds ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

const char * WitMrMgr <Pmr>::selCaseName ()
   {
   return "Production Multi-Route";
   }

//------------------------------------------------------------------------------

void WitMrMgr <Pmr>::buildMrSelSites ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      myMrSelSiteFor_ (thePart) = 
         new WitMrSelSite <Pmr> (thePart, this);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrSelSite <Pmr>.
//------------------------------------------------------------------------------

WitBopEntry * WitMrSelSite <Pmr>::defaultCandComp (WitPeriod expPer)
   {
   return
      thePartFor (this)->explodeable (expPer)?
         thePartFor (this)->expBopEntry (expPer):
         NULL;
   }

//------------------------------------------------------------------------------

void WitMrSelSite <Pmr>::buildMrCands ()
   {
   WitBopEntry * theBopEnt;

   if (thePartFor (this)->producingBopEntries ().isEmpty ())
      return;

   forEachEl (theBopEnt, thePartFor (this)->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         myMrCands_.push (new WitMrCand <Pmr> (theBopEnt, this));

   myMrCands_.reverse ();

   multiChoice_ = (myMrCands_.nElements () > 1);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrCand <Pmr>.
//------------------------------------------------------------------------------

void WitMrCand <Pmr>::prtID ()
   {
   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEntFor (this)->myOperationName ().myCstring (),
      theBopEntFor (this)->localIndex ());
   }

//------------------------------------------------------------------------------

WitMrCand <Pmr> * WitMrCand <Pmr>::myPmrCand ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitMrCand <Cmr> * WitMrCand <Pmr>::myCmrCand ()
   {
   stronglyAssert (witFALSE);

   return NULL;
   }

//------------------------------------------------------------------------------

WitBoolean WitMrCand <Pmr>::isEligible (WitPeriod expPer)
   {
   return theBopEntFor (this)->expEligible (expPer);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrPt <Pmr>.
//------------------------------------------------------------------------------

void WitMrPt <Pmr>::printID ()
   {
   fprintf (msgFile (), 
      "   Part %s, Exp Per %d\n", 
      thePartFor (myMrSelSite_)->partName ().myCstring (),
      myPer_);
   }

//------------------------------------------------------------------------------

void WitMrPt <Pmr>::printSelection ()
   {
   fprintf (msgFile (), "\n");

   printID ();

   fprintf (msgFile (), "   Selected BopEntry: ");

   if (selMrCand () == NULL)
      fprintf (msgFile (), "None\n");
   else
      fprintf (msgFile (),
         "%s #%d\n",
         theBopEntFor (selMrCand ())->myOperationName ().myCstring (),
         theBopEntFor (selMrCand ())->localIndex ());
   }

//------------------------------------------------------------------------------

void WitMrPt <Pmr>::prtID ()
   {
   fprintf (msgFile (),
      "   Part:        %s\n"
      "   Exp Per:     %d\n",
      thePartFor (myMrSelSite_)->partName ().myCstring (),
      myPer_);
   }

//------------------------------------------------------------------------------

void WitMrPt <Pmr>::getSortData (WitPart * & thePart, WitPeriod & thePer)
   {
   thePart = thePartFor (myMrSelSite_);
   thePer  = myPer_;
   }

//------------------------------------------------------------------------------

WitPart * WitMrPt <Pmr>::myPmrPart ()
   {
   return thePartFor (myMrSelSite_);
   }

//------------------------------------------------------------------------------

WitBomEntry * WitMrPt <Pmr>::myCmrBomEnt ()
   {
   return NULL;
   }
@


1.50
log
@Continued implementation of Single-Source.
@
text
@d26 1
@


1.49
log
@Continued implementation of Single-Source.
@
text
@d100 14
a163 35
   }

//------------------------------------------------------------------------------

void WitPmrMgr::getCandBopEnts (WitPart * thePart, WitBopEntStack & theBopEnts)
   {
   WitObjStItr <WitMrCand <Pmr> > theItr;
   WitMrCand <Pmr> *              thePmrCand;

   theBopEnts.clear ();

   theItr.attachTo (myMrMgr_->myMrSelSiteFor (thePart)->myMrCands ());

   while (theItr.advance (thePmrCand))
      theBopEnts.push (theBopEntFor (thePmrCand));

   theBopEnts.reverse ();
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::valid (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitMrSelSite <Pmr> * thePmrSelSite;
   WitMrCand    <Pmr> * thePmrCand;

   thePmrSelSite = myMrMgr_->myMrSelSiteFor (theBopEnt->myPart ());

   thePmrCand    = thePmrSelSite->myMrCandFor (theBopEnt);

   if (thePmrCand->isEligible (expPer))
      if (! thePmrCand->prevSel (expPer))
         return witTRUE;

   return witFALSE;
@


1.48
log
@Continued implementation of Single-Source.
@
text
@d171 1
a171 1
WitBoolean WitPmrMgr::valid (WitBopEntry * theBopEnt, WitPeriod thePer)
d180 2
a181 2
   if (thePmrCand->isEligible (thePer))
      if (! thePmrCand->prevSel (thePer))
d374 7
@


1.47
log
@Continued implementation of Single-Source.
@
text
@d154 1
a154 3
void WitPmrMgr::getCandBopEnts (
      WitPart *        thePart,
      WitBopEntStack & theBopEntStack)
d159 1
a159 1
   theBopEntStack.clear ();
d164 1
a164 1
      theBopEntStack.push (theBopEntFor (thePmrCand));
d166 1
a166 1
   theBopEntStack.reverse ();
@


1.46
log
@Continued implementation of Single-Source.
@
text
@d154 3
a156 4
WitBopEntry * WitPmrMgr::nextBopEnt (
      WitPart *                    thePart,
      WitBopEntry *                theBopEnt,
      const WitTVec <WitBoolean> & activeVec)
d158 11
a168 2
   return
      myMrMgr_->myMrSelSiteFor (thePart)->nextCandComp (theBopEnt, activeVec);
@


1.45
log
@Continued implementation of Single-Source.
@
text
@d165 18
@


1.44
log
@Continued implementation of Single-Source.
@
text
@d15 1
a15 1
//    PmrMgr 
d154 4
a157 3
WitBopEntry * WitPmrMgr::nextAllPerBopEnt (
      WitPart *     thePart,
      WitBopEntry * theBopEnt)
d159 2
a160 3
   return myMrMgr_->myMrSelSiteFor (thePart)->nextAllPerCandComp (theBopEnt);

   return NULL;
@


1.43
log
@Continued implementation of single-source.
@
text
@d154 11
@


1.42
log
@Continued implementation of single-source.
@
text
@d136 1
a136 1
   WitBoolean resFound;
d138 10
a147 1
   return myMrMgr_->mySelPt (thePart, thePer, resFound);
d149 1
a149 1
   return NULL;
d177 1
a177 2
      WitPeriod,
      WitBoolean &  resFound)
d183 1
a183 1
   return mySelPt (theBopEnt->myPart (), expPer, resFound);
d336 1
a336 1
WitBoolean WitMrPt <Pmr>::sglSrcMode ()
d338 1
a338 5
   witAssert (mySelMgr ()->mySelector ()->singleSource ());

   return 
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->
         sglSrcMode (thePartFor (myMrSelSite_));
a339 1

@


1.41
log
@Continued implementation of single source.
@
text
@d326 11
@


1.40
log
@Began implementation of object iteration.
@
text
@d233 1
a233 1
         myMrCands_.push (new WitMrCand <Pmr> (theBopEnt));
@


1.39
log
@Continued implementation of sel-split for pen-exec.
@
text
@d25 1
@


1.38
log
@Continued implementation of sel-split for pen-exec.
@
text
@d319 1
a319 4
void WitMrPt <Pmr>::getSortData (
      WitPart * & thePart,
      int &       caseIdx,
      WitPeriod & thePer)
a321 1
   caseIdx = 2;
@


1.37
log
@Continued implementation of sel-split for pen-exec.
@
text
@d24 1
d104 1
a104 1
   myMrMgr_->recordFlow (thePart, expPer, expVol);
a314 7
   }

//------------------------------------------------------------------------------

WitPart * WitMrPt <Pmr>::myFillPart ()
   {
   return thePartFor (myMrSelSite_);
@


1.36
log
@Continued implementation of sel-split for pen-exec.
@
text
@d325 4
a328 1
WitPart * WitMrPt <Pmr>::mySortPart ()
d330 3
a332 1
   return thePartFor (myMrSelSite_);
a334 6
//------------------------------------------------------------------------------

int WitMrPt <Pmr>::caseIndex ()
   {
   return 2;
   }
@


1.35
log
@Continued implementation of sel-split for pen-exec.
@
text
@d262 1
a262 1
   myMsgFac () ("internalErrorFmsg", "WitMrCand <Pmr>::myCmrCand");
@


1.34
log
@Continued implementation of sel-split for pen-exec.
@
text
@d178 7
@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@d318 1
a318 1
WitPart * WitMrPt <Pmr>::sortPart ()
@


1.32
log
@Continued implementation of sel-split for pen-exec.
@
text
@d318 1
a318 1
int WitMrPt <Pmr>::sspeIndex ()
d320 8
a327 1
   return thePartFor (myMrSelSite_)->sortedPartIndex () * 10;
@


1.31
log
@Continued implementation of sel-split for pen-exec.
@
text
@d320 1
a320 1
   return thePartFor (myMrSelSite_)->sortedPartIndex ();
@


1.30
log
@Continued implementation of sel-split for pen-exec.
@
text
@a97 10
void WitPmrMgr::setPrevSel (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer,
      WitBoolean    theVal)
   {
   myMrMgr_->setPrevSel (theBopEnt, expPer, theVal);
   }

//------------------------------------------------------------------------------

a142 20
WitBoolean WitPmrMgr::getPmrCoords (
      WitSelPt *  theSelPt, 
      WitPart * & thePart, 
      WitPeriod & expPer)
   {
   WitMrPt <Pmr> * thePmrPt;

   thePmrPt = theSelPt->myPmrPtIfAny ();

   if (thePmrPt == NULL)
      return witFALSE;

   thePart = thePmrPt->myMrSelSite ()->mySelComp ();
   expPer  = thePmrPt->myPer ();

   return witTRUE;
   }

//------------------------------------------------------------------------------

a320 14
   }

//------------------------------------------------------------------------------

WitMrPt <Pmr> * WitMrPt <Pmr>::myPmrPtIfAny ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitMrPt <Cmr> * WitMrPt <Pmr>::myCmrPtIfAny ()
   {
   return NULL;
@


1.29
log
@Continued implementation of sel-split fpr pen-exec.
@
text
@d158 1
a158 1
   WitMrPt <Pmr> * theMrPtPmr;
d160 1
a160 1
   theMrPtPmr = theSelPt->myMrPtPmrIfAny ();
d162 1
a162 1
   if (theMrPtPmr == NULL)
d165 2
a166 2
   thePart = theMrPtPmr->myMrSelSite ()->mySelComp ();
   expPer  = theMrPtPmr->myPer ();
d276 1
a276 1
WitMrCand <Pmr> * WitMrCand <Pmr>::myMrCandPmr ()
d283 1
a283 1
WitMrCand <Cmr> * WitMrCand <Pmr>::myMrCandCmr ()
d285 1
a285 1
   myMsgFac () ("internalErrorFmsg", "WitMrCand <Pmr>::myMrCandCmr");
d346 6
d355 1
a355 1
WitMrPt <Pmr> * WitMrPt <Pmr>::myMrPtPmrIfAny ()
d358 7
@


1.28
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d98 10
d152 27
d346 7
@


1.27
log
@Initial implementation of selection splitting for multi-route.
@
text
@d131 11
d166 1
a166 1
   return mySelPt (theBopEnt, expPer, resFound);
@


1.26
log
@Continued implmentation of selective stock reallocation.
@
text
@d98 4
a101 4
void WitPmrMgr::recBopEntExpPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double        expVol)
d103 1
@


1.25
log
@Refactoring for constrained stock reallocation.
@
text
@d227 1
a227 1
WitBoolean WitMrCand <Pmr>::isaPmrCand ()
d229 1
a229 1
   return witTRUE;
d234 1
a234 1
WitBoolean WitMrCand <Pmr>::isaCmrCand ()
d236 3
a238 1
   return witFALSE;
@


1.24
log
@Refactoring for constrained stock reallocation.
@
text
@d19 1
a19 1
//    MrSelPt   <Pmr> [non-param]
d247 1
a247 1
// Non-parametric implementation of template class MrSelPt <Pmr>.
d250 1
a250 1
void WitMrSelPt <Pmr>::printID ()
d260 1
a260 1
void WitMrSelPt <Pmr>::printSelection ()
d279 1
a279 1
void WitMrSelPt <Pmr>::prtID ()
d290 1
a290 1
WitPart * WitMrSelPt <Pmr>::myFillPart ()
@


1.23
log
@Refactoring for constrained stock reallocation.
@
text
@d30 3
a32 1
      WitMrMgr <Pmr> (theSelector)
d35 2
d43 1
d50 1
a50 1
   return selCandComp (thePart, expPer);
d57 1
a57 1
   WitMrMgr <Pmr>::modifyRouting (theBopEntPers);
d67 1
a67 1
   findCandComps (thePart, expPer, theBopEnts);
d74 1
a74 1
   return WitMrMgr <Pmr>::selIsSplit (thePart, expPer);
d84 1
a84 1
   WitMrMgr <Pmr>::startSplitExp (thePart, expPer, expVol);
d93 1
a93 1
   return WitMrMgr <Pmr>::findNextSplit (theBopEnt, splitExpVol);
d117 1
a117 1
      myMrSelSiteFor (thePart)->printHasAlt ();
d120 7
@


1.22
log
@Refactoring for constrained stock reallocation.
@
text
@d30 1
a30 3
      WitMrMgr <Pmr> (theSelector),

      totExpVol_         (myProblem ())
a97 3
   if (selSplit ())
      if (myMrSelSiteFor (theBopEnt->myPart ())->multiChoice ())
         totExpVol_.incCell (theBopEnt, expPer, expVol);
a114 39
   }

//------------------------------------------------------------------------------

void WitPmrMgr::setUpDerivedSS ()
   {
   WitPart *     thePart;
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   totExpVol_.allocate1D ();

   forEachPart (thePart, myProblem ())
      if (myMrSelSiteFor (thePart)->multiChoice ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expAllowed ())
               totExpVol_.allocateRow (theBopEnt);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExpVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitPmrMgr::adjustSplitBound (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double &      splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExpVol_ (theBopEnt, expPer);
@


1.21
log
@Refactoring for constrained stock reallocation.
@
text
@d191 1
a191 1
void WitMrMgr <Pmr>::prtSelCandID (WitTlObj * theTlObj)
d193 2
a194 1
   WitBopEntry * theBopEnt;
d196 1
a196 1
   theBopEnt = (WitBopEntry *) theTlObj;
d198 3
a200 5
   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
d221 2
a222 2
      mySelComp_->explodeable (expPer)?
         mySelComp_->expBopEntry (expPer):
d232 1
a232 1
   if (mySelComp_->producingBopEntries ().isEmpty ())
d235 1
a235 1
   forEachEl (theBopEnt, mySelComp_->producingBopEntries ())
d248 25
d275 1
a275 1
   return myCandComp_->expEligible (expPer);
d286 1
a286 1
      myMrSelSite_->mySelComp ()->partName ().myCstring (),
a293 2
   WitBopEntry * theBopEnt;

a302 3
      {
      theBopEnt = selMrCand ()->myCandComp ();

d305 2
a306 3
         theBopEnt->myOperationName ().myCstring (),
         theBopEnt->localIndex ());
      }
d316 1
a316 1
      myMrSelSite_->mySelComp ()->partName ().myCstring (),
d324 1
a324 1
   return myMrSelSite_->mySelComp ();
@


1.20
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d16 4
a19 4
//    MrMgr     <PmrArgs> [non-param]
//    MrSelSite <PmrArgs> [non-param]
//    MrCand    <PmrArgs> [non-param]
//    MrSelPt   <PmrArgs> [non-param]
d23 1
a23 1
#include <MrMgr_TI.h>
d30 1
a30 1
      WitMrMgr <PmrArgs> (theSelector),
d54 1
a54 1
   WitMrMgr <PmrArgs>::modifyRouting (theBopEntPers);
d71 1
a71 1
   return WitMrMgr <PmrArgs>::selIsSplit (thePart, expPer);
d81 1
a81 1
   WitMrMgr <PmrArgs>::startSplitExp (thePart, expPer, expVol);
d90 1
a90 1
   return WitMrMgr <PmrArgs>::findNextSplit (theBopEnt, splitExpVol);
d162 1
a162 1
// Non-parametric implementation of template class MrMgr <PmrArgs>.
d165 1
a165 1
WitMrMgr <PmrArgs>::~WitMrMgr ()
d175 1
a175 1
WitSelPt * WitMrMgr <PmrArgs>::mySelPt (
d191 1
a191 15
WitBoolean WitMrMgr <PmrArgs>::validForExecBounds ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

const char * WitMrMgr <PmrArgs>::selCaseName ()
   {
   return "Production Multi-Route";
   }

//------------------------------------------------------------------------------

void WitMrMgr <PmrArgs>::prtSelCandID (WitTlObj * theTlObj)
d206 1
a206 1
void WitMrMgr <PmrArgs>::buildMrSelSites ()
d212 1
a212 1
         new WitMrSelSite <PmrArgs> (thePart, this);
d216 1
a216 1
// Non-parametric implementation of template class MrSelSite <PmrArgs>.
d219 1
a219 1
WitBopEntry * WitMrSelSite <PmrArgs>::defaultCandComp (WitPeriod expPer)
d229 1
a229 1
void WitMrSelSite <PmrArgs>::buildMrCands ()
d238 1
a238 1
         myMrCands_.push (new WitMrCand <PmrArgs> (theBopEnt));
d246 1
a246 1
// Non-parametric implementation of template class MrCand <PmrArgs>.
d249 1
a249 1
WitBoolean WitMrCand <PmrArgs>::isEligible (WitPeriod expPer)
d255 1
a255 1
// Non-parametric implementation of template class MrSelPt <PmrArgs>.
d258 1
a258 1
void WitMrSelPt <PmrArgs>::printID ()
d268 1
a268 1
void WitMrSelPt <PmrArgs>::printSelection ()
d278 1
a278 1
   if (selMrCand_ == NULL)
d282 1
a282 1
      theBopEnt = selMrCand_->myCandComp ();
d293 1
a293 1
void WitMrSelPt <PmrArgs>::prtID ()
d304 1
a304 1
WitPart * WitMrSelPt <PmrArgs>::myFillPart ()
@


1.19
log
@Refactoring.
@
text
@d315 8
@


1.18
log
@Replaced non-template based production multi-route with template based
production multi-route.
@
text
@d1 314
@


1.17
log
@Initial implementation of multi-route class templates.
@
text
@a0 634
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "ProdMR.C"
//
// Contains the implementation of the following classes:
//
//    PmrMgr.
//    PmrPart.
//    PmrCand.
//    PmrSelPt.
//------------------------------------------------------------------------------

#include <PmrMgr.h>
#include <PmrPart.h>
#include <PmrCand.h>

//------------------------------------------------------------------------------
// Implementation of class PmrMgr.
//------------------------------------------------------------------------------

WitPmrMgr::WitPmrMgr (WitSelector * theSelector):
      WitSelMgr    (theSelector),

      myPmrPartTl_ (),
      totExpVol_   (myProblem ())
   {
   WitPart * thePart;

   myPmrPartTl_.allocate (myProblem (), NULL);

   forEachPart (thePart, myProblem ())
      myPmrPart (thePart) = new WitPmrPart (thePart, this);
   }

//------------------------------------------------------------------------------

WitPmrMgr::~WitPmrMgr ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      delete myPmrPart (thePart);
   }

//------------------------------------------------------------------------------

WitBopEntry * WitPmrMgr::selBopEntry (WitPart * thePart, WitPeriod expPer)
   {
   return myPmrPart (thePart)->selBopEntry (expPer);
   }

//------------------------------------------------------------------------------

WitSelPt * WitPmrMgr::mySelPt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod,
      WitBoolean &  resFound)
   {
   WitPeriod     expPer;
   WitPmrSelPt * thePmrSelPt;

   expPer      = theBopEnt->impactPeriod ()[execPer];

   thePmrSelPt = myPmrPart (theBopEnt->myPart ())->myPmrSelPtWithAlt (expPer);

   resFound    =
      (thePmrSelPt != NULL)?
         thePmrSelPt->hasResAlt ():
         witFALSE;

   return thePmrSelPt;
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::validForExecBounds ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

const char * WitPmrMgr::selCaseName ()
   {
   return "Production Multi-Route";
   }

//------------------------------------------------------------------------------

void WitPmrMgr::prtSelCandID (WitTlObj * theTlObj)
   {
   WitBopEntry * theBopEnt;

   theBopEnt = (WitBopEntry *) theTlObj;

   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
   }

//------------------------------------------------------------------------------

void WitPmrMgr::printHasAlt ()
   {
   WitPart * thePart;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Production Multi-Route Selection Points with Alternative(s):\n\n");

   forEachPart (thePart, myProblem ())
      myPmrPart (thePart)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitPmrMgr::modifyRouting (WitBopEntPerStack & theBopEntPers)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitPmrPart *  thePmrPart;

   while (theBopEntPers.pop (theBopEnt, expPer))
      {
      thePmrPart = myPmrPart (theBopEnt->myPart ());

      thePmrPart->myPmrSelPt ()[expPer]->select (theBopEnt);
      }
   }

//------------------------------------------------------------------------------

void WitPmrMgr::findExpBopEnts (
      WitPart *        thePart, 
      WitPeriod        expPer,
      WitBopEntStack & theBopEnts)
   {
   myPmrPart (thePart)->findExpBopEnts (expPer, theBopEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::selSplitNeeded ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   WitPmrPart * thePmrPart;

   if (! selSplit ())
      return witFALSE;

   thePmrPart = myPmrPart (thePart);
      
   if (! thePmrPart->multiChoice ())
      return witFALSE;

   return thePmrPart->myPmrSelPt ()[expPer]->isSplit ();
   }

//------------------------------------------------------------------------------

void WitPmrMgr::startSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol)
   {
   WitPmrSelPt * thePmrSelPt;

   witAssert (selIsSplit (thePart, expPer));

   thePmrSelPt = myPmrPart (thePart)->myPmrSelPt ()[expPer];

   startSplitExpAbs (thePmrSelPt, expVol);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::adjustSplitBound (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double &      splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExpVol_ (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::recBopEntExpPerSS (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol)
   {
   if (selSplit ())
      if (myPmrPart (theBopEnt->myPart ())->multiChoice ())
         totExpVol_.incCell (theBopEnt, expPer, expVol);
   }

//------------------------------------------------------------------------------

void WitPmrMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExpVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitPmrMgr::postSplitCommit ()
   {
   }

//------------------------------------------------------------------------------

void WitPmrMgr::setUpDerivedSS ()
   {
   WitPart *     thePart;
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   totExpVol_.allocate1D ();

   forEachPart (thePart, myProblem ())
      if (myPmrPart (thePart)->multiChoice ())
         forEachEl (theBopEnt, thePart->producingBopEntries ())
            if (theBopEnt->expAllowed ())
               totExpVol_.allocateRow (theBopEnt);
   }

//------------------------------------------------------------------------------
// Implementation of class PmrPart.
//------------------------------------------------------------------------------

WitPmrPart::WitPmrPart (WitPart * thePart, WitPmrMgr * thePmrMgr):
      WitProbAssoc (thePmrMgr),

      myPmrMgr_    (thePmrMgr),
      myPart_      (thePart),
      myPmrCands_  (myProblem ()),
      multiChoice_ (witFALSE),
      myPmrSelPt_  ()
   {
   if (! myGlobalComp ()->multiRoute ())
      return;

   buildPmrCands ();

   buildPmrSelPts ();
   }

//------------------------------------------------------------------------------

WitPmrPart::~WitPmrPart ()
   {
   WitPeriod    expPer;
   WitPmrCand * thePmrCand;

   if (multiChoice_)
      forEachPeriod (expPer, myProblem ())
         delete myPmrSelPt_[expPer];

   while (myPmrCands_.pop (thePmrCand))
      delete thePmrCand;
   }

//------------------------------------------------------------------------------

void WitPmrPart::printHasAlt ()
   {
   WitPeriod     expPer;
   WitPmrSelPt * thePmrSelPt;

   if (! multiChoice_)
      return;

   forEachPeriod (expPer, myProblem ())
      {
      thePmrSelPt = myPmrSelPt_[expPer];

      if (thePmrSelPt != NULL)
         if (thePmrSelPt->selPmrCand () != NULL)
            thePmrSelPt->printID ();
      }
   }

//------------------------------------------------------------------------------

void WitPmrPart::findExpBopEnts (WitPeriod expPer, WitBopEntStack & theBopEnts)
   {
   WitPmrCandItr thePmrCandItr;
   WitPmrCand *  thePmrCand;

   theBopEnts.clear ();

   if (multiChoice ())
      {
      thePmrCandItr.attachTo (myPmrCands_);

      while (thePmrCandItr.advance (thePmrCand))
         if (thePmrCand->isEligible (expPer))
            if (! thePmrCand->prevSel ()[expPer])
               theBopEnts.push (thePmrCand->myBopEnt ());

      theBopEnts.reverse ();
      }

   if (theBopEnts.isEmpty ())
      if (myPart_->explodeable (expPer))
         theBopEnts.push (myPart_->expBopEntry (expPer));
   }

//------------------------------------------------------------------------------

WitPmrCand * WitPmrPart::myPmrCandFor (WitBopEntry * theBopEnt)
   {
   WitPmrCandItr thePmrCandItr;
   WitPmrCand *  thePmrCand;

   thePmrCandItr.attachTo (myPmrCands_);

   while (thePmrCandItr.advance (thePmrCand))
      if (thePmrCand->myBopEnt () == theBopEnt)
         return thePmrCand;

   myMsgFac () ("internalErrorFmsg", "WitPmrPart::myPmrCand");

   return NULL;
   }

//------------------------------------------------------------------------------

WitBopEntry * WitPmrPart::selBopEntry (WitPeriod expPer)
   {
   WitPmrCand * thePmrCand;

   witAssert (myPart_->explodeable (expPer));

   if (multiChoice_)
      {
      thePmrCand = myPmrSelPt_[expPer]->selPmrCand ();

      if (thePmrCand != NULL)
         return thePmrCand->myBopEnt ();
      }

   return myPart_->expBopEntry (expPer);
   }

//------------------------------------------------------------------------------

void WitPmrPart::buildPmrSelPts ()
   {
   WitPeriod expPer;

   if (! multiChoice_)
      return;

   myPmrSelPt_.allocate (myProblem ());

   forEachPeriod (expPer, myProblem ())
      if (myPart_->explodeable (expPer))
         myPmrSelPt_[expPer] = new WitPmrSelPt (this, expPer);
   }

//------------------------------------------------------------------------------

WitPmrSelPt * WitPmrPart::multiChoicePmrSelPtWithAlt (WitPeriod expPer)
   {
   WitPmrSelPt * thePmrSelPt;

   witAssert (multiChoice_);

   thePmrSelPt = myPmrSelPt_[expPer];

   witAssert (thePmrSelPt != NULL);

   return
      (thePmrSelPt->selPmrCand () != NULL)?
         thePmrSelPt:
         NULL;
   }

//------------------------------------------------------------------------------

void WitPmrPart::buildPmrCands ()
   {
   WitBopEntry * theBopEnt;

   if (myPart_->producingBopEntries ().isEmpty ())
      return;

   forEachEl (theBopEnt, myPart_->producingBopEntries ())
      if (theBopEnt->expAllowed ())
         myPmrCands_.push (new WitPmrCand (theBopEnt));

   myPmrCands_.reverse ();

   multiChoice_ = (myPmrCands_.nElements () > 1);
   }

//------------------------------------------------------------------------------

void WitPmrPart::addPrereq (
      WitObjStack <WitPart> & prereqs, 
      WitBopEntry *           theBopEnt)
   {
   prereqs.push (theBopEnt->myOperation ()->bom ().first ()->myPart ());
   }

//------------------------------------------------------------------------------
// Implementation of class PmrCand.
//------------------------------------------------------------------------------

WitPmrCand::WitPmrCand (WitBopEntry * theBopEnt):

      WitSelCand (theBopEnt),

      myBopEnt_  (theBopEnt),
      prevSel_   (myProblem (), witFALSE)
   {
   }

//------------------------------------------------------------------------------

WitPmrCand::~WitPmrCand ()
   {
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrCand::isEligible (WitPeriod expPer)
   {
   return myBopEnt_->expEligible (expPer);
   }

//------------------------------------------------------------------------------

void WitPmrCand::setPrevSel (WitPeriod expPer)
   {
   prevSel_.elemRef (expPer) = witTRUE;
   }

//------------------------------------------------------------------------------
// Implementation of class PmrSelPt.
//------------------------------------------------------------------------------

WitPmrSelPt::WitPmrSelPt (WitPmrPart * thePmrPart, WitPeriod expPer):

      WitSelPt    (),

      myPmrPart_  (thePmrPart),
      myExpPer_   (expPer),
      selPmrCand_ (NULL),
      hasResAlt_  (witFALSE)
   {
   WitBopEntry * theBopEnt;
   WitPmrCandItr thePmrCandItr;
   WitPmrCand *  thePmrCand;

   witAssert (myPmrPart_->myPart ()->explodeable (myExpPer_));

   theBopEnt   = myPmrPart_->myPart ()->expBopEntry (myExpPer_);

   selPmrCand_ = myPmrPart_->myPmrCandFor (theBopEnt);

   thePmrCandItr.attachTo (myPmrPart_->myPmrCands ());

   while (thePmrCandItr.advance (thePmrCand))
      if (thePmrCand->isEligible (myExpPer_))
         if (thePmrCand != selPmrCand_)
            {
            hasResAlt_ = witTRUE;

            break;
            }
   }

//------------------------------------------------------------------------------

WitPmrSelPt::~WitPmrSelPt ()
   {
   }

//------------------------------------------------------------------------------

WitTlObj * WitPmrSelPt::selectedObj ()
   {
   WitBopEntry * theBopEnt;

   witAssert (selPmrCand_ != NULL);

   theBopEnt = selPmrCand_->myBopEnt ();

   return (WitTlObj *) theBopEnt;
   }

//------------------------------------------------------------------------------

void WitPmrSelPt::alterSelection ()
   {
   WitPmrCandItr thePmrCandItr;
   WitPmrCand *  thePmrCand;

   witAssert (selPmrCand_ != NULL);

   selPmrCand_->setPrevSel (myExpPer_);

   selPmrCand_ = NULL;
   hasResAlt_  = witFALSE;

   thePmrCandItr.attachTo (myPmrPart_->myPmrCands ());

   while (thePmrCandItr.advance (thePmrCand))
      if (thePmrCand->isEligible (myExpPer_))
         if (! thePmrCand->prevSel ()[myExpPer_])
            if (selPmrCand_ == NULL)
               selPmrCand_ = thePmrCand;
            else
               {
               hasResAlt_ = witTRUE;

               return;
               }
   }

//------------------------------------------------------------------------------

void WitPmrSelPt::printSelection ()
   {
   fprintf (msgFile (), "\n");

   printID ();

   fprintf (msgFile (), "   Selected BopEntry: ");

   if (selPmrCand_ == NULL)
      fprintf (msgFile (), "None\n");
   else
      fprintf (msgFile (),
         "%s #%d\n",
         selPmrCand_->myBopEnt ()->myOperationName ().myCstring (),
         selPmrCand_->myBopEnt ()->localIndex ());
   }

//------------------------------------------------------------------------------

WitSelMgr * WitPmrSelPt::mySelMgr ()
   {
   return myPmrPart_->myPmrMgr ();
   }

//------------------------------------------------------------------------------

void WitPmrSelPt::prtID ()
   {
   fprintf (msgFile (),
      "   Part:        %s\n"
      "   Exp Per:     %d\n",
      myPmrPart_->myPart ()->partName ().myCstring (),
      myExpPer_);
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrSelPt::splittable ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitPmrSelPt::adjustSplitBound (WitTlObj * theTlObj, double & splitBound)
   {
   WitBopEntry * theBopEnt;

   theBopEnt = (WitBopEntry *) theTlObj;

   myPmrPart_->myPmrMgr ()->adjustSplitBound (theBopEnt, myExpPer_, splitBound);
   }

//------------------------------------------------------------------------------

void WitPmrSelPt::printID ()
   {
   fprintf (msgFile (), 
      "   Part %s, Exp Per %d\n", 
      myPmrPart_->myPart ()->partName ().myCstring (),
      myExpPer_);
   }

//------------------------------------------------------------------------------

void WitPmrSelPt::select (WitBopEntry * theBopEnt)
   {
   WitPmrCand * thePmrCand;

   thePmrCand = myPmrPart_->myPmrCandFor (theBopEnt);

   witAssert (thePmrCand != selPmrCand_);

   witAssert (! thePmrCand->prevSel ()[myExpPer_]);

   selPmrCand_ = thePmrCand;
   }

//------------------------------------------------------------------------------

FILE * WitPmrSelPt::msgFile ()
   {
   return myPmrPart_->msgFile ();
   }
@


1.16
log
@Converted several generic classes into class templates.
@
text
@d417 1
a417 1
         myPmrCands_.push (new WitPmrCand (theBopEnt, this));
d437 1
a437 1
WitPmrCand::WitPmrCand (WitBopEntry * theBopEnt, WitPmrPart * thePmrPart):
d439 1
a439 1
      WitSelCand (thePmrPart),
a441 1
      myPmrPart_ (thePmrPart),
@


1.15
log
@Replaced use of CandIndex with CmrCand in Consumption Multi-Route subsystem.
@
text
@d427 1
a427 1
      WitObjStack (WitPart) & prereqs, 
@


1.14
log
@Removed indexes from production multi-route.
Other refactoring.
@
text
@a319 2
      witAssert (myPmrSelPt_[expPer] != NULL);

d323 1
a323 1
         if (thePmrCand->eligible (expPer))
d337 1
a337 1
WitPmrCand * WitPmrPart::myPmrCand (WitBopEntry * theBopEnt)
d410 1
a410 2
   WitBopEntry *  theBopEnt;
   int            nCands;
a414 2
   nCands = 0;

a416 1
         {
a418 3
         nCands ++;
         }

d421 1
a421 1
   multiChoice_ = (nCands > 1);
d455 1
a455 1
WitBoolean WitPmrCand::eligible (WitPeriod expPer)
d488 1
a488 1
   selPmrCand_ = myPmrPart_->myPmrCand (theBopEnt);
d493 1
a493 1
      if (thePmrCand->eligible (myExpPer_))
d538 1
a538 1
      if (thePmrCand->eligible (myExpPer_))
d621 1
a621 1
   thePmrCand = myPmrPart_->myPmrCand (theBopEnt);
@


1.13
log
@Created class SelCand and classes derived from it.
@
text
@d17 1
a18 1
//    PmrCand.
d136 1
d139 5
a143 1
      myPmrPart (theBopEnt->myPart ())->select (theBopEnt, expPer);
d262 1
a262 1
      candBopEnt_  (),
d269 1
a269 3
   initCandidate ();

   multiChoice_ = (nCandidates () > 1);
d278 2
a279 1
   WitPeriod expPer;
d284 3
d304 1
a304 1
         if (thePmrSelPt->selIndex () >= 0)
a310 21
WitBoolean WitPmrPart::candIsDefault (WitCandIndex theIdx, WitPeriod expPer)
   {
   return (candBopEnt_[theIdx] == myPart_->expBopEntry (expPer));
   }

//------------------------------------------------------------------------------

WitCandIndex WitPmrPart::nCandidates ()
   {
   return candBopEnt_.length ();
   }

//------------------------------------------------------------------------------

WitBoolean WitPmrPart::candIsEligible (WitCandIndex theIdx, WitPeriod expPer)
   {
   return candBopEnt_[theIdx]->expEligible (expPer);
   }

//------------------------------------------------------------------------------

d313 2
a314 2
   WitCandIndex  theIdx;
   WitPmrSelPt * thePmrSelPt;
d320 3
a322 1
      thePmrSelPt = myPmrSelPt_[expPer];
d324 4
a327 1
      witAssert (thePmrSelPt != NULL);
d329 1
a329 4
      for (theIdx = nCandidates () - 1; theIdx >= 0; theIdx --)
         if (candIsEligible (theIdx, expPer))
            if (! thePmrSelPt->prevSel ()[theIdx])
               theBopEnts.push (candBopEnt_[theIdx]);
d339 1
a339 1
void WitPmrPart::select (WitBopEntry * theBopEnt, WitPeriod expPer)
d341 2
a342 3
   WitCandIndex nCands;
   WitCandIndex theIdx;
   WitCandIndex theSelIdx;
d344 1
a344 1
   witAssert (myPmrSelPt_[expPer] != NULL);
d346 3
a348 1
   nCands = nCandidates ();
d350 1
a350 12
   if (DEBUG_MODE)
      theSelIdx = -1;
   
   for (theIdx = 0; theIdx < nCands; theIdx ++)
      if (candBopEnt_[theIdx] == theBopEnt)
         {
         theSelIdx = theIdx;

         break;
         }

   witAssert (theSelIdx >= 0);
d352 1
a352 1
   myPmrSelPt_[expPer]->select (theSelIdx);
d359 1
a359 1
   WitCandIndex theIdx;
d365 1
a365 1
      theIdx = myPmrSelPt_[expPer]->selIndex ();
d367 2
a368 2
      if (theIdx >= 0)
         return candBopEnt_[theIdx];
d403 1
a403 1
      (thePmrSelPt->selIndex () >= 0)?
d410 1
a410 1
void WitPmrPart::initCandidate ()
d412 3
a417 5
   WitBopEntry *  theBopEnt;
   int            nCands;
   WitCandIndex   theIdx;
   WitBopEntStack theCands (myProblem ());

d423 2
a425 2

         theCands.push (theBopEnt);
d428 1
a428 3
   candBopEnt_.resize (nCands);

   theIdx = nCands - 1;
d430 1
a430 2
   while (theCands.pop (theBopEnt))
      candBopEnt_[theIdx --] = theBopEnt;
d443 34
d486 2
a487 3
      selIndex_   (-1),
      hasResAlt_  (witFALSE),
      prevSel_    (thePmrPart->nCandidates (), witFALSE)
d489 3
a491 1
   WitCandIndex theIdx;
d495 3
a497 1
   selectDefault ();
d499 5
a503 3
   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myPmrPart_->candIsEligible (theIdx, myExpPer_))
         if (theIdx != selIndex_)
d523 1
a523 1
   witAssert (selIndex_ >= 0);
d525 1
a525 1
   theBopEnt = myPmrPart_->candBopEnt ()[selIndex_];
d534 6
a539 1
   WitCandIndex theIdx;
d541 2
a542 1
   witAssert (selIndex_ >= 0);
d544 7
a550 9
   prevSel_[selIndex_] = witTRUE;
   selIndex_           = -1;
   hasResAlt_          = witFALSE;

   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myPmrPart_->candIsEligible (theIdx, myExpPer_))
         if (! prevSel_[theIdx])
            if (selIndex_ == -1)
               selIndex_ = theIdx;
a562 2
   WitBopEntry * theBopEnt;

d569 1
a569 1
   if (selIndex_ == -1)
a571 3
      {
      theBopEnt = myPmrPart_->candBopEnt ()[selIndex_];

d574 2
a575 3
         theBopEnt->myOperationName ().myCstring (),
         theBopEnt->localIndex ());
      }
d626 1
a626 1
void WitPmrSelPt::select (WitCandIndex theIdx)
d628 1
a628 2
   witAssert (theIdx >= 0);
   witAssert (theIdx < nCandidates ());
d630 1
a630 3
   witAssert (! prevSel_[theIdx]);
 
   witAssert (theIdx != selIndex_);
d632 1
a632 4
   selIndex_ = theIdx;
   }

//------------------------------------------------------------------------------
d634 1
a634 3
void WitPmrSelPt::selectDefault ()
   {
   WitCandIndex theIdx;
d636 1
a636 9
   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myPmrPart_->candIsDefault (theIdx, myExpPer_))
         {
         selIndex_ = theIdx;

         return;
         }

   myPmrPart_->myMsgFac () ("internalErrorFmsg", "WitPmrSelPt::selectDefault");
a643 23
   }

//------------------------------------------------------------------------------
// Implementation of class PmrCand.
//------------------------------------------------------------------------------

WitPmrCand::WitPmrCand (
         WitBopEntry * theBopEnt,
         WitPmrPart *  thePmrPart, 
         WitCandIndex  theIdx):

      WitSelCand (thePmrPart),

      myBopEnt_  (theBopEnt),
      myPmrPart_ (thePmrPart),
      myIdx_     (theIdx)
   {
   }

//------------------------------------------------------------------------------

WitPmrCand::~WitPmrCand ()
   {
@


1.12
log
@Fixed bug in two-way multi-exec:
   NSTN and ASAP multi-exec collisions were not being adequately detected.
@
text
@d16 1
a16 1
//    MrPart.
d18 1
d22 2
a23 1
#include <MrPart.h>
d30 1
a30 1
      WitSelMgr   (theSelector),
d32 2
a33 2
      myMrPartTl_ (),
      totExpVol_  (myProblem ())
d37 1
a37 1
   myMrPartTl_.allocate (myProblem (), NULL);
d40 1
a40 1
      myMrPart (thePart) = new WitMrPart (thePart, this);
d50 1
a50 1
      delete myMrPart (thePart);
d57 1
a57 1
   return myMrPart (thePart)->selBopEntry (expPer);
d74 1
a74 1
   thePmrSelPt = myMrPart (theBopEnt->myPart ())->myPmrSelPtWithAlt (expPer);
d125 1
a125 1
      myMrPart (thePart)->printHasAlt ();
d138 1
a138 1
      myMrPart (theBopEnt->myPart ())->select (theBopEnt, expPer);
d148 1
a148 1
   myMrPart (thePart)->findExpBopEnts (expPer, theBopEnts);
d162 1
a162 1
   WitMrPart * theMrPart;
d167 1
a167 1
   theMrPart = myMrPart (thePart);
d169 1
a169 1
   if (! theMrPart->multiChoice ())
d172 1
a172 1
   return theMrPart->myPmrSelPt ()[expPer]->isSplit ();
d186 1
a186 1
   thePmrSelPt = myMrPart (thePart)->myPmrSelPt ()[expPer];
d211 1
a211 1
      if (myMrPart (theBopEnt->myPart ())->multiChoice ())
d242 1
a242 1
      if (myMrPart (thePart)->multiChoice ())
d249 1
a249 1
// Implementation of class MrPart.
d252 1
a252 1
WitMrPart::WitMrPart (WitPart * thePart, WitPmrMgr * thePmrMgr):
d273 1
a273 1
WitMrPart::~WitMrPart ()
d284 1
a284 1
void WitMrPart::printHasAlt ()
d304 1
a304 1
WitBoolean WitMrPart::candIsDefault (WitCandIndex theIdx, WitPeriod expPer)
d311 1
a311 1
WitCandIndex WitMrPart::nCandidates ()
d318 1
a318 1
WitBoolean WitMrPart::candIsEligible (WitCandIndex theIdx, WitPeriod expPer)
d325 1
a325 1
void WitMrPart::findExpBopEnts (WitPeriod expPer, WitBopEntStack & theBopEnts)
d351 1
a351 1
void WitMrPart::select (WitBopEntry * theBopEnt, WitPeriod expPer)
d379 1
a379 1
WitBopEntry * WitMrPart::selBopEntry (WitPeriod expPer)
d398 1
a398 1
void WitMrPart::buildPmrSelPts ()
d414 1
a414 1
WitPmrSelPt * WitMrPart::multiChoicePmrSelPtWithAlt (WitPeriod expPer)
d432 1
a432 1
void WitMrPart::initCandidate ()
d462 1
a462 1
void WitMrPart::addPrereq (
d473 1
a473 1
WitPmrSelPt::WitPmrSelPt (WitMrPart * theMrPart, WitPeriod expPer):
d475 1
a475 1
      WitSelPt   (),
d477 5
a481 5
      myMrPart_  (theMrPart),
      myExpPer_  (expPer),
      selIndex_  (-1),
      hasResAlt_ (witFALSE),
      prevSel_   (theMrPart->nCandidates (), witFALSE)
d485 1
a485 1
   witAssert (myMrPart_->myPart ()->explodeable (myExpPer_));
d490 1
a490 1
      if (myMrPart_->candIsEligible (theIdx, myExpPer_))
d513 1
a513 1
   theBopEnt = myMrPart_->candBopEnt ()[selIndex_];
d531 1
a531 1
      if (myMrPart_->candIsEligible (theIdx, myExpPer_))
d559 1
a559 1
      theBopEnt = myMrPart_->candBopEnt ()[selIndex_];
d572 1
a572 1
   return myMrPart_->myPmrMgr ();
d582 1
a582 1
      myMrPart_->myPart ()->partName ().myCstring (),
d601 1
a601 1
   myMrPart_->myPmrMgr ()->adjustSplitBound (theBopEnt, myExpPer_, splitBound);
d610 1
a610 1
      myMrPart_->myPart ()->partName ().myCstring (),
d635 1
a635 1
      if (myMrPart_->candIsDefault (theIdx, myExpPer_))
d642 1
a642 1
   myMrPart_->myMsgFac () ("internalErrorFmsg", "WitPmrSelPt::selectDefault");
d649 24
a672 1
   return myMrPart_->msgFile ();
@


1.11
log
@Refactoring.
@
text
@d568 1
a568 1
WitSelMgr * WitPmrSelPt::mySelMgr (WitSelector * theSelector)
d570 1
a570 1
   return theSelector->myPmrMgr ();
@


1.10
log
@Refactoring.
@
text
@a129 16
void WitPmrMgr::printMultiChoices ()
   {
   WitPart * thePart;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Multi-Route Parts with multi-choice:\n"
      "\n");

   forEachPart (thePart, myProblem ())
      myMrPart (thePart)->printIfMultiChoice ();
   }

//------------------------------------------------------------------------------

a281 12
void WitMrPart::printIfMultiChoice ()
   {
   if (multiChoice_)
      {
      printID ();

      fprintf (msgFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

d295 1
a295 1
         if (thePmrSelPt->hasAlt ())
a322 17
void WitMrPart::printID ()
   {
   fprintf (msgFile (), "   Part %s", myPart_->partName ().myCstring ());
   }

//------------------------------------------------------------------------------

void WitMrPart::printCandidate (WitCandIndex theIdx)
   {
   fprintf (msgFile (),
      "BopEntry: %s #%d",
      candBopEnt_[theIdx]->myOperationName ().myCstring (),
      candBopEnt_[theIdx]->localIndex ());
   }

//------------------------------------------------------------------------------

d423 1
a423 1
      thePmrSelPt->hasAlt ()?
d476 1
a476 1
      expPeriod_ (expPer),
d483 1
a483 1
   witAssert (myMrPart_->myPart ()->explodeable (expPeriod_));
d488 1
a488 1
      if (myMrPart_->candIsEligible (theIdx, expPeriod_))
a504 7
WitBoolean WitPmrSelPt::hasAlt ()
   {
   return (selIndex_ >= 0);
   }

//------------------------------------------------------------------------------

d522 1
a522 1
   witAssert (hasAlt ());
d529 1
a529 1
      if (myMrPart_->candIsEligible (theIdx, expPeriod_))
d545 2
d551 2
d554 2
d557 1
a557 1
      fprintf (msgFile (), "   Selected BopEntry: None\n");
d559 4
a562 1
      return;
a563 8

   fprintf (msgFile (), "   Selected ");

   myMrPart_->printCandidate (selIndex_);

   fprintf (msgFile (),
      ", Has Alt? %s\n",
      myMrPart_->myMsgFac ().booleanText (hasAlt ()));
d581 1
a581 1
      expPeriod_);
d599 1
a599 1
   myMrPart_->myPmrMgr ()->adjustSplitBound (theBopEnt, expPeriod_, splitBound);
d606 4
a609 3
   myMrPart_->printID ();

   fprintf (msgFile (), ", Period %d\n", expPeriod_);
d633 1
a633 1
      if (myMrPart_->candIsDefault (theIdx, expPeriod_))
@


1.9
log
@Refactoring.
@
text
@d428 7
a434 4
   theIdx = 
      multiChoice_?
         myPmrSelPt_[expPer]->selIndex ():
         0;
d436 1
a436 3
   witAssert (theIdx >= 0);

   return candBopEnt_[theIdx];
d522 1
a522 1
      selIndex_  (0),
d552 1
a552 4
   return
      hasResAlt_?
         witTRUE:
         ! myMrPart_->candIsDefault (selIndex_, expPeriod_);
d561 2
a571 1
   WitBoolean   altFound;
d577 1
a577 1
   altFound            = witFALSE;
d583 1
a583 2
            if (! altFound)
               {
a584 2
               altFound  = witTRUE;
               }
d589 1
a589 1
               break;
a590 3

   if (! altFound)
      selectDefault ();
d600 7
@


1.8
log
@Continued development of selection splitting for multi=exec.
@
text
@d289 1
a289 1
   WitPeriod thePer;
d292 2
a293 2
      forEachPeriod (thePer, myProblem ())
         delete myPmrSelPt_[thePer];
d322 3
a324 2
      if (thePmrSelPt->hasAlt ())
         thePmrSelPt->printID ();
d330 1
a330 1
WitBoolean WitMrPart::candIsDefault (WitCandIndex theIdx, WitPeriod thePer)
d332 1
a332 1
   return (candBopEnt_[theIdx] == myPart_->expBopEntry (thePer));
d344 1
a344 1
WitBoolean WitMrPart::candIsEligible (WitCandIndex theIdx, WitPeriod thePer)
d346 1
a346 1
   return candBopEnt_[theIdx]->expEligible (thePer);
d379 2
d400 2
d442 1
a442 1
   WitPeriod thePer;
d449 3
a451 2
   forEachPeriod (thePer, myProblem ())
      myPmrSelPt_[thePer] = new WitPmrSelPt (this, thePer);
d464 2
d515 1
a515 1
WitPmrSelPt::WitPmrSelPt (WitMrPart * theMrPart, WitPeriod thePer):
d520 2
a521 2
      expPeriod_ (thePer),
      selIndex_  (-1),
d527 1
a527 2
   if (! myMrPart_->myPart ()->explodeable (expPeriod_))
      return;
d551 4
a554 7
   if (hasResAlt_)
      return witTRUE;

   if (selIndex_ == -1)
      return witFALSE;

   return ! myMrPart_->candIsDefault (selIndex_, expPeriod_);
a562 2
   witAssert (selIndex_ >= 0);

d572 1
d578 1
a578 1
   selIndex_           = -1;
d584 2
a585 1
            if (selIndex_ == -1)
d587 2
d596 1
a596 1
   if (selIndex_ == -1)
a603 2
   witAssert (selIndex_ >= 0);

d667 1
@


1.7
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@d91 22
d622 11
a646 29
   }

//------------------------------------------------------------------------------

void WitPmrSelPt::prtSplitting (double)
   {
   WitMsgFacility::current () ("internalErrorFmsg", 
      "WitPmrSelPt::prtSplitting");
   }

//------------------------------------------------------------------------------

void WitPmrSelPt::prtSplitExp (WitTlObj * splitTlObj)
   {
   WitBopEntry * theBopEnt;

   theBopEnt = (WitBopEntry *) splitTlObj;

   fprintf (msgFile (),
      "\n"
      "Split Selection for Production Multi-Route:\n"
      "   Part:        %s\n"
      "   Exp Per:     %d\n"
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEnt->myPartName ().myCstring (),
      expPeriod_,
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
@


1.6
log
@Various refactorings for sel-split for multi-exec.
@
text
@d28 1
a28 1
      WitSelMgr    (theSelector),
d30 2
a31 3
      myMrPartTl_  (),
      totExpVol_   (myProblem ()),
      splitExpPer_ (-1)
d181 10
d192 1
a192 1
   splitExpPer_ = expPer;
d198 3
a200 3
      WitBopEntry * theBopEnt, 
      WitPeriod      expPer, 
      double         expVol)
a240 9

void WitPmrMgr::adjustSplitBound (WitTlObj * theTlObj, double & splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExpVol_ (asaBopEntry (theTlObj), splitExpPer_);
   }

//------------------------------------------------------------------------------
d603 11
@


1.5
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@a174 1
   WitMrPart *   theMrPart;
a175 1
   WitBopEntry * theBopEnt;
d179 1
a179 4
   theMrPart   = myMrPart (thePart);

   thePmrSelPt = theMrPart->myPmrSelPt ()[expPer];
   theBopEnt   = theMrPart->selBopEntry  (expPer);
d181 1
a181 1
   startSplitExpAbs (thePmrSelPt, asaTlObj (theBopEnt), expVol);
a240 23

void WitPmrMgr::prtSplitExp (WitTlObj * theTlObj)
   {
   WitBopEntry * theBopEnt;

   witAssert (selSplit ());

   theBopEnt = asaBopEntry (theTlObj);

   fprintf (msgFile (),
      "\n"
      "Split Selection for Production Multi-Route:\n"
      "   Part:        %s\n"
      "   Exp Per:     %d\n"
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n",
      theBopEnt->myPartName ().myCstring (),
      splitExpPer_,
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
   }

//------------------------------------------------------------------------------
a488 1
      myPeriod_  (thePer),
d490 1
d497 1
a497 1
   if (! myMrPart_->myPart ()->explodeable (myPeriod_))
d503 1
a503 1
      if (myMrPart_->candIsEligible (theIdx, myPeriod_))
d528 1
a528 1
   return ! myMrPart_->candIsDefault (selIndex_, myPeriod_);
d533 1
a533 1
WitTlObj * WitPmrSelPt::selection ()
d557 1
a557 1
      if (myMrPart_->candIsEligible (theIdx, myPeriod_))
d615 21
d640 1
a640 1
   fprintf (msgFile (), ", Period %d\n", myPeriod_);
d663 1
a663 1
      if (myMrPart_->candIsDefault (theIdx, myPeriod_))
@


1.4
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a31 1
      splitSched_  (myProblem ()),
d54 1
a54 1
WitBopEntry * WitPmrMgr::selBopEntry (WitPart * thePart, WitPeriod thePer)
d56 1
a56 1
   return myMrPart (thePart)->selBopEntry (thePer);
d68 1
a68 1
   WitPeriod     prodPer;
d71 1
a71 1
   prodPer     = theBopEnt->impactPeriod ()[execPer];
d73 1
a73 1
   thePmrSelPt = myMrPart (theBopEnt->myPart ())->myPmrSelPtWithAlt (prodPer);
d75 1
a75 1
   resFound    = 
d155 9
a163 4
   if (selSplit ())
      if (myMrPart (thePart)->multiChoice ())
         if (! splitSched_ (thePart, expPer).isEmpty ())
            return witTRUE;
d165 1
a165 1
   return witFALSE;
d175 4
d181 7
a188 6

   startSplitExpAbs (
      splitSched_           (thePart, expPer),
      asaTlObj (selBopEntry (thePart, expPer)),
      expVol,
      NULL);
a215 3
   witAssert (selSplit ());

   splitSched_.clear ();
d227 1
a227 2
   totExpVol_ .allocate1D ();
   splitSched_.allocate1D ();
a230 1
         {
a233 3

         splitSched_.allocateRow (thePart);
         }
d238 1
a238 1
void WitPmrMgr::adjustSplitBound (WitTl * theTlObj, double & splitBound)
d247 1
a247 1
void WitPmrMgr::prtSelSplit (WitTl * theTlObj)
d277 1
a277 1
      candidate_   (),
d318 1
a318 1
   WitPeriod     thePer;
d324 1
a324 1
   forEachPeriod (thePer, myProblem ())
d326 1
a326 1
      thePmrSelPt = myPmrSelPt_[thePer];
d337 1
a337 1
   return (candidate_[theIdx] == myPart_->expBopEntry (thePer));
d344 1
a344 1
   return candidate_.length ();
d351 1
a351 1
   return candidate_[theIdx]->expEligible (thePer);
d367 2
a368 2
      candidate_[theIdx]->myOperationName ().myCstring (),
      candidate_[theIdx]->localIndex ());
d382 1
a382 1
      thePmrSelPt = myPmrSelPt ()[expPer];
d387 1
a387 1
               theBopEnts.push (candidate_[theIdx]);
d409 1
a409 1
      if (candidate_[theIdx] == theBopEnt)
d418 19
a436 1
   myPmrSelPt ()[expPer]->select (theSelIdx);
d456 1
a456 1
WitPmrSelPt * WitMrPart::multiChoicePmrSelPtWithAlt (WitPeriod thePer)
d462 1
a462 1
   thePmrSelPt = myPmrSelPt_[thePer];
d492 1
a492 1
   candidate_.resize (nCands);
d497 1
a497 1
      candidate_[theIdx --] = theBopEnt;
d561 13
a601 7
void WitPmrSelPt::splitSelection (double)
   {
   myMrPart_->myMsgFac () ("internalErrorFmsg", "PmrSelPt::splitSelection");
   }

//------------------------------------------------------------------------------

d631 8
@


1.3
log
@Renamed AltPt classes to SelPt classes.
@
text
@a40 3

   if (selSplit ())
      setupSelSplit ();
d147 7
d214 1
a214 1
void WitPmrMgr::setupSelSplit ()
@


1.2
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@d17 1
a17 1
//    PmrAltPt.
d65 1
a65 1
WitAltPt * WitPmrMgr::myAltPt (
d73 1
a73 1
   WitPmrAltPt * thePmrAltPt;
d77 1
a77 1
   thePmrAltPt = myMrPart (theBopEnt->myPart ())->myPmrAltPtWithAlt (prodPer);
d80 2
a81 2
      (thePmrAltPt != NULL)?
         thePmrAltPt->hasResAlt ():
d84 1
a84 1
   return thePmrAltPt;
d103 1
a103 1
      "Production Multi-Route Alt Points with Alternative(s):\n\n");
d274 1
a274 1
      myPmrAltPt_  ()
d283 1
a283 1
   buildPmrAltPts ();
d294 1
a294 1
         delete myPmrAltPt_[thePer];
d314 1
a314 1
   WitPmrAltPt * thePmrAltPt;
d321 1
a321 1
      thePmrAltPt = myPmrAltPt_[thePer];
d323 2
a324 2
      if (thePmrAltPt->hasAlt ())
         thePmrAltPt->printID ();
d371 1
a371 1
   WitPmrAltPt * thePmrAltPt;
d377 1
a377 1
      thePmrAltPt = myPmrAltPt ()[expPer];
d381 1
a381 1
            if (! thePmrAltPt->prevSel ()[theIdx])
d413 1
a413 1
   myPmrAltPt ()[expPer]->select (theSelIdx);
d418 1
a418 1
void WitMrPart::buildPmrAltPts ()
d425 1
a425 1
   myPmrAltPt_.allocate (myProblem ());
d428 1
a428 1
      myPmrAltPt_[thePer] = new WitPmrAltPt (this, thePer);
d433 1
a433 1
WitPmrAltPt * WitMrPart::multiChoicePmrAltPtWithAlt (WitPeriod thePer)
d435 1
a435 1
   WitPmrAltPt * thePmrAltPt;
d439 1
a439 1
   thePmrAltPt = myPmrAltPt_[thePer];
d442 2
a443 2
      thePmrAltPt->hasAlt ()?
         thePmrAltPt:
d487 1
a487 1
// Implementation of class PmrAltPt.
d490 1
a490 1
WitPmrAltPt::WitPmrAltPt (WitMrPart * theMrPart, WitPeriod thePer):
d492 1
a492 1
      WitAltPt   (),
d519 1
a519 1
WitPmrAltPt::~WitPmrAltPt ()
d525 1
a525 1
WitBoolean WitPmrAltPt::hasAlt ()
d538 1
a538 1
void WitPmrAltPt::alterSelection ()
d566 1
a566 1
void WitPmrAltPt::splitSelection (double)
d568 1
a568 1
   myMrPart_->myMsgFac () ("internalErrorFmsg", "PmrAltPt::splitSelection");
d573 1
a573 1
void WitPmrAltPt::printSelection ()
d592 1
a592 1
WitSelMgr * WitPmrAltPt::mySelMgr (WitSelector * theSelector)
d599 1
a599 1
WitBoolean WitPmrAltPt::splittable ()
d606 1
a606 1
void WitPmrAltPt::printID ()
d615 1
a615 1
void WitPmrAltPt::select (WitCandIndex theIdx)
d628 1
a628 1
void WitPmrAltPt::selectDefault ()
d640 1
a640 1
   myMrPart_->myMsgFac () ("internalErrorFmsg", "WitPmrAltPt::selectDefault");
d645 1
a645 1
FILE * WitPmrAltPt::msgFile ()
@


1.1
log
@Refactoring for selection splitting.
@
text
@d173 1
a173 1
      asaTlPtr (selBopEntry (thePart, expPer)),
@


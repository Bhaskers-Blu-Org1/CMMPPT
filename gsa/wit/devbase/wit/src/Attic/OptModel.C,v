head	1.57;
access;
symbols
	sce_5_01_20080919:1.47
	latest_sce_4_20_20060523:1.43.0.2
	sce_4_20_20060523:1.43
	latest_sce4_20_OSL:1.37.0.2
	sce_4_20_OSL:1.37
	sce_410_withVa:1.29
	sce_4_05_20040511:1.26
	sce_4_00_20040201:1.22
	nextGenBranch:1.19.0.2
	nextGenRoot:1.19
	sce_3_30_20030627:1.17
	EndRw-branch:1.3.0.4
	Root-of-EndRw:1.3
	rwToStl:1.3.0.2;
locks; strict;
comment	@ * @;


1.57
date	2010.08.19.18.00.13;	author rjw;	state dead;
branches;
next	1.56;

1.56
date	2010.08.19.14.22.14;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2010.08.17.22.22.56;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2010.06.07.21.21.43;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2010.06.04.23.24.56;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2010.03.24.21.31.03;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2010.02.23.19.19.35;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2010.01.14.22.57.54;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.13.19.52.08;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2010.01.09.00.12.04;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.03.22.35.43;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.29.23.24.29;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.27.23.19.10;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.08.18.18.43.38;	author rjw;	state dead;
branches;
next	1.43;

1.43
date	2006.05.02.17.34.05;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.27.22.08.58;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.21.21.02.49;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.21.20.37.11;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.21.20.06.32;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.18.19.06.55;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.02.21.40.36;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.02.20.35.33;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.01.19.23.24;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.21.15.44.14;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2006.02.17.17.07.17;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.18.20.56.21;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.04.19.53.50;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.13.19.31.57;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.30.18.13.59;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.17.17.30.43;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.12.21.29.50;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.13.21.50.14;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.20.15.37.35;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.18.18.30.16;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.31.16.23.29;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.29.21.07.35;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.28.23.37.47;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.18.21.13.38;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.30.18.19.11;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.28.22.19.30;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.28.15.10.16;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.27.20.34.33;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.23.18.12.36;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.21.17.37.02;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.20.19.38.33;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.20.16.02.39;	author fasano;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.13.22.00.04;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.13.20.43.24;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.23.20.47.18;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.02.23.40.45;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.02.22.18.40;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.25.15.15.22;	author rwToStl;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.06.19.56.09;	author rjw;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.08.29.23.06.27;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.26.22.49.04;	author rjw;	state Exp;
branches;
next	;

1.3.2.1
date	2002.11.08.16.11.34;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.57
log
@CPLEX
@
text
@//----------------------------------------------------------------------------
// 
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Source file: "OptModel.C"
//
// Implementation of class OptModel.
//----------------------------------------------------------------------------

#include <OptModel.h>
#include <SolverMgr.h>
#include <OptVar.h>
#include <OptCon.h>
#include <DetOptImpMgr.h>
#include <Coeff.h>
#include <OptComp.h>
#include <Timing.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <Session.h>

#include <float.h>

//------------------------------------------------------------------------------
// Implementation of class OptModel.
//------------------------------------------------------------------------------

inline WitCoeff * & WitOptModel::varLastCoeff (const WitOptVar * theVar)
   {
   return varLastCoeff_[theVar->index ()];
   }

//------------------------------------------------------------------------------

void WitOptModel::store (WitOptVar * theVar)
   {
   myOptVars_.append (theVar);
   }

//------------------------------------------------------------------------------

void WitOptModel::store (WitOptCon * theCon)
   {
   myOptCons_.append (theCon);
   }

//------------------------------------------------------------------------------

void WitOptModel::generateFixed ()
   {
   generateVariables ();

   countIntVars ();

   generateConstraints ();

   generateCoeffs ();

   if (myOptComp ()->multiObjMode ())
      {
      generateLexOptVarSeq (myLexOptVarSeq_);
      }

   postGenFixed ();

   if (DEVELOPMENT)
      {
      myMsgFac () ("lpMipDimMsg",
         myMsgFac ().myFrag (myOptComp ()->mipMode ()? "mipFrag": "lpFrag"),
         nOptVars (),
         nOptCons (),
         nCoeffs  ());

      if (myOptComp ()->mipMode ())
         myMsgFac () ("nIntVarsMsg", nIntVars_);

      displayDerived ();
      }
   }

//------------------------------------------------------------------------------

void WitOptModel::countIntVars ()
   {
   WitOptVar * theVar;

   nIntVars_ = 0;

   forEachEl (theVar, myOptVars_)
      if (theVar->isAnIntVar ())
         nIntVars_ ++;
   }

//------------------------------------------------------------------------------

void WitOptModel::incCoeff (WitOptVar * theVar, double delta)
   {
   if (fabs (delta) <= FLOAT_EPSILON)
      return;

   WitCoeff * theCoeff;

   theCoeff = varLastCoeff (theVar);

   if (theCoeff != NULL)
      if (theCoeff->myCon () == curCon_)
         {
         theCoeff->increment (delta);

         return;
         }

   theCoeff = new WitCoeff (curCon_, theVar, delta);

   varLastCoeff (theVar) = theCoeff;

   curConCoeffs_.push (theCoeff);

   nCoeffs_ ++;
   }

//------------------------------------------------------------------------------

void WitOptModel::generateFlexible ()
   {
   WitOptVar * theOptVar;
   WitOptCon * theOptCon;

   forEachEl (theOptVar, myOptVars_)
      theOptVar->compBounds ();

   forEachEl (theOptCon, myOptCons_)
      theOptCon->compBounds ();

   generateObjCoeffs ();

   postGenFlexible ();
   }

//------------------------------------------------------------------------------

const WitBoundPair & WitOptModel::preScreenBounds (const WitOptVar * theVar)
   {
   return varPreScreenBounds_.myElemAt (theVar->index ());
   }

//------------------------------------------------------------------------------

const WitBoundPair & WitOptModel::preScreenBounds (const WitOptCon * theCon)
   {
   return conPreScreenBounds_.myElemAt (theCon->index ());
   }

//------------------------------------------------------------------------------
// calcInitSoln calculates an initial solution.
// First the independent variable are initialized, by calling indepInitValue.
// Then the dependent variables are initialized with a call to initDepVars.
//------------------------------------------------------------------------------

void WitOptModel::calcInitSoln ()
   {
   WitOptVar * theVar;

   forEachEl (theVar, myOptVars_)
      theVar->setPrimalValue (theVar->indepInitValue ());

   initDepVars ();
   }

//------------------------------------------------------------------------------

void WitOptModel::getLpProbForCplex (
      WitVector <double> & objective,
      WitVector <double> & rhs,
      WitVector <char>   & sense,
      WitVector <int>    & matbeg,
      WitVector <int>    & matcnt,
      WitVector <int>    & matind,
      WitVector <double> & matval,
      WitVector <double> & lb,
      WitVector <double> & ub)
   {
   getRowDataForCplex (rhs, sense);

   getColumnDataForCplex (objective, matbeg, matcnt, matind, matval, lb, ub);
   }

//------------------------------------------------------------------------------

void WitOptModel::getMatrixByCols (
      WitVector <int> &    firstCoeffIdx,
      WitVector <int> &    rowIdx,
      WitVector <double> & coeffVal)
   {
   WitCoeffItr theItr;
   WitOptVar * theVar;
   WitCoeff *  theCoeff;
   int         idx;

   rowIdx       .resize (nCoeffs_);
   firstCoeffIdx.resize (nOptVars () + 1);
   coeffVal     .resize (nCoeffs_);

   idx = 0;

   forEachEl (theVar, myOptVars_)
      {
      firstCoeffIdx[theVar->index ()] = idx;

      theVar->attachCoeffItr (theItr);

      while (theItr.advance (theCoeff))
         {
         rowIdx  [idx] = theCoeff->myCon ()->index ();

         coeffVal[idx] = theCoeff->myValue ();

         idx ++;
         }
      }

   firstCoeffIdx[nOptVars ()] = idx;

   witAssert (idx == nCoeffs ());
   }

//------------------------------------------------------------------------------

void WitOptModel::print ()
   {
   WitTimer::enterSection ("extra");

   myMsgFac () ("writeOptModelMsg");

   modelFile_ = openFile ("model.out", "w");

   myProblem ()->mySession ()->writeHeading (modelFile ());

   if (myOptComp ()->mipMode ())
      fprintf (modelFile (),
         "Mixed Integer Programming Model\n"
         "===== ======= =========== =====\n\n\n");
   else
      fprintf (modelFile (),
         "Linear Programming Model\n"
         "====== =========== =====\n\n\n");

   fprintf (modelFile (), "# Variables:    %8d\n",   nOptVars ());

   if (myOptComp ()->mipMode ())
      fprintf (modelFile (), 
                            "# Integer Vars: %8d\n",   nIntVars_);

   fprintf (modelFile (), "# Constraints:  %8d\n",   nOptCons ());
   fprintf (modelFile (), "# Coefficients: %8d\n\n", nCoeffs ());

   printVars    ();
   printCons    ();
   printObjFunc ();

   if (myOptComp ()->multiObjMode ())
      {
      printLexSeq ();
      }

   printDerived ();

   if (myOptComp ()->printMatByCols ())
      prtMatrixByCols ();

   fclose (modelFile ());

   modelFile_ = NULL;

   WitTimer::leaveSection ("extra");
   }

//------------------------------------------------------------------------------

WitOptModel::WitOptModel (WitProblem * theProblem):

      WitProbAssoc    (theProblem),

      mySolverMgr_    (NULL),
      nCoeffs_        (0),
      curCon_         (NULL),
      curConCoeffs_   (myProblem ()),
      myLexOptVarSeq_ (),
      modelFile_      (NULL)
   {
   mySolverMgr_ = WitSolverMgr::newInstance (this);
   }

//------------------------------------------------------------------------------

WitOptModel::~WitOptModel ()
   {
   int idx;

   delete mySolverMgr_;

   while (not myOptCons_.isEmpty ())
      delete myOptCons_.get ();

   while (not myOptVars_.isEmpty ())
      delete myOptVars_.get ();

   for (idx = 0; idx < conPreScreenBounds_.length (); idx ++)
      delete conPreScreenBounds_[idx];

   for (idx = 0; idx < varPreScreenBounds_.length (); idx ++)
      delete varPreScreenBounds_[idx];
   }

//------------------------------------------------------------------------------

void WitOptModel::generateLexOptVarSeq (WitPtrVec <WitOptVar> & theOptVarSeq)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitOptModel::solve ()
   {
   if (not myOptComp ()->skipScreening ())
      doScreening ();

   if (myOptComp ()->printOptModel ())
      print ();

   checkVarBounds ();

   mySolverMgr_->solve ();

   if (needDual ())
      reconstructDual ();
   }

//------------------------------------------------------------------------------

double WitOptModel::compObjValue ()
   {
   WitOptVar * theOptVar;
   double      theObjValue;

   theObjValue = 0.0;

   forEachEl (theOptVar, myOptVars_)
      {
      theObjValue +=
         theOptVar->objCoeff    () *
         theOptVar->primalValue ();
      }

   return theObjValue;
   }

//------------------------------------------------------------------------------

void WitOptModel::displayDerived ()
   {
   }

//------------------------------------------------------------------------------

void WitOptModel::printDerived ()
   {
   }

//------------------------------------------------------------------------------
// initDepVars.
// Initializes the dependent variables, i.e., those variables whose
// initial value depends on the initial value of other variables.
//------------------------------------------------------------------------------

void WitOptModel::initDepVars ()
   {
   }

//------------------------------------------------------------------------------

void WitOptModel::saveBounds ()
   {
   WitOptVar * theVar;
   WitOptCon * theCon;

   varPreScreenBounds_.resize (nOptVars ());
   conPreScreenBounds_.resize (nOptCons ());

   forEachEl (theVar, myOptVars_)
      {
      varPreScreenBounds_          [theVar->index ()] = new WitBoundPair;

      varPreScreenBounds_.myElemAt (theVar->index ()) = theVar->bounds ();
      }

   forEachEl (theCon, myOptCons_)
      {
      conPreScreenBounds_          [theCon->index ()] = new WitBoundPair;

      conPreScreenBounds_.myElemAt (theCon->index ()) = theCon->bounds ();
      }
   }

//------------------------------------------------------------------------------

int WitOptModel::screen (WitOptCon * theCon)
   {
   int         nVarsFixed;
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   nVarsFixed = 0;

   if (theCon == NULL)
      return 0;

   if (not theCon->screenable ())
      return 0;

   theCon->attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      {
      if (theCoeff->myValue () <= FLOAT_EPSILON)
         continue;

      if (theCoeff->myVar ()->bounds ().upper () == 0.0)
         continue;

      theCoeff->myVar ()->bounds ().upper () = 0.0;

      if (needDual ())
         screenedCoeffs_.prepend (theCoeff);

      ++ nVarsFixed;
      }

   return nVarsFixed;
   }

//------------------------------------------------------------------------------

void WitOptModel::generateCoeffs ()
   {
   buildCoeffs ();

   allocVarCoeffs ();

   storeCoeffs ();
   }

//------------------------------------------------------------------------------

void WitOptModel::buildCoeffs ()
   {
   WitCoeff * theCoeff;

   nCoeffs_ = 0;

   varLastCoeff_.resize (nOptVars ());
                
   forEachEl (curCon_, myOptCons_)
      {
      curCon_->generateCoeffs ();

      curCon_->allocMyCoeffs (curConCoeffs_.nElements ());

      while (curConCoeffs_.pop (theCoeff))
         curCon_->store (theCoeff);
      }

   varLastCoeff_.clear  ();
   }

//------------------------------------------------------------------------------

void WitOptModel::allocVarCoeffs ()
   {
   WitOptVar * theVar;
   WitOptCon * theCon;
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   WitVector <int> nCoeffsForVar (nOptVars (), 0);
      //
      // nCoeffsForVar[theVar->index ()] is # Coeffs for theVar.

   forEachEl (theCon, myOptCons_)
      {
      theCon->attachCoeffItr (theItr);

      while (theItr.advance (theCoeff))
         ++ nCoeffsForVar[theCoeff->myVar ()->index ()];
      }

   forEachEl (theVar, myOptVars_)
      theVar->allocMyCoeffs (nCoeffsForVar[theVar->index ()]);
   }

//------------------------------------------------------------------------------

void WitOptModel::storeCoeffs ()
   {
   WitOptCon * theCon;
   WitOptVar * theVar;
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   forEachEl (theCon, myOptCons_)
      {
      theCon->attachCoeffItr (theItr);

      while (theItr.advance (theCoeff))
         theCoeff->myVar ()->store (theCoeff);

      theCon->clearMyCoeffs ();
      }

   forEachEl (theVar, myOptVars_)
      {
      theVar->attachCoeffItr (theItr);

      while (theItr.advance (theCoeff))
         theCoeff->myCon ()->store (theCoeff);
      }
   }

//------------------------------------------------------------------------------

void WitOptModel::generateObjCoeffs ()
   {
   WitOptVar * theVar;

   forEachEl (theVar, myOptVars_)
      theVar->generateObjCoeff ();
   }

//------------------------------------------------------------------------------

void WitOptModel::printVars ()
   {
   WitOptVar * theVar;

   fprintf (modelFile (),
      "\n\n"
      "Variables\n"
      "=========\n");

   fprintf (modelFile (), "Var ");

   printOptVCHeading ();

   fprintf (modelFile (), " I  Obj Cff Low Bnd  Up Bnd   PS LB   PS UB\n");

   forEachEl (theVar, myOptVars_)
      theVar->print ();
   }

//------------------------------------------------------------------------------

void WitOptModel::printCons ()
   {
   WitOptCon * theCon;

   fprintf (modelFile (),
      "\n\n"
      "Constraints\n"
      "===========\n");

   fprintf (modelFile (), "Con ");

   printOptVCHeading ();

   fprintf (modelFile (), " Low Bnd  Up Bnd   PS LB   PS UB\n");

   fprintf (modelFile (), "Var ");

   printOptVCHeading ();

   fprintf (modelFile (), "   Coeff\n");

   forEachEl (theCon, myOptCons_)
      theCon->print ();
   }

//------------------------------------------------------------------------------

void WitOptModel::printObjFunc ()
   {
   WitOptVar * theOptVar;
   double      theObjCoeff;

   fprintf (modelFile (),
      "\n\n"
      "Objective Function\n"
      "==================\n");

   fprintf (modelFile (), "Var ");

   printOptVCHeading ();

   fprintf (modelFile (), "    Coeff\n");

   forEachEl (theOptVar, myOptVars_)
      {
      theObjCoeff = theOptVar->objCoeff ();

      if (fabs (theObjCoeff) > FLOAT_EPSILON)
         {
         theOptVar->printID ();

         fprintf (modelFile_, " %8.1f\n", theObjCoeff);
         }
      }
   }

//------------------------------------------------------------------------------

void WitOptModel::printLexSeq ()
   {
   WitPtrVecItr <WitOptVar> theOptVarItr;
   WitOptVar *              theOptVar;

   stronglyAssert (myOptComp ()->multiObjMode ());

   fprintf (modelFile (),
      "\n\n"
      "Sequence of Variables to be Lexicographically Maximized\n"
      "=======================================================\n\n");

   myLexOptVarSeq_.attachItr (theOptVarItr);

   while (theOptVarItr.advance (theOptVar))
      {
      theOptVar->printID ();

      fprintf (modelFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

void WitOptModel::prtMatrixByCols ()
   {
   WitVector <int>    firstCoeffIdx;
   WitVector <int>    rowIdx;
   WitVector <double> coeffVal;
   int                theIdx;

   getMatrixByCols (firstCoeffIdx, rowIdx, coeffVal);

   fprintf (modelFile (),
      "\n\n\n"
      "Matrix by Columns\n"
      "====== == =======\n\n");

   fprintf (modelFile (), "\nColumn #      Elem #\n");

   for (theIdx = 0; theIdx <= nOptVars (); theIdx ++)
      fprintf (modelFile (), "%8d  %8d\n", theIdx, firstCoeffIdx[theIdx]);

   fprintf (modelFile (), "\n  Elem #     Row #    Coefficient\n");

   for (theIdx = 0; theIdx < nCoeffs (); theIdx ++)
      fprintf (
         modelFile (),
         "%8d  %8d  %13.3f\n",
         theIdx,
         rowIdx  [theIdx],
         coeffVal[theIdx]);
   }

//------------------------------------------------------------------------------

void WitOptModel::checkVarBounds ()
   {
   WitOptVar * theVar;

   forEachEl (theVar, myOptVars_)
      if (theVar->bounds ().lower () > theVar->bounds ().upper ())
         reportInfeasible ();
   }

//------------------------------------------------------------------------------

void WitOptModel::getRowDataForCplex (
      WitVector <double> & rhs,
      WitVector <char> &   sense)
   {
   WitOptCon * theOptCon;
   int         theIdx;
   double      theLB;
   double      theUB;

   rhs  .resize (nOptCons ());
   sense.resize (nOptCons ());

   forEachEl (theOptCon, myOptCons_)
      {
      theIdx = theOptCon->index ();

      theLB  = theOptCon->bounds ().lower ();
      theUB  = theOptCon->bounds ().upper ();

      if (theLB == theUB)
         {
         rhs  [theIdx] = theLB;
         sense[theIdx] = 'E';
         }
      else if (theUB == + DBL_MAX)
         {
         rhs  [theIdx] = theLB;
         sense[theIdx] = 'G';
         }
      else if (theLB == - DBL_MAX)
         {
         rhs  [theIdx] = theUB;
         sense[theIdx] = 'L';
         }
      else
         {
         stronglyAssert (false);
         }
      }
   }

//------------------------------------------------------------------------------

void WitOptModel::getColumnDataForCplex (
      WitVector <double> & objective,
      WitVector <int> &    matbeg,
      WitVector <int> &    matcnt,
      WitVector <int> &    matind,
      WitVector <double> & matval,
      WitVector <double> & lb,
      WitVector <double> & ub)
   {
   WitOptVar * theOptVar;
   int         theIdx;

   objective.resize (nOptVars ());
   matcnt   .resize (nOptVars ());
   lb       .resize (nOptVars ());
   ub       .resize (nOptVars ());

   getMatrixByCols (matbeg, matind, matval);

   forEachEl (theOptVar, myOptVars_)
      {
      theIdx            = theOptVar->index ();

      objective[theIdx] = theOptVar->objCoeff ();

      matcnt[theIdx]    = matbeg[theIdx + 1] - matbeg[theIdx];

      lb[theIdx]        = theOptVar->bounds ().lower ();
      ub[theIdx]        = theOptVar->bounds ().upper ();
      }
   }

//------------------------------------------------------------------------------

void WitOptModel::reconstructDual ()
   {
   int        nElim;
   WitCoeff * theCoeff;
   double     redReward;
   double     newDualVal;

   nElim = 0;

   while (not screenedCoeffs_.isEmpty ())
      {
      theCoeff  = screenedCoeffs_.get ();

      redReward = theCoeff->myVar ()->reducedReward ();

      if (redReward > FLOAT_EPSILON)
         {
         newDualVal = 
              theCoeff->myCon ()->dualValue ()
            + (redReward / theCoeff->myValue ());

         theCoeff->myCon ()->setDualValue (newDualVal);

         ++ nElim;
         }
      }

   if (DEVELOPMENT)
      myMsgFac () ("nDualElimMsg", nElim);
   }
@


1.56
log
@CPLEX
@
text
@@


1.55
log
@CPLEX
@
text
@a178 3
      int                & numcols,
      int                & numrows,
      int                & objsense,
d187 1
a187 2
      WitVector <double> & ub,
      WitVector <double> & rngval)
a188 6
   numcols  = nOptVars ();
   numrows  = nOptCons ();
   objsense = -1;

   rngval.resize (0);

@


1.54
log
@CPLEX
@
text
@d178 4
a181 1
void WitOptModel::getLpModelForCplex (
d184 4
a187 4
      WitVector <char> &   sense,
      WitVector <int> &    matbeg,
      WitVector <int> &    matcnt,
      WitVector <int> &    matind,
d190 2
a191 1
      WitVector <double> & ub)
d193 6
d218 1
a218 1
   coeffVal     .resize (nCoeffs ());
@


1.53
log
@CPLEX
@
text
@d189 1
a189 14
   WitOptVar * theOptVar;
   int         theIdx;
   double      theLB;
   double      theUB;

   objective.resize (nOptVars ());
   rhs      .resize (nOptVars ());
   sense    .resize (nOptVars ());

   forEachEl (theOptVar, myOptVars_)
      {
      theIdx = theOptVar->index ();

      objective[theIdx] = theOptVar->objCoeff ();
d191 1
a191 25
      theLB = theOptVar->bounds ().lower ();
      theUB = theOptVar->bounds ().upper ();

      if (theLB == theUB)
         {
         rhs  [theIdx] = theLB;
         sense[theIdx] = 'E';
         }
      else if (theUB == + DBL_MAX)
         {
         rhs  [theIdx] = theLB;
         sense[theIdx] = 'G';
         }
      else if (theLB == - DBL_MAX)
         {
         rhs  [theIdx] = theUB;
         sense[theIdx] = 'L';
         }
      else
         {
         stronglyAssert (false);
         }
      }

   stronglyAssert (false);
d694 77
@


1.52
log
@Removed OptObj classes.
@
text
@d28 2
d178 55
@


1.51
log
@Multi-Obj Mode
@
text
@a21 1
#include <OptObj.h>
a52 7
void WitOptModel::store (WitOptObj * theObj)
   {
   myOptObjs_.append (theObj);
   }

//------------------------------------------------------------------------------

a60 2
   mainObj_ = generateObjectives ();

d139 1
a139 1
   generateMainObjCoeffs ();
a240 1
   fprintf (modelFile (), "# Objectives:   %8d\n",   nOptObjs ());
d243 3
a245 5
   fprintf (modelFile (), "Objective Function:  %s\n", mainObj ()->myText ());

   printVars ();
   printCons ();
   printObjs ();
a273 1
      mainObj_        (NULL),
a287 3
   while (not myOptObjs_.isEmpty ())
      delete myOptObjs_.get ();

d328 19
d518 1
a518 1
void WitOptModel::generateMainObjCoeffs ()
d523 1
a523 1
      theVar->compMainObjCoeffVal ();
d576 1
a576 1
void WitOptModel::printObjs ()
d578 2
a579 1
   WitOptObj * theObj;
d583 2
a584 2
      "Objectives\n"
      "==========\n");
d592 11
a602 2
   forEachEl (theObj, myOptObjs_)
      theObj->print ();
@


1.50
log
@Multi-objective mode.
@
text
@a85 1
         nOptObjs (),
@


1.49
log
@Multi-objective mode
@
text
@d83 1
a83 4
         myMsgFac ().myFrag (
            myOptComp ()->mipMode ()?
               "mipFrag":
               "lpFrag"),
@


1.48
log
@Multi-objective mode
@
text
@d17 1
a17 1
#include <OptSolver.h>
d287 1
a287 1
      myOptSolver_    (NULL),
d295 1
a295 1
   myOptSolver_ = new WitOptSolver (this);
d304 1
a304 1
   delete myOptSolver_;
d341 1
a341 1
   myOptSolver_->solve ();
@


1.47
log
@Stochastic Implosion
@
text
@d73 5
d263 6
d285 1
a285 1
      WitProbAssoc  (theProblem),
d287 7
a293 6
      myOptSolver_  (NULL),
      nCoeffs_      (0),
      curCon_       (NULL),
      curConCoeffs_ (myProblem ()),
      mainObj_      (NULL),
      modelFile_    (NULL)
d324 7
d599 24
@


1.46
log
@Stochastic Implosion
@
text
@d236 2
a237 2
         "Mixed Integer Programming Problem\n"
         "===== ======= =========== =======\n\n\n");
d240 2
a241 2
         "Linear Programming Problem\n"
         "====== =========== =======\n\n\n");
@


1.45
log
@Stochastic Implosion
@
text
@d230 1
a230 1
   optProbFile_ = openFile ("opt-prob.out", "w");
d232 1
a232 1
   myProblem ()->mySession ()->writeHeading (optProbFile ());
d235 1
a235 1
      fprintf (optProbFile (),
d239 1
a239 1
      fprintf (optProbFile (),
d243 1
a243 1
   fprintf (optProbFile (), "# Variables:    %8d\n",   nOptVars ());
d246 1
a246 1
      fprintf (optProbFile (), 
d249 3
a251 3
   fprintf (optProbFile (), "# Constraints:  %8d\n",   nOptCons ());
   fprintf (optProbFile (), "# Objectives:   %8d\n",   nOptObjs ());
   fprintf (optProbFile (), "# Coefficients: %8d\n\n", nCoeffs ());
d253 1
a253 1
   fprintf (optProbFile (), "Objective Function:  %s\n", mainObj ()->myText ());
d263 1
a263 1
   fclose (optProbFile ());
d265 1
a265 1
   optProbFile_ = NULL;
d281 1
a281 1
      optProbFile_  (NULL)
d515 1
a515 1
   fprintf (optProbFile (),
d520 1
a520 1
   fprintf (optProbFile (), "Var ");
d524 1
a524 1
   fprintf (optProbFile (), " I  Obj Cff Low Bnd  Up Bnd   PS LB   PS UB\n");
d536 1
a536 1
   fprintf (optProbFile (),
d541 1
a541 1
   fprintf (optProbFile (), "Con ");
d545 1
a545 1
   fprintf (optProbFile (), " Low Bnd  Up Bnd   PS LB   PS UB\n");
d547 1
a547 1
   fprintf (optProbFile (), "Var ");
d551 1
a551 1
   fprintf (optProbFile (), "   Coeff\n");
d563 1
a563 1
   fprintf (optProbFile (),
d568 1
a568 1
   fprintf (optProbFile (), "Var ");
d572 1
a572 1
   fprintf (optProbFile (), "    Coeff\n");
d589 1
a589 1
   fprintf (optProbFile (),
d594 1
a594 1
   fprintf (optProbFile (), "\nColumn #      Elem #\n");
d597 1
a597 1
      fprintf (optProbFile (), "%8d  %8d\n", theIdx, firstCoeffIdx[theIdx]);
d599 1
a599 1
   fprintf (optProbFile (), "\n  Elem #     Row #    Coefficient\n");
d603 1
a603 1
         optProbFile (),
@


1.44
log
@App controlled opt implosion.
@
text
@d13 1
a13 3
// Implementation of the following classes:
//
//    OptModel.
d17 1
d20 1
a20 2
#include <OptImp.h>
#include <CoinSolver.h>
d25 1
a28 2
#ifdef OPT_IMPLODE

a39 41
WitOptModel::WitOptModel (WitOptImploder * theOptImploder):

      WitProbAssoc   (theOptImploder->myProblem ()),

      myOptImploder_ (theOptImploder),
      myCoinSolver_  (NULL),
      nCoeffs_       (0),
      curCon_        (NULL),
      curConCoeffs_  (myProblem ()),
      mainObj_       (NULL),
      modelFile_     (NULL)
   {
   myCoinSolver_ = new WitCoinSolver (this);
   }

//------------------------------------------------------------------------------

WitOptModel::~WitOptModel ()
   {
   int idx;

   delete myCoinSolver_;

   while (not myOptObjs_.isEmpty ())
      delete myOptObjs_.get ();

   while (not myOptCons_.isEmpty ())
      delete myOptCons_.get ();

   while (not myOptVars_.isEmpty ())
      delete myOptVars_.get ();

   for (idx = 0; idx < conPreScreenBounds_.length (); idx ++)
      delete conPreScreenBounds_[idx];

   for (idx = 0; idx < varPreScreenBounds_.length (); idx ++)
      delete varPreScreenBounds_[idx];
   }

//------------------------------------------------------------------------------

d73 2
d77 9
a85 4
      if (isaMIP ())
         myMsgFac () ("mipDimMsg", nOptVars (), nIntVars_);
      else
         myMsgFac () ("lpDimMsg", nOptVars ());
d87 2
a88 1
      myMsgFac () ("mpDimMsg", nOptCons (), nOptObjs (), nCoeffs ());
d139 5
a143 2
   generateBounds (
      reinterpret_cast <const WitList <WitModelEl> &> (myOptVars ()));
d145 2
a146 2
   generateBounds (
      reinterpret_cast <const WitList <WitModelEl> &> (myOptCons ()));
d149 2
d157 1
a157 1
   return varPreScreenBounds_ (theVar->index ());
d164 1
a164 1
   return conPreScreenBounds_ (theCon->index ());
d177 1
a177 1
   forEachEl (theVar, myOptVars ())
d185 4
a188 4
void WitOptModel::defMatrixByCols (
      WitVector <int> &    indexRow,
      WitVector <int> &    startOfEachColumn,
      WitVector <double> & elements)
d195 3
a197 3
   indexRow         .resize (nCoeffs_);
   startOfEachColumn.resize (nOptVars () + 1);
   elements         .resize (nCoeffs ());
d201 1
a201 1
   forEachEl (theVar, myOptVars ())
d203 1
a203 1
      startOfEachColumn[theVar->index ()] = idx;
d209 1
a209 1
         indexRow[idx] = theCoeff->myCon ()->index ();
d211 1
a211 1
         elements[idx] = theCoeff->myValue ();
d217 1
a217 1
   startOfEachColumn[nOptVars ()] = idx;
d230 1
a230 1
   modelFile_ = openFile (myOptImploder ()->modelOFName ().myCstring (), "w");
d232 1
a232 1
   myProblem ()->mySession ()->writeHeading (modelFile ());
d234 4
a237 4
   if (isaMIP ())
      fprintf (modelFile (),
         "Mixed Integer Programming Model\n"
         "===== ======= =========== =====\n\n\n");
d239 3
a241 3
      fprintf (modelFile (),
         "Linear Programming Model\n"
         "====== =========== =====\n\n\n");
d243 1
a243 1
   fprintf (modelFile (), "# Variables:    %8d\n",   nOptVars ());
d245 3
a247 3
   if (isaMIP ())
      fprintf (modelFile (), 
                          "# Integer Vars: %8d\n",   nIntVars_);
d249 3
a251 3
   fprintf (modelFile (), "# Constraints:  %8d\n",   nOptCons ());
   fprintf (modelFile (), "# Objectives:   %8d\n",   nOptObjs ());
   fprintf (modelFile (), "# Coefficients: %8d\n\n", nCoeffs ());
d253 1
a253 1
   fprintf (modelFile (), "Objective Function:  %s\n", mainObj ()->myText ());
d260 1
a260 1
   if (myOptImploder ()->printMatByCols ())
d263 1
a263 1
   fclose (modelFile ());
d265 1
a265 1
   modelFile_ = NULL;
d272 40
d314 6
d322 1
a322 1
   myCoinSolver_->solve ();
d360 1
a360 1
   forEachEl (theVar, myOptVars ())
d362 1
a362 1
      varPreScreenBounds_ [theVar->index ()] = new WitBoundPair;
d364 1
a364 1
      varPreScreenBounds_ (theVar->index ()) = theVar->bounds ();
d367 1
a367 1
   forEachEl (theCon, myOptCons ())
d369 1
a369 1
      conPreScreenBounds_ [theCon->index ()] = new WitBoundPair;
d371 1
a371 1
      conPreScreenBounds_ (theCon->index ()) = theCon->bounds ();
d377 1
a377 1
int WitOptModel::screen (const WitOptCon * theCon)
d433 1
a433 1
   forEachEl (curCon_, myOptCons ())
d459 1
a459 1
   forEachEl (theCon, myOptCons ())
d467 1
a467 1
   forEachEl (theVar, myOptVars ())
d480 1
a480 1
   forEachEl (theCon, myOptCons ())
d490 1
a490 1
   forEachEl (theVar, myOptVars ())
d505 1
a505 1
   forEachEl (theVar, myOptVars ())
a510 10
void WitOptModel::generateBounds (const WitList <WitModelEl> & theModelEls)
   {
   WitModelEl * theModelEl;

   forEachEl (theModelEl, theModelEls)
      theModelEl->compBounds ();
   }

//------------------------------------------------------------------------------

d515 1
a515 1
   fprintf (modelFile (),
d520 1
a520 1
   fprintf (modelFile (), "Var ");
d522 1
a522 1
   printModelElHeading ();
d524 1
a524 1
   fprintf (modelFile (), " I Obj Cff Low Bnd  Up Bnd   PS LB   PS UB\n");
d526 1
a526 1
   forEachEl (theVar, myOptVars ())
d536 1
a536 1
   fprintf (modelFile (),
d541 1
a541 1
   fprintf (modelFile (), "Con ");
d543 1
a543 1
   printModelElHeading ();
d545 1
a545 1
   fprintf (modelFile (), " Low Bnd  Up Bnd   PS LB   PS UB\n");
d547 1
a547 1
   fprintf (modelFile (), "Var ");
d549 1
a549 1
   printModelElHeading ();
d551 1
a551 1
   fprintf (modelFile (), "   Coeff\n");
d553 1
a553 1
   forEachEl (theCon, myOptCons ())
d563 1
a563 1
   fprintf (modelFile (),
d568 1
a568 1
   fprintf (modelFile (), "Var ");
d570 1
a570 1
   printModelElHeading ();
d572 1
a572 1
   fprintf (modelFile (), "   Coeff\n");
d582 3
a584 3
   WitVector <int>    indexRow;
   WitVector <int>    startOfEachColumn;
   WitVector <double> elements;
d587 1
a587 1
   defMatrixByCols (indexRow, startOfEachColumn, elements);
d589 1
a589 1
   fprintf (modelFile (),
d594 1
a594 1
   fprintf (modelFile (), "\nColumn #      Elem #\n");
d597 1
a597 1
      fprintf (modelFile (), "%8d  %8d\n", theIdx, startOfEachColumn[theIdx]);
d599 1
a599 1
   fprintf (modelFile (), "\n  Elem #     Row #    Coefficient\n");
d603 1
a603 1
         modelFile (),
d606 2
a607 2
         indexRow[theIdx],
         elements[theIdx]);
d616 1
a616 1
   forEachEl (theVar, myOptVars ())
a652 2

#endif // OPT_IMPLODE
@


1.43
log
@Updated the copyright date on all source files.
@
text
@@


1.42
log
@Added test in WIT for an LP variable whose lower bound exceeds its upper
bound.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.41
log
@Removed class OptSolver.
@
text
@d305 2
d607 11
@


1.40
log
@Removed some more OSL items.
@
text
@a15 1
//    OptSolver.
a21 1
#include <OptSolver.h>
d48 1
a48 1
      myOptSolver_   (NULL),
d55 1
a55 1
   buildOptSolver ();
d64 1
a64 1
   delete myOptSolver_;
d305 1
a305 1
   myOptSolver_->solve ();
a396 7
void WitOptModel::buildOptSolver ()
   {
   myOptSolver_ = new WitCoinSolver (this);
   }

//------------------------------------------------------------------------------

a635 17
//------------------------------------------------------------------------------
// Implementation of class OptSolver.
//------------------------------------------------------------------------------

WitOptSolver::~WitOptSolver ()
   {
   }

//------------------------------------------------------------------------------

WitOptSolver::WitOptSolver (WitOptModel * theOptModel):

      WitProbAssoc (theOptModel->myProblem ()),
      myOptModel_  (theOptModel)
   {
   }

@


1.39
log
@Removed some more OSL items.
@
text
@a654 7
bool WitOptSolver::coinMode ()
   {
   return true;
   }

//------------------------------------------------------------------------------

@


1.38
log
@Removed class OslSolver.
@
text
@d257 1
a257 1
void WitOptModel::print (bool printOslVecs)
d293 1
a293 1
   if (printOslVecs)
@


1.37
log
@[shared-resource pegging]
@
text
@a23 1
#include <OslSolver.h>
a398 2
#ifdef COIN_BUILD

a403 9
#else

void WitOptModel::buildOptSolver ()
   {
   myOptSolver_ = new WitOslSolver (this);
   }

#endif // COIN_BUILD

a654 2
#ifdef COIN_BUILD

a659 9
#else

bool WitOptSolver::coinMode ()
   {
   return false;
   }

#endif // COIN_BUILD

@


1.36
log
@[shared-resource pegging]
@
text
@d224 1
d239 3
a241 1
      forEachElDense (theCoeff, theVar->myCoeffs ())
d365 3
a367 1
   int nVarsFixed = 0;
d369 1
a369 1
   WitCoeff * theCoeff;
d377 3
a379 1
   forEachElDense (theCoeff, theCon->myCoeffs ())
d456 1
d464 4
a467 1
      forEachElDense (theCoeff, theCon->myCoeffs ())
d469 1
d481 1
d486 3
a488 1
      forEachElDense (theCoeff, theCon->myCoeffs ())
d495 4
a498 1
      forEachElDense (theCoeff, theVar->myCoeffs ())
d500 1
@


1.35
log
@[shared-resource pegging]
@
text
@d54 1
d169 3
a171 1
   curConCoeffs_.append (theCoeff);
a427 1
   curConCoeffs_.resize (nOptVars () + 1);
a431 2
      curConCoeffs_.clear ();

a433 2
      nCoeffs_ += curConCoeffs_.nElements ();

d436 1
a436 1
      forEachElDense (theCoeff, curConCoeffs_)
a439 1
   curConCoeffs_.resize (0);
@


1.34
log
@[shared-resource pegging]
@
text
@d443 1
a443 1
   varLastCoeff_.clear ();
@


1.33
log
@[shared-resource pegging]
@
text
@d64 1
a64 1
   WitSiz idx;
@


1.32
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d64 1
a64 1
   size_t idx;
@


1.31
log
@[multi-thread]
@
text
@d258 1
a258 1
   modelFile_ = openFile (myOptImploder ()->modelOFName (), "w");
@


1.30
log
@[multi-thread]
@
text
@a38 4
FILE * WitOptModel::modelFile_ = NULL;

//------------------------------------------------------------------------------

d54 2
a55 1
      mainObj_       (NULL)
@


1.29
log
@[multi-thread]
@
text
@d52 2
a54 2
      myProblem_     (theOptImploder->myProblem ()),
      myMsgFac_      (theOptImploder->myMsgFac ()),
@


1.28
log
@Made opt implosion use COIN unconditionally when COIN_BUILD is defined.
@
text
@d654 18
@


1.27
log
@Added "solverIsCoin" attribute.
@
text
@d393 2
d397 1
a397 4
   if (myOptImploder_->myOptComp ()->solverIsCoin ())
      myOptSolver_ = new WitCoinSolver (this);
   else
      myOptSolver_ = new WitOslSolver (this);
d400 9
@


1.26
log
@Double Precision.
@
text
@d395 1
a395 1
   if (myOptImploder_->myOptComp ()->optWithCoin ())
@


1.25
log
@Double Precision.
@
text
@d347 1
a347 1
      varPreScreenBounds_ (theVar->index ()).copy (theVar->bounds ());
d354 1
a354 1
      conPreScreenBounds_ (theCon->index ()).copy (theCon->bounds ());
@


1.24
log
@Double Precision.
@
text
@d150 1
a150 1
void WitOptModel::incCoeff (WitOptVar * theVar, float delta)
d242 1
a242 1
         elements[idx] = dblFromFlt (theCoeff->myValue ());
@


1.23
log
@Continued double precision.
@
text
@d242 1
a242 1
         elements[idx] = doubleFromFloat (theCoeff->myValue ());
@


1.22
log
@Continued implementation of opt with COIN.
@
text
@d242 1
a242 1
         elements[idx] = static_cast <double> (theCoeff->myValue ());
@


1.21
log
@Continued implementation of opt with COIN.
@
text
@a18 5
int compiledOptModel = 1;
   //
   // WATCOM's strict compatibility mode requires every file to
   // have at least one external definition.

d24 1
a24 1
#include <OslMgr.h>
d398 1
a398 1
      myOptSolver_ = new WitOslMgr (this);
@


1.20
log
@Continued implementation of opt with COIN.
@
text
@d30 1
a30 1
#include <ClpOsiSolver.h>
d401 1
a401 1
      myOptSolver_ = new WitClpOsiSolver (this);
@


1.19
log
@Continued implementation of opt with COIN.
@
text
@d400 1
a400 8
   WitOptSolveMethod theOptSolveMethod;

   theOptSolveMethod = myOptImploder_->myOptComp ()->myOptSolveMethod ();

   if (theOptSolveMethod == oslDirMethod)
      myOptSolver_ = new WitOslMgr (this);

   else if (theOptSolveMethod == clpOsiMethod)
a401 1

d403 1
a403 1
      stronglyAssert (false);
@


1.18
log
@Continued implementation of opt with COIN.
@
text
@a29 1
#include <OslOsiSolver.h>
a405 3

   else if (theOptSolveMethod == oslOsiMethod)
      myOptSolver_ = new WitOslOsiSolver (this);
@


1.17
log
@Continued implementation of opt with COIN.
@
text
@d31 1
a31 1
#include <ClpSolver.h>
d411 2
a412 2
   else if (theOptSolveMethod == clpMethod)
      myOptSolver_ = new WitClpSolver (this);
@


1.16
log
@Continued implementation of opt with COIN.
@
text
@d30 1
a30 1
#include <OsiOslSolver.h>
a233 2
   WitTimer::enterSection ("model");

a256 2

   WitTimer::leaveSection ("model");
d405 1
a405 1
   if (theOptSolveMethod == dirOslMethod)
d408 2
a409 2
   else if (theOptSolveMethod == osiOslMethod)
      myOptSolver_ = new WitOsiOslSolver (this);
@


1.15
log
@Continued implementation of opt with COIN.
@
text
@a16 2
//
// Contains the dummy implementation of class OsiOslSolver.
d31 1
d34 1
a34 1
#include <Global.h>
d66 1
a66 4
   if (myOptImploder_->myGlobalComp ()->useCoin ())
      myOptSolver_ = new WitOsiOslSolver (this);
   else
      myOptSolver_ = new WitOslMgr       (this);
d403 21
d669 2
a670 23
      myOptModel_    (theOptModel),
      myOptImploder_ (theOptModel->myOptImploder ()),
      myMsgFac_      (theOptModel->myMsgFac ())
   {
   }

//------------------------------------------------------------------------------
// Dummy implementation of class OsiOslSolver.
//
// See OsiOslSolverI.h for the main implementation.
//------------------------------------------------------------------------------

#if ! USE_COIN

//------------------------------------------------------------------------------

WitOsiOslSolver::WitOsiOslSolver (WitOptModel * theOptModel):

      WitOptSolver      (theOptModel),

      mySolverInter_    (NULL),
      retVal_           (0),
      presolveFileName_ ()
a671 1
   myMsgFac () ("coinNYAvailSmsg");
a672 16

//------------------------------------------------------------------------------

WitOsiOslSolver::~WitOsiOslSolver ()
   {
   }

//------------------------------------------------------------------------------

void WitOsiOslSolver::solve ()
   {
   }

//------------------------------------------------------------------------------

#endif // Not USE_COIN
@


1.14
log
@Continued implementation of opt with COIN.
@
text
@d18 1
a18 1
// Contains the dummy implementation of class CoinSolver.
d32 1
a32 1
#include <CoinSolver.h>
d68 1
a68 1
      myOptSolver_ = new WitCoinSolver (this);
d70 1
a70 1
      myOptSolver_ = new WitOslMgr     (this);
d659 1
a659 1
// Dummy implementation of class CoinSolver.
d661 1
a661 1
// See CoinSolver.C for the main implementation.
d668 1
a668 1
WitCoinSolver::WitCoinSolver (WitOptModel * theOptModel):
d681 1
a681 1
WitCoinSolver::~WitCoinSolver ()
d687 1
a687 1
void WitCoinSolver::solve ()
@


1.13
log
@Continued implementation of opt with COIN.
@
text
@a316 14
void WitOptModel::getInitSoln (double * colsol)
   {
   WitOptVar * theVar;

   WitTimer::enterSection ("model");

   forEachEl (theVar, myOptVars ())
      colsol[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("model");
   }

//------------------------------------------------------------------------------

@


1.12
log
@Continued implementation of opt with COIN.
Modified appl.mk to facilitate linking WIT to COIN.
@
text
@d222 1
a222 1
      theVar->primalValue () = theVar->indepInitValue ();
d238 1
a238 1
   WitTimingEvent theEvent ("model");
d263 2
d271 1
a271 1
   WitTimingEvent theEvent ("extra");
d311 2
d321 1
a321 1
   WitTimingEvent theEvent ("model");
a324 1
   }
d326 1
a326 22
//------------------------------------------------------------------------------

void WitOptModel::storePrimalSoln (const double * colsol)
   {
   WitOptVar * theVar;

   WitTimingEvent theEvent ("model");

   forEachEl (theVar, myOptVars ())
      theVar->primalValue () = colsol[theVar->index ()];
   }

//------------------------------------------------------------------------------

void WitOptModel::storeDualSoln (const double * rowduals)
   {
   WitOptCon * theCon;

   WitTimingEvent theEvent ("model");

   forEachEl (theCon, myOptCons ())
      theCon->dualValue () = - rowduals[theCon->index ()];
d625 1
d627 4
a630 2
   double  redReward;
   int     nElim = 0;
d634 1
a634 1
      theCoeff = screenedCoeffs_.get ();
d640 5
a644 1
         theCoeff->myCon ()->dualValue () += redReward / theCoeff->myValue ();
@


1.11
log
@Continued implementation of opt with Coin.
@
text
@d17 2
a66 4
   myOptSolver_ = new WitOslMgr (this);

#if 0

a70 2

#endif
d683 38
a720 1
#endif
@


1.10
log
@changes to compile with coin
@
text
@d65 7
a71 3
   //if (myOptImploder_->myGlobalComp ()->useCoin ())
      //myOptSolver_ = new WitCoinSolver (this);
   //else
d73 3
a75 1
  }
d233 1
a233 1
void WitOptModel::generateOslVectors (
d308 1
a308 1
      printOslVectors ();
a316 61
void WitOptModel::getConLBs (WitVector <double> & theConLBvec)
   {
   WitOptCon * theOptCon;

   WitTimingEvent theEvent ("model");

   forEachEl (theOptCon, myOptCons_)
      theConLBvec[theOptCon->index ()] = theOptCon->bounds ().lower ();
   }

//------------------------------------------------------------------------------

void WitOptModel::getConUBs (WitVector <double> & theConUBvec)
   {
   WitOptCon * theOptCon;

   WitTimingEvent theEvent ("model");

   forEachEl (theOptCon, myOptCons_)
      theConUBvec[theOptCon->index ()] = theOptCon->bounds ().upper ();
   }

//------------------------------------------------------------------------------

void WitOptModel::getVarLBs (WitVector <double> & theVarLBvec)
   {
   WitOptVar * theOptVar;

   WitTimingEvent theEvent ("model");

   forEachEl (theOptVar, myOptVars_)
      theVarLBvec[theOptVar->index ()] = theOptVar->bounds ().lower ();
   }

//------------------------------------------------------------------------------

void WitOptModel::getVarUBs (WitVector <double> & theVarUBvec)
   {
   WitOptVar * theOptVar;

   WitTimingEvent theEvent ("model");

   forEachEl (theOptVar, myOptVars_)
      theVarUBvec[theOptVar->index ()] = theOptVar->bounds ().upper ();
   }

//------------------------------------------------------------------------------

void WitOptModel::getObjCoeffs (WitVector <double> & theObjCoeffVec)
   {
   WitOptVar * theOptVar;

   WitTimingEvent theEvent ("model");

   forEachEl (theOptVar, myOptVars_)
      theObjCoeffVec[theOptVar->index ()] =
         static_cast <double> (theOptVar->mainObjCoeffVal ());
   }

//------------------------------------------------------------------------------

d613 1
a613 1
void WitOptModel::printOslVectors ()
d620 1
a620 1
   generateOslVectors (indexRow, startOfEachColumn, elements);
d622 4
a625 2
   fprintf (modelFile (), "\n\n\nOSL Vectors\n"
                             "=== =======\n\n");
@


1.9
log
@Continued implementation of opt with COIN.
@
text
@d65 3
a67 3
   if (myOptImploder_->myGlobalComp ()->useCoin ())
      myOptSolver_ = new WitCoinSolver (this);
   else
d69 1
a69 1
   }
@


1.8
log
@Continued implementation of opt with COIN.
@
text
@a24 1
#include <OptSolver.h>
d28 1
d30 1
d33 1
d65 4
a68 1
   myOptSolver_ = new WitOslMgr (this);
@


1.7
log
@Changed some C style casts to C++ style.
@
text
@d13 4
a16 1
// Implementation of class OptModel.
d25 1
d39 2
d58 1
d63 1
a63 1
   myOslMgr_ = new WitOslMgr (this);
d72 1
a72 1
   delete myOslMgr_;
d405 1
a405 1
   myOslMgr_->solve ();
d715 18
@


1.6
log
@Internal changes.
@
text
@d174 2
a175 1
   generateBounds ((const WitList <WitModelEl> &) myOptVars ());
d177 2
a178 1
   generateBounds ((const WitList <WitModelEl> &) myOptCons ());
d239 2
a240 1
         elements[idx] = (double) theCoeff->myValue ();
d355 1
a355 1
         (double) theOptVar->mainObjCoeffVal ();
@


1.5
log
@Internal changes.
@
text
@d67 1
a67 1
   while (!  myOptObjs_.isEmpty ())
d70 1
a70 1
   while (!  myOptCons_.isEmpty ())
d73 1
a73 1
   while (!  myOptVars_.isEmpty ())
d459 1
a459 1
   if (! theCon->screenable ())
d689 1
a689 1
   while (! screenedCoeffs_.isEmpty ())
@


1.4
log
@modications to change rogueWave tools.h++ to STL
@
text
@d250 1
a250 1
void WitOptModel::print (WitBoolean printOslVecs)
@


1.3
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d63 1
a63 1
   int idx;
@


1.3.2.1
log
@Migration from Roguewave tools.h++ to STL
@
text
@d63 1
a63 1
   size_t idx;
@


1.2
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d70 2
a71 2
   while (!  myOptObjs_.isEmpty ())
      delete myOptObjs_.get ();
@


1.1
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a20 1
#include <Session.h>
d22 2
d26 2
d30 1
d40 7
d179 14
@


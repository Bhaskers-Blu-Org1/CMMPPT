head	1.44;
access;
symbols
	sce_4_05_20040511:1.43
	sce_4_00_20040201:1.43
	nextGenBranch:1.41.0.2
	nextGenRoot:1.41
	sce_3_30_20030627:1.41
	EndRw-branch:1.35.0.4
	Root-of-EndRw:1.35
	rwToStl:1.35.0.2
	latest_sce_3_10_20010924:1.17.0.2
	sce_3_10_20010924:1.17
	latest_sce_3_00_20010601:1.13.0.2
	sce_3_00_20010601:1.13
	latest_sce_2_31_20010308:1.12.0.2
	sce_2_31_20010308:1.12
	latest_sce_2_31_20001003:1.8.0.2
	sce_2_31_20001003:1.8
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2005.01.19.23.50.57;	author rjw;	state dead;
branches;
next	1.43;

1.43
date	2003.11.11.18.29.12;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.19.16.48.16;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.14.20.12.55;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.02.23.40.39;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.02.22.18.25;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.30.21.57.24;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.30.20.37.25;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.09.19.52.31;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.06.18.53.36;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.05.21.19.58;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.10.18.02.10;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.07.20.14.55;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.22.14.32.07;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.18.14.02.31;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.15.21.21.35;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.05.20.43.56;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.28.00.08.12;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.20.22.28.06;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.07.16.57.28;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.21.21.55.16;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.14.23.56.07;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.10.22.06.53;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.28.18.09.14;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.27.23.15.37;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.28.00.12.57;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.19.18.50.56;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.12.21.19.50;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.14.20.43.53;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.25.16.08.14;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.26.20.28.06;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.20.00.44.16;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.15.19.01.49;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.11.16.35.08;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.28.22.13.35;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.08.21.56.11;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.24.19.55.21;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.21.17.42.48;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.19.22.35.29;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.01.00.35.42;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.16.33.07;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.45;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Low-Pri Prop-Rt.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "ExpRest.C"
//
// Contains the implementation of class ExpRest.
//------------------------------------------------------------------------------

#include <ExpRest.h>
#include <HeurAtor.h>
#include <Repos.h>
#include <Material.h>
#include <BopEntry.h>
#include <MsgFac.h>
#include <MapIdxI.h>

//------------------------------------------------------------------------------
// Implementation of class ExpRest.
//------------------------------------------------------------------------------

WitExpRest::WitExpRest (WitHeurAtor * theHeurAtor):
      WitProbAssoc       (theHeurAtor->myProblem ()),

      myHeurAtor_        (theHeurAtor),
      hasPosPenalty_     (myProblem (), false),
      hasPseudoSup_      (),
      curExhaustReqs_    (myProblem ()),
      failExhaustReqs_   (myProblem ()),
      curFundShort_      (false),
      failRestShortOnly_ (false),
      repReqs_           (myProblem ()),
      unanReqs_          (myProblem (), false),
      unanReqsPairs_     (myProblem ()),
      unanByConsEntNet_  (false),
      tempMode_          (false),
      psSupRepos_        (NULL)
   {
   WitPart * thePart;

   findPosPenalties ();

   hasPseudoSup_.allocate1D (myProblem ());

   psSupRepos_ = new WitDataRepos (myProblem ());
   
   forEachPart (thePart, myProblem ())
      init (thePart);
   }

//------------------------------------------------------------------------------

WitExpRest::~WitExpRest ()
   {
   delete psSupRepos_;
   }

//------------------------------------------------------------------------------

void WitExpRest::placeReqs (
      WitPart * srcPart,
      WitPeriod srcPer,
      WitPart * reqPart,
      WitPeriod reqPer)
   {
   if (unanReqs_ (srcPart)[srcPer] or unanByConsEntNet_)
      setUnanReqs (reqPart, reqPer);
   }

//------------------------------------------------------------------------------

void WitExpRest::recExpBeyondNet (
      WitPart *  thePart, 
      WitPeriod  thePer, 
      bool       netForConsEnt)
   {
   if (not hasPseudoSup (thePart, thePer))
      return;

   curExhaustReqs_.push (thePart, thePer);

   if (netForConsEnt)
      unanByConsEntNet_ = true;
   else
      setUnanReqs (thePart, thePer);
   }

//------------------------------------------------------------------------------

void WitExpRest::postExpBomEnt ()
   {
   unanByConsEntNet_ = false;
   }

//------------------------------------------------------------------------------

bool WitExpRest::restExpAllowed (
      WitBopEntry * theBopEnt, 
      WitPeriod     fillPer)
   {
   if (hasPosPenalty_ (theBopEnt->myOperation ()))
      if (unanReqs_ (theBopEnt->myPart ())[fillPer])
         return false;

   return true;
   }

//------------------------------------------------------------------------------

void WitExpRest::recordFundShortage ()
   {
   stronglyAssert (not curFundShort_);

   curFundShort_ = true;
   }

//------------------------------------------------------------------------------

void WitExpRest::reqPsSupRep (WitPart * thePart, WitPeriod thePer)
   {
   repReqs_.push (thePart, thePer);
   }

//------------------------------------------------------------------------------

void WitExpRest::postTempCommit (bool success)
   {
   WitPart * thePart;
   WitPeriod thePer;

   if (success)
      curExhaustReqs_.clear ();
   else
      {
      failExhaustReqs_.takeContents (curExhaustReqs_);

      failRestShortOnly_ = not curFundShort_;

      while (unanReqsPairs_.pop (thePart, thePer))
         unanReqs_ (thePart)[thePer] = false;
      }

   curFundShort_ = false;
   }

//------------------------------------------------------------------------------

void WitExpRest::updatePsSup ()
   {
   WitPairStItr <WitPart, WitPeriod> theItr;
   WitPart *                         thePart;
   WitPeriod                         fillPer;
   WitMaterial *                     theMat;

   theItr.attachTo (failExhaustReqs_);

   while (theItr.advance (thePart, fillPer))
      {
      if (not hasPseudoSup_ (thePart)[fillPer])
         continue;

      exhaustPsSup (thePart, fillPer);

      printExhRepAsNeeded (thePart, fillPer, true);

      theMat = thePart->thisMat ();

      if (theMat != NULL)
         exhaustOtherPers (theMat, fillPer);
      }

   if (not tempMode_)
      {
      failExhaustReqs_.clear ();

      failRestShortOnly_ = false;
      }
   }

//------------------------------------------------------------------------------

void WitExpRest::startTempMode ()
   {
   stronglyAssert (not tempMode_);

   tempMode_ = true;
   }

//------------------------------------------------------------------------------

void WitExpRest::finishTempMode ()
   {
   stronglyAssert (tempMode_);

   psSupRepos_->restore ();

   tempMode_ = false;
   }

//------------------------------------------------------------------------------

void WitExpRest::replenishPsSups ()
   {
   WitPart * thePart;
   WitPeriod reqPer;
   WitPeriod thePer;

   while (repReqs_.pop (thePart, reqPer))
      {
      if (not myHeurAtor_->incAvailPos (thePart, reqPer))
         continue;

      if (not hasPseudoSup_ (thePart).isAllocated ())
         hasPseudoSup_ (thePart).allocate (myProblem (), false);

      for (thePer = reqPer; thePer < nPeriods (); thePer ++)
         {
         if (hasPseudoSup_ (thePart)[thePer])
            break;

         hasPseudoSup_ (thePart)[thePer] = true;

         printExhRepAsNeeded (thePart, thePer, (thePer == reqPer));

         if (not thePart->canStock (thePer))
            break;
         }
      }
   }

//------------------------------------------------------------------------------

void WitExpRest::print ()
   {
   WitPart * thePart;
   WitPeriod thePer;

   fprintf (msgFile (), 
      "\n"
      "Parts and Periods with Pseudo-Supply:\n\n");

   forEachPart (thePart, myProblem ())
      if (hasPseudoSup_ (thePart).isAllocated ())
         forEachPeriod (thePer, myProblem ())
            if (hasPseudoSup_ (thePart)[thePer])
               fprintf (msgFile (), 
                  "   Part %s, Per %d\n", 
                  thePart->partName ().myCstring (),
                  thePer);
   }

//------------------------------------------------------------------------------

void WitExpRest::exhaustOtherPers (WitMaterial * theMat, WitPeriod fillPer)
   {
   WitPeriod thePer;

   for (thePer = fillPer - 1; thePer >= 0; thePer --)
      {
      if (theMat->mandEC ()[thePer])
         break;

      if (not hasPseudoSup_ (theMat)[thePer])
         break;

      exhaustPsSup (theMat, thePer);

      printExhRepAsNeeded (theMat, thePer, false);
      }

   for (thePer = fillPer + 1; thePer < nPeriods (); thePer ++)
      {
      if (theMat->mandEC ()[thePer - 1])
         break;

      if (theMat->supplyVol ()[thePer] > NET_TOL)
         break;

      exhaustPsSup (theMat, thePer);

      printExhRepAsNeeded (theMat, thePer, false);
      }
   }

//------------------------------------------------------------------------------

void WitExpRest::exhaustPsSup (WitPart * thePart, WitPeriod thePer)
   {
   if (tempMode_)
      psSupRepos_->saveVal (hasPseudoSup_ (thePart)[thePer]);

   hasPseudoSup_ (thePart)[thePer] = false;
   }

//------------------------------------------------------------------------------

void WitExpRest::setUnanReqs (WitPart * thePart, WitPeriod thePer)
   {
   if (unanReqs_ (thePart)[thePer])
      return;

   unanReqs_ (thePart)[thePer] = true;

   unanReqsPairs_.push (thePart, thePer);
   }

//------------------------------------------------------------------------------

void WitExpRest::findPosPenalties ()
   {
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->execPenalty () > 0.0)
         hasPosPenalty_ (theOpn) = true;

   forEachBomEntry (theBomEnt, myProblem ())
      if (theBomEnt->execPenalty () > 0.0)
         hasPosPenalty_ (theBomEnt->myOperation ()) = true;

   forEachSubEntry (theSub, myProblem ())
      if (theSub->execPenalty () > 0.0)
         hasPosPenalty_ (theSub->myOperation ()) = true;
   }

//------------------------------------------------------------------------------
// init
//
// carryOver: true, iff supply from an earlier period carries over to the 
//            current period.
//------------------------------------------------------------------------------

void WitExpRest::init (WitPart * thePart)
   {
   WitPeriod fillPer;
   bool      carryOver;

   carryOver = false;

   forEachPeriod (fillPer, myProblem ())
      {
      if (not carryOver)
         if (thePart->supplyVol ()[fillPer] <= NET_TOL)
            continue;

      if (not hasPseudoSup_ (thePart).isAllocated ())
         hasPseudoSup_ (thePart).allocate (myProblem (), false);

      hasPseudoSup_ (thePart)[fillPer] = true;

      carryOver = thePart->canStock (fillPer);
      }
   }

//------------------------------------------------------------------------------

void WitExpRest::printExhRep (
      WitPart * thePart, 
      WitPeriod fillPer, 
      bool      firstPer)
   {
   const char * changeText;

   if (tempMode_)
      return;

   changeText = 
      hasPseudoSup (thePart, fillPer)?
         "replenished":
         "exhausted";

   if (firstPer)
      fprintf (msgFile (), "\n");

   fprintf (msgFile (), 
      "Pseudo-supply %s for part %s in period %d.\n",
      changeText,
      thePart->partName ().myCstring (),
      fillPer);
   }
@


1.43
log
@Removed a bad function overload.
@
text
@@


1.42
log
@Continued implementation of post-implosion pegging.
@
text
@d172 1
a172 1
      theMat = thePart->myMat ();
@


1.41
log
@Continued implementation of proportionate routing.
@
text
@a20 1
#include <ScheduleI.h>
d22 1
@


1.40
log
@Continued implementation of proportionate routing.
@
text
@d172 1
a172 1
      thePart->getMaterial (theMat);
@


1.39
log
@Internal changes.
@
text
@d29 1
a29 1
      WitProbAssoc       (theHeurAtor),
@


1.38
log
@Internal changes.
@
text
@d72 1
a72 1
   if (unanReqs_ (srcPart)[srcPer] || unanByConsEntNet_)
d83 1
a83 1
   if (! hasPseudoSup (thePart, thePer))
d118 1
a118 1
   stronglyAssert (! curFundShort_);
d143 1
a143 1
      failRestShortOnly_ = ! curFundShort_;
d165 1
a165 1
      if (! hasPseudoSup_ (thePart)[fillPer])
d178 1
a178 1
   if (! tempMode_)
d190 1
a190 1
   stronglyAssert (! tempMode_);
d216 1
a216 1
      if (! myHeurAtor_->incAvailPos (thePart, reqPer))
d219 1
a219 1
      if (! hasPseudoSup_ (thePart).isAllocated ())
d231 1
a231 1
         if (! thePart->canStock (thePer))
d269 1
a269 1
      if (! hasPseudoSup_ (theMat)[thePer])
d350 1
a350 1
      if (! carryOver)
d354 1
a354 1
      if (! hasPseudoSup_ (thePart).isAllocated ())
@


1.37
log
@Continued implementation of execPenalties on BOM entries and subs.
@
text
@d32 1
a32 1
      hasPosPenalty_     (myProblem (), witFALSE),
d36 2
a37 2
      curFundShort_      (witFALSE),
      failRestShortOnly_ (witFALSE),
d39 1
a39 1
      unanReqs_          (myProblem (), witFALSE),
d41 2
a42 2
      unanByConsEntNet_  (witFALSE),
      tempMode_          (witFALSE),
d81 1
a81 1
      WitBoolean netForConsEnt)
d89 1
a89 1
      unanByConsEntNet_ = witTRUE;
d98 1
a98 1
   unanByConsEntNet_ = witFALSE;
d103 1
a103 1
WitBoolean WitExpRest::restExpAllowed (
d109 1
a109 1
         return witFALSE;
d111 1
a111 1
   return witTRUE;
d120 1
a120 1
   curFundShort_ = witTRUE;
d132 1
a132 1
void WitExpRest::postTempCommit (WitBoolean success)
d146 1
a146 1
         unanReqs_ (thePart)[thePer] = witFALSE;
d149 1
a149 1
   curFundShort_ = witFALSE;
d170 1
a170 1
      printExhRepAsNeeded (thePart, fillPer, witTRUE);
d182 1
a182 1
      failRestShortOnly_ = witFALSE;
d192 1
a192 1
   tempMode_ = witTRUE;
d203 1
a203 1
   tempMode_ = witFALSE;
d220 1
a220 1
         hasPseudoSup_ (thePart).allocate (myProblem (), witFALSE);
d227 1
a227 1
         hasPseudoSup_ (thePart)[thePer] = witTRUE;
d274 1
a274 1
      printExhRepAsNeeded (theMat, thePer, witFALSE);
d287 1
a287 1
      printExhRepAsNeeded (theMat, thePer, witFALSE);
d298 1
a298 1
   hasPseudoSup_ (thePart)[thePer] = witFALSE;
d308 1
a308 1
   unanReqs_ (thePart)[thePer] = witTRUE;
d323 1
a323 1
         hasPosPenalty_ (theOpn) = witTRUE;
d327 1
a327 1
         hasPosPenalty_ (theBomEnt->myOperation ()) = witTRUE;
d331 1
a331 1
         hasPosPenalty_ (theSub->myOperation ()) = witTRUE;
d337 1
a337 1
// carryOver: TRUE, iff supply from an earlier period carries over to the 
d343 2
a344 2
   WitPeriod  fillPer;
   WitBoolean carryOver;
d346 1
a346 1
   carryOver = witFALSE;
d355 1
a355 1
         hasPseudoSup_ (thePart).allocate (myProblem (), witFALSE);
d357 1
a357 1
      hasPseudoSup_ (thePart)[fillPer] = witTRUE;
d366 3
a368 3
      WitPart *  thePart, 
      WitPeriod  fillPer, 
      WitBoolean firstPer)
@


1.36
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d326 1
a326 1
      if (theBomEnt->usePenalty () > 0.0)
d330 1
a330 1
      if (theSub->usePenalty () > 0.0)
@


1.35
log
@Continued implementation of single-source.
@
text
@d32 1
d47 2
d107 1
a107 1
   if (theBopEnt->myOperation ()->execPenalty () > 0.0)
d311 21
@


1.34
log
@Continued implementation of Single-Source.
@
text
@d42 1
a42 1
      psSupRepos_        (* new WitDataRepos (myProblem ()))
d47 2
d58 1
a58 1
   delete & psSupRepos_;
d198 1
a198 1
   psSupRepos_.restore ();
d293 1
a293 1
      psSupRepos_.saveVal (hasPseudoSup_ (thePart)[thePer]);
@


1.33
log
@Continued implementation of single-source.
@
text
@d21 1
@


1.32
log
@Continued implementation of single source.
@
text
@d66 1
a66 1
   if (unanReqs_ (srcPart, srcPer) || unanByConsEntNet_)
d102 1
a102 1
      if (unanReqs_ (theBopEnt->myPart (), fillPer))
d140 1
a140 1
         unanReqs_ (thePart, thePer) = witFALSE;
d159 1
a159 1
      if (! hasPseudoSup_ (thePart, fillPer))
d218 1
a218 1
         if (hasPseudoSup_ (thePart, thePer))
d221 1
a221 1
         hasPseudoSup_ (thePart, thePer) = witTRUE;
d245 1
a245 1
            if (hasPseudoSup_ (thePart, thePer))
d263 1
a263 1
      if (! hasPseudoSup_ (theMat, thePer))
d290 1
a290 1
      psSupRepos_.saveVal (hasPseudoSup_ (thePart, thePer));
d292 1
a292 1
   hasPseudoSup_ (thePart, thePer) = witFALSE;
d299 1
a299 1
   if (unanReqs_ (thePart, thePer))
d302 1
a302 1
   unanReqs_ (thePart, thePer) = witTRUE;
d330 1
a330 1
      hasPseudoSup_ (thePart, fillPer) = witTRUE;
@


1.31
log
@Continued preliminary work on single source.
@
text
@d18 1
a18 1
#include <Archive.h>
d41 1
a41 1
      psSupArch_         (NULL)
a48 2

   psSupArch_ = new WitArchive <WitBoolean> (myProblem ());
d55 1
a55 1
   delete psSupArch_;
d195 1
a195 1
   psSupArch_->restore ();
d290 1
a290 1
      psSupArch_->saveVal (hasPseudoSup_ (thePart, thePer));
@


1.30
log
@Continued implementation of object iteration.
@
text
@d19 2
@


1.29
log
@Began implementation of object iteration.
@
text
@d166 1
a166 1
      theMat = thePart->myMat ();
@


1.28
log
@Continued implementation of sel-split for pen-exec.
@
text
@d19 1
@


1.27
log
@Continued implementation of sel-split for pen-exec.
@
text
@d194 1
a194 1
   psSupArch_->restoreAllVals ();
@


1.26
log
@Continued implementation of sel-split for pen-exec.
@
text
@d111 1
a111 1
   witAssert (! curFundShort_);
d183 1
a183 1
   witAssert (! tempMode_);
d192 1
a192 1
   witAssert (tempMode_);
@


1.25
log
@Continued implementation of sel-split for pen-exec.
@
text
@a148 14
   updatePsSup (failExhaustReqs_);

   if (! tempMode_)
      {
      failExhaustReqs_.clear ();

      failRestShortOnly_ = witFALSE;
      }
   }

//------------------------------------------------------------------------------

void WitExpRest::updatePsSup (const WitPartPerStack & theExhPts)
   {
d154 1
a154 1
   theItr.attachTo (theExhPts);
d169 7
@


1.24
log
@Continued implementation of sel-split for pen-exec.
@
text
@d149 14
d168 1
a168 1
   theItr.attachTo (failExhaustReqs_);
a182 7
      }

   if (! tempMode_)
      {
      failExhaustReqs_.clear ();

      failRestShortOnly_ = witFALSE;
@


1.23
log
@Continued implementation of pen-exec for sel-split.
@
text
@d147 1
a147 1
void WitExpRest::updatePsSup (WitBoolean forFailCom)
d154 1
a154 4
   if (forFailCom)
      theItr.attachTo (failExhaustReqs_);
   else
      theItr.attachTo (curExhaustReqs_);
a172 2
      witAssert (forFailCom);

@


1.22
log
@Continued implementation of sel-split for pen-exec.
@
text
@d349 3
@


1.21
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d147 1
a147 1
void WitExpRest::updatePsSup ()
d154 4
a157 1
   theItr.attachTo (failExhaustReqs_);
d176 2
@


1.20
log
@More improvements to pen-exec.
@
text
@d18 1
d36 3
a38 1
      unanByConsEntNet_  (witFALSE)
d46 2
d54 1
d147 1
a147 1
WitBoolean WitExpRest::updatePsSup ()
d149 6
a154 4
   WitPart *     thePart;
   WitPeriod     fillPer;
   WitMaterial * theMat;
   WitBoolean    restShortOnly;
d156 1
a156 1
   while (failExhaustReqs_.pop (thePart, fillPer))
d161 1
a161 1
      hasPseudoSup_ (thePart, fillPer) = witFALSE;
d171 24
a194 2
   restShortOnly      = failRestShortOnly_;
   failRestShortOnly_ = witFALSE;
d196 1
a196 1
   return restShortOnly;
a256 2
   WitTVec (WitBoolean) & barredVec = hasPseudoSup_ (theMat);

d262 1
a262 1
      if (! barredVec[thePer])
d265 1
a265 1
      barredVec[thePer] = witFALSE;
d278 1
a278 1
      barredVec[thePer] = witFALSE;
d282 10
@


1.19
log
@Added allowSSPE dev param.
Switched pen-exec to single-shortage logic.
Made pen-exec exploit sparse penalties.
@
text
@d35 1
a35 1
      unanNetting_       (witFALSE)
d59 1
a59 1
   if (unanReqs_ (srcPart, srcPer) || unanNetting_)
d65 4
a68 4
void WitExpRest::recRestExp (
      WitPart *    thePart, 
      WitPeriod    fillPer, 
      WitBoolean & restExpOK)
d70 1
a70 3
   restExpOK = ! hasPseudoSup (thePart, fillPer);

   if (restExpOK)
d73 1
a73 1
   curExhaustReqs_.push (thePart, fillPer);
d75 4
a78 1
   setUnanReqs (thePart, fillPer);
d83 1
a83 1
void WitExpRest::recRestNet (WitPart * thePart, WitPeriod fillPer)
d85 1
a85 6
   if (! hasPseudoSup (thePart, fillPer))
      return;

   curExhaustReqs_.push (thePart, fillPer);

   unanNetting_ = witTRUE;
d90 9
a98 3
void WitExpRest::expBomEnt ()
   {
   unanNetting_ = witFALSE;
@


1.18
log
@Continued development of Selective Stock Reallocation.
@
text
@a29 1
      curShort_          (witFALSE),
d32 4
a35 1
      repReqs_           (myProblem ())
d53 12
d72 21
a92 3
   if (! restExpOK)
      {
      curExhaustReqs_.push (thePart, fillPer);
d94 3
a96 2
      curShort_ = witTRUE;
      }
d101 1
a101 1
void WitExpRest::recordFundShortage (WitBoolean & first)
d103 3
a105 3
   first          = ! curFundShort_;
   curFundShort_  =   witTRUE;
   curShort_      =   witTRUE;
d119 3
d129 3
a133 1
   curShort_     = witFALSE;
d252 12
@


1.17
log
@Continued implementation of selective stock reallocation.
@
text
@d117 3
a119 1
      if (thePart->getMyMaterial (theMat))
@


1.16
log
@Tightly integrated stock reallocation and stock non-reallocation in preparation
for selective stock reallocation.
@
text
@a16 1
#include <AvSched.h>
d117 1
a117 1
      if (thePart->isaMaterial (theMat))
d131 3
a133 6
   const WitAvailSched * theAvailSched;
   WitPart *             thePart;
   WitPeriod             reqPer;
   WitPeriod             thePer;

   theAvailSched = myHeurAtor_->myAvailSched ();
d137 1
a137 1
      if (theAvailSched->incAvailVol (thePart, reqPer) <= NET_TOL)
@


1.15
log
@Created and used Archive template.
@
text
@d141 1
a141 1
      if (theAvailSched->incAvail (thePart, reqPer) <= NET_TOL)
@


1.14
log
@Initial implementation of pegging.
@
text
@a16 1
#include <AllMode.h>
d137 1
a137 1
   theAvailSched = myHeurAtor_->myAllocMode ()->curAvailSched ();
@


1.13
log
@Continued implementation of selection splitting.
@
text
@d19 1
a19 1
#include <HeurAllP.h>
d25 2
a26 2
WitExpRest::WitExpRest (WitHeurAllPerf * theHeurAllPerf):
      WitProbAssoc       (theHeurAllPerf),
d28 1
a28 1
      myHeurAllPerf_     (theHeurAllPerf),
d138 1
a138 1
   theAvailSched = myHeurAllPerf_->myAllocMode ()->curAvailSched ();
@


1.12
log
@Implemented and used class SelMgr.
@
text
@d103 1
a103 1
void WitExpRest::update (WitBoolean & restShortOnly)
d108 1
d125 2
@


1.11
log
@Fixed some bugs in coarse selection splitting.
@
text
@d19 1
d25 2
a26 2
WitExpRest::WitExpRest (WitProblem * theProblem):
      WitProbAssoc       (theProblem),
d28 1
d128 1
a128 1
void WitExpRest::replenishPsSups (WitAllocMode * theAllocMode)
d130 6
a135 3
   WitPart * thePart;
   WitPeriod reqPer;
   WitPeriod thePer;
d139 1
a139 1
      if (theAllocMode->curAvailSched ()->incAvail (thePart, reqPer) <= NET_TOL)
@


1.10
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d60 1
a60 1
      curExhaustReqs_.put (thePart, fillPer);
d79 1
a79 1
   repReqs_.put (thePart, thePer);
d107 1
a107 1
   while (failExhaustReqs_.get (thePart, fillPer))
d132 1
a132 1
   while (repReqs_.get (thePart, reqPer))
@


1.9
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d37 1
a37 1
   hasPseudoSup_.partiallyAllocate (myProblem ());
@


1.8
log
@Finished implementing stock reallocation.
@
text
@d60 1
a60 1
      curExhaustReqs_.push (thePart, fillPer);
d79 1
a79 1
   repReqs_.push (thePart, thePer);
d107 1
a107 1
   while (failExhaustReqs_.pop (thePart, fillPer))
d132 1
a132 1
   while (repReqs_.pop (thePart, reqPer))
@


1.7
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d18 1
d134 2
a135 9
      if (myGlobalComp ()->stockRealloc ())
         {
         if (   theAllocMode->curAvailSched ()->incAvail (thePart, reqPer) 
             <= NET_TOL)
            continue;
         }
      else
         if (theAllocMode->curNetSupp (thePart)[reqPer] <= NET_TOL)
            continue;
@


1.6
log
@Continued implementation of stock reallocation.
@
text
@d133 1
a133 1
      if (myGlobalComp ()->stockReAlloc ())
@


1.5
log
@Continued implementation of stock re-allocation.
@
text
@d135 2
a136 1
         if (theAllocMode->curIncAvail (thePart)[reqPer] <= NET_TOL)
@


1.4
log
@Minor update to stock re-allocation.
@
text
@d135 1
a135 1
         if (theAllocMode->curSurplus (thePart)[reqPer] <= NET_TOL)
@


1.3
log
@Initial implementation of stock re-allocation.
@
text
@d133 6
a138 1
      if (myGlobalComp ()->usingNetSupp ())
a139 4
            continue;

      if (myGlobalComp ()->usingSurplus ())
         if (theAllocMode->curSurplus (thePart)[reqPer] <= NET_TOL)
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d133 7
a139 2
      if (theAllocMode->netSupp (thePart)[reqPer] <= NET_TOL)
         continue;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.12;
access;
symbols
	EndRw-branch:1.11.0.10
	Root-of-EndRw:1.11
	rwToStl:1.11.0.8
	latest_sce_3_10_20010924:1.11.0.6
	sce_3_10_20010924:1.11
	latest_sce_3_00_20010601:1.11.0.4
	sce_3_00_20010601:1.11
	latest_sce_2_31_20010308:1.11.0.2
	sce_2_31_20010308:1.11
	latest_sce_2_31_20001003:1.7.0.2
	sce_2_31_20001003:1.7
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2003.01.02.22.18.46;	author rjw;	state dead;
branches;
next	1.11;

1.11
date	2001.01.20.00.44.21;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.20.20.08.37;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.22.23.11.47;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.21.20.03.27;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.29.21.22.47;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.18.00.16.01;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.24.19.55.26;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.10.23.17.46;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.16.56.50;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.29.21.55.59;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Internal changes.
@
text
@@


1.11
log
@Implemented and used class SelMgr.
@
text
@@


1.10
log
@Further development of coarse selection splitting.
@
text
@a0 722
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

#ifndef RWClientH
#define RWClientH

//------------------------------------------------------------------------------
// Header file: "RWClient.h"
//
// Contains the declaration of all classes that use Rogue Wave classes.
// Currently, these are:
//
//    Vector (TheType)
//    AbsList
//    ListItr
//    List (TheType)
//
// Notes:
//
// 1. The "type" argument to macros defining a generic class must be a single
//    symbol naming a type. This applies to all generics, not just RW wrappers.
//
// 2. The "declare" macro for the generic classes defined in this header
//    should only be invoked in this header, because the corresponding
//    "implement" macro invocations are in RWClient.C
//
// 3. The "declare" macro cannot be called from WIT's declaration
//    macros, because they themselves are called by the "declare" macro and
//    the C++ preprocessor does not allow recursion. Thus the RW declaration
//    macros must be called directly.
//------------------------------------------------------------------------------

#include <rw/gvector.h>
#include <rw/cstring.h>
#include <rw/gslist.h>

#include <MsgFac.h>

//------------------------------------------------------------------------------
// generic class Vector (TheType).
//
// A vector whose elements are instances of TheType.
// Implemented as a wrapper for RWGVector (TheType).
//
// Warning: This is a value-based collection class; its methods make heavy use
// of the copy constructor for TheType.
//
// To declare and implement WitVector (YourType), check the "Declarations of all
// specific cases of generic class Vector", which appears in this file, and
// look for the following line:
//
//     declare (WitVector, YourType)
//
// If this line is not there, add it. In this case, you must also add the
// following line to the list of "implement" macro invocations in RWClient.C
//
//     implement (WitVector, YourType)
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Generic class declaration macro.
//------------------------------------------------------------------------------

#define WitVectordeclare(TheType)                                              \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
RWGVectordeclare (TheType)                                                     \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitVector (TheType): public WitUtil                                      \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* The following functions and operators are wrappers around the       */\
      /* corresponding RWGVector member functions and operators.             */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitVector (TheType) ();                                                  \
         /*                                                                  */\
         /* Constructs an instance with 0 elements.                          */\
                                                                               \
      WitVector (TheType) (size_t nElems, TheType initValue);                  \
                                                                               \
         /* Constructs an instance with nElems elements, each of which is    */\
         /* initialized to initValue.                                        */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitVector (TheType) ();                                                 \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Public member operators.                                            */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline TheType operator [] (int theIndex) const;                         \
         /*                                                                  */\
         /* Returns the indexed element of this WitVector.                   */\
         /* Bounds checking is performed (by WIT), iff the compile is in     */\
         /* DEBUG  mode.                                                     */\
         /* Returned value is not an lvalue.                                 */\
                                                                               \
      inline TheType & operator [] (int theIndex);                             \
         /*                                                                  */\
         /* Same as the preceeding operator [], except that this WitVector   */\
         /* is non-const and the returned value is an lvalue.                */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Other public member functions.                                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline size_t length () const                                            \
            /*                                                               */\
            /* Returns the length of this WitVector.                         */\
         {                                                                     \
         return myRWData_.length ();                                           \
         }                                                                     \
                                                                               \
      const TheType * myCvector () const;                                      \
         /*                                                                  */\
         /* Returns the c-vector which stores the elements of this vector.   */\
                                                                               \
      void operator = (TheType theValue);                                      \
         /*                                                                  */\
         /* Sets all elements of this WitVector to theValue.                 */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* The remaining functions are not wrappers around RWGVector member    */\
      /* functions.                                                          */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      void operator = (const WitVector (TheType) & theVector);                 \
         /*                                                                  */\
         /* Copies the elements of theVector into the corresponding          */\
         /* elements of this WitVector.                                      */\
         /* The length of theVector must match that of this WitVector.       */\
         /* This is a different convention from the RW assignment operator,  */\
         /* which resizes this RWGVector to match theVector.                 */\
                                                                               \
      void operator = (const TheType * theCvector);                            \
         /*                                                                  */\
         /* Copies the elements of theCvector into the corresponding         */\
         /* elements of this WitVector.                                      */\
         /* The length of theCvector is assumed match that of this           */\
         /* WitVector, but this assumption cannot be verified.               */\
                                                                               \
      void copySelfInto (TheType * theCvector) const;                          \
         /*                                                                  */\
         /* Copies the elements of this Vector into the corresponding        */\
         /* elements of this theCvector.                                     */\
         /* The length of theCvector is assumed match that of this           */\
         /* WitVector, but this assumption cannot be verified.               */\
                                                                               \
      TheType * myCvectorForUpdate ();                                         \
         /*                                                                  */\
         /* Same as myCvector (), but returns non-const.                     */\
         /* Use with discretion.                                             */\
                                                                               \
      void clear ();                                                           \
         /*                                                                  */\
         /* Resizes this WitVector to 0 elements.                            */\
                                                                               \
      void resize (size_t nElems);                                             \
         /*                                                                  */\
         /* Resizes this WitVector to nElems elements.                       */\
         /* The resulting element values are undefined.                      */\
                                                                               \
      void resize (size_t nElems, TheType theValue);                           \
         /*                                                                  */\
         /* Resizes this WitVector to nElems elements.                       */\
         /* The elements are all set to theValue.                            */\
                                                                               \
      WitBoolean operator == (const WitVector (TheType) & theVector) const;    \
         /*                                                                  */\
         /* Returns TRUE iff this Vector == theVector.                       */\
                                                                               \
      WitBoolean operator == (TheType theValue) const;                         \
         /*                                                                  */\
         /* Returns TRUE iff every element of this Vector == theValue.       */\
                                                                               \
      inline WitBoolean isAllocated () const                                   \
         {                                                                     \
         return (length () > 0);                                               \
         }                                                                     \
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      void checkBounds (int theIndex) const;                                   \
         /*                                                                  */\
         /* Verifies the theIndex is within the bounds of this               */\
         /* WitVector (TheType).                                             */\
                                                                               \
      noCopyCtor (WitVector (TheType));                                        \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member data.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      RWGVector (TheType) myRWData_;                                           \
         /*                                                                  */\
         /* The RWGVector (TheType) for which this Vector is a wrapper.      */\
   };                                                                          \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Implementations of inline member functions.                               */\
/*---------------------------------------------------------------------------*/\
                                                                               \
inline TheType WitVector (TheType)::operator [] (int theIndex) const           \
   {                                                                           \
   ifDebug (checkBounds (theIndex));                                           \
                                                                               \
   return myRWData_ (theIndex);                                                \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
inline TheType & WitVector (TheType)::operator [] (int theIndex)               \
   {                                                                           \
   ifDebug (checkBounds (theIndex));                                           \
                                                                               \
   return myRWData_ (theIndex);                                                \
   }                                                                           \

//------------------------------------------------------------------------------
// Declarations of all specific cases of generic class Vector.
//------------------------------------------------------------------------------

declare (WitVector, int)
declare (WitVector, long)
declare (WitVector, float)
declare (WitVector, double)
declare (WitVector, char)
declare (WitVector, WitTlPtr)

//------------------------------------------------------------------------------
// Global functions that use specific cases of class Vector.
//------------------------------------------------------------------------------

WitBoolean operator >= (const WitVector (float) & theVector, float theValue);
   //
   // Returns TRUE, iff each element of theVector >= theValue.

void copyInto (WitVector (double) & dstVec, const float * srcCVec);
   //
   // Copies the elements of srcCVec into dstVec.

void copyInto (WitVector (double) & dstVec, const WitVector (float) & srcVec);
   //
   // Copies the elements of srcVec into dstVec.

void copyInto (WitVector (float) & dstVec, const WitVector (double) & srcVec);
   //
   // Copies the elements of srcVec into dstVec.

WitBoolean operator >= (const WitVector (double) & theVector, double theValue);
   //
   // Returns TRUE, iff each element of theVector >= theValue.

//------------------------------------------------------------------------------
// class WitAbsList (Abstract List)
//
// An AbsList is a singly-linked list whose elements are TlPtrs.
// It is Implemented as a wrapper for RWGSlist(void).
// This class functions as a base class for the generic class List (TheType).
// Its purpose is to implement all type-independent aspects of List (TheType).
// Since this function is intended to be used only as a base class, its
// ctors and dtor are protected.
//------------------------------------------------------------------------------

declare (RWGSlist, WitTl)

class WitAbsList: public WitUtil
   {
      friend class WitListItr;

   public:

      //------------------------------------------------------------------------
      // The following functions and operators are wrappers around the
      // corresponding RWGSlist member functions and operators.
      //------------------------------------------------------------------------

      void clear ();
         //
         // Removes all of the elements from this AbsList.

      inline size_t nElements () const
            //
            // Returns the number of elements in this AbsList.
         {
         return myRWData_.entries ();
         }

      inline WitBoolean isEmpty () const
            //
            // Returns TRUE iff this AbsList is empty.
         {
         return myRWData_.isEmpty ();
         }

   protected:

      //------------------------------------------------------------------------
      // The following functions and operators are wrappers around the
      // corresponding RWGSlist member functions and operators.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAbsList ();
         //
         // Constructs an empty list.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitAbsList ();

      //------------------------------------------------------------------------
      // Other protected wrappers.
      //------------------------------------------------------------------------

      void operator = (const WitAbsList & theAbsList);
         //
         // Assignment operator. 
         // Makes this AbsList a shallow copy of theAbsList.

      void append (WitTl * theObject);
         //
         // Adds theObject to the end of this AbsList.
         // Generates a severe error if the appending was unsuccessful, or
         // if theObject is NULL.

      WitTl * first () const;
         //
         // Returns the first element in this AbsList.

      WitTl * get ();
         //
         // Returns and removes the first element in this AbsList.

      WitTl * last () const;
         //
         // Returns the last element in this AbsList.

      WitTl * prepend (WitTl * theObject);
         //
         // Adds theObject to the beginning of this AbsList and returns
         // it. Generates a severe error if the prepending was unsuccessful,
         // or if theObject is NULL.

      WitTl * at (size_t theIndex) const;
         //
         // Returns a pointer to the element in this AbsList whose index ==
         // theIndex, where the indices are 0, 1, ..., nElements - 1.
         // If theIndex is outside this range, an RW error is issued.

      WitTl * removeReference (const WitTl * theElement);
         //
         // Removes and returns the first element in this AbsList whose
         // address == theElement, or returns NULL, if no match is found.

      //------------------------------------------------------------------------
      // Non-wrapper member functions.
      //------------------------------------------------------------------------

      void appendUniquely (WitTl * theObject);
         //
         // Same as append, but asserts that theObject is not already in this
         // AbsList.

      WitBoolean contains (const WitTl * theObject) const;
         //
         // Returns TRUE, iff theObject is in this AbsList.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtor (WitAbsList);

      RWGSlist (WitTl) myRWData_;
         //
         // The RWGSlist (Tl) for which this AbsList is a wrapper.
   };

//------------------------------------------------------------------------------
// Class ListItr (List Iterator)
//
// An iterator for an AbsList. Facilitates interating thru the elements of an
// AbsList, to which is it "attached" at contruction time. Implemented as
// a wrapper for class RWGSlistIterator (Tl). Since AbsList is only a base
// class for generic class List (TheType), ListItrs are actually always attached
// List (TheType)s, but only interact with them using the AbsList interface.
// Class ListItr is not intended to be used directly, but instead, used only
// thru various macros:
//    forEachEl       in RWCLient.h
//    forEach<object> in Problem.h
//------------------------------------------------------------------------------

class WitListItr: public WitUtil
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitListItr (const WitAbsList & theAbsList);
         //
         // Constucts an ListItr attached to theAbsList.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitListItr ();

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      WitTl * key ();
         //
         // Returns the element to which this ListItr points.

      WitBoolean advance ();
         //
         // Advances this Itr in its AbsList.
         // Returns TRUE iff the advance did not move beyond the end of the
         // AbsList.

      WitBoolean advance (WitTl * & theElement, const WitAbsList & theAbsList);
         //
         // Advances this Itr. If this Itr is still within theAbsList after the
         // advance, this function sets theElement to its key and returns
         // TRUE. Otherwise this function sets theElement to NULL and
         // returns FALSE. This Itr is required to be attached to theAbsList.

   private:

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      RWGSlistIterator (WitTl) myRWData_;
   };

//------------------------------------------------------------------------------
// generic class List (TheType)
//
// A List (TheType) is a singly-linked list whose elements are instances of
// TheType. Derived from class AbsList.
//
// This is a pointer-based collection class: its methods do not use the copy
// constructor for TheType.
//
// To declare and implement this generic classe for YourType,
// check the "Declarations of all specific cases of generic class List",
// which appears in this file, and look for the following line:
//
//     declare (WitList, YourType)
//
// If this line is not there, add it. In this case, you must also add the
// following line to the list of "implement" macro invocations in RWClient.C
//
//     implement (WitList, YourType)
//
// These two macros declare and implement List (YourType).
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Declaration macro for generic class List (TheType).
//------------------------------------------------------------------------------

#define WitListdeclare(TheType)                                                \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Declaration of class List (TheType).                                      */\
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitList (TheType): public WitAbsList                                     \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitList (TheType) ();                                                    \
         /*                                                                  */\
         /* Constructs an empty list.                                        */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitList (TheType) ();                                                   \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Wrappers around AbsList member functions.                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline void operator = (const WitList (TheType) & theList)               \
         {                                                                     \
         WitAbsList::operator = (theList);                                     \
         }                                                                     \
                                                                               \
      inline void append (TheType * theInstance)                               \
         {                                                                     \
         WitAbsList::append ((WitTl *) theInstance);                           \
         }                                                                     \
                                                                               \
      inline TheType * first () const                                          \
         {                                                                     \
         return (TheType *) WitAbsList::first ();                              \
         }                                                                     \
                                                                               \
      inline TheType * get ()                                                  \
         {                                                                     \
         return (TheType *) WitAbsList::get ();                                \
         }                                                                     \
                                                                               \
      inline TheType * last () const                                           \
         {                                                                     \
         return (TheType *) WitAbsList::last ();                               \
         }                                                                     \
                                                                               \
      inline TheType * prepend (TheType * theInstance)                         \
         {                                                                     \
         return (TheType *) WitAbsList::prepend ((WitTl *) theInstance);       \
         }                                                                     \
                                                                               \
      inline TheType * removeReference (const TheType * theElement)            \
         {                                                                     \
         return (TheType *) WitAbsList::removeReference ((WitTl *) theElement);\
         }                                                                     \
                                                                               \
      inline TheType * at (size_t theIndex) const                              \
         {                                                                     \
         return (TheType *) WitAbsList::at (theIndex);                         \
         }                                                                     \
                                                                               \
      inline WitBoolean advance (                                              \
            WitListItr & theItr,                                               \
            TheType * &  theElement)                                           \
            const                                                              \
         {                                                                     \
         return theItr.advance ((WitTl * &) theElement, * this);               \
         }                                                                     \
                                                                               \
      inline void appendUniquely (TheType * theObject)                         \
         {                                                                     \
         WitAbsList::appendUniquely ((WitTl *) theObject);                     \
         }                                                                     \
                                                                               \
      inline WitBoolean contains (const TheType * theObject) const             \
         {                                                                     \
         return WitAbsList::contains ((WitTl *) theObject);                    \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Other public member functions.                                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      void clearContents ();                                                   \
         /*                                                                  */\
         /* Clears this List while deleting all its elements.                */\
                                                                               \
      TheType * find (                                                         \
            const WitString & (* theFunc) (const TheType *),                   \
            const char * theCstring)                                           \
            const;                                                             \
         /*                                                                  */\
         /* Return the first element of this List, theElement, such that     */\
         /* theFunc (theElement) == theCstring, if any, else NULL.           */\
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtor (WitList (TheType));                                          \
   };                                                                          \

//------------------------------------------------------------------------------
// Declarations of all specific cases of generic class List.
//------------------------------------------------------------------------------

declare (WitList, void)
declare (WitList, int)

declare (WitList, WitString)

declare (WitList, WitComponent)
declare (WitList, WitNode)
declare (WitList, WitPart)
declare (WitList, WitOperation)
declare (WitList, WitBomEntry)
declare (WitList, WitSubEntry)
declare (WitList, WitBopEntry)
declare (WitList, WitDemand)

declare (WitList, WitDatedPart)

declare (WitList, WitParam)
declare (WitList, WitStringParam)
declare (WitList, WitIntParam)
declare (WitList, WitChoiceParam)

declare (WitList, WitTimingSection)

declare (WitList, WitVariant)

declare (WitList, WitObjFunc)
declare (WitList, WitOptStarter)

declare (WitList, WitMeAltPt)

declare (WitList, WitBoundedVar)
declare (WitList, WitCoeff)
declare (WitList, WitLpCon)
declare (WitList, WitLpObj)
declare (WitList, WitLpVar)
declare (WitList, WitModelEl)

//------------------------------------------------------------------------------
// macro forEachEl (theElement, theList)
//
// Expands to a header of a for loop that iterates thru each element in
// theList.
//
// Arguments:
//
//    theList:    Type: const List (TheType), for some type, TheType.
//                The list being iterated.
//
//    theElement: Type: TheType *
//                A pointer that will be set to each element of theList, in
//                sequence. The body of the for loop should normally make use
//                of this pointer.
//
// Note: If theList is empty, the forEachEl loop does nothing (which is to be
// expected).
//
// Example:
//
// WitList (WitBomEntry) bom;
//
// ...Fill up bom with BomEntries...
//
// WitBomEntry * theBomEnt;
//
// forEachEl (theBomEnt, bom)
//    {
//    ...statements using theBomEnt...
//    }
//
// The implementation of this macro calls the macro forEachElItr (defined
// below), which expands to a name unique to the line of source code from which
// the forEachElItr macro was called. This name is used as the name of a
// ListItr, which is used to implement the forEachEl macro. It is necessary for
// the forEachEl macro to use a different name for its ListItr each time it is
// called, because it might get called more than once from within the same
// scope.
//------------------------------------------------------------------------------

#define forEachElItr name2 (forEachElItrOnLine, __LINE__)

//------------------------------------------------------------------------------

#define forEachEl(theElement, theList)                                         \
                                                                               \
   for (                                                                       \
      WitListItr forEachElItr (theList);                                       \
      (theList).advance (forEachElItr, theElement);                            \
      )                                                                        \

//------------------------------------------------------------------------------
// Macro implementClearContents(TheType)
//
// Implements the clearContents member function of class List (TheType).
// This function is implemented thru a separate macro, because the
// implementation uses the dtor for TheType, which is not in general visible
// to RWClient.C. The macro is normally invoked in the file that contains the
// implementation of TheType. For a given TheType, the macro only needs to be
// invoked if List (TheType)::clearContents will be invoked.
//------------------------------------------------------------------------------

#define implementClearContents(TheType)                                        \
                                                                               \
void WitList (TheType)::clearContents ()                                       \
   {                                                                           \
   while (! isEmpty ())                                                        \
      delete get ();                                                           \
   }                                                                           \

#endif
@


1.9
log
@Refactoring for selection splitting.
@
text
@d251 1
a251 1
declare (WitVector, WitTypelessPtr)
d280 1
a280 1
// An AbsList is a singly-linked list whose elements are TypelessPtr's.
d288 1
a288 1
declare (RWGSlist, WitNoClass)
d349 1
a349 1
      void append (WitTypelessPtr theObject);
d355 1
a355 1
      WitTypelessPtr first () const;
d359 1
a359 1
      WitTypelessPtr get ();
d363 1
a363 1
      WitTypelessPtr last () const;
d367 1
a367 1
      WitTypelessPtr prepend (WitTypelessPtr theObject);
d373 1
a373 1
      WitTypelessPtr at (size_t theIndex) const;
d379 1
a379 1
      WitTypelessPtr removeReference (const WitTypelessPtr theElement);
d388 1
a388 1
      void appendUniquely (WitTypelessPtr theObject);
d393 1
a393 1
      WitBoolean contains (const WitTypelessPtr theObject) const;
d405 1
a405 1
      RWGSlist (WitNoClass) myRWData_;
d407 1
a407 1
         // The RWGSlist (NoClass) for which this AbsList is a wrapper.
d415 1
a415 1
// a wrapper for class RWGSlistIterator(NoClass). Since AbsList is only a base
d446 1
a446 1
      WitTypelessPtr key ();
d456 1
a456 3
      WitBoolean advance (
            WitTypelessPtr &   theElement, 
            const WitAbsList & theAbsList);
d469 1
a469 1
      RWGSlistIterator (WitNoClass) myRWData_;
d534 1
a534 1
         WitAbsList::append ((WitTypelessPtr) theInstance);                    \
d554 1
a554 1
         return (TheType *) WitAbsList::prepend ((WitTypelessPtr) theInstance);\
d559 1
a559 3
         return                                                                \
            (TheType *) WitAbsList::removeReference (                          \
               (WitTypelessPtr) theElement);                                   \
d572 1
a572 1
         return theItr.advance ((WitTypelessPtr &) theElement, * this);        \
d577 1
a577 1
         WitAbsList::appendUniquely ((WitTypelessPtr) theObject);              \
d582 1
a582 1
         return WitAbsList::contains ((WitTypelessPtr) theObject);             \
@


1.8
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d137 1
a137 1
      WitVector (TheType) & operator = (TheType theValue);                     \
d146 1
a146 1
      WitVector (TheType) & operator = (const WitVector (TheType) & theVector);\
d154 1
a154 1
      WitVector (TheType) & operator = (const TheType * theCvector);           \
d211 1
a211 3
      WitVector (TheType) (const WitVector (TheType) &);                       \
         /*                                                                  */\
         /* Not implemented: prevents accidental copying.                    */\
a333 4
      WitAbsList (const WitAbsList & theAbsList);
         //
         // Copy constructor: Constructs a shallow copy of theAbsList.

d344 1
a344 1
      WitAbsList & operator = (const WitAbsList & theAbsList);
d346 2
a347 2
         // Assignment operator. Makes this AbsList a shallow copy of theAbsList
         // and returns it.
d400 1
a400 1
      // Other private member data.
d403 2
a518 4
      WitList (TheType) (const WitList (TheType) & theList);                   \
         /*                                                                  */\
         /* Copy constructor: Constructs a shallow copy of theList.          */\
                                                                               \
d529 1
a529 1
      inline WitList (TheType) & operator = (const WitList (TheType) & theList)\
d531 1
a531 1
         return (WitList (TheType) &) WitAbsList::operator = (theList);        \
d604 8
@


1.7
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d161 1
a161 1
      void copyInto (TheType * theCvector) const;                              \
d263 1
a263 1
void copyTo (WitVector (double) & dstVec, const float * srcCVec);
d267 1
a267 1
void copyTo (WitVector (double) & dstVec, const WitVector (float) & srcVec);
d271 1
a271 1
void copyTo (WitVector (float) & dstVec, const WitVector (double) & srcVec);
@


1.6
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d263 1
a263 1
void copy (WitVector (double) & dstVec, const float * srcCVec);
d267 1
a267 1
void copy (WitVector (double) & dstVec, const WitVector (float) & srcVec);
d271 1
a271 1
void copy (WitVector (float) & dstVec, const WitVector (double) & srcVec);
@


1.5
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@a252 1
declare (WitVector, WitVoidStar)
d282 1
a282 1
// An AbsList is a singly-linked list whose elements are void *'s.
d290 1
a290 1
declare (RWGSlist, void)
d355 1
a355 1
      void append (void * theObject);
d361 1
a361 1
      void * first () const;
d365 1
a365 1
      void * get ();
d369 1
a369 1
      void * last () const;
d373 1
a373 1
      void * prepend (void * theObject);
d379 1
a379 1
      void * at (size_t theIndex) const;
d385 1
a385 1
      void * removeReference (const void * theElement);
d394 1
a394 1
      void appendUniquely (void * theObject);
d399 1
a399 1
      WitBoolean contains (const void * theObject) const;
d409 1
a409 1
      RWGSlist(void) myRWData_;
d411 1
a411 1
         // The RWGSlist(void) for which this AbsList is a wrapper.
d419 1
a419 1
// a wrapper for class RWGSlistIterator(void). Since AbsList is only a base
d450 1
a450 1
      void * key ();
d460 3
a462 1
      WitBoolean advance (void * & theElement, const WitAbsList & theAbsList);
d475 1
a475 1
      RWGSlistIterator(void) myRWData_;
d544 1
a544 1
         WitAbsList::append (theInstance);                                     \
d564 1
a564 1
         return (TheType *) WitAbsList::prepend (theInstance);                 \
d569 3
a571 1
         return (TheType *) WitAbsList::removeReference (theElement);          \
d584 1
a584 1
         return theItr.advance ((void * &) theElement, * this);                \
d589 1
a589 1
         WitAbsList::appendUniquely (theObject);                               \
d594 1
a594 1
         return WitAbsList::contains (theObject);                              \
@


1.4
log
@Replaced "PRM" with "WIT".
Replaced "Production Resource Manager" with "Watson Implosion Technology".
Upgraded release # to 6.0.
@
text
@d78 1
a78 1
class WitVector (TheType)                                                      \
d293 1
a293 1
class WitAbsList
d429 1
a429 1
class WitListItr
@


1.3
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d113 1
a113 1
         /* Bounds checking is performed (by PRM), iff the compile is in     */\
@


1.2
log
@Bob's changes to
-fix Aix V4.1.5 compiler warning
-remove WitUtil::nonPortableFree macro which was causing problems in the
 lexx and yacc generated calls to free
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1
log
@Initial revision
@
text
@d645 6
a650 10
#ifdef OPT_IMPLODE

   declare (WitList, WitBoundedVar)
   declare (WitList, WitCoeff)
   declare (WitList, WitLpCon)
   declare (WitList, WitLpObj)
   declare (WitList, WitLpVar)
   declare (WitList, WitModelEl)

#endif
@


1.1.1.1
log
@Import wit
@
text
@@

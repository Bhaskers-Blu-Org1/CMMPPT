head	1.208;
access;
symbols
	sce_5_01_20080919:1.199
	latest_sce_4_20_20060523:1.145.0.2
	sce_4_20_20060523:1.145
	latest_sce4_20_OSL:1.140.0.2
	sce_4_20_OSL:1.140
	sce_410_withVa:1.131
	sce_4_05_20040511:1.109
	sce_4_00_20040201:1.95
	nextGenBranch:1.83.0.2
	nextGenRoot:1.83
	sce_3_30_20030627:1.83
	EndRw-branch:1.69.0.2
	Root-of-EndRw:1.69
	rwToStl:1.68.0.2
	latest_sce_3_10_20010924:1.38.0.2
	sce_3_10_20010924:1.38
	latest_sce_3_00_20010601:1.27.0.2
	sce_3_00_20010601:1.27
	latest_sce_2_31_20010308:1.17.0.2
	sce_2_31_20010308:1.17
	latest_sce_2_31_20001003:1.10.0.2
	sce_2_31_20001003:1.10
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.208
date	2010.03.16.22.42.25;	author rjw;	state dead;
branches;
next	1.207;

1.207
date	2010.03.05.00.10.14;	author rjw;	state Exp;
branches;
next	1.206;

1.206
date	2010.03.04.22.18.35;	author rjw;	state Exp;
branches;
next	1.205;

1.205
date	2010.03.03.20.10.29;	author rjw;	state Exp;
branches;
next	1.204;

1.204
date	2009.11.13.19.01.25;	author rjw;	state Exp;
branches;
next	1.203;

1.203
date	2009.10.06.21.06.11;	author rjw;	state Exp;
branches;
next	1.202;

1.202
date	2009.06.23.21.34.40;	author rjw;	state Exp;
branches;
next	1.201;

1.201
date	2009.05.08.23.18.00;	author rjw;	state Exp;
branches;
next	1.200;

1.200
date	2009.01.30.16.07.19;	author rjw;	state Exp;
branches;
next	1.199;

1.199
date	2007.11.15.17.15.33;	author rjw;	state Exp;
branches;
next	1.198;

1.198
date	2007.11.13.20.17.39;	author rjw;	state Exp;
branches;
next	1.197;

1.197
date	2007.11.12.20.27.36;	author rjw;	state Exp;
branches;
next	1.196;

1.196
date	2007.11.08.19.16.39;	author rjw;	state Exp;
branches;
next	1.195;

1.195
date	2007.11.07.21.50.12;	author rjw;	state Exp;
branches;
next	1.194;

1.194
date	2007.10.15.21.50.34;	author rjw;	state Exp;
branches;
next	1.193;

1.193
date	2007.07.17.22.10.26;	author rjw;	state Exp;
branches;
next	1.192;

1.192
date	2007.07.13.23.05.32;	author rjw;	state Exp;
branches;
next	1.191;

1.191
date	2007.07.05.18.37.54;	author rjw;	state Exp;
branches;
next	1.190;

1.190
date	2007.06.29.15.25.49;	author rjw;	state Exp;
branches;
next	1.189;

1.189
date	2007.06.08.18.09.39;	author rjw;	state Exp;
branches;
next	1.188;

1.188
date	2007.06.05.21.06.00;	author rjw;	state Exp;
branches;
next	1.187;

1.187
date	2007.06.05.16.15.23;	author rjw;	state Exp;
branches;
next	1.186;

1.186
date	2007.05.31.19.52.54;	author rjw;	state Exp;
branches;
next	1.185;

1.185
date	2007.05.30.16.01.19;	author rjw;	state Exp;
branches;
next	1.184;

1.184
date	2007.05.25.18.39.10;	author rjw;	state Exp;
branches;
next	1.183;

1.183
date	2007.05.10.21.58.10;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2007.05.10.21.14.41;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2007.05.10.20.08.49;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2007.05.10.17.22.14;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2007.04.03.22.04.03;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2007.03.09.20.13.06;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2007.03.08.22.47.17;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2007.03.02.22.22.36;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2007.02.28.23.09.07;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2007.02.28.20.04.56;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2007.02.27.22.59.29;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2007.02.27.21.03.04;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2007.02.27.19.59.31;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2007.02.13.23.40.13;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2007.01.29.22.34.12;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2007.01.29.21.52.03;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2007.01.26.20.56.57;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2007.01.24.20.52.56;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2007.01.22.21.27.54;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2007.01.08.18.38.24;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2006.12.01.19.55.17;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2006.11.22.21.45.06;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2006.09.29.18.40.58;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2006.09.27.20.10.16;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2006.09.21.20.31.52;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2006.09.21.17.16.36;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2006.09.08.20.00.59;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2006.09.08.16.16.00;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2006.09.07.20.49.24;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2006.08.30.16.37.34;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2006.08.16.15.49.17;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2006.08.03.18.59.32;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2006.08.02.19.03.00;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2006.08.02.17.27.31;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2006.07.27.23.02.47;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2006.07.19.19.17.06;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2006.06.14.17.40.42;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2006.06.09.15.23.20;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2006.05.22.16.02.41;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2006.05.10.14.45.12;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2006.05.09.14.58.30;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2006.05.08.19.51.24;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2006.05.02.17.33.59;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2006.03.20.23.47.33;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.20.21.54.31;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2006.03.10.23.23.30;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.08.23.57.11;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2006.03.06.23.10.15;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2006.01.04.23.07.39;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2005.11.10.20.33.07;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2005.09.08.19.29.44;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2005.06.16.19.19.11;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2005.06.14.20.35.12;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2005.03.18.21.28.21;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2005.03.02.22.34.35;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2005.02.10.18.38.30;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2005.02.07.20.23.43;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2005.02.07.19.32.28;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2005.02.03.23.35.57;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2005.02.03.23.15.34;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2005.02.03.21.31.35;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2005.02.03.21.20.29;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2005.02.02.17.26.52;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2005.01.31.23.59.29;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2005.01.21.23.01.51;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2005.01.17.23.43.10;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2005.01.10.22.34.47;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2004.12.22.22.27.09;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2004.12.02.21.25.41;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2004.11.09.23.07.59;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2004.11.06.00.30.33;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2004.11.04.20.42.27;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2004.05.17.22.15.17;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.05.15.26.31;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2004.04.30.23.27.43;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2004.04.16.17.42.49;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2004.03.22.21.45.51;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2004.03.12.15.09.23;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2004.03.11.16.36.17;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2004.03.10.22.53.19;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2004.02.27.21.00.29;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.12.19.13.39;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.05.21.24.56;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.05.16.39.43;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2004.02.04.22.31.27;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2004.02.04.18.57.49;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2004.01.30.20.09.48;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2004.01.19.23.26.50;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2004.01.16.18.48.25;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.05.23.37.33;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2003.12.29.20.59.23;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2003.12.23.16.18.46;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2003.12.15.23.22.31;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2003.12.04.22.44.56;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2003.12.04.16.20.41;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2003.10.31.15.37.54;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2003.10.09.21.31.51;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2003.09.22.23.13.51;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2003.09.22.20.27.02;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2003.05.28.22.19.28;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2003.05.13.22.00.02;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2003.05.06.21.04.48;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2003.02.14.20.12.56;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2003.01.31.21.28.54;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2003.01.27.21.17.16;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2003.01.16.16.34.30;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2003.01.02.22.18.28;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2002.12.30.20.37.25;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2002.12.24.22.50.46;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2002.12.23.20.44.45;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2002.12.20.22.47.59;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2002.12.19.17.15.20;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2002.12.17.21.32.45;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2002.11.21.22.53.54;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2002.10.18.22.23.54;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2002.10.16.22.30.19;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2002.10.09.18.42.10;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2002.10.04.21.26.27;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2002.09.30.21.36.35;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.25.17.43.51;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.05.19.31.31;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.04.23.07.20;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.03.22.35.18;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.03.16.01.48;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.30.20.08.58;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.29.21.35.45;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.17.21.45.01;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.13.21.31.39;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2002.05.01.14.25.55;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.24.20.05.29;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.22.14.32.07;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2002.04.18.14.02.32;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2002.04.15.22.02.49;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.27.23.15.38;	author bobw;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.20.18.50.05;	author bobw;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.19.16.17.09;	author bobw;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.17.19.22.50;	author bobw;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.09.21.42.26;	author bobw;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.07.23.03.54;	author bobw;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.05.20.53.57;	author bobw;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.05.18.55.27;	author bobw;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.03.18.55.11;	author bobw;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.28.21.42.39;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.28.20.50.27;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.09.16.21.42.30;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.30.23.00.33;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.08.29.17.12.03;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.08.06.17.31.06;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.03.18.40.41;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.30.15.12.09;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.28.00.48.33;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.25.16.08.14;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.17.20.49.19;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.21.18.24.30;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.02.02.11.27;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.29.22.11.26;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.17.20.02.19;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.17.15.11.14;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.15.15.30.26;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.07.15.58.56;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.03.22.55.45;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.03.20.47.25;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.10.21.59.34;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.06.19.22.08;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.08.16.37.04;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.26.21.46.00;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.04.22.27.50;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.06.19.58.37;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.22.23.11.40;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.21.20.03.23;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.13.21.03.53;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.06.18.45.07;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.29.21.22.43;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.18.00.15.59;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.08.21.56.11;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.02.20.43.12;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.24.19.55.21;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.19.22.35.30;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.01.00.35.43;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.16.33.07;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.51;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches;
next	;


desc
@@


1.208
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

#ifndef GlobalH
#define GlobalH

//------------------------------------------------------------------------------
// Header file: "Global.h"
//
// Contains the declaration of class GlobalComp.
//------------------------------------------------------------------------------

#include <Compo.h>
#include <Str.h>
#include <PairStack.h>

//------------------------------------------------------------------------------
// class GlobalComp
//
// "Global Component"
// Responsible for the global attributes of a Problem,
// except those specific to optimizing implosion.
//
// Class Hierarchy:
//
// ProbAssoc
//    Component
//       GlobalComp
//------------------------------------------------------------------------------

class WitGlobalComp: public WitComponent
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitGlobalComp (WitCompMgr * theCompMgr);
         //
         // Component <<< theCompMgr.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitGlobalComp ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const WitString &,          title)
      accessFunc (int,                        nPeriods)
      accessFunc (bool,                       independentOffsets)
      accessFunc (bool,                       execEmptyBom)
      accessFunc (int,                        hashTableSize)
      accessFunc (bool,                       roundReqVols)
      accessFunc (int,                        outputPrecision)
      accessFunc (bool,                       computeCriticalList)
      accessFunc (bool,                       pgdCritListMode)
      accessFunc (bool,                       wit34Compatible)
      accessFunc (bool,                       wit34Allowed)
      accessFunc (bool,                       useFocusHorizons)
      accessFunc (bool,                       localBuildAhead)
      accessFunc (bool,                       multiExec)
      accessFunc (bool,                       twoWayMultiExec)
      accessFunc (bool,                       localMultiExec)
      accessFunc (int,                        equitability)
      accessFunc (bool,                       forcedMultiEq)
      accessFunc (bool,                       autoPriority)
      accessFunc (bool,                       skipFailures)
      accessFunc (bool,                       multiRoute)
      accessFunc (bool,                       truncOffsets)
      accessFunc (double,                     lotSizeTol)
      accessFunc (double,                     expCutoff)
      accessFunc (bool,                       penExec)
      accessFunc (bool,                       tieBreakPropRt)
      accessFunc (bool,                       stockRealloc)
      accessFunc (bool,                       stockReallocation)
      accessFunc (bool,                       srSelSplit)
      accessFunc (bool,                       respectStockSLBs)
      accessFunc (bool,                       prefHighStockSLBs)
      accessFunc (bool,                       perfPegging) 
      accessFunc (bool,                       selSplit)
      accessFunc (bool,                       nonMrSelSplit)
      accessFunc (bool,                       userHeurStart)
      accessFunc (bool,                       pipSeqFromHeur)
      accessFunc (bool,                       newPipPggOrder) 
      accessFunc (bool,                       highPrecisionWD)
      accessFunc (bool,                       nstnResidual)
      accessFunc (bool,                       minimalExcess)
      accessFunc (bool,                       readDataMsgs)
      accessFunc (bool,                       printIncAlloc)
      accessFunc (bool,                       printEqAlloc)
      accessFunc (int,                        selPrintLevel)
      accessFunc (bool,                       twmeByDemand)
      accessFunc (double,                     splitTol)
      accessFunc (double,                     splitRes)
      accessFunc (int,                        splitItrUB)
      accessFunc (bool,                       pauses)
      accessFunc (bool,                       prtPipMaxRatio)
      accessFunc (bool,                       printDebug)
      accessFunc (bool,                       printExcessVol)
      accessFunc (bool,                       lotSizesExist)
      accessFunc (const WitPartPerStack &,    revCritList)
      accessFunc (const WitList <WitPclEl> &, pgdCritList)
      accessFunc (bool,                       feasible)

      inline bool oldSR ()
         {
         return stockRealloc_;
         }

      const WitString & tempPar (int index) const;
         //
         // Returns the indexed temp par.

      int nTempPars () const;
         //
         // # temporary parameters.

      //------------------------------------------------------------------------
      // Default value functions.
      //------------------------------------------------------------------------

      defaultValue (const char * defTitle,               "Untitled")
      defaultValue (int          defNPeriods,            26)
      defaultValue (bool         defIndependentOffsets,  false)
      defaultValue (bool         defExecEmptyBom,        true)
      defaultValue (int          defHashTableSize,       2000)
      defaultValue (bool         defRoundReqVols,        false)
      defaultValue (int          defOutputPrecision,     3)
      defaultValue (bool         defComputeCriticalList, false)
      defaultValue (bool         defPgdCritListMode,     false)
      defaultValue (bool         defWit34Compatible,     false)
      defaultValue (bool         defWit34Allowed,        true)
      defaultValue (bool         defUseFocusHorizons,    true)
      defaultValue (bool         defLocalBuildAhead,     false)
      defaultValue (bool         defMultiExec,           false)
      defaultValue (bool         defTwoWayMultiExec,     false)
      defaultValue (bool         defLocalMultiExec,      false)
      defaultValue (int          defEquitability,        1)
      defaultValue (bool         defForcedMultiEq,       false)
      defaultValue (bool         defAutoPriority,        false)
      defaultValue (bool         defSkipFailures,        true)
      defaultValue (bool         defMultiRoute,          false)
      defaultValue (bool         defTruncOffsets,        false)
      defaultValue (double       defLotSizeTol,          1.0E-5)
      defaultValue (double       defExpCutoff,           0.01)
      defaultValue (bool         defPenExec,             false)
      defaultValue (bool         defTieBreakPropRt,      false)
      defaultValue (bool         defStockRealloc,        false)
      defaultValue (bool         defStockReallocation,   false)
      defaultValue (bool         defSrSelSplit,          false)
      defaultValue (bool         defRespectStockSLBs,    false)
      defaultValue (bool         defPrefHighStockSLBs,   false)
      defaultValue (bool         defPerfPegging,         false)
      defaultValue (bool         defSelSplit,            false)
      defaultValue (bool         defNonMrSelSplit,       false)
      defaultValue (bool         defUserHeurStart,       false)
      defaultValue (bool         defPipSeqFromHeur,      false)
      defaultValue (bool         defNewPipPggOrder,      true)
      defaultValue (bool         defHighPrecisionWD,     false)
      defaultValue (bool         defNstnResidual,        false)
      defaultValue (bool         defMinimalExcess,       false)

      //------------------------------------------------------------------------
      // "Set" functions.
      //------------------------------------------------------------------------

      void setTitle               (const char *);
      void setNPeriods            (int);
      void setIndependentOffsets  (bool);
      void setExecEmptyBom        (bool);
      void setHashTableSize       (int);
      void setRoundReqVols        (bool);
      void setOutputPrecision     (int);
      void setComputeCriticalList (bool);
      void setPgdCritListMode     (bool);
      void setWit34Compatible     (bool);
      void setWit34Allowed        (bool);
      void setUseFocusHorizons    (bool);
      void setLocalBuildAhead     (bool);
      void setMultiExec           (bool);
      void setTwoWayMultiExec     (bool);
      void setLocalMultiExec      (bool);
      void setEquitability        (int);
      void setForcedMultiEq       (bool);
      void setAutoPriority        (bool);
      void setSkipFailures        (bool);
      void setMultiRoute          (bool);
      void setTruncOffsets        (bool);
      void setLotSizeTol          (double);
      void setExpCutoff           (double);
      void setPenExec             (bool);
      void setTieBreakPropRt      (bool);
      void setStockRealloc        (bool);
      void setStockReallocation   (bool);
      void setSrSelSplit          (bool);
      void setRespectStockSLBs    (bool);
      void setPrefHighStockSLBs   (bool);
      void setPerfPegging         (bool);
      void setSelSplit            (bool);
      void setNonMrSelSplit       (bool);
      void setUserHeurStart       (bool);
      void setPipSeqFromHeur      (bool);
      void setNewPipPggOrder      (bool);
      void setHighPrecisionWD     (bool);
      void setNstnResidual        (bool);
      void setMinimalExcess       (bool);

      //------------------------------------------------------------------------
      // Set functions for development control parameters.
      //------------------------------------------------------------------------

      void setReadDataMsgs   (bool);
      void setPrintIncAlloc  (bool);
      void setPrintEqAlloc   (bool);
      void setSelPrintLevel  (int);
      void setTwmeByDemand   (bool);
      void setSplitTol       (double);
      void setSplitRes       (double);
      void setSplitItrUB     (int);
      void setPauses         (bool);
      void setPrtPipMaxRatio (bool);
      void setPrintDebug     (bool);
      void setPrintExcessVol (bool);

      void setTempPar (int index, const WitString & theValue);
         //
         // Sets tempPar_ (t) to theValue.

      //------------------------------------------------------------------------
      // store<Activity><Attr> functions.
      // Each of these functions sets the value of indicated attribute to the
      // value of the argument.
      // Each function is only valid when the indicated activity is being
      // performed.
      //------------------------------------------------------------------------

      void storePreLotSizesExist (bool);
         //
         // Valid only when preprocessing is being performed.

      void storePostFeasible (bool);
         //
         // Valid only when postprocessing is being performed.

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual bool       inserted       ();
      virtual WitMsgFrag classMsgFrag   ();
      virtual void       copySelfInto   (WitCompMgr * theCompMgr);
      virtual void       recount        ();
      virtual void       unpreprocess   ();
      virtual void       clearOptSoln   ();
      virtual void       clearStochSoln ();
         //
         // Overrides from class Component.

      void display ();
         //
         // Displays the input and preprocessing data for this GlobalComp.

      bool multiExecNeeded ();
         //
         // Returns true, iff it is appropriate to use the multiple execution
         // periods technique.

      void unpostprocess ();
         //
         // Does unpostprocessing for this GlobalComp.

      void clearRevCritListForHeur ();
         //
         // Clears revCritList_.
         // Valid only when heuristic allocation is updating the solution.

      void addToRevCritListForHeur (WitPart * thePart, WitPeriod thePer);
         //
         // Adds (thePart, thePer) to revCritList_.
         // Valid only when heuristic allocation is updating the solution.

      void receiveOptRevCritList (WitPartPerStack & thePartPerStack);
         //
         // Moves the (Part, Pers) pairs from thePartPerStack into revCritList_,
         // which must be empty.
         // Valid only when the optimizing implosion subsystem is uploading the
         // solution.

      void writePdgCritList ();
         //
         // Writes the pegged critical list to the solution file.

      void clearPgdCritList ();
         //
         // Clears pgdCritList_.

      void appendToPgdCritListForHeur (WitPclEl * thePclEl);
         //
         // Appends thePclEl to pgdCritList_.
         // Valid only when heuristic allocation is updating the solution.

      bool tempParIsSet (int index);
         //
         // Returns true, if tempPar #index is set (to a non-empty string).

      bool tempParAsBool (int index);
         //
         // Returns tempPar #index converted to a bool.
         // The value must be "yes" to "no".

      int tempParAsInt (int index);
         //
         // Returns tempPar #index converted to an int.

      double tempParAsDouble (int index);
         //
         // Returns tempPar #index converted to a double.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitGlobalComp);

      void setNTempPars (int theValue);
         //
         // Sets # of tempPars to theValue, setting their values to the empty
         // string.

      void checkTempParIndex (int i) const;
         //
         // Checks that i is a valid tempPar index.

      virtual void writeDataID ();
         //
         // Override from class Component.

      virtual void writeDataAttrs ();
         //
         // Override from class Component.

      void copyAttrsFrom (WitGlobalComp * theGlobalComp);
         //
         // Copies the input attributes of theGlobalComp into this GlobalComp.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Private input data.
      //------------------------------------------------------------------------

      WitString title_;
         //
         // Problem title.

      int nPeriods_;
         //
         // Total number of time periods.

      bool independentOffsets_;
         //
         // If false, the offset of a subEntry cannot be set, and is
         // automatically identical to the offset of the corresponding bomEntry.
         // If true, the offset of a subEntry can be set independently of the
         // offset of the offset of the corresponding bomEntry.

      bool execEmptyBom_;
         //
         // If false, then any Operation will be prevented from executing in
         // any period in which the either of the following conditions hold:
         //
         //    * Its BOM contains to entries, or
         //    * None of its BomEntries is in effect in the period.
         //
         // If true, Operations will be allowed to execute under the above
         // condtions.
         // Defaults to true.

      int hashTableSize_;
         //
         // No longer used.

      bool roundReqVols_;
         //
         // If true, reqVols and focShortageVols will be rounded up to integer
         // values.

      int outputPrecision_;
         //
         // The number of digits to the right of the decimal point in the
         // production schedule output file and shipment schedule output file.
         // Must be >= 0.
         // Defaults to 3.

      bool computeCriticalList_;
         //
         // true, iff the critical part list is to be computed.

      bool pgdCritListMode_;
         //
         // true, iff the heuristic is to compute the pegged critical list.

      bool wit34Compatible_;
         //
         // true iff myProblem () is in WIT 3.4 compatible mode.

      bool wit34Allowed_;
         //
         // wit34Compatible is allowed to be set through the API, iff
         // wit34Allowed_ is true.

      bool useFocusHorizons_;
         //
         // If true, then before the shortage schedule is computed, the
         // fssShipVol for each Demand will be computed using the Demand's
         // focus horizon. If false, the fssShipVols will be left at their
         // current values.

      bool localBuildAhead_;
         //
         // true, iff the local build-ahead periods technique as been
         // requested.
         // This is no longer an officially documented attribute and is only
         // included for upward compatbility.

      bool multiExec_;
         //
         // true, iff the multiple execution periods technique as been
         // explicitly requested.

      bool twoWayMultiExec_;
         //
         // true, iff the multiple execution periods technique is to be used.
         // The set functions assure that whenever twoWayMultiExec_ is true, 
         // multiExec_ also true.

      bool localMultiExec_;
         //
         // true, iff the local multiple execution periods technique as been
         // requested.
         // This is no longer an officially documented attribute and is only
         // included for upward compatbility.

      int equitability_;
         //
         // Must be >= 1.
         // The precision to which equitable allocation is to be performed.
         // 1 means no equitable allocation.

      bool forcedMultiEq_;
         //
         // If true, equitable allocation will use multiple passes,
         // even if there is no tie for priority or there is only one
         // target with positive desIncVol.

      bool autoPriority_;
         //
         // If true, heuristic implosion will generate priorities automatically
         // from the objective function.

      bool skipFailures_;
         //
         // If true, heuristic allocation will not attempt to allocate to a
         // Part in a period if it previously tried and failed to allocate to
         // the Part in the period (with some exceptions).

      bool multiRoute_;
         //
         // If true, multiple routes logic will be used by heuristic allocation.

      bool truncOffsets_;
         //
         // If true, preprocessing will compute impact periods using truncated
         // offsets, i.e., whenever offset[t] > t, it will be treated as if
         // offset[t] == t.

      double lotSizeTol_;
         //
         // Rounding lot-size tolerance, relative to the incremental lot-size.
         // Range: [0.0, +inf).

      double expCutoff_;
         //
         // Smallest acceptable effProdRate for explosion.
         // Range: [1.0E-6, +inf).

      bool penExec_;
         //
         // Heuristic implosion/allocation will use penalized execution iff
         // penExec and multiRoute are both true.

      bool tieBreakPropRt_;
         //
         // If true, penalized execution overrides proportionate routing, so
         // proportionate routing functions only as a tie breaker for
         // penalized execution.
         // If false, proportionate routing overrides penalized execution.

      bool stockRealloc_;
         //
         // true, iff heuristic implosion/allocation is to perform pure
         // unconditional stock reallocation.

      bool stockReallocation_;
         //
         // true, iff heuristic implosion/allocation is to perform selective
         // stock reallocation.

      bool srSelSplit_;
         //
         // true, iff heuristic implosion/allocation is to perform selection
         // splitting for stock reallocation.

      bool respectStockSLBs_;
         //
         // true, iff heuristic allocation is to respect stock soft lower 
         // bounds.

      bool prefHighStockSLBs_;
         //
         // true, iff heuristic allocation is to give preference to stock soft
         // lower bounds on parts higher in the BOM structure over parts lower 
         // in the BOM structure.

      bool perfPegging_;
         //
         // true, iff concurrent pegging is to be performed by the heuristic.

      bool selSplit_;
         //
         // true, iff heuristic implosion/allocation is to perform all cases of
         // selection splitting.

      bool nonMrSelSplit_;
         //
         // true, iff heuristic implosion/allocation is to perform all cases of
         // selection splitting, except multi-route.

      bool userHeurStart_;
         //
         // true, iff user-specified heuristic starting solution is to be used.

      bool pipSeqFromHeur_;
         //
         // true, iff the PIP shipment sequence is to be set by the heuristic.

      bool newPipPggOrder_;
         //
         // true, iff PIP is to use the new pegging order.

      bool highPrecisionWD_;
         //
         // true, iff writeData is to use high precision when writing double
         // data.

      bool nstnResidual_;
         //
         // If true,  residualVol is to be computed on a
         //           "no sooner than necessary" basis.
         // If false, residualVol is to be computed on an
         //           "as soon as possible" basis.

      bool minimalExcess_;
         //
         // If true,  excessVol is to be minimized, given residualVol.
         // If false, excessVol is to be maximized, given residualVol.

      //------------------------------------------------------------------------
      // Development control parameters.
      //------------------------------------------------------------------------

      bool readDataMsgs_;
         //
         // If true, API informational msgs will be issued during readData.

      bool printIncAlloc_;
         //
         // If true, the heuristic allocation data is to be displayed.

      bool printEqAlloc_;
         //
         // If true, the equitable allocation Targets is to be displayed.

      int selPrintLevel_;
         //
         // Printing will be done for the multiple selections heuristic:
         //
         // 0: No printing
         // 1: Counts
         // 2: Alterations
         // 3: Everything

      bool twmeByDemand_;
         //
         // If true, then in two-way multi-exec mode, the multi-exec direction
         // for a demand will be ASAP, iff selForSel is true.

      double splitTol_;
         //
         // Tolerance for selection splitting.

      double splitRes_;
         //
         // Resolution for selection splitting.

      int splitItrUB_;
         //
         // An upper bound on the number of iterations that will be used in
         // selection splitting.

      bool pauses_;
         //
         // If true, WIT will pause at certain times and then wait for user
         // input before continuing.
         // Used for measuring memory utilization.

      bool prtPipMaxRatio_;
         //
         // If true, print the PIP max pegging ratio data.

      bool printDebug_;
         //
         // If true, do various debug printing.

      bool printExcessVol_;
         //
         // If true, excessVol will be printed instead of fssShortageVol in the
         // comprehensive implosion solution output.

      WitPtrVec <WitString> & tempPar_;
         //
         // A vector of temporary development control parameters.
         // Set by ParamMgr.
         // These parameters are only to be used in a local copy of WIT, i.e.,
         // code that depends on their values should never be committed to the
         // CVS repository. This allows all WIT developers to use them at will,
         // without co-ordination.
         // tempPar_ (0) is not used.

      //------------------------------------------------------------------------
      // Data set by preprocessing.
      //------------------------------------------------------------------------

      bool lotSizesExist_;
         //
         // true iff any minLotSize or incLotSize has a positive value.

      //------------------------------------------------------------------------
      // Data set by implosion.
      //------------------------------------------------------------------------

      WitPartPerStack revCritList_;
         //
         // The critical part list.
         // Stored in reverse order.

      //------------------------------------------------------------------------
      // Data set by heuristic allocation.
      //------------------------------------------------------------------------

      WitList <WitPclEl> pgdCritList_;
         //
         // The pegged critical list.

      //------------------------------------------------------------------------
      // Data set by postprocessing.
      //------------------------------------------------------------------------

      bool feasible_;
         //
         // true, iff postprocessed () is true and the current implosion
         // solution is feasible respect to all constraints relevant to the
         // method by which the solution was computed.
   };

#endif
@


1.207
log
@Multi-Obj Mode
@
text
@@


1.206
log
@Multi-Obj Mode
@
text
@a110 1
      accessFunc (double,                     multiObjTol)
a234 1
      void setMultiObjTol    (double);
a644 6
      double multiObjTol_;
         //
         // In multiple objectives mode, each objective that has already been
         // optimized is constrained to achieve its
         // maximum value - multiObjTol_.

@


1.205
log
@Added display of constraint violations > FEAS_TOL.
@
text
@d111 1
d236 1
d647 6
@


1.204
log
@Removing objective #2.
@
text
@a101 1
      accessFunc (bool,                       reportIncViol)
a225 1
      void setReportIncViol  (bool);
a598 5
      bool reportIncViol_;
         //
         // If true, postprocessing will print each constraint violation that
         // increases the value of maxViolation_.

@


1.203
log
@Fixed bug: Printing of incHeurAlloc data is no longer controlled by the
           timesPrint mesg attribute.
@
text
@d618 1
a618 1
         // for a demand will be ASAP, iff its grossRev < 5.
@


1.202
log
@Revised wit34Allowed.
@
text
@d100 1
d225 1
d593 4
d599 1
a599 1
         // If true, the equitable allocation Targets will be displayed.
@


1.201
log
@Fixed two bugs:
   wit34Allowed may not be set when wit34Compatible is TRUE.
   wit34Compatible does not get copied when wit34Allowed is FALSE.
@
text
@d424 2
a425 1
         // true iff wit34Compatible is allowed to be true.
@


1.200
log
@Implemented the undocumented "wit34Allowed" attribute.
@
text
@d424 1
a424 1
         // true iff it permissible to set wit34Compatible to true.
@


1.199
log
@Stochastic Implosion
@
text
@d69 1
d143 1
d188 1
d422 4
@


1.198
log
@Stochastic Implosion
@
text
@d245 4
a260 1
      virtual void       passPreRefs    ();
@


1.197
log
@Stochastic Implosion
@
text
@d259 1
a259 1
      virtual void       importOptSoln  ();
d287 7
@


1.196
log
@Stochastic Implosion
@
text
@a38 2
      friend class WitHeurAccess;

@


1.195
log
@Stochastic Implosion
@
text
@d279 10
d297 5
@


1.194
log
@Stochastic Implosion
@
text
@a38 1
      friend class WitPostAccess;
d240 12
d275 4
@


1.193
log
@ASAP Pegging Order.
@
text
@d244 8
a251 7
      virtual bool       inserted      ();
      virtual WitMsgFrag classMsgFrag  ();
      virtual void       copySelfInto  (WitCompMgr * theCompMgr);
      virtual void       recount       ();
      virtual void       passPreRefs   ();
      virtual void       unpreprocess  ();
      virtual void       importOptSoln ();
@


1.192
log
@ASAP pegging order
@
text
@a112 1
      accessFunc (bool,                       allowAsapPip)
a234 1
      void setAllowAsapPip   (bool);
a598 5
      bool allowAsapPip_;
         //
         // ASAP pegging order for PIP will be allowed, iff allowAsapPip_ is
         // true.

@


1.191
log
@ASAP Pegging Order
@
text
@d113 1
d236 1
d601 5
@


1.190
log
@ASAP Pegging Order
@
text
@a112 1
      accessFunc (bool,                       useNewMatPgg)
a234 1
      void setUseNewMatPgg   (bool);
a598 4
      bool useNewMatPgg_;
         //
         // If true, PIP will use the new algorithm for Material pegging.

@


1.189
log
@Stochastic Implosion
@
text
@d113 1
d236 1
d601 4
@


1.188
log
@Stochastic Implosion
@
text
@d244 7
a250 7
      virtual bool       inserted       ();
      virtual WitMsgFrag classMsgFrag   ();
      virtual void       copySelfInto   (WitCompMgr * theCompMgr);
      virtual void       recount        ();
      virtual void       passPreRefs    ();
      virtual void       unpreprocess   ();
      virtual void       acquireOptSoln ();
@


1.187
log
@Stochastic Implosion
@
text
@a248 1
      virtual void       importPreData  ();
@


1.186
log
@Stochastic Implosion
@
text
@d248 1
@


1.185
log
@Stochastic Implosion
@
text
@a38 1
      friend class WitPreAccess;
@


1.184
log
@Stochastic Implosion
@
text
@d249 1
@


1.183
log
@Stochastic Implosion
@
text
@d245 6
a250 5
      virtual bool       inserted     ();
      virtual WitMsgFrag classMsgFrag ();
      virtual void       copySelfInto (WitCompMgr * theCompMgr);
      virtual void       recount      ();
      virtual void       unpreprocess ();
a257 6
      void importOptImpSoln ();
         //
         // Imports this GlobalComp's portion of the optimizing implosion
         // solution.
         // Valid only when optimizing implosion is exporting its solution.

@


1.182
log
@Stochastic Implosion
@
text
@d245 1
a245 4
      virtual bool inserted ();
         //
         // Override from class Component.

d247 3
d251 1
a251 9
         // Override from class Component.

      virtual void copySelfInto (WitCompMgr * theCompMgr);
         //
         // Override from class Component.

      virtual void recount ();
         //
         // Override from class Component.
a256 4
      virtual void unpreprocess ();
         //
         // Override from class Component.

@


1.181
log
@Stochastic Implosion
@
text
@a41 1
      friend class WitOptAccess;
d269 1
a269 1
      virtual void importOptImpSoln (WitPeriod);
d271 3
a273 1
         // Override from class Component.
@


1.180
log
@Stochastic Implosion
@
text
@d21 1
d64 55
a118 55
      accessFunc (const WitString &,            title)
      accessFunc (int,                          nPeriods)
      accessFunc (bool,                         independentOffsets)
      accessFunc (bool,                         execEmptyBom)
      accessFunc (int,                          hashTableSize)
      accessFunc (bool,                         roundReqVols)
      accessFunc (int,                          outputPrecision)
      accessFunc (bool,                         computeCriticalList)
      accessFunc (bool,                         pgdCritListMode)
      accessFunc (bool,                         wit34Compatible)
      accessFunc (bool,                         useFocusHorizons)
      accessFunc (bool,                         localBuildAhead)
      accessFunc (bool,                         multiExec)
      accessFunc (bool,                         twoWayMultiExec)
      accessFunc (bool,                         localMultiExec)
      accessFunc (int,                          equitability)
      accessFunc (bool,                         forcedMultiEq)
      accessFunc (bool,                         autoPriority)
      accessFunc (bool,                         skipFailures)
      accessFunc (bool,                         multiRoute)
      accessFunc (bool,                         truncOffsets)
      accessFunc (double,                       lotSizeTol)
      accessFunc (double,                       expCutoff)
      accessFunc (bool,                         penExec)
      accessFunc (bool,                         tieBreakPropRt)
      accessFunc (bool,                         stockRealloc)
      accessFunc (bool,                         stockReallocation)
      accessFunc (bool,                         srSelSplit)
      accessFunc (bool,                         respectStockSLBs)
      accessFunc (bool,                         prefHighStockSLBs)
      accessFunc (bool,                         perfPegging) 
      accessFunc (bool,                         selSplit)
      accessFunc (bool,                         nonMrSelSplit)
      accessFunc (bool,                         userHeurStart)
      accessFunc (bool,                         pipSeqFromHeur)
      accessFunc (bool,                         newPipPggOrder) 
      accessFunc (bool,                         highPrecisionWD)
      accessFunc (bool,                         nstnResidual)
      accessFunc (bool,                         minimalExcess)
      accessFunc (bool,                         readDataMsgs)
      accessFunc (bool,                         printEqAlloc)
      accessFunc (bool,                         reportIncViol)
      accessFunc (int,                          selPrintLevel)
      accessFunc (bool,                         twmeByDemand)
      accessFunc (double,                       splitTol)
      accessFunc (double,                       splitRes)
      accessFunc (int,                          splitItrUB)
      accessFunc (bool,                         pauses)
      accessFunc (bool,                         prtPipMaxRatio)
      accessFunc (bool,                         printDebug)
      accessFunc (bool,                         printExcessVol)
      accessFunc (bool,                         lotSizesExist)
      accessFunc (const WitList <WitPartPer> &, criticalList)
      accessFunc (const WitList <WitPclEl>   &, pgdCritList)
      accessFunc (bool,                         feasible)
d637 1
a637 1
      WitList <WitPartPer> criticalList_;
d640 1
a640 5
         // If computeCriticalList () == true, this is computed
         // by implosion. This is a list of all possible PartPers,
         // thePartPer, such that WIT considers that there is a "potential"
         // to improve the solution by increasing the supply of the Part in the
         // period. The list is sorted in order of decreasing "potential".
@


1.179
log
@Stochastic Implosion.
@
text
@d269 4
@


1.178
log
@[disallowed scrap]
@
text
@d249 4
@


1.177
log
@[disallowing scrap]
@
text
@a113 1
      accessFunc (bool,                         allowSA)
a235 1
      void setAllowSA        (bool);
a605 4
      bool allowSA_;
         //
         // thePart_->scrapAllowed_ cannot be set unless allowSA is true.

@


1.176
log
@[disallowed backlog]
@
text
@d114 1
d237 1
d608 4
@


1.175
log
@[disallowed backlog]
@
text
@a113 1
      accessFunc (bool,                         allowDBL)
a235 1
      void setAllowDBL       (bool);
a605 4
      bool allowDBL_;
         //
         // theDemand->disallowBackLog_ can be set, iff allowDBL_ is true.

@


1.174
log
@[disallowed backlog]
@
text
@d114 1
a114 1
      accessFunc (bool,                         allowBLA)
d237 1
a237 1
      void setAllowBLA       (bool);
d608 1
a608 1
      bool allowBLA_;
d610 1
a610 1
         // theDemand->backLogAllowed_ can be set, iff allowBLA_ is true.
@


1.173
log
@[disallowed backlog]
@
text
@a296 4
      static void transmitDMPs ();
         //
         // See comment on transmitAllDMPs in CompMgr.h.

@


1.172
log
@[disallowed backlog]
@
text
@d38 1
@


1.171
log
@Rescinded all changed made since 1/31/07.
@
text
@d38 4
@


1.170
log
@[disallowed backlog]
@
text
@a20 1
#include <Restricted.h>
a57 2
      accessFunc (bool,                         lotSizesExist)

d110 1
d258 4
a295 8
      //------------------------------------------------------------------------
      // Restricted public member data.
      //------------------------------------------------------------------------

      WitPreRestricted <bool> lotSizesExist_;
         //
         // true iff any minLotSize or incLotSize has a positive value.

d622 8
@


1.169
log
@[backlog avoidance]
@
text
@d21 1
d59 2
a112 1
      accessFunc (bool,                         lotSizesExist)
a259 4
      virtual void unpreprocess ();
         //
         // Override from class Component.

d294 8
a627 8
      // Data set by preprocessing.
      //------------------------------------------------------------------------

      bool lotSizesExist_;
         //
         // true iff any minLotSize or incLotSize has a positive value.

      //------------------------------------------------------------------------
@


1.168
log
@[backlog avoidance]
@
text
@a96 1
      accessFunc (bool,                         backlogAllowed)
a170 1
      defaultValue (bool         defBacklogAllowed,      true)
a214 1
      void setBacklogAllowed      (bool);
a543 4
      bool backlogAllowed_;
         //
         // Backlogging of demand is allowed, iff backlogAllowed_ is true.

d609 1
a609 1
         // backLogAllowed_ can be set, iff allowBLA_ is true.
@


1.167
log
@witCopy<Object>Data
@
text
@d97 1
d110 1
d172 1
d217 1
d235 1
d547 4
d614 4
@


1.166
log
@witCopy<Object>Data
@
text
@a289 5
      void checkForCopyObjData (WitGlobalComp * origGlobalComp);
         //
         // Verifies that the necessary attributes of this GlobalComp and
         // origGlobalComp match for a call to a witCopy<Object>Data function.

@


1.165
log
@witCopy<Object>Data
@
text
@d290 5
@


1.164
log
@witCopy<Object>Data
@
text
@a108 1
      accessFunc (bool,                         allowCopyObjData)
a231 2
      void setAllowCopyObjData (bool);
 
a615 9
      // Data set by witIssueDevCommand.
      //------------------------------------------------------------------------

      bool allowCopyObjData_;
         //
         // The calling witCopy<Object>Data is only allowed if allowCopyObjData_
         // is true.

      //------------------------------------------------------------------------
@


1.163
log
@External opt implosion.
@
text
@d109 1
d232 2
d619 9
@


1.162
log
@external opt implosion.
@
text
@d26 2
a27 1
// Responsible for the global attributes of a Problem.
@


1.161
log
@App controlled opt implosion.
@
text
@a258 4
      void unpostprocess ();
         //
         // Puts this GlobalComp into its unpostprocessed state.

@


1.160
log
@Heuristic search increment.
@
text
@a546 1
      // Set by ParamMgr.
@


1.159
log
@Heuristic search increment.
@
text
@a95 1
      accessFunc (double,                       heurSearchInc)
a168 1
      defaultValue (double       defHeurSearchInc,       1.0)
a212 1
      void setHeurSearchInc       (double);
a544 5
      double heurSearchInc_;
         //
         // Increment for searches by the heuristic.
         // Range: [0.001, +inf).

@


1.158
log
@App controlled opt implosion.
@
text
@d96 1
d170 1
d215 1
d548 5
@


1.157
log
@NSTN residual.
@
text
@a106 1
      accessFunc (bool,                         allowIntVars)
a228 1
      void setAllowIntVars   (bool);
a603 4
      bool allowIntVars_;
         //
         // Integer variables are allowed if allowIntVars_ is true.

@


1.156
log
@NSTN residualVol.
@
text
@a107 1
      accessFunc (bool,                         allowNstnRes)
a230 1
      void setAllowNstnRes   (bool);
a609 4
      bool allowNstnRes_;
         //
         // nstnResidual and minimalExcess can be set iff allowNstnRes_ is true.

@


1.155
log
@NSTN residualVol.
@
text
@d95 1
d170 1
d214 1
d539 9
a547 2
         // true, iff residualVol and excessVol are to be computed an a
         // no-sooner-than-necessary basis.
d614 1
a614 1
         // nstnResidual can be set iff allowNstnRes_ is true.
@


1.154
log
@NSTN residualVols.
@
text
@d108 1
d230 1
d606 5
@


1.153
log
@Opt implosion with integrality constraints.
@
text
@d94 1
d107 1
d167 1
d210 1
d228 1
d532 5
d598 5
a602 1
         // Integer variables are allowed if allowIntVars is true.
@


1.152
log
@GPIP migration.
@
text
@d105 1
d223 1
d586 4
@


1.151
log
@GPIP migration.
@
text
@d103 1
a103 1
      accessFunc (bool,                         prtGpipMaxRatio)
d211 11
a221 11
      void setReadDataMsgs    (bool);
      void setPrintEqAlloc    (bool);
      void setReportIncViol   (bool);
      void setSelPrintLevel   (int);
      void setTwmeByDemand    (bool);
      void setSplitTol        (double);
      void setSplitRes        (double);
      void setSplitItrUB      (int);
      void setPauses          (bool);
      void setPrtGpipMaxRatio (bool);
      void setPrintDebug      (bool);
d576 1
a576 1
      bool prtGpipMaxRatio_;
d578 1
a578 1
         // If true, print the GPIP max pegging ratio data.
@


1.150
log
@GPIP migration
@
text
@a91 1
      accessFunc (bool,                         groupPipMode) 
a161 1
      defaultValue (bool         defGroupPipMode,        true)
a515 4
      bool groupPipMode_;
         //
         // true, iff PIP is to operate be in Group Post-Implosion Pegging mode.

@


1.149
log
@Changed the default value of groupPipMode to true.
@
text
@a205 1
      void setGroupPipMode        (bool);
@


1.148
log
@Replaced WIT's hash tables with std:maps.
@
text
@d163 1
a163 1
      defaultValue (bool         defGroupPipMode,        false)
@


1.147
log
@Changed the default value of newPipPggOrder to false.
@
text
@d358 1
a358 1
         // The size of all HashTables for myProblem ().
@


1.146
log
@New PIP pegging order.
@
text
@d164 1
a164 1
      defaultValue (bool         defNewPipPggOrder,      false)
@


1.145
log
@New PIP pegging order.
@
text
@a105 1
      accessFunc (bool,                         allowGpipNpo)
a224 1
      void setAllowGpipNpo    (bool);
a590 4
      bool allowGpipNpo_;
         //
         // If true, allow GPIP with the new pegging order.

@


1.144
log
@New PIP pegging order.
@
text
@d106 1
d226 1
d593 4
@


1.143
log
@New PIP pegging order.
@
text
@a105 1
      accessFunc (bool,                         allowNewPipOrd)
a224 1
      void setAllowNewPipOrd  (bool);
a590 4
      bool allowNewPipOrd_;
         //
         // newPipPggOrder_ may be set iff allowNewPipOrd_ is true.

@


1.142
log
@New PIP pegging order.
@
text
@d105 1
a105 1
      accessFunc (bool,                         printGpip)
d225 1
a225 1
      void setPrintGpip       (bool);
d589 1
a589 1
      bool printGpip_;
d591 1
a591 1
         // If true, do debug printing of Group Post-Implosion Pegging.
@


1.141
log
@Updated the copyright date on all source files.
@
text
@d93 1
d106 1
d165 1
d208 1
d226 1
d525 4
d593 4
@


1.140
log
@GPIP
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.139
log
@GPIP
@
text
@a102 1
      accessFunc (bool,                         allowGpipMode)
a219 1
      void setAllowGpipMode   (bool);
a575 4
      bool allowGpipMode_;
         //
         // groupPipMode_ is allowed to be altered iff allowGpipMode_ is true.

@


1.138
log
@GPIP
@
text
@d104 1
d212 12
a223 11
      void setReadDataMsgs  (bool);
      void setPrintEqAlloc  (bool);
      void setReportIncViol (bool);
      void setSelPrintLevel (int);
      void setTwmeByDemand  (bool);
      void setSplitTol      (double);
      void setSplitRes      (double);
      void setSplitItrUB    (int);
      void setPauses        (bool);
      void setAllowGpipMode (bool);
      void setPrintGpip     (bool);
d582 4
@


1.137
log
@[shared-resource pegging]
@
text
@d92 1
a92 1
      accessFunc (bool,                         srpMode) 
d103 2
a104 2
      accessFunc (bool,                         allowSrpMode)
      accessFunc (bool,                         printSrpDB)
d162 1
a162 1
      defaultValue (bool         defSrpMode,             false)
d204 1
a204 1
      void setSrpMode             (bool);
d220 2
a221 2
      void setAllowSrpMode  (bool);
      void setPrintSrpDB    (bool);
d516 1
a516 1
      bool srpMode_;
d518 1
a518 1
         // true, iff PIP is to operate be in Shared-Resource Pegging mode.
d576 1
a576 1
      bool allowSrpMode_;
d578 1
a578 1
         // srpMode_ is allowed to be altered iff allowSrpMode_ is true.
d580 1
a580 1
      bool printSrpDB_;
d582 1
a582 1
         // If true, do debug printing of Shared-Resource Pegging.
@


1.136
log
@[shared-resource pegging]
@
text
@a104 1
      accessFunc (bool,                         newPip)
a221 1
      void setNewPip        (bool);
a583 4
      bool newPip_;
         //
         // If true, use new PIP classes.

@


1.135
log
@[shared-resource pegging]
@
text
@d105 1
d223 1
d586 4
@


1.134
log
@Began [shared-resource pegging]
@
text
@d104 1
d221 1
d580 4
@


1.133
log
@[multi-thread]
@
text
@d92 1
d103 1
d161 1
d203 1
d219 1
d514 4
d574 4
@


1.132
log
@[multi-thread]
@
text
@a243 7
      virtual void loadPre  ();
      virtual void loadPost ();
      virtual void loadHeur ();
      virtual void loadOpt  ();
         //
         // Override from class Component.

d278 4
@


1.131
log
@Cut-over to the new interpretation of pipShare.
@
text
@d519 1
a519 1
      // Set by AloneRun.
d571 1
a571 1
         // Set by AloneRun.
@


1.130
log
@Began work on the new interpretation of pipShare.
@
text
@a101 1
      accessFunc (bool,                         newPipShare)
a214 1
      void setNewPipShare   (bool);
a567 5
      bool newPipShare_;
         //
         // If true, PIP will use the new interpretation of the pipShare
         // attribute.

@


1.129
log
@Trivial update.
@
text
@d102 1
d216 1
d570 5
@


1.128
log
@Vector PropRtg.
@
text
@a101 1
      accessFunc (bool,                         allowVecPR)
a214 1
      void setAllowVecPR    (bool);
a567 4
      bool allowVecPR_;
         //
         // The vector attribute propRtg can only be set if allowVecPR_ is true.

@


1.127
log
@Vector propRt.
@
text
@d572 1
a572 1
         // The vector attribute propRt can only be used if allowVecPR_ is true.
@


1.126
log
@Pegged Critical List
@
text
@d102 1
d216 1
d570 4
@


1.125
log
@Pegged Critical List
@
text
@d264 4
a313 4
      void clearPgdCritList ();
         //
         // Clears pgdCritList_.

@


1.124
log
@Pegged Critical List.
@
text
@d310 4
@


1.123
log
@Pegged Critical List.
@
text
@a101 1
      accessFunc (bool,                         allowPCL)
a214 1
      void setAllowPCL      (bool);
a563 4
      bool allowPCL_;
         //
         // pgdCritListMode can be set only if allowPCL is true.

@


1.122
log
@Pegged Critical List.
@
text
@d105 1
@


1.121
log
@pegged Critical List.
@
text
@d65 1
a65 1
      accessFunc (bool,                         pgdCritListNeeded)
d132 1
a132 1
      defaultValue (bool         defPgdCritListNeeded,   false)
d173 1
a173 1
      void setPgdCritListNeeded   (bool);
d366 1
a366 1
      bool pgdCritListNeeded_;
d567 1
a567 1
         // pgdCritListNeeded can be set only if allowPCL is true.
@


1.120
log
@Pegged Critical List
@
text
@d261 4
d601 8
@


1.119
log
@Pegged Critical List.
@
text
@d65 1
a65 1
      accessFunc (bool,                         compPgdCritList)
d132 1
a132 1
      defaultValue (bool         defCompPgdCritList,     false)
d173 1
a173 1
      void setCompPgdCritList     (bool);
d362 1
a362 1
      bool compPgdCritList_;
d563 1
a563 1
         // compPgdCritList can be set only if allowPCL is true.
@


1.118
log
@Changed terminology from "low priority proportionate routing" to
"tie breaking proportionate routing".
@
text
@d65 1
d102 1
d132 1
d173 1
d215 1
d362 4
d561 4
@


1.117
log
@Low-Pri Prop-Rt.
@
text
@d80 1
a80 1
      accessFunc (bool,                         lowPriPropRt)
d145 1
a145 1
      defaultValue (bool         defLowPriPropRt,        false)
d185 1
a185 1
      void setLowPriPropRt        (bool);
d441 1
a441 1
      bool lowPriPropRt_;
@


1.116
log
@Low-Pri Prop-Rt.
@
text
@a100 1
      accessFunc (bool,                         allowLPPR)
a210 1
      void setAllowLPPR     (bool);
a551 4
      bool allowLPPR_;
         //
         // The lowPriPropRt attribute can be set only if allowLPPR_ is true.

@


1.115
log
@Low-Pri Prop-Rt.
@
text
@a101 1
      accessFunc (bool,                         newPropRt)
a212 1
      void setNewPropRt     (bool);
a557 5
      bool newPropRt_;
         //
         // The new version of proportionate routing will be used only if
         // newPropRt_ is true.

@


1.114
log
@Low-Pri Prop-Rt.
@
text
@d102 1
d214 1
d560 5
@


1.113
log
@Continued implmentation of low priority proportionate routing.
@
text
@d101 1
a101 1
      accessFunc (bool,                         allowLowPriPR)
d212 1
a212 1
      void setAllowLowPriPR (bool);
d554 1
a554 1
      bool allowLowPriPR_;
d556 1
a556 2
         // The lowPriPropRt attribute can be set only if allowLowPriPR_ is
         // true.
@


1.112
log
@Continued implementation of pen-exec override of prop-rt.
@
text
@d80 1
a80 1
      accessFunc (bool,                         penExecOverPropRt)
d101 1
a101 1
      accessFunc (bool,                         allowPeOverPr)
d146 1
a146 1
      defaultValue (bool         defPenExecOverPropRt,   false)
d186 1
a186 1
      void setPenExecOverPropRt   (bool);
d212 1
a212 1
      void setAllowPeOverPr (bool);
d443 1
a443 1
      bool penExecOverPropRt_;
d554 1
a554 1
      bool allowPeOverPr_;
d556 2
a557 2
         // The penExecOverPropRt attribute can be set only if allowPeOverPr_
         // is true.
@


1.111
log
@Began work on [propRouting as penExec tie-breaker].
@
text
@d101 1
a101 1
      accessFunc (bool,                         peOverPrAllowed)
d203 10
a212 10
      void setReadDataMsgs    (bool);
      void setPrintEqAlloc    (bool);
      void setReportIncViol   (bool);
      void setSelPrintLevel   (int);
      void setTwmeByDemand    (bool);
      void setSplitTol        (double);
      void setSplitRes        (double);
      void setSplitItrUB      (int);
      void setPauses          (bool);
      void setPeOverPrAllowed (bool);
d554 1
a554 1
      bool peOverPrAllowed_;
d556 1
a556 1
         // The penExecOverPropRt attribute can be set only if peOverPrAllowed_
@


1.110
log
@PIP.
@
text
@d80 1
d101 1
d146 1
d186 1
d203 10
a212 9
      void setReadDataMsgs  (bool);
      void setPrintEqAlloc  (bool);
      void setReportIncViol (bool);
      void setSelPrintLevel (int);
      void setTwmeByDemand  (bool);
      void setSplitTol      (double);
      void setSplitRes      (double);
      void setSplitItrUB    (int);
      void setPauses        (bool);
d443 7
d554 5
@


1.109
log
@PIP.
@
text
@a99 1
      accessFunc (bool,                         allowMultiPip)
a207 1
      void setAllowMultiPip (bool);
a550 5

      bool allowMultiPip_;
         //
         // PIP with multiple-explodeable BopEntries is allowed, iff
         // allowMultiPip_ is true.
@


1.108
log
@PIP.
@
text
@d100 1
a100 1
      accessFunc (bool,                         allowMoPip)
d209 1
a209 1
      void setAllowMoPip    (bool);
d554 1
a554 1
      bool allowMoPip_;
d556 2
a557 2
         // PIP with multiple-explodeable BopEntries is allowed, iff allowMoPip_
         // is true.
@


1.107
log
@Double Precision.
@
text
@d100 1
d209 1
d553 5
@


1.106
log
@Double Precision.
@
text
@d90 1
d154 1
d193 1
d485 5
@


1.105
log
@Double Precision.
@
text
@d58 1
a58 1
      accessFunc (const int &,                  nPeriods)
a101 1
      accessFunc (const WitPeriod &,            lastPeriod)
a573 8

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitPeriod lastPeriod_;
         //
         // The last period in myProblem (), i.e., nPeriods () - 1.
@


1.104
log
@Double Precision.
@
text
@d205 2
a206 2
      void setPauses        (bool)
;
@


1.103
log
@Double Precision.
@
text
@a108 2
      bool doubleMode ();

a191 1
      void setDoubleMode          (bool);
@


1.102
log
@Double Precision.
@
text
@d95 2
a96 2
      accessFunc (float,                        splitTol)
      accessFunc (float,                        splitRes)
d205 2
a206 2
      void setSplitTol      (float);
      void setSplitRes      (float);
d267 1
a267 1
      float tempParAsFloat (int index);
d269 1
a269 1
         // Returns tempPar #index converted to a float.
d519 1
a519 1
      float splitTol_;
d523 1
a523 1
      float splitRes_;
@


1.101
log
@Continued double precision.
@
text
@d109 2
d194 1
@


1.100
log
@Continued double precision.
@
text
@d77 2
a78 2
      accessFunc (StrDbl,                       lotSizeTol)
      accessFunc (StrDbl,                       expCutoff)
d141 2
a142 2
      defaultValue (StrDbl       defLotSizeTol,          1.0E-5)
      defaultValue (StrDbl       defExpCutoff,           0.01)
d179 2
a180 2
      void setLotSizeTol          (StrDbl);
      void setExpCutoff           (StrDbl);
d421 1
a421 1
      StrDbl lotSizeTol_;
d426 1
a426 1
      StrDbl expCutoff_;
@


1.99
log
@Removed the "pip" attribute.
@
text
@d78 1
a78 1
      accessFunc (float,                        expCutoff)
d142 1
a142 1
      defaultValue (float        defExpCutoff,           0.01F)
d180 1
a180 1
      void setExpCutoff           (float);
d426 1
a426 1
      float expCutoff_;
@


1.98
log
@Continued double precision.
@
text
@a85 1
      accessFunc (bool,                         pip) 
a149 1
      defaultValue (bool         defPip,                 false)
a187 1
      void setPip                 (bool);
a464 4

      bool pip_;
         //
         // true, iff post-implosion pegging is to be performed.
@


1.97
log
@Continued double precision.
@
text
@d77 1
a77 1
      accessFunc (double,                       lotSizeTol)
d142 1
a142 1
      defaultValue (double       defLotSizeTol,          1.0E-5)
d181 1
a181 1
      void setLotSizeTol          (double);
d424 1
a424 1
      double lotSizeTol_;
@


1.96
log
@Began implementation of double precision.
@
text
@d77 1
a77 1
      accessFunc (float,                        lotSizeTol)
d142 1
a142 1
      defaultValue (float        defLotSizeTol,          1.0E-5F)
d181 1
a181 1
      void setLotSizeTol          (float);
d424 1
a424 1
      float lotSizeTol_;
@


1.95
log
@Continued implementation of PIP.
@
text
@d99 1
d208 2
a209 1

d535 6
@


1.94
log
@Continued implementation of PIP.
@
text
@d90 1
a90 1
      accessFunc (bool,                         heurPipSeq)
d154 1
a154 1
      defaultValue (bool         defHeurPipSeq,          false)
d193 1
a193 1
      void setHeurPipSeq          (bool);
d485 1
a485 1
      bool heurPipSeq_;
@


1.93
log
@Continued implementation of PIP.
@
text
@a90 4
      accessFunc (const WitString &,            pipSeqPartName)
      accessFunc (const WitString &,            pipSeqDemandName)
      accessFunc (int,                          pipSeqShipPeriod)
      accessFunc (float,                        pipSeqIncShipVol)
a154 4
      defaultValue (const char * defPipSeqPartName,      "")
      defaultValue (const char * defPipSeqDemandName,    "")
      defaultValue (int          defPipSeqShipPeriod,    0)
      defaultValue (float        defPipSeqIncShipVol,    0.0)
a193 4
      void setPipSeqPartName      (const char *);
      void setPipSeqDemandName    (const char *);
      void setPipSeqShipPeriod    (int);
      void setPipSeqIncShipVol    (float);
a487 21

      //------------------------------------------------------------------------
      // Pseudo attributes used by the DataReader to append to the PIP shipment
      // sequence.
      //------------------------------------------------------------------------

      WitString pipSeqPartName_;
         //
         // partName of the Demand to append to the PIP shipment sequence.

      WitString pipSeqDemandName_;
         //
         // demandName of the Demand to append to the PIP shipment sequence.

      int pipSeqShipPeriod_;
         //
         // shipPeriod to append to the PIP shipment sequence.

      float pipSeqIncShipVol_;
         //
         // incShipVol to append to the PIP shipment sequence.
@


1.92
log
@Continued implementation of PIP.
@
text
@d91 4
d159 4
d202 4
d500 21
@


1.91
log
@Continued implementation of PIP.
@
text
@a98 1
      accessFunc (bool,                         allowPipSeq)
a206 1
      void setAllowPipSeq   (bool);
a532 4

      bool allowPipSeq_;
         //
         // If true, the PIP shipment sequence capability is enabled.
@


1.90
log
@Continued implementation of PIP.
@
text
@d90 1
d99 1
a99 2
      accessFunc (bool,                         revPipSeq)
      accessFunc (bool,                         allowShipSeq)
d155 1
d194 1
d208 1
a208 2
      void setRevPipSeq     (bool);
      void setAllowShipSeq  (bool);
d487 4
d536 1
a536 5
      bool revPipSeq_;
         //
         // If true, the shipment sequence for PIP will be reversed.

      bool allowShipSeq_;
@


1.89
log
@Continued implementation of PIP.
@
text
@d57 47
a103 46
      accessFunc (const WitString &,              title)
      accessFunc (const int &,                    nPeriods)
      accessFunc (bool,                           independentOffsets)
      accessFunc (bool,                           execEmptyBom)
      accessFunc (int,                            hashTableSize)
      accessFunc (bool,                           roundReqVols)
      accessFunc (int,                            outputPrecision)
      accessFunc (bool,                           computeCriticalList)
      accessFunc (bool,                           wit34Compatible)
      accessFunc (bool,                           useFocusHorizons)
      accessFunc (bool,                           localBuildAhead)
      accessFunc (bool,                           multiExec)
      accessFunc (bool,                           twoWayMultiExec)
      accessFunc (bool,                           localMultiExec)
      accessFunc (int,                            equitability)
      accessFunc (bool,                           forcedMultiEq)
      accessFunc (bool,                           autoPriority)
      accessFunc (bool,                           skipFailures)
      accessFunc (bool,                           multiRoute)
      accessFunc (bool,                           truncOffsets)
      accessFunc (float,                          lotSizeTol)
      accessFunc (float,                          expCutoff)
      accessFunc (bool,                           penExec)
      accessFunc (bool,                           stockRealloc)
      accessFunc (bool,                           stockReallocation)
      accessFunc (bool,                           srSelSplit)
      accessFunc (bool,                           respectStockSLBs)
      accessFunc (bool,                           prefHighStockSLBs)
      accessFunc (bool,                           perfPegging) 
      accessFunc (bool,                           pip) 
      accessFunc (bool,                           selSplit)
      accessFunc (bool,                           nonMrSelSplit)
      accessFunc (bool,                           userHeurStart)
      accessFunc (bool,                           readDataMsgs)
      accessFunc (bool,                           printEqAlloc)
      accessFunc (bool,                           reportIncViol)
      accessFunc (int,                            selPrintLevel)
      accessFunc (bool,                           twmeByDemand)
      accessFunc (float,                          splitTol)
      accessFunc (float,                          splitRes)
      accessFunc (int,                            splitItrUB)
      accessFunc (bool,                           revPipSeq)
      accessFunc (bool,                           lotSizesExist)
      accessFunc (const WitList <WitDatedPart> &, criticalList)
      accessFunc (bool,                           feasible)
      accessFunc (const WitPeriod &,              lastPeriod)
d207 1
d535 4
d561 1
a561 1
      WitList <WitDatedPart> criticalList_;
d565 4
a568 5
         // by implosion. This is a list of all possible DatedParts,
         // theDP, such that WIT considers that there is a "potential"
         // to improve the solution by increasing the supply of part
         // theDP->myPart () in period theDP->myPeriod ().
         // The list is sorted in order of decreasing "potential".
@


1.88
log
@Continued implementation of PIP.
@
text
@a98 1
      accessFunc (bool,                           allowSideEffs)
a205 1
      void setAllowSideEffs (bool);
a531 4

      bool allowSideEffs_;
         //
         // If true, unexplodable side-effects will be allowed when using PIP.
@


1.87
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d99 1
d207 1
d534 4
@


1.86
log
@Continued implementation of post-implosion pegging.
@
text
@d86 1
a86 1
      accessFunc (bool,                           perfPIPegging) 
a97 1
      accessFunc (bool,                           allowPIP)
d150 1
a150 1
      defaultValue (bool         defPerfPIPegging,       false)
d188 1
a188 1
      void setPerfPIPegging       (bool);
a204 1
      void setAllowPIP      (bool);
d466 1
a466 1
      bool perfPIPegging_;
a527 4

      bool allowPIP_;
         //
         // perfPIPegging can only be set if allowPIP is true.
@


1.85
log
@Continued implementation of post-implosion pegging.
@
text
@d99 1
d207 1
d534 4
@


1.84
log
@Began implementation of post-implosion pegging.
@
text
@d86 1
a86 1
      accessFunc (bool,                           piPegging) 
d150 1
a150 1
      defaultValue (bool         defPiPegging,           false)
d188 1
a188 1
      void setPiPegging           (bool);
d464 1
a464 1
         // true, iff pegging is to be performed.
d466 1
a466 1
      bool piPegging_;
d468 1
a468 4
         // If perfPegging_ is true and piPegging_ is true,
         //    post-implosion pegging is to be performed.
         // If perfPegging_ is true and piPegging_ is false,
         //    concurrent pegging is to be performed by the heuristic.
d531 1
a531 1
         // piPegging can only be set if allowPIP is true.
@


1.83
log
@Continued implementation of opt with COIN.
@
text
@d86 1
d98 1
d150 1
d188 1
d205 1
d464 8
a471 1
         // true, iff pegging is to be performed by heuristic allocation.
d531 4
@


1.82
log
@Continued implementation of opt with COIN.
@
text
@a96 1
      accessFunc (bool,                           useCoin)
a200 1
      void setUseCoin       (bool);
a518 5

      bool useCoin_;
         //
         // If true,  opt implosion is to use the COIN solvers.
         // If false, opt implosion is to use OSL.
@


1.81
log
@Continued implementation of proportionate routing.
@
text
@d97 1
d202 1
d521 5
@


1.80
log
@Continued implementation of proportionate routing.
@
text
@a96 1
      accessFunc (bool,                           allowPR)
a200 1
      void setAllowPR       (bool);
a518 4

      bool allowPR_;
         //
         // Proportionate routing can be used only if allowPR_ is TRUE.
@


1.79
log
@Continued implementation of proportionate routing.
@
text
@a88 1
      accessFunc (bool,                           propRouting)
a151 1
      defaultValue (bool         defPropRouting,         false)
a188 1
      void setPropRouting         (bool);
a475 4

      bool propRouting_;
         //
         // true, iff the proportionate routing technique is to be performed.
@


1.78
log
@Began implementation of Proportionate Routing.
@
text
@d89 1
d153 1
d191 1
d480 4
d531 1
a531 1
         // expFactor and propRoute can be set iff allowPR_ is TRUE.
@


1.77
log
@Attempt to fix a syntax error from the MS compiler in Pre.C.
@
text
@d97 1
d202 1
d521 4
@


1.76
log
@Internal changes.
@
text
@d139 2
a140 2
      defaultValue (float        defLotSizeTol,          1.0E-5)
      defaultValue (float        defExpCutoff,           0.01)
@


1.75
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d59 2
a60 2
      accessFunc (WitBoolean,                     independentOffsets)
      accessFunc (WitBoolean,                     execEmptyBom)
d62 1
a62 1
      accessFunc (WitBoolean,                     roundReqVols)
d64 7
a70 7
      accessFunc (WitBoolean,                     computeCriticalList)
      accessFunc (WitBoolean,                     wit34Compatible)
      accessFunc (WitBoolean,                     useFocusHorizons)
      accessFunc (WitBoolean,                     localBuildAhead)
      accessFunc (WitBoolean,                     multiExec)
      accessFunc (WitBoolean,                     twoWayMultiExec)
      accessFunc (WitBoolean,                     localMultiExec)
d72 5
a76 5
      accessFunc (WitBoolean,                     forcedMultiEq)
      accessFunc (WitBoolean,                     autoPriority)
      accessFunc (WitBoolean,                     skipFailures)
      accessFunc (WitBoolean,                     multiRoute)
      accessFunc (WitBoolean,                     truncOffsets)
d79 13
a91 13
      accessFunc (WitBoolean,                     penExec)
      accessFunc (WitBoolean,                     stockRealloc)
      accessFunc (WitBoolean,                     stockReallocation)
      accessFunc (WitBoolean,                     srSelSplit)
      accessFunc (WitBoolean,                     respectStockSLBs)
      accessFunc (WitBoolean,                     prefHighStockSLBs)
      accessFunc (WitBoolean,                     perfPegging) 
      accessFunc (WitBoolean,                     selSplit)
      accessFunc (WitBoolean,                     nonMrSelSplit)
      accessFunc (WitBoolean,                     userHeurStart)
      accessFunc (WitBoolean,                     readDataMsgs)
      accessFunc (WitBoolean,                     printEqAlloc)
      accessFunc (WitBoolean,                     reportIncViol)
d93 1
a93 1
      accessFunc (WitBoolean,                     twmeByDemand)
d97 1
a97 1
      accessFunc (WitBoolean,                     lotSizesExist)
d99 1
a99 1
      accessFunc (WitBoolean,                     feasible)
d102 1
a102 1
      inline WitBoolean oldSR ()
d121 2
a122 2
      defaultValue (WitBoolean   defIndependentOffsets,  witFALSE)
      defaultValue (WitBoolean   defExecEmptyBom,        witTRUE)
d124 1
a124 1
      defaultValue (WitBoolean   defRoundReqVols,        witFALSE)
d126 7
a132 7
      defaultValue (WitBoolean   defComputeCriticalList, witFALSE)
      defaultValue (WitBoolean   defWit34Compatible,     witFALSE)
      defaultValue (WitBoolean   defUseFocusHorizons,    witTRUE)
      defaultValue (WitBoolean   defLocalBuildAhead,     witFALSE)
      defaultValue (WitBoolean   defMultiExec,           witFALSE)
      defaultValue (WitBoolean   defTwoWayMultiExec,     witFALSE)
      defaultValue (WitBoolean   defLocalMultiExec,      witFALSE)
d134 5
a138 5
      defaultValue (WitBoolean   defForcedMultiEq,       witFALSE)
      defaultValue (WitBoolean   defAutoPriority,        witFALSE)
      defaultValue (WitBoolean   defSkipFailures,        witTRUE)
      defaultValue (WitBoolean   defMultiRoute,          witFALSE)
      defaultValue (WitBoolean   defTruncOffsets,        witFALSE)
d141 10
a150 10
      defaultValue (WitBoolean   defPenExec,             witFALSE)
      defaultValue (WitBoolean   defStockRealloc,        witFALSE)
      defaultValue (WitBoolean   defStockReallocation,   witFALSE)
      defaultValue (WitBoolean   defSrSelSplit,          witFALSE)
      defaultValue (WitBoolean   defRespectStockSLBs,    witFALSE)
      defaultValue (WitBoolean   defPrefHighStockSLBs,   witFALSE)
      defaultValue (WitBoolean   defPerfPegging,         witFALSE)
      defaultValue (WitBoolean   defSelSplit,            witFALSE)
      defaultValue (WitBoolean   defNonMrSelSplit,       witFALSE)
      defaultValue (WitBoolean   defUserHeurStart,       witFALSE)
d158 2
a159 2
      void setIndependentOffsets  (WitBoolean);
      void setExecEmptyBom        (WitBoolean);
d161 1
a161 1
      void setRoundReqVols        (WitBoolean);
d163 7
a169 7
      void setComputeCriticalList (WitBoolean);
      void setWit34Compatible     (WitBoolean);
      void setUseFocusHorizons    (WitBoolean);
      void setLocalBuildAhead     (WitBoolean);
      void setMultiExec           (WitBoolean);
      void setTwoWayMultiExec     (WitBoolean);
      void setLocalMultiExec      (WitBoolean);
d171 5
a175 5
      void setForcedMultiEq       (WitBoolean);
      void setAutoPriority        (WitBoolean);
      void setSkipFailures        (WitBoolean);
      void setMultiRoute          (WitBoolean);
      void setTruncOffsets        (WitBoolean);
d178 10
a187 10
      void setPenExec             (WitBoolean);
      void setStockRealloc        (WitBoolean);
      void setStockReallocation   (WitBoolean);
      void setSrSelSplit          (WitBoolean);
      void setRespectStockSLBs    (WitBoolean);
      void setPrefHighStockSLBs   (WitBoolean);
      void setPerfPegging         (WitBoolean);
      void setSelSplit            (WitBoolean);
      void setNonMrSelSplit       (WitBoolean);
      void setUserHeurStart       (WitBoolean);
d193 3
a195 3
      void setReadDataMsgs  (WitBoolean);
      void setPrintEqAlloc  (WitBoolean);
      void setReportIncViol (WitBoolean);
d197 1
a197 1
      void setTwmeByDemand  (WitBoolean);
d210 1
a210 1
      virtual WitBoolean inserted ();
d241 1
a241 1
      WitBoolean multiExecNeeded ();
d243 1
a243 1
         // Returns TRUE, iff it is appropriate to use the multiple execution
d246 1
a246 1
      WitBoolean tempParIsSet (int index);
d248 1
a248 1
         // Returns TRUE, if tempPar #index is set (to a non-empty string).
d250 1
a250 1
      WitBoolean tempParAsBoolean (int index);
d252 1
a252 1
         // Returns tempPar #index converted to a boolean.
d308 1
a308 1
      WitBoolean independentOffsets_;
d310 1
a310 1
         // If FALSE, the offset of a subEntry cannot be set, and is
d312 1
a312 1
         // If TRUE, the offset of a subEntry can be set independently of the
d315 1
a315 1
      WitBoolean execEmptyBom_;
d317 1
a317 1
         // If FALSE, then any Operation will be prevented from executing in
d323 1
a323 1
         // If TRUE, Operations will be allowed to execute under the above
d325 1
a325 1
         // Defaults to TRUE.
d331 1
a331 1
      WitBoolean roundReqVols_;
d333 1
a333 1
         // If TRUE, reqVols and focShortageVols will be rounded up to integer
d343 1
a343 1
      WitBoolean computeCriticalList_;
d345 1
a345 1
         // TRUE, iff the critical part list is to be computed.
d347 1
a347 1
      WitBoolean wit34Compatible_;
d349 1
a349 1
         // TRUE iff myProblem () is in WIT 3.4 compatible mode.
d351 1
a351 1
      WitBoolean useFocusHorizons_;
d353 1
a353 1
         // If TRUE, then before the shortage schedule is computed, the
d355 1
a355 1
         // focus horizon. If FALSE, the fssShipVols will be left at their
d358 1
a358 1
      WitBoolean localBuildAhead_;
d360 1
a360 1
         // TRUE, iff the local build-ahead periods technique as been
d365 1
a365 1
      WitBoolean multiExec_;
d367 1
a367 1
         // TRUE, iff the multiple execution periods technique as been
d370 1
a370 1
      WitBoolean twoWayMultiExec_;
d372 3
a374 3
         // TRUE, iff the multiple execution periods technique is to be used.
         // The set functions assure that whenever twoWayMultiExec_ is TRUE, 
         // multiExec_ also TRUE.
d376 1
a376 1
      WitBoolean localMultiExec_;
d378 1
a378 1
         // TRUE, iff the local multiple execution periods technique as been
d389 1
a389 1
      WitBoolean forcedMultiEq_;
d391 1
a391 1
         // If TRUE, equitable allocation will use multiple passes,
d395 1
a395 1
      WitBoolean autoPriority_;
d397 1
a397 1
         // If TRUE, heuristic implosion will generate priorities automatically
d400 1
a400 1
      WitBoolean skipFailures_;
d402 1
a402 1
         // If TRUE, heuristic allocation will not attempt to allocate to a
d406 1
a406 1
      WitBoolean multiRoute_;
d408 1
a408 1
         // If TRUE, multiple routes logic will be used by heuristic allocation.
d410 1
a410 1
      WitBoolean truncOffsets_;
d412 1
a412 1
         // If TRUE, preprocessing will compute impact periods using truncated
d426 1
a426 1
      WitBoolean penExec_;
d429 1
a429 1
         // penExec and multiRoute are both TRUE.
d431 1
a431 1
      WitBoolean stockRealloc_;
d433 1
a433 1
         // TRUE, iff heuristic implosion/allocation is to perform pure
d436 1
a436 1
      WitBoolean stockReallocation_;
d438 1
a438 1
         // TRUE, iff heuristic implosion/allocation is to perform selective
d441 1
a441 1
      WitBoolean srSelSplit_;
d443 1
a443 1
         // TRUE, iff heuristic implosion/allocation is to perform selection
d446 1
a446 1
      WitBoolean respectStockSLBs_;
d448 1
a448 1
         // TRUE, iff heuristic allocation is to respect stock soft lower 
d451 1
a451 1
      WitBoolean prefHighStockSLBs_;
d453 1
a453 1
         // TRUE, iff heuristic allocation is to give preference to stock soft
d457 1
a457 1
      WitBoolean perfPegging_;
d459 1
a459 1
         // TRUE, iff pegging is to be performed by heuristic allocation.
d461 1
a461 1
      WitBoolean selSplit_;
d463 1
a463 1
         // TRUE, iff heuristic implosion/allocation is to perform all cases of
d466 1
a466 1
      WitBoolean nonMrSelSplit_;
d468 1
a468 1
         // TRUE, iff heuristic implosion/allocation is to perform all cases of
d471 1
a471 1
      WitBoolean userHeurStart_;
d473 1
a473 1
         // TRUE, iff user-specified heuristic starting solution is to be used.
d480 1
a480 1
      WitBoolean readDataMsgs_;
d482 1
a482 1
         // If TRUE, API informational msgs will be issued during readData.
d484 1
a484 1
      WitBoolean printEqAlloc_;
d486 1
a486 1
         // If TRUE, the equitable allocation Targets will be displayed.
d488 1
a488 1
      WitBoolean reportIncViol_;
d490 1
a490 1
         // If TRUE, postprocessing will print each constraint violation that
d502 1
a502 1
      WitBoolean twmeByDemand_;
d504 1
a504 1
         // If TRUE, then in two-way multi-exec mode, the multi-exec direction
d534 1
a534 1
      WitBoolean lotSizesExist_;
d536 1
a536 1
         // TRUE iff any minLotSize or incLotSize has a positive value.
d545 1
a545 1
         // If computeCriticalList () == TRUE, this is computed
d556 1
a556 1
      WitBoolean feasible_;
d558 1
a558 1
         // TRUE, iff postprocessed () is TRUE and the current implosion
@


1.74
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@a530 1
      //------------------------------------------------------------------------
@


1.73
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d473 1
a473 2
         // TRUE, iff heuristic implosion/allocation is to use the existing
         // execution and shipments schedules as its initial solution.
@


1.72
log
@Continued implementation of heuristic implosion from an initial solution.
Fixed a bug in build-ahead by demand.
Removed RWClient.C.
@
text
@d88 1
a88 1
      accessFunc (WitBoolean,                     heurInitSoln)
d150 1
a150 1
      defaultValue (WitBoolean   defHeurInitSoln,        witFALSE)
d187 1
a187 1
      void setHeurInitSoln        (WitBoolean);
d471 1
a471 1
      WitBoolean heurInitSoln_;
@


1.71
log
@Continued implementation of heuristic initial solution.
@
text
@a93 1
      accessFunc (WitBoolean,                     allowHIS)
a197 1
      void setAllowHIS      (WitBoolean);
a506 4

      WitBoolean allowHIS_;
         //
         // heurInitSoln_ may be set only if allowHIS_ is TRUE.
@


1.70
log
@Removed implementation of single-source by the old algorithm.
@
text
@d88 1
a88 1
      accessFunc (WitBoolean,                     initHeurSoln)
d94 1
a94 1
      accessFunc (WitBoolean,                     allowIHS)
d151 1
a151 1
      defaultValue (WitBoolean   defInitHeurSoln,        witFALSE)
d188 1
a188 1
      void setInitHeurSoln        (WitBoolean);
d199 1
a199 1
      void setAllowIHS      (WitBoolean);
d473 1
a473 1
      WitBoolean initHeurSoln_;
d510 1
a510 1
      WitBoolean allowIHS_;
d512 1
a512 1
         // initHeurSoln_ may be set only if allowIHS_ is TRUE.
@


1.69
log
@Continued implementation of single-source with the new algorithm.
@
text
@a94 1
      accessFunc (WitBoolean,                     sglSrcNewAlg)
a199 1
      void setSglSrcNewAlg  (WitBoolean);
a512 5

      WitBoolean sglSrcNewAlg_;
         //
         // If single-source is invoked, it will use the new algorithm, iff
         // sglSrcNewAlg_ is TRUE.
@


1.68
log
@Continued implementation of heuristic implosion from an initial solution.
Added some debugging code to Single-Source.
@
text
@d95 1
d201 1
d514 6
a519 1
         // If initHeurSoln_ may be set only if allowIHS_ is TRUE.
@


1.67
log
@Began implementation of heuristic implosion from an initial solution.
@
text
@d88 1
a88 1
      accessFunc (WitBoolean,                     heurInitSoln)
d94 1
a94 1
      accessFunc (WitBoolean,                     allowHIS)
d151 1
a151 1
      defaultValue (WitBoolean   defHeurInitSoln,        witFALSE)
d188 1
a188 1
      void setHeurInitSoln        (WitBoolean);
d199 1
a199 1
      void setAllowHIS      (WitBoolean);
d473 1
a473 1
      WitBoolean heurInitSoln_;
d510 1
a510 1
      WitBoolean allowHIS_;
d512 1
a512 1
         // If heurInitSoln_ may be set only if allowHIS_ is TRUE.
@


1.66
log
@Continued implementation of 2-level lot sizes.
@
text
@d88 1
d94 1
d151 1
d188 1
d199 1
d473 5
d509 4
@


1.65
log
@Continued implementation of 2-level lot sizes.
@
text
@a95 1
      accessFunc (WitBoolean,                     allowTlls)
a197 1
      void setAllowTlls     (WitBoolean);
a511 4

      WitBoolean allowTlls_;
         //
         // lotSize2Thresh be may >= only if allowTlls_ is TRUE.
@


1.64
log
@Continued implementation of two-level lot sizes.
@
text
@a244 12
      int lotSizeGridPoint (
            double     minQty,
            double     incQty,
            double     qty,
            WitBoolean upwards,
            WitBoolean useTol);
        //
        // Computes and returns the location for qty on the lot size grid
        // defined by minQty and incQty. If upwards is TRUE, the grid point
        // will be found by moving up; otherwise moving down.
        // A tolerance will be used iff useTol is TRUE.

@


1.63
log
@Continued implementation of single-source.
@
text
@d96 1
d199 1
d526 4
@


1.62
log
@Continued implementation of single-source.
@
text
@a95 1
      accessFunc (WitBoolean,                     allowSglSrc)
a197 1
      void setAllowSglSrc   (WitBoolean);
a523 5

      WitBoolean allowSglSrc_;
         //
         // The single-source technique is allowed to be used, iff allowSglSrc_
         // is TRUE.
@


1.61
log
@Continued implementation of single-source.
@
text
@a187 7
      // Conditional reference access functions.
      //------------------------------------------------------------------------

      conditionalRef (WitList <WitDatedPart>, criticalList,  heurAllAcc () ||
                                                              optImpAcc ())

      //------------------------------------------------------------------------
d231 2
@


1.60
log
@Continued implementation of single-source.
@
text
@a192 1
      conditionalRef (WitBoolean,             lotSizesExist, preprocAcc ())
d232 5
@


1.59
log
@Continued implementation of single-source.
@
text
@a192 1
      conditionalRef (WitBoolean,             feasible,     postprocAcc ())
d232 8
@


1.58
log
@Continued implementation of single-source.
@
text
@d193 2
a229 8
      void compLotSizesExist ();
         //
         // Computes lotSizesExist_.

      void resetLotSizesExist ();
         //
         // Sets lotSizesExist_ to FALSE.

a266 8

      void compFeasible ();
         //
         // Computes feasible_.

      void unpostprocess ();
         //
         // Updates the state of this GlobalComp for unpostprocessing.
@


1.57
log
@Continued implementation of single-source.
@
text
@a192 1
      conditionalRef (WitBoolean,             lotSizesExist, preprocAcc ())
d228 1
a228 1
      virtual void importPostprocResults ();
d230 5
a234 1
         // Override from class Component.
d273 4
@


1.56
log
@Continued implementation of single-source.
@
text
@a192 1
      conditionalRef (WitBoolean,             feasible,     postprocAcc ())
d229 4
d270 4
@


1.55
log
@Continued implementation of single source.
@
text
@d96 1
a96 1
      accessFunc (WitBoolean,                     sglSrc)
d208 1
a208 1
      void setSglSrc        (WitBoolean);
d521 1
a521 1
      WitBoolean sglSrc_;
d523 2
a524 1
         // TRUE, iff the single source technique is to be used.
@


1.54
log
@Preliminary work on single source.
@
text
@d96 1
d208 1
d521 4
d535 1
@


1.53
log
@Continued implementation of object iteration.
@
text
@d97 1
a97 1
      accessFunc (const WitList (WitDatedPart) &, criticalList)
d190 1
a190 1
      conditionalRef (WitList (WitDatedPart), criticalList,  heurAllAcc () ||
d541 1
a541 1
      WitList (WitDatedPart) criticalList_;
@


1.52
log
@Continued implementation of object iteration.
@
text
@a95 1
      accessFunc (WitBoolean,                     allowObjItr)
a206 1
      void setAllowObjItr   (WitBoolean);
a517 4

      WitBoolean allowObjItr_;
         //
         // Object iteration is only allowed if allowObjItr_ is TRUE.
@


1.51
log
@Began implementation of object iteration.
@
text
@d96 1
d208 1
d520 4
@


1.50
log
@Continued implementation of sel-split for pen-exec.
@
text
@d19 2
a20 1
#include <DelComp.h>
@


1.49
log
@Added allowSSPE dev param.
Switched pen-exec to single-shortage logic.
Made pen-exec exploit sparse penalties.
@
text
@a94 1
      accessFunc (WitBoolean,                     allowSSPE)
a205 1
      void setAllowSSPE     (WitBoolean);
a516 5

      WitBoolean allowSSPE_;
         //
         // Selection splitting and penalized execution cannot both be used,
         // unless allowSSPE_ is TRUE.
@


1.48
log
@Finished implementation of selection splitting for multi-route.
@
text
@d95 1
d207 1
d519 5
@


1.47
log
@Initial implementation of selection splitting for multi-route.
@
text
@a94 1
      accessFunc (WitBoolean,                     allowNewSS)
a205 1
      void setAllowNewSS    (WitBoolean);
a516 5

      WitBoolean allowNewSS_;
         //
         // setSplit_ and nonMrSelSplit_ can be set to TRUE only if allowNewSS_
         // is TRUE.
@


1.46
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d84 3
a86 1
      accessFunc (WitBoolean,                     perfPegging)
d95 1
d147 2
d183 2
d207 1
d465 10
d519 5
@


1.45
log
@Began implementation of selection splitting for stock reallocation.
@
text
@a92 1
      accessFunc (WitBoolean,                     allowSRSS)
a199 1
      void setAllowSRSS     (WitBoolean);
a500 4

      WitBoolean allowSRSS_;
         //
         // srSelSplit_ can be set to TRUE only if allowSRSS_ is TRUE.
@


1.44
log
@Made stock reallocation use ssr vs. usr on a part-by-part basis.
@
text
@d81 1
d93 1
d141 1
d175 1
d201 1
d439 5
d503 4
@


1.43
log
@Changed selStockRe attribute to stockReallocation (fullSR, internally).
@
text
@d97 1
a97 1
      inline WitBoolean pureUncondSR ()
a99 5
         }

      inline WitBoolean fullSR ()
         {
         return stockReallocation_;
@


1.42
log
@Replaced uncondStockRe attribute with the old stockRealloc attribute.
@
text
@d79 2
a80 2
      accessFunc (WitBoolean,                     pureUncondSR)
      accessFunc (WitBoolean,                     selStockRe)
d97 10
d142 2
a143 2
      defaultValue (WitBoolean   defPureUncondSR,        witFALSE)
      defaultValue (WitBoolean   defSelStockRe,          witFALSE)
d175 2
a176 2
      void setPureUncondSR        (WitBoolean);
      void setSelStockRe          (WitBoolean);
d429 1
a429 1
      WitBoolean pureUncondSR_;
d434 1
a434 1
      WitBoolean selStockRe_;
@


1.41
log
@Renamed mandatory stock reallocation to unconditional stock reallocation.
@
text
@d79 1
a79 1
      accessFunc (WitBoolean,                     uncondStockRe)
d132 1
a132 1
      defaultValue (WitBoolean   defUncondStockRe,       witFALSE)
d165 1
a165 1
      void setUncondStockRe       (WitBoolean);
d419 1
a419 1
      WitBoolean uncondStockRe_;
d421 2
a422 2
         // TRUE, iff heuristic implosion/allocation is to perform unconditional
         // stock reallocation.
@


1.40
log
@Removed allowSSR development control parameter.
@
text
@d79 1
a79 1
      accessFunc (WitBoolean,                     mandStockRe)
d132 1
a132 1
      defaultValue (WitBoolean   defMandStockRe,         witFALSE)
d165 1
a165 1
      void setMandStockRe         (WitBoolean);
d419 1
a419 1
      WitBoolean mandStockRe_;
d421 1
a421 1
         // TRUE, iff heuristic implosion/allocation is to perform mandatory
@


1.39
log
@Changed attribute stockRealloc to mandStockRe.
@
text
@a91 1
      accessFunc (WitBoolean,                     allowSSR)
a191 1
      void setAllowSSR      (WitBoolean);
a487 5

      WitBoolean allowSSR_;
         //
         // Selective stock reallocation can only be requested if allowSSR_ is
         // TRUE.
@


1.38
log
@Continued implementation of selective stock reallocation.
@
text
@d79 1
a79 1
      accessFunc (WitBoolean,                     stockRealloc)
a105 5
      inline WitBoolean mandStockRe ()
         {
         return stockRealloc_;
         }

d133 1
a133 1
      defaultValue (WitBoolean   defStockRealloc,        witFALSE)
d166 1
a166 1
      void setStockRealloc        (WitBoolean);
d421 1
a421 1
      WitBoolean stockRealloc_;
d423 2
a424 2
         // TRUE, iff heuristic implosion/allocation is to perform stock
         // reallocation.
d428 2
a429 2
         // TRUE, iff selective stock reallocation is to be performed by
         // heuristic allocation.
@


1.37
log
@Added selStockRealloc attribute.
@
text
@d80 1
a80 1
      accessFunc (WitBoolean,                     selStockRealloc)
d106 5
d139 1
a139 1
      defaultValue (WitBoolean   defSelStockRealloc,     witFALSE)
d172 1
a172 1
      void setSelStockRealloc     (WitBoolean);
d431 1
a431 1
      WitBoolean selStockRealloc_;
@


1.36
log
@Began implemention of constrained stock reallocation.
@
text
@d80 1
d134 1
d167 1
d425 5
@


1.35
log
@Minor change.
@
text
@d91 1
d190 1
d482 5
@


1.34
log
@Continued implementation of pegging.
@
text
@d82 1
a82 1
      accessFunc (WitBoolean,                     peggingNeeded)
d134 1
a134 1
      defaultValue (WitBoolean   defPeggingNeeded,       witFALSE)
d166 1
a166 1
      void setPeggingNeeded       (WitBoolean);
d432 1
a432 1
      WitBoolean peggingNeeded_;
@


1.33
log
@Continued implementation of pegging.
@
text
@d82 1
a82 1
      accessFunc (WitBoolean,                     pegging)
d134 1
a134 1
      defaultValue (WitBoolean   defPegging,             witFALSE)
d166 1
a166 1
      void setPegging             (WitBoolean);
d432 1
a432 1
      WitBoolean pegging_;
@


1.32
log
@Continued implementation of pegging.
@
text
@d82 1
a82 1
      accessFunc (WitBoolean,                     perfPegging)
d134 1
a134 1
      defaultValue (WitBoolean   defPerfPegging,         witFALSE)
d166 1
a166 1
      void setPerfPegging         (WitBoolean);
d432 1
a432 1
      WitBoolean perfPegging_;
@


1.31
log
@Initial implementation of pegging.
@
text
@d82 1
a82 1
      accessFunc (WitBoolean,                     doPegging)
a90 1
      accessFunc (WitBoolean,                     allowPegging)
d134 1
a134 1
      defaultValue (WitBoolean   defDoPegging,           witFALSE)
d166 1
a166 1
      void setDoPegging           (WitBoolean);
a188 1
      void setAllowPegging  (WitBoolean);
d432 1
a432 1
      WitBoolean doPegging_;
a479 4

      WitBoolean allowPegging_;
         //
         // doPegging can be set to TRUE, iff allowPegging_ is TRUE.
@


1.30
log
@Implemented an iteration upper bound for selection splitting.
@
text
@d82 1
d91 1
d135 1
d167 1
d190 1
d434 4
d482 4
@


1.29
log
@More templates.
@
text
@d89 1
d185 1
d468 5
@


1.28
log
@Continued development of selection splitting for multi-exec.
@
text
@d467 1
a467 1
      WitPtrVec (WitString) & tempPar_;
@


1.27
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@a86 1
      accessFunc (WitBoolean,                     meSelSplitOK)
a181 1
      void setMeSelSplitOK  (WitBoolean);
a457 5

      WitBoolean meSelSplitOK_;
         //
         // The BopEntry meSelSplit attribute can be set iff meSelSplitOK_ is 
         // TRUE.
@


1.26
log
@Removed allowSS development parameter.
@
text
@d87 1
d183 1
d460 5
@


1.25
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a86 1
      accessFunc (WitBoolean,                     allowSS)
a181 1
      void setAllowSS       (WitBoolean);
a457 5

      WitBoolean allowSS_;
         //
         // The selection splitting attributes are allowed to be set, iff
         // allowSS_ is TRUE.
@


1.24
log
@Implemented timing wrap-around adjustment.
@
text
@d87 1
a87 1
      accessFunc (WitBoolean,                     selSplit)
a89 1
      accessFunc (int,                            heurTimingDelta)
d178 8
a185 9
      void setReadDataMsgs    (WitBoolean);
      void setPrintEqAlloc    (WitBoolean);
      void setReportIncViol   (WitBoolean);
      void setSelPrintLevel   (int);
      void setTwmeByDemand    (WitBoolean);
      void setSelSplit        (WitBoolean);
      void setSplitTol        (float);
      void setSplitRes        (float);
      void setHeurTimingDelta (int);
d461 1
a461 1
      WitBoolean selSplit_;
d463 2
a464 1
         // TRUE, iff selection splitting is to be performed.
a472 5

      int heurTimingDelta_;
         //
         // If heurTimingDelta_ > 0, incHeurAlloc will do a timing charge once
         // every heurTimingDelta_ calls.
@


1.23
log
@Implemented Ticker class.
Disallowed sel-split w multi-exec.
@
text
@d90 1
d179 9
a187 8
      void setReadDataMsgs  (WitBoolean);
      void setPrintEqAlloc  (WitBoolean);
      void setReportIncViol (WitBoolean);
      void setSelPrintLevel (int);
      void setTwmeByDemand  (WitBoolean);
      void setSelSplit      (WitBoolean);
      void setSplitTol      (float);
      void setSplitRes      (float);
d474 5
@


1.22
log
@Implemented incAlloc count.
@
text
@a85 1
      accessFunc (int,                            incCountDelta)
a181 1
      void setIncCountDelta (int);
a454 5

      int incCountDelta_;
         //
         // If incCountDelta_ > 0, incHeurAlloc will print #calls once every
         // incCountDelta_ calls.
@


1.21
log
@Implemented tick printing for incHeurAlloc.
@
text
@d86 1
a86 1
      accessFunc (WitBoolean,                     incAllocTicks)
d183 1
a183 1
      void setIncAllocTicks (WitBoolean);
d458 1
a458 1
      WitBoolean incAllocTicks_;
d460 2
a461 1
         // If TRUE, incHeurAlloc will print a "*" for each call.
@


1.20
log
@Continuing development of selection splitting.
@
text
@d86 1
d183 1
d457 4
@


1.19
log
@Re-worked the controls for selection splitting.
@
text
@d88 1
d184 1
d464 4
@


1.18
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d87 2
a88 1
      accessFunc (WitBoolean,                     allowSS)
d182 2
a183 1
      void setAllowSS       (WitBoolean);
d459 1
a459 1
      WitBoolean allowSS_;
d461 5
a465 1
         // The selection splitting attributes can be set, iff allowSS_ is TRUE.
@


1.17
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d87 1
a87 1
      accessFunc (WitBoolean,                     selSplit)
d181 1
a181 2
      void setSelSplit      (WitBoolean);
      void setPrtExecPen    (WitBoolean);
d457 1
a457 1
      WitBoolean selSplit_;
d459 1
a459 1
         // TRUE, iff selection splitting is to be performed.
@


1.16
log
@Coarse selection splitting.
@
text
@d86 1
a86 1
      accessFunc (WitBoolean,                     twmeIsAsap)
d176 7
a182 8
      void setReadDataMsgs      (WitBoolean);
      void setPrintEqAlloc      (WitBoolean);
      void setReportIncViol     (WitBoolean);
      void setSelPrintLevel     (int);
      void setAllowTwme         (WitBoolean);
      void setTwmeIsAsap        (WitBoolean);
      void setSelSplit          (WitBoolean);
      void setPrtExecPen        (WitBoolean);
d453 1
a453 1
      WitBoolean twmeIsAsap_;
d455 2
a456 3
         // The value of the asapMultiExec argument to be passed to
         // HeurAllocator::inc by heuristic implosion, in two-way multi-exec
         // mode.
@


1.15
log
@Some minor changes.
@
text
@d201 4
@


1.14
log
@Refactoring for selection splitting.
@
text
@d93 5
a97 11
      inline const WitString & tempPar (int index) const
         {
         checkTempParIndex (index);

         return tempPar_[index];
         }

      inline int nTempPars () const
         {
         return tempPar_.length () - 1;
         }
d187 1
a187 1
         // Sets tempPar_[t] to theValue.
d460 1
a460 1
      WitRefVector (WitString) tempPar_;
d468 1
a468 1
         // tempPar_[0] is not used.
@


1.13
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d251 1
a251 3
      copyCtorAndAssignment (WitGlobalComp);
         //
         // Prevents unintentional copying and assignment.
@


1.12
log
@Implemented respectStockSLBs and prefHighStockSLBs global attributes.
@
text
@d87 1
d188 1
d203 1
a203 1
      virtual void copyInto (WitCompMgr * theCompMgr);
d463 4
@


1.11
log
@

Revised stand-alone FSS capabilties in development mode.
Modified some stock soft-lower bound controls.
Fixed bug: BOP entry productRate attribute could not be read.
@
text
@d80 2
a86 1
      accessFunc (WitBoolean,                     respectStockSLBs)
d134 2
d165 2
d181 7
a187 8
      void setReadDataMsgs     (WitBoolean);
      void setPrintEqAlloc     (WitBoolean);
      void setReportIncViol    (WitBoolean);
      void setSelPrintLevel    (int);
      void setAllowTwme        (WitBoolean);
      void setTwmeIsAsap       (WitBoolean);
      void setRespectStockSLBs (WitBoolean);
      void setPrtExecPen       (WitBoolean);
d418 11
a460 5

      WitBoolean respectStockSLBs_;
         //
         // TRUE, iff heuristic allocation is to respect stock soft lower 
         // bounds.
@


1.10
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d85 1
a85 1
      accessFunc (WitBoolean,                     enforceStSLBs)
d176 8
a183 8
      void setReadDataMsgs  (WitBoolean);
      void setPrintEqAlloc  (WitBoolean);
      void setReportIncViol (WitBoolean);
      void setSelPrintLevel (int);
      void setAllowTwme     (WitBoolean);
      void setTwmeIsAsap    (WitBoolean);
      void setEnforceStSLBs (WitBoolean);
      void setPrtExecPen    (WitBoolean);
d447 1
a447 1
      WitBoolean enforceStSLBs_;
d449 1
a449 1
         // TRUE, iff heuristic allocation is to enforce stock soft lower 
@


1.9
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d406 2
a407 1
         // This attribute will be given meaning later.
@


1.8
log
@Finished implementing stock reallocation.
@
text
@d85 1
d132 1
a132 1
      defaultValue (WitBoolean   defStockRealloc,        witTRUE)
d182 1
d445 5
@


1.7
log
@Made HeurAllPerf::findMaxQty test desQty when it's < minQty.
   This fixed a "commit failed" error, by making the heuristic function
   properly in cases in which commit fails at a lower desQty than one in which
   it succeeds.
Moved top-level net into commitMaxQtySel.
@
text
@d79 1
a84 3
      accessFunc (WitBoolean,                     stockRealloc)
      accessFunc (WitBoolean,                     emulatedSF)
      accessFunc (WitBoolean,                     trackInterval)
d131 1
d160 1
a180 3
      void setStockRealloc  (WitBoolean);
      void setEmulatedSF    (WitBoolean);
      void setTrackInterval (WitBoolean);
d406 5
a442 15

      WitBoolean stockRealloc_;
         //
         // TRUE, iff heuristic implosion/allocation is to perform stock
         // reallocation.

      WitBoolean emulatedSF_;
         //
         // TRUE, iff heuristic implosion/allocation is to use the stock 
         // reallocation algorithms to emulate stock freezing.

      WitBoolean trackInterval_;
         //
         // TRUE, iff heuristic implosion/allocation is to keep track of the
         // ReqVol interval when in non-stock reallocation mode.
@


1.6
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d85 2
d175 10
a184 8
      void setReadDataMsgs   (WitBoolean);
      void setPrintEqAlloc   (WitBoolean);
      void setReportIncViol  (WitBoolean);
      void setSelPrintLevel  (int);
      void setAllowTwme      (WitBoolean);
      void setTwmeIsAsap     (WitBoolean);
      void setStockRealloc   (WitBoolean);
      void setPrtExecPen     (WitBoolean);
d446 10
@


1.5
log
@Continued implementation of stock re-allocation.
@
text
@d84 1
a84 1
      accessFunc (WitBoolean,                     stockReAlloc)
d88 1
d179 1
a179 1
      void setStockReAlloc   (WitBoolean);
d438 1
a438 1
      WitBoolean stockReAlloc_;
d441 1
a441 1
         // re-allocation.
d484 8
@


1.4
log
@Minor update to stock re-allocation.
@
text
@d439 1
a439 1
         // TRUE, iff heuristic implosion/allocation is to perform stock 
@


1.3
log
@Initial implementation of stock re-allocation.
@
text
@d84 1
a84 2
      accessFunc (WitBoolean,                     usingNetSupp)
      accessFunc (WitBoolean,                     usingSurplus)
d178 1
a178 2
      void setUsingNetSupp   (WitBoolean);
      void setUsingSurplus   (WitBoolean);
d437 1
a437 1
      WitBoolean usingNetSupp_;
d439 2
a440 7
         // TRUE, iff heuristic implosion/allocation is to use net supply as its
         // model of resource availability.

      WitBoolean usingSurplus_;
         //
         // TRUE, iff heuristic implosion/allocation is to use surplus as its
         // model of resource availability.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d84 2
d179 2
d438 10
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.240;
access;
symbols
	sce_5_01_20080919:1.228
	latest_sce_4_20_20060523:1.169.0.2
	sce_4_20_20060523:1.169
	latest_sce4_20_OSL:1.164.0.2
	sce_4_20_OSL:1.164
	sce_410_withVa:1.152
	sce_4_05_20040511:1.126
	sce_4_00_20040201:1.109
	nextGenBranch:1.92.0.2
	nextGenRoot:1.92
	sce_3_30_20030627:1.92
	EndRw-branch:1.78.0.2
	Root-of-EndRw:1.78
	rwToStl:1.77.0.2
	latest_sce_3_10_20010924:1.43.0.2
	sce_3_10_20010924:1.43
	latest_sce_3_00_20010601:1.29.0.2
	sce_3_00_20010601:1.29
	latest_sce_2_31_20010308:1.17.0.2
	sce_2_31_20010308:1.17
	latest_sce_2_31_20001003:1.10.0.2
	sce_2_31_20001003:1.10
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.240
date	2010.03.16.22.42.25;	author rjw;	state dead;
branches;
next	1.239;

1.239
date	2010.03.05.00.10.14;	author rjw;	state Exp;
branches;
next	1.238;

1.238
date	2010.03.04.22.18.35;	author rjw;	state Exp;
branches;
next	1.237;

1.237
date	2010.03.03.20.10.28;	author rjw;	state Exp;
branches;
next	1.236;

1.236
date	2010.03.02.23.07.56;	author rjw;	state Exp;
branches;
next	1.235;

1.235
date	2010.01.25.19.45.17;	author rjw;	state Exp;
branches;
next	1.234;

1.234
date	2009.10.06.21.06.11;	author rjw;	state Exp;
branches;
next	1.233;

1.233
date	2009.06.23.21.34.39;	author rjw;	state Exp;
branches;
next	1.232;

1.232
date	2009.05.08.23.18.00;	author rjw;	state Exp;
branches;
next	1.231;

1.231
date	2009.01.30.16.07.18;	author rjw;	state Exp;
branches;
next	1.230;

1.230
date	2008.11.12.21.46.37;	author rjw;	state Exp;
branches;
next	1.229;

1.229
date	2008.11.12.19.52.25;	author rjw;	state Exp;
branches;
next	1.228;

1.228
date	2007.11.15.17.15.33;	author rjw;	state Exp;
branches;
next	1.227;

1.227
date	2007.11.14.17.18.54;	author rjw;	state Exp;
branches;
next	1.226;

1.226
date	2007.11.13.20.17.38;	author rjw;	state Exp;
branches;
next	1.225;

1.225
date	2007.11.08.19.16.39;	author rjw;	state Exp;
branches;
next	1.224;

1.224
date	2007.11.07.21.50.12;	author rjw;	state Exp;
branches;
next	1.223;

1.223
date	2007.10.15.21.50.34;	author rjw;	state Exp;
branches;
next	1.222;

1.222
date	2007.08.01.22.41.56;	author rjw;	state Exp;
branches;
next	1.221;

1.221
date	2007.07.17.22.10.25;	author rjw;	state Exp;
branches;
next	1.220;

1.220
date	2007.07.13.23.05.31;	author rjw;	state Exp;
branches;
next	1.219;

1.219
date	2007.07.05.18.37.54;	author rjw;	state Exp;
branches;
next	1.218;

1.218
date	2007.06.29.15.25.49;	author rjw;	state Exp;
branches;
next	1.217;

1.217
date	2007.06.08.18.09.39;	author rjw;	state Exp;
branches;
next	1.216;

1.216
date	2007.06.06.16.28.02;	author rjw;	state Exp;
branches;
next	1.215;

1.215
date	2007.06.05.21.06.00;	author rjw;	state Exp;
branches;
next	1.214;

1.214
date	2007.06.05.16.15.23;	author rjw;	state Exp;
branches;
next	1.213;

1.213
date	2007.05.31.19.52.54;	author rjw;	state Exp;
branches;
next	1.212;

1.212
date	2007.05.30.16.01.18;	author rjw;	state Exp;
branches;
next	1.211;

1.211
date	2007.05.25.18.39.10;	author rjw;	state Exp;
branches;
next	1.210;

1.210
date	2007.05.11.15.56.45;	author rjw;	state Exp;
branches;
next	1.209;

1.209
date	2007.05.10.21.58.10;	author rjw;	state Exp;
branches;
next	1.208;

1.208
date	2007.05.10.21.14.41;	author rjw;	state Exp;
branches;
next	1.207;

1.207
date	2007.05.10.20.08.49;	author rjw;	state Exp;
branches;
next	1.206;

1.206
date	2007.05.10.17.22.14;	author rjw;	state Exp;
branches;
next	1.205;

1.205
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.204;

1.204
date	2007.04.06.19.34.17;	author rjw;	state Exp;
branches;
next	1.203;

1.203
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.202;

1.202
date	2007.04.03.22.04.03;	author rjw;	state Exp;
branches;
next	1.201;

1.201
date	2007.03.09.20.13.06;	author rjw;	state Exp;
branches;
next	1.200;

1.200
date	2007.03.08.22.47.17;	author rjw;	state Exp;
branches;
next	1.199;

1.199
date	2007.03.02.22.22.36;	author rjw;	state Exp;
branches;
next	1.198;

1.198
date	2007.02.28.23.09.06;	author rjw;	state Exp;
branches;
next	1.197;

1.197
date	2007.02.28.20.04.55;	author rjw;	state Exp;
branches;
next	1.196;

1.196
date	2007.02.27.22.59.29;	author rjw;	state Exp;
branches;
next	1.195;

1.195
date	2007.02.27.21.03.03;	author rjw;	state Exp;
branches;
next	1.194;

1.194
date	2007.02.27.19.59.31;	author rjw;	state Exp;
branches;
next	1.193;

1.193
date	2007.02.13.23.40.13;	author rjw;	state Exp;
branches;
next	1.192;

1.192
date	2007.01.29.22.34.12;	author rjw;	state Exp;
branches;
next	1.191;

1.191
date	2007.01.29.21.52.03;	author rjw;	state Exp;
branches;
next	1.190;

1.190
date	2007.01.26.20.56.56;	author rjw;	state Exp;
branches;
next	1.189;

1.189
date	2007.01.24.20.52.56;	author rjw;	state Exp;
branches;
next	1.188;

1.188
date	2007.01.22.21.27.53;	author rjw;	state Exp;
branches;
next	1.187;

1.187
date	2007.01.08.18.38.24;	author rjw;	state Exp;
branches;
next	1.186;

1.186
date	2006.11.22.21.45.06;	author rjw;	state Exp;
branches;
next	1.185;

1.185
date	2006.09.27.20.10.16;	author rjw;	state Exp;
branches;
next	1.184;

1.184
date	2006.09.21.20.31.52;	author rjw;	state Exp;
branches;
next	1.183;

1.183
date	2006.09.21.17.16.36;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2006.09.18.22.27.40;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2006.09.08.20.00.59;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2006.09.08.16.16.00;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2006.09.07.20.49.24;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2006.08.30.16.37.34;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2006.08.29.15.01.46;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2006.08.21.16.00.20;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2006.08.16.15.49.17;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2006.08.03.18.59.32;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2006.08.02.19.03.00;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2006.08.02.17.27.31;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2006.06.09.15.23.20;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2006.05.22.16.02.41;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2006.05.10.14.45.12;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2006.05.09.14.58.30;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2006.05.08.19.51.24;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2006.05.02.17.33.59;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2006.03.27.23.03.15;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2006.03.24.20.49.13;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2006.03.24.19.16.11;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2006.03.20.23.47.33;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2006.03.20.21.54.31;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2006.03.10.23.23.30;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2006.03.08.23.57.11;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2006.03.06.23.10.15;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2006.01.18.21.42.58;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2006.01.04.23.07.39;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2005.11.10.20.33.07;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2005.06.16.19.19.11;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2005.06.14.20.35.12;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2005.03.18.21.28.20;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2005.03.16.17.00.30;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2005.02.10.18.38.30;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2005.02.07.20.23.43;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2005.02.07.19.32.28;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2005.02.04.21.17.33;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2005.02.03.23.35.57;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2005.02.03.21.31.35;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2005.02.03.21.20.28;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2005.02.02.19.31.22;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2005.02.02.17.26.52;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2005.01.31.23.59.29;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2005.01.28.19.34.26;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2005.01.21.23.01.50;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2005.01.17.23.43.10;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2005.01.10.22.34.47;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2005.01.10.21.35.22;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2004.12.22.22.27.09;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2004.12.02.21.25.41;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2004.11.23.20.50.06;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2004.11.09.23.07.59;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2004.11.06.00.30.33;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2004.11.04.20.42.27;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2004.05.17.22.15.17;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2004.05.05.15.26.31;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2004.04.30.23.27.43;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2004.04.16.17.42.49;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.22.21.45.51;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2004.03.12.15.09.23;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2004.03.11.16.36.17;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2004.03.10.22.53.19;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2004.03.08.16.54.29;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2004.02.27.22.46.05;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2004.02.27.21.00.29;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2004.02.12.19.13.39;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2004.02.05.21.24.56;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2004.02.05.16.39.43;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2004.02.04.22.31.27;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.04.18.57.49;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2004.01.30.20.09.48;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2004.01.19.23.26.50;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2004.01.16.18.48.25;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2004.01.05.23.37.33;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2003.12.31.21.44.53;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2003.12.30.21.47.02;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2003.12.29.20.59.23;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2003.12.24.23.25.55;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2003.12.23.16.18.46;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2003.12.15.23.22.31;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2003.12.04.22.44.55;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2003.12.04.16.20.40;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2003.10.31.15.37.54;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2003.10.09.21.31.50;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2003.09.29.23.29.40;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2003.09.24.23.08.17;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2003.09.22.23.13.51;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2003.09.22.20.27.01;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2003.05.28.22.19.28;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2003.05.13.22.00.02;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2003.05.06.21.04.48;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2003.02.21.18.56.24;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2003.02.14.20.12.55;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2003.01.31.21.28.53;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2003.01.27.21.17.16;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2003.01.02.23.40.40;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2003.01.02.22.18.27;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2002.12.23.20.44.45;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2002.12.20.22.47.58;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2002.12.19.17.15.20;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2002.12.17.21.32.45;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2002.12.17.17.01.42;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.21.22.53.54;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2002.10.18.22.23.54;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2002.10.16.22.30.18;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2002.10.09.18.42.09;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2002.10.04.21.26.26;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2002.09.30.21.36.34;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2002.09.09.16.04.35;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2002.07.25.17.43.51;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.05.19.31.30;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.04.23.07.20;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.03.22.35.18;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.03.16.01.48;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.30.20.08.58;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.29.21.35.45;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.17.21.45.00;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2002.05.13.21.31.38;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.08.21.58.53;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.07.20.14.56;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.24.20.05.29;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2002.04.22.14.32.07;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.18.14.02.32;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2002.04.16.19.00.51;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2002.04.15.22.02.49;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.29.23.47.07;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2001.12.27.23.15.38;	author bobw;	state Exp;
branches;
next	1.53;

1.53
date	2001.12.20.18.50.05;	author bobw;	state Exp;
branches;
next	1.52;

1.52
date	2001.12.19.16.17.09;	author bobw;	state Exp;
branches;
next	1.51;

1.51
date	2001.12.17.19.22.50;	author bobw;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.09.21.42.26;	author bobw;	state Exp;
branches;
next	1.49;

1.49
date	2001.10.08.19.40.11;	author bobw;	state Exp;
branches;
next	1.48;

1.48
date	2001.10.05.20.53.56;	author bobw;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.05.18.55.27;	author bobw;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.03.18.55.10;	author bobw;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.28.21.42.38;	author bobw;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.28.20.50.27;	author bobw;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.16.21.42.29;	author bobw;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.31.15.06.11;	author bobw;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.30.23.00.33;	author bobw;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.29.17.12.02;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.06.17.31.06;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.03.23.37.55;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.03.18.40.41;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.08.01.14.55.29;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.30.15.12.09;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.28.00.48.33;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.25.16.08.14;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.17.20.49.18;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.21.18.24.30;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.02.02.11.27;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.29.22.11.26;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.17.20.02.19;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.17.15.11.13;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.15.15.30.26;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.07.15.58.55;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.03.22.55.44;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.03.20.47.24;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.30.21.29.41;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.24.17.48.33;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.10.21.59.33;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.06.19.22.08;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.08.16.37.04;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.26.21.46.00;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.20.00.44.16;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.04.22.27.50;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.06.19.58.37;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.21.20.03.23;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.13.21.03.53;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.06.18.45.07;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.30.19.09.12;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.18.00.15.59;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.08.21.56.11;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.02.20.43.11;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.24.19.55.21;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.01.00.35.42;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.31.19.25.07;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.16.33.07;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.51;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches;
next	;


desc
@@


1.240
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "Global.C"
//
// Contains the implementation of class GlobalComp.
//------------------------------------------------------------------------------

#include <Global.h>
#include <CompMgr.h>
#include <DataWrit.h>
#include <Pre.h>
#include <Post.h>
#include <FSS.h>
#include <PipMgr.h>
#include <HeurAllMgr.h>
#include <PclEl.h>
#include <DetOptImpMgr.h>
#include <Part.h>
#include <Demand.h>
#include <Opn.h>
#include <MsgFac.h>
#include <MsgFrag.h>
#include <PtrVec.h>

//------------------------------------------------------------------------------

WitGlobalComp::WitGlobalComp (WitCompMgr * theCompMgr):

      WitComponent         (theCompMgr),

      title_               (defTitle               ()),
      nPeriods_            (defNPeriods            ()),
      independentOffsets_  (defIndependentOffsets  ()),
      execEmptyBom_        (defExecEmptyBom        ()),
      hashTableSize_       (defHashTableSize       ()),
      roundReqVols_        (defRoundReqVols        ()),
      outputPrecision_     (defOutputPrecision     ()),
      computeCriticalList_ (defComputeCriticalList ()),
      pgdCritListMode_     (defPgdCritListMode     ()),
      wit34Compatible_     (defWit34Compatible     ()),
      wit34Allowed_        (defWit34Allowed        ()),
      useFocusHorizons_    (defUseFocusHorizons    ()),
      localBuildAhead_     (defLocalBuildAhead     ()),
      multiExec_           (defMultiExec           ()),
      twoWayMultiExec_     (defTwoWayMultiExec     ()),
      localMultiExec_      (defLocalMultiExec      ()),
      equitability_        (defEquitability        ()),
      forcedMultiEq_       (defForcedMultiEq       ()),
      autoPriority_        (defAutoPriority        ()),
      skipFailures_        (defSkipFailures        ()),
      multiRoute_          (defMultiRoute          ()),
      truncOffsets_        (defTruncOffsets        ()),
      lotSizeTol_          (defLotSizeTol          ()),
      expCutoff_           (defExpCutoff           ()),
      penExec_             (defPenExec             ()),
      tieBreakPropRt_      (defTieBreakPropRt      ()),
      stockRealloc_        (defStockRealloc        ()),
      stockReallocation_   (defStockReallocation   ()),
      srSelSplit_          (defSrSelSplit          ()),
      respectStockSLBs_    (defRespectStockSLBs    ()),
      prefHighStockSLBs_   (defPrefHighStockSLBs   ()),
      perfPegging_         (defPerfPegging         ()),
      selSplit_            (defSelSplit            ()),
      nonMrSelSplit_       (defNonMrSelSplit       ()),
      userHeurStart_       (defUserHeurStart       ()),
      pipSeqFromHeur_      (defPipSeqFromHeur      ()),
      newPipPggOrder_      (defNewPipPggOrder      ()),
      highPrecisionWD_     (defHighPrecisionWD     ()),
      nstnResidual_        (defNstnResidual        ()),
      minimalExcess_       (defMinimalExcess       ()),

      readDataMsgs_        (false),
      printIncAlloc_       (false),
      printEqAlloc_        (false),
      selPrintLevel_       (0),
      twmeByDemand_        (false),
      splitTol_            (1.0),
      splitRes_            (1.0),
      splitItrUB_          (20),
      pauses_              (false),
      prtPipMaxRatio_      (false),
      printDebug_          (false),
      printExcessVol_      (false),
      tempPar_             (* new WitPtrVec <WitString>),

      lotSizesExist_       (false),
      revCritList_         (myProblem ()),
      pgdCritList_         (),
      feasible_            (false)
   {
      // The following statement normally sets nTempPars to 1, but it can be
      // altered to a larger number for testing purposes:
      //
   setNTempPars (1);

   myCompMgr ()->insert (this);
   }

//------------------------------------------------------------------------------

WitGlobalComp::~WitGlobalComp ()
   {
   clearPgdCritList ();

   setNTempPars (0);

   delete & tempPar_;
   }

//------------------------------------------------------------------------------

const WitString & WitGlobalComp::tempPar (int index) const
   {
   checkTempParIndex (index);

   return tempPar_.myElemAt (index);
   }

//------------------------------------------------------------------------------

int WitGlobalComp::nTempPars () const
   {
   return tempPar_.length () - 1;
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitGlobalComp::setTitle (const char * theValue)
   {
   witAssert (theValue != NULL);

   prepSetNonUnpostAttr ();

   title_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setNPeriods (int theValue)
   {
   witAssert (myCompMgr ()->nNodes () == 0);

   witAssert (theValue >= 1);

   prepSetUnpreAttr ();

   nPeriods_ = theValue;

   myProblem ()->updateNPeriods ();
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setIndependentOffsets (bool theValue)
   {
   witAssert (myCompMgr ()->nNodes () == 0);

   prepSetUnpreAttr ();

   independentOffsets_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setExecEmptyBom (bool theValue)
   {
   prepSetUnpreAttr ();

   execEmptyBom_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setHashTableSize (int theValue)
   {
   witAssert (theValue >= 0);

   prepSetNonUnpostAttr ();

   hashTableSize_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setRoundReqVols (bool theValue)
   {
   prepSetUnpostAttr ();

   roundReqVols_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setOutputPrecision (int theValue)
   {
   witAssert (theValue >= 0);

   prepSetNonUnpostAttr ();

   outputPrecision_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setComputeCriticalList (bool theValue)
   {
   prepSetUnpostAttr ();

   computeCriticalList_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPgdCritListMode (bool theValue)
   {
   if (pgdCritListMode_)
      if (not theValue)
         clearPgdCritList ();

   prepSetUnpostAttr ();

   pgdCritListMode_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setWit34Compatible (bool theValue)
   {
   WitOperation * theOpn;

   prepSetUnpreAttr ();

   if (myCompMgr ()->nOperations () > 0)
      myMsgFac () ("setWit34CompatibleCpuWmsg");

   forEachOperation (theOpn, myProblem ())
      theOpn->setWit34Compatible (theValue);

   wit34Compatible_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setWit34Allowed (bool theValue)
   {
   prepSetUnpreAttr ();

   wit34Allowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setUseFocusHorizons (bool theValue)
   {
   prepSetNonUnpostAttr ();

   myProblem ()->myFSS ()->uncompute ();

   useFocusHorizons_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setLocalBuildAhead (bool theValue)
   {
   prepSetUnpostAttr ();

   localBuildAhead_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setMultiExec (bool theValue)
   {
   if (theValue)
      setLocalMultiExec  (false);

   if (not theValue)
      setTwoWayMultiExec (false);

   prepSetUnpreAttr ();

   multiExec_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setTwoWayMultiExec (bool theValue)
   {
   if (theValue)
      setMultiExec (true);

   prepSetUnpreAttr ();

   twoWayMultiExec_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setLocalMultiExec (bool theValue)
   {
   if (theValue)
      setMultiExec (false);

   prepSetUnpreAttr ();

   localMultiExec_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setEquitability (int theValue)
   {
   witAssert (theValue >=   1);
   witAssert (theValue <= 100);

   prepSetUnpostAttr ();

   equitability_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setForcedMultiEq (bool theValue)
   {
   prepSetUnpostAttr ();

   forcedMultiEq_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAutoPriority (bool theValue)
   {
   prepSetUnpostAttr ();

   autoPriority_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setSkipFailures (bool theValue)
   {
   prepSetUnpostAttr ();

   skipFailures_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setMultiRoute (bool theValue)
   {
   prepSetUnpreAttr ();

   multiRoute_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setTruncOffsets (bool theValue)
   {
   prepSetUnpreAttr ();

   truncOffsets_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setLotSizeTol (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   lotSizeTol_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setExpCutoff (double theValue)
   {
   witAssert (theValue > 0.999E-6);

   prepSetUnpreAttr ();

   expCutoff_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPenExec (bool theValue)
   {
   prepSetUnpostAttr ();

   penExec_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setTieBreakPropRt (bool theValue)
   {
   prepSetUnpostAttr ();

   tieBreakPropRt_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setStockRealloc (bool theValue)
   {
   if (theValue)
      witAssert (not stockReallocation_);

   prepSetUnpostAttr ();

   stockRealloc_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setStockReallocation (bool theValue)
   {
   if (theValue)
      witAssert (not stockRealloc_);

   prepSetUnpostAttr ();

   stockReallocation_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setSrSelSplit (bool theValue)
   {
   prepSetUnpostAttr ();

   srSelSplit_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setRespectStockSLBs (bool theValue)
   {
   prepSetUnpostAttr ();

   respectStockSLBs_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPrefHighStockSLBs (bool theValue)
   {
   prepSetUnpostAttr ();

   prefHighStockSLBs_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPerfPegging (bool theValue)
   {
   prepSetUnpostAttr ();

   if (perfPegging_ == theValue)
      return;

   perfPegging_ = theValue;

   if (theValue)
      myProblem ()->myHeurAllMgr ()->setUpPegging ();
   else
      myProblem ()->myHeurAllMgr ()->shutDownPegging ();
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setSelSplit (bool theValue)
   {
   prepSetUnpostAttr ();

   if (theValue)
      nonMrSelSplit_ = false;

   selSplit_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setNonMrSelSplit (bool theValue)
   {
   prepSetUnpostAttr ();

   if (theValue)
      selSplit_ = false;

   nonMrSelSplit_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setUserHeurStart (bool theValue)
   {
   prepSetUnpostAttr ();

   userHeurStart_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPipSeqFromHeur (bool theValue)
   {
   prepSetUnpostAttr ();

   pipSeqFromHeur_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setNewPipPggOrder (bool theValue)
   {
   prepSetNonUnpostAttr ();

   myProblem ()->myPipMgr ()->clearPegging ();

   newPipPggOrder_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setHighPrecisionWD (bool theValue)
   {
   prepSetUnpostAttr ();

   highPrecisionWD_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setNstnResidual (bool theValue)
   {
   prepSetUnpostAttr ();

   nstnResidual_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setMinimalExcess (bool theValue)
   {
   prepSetUnpostAttr ();

   minimalExcess_ = theValue;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitGlobalComp::setReadDataMsgs (bool theValue)
   {
   readDataMsgs_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPrintIncAlloc (bool theValue)
   {
   printIncAlloc_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPrintEqAlloc (bool theValue)
   {
   printEqAlloc_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setSelPrintLevel (int theValue)
   {
   selPrintLevel_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setTwmeByDemand (bool theValue)
   {
   twmeByDemand_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setSplitTol (double theValue)
   {
   splitTol_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setSplitRes (double theValue)
   {
   splitRes_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setSplitItrUB (int theValue)
   {
   splitItrUB_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPauses (bool theValue)
   {
   pauses_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPrtPipMaxRatio (bool theValue)
   {
   prtPipMaxRatio_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPrintDebug (bool theValue)
   {
   printDebug_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPrintExcessVol (bool theValue)
   {
   printExcessVol_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setTempPar (int index, const WitString & theValue)
   {
   checkTempParIndex (index);

   tempPar_.myElemAt (index) = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::storePreLotSizesExist (bool theValue)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   lotSizesExist_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::storePostFeasible (bool theValue)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   feasible_ = theValue;
   }

//------------------------------------------------------------------------------

bool WitGlobalComp::inserted ()
   {
   return (myCompMgr ()->myGlobalComp () == this);
   }

//------------------------------------------------------------------------------

WitMsgFrag WitGlobalComp::classMsgFrag ()
   {
   return myMsgFac ().myFrag ("globalFrag");
   }

//------------------------------------------------------------------------------

void WitGlobalComp::copySelfInto (WitCompMgr * theCompMgr)
   {
   theCompMgr->myGlobalComp ()->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::recount ()
   {
   myCompMgr ()->recountGlobalComp (this);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::unpreprocess ()
   {
   lotSizesExist_ = false;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::clearOptSoln  ()
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());

   revCritList_.clear ();
   }

//------------------------------------------------------------------------------

void WitGlobalComp::clearStochSoln ()
   {
   WitComponent::clearStochSoln ();

   feasible_ = false;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::display ()
   {
   myMsgFac () ("globalComp1DdMsg",
      multiExecNeeded (),
      twoWayMultiExec (),
      equitability    (),
      forcedMultiEq   (),
      userHeurStart   (),
      autoPriority    (),
      skipFailures    (),
      multiRoute      (),
      penExec         (),
      tieBreakPropRt  ());

   myMsgFac () ("globalComp2DdMsg",
      stockReallocation (),
      selSplit          (),
      respectStockSLBs  (),
      prefHighStockSLBs (),
      perfPegging       (),
      pipSeqFromHeur    (),
      newPipPggOrder    (),
      truncOffsets      (),
      highPrecisionWD   (),
      nstnResidual      (),
      minimalExcess     (),
      lotSizeTol        (),
      expCutoff         ());
   }

//------------------------------------------------------------------------------

bool WitGlobalComp::multiExecNeeded ()
   {
   return (multiExec_ or localMultiExec_);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::unpostprocess ()
   {
   feasible_ = false;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::clearRevCritListForHeur ()
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   revCritList_.clear ();
   }

//------------------------------------------------------------------------------

void WitGlobalComp::addToRevCritListForHeur (
      WitPart * thePart,
      WitPeriod thePer)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   revCritList_.push (thePart, thePer);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::receiveOptRevCritList (WitPartPerStack & thePartPerStack)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   revCritList_.takeContentsFrom (thePartPerStack);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::writePdgCritList ()
   {
   WitPclEl * thePclEl;

   stronglyAssert (DEVELOPMENT);

   fprintf (solnFile (),
      "\n"
      "Pegged Critical List:\n"
      "\n"
      "---------------------------\n"
      "Crit  Crit   Dem  Dem  Ship\n"
      "Part   Per  Part        Per\n"
      "---------------------------\n"
      );

   forEachEl (thePclEl, pgdCritList_)
      fprintf (solnFile (),
         "%4s   %3d    %2s  %3s   %3d\n",
         thePclEl->critPart ()->partName ()        .myCstring (),
         thePclEl->critPer (),
         thePclEl->myDemand ()->demandedPartName ().myCstring (),
         thePclEl->myDemand ()->demandName ()      .myCstring (),
         thePclEl->myShipPer ());
   }

//------------------------------------------------------------------------------

void WitGlobalComp::clearPgdCritList ()
   {
   while (not pgdCritList_.isEmpty ())
      delete pgdCritList_.get ();
   }

//------------------------------------------------------------------------------

void WitGlobalComp::appendToPgdCritListForHeur (WitPclEl * thePclEl)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   pgdCritList_.append (thePclEl);
   }

//------------------------------------------------------------------------------

bool WitGlobalComp::tempParIsSet (int index)
   {
   checkTempParIndex (index);

   return (tempPar (index) != "");
   }

//------------------------------------------------------------------------------

bool WitGlobalComp::tempParAsBool (int index)
   {
   checkTempParIndex (index);

   if (tempPar (index) == "yes")
      return true;

   if (tempPar (index) == "no")
      return false;

   myMsgFac () ("invalidBoolTempParSmsg", index, tempPar (index));

   return false;
   }

//------------------------------------------------------------------------------

int WitGlobalComp::tempParAsInt (int index)
   {
   int theValue;

   checkTempParIndex (index);

   if (sscanf (tempPar (index).myCstring (), "%d", & theValue) != 1)
      myMsgFac () ("invalidIntTempParSmsg", index, tempPar (index));

   return theValue;
   }

//------------------------------------------------------------------------------

double WitGlobalComp::tempParAsDouble (int index)
   {
   double theValue;

   checkTempParIndex (index);

   if (sscanf (tempPar (index).myCstring (), "%lg", & theValue) != 1)
      myMsgFac () ("invalidDoubleTempParSmsg", index, tempPar (index));

   return theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setNTempPars (int theValue)
   {
   int idx;

   for (idx = 1; idx <= nTempPars (); idx ++)
      delete tempPar_[idx];

   tempPar_.resize (theValue + 1);

   for (idx = 1; idx <= nTempPars (); idx ++)
      tempPar_[idx] = new WitString;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::checkTempParIndex (int i) const
   {
   stronglyAssert (i >= 1);
   stronglyAssert (i <= nTempPars ());
   }

//------------------------------------------------------------------------------

void WitGlobalComp::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
   }

//------------------------------------------------------------------------------

void WitGlobalComp::writeDataAttrs ()
   {
   WitComponent::writeDataAttrs ();

   myDataWriter ()->writeString (
        "title",
         title (),
      defTitle ());

   myDataWriter ()->writeInt (
        "nPeriods",
         nPeriods (),
      defNPeriods ());

   myDataWriter ()->writeBool (
        "independentOffsets",
         independentOffsets (),
      defIndependentOffsets ());

   myDataWriter ()->writeBool (
        "execEmptyBom",
         execEmptyBom (),
      defExecEmptyBom ());

   myDataWriter ()->writeInt (
        "hashTableSize",
         hashTableSize (),
      defHashTableSize ());

   myDataWriter ()->writeBool (
        "roundReqVols",
         roundReqVols (),
      defRoundReqVols ());

   myDataWriter ()->writeInt (
        "outputPrecision",
         outputPrecision (),
      defOutputPrecision ());

   myDataWriter ()->writeBool (
        "computeCriticalList",
         computeCriticalList (),
      defComputeCriticalList ());

   myDataWriter ()->writeBool (
        "pgdCritListMode",
         pgdCritListMode (),
      defPgdCritListMode ());

   myDataWriter ()->writeBool (
        "wit34Compatible",
         wit34Compatible (),
      defWit34Compatible ());

   myDataWriter ()->writeBool (
        "useFocusHorizons",
         useFocusHorizons (),
      defUseFocusHorizons ());

   myDataWriter ()->writeBool (
        "localBuildAhead",
         localBuildAhead (),
      defLocalBuildAhead ());

   myDataWriter ()->writeBool (
        "multiExec",
         multiExec (),
      defMultiExec ());

   myDataWriter ()->writeBool (
        "twoWayMultiExec",
         twoWayMultiExec (),
      defTwoWayMultiExec ());

   myDataWriter ()->writeBool (
        "localMultiExec",
         localMultiExec (),
      defLocalMultiExec ());

   myDataWriter ()->writeInt (
        "equitability",
         equitability (),
      defEquitability ());

   myDataWriter ()->writeBool (
        "forcedMultiEq",
         forcedMultiEq (),
      defForcedMultiEq ());

   myDataWriter ()->writeBool (
        "autoPriority",
         autoPriority (),
      defAutoPriority ());

   myDataWriter ()->writeBool (
        "skipFailures",
         skipFailures (),
      defSkipFailures ());

   myDataWriter ()->writeBool (
        "multiRoute",
         multiRoute (),
      defMultiRoute ());

   myDataWriter ()->writeBool (
        "truncOffsets",
         truncOffsets (),
      defTruncOffsets ());

   myDataWriter ()->writeDouble (
        "lotSizeTol",
         lotSizeTol (),
      defLotSizeTol ());

   myDataWriter ()->writeDouble (
        "expCutoff",
         expCutoff (),
      defExpCutoff ());

   myDataWriter ()->writeBool (
        "penExec",
         penExec (),
      defPenExec ());

   myDataWriter ()->writeBool (
        "tieBreakPropRt",
         tieBreakPropRt (),
      defTieBreakPropRt ());

   myDataWriter ()->writeBool (
        "stockRealloc",
         stockRealloc (),
      defStockRealloc ());

   myDataWriter ()->writeBool (
        "stockReallocation",
         stockReallocation (),
      defStockReallocation ());

   myDataWriter ()->writeBool (
        "srSelSplit",
         srSelSplit (),
      defSrSelSplit ());

   myDataWriter ()->writeBool (
        "respectStockSLBs",
         respectStockSLBs (),
      defRespectStockSLBs ());

   myDataWriter ()->writeBool (
        "prefHighStockSLBs",
         prefHighStockSLBs (),
      defPrefHighStockSLBs ());

   myDataWriter ()->writeBool (
        "perfPegging",
         perfPegging (),
      defPerfPegging ());

   myDataWriter ()->writeBool (
        "selSplit",
         selSplit (),
      defSelSplit ());

   myDataWriter ()->writeBool (
        "nonMrSelSplit",
         nonMrSelSplit (),
      defNonMrSelSplit ());

   myDataWriter ()->writeBool (
        "userHeurStart",
         userHeurStart (),
      defUserHeurStart ());

   myDataWriter ()->writeBool (
        "pipSeqFromHeur",
         pipSeqFromHeur (),
      defPipSeqFromHeur ());

   myDataWriter ()->writeBool (
        "newPipPggOrder",
         newPipPggOrder (),
      defNewPipPggOrder ());

   myDataWriter ()->writeBool (
        "highPrecisionWD",
         highPrecisionWD (),
      defHighPrecisionWD ());

   myDataWriter ()->writeBool (
        "nstnResidual",
         nstnResidual (),
      defNstnResidual ());

   myDataWriter ()->writeBool (
        "minimalExcess",
         minimalExcess (),
      defMinimalExcess ());
   }

//------------------------------------------------------------------------------

void WitGlobalComp::copyAttrsFrom (WitGlobalComp * theGlobalComp)
   {
   WitComponent::copyAttrsFrom (theGlobalComp);

   title_               = theGlobalComp->title_;
   nPeriods_            = theGlobalComp->nPeriods_;
   independentOffsets_  = theGlobalComp->independentOffsets_;
   execEmptyBom_        = theGlobalComp->execEmptyBom_;
   hashTableSize_       = theGlobalComp->hashTableSize_;
   roundReqVols_        = theGlobalComp->roundReqVols_;
   outputPrecision_     = theGlobalComp->outputPrecision_;
   computeCriticalList_ = theGlobalComp->computeCriticalList_;
   wit34Allowed_        = theGlobalComp->wit34Allowed_;
   localBuildAhead_     = theGlobalComp->localBuildAhead_;
   multiExec_           = theGlobalComp->multiExec_;
   twoWayMultiExec_     = theGlobalComp->twoWayMultiExec_;
   localMultiExec_      = theGlobalComp->localMultiExec_;
   equitability_        = theGlobalComp->equitability_;
   forcedMultiEq_       = theGlobalComp->forcedMultiEq_;
   autoPriority_        = theGlobalComp->autoPriority_;
   skipFailures_        = theGlobalComp->skipFailures_;
   multiRoute_          = theGlobalComp->multiRoute_;
   truncOffsets_        = theGlobalComp->truncOffsets_;
   lotSizeTol_          = theGlobalComp->lotSizeTol_;
   expCutoff_           = theGlobalComp->expCutoff_;
   penExec_             = theGlobalComp->penExec_;
   tieBreakPropRt_      = theGlobalComp->tieBreakPropRt_;
   stockRealloc_        = theGlobalComp->stockRealloc_;
   stockReallocation_   = theGlobalComp->stockReallocation_;
   srSelSplit_          = theGlobalComp->srSelSplit_;
   respectStockSLBs_    = theGlobalComp->respectStockSLBs_;
   prefHighStockSLBs_   = theGlobalComp->prefHighStockSLBs_;
   selSplit_            = theGlobalComp->selSplit_;
   nonMrSelSplit_       = theGlobalComp->nonMrSelSplit_;
   userHeurStart_       = theGlobalComp->userHeurStart_;
   pipSeqFromHeur_      = theGlobalComp->pipSeqFromHeur_;
   newPipPggOrder_      = theGlobalComp->newPipPggOrder_;
   highPrecisionWD_     = theGlobalComp->highPrecisionWD_;
   nstnResidual_        = theGlobalComp->nstnResidual_;
   minimalExcess_       = theGlobalComp->minimalExcess_;

   setPgdCritListMode    (theGlobalComp->pgdCritListMode_);
   setUseFocusHorizons   (theGlobalComp->useFocusHorizons_);
   setPerfPegging        (theGlobalComp->perfPegging_);

   setWit34Compatible (theGlobalComp->wit34Compatible_);

   myProblem ()->
      myPipMgr ()->
         copyShipSeq (theGlobalComp->myProblem ()->myPipMgr ());

   myProblem ()->updateNPeriods ();
   }
@


1.239
log
@Multi-Obj Mode
@
text
@@


1.238
log
@Multi-Obj Mode
@
text
@a91 1
      multiObjTol_         (0.0),
a652 7
void WitGlobalComp::setMultiObjTol (double theValue)
   {
   multiObjTol_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.237
log
@Added display of constraint violations > FEAS_TOL.
@
text
@d92 1
d114 1
a114 1
   setNTempPars (1);
d654 7
@


1.236
log
@Multi-Obj Mode
@
text
@a82 1
      reportIncViol_       (false),
a589 7
void WitGlobalComp::setReportIncViol (bool theValue)
   {
   reportIncViol_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.235
log
@Multi-objective mode
@
text
@d114 1
a114 1
   setNTempPars (0);
@


1.234
log
@Fixed bug: Printing of incHeurAlloc data is no longer controlled by the
           timesPrint mesg attribute.
@
text
@d145 1
a145 1
   title_.copyCstring (theValue);
@


1.233
log
@Revised wit34Allowed.
@
text
@d81 1
d577 7
@


1.232
log
@Fixed two bugs:
   wit34Allowed may not be set when wit34Compatible is TRUE.
   wit34Compatible does not get copied when wit34Allowed is FALSE.
@
text
@a240 2
   stronglyAssert (wit34Allowed_);

a255 3
   stronglyAssert (not theValue);
   stronglyAssert (not wit34Compatible_);

d1185 1
a1185 4
   if (wit34Allowed_)
      {
      setWit34Compatible (theGlobalComp->wit34Compatible_);
      }
@


1.231
log
@Implemented the undocumented "wit34Allowed" attribute.
@
text
@d259 1
a1186 1
   setWit34Compatible    (theGlobalComp->wit34Compatible_);
d1190 5
@


1.230
log
@Corrected a fscanf format.
@
text
@d49 1
d241 2
d256 11
d1156 1
@


1.229
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@d889 1
a889 1
   if (sscanf (tempPar (index).myCstring (), "%gl", & theValue) != 1)
@


1.228
log
@Stochastic Implosion
@
text
@d889 1
a889 1
   if (sscanf (tempPar (index).myCstring (), "%g", & theValue) != 1)
@


1.227
log
@Stochastic Implosion
@
text
@d652 9
a697 7
void WitGlobalComp::passPreRefs ()
   {
   myPreprocessor ()->receiveRefs (this, lotSizesExist_);
   }

//------------------------------------------------------------------------------

@


1.226
log
@Stochastic Implosion
@
text
@d26 3
@


1.225
log
@Stochastic Implosion
@
text
@d700 1
a700 1
void WitGlobalComp::importOptSoln ()
d702 3
a704 1
   myDetOptImpMgr ()->exportSoln (this, revCritList_);
d784 9
@


1.224
log
@Stochastic Implosion
@
text
@d762 20
d818 9
@


1.223
log
@Stochastic Implosion
@
text
@d20 1
d649 9
d755 7
@


1.222
log
@Stochastic Implosion
@
text
@d697 9
@


1.221
log
@ASAP Pegging Order.
@
text
@d24 1
a24 1
#include <OptImp.h>
d692 1
a692 1
   myOptImploder ()->exportSoln (this, revCritList_);
@


1.220
log
@ASAP pegging order
@
text
@a86 1
      allowAsapPip_        (false),
a638 7
void WitGlobalComp::setAllowAsapPip (bool theValue)
   {
   allowAsapPip_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.219
log
@ASAP Pegging Order
@
text
@d87 1
d640 7
@


1.218
log
@ASAP Pegging Order
@
text
@a86 1
      useNewMatPgg_        (false),
a638 7
void WitGlobalComp::setUseNewMatPgg (bool theValue)
   {
   useNewMatPgg_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.217
log
@Stochastic Implosion
@
text
@d87 1
d640 7
@


1.216
log
@Stochastic Implosion
@
text
@d690 1
a690 1
void WitGlobalComp::acquireOptSoln ()
d692 1
a692 1
   myOptImploder ()->provideSoln (this, revCritList_);
@


1.215
log
@Stochastic Implosion
@
text
@d692 1
a692 1
   myOptImploder ()->provideGlobalSoln (revCritList_);
@


1.214
log
@Stochastic Implosion
@
text
@a19 1
#include <PreData.h>
a682 7
void WitGlobalComp::importPreData ()
   {
   lotSizesExist_ = expPreData ()->lotSizesExist ();
   }

//------------------------------------------------------------------------------

@


1.213
log
@Stochastic Implosion
@
text
@d677 7
@


1.212
log
@Stochastic Implosion
@
text
@d20 1
d679 1
@


1.211
log
@Stochastic Implosion
@
text
@d676 6
@


1.210
log
@Stochastic Implosion
@
text
@d683 7
a721 7
void WitGlobalComp::importOptImpSoln ()
   {
   revCritList_.revCopyFrom (myOptImploder ()->criticalList ());
   }

//------------------------------------------------------------------------------

@


1.209
log
@Stochastic Implosion
@
text
@d119 1
a119 1
   return tempPar_ (index);
d643 1
a643 1
   tempPar_ (index) = theValue;
@


1.208
log
@Stochastic Implosion
@
text
@d676 7
a714 7
void WitGlobalComp::unpreprocess ()
   {
   lotSizesExist_ = false;
   }

//------------------------------------------------------------------------------

@


1.207
log
@Stochastic Implosion
@
text
@d715 1
a715 1
void WitGlobalComp::importOptImpSoln (WitPeriod thePer)
d717 1
@


1.206
log
@Stochastic Implosion
@
text
@d90 1
a90 1
      criticalList_        (),
d94 3
a96 5
   //---------------------------------------------------------------------------
   // The following statement normally sets nTempPars to 1, but it can 
   // altered to a larger number for testing purposes:
   //---------------------------------------------------------------------------

a98 2
   //---------------------------------------------------------------------------

a107 3
   while (not criticalList_.isEmpty ())
      delete  criticalList_.get ();

@


1.205
log
@Stochastic Implosion
@
text
@d24 1
d722 6
@


1.204
log
@Stochastic implosion.
@
text
@d143 1
a143 1
   settingNonUnpostAttr ();
d156 1
a156 1
   settingUnpreAttr ();
d169 1
a169 1
   settingUnpreAttr ();
d178 1
a178 1
   settingUnpreAttr ();
d189 1
a189 1
   settingNonUnpostAttr ();
d198 1
a198 1
   settingUnpostAttr ();
d209 1
a209 1
   settingNonUnpostAttr ();
d218 1
a218 1
   settingUnpostAttr ();
d231 1
a231 1
   settingUnpostAttr ();
d242 1
a242 1
   settingUnpreAttr ();
d257 1
a257 1
   settingNonUnpostAttr ();
d268 1
a268 1
   settingUnpostAttr ();
d283 1
a283 1
   settingUnpreAttr ();
d295 1
a295 1
   settingUnpreAttr ();
d307 1
a307 1
   settingUnpreAttr ();
d319 1
a319 1
   settingUnpostAttr ();
d328 1
a328 1
   settingUnpostAttr ();
d337 1
a337 1
   settingUnpostAttr ();
d346 1
a346 1
   settingUnpostAttr ();
d355 1
a355 1
   settingUnpreAttr ();
d364 1
a364 1
   settingUnpreAttr ();
d375 1
a375 1
   settingUnpostAttr ();
d386 1
a386 1
   settingUnpreAttr ();
d395 1
a395 1
   settingUnpostAttr ();
d404 1
a404 1
   settingUnpostAttr ();
d416 1
a416 1
   settingUnpostAttr ();
d428 1
a428 1
   settingUnpostAttr ();
d437 1
a437 1
   settingUnpostAttr ();
d446 1
a446 1
   settingUnpostAttr ();
d455 1
a455 1
   settingUnpostAttr ();
d464 1
a464 1
   settingUnpostAttr ();
d481 1
a481 1
   settingUnpostAttr ();
d493 1
a493 1
   settingUnpostAttr ();
d505 1
a505 1
   settingUnpostAttr ();
d514 1
a514 1
   settingUnpostAttr ();
d523 1
a523 1
   settingNonUnpostAttr ();
d534 1
a534 1
   settingUnpostAttr ();
d543 1
a543 1
   settingUnpostAttr ();
d552 1
a552 1
   settingUnpostAttr ();
@


1.203
log
@Stochastic implosion.
@
text
@d143 2
d189 2
d209 2
d257 2
d523 2
@


1.202
log
@Stochastic Implosion.
@
text
@d154 1
a154 1
   myPreprocessor ()->unpreprocess ();
d167 1
a167 1
   myPreprocessor ()->unpreprocess ();
d176 1
a176 1
   myPreprocessor ()->unpreprocess ();
d194 1
a194 1
   myProblem ()->resetSoln ();
d212 1
a212 1
   myProblem ()->resetSoln ();
d225 1
a225 1
   myProblem ()->resetSoln ();
d236 1
a236 1
   myPreprocessor ()->unpreprocess ();
d260 1
a260 1
   myProblem ()->resetSoln ();
d275 1
a275 1
   myPreprocessor ()->unpreprocess ();
d287 1
a287 1
   myPreprocessor ()->unpreprocess ();
d299 1
a299 1
   myPreprocessor ()->unpreprocess ();
d311 1
a311 1
   myProblem ()->resetSoln ();
d320 1
a320 1
   myProblem ()->resetSoln ();
d329 1
a329 1
   myProblem ()->resetSoln ();
d338 1
a338 1
   myProblem ()->resetSoln ();
d347 1
a347 1
   myPreprocessor ()->unpreprocess ();
d356 1
a356 1
   myPreprocessor ()->unpreprocess ();
d367 1
a367 1
   myProblem ()->resetSoln ();
d378 1
a378 1
   myPreprocessor ()->unpreprocess ();
d387 1
a387 1
   myProblem ()->resetSoln ();
d396 1
a396 1
   myProblem ()->resetSoln ();
d408 1
a408 1
   myProblem ()->resetSoln ();
d420 1
a420 1
   myProblem ()->resetSoln ();
d429 1
a429 1
   myProblem ()->resetSoln ();
d438 1
a438 1
   myProblem ()->resetSoln ();
d447 1
a447 1
   myProblem ()->resetSoln ();
d456 1
a456 1
   myProblem ()->resetSoln ();
d473 1
a473 1
   myProblem ()->resetSoln ();
d485 1
a485 1
   myProblem ()->resetSoln ();
d497 1
a497 1
   myProblem ()->resetSoln ();
d506 1
a506 1
   myProblem ()->resetSoln ();
d524 1
a524 1
   myProblem ()->resetSoln ();
d533 1
a533 1
   myProblem ()->resetSoln ();
d542 1
a542 1
   myProblem ()->resetSoln ();
@


1.201
log
@[disallowed scrap]
@
text
@d25 1
d651 7
@


1.200
log
@[disallowing scrap]
@
text
@a84 1
      allowSA_             (false),
a633 7
void WitGlobalComp::setAllowSA (bool theValue)
   {
   allowSA_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.199
log
@[disallowed backlog]
@
text
@d85 1
d635 7
@


1.198
log
@[disallowed backlog]
@
text
@a84 1
      allowDBL_            (false),
a633 7
void WitGlobalComp::setAllowDBL (bool theValue)
   {
   allowDBL_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.197
log
@[disallowed backlog]
@
text
@d85 1
a85 1
      allowBLA_            (false),
d635 1
a635 1
void WitGlobalComp::setAllowBLA (bool theValue)
d637 1
a637 1
   allowBLA_ = theValue;
@


1.196
log
@[disallowed backlog]
@
text
@a807 8
void WitGlobalComp::transmitDMPs ()
   {
   WitHeurAllMgr::receiveDMPs (& WitGlobalComp::criticalList_,
                               & WitGlobalComp::pgdCritList_);
   }

//------------------------------------------------------------------------------

@


1.195
log
@[disallowed backlog]
@
text
@d810 2
a811 3
   WitPreprocessor::receiveDMPs (& WitGlobalComp::lotSizesExist_);
   WitHeurAllMgr  ::receiveDMPs (& WitGlobalComp::criticalList_,
                                 & WitGlobalComp::pgdCritList_);
@


1.194
log
@Rescinded all changed made since 1/31/07.
@
text
@a19 1
#include <FeasChkr.h>
a23 1
#include <OptImp.h>
a812 2
   WitOptImploder ::receiveDMPs (& WitGlobalComp::criticalList_);
   WitFeasChkr    ::receiveDMPs (& WitGlobalComp::feasible_);
@


1.193
log
@[disallowed backlog]
@
text
@a34 2
      lotSizesExist_       (false),

d90 1
d706 7
d812 1
@


1.192
log
@[backlog avoidance]
@
text
@d35 2
a91 1
      lotSizesExist_       (false),
a706 7
void WitGlobalComp::unpreprocess ()
   {
   lotSizesExist_ = false;
   }

//------------------------------------------------------------------------------

a805 1
   WitPreprocessor::receiveDMPs (& WitGlobalComp::lotSizesExist_);
@


1.191
log
@[backlog avoidance]
@
text
@a73 1
      backlogAllowed_      (defBacklogAllowed      ()),
a549 11

void WitGlobalComp::setBacklogAllowed (bool theValue)
   {
   stronglyAssert (allowBLA_);

   myPreprocessor ()->unpreprocess ();

   backlogAllowed_ = theValue;
   }

//------------------------------------------------------------------------------
a695 1
      backlogAllowed    (),
a1049 5

   myDataWriter ()->writeBool (
        "backlogAllowed",
         backlogAllowed (),
      defBacklogAllowed ());
a1092 1
   backlogAllowed_      = theGlobalComp->backlogAllowed_;
@


1.190
log
@witCopy<Object>Data
@
text
@d74 1
d88 1
d551 11
d649 7
d708 1
d1063 5
d1111 1
@


1.189
log
@witCopy<Object>Data
@
text
@a801 28
void WitGlobalComp::checkForCopyObjData (WitGlobalComp * origGlobalComp)
   {
   if (nPeriods_ != origGlobalComp->nPeriods_)
      {
      myMsgFac () ("copyObjDiffNPeriodsSmsg",
                         nPeriods_,
         origGlobalComp->nPeriods_);
      }
 
   if (wit34Compatible_ != origGlobalComp->wit34Compatible_)
      {
      myMsgFac () ("copyObjDiffBooAttSmsg",
                        "wit34Compatible",
                         wit34Compatible_,
         origGlobalComp->wit34Compatible_);
      }

   if (independentOffsets_ != origGlobalComp->independentOffsets_)
      {
      myMsgFac () ("copyObjDiffBooAttSmsg",
                        "independentOffsets",
                         independentOffsets_,
         origGlobalComp->independentOffsets_);
      }
   }

//------------------------------------------------------------------------------

@


1.188
log
@witCopy<Object>Data
@
text
@d802 28
@


1.187
log
@witCopy<Object>Data
@
text
@a88 1
      allowCopyObjData_    (false),
a644 7
void WitGlobalComp::setAllowCopyObjData (bool theValue)
   {
   allowCopyObjData_ = theValue;
   }

//------------------------------------------------------------------------------

a1057 3
   setPgdCritListMode    (theGlobalComp->pgdCritListMode_);
   setWit34Compatible    (theGlobalComp->wit34Compatible_);
   setUseFocusHorizons   (theGlobalComp->useFocusHorizons_);
a1076 1
   setPerfPegging        (theGlobalComp->perfPegging_);
d1086 5
@


1.186
log
@external opt implosion.
@
text
@d89 1
d646 7
@


1.185
log
@Heuristic search increment.
@
text
@d20 1
a20 1
#include <Post.h>
a704 7
void WitGlobalComp::unpostprocess ()
   {
   feasible_ = false;
   }

//------------------------------------------------------------------------------

d804 5
a808 5
   WitPreprocessor ::receiveDMPs (& WitGlobalComp::lotSizesExist_);
   WitHeurAllMgr   ::receiveDMPs (& WitGlobalComp::criticalList_,
                                  & WitGlobalComp::pgdCritList_);
   WitOptImploder  ::receiveDMPs (& WitGlobalComp::criticalList_);
   WitPostprocessor::receiveDMPs (& WitGlobalComp::feasible_);
@


1.184
log
@Heuristic search increment.
@
text
@a73 1
      heurSearchInc_       (defHeurSearchInc       ()),
a548 13

void WitGlobalComp::setHeurSearchInc (double theValue)
   {
   stronglyAssert (DEVELOPMENT);

   witAssert (theValue >= 0.000999);

   myProblem ()->resetSoln ();

   heurSearchInc_ = theValue;
   }

//------------------------------------------------------------------------------
d693 1
a693 2
      expCutoff         (),
      heurSearchInc     ());
a1048 5

   myDataWriter ()->writeDouble (
        "heurSearchInc",
         heurSearchInc (),
      defHeurSearchInc ());
a1095 1
   heurSearchInc_       = theGlobalComp->heurSearchInc_;
@


1.183
log
@App controlled opt implosion.
@
text
@d74 1
d550 13
d707 2
a708 1
      expCutoff         ());
d1064 5
d1116 1
@


1.182
log
@App controlled opt implosion.
@
text
@a85 1
      allowIntVars_        (false),
a628 7
void WitGlobalComp::setAllowIntVars (bool theValue)
   {
   allowIntVars_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.181
log
@App controlled opt implosion.
@
text
@a25 1
#include <DataAlt.h>
d143 3
a145 1
   title_.copyCstring (prepString (theValue, noOpAlt ()));
d154 5
a158 1
   nPeriods_ = prepRangedInt (theValue, preprocAlt (), 1, -1);
d169 3
a171 1
   independentOffsets_ = prepBool (theValue, preprocAlt ());
d178 3
a180 1
   execEmptyBom_ = prepBool (theValue, preprocAlt ());
d187 3
a189 1
   hashTableSize_ = prepRangedInt (theValue, noOpAlt (), 0, -1);
d196 3
a198 1
   roundReqVols_ = prepBool (theValue, postprocAlt ());
d205 3
a207 1
   outputPrecision_ = prepRangedInt (theValue, noOpAlt (), 0, -1);
d214 3
a216 1
   computeCriticalList_ = prepBool (theValue, postprocAlt ());
d227 3
a229 1
   pgdCritListMode_ = prepBool (theValue, postprocAlt ());
d238 1
a238 1
   preprocAlt ()->incur ();
d255 1
a255 1
   useFocusHorizons_ = prepBool (theValue, noOpAlt ());
d262 3
a264 1
   localBuildAhead_ = prepBool (theValue, postprocAlt ());
d277 3
a279 1
   multiExec_ = prepBool (theValue, preprocAlt ());
d289 3
a291 1
   twoWayMultiExec_ = prepBool (theValue, preprocAlt ());
d301 3
a303 1
   localMultiExec_ = prepBool (theValue, preprocAlt ());
d310 6
a315 1
   equitability_ = prepRangedInt (theValue, postprocAlt (), 1, 100);
d322 3
a324 1
   forcedMultiEq_ = prepBool (theValue, postprocAlt ());
d331 3
a333 1
   autoPriority_ = prepBool (theValue, postprocAlt ());
d340 3
a342 1
   skipFailures_ = prepBool (theValue, postprocAlt ());
d349 3
a351 1
   multiRoute_ = prepBool (theValue, preprocAlt ());
d358 3
a360 1
   truncOffsets_ = prepBool (theValue, preprocAlt ());
d367 5
a371 1
   lotSizeTol_ = prepNonNegDouble (theValue, postprocAlt ());
d380 3
a382 1
   expCutoff_ = prepDouble (theValue, preprocAlt ());
d389 3
a391 1
   penExec_ = prepBool (theValue, postprocAlt ());
d398 3
a400 1
   tieBreakPropRt_ = prepBool (theValue, postprocAlt ());
d410 3
a412 1
   stockRealloc_ = prepBool (theValue, postprocAlt ());
d422 3
a424 1
   stockReallocation_ = prepBool (theValue, postprocAlt ());
d431 3
a433 1
   srSelSplit_ = prepBool (theValue, postprocAlt ());
d440 3
a442 1
   respectStockSLBs_ = prepBool (theValue, postprocAlt ());
d449 3
a451 1
   prefHighStockSLBs_ = prepBool (theValue, postprocAlt ());
d458 1
a458 1
   prepBool (theValue, postprocAlt ());
d475 2
d480 1
a480 1
   selSplit_ = prepBool (theValue, postprocAlt ());
d487 2
d492 1
a492 1
   nonMrSelSplit_ = prepBool (theValue, postprocAlt ());
d499 3
a501 1
   userHeurStart_ = prepBool (theValue, postprocAlt ());
d508 3
a510 1
   pipSeqFromHeur_ = prepBool (theValue, postprocAlt ());
d519 1
a519 1
   newPipPggOrder_ = prepBool (theValue, noOpAlt ());
d526 3
a528 1
   highPrecisionWD_ = prepBool (theValue, postprocAlt ());
d535 3
a537 1
   nstnResidual_ = prepBool (theValue, postprocAlt ());
d544 3
a546 1
   minimalExcess_ = prepBool (theValue, postprocAlt ());
@


1.180
log
@NSTN residual.
@
text
@d276 1
a276 1
   localMultiExec_ = prepBool (theValue, postprocAlt ());
@


1.179
log
@NSTN residualVol.
@
text
@a87 1
      allowNstnRes_        (false),
a462 2
   witAssert (allowNstnRes_);

a469 2
   witAssert (allowNstnRes_);

a560 7
void WitGlobalComp::setAllowNstnRes (bool theValue)
   {
   allowNstnRes_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.178
log
@NSTN residualVol.
@
text
@d74 1
d470 9
d635 1
d988 5
d1039 1
@


1.177
log
@NSTN residualVols.
@
text
@d88 1
d563 7
@


1.176
log
@App controlled opt implosion.
@
text
@d73 1
d87 1
d459 9
d555 7
d616 1
d964 5
d1014 1
@


1.175
log
@App controlled opt implode.
@
text
@a141 2

   myOptImploder ()->recTitleUpdate ();
@


1.174
log
@Opt implosion with integrality constraints.
@
text
@d142 2
@


1.173
log
@GPIP migration.
@
text
@d85 1
d537 7
@


1.172
log
@GPIP migration.
@
text
@d83 1
a83 1
      prtGpipMaxRatio_     (false),
d522 1
a522 1
void WitGlobalComp::setPrtGpipMaxRatio (bool theValue)
d524 1
a524 1
   prtGpipMaxRatio_ = theValue;
@


1.171
log
@GPIP migration
@
text
@a70 1
      groupPipMode_        (defGroupPipMode        ()),
a979 1
   groupPipMode_        = theGlobalComp->groupPipMode_;
@


1.170
log
@New PIP pegging order.
@
text
@a441 9
void WitGlobalComp::setGroupPipMode (bool theValue)
   {
   myProblem ()->myPipMgr ()->clearPegging ();

   groupPipMode_ = prepBool (theValue, noOpAlt ());
   }

//------------------------------------------------------------------------------

a587 1
      groupPipMode      (),
a929 5
        "groupPipMode",
         groupPipMode (),
      defGroupPipMode ());

   myDataWriter ()->writeBool (
@


1.169
log
@New PIP pegging order.
@
text
@a85 1
      allowGpipNpo_        (false),
a545 7
void WitGlobalComp::setAllowGpipNpo (bool theValue)
   {
   allowGpipNpo_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.168
log
@New PIP pegging order.
@
text
@d86 1
d547 7
@


1.167
log
@New PIP pegging order.
@
text
@a85 1
      allowNewPipOrd_      (false),
a452 2
   stronglyAssert (allowNewPipOrd_);

a545 7
void WitGlobalComp::setAllowNewPipOrd (bool theValue)
   {
   allowNewPipOrd_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.166
log
@New PIP pegging order.
@
text
@d85 1
a85 1
      printGpip_           (false),
d542 1
a542 1
void WitGlobalComp::setPrintGpip (bool theValue)
d544 1
a544 1
   printGpip_ = theValue;
@


1.165
log
@Updated the copyright date on all source files.
@
text
@d72 1
d86 1
d452 11
d549 7
d608 1
d955 5
d1007 1
@


1.164
log
@GPIP
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.163
log
@Fixed bugs:
   witWriteData didn't write problem.compPrices.
   witWriteData didn't write problem.accMethod.
   witCopyData  didn't copy  problem.solverLogFileName.
   witCopyData  didn't copy  problem.accMethod.
@
text
@d443 3
a445 1
   groupPipMode_ = prepBool (theValue, postprocAlt ());
@


1.162
log
@Removed unistd.h.
Regenerated witLexer.C.
Minor updates for GPIP.
@
text
@d951 3
d973 1
a980 5
   setPgdCritListMode    (theGlobalComp->pgdCritListMode_);
   setWit34Compatible    (theGlobalComp->wit34Compatible_);
   setUseFocusHorizons   (theGlobalComp->useFocusHorizons_);
   setPerfPegging        (theGlobalComp->perfPegging_);

@


1.161
log
@GPIP
@
text
@d943 1
a944 2
   hashTableSize_       = theGlobalComp->hashTableSize_;
   computeCriticalList_ = theGlobalComp->computeCriticalList_;
d947 1
d950 1
a975 1
   title_               = theGlobalComp->title_;
d977 1
a980 1
   setPgdCritListMode    (theGlobalComp->pgdCritListMode_);
@


1.160
log
@GPIP
@
text
@a82 1
      allowGpipMode_       (false),
a442 2
   stronglyAssert (allowGpipMode_);

a519 7
void WitGlobalComp::setAllowGpipMode (bool theValue)
   {
   allowGpipMode_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.159
log
@GPIP
@
text
@d84 1
d530 7
@


1.158
log
@[shared-resource pegging]
@
text
@d71 1
a71 1
      srpMode_             (defSrpMode             ()),
d83 2
a84 2
      allowSrpMode_        (false),
      printSrpDB_          (false),
d441 1
a441 1
void WitGlobalComp::setSrpMode (bool theValue)
d443 1
a443 1
   stronglyAssert (allowSrpMode_);
d445 1
a445 1
   srpMode_ = prepBool (theValue, postprocAlt ());
d522 1
a522 1
void WitGlobalComp::setAllowSrpMode (bool theValue)
d524 1
a524 1
   allowSrpMode_ = theValue;
d529 1
a529 1
void WitGlobalComp::setPrintSrpDB (bool theValue)
d531 1
a531 1
   printSrpDB_ = theValue;
d587 1
a587 1
      srpMode           (),
d929 3
a931 3
        "srpMode",
         srpMode (),
      defSrpMode ());
d975 1
a975 1
   srpMode_             = theGlobalComp->srpMode_;
@


1.157
log
@[shared-resource pegging]
@
text
@a84 1
      newPip_              (false),
a535 7
void WitGlobalComp::setNewPip (bool theValue)
   {
   newPip_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.156
log
@[shared-resource pegging]
@
text
@d85 1
d537 7
@


1.155
log
@[shared-resource pegging]
@
text
@a25 1
#include <PerPair.h>
@


1.154
log
@Began [shared-resource pegging]
@
text
@d85 1
d530 7
@


1.153
log
@[multi-thread]
@
text
@d72 1
d84 1
d441 9
d522 7
d580 1
d922 5
d968 1
@


1.152
log
@Cut-over to the new interpretation of pipShare.
@
text
@a576 28
void WitGlobalComp::loadPre ()
   {
   myPreprocessor ()->loadDataFromGlobalComp (lotSizesExist_);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::loadPost ()
   {
   myPostprocessor ()->loadDataFromGlobalComp (feasible_);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::loadHeur ()
   {
   myHeurAllMgr ()->loadDataFromGlobalComp (criticalList_, pgdCritList_);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::loadOpt ()
   {
   myOptImploder ()->loadDataFromGlobalComp (criticalList_);
   }

//------------------------------------------------------------------------------

d681 11
@


1.151
log
@Began work on the new interpretation of pipShare.
@
text
@a82 1
      newPipShare_         (false),
a510 7
void WitGlobalComp::setNewPipShare (bool theValue)
   {
   newPipShare_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.150
log
@Trivial update.
@
text
@d83 1
d512 7
@


1.149
log
@Vector PropRtg.
@
text
@a82 1
      allowVecPR_          (true),
a510 7
void WitGlobalComp::setAllowVecPR (bool theValue)
   {
   allowVecPR_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.148
log
@Vector propRt.
@
text
@d83 1
a83 1
      allowVecPR_          (false),
@


1.147
log
@Pegged Critical List
@
text
@d83 1
d512 7
@


1.146
log
@Pegged Critical List
@
text
@d647 8
a974 8

//------------------------------------------------------------------------------

void WitGlobalComp::clearPgdCritList ()
   {
   while (not pgdCritList_.isEmpty ())
      delete  pgdCritList_.get ();
   }
@


1.145
log
@Pegged Critical List.
@
text
@d106 1
a106 2
   while (not pgdCritList_.isEmpty ())
      delete  pgdCritList_.get ();
d200 4
d967 8
@


1.144
log
@Pegged Critical List.
@
text
@d626 5
a630 3
      "   -------------------------\n"
      "   Part  Dem  Per  Part  Per\n"
      "   -------------------------\n");
d634 3
a636 1
         "   %4s  %3s  %3d  %4s  %3d\n",
d639 1
a639 3
         thePclEl->myShipPer (),
         thePclEl->critPart ()->partName ()        .myCstring (),
         thePclEl->critPer ());
@


1.143
log
@Pegged Critical List.
@
text
@a82 1
      allowPCL_            (false),
a507 7
void WitGlobalComp::setAllowPCL (bool theValue)
   {
   allowPCL_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.142
log
@pegged Critical List.
@
text
@d45 1
a45 1
      pgdCritListNeeded_   (defPgdCritListNeeded   ()),
d200 1
a200 1
void WitGlobalComp::setPgdCritListNeeded (bool theValue)
d202 1
a202 1
   pgdCritListNeeded_ = prepBool (theValue, postprocAlt ());
d780 3
a782 3
        "pgdCritListNeeded",
         pgdCritListNeeded (),
      defPgdCritListNeeded ());
d959 4
a962 4
   setWit34Compatible   (theGlobalComp->wit34Compatible_);
   setUseFocusHorizons  (theGlobalComp->useFocusHorizons_);
   setPerfPegging       (theGlobalComp->perfPegging_);
   setPgdCritListNeeded (theGlobalComp->pgdCritListNeeded_);
@


1.141
log
@Pegged Critical List.
@
text
@d24 1
d88 1
d107 5
a111 2
   while (not  criticalList_.isEmpty ())
      delete criticalList_.get ();
d202 1
a202 11
   prepBool (theValue, postprocAlt ());

   if (pgdCritListNeeded_ == theValue)
      return;

   pgdCritListNeeded_ = theValue;

   if (theValue)
      myProblem ()->myHeurAllMgr ()->setUpPcl ();
   else
      myProblem ()->myHeurAllMgr ()->shutDownPcl ();
d598 1
a598 1
   myHeurAllMgr ()->loadDataFromGlobalComp (criticalList_);
d624 26
@


1.140
log
@Pegged Critical List
@
text
@a196 2
   stronglyAssert (allowPCL_);

a907 1
   pgdCritListNeeded_   = theGlobalComp->pgdCritListNeeded_;
d938 4
a941 3
   setWit34Compatible  (theGlobalComp->wit34Compatible_);
   setUseFocusHorizons (theGlobalComp->useFocusHorizons_);
   setPerfPegging      (theGlobalComp->perfPegging_);
@


1.139
log
@Pegged Critical List.
@
text
@d44 1
a44 1
      compPgdCritList_     (defCompPgdCritList     ()),
d195 1
a195 1
void WitGlobalComp::setCompPgdCritList (bool theValue)
d201 1
a201 1
   if (compPgdCritList_ == theValue)
d204 1
a204 1
   compPgdCritList_ = theValue;
d761 3
a763 3
        "compPgdCritList",
         compPgdCritList (),
      defCompPgdCritList ());
d910 1
a910 1
   compPgdCritList_     = theGlobalComp->compPgdCritList_;
@


1.138
log
@Tie Breaking Prop-Rt.
@
text
@d44 1
d82 1
d195 19
d395 2
d400 1
a400 1
   perfPegging_ = prepBool (theValue, postprocAlt ());
d516 7
d761 5
d910 1
@


1.137
log
@Changed terminology from "low priority proportionate routing" to
"tie breaking proportionate routing".
@
text
@d22 1
a22 1
#include <PipSysMgr.h>
d909 3
a911 2
   myProblem ()->myPipSysMgr ()->copyShipSeq (
      theGlobalComp->myProblem ()->myPipSysMgr ());
@


1.136
log
@Low-Pri Prop-Rt.
@
text
@d59 1
a59 1
      lowPriPropRt_        (defLowPriPropRt        ()),
d324 1
a324 1
void WitGlobalComp::setLowPriPropRt (bool theValue)
d326 1
a326 1
   lowPriPropRt_ = prepBool (theValue, postprocAlt ());
d535 1
a535 1
      lowPriPropRt    ());
d806 3
a808 3
        "lowPriPropRt",
         lowPriPropRt (),
      defLowPriPropRt ());
d892 1
a892 1
   lowPriPropRt_        = theGlobalComp->lowPriPropRt_;
@


1.135
log
@Low-Pri Prop-Rt.
@
text
@a80 1
      allowLPPR_           (false),
a325 2
   stronglyAssert (allowLPPR_);

a492 7
void WitGlobalComp::setAllowLPPR (bool theValue)
   {
   allowLPPR_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.134
log
@Low-Pri Prop-Rt.
@
text
@a81 1
      newPropRt_           (true),
a502 7
void WitGlobalComp::setNewPropRt (bool theValue)
   {
   newPropRt_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.133
log
@Low-Pri Prop-Rt.
@
text
@d82 1
a82 1
      newPropRt_           (false),
@


1.132
log
@Low-Pri Prop-Rt.
@
text
@d82 1
d504 7
@


1.131
log
@Low-Pri Prop-Rt.
@
text
@d81 1
a81 1
      allowLowPriPR_       (false),
d327 1
a327 1
   stronglyAssert (allowLowPriPR_);
d496 1
a496 1
void WitGlobalComp::setAllowLowPriPR (bool theValue)
d498 1
a498 1
   allowLowPriPR_ = theValue;
@


1.130
log
@Continued implmentation of low priority proportionate routing.
@
text
@a549 2
      nonMrSelSplit     (),
      srSelSplit        (),
@


1.129
log
@Continued implementation of pen-exec override of prop-rt.
@
text
@d59 1
a59 1
      penExecOverPropRt_   (defPenExecOverPropRt   ()),
d81 1
a81 1
      allowPeOverPr_       (false),
d325 1
a325 1
void WitGlobalComp::setPenExecOverPropRt (bool theValue)
d327 1
a327 1
   stronglyAssert (allowPeOverPr_);
d329 1
a329 1
   penExecOverPropRt_ = prepBool (theValue, postprocAlt ());
d496 1
a496 1
void WitGlobalComp::setAllowPeOverPr (bool theValue)
d498 1
a498 1
   allowPeOverPr_ = theValue;
d536 10
a545 10
      multiExecNeeded   (),
      twoWayMultiExec   (),
      equitability      (),
      forcedMultiEq     (),
      userHeurStart     (),
      autoPriority      (),
      skipFailures      (),
      multiRoute        (),
      penExec           (),
      penExecOverPropRt ());
d818 3
a820 3
        "penExecOverPropRt",
         penExecOverPropRt (),
      defPenExecOverPropRt ());
d904 1
a904 1
   penExecOverPropRt_   = theGlobalComp->penExecOverPropRt_;
@


1.128
log
@Began work on [propRouting as penExec tie-breaker].
@
text
@d81 1
a81 1
      peOverPrAllowed_     (false),
d327 1
a327 1
   stronglyAssert (peOverPrAllowed_);
d496 1
a496 1
void WitGlobalComp::setPeOverPrAllowed (bool theValue)
d498 1
a498 1
   peOverPrAllowed_ = theValue;
@


1.127
log
@PIP.
@
text
@d59 1
d81 1
d325 9
d496 7
d544 2
a545 1
      penExec           ());
d818 5
d904 1
@


1.126
log
@PIP.
@
text
@a80 1
      allowMultiPip_       (false),
a480 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowMultiPip (bool theValue)
   {
   allowMultiPip_ = theValue;
@


1.125
log
@PIP.
@
text
@d81 1
a81 1
      allowMoPip_          (false),
d486 1
a486 1
void WitGlobalComp::setAllowMoPip (bool theValue)
d488 1
a488 1
   allowMoPip_ = theValue;
@


1.124
log
@Double Precision.
@
text
@d81 1
d482 7
@


1.123
log
@Double Precision.
@
text
@d69 1
d412 7
d538 1
d847 5
d889 1
@


1.122
log
@Double Precision.
@
text
@d481 1
a481 1
   tempPar_ (index).copy (theValue);
d875 1
a875 2

   title_.copy (theGlobalComp->title_);
@


1.121
log
@Double Precision.
@
text
@d83 1
a83 2
      feasible_            (false),
      lastPeriod_          (defNPeriods () - 1)
d140 1
a140 1
   nPeriods_   = prepRangedInt (theValue, preprocAlt (), 1, -1);
d142 1
a142 1
   lastPeriod_ = nPeriods_ - 1;
a875 2
   lastPeriod_          = nPeriods_ - 1;

d884 2
@


1.120
log
@Double Precision.
@
text
@d143 1
a143 1
   lastPeriod_ = nPeriods () - 1;
d847 37
a883 37
   nPeriods_            = theGlobalComp->nPeriods            ();
   hashTableSize_       = theGlobalComp->hashTableSize       ();
   computeCriticalList_ = theGlobalComp->computeCriticalList ();
   independentOffsets_  = theGlobalComp->independentOffsets  ();
   execEmptyBom_        = theGlobalComp->execEmptyBom        ();
   roundReqVols_        = theGlobalComp->roundReqVols        ();
   outputPrecision_     = theGlobalComp->outputPrecision     ();
   localBuildAhead_     = theGlobalComp->localBuildAhead     ();
   multiExec_           = theGlobalComp->multiExec           ();
   twoWayMultiExec_     = theGlobalComp->twoWayMultiExec     ();
   localMultiExec_      = theGlobalComp->localMultiExec      ();
   equitability_        = theGlobalComp->equitability        ();
   forcedMultiEq_       = theGlobalComp->forcedMultiEq       ();
   autoPriority_        = theGlobalComp->autoPriority        ();
   skipFailures_        = theGlobalComp->skipFailures        ();
   multiRoute_          = theGlobalComp->multiRoute          ();
   truncOffsets_        = theGlobalComp->truncOffsets        ();
   lotSizeTol_          = theGlobalComp->lotSizeTol          ();
   expCutoff_           = theGlobalComp->expCutoff           ();
   penExec_             = theGlobalComp->penExec             ();
   stockRealloc_        = theGlobalComp->stockRealloc        ();
   stockReallocation_   = theGlobalComp->stockReallocation   ();
   srSelSplit_          = theGlobalComp->srSelSplit          ();
   respectStockSLBs_    = theGlobalComp->respectStockSLBs    ();
   prefHighStockSLBs_   = theGlobalComp->prefHighStockSLBs   ();
   selSplit_            = theGlobalComp->selSplit            ();
   nonMrSelSplit_       = theGlobalComp->nonMrSelSplit       ();
   userHeurStart_       = theGlobalComp->userHeurStart       ();
   pipSeqFromHeur_      = theGlobalComp->pipSeqFromHeur      ();

   lastPeriod_          = nPeriods () - 1;

   title_.copy (theGlobalComp->title ());

   setWit34Compatible  (theGlobalComp->wit34Compatible ());
   setUseFocusHorizons (theGlobalComp->useFocusHorizons ());
   setPerfPegging      (theGlobalComp->perfPegging ());
@


1.119
log
@Double Precision.
@
text
@a26 1
#include <RealVec.h>
a111 7
bool WitGlobalComp::doubleMode ()
   {
   return WitRealVec::doubleMode ();
   }

//------------------------------------------------------------------------------

a411 7

void WitGlobalComp::setDoubleMode (bool theValue)
   {
   WitRealVec::setDoubleMode (theValue);
   }

//------------------------------------------------------------------------------
d532 1
a532 2
      expCutoff         (),
      doubleMode        ());
a838 5

   myDataWriter ()->writeBool (
        "doubleMode",
         doubleMode (),
         false);
@


1.118
log
@Double Precision.
@
text
@d465 1
a465 1
void WitGlobalComp::setSplitTol (float theValue)
d472 1
a472 1
void WitGlobalComp::setSplitRes (float theValue)
d642 1
a642 1
float WitGlobalComp::tempParAsFloat (int index)
d644 1
a644 1
   float theValue;
d649 1
a649 1
      myMsgFac () ("invalidFloatTempParSmsg", index, tempPar (index));
@


1.117
log
@Double Precision.
@
text
@a422 5
   if (Use_ModeRV)
      myMsgFac () ("useModeRVMsg");
   else
      myMsgFac () ("useFixedRVMsg");

@


1.116
log
@Double Precision.
@
text
@d423 5
@


1.115
log
@Continued double precision.
@
text
@d27 1
d113 7
d420 7
d547 2
a548 1
      expCutoff         ());
d855 5
@


1.114
log
@Continued double precision.
@
text
@d300 1
a300 1
void WitGlobalComp::setLotSizeTol (StrDbl theValue)
d302 1
a302 1
   lotSizeTol_ = prepNonNegStrDbl (theValue, postprocAlt ());
d307 1
a307 1
void WitGlobalComp::setExpCutoff (StrDbl theValue)
d311 1
a311 1
   expCutoff_ = prepStrDbl (theValue, preprocAlt ());
d775 1
a775 1
   myDataWriter ()->writeStrDbl (
d780 1
a780 1
   myDataWriter ()->writeStrDbl (
@


1.113
log
@Removed the "pip" attribute.
@
text
@d307 1
a307 1
void WitGlobalComp::setExpCutoff (float theValue)
d311 1
a311 1
   expCutoff_ = prepFloat (theValue, preprocAlt ());
d780 1
a780 1
   myDataWriter ()->writeFloat (
@


1.112
log
@Continued double precision.
@
text
@a64 1
      pip_                 (defPip                 ()),
a378 7
void WitGlobalComp::setPip (bool theValue)
   {
   pip_ = prepBool (theValue, preprocAlt ());
   }

//------------------------------------------------------------------------------

a528 1
      pip               (),
a820 5
        "pip",
         pip (),
      defPip ());

   myDataWriter ()->writeBool (
a875 1
   pip_                 = theGlobalComp->pip                 ();
@


1.111
log
@Continued double precision.
@
text
@d301 1
a301 1
void WitGlobalComp::setLotSizeTol (double theValue)
d303 1
a303 1
   lotSizeTol_ = prepNonNegDouble (theValue, postprocAlt ());
d784 1
a784 1
   myDataWriter ()->writeDouble (
@


1.110
log
@Began implementation of double precision.
@
text
@d301 1
a301 1
void WitGlobalComp::setLotSizeTol (float theValue)
d303 1
a303 1
   lotSizeTol_ = prepNonNegFloat (theValue, postprocAlt ());
d784 1
a784 1
   myDataWriter ()->writeFloat (
@


1.109
log
@Continued implementation of PIP.
@
text
@d79 1
d475 7
@


1.108
log
@Continued implementation of PIP.
@
text
@d69 1
a69 1
      heurPipSeq_          (defHeurPipSeq          ()),
d413 1
a413 1
void WitGlobalComp::setHeurPipSeq (bool theValue)
d415 1
a415 1
   heurPipSeq_ = prepBool (theValue, postprocAlt ());
d530 1
a530 1
      heurPipSeq        (),
d842 3
a844 3
        "heurPipSeq",
         heurPipSeq (),
      defHeurPipSeq ());
d881 1
a881 1
   heurPipSeq_          = theGlobalComp->heurPipSeq          ();
@


1.107
log
@Continued implementation of PIP.
@
text
@a69 4
      pipSeqPartName_      (defPipSeqPartName      ()),
      pipSeqDemandName_    (defPipSeqDemandName    ()),
      pipSeqShipPeriod_    (defPipSeqShipPeriod    ()),
      pipSeqIncShipVol_    (defPipSeqIncShipVol    ()),
a415 28
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPipSeqPartName (const char * theValue)
   {
   pipSeqPartName_.copyCstring (prepString (theValue, noOpAlt ()));
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPipSeqDemandName (const char * theValue)
   {
   pipSeqDemandName_.copyCstring (prepString (theValue, noOpAlt ()));
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPipSeqShipPeriod (int theValue)
   {
   pipSeqShipPeriod_ = prepRangedInt (theValue, noOpAlt (), 0, nPeriods () - 1);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setPipSeqIncShipVol (float theValue)
   {
   pipSeqIncShipVol_ = prepNonNegFloat (theValue, noOpAlt ());
@


1.106
log
@Continued implementation of PIP.
@
text
@d70 4
d420 28
@


1.105
log
@Implemented copying of the PIP shipment sequence.
@
text
@d22 1
a22 1
#include <PipMgr.h>
d892 2
a893 2
   myProblem ()->myPipMgr ()->copyShipSeq (
      theGlobalComp->myProblem ()->myPipMgr ());
@


1.104
log
@Continued implementation of PIP.
@
text
@d22 1
d886 1
a886 1
   title_ .copy (theGlobalComp->title ());
d891 3
@


1.103
log
@Continued implementation of PIP.
@
text
@a77 1
      allowPipSeq_         (false),
a413 2
   stronglyAssert (allowPipSeq_);

a472 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowPipSeq (bool theValue)
   {
   allowPipSeq_ = theValue;
@


1.102
log
@Continued implementation of PIP.
@
text
@d24 1
a25 1
#include <PerPair.h>
@


1.101
log
@Continued implementation of PIP.
@
text
@d68 1
d78 1
a78 2
      revPipSeq_           (false),
      allowShipSeq_        (false),
d412 9
d480 1
a480 1
void WitGlobalComp::setRevPipSeq (bool theValue)
d482 1
a482 8
   revPipSeq_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowShipSeq (bool theValue)
   {
   allowShipSeq_ = theValue;
d539 1
d849 5
d890 1
@


1.100
log
@Continued implementation of PIP.
@
text
@d25 1
a25 1
#include <Dated.h>
d78 1
d474 7
@


1.99
log
@Continued implementation of PIP.
@
text
@a77 1
      allowSideEffs_       (false),
a472 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowSideEffs (bool theValue)
   {
   allowSideEffs_ = theValue;
@


1.98
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d78 1
d474 7
@


1.97
log
@Continued implementation of post-implosion pegging.
@
text
@d64 1
a64 1
      perfPIPegging_       (defPerfPIPegging       ()),
a76 1
      allowPIP_            (false),
d378 1
a378 1
void WitGlobalComp::setPerfPIPegging (bool theValue)
d380 1
a380 5
   if (theValue)
      if (not allowPIP_)
         myMsgFac () ("pipNYISmsg");

   perfPIPegging_ = prepBool (theValue, preprocAlt ());
a469 7
void WitGlobalComp::setAllowPIP (bool theValue)
   {
   allowPIP_ = theValue;
   }

//------------------------------------------------------------------------------

d528 1
a528 1
      perfPIPegging     (),
d820 3
a822 3
        "perfPIPegging",
         perfPIPegging (),
      defPerfPIPegging ());
d874 1
a874 1
   perfPIPegging_       = theGlobalComp->perfPIPegging       ();
@


1.96
log
@Contined implementation of post-implosion pegging.
@
text
@d78 1
d478 7
@


1.95
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d384 1
a384 1
   perfPIPegging_ = prepBool (theValue, postprocAlt ());
@


1.94
log
@Continued implementation of post-implosion pegging.
@
text
@a367 4
   if (theValue)
      if (perfPIPegging_)
         myMsgFac () ("bothPeggingSmsg");

a382 4

   if (theValue)
      if (perfPegging_)
         myMsgFac () ("bothPeggingSmsg");
@


1.93
log
@Began implementation of post-implosion pegging.
@
text
@d64 1
a64 1
      piPegging_           (defPiPegging           ()),
d368 4
d382 1
a382 1
void WitGlobalComp::setPiPegging (bool theValue)
d388 5
a392 1
   piPegging_ = prepBool (theValue, postprocAlt ());
d540 1
a540 1
      piPegging         (),
d832 3
a834 3
        "piPegging",
         piPegging (),
      defPiPegging ());
d886 1
a886 1
   piPegging_           = theGlobalComp->piPegging           ();
@


1.92
log
@Continued implementation of opt with COIN.
@
text
@d64 1
d77 1
d378 11
d474 7
d532 1
d824 5
d878 1
@


1.91
log
@Continued implementation of opt with COIN.
@
text
@a75 1
      useCoin_             (false),
a456 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setUseCoin (bool theValue)
   {
   useCoin_ = theValue;
@


1.90
log
@Continued implementation of proportionate routing.
@
text
@d76 1
d458 7
@


1.89
log
@Continued implementation of proportionate routing.
@
text
@a75 1
      allowPR_             (false),
a456 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowPR (bool theValue)
   {
   allowPR_ = theValue;
@


1.88
log
@Continued implementation of proportionate routing.
@
text
@d510 1
a510 2
      penExec           (),
      userHeurStart     ());
@


1.87
log
@Continued implementation of proportionate routing.
@
text
@a66 1
      propRouting_         (defPropRouting         ()),
a402 7

void WitGlobalComp::setPropRouting (bool theValue)
   {
   propRouting_ = prepBool (theValue, postprocAlt ());
   }

//------------------------------------------------------------------------------
a824 5

   myDataWriter ()->writeBool (
        "propRouting",
         propRouting (),
      defPropRouting ());
a860 1
   propRouting_         = theGlobalComp->propRouting         ();
@


1.86
log
@Began implementation of Proportionate Routing.
@
text
@d67 1
d404 7
d518 2
a519 1
      penExec           ());
d833 5
d874 1
@


1.85
log
@Internal changes.
@
text
@d76 1
d458 7
@


1.84
log
@Internal changes.
@
text
@d99 1
a99 1
   while (!  criticalList_.isEmpty ())
d227 1
a227 1
   if (! theValue)
d323 1
a323 1
      witAssert (! stockReallocation_);
d333 1
a333 1
      witAssert (! stockRealloc_);
d563 1
a563 1
   return (multiExec_ || localMultiExec_);
@


1.83
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d68 3
a70 3
      readDataMsgs_        (witFALSE),
      printEqAlloc_        (witFALSE),
      reportIncViol_       (witFALSE),
d72 1
a72 1
      twmeByDemand_        (witFALSE),
d78 1
a78 1
      lotSizesExist_       (witFALSE),
d80 1
a80 1
      feasible_            (witFALSE),
d145 1
a145 1
void WitGlobalComp::setIndependentOffsets (WitBoolean theValue)
d149 1
a149 1
   independentOffsets_ = prepBoolean (theValue, preprocAlt ());
d154 1
a154 1
void WitGlobalComp::setExecEmptyBom (WitBoolean theValue)
d156 1
a156 1
   execEmptyBom_ = prepBoolean (theValue, preprocAlt ());
d168 1
a168 1
void WitGlobalComp::setRoundReqVols (WitBoolean theValue)
d170 1
a170 1
   roundReqVols_ = prepBoolean (theValue, postprocAlt ());
d182 1
a182 1
void WitGlobalComp::setComputeCriticalList (WitBoolean theValue)
d184 1
a184 1
   computeCriticalList_ = prepBoolean (theValue, postprocAlt ());
d189 1
a189 1
void WitGlobalComp::setWit34Compatible (WitBoolean theValue)
d206 1
a206 1
void WitGlobalComp::setUseFocusHorizons (WitBoolean theValue)
d210 1
a210 1
   useFocusHorizons_ = prepBoolean (theValue, noOpAlt ());
d215 1
a215 1
void WitGlobalComp::setLocalBuildAhead (WitBoolean theValue)
d217 1
a217 1
   localBuildAhead_ = prepBoolean (theValue, postprocAlt ());
d222 1
a222 1
void WitGlobalComp::setMultiExec (WitBoolean theValue)
d225 1
a225 1
      setLocalMultiExec  (witFALSE);
d228 1
a228 1
      setTwoWayMultiExec (witFALSE);
d230 1
a230 1
   multiExec_ = prepBoolean (theValue, preprocAlt ());
d235 1
a235 1
void WitGlobalComp::setTwoWayMultiExec (WitBoolean theValue)
d238 1
a238 1
      setMultiExec (witTRUE);
d240 1
a240 1
   twoWayMultiExec_ = prepBoolean (theValue, preprocAlt ());
d245 1
a245 1
void WitGlobalComp::setLocalMultiExec (WitBoolean theValue)
d248 1
a248 1
      setMultiExec (witFALSE);
d250 1
a250 1
   localMultiExec_ = prepBoolean (theValue, postprocAlt ());
d262 1
a262 1
void WitGlobalComp::setForcedMultiEq (WitBoolean theValue)
d264 1
a264 1
   forcedMultiEq_ = prepBoolean (theValue, postprocAlt ());
d269 1
a269 1
void WitGlobalComp::setAutoPriority (WitBoolean theValue)
d271 1
a271 1
   autoPriority_ = prepBoolean (theValue, postprocAlt ());
d276 1
a276 1
void WitGlobalComp::setSkipFailures (WitBoolean theValue)
d278 1
a278 1
   skipFailures_ = prepBoolean (theValue, postprocAlt ());
d283 1
a283 1
void WitGlobalComp::setMultiRoute (WitBoolean theValue)
d285 1
a285 1
   multiRoute_ = prepBoolean (theValue, preprocAlt ());
d290 1
a290 1
void WitGlobalComp::setTruncOffsets (WitBoolean theValue)
d292 1
a292 1
   truncOffsets_ = prepBoolean (theValue, preprocAlt ());
d313 1
a313 1
void WitGlobalComp::setPenExec (WitBoolean theValue)
d315 1
a315 1
   penExec_ = prepBoolean (theValue, postprocAlt ());
d320 1
a320 1
void WitGlobalComp::setStockRealloc (WitBoolean theValue)
d325 1
a325 1
   stockRealloc_ = prepBoolean (theValue, postprocAlt ());
d330 1
a330 1
void WitGlobalComp::setStockReallocation (WitBoolean theValue)
d335 1
a335 1
   stockReallocation_ = prepBoolean (theValue, postprocAlt ());
d340 1
a340 1
void WitGlobalComp::setSrSelSplit (WitBoolean theValue)
d342 1
a342 1
   srSelSplit_ = prepBoolean (theValue, postprocAlt ());
d347 1
a347 1
void WitGlobalComp::setRespectStockSLBs (WitBoolean theValue)
d349 1
a349 1
   respectStockSLBs_ = prepBoolean (theValue, postprocAlt ());
d354 1
a354 1
void WitGlobalComp::setPrefHighStockSLBs (WitBoolean theValue)
d356 1
a356 1
   prefHighStockSLBs_ = prepBoolean (theValue, postprocAlt ());
d361 1
a361 1
void WitGlobalComp::setPerfPegging (WitBoolean theValue)
d366 1
a366 1
   perfPegging_ = prepBoolean (theValue, postprocAlt ());
d376 1
a376 1
void WitGlobalComp::setSelSplit (WitBoolean theValue)
d379 1
a379 1
      nonMrSelSplit_ = witFALSE;
d381 1
a381 1
   selSplit_ = prepBoolean (theValue, postprocAlt ());
d386 1
a386 1
void WitGlobalComp::setNonMrSelSplit (WitBoolean theValue)
d389 1
a389 1
      selSplit_ = witFALSE;
d391 1
a391 1
   nonMrSelSplit_ = prepBoolean (theValue, postprocAlt ());
d396 1
a396 1
void WitGlobalComp::setUserHeurStart (WitBoolean theValue)
d398 1
a398 1
   userHeurStart_ = prepBoolean (theValue, postprocAlt ());
d405 1
a405 1
void WitGlobalComp::setReadDataMsgs (WitBoolean theValue)
d412 1
a412 1
void WitGlobalComp::setPrintEqAlloc (WitBoolean theValue)
d419 1
a419 1
void WitGlobalComp::setReportIncViol (WitBoolean theValue)
d433 1
a433 1
void WitGlobalComp::setTwmeByDemand (WitBoolean theValue)
d470 1
a470 1
WitBoolean WitGlobalComp::inserted ()
d521 1
a521 1
   lotSizesExist_ = witFALSE;
d556 1
a556 1
   feasible_ = witFALSE;
d561 1
a561 1
WitBoolean WitGlobalComp::multiExecNeeded ()
d568 1
a568 1
WitBoolean WitGlobalComp::tempParIsSet (int index)
d577 1
a577 1
WitBoolean WitGlobalComp::tempParAsBoolean (int index)
d582 1
a582 1
      return witTRUE;
d585 1
a585 1
      return witFALSE;
d587 1
a587 1
   myMsgFac () ("invalidBooleanTempParSmsg", index, tempPar (index));
d589 1
a589 1
   return witFALSE;
d667 1
a667 1
   myDataWriter ()->writeBoolean (
d672 1
a672 1
   myDataWriter ()->writeBoolean (
d682 1
a682 1
   myDataWriter ()->writeBoolean (
d692 1
a692 1
   myDataWriter ()->writeBoolean (
d697 1
a697 1
   myDataWriter ()->writeBoolean (
d702 1
a702 1
   myDataWriter ()->writeBoolean (
d707 1
a707 1
   myDataWriter ()->writeBoolean (
d712 1
a712 1
   myDataWriter ()->writeBoolean (
d717 1
a717 1
   myDataWriter ()->writeBoolean (
d722 1
a722 1
   myDataWriter ()->writeBoolean (
d732 1
a732 1
   myDataWriter ()->writeBoolean (
d737 1
a737 1
   myDataWriter ()->writeBoolean (
d742 1
a742 1
   myDataWriter ()->writeBoolean (
d747 1
a747 1
   myDataWriter ()->writeBoolean (
d752 1
a752 1
   myDataWriter ()->writeBoolean (
d767 1
a767 1
   myDataWriter ()->writeBoolean (
d772 1
a772 1
   myDataWriter ()->writeBoolean (
d777 1
a777 1
   myDataWriter ()->writeBoolean (
d782 1
a782 1
   myDataWriter ()->writeBoolean (
d787 1
a787 1
   myDataWriter ()->writeBoolean (
d792 1
a792 1
   myDataWriter ()->writeBoolean (
d797 1
a797 1
   myDataWriter ()->writeBoolean (
d802 1
a802 1
   myDataWriter ()->writeBoolean (
d807 1
a807 1
   myDataWriter ()->writeBoolean (
d812 1
a812 1
   myDataWriter ()->writeBoolean (
@


1.82
log
@Continued implementation of heuristic implosion from an initial solution.
Fixed a bug in build-ahead by demand.
Removed RWClient.C.
@
text
@d66 1
a66 1
      heurInitSoln_        (defHeurInitSoln        ()),
d396 1
a396 1
void WitGlobalComp::setHeurInitSoln (WitBoolean theValue)
d398 1
a398 1
   heurInitSoln_ = prepBoolean (theValue, postprocAlt ());
d498 1
a498 1
      heurInitSoln      (),
d813 3
a815 3
        "heurInitSoln",
         heurInitSoln (),
      defHeurInitSoln ());
d851 1
a851 1
   heurInitSoln_        = theGlobalComp->heurInitSoln        ();
@


1.81
log
@Continued implementation of heuristic initial solution.
@
text
@a72 1
      allowHIS_            (witFALSE),
a397 2
   stronglyAssert (allowHIS_);

a435 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowHIS (WitBoolean theValue)
   {
   allowHIS_ = theValue;
@


1.80
log
@Removed implementation of single-source by the old algorithm.
@
text
@d66 1
a66 1
      initHeurSoln_        (defInitHeurSoln        ()),
d73 1
a73 1
      allowIHS_            (witFALSE),
d397 1
a397 1
void WitGlobalComp::setInitHeurSoln (WitBoolean theValue)
d399 1
a399 1
   stronglyAssert (allowIHS_);
d401 1
a401 1
   initHeurSoln_ = prepBoolean (theValue, postprocAlt ());
d443 1
a443 1
void WitGlobalComp::setAllowIHS (WitBoolean theValue)
d445 1
a445 1
   allowIHS_ = theValue;
d508 1
a508 1
      initHeurSoln      (),
d823 3
a825 3
        "initHeurSoln",
         initHeurSoln (),
      defInitHeurSoln ());
d861 1
a861 1
   initHeurSoln_        = theGlobalComp->initHeurSoln        ();
@


1.79
log
@Cut-over single-source to use the new algorithm.
@
text
@a73 1
      sglSrcNewAlg_        (witTRUE),
a445 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setSglSrcNewAlg (WitBoolean theValue)
   {
   sglSrcNewAlg_ = theValue;
@


1.78
log
@Continued implementation of single-source with the new algorithm.
@
text
@d74 1
a74 1
      sglSrcNewAlg_        (witFALSE),
@


1.77
log
@Continued implementation of heuristic implosion from an initial solution.
Added some debugging code to Single-Source.
@
text
@d74 1
d447 7
@


1.76
log
@Began implementation of heuristic implosion from an initial solution.
@
text
@d66 1
a66 1
      heurInitSoln_        (defHeurInitSoln        ()),
d73 1
a73 1
      allowHIS_            (witFALSE),
d397 1
a397 1
void WitGlobalComp::setHeurInitSoln (WitBoolean theValue)
d399 1
a399 1
   stronglyAssert (allowHIS_);
d401 1
a401 1
   heurInitSoln_ = prepBoolean (theValue, postprocAlt ());
d443 1
a443 1
void WitGlobalComp::setAllowHIS (WitBoolean theValue)
d445 1
a445 1
   allowHIS_ = theValue;
d508 1
a508 1
      heurInitSoln      (),
d823 3
a825 3
        "heurInitSoln",
         heurInitSoln (),
      defHeurInitSoln ());
d861 1
a861 1
   heurInitSoln_        = theGlobalComp->heurInitSoln        ();
@


1.75
log
@Continued implementation of 2-level lot sizes.
@
text
@d66 1
d73 1
d396 9
d443 7
d508 1
d821 5
d861 1
@


1.74
log
@Continued implementation of 2-level lot sizes.
@
text
@a74 1
      allowTlls_           (witFALSE),
a448 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowTlls (WitBoolean theValue)
   {
   allowTlls_ = theValue;
@


1.73
log
@Continued implementation of two-level lot sizes.
@
text
@a566 39
int WitGlobalComp::lotSizeGridPoint (
      double     minQty,
      double     incQty,
      double     qty,
      WitBoolean upwards,
      WitBoolean useTol)
   {
   double adjustment;
   double doubleGP;
   int    intGP;

   witAssert (qty >= NET_TOL);

   adjustment =
      useTol?
         (upwards?
            - lotSizeTol_:
            + lotSizeTol_):
         0.0;

   doubleGP = (qty - minQty) / incQty + adjustment;

   intGP    =
      (int)
         (upwards?
            ceil  (doubleGP):
            floor (doubleGP));

   if (intGP < 0)
      intGP =
         upwards?
             0:
            -1;

   return intGP;
   }

//------------------------------------------------------------------------------

@


1.72
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d75 1
d450 7
@


1.71
log
@Continued implementation of single-source.
@
text
@d570 2
d588 4
a591 1
      intGP = 0;
@


1.70
log
@Continued implementation of single-source.
@
text
@a74 1
      allowSglSrc_         (witFALSE),
a448 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowSglSrc (WitBoolean theValue)
   {
   allowSglSrc_ = theValue;
@


1.69
log
@Continued implementation of single-source.
@
text
@d23 1
d535 14
@


1.68
log
@Continued implementation of single-source.
@
text
@d19 1
d513 14
@


1.67
log
@Continued implementation of single-source.
@
text
@d19 1
d512 14
@


1.66
log
@Continued implementation of single-source.
@
text
@a19 1
#include <Post.h>
a487 27
void WitGlobalComp::compLotSizesExist ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if ((theOpn->minLotSize ()[thePer] > 0.0) ||
             (theOpn->incLotSize ()[thePer] > 0.0)   )
            {
            lotSizesExist_ = witTRUE;

            return;
            }

   lotSizesExist_ = witFALSE;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::resetLotSizesExist ()
   {
   lotSizesExist_ = witFALSE;
   }

//------------------------------------------------------------------------------

a605 14
   }

//------------------------------------------------------------------------------

void WitGlobalComp::compFeasible ()
   {
   feasible_ = (myPostprocessor ()->maxViolation () <= FEAS_TOL);
   }

//------------------------------------------------------------------------------

void WitGlobalComp::unpostprocess ()
   {
   feasible_ = witFALSE;
@


1.65
log
@Continued implementation of single-source.
@
text
@d489 1
a489 1
void WitGlobalComp::importPostprocResults ()
d491 21
a511 1
   feasible_ = myPostprocessor ()->feasible ();
d634 7
@


1.64
log
@Continued implementation of single-source.
@
text
@d20 1
d489 7
d614 7
@


1.63
log
@Continued implementation of single source.
@
text
@d72 1
a72 1
      sglSrc_              (witFALSE),
d451 1
a451 1
void WitGlobalComp::setSglSrc (WitBoolean theValue)
d453 1
a453 1
   sglSrc_ = theValue;
@


1.62
log
@Preliminary work on single source.
@
text
@d72 1
d447 7
@


1.61
log
@Continued preliminary work on single source.
@
text
@d125 1
a125 1
   title_ = prepString (theValue, noOpAlt ());
d454 1
a454 1
   tempPar_ (index) = theValue;
a804 1
   title_               = theGlobalComp->title               ();
a805 2
   setWit34Compatible    (theGlobalComp->wit34Compatible     ());
   setUseFocusHorizons   (theGlobalComp->useFocusHorizons    ());
a823 1
   setPerfPegging        (theGlobalComp->perfPegging         ());
d828 6
@


1.60
log
@Continued implementation of object iteration.
@
text
@d17 1
@


1.59
log
@Continued implementation of object iteration.
@
text
@a70 1
      allowObjItr_         (witFALSE),
a444 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowObjItr (WitBoolean theValue)
   {
   allowObjItr_ = theValue;
@


1.58
log
@Began implementation of object iteration.
@
text
@d71 1
d125 1
a125 1
   title_ = prepString (theValue, noopAlt ());
d159 1
a159 1
   hashTableSize_ = prepRangedInt (theValue, noopAlt (), 0, -1);
d173 1
a173 1
   outputPrecision_ = prepRangedInt (theValue, noopAlt (), 0, -1);
d206 1
a206 1
   useFocusHorizons_ = prepBoolean (theValue, noopAlt ());
d446 7
@


1.57
log
@Continued implementation of sel-split for pen-exec.
@
text
@d16 1
d22 1
@


1.56
log
@Continued implementation of sel-split for pen-exec.
@
text
@d68 1
a68 1
      splitItrUB_          (100),
@


1.55
log
@Continued implementation of sel-split for pen-exec.
@
text
@a68 1
      allowSSPE_           (witFALSE),
a442 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowSSPE (WitBoolean theValue)
   {
   allowSSPE_ = theValue;
@


1.54
log
@Added allowSSPE dev param.
Switched pen-exec to single-shortage logic.
Made pen-exec exploit sparse penalties.
@
text
@d624 2
a625 5
   if (i < 1)
      myMsgFac () ("internalErrorFmsg", "WitGlobalComp::checkTempParIndex");

   if (i > nTempPars ())
      myMsgFac () ("internalErrorFmsg", "WitGlobalComp::checkTempParIndex");
@


1.53
log
@Finished implementation of selection splitting for multi-route.
@
text
@d69 1
d444 7
@


1.52
log
@Initial implementation of selection splitting for multi-route.
@
text
@a68 1
      allowNewSS_          (witFALSE),
a370 2
   witAssert (allowNewSS_);

a380 2
   witAssert (allowNewSS_);

a442 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowNewSS (WitBoolean theValue)
   {
   allowNewSS_ = theValue;
@


1.51
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d58 2
d69 1
d369 24
d452 7
d503 2
d793 10
d840 2
@


1.50
log
@Began implementation of selection splitting for stock reallocation.
@
text
@a66 1
      allowSRSS_           (witFALSE),
a332 3
   if (! allowSRSS_)
      myMsgFac () ("srssNotAllowedSmsg");

a420 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowSRSS (WitBoolean theValue)
   {
   allowSRSS_ = theValue;
@


1.49
log
@Added a severe error for setting both stockRealloc and stockReallocation to
TRUE.
@
text
@d54 1
d67 1
d332 10
d429 7
d480 1
d750 5
d801 1
@


1.48
log
@Changed selStockRe attribute to stockReallocation (fullSR, internally).
@
text
@d312 3
a315 3

   if (stockRealloc_)
      stockReallocation_ = witFALSE;
d322 3
a325 3

   if (stockReallocation_)
      stockRealloc_ = witFALSE;
@


1.47
log
@Replaced uncondStockRe attribute with the old stockRealloc attribute.
@
text
@d52 2
a53 2
      pureUncondSR_        (defPureUncondSR        ()),
      selStockRe_          (defSelStockRe          ()),
d310 1
a310 1
void WitGlobalComp::setPureUncondSR (WitBoolean theValue)
d312 1
a312 1
   pureUncondSR_ = prepBoolean (theValue, postprocAlt ());
d314 2
a315 2
   if (pureUncondSR_)
      selStockRe_ = witFALSE;
d320 1
a320 1
void WitGlobalComp::setSelStockRe (WitBoolean theValue)
d322 1
a322 1
   selStockRe_ = prepBoolean (theValue, postprocAlt ());
d324 2
a325 2
   if (selStockRe_)
      pureUncondSR_ = witFALSE;
d460 1
a460 1
      selStockRe        (),
d721 2
a722 2
         pureUncondSR (),
      defPureUncondSR ());
d725 3
a727 3
        "selStockRe",
         selStockRe (),
      defSelStockRe ());
d774 2
a775 2
   pureUncondSR_        = theGlobalComp->pureUncondSR        ();
   selStockRe_          = theGlobalComp->selStockRe          ();
@


1.46
log
@Renamed mandatory stock reallocation to unconditional stock reallocation.
@
text
@d52 1
a52 1
      uncondStockRe_       (defUncondStockRe       ()),
d310 1
a310 1
void WitGlobalComp::setUncondStockRe (WitBoolean theValue)
d312 1
a312 1
   uncondStockRe_ = prepBoolean (theValue, postprocAlt ());
d314 1
a314 1
   if (uncondStockRe_)
d325 1
a325 1
      uncondStockRe_ = witFALSE;
a459 1
      uncondStockRe     (),
d720 3
a722 3
        "uncondStockRe",
         uncondStockRe (),
      defUncondStockRe ());
d774 1
a774 1
   uncondStockRe_       = theGlobalComp->uncondStockRe       ();
@


1.45
log
@Removed allowSSR development control parameter.
@
text
@d52 1
a52 1
      mandStockRe_         (defMandStockRe         ()),
d310 1
a310 1
void WitGlobalComp::setMandStockRe (WitBoolean theValue)
d312 1
a312 1
   mandStockRe_ = prepBoolean (theValue, postprocAlt ());
d314 1
a314 1
   if (mandStockRe_)
d325 1
a325 1
      mandStockRe_ = witFALSE;
d460 1
a460 1
      mandStockRe       (),
d721 3
a723 3
        "mandStockRe",
         mandStockRe (),
      defMandStockRe ());
d775 1
a775 1
   mandStockRe_         = theGlobalComp->mandStockRe         ();
@


1.44
log
@Changed attribute stockRealloc to mandStockRe.
@
text
@a65 1
      allowSSR_            (witFALSE),
a321 3
   if (! allowSSR_)
      myMsgFac () ("ssrWoAllowSsrSmsg");

a412 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowSSR (WitBoolean theValue)
   {
   allowSSR_ = theValue;
@


1.43
log
@Continued implementation of selective stock reallocation.
@
text
@d52 1
a52 1
      stockRealloc_        (defStockRealloc        ()),
d311 1
a311 1
void WitGlobalComp::setStockRealloc (WitBoolean theValue)
d313 1
a313 1
   stockRealloc_ = prepBoolean (theValue, postprocAlt ());
d315 2
a316 3
   if (stockRealloc_)
      if (selStockRe_)
         selStockRe_ = witFALSE;
d329 1
a329 2
      if (stockRealloc_)
         stockRealloc_ = witFALSE;
d471 1
a471 1
      stockRealloc      (),
d732 3
a734 3
        "stockRealloc",
         stockRealloc (),
      defStockRealloc ());
d786 1
a786 1
   stockRealloc_        = theGlobalComp->stockRealloc        ();
@


1.42
log
@Continued implementation of selective stock reallocation.
@
text
@d53 1
a53 1
      selStockRealloc_     (defSelStockRealloc     ()),
d316 2
a317 2
      if (selStockRealloc_)
         selStockRealloc_ = witFALSE;
d322 1
a322 1
void WitGlobalComp::setSelStockRealloc (WitBoolean theValue)
d327 1
a327 1
   selStockRealloc_ = prepBoolean (theValue, postprocAlt ());
d329 1
a329 1
   if (selStockRealloc_)
d474 1
a474 1
      selStockRealloc   (),
d739 3
a741 3
        "selStockRealloc",
         selStockRealloc (),
      defSelStockRealloc ());
d789 1
a789 1
   selStockRealloc_     = theGlobalComp->selStockRealloc     ();
@


1.41
log
@Added selStockRealloc attribute.
@
text
@d324 3
@


1.40
log
@Began implemention of constrained stock reallocation.
@
text
@d53 1
d314 15
d459 1
a459 1
   myMsgFac () ("globalCompDdMsg",
d467 3
a469 1
      penExec           (),
d471 1
d736 5
d786 1
@


1.39
log
@Minor change.
@
text
@d65 1
d400 7
@


1.38
log
@Minor chnages.
@
text
@d55 1
a55 1
      peggingNeeded_       (defPeggingNeeded       ()),
d330 1
a330 1
void WitGlobalComp::setPeggingNeeded (WitBoolean theValue)
d332 1
a332 1
   if (peggingNeeded_ == theValue)
d335 1
a335 1
   peggingNeeded_ = prepBoolean (theValue, postprocAlt ());
d447 1
a447 1
      peggingNeeded     (),
d719 3
a721 3
        "peggingNeeded",
         peggingNeeded (),
      defPeggingNeeded ());
d756 1
a756 1
   setPeggingNeeded      (theGlobalComp->peggingNeeded       ());
@


1.37
log
@Continued implementation of pegging.
@
text
@d318 1
a318 1
   respectStockSLBs_ = theValue;
d325 1
a325 1
   prefHighStockSLBs_ = theValue;
d335 1
a335 1
   peggingNeeded_ = theValue;
@


1.36
log
@Continued implementation of pegging.
@
text
@d55 1
a55 1
      pegging_             (defPegging             ()),
d330 1
a330 1
void WitGlobalComp::setPegging (WitBoolean theValue)
d332 1
a332 1
   if (pegging_ == theValue)
d335 1
a335 1
   pegging_ = theValue;
d447 1
a447 1
      pegging           (),
d719 3
a721 3
        "pegging",
         pegging (),
      defPegging ());
d756 1
a756 1
   setPegging            (theGlobalComp->pegging             ());
@


1.35
log
@Continued implementation of pegging.
@
text
@d338 1
a338 1
      myProblem ()->myHeurAllMgr ()->startUpPegging ();
@


1.34
log
@Continued implementation of pegging.
@
text
@d55 1
a55 1
      perfPegging_         (defPerfPegging         ()),
d330 1
a330 1
void WitGlobalComp::setPerfPegging (WitBoolean theValue)
d332 1
a332 1
   if (perfPegging_ == theValue)
d335 1
a335 1
   perfPegging_ = theValue;
d447 1
a447 1
      perfPegging       (),
d719 3
a721 3
        "perfPegging",
         perfPegging (),
      defPerfPegging ());
d756 1
a756 1
   setPerfPegging        (theGlobalComp->perfPegging         ());
@


1.33
log
@Initial implementation of pegging.
@
text
@d55 1
a55 1
      doPegging_           (defDoPegging           ()),
a64 1
      allowPegging_        (witFALSE),
d330 1
a330 1
void WitGlobalComp::setDoPegging (WitBoolean theValue)
d332 1
a332 4
   if (! allowPegging_)
      myMsgFac () ("noPeggingAllowedSmsg");

   if (doPegging_ == theValue)
d335 1
a335 1
   doPegging_ = theValue;
a402 7
void WitGlobalComp::setAllowPegging (WitBoolean theValue)
   {
   allowPegging_ = theValue;
   }

//------------------------------------------------------------------------------

d447 1
a447 1
      doPegging         (),
d719 3
a721 3
        "doPegging",
         doPegging (),
      defDoPegging ());
d756 1
a756 5

   if (allowPegging ())
      setDoPegging       (theGlobalComp->doPegging           ());
   else if (theGlobalComp->doPegging ())
      myMsgFac () ("noPeggingAllowedSmsg");
@


1.32
log
@Implemented an iteration upper bound for selection splitting.
@
text
@d18 1
d55 1
d65 1
d330 18
d407 7
d458 1
d728 5
d767 5
@


1.31
log
@More templates.
@
text
@d62 1
d375 7
@


1.30
log
@Continued development of selection splitting for multi-exec.
@
text
@d62 1
a62 1
      tempPar_             (* new WitPtrVec (WitString)),
@


1.29
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@a59 1
      meSelSplitOK_        (witFALSE),
a359 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setMeSelSplitOK (WitBoolean theValue)
   {
   meSelSplitOK_ = theValue;
@


1.28
log
@Removed allowSS development parameter.
@
text
@d60 1
d361 7
@


1.27
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a59 1
      allowSS_             (witFALSE),
a359 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setAllowSS (WitBoolean theValue)
   {
   allowSS_ = theValue;
@


1.26
log
@Implemented timing wrap-around adjustment.
@
text
@d60 1
a60 1
      selSplit_            (witFALSE),
a62 1
      heurTimingDelta_     (0),
d365 1
a365 1
void WitGlobalComp::setSelSplit (WitBoolean theValue)
d367 1
a367 1
   selSplit_ = theValue;
a381 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setHeurTimingDelta (int theValue)
   {
   heurTimingDelta_ = theValue;
@


1.25
log
@Implemented Ticker class.
Disallowed sel-split w multi-exec.
@
text
@d63 1
d383 7
@


1.24
log
@Implemented incAlloc count.
@
text
@a58 1
      incCountDelta_       (0),
a353 7
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setIncCountDelta (int theValue)
   {
   incCountDelta_ = theValue;
@


1.23
log
@Implemented tick printing for incHeurAlloc.
@
text
@d59 1
a59 1
      incAllocTicks_       (witFALSE),
d359 1
a359 1
void WitGlobalComp::setIncAllocTicks (WitBoolean theValue)
d361 1
a361 1
   incAllocTicks_ = theValue;
@


1.22
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@d59 1
d355 7
@


1.21
log
@Minor change.
@
text
@d453 1
a453 1
   int    theGP;
d464 1
a464 1
   theGP =
d470 2
a471 2
   if (theGP < 0)
      theGP = 0;
d473 1
a473 1
   return theGP;
@


1.20
log
@Continuing development of selection splitting.
@
text
@d61 2
a62 2
      splitTol_            (1.0E-4),
      splitRes_            (1.0E-4),
@


1.19
log
@Re-worked the controls for selection splitting.
@
text
@d61 2
a62 1
      splitRes_            (1.0),
d368 7
@


1.18
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d60 2
a61 1
      allowSS_             (witFALSE),
d364 1
a364 1
void WitGlobalComp::setAllowSS (WitBoolean theValue)
d366 8
a373 1
   allowSS_ = theValue;
@


1.17
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d60 1
a60 1
      selSplit_            (witFALSE),
d363 1
a363 1
void WitGlobalComp::setSelSplit (WitBoolean theValue)
d365 1
a365 1
   selSplit_ = theValue;
@


1.16
log
@Implemented and used class SelMgr.
@
text
@d59 1
a59 1
      twmeIsAsap_          (witTRUE),
d356 1
a356 1
void WitGlobalComp::setTwmeIsAsap (WitBoolean theValue)
d358 1
a358 1
   twmeIsAsap_ = theValue;
@


1.15
log
@Coarse selection splitting.
@
text
@d84 2
a85 1
   criticalList_.clearContents ();
a719 7

//------------------------------------------------------------------------------

implementClearContents (WitDatedPart)
   //
   // See RWClient.h.

@


1.14
log
@Some minor changes.
@
text
@d392 7
@


1.13
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d20 1
d61 1
a61 1
      tempPar_             (1),
d85 20
d373 1
a373 1
   tempPar_[index] = theValue;
d510 5
d516 3
@


1.12
log
@Implemented respectStockSLBs and prefHighStockSLBs global attributes.
@
text
@d59 1
d341 7
d364 1
a364 1
void WitGlobalComp::copyInto (WitCompMgr * theCompMgr)
@


1.11
log
@

Revised stand-alone FSS capabilties in development mode.
Modified some stock soft-lower bound controls.
Fixed bug: BOP entry productRate attribute could not be read.
@
text
@d51 2
a58 1
      respectStockSLBs_    (witFALSE),
d288 14
a339 7
void WitGlobalComp::setRespectStockSLBs (WitBoolean theValue)
   {
   respectStockSLBs_ = theValue;
   }

//------------------------------------------------------------------------------

d366 14
a379 12
      multiExecNeeded (),
      twoWayMultiExec (),
      equitability    (),
      forcedMultiEq   (),
      autoPriority    (),
      skipFailures    (),
      multiRoute      (),
      penExec         (),
      stockRealloc    (),
      truncOffsets    (),
      lotSizeTol      (),
      expCutoff       ());
d628 10
d670 2
@


1.10
log
@Fixed a minor bug in witSetStockRealloc.
@
text
@d57 1
a57 1
      enforceStSLBs_       (witFALSE),
d325 1
a325 1
void WitGlobalComp::setEnforceStSLBs (WitBoolean theValue)
d327 1
a327 1
   enforceStSLBs_ = theValue;
@


1.9
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d283 1
a283 1
   stockRealloc_ = theValue;
@


1.8
log
@Finished implementing stock reallocation.
@
text
@d57 1
d321 7
@


1.7
log
@Made HeurAllPerf::findMaxQty test desQty when it's < minQty.
   This fixed a "commit failed" error, by making the heuristic function
   properly in cases in which commit fails at a lower desQty than one in which
   it succeeds.
Moved top-level net into commitMaxQtySel.
@
text
@d50 1
a56 3
      stockRealloc_        (witFALSE),
      emulatedSF_          (witFALSE),
      trackInterval_       (witFALSE),
d279 7
a323 21
void WitGlobalComp::setStockRealloc (WitBoolean theValue)
   {
   stockRealloc_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setEmulatedSF (WitBoolean theValue)
   {
   emulatedSF_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setTrackInterval (WitBoolean theValue)
   {
   trackInterval_ = theValue;
   }

//------------------------------------------------------------------------------

d358 1
d605 5
d641 1
@


1.6
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d57 2
d322 14
@


1.5
log
@Minor update to stock re-allocation.
@
text
@d56 1
a56 1
      stockReAlloc_        (witFALSE),
d61 2
a62 1
      feasible_            (witFALSE)
d98 3
a100 1
   nPeriods_ = prepRangedInt (theValue, preprocAlt (), 1, -1);
d317 1
a317 1
void WitGlobalComp::setStockReAlloc (WitBoolean theValue)
d319 1
a319 1
   stockReAlloc_ = theValue;
d635 2
@


1.4
log
@Fixed bug:
   Stock re-allocation caused selection trace-back to malfunction.
@
text
@d56 1
a56 2
      usingNetSupp_        (witTRUE),
      usingSurplus_        (witFALSE),
d314 1
a314 1
void WitGlobalComp::setUsingNetSupp (WitBoolean theValue)
d316 1
a316 16
   if (DEBUG_MODE)
      if (theValue)
         witAssert (! usingSurplus ());

   usingNetSupp_ = theValue;
   }

//------------------------------------------------------------------------------

void WitGlobalComp::setUsingSurplus (WitBoolean theValue)
   {
   if (DEBUG_MODE)
      if (theValue)
         witAssert (! usingNetSupp ());

   usingSurplus_ = theValue;
@


1.3
log
@Initial implementation of stock re-allocation.
@
text
@d64 5
d70 2
a71 3
      //
      // Normally 1.
      // Set to a larger number temporarily only.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d56 2
d307 22
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

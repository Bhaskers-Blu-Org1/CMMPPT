head	1.148;
access;
symbols;
locks; strict;
comment	@ * @;


1.148
date	2006.03.13.17.02.23;	author rjw;	state dead;
branches;
next	1.147;

1.147
date	2006.03.11.00.03.45;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2006.03.10.23.23.30;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2006.03.10.17.14.19;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2006.03.10.16.19.58;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2006.03.09.23.59.36;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2006.03.09.23.07.06;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2006.03.09.21.51.59;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2006.03.08.23.57.12;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.06.19.59.46;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2006.03.03.23.16.29;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.03.22.22.05;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2006.03.03.21.01.02;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2006.03.03.20.46.56;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2006.03.02.23.29.02;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2006.02.28.19.43.05;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2006.02.27.22.02.32;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2006.02.27.21.19.54;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2006.02.27.18.28.12;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2006.02.25.00.12.43;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2006.02.24.21.04.23;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2006.02.24.20.20.44;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2006.02.24.00.22.26;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2006.02.23.22.42.10;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2006.02.22.23.20.34;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2006.02.21.19.21.49;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2006.02.21.18.24.52;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2006.02.18.00.42.59;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2006.02.18.00.38.49;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2006.02.14.21.59.09;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2006.02.10.23.36.50;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2006.02.10.17.09.52;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2006.02.09.21.54.43;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2006.02.07.21.45.06;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2006.02.07.19.30.13;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2006.02.06.23.24.03;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2006.02.06.21.29.24;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2006.02.06.20.36.00;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2006.02.03.21.49.05;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2006.02.02.22.50.47;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2006.02.02.22.37.44;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2006.02.01.20.45.46;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2006.01.31.20.45.31;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2006.01.31.20.04.24;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2006.01.31.19.27.38;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2006.01.31.18.24.14;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2006.01.30.23.59.37;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2006.01.27.23.51.33;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2006.01.27.23.32.33;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2006.01.27.23.16.22;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2006.01.27.21.14.35;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2006.01.26.22.10.56;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2006.01.25.22.16.42;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2006.01.25.20.32.25;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2006.01.24.22.59.40;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2006.01.24.22.09.07;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2006.01.24.22.03.14;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2006.01.23.23.04.22;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2006.01.23.20.54.05;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2006.01.23.20.18.33;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2006.01.23.17.25.49;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2006.01.23.16.43.02;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2006.01.23.16.00.34;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2006.01.20.21.41.36;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2006.01.20.20.58.06;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2006.01.20.18.52.54;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2006.01.20.18.31.59;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2006.01.20.17.00.47;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2006.01.19.22.20.42;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2006.01.19.20.43.04;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2006.01.19.19.50.14;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2006.01.18.23.20.06;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2006.01.18.20.02.59;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2006.01.17.19.01.10;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2006.01.17.17.41.14;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2006.01.17.17.00.50;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2006.01.17.16.37.26;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2006.01.16.23.44.22;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2006.01.16.22.39.43;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2006.01.16.20.50.34;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2006.01.13.22.50.18;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2006.01.13.20.23.00;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2006.01.12.23.10.47;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2006.01.12.22.09.24;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2006.01.12.20.07.43;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2006.01.12.16.28.33;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.01.11.23.30.14;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.01.11.23.18.34;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2006.01.11.20.24.23;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2006.01.11.19.52.06;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.11.19.31.16;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.01.10.21.43.00;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2006.01.10.21.24.29;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.10.16.51.53;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.09.23.42.39;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.09.20.02.30;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.06.22.43.27;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.05.21.15.21;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.05.20.44.35;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.04.23.07.39;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.03.20.44.06;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.03.19.00.03;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.03.17.12.43;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.30.23.37.56;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.30.19.32.04;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.29.21.36.34;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.29.20.55.11;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.29.17.00.23;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.28.22.58.58;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.28.18.57.50;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.27.19.43.39;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.23.23.07.43;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.23.16.07.11;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.22.23.17.30;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.22.22.07.05;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.21.22.56.46;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.21.22.44.46;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.20.22.48.24;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.20.20.38.56;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.20.20.15.24;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.20.19.45.38;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.20.19.04.54;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.20.17.09.35;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.19.21.11.25;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.19.19.29.26;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.16.23.55.50;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.16.23.19.26;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.13.17.18.59;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.13.17.16.22;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.05.22.24.09;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.02.23.31.29;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.02.22.49.51;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.29.22.59.06;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.29.22.14.05;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.28.22.23.13;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.22.22.20.28;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.21.22.27.20;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.21.20.08.49;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.21.18.30.35;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.18.23.36.32;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.18.21.12.10;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.18.20.38.11;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.17.22.33.33;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.17.22.04.42;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.17.16.54.03;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.16.23.24.49;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.15.17.08.19;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.14.22.29.02;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.148
log
@GPIP
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "SRP.C"
//
// Contains the implementation of the following classes:
//
//    GpipBldr
//------------------------------------------------------------------------------

#include <SrpBuilder.h>
#include <SrpReqMgr.h>
#include <SrpReqSrc.h>
#include <SrpSeqEl.h>
#include <PipMgr.h>
#include <PipPgg.h>
#include <PipAttPgg.h>
#include <ExecPerSch.h>
#include <PairStack.h>
#include <TripStack.h>
#include <Global.h>
#include <Material.h>
#include <Opn.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Demand.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class GpipBldr.
//------------------------------------------------------------------------------

WitGpipBldr::WitGpipBldr (WitPipPgg * thePgg):

      WitProbAssoc       (thePgg->myProblem ()),

      myPgg_             (thePgg),
      myReqMgr_          (NULL),
      myExecPerSched_    (NULL),
      nUnscannedBopEnts_ (),
      prevPgdSched_      (myProblem (), false)
   {
   witAssert (myGlobalComp ()->groupPipMode ());
   }

//------------------------------------------------------------------------------

WitGpipBldr::~WitGpipBldr ()
   {
   }

//------------------------------------------------------------------------------

void WitGpipBldr::buildPegging ()
   {
   checkRestrictions ();

   setUpBuild ();

   placeShipmentReqs ();

   explodeAllReqs ();

   shutDownBuild ();

   myPgg_->consolidatePegging ();
   }

//------------------------------------------------------------------------------

void WitGpipBldr::checkRestrictions ()
   {
   WitBopEntry * theBopEnt;
   WitBomEntry * theBomEnt;
   WitPeriod     thePer;

   if (not myGlobalComp ()->feasible ())
      myMsgFac () ("gpipCaseNyiSmsg",
         "The solution is infeasible.");

   forEachBopEntry (theBopEnt, myProblem ())
      if (not theBopEnt->expAllowed ())
         myMsgFac () ("gpipCaseNyiSmsg",
            "The problem contains an unexplodeable BOP entry.");

   forEachBomEntry (theBomEnt, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theBomEnt->consRate ()[thePer] < 0.0)
            myMsgFac () ("gpipCaseNyiSmsg",
               "The problem contains an cons rate < 0.");
   }

//------------------------------------------------------------------------------

void WitGpipBldr::setUpBuild ()
   {
   WitBopEntry * theBopEnt;

   myReqMgr_       = new WitGpipReqMgr   (myProblem ());
   myExecPerSched_ = new WitExecPerSched (myProblem ());

   nUnscannedBopEnts_.allocate (myProblem (), 0);

   forEachBopEntry (theBopEnt, myProblem ())
      nUnscannedBopEnts_ (theBopEnt->myOperation ()) ++;
   }

//------------------------------------------------------------------------------

void WitGpipBldr::shutDownBuild ()
   {
   delete myExecPerSched_;
   delete myReqMgr_;

   myExecPerSched_ = NULL;
   myReqMgr_       = NULL;
   }

//------------------------------------------------------------------------------

void WitGpipBldr::placeShipmentReqs ()
   {
   WitDemTripStack theShipSeq (myProblem ());
   int             theSeqNo;
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;
   WitGpipReqSrc * theReqSrc;
   WitPart *       thePart;

   myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

   theSeqNo = -1;

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      theSeqNo ++;

      theReqSrc = myReqMgr_->newReqSrcForSeqNo (theSeqNo);

      thePart   = theDemand->demandedPart ();

      myReqMgr_->addReq (thePart, shipPer, theReqSrc, incShipVol);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeAllReqs ()
   {
   WitPart * thePart;
   WitPeriod fillPer;

   WitObjStack <WitPart> reversedParts (myProblem ());

   revCopyInto (reversedParts, myCompMgr ()->allParts ());

   while (reversedParts.pop (thePart))
      {
      for (fillPer = lastPeriod (); fillPer >= 0; fillPer --)
         fillReqs (thePart, fillPer);

      explodeOperations (thePart);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::fillReqs (WitPart * thePart, WitPeriod fillPer)
   {
   if (not myReqMgr_->hasReqsFor (thePart, fillPer))
      return;

   if (myGlobalComp ()->printGpip ())
      prtFillReqs (thePart, fillPer);

   myReqMgr_->loadCurReqList (thePart, fillPer);

   fillCurReqs (thePart, fillPer);

   myReqMgr_->clearCurReqList ();
   }

//------------------------------------------------------------------------------

void WitGpipBldr::fillCurReqs (WitPart * thePart, WitPeriod fillPer)
   {
   WitGpipReqSrc * theReqSrc;
   double          incReqVol;

   myReqMgr_->initReqListItr ();

   netAgainstSupply (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   explodeToProd (thePart, fillPer);

   if (myReqMgr_->finishedReqListItr ())
      return;

   explodeToStock (thePart, fillPer);

   if (not DEBUG_MODE)
      return;

   if (myReqMgr_->finishedReqListItr ())
      return;

   myReqMgr_->advanceReqListItr (theReqSrc, incReqVol);

   witAssert (incReqVol <= 2 * FEAS_TOL);

   witAssert (myReqMgr_->finishedReqListItr ());
   }

//------------------------------------------------------------------------------

void WitGpipBldr::netAgainstSupply (WitPart * thePart, WitPeriod fillPer)
   {
   double          residVol;
   double          netSuppVol;
   WitGpipReqSrc * theReqSrc;
   double          incSuppVol;

   witAssert (not myReqMgr_->finishedReqListItr ());

   residVol   = positivePart (thePart->residualVol ()[fillPer]);

   netSuppVol = positivePart (thePart->supplyVol ()[fillPer] - residVol);

   while (netSuppVol > NET_TOL)
      {
      myReqMgr_->advanceReqListItr (netSuppVol, theReqSrc, incSuppVol);

      if (myGlobalComp ()->printGpip ())
         prtNetToSupply (thePart, fillPer, incSuppVol, theReqSrc);

      pegReqSrc (
         myPgg_->supplyVolPgg (),
         thePart,
         fillPer,
         incSuppVol,
         theReqSrc,
         prevPgdSched_);

      if (myReqMgr_->finishedReqListItr ())
         break;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeToStock (WitPart * thePart, WitPeriod fillPer)
   {
   WitMaterial *   theMat;
   WitPeriod       stockPer;
   double          netStockVol;
   WitGpipReqSrc * theReqSrc;
   double          incStockVol;

   witAssert (not myReqMgr_->finishedReqListItr ());

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return;

   if (fillPer == 0)
      return;

   stockPer    = fillPer - 1;

   netStockVol = theMat->stockVol ()[stockPer];

   while (netStockVol > NET_TOL)
      {
      myReqMgr_->advanceReqListItr (netStockVol, theReqSrc, incStockVol);

      myReqMgr_->addReq (theMat, stockPer, theReqSrc, incStockVol);

      if (myReqMgr_->finishedReqListItr ())
         break;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeToProd (WitPart * thePart, WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;

   witAssert (not myReqMgr_->finishedReqListItr ());

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      {
      if (not theBopEnt->expEligible (fillPer))
         continue;

      explodeBopEntry (theBopEnt, fillPer);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeBopEntry (
      WitBopEntry * theBopEnt,
      WitPeriod     fillPer)
   {
   WitPeriod execPerFirst;
   WitPeriod execPerLast;
   WitPeriod execPer;

   witAssert (theBopEnt->expEligible (fillPer));

   witAssert (not myReqMgr_->finishedReqListItr ());

   myExecPerSched_->
      getExecPerRange (theBopEnt, fillPer, execPerFirst, execPerLast);

   for (execPer = execPerLast; execPer >= execPerFirst; execPer --)
      {
      if (not theBopEnt->execPerOKForExp (execPer))
         continue;

      if (theBopEnt->impactPeriod ()[execPer] != fillPer)
         continue;

      explodeToExecPer (theBopEnt, execPer);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeToExecPer (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer)
   {
   WitPart *       thePart;
   WitPeriod       prodPer;
   double          netProdVol;
   WitGpipReqSrc * theReqSrc;
   double          incProdVol;
   double          incExecVol;

   thePart    = theBopEnt->myPart ();
   prodPer    = theBopEnt->impactPeriod ()[execPer];

   netProdVol =
        theBopEnt->myOperation ()->execVol ()[execPer]
      * theBopEnt->effProdRate ()            [execPer];

   while (netProdVol > NET_TOL)
      {
      myReqMgr_->advanceReqListItr (netProdVol, theReqSrc, incProdVol);

      pegReqSrc (
         myPgg_->prodVolPgg (),
         thePart,
         prodPer,
         incProdVol,
         theReqSrc,
         prevPgdSched_);

      incExecVol = incProdVol / theBopEnt->effProdRate ()[execPer];

      myReqMgr_->addReq (theBopEnt, execPer, theReqSrc, incExecVol);

      if (myReqMgr_->finishedReqListItr ())
         return;
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeOperations (WitPart * thePart)
   {
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitPeriod      execPer;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      {
      theOpn = theBopEnt->myOperation ();

      nUnscannedBopEnts_ (theOpn) --;

      witAssert (nUnscannedBopEnts_ (theOpn) >= 0);

      if (nUnscannedBopEnts_ (theOpn) == 0)
         for (execPer = nPeriods () - 1; execPer >= 0; execPer --)
            explodeOperation (theOpn, execPer);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeOperation (WitOperation * theOpn, WitPeriod execPer)
   {
   WitGpipReqSrc * theReqSrc;
   double          incExecVol;
   WitBomEntry *   theBomEnt;

   if (not myReqMgr_->hasReqsFor (theOpn, execPer))
      return;

   myReqMgr_->loadCurReqList (theOpn, execPer);

   myReqMgr_->initReqListItr ();

   while (not myReqMgr_->finishedReqListItr ())
      {
      myReqMgr_->advanceReqListItr (theReqSrc, incExecVol);

      pegReqSrc (
         myPgg_->execVolPgg (),
         theOpn,
         execPer,
         incExecVol,
         theReqSrc,
         prevPgdSched_);
      }

   forEachEl (theBomEnt, theOpn->bom ())
      explodeBomEntry (theBomEnt, execPer);

   myReqMgr_->clearCurReqList ();
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeBomEntry (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitSubEntry * theSub;

   if (not theBomEnt->inEffect (execPer))
      return;

   myReqMgr_->initReqListItr ();

   explodeConsEntry (
      theBomEnt,
      execPer,
      theBomEnt->nonSubVol ()[execPer]);

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      if (myReqMgr_->finishedReqListItr ())
         return;

      explodeConsEntry (
         theSub,
         execPer,
         theSub->subVol ()[execPer]);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeConsEntry (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         totExecVol)
   {
   double          netExecVol;
   WitGpipReqSrc * theReqSrc;
   double          incExecVol;
   WitSubEntry *   theSub;

   netExecVol = totExecVol;

   while (netExecVol > NET_TOL)
      {
      if (myReqMgr_->finishedReqListItr ())
         return;

      myReqMgr_->advanceReqListItr (netExecVol, theReqSrc, incExecVol);

      theSub     = theConsEnt->thisSub ();

      if (theSub != NULL)
         pegReqSrc (
            myPgg_->subVolPgg (),
            theSub,
            execPer,
            incExecVol,
            theReqSrc,
            prevPgdSched_);

      explodeToConsumption (theConsEnt, execPer, incExecVol, theReqSrc);
      }
   }

//------------------------------------------------------------------------------

void WitGpipBldr::explodeToConsumption (
      WitConsEntry *  theConsEnt,
      WitPeriod       execPer,
      double          incExecVol,
      WitGpipReqSrc * theReqSrc)
   {
   WitPart * consPart;
   WitPeriod consPer;
   double    incConsVol;

   consPart   = theConsEnt->myPart ();

   consPer    = theConsEnt->impactPeriod ()[execPer];

   incConsVol = incExecVol * theConsEnt->effConsRate ()[execPer];

   if (incConsVol <= NET_TOL)
      return;

   pegReqSrc (
      myPgg_->consVolPgg (),
      consPart,
      consPer,
      incConsVol,
      theReqSrc,
      prevPgdSched_);

   myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::prtFillReqs (WitPart * thePart, WitPeriod fillPer)
   {
   witAssert (myGlobalComp ()->printGpip ());

   fprintf (msgFile (),
      "\n"
      "Filling requirements for Part %s in Period %d:\n",
      thePart->partName ().myCstring (),
      fillPer);
   }

//------------------------------------------------------------------------------

void WitGpipBldr::prtNetToSupply (
      WitPart *       thePart,
      WitPeriod       thePer,
      double          incSuppVol,
      WitGpipReqSrc * theReqSrc)
   {
   witAssert (myGlobalComp ()->printGpip ());

   fprintf (msgFile (),
      "\n"
      "Netting Against Supply:\n"
      "   Part:        %s\n"
      "   Period:      %d\n"
      "   Inc SuppVol: %.0f\n",
      thePart->partName ().myCstring (),
      thePer,
      incSuppVol);

   theReqSrc->print (msgFile (), "   ");
   }

//------------------------------------------------------------------------------
// Implementation of NonClass function template pegReqSrc.
//------------------------------------------------------------------------------

template <typename SrcComp>
      void WitNonClass::pegReqSrc (
         WitPipAttPgg <SrcComp> *        theAttPgg,
         SrcComp *                       theSrcComp,
         WitPeriod                       pegPer,
         double                          pegVol,
         WitGpipReqSrc *                 theReqSrc,
         WitSchedule <WitDemand, bool> & prevPgd)
   {
   WitGpipSeqElItr theItr;
   WitGpipSeqEl *  theSeqEl;
   WitDemand *     theDemand;
   WitPeriod       shipPer;

   witAssert (pegVol > NET_TOL);

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         if (prevPgd (theDemand)[shipPer])
            continue;

         theAttPgg->append (theDemand, shipPer, theSrcComp, pegPer, pegVol);

         prevPgd (theDemand)[shipPer] = true;
         }

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         prevPgd (theDemand)[shipPer] = false;
         }
   }
@


1.147
log
@GPIP
@
text
@@


1.146
log
@GPIP
@
text
@d15 1
a15 1
//    SrpBuilder
d38 1
a38 1
// Implementation of class SrpBuilder.
d41 1
a41 1
WitSrpBuilder::WitSrpBuilder (WitPipPgg * thePgg):
d56 1
a56 1
WitSrpBuilder::~WitSrpBuilder ()
d62 1
a62 1
void WitSrpBuilder::buildPegging ()
d79 1
a79 1
void WitSrpBuilder::checkRestrictions ()
d103 1
a103 1
void WitSrpBuilder::setUpBuild ()
d107 1
a107 1
   myReqMgr_       = new WitSrpReqMgr    (myProblem ());
d118 1
a118 1
void WitSrpBuilder::shutDownBuild ()
d129 1
a129 1
void WitSrpBuilder::placeShipmentReqs ()
d136 1
a136 1
   WitSrpReqSrc *  theReqSrc;
d157 1
a157 1
void WitSrpBuilder::explodeAllReqs ()
d177 1
a177 1
void WitSrpBuilder::fillReqs (WitPart * thePart, WitPeriod fillPer)
d194 1
a194 1
void WitSrpBuilder::fillCurReqs (WitPart * thePart, WitPeriod fillPer)
d196 2
a197 2
   WitSrpReqSrc * theReqSrc;
   double         incReqVol;
d228 1
a228 1
void WitSrpBuilder::netAgainstSupply (WitPart * thePart, WitPeriod fillPer)
d230 4
a233 4
   double         residVol;
   double         netSuppVol;
   WitSrpReqSrc * theReqSrc;
   double         incSuppVol;
d263 1
a263 1
void WitSrpBuilder::explodeToStock (WitPart * thePart, WitPeriod fillPer)
d265 5
a269 5
   WitMaterial *  theMat;
   WitPeriod      stockPer;
   double         netStockVol;
   WitSrpReqSrc * theReqSrc;
   double         incStockVol;
d298 1
a298 1
void WitSrpBuilder::explodeToProd (WitPart * thePart, WitPeriod fillPer)
d318 1
a318 1
void WitSrpBuilder::explodeBopEntry (
d350 1
a350 1
void WitSrpBuilder::explodeToExecPer (
d354 6
a359 6
   WitPart *      thePart;
   WitPeriod      prodPer;
   double         netProdVol;
   WitSrpReqSrc * theReqSrc;
   double         incProdVol;
   double         incExecVol;
d391 1
a391 1
void WitSrpBuilder::explodeOperations (WitPart * thePart)
d413 1
a413 1
void WitSrpBuilder::explodeOperation (WitOperation * theOpn, WitPeriod execPer)
d415 3
a417 3
   WitSrpReqSrc * theReqSrc;
   double         incExecVol;
   WitBomEntry *  theBomEnt;
d447 1
a447 1
void WitSrpBuilder::explodeBomEntry (
d477 1
a477 1
void WitSrpBuilder::explodeConsEntry (
d482 4
a485 4
   double         netExecVol;
   WitSrpReqSrc * theReqSrc;
   double         incExecVol;
   WitSubEntry *  theSub;
d513 5
a517 5
void WitSrpBuilder::explodeToConsumption (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         incExecVol,
      WitSrpReqSrc * theReqSrc)
d545 1
a545 1
void WitSrpBuilder::prtFillReqs (WitPart * thePart, WitPeriod fillPer)
d558 5
a562 5
void WitSrpBuilder::prtNetToSupply (
      WitPart *      thePart,
      WitPeriod      thePer,
      double         incSuppVol,
      WitSrpReqSrc * theReqSrc)
d589 1
a589 1
         WitSrpReqSrc *                  theReqSrc,
d592 4
a595 4
   WitSrpSeqElItr theItr;
   WitSrpSeqEl *  theSeqEl;
   WitDemand *    theDemand;
   WitPeriod      shipPer;
@


1.145
log
@[shared-resource pegging]
@
text
@d51 1
a51 1
   witAssert (myGlobalComp ()->srpMode ());
d86 1
a86 1
      myMsgFac () ("srpCaseNyiSmsg",
d91 1
a91 1
         myMsgFac () ("srpCaseNyiSmsg",
d97 1
a97 1
            myMsgFac () ("srpCaseNyiSmsg",
d182 1
a182 1
   if (myGlobalComp ()->printSrpDB ())
d245 1
a245 1
      if (myGlobalComp ()->printSrpDB ())
d547 1
a547 1
   witAssert (myGlobalComp ()->printSrpDB ());
d564 1
a564 1
   witAssert (myGlobalComp ()->printSrpDB ());
@


1.144
log
@[shared-resource pegging]
@
text
@a485 3
   WitPart *      consPart;
   WitPeriod      consPer;
   double         incConsVol;
d507 5
a511 1
      consPart   = theConsEnt->myPart ();
d513 9
a521 1
      consPer    = theConsEnt->impactPeriod ()[execPer];
d523 1
a523 1
      incConsVol = incExecVol * theConsEnt->effConsRate ()[execPer];
d525 16
a540 3
      if (incConsVol > NET_TOL)
         myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
      }
@


1.143
log
@[shared-resource pegging]
@
text
@d248 1
a248 1
      pegSrpReqSrc (
d302 2
d306 5
a312 2

      explodeBopEntry (theBopEnt, fillPer);
d326 1
a326 2
   if (not theBopEnt->expEligible (fillPer))
      return;
d354 2
d361 3
d366 1
a366 1
      * theBopEnt->effProdRate ()[execPer];
d372 8
d430 1
a430 1
      pegSrpReqSrc (
d502 1
a502 1
         pegSrpReqSrc (
d558 1
a558 1
// Implementation of NonClass function template pegSrpReqSrc.
d562 1
a562 1
      void WitNonClass::pegSrpReqSrc (
@


1.142
log
@[shared-resource pegging]
@
text
@d317 3
a319 8
   WitOperation * theOpn;
   WitPeriod      execPerFirst;
   WitPeriod      execPerLast;
   WitPeriod      execPer;
   double         netProdVol;
   WitSrpReqSrc * theReqSrc;
   double         incProdVol;
   double         incExecVol;
d326 2
a327 7
   theOpn       = theBopEnt->myOperation ();

   myExecPerSched_->getExecPerRange (
      theBopEnt,
      fillPer,
      execPerFirst,
      execPerLast);
d337 8
a344 2
      netProdVol =
         theOpn->execVol ()[execPer] * theBopEnt->effProdRate ()[execPer];
d346 16
a361 3
      while (netProdVol > NET_TOL)
         {
         myReqMgr_->advanceReqListItr (netProdVol, theReqSrc, incProdVol);
d363 1
a363 1
         incExecVol = incProdVol / theBopEnt->effProdRate ()[execPer];
d365 1
a365 1
         myReqMgr_->addReq (theBopEnt, execPer, theReqSrc, incExecVol);
d367 2
a368 3
         if (myReqMgr_->finishedReqListItr ())
            return;
         }
@


1.141
log
@[shared-resource pegging]
@
text
@d248 8
@


1.140
log
@[shared-resource pegging]
@
text
@d49 1
a49 1
      wasPeggedTo_       (myProblem (), false)
d397 7
a403 1
      pegExecVol (theOpn, execPer, incExecVol, theReqSrc);
d469 7
a475 1
         pegSubVol (theSub, execPer, incExecVol, theReqSrc);
d490 1
a490 5
void WitSrpBuilder::pegExecVol (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         incExecVol,
      WitSrpReqSrc * theReqSrc)
d492 1
a492 4
   WitSrpSeqElItr theItr;
   WitSrpSeqEl *  theSeqEl;
   WitDemand *    theDemand;
   WitPeriod      shipPer;
d494 6
a499 1
   witAssert (incExecVol > NET_TOL);
d501 1
a501 1
   theReqSrc->attachSeqElItr (theItr);
d503 7
a509 4
   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);
d511 9
a519 2
         if (wasPeggedTo_ (theDemand)[shipPer])
            continue;
d521 1
a521 16
         myPgg_->
            execVolPgg ()->
               append (theDemand, shipPer, theOpn, execPer, incExecVol);

         wasPeggedTo_ (theDemand)[shipPer] = true;
         }

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         wasPeggedTo_ (theDemand)[shipPer] = false;
         }
d525 2
d528 8
a535 5
void WitSrpBuilder::pegSubVol (
      WitSubEntry  * theSub,
      WitPeriod      execPer,
      double         incSubVol,
      WitSrpReqSrc * theReqSrc)
d542 1
a542 1
   witAssert (incSubVol > NET_TOL);
d551 1
a551 1
         if (wasPeggedTo_ (theDemand)[shipPer])
d554 1
a554 3
         myPgg_->
            subVolPgg ()->
               append (theDemand, shipPer, theSub, execPer, incSubVol);
d556 1
a556 1
         wasPeggedTo_ (theDemand)[shipPer] = true;
d566 1
a566 1
         wasPeggedTo_ (theDemand)[shipPer] = false;
a568 36

//------------------------------------------------------------------------------

void WitSrpBuilder::prtFillReqs (WitPart * thePart, WitPeriod fillPer)
   {
   witAssert (myGlobalComp ()->printSrpDB ());

   fprintf (msgFile (),
      "\n"
      "Filling requirements for Part %s in Period %d:\n",
      thePart->partName ().myCstring (),
      fillPer);
   }

//------------------------------------------------------------------------------

void WitSrpBuilder::prtNetToSupply (
      WitPart *      thePart,
      WitPeriod      thePer,
      double         incSuppVol,
      WitSrpReqSrc * theReqSrc)
   {
   witAssert (myGlobalComp ()->printSrpDB ());

   fprintf (msgFile (),
      "\n"
      "Netting Against Supply:\n"
      "   Part:        %s\n"
      "   Period:      %d\n"
      "   Inc SuppVol: %.0f\n",
      thePart->partName ().myCstring (),
      thePer,
      incSuppVol);

   theReqSrc->print (msgFile (), "   ");
   }
@


1.139
log
@[shared-resource pegging]
@
text
@d24 1
a24 2
#include <PipTarg.h>
#include <PipPegList.h>
d502 2
a503 3
            myTargFor (theDemand, shipPer)->
               execVolPegList ()->
                  append (theOpn, execPer, incExecVol);
d545 2
a546 3
            myTargFor (theDemand, shipPer)->
               subVolPegList ()->
                  append (theSub, execPer, incSubVol);
@


1.138
log
@[shared-resource pegging]
@
text
@d23 1
a23 1
#include <PipOwner.h>
d42 1
a42 1
WitSrpBuilder::WitSrpBuilder (WitPipOwner * thePipOwner):
d44 1
a44 1
      WitProbAssoc       (thePipOwner->myProblem ()),
d46 1
a46 1
      myPipOwner_        (thePipOwner),
d75 1
a75 1
   myPipOwner_->consolidatePegging ();
d502 1
a502 1
         myPipOwner_->
d546 1
a546 1
         myPipOwner_->
@


1.137
log
@[shared-resource pegging]
@
text
@d119 11
a408 47
void WitSrpBuilder::pegExecVol (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         incExecVol,
      WitSrpReqSrc * theReqSrc)
   {
   WitSrpSeqElItr theItr;
   WitSrpSeqEl *  theSeqEl;
   WitDemand *    theDemand;
   WitPeriod      shipPer;

   witAssert (incExecVol > NET_TOL);

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         if (wasPeggedTo_ (theDemand)[shipPer])
            continue;

         myPipOwner_->
            myTargFor (theDemand, shipPer)->
               execVolPegList ()->
                  append (theOpn, execPer, incExecVol);

         if (myGlobalComp ()->printSrpDB ())
            prtPegExecVol (theOpn, execPer, incExecVol, theDemand, shipPer);

         wasPeggedTo_ (theDemand)[shipPer] = true;
         }

   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         wasPeggedTo_ (theDemand)[shipPer] = false;
         }
   }

//------------------------------------------------------------------------------

d447 1
d461 5
d479 49
a527 1
void WitSrpBuilder::shutDownBuild ()
d529 31
a559 2
   delete myExecPerSched_;
   delete myReqMgr_;
d561 2
a562 2
   myExecPerSched_ = NULL;
   myReqMgr_       = NULL;
a599 26

//------------------------------------------------------------------------------

void WitSrpBuilder::prtPegExecVol (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         incExecVol,
      WitDemand *    theDemand,
      WitPeriod      shipPer)
   {
   witAssert (myGlobalComp ()->printSrpDB ());

   fprintf (msgFile (),
      "\n"
      "Pegging ExecVol:\n"
      "   Operation:   %s\n"
      "   Exec Period: %d\n"
      "   Inc ExecVol: %.0f\n"
      "   Demand:      %s\n"
      "   Ship Period  %d\n",
      theOpn->operationName ().myCstring (),
      execPer,
      incExecVol,
      theDemand->demandName ().myCstring (),
      shipPer);
   }
@


1.136
log
@[shared-resource pegging]
@
text
@a14 1
//    SrpOwner
a17 1
#include <SrpOwner.h>
d23 1
d39 1
a39 1
// Implementation of class SrpOwner.
d42 1
a42 1
WitSrpOwner::WitSrpOwner (WitProblem * theProblem):
d44 7
a50 1
      WitPipOwner (theProblem)
d52 1
a52 9
   WitSrpBuilder * theBuilder;

   checkRestrictions ();

   theBuilder = new WitSrpBuilder (this);

   theBuilder->buildPegging ();

   delete theBuilder;
d57 1
a57 1
WitSrpOwner::~WitSrpOwner ()
d63 1
a63 4
void WitSrpOwner::getExecVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitOpnTripStack & execVolTrips)
d65 1
a65 1
   WitPipTarg * theTarg;
d67 1
a67 1
   theTarg = myTargFor (theDemand, shipPer);
d69 1
a69 5
   if (theTarg != NULL)
      theTarg->execVolPegList ()->getPegTrips (execVolTrips);
   else
      execVolTrips.clear ();
   }
d71 1
a71 1
//------------------------------------------------------------------------------
d73 1
a73 7
void WitSrpOwner::getSubVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitSubTripStack & subVolTrips)
   {
   stronglyAssert (false);
   }
d75 1
a75 9
//------------------------------------------------------------------------------

void WitSrpOwner::getPartPegTrips (
      WitDemand *        theDemand,
      WitPeriod          shipPer,
      WitPipPartAtt::Tag theAttTag,
      WitPartTripStack & thePegTrips)
   {
   stronglyAssert (false);
d80 1
a80 1
void WitSrpOwner::checkRestrictions ()
a102 37
// Implementation of class SrpBuilder.
//------------------------------------------------------------------------------

WitSrpBuilder::WitSrpBuilder (WitPipOwner * thePipOwner):

      WitProbAssoc       (thePipOwner->myProblem ()),

      myPipOwner_        (thePipOwner),
      myReqMgr_          (NULL),
      myExecPerSched_    (NULL),
      nUnscannedBopEnts_ (),
      wasPeggedTo_       (myProblem (), false)
   {
   }

//------------------------------------------------------------------------------

WitSrpBuilder::~WitSrpBuilder ()
   {
   }

//------------------------------------------------------------------------------

void WitSrpBuilder::buildPegging ()
   {
   setUpBuild ();

   placeShipmentReqs ();

   explodeAllReqs ();

   shutDownBuild ();

   myPipOwner_->consolidatePegging ();
   }

//------------------------------------------------------------------------------
@


1.135
log
@[shared-resource pegging]
@
text
@d160 1
a160 1
   consolidatePegLists ();
a580 23
void WitSrpBuilder::consolidatePegLists ()
   {
   WitDemand *  theDemand;
   WitPeriod    shipPer;
   WitPipTarg * theTarg;

   WitSchedule <WitOperation, double> workOpnSched;

   workOpnSched .allocate1D (myProblem ());

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theTarg = myPipOwner_->myTargFor (theDemand, shipPer);

         if (theTarg == NULL)
            continue;

         theTarg->execVolPegList ()->consolidate (workOpnSched);
         }
   }
//------------------------------------------------------------------------------

@


1.134
log
@[shared-resource pegging]
@
text
@d25 2
d45 1
a45 2
      WitPipOwner     (theProblem),
      myExecVolTrips_ ()
a46 2
   WitDemand *     theDemand;
   WitPeriod       shipPer;
d51 1
a51 8
   myExecVolTrips_.allocate (myProblem ());

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         myExecVolTrips_.myPtrAt (theDemand, shipPer) =
            new WitOpnTripStack (myProblem ());

   theBuilder = new WitSrpBuilder (myProblem (), myExecVolTrips_);
a61 6
   WitDemand * theDemand;
   WitPeriod   shipPer;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         delete myExecVolTrips_.myPtrAt (theDemand, shipPer);
d71 8
a78 1
   execVolTrips.revCopyFrom (myExecVolTrips_.myElemAt (theDemand, shipPer));
d106 3
a108 5
   WitPart *      thePart;
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;
   WitBomEntry *  theBomEnt;
   WitPeriod      thePer;
d130 1
a130 3
WitSrpBuilder::WitSrpBuilder (
         WitProblem *                               theProblem,
         WitPtrSched <WitDemand, WitOpnTripStack> & theExecVolTrips):
d132 1
a132 1
      WitProbAssoc       (theProblem),
d134 1
a134 1
      myExecVolTrips_    (theExecVolTrips),
d160 1
a160 1
   consolidatePegging ();
d482 4
a485 3
         myExecVolTrips_.
            myElemAt (theDemand, shipPer).
               push (theOpn, execPer, incExecVol);
d581 1
a581 1
void WitSrpBuilder::consolidatePegging ()
d583 3
a585 6
   WitDemand *       theDemand;
   WitPeriod         shipPer;
   WitOpnTripStack * theOpnTripsPtr;
   WitOperation *    theOpn;
   WitPeriod         execPer;
   double            incExecVol;
d587 1
a587 2
   WitSchedule  <WitOperation, double>    pgdExecVol;
   WitPairStack <WitOperation, WitPeriod> theOpnPairs (myProblem ());
d589 1
a589 1
   pgdExecVol.allocate1D (myProblem ());
d594 1
a594 1
         theOpnTripsPtr = myExecVolTrips_.myPtrAt (theDemand, shipPer);
d596 2
a597 6
         while (theOpnTripsPtr->pop (theOpn, execPer, incExecVol))
            {
            if (not pgdExecVol (theOpn).isAllocated ())
               pgdExecVol (theOpn).allocate (myProblem (), 0.0);

            pgdExecVol (theOpn)[execPer] += incExecVol;
d599 1
a599 14
            theOpnPairs.push (theOpn, execPer);
            }

         while (theOpnPairs.pop (theOpn, execPer))
            {
            incExecVol = pgdExecVol (theOpn)[execPer];

            if (incExecVol == 0.0)
               continue;

            pgdExecVol (theOpn)[execPer] = 0.0;

            theOpnTripsPtr->push (theOpn, execPer, incExecVol);
            }
a601 1

@


1.133
log
@[shared-resource pegging]
@
text
@a118 3
   if (not myProblem ()->postprocessed ())
      myMsgFac () ("unpostPipSmsg");

a128 6
      {
      forEachPeriod (thePer, myProblem ())
         if (theBomEnt->effConsRate ()[thePer] < 1.0)
            myMsgFac () ("srpCaseNyiSmsg",
               "The problem contains an effective cons rate < 1.");

d130 1
a130 1
         if (theBomEnt->impactPeriod ()[thePer] != thePer)
d132 1
a132 2
               "The problem contains an impact period != the period.");
      }
d522 3
d569 1
a569 1
      consPer    = execPer;
d573 2
a574 1
      myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
@


1.132
log
@[shared-resource pegging]
@
text
@d25 1
a25 1
#include <ExecPerSched.h>
d397 1
a397 1
   myExecPerSched_->getData (
@


1.131
log
@[shared-resource pegging]
@
text
@d397 5
a401 2
   execPerFirst = myExecPerSched_->firstExecPer (theBopEnt, fillPer);
   execPerLast  = myExecPerSched_->lastExecPer  (theBopEnt, fillPer);
@


1.130
log
@[shared-resource pegging]
@
text
@d25 1
d157 1
d190 2
a191 1
   myReqMgr_ = new WitSrpReqMgr (myProblem ());
d382 2
d395 1
a395 1
   theOpn = theBopEnt->myOperation ();
d397 4
a400 1
   for (execPer = nPeriods () - 1; execPer >= 0; execPer --)
d585 1
d588 2
a589 1
   myReqMgr_ = NULL;
@


1.129
log
@[shared-resource pegging]
@
text
@d368 1
a368 1
      explodeBopEntryNew (theBopEnt, fillPer);
a384 37
   witAssert (not myReqMgr_->finishedReqListItr ());

   stronglyAssert (theBopEnt->expEligible (fillPer));

   theOpn     = theBopEnt->myOperation ();

   execPer    = fillPer;

   netProdVol =
      theOpn->execVol ()[execPer] * theBopEnt->effProdRate ()[execPer];

   while (netProdVol > NET_TOL)
      {
      myReqMgr_->advanceReqListItr (netProdVol, theReqSrc, incProdVol);

      incExecVol = incProdVol / theBopEnt->effProdRate ()[execPer];

      myReqMgr_->addReq (theBopEnt, execPer, theReqSrc, incExecVol);

      if (myReqMgr_->finishedReqListItr ())
         break;
      }
   }

//------------------------------------------------------------------------------

void WitSrpBuilder::explodeBopEntryNew (
      WitBopEntry * theBopEnt,
      WitPeriod     fillPer)
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         netProdVol;
   WitSrpReqSrc * theReqSrc;
   double         incProdVol;
   double         incExecVol;

@


1.128
log
@[shared-resource pegging]
@
text
@a125 6
      {
      forEachPeriod (thePer, myProblem ())
         if (theBopEnt->impactPeriod ()[thePer] != thePer)
            myMsgFac () ("srpCaseNyiSmsg",
               "The problem contains an impact period != the period.");

a128 1
      }
d248 1
a248 1
   if (myReqMgr_->hasNoReqsFor (thePart, fillPer))
d368 1
a368 1
      explodeBopEntry (theBopEnt, fillPer);
d411 45
d484 3
@


1.127
log
@[shared-resource pegging]
@
text
@d433 1
a433 1
         forEachPeriod (execPer, myProblem ())
@


1.126
log
@[shared-resource pegging]
@
text
@d28 1
a28 1
#include <Part.h>
a124 5
   forEachPart (thePart, myProblem ())
      if (thePart->thisMat () != NULL)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains at least one material part.");

d284 5
d331 35
@


1.125
log
@[shared-resource pegging]
@
text
@d31 1
a148 4
      if (not theBomEnt->mySubEntries ().isEmpty ())
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains at least one substitute.");

d420 1
d422 2
a423 3
      forEachEl (theBomEnt, theOpn->bom ())
         explodeBomEntry (theBomEnt, execPer, incExecVol, theReqSrc);
      }
d477 28
a504 1
      WitBomEntry *  theBomEnt,
d506 1
a506 2
      double         incExecVol,
      WitSrpReqSrc * theReqSrc)
d508 6
a513 3
   WitPart * consPart;
   WitPeriod consPer;
   double    incConsVol;
d515 8
a522 1
   witAssert (incExecVol > NET_TOL);
d524 1
a524 1
   consPart   = theBomEnt->myPart ();
d526 1
a526 1
   consPer    = execPer;
d528 1
a528 1
   incConsVol = incExecVol * theBomEnt->effConsRate ()[execPer];
d530 2
a531 1
   myReqMgr_->addReq (consPart, consPer, theReqSrc, incConsVol);
@


1.124
log
@[shared-resource pegging]
@
text
@a262 3
   WitSrpReqSrc * theReqSrc;
   double         incReqVol;

d271 14
d287 1
a287 1
   if (myReqMgr_->curReqListIsEmpty ())
d292 1
a292 1
   if (myReqMgr_->curReqListIsEmpty ())
d295 4
a298 1
   myReqMgr_->getFromCurReqList (theReqSrc, incReqVol);
d302 1
a302 1
   witAssert (myReqMgr_->curReqListIsEmpty ());
d314 1
a314 1
   witAssert (not myReqMgr_->curReqListIsEmpty ());
d322 1
a322 1
      myReqMgr_->netWithCurReqList (netSuppVol, theReqSrc, incSuppVol);
d327 1
a327 1
      if (myReqMgr_->curReqListIsEmpty ())
d340 1
a340 1
      if (myReqMgr_->curReqListIsEmpty ())
d360 1
a360 1
   witAssert (not myReqMgr_->curReqListIsEmpty ());
d373 1
a373 1
      myReqMgr_->netWithCurReqList (netProdVol, theReqSrc, incProdVol);
d375 1
a375 1
      incExecVol  = incProdVol / theBopEnt->effProdRate ()[execPer];
d379 1
a379 1
      if (myReqMgr_->curReqListIsEmpty ())
d416 3
a418 1
   while (not myReqMgr_->curReqListIsEmpty ())
d420 1
a420 1
      myReqMgr_->getFromCurReqList (theReqSrc, incExecVol);
d427 2
@


1.123
log
@[shared-resource pegging]
@
text
@d297 1
a298 2
   WitSrpReqSrc * theReqSrc;
   double         incReqVol;
d308 1
a308 9
      myReqMgr_->getFromCurReqList (theReqSrc, incReqVol);

      incSuppVol  = min (incReqVol, netSuppVol);

      incReqVol  -= incSuppVol;
      netSuppVol -= incSuppVol;

      if (incReqVol > NET_TOL)
         myReqMgr_->restoreToCurReqList (incReqVol);
a342 1
   double         incReqVol;
d359 1
a359 9
      myReqMgr_->getFromCurReqList (theReqSrc, incReqVol);

      incProdVol  = min (incReqVol, netProdVol);

      incReqVol  -= incProdVol;
      netProdVol -= incProdVol;

      if (incReqVol > NET_TOL)
         myReqMgr_->restoreToCurReqList (incReqVol);
@


1.122
log
@[shared-resource pegging]
@
text
@d350 1
a350 1
   double         netExecVol;
d353 1
a353 1
   double         incReqExecVol;
d364 2
a365 1
   netExecVol = theOpn->execVol ()[execPer];
d367 1
a367 1
   while (netExecVol > NET_TOL)
d371 1
a371 1
      incReqExecVol  = incReqVol / theBopEnt->effProdRate ()[fillPer];
d373 2
a374 6
      incExecVol     = min (incReqExecVol, netExecVol);

      incReqExecVol -= incExecVol;
      netExecVol    -= incExecVol;

      incReqVol      = incReqExecVol * theBopEnt->effProdRate ()[fillPer];
d379 2
@


1.121
log
@[shared-resource pegging]
@
text
@a130 4
      if (theBopEnt->effProdRate () != 1.0)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an effective prodRate != 1.");

d353 1
d370 6
a375 1
      incExecVol  = min (incReqVol, netExecVol);
d377 1
a377 2
      incReqVol  -= incExecVol;
      netExecVol -= incExecVol;
@


1.120
log
@[shared-resource pegging]
@
text
@d449 3
a451 3
      {
      if (theSeqEl->isNull ())
         continue;
d453 2
a454 1
      theSeqEl->getData (theDemand, shipPer);
d456 3
a458 2
      if (wasPeggedTo_ (theDemand)[shipPer])
         continue;
d460 2
a461 3
      myExecVolTrips_.
         myElemAt (theDemand, shipPer).
            push (theOpn, execPer, incExecVol);
d463 2
a464 5
      if (myGlobalComp ()->printSrpDB ())
         prtPegExecVol (theOpn, execPer, incExecVol, theDemand, shipPer);

      wasPeggedTo_ (theDemand)[shipPer] = true;
      }
d469 3
a471 3
      {
      if (theSeqEl->isNull ())
         continue;
d473 2
a474 4
      theSeqEl->getData (theDemand, shipPer);

      wasPeggedTo_ (theDemand)[shipPer] = false;
      }
@


1.119
log
@[shared-resource pegging]
@
text
@d439 4
a442 3
   int         theIdx;
   WitDemand * theDemand;
   WitPeriod   shipPer;
d446 3
a448 1
   for (theIdx = 0; theIdx < theReqSrc->nSeqEls (); theIdx ++)
d450 1
a450 1
      if (theReqSrc->mySeqElFor (theIdx)->isNull ())
d453 1
a453 1
      theReqSrc->mySeqElFor (theIdx)->getData (theDemand, shipPer);
d468 3
a470 1
   for (theIdx = 0; theIdx < theReqSrc->nSeqEls (); theIdx ++)
d472 1
a472 1
      if (theReqSrc->mySeqElFor (theIdx)->isNull ())
d475 1
a475 1
      theReqSrc->mySeqElFor (theIdx)->getData (theDemand, shipPer);
@


1.118
log
@[shared-resource pegging]
@
text
@d235 1
a235 1
      theReqSrc = myReqMgr_->newReqSrc (theDemand, shipPer, theSeqNo);
d447 3
d467 3
@


1.117
log
@[shared-resource pegging]
@
text
@a417 3
   if (myGlobalComp ()->printSrpDB ())
      prtExplodeOperation (theOpn, execPer);

a607 15

//------------------------------------------------------------------------------

void WitSrpBuilder::prtExplodeOperation (
      WitOperation * theOpn,
      WitPeriod      execPer)
   {
   witAssert (myGlobalComp ()->printSrpDB ());

   fprintf (msgFile (),
      "\n"
      "Exploding requirements for Operation %s in Period %d:\n",
      theOpn->operationName ().myCstring (),
      execPer);
   }
@


1.116
log
@[shared-resource pegging]
@
text
@d450 1
a450 2
      theDemand = theReqSrc->mySeqElFor (theIdx)->myDemand  ();
      shipPer   = theReqSrc->mySeqElFor (theIdx)->shipPerFor ();
d467 1
a467 2
      theDemand = theReqSrc->mySeqElFor (theIdx)->myDemand  ();
      shipPer   = theReqSrc->mySeqElFor (theIdx)->shipPerFor ();
@


1.115
log
@[shared-resource pegging]
@
text
@d442 3
a444 4
   WitSrpSeqElItr theItr;
   WitSrpSeqEl *  theSeqEl;
   WitDemand *    theDemand;
   WitPeriod      shipPer;
d448 1
a448 3
   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
d450 2
a451 2
      theDemand = theSeqEl->myDemand  ();
      shipPer   = theSeqEl->shipPerFor ();
d466 1
a466 3
   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
d468 2
a469 2
      theDemand = theSeqEl->myDemand  ();
      shipPer   = theSeqEl->shipPerFor ();
d585 1
a585 1
   theReqSrc->print ("   ");
@


1.114
log
@[shared-resource pegging]
@
text
@a26 1
#include <Schedule.h>
d175 2
a176 1
      nUnscannedBopEnts_ ()
a441 1
   WitSrpSeqEl *  prevSeqEl;
a448 2
   prevSeqEl = NULL;

a452 3
      if (theSeqEl == prevSeqEl)
         continue;

d456 3
d466 11
a476 1
      prevSeqEl = theSeqEl;
@


1.113
log
@[shared-resource pegging]
@
text
@d442 1
d450 2
d456 3
d468 2
@


1.112
log
@[shared-resource pegging]
@
text
@a562 3
   WitSrpSeqElItr theItr;
   WitSrpSeqEl *  theSeqEl;

a567 1
      "   ----------------\n"
d570 1
a570 2
      "   Inc SuppVol: %.0f\n"
      "   ----------------\n",
d575 1
a575 11
   theReqSrc->attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      fprintf (msgFile (),
         "   Demand:      %s\n"
         "   Ship Period  %d\n"
         "   Seq #:       %d\n"
         "   ----------------\n",
         theSeqEl->myDemand ()->demandName ().myCstring (),
         theSeqEl->shipPerFor (),
         theSeqEl->mySeqNo ());
@


1.111
log
@[shared-resource pegging]
@
text
@d148 4
a151 3
      if (theBomEnt->effConsRate () != 1.0)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an effective cons rate != 1.");
d483 1
a483 1
   incConsVol = incExecVol;
@


1.110
log
@[shared-resource pegging]
@
text
@d453 1
a453 1
      shipPer   = theSeqEl->myShipPer ();
d588 1
a588 1
         theSeqEl->myShipPer (),
@


1.109
log
@{shared-resource pegging]
@
text
@d25 1
d27 1
d196 2
d498 45
@


1.108
log
@[shared-resource pegging]
@
text
@a127 5
   forEachOperation (theOpn, myProblem ())
      if (theOpn->bop ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an operation with multiple BOP entries.");

a415 2
   stronglyAssert (theOpn->bop ().nElements () == 1);

@


1.107
log
@[shared-resource pegging]
@
text
@a413 1
   WitBopEntry *  theBopEnt;
d423 1
a423 3
   theBopEnt = theOpn->bop ().first ();

   myReqMgr_->loadCurReqList (theBopEnt, execPer);
d451 1
a451 1
   theReqSrc->mySeqEls ().attach (theItr);
d537 1
a537 1
   theReqSrc->mySeqEls ().attach (theItr);
@


1.106
log
@[shared-resource pegging]
@
text
@d447 4
a450 2
   WitDemand * theDemand;
   WitPeriod   shipPer;
d454 1
a454 2
   theDemand = theReqSrc->mySeqEl ()->myDemand  ();
   shipPer   = theReqSrc->mySeqEl ()->myShipPer ();
d456 12
a467 6
   myExecVolTrips_.
      myElemAt (theDemand, shipPer).
         push (theOpn, execPer, incExecVol);

   if (myGlobalComp ()->printSrpDB ())
      prtPegExecVol (theOpn, execPer, incExecVol, theReqSrc);
d523 3
d531 1
d535 1
a535 3
      "   Demand:      %s\n"
      "   Ship Period  %d\n"
      "   Seq #:       %d\n",
d538 13
a550 4
      incSuppVol,
      theReqSrc->mySeqEl ()->myDemand ()->demandName ().myCstring (),
      theReqSrc->mySeqEl ()->myShipPer (),
      theReqSrc->mySeqEl ()->mySeqNo ());
d559 2
a560 1
      WitSrpReqSrc * theReqSrc)
d571 1
a571 2
      "   Ship Period  %d\n"
      "   Seq #:       %d\n",
d575 2
a576 3
      theReqSrc->mySeqEl ()->myDemand ()->demandName ().myCstring (),
      theReqSrc->mySeqEl ()->myShipPer (),
      theReqSrc->mySeqEl ()->mySeqNo ());
@


1.105
log
@[shared-resource pegging]
@
text
@a16 4
//    SrpReqMgr
//    SrpReqSpec
//    SrpReqSrc
//    SrpSeqEl
a21 1
#include <SrpReqSpec.h>
a24 2
#include <ObjStack.h>
#include <PairStack.h>
a31 1
#include <CompMgr.h>
a33 2
#include <algorithm>

a575 439

//------------------------------------------------------------------------------
// Implementation of class SrpReqMgr.
//------------------------------------------------------------------------------

WitSrpReqMgr::WitSrpReqMgr (WitProblem * theProblem):

      WitProbAssoc      (theProblem),

      mySeqEls_         (theProblem),
      myReqSrcs_        (theProblem),
      myPartReqs_       (),
      myBopEntReqs_     (),
      myReqSpecVec_     (),
      nReqSpecsInVec_   (0),
      unusedReqSpecs_   (myProblem ()),
      curReqList_       (myProblem ()),
      maxReqListLength_ (0),
      retrievedReqSrc_  (NULL)
   {
   WitPart *     thePart;
   WitPeriod     fillPer;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   myPartReqs_.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      forEachPeriod (fillPer, myProblem ())
         myPartReqs_.myPtrAt (thePart, fillPer) =
            new WitSrpReqPairStack (myProblem ());

   myBopEntReqs_.allocate (myProblem ());

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         myBopEntReqs_.myPtrAt (theBopEnt, execPer) =
            new WitSrpReqPairStack (myProblem ());
   }

//------------------------------------------------------------------------------

WitSrpReqMgr::~WitSrpReqMgr ()
   {
   WitPart *     thePart;
   WitPeriod     fillPer;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   if (DEVELOPMENT)
      prtSizes ();

   deleteContents (unusedReqSpecs_);

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         delete myBopEntReqs_.myPtrAt (theBopEnt, execPer);

   myBopEntReqs_.clear ();

   forEachPart (thePart, myProblem ())
      forEachPeriod (fillPer, myProblem ())
         delete myPartReqs_.myPtrAt (thePart, fillPer);

   myPartReqs_.clear ();

   deleteContents (myReqSrcs_);
   deleteContents (mySeqEls_);
   }

//------------------------------------------------------------------------------

bool WitSrpReqMgr::hasNoReqsFor (WitPart * thePart, WitPeriod fillPer)
   {
   return myPartReqs_.myElemAt (thePart, fillPer).isEmpty ();
   }

//------------------------------------------------------------------------------

WitSrpReqSrc * WitSrpReqMgr::newReqSrc (
      WitDemand * theDemand,
      WitPeriod   shipPer,
      int         theSeqNo)
   {
   WitSrpSeqEl *  theSeqEl;
   WitSrpReqSrc * theReqSrc;

   theSeqEl  = new WitSrpSeqEl (theDemand, shipPer, theSeqNo);

   mySeqEls_.push (theSeqEl);

   theReqSrc = new WitSrpReqSrc (theSeqEl);

   myReqSrcs_.push (theReqSrc);

   return theReqSrc;
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::addReq (
      WitPart *      thePart,
      WitPeriod      fillPer,
      WitSrpReqSrc * theReqSrc,
      double         incReqVol)
   {
   witAssert (incReqVol > NET_TOL);

   myPartReqs_.myElemAt (thePart, fillPer).push (theReqSrc, incReqVol);
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::addReq (
      WitBopEntry *  theBopEnt,
      WitPeriod      execPer,
      WitSrpReqSrc * theReqSrc,
      double         incExecVol)
   {
   witAssert (incExecVol > NET_TOL);

   myBopEntReqs_.myElemAt (theBopEnt, execPer).push (theReqSrc, incExecVol);
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::loadCurReqList (WitPart * thePart, WitPeriod fillPer)
   {
   loadCurReqList (myPartReqs_.myElemAt (thePart, fillPer));

   if (curReqListIsEmpty ())
      return;

   loadReqSpecVec ();

   std::sort (
      myReqSpecVec_.myCVecForUpdate (),
      myReqSpecVec_.myCVecForUpdate () + nReqSpecsInVec_,
      WitSrpReqSpec::compare);

   unloadReqSpecVec ();
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::loadCurReqList (WitBopEntry * theBopEnt, WitPeriod execPer)
   {
   loadCurReqList (myBopEntReqs_.myElemAt (theBopEnt, execPer));
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::getFromCurReqList (
      WitSrpReqSrc * & theReqSrc,
      double &         incReqVol)
   {
   WitSrpReqSpec * theReqSpec;

   witAssert (not curReqListIsEmpty ());

   curReqList_.pop (theReqSpec);

   theReqSpec->getData (theReqSrc, incReqVol);

   reclaimReqSpec (theReqSpec);

   retrievedReqSrc_ = theReqSrc;
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::restoreToCurReqList (double incReqVol)
   {
   WitSrpReqSpec * theReqSpec;

   witAssert (incReqVol > NET_TOL);

   witAssert (retrievedReqSrc_ != NULL);
   
   theReqSpec = provideReqSpec (retrievedReqSrc_, incReqVol);

   curReqList_.push (theReqSpec);

   retrievedReqSrc_ = NULL;
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::loadCurReqList (WitSrpReqPairStack & theReqPairs)
   {
   WitSrpReqSrc *  theReqSrc;
   double          incReqVol;
   WitSrpReqSpec * theReqSpec;

   witAssert (curReqListIsEmpty ());

   while (theReqPairs.pop (theReqSrc, incReqVol))
      {
      theReqSpec = provideReqSpec (theReqSrc, incReqVol);

      curReqList_.push (theReqSpec);
      }

   setToMax (maxReqListLength_, curReqList_.nElements ());

   retrievedReqSrc_ = NULL;
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::loadReqSpecVec ()
   {
   int             theIdx;
   WitSrpReqSpec * theReqSpec;

   witAssert (nReqSpecsInVec_ == 0);

   nReqSpecsInVec_ = curReqList_.nElements ();

   if (nReqSpecsInVec_ > myReqSpecVec_.length ())
      myReqSpecVec_.resize (2 * nReqSpecsInVec_, NULL);

   theIdx = -1;

   while (curReqList_.pop (theReqSpec))
      {
      theIdx ++;

      myReqSpecVec_[theIdx] = theReqSpec;
      }

   if (myGlobalComp ()->printSrpDB ())
      prtReqSpecs (false);
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::unloadReqSpecVec ()
   {
   WitSrpReqSrc *  theReqSrcPrev;
   int             theIdx;
   WitSrpReqSpec * theReqSpec;
   WitSrpReqSrc *  theReqSrcCur;
   double          incReqVolCur;

   witAssert (nReqSpecsInVec_ > 0);

   if (myGlobalComp ()->printSrpDB ())
      prtReqSpecs (true);

   theReqSrcPrev = NULL;

   for (theIdx = nReqSpecsInVec_ - 1; theIdx >= 0; theIdx --)
      {
      theReqSpec            = myReqSpecVec_[theIdx];

      myReqSpecVec_[theIdx] = NULL;

      theReqSpec->getData (theReqSrcCur, incReqVolCur);

      if (theReqSrcCur != theReqSrcPrev)
         {
         curReqList_.push (theReqSpec);

         theReqSrcPrev = theReqSrcCur;
         }
      else
         {
         curReqList_.firstObject ()->addToIncReqVol (incReqVolCur);

         reclaimReqSpec (theReqSpec);
         }
      }

   nReqSpecsInVec_ = 0;
   }

//------------------------------------------------------------------------------

WitSrpReqSpec * WitSrpReqMgr::provideReqSpec (
      WitSrpReqSrc * theReqSrc,
      double         incReqVol)
   {
   WitSrpReqSpec * theReqSpec;

   if (unusedReqSpecs_.isNonEmpty ())
      unusedReqSpecs_.pop (theReqSpec);
   else
      theReqSpec = new WitSrpReqSpec;

   theReqSpec->setData (theReqSrc, incReqVol);

   return theReqSpec;
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::reclaimReqSpec (WitSrpReqSpec * theReqSpec)
   {
   unusedReqSpecs_.push (theReqSpec);
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::prtReqSpecs (bool afterSort)
   {
   int            theIdx;
   WitSrpReqSrc * theReqSrc;
   WitSrpSeqEl *  theSeqEl;
   double         incReqVol;

   fprintf (msgFile (),
      "\n"
      "   %s sorting:\n"
      "      Seq #  Dem  Per  Req\n",
      afterSort? "After": "Before");

   for (theIdx = 0; theIdx < nReqSpecsInVec_; theIdx ++)
      {
      myReqSpecVec_[theIdx]->getData (theReqSrc, incReqVol);

      theSeqEl = theReqSrc->mySeqEl ();

      fprintf (msgFile (),
         "      %5d  %3s  %3d  %3.0f\n",
         theSeqEl->mySeqNo (),
         theSeqEl->myDemand ()->demandName ().myCstring (),
         theSeqEl->myShipPer (),
         incReqVol);
      }
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::prtSizes ()
   {
   fprintf (msgFile (),
      "\n"
      "Max SRP Req List Length:        %d\n"
      "Max SRP Req Spec Vector Length: %d\n"
      "Total # Req Specs:              %d\n\n",
      maxReqListLength_,
      myReqSpecVec_.length (),
      unusedReqSpecs_.nElements ());
   }

//------------------------------------------------------------------------------
// Implementation of class SrpReqSpec.
//------------------------------------------------------------------------------

WitSrpReqSpec::WitSrpReqSpec ():
      myReqSrc_     (NULL),
      incReqVolVal_ (0.0)
   {
   }

//------------------------------------------------------------------------------

WitSrpReqSpec::~WitSrpReqSpec ()
   {
   }

//------------------------------------------------------------------------------

void WitSrpReqSpec::setData (WitSrpReqSrc * theReqSrc, double incReqVol)
   {
   witAssert (theReqSrc != NULL);
   witAssert (incReqVol >  NET_TOL);

   myReqSrc_     = theReqSrc;
   incReqVolVal_ = incReqVol;
   }

//------------------------------------------------------------------------------

void WitSrpReqSpec::addToIncReqVol (double deltaIncReqVol)
   {
   witAssert (deltaIncReqVol >  NET_TOL);

   incReqVolVal_ += deltaIncReqVol;
   }

//------------------------------------------------------------------------------

void WitSrpReqSpec::getData (WitSrpReqSrc * & theReqSrc, double & incReqVol)
   {
   witAssert (myReqSrc_ != NULL);

   theReqSrc = myReqSrc_;
   incReqVol = incReqVolVal_;
   }

//------------------------------------------------------------------------------

bool WitSrpReqSpec::compare (
      WitSrpReqSpec * theReqSpec1,
      WitSrpReqSpec * theReqSpec2)
   {
   return
      theReqSpec1->myReqSrc_->mySeqEl ()->mySeqNo ()
      < 
      theReqSpec2->myReqSrc_->mySeqEl ()->mySeqNo ();
   }

//------------------------------------------------------------------------------
// Implementation of class SrpReqSrc.
//------------------------------------------------------------------------------

WitSrpReqSrc::WitSrpReqSrc (WitSrpSeqEl * theSeqEl):
      mySeqEl_ (theSeqEl)
   {
   }

//------------------------------------------------------------------------------

WitSrpReqSrc::~WitSrpReqSrc ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class SrpSeqEl.
//------------------------------------------------------------------------------

WitSrpSeqEl::WitSrpSeqEl (
         WitDemand * theDemand,
         WitPeriod   shipPer,
         int         theSeqNo):

      myDemand_  (theDemand),
      myShipPer_ (shipPer),
      mySeqNo_   (theSeqNo)
   {
   }

//------------------------------------------------------------------------------

WitSrpSeqEl::~WitSrpSeqEl ()
   {
   }
@


1.104
log
@[shared-resource pegging]
@
text
@d714 1
a714 20
   WitSrpReqSrc *  theReqSrc;
   double          incReqVol;
   WitSrpReqSpec * theReqSpec;

   WitSrpReqPairStack & theReqPairs = myPartReqs_.myElemAt (thePart, fillPer);

   witAssert (curReqListIsEmpty ());

   while (theReqPairs.pop (theReqSrc, incReqVol))
      {
      theReqSpec = availReqSpec ();

      theReqSpec->setData (theReqSrc, incReqVol);

      curReqList_.push (theReqSpec);
      }

   setToMax (maxReqListLength_, curReqList_.nElements ());

   retrievedReqSrc_ = NULL;
d733 1
a733 21
   WitSrpReqSrc *  theReqSrc;
   double          incReqVol;
   WitSrpReqSpec * theReqSpec;

   WitSrpReqPairStack & theReqPairs =
      myBopEntReqs_.myElemAt (theBopEnt, execPer);

   witAssert (curReqListIsEmpty ());

   while (theReqPairs.pop (theReqSrc, incReqVol))
      {
      theReqSpec = availReqSpec ();

      theReqSpec->setData (theReqSrc, incReqVol);

      curReqList_.push (theReqSpec);
      }

   setToMax (maxReqListLength_, curReqList_.nElements ());

   retrievedReqSrc_ = NULL;
d765 20
a784 1
   theReqSpec = availReqSpec ();
d786 2
a787 1
   theReqSpec->setData (retrievedReqSrc_, incReqVol);
d789 1
a789 1
   curReqList_.push (theReqSpec);
d865 3
a867 1
WitSrpReqSpec * WitSrpReqMgr::availReqSpec ()
d876 2
@


1.103
log
@[shared-resource pegging]
@
text
@d844 1
d846 2
a847 1
   double          incReqVolPrev;
a848 3
   WitSrpReqSrc *  theReqSrcCur;
   WitSrpReqSrc *  theReqSrcPrev;
   WitSrpReqSpec * theReqSpec;
d855 1
a855 1
   getReqSpecFromVec (nReqSpecsInVec_ - 1, theReqSrcPrev, incReqVolPrev);
d857 1
a857 1
   for (theIdx = nReqSpecsInVec_ - 2; theIdx >= 0; theIdx --)
d859 1
a859 1
      getReqSpecFromVec (theIdx, theReqSrcCur, incReqVolCur);
d861 1
a861 5
      if (theReqSrcCur->mySeqEl () == theReqSrcPrev->mySeqEl ())
         incReqVolPrev += incReqVolCur;
      else
         {
         theReqSpec = availReqSpec ();
d863 1
a863 1
         theReqSpec->setData (theReqSrcPrev, incReqVolPrev);
d865 2
d870 6
a875 1
         incReqVolPrev = incReqVolCur;
a878 6
   theReqSpec = availReqSpec ();

   theReqSpec->setData (theReqSrcPrev, incReqVolPrev);

   curReqList_.push (theReqSpec);

a883 18
void WitSrpReqMgr::getReqSpecFromVec (
      int              theIdx,
      WitSrpReqSrc * & theReqSrc,
      double &         incReqVol)
   {
   WitSrpReqSpec * theReqSpec;

   theReqSpec            = myReqSpecVec_[theIdx];

   myReqSpecVec_[theIdx] = NULL;

   theReqSpec->getData (theReqSrc, incReqVol);

   reclaimReqSpec (theReqSpec);
   }

//------------------------------------------------------------------------------

d976 9
@


1.102
log
@[shared-resource pegging]
@
text
@d817 1
a818 2
   WitSrpReqSrc *  theReqSrc;
   double          incReqVol;
d822 6
a827 2
   if (curReqList_.nElements () > myReqSpecVec_.length ())
      myReqSpecVec_.resize (2 * curReqList_.nElements (), NULL);
d831 1
a831 1
      nReqSpecsInVec_ ++;
d833 1
a833 1
      myReqSpecVec_[nReqSpecsInVec_ - 1] = theReqSpec;
d844 1
d856 1
a856 1
   getLastReqSpecInVec (theReqSrcPrev, incReqVolPrev);
d858 1
a858 1
   while (nReqSpecsInVec_ > 0)
d860 1
a860 1
      getLastReqSpecInVec (theReqSrcCur, incReqVolCur);
d882 2
d888 2
a889 1
void WitSrpReqMgr::getLastReqSpecInVec (
d895 1
a895 5
   witAssert (nReqSpecsInVec_ > 0);

   theReqSpec = myReqSpecVec_[nReqSpecsInVec_ - 1];

   myReqSpecVec_[nReqSpecsInVec_ - 1] = NULL;
d897 1
a897 1
   nReqSpecsInVec_ --;
@


1.101
log
@[shared-resource pegging]
@
text
@d593 1
a593 1
      WitProbAssoc     (theProblem),
d595 10
a604 9
      mySeqEls_        (theProblem),
      myReqSrcs_       (theProblem),
      myPartReqs_      (),
      myBopEntReqs_    (),
      myReqSpecVec_    (),
      nReqSpecsInVec_  (0),
      unusedReqSpecs_  (myProblem ()),
      curReqList_      (myProblem ()),
      retrievedReqSrc_ (NULL)
d714 6
d722 8
a729 1
   curReqList_.takeContents (myPartReqs_.myElemAt (thePart, fillPer));
d731 1
a731 1
   curReqList_.reverse ();
d752 7
d761 8
a768 1
   retrievedReqSrc_ = NULL;
d770 1
a770 1
   curReqList_.takeContents (myBopEntReqs_.myElemAt (theBopEnt, execPer));
d772 1
a772 1
   curReqList_.reverse ();
d781 2
d785 5
a789 1
   curReqList_.pop (theReqSrc, incReqVol);
d798 2
d804 5
a808 1
   curReqList_.push (retrievedReqSrc_, incReqVol);
d826 1
a826 1
   while (curReqList_.pop (theReqSrc, incReqVol))
a827 4
      theReqSpec = availReqSpec ();

      theReqSpec->setData (theReqSrc, incReqVol);

d832 1
a832 1
   
d841 5
a845 4
   double         incReqVolPrev;
   double         incReqVolCur;
   WitSrpReqSrc * theReqSrcCur;
   WitSrpReqSrc * theReqSrcPrev;
d862 5
a866 1
         curReqList_.push (theReqSrcPrev, incReqVolPrev);
d873 5
a877 1
   curReqList_.push (theReqSrcPrev, incReqVolPrev);
d958 6
a963 4
      "Max # SRP Req Specs in Vector:  %d\n"
      "Max SRP Req Spec Vector Length: %d\n\n",
      unusedReqSpecs_.nElements (),
      myReqSpecVec_.length ());
@


1.100
log
@[shared-resource pegging]
@
text
@d788 1
a788 4
      if (unusedReqSpecs_.isNonEmpty ())
         unusedReqSpecs_.pop (theReqSpec);
      else
         theReqSpec = new WitSrpReqSpec;
d853 21
@


1.99
log
@[shared-resource pegging]
@
text
@d717 2
a777 1
   int             theIdx;
d783 2
a784 6
   nReqSpecsInVec_ = curReqList_.nElements ();
   
   if (nReqSpecsInVec_ > myReqSpecVec_.length ())
      myReqSpecVec_.resize (2 * nReqSpecsInVec_, NULL);

   theIdx = nReqSpecsInVec_;
d795 1
a795 1
      theIdx --;
d797 1
a797 1
      myReqSpecVec_[theIdx] = theReqSpec;
@


1.98
log
@[shared-resource pegging]
@
text
@d593 1
a593 1
      WitProbAssoc      (theProblem),
d595 9
a603 8
      mySeqEls_         (theProblem),
      myReqSrcs_        (theProblem),
      myPartReqs_       (),
      myBopEntReqs_     (),
      activeReqSpecs_   (),
      inactiveReqSpecs_ (myProblem ()),
      curReqList_       (myProblem ()),
      retrievedReqSrc_  (NULL)
d637 1
a637 1
   deleteContents (inactiveReqSpecs_);
d722 1
a722 1
   formActiveReqSpecs ();
d725 2
a726 2
      activeReqSpecs_.begin (),
      activeReqSpecs_.end   (),
d729 1
a729 1
   formReqPairs ();
d773 1
a773 1
void WitSrpReqMgr::formActiveReqSpecs ()
a774 1
   int             nPairs;
d780 1
a780 1
   witAssert (activeReqSpecs_.empty ());
d782 1
a782 1
   nPairs = curReqList_.nElements ();
d784 2
a785 2
   if (nPairs > activeReqSpecs_.capacity ())
      activeReqSpecs_.reserve (2 * nPairs);
d787 1
a787 3
   activeReqSpecs_.resize (nPairs);

   theIdx = nPairs;
d791 2
a792 2
      if (inactiveReqSpecs_.isNonEmpty ())
         inactiveReqSpecs_.pop (theReqSpec);
d800 1
a800 1
      activeReqSpecs_[theIdx] = theReqSpec;
d809 1
a809 1
void WitSrpReqMgr::formReqPairs ()
d816 1
a816 1
   witAssert (not activeReqSpecs_.empty ());
d821 1
a821 1
   popActiveReqSpecs (theReqSrcPrev, incReqVolPrev);
d823 1
a823 1
   while (not activeReqSpecs_.empty ())
d825 1
a825 1
      popActiveReqSpecs (theReqSrcCur, incReqVolCur);
d843 1
a843 1
void WitSrpReqMgr::popActiveReqSpecs (
d849 1
a849 1
   witAssert (not activeReqSpecs_.empty ());
d851 1
a851 1
   theReqSpec = activeReqSpecs_.back ();
d853 1
a853 1
   activeReqSpecs_.back () = NULL;
d855 1
a855 1
   activeReqSpecs_.pop_back ();
d859 1
a859 1
   inactiveReqSpecs_.push (theReqSpec);
d877 1
a877 1
   for (theIdx = 0; theIdx < activeReqSpecs_.size (); theIdx ++)
d879 1
a879 1
      activeReqSpecs_[theIdx]->getData (theReqSrc, incReqVol);
d898 4
a901 4
      "Max SRP Req List Length:   %d\n"
      "Max SRP Req List Capacity: %d\n\n",
      inactiveReqSpecs_.nElements (),
      activeReqSpecs_.capacity ());
@


1.97
log
@[shared-resource pegging]
@
text
@d17 1
a17 1
//    SrpReqList
d25 1
a25 1
#include <SrpReqList.h>
d187 1
a187 5
      mySeqEls_          (theProblem),
      myReqSrcs_         (theProblem),
      myPartReqs_        (),
      myBopEntReqs_      (),
      myReqList_         (NULL),
d215 1
a215 3
   WitPart *      thePart;
   WitPeriod      thePer;
   WitBopEntry *  theBopEnt;
d217 1
a217 15
   myReqList_ = new WitSrpReqList (myProblem ());

   myPartReqs_.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         myPartReqs_.myPtrAt (thePart, thePer) =
            new WitSrpReqPairStack (myProblem ());

   myBopEntReqs_.allocate (myProblem ());

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (thePer, myProblem ())
         myBopEntReqs_.myPtrAt (theBopEnt, thePer) =
            new WitSrpReqPairStack (myProblem ());
a231 1
   WitSrpSeqEl *   theSeqEl;
d234 1
a235 1
   WitSrpReqSrc *  theReqSrc;
d245 1
a245 7
      theSeqEl  = new WitSrpSeqEl (theDemand, shipPer, theSeqNo);

      mySeqEls_.push (theSeqEl);

      theReqSrc = new WitSrpReqSrc (theSeqEl);

      myReqSrcs_.push (theReqSrc);
d249 1
a249 1
      myPartReqs_.myElemAt (thePart, shipPer).push (theReqSrc, incShipVol);
d280 1
a280 1
   if (myPartReqs_.myElemAt (thePart, fillPer).isEmpty ())
d286 1
a286 1
   myReqList_->load (myPartReqs_.myElemAt (thePart, fillPer));
d290 1
a290 1
   if (myReqList_->isEmpty ())
d295 1
a295 1
   if (myReqList_->isEmpty ())
d298 1
a298 1
   myReqList_->getReq (theReqSrc, incReqVol);
d302 1
a302 1
   witAssert (myReqList_->isEmpty ());
d315 1
a315 1
   witAssert (not myReqList_->isEmpty ());
d323 1
a323 1
      myReqList_->getReq (theReqSrc, incReqVol);
d331 1
a331 1
         myReqList_->restoreReq (incReqVol);
d336 1
a336 1
      if (myReqList_->isEmpty ())
d349 1
a349 1
      if (myReqList_->isEmpty ())
d369 1
a369 1
   witAssert (not myReqList_->isEmpty ());
a376 2
   witAssert (myBopEntReqs_.myElemAt (theBopEnt, execPer).isEmpty ());

d381 1
a381 1
      myReqList_->getReq (theReqSrc, incReqVol);
d389 1
a389 1
         myReqList_->restoreReq (incReqVol);
d391 3
a393 3
      myBopEntReqs_.myElemAt (theBopEnt, execPer).push (theReqSrc, incExecVol);
      
      if (myReqList_->isEmpty ())
d424 4
a427 5
   WitBopEntry *        theBopEnt;
   WitSrpReqPairStack * theReqPairsPtr;
   WitSrpReqSrc *       theReqSrc;
   double               incExecVol;
   WitBomEntry *        theBomEnt;
a432 2
   
   theBopEnt      = theOpn->bop ().first ();
d434 1
a434 1
   theReqPairsPtr = myBopEntReqs_.myPtrAt (theBopEnt, execPer);
d436 1
a436 1
   theReqPairsPtr->reverse ();
d438 1
a438 1
   while (theReqPairsPtr->pop (theReqSrc, incExecVol))
d440 2
d493 1
a493 1
   myPartReqs_.myElemAt (consPart, consPer).push (theReqSrc, incConsVol);
d500 1
a500 9
   WitBopEntry * theBopEnt;
   WitPart *     thePart;
   WitPeriod     thePer;

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myBopEntReqs_.myPtrAt (theBopEnt, thePer);

   myBopEntReqs_.clear ();
d502 1
a502 12
   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myPartReqs_.myPtrAt (thePart, thePer);

   myPartReqs_.clear ();

   delete myReqList_;

   myReqList_ = NULL;

   deleteContents (myReqSrcs_);
   deleteContents (mySeqEls_);
d588 1
a588 1
// Implementation of class SrpReqList.
d591 1
a591 1
WitSrpReqList::WitSrpReqList (WitProblem * theProblem):
d595 4
d601 1
a601 1
      curReqPairs_      (myProblem ()),
d604 18
d626 1
a626 1
WitSrpReqList::~WitSrpReqList ()
d628 5
d637 43
d684 5
a688 1
void WitSrpReqList::load (WitSrpReqPairStack & theReqPairs)
d690 25
a714 1
   witAssert (isEmpty ());
d718 1
a718 1
   if (theReqPairs.isEmpty ())
d721 1
a721 1
   formActiveReqSpecs (theReqPairs);
d733 16
a748 1
void WitSrpReqList::getReq (WitSrpReqSrc * & theReqSrc, double & incReqVol)
d750 1
a750 1
   witAssert (not isEmpty ());
d752 1
a752 1
   curReqPairs_.pop (theReqSrc, incReqVol);
d759 1
a759 1
void WitSrpReqList::restoreReq (double incReqVol)
d765 1
a765 1
   curReqPairs_.push (retrievedReqSrc_, incReqVol);
d772 1
a772 1
void WitSrpReqList::formActiveReqSpecs (WitSrpReqPairStack & theReqPairs)
d782 1
a782 1
   nPairs = theReqPairs.nElements ();
d791 1
a791 1
   while (theReqPairs.pop (theReqSrc, incReqVol))
d811 1
a811 1
void WitSrpReqList::formReqPairs ()
d833 1
a833 1
         curReqPairs_.push (theReqSrcPrev, incReqVolPrev);
d840 1
a840 1
   curReqPairs_.push (theReqSrcPrev, incReqVolPrev);
d845 1
a845 1
void WitSrpReqList::popActiveReqSpecs (
d866 1
a866 1
void WitSrpReqList::prtReqSpecs (bool afterSort)
d896 1
a896 1
void WitSrpReqList::prtSizes ()
@


1.96
log
@[shared-resource pegging]
@
text
@d19 1
d27 1
d188 1
d256 1
d266 1
a266 1
      theSeqEl = new WitSrpSeqEl (theDemand, shipPer, theSeqNo);
d270 1
a270 1
      thePart     = theDemand->demandedPart ();
d272 5
a276 1
      myPartReqs_.myElemAt (thePart, shipPer).push (theSeqEl, incShipVol);
d304 2
a305 2
   WitSrpSeqEl * theSeqEl;
   double        incReqVol;
d325 1
a325 1
   myReqList_->getReq (theSeqEl, incReqVol);
d336 5
a340 5
   double        residVol;
   double        netSuppVol;
   double        incSuppVol;
   WitSrpSeqEl * theSeqEl;
   double        incReqVol;
d350 1
a350 1
      myReqList_->getReq (theSeqEl, incReqVol);
d361 1
a361 1
         prtNetToSupply (thePart, fillPer, incSuppVol, theSeqEl);
d392 1
a392 1
   WitSrpSeqEl *  theSeqEl;
d410 1
a410 1
      myReqList_->getReq (theSeqEl, incReqVol);
d420 1
a420 1
      myBopEntReqs_.myElemAt (theBopEnt, execPer).push (theSeqEl, incExecVol);
d455 1
a455 1
   WitSrpSeqEl *        theSeqEl;
d464 1
a464 1
   theBopEnt = theOpn->bop ().first ();
d470 1
a470 1
   while (theReqPairsPtr->pop (theSeqEl, incExecVol))
d472 1
a472 1
      pegExecVol (theOpn, execPer, incExecVol, theSeqEl);
d475 1
a475 1
         explodeBomEntry (theBomEnt, execPer, incExecVol, theSeqEl);
d485 1
a485 1
      WitSrpSeqEl *  theSeqEl)
d492 2
a493 2
   theDemand = theSeqEl->myDemand  ();
   shipPer   = theSeqEl->myShipPer ();
d500 1
a500 1
      prtPegExecVol (theOpn, execPer, incExecVol, theSeqEl);
d506 4
a509 4
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        incExecVol,
      WitSrpSeqEl * theSeqEl)
d523 1
a523 1
   myPartReqs_.myElemAt (consPart, consPer).push (theSeqEl, incConsVol);
d550 1
d570 4
a573 4
      WitPart *     thePart,
      WitPeriod     thePer,
      double        incSuppVol,
      WitSrpSeqEl * theSeqEl)
d589 3
a591 3
      theSeqEl->myDemand ()->demandName ().myCstring (),
      theSeqEl->myShipPer (),
      theSeqEl->mySeqNo ());
d600 1
a600 1
      WitSrpSeqEl *  theSeqEl)
d616 3
a618 3
      theSeqEl->myDemand ()->demandName ().myCstring (),
      theSeqEl->myShipPer (),
      theSeqEl->mySeqNo ());
d645 3
a647 3
      inactiveReqSpecs_ (theProblem),
      myReqPairs_       (theProblem),
      retrievedSeqEl_   (NULL)
d667 1
a667 1
   retrievedSeqEl_ = NULL;
d684 1
a684 1
void WitSrpReqList::getReq (WitSrpSeqEl * & theSeqEl, double & incReqVol)
d688 1
a688 1
   myReqPairs_.pop (theSeqEl, incReqVol);
d690 1
a690 1
   retrievedSeqEl_ = theSeqEl;
d699 1
a699 1
   witAssert (retrievedSeqEl_ != NULL);
d701 1
a701 1
   myReqPairs_.push (retrievedSeqEl_, incReqVol);
d703 1
a703 1
   retrievedSeqEl_ = NULL;
d713 1
a713 1
   WitSrpSeqEl *   theSeqEl;
d727 1
a727 1
   while (theReqPairs.pop (theSeqEl, incReqVol))
d734 1
a734 1
      theReqSpec->setData (theSeqEl, incReqVol);
d749 4
a752 4
   WitSrpSeqEl * theSeqElPrev;
   double        incReqVolPrev;
   WitSrpSeqEl * theSeqElCur;
   double        incReqVolCur;
d759 1
a759 1
   popActiveReqSpecs (theSeqElPrev, incReqVolPrev);
d763 1
a763 1
      popActiveReqSpecs (theSeqElCur, incReqVolCur);
d765 1
a765 1
      if (theSeqElCur == theSeqElPrev)
d769 1
a769 1
         myReqPairs_.push (theSeqElPrev, incReqVolPrev);
d771 2
a772 2
         theSeqElPrev   = theSeqElCur;
         incReqVolPrev  = incReqVolCur;
d776 1
a776 1
   myReqPairs_.push (theSeqElPrev, incReqVolPrev);
d782 2
a783 2
      WitSrpSeqEl * & theSeqEl,
      double &        incReqVol)
d795 1
a795 1
   theReqSpec->getData (theSeqEl, incReqVol);
d804 4
a807 3
   int           theIdx;
   WitSrpSeqEl * theSeqEl;
   double        incReqVol;
d817 3
a819 1
      activeReqSpecs_[theIdx]->getData (theSeqEl, incReqVol);
d847 1
a847 1
      mySeqEl_      (NULL),
d860 1
a860 1
void WitSrpReqSpec::setData (WitSrpSeqEl * theSeqEl, double incReqVol)
d862 1
a862 1
   witAssert (theSeqEl  != NULL);
d865 1
a865 1
   mySeqEl_      = theSeqEl;
d871 1
a871 1
void WitSrpReqSpec::getData (WitSrpSeqEl * & theSeqEl, double & incReqVol)
d873 1
a873 1
   witAssert (mySeqEl_ != NULL);
d875 1
a875 1
   theSeqEl  = mySeqEl_;
d886 1
a886 1
      theReqSpec1->mySeqEl_->mySeqNo ()
d888 16
a903 1
      theReqSpec2->mySeqEl_->mySeqNo ();
@


1.95
log
@[shared-resource pegging]
@
text
@d186 2
a187 1
      myReqPairStacks_   (),
d222 1
a222 1
   myReqPairStacks_.allocate (myProblem ());
d226 8
a233 1
         myReqPairStacks_.myPtrAt (thePart, thePer) =
d268 1
a268 1
      myReqPairStacks_.myElemAt (thePart, shipPer).push (theSeqEl, incShipVol);
d299 1
a299 1
   if (myReqPairStacks_.myElemAt (thePart, fillPer).isEmpty ())
d305 1
a305 1
   myReqList_->load (myReqPairStacks_.myElemAt (thePart, fillPer));
d377 3
a379 1
void WitSrpBuilder::explodeBopEntry (WitBopEntry * theBopEnt, WitPeriod fillPer)
a386 1
   WitBomEntry *  theBomEnt;
d396 2
d412 52
a467 3

      if (myReqList_->isEmpty ())
         break;
d492 1
a492 1
      prtExplodeToProd (theOpn, execPer, incExecVol, theSeqEl);
d515 1
a515 1
   myReqPairStacks_.myElemAt (consPart, consPer).push (theSeqEl, incConsVol);
d520 1
a520 1
void WitSrpBuilder::explodeOperations (WitPart * thePart)
d522 3
a524 3
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitPeriod      execPer;
d526 3
a528 3
   forEachEl (theBopEnt, thePart->producingBopEntries ())
      {
      theOpn = theBopEnt->myOperation ();
d530 1
a530 24
      nUnscannedBopEnts_ (theOpn) --;

      witAssert (nUnscannedBopEnts_ (theOpn) >= 0);

      if (nUnscannedBopEnts_ (theOpn) == 0)
         forEachPeriod (execPer, myProblem ())
            explodeOperation (theOpn, execPer);
      }
   }

//------------------------------------------------------------------------------

void WitSrpBuilder::explodeOperation (WitOperation * theOpn, WitPeriod execPer)
   {
   if (myGlobalComp ()->printSrpDB ())
      prtExplodeOperation (theOpn, execPer);
   }

//------------------------------------------------------------------------------

void WitSrpBuilder::shutDownBuild ()
   {
   WitPart * thePart;
   WitPeriod thePer;
d534 1
a534 1
         delete myReqPairStacks_.myPtrAt (thePart, thePer);
d536 1
a536 1
   myReqPairStacks_.clear ();
d587 1
a587 1
void WitSrpBuilder::prtExplodeToProd (
d597 1
a597 1
      "Exploding to Production:\n"
@


1.94
log
@[shared-resource pegging]
@
text
@d182 1
a182 1
      WitProbAssoc     (theProblem),
d184 5
a188 4
      myExecVolTrips_  (theExecVolTrips),
      mySeqEls_        (theProblem),
      myReqPairStacks_ (),
      myReqList_       (NULL)
d215 3
a217 2
   WitPart * thePart;
   WitPeriod thePer;
d227 5
d276 2
a277 1
      forEachPeriod (fillPer, myProblem ())
d279 3
d432 1
a432 1
      prtExpToProd (theOpn, execPer, incExecVol, theSeqEl);
d460 30
d550 1
a550 1
void WitSrpBuilder::prtExpToProd (
d576 15
@


1.93
log
@[shared-resource pegging]
@
text
@a131 1
      {
a135 5
      if (thePart->producingBopEntries ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains a part produced by > 1 BOP entry.");
      }

d345 15
a359 1
   WitBopEntry *  theBopEnt;
a369 5
   if (thePart->producingBopEntries ().isEmpty ())
      return;

   theBopEnt = thePart->producingBopEntries ().first ();

@


1.92
log
@[shared-resource pegging]
@
text
@d560 4
a635 2
   retrievedSeqEl_ = NULL;

a650 2
   witAssert (isEmpty ());

@


1.91
log
@[shared-resource pegging]
@
text
@d289 3
d466 13
d601 3
a605 1
   WitSrpReqSpec * theReqSpec;
d609 8
a616 2
   if (theReqPairs.nElements () > activeReqSpecs_.capacity ())
      activeReqSpecs_.reserve (2 * theReqPairs.nElements ());
d627 3
a629 1
      activeReqSpecs_.push_back (theReqSpec);
d631 2
d634 2
a635 1
   retrievedSeqEl_ = NULL;
d651 3
d697 27
@


1.90
log
@[shared-resource pegging]
@
text
@d301 1
a301 1
   myReqList_->getFirst (theSeqEl, incReqVol);
d326 1
a326 1
      myReqList_->getFirst (theSeqEl, incReqVol);
d334 1
a334 1
         myReqList_->addToFront (theSeqEl, incReqVol);
d374 1
a374 1
      myReqList_->getFirst (theSeqEl, incReqVol);
d382 1
a382 1
         myReqList_->addToFront (theSeqEl, incReqVol);
d523 2
d526 1
a526 2
      activeReqSpecs_   (),
      inactiveReqSpecs_ (theProblem)
d559 1
a559 1
void WitSrpReqList::addToFront (WitSrpSeqEl * theSeqEl, double incReqVol)
d561 1
a561 1
   witAssert (incReqVol > NET_TOL);
d563 1
a563 1
   witAssert (belongsInFront (theSeqEl));
d565 1
a565 1
   myReqPairs_.push (theSeqEl, incReqVol);
d570 1
a570 1
bool WitSrpReqList::getFirst (WitSrpSeqEl * & theSeqEl, double & incReqVol)
d572 7
a578 1
   return myReqPairs_.pop (theSeqEl, incReqVol);
d605 2
d620 1
a620 1
   witAssert (myReqPairs_.isEmpty ());
a664 16
bool WitSrpReqList::belongsInFront (WitSrpSeqEl * theSeqEl)
   {
   WitSrpSeqEl * firstSeqEl;
   double        firstIncReqVol;

   if (isEmpty ())
      return true;

   myReqPairs_.pop  (firstSeqEl, firstIncReqVol);
   myReqPairs_.push (firstSeqEl, firstIncReqVol);

   return (theSeqEl->mySeqNo () <= firstSeqEl->mySeqNo ());
   }

//------------------------------------------------------------------------------

@


1.89
log
@[shared-resource pegging]
@
text
@d188 1
a188 1
      WitProbAssoc    (theProblem),
d190 4
a193 4
      myExecVolTrips_ (theExecVolTrips),
      mySeqEls_       (theProblem),
      myReqSets_      (),
      myReqList_      (NULL)
d225 1
a225 1
   myReqSets_.allocate (myProblem ());
d229 2
a230 1
         myReqSets_.myPtrAt (thePart, thePer) = new WitSrpReqSet (myProblem ());
d259 1
a259 1
      myReqSets_.myElemAt (thePart, shipPer).push (theSeqEl, incShipVol);
d286 1
a286 1
   if (myReqSets_.myElemAt (thePart, fillPer).isEmpty ())
d289 1
a289 1
   myReqList_->load (myReqSets_.myElemAt (thePart, fillPer));
d438 1
a438 1
   myReqSets_.myElemAt (consPart, consPer).push (theSeqEl, incConsVol);
d450 1
a450 1
         delete myReqSets_.myPtrAt (thePart, thePer);
d452 1
a452 1
   myReqSets_.clear ();
d541 1
a541 1
void WitSrpReqList::load (WitSrpReqSet & theReqSet)
d543 1
a543 1
   if (theReqSet.isEmpty ())
d546 1
a546 1
   formActiveReqSpecs (theReqSet);
d576 1
a576 1
void WitSrpReqList::formActiveReqSpecs (WitSrpReqSet & theReqSet)
d584 2
a585 2
   if (theReqSet.nElements () > activeReqSpecs_.capacity ())
      activeReqSpecs_.reserve (2 * theReqSet.nElements ());
d587 1
a587 1
   while (theReqSet.pop (theSeqEl, incReqVol))
@


1.88
log
@[shared-resource pegging]
@
text
@d542 4
a545 1
   myReqPairs_.takeContents (theReqSet);
d547 4
a550 1
   sort ();
d552 1
a552 1
   consolidate ();
d575 1
a575 1
void WitSrpReqList::sort ()
d581 1
a581 2
   if (myReqPairs_.nElements () > activeReqSpecs_.capacity ())
      activeReqSpecs_.reserve (2 * myReqPairs_.nElements ());
d583 4
a586 1
   while (myReqPairs_.pop (theSeqEl, incReqVol))
d597 1
d599 14
a612 4
   std::sort (
      activeReqSpecs_.begin (),
      activeReqSpecs_.end   (),
      WitSrpReqSpec::compare);
d616 1
a616 1
      theReqSpec = activeReqSpecs_.back ();
d618 5
a622 1
      activeReqSpecs_.back () = NULL;
d624 4
a627 3
      activeReqSpecs_.pop_back ();

      theReqSpec->getData (theSeqEl, incReqVol);
d629 1
a629 4
      inactiveReqSpecs_.push (theReqSpec);
      
      myReqPairs_.push (theSeqEl, incReqVol);
      }
d634 3
a636 1
void WitSrpReqList::consolidate ()
d638 1
a638 6
   WitSrpSeqEl * nextSeqEl;
   double        nextIncReqVol;
   WitSrpSeqEl * curSeqEl;
   double        curIncReqVol;

   WitPairStack <WitSrpSeqEl, double> consPairs (myProblem ());
d640 1
a640 2
   if (myReqPairs_.nElements () < 2)
      return;
d642 1
a642 1
   myReqPairs_.pop (curSeqEl, curIncReqVol);
d644 1
a644 3
   while (myReqPairs_.isNonEmpty ())
      {
      myReqPairs_.pop (nextSeqEl, nextIncReqVol);
d646 1
a646 8
      if (nextSeqEl == curSeqEl)
         nextIncReqVol += curIncReqVol;
      else
         consPairs.push (curSeqEl, curIncReqVol);

      curSeqEl     = nextSeqEl;
      curIncReqVol = nextIncReqVol;
      }
d648 1
a648 1
   consPairs.push (curSeqEl, curIncReqVol);
d650 1
a650 1
   myReqPairs_.revCopyFrom (consPairs);
@


1.87
log
@[shared-resource pegging]
@
text
@d520 1
a520 1
      WitProbAssoc  (theProblem),
d522 3
a524 2
      myReqPairs_   (theProblem),
      myReqSpecVec_ ()
a531 2
   int theIdx;

d535 1
a535 2
   for (theIdx = 0; theIdx < myReqSpecVec_.size (); theIdx ++)
      delete myReqSpecVec_[theIdx];
d571 3
a573 9
   int           nActReqSpecs;
   int           theIdx;
   WitSrpSeqEl * theSeqEl;
   double        incReqVol;

   nActReqSpecs = myReqPairs_.nElements ();

   if (nActReqSpecs > myReqSpecVec_.capacity ())
      myReqSpecVec_.reserve (2 * nActReqSpecs);
d575 2
a576 4
   while (myReqSpecVec_.size () < nActReqSpecs)
      myReqSpecVec_.push_back (new WitSrpReqSpec);

   theIdx = -1;
d580 4
a583 1
      theIdx ++;
d585 3
a587 1
      myReqSpecVec_[theIdx]->setData (theSeqEl, incReqVol);
d591 2
a592 2
      myReqSpecVec_.begin (),
      myReqSpecVec_.begin () + nActReqSpecs,
d595 1
a595 1
   for (theIdx = nActReqSpecs - 1; theIdx >= 0; -- theIdx)
d597 7
a603 1
      myReqSpecVec_[theIdx]->getData (theSeqEl, incReqVol);
d605 2
d669 2
a670 2
      myReqSpecVec_.size     (),
      myReqSpecVec_.capacity ());
@


1.86
log
@[shared-resource pegging]
@
text
@d18 1
a18 1
//    SrpReqPair
d25 1
a25 1
#include <SrpReqPair.h>
d523 1
a523 1
      myReqPairVec_ ()
d536 2
a537 2
   for (theIdx = 0; theIdx < myReqPairVec_.size (); theIdx ++)
      delete myReqPairVec_[theIdx];
d573 4
a576 5
   int             nActReqPairs;
   int             theIdx;
   WitSrpSeqEl *   theSeqEl;
   double          incReqVol;
   WitSrpReqPair * theReqPair;
d578 1
a578 1
   nActReqPairs = myReqPairs_.nElements ();
d580 2
a581 2
   if (nActReqPairs > myReqPairVec_.capacity ())
      myReqPairVec_.reserve (2 * nActReqPairs);
d583 2
a584 2
   while (myReqPairVec_.size () < nActReqPairs)
      myReqPairVec_.push_back (new WitSrpReqPair);
d592 1
a592 1
      myReqPairVec_[theIdx]->setData (theSeqEl, incReqVol);
d596 3
a598 3
      myReqPairVec_.begin (),
      myReqPairVec_.begin () + nActReqPairs,
      WitSrpReqPair::compare);
d600 1
a600 1
   for (theIdx = nActReqPairs - 1; theIdx >= 0; -- theIdx)
d602 1
a602 1
      myReqPairVec_[theIdx]->getData (theSeqEl, incReqVol);
d666 2
a667 2
      myReqPairVec_.size     (),
      myReqPairVec_.capacity ());
d671 1
a671 1
// Implementation of class SrpReqPair.
d674 1
a674 1
WitSrpReqPair::WitSrpReqPair ():
d682 1
a682 1
WitSrpReqPair::~WitSrpReqPair ()
d688 1
a688 1
void WitSrpReqPair::setData (WitSrpSeqEl * theSeqEl, double incReqVol)
d699 1
a699 1
void WitSrpReqPair::getData (WitSrpSeqEl * & theSeqEl, double & incReqVol)
d709 3
a711 3
bool WitSrpReqPair::compare (
      WitSrpReqPair * theReqPair1,
      WitSrpReqPair * theReqPair2)
d714 1
a714 1
      theReqPair1->mySeqEl_->mySeqNo ()
d716 1
a716 1
      theReqPair2->mySeqEl_->mySeqNo ();
@


1.85
log
@[shared-resource pegging]
@
text
@d598 1
a598 1
      myReqPairVec_.end   (),
@


1.84
log
@[shared-resource pegging]
@
text
@a446 3
   if (myGlobalComp ()->printSrpDB ())
      fprintf (msgFile (), "\n");

d520 2
d533 3
d581 3
d618 1
a618 1
   WitPairStack <WitSrpSeqEl, double> consPairs (myReqPairs_.myProblem ());
d660 12
@


1.83
log
@[shared-resource pegging]
@
text
@a39 1
#include <vector>
d523 2
a524 1
      myReqPairs_ (theProblem)
d532 4
d571 7
a577 4
   std::vector <WitSrpReqPair *> theReqPairVec;
   int                           theIdx;
   WitSrpSeqEl *                 theSeqEl;
   double                        incReqVol;
d579 2
a580 1
   theReqPairVec.resize (myReqPairs_.nElements ());
d588 1
a588 1
      theReqPairVec[theIdx] = new WitSrpReqPair (theSeqEl, incReqVol);
d592 2
a593 2
      theReqPairVec.begin (),
      theReqPairVec.end   (),
d596 1
a596 1
   for (theIdx = theReqPairVec.size () - 1; theIdx >= 0; -- theIdx)
d598 1
a598 1
      theReqPairVec[theIdx]->getData (theSeqEl, incReqVol);
a600 2

      delete theReqPairVec[theIdx];
a601 2

   theReqPairVec.clear ();
d658 3
a660 3
WitSrpReqPair::WitSrpReqPair (WitSrpSeqEl * theSeqEl, double incReqVol):
      mySeqEl_      (theSeqEl),
      incReqVolVal_ (incReqVol)
d672 11
d685 2
@


1.82
log
@[shared-resource pegging]
@
text
@d65 1
a65 1
   theBuilder = new WitSrpBuilder (myProblem ());
d67 1
a67 1
   theBuilder->buildPegging (myExecVolTrips_);
d185 3
a187 1
WitSrpBuilder::WitSrpBuilder (WitProblem * theProblem):
d191 1
a191 1
      myExecVolTrips_ (),
d206 1
a206 2
void WitSrpBuilder::buildPegging (
      WitPtrSched <WitDemand, WitOpnTripStack> & theExecVolTripSched)
a213 2
   transferPegging (theExecVolTripSched);

d221 2
a222 4
   WitPart *   thePart;
   WitPeriod   thePer;
   WitDemand * theDemand;
   WitPeriod   shipPer;
d226 1
a226 2
   myReqSets_     .allocate (myProblem ());
   myExecVolTrips_.allocate (myProblem ());
a230 5

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         myExecVolTrips_.myPtrAt (theDemand, shipPer) =
            new WitOpnTripStack (myProblem ());
a442 15
void WitSrpBuilder::transferPegging (
      const WitPtrSched <WitDemand, WitOpnTripStack> & theExecVolTripSched)
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         theExecVolTripSched.  myElemAt (theDemand, shipPer).
            takeContents (
               myExecVolTrips_.myElemAt (theDemand, shipPer));
   }

//------------------------------------------------------------------------------

d445 2
a446 4
   WitDemand * theDemand;
   WitPeriod   shipPer;
   WitPart *   thePart;
   WitPeriod   thePer;
a450 4
   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         delete myExecVolTrips_.myPtrAt (theDemand, shipPer);

d455 1
a455 2
   myExecVolTrips_.clear ();
   myReqSets_     .clear ();
@


1.81
log
@[shared-resource pegging]
@
text
@d52 3
a54 2
   WitDemand * theDemand;
   WitPeriod   shipPer;
d65 5
a69 1
   buildPegging ();
a181 9

void WitSrpOwner::buildPegging ()
   {
   WitSrpBuilder theBuilder (myProblem ());

   theBuilder.buildPegging (myExecVolTrips_);
   }

//------------------------------------------------------------------------------
a193 1
   myReqList_ = new WitSrpReqList (myProblem ());
a199 3
   delete myReqList_;

   deleteContents (mySeqEls_);
d227 2
d487 6
@


1.80
log
@[shared-resource pegging]
@
text
@d195 2
a196 1
      myReqLists_     ()
d198 1
d205 2
d235 1
a235 1
   myReqLists_    .allocate (myProblem ());
d240 1
a240 2
         myReqLists_.myPtrAt (thePart, thePer) = 
            new WitSrpReqList (myProblem ());
d274 1
a274 2
      myReqLists_.myPtrAt (thePart, shipPer)->
         addUnsorted (theSeqEl, incShipVol);
d298 2
a299 3
   WitSrpReqList * theReqList;
   WitSrpSeqEl *   theSeqEl;
   double          incReqVol;
d301 1
a301 3
   theReqList = myReqLists_.myPtrAt (thePart, fillPer);

   if (theReqList->isEmpty ())
d304 1
a304 1
   theReqList->sort ();
d308 1
a308 1
   if (theReqList->isEmpty ())
d313 1
a313 1
   if (theReqList->isEmpty ())
d316 1
a316 1
   theReqList->getFirst (theSeqEl, incReqVol);
d320 1
a320 1
   witAssert (theReqList->isEmpty ());
d327 5
a331 6
   WitSrpReqList * theReqList;
   double          residVol;
   double          netSuppVol;
   double          incSuppVol;
   WitSrpSeqEl *   theSeqEl;
   double          incReqVol;
d333 1
a333 3
   theReqList = myReqLists_.myPtrAt (thePart, fillPer);

   witAssert (not theReqList->isEmpty ());
d341 1
a341 1
      theReqList->getFirst (theSeqEl, incReqVol);
d349 1
a349 1
         theReqList->addToFront (theSeqEl, incReqVol);
d354 1
a354 1
      if (theReqList->isEmpty ())
d363 8
a370 11
   WitSrpReqList * theReqList;
   WitBopEntry *   theBopEnt;
   WitOperation *  theOpn;
   WitPeriod       execPer;
   double          netExecVol;
   WitSrpSeqEl *   theSeqEl;
   double          incReqVol;
   double          incExecVol;
   WitBomEntry *   theBomEnt;

   theReqList = myReqLists_.myPtrAt (thePart, fillPer);
d372 1
a372 1
   witAssert (not theReqList->isEmpty ());
d389 1
a389 1
      theReqList->getFirst (theSeqEl, incReqVol);
d397 1
a397 1
         theReqList->addToFront (theSeqEl, incReqVol);
d404 1
a404 1
      if (theReqList->isEmpty ())
d453 1
a453 2
   myReqLists_.myPtrAt (consPart, consPer)->
      addUnsorted (theSeqEl, incConsVol);
d489 1
a489 1
         delete myReqLists_.myPtrAt (thePart, thePer);
d492 1
a492 1
   myReqLists_    .clear ();
d555 1
a555 2
      myReqPairs_ (theProblem),
      sorted_     (false)
d567 1
a567 1
void WitSrpReqList::addUnsorted (WitSrpSeqEl * theSeqEl, double incReqVol)
d569 8
a576 1
   witAssert (not sorted_);
d578 2
d582 2
d589 7
a602 2
   witAssert (not sorted_);

a628 26

   consolidate ();

   sorted_ = true;
   }

//------------------------------------------------------------------------------

void WitSrpReqList::addToFront (WitSrpSeqEl * theSeqEl, double incReqVol)
   {
   witAssert (sorted_);

   witAssert (incReqVol > NET_TOL);

   witAssert (belongsInFront (theSeqEl));

   myReqPairs_.push (theSeqEl, incReqVol);
   }

//------------------------------------------------------------------------------

bool WitSrpReqList::getFirst (WitSrpSeqEl * & theSeqEl, double & incReqVol)
   {
   witAssert (sorted_);

   return myReqPairs_.pop (theSeqEl, incReqVol);
a671 2
   witAssert (sorted_);

@


1.79
log
@[shared-resource pegging]
@
text
@d18 1
d25 1
d610 1
a610 1
      compare);
d614 1
a614 2
      theSeqEl  = theReqPairVec[theIdx]->first;
      incReqVol = theReqPairVec[theIdx]->second;
a651 7
bool WitSrpReqList::compare (WitSrpReqPair * thePair1, WitSrpReqPair * thePair2)
   {
   return (thePair1->first->mySeqNo () < thePair2->first->mySeqNo ());
   }

//------------------------------------------------------------------------------

d654 1
a654 1
   WitSrpSeqEl * nextSrpSeqEl;
d656 1
a656 1
   WitSrpSeqEl * curSrpSeqEl;
d664 1
a664 1
   myReqPairs_.pop (curSrpSeqEl, curIncReqVol);
d668 1
a668 1
      myReqPairs_.pop (nextSrpSeqEl, nextIncReqVol);
d670 1
a670 1
      if (nextSrpSeqEl == curSrpSeqEl)
d673 1
a673 1
         consPairs.push (curSrpSeqEl, curIncReqVol);
d675 1
a675 1
      curSrpSeqEl  = nextSrpSeqEl;
d679 1
a679 1
   consPairs.push (curSrpSeqEl, curIncReqVol);
d703 36
@


1.78
log
@[shared-resource pegging]
@
text
@d178 1
a178 1
   WitSrpBuilder theSrpBuilder (myProblem ());
d180 1
a180 1
   theSrpBuilder.buildPegging (myExecVolTrips_);
d192 2
a193 2
      mySrpSeqEls_    (theProblem),
      mySrpReqLists_  ()
d201 1
a201 1
   deleteContents (mySrpSeqEls_);
d229 1
a229 1
   mySrpReqLists_ .allocate (myProblem ());
d234 1
a234 1
         mySrpReqLists_.myPtrAt (thePart, thePer) = 
d250 1
a250 1
   WitSrpSeqEl *   theSrpSeqEl;
d263 1
a263 1
      theSrpSeqEl = new WitSrpSeqEl (theDemand, shipPer, theSeqNo);
d265 1
a265 1
      mySrpSeqEls_.push (theSrpSeqEl);
d269 2
a270 2
      mySrpReqLists_.myPtrAt (thePart, shipPer)->
         addUnsorted (theSrpSeqEl, incShipVol);
d294 2
a295 2
   WitSrpReqList * theSrpReqList;
   WitSrpSeqEl *   theSrpSeqEl;
d298 1
a298 1
   theSrpReqList = mySrpReqLists_.myPtrAt (thePart, fillPer);
d300 1
a300 1
   if (theSrpReqList->isEmpty ())
d303 1
a303 1
   theSrpReqList->sort ();
d307 1
a307 1
   if (theSrpReqList->isEmpty ())
d312 1
a312 1
   if (theSrpReqList->isEmpty ())
d315 1
a315 1
   theSrpReqList->getFirst (theSrpSeqEl, incReqVol);
d319 1
a319 1
   witAssert (theSrpReqList->isEmpty ());
d326 1
a326 1
   WitSrpReqList * theSrpReqList;
d330 1
a330 1
   WitSrpSeqEl *   theSrpSeqEl;
d333 1
a333 1
   theSrpReqList = mySrpReqLists_.myPtrAt (thePart, fillPer);
d335 1
a335 1
   witAssert (not theSrpReqList->isEmpty ());
d343 1
a343 1
      theSrpReqList->getFirst (theSrpSeqEl, incReqVol);
d351 1
a351 1
         theSrpReqList->addToFront (theSrpSeqEl, incReqVol);
d354 1
a354 1
         prtNetToSupply (thePart, fillPer, incSuppVol, theSrpSeqEl);
d356 1
a356 1
      if (theSrpReqList->isEmpty ())
d365 1
a365 1
   WitSrpReqList * theSrpReqList;
d370 1
a370 1
   WitSrpSeqEl *   theSrpSeqEl;
d375 1
a375 1
   theSrpReqList = mySrpReqLists_.myPtrAt (thePart, fillPer);
d377 1
a377 1
   witAssert (not theSrpReqList->isEmpty ());
d394 1
a394 1
      theSrpReqList->getFirst (theSrpSeqEl, incReqVol);
d402 1
a402 1
         theSrpReqList->addToFront (theSrpSeqEl, incReqVol);
d404 1
a404 1
      pegExecVol (theOpn, execPer, incExecVol, theSrpSeqEl);
d407 1
a407 1
         explodeBomEntry (theBomEnt, execPer, incExecVol, theSrpSeqEl);
d409 1
a409 1
      if (theSrpReqList->isEmpty ())
d420 1
a420 1
      WitSrpSeqEl *  theSrpSeqEl)
d427 2
a428 2
   theDemand   = theSrpSeqEl->myDemand  ();
   shipPer     = theSrpSeqEl->myShipPer ();
d435 1
a435 1
      prtExpToProd (theOpn, execPer, incExecVol, theSrpSeqEl);
d444 1
a444 1
      WitSrpSeqEl * theSrpSeqEl)
d458 2
a459 2
   mySrpReqLists_.myPtrAt (consPart, consPer)->
      addUnsorted (theSrpSeqEl, incConsVol);
d495 1
a495 1
         delete mySrpReqLists_.myPtrAt (thePart, thePer);
d498 1
a498 1
   mySrpReqLists_ .clear ();
d507 1
a507 1
      WitSrpSeqEl * theSrpSeqEl)
d523 3
a525 3
      theSrpSeqEl->myDemand ()->demandName ().myCstring (),
      theSrpSeqEl->myShipPer (),
      theSrpSeqEl->mySeqNo ());
d534 1
a534 1
      WitSrpSeqEl *  theSrpSeqEl)
d550 3
a552 3
      theSrpSeqEl->myDemand ()->demandName ().myCstring (),
      theSrpSeqEl->myShipPer (),
      theSrpSeqEl->mySeqNo ());
d574 1
a574 1
void WitSrpReqList::addUnsorted (WitSrpSeqEl * theSrpSeqEl, double incReqVol)
d580 1
a580 1
   myReqPairs_.push (theSrpSeqEl, incReqVol);
d589 1
a589 1
   WitSrpSeqEl *                 theSrpSeqEl;
d598 1
a598 1
   while (myReqPairs_.pop (theSrpSeqEl, incReqVol))
d602 1
a602 1
      theReqPairVec[theIdx] = new WitSrpReqPair (theSrpSeqEl, incReqVol);
d612 2
a613 2
      theSrpSeqEl = theReqPairVec[theIdx]->first;
      incReqVol   = theReqPairVec[theIdx]->second;
d615 1
a615 1
      myReqPairs_.push (theSrpSeqEl, incReqVol);
d629 1
a629 1
void WitSrpReqList::addToFront (WitSrpSeqEl * theSrpSeqEl, double incReqVol)
d635 1
a635 1
   witAssert (belongsInFront (theSrpSeqEl));
d637 1
a637 1
   myReqPairs_.push (theSrpSeqEl, incReqVol);
d642 1
a642 1
bool WitSrpReqList::getFirst (WitSrpSeqEl * & theSrpSeqEl, double & incReqVol)
d646 1
a646 1
   return myReqPairs_.pop (theSrpSeqEl, incReqVol);
d692 1
a692 1
bool WitSrpReqList::belongsInFront (WitSrpSeqEl * theSrpSeqEl)
d694 1
a694 1
   WitSrpSeqEl * firstSrpSeqEl;
d702 2
a703 2
   myReqPairs_.pop  (firstSrpSeqEl, firstIncReqVol);
   myReqPairs_.push (firstSrpSeqEl, firstIncReqVol);
d705 1
a705 1
   return (theSrpSeqEl->mySeqNo () <= firstSrpSeqEl->mySeqNo ());
@


1.77
log
@[shared-resource pegging]
@
text
@d38 1
d587 4
a590 5
   int               nPairs;
   WitSrpReqPair * * theReqPairCvec;
   int               theIdx;
   WitSrpSeqEl *     theSrpSeqEl;
   double            incReqVol;
d594 1
a594 1
   nPairs         = myReqPairs_.nElements ();
d596 1
a596 3
   theReqPairCvec = new WitSrpReqPair * [nPairs];

   theIdx         = -1;
d602 1
a602 1
      theReqPairCvec[theIdx] = new WitSrpReqPair (theSrpSeqEl, incReqVol);
d605 4
a608 1
   std::sort (theReqPairCvec, theReqPairCvec + nPairs, compare);
d610 1
a610 1
   for (theIdx = nPairs - 1; theIdx >= 0; -- theIdx)
d612 2
a613 2
      theSrpSeqEl = theReqPairCvec[theIdx]->first;
      incReqVol   = theReqPairCvec[theIdx]->second;
d617 1
a617 1
      delete theReqPairCvec[theIdx];
d620 1
a620 3
   delete theReqPairCvec;

   theReqPairCvec = NULL;
@


1.76
log
@[shared-resource pegging]
@
text
@d38 2
d586 7
a592 4
   WitSrpSeqEl * theSrpSeqEl;
   double        incReqVol;
   WitSrpSeqEl * highSrpSeqEl;
   double        highReqVol;
d594 1
a594 2
   WitPairStack <WitSrpSeqEl, double> fromPairs (myReqPairs_.myProblem ());
   WitPairStack <WitSrpSeqEl, double> toPairs   (myReqPairs_.myProblem ());
d596 1
a596 1
   witAssert (not sorted_);
d598 1
a598 1
   fromPairs.takeContents (myReqPairs_);
d600 1
a600 1
   while (fromPairs.isNonEmpty ())
d602 1
a602 1
      highSrpSeqEl = NULL;
d604 4
a607 17
      while (fromPairs.pop (theSrpSeqEl, incReqVol))
         {
         if (highSrpSeqEl == NULL)
            {
            highSrpSeqEl = theSrpSeqEl;
            highReqVol   = incReqVol;
            }
         else if (theSrpSeqEl->mySeqNo () > highSrpSeqEl->mySeqNo ())
            {
            toPairs.push (highSrpSeqEl, highReqVol);

            highSrpSeqEl = theSrpSeqEl;
            highReqVol   = incReqVol;
            }
         else
            toPairs.push (theSrpSeqEl, incReqVol);
         }
d609 4
a612 1
      myReqPairs_.push (highSrpSeqEl, highReqVol);
d614 1
a614 1
      toPairs.reverse ();
d616 1
a616 1
      fromPairs.takeContents (toPairs);
d619 4
d652 7
@


1.75
log
@[shared-resource pegging]
@
text
@d17 1
d23 1
a23 1
#include <SrpReqSpec.h>
d190 1
a190 1
      myReqSpecs_     ()
d226 1
a226 1
   myReqSpecs_    .allocate (myProblem ());
d231 2
a232 2
         myReqSpecs_.myPtrAt (thePart, thePer) = 
            new WitSrpReqSpec (myProblem ());
d266 1
a266 1
      myReqSpecs_.myPtrAt (thePart, shipPer)->
d291 1
a291 1
   WitSrpReqSpec * theReqSpec;
d295 1
a295 1
   theReqSpec = myReqSpecs_.myPtrAt (thePart, fillPer);
d297 1
a297 1
   if (theReqSpec->isEmpty ())
d300 1
a300 1
   theReqSpec->sort ();
d304 1
a304 1
   if (theReqSpec->isEmpty ())
d309 1
a309 1
   if (theReqSpec->isEmpty ())
d312 1
a312 1
   theReqSpec->getFirst (theSrpSeqEl, incReqVol);
d316 1
a316 1
   witAssert (theReqSpec->isEmpty ());
d323 1
a323 1
   WitSrpReqSpec * theReqSpec;
d330 1
a330 1
   theReqSpec = myReqSpecs_.myPtrAt (thePart, fillPer);
d332 1
a332 1
   witAssert (not theReqSpec->isEmpty ());
d340 1
a340 1
      theReqSpec->getFirst (theSrpSeqEl, incReqVol);
d348 1
a348 1
         theReqSpec->addToFront (theSrpSeqEl, incReqVol);
d353 1
a353 1
      if (theReqSpec->isEmpty ())
d362 1
a362 1
   WitSrpReqSpec * theReqSpec;
d372 1
a372 1
   theReqSpec = myReqSpecs_.myPtrAt (thePart, fillPer);
d374 1
a374 1
   witAssert (not theReqSpec->isEmpty ());
d391 1
a391 1
      theReqSpec->getFirst (theSrpSeqEl, incReqVol);
d399 1
a399 1
         theReqSpec->addToFront (theSrpSeqEl, incReqVol);
d406 1
a406 1
      if (theReqSpec->isEmpty ())
d455 1
a455 1
   myReqSpecs_.myPtrAt (consPart, consPer)->
d492 1
a492 1
         delete myReqSpecs_.myPtrAt (thePart, thePer);
d495 1
a495 1
   myReqSpecs_    .clear ();
d553 1
a553 1
// Implementation of class SrpReqSpec.
d556 1
a556 1
WitSrpReqSpec::WitSrpReqSpec (WitProblem * theProblem):
d565 1
a565 1
WitSrpReqSpec::~WitSrpReqSpec ()
d571 1
a571 1
void WitSrpReqSpec::addUnsorted (WitSrpSeqEl * theSrpSeqEl, double incReqVol)
d582 1
a582 1
void WitSrpReqSpec::sort ()
d632 1
a632 1
void WitSrpReqSpec::addToFront (WitSrpSeqEl * theSrpSeqEl, double incReqVol)
d645 1
a645 1
bool WitSrpReqSpec::getFirst (WitSrpSeqEl * & theSrpSeqEl, double & incReqVol)
d654 1
a654 1
void WitSrpReqSpec::consolidate ()
d688 1
a688 1
bool WitSrpReqSpec::belongsInFront (WitSrpSeqEl * theSrpSeqEl)
@


1.74
log
@[shared-resource pegging]
@
text
@d624 2
d653 34
@


1.73
log
@[shared-resource pegging]
@
text
@a132 5
      {
      if (theOpn->bom ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an operation with multiple BOM entries.");

a135 1
      }
d402 1
a402 4
      if (not theOpn->bom ().isEmpty ())
         {
         theBomEnt = theOpn->bom ().first ();

a403 1
         }
@


1.72
log
@[shared-resource pegging]
@
text
@a126 4
      if (thePart->consumingBomEntries ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains a part consumed by > 1 BOM entry.");

a129 6

      if (thePart->consumingBomEntries ().nElements () >= 1)
         if (thePart->myDemands ().nElements () >= 1)
            myMsgFac () ("srpCaseNyiSmsg",
               "The problem contains a part that is consumed by a BOM entry "
               "and also has a demand.");
@


1.71
log
@[shared-resource pegging]
@
text
@d655 2
d670 18
@


1.70
log
@[shared-resource pegging]
@
text
@a126 4
      if (thePart->myDemands ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains a part with > 1 demand.");

d341 1
a341 1
   double          incConsSuppVol;
d357 1
a357 1
      incConsSuppVol = min (incReqVol, netSuppVol);
d359 2
a360 2
      incReqVol     -= incConsSuppVol;
      netSuppVol    -= incConsSuppVol;
d365 3
d449 3
d502 3
d518 54
@


1.69
log
@[shared-resource pegging]
@
text
@d285 1
a285 3
      stronglyAssert (myReqSpecs_.myElemAt (thePart, shipPer).isEmpty ());

      myReqSpecs_.myElemAt (thePart, shipPer).
d310 5
a314 2
   WitSrpSeqEl * theSrpSeqEl;
   double        incReqVol;
d316 1
a316 1
   if (myReqSpecs_.myElemAt (thePart, fillPer).isEmpty ())
d319 1
a319 1
   myReqSpecs_.myElemAt (thePart, fillPer).sort ();
d323 1
a323 1
   if (myReqSpecs_.myElemAt (thePart, fillPer).isEmpty ())
d328 1
a328 1
   if (myReqSpecs_.myElemAt (thePart, fillPer).isEmpty ())
d331 1
a331 1
   myReqSpecs_.myElemAt (thePart, fillPer).getFirst (theSrpSeqEl, incReqVol);
d335 1
a335 1
   witAssert (myReqSpecs_.myElemAt (thePart, fillPer).isEmpty ());
d342 8
a349 5
   double        residVol;
   double        consSuppVol;
   double        incConsSuppVol;
   WitSrpSeqEl * theSrpSeqEl;
   double        incReqVol;
d351 1
a351 1
   witAssert (myReqSpecs_.myElemAt (thePart, fillPer).isNonEmpty ());
d353 1
a353 1
   residVol    = positivePart (thePart->residualVol ()[fillPer]);
d355 1
a355 1
   consSuppVol = positivePart (thePart->supplyVol ()[fillPer] - residVol);
d357 3
a359 2
   if (consSuppVol <= NET_TOL)
      return;
d361 1
a361 1
   myReqSpecs_.myElemAt (thePart, fillPer).getFirst (theSrpSeqEl, incReqVol);
d363 2
a364 1
   incConsSuppVol = min (incReqVol, consSuppVol);
d366 2
a367 1
   incReqVol     -= incConsSuppVol;
d369 3
a371 3
   if (incReqVol > NET_TOL)
      myReqSpecs_.myElemAt (thePart, fillPer).
         addToFront (theSrpSeqEl, incReqVol);
d378 11
a388 9
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitPeriod      execPer;
   WitSrpSeqEl *  theSrpSeqEl;
   double         incReqVol;
   double         incExecVol;
   WitDemand *    theDemand;
   WitPeriod      shipPer;
   WitBomEntry *  theBomEnt;
d390 1
a390 1
   witAssert (myReqSpecs_.myElemAt (thePart, fillPer).isNonEmpty ());
d399 5
a403 1
   theOpn    = theBopEnt->myOperation ();
d405 5
a409 1
   execPer   = fillPer;
d411 5
a415 2
   if (theOpn->execVol ()[execPer] <= NET_TOL)
      return;
d417 1
a417 1
   myReqSpecs_.myElemAt (thePart, fillPer).getFirst (theSrpSeqEl, incReqVol);
d419 3
a421 1
   incExecVol = min (incReqVol, theOpn->execVol ()[execPer]);
d423 2
a424 2
   theDemand  = theSrpSeqEl->myDemand  ();
   shipPer    = theSrpSeqEl->myShipPer ();
d426 4
a429 3
   myExecVolTrips_.
      myElemAt (theDemand, shipPer).
         push (theOpn, execPer, incExecVol);
d431 1
a431 1
   incReqVol -= incExecVol;
d433 8
a440 3
   if (incReqVol > NET_TOL)
      myReqSpecs_.myElemAt (thePart, fillPer).
         addToFront (theSrpSeqEl, incReqVol);
d442 1
a442 2
   if (theOpn->bom ().isEmpty ())
      return;
d444 2
a445 1
   theBomEnt = theOpn->bom ().first ();
d447 3
a449 1
   explodeBomEntry (theBomEnt, execPer, incExecVol, theSrpSeqEl);
d472 1
a472 3
   stronglyAssert (myReqSpecs_.myElemAt (consPart, consPer).isEmpty ());

   myReqSpecs_.myElemAt (consPart, consPer).
@


1.68
log
@[shared-resource pegging]
@
text
@d287 2
a288 1
      myReqSpecs_.myElemAt (thePart, shipPer).add (theSrpSeqEl, incShipVol);
d318 2
d330 1
a330 1
   myReqSpecs_.myElemAt (thePart, fillPer).get (theSrpSeqEl, incReqVol);
d356 1
a356 1
   myReqSpecs_.myElemAt (thePart, fillPer).get (theSrpSeqEl, incReqVol);
d363 2
a364 1
      myReqSpecs_.myElemAt (thePart, fillPer).add (theSrpSeqEl, incReqVol);
d397 1
a397 1
   myReqSpecs_.myElemAt (thePart, fillPer).get (theSrpSeqEl, incReqVol);
d411 2
a412 1
      myReqSpecs_.myElemAt (thePart, fillPer).add (theSrpSeqEl, incReqVol);
d444 2
a445 1
   myReqSpecs_.myElemAt (consPart, consPer).add (theSrpSeqEl, incConsVol);
d490 2
a491 1
      myReqPairs_ (theProblem)
d503 1
a503 1
void WitSrpReqSpec::add (WitSrpSeqEl * theSrpSeqEl, double incReqVol)
d505 2
d514 1
a514 1
bool WitSrpReqSpec::get (WitSrpSeqEl * & theSrpSeqEl, double & incReqVol)
d516 61
@


1.67
log
@[shared-resource pegging]
@
text
@d22 1
d287 1
a287 1
      myReqSpecs_.myElemAt (thePart, shipPer).push (theSrpSeqEl, incShipVol);
d327 1
a327 1
   myReqSpecs_.myElemAt (thePart, fillPer).pop (theSrpSeqEl, incReqVol);
d353 1
a353 1
   myReqSpecs_.myElemAt (thePart, fillPer).pop  (theSrpSeqEl, incReqVol);
d360 1
a360 1
      myReqSpecs_.myElemAt (thePart, fillPer).push (theSrpSeqEl, incReqVol);
d393 1
a393 1
   myReqSpecs_.myElemAt (thePart, fillPer).pop  (theSrpSeqEl, incReqVol);
d407 1
a407 1
      myReqSpecs_.myElemAt (thePart, fillPer).push (theSrpSeqEl, incReqVol);
d439 1
a439 1
   myReqSpecs_.myElemAt (consPart, consPer).push (theSrpSeqEl, incConsVol);
d479 32
@


1.66
log
@[shared-resource pegging]
@
text
@d208 1
a208 4
      myReqSpecs_     (),
      myReqVol_       (),
      reqDemand_      (),
      reqShipPer_     ()
a244 3
   myReqVol_      .allocate (myProblem (), 0.0);
   reqDemand_     .allocate (myProblem ());
   reqShipPer_    .allocate (myProblem (), -1);
d284 1
a284 1
      stronglyAssert (reqDemand_.myPtrAt (thePart, shipPer) == NULL);
d286 1
a286 4
      myReqVol_          (thePart)[shipPer] += incShipVol;

      reqDemand_.myPtrAt (thePart, shipPer)  = theDemand;
      reqShipPer_        (thePart)[shipPer]  = shipPer;
d310 4
a313 1
   if (myReqVol_ (thePart)[fillPer] <= NET_TOL)
d318 1
a318 1
   if (myReqVol_ (thePart)[fillPer] <= NET_TOL)
d323 1
a323 1
   if (myReqVol_ (thePart)[fillPer] <= NET_TOL)
d326 5
a330 1
   witAssert (myReqVol_ (thePart)[fillPer] <= 2 * FEAS_TOL);
d337 5
a341 3
   double residVol;
   double consSuppVol;
   double incConsSuppVol;
d343 1
a343 1
   witAssert (myReqVol_ (thePart)[fillPer] > NET_TOL);
d345 1
a345 1
   residVol       = positivePart (thePart->residualVol ()[fillPer]);
d347 1
a347 1
   consSuppVol    = positivePart (thePart->supplyVol ()[fillPer] - residVol);
d352 3
a354 1
   incConsSuppVol = min (myReqVol_ (thePart)[fillPer], consSuppVol);
d356 4
a359 1
   myReqVol_ (thePart)[fillPer] -= incConsSuppVol;
d369 2
d376 1
a376 1
   witAssert (myReqVol_ (thePart)[fillPer] > NET_TOL);
d392 3
a394 4
   incExecVol =
      min (
         myReqVol_ (thePart)[fillPer],
         theOpn->execVol ()[execPer]);
d396 2
a397 2
   theDemand = reqDemand_.myPtrAt (thePart, fillPer);
   shipPer   = reqShipPer_        (thePart)[fillPer];
d403 4
a406 1
   myReqVol_ (thePart)[fillPer] -= incExecVol;
d413 1
a413 1
   explodeBomEntry (theBomEnt, execPer, incExecVol, theDemand, shipPer);
d422 1
a422 2
      WitDemand *   theDemand,
      WitPeriod     shipPer)
d428 2
d436 1
a436 1
   stronglyAssert (reqDemand_.myPtrAt (consPart, consPer) == NULL);
d438 1
a438 3
   myReqVol_          (consPart)[consPer] += incConsVol;
   reqDemand_.myPtrAt (consPart, consPer)  = theDemand;
   reqShipPer_        (consPart)[consPer]  = shipPer;
a473 3
   reqShipPer_    .clear ();
   reqDemand_     .clear ();
   myReqVol_      .clear ();
@


1.65
log
@[shared-resource pegging]
@
text
@d25 1
d137 6
d208 1
d242 2
d247 5
a251 3
   myReqVol_  .allocate (myProblem (), 0.0);
   reqDemand_ .allocate (myProblem ());
   reqShipPer_.allocate (myProblem (), -1);
d253 4
a256 1
   myExecVolTrips_.allocate (myProblem ());
d454 2
d461 4
d466 4
a469 4

   reqShipPer_.clear ();
   reqDemand_ .clear ();
   myReqVol_  .clear ();
@


1.64
log
@[shared-resource pegging]
@
text
@d39 1
a39 1
WitSrpOwner::WitSrpOwner (WitPipSeqMgr * theSeqMgr):
d41 1
a41 1
      WitPipOwner     (theSeqMgr),
@


1.63
log
@[shared-resource pegging]
@
text
@d41 1
a41 1
      WitPipCoord     (theSeqMgr),
@


1.62
log
@[shared-resource pegging]
@
text
@d15 1
a15 1
//    SrpCoord
d20 1
a20 1
#include <SrpCoord.h>
d36 1
a36 1
// Implementation of class SrpCoord.
d39 1
a39 1
WitSrpCoord::WitSrpCoord (WitPipSeqMgr * theSeqMgr):
d61 1
a61 1
WitSrpCoord::~WitSrpCoord ()
d73 1
a73 1
void WitSrpCoord::getExecVolTrips (
d83 1
a83 1
void WitSrpCoord::getSubVolTrips (
d93 1
a93 1
void WitSrpCoord::getPartPegTrips (
d104 1
a104 1
void WitSrpCoord::checkRestrictions ()
d184 1
a184 1
void WitSrpCoord::buildPegging ()
@


1.61
log
@[shared-resource pegging]
@
text
@d16 1
a16 1
//    SrpBldr
d21 1
a21 1
#include <SrpBldr.h>
d186 1
a186 1
   WitSrpBldr theSrpBldr (myProblem ());
d188 1
a188 1
   theSrpBldr.buildPegging (myExecVolTrips_);
d192 1
a192 1
// Implementation of class SrpBldr.
d195 1
a195 1
WitSrpBldr::WitSrpBldr (WitProblem * theProblem):
d209 1
a209 1
WitSrpBldr::~WitSrpBldr ()
d216 1
a216 1
void WitSrpBldr::buildPegging (
d232 1
a232 1
void WitSrpBldr::setUpBuild ()
d251 1
a251 1
void WitSrpBldr::placeShipmentReqs ()
d286 1
a286 1
void WitSrpBldr::explodeAllReqs ()
d302 1
a302 1
void WitSrpBldr::fillReqs (WitPart * thePart, WitPeriod fillPer)
d322 1
a322 1
void WitSrpBldr::netAgainstSupply (WitPart * thePart, WitPeriod fillPer)
d344 1
a344 1
void WitSrpBldr::explodeToProd (WitPart * thePart, WitPeriod fillPer)
d394 1
a394 1
void WitSrpBldr::explodeBomEntry (
d420 1
a420 1
void WitSrpBldr::transferPegging (
d435 1
a435 1
void WitSrpBldr::shutDownBuild ()
@


1.60
log
@[shared-resource pegging]
@
text
@d17 1
d22 1
d200 1
d211 1
d254 1
d256 1
d263 2
d267 9
a275 1
      thePart = theDemand->demandedPart ();
d411 2
d450 21
@


1.59
log
@[shared-resource pegging]
@
text
@a76 2

   execVolTrips.reverse ();
d195 1
a195 1
      WitProbAssoc     (theProblem),
d197 4
a200 4
      revExecVolTrips_ (),
      myReqVol_        (),
      reqDemand_       (),
      reqShipPer_      ()
d237 1
a237 1
   revExecVolTrips_.allocate (myProblem ());
d241 1
a241 1
         revExecVolTrips_.myPtrAt (theDemand, shipPer) =
d362 1
a362 1
   revExecVolTrips_.
d405 2
a406 3
   WitOpnTripStack theTrips (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
d410 3
a412 9
         {
         theTrips.takeContents (
            revExecVolTrips_.myElemAt (theDemand, shipPer));

         theTrips.reverse ();

         theExecVolTripSched.myElemAt (theDemand, shipPer).
            takeContents (theTrips);
         }
d424 1
a424 1
         delete revExecVolTrips_.myPtrAt (theDemand, shipPer);
d426 1
a426 1
   revExecVolTrips_.clear ();
@


1.58
log
@[shared-resource pegging]
@
text
@d405 1
a405 1
      WitPtrSched <WitDemand, WitOpnTripStack> & theExecVolTripSched)
@


1.57
log
@[shared-resource pegging]
@
text
@d21 1
a21 1
#include <PipSeqMgr.h>
d23 1
d77 2
a103 14
void WitSrpCoord::pegExecVol (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         incExecVol,
      WitDemand *    theDemand,
      WitPeriod      shipPer)
   {
   myExecVolTrips_.
      myElemAt (theDemand, shipPer).
         push (theOpn, execPer, incExecVol);
   }

//------------------------------------------------------------------------------

d186 1
a186 1
   WitSrpBldr theSrpBldr (this);
d188 1
a188 1
   theSrpBldr.buildPegging ();
d195 1
a195 1
WitSrpBldr::WitSrpBldr (WitSrpCoord * theSrpCoord):
d197 1
a197 1
      WitProbAssoc (theSrpCoord->myProblem ()),
d199 4
a202 4
      mySrpCoord_  (theSrpCoord),
      myReqVol_    (),
      reqDemand_   (),
      reqShipPer_  ()
d214 2
a215 1
void WitSrpBldr::buildPegging ()
d223 2
d232 3
a237 1
   }
d239 1
a239 1
//------------------------------------------------------------------------------
d241 4
a244 5
void WitSrpBldr::shutDownBuild ()
   {
   myReqVol_  .clear ();
   reqDemand_ .clear ();
   reqShipPer_.clear ();
d257 1
a257 1
   mySrpCoord_->myPipSeqMgr ()->get (theShipSeq);
d364 3
a366 6
   mySrpCoord_->pegExecVol (
      theOpn,
      execPer,
      incExecVol,
      theDemand,
      shipPer);
d401 40
@


1.56
log
@[shared-resource pegging]
@
text
@a75 2

   execVolTrips.reverse ();
d117 5
a121 6
   WitPart *       thePart;
   WitOperation *  theOpn;
   WitBopEntry *   theBopEnt;
   WitBomEntry *   theBomEnt;
   WitPeriod       thePer;
   WitDemTripStack theShipSeq (myProblem ());
a190 10

#if 0

   myPipSeqMgr ()->get (theShipSeq);

   if (theShipSeq.nElements () != 1)
      myMsgFac () ("srpCaseNyiSmsg",
         "The number of elements in the shipment sequence is not 1.");

#endif
@


1.55
log
@[shared-resource pegging]
@
text
@a21 1
#include <ReqSched.h>
a125 2
// myMsgFac () ("srpCaseNyiSmsg", "Any case.");

d195 2
d202 2
d224 3
a226 1
      myReqSched_  (NULL)
a227 1
   myReqSched_ = new WitReqSched (myProblem ());
a233 1
   delete myReqSched_;
d240 2
d245 20
d275 1
d279 3
a281 1
   stronglyAssert (theShipSeq.isNonEmpty ());
d283 1
a283 1
   theShipSeq.pop (theDemand, shipPer, incShipVol);
d285 3
a287 3
   stronglyAssert (theShipSeq.isEmpty ());

   myReqSched_->addTo (theDemand->demandedPart (), shipPer, incShipVol);
d310 1
a310 5
   double netReqVol;

   netReqVol = myReqSched_->reqVol (thePart, fillPer);

   if (netReqVol <= NET_TOL)
d313 1
a313 1
   netAgainstSupply (thePart, fillPer, netReqVol);
d315 1
a315 1
   if (netReqVol <= NET_TOL)
d318 1
a318 1
   explodeToProd (thePart, fillPer, netReqVol);
d320 1
a320 1
   if (netReqVol <= NET_TOL)
d323 1
a323 1
   witAssert (netReqVol <= 2 * FEAS_TOL);
d328 1
a328 4
void WitSrpBldr::netAgainstSupply (
      WitPart * thePart,
      WitPeriod fillPer,
      double &  netReqVol)
d334 1
a334 1
   witAssert (netReqVol > NET_TOL);
d343 1
a343 1
   incConsSuppVol = min (netReqVol, consSuppVol);
d345 1
a345 1
   netReqVol     -= incConsSuppVol;
d350 1
a350 4
void WitSrpBldr::explodeToProd (
      WitPart * thePart,
      WitPeriod fillPer,
      double &  netReqVol)
d356 2
d360 1
a360 1
   witAssert (netReqVol > NET_TOL);
d376 4
a379 29
   incExecVol = min (netReqVol, theOpn->execVol ()[execPer]);

   pegExecVol (theOpn, execPer, incExecVol);

   netReqVol -= incExecVol;

   if (theOpn->bom ().isEmpty ())
      return;

   theBomEnt  = theOpn->bom ().first ();

   explodeBomEntry (theBomEnt, execPer, incExecVol);
   }

//------------------------------------------------------------------------------

void WitSrpBldr::pegExecVol (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         incExecVol)
   {
   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   mySrpCoord_->myPipSeqMgr ()->get (theShipSeq);

   stronglyAssert (theShipSeq.isNonEmpty ());
d381 2
a382 1
   theShipSeq.pop (theDemand, shipPer, incShipVol);
d390 9
d406 3
a408 1
      double        incExecVol)
d420 3
a422 1
   myReqSched_->addTo (consPart, consPer, incConsVol);
@


1.54
log
@[shared-resource pegging]
@
text
@d104 14
d127 1
a127 1
   myMsgFac () ("srpCaseNyiSmsg", "Any case.");
d292 10
d311 3
a313 2
   double resVol;
   double netSuppVol;
d317 95
a411 1
   resVol     = positivePart (thePart->residualVol ()[fillPer]);
d413 1
a413 1
   netSuppVol = positivePart (thePart->supplyVol ()[fillPer] - resVol);
d415 1
a415 1
   net (netReqVol, netSuppVol);
@


1.53
log
@[shared-resource pegging]
@
text
@d16 1
d20 11
d39 2
a40 1
      WitPipCoord (theSeqMgr)
d42 3
d46 9
d61 6
d76 3
a78 1
   stronglyAssert (false);
d104 149
a252 1
void WitSrpCoord::printInternal ()
d254 24
d282 4
a285 1
void WitSrpCoord::checkRestrictions ()
d287 8
a294 2
   if (not myProblem ()->postprocessed ())
      myMsgFac () ("unpostPipSmsg");
d296 1
a296 1
   myMsgFac () ("srpCaseNyiSmsg", "Any case.");
@


1.52
log
@[shared-resource pegging]
@
text
@d13 1
a13 1
// Contains the implementation of the following classes and templates:
a15 1
//    SrpPegger
a18 13
#include <SrpExpSpec.h>
#include <SrpExpSync.h>
#include <SrpPegger.h>
#include <PipSeqMgr.h>
#include <Part.h>
#include <Opn.h>
#include <Demand.h>
#include <BopEntry.h>
#include <BomEntry.h>
#include <Global.h>
#include <PairStack.h>
#include <DblDblStack.h>
#include <Schedule.h>
d27 1
a27 4
      WitPipCoord   (theSeqMgr),

      mySrpExpSync_ (NULL),
      mySrpPegger_  (NULL)
a29 4

   mySrpExpSync_ = new WitSrpExpSync (myPipSeqMgr ());

   mySrpPegger_  = new WitSrpPegger  (mySrpExpSync_);
a35 2
   delete mySrpPegger_;
   delete mySrpExpSync_;
d45 1
a45 1
   mySrpPegger_->getExecVolTrips (theDemand, shipPer, execVolTrips);
a72 3
   mySrpPegger_ ->printExpSpec ();

   mySrpExpSync_->print ();
a78 8
   WitOperation * theOpn;
   WitPart *      thePart;
   WitBopEntry *  theBopEnt;
   WitBomEntry *  theBomEnt;
   WitPeriod      thePer;
   bool           multiBomEnts;
   bool           multiBopEnts;

d82 1
a82 327
   if (not myGlobalComp ()->feasible ())
      myMsgFac () ("srpCaseNyiSmsg",
         "The solution is infeasible.");

   forEachPart (thePart, myProblem ())
      {
      if (thePart->thisMat () != NULL)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains at least one material part.");

      if (thePart->producingBopEntries ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains a part produced by > 1 BOP entry.");
      }

   forEachBopEntry (theBopEnt, myProblem ())
      {
      if (theBopEnt->effProdRate () != 1.0)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an effective prodRate != 1.");

      forEachPeriod (thePer, myProblem ())
         if (theBopEnt->impactPeriod ()[thePer] != thePer)
            myMsgFac () ("srpCaseNyiSmsg",
               "The problem contains an impact period != the period.");

      if (not theBopEnt->expAllowed ())
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an unexplodeable BOP entry.");
      }

   forEachBomEntry (theBomEnt, myProblem ())
      {
      if (theBomEnt->effConsRate () != 1.0)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an effective cons rate != 1.");

      if (not theBomEnt->mySubEntries ().isEmpty ())
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains at least one substitute.");

      forEachPeriod (thePer, myProblem ())
         if (theBomEnt->impactPeriod ()[thePer] != thePer)
            myMsgFac () ("srpCaseNyiSmsg",
               "The problem contains an impact period != the period.");
      }

   multiBomEnts = false;
   multiBopEnts = false;

   forEachOperation (theOpn, myProblem ())
      {
      if (theOpn->bom ().nElements () > 1)
         multiBomEnts = true;

      if (theOpn->bop ().nElements () > 1)
         multiBopEnts = true;
      }

   if (multiBomEnts)
      if (multiBopEnts)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an operation with multiple BOM entries "
            "and an operation with multiple BOP entries.");

   checkFullShipSeq ();
   }

//------------------------------------------------------------------------------

void WitSrpCoord::checkFullShipSeq ()
   {
   WitSchedule <WitDemand, double> shipVolInSeq;

   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   shipVolInSeq.allocate (myProblem (), 0.0);

   myPipSeqMgr ()->get (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      shipVolInSeq (theDemand)[shipPer] += incShipVol;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         if (
               shipVolInSeq (theDemand)[shipPer]
               <=
               theDemand->shipVol ()[shipPer] - .001)
            {
            myMsgFac () ("srpCaseNyiSmsg",
               "The shipment sequence not a full shipment sequence.");
            }
   }

//------------------------------------------------------------------------------
// Implementation of class SrpPegger.
//------------------------------------------------------------------------------

WitSrpPegger::WitSrpPegger (WitSrpExpSync * theSrpExpSync):

      WitProbAssoc    (theSrpExpSync->myProblem ()),

      mySrpExpSpec_   (NULL),
      mySrpExpSync_   (theSrpExpSync),
      myReqPairs_     (myProblem ()),
      myExecVolTrips_ (myProblem ()),
      pgdExecVol_     ()
   {
   WitPart * thePart;
   WitPeriod thePer;

   mySrpExpSpec_ = new WitSrpExpSpec (myProblem ());

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         myReqPairs_.myPtrAt (thePart, thePer) =
            new WitDblDblStack (myProblem ());

   pgdExecVol_.allocate1D (myProblem ());
   }

//------------------------------------------------------------------------------

WitSrpPegger::~WitSrpPegger ()
   {
   WitPart * thePart;
   WitPeriod thePer;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myReqPairs_.myPtrAt (thePart, thePer);

   delete mySrpExpSpec_;

   if (myGlobalComp ()->printSrpDB ())
      fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitSrpPegger::getExecVolTrips (
      WitDemand *       theDemand,
      WitPeriod         shipPer,
      WitOpnTripStack & execVolTrips)
   {
   WitPart *      demPart;
   WitDblDblStack theReqPairs (myProblem ());
   double         incReqVol;
   double         priorVol;
   WitPart *      thePart;
   WitPeriod      thePer;

   execVolTrips.clear ();

   if (theDemand->shipVol ()[shipPer] <= NET_TOL)
      return;

   demPart = theDemand->demandedPart ();

   mySrpExpSync_->getShipReqPairs (theDemand, shipPer, theReqPairs);

   while (theReqPairs.pop (incReqVol, priorVol))
      myReqPairs_.myElemAt (demPart, shipPer).push (incReqVol, priorVol);

   forEachElDense (thePart, demPart->belowList ())
      forEachPeriod (thePer, myProblem ())
         fillReqs (thePart, thePer);

   myExecVolTrips_.reverse ();

   consolidateExecVolTrips ();

   execVolTrips.takeContents (myExecVolTrips_);
   }

//------------------------------------------------------------------------------

void WitSrpPegger::printExpSpec ()
   {
   mySrpExpSpec_->print ();
   }

//------------------------------------------------------------------------------

void WitSrpPegger::fillReqs (WitPart * thePart, WitPeriod thePer)
   {
   WitDblDblStack theReqPairs (myProblem ());
   double         incReqVol;
   double         prevReqVol;

   theReqPairs.takeContents (
      myReqPairs_.myElemAt (thePart, thePer));
   
   theReqPairs.reverse ();

   while (theReqPairs.pop (incReqVol, prevReqVol))
      {
      mySrpExpSpec_->specifyExplosion (thePart, thePer, incReqVol, prevReqVol);

      netWithSupply (thePart, thePer);
      explodeToProd (thePart, thePer);

      mySrpExpSpec_->unspecifyExplosion ();
      }
   }

//------------------------------------------------------------------------------

void WitSrpPegger::netWithSupply (WitPart * thePart, WitPeriod thePer)
   {
   double fillVol;

   fillVol = mySrpExpSpec_->suppFillVol ();

   if (fillVol <= NET_TOL)
      return;
   }

//------------------------------------------------------------------------------

void WitSrpPegger::explodeToProd (WitPart * thePart, WitPeriod expPer)
   {
   double         fillVol;
   double         prevVol;
   WitBopEntry *  theBopEnt;
   WitPeriod      execPer;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;

   fillVol = mySrpExpSpec_->prodFillVol ();

   if (fillVol <= NET_TOL)
      return;

   prevVol = mySrpExpSpec_->prodPrevVol ();

   stronglyAssert (thePart->producingBopEntries ().nElements () == 1);

   theBopEnt = thePart->producingBopEntries ().first ();

   stronglyAssert (theBopEnt->expEligible (expPer));

   execPer = expPer;

   stronglyAssert (theBopEnt->impactPeriod ()[execPer] == expPer);

   theOpn = theBopEnt->myOperation ();

   myExecVolTrips_.push (theOpn, execPer, fillVol);

   forEachEl (theBomEnt, theOpn->bom ())
      explodeBomEntry (theBomEnt, execPer, fillVol, prevVol);
   }

//------------------------------------------------------------------------------

void WitSrpPegger::explodeBomEntry (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        incExecVol,
      double        prevVol)
   {
   WitPart *        consPart;
   WitPeriod        consPer;
   double           incConsVol;
   WitDblDblStack   theNewReqPairs (myProblem ());
   WitDblDblStack * theReqPairsPtr;
   double           incReqVol;
   double           priorVol;

   witAssert (incExecVol > NET_TOL);

   consPart   = theBomEnt->myPart ();

   consPer    = execPer;

   incConsVol = incExecVol;

   mySrpExpSync_->
      getConsReqPairs (
         theBomEnt,
         execPer,
         incConsVol,
         prevVol,
         theNewReqPairs);

   theReqPairsPtr = myReqPairs_.myPtrAt (consPart, consPer);

   while (theNewReqPairs.pop (incReqVol, priorVol))
      theReqPairsPtr->push (incReqVol, priorVol);
   }

//------------------------------------------------------------------------------

void WitSrpPegger::consolidateExecVolTrips ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         pgdVol;

   WitPairStack <WitOperation, WitPeriod> thePairs (myProblem ());

   while (myExecVolTrips_.pop (theOpn, execPer, pgdVol))
      {
      if (not pgdExecVol_ (theOpn).isAllocated ())
         pgdExecVol_ (theOpn).allocate (myProblem (), 0.0);

      pgdExecVol_ (theOpn)[execPer] += pgdVol;

      thePairs.push (theOpn, execPer);
      }

   while (thePairs.pop (theOpn, execPer))
      {
      pgdVol = pgdExecVol_ (theOpn)[execPer];

      if (pgdVol == 0.0)
         continue;

      pgdExecVol_ (theOpn)[execPer] = 0.0;

      myExecVolTrips_.push (theOpn, execPer, pgdVol);
      }
@


1.51
log
@[shared-resource pegging]
@
text
@d110 2
d163 18
@


1.50
log
@[shared-resource pegging]
@
text
@a161 1
   checkSimpleShipSeq ();
a194 26

void WitSrpCoord::checkSimpleShipSeq ()
   {
   WitSchedule <WitDemand, bool> inSeq;

   WitDemTripStack theShipSeq (myProblem ());
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   inSeq.allocate (myProblem (), false);

   myPipSeqMgr ()->get (theShipSeq);

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      if (inSeq (theDemand)[shipPer])
         myMsgFac () ("srpCaseNyiSmsg",
            "The shipment sequence contains two elements "
            "for the same shipment.");

      inSeq (theDemand)[shipPer] = true;
      }
   }

//------------------------------------------------------------------------------
a248 1
   double         theReqVol;
d261 2
a262 5
   stronglyAssert (theReqPairs.nElements () == 1);

   theReqPairs.pop (incReqVol, priorVol);

   myReqPairs_.myElemAt (demPart, shipPer).push (incReqVol, priorVol);
@


1.49
log
@[shared-resource pegging]
@
text
@d232 2
a233 1
      myExecVolTrips_ (myProblem ())
d244 2
d301 2
d422 33
@


1.48
log
@[shared-resource pegging]
@
text
@a117 5
   forEachOperation (theOpn, myProblem ())
      if (theOpn->bop ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an operation with > 1 BOP entry.");

d257 3
@


1.47
log
@[shared-resource pegging]
@
text
@d327 2
a328 13
      if (mySrpExpSpec_->suppFillVol () > NET_TOL)
         netWithSupply (
            thePart,
            thePer,
            mySrpExpSpec_->suppFillVol (),
            mySrpExpSpec_->suppPrevVol ());

      if (mySrpExpSpec_->prodFillVol () > NET_TOL)
         explodeToProd (
            thePart,
            thePer,
            mySrpExpSpec_->prodFillVol (),
            mySrpExpSpec_->prodPrevVol ());
d336 1
a336 5
void WitSrpPegger::netWithSupply (
      WitPart * thePart,
      WitPeriod thePer,
      double    fillVol,
      double    prevFillVol)
d338 6
a343 1
   witAssert (fillVol > NET_TOL);
d348 1
a348 5
void WitSrpPegger::explodeToProd (
      WitPart * thePart,
      WitPeriod expPer,
      double    fillVol,
      double    prevFillVol)
d350 2
d357 6
a362 1
   witAssert (fillVol > NET_TOL);
d370 1
a370 1
   execPer   = expPer;
d374 1
a374 1
   theOpn    = theBopEnt->myOperation ();
d379 1
a379 1
      explodeBomEntry (theBomEnt, execPer, fillVol, prevFillVol);
d388 1
a388 1
      double        prevFillVol)
d411 1
a411 1
         prevFillVol,
@


1.46
log
@[shared-resource pegging]
@
text
@a22 1
#include <SrpFillMeth.h>
a42 1
      mySrpOldSpec_ (NULL),
d48 1
a48 1
   mySrpOldSpec_ = new WitSrpOldSpec (myProblem ());
d50 1
a50 3
   mySrpExpSync_ = new WitSrpExpSync (myPipSeqMgr (), mySrpOldSpec_);

   mySrpPegger_  = new WitSrpPegger  (mySrpOldSpec_, mySrpExpSync_);
a58 1
   delete mySrpOldSpec_;
a97 1
   mySrpOldSpec_->print ();
d230 1
a230 3
WitSrpPegger::WitSrpPegger (
         WitSrpOldSpec * theSrpOldSpec,
         WitSrpExpSync * theSrpExpSync):
a234 1
      mySrpOldSpec_   (theSrpOldSpec),
a346 44
void WitSrpPegger::fillReqsOld (WitPart * thePart, WitPeriod thePer)
   {
   WitDblDblStack * theReqPairsPtr;
   double           incReqVol;
   double           prevReqVol;
   double           prevFillVol;
   WitSrpFillMeth * theSrpFillMeth;
   double           fillVol;

   WitSrpFillMethDblStack theFillMethPairs (myProblem ());

   theReqPairsPtr = myReqPairs_.myPtrAt (thePart, thePer);

   theReqPairsPtr->reverse ();

   while (theReqPairsPtr->pop (incReqVol, prevReqVol))
      {
      mySrpOldSpec_->
         getFillMethPairs (
            thePart,
            thePer,
            incReqVol,
            prevReqVol,
            prevFillVol,
            theFillMethPairs);

      while (theFillMethPairs.pop (theSrpFillMeth, fillVol))
         {
         if (theSrpFillMeth->byNetWithSupp ())
            netWithSupply (thePart, thePer, fillVol, prevFillVol);

         else if (theSrpFillMeth->byExpToProd ())
            explodeToProd (thePart, thePer, fillVol, prevFillVol);

         else
            stronglyAssert (false);

         prevFillVol = 0.0;
         }
      }
   }

//------------------------------------------------------------------------------

@


1.45
log
@[shared-resource pegging]
@
text
@d101 1
a101 3
   WitSrpExpSpec theSrpExpSpec (myProblem ());

   theSrpExpSpec. print ();
d242 1
d251 2
d269 2
d314 7
d323 35
@


1.44
log
@[shared-resource pegging]
@
text
@d44 1
a44 1
      mySrpExpSpec_ (NULL),
d50 1
a50 1
   mySrpExpSpec_ = new WitSrpExpSpec (myProblem ());
d52 1
a52 1
   mySrpExpSync_ = new WitSrpExpSync (myPipSeqMgr (), mySrpExpSpec_);
d54 1
a54 1
   mySrpPegger_  = new WitSrpPegger  (mySrpExpSpec_, mySrpExpSync_);
d63 1
a63 1
   delete mySrpExpSpec_;
d101 5
a105 1
   mySrpExpSpec_->print ();
d239 1
a239 1
         WitSrpExpSpec * theSrpExpSpec,
d244 1
a244 1
      mySrpExpSpec_   (theSrpExpSpec),
d328 1
a328 1
      mySrpExpSpec_->
@


1.43
log
@[shared-resource pegging]
@
text
@d311 2
a312 1
   double           prevVol;
d322 1
a322 1
   while (theReqPairsPtr->pop (incReqVol, prevVol))
d329 2
a330 1
            prevVol,
d336 1
a336 1
            netWithSupply (thePart, thePer, fillVol, prevVol);
d339 1
a339 1
            explodeToProd (thePart, thePer, fillVol, prevVol);
d343 2
d355 1
a355 1
      double    prevVol)
d366 1
a366 1
      double    prevVol)
d390 1
a390 1
      explodeBomEntry (theBomEnt, execPer, fillVol, prevVol);
d399 1
a399 1
      double        prevVol)
d422 1
a422 1
         prevVol,
@


1.42
log
@[shared-resource pegging]
@
text
@d242 1
a242 1
      myReqInts_      (myProblem ()),
d250 1
a250 1
         myReqInts_.myPtrAt (thePart, thePer) =
d263 1
a263 1
         delete myReqInts_.myPtrAt (thePart, thePer);
d294 1
a294 1
   myReqInts_.myElemAt (demPart, shipPer).push (incReqVol, priorVol);
d309 1
a309 1
   WitDblDblStack * theReqIntsPtr;
d317 1
a317 1
   theReqIntsPtr = myReqInts_.myPtrAt (thePart, thePer);
d319 1
a319 1
   theReqIntsPtr->reverse ();
d321 1
a321 1
   while (theReqIntsPtr->pop (incReqVol, prevVol))
a367 6
   WitPart *      consPart;
   WitPeriod      consPer;
   double         incConsVol;
   WitDblDblStack theReqPairs (myProblem ());
   double         incReqVol;
   double         priorVol;
d386 24
a409 2
      {
      consPart   = theBomEnt->myPart ();
d411 1
a411 1
      consPer    = execPer;
d413 7
a419 1
      incConsVol = fillVol;
d421 1
a421 7
      mySrpExpSync_->
         getConsReqPairs (
            theBomEnt,
            execPer,
            incConsVol,
            prevVol,
            theReqPairs);
d423 2
a424 4
      while (theReqPairs.pop (incReqVol, priorVol))
         myReqInts_.myElemAt (consPart, consPer).
            push (incReqVol, priorVol);
      }
@


1.41
log
@[shared-resource pegging]
@
text
@a122 1
      {
a126 5
      if (theOpn->bom ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains an operation with > 1 BOM entry.");
      }

d283 1
a283 1
   if (theDemand->shipVol ()[shipPer] < NET_TOL)
d309 1
d317 5
a321 1
   while (myReqInts_.myElemAt (thePart, thePer).pop (incReqVol, prevVol))
d353 1
a353 1
   witAssert (fillVol >= NET_TOL);
d375 1
a375 1
   witAssert (fillVol >= NET_TOL);
d391 3
a393 2
   if (theOpn->bom ().isEmpty ())
      return;
d395 1
a395 1
   stronglyAssert (theOpn->bom ().nElements () == 1);
d397 1
a397 1
   theBomEnt  = theOpn->bom ().first ();
d399 7
a405 1
   consPart   = theBomEnt->myPart ();
d407 4
a410 15
   consPer    = execPer;

   incConsVol = fillVol;

   mySrpExpSync_->
      getConsReqPairs (
         theBomEnt,
         execPer,
         incConsVol,
         prevVol,
         theReqPairs);

   while (theReqPairs.pop (incReqVol, priorVol))
      myReqInts_.myElemAt (consPart, consPer).
         push (incReqVol, priorVol);
@


1.40
log
@[shared-resource pegging]
@
text
@a141 6

      if (thePart->consumingBomEntries ().nElements () == 1)
         if (thePart->myDemands ().nElements () == 1)
            myMsgFac () ("srpCaseNyiSmsg",
               "The problem contains a part with both a consuming BOM entry "
               "and a demand.");
@


1.39
log
@[shared-resource peging]
@
text
@a142 4
      if (thePart->consumingBomEntries ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains a part consumed by > 1 BOM entry.");

d286 1
a286 1
   WitDblDblStack theDefPairs (myProblem ());
d288 1
a288 1
   double         deferVol;
d300 1
a300 1
   mySrpExpSync_->getShipDefPairs (theDemand, shipPer, theDefPairs);
d302 1
a302 1
   stronglyAssert (theDefPairs.nElements () == 1);
d304 1
a304 1
   theDefPairs.pop (incReqVol, deferVol);
d306 1
a306 1
   myReqInts_.myElemAt (demPart, shipPer).push (incReqVol, deferVol);
d328 1
a328 16
   if (myReqInts_.myElemAt (thePart, thePer).isEmpty ())
      return;

   stronglyAssert (myReqInts_.myElemAt (thePart, thePer).nElements () == 1);

   myReqInts_.myElemAt (thePart, thePer).pop (incReqVol, prevVol);

   mySrpExpSpec_->
      getFillMethPairs (
         thePart,
         thePer,
         incReqVol,
         prevVol,
         theFillMethPairs);

   while (theFillMethPairs.pop (theSrpFillMeth, fillVol))
d330 19
a348 8
      if (theSrpFillMeth->byNetWithSupp ())
         netWithSupply (thePart, thePer, fillVol, prevVol);

      else if (theSrpFillMeth->byExpToProd ())
         explodeToProd (thePart, thePer, fillVol, prevVol);

      else
         stronglyAssert (false);
d378 3
d411 11
a421 1
   myReqInts_.myElemAt (consPart, consPer).push (incConsVol, prevVol);
@


1.38
log
@[shared-resource pegging]
@
text
@a146 4
      if (thePart->myDemands ().nElements () > 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains a part with > 1 demand.");

d289 7
a295 4
   WitPart * demPart;
   double    theReqVol;
   WitPart * thePart;
   WitPeriod thePer;
d302 1
a302 1
   demPart   = theDemand->demandedPart ();
d304 1
a304 1
   theReqVol = theDemand->shipVol ()[shipPer];
d306 5
a310 1
   myReqInts_.myElemAt (demPart, shipPer).push (theReqVol, 0.0);
d325 1
a325 1
   double           theReqVol;
d330 1
a330 1
   WitPairStack <WitSrpFillMeth, double> theFillMethPairs (myProblem ());
d337 1
a337 3
   myReqInts_.myElemAt (thePart, thePer).pop (theReqVol, prevVol);

   stronglyAssert (prevVol == 0.0);
d343 2
a344 2
         theReqVol,
         0.0,
d416 1
a416 1
   myReqInts_.myElemAt (consPart, consPer).push (incConsVol, 0.0);
@


1.37
log
@[shared-resource pegging]
@
text
@d20 1
a20 1
#include <SrpExpGuide.h>
d42 1
a42 1
      WitPipCoord    (theSeqMgr),
d44 3
a46 3
      mySrpExpGuide_ (NULL),
      mySrpExpSync_  (NULL),
      mySrpPegger_   (NULL)
d50 1
a50 1
   mySrpExpGuide_ = new WitSrpExpGuide (myProblem ());
d52 1
a52 1
   mySrpExpSync_  = new WitSrpExpSync  (myPipSeqMgr (), mySrpExpGuide_);
d54 1
a54 1
   mySrpPegger_   = new WitSrpPegger   (mySrpExpGuide_, mySrpExpSync_);
d63 1
a63 1
   delete mySrpExpGuide_;
d101 2
a102 2
   mySrpExpGuide_->print ();
   mySrpExpSync_ ->print ();
d255 2
a256 2
         WitSrpExpGuide * theSrpExpGuide,
         WitSrpExpSync *  theSrpExpSync):
d260 1
a260 1
      mySrpExpGuide_  (theSrpExpGuide),
d338 1
a338 1
   mySrpExpGuide_->
@


1.36
log
@[shared-resource pegging]
@
text
@d21 1
d23 1
a23 2
#include <SrpExpSync.h>
#include <SrpSyncBldr.h>
d31 1
d322 4
a325 2
   if (myReqInts_.myElemAt (thePart, thePer).isEmpty ())
      return;
d327 1
a327 1
   netWithSupply (thePart, thePer);
d332 1
a332 1
   explodeToProd (thePart, thePer);
d334 1
a334 2
   if (myReqInts_.myElemAt (thePart, thePer).isEmpty ())
      return;
d336 1
a336 2
   acctViolation (thePart, thePer);
   }
d338 7
a344 1
//------------------------------------------------------------------------------
d346 4
a349 6
void WitSrpPegger::netWithSupply (WitPart * thePart, WitPeriod supPer)
   {
   double theReqVol;
   double priorVol;
   double incSuppVol;
   double netReqVol;
d351 2
a352 2
   if (thePart->supplyVol ()[supPer] < NET_TOL)
      return;
d354 4
a357 1
   witAssert (myReqInts_.myElemAt (thePart, supPer).isNonEmpty ());
d359 1
a359 1
   myReqInts_.myElemAt (thePart, supPer).pop (theReqVol, priorVol);
d361 7
a367 10
   witAssert (theReqVol >= NET_TOL);

   stronglyAssert (priorVol == 0.0);

   incSuppVol = min (theReqVol, thePart->supplyVol ()[supPer]);

   netReqVol  = theReqVol - incSuppVol;

   if (netReqVol >= NET_TOL)
      myReqInts_.myElemAt (thePart, supPer).push (netReqVol, 0.0);
d372 5
a376 1
void WitSrpPegger::explodeToProd (WitPart * thePart, WitPeriod expPer)
a377 2
   double         theReqVol;
   double         priorVol;
d379 1
d383 2
d386 1
a386 12
   if (thePart->producingBopEntries ().isEmpty ())
      return;

   witAssert (myReqInts_.myElemAt (thePart, expPer).isNonEmpty ());

   myReqInts_.myElemAt (thePart, expPer).pop (theReqVol, priorVol);

   stronglyAssert (myReqInts_.myElemAt (thePart, expPer).isEmpty ());

   stronglyAssert (theReqVol >= NET_TOL);

   stronglyAssert (priorVol == 0.0);
d394 1
a394 1
   stronglyAssert (theBopEnt->impactPeriod ()[expPer] == expPer);
d396 1
a396 1
   theOpn = theBopEnt->myOperation ();
d398 3
a400 1
   myExecVolTrips_.push (theOpn, expPer, theReqVol);
d407 1
a407 20
   theBomEnt = theOpn->bom ().first ();
   
   consPart  = theBomEnt->myPart ();

   myReqInts_.myElemAt (consPart, expPer).push (theReqVol, 0.0);
   }

//------------------------------------------------------------------------------

void WitSrpPegger::acctViolation (WitPart * thePart, WitPeriod thePer)
   {
   double theReqVol;
   double priorVol;

   if (not DEVELOPMENT)
      return;

   witAssert (myReqInts_.myElemAt (thePart, thePer).isNonEmpty ());

   myReqInts_.myElemAt (thePart, thePer).pop (theReqVol, priorVol);
d409 1
a409 1
   stronglyAssert (myReqInts_.myElemAt (thePart, thePer).isEmpty ());
d411 1
a411 1
   stronglyAssert (theReqVol >= NET_TOL);
d413 1
a413 1
   stronglyAssert (priorVol == 0.0);
d415 1
a415 1
   witAssert (theReqVol <= 2.0 * FEAS_TOL);
@


1.35
log
@[shared-resource pegging]
@
text
@d49 1
a49 1
   mySrpExpGuide_ = WitSrpExpGuide::builtExpGuide (myProblem ());
d51 1
a51 1
   mySrpExpSync_  = new WitSrpExpSync (myPipSeqMgr (), mySrpExpGuide_);
d53 1
a53 1
   mySrpPegger_   = new WitSrpPegger  (mySrpExpGuide_, mySrpExpSync_);
@


1.34
log
@[shared-resource pegging]
@
text
@d51 1
a51 1
   mySrpExpSync_  = new WitSrpExpSync (mySrpExpGuide_, myPipSeqMgr ());
@


1.33
log
@[shared-resource pegging]
@
text
@d51 1
a51 1
   mySrpExpSync_  = new WitSrpExpSync (myPipSeqMgr ());
d53 1
a53 1
   mySrpPegger_   = new WitSrpPegger (mySrpExpSync_);
d253 3
a255 1
WitSrpPegger::WitSrpPegger (WitSrpExpSync * theSrpExpSync):
d259 1
@


1.32
log
@[shared-resource pegging]
@
text
@d51 1
a51 1
   mySrpExpSync_  = WitSrpExpSync::builtExpSync (myPipSeqMgr ());
@


1.31
log
@[shared-resource pegging]
@
text
@d51 1
a51 1
   mySrpExpSync_  = WitSrpExpSync::builtExpSync (this);
@


1.30
log
@[shared-resource pegging]
@
text
@d49 1
a49 1
   mySrpExpGuide_ = WitSrpExpGuide::newInst (myProblem ());
d51 1
a51 3
   mySrpExpSync_  = new WitSrpExpSync (this);

   mySrpExpSync_->build ();
@


1.29
log
@[shared-resource pegging]
@
text
@d291 4
a294 6
   WitPart *      demPart;
   WitDblDblStItr theItr;
   double         theReqVol;
   double         priorVol;
   WitPart *      thePart;
   WitPeriod      thePer;
d301 1
a301 1
   demPart = theDemand->demandedPart ();
d303 1
a303 1
   mySrpExpSync_->serShipReqs (theDemand, shipPer).attach (theItr);
d305 1
a305 2
   while (theItr.advance (theReqVol, priorVol))
      myReqInts_.myElemAt (demPart, shipPer).push (theReqVol, priorVol);
@


1.28
log
@[shared-resource pegging]
@
text
@d16 1
a16 1
//    SrpGlobPgr
d21 1
a21 1
#include <SrpGlobPgr.h>
d45 1
a45 1
      mySrpGlobPgr_  (NULL)
d55 1
a55 1
   mySrpGlobPgr_  = new WitSrpGlobPgr (mySrpExpSync_);
d62 1
a62 1
   delete mySrpGlobPgr_;
d74 1
a74 1
   mySrpGlobPgr_->getExecVolTrips (theDemand, shipPer, execVolTrips);
d252 1
a252 1
// Implementation of class SrpGlobPgr.
d255 1
a255 1
WitSrpGlobPgr::WitSrpGlobPgr (WitSrpExpSync * theSrpExpSync):
d274 1
a274 1
WitSrpGlobPgr::~WitSrpGlobPgr ()
d286 1
a286 1
void WitSrpGlobPgr::getExecVolTrips (
d321 1
a321 1
void WitSrpGlobPgr::fillReqs (WitPart * thePart, WitPeriod thePer)
d341 1
a341 1
void WitSrpGlobPgr::netWithSupply (WitPart * thePart, WitPeriod supPer)
d369 1
a369 1
void WitSrpGlobPgr::explodeToProd (WitPart * thePart, WitPeriod expPer)
d417 1
a417 1
void WitSrpGlobPgr::acctViolation (WitPart * thePart, WitPeriod thePer)
@


1.27
log
@[shared-resource pegging]
@
text
@d23 1
a23 1
#include <SrpLocPgr.h>
@


1.26
log
@[shared-resource pegging]
@
text
@d22 1
a22 1
#include <SrpLocPgg.h>
d44 1
a44 1
      mySrpLocPgg_   (NULL),
d51 1
a51 1
   mySrpLocPgg_   = new WitSrpLocPgg (this);
d53 1
a53 1
   mySrpLocPgg_->build ();
d55 1
a55 1
   mySrpGlobPgr_  = new WitSrpGlobPgr (mySrpLocPgg_);
d63 1
a63 1
   delete mySrpLocPgg_;
d103 1
a103 1
   mySrpLocPgg_  ->print ();
d255 1
a255 1
WitSrpGlobPgr::WitSrpGlobPgr (WitSrpLocPgg * theSrpLocPgg):
d257 1
a257 1
      WitProbAssoc    (theSrpLocPgg->myProblem ()),
d259 1
a259 1
      mySrpLocPgg_    (theSrpLocPgg),
d305 1
a305 1
   mySrpLocPgg_->serShipReqs (theDemand, shipPer).attach (theItr);
@


1.25
log
@[shared-resource pegging]
@
text
@d20 1
a20 1
#include <SrpExpSpec.h>
d41 1
a41 1
      WitPipCoord   (theSeqMgr),
d43 3
a45 3
      mySrpExpSpec_ (NULL),
      mySrpLocPgg_  (NULL),
      mySrpGlobPgr_ (NULL)
d49 1
a49 1
   mySrpExpSpec_ = WitSrpExpSpec::newInst (myProblem ());
d51 1
a51 1
   mySrpLocPgg_ = new WitSrpLocPgg (this);
d55 1
a55 1
   mySrpGlobPgr_ = new WitSrpGlobPgr (mySrpLocPgg_);
d64 1
a64 1
   delete mySrpExpSpec_;
d102 2
a103 2
   mySrpExpSpec_->print ();
   mySrpLocPgg_ ->print ();
@


1.24
log
@[shared-resource pegging]
@
text
@d102 2
a103 1
   mySrpLocPgg_->print ();
@


1.23
log
@[shared-resource pegging]
@
text
@d20 1
d41 1
a41 1
      WitPipCoord (theSeqMgr),
d43 3
a45 2
      myLocPgg_   (NULL),
      myGlobPgr_  (NULL)
d49 1
a49 1
   myLocPgg_ = new WitSrpLocPgg (this);
d51 1
a51 1
   myLocPgg_->build ();
d53 3
a55 1
   myGlobPgr_ = new WitSrpGlobPgr (myLocPgg_);
d62 3
a64 2
   delete myGlobPgr_;
   delete myLocPgg_;
d74 1
a74 1
   myGlobPgr_->getExecVolTrips (theDemand, shipPer, execVolTrips);
d102 1
a102 1
   myLocPgg_->print ();
d254 1
a254 1
WitSrpGlobPgr::WitSrpGlobPgr (WitSrpLocPgg * theLocPgg):
d256 1
a256 1
      WitProbAssoc    (theLocPgg->myProblem ()),
d258 1
a258 1
      myLocPgg_       (theLocPgg),
d304 1
a304 1
   myLocPgg_->serShipReqs (theDemand, shipPer).attach (theItr);
@


1.22
log
@[shared-resource pegging]
@
text
@d255 1
a255 2
      myExecVolTrips_ (myProblem ()),
      maxExcViolVol_  (0.0)
a414 2
   double locViolVol;
   double excViolVol;
d429 1
a429 16
   locViolVol = myLocPgg_->violVol (thePart, thePer);

   excViolVol = positivePart (theReqVol - locViolVol);

   if (excViolVol < NET_TOL)
      return;

   if (excViolVol <= maxExcViolVol_)
      return;

   maxExcViolVol_ = excViolVol;

   myMsgFac () ("srpViolWmsg",
      excViolVol,
      thePart->partName (),
      thePer);
@


1.21
log
@Testing CVS.
@
text
@d29 1
d113 4
@


1.20
log
@Testing CVS.
@
text
@a9 2
// CVS test.

@


1.19
log
@[shared-resource pegging]
@
text
@d10 2
@


1.18
log
@[shared-resource pegging]
@
text
@d295 1
a295 1
   theItr.attachTo (myLocPgg_->serShipReqs (theDemand, shipPer));
@


1.17
log
@[shared-resource pegging]
@
text
@d281 6
a286 4
   WitPart * demPart;
   double    shipVolVal;
   WitPart * thePart;
   WitPeriod thePer;
d293 3
a295 2
   demPart    = theDemand->demandedPart ();
   shipVolVal = theDemand->shipVol ()[shipPer];
d297 2
a298 1
   myReqInts_.myElemAt (demPart, shipPer).push (shipVolVal, 0.0);
d427 1
a427 1
   locViolVol = myLocPgg_->violVol () (thePart)[thePer];
@


1.16
log
@[shared-resource pegging]
@
text
@d281 1
a281 1
   WitPart * topPart;
d288 4
a291 1
   topPart    = theDemand->demandedPart ();
d294 1
a294 4
   if (shipVolVal < NET_TOL)
      return;

   myReqInts_.myElemAt (topPart, shipPer).push (shipVolVal, 0.0);
d296 1
a296 1
   forEachElDense (thePart, topPart->belowList ())
d423 1
a423 1
   locViolVol = myLocPgg_->violVol (thePart, thePer);
@


1.15
log
@[shared-resource pegging]
@
text
@a128 12
#if 0

      if (thePart->supplyVol () != 0.0)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains a part with a positive supplyVol.");

      if (thePart->producingBopEntries ().nElements () != 1)
         myMsgFac () ("srpCaseNyiSmsg",
            "The problem contains a part produced by other than 1 BOP entry.");

#endif

d410 3
d430 9
a438 1
   stronglyAssert (false);
@


1.14
log
@[shared-resource pegging]
@
text
@d262 2
a263 1
      myExecVolTrips_ (myProblem ())
d330 5
d376 3
d412 29
@


1.13
log
@[shared-resource pegging]
@
text
@d129 6
d139 6
d309 1
a309 1
         pegPart (thePart, thePer);
d318 44
a361 1
void WitSrpGlobPgr::pegPart (WitPart * thePart, WitPeriod thePer)
d370 1
a370 2
   if (myReqInts_.myElemAt (thePart, thePer).isEmpty ())
      return;
d372 1
a372 1
   myReqInts_.myElemAt (thePart, thePer).pop (theReqVol, priorVol);
d374 1
a374 1
   stronglyAssert (myReqInts_.myElemAt (thePart, thePer).isEmpty ());
d384 1
a384 1
   stronglyAssert (theBopEnt->expEligible (thePer));
d386 1
a386 1
   stronglyAssert (theBopEnt->impactPeriod ()[thePer] == thePer);
d390 1
a390 1
   myExecVolTrips_.push (theOpn, thePer, theReqVol);
d401 1
a401 1
   myReqInts_.myElemAt (consPart, thePer).push (theReqVol, 0.0);
a402 1

@


1.12
log
@[shared-resource pegging]
@
text
@d94 7
@


1.11
log
@[shared-resource pegging]
@
text
@d174 1
d208 26
@


1.10
log
@[shared-resource pegging]
@
text
@d46 1
a46 1
   myLocPgg_ = new WitSrpLocPgg (myProblem ());
d260 1
a260 1
 
@


1.9
log
@[shared-resource pegging]
@
text
@d39 1
a39 1
      WitPipCoord   (theSeqMgr),
d41 2
a42 2
      mySrpLocPgg_  (NULL),
      mySrpGlobPgr_ (NULL)
d46 1
a46 1
   mySrpLocPgg_ = new WitSrpLocPgg (myProblem ());
d48 1
a48 1
   mySrpLocPgg_->build ();
d50 1
a50 1
   mySrpGlobPgr_ = new WitSrpGlobPgr (mySrpLocPgg_);
d57 2
a58 2
   delete mySrpGlobPgr_;
   delete mySrpLocPgg_;
d68 1
a68 1
   mySrpGlobPgr_->getExecVolTrips (theDemand, shipPer, execVolTrips);
d210 1
a210 1
WitSrpGlobPgr::WitSrpGlobPgr (WitSrpLocPgg * theSrpLocPgg):
d212 1
a212 1
      WitProbAssoc    (theSrpLocPgg->myProblem ()),
d214 1
a214 1
      mySrpLogPgg_    (theSrpLocPgg),
@


1.8
log
@[shared-resource pegging]
@
text
@d21 1
d41 1
d46 1
a46 1
   WitSrpLocPgr::buildLocalPegging (this);
d48 3
a50 1
   mySrpGlobPgr_ = new WitSrpGlobPgr (this);
d58 1
d210 1
a210 1
WitSrpGlobPgr::WitSrpGlobPgr (WitSrpCoord * theSrpCoord):
d212 1
a212 1
      WitProbAssoc    (theSrpCoord->myProblem ()),
d214 1
a214 1
      mySrpCoord_     (theSrpCoord),
@


1.7
log
@[shared-resource pegging]
@
text
@d29 1
d167 32
@


1.6
log
@[shared-resource pegging]
@
text
@d16 1
d20 2
d37 1
a37 1
      WitPipCoord     (theSeqMgr),
d39 1
a39 2
      myReqInts_      (myProblem ()),
      myExecVolTrips_ (myProblem ())
d41 1
a41 2
   WitPart * thePart;
   WitPeriod thePer;
d43 1
a43 1
   checkRestrictions ();
d45 1
a45 4
   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         myReqInts_.myPtrAt (thePart, thePer) =
            new WitDblDblStack (myProblem ());
d52 1
a52 6
   WitPart * thePart;
   WitPeriod thePer;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete myReqInts_.myPtrAt (thePart, thePer);
d62 1
a62 22
   WitPart * topPart;
   double    shipVolVal;
   WitPart * thePart;
   WitPeriod thePer;

   execVolTrips.clear ();

   topPart    = theDemand->demandedPart ();
   shipVolVal = theDemand->shipVol ()[shipPer];

   if (shipVolVal < NET_TOL)
      return;

   myReqInts_.myElemAt (topPart, shipPer).push (shipVolVal, 0.0);
 
   forEachElDense (thePart, topPart->belowList ())
      forEachPeriod (thePer, myProblem ())
         pegPart (thePart, thePer);

   myExecVolTrips_.reverse ();

   execVolTrips.takeContents (myExecVolTrips_);
d169 4
d174 61
a234 1
void WitSrpCoord::pegPart (WitPart * thePart, WitPeriod thePer)
d277 1
@


1.5
log
@[shared-resource pegging]
@
text
@d34 1
a34 1
      WitPipCoord         (theSeqMgr),
d36 2
a37 2
      myReqInts_          (theSeqMgr->myProblem ()),
      curExecVolTripsPtr_ (NULL)
a81 2
   curExecVolTripsPtr_ = & execVolTrips;

d88 3
a90 1
   curExecVolTripsPtr_ = NULL;
d228 1
a228 1
   curExecVolTrips ().push (theOpn, thePer, theReqVol);
@


1.4
log
@[shared-resource pegging]
@
text
@a63 9
void WitSrpCoord::print ()
   {
   fprintf (solnFile (),
      "\n"
      "Shared-Resource Pegging (Place Holder)\n");
   }

//------------------------------------------------------------------------------

@


1.3
log
@[shared-resource pegging]
@
text
@d127 6
d136 67
a202 1
   myMsgFac () ("srpCaseNyiSmsg", "Any implosion problem");
a215 2
   stronglyAssert (false);

@


1.2
log
@[shared-resource pegging]
@
text
@d19 7
d34 4
a37 1
      WitPipCoord (theSeqMgr)
d39 3
d43 5
d54 6
d78 22
a99 1
   stronglyAssert (false);
d132 48
@


1.1
log
@[shared-resource pegging]
@
text
@d19 1
d22 1
a22 1
// Implementation of class UrpCoord.
d29 1
d44 1
a44 1
      "Printing of shared-resource pegging is not yet implemented.\n");
d77 10
@


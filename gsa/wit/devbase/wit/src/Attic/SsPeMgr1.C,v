head	1.35;
access;
symbols;
locks; strict;
comment	@ * @;


1.35
date	2002.04.11.15.36.33;	author rjw;	state dead;
branches;
next	1.34;

1.34
date	2002.04.09.16.05.54;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.08.17.28.22;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.05.20.43.59;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.04.18.14.49;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.03.16.34.56;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.02.19.20.38;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.29.23.47.12;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.27.17.18.32;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.22.15.36.30;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.20.22.51.20;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.19.16.20.58;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.15.23.17.32;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.20.04.03;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.15.05.49;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.13.19.27.20;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.12.21.58.17;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.12.18.01.08;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.08.21.18.00;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.07.23.24.30;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.28.23.21.51;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.28.00.08.13;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.26.15.17.19;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.20.22.28.07;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.09.00.43.49;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.07.21.01.01;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.07.16.57.30;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.22.21.45.14;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.21.21.55.17;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.19.01.49.06;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.16.21.53.01;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.14.23.56.09;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.11.23.45.36;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.11.19.17.29;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.10.22.06.59;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Continued implementation of sel-split for pen-exec.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "SsPeMgr1.C"
//
// Contains the implementation of class SsPeMgr.
//------------------------------------------------------------------------------

#include <SsPeMgr1.h>
#include <Selector.h>
#include <SelMgr.h>
#include <SelCand.h>
#include <SelPt.h>
#include <Splitter.h>
#include <SplitCntr.h>
#include <SplitPt.h>
#include <ExpRest.h>
#include <RtAn.h>
#include <PmrMgr.h>
#include <CmrMgr.h>
#include <HeurAtor.h>
#include <PairStack.h>
#include <Archive.h>

//------------------------------------------------------------------------------
// Implementation of class SsPeMgr.
//------------------------------------------------------------------------------

WitSsPeMgr::WitSsPeMgr (WitSelector * theSelector):
      WitProbAssoc  (theSelector),

      mySelector_   (theSelector),
      mySplitter_   (theSelector->mySplitter ()),
      myExpRest_    (theSelector->myExpRest ()),
      myRtAnalyzer_ (theSelector->myRtAnalyzer ()),
      zeroPts_      (myProblem ()),
      nBSsDone_     (0),
      nBSsSkipped_  (0),
      nBatches_     (0)
   {
   stronglyAssert (mySelector_->selSplit ());

   stronglyAssert (myGlobalComp ()->penExec ());

   if (! myGlobalComp ()->allowSSPE ())
      myMsgFac () ("ssPeNotAllowedSMsg");
   }

//------------------------------------------------------------------------------

WitSsPeMgr::~WitSsPeMgr ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 1)
      fprintf (msgFile (), 
         "# SSPE BS's Done:       %7d\n"
         "# SSPE BS's Skipped:    %7d\n"
         "# Split Batches:        %7d\n",
         nBSsDone_,
         nBSsSkipped_,
         nBatches_);
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::commitMaxQty (double & netQty)
   {
   WitBoolean scNeeded;
   WitBoolean unresFound;
   WitSelPt * theSelPt;

   while (witTRUE)
      {
      mySelector_->failResAlt_ = witFALSE;

      myRtAnalyzer_->modifyRouting ();

      mySplitter_->startFlowMon ();

      mySelector_->myHeurAtor ()->commitMaxQtySel (netQty);

      if ((netQty <= 0.0) || ! resAltOrRest ())
         {
         mySplitter_->finishFlowMon ();

         break;
         }

      scNeeded = splitCommitNeeded ();
      
      mySplitter_->finishFlowMon ();

      if (scNeeded)
         if (! mySelector_->myHeurAtor ()->failedOn1 ())
            if (mySelector_->myHeurAtor ()->tempCommit (1.0))
               scNeeded = witFALSE;

      if (scNeeded)
         {
         splitCommit (unresFound);

         if (unresFound)
            break;
         }
      else
         {
         myExpRest_->updatePsSup ();

         if (mySelector_->getPendingPt (theSelPt))
            mySelector_->alterSelection (theSelPt);
         }
      }

   myExpRest_->updatePsSup ();
   }

//------------------------------------------------------------------------------

WitBoolean WitSsPeMgr::splitCommitNeeded ()
   {
   WitSelPt * theSelPt;
   double     flowGap;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      if (mySplitter_->splitIsNeeded (theSelPt, witTRUE, flowGap))
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::splitCommit (WitBoolean & unresFound)
   {
   int         nItrs;
   WitBoolean  tcOK;
   WitBoolean  splitFound;
   WitSelPt *  theSelPt;
   WitSelMgr * theSelMgr;

   unresFound = witFALSE;
   nItrs      = 0;
   tcOK       = witFALSE;

   mySplitter_->splitCommActive_ = witTRUE;

   mySplitter_->mySplitCntr_->initCurSplits ();

   while (! tcOK)
      {
      nItrs ++;

      if (nItrs > myGlobalComp ()->splitItrUB ())
         break;

      buildZeroPts (unresFound, splitFound);

      if (unresFound)
         break;

      if (splitFound)
         splitSels ();

      clearSplitItr ();

      stronglyAssert (resAltOrRest ());

      myExpRest_->updatePsSup ();

      if (mySelector_->getPendingPt (theSelPt))
         mySelector_->alterSelection (theSelPt);

      myRtAnalyzer_->modifyRouting ();

      tcOK = mySelector_->myHeurAtor ()->tempCommit (1.0);
      }

   if (tcOK)
      mySelector_->myHeurAtor ()->permCommit1SS ();

   mySplitter_->mySplitCntr_->countSplits (tcOK);

   mySplitter_->splitCommActive_ = witFALSE;

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->postSplitCommit ();

   deleteContents (mySplitter_->mySplitPts_);
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::buildZeroPts (WitBoolean & unresFound, WitBoolean & splitFound)
   {
   WitBoolean addedZeroPts;

   stronglyAssert (zeroPts_.isEmpty ());

   unresFound = witFALSE;
   splitFound = witFALSE;

   while (! splitFound)
      {
      unresFound = ! resAltOrRest ();

      if (unresFound)
         {
         clearSplitItr ();

         return;
         }

      addedZeroPts = addChgPtsToZeroPts ();

      if (! addedZeroPts)
         return;

      splitFound = tempCommDiscZeroPts ();
      }
   }

//------------------------------------------------------------------------------

WitBoolean WitSsPeMgr::addChgPtsToZeroPts ()
   {
   WitBoolean addedZeroPts;
   WitSelPt * theSelPt;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   addedZeroPts = witFALSE;

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      {
      if (! theSelPt->isSplit ())
         mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));

      else if (zeroPts_.contains (theSelPt->mySplitPt ()))
         continue;

      zeroPts_.push (theSelPt->mySplitPt ());

      addedZeroPts = witTRUE;
      }

   return addedZeroPts;
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::splitSels ()
   {
   WitBoolean   success;
   WitSplitPt * searchPt;
   WitBoolean   splitNeeded;
   double       flowGap;
   double       splitBound;

   mySplitter_->startFlowMon ();

   success = witTRUE;

   while (success)
      {
      stronglyAssert (! zeroPts_.isEmpty ());

      searchPt = findLowestZeroPt ();

      zeroPts_.remove (searchPt);

      success = tempCommDiscZeroPts ();
      }

   splitNeeded =
      mySplitter_->splitIsNeeded (searchPt->mySelPt_, witFALSE, flowGap);

   if (splitNeeded)
      splitBound = findSplitBound (searchPt, flowGap);
   else
      splitBound = 0.0;

   if (resAltOrRest ())
      splitChgPts (searchPt, splitBound);
   else
      {
      success = mySelector_->myHeurAtor ()->tempCommit (1.0);

      stronglyAssert (! success);
      }

   mySplitter_->finishFlowMon ();
   }

//------------------------------------------------------------------------------

WitSplitPt * WitSsPeMgr::findLowestZeroPt ()
   {
   WitSplitPt * lowZeroPt;
   WitSelPt *   lowSelPt;
   int          lowPartIdx;
   WitSplitPt * theZeroPt;
   WitSelPt *   theSelPt;
   int          thePartIdx;

   WitObjStItr <WitSplitPt> theItr;

   lowZeroPt  = NULL;
   lowSelPt   = NULL;
   lowPartIdx = -1;

   theItr.attachTo (zeroPts_);

   while (theItr.advance (theZeroPt))
      {
      theSelPt   = theZeroPt->mySelPt_;
      thePartIdx = theSelPt->mySortPart ()->sortedPartIndex ();

      if (lowZeroPt != NULL)
         {
         if (thePartIdx > lowPartIdx)
            continue;

         if (thePartIdx == lowPartIdx)
            if (theSelPt->caseIndex () >= lowSelPt->caseIndex ())
               continue;
         }
            
      lowZeroPt  = theZeroPt;
      lowSelPt   = theSelPt;
      lowPartIdx = thePartIdx;
      }

   return lowZeroPt;
   }

//------------------------------------------------------------------------------

double WitSsPeMgr::findSplitBound (WitSplitPt * searchPt, double theFlowVol)
   {
   WitBoolean success;
   double     splitBound;

   success = tempCommForSearch (searchPt, mySplitter_->splitRes_);

   if (success)
      splitBound = binarySearch (searchPt, theFlowVol);
   else
      {
      nBSsSkipped_ ++;

      splitBound = 0.0;
      }

   return splitBound;
   }

//------------------------------------------------------------------------------

double WitSsPeMgr::binarySearch (WitSplitPt * searchPt, double theFlowVol)
   {
   int        upperGP;
   int        lowerGP;
   int        midGP;
   WitBoolean success;

   nBSsDone_ ++;

   lowerGP  = 1;
   upperGP  = ceil (theFlowVol / mySplitter_->splitRes_);

   stronglyAssert (upperGP >= 2);

   while (upperGP - lowerGP > 1)
      {
      midGP   = (lowerGP + upperGP) / 2;

      success = tempCommForSearch (searchPt, midGP * mySplitter_->splitRes_);

      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
      }

   return (lowerGP * mySplitter_->splitRes_);
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::splitChgPts (WitSplitPt * searchPt, double splitBound)
   {
   WitSplitPt * theSplitPt;

   WitObjStack <WitSplitPt> chgSplitPts (myProblem ());
   WitObjStItr <WitSplitPt> theItr;

   nBatches_ ++;

   findChgSplitPts (chgSplitPts);

   theItr.attachTo (chgSplitPts);

   while (theItr.advance (theSplitPt))
      {
      stronglyAssert (theSplitPt->totFlowVol_ < -0.5);

      theSplitPt->totFlowVol_ = 0.0;
      }

   compChgPtFlowVols ();

   theItr.attachTo (chgSplitPts);

   while (theItr.advance (theSplitPt))
      {
      if (theSplitPt->totFlowVol_ > NET_TOL)
         {
         theSplitPt->splitSelection (theSplitPt->totFlowVol_);

         mySplitter_->mySplitCntr_->countCurSplits ();
         }

      theSplitPt->totFlowVol_ = -1.0;
      }
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::compChgPtFlowVols ()
   {
   WitSelPt *   theSelPt;
   double       incFlowVol;
   WitSplitPt * theSplitPt;

   WitPairStItr <WitSelPt, double> theItr;

   theItr.attachTo (mySplitter_->okFlowPairs_);

   while (theItr.advance (theSelPt, incFlowVol))
      if (theSelPt->isSplit ())
         {  
         theSplitPt = theSelPt->mySplitPt ();

         if (theSplitPt->totFlowVol_ > -0.5)
            theSplitPt->totFlowVol_ += incFlowVol;
         }
   }

//------------------------------------------------------------------------------

WitBoolean WitSsPeMgr::tempCommForSearch (
      WitSplitPt * searchPt, 
      double       searchVol)
   {
   WitBoolean success;

   stronglyAssert (searchVol >= 0.0);

   stronglyAssert (searchPt->netSearchVol_ < -0.5);

   searchPt->netSearchVol_ = searchVol;

   success                 = tempCommDiscZeroPts ();

   searchPt->netSearchVol_ = -1.0;

   return success;
   }

//------------------------------------------------------------------------------

WitBoolean WitSsPeMgr::tempCommDiscZeroPts ()
   {
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theZeroPt;
   WitBoolean               success;

   theItr.attachTo (zeroPts_);

   while (theItr.advance (theZeroPt))
      {
      stronglyAssert (theZeroPt->netSearchVol_ < -0.5);

      theZeroPt->netSearchVol_ = 0.0;
      }

   success = mySelector_->myHeurAtor ()->tempCommit (1.0);

   theItr.attachTo (zeroPts_);

   while (theItr.advance (theZeroPt))
      theZeroPt->netSearchVol_ = -1.0;

   return success;
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::findChgSplitPts (WitObjStack <WitSplitPt> & chgSplitPts)
   {
   WitSelPt * theSelPt;

   WitObjStack <WitSelPt> chgSelPts (myProblem ());

   findHypoChanges (chgSelPts);

   while (chgSelPts.pop (theSelPt))
      {
      if (! theSelPt->isSplit ())
         mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));

      chgSplitPts.push (theSelPt->mySplitPt ());
      }
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::findHypoChanges (WitObjStack <WitSelPt> & chgSelPts)
   {
   WitSelPt *     altSelPt;
   WitSelCand *   savedSelCand;
   WitBopEntry *  theBopEnt;
   WitPeriod      thePer;
   WitConsEntry * theConsEnt;
   WitSelPt *     modSelPt;

   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());

   if (! mySelector_->pendingPts_.isEmpty ())
      {
      altSelPt     = mySelector_->pendingPts_.firstObject ();

      savedSelCand = altSelPt->selSelCand ();

      altSelPt->tempAlterSel ();
      }
   else
      altSelPt = NULL;

   myExpRest_->startTempMode ();

   myExpRest_->updatePsSup ();

   myRtAnalyzer_->findRoutingMods (modBopEntPers, modConsEntPers);

   myExpRest_->finishTempMode ();

   chgSelPts.clear ();

   while (modBopEntPers.pop (theBopEnt, thePer))
      {
      modSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);

      chgSelPts.push (modSelPt);
      }

   while (modConsEntPers.pop (theConsEnt, thePer))
      {
      modSelPt =
         mySelector_->myCmrMgr ()->mySelPt (theConsEnt->myBomEnt (), thePer);

      chgSelPts.push (modSelPt);
      }

   if (altSelPt != NULL)
      {
      altSelPt->restoreSel (savedSelCand);

      if (! chgSelPts.contains (altSelPt))
         chgSelPts.push (altSelPt);
      }
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::clearSplitItr ()
   {
   WitObjStack <WitSplitPt> revSplitPts (myProblem ());
   WitSplitPt *             theSplitPt;

   zeroPts_.clear ();

   mySplitter_->mySplitPts_.revCopyInto (revSplitPts);

   mySplitter_->mySplitPts_.clear ();

   while (revSplitPts.pop (theSplitPt))
      if (theSplitPt->revSplitList_.isEmpty ())
         delete theSplitPt;
      else
         mySplitter_->mySplitPts_.push (theSplitPt);
   }

//------------------------------------------------------------------------------

WitBoolean WitSsPeMgr::resAltOrRest ()
   {
   return
         mySelector_->failResAlt_
      || myExpRest_ ->failRestShortOnly ();
   }
@


1.34
log
@Continued implementation of sel-split for pen-exec,
@
text
@@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@d46 1
a46 1
      nSplitCPs_    (0)
d62 3
a64 3
         "# SSPE BS's done:       %7d\n"
         "# SSPE BS's skipped:    %7d\n"
         "# SplitChgPts calls:    %7d\n",
d67 1
a67 1
         nSplitCPs_);
d135 1
a135 1
      if (mySplitter_->splitIsNeeded (theSelPt, flowGap))
a278 2
      mySplitter_->resetFlowMon ();

d286 2
a287 3
   splitNeeded = mySplitter_->splitIsNeeded (searchPt->mySelPt_, flowGap);

   mySplitter_->finishFlowMon ();
d294 3
a296 1
   if (! resAltOrRest ())
a300 2
         
      return;
d303 1
a303 1
   splitChgPts (searchPt, splitBound);
a404 1
   WitBoolean   success;
d409 1
a409 1
   nSplitCPs_ ++;
d422 1
a422 3
   success = tempCommForSearch (searchPt, splitBound);

   stronglyAssert (success);
d437 22
@


1.32
log
@Continued implementation of sel-split for pen-exec.
@
text
@d37 1
a37 1
      WitProbAssoc     (theSelector),
d39 8
a46 16
      mySelector_      (theSelector),
      mySplitter_      (theSelector->mySplitter ()),
      myExpRest_       (theSelector->myExpRest ()),
      myRtAnalyzer_    (theSelector->myRtAnalyzer ()),
      zeroPts_         (myProblem ()),
      nTCsSkipped_     (0),
      nBSsDone_        (0),
      nBSsSkipped_     (0),
      fastMode_        (witTRUE),
      nettedSplitPts_  (myProblem ()),
      searchPart_      (NULL),
      firstTCActive_   (witFALSE),
      binSearchActive_ (witFALSE),
      nDblsAtSP_       (-1),
      nPersAtSP_       (-1),
      nNettedAtSP_     (-1)
d62 3
a64 4
         "# Temp-Commits skipped:    %7d\n"
         "# SSPE BS's    done:       %7d\n"
         "# SSPE BS's    skipped:    %7d\n\n",
         nTCsSkipped_,
d66 2
a67 1
         nBSsSkipped_);
d100 3
a102 7
         {
         if (mySelector_->myHeurAtor ()->failedOn1 ())
            nTCsSkipped_ ++;

         else if (mySelector_->myHeurAtor ()->tempCommit (1.0))
            scNeeded = witFALSE;
         }
a124 69
void WitSsPeMgr::preCommit ()
   {
   if (fastMode_)
      {
      if (binSearchActive_)
         {
         restoreNetSplitsToSP ();

         return;
         }

      nettedSplitPts_.clear ();
      }

   mySplitter_->initNetSplitLists ();
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::recCommitItr (WitPart * thePart)
   {
   stronglyAssert (fastMode_);

   if (firstTCActive_)
      if (thePart == searchPart_)
         {
         nDblsAtSP_   = mySelector_->myHeurAtor ()->myDblArch ()->nSavedVals ();
         nPersAtSP_   = mySelector_->myHeurAtor ()->myPerArch ()->nSavedVals ();

         nNettedAtSP_ = nettedSplitPts_.nElements ();
         }
   }

//------------------------------------------------------------------------------

WitBoolean WitSsPeMgr::skipCommitItr (WitPart * thePart)
   {
   stronglyAssert (fastMode_);

   if (binSearchActive_)
      if (thePart->sortedPartIndex () > searchPart_->sortedPartIndex ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::startSplitExp (WitSplitPt * theSplitPt, double toSplitVol)
   {
   theSplitPt->startSplitExp (toSplitVol);

   if (fastMode_)
      nettedSplitPts_.push (theSplitPt);
   }

//------------------------------------------------------------------------------

WitBoolean WitSsPeMgr::restoreNeeded ()
   {
   if (fastMode_)
      if (searchPart_ != NULL)
         return witFALSE;

   return witTRUE;
   }

//------------------------------------------------------------------------------

a357 11
   if (fastMode_)
      {
      stronglyAssert (searchPart_ == NULL);

      searchPart_    = searchPt->mySelPt_->myFillPart ();

      nDblsAtSP_     = -1;

      firstTCActive_ = witTRUE;
      }

a359 9
   if (fastMode_)
      {
      firstTCActive_ = witFALSE;

      stronglyAssert (nDblsAtSP_ >= 0);

      restoreHeurToSP ();
      }

a368 7
   if (fastMode_)
      {
      searchPart_ = NULL;

      mySplitter_->restoreAllVals ();
      }

a380 3
   if (fastMode_)
      binSearchActive_ = witTRUE;

a393 3
      if (fastMode_)
         restoreHeurToSP ();

a399 3
   if (fastMode_)
      binSearchActive_ = witFALSE;

d413 2
a598 31
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::restoreNetSplitsToSP ()
   {
   int          nNettedPts;
   WitSplitPt * theSplitPt;

   stronglyAssert (fastMode_);

   nNettedPts = nettedSplitPts_.nElements ();

   while (nNettedPts > nNettedAtSP_)
      {
      nettedSplitPts_.pop (theSplitPt);

      theSplitPt->initNetSplitList ();

      nNettedPts --;
      }
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::restoreHeurToSP ()
   {
   stronglyAssert (searchPart_ != NULL);

   mySelector_->myHeurAtor ()->myDblArch ()->restoreAllExcept (nDblsAtSP_);
   mySelector_->myHeurAtor ()->myPerArch ()->restoreAllExcept (nPersAtSP_);
@


1.31
log
@Continued implemenation of sel-split fpr pen-exec.
@
text
@d30 1
d37 1
a37 1
      WitProbAssoc  (theSelector),
d39 16
a54 8
      mySelector_   (theSelector),
      mySplitter_   (theSelector->mySplitter ()),
      myExpRest_    (theSelector->myExpRest ()),
      myRtAnalyzer_ (theSelector->myRtAnalyzer ()),
      zeroPts_      (myProblem ()),
      nTCsSkipped_  (0),
      nBSsDone_     (0),
      nBSsSkipped_  (0)
d56 1
a56 1
   witAssert (mySelector_->selSplit ());
d58 1
a58 1
   witAssert (myGlobalComp ()->penExec ());
d137 69
d288 1
a288 1
   witAssert (zeroPts_.isEmpty ());
a435 4
   float      splitRes;
   int        upperGP;
   int        lowerGP;
   int        midGP;
d437 14
d452 5
a456 1
   splitRes = mySplitter_->splitRes_;
d458 2
a459 1
   success  = tempCommForSearch (searchPt, splitRes);
d461 3
a463 1
   if (! success)
d467 8
a474 1
      return 0.0;
d477 15
d495 1
a495 1
   upperGP  = ceil (theFlowVol / splitRes);
d497 1
a497 1
   witAssert (upperGP >= 2);
d503 4
a506 1
      success = tempCommForSearch (searchPt, midGP * splitRes);
d514 4
a517 1
   return (lowerGP * splitRes);
d536 1
a536 1
      witAssert (theSplitPt->totFlowVol_ < -0.5);
d543 1
a543 1
   witAssert (success);
d568 1
a568 1
   witAssert (searchVol >= 0.0);
d570 1
a570 1
   witAssert (searchPt->netSearchVol_ < -0.5);
d574 1
a574 1
   success = tempCommDiscZeroPts ();
d593 1
a593 1
      witAssert (theZeroPt->netSearchVol_ < -0.5);
d714 31
@


1.30
log
@Continued implementation of sel-split for pen-exec.
@
text
@d43 3
a45 1
      nTCsSkipped_  (0)
d60 7
a66 1
      fprintf (msgFile (), "# TCs skipped:       %7d\n\n", nTCsSkipped_);
d99 1
d105 1
d366 12
a377 1
   lowerGP  = 0;
@


1.29
log
@Continued implementation of sel-split for pen-exec.
@
text
@d42 2
a43 1
      zeroPts_      (myProblem ())
d57 2
d91 5
a95 1
         scNeeded = ! mySelector_->myHeurAtor ()->tempCommit (1.0);
@


1.28
log
@Continued implementation of sel-split for pen-exec.
@
text
@d177 2
@


1.27
log
@Continued implementation of sel-split for pen-exec.
@
text
@d22 1
d131 2
a132 1
   WitBoolean  success;
d138 2
d143 3
a145 1
   while (witTRUE)
d147 5
d160 1
a160 3
      zeroPts_.clear ();

      delEmptySplitPts ();
d162 1
a162 2
      if (! resAltOrRest ())
         myMsgFac () ("internalErrorFmsg", "WitSsPeMgr::splitCommit");
d171 2
a172 5
      success = mySelector_->myHeurAtor ()->tempCommit (1.0);

      if (success)
         {
         mySelector_->myHeurAtor ()->permCommit1SS ();
d174 2
a175 3
         break;
         }
      }
d191 2
a195 2
   witAssert (zeroPts_.isEmpty ());

d201 3
d205 1
d261 1
a261 2
      if (zeroPts_.isEmpty ())
         myMsgFac () ("internalErrorFmsg", "WitSsPeMgr::splitSels (1)");
d285 1
a285 2
      if (success)
         myMsgFac () ("internalErrorFmsg", "WitSsPeMgr::splitSels (2)");
d397 1
d400 3
d536 1
a536 1
void WitSsPeMgr::delEmptySplitPts ()
d540 2
@


1.26
log
@Continued implementation of sel-split for pen-exec.
@
text
@d75 1
a75 1
      if (netQty <= 0.0)
a81 8
      if (! mySelector_->failResAlt_)
         if (! myExpRest_->failRestShortOnly ())
            {
            mySplitter_->finishFlowMon ();

            break;
            }

d153 2
a154 3
      if (! myExpRest_->failRestShortOnly ())
         if (! mySelector_->failResAlt_)
            myMsgFac () ("internalErrorFmsg", "WitSsPeMgr::splitCommit");
d192 1
a192 1
   while (witTRUE)
d194 1
a194 4
      if (! myExpRest_->failRestShortOnly ())
         if (! mySelector_->failResAlt_)
            {
            unresFound = witTRUE;
d196 2
a197 2
            return;
            }
a204 3

      if (splitFound)
         return;
a264 6
   if (! myExpRest_->failRestShortOnly ())
      if (! mySelector_->failResAlt_)
         myMsgFac () ("internalErrorFmsg", "WitSsPeMgr::splitSels (2)");
            //
            // searchPt should always be a resolving alt in this case.

d274 10
a355 5

      if (! success)
         if (! myExpRest_->failRestShortOnly ())
            if (! mySelector_->failResAlt_)
               myMsgFac () ("internalErrorFmsg", "WitSsPeMgr::findSplitBound");
d540 9
@


1.25
log
@Continued implementation of sel-split for pen-exec.
@
text
@d95 3
d143 2
a146 2
   unresFound = witFALSE;

a148 9
      success = mySelector_->myHeurAtor ()->tempCommit (1.0);

      if (success)
         {
         mySelector_->myHeurAtor ()->permCommit1SS ();

         break;
         }

d161 4
d171 9
d182 2
a187 2

   mySplitter_->splitCommActive_ = witFALSE;
d268 3
a272 2
      witAssert (! zeroPts_.isEmpty ());

d282 1
a282 1
         myMsgFac () ("internalErrorFmsg", "WitSsPeMgr::splitSels");
d367 5
@


1.24
log
@Continued implementation of sel-split for pen-exec.
@
text
@a48 3

   if (myGlobalComp ()->stockReallocation ())
      myMsgFac () ("nyiInSsPeSmsg", "Stock reallocation");
d312 1
a312 1
      thePartIdx = theSelPt->sortPart ()->sortedPartIndex ();
a468 2
#if 1

a525 2

#endif
@


1.23
log
@Continued implementation of sel-split for pen-exec.
@
text
@a49 3
   if (mySelector_->multiExec ())
      myMsgFac () ("nyiInSsPeSmsg", "Multi-Exec");

d297 3
a299 2
   int          initIdx;
   int          lowIdx;
d301 2
a302 2
   int          theIdx;
   WitSplitPt * lowZeroPt;
d306 3
a308 3
   initIdx = myProblem ()->myCompMgr ()->nParts () * 10;

   lowIdx  = initIdx;
d314 2
a315 1
      theIdx = theZeroPt->mySelPt_->sspeIndex ();
d317 1
a317 1
      if (theIdx < lowIdx)
d319 6
a324 2
         lowIdx    = theIdx;
         lowZeroPt = theZeroPt;
d326 4
a330 2

   witAssert (lowIdx < initIdx);
@


1.22
log
@Continued implementation of sel-split for pen-exec,
@
text
@a49 3
   if (mySelector_->buildAhead ())
      myMsgFac () ("nyiInSsPeSmsg", "Build-Ahead");

d126 1
a126 1
   WitObjStack <WitSelPt> modSelPts (myProblem ());
d128 1
a128 1
   findHypoMods (modSelPts);
d130 1
a130 1
   while (modSelPts.pop (theSelPt))
d210 1
a210 1
      addedZeroPts = addModPtsToZeroPts ();
d224 1
a224 1
WitBoolean WitSsPeMgr::addModPtsToZeroPts ()
d229 1
a229 1
   WitObjStack <WitSelPt> modSelPts (myProblem ());
d233 1
a233 1
   findHypoMods (modSelPts);
d235 1
a235 1
   while (modSelPts.pop (theSelPt))
d293 1
a293 1
   splitModPts (searchPt, splitBound);
d300 1
d308 3
a310 1
   lowIdx = myProblem ()->myCompMgr ()->nParts ();
d325 1
a325 1
   witAssert (lowIdx < myProblem ()->myCompMgr ()->nParts ());
d364 1
a364 1
void WitSsPeMgr::splitModPts (WitSplitPt * searchPt, double splitBound)
d369 1
a369 1
   WitObjStack <WitSplitPt> modSplitPts (myProblem ());
d372 1
a372 1
   findModSplitPts (modSplitPts);
d374 1
a374 1
   theItr.attachTo (modSplitPts);
d387 1
a387 1
   theItr.attachTo (modSplitPts);
d448 1
a448 1
void WitSsPeMgr::findModSplitPts (WitObjStack <WitSplitPt> & modSplitPts)
d452 1
a452 1
   WitObjStack <WitSelPt> modSelPts (myProblem ());
d454 1
a454 1
   findHypoMods (modSelPts);
d456 1
a456 1
   while (modSelPts.pop (theSelPt))
d461 1
a461 1
      modSplitPts.push (theSelPt->mySplitPt ());
d467 3
a469 1
void WitSsPeMgr::findHypoMods (WitObjStack <WitSelPt> & modSelPts)
d472 1
d476 1
a476 1
   WitSelPt *     theSelPt;
d483 1
a483 1
      altSelPt = mySelector_->pendingPts_.firstObject ();
d485 3
a487 1
      altSelPt->setMrSelPrevSel (witTRUE);
d500 1
a500 4
   if (altSelPt != NULL)
      altSelPt->setMrSelPrevSel (witFALSE);

   modSelPts.clear ();
d504 1
a504 1
      theSelPt =
d507 1
a507 1
      modSelPts.push (theSelPt);
d512 1
a512 1
      theSelPt =
d515 9
a523 1
      modSelPts.push (theSelPt);
d526 2
@


1.21
log
@Continued implementation of sel-split for pen-exec.
@
text
@a123 38
void WitSsPeMgr::mergeSplitBopEnts (
      WitPart *        thePart,
      WitPeriod        expPer,
      WitBopEntStack & expBopEnts)
   {
   WitSelPt *    theSelPt;
   WitSplitPt *  theSplitPt;
   WitSelCand *  theSelCand;
   double        splitBound;
   WitBopEntry * theBopEnt;

   WitPairStItr <WitSelCand, double> theItr;

   theSelPt = mySelector_->myPmrMgr ()->mySelPt (thePart, expPer);

   if (! theSelPt->isSplit ())
      return;

   theSplitPt = theSelPt->mySplitPt ();

   theItr.attachTo (theSplitPt->revSplitList_);

   while (theItr.advance (theSelCand, splitBound))
      {
      theBopEnt = WitPmrMgr::theBopEntFor (theSelCand->myPmrCand ());

      if (! expBopEnts.contains (theBopEnt))
         expBopEnts.push (theBopEnt);
      }

   theBopEnt = mySelector_->myPmrMgr ()->selBopEntry (thePart, expPer);

   if (! expBopEnts.contains (theBopEnt))
      expBopEnts.push (theBopEnt);
   }

//------------------------------------------------------------------------------

@


1.20
log
@Continued implementation of sel-split for pen-exec.
@
text
@d164 2
a165 15
   WitBopEntry *  theBopEnt;
   WitPeriod      thePer;
   WitSelPt *     theSelPt;
   double         flowGap;
   WitConsEntry * theConsEnt;

   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());

   findHypoMods (modBopEntPers, modConsEntPers);

   while (modBopEntPers.pop (theBopEnt, thePer))
      {
      theSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);
d167 1
a167 3
      if (mySplitter_->splitIsNeeded (theSelPt, flowGap))
         return witTRUE;
      }
d169 1
a169 4
   while (modConsEntPers.pop (theConsEnt, thePer))
      {
      theSelPt =
         mySelector_->myCmrMgr ()->mySelPt (theConsEnt->myBomEnt (), thePer);
d171 1
a173 1
      }
d267 2
a268 5
   WitBoolean     addedZeroPts;
   WitBopEntry *  theBopEnt;
   WitPeriod      thePer;
   WitSelPt *     theSelPt;
   WitConsEntry * theConsEnt;
d270 1
a270 2
   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());
d274 1
a274 1
   findHypoMods (modBopEntPers, modConsEntPers);
d276 1
a276 1
   while (modBopEntPers.pop (theBopEnt, thePer))
d278 2
a279 2
      theSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);
d281 2
a282 2
      addToZeroPts (theSelPt, addedZeroPts);
      }
d284 1
a284 4
   while (modConsEntPers.pop (theConsEnt, thePer))
      {
      theSelPt =
         mySelector_->myCmrMgr ()->mySelPt (theConsEnt->myBomEnt (), thePer);
d286 1
a286 1
      addToZeroPts (theSelPt, addedZeroPts);
a293 15
void WitSsPeMgr::addToZeroPts (WitSelPt * theSelPt, WitBoolean & addedZeroPts)
   {
   if (! theSelPt->isSplit ())
      mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));

   else if (zeroPts_.contains (theSelPt->mySplitPt ()))
      return;

   zeroPts_.push (theSelPt->mySplitPt ());

   addedZeroPts = witTRUE;
   }

//------------------------------------------------------------------------------

d488 1
a488 7
   WitBopEntry *  theBopEnt;
   WitPeriod      thePer;
   WitSelPt *     theSelPt;
   WitConsEntry * theConsEnt;

   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());
d490 1
a490 1
   findHypoMods (modBopEntPers, modConsEntPers);
d492 1
a492 1
   modSplitPts.clear ();
d494 1
a494 1
   while (modBopEntPers.pop (theBopEnt, thePer))
d496 2
a497 2
      theSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);
d499 1
a499 9
      addToModSplitPts (theSelPt, modSplitPts);
      }

   while (modConsEntPers.pop (theConsEnt, thePer))
      {
      theSelPt =
         mySelector_->myCmrMgr ()->mySelPt (theConsEnt->myBomEnt (), thePer);

      addToModSplitPts (theSelPt, modSplitPts);
d505 1
a505 15
void WitSsPeMgr::addToModSplitPts (
      WitSelPt *                 theSelPt,
      WitObjStack <WitSplitPt> & modSplitPts)
   {
   if (! theSelPt->isSplit ())
      mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));

   modSplitPts.push (theSelPt->mySplitPt ());
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::findHypoMods (
      WitBopEntPerStack &  modBopEntPers,
      WitConsEntPerStack & modConsEntPers)
d507 1
d509 1
a511 4
   WitPart *      thePart;
   WitPeriod      expPer;
   WitBomEntry *  theBomEnt;
   WitPeriod      execPer;
d513 2
a514 2
   theBopEnt  = NULL;
   theConsEnt = NULL;
d518 1
a518 1
      theSelPt = mySelector_->pendingPts_.firstObject ();
d520 1
a520 16
      if (WitPmrMgr::getPmrCoords (theSelPt, thePart, expPer))
         {
         theBopEnt = mySelector_->myPmrMgr ()->selBopEntry (thePart, expPer);

         mySelector_->myPmrMgr ()->setPrevSel (theBopEnt, expPer, witTRUE);
         }
      else if (WitCmrMgr::getCmrCoords (theSelPt, theBomEnt, execPer))
         {
         theConsEnt =
            mySelector_->myCmrMgr ()->selConsEntry (theBomEnt, execPer);

         mySelector_->myCmrMgr ()->setPrevSel (theConsEnt, execPer, witTRUE);
         }
      else
         myMsgFac () ("nyiInSsPeSmsg",
            "Non-MR resolving alteration in findHypoMods");
d522 2
d533 20
a552 4
   if (theBopEnt != NULL)
      mySelector_->myPmrMgr ()->setPrevSel (theBopEnt,  expPer,  witFALSE);
   else if (theConsEnt != NULL)
      mySelector_->myCmrMgr ()->setPrevSel (theConsEnt, execPer, witFALSE);
@


1.19
log
@Continued implemenation of sel-split for pen-exec.
@
text
@d26 1
d148 1
a148 1
      theBopEnt = WitPmrMgr::theBopEntFor (theSelCand->myMrCandPmr ());
d164 5
a168 4
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
   WitSelPt *    theSelPt;
   double        flowGap;
d170 2
a171 1
   WitBopEntPerStack modBopEntPers (myProblem ());
d173 1
a173 1
   findHypoMods (modBopEntPers);
d184 9
d252 1
a252 1
   WitBoolean addedAny;
d269 1
a269 1
      addedAny = addModPtsToZeroPts ();
d271 1
a271 1
      if (! addedAny)
d285 5
a289 4
   WitBoolean    addedAny;
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
   WitSelPt *    theSelPt;
d291 2
a292 1
   WitBopEntPerStack modBopEntPers (myProblem ());
d294 1
a294 1
   addedAny = witFALSE;
d296 1
a296 1
   findHypoMods (modBopEntPers);
d303 2
a304 7
      if (theSelPt->isSplit ())
         {
         if (zeroPts_.contains (theSelPt->mySplitPt ()))
            continue;
         }
      else
         mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));
d306 4
a309 1
      zeroPts_.push (theSelPt->mySplitPt ());
d311 1
a311 1
      addedAny = witTRUE;
d314 16
a329 1
   return addedAny;
a382 1
   WitSelPt *   theSelPt;
d394 1
a394 5
      theSelPt = theZeroPt->mySelPt_;

      witAssert (theSelPt->myMrPtPmrIfAny () != NULL);

      theIdx = theSelPt->myFillPart ()->sortedPartIndex ();
d528 4
a531 3
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
   WitSelPt *    theSelPt;
d533 2
a534 1
   WitBopEntPerStack modBopEntPers (myProblem ());
d536 1
a536 1
   findHypoMods (modBopEntPers);
d545 7
a551 2
      if (! theSelPt->isSplit ())
         mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));
d553 1
a553 1
      modSplitPts.push (theSelPt->mySplitPt ());
d559 3
a561 1
void WitSsPeMgr::findHypoMods (WitBopEntPerStack & modBopEntPers)
d563 7
a569 4
   WitBopEntry * theBopEnt;
   WitSelPt *    theSelPt;
   WitPart *     thePart;
   WitPeriod     expPer;
d571 11
a581 1
   WitConsEntPerStack modConsEntPers (myProblem ());
d583 2
a584 1
   theBopEnt = NULL;
d596 7
d605 1
a605 1
            "Non-PMR resolving alteration in findHypoMods");
d617 3
a619 4
      mySelector_->myPmrMgr ()->setPrevSel (theBopEnt, expPer, witFALSE);

   if (! modConsEntPers.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "ConsEnt split points in findHypoMods");
@


1.18
log
@Continued implementation of sel-split for pen-exec.
@
text
@d70 1
d87 1
a87 3
         myExpRest_->updatePsSup ();

         return;
d92 5
a96 2
            myMsgFac () ("nyiInSsPeSmsg", 
               "Unresolveable fundamental shortage in commitMaxQty");
d103 6
a108 1
         splitCommit ();
d117 2
d186 1
a186 1
void WitSsPeMgr::splitCommit ()
d189 2
d195 2
d202 9
d213 13
a225 1
      splitItr ();
a227 2
   mySelector_->myHeurAtor ()->permCommit1SS ();

d238 1
a238 1
void WitSsPeMgr::splitItr ()
d241 3
a243 2
   WitBoolean success;
   WitSelPt * theSelPt;
d251 5
a255 2
            myMsgFac () ("nyiInSsPeSmsg",
               "Unresolveable fundamental shortage in splitItr");
d260 1
a260 1
         break;
d262 1
a262 1
      success = tempCommDiscZeroPts ();
d264 2
a265 6
      if (success)
         {
         splitSels ();

         break;
         }
a266 11

   zeroPts_.clear ();

   delEmptySplitPts ();

   myExpRest_->updatePsSup ();

   if (mySelector_->getPendingPt (theSelPt))
      mySelector_->alterSelection (theSelPt);

   myRtAnalyzer_->modifyRouting ();
d334 3
a336 2
         myMsgFac () ("nyiInSsPeSmsg",
            "Unresolveable fundamental shortage in splitSels");
@


1.17
log
@Continued implementation of sel-split for pen-exec.
@
text
@d230 1
a230 1
         splitatLowest ();
d286 1
a286 1
void WitSsPeMgr::splitatLowest ()
d290 5
d300 2
d311 15
a325 1
   splitSels (searchPt);
a361 33
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::splitSels (WitSplitPt * searchPt)
   {
   WitBoolean success;
   WitBoolean splitNeeded;
   double     flowGap;
   double     splitBound;

   mySplitter_->startFlowMon ();

   success = tempCommDiscZeroPts ();

   if (success)
      myMsgFac () ("internalErrorFmsg", "WitSsPeMgr::splitSels");

   if (! myExpRest_->failRestShortOnly ())
      if (! mySelector_->failResAlt_)
         myMsgFac () ("nyiInSsPeSmsg",
            "Unresolveable fundamental shortage in splitSels");

   splitNeeded = mySplitter_->splitIsNeeded (searchPt->mySelPt_, flowGap);

   mySplitter_->finishFlowMon ();

   if (splitNeeded)
      splitBound = findSplitBound (searchPt, flowGap);
   else
      splitBound = 0.0;

   splitModPts (searchPt, splitBound);
@


1.16
log
@Continued implementation of sel-split fpr pen-exec.
@
text
@d208 3
a210 3
   WitSelPt *   theSelPt;
   WitSplitPt * searchPt;
   WitBoolean   success;
d221 1
a221 1
      theSelPt = findTopModSelPt ();
d223 1
a223 1
      if (theSelPt == NULL)
d226 1
a226 6
      if (! theSelPt->isSplit ())
         mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));

      searchPt = theSelPt->mySplitPt ();

      success  = tempCommForSearch (searchPt, 0.0);
d230 1
a230 1
         splitSels (searchPt);
a233 2

      zeroPts_.push (searchPt);
d250 1
a250 1
WitSelPt * WitSsPeMgr::findTopModSelPt ()
d252 5
a256 2
   WitSelPt *        topSelPt;
   int               topIdx;
a257 4
   WitBopEntry *     theBopEnt;
   WitPeriod         thePer;
   WitSelPt *        theSelPt;
   int               theIdx;
d259 1
a259 2
   topSelPt = NULL;
   topIdx   = -1;
d269 1
d272 18
d291 1
a291 1
      theIdx = theBopEnt->myPart ()->sortedPartIndex ();
d293 39
a331 1
      if (theIdx > topIdx)
d333 2
a334 2
         topSelPt = theSelPt;
         topIdx   = theIdx;
d338 3
a340 1
   return topSelPt;
a391 2

   midGP = 1;
@


1.15
log
@Continued implementation of sel-split for pen-exec.
@
text
@d19 1
d70 1
d91 5
a95 3
      if (! myExpRest_->failRestShortOnly ())
         myMsgFac () ("nyiInSsPeSmsg", "Fundamental shortage in commitMaxQty");
         
d103 1
d105 37
d143 5
d217 3
a219 1
         myMsgFac () ("nyiInSsPeSmsg", "Fundamental shortage in splitItr");
d249 3
d310 3
a312 1
      myMsgFac () ("nyiInSsPeSmsg", "Fundamental shortage in splitSels");
d338 1
a338 1
   lowerGP  = 1;
d474 5
d481 16
a496 1
   witAssert (myExpRest_->failRestShortOnly ());
d505 3
@


1.14
log
@Continued implementation of sel-split for pen-exec.
@
text
@d174 3
d185 3
d189 1
d194 1
a194 1
   splitSels (searchPt);
d196 5
a200 1
   zeroPts_.clear ();
d207 1
d212 2
a213 2
   WitPart *         topPart;
   WitPeriod         topPer;
d215 2
a216 1
   topIdx  = -1;
d221 16
a236 11
      if (! isInZeroPts (theBopEnt, thePer))
         if (theBopEnt->myPart ()->sortedPartIndex () > topIdx)
            {
            topPart = theBopEnt->myPart ();
            topPer  = thePer;
            topIdx  = topPart->sortedPartIndex ();
            }

   if (topIdx == -1)
      myMsgFac () ("nyiInSsPeSmsg",
         "No non-zero point mod point in findTopModSelPt");
d238 1
a238 1
   return mySelector_->myPmrMgr ()->mySelPt (topPart, topPer);
d255 1
a255 2
      myMsgFac () ("nyiInSsPeSmsg", 
         "Successful initial tempCommit in splitSels");
d264 19
a282 2
   if (! splitNeeded)
      myMsgFac () ("nyiInSsPeSmsg", "Split not needed in splitSels");
d284 10
a293 1
   splitBound = findSplitBound (searchPt, flowGap);
d295 9
a303 1
   splitModPts (searchPt, splitBound);
a339 62

   delEmptySplitPts ();

   myExpRest_->updatePsSup ();

   myRtAnalyzer_->modifyRouting ();
   }

//------------------------------------------------------------------------------

WitBoolean WitSsPeMgr::isInZeroPts (WitBopEntry * theBopEnt, WitPeriod thePer)
   {
   WitSelPt *               theSelPt;
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theZeroPt;

   theSelPt = mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);

   if (! theSelPt->isSplit ())
      return witFALSE;

   theItr.attachTo (zeroPts_);

   while (theItr.advance (theZeroPt))
      if (theZeroPt == theSelPt->mySplitPt ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

double WitSsPeMgr::findSplitBound (WitSplitPt * searchPt, double theFlowVol)
   {
   float      splitRes;
   int        upperGP;
   int        lowerGP;
   int        midGP;
   WitBoolean success;

   splitRes = mySplitter_->splitRes_;

   lowerGP  = 1;
   upperGP  = ceil (theFlowVol / splitRes);

   witAssert (upperGP >= 2);

   midGP = 1;

   while (upperGP - lowerGP > 1)
      {
      midGP   = (lowerGP + upperGP) / 2;

      success = tempCommForSearch (searchPt, midGP * splitRes);

      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
      }

   return (lowerGP * splitRes);
@


1.13
log
@Continued implementation of sel-split for pen-exec.
@
text
@d68 1
a68 2
   WitPartPerStack theExhPts (myProblem ());
   WitBoolean      scNeeded;
a91 2
      theExhPts.revCopyFrom (myExpRest_->failExhaustReqs_);

d98 2
a99 2

      myExpRest_->updatePsSup (theExhPts);
d139 1
a139 1
      success = tempCommDiscZeroPts (NULL);
d141 1
a141 3
      if (! success)
         addToZeroPts ();
      else if (zeroPts_.isEmpty ())
d143 2
a144 2
      else
         splitSels ();
d159 1
a159 1
void WitSsPeMgr::addToZeroPts ()
d161 19
a179 1
   WitSelPt * theSelPt;
d181 2
a182 2
   if (! myExpRest_->failRestShortOnly ())
      myMsgFac () ("nyiInSsPeSmsg", "Fundamental shortage in addToZeroPts");
d184 2
a185 1
   theSelPt = findTopModSelPt ();
d187 1
a187 2
   if (! theSelPt->isSplit ())
      mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));
d189 1
a189 1
   zeroPts_.push (theSelPt->mySplitPt ());
d196 1
d203 2
a206 8
   if (modBopEntPers.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "Empty mod point set in findTopModSelPt");

   modBopEntPers.pop (theBopEnt, thePer);

   topPart = theBopEnt->myPart ();
   topPer  = thePer;

d209 1
a209 2
         if (theBopEnt->myPart ()->sortedPartIndex () > 
             topPart             ->sortedPartIndex ())
d213 1
d216 4
d225 1
a225 1
WitBoolean WitSsPeMgr::isInZeroPts (WitBopEntry * theBopEnt, WitPeriod thePer)
d227 15
a241 3
   WitSelPt *               theSelPt;
   WitObjStItr <WitSplitPt> theItr;
   WitSplitPt *             theZeroPt;
d243 1
a243 1
   theSelPt = mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);
d245 1
a245 2
   if (! theSelPt->isSplit ())
      return witFALSE;
d247 2
a248 1
   theItr.attachTo (zeroPts_);
d250 1
a250 3
   while (theItr.advance (theZeroPt))
      if (theZeroPt == theSelPt->mySplitPt ())
         return witTRUE;
d252 1
a252 1
   return witFALSE;
d257 1
a257 1
void WitSsPeMgr::splitSels ()
d259 2
a260 2
   WitSplitPt *    theSplitPt;
   WitPartPerStack cumExhPts (myProblem ());
d262 1
d265 3
a267 1
   theItr.attachTo (zeroPts_);
d270 2
a271 1
      splitSel (theSplitPt, cumExhPts);
d273 2
a274 1
   splitUnsearchedPts (cumExhPts);
d276 1
a276 1
   zeroPts_.clear ();
d278 1
a278 1
   myExpRest_->updatePsSup (cumExhPts);
d280 1
a280 2
   myRtAnalyzer_->modifyRouting ();
   }
d282 4
a285 1
//------------------------------------------------------------------------------
d287 2
a288 8
void WitSsPeMgr::splitSel (WitSplitPt * theSplitPt, WitPartPerStack & cumExhPts)
   {
   WitBoolean success;
   WitBoolean splitNeeded;
   double     flowGap;
   double     splitBound;
   WitPart *  thePart;
   WitPeriod  thePer;
d290 1
a290 1
   WitPairStItr <WitPart, WitPeriod> theItr;
d292 1
a292 1
   mySplitter_->startFlowMon ();
d294 2
a295 1
   success = tempCommDiscZeroPts (theSplitPt);
d297 1
a297 3
   if (success)
      myMsgFac () ("nyiInSsPeSmsg", 
         "Successful initial tempCommit in splitSel");
d299 5
a303 2
   if (! myExpRest_->failRestShortOnly ())
      myMsgFac () ("nyiInSsPeSmsg", "Fundamental shortage in splitSel");
d305 1
a305 1
   splitNeeded = mySplitter_->splitIsNeeded (theSplitPt->mySelPt_, flowGap);
d307 2
a308 1
   mySplitter_->finishFlowMon ();
d310 1
a310 3
   if (splitNeeded)
      {
      splitBound = findSplitBound (theSplitPt, flowGap);
d312 3
a314 2
      theSplitPt->splitSelection (splitBound);
      }
d316 1
a316 4
   theItr.attachTo (myExpRest_->failExhaustReqs_);

   while (theItr.advance (thePart, thePer))
      cumExhPts.push (thePart, thePer);
d321 1
a321 1
double WitSsPeMgr::findSplitBound (WitSplitPt * theSplitPt, double theFlowVol)
d342 1
a342 1
      success = tempCommForSearch (theSplitPt, midGP * splitRes);
a354 38
void WitSsPeMgr::splitUnsearchedPts (const WitPartPerStack & cumExhPts)
   {
   WitSplitPt * theSplitPt;
   WitBoolean   success;

   WitObjStack <WitSplitPt> modSplitPts (myProblem ());
   WitObjStItr <WitSplitPt> theItr;

   findModSplitPts (modSplitPts, cumExhPts);

   theItr.attachTo (modSplitPts);

   while (theItr.advance (theSplitPt))
      {
      witAssert (theSplitPt->totFlowVol_ < -0.5);

      theSplitPt->totFlowVol_ = 0.0;
      }

   success = tempCommDiscZeroPts (NULL);

   witAssert (success);

   theItr.attachTo (modSplitPts);

   while (theItr.advance (theSplitPt))
      {
      if (theSplitPt->totFlowVol_ > NET_TOL)
         theSplitPt->splitSelection (theSplitPt->totFlowVol_);

      theSplitPt->totFlowVol_ = -1.0;
      }

   delEmptySplitPts ();
   }

//------------------------------------------------------------------------------

d367 1
a367 1
   success = tempCommDiscZeroPts (searchPt);
d376 1
a376 1
WitBoolean WitSsPeMgr::tempCommDiscZeroPts (WitSplitPt * exceptPt)
d385 2
a386 3
      if (theZeroPt != exceptPt)
         {
         witAssert (theZeroPt->netSearchVol_ < -0.5);
d388 2
a389 2
         theZeroPt->netSearchVol_ = 0.0;
         }
d403 1
a403 3
void WitSsPeMgr::findModSplitPts (
      WitObjStack <WitSplitPt> & modSplitPts,
      const WitPartPerStack &    cumExhPts)
d411 1
a411 1
   findHypoMods (modBopEntPers, cumExhPts);
a430 9
   findHypoMods (modBopEntPers, myExpRest_->failExhaustReqs_);
   }

//------------------------------------------------------------------------------

void WitSsPeMgr::findHypoMods (
      WitBopEntPerStack &     modBopEntPers,
      const WitPartPerStack & theExhPts)
   {
d437 1
a437 1
   myExpRest_->updatePsSup (theExhPts);
@


1.12
log
@Continued implementation of sel-split for pen-exec.
@
text
@d135 1
a135 1
   WitBoolean  splitItrNeeded;
d140 3
a142 1
   splitItrNeeded = witTRUE;
d144 7
a150 2
   while (splitItrNeeded)
      splitItrNeeded = splitItr ();
d164 1
a164 1
WitBoolean WitSsPeMgr::splitItr ()
a165 1
   WitBoolean success;
a166 2
   WitBoolean splitNeeded;
   double     flowGap;
d168 2
a169 1
   mySplitter_->startFlowMon ();
d171 1
a171 1
   success = mySelector_->myHeurAtor ()->tempCommit (1.0);
d173 2
a174 16
   while (! success)
      {
      if (! myExpRest_->failRestShortOnly ())
         myMsgFac () ("nyiInSsPeSmsg", "Fundamental shortage in splitCommit");

      theSelPt    = findTopModSelPt ();

      splitNeeded = mySplitter_->splitIsNeeded (theSelPt, flowGap);

      if (! splitNeeded)
         myMsgFac () ("nyiInSsPeSmsg", "Split not needed in splitCommit");

      if (! theSelPt->isSplit ())
         mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));

      zeroPts_.push (theSelPt->mySplitPt ());
d176 1
a176 13
      mySplitter_->resetFlowMon ();

      success = tempCommDiscZeroPts (NULL);
      }

   mySplitter_->finishFlowMon ();

   if (zeroPts_.isEmpty ())
      return witFALSE;

   splitSels ();

   return witTRUE;
d282 1
a282 2
   if (! splitNeeded)
      myMsgFac () ("nyiInSsPeSmsg", "Split not needed in splitSel");
d284 3
a286 1
   mySplitter_->finishFlowMon ();
d288 2
a289 1
   splitBound = findSplitBound (theSplitPt, flowGap);
a294 2

   theSplitPt->splitSelection (splitBound);
@


1.11
log
@Fixed a subtle bug in sel-split for stock reallocation.
Continued implementation of sel-split for pen-exec.
@
text
@d68 2
a69 5
   WitBoolean resFound;
   WitBoolean prsFound;
   WitSelPt * theSelPt;
   double     flowGap;
   WitBoolean splitFound;
d81 3
a83 2
      if (mySelector_->failResAlt_)
         myMsgFac () ("nyiInSsPeSmsg", "Alteration (case 1)");
d85 1
a85 1
      resFound = mySelector_->failResAlt_;
d87 2
a88 1
      prsFound = myExpRest_->failRestShortOnly ();
d90 4
a93 1
      findSelPtToSplit (theSelPt, flowGap, splitFound);
d95 2
d99 17
a115 2
      if (splitFound)
         splitFound = splitCommit ();
d117 1
a117 3
      if (! splitFound)
         {
         myExpRest_->updatePsSup ();
d119 4
a122 2
         if (resFound)
            mySelector_->alterSelection (theSelPt);
d124 2
a125 3
         else if (! prsFound)
            return;
         }
d127 2
d133 1
a133 1
WitBoolean WitSsPeMgr::splitCommit ()
d135 1
a135 6
   WitBoolean  dummmyBool1;
   WitBoolean  dummmyBool2;
   WitBoolean  dummmyBool3;
   WitBoolean  splitFound;
   WitBoolean  tempCommOK;
   WitBoolean  progress;
a137 2
   witAssert (! mySplitter_->splitCommActive_);

d140 1
a140 5
   splitItr (dummmyBool1, dummmyBool2, splitFound);

   if (splitFound)
      {
      progress = witTRUE;
d142 2
a143 2
      while (progress)
         splitItr (tempCommOK, progress, dummmyBool3);
d145 1
a145 3
      if (tempCommOK)
         mySelector_->myHeurAtor ()->permCommit1SS ();
      }
a152 2

   return splitFound;
d157 1
a157 4
void WitSsPeMgr::splitItr (
      WitBoolean & tempCommOK, 
      WitBoolean & progress,
      WitBoolean & splitFound)
d159 3
a162 5
   WitSelPt * theSelPt;

   progress   = witFALSE;

   splitFound = witFALSE;
d166 1
a166 1
   tempCommOK = mySelector_->myHeurAtor ()->tempCommit (1.0);
d168 1
a168 1
   if (! tempCommOK)
d170 2
a171 2
      if (mySelector_->failResAlt_)
         myMsgFac () ("nyiInSsPeSmsg", "Alteration (case 2)");
d173 1
a173 1
      progress = myExpRest_->failRestShortOnly ();
d175 1
a175 2
      findSelPtToSplit (theSelPt, flowGap, splitFound);
      }
d177 2
a178 1
   mySplitter_->finishFlowMon ();
d180 2
a181 2
   if (splitFound)
      splitSelection (theSelPt, flowGap);
d183 1
a183 1
   mySplitter_->restoreAllVals ();
d185 1
a185 1
   myExpRest_->updatePsSup ();
d187 2
a188 2
   myRtAnalyzer_->modifyRouting ();
   }
d190 1
a190 1
//------------------------------------------------------------------------------
d192 2
a193 8
void WitSsPeMgr::findSelPtToSplit (
      WitSelPt * & theSelPt, 
      double &     flowGap, 
      WitBoolean & splitFound)
   {
   theSelPt   = NULL;
   flowGap    = 0.0;
   splitFound = witFALSE;
d195 1
a195 2
   if (mySelector_->failResAlt_)
      myMsgFac () ("nyiInSsPeSmsg", "Alteration (case 3)");
d197 1
a197 8
   if (mySelector_->failResAlt_)
      mySelector_->getPendingPt (theSelPt);

   else if (myExpRest_->failRestShortOnly ())
      theSelPt = findRestSelPtToSplit ();

   if (theSelPt != NULL)
      splitFound = mySplitter_->splitIsNeeded (theSelPt, flowGap);
d202 1
a202 1
WitSelPt * WitSsPeMgr::findRestSelPtToSplit ()
d213 1
a213 1
      return NULL;
d221 7
a227 6
      if (theBopEnt->myPart ()->sortedPartIndex () > 
          topPart             ->sortedPartIndex ())
         {
         topPart = theBopEnt->myPart ();
         topPer  = thePer;
         }
d234 1
a234 1
void WitSsPeMgr::splitSelection (WitSelPt * theSelPt, double theFlowVol)
d236 3
a238 10
   WitBoolean   searchPtIsNew;
   WitSplitPt * theSplitPt;
   WitBoolean   success;

   searchPtIsNew = ! theSelPt->isSplit ();

   if (searchPtIsNew)
      mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));

   theSplitPt = theSelPt->mySplitPt ();
d240 1
a240 1
   success = tempCommForSearch (theSplitPt, 0.0);
d242 2
a243 2
   if (! success)
      myMsgFac () ("nyiInSsPeSmsg", "Temp-Commit failure with searchVol == 0");
d245 1
a245 1
   success = tempCommForSearch (theSplitPt, mySplitter_->splitRes_);
d247 3
a249 6
   if (success)
      splitMultiSels (theSplitPt, theFlowVol);

   else if (searchPtIsNew)
      {
      mySplitter_->mySplitPts_.pop (theSplitPt);
d251 1
a251 4
      witAssert (theSplitPt == theSelPt->mySplitPt ());

      delete theSplitPt;
      }
d256 1
a256 1
void WitSsPeMgr::splitMultiSels (WitSplitPt * initSplitPt, double theFlowVol)
d258 2
a259 3
   double       splitBound;
   WitSplitPt * theSplitPt;
   WitBoolean   success;
a260 1
   WitObjStack <WitSplitPt> modSplitPts (myProblem ());
d263 1
a263 1
   splitBound = findSplitBound (initSplitPt, theFlowVol);
d265 2
a266 1
   findModSplitPts (modSplitPts);
d268 1
a268 1
   theItr.attachTo (modSplitPts);
d270 1
a270 3
   while (theItr.advance (theSplitPt))
      {
      witAssert (theSplitPt->totFlowVol_ < -0.5);
d272 1
a272 2
      theSplitPt->totFlowVol_ = 0.0;
      }
d274 2
a275 1
   success = tempCommForSearch (initSplitPt, splitBound);
d277 1
a277 1
   witAssert (success);
d279 8
a286 1
   theItr.attachTo (modSplitPts);
d288 1
a288 4
   while (theItr.advance (theSplitPt))
      {
      if (theSplitPt->totFlowVol_ > NET_TOL)
         theSplitPt->splitSelection (theSplitPt->totFlowVol_);
d290 1
a290 2
      theSplitPt->totFlowVol_ = -1.0;
      }
d292 1
a292 2
   purgeSplitPts ();
   }
d294 3
a296 1
//------------------------------------------------------------------------------
d298 2
a299 5
void WitSsPeMgr::findModSplitPts (WitObjStack <WitSplitPt> & modSplitPts)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
   WitSelPt *    theSelPt;
d301 1
a301 1
   WitBopEntPerStack modBopEntPers (myProblem ());
d303 2
a304 1
   findHypoMods (modBopEntPers);
d306 1
a306 2
   if (modBopEntPers.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "Empty mod point set");
d308 1
a308 1
   modSplitPts.clear ();
d310 1
a310 4
   while (modBopEntPers.pop (theBopEnt, thePer))
      {
      theSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);
d312 2
a313 2
      if (! theSelPt->isSplit ())
         mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));
d315 1
a315 2
      modSplitPts.push (theSelPt->mySplitPt ());
      }
d354 1
a354 1
void WitSsPeMgr::findHypoMods (WitBopEntPerStack & modBopEntPers)
d356 16
a371 1
   WitConsEntPerStack modConsEntPers (myProblem ());
d373 1
a373 1
   witAssert (myExpRest_->failRestShortOnly ());
d375 1
a375 1
   myExpRest_->startTempMode ();
d377 1
a377 1
   myExpRest_->updatePsSup ();
d379 4
a382 1
   myRtAnalyzer_->findRoutingMods (modBopEntPers, modConsEntPers);
d384 2
a385 1
   myExpRest_->finishTempMode ();
d387 1
a387 2
   if (! modConsEntPers.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "ConsEnt split points (case 1)");
d393 1
a393 1
      WitSplitPt * theSplitPt, 
d396 1
a396 1
   WitBoolean tempCommOK;
d400 12
a411 1
   witAssert (theSplitPt->netSearchVol_ < -0.5);
d413 5
a417 1
   theSplitPt->netSearchVol_ = searchVol;
d419 1
a419 1
   tempCommOK = mySelector_->myHeurAtor ()->tempCommit (1.0);
d421 7
a427 1
   theSplitPt->netSearchVol_ = -1.0;
d429 8
a436 1
   return tempCommOK;
d441 3
a443 1
void WitSsPeMgr::purgeSplitPts ()
d445 17
a461 2
   WitObjStack <WitSplitPt> revSplitPts  (myProblem ());
   WitSplitPt *             theSplitPt;
d463 3
a465 1
   mySplitter_->mySplitPts_.revCopyInto (revSplitPts);
d467 1
a467 1
   mySplitter_->mySplitPts_.clear ();
d469 3
a471 5
   while (revSplitPts.pop (theSplitPt))
      if (theSplitPt->revSplitList_.isEmpty ())
         delete theSplitPt;
      else
         mySplitter_->mySplitPts_.push (theSplitPt);
d473 1
a473 1
 
d476 3
a478 1
void WitSsPeMgr::addToZeroPts (WitSplitPt * theSplitPt)
d480 5
a484 1
   witAssert (theSplitPt->netSearchVol_ < -0.5);
d486 1
a486 1
   theSplitPt->netSearchVol_ = 0.0;
d488 6
a493 1
   zeroPts_.push (theSplitPt);
d497 2
a498 2
    
void WitSsPeMgr::clearZeroPts ()
d500 4
a503 1
   WitSplitPt * theSplitPt;
d505 1
a505 3
   while (zeroPts_.pop (theSplitPt))
      {
      witAssert (theSplitPt->netSearchVol_ == 0.0);
d507 5
a511 2
      theSplitPt->netSearchVol_ = -1.0;
      }
@


1.10
log
@Continued development of sel-split for pen-exec.
@
text
@a165 2
   mySplitter_->firstTCActive_ = witTRUE;

a167 2
   mySplitter_->firstTCActive_ = witFALSE;

d218 5
a222 6
   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());
   WitBopEntry *      theBopEnt;
   WitPeriod          thePer;
   WitPart *          topPart;
   WitPeriod          topPer;
d224 1
a224 12
   witAssert (myExpRest_->failRestShortOnly ());

   myExpRest_->startTempMode ();

   myExpRest_->updatePsSup ();

   myRtAnalyzer_->findRoutingMods (modBopEntPers, modConsEntPers);

   myExpRest_->finishTempMode ();

   if (! modConsEntPers.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "ConsEnt split points (case 1)");
a252 2
   witAssert (mySplitter_->searchPart_ == NULL);

a259 2
   mySplitter_->searchPart_ = theSelPt->myFillPart ();

d268 1
a268 1
      splitSel1 (theSplitPt, theFlowVol);
a277 2

   mySplitter_->searchPart_ = NULL;
d282 1
a282 1
void WitSsPeMgr::splitSel1 (WitSplitPt * mainSplitPt, double theFlowVol)
d284 3
a286 13
   double        splitBound;
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;
   WitSelPt *    theSelPt;
   WitSplitPt *  theSplitPt;
   WitBoolean    success;

   WitBopEntPerStack        modBopEntPers  (myProblem ());
   WitConsEntPerStack       modConsEntPers (myProblem ());
   WitObjStack <WitSplitPt> modSplitPts    (myProblem ());
   WitObjStack <WitSplitPt> keptSplitPts   (myProblem ());

   splitBound = findSplitBound (mainSplitPt, theFlowVol);
d288 2
a289 1
   myExpRest_->startTempMode ();
d291 1
a291 1
   myExpRest_->updatePsSup ();
d293 1
a293 1
   myRtAnalyzer_->findRoutingMods (modBopEntPers, modConsEntPers);
d295 1
a295 1
   myExpRest_->finishTempMode ();
d297 1
a297 7
   if (! modConsEntPers.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "ConsEnt split points (case 3)");

   if (modBopEntPers.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "Empty mod point set");

   while (modBopEntPers.pop (theBopEnt, thePer))
a298 8
      theSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);

      if (! theSelPt->isSplit ())
         mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));

      theSplitPt = theSelPt->mySplitPt ();

a301 2

      modSplitPts.push (theSplitPt);
d304 1
a304 1
   success = tempCommForSearch (mainSplitPt, splitBound);
d308 3
a310 1
   while (modSplitPts.pop (theSplitPt))
d318 27
a344 5
   while (mySplitter_->mySplitPts_.pop (theSplitPt))
      if (theSplitPt->revSplitList_.isEmpty ())
         delete theSplitPt;
      else
         keptSplitPts.push (theSplitPt);
d346 2
a347 1
   keptSplitPts.revCopyInto (mySplitter_->mySplitPts_);
d386 20
d425 18
@


1.9
log
@Continued implementation of sel-split for pen-exec.
@
text
@a38 1
      altSplit_     (witFALSE),
a158 1
   WitBoolean altFound;
d177 1
a177 3
      altSplit_ = mySelector_->failResAlt_;

      progress  = altSplit_ || myExpRest_->failRestShortOnly ();
a186 7
   if (altSplit_)
      mySelector_->alterSelection (theSelPt);

   altFound  = altSplit_;

   altSplit_ = witFALSE;

a190 3
   if (altFound)
      checkMixedSplit (theSelPt);

a219 31
void WitSsPeMgr::checkMixedSplit (WitSelPt * theSelPt)
   {
   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());
   WitBopEntry *      theBopEnt;
   WitPeriod          thePer;
   WitSelPt *         modSelPt;

   myRtAnalyzer_->findRoutingMods (modBopEntPers, modConsEntPers);

   if (! modConsEntPers.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "ConsEnt split points (case 2)");

   if (modBopEntPers.isEmpty ())
      return;

   if (modBopEntPers.nElements () > 1)
      myMsgFac () ("nyiInSsPeSmsg",
         "Mixed alteration and modification split points (case 1)");

   modBopEntPers.pop (theBopEnt, thePer);

   modSelPt = mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);

   if (modSelPt != theSelPt)
      myMsgFac () ("nyiInSsPeSmsg",
         "Mixed alteration and modification split points (case 2)");
   }

//------------------------------------------------------------------------------

a412 3

   if (altSplit_)
      return theSplitPt->tempCommForSearch (searchVol);
@


1.8
log
@Continued implementation of sel-split for pen-exec.
@
text
@d33 1
a33 1
      WitProbAssoc   (theSelector),
d35 6
a40 6
      mySelector_    (theSelector),
      mySplitter_    (theSelector->mySplitter ()),
      myExpRest_     (theSelector->myExpRest ()),
      myRtAnalyzer_  (theSelector->myRtAnalyzer ()),
      searchSplitPt_ (NULL),
      altSplit_      (witFALSE)
d85 3
d101 1
a101 1
         myExpRest_->updatePsSup (witTRUE);
a113 36
void WitSsPeMgr::postTempCommit (WitBoolean & success)
   {
   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());
   WitBopEntry *      theBopEnt;
   WitPeriod          thePer;
   WitSelPt *         theSelPt;

   if (searchSplitPt_ == NULL)
      return;

   if (success)
      return;

   myExpRest_   ->startTempMode ();

   myExpRest_   ->updatePsSup (witFALSE);

   myRtAnalyzer_->findRoutingMods (modBopEntPers, modConsEntPers);

   myExpRest_   ->finishTempMode ();

   while (modBopEntPers.pop (theBopEnt, thePer))
      {
      theSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);

      if (theSelPt == searchSplitPt_->mySelPt_)
         return;
      }

   success = witTRUE;
   }

//------------------------------------------------------------------------------

d176 3
d200 1
a200 1
   myExpRest_->updatePsSup (witTRUE);
d220 3
d271 2
d278 1
a278 1
   myExpRest_->updatePsSup (witTRUE);
a286 3
   if (modBopEntPers.nElements () > 1)
      myMsgFac () ("nyiInSsPeSmsg", "More than one split point");

d292 12
a303 1
   return mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);
a312 1
   double       splitBound;
d325 5
d333 1
a333 2
      {
      splitBound = findSplitBound (theSplitPt, theFlowVol);
a334 2
      theSplitPt->splitSelection (splitBound);
      }
d349 70
d462 1
a462 1
   witAssert (searchVol > 0.0);
a465 4
   witAssert (searchSplitPt_ == NULL);

   searchSplitPt_            = theSplitPt;

d472 23
a494 1
   searchSplitPt_            = NULL;
d496 2
a497 1
   return tempCommOK;
@


1.7
log
@Continued implementation of pen-exec for sel-split.
@
text
@d193 1
d224 2
d232 3
d261 31
d310 1
a310 1
      myMsgFac () ("nyiInSsPeSmsg", "ConsEnt split points");
a316 2

   witAssert (modBopEntPers.nElements () == 1);
@


1.6
log
@Implemented alteration in sel-split for pen-exec.
@
text
@d149 4
d154 1
a154 3
   WitBoolean  prsFound;
   WitBoolean  split1Found;
   WitBoolean  split2Found;
d161 1
a161 1
   splitItr (tempCommOK, prsFound, split1Found);
d163 1
a163 1
   if (split1Found)
d165 1
a165 1
      prsFound = witTRUE;
d167 2
a168 2
      while (prsFound)
         splitItr (tempCommOK, prsFound, split2Found);
d181 1
a181 1
   return split1Found;
d188 1
a188 1
      WitBoolean & prsFound,
d194 2
a205 2
   prsFound = myExpRest_->failRestShortOnly ();

d210 2
d229 1
a229 2
   if (prsFound)
      myRtAnalyzer_->modifyRouting ();
@


1.5
log
@Continued implementation of Sel-Split for Pen-Exec.
@
text
@d39 2
a40 1
      searchSplitPt_ (NULL)
d42 4
d67 1
a67 1
void WitSsPeMgr::doSSPE (WitBoolean & finished)
d69 1
a70 1
   double     dummyFlowGap;
d72 8
d81 1
a81 1
   theSelPt = findSelPtToSplit (prsFound, dummyFlowGap);
d83 12
a94 1
   mySplitter_->finishFlowMon ();
d96 3
a98 1
   finished = ! prsFound;
d100 2
a101 3
   if (theSelPt == NULL)
      {
      myExpRest_->updatePsSup (witTRUE);
d103 3
a105 1
      return;
a106 2

   splitCommit ();
d147 1
a147 1
void WitSsPeMgr::splitCommit ()
d149 1
a149 1
   WitBoolean  splitFound;
d151 2
a152 1
   WitBoolean  tempCommOK;
d159 1
a159 1
   splitItr (tempCommOK, prsFound, splitFound);
d161 1
a161 1
   if (splitFound)
d166 1
a166 1
         splitItr (tempCommOK, prsFound, splitFound);
d178 2
d192 2
d202 2
d206 1
a206 7
      theSelPt   = findSelPtToSplit (prsFound, flowGap);

      splitFound = (theSelPt != NULL);
      }
    else
      {
      prsFound   = witFALSE;
d208 1
a208 1
      splitFound = witFALSE;
d216 5
d231 22
a252 3
WitSelPt * WitSsPeMgr::findSelPtToSplit (
      WitBoolean & prsFound, 
      double &     flowGap)
a257 1
   WitSelPt *         theSelPt;
d259 1
a259 9
   prsFound = myExpRest_->failRestShortOnly ();

   flowGap  = 0.0;

   if (mySelector_->failResAlt_)
      myMsgFac () ("nyiInSsPeSmsg", "Alteration");

   if (! prsFound)
      return NULL;
d282 1
a282 8
   theSelPt = mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);

   witAssert (theSelPt != NULL);

   if (! mySplitter_->splitIsNeeded (theSelPt, flowGap))
      return NULL;

   return theSelPt;
d367 3
a384 3

   if (mySelector_->failResAlt_)
      myMsgFac () ("nyiInSsPeSmsg", "Alteration during EBS");
@


1.4
log
@Continued implementation of sel-split for pen-exec.
@
text
@d64 1
d68 1
a68 1
   theSelPt = findSelPtToSplit (finished, dummyFlowGap);
d72 2
d75 3
d79 1
d125 1
d133 1
a133 1
   splitItr1 (splitFound);
d137 4
a140 2
      while (! tempCommOK)
         splitItr2 (tempCommOK);
d142 2
a143 1
      mySelector_->myHeurAtor ()->permCommit1SS ();
d156 4
a159 1
void WitSsPeMgr::splitItr1 (WitBoolean & splitFound)
a160 1
   WitBoolean finished;
d168 1
a168 1
   splitFound = ! mySelector_->myHeurAtor ()->tempCommit (1.0);
d172 1
a172 1
   if (splitFound)
d174 1
a174 1
      theSelPt   = findSelPtToSplit (finished, flowGap);
d178 6
a187 1
      {
a189 6
      if (! myExpRest_->failRestShortOnly ())
         myMsgFac () ("nyiInSsPeSmsg", 
            "Split selection without a pure restriction shortage in iteration "
            "1");
      }

d194 1
a194 1
   if (splitFound)
a199 48
void WitSsPeMgr::splitItr2 (WitBoolean & tempCommOK)
   {
   WitBoolean finished;
   double     flowGap;
   WitSelPt * theSelPt;

   mySplitter_->startFlowMon ();

   mySplitter_->firstTCActive_ = witTRUE;

   tempCommOK = mySelector_->myHeurAtor ()->tempCommit (1.0);

   mySplitter_->firstTCActive_ = witFALSE;

   if (tempCommOK)
      {
      mySplitter_->finishFlowMon ();

      mySplitter_->restoreAllVals ();

      myExpRest_->updatePsSup (witTRUE);

      return;
      }

   theSelPt = findSelPtToSplit (finished, flowGap);

   mySplitter_->finishFlowMon ();

   if (theSelPt == NULL)
      myMsgFac () ("nyiInSsPeSmsg", "Failure to find a SelPt to split");

   splitSelection (theSelPt, flowGap);

   if (! myExpRest_->failRestShortOnly ())
      myMsgFac () ("nyiInSsPeSmsg", 
            "Split selection without a pure restriction shortage in iteration "
            "2+");

   mySplitter_->restoreAllVals ();

   myExpRest_->updatePsSup (witTRUE);

   myRtAnalyzer_->modifyRouting ();
   }

//------------------------------------------------------------------------------

d201 1
a201 1
      WitBoolean & finished, 
d210 2
a213 2
   finished = witFALSE;

d217 1
a217 4
   if (! myExpRest_->failRestShortOnly ())
      {
      finished = witTRUE;

a218 1
      }
d243 1
a243 2
   if (theSelPt == NULL)
      return NULL;
@


1.3
log
@Continued implementation of sel-split for pen-exec.
@
text
@d33 1
a33 1
      WitProbAssoc  (theSelector),
d35 5
a39 4
      mySelector_   (theSelector),
      mySplitter_   (theSelector->mySplitter ()),
      myExpRest_    (theSelector->myExpRest ()),
      myRtAnalyzer_ (theSelector->myRtAnalyzer ())
d79 36
d117 1
d125 1
a125 1
   splitItr (tempCommOK);
d127 1
a127 1
   if (! tempCommOK)
d130 1
a130 1
         splitItr (tempCommOK);
d145 44
a188 1
void WitSsPeMgr::splitItr (WitBoolean & tempCommOK)
d208 1
a208 1
      myExpRest_->updatePsSup ();
d224 2
a225 1
         "Split selection without a pure restriction shortage");
d229 1
a229 1
   myExpRest_->updatePsSup ();
d262 1
a262 1
   myExpRest_->updatePsSup ();
d372 1
a372 6
   WitBoolean         tempCommOK;
   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());
   WitBopEntry *      theBopEnt;
   WitPeriod          thePer;
   WitSelPt *         theSelPt;
d378 4
d388 1
a388 2
   if (tempCommOK)
      return witTRUE;
d393 1
a393 18
   myExpRest_->startTempMode ();

   myExpRest_->updatePsSup ();

   myRtAnalyzer_->findRoutingMods (modBopEntPers, modConsEntPers);

   myExpRest_->finishTempMode ();

   while (modBopEntPers.pop (theBopEnt, thePer))
      {
      theSelPt =
         mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);

      if (theSelPt == theSplitPt->mySelPt_)
         return witFALSE;
      }

   return witTRUE;
@


1.2
log
@Continued implementation of sel-split for pen-exec.
@
text
@d89 4
a92 2
   if (tempCommOK)
      myMsgFac () ("nyiInSsPeSmsg", "Successful initial temp-commit of 1");
d94 2
a95 4
   while (! tempCommOK)
      splitItr (tempCommOK);

   mySelector_->myHeurAtor ()->permCommit1SS ();
d127 2
d145 2
a149 2

   mySplitter_->restoreAllVals ();
d214 1
d221 3
a223 1
   if (! theSelPt->isSplit ())
d232 3
a234 2
   if (! success)
      myMsgFac () ("nyiInSsPeSmsg", "Failure on searchVol = splitRes");
d236 7
a242 1
   splitBound = findSplitBound (theSplitPt, theFlowVol);
d244 2
a245 1
   theSplitPt->splitSelection (splitBound);
@


1.1
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d68 2
a80 3
   WitBoolean  finished;
   double      flowGap;
   WitSelPt *  theSelPt;
d87 26
d122 7
a128 1
      myMsgFac () ("nyiInSsPeSmsg", "Successful initial temp-commit of 1");
d132 2
a147 14

   tempCommOK = mySelector_->myHeurAtor ()->tempCommit (1.0);

   if (! tempCommOK)
      myMsgFac () ("nyiInSsPeSmsg", "Failing subsequent temp-commit of 1");

   mySelector_->myHeurAtor ()->permCommit1SS ();

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->postSplitCommit ();

   deleteContents (mySplitter_->mySplitPts_);

   mySplitter_->splitCommActive_ = witFALSE;
a155 19
   WitSelPt * theSelPt;

   flowGap  = 0.0;

   theSelPt = findSelPtToSplit1 (finished);

   if (theSelPt != NULL)
      if (! mySplitter_->splitIsNeeded (theSelPt, flowGap))
         theSelPt = NULL;

   mySplitter_->finishFlowMon ();

   return theSelPt;
   }

//------------------------------------------------------------------------------

WitSelPt * WitSsPeMgr::findSelPtToSplit1 (WitBoolean & finished)
   {
d160 3
d197 9
a205 1
   return mySelector_->myPmrMgr ()->mySelPt (theBopEnt->myPart (), thePer);
d218 2
a219 7
   if (theSelPt->isSplit ())
      myMsgFac () ("nyiInSsPeSmsg", "Multiple splits at a single split point");

   if (! mySplitter_->mySplitPts_.isEmpty ())
      myMsgFac () ("nyiInSsPeSmsg", "Multiple split points");

   mySplitter_->mySplitPts_.push (new WitSplitPt (mySelector_, theSelPt));
d227 2
a228 3
   if (success)
      {
      splitBound = findSplitBound (theSplitPt, theFlowVol);
d230 1
a230 5
      theSplitPt->splitSelection (splitBound);
      }
   else
      {
      mySplitter_->mySplitPts_.pop (theSplitPt);
d232 1
a232 4
      witAssert (theSplitPt == theSelPt->mySplitPt ());

      delete theSplitPt;
      }
@


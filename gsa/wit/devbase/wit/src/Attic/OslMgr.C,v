head	1.41;
access;
symbols
	nextGenBranch:1.39.0.2
	nextGenRoot:1.39
	sce_3_30_20030627:1.37
	EndRw-branch:1.25.0.4
	Root-of-EndRw:1.25
	rwToStl:1.25.0.2
	latest_sce_3_10_20010924:1.4.0.8
	sce_3_10_20010924:1.4
	latest_sce_3_00_20010601:1.4.0.6
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.4.0.4
	sce_2_31_20010308:1.4
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2003.09.18.18.30.17;	author rjw;	state dead;
branches;
next	1.40;

1.40
date	2003.08.06.23.31.50;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.09.20.56.44;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.08.20.59.29;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.20.19.03.27;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.30.18.19.13;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.28.22.19.31;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.27.20.34.34;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.23.18.12.37;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.21.17.37.03;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.20.19.38.34;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.13.20.43.25;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.24.20.40.20;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.19.16.48.22;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.27.21.17.18;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.02.23.40.46;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.26.19.52.59;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.13.18.24.18;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.06.19.56.10;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.04.21.53.36;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.29.23.06.28;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.29.17.57.51;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.27.20.26.34;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.26.22.49.06;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.23.21.00.39;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.23.18.09.14;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.20.19.07.25;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.19.23.25.06;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.16.14.06.21;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.15.20.03.46;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.08.17.33.34;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.02.17.03.36;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.09.19.52.34;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.08.21.58.56;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.02.20.53.14;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.01.14.25.59;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.18.14.02.39;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.25;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.33;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.34;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Continued implementation of opt with COIN.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "OslMgr.C"
//
// Contains the implementation of class OslMgr.
//------------------------------------------------------------------------------

int compiledOslMgr = 1;
   //
   // WATCOM's strict compatibility mode requires every file to
   // have at least one external definition.

#include <OslMgr.h>
#include <OptComp.h>
#include <OptModel.h>
#include <OptVar.h>
#include <OptCon.h>
#include <OptImp.h>
#include <OptStarter.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <Timing.h>

//------------------------------------------------------------------------------

#ifdef OPT_IMPLODE

#include <osl/ekk_c_api.h>

#define INVALID_RET_VAL -444555

EKKContext * WitOslMgr::sharedOslContext_ = NULL;

//------------------------------------------------------------------------------

WitOslMgr::WitOslMgr (WitOptModel * theOptModel):

      WitOptSolver      (theOptModel),

      retVal_           (INVALID_RET_VAL),
      myOslModel_       (NULL),
      presolveFileName_ ()
   {
   }

//------------------------------------------------------------------------------

WitOslMgr::~WitOslMgr ()
   {
   WitTimer::enterSection ("osl");

   deleteOslModel ();

   WitTimer::leaveSection ("osl");
   }

//------------------------------------------------------------------------------

void WitOslMgr::solve ()
   {
   WitTimer::enterSection ("osl");

   innerSolve ();

   WitTimer::leaveSection ("osl");
   }

//------------------------------------------------------------------------------

void WitOslMgr::innerSolve ()
   {
   if (myOptImploder ()->accelerated ())
      myMsgFac () ("reSolveLpMsg", "OSL");
   else
      {
      if (myOptModel ()->isaMIP ())
         myMsgFac () ("solveMipMsg", "OSL");
      else
         myMsgFac () ("solveLpMsg", "OSL");

      createOslModel ();

      passFixedModel ();
      }

   passFlexibleModel ();

   if (myOptImploder ()->printMps ())
      prtMpsFile ();

   if (myOptImploder ()->stopOpt () == 2)
      return;

   if (myOptModel ()->isaMIP ())
      solveMIP ();
   else if (myOptImploder ()->accelerated ())
      solveLpAcc ();
   else
      solveLpUnAcc ();

   myMsgFac () ("optSolnFoundMsg");

   storePrimalSoln ();

   if (myOptModel ()->needDual ())
      storeDualSoln ();

   if (myOptImploder ()->printMask () > 0)
      printSoln ();
   }

//------------------------------------------------------------------------------

void WitOslMgr::createOslModel ()
   {
   if (sharedOslContext_ == NULL)
      initContext ();

   myOslModel_ = ekk_newModel (sharedOslContext_, "WIT");

   checkRetPtr (myOslModel_, "ekk_newModel");

   retVal_ =
      ekk_setLogfileName (
         myOslModel_, 
         myOptComp ()->oslMesgFileName ().myCstring ());

   checkRetVal ("ekk_setLogfileName");

   retVal_ = ekk_messagePrintOn (myOslModel_, 317);
      
   checkRetVal ("ekk_messagePrintOn");

   retVal_ = ekk_mset (myOslModel_, 1, 256, 0, 0, 9999, 0);
      
   checkRetVal ("ekk_mset");

   retVal_ = ekk_setIlinelen (myOslModel_, 90);
   
   checkRetVal ("ekk_setIlinelen");
   }

//------------------------------------------------------------------------------

void WitOslMgr::initContext ()
   {
   EKKModel * baseModel;

   sharedOslContext_ = ekk_initializeContext ();

   checkRetPtr (sharedOslContext_, "ekk_initializeContext");

   baseModel = ekk_baseModel (sharedOslContext_);

   checkRetPtr (baseModel, "ekk_baseModel");

   retVal_ = ekk_messagePrintOff (baseModel, 317);
      
   checkRetVal ("ekk_messagePrintOff");
   }

//------------------------------------------------------------------------------

void WitOslMgr::deleteOslModel ()
   {
   int nModels;

   if (myOslModel_ == NULL)
      return;

   retVal_ = ekk_deleteModel (myOslModel_);

   checkRetVal ("ekk_deleteModel");

   myOslModel_ = NULL;

   nModels     = ekk_numberOfModels (sharedOslContext_);

   if (nModels == 0)
      {
      ekk_endContext (sharedOslContext_);

      sharedOslContext_ = NULL;
      }
   }

//------------------------------------------------------------------------------

void WitOslMgr::passFixedModel ()
   {
   passDimens ();

   passMatrix ();

   setParams ();

   if (myOptModel ()->isaMIP ())
      markIntVars ();
   }

//------------------------------------------------------------------------------

void WitOslMgr::passDimens ()
   {
   retVal_ = ekk_loadRimModel (
      myOslModel_,
      myOptModel ()->nOptCons (),
      NULL,
      NULL,
      myOptModel ()->nOptVars (),
      NULL,
      NULL,
      NULL);

   checkRetVal ("ekk_loadRimModel");
   }

//------------------------------------------------------------------------------

void WitOslMgr::passMatrix ()
   {
   WitVector <int>    indexRow;
   WitVector <int>    startOfEachColumn;
   WitVector <double> elements;

   WitTimer::enterSection ("model");

   myOptModel ()->defMatrixByCols (indexRow, startOfEachColumn, elements);

   WitTimer::leaveSection ("model");

   retVal_ =
      ekk_addColumnElementBlock (
         myOslModel_,
         myOptModel ()->nOptVars (),
         indexRow.myCvector (),
         startOfEachColumn.myCvector (),
         elements.myCvector ());

   if (retVal_ < 0)
      myMsgFac () ("oslErrorSmsg", "ekk_addColumnElementBlock");
   }

//------------------------------------------------------------------------------

void WitOslMgr::setParams () 
   {
   retVal_ = ekk_setMaximize (myOslModel_);

   checkRetVal ("ekk_setMaximize");

   retVal_ = ekk_setImaxfactor (myOslModel_, 500);

   checkRetVal ("ekk_setImaxfactor");
   }

//------------------------------------------------------------------------------

void WitOslMgr::markIntVars ()
   {
   WitOptVar * theOptVar;

   retVal_ = ekk_messagePrintOff (myOslModel_, 317);

   checkRetVal ("ekk_messagePrintOff");

   forEachEl (theOptVar, myOptModel ()->myOptVars ())
      if (theOptVar->isAnIntVar ())
         {
         retVal_ = ekk_markAsInteger (myOslModel_, theOptVar->index ());
         
         checkRetVal ("ekk_markAsInteger");
         }

   retVal_ = ekk_messagePrintOn (myOslModel_, 317);

   checkRetVal ("ekk_messagePrintOn");
   }

//------------------------------------------------------------------------------

void WitOslMgr::passFlexibleModel ()
   {
   int                vecSize;
   WitVector <double> workVector1;
   WitVector <double> workVector2;

   vecSize = max (myOptModel ()->nOptCons (), myOptModel ()->nOptVars ());

   workVector1.resize (vecSize);
   workVector2.resize (vecSize);

   passConBounds (workVector1, workVector2);
   passVarBounds (workVector1, workVector2);
   passObjCoeffs (workVector1);
   }

//------------------------------------------------------------------------------

void WitOslMgr::passConBounds (
      WitVector <double> & theConLBvec,
      WitVector <double> & theConUBvec)
   {
   WitOptCon * theOptCon;

   WitTimer::enterSection ("model");

   forEachEl (theOptCon, myOptModel ()->myOptCons ())
      {
      theConLBvec[theOptCon->index ()] = theOptCon->bounds ().lower ();
      theConUBvec[theOptCon->index ()] = theOptCon->bounds ().upper ();
      }

   WitTimer::leaveSection ("model");

   retVal_ =
      ekk_copyRowlower (
         myOslModel_,
         theConLBvec.myCvector (),
         0,
         myOptModel ()->nOptCons ());

   checkRetVal ("ekk_copyRowlower");

   retVal_ =
      ekk_copyRowupper (
         myOslModel_,
         theConUBvec.myCvector (),
         0,
         myOptModel ()->nOptCons ());

   checkRetVal ("ekk_copyRowupper");
   }

//------------------------------------------------------------------------------

void WitOslMgr::passVarBounds (
      WitVector <double> & theVarLBvec,
      WitVector <double> & theVarUBvec)
   {
   WitOptVar * theOptVar;

   WitTimer::enterSection ("model");

   forEachEl (theOptVar, myOptModel ()->myOptVars ())
      {
      theVarLBvec[theOptVar->index ()] = theOptVar->bounds ().lower ();
      theVarUBvec[theOptVar->index ()] = theOptVar->bounds ().upper ();
      }

   WitTimer::leaveSection ("model");

   retVal_ =
      ekk_copyCollower (
         myOslModel_,
         theVarLBvec.myCvector (),
         0,
         myOptModel ()->nOptVars ());

   checkRetVal ("ekk_copyCollower");

   retVal_ =
      ekk_copyColupper (
         myOslModel_,
         theVarUBvec.myCvector (),
         0,
         myOptModel ()->nOptVars ());

   checkRetVal ("ekk_copyColupper");
   }

//------------------------------------------------------------------------------

void WitOslMgr::passObjCoeffs (WitVector <double> & theObjCoeffVec)
   {
   WitOptVar * theOptVar;

   WitTimer::enterSection ("model");

   forEachEl (theOptVar, myOptModel ()->myOptVars ())
      theObjCoeffVec[theOptVar->index ()] =
         static_cast <double> (theOptVar->mainObjCoeffVal ());

   WitTimer::leaveSection ("model");

   retVal_ =
      ekk_copyObjective (
         myOslModel_,
         theObjCoeffVec.myCvector (),
         0,
         myOptModel ()->nOptVars ());

   checkRetVal ("ekk_copyColupper");
   }

//------------------------------------------------------------------------------

void WitOslMgr::prtMpsFile ()
   {
   myMsgFac () ("mpsFileMsg");

   retVal_ = ekk_exportModel (myOslModel_, "model.mps", 1, 2);

   checkRetVal ("ekk_exportModel");
   }

//------------------------------------------------------------------------------

void WitOslMgr::solveMIP ()
   {
   solveLpUnAcc ();

   retVal_ = ekk_messagePrintOff (myOslModel_, 105);

   checkRetVal ("ekk_messagePrintOff");

   retVal_ = ekk_messagePrintOff (myOslModel_, 114);

   checkRetVal ("ekk_messagePrintOff");

   retVal_ = ekk_branchAndBound (myOslModel_, NULL, NULL);

   checkRetVal ("ekk_branchAndBound");
   }

//------------------------------------------------------------------------------

void WitOslMgr::solveLpUnAcc ()
   {
   passInitSoln ();

   scale ();

   preSolve ();

   crash ();

   primalSimplex ();

   postSolve ();

   primalSimplex ();
   }

//------------------------------------------------------------------------------

void WitOslMgr::solveLpAcc ()
   {
   ekk_primalSimplex (myOslModel_, 0);

   checkProbStat ();
   }

//------------------------------------------------------------------------------

void WitOslMgr::passInitSoln ()
   {
   double *    colsol;
   WitOptVar * theVar;
   
   if (not myOptComp ()->optInitMethod ()->external ())
      return;

   colsol = ekk_getColsol (myOslModel_);

   checkRetPtr (colsol, "ekk_getColsol");

   WitTimer::enterSection ("model");

   forEachEl (theVar, myOptModel ()->myOptVars ())
      colsol[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("model");

   retVal_ = ekk_setColsol (myOslModel_, colsol);

   checkRetVal ("ekk_setColsol");

   ekk_free (colsol);
   }

//------------------------------------------------------------------------------

void WitOslMgr::scale ()
   {
   retVal_ = ekk_scale (myOslModel_);

   checkRetVal ("ekk_scale");
   }

//------------------------------------------------------------------------------

void WitOslMgr::preSolve ()
   {
   if (myOptModel ()->isaMIP ())
      retVal_ = ekk_preSolve (myOslModel_, 3, NULL);
   else
      {
      defPresolveFileName ();

      retVal_ = ekk_preSolve (myOslModel_, 3, presolveFileName_.myCstring ());
      }

   if (retVal_ == 1)
      myOptModel ()->reportInfeasible ();

   checkRetVal ("ekk_preSolve");
   }

//------------------------------------------------------------------------------

#if    defined (RS6K)        \
    or defined (SUN4)        \
    or defined (__OS2__)     \
    or defined (WIN32)       \
    or defined (__WINDOWS__) \

void WitOslMgr::defPresolveFileName ()
   {
   char * theName;

   theName = tempnam (NULL, "witpr");

   if (theName == NULL)
      WitMsgFacility::current () ("tempnamError", errno, strerror (errno));

   presolveFileName_.copyCstring (theName);

   portableFree (theName);
   }

#else

#if defined (__GNUC__)

void WitOslMgr::defPresolveFileName ()
   {
   int retVal;

   presolveFileName_.copyCstring ("witprXXXXXX");
   
   retVal = mkstemp (presolveFileName_.myCstringForUpdate ());

   if (retVal == -1)
      WitMsgFacility::current () ("msktempSmsg");
   }

#else

#error                                                                  \
   Function WitOslMgr::defPresolveFileName has not been defined on this \
   platform.                                                            \

#endif
#endif

//------------------------------------------------------------------------------

void WitOslMgr::crash ()
   {
   if (not myOptComp ()->crashOptStarter ()->isChosen ())
      return;

   retVal_ = ekk_crash (myOslModel_, 3);

   checkRetVal ("ekk_crash");
   }

//------------------------------------------------------------------------------
    
void WitOslMgr::primalSimplex ()
   {
   ekk_primalSimplex (myOslModel_, 3);
      //
      // The return value is ignored; it seems to be the same as probstat.

   checkProbStat ();
   }

//------------------------------------------------------------------------------

void WitOslMgr::postSolve ()
   {
   const char * fileName;

   fileName =
      myOptModel ()->isaMIP ()?
         NULL:
         presolveFileName_.myCstring ();

   if (myOptComp ()->postSolveRecovery ())
      postSolveWithRec (fileName);
   else
      retVal_ = ekk_postSolve (myOslModel_, fileName);

   if (not myOptModel ()->isaMIP ())
      remove (presolveFileName_.myCstring ());

   checkRetVal ("ekk_postSolve");
   }

//------------------------------------------------------------------------------

void WitOslMgr::postSolveWithRec (const char * saveFile)
   {
   int i,nrow=ekk_getInumrows(myOslModel_),ncol=ekk_getInumcols(myOslModel_);
   int * cstat = const_cast <int *> (ekk_colstat(myOslModel_));
   int * rstat = const_cast <int *> (ekk_rowstat(myOslModel_));
   double * csol = const_cast <double *> (ekk_colsol(myOslModel_));
   double * rsol = const_cast <double *> (ekk_rowacts(myOslModel_));
   int * cstatx=ekk_int(ncol);
   int * rstatx=ekk_int(nrow);
   double * csolx=ekk_double(ncol);
   double * rsolx=ekk_double(nrow);
   const double * rowlower = ekk_rowlower(myOslModel_);
   const double * rowupper = ekk_rowupper(myOslModel_);
   double * collower = const_cast <double *> (ekk_collower(myOslModel_));
   double * colupper = const_cast <double *> (ekk_colupper(myOslModel_));

   for (i=0;i<nrow;i++) {
     if(rowupper[i]-rowlower[i]>1.0e-7) {
       rstatx[i]=rstat[i];
       rsolx[i]=rsol[i];
     } else {
       rstatx[i]=-1;
       rsolx[i]=rowlower[i];
     }
   }

   for (i=0;i<ncol;i++) {
     if(colupper[i]-collower[i]>1.0e-7) {
       cstatx[i]=cstat[i];
       csolx[i]=csol[i];
     } else {
       cstatx[i]=-1;
       csolx[i]=collower[i];
     }
   }

   retVal_ = ekk_postSolve(myOslModel_,saveFile);

   if (retVal_ != 0) {
     double * cup=ekk_double(ncol);
     double * clo=ekk_double(ncol);

     if (DEVELOPMENT)
        myMsgFac () ("postSolveRecMsg");

     memcpy(cup,colupper,ncol*sizeof(double));
     memcpy(clo,collower,ncol*sizeof(double));

     for (i=0;i<ncol;i++) {
       if(colupper[i]-collower[i]>1.0e-7) {
         if (cstatx[i]!=-1) {
           csol[i]=csolx[i];
           if (colupper[i]>csol[i])
             colupper[i] = csol[i];
           if (collower[i]<csol[i])
             collower[i] = csol[i];
         }
       } else {
         csol[i]=collower[i];
       }
     }

     ekk_preSolve(myOslModel_,16,saveFile);
     ekk_setImaxiter(myOslModel_,ekk_getIiternum(myOslModel_)+1000000);
     ekk_primalSimplex(myOslModel_,3);
     retVal_=ekk_postSolve(myOslModel_,saveFile);
     memcpy(colupper,cup,ncol*sizeof(double));
     memcpy(collower,clo,ncol*sizeof(double));
     ekk_free(cup);
     ekk_free(clo);
   }

   ekk_free(csolx);
   ekk_free(cstatx);
   ekk_free(rsolx);
   ekk_free(rstatx);
   }

//------------------------------------------------------------------------------

void WitOslMgr::storePrimalSoln ()
   {
   const double * colsol;
   WitOptVar *    theVar;

   colsol = ekk_colsol (myOslModel_);

   checkRetPtr (colsol, "ekk_colsol");

   WitTimer::enterSection ("model");

   forEachEl (theVar, myOptModel ()->myOptVars ())
      theVar->setPrimalValue (colsol[theVar->index ()]);

   WitTimer::leaveSection ("model");
   }

//------------------------------------------------------------------------------

void WitOslMgr::storeDualSoln ()
   {
   const double * rowduals;
   WitOptCon *    theCon;

   rowduals = ekk_rowduals (myOslModel_);

   checkRetPtr (rowduals, "ekk_rowduals");

   WitTimer::enterSection ("model");

   forEachEl (theCon, myOptModel ()->myOptCons ())
      theCon->setDualValue (- rowduals[theCon->index ()]);

   WitTimer::leaveSection ("model");
   }

//------------------------------------------------------------------------------

void WitOslMgr::printSoln ()
   {
   retVal_ = ekk_setIprtinfomask (myOslModel_, myOptImploder ()->printMask ());

   checkRetVal ("ekk_setIprtinfomask");

   retVal_ = ekk_printSolution (myOslModel_);

   checkRetVal ("ekk_printSolution");
   }

//------------------------------------------------------------------------------

void WitOslMgr::checkProbStat ()
   {
   int probStat;

   const WitMsgFragID statFragID [] =
      {
      "iprobstat0Frag",
      "iprobstat1Frag",
      "iprobstat2Frag",
      "iprobstat3Frag",
      "iprobstat4Frag",
      "iprobstat5Frag",
      "iprobstat6Frag",
      };

   probStat = ekk_getIprobstat (myOslModel_);

   if (probStat == 0)
      return;

   if (probStat == 1)
      myOptModel ()->reportInfeasible ();

   if (probStat == 2)
      myOptModel ()->reportUnbounded ();

   if ((probStat < 0) or (probStat >= NumberElem (statFragID)))
      myMsgFac () ("oslOptimalNotFoundFmsg",
         probStat,
         myMsgFac ().myFrag ("iprobstatRangeErrorFrag"));
   else
      myMsgFac () ("oslOptimalNotFoundFmsg",
         probStat,
         myMsgFac ().myFrag (statFragID[probStat]));
   }

//------------------------------------------------------------------------------

void WitOslMgr::checkRetPtr (const void * thePtr, const char * funcName)
   {
   if (thePtr == NULL)
      {
      if (myOslModel_ != NULL)
         {
         ekk_deleteModel (myOslModel_);

         myOslModel_ = NULL;
         }

      myMsgFac () ("oslErrorSmsg", funcName);
      }
   }

//------------------------------------------------------------------------------

void WitOslMgr::checkRetVal (const char * funcName)
   {
   stronglyAssert (retVal_ != INVALID_RET_VAL);

   if (retVal_ != 0)
      {
      if (myOslModel_ != NULL)
         {
         ekk_deleteModel (myOslModel_);

         myOslModel_ = NULL;
         }

      myMsgFac () ("oslErrorSmsg", funcName);
      }

   retVal_ = INVALID_RET_VAL;
   }

//------------------------------------------------------------------------------

#endif
@


1.40
log
@Eliminated the "tempnam" linker warning on Linux.
@
text
@@


1.39
log
@Removed temporary control parameter undoc1.
@
text
@a502 2
   char * theFileName;

d507 1
a507 5
      theFileName = tempFileName ("witpr");

      presolveFileName_.copyCstring (theFileName);

      portableFree (theFileName);
d517 47
@


1.38
log
@Fixed a bug with the stopOpt parameter.
Fixed a timing bug.
@
text
@a504 3
   if (myOptComp ()->skipPreSolve ())
      return;

a551 3

   if (myOptComp ()->skipPreSolve ())
      return;
@


1.37
log
@Added a temporary undocumented control parameter to turn off ekk_preSolve.
@
text
@d71 9
a117 2

   WitTimer::leaveSection ("osl");
@


1.36
log
@Continued implementation of opt with COIN.
@
text
@d498 3
d548 3
@


1.35
log
@Continued implementation of opt with COIN.
@
text
@d227 2
d230 2
@


1.34
log
@Continued implementation of opt with COIN.
@
text
@d127 1
a127 1
         myOptImploder ()->myOptComp ()->oslMesgFileName ().myCstring ());
d458 1
a458 1
   if (not myOptImploder ()->myOptComp ()->optInitMethod ()->external ())
d517 1
a517 1
   if (not myOptImploder ()->myOptComp ()->crashOptStarter ()->isChosen ())
d547 1
a547 1
   if (myOptImploder ()->myOptComp ()->postSolveRecovery ())
@


1.33
log
@Continued implementation of opt with COIN.
@
text
@d455 2
a456 1
   double * colsol;
d465 6
a470 1
   myOptModel ()->getInitSoln (colsol);
@


1.32
log
@Continued implementation of opt with COIN.
Modified appl.mk to facilitate linking WIT to COIN.
@
text
@d58 1
a58 1
   WitTimingEvent theEvent ("osl");
d61 2
d69 1
a69 1
   WitTimingEvent theEvent ("osl");
d109 2
d301 5
d307 3
a309 2
      WitTimingEvent theEvent ("model");
      WitOptCon *    theOptCon;
d311 1
a311 6
      forEachEl (theOptCon, myOptModel ()->myOptCons ())
         {
         theConLBvec[theOptCon->index ()] = theOptCon->bounds ().lower ();
         theConUBvec[theOptCon->index ()] = theOptCon->bounds ().upper ();
         }
      }
d338 5
d344 3
a346 2
      WitTimingEvent theEvent ("model");
      WitOptVar *    theOptVar;
d348 1
a348 6
      forEachEl (theOptVar, myOptModel ()->myOptVars ())
         {
         theVarLBvec[theOptVar->index ()] = theOptVar->bounds ().lower ();
         theVarUBvec[theOptVar->index ()] = theOptVar->bounds ().upper ();
         }
      }
d373 7
a379 3
      {
      WitTimingEvent theEvent ("model");
      WitOptVar *    theOptVar;
d381 1
a381 4
      forEachEl (theOptVar, myOptModel ()->myOptVars ())
         theObjCoeffVec[theOptVar->index ()] =
            static_cast <double> (theOptVar->mainObjCoeffVal ());
      }
d637 1
d643 6
a648 1
   myOptModel ()->storePrimalSoln (colsol);
d656 1
d662 6
a667 1
   myOptModel ()->storeDualSoln (rowduals);
@


1.31
log
@Continued implementation of opt with Coin.
@
text
@d669 11
a679 1
   int index;
d692 8
a699 22
   index = probStat + 1;

   const WitMsgFragID statFragID [] =
      {
      "iprobstatM1Frag",
      "iprobstat0Frag",
      "iprobstat1Frag",
      "iprobstat2Frag",
      "iprobstat3Frag",
      "iprobstat4Frag",
      "iprobstat5Frag",
      "iprobstat6Frag",
      };

   if ((index < 0) or (index >= NumberElem (statFragID)))
      index = 0;
         //
         // Ensure index is in range.

   myMsgFac () ("oslOptimalNotFoundFmsg",
      probStat,
      myMsgFac ().myFrag (statFragID[index]));
@


1.30
log
@Continued implementation of opt with COIN.
@
text
@d25 1
d70 1
a70 1
      myMsgFac () ("reSolveLpOslMsg");
d74 1
a74 1
         myMsgFac () ("solveMipOslMsg");
d76 1
a76 1
         myMsgFac () ("solveLpOslMsg");
d223 1
a223 1
   myOptModel ()->generateOslVectors (indexRow, startOfEachColumn, elements);
d278 2
a279 1
   WitVector <double> workVector;
d283 2
a284 1
   workVector.resize (vecSize);
d286 3
a288 5
   passConLBs    (workVector);
   passConUBs    (workVector);
   passVarLBs    (workVector);
   passVarUBs    (workVector);
   passObjCoeffs (workVector);
d293 3
a295 1
void WitOslMgr::passConLBs (WitVector <double> & theConLBvec)
d297 10
a306 1
   myOptModel ()->getConLBs (theConLBvec);
a315 7
   }

//------------------------------------------------------------------------------

void WitOslMgr::passConUBs (WitVector <double> & theConUBvec)
   {
   myOptModel ()->getConUBs (theConUBvec);
d329 3
a331 1
void WitOslMgr::passVarLBs (WitVector <double> & theVarLBvec)
d333 10
a342 1
   myOptModel ()->getVarLBs (theVarLBvec);
a351 7
   }

//------------------------------------------------------------------------------

void WitOslMgr::passVarUBs (WitVector <double> & theVarUBvec)
   {
   myOptModel ()->getVarUBs (theVarUBvec);
d367 8
a374 1
   myOptModel ()->getObjCoeffs (theObjCoeffVec);
@


1.29
log
@Implemented OSL postSolve error recovery.
@
text
@d45 2
a46 3
      myOptModel_       (theOptModel),
      myOptImploder_    (theOptModel->myOptImploder ()),
      myMsgFac_         (theOptModel->myMsgFac ()),
d68 2
a69 2
   if (myOptImploder_->accelerated ())
      myMsgFac_ ("reSolveLpOslMsg");
d72 2
a73 2
      if (myOptModel_->isaMIP ())
         myMsgFac_ ("solveMipOslMsg");
d75 1
a75 1
         myMsgFac_ ("solveLpOslMsg");
d84 1
a84 1
   if (myOptImploder_->printMps ())
d87 1
a87 1
   if (myOptImploder_->stopOpt () == 2)
d90 1
a90 1
   if (myOptModel_->isaMIP ())
d92 1
a92 1
   else if (myOptImploder_->accelerated ())
d97 1
a97 1
   myMsgFac_ ("optSolnFoundMsg");
d101 1
a101 1
   if (myOptModel_->needDual ())
d104 1
a104 1
   if (myOptImploder_->printMask () > 0)
d122 1
a122 1
         myOptImploder_->myOptComp ()->oslMesgFileName ().myCstring ());
d193 1
a193 1
   if (myOptModel_->isaMIP ())
d203 1
a203 1
      myOptModel_->nOptCons (),
d206 1
a206 1
      myOptModel_->nOptVars (),
d222 1
a222 1
   myOptModel_->generateOslVectors (indexRow, startOfEachColumn, elements);
d227 1
a227 1
         myOptModel_->nOptVars (),
d233 1
a233 1
      myMsgFac_ ("oslErrorSmsg", "ekk_addColumnElementBlock");
d259 1
a259 1
   forEachEl (theOptVar, myOptModel_->myOptVars ())
d279 1
a279 1
   vecSize = max (myOptModel_->nOptCons (), myOptModel_->nOptVars ());
d294 1
a294 1
   myOptModel_->getConLBs (theConLBvec);
d301 1
a301 1
         myOptModel_->nOptCons ());
d310 1
a310 1
   myOptModel_->getConUBs (theConUBvec);
d317 1
a317 1
         myOptModel_->nOptCons ());
d326 1
a326 1
   myOptModel_->getVarLBs (theVarLBvec);
d333 1
a333 1
         myOptModel_->nOptVars ());
d342 1
a342 1
   myOptModel_->getVarUBs (theVarUBvec);
d349 1
a349 1
         myOptModel_->nOptVars ());
d358 1
a358 1
   myOptModel_->getObjCoeffs (theObjCoeffVec);
d365 1
a365 1
         myOptModel_->nOptVars ());
d374 1
a374 1
   myMsgFac_ ("mpsFileMsg");
d434 1
a434 1
   if (not myOptImploder_->myOptComp ()->optInitMethod ()->external ())
d441 1
a441 1
   myOptModel_->getInitSoln (colsol);
d465 1
a465 1
   if (myOptModel_->isaMIP ())
d479 1
a479 1
      myOptModel_->reportInfeasible ();
d488 1
a488 1
   if (not myOptImploder_->myOptComp ()->crashOptStarter ()->isChosen ())
d514 1
a514 1
      myOptModel_->isaMIP ()?
d518 1
a518 1
   if (myOptImploder_->myOptComp ()->postSolveRecovery ())
d523 1
a523 1
   if (not myOptModel_->isaMIP ())
d574 1
a574 1
        myMsgFac_ ("postSolveRecMsg");
d619 1
a619 1
   myOptModel_->storePrimalSoln (colsol);
d632 1
a632 1
   myOptModel_->storeDualSoln (rowduals);
d639 1
a639 1
   retVal_ = ekk_setIprtinfomask (myOslModel_, myOptImploder_->printMask ());
d661 1
a661 1
      myOptModel_->reportInfeasible ();
d664 1
a664 1
      myOptModel_->reportUnbounded ();
d685 1
a685 1
   myMsgFac_ ("oslOptimalNotFoundFmsg",
d687 1
a687 1
      myMsgFac_.myFrag (statFragID[index]));
d703 1
a703 1
      myMsgFac_ ("oslErrorSmsg", funcName);
d722 1
a722 1
      myMsgFac_ ("oslErrorSmsg", funcName);
@


1.28
log
@Continued implementation of proportionate routing.
@
text
@d512 9
a520 2
   if (myOptModel_->isaMIP ())
      retVal_ = ekk_postSolve (myOslModel_, NULL);
d522 1
a522 2
      {
      retVal_ = ekk_postSolve (myOslModel_, presolveFileName_.myCstring ());
d524 1
a525 1
      }
d527 40
a566 2
   if (retVal_ == 1)
      myOptModel_->reportInfeasible ();
d568 40
a607 1
   checkRetVal ("ekk_postSolve");
@


1.27
log
@Began implementation of Proportionate Routing.
@
text
@d613 8
d622 1
d632 8
d641 1
@


1.26
log
@Internal changes.
@
text
@a143 1
   EKKContext * theOslContext;
@


1.25
log
@Switched to specifying the OSL log file by name instead of by file pointer.
@
text
@d436 1
a436 1
   if (! myOptImploder_->myOptComp ()->optInitMethod ()->external ())
d490 1
a490 1
   if (! myOptImploder_->myOptComp ()->crashOptStarter ()->isChosen ())
d599 1
a599 1
   if ((index < 0) || (index >= NumberElem (statFragID)))
@


1.24
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a48 1
      oslLogFile_       (NULL),
a106 2

   fflush (oslLogFile_);
d120 4
a123 4
   oslLogFile_ =
      openFile (myOptImploder_->myOptComp ()->oslMesgFileName (), "a");

   retVal_ = ekk_setLogfileFilePointer (myOslModel_, oslLogFile_);
d125 1
a125 1
   checkRetVal ("ekk_setLogfileFilePointer");
@


1.23
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d470 5
a474 1
   theFileName = tempFileName ("witpr");
d476 1
a476 1
   presolveFileName_.copyCstring (theFileName);
d478 1
a478 1
   portableFree (theFileName);
d480 2
a481 1
   retVal_ = ekk_preSolve (myOslModel_, 3, presolveFileName_.myCstring ());
d516 5
a520 1
   retVal_ = ekk_postSolve (myOslModel_, presolveFileName_.myCstring ());
d522 2
a523 1
   remove (presolveFileName_.myCstring ());
@


1.22
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a399 2
   ekk_integerPresolve (myOslModel_, NULL, NULL, 0);

@


1.21
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d400 2
@


1.20
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d24 1
a24 1
#include <ModelEl.h>
@


1.19
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d260 4
d271 4
d388 19
a430 9
   }

//------------------------------------------------------------------------------

void WitOslMgr::solveMIP ()
   {
   retVal_ = ekk_branchAndBound (myOslModel_, NULL, NULL);

   checkRetVal ("ekk_branchAndBound");
@


1.18
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d24 1
d71 1
a71 1
      myMsgFac_ ("reSolveOptOslMsg");
d74 4
a77 1
      myMsgFac_ ("solveOptOslMsg");
d92 4
a95 2
   if (myOptImploder_->accelerated ())
      solveByOslAcc ();
d97 1
a97 1
      solveByOslUnAcc ();
d197 3
d256 15
d380 1
a380 1
void WitOslMgr::solveByOslUnAcc ()
d399 1
a399 1
void WitOslMgr::solveByOslAcc ()
d404 9
@


1.17
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d23 1
a23 1
#include <MpModel.h>
d42 1
a42 1
WitOslMgr::WitOslMgr (WitMpModel * theMpModel):
d44 3
a46 3
      myMpModel_        (theMpModel),
      myOptImploder_    (theMpModel->myOptImploder ()),
      myMsgFac_         (theMpModel->myMsgFac ()),
d65 1
a65 1
void WitOslMgr::solveMP ()
d70 1
a70 1
      myMsgFac_ ("reSolveMpOslMsg");
d73 1
a73 1
      myMsgFac_ ("solveMpOslMsg");
d97 1
a97 1
   if (myMpModel_->needDual ())
d199 1
a199 1
      myMpModel_->nMpCons (),
d202 1
a202 1
      myMpModel_->nMpVars (),
d218 1
a218 1
   myMpModel_->generateOslVectors (indexRow, startOfEachColumn, elements);
d223 1
a223 1
         myMpModel_->nMpVars (),
d252 1
a252 1
   vecSize = max (myMpModel_->nMpCons (), myMpModel_->nMpVars ());
d267 1
a267 1
   myMpModel_->getConLBs (theConLBvec);
d274 1
a274 1
         myMpModel_->nMpCons ());
d283 1
a283 1
   myMpModel_->getConUBs (theConUBvec);
d290 1
a290 1
         myMpModel_->nMpCons ());
d299 1
a299 1
   myMpModel_->getVarLBs (theVarLBvec);
d306 1
a306 1
         myMpModel_->nMpVars ());
d315 1
a315 1
   myMpModel_->getVarUBs (theVarUBvec);
d322 1
a322 1
         myMpModel_->nMpVars ());
d331 1
a331 1
   myMpModel_->getObjCoeffs (theObjCoeffVec);
d338 1
a338 1
         myMpModel_->nMpVars ());
d395 1
a395 1
   myMpModel_->getInitSoln (colsol);
d428 1
a428 1
      myMpModel_->reportInfeasible ();
d465 1
a465 1
      myMpModel_->reportInfeasible ();
d480 1
a480 1
   myMpModel_->storePrimalSoln (colsol);
d493 1
a493 1
   myMpModel_->storeDualSoln (rowduals);
d522 1
a522 1
      myMpModel_->reportInfeasible ();
d525 1
a525 1
      myMpModel_->reportUnbounded ();
@


1.16
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d23 1
a23 1
#include <LpModel.h>
d42 1
a42 1
WitOslMgr::WitOslMgr (WitLpModel * theLpModel):
d44 3
a46 3
      myLpModel_        (theLpModel),
      myOptImploder_    (theLpModel->myOptImploder ()),
      myMsgFac_         (theLpModel->myMsgFac ()),
d65 1
a65 1
void WitOslMgr::solveLP ()
d70 1
a70 1
      myMsgFac_ ("reSolveLpOslMsg");
d73 1
a73 1
      myMsgFac_ ("solveLpOslMsg");
d97 1
a97 1
   if (myLpModel_->needDual ())
d199 1
a199 1
      myLpModel_->nLpCons (),
d202 1
a202 1
      myLpModel_->nLpVars (),
d218 1
a218 1
   myLpModel_->generateOslVectors (indexRow, startOfEachColumn, elements);
d223 1
a223 1
         myLpModel_->nLpVars (),
d252 1
a252 1
   vecSize = max (myLpModel_->nLpCons (), myLpModel_->nLpVars ());
d267 1
a267 1
   myLpModel_->getConLBs (theConLBvec);
d274 1
a274 1
         myLpModel_->nLpCons ());
d283 1
a283 1
   myLpModel_->getConUBs (theConUBvec);
d290 1
a290 1
         myLpModel_->nLpCons ());
d299 1
a299 1
   myLpModel_->getVarLBs (theVarLBvec);
d306 1
a306 1
         myLpModel_->nLpVars ());
d315 1
a315 1
   myLpModel_->getVarUBs (theVarUBvec);
d322 1
a322 1
         myLpModel_->nLpVars ());
d331 1
a331 1
   myLpModel_->getObjCoeffs (theObjCoeffVec);
d338 1
a338 1
         myLpModel_->nLpVars ());
d395 1
a395 1
   myLpModel_->getInitSoln (colsol);
d428 1
a428 1
      myLpModel_->reportInfeasible ();
d465 1
a465 1
      myLpModel_->reportInfeasible ();
d480 1
a480 1
   myLpModel_->storePrimalSoln (colsol);
d493 1
a493 1
   myLpModel_->storeDualSoln (rowduals);
d522 1
a522 1
      myLpModel_->reportInfeasible ();
d525 1
a525 1
      myLpModel_->reportUnbounded ();
@


1.15
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d22 1
d25 1
@


1.14
log
@Fixed a CPU time problem in opt implosion with OSL V3.
@
text
@d216 1
a216 5
   indexRow         .resize (myLpModel_->nCoeffs ());
   startOfEachColumn.resize (myLpModel_->nLpVars () + 1);
   elements         .resize (myLpModel_->nCoeffs ());

   myLpModel_->generateOsl3Vectors (indexRow, startOfEachColumn, elements);
d265 1
a265 1
   myLpModel_->getOsl3ConLBs (theConLBvec);
d281 1
a281 1
   myLpModel_->getOsl3ConUBs (theConUBvec);
d297 1
a297 1
   myLpModel_->getOsl3VarLBs (theVarLBvec);
d313 1
a313 1
   myLpModel_->getOsl3VarUBs (theVarUBvec);
d329 1
a329 1
   myLpModel_->getOsl3ObjCoeffs (theObjCoeffVec);
d478 1
a478 1
   myLpModel_->storeOsl3PrimalSoln (colsol);
d491 1
a491 1
   myLpModel_->storeOsl3DualSoln (rowduals);
@


1.13
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d83 3
d111 1
a111 1
   myOslModel_ = ekk_newModel (sharedOslContext_, "WIT LP Model");
d188 1
a188 1
   setAsMax ();
d236 1
a236 1
void WitOslMgr::setAsMax () 
d238 5
a242 1
   retVal_ = ekk_setRmaxmin (myOslModel_, -1.0);
d244 1
a244 1
   checkRetVal ("ekk_setRmaxmin");
@


1.12
log
@Continued implementation of opt implosion with OSL V3.
@
text
@a146 4
   retVal_ = ekk_messagePrintOff (baseModel, 259);
      
   checkRetVal ("ekk_messagePrintOff");

@


1.11
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d26 3
d32 1
a32 3
#if OSL_VERSION == 3

#include <Osl3MgrI.h>
d34 1
a34 1
#endif
d36 1
a36 34
#if OSL_VERSION == 2

extern "C"
   {
#  include <osl/osli.h>
#  include <osl/osln.h>
#  include <osl/oslr.h>
#  include <osl/oslc.h>
#  include <osl/ekkc.h>
   }

//------------------------------------------------------------------------------
// Macro callOsl.
//
// oslCall is assumed to be statement calling OSL.
// This macro assigns the CPU for oslCall to the "osl" TimingSection.
//------------------------------------------------------------------------------

#define callOsl(oslCall)                                                       \
                                                                               \
   {                                                                           \
   WitTimingEvent theEvent ("osl");                                            \
                                                                               \
   oslCall;                                                                    \
   }                                                                           \

//------------------------------------------------------------------------------
// Static member data.
//------------------------------------------------------------------------------

const int  WitOslMgr::logUnit_           = 7;
const int  WitOslMgr::prslUnit_          = 8;
const int  WitOslMgr::bcdoUnit_          = 9;
WitBoolean WitOslMgr::oslHasBeenInvoked_ = witFALSE;
d45 4
a48 4
      dSpace_           (NULL),
      rtCodeData_       (0),
      ioStat_           (0),
      prslTempFileName_ (NULL)
d56 1
a56 1
   shutDownOsl ();
d58 1
a58 1
   delete[] dSpace ();
d63 1
a63 1
void WitOslMgr::checkRtCode (const char * routineName)
d65 1
a65 3
   if (rtCode () >= 200)
      myMsgFac () ("oslError", routineName, rtCode ());
   }
a66 4
//------------------------------------------------------------------------------

void WitOslMgr::solve ()
   {
d68 1
a68 5
      {
      myMsgFac () ("reSolveLpOslMsg");

      restoreOsl ();
      }
d71 1
a71 1
      myMsgFac () ("solveLpOslMsg");
d73 1
a73 1
      startUpOsl ();
d81 6
a86 1
      printMpsDeck ();
d88 3
a90 3
   if (myOptImploder_->stopOpt () == 2)
      {
      shutDownOsl ();
d92 2
a93 2
      return;
      }
d95 2
a96 3
   if (myOptImploder_->accelerated ())
      {
      callOsl (ekksslv (rtCodePtr (), dSpace (), 0, 0))
d98 2
a99 1
      checkRtCode ("sslv");
d101 1
a101 3
      checkProbStat ();
      }
   else solveOslUnAcc ();
d103 4
a106 1
   myMsgFac () ("optSolnFoundMsg");
d108 1
a108 1
   recordPrimal ();
d110 1
a110 2
   if (myLpModel_->needDual ())
      recordDual ();
d112 2
a113 3
   if (myOptImploder_->printMask () > 0)
      {
      setVal (IPRTINFOMASK, myOptImploder_->printMask ());
d115 1
a115 1
      callOsl (ekkprts (rtCodePtr (), dSpace ()))
d117 1
a117 2
      checkRtCode ("prts");
      }
d119 3
a121 3
   callOsl (ekkptmi (rtCodePtr (), dSpace (), 1))
      //
      // Stores current model in dSpace () for later use.
d123 3
a125 1
   checkRtCode ("ptmi");
d127 3
a129 1
   shutDownOsl ();
d134 1
a134 1
void WitOslMgr::closeFilesAtExit ()
d136 18
a153 1
   ekkfcls (logUnit_, "KEEP", &ioStat_);
d158 1
a158 1
long WitOslMgr::getVal (long & var)
d160 1
a160 1
   callOsl (ekkiget (rtCodePtr (), dSpace (), osli, OSLILN))
d162 2
a163 1
   checkRtCode ("iget");
d165 14
a178 1
   return var;
d183 1
a183 1
void WitOslMgr::setVal (long & var, long val)
d185 1
a185 3
   getVal (var);

   var = val;
d187 1
a187 1
   callOsl (ekkiset (rtCodePtr (), dSpace (), osli, OSLILN))
d189 1
a189 1
   checkRtCode ("iset");
d194 1
a194 1
double WitOslMgr::getVal (double & var)
d196 9
a204 1
   callOsl (ekkrget (rtCodePtr (), dSpace (), oslr, OSLRLN))
d206 1
a206 3
   checkRtCode ("rget");

   return var;
d211 1
a211 1
void WitOslMgr::setVal (double & var, double val)
d213 7
a219 1
   getVal (var);
d221 1
a221 1
   var = val;
d223 7
a229 1
   callOsl (ekkrset (rtCodePtr (), dSpace (), oslr, OSLRLN))
d231 2
a232 1
   checkRtCode ("rset");
d237 1
a237 1
double * WitOslMgr::dSpaceArray (long & indexVar)
d239 1
a239 1
   callOsl (ekknget (rtCodePtr (), dSpace (), osln, OSLNLN))
d241 1
a241 3
   checkRtCode ("nget");

   return dSpace () + indexVar - 2;
d246 1
a246 1
long * WitOslMgr::mSpaceArray (long & indexVar)
d248 2
a249 1
   callOsl (ekknget (rtCodePtr (), dSpace (), osln, OSLNLN))
d251 1
a251 1
   checkRtCode ("nget");
d253 7
a259 1
   return ((long *) dSpace ()) + indexVar - 2;
d264 1
a264 1
void WitOslMgr::setOslInfoMsgs (WitBoolean printMsgs)
d266 1
a266 4
   const long maxprt =
      printMsgs?
         256:
         -1;
d268 6
a273 1
   callOsl (ekkmset (rtCodePtr (), dSpace (), 1, 0, maxprt, 0, 0, 2999, 0))
d275 1
a275 1
   checkRtCode ("mset");
d280 1
a280 1
void WitOslMgr::openLogFile ()
d282 1
a282 1
   WitString logFileName;
d284 4
a287 11
   logFileName.copy (myOptImploder_->myOptComp ()->oslMesgFileName ());

   callOsl (
      ekkfopn
         (
         logUnit_,
         logFileName.myCstringForUpdate (),
         "UNKNOWN",
         "SEQUENTIAL",
         "FORMATTED",
         "NULL",
d289 1
a289 1
         &ioStat_))
d291 1
a291 5
   if (ioStat_ != 0)
      myMsgFac () ("openOslLogFileError",
         myOptImploder_->myOptComp ()->oslMesgFileName (),
         logUnit_,
         ioStat_);
d296 1
a296 1
void WitOslMgr::closeLogFile ()
d298 8
a305 1
   ekkfcls (logUnit_, "KEEP", &ioStat_);
d307 1
a307 4
   if (ioStat_ != 0)
      myMsgFac () ("closeOslLogFileError",
         myOptImploder_->myOptComp ()->oslMesgFileName (),
         ioStat_);
d312 1
a312 1
void WitOslMgr::openPrslFile ()
d314 1
a314 1
   prslTempFileName_ = tempFileName ("witpr");
d316 4
a319 9
   callOsl (
      ekkfopn
         (
         prslUnit_,
         prslTempFileName_,
         "NEW",
         "SEQUENTIAL",
         "UNFORMATTED",
         "NULL",
d321 1
a321 1
         &ioStat_))
d323 1
a323 3
   if (ioStat_ != 0)
      myMsgFac () ("openOslPrslUnitError",
         prslTempFileName_, prslUnit_, ioStat_);
d328 1
a328 1
void WitOslMgr::closePrslFile ()
d330 1
a330 1
   ekkfcls (prslUnit_, "DELETE", &ioStat_);
d332 6
a337 4
   if (ioStat_ != 0)
      myMsgFac () ("closeOslUnitError", prslTempFileName_, prslUnit_, ioStat_);

   portableFree (prslTempFileName_);
d339 1
a339 1
   prslTempFileName_ = NULL;
a342 6
// WitOslMgr::allocDSpace allocates dSpace_.
// To determine the size of dSpace_, the formula in the section of the OSL
// manual section on ekkdsca is used (with dSpaceFactor = 10).
// dSpaceFactor should be increased incrementally and permanently any
// time OSL runs out of space.
//------------------------------------------------------------------------------
d344 1
a344 1
int WitOslMgr::allocDSpace ()
d346 1
a346 1
   const int dSpaceFactor = 11;
d348 1
a348 7
   const int dSpaceSize =
      11000 + dSpaceFactor *
         (myLpModel_->nLpVars () +
         myLpModel_->nLpCons () +
         myLpModel_->nCoeffs ());
      //
      // Size of dSpace_ in double words.
d350 2
a351 3
   int displayedSize = (dSpaceSize * sizeof (double)) / 1024;
      //
      // Size of dSpace_ for display purposes, either in KB or MB.
d353 1
a353 3
   const char * displayedUnit = "kilobytes";
      //
      // Units of displayedSize.
d355 3
a357 1
   int i;
d359 1
a359 3
   if (displayedSize >= 10240)
      {
      displayedSize /= 1024;
d361 1
a361 2
      displayedUnit = "megabytes";
      }
d363 1
a363 5
   set_new_handler (NULL);
      //
      // Temporarily turn off the C++ "new" handler during the allocation of
      // dSpace_. If there is an error when allocating dSpace_, this function
      // (allocDSpace) will handle it explicitly.
d365 1
a365 1
   dSpace_ = new double[dSpaceSize];
d367 1
a367 3
   set_new_handler (newError);
      //
      // Restore the C++ "new" handler to the one we have defined for WIT.
d369 2
a370 2
   for (i = 0; i < dSpaceSize; ++ i)
      dSpace ()[i] = 0.0;
d372 1
a372 2
   if (dSpace () == NULL)
      myMsgFac () ("dSpaceAllocError", displayedSize, displayedUnit);
d374 3
a376 2
   if (DEVELOPMENT)
      myMsgFac () ("dSpaceAllocMsg", displayedSize, displayedUnit);
d378 1
a378 1
   return dSpaceSize;
d383 1
a383 1
void WitOslMgr::startUpOsl ()
d385 4
a388 1
   const int dSpaceSize = allocDSpace ();
d390 1
a390 1
   openLogFile ();
d392 10
a401 5
   if (oslHasBeenInvoked_)
      {
      callOsl (ekkinit (rtCodePtr (), dSpace ()))
         //
         // Re-initialize OSL.
d403 1
a403 2
      checkRtCode ("init");
      }
d405 3
a407 1
   oslHasBeenInvoked_ = witTRUE;
d409 2
a410 1
   setOslInfoMsgs (witFALSE);
d412 1
a412 1
   setVal (IPRINTUNIT, logUnit_);
d414 3
a416 1
   setVal (ILINELEN, 90);
d418 1
a418 1
   setVal (IMSGPOS, 1);
d420 1
a420 1
   setOslInfoMsgs (witTRUE);
d422 1
a422 3
   callOsl (ekkmset (rtCodePtr (), dSpace (), 1, 256,  0, 0, 0, 9999, 0))
      //
      // Set OSL so it continues to run after severe messages.
d424 1
a424 1
   checkRtCode ("mset");
d426 2
a427 3
   callOsl (ekkdsca (rtCodePtr (), dSpace (), dSpaceSize, 1))
      //
      // Describe application to OSL.
d429 1
a429 1
   checkRtCode ("dsca");
d434 1
a434 1
void WitOslMgr::restoreOsl ()
d436 2
a437 5
   openLogFile ();

   callOsl (ekkgtmi (rtCodePtr (), dSpace (), 1))
      //
      // Restores current model from dSpace ().
d439 1
a439 1
   checkRtCode ("gtmi");
d441 1
a441 1
   setOslInfoMsgs (witTRUE);
d445 2
a446 2

void WitOslMgr::shutDownOsl ()
d448 1
a448 1
   setOslInfoMsgs (witFALSE);
d450 1
a450 1
      // Makes the next call to ekkinit silent.
d452 1
a452 3
   closePrslFile ();

   closeLogFile ();
d457 1
a457 1
void WitOslMgr::printMpsDeck ()
d459 1
a459 1
   myMsgFac () ("mpsFileMsg");
d461 1
a461 1
   callOsl (ekkbcdo (rtCodePtr (), dSpace (), bcdoUnit_, 1, 2))
d463 2
a464 3
   checkRtCode ("bcdo");

   callOsl (ekkfcls (bcdoUnit_, "KEEP", &ioStat_))
d466 1
a466 2
   if (ioStat_ != 0)
      myMsgFac () ("mpsFileError", ioStat_);
a469 13
// Note: The vectors passed to OSL in WitOslMgr::passFixedModel are specified
// as [vector] + 1, to be compatible with the OSL (FORTRAN) index convention,
// which requires that the first element of a vector be index == 1.
// To reduce memory allocation,
// several of the arguments to ekklmdl are specified as a dummy array; the
// values these arguments set will be specified by other means.
// Since the values of the dummy are don't matter, the dummy c-vector is
// simply the same c-vector as oslDels, which in turn is allocated to be long
// enough for each of the arguments to which the dummy c-vector is passed.
// This approach results in several occurances of the following OSL message:
//    EKK0120I Data defined by parameter I1 overlaps data for I2.
// The above message does not indicate an error.
//------------------------------------------------------------------------------
d471 1
a471 1
void WitOslMgr::passFixedModel ()
d473 1
a473 1
   int dummyArraySize = 0;
d475 1
a475 29
   setToMax (dummyArraySize, myLpModel_->nCoeffs () + 1);
   setToMax (dummyArraySize, myLpModel_->nLpVars ());
   setToMax (dummyArraySize, myLpModel_->nLpCons ());

   WitVector <long>   oslMrow (myLpModel_->nCoeffs () + 1, 0);
   WitVector <long>   oslMcol (myLpModel_->nLpVars () + 2, 0);
   WitVector <double> oslDels (dummyArraySize,           0.0);

   WitVector <double> & dummyArray = oslDels;

   myLpModel_->generateOslVectors (oslMrow, oslMcol, oslDels);

   callOsl (
      ekklmdl
         (
         rtCodePtr (),
         dSpace (),
         2,
         myLpModel_->nLpCons (),
         myLpModel_->nLpVars (),
         myLpModel_->nCoeffs (),
         dummyArray.myCvectorForUpdate (),
         dummyArray.myCvectorForUpdate (),
         dummyArray.myCvectorForUpdate (),
         dummyArray.myCvectorForUpdate (),
         dummyArray.myCvectorForUpdate (),
         oslMrow.   myCvectorForUpdate () + 1,
         oslMcol.   myCvectorForUpdate () + 1,
         oslDels.   myCvectorForUpdate () + 1))
d477 1
a477 1
   checkRtCode ("lmdl");
d479 1
a479 3
   setVal (RMAXMIN, -1.0);
      //
      // Maximize.
d484 1
a484 1
void WitOslMgr::passFlexibleModel ()
d486 3
a488 4
   myLpModel_->passBounds (
      dSpaceArray (NCOLLOWER),
      dSpaceArray (NCOLUPPER),
      (const WitList <WitModelEl> &) myLpModel_->myLpVars ());
d490 1
a490 4
   myLpModel_->passBounds (
      dSpaceArray (NROWLOWER),
      dSpaceArray (NROWUPPER),
      (const WitList <WitModelEl> &) myLpModel_->myLpCons ());
d492 1
a492 1
   myLpModel_->passObj (dSpaceArray (NOBJECTIVE));
d497 1
a497 1
void WitOslMgr::passPrimal ()
d499 7
a505 1
   myLpModel_->passPrimal (dSpaceArray (NCOLSOL));
d515 1
a515 1
   probStat = getVal (IPROBSTAT);
d545 1
a545 1
   myMsgFac () ("oslOptimalNotFoundFmsg",
d547 1
a547 1
      myMsgFac ().myFrag (statFragID[index]));
d552 1
a552 1
void WitOslMgr::recordPrimal ()
d554 2
a555 1
   myLpModel_->recordPrimal (dSpaceArray (NCOLSOL));
d560 1
a560 1
void WitOslMgr::recordDual ()
d562 1
a562 4
   myLpModel_->recordDual (dSpaceArray (NROWDUALS));
   }

//------------------------------------------------------------------------------
d564 2
a565 6
void WitOslMgr::solveOslUnAcc ()
   {
   if (myOptImploder_->myOptComp ()->optInitMethod ()->external ())
      passPrimal ();
         //
         // Pass initial primal solution to OSL.
d567 1
a567 50
   callOsl (ekkscal (rtCodePtr (), dSpace ()))

   checkRtCode ("scal");

      // ekkprsl and pssl are only called if myLpModel_ is non-trivial, to
      // prevent prsl from eliminating the whole problem and giving a severe
      // error.
      //
   if (! myLpModel_->isTrivial ())
      {
      openPrslFile ();

      callOsl (ekkprsl (rtCodePtr (), dSpace (), prslUnit_, 3))

      if (rtCode () == 210)
         myLpModel_->reportInfeasible ();

      if (rtCode () == 340)
         myMsgFac () ("oslPrslFileSpaceError", prslTempFileName_);

      checkRtCode ("prsl");
      }

   if (myOptImploder_->myOptComp ()->crashOptStarter ()->isChosen ())
      {
      callOsl (ekkcrsh (rtCodePtr (), dSpace (), 3))

      checkRtCode ("crsh");
      }

   callOsl (ekksslv (rtCodePtr (), dSpace (), 1, 3))

   checkRtCode ("sslv");

   checkProbStat ();

   if (! myLpModel_->isTrivial ())
      {
      callOsl (ekkpssl (rtCodePtr (), dSpace (), prslUnit_))

      checkRtCode ("pssl");

      closePrslFile ();
      }

   callOsl (ekksslv (rtCodePtr (), dSpace (), 1, 3))

   checkRtCode ("sslv");

   checkProbStat ();
d570 1
a570 1
#endif
@


1.10
log
@Began implementation of optimizing implosion with OSL V3.
@
text
@d122 2
a123 2
   if (myOptImploder_->dumpMps ())
      dumpMpsDeck ();
d467 1
a467 1
void WitOslMgr::dumpMpsDeck ()
d469 1
a469 1
   myMsgFac () ("mpsDeckMsg");
@


1.9
log
@Continued implementation of single-source.
@
text
@d29 8
d677 2
@


1.8
log
@Preliminary work on single source.
@
text
@d24 1
d592 1
a592 1
      myMsgFac ()[statFragID[index]]);
@


1.7
log
@Preliminary work on single source.
@
text
@d253 3
a255 1
   WitString logFileName (myOptImploder_->myOptComp ()->oslMesgFileName ());
@


1.6
log
@Preliminary work on single source.
@
text
@d493 3
a495 3
   WitVector (long)   oslMrow (myLpModel_->nCoeffs () + 1, 0);
   WitVector (long)   oslMcol (myLpModel_->nLpVars () + 2, 0);
   WitVector (double) oslDels (dummyArraySize,           0.0);
d497 1
a497 1
   WitVector (double) & dummyArray = oslDels;
@


1.5
log
@Began implementation of object iteration.
@
text
@d533 1
a533 1
      (const WitList (WitModelEl) &) myLpModel_->myLpVars ());
d538 1
a538 1
      (const WitList (WitModelEl) &) myLpModel_->myLpCons ());
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d24 1
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d289 1
a289 1
   prslTempFileName_ = WitUtil::tempFileName ("witpr");
d317 1
a317 1
   WitUtil::portableFree (prslTempFileName_);
d359 1
a359 1
   WitUtil::set_new_handler (NULL);
d367 1
a367 1
   WitUtil::set_new_handler (WitUtil::newError);
d488 3
a490 3
   WitUtil::setToMax (dummyArraySize, myLpModel_->nCoeffs () + 1);
   WitUtil::setToMax (dummyArraySize, myLpModel_->nLpVars ());
   WitUtil::setToMax (dummyArraySize, myLpModel_->nLpCons ());
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d488 3
a490 3
   WitUtil::updateToMax (dummyArraySize, myLpModel_->nCoeffs () + 1);
   WitUtil::updateToMax (dummyArraySize, myLpModel_->nLpVars ());
   WitUtil::updateToMax (dummyArraySize, myLpModel_->nLpCons ());
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

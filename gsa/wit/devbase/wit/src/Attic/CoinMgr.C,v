head	1.60;
access;
symbols;
locks; strict;
comment	@ * @;


1.60
date	2011.08.25.23.26.59;	author rjw;	state dead;
branches;
next	1.59;

1.59
date	2011.02.09.19.13.21;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2010.12.10.00.40.25;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2010.12.07.00.29.44;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2010.12.04.00.29.43;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2010.11.17.20.20.51;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2010.11.12.22.03.04;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2010.11.04.20.32.37;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2010.11.03.20.25.32;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2010.08.27.21.06.49;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.24.19.36.20;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2010.08.20.21.07.36;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2010.08.20.19.42.21;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2010.08.20.16.43.58;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.19.18.00.10;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.18.20.58.22;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.04.23.24.56;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.02.18.38.41;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.28.20.51.43;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.28.18.08.30;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.24.20.32.07;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.24.18.10.28;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.24.16.09.29;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.21.23.46.13;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.21.15.28.00;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.20.23.18.42;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.20.17.40.17;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.19.21.09.03;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.19.20.34.09;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.19.16.07.35;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.13.21.57.50;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.12.18.38.06;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.07.23.27.35;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.07.23.18.59;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.26.22.22.52;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.24.21.31.01;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2010.03.11.22.36.23;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2010.03.11.19.02.39;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.09.20.12.24;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.04.23.11.32;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.04.22.18.35;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.03.22.07.48;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.02.23.07.55;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.19.21.03.09;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2010.02.19.20.09.13;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2010.02.16.20.47.03;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.16.19.29.39;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2010.02.12.23.49.43;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.12.22.33.08;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.08.21.39.43;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.08.20.15.25;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.08.20.11.38;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.28.20.10.11;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.16.00.09.07;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.15.22.24.39;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.15.20.44.15;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.15.17.13.02;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.14.22.30.16;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.21.04.27;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.13.19.52.08;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Removed COIN from WIT.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "CoinMgr.C"
//
// Contains the implementation of class CoinMgr.
//    The implementation compiled only if COIN_EMBEDDED is #defined.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Implementation of class CoinMgr.
//------------------------------------------------------------------------------

#ifdef COIN_EMBEDDED

#include <CoinMgr.h>
#include <OptCon.h>
#include <OptVar.h>
#include <OptProblem.h>
#include <OptStarter.h>
#include <OptComp.h>
#include <MultiObjMgr.h>
#include <SaeMgr.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <Timing.h>

#include <ClpPresolve.hpp>
#include <ClpFactorization.hpp>

//------------------------------------------------------------------------------
// Inlines.
//------------------------------------------------------------------------------

inline bool WitCoinMgr::multiObjMode ()
   {
   return myOptComp ()->multiObjMode ();
   }

//------------------------------------------------------------------------------
// Non-inlines.
//------------------------------------------------------------------------------

WitCoinMgr::WitCoinMgr (WitOptProblem * theOptProblem):

      WitSolverMgr    (theOptProblem),
      lpModeOsiClpSI_ (NULL),
      myCbcModel_     (NULL)
   {
   WitTimer::enterSection ("coin");

   setUpCoin ();

   WitTimer::leaveSection ("coin");
   }

//------------------------------------------------------------------------------

WitCoinMgr::~WitCoinMgr ()
   {
   WitTimer::enterSection ("coin");

   shutDownCoin ();

   WitTimer::leaveSection ("coin");
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solveOptProb ()
   {
   WitTimer::enterSection ("coin");

   if (myOptProblem ()->reSolveMode ())
      {
      myMsgFac () ("reSolveLpMsg", "COIN");
      }
   else
      {
      myMsgFac () ("solveOptProblemMsg",
         myMsgFac ().myFrag (mipMode ()? "mipFrag": "lpFrag"),
         "COIN");

      if (multiObjMode ())
         myMsgFac () ("lexOptMsg");

      loadFixedProb ();
      }

   loadFlexibleProb ();

   writeMps ();

   if      (multiObjMode () and mipMode ())
      {
      solveLexMip ();
      }
   else if (multiObjMode ())
      {
      solveLexLp ();
      }
   else if (mipMode ())
      {
      solveMip ();
      }
   else if (myOptProblem ()->reSolveMode ())
      {
      reSolveLp ();
      }
   else
      {
      solveLp ();
      }

   if (not multiObjMode ())
      myMsgFac () ("optSolnFoundMsg");

   storePrimalSoln ();

   if (myOptProblem ()->needDual ())
      storeDualSoln ();

   WitTimer::leaveSection ("coin");
   }

//------------------------------------------------------------------------------

void WitCoinMgr::setUpCoin ()
   {
   if (mipMode ())
      {
      OsiClpSolverInterface * theOsiClpSI;

      theOsiClpSI = new OsiClpSolverInterface;

      myCbcModel_ = new CbcModel (* theOsiClpSI);

      delete theOsiClpSI;
      }
   else
      lpModeOsiClpSI_ = new OsiClpSolverInterface;

   setUpMH ();
   }

//------------------------------------------------------------------------------

void WitCoinMgr::setUpMH ()
   {
   FILE *               theFile;
   CoinMessageHandler * theCMH;
   CoinMessageHandler * theCbcCMH;

   theFile = openFile (myOptComp ()->solverLogFileName ().myCstring (), "w");

   theCMH  = new CoinMessageHandler (theFile);

   theCMH->setLogLevel (myOptComp ()->coinLogLevel ());

   myOsiSI ()     ->passInMessageHandler (theCMH);
   myClpSimplex ()->passInMessageHandler (theCMH);

   if (mipMode ())
      {
      theCbcCMH  = new CoinMessageHandler (theFile);

      theCbcCMH->setLogLevel (2);

      myCbcModel ()->passInMessageHandler (theCbcCMH);
      }
   }

//------------------------------------------------------------------------------

void WitCoinMgr::shutDownCoin ()
   {
   CoinMessageHandler * theCMH;
   CoinMessageHandler * theCbcCMH;

   theCMH = myOsiSI ()->messageHandler ();

   if (mipMode ())
      {
      theCbcCMH = myCbcModel_->messageHandler ();

      delete myCbcModel_;

      myCbcModel_ = NULL;

      delete theCbcCMH;

      theCbcCMH = NULL;
      }
   else
      {
      delete lpModeOsiClpSI_;

      lpModeOsiClpSI_ = NULL;
      }

   shutDownCMH (theCMH);
   }

//------------------------------------------------------------------------------

void WitCoinMgr::shutDownCMH (CoinMessageHandler * & theCMH)
   {
   FILE * theFile;
   int    fcloseRes;

   theFile = theCMH->filePointer ();

   delete theCMH;

   theCMH    = NULL;

   fcloseRes = fclose (theFile);

   if (fcloseRes != 0)
      myMsgFac () ("fcloseSmsg", myOptComp ()->solverLogFileName ());
   }

//------------------------------------------------------------------------------

void WitCoinMgr::loadFixedProb ()
   {
   WitVector <int>    firstCoeffIdx;
   WitVector <int>    rowIdx;
   WitVector <double> coeffVal;

   WitTimer::enterSection ("opt-prob");

   myOptProblem ()->getMatrixByCols (firstCoeffIdx, rowIdx, coeffVal);

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->loadProblem (
      myOptProblem ()->nOptVars (),
      myOptProblem ()->nOptCons (),
      firstCoeffIdx.myCVec (),
      rowIdx.myCVec (),
      coeffVal.myCVec (),
      NULL,
      NULL,
      NULL,
      NULL,
      NULL);
     
   myOsiSI ()->setObjSense (-1.0);
 
   if (mipMode ())
      markIntVars ();
   }

//------------------------------------------------------------------------------

void WitCoinMgr::markIntVars ()
   {
   WitOptVar * theOptVar;

   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
      if (theOptVar->isAnIntVar ())
         myOsiSI ()->setInteger (theOptVar->index ());
   }

//------------------------------------------------------------------------------

void WitCoinMgr::loadFlexibleProb ()
   {
   loadConBounds ();
   loadVarBounds ();
   loadObjCoeffs ();
   }

//------------------------------------------------------------------------------

void WitCoinMgr::loadConBounds ()
   {
   int                nCons;
   WitVector <int>    indexVec;
   WitVector <double> boundVec;
   int                theRowIdx;
   WitOptCon *        theOptCon;

   WitTimer::enterSection ("opt-prob");

   nCons = myOptProblem ()->nOptCons ();

   indexVec.resize (nCons + 1);
   boundVec.resize (nCons * 2);

   theRowIdx = -1;

   forEachEl (theOptCon, myOptProblem ()->myOptCons ())
      {
      theRowIdx ++;

      witAssert (theRowIdx == theOptCon->index ());

      indexVec[theRowIdx        ] = theRowIdx;
      boundVec[theRowIdx * 2    ] = theOptCon->bounds ().lower ();
      boundVec[theRowIdx * 2 + 1] = theOptCon->bounds ().upper ();
      }

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->setRowSetBounds (
      indexVec.myCVec (),
      indexVec.myCVec () + nCons,
      boundVec.myCVec ());
   }

//------------------------------------------------------------------------------

void WitCoinMgr::loadVarBounds ()
   {
   int                nVars;
   WitVector <int>    indexVec;
   WitVector <double> boundVec;
   int                theColIdx;
   WitOptVar *        theOptVar;

   WitTimer::enterSection ("opt-prob");

   nVars = myOptProblem ()->nOptVars ();

   indexVec.resize (nVars + 1);
   boundVec.resize (nVars * 2);

   theColIdx = -1;

   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
      {
      theColIdx ++;

      witAssert (theColIdx == theOptVar->index ());

      indexVec[theColIdx        ] = theColIdx;
      boundVec[theColIdx * 2    ] = theOptVar->bounds ().lower ();
      boundVec[theColIdx * 2 + 1] = theOptVar->bounds ().upper ();
      }

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->setColSetBounds (
      indexVec.myCVec (),
      indexVec.myCVec () + nVars,
      boundVec.myCVec ());
   }

//------------------------------------------------------------------------------

void WitCoinMgr::loadObjCoeffs ()
   {
   int                nVars;
   WitVector <int>    indexVec;
   WitVector <double> objVec;
   WitOptVar *        theOptVar;
   int                theColIdx;

   WitTimer::enterSection ("opt-prob");

   nVars = myOptProblem ()->nOptVars ();

   indexVec.resize (nVars + 1);
   objVec  .resize (nVars);

   theColIdx = -1;

   forEachEl (theOptVar, myOptProblem ()->myOptVars ())
      {
      theColIdx ++;

      witAssert (theColIdx == theOptVar->index ());

      indexVec[theColIdx] = theColIdx;
      objVec  [theColIdx] = theOptVar->objCoeff ();

      if (multiObjMode ())
         {
         witAssert (objVec[theColIdx] == 0.0);
         }
      }

   WitTimer::leaveSection ("opt-prob");

   myOsiSI ()->setObjCoeffSet (
      indexVec.myCVec (),
      indexVec.myCVec () + nVars,
      objVec.myCVec ());
   }

//------------------------------------------------------------------------------

void WitCoinMgr::writeMps ()
   {
   if (myOptComp ()->printMps ())
      {
      myMsgFac () ("mpsFileMsg");

      myClpSimplex ()->writeMps ("opt-prob.mps", 1, 1, +1.0);
         //
         // Arguments:
         //    File name
         //    Format with "extra accuracy"
         //    One matrix element per line
         //    Maximization (multiplies objective coeffs by -1)
      }
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solveMip ()
   {
   stronglyAssert (mipMode ());

   myCbcModel ()->initialSolve ();

   checkLpSolnStatus ();

   myCbcModel ()->branchAndBound ();

   checkMipSolnStatus ();
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solveLexMip ()
   {
   OsiSolverInterface *     ongoingOsiSI;
   WitPtrVecItr <WitOptVar> theOptVarItr;
   WitOptVar *              theOptVar;

   ongoingOsiSI = myOsiSI ()->clone ();

   myOptProblem ()->myLexOptVarSeq ().attachItr (theOptVarItr);

   theOptVarItr.advance (theOptVar);

   solveLexObjElemMip (theOptVar, ongoingOsiSI);

   while (theOptVarItr.advance (theOptVar))
      {
      renewCbcModel (ongoingOsiSI);

      solveLexObjElemMip (theOptVar, ongoingOsiSI);
      }

   delete ongoingOsiSI;
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solveLexObjElemMip (
      WitOptVar *          theOptVar,
      OsiSolverInterface * ongoingOsiSI)
   {
   int    theColIdx;
   double curObjVal;

   myMsgFac () ("optLexObjElemMsg", theOptVar->lexObjElemName ());

   theColIdx = theOptVar->index ();

   myOsiSI ()->setObjCoeff (theColIdx, 1.0);

   myCbcModel ()->initialSolve ();

   checkLpSolnStatus ();

   myCbcModel ()->branchAndBound ();

   checkMipSolnStatus ();

   curObjVal = myOsiSI ()->getColSolution ()[theColIdx];

   ongoingOsiSI->setColBounds (theColIdx, curObjVal, DBL_MAX);

   myMsgFac () ("optSolnFoundMsg");
   }

//------------------------------------------------------------------------------

void WitCoinMgr::renewCbcModel (OsiSolverInterface * ongoingOsiSI)
   {
   CoinMessageHandler * theCMH;

   theCMH      = myCbcModel ()->messageHandler ();

   delete myCbcModel_;

   myCbcModel_ = new CbcModel (* ongoingOsiSI);

   myCbcModel_->passInMessageHandler (theCMH);
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solveLexLp ()
   {
   bool                     isFirstLexElem;
   WitPtrVecItr <WitOptVar> theOptVarItr;
   WitOptVar *              theOptVar;
   int                      theColIdx;
   bool                     useDual;

   if (DEVELOPMENT)
      WitTimer::getTimeAndChargeToCurrent ();

   loadInitSoln ();

   isFirstLexElem = true;

   myOptProblem ()->myLexOptVarSeq ().attachItr (theOptVarItr);

   while (theOptVarItr.advance (theOptVar))
      {
      myMsgFac () ("optLexObjElemMsg", theOptVar->lexObjElemName ());

      theColIdx = theOptVar->index ();

      myOsiSI ()->setObjCoeff (theColIdx, 1.0);

      if (isFirstLexElem)
         useDual = myOptComp ()->crashOptStarter ()->isChosen ();
      else
         useDual = false;

      solveLpAsUsual (useDual);

      checkLpSolnStatus ();

      lockLexObjElemVal (theOptVar);

      myOsiSI ()->setObjCoeff (theColIdx, 0.0);

      myMsgFac () ("optSolnFoundMsg");

      if (DEVELOPMENT)
         if (WitSaeMgr::standAloneMode ())
            myMsgFac () ("lexObjElemCpuTimeMsg",
               WitTimer::getTimeAndChargeToCurrent ());

      isFirstLexElem = false;
      }
   }

//------------------------------------------------------------------------------

void WitCoinMgr::lockLexObjElemVal (WitOptVar * theOptVar)
   {
   int    theColIdx;
   double optObjVal;
   double moTol;
   double theTol;

   theColIdx = theOptVar->index ();

   optObjVal = myOsiSI ()->getColSolution ()[theColIdx];

   moTol     = myOptComp ()->myMultiObjMgr ()->multiObjTol ();

   theTol    = WitNonClass::max (moTol * fabs (optObjVal), moTol);

   myOsiSI ()->setColBounds (theColIdx, optObjVal - theTol, DBL_MAX);
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solveLp ()
   {
   bool useDual;

   loadInitSoln ();

   useDual = myOptComp ()->crashOptStarter ()->isChosen ();

   solveLpAsUsual (useDual);

   checkLpSolnStatus ();
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solveLpAsUsual (bool useDual)
   {
   ClpPresolve thePresolve;

   thePresolve.setDoDual (useDual);

   thePresolve.presolvedModel (* myClpSimplex (), 1.0e-8, false, 5, true);

   if (thePresolve.model () != NULL)
      {
      invokeSimplex (thePresolve.model (), useDual);

      thePresolve.postsolve (true);
	  
      delete thePresolve.model ();

      cleanUpSimplex ();
      }
   else
      {
      if (DEVELOPMENT)
         myMsgFac () ("presolveNullMsg");

      invokeSimplex (myClpSimplex (), useDual);
      }
   }

//------------------------------------------------------------------------------

void WitCoinMgr::invokeSimplex (ClpSimplex * theClpSimplex, bool useDual)
   {
   theClpSimplex->
      setFactorizationFrequency (100 + theClpSimplex->numberRows () / 50);

   if (useDual)
      {
      theClpSimplex->tightenPrimalBounds ();

      theClpSimplex->dual ();
      }
   else
      theClpSimplex->primal (1);
   }

//------------------------------------------------------------------------------

void WitCoinMgr::cleanUpSimplex ()
   {
   myClpSimplex ()->factorization ()->areaFactor (0.5);

   myClpSimplex ()->primal (1);
   }

//------------------------------------------------------------------------------

void WitCoinMgr::loadInitSoln ()
   {
   WitVector <double> initSoln;
      
   if (not myOptComp ()->optInitMethod ()->external ())
      return;

   WitSolverMgr::getInitSoln (initSoln);

   myOsiSI ()->setColSolution (initSoln.myCVec ());
   }

//------------------------------------------------------------------------------

void WitCoinMgr::reSolveLp ()
   {
   double totPrimalInf;
   double totDualInf;
   bool   useDual;

   myClpSimplex ()->checkSolution ();

   totPrimalInf = myClpSimplex ()->sumPrimalInfeasibilities ();
   totDualInf   = myClpSimplex ()->sumDualInfeasibilities ();

   if (myOptComp ()->accMethod () >= 1)
      fprintf (msgFile (),
         "\n"
         "# Primal Infeasibilities: %d\n"
         "Tot Primal Infeasibility: %g\n"
         "# Dual Infeasibilities:   %d\n"
         "Tot Dual Infeasibility:   %g\n",
         myClpSimplex ()->numberPrimalInfeasibilities (),
         totPrimalInf,
         myClpSimplex ()->numberDualInfeasibilities (),
         totDualInf);

   useDual =
      (myOptComp ()->accMethod () == 2)? false:
      (myOptComp ()->accMethod () == 3)? true:
      (totPrimalInf > totDualInf)?       true:
                                         false;

   if (useDual)
      {
      if (myOptComp ()->accMethod () >= 1)
         fprintf (msgFile (), "Dual Simplex invoked.\n\n");
      
      myClpSimplex ()->dual (0);
      }
   else
      {
      if (myOptComp ()->accMethod () >= 1)
         fprintf (msgFile (), "Primal Simplex invoked.\n\n");

      myClpSimplex ()->primal (0);
      }

   checkLpSolnStatus ();
   }

//------------------------------------------------------------------------------

void WitCoinMgr::checkLpSolnStatus ()
   {
   WitMsgFragID theFragID;

   if      (myOsiSI ()->isProvenOptimal ())
      {
      return;
      }

   else if (myOsiSI ()->isProvenPrimalInfeasible ())
      {
      myMsgFac () ("infeasSmsg");
      }

   else if (myOsiSI ()->isProvenDualInfeasible ())
      {
      myMsgFac () ("unboundedOrInfeasSmsg");
      }

   else if (myOsiSI ()->isAbandoned ())
      {
      myMsgFac () ("optProbAbandonedSmsg");
      }

   else
      {
      myMsgFac () ("noOptReasonUnknownSmsg");
      }
   }

//------------------------------------------------------------------------------

void WitCoinMgr::checkMipSolnStatus ()
   {
   WitMsgFragID theFragID;

   if      (myCbcModel ()->isProvenOptimal ())
      {
      return;
      }

   else if (myCbcModel ()->isProvenInfeasible ())
      {
      myMsgFac () ("infeasSmsg");
      }

   else if (myCbcModel ()->isAbandoned ())
      {
      myMsgFac () ("optProbAbandonedSmsg");
      }

   else
      {
      myMsgFac () ("noOptReasonUnknownSmsg");
      }
   }

//------------------------------------------------------------------------------

void WitCoinMgr::storePrimalSoln ()
   {
   const double * primalSoln;

   primalSoln = myOsiSI ()->getColSolution ();

   WitSolverMgr::storePrimalSoln (primalSoln);
   }

//------------------------------------------------------------------------------

void WitCoinMgr::storeDualSoln ()
   {
   const double * dualSoln;

   dualSoln = myOsiSI ()->getRowPrice ();

   WitSolverMgr::storeDualSoln (dualSoln);
   }

//------------------------------------------------------------------------------

OsiSolverInterface * WitCoinMgr::myOsiSI ()
   {
   return
      mipMode ()?
         myCbcModel ()->solver ():
         lpModeOsiClpSI_;
   }

//------------------------------------------------------------------------------

ClpSimplex * WitCoinMgr::myClpSimplex ()
   {
   if (mipMode ())
      {
      OsiClpSolverInterface * theOsiClpSI;

      theOsiClpSI =
         static_cast <OsiClpSolverInterface *> (myCbcModel ()->solver ());

      return theOsiClpSI->getModelPtr ();
      }
   else
      return lpModeOsiClpSI_->getModelPtr ();
   }

//------------------------------------------------------------------------------

#endif // COIN_EMBEDDED
@


1.59
log
@CPLEX
@
text
@@


1.58
log
@CPLEX
@
text
@a12 3
// Contains the implementation NonClass function coinEmbedded ().
// Contains the implementation NonClass function newSolverMgrForCoin (...).
//
a16 43
#include <CoinMgr.h>
#include <OptComp.h>

//------------------------------------------------------------------------------
// Implementation NonClass function coinEmbedded ().
//
// Declared in OptComp.h.
//------------------------------------------------------------------------------

bool WitNonClass::coinEmbedded ()
   {
#ifdef COIN_EMBEDDED

   return true;

#else

   return false;

#endif
   }

//------------------------------------------------------------------------------
// Implementation NonClass function newSolverMgrForCoin (...).
//
// Declared in SolverMgr.h.
//------------------------------------------------------------------------------

WitSolverMgr * WitNonClass::newSolverMgrForCoin (WitOptProblem * theOptProblem)
   {
#ifdef COIN_EMBEDDED

   return new WitCoinMgr (theOptProblem);

#else

   stronglyAssert (false);

   return NULL;

#endif
   }

d23 1
@


1.57
log
@CPLEX
@
text
@a86 7
inline bool WitCoinMgr::mipMode ()
   {
   return myOptComp ()->mipMode ();
   }

//------------------------------------------------------------------------------

@


1.56
log
@CPLEX
@
text
@d592 1
a592 1
      lockLexObjElemVal (theColIdx);
d609 1
a609 1
void WitCoinMgr::lockLexObjElemVal (int theColIdx)
d611 1
d616 2
@


1.55
log
@CPLEX
@
text
@d144 1
a144 1
         myMsgFac () ("lexObjMsg");
@


1.54
log
@CPLEX
@
text
@d129 1
a129 1
void WitCoinMgr::solve ()
@


1.53
log
@CPLEX
@
text
@a71 1
#include <DetOptImpMgr.h>
d133 1
a133 1
   if (myDetOptImpMgr ()->accelerated ())
d165 1
a165 1
   else if (myDetOptImpMgr ()->accelerated ())
d167 1
a167 1
      solveLpAcc ();
d171 1
a171 1
      solveLpUnacc ();
d626 1
a626 1
void WitCoinMgr::solveLpUnacc ()
d710 1
a710 1
void WitCoinMgr::solveLpAcc ()
@


1.52
log
@CPLEX
@
text
@d108 1
a108 2
      myCbcModel_     (NULL),
      coinIsSetUp_    (false)
d110 5
a146 2
      setUpCoin ();

a189 3
   if (coinIsSetUp_)
      return;

a203 2

   coinIsSetUp_ = true;
d235 50
a840 55
void WitCoinMgr::shutDownCoin ()
   {
   CoinMessageHandler * theCMH;
   CoinMessageHandler * theCbcCMH;

   if (not coinIsSetUp_)
      return;

   theCMH = myOsiSI ()->messageHandler ();

   if (mipMode ())
      {
      theCbcCMH = myCbcModel_->messageHandler ();

      delete myCbcModel_;

      myCbcModel_ = NULL;

      delete theCbcCMH;

      theCbcCMH = NULL;
      }
   else
      {
      delete lpModeOsiClpSI_;

      lpModeOsiClpSI_ = NULL;
      }

   shutDownCMH (theCMH);

   coinIsSetUp_ = false;
   }

//------------------------------------------------------------------------------

void WitCoinMgr::shutDownCMH (CoinMessageHandler * & theCMH)
   {
   FILE * theFile;
   int    fcloseRes;

   theFile = theCMH->filePointer ();

   delete theCMH;

   theCMH    = NULL;

   fcloseRes = fclose (theFile);

   if (fcloseRes != 0)
      myMsgFac () ("fcloseSmsg", myOptComp ()->solverLogFileName ());
   }

//------------------------------------------------------------------------------

@


1.51
log
@CPLEX
@
text
@d132 1
a132 1
      myMsgFac () ("reSolveLpMsg");
@


1.50
log
@CPLEX
@
text
@d453 1
a453 1
   solveLexObjElemMip (theOptVar, ongoingOsiSI, true);
d459 1
a459 1
      solveLexObjElemMip (theOptVar, ongoingOsiSI, false);
d469 1
a469 2
      OsiSolverInterface * ongoingOsiSI,
      bool                 isFirstLexElem)
d482 1
a482 1
   checkLexLpSolnStatus (theOptVar, isFirstLexElem);
d486 1
a486 1
   checkLexMipSolnStatus (theOptVar, isFirstLexElem);
d544 1
a544 1
      checkLexLpSolnStatus (theOptVar, isFirstLexElem);
d717 2
a718 1
   if (myOsiSI ()->isProvenOptimal ())
d720 1
d722 4
a725 2
   if (myOsiSI ()->isProvenPrimalInfeasible ())
      myOptProblem ()->reportInfeasible ();
d727 4
a730 2
   if (myOsiSI ()->isProvenDualInfeasible ())
      myOptProblem ()->reportUnbounded ();
d732 4
a735 5
   theFragID =
      myOsiSI ()->isProvenPrimalInfeasible ()?        "primalInfeasFrag":
      myOsiSI ()->isProvenDualInfeasible   ()?          "dualInfeasFrag":
      myOsiSI ()->isAbandoned              ()?           "abandonedFrag":
                                               "unknownNonOptReasonFrag";
d737 4
a740 1
   myMsgFac () ("optimalNotFoundFmsg", "CLP", myMsgFac ().myFrag (theFragID));
d749 2
a750 1
   if (myCbcModel ()->isProvenOptimal ())
d752 1
d754 4
a757 2
   if (myCbcModel ()->isProvenInfeasible ())
      myOptProblem ()->reportInfeasible ();
d759 4
a762 4
   theFragID =
      myCbcModel ()->isProvenInfeasible ()?        "primalInfeasFrag":
      myCbcModel ()->isAbandoned        ()?           "abandonedFrag":
                                            "unknownNonOptReasonFrag";
d764 4
a767 51
   myMsgFac () ("optimalNotFoundFmsg", "CBC", myMsgFac ().myFrag (theFragID));
   }

//------------------------------------------------------------------------------

void WitCoinMgr::checkLexLpSolnStatus (
      WitOptVar * theOptVar,
      bool        isFirstLexElem)
   {
   WitMsgFragID theFragID;

   if (myOsiSI ()->isProvenOptimal ())
      return;

   if (isFirstLexElem)
      if (myOsiSI ()->isProvenPrimalInfeasible ())
         myOptProblem ()->reportInfeasible ();

   if (myOsiSI ()->isProvenDualInfeasible ())
      theOptVar->reportLexUnbounded ();

   theFragID =
      myOsiSI ()->isProvenPrimalInfeasible ()?        "primalInfeasFrag":
      myOsiSI ()->isProvenDualInfeasible   ()?          "dualInfeasFrag":
      myOsiSI ()->isAbandoned              ()?           "abandonedFrag":
                                               "unknownNonOptReasonFrag";

   myMsgFac () ("optimalNotFoundFmsg", "CLP", myMsgFac ().myFrag (theFragID));
   }

//------------------------------------------------------------------------------

void WitCoinMgr::checkLexMipSolnStatus (
      WitOptVar * theOptVar,
      bool        isFirstLexElem)
   {
   WitMsgFragID theFragID;

   if (myCbcModel ()->isProvenOptimal ())
      return;

   if (isFirstLexElem)
      if (myCbcModel ()->isProvenInfeasible ())
         myOptProblem ()->reportInfeasible ();

   theFragID =
      myCbcModel ()->isProvenInfeasible ()?        "primalInfeasFrag":
      myCbcModel ()->isAbandoned        ()?           "abandonedFrag":
                                            "unknownNonOptReasonFrag";

   myMsgFac () ("optimalNotFoundFmsg", "CBC", myMsgFac ().myFrag (theFragID));
@


1.49
log
@CPLEX
@
text
@d108 1
a108 1
      myCbcModyl_     (NULL),
d197 1
a197 1
      myCbcModyl_ = new CbcModyl (* theOsiClpSI);
d232 1
a232 1
      myCbcModyl ()->passInMessageHandler (theCbcCMH);
d430 1
a430 1
   myCbcModyl ()->initialSolve ();
d434 1
a434 1
   myCbcModyl ()->branchAndBound ();
d457 1
a457 1
      renewCbcModyl (ongoingOsiSI);
d481 1
a481 1
   myCbcModyl ()->initialSolve ();
d485 1
a485 1
   myCbcModyl ()->branchAndBound ();
d498 1
a498 1
void WitCoinMgr::renewCbcModyl (OsiSolverInterface * ongoingOsiSI)
d502 1
a502 1
   theCMH      = myCbcModyl ()->messageHandler ();
d504 1
a504 1
   delete myCbcModyl_;
d506 1
a506 1
   myCbcModyl_ = new CbcModyl (* ongoingOsiSI);
d508 1
a508 1
   myCbcModyl_->passInMessageHandler (theCMH);
d742 1
a742 1
   if (myCbcModyl ()->isProvenOptimal ())
d745 1
a745 1
   if (myCbcModyl ()->isProvenInfeasible ())
d749 2
a750 2
      myCbcModyl ()->isProvenInfeasible ()?        "primalInfeasFrag":
      myCbcModyl ()->isAbandoned        ()?           "abandonedFrag":
d791 1
a791 1
   if (myCbcModyl ()->isProvenOptimal ())
d795 1
a795 1
      if (myCbcModyl ()->isProvenInfeasible ())
d799 2
a800 2
      myCbcModyl ()->isProvenInfeasible ()?        "primalInfeasFrag":
      myCbcModyl ()->isAbandoned        ()?           "abandonedFrag":
d842 1
a842 1
      theCbcCMH = myCbcModyl_->messageHandler ();
d844 1
a844 1
      delete myCbcModyl_;
d846 1
a846 1
      myCbcModyl_ = NULL;
d889 1
a889 1
         myCbcModyl ()->solver ():
d902 1
a902 1
         static_cast <OsiClpSolverInterface *> (myCbcModyl ()->solver ());
@


1.48
log
@CPLEX
@
text
@a653 1
   WitOptVar *        theVar;
d658 1
a658 8
   WitTimer::enterSection ("opt-prob");

   initSoln.resize (myOptProblem ()->nOptVars (), 0.0);

   forEachEl (theVar, myOptProblem ()->myOptVars ())
      initSoln[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("opt-prob");
a810 2
   WitOptVar *    theVar;
   double         thePrimalVal;
d814 1
a814 10
   WitTimer::enterSection ("opt-prob");

   forEachEl (theVar, myOptProblem ()->myOptVars ())
      {
      thePrimalVal = primalSoln[theVar->index ()];

      theVar->setPrimalValue (thePrimalVal);
      }

   WitTimer::leaveSection ("opt-prob");
a821 2
   WitOptCon *    theCon;
   double         theDualVal;
d825 1
a825 10
   WitTimer::enterSection ("opt-prob");

   forEachEl (theCon, myOptProblem ()->myOptCons ())
      {
      theDualVal = dualSoln[theCon->index ()];

      theCon->setDualValue (theDualVal);
      }

   WitTimer::leaveSection ("opt-prob");
@


1.47
log
@CPLEX
@
text
@d145 1
a145 1
      passFixedProb ();
d148 1
a148 1
   passFlexibleProb ();
d238 1
a238 1
void WitCoinMgr::passFixedProb ()
d281 1
a281 1
void WitCoinMgr::passFlexibleProb ()
d283 3
a285 3
   passConBounds ();
   passVarBounds ();
   passObjCoeffs ();
d290 1
a290 1
void WitCoinMgr::passConBounds ()
d328 1
a328 1
void WitCoinMgr::passVarBounds ()
d366 1
a366 1
void WitCoinMgr::passObjCoeffs ()
d524 1
a524 1
   passInitSoln ();
d585 1
a585 1
   passInitSoln ();
d651 1
a651 1
void WitCoinMgr::passInitSoln ()
d659 2
a662 2
   WitTimer::enterSection ("opt-prob");

@


1.46
log
@CPLEX
@
text
@a178 1
      {
a179 1
      }
@


1.45
log
@CPLEX
@
text
@d48 1
a48 1
WitSolverMgr * WitNonClass::newSolverMgrForCoin (WitOptModel * theOptModel)
d52 1
a52 1
   return new WitCoinMgr (theOptModel);
d71 1
a71 1
#include <OptModel.h>
d104 1
a104 1
WitCoinMgr::WitCoinMgr (WitOptModel * theOptModel):
d106 1
a106 1
      WitSolverMgr    (theOptModel),
d108 1
a108 1
      myCbcModel_     (NULL),
d136 1
a136 1
      myMsgFac () ("solveOptModelMsg",
d178 1
a178 1
   if (myOptModel ()->needDual ())
d199 1
a199 1
      myCbcModel_ = new CbcModel (* theOsiClpSI);
d234 1
a234 1
      myCbcModel ()->passInMessageHandler (theCbcCMH);
d248 1
a248 1
   myOptModel ()->getMatrixByCols (firstCoeffIdx, rowIdx, coeffVal);
d253 2
a254 2
      myOptModel ()->nOptVars (),
      myOptModel ()->nOptCons (),
d276 1
a276 1
   forEachEl (theOptVar, myOptModel ()->myOptVars ())
d302 1
a302 1
   nCons = myOptModel ()->nOptCons ();
d309 1
a309 1
   forEachEl (theOptCon, myOptModel ()->myOptCons ())
d340 1
a340 1
   nVars = myOptModel ()->nOptVars ();
d347 1
a347 1
   forEachEl (theOptVar, myOptModel ()->myOptVars ())
d378 1
a378 1
   nVars = myOptModel ()->nOptVars ();
d385 1
a385 1
   forEachEl (theOptVar, myOptModel ()->myOptVars ())
d432 1
a432 1
   myCbcModel ()->initialSolve ();
d436 1
a436 1
   myCbcModel ()->branchAndBound ();
d451 1
a451 1
   myOptModel ()->myLexOptVarSeq ().attachItr (theOptVarItr);
d459 1
a459 1
      renewCbcModel   (ongoingOsiSI);
d483 1
a483 1
   myCbcModel ()->initialSolve ();
d487 1
a487 1
   myCbcModel ()->branchAndBound ();
d500 1
a500 1
void WitCoinMgr::renewCbcModel (OsiSolverInterface * ongoingOsiSI)
d504 1
a504 1
   theCMH      = myCbcModel ()->messageHandler ();
d506 1
a506 1
   delete myCbcModel_;
d508 1
a508 1
   myCbcModel_ = new CbcModel (* ongoingOsiSI);
d510 1
a510 1
   myCbcModel_->passInMessageHandler (theCMH);
d530 1
a530 1
   myOptModel ()->myLexOptVarSeq ().attachItr (theOptVarItr);
d661 1
a661 1
   initSoln.resize (myOptModel ()->nOptVars (), 0.0);
d665 1
a665 1
   forEachEl (theVar, myOptModel ()->myOptVars ())
d732 1
a732 1
      myOptModel ()->reportInfeasible ();
d735 1
a735 1
      myOptModel ()->reportUnbounded ();
d752 1
a752 1
   if (myCbcModel ()->isProvenOptimal ())
d755 2
a756 2
   if (myCbcModel ()->isProvenInfeasible ())
      myOptModel ()->reportInfeasible ();
d759 2
a760 2
      myCbcModel ()->isProvenInfeasible ()?        "primalInfeasFrag":
      myCbcModel ()->isAbandoned        ()?           "abandonedFrag":
d779 1
a779 1
         myOptModel ()->reportInfeasible ();
d801 1
a801 1
   if (myCbcModel ()->isProvenOptimal ())
d805 2
a806 2
      if (myCbcModel ()->isProvenInfeasible ())
         myOptModel ()->reportInfeasible ();
d809 2
a810 2
      myCbcModel ()->isProvenInfeasible ()?        "primalInfeasFrag":
      myCbcModel ()->isAbandoned        ()?           "abandonedFrag":
d828 1
a828 1
   forEachEl (theVar, myOptModel ()->myOptVars ())
d850 1
a850 1
   forEachEl (theCon, myOptModel ()->myOptCons ())
d874 1
a874 1
      theCbcCMH = myCbcModel_->messageHandler ();
d876 1
a876 1
      delete myCbcModel_;
d878 1
a878 1
      myCbcModel_ = NULL;
d921 1
a921 1
         myCbcModel ()->solver ():
d934 1
a934 1
         static_cast <OsiClpSolverInterface *> (myCbcModel ()->solver ());
@


1.44
log
@CPLEX
@
text
@d545 1
a545 1
      solveLpAsUusual (useDual);
d591 1
a591 1
   solveLpAsUusual (useDual);
d598 1
a598 1
void WitCoinMgr::solveLpAsUusual (bool useDual)
d743 1
a743 1
   myMsgFac () ("clpOptimalNotFoundFmsg", myMsgFac ().myFrag (theFragID));
d763 1
a763 1
   myMsgFac () ("cbcOptimalNotFoundFmsg", myMsgFac ().myFrag (theFragID));
d790 1
a790 1
   myMsgFac () ("clpOptimalNotFoundFmsg", myMsgFac ().myFrag (theFragID));
d813 1
a813 1
   myMsgFac () ("cbcOptimalNotFoundFmsg", myMsgFac ().myFrag (theFragID));
@


1.43
log
@CPLEX
@
text
@d137 2
a138 1
         myMsgFac ().myFrag (mipMode ()? "mipFrag": "lpFrag"));
@


1.42
log
@CPLEX
@
text
@d26 1
a26 1
// Declared in SolverMgr.h.
@


1.41
log
@CPLEX
@
text
@d17 1
a17 1
//    The implementation compiled only if COIN_EMBEDDED == 1.
a23 13
// The following code verifies that COIN_EMBEDDED is defined as either 0 or 1.
//------------------------------------------------------------------------------

#if (COIN_EMBEDDED != 0) && (COIN_EMBEDDED != 1)

Invalid_Code;
   //
   // The above code results in a syntax error, when COIN_EMBEDDED is not
   // defined as either 0 or 1.

#endif

//------------------------------------------------------------------------------
d31 1
a31 1
#if COIN_EMBEDDED == 1
d50 1
a50 1
#if COIN_EMBEDDED == 1
d67 1
a67 1
#if COIN_EMBEDDED == 1
d943 1
a943 1
#endif // COIN_EMBEDDED == 1
@


1.40
log
@CPLEX
@
text
@d13 1
d21 1
d37 19
@


1.39
log
@Embedded CPLEX.
@
text
@d15 1
a15 1
// Contains the implementations of class CoinMgr.
@


1.38
log
@Modified comments.
@
text
@a19 11
#include <OptCon.h>
#include <OptVar.h>
#include <OptModel.h>
#include <DetOptImpMgr.h>
#include <OptStarter.h>
#include <OptComp.h>
#include <MultiObjMgr.h>
#include <SaeMgr.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <Timing.h>
d61 12
@


1.37
log
@CPLEX
@
text
@d47 2
@


1.36
log
@CPLEX
@
text
@d13 2
d16 1
a16 13
//
// This file contains two implementations of class CoinMgr, only one of which
// gets compiled:
//
// * When COIN_EMBEDDED == 1, the main implementation is compiled.
//   The main implementation of class CoinMgr invokes COIN to fulfill the
//   responsibilities of class SolverMgr.
// 
// * When COIN_EMBEDDED == 0, the dummy implementation is compiled.
//   The dummy implementation of class CoinMgr does not invoke COIN 
//   It generates a fatal error if any of its member functions is invoked.
//
// Note that this file is to be the only file that uses COIN_EMBEDDED.
d46 20
a65 1
// Main implementation of class CoinMgr.
a69 1
#include <OsiClpSolverInterface.hpp>
a71 1
#include <CbcModel.hpp>
a932 33

//------------------------------------------------------------------------------
// Dummy implementation of class CoinMgr.
//------------------------------------------------------------------------------

#if COIN_EMBEDDED == 0

//------------------------------------------------------------------------------

WitCoinMgr::WitCoinMgr (WitOptModel *):

      WitSolverMgr (NULL)
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

WitCoinMgr::~WitCoinMgr ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solve ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

#endif // COIN_EMBEDDED == 0
@


1.35
log
@CPLEX
@
text
@a42 10
// The following code makes 1 the default value of  COIN_EMBEDDED.
//------------------------------------------------------------------------------

#ifndef COIN_EMBEDDED

#define COIN_EMBEDDED 1

#endif

//------------------------------------------------------------------------------
a85 7
bool WitCoinMgr::coinEmbedded ()
   {
   return true;
   }

//------------------------------------------------------------------------------

a934 7
bool WitCoinMgr::coinEmbedded ()
   {
   return false;
   }

//------------------------------------------------------------------------------

@


1.34
log
@Preparing for embedded CPLEX.
@
text
@d20 1
a20 1
///  responsibilities of class SolverMgr.
d23 1
a23 1
//   The dummy implementation of class CoinMgr does not invoke.COIN 
@


1.33
log
@Preparing for embedded CPLEX.
@
text
@d71 4
a74 4
#include <coin/OsiClpSolverInterface.hpp>
#include <coin/ClpPresolve.hpp>
#include <coin/ClpFactorization.hpp>
#include <coin/CbcModel.hpp>
@


1.32
log
@Preparing for embedded CPLEX.
@
text
@d25 2
d43 10
d56 1
a56 2
#if COIN_EMBEDDED != 0
#if COIN_EMBEDDED != 1
a63 1
#endif
d96 7
d952 7
@


1.31
log
@Preparing for embedded CPLEX.
@
text
@d933 2
@


1.30
log
@Revising the build procedure.
@
text
@d13 12
a24 1
// Contains the implementation of class CoinMgr.
d56 2
d59 1
a59 1
#if COIN_EMBEDDED
d925 32
a956 1
#endif // COIN_EMBEDDED
@


1.29
log
@Revising the build procedure.
@
text
@d29 17
@


1.28
log
@Revising the build procedure.
@
text
@d29 1
a29 1
#if WIT_EMBEDS_COIN
d895 1
a895 1
#endif // WIT_EMBEDS_COIN
@


1.27
log
@Revising the build procedure.
@
text
@d29 1
a29 1
#ifdef WIT_EMBEDS_COIN
@


1.26
log
@Multi-Obj Mode
@
text
@d29 1
a29 1
#ifdef OPT_IMPLODE
d895 1
a895 1
#endif // OPT_IMPLODE
@


1.25
log
@Removed OptObj classes.
@
text
@d23 1
a515 5
// lockLexObjElemVal (theColIdx)
//
// relTol: the relative tolerance
// objTol: the max of the relative tolerance and the absolute tolerance
//------------------------------------------------------------------------------
d520 2
a521 2
   double relTol;
   double objTol;
d525 1
a525 1
   relTol    = myOptComp ()->multiObjTol () * fabs (optObjVal);
d527 1
a527 1
   objTol    = WitNonClass::max (relTol, myOptComp ()->multiObjTol ());
d529 1
a529 1
   myOsiSI ()->setColBounds (theColIdx, optObjVal - objTol, DBL_MAX);
@


1.24
log
@Multi-Obj Mode
@
text
@d342 1
a342 1
      objVec  [theColIdx] = theOptVar->mainObjCoeffVal ();
@


1.23
log
@Multi-Obj Mode
@
text
@d405 1
a405 1
   solveLexCompMip (theOptVar, ongoingOsiSI, true);
d411 1
a411 1
      solveLexCompMip (theOptVar, ongoingOsiSI, false);
d419 1
a419 1
void WitCoinMgr::solveLexCompMip (
d422 1
a422 1
      bool                 firstLexComp)
d427 1
a427 1
   myMsgFac () ("optLexObjCompMsg", theOptVar->lexObjCompName ());
d435 1
a435 1
   checkLexLpSolnStatus (theOptVar, firstLexComp);
d439 1
a439 1
   checkLexMipSolnStatus (theOptVar, firstLexComp);
d467 1
a467 1
   bool                     firstLexComp;
d478 1
a478 1
   firstLexComp = true;
d484 1
a484 1
      myMsgFac () ("optLexObjCompMsg", theOptVar->lexObjCompName ());
d490 1
a490 1
      if (firstLexComp)
d497 1
a497 1
      checkLexLpSolnStatus (theOptVar, firstLexComp);
d499 1
a499 1
      lockLexObjCompVal (theColIdx);
d507 1
a507 1
            myMsgFac () ("lexObjCompCpuTimeMsg",
d510 1
a510 1
      firstLexComp = false;
d515 1
a515 1
// lockLexObjCompVal (theColIdx)
d521 1
a521 1
void WitCoinMgr::lockLexObjCompVal (int theColIdx)
d723 3
a725 1
void WitCoinMgr::checkLexLpSolnStatus (WitOptVar * theOptVar, bool firstLexComp)
d732 1
a732 1
   if (firstLexComp)
d752 1
a752 1
      bool        firstLexComp)
d759 1
a759 1
   if (firstLexComp)
@


1.22
log
@Multi-Obj Mode
@
text
@d427 1
a427 1
   myMsgFac () ("maxLexObjCompMsg", theOptVar->lexObjCompName ());
d484 1
a484 1
      myMsgFac () ("maxLexObjCompMsg", theOptVar->lexObjCompName ());
@


1.21
log
@Revised MPS file writing:
   Maximization
   "extra accuracy"
   One matrix element per line
@
text
@a120 2

      checkLpSolnStatus ();
d471 1
a471 1
   double                   theObjValLB;
d476 2
d491 1
a491 3
         {
         solveLpUnacc ();
         }
d493 3
a495 3
         {
         myClpSimplex ()->primal (0);
         }
d499 1
a499 3
      theObjValLB = myOsiSI ()->getColSolution ()[theColIdx];

      myOsiSI ()->setColBounds (theColIdx, theObjValLB, DBL_MAX);
d515 22
d540 1
a540 2
   bool        doDual;
   ClpPresolve thePresolve;
d544 3
a546 1
   doDual = myOptComp ()->crashOptStarter ()->isChosen ();
d548 10
a557 1
   thePresolve.setDoDual (doDual);
d563 1
a563 1
      invokeSimplex (thePresolve.model ());
d576 1
a576 1
      invokeSimplex (myClpSimplex ());
d582 1
a582 1
void WitCoinMgr::invokeSimplex (ClpSimplex * theClpSimplex)
d587 1
a587 1
   if (myOptComp ()->crashOptStarter ()->isChosen ())
@


1.20
log
@Multi-Obj Mode
@
text
@d368 7
a374 1
      myOsiSI ()->writeMps ("opt-prob", "mps");
@


1.19
log
@Multi-Obj Mode
@
text
@d467 1
a467 1
   double                   curObjVal;
d495 1
a495 1
      curObjVal = myOsiSI ()->getColSolution ()[theColIdx];
d497 1
a497 1
      myOsiSI ()->setColBounds (theColIdx, curObjVal, DBL_MAX);
@


1.18
log
@Multi-Obj Mode
@
text
@d439 1
a439 3
   ongoingOsiSI->setColBounds (theColIdx, curObjVal, curObjVal);

// ongoingOsiSI->setColBounds (theColIdx, curObjVal, DBL_MAX);
d497 1
a497 3
      myOsiSI ()->setColBounds (theColIdx, curObjVal, curObjVal);

//    myOsiSI ()->setColBounds (theColIdx, curObjVal, DBL_MAX);
@


1.17
log
@Switched to using myCbcModel ()->initialSolve () in solveMip ().
@
text
@d23 1
d441 2
d471 3
d487 1
d489 1
d491 1
d493 1
d501 2
d507 5
@


1.16
log
@Multi-Obj Mode
@
text
@d377 1
a377 1
   solveLpUnacc ();
@


1.15
log
@Multi-Obj Mode
@
text
@a395 2
   solveFirstLexCompMip (ongoingOsiSI);

d400 1
a400 1
   stronglyAssert (theOptVar != NULL);
d404 3
a406 1
      solveNonFirstLexCompMip (theOptVar, ongoingOsiSI);
d414 4
a417 1
void WitCoinMgr::solveFirstLexCompMip (OsiSolverInterface * ongoingOsiSI)
d419 2
a420 5
   WitOptVar * theOptVar;
   int         theColIdx;
   double      curObjVal;

   theOptVar = myOptModel ()->myLexOptVarSeq ()[0];
d430 1
a430 1
   checkLexLpSolnStatus (theOptVar, true);
d434 1
a434 1
   checkLexMipSolnStatus (theOptVar, true);
d445 1
a445 3
void WitCoinMgr::solveNonFirstLexCompMip (
      WitOptVar *          theOptVar,
      OsiSolverInterface * ongoingOsiSI)
a447 4
   int                  theColIdx;
   double               curObjVal;

   myMsgFac () ("maxLexObjCompMsg", theOptVar->lexObjCompName ());
a455 18

   theColIdx   = theOptVar->index ();

   myOsiSI ()->setObjCoeff (theColIdx, 1.0);

   myCbcModel ()->initialSolve ();

   checkLexLpSolnStatus (theOptVar, false);

   myCbcModel ()->branchAndBound ();

   checkLexMipSolnStatus (theOptVar, false);

   curObjVal = myOsiSI ()->getColSolution ()[theColIdx];

   ongoingOsiSI->setColBounds (theColIdx, curObjVal, curObjVal);

   myMsgFac () ("optSolnFoundMsg");
@


1.14
log
@Multi-Obj Mode
@
text
@d390 1
a390 2
   OsiSolverInterface *     unsolvedOsiSI;
   bool                     firstLexElem;
a392 2
   int                      theColIdx;
   double                   curObjVal;
d394 1
a394 1
   unsolvedOsiSI = myOsiSI ()->clone ();
d396 1
a396 1
   firstLexElem  = true;
d400 4
d406 2
a407 1
      myMsgFac () ("maxLexObjElemMsg", theOptVar->lexObjElemName ());
d409 2
a410 2
      if (not firstLexElem)
         replaceCbcModel (unsolvedOsiSI);
d412 9
a420 1
      theColIdx = theOptVar->index ();
d422 1
a422 1
      myOsiSI ()->setObjCoeff (theColIdx, 1.0);
d424 1
a424 1
      myCbcModel ()->initialSolve ();
d426 1
a426 1
      checkLexLpSolnStatus (theOptVar, firstLexElem);
d428 1
a428 1
      myCbcModel ()->branchAndBound ();
d430 1
a430 1
      checkLexMipSolnStatus (theOptVar, firstLexElem);
d432 1
a432 1
      curObjVal = myOsiSI ()->getColSolution ()[theColIdx];
d434 1
a434 1
      unsolvedOsiSI->setColBounds (theColIdx, curObjVal, curObjVal);
d436 1
a436 1
      myMsgFac () ("optSolnFoundMsg");
d438 1
a438 2
      firstLexElem = false;
      }
d440 1
a440 1
   delete unsolvedOsiSI;
d445 3
a447 1
void WitCoinMgr::replaceCbcModel (OsiSolverInterface * theOsiSI)
d450 4
d459 1
a459 1
   myCbcModel_ = new CbcModel (* theOsiSI);
d462 18
d486 1
a486 1
   bool                     firstLexElem;
d492 1
a492 1
   firstLexElem = true;
d498 1
a498 1
      myMsgFac () ("maxLexObjElemMsg", theOptVar->lexObjElemName ());
d504 1
a504 1
      if (firstLexElem)
d509 1
a509 1
      checkLexLpSolnStatus (theOptVar, firstLexElem);
d519 1
a519 1
      firstLexElem = false;
d700 1
a700 1
void WitCoinMgr::checkLexLpSolnStatus (WitOptVar * theOptVar, bool firstLexElem)
d707 1
a707 1
   if (firstLexElem)
d727 1
a727 1
      bool        firstLexElem)
d734 1
a734 1
   if (firstLexElem)
@


1.13
log
@Multi-Obj Mode
@
text
@d414 1
a414 1
      solveLpUnacc ();
@


1.12
log
@Multi-Obj mode
@
text
@d390 1
a390 1
   OsiSolverInterface *     mainOsiSI;
d397 1
a397 1
   mainOsiSI    = myOsiSI ()->clone ();
d399 1
a399 1
   firstLexElem = true;
d407 3
d412 1
a412 3
      mainOsiSI->setObjCoeff (theColIdx, 1.0);

      replaceCbcModel (mainOsiSI);
d424 1
a424 3
      mainOsiSI->setColBounds (theColIdx, curObjVal, curObjVal);

      mainOsiSI->setObjCoeff (theColIdx, 0.0);
d431 1
a431 1
   delete mainOsiSI;
@


1.11
log
@Multi-obj mode
@
text
@d101 5
a105 1
   if (multiObjMode ())
d111 1
a111 1
      solveMIP ();
d373 1
a373 1
void WitCoinMgr::solveMIP ()
d388 64
d693 23
@


1.10
log
@Multi-obj mode
@
text
@d386 1
d392 2
d404 4
a407 1
      solveLpUnacc ();
d409 1
a409 1
      checkLexLpSolnStatus (theOptVar);
d418 2
d600 1
a600 1
void WitCoinMgr::checkLexLpSolnStatus (WitOptVar * theOptVar)
d607 1
a607 2
   if (theOptVar == myOptModel ()->myLexOptVarSeq ()[0])
      {
a609 1
      }
@


1.9
log
@Multi-obj mode
@
text
@a390 2
   passInitSoln ();

@


1.8
log
@Multi-objective mode.
@
text
@d116 2
d375 2
d384 35
a448 37

   checkLpSolnStatus ();
   }

//------------------------------------------------------------------------------

void WitCoinMgr::solveLexLp ()
   {
   WitPtrVecItr <WitOptVar> theOptVarItr;
   WitOptVar *              theOptVar;
   int                      theColIdx;
   double                   curObjVal;

   passInitSoln ();

   myOptModel ()->myLexOptVarSeq ().attachItr (theOptVarItr);

   while (theOptVarItr.advance (theOptVar))
      {
      myMsgFac () ("maxLexObjElemMsg", theOptVar->lexObjElemName ());

      theColIdx = theOptVar->index ();

      myOsiSI ()->setObjCoeff (theColIdx, 1.0);

      invokeSimplex (myClpSimplex ());

      checkLexLpSolnStatus (theOptVar);

      curObjVal = myOsiSI ()->getColSolution ()[theColIdx];

      myOsiSI ()->setColBounds (theColIdx, curObjVal, curObjVal);

      myOsiSI ()->setObjCoeff (theColIdx, 0.0);

      myMsgFac () ("optSolnFoundMsg");
      }
@


1.7
log
@Multi-objective mode
@
text
@d360 1
@


1.6
log
@Multi-objective mode
@
text
@d433 1
a433 1
      
a600 1
         {
a601 1
         }
d605 1
a605 1
      myOptModel ()->reportUnbounded ();
@


1.5
log
@Multi-objective mode
@
text
@d436 1
a436 1
      checkLpSolnStatus ();
a553 2
   stronglyAssert (not multiObjMode ());

d591 29
@


1.4
log
@Multi-objective mode
@
text
@d549 2
d562 5
a566 10
   myMsgFac () ("clpOptimalNotFoundSmsg");

   if (myOsiSI ()->isProvenPrimalInfeasible ())
      myMsgFac () ("primalInfeasFmsg");

   if (myOsiSI ()->isProvenDualInfeasible ())
      myMsgFac () ("dualInfeasFmsg");

   if (myOsiSI ()->isAbandoned ())
      myMsgFac () ("abandonedFmsg");
d568 1
a568 1
   myMsgFac () ("unknownNonOptReasonFmsg");
d575 2
d583 4
a586 7
   myMsgFac () ("clpOptimalNotFoundSmsg");

   if (myCbcModel ()->isProvenInfeasible ())
      myMsgFac () ("primalInfeasFmsg");

   if (myCbcModel ()->isAbandoned ())
      myMsgFac () ("abandonedFmsg");
d588 1
a588 1
   myMsgFac () ("unknownNonOptReasonFmsg");
@


1.3
log
@Multi-objective mode
@
text
@d118 2
a119 1
   myMsgFac () ("optSolnFoundMsg");
d428 2
a437 2
      myOsiSI ()->setObjCoeff (theColIdx, 0.0);

d441 4
@


1.2
log
@Multi-objective mode
@
text
@d81 1
d83 1
d101 6
a106 1
   if (mipMode ())
d108 1
a108 1

d110 1
d112 1
a112 1

d114 3
a116 1
      solveLpUnAcc ();
d123 1
d125 1
d241 1
a242 2
   int                conIdx;
   int                bndIdx;
d251 1
a251 1
   bndIdx = 0;
d255 1
a255 1
      conIdx = theOptCon->index ();
d257 1
a257 1
      witAssert (bndIdx == conIdx * 2);
d259 3
a261 6
      indexVec[conIdx]     = conIdx;

      boundVec[bndIdx]     = theOptCon->bounds ().lower ();
      boundVec[bndIdx + 1] = theOptCon->bounds ().upper ();

      bndIdx += 2;
d279 1
a280 2
   int                varIdx;
   int                bndIdx;
d289 1
a289 1
   bndIdx = 0;
d293 1
a293 3
      varIdx = theOptVar->index ();

      witAssert (bndIdx == varIdx * 2);
d295 1
a295 1
      indexVec[varIdx]     = varIdx;
d297 3
a299 4
      boundVec[bndIdx]     = theOptVar->bounds ().lower ();
      boundVec[bndIdx + 1] = theOptVar->bounds ().upper ();

      bndIdx += 2;
d318 1
a318 1
   int                theIdx;
d327 2
d331 3
a333 1
      theIdx           = theOptVar->index ();
d335 2
a336 1
      indexVec[theIdx] = theIdx;
d338 4
a341 1
      objVec  [theIdx] = theOptVar->mainObjCoeffVal ();
d369 1
a369 1
   solveLpUnAcc ();
d378 1
a378 1
void WitCoinMgr::solveLpUnAcc ()
d380 1
d385 3
a387 2
   if (not myOptComp ()->crashOptStarter ()->isChosen ())
      thePresolve.setDoDual (false);
d414 31
d547 2
d596 1
d603 5
a607 1
      theVar->setPrimalValue (primalSoln[theVar->index ()]);
d618 1
d625 5
a629 1
      theCon->setDualValue (dualSoln[theCon->index ()]);
@


1.1
log
@Multi-objective mode
@
text
@d44 7
d84 1
a84 1
      myMsgFac () ("solveLpMipMsg",
d87 3
@


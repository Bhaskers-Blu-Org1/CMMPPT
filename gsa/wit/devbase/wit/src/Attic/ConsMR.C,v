head	1.51;
access;
symbols
	EndRw-branch:1.50.0.4
	Root-of-EndRw:1.50
	rwToStl:1.50.0.2
	latest_sce_3_10_20010924:1.27.0.2
	sce_3_10_20010924:1.27
	latest_sce_3_00_20010601:1.7.0.2
	sce_3_00_20010601:1.7;
locks; strict;
comment	@ * @;


1.51
date	2003.03.03.23.26.40;	author rjw;	state dead;
branches;
next	1.50;

1.50
date	2002.09.26.19.05.25;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.11.18.53.06;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.25.22.47.30;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.02.21.53.02;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.02.19.20.56;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.24.23.00.03;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.21.19.10.25;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.16.23.32.05;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.04.22.14.32.05;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2002.04.18.14.02.29;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.04.15.21.21.34;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.04.12.21.01.58;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.04.11.15.36.27;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.29.23.47.07;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.22.21.23.20;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.20.22.51.16;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.15.23.17.28;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.15.05.46;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.13.19.27.18;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.07.23.24.27;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.10.22.06.52;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.19.16.17.09;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.17.18.56.27;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.30.20.29.22;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.28.20.30.26;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.24.22.03.19;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.23.21.13.52;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.22.20.41.48;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.17.22.00.09;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.12.19.58.24;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.12.17.57.00;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.06.23.36.00;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.27.21.45.10;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.19.14.42.51;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.18.18.42.22;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.15.20.53.35;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.14.17.41.53;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.13.20.30.23;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.11.19.29.09;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.08.22.34.47;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.08.18.00.27;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.01.19.23.32;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.29.22.11.25;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.25.22.59.12;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.25.14.53.23;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.17.15.11.13;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.10.22.31.11;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.30.21.29.40;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.26.21.25.44;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Removed all empty files from WIT (64 of them).
@
text
@@


1.50
log
@Began implementation of multi-level lot sizes.
@
text
@@


1.49
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a0 413
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "ConsMR.C"
//
// Contains the implementation of the following classes:
//
//    CmrMgr
//    MrMgr     <Cmr> [non-param]
//    MrSelSite <Cmr> [non-param]
//    MrCand    <Cmr> [non-param]
//    MrPt      <Cmr> [non-param]
//------------------------------------------------------------------------------

#include <CmrMgr.h>
#include <MultiRoute_TI.h>
#include <Selector.h>
#include <Opn.h>
#include <SubEntry.h>
#include <PtrMapI.h>

//------------------------------------------------------------------------------
// Implementation of class CmrMgr.
//------------------------------------------------------------------------------

WitCmrMgr::WitCmrMgr (WitSelector * theSelector):
      WitProbAssoc (theSelector),

      myMrMgr_     (NULL)
   {
   myMrMgr_ = new WitMrMgr <Cmr> (theSelector);
   }

//------------------------------------------------------------------------------

WitCmrMgr::~WitCmrMgr ()
   {
   delete myMrMgr_;
   }

//------------------------------------------------------------------------------

WitConsEntry * WitCmrMgr::selConsEntry (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer)
   {
   return myMrMgr_->selCandComp (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::modifyRouting (WitConsEntPerStack & theConsEntPers)
   {
   myMrMgr_->modifyRouting (theConsEntPers);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::findExpConsEnts (
      WitBomEntry *     theBomEnt, 
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   myMrMgr_->findCandComps (theBomEnt, execPer, theConsEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   return myMrMgr_->selIsSplit (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::startSplitExp (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer,
      double        expVol)
   {
   myMrMgr_->startSplitExp (theBomEnt, execPer, expVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::findNextSplit (
      WitConsEntry * & theConsEnt, 
      double &         splitExpVol)
   {
   return myMrMgr_->findNextSplit (theConsEnt, splitExpVol);
   }
 
//------------------------------------------------------------------------------

void WitCmrMgr::getCandConsEnts (
      WitBomEntry *     theBomEnt,
      WitConsEntStack & theConsEnts)
   {
   myMrMgr_->getCandComps (theBomEnt, theConsEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::valid (WitConsEntry * theConsEnt, WitPeriod execPer)
   {
   return myMrMgr_->valid (theConsEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::recExpConsEntSS (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer, 
      double         deltaExecVol)
   {
   }

//------------------------------------------------------------------------------

void WitCmrMgr::recExpBomEntSS (
      WitBomEntry * theBomsEnt, 
      WitPeriod     execPer, 
      double        deltaExecVol)
   {
   myMrMgr_->recordFlowSS (theBomsEnt, execPer, deltaExecVol);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::printHasAlt ()
   {
   WitBomEntry * theBomEnt;

   fprintf (msgFile (),
      "\n"
      "Consumption Multi-Route Selection Points with Alternative(s):\n\n");

   forEachBomEntry (theBomEnt, myProblem ())
      myMrMgr_->myMrSelSiteFor (theBomEnt)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

WitSelMgr * WitCmrMgr::mySelMgr ()
   {
   return myMrMgr_;
   }

//------------------------------------------------------------------------------

WitSelPt * WitCmrMgr::mySelPt (WitBomEntry * theBomEnt, WitPeriod thePer)
   {
   return myMrMgr_->myMrPt (theBomEnt, thePer);

   return NULL;
   }

//------------------------------------------------------------------------------

void WitCmrMgr::select (WitConsEntry * theConsEnt, WitPeriod execPer)
   {
   WitMrPt <Cmr> * theCmrPt;

   theCmrPt = myMrMgr_->myMrPt (theConsEnt->myBomEnt (), execPer);

   theCmrPt->select (theConsEnt);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrMgr <Cmr>.
//------------------------------------------------------------------------------

WitMrMgr <Cmr>::~WitMrMgr ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      delete myMrSelSiteFor_ (theBomEnt);
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrMgr <Cmr>::mySelPt (
      WitBopEntry *,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod)
   {
   return myMrPt (theConsEnt->myBomEnt (), execPer);
   }

//------------------------------------------------------------------------------

WitBoolean WitMrMgr <Cmr>::validForNetting ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitMrMgr <Cmr>::validForExecBounds ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

const char * WitMrMgr <Cmr>::selCaseName ()
   {
   return "Consumption Multi-Route";
   }

//------------------------------------------------------------------------------

void WitMrMgr <Cmr>::buildMrSelSites ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      myMrSelSiteFor_ (theBomEnt) = new WitMrSelSite <Cmr> (theBomEnt, this);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrSelSite <Cmr>.
//------------------------------------------------------------------------------

WitConsEntry * WitMrSelSite <Cmr>::defaultCandComp (WitPeriod execPer)
   {
   return
      theBomEntFor (this)->inEffect (execPer)?
         theBomEntFor (this):
         NULL;
   }

//------------------------------------------------------------------------------

void WitMrSelSite <Cmr>::buildMrCands ()
   {
   WitSubEntry * theSub;

   myMrCands_.push (new WitMrCand <Cmr> (theBomEntFor (this), this));

   forEachEl (theSub, theBomEntFor (this)->mySubEntries ())
      {
      if (theSub->myPart ()->producingBopEntries ().isEmpty ())
         if (theSub->netAllowed ())
            if (! theBomEntFor (this)->singleSource ())
               continue;

      if (! theSub->expAllowed ())
         continue;

      myMrCands_.push (new WitMrCand <Cmr> (theSub, this));
      }

   myMrCands_.reverse ();

   multiChoice_ = (myMrCands_.nElements () > 1);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrCand <Cmr>.
//------------------------------------------------------------------------------

void WitMrCand <Cmr>::prtID ()
   {
   WitSubEntry * theSub;

   theConsEntFor (this)->getSubEntry (theSub);

   if (theSub != NULL)
      fprintf (msgFile (), "   Sub #:       %d\n", theSub->localIndex ());
   else
      fprintf (msgFile (), "   Self\n");
                  
   fprintf    (msgFile (), "   Part:        %s\n",
      theConsEntFor (this)->myPartName ().myCstring ());
   }

//------------------------------------------------------------------------------

WitMrCand <Pmr> * WitMrCand <Cmr>::myPmrCand ()
   {
   stronglyAssert (witFALSE);

   return NULL;
   }

//------------------------------------------------------------------------------

WitMrCand <Cmr> * WitMrCand <Cmr>::myCmrCand ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitBoolean WitMrCand <Cmr>::isEligible (WitPeriod execPer)
   {
   return theConsEntFor (this)->inEffect (execPer);
   }

//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrPt <Cmr>.
//------------------------------------------------------------------------------

void WitMrPt <Cmr>::printID ()
   {
   WitBomEntry * theBomEnt;

   theBomEnt = theBomEntFor (myMrSelSite_);

   fprintf (msgFile (),
      "   BomEntry %s, #%d, Period %d\n", 
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex (),
      myPer_);
   }

//------------------------------------------------------------------------------

void WitMrPt <Cmr>::printSelection ()
   {
   WitSubEntry * theSub;

   fprintf (msgFile (), "\n");

   printID ();

   fprintf (msgFile (), "   Selected ConsEntry: ");

   if (selMrCand () == NULL)
      fprintf (msgFile (), "None\n");
   else 
      {
      theConsEntFor (selMrCand ())->getSubEntry (theSub);

      if (theSub != NULL)
         fprintf (msgFile (), "SubEntry #%d\n", theSub->localIndex ());
      else
         fprintf (msgFile (), "The BomEntry Itself\n");
      }
   }

//------------------------------------------------------------------------------

void WitMrPt <Cmr>::prtID ()
   {
   WitBomEntry * theBomEnt;

   theBomEnt = theBomEntFor (myMrSelSite_);

   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Part:        %s\n"
      "   Exec Per:    %d\n",
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex (),
      theBomEnt->myPartName ().myCstring (),
      myPer_);
   }

//------------------------------------------------------------------------------

void WitMrPt <Cmr>::getSortData (WitPart * & thePart, WitPeriod & thePer)
   {
   int            minIdx;
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;

   theOpn  = theBomEntFor (myMrSelSite_)->myOperation ();

   minIdx  = theOpn->myCompMgr ()->nParts ();

   thePart = NULL;

   forEachEl (theBopEnt, theOpn->bop ())
      if (theBopEnt->expAllowed ())
         if (theBopEnt->myPart ()->sortedPartIndex () < minIdx)
            {
            thePart = theBopEnt->myPart ();

            minIdx  = thePart->sortedPartIndex ();
            }

   witAssert (thePart != NULL);

   thePer = myPer_;
   }

//------------------------------------------------------------------------------

WitPart * WitMrPt <Cmr>::myPmrPart ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitBomEntry * WitMrPt <Cmr>::myCmrBomEnt ()
   {
   return theBomEntFor (myMrSelSite_);
   }
@


1.48
log
@Continued implementation of single-source.
@
text
@d27 1
@


1.47
log
@Continued implementation of Single-Source.
@
text
@d255 2
a256 1
            continue;
@


1.46
log
@Continued implementation of Single-Source.
@
text
@d101 16
a174 37
   }

//------------------------------------------------------------------------------

void WitCmrMgr::getCandConsEnts (
      WitBomEntry *     theBomEnt,
      WitConsEntStack & theConsEnts)
   {
   WitObjStItr <WitMrCand <Cmr> > theItr;
   WitMrCand <Cmr> *              theCmrCand;

   theConsEnts.clear ();

   theItr.attachTo (myMrMgr_->myMrSelSiteFor (theBomEnt)->myMrCands ());

   while (theItr.advance (theCmrCand))
      theConsEnts.push (theConsEntFor (theCmrCand));

   theConsEnts.reverse ();
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::valid (WitConsEntry * theConsEnt, WitPeriod execPer)
   {
   WitMrSelSite <Cmr> * theCmrSelSite;
   WitMrCand    <Cmr> * theCmrCand;

   theCmrSelSite = myMrMgr_->myMrSelSiteFor (theConsEnt->myBomEnt ());

   theCmrCand    = theCmrSelSite->myMrCandFor (theConsEnt);

   if (theCmrCand->isEligible (execPer))
      if (! theCmrCand->prevSel (execPer))
         return witTRUE;

   return witFALSE;
@


1.45
log
@Continued implementation of single-source.
@
text
@d151 48
d425 7
@


1.44
log
@Continued implementation of single-source.
@
text
@d145 1
a145 3
   WitBoolean resFound;

   return myMrMgr_->mySelPt (theBomEnt, thePer, resFound);
d168 1
a168 2
      WitPeriod,
      WitBoolean &   resFound)
d170 1
a170 1
   return mySelPt (theConsEnt->myBomEnt (), execPer, resFound);
d374 1
a374 1
WitBoolean WitMrPt <Cmr>::sglSrcMode ()
d376 1
a376 3
   stronglyAssert (witFALSE);

   return witFALSE;
a377 1

@


1.43
log
@Continued implementation of single source.
@
text
@d375 9
@


1.42
log
@Continued implementation of object iteration.
@
text
@d225 1
a225 1
   myMrCands_.push (new WitMrCand <Cmr> (theBomEntFor (this)));
d236 1
a236 1
      myMrCands_.push (new WitMrCand <Cmr> (theSub));
@


1.41
log
@Began implementation of object iteration.
@
text
@d250 1
a250 1
   WitConsEntry * theConsEnt;
d252 1
a252 1
   theConsEnt = theConsEntFor (this);
d254 2
a255 2
   if (theConsEnt->isaSubEntry ())
      fprintf (msgFile (), "   Sub #:       %d\n", theConsEnt->localIndex ());
d260 1
a260 1
      theConsEnt->myPartName ().myCstring ());
d307 2
d317 9
a325 8

   else if (theConsEntFor (selMrCand ())->isaSubEntry ())
      fprintf (msgFile (), 
         "SubEntry #%d\n", 
         theConsEntFor (selMrCand ())->localIndex ());

   else
      fprintf (msgFile (), "The BomEntry Itself\n");
@


1.40
log
@Continued implementation of sel-split for pen-exec.
@
text
@d25 2
@


1.39
log
@Continued implementation of sel-split for pen-exec.
@
text
@d344 1
a344 4
void WitMrPt <Cmr>::getSortData (
      WitPart * & thePart,
      int &       caseIdx,
      WitPeriod & thePer)
d367 1
a367 2
   caseIdx = 0;
   thePer  = myPer_;
@


1.38
log
@Continued implementation of sel-split for pen-exec.
@
text
@d24 1
d113 1
a113 1
   myMrMgr_->recordFlow (theBomsEnt, execPer, deltaExecVol);
a339 28
   }

//------------------------------------------------------------------------------

WitPart * WitMrPt <Cmr>::myFillPart ()
   {
   WitOperation * theOpn;
   WitBopEntry *  theBopEnt;
   WitPart *      maxPart;
   int            maxIdx;

   maxPart  = NULL;
   maxIdx = -1;

   theOpn = theBomEntFor (myMrSelSite_)->myOperation ();

   forEachEl (theBopEnt, theOpn->bop ())
      if (theBopEnt->expAllowed ())
         if (theBopEnt->myPart ()->sortedPartIndex () > maxIdx)
            {
            maxPart = theBopEnt->myPart ();

            maxIdx  = maxPart->sortedPartIndex ();
            }

   witAssert (maxPart != NULL);

   return maxPart;
@


1.37
log
@Continued implementation of sel-split for pen-exec.
@
text
@d371 4
a374 1
WitPart * WitMrPt <Cmr>::mySortPart ()
a376 1
   WitPart *      minPart;
d382 1
a382 1
   minIdx = theOpn->myCompMgr ()->nParts ();
d384 1
a384 1
   minPart = NULL;
d390 1
a390 1
            minPart = theBopEnt->myPart ();
d392 1
a392 1
            minIdx  = minPart->sortedPartIndex ();
d395 1
a395 1
   witAssert (minPart != NULL);
d397 2
a398 1
   return minPart;
a400 6
//------------------------------------------------------------------------------

int WitMrPt <Cmr>::caseIndex ()
   {
   return 0;
   }
@


1.36
log
@Continued implementation of sel-split for pen-exec.
@
text
@d264 1
a264 1
   myMsgFac () ("internalErrorFmsg", "WitMrCand <Cmr>::myPmrCand");
@


1.35
log
@Continued implementation of sel-split for pen-exec.
@
text
@d175 7
@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@d341 1
a341 1
   int            maxIndex;
d344 1
a344 1
   maxIndex = -1;
d350 1
a350 1
         if (theBopEnt->myPart ()->sortedPartIndex () > maxIndex)
d352 1
a352 1
            maxPart  = theBopEnt->myPart ();
d354 1
a354 1
            maxIndex = maxPart->sortedPartIndex ();
d364 1
a364 1
int WitMrPt <Cmr>::sspeIndex ()
d366 4
a369 3
   WitBomEntry * theBomEnt;
   int           maxIdx;
   WitSubEntry * theSub;
d371 1
a371 1
   theBomEnt = theBomEntFor (myMrSelSite_);
d373 1
a373 1
   maxIdx    = theBomEnt->myPart ()->sortedPartIndex ();
d375 1
a375 3
   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->expAllowed ())
         setToMax (maxIdx, theSub->myPart ()->sortedPartIndex ());
d377 19
a395 1
   return maxIdx * 10;
@


1.32
log
@Continued implementation of sel-split for pen-exec.
@
text
@d378 1
a378 1
   return maxIdx;
@


1.31
log
@Continued implementation of sel-split for pen-exec.
@
text
@a97 10
void WitCmrMgr::setPrevSel (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer,
      WitBoolean     theVal)
   {
   myMrMgr_->setPrevSel (theConsEnt, execPer, theVal);
   }

//------------------------------------------------------------------------------

a149 20

WitBoolean WitCmrMgr::getCmrCoords (
      WitSelPt *      theSelPt, 
      WitBomEntry * & theBomEnt, 
      WitPeriod &     execPer)
   {
   WitMrPt <Cmr> * theCmrPt;

   theCmrPt = theSelPt->myCmrPtIfAny ();

   if (theCmrPt == NULL)
      return witFALSE;

   theBomEnt = theCmrPt->myMrSelSite ()->mySelComp ();
   execPer   = theCmrPt->myPer ();

   return witTRUE;
   }

//------------------------------------------------------------------------------
a378 14
   }

//------------------------------------------------------------------------------

WitMrPt <Pmr> * WitMrPt <Cmr>::myPmrPtIfAny ()
   {
   return NULL;
   }

//------------------------------------------------------------------------------

WitMrPt <Cmr> * WitMrPt <Cmr>::myCmrPtIfAny ()
   {
   return this;
@


1.30
log
@Continued implementation of sel-split fpr pen-exec.
@
text
@d98 10
d149 31
d285 1
a285 1
WitMrCand <Pmr> * WitMrCand <Cmr>::myMrCandPmr ()
d287 1
a287 1
   myMsgFac () ("internalErrorFmsg", "WitMrCand <Cmr>::myMrCandPmr");
d294 1
a294 1
WitMrCand <Cmr> * WitMrCand <Cmr>::myMrCandCmr ()
d394 20
a413 1
WitMrPt <Pmr> * WitMrPt <Cmr>::myMrPtPmrIfAny ()
d418 6
@


1.29
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d350 8
@


1.28
log
@Initial implementation of selection splitting for multi-route.
@
text
@d159 1
a159 1
   return mySelPt (theConsEnt, execPer, resFound);
@


1.27
log
@Continued implmentation of selective stock reallocation.
@
text
@d107 10
@


1.26
log
@Refactoring for constrained stock reallocation.
@
text
@d234 1
a234 1
WitBoolean WitMrCand <Cmr>::isaPmrCand ()
d236 3
a238 1
   return witFALSE;
d243 1
a243 1
WitBoolean WitMrCand <Cmr>::isaCmrCand ()
d245 1
a245 1
   return witTRUE;
@


1.25
log
@Refactoring for constrained stock reallocation.
@
text
@d19 1
a19 1
//    MrSelPt   <Cmr> [non-param]
d254 1
a254 1
// Non-parametric implementation of template class MrSelPt <Cmr>.
d257 1
a257 1
void WitMrSelPt <Cmr>::printID ()
d272 1
a272 1
void WitMrSelPt <Cmr>::printSelection ()
d294 1
a294 1
void WitMrSelPt <Cmr>::prtID ()
d313 1
a313 1
WitPart * WitMrSelPt <Cmr>::myFillPart ()
@


1.24
log
@Refactoring for constrained stock reallocation.
@
text
@d30 3
a32 1
      WitMrMgr <Cmr> (theSelector)
d34 1
d41 1
d50 1
a50 1
   return selCandComp (theBomEnt, execPer);
d57 1
a57 1
   WitMrMgr <Cmr>::modifyRouting (theConsEntPers);
d67 1
a67 1
   findCandComps (theBomEnt, execPer, theConsEnts);
d74 1
a74 1
   return WitMrMgr <Cmr>::selIsSplit (theBomEnt, execPer);
d84 1
a84 1
   WitMrMgr <Cmr>::startSplitExp (theBomEnt, execPer, expVol);
d93 1
a93 1
   return WitMrMgr <Cmr>::findNextSplit (theConsEnt, splitExpVol);
d116 1
a116 1
      myMrSelSiteFor (theBomEnt)->printHasAlt ();
d119 7
@


1.23
log
@Refactoring for constrained stock reallocation.
@
text
@d30 1
a30 3
      WitMrMgr <Cmr> (theSelector),

      totExecVol_        (myProblem ())
a98 3
   if (selSplit ())
      if (myMrSelSiteFor (theConsEnt->myBomEnt ())->multiChoice ())
         totExecVol_.incCell (theConsEnt, execPer, deltaExecVol);
a114 43
   }

//------------------------------------------------------------------------------

void WitCmrMgr::setUpDerivedSS ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   witAssert (selSplit ());

   totExecVol_.allocate1D ();

   forEachBomEntry (theBomEnt, myProblem ())
      if (myMrSelSiteFor (theBomEnt)->multiChoice ())
         {
         totExecVol_.allocateRow (theBomEnt);

         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->expAllowed ())
               totExecVol_.allocateRow (theSub);
         }
   }

//------------------------------------------------------------------------------

void WitCmrMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExecVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitCmrMgr::adjustSplitBound (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer, 
      double &       splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExecVol_ (theConsEnt, execPer);
@


1.22
log
@Refactoring for constrained stock reallocation.
@
text
@d191 1
a191 1
void WitMrMgr <Cmr>::prtSelCandID (WitTlObj * theTlObj)
d193 2
a194 1
   WitConsEntry * theConsEnt;
d196 1
a196 1
   theConsEnt = (WitConsEntry *) theTlObj;
d198 3
a200 7
   if (theConsEnt == theConsEnt->myBomEnt ())
      fprintf (msgFile (), "   Self\n");
   else
      fprintf (msgFile (), "   Sub #:       %d\n", theConsEnt->localIndex ());
                  
   fprintf    (msgFile (), "   Part:        %s\n",
      theConsEnt->myPartName ().myCstring ());
d220 2
a221 2
      mySelComp_->inEffect (execPer)?
         mySelComp_:
d231 1
a231 1
   myMrCands_.push (new WitMrCand <Cmr> (mySelComp_));
d233 1
a233 1
   forEachEl (theSub, mySelComp_->mySubEntries ())
d254 31
d287 1
a287 1
   return myCandComp_->inEffect (execPer);
d298 1
a298 1
   theBomEnt = myMrSelSite_->mySelComp ();
a310 2
   WitConsEntry * theConsEnt;

d319 6
d326 1
a326 8
      {
      theConsEnt = selMrCand ()->myCandComp ();

      if (theConsEnt->isaSubEntry ())
         fprintf (msgFile (), "SubEntry #%d\n", theConsEnt->localIndex ());
      else
         fprintf (msgFile (), "The BomEntry Itself\n");
      }
d335 1
a335 1
   theBomEnt = myMrSelSite_->mySelComp ();
d360 1
a360 1
   theOpn = myMrSelSite_->mySelComp ()->myOperation ();
@


1.21
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d16 4
a19 4
//    MrMgr     <CmrArgs> [non-param]
//    MrSelSite <CmrArgs> [non-param]
//    MrCand    <CmrArgs> [non-param]
//    MrSelPt   <CmrArgs> [non-param]
d23 1
a23 1
#include <MrMgr_TI.h>
d30 1
a30 1
      WitMrMgr <CmrArgs> (theSelector),
d55 1
a55 1
   WitMrMgr <CmrArgs>::modifyRouting (theConsEntPers);
d72 1
a72 1
   return WitMrMgr <CmrArgs>::selIsSplit (theBomEnt, execPer);
d82 1
a82 1
   WitMrMgr <CmrArgs>::startSplitExp (theBomEnt, execPer, expVol);
d91 1
a91 1
   return WitMrMgr <CmrArgs>::findNextSplit (theConsEnt, splitExpVol);
d166 1
a166 1
// Non-parametric implementation of template class MrMgr <CmrArgs>.
d169 1
a169 1
WitMrMgr <CmrArgs>::~WitMrMgr ()
d179 1
a179 1
WitSelPt * WitMrMgr <CmrArgs>::mySelPt (
d191 1
a191 15
WitBoolean WitMrMgr <CmrArgs>::validForExecBounds ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

const char * WitMrMgr <CmrArgs>::selCaseName ()
   {
   return "Consumption Multi-Route";
   }

//------------------------------------------------------------------------------

void WitMrMgr <CmrArgs>::prtSelCandID (WitTlObj * theTlObj)
d208 1
a208 1
void WitMrMgr <CmrArgs>::buildMrSelSites ()
d213 1
a213 2
      myMrSelSiteFor_ (theBomEnt) = 
         new WitMrSelSite <CmrArgs> (theBomEnt, this);
d217 1
a217 1
// Non-parametric implementation of template class MrSelSite <CmrArgs>.
d220 1
a220 1
WitConsEntry * WitMrSelSite <CmrArgs>::defaultCandComp (WitPeriod execPer)
d230 1
a230 1
void WitMrSelSite <CmrArgs>::buildMrCands ()
d234 1
a234 1
   myMrCands_.push (new WitMrCand <CmrArgs> (mySelComp_));
d245 1
a245 1
      myMrCands_.push (new WitMrCand <CmrArgs> (theSub));
d254 1
a254 1
// Non-parametric implementation of template class MrCand <CmrArgs>.
d257 1
a257 1
WitBoolean WitMrCand <CmrArgs>::isEligible (WitPeriod execPer)
d263 1
a263 1
// Non-parametric implementation of template class MrSelPt <CmrArgs>.
d266 1
a266 1
void WitMrSelPt <CmrArgs>::printID ()
d281 1
a281 1
void WitMrSelPt <CmrArgs>::printSelection ()
d291 1
a291 1
   if (selMrCand_ == NULL)
d295 1
a295 1
      theConsEnt = selMrCand_->myCandComp ();
d306 1
a306 1
void WitMrSelPt <CmrArgs>::prtID ()
d325 1
a325 1
WitPart * WitMrSelPt <CmrArgs>::myFillPart ()
@


1.20
log
@Refactoring.
@
text
@d337 28
@


1.19
log
@Templatized consumption multi-route.
@
text
@d1 336
@


1.18
log
@Replaced Mapping (*, WitTlObjPtr) with PtrMap <*, *>.
@
text
@a0 655
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "ConsMR.C"
//
// Contains the implementation of the following classes:
//
//    CmrMgr.
//    CmrBomEnt.
//    CmrCand.
//    CmrSelPt.
//------------------------------------------------------------------------------

#include <CmrMgr.h>
#include <CmrBom.h>
#include <CmrCand.h>

//------------------------------------------------------------------------------
// Implementation of class CmrMgr.
//------------------------------------------------------------------------------

WitCmrMgr::WitCmrMgr (WitSelector * theSelector):
      WitSelMgr       (theSelector),

      myCmrBomEntFor_ (myProblem ()),
      totExecVol_     (myProblem ())
   {
   WitBomEntry * theBomEnt;

   myMsgFac () ("multiRouteMsg");

   forEachBomEntry (theBomEnt, myProblem ())
      myCmrBomEntFor_ (theBomEnt) = new WitCmrBomEnt (theBomEnt, this);
   }

//------------------------------------------------------------------------------

WitCmrMgr::~WitCmrMgr ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      delete myCmrBomEntFor_ (theBomEnt);
   }

//------------------------------------------------------------------------------

WitConsEntry * WitCmrMgr::selConsEntry (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer)
   {
   return myCmrBomEntFor_ (theBomEnt)->selConsEntry (execPer);
   }

//------------------------------------------------------------------------------

WitSelPt * WitCmrMgr::mySelPt (
      WitBopEntry *,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod,
      WitBoolean &   resFound)
   {
   WitCmrSelPt * theCmrSelPt;

   theCmrSelPt = 
      myCmrBomEntFor_ (theConsEnt->myBomEnt ())->myCmrSelPtWithAlt (execPer);

   resFound = 
      (theCmrSelPt != NULL)?
         theCmrSelPt->hasResAlt ():
         witFALSE;

   return theCmrSelPt;
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::validForExecBounds ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

const char * WitCmrMgr::selCaseName ()
   {
   return "Consumption Multi-Route";
   }

//------------------------------------------------------------------------------

void WitCmrMgr::prtSelCandID (WitTlObj * theTlObj)
   {
   WitConsEntry * theConsEnt;

   theConsEnt = (WitConsEntry *) theTlObj;

   if (theConsEnt == theConsEnt->myBomEnt ())
      fprintf (msgFile (), "   Self\n");
   else
      fprintf (msgFile (), "   Sub #:       %d\n", theConsEnt->localIndex ());
                  
   fprintf    (msgFile (), "   Part:        %s\n",
      theConsEnt->myPartName ().myCstring ());
   }

//------------------------------------------------------------------------------

void WitCmrMgr::printHasAlt ()
   {
   WitBomEntry * theBomEnt;

   fprintf (msgFile (),
      "\n"
      "Consumption Multi-Route Selection Points with Alternative(s):\n\n");

   forEachBomEntry (theBomEnt, myProblem ())
      myCmrBomEntFor_ (theBomEnt)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitCmrMgr::modifyRouting (WitConsEntPerStack & theConsEntPers)
   {
   WitConsEntry * theConsEnt;
   WitPeriod      execPer;
   WitCmrBomEnt * theCmrBomEnt;

   while (theConsEntPers.pop (theConsEnt, execPer))
      {
      theCmrBomEnt = myCmrBomEntFor_ (theConsEnt->myBomEnt ());

      theCmrBomEnt->myCmrSelPt ()[execPer]->select (theConsEnt);
      }
   }

//------------------------------------------------------------------------------

void WitCmrMgr::findExpConsEnts (
      WitBomEntry *     theBomEnt,
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   myCmrBomEntFor_ (theBomEnt)->findExpConsEnts (execPer, theConsEnts);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::selSplitNeeded ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   WitCmrBomEnt * theCmrBomEnt;

   if (! selSplit ())
      return witFALSE;

   theCmrBomEnt = myCmrBomEntFor_ (theBomEnt);

   if (! theCmrBomEnt->multiChoice ())
      return witFALSE;

   return theCmrBomEnt->myCmrSelPt ()[execPer]->isSplit ();
   }

//------------------------------------------------------------------------------

void WitCmrMgr::startSplitExp (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer,
      double        execVolVal)
   {
   WitCmrSelPt * theCmrSelPt;

   witAssert (selIsSplit (theBomEnt, execPer));

   theCmrSelPt = myCmrBomEntFor_ (theBomEnt)->myCmrSelPt ()[execPer];

   startSplitExpAbs (theCmrSelPt, execVolVal);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::adjustSplitBound (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer, 
      double &       splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExecVol_ (theConsEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::recExpConsEntSS (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer, 
      double         deltaExecVol)
   {
   if (selSplit ())
      if (myCmrBomEntFor_ (theConsEnt->myBomEnt ())->multiChoice ())
         totExecVol_.incCell (theConsEnt, execPer, deltaExecVol);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::postCommitSS ()
   {
   witAssert (selSplit ());

   totExecVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitCmrMgr::postSplitCommit ()
   {
   }

//------------------------------------------------------------------------------

void WitCmrMgr::setUpDerivedSS ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   witAssert (selSplit ());

   totExecVol_.allocate1D ();

   forEachBomEntry (theBomEnt, myProblem ())
      if (myCmrBomEntFor_ (theBomEnt)->multiChoice ())
         {
         totExecVol_.allocateRow (theBomEnt);

         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->expAllowed ())
               totExecVol_.allocateRow (theSub);
         }
   }

//------------------------------------------------------------------------------
// Implementation of class CmrBomEnt.
//------------------------------------------------------------------------------

WitCmrBomEnt::WitCmrBomEnt (WitBomEntry * theBomEnt, WitCmrMgr * theCmrMgr):
      WitProbAssoc (theCmrMgr),

      myCmrMgr_    (theCmrMgr),
      myBomEnt_    (theBomEnt),
      myCmrCands_  (myProblem ()),
      multiChoice_ (witFALSE),
      myCmrSelPt_  ()
   {
   if (! myGlobalComp ()->multiRoute ())
      return;

   buildCmrCands ();

   buildCmrSelPts ();
   }

//------------------------------------------------------------------------------

WitCmrBomEnt::~WitCmrBomEnt ()
   {
   WitPeriod    execPer;
   WitCmrCand * theCmrCand;

   if (multiChoice_)
      forEachPeriod (execPer, myProblem ())
         delete myCmrSelPt_[execPer];

   while (myCmrCands_.pop (theCmrCand))
      delete theCmrCand;
   }

//------------------------------------------------------------------------------

void WitCmrBomEnt::printHasAlt ()
   {
   WitPeriod     execPer;
   WitCmrSelPt * theCmrSelPt;

   if (! multiChoice_)
      return;

   forEachPeriod (execPer, myProblem ())
      {
      theCmrSelPt = myCmrSelPt_[execPer];

      if (theCmrSelPt != NULL)
         if (theCmrSelPt->selCmrCand () != NULL)
            theCmrSelPt->printID ();
      }
   }

//------------------------------------------------------------------------------

void WitCmrBomEnt::findExpConsEnts (
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   WitCmrCandItr theCmrCandItr;
   WitCmrCand *  theCmrCand;

   witAssert (myBomEnt_->inEffect (execPer));

   theConsEnts.clear ();

   if (multiChoice ())
      {
      theCmrCandItr.attachTo (myCmrCands_);

      while (theCmrCandItr.advance (theCmrCand))
         if (theCmrCand->isEligible (execPer))
            if (! theCmrCand->prevSel ()[execPer])
               theConsEnts.push (theCmrCand->myConsEnt ());

      theConsEnts.reverse ();
      }

   if (theConsEnts.isEmpty ())
      theConsEnts.push (myBomEnt_);
   }

//------------------------------------------------------------------------------

WitCmrCand * WitCmrBomEnt::myCmrCandFor (WitConsEntry * theConsEnt)
   {
   WitCmrCandItr theCmrCandItr;
   WitCmrCand *  theCmrCand;

   theCmrCandItr.attachTo (myCmrCands_);

   while (theCmrCandItr.advance (theCmrCand))
      if (theCmrCand->myConsEnt () == theConsEnt)
         return theCmrCand;

   myMsgFac () ("internalErrorFmsg", "WitCmrBomEnt::myCmrCand");

   return NULL;
   }

//------------------------------------------------------------------------------

WitConsEntry * WitCmrBomEnt::selConsEntry (WitPeriod execPer)
   {
   WitCmrCand * theCmrCand;

   witAssert (myBomEnt_->inEffect (execPer));

   if (multiChoice_)
      {
      theCmrCand = myCmrSelPt_[execPer]->selCmrCand ();

      if (theCmrCand != NULL)
         return theCmrCand->myConsEnt ();
      }

   return myBomEnt_;
   }

//------------------------------------------------------------------------------

void WitCmrBomEnt::buildCmrSelPts ()
   {
   WitPeriod execPer;

   if (! multiChoice_)
      return;

   myCmrSelPt_.allocate (myProblem ());

   forEachPeriod (execPer, myProblem ())
      if (myBomEnt_->inEffect (execPer))
         myCmrSelPt_[execPer] = new WitCmrSelPt (this, execPer);
   }

//------------------------------------------------------------------------------

WitCmrSelPt * WitCmrBomEnt::multiChoiceCmrSelPtWithAlt (WitPeriod execPer)
   {
   WitCmrSelPt * theCmrSelPt;

   witAssert (multiChoice_);

   theCmrSelPt = myCmrSelPt_[execPer];

   witAssert (theCmrSelPt != NULL);

   return
      (theCmrSelPt->selCmrCand () != NULL)?
         theCmrSelPt:
         NULL;
   }

//------------------------------------------------------------------------------

void WitCmrBomEnt::buildCmrCands ()
   {
   WitSubEntry * theSub;

   myCmrCands_.push (new WitCmrCand (myBomEnt_));

   forEachEl (theSub, myBomEnt_->mySubEntries ())
      {
      if (theSub->myPart ()->producingBopEntries ().isEmpty ())
         if (theSub->netAllowed ())
            continue;

      if (! theSub->expAllowed ())
         continue;

      myCmrCands_.push (new WitCmrCand (theSub));
      }

   myCmrCands_.reverse ();

   multiChoice_ = (myCmrCands_.nElements () > 1);
   }

//------------------------------------------------------------------------------
// Implementation of class CmrCand.
//------------------------------------------------------------------------------

WitCmrCand::WitCmrCand (WitConsEntry * theConsEnt):

      WitSelCand (theConsEnt),

      myConsEnt_ (theConsEnt),
      prevSel_   (myProblem (), witFALSE)
   {
   }

//------------------------------------------------------------------------------

WitCmrCand::~WitCmrCand ()
   {
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrCand::isEligible (WitPeriod execPer)
   {
   return myConsEnt_->inEffect (execPer);
   }

//------------------------------------------------------------------------------

void WitCmrCand::setPrevSel (WitPeriod execPer)
   {
   prevSel_.elemRef (execPer) = witTRUE;
   }

//------------------------------------------------------------------------------
// Implementation of class CmrSelPt.
//------------------------------------------------------------------------------

WitCmrSelPt::WitCmrSelPt (WitCmrBomEnt * theCmrBomEnt, WitPeriod execPer):

      WitSelPt     (),

      myCmrBomEnt_ (theCmrBomEnt),
      myExecPer_   (execPer),
      selCmrCand_  (NULL),
      hasResAlt_   (witFALSE)
   {
   WitCmrCandItr theCmrCandItr;
   WitCmrCand *  theCmrCand;

   witAssert (myCmrBomEnt_->myBomEnt ()->inEffect (myExecPer_));

   selCmrCand_ = myCmrBomEnt_->myCmrCandFor (myCmrBomEnt_->myBomEnt ());

   theCmrCandItr.attachTo (myCmrBomEnt_->myCmrCands ());

   while (theCmrCandItr.advance (theCmrCand))
      if (theCmrCand->isEligible (myExecPer_))
         if (theCmrCand != selCmrCand_)
            {
            hasResAlt_ = witTRUE;

            break;
            }
   }

//------------------------------------------------------------------------------

WitCmrSelPt::~WitCmrSelPt ()
   {
   }

//------------------------------------------------------------------------------

WitTlObj * WitCmrSelPt::selectedObj ()
   {
   WitConsEntry * theConsEnt;

   witAssert (selCmrCand_ != NULL);

   theConsEnt = selCmrCand_->myConsEnt ();

   return (WitTlObj *) theConsEnt;
   }

//------------------------------------------------------------------------------

void WitCmrSelPt::alterSelection ()
   {
   WitCmrCandItr theCmrCandItr;
   WitCmrCand *  theCmrCand;

   witAssert (selCmrCand_ != NULL);

   selCmrCand_->setPrevSel (myExecPer_);

   selCmrCand_ = NULL;
   hasResAlt_  = witFALSE;

   theCmrCandItr.attachTo (myCmrBomEnt_->myCmrCands ());

   while (theCmrCandItr.advance (theCmrCand))
      if (theCmrCand->isEligible (myExecPer_))
         if (! theCmrCand->prevSel ()[myExecPer_])
            if (selCmrCand_ == NULL)
               selCmrCand_ = theCmrCand;
            else
               {
               hasResAlt_ = witTRUE;

               return;
               }
   }

//------------------------------------------------------------------------------

void WitCmrSelPt::printSelection ()
   {
   WitConsEntry * theConsEnt;

   fprintf (msgFile (), "\n");

   printID ();

   fprintf (msgFile (), "   Selected ConsEntry: ");

   if (selCmrCand_ == NULL)
      fprintf (msgFile (), "None\n");
   else
      {
      theConsEnt = selCmrCand_->myConsEnt ();

      if (theConsEnt->isaSubEntry ())
         fprintf (msgFile (), "SubEntry #%d\n", theConsEnt->localIndex ());
      else
         fprintf (msgFile (), "The BomEntry Itself\n");
      }
   }

//------------------------------------------------------------------------------

WitSelMgr * WitCmrSelPt::mySelMgr ()
   {
   return myCmrBomEnt_->myCmrMgr ();
   }

//------------------------------------------------------------------------------

void WitCmrSelPt::prtID ()
   {
   fprintf (msgFile (),
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Part:        %s\n"
      "   Exec Per:    %d\n",
      myCmrBomEnt_->myBomEnt ()->myOperationName ().myCstring (),
      myCmrBomEnt_->myBomEnt ()->localIndex (),
      myCmrBomEnt_->myBomEnt ()->myPartName ().myCstring (),
      myExecPer_);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrSelPt::splittable ()
   {
   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitCmrSelPt::adjustSplitBound (WitTlObj * theTlObj, double & splitBound)
   {
   WitConsEntry * theConsEnt;

   theConsEnt = (WitConsEntry *) theTlObj;

   myCmrBomEnt_->myCmrMgr ()->adjustSplitBound (
      theConsEnt, 
      myExecPer_, 
      splitBound);
   }

//------------------------------------------------------------------------------

void WitCmrSelPt::printID ()
   {
   WitBomEntry * theBomEnt;

   theBomEnt = myCmrBomEnt_->myBomEnt ();

   fprintf (msgFile (),
      "   BomEntry %s, #%d, Period %d\n", 
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex (),
      myExecPer_);
   }

//------------------------------------------------------------------------------

void WitCmrSelPt::select (WitConsEntry * theConsEnt)
   {  
   WitCmrCand * theCmrCand;

   theCmrCand = myCmrBomEnt_->myCmrCandFor (theConsEnt);

   witAssert (theCmrCand != selCmrCand_);

   witAssert (! theCmrCand->prevSel ()[myExecPer_]);

   selCmrCand_ = theCmrCand;
   }

//------------------------------------------------------------------------------

FILE * WitCmrSelPt::msgFile ()
   {
   return myCmrBomEnt_->msgFile ();
   }
@


1.17
log
@Initial implementation of multi-route class templates.
@
text
@d30 1
a30 1
      WitSelMgr      (theSelector),
d32 2
a33 2
      myCmrBomEntTl_ (),
      totExecVol_    (myProblem ())
a38 2
   myCmrBomEntTl_.allocate (myProblem (), NULL);

d40 1
a40 1
      myCmrBomEnt (theBomEnt) = new WitCmrBomEnt (theBomEnt, this);
d50 1
a50 1
      delete myCmrBomEnt (theBomEnt);
d59 1
a59 1
   return myCmrBomEnt (theBomEnt)->selConsEntry (execPer);
d74 1
a74 1
      myCmrBomEnt (theConsEnt->myBomEnt ())->myCmrSelPtWithAlt (execPer);
d126 1
a126 1
      myCmrBomEnt (theBomEnt)->printHasAlt ();
d141 1
a141 1
      theCmrBomEnt = myCmrBomEnt (theConsEnt->myBomEnt ());
d154 1
a154 1
   myCmrBomEnt (theBomEnt)->findExpConsEnts (execPer, theConsEnts);
d173 1
a173 1
   theCmrBomEnt = myCmrBomEnt (theBomEnt);
d192 1
a192 1
   theCmrSelPt = myCmrBomEnt (theBomEnt)->myCmrSelPt ()[execPer];
d217 1
a217 1
      if (myCmrBomEnt (theConsEnt->myBomEnt ())->multiChoice ())
d248 1
a248 1
      if (myCmrBomEnt (theBomEnt)->multiChoice ())
@


1.16
log
@Minor changes.
@
text
@d422 1
a422 1
   myCmrCands_.push (new WitCmrCand (myBomEnt_, this));
d433 1
a433 1
      myCmrCands_.push (new WitCmrCand (theSub, this));
d445 1
a445 1
WitCmrCand::WitCmrCand (WitConsEntry * theConsEnt, WitCmrBomEnt * theCmrBomEnt):
d447 1
a447 1
      WitSelCand   (theCmrBomEnt),
d449 2
a450 3
      myConsEnt_   (theConsEnt),
      myCmrBomEnt_ (theCmrBomEnt),
      prevSel_     (myProblem (), witFALSE)
@


1.15
log
@Replaced use of CandIndex with CmrCand in Consumption Multi-Route subsystem.
@
text
@a420 2
   WitCmrCandItr theCmrCandItr;
   WitCmrCand *  theCmrCand;
a422 1

@


1.14
log
@Removed indexes from production multi-route.
Other refactoring.
@
text
@d139 1
d142 5
a146 1
      myCmrBomEnt (theConsEnt->myBomEnt ())->select (theConsEnt, execPer);
d269 1
a269 1
      myCmrCand_   (),
d276 1
a276 3
   initCandidate ();

   multiChoice_ = (myCmrCand_.length () > 1);
d286 1
a286 1
   WitCandIndex theIdx;
d292 2
a293 3
   if (myCmrCand_.length () > 0)
      for (theIdx = 0; theIdx < myCmrCand_.length (); theIdx ++)
         delete myCmrCand_[theIdx];
d311 1
a311 1
         if (theCmrSelPt->selIndex () >= 0)
a317 14
WitBoolean WitCmrBomEnt::candIsDefault (WitCandIndex theIdx, WitPeriod)
   {
   return (myCmrCand_[theIdx]->myConsEnt () == myBomEnt_);
   }

//------------------------------------------------------------------------------

WitBoolean WitCmrBomEnt::candIsEligible (WitCandIndex theIdx, WitPeriod execPer)
   {
   return myCmrCand_[theIdx]->myConsEnt ()->inEffect (execPer);
   }

//------------------------------------------------------------------------------

d322 2
a323 2
   WitCandIndex  theIdx;
   WitCmrSelPt * theCmrSelPt;
d331 6
a336 1
      theCmrSelPt = myCmrSelPt_[execPer];
d338 1
a338 4
      for (theIdx = myCmrCand_.length () - 1; theIdx >= 0; theIdx --)
         if (candIsEligible (theIdx, execPer))
            if (! theCmrSelPt->prevSel ()[theIdx])
               theConsEnts.push (myCmrCand_[theIdx]->myConsEnt ());
d347 1
a347 1
void WitCmrBomEnt::select (WitConsEntry * theConsEnt, WitPeriod execPer)
d349 2
a350 3
   WitCandIndex nCands;
   WitCandIndex theIdx;
   WitCandIndex theSelIdx;
d352 1
a352 1
   witAssert (myCmrSelPt_[execPer] != NULL);
d354 3
a356 1
   nCands = myCmrCand_.length ();
d358 1
a358 7
   if (DEBUG_MODE)
      theSelIdx = -1;
   
   for (theIdx = 0; theIdx < nCands; theIdx ++)
      if (myCmrCand_[theIdx]->myConsEnt () == theConsEnt)
         {
         theSelIdx = theIdx;
d360 1
a360 6
         break;
         }

   witAssert (theSelIdx >= 0);

   myCmrSelPt_[execPer]->select (theSelIdx);
d367 1
a367 1
   WitCandIndex theIdx;
d373 1
a373 1
      theIdx = myCmrSelPt_[execPer]->selIndex ();
d375 2
a376 2
      if (theIdx >= 0)
         return myCmrCand_[theIdx]->myConsEnt ();
d411 1
a411 1
      (theCmrSelPt->selIndex () >= 0)?
d418 1
a418 1
void WitCmrBomEnt::initCandidate ()
d421 2
a422 2
   int           nCands;
   WitCandIndex  theIdx;
d424 1
a424 1
   WitObjStack (WitSubEntry) theCands (myProblem ());
a425 1
   nCands = 1;
d436 1
a436 3
      nCands ++;

      theCands.push (theSub);
d439 1
a439 7
   myCmrCand_.resize (nCands);

   theIdx = nCands - 1;

   while (theCands.pop (theSub))
      {
      myCmrCand_  [theIdx] = new WitCmrCand (theSub, this, theIdx);
d441 1
a441 4
      theIdx --;
      }

   myCmrCand_[0] = new WitCmrCand (myBomEnt_, this, theIdx);
d448 1
a448 4
WitCmrCand::WitCmrCand (
         WitConsEntry * theConsEnt,
         WitCmrBomEnt * theCmrBomEnt, 
         WitCandIndex   theIdx):
d454 1
a454 1
      myIdx_       (theIdx)
d465 14
d488 2
a489 3
      selIndex_    (-1),
      hasResAlt_   (witFALSE),
      prevSel_     (theCmrBomEnt->myCmrCand ().length (), witFALSE)
d491 2
a492 1
   WitCandIndex theIdx;
d496 3
a498 1
   selectDefault ();
d500 3
a502 3
   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myCmrBomEnt_->candIsEligible (theIdx, myExecPer_))
         if (theIdx != selIndex_)
d522 1
a522 1
   witAssert (selIndex_ >= 0);
d524 1
a524 1
   theConsEnt = myCmrBomEnt_->myCmrCand ()[selIndex_]->myConsEnt ();
d533 2
a534 1
   WitCandIndex theIdx;
d536 1
a536 1
   witAssert (selIndex_ >= 0);
d538 12
a549 9
   prevSel_[selIndex_] = witTRUE;
   selIndex_           = -1;
   hasResAlt_          = witFALSE;

   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myCmrBomEnt_->candIsEligible (theIdx, myExecPer_))
         if (! prevSel_[theIdx])
            if (selIndex_ == -1)
               selIndex_ = theIdx;
d570 1
a570 1
   if (selIndex_ == -1)
d574 1
a574 1
      theConsEnt = myCmrBomEnt_->myCmrCand ()[selIndex_]->myConsEnt ();
d643 3
a645 13
void WitCmrSelPt::select (WitCandIndex theIdx)
   {
   witAssert (theIdx >= 0);
   witAssert (theIdx < nCandidates ());

   witAssert (! prevSel_[theIdx]);
 
   witAssert (theIdx != selIndex_);

   selIndex_ = theIdx;
   }

//------------------------------------------------------------------------------
d647 1
a647 3
void WitCmrSelPt::selectDefault ()
   {
   WitCandIndex theIdx;
d649 1
a649 4
   for (theIdx = 0; theIdx < nCandidates (); theIdx ++)
      if (myCmrBomEnt_->candIsDefault (theIdx, myExecPer_))
         {
         selIndex_ = theIdx;
d651 1
a651 2
         return;
         }
d653 1
a653 2
   myCmrBomEnt_->myMsgFac () ("internalErrorFmsg", 
      "WitCmrSelPt::selectDefault");
@


1.13
log
@Created class SelCand and classes derived from it.
@
text
@d17 1
a18 1
//    CmrCand.
d264 1
a264 1
      candConsEnt_ (),
d273 1
a273 1
   multiChoice_ = (nCandidates () > 1);
d282 2
a283 1
   WitPeriod execPer;
d288 4
d318 1
a318 8
   return (candConsEnt_[theIdx] == myBomEnt_);
   }

//------------------------------------------------------------------------------

WitCandIndex WitCmrBomEnt::nCandidates ()
   {
   return candConsEnt_.length ();
d325 1
a325 1
   return candConsEnt_[theIdx]->inEffect (execPer);
d345 1
a345 1
      for (theIdx = nCandidates () - 1; theIdx >= 0; theIdx --)
d348 1
a348 1
               theConsEnts.push (candConsEnt_[theIdx]);
d365 1
a365 1
   nCands = nCandidates ();
d371 1
a371 1
      if (candConsEnt_[theIdx] == theConsEnt)
d396 1
a396 1
         return candConsEnt_[theIdx];
d462 1
a462 1
   candConsEnt_.resize (nCands);
d467 8
a474 1
      candConsEnt_[theIdx --] = theSub;
d476 21
a496 1
   candConsEnt_[0] = myBomEnt_;
d511 1
a511 1
      prevSel_     (theCmrBomEnt->nCandidates (), witFALSE)
d543 1
a543 1
   theConsEnt = myCmrBomEnt_->candConsEnt ()[selIndex_];
d589 1
a589 1
      theConsEnt = myCmrBomEnt_->candConsEnt ()[selIndex_];
a692 23
   }

//------------------------------------------------------------------------------
// Implementation of class CmrCand.
//------------------------------------------------------------------------------

WitCmrCand::WitCmrCand (
         WitConsEntry * theConsEnt,
         WitCmrBomEnt * theCmrBomEnt, 
         WitCandIndex   theIdx):

      WitSelCand   (theCmrBomEnt),

      myConsEnt_   (theConsEnt),
      myCmrBomEnt_ (theCmrBomEnt),
      myIdx_       (theIdx)
   {
   }

//------------------------------------------------------------------------------

WitCmrCand::~WitCmrCand ()
   {
@


1.12
log
@Fixed bug in two-way multi-exec:
   NSTN and ASAP multi-exec collisions were not being adequately detected.
@
text
@d16 1
a16 1
//    MrBomEnt.
d18 1
d22 2
a23 1
#include <MrBomEnt.h>
d30 1
a30 1
      WitSelMgr     (theSelector),
d32 2
a33 2
      myMrBomEntTl_ (),
      totExecVol_   (myProblem ())
d39 1
a39 1
   myMrBomEntTl_.allocate (myProblem (), NULL);
d42 1
a42 1
      myMrBomEnt (theBomEnt) = new WitMrBomEnt (theBomEnt, this);
d52 1
a52 1
      delete myMrBomEnt (theBomEnt);
d61 1
a61 1
   return myMrBomEnt (theBomEnt)->selConsEntry (execPer);
d76 1
a76 1
      myMrBomEnt (theConsEnt->myBomEnt ())->myCmrSelPtWithAlt (execPer);
d128 1
a128 1
      myMrBomEnt (theBomEnt)->printHasAlt ();
d141 1
a141 1
      myMrBomEnt (theConsEnt->myBomEnt ())->select (theConsEnt, execPer);
d151 1
a151 1
   myMrBomEnt (theBomEnt)->findExpConsEnts (execPer, theConsEnts);
d165 1
a165 1
   WitMrBomEnt * theMrBomEnt;
d170 1
a170 1
   theMrBomEnt = myMrBomEnt (theBomEnt);
d172 1
a172 1
   if (! theMrBomEnt->multiChoice ())
d175 1
a175 1
   return theMrBomEnt->myCmrSelPt ()[execPer]->isSplit ();
d189 1
a189 1
   theCmrSelPt = myMrBomEnt (theBomEnt)->myCmrSelPt ()[execPer];
d214 1
a214 1
      if (myMrBomEnt (theConsEnt->myBomEnt ())->multiChoice ())
d245 1
a245 1
      if (myMrBomEnt (theBomEnt)->multiChoice ())
d256 1
a256 1
// Implementation of class MrBomEnt.
d259 1
a259 1
WitMrBomEnt::WitMrBomEnt (WitBomEntry * theBomEnt, WitCmrMgr * theCmrMgr):
d280 1
a280 1
WitMrBomEnt::~WitMrBomEnt ()
d291 1
a291 1
void WitMrBomEnt::printHasAlt ()
d311 1
a311 1
WitBoolean WitMrBomEnt::candIsDefault (WitCandIndex theIdx, WitPeriod)
d318 1
a318 1
WitCandIndex WitMrBomEnt::nCandidates ()
d325 1
a325 1
WitBoolean WitMrBomEnt::candIsEligible (WitCandIndex theIdx, WitPeriod execPer)
d332 1
a332 1
void WitMrBomEnt::findExpConsEnts (
d359 1
a359 1
void WitMrBomEnt::select (WitConsEntry * theConsEnt, WitPeriod execPer)
d387 1
a387 1
WitConsEntry * WitMrBomEnt::selConsEntry (WitPeriod execPer)
d406 1
a406 1
void WitMrBomEnt::buildCmrSelPts ()
d422 1
a422 1
WitCmrSelPt * WitMrBomEnt::multiChoiceCmrSelPtWithAlt (WitPeriod execPer)
d440 1
a440 1
void WitMrBomEnt::initCandidate ()
d478 1
a478 1
WitCmrSelPt::WitCmrSelPt (WitMrBomEnt * theMrBomEnt, WitPeriod execPer):
d480 1
a480 1
      WitSelPt    (),
d482 5
a486 5
      myMrBomEnt_ (theMrBomEnt),
      myExecPer_  (execPer),
      selIndex_   (-1),
      hasResAlt_  (witFALSE),
      prevSel_    (theMrBomEnt->nCandidates (), witFALSE)
d490 1
a490 1
   witAssert (myMrBomEnt_->myBomEnt ()->inEffect (myExecPer_));
d495 1
a495 1
      if (myMrBomEnt_->candIsEligible (theIdx, myExecPer_))
d518 1
a518 1
   theConsEnt = myMrBomEnt_->candConsEnt ()[selIndex_];
d536 1
a536 1
      if (myMrBomEnt_->candIsEligible (theIdx, myExecPer_))
d564 1
a564 1
      theConsEnt = myMrBomEnt_->candConsEnt ()[selIndex_];
d577 1
a577 1
   return myMrBomEnt_->myCmrMgr ();
d589 3
a591 3
      myMrBomEnt_->myBomEnt ()->myOperationName ().myCstring (),
      myMrBomEnt_->myBomEnt ()->localIndex (),
      myMrBomEnt_->myBomEnt ()->myPartName ().myCstring (),
d610 1
a610 1
   myMrBomEnt_->myCmrMgr ()->adjustSplitBound (
d622 1
a622 1
   theBomEnt = myMrBomEnt_->myBomEnt ();
d652 1
a652 1
      if (myMrBomEnt_->candIsDefault (theIdx, myExecPer_))
d659 2
a660 1
   myMrBomEnt_->myMsgFac () ("internalErrorFmsg", "WitCmrSelPt::selectDefault");
d667 24
a690 1
   return myMrBomEnt_->msgFile ();
@


1.11
log
@Refactoring.
@
text
@d573 1
a573 1
WitSelMgr * WitCmrSelPt::mySelMgr (WitSelector * theSelector)
d575 1
a575 1
   return theSelector->myCmrMgr ();
@


1.10
log
@Refactoring.
@
text
@a132 15
void WitCmrMgr::printMultiChoices ()
   {
   WitBomEntry * theBomEnt;

   fprintf (msgFile (),
      "\n"
      "Multi-Route BOM entries with multi-choice:\n"
      "\n");

   forEachBomEntry (theBomEnt, myProblem ())
      myMrBomEnt (theBomEnt)->printIfMultiChoice ();
   }

//------------------------------------------------------------------------------

a288 12
void WitMrBomEnt::printIfMultiChoice ()
   {
   if (multiChoice_)
      {
      printID ();

      fprintf (msgFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

d302 1
a302 1
         if (theCmrSelPt->hasAlt ())
a329 22
void WitMrBomEnt::printID ()
   {
   fprintf (msgFile (),
      "   BomEntry %s, #%d",
      myBomEnt_->myOperationName ().myCstring (),
      myBomEnt_->localIndex ());
   }

//------------------------------------------------------------------------------

void WitMrBomEnt::printCandidate (WitCandIndex theIdx)
   {
   if (candConsEnt_[theIdx]->isaSubEntry ())
      fprintf (msgFile (),
         "SubEntry: #%d",
         candConsEnt_[theIdx]->localIndex ());
   else
      fprintf (msgFile (), "Original BomEntry");
   }

//------------------------------------------------------------------------------

d431 1
a431 1
      theCmrSelPt->hasAlt ()?
d481 1
a481 1
      execPeriod_ (execPer),
d488 1
a488 1
   witAssert (myMrBomEnt_->myBomEnt ()->inEffect (execPeriod_));
d493 1
a493 1
      if (myMrBomEnt_->candIsEligible (theIdx, execPeriod_))
a509 7
WitBoolean WitCmrSelPt::hasAlt ()
   {
   return (selIndex_ >= 0);
   }

//------------------------------------------------------------------------------

d527 1
a527 1
   witAssert (hasAlt ());
d534 1
a534 1
      if (myMrBomEnt_->candIsEligible (theIdx, execPeriod_))
d550 2
d556 2
d559 2
d562 1
a562 1
      fprintf (msgFile (), "   Selected ConsEntry: None\n");
d564 4
a567 1
      return;
a568 8

   fprintf (msgFile (), "   Selected ");

   myMrBomEnt_->printCandidate (selIndex_);

   fprintf (msgFile (),
      ", Has Alt? %s\n",
      myMrBomEnt_->myMsgFac ().booleanText (hasAlt ()));
d590 1
a590 1
      execPeriod_);
d610 1
a610 1
      execPeriod_, 
d618 3
a620 1
   myMrBomEnt_->printID ();
d622 5
a626 1
   fprintf (msgFile (), ", Period %d\n", execPeriod_);
d650 1
a650 1
      if (myMrBomEnt_->candIsDefault (theIdx, execPeriod_))
@


1.9
log
@Refactoring.
@
text
@d440 3
a442 4
   theIdx = 
      multiChoice_?
         myCmrSelPt_[execPer]->selIndex ():
         0;
d444 3
a446 1
   witAssert (theIdx >= 0);
d448 1
a448 1
   return candConsEnt_[theIdx];
d531 1
a531 1
      selIndex_   (0),
d561 1
a561 4
   if (hasResAlt_)
      return witTRUE;

   return ! myMrBomEnt_->candIsDefault (selIndex_, execPeriod_);
d570 2
a580 1
   WitBoolean   altFound;
d586 1
a586 1
   altFound            = witFALSE;
d592 1
a592 2
            if (! altFound)
               {
a593 2
               altFound  = witTRUE;
               }
d598 1
a598 1
               break;
a599 3

   if (! altFound)
      selectDefault ();
d609 7
@


1.8
log
@Continued development of selection splitting for multi=exec.
@
text
@d295 1
a295 1
   WitPeriod thePer;
d298 2
a299 2
      forEachPeriod (thePer, myProblem ())
         delete myCmrSelPt_[thePer];
d318 1
a318 1
   WitPeriod     thePer;
d324 1
a324 1
   forEachPeriod (thePer, myProblem ())
d326 1
a326 1
      theCmrSelPt = myCmrSelPt_[thePer];
d328 3
a330 2
      if (theCmrSelPt->hasAlt ())
         theCmrSelPt->printID ();
d350 1
a350 1
WitBoolean WitMrBomEnt::candIsEligible (WitCandIndex theIdx, WitPeriod thePer)
d352 1
a352 1
   return candConsEnt_[theIdx]->inEffect (thePer);
d412 2
d462 2
a463 1
      myCmrSelPt_[execPer] = new WitCmrSelPt (this, execPer);
d468 1
a468 1
WitCmrSelPt * WitMrBomEnt::multiChoiceCmrSelPtWithAlt (WitPeriod thePer)
d474 3
a476 1
   theCmrSelPt = myCmrSelPt_[thePer];
d524 1
a524 1
WitCmrSelPt::WitCmrSelPt (WitMrBomEnt * theMrBomEnt, WitPeriod thePer):
d529 2
a530 2
      execPeriod_ (thePer),
      selIndex_   (-1),
d536 1
a536 2
   if (! myMrBomEnt_->myBomEnt ()->inEffect (execPeriod_))
      return;
a562 3
   if (selIndex_ == -1)
      return witFALSE;

a571 2
   witAssert (selIndex_ >= 0);

d581 1
d587 1
a587 1
   selIndex_           = -1;
d593 2
a594 1
            if (selIndex_ == -1)
d596 2
d605 1
a605 1
   if (selIndex_ == -1)
a612 2
   witAssert (selIndex_ >= 0);

d683 1
@


1.7
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@d74 1
a74 1
      myMrBomEnt (theConsEnt->myBomEntry ())->myCmrSelPtWithAlt (execPer);
d93 24
d154 1
a154 1
      myMrBomEnt (theConsEnt->myBomEntry ())->select (theConsEnt, execPer);
d227 1
a227 1
      if (myMrBomEnt (theConsEnt->myBomEntry ())->multiChoice ())
d276 1
a276 1
      myBomEntry_  (theBomEnt),
d337 1
a337 1
   return (candConsEnt_[theIdx] == myBomEntry_);
d360 2
a361 2
      myBomEntry_->myOperationName ().myCstring (),
      myBomEntry_->localIndex ());
d385 1
a385 1
   witAssert (myBomEntry_->inEffect (execPer));
d400 1
a400 1
      theConsEnts.push (myBomEntry_);
d435 1
a435 1
   witAssert (myBomEntry_->inEffect (execPer));
d490 1
a490 1
   forEachEl (theSub, myBomEntry_->mySubEntries ())
d511 1
a511 1
   candConsEnt_[0] = myBomEntry_;
d530 1
a530 1
   if (! myMrBomEnt_->myBomEntry ()->inEffect (execPeriod_))
d633 15
a664 41
   }

//------------------------------------------------------------------------------

void WitCmrSelPt::prtSplitting (double)
   {
   WitMsgFacility::current () ("internalErrorFmsg", 
      "WitCmrSelPt::prtSplitting");
   }

//------------------------------------------------------------------------------

void WitCmrSelPt::prtSplitExp (WitTlObj * splitTlObj)
   {
   WitConsEntry * theConsEnt;

   theConsEnt = (WitConsEntry *) splitTlObj;

   fprintf (msgFile (),
      "\n"
      "Split Selection for Consumption Multi-Route:\n"
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Part:        %s\n"
      "   Exec Per:    %d\n",
      theConsEnt->myOperationName ().myCstring (),
      theConsEnt->myBomEntry ()->localIndex (),
      theConsEnt->myBomEntry ()->myPartName ().myCstring (),
      execPeriod_);

   if (theConsEnt == theConsEnt->myBomEntry ())
      fprintf (msgFile (), 
         "   Self\n");
   else
      fprintf (msgFile (), 
         "   Sub #:       %d\n", 
         theConsEnt->localIndex ());
                  
   fprintf (msgFile (),
      "   Part:        %s\n",
      theConsEnt->myPartName ().myCstring ());
@


1.6
log
@Various refactorings for sel-split for multi-exec.
@
text
@d31 1
a31 2
      totExecVol_   (myProblem ()),
      splitExecPer_ (-1)
d181 10
d192 1
a192 1
   splitExecPer_ = execPer;
a244 9

void WitCmrMgr::adjustSplitBound (WitTlObj * theTlObj, double & splitBound)
   {
   witAssert (selSplit ());

   splitBound -= totExecVol_ (asaConsEntry (theTlObj), splitExecPer_);
   }

//------------------------------------------------------------------------------
d612 14
@


1.5
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d175 1
a175 3
   WitMrBomEnt *  theMrBomEnt;
   WitCmrSelPt *  theCmrSelPt;
   WitConsEntry * theConsEnt;
d179 1
a179 4
   theMrBomEnt = myMrBomEnt (theBomEnt);

   theCmrSelPt = theMrBomEnt->myCmrSelPt ()[execPer];
   theConsEnt  = theMrBomEnt->selConsEntry (execPer);
d181 1
a181 1
   startSplitExpAbs (theCmrSelPt, asaTlObj (theConsEnt), execVolVal);
a244 35

void WitCmrMgr::prtSplitExp (WitTlObj * theTlObj)
   {
   WitConsEntry * theConsEnt;

   witAssert (selSplit ());

   theConsEnt = asaConsEntry (theTlObj);

   fprintf (msgFile (),
      "\n"
      "Split Selection for Consumption Multi-Route:\n"
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Part:        %s\n"
      "   Exec Per:    %d\n",
      theConsEnt->myOperationName ().myCstring (),
      theConsEnt->myBomEntry ()->localIndex (),
      theConsEnt->myBomEntry ()->myPartName ().myCstring (),
      splitExecPer_);

   if (theConsEnt == theConsEnt->myBomEntry ())
      fprintf (msgFile (), 
         "   Self\n");
   else
      fprintf (msgFile (), 
         "   Sub #:       %d\n", 
         theConsEnt->localIndex ());
                  
   fprintf (msgFile (),
      "   Part:        %s\n",
      theConsEnt->myPartName ().myCstring ());
   }

//------------------------------------------------------------------------------
a497 1
      myPeriod_   (thePer),
d499 1
d506 1
a506 1
   if (! myMrBomEnt_->myBomEntry ()->inEffect (myPeriod_))
d512 1
a512 1
      if (myMrBomEnt_->candIsEligible (theIdx, myPeriod_))
d537 1
a537 1
   return ! myMrBomEnt_->candIsDefault (selIndex_, myPeriod_);
d542 1
a542 1
WitTlObj * WitCmrSelPt::selection ()
d566 1
a566 1
      if (myMrBomEnt_->candIsEligible (theIdx, myPeriod_))
d624 33
d661 1
a661 1
   fprintf (msgFile (), ", Period %d\n", myPeriod_);
d684 1
a684 1
      if (myMrBomEnt_->candIsDefault (theIdx, myPeriod_))
@


1.4
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a31 1
      splitSched_   (myProblem ()),
d58 1
a58 1
      WitPeriod     thePer)
d60 1
a60 1
   return myMrBomEnt (theBomEnt)->selConsEntry (thePer);
d155 9
a163 4
   if (selSplit ())
      if (myMrBomEnt (theBomEnt)->multiChoice ())
         if (! splitSched_ (theBomEnt, execPer).isEmpty ())
            return witTRUE;
d165 1
a165 1
   return witFALSE;
d173 1
a173 1
      double        theExecVol)
d175 4
d181 7
a188 6

   startSplitExpAbs (
      splitSched_            (theBomEnt, execPer),
      asaTlObj (selConsEntry (theBomEnt, execPer)),
      theExecVol,
      NULL);
a215 3
   witAssert (selSplit ());

   splitSched_.clear ();
a227 1
   splitSched_.allocate1D ();
a236 2

         splitSched_.allocateRow (theBomEnt);
d242 1
a242 1
void WitCmrMgr::adjustSplitBound (WitTl * theTlObj, double & splitBound)
d251 1
a251 1
void WitCmrMgr::prtSelSplit (WitTl * theTlObj)
d293 1
a293 1
      candidate_   (),
d353 1
a353 1
   return (candidate_[theIdx] == myBomEntry_);
d360 1
a360 1
   return candidate_.length ();
d367 1
a367 1
   return candidate_[theIdx]->inEffect (thePer);
d384 1
a384 1
   if (candidate_[theIdx]->isaSubEntry ())
d387 1
a387 1
         candidate_[theIdx]->localIndex ());
d407 1
a407 1
      theCmrSelPt = myCmrSelPt ()[execPer];
d412 1
a412 1
               theConsEnts.push (candidate_[theIdx]);
d433 1
a433 1
      if (candidate_[theIdx] == theConsEnt)
d442 19
a460 1
   myCmrSelPt ()[execPer]->select (theSelIdx);
d467 1
a467 1
   WitPeriod thePer;
d474 2
a475 2
   forEachPeriod (thePer, myProblem ())
      myCmrSelPt_[thePer] = new WitCmrSelPt (this, thePer);
d520 1
a520 1
   candidate_.resize (nCands);
d525 1
a525 1
      candidate_[theIdx --] = theSub;
d527 1
a527 1
   candidate_[0] = myBomEntry_;
d582 13
a622 7
void WitCmrSelPt::splitSelection (double)
   {
   myMrBomEnt_->myMsgFac () ("internalErrorFmsg", "CmrSelPt::splitSelection");
   }

//------------------------------------------------------------------------------

d652 8
@


1.3
log
@Renamed AltPt classes to SelPt classes.
@
text
@a42 3

   if (selSplit ())
      setupSelSplit ();
d147 7
d214 1
a214 1
void WitCmrMgr::setupSelSplit ()
@


1.2
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@d17 1
a17 1
//    CmrAltPt.
d69 1
a69 1
WitAltPt * WitCmrMgr::myAltPt (
d76 1
a76 1
   WitCmrAltPt * theCmrAltPt;
d78 2
a79 2
   theCmrAltPt = 
      myMrBomEnt (theConsEnt->myBomEntry ())->myCmrAltPtWithAlt (execPer);
d82 2
a83 2
      (theCmrAltPt != NULL)?
         theCmrAltPt->hasResAlt ():
d86 1
a86 1
   return theCmrAltPt;
d104 1
a104 1
      "Consumption Multi-Route Alt Points with Alternative(s):\n\n");
d288 1
a288 1
      myCmrAltPt_  ()
d297 1
a297 1
   buildCmrAltPts ();
d308 1
a308 1
         delete myCmrAltPt_[thePer];
d328 1
a328 1
   WitCmrAltPt * theCmrAltPt;
d335 1
a335 1
      theCmrAltPt = myCmrAltPt_[thePer];
d337 2
a338 2
      if (theCmrAltPt->hasAlt ())
         theCmrAltPt->printID ();
d392 1
a392 1
   WitCmrAltPt * theCmrAltPt;
d400 1
a400 1
      theCmrAltPt = myCmrAltPt ()[execPer];
d404 1
a404 1
            if (! theCmrAltPt->prevSel ()[theIdx])
d435 1
a435 1
   myCmrAltPt ()[execPer]->select (theSelIdx);
d440 1
a440 1
void WitMrBomEnt::buildCmrAltPts ()
d447 1
a447 1
   myCmrAltPt_.allocate (myProblem ());
d450 1
a450 1
      myCmrAltPt_[thePer] = new WitCmrAltPt (this, thePer);
d455 1
a455 1
WitCmrAltPt * WitMrBomEnt::multiChoiceCmrAltPtWithAlt (WitPeriod thePer)
d457 1
a457 1
   WitCmrAltPt * theCmrAltPt;
d461 1
a461 1
   theCmrAltPt = myCmrAltPt_[thePer];
d464 2
a465 2
      theCmrAltPt->hasAlt ()?
         theCmrAltPt:
d506 1
a506 1
// Implementation of class CmrAltPt.
d509 1
a509 1
WitCmrAltPt::WitCmrAltPt (WitMrBomEnt * theMrBomEnt, WitPeriod thePer):
d511 1
a511 1
      WitAltPt    (),
d538 1
a538 1
WitCmrAltPt::~WitCmrAltPt ()
d544 1
a544 1
WitBoolean WitCmrAltPt::hasAlt ()
d557 1
a557 1
void WitCmrAltPt::alterSelection ()
d585 1
a585 1
void WitCmrAltPt::splitSelection (double)
d587 1
a587 1
   myMrBomEnt_->myMsgFac () ("internalErrorFmsg", "CmrAltPt::splitSelection");
d592 1
a592 1
void WitCmrAltPt::printSelection ()
d611 1
a611 1
WitSelMgr * WitCmrAltPt::mySelMgr (WitSelector * theSelector)
d618 1
a618 1
WitBoolean WitCmrAltPt::splittable ()
d625 1
a625 1
void WitCmrAltPt::printID ()
d634 1
a634 1
void WitCmrAltPt::select (WitCandIndex theIdx)
d647 1
a647 1
void WitCmrAltPt::selectDefault ()
d659 1
a659 1
   myMrBomEnt_->myMsgFac () ("internalErrorFmsg", "WitCmrAltPt::selectDefault");
d664 1
a664 1
FILE * WitCmrAltPt::msgFile ()
@


1.1
log
@Refactoring for selection splitting.
@
text
@d173 1
a173 1
      asaTlPtr (selConsEntry (theBomEnt, execPer)),
@


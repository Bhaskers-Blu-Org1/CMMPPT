head	1.27;
access;
symbols
	sce_4_05_20040511:1.22
	sce_4_00_20040201:1.22
	nextGenBranch:1.21.0.2
	nextGenRoot:1.21
	sce_3_30_20030627:1.21
	EndRw-branch:1.1.0.4
	Root-of-EndRw:1.1
	rwToStl:1.1.0.2;
locks; strict;
comment	@ * @;


1.27
date	2004.12.09.19.22.50;	author rjw;	state dead;
branches;
next	1.26;

1.26
date	2004.11.30.00.19.46;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.12.23.50.50;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.12.21.03.45;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.11.22.16.12;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.02.20.46.43;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.09.18.55.40;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.29.19.55.29;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.29.14.27.46;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.15.20.50.10;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.14.22.00.35;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.11.19.08.26;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.01.20.34.27;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.31.23.09.48;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.28.23.05.31;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.21.23.36.51;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.21.21.35.28;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.20.19.03.56;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.19.16.48.19;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.07.21.34.16;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.27.17.21.24;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.07.23.29.09;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.29.19.16.47;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.02.23.40.43;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.02.22.18.33;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.04.19.17.56;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.26.19.05.26;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Low-Pri Prop-Rt.
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "MrMgr.C"
//
// Contains the implementation of the following classes and templates:
//
//    MrMgr
//    MrCoord
//    MrSelMgr
//    PmrSelMgr
//    CmrSelMgr
//------------------------------------------------------------------------------

#include <MrMgr.h>
#include <MrCoord.h>
#include <MrSelMgr.h>
#include <MrCand.h>
#include <MrPt.h>
#include <Selector.h>
#include <MrSite.h>
#include <RtMgr.h>
#include <RtSite.h>
#include <RtCand.h>
#include <SplitPt.h>
#include <Global.h>
#include <Opn.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <MsgFac.h>
#include <MapIdxI.h>

//------------------------------------------------------------------------------
// Implementation of class MrMgr.
//------------------------------------------------------------------------------

WitMrMgr::WitMrMgr (WitSelector * theSelector):

      WitProbAssoc (theSelector->myProblem ()),
      myMrCoord_   (NULL)
   {
   myMsgFac () ("multiRouteMsg");

   myMrCoord_ = new WitMrCoord (theSelector);
   }

//------------------------------------------------------------------------------

WitMrMgr::~WitMrMgr ()
   {
   delete myMrCoord_;
   }

//------------------------------------------------------------------------------

bool WitMrMgr::instNeededFor (WitProblem * theProblem)
   {
   return theProblem->myGlobalComp ()->multiRoute ();
   }

//------------------------------------------------------------------------------

WitRtCand * WitMrMgr::selRtCand (WitRtSite * theRtSite, WitPeriod thePer)
   {
   return myMrCoord_->selRtCand (theRtSite, thePer);
   }

//------------------------------------------------------------------------------

bool WitMrMgr::activeForPE (WitRtCand * theRtCand, WitPeriod thePer)
   {
   WitMrCand * theMrCand;
   WitMrSite * theMrSite;

   if (not theRtCand->isEligible (thePer))
      return false;

   theMrCand = myMrCoord_->myMrCandFor (theRtCand);

   if (theMrCand == NULL)
      return false;

   if (not theMrCand->prevSel (thePer))
      return true;

   theMrSite = theMrCand->myMrSite ();

   if (theMrSite->myMrPt ()[thePer]->selSelCand () == NULL)
      if (theMrCand == theMrSite->defaultMrCand (thePer))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitMrMgr::multiChoice (WitRtSite * theRtSite)
   {
   return myMrCoord_->myMrSiteFor (theRtSite)->multiChoice ();
   }

//------------------------------------------------------------------------------

bool WitMrMgr::valid (WitRtCand * theRtCand, WitPeriod thePer)
   {
   return myMrCoord_->myMrCandFor (theRtCand)->valid (thePer);
   }

//------------------------------------------------------------------------------

void WitMrMgr::select (WitRtCand * theRtCand, WitPeriod thePer)
   {
   WitMrCand * theMrCand;

   theMrCand = myMrCoord_->myMrCandFor (theRtCand);

   theMrCand->myMrSite ()->myMrPt ()[thePer]->select (theMrCand);
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrMgr::mySelPtFor (WitRtSite * theRtSite, WitPeriod thePer)
   {
   return myMrCoord_->myMrSiteFor (theRtSite)->myMrPt ()[thePer];
   }

//------------------------------------------------------------------------------

void WitMrMgr::print ()
   {
   WitRtSite * theRtSite;

   fprintf (msgFile (),
      "\n"
      "\n"
      "Multi-Route Selection Points with Alternative(s):\n\n");

   forEachEl (theRtSite, myMrCoord_->mySelector ()->myRtMgr ()->myRtSites ())
      myMrCoord_->myMrSiteFor (theRtSite)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

bool WitMrMgr::selIsSplit (WitRtSite * theRtSite, WitPeriod thePer)
   {
   return myMrCoord_->selIsSplit (theRtSite, thePer);
   }

//------------------------------------------------------------------------------

void WitMrMgr::defineSplit (
      WitRtSite *         theRtSite, 
      WitPeriod           thePer,
      double              expVol,
      WitRtCandDblStack & theSplitPairs,
      bool &              lastUnbdd)
   {
   WitMrSite *        theMrSite;
   WitSplitPt *       theSplitPt;
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitRtCand *        theRtCand;

   witAssert (myMrCoord_->selIsSplit (theRtSite, thePer));

   theMrSite  = myMrCoord_->myMrSiteFor (theRtSite);

   theSplitPt = theMrSite->myMrPt ()[thePer]->mySplitPt ();

   theSplitPt->defineSplit (expVol, theAbsSplitPairs, lastUnbdd);

   theSplitPairs.clear ();

   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      theRtCand = theSelCand->myMrCand ()->myRtCand ();

      theSplitPairs.push (theRtCand, splitVol);
      }
   }

//------------------------------------------------------------------------------

void WitMrMgr::recordFlowSS (
      WitRtSite * theRtSite,
      WitPeriod   thePer,
      double      incFlowVol)
   {
   WitMrSite * theMrSite;

   theMrSite = myMrCoord_->myMrSiteFor (theRtSite);

   if (theMrSite->multiChoice ())
      theMrSite->myMrPt ()[thePer]->recordFlowSS (incFlowVol);
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrMgr::mySelMgr (WitRtCase theRtCase)
   {
   return myMrCoord_->myMrSelMgr (theRtCase);
   }

//------------------------------------------------------------------------------
// Implementation of class MrCoord.
//------------------------------------------------------------------------------

WitMrCoord::WitMrCoord (WitSelector * theSelector):

      WitProbAssoc       (theSelector->myProblem ()),
      myMrSelMgrForProd_ (NULL),
      myMrSelMgrForCons_ (NULL),
      myMrSiteFor_       (myProblem ()),
      myMrCandFor_       (myProblem ()),
      mySelector_        (theSelector)
   {
   WitRtSite * theRtSite;

   myMrSelMgrForProd_ = new WitPmrSelMgr (this);
   myMrSelMgrForCons_ = new WitCmrSelMgr (this);

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      myMrSiteFor_ (theRtSite) = new WitMrSite (theRtSite, this);
   }

//------------------------------------------------------------------------------

WitMrCoord::~WitMrCoord ()
   {
   WitRtSite * theRtSite;

   myMrCandFor_.clear ();

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      delete myMrSiteFor_ (theRtSite);

   delete myMrSelMgrForCons_;
   delete myMrSelMgrForProd_;
   }

//------------------------------------------------------------------------------

void WitMrCoord::store (WitMrCand * theMrCand)
   {
   witAssert (myMrCandFor_ (theMrCand->myRtCand ()) == NULL);

   myMrCandFor_ (theMrCand->myRtCand ()) = theMrCand;
   }

//------------------------------------------------------------------------------

WitRtCand * WitMrCoord::selRtCand (WitRtSite * theRtSite, WitPeriod thePer)
   {
   return myMrSiteFor_ (theRtSite)->selMrCand (thePer)->myRtCand ();
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrCoord::mySelPtForAlt (WitRtCand * theRtCand, WitPeriod thePer)
   {
   WitMrSite * theMrSite;

   theMrSite = myMrSiteFor_ (theRtCand->myRtSite ());

   return theMrSite->myMrPtWithAlt (thePer);
   }

//------------------------------------------------------------------------------

bool WitMrCoord::selIsSplit (WitRtSite * theRtSite, WitPeriod thePer)
   {
   WitMrSite * theMrSite;

   if (not mySelector_->selSplit ())
      return false;

   theMrSite = myMrSiteFor_ (theRtSite);

   if (not theMrSite->multiChoice ())
      return false;

   return theMrSite->myMrPt ()[thePer]->isSplit ();
   }

//------------------------------------------------------------------------------

WitMrSelMgr * WitMrCoord::myMrSelMgr (WitRtCase theRtCase)
   {
   return
      (theRtCase == prodRtCase)? myMrSelMgrForProd_:
      (theRtCase == consRtCase)? myMrSelMgrForCons_:
                                 NULL;
   }

//------------------------------------------------------------------------------
// Implementation of class MrSelMgr.
//------------------------------------------------------------------------------

WitMrSelMgr::~WitMrSelMgr ()
   {
   }

//------------------------------------------------------------------------------

WitMrSelMgr::WitMrSelMgr (WitMrCoord * theMrCoord):

      WitSelMgr  (theMrCoord->mySelector ()),
      myMrCoord_ (theMrCoord)
   {
   }

//------------------------------------------------------------------------------

bool WitMrSelMgr::selSplitNeeded ()
   {
   return (myGlobalComp ()->selSplit ());
   }

//------------------------------------------------------------------------------
// Implementation of class PmrSelMgr.
//------------------------------------------------------------------------------

WitPmrSelMgr::WitPmrSelMgr (WitMrCoord * theMrCoord):

      WitMrSelMgr (theMrCoord)
   {
   }

//------------------------------------------------------------------------------

WitPmrSelMgr::~WitPmrSelMgr ()
   {
   }

//------------------------------------------------------------------------------

WitSelPt * WitPmrSelMgr::mySelPtForAlt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
   {
   WitPeriod expPer;

   expPer = theBopEnt->impactPeriod ()[execPer];

   return myMrCoord ()->mySelPtForAlt (theBopEnt->myRtCand (), expPer);
   }

//------------------------------------------------------------------------------

bool WitPmrSelMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitPmrSelMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

const char * WitPmrSelMgr::selCaseName ()
   {
   return "Production Multi-Route";
   }

//------------------------------------------------------------------------------
// Implementation of class CmrSelMgr.
//------------------------------------------------------------------------------

WitCmrSelMgr::WitCmrSelMgr (WitMrCoord * theMrCoord):

      WitMrSelMgr (theMrCoord)
   {
   }

//------------------------------------------------------------------------------

WitCmrSelMgr::~WitCmrSelMgr ()
   {
   }

//------------------------------------------------------------------------------

WitSelPt * WitCmrSelMgr::mySelPtForAlt (
      WitBopEntry *,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod)
   {
   return myMrCoord ()->mySelPtForAlt (theConsEnt->myRtCand (), execPer);
   }

//------------------------------------------------------------------------------

bool WitCmrSelMgr::validForNetting ()
   {
   return false;
   }

//------------------------------------------------------------------------------

bool WitCmrSelMgr::validForExecBounds ()
   {
   return false;
   }

//------------------------------------------------------------------------------

const char * WitCmrSelMgr::selCaseName ()
   {
   return "Consumption Multi-Route";
   }
@


1.26
log
@Low-Pri Prop-Rt.
@
text
@@


1.25
log
@Low-Pri Prop-Rt.
@
text
@d129 1
a129 1
WitSelPt * WitMrMgr::mySelPt (WitRtSite * theRtSite, WitPeriod thePer)
@


1.24
log
@Low-Pri Prop-Rt.
@
text
@d77 1
a77 1
bool WitMrMgr::activeForPE (WitBillEntry * theBillEnt, WitPeriod thePer)
a78 1
   WitRtCand * theRtCand;
a81 2
   theRtCand = theBillEnt->myRtCand ();

@


1.23
log
@Low-Pri Prop-Rt.
@
text
@a33 1
#include <RtSitePtr.h>
a76 7
WitRtCand * WitMrMgr::selRtCand (WitRtSitePtr theRtSite, WitPeriod thePer)
   {
   return myMrCoord_->selRtCand (theRtSite, thePer);
   }

//------------------------------------------------------------------------------

d156 1
a156 1
bool WitMrMgr::selIsSplit (WitRtSitePtr theRtSite, WitPeriod thePer)
d164 1
a164 1
      WitRtSitePtr        theRtSite, 
d198 3
a200 3
      WitRtSitePtr theRtSite,
      WitPeriod    thePer,
      double       incFlowVol)
@


1.22
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d78 1
a78 1
WitRtCand * WitMrMgr::selRtCand (WitRtSitePtr theRtSitePtr, WitPeriod thePer)
d80 1
a80 1
   return myMrCoord_->selRtCand (theRtSitePtr (), thePer);
d164 1
a164 1
bool WitMrMgr::selIsSplit (WitRtSitePtr theRtSitePtr, WitPeriod thePer)
d166 1
a166 1
   return myMrCoord_->selIsSplit (theRtSitePtr (), thePer);
d172 1
a172 1
      WitRtSitePtr        theRtSitePtr, 
d185 1
a185 1
   witAssert (myMrCoord_->selIsSplit (theRtSitePtr (), thePer));
d187 1
a187 1
   theMrSite  = myMrCoord_->myMrSiteFor (theRtSitePtr ());
d206 1
a206 1
      WitRtSitePtr theRtSitePtr,
d212 1
a212 1
   theMrSite = myMrCoord_->myMrSiteFor (theRtSitePtr ());
@


1.21
log
@Attempt to fix syntax errors from GCC compiler.
@
text
@a37 1
#include <PtrMapI.h>
d39 1
@


1.20
log
@Continued implementation of proportionate routing.
@
text
@d34 1
a34 1
#include <RtSiteComp.h>
d78 1
a78 1
WitRtCand * WitMrMgr::selRtCand (WitRtSiteComp theRtSiteComp, WitPeriod thePer)
d80 1
a80 1
   return myMrCoord_->selRtCand (theRtSiteComp, thePer);
d164 1
a164 1
bool WitMrMgr::selIsSplit (WitRtSiteComp theRtSiteComp, WitPeriod thePer)
d166 1
a166 1
   return myMrCoord_->selIsSplit (theRtSiteComp, thePer);
d172 1
a172 1
      WitRtSiteComp       theRtSiteComp, 
d185 1
a185 1
   witAssert (myMrCoord_->selIsSplit (theRtSiteComp, thePer));
d187 1
a187 1
   theMrSite  = myMrCoord_->myMrSiteFor (theRtSiteComp);
d206 3
a208 3
      WitRtSiteComp theRtSiteComp,
      WitPeriod     thePer,
      double        incFlowVol)
d212 1
a212 1
   theMrSite = myMrCoord_->myMrSiteFor (theRtSiteComp);
@


1.19
log
@Continued implementation of proportionate routing.
@
text
@d34 1
a34 1
#include <Part.h>
d78 1
a78 1
bool WitMrMgr::activeForPE (WitRtCand * theRtCand, WitPeriod thePer)
d80 8
d91 2
d164 1
a164 1
bool WitMrMgr::selIsSplit (WitRtSite * theRtSite, WitPeriod thePer)
d166 1
a166 1
   return myMrCoord_->selIsSplit (theRtSite, thePer);
d172 1
a172 1
      WitRtSite *         theRtSite, 
d185 1
a185 1
   witAssert (selIsSplit (theRtSite, thePer));
d187 1
a187 1
   theMrSite  = myMrCoord_->myMrSiteFor (theRtSite);
d206 3
a208 3
      WitRtSite * theRtSite,
      WitPeriod   thePer,
      double      incFlowVol)
d212 1
a212 1
   theMrSite = myMrCoord_->myMrSiteFor (theRtSite);
@


1.18
log
@Continued implementation of proportionate routing.
@
text
@d196 1
a196 1
      WitRtCand * theRtCand,
d200 1
a200 1
   WitMrSelMgr * theMrSelMgr;
d202 1
a202 1
   theMrSelMgr = myMrCoord_->myMrSelMgr (theRtCand->myRtSite ()->myRtCase ());
d204 2
a205 1
   theMrSelMgr->recordFlowSS (theRtCand, thePer, incFlowVol);
a311 22
   }

//------------------------------------------------------------------------------

void WitMrSelMgr::recordFlowSS (
      WitRtCand * theRtCand,
      WitPeriod   thePer,
      double      incFlowVol)
   {
   WitMrSite * theMrSite;
   WitMrPt *   theMrPt;

   witAssert (selSplit ());

   theMrSite = myMrCoord_->myMrSiteFor (theRtCand->myRtSite ());

   if (not theMrSite->multiChoice ())
      return;

   theMrPt = theMrSite->myMrPt ()[thePer];

   mySelector ()->recordFlowSS (theMrPt, incFlowVol);
@


1.17
log
@Continued implementation of proportionate routing.
@
text
@a153 24
WitBopEntry * WitMrMgr::selBopEnt (WitPart * thePart, WitPeriod expPer)
   {
   WitRtCand * theRtCand;

   theRtCand = myMrCoord_->selRtCand (thePart->myRtSite (), expPer);

   return theRtCand->myBillEnt ()->myBopEnt ();
   }

//------------------------------------------------------------------------------

WitConsEntry * WitMrMgr::selConsEnt (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitRtCand * theRtCand;

   theRtCand = myMrCoord_->selRtCand (theBomEnt->myRtSite (), execPer);

   return theRtCand->myBillEnt ()->myConsEnt ();
   }

//------------------------------------------------------------------------------

d195 4
a198 1
void WitMrMgr::setProdBoundedSplit (bool theVal)
d200 1
a200 2
   myMrCoord_->myMrSelMgrForProd ()->setBoundedSplit (theVal);
   }
d202 1
a202 1
//------------------------------------------------------------------------------
d204 1
a204 3
void WitMrMgr::setConsBoundedSplit (bool theVal)
   {
   myMrCoord_->myMrSelMgrForCons ()->setBoundedSplit (theVal);
d209 1
a209 4
void WitMrMgr::recExpPartSS (
      WitPart * thePart,
      WitPeriod expPer,
      double    expVol)
d211 1
a211 31
   myMrCoord_->myMrSelMgrForProd ()->recExpRtSiteSS (
      thePart->myRtSite (),
      expPer,
      expVol);
   }

//------------------------------------------------------------------------------

void WitMrMgr::recExpBomEntSS (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        expVol)
   {
   myMrCoord_->myMrSelMgrForCons ()->recExpRtSiteSS (
      theBomEnt->myRtSite (),
      execPer,
      expVol);
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrMgr::mySelMgrForProd ()
   {
   return myMrCoord_->myMrSelMgrForProd ();
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMrMgr::mySelMgrForCons ()
   {
   return myMrCoord_->myMrSelMgrForCons ();
d296 10
d315 2
a316 2
void WitMrSelMgr::recExpRtSiteSS (
      WitRtSite * theRtSite,
d325 1
a325 1
   theMrSite = myMrCoord_->myMrSiteFor (theRtSite);
@


1.16
log
@Continued implementation of proportionate routing.
@
text
@d199 1
a199 1
   witAssert (myMrCoord_->selIsSplit (theRtSite, thePer));
@


1.15
log
@Continued implementation of proportionate routing.
@
text
@d32 1
d178 1
a178 4
void WitMrMgr::startSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol)
d180 1
a180 4
   myMrCoord_->myMrSelMgrForProd ()->startSplitExp (
      thePart->myRtSite (),
      expPer,
      expVol);
d185 6
a190 4
void WitMrMgr::startSplitExp (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer,
      double        execVolVal)
d192 6
a197 5
   myMrCoord_->myMrSelMgrForCons ()->startSplitExp (
      theBomEnt->myRtSite (),
      execPer,
      execVolVal);
   }
d199 1
a199 23
//------------------------------------------------------------------------------

bool WitMrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   return myMrCoord_->selIsSplit (thePart->myRtSite (), expPer);
   }

//------------------------------------------------------------------------------

bool WitMrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   return myMrCoord_->selIsSplit (theBomEnt->myRtSite (), execPer);
   }

//------------------------------------------------------------------------------

bool WitMrMgr::findNextSplit (WitBopEntry * & theBopEnt, double & splitExpVol)
   {
   bool        splitFound;
   WitRtCand * theRtCand;

   splitFound =
      myMrCoord_->myMrSelMgrForProd ()->findNextSplit (theRtCand, splitExpVol);
d201 1
a201 2
   if (splitFound)
      theBopEnt = theRtCand->myBillEnt ()->myBopEnt ();
d203 1
a203 2
   return splitFound;
   }
d205 1
a205 1
//------------------------------------------------------------------------------
d207 1
a207 6
bool WitMrMgr::findNextSplit (
      WitConsEntry * & theConsEnt,
      double &         splitExecVol)
   {
   bool        splitFound;
   WitRtCand * theRtCand;
d209 3
a211 2
   splitFound =
      myMrCoord_->myMrSelMgrForCons ()->findNextSplit (theRtCand, splitExecVol);
d213 2
a214 4
   if (splitFound)
      theConsEnt = theRtCand->myBillEnt ()->myConsEnt ();

   return splitFound;
d219 1
a219 1
void WitMrMgr::finishProdSplitExp ()
d221 1
a221 1
   myMrCoord_->myMrSelMgrForProd ()->finishSplitExp ();
d226 1
a226 1
void WitMrMgr::finishConsSplitExp ()
d228 1
a228 1
   myMrCoord_->myMrSelMgrForCons ()->finishSplitExp ();
a361 35
void WitMrSelMgr::startSplitExp (
      WitRtSite * theRtSite, 
      WitPeriod   thePer,
      double      expVol)
   {
   WitMrPt * theMrPt;

   witAssert (myMrCoord_->selIsSplit (theRtSite, thePer));

   theMrPt = myMrCoord_->myMrSiteFor (theRtSite)->myMrPt ()[thePer];

   startSplitExpAbs (theMrPt, expVol);
   }

//------------------------------------------------------------------------------

bool WitMrSelMgr::findNextSplit (WitRtCand * & theRtCand, double & splitExpVol)
   {
   WitSelCand * theSelCand;
   bool         splitFound;

   witAssert (selSplit ());

   splitFound = findNextSplitAbs (theSelCand, splitExpVol);

   theRtCand =
      splitFound?
         theSelCand->myMrCand ()->myRtCand ():
         NULL;

   return splitFound;
   }

//------------------------------------------------------------------------------

d379 1
a379 1
   recordFlowSS (theMrPt, incFlowVol);
@


1.14
log
@Continued implementation of proportionate routing.
@
text
@a15 3
//    MrSecMgr
//    PmrMgr
//    CmrMgr
d17 3
d24 1
a24 1
#include <MrSecMgr.h>
d153 1
a153 1
WitPmrMgr * WitMrMgr::myPmrMgr ()
d155 5
a159 1
   return myMrCoord_->myPmrMgr ();
d164 3
a166 1
WitCmrMgr * WitMrMgr::myCmrMgr ()
d168 5
a172 1
   return myMrCoord_->myCmrMgr ();
a175 2
// Implementation of class MrSecMgr.
//------------------------------------------------------------------------------
d177 4
a180 4
WitMrSecMgr::WitMrSecMgr (WitMrCoord * theMrCoord):

      WitSelMgr  (theMrCoord->mySelector ()),
      myMrCoord_ (theMrCoord)
d182 4
d190 4
a193 1
WitMrSecMgr::~WitMrSecMgr ()
d195 4
d203 1
a203 4
void WitMrSecMgr::startSplitExpMR (
      WitRtSite * theRtSite, 
      WitPeriod   thePer,
      double      expVol)
d205 2
a206 1
   WitMrPt * theMrPt;
d208 1
a208 1
   witAssert (myMrCoord_->selIsSplit (theRtSite, thePer));
d210 3
a212 3
   theMrPt = myMrCoord_->myMrSiteFor (theRtSite)->myMrPt ()[thePer];

   startSplitExpAbs (theMrPt, expVol);
d217 1
a217 3
bool WitMrSecMgr::findNextSplitMR (
      WitRtCand * & theRtCand,
      double &      splitExpVol)
d219 2
a220 2
   WitSelCand * theSelCand;
   bool         splitFound;
d222 2
a223 1
   witAssert (selSplit ());
d225 2
a226 6
   splitFound = findNextSplitAbs (theSelCand, splitExpVol);

   theRtCand =
      splitFound?
         theSelCand->myMrCand ()->myRtCand ():
         NULL;
d233 3
a235 4
void WitMrSecMgr::recExpRtSiteSS (
      WitRtSite * theRtSite,
      WitPeriod   thePer,
      double      incFlowVol)
d237 2
a238 2
   WitMrSite * theMrSite;
   WitMrPt *   theMrPt;
d240 2
a241 1
   witAssert (selSplit ());
d243 2
a244 1
   theMrSite = myMrCoord_->myMrSiteFor (theRtSite);
d246 2
a247 2
   if (not theMrSite->multiChoice ())
      return;
d249 1
a249 1
   theMrPt = theMrSite->myMrPt ()[thePer];
d251 3
a253 1
   recordFlowSS (theMrPt, incFlowVol);
d258 1
a258 1
bool WitMrSecMgr::selSplitNeeded ()
d260 1
a260 1
   return (myGlobalComp ()->selSplit ());
a263 2
// Implementation of class PmrMgr.
//------------------------------------------------------------------------------
d265 4
a268 3
WitPmrMgr::WitPmrMgr (WitMrCoord * theMrCoord):

      WitMrSecMgr (theMrCoord)
d270 4
d278 4
a281 1
WitPmrMgr::~WitPmrMgr ()
d283 4
d291 1
a291 1
WitBopEntry * WitPmrMgr::selBopEnt (WitPart * thePart, WitPeriod expPer)
d293 2
a294 1
   WitRtCand * theRtCand;
d296 1
a296 1
   theRtCand = myMrCoord ()->selRtCand (thePart->myRtSite (), expPer);
d298 3
a300 1
   return theRtCand->myBillEnt ()->myBopEnt ();
d304 4
d309 6
a314 4
void WitPmrMgr::startSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol)
d316 7
a322 1
   startSplitExpMR (thePart->myRtSite (), expPer, expVol);
d327 1
a327 1
bool WitPmrMgr::findNextSplit (WitBopEntry * & theBopEnt, double & splitExpVol)
d329 1
a329 2
   bool        splitFound;
   WitRtCand * theRtCand;
d331 1
a331 1
   splitFound = findNextSplitMR (theRtCand, splitExpVol);
d333 2
a334 2
   if (splitFound)
      theBopEnt = theRtCand->myBillEnt ()->myBopEnt ();
d336 2
a337 1
   return splitFound;
d342 1
a342 1
bool WitPmrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
d344 3
a346 1
   return myMrCoord ()->selIsSplit (thePart->myRtSite (), expPer);
d351 1
a351 4
void WitPmrMgr::recExpPartSS (
      WitPart * thePart,
      WitPeriod expPer,
      double    expVol)
d353 1
a353 1
   recExpRtSiteSS (thePart->myRtSite (), expPer, expVol);
d358 1
a358 5
WitSelPt * WitPmrMgr::mySelPtForAlt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
d360 1
a360 1
   WitPeriod expPer;
d362 1
a362 1
   expPer = theBopEnt->impactPeriod ()[execPer];
d364 1
a364 1
   return myMrCoord ()->mySelPtForAlt (theBopEnt->myRtCand (), expPer);
d369 1
a369 1
bool WitPmrMgr::validForNetting ()
d371 11
a381 1
   return true;
d385 2
d388 1
a388 1
bool WitPmrMgr::validForExecBounds ()
a389 1
   return true;
d394 4
a397 1
const char * WitPmrMgr::selCaseName ()
d399 1
a399 2
   return "Production Multi-Route";
   }
d401 1
a401 3
//------------------------------------------------------------------------------
// Implementation of class CmrMgr.
//------------------------------------------------------------------------------
d403 1
a403 1
WitCmrMgr::WitCmrMgr (WitMrCoord * theMrCoord):
d405 1
a405 2
      WitMrSecMgr (theMrCoord)
   {
d410 1
a410 1
WitCmrMgr::~WitCmrMgr ()
d412 13
d429 4
a432 3
WitConsEntry * WitCmrMgr::selConsEnt (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
d434 9
a442 1
   WitRtCand * theRtCand;
d444 1
a444 1
   theRtCand = myMrCoord ()->selRtCand (theBomEnt->myRtSite (), execPer);
d446 1
a446 1
   return theRtCand->myBillEnt ()->myConsEnt ();
d451 4
a454 4
void WitCmrMgr::startSplitExp (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer,
      double        execVolVal)
a455 1
   startSplitExpMR (theBomEnt->myRtSite (), execPer, execVolVal);
d460 1
a460 3
bool WitCmrMgr::findNextSplit (
      WitConsEntry * & theConsEnt,
      double &         splitExecVol)
d462 2
a463 2
   bool        splitFound;
   WitRtCand * theRtCand;
d465 3
a467 1
   splitFound = findNextSplitMR (theRtCand, splitExecVol);
d469 1
a469 2
   if (splitFound)
      theConsEnt = theRtCand->myBillEnt ()->myConsEnt ();
d471 2
a472 1
   return splitFound;
d477 1
a477 1
bool WitCmrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
a478 1
   return myMrCoord ()->selIsSplit (theBomEnt->myRtSite (), execPer);
d483 3
a485 2
void WitCmrMgr::recExpBomEntSS (
      WitBomEntry * theBomEnt,
d487 1
a487 1
      double        expVol)
d489 1
a489 2
   recExpRtSiteSS (theBomEnt->myRtSite (), execPer, expVol);
   }
d491 1
a491 1
//------------------------------------------------------------------------------
d493 1
a493 7
WitSelPt * WitCmrMgr::mySelPtForAlt (
      WitBopEntry *,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod)
   {
   return myMrCoord ()->mySelPtForAlt (theConsEnt->myRtCand (), execPer);
d498 1
a498 1
bool WitCmrMgr::validForNetting ()
d500 1
a500 1
   return false;
d505 1
a505 1
bool WitCmrMgr::validForExecBounds ()
d507 1
a507 1
   return false;
d512 1
a512 1
const char * WitCmrMgr::selCaseName ()
d514 1
a514 1
   return "Consumption Multi-Route";
d518 1
a518 1
// Implementation of class MrCoord.
d521 1
a521 1
WitMrCoord::WitMrCoord (WitSelector * theSelector):
d523 1
a523 6
      WitProbAssoc (theSelector->myProblem ()),
      myPmrMgr_    (NULL),
      myCmrMgr_    (NULL),
      myMrSiteFor_ (myProblem ()),
      myMrCandFor_ (myProblem ()),
      mySelector_  (theSelector)
a524 7
   WitRtSite * theRtSite;

   myPmrMgr_ = new WitPmrMgr (this);
   myCmrMgr_ = new WitCmrMgr (this);

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      myMrSiteFor_ (theRtSite) = new WitMrSite (theRtSite, this);
d529 1
a529 1
WitMrCoord::~WitMrCoord ()
a530 9
   WitRtSite * theRtSite;

   myMrCandFor_.clear ();

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      delete myMrSiteFor_ (theRtSite);

   delete myCmrMgr_;
   delete myPmrMgr_;
d535 5
a539 1
void WitMrCoord::store (WitMrCand * theMrCand)
d541 1
a541 3
   witAssert (myMrCandFor_ (theMrCand->myRtCand ()) == NULL);

   myMrCandFor_ (theMrCand->myRtCand ()) = theMrCand;
d546 1
a546 1
WitRtCand * WitMrCoord::selRtCand (WitRtSite * theRtSite, WitPeriod thePer)
d548 1
a548 1
   return myMrSiteFor_ (theRtSite)->selMrCand (thePer)->myRtCand ();
d553 1
a553 1
WitSelPt * WitMrCoord::mySelPtForAlt (WitRtCand * theRtCand, WitPeriod thePer)
d555 1
a555 5
   WitMrSite * theMrSite;

   theMrSite = myMrSiteFor_ (theRtCand->myRtSite ());

   return theMrSite->myMrPtWithAlt (thePer);
d560 1
a560 1
bool WitMrCoord::selIsSplit (WitRtSite * theRtSite, WitPeriod thePer)
d562 1
a562 11
   WitMrSite * theMrSite;

   if (not mySelector_->selSplit ())
      return false;

   theMrSite = myMrSiteFor_ (theRtSite);

   if (not theMrSite->multiChoice ())
      return false;

   return theMrSite->myMrPt ()[thePer]->isSplit ();
@


1.13
log
@Continued implementation of proportionate routing.
@
text
@a103 19
void WitMrMgr::modifyRouting (WitRtCandPerStack & theRtCandPers)
   {
   WitRtCand * theRtCand;
   WitPeriod   thePer;
   WitMrSite * theMrSite;
   WitMrPt *   theMrPt;

   while (theRtCandPers.pop (theRtCand, thePer))
      {
      theMrSite = myMrCoord_->myMrSiteFor (theRtCand->myRtSite ());

      theMrPt   = theMrSite->myMrPt ()[thePer];

      theMrPt->select (myMrCoord_->myMrCandFor (theRtCand));
      }
   }

//------------------------------------------------------------------------------

@


1.12
log
@Continued implementation of propotionate routing.
@
text
@a15 1
//    MrCoord
d19 1
d77 27
a129 16
void WitMrMgr::getRtCands (WitRtSite * theRtSite, WitRtCandStack & theRtCands)
   {
   WitMrCandItr theMrCandItr;

   theRtCands.clear ();

   theMrCandItr.attachTo (myMrCoord_->myMrSiteFor (theRtSite)->myMrCands ());

   while (theMrCandItr.advance ())
      theRtCands.push (theMrCandItr->myRtCand ());

   theRtCands.reverse ();
   }

//------------------------------------------------------------------------------

a171 14
void WitMrMgr::findExpRtCands (
      WitRtSite *      theRtSite,
      WitPeriod        thePer,
      WitRtCandStack & theRtCands)
   {
   WitMrSite * theMrSite;

   theMrSite = myMrCoord_->myMrSiteFor (theRtSite);

   theMrSite->findExpRtCands (thePer, theRtCands);
   }

//------------------------------------------------------------------------------

a184 81
// Implementation of class MrCoord.
//------------------------------------------------------------------------------

WitMrCoord::WitMrCoord (WitSelector * theSelector):

      WitProbAssoc (theSelector->myProblem ()),
      myPmrMgr_    (NULL),
      myCmrMgr_    (NULL),
      myMrSiteFor_ (myProblem ()),
      myMrCandFor_ (myProblem ()),
      mySelector_  (theSelector)
   {
   WitRtSite * theRtSite;

   myPmrMgr_ = new WitPmrMgr (this);
   myCmrMgr_ = new WitCmrMgr (this);

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      myMrSiteFor_ (theRtSite) = new WitMrSite (theRtSite, this);
   }

//------------------------------------------------------------------------------

WitMrCoord::~WitMrCoord ()
   {
   WitRtSite * theRtSite;

   myMrCandFor_.clear ();

   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
      delete myMrSiteFor_ (theRtSite);

   delete myCmrMgr_;
   delete myPmrMgr_;
   }

//------------------------------------------------------------------------------

void WitMrCoord::store (WitMrCand * theMrCand)
   {
   witAssert (myMrCandFor_ (theMrCand->myRtCand ()) == NULL);

   myMrCandFor_ (theMrCand->myRtCand ()) = theMrCand;
   }

//------------------------------------------------------------------------------

WitRtCand * WitMrCoord::selRtCand (WitRtSite * theRtSite, WitPeriod thePer)
   {
   return myMrSiteFor_ (theRtSite)->selMrCand (thePer)->myRtCand ();
   }

//------------------------------------------------------------------------------

WitSelPt * WitMrCoord::mySelPtForAlt (WitRtCand * theRtCand, WitPeriod thePer)
   {
   WitMrSite * theMrSite;

   theMrSite = myMrSiteFor_ (theRtCand->myRtSite ());

   return theMrSite->myMrPtWithAlt (thePer);
   }

//------------------------------------------------------------------------------

bool WitMrCoord::selIsSplit (WitRtSite * theRtSite, WitPeriod thePer)
   {
   WitMrSite * theMrSite;

   if (not mySelector_->selSplit ())
      return false;

   theMrSite = myMrSiteFor_ (theRtSite);

   if (not theMrSite->multiChoice ())
      return false;

   return theMrSite->myMrPt ()[thePer]->isSplit ();
   }

//------------------------------------------------------------------------------
d475 81
@


1.11
log
@Continued implementation of proportionate routing.
@
text
@d17 3
a19 3
//    MrSelMgr
//    PmrSelMgr
//    CmrSelMgr
d24 1
a24 1
#include <MrSelMgr.h>
d175 1
a175 1
WitPmrSelMgr * WitMrMgr::myPmrSelMgr ()
d177 1
a177 1
   return myMrCoord_->myPmrSelMgr ();
d182 1
a182 1
WitCmrSelMgr * WitMrMgr::myCmrSelMgr ()
d184 1
a184 1
   return myMrCoord_->myCmrSelMgr ();
d194 2
a195 2
      myPmrSelMgr_ (NULL),
      myCmrSelMgr_ (NULL),
d202 2
a203 2
   myPmrSelMgr_ = new WitPmrSelMgr (this);
   myCmrSelMgr_ = new WitCmrSelMgr (this);
d220 2
a221 2
   delete myCmrSelMgr_;
   delete myPmrSelMgr_;
d269 1
a269 1
// Implementation of class MrSelMgr.
d272 1
a272 1
WitMrSelMgr::WitMrSelMgr (WitMrCoord * theMrCoord):
d281 1
a281 1
WitMrSelMgr::~WitMrSelMgr ()
d287 1
a287 1
void WitMrSelMgr::startSplitExpMR (
d303 1
a303 1
bool WitMrSelMgr::findNextSplitMR (
d324 1
a324 1
void WitMrSelMgr::recExpRtSiteSS (
d346 1
a346 1
bool WitMrSelMgr::selSplitNeeded ()
d352 1
a352 1
// Implementation of class PmrSelMgr.
d355 1
a355 1
WitPmrSelMgr::WitPmrSelMgr (WitMrCoord * theMrCoord):
d357 1
a357 1
      WitMrSelMgr (theMrCoord)
d363 1
a363 1
WitPmrSelMgr::~WitPmrSelMgr ()
d369 1
a369 1
WitBopEntry * WitPmrSelMgr::selBopEnt (WitPart * thePart, WitPeriod expPer)
d380 1
a380 1
void WitPmrSelMgr::startSplitExp (
d390 1
a390 3
bool WitPmrSelMgr::findNextSplit (
      WitBopEntry * & theBopEnt,
      double &        splitExpVol)
d405 1
a405 1
bool WitPmrSelMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
d412 1
a412 1
void WitPmrSelMgr::recExpPartSS (
d422 1
a422 1
WitSelPt * WitPmrSelMgr::mySelPtForAlt (
d437 1
a437 1
bool WitPmrSelMgr::validForNetting ()
d444 1
a444 1
bool WitPmrSelMgr::validForExecBounds ()
d451 1
a451 1
const char * WitPmrSelMgr::selCaseName ()
d457 1
a457 1
// Implementation of class CmrSelMgr.
d460 1
a460 1
WitCmrSelMgr::WitCmrSelMgr (WitMrCoord * theMrCoord):
d462 1
a462 1
      WitMrSelMgr (theMrCoord)
d468 1
a468 1
WitCmrSelMgr::~WitCmrSelMgr ()
d474 1
a474 1
WitConsEntry * WitCmrSelMgr::selConsEnt (
d487 1
a487 1
void WitCmrSelMgr::startSplitExp (
d497 1
a497 1
bool WitCmrSelMgr::findNextSplit (
d514 1
a514 1
bool WitCmrSelMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
d521 1
a521 1
void WitCmrSelMgr::recExpBomEntSS (
d531 1
a531 1
WitSelPt * WitCmrSelMgr::mySelPtForAlt (
d542 1
a542 1
bool WitCmrSelMgr::validForNetting ()
d549 1
a549 1
bool WitCmrSelMgr::validForExecBounds ()
d556 1
a556 1
const char * WitCmrSelMgr::selCaseName ()
@


1.10
log
@Continued implementation of proportionate routing.
@
text
@d103 1
a103 3
void WitMrMgr::getRtCands (
      WitRtSite *               theRtSite,
      WitObjStack <WitRtCand> & theRtCands)
d161 14
d200 1
a200 2
   WitPart *     thePart;
   WitBomEntry * theBomEnt;
d205 2
a206 7
   forEachPart (thePart, myProblem ())
      myMrSiteFor_ (thePart->myRtSite ()) =
         new WitMrSite (thePart->myRtSite (), this);

   forEachBomEntry (theBomEnt, myProblem ())
      myMrSiteFor_ (theBomEnt->myRtSite ()) =
         new WitMrSite (theBomEnt->myRtSite (), this);
a379 21
void WitPmrSelMgr::findExpBopEnts (
      WitPart *        thePart,
      WitPeriod        expPer,
      WitBopEntStack & theBopEnts)
   {
   WitObjStack <WitMrCand> theMrCands (myProblem ());
   WitMrSite *             theMrSite;
   WitMrCand *             theMrCand;

   theMrSite = myMrCoord ()->myMrSiteFor (thePart->myRtSite ());

   theMrSite->findExpMrCands (expPer, theMrCands);

   theBopEnts.clear ();

   while (theMrCands.pop (theMrCand))
      theBopEnts.push (theMrCand->myRtCand ()->myBillEnt ()->myBopEnt ());
   }

//------------------------------------------------------------------------------

a484 21
   }

//------------------------------------------------------------------------------

void WitCmrSelMgr::findExpConsEnts (
      WitBomEntry *     theBomEnt,
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   WitObjStack <WitMrCand> theMrCands (myProblem ());
   WitMrSite *             theMrSite;
   WitMrCand *             theMrCand;

   theMrSite = myMrCoord ()->myMrSiteFor (theBomEnt->myRtSite ());

   theMrSite->findExpMrCands (execPer, theMrCands);

   theConsEnts.clear ();

   while (theMrCands.pop (theMrCand))
      theConsEnts.push (theMrCand->myRtCand ()->myBillEnt ()->myConsEnt ());
@


1.9
log
@Continued implementation of proportionate routing.
@
text
@a95 18
void WitMrMgr::findRtCands (
      WitRtSite *      theRtSite,
      WitPeriod        thePer,
      WitRtCandStack & theRtCands)
   {
   WitObjStack <WitMrCand> theMrCands (myProblem ());
   WitMrCand *             theMrCand;

   myMrCoord_->myMrSiteFor (theRtSite)->findMrCands (thePer, theMrCands);

   theRtCands.clear ();

   while (theMrCands.pop (theMrCand))
      theRtCands.push (theMrCand->myRtCand ());
   }

//------------------------------------------------------------------------------

d374 21
d500 21
@


1.8
log
@Continued implementation of proportionate routing.
@
text
@d16 4
a19 3
//    SpecMrMgr <MrArgs>
//    PmrMgr
//    CmrMgr
d23 2
d27 1
d29 2
d44 4
a47 1
bool WitMrMgr::selSplitNeeded ()
d49 3
a51 1
   return (myGlobalComp ()->selSplit ());
d56 1
a56 2
WitMrMgr::WitMrMgr (WitSelector * theSelector):
      WitSelMgr (theSelector)
d58 1
d63 1
a63 1
WitMrMgr::~WitMrMgr ()
d65 1
d70 1
a70 4
void WitMrMgr::recordFlowSS (
      WitMrSite * theMrSite,
      WitPeriod   thePer,
      double      incFlowVol)
d72 4
a75 1
   WitMrPt * theMrPt;
d77 6
a82 1
   witAssert (selSplit ());
d84 3
a86 2
   if (not theMrSite->multiChoice ())
      return;
d88 1
a88 1
   theMrPt = theMrSite->myMrPt ()[thePer];
d90 2
a91 1
   WitSelMgr::recordFlowSS (theMrPt, incFlowVol);
d96 4
a99 1
bool WitMrMgr::selIsSplit (WitMrSite * theMrSite, WitPeriod thePer)
d101 4
a104 2
   if (not selSplit ())
      return false;
d106 1
a106 2
   if (not theMrSite->multiChoice ())
      return false;
d108 2
a109 1
   return theMrSite->myMrPt ()[thePer]->isSplit ();
a112 2
// Global functions used by class template SpecMrMgr <MrArgs>.
//------------------------------------------------------------------------------
d114 1
a114 1
inline WitPart * theSelCompFor (WitBopEntry * theBopEnt)
d116 1
a116 1
   return theBopEnt->myPart ();
d121 3
a123 1
inline WitBomEntry * theSelCompFor (WitConsEntry * theConsEnt)
d125 3
a127 2
   return theConsEnt->myBomEnt ();
   }
d129 1
a129 3
//------------------------------------------------------------------------------
// Implementation of class template SpecMrMgr <MrArgs>.
//------------------------------------------------------------------------------
d131 2
a132 3
template <MrArgDecs>
      WitSpecMrMgr <MrArgs>::WitSpecMrMgr (WitSelector * theSelector):
         WitMrMgr     (theSelector),
d134 1
a134 3
         myMrSiteFor_ (myProblem ()),
         myMrCandFor_ (myProblem ())
   {
d139 1
a139 2
template <MrArgDecs>
      WitSpecMrMgr <MrArgs>::~WitSpecMrMgr ()
d141 1
d146 1
a146 4
template <MrArgDecs>
      CandComp * WitSpecMrMgr <MrArgs>::selCandComp (
         SelComp * theSelComp,
         WitPeriod thePer)
d148 1
a148 1
   CandComp * theCandComp;
d150 1
a150 1
   myMrSiteFor_ (theSelComp)->selMrCand (thePer)->getMyComp (theCandComp);
d152 1
a152 1
   return theCandComp;
d157 1
a157 3
template <MrArgDecs>
      void WitSpecMrMgr <MrArgs>::modifyRouting (
         WitPairStack <CandComp, WitPeriod> & theCandCompPers)
d159 1
a159 13
   CandComp *  theCandComp;
   WitPeriod   thePer;
   WitMrSite * theMrSite;
   WitMrPt *   theMrPt;

   while (theCandCompPers.pop (theCandComp, thePer))
      {
      theMrSite = myMrSiteFor_ (theSelCompFor (theCandComp));

      theMrPt   = theMrSite->myMrPt ()[thePer];

      theMrPt->select (myMrCandFor_ (theCandComp));
      }
d164 1
a164 5
template <MrArgDecs>
      void WitSpecMrMgr <MrArgs>::findCandComps (
         SelComp *                theSelComp, 
         WitPeriod                thePer,
         WitObjStack <CandComp> & theCandComps)
d166 1
a166 4
   WitObjStack <WitMrCand> theMrCands (myProblem ());
   WitMrCandItr            theItr;
   WitMrCand *             theMrCand;
   CandComp *              theCandComp;
d168 4
a171 1
   myMrSiteFor_ (theSelComp)->findMrCands (thePer, theMrCands);
d173 2
a174 1
   theCandComps.clear ();
d176 1
a176 8
   theItr.attachTo (theMrCands);

   while (theItr.advance (theMrCand))
      {
      theMrCand->getMyComp (theCandComp);

      theCandComps.push (theCandComp);
      }
d181 1
a181 4
template <MrArgDecs>
      void WitSpecMrMgr <MrArgs>::select (
         CandComp * theCandComp, 
         WitPeriod  thePer)
d183 1
a183 5
   WitMrPt * theMrPt;

   theMrPt = myMrSiteFor_ (theSelCompFor (theCandComp))->myMrPt ()[thePer];

   theMrPt->select (myMrCandFor_ (theCandComp));
d188 1
a188 4
template <MrArgDecs>
      void WitSpecMrMgr <MrArgs>::getCandComps (
         SelComp *                theSelComp,
         WitObjStack <CandComp> & theCandComps)
d190 2
a191 3
   WitMrCandItr theItr;
   WitMrCand *  theMrCand;
   CandComp *   theCandComp;
d193 3
a195 1
   theCandComps.clear ();
d197 1
a197 1
   theItr.attachTo (myMrSiteFor_ (theSelComp)->myMrCands ());
d199 9
a207 3
   while (theItr.advance (theMrCand))
      {
      theMrCand->getMyComp (theCandComp);
d209 2
a210 2
      theCandComps.push (theCandComp);
      }
d212 3
a214 2
   theCandComps.reverse ();
   }
d216 3
a218 8
//------------------------------------------------------------------------------

template <MrArgDecs>
      bool WitSpecMrMgr <MrArgs>::selIsSplit (
         SelComp * theSelComp, 
         WitPeriod thePer)
   {
   return WitMrMgr::selIsSplit (myMrSiteFor_ (theSelComp), thePer);
d223 1
a223 5
template <MrArgDecs>
      void WitSpecMrMgr <MrArgs>::startSplitExp (
         SelComp * theSelComp, 
         WitPeriod thePer,
         double    expVol)
d225 1
a225 1
   WitMrPt * theMrPt;
d227 1
a227 1
   witAssert (selIsSplit (theSelComp, thePer));
d229 2
a230 1
   theMrPt = myMrSiteFor_ (theSelComp)->myMrPt ()[thePer];
d232 2
a233 1
   startSplitExpAbs (theMrPt, expVol);
d238 1
a238 4
template <MrArgDecs>
      bool WitSpecMrMgr <MrArgs>::findNextSplit (
         CandComp * & theCandComp, 
         double &     splitExpVol)
d240 1
a240 2
   WitSelCand * theSelCand;
   bool         splitFound;
d242 2
a243 3
   witAssert (selSplit ());

   splitFound = findNextSplitAbs (theSelCand, splitExpVol);
a244 8
   if (splitFound)
      theSelCand->myMrCand ()->getMyComp (theCandComp);
   else
      theCandComp = NULL;

   return splitFound;
   }
 
d247 1
a247 5
template <MrArgDecs>
      void WitSpecMrMgr <MrArgs>::recordFlowSS (
         SelComp * theSelComp, 
         WitPeriod thePer,
         double    incFlowVol)
d249 1
a249 1
   WitMrMgr::recordFlowSS (myMrSiteFor_ (theSelComp), thePer, incFlowVol);
d254 1
a254 4
template <MrArgDecs>
      void WitSpecMrMgr <MrArgs>::storeMrSiteFor (
         SelComp *   theSelComp,
         WitMrSite * theMrSite)
d256 1
a256 1
   witAssert (myMrSiteFor_ (theSelComp) == NULL);
d258 3
a260 1
   myMrSiteFor_ (theSelComp) = theMrSite;
d265 1
a265 2
template <MrArgDecs>
      void WitSpecMrMgr <MrArgs>::store (WitMrCand * theMrCand)
d267 1
a267 1
   CandComp * theCandComp;
d269 4
a272 1
   theMrCand->getMyComp (theCandComp);
d274 2
a275 1
   witAssert (myMrCandFor_ (theCandComp) == NULL);
d277 1
a277 1
   myMrCandFor_ (theCandComp) = theMrCand;
d281 4
d286 2
a287 2
template <>
      WitBopEntry * WitSpecMrMgr <Pmr>::theCompFor (WitMrCand * theMrCand)
d289 1
a289 1
   WitBopEntry * theBopEnt;
d291 1
a291 1
   theMrCand->myRtCand ()->myBillEnt ()->getBopEntry (theBopEnt);
d293 2
a294 3
   witAssert (theBopEnt != NULL);

   return theBopEnt;
d299 4
a302 2
template <>
      WitConsEntry * WitSpecMrMgr <Cmr>::theCompFor (WitMrCand * theMrCand)
d304 1
a304 1
   WitConsEntry * theConsEnt;
d306 1
a306 1
   theMrCand->myRtCand ()->myBillEnt ()->getConsEntry (theConsEnt);
d308 1
a308 1
   witAssert (theConsEnt != NULL);
d310 1
a310 1
   return theConsEnt;
a313 2
// Implementation of class PmrMgr.
//------------------------------------------------------------------------------
d315 3
a317 2
WitPmrMgr::WitPmrMgr (WitSelector * theSelector):
      WitSpecMrMgr <Pmr> (theSelector)
d319 4
a322 2
   myMsgFac () ("multiRouteMsg");
   }
d324 1
a324 1
//------------------------------------------------------------------------------
d326 4
a329 3
WitPmrMgr::~WitPmrMgr ()
   {
   WitPart * thePart;
d331 1
a331 2
   forEachPart (thePart, myProblem ())
      delete myMrSiteFor (thePart);
d336 4
a339 1
void WitPmrMgr::setUp ()
d341 2
a342 1
   WitPart * thePart;
d344 1
a344 3
   forEachPart (thePart, myProblem ())
      storeMrSiteFor (thePart, new WitPmrSite (thePart, this));
   }
d346 1
a346 1
//------------------------------------------------------------------------------
d348 2
a349 4
WitBopEntry * WitPmrMgr::selBopEntry (WitPart * thePart, WitPeriod expPer)
   {
   return selCandComp (thePart, expPer);
   }
d351 1
a351 1
//------------------------------------------------------------------------------
d353 1
a353 3
void WitPmrMgr::modifyRouting (WitBopEntPerStack & theBopEntPers)
   {
   WitSpecMrMgr <Pmr>::modifyRouting (theBopEntPers);
d358 1
a358 4
void WitPmrMgr::findExpBopEnts (
      WitPart *        thePart, 
      WitPeriod        expPer,
      WitBopEntStack & theBopEnts)
d360 1
a360 1
   WitSpecMrMgr <Pmr>::findCandComps (thePart, expPer, theBopEnts);
d364 4
d369 1
a369 1
bool WitPmrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
a370 1
   return WitSpecMrMgr <Pmr>::selIsSplit (thePart, expPer);
d375 1
a375 4
void WitPmrMgr::startSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol)
a376 1
   WitSpecMrMgr <Pmr>::startSplitExp (thePart, expPer, expVol);
d381 1
a381 3
bool WitPmrMgr::findNextSplit (
      WitBopEntry * & theBopEnt, 
      double &        splitExpVol)
d383 1
a383 4
   return WitSpecMrMgr <Pmr>::findNextSplit (theBopEnt, splitExpVol);
   }
 
//------------------------------------------------------------------------------
d385 1
a385 6
void WitPmrMgr::getCandBopEnts (WitPart * thePart, WitBopEntStack & theBopEnts)
   {
   getCandComps (thePart, theBopEnts);
   }

//------------------------------------------------------------------------------
d387 1
a387 3
bool WitPmrMgr::valid (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   return myMrCandFor (theBopEnt)->valid (expPer);
d392 1
a392 1
void WitPmrMgr::recPartExpPerSS (
d394 1
a394 1
      WitPeriod expPer, 
d397 1
a397 1
   recordFlowSS (thePart, expPer, expVol);
d402 3
a404 1
void WitPmrMgr::printHasAlt ()
d406 2
a407 1
   WitPart * thePart;
d409 1
a409 4
   fprintf (msgFile (),
      "\n"
      "\n"
      "Production Multi-Route Selection Points with Alternative(s):\n\n");
d411 2
a412 2
   forEachPart (thePart, myProblem ())
      myMrSiteFor (thePart)->printHasAlt ();
d414 1
a414 1
   fprintf (msgFile (), "\n");
d419 1
a419 1
WitSelPt * WitPmrMgr::mySelPt (WitPart * thePart, WitPeriod thePer)
d421 1
a421 1
   return myMrSiteFor (thePart)->myMrPt ()[thePer];
d426 4
a429 1
void WitPmrMgr::select (WitBopEntry * theBopEnt, WitPeriod expPer)
d431 1
a431 1
   WitSpecMrMgr <Pmr>::select (theBopEnt, expPer);
d436 1
a436 8
bool WitPmrMgr::multiChoice (WitPart * thePart)
   {
   return myMrSiteFor (thePart)->multiChoice ();
   }

//------------------------------------------------------------------------------

WitSelPt * WitPmrMgr::mySelPtForAlt (
a441 1
   WitPart * thePart;
d444 1
a444 3
   thePart = theBopEnt->myPart ();

   expPer  = theBopEnt->impactPeriod ()[execPer];
d446 1
a446 1
   return myMrSiteFor (thePart)->myMrPtWithAlt (expPer);
d451 1
a451 1
bool WitPmrMgr::validForNetting ()
d458 1
a458 1
bool WitPmrMgr::validForExecBounds ()
d465 1
a465 1
const char * WitPmrMgr::selCaseName ()
d471 1
a471 1
// Implementation of class CmrMgr.
d474 1
a474 6
WitCmrMgr::WitCmrMgr (WitSelector * theSelector):
      WitSpecMrMgr <Cmr> (theSelector)
   {
   }

//------------------------------------------------------------------------------
d476 1
a476 1
WitCmrMgr::~WitCmrMgr ()
a477 4
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      delete myMrSiteFor (theBomEnt);
d482 1
a482 1
void WitCmrMgr::setUp ()
a483 4
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      storeMrSiteFor (theBomEnt, new WitCmrSite (theBomEnt, this));
d488 2
a489 2
WitConsEntry * WitCmrMgr::selConsEntry (
      WitBomEntry * theBomEnt, 
d492 1
a492 19
   return selCandComp (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::modifyRouting (WitConsEntPerStack & theConsEntPers)
   {
   WitSpecMrMgr <Cmr>::modifyRouting (theConsEntPers);
   }

//------------------------------------------------------------------------------

void WitCmrMgr::findExpConsEnts (
      WitBomEntry *     theBomEnt, 
      WitPeriod         execPer,
      WitConsEntStack & theConsEnts)
   {
   findCandComps (theBomEnt, execPer, theConsEnts);
   }
d494 1
a494 1
//------------------------------------------------------------------------------
d496 1
a496 3
bool WitCmrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   return WitSpecMrMgr <Cmr>::selIsSplit (theBomEnt, execPer);
d501 1
a501 1
void WitCmrMgr::startSplitExp (
d504 1
a504 1
      double        expVol)
d506 1
a506 1
   WitSpecMrMgr <Cmr>::startSplitExp (theBomEnt, execPer, expVol);
d511 3
a513 3
bool WitCmrMgr::findNextSplit (
      WitConsEntry * & theConsEnt, 
      double &         splitExpVol)
d515 2
a516 4
   return WitSpecMrMgr <Cmr>::findNextSplit (theConsEnt, splitExpVol);
   }
 
//------------------------------------------------------------------------------
d518 1
a518 6
void WitCmrMgr::getCandConsEnts (
      WitBomEntry *     theBomEnt,
      WitConsEntStack & theConsEnts)
   {
   getCandComps (theBomEnt, theConsEnts);
   }
d520 2
a521 1
//------------------------------------------------------------------------------
d523 1
a523 3
bool WitCmrMgr::valid (WitConsEntry * theConsEnt, WitPeriod execPer)
   {
   return myMrCandFor (theConsEnt)->valid (execPer);
d528 1
a528 4
void WitCmrMgr::recExpBomEntSS (
      WitBomEntry * theBomsEnt, 
      WitPeriod     execPer, 
      double        deltaExecVol)
d530 1
a530 1
   recordFlowSS (theBomsEnt, execPer, deltaExecVol);
d535 4
a538 17
void WitCmrMgr::printHasAlt ()
   {
   WitBomEntry * theBomEnt;

   fprintf (msgFile (),
      "\n"
      "Consumption Multi-Route Selection Points with Alternative(s):\n\n");

   forEachBomEntry (theBomEnt, myProblem ())
      myMrSiteFor (theBomEnt)->printHasAlt ();

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

WitSelPt * WitCmrMgr::mySelPt (WitBomEntry * theBomEnt, WitPeriod thePer)
d540 1
a540 1
   return myMrSiteFor (theBomEnt)->myMrPt ()[thePer];
d545 1
a545 15
void WitCmrMgr::select (WitConsEntry * theConsEnt, WitPeriod execPer)
   {
   WitSpecMrMgr <Cmr>::select (theConsEnt, execPer);
   }

//------------------------------------------------------------------------------

bool WitCmrMgr::multiChoice (WitBomEntry * theBomEnt)
   {
   return myMrSiteFor (theBomEnt)->multiChoice ();
   }

//------------------------------------------------------------------------------

WitSelPt * WitCmrMgr::mySelPtForAlt (
d551 1
a551 5
   WitBomEntry * theBomEnt;

   theBomEnt = theConsEnt->myBomEnt ();

   return myMrSiteFor (theBomEnt)->myMrPtWithAlt (execPer);
d556 1
a556 1
bool WitCmrMgr::validForNetting ()
d563 1
a563 1
bool WitCmrMgr::validForExecBounds ()
d570 1
a570 1
const char * WitCmrMgr::selCaseName ()
@


1.7
log
@Continued implementation of proportionate routing.
@
text
@d25 1
d312 28
d489 1
d492 3
a494 1
   expPer = theBopEnt->impactPeriod ()[execPer];
d496 1
a496 1
   return myMrSiteFor (theBopEnt->myPart ())->myMrPtWithAlt (expPer);
d672 5
a676 1
   return myMrSiteFor (theConsEnt->myBomEnt ())->myMrPtWithAlt (execPer);
@


1.6
log
@Continued implementation of proportionate routing.
@
text
@a405 7
bool WitPmrMgr::instNeededFor (WitProblem * theProblem)
   {
   return theProblem->myGlobalComp ()->multiRoute ();
   }

//------------------------------------------------------------------------------

a582 7
   }

//------------------------------------------------------------------------------

bool WitCmrMgr::instNeededFor (WitProblem * theProblem)
   {
   return theProblem->myGlobalComp ()->multiRoute ();
@


1.5
log
@Continued implementation of Proportionate Routing.
@
text
@d461 1
a461 1
WitSelPt * WitPmrMgr::mySelPt (
d648 1
a648 1
WitSelPt * WitCmrMgr::mySelPt (
@


1.4
log
@Internal changes.
@
text
@d406 7
d590 7
@


1.3
log
@Internal changes.
@
text
@d66 1
a66 1
   if (! theMrSite->multiChoice ())
d78 1
a78 1
   if (! selSplit ())
d81 1
a81 1
   if (! theMrSite->multiChoice ())
@


1.2
log
@Continued implementation of single-source with the new algorithm.
@
text
@d37 1
a37 1
WitBoolean WitMrMgr::selSplitNeeded ()
d76 1
a76 1
WitBoolean WitMrMgr::selIsSplit (WitMrSite * theMrSite, WitPeriod thePer)
d79 1
a79 1
      return witFALSE;
d82 1
a82 1
      return witFALSE;
d227 1
a227 1
      WitBoolean WitSpecMrMgr <MrArgs>::selIsSplit (
d254 1
a254 1
      WitBoolean WitSpecMrMgr <MrArgs>::findNextSplit (
d259 1
a259 1
   WitBoolean   splitFound;
d366 1
a366 1
WitBoolean WitPmrMgr::selIsSplit (WitPart * thePart, WitPeriod expPer)
d383 1
a383 1
WitBoolean WitPmrMgr::findNextSplit (
d399 1
a399 1
WitBoolean WitPmrMgr::valid (WitBopEntry * theBopEnt, WitPeriod expPer)
d447 1
a447 1
WitBoolean WitPmrMgr::multiChoice (WitPart * thePart)
d469 1
a469 1
WitBoolean WitPmrMgr::validForNetting ()
d471 1
a471 1
   return witTRUE;
d476 1
a476 1
WitBoolean WitPmrMgr::validForExecBounds ()
d478 1
a478 1
   return witTRUE;
d545 1
a545 1
WitBoolean WitCmrMgr::selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer)
d562 1
a562 1
WitBoolean WitCmrMgr::findNextSplit (
d580 1
a580 1
WitBoolean WitCmrMgr::valid (WitConsEntry * theConsEnt, WitPeriod execPer)
d627 1
a627 1
WitBoolean WitCmrMgr::multiChoice (WitBomEntry * theBomEnt)
d645 1
a645 1
WitBoolean WitCmrMgr::validForNetting ()
d647 1
a647 1
   return witFALSE;
d652 1
a652 1
WitBoolean WitCmrMgr::validForExecBounds ()
d654 1
a654 1
   return witFALSE;
@


1.1
log
@Began implementation of multi-level lot sizes.
@
text
@d447 7
d623 7
@


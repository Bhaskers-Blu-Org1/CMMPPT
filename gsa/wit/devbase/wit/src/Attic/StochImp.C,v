head	1.114;
access;
symbols;
locks; strict;
comment	@ * @;


1.114
date	2007.08.07.19.17.44;	author rjw;	state dead;
branches;
next	1.113;

1.113
date	2007.08.07.17.35.36;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2007.08.03.22.04.11;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2007.08.02.20.46.56;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2007.08.02.19.39.47;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2007.08.01.22.41.58;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2007.08.01.21.28.06;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2007.08.01.18.56.02;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2007.07.31.23.18.26;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2007.07.31.22.22.33;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.07.24.22.17.32;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.06.22.21.23.56;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.06.21.22.05.19;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.06.12.21.56.45;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.06.11.21.54.57;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.06.11.21.04.27;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.06.08.23.17.58;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.06.08.22.47.02;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.08.21.54.42;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.08.18.26.10;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.08.18.09.40;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.04.19.34.01;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.31.14.13.47;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.25.23.26.52;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.25.20.55.51;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.05.24.21.57.10;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.24.18.52.22;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.05.23.22.32.29;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.23.21.42.06;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.05.23.15.33.52;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.05.22.21.55.36;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.05.22.20.44.26;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.05.22.16.06.27;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.05.22.15.46.53;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.05.21.18.18.46;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.05.21.15.31.46;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.05.21.15.20.10;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.18.23.16.08;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.18.21.51.42;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.18.21.20.50;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.17.22.11.46;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.17.18.45.37;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.17.18.37.04;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.17.17.59.18;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.16.22.16.46;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.15.20.28.49;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.15.19.45.43;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.14.20.25.17;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.14.19.48.41;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.11.22.49.32;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.04.23.27.11;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.04.19.33.46;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.04.14.41.50;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.03.20.05.15;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.02.23.11.05;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.02.21.03.52;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.30.21.52.09;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.30.21.34.59;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.30.19.32.31;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.27.21.53.44;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.27.21.02.02;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.27.19.32.46;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.26.22.35.18;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.26.21.32.27;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.04.26.20.45.31;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.04.25.23.30.30;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.24.22.40.57;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.24.21.18.13;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.24.20.07.50;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.04.23.21.54.54;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.23.21.03.20;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.23.20.20.00;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.20.23.31.46;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.20.21.57.33;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.20.20.51.14;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.20.19.44.49;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.19.22.03.27;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.19.21.38.44;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.19.20.22.30;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.19.14.52.49;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.18.23.09.41;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.18.22.27.02;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.18.21.18.20;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.17.22.08.31;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.17.21.27.10;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.16.22.52.05;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.16.22.21.42;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.16.21.32.58;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.16.20.12.55;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.13.22.56.25;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.13.20.24.22;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.13.20.07.58;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.13.18.36.06;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.12.22.05.19;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.12.21.20.40;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.11.23.03.38;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.11.18.41.52;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.11.16.05.40;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.10.20.49.29;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.10.18.14.55;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.10.16.33.21;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.09.18.41.24;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.09.16.05.08;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.06.19.34.18;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.05.20.23.52;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.04.20.04.40;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.02.23.01.15;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.02.21.21.20;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.30.22.45.03;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.30.22.33.03;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.29.21.16.48;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.28.22.14.32;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.22.20.01.17;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.114
log
@Stochastic Implosion
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "StochImp.C"
//
// Contains the implementation of class StochImploder.
//------------------------------------------------------------------------------

#include <StochImp.h>
#include <StochModeMgr.h>
#include <StageMgr.h>
#include <ScenMgr.h>
#include <Scenario.h>
#include <StochImpOP.h>
#include <OptStarter.h>
#include <Pre.h>
#include <OptComp.h>
#include <wit/src/Variant.h>
#include <Timing.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class StochImploder.
//------------------------------------------------------------------------------

WitStochImploder::WitStochImploder (WitStochModeMgr * theStochModeMgr):

      WitProbAssoc    (theStochModeMgr),
      myStochModeMgr_ (theStochModeMgr),
      myStochImpOP_   (NULL),
      uploadingSoln_  (false)
   {
   }

//------------------------------------------------------------------------------

WitStochImploder::~WitStochImploder ()
   {
   }

//------------------------------------------------------------------------------

void WitStochImploder::implode ()
   {
   WitTimer::enterSection ("opt-prob");

   startStochImp ();

   myStochImpOP ()->solve ();

   finishStochImp ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitStochImploder::startStochImp ()
   {
   stronglyAssert (WitOptComp::optImpAllowed ());

   stronglyAssert (not myStochModeMgr_->stochSolnMode ());

   myMsgFac () ("stochImpMsg");

   myMsgFac () ("stochSingleLPMsg");

   myStochModeMgr_->myStageMgr ()->validateData      ();
   myStochModeMgr_->myScenMgr  ()->validateData      ();
   myStochModeMgr_->myStageMgr ()->verifyAllRecourse ();

   myStochModeMgr_->myScenMgr  ()->curScenario ()->saveInputAttrs ();

   verifyData     ();

   myProblem      ()->resetSoln ();

   myPreprocessor ()->verifyNoIntCons ();

   myPreprocessor ()->preprocess ();

   myOptComp      ()->optInitMethod ()->display ();

   setUpOptProb   ();
   }

//------------------------------------------------------------------------------

void WitStochImploder::verifyData ()
   {
   if (myCompMgr ()->nDemands () > 0)
      myMsgFac () ("singleStochLPwObjectNyiSmsg", "demands");

   if (myCompMgr ()->nBopEntries () > 0)
      myMsgFac () ("singleStochLPwObjectNyiSmsg", "BOP entries");

   if (myCompMgr ()->nSubEntries () > 0)
      myMsgFac () ("singleStochLPwObjectNyiSmsg", "substitute BOM entries");

   if (myCompMgr ()->nMaterials () > 0)
      myMsgFac () ("singleStochLPwObjectNyiSmsg", "material parts");
   }

//------------------------------------------------------------------------------

void WitStochImploder::setUpOptProb ()
   {
   myMsgFac () ("genLpMipProbMsg", myMsgFac ().myFrag ("stochLpFrag"));

   myStochImpOP_ = new WitStochImpOP (this);

   myStochImpOP ()->generateFixed ();

   myStochImpOP ()->generateFlexible ();
   }

//------------------------------------------------------------------------------

void WitStochImploder::finishStochImp ()
   {
   myProblem ()->optVariant ()->becomesCurrent ();

   uploadSoln ();

   myMsgFac () ("singleStochLPNyiSmsg", 12);

   delete myStochImpOP_;

   myStochImpOP_ = NULL;
   }

//------------------------------------------------------------------------------

void WitStochImploder::uploadSoln ()
   {
   uploadingSoln_ = true;

   myMsgFac () ("singleStochLPNyiSmsg", 13);

   uploadingSoln_ = false;
   }
@


1.113
log
@Stochastic Implosion
@
text
@@


1.112
log
@Stochastic Implosion
@
text
@d38 2
a39 1
      myStochImpOP_   (NULL)
d131 2
d139 11
@


1.111
log
@Stochastic Implosion
@
text
@d25 1
a25 1
#include <DetOptImpMgr.h>
a57 2
   myMsgFac () ("singleStochLPNyiSmsg", 5);

d85 1
a85 1
   myDetOptImpMgr ()->verifyNoIntCons ();
d128 4
@


1.110
log
@Stochastic Implosion
@
text
@d56 4
a123 2

   myMsgFac () ("singleStochLPNyiSmsg", 4);
@


1.109
log
@Stochastic Implosion
@
text
@d121 1
a121 1
   stronglyAssert (false);
@


1.108
log
@Stochastic Implosion
@
text
@d25 1
a25 1
#include <OptImp.h>
d83 1
a83 1
   myOptImploder  ()->verifyNoIntCons ();
@


1.107
log
@Stochastic Implosion
@
text
@d36 1
a36 1
      WitProbAssoc    (theStochModeMgr->myProblem ()),
@


1.106
log
@Stochastic Implosion
@
text
@d120 2
@


1.105
log
@Stochastic Implosion
@
text
@d119 1
a119 1
   myMsgFac () ("singleStochLPNyiSmsg");
@


1.104
log
@Stochastic Implosion
@
text
@d118 2
@


1.103
log
@Stochastic Implosion
@
text
@d115 1
a115 1
   myStochImpOP_ = new WitStochImpOP (myProblem ());
@


1.102
log
@Stochastic Implosion
@
text
@d21 1
d37 2
a38 1
      myStochModeMgr_ (theStochModeMgr)
d54 11
a78 9
   start ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitStochImploder::start ()
   {
d115 12
a126 1
   myMsgFac () ("singleStochLPNyiSmsg");
@


1.101
log
@Stochastic Implosion
@
text
@d60 3
a62 2
   myStochModeMgr_->myScenMgr  ()->validateData ();
   myStochModeMgr_->myStageMgr ()->validateData ();
@


1.100
log
@Stochastic Implosion
@
text
@d74 2
d89 17
@


1.99
log
@Stochastic Implosion
@
text
@d21 2
d25 2
d50 2
d65 27
a91 1
   myOptImploder ()->stochImplode ();
@


1.98
log
@Stochastic Implosion.
@
text
@d18 6
d41 20
@


1.97
log
@Stochastic Implosion
@
text
@d12 2
d15 20
@


1.96
log
@Stochastic Implosion
@
text
@a11 8
//
// Contains the implementation of the following classes
//
//    StochImpMgr
//    StochModeMgr
//    StageMgr
//    ScenMgr
//    Scenario
a12 1383

#include <StochImpMgr.h>
#include <StochModeMgr.h>
#include <StageMgr.h>
#include <ScenMgr.h>
#include <Scenario.h>
#include <DataWrit.h>
#include <Post.h>
#include <OptImp.h>
#include <OptStarter.h>
#include <Global.h>
#include <Material.h>
#include <Demand.h>
#include <Opn.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <OptComp.h>
#include <MsgFac.h>
#include <MsgFrag.h>

//------------------------------------------------------------------------------
// Implementation of class StochImpMgr.
//------------------------------------------------------------------------------

WitStochImpMgr::WitStochImpMgr (WitProblem * theProblem):

      WitProbAssoc        (theProblem),

      stochImpAllowed_    (false),
      singleStochLP_      (false),
      stageByObject_      (defStageByObject ()),
      nScenarios_         (defNScenarios ()),
      stochMode_          (defStochMode ()),
      myStochModeMgr_     (NULL),
      toWriteStochAttr_   (false),
      toSetStochModeAttr_ (false)
   {
   }

//------------------------------------------------------------------------------

WitStochImpMgr::~WitStochImpMgr ()
   {
   delete myStochModeMgr_;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::copyAttrsFrom (WitStochImpMgr * theStochImpMgr)
   {
   stochImpAllowed_ = theStochImpMgr->stochImpAllowed_;
   stageByObject_   = theStochImpMgr->stageByObject_;
   nScenarios_      = theStochImpMgr->nScenarios_;

   if (stochMode_ != theStochImpMgr->stochMode_)
      setStochMode (theStochImpMgr->stochMode_);

   if (stochMode_)
      myStochModeMgr ()->copyAttrsFrom (theStochImpMgr->myStochModeMgr ());
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::writeData ()
   {
   if (not writeDataNeeded ())
      return;

   myMsgFac () ("stochImpPreCommentWdMsg");

   writeDataID ();

   writeDataAttrs ();

   myDataWriter ()->writeEndCommand ();

   if (stochMode_)
      {
      myStochModeMgr ()->myStageMgr ()->writeData ();
      myStochModeMgr ()->myScenMgr  ()->writeData ();
      }

   myMsgFac () ("stochImpPostCommentWdMsg");
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::prepWriteStochAttr ()
   {
   stronglyAssert (not toWriteStochAttr_);

   toWriteStochAttr_ = true;
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::skipVectorWrite ()
   {
   bool skip;

   skip              = (stochMode_ and toWriteStochAttr_);

   toWriteStochAttr_ = false;

   return skip;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::prepWriteVector ()
   {
   if (stochMode_)
      myStochModeMgr ()->prepWriteVector ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::display ()
   {
   myMsgFac () ("stochMgrDdMsg",
      stochMode_,
      stageByObject_,
      nScenarios_);

   if (stochMode_)
      myStochModeMgr ()->myScenMgr ()->display ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::display (WitNode * theNode)
   {
   if (stochMode_)
      myStochModeMgr ()->myStageMgr ()->display (theNode);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::prepStochModeAttr ()
   {
   stronglyAssert (not toSetStochModeAttr_);

   toSetStochModeAttr_ = true;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::prepSetAttr ()
   {
   if (stochMode_)
      stronglyAssert (toSetStochModeAttr_);

   toSetStochModeAttr_ = false;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setStochImpAllowed (bool theValue)
   {
   stochImpAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setSingleStochLP (bool theValue)
   {
   singleStochLP_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setStageByObject (bool theValue)
   {
   stronglyAssert (stochImpAllowed_);

   myProblem ()->prepSetUnpostAttr ();

   stageByObject_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setNScenarios (int theValue)
   {
   stronglyAssert (stochImpAllowed_);

   stronglyAssert (theValue >= 1);

   myProblem ()->prepSetUnpostAttr ();

   nScenarios_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setStochMode (bool theValue)
   {
   stronglyAssert (stochImpAllowed_);

   prepStochModeAttr ();

   myProblem ()->prepSetUnpostAttr ();

   if (theValue == stochMode_)
      return;

   if (theValue)
      {
      myStochModeMgr_ = new WitStochModeMgr (myProblem ());

      myStochModeMgr ()->clearSoln ();
      }
   else
      {
      delete myStochModeMgr_;

      myStochModeMgr_ = NULL;
      }

   stochMode_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::implode ()
   {
   if (singleStochLP_)
      myStochModeMgr ()->implodeSingleLP ();
   else
      myStochModeMgr ()->implodeSeriesLP ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::discardSoln ()
   {
   myStochModeMgr ()->discardSoln ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportInput (
      WitDemand *     theDemand,
      WitDblFlexVec & demandVolRef)
   {
   stronglyAssert (exportingInput ());

   demandVolRef = curScenario ()->demandVol () (theDemand);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitOptComp *,
      double &    objValueRef,
      double & boundsValueRef)
   {
   if (exportingSoln ())
      {
         objValueRef = myStochModeMgr ()->   objValue ();
      boundsValueRef = myStochModeMgr ()->boundsValue ();
      }

   else if (clearingSoln ())
      {
         objValueRef = 0.0;
      boundsValueRef = 0.0;
      }

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitPart *       thePart,
      WitDblFlexVec & scrapVolRef)
   {
   if (exportingSoln ())
      scrapVolRef = curScenario ()->scrapVol () (thePart);

   else if (clearingSoln ())
      scrapVolRef = 0.0;

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitMaterial *   theMat,
      WitDblFlexVec & stockVolRef)
   {
   if (exportingSoln ())
      stockVolRef = curScenario ()->stockVol () (theMat);

   else if (clearingSoln ())
      stockVolRef = 0.0;

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitDemand *     theDemand,
      WitDblFlexVec &    shipVolRef,
      WitDblFlexVec & cumShipVolRef)
   {
   if (exportingSoln ())
      {
      shipVolRef    = curScenario ()->shipVol    () (theDemand);
      cumShipVolRef = curScenario ()->cumShipVol () (theDemand);
      }

   else if (clearingSoln ())
      {
      shipVolRef    = 0.0;
      cumShipVolRef = 0.0;
      }

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitOperation *  theOpn,
      WitDblFlexVec & execVolRef)
   {
   if (exportingSoln ())
      execVolRef = curScenario ()->execVol () (theOpn);

   else if (clearingSoln ())
      execVolRef = 0.0;

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitSubEntry *   theSub,
      WitDblFlexVec & subVolRef)
   {
   if (exportingSoln ())
      subVolRef = curScenario ()->subVol () (theSub);

   else if (clearingSoln ())
      subVolRef = 0.0;

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setScenarioIndex (int theIdx)
   {
   myStochModeMgr ()->myScenMgr ()->setScenarioIndex (theIdx);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setScenarioProb (double theValue)
   {
   myStochModeMgr ()->myScenMgr ()->curScenario ()->setScenarioProb (theValue);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setRecourseStage (WitNode * theNode, bool theValue)
   {
   myStochModeMgr ()->myStageMgr ()->setRecourseStage (theNode, theValue);
   }

//------------------------------------------------------------------------------

int WitStochImpMgr::scenarioIndex ()
   {
   return myStochModeMgr ()->myScenMgr ()->curScenario ()->myIndex ();
   }

//------------------------------------------------------------------------------

double WitStochImpMgr::scenarioProb ()
   {
   return myStochModeMgr ()->myScenMgr ()->curScenario ()->scenarioProb ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::recourseStage (WitNode * theNode)
   {
   return myStochModeMgr ()->myStageMgr ()->recourseStage () (theNode);
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::stochSolnMode ()
   {
   return myStochModeMgr ()->stochSolnMode ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::writeDataNeeded ()
   {
   if (stageByObject_ != defStageByObject ())
      return true;

   if (nScenarios_ != defNScenarios ())
      return true;

   if (stochMode_)
      return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::writeDataAttrs ()
   {
   myDataWriter ()->writeBool (
        "stageByObject",
         stageByObject_,
      defStageByObject ());

   myDataWriter ()->writeInt (
        "nScenarios",
         nScenarios_,
      defNScenarios ());

   myDataWriter ()->writeBool (
        "stochMode",
         stochMode_,
      defStochMode ());
   }

//------------------------------------------------------------------------------

WitScenario * WitStochImpMgr::curScenario ()
   {
   return myStochModeMgr ()->myScenMgr ()->curScenario ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::exportingInput ()
   {
   return myStochModeMgr ()->exportingInput ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::exportingSoln ()
   {
   return myStochModeMgr ()->exportingSoln ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::clearingSoln ()
   {
   return myStochModeMgr ()->clearingSoln ();
   }

//------------------------------------------------------------------------------
// Implementation of class StochModeMgr.
//------------------------------------------------------------------------------

WitStochModeMgr::WitStochModeMgr (WitProblem * theProblem):

      WitProbAssoc    (theProblem),

      myStageMgr_     (NULL),
      myScenMgr_      (NULL),
      exportingInput_ (false),
      exportingSoln_  (false),
      clearingSoln_   (false),
      stochSolnMode_  (false),
      objValue_       (0.0),
      boundsValue_    (0.0),
      curWriteComp_   (NULL),
      vectorWritten_  (false)
   {
   myMsgFac () ("enterStochModeMsg");

   verifyData ();

   myStageMgr_ = new WitStageMgr (myProblem ());
   myScenMgr_  = new WitScenMgr  (this);

   myOptComp ()->crashOptStarter ()->beChosen ();
   }

//------------------------------------------------------------------------------

WitStochModeMgr::~WitStochModeMgr ()
   {
   if (stochSolnMode_)
      discardSoln ();

   myMsgFac () ("leaveStochModeMsg");

   delete myScenMgr_;
   delete myStageMgr_;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::copyAttrsFrom (WitStochModeMgr * theStochModeMgr)
   {
   myScenMgr_ ->copyAttrsFrom (theStochModeMgr->myScenMgr_);
   myStageMgr_->copyAttrsFrom (theStochModeMgr->myStageMgr_);
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::exportInput ()
   {
   WitComponent * theComp;

   exportingInput_ = true;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importStochInput ();

   exportingInput_ = false;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::exportSoln ()
   {
   WitComponent * theComp;

   exportingSoln_ = true;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importStochSoln ();

   exportingSoln_ = false;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::clearSoln ()
   {
   WitComponent * theComp;

   clearingSoln_ = true;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importStochSoln ();

   clearingSoln_ = false;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::startWriteCompData (WitComponent * theComp)
   {
   stronglyAssert (curWriteComp_ == NULL);

   curWriteComp_ = theComp;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::prepWriteVector ()
   {
   if (curWriteComp_ != NULL)
      if (not vectorWritten_)
         {
         curWriteComp_->writeDataSetClause ();

         vectorWritten_ = true;
         }
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::finishWriteCompData ()
   {
   stronglyAssert (curWriteComp_ != NULL);

   if (vectorWritten_)
      myDataWriter ()->writeEndCommand ();

   vectorWritten_ = false;
   curWriteComp_  = NULL;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::implodeSeriesLP ()
   {
   WitScenario * origCurScenario;
   WitScenario * theScenario;
   double        scenProb;

   stronglyAssert (WitOptComp::optImpAllowed ());

   stronglyAssert (not stochSolnMode_);

   myMsgFac () ("stochImpMsg");

   myMsgFac () ("stochSeriesLPMsg");

   myScenMgr_ ->validateData ();
   myStageMgr_->validateData ();

   myScenMgr_->curScenario ()->saveInputAttrs ();

   origCurScenario = myScenMgr_->curScenario ();

   objValue_    = 0.0;
   boundsValue_ = 0.0;

   forEachEl (theScenario, myScenMgr_->myScenarios ())
      {
      myScenMgr_->setScenarioForImplode (theScenario);

      myOptImploder ()->implode ();

      myScenMgr_->curScenario ()->saveSolnAttrs ();

      scenProb = myScenMgr_->curScenario ()->scenarioProb ();

      objValue_    += myOptComp ()->objValue    () * scenProb;
      boundsValue_ += myOptComp ()->boundsValue () * scenProb;
      }

   myScenMgr_->setScenarioForImplode (origCurScenario);

   exportSoln ();

   myPostprocessor ()->postprocess ();

   stochSolnMode_ = true;

   myMsgFac () ("enterStochSolnModeMsg");
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::implodeSingleLP ()
   {
   WitScenario * origCurScenario;

   stronglyAssert (WitOptComp::optImpAllowed ());

   stronglyAssert (not stochSolnMode_);

   myMsgFac () ("stochImpMsg");

   myMsgFac () ("stochSingleLPMsg");

   myScenMgr_ ->validateData ();
   myStageMgr_->validateData ();

   myScenMgr_->curScenario ()->saveInputAttrs ();

   origCurScenario = myScenMgr_->curScenario ();

   myOptImploder ()->stochImplode ();
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::discardSoln ()
   {
   WitScenario * theScenario;

   stronglyAssert (stochSolnMode_);

   clearSoln ();

   forEachEl (theScenario, myScenMgr_->myScenarios ())
      theScenario->clearSoln ();

   objValue_      = 0.0;
   boundsValue_   = 0.0;
   stochSolnMode_ = false;

   myMsgFac () ("leaveStochSolnModeMsg");
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::verifyData ()
   {
   verifyGlobalBool (  "stageByObject",
      myStochImpMgr ()->stageByObject       (), true);

   verifyGlobalBool (  "computeCriticalList", 
      myGlobalComp  ()->computeCriticalList (), false);

   verifyGlobalBool (  "wit34Compatible",
      myGlobalComp  ()->wit34Compatible     (), false);

   verifyGlobalBool (  "compPrices",
      myOptComp     ()->compPrices          (), false);

   verifyGlobalBool (  "accAfterOptImp",
      myOptComp     ()->accAfterOptImp      (), false);

   verifyGlobalBool (  "accAfterSoftLB",
      myOptComp     ()->accAfterSoftLB      (), false);

   verifyGlobalBool (  "mipMode",
      myOptComp     ()->mipMode             (), false);

   if (not myOptComp ()->myObjFunc1 ()->isChosen ())
      myMsgFac () ("invIntAttStochModeSmsg", "objChoice", 1);
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::verifyGlobalBool (
      const char * theAttName,
      bool         theVal,
      bool         reqVal)
   {
   if (theVal != reqVal)
      myMsgFac () ("invBoolAttStochModeSmsg", theAttName, reqVal);
   }

//------------------------------------------------------------------------------
// Implementation of class StageMgr.
//------------------------------------------------------------------------------

WitStageMgr::WitStageMgr (WitProblem * theProblem):

      WitProbAssoc   (theProblem),

      recourseStage_ (myProblem (), defRecourseStage ())
   {
   }

//------------------------------------------------------------------------------

WitStageMgr::~WitStageMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitStageMgr::writeData ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   forEachPart (thePart, myProblem ())
      writeRecourseStage (thePart, "part");

   forEachOperation (theOpn, myProblem ())
      writeRecourseStage (theOpn, "operation");
   }

//------------------------------------------------------------------------------

void WitStageMgr::display (WitNode * theNode)
   {
   myMsgFac () ("stochNodeDdMsg", recourseStage_ (theNode));
   }

//------------------------------------------------------------------------------

void WitStageMgr::copyAttrsFrom (WitStageMgr * origStageMgr)
   {
   WitPart *      dupPart;
   WitPart *      origPart;
   WitOperation * dupOpn;
   WitOperation * origOpn;

   forEachPart (dupPart, myProblem ())
      {
      origPart =
         origStageMgr->
            myCompMgr ()->
               findPart (dupPart->partName ().myCstring ());

      recourseStage_ (dupPart) = origStageMgr->recourseStage_ (origPart);
      }

   forEachOperation (dupOpn, myProblem ())
      {
      origOpn =
         origStageMgr->
            myCompMgr ()->
               findOperation (dupOpn->operationName ().myCstring ());

      recourseStage_ (dupOpn) = origStageMgr->recourseStage_ (origOpn);
      }
   }

//------------------------------------------------------------------------------

void WitStageMgr::validateData ()
   {
   validateBomEnts   ();
   validateSubs      ();
   validateBopEnts   ();
   verifyAllRecourse ();
   }

//------------------------------------------------------------------------------

void WitStageMgr::setRecourseStage (WitNode * theNode, bool theValue)
   {
   myStochImpMgr ()->prepStochModeAttr ();
   myProblem     ()->prepSetUnpostAttr ();

   recourseStage_ (theNode) = theValue;
   }

//------------------------------------------------------------------------------

void WitStageMgr::writeRecourseStage (
      WitNode *    theNode,
      const char * nodeTypeName)
   {
   if (recourseStage_ (theNode) == defRecourseStage ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      (nodeTypeName);
   myDataWriter ()->writeStringValue  (theNode->nodeName ());

   myDataWriter ()->writeBool (
        "recourseStage",
         recourseStage_ (theNode),
      defRecourseStage ());

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitStageMgr::validateBomEnts ()
   {
   WitBomEntry * theBomEnt;

   forEachBomEntry (theBomEnt, myProblem ())
      {
      if (recourseStage_ (theBomEnt->myOperation ()))
         if (not recourseStage_ (theBomEnt->myPart ()))
            myMsgFac () ("bomEntRecMisMatchSmsg",
               true,
               false,
               theBomEnt->myOperationName (),
               theBomEnt->localIndex (),
               theBomEnt->myPartName ());

      if (not recourseStage_ (theBomEnt->myOperation ()))
         if (recourseStage_ (theBomEnt->myPart ()))
            myMsgFac () ("bomEntRecMisMatchSmsg",
               false,
               true,
               theBomEnt->myOperationName (),
               theBomEnt->localIndex (),
               theBomEnt->myPartName ());
      }
   }

//------------------------------------------------------------------------------

void WitStageMgr::validateSubs ()
   {
   WitSubEntry * theSub;

   forEachSubEntry (theSub, myProblem ())
      {
      if (recourseStage_ (theSub->myOperation ()))
         if (not recourseStage_ (theSub->myPart ()))
            myMsgFac () ("subRecMisMatchSmsg",
               true,
               false,
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               theSub->myPartName ());

      if (not recourseStage_ (theSub->myOperation ()))
         if (recourseStage_ (theSub->myPart ()))
            myMsgFac () ("subRecMisMatchSmsg",
               false,
               true,
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               theSub->myPartName ());
      }
   }

//------------------------------------------------------------------------------

void WitStageMgr::validateBopEnts ()
   {
   WitBopEntry * theBopEnt;

   forEachBopEntry (theBopEnt, myProblem ())
      if (recourseStage_ (theBopEnt->myOperation ()))
         if (not recourseStage_ (theBopEnt->myPart ()))
            myMsgFac () ("bopEntRecMisMatchSmsg",
               theBopEnt->myOperationName (),
               theBopEnt->localIndex (),
               theBopEnt->myPartName ());
   }

//------------------------------------------------------------------------------

void WitStageMgr::verifyAllRecourse ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   forEachPart (thePart, myProblem ())
      if (not recourseStage_ (thePart))
         myMsgFac () ("stochImpNonRecNodeSmsg",
            myMsgFac ().myFrag ("partFrag"),
            thePart->partName ());

   forEachOperation (theOpn, myProblem ())
      if (not recourseStage_ (theOpn))
         myMsgFac () ("stochImpNonRecNodeSmsg",
            myMsgFac ().myFrag ("operationFrag"),
            theOpn->operationName ());
   }

//------------------------------------------------------------------------------
// Implementation of class ScenMgr.
//------------------------------------------------------------------------------

WitScenMgr::WitScenMgr (WitStochModeMgr * theStochModeMgr):

      WitProbAssoc    (theStochModeMgr->myProblem ()),

      myStochModeMgr_ (theStochModeMgr),
      nScenarios_     (myStochImpMgr ()->nScenarios ()),
      myScenarios_    (),
      myScenByIdx_    (myStochImpMgr ()->nScenarios ()),
      curScenario_    (NULL)
   {
   int            theIdx;
   WitScenario *  theScenario;

   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      {
      theScenario          = new WitScenario (this, theIdx);

      myScenarios_.append (theScenario);

      myScenByIdx_[theIdx] = theScenario;
      }

   curScenario_ = myScenByIdx_[0];
   }

//------------------------------------------------------------------------------

WitScenMgr::~WitScenMgr ()
   {
   int theIdx;

   curScenario_ = NULL;

   myScenByIdx_.clear ();

   while (not myScenarios_.isEmpty ())
      myScenarios_.get ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::copyAttrsFrom (WitScenMgr * theScenMgr)
   {
   int           theIdx;
   WitScenario * dupScenario;
   WitScenario * origScenario;

   theIdx        = theScenMgr->curScenario_->myIndex ();

   curScenario_  = myScenByIdx_[theIdx];

   forEachEl (dupScenario, myScenarios_)
      {
      theIdx       = dupScenario->myIndex ();

      origScenario = theScenMgr->myScenByIdx_[theIdx];

      dupScenario->copyAttrsFrom (origScenario);
      }
   }

//------------------------------------------------------------------------------

void WitScenMgr::writeData ()
   {
   WitScenario * theScenario;

   if (not myStochModeMgr_->stochSolnMode ())
      curScenario_->saveInputAttrs ();

   forEachEl (theScenario, myScenarios_)
      theScenario->writeData ();

   myMsgFac () ("finalScenIdxWdMsg");

   curScenario_->writeScenarioIndex ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::display ()
   {
   WitScenario * theScenario;

   if (not myStochModeMgr_->stochSolnMode ())
      curScenario_->saveInputAttrs ();

   myMsgFac () ("stochImploderDdMsg", curScenario_->myIndex ());

   forEachEl (theScenario, myScenarios_)
      theScenario->display ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::validateData ()
   {
   checkScenarioProbs ();
   checkNonRecAtts    ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::setScenarioIndex (int theIdx)
   {
   myStochImpMgr ()->prepStochModeAttr ();
   myProblem     ()->prepSetUnpostAttr ();

   if (not myStochModeMgr_->stochSolnMode ())
      curScenario_->saveInputAttrs ();
                                  
   curScenario_ = myScenByIdx_[theIdx];

   myStochModeMgr_->exportInput ();

   if (myStochModeMgr_->stochSolnMode ())
      {
      myStochModeMgr_->exportSoln ();

      myPostprocessor ()->postprocess ();
      }
   }

//------------------------------------------------------------------------------

void WitScenMgr::setScenarioForImplode (WitScenario * theScenario)
   {
   curScenario_ = theScenario;

   myStochModeMgr_->exportInput ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::checkScenarioProbs ()
   {
   double        totProb;
   WitScenario * theScenario;

   totProb = 0.0;

   forEachEl (theScenario, myScenarios_)
      totProb += theScenario->scenarioProb ();

   if (fabs (totProb - 1.0) > 0.001)
      myMsgFac () ("totScenProbNeq1Smsg", totProb);
   }

//------------------------------------------------------------------------------

void WitScenMgr::checkNonRecAtts ()
   {
   WitScenario * firstScenario;
   WitScenario * otherScenario;

   firstScenario = myScenByIdx_[0];

   forEachEl (otherScenario, myScenarios_)
      if (otherScenario != firstScenario)
         firstScenario->checkNonRecAtts (otherScenario);
   }

//------------------------------------------------------------------------------
// Implementation of class Scenario.
//------------------------------------------------------------------------------

WitScenario::WitScenario (WitScenMgr * theScenMgr, int theIdx):

      WitProbAssoc  (theScenMgr->myProblem ()),

      myScenMgr_    (theScenMgr),
      myIndex_      (theIdx),
      scenarioProb_ (defScenarioProb ()),
      demandVol_    (myProblem (), 0.0),

      scrapVol_     (),
      stockVol_     (),
      shipVol_      (),
      cumShipVol_   (),
      execVol_      (),
      subVol_       ()
   {
   saveInputAttrsInt ();
   }

//------------------------------------------------------------------------------

WitScenario::~WitScenario ()
   {
   }

//------------------------------------------------------------------------------

void WitScenario::saveInputAttrs ()
   {
   stronglyAssert (this == myScenMgr_->curScenario ());

   saveInputAttrsInt ();
   }

//------------------------------------------------------------------------------

void WitScenario::saveSolnAttrs ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   stronglyAssert (this == myScenMgr_->curScenario ());

   scrapVol_  .allocate (myProblem (), 0.0);
   stockVol_  .allocate (myProblem (), 0.0);
   shipVol_   .allocate (myProblem (), 0.0);
   cumShipVol_.allocate (myProblem (), 0.0);
   execVol_   .allocate (myProblem (), 0.0);
   subVol_    .allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      scrapVol_   (thePart)   = thePart  ->scrapVol   ();
      }

   forEachMaterial (theMat, myProblem ())
      {
      stockVol_   (theMat)    = theMat   ->stockVol   ();
      }

   forEachDemand (theDemand, myProblem ())
      {
      shipVol_    (theDemand) = theDemand->shipVol    ();
      cumShipVol_ (theDemand) = theDemand->cumShipVol ();
      }

   forEachOperation (theOpn, myProblem ())
      {       
      execVol_    (theOpn)    = theOpn   ->execVol    ();
      }

   forEachSubEntry (theSub, myProblem ())
      {       
      subVol_     (theSub)    = theSub   ->subVol     ();
      }
   }

//------------------------------------------------------------------------------

void WitScenario::clearSoln ()
   {
   scrapVol_  .clear ();
   stockVol_  .clear ();
   shipVol_   .clear ();
   cumShipVol_.clear ();
   execVol_   .clear ();
   subVol_    .clear ();
   }

//------------------------------------------------------------------------------

void WitScenario::copyAttrsFrom (WitScenario * theScenario)
   {
   scenarioProb_ = theScenario->scenarioProb_;
   demandVol_    = theScenario->demandVol_;
   }

//------------------------------------------------------------------------------

void WitScenario::writeData ()
   {
   myMsgFac () ("scenarioHeadingWdMsg", myIndex_);

   writeScenarioIndex ();

   writeScenarioProb ();

   writeDemandData ();
   }

//------------------------------------------------------------------------------

void WitScenario::writeScenarioIndex ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

   myDataWriter ()->writeDouble (
      "scenarioIndex",
       myIndex_,
       -1);

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitScenario::display ()
   {
   myMsgFac () ("scenarioDdMsg",
      myIndex_,
      scenarioProb_);

   displayDemandData ();
   }

//------------------------------------------------------------------------------

void WitScenario::checkNonRecAtts (WitScenario * otherScenario)
   {
   WitDemand * theDemand;
   bool        recDem;
   WitPeriod   thePer;
   double      demVol1;
   double      demVol2;

   forEachDemand (theDemand, myProblem ())
      {
      recDem =
         myScenMgr_->
            myStochModeMgr ()->
               myStageMgr ()->
                  recourseStage () (theDemand->demandedPart ());

      if (not recDem)
         forEachPeriod (thePer, myProblem ())
            {
            demVol1 =                demandVol_ (theDemand)[thePer];
            demVol2 = otherScenario->demandVol_ (theDemand)[thePer];

            if (demVol1 != demVol2)
               myMsgFac () ("nonRecDemAttMisMatchSmsg",
                  "demandVol",
                  theDemand->demandedPartName (),
                  theDemand->demandName (),
                  thePer,
                  myIndex_,
                  demVol1,
                  otherScenario->myIndex_,
                  demVol2);
            }
      }
   }

//------------------------------------------------------------------------------

double WitScenario::defScenarioProb ()
   {
   return 1.0 / static_cast <double> (myStochImpMgr ()->nScenarios ());
   }

//------------------------------------------------------------------------------

void WitScenario::setScenarioProb (double theValue)
   {
   stronglyAssert (theValue >= 0.0);
   stronglyAssert (theValue <= 1.0 + FEAS_TOL);

   myStochImpMgr ()->prepStochModeAttr ();
   myProblem     ()->prepSetUnpostAttr ();

   scenarioProb_ = theValue;
   }

//------------------------------------------------------------------------------

void WitScenario::saveInputAttrsInt ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      demandVol_ (theDemand) = theDemand->demandVol ();
   }

//------------------------------------------------------------------------------

void WitScenario::writeScenarioProb ()
   {
   if (scenarioProb_ == defScenarioProb ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

   myDataWriter ()->writeDouble (
      "scenarioProb",
       scenarioProb_,
       defScenarioProb ());

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitScenario::writeDemandData ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      {
      myScenMgr_->
         myStochModeMgr ()->
            startWriteCompData (theDemand);

      myDataWriter ()->writeVector (
         "demandVol",
         demandVol_ (theDemand),
         WitDemand::defDemandVol ());

      myScenMgr_->
         myStochModeMgr ()->
            finishWriteCompData ();
      }
   }

//------------------------------------------------------------------------------

void WitScenario::displayDemandData ()
   {
   WitDemand *   theDemand;
   WitDblFlexVec theDblFlexVec (myProblem (), 0.0);

   forEachDemand (theDemand, myProblem ())
      {
      myMsgFac () ("demandIdDdMsg",
         theDemand->demandedPartName (),
         theDemand->demandName ());

      theDblFlexVec = demandVol_ (theDemand);

      myProblem ()->display ("demVolDdMsg", theDblFlexVec);
      }
   }
@


1.95
log
@Stochastic Implosion
@
text
@d275 23
a383 23
void WitStochImpMgr::exportSoln (
      WitOptImploder *,
      double &    objValueRef,
      double & boundsValueRef)
   {
   if (exportingSoln ())
      {
         objValueRef = myStochModeMgr ()->   objValue ();
      boundsValueRef = myStochModeMgr ()->boundsValue ();
      }

   else if (clearingSoln ())
      {
         objValueRef = 0.0;
      boundsValueRef = 0.0;
      }

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

a577 2
   myOptImploder ()->importStochSoln ();

d666 2
a667 2
      objValue_    += myOptImploder ()->objValue    () * scenProb;
      boundsValue_ += myOptImploder ()->boundsValue () * scenProb;
@


1.94
log
@Stochastic Implosion
@
text
@d265 1
a265 1
      WitDblFlexVec & demandVolArg)
d269 1
a269 1
   demandVolArg = curScenario ()->demandVol () (theDemand);
d276 1
a276 1
      WitDblFlexVec & scrapVolArg)
d279 1
a279 1
      scrapVolArg = curScenario ()->scrapVol () (thePart);
d282 1
a282 1
      scrapVolArg = 0.0;
d292 1
a292 1
      WitDblFlexVec & stockVolArg)
d295 1
a295 1
      stockVolArg = curScenario ()->stockVol () (theMat);
d298 1
a298 1
      stockVolArg = 0.0;
d308 2
a309 2
      WitDblFlexVec &    shipVolArg,
      WitDblFlexVec & cumShipVolArg)
d313 2
a314 2
      shipVolArg    = curScenario ()->shipVol    () (theDemand);
      cumShipVolArg = curScenario ()->cumShipVol () (theDemand);
d319 2
a320 2
      shipVolArg    = 0.0;
      cumShipVolArg = 0.0;
d331 1
a331 1
      WitDblFlexVec & execVolArg)
d334 1
a334 1
      execVolArg = curScenario ()->execVol () (theOpn);
d337 1
a337 1
      execVolArg = 0.0;
d347 1
a347 1
      WitDblFlexVec & subVolArg)
d350 1
a350 1
      subVolArg = curScenario ()->subVol () (theSub);
d353 1
a353 1
      subVolArg = 0.0;
d363 2
a364 2
      double &    objValueArg,
      double & boundsValueArg)
d368 2
a369 2
         objValueArg = myStochModeMgr ()->   objValue ();
      boundsValueArg = myStochModeMgr ()->boundsValue ();
d374 2
a375 2
         objValueArg = 0.0;
      boundsValueArg = 0.0;
@


1.93
log
@Stochastic Implosion
@
text
@a17 1
//    StochRefMgr
a24 1
#include <StochRefMgr.h>
d232 1
a232 2
      myStochModeMgr ()->myStochRefMgr ()->acquireRefs ();
      myStochModeMgr ()->myStochRefMgr ()->clearSoln   ();
d261 10
d274 2
a275 1
void WitStochImpMgr::receivePartRefs (
d278 8
a285 1
   myStochModeMgr ()->myStochRefMgr ()->receivePartRefs (scrapVolArg);
d290 2
a291 1
void WitStochImpMgr::receiveMaterialRefs (
d294 8
a301 1
   myStochModeMgr ()->myStochRefMgr ()->receiveMaterialRefs (stockVolArg);
d306 3
a308 3
void WitStochImpMgr::receiveDemandRefs (
      WitDblFlexVec & demandVolArg,
      WitDblFlexVec & shipVolArg,
d311 14
a324 3
   myStochModeMgr ()->myStochRefMgr ()->receiveDemandRefs (demandVolArg,
                                                             shipVolArg,
                                                          cumShipVolArg);
d329 2
a330 1
void WitStochImpMgr::receiveOperationRefs (
d333 8
a340 1
   myStochModeMgr ()->myStochRefMgr ()->receiveOperationRefs (execVolArg);
d345 2
a346 1
void WitStochImpMgr::receiveSubEntryRefs (
d349 8
a356 1
   myStochModeMgr ()->myStochRefMgr ()->receiveSubEntryRefs (subVolArg);
d361 3
a363 2
void WitStochImpMgr::receiveOptImpData (
      double & objValueArg,
d366 14
a379 2
   myStochModeMgr ()->myStochRefMgr ()->receiveOptImpData (objValueArg,
                                                        boundsValueArg);
d476 28
d509 1
a509 1
      WitProbAssoc   (theProblem),
d511 10
a520 6
      myStageMgr_    (NULL),
      myScenMgr_     (NULL),
      myStochRefMgr_ (NULL),
      stochSolnMode_ (false),
      curWriteComp_  (NULL),
      vectorWritten_ (false)
d526 2
a527 3
   myStageMgr_     = new WitStageMgr    (myProblem ());
   myScenMgr_      = new WitScenMgr     (this);
   myStochRefMgr_  = new WitStochRefMgr (this);
a540 1
   delete myStochRefMgr_;
d555 44
a637 2
   double        objVal;
   double        boundsVal;
d655 2
a656 2
   objVal    = 0.0;
   boundsVal = 0.0;
d668 2
a669 2
      objVal    += myOptImploder ()->objValue    () * scenProb;
      boundsVal += myOptImploder ()->boundsValue () * scenProb;
d674 1
a674 3
   myStochRefMgr_->setObjValues (objVal, boundsVal);

   myStochRefMgr_->restoreSoln ();
d715 1
a715 1
   myStochRefMgr ()->clearSoln ();
d720 2
a970 184
// Implementation of class StochRefMgr.
//------------------------------------------------------------------------------

WitStochRefMgr::WitStochRefMgr (WitStochModeMgr * theStochModeMgr):

      WitProbAssoc    (theStochModeMgr->myProblem ()),

      myStochModeMgr_ (theStochModeMgr),
      passRefsComp_   (NULL),
      demandVol_      (myProblem ()),
      scrapVol_       (myProblem ()),
      stockVol_       (myProblem ()),
      shipVol_        (myProblem ()),
      cumShipVol_     (myProblem ()),
      execVol_        (myProblem ()),
      subVol_         (myProblem ()),
      objValuePtr_    (NULL),
      boundsValuePtr_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitStochRefMgr::~WitStochRefMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::acquireRefs ()
   {
   forEachEl (passRefsComp_, myCompMgr ()->allComponents ())
      passRefsComp_->passStochRefs ();

   passRefsComp_ = NULL;

   myOptImploder ()->passStochRefs ();
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::restoreInput ()
   {
   WitScenario * theScenario;
   WitDemand *   theDemand;

   theScenario = myStochModeMgr_->myScenMgr ()->curScenario ();

   forEachDemand (theDemand, myProblem ())
      {
      demandVol_ (theDemand) = theScenario->demandVol () (theDemand);

      theDemand->compCumDemandVol ();
      }
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::clearSoln ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachPart (thePart, myProblem ())
      scrapVol_   (thePart)   = 0.0;

   forEachMaterial (theMat, myProblem ())
      stockVol_   (theMat)    = 0.0;

   forEachDemand (theDemand, myProblem ())
      {
      shipVol_    (theDemand) = 0.0;
      cumShipVol_ (theDemand) = 0.0;
      }

   forEachOperation (theOpn, myProblem ())
      execVol_    (theOpn)    = 0.0;

   forEachSubEntry (theSub, myProblem ())
      subVol_     (theSub)    = 0.0;
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::restoreSoln ()
   {
   WitScenario *  theScenario;
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   theScenario = myStochModeMgr_->myScenMgr ()->curScenario ();

   forEachPart (thePart, myProblem ())
      scrapVol_   (thePart)   = theScenario->scrapVol   () (thePart);

   forEachMaterial (theMat, myProblem ())
      stockVol_   (theMat)    = theScenario->stockVol   () (theMat);

   forEachDemand (theDemand, myProblem ())
      {
      shipVol_    (theDemand) = theScenario->shipVol    () (theDemand);
      cumShipVol_ (theDemand) = theScenario->cumShipVol () (theDemand);
      }

   forEachOperation (theOpn, myProblem ())
      execVol_    (theOpn)    = theScenario->execVol    () (theOpn);

   forEachSubEntry (theSub, myProblem ())
      subVol_     (theSub)    = theScenario->subVol     () (theSub);
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::setObjValues (
      double objValueVal,
      double boundsValueVal)
   {
   * objValuePtr_    = objValueVal;
   * boundsValuePtr_ = boundsValueVal;
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::receivePartRefs (
      WitDblFlexVec & scrapVolArg)
   {
   scrapVol_.setMapFor (passRefsComp ()->thisPart (), scrapVolArg);
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::receiveMaterialRefs (
      WitDblFlexVec & stockVolArg)
   {
   stockVol_.setMapFor (passRefsComp ()->thisMat (), stockVolArg);
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::receiveDemandRefs (
      WitDblFlexVec & demandVolArg,
      WitDblFlexVec & shipVolArg,
      WitDblFlexVec & cumShipVolArg)
   {
   demandVol_ .setMapFor (passRefsComp ()->thisDemand (), demandVolArg);
   shipVol_   .setMapFor (passRefsComp ()->thisDemand (), shipVolArg);
   cumShipVol_.setMapFor (passRefsComp ()->thisDemand (), cumShipVolArg);
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::receiveOperationRefs (
      WitDblFlexVec & execVolArg)
   {
   execVol_.setMapFor (passRefsComp ()->thisOpn (), execVolArg);
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::receiveSubEntryRefs (
      WitDblFlexVec & subVolArg)
   {
   subVol_.setMapFor (passRefsComp ()->thisSub (), subVolArg);
   }

//------------------------------------------------------------------------------

void WitStochRefMgr::receiveOptImpData (
      double & objValueArg,
      double & boundsValueArg)
   {
   witAssert (objValuePtr_ == NULL);

   objValuePtr_    = & objValueArg;
   boundsValuePtr_ = & boundsValueArg;
   }

//------------------------------------------------------------------------------
d1087 1
a1087 1
   myStochModeMgr_->myStochRefMgr ()->restoreInput ();
d1091 1
a1091 1
      myStochModeMgr_->myStochRefMgr ()->restoreSoln ();
d1103 1
a1103 1
   myStochModeMgr_->myStochRefMgr ()->restoreInput ();
@


1.92
log
@Stochastic Implosion
@
text
@d884 3
a886 1
   copy (demandVol_, theScenario->demandVol ());
a887 1
   forEachDemand (theDemand, myProblem ())
d889 1
d896 23
a918 6
   copy (scrapVol_,   0.0);
   copy (stockVol_,   0.0);
   copy (shipVol_,    0.0);
   copy (cumShipVol_, 0.0);
   copy (execVol_,    0.0);
   copy (subVol_,     0.0);
d925 6
a930 1
   WitScenario * theScenario;
d934 17
a950 6
   copy (scrapVol_,   theScenario->scrapVol   ());
   copy (stockVol_,   theScenario->stockVol   ());
   copy (shipVol_,    theScenario->shipVol    ());
   copy (cumShipVol_, theScenario->cumShipVol ());
   copy (execVol_,    theScenario->execVol    ());
   copy (subVol_,     theScenario->subVol     ());
@


1.91
log
@Stochastic Implosion
@
text
@d358 1
a358 1
   return myStochModeMgr ()->myStageMgr ()->recourseStage (theNode);
d1309 1
a1309 1
                  recourseStage (theDemand->demandedPart ());
@


1.90
log
@Stochastic Implosion
@
text
@d254 1
a254 1
      myStochModeMgr ()->implodeMultiLP ();
d497 1
a497 1
void WitStochModeMgr::implodeMultiLP ()
d511 2
d516 2
a519 2
   myScenMgr_->curScenario ()->saveInputAttrs ();

d554 18
a571 1
   myMsgFac () ("singleStochLPNyiSmsg");
@


1.89
log
@Stochastic Implosion
@
text
@d53 1
d188 7
d251 4
a254 1
   myStochModeMgr ()->implode ();
d497 1
a497 1
void WitStochModeMgr::implode ()
d499 5
a503 5
   WitScenario *  origCurScenario;
   WitScenario *  theScenario;
   double         objVal;
   double         boundsVal;
   double         scenProb;
d550 7
@


1.88
log
@Stochastic Implosion
@
text
@d18 1
a18 1
//    StochAttMgr
d26 1
a26 1
#include <StochAttMgr.h>
d226 2
a227 2
      myStochModeMgr ()->myStochAttMgr ()->acquireData ();
      myStochModeMgr ()->myStochAttMgr ()->clearSoln   ();
d259 1
a259 1
   myStochModeMgr ()->myStochAttMgr ()->receivePartRefs (scrapVolArg);
d267 1
a267 1
   myStochModeMgr ()->myStochAttMgr ()->receiveMaterialRefs (stockVolArg);
d277 3
a279 6
   myStochModeMgr ()->
      myStochAttMgr ()->
         receiveDemandRefs (
            demandVolArg,
            shipVolArg,
            cumShipVolArg);
d287 1
a287 1
   myStochModeMgr ()->myStochAttMgr ()->receiveOperationRefs (execVolArg);
d295 1
a295 1
   myStochModeMgr ()->myStochAttMgr ()->receiveSubEntryRefs (subVolArg);
d304 2
a305 5
   myStochModeMgr ()->
      myStochAttMgr ()->
         receiveOptImpData (
            objValueArg,
            boundsValueArg);
d411 1
a411 1
      myStochAttMgr_ (NULL),
d422 1
a422 1
   myStochAttMgr_  = new WitStochAttMgr (this);
d436 1
a436 1
   delete myStochAttMgr_;
d526 1
a526 1
   myStochAttMgr_->setObjValues (objVal, boundsVal);
d528 1
a528 1
   myStochAttMgr_->restoreSoln ();
d545 1
a545 1
   myStochAttMgr ()->clearSoln ();
d799 1
a799 1
// Implementation of class StochAttMgr.
d802 1
a802 1
WitStochAttMgr::WitStochAttMgr (WitStochModeMgr * theStochModeMgr):
d822 1
a822 1
WitStochAttMgr::~WitStochAttMgr ()
d828 1
a828 1
void WitStochAttMgr::acquireData ()
d840 1
a840 1
void WitStochAttMgr::restoreInput ()
d855 1
a855 1
void WitStochAttMgr::clearSoln ()
d867 1
a867 1
void WitStochAttMgr::restoreSoln ()
d883 1
a883 1
void WitStochAttMgr::setObjValues (
d893 1
a893 1
void WitStochAttMgr::receivePartRefs (
d901 1
a901 1
void WitStochAttMgr::receiveMaterialRefs (
d909 1
a909 1
void WitStochAttMgr::receiveDemandRefs (
d921 1
a921 1
void WitStochAttMgr::receiveOperationRefs (
d929 1
a929 1
void WitStochAttMgr::receiveSubEntryRefs (
d937 1
a937 1
void WitStochAttMgr::receiveOptImpData (
d1064 1
a1064 1
   myStochModeMgr_->myStochAttMgr ()->restoreInput ();
d1068 1
a1068 1
      myStochModeMgr_->myStochAttMgr ()->restoreSoln ();
d1080 1
a1080 1
   myStochModeMgr_->myStochAttMgr ()->restoreInput ();
@


1.87
log
@Stochastic Implosion
@
text
@d256 1
a256 1
void WitStochImpMgr::receivePartData (
d259 1
a259 1
   myStochModeMgr ()->myStochAttMgr ()->receivePartData (scrapVolArg);
d264 1
a264 1
void WitStochImpMgr::receiveMaterialData (
d267 1
a267 1
   myStochModeMgr ()->myStochAttMgr ()->receiveMaterialData (stockVolArg);
d272 1
a272 1
void WitStochImpMgr::receiveDemandData (
d279 1
a279 1
         receiveDemandData (
d287 1
a287 1
void WitStochImpMgr::receiveOperationData (
d290 1
a290 1
   myStochModeMgr ()->myStochAttMgr ()->receiveOperationData (execVolArg);
d295 1
a295 1
void WitStochImpMgr::receiveSubEntryData (
d298 1
a298 1
   myStochModeMgr ()->myStochAttMgr ()->receiveSubEntryData (subVolArg);
d813 1
a813 1
      passDataComp_   (NULL),
d836 2
a837 2
   forEachEl (passDataComp_, myCompMgr ()->allComponents ())
      passDataComp_->passStochData ();
d839 1
a839 1
   passDataComp_ = NULL;
d841 1
a841 1
   myOptImploder ()->passStochData ();
d899 1
a899 1
void WitStochAttMgr::receivePartData (
d902 1
a902 1
   scrapVol_.setMapFor (passDataComp ()->thisPart (), scrapVolArg);
d907 1
a907 1
void WitStochAttMgr::receiveMaterialData (
d910 1
a910 1
   stockVol_.setMapFor (passDataComp ()->thisMat (), stockVolArg);
d915 1
a915 1
void WitStochAttMgr::receiveDemandData (
d920 3
a922 3
   demandVol_ .setMapFor (passDataComp ()->thisDemand (), demandVolArg);
   shipVol_   .setMapFor (passDataComp ()->thisDemand (), shipVolArg);
   cumShipVol_.setMapFor (passDataComp ()->thisDemand (), cumShipVolArg);
d927 1
a927 1
void WitStochAttMgr::receiveOperationData (
d930 1
a930 1
   execVol_.setMapFor (passDataComp ()->thisOpn (), execVolArg);
d935 1
a935 1
void WitStochAttMgr::receiveSubEntryData (
d938 1
a938 1
   subVol_.setMapFor (passDataComp ()->thisSub (), subVolArg);
@


1.86
log
@Stochastic Implosion
@
text
@d303 13
a364 14
double WitStochImpMgr::objValue ()
   {
   return myStochModeMgr ()->objValue ();
   }

//------------------------------------------------------------------------------

double WitStochImpMgr::boundsValue ()
   {
   return myStochModeMgr ()->boundsValue ();
   }

//------------------------------------------------------------------------------

d420 1
a420 3
      vectorWritten_ (false),
      objValue_      (0.0),
      boundsValue_   (0.0)
d496 2
d513 2
a514 2
   objValue_    = 0.0;
   boundsValue_ = 0.0;
d526 2
a527 2
      objValue_    += myOptImploder ()->objValue    () * scenProb;
      boundsValue_ += myOptImploder ()->boundsValue () * scenProb;
d532 1
a532 1
   myOptImploder ()->importStochObjValues ();
d820 3
a822 1
      subVol_         (myProblem ())
d840 2
d889 10
d942 12
@


1.85
log
@Stochastic Implosion
@
text
@d1029 2
a1030 10
   double        totProb;
   WitScenario * theScenario;

   totProb = 0.0;

   forEachEl (theScenario, myScenarios_)
      totProb += theScenario->scenarioProb ();

   if (fabs (totProb - 1.0) > 0.001)
      myMsgFac () ("totScenProbNeq1Smsg", totProb);
d1065 30
d1239 38
@


1.84
log
@Stochastic Implosion
@
text
@d39 1
d675 3
a677 2
   validateBillEntries ();

d714 1
a714 1
void WitStageMgr::validateBillEntries ()
d726 10
d742 45
@


1.83
log
@Stochastic Implosion
@
text
@d674 1
a674 8
   WitPart *      thePart;
   WitOperation * theOpn;

   forEachPart (thePart, myProblem ())
      if (not recourseStage_ (thePart))
         myMsgFac () ("stochImpNonRecNodeSmsg",
            myMsgFac ().myFrag ("partFrag"),
            thePart->partName ());
d676 1
a676 5
   forEachOperation (theOpn, myProblem ())
      if (not recourseStage_ (theOpn))
         myMsgFac () ("stochImpNonRecNodeSmsg",
            myMsgFac ().myFrag ("operationFrag"),
            theOpn->operationName ());
d711 38
@


1.82
log
@Stochastic Implosion
@
text
@d225 2
a226 2
      myStochModeMgr ()->myStochAttMgr ()->acquireStochData ();
      myStochModeMgr ()->myStochAttMgr ()->clearSoln        ();
d749 1
a749 1
void WitStochAttMgr::acquireStochData ()
@


1.81
log
@Stochastic Implosion
@
text
@a55 3
      myStageMgr_         (NULL),
      myScenMgr_          (NULL),
      myStochAttMgr_      (NULL),
a64 4
   myStochAttMgr_ = NULL;
   myScenMgr_     = NULL;
   myStageMgr_    = NULL;

d147 1
a147 1
      myScenMgr ()->display ();
d155 1
a155 1
      myStageMgr ()->display (theNode);
d225 2
a226 6
      myStageMgr_     = myStochModeMgr_->myStageMgr ();
      myScenMgr_      = myStochModeMgr_->myScenMgr ();
      myStochAttMgr_  = myStochModeMgr_->myStochAttMgr ();

      myStochAttMgr ()->acquireStochData ();
      myStochAttMgr ()->clearSoln        ();
a229 4
      myStochAttMgr_  = NULL;
      myScenMgr_      = NULL;
      myStageMgr_     = NULL;

d258 1
a258 2
   myStochAttMgr ()->
      receivePartData (scrapVolArg);
d266 1
a266 2
   myStochAttMgr ()->
      receiveMaterialData (stockVolArg);
d276 6
a281 5
   myStochAttMgr ()->
      receiveDemandData (
         demandVolArg,
         shipVolArg,
         cumShipVolArg);
d289 1
a289 2
   myStochAttMgr ()->
      receiveOperationData (execVolArg);
d297 1
a297 2
   myStochAttMgr ()->
      receiveSubEntryData (subVolArg);
d304 1
a304 1
   myScenMgr ()->setScenarioIndex (theIdx);
d311 1
a311 1
   myScenMgr ()->curScenario ()->setScenarioProb (theValue);
d318 1
a318 1
   myStageMgr ()->setRecourseStage (theNode, theValue);
d325 1
a325 1
   return myScenMgr ()->curScenario ()->myIndex ();
d332 1
a332 1
   return myScenMgr ()->curScenario ()->scenarioProb ();
d339 1
a339 1
   return myStageMgr ()->recourseStage (theNode);
d994 1
a994 1
      WitProbAssoc    (theScenMgr->myProblem ()),
d996 11
a1006 12
      myScenMgr_      (theScenMgr),
      myStochModeMgr_ (theScenMgr->myStochModeMgr ()),
      myIndex_        (theIdx),
      scenarioProb_   (defScenarioProb ()),
      demandVol_      (myProblem (), 0.0),

      scrapVol_       (),
      stockVol_       (),
      shipVol_        (),
      cumShipVol_     (),
      execVol_        (),
      subVol_         ()
d1187 3
a1189 1
      myStochModeMgr_->startWriteCompData (theDemand);
d1196 3
a1198 1
      myStochModeMgr_->finishWriteCompData ();
@


1.80
log
@Stochastic Implosion
@
text
@d18 1
d26 1
a43 16
// Macro implementSchedWrapper
//
// Implements a wrapper access function for a Schedule in
// myScenMgr ()->curScenario ().
// The Schedule is of type Schedule <DomEl, RangeEl>.
// The function's name is given by funcName.
//------------------------------------------------------------------------------

#define implementSchedWrapper(RangeEl, funcName, DomEl)                        \
                                                                               \
   const WitTVec <RangeEl> & WitStochImpMgr::funcName (DomEl * theDomEl)       \
      {                                                                        \
      return myScenMgr ()->curScenario ()->funcName () (theDomEl);             \
      }                                                                        \

//------------------------------------------------------------------------------
d58 1
d68 3
a70 2
   myScenMgr_  = NULL;
   myStageMgr_ = NULL;
d234 4
d241 1
d267 51
a382 10
implementSchedWrapper (double, demandVol,  WitDemand)
implementSchedWrapper (double, scrapVol,   WitPart)
implementSchedWrapper (double, stockVol,   WitMaterial)
implementSchedWrapper (double, shipVol,    WitDemand)
implementSchedWrapper (double, cumShipVol, WitDemand)
implementSchedWrapper (double, execVol,    WitOperation)
implementSchedWrapper (double, subVol,     WitSubEntry)

//------------------------------------------------------------------------------

d435 1
a441 2
   WitComponent * theComp;

d446 3
a448 3
   myStageMgr_ = new WitStageMgr (myProblem ());

   myScenMgr_  = new WitScenMgr  (this);
a450 3

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->clearStochSoln ();
d462 1
a515 1
   WitComponent * theComp;
d552 1
a552 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->restoreStochSoln ();
d565 1
a565 2
   WitComponent * theComp;
   WitScenario *  theScenario;
d569 1
a569 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->clearStochSoln ();
d740 123
a978 2
   WitComponent * theComp;

d987 1
a987 1
   restoreInputAttrs ();
d991 1
a991 2
      forEachEl (theComp, myCompMgr ()->allComponents ())
         theComp->restoreStochSoln ();
d1003 1
a1003 11
   restoreInputAttrs ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::restoreInputAttrs ()
   {
   WitComponent * theComp;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->restoreStochInputAttrs ();
@


1.79
log
@Stochastic Implosion
@
text
@d54 1
a54 1
      return myScenMgr ()->curScenario ()->funcName (theDomEl);                \
@


1.78
log
@Stochastic Implosion
@
text
@d16 1
a16 1
//    StochDataMgr
d23 1
a23 1
#include <StochDataMgr.h>
d69 1
a69 1
      myStochDataMgr_     (NULL),
d84 1
a84 1
   delete myStochDataMgr_;
d99 1
a99 1
      myStochDataMgr ()->copyAttrsFrom (theStochImpMgr->myStochDataMgr ());
d119 2
a120 2
      myStochDataMgr ()->myStageMgr ()->writeData ();
      myStochDataMgr ()->myScenMgr  ()->writeData ();
d153 1
a153 1
      myStochDataMgr ()->prepWriteVector ();
d242 1
a242 1
      myStochDataMgr_ = new WitStochDataMgr (myProblem ());
d244 2
a245 2
      myStageMgr_     = myStochDataMgr_->myStageMgr ();
      myScenMgr_      = myStochDataMgr_->myScenMgr ();
d252 1
a252 1
      delete myStochDataMgr_;
d254 1
a254 1
      myStochDataMgr_ = NULL;
d264 1
a264 1
   myStochDataMgr ()->implode ();
d271 1
a271 1
   myStochDataMgr ()->discardSoln ();
d320 1
a320 1
   return myStochDataMgr ()->stochSolnMode ();
d327 1
a327 1
   return myStochDataMgr ()->objValue ();
d334 1
a334 1
   return myStochDataMgr ()->boundsValue ();
d392 1
a392 1
// Implementation of class StochDataMgr.
d395 1
a395 1
WitStochDataMgr::WitStochDataMgr (WitProblem * theProblem):
d425 1
a425 1
WitStochDataMgr::~WitStochDataMgr ()
d438 1
a438 1
void WitStochDataMgr::copyAttrsFrom (WitStochDataMgr * theStochDataMgr)
d440 2
a441 2
   myScenMgr_ ->copyAttrsFrom (theStochDataMgr->myScenMgr_);
   myStageMgr_->copyAttrsFrom (theStochDataMgr->myStageMgr_);
d446 1
a446 1
void WitStochDataMgr::startWriteCompData (WitComponent * theComp)
d455 1
a455 1
void WitStochDataMgr::prepWriteVector ()
d468 1
a468 1
void WitStochDataMgr::finishWriteCompData ()
d481 1
a481 1
void WitStochDataMgr::implode ()
d534 1
a534 1
void WitStochDataMgr::discardSoln ()
d554 1
a554 1
void WitStochDataMgr::verifyData ()
d583 1
a583 1
void WitStochDataMgr::verifyGlobalBool (
d716 1
a716 1
WitScenMgr::WitScenMgr (WitStochDataMgr * theStochDataMgr):
d718 1
a718 1
      WitProbAssoc    (theStochDataMgr->myProblem ()),
d720 1
a720 1
      myStochDataMgr_ (theStochDataMgr),
d783 1
a783 1
   if (not myStochDataMgr_->stochSolnMode ())
d800 1
a800 1
   if (not myStochDataMgr_->stochSolnMode ())
d834 1
a834 1
   if (not myStochDataMgr_->stochSolnMode ())
d841 1
a841 1
   if (myStochDataMgr_->stochSolnMode ())
d878 1
a878 1
      myStochDataMgr_ (theScenMgr->myStochDataMgr ()),
d1069 1
a1069 1
      myStochDataMgr_->startWriteCompData (theDemand);
d1076 1
a1076 1
      myStochDataMgr_->finishWriteCompData ();
@


1.77
log
@Stochastic Implosion
@
text
@d68 1
a68 1
      stochDataMode_      (defStochDataMode ()),
d95 2
a96 2
   if (stochDataMode_ != theStochImpMgr->stochDataMode_)
      setStochDataMode (theStochImpMgr->stochDataMode_);
d98 1
a98 1
   if (stochDataMode_)
d117 1
a117 1
   if (stochDataMode_)
d141 1
a141 1
   skip              = (stochDataMode_ and toWriteStochAttr_);
d152 1
a152 1
   if (stochDataMode_)
d161 1
a161 1
      stochDataMode_,
d165 1
a165 1
   if (stochDataMode_)
d173 1
a173 1
   if (stochDataMode_)
d179 1
a179 1
void WitStochImpMgr::prepStochDataModeAttr ()
d190 1
a190 1
   if (stochDataMode_)
d229 1
a229 1
void WitStochImpMgr::setStochDataMode (bool theValue)
d233 1
a233 1
   prepStochDataModeAttr ();
d237 1
a237 1
   if (theValue == stochDataMode_)
d257 1
a257 1
   stochDataMode_ = theValue;
d357 1
a357 1
   if (stochDataMode_)
d386 3
a388 3
        "stochDataMode",
         stochDataMode_,
      defStochDataMode ());
d685 2
a686 2
   myStochImpMgr ()->prepStochDataModeAttr ();
   myProblem     ()->prepSetUnpostAttr     ();
d831 2
a832 2
   myStochImpMgr ()->prepStochDataModeAttr ();
   myProblem     ()->prepSetUnpostAttr     ();
d1027 2
a1028 2
   myStochImpMgr ()->prepStochDataModeAttr ();
   myProblem     ()->prepSetUnpostAttr     ();
@


1.76
log
@Stochastic Implosion
@
text
@d494 1
d811 16
@


1.75
log
@Stochastic Implosion
@
text
@d45 1
a45 1
// myStochDataMgr ()->myScenMgr ()->curScenario ().
d54 1
a54 5
      return                                                                   \
         myStochDataMgr ()->                                                   \
            myScenMgr ()->                                                     \
               curScenario ()->                                                \
                  funcName (theDomEl);                                         \
d70 2
d81 3
d166 1
a166 1
      myStochDataMgr ()->myScenMgr ()->display ();
d174 1
a174 1
      myStochDataMgr ()->myStageMgr ()->display (theNode);
d241 1
d243 4
d249 3
d278 1
a278 3
   myStochDataMgr ()->
      myScenMgr ()->
         setScenarioIndex (theIdx);
d285 1
a285 4
   myStochDataMgr ()->
      myScenMgr ()->
         curScenario ()->
            setScenarioProb (theValue);
d292 1
a292 3
   myStochDataMgr ()->
      myStageMgr ()->
         setRecourseStage (theNode, theValue);
d299 1
a299 5
   return
      myStochDataMgr ()->
         myScenMgr ()->
            curScenario ()->
               myIndex ();
d306 1
a306 5
   return
      myStochDataMgr ()->
         myScenMgr ()->
            curScenario ()->
               scenarioProb ();
d313 1
a313 4
   return
      myStochDataMgr ()->
         myStageMgr ()->
            recourseStage (theNode);
d730 1
a730 1
      theScenario          = new WitScenario (myStochDataMgr_, theIdx);
d856 1
a856 1
WitScenario::WitScenario (WitStochDataMgr * theStochDataMgr, int theIdx):
d858 1
a858 1
      WitProbAssoc    (theStochDataMgr->myProblem ()),
d860 2
a861 1
      myStochDataMgr_ (theStochDataMgr),
d886 1
a886 1
   stronglyAssert (this == myStochDataMgr_->myScenMgr ()->curScenario ());
d901 1
a901 1
   stronglyAssert (this == myStochDataMgr_->myScenMgr ()->curScenario ());
@


1.74
log
@Stochastic Implosion
@
text
@d18 1
d25 1
d45 1
a45 1
// myStochDataMgr ()->curScenario ().
d54 5
a58 1
      return myStochDataMgr ()->curScenario ()->funcName (theDomEl);           \
d119 1
a119 2

      myStochDataMgr ()->writeScenarioData ();
d165 1
a165 1
      myStochDataMgr ()->display ();
d269 3
a271 1
   myStochDataMgr ()->setScenarioIndex (theIdx);
d278 4
a281 1
   myStochDataMgr ()->curScenario ()->setScenarioProb (theValue);
d288 3
a290 1
   myStochDataMgr ()->myStageMgr ()->setRecourseStage (theNode, theValue);
d297 5
a301 1
   return myStochDataMgr ()->curScenario ()->myIndex ();
d308 5
a312 1
   return myStochDataMgr ()->curScenario ()->scenarioProb ();
d319 4
a322 1
   return myStochDataMgr ()->myStageMgr ()->recourseStage (theNode);
d409 1
a409 4
      nScenarios_    (myStochImpMgr ()->nScenarios ()),
      myScenarios_   (),
      myScenByIdx_   (myStochImpMgr ()->nScenarios ()),
      curScenario_   (NULL),
a415 2
   int            theIdx;
   WitScenario *  theScenario;
d424 1
a424 10
   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      {
      theScenario          = new WitScenario (this, theIdx);

      myScenarios_.append (theScenario);

      myScenByIdx_[theIdx] = theScenario;
      }

   curScenario_ = myScenByIdx_[0];
a435 2
   int theIdx;

d441 1
a441 7
   curScenario_ = NULL;

   myScenByIdx_.clear ();

   while (not myScenarios_.isEmpty ())
      myScenarios_.get ();

d449 1
a449 8
   int           theIdx;
   WitScenario * dupScenario;
   WitScenario * origScenario;

   theIdx        = theStochDataMgr->curScenario_->myIndex ();

   curScenario_  = myScenByIdx_[theIdx];

a450 26
                
   forEachEl (dupScenario, myScenarios_)
      {
      theIdx       = dupScenario->myIndex ();

      origScenario = theStochDataMgr->myScenByIdx_[theIdx];

      dupScenario->copyAttrsFrom (origScenario);
      }
   }

//------------------------------------------------------------------------------

void WitStochDataMgr::writeScenarioData ()
   {
   WitScenario * theScenario;

   if (not stochSolnMode_)
      curScenario_->saveInputAttrs ();

   forEachEl (theScenario, myScenarios_)
      theScenario->writeData ();

   myMsgFac () ("finalScenIdxWdMsg");

   curScenario_->writeScenarioIndex ();
a489 15
void WitStochDataMgr::display ()
   {
   WitScenario * theScenario;

   if (not stochSolnMode_)
      curScenario_->saveInputAttrs ();

   myMsgFac () ("stochImploderDdMsg", curScenario_->myIndex ());

   forEachEl (theScenario, myScenarios_)
      theScenario->display ();
   }

//------------------------------------------------------------------------------

d493 1
d495 1
d505 1
a505 1
   origCurScenario = curScenario_;
d507 1
a507 1
   curScenario_->saveInputAttrs ();
d512 1
a512 1
   forEachEl (curScenario_, myScenarios_)
d514 1
a514 1
      restoreInputAttrs ();
d518 1
a518 1
      curScenario_->saveSolnAttrs ();
d520 1
a520 2
      objValue_    +=
         myOptImploder ()->objValue    () * curScenario_->scenarioProb ();
d522 2
a523 2
      boundsValue_ +=
         myOptImploder ()->boundsValue () * curScenario_->scenarioProb ();
d526 1
a526 3
   curScenario_ = origCurScenario;

   restoreInputAttrs ();
d552 1
a552 1
   forEachEl (theScenario, myScenarios_)
a561 25
void WitStochDataMgr::setScenarioIndex (int theIdx)
   {
   WitComponent * theComp;

   myStochImpMgr ()->prepStochDataModeAttr ();
   myProblem     ()->prepSetUnpostAttr     ();

   if (not stochSolnMode_)
      curScenario_->saveInputAttrs ();
                                  
   curScenario_ = myScenByIdx_[theIdx];

   restoreInputAttrs ();

   if (stochSolnMode_)
      {
      forEachEl (theComp, myCompMgr ()->allComponents ())
         theComp->restoreStochSoln ();

      myPostprocessor ()->postprocess ();
      }
   }

//------------------------------------------------------------------------------

a600 10

void WitStochDataMgr::restoreInputAttrs ()
   {
   WitComponent * theComp;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->restoreStochInputAttrs ();
   }

//------------------------------------------------------------------------------
d721 141
d894 1
a894 1
   stronglyAssert (this == myStochDataMgr_->curScenario ());
d909 1
a909 1
   stronglyAssert (this == myStochDataMgr_->curScenario ());
@


1.73
log
@Stochastic Implosion
@
text
@d17 1
d23 1
d112 1
a112 1
      myStochDataMgr ()->writeStageData ();
d168 1
a168 1
      myStochDataMgr ()->display (theNode);
d278 1
a278 1
   myStochDataMgr ()->setRecourseStage (theNode, theValue);
d299 1
a299 1
   return myStochDataMgr ()->recourseStage (theNode);
d385 1
a389 1
      recourseStage_ (myProblem (), defRecourseStage ()),
d404 2
d440 2
d448 3
a450 7
   int            theIdx;
   WitPart *      dupPart;
   WitPart *      origPart;
   WitOperation * dupOpn;
   WitOperation * origOpn;
   WitScenario *  dupScenario;
   WitScenario *  origScenario;
d456 2
a457 20
   forEachPart (dupPart, myProblem ())
      {
      origPart =
         theStochDataMgr->
            myCompMgr ()->
               findPart (dupPart->partName ().myCstring ());

      recourseStage_ (dupPart) = theStochDataMgr->recourseStage_ (origPart);
      }

   forEachOperation (dupOpn, myProblem ())
      {
      origOpn =
         theStochDataMgr->
            myCompMgr ()->
               findOperation (dupOpn->operationName ().myCstring ());

      recourseStage_ (dupOpn) = theStochDataMgr->recourseStage_ (origOpn);
      }

a469 14
void WitStochDataMgr::writeStageData ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   forEachPart (thePart, myProblem ())
      writeRecourseStage (thePart, "part");

   forEachOperation (theOpn, myProblem ())
      writeRecourseStage (theOpn, "operation");
   }

//------------------------------------------------------------------------------

a536 7
void WitStochDataMgr::display (WitNode * theNode)
   {
   myMsgFac () ("stochNodeDdMsg", recourseStage_ (theNode));
   }

//------------------------------------------------------------------------------

d548 1
a548 1
   validateStageData ();
a589 20
void WitStochDataMgr::validateStageData ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   forEachPart (thePart, myProblem ())
      if (not recourseStage_ (thePart))
         myMsgFac () ("stochImpNonRecNodeSmsg",
            myMsgFac ().myFrag ("partFrag"),
            thePart->partName ());

   forEachOperation (theOpn, myProblem ())
      if (not recourseStage_ (theOpn))
         myMsgFac () ("stochImpNonRecNodeSmsg",
            myMsgFac ().myFrag ("operationFrag"),
            theOpn->operationName ());
   }

//------------------------------------------------------------------------------

a634 10
void WitStochDataMgr::setRecourseStage (WitNode * theNode, bool theValue)
   {
   myStochImpMgr ()->prepStochDataModeAttr ();
   myProblem     ()->prepSetUnpostAttr     ();

   recourseStage_ (theNode) = theValue;
   }

//------------------------------------------------------------------------------

d675 110
a784 1
void WitStochDataMgr::writeRecourseStage (
a803 10

void WitStochDataMgr::restoreInputAttrs ()
   {
   WitComponent * theComp;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->restoreStochInputAttrs ();
   }

//------------------------------------------------------------------------------
@


1.72
log
@Stochastic Implosion
@
text
@d883 1
a883 1
   writeStochDataMgrData ();
d946 1
a946 1
void WitScenario::writeStochDataMgrData ()
d948 2
a949 1
   double defScenProb;
d951 2
a952 1
   defScenProb = defScenarioProb ();
d954 4
a957 4
   if (scenarioProb_ != defScenProb)
      {
      myDataWriter ()->writeFirstKeyWord ("set");
      myDataWriter ()->writeKeyWord      ("problem");
d959 1
a959 7
      myDataWriter ()->writeDouble (
         "scenarioProb",
          scenarioProb_,
          defScenProb);

      myDataWriter ()->writeEndCommand ();
      }
@


1.71
log
@Stochastic Implosion
@
text
@d269 1
a269 1
   myStochDataMgr ()->setScenarioProb (theValue);
d290 1
a290 1
   return myStochDataMgr ()->scenarioProb ();
a386 1
      scenarioProb_  (defScenarioProb ()),
a453 2
   scenarioProb_ = theStochDataMgr->scenarioProb_;

d602 5
a606 2
      objValue_    += myOptImploder ()->objValue    () * scenarioProb_;
      boundsValue_ += myOptImploder ()->boundsValue () * scenarioProb_;
a666 7
double WitStochDataMgr::defScenarioProb ()
   {
   return 1.0 / static_cast <double> (myStochImpMgr ()->nScenarios ());
   }

//------------------------------------------------------------------------------

a691 13
void WitStochDataMgr::setScenarioProb (double theValue)
   {
   stronglyAssert (theValue >= 0.0);
   stronglyAssert (theValue <= 1.0 + FEAS_TOL);

   myStochImpMgr ()->prepStochDataModeAttr ();
   myProblem     ()->prepSetUnpostAttr     ();

   scenarioProb_ = theValue;
   }

//------------------------------------------------------------------------------

a766 2
   scenarioProb_ = curScenario_->scenarioProb ();

a767 1
      {
a768 1
      }
d781 1
a781 1
      scenarioProb_   (0.0),
d916 20
a939 2
   scenarioProb_ = myStochDataMgr_->scenarioProb ();

a940 1
      {
a941 1
      }
d950 1
a950 1
   defScenProb = myStochDataMgr_->defScenarioProb ();
@


1.70
log
@Stochastic Implosion
@
text
@d267 1
a267 1
void WitStochImpMgr::setProbability (double theValue)
d269 1
a269 1
   myStochDataMgr ()->setProbability (theValue);
d288 1
a288 1
double WitStochImpMgr::probability ()
d290 1
a290 1
   return myStochDataMgr ()->probability ();
d387 1
a387 1
      probability_   (defProbability ()),
d451 1
a451 1
   theIdx       = theStochDataMgr->curScenario_->myIndex ();
d453 1
a453 1
   curScenario_ = myScenByIdx_[theIdx];
d455 1
a455 1
   probability_ = theStochDataMgr->probability_;
d605 2
a606 2
      objValue_    += myOptImploder ()->objValue    () * probability_;
      boundsValue_ += myOptImploder ()->boundsValue () * probability_;
d667 1
a667 1
double WitStochDataMgr::defProbability ()
d699 1
a699 1
void WitStochDataMgr::setProbability (double theValue)
d707 1
a707 1
   probability_ = theValue;
d787 1
a787 1
   probability_ = curScenario_->probability ();
d805 1
a805 1
      probability_    (0.0),
d895 2
a896 2
   probability_ = theScenario->probability_;
   demandVol_   = theScenario->demandVol_;
d933 1
a933 1
      probability_);
d944 1
a944 1
   probability_ = myStochDataMgr_->probability ();
d958 1
a958 1
   defScenProb = myStochDataMgr_->defProbability ();
d960 1
a960 1
   if (probability_ != defScenProb)
d966 2
a967 2
         "probability",
          probability_,
@


1.69
log
@Stochastic Implosion
@
text
@d35 1
d109 5
a113 1
      myStochDataMgr ()->writeData ();
d274 7
d443 7
a449 3
   int           theIdx;
   WitScenario * dupScenario;
   WitScenario * origScenario;
d457 20
d489 15
a503 1
void WitStochDataMgr::writeData ()
d588 2
d627 20
d679 1
a679 2

   myProblem ()->prepSetUnpostAttr ();
d705 6
d712 4
a715 1
   myProblem ()->prepSetUnpostAttr ();
d717 1
a717 1
   probability_ = theValue;
d762 21
@


1.68
log
@Stochastic Implosion
@
text
@d283 1
a283 1
bool WitStochImpMgr::stochRecourse (WitNode * theNode)
d285 1
a285 1
   return myStochDataMgr ()->stochRecourse (theNode);
d376 1
a376 1
      stochRecourse_ (myProblem (), defStochRecourse ()),
d522 1
a522 1
   myMsgFac () ("stochNodeDdMsg", stochRecourse_ (theNode));
@


1.67
log
@Stochastic Implosion.
@
text
@d158 8
d283 7
d376 1
d520 7
@


1.66
log
@Stochastic Implosion
@
text
@a246 7
void WitStochImpMgr::setSglStochLP (bool theValue)
   {
   myStochDataMgr ()->setSglStochLP (theValue);
   }

//------------------------------------------------------------------------------

a260 7
bool WitStochImpMgr::sglStochLP ()
   {
   return myStochDataMgr ()->sglStochLP ();
   }

//------------------------------------------------------------------------------

a355 1
      sglStochLP_    (false),
a578 11
void WitStochDataMgr::setSglStochLP (bool theValue)
   {
   myStochImpMgr ()->prepStochDataModeAttr ();

   myProblem ()->prepSetUnpostAttr ();

   sglStochLP_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.65
log
@Stochastic Implosion
@
text
@d247 7
d268 7
d370 1
d594 11
@


1.64
log
@Stochastic Implosion
@
text
@d282 14
d363 3
a365 1
      vectorWritten_ (false)
d519 3
d529 3
d538 2
@


1.63
log
@Stochastic Implosion
@
text
@d28 1
a28 1
#include <Part.h>
d30 3
a33 2
#include <OptAccess.h>
#include <StochAccess.h>
d37 16
d282 10
d351 3
a353 2
   int           theIdx;
   WitScenario * theScenario;
d372 2
a373 1
   clearSoln ();
d490 2
a491 1
   WitScenario * origCurScenario;
d505 1
a505 1
      curScenario_->restoreInputAttrs ();
d514 4
a517 2
   curScenario_->restoreInputAttrs ();
   curScenario_->restoreSolnAttrs  ();
d530 2
a531 1
   WitScenario * theScenario;
d535 2
a536 1
   clearSoln ();
d557 2
d568 1
a568 1
   curScenario_->restoreInputAttrs ();
d572 2
a573 1
      curScenario_->restoreSolnAttrs ();
d635 1
a635 1
void WitStochDataMgr::clearSoln ()
d637 1
a637 10
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachPart (thePart, myProblem ())
      {
      WitOptAccess::scrapVol   (thePart)   = 0.0;
      }
d639 1
a639 4
   forEachMaterial (theMat, myProblem ())
      {
      WitOptAccess::stockVol   (theMat)    = 0.0;
      }
d641 1
a641 1
   forEachDemand (theDemand, myProblem ())
d643 1
a643 12
      WitOptAccess::shipVol    (theDemand) = 0.0;
      WitOptAccess::cumShipVol (theDemand) = 0.0;
      }

   forEachOperation (theOpn, myProblem ())
      {       
      WitOptAccess::execVol    (theOpn)    = 0.0;
      }

   forEachSubEntry (theSub, myProblem ())
      {       
      WitOptAccess::subVol     (theSub)    = 0.0;
a732 57
void WitScenario::restoreInputAttrs ()
   {
   WitDemand * theDemand;

   stronglyAssert (this == myStochDataMgr_->curScenario ());

   WitStochAccess::probability (myStochDataMgr_) = probability_;

   forEachDemand (theDemand, myProblem ())
      {
      WitStochAccess::demandVol (theDemand) = demandVol_ (theDemand);

      theDemand->compCumDemandVol ();
      }
   }

//------------------------------------------------------------------------------

void WitScenario::restoreSolnAttrs ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   stronglyAssert (this == myStochDataMgr_->curScenario ());

   forEachPart (thePart, myProblem ())
      {
      WitOptAccess::scrapVol   (thePart)   = scrapVol_   (thePart);
      }

   forEachMaterial (theMat, myProblem ())
      {
      WitOptAccess::stockVol   (theMat)    = stockVol_   (theMat);
      }

   forEachDemand (theDemand, myProblem ())
      {
      WitOptAccess::shipVol    (theDemand) = shipVol_    (theDemand);
      WitOptAccess::cumShipVol (theDemand) = cumShipVol_ (theDemand);
      }

   forEachOperation (theOpn, myProblem ())
      {       
      WitOptAccess::execVol    (theOpn)    = execVol_    (theOpn);
      }

   forEachSubEntry (theSub, myProblem ())
      {       
      WitOptAccess::subVol     (theSub)    = subVol_     (theSub);
      }
   }

//------------------------------------------------------------------------------

@


1.62
log
@Stochastic Implosion
@
text
@d316 2
a317 1
      myScenarios_   (myStochImpMgr ()->nScenarios ()),
d324 2
a325 1
   int theIdx;
d332 7
a338 2
      myScenarios_[theIdx] =
         new WitScenario (this, theIdx);
d340 1
a340 1
   curScenario_ = myScenarios_[0];
d360 4
a363 2
   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      delete myScenarios_[theIdx];
d371 2
a372 1
   WitScenario * theScenario;
d376 1
a376 1
   curScenario_ = myScenarios_[theIdx];
d380 1
a380 1
   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
d382 3
a384 1
      theScenario = theStochDataMgr->myScenarios_[theIdx];
d386 1
a386 1
      myScenarios_[theIdx]->copyAttrsFrom (theScenario);
d394 1
a394 1
   int theIdx;
d399 2
a400 2
   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      myScenarios_[theIdx]->writeData ();
d446 1
a446 1
   int theIdx;
d453 2
a454 2
   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      myScenarios_[theIdx]->display ();
a461 1
   int           theIdx;
d473 1
a473 1
   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
a474 2
      curScenario_ = myScenarios_[theIdx];

d498 1
a498 1
   int theIdx;
d504 2
a505 4
   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      {
      myScenarios_[theIdx]->clearSoln ();
      }
d530 1
a530 1
   curScenario_ = myScenarios_[theIdx];
@


1.61
log
@Stochastic Implosion
@
text
@d327 1
a327 2
   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("notByObjectStochModeSmsg");
d551 40
@


1.60
log
@Stochastic Implosion
@
text
@d41 1
a41 1
      WitProbAssoc      (theProblem),
d43 7
a49 7
      stochImpAllowed_  (false),
      stageByObject_    (defStageByObject ()),
      nScenarios_       (defNScenarios ()),
      stochDataMode_    (defStochDataMode ()),
      myStochDataMgr_   (NULL),
      toWriteStochAttr_ (false),
      toSetStochAttr_   (false)
d141 1
a141 1
void WitStochImpMgr::prepSetStochAttr ()
d143 1
a143 1
   stronglyAssert (not toSetStochAttr_);
d145 1
a145 1
   toSetStochAttr_ = true;
d153 1
a153 1
      stronglyAssert (toSetStochAttr_);
d155 1
a155 1
   toSetStochAttr_ = false;
d195 1
a195 1
   prepSetStochAttr ();
d517 1
a517 1
   myStochImpMgr ()->prepSetStochAttr ();
d543 1
a543 1
   myStochImpMgr ()->prepSetStochAttr ();
@


1.59
log
@Stochastic Implosion
@
text
@d337 2
d490 2
d494 7
d551 37
d599 7
a605 6
      scrapVol_       (myProblem (), 0.0),
      stockVol_       (myProblem (), 0.0),
      shipVol_        (myProblem (), 0.0),
      cumShipVol_     (myProblem (), 0.0),
      execVol_        (myProblem (), 0.0),
      subVol_         (myProblem (), 0.0)
d637 7
d730 12
d791 1
a791 3
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;
a797 1
      shipVol_   (theDemand) = theDemand->shipVol   ();
a798 6

   forEachOperation (theOpn, myProblem ())
      execVol_ (theOpn) = theOpn->execVol ();

   forEachSubEntry (theSub, myProblem ())
      subVol_ (theSub) = theSub->subVol ();
@


1.58
log
@Stochastic Implosion
@
text
@d26 1
d335 2
@


1.57
log
@Stochastic Implosion
@
text
@d15 1
a15 1
//    StochMgr
d20 1
a20 1
#include <StochMgr.h>
d35 1
a35 1
// Implementation of class StochMgr.
d38 1
a38 1
WitStochMgr::WitStochMgr (WitProblem * theProblem):
d54 1
a54 1
WitStochMgr::~WitStochMgr ()
d61 1
a61 1
void WitStochMgr::copyAttrsFrom (WitStochMgr * theStochMgr)
d63 3
a65 3
   stochImpAllowed_ = theStochMgr->stochImpAllowed_;
   stageByObject_   = theStochMgr->stageByObject_;
   nScenarios_      = theStochMgr->nScenarios_;
d67 2
a68 2
   if (stochDataMode_ != theStochMgr->stochDataMode_)
      setStochDataMode (theStochMgr->stochDataMode_);
d71 1
a71 1
      myStochDataMgr ()->copyAttrsFrom (theStochMgr->myStochDataMgr ());
d76 1
a76 1
void WitStochMgr::writeData ()
d97 1
a97 1
void WitStochMgr::prepWriteStochAttr ()
d106 1
a106 1
bool WitStochMgr::skipVectorWrite ()
d119 1
a119 1
void WitStochMgr::prepWriteVector ()
d127 1
a127 1
void WitStochMgr::display ()
d140 1
a140 1
void WitStochMgr::prepSetStochAttr ()
d149 1
a149 1
void WitStochMgr::prepSetAttr ()
d159 1
a159 1
void WitStochMgr::setStochImpAllowed (bool theValue)
d166 1
a166 1
void WitStochMgr::setStageByObject (bool theValue)
d177 1
a177 1
void WitStochMgr::setNScenarios (int theValue)
d190 1
a190 1
void WitStochMgr::setStochDataMode (bool theValue)
d215 1
a215 1
void WitStochMgr::implode ()
d222 1
a222 1
void WitStochMgr::discardSoln ()
d229 1
a229 1
void WitStochMgr::setScenarioIndex (int theIdx)
d236 1
a236 1
void WitStochMgr::setProbability (double theValue)
d243 1
a243 1
int WitStochMgr::scenarioIndex ()
d250 1
a250 1
double WitStochMgr::probability ()
d257 1
a257 1
bool WitStochMgr::stochSolnMode ()
d264 1
a264 1
bool WitStochMgr::writeDataNeeded ()
d280 1
a280 1
void WitStochMgr::writeDataID ()
d288 1
a288 1
void WitStochMgr::writeDataAttrs ()
d314 2
a315 2
      nScenarios_    (myStochMgr ()->nScenarios ()),
      myScenarios_   (myStochMgr ()->nScenarios ()),
d326 1
a326 1
   if (not myStochMgr ()->stageByObject ())
d496 1
a496 1
   return 1.0 / static_cast <double> (myStochMgr ()->nScenarios ());
d503 1
a503 1
   myStochMgr ()->prepSetStochAttr ();
d529 1
a529 1
   myStochMgr ()->prepSetStochAttr ();
@


1.56
log
@Stochastic Implosion
@
text
@d16 1
a16 1
//    StochImploder
d21 1
a21 1
#include <StochImploder.h>
d46 1
a46 1
      myStochImploder_  (NULL),
d56 1
a56 1
   delete myStochImploder_;
d71 1
a71 1
      myStochImploder ()->copyAttrsFrom (theStochMgr->myStochImploder ());
d90 1
a90 1
      myStochImploder ()->writeData ();
d122 1
a122 1
      myStochImploder ()->prepWriteVector ();
d135 1
a135 1
      myStochImploder ()->display ();
d202 1
a202 1
      myStochImploder_ = new WitStochImploder (myProblem ());
d205 1
a205 1
      delete myStochImploder_;
d207 1
a207 1
      myStochImploder_ = NULL;
d217 1
a217 1
   myStochImploder ()->implode ();
d224 1
a224 1
   myStochImploder ()->discardSoln ();
d231 1
a231 1
   myStochImploder ()->setScenarioIndex (theIdx);
d238 1
a238 1
   myStochImploder ()->setProbability (theValue);
d245 1
a245 1
   return myStochImploder ()->curScenario ()->myIndex ();
d252 1
a252 1
   return myStochImploder ()->probability ();
d259 1
a259 1
   return myStochImploder ()->stochSolnMode ();
d307 1
a307 1
// Implementation of class StochImploder.
d310 1
a310 1
WitStochImploder::WitStochImploder (WitProblem * theProblem):
d338 1
a338 1
WitStochImploder::~WitStochImploder ()
d355 1
a355 1
void WitStochImploder::copyAttrsFrom (WitStochImploder * theStochImploder)
d360 1
a360 1
   theIdx       = theStochImploder->curScenario_->myIndex ();
d364 1
a364 1
   probability_ = theStochImploder->probability_;
d368 1
a368 1
      theScenario = theStochImploder->myScenarios_[theIdx];
d376 1
a376 1
void WitStochImploder::writeData ()
d393 1
a393 1
void WitStochImploder::startWriteCompData (WitComponent * theComp)
d402 1
a402 1
void WitStochImploder::prepWriteVector ()
d415 1
a415 1
void WitStochImploder::finishWriteCompData ()
d428 1
a428 1
void WitStochImploder::display ()
d443 1
a443 1
void WitStochImploder::implode ()
d483 1
a483 1
void WitStochImploder::discardSoln ()
d494 1
a494 1
double WitStochImploder::defProbability ()
d501 1
a501 1
void WitStochImploder::setScenarioIndex (int theIdx)
d524 1
a524 1
void WitStochImploder::setProbability (double theValue)
d540 1
a540 1
WitScenario::WitScenario (WitStochImploder * theStochImploder, int theIdx):
d542 1
a542 1
      WitProbAssoc     (theStochImploder->myProblem ()),
d544 10
a553 10
      myStochImploder_ (theStochImploder),
      myIndex_         (theIdx),
      probability_     (0.0),
      demandVol_       (myProblem (), 0.0),
      scrapVol_        (myProblem (), 0.0),
      stockVol_        (myProblem (), 0.0),
      shipVol_         (myProblem (), 0.0),
      cumShipVol_      (myProblem (), 0.0),
      execVol_         (myProblem (), 0.0),
      subVol_          (myProblem (), 0.0)
d568 1
a568 1
   stronglyAssert (this == myStochImploder_->curScenario ());
d583 1
a583 1
   stronglyAssert (this == myStochImploder_->curScenario ());
d618 1
a618 1
   stronglyAssert (this == myStochImploder_->curScenario ());
d620 1
a620 1
   WitStochAccess::probability (myStochImploder_) = probability_;
d640 1
a640 1
   stronglyAssert (this == myStochImploder_->curScenario ());
d685 1
a685 1
   writeStochImploderData ();
d724 1
a724 1
   probability_ = myStochImploder_->probability ();
d741 1
a741 1
void WitScenario::writeStochImploderData ()
d745 1
a745 1
   defScenProb = myStochImploder_->defProbability ();
d769 1
a769 1
      myStochImploder_->startWriteCompData (theDemand);
d776 1
a776 1
      myStochImploder_->finishWriteCompData ();
@


1.55
log
@Stochastic Implosion
@
text
@d257 1
a257 1
bool WitStochMgr::stochSolnExists ()
d259 1
a259 1
   return myStochImploder ()->stochSolnExists ();
d312 1
a312 1
      WitProbAssoc     (theProblem),
d314 7
a320 7
      nScenarios_      (myStochMgr ()->nScenarios ()),
      myScenarios_     (myStochMgr ()->nScenarios ()),
      curScenario_     (NULL),
      probability_     (defProbability ()),
      stochSolnExists_ (false),
      curWriteComp_    (NULL),
      vectorWritten_   (false)
d342 1
a342 1
   if (stochSolnExists_)
d380 1
a380 1
   if (not stochSolnExists_)
d432 1
a432 1
   if (not stochSolnExists_)
d450 1
a450 1
   stronglyAssert (not stochSolnExists_);
d469 1
a469 1
   curScenario_     = origCurScenario;
d476 1
a476 1
   stochSolnExists_ = true;
d478 1
a478 1
   myMsgFac () ("stochSolnCompMsg");
d485 1
a485 1
   stronglyAssert (stochSolnExists_);
d487 1
a487 1
   stochSolnExists_ = false;
d489 1
a489 1
   myMsgFac () ("stochSolnDiscMsg");
d507 1
a507 1
   if (not stochSolnExists_)
d514 1
a514 1
   if (stochSolnExists_)
@


1.54
log
@Stochastic Implosion
@
text
@d515 1
d517 3
d624 3
a626 1
      WitStochAccess::demandVol  (theDemand) = demandVol_  (theDemand);
@


1.53
log
@Stochastic Implosion
@
text
@a502 2
   stronglyAssert (not stochSolnExists_);

@


1.52
log
@Stochastic Implosion
@
text
@d24 1
d380 2
a381 1
   curScenario_->saveStochAttrs ();
d432 2
a433 1
   curScenario_->saveStochAttrs ();
d445 3
d454 21
a474 1
   myOptImploder ()->implode ();
d509 2
a510 1
   curScenario_->saveStochAttrs ();
d514 4
a517 1
   curScenario_->restoreStochAttrs ();
d545 1
a547 1
      demandVol_       (myProblem (), 0.0),
d553 1
a553 1
   saveStochAttrsInt ();
d564 1
a564 1
void WitScenario::saveStochAttrs ()
d568 1
a568 4
   if (myStochImploder_->stochSolnExists ())
      return;

   saveStochAttrsInt ();
d573 1
a573 1
void WitScenario::restoreStochAttrs ()
d583 35
d620 18
d640 1
a640 1
        WitOptAccess::scrapVol   (thePart)   = scrapVol_   (thePart);
d645 1
a645 1
        WitOptAccess::stockVol   (theMat)    = stockVol_   (theMat);
d650 2
a651 3
      WitStochAccess::demandVol  (theDemand) = demandVol_  (theDemand);
        WitOptAccess::shipVol    (theDemand) = shipVol_    (theDemand);
        WitOptAccess::cumShipVol (theDemand) = cumShipVol_ (theDemand);
d656 1
a656 1
        WitOptAccess::execVol    (theOpn)    = execVol_    (theOpn);
d661 1
a661 1
        WitOptAccess::subVol     (theSub)    = subVol_     (theSub);
d714 1
a714 1
void WitScenario::saveStochAttrsInt ()
@


1.51
log
@Stochastic Implosion
@
text
@d29 1
d515 2
d519 1
d538 3
d548 2
d558 10
d570 3
a572 2
      WitStochAccess::demandVol (theDemand) = demandVol_ (theDemand);
      WitStochAccess::shipVol   (theDemand) = shipVol_   (theDemand);
d576 3
a578 1
      WitStochAccess::execVol (theOpn) = execVol_ (theOpn);
d581 3
a583 1
      WitStochAccess::subVol (theSub) = subVol_ (theSub);
@


1.50
log
@Stochastic Implosion
@
text
@d516 2
a517 1
      execVol_         (myProblem (), 0.0)
d543 1
d557 3
d615 1
d627 3
@


1.49
log
@Stochastic Implosion
@
text
@d515 2
a516 1
      shipVol_         (myProblem (), 0.0)
d540 2
a541 1
   WitDemand * theDemand;
d552 3
d608 2
a609 1
   WitDemand * theDemand;
d618 3
@


1.48
log
@Stochastic Implosion
@
text
@d514 2
a515 1
      demandVol_       (myProblem (), 0.0)
d546 1
d548 2
d608 1
d610 2
@


1.47
log
@Stochastic Implosion
@
text
@d38 1
a38 1
      WitProbAssoc     (theProblem),
d40 7
a46 6
      stochImpAllowed_ (false),
      stageByObject_   (defStageByObject ()),
      nScenarios_      (defNScenarios ()),
      stochDataMode_   (defStochDataMode ()),
      myStochImploder_ (NULL),
      nextAttrIsStoch_ (false)
d95 22
d138 1
a138 1
void WitStochMgr::willSetStochAttr ()
d140 1
a140 1
   stronglyAssert (not nextAttrIsStoch_);
d142 1
a142 1
   nextAttrIsStoch_ = true;
d147 1
a147 1
void WitStochMgr::settingAttr ()
d150 1
a150 1
      stronglyAssert (nextAttrIsStoch_);
d152 1
a152 1
   nextAttrIsStoch_ = false;
d168 1
a168 1
   myProblem ()->settingUnpostAttr ();
d181 1
a181 1
   myProblem ()->settingUnpostAttr ();
d192 1
a192 1
   willSetStochAttr ();
d194 1
a194 1
   myProblem ()->settingUnpostAttr ();
d478 1
a478 1
   myStochMgr ()->willSetStochAttr ();
d480 1
a480 1
   myProblem ()->settingUnpostAttr ();
d496 1
a496 1
   myStochMgr ()->willSetStochAttr ();
d498 1
a498 1
   myProblem ()->settingUnpostAttr ();
@


1.46
log
@Stochastic Implosion
@
text
@d213 1
a213 1
   myStochImploder ()->curScenario ()->setProbability (theValue);
d227 1
a227 1
   return myStochImploder ()->curScenario ()->probability ();
d292 1
d339 2
d444 7
d467 14
d490 1
a490 1
      probability_     (defProbability ()),
d519 2
d541 1
a541 1
   writeProbability ();
a573 21
double WitScenario::defProbability ()
   {
   return 1.0 / static_cast <double> (myStochMgr ()->nScenarios ());
   }

//------------------------------------------------------------------------------

void WitScenario::setProbability (double theValue)
   {
   stronglyAssert (theValue >= 0.0);
   stronglyAssert (theValue <= 1.0 + FEAS_TOL);

   myStochMgr ()->willSetStochAttr ();

   myProblem ()->settingUnpostAttr ();

   probability_ = theValue;
   }

//------------------------------------------------------------------------------

d578 2
d586 1
a586 1
void WitScenario::writeProbability ()
d590 1
a590 1
   defScenProb = defProbability ();
d592 4
a595 5
   if (probability_ == defScenProb)
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
d597 4
a600 4
   myDataWriter ()->writeDouble (
      "probability",
       probability_,
       defScenProb);
d602 2
a603 1
   myDataWriter ()->writeEndCommand ();
@


1.45
log
@Stochastic Implosion
@
text
@d211 1
a211 1
void WitStochMgr::setScenarioProb (double theValue)
d213 1
a213 1
   myStochImploder ()->curScenario ()->setScenarioProb (theValue);
d225 1
a225 1
double WitStochMgr::scenarioProb ()
d227 1
a227 1
   return myStochImploder ()->curScenario ()->scenarioProb ();
d466 1
a466 1
      scenarioProb_    (defScenarioProb ()),
d503 2
a504 2
   scenarioProb_ = theScenario->scenarioProb_;
   demandVol_    = theScenario->demandVol_;
d515 1
a515 1
   writeScenarioProb ();
d541 1
a541 1
      scenarioProb_);
d548 1
a548 1
double WitScenario::defScenarioProb ()
d555 1
a555 1
void WitScenario::setScenarioProb (double theValue)
d564 1
a564 1
   scenarioProb_ = theValue;
d579 1
a579 1
void WitScenario::writeScenarioProb ()
d583 1
a583 1
   defScenProb = defScenarioProb ();
d585 1
a585 1
   if (scenarioProb_ == defScenProb)
d592 2
a593 2
      "scenarioProb",
       scenarioProb_,
@


1.44
log
@Stochastic Implosion
@
text
@d44 2
a45 1
      myStochImploder_ (NULL)
d115 19
d169 3
a171 1
   myProblem ()->settingStochAttr ();
d445 4
d560 4
@


1.43
log
@Stochastic Implosion
@
text
@d421 2
@


1.42
log
@Stochastic Implosion
@
text
@d43 1
a43 1
      stochasticMode_  (defStochasticMode ()),
d63 2
a64 2
   if (stochasticMode_ != theStochMgr->stochasticMode_)
      setStochasticMode (theStochMgr->stochasticMode_);
d66 1
a66 1
   if (stochasticMode_)
d85 1
a85 1
   if (stochasticMode_)
d95 1
a95 1
   if (stochasticMode_)
d104 1
a104 1
      stochasticMode_,
d108 1
a108 1
   if (stochasticMode_)
d145 1
a145 1
void WitStochMgr::setStochasticMode (bool theValue)
d151 1
a151 1
   if (theValue == stochasticMode_)
d163 1
a163 1
   stochasticMode_ = theValue;
d225 1
a225 1
   if (stochasticMode_)
d254 3
a256 3
        "stochasticMode",
         stochasticMode_,
      defStochasticMode ());
@


1.41
log
@Stochastic Implosion
@
text
@d151 6
a156 1
   if (theValue != stochasticMode_)
d158 1
a158 5
      if (theValue)
         myStochImploder_ = new WitStochImploder (myProblem ());
      else
         {
         delete myStochImploder_;
d160 1
a160 2
         myStochImploder_ = NULL;
         }
d170 4
a173 1
   stronglyAssert (WitOptComp::optImpAllowed ());
d175 3
a177 1
   myStochImploder ()->implode ();
d210 1
a210 1
bool WitStochMgr::stochSolnAvail ()
d212 1
a212 1
   return myStochImploder ()->stochSolnAvail ();
d265 1
a265 1
      WitProbAssoc    (theProblem),
d267 6
a272 6
      nScenarios_     (myStochMgr ()->nScenarios ()),
      myScenarios_    (myStochMgr ()->nScenarios ()),
      curScenario_    (NULL),
      stochSolnAvail_ (false),
      curWriteComp_   (NULL),
      vectorWritten_  (false)
d294 3
d393 4
d400 15
@


1.40
log
@Stochastic Implosion
@
text
@d205 7
d260 1
a260 1
      WitProbAssoc   (theProblem),
d262 6
a267 5
      nScenarios_    (myStochMgr ()->nScenarios ()),
      myScenarios_   (myStochMgr ()->nScenarios ()),
      curScenario_   (NULL),
      curWriteComp_  (NULL),
      vectorWritten_ (false)
@


1.39
log
@Stochastic Implosion
@
text
@d24 1
a24 1
#include <Post.h>
d379 1
a379 1
   myPostprocessor ()->postprocess ();
@


1.38
log
@Stochastic Implosion
@
text
@d43 1
a43 1
      stochImpMode_    (defStochImpMode ()),
d63 2
a64 2
   if (stochImpMode_ != theStochMgr->stochImpMode_)
      setStochImpMode (theStochMgr->stochImpMode_);
d66 1
a66 1
   if (stochImpMode_)
d85 1
a85 1
   if (stochImpMode_)
d95 1
a95 1
   if (stochImpMode_)
d104 1
a104 1
      stochImpMode_,
d108 1
a108 1
   if (stochImpMode_)
d145 1
a145 1
void WitStochMgr::setStochImpMode (bool theValue)
d151 1
a151 1
   if (theValue != stochImpMode_)
d163 1
a163 1
   stochImpMode_ = theValue;
d213 1
a213 1
   if (stochImpMode_)
d242 3
a244 3
        "stochImpMode",
         stochImpMode_,
      defStochImpMode ());
d367 1
a367 1
   myMsgFac () ("stochModeMgrDdMsg", curScenario_->myIndex ());
@


1.37
log
@Stochastic Implosion
@
text
@d24 1
d28 1
d170 2
d378 2
@


1.36
log
@Stochastic Implosion
@
text
@d173 1
a173 1
void WitStochMgr::setScenarioIndex (int theValue)
d175 1
a175 5
   WitScenario * theScenario;

   theScenario = myStochImploder ()->myScenario (theValue);

   myStochImploder ()->setCurScenario (theScenario);
d268 1
a268 1
   curScenario_ = myScenario (0);
d282 1
a282 1
      delete myScenario (theIdx);
d294 1
a294 1
   curScenario_ = myScenario (theIdx);
d298 1
a298 1
      theScenario = theStochImploder->myScenario (theIdx);
d300 1
a300 1
      myScenario (theIdx)->copyAttrsFrom (theScenario);
d313 1
a313 1
      myScenario (theIdx)->writeData ();
d366 1
a366 1
      myScenario (theIdx)->display ();
d378 1
a378 1
void WitStochImploder::setCurScenario (WitScenario * theScenario)
a379 3
   stronglyAssert (theScenario != NULL);
   stronglyAssert (theScenario->myProblem () == myProblem ());

d382 1
a382 1
   curScenario_ = theScenario;
@


1.35
log
@Stochastic Implosion
@
text
@d166 7
d375 7
@


1.34
log
@Stochastic Implosion
@
text
@d16 1
a16 1
//    StochModeMgr
d21 1
a21 1
#include <StochMode.h>
d42 1
a42 1
      myStochModeMgr_  (NULL)
d50 1
a50 1
   delete myStochModeMgr_;
d65 1
a65 1
      myStochModeMgr ()->copyAttrsFrom (theStochMgr->myStochModeMgr ());
d84 1
a84 1
      myStochModeMgr ()->writeData ();
d91 1
a91 1
void WitStochMgr::writingVector ()
d94 1
a94 1
      myStochModeMgr ()->writingVector ();
d107 1
a107 1
      myStochModeMgr ()->display ();
d152 1
a152 1
         myStochModeMgr_ = new WitStochModeMgr (myProblem ());
d155 1
a155 1
         delete myStochModeMgr_;
d157 1
a157 1
         myStochModeMgr_ = NULL;
d170 1
a170 1
   theScenario = myStochModeMgr ()->myScenario (theValue);
d172 1
a172 1
   myStochModeMgr ()->setCurScenario (theScenario);
d179 1
a179 1
   myStochModeMgr ()->curScenario ()->setScenarioProb (theValue);
d186 1
a186 1
   return myStochModeMgr ()->curScenario ()->myIndex ();
d193 1
a193 1
   return myStochModeMgr ()->curScenario ()->scenarioProb ();
d241 1
a241 1
// Implementation of class StochModeMgr.
d244 1
a244 1
WitStochModeMgr::WitStochModeMgr (WitProblem * theProblem):
d270 1
a270 1
WitStochModeMgr::~WitStochModeMgr ()
d284 1
a284 1
void WitStochModeMgr::copyAttrsFrom (WitStochModeMgr * theStochModeMgr)
d286 2
a287 1
   int theIdx;
d289 1
a289 1
   theIdx       = theStochModeMgr->curScenario_->myIndex ();
d294 5
a298 1
      myScenario (theIdx)->copyAttrsFrom (theStochModeMgr->myScenario (theIdx));
d303 1
a303 1
void WitStochModeMgr::writeData ()
d319 1
a319 1
void WitStochModeMgr::startWriteCompData (WitComponent * theComp)
d328 1
a328 1
void WitStochModeMgr::writingVector ()
d341 1
a341 1
void WitStochModeMgr::finishWriteCompData ()
d354 1
a354 1
void WitStochModeMgr::display ()
d368 1
a368 1
void WitStochModeMgr::setCurScenario (WitScenario * theScenario)
d384 1
a384 1
WitScenario::WitScenario (WitStochModeMgr * theStochModeMgr, int theIdx):
d386 1
a386 1
      WitProbAssoc    (theStochModeMgr->myProblem ()),
d388 4
a391 4
      myStochModeMgr_ (theStochModeMgr),
      myIndex_        (theIdx),
      scenarioProb_   (defScenarioProb ()),
      demandVol_      (myProblem (), 0.0)
d406 1
a406 1
   stronglyAssert (this == myStochModeMgr_->curScenario ());
d417 1
a417 1
   stronglyAssert (this == myStochModeMgr_->curScenario ());
d527 1
a527 1
      myStochModeMgr_->startWriteCompData (theDemand);
d534 1
a534 1
      myStochModeMgr_->finishWriteCompData ();
@


1.33
log
@Stochastic Implosion
@
text
@d166 11
@


1.32
log
@Stochastic Implosion
@
text
@d166 21
@


1.31
log
@Stochastic Implosion
@
text
@d27 1
d270 1
a270 1
   curScenario_->storeStochAttrs ();
d321 1
a321 1
   curScenario_->storeStochAttrs ();
a332 2
   WitComponent * theComp;

d336 1
a336 1
   curScenario_->storeStochAttrs ();
d340 1
a340 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->retrieveStochAttrs ();
d356 1
a356 1
   storeStochAttrsInt ();
d367 1
a367 1
void WitScenario::storeStochAttrs ()
d369 1
a369 1
   stronglyAssert (this == myStochMgr ()->myStochModeMgr ()->curScenario ());
d371 13
a383 1
   storeStochAttrsInt ();
d452 1
a452 1
void WitScenario::storeStochAttrsInt ()
d457 1
a457 8
      storeStochAttrs (theDemand);
   }

//------------------------------------------------------------------------------

void WitScenario::storeStochAttrs (WitDemand * theDemand)
   {
   demandVol_ (theDemand) = theDemand->demandVol ();
@


1.30
log
@Stochastic Implosion
@
text
@d90 8
d213 1
a213 1
      WitProbAssoc (theProblem),
d215 5
a219 3
      nScenarios_  (myStochMgr ()->nScenarios ()),
      myScenarios_ (myStochMgr ()->nScenarios ()),
      curScenario_ (NULL)
d281 35
d351 1
a351 1
      WitProbAssoc  (theStochModeMgr->myProblem ()),
d353 4
a356 3
      myIndex_      (theIdx),
      scenarioProb_ (defScenarioProb ()),
      demandVol_    (myProblem (), 0.0)
d486 7
a492 11
      if (not (demandVol_ (theDemand) == WitDemand::defDemandVol ()))
         {
         myDataWriter ()->writeFirstKeyWord ("set");
         myDataWriter ()->writeKeyWord      ("demand");
         myDataWriter ()->writeStringValue  (theDemand->demandedPartName ());
         myDataWriter ()->writeStringValue  (theDemand->demandName ());

         myDataWriter ()->writeVector (
            "demandVol",
            demandVol_ (theDemand),
            WitDemand::defDemandVol ());
d494 2
a495 2
         myDataWriter ()->writeEndCommand ();
         }
@


1.29
log
@Stochastic Implosion
@
text
@d83 1
a83 1
      myStochModeMgr ()->writeDataAttrs ();
d255 1
a255 1
void WitStochModeMgr::writeDataAttrs ()
d259 2
d275 2
@


1.28
log
@Stochastic Implosion
@
text
@d343 2
d431 23
@


1.27
log
@Stochastic Implosion
@
text
@d331 1
@


1.26
log
@Stochastic Implosion
@
text
@d366 2
d425 19
@


1.25
log
@Stochastic implosion
@
text
@d16 1
a16 1
//    StochProb
d21 1
a21 1
#include <StochProb.h>
d41 1
a41 1
      myStochProb_     (NULL)
d49 1
a49 1
   delete myStochProb_;
d64 1
a64 1
      myStochProb ()->copyAttrsFrom (theStochMgr->myStochProb ());
d83 1
a83 1
      myStochProb ()->writeDataAttrs ();
d98 1
a98 1
      myStochProb ()->display ();
d143 1
a143 1
         myStochProb_ = new WitStochProb (myProblem ());
d146 1
a146 1
         delete myStochProb_;
d148 1
a148 1
         myStochProb_ = NULL;
d200 1
a200 1
// Implementation of class StochProb.
d203 1
a203 1
WitStochProb::WitStochProb (WitProblem * theProblem):
d227 1
a227 1
WitStochProb::~WitStochProb ()
d241 1
a241 1
void WitStochProb::copyAttrsFrom (WitStochProb * theStochProb)
d245 1
a245 1
   theIdx       = theStochProb->curScenario_->myIndex ();
d250 1
a250 1
      myScenario (theIdx)->copyAttrsFrom (theStochProb->myScenario (theIdx));
d255 1
a255 1
void WitStochProb::writeDataAttrs ()
d269 1
a269 1
void WitStochProb::display ()
d273 1
a273 1
   myMsgFac () ("stochProbDdMsg", curScenario_->myIndex ());
d281 1
a281 1
void WitStochProb::setCurScenario (WitScenario * theScenario)
d300 1
a300 1
WitScenario::WitScenario (WitStochProb * theStochProb, int theIdx):
d302 1
a302 1
      WitProbAssoc  (theStochProb->myProblem ()),
d321 1
a321 1
   stronglyAssert (this == myStochMgr ()->myStochProb ()->curScenario ());
@


1.24
log
@Stochastic Implosion
@
text
@d25 2
d283 2
d288 2
d291 3
d305 2
a306 1
      scenarioProb_ (defScenarioProb ())
d308 1
d319 9
d387 17
@


1.23
log
@Stochastic Implosion
@
text
@d35 1
a35 1
      stochImpAllowed_ (),
d54 3
a56 2
   stageByObject_ = theStochMgr->stageByObject_;
   nScenarios_    = theStochMgr->nScenarios_;
@


1.22
log
@Stochastic Implosion
@
text
@d242 1
a242 1
   theIdx        = theStochProb->curScenario_->myIndex ();
d244 4
a247 1
   curScenario_  = myScenario (theIdx);
d307 7
@


1.21
log
@Stochastic Implosion
@
text
@d265 2
d268 3
d330 9
@


1.20
log
@Stochastic Implosion.
@
text
@d256 1
a256 2
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
d258 1
a258 6
   myDataWriter ()->writeInt (
      "scenarioIndex",
       curScenario_->myIndex (),
       -1);

   myDataWriter ()->writeEndCommand ();
d301 11
d315 1
a315 1
   myDataWriter ()->writeInt (
d339 22
@


1.19
log
@Stochastic Implosion
@
text
@d77 2
a81 2
   myDataWriter ()->writeEndCommand ();

d251 8
d262 3
a264 1
       0);
d305 15
@


1.18
log
@Stochastic Implosion
@
text
@d13 1
a13 1
// Contains the implementation of the following class:
d17 1
d162 1
a162 1
   if (stochImpMode_ != defStochImpMode ())
d202 1
a202 1
      WitProbAssoc  (theProblem),
d204 3
a206 4
      nScenarios_   (myStochMgr ()->nScenarios ()),
      myScenarios_  (myStochMgr ()->nScenarios ()),
      curScenario_  (NULL),
      scenarioProb_ (0.0)
d219 1
a219 3
   curScenario_  = myScenario (0);

   scenarioProb_ = defScenarioProb ();
a244 2

   scenarioProb_ = theStochProb->scenarioProb_;
a254 5

   myDataWriter ()->writeDouble (
      "scenarioProb",
       scenarioProb_,
       defScenarioProb ());
d261 1
a261 10
   myMsgFac () ("stochProbDdMsg",
      curScenario_->myIndex (),
      scenarioProb_);
   }

//------------------------------------------------------------------------------

double WitStochProb::defScenarioProb ()
   {
   return 1.0 / static_cast <double> (nScenarios_);
d271 1
a271 15
   curScenario_->storeStochAttrs ();

   curScenario_  = theScenario;

   scenarioProb_ = curScenario_->scenarioProb ();
   }

//------------------------------------------------------------------------------

void WitStochProb::setScenarioProb (double theValue)
   {
   stronglyAssert (theValue >= 0.0);
   stronglyAssert (theValue <= 1.0 + FEAS_TOL);

   scenarioProb_ = theValue;
d283 1
a283 1
      scenarioProb_ (theStochProb->scenarioProb ())
d295 8
a302 1
void WitScenario::storeStochAttrs ()
d304 2
a305 1
   stronglyAssert (myStochMgr ()->myStochProb ()->curScenario () == this);
d307 1
a307 1
   scenarioProb_ = myStochMgr ()->myStochProb ()->scenarioProb ();
@


1.17
log
@Stochastic Implosion.
@
text
@d201 1
a201 1
      WitProbAssoc (theProblem),
d203 4
a206 4
      nScenarios_  (myStochMgr ()->nScenarios ()),
      myScenarios_ (myStochMgr ()->nScenarios ()),
      curScenario_ (NULL),
      probability_ (0.0)
d219 1
a219 1
   curScenario_ = myScenario (0);
d221 1
a221 1
   probability_ = defProbability ();
d244 1
a244 1
   theIdx       = theStochProb->curScenario_->myIndex ();
d246 1
a246 1
   curScenario_ = myScenario (theIdx);
d248 1
a248 1
   probability_ = theStochProb->probability_;
d261 3
a263 3
      "probability",
       probability_,
       defProbability ());
d272 1
a272 1
      probability_);
d277 1
a277 1
double WitStochProb::defProbability ()
d291 1
a291 1
   curScenario_ = theScenario;
d293 1
a293 1
   probability_ = curScenario_->probability ();
d298 1
a298 1
void WitStochProb::setProbability (double theValue)
d303 1
a303 1
   probability_ = theValue;
d312 1
a312 1
      WitProbAssoc (theStochProb->myProblem ()),
d314 2
a315 2
      myIndex_     (theIdx),
      probability_ (theStochProb->probability ())
d331 1
a331 1
   probability_ = myStochMgr ()->myStochProb ()->probability ();
@


1.16
log
@Stochastic Implosion
@
text
@d216 2
a217 1
      myScenarios_[theIdx] = new WitScenario (myProblem (), theIdx);
d289 2
d292 2
d310 1
a310 1
WitScenario::WitScenario (WitProblem * theProblem, int theIdx):
d312 1
a312 1
      WitProbAssoc (theProblem),
d314 2
a315 1
      myIndex_     (theIdx)
d324 9
@


1.15
log
@Stochastic Implosion
@
text
@d77 1
a77 1
      myStochProb ()->writeData ();
d205 2
a206 1
      curScenario_ (NULL)
d219 2
d246 2
d252 1
a252 1
void WitStochProb::writeData ()
d258 5
d269 10
a278 1
   myMsgFac () ("sipDdMsg", curScenario_->myIndex ());
d292 10
@


1.14
log
@Stochastic Implosion
@
text
@d16 1
a16 1
//    SIP
d20 1
a20 1
#include <SIP.h>
d38 1
a38 1
      mySIP_           (NULL)
d46 1
a46 1
   delete mySIP_;
d60 1
a60 1
      mySIP ()->copyAttrsFrom (theStochMgr->mySIP ());
d77 1
a77 1
      mySIP ()->writeData ();
d94 1
a94 1
      mySIP ()->display ();
d139 1
a139 1
         mySIP_ = new WitSIP (myProblem ());
d142 1
a142 1
         delete mySIP_;
d144 1
a144 1
         mySIP_ = NULL;
d196 1
a196 1
// Implementation of class SIP.
d199 1
a199 1
WitSIP::WitSIP (WitProblem * theProblem):
d222 1
a222 1
WitSIP::~WitSIP ()
d236 1
a236 1
void WitSIP::copyAttrsFrom (WitSIP * theSIP)
d240 1
a240 1
   theIdx       = theSIP->curScenario_->myIndex ();
d247 1
a247 1
void WitSIP::writeData ()
d257 1
a257 1
void WitSIP::display ()
d264 1
a264 1
void WitSIP::setCurScenario (WitScenario * theScenario)
@


1.13
log
@Stochastic Implosion
@
text
@a152 14
void WitStochMgr::setScenarioIndex (int theIdx)
   {
   mySIP ()->setCurScenarioByIdx (theIdx);
   }

//------------------------------------------------------------------------------

int WitStochMgr::scenarioIndex ()
   {
   return mySIP ()->curScenario ()->myIndex ();
   }

//------------------------------------------------------------------------------

d217 1
a217 1
   curScenario_ = myScenarios_[0];
d231 1
a231 5
      {
      delete myScenarios_[theIdx];

      myScenarios_[theIdx] = NULL;
      }
d238 5
a242 1
   setCurScenarioByIdx (theSIP->curScenario_->myIndex ());
d264 1
a264 1
void WitSIP::setCurScenarioByIdx (int theIdx)
d266 2
a267 2
   stronglyAssert (theIdx >= 0);
   stronglyAssert (theIdx <  nScenarios_);
d269 1
a269 1
   curScenario_ = myScenarios_[theIdx];
@


1.12
log
@Stochastic Implosion.
@
text
@d21 1
d51 48
d121 2
d153 1
a153 1
void WitStochMgr::copyAttrsFrom (WitStochMgr * theStochMgr)
d155 1
a155 5
   stageByObject_ = theStochMgr->stageByObject_;
   nScenarios_    = theStochMgr->nScenarios_;

   if (stochImpMode_ != theStochMgr->stochImpMode_)
      setStochImpMode (theStochMgr->stochImpMode_);
d160 1
a160 1
void WitStochMgr::writeData ()
d162 1
a162 22
   if (not writeDataNeeded ())
      return;

   myMsgFac () ("stochImpPreCommentWdMsg");

   writeDataID ();

   writeDataAttrs ();

   myDataWriter ()->writeEndCommand ();

   myMsgFac () ("stochImpPostCommentWdMsg");
   }

//------------------------------------------------------------------------------

void WitStochMgr::display ()
   {
   myMsgFac () ("stochImpDdMsg",
      stageByObject_,
      nScenarios_,
      stochImpMode_);
d215 5
a219 1
      WitProbAssoc (theProblem)
d221 2
d227 5
d238 2
d241 61
@


1.11
log
@Stochastic implosion.
@
text
@d16 1
a16 1
//    StProblem
d20 1
a20 1
#include <StProblem.h>
d37 1
a37 1
      myStProblem_     (NULL)
d45 1
a45 1
   delete myStProblem_;
d88 1
a88 1
         myStProblem_ = new WitStProblem (myProblem ());
d91 1
a91 1
         delete myStProblem_;
d93 1
a93 1
         myStProblem_ = NULL;
d184 1
a184 1
// Implementation of class StProblem.
d187 1
a187 1
WitStProblem::WitStProblem (WitProblem * theProblem):
d199 1
a199 1
WitStProblem::~WitStProblem ()
@


1.10
log
@Stochastic implosion.
@
text
@d36 1
a36 1
      active_          (defActive ()),
d79 1
a79 1
void WitStochMgr::setActive (bool theValue)
d85 1
a85 1
   if (theValue != active_)
d97 1
a97 1
   active_ = theValue;
d107 2
a108 2
   if (active_   != theStochMgr->active_)
      setActive (theStochMgr->active_);
d136 1
a136 1
      active_);
d149 1
a149 1
   if (active_ != defActive ())
d178 3
a180 3
        "stochImpActive",
         active_,
      defActive ());
d191 1
a191 1
   myMsgFac () ("actStochImpMsg");
d194 1
a194 1
      myMsgFac () ("actWoStageByObjectSmsg");
d201 1
a201 1
   myMsgFac () ("deactStochImpMsg");
@


1.9
log
@Stochastic implosion.
@
text
@d83 1
a83 1
   myProblem ()->resetSoln ();
@


1.8
log
@Stochastic implosion.
@
text
@d22 1
d61 1
a61 1
   myProblem ()->resetSoln ();
d72 1
a72 1
   myProblem ()->resetSoln ();
a82 2
   settingStochAttr ();

a140 16
void WitStochMgr::settingStochAttr ()
   {
   if (active_)
      myStProblem ()->settingStochAttr ();
   }

//------------------------------------------------------------------------------

void WitStochMgr::resetSoln ()
   {
   if (active_)
      myStProblem ()->resetSoln ();
   }

//------------------------------------------------------------------------------

d189 1
a189 3
      WitProbAssoc      (theProblem),

      stochAttrSetMode_ (false)
a202 18

//------------------------------------------------------------------------------

void WitStProblem::settingStochAttr ()
   {
   stronglyAssert (not stochAttrSetMode_);

   stochAttrSetMode_ = true;
   }

//------------------------------------------------------------------------------

void WitStProblem::resetSoln ()
   {
   stronglyAssert (stochAttrSetMode_);

   stochAttrSetMode_ = false;
   }
@


1.7
log
@Stochastic implosion.
@
text
@d82 2
d142 16
d206 3
a208 1
      WitProbAssoc (theProblem)
d222 18
@


1.6
log
@Stochastic implosion.
@
text
@d35 1
a35 1
      stochImpActive_  (defStochImpActive ()),
d78 1
a78 1
void WitStochMgr::setStochImpActive (bool theValue)
d84 1
a84 1
   if (theValue != stochImpActive_)
d96 1
a96 1
   stochImpActive_ = theValue;
d106 2
a107 2
   if (stochImpActive_ != theStochMgr->stochImpActive_)
      setStochImpActive (theStochMgr->stochImpActive_);
d135 1
a135 1
      stochImpActive_);
d148 1
a148 1
   if (stochImpActive_ != defStochImpActive ())
d178 2
a179 2
         stochImpActive_,
      defStochImpActive ());
@


1.5
log
@Stochastic Implosion.
@
text
@d192 1
a192 1
   if (not myProblem ()->myStochMgr ()->stageByObject ())
@


1.4
log
@Stochastic Implosion.
@
text
@d191 3
@


1.3
log
@Stochastic implosion.
@
text
@d16 1
d20 1
d34 3
a36 1
      nScenarios_      (defNScenarios ())
d44 1
d78 23
d105 3
d134 2
a135 1
      nScenarios_);
d148 3
d175 23
@


1.2
log
@Stochastic implosion.
@
text
@d31 2
a32 1
      stageByObject_   (defStageByObject ())
d62 11
d75 2
a76 1
   stochImpAllowed_ = theStochMgr->stochImpAllowed_;
d83 5
d93 2
d102 15
a116 1
      stageByObject_);
d135 5
@


1.1
log
@Stochastic Implosion.
@
text
@d19 1
d30 2
a31 1
      stochImpAllowed_ ()
d47 55
@


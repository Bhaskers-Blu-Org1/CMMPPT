head	1.35;
access;
symbols;
locks; strict;
comment	@ * @;


1.35
date	2006.03.13.17.02.23;	author rjw;	state dead;
branches;
next	1.34;

1.34
date	2006.03.11.00.03.45;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.10.23.23.31;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.25.00.12.43;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.23.22.42.10;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.22.23.20.34;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.21.21.11.17;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.18.00.42.59;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.18.00.38.49;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.17.20.53.14;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.17.19.30.50;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.16.23.36.21;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2006.02.16.22.37.08;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.16.16.48.45;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.15.16.57.49;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.15.00.07.36;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.14.21.59.09;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.10.23.36.50;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.10.17.25.42;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.10.17.09.52;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.10.16.51.59;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.09.21.54.43;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.07.19.18.43;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.06.23.43.26;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.06.23.24.03;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.06.20.36.00;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.03.21.49.05;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.03.17.05.29;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.03.16.48.13;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.02.22.50.47;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.02.22.37.44;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.01.20.45.46;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.31.23.06.12;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.31.22.40.39;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.31.20.45.31;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.35
log
@GPIP
@
text
@//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Source file: "SrpReq.C"
//
// Contains the implementation of the following classes:
//
//    GpipReqMgr
//    GpipReqSpec
//    GpipReqSrc
//    GpipSeqEl
//------------------------------------------------------------------------------

#include <SrpReqMgr.h>
#include <SrpReqSpec.h>
#include <SrpReqSrc.h>
#include <SrpSeqEl.h>
#include <PipMgr.h>
#include <TripStack.h>
#include <PtrVecSort.h>
#include <Global.h>
#include <Part.h>
#include <Opn.h>
#include <BopEntry.h>
#include <Demand.h>

//------------------------------------------------------------------------------
// Implementation of class GpipReqMgr.
//------------------------------------------------------------------------------

WitGpipReqMgr::WitGpipReqMgr (WitProblem * theProblem):

      WitProbAssoc      (theProblem),

      mySeqElVec_       (),
      myReqSrcs_        (theProblem),
      myVacReqSrc_      (NULL),
      myPartReqs_       (),
      myBopEntReqs_     (),
      myReqSpecVec_     (),
      nReqSpecsInVec_   (0),
      maxReqSpecsInVec_ (0),
      unusedReqSpecs_   (myProblem ()),
      curReqList_       (myProblem ()),
      myReqSpecItr_     (),
      curReqSrc_        (NULL),
      incReqVolCur_     (0.0)
   {
   WitPart *     thePart;
   WitPeriod     fillPer;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   buildSeqEls ();

   myVacReqSrc_ = newReqSrcForSeqNo (mySeqElVec_.length () - 1);

   myPartReqs_.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      forEachPeriod (fillPer, myProblem ())
         myPartReqs_.myPtrAt (thePart, fillPer) =
            new WitGpipReqList (myProblem ());

   myBopEntReqs_.allocate (myProblem ());

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         myBopEntReqs_.myPtrAt (theBopEnt, execPer) =
            new WitGpipReqList (myProblem ());
   }

//------------------------------------------------------------------------------

WitGpipReqMgr::~WitGpipReqMgr ()
   {
   WitPart *     thePart;
   WitPeriod     fillPer;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   int           theSeqNo;

   if (DEVELOPMENT)
      prtSizes ();

   deleteContents (unusedReqSpecs_);

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (execPer, myProblem ())
         delete myBopEntReqs_.myPtrAt (theBopEnt, execPer);

   myBopEntReqs_.clear ();

   forEachPart (thePart, myProblem ())
      forEachPeriod (fillPer, myProblem ())
         delete myPartReqs_.myPtrAt (thePart, fillPer);

   myPartReqs_.clear ();

   myVacReqSrc_ = NULL;

   deleteContents (myReqSrcs_);

   for (theSeqNo = 0; theSeqNo < mySeqElVec_.length (); theSeqNo ++)
      delete mySeqElVec_[theSeqNo];

   mySeqElVec_.clear ();
   }

//------------------------------------------------------------------------------

bool WitGpipReqMgr::hasReqsFor (WitPart * thePart, WitPeriod fillPer)
   {
   return myPartReqs_.myElemAt (thePart, fillPer).isNonEmpty ();
   }

//------------------------------------------------------------------------------

bool WitGpipReqMgr::hasReqsFor (WitOperation * theOpn, WitPeriod execPer)
   {
   WitBopEntry * theBopEnt;

   forEachEl (theBopEnt, theOpn->bop ())
      if (myBopEntReqs_.myElemAt (theBopEnt, execPer).isNonEmpty ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

WitGpipReqSrc * WitGpipReqMgr::newReqSrcForSeqNo (int theSeqNo)
   {
   WitGpipReqSrc * theReqSrc;

   theReqSrc = new WitGpipReqSrc (mySeqElVec_[theSeqNo]);

   myReqSrcs_.push (theReqSrc);

   return theReqSrc;
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::addReq (
      WitPart *       thePart,
      WitPeriod       fillPer,
      WitGpipReqSrc * theReqSrc,
      double          incReqVol)
   {
   WitGpipReqSpec * theReqSpec;

   witAssert (incReqVol > NET_TOL);

   theReqSpec = provideReqSpec (theReqSrc, incReqVol);

   myPartReqs_.myElemAt (thePart, fillPer).push (theReqSpec);
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::addReq (
      WitBopEntry *   theBopEnt,
      WitPeriod       execPer,
      WitGpipReqSrc * theReqSrc,
      double          incExecVol)
   {
   WitGpipReqSpec * theReqSpec;

   witAssert (incExecVol > NET_TOL);

   theReqSpec = provideReqSpec (theReqSrc, incExecVol);

   myBopEntReqs_.myElemAt (theBopEnt, execPer).push (theReqSpec);
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::loadCurReqList (WitPart * thePart, WitPeriod fillPer)
   {
   witAssert (curReqList_.isEmpty ());

   curReqList_.takeContents (myPartReqs_.myElemAt (thePart, fillPer));

   if (curReqList_.isNonEmpty ())
      sortReqList ();
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::loadCurReqList (WitOperation * theOpn, WitPeriod execPer)
   {
   WitBopEntry * theBopEnt;

   witAssert (curReqList_.isEmpty ());

   witAssert (not theOpn->bop ().isEmpty ());

   if (theOpn->bop ().nElements () == 1)
      {
      theBopEnt = theOpn->bop ().first ();

      curReqList_.takeContents (myBopEntReqs_.myElemAt (theBopEnt, execPer));

      curReqList_.reverse ();

      if (myGlobalComp ()->printGpip ())
         prtCurReqList (theOpn, execPer);
      }
   else
      mergeReqs (theOpn, execPer);
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::clearCurReqList ()
   {  
   WitGpipReqSpec * theReqSpec;

   while (curReqList_.pop (theReqSpec))
      reclaimReqSpec (theReqSpec);
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::initReqListItr ()
   {
   WitGpipReqSpec * theReqSpec;

   curReqList_.attachItr (myReqSpecItr_);

   if (myReqSpecItr_.advance (theReqSpec))
      {
      curReqSrc_    = theReqSpec->myReqSrc     ();
      incReqVolCur_ = theReqSpec->incReqVolFor ();
      }
   else
      curReqSrc_    = NULL;
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::advanceReqListItr (
      double &          netReqVol,
      WitGpipReqSrc * & theReqSrc,
      double &          incReqVol)
   {
   WitGpipReqSpec * theReqSpec;

   witAssert (not finishedReqListItr ());

   witAssert (netReqVol > NET_TOL);

   theReqSrc      = curReqSrc_;

   incReqVol      = min (incReqVolCur_, netReqVol);

   incReqVolCur_ -= incReqVol;
   netReqVol     -= incReqVol;

   if (incReqVolCur_ > NET_TOL)
      return;

   if (myReqSpecItr_.advance (theReqSpec))
      {
      curReqSrc_    = theReqSpec->myReqSrc     ();
      incReqVolCur_ = theReqSpec->incReqVolFor ();
      }
   else
      {
      curReqSrc_    = NULL;
      incReqVolCur_ = 0.0;
      }
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::advanceReqListItr (
      WitGpipReqSrc * & theReqSrc,
      double &          incReqVol)
   {
   WitGpipReqSpec * theReqSpec;

   witAssert (not finishedReqListItr ());

   theReqSrc = curReqSrc_;
   incReqVol = incReqVolCur_;

   if (myReqSpecItr_.advance (theReqSpec))
      {
      curReqSrc_    = theReqSpec->myReqSrc     ();
      incReqVolCur_ = theReqSpec->incReqVolFor ();
      }
   else
      {
      curReqSrc_    = NULL;
      incReqVolCur_ = 0.0;
      }
   }

//------------------------------------------------------------------------------

bool WitGpipReqMgr::finishedReqListItr ()
   {
   return (curReqSrc_ == NULL);
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::buildSeqEls ()
   {
   WitDemTripStack theShipSeq (myProblem ());
   int             theSeqNo;
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   double          incShipVol;

   myProblem ()->myPipMgr ()->getShipSeq (theShipSeq);

   mySeqElVec_.resize (theShipSeq.nElements () + 1);

   theSeqNo = -1;

   while (theShipSeq.pop (theDemand, shipPer, incShipVol))
      {
      theSeqNo ++;

      mySeqElVec_[theSeqNo] = new WitGpipSeqEl (theDemand, shipPer, theSeqNo);
      }

   theSeqNo ++;

   mySeqElVec_[theSeqNo] = new WitGpipSeqEl (NULL, -1, theSeqNo);
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::mergeReqs (WitOperation * theOpn, WitPeriod execPer)
   {
   WitBopEntry *      theBopEnt;
   double             incExecVol;
   WitGpipReqSrc *    theReqSrc;
   WitGpipReqSpec *   theReqSpec;
   WitGpipReqSrcStack theReqSrcs (myProblem ());

   witAssert (theOpn->bop ().nElements () > 1);

   forEachEl (theBopEnt, theOpn->bop ())
      myBopEntReqs_.myElemAt (theBopEnt, execPer).reverse ();

   if (myGlobalComp ()->printGpip ())
      prtBopEntReqs (theOpn, execPer);

   while (true)
      {
      incExecVol = minIncReqVol (theOpn, execPer);

      if (incExecVol < 0.0)
         break;

      extractReqSrcs (theOpn, execPer, incExecVol, theReqSrcs);

      theReqSrc = new WitGpipReqSrc (theReqSrcs);

      myReqSrcs_.push (theReqSrc);
      
      theReqSpec = provideReqSpec (theReqSrc, incExecVol);

      curReqList_.push (theReqSpec);
      }

   sortReqList ();
   }

//------------------------------------------------------------------------------

double WitGpipReqMgr::minIncReqVol (WitOperation * theOpn, WitPeriod execPer)
   {
   double        minVol;
   WitBopEntry * theBopEnt;
   double        incReqVol;

   witAssert (theOpn->bop ().nElements () > 1);

   minVol = -1.0;

   forEachEl (theBopEnt, theOpn->bop ())
      if (myBopEntReqs_.myElemAt (theBopEnt, execPer).isNonEmpty ())
         {
         incReqVol =
            myBopEntReqs_.myElemAt (theBopEnt, execPer).
               firstObject ()->
                  incReqVolFor ();

         if (minVol < 0.0)
            minVol = incReqVol;
         else
            setToMin (minVol, incReqVol);
         }

   return minVol;
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::extractReqSrcs (
      WitOperation *       theOpn,
      WitPeriod            execPer,
      double               deltaIncReqVol,
      WitGpipReqSrcStack & theReqSrcs)
   {
   WitBopEntry *    theBopEnt;
   WitGpipReqSpec * theReqSpec;

   witAssert (deltaIncReqVol > NET_TOL);

   theReqSrcs.clear ();

   forEachEl (theBopEnt, theOpn->bop ())
      if (myBopEntReqs_.myElemAt (theBopEnt, execPer).isNonEmpty ())
         {
         theReqSpec =
            myBopEntReqs_.myElemAt (theBopEnt, execPer).firstObject ();

         theReqSrcs.push (theReqSpec->myReqSrc ());

         if (theReqSpec->incReqVolFor () - deltaIncReqVol > NET_TOL)
            theReqSpec->addToIncReqVol (- deltaIncReqVol);
         else
            {
            myBopEntReqs_.myElemAt (theBopEnt, execPer).pop (theReqSpec);

            reclaimReqSpec (theReqSpec);
            }
         }
      else
         theReqSrcs.push (myVacReqSrc_);
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::sortReqList ()
   {
   if (myGlobalComp ()->printGpip ())
      prtCurReqListBeforeSort ();

   loadReqSpecVec ();

   sort (
        myReqSpecVec_,
        nReqSpecsInVec_,
      & WitGpipReqMgr::compareReqSpecs,
        this);

   unloadReqSpecVec ();

   if (myGlobalComp ()->printGpip ())
      prtCurReqListAfterSort ();
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::loadReqSpecVec ()
   {
   int              theIdx;
   WitGpipReqSpec * theReqSpec;

   witAssert (nReqSpecsInVec_ == 0);

   nReqSpecsInVec_ = curReqList_.nElements ();

   if (nReqSpecsInVec_ > myReqSpecVec_.length ())
      myReqSpecVec_.resize (2 * nReqSpecsInVec_);

   for (theIdx = nReqSpecsInVec_ - 1; theIdx >= 0; theIdx --)
      {
      curReqList_.pop (theReqSpec);

      myReqSpecVec_[theIdx] = theReqSpec;
      }

   setToMax (maxReqSpecsInVec_, nReqSpecsInVec_);
   }

//------------------------------------------------------------------------------

bool WitGpipReqMgr::compareReqSpecs (
      WitGpipReqSpec * theReqSpec1,
      WitGpipReqSpec * theReqSpec2)
   {
   return theReqSpec1->myReqSrc ()->belongsBefore (theReqSpec2->myReqSrc ());
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::unloadReqSpecVec ()
   {
   int              theIdx;
   WitGpipReqSpec * theReqSpec;
   WitGpipReqSpec * prevReqSpec;

   witAssert (nReqSpecsInVec_ > 0);

   for (theIdx = nReqSpecsInVec_ - 1; theIdx >= 0; theIdx --)
      {
      theReqSpec            = myReqSpecVec_[theIdx];

      myReqSpecVec_[theIdx] = NULL;

      if (curReqList_.isNonEmpty ())
         {
         prevReqSpec = curReqList_.firstObject ();

         if (prevReqSpec->myReqSrc ()->isEquivalentTo (theReqSpec->myReqSrc ()))
            {
            prevReqSpec->addToIncReqVol (theReqSpec->incReqVolFor ());

            reclaimReqSpec (theReqSpec);

            continue;
            }
         }

      curReqList_.push (theReqSpec);
      }

   nReqSpecsInVec_ = 0;
   }

//------------------------------------------------------------------------------

WitGpipReqSpec * WitGpipReqMgr::provideReqSpec (
      WitGpipReqSrc * theReqSrc,
      double          incReqVol)
   {
   WitGpipReqSpec * theReqSpec;

   if (unusedReqSpecs_.isNonEmpty ())
      unusedReqSpecs_.pop (theReqSpec);
   else
      theReqSpec = new WitGpipReqSpec;

   theReqSpec->setData (theReqSrc, incReqVol);

   return theReqSpec;
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::reclaimReqSpec (WitGpipReqSpec * theReqSpec)
   {
   unusedReqSpecs_.push (theReqSpec);
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::prtCurReqListBeforeSort ()
   {
   fprintf (msgFile (), 
      "\n"
      "Requirements before sorting and consolidation:\n");

   prtCurReqList ();
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::prtCurReqListAfterSort ()
   {
   fprintf (msgFile (), 
      "\n"
      "Requirements after sorting and consolidation:\n");

   prtCurReqList ();
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::prtCurReqList (WitOperation * theOpn, WitPeriod execPer)
   {
   fprintf (msgFile (), 
      "\n"
      "Requirements for Operation %s in Period %d:\n",
      theOpn->operationName ().myCstring (),
      execPer);

   prtCurReqList ();
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::prtCurReqList ()
   {
   WitObjStItr <WitGpipReqSpec> theReqSpecItr;
   WitGpipReqSpec *             theReqSpec;

   witAssert (myGlobalComp ()->printGpip ());

   curReqList_.attachItr (theReqSpecItr);

   while (theReqSpecItr.advance (theReqSpec))
      {
      fprintf (msgFile (),
         "\n"
         "   IncReqVol: %3.0f\n",
         theReqSpec->incReqVolFor ());

      theReqSpec->myReqSrc ()->print (msgFile (), "   ");
      }
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::prtBopEntReqs (WitOperation * theOpn, WitPeriod execPer)
   {
   WitBopEntry *                theBopEnt;
   WitObjStItr <WitGpipReqSpec> theReqSpecItr;
   WitGpipReqSpec *             theReqSpec;
   
   witAssert (myGlobalComp ()->printGpip ());

   fprintf (msgFile (),
      "\n"
      "Merging requirements for Operation %s in Period %d:\n",
      theOpn->operationName ().myCstring (),
      execPer);

   forEachEl (theBopEnt, theOpn->bop ())
      {
      fprintf (msgFile (),
         "\n"
         "   BOP Entry #%d:\n",
         theBopEnt->localIndex ());

      myBopEntReqs_.myElemAt (theBopEnt, execPer).attachItr (theReqSpecItr);

      while (theReqSpecItr.advance (theReqSpec))
         {
         fprintf (msgFile (),
            "\n"
            "      IncReqVol: %3.0f\n",
            theReqSpec->incReqVolFor ());

         theReqSpec->myReqSrc ()->print (msgFile (), "      ");
         }
      }
   }

//------------------------------------------------------------------------------

void WitGpipReqMgr::prtSizes ()
   {
   witAssert (myGlobalComp ()->printGpip ());

   fprintf (msgFile (),
      "\n"
      "Max # SRP Req Specs in Vector:  %d\n"
      "Max SRP Req Spec Vector Length: %d\n"
      "Total # Req Specs:              %d\n\n",
      maxReqSpecsInVec_,
      myReqSpecVec_.length (),
      unusedReqSpecs_.nElements ());
   }

//------------------------------------------------------------------------------
// Implementation of class GpipReqSpec.
//------------------------------------------------------------------------------

WitGpipReqSpec::WitGpipReqSpec ():
      myReqSrc_     (NULL),
      incReqVolFor_ (0.0)
   {
   }

//------------------------------------------------------------------------------

WitGpipReqSpec::~WitGpipReqSpec ()
   {
   }

//------------------------------------------------------------------------------

void WitGpipReqSpec::setData (WitGpipReqSrc * theReqSrc, double incReqVol)
   {
   witAssert (theReqSrc != NULL);
   witAssert (incReqVol >  NET_TOL);

   myReqSrc_     = theReqSrc;
   incReqVolFor_ = incReqVol;
   }

//------------------------------------------------------------------------------

void WitGpipReqSpec::addToIncReqVol (double deltaIncReqVol)
   {
   incReqVolFor_ += deltaIncReqVol;

   witAssert (incReqVolFor_ >  NET_TOL);
   }

//------------------------------------------------------------------------------
// Implementation of class GpipReqSrc.
//------------------------------------------------------------------------------

WitGpipReqSrc::WitGpipReqSrc (WitGpipSeqEl * theSeqEl):
      mySeqElVec_ (1)
   {
   mySeqElVec_[0] = theSeqEl;
   }

//------------------------------------------------------------------------------

WitGpipReqSrc::WitGpipReqSrc (const WitGpipReqSrcStack & theReqSrcs):
      mySeqElVec_ ()
   {
   WitPtrVec <WitGpipSeqEl> tempSeqElVec;

   witAssert (theReqSrcs.isNonEmpty ());

   buildTempSeqElVec (theReqSrcs, tempSeqElVec);

   sort (
        tempSeqElVec,
      & WitGpipReqSrc::compareSeqEls,
        this);

   consolidateSeqEls (tempSeqElVec);
   }

//------------------------------------------------------------------------------

WitGpipReqSrc::~WitGpipReqSrc ()
   {
   }

//------------------------------------------------------------------------------

bool WitGpipReqSrc::belongsBefore (WitGpipReqSrc * theReqSrc)
   {
   WitGpipSeqElItr theItr;
   WitGpipSeqEl *  theSeqEl;
   int             theSeqNo1;
   int             theSeqNo2;

   attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      {
      if (theItr.myIdx () >= theReqSrc->mySeqElVec_.length ())
         return false;

      theSeqNo1 = theSeqEl->mySeqNo ();

      theSeqNo2 = theReqSrc->mySeqElVec_[theItr.myIdx ()]->mySeqNo ();

      if (theSeqNo1 < theSeqNo2)
         return true;

      if (theSeqNo1 > theSeqNo2)
         return false;
      }

   if (mySeqElVec_.length () < theReqSrc->mySeqElVec_.length ())
      return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitGpipReqSrc::isEquivalentTo (WitGpipReqSrc * theReqSrc)
   {
   WitGpipSeqElItr theItr;
   WitGpipSeqEl *  theSeqEl;

   if (mySeqElVec_.length () != theReqSrc->mySeqElVec_.length ())
      return false;

   attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl != theReqSrc->mySeqElVec_[theItr.myIdx ()])
         return false;

   return true;
   }

//------------------------------------------------------------------------------

void WitGpipReqSrc::print (FILE * theFile, const char * leadingBlanks)
   {
   WitGpipSeqElItr theItr;
   WitGpipSeqEl *  theSeqEl;
   WitDemand *     theDemand;
   WitPeriod       shipPer;
   
   fprintf (theFile,
      "%sReq Src:\n",
      leadingBlanks);

   attachSeqElItr (theItr);

   while (theItr.advance (theSeqEl))
      if (theSeqEl->hasaShipment ())
         {
         theSeqEl->getData (theDemand, shipPer);

         fprintf (theFile,
            "   %sDem %s, Per %d, Seq #%d\n",
            leadingBlanks,
            theDemand->demandName ().myCstring (),
            shipPer,
            theSeqEl->mySeqNo ());
         }
      else
         fprintf (theFile,
            "   %sDem None,     Seq #%d\n",
            leadingBlanks,
            theSeqEl->mySeqNo ());
   }

//------------------------------------------------------------------------------

void WitGpipReqSrc::attachSeqElItr (WitGpipSeqElItr & theItr)
   {
   mySeqElVec_.attachItr (theItr);
   }

//------------------------------------------------------------------------------

bool WitGpipReqSrc::compareSeqEls (
      WitGpipSeqEl * theSeqEl1,
      WitGpipSeqEl * theSeqEl2)
   {
   return (theSeqEl1->mySeqNo () < theSeqEl2->mySeqNo ());
   }

//------------------------------------------------------------------------------

void WitGpipReqSrc::buildTempSeqElVec (
      const WitGpipReqSrcStack & theReqSrcs,
      WitPtrVec <WitGpipSeqEl> & tempSeqElVec)
   {
   int                         totSeqEls;
   WitObjStItr <WitGpipReqSrc> theReqSrcItr;
   WitGpipReqSrc *             theReqSrc;
   int                         tempIdx;
   WitGpipSeqElItr             theSeqElItr;
   WitGpipSeqEl *              theSeqEl;

   totSeqEls = 0;

   theReqSrcs.attachItr (theReqSrcItr);

   while (theReqSrcItr.advance (theReqSrc))
      totSeqEls += theReqSrc->mySeqElVec_.length ();

   tempSeqElVec.resize (totSeqEls);

   tempIdx = -1;

   theReqSrcs.attachItr (theReqSrcItr);

   while (theReqSrcItr.advance (theReqSrc))
      {
      theReqSrc->attachSeqElItr (theSeqElItr);

      while (theSeqElItr.advance (theSeqEl))
         {
         tempIdx ++;

         tempSeqElVec[tempIdx] = theSeqEl;
         }
      }
   }

//------------------------------------------------------------------------------

void WitGpipReqSrc::consolidateSeqEls (
      const WitPtrVec <WitGpipSeqEl> & tempSeqElVec)
   {
   int nDistinct;
   int tempIdx;
   int theIdx;

   nDistinct = 1;

   for (tempIdx = 1; tempIdx < tempSeqElVec.length (); tempIdx ++)
      if (tempSeqElVec[tempIdx] != tempSeqElVec[tempIdx - 1])
         nDistinct ++;

   mySeqElVec_.resize (nDistinct);

   mySeqElVec_[0] = tempSeqElVec[0];

   theIdx = 0;

   for (tempIdx = 1; tempIdx < tempSeqElVec.length (); tempIdx ++)
      if (tempSeqElVec[tempIdx] != mySeqElVec_[theIdx])
         {
         theIdx ++;

         mySeqElVec_[theIdx] = tempSeqElVec[tempIdx];
         }
   }

//------------------------------------------------------------------------------
// Implementation of class GpipSeqEl.
//------------------------------------------------------------------------------

WitGpipSeqEl::WitGpipSeqEl (
         WitDemand * theDemand,
         WitPeriod   shipPer,
         int         theSeqNo):

      myDemand_   (theDemand),
      shipPerFor_ (shipPer),
      mySeqNo_    (theSeqNo)
   {
   }

//------------------------------------------------------------------------------

WitGpipSeqEl::~WitGpipSeqEl ()
   {
   }

//------------------------------------------------------------------------------

void WitGpipSeqEl::getData (WitDemand * & theDemand, WitPeriod & shipPer)
   {
   witAssert (hasaShipment ());

   theDemand = myDemand_;
   shipPer   = shipPerFor_;
   }
@


1.34
log
@GPIP
@
text
@@


1.33
log
@GPIP
@
text
@d15 4
a18 4
//    SrpReqMgr
//    SrpReqSpec
//    SrpReqSrc
//    SrpSeqEl
d35 1
a35 1
// Implementation of class SrpReqMgr.
d38 1
a38 1
WitSrpReqMgr::WitSrpReqMgr (WitProblem * theProblem):
d70 1
a70 1
            new WitSrpReqList (myProblem ());
d77 1
a77 1
            new WitSrpReqList (myProblem ());
d82 1
a82 1
WitSrpReqMgr::~WitSrpReqMgr ()
d119 1
a119 1
bool WitSrpReqMgr::hasReqsFor (WitPart * thePart, WitPeriod fillPer)
d126 1
a126 1
bool WitSrpReqMgr::hasReqsFor (WitOperation * theOpn, WitPeriod execPer)
d139 1
a139 1
WitSrpReqSrc * WitSrpReqMgr::newReqSrcForSeqNo (int theSeqNo)
d141 1
a141 1
   WitSrpReqSrc * theReqSrc;
d143 1
a143 1
   theReqSrc = new WitSrpReqSrc (mySeqElVec_[theSeqNo]);
d152 5
a156 5
void WitSrpReqMgr::addReq (
      WitPart *      thePart,
      WitPeriod      fillPer,
      WitSrpReqSrc * theReqSrc,
      double         incReqVol)
d158 1
a158 1
   WitSrpReqSpec * theReqSpec;
d169 5
a173 5
void WitSrpReqMgr::addReq (
      WitBopEntry *  theBopEnt,
      WitPeriod      execPer,
      WitSrpReqSrc * theReqSrc,
      double         incExecVol)
d175 1
a175 1
   WitSrpReqSpec * theReqSpec;
d186 1
a186 1
void WitSrpReqMgr::loadCurReqList (WitPart * thePart, WitPeriod fillPer)
d198 1
a198 1
void WitSrpReqMgr::loadCurReqList (WitOperation * theOpn, WitPeriod execPer)
d223 1
a223 1
void WitSrpReqMgr::clearCurReqList ()
d225 1
a225 1
   WitSrpReqSpec * theReqSpec;
d233 1
a233 1
void WitSrpReqMgr::initReqListItr ()
d235 1
a235 1
   WitSrpReqSpec * theReqSpec;
d250 4
a253 4
void WitSrpReqMgr::advanceReqListItr (
      double &         netReqVol,
      WitSrpReqSrc * & theReqSrc,
      double &         incReqVol)
d255 1
a255 1
   WitSrpReqSpec * theReqSpec;
d285 3
a287 3
void WitSrpReqMgr::advanceReqListItr (
      WitSrpReqSrc * & theReqSrc,
      double &         incReqVol)
d289 1
a289 1
   WitSrpReqSpec * theReqSpec;
d310 1
a310 1
bool WitSrpReqMgr::finishedReqListItr ()
d317 1
a317 1
void WitSrpReqMgr::buildSeqEls ()
d335 1
a335 1
      mySeqElVec_[theSeqNo] = new WitSrpSeqEl (theDemand, shipPer, theSeqNo);
d340 1
a340 1
   mySeqElVec_[theSeqNo] = new WitSrpSeqEl (NULL, -1, theSeqNo);
d345 1
a345 1
void WitSrpReqMgr::mergeReqs (WitOperation * theOpn, WitPeriod execPer)
d347 5
a351 5
   WitBopEntry *     theBopEnt;
   double            incExecVol;
   WitSrpReqSrc *    theReqSrc;
   WitSrpReqSpec *   theReqSpec;
   WitSrpReqSrcStack theReqSrcs (myProblem ());
d370 1
a370 1
      theReqSrc = new WitSrpReqSrc (theReqSrcs);
d384 1
a384 1
double WitSrpReqMgr::minIncReqVol (WitOperation * theOpn, WitPeriod execPer)
d413 5
a417 5
void WitSrpReqMgr::extractReqSrcs (
      WitOperation *      theOpn,
      WitPeriod           execPer,
      double              deltaIncReqVol,
      WitSrpReqSrcStack & theReqSrcs)
d419 2
a420 2
   WitBopEntry *   theBopEnt;
   WitSrpReqSpec * theReqSpec;
d449 1
a449 1
void WitSrpReqMgr::sortReqList ()
d459 1
a459 1
      & WitSrpReqMgr::compareReqSpecs,
d470 1
a470 1
void WitSrpReqMgr::loadReqSpecVec ()
d472 2
a473 2
   int             theIdx;
   WitSrpReqSpec * theReqSpec;
d494 3
a496 3
bool WitSrpReqMgr::compareReqSpecs (
      WitSrpReqSpec * theReqSpec1,
      WitSrpReqSpec * theReqSpec2)
d503 1
a503 1
void WitSrpReqMgr::unloadReqSpecVec ()
d505 3
a507 3
   int             theIdx;
   WitSrpReqSpec * theReqSpec;
   WitSrpReqSpec * prevReqSpec;
d539 3
a541 3
WitSrpReqSpec * WitSrpReqMgr::provideReqSpec (
      WitSrpReqSrc * theReqSrc,
      double         incReqVol)
d543 1
a543 1
   WitSrpReqSpec * theReqSpec;
d548 1
a548 1
      theReqSpec = new WitSrpReqSpec;
d557 1
a557 1
void WitSrpReqMgr::reclaimReqSpec (WitSrpReqSpec * theReqSpec)
d564 1
a564 1
void WitSrpReqMgr::prtCurReqListBeforeSort ()
d575 1
a575 1
void WitSrpReqMgr::prtCurReqListAfterSort ()
d586 1
a586 1
void WitSrpReqMgr::prtCurReqList (WitOperation * theOpn, WitPeriod execPer)
d599 1
a599 1
void WitSrpReqMgr::prtCurReqList ()
d601 2
a602 2
   WitObjStItr <WitSrpReqSpec> theReqSpecItr;
   WitSrpReqSpec *             theReqSpec;
d621 1
a621 1
void WitSrpReqMgr::prtBopEntReqs (WitOperation * theOpn, WitPeriod execPer)
d623 3
a625 3
   WitBopEntry *               theBopEnt;
   WitObjStItr <WitSrpReqSpec> theReqSpecItr;
   WitSrpReqSpec *             theReqSpec;
d658 1
a658 1
void WitSrpReqMgr::prtSizes ()
d673 1
a673 1
// Implementation of class SrpReqSpec.
d676 1
a676 1
WitSrpReqSpec::WitSrpReqSpec ():
d684 1
a684 1
WitSrpReqSpec::~WitSrpReqSpec ()
d690 1
a690 1
void WitSrpReqSpec::setData (WitSrpReqSrc * theReqSrc, double incReqVol)
d701 1
a701 1
void WitSrpReqSpec::addToIncReqVol (double deltaIncReqVol)
d709 1
a709 1
// Implementation of class SrpReqSrc.
d712 1
a712 1
WitSrpReqSrc::WitSrpReqSrc (WitSrpSeqEl * theSeqEl):
d720 1
a720 1
WitSrpReqSrc::WitSrpReqSrc (const WitSrpReqSrcStack & theReqSrcs):
d723 1
a723 1
   WitPtrVec <WitSrpSeqEl> tempSeqElVec;
d731 1
a731 1
      & WitSrpReqSrc::compareSeqEls,
d739 1
a739 1
WitSrpReqSrc::~WitSrpReqSrc ()
d745 1
a745 1
bool WitSrpReqSrc::belongsBefore (WitSrpReqSrc * theReqSrc)
d747 4
a750 4
   WitSrpSeqElItr theItr;
   WitSrpSeqEl *  theSeqEl;
   int            theSeqNo1;
   int            theSeqNo2;
d778 1
a778 1
bool WitSrpReqSrc::isEquivalentTo (WitSrpReqSrc * theReqSrc)
d780 2
a781 2
   WitSrpSeqElItr theItr;
   WitSrpSeqEl *  theSeqEl;
d797 1
a797 1
void WitSrpReqSrc::print (FILE * theFile, const char * leadingBlanks)
d799 4
a802 4
   WitSrpSeqElItr theItr;
   WitSrpSeqEl *  theSeqEl;
   WitDemand *    theDemand;
   WitPeriod      shipPer;
d831 1
a831 1
void WitSrpReqSrc::attachSeqElItr (WitSrpSeqElItr & theItr)
d838 3
a840 3
bool WitSrpReqSrc::compareSeqEls (
      WitSrpSeqEl * theSeqEl1,
      WitSrpSeqEl * theSeqEl2)
d847 10
a856 10
void WitSrpReqSrc::buildTempSeqElVec (
      const WitSrpReqSrcStack & theReqSrcs,
      WitPtrVec <WitSrpSeqEl> & tempSeqElVec)
   {
   int                        totSeqEls;
   WitObjStItr <WitSrpReqSrc> theReqSrcItr;
   WitSrpReqSrc *             theReqSrc;
   int                        tempIdx;
   WitSrpSeqElItr             theSeqElItr;
   WitSrpSeqEl *              theSeqEl;
d886 2
a887 2
void WitSrpReqSrc::consolidateSeqEls (
      const WitPtrVec <WitSrpSeqEl> & tempSeqElVec)
d915 1
a915 1
// Implementation of class SrpSeqEl.
d918 1
a918 1
WitSrpSeqEl::WitSrpSeqEl (
d931 1
a931 1
WitSrpSeqEl::~WitSrpSeqEl ()
d937 1
a937 1
void WitSrpSeqEl::getData (WitDemand * & theDemand, WitPeriod & shipPer)
@


1.32
log
@[shared-resource pegging]
@
text
@d214 1
a214 1
      if (myGlobalComp ()->printSrpDB ())
d358 1
a358 1
   if (myGlobalComp ()->printSrpDB ())
d451 1
a451 1
   if (myGlobalComp ()->printSrpDB ())
d464 1
a464 1
   if (myGlobalComp ()->printSrpDB ())
d604 1
a604 1
   witAssert (myGlobalComp ()->printSrpDB ());
d627 1
a627 1
   witAssert (myGlobalComp ()->printSrpDB ());
d660 1
a660 1
   witAssert (myGlobalComp ()->printSrpDB ());
@


1.31
log
@[shared-resource pegging]
@
text
@d119 1
a119 1
bool WitSrpReqMgr::hasNoReqsFor (WitPart * thePart, WitPeriod fillPer)
d121 14
a134 1
   return myPartReqs_.myElemAt (thePart, fillPer).isEmpty ();
@


1.30
log
@[shared-resource pegging]
@
text
@d51 4
a54 1
      curReqList_       (myProblem ())
d175 1
a175 1
   witAssert (curReqListIsEmpty ());
d179 1
a179 1
   if (not curReqListIsEmpty ())
d189 2
a190 1
   witAssert (curReqListIsEmpty ());
d210 2
a211 4
void WitSrpReqMgr::getFromCurReqList (
      WitSrpReqSrc * & theReqSrc,
      double &         incReqVol)
   {
d214 5
a218 1
   witAssert (not curReqListIsEmpty ());
d220 3
a222 1
   curReqList_.pop (theReqSpec);
d224 1
a224 2
   theReqSrc = theReqSpec->myReqSrc     ();
   incReqVol = theReqSpec->incReqVolFor ();
d226 7
a232 1
   reclaimReqSpec (theReqSpec);
d237 1
a237 1
void WitSrpReqMgr::netWithCurReqList (
d244 1
a244 1
   witAssert (not curReqListIsEmpty ());
d248 6
a253 1
   curReqList_.pop (theReqSpec);
d255 2
a256 2
   theReqSrc = theReqSpec->myReqSrc     ();
   incReqVol = theReqSpec->incReqVolFor ();
d258 1
a258 1
   if (incReqVol - netReqVol > NET_TOL)
d260 27
a286 3
      theReqSpec->addToIncReqVol (- netReqVol);
      
      curReqList_.push (theReqSpec);
d289 5
a293 1
      reclaimReqSpec (theReqSpec);
d295 1
a295 1
   setToMin (incReqVol, netReqVol);
d297 3
a299 1
   netReqVol -= incReqVol;
@


1.29
log
@[shared-resource pegging]
@
text
@d51 1
a51 2
      curReqList_       (myProblem ()),
      retrievedReqSrc_  (NULL)
a173 2
   retrievedReqSrc_ = NULL;

a188 2
   retrievedReqSrc_ = NULL;

d216 2
a217 4
   theReqSrc        = theReqSpec->myReqSrc     ();
   incReqVol        = theReqSpec->incReqVolFor ();

   retrievedReqSrc_ = theReqSrc;
d224 4
a227 1
void WitSrpReqMgr::restoreToCurReqList (double incReqVol)
d231 8
a238 1
   witAssert (incReqVol > NET_TOL);
d240 8
a247 3
   witAssert (retrievedReqSrc_ != NULL);
   
   theReqSpec = provideReqSpec (retrievedReqSrc_, incReqVol);
d249 1
a249 1
   curReqList_.push (theReqSpec);
d251 1
a251 1
   retrievedReqSrc_ = NULL;
@


1.28
log
@[shared-resource pegging]
@
text
@d44 1
a44 1
      myNullReqSrc_     (NULL),
d61 1
a61 1
   myNullReqSrc_ = newReqSrcForSeqNo (mySeqElVec_.length () - 1);
d105 1
a105 1
   myNullReqSrc_ = NULL;
d375 1
a375 1
         theReqSrcs.push (myNullReqSrc_);
@


1.27
log
@[shared-resource pegging]
@
text
@d742 1
a742 1
      if (not theSeqEl->isNull ())
d870 1
a870 1
   witAssert (not isNull ());
@


1.26
log
@[shared-resource pegging]
@
text
@d678 6
a683 3
   int theIdx;
   int theSeqNo1;
   int theSeqNo2;
d685 1
a685 1
   for (theIdx = 0; theIdx < nSeqEls (); theIdx ++)
d687 1
a687 1
      if (theIdx >= theReqSrc->nSeqEls ())
d690 3
a692 2
      theSeqNo1 =            mySeqElFor (theIdx)->mySeqNo ();
      theSeqNo2 = theReqSrc->mySeqElFor (theIdx)->mySeqNo ();
d701 1
a701 1
   if (nSeqEls () < theReqSrc->nSeqEls ())
d711 2
a712 1
   int theIdx;
d714 1
a714 1
   if (nSeqEls () != theReqSrc->nSeqEls ())
d717 4
a720 2
   for (theIdx = 0; theIdx < nSeqEls (); theIdx ++)
      if (mySeqElFor (theIdx) != theReqSrc->mySeqElFor (theIdx))
d730 4
a733 3
   int         theIdx;
   WitDemand * theDemand;
   WitPeriod   shipPer;
d739 4
a742 2
   for (theIdx = 0; theIdx < nSeqEls (); theIdx ++)
      if (not mySeqElFor (theIdx)->isNull ())
d744 1
a744 1
         mySeqElFor (theIdx)->getData (theDemand, shipPer);
d751 1
a751 1
            mySeqElFor (theIdx)->mySeqNo ());
d757 8
a764 1
            mySeqElFor (theIdx)->mySeqNo ());
d783 1
a783 1
   WitObjStItr <WitSrpReqSrc> theItr;
d786 2
a787 1
   int                        theIdx;
d791 1
a791 1
   theReqSrcs.attachItr (theItr);
d793 2
a794 2
   while (theItr.advance (theReqSrc))
      totSeqEls += theReqSrc->nSeqEls ();
d800 1
a800 1
   theReqSrcs.attachItr (theItr);
d802 5
a806 2
   while (theItr.advance (theReqSrc))
      for (theIdx = 0; theIdx < theReqSrc->nSeqEls (); theIdx ++)
d810 1
a810 1
         tempSeqElVec[tempIdx] = theReqSrc->mySeqElFor (theIdx);
d812 1
@


1.25
log
@[shared-resource pegging]
@
text
@d27 1
a27 1
#include <PVecSorter.h>
@


1.24
log
@[shared-resource pegging]
@
text
@a381 4
   WitPVecSorter <WitSrpReqSpec, WitSrpReqMgr> theSorter (
      & WitSrpReqMgr::compareReqSpecs,
        this);

d387 5
a391 1
   theSorter.sort (myReqSpecVec_, nReqSpecsInVec_);
a655 4
   WitPVecSorter <WitSrpSeqEl, WitSrpReqSrc> theSorter (
      & WitSrpReqSrc::compareSeqEls,
        this);

d660 4
a663 1
   theSorter.sort (tempSeqElVec);
@


1.23
log
@[shared-resource pegging]
@
text
@d654 13
a666 1
   mergeReqSrcs (theReqSrcs);
d753 12
a764 1
void WitSrpReqSrc::mergeReqSrcs (const WitSrpReqSrcStack & theReqSrcs)
a768 1
   WitPtrVec <WitSrpSeqEl>    tempSeqElPtV;
a770 7
   int                        distinctSeqEls;

   WitPVecSorter <WitSrpSeqEl, WitSrpReqSrc> theSorter (
      & WitSrpReqSrc::compareSeqEls,
        this);

   witAssert (theReqSrcs.isNonEmpty ());
d779 1
a779 1
   tempSeqElPtV.resize (totSeqEls);
d790 1
a790 1
         tempSeqElPtV[tempIdx] = theReqSrc->mySeqElFor (theIdx);
d792 3
d796 6
a801 1
   theSorter.sort (tempSeqElPtV);
d803 1
a803 1
   distinctSeqEls = 1;
d805 3
a807 3
   for (tempIdx = 1; tempIdx < totSeqEls; tempIdx ++)
      if (tempSeqElPtV[tempIdx] != tempSeqElPtV[tempIdx - 1])
         distinctSeqEls ++;
d809 1
a809 1
   mySeqElVec_.resize (distinctSeqEls);
d811 1
a811 1
   mySeqElVec_[0] = tempSeqElPtV[0];
d815 2
a816 2
   for (tempIdx = 1; tempIdx < totSeqEls; tempIdx ++)
      if (tempSeqElPtV[tempIdx] != mySeqElVec_[theIdx])
d820 1
a820 1
         mySeqElVec_[theIdx] = tempSeqElPtV[tempIdx];
a824 18

bool WitSrpReqSrc::areInOrder (
      WitSrpSeqEl * theSeqEl1,
      WitSrpSeqEl * theSeqEl2)
   {
   return (theSeqEl1->mySeqNo () < theSeqEl2->mySeqNo ());
   }

//------------------------------------------------------------------------------

bool WitSrpReqSrc::compareSeqEls (
      WitSrpSeqEl * theSeqEl1,
      WitSrpSeqEl * theSeqEl2)
   {
   return (theSeqEl1->mySeqNo () < theSeqEl2->mySeqNo ());
   }

//------------------------------------------------------------------------------
@


1.22
log
@[shared-resource pegging]
@
text
@a33 2
#include <algorithm>

d746 1
a746 1
   WitVector <WitSrpSeqEl *>  tempSeqElVec;
d751 4
d764 1
a764 1
   tempSeqElVec.resize (totSeqEls, NULL);
d775 1
a775 1
         tempSeqElVec[tempIdx] = theReqSrc->mySeqElFor (theIdx);
d778 1
a778 4
   std::sort (
      tempSeqElVec.myCVecForUpdate (),
      tempSeqElVec.myCVecForUpdate () + totSeqEls,
      areInOrder);
d783 1
a783 1
      if (tempSeqElVec[tempIdx] != tempSeqElVec[tempIdx - 1])
d788 1
a788 1
   mySeqElVec_[0] = tempSeqElVec[0];
d793 1
a793 1
      if (tempSeqElVec[tempIdx] != mySeqElVec_[theIdx])
d797 1
a797 1
         mySeqElVec_[theIdx] = tempSeqElVec[tempIdx];
d811 9
@


1.21
log
@[shared-resource pegging]
@
text
@d27 1
d384 4
d393 1
a393 4
   std::sort (
      myReqSpecVec_.myCVecForUpdate (),
      myReqSpecVec_.myCVecForUpdate () + nReqSpecsInVec_,
      areInOrder);
d413 1
a413 1
      myReqSpecVec_.resize (2 * nReqSpecsInVec_, NULL);
d427 1
a427 1
bool WitSrpReqMgr::areInOrder (
@


1.20
log
@[shared-resource pegging]
@
text
@d180 2
a181 17
   if (curReqListIsEmpty ())
      return;

   if (myGlobalComp ()->printSrpDB ())
      prtCurReqListBeforeSort ();

   loadReqSpecVec ();

   std::sort (
      myReqSpecVec_.myCVecForUpdate (),
      myReqSpecVec_.myCVecForUpdate () + nReqSpecsInVec_,
      areInOrder);

   unloadReqSpecVec ();

   if (myGlobalComp ()->printSrpDB ())
      prtCurReqListAfterSort ();
d202 3
a207 3

   if (myGlobalComp ()->printSrpDB ())
      prtCurReqList (theOpn, execPer);
a276 69
void WitSrpReqMgr::loadReqSpecVec ()
   {
   int             theIdx;
   WitSrpReqSpec * theReqSpec;

   witAssert (nReqSpecsInVec_ == 0);

   nReqSpecsInVec_ = curReqList_.nElements ();

   if (nReqSpecsInVec_ > myReqSpecVec_.length ())
      myReqSpecVec_.resize (2 * nReqSpecsInVec_, NULL);

   for (theIdx = nReqSpecsInVec_ - 1; theIdx >= 0; theIdx --)
      {
      curReqList_.pop (theReqSpec);

      myReqSpecVec_[theIdx] = theReqSpec;
      }

   setToMax (maxReqSpecsInVec_, nReqSpecsInVec_);
   }

//------------------------------------------------------------------------------

bool WitSrpReqMgr::areInOrder (
      WitSrpReqSpec * theReqSpec1,
      WitSrpReqSpec * theReqSpec2)
   {
   return theReqSpec1->myReqSrc ()->belongsBefore (theReqSpec2->myReqSrc ());
   }

//------------------------------------------------------------------------------

void WitSrpReqMgr::unloadReqSpecVec ()
   {
   int             theIdx;
   WitSrpReqSpec * theReqSpec;
   WitSrpReqSpec * prevReqSpec;

   witAssert (nReqSpecsInVec_ > 0);

   for (theIdx = nReqSpecsInVec_ - 1; theIdx >= 0; theIdx --)
      {
      theReqSpec            = myReqSpecVec_[theIdx];

      myReqSpecVec_[theIdx] = NULL;

      if (curReqList_.isNonEmpty ())
         {
         prevReqSpec = curReqList_.firstObject ();

         if (prevReqSpec->myReqSrc ()->isEquivalentTo (theReqSpec->myReqSrc ()))
            {
            prevReqSpec->addToIncReqVol (theReqSpec->incReqVolFor ());

            reclaimReqSpec (theReqSpec);

            continue;
            }
         }

      curReqList_.push (theReqSpec);
      }

   nReqSpecsInVec_ = 0;
   }

//------------------------------------------------------------------------------

d311 1
a311 1
   curReqList_.reverse ();
d381 89
@


1.19
log
@[shared-resource pegging]
@
text
@d639 1
a639 1
      mySeqElVec_ ()
a640 2
   mySeqElVec_.resize (1, NULL);

d669 1
a669 1
         return true;
d681 3
d741 2
a742 1
   int                        mergedIdx;
d744 3
d755 1
a755 1
   mySeqElVec_.resize (totSeqEls, NULL);
d757 1
a757 1
   mergedIdx = -1;
d764 1
a764 1
         mergedIdx ++;
d766 1
a766 1
         mySeqElVec_[mergedIdx] = theReqSrc->mySeqElFor (theIdx);
d770 2
a771 2
      mySeqElVec_.myCVecForUpdate (),
      mySeqElVec_.myCVecForUpdate () + totSeqEls,
d773 20
@


1.18
log
@[shared-resource pegging]
@
text
@d25 2
d43 1
a43 1
      mySeqEls_         (theProblem),
d45 1
d60 4
d87 1
d106 2
d109 5
a113 1
   deleteContents (mySeqEls_);
d125 1
a125 4
WitSrpReqSrc * WitSrpReqMgr::newReqSrc (
      WitDemand * theDemand,
      WitPeriod   shipPer,
      int         theSeqNo)
a126 1
   WitSrpSeqEl *  theSeqEl;
d129 1
a129 5
   theSeqEl  = new WitSrpSeqEl (theDemand, shipPer, theSeqNo);

   mySeqEls_.push (theSeqEl);

   theReqSrc = new WitSrpReqSrc (theSeqEl);
d264 28
d459 2
d715 3
a717 2
      {
      mySeqElFor (theIdx)->getData (theDemand, shipPer);
d719 12
a730 7
      fprintf (theFile,
         "   %sDem %s, Per %d, Seq #%d\n",
         leadingBlanks,
         theDemand->demandName ().myCstring (),
         shipPer,
         mySeqElFor (theIdx)->mySeqNo ());
      }
d804 2
@


1.17
log
@[shared-resource pegging]
@
text
@d178 1
a178 1
      prtCurReqList (thePart, fillPer, false);
d190 1
a190 1
      prtCurReqList (thePart, fillPer, true);
a212 1
      {
d214 3
a216 1
      }
d454 36
a489 4
void WitSrpReqMgr::prtCurReqList (
      WitPart * thePart,
      WitPeriod fillPer,
      bool      afterSort)
a495 7
   fprintf (msgFile (),
      "\n"
      "Requirements for Part %s in Period %d, %s sorting and consolidation:\n",
      thePart->partName ().myCstring (),
      fillPer,
      afterSort? "after": "before");

d521 1
a521 1
      "Merging requirements for Operation %s in Execution Period %d:\n",
@


1.16
log
@[shared-resource pegging]
@
text
@d606 1
a606 3
   theIdx = -1;

   while (true)
a607 5
      theIdx ++;

      if (theIdx >= nSeqEls ())
         return false;

d614 3
d619 1
d621 1
a621 3
      if (theSeqNo1 < theSeqNo2)
         return true;
      }
@


1.15
log
@[shared-resource pegging]
@
text
@d649 3
a651 1
   int theIdx;
d658 3
d664 2
a665 2
         mySeqElFor (theIdx)->myDemand ()->demandName ().myCstring (),
         mySeqElFor (theIdx)->shipPerFor (),
d667 1
d736 8
@


1.14
log
@[shared-resource pegging]
@
text
@d185 1
a185 1
      WitSrpReqSpec::areInOrder);
d281 9
a572 9

bool WitSrpReqSpec::areInOrder (
      WitSrpReqSpec * theReqSpec1,
      WitSrpReqSpec * theReqSpec2)
   {
   return theReqSpec1->myReqSrc ()->belongsBefore (theReqSpec2->myReqSrc ());
   }

//------------------------------------------------------------------------------
d577 1
a577 1
      mySeqElVec_ (1)
d579 2
a667 44
   int                theSeqElIdx;
   WitSrpSeqEl *      minSeqEl;
   WitSrpSeqEl *      theSeqEl;
   WitSrpSeqElStack * theSeqElStPtr;

   WitObjStItr <WitSrpSeqElStack> theItr;
   WitObjStack <WitSrpSeqElStack> theSeqElStacks (theReqSrcs.myProblem ());

   witAssert (nSeqEls () == 0);

   buildSeqElStacks (theReqSrcs, theSeqElStacks);

   theSeqElIdx = -1;

   while (true)
      {
      minSeqEl = findMinSeqEl (theSeqElStacks);

      if (minSeqEl == NULL)
         break;

      theSeqElStacks.attachItr (theItr);

      while (theItr.advance (theSeqElStPtr))
         if (theSeqElStPtr->isNonEmpty ())
            if (theSeqElStPtr->firstObject () == minSeqEl)
               {
               theSeqElStPtr->pop (theSeqEl);

               theSeqElIdx ++;

               mySeqElVec_[theSeqElIdx] = theSeqEl;
               }
      }

   deleteContents (theSeqElStacks);
   }

//------------------------------------------------------------------------------

void WitSrpReqSrc::buildSeqElStacks (
      const WitSrpReqSrcStack &        theReqSrcs,
      WitObjStack <WitSrpSeqElStack> & theSeqElStacks)
   {
d671 1
a671 1
   WitSrpSeqElStack *         theSeqElStPtr;
d679 1
a679 2
      {
      theSeqElStPtr = new WitSrpSeqElStack (theReqSrcs.myProblem ());
d681 1
a681 2
      for (theIdx = 0; theIdx < theReqSrc->nSeqEls (); theIdx ++)
         theSeqElStPtr->push (theReqSrc->mySeqElFor (theIdx));
d683 1
a683 1
      theSeqElStPtr->reverse ();
d685 6
a690 1
      theSeqElStacks.push (theSeqElStPtr);
d692 2
a693 2
      totSeqEls += theReqSrc->nSeqEls ();
      }
d695 4
a698 1
   mySeqElVec_.resize (totSeqEls);
d703 3
a705 2
WitSrpSeqEl * WitSrpReqSrc::findMinSeqEl (
      const WitObjStack <WitSrpSeqElStack> & theSeqElStacks)
d707 1
a707 25
   WitSrpSeqEl * minSeqEl;
   WitSrpSeqEl * theSeqEl;
   int           minSeqNo;

   WitObjStItr <WitSrpSeqElStack> theItr;
   WitSrpSeqElStack *             theSeqElStPtr;

   minSeqEl = NULL;

   theSeqElStacks.attachItr (theItr);

   while (theItr.advance (theSeqElStPtr))
      if (theSeqElStPtr->isNonEmpty ())
         {
         theSeqEl = theSeqElStPtr->firstObject ();

         if ((minSeqEl == NULL) or (theSeqEl->mySeqNo () < minSeqNo))
            {
            minSeqEl = theSeqEl;

            minSeqNo = minSeqEl->mySeqNo ();
            }
         }

   return minSeqEl;
@


1.13
log
@[shared-resource pegging]
@
text
@a29 1
#include <MsgFac.h>
d185 1
a185 1
      WitSrpReqSpec::compare);
d470 1
a470 1
      theReqSpec->myReqSrc ()->print ("   ");
d506 1
a506 1
         theReqSpec->myReqSrc ()->print ("      ");
d565 1
a565 1
bool WitSrpReqSpec::compare (
d569 1
a569 22
   WitSrpSeqElItr theItr1;
   WitSrpSeqElItr theItr2;
   WitSrpSeqEl *  theSeqEl1;
   WitSrpSeqEl *  theSeqEl2;

   theReqSpec1->myReqSrc_->attachSeqElItr (theItr1);
   theReqSpec2->myReqSrc_->attachSeqElItr (theItr2);

   while (true)
      {
      if (not theItr1.advance (theSeqEl1))
         return false;

      if (not theItr2.advance (theSeqEl2))
         return true;

      if (theSeqEl1->mySeqNo () < theSeqEl2->mySeqNo ())
         return true;

      if (theSeqEl2->mySeqNo () < theSeqEl1->mySeqNo ())
         return false;
      }
d577 1
a577 1
      mySeqEls_ (theSeqEl->myDemand ()->myProblem ())
d579 1
a579 1
   mySeqEls_.push (theSeqEl);
d585 1
a585 1
      mySeqEls_ (theReqSrcs.myProblem ())
d598 1
a598 1
void WitSrpReqSrc::attachSeqElItr (WitSrpSeqElItr & theItr)
d600 25
a624 1
   mySeqEls_.attachItr (theItr);
d631 1
a631 4
   WitSrpSeqElItr theItr1;
   WitSrpSeqElItr theItr2;
   WitSrpSeqEl *  theSeqEl1;
   WitSrpSeqEl *  theSeqEl2;
d633 2
a634 2
   mySeqEls_           .attachItr (theItr1);
   theReqSrc->mySeqEls_.attachItr (theItr2);
d636 2
a637 3
   while (theItr1.advance (theSeqEl1))
      {
      if (not theItr2.advance (theSeqEl2))
a639 7
      if (theSeqEl1 != theSeqEl2)
         return false;
      }

   if (theItr2.advance (theSeqEl2))
      return false;

d645 1
a645 1
void WitSrpReqSrc::print (const char * leadingBlanks)
d647 1
a647 2
   WitSrpSeqElItr theSeqElItr;
   WitSrpSeqEl *  theSeqEl;
d649 1
a649 1
   fprintf (mySeqEls_.myProblem ()->myMsgFac ().myFile (),
d653 2
a654 4
   mySeqEls_.attachItr (theSeqElItr);

   while (theSeqElItr.advance (theSeqEl))
      fprintf (mySeqEls_.myProblem ()->myMsgFac ().myFile (),
d657 3
a659 3
         theSeqEl->myDemand ()->demandName ().myCstring (),
         theSeqEl->shipPerFor (),
         theSeqEl->mySeqNo ());
d666 1
d674 1
a674 1
   witAssert (mySeqEls_.isEmpty ());
d678 2
d695 3
a697 1
               mySeqEls_.push (theSeqEl);
a700 2
   mySeqEls_.reverse ();

d710 7
a716 3
   WitObjStItr <WitSrpReqSrc>  theItr;
   WitSrpReqSrc *              theReqSrc;
   WitSrpSeqElStack *          theSeqElStPtr;
d724 2
a725 1
      theSeqElStPtr->revCopyFrom (theReqSrc->mySeqEls_);
d730 2
d733 2
@


1.12
log
@[shared-resource pegging]
@
text
@d634 1
a634 1
              mySeqEls_.attachItr (theItr1);
d678 6
a683 7
   WitSrpSeqEl *               minSeqEl;
   WitSrpSeqEl *               theSeqEl;
   WitObjStack <WitSrpSeqEl> * theSeqElStackPtr;

   WitObjStItr <WitObjStack <WitSrpSeqEl> > theItr;
   WitObjStack <WitObjStack <WitSrpSeqEl> > theSeqElStacks (
      theReqSrcs.myProblem ());
d696 1
a696 1
      mySeqEls_.push (minSeqEl);
d698 5
a702 1
      theSeqElStacks.attachItr (theItr);
d704 2
a705 4
      while (theItr.advance (theSeqElStackPtr))
         if (theSeqElStackPtr->isNonEmpty ())
            if (theSeqElStackPtr->firstObject () == minSeqEl)
               theSeqElStackPtr->pop (theSeqEl);
d716 2
a717 2
      const WitSrpReqSrcStack &                  theReqSrcs,
      WitObjStack <WitObjStack <WitSrpSeqEl> > & theSeqElStacks)
d721 1
a721 1
   WitObjStack <WitSrpSeqEl> * theSeqElStackPtr;
d727 1
a727 2
      theSeqElStackPtr =
         new WitObjStack <WitSrpSeqEl> (theReqSrcs.myProblem ());
d729 1
a729 1
      theSeqElStackPtr->revCopyFrom (theReqSrc->mySeqEls_);
d731 1
a731 1
      theSeqElStackPtr->reverse ();
d733 1
a733 1
      theSeqElStacks.push (theSeqElStackPtr);
d740 1
a740 1
      const WitObjStack <WitObjStack <WitSrpSeqEl> > & theSeqElStacks)
d744 1
d746 2
a747 2
   WitObjStItr <WitObjStack <WitSrpSeqEl> > theItr;
   WitObjStack <WitSrpSeqEl> *              theSeqElStackPtr;
d753 2
a754 2
   while (theItr.advance (theSeqElStackPtr))
      if (theSeqElStackPtr->isNonEmpty ())
d756 1
a756 1
         theSeqEl = theSeqElStackPtr->firstObject ();
d758 2
a759 1
         if (minSeqEl == NULL)
d762 2
a763 2
         else if (theSeqEl->mySeqNo () < minSeqEl->mySeqNo ())
            minSeqEl = theSeqEl;
@


1.11
log
@[shared-resource pegging]
@
text
@d300 1
a300 1
         if (prevReqSpec->myReqSrc () == theReqSpec->myReqSrc ())
d627 27
@


1.10
log
@[shared-resource pegging]
@
text
@d30 1
d178 3
d189 3
a276 3
   if (myGlobalComp ()->printSrpDB ())
      prtReqSpecs (false);

a289 3
   if (myGlobalComp ()->printSrpDB ())
      prtReqSpecs (true);

d445 4
a448 1
void WitSrpReqMgr::prtReqSpecs (bool afterSort)
d450 2
a451 4
   int            theIdx;
   WitSrpSeqEl *  theSeqEl;
   WitSrpSeqElItr theItr;
   bool           firstTime;
d457 6
a462 3
      "   %s sorting:\n"
      "      Seq #  Dem  Per  Req\n",
      afterSort? "After": "Before");
d464 1
a464 1
   for (theIdx = 0; theIdx < nReqSpecsInVec_; theIdx ++)
d466 4
a469 3
      myReqSpecVec_[theIdx]->myReqSrc ()->attachSeqElItr (theItr);

      firstTime = true;
d471 1
a471 17
      while (theItr.advance (theSeqEl))
         {
         fprintf (msgFile (),
            "      %5d  %3s  %3d",
            theSeqEl->mySeqNo (),
            theSeqEl->myDemand ()->demandName ().myCstring (),
            theSeqEl->shipPerFor ());

         if (firstTime)
            fprintf (msgFile (),
               "  %3.0f\n",
               myReqSpecVec_[theIdx]->incReqVolFor ());
         else
            fprintf (msgFile (), "\n");

         firstTime = false;
         }
a481 2
   WitSrpSeqElItr              theSeqElItr;
   WitSrpSeqEl *               theSeqEl;
d503 1
d507 1
a507 8
         theReqSpec->myReqSrc ()->attachSeqElItr (theSeqElItr);

         while (theSeqElItr.advance (theSeqEl))
            fprintf (msgFile (),
               "         SeqEl #%d: Demand %s in Ship Per %d\n",
               theSeqEl->mySeqNo (),
               theSeqEl->myDemand ()->demandName ().myCstring (),
               theSeqEl->shipPerFor ());
d627 22
@


1.9
log
@[shared-resource pegging]
@
text
@d225 1
a225 1
   incReqVol        = theReqSpec->incReqVolVal ();
d301 1
a301 1
            prevReqSpec->addToIncReqVol (theReqSpec->incReqVolVal ());
d330 3
d372 1
a372 1
                  incReqVolVal ();
d406 1
a406 1
         if (theReqSpec->incReqVolVal () - deltaIncReqVol > NET_TOL)
d451 2
d471 1
a471 1
            theSeqEl->myShipPer ());
d476 1
a476 1
               myReqSpecVec_[theIdx]->incReqVolVal ());
d487 45
d534 2
d552 1
a552 1
      incReqVolVal_ (0.0)
d570 1
a570 1
   incReqVolVal_ = incReqVol;
d577 1
a577 1
   incReqVolVal_ += deltaIncReqVol;
d579 1
a579 1
   witAssert (incReqVolVal_ >  NET_TOL);
d745 3
a747 3
      myDemand_  (theDemand),
      myShipPer_ (shipPer),
      mySeqNo_   (theSeqNo)
@


1.8
log
@[shared-resource pegging]
@
text
@d626 1
a626 2
   while (theSeqElStacks.pop (theSeqElStackPtr))
      delete theSeqElStackPtr;
@


1.7
log
@[shared-resource pegging]
@
text
@d624 2
d649 2
@


1.6
log
@{shared-resource pegging]
@
text
@d588 1
a588 1
   mySeqEls_.attach (theItr);
d616 1
a616 1
      theSeqElStacks.attach (theItr);
d638 1
a638 1
   theReqSrcs.attach (theItr);
d659 1
a659 1
   WitObjStItr <WitObjStack <WitSrpSeqEl> > theSeqElStackItr;
d664 1
a664 1
   theSeqElStacks.attach (theSeqElStackItr);
d666 1
a666 1
   while (theSeqElStackItr.advance (theSeqElStackPtr))
@


1.5
log
@[shared-resource pegging]
@
text
@a358 2
   stronglyAssert (false);

@


1.4
log
@[shared-resource pegging]
@
text
@d189 1
a189 1
void WitSrpReqMgr::loadCurReqList (WitBopEntry * theBopEnt, WitPeriod execPer)
d191 2
d194 1
d198 5
a202 1
   curReqList_.takeContents (myBopEntReqs_.myElemAt (theBopEnt, execPer));
d204 6
a209 1
   curReqList_.reverse ();
d224 4
a227 1
   theReqSpec->getData (theReqSrc, incReqVol);
a229 2

   retrievedReqSrc_ = theReqSrc;
a279 1
   WitSrpReqSrc *  theReqSrcPrev;
d282 1
a282 2
   WitSrpReqSrc *  theReqSrcCur;
   double          incReqVolCur;
a288 2
   theReqSrcPrev = NULL;

d295 67
a361 1
      theReqSpec->getData (theReqSrcCur, incReqVolCur);
d363 4
a366 1
      if (theReqSrcCur != theReqSrcPrev)
d368 4
a371 1
         curReqList_.push (theReqSpec);
d373 4
a376 1
         theReqSrcPrev = theReqSrcCur;
d378 21
a398 1
      else
d400 10
a409 1
         curReqList_.firstObject ()->addToIncReqVol (incReqVolCur);
d411 2
a412 1
         reclaimReqSpec (theReqSpec);
a413 3
      }

   nReqSpecsInVec_ = 0;
a445 1
   WitSrpReqSrc * theReqSrc;
a446 1
   double         incReqVol;
d448 1
d458 1
a458 1
      myReqSpecVec_[theIdx]->getData (theReqSrc, incReqVol);
d460 1
a460 1
      theReqSrc->mySeqEls ().attach (theItr);
d470 1
a470 1
         if (incReqVol > 0.0)
d473 1
a473 1
               incReqVol);
d477 1
a477 1
         incReqVol = 0.0;
a526 2
   witAssert (deltaIncReqVol >  NET_TOL);

a527 7
   }

//------------------------------------------------------------------------------

void WitSrpReqSpec::getData (WitSrpReqSrc * & theReqSrc, double & incReqVol)
   {
   witAssert (myReqSrc_ != NULL);
d529 1
a529 2
   theReqSrc = myReqSrc_;
   incReqVol = incReqVolVal_;
d543 2
a544 2
   theReqSpec1->myReqSrc_->mySeqEls ().attach (theItr1);
   theReqSpec2->myReqSrc_->mySeqEls ().attach (theItr2);
d574 8
d587 97
@


1.3
log
@[shared-resource pegging]
@
text
@d338 1
d350 1
a350 1
      theSeqEl = theReqSrc->mySeqEl ();
d352 17
a368 6
      fprintf (msgFile (),
         "      %5d  %3s  %3d  %3.0f\n",
         theSeqEl->mySeqNo (),
         theSeqEl->myDemand ()->demandName ().myCstring (),
         theSeqEl->myShipPer (),
         incReqVol);
d438 22
a459 4
   return
      theReqSpec1->myReqSrc_->mySeqEl ()->mySeqNo ()
      <
      theReqSpec2->myReqSrc_->mySeqEl ()->mySeqNo ();
d467 1
a467 1
      mySeqEl_ (theSeqEl)
d469 1
@


1.2
log
@[shared-resource pegging]
@
text
@d250 1
a250 3
   theIdx = -1;

   while (curReqList_.pop (theReqSpec))
d252 1
a252 1
      theIdx ++;
d280 1
a280 1
   for (theIdx = 0; theIdx < nReqSpecsInVec_; theIdx ++)
d428 1
a428 1
      >
@


1.1
log
@[shared-resource pegging]
@
text
@a24 1
#include <PairStack.h>
d47 1
a49 1
      maxReqListLength_ (0),
d62 1
a62 1
            new WitSrpReqPairStack (myProblem ());
d69 1
a69 1
            new WitSrpReqPairStack (myProblem ());
d138 2
d142 3
a144 1
   myPartReqs_.myElemAt (thePart, fillPer).push (theReqSrc, incReqVol);
d155 2
d159 3
a161 1
   myBopEntReqs_.myElemAt (theBopEnt, execPer).push (theReqSrc, incExecVol);
d168 5
a172 1
   loadCurReqList (myPartReqs_.myElemAt (thePart, fillPer));
d191 7
a197 1
   loadCurReqList (myBopEntReqs_.myElemAt (theBopEnt, execPer));
a237 22
void WitSrpReqMgr::loadCurReqList (WitSrpReqPairStack & theReqPairs)
   {
   WitSrpReqSrc *  theReqSrc;
   double          incReqVol;
   WitSrpReqSpec * theReqSpec;

   witAssert (curReqListIsEmpty ());

   while (theReqPairs.pop (theReqSrc, incReqVol))
      {
      theReqSpec = provideReqSpec (theReqSrc, incReqVol);

      curReqList_.push (theReqSpec);
      }

   setToMax (maxReqListLength_, curReqList_.nElements ());

   retrievedReqSrc_ = NULL;
   }

//------------------------------------------------------------------------------

d261 2
d282 1
a282 1
   for (theIdx = nReqSpecsInVec_ - 1; theIdx >= 0; theIdx --)
d368 1
a368 1
      "Max SRP Req List Length:        %d\n"
d371 1
a371 1
      maxReqListLength_,
d430 1
a430 1
      < 
@


head	1.138;
access;
symbols
	sce_5_01_20080919:1.130
	latest_sce_4_20_20060523:1.117.0.2
	sce_4_20_20060523:1.117
	latest_sce4_20_OSL:1.116.0.2
	sce_4_20_OSL:1.116
	sce_410_withVa:1.72
	sce_4_05_20040511:1.36
	sce_4_00_20040201:1.18
	nextGenBranch:1.16.0.2
	nextGenRoot:1.16
	sce_3_30_20030627:1.15
	EndRw-branch:1.13.0.4
	Root-of-EndRw:1.13
	rwToStl:1.13.0.2
	latest_sce_3_10_20010924:1.7.0.2
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.6.0.2
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.5.0.4
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.138
date	2011.09.28.23.49.01;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2011.09.24.00.27.18;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2011.08.30.20.17.14;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2010.09.10.22.10.37;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2009.10.08.16.06.02;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2009.10.07.22.08.37;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2009.02.04.22.27.35;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2008.11.12.19.52.25;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2008.07.02.17.48.36;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2007.08.01.22.41.55;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2007.01.12.20.00.37;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2007.01.11.22.53.24;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2007.01.11.18.38.31;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2006.11.02.23.07.13;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2006.10.05.18.19.15;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2006.08.29.17.37.54;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2006.08.24.20.50.27;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2006.08.24.17.50.52;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2006.08.22.21.26.54;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2006.08.21.15.29.29;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2006.07.31.17.26.09;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2006.05.02.17.33.54;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2005.11.04.21.53.35;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2005.11.04.20.42.54;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2005.11.02.23.59.31;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2005.11.01.21.58.10;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2005.11.01.16.30.55;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2005.10.31.22.00.50;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2005.10.31.21.29.25;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2005.10.28.22.28.08;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2005.10.28.20.29.10;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2005.10.28.17.22.58;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2005.10.24.22.37.49;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2005.10.21.22.23.34;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2005.10.21.18.50.58;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2005.10.21.16.10.58;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2005.10.21.15.37.51;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2005.10.19.20.53.07;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2005.10.18.20.56.21;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2005.10.17.22.07.38;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2005.10.17.21.24.02;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2005.10.17.15.02.06;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2005.10.12.22.58.30;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2005.10.10.14.59.57;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2005.10.07.20.01.22;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2005.10.07.17.14.21;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2005.10.07.15.21.44;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2005.10.06.15.47.34;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2005.09.27.19.54.36;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2005.09.27.18.41.24;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2005.09.20.21.47.57;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2005.09.20.21.15.11;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.09.19.14.49.33;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2005.09.16.15.38.42;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2005.09.16.14.58.48;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2005.09.15.21.57.42;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2005.09.15.19.58.21;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2005.09.15.19.47.10;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.15.18.57.52;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.09.15.18.11.23;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2005.09.15.16.10.42;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2005.09.15.15.27.20;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2005.09.14.22.44.10;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2005.09.14.21.54.45;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2005.09.13.19.31.56;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2005.09.12.22.17.33;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2005.09.06.20.43.26;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2005.09.06.17.51.31;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.06.17.33.36;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.09.01.21.45.02;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.08.31.22.11.00;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.08.31.19.00.36;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2005.08.29.21.44.42;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.29.20.29.48;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.29.19.14.35;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2005.08.25.21.47.39;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.24.19.26.42;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2005.08.23.17.38.58;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2005.08.22.20.38.59;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.19.23.24.11;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.19.21.38.02;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2005.08.12.19.35.29;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.15.18.52.54;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.14.18.16.49;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.07.13.21.18.46;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.07.13.15.54.09;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.11.22.53.49;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.07.11.19.51.28;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.07.08.21.02.12;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.08.20.48.19;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.08.15.59.42;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.06.22.21.30;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.05.22.40.32;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.05.22.04.25;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.05.20.07.19;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.16.17.00.30;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.03.21.25.12;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.13.19.21.34;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.13.20.53.55;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.12.21.50.59;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.12.19.43.31;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.12.18.19.21;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.20.21.37.51;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.19.22.16.27;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.13.21.50.12;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.09.19.37.57;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.25.20.35.02;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.23.21.01.02;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.12.15.09.23;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.27.21.00.28;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.26.20.40.26;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.26.18.59.42;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.24.22.29.04;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.24.19.37.22;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.19.16.31.24;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.19.16.08.16;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.18.00.05.24;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.17.20.23.46;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.14.00.45.34;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.10.23.57.45;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.08.19.27.43;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.01.21.05.02;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.10.19.57.15;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.02.23.40.35;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.02.22.18.17;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.09.20.49.47;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.09.19.52.29;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.08.21.58.52;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.03.23.16.34;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.24.18.26.04;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.14.02.26;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.01.19.23.31;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.25.14.53.22;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.20.12.29;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.18;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.29;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.16;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.18;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.18;	author wit;	state Exp;
branches;
next	;


desc
@@


1.138
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "ApiMgr.C"
//
// Contains the implementation of the following classes:
//
//    ApiMgr.
//    InputID.
//------------------------------------------------------------------------------

#include <ApiMgr.h>
#include <InputID.h>
#include <AbortApiExc.h>
#include <IssueMsgExc.h>
#include <SaeMgr.h>
#include <WitRun.h>
#include <Demand.h>
#include <Part.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BomEntry.h>
#include <BopEntry.h>
#include <DetOptImpMgr.h>
#include <RealArg.h>
#include <MsgFac.h>

#include <stdlib.h>

//------------------------------------------------------------------------------
// Implementation of class ApiMgr.
//------------------------------------------------------------------------------

bool WitApiMgr::newHandlerSet_ = false;

//------------------------------------------------------------------------------

inline WitMsgFacility & WitApiMgr::myMsgFac ()
   {
   return myWitRun_->myMsgFac ();
   }

//------------------------------------------------------------------------------
// Constructor
//------------------------------------------------------------------------------

WitApiMgr::WitApiMgr (WitRun * theWitRun):
      myWitRun_         (theWitRun),
      mySession_        (NULL),
      myInputID_        (NULL),
      myWitRunIsLocked_ (false),
      apiFuncName_      (NULL),
      startInnerNeeded_ (false),
      mustSkipCallMsg_  (false),
      preInitAllowed_   (false),
      extOptActAllowed_ (false),
      prevApiAbort_     (false),
      myApiMgr2_        (NULL),
      tempIntVec_       (),
      tempDblVec_       (),
      tempVecsReserved_ (false)
   {
   setUpNewFailure ();

   mySession_ = new WitSession (this);
   myInputID_ = new WitInputID (this);
   }

//------------------------------------------------------------------------------

WitApiMgr::~WitApiMgr ()
   {
   delete myInputID_;
   delete mySession_;
   }

//------------------------------------------------------------------------------

void WitApiMgr::startApiFunc (WitRun * theWitRun, const char * theFuncName)
   {
   WitApiMgr * theApiMgr;

   WitRun::validateWitRun (theWitRun, theFuncName);

   theApiMgr = theWitRun->myApiMgr ();

   theApiMgr->lockMyWitRun (theFuncName);

   theApiMgr->apiRc_ = WitINFORMATIONAL_RC;

   if (theApiMgr->prevApiAbort_)
      theApiMgr->myMsgFac () ("postErrApiCallSameWRSmsg",
         theApiMgr->apiFuncName_);

   theApiMgr->startInnerNeeded_ = true;
   theApiMgr->mustSkipCallMsg_  = false;
   theApiMgr->preInitAllowed_   = false;
   theApiMgr->extOptActAllowed_ = false;
   }

//------------------------------------------------------------------------------

void WitApiMgr::finishApiFunc ()
   {
   nonMsgAssert (not startInnerNeeded_);

   if (myApiMgr2_ != NULL)
      {
      setToMax (apiRc_, myApiMgr2_->apiRc_);

      myApiMgr2_->unlockMyWitRun ();

      myApiMgr2_ = NULL;
      }

   unlockMyWitRun ();
   }

//------------------------------------------------------------------------------

void WitApiMgr::handleAnyExc ()
   {
   try
      {
      try
         {
         throw;
         }

      catch (WitAbortApiExc &)
         {
         throw;
         }

      catch (WitIssueMsgExc & theIssueMsgExc)
         {
         handleIssueMsgExc (theIssueMsgExc);
         }

      catch (std::bad_alloc &)
         {
         myMsgFac () ("memoryErrorSmsg");
         }

      catch (std::exception & theStdExc)
         {
         myMsgFac () ("stdExcFmsg", theStdExc.what ());
         }

      catch (...)
         {
         myMsgFac () ("unknownExcFmsg");
         }
      }

   catch (WitAbortApiExc & theAbortApiExc)
      {
      handleAbortApiExc (theAbortApiExc);
      }
   }

//------------------------------------------------------------------------------

void WitApiMgr::lockMyWitRun (const char * theFuncName)
   {
   if (myWitRunIsLocked_)
      {
      startNonMsgSevereError ();

      fprintf (stderr,
         "WIT Thread-safety error:\n"
         "\n"
         "   An API function was called while the previous API function call\n"
         "   with the same WitRun argument was still in progress.\n"
         "   Overlapping API function calls with the same WitRun argument\n"
         "   are not allowed.\n"
         "\n"
         "      Previous Function: %s\n"
         "      Current  Function: %s\n",
         apiFuncName_,
         theFuncName);

      finishNonMsgSevereError ();
      }

   myWitRunIsLocked_ = true;

   apiFuncName_      = theFuncName;
   }

//------------------------------------------------------------------------------

void WitApiMgr::unlockMyWitRun ()
   {
   nonMsgAssert (myWitRunIsLocked_);

   apiFuncName_      = NULL;
   myWitRunIsLocked_ = false;
   }

//------------------------------------------------------------------------------

void WitApiMgr::skipCallMsg ()
   {
   if (not startInnerNeeded_)
      return;

   nonMsgAssert (not mustSkipCallMsg_);

   mustSkipCallMsg_ = true;
   }

//------------------------------------------------------------------------------

void WitApiMgr::allowPreInit ()
   {
   if (not startInnerNeeded_)
      return;

   nonMsgAssert (not preInitAllowed_);

   preInitAllowed_ = true;
   }

//------------------------------------------------------------------------------

void WitApiMgr::allowExtOptActive ()
   {
   if (not startInnerNeeded_)
      return;

   nonMsgAssert (not extOptActAllowed_);

   extOptActAllowed_ = true;
   }

//------------------------------------------------------------------------------

void WitApiMgr::startInnerFunc ()
   {
   if (not startInnerNeeded_)
      return;

   startInnerNeeded_ = false;

   if (not mustSkipCallMsg_)
      if (myMsgFac ().mayIssue ("witFuncCalled"))
         myMsgFac () ("witFuncCalled", apiFuncName_);

   if (not preInitAllowed_)
      if (not myWitRun_->mySession ()->active ())
         myMsgFac () ("callBeforeInitSMsg", apiFuncName_);

   if (strncmp (apiFuncName_ + 3, "Get", 3) == 0)
      {
      nonMsgAssert (not extOptActAllowed_);

      extOptActAllowed_ = true;
      }

   if (not extOptActAllowed_)
      if (myWitRun_->myDetOptImpMgr ()->extOptActive ())
         myMsgFac () ("extOptActiveSmsg", apiFuncName_);

   mustSkipCallMsg_  = false;
   preInitAllowed_   = false;
   extOptActAllowed_ = false;
   }

//------------------------------------------------------------------------------

void WitApiMgr::start2WitRunFunc (WitApiMgr * theApiMgr2)
   {
   if (theApiMgr2 == this)
      return;

   nonMsgAssert (myApiMgr2_ == NULL);

   myApiMgr2_ = theApiMgr2;

   myApiMgr2_->lockMyWitRun (apiFuncName_);

   if (myApiMgr2_->prevApiAbort_)
      myMsgFac () ("postErrApiCallSameWRSmsg", apiFuncName_);

   myApiMgr2_->apiRc_ = WitINFORMATIONAL_RC;
   }

//------------------------------------------------------------------------------

void WitApiMgr::updateApiRc (WitReturnCode theRc)
   {
   setToMax (apiRc_, theRc);
   }

//------------------------------------------------------------------------------

#if defined(_MSC_VER)

#include <new.h>

void WitApiMgr::setUpNewFailure ()
   {
   if (newHandlerSet_)
      return;

   _set_new_handler (throwBadAlloc);

   newHandlerSet_ = true;
   }

#else

void WitApiMgr::setUpNewFailure ()
   {
   }

#endif

//------------------------------------------------------------------------------

int WitApiMgr::throwBadAlloc (size_t)
   {
   throw std::bad_alloc ();
   }

//------------------------------------------------------------------------------

void WitApiMgr::handleIssueMsgExc (WitIssueMsgExc & theIssueMsgExc)
   {
   myMsgFac () (theIssueMsgExc.myMsgID (),
      theIssueMsgExc.myMsgArg1 (),
      theIssueMsgExc.myMsgArg2 (),
      theIssueMsgExc.myMsgArg3 ());

   myMsgFac () ("invIssueByExcFmsg");
   }

//------------------------------------------------------------------------------

void WitApiMgr::handleAbortApiExc (WitAbortApiExc & theAbortApiExc)
   {
   WitString theFuncName;

   theFuncName   = apiFuncName_;

   if (myApiMgr2_ != NULL)
      myApiMgr2_->prevApiAbort_ = true;

   prevApiAbort_ = true;

   finishApiFunc ();

   abortApiFunc (theAbortApiExc, theFuncName);
   }

//------------------------------------------------------------------------------

void WitApiMgr::abortApiFunc (
      WitAbortApiExc &  theAbortApiExc,
      const WitString & theFuncName)
   {
   if      (theAbortApiExc.stopRunning ())
      {
      myMsgFac () ("witStopsSmsg", apiRc_);

      fflush (stdout);

      exit (apiRc_);
      }
   else if (theAbortApiExc.throwErrorExc ())
      {
      WitErrorExc theErrorExc (
         theFuncName   .myCstring (),
         theAbortApiExc.myMsgNum (),
         apiRc_);

      myMsgFac () ("throwWitExcSmsg", apiRc_);

      throw theErrorExc;
      }
   else
      myMsgFac () ("returnOnErrorSmsg", apiRc_);
   }

//------------------------------------------------------------------------------

WitTVec <WitBoolean> & WitApiMgr::reserveTempBooleanVec ()
   {
   return reserveTempIntVec ();
   }

//------------------------------------------------------------------------------

WitTVec <int> & WitApiMgr::reserveTempIntVec ()
   {
   stronglyAssert (not tempVecsReserved_);

   tempVecsReserved_ = true;

   if (tempIntVec_.length () != mySession ()->myProblem ()->nPeriods ())
      tempIntVec_.allocate (mySession ()->myProblem (), 0);

   return tempIntVec_;
   }

//------------------------------------------------------------------------------

WitTVec <double> & WitApiMgr::reserveTempDblVec ()
   {
   stronglyAssert (not tempVecsReserved_);

   tempVecsReserved_ = true;

   if (tempDblVec_.length () != mySession ()->myProblem ()->nPeriods ())
      tempDblVec_.allocate (mySession ()->myProblem (), 0);

   return tempDblVec_;
   }

//------------------------------------------------------------------------------

void WitApiMgr::releaseTempVecs ()
   {
   stronglyAssert (tempVecsReserved_);

   tempVecsReserved_ = false;
   }

//------------------------------------------------------------------------------

void WitApiMgr::resetInputID ()
   {
   delete myInputID ();

   myInputID_ = new WitInputID (this);
   }

//------------------------------------------------------------------------------
// Implementation of class InputID.
//------------------------------------------------------------------------------

WitInputID::WitInputID (WitApiMgr * theApiMgr):

      myApiMgr_       (theApiMgr),
      myAttName_      (NULL),
      myPart_         (NULL),
      myOperation_    (NULL),
      myDemand_       (NULL),
      myBomEnt_       (NULL),
      mySub_          (NULL),
      myBopEnt_       (NULL),
      argName_        (NULL),
      argIndex_       (-1),
      dataFileName_   (NULL),
      dataFileLineNo_ (0),
      errorPeriod_    (-1)
   {
   }

//------------------------------------------------------------------------------

WitInputID::~WitInputID ()
   {
   }

//------------------------------------------------------------------------------

void WitInputID::setMyAttName (const char * theAttName)
   {
   myAttName_ = theAttName;
   }

//------------------------------------------------------------------------------

void WitInputID::setMyPart (WitPart * thePart)
   {
   myPart_ = thePart;
   }

//------------------------------------------------------------------------------

void WitInputID::setMyOperation (WitOperation * theOpn)
   {
   myOperation_ = theOpn;
   }

//------------------------------------------------------------------------------

void WitInputID::setMyDemand (WitDemand * theDemand)
   {
   myDemand_ = theDemand;
   }

//------------------------------------------------------------------------------

void WitInputID::setMyBomEntry (WitBomEntry * theBomEnt)
   {
   myBomEnt_ = theBomEnt;
   }

//------------------------------------------------------------------------------

void WitInputID::setMySubEntry (WitSubEntry * theSub)
   {
   mySub_ = theSub;
   }

//------------------------------------------------------------------------------

void WitInputID::setMyBopEntry (WitBopEntry * theBopEnt)
   {
   myBopEnt_ = theBopEnt;
   }

//------------------------------------------------------------------------------

void WitInputID::setArgName (const char * theName)
   {
   argName_ = theName;
   }

//------------------------------------------------------------------------------

void WitInputID::setArgIndex (int theIndex)
   {
   argIndex_ = theIndex;
   }

//------------------------------------------------------------------------------

void WitInputID::setDataFileName (const char * theName)
   {
   dataFileName_ = theName;
   }

//------------------------------------------------------------------------------

void WitInputID::setDataFileLineNo (int theValue)
   {
   dataFileLineNo_ = theValue;
   }

//------------------------------------------------------------------------------

void WitInputID::setErrorPeriod (WitPeriod t)
   {
   errorPeriod_ = t;
   }

//------------------------------------------------------------------------------

void WitInputID::idInput ()
   {
   WitMsgFacility & theMsgFac = myApiMgr_->myWitRun ()->myMsgFac ();

   if (myAttName_ != NULL)
      theMsgFac ("inputAttribSmsg", myAttName_);

   if (argName_ != NULL)
      {
      if (argIndex_ >= 0)
         theMsgFac ("inputArgElSmsg", argName_, argIndex_);
      else
         theMsgFac ("inputArgumentSmsg", argName_);
      }

   if (errorPeriod_ >= 0)
      theMsgFac ("inputPeriodSmsg", errorPeriod_);

   if (myPart_ != NULL)
      theMsgFac ("inputPartNameSmsg", myPart_->partName ());

   if (myOperation_ != NULL)
      theMsgFac ("inputOperationNameSmsg", myOperation_->operationName ());

   if (myDemand_ != NULL)
      theMsgFac ("inputDemandNameSmsg", myDemand_->demandName ());

   if      (mySub_ != NULL)
      theMsgFac ("inputConsumedPartNameSmsg", mySub_->myPartName ());
   else if (myBomEnt_ != NULL)
      theMsgFac ("inputConsumedPartNameSmsg", myBomEnt_->myPartName ());

   if (myBopEnt_ != NULL)
      theMsgFac ("inputProducedPartNameSmsg", myBopEnt_->myPartName ());

   if (myBomEnt_ != NULL)
      theMsgFac ("inputBomIndexSmsg", myBomEnt_->localIndex ());

   if (mySub_ != NULL)
      theMsgFac ("inputSubsBomEntryIndexSmsg", mySub_->localIndex ());

   if (myBopEnt_ != NULL)
      theMsgFac ("inputBopIndexSmsg", myBopEnt_->localIndex ());

   if (dataFileName_ != NULL)
      theMsgFac ("inputFileNameSmsg", dataFileName_);

   if (dataFileLineNo_ != 0)
      theMsgFac ("inputFileLineNumberSmsg", dataFileLineNo_);

   if (not WitSaeMgr::standAloneMode ())
      if (myApiMgr_->apiFuncName () != NULL)
         theMsgFac ("apiFunctionSmsg", myApiMgr_->apiFuncName ());
   }

//------------------------------------------------------------------------------

bool WitNonClass::asaBool (WitBoolean theBoolean)
   {
   return
      theBoolean?
         true:
         false;
   }
@


1.137
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.136
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d46 3
a48 3
{
return myWitRun_->myMsgFac ();
}
d55 20
a74 20
myWitRun_         (theWitRun),
mySession_        (NULL),
myInputID_        (NULL),
myWitRunIsLocked_ (false),
apiFuncName_      (NULL),
startInnerNeeded_ (false),
mustSkipCallMsg_  (false),
preInitAllowed_   (false),
extOptActAllowed_ (false),
prevApiAbort_     (false),
myApiMgr2_        (NULL),
tempIntVec_       (),
tempDblVec_       (),
tempVecsReserved_ (false)
{
setUpNewFailure ();

mySession_ = new WitSession (this);
myInputID_ = new WitInputID (this);
}
d79 4
a82 4
{
delete myInputID_;
delete mySession_;
}
d87 2
a88 2
{
WitApiMgr * theApiMgr;
d90 1
a90 1
WitRun::validateWitRun (theWitRun, theFuncName);
d92 1
a92 1
theApiMgr = theWitRun->myApiMgr ();
d94 1
a94 1
theApiMgr->lockMyWitRun (theFuncName);
d96 1
a96 1
theApiMgr->apiRc_ = WitINFORMATIONAL_RC;
d98 3
a100 3
if (theApiMgr->prevApiAbort_)
theApiMgr->myMsgFac () ("postErrApiCallSameWRSmsg",
theApiMgr->apiFuncName_);
d102 5
a106 5
theApiMgr->startInnerNeeded_ = true;
theApiMgr->mustSkipCallMsg_  = false;
theApiMgr->preInitAllowed_   = false;
theApiMgr->extOptActAllowed_ = false;
}
d111 2
a112 2
{
nonMsgAssert (not startInnerNeeded_);
d114 3
a116 3
if (myApiMgr2_ != NULL)
{
setToMax (apiRc_, myApiMgr2_->apiRc_);
d118 1
a118 1
myApiMgr2_->unlockMyWitRun ();
d120 2
a121 2
myApiMgr2_ = NULL;
}
d123 2
a124 2
unlockMyWitRun ();
}
d129 39
a167 39
{
try
{
try
{
throw;
}

catch (WitAbortApiExc &)
{
throw;
}

catch (WitIssueMsgExc & theIssueMsgExc)
{
handleIssueMsgExc (theIssueMsgExc);
}

catch (std::bad_alloc &)
{
myMsgFac () ("memoryErrorSmsg");
}

catch (std::exception & theStdExc)
{
myMsgFac () ("stdExcFmsg", theStdExc.what ());
}

catch (...)
{
myMsgFac () ("unknownExcFmsg");
}
}

catch (WitAbortApiExc & theAbortApiExc)
{
handleAbortApiExc (theAbortApiExc);
}
}
d172 17
a188 17
{
if (myWitRunIsLocked_)
{
startNonMsgSevereError ();

fprintf (stderr,
"WIT Thread-safety error:\n"
"\n"
"   An API function was called while the previous API function call\n"
"   with the same WitRun argument was still in progress.\n"
"   Overlapping API function calls with the same WitRun argument\n"
"   are not allowed.\n"
"\n"
"      Previous Function: %s\n"
"      Current  Function: %s\n",
apiFuncName_,
theFuncName);
d190 2
a191 2
finishNonMsgSevereError ();
}
d193 1
a193 1
myWitRunIsLocked_ = true;
d195 2
a196 2
apiFuncName_      = theFuncName;
}
d201 2
a202 2
{
nonMsgAssert (myWitRunIsLocked_);
d204 3
a206 3
apiFuncName_      = NULL;
myWitRunIsLocked_ = false;
}
d211 3
a213 3
{
if (not startInnerNeeded_)
return;
d215 1
a215 1
nonMsgAssert (not mustSkipCallMsg_);
d217 2
a218 2
mustSkipCallMsg_ = true;
}
d223 3
a225 3
{
if (not startInnerNeeded_)
return;
d227 1
a227 1
nonMsgAssert (not preInitAllowed_);
d229 2
a230 2
preInitAllowed_ = true;
}
d235 3
a237 3
{
if (not startInnerNeeded_)
return;
d239 1
a239 1
nonMsgAssert (not extOptActAllowed_);
d241 2
a242 2
extOptActAllowed_ = true;
}
d247 29
a275 29
{
if (not startInnerNeeded_)
return;

startInnerNeeded_ = false;

if (not mustSkipCallMsg_)
if (myMsgFac ().mayIssue ("witFuncCalled"))
myMsgFac () ("witFuncCalled", apiFuncName_);

if (not preInitAllowed_)
if (not myWitRun_->mySession ()->active ())
myMsgFac () ("callBeforeInitSMsg", apiFuncName_);

if (strncmp (apiFuncName_ + 3, "Get", 3) == 0)
{
nonMsgAssert (not extOptActAllowed_);

extOptActAllowed_ = true;
}

if (not extOptActAllowed_)
if (myWitRun_->myDetOptImpMgr ()->extOptActive ())
myMsgFac () ("extOptActiveSmsg", apiFuncName_);

mustSkipCallMsg_  = false;
preInitAllowed_   = false;
extOptActAllowed_ = false;
}
d280 3
a282 3
{
if (theApiMgr2 == this)
return;
d284 1
a284 1
nonMsgAssert (myApiMgr2_ == NULL);
d286 1
a286 1
myApiMgr2_ = theApiMgr2;
d288 1
a288 1
myApiMgr2_->lockMyWitRun (apiFuncName_);
d290 2
a291 2
if (myApiMgr2_->prevApiAbort_)
myMsgFac () ("postErrApiCallSameWRSmsg", apiFuncName_);
d293 2
a294 2
myApiMgr2_->apiRc_ = WitINFORMATIONAL_RC;
}
d299 3
a301 3
{
setToMax (apiRc_, theRc);
}
d310 3
a312 3
{
if (newHandlerSet_)
return;
d314 1
a314 1
_set_new_handler (throwBadAlloc);
d316 2
a317 2
newHandlerSet_ = true;
}
d322 2
a323 2
{
}
d330 3
a332 3
{
throw std::bad_alloc ();
}
d337 5
a341 5
{
myMsgFac () (theIssueMsgExc.myMsgID (),
theIssueMsgExc.myMsgArg1 (),
theIssueMsgExc.myMsgArg2 (),
theIssueMsgExc.myMsgArg3 ());
d343 2
a344 2
myMsgFac () ("invIssueByExcFmsg");
}
d349 2
a350 2
{
WitString theFuncName;
d352 1
a352 1
theFuncName   = apiFuncName_;
d354 2
a355 2
if (myApiMgr2_ != NULL)
myApiMgr2_->prevApiAbort_ = true;
d357 1
a357 1
prevApiAbort_ = true;
d359 1
a359 1
finishApiFunc ();
d361 2
a362 2
abortApiFunc (theAbortApiExc, theFuncName);
}
d367 25
a391 25
WitAbortApiExc &  theAbortApiExc,
const WitString & theFuncName)
{
if      (theAbortApiExc.stopRunning ())
{
myMsgFac () ("witStopsSmsg", apiRc_);

fflush (stdout);

exit (apiRc_);
}
else if (theAbortApiExc.throwErrorExc ())
{
WitErrorExc theErrorExc (
theFuncName   .myCstring (),
theAbortApiExc.myMsgNum (),
apiRc_);

myMsgFac () ("throwWitExcSmsg", apiRc_);

throw theErrorExc;
}
else
myMsgFac () ("returnOnErrorSmsg", apiRc_);
}
d396 3
a398 3
{
return reserveTempIntVec ();
}
d403 2
a404 2
{
stronglyAssert (not tempVecsReserved_);
d406 1
a406 1
tempVecsReserved_ = true;
d408 2
a409 2
if (tempIntVec_.length () != mySession ()->myProblem ()->nPeriods ())
tempIntVec_.allocate (mySession ()->myProblem (), 0);
d411 2
a412 2
return tempIntVec_;
}
d417 2
a418 2
{
stronglyAssert (not tempVecsReserved_);
d420 1
a420 1
tempVecsReserved_ = true;
d422 2
a423 2
if (tempDblVec_.length () != mySession ()->myProblem ()->nPeriods ())
tempDblVec_.allocate (mySession ()->myProblem (), 0);
d425 2
a426 2
return tempDblVec_;
}
d431 2
a432 2
{
stronglyAssert (tempVecsReserved_);
d434 2
a435 2
tempVecsReserved_ = false;
}
d440 2
a441 2
{
delete myInputID ();
d443 2
a444 2
myInputID_ = new WitInputID (this);
}
d452 15
a466 15
myApiMgr_       (theApiMgr),
myAttName_      (NULL),
myPart_         (NULL),
myOperation_    (NULL),
myDemand_       (NULL),
myBomEnt_       (NULL),
mySub_          (NULL),
myBopEnt_       (NULL),
argName_        (NULL),
argIndex_       (-1),
dataFileName_   (NULL),
dataFileLineNo_ (0),
errorPeriod_    (-1)
{
}
d471 2
a472 2
{
}
d477 3
a479 3
{
myAttName_ = theAttName;
}
d484 3
a486 3
{
myPart_ = thePart;
}
d491 3
a493 3
{
myOperation_ = theOpn;
}
d498 3
a500 3
{
myDemand_ = theDemand;
}
d505 3
a507 3
{
myBomEnt_ = theBomEnt;
}
d512 3
a514 3
{
mySub_ = theSub;
}
d519 3
a521 3
{
myBopEnt_ = theBopEnt;
}
d526 3
a528 3
{
argName_ = theName;
}
d533 3
a535 3
{
argIndex_ = theIndex;
}
d540 3
a542 3
{
dataFileName_ = theName;
}
d547 3
a549 3
{
dataFileLineNo_ = theValue;
}
d554 3
a556 3
{
errorPeriod_ = t;
}
d561 2
a562 2
{
WitMsgFacility & theMsgFac = myApiMgr_->myWitRun ()->myMsgFac ();
d564 2
a565 2
if (myAttName_ != NULL)
theMsgFac ("inputAttribSmsg", myAttName_);
d567 7
a573 7
if (argName_ != NULL)
{
if (argIndex_ >= 0)
theMsgFac ("inputArgElSmsg", argName_, argIndex_);
else
theMsgFac ("inputArgumentSmsg", argName_);
}
d575 2
a576 2
if (errorPeriod_ >= 0)
theMsgFac ("inputPeriodSmsg", errorPeriod_);
d578 2
a579 2
if (myPart_ != NULL)
theMsgFac ("inputPartNameSmsg", myPart_->partName ());
d581 2
a582 2
if (myOperation_ != NULL)
theMsgFac ("inputOperationNameSmsg", myOperation_->operationName ());
d584 2
a585 2
if (myDemand_ != NULL)
theMsgFac ("inputDemandNameSmsg", myDemand_->demandName ());
d587 4
a590 4
if      (mySub_ != NULL)
theMsgFac ("inputConsumedPartNameSmsg", mySub_->myPartName ());
else if (myBomEnt_ != NULL)
theMsgFac ("inputConsumedPartNameSmsg", myBomEnt_->myPartName ());
d592 2
a593 2
if (myBopEnt_ != NULL)
theMsgFac ("inputProducedPartNameSmsg", myBopEnt_->myPartName ());
d595 2
a596 2
if (myBomEnt_ != NULL)
theMsgFac ("inputBomIndexSmsg", myBomEnt_->localIndex ());
d598 2
a599 2
if (mySub_ != NULL)
theMsgFac ("inputSubsBomEntryIndexSmsg", mySub_->localIndex ());
d601 2
a602 2
if (myBopEnt_ != NULL)
theMsgFac ("inputBopIndexSmsg", myBopEnt_->localIndex ());
d604 2
a605 2
if (dataFileName_ != NULL)
theMsgFac ("inputFileNameSmsg", dataFileName_);
d607 2
a608 2
if (dataFileLineNo_ != 0)
theMsgFac ("inputFileLineNumberSmsg", dataFileLineNo_);
d610 4
a613 4
if (not WitSaeMgr::standAloneMode ())
if (myApiMgr_->apiFuncName () != NULL)
theMsgFac ("apiFunctionSmsg", myApiMgr_->apiFuncName ());
}
d618 6
a623 6
{
return
theBoolean?
true:
false;
}
@


1.135
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d46 3
a48 3
   {
   return myWitRun_->myMsgFac ();
   }
d55 20
a74 20
      myWitRun_         (theWitRun),
      mySession_        (NULL),
      myInputID_        (NULL),
      myWitRunIsLocked_ (false),
      apiFuncName_      (NULL),
      startInnerNeeded_ (false),
      mustSkipCallMsg_  (false),
      preInitAllowed_   (false),
      extOptActAllowed_ (false),
      prevApiAbort_     (false),
      myApiMgr2_        (NULL),
      tempIntVec_       (),
      tempDblVec_       (),
      tempVecsReserved_ (false)
   {
   setUpNewFailure ();

   mySession_ = new WitSession (this);
   myInputID_ = new WitInputID (this);
   }
d79 4
a82 4
   {
   delete myInputID_;
   delete mySession_;
   }
d87 2
a88 2
   {
   WitApiMgr * theApiMgr;
d90 1
a90 1
   WitRun::validateWitRun (theWitRun, theFuncName);
d92 1
a92 1
   theApiMgr = theWitRun->myApiMgr ();
d94 1
a94 1
   theApiMgr->lockMyWitRun (theFuncName);
d96 1
a96 1
   theApiMgr->apiRc_ = WitINFORMATIONAL_RC;
d98 3
a100 3
   if (theApiMgr->prevApiAbort_)
      theApiMgr->myMsgFac () ("postErrApiCallSameWRSmsg",
         theApiMgr->apiFuncName_);
d102 5
a106 5
   theApiMgr->startInnerNeeded_ = true;
   theApiMgr->mustSkipCallMsg_  = false;
   theApiMgr->preInitAllowed_   = false;
   theApiMgr->extOptActAllowed_ = false;
   }
d111 2
a112 2
   {
   nonMsgAssert (not startInnerNeeded_);
d114 3
a116 3
   if (myApiMgr2_ != NULL)
      {
      setToMax (apiRc_, myApiMgr2_->apiRc_);
d118 1
a118 1
      myApiMgr2_->unlockMyWitRun ();
d120 2
a121 2
      myApiMgr2_ = NULL;
      }
d123 2
a124 2
   unlockMyWitRun ();
   }
d129 39
a167 39
   {
   try
      {
      try
         {
         throw;
         }

      catch (WitAbortApiExc &)
         {
         throw;
         }

      catch (WitIssueMsgExc & theIssueMsgExc)
         {
         handleIssueMsgExc (theIssueMsgExc);
         }

      catch (std::bad_alloc &)
         {
         myMsgFac () ("memoryErrorSmsg");
         }

      catch (std::exception & theStdExc)
         {
         myMsgFac () ("stdExcFmsg", theStdExc.what ());
         }

      catch (...)
         {
         myMsgFac () ("unknownExcFmsg");
         }
      }

   catch (WitAbortApiExc & theAbortApiExc)
      {
      handleAbortApiExc (theAbortApiExc);
      }
   }
d172 17
a188 17
   {
   if (myWitRunIsLocked_)
      {
      startNonMsgSevereError ();

      fprintf (stderr,
         "WIT Thread-safety error:\n"
         "\n"
         "   An API function was called while the previous API function call\n"
         "   with the same WitRun argument was still in progress.\n"
         "   Overlapping API function calls with the same WitRun argument\n"
         "   are not allowed.\n"
         "\n"
         "      Previous Function: %s\n"
         "      Current  Function: %s\n",
         apiFuncName_,
         theFuncName);
d190 2
a191 2
      finishNonMsgSevereError ();
      }
d193 1
a193 1
   myWitRunIsLocked_ = true;
d195 2
a196 2
   apiFuncName_      = theFuncName;
   }
d201 2
a202 2
   {
   nonMsgAssert (myWitRunIsLocked_);
d204 3
a206 3
   apiFuncName_      = NULL;
   myWitRunIsLocked_ = false;
   }
d211 3
a213 3
   {
   if (not startInnerNeeded_)
      return;
d215 1
a215 1
   nonMsgAssert (not mustSkipCallMsg_);
d217 2
a218 2
   mustSkipCallMsg_ = true;
   }
d223 3
a225 3
   {
   if (not startInnerNeeded_)
      return;
d227 1
a227 1
   nonMsgAssert (not preInitAllowed_);
d229 2
a230 2
   preInitAllowed_ = true;
   }
d235 3
a237 3
   {
   if (not startInnerNeeded_)
      return;
d239 1
a239 1
   nonMsgAssert (not extOptActAllowed_);
d241 2
a242 2
   extOptActAllowed_ = true;
   }
d247 29
a275 29
   {
   if (not startInnerNeeded_)
      return;

   startInnerNeeded_ = false;

   if (not mustSkipCallMsg_)
      if (myMsgFac ().mayIssue ("witFuncCalled"))
         myMsgFac () ("witFuncCalled", apiFuncName_);

   if (not preInitAllowed_)
      if (not myWitRun_->mySession ()->active ())
         myMsgFac () ("callBeforeInitSMsg", apiFuncName_);

   if (strncmp (apiFuncName_ + 3, "Get", 3) == 0)
      {
      nonMsgAssert (not extOptActAllowed_);

      extOptActAllowed_ = true;
      }

   if (not extOptActAllowed_)
      if (myWitRun_->myDetOptImpMgr ()->extOptActive ())
         myMsgFac () ("extOptActiveSmsg", apiFuncName_);

   mustSkipCallMsg_  = false;
   preInitAllowed_   = false;
   extOptActAllowed_ = false;
   }
d280 3
a282 3
   {
   if (theApiMgr2 == this)
      return;
d284 1
a284 1
   nonMsgAssert (myApiMgr2_ == NULL);
d286 1
a286 1
   myApiMgr2_ = theApiMgr2;
d288 1
a288 1
   myApiMgr2_->lockMyWitRun (apiFuncName_);
d290 2
a291 2
   if (myApiMgr2_->prevApiAbort_)
      myMsgFac () ("postErrApiCallSameWRSmsg", apiFuncName_);
d293 2
a294 2
   myApiMgr2_->apiRc_ = WitINFORMATIONAL_RC;
   }
d299 3
a301 3
   {
   setToMax (apiRc_, theRc);
   }
d310 3
a312 3
   {
   if (newHandlerSet_)
      return;
d314 1
a314 1
   _set_new_handler (throwBadAlloc);
d316 2
a317 2
   newHandlerSet_ = true;
   }
d322 2
a323 2
   {
   }
d330 3
a332 3
   {
   throw std::bad_alloc ();
   }
d337 5
a341 5
   {
   myMsgFac () (theIssueMsgExc.myMsgID (),
      theIssueMsgExc.myMsgArg1 (),
      theIssueMsgExc.myMsgArg2 (),
      theIssueMsgExc.myMsgArg3 ());
d343 2
a344 2
   myMsgFac () ("invIssueByExcFmsg");
   }
d349 2
a350 2
   {
   WitString theFuncName;
d352 1
a352 1
   theFuncName   = apiFuncName_;
d354 2
a355 2
   if (myApiMgr2_ != NULL)
      myApiMgr2_->prevApiAbort_ = true;
d357 1
a357 1
   prevApiAbort_ = true;
d359 1
a359 1
   finishApiFunc ();
d361 2
a362 2
   abortApiFunc (theAbortApiExc, theFuncName);
   }
d367 25
a391 25
      WitAbortApiExc &  theAbortApiExc,
      const WitString & theFuncName)
   {
   if      (theAbortApiExc.stopRunning ())
      {
      myMsgFac () ("witStopsSmsg", apiRc_);

      fflush (stdout);

      exit (apiRc_);
      }
   else if (theAbortApiExc.throwErrorExc ())
      {
      WitErrorExc theErrorExc (
         theFuncName   .myCstring (),
         theAbortApiExc.myMsgNum (),
         apiRc_);

      myMsgFac () ("throwWitExcSmsg", apiRc_);

      throw theErrorExc;
      }
   else
      myMsgFac () ("returnOnErrorSmsg", apiRc_);
   }
d396 3
a398 3
   {
   return reserveTempIntVec ();
   }
d403 2
a404 2
   {
   stronglyAssert (not tempVecsReserved_);
d406 1
a406 1
   tempVecsReserved_ = true;
d408 2
a409 2
   if (tempIntVec_.length () != mySession ()->myProblem ()->nPeriods ())
      tempIntVec_.allocate (mySession ()->myProblem (), 0);
d411 2
a412 2
   return tempIntVec_;
   }
d417 2
a418 2
   {
   stronglyAssert (not tempVecsReserved_);
d420 1
a420 1
   tempVecsReserved_ = true;
d422 2
a423 2
   if (tempDblVec_.length () != mySession ()->myProblem ()->nPeriods ())
      tempDblVec_.allocate (mySession ()->myProblem (), 0);
d425 2
a426 2
   return tempDblVec_;
   }
d431 2
a432 2
   {
   stronglyAssert (tempVecsReserved_);
d434 2
a435 2
   tempVecsReserved_ = false;
   }
d440 2
a441 2
   {
   delete myInputID ();
d443 2
a444 2
   myInputID_ = new WitInputID (this);
   }
d452 15
a466 15
      myApiMgr_       (theApiMgr),
      myAttName_      (NULL),
      myPart_         (NULL),
      myOperation_    (NULL),
      myDemand_       (NULL),
      myBomEnt_       (NULL),
      mySub_          (NULL),
      myBopEnt_       (NULL),
      argName_        (NULL),
      argIndex_       (-1),
      dataFileName_   (NULL),
      dataFileLineNo_ (0),
      errorPeriod_    (-1)
   {
   }
d471 2
a472 2
   {
   }
d477 3
a479 3
   {
   myAttName_ = theAttName;
   }
d484 3
a486 3
   {
   myPart_ = thePart;
   }
d491 3
a493 3
   {
   myOperation_ = theOpn;
   }
d498 3
a500 3
   {
   myDemand_ = theDemand;
   }
d505 3
a507 3
   {
   myBomEnt_ = theBomEnt;
   }
d512 3
a514 3
   {
   mySub_ = theSub;
   }
d519 3
a521 3
   {
   myBopEnt_ = theBopEnt;
   }
d526 3
a528 3
   {
   argName_ = theName;
   }
d533 3
a535 3
   {
   argIndex_ = theIndex;
   }
d540 3
a542 3
   {
   dataFileName_ = theName;
   }
d547 3
a549 3
   {
   dataFileLineNo_ = theValue;
   }
d554 3
a556 3
   {
   errorPeriod_ = t;
   }
d561 2
a562 2
   {
   WitMsgFacility & theMsgFac = myApiMgr_->myWitRun ()->myMsgFac ();
d564 2
a565 2
   if (myAttName_ != NULL)
      theMsgFac ("inputAttribSmsg", myAttName_);
d567 7
a573 7
   if (argName_ != NULL)
      {
      if (argIndex_ >= 0)
         theMsgFac ("inputArgElSmsg", argName_, argIndex_);
      else
         theMsgFac ("inputArgumentSmsg", argName_);
      }
d575 2
a576 2
   if (errorPeriod_ >= 0)
      theMsgFac ("inputPeriodSmsg", errorPeriod_);
d578 2
a579 2
   if (myPart_ != NULL)
      theMsgFac ("inputPartNameSmsg", myPart_->partName ());
d581 2
a582 2
   if (myOperation_ != NULL)
      theMsgFac ("inputOperationNameSmsg", myOperation_->operationName ());
d584 2
a585 2
   if (myDemand_ != NULL)
      theMsgFac ("inputDemandNameSmsg", myDemand_->demandName ());
d587 4
a590 4
   if      (mySub_ != NULL)
      theMsgFac ("inputConsumedPartNameSmsg", mySub_->myPartName ());
   else if (myBomEnt_ != NULL)
      theMsgFac ("inputConsumedPartNameSmsg", myBomEnt_->myPartName ());
d592 2
a593 2
   if (myBopEnt_ != NULL)
      theMsgFac ("inputProducedPartNameSmsg", myBopEnt_->myPartName ());
d595 2
a596 2
   if (myBomEnt_ != NULL)
      theMsgFac ("inputBomIndexSmsg", myBomEnt_->localIndex ());
d598 2
a599 2
   if (mySub_ != NULL)
      theMsgFac ("inputSubsBomEntryIndexSmsg", mySub_->localIndex ());
d601 2
a602 2
   if (myBopEnt_ != NULL)
      theMsgFac ("inputBopIndexSmsg", myBopEnt_->localIndex ());
d604 2
a605 2
   if (dataFileName_ != NULL)
      theMsgFac ("inputFileNameSmsg", dataFileName_);
d607 2
a608 2
   if (dataFileLineNo_ != 0)
      theMsgFac ("inputFileLineNumberSmsg", dataFileLineNo_);
d610 4
a613 4
   if (not WitSaeMgr::standAloneMode ())
      if (myApiMgr_->apiFuncName () != NULL)
         theMsgFac ("apiFunctionSmsg", myApiMgr_->apiFuncName ());
   }
d618 6
a623 6
   {
   return
      theBoolean?
         true:
         false;
   }
@


1.134
log
@Removed multiThread.
@
text
@d27 1
a27 1
#include <Opn.h>
@


1.133
log
@Made WIT operate in multi-thread mode unconditionally.
The multithread attribute in no longer meaningful.
@
text
@a41 1
bool WitApiMgr::multiThread_   = false;
a85 10
void WitApiMgr::setMultiThread ()
   {
   if (multiThread_)
      return;

   multiThread_ = true;
   }

//------------------------------------------------------------------------------

@


1.132
log
@Changed some witAsserts into nonMsgAsserts.
@
text
@d41 2
a42 4
bool         WitApiMgr::multiThread_     = false;
bool         WitApiMgr::witIsLocked_     = false;
const char * WitApiMgr::lockingFuncName_ = NULL;
bool         WitApiMgr::newHandlerSet_   = false;
a88 2
   stronglyAssert (not WitSaeMgr::standAloneMode ());

a91 2
   unlockWit ();

a106 3
   if (not multiThread_)
      lockWit (theFuncName);

a133 3
   if (not multiThread_)
      unlockWit ();

a181 45
void WitApiMgr::lockWit (const char * theFuncName)
   {
   nonMsgAssert (not multiThread_);

   if (witIsLocked_)
      {
      startNonMsgSevereError ();

      fprintf (stderr,
         "WIT Thread-safety error:\n"
         "\n"
         "   An API function was called while the previous API function call\n"
         "   with a different WitRun argument was still in progress.\n"
         "   Since the multiThread attribute is false,\n"
         "   overlapping API function calls are not allowed.\n"
         "\n"
         "      Previous Function: %s\n"
         "      Current  Function: %s\n",
         lockingFuncName_,
         theFuncName);

      finishNonMsgSevereError ();
      }
   else
      {
      witIsLocked_     = true;

      lockingFuncName_ = theFuncName;
      }
   }

//------------------------------------------------------------------------------

void WitApiMgr::unlockWit ()
   {
   nonMsgAssert (not multiThread_);
   nonMsgAssert (witIsLocked_);

   lockingFuncName_ = NULL;

   witIsLocked_     = false;
   }

//------------------------------------------------------------------------------

@


1.131
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@d132 1
a132 1
   witAssert (not startInnerNeeded_);
d283 1
a283 1
   witAssert (not mustSkipCallMsg_);
d295 1
a295 1
   witAssert (not preInitAllowed_);
d307 1
a307 1
   witAssert (not extOptActAllowed_);
d331 1
a331 1
      witAssert (not extOptActAllowed_);
d352 1
a352 1
   witAssert (myApiMgr2_ == NULL);
@


1.130
log
@Removed many conversions of string constant to char *.
@
text
@d35 2
@


1.129
log
@Stochastic Implosion
@
text
@d519 1
a519 1
      myAttr_         (NULL),
d542 1
a542 1
void WitInputID::setMyAttr (WitAttr theAttr)
d544 1
a544 1
   myAttr_ = theAttr;
d630 2
a631 2
   if (myAttr_ != NULL)
      theMsgFac ("inputAttribSmsg", myAttr_);
@


1.128
log
@witCopy<Object>Data
@
text
@d31 1
a31 1
#include <OptImp.h>
d335 1
a335 1
      if (myWitRun_->myOptImploder ()->extOptActive ())
@


1.127
log
@witCopy<Object>Data
@
text
@d66 1
d128 1
a128 1
void WitApiMgr::finishApiFunc (WitRun * theWitRun)
d130 10
a139 1
   witAssert (not theWitRun->myApiMgr ()->startInnerNeeded_);
d144 1
a144 1
   theWitRun->myApiMgr ()->unlockMyWitRun ();
d347 1
a347 1
   if (this == theApiMgr2)
d350 1
a350 1
   theApiMgr2->lockMyWitRun (apiFuncName_);
d352 1
a352 2
   if (theApiMgr2->prevApiAbort_)
      myMsgFac () ("postErrApiCallSameWRSmsg", apiFuncName_);
d354 1
a354 2
   theApiMgr2->apiRc_ = WitINFORMATIONAL_RC;
   }
d356 2
a357 11
//------------------------------------------------------------------------------

void WitApiMgr::finish2WitRunFunc (WitApiMgr * theApiMgr2)
   {
   if (this == theApiMgr2)
      return;

   setToMax (apiRc_, theApiMgr2->apiRc_);

   theApiMgr2->unlockMyWitRun ();
   }
d359 1
a359 5
//------------------------------------------------------------------------------

void WitApiMgr::setPrevApiAbort ()
   {
   prevApiAbort_ = true;
d420 3
d425 1
a425 1
   finishApiFunc (myWitRun_);
@


1.126
log
@witCopy<Object>Data
@
text
@a16 1
//    AbortApiExc.
d429 1
a429 1
   abortApiFunc (theAbortApiExc.myMsgNum (), theFuncName);
d434 3
a436 1
void WitApiMgr::abortApiFunc (int theMsgNum, const WitString & theFuncName)
d438 1
a438 1
   if (myMsgFac ().stopRunning (theMsgNum))
d446 1
a446 1
   else if (myMsgFac ().throwErrorExc (theMsgNum))
d448 4
a451 1
      WitErrorExc theErrorExc (theFuncName.myCstring (), theMsgNum, apiRc_);
a691 24

//------------------------------------------------------------------------------
// Implementation of class AbortApiExc.
//------------------------------------------------------------------------------

WitAbortApiExc::WitAbortApiExc (int theMsgNum):

      myMsgNum_ (theMsgNum)
   {
   }

//------------------------------------------------------------------------------

WitAbortApiExc::WitAbortApiExc (const WitAbortApiExc & theAbortApiExc):

      myMsgNum_ (theAbortApiExc.myMsgNum_)
   {
   }

//------------------------------------------------------------------------------

WitAbortApiExc::~WitAbortApiExc ()
   {
   }
@


1.125
log
@External opt implosion.
@
text
@d336 1
a336 1
void WitApiMgr::startCopyData (WitApiMgr * srcApiMgr)
d338 1
a338 1
   if (this == srcApiMgr)
d341 1
a341 1
   srcApiMgr->lockMyWitRun ("witCopyData");
d343 2
a344 2
   if (srcApiMgr->prevApiAbort_)
      myMsgFac () ("postErrApiCallSameWRSmsg", "witCopyData");
d346 1
a346 1
   srcApiMgr->apiRc_ = WitINFORMATIONAL_RC;
d351 1
a351 1
void WitApiMgr::finishCopyData (WitApiMgr * srcApiMgr)
d353 1
a353 1
   if (this == srcApiMgr)
d356 1
a356 1
   setToMax (apiRc_, srcApiMgr->apiRc_);
d358 1
a358 1
   srcApiMgr->unlockMyWitRun ();
@


1.124
log
@App controlled opt implosion.
@
text
@a20 2
#include <AfrMgr.h>
#include <ApiFuncRep.h>
d32 1
a57 1
      myAfrMgr_         (NULL),
d61 5
a65 1
      curFuncRep_       (NULL),
a72 1
   myAfrMgr_  = new WitAfrMgr  (myWitRun_);
a82 8
   delete myAfrMgr_;
   }

//------------------------------------------------------------------------------

const WitString & WitApiMgr::apiFuncName ()
   {
   return curFuncRep_->myFuncName ();
d118 1
a118 1
         theApiMgr->apiFuncName ());
d120 4
a123 1
   theApiMgr->curFuncRep_->startMyFunc ();
d130 2
d244 1
a244 1
         apiFuncName ().myCstring (),
a248 3
   else
      {
      myWitRunIsLocked_ = true;
d250 3
a252 2
      curFuncRep_       = myAfrMgr_->findFuncRep (theFuncName);
      }
d261 22
a282 1
   curFuncRep_       = NULL;
d284 48
a331 1
   myWitRunIsLocked_ = false;
d424 1
a424 1
   theFuncName   = apiFuncName ();
d675 1
a675 1
      if (myApiMgr_->apiFuncName () != "")
@


1.123
log
@App controlled opt implosion.
@
text
@d108 1
a108 1
void WitApiMgr::startApiFunc (const char * theFuncName)
d110 7
a116 1
   lockMyWitRun (theFuncName);
d121 1
a121 1
   apiRc_ = WitINFORMATIONAL_RC;
d123 3
a125 2
   if (prevApiAbort_)
      myMsgFac () ("postErrApiCallSameWRSmsg", apiFuncName ());
d127 1
a127 1
   curFuncRep_->startMyFunc ();
d132 1
a132 1
void WitApiMgr::finishApiFunc ()
d137 1
a137 1
   unlockMyWitRun ();
d364 1
a364 1
   finishApiFunc ();
@


1.122
log
@App controlled opt implosion.
@
text
@d21 2
a22 2
#include <AfaMgr.h>
#include <ApiFuncAid.h>
d59 1
a59 1
      myAfaMgr_         (NULL),
d63 1
a63 1
      curFuncAid_       (NULL),
d71 1
a71 1
   myAfaMgr_  = new WitAfaMgr  (myWitRun_);
d82 1
a82 1
   delete myAfaMgr_;
d89 1
a89 1
   return curFuncAid_->myFuncName ();
d120 1
a120 1
   curFuncAid_->startMyFunc ();
d248 1
a248 1
      curFuncAid_       = myAfaMgr_->findFuncAid (theFuncName);
d258 1
a258 1
   curFuncAid_       = NULL;
@


1.121
log
@App controlled opt implosion.
@
text
@a64 1
      startInnerNeeded_ (false),
d71 1
a71 1
   myAfaMgr_  = new WitAfaMgr;
d120 1
a120 3
   witAssert (not startInnerNeeded_);

   startInnerNeeded_ = true;
a126 2
   witAssert (not startInnerNeeded_);

a264 19
void WitApiMgr::startInnerApiFunc (
      WitInitState  ::Tag theInitStateTag,
      WitOptImpState::Tag)
   {
   if (theInitStateTag == WitInitState::postInit)
      {
      if (startInnerNeeded_)
         if (myMsgFac ().mayIssue ("witFuncCalled"))
            myMsgFac () ("witFuncCalled", apiFuncName ());

      if (not myWitRun_->mySession ()->active ())
         myMsgFac () ("callBeforeInitSMsg", apiFuncName ());
      }

   startInnerNeeded_ = false;
   }

//------------------------------------------------------------------------------

d353 1
a353 1
   theFuncName       = apiFuncName ();
d355 1
a355 3
   prevApiAbort_     = true;

   startInnerNeeded_ = false;
@


1.120
log
@App controlled opt implosion.
@
text
@d21 2
d59 1
d63 1
a63 1
      apiFuncName_      (),
d72 1
d83 8
d119 1
a119 1
      myMsgFac () ("postErrApiCallSameWRSmsg", apiFuncName_);
d244 1
a244 1
         apiFuncName_.myCstring (),
d253 1
a253 1
      apiFuncName_.copyCstring (theFuncName);
d263 1
a263 1
   apiFuncName_.copyCstring ("");
d278 1
a278 1
            myMsgFac () ("witFuncCalled", apiFuncName_);
d281 1
a281 1
         myMsgFac () ("callBeforeInitSMsg", apiFuncName_);
d377 1
a377 1
   theFuncName       = apiFuncName_;
@


1.119
log
@Reinstated catching of unknown exceptions.
@
text
@d62 1
d97 1
a97 1
void WitApiMgr::startApiFunc (const char * theFuncName, bool preInitMode)
a105 4
   if (not preInitMode)
      if (myMsgFac ().mayIssue ("witFuncCalled"))
         myMsgFac () ("witFuncCalled", apiFuncName_);

d109 3
a111 3
   if (not myWitRun_->mySession ()->active ())
      if (not preInitMode)
         myMsgFac () ("callBeforeInitSMsg", apiFuncName_);
d118 2
d258 19
d365 1
a365 1
   theFuncName   = apiFuncName_;
d367 3
a369 1
   prevApiAbort_ = true;
@


1.118
log
@Removed code to catch unknown exceptions.
@
text
@d138 5
d157 5
@


1.117
log
@Updated the copyright date on all source files.
@
text
@a137 5
      catch (WitAbortApiExc &)
         {
         throw;
         }

a151 5

      catch (...)
         {
         myMsgFac () ("unknownExcFmsg");
         }
@


1.116
log
@Minor update.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.115
log
@[error recovery]
@
text
@d110 1
a110 1
      myMsgFac () ("postErrApiCallMyWRSmsg", apiFuncName_);
d267 1
a267 1
      myMsgFac () ("postErrApiCallMyWRSmsg", "witCopyData");
@


1.114
log
@Error exceptions.
@
text
@d39 4
a42 6
bool         WitApiMgr::multiThread_       = false;
bool         WitApiMgr::witIsLocked_       = false;
const char * WitApiMgr::lockingFuncName_   = NULL;
bool         WitApiMgr::prevApiAbortAnyWR_ = false;
bool         WitApiMgr::newHandlerSet_     = false;
bool         WitApiMgr::errorRecovery_     = false;
d61 1
a61 1
      prevApiAbortMyWR_ (false),
a95 7
void WitApiMgr::setErrorRecovery ()
   {
   errorRecovery_ = true;
   }

//------------------------------------------------------------------------------

d109 1
a109 1
   if (prevApiAbortMyWR_)
a111 4
   if (not errorRecovery_)
      if (prevApiAbortAnyWR_)
         myMsgFac () ("postErrApiCallAnyWRSmsg", apiFuncName_);

d266 1
a266 1
   if (srcApiMgr->prevApiAbortMyWR_)
d286 1
a286 1
void WitApiMgr::setPrevApiAbortMyWR ()
d288 1
a288 1
   prevApiAbortMyWR_ = true;
d347 1
a347 1
   theFuncName        = apiFuncName_;
d349 1
a349 2
   prevApiAbortMyWR_  = true;
   prevApiAbortAnyWR_ = true;
@


1.113
log
@[error recovery]
@
text
@a16 1
//    ErrorExcData.
a21 1
#include <ErrorExcData.h>
a626 31
// Implementation of class ErrorExcData.
//------------------------------------------------------------------------------

WitErrorExcData::WitErrorExcData (
         const WitString & funcNameVal,
         int               mesgNumVal,
         WitReturnCode     retCodeVal):

      funcName_ (funcNameVal),
      mesgNum_  (mesgNumVal),
      retCode_  (retCodeVal)
   {
   }

//------------------------------------------------------------------------------

WitErrorExcData::WitErrorExcData (const WitErrorExcData * theErrorExcData):

      funcName_ (theErrorExcData->funcName_),
      mesgNum_  (theErrorExcData->mesgNum_),
      retCode_  (theErrorExcData->retCode_)
   {
   }

//------------------------------------------------------------------------------

WitErrorExcData::~WitErrorExcData ()
   {
   }

//------------------------------------------------------------------------------
@


1.112
log
@WitErrorExc with MS compiler.
@
text
@d68 1
a68 2
      tempVecsReserved_ (false),
      srcApiMgrForCopy_ (NULL)
d276 2
a277 5
   stronglyAssert (srcApiMgr         != NULL);
   stronglyAssert (srcApiMgr         != this);
   stronglyAssert (srcApiMgrForCopy_ == NULL);

   srcApiMgrForCopy_ = srcApiMgr;
d279 1
a279 1
   srcApiMgrForCopy_->lockMyWitRun ("witCopyData");
d281 1
a281 1
   if (srcApiMgrForCopy_->prevApiAbortMyWR_)
d284 1
a284 1
   srcApiMgrForCopy_->apiRc_ = WitINFORMATIONAL_RC;
d289 1
a289 1
void WitApiMgr::finishCopyData ()
d291 2
a292 1
   stronglyAssert (srcApiMgrForCopy_ != NULL);
d294 1
a294 1
   setToMax (apiRc_, srcApiMgrForCopy_->apiRc_);
d296 4
a299 1
   srcApiMgrForCopy_->unlockMyWitRun ();
d301 3
a303 1
   srcApiMgrForCopy_ = NULL;
a366 7
   if (srcApiMgrForCopy_ != NULL)
      {
      srcApiMgrForCopy_->prevApiAbortMyWR_ = true;

      finishCopyData ();
      }

@


1.111
log
@Minor update.
@
text
@d391 1
a391 3
      WitErrorExcData theErrorExcData (theFuncName, theMsgNum, apiRc_);

      WitErrorExc     theErrorExc     (theErrorExcData);
d650 1
a650 1
WitErrorExcData::WitErrorExcData (const WitErrorExcData & theErrorExcData):
d652 3
a654 3
      funcName_ (theErrorExcData.funcName_),
      mesgNum_  (theErrorExcData.mesgNum_),
      retCode_  (theErrorExcData.retCode_)
@


1.110
log
@Error exceptions on MS compiler.
@
text
@d644 1
a644 1
      funcName_ (funcNameVal.myCstring ()),
d654 1
a654 1
      funcName_ (),
a657 1
   funcName_ = theErrorExcData.funcName_;
@


1.109
log
@[error recovery]
@
text
@d17 1
a17 1
//    ConcErrorExc.
d23 1
a23 1
#include <ConcErrorExc.h>
d391 1
a391 1
      myMsgFac () ("throwWitExcSmsg", apiRc_);
d393 1
a393 1
#if 0
d395 1
a395 9
// #if defined(_MSC_VER)

      WitConcErrorExc theConcErrorExc (theFuncName, theMsgNum, apiRc_);

      WitTempExc      theTempExc      (theConcErrorExc);

      throw theTempExc;

#endif
d397 1
a397 1
      throw WitConcErrorExc (theFuncName, theMsgNum, apiRc_);
d636 1
a636 1
// Implementation of class ConcErrorExc.
d639 1
a639 1
WitConcErrorExc::WitConcErrorExc (
d644 3
a646 23
      WitErrorExc (),

      funcName_   (funcNameVal.myCstring ()),
      mesgNum_    (mesgNumVal),
      retCode_    (retCodeVal)
   {
   }

//------------------------------------------------------------------------------

WitConcErrorExc::WitConcErrorExc (const WitConcErrorExc & theConcErrorExc):

      WitErrorExc (theConcErrorExc),

      funcName_   (theConcErrorExc.funcName_.myCstring ()),
      mesgNum_    (theConcErrorExc.mesgNum_),
      retCode_    (theConcErrorExc.retCode_)
   {
   }

//------------------------------------------------------------------------------

WitConcErrorExc::~WitConcErrorExc ()
d652 1
a652 6
const char * WitConcErrorExc::funcName () const
   {
   return funcName_.myCstring ();
   }

//------------------------------------------------------------------------------
d654 3
a656 1
int WitConcErrorExc::mesgNum () const
d658 1
a658 1
   return mesgNum_;
d663 1
a663 1
witReturnCode WitConcErrorExc::retCode () const
a664 1
   return retCode_;
@


1.108
log
@Experiment for MS trouble with WitErrorExc.
@
text
@a364 2
   mySession_->recordError ();

@


1.107
log
@Experiment for WitErrorExc trouble with MS complier.
@
text
@d395 3
a397 1
#if defined(_MSC_VER)
@


1.106
log
@An attempt to implement the bad_alloc new error behavior
with the MS Visual C++ V6 compiler.
@
text
@d395 10
@


1.105
log
@[error recovery]
@
text
@a311 12
// Function ApiMgr::setUpNewFailure ()
//
// According to the ISO C++ standard, when the "new" operator is unable to
// allocate the requested memory, a std::bad_alloc exception is to be thrown.
// WIT's proper functioning depends on this "bad_alloc" behavior.
// If NO_BAD_ALLOC is defined, this indicates that WIT is being compiled on a
// platform that does not implement the "bad_alloc" behavior.
// In this case, setUpNewFailure uses std::set_new_handler to cause the
// "bad_alloc" behavior to happen anyway.
// (It only does this the first time it is called.)
// If NO_BAD_ALLOC is not defined, there is no need to do anything.
//------------------------------------------------------------------------------
d313 3
a315 1
#ifdef NO_BAD_ALLOC
d322 1
a322 1
   std::set_new_handler (throwBadAlloc);
d337 1
a337 1
void WitApiMgr::throwBadAlloc ()
@


1.104
log
@Minor updates.
@
text
@d375 2
d386 8
a393 1
   if (myMsgFac ().stopRunning (theAbortApiExc.myMsgNum ()))
d401 1
a401 1
   else if (myMsgFac ().throwErrorExc (theAbortApiExc.myMsgNum ()))
d405 1
a405 5
      throw
         WitConcErrorExc (
            theFuncName,
            theAbortApiExc.myMsgNum (),
            apiRc_);
@


1.103
log
@Minor update.
@
text
@d384 1
a384 1
   if (myMsgFac ().throwErrorExc (theAbortApiExc.myMsgNum ()))
d386 9
a394 1
      myMsgFac () ("throwWitExcMsg", apiRc_);
d403 1
a403 1
      myMsgFac () ("returnOnErrorMsg", apiRc_);
@


1.102
log
@Fixed a bug that occurred when witCopyData issued a severe error.
@
text
@d386 1
a386 1
      myMsgFac () ("throwWitExcSmsg", apiRc_);
d395 1
a395 1
      myMsgFac () ("returnOnErrorSmsg", apiRc_);
@


1.101
log
@Setting bad_alloc behavior for the MS compiler.
@
text
@a68 1
      abortingApiFunc_  (false),
d283 2
a287 2
   srcApiMgrForCopy_->lockMyWitRun ("witCopyData");

a399 13
void WitApiMgr::abortApiFunc (int theMsgNum)
   {
   WitAbortApiExc theAbortApiExc (theMsgNum);

   nonMsgAssert (not myMsgFac ().stopRunning (theMsgNum));

   abortingApiFunc_ = true;

   throw theAbortApiExc;
   }

//------------------------------------------------------------------------------

@


1.100
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d45 1
d72 2
d313 41
@


1.99
log
@[error recovery]
@
text
@a36 2
#include <errno.h>

a114 2
   errno  = 0;

a440 1
   errno = 0;
a549 12
#if defined(__GNUC__)

   if (errno == 25)
      errno = 0;
         //
         // On GNU C++, LEX/YACC seems to generate this condition harmlessly.

#endif

   if (errno != 0)
      theMsgFac ("errnoSmsg", errno, strerror (errno));

@


1.98
log
@Fixed a bug:
   When witCopyData detected a severe error in srcWitRun, the function was
   returning 0, instead of 3 as its return code.
@
text
@d71 1
a71 2
      srcApiMgrForCopy_ (NULL),
      dstApiMgrForCopy_ (NULL)
d279 3
a281 3
   stronglyAssert (srcApiMgr                    != NULL);
   stronglyAssert (srcApiMgrForCopy_            == NULL);
   stronglyAssert (srcApiMgr->dstApiMgrForCopy_ == NULL);
d283 1
a283 2
   srcApiMgrForCopy_                    = srcApiMgr;
   srcApiMgrForCopy_->dstApiMgrForCopy_ = this;
d288 3
a290 2
   if (srcApiMgrForCopy_ != this)
      srcApiMgrForCopy_->lockMyWitRun ("witCopyData");
d297 3
a299 2
   stronglyAssert (srcApiMgrForCopy_                    != NULL);
   stronglyAssert (srcApiMgrForCopy_->dstApiMgrForCopy_ == this);
d301 1
a301 2
   if (srcApiMgrForCopy_ != this)
      srcApiMgrForCopy_->unlockMyWitRun ();
d303 1
a303 2
   srcApiMgrForCopy_->dstApiMgrForCopy_ = NULL;
   srcApiMgrForCopy_                    = NULL;
d310 1
a310 4
   if (dstApiMgrForCopy_ == NULL)
      setToMax (apiRc_, theRc);
   else
      setToMax (dstApiMgrForCopy_->apiRc_, theRc);
@


1.97
log
@[error recovery]
@
text
@d71 2
a72 1
      srcApiMgrForCopy_ (NULL)
d280 3
a282 2
   stronglyAssert (srcApiMgr         != NULL);
   stronglyAssert (srcApiMgrForCopy_ == NULL);
d284 2
a285 1
   srcApiMgrForCopy_ = srcApiMgr;
d298 2
a299 1
   stronglyAssert (srcApiMgrForCopy_ != NULL);
d304 2
a305 1
   srcApiMgrForCopy_ = NULL;
d312 4
a315 1
   setToMax (apiRc_, theRc);
@


1.96
log
@[multi-thread]
@
text
@d43 5
a47 4
bool          WitApiMgr::multiThread_     = false;
bool          WitApiMgr::witIsLocked_     = false;
const char *  WitApiMgr::lockingFuncName_ = NULL;
bool          WitApiMgr::prevApiAbort_    = false;
d66 1
d70 2
a71 1
      abortingApiFunc_  (false)
d101 7
d123 6
a128 2
   if (prevApiAbort_)
      myMsgFac () ("apiCallAfterErrorSmsg", apiFuncName_);
d277 28
d328 4
a331 1
   prevApiAbort_ = true;
d333 6
a338 1
   theFuncName   = apiFuncName_;
@


1.95
log
@[multi-thread]
@
text
@d187 2
a188 4
         "   An API function was called while the previous API\n"
         "   function call to a different WitRun was still in progress.\n"
         "   This indicates that concurrent API function calls from two\n"
         "   different threads have been made to two different WitRuns.\n"
d190 1
a190 1
         "   multiply-threaded API function calls are not allowed.\n"
d230 4
a233 5
         "   An API function was called while the previous API\n"
         "   function call to the same WitRun was still in progress.\n"
         "   This indicates that concurrent API function calls from two\n"
         "   different threads have been made to a single WitRun,\n"
         "   and this is not allowed.\n"
@


1.94
log
@[multi-thread]
@
text
@d100 1
a100 1
   lockWitRun (theFuncName);
d128 1
a128 1
   unlockWitRun ();
d185 1
a185 1
         "WIT Thread-safety error #2:\n"
d223 1
a223 1
void WitApiMgr::lockWitRun (const char * theFuncName)
d230 1
a230 1
         "WIT Thread-safety error #1:\n"
d255 1
a255 1
void WitApiMgr::unlockWitRun ()
@


1.93
log
@[multi-thread]
@
text
@d98 1
a98 4
void WitApiMgr::startApiFunc (
      const char * theFuncName,
      bool         preInitMode,
      bool         quietMode)
d109 1
a109 1
   if (not quietMode)
@


1.92
log
@[multi-thread]
@
text
@d43 4
a46 6
bool          WitApiMgr::multiThread_       = false;
bool          WitApiMgr::witIsLocked_       = false;
const char *  WitApiMgr::lockingFuncName_   = NULL;
bool          WitApiMgr::witIsLockedMT_     = false;
const char *  WitApiMgr::lockingFuncNameMT_ = NULL;
bool          WitApiMgr::prevApiAbort_      = false;
a93 2

   lockWitMT ("witSetMultiThread");
d105 2
a106 4
   if (multiThread_)
      lockWitMT (theFuncName);
   else
      lockWit   (theFuncName);
d128 2
a129 4
   if (multiThread_)
      unlockWitMT ();
   else
      unlockWit   ();
a225 47
void WitApiMgr::lockWitMT (const char * theFuncName)
   {
   nonMsgAssert (multiThread_);

   if (witIsLockedMT_)
      {
      startNonMsgSevereError ();

      fprintf (stderr,
         "WIT Thread-safety error #3:\n"
         "\n"
         "   An API function was called while the previous API\n"
         "   function call to a different WitRun was still in progress.\n"
         "   This indicates that concurrent API function calls from two\n"
         "   different threads have been made to two different WitRuns.\n"
         "   Although the multiThread attribute is true, multiply-threaded\n"
         "   API function calls to WIT are not yet allowed.\n"
         "\n"
         "      Previous Function: %s\n"
         "      Current  Function: %s\n",
         lockingFuncNameMT_,
         theFuncName);

      finishNonMsgSevereError ();
      }
   else
      {
      witIsLockedMT_     = true;

      lockingFuncNameMT_ = theFuncName;
      }
   }

//------------------------------------------------------------------------------

void WitApiMgr::unlockWitMT ()
   {
   nonMsgAssert (multiThread_);
   nonMsgAssert (witIsLockedMT_);

   lockingFuncNameMT_ = NULL;

   witIsLockedMT_     = false;
   }

//------------------------------------------------------------------------------

@


1.91
log
@[multi-thread]
@
text
@a280 7
void WitApiMgr::updateApiRc (WitReturnCode theRc)
   {
   setToMax (apiRc_, theRc);
   }

//------------------------------------------------------------------------------

d324 7
@


1.90
log
@Reinstated code to catch unknown exceptions.
Added code to handle standard library exceptions.
@
text
@d43 6
a48 3
bool          WitApiMgr::multiThread_  = false;
const char *  WitApiMgr::sglFuncName_  = NULL;
bool          WitApiMgr::prevApiAbort_ = false;
d65 1
a65 1
      actCallToThis_    (false),
d90 5
d96 2
d107 1
a107 2
   if (actCallToThis_)
      actCallToThisError (theFuncName);
d109 4
a112 1
   actCallToThis_   = true;
d114 1
a114 1
   sglThreadLock (theFuncName);
d116 1
a116 5
   apiRc_           = WitINFORMATIONAL_RC;

   apiFuncName_.copyCstring (theFuncName);

   errno = 0;
d134 4
a137 5
   apiFuncName_.copyCstring ("");

   sglThreadUnlock ();

   nonMsgAssert (actCallToThis_);
d139 1
a139 1
   actCallToThis_ = false;
d187 48
a234 1
void WitApiMgr::sglThreadLock (const char * theFuncName)
d236 3
a238 1
   if (sglFuncName_ != NULL)
d242 14
a255 30
      if (multiThread_)
         fprintf (stderr,
            "WIT Thread-safety error #3:\n"
            "\n"
            "   An API function was called while the previous API\n"
            "   function call to a different WitRun was still in progress.\n"
            "   This indicates that concurrent API function calls from two\n"
            "   different threads have been made to two different WitRuns.\n"
            "   Although the multiThread attribute is true, multiply-threaded\n"
            "   API function calls to WIT are not yet allowed.\n"
            "\n"
            "      Previous Function: %s\n"
            "      Current  Function: %s\n",
            sglFuncName_,
            theFuncName);
      else
         fprintf (stderr,
            "WIT Thread-safety error #2:\n"
            "\n"
            "   An API function was called while the previous API\n"
            "   function call to a different WitRun was still in progress.\n"
            "   This indicates that concurrent API function calls from two\n"
            "   different threads have been made to two different WitRuns.\n"
            "   Since the multiThread attribute is false,\n"
            "   multiply-threaded API function calls are not allowed.\n"
            "\n"
            "      Previous Function: %s\n"
            "      Current  Function: %s\n",
            sglFuncName_,
            theFuncName);
d259 3
d263 2
a264 1
   sglFuncName_ = theFuncName;
d269 1
a269 1
void WitApiMgr::sglThreadUnlock ()
d271 2
a272 1
   nonMsgAssert (sglFuncName_ != NULL);
d274 3
a276 1
   sglFuncName_ = NULL;
d288 33
a320 1
void WitApiMgr::actCallToThisError (const char * theFuncName)
d322 1
a322 1
   startNonMsgSevereError ();
d324 1
a324 13
   fprintf (stderr,
      "WIT Thread-safety error #1:\n"
      "\n"
      "   An API function was called while the previous API\n"
      "   function call to the same WitRun was still in progress.\n"
      "   This indicates that concurrent API function calls from two\n"
      "   different threads have been made to a single WitRun,\n"
      "   and this is not allowed.\n"
      "\n"
      "      Previous Function: %s\n"
      "      Current  Function: %s\n",
      apiFuncName_.myCstring (),
      theFuncName);
d326 1
a326 1
   finishNonMsgSevereError ();
@


1.89
log
@Temporarily turned off catching of unknown exceptions.
@
text
@d146 1
a146 1
      catch (std::bad_alloc &)
d148 1
a148 1
         handleBadAllocExc ();
d155 15
a175 9

#if 0

   catch (...)
      {
      handleUnknownExc ();
      }

#endif
a263 7
void WitApiMgr::handleBadAllocExc ()
   {
   myMsgFac () ("memoryErrorSmsg");
   }

//------------------------------------------------------------------------------

a301 15
void WitApiMgr::handleUnknownExc ()
   {
   try
      {
      myMsgFac () ("unknownExcFmsg");
      }

   catch (WitAbortApiExc & theExc)
      {
      handleAbortApiExc (theExc);
      }
   }

//------------------------------------------------------------------------------

@


1.88
log
@[multi-thread]
@
text
@d162 2
d168 2
@


1.87
log
@[multi-thread]
@
text
@d26 1
a61 1
      standAloneMode_   (false),
d83 1
a83 1
void WitApiMgr::setStandAloneMode (bool theValue)
d85 1
a85 4
   standAloneMode_ = theValue;
   }

//------------------------------------------------------------------------------
a86 2
void WitApiMgr::setMultiThread ()
   {
d555 1
a555 1
   if (not myApiMgr_->standAloneMode ())
@


1.86
log
@Updated WIT's exception throwing capability.
@
text
@d61 1
a61 1
      apiMode_          (true),
d83 1
a83 1
void WitApiMgr::setApiMode (bool theValue)
d85 1
a85 1
   apiMode_ = theValue;
d560 1
a560 1
   if (myApiMgr_->apiMode ())
@


1.85
log
@[multi-thread]
@
text
@d17 1
d23 1
d288 1
a288 1
   if (myMsgFac ().throwException (theAbortApiExc.myMsgNum ()))
a289 9
      WitException theWitExc;

      nonMsgAssert (theFuncName.length () < 50);

      strcpy (theWitExc.funcName, theFuncName.myCstring ());

      theWitExc.mesgNum = theAbortApiExc.myMsgNum ();
      theWitExc.retCode = apiRc_;

d292 5
a296 1
      throw theWitExc;
d576 56
@


1.84
log
@[multi-thread]
@
text
@d40 3
a42 3
bool          WitApiMgr::multiThread_    = false;
const char *  WitApiMgr::sglFuncName_    = NULL;
bool          WitApiMgr::errorMsgIssued_ = false;
d117 1
a117 1
   if (errorMsgIssued_)
a229 3

   if (theRc >= WitSEVERE_RC)
      errorMsgIssued_ = true;
d280 3
a282 1
   theFuncName = apiFuncName_;
@


1.83
log
@[multi-thread]
@
text
@d40 3
a42 3
bool          WitApiMgr::multiThread_ = false;
const char *  WitApiMgr::sglFuncName_ = NULL;
witReturnCode WitApiMgr::maxRc_       = WitINFORMATIONAL_RC;
d117 1
a117 1
   if (maxRc_ >= WitSEVERE_RC)
d227 1
a227 1
void WitApiMgr::updateApiRc (WitReturnCode rc)
d229 4
a232 2
   setToMax (apiRc_, rc);
   setToMax (maxRc_, rc);
@


1.82
log
@[multi-thread]
@
text
@d118 1
a118 1
      myMsgFac () ("apiCallAfterSorFSmsg", apiFuncName_);
@


1.81
log
@[multi-thread]
@
text
@a110 2
   mySession_->becomesCurrent ();

a128 2
   mySession_->becomesUncurrent ();

@


1.80
log
@[multi-thread]
@
text
@d16 1
a17 1
//    InputID.
d22 2
d158 1
a158 1
      catch (WitMsgIssueExc & theMsgIssueExc)
d160 1
a160 1
         handleMsgIssueExc (theMsgIssueExc);
d269 1
a269 1
void WitApiMgr::handleMsgIssueExc (WitMsgIssueExc & theMsgIssueExc)
d271 4
a274 4
   myMsgFac () (theMsgIssueExc.myMsgID (),
      theMsgIssueExc.myMsgArg1 (),
      theMsgIssueExc.myMsgArg2 (),
      theMsgIssueExc.myMsgArg3 ());
a389 24
// Implementation of class AbortApiExc.
//------------------------------------------------------------------------------

WitAbortApiExc::WitAbortApiExc (int theMsgNum):

      myMsgNum_ (theMsgNum)
   {
   }

//------------------------------------------------------------------------------

WitAbortApiExc::WitAbortApiExc (const WitAbortApiExc & theAbortApiExc):

      myMsgNum_ (theAbortApiExc.myMsgNum_)
   {
   }

//------------------------------------------------------------------------------

WitAbortApiExc::~WitAbortApiExc ()
   {
   }

//------------------------------------------------------------------------------
d580 24
@


1.79
log
@[multi-thread]
@
text
@d135 1
a135 1
   witAssert (actCallToThis_);
d222 1
a222 1
   witAssert (sglFuncName_ != NULL);
d291 1
a291 1
      stronglyAssert (theFuncName.length () < 50);
d327 1
a327 1
   witAssert (not myMsgFac ().stopRunning (theMsgNum));
@


1.78
log
@[multi-thread]
@
text
@d16 1
d151 1
a151 1
      catch (std::bad_alloc)
d287 1
a287 1
   if (myMsgFac ().throwException (theAbortApiExc.myMsgNum_))
d295 1
a295 1
      theWitExc.mesgNum = theAbortApiExc.myMsgNum_;
d325 1
a325 1
   WitAbortApiExc theAbortApiExc;
d329 1
a329 3
   theAbortApiExc.myMsgNum_ = theMsgNum;

   abortingApiFunc_         = true;
d388 24
@


1.77
log
@[multi-thread]
@
text
@d152 1
a152 1
         myMsgFac () ("memoryErrorSmsg");
d155 1
a155 1
      catch (WitMsgIssueExc & theExc)
d157 1
a157 4
         myMsgFac () (theExc.myMsgID (),
            theExc.myMsgArg1 (),
            theExc.myMsgArg2 (),
            theExc.myMsgArg3 ());
d161 1
a161 1
   catch (WitAbortApiExc & theExc)
d163 1
a163 1
      handleAbortApiExc (theExc);
d259 8
a266 1
void WitApiMgr::handleUnknownExc ()
d268 4
a271 4
   try
      {
      myMsgFac () ("unknownExcFmsg");
      }
d273 1
a273 4
   catch (WitAbortApiExc & theExc)
      {
      handleAbortApiExc (theExc);
      }
d307 15
@


1.76
log
@[multi-thread]
@
text
@d141 1
a141 1
void WitApiMgr::handleInternalExc ()
d168 5
d262 15
@


1.75
log
@[multi-thread]
@
text
@d141 1
a141 1
void WitApiMgr::handleBadAllocExc ()
d145 17
a161 1
      myMsgFac () ("memoryErrorSmsg");
a171 47
void WitApiMgr::handleMsgIssueExc (WitMsgIssueExc & theMsgIssueExc)
   {
   try
      {
      myMsgFac () (theMsgIssueExc.myMsgID (),
         theMsgIssueExc.myMsgArg1 (),
         theMsgIssueExc.myMsgArg2 (),
         theMsgIssueExc.myMsgArg3 ());
      }

   catch (WitAbortApiExc & theExc)
      {
      handleAbortApiExc (theExc);
      }
   }

//------------------------------------------------------------------------------

void WitApiMgr::handleAbortApiExc (WitAbortApiExc & theAbortApiExc)
   {
   WitString theFuncName;

   theFuncName = apiFuncName_;

   finishApiFunc ();

   if (myMsgFac ().throwException (theAbortApiExc.myMsgNum_))
      {
      WitException theWitExc;

      stronglyAssert (theFuncName.length () < 50);

      strcpy (theWitExc.funcName, theFuncName.myCstring ());

      theWitExc.mesgNum = theAbortApiExc.myMsgNum_;
      theWitExc.retCode = apiRc_;

      myMsgFac () ("throwWitExcSmsg", apiRc_);

      throw theWitExc;
      }
   else
      myMsgFac () ("returnOnErrorSmsg", apiRc_);
   }

//------------------------------------------------------------------------------

d257 29
@


1.74
log
@[multi-thread]
@
text
@d156 18
@


1.73
log
@Removed code supporting the variable-argument-list API functions.
@
text
@d476 1
a476 1
      theMsgFac ("errnoSmsg", errno, WitNonClass::strerror (errno));
@


1.72
log
@[multi-thread]
@
text
@a15 1
//    ApiVaList
a336 16
// Implementation of class WitApiVaList.
//------------------------------------------------------------------------------

WitApiVaList::WitApiVaList ():
      myVaList_ ()
   {
   }

//------------------------------------------------------------------------------

WitApiVaList::~WitApiVaList ()
   {
   va_end (myVaList_);
   }

//------------------------------------------------------------------------------
@


1.71
log
@[multi-thread]
@
text
@a59 1
      savedNewHandler_  (NULL),
a104 2
// savedNewHandler_ = WitNonClass::set_new_handler (newError);

a132 4
// WitNonClass::set_new_handler (savedNewHandler_);

   savedNewHandler_ = NULL;

d146 1
a146 1
      myMsgFac () ("memoryExcErrorSmsg");
@


1.70
log
@[multi-thread]
@
text
@d96 2
a97 2
      bool         preInitFunc,
      bool         quietFunc)
d116 1
a116 1
   if (not quietFunc)
d124 1
a124 1
      if (not preInitFunc)
@


1.69
log
@[multi-thread]
@
text
@d96 2
a97 2
      bool         preInit,
      bool         quiet)
d116 1
a116 1
   if (not quiet)
d124 1
a124 1
      if (not preInit)
@


1.68
log
@[multi-thread]
@
text
@d16 1
d106 1
a106 1
   savedNewHandler_ = WitNonClass::set_new_handler (newError);
d136 1
a136 1
   WitNonClass::set_new_handler (savedNewHandler_);
d149 15
d345 16
d539 1
a539 1
         theMsgFac ("apiFunctionSmsg",  myApiMgr_->apiFuncName ());
@


1.67
log
@[multi-thread]
@
text
@a15 1
//    ApiGroup.
a20 1
#include <ApiGroup.h>
a55 3
      defaultGroup_     (NULL),
      preInGroup_       (NULL),
      quietGroup_       (NULL),
d65 2
a66 7
   mySession_    = new WitSession (this);
   myInputID_    = new WitInputID (this);

//                                  preInit quiet
   defaultGroup_ = new WitApiGroup (false,  false);
   preInGroup_   = new WitApiGroup (true,   false);
   quietGroup_   = new WitApiGroup (true,   true);
a72 4
   delete quietGroup_;
   delete preInGroup_;
   delete defaultGroup_;

d93 4
a96 1
void WitApiMgr::startApiFunc (const char * theFuncName, WitApiGroup * theGroup)
d115 1
a115 1
   if (not theGroup->quietMode ())
d123 1
a123 1
      if (not theGroup->preInitMode ())
a328 17
// Implementation of class WitApiGroup.
//------------------------------------------------------------------------------

WitApiGroup::WitApiGroup (bool preInitModeVal, bool quietModeVal):

      preInitMode_ (preInitModeVal),
      quietMode_   (quietModeVal)
   {
   }

//------------------------------------------------------------------------------

WitApiGroup::~WitApiGroup ()
   {
   }

//------------------------------------------------------------------------------
@


1.66
log
@[multi-thread]
@
text
@d55 22
a76 24
      myWitRun_          (theWitRun),
      mySession_         (NULL),
      myInputID_         (NULL),
      defaultGroup_      (NULL),
      quietGroup_        (NULL),
      preInGroup_        (NULL),
      quietPreInGroup_   (NULL),
      apiMode_           (true),
      actCallToThis_     (false),
      apiFuncName_       (),
      savedNewHandler_   (NULL),
      tempIntVec_        (),
      tempDblVec_        (),
      tempVecsReserved_  (false),
      abortingApiFunc_   (false)
   {
   mySession_       = new WitSession (this);
   myInputID_       = new WitInputID (this);

//                                     quiet  preInit
   defaultGroup_    = new WitApiGroup (false, false);
   quietGroup_      = new WitApiGroup (true,  false);
   preInGroup_      = new WitApiGroup (false, true);
   quietPreInGroup_ = new WitApiGroup (true,  true);
d83 1
a83 1
   delete quietPreInGroup_;
a84 1
   delete quietGroup_;
d343 1
a343 1
WitApiGroup::WitApiGroup (bool quietModeVal, bool preInitModeVal):
d345 2
a346 2
      quietMode_   (quietModeVal),
      preInitMode_ (preInitModeVal)
@


1.65
log
@[multi-thread]
@
text
@a58 1
      doubleGroup_       (NULL),
d74 5
a78 6
//                                     double quiet  preInit
   defaultGroup_    = new WitApiGroup (false, false, false);
   doubleGroup_     = new WitApiGroup (true,  false, false);
   quietGroup_      = new WitApiGroup (false, true,  false);
   preInGroup_      = new WitApiGroup (false, false, true);
   quietPreInGroup_ = new WitApiGroup (false, true,  true);
a87 1
   delete doubleGroup_;
d123 1
a123 10
   if (theGroup->doubleMode ())
      {
      apiFuncName_.resize (strlen (theFuncName) + 3);

      strcpy (apiFuncName_.myCstringForUpdate (), theFuncName);

      strcpy (apiFuncName_.myCstringForUpdate () + strlen (theFuncName), "Dbl");
      }
   else
      apiFuncName_.copyCstring (theFuncName);
d346 1
a346 4
WitApiGroup::WitApiGroup (
         bool doubleModeVal,
         bool quietModeVal,
         bool preInitModeVal):
a347 1
      doubleMode_  (doubleModeVal),
@


1.64
log
@[multi-thread]
@
text
@d40 1
a40 1
bool          WitApiMgr::locked_      = false;
d120 1
a120 1
   lockApi (theFuncName);
d165 1
a165 1
   unlockApi ();
d203 1
a203 1
void WitApiMgr::lockApi (const char * theFuncName)
d205 1
a205 1
   if (locked_)
d220 3
a222 1
            "      Current Function: %s\n",
d235 3
a237 1
            "      Current Function: %s\n",
d243 1
a243 1
   locked_ = true;
d248 1
a248 1
void WitApiMgr::unlockApi ()
d250 1
a250 1
   witAssert (locked_);
d252 1
a252 1
   locked_ = false;
@


1.63
log
@[multi-thread]
@
text
@d40 1
d64 1
a64 1
      callInProgress_    (false),
d115 2
a116 4
   if (callInProgress_)
      callInProgressError (
         theFuncName,
         (theGroup->doubleMode ()? "Dbl": ""));
d118 3
a120 1
   callInProgress_  = true;
d165 3
a167 1
   witAssert (callInProgress_);
d169 1
a169 1
   callInProgress_ = false;
d203 50
d261 1
a261 3
void WitApiMgr::callInProgressError (
      const char * theFuncName,
      const char * suffix)
d266 1
a266 1
      "WIT Thread-safety error:\n"
d268 5
a272 2
      "   An API function has been called while the previous API\n"
      "   function call to the same WitRun is still in progress.\n"
d275 1
a275 1
      "      Current  Function: %s%s\n",
d277 1
a277 2
      theFuncName,
      suffix);
@


1.62
log
@[multi-thread]
@
text
@d39 2
a40 1
witReturnCode WitApiMgr::maxRc_ = WitINFORMATIONAL_RC;
d105 7
@


1.61
log
@[multi-thread]
@
text
@d60 1
a60 1
      preInQuietGroup_   (NULL),
d78 1
a78 1
   preInQuietGroup_ = new WitApiGroup (false, true,  true);
d85 1
a85 1
   delete preInQuietGroup_;
@


1.60
log
@[multi-threads]
@
text
@d59 2
a60 1
      preInitGroup_      (NULL),
d70 2
a71 2
   mySession_    = new WitSession (this);
   myInputID_    = new WitInputID (this);
d73 6
a78 4
   defaultGroup_ = new WitApiGroup (false, false, false);
   doubleGroup_  = new WitApiGroup (true,  false, false);
   quietGroup_   = new WitApiGroup (false, true,  false);
   preInitGroup_ = new WitApiGroup (false, true,  true);
d85 2
a86 1
   delete preInitGroup_;
@


1.59
log
@[multi-threads]
@
text
@d16 1
d22 1
d53 23
a75 16
      myWitRun_         (theWitRun),
      mySession_        (NULL),
      myInputID_        (NULL),
      apiMode_          (true),
      quietCall_        (false),
      dblCall_          (false),
      callInProgress_   (false),
      apiFuncName_      (),
      savedNewHandler_  (NULL),
      tempIntVec_       (),
      tempDblVec_       (),
      tempVecsReserved_ (false),
      abortingApiFunc_  (false)
   {
   mySession_ = new WitSession (this);
   myInputID_ = new WitInputID (this);
d82 5
d100 1
a100 8
void WitApiMgr::setQuietCall ()
   {
   quietCall_ = true;
   }

//------------------------------------------------------------------------------

void WitApiMgr::setDblCall ()
a101 16
   dblCall_ = true;
   }

//------------------------------------------------------------------------------

void WitApiMgr::startApiFunc (const char * theFuncName)
   {
   bool quietCallVal;
   bool dblCallVal;

   quietCallVal = quietCall_;
   dblCallVal   = dblCall_;

   quietCall_   = false;
   dblCall_     = false;

d105 1
a105 1
         (dblCallVal? "Dbl": ""));
d113 1
a113 1
   if (dblCallVal)
d128 1
a128 1
   if (not quietCallVal)
d135 3
a137 1
   checkAllowBeforeInit ();
a218 48
const char * const WitApiMgr::allowBeforeInit_[] =
   {
   "witCopyData",
   "witDeleteRun",
   "witInitialize",
   "witNewRun",
   "witNoDependantWitRunVeneers",
   "witSetMesg", // prefix
   "witStandAlone",
   "witTestFatalMesg"
   };

//------------------------------------------------------------------------------

void WitApiMgr::checkAllowBeforeInit ()
   {
   bool         matchFound;
   int          theIdx;
   const char * allowedName;
   int          length;

   if (myWitRun_->mySession ()->active ())
      return;

   matchFound = false;

   for (theIdx = 0; theIdx < NumberElem (allowBeforeInit_); theIdx ++)
      {
      allowedName = allowBeforeInit_[theIdx];

      length      = strlen (allowedName);

      if (strncmp (apiFuncName_.myCstring (), allowedName, length) == 0)
         {
         matchFound = true;

         break;
         }
      }

   if (not matchFound)
      myMsgFac () ("callOutOfOrder1Msg",
         apiFuncName_.myCstring (),
         "witInitialize");
   }

//------------------------------------------------------------------------------

d286 21
@


1.58
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d55 2
d86 1
a86 1
void WitApiMgr::startApiFunc (const char * theFuncName, bool quiet)
d88 23
d112 3
a114 1
      callInProgressError (theFuncName);
d122 10
a131 1
   apiFuncName_.copyCstring (theFuncName);
d137 1
a137 1
   if (not quiet)
d203 3
a205 1
void WitApiMgr::callInProgressError (const char * theFuncName)
d216 1
a216 1
      "      Current  Function: %s\n",
d218 2
a219 1
      theFuncName);
@


1.57
log
@[multi-threads]
@
text
@a19 1
#include <ProEpilog.h>
d55 1
a55 1
      nActCalls_        (0),
d84 6
a89 9
void WitApiMgr::enteringApiFunction (const char * funcName, bool quiet)
   { 
   nActCalls_ ++;

      // Determine if the application invoked this routine. If not then nothing
      // else to do.
      //
   if (not calledByApp ())
      return;
d93 3
a95 7
      // Initialize return code to zero
      //
   apiRc_ = WitINFORMATIONAL_RC;

      // Save function name
      //
   apiFuncName_.copyCstring (funcName);
a98 11
   if (WitRealArg::doubleArgsExist ())
      {
      witAssert (not WitRealArg::floatArgsExist ());

      appDblToFuncName ();
      }

      // Make sure errno is zero, so idInput will not find it
      // containing a nonZero which results will result in an incorrect
      // error message
      //
a100 2
      // If not quiet, then display entering API function message.
      //
d108 19
a126 4
      // Make sure witInitialize has been called if required
      //
   apiCallOrder (apiFuncName_.myCstring ());
   };
a131 1
   bool      byApp;
a133 2
   byApp       = calledByApp ();

d136 1
a136 4
   leavingApiFunction ();

   if (byApp)
      throw theAbortApiExc;
a157 5
// leavingApiFunction member function of class ApiMgr.
//
// This function is invoked when an API routine is exited.  It restores
// state information and is invoked via the EPILOG macro.
//------------------------------------------------------------------------------
d159 1
a159 1
void WitApiMgr::leavingApiFunction ()
d161 3
a163 3
   if (calledByApp ())
      {
      mySession_->becomesUncurrent ();
d165 1
a165 1
      apiFuncName_.copyCstring ("");
d167 3
a169 1
      WitNonClass::set_new_handler (savedNewHandler_);
d171 10
a180 2
      savedNewHandler_ = NULL;
      }
d182 2
a183 2
   nActCalls_ --;
   };
d187 1
a187 1
void WitApiMgr::updateApiRc (WitReturnCode rc)
a188 9
   setToMax (apiRc_, rc);
   setToMax (maxRc_, rc);
   }

//------------------------------------------------------------------------------
// apiCallOrder - Test to insure api function is called in correct order.
//------------------------------------------------------------------------------

const char * const WitApiMgr::allowBeforeInit_[] = {
d197 3
a199 1
};
d201 1
a201 1
void WitApiMgr::apiCallOrder ( const char * const name )
d203 2
a204 1
   int          i;
d206 1
d208 2
a209 3
   // Make sure witInitalize has been called if required
   if ( not myWitRun_->mySession ()->active () ) {
      bool error=true;
d211 1
a211 3
      for ( i=0; i<NumberElem(allowBeforeInit_); i++ )
         {
         allowedName = allowBeforeInit_[i];
d213 3
a215 6
         if (strncmp (name, allowedName, strlen (allowedName)) == 0)
            {
            error = false;
            break;
            }
         }
d217 1
a217 4
      // name must be after witInitialize
      if ( error ) 
         myMsgFac () ("callOutOfOrder1Msg",name,"witInitialize");
   }
d219 3
a221 1
}  // api_call_order
d223 3
a225 11
//------------------------------------------------------------------------------

void WitApiMgr::appDblToFuncName ()
   {
   WitString dblName;

   dblName.resize (apiFuncName_.length () + 3);

   strcpy (dblName.myCstringForUpdate (), apiFuncName_.myCstring ());

   strcpy (dblName.myCstringForUpdate () + apiFuncName_.length (), "Dbl");
d227 4
a230 1
   apiFuncName_ = dblName;
@


1.56
log
@[exceptions]
@
text
@d56 1
a56 1
      apiDepth_         (0),
d87 1
a87 1
   apiDepth_++;
d92 1
a92 1
   if (not applicationCalled ())
d136 1
a136 1
void WitApiMgr::handle (WitAbortApiExc & theAbortApiExc)
d138 1
d141 2
d147 1
a147 1
   if (apiDepth_ > 0)
d178 1
a178 1
   if (applicationCalled ())
d189 1
a189 1
   apiDepth_--;
@


1.55
log
@[exceptions]
@
text
@d155 2
a156 2
      theWitExc.mesgNum      = theAbortApiExc.myMsgNum_;
      theWitExc.myReturnCode = apiRc_;
@


1.54
log
@[exceptions]
@
text
@d260 1
a260 1
   witAssert (not myMsgFac ().stopOnAbort (theMsgNum));
@


1.53
log
@[exceptions]
@
text
@d16 1
a16 1
//    InputId.
d20 2
d54 1
a54 1
      myInputId_        (NULL),
d65 1
a65 1
   myInputId_ = new WitInputId (this);
d72 1
a72 1
   delete myInputId_;
d147 1
a147 1
   if (theAbortApiExc.byException_)
d153 1
a153 1
      strcpy (theWitExc.functionName_, theFuncName.myCstring ());
d155 2
a156 1
      theWitExc.myReturnCode_ = apiRc_;
d256 1
a256 1
void WitApiMgr::abortApiFunc (bool byException)
d260 1
a260 1
   theAbortApiExc.byException_ = byException;
d262 3
a264 1
   abortingApiFunc_ = true;
d315 1
a315 1
void WitApiMgr::resetInputId ()
d317 1
a317 1
   delete myInputId ();
d319 1
a319 1
   myInputId_ = new WitInputId (this);
d323 1
a323 1
// Implementation of class InputId.
d326 1
a326 1
WitInputId::WitInputId (WitApiMgr * theApiMgr):
d347 1
a347 1
WitInputId::~WitInputId ()
d353 1
a353 1
void WitInputId::setMyAttr (WitAttr theAttr)
d360 1
a360 1
void WitInputId::setMyPart (WitPart * thePart)
d367 1
a367 1
void WitInputId::setMyOperation (WitOperation * theOpn)
d374 1
a374 1
void WitInputId::setMyDemand (WitDemand * theDemand)
d381 1
a381 1
void WitInputId::setMyBomEntry (WitBomEntry * theBomEnt)
d388 1
a388 1
void WitInputId::setMySubEntry (WitSubEntry * theSub)
d395 1
a395 1
void WitInputId::setMyBopEntry (WitBopEntry * theBopEnt)
d402 1
a402 1
void WitInputId::setArgName (const char * theName)
d409 1
a409 1
void WitInputId::setArgIndex (int theIndex)
d416 1
a416 1
void WitInputId::setDataFileName (const char * theName)
d423 1
a423 1
void WitInputId::setDataFileLineNo (int theValue)
d430 1
a430 1
void WitInputId::setErrorPeriod (WitPeriod t)
d437 1
a437 1
void WitInputId::idInput ()
@


1.52
log
@[exceptions]
@
text
@d147 1
a147 1
      WitErrorExc theErrorExc;
d151 1
a151 1
      strcpy (theErrorExc.functionName_, theFuncName.myCstring ());
d153 1
a153 1
      theErrorExc.myReturnCode_ = apiRc_;
d155 1
a155 1
      myMsgFac () ("throwErrorExcSmsg", apiRc_);
d157 1
a157 1
      throw theErrorExc;
@


1.51
log
@[exceptions]
@
text
@a52 1
      throwExcOnError_  (false),
d60 1
a60 1
      returningToApp_   (false)
a75 7
void WitApiMgr::setThrowExcOnError (bool theValue)
   {
   throwExcOnError_ = theValue;
   }

//------------------------------------------------------------------------------

d134 1
a134 1
void WitApiMgr::handleReturnToAppExc ()
d143 1
a143 1
      throw WitReturnToAppExc ();
d145 1
a145 1
   if (throwExcOnError_)
a202 1
   "witSetThrowExcOnError",
d253 1
a253 1
void WitApiMgr::returnToApp ()
d255 5
a259 1
   returningToApp_ = true;
d261 1
a261 1
   throw WitReturnToAppExc ();
@


1.50
log
@[exceptions]
@
text
@d157 2
@


1.49
log
@[exceptions]
@
text
@d39 7
d129 2
a130 2
      if (myWitRun_->myMsgFac ().mayIssue ("witFuncCalled"))
         myWitRun_->myMsgFac () ("witFuncCalled", apiFuncName_);
d133 1
a133 1
      myWitRun_->myMsgFac () ("apiCallAfterSorFSmsg", apiFuncName_);
d161 1
a161 1
      myWitRun_->myMsgFac () ("throwErrorExcSmsg", apiRc_);
d166 1
a166 1
      myWitRun_->myMsgFac () ("returnOnErrorSmsg", apiRc_);
d238 1
a238 1
         myWitRun_->myMsgFac () ("callOutOfOrder1Msg",name,"witInitialize");
@


1.48
log
@[exceptions]
@
text
@d46 1
a46 1
      throwOnErrors_    (false),
d54 1
a54 1
      directRetCalled_  (false)
d70 1
a70 1
void WitApiMgr::setThrowOnErrors (bool theValue)
d72 1
a72 1
   throwOnErrors_ = theValue;
d135 1
a135 1
void WitApiMgr::handleRetToCallerExc ()
d137 4
d144 1
a144 1
      throw WitRetToCallerExc ();
d146 1
a146 1
   if (throwOnErrors_)
d150 2
d158 2
d202 1
a202 1
   "witSetThrowOnErrors",
d253 1
a253 1
void WitApiMgr::directlyReturnToCaller ()
d255 1
a255 1
   directRetCalled_ = true;
d257 1
a257 1
   throw WitRetToCallerExc ();
@


1.47
log
@[exceptions]
@
text
@d46 1
d70 7
d134 21
d194 1
@


1.46
log
@[exceptions]
@
text
@d219 1
a219 1
   throw (1);
@


1.45
log
@[exceptions]
@
text
@d49 1
d86 2
d139 4
@


1.44
log
@Removed #define TRY_THROW_CATCH_NOT_SUPPORTED.
@
text
@d46 1
a46 1
      witApi_           (true),
d67 6
a72 8
// enteringApiFunction member function of class ApiMgr.
//
// This function is invoked when an API routine is entered.  It saves
// state information and is invoked via the PROLOG macro. 
//
// Arguments:
//    name:  Name of api function
//    quiet: True if informational messages to be surpressed
d75 1
a75 1
void WitApiMgr::enteringApiFunction (const char * const name, const bool quiet)
d91 1
a91 1
   apiFuncName_.copyCstring (name);
a260 12
void WitApiMgr::allowInternalApiMethodUse ()
   {
   apiDepth_++;
   }

void WitApiMgr::noLongerAllowInternalApiMethodUse ()
   {
   apiDepth_--;
   }

//------------------------------------------------------------------------------

@


1.43
log
@Vector PropRtg.
@
text
@a213 8
#ifdef TRY_THROW_CATCH_NOT_SUPPORTED

   apiDepth_ = 0;

   longjmp (apiEntryEnv, apiRc_);

#else

a214 2

#endif
@


1.42
log
@Vector PropRtg.
@
text
@d238 1
a238 1
   witAssert (not tempVecsReserved_);
d252 1
a252 1
   witAssert (not tempVecsReserved_);
d266 1
a266 1
   witAssert (tempVecsReserved_);
@


1.41
log
@Fixed a bug in the ApiCall dtor in mesgStopRunning = false mode.
@
text
@d229 7
@


1.40
log
@More work on handling severe and fatal errors.
@
text
@d51 2
a52 1
      tempVecsReserved_ (false)
a142 1

d212 2
@


1.39
log
@Added:
   WitFATAL_RC
   witTestFatalMesg
@
text
@a155 2
   "witSetMesg",      /* prefix */
   "witNoDependantWitRunVeneers",
d157 1
d159 5
a163 2
   "witTestFatalMesg",
   "witStandAlone"
@


1.38
log
@Minor change.
@
text
@d160 1
@


1.37
log
@Added a test for an API function call after a severe or fatal condition.
@
text
@a27 1
#include <wit.h>
@


1.36
log
@Double Precision.
@
text
@d37 2
d116 3
d149 1
@


1.35
log
@Double Precision.
@
text
@a113 3
   if (WitRealArg::doubleArgsExist ())
      myWitRun_->myMsgFac () ("apiDblWmsg", apiFuncName_);

@


1.34
log
@Double Precision.
@
text
@a48 1
      tempFltVec_       (),
a231 14
   }

//------------------------------------------------------------------------------

WitTVec <float> & WitApiMgr::reserveTempFltVec ()
   {
   witAssert (not tempVecsReserved_);

   tempVecsReserved_ = true;

   if (tempFltVec_.length () != mySession ()->myProblem ()->nPeriods ())
      tempFltVec_.allocate (mySession ()->myProblem (), 0);

   return tempFltVec_;
@


1.33
log
@Double Precision.
@
text
@d201 1
a201 1
   apiFuncName_.copy (dblName);
@


1.32
log
@Double Precision.
@
text
@d49 2
a50 1
      tempFloatVec_     (),
d237 1
a237 1
WitTVec <float> & WitApiMgr::reserveTempFloatVec ()
d243 2
a244 2
   if (tempFloatVec_.length () != mySession ()->myProblem ()->nPeriods ())
      tempFloatVec_.allocate (mySession ()->myProblem (), 0);
d246 15
a260 1
   return tempFloatVec_;
@


1.31
log
@Double Precision.
@
text
@d459 10
@


1.30
log
@Double Precision.
@
text
@d114 3
@


1.29
log
@Double Precision.
@
text
@d93 2
d127 8
a134 2
{
   if ( applicationCalled() ) apiFuncName_.copyCstring ("");
d136 1
a136 1
};
d154 2
a155 1
   "witInitialize"
@


1.28
log
@Double Precision.
@
text
@d146 1
a146 3
   "witInitialize",
   "witSetDoubleMode",
   "witGetDoubleMode"
@


1.27
log
@Double Precision.
@
text
@a19 1
#include <Session.h>
@


1.26
log
@Double Precision
@
text
@d94 1
a94 1
   if (RealArg::doubleArgsExist ())
d96 1
a96 1
      witAssert (not RealArg::floatArgsExist ());
@


1.25
log
@Continued double precision.
@
text
@d95 3
d99 1
@


1.24
log
@Continued double precision.
@
text
@d28 1
a28 1
#include <RealSOutArg.h>
@


1.23
log
@Continued double precision.
@
text
@a111 6

   if (RealArg::floatArgsExist ())
      checkDblMode (false);

   if (RealArg::doubleArgsExist ())
      checkDblMode (true);
a187 10
   }

//------------------------------------------------------------------------------

void WitApiMgr::checkDblMode (bool theValue)
   {
   if (WitSession::doubleMode () != theValue)
      myWitRun_->myMsgFac () ("dblModeViolSmsg",
         apiFuncName_,
         WitSession::doubleMode ());
@


1.22
log
@Continued double precision.
@
text
@d94 1
a94 1
   if (RealArg::doubleCaseExists ())
d113 1
a113 1
   if (RealArg::floatCaseExists ())
d116 1
a116 1
   if (RealArg::doubleCaseExists ())
@


1.21
log
@Continued double precision.
@
text
@d28 1
a28 1
#include <RealOutArg.h>
d94 1
a94 1
   if (RealOutArg::doubleCaseExists ())
d113 1
a113 1
   if (RealOutArg::floatCaseExists ())
d116 1
a116 1
   if (RealOutArg::doubleCaseExists ())
@


1.20
log
@Continued double precision.
@
text
@d150 2
a151 2
   "witSetDoublePrecision",
   "witGetDoublePrecision"
d200 1
a200 1
   if (WitSession::doublePrecision () != theValue)
d203 1
a203 1
         WitSession::doublePrecision ());
@


1.19
log
@Continued double precision.
@
text
@d28 1
d70 4
d76 2
a77 5
void WitApiMgr::enteringApiFunction ( 
   const char * const name, // Name of api function
   const bool quiet )       // True if informational messages to be surpressed
{ 

d80 5
a84 3
   // Determine if the application invoked this routine. If not then nothing
   // else to do.
   if ( !applicationCalled() ) return;
d86 2
a87 1
   // Initialize return code to zero
d90 2
a91 1
   // Save function name
d94 7
a100 3
   // Make sure errno is zero, so idInput will not find it
   // containing a nonZero which results will result in an incorrect
   // error message
d109 2
a110 1
   // Make sure witInitialize has been called if required
d113 6
a118 1
};  /* enteringApiFunction  */
d180 25
@


1.18
log
@Continued implementation of PIP.
@
text
@d133 3
a135 1
   "witInitialize"
d143 1
a143 1
   /* Make sure witInitalize has been called if required */
d158 1
a158 1
      /* name must be after witInitialize */
d163 1
a163 1
}  /* api_call_order */
@


1.17
log
@Continued implementation of PIP.
@
text
@d378 1
a378 1
      theMsgFac ("errnoSmsg", errno, WitUtil::strerror (errno));
@


1.16
log
@Eliminated an extraneous error code caused by LEX and YACC.
@
text
@d378 1
a378 1
      theMsgFac ("errnoSmsg", errno, strerror (errno));
@


1.15
log
@Internal changes.
@
text
@d368 9
@


1.14
log
@Internal changes.
@
text
@d95 1
a95 1
   if (! quiet)
d142 1
a142 1
   if ( ! myWitRun_->mySession ()->active () ) {
d184 1
a184 1
   witAssert (! tempVecsReserved_);
d198 1
a198 1
   witAssert (! tempVecsReserved_);
@


1.13
log
@Continued implementation of Single-Source.
@
text
@d45 1
a45 1
      witApi_           (witTRUE),
d50 1
a50 1
      tempVecsReserved_ (witFALSE)
d73 1
a73 1
   const WitBoolean quiet ) // True if informational messages to be surpressed
d143 1
a143 1
      WitBoolean error=witTRUE;
d151 1
a151 1
            error = witFALSE;
d186 1
a186 1
   tempVecsReserved_ = witTRUE;
d200 1
a200 1
   tempVecsReserved_ = witTRUE;
d214 1
a214 1
   tempVecsReserved_ = witFALSE;
@


1.12
log
@Continued implementation of single-source.
@
text
@d48 2
a49 2
      tempIntVec_       (* new WitTVec <int>   ()),
      tempFloatVec_     (* new WitTVec <float> ()),
d60 2
a61 4
   delete & tempFloatVec_;
   delete & tempIntVec_;
   delete   myInputId_;
   delete   mySession_;
@


1.11
log
@Preliminary work on single source.
@
text
@d47 1
a47 1
      apiFuncName_      (* new WitString),
a61 1
   delete & apiFuncName_;
@


1.10
log
@Continued preliminary work on single source.
@
text
@d89 1
a89 1
   apiFuncName_ = name;
d116 1
a116 1
   if ( applicationCalled() ) apiFuncName_ = "";
@


1.9
log
@Continued implementation of object iteration.
@
text
@d48 2
a49 2
      tempIntVec_       (* new WitTVec (int)   ()),
      tempFloatVec_     (* new WitTVec (float) ()),
d185 1
a185 1
WitTVec (int) & WitApiMgr::reserveTempIntVec ()
d199 1
a199 1
WitTVec (float) & WitApiMgr::reserveTempFloatVec ()
@


1.8
log
@Began implementation of object iteration.
@
text
@d28 1
d141 2
a142 1
   int i;
d147 2
a148 2
      for ( i=0; i<NumberElem(allowBeforeInit_); i++ ) {
         if (streqn (name, allowBeforeInit_[i], strlen (allowBeforeInit_[i]))) 
d150 5
a154 1
            error=witFALSE;
d156 1
d158 1
a158 1
      }
@


1.7
log
@Continued development of selection splitting for multi=exec.
@
text
@d23 6
@


1.6
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d239 3
a241 3
      myBomEntry_     (NULL),
      mySubEntry_     (NULL),
      myBopEntry_     (NULL),
d289 1
a289 1
   myBomEntry_ = theBomEnt;
d296 1
a296 1
   mySubEntry_ = theSub;
d303 1
a303 1
   myBopEntry_ = theBopEnt;
d373 7
a379 7
   if      (mySubEntry_ != NULL)
      theMsgFac ("inputConsumedPartNameSmsg", mySubEntry_->myPartName ());
   else if (myBomEntry_ != NULL)
      theMsgFac ("inputConsumedPartNameSmsg", myBomEntry_->myPartName ());

   if (myBopEntry_ != NULL)
      theMsgFac ("inputProducedPartNameSmsg", myBopEntry_->myPartName ());
d381 2
a382 2
   if (myBomEntry_ != NULL)
      theMsgFac ("inputBomIndexSmsg", myBomEntry_->localIndex ());
d384 2
a385 2
   if (mySubEntry_ != NULL)
      theMsgFac ("inputSubsBomEntryIndexSmsg", mySubEntry_->localIndex ());
d387 2
a388 2
   if (myBopEntry_ != NULL)
      theMsgFac ("inputBopIndexSmsg", myBopEntry_->localIndex ());
@


1.5
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d294 1
a294 1
void WitInputId::setMySubEntry (WitSubEntry * theSubEntry)
d296 1
a296 1
   mySubEntry_ = theSubEntry;
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d35 9
a43 8
      myWitRun_     (theWitRun),
      mySession_    (NULL),
      myInputId_    (NULL),
      witApi_       (witTRUE),
      apiDepth_     (0),
      apiFuncName_  (* new WitString),
      tempVec_      (* new WitTVec (int) ()),
      tempVecInUse_ (witFALSE)
d53 2
a54 1
   delete & tempVec_;
d172 1
a172 1
WitTVec (int) & WitApiMgr::useTempVec ()
d174 1
a174 1
   witAssert (! tempVecInUse_);
d176 1
a176 2
   if (DEBUG_MODE)
      tempVecInUse_ = witTRUE;
d178 2
a179 2
   if (tempVec_.length () != mySession ()->myProblem ()->nPeriods ())
      tempVec_.allocate (mySession ()->myProblem (), 0);
d181 1
a181 1
   return tempVec_;
d186 1
a186 1
void WitApiMgr::releaseTempVec ()
d188 1
a188 1
   witAssert (tempVecInUse_);
d190 15
a204 2
   if (DEBUG_MODE)
      tempVecInUse_ = witFALSE;
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d116 1
a116 1
   WitUtil::setToMax (apiRc_, rc);
d138 2
a139 2
         if (WitUtil::streqn (
                name, allowBeforeInit_[i], strlen (allowBeforeInit_[i]))) {
d345 1
a345 1
      theMsgFac ("errnoSmsg", errno, WitUtil::strerror (errno));
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d116 1
a116 1
   WitUtil::updateToMax (apiRc_, rc);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

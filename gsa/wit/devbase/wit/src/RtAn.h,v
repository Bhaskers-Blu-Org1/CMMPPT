head	1.60;
access;
symbols
	sce_5_01_20080919:1.57
	latest_sce_4_20_20060523:1.56.0.2
	sce_4_20_20060523:1.56
	latest_sce4_20_OSL:1.55.0.2
	sce_4_20_OSL:1.55
	sce_410_withVa:1.55
	sce_4_05_20040511:1.29
	sce_4_00_20040201:1.29
	nextGenBranch:1.28.0.2
	nextGenRoot:1.28
	sce_3_30_20030627:1.28
	EndRw-branch:1.17.0.4
	Root-of-EndRw:1.17
	rwToStl:1.17.0.2
	latest_sce_3_10_20010924:1.15.0.2
	sce_3_10_20010924:1.15
	latest_sce_3_00_20010601:1.13.0.2
	sce_3_00_20010601:1.13
	latest_sce_2_31_20010308:1.10.0.2
	sce_2_31_20010308:1.10
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.60
date	2011.09.28.23.50.05;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2011.09.24.00.28.28;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2011.08.30.20.18.05;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.09.25.21.11.58;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.02.17.34.11;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.01.27.23.13.45;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.26.23.50.33;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.01.21.23.01.51;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.19.23.50.58;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.14.21.34.41;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.14.00.01.17;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.13.21.27.25;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.12.22.48.38;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.01.10.22.34.48;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.23.20.30.08;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.23.17.24.20;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.06.22.38.16;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.30.00.19.47;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.24.22.45.30;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.24.00.05.54;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.23.20.50.07;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.15.22.02.01;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.12.23.50.52;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.12.21.03.46;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.12.17.02.44;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.11.20.11.10;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.11.16.30.22;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.10.20.41.42;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.10.19.00.43;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.09.23.08.00;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.06.00.30.34;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.24.17.11.17;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.29.19.55.32;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.29.14.27.49;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.21.17.11.10;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.31.23.09.50;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.28.23.05.33;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.24.17.24.34;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.21.21.35.32;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.20.19.03.58;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.19.16.48.26;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.02.22.18.47;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.30.20.37.28;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.07.20.15.03;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.10.22.06.58;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.18.21.44.45;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.03.20.07.31;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.25.14.53.27;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.25.20.54.36;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.21.21.55.48;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.04.22.27.53;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.28.22.13.39;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.22.16.18.27;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.20.20.08.37;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.05.19.05.31;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.04.22.07.39;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.48;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.20.03.28;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.53;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef RtAnH
#define RtAnH

//------------------------------------------------------------------------------
// Header file: "RtAn.h"
//
// Contains the declaration of class RtAnalyzer.
//------------------------------------------------------------------------------

#include <Schedule.h>
#include <PtrSched.h>
#include <PairStack.h>
#include <Assoc.h>

//------------------------------------------------------------------------------
// Class RtAnalyzer
//
// "Routing Analyzer"
// Responsible for performing the routing analysis of penalized execution.
//
// Implemented in PenExec.C.
//------------------------------------------------------------------------------

class WitRtAnalyzer: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitRtAnalyzer (WitSelector *, WitExpRest *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitRtAnalyzer ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void modifyRouting ();
         //
         // Modifies the current routing as appropriate in order to fill a small
         // incremental requirement for topPart in topPer at a heuristically 
         // minimum exec penalty.

      void findHypoModPts (WitObjStack <WitSelPt> & theModPts);
         //
         // Sets theModPts to the set of SelPts at which the selection
         // configuration would be modified by a hypothetical call to
         // modifyRouting ().

      void recCommitVol (double commitVol);
         //
         // Records the fact that commitVol units of demand were commited based
         // on the current routing.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitRtAnalyzer);

      void checkInput ();
         //
         // Verifies that all required preconditions for pen-exec are met.

      void findRoutingMods ();

      bool inInitState ();
         //
         // Returns true, iff this RtAnalyzer is in its initial state.
         // (This function is only used for program verification.)

      void preAnalyze (WitPart * fillPart, WitPeriod fillPer);
         //
         // Pre-analyzes fillPart for filling demand in fillPer, i.e, records 
         // the fact the prerequisites for fillPart in fillPer are to be 
         // pre-analyzed and that fillPart in fillPer is to be analyzed some 
         // time after its prerequisites have been analyzed.

      void recBomEntPrereq (
            WitPart *     fillPart, 
            WitPeriod     fillPer,
            WitBomEntry * theBomEnt,
            WitPeriod     execPer);
         //
         // Records the prerequisite for fillPart in fillPer found thru 
         // theBomEnt in execPer, if any.

      void recConsEntPrereq (
            WitPart *      fillPart, 
            WitPeriod      fillPer,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer);
         //
         // Records the prerequisite for fillPart in fillPer found thru 
         // theConsEnt in execPer, if any.

      void recordPrereq (
            WitPart * depPart, 
            WitPeriod depPer,
            WitPart * prereqPart, 
            WitPeriod prereqPer);
         //
         // Records the fact that prereqPart in prereqPer is a prerequisite for 
         // depPart in depPer, i.e., that depPart in depPer cannot be analyzed 
         // until prereqPart in prereqPer has been analyzed.

      bool activeForPreAn (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns true, iff theRtCand is currently active for explosion in
         // thePer for pre-analysis purposes.

      double analyze (WitPart * fillPart, WitPeriod fillPer);
         //
         // Analyzes fillPart for filling demand in fillPer and returns the
         // minimum penalty computed for it.

      bool needToAnalyze (
            WitPart *   fillPart,
            WitPeriod   fillPer, 
            WitPeriod & expPer);
         //
         // Returns true, iff it's necessary to do a detailed routing
         // analysis the fillPart in fillPer.
         // In the true case, expPer is set to the explosion period.

      double penThruBopEnt (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Returns the per unit exec penalty for exploding down thru theBopEnt
         // in expPer.

      double penThruBomEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Returns the per unit exec penalty for exploding down thru theBomEnt
         // or one of its substitutes in expPer.

      double penThruBomEntMR (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Does the multi-route case of penThruBomEnt.

      double penThruRtSiteMR (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Analyzes theRtSite for a multi-route explosion in thePer and returns
         // the minimum penalty computed for it.

      double penThruRtSiteOPR (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Analyzes theRtSite for an overriding proportionate routing
         // explosion in thePer and returns the minimum penalty computed for it.

      double penThruRtSiteTBPR (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Analyzes theRtSite for a tie breaking proportionate routing
         // explosion in thePer and returns the minimum penalty computed for it.

      double penThruRtCand (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns the per unit exec penalty for exploding down thru theRtCand
         // in thePer.

      double penThruConsEnt (WitConsEntry * theConsEnt, WitPeriod execPer);
         //
         // Returns the per unit exec penalty for exploding down thru theConsEnt
         // in expPer.

      bool canPseudoNet (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Returns true, iff explosion thru theBomEnt in execPer
         // is blocked by the availability of pseudo-supply for netting thru the
         // substitutes of theBomEnt or thru theBomEnt itself.

      bool canDirPseudoNet (WitConsEntry * theConsEnt, WitPeriod execPer);
         //
         // Returns true, iff explosion thru theConsEnt in execPer is blocked by
         // the availability of pseudo-supply for netting thru theConsEnt
         // directly.

      void postAnalyze (WitPart * anaPart, WitPeriod anaPer);
         //
         // Records the fact that anaPart has been analyzed in anaPer.

      void addHypoPrModPts (WitObjStack <WitSelPt> & theModPts);
         //
         // Valid only when called by findHypoModPts.
         // Adds to theModPts the set of SelPts at which the prop-rt
         // configuration would be modified by a hypothetical call to 
         // modifyRouting ().

      //------------------------------------------------------------------------
      // Print functions.
      // Valid only if printMode_ is true.
      //------------------------------------------------------------------------

      void printAnaHead  ();
      void printPreAn    (WitPart *,   WitPeriod);
      void printPrereq   (WitPart *,   WitPeriod);
      void printGap      ();
      void printAnalysis (WitPart *,   WitPeriod);
      void printMrMods   ();
      void printLpprMods ();

      void printLpprMods (
            const WitRtCandPerStack & theRtCandPers,
            const char *              statText);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector for this RtAnalyzer.

      WitExpRest * const myExpRest_;
         //
         // The ExpRest associated with this RtAnalyzer.

      WitMrMgr * const myMrMgr_;
         //
         // The MrMgr associated with this RtAnalyzer.

      WitPrMgr * myPrMgr_;
         //
         // The PrMgr associated with this RtAnalyzer, if any, otherwise NULL.

      WitRtMgr * const myRtMgr_;
         //
         // The RtMgr associated with this RtAnalyzer.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitRtCandPerStack curMrMods_;
         //
         // Valid only during a call to modifyRouting or findHypoModPts.
         // The set of modifications to the multi-route configuration that would
         // result from a hypothetical call to modifyRouting ().

      WitRtCandPerStack curPrActMods_;
      WitRtCandPerStack curPrDeactMods_;
         //
         // Non-Empty only in tie breaking prop-rt mode.
         // Valid only during a call to modifyRouting or findHypoModPts.
         //
         // curPrActMods_ is the set of (RtCand, Period) pairs at which prop-rt
         // would be activated by a hypothetical call to modifyRouting ().
         //
         // curPrDeactMods_ is the set of (RtCand, Period) pairs at which
         // prop-rt would be deactivated by a hypothetical call to
         // modifyRouting ().

      WitPartPerStack toPreAn_;
         //
         // The set of (Part, fill period)s to be pre-analyzed.

      WitPtrSched <WitPart, WitPartPerStack> dependents_;
         //
         // dependents_.refFor (thePart, fillPer) is the set of (Part, Period)s 
         // which depend directly on (thePart, fillPer) for their analysis.

      WitSchedule <WitPart, int> nPrereqsToAna_;
         //
         // nPrereqsToAna_ (thePart, fillPer) is # direct prerequisites of
         // thePart in fillPer that have yet to be analyzed.

      WitPartPerStack toAnalyze_;
         //
         // The set of (Part, fill period)s to be analyzed.

      WitSchedule <WitPart, double> minPen_;
         //
         // minPen_ (thePart, thePer) is the minimum per unit penalty found for
         // meeting an infinitesimal incremental demand for thePart in thePer.

      WitSchedule <WitPart, bool> minPenValid_;
         //
         // minPenValid_ (thePart, thePer) is true, iff 
         // minPen_ (thePart, thePer) currently holds a valid value.
         // Allocated and used in DEBUG mode only.

      const bool printMode_;
         //
         // true, iff printing has been requested.

      double curPen_;
         //
         // The penalty of the currently selected route.

      double totCommitVol_;
         //
         // The total volume commited.

      double weightedTotPen_;
         //
         // The total penalty incurred, weighted by commitVol.

      WitSchedule <WitRtSite, bool> inTheModPts_;
         //
         // Valid only in tie breaking prop-rt mode.
         // inTheModPts_ (theRtSite)[thePer] is true, iff addHypoPrModPts () is
         // executing and the SelPt for prop-rt at theRtSite in thePer has been
         // added to theModPts.
   };

#endif
@


1.59
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 5
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
//------------------------------------------------------------------------------
@


1.58
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 1
a6 1
//     IBM Confidential
d33 2
a34 2
{
public:
d36 288
a323 288
//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitRtAnalyzer (WitSelector *, WitExpRest *);

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitRtAnalyzer ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void modifyRouting ();
//
// Modifies the current routing as appropriate in order to fill a small
// incremental requirement for topPart in topPer at a heuristically
// minimum exec penalty.

void findHypoModPts (WitObjStack <WitSelPt> & theModPts);
//
// Sets theModPts to the set of SelPts at which the selection
// configuration would be modified by a hypothetical call to
// modifyRouting ().

void recCommitVol (double commitVol);
//
// Records the fact that commitVol units of demand were commited based
// on the current routing.

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitRtAnalyzer);

void checkInput ();
//
// Verifies that all required preconditions for pen-exec are met.

void findRoutingMods ();

bool inInitState ();
//
// Returns true, iff this RtAnalyzer is in its initial state.
// (This function is only used for program verification.)

void preAnalyze (WitPart * fillPart, WitPeriod fillPer);
//
// Pre-analyzes fillPart for filling demand in fillPer, i.e, records
// the fact the prerequisites for fillPart in fillPer are to be
// pre-analyzed and that fillPart in fillPer is to be analyzed some
// time after its prerequisites have been analyzed.

void recBomEntPrereq (
WitPart *     fillPart,
WitPeriod     fillPer,
WitBomEntry * theBomEnt,
WitPeriod     execPer);
//
// Records the prerequisite for fillPart in fillPer found thru
// theBomEnt in execPer, if any.

void recConsEntPrereq (
WitPart *      fillPart,
WitPeriod      fillPer,
WitConsEntry * theConsEnt,
WitPeriod      execPer);
//
// Records the prerequisite for fillPart in fillPer found thru
// theConsEnt in execPer, if any.

void recordPrereq (
WitPart * depPart,
WitPeriod depPer,
WitPart * prereqPart,
WitPeriod prereqPer);
//
// Records the fact that prereqPart in prereqPer is a prerequisite for
// depPart in depPer, i.e., that depPart in depPer cannot be analyzed
// until prereqPart in prereqPer has been analyzed.

bool activeForPreAn (WitRtCand * theRtCand, WitPeriod thePer);
//
// Returns true, iff theRtCand is currently active for explosion in
// thePer for pre-analysis purposes.

double analyze (WitPart * fillPart, WitPeriod fillPer);
//
// Analyzes fillPart for filling demand in fillPer and returns the
// minimum penalty computed for it.

bool needToAnalyze (
WitPart *   fillPart,
WitPeriod   fillPer,
WitPeriod & expPer);
//
// Returns true, iff it's necessary to do a detailed routing
// analysis the fillPart in fillPer.
// In the true case, expPer is set to the explosion period.

double penThruBopEnt (WitBopEntry * theBopEnt, WitPeriod expPer);
//
// Returns the per unit exec penalty for exploding down thru theBopEnt
// in expPer.

double penThruBomEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
//
// Returns the per unit exec penalty for exploding down thru theBomEnt
// or one of its substitutes in expPer.

double penThruBomEntMR (WitBomEntry * theBomEnt, WitPeriod execPer);
//
// Does the multi-route case of penThruBomEnt.

double penThruRtSiteMR (WitRtSite * theRtSite, WitPeriod thePer);
//
// Analyzes theRtSite for a multi-route explosion in thePer and returns
// the minimum penalty computed for it.

double penThruRtSiteOPR (WitRtSite * theRtSite, WitPeriod thePer);
//
// Analyzes theRtSite for an overriding proportionate routing
// explosion in thePer and returns the minimum penalty computed for it.

double penThruRtSiteTBPR (WitRtSite * theRtSite, WitPeriod thePer);
//
// Analyzes theRtSite for a tie breaking proportionate routing
// explosion in thePer and returns the minimum penalty computed for it.

double penThruRtCand (WitRtCand * theRtCand, WitPeriod thePer);
//
// Returns the per unit exec penalty for exploding down thru theRtCand
// in thePer.

double penThruConsEnt (WitConsEntry * theConsEnt, WitPeriod execPer);
//
// Returns the per unit exec penalty for exploding down thru theConsEnt
// in expPer.

bool canPseudoNet (WitBomEntry * theBomEnt, WitPeriod execPer);
//
// Returns true, iff explosion thru theBomEnt in execPer
// is blocked by the availability of pseudo-supply for netting thru the
// substitutes of theBomEnt or thru theBomEnt itself.

bool canDirPseudoNet (WitConsEntry * theConsEnt, WitPeriod execPer);
//
// Returns true, iff explosion thru theConsEnt in execPer is blocked by
// the availability of pseudo-supply for netting thru theConsEnt
// directly.

void postAnalyze (WitPart * anaPart, WitPeriod anaPer);
//
// Records the fact that anaPart has been analyzed in anaPer.

void addHypoPrModPts (WitObjStack <WitSelPt> & theModPts);
//
// Valid only when called by findHypoModPts.
// Adds to theModPts the set of SelPts at which the prop-rt
// configuration would be modified by a hypothetical call to
// modifyRouting ().

//------------------------------------------------------------------------
// Print functions.
// Valid only if printMode_ is true.
//------------------------------------------------------------------------

void printAnaHead  ();
void printPreAn    (WitPart *,   WitPeriod);
void printPrereq   (WitPart *,   WitPeriod);
void printGap      ();
void printAnalysis (WitPart *,   WitPeriod);
void printMrMods   ();
void printLpprMods ();

void printLpprMods (
const WitRtCandPerStack & theRtCandPers,
const char *              statText);

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Associations.
//------------------------------------------------------------------------

WitSelector * const mySelector_;
//
// The Selector for this RtAnalyzer.

WitExpRest * const myExpRest_;
//
// The ExpRest associated with this RtAnalyzer.

WitMrMgr * const myMrMgr_;
//
// The MrMgr associated with this RtAnalyzer.

WitPrMgr * myPrMgr_;
//
// The PrMgr associated with this RtAnalyzer, if any, otherwise NULL.

WitRtMgr * const myRtMgr_;
//
// The RtMgr associated with this RtAnalyzer.

//------------------------------------------------------------------------
// Other private member data.
//------------------------------------------------------------------------

WitRtCandPerStack curMrMods_;
//
// Valid only during a call to modifyRouting or findHypoModPts.
// The set of modifications to the multi-route configuration that would
// result from a hypothetical call to modifyRouting ().

WitRtCandPerStack curPrActMods_;
WitRtCandPerStack curPrDeactMods_;
//
// Non-Empty only in tie breaking prop-rt mode.
// Valid only during a call to modifyRouting or findHypoModPts.
//
// curPrActMods_ is the set of (RtCand, Period) pairs at which prop-rt
// would be activated by a hypothetical call to modifyRouting ().
//
// curPrDeactMods_ is the set of (RtCand, Period) pairs at which
// prop-rt would be deactivated by a hypothetical call to
// modifyRouting ().

WitPartPerStack toPreAn_;
//
// The set of (Part, fill period)s to be pre-analyzed.

WitPtrSched <WitPart, WitPartPerStack> dependents_;
//
// dependents_.refFor (thePart, fillPer) is the set of (Part, Period)s
// which depend directly on (thePart, fillPer) for their analysis.

WitSchedule <WitPart, int> nPrereqsToAna_;
//
// nPrereqsToAna_ (thePart, fillPer) is # direct prerequisites of
// thePart in fillPer that have yet to be analyzed.

WitPartPerStack toAnalyze_;
//
// The set of (Part, fill period)s to be analyzed.

WitSchedule <WitPart, double> minPen_;
//
// minPen_ (thePart, thePer) is the minimum per unit penalty found for
// meeting an infinitesimal incremental demand for thePart in thePer.

WitSchedule <WitPart, bool> minPenValid_;
//
// minPenValid_ (thePart, thePer) is true, iff
// minPen_ (thePart, thePer) currently holds a valid value.
// Allocated and used in DEBUG mode only.

const bool printMode_;
//
// true, iff printing has been requested.

double curPen_;
//
// The penalty of the currently selected route.

double totCommitVol_;
//
// The total volume commited.

double weightedTotPen_;
//
// The total penalty incurred, weighted by commitVol.

WitSchedule <WitRtSite, bool> inTheModPts_;
//
// Valid only in tie breaking prop-rt mode.
// inTheModPts_ (theRtSite)[thePer] is true, iff addHypoPrModPts () is
// executing and the SelPt for prop-rt at theRtSite in thePer has been
// added to theModPts.
};
@


1.57
log
@Heuristic search increment.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 1
a6 1
//     IBM Confidential 
d33 2
a34 2
   {
   public:
d36 288
a323 288
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitRtAnalyzer (WitSelector *, WitExpRest *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitRtAnalyzer ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void modifyRouting ();
         //
         // Modifies the current routing as appropriate in order to fill a small
         // incremental requirement for topPart in topPer at a heuristically 
         // minimum exec penalty.

      void findHypoModPts (WitObjStack <WitSelPt> & theModPts);
         //
         // Sets theModPts to the set of SelPts at which the selection
         // configuration would be modified by a hypothetical call to
         // modifyRouting ().

      void recCommitVol (double commitVol);
         //
         // Records the fact that commitVol units of demand were commited based
         // on the current routing.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitRtAnalyzer);

      void checkInput ();
         //
         // Verifies that all required preconditions for pen-exec are met.

      void findRoutingMods ();

      bool inInitState ();
         //
         // Returns true, iff this RtAnalyzer is in its initial state.
         // (This function is only used for program verification.)

      void preAnalyze (WitPart * fillPart, WitPeriod fillPer);
         //
         // Pre-analyzes fillPart for filling demand in fillPer, i.e, records 
         // the fact the prerequisites for fillPart in fillPer are to be 
         // pre-analyzed and that fillPart in fillPer is to be analyzed some 
         // time after its prerequisites have been analyzed.

      void recBomEntPrereq (
            WitPart *     fillPart, 
            WitPeriod     fillPer,
            WitBomEntry * theBomEnt,
            WitPeriod     execPer);
         //
         // Records the prerequisite for fillPart in fillPer found thru 
         // theBomEnt in execPer, if any.

      void recConsEntPrereq (
            WitPart *      fillPart, 
            WitPeriod      fillPer,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer);
         //
         // Records the prerequisite for fillPart in fillPer found thru 
         // theConsEnt in execPer, if any.

      void recordPrereq (
            WitPart * depPart, 
            WitPeriod depPer,
            WitPart * prereqPart, 
            WitPeriod prereqPer);
         //
         // Records the fact that prereqPart in prereqPer is a prerequisite for 
         // depPart in depPer, i.e., that depPart in depPer cannot be analyzed 
         // until prereqPart in prereqPer has been analyzed.

      bool activeForPreAn (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns true, iff theRtCand is currently active for explosion in
         // thePer for pre-analysis purposes.

      double analyze (WitPart * fillPart, WitPeriod fillPer);
         //
         // Analyzes fillPart for filling demand in fillPer and returns the
         // minimum penalty computed for it.

      bool needToAnalyze (
            WitPart *   fillPart,
            WitPeriod   fillPer, 
            WitPeriod & expPer);
         //
         // Returns true, iff it's necessary to do a detailed routing
         // analysis the fillPart in fillPer.
         // In the true case, expPer is set to the explosion period.

      double penThruBopEnt (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Returns the per unit exec penalty for exploding down thru theBopEnt
         // in expPer.

      double penThruBomEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Returns the per unit exec penalty for exploding down thru theBomEnt
         // or one of its substitutes in expPer.

      double penThruBomEntMR (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Does the multi-route case of penThruBomEnt.

      double penThruRtSiteMR (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Analyzes theRtSite for a multi-route explosion in thePer and returns
         // the minimum penalty computed for it.

      double penThruRtSiteOPR (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Analyzes theRtSite for an overriding proportionate routing
         // explosion in thePer and returns the minimum penalty computed for it.

      double penThruRtSiteTBPR (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Analyzes theRtSite for a tie breaking proportionate routing
         // explosion in thePer and returns the minimum penalty computed for it.

      double penThruRtCand (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns the per unit exec penalty for exploding down thru theRtCand
         // in thePer.

      double penThruConsEnt (WitConsEntry * theConsEnt, WitPeriod execPer);
         //
         // Returns the per unit exec penalty for exploding down thru theConsEnt
         // in expPer.

      bool canPseudoNet (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Returns true, iff explosion thru theBomEnt in execPer
         // is blocked by the availability of pseudo-supply for netting thru the
         // substitutes of theBomEnt or thru theBomEnt itself.

      bool canDirPseudoNet (WitConsEntry * theConsEnt, WitPeriod execPer);
         //
         // Returns true, iff explosion thru theConsEnt in execPer is blocked by
         // the availability of pseudo-supply for netting thru theConsEnt
         // directly.

      void postAnalyze (WitPart * anaPart, WitPeriod anaPer);
         //
         // Records the fact that anaPart has been analyzed in anaPer.

      void addHypoPrModPts (WitObjStack <WitSelPt> & theModPts);
         //
         // Valid only when called by findHypoModPts.
         // Adds to theModPts the set of SelPts at which the prop-rt
         // configuration would be modified by a hypothetical call to 
         // modifyRouting ().

      //------------------------------------------------------------------------
      // Print functions.
      // Valid only if printMode_ is true.
      //------------------------------------------------------------------------

      void printAnaHead  ();
      void printPreAn    (WitPart *,   WitPeriod);
      void printPrereq   (WitPart *,   WitPeriod);
      void printGap      ();
      void printAnalysis (WitPart *,   WitPeriod);
      void printMrMods   ();
      void printLpprMods ();

      void printLpprMods (
            const WitRtCandPerStack & theRtCandPers,
            const char *              statText);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector for this RtAnalyzer.

      WitExpRest * const myExpRest_;
         //
         // The ExpRest associated with this RtAnalyzer.

      WitMrMgr * const myMrMgr_;
         //
         // The MrMgr associated with this RtAnalyzer.

      WitPrMgr * myPrMgr_;
         //
         // The PrMgr associated with this RtAnalyzer, if any, otherwise NULL.

      WitRtMgr * const myRtMgr_;
         //
         // The RtMgr associated with this RtAnalyzer.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitRtCandPerStack curMrMods_;
         //
         // Valid only during a call to modifyRouting or findHypoModPts.
         // The set of modifications to the multi-route configuration that would
         // result from a hypothetical call to modifyRouting ().

      WitRtCandPerStack curPrActMods_;
      WitRtCandPerStack curPrDeactMods_;
         //
         // Non-Empty only in tie breaking prop-rt mode.
         // Valid only during a call to modifyRouting or findHypoModPts.
         //
         // curPrActMods_ is the set of (RtCand, Period) pairs at which prop-rt
         // would be activated by a hypothetical call to modifyRouting ().
         //
         // curPrDeactMods_ is the set of (RtCand, Period) pairs at which
         // prop-rt would be deactivated by a hypothetical call to
         // modifyRouting ().

      WitPartPerStack toPreAn_;
         //
         // The set of (Part, fill period)s to be pre-analyzed.

      WitPtrSched <WitPart, WitPartPerStack> dependents_;
         //
         // dependents_.refFor (thePart, fillPer) is the set of (Part, Period)s 
         // which depend directly on (thePart, fillPer) for their analysis.

      WitSchedule <WitPart, int> nPrereqsToAna_;
         //
         // nPrereqsToAna_ (thePart, fillPer) is # direct prerequisites of
         // thePart in fillPer that have yet to be analyzed.

      WitPartPerStack toAnalyze_;
         //
         // The set of (Part, fill period)s to be analyzed.

      WitSchedule <WitPart, double> minPen_;
         //
         // minPen_ (thePart, thePer) is the minimum per unit penalty found for
         // meeting an infinitesimal incremental demand for thePart in thePer.

      WitSchedule <WitPart, bool> minPenValid_;
         //
         // minPenValid_ (thePart, thePer) is true, iff 
         // minPen_ (thePart, thePer) currently holds a valid value.
         // Allocated and used in DEBUG mode only.

      const bool printMode_;
         //
         // true, iff printing has been requested.

      double curPen_;
         //
         // The penalty of the currently selected route.

      double totCommitVol_;
         //
         // The total volume commited.

      double weightedTotPen_;
         //
         // The total penalty incurred, weighted by commitVol.

      WitSchedule <WitRtSite, bool> inTheModPts_;
         //
         // Valid only in tie breaking prop-rt mode.
         // inTheModPts_ (theRtSite)[thePer] is true, iff addHypoPrModPts () is
         // executing and the SelPt for prop-rt at theRtSite in thePer has been
         // added to theModPts.
   };
@


1.56
log
@Updated the copyright date on all source files.
@
text
@d64 1
a64 1
      void recCommitVol (double commitVol, bool byExp);
a67 2
         // If byExp is true, the commit was done by exploding; 
         // if it is false, the commit was done by netting.
@


1.55
log
@Tie breaking prop-rt.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.54
log
@Pegged critical list.
@
text
@d144 14
a177 14
      double penThruBopEnt (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Returns the per unit exec penalty for exploding down thru theBopEnt
         // in expPer.

      double penThruBomEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Returns the per unit exec penalty for exploding down thru theBomEnt
         // or one of its substitutes in expPer.

      double penThruBomEntMR (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Does the multi-route case of penThruBomEnt.

@


1.53
log
@Changed terminology from "low priority proportionate routing" to
"tie breaking proportionate routing".
@
text
@d247 4
@


1.52
log
@Low-Pri Prop-Rt.
@
text
@d149 1
a149 1
      double penThruRtSiteHPPR (WitRtSite * theRtSite, WitPeriod thePer);
d151 1
a151 1
         // Analyzes theRtSite for a high-priority proportionate routing
d154 1
a154 1
      double penThruRtSiteLPPR (WitRtSite * theRtSite, WitPeriod thePer);
d156 1
a156 1
         // Analyzes theRtSite for a low-priority proportionate routing
d260 1
a260 1
         // Non-Empty only in low-pri prop-rt mode.
d317 1
a317 1
         // Valid only in low-pri prop-rt mode.
@


1.51
log
@Low-Pri Prop-Rt.
@
text
@d40 1
a40 1
      WitRtAnalyzer (WitSelector *);
d233 5
a237 1
         // The Selector that owns this RtAnalyzer.
a242 4
      WitExpRest * const myExpRest_;
         //
         // The ExpRest associated with this RtAnalyzer.

@


1.50
log
@Low-Pri Prop-Rt.
@
text
@d216 1
a216 1
      void printMods     ();
@


1.49
log
@Low-Pri Prop-Rt.
@
text
@d199 7
d314 7
@


1.48
log
@Low-Pri Prop-Rt.
@
text
@d60 3
a62 4
         // Sets theModPts to be the set of SelPts at which the selection
         // configuration would be modified in order to fill a small incremental
         // requirement for topPart in topPer at a heuristically minimum exec
         // penalty.
d212 4
d247 2
a248 3
         // The set of routing modifications appropriate in order to fill a
         // small incremental requirement for topPart in topPer at a
         // heuristically minimum exec penalty.
d250 2
a251 1
      WitRtCandPerStack curLpprMods_;
d254 8
a261 11
         // Valid only during a call to findRoutingMods or modifyRouting.
         // The set of (RtCand, Period) pairs whose LPPR active status is to be
         // modified in order to fill a small incremental requirement for
         // topPart in topPer at a heuristically minimum exec penalty.

      WitSchedule <WitRtCand, bool> modLpprActStat_;
         //
         // Only allocated in low-pri prop-rt mode.
         // If (theRtCand, thePer) is in curLpprMods_, then
         // modLpprActStat_ (theRtCand) [thePer] is the LPPR active status to be
         // assigned to (theRtCand, thePer).
@


1.47
log
@Low-Pri Prop-Rt.
@
text
@d58 1
a58 1
      void findRoutingMods (WitRtCandPerStack & theMrMods);
d60 4
a63 3
         // Sets theMrMods to be the set of multi-route modifications
         // appropriate in order to fill a small incremental requirement for
         // topPart in topPer at a heuristically minimum exec penalty.
d243 1
a243 1
         // Valid only during a call to findRoutingMods or modifyRouting.
@


1.46
log
@Low-Pri Prop-Rt.
@
text
@a231 4
      WitPoMgr * myPoMgr_;
         //
         // The PoMgr associated with this RtAnalyzer, if any, otherwise NULL.

@


1.45
log
@Low-Pri Prop-Rt.
@
text
@d58 1
a58 3
      void findRoutingMods (
            WitRtCandPerStack & theMrMods,
            WitRtCandPerStack & theLpprMods);
d63 1
a63 3
         // In in low-pri prop-rt mode, sets theLpprMods to be the corresponding
         // set of prop-rt modifications.
                                         
@


1.44
log
@Low-Pri Prop-Rt.
@
text
@d240 4
@


1.43
log
@Low-Pri Prop-Rt.
@
text
@d236 1
a236 1
      WitPrMgr * myPrMgr_;
d238 1
a238 1
         // The PrMgr associated with this RtAnalyzer, if any, otherwise NULL.
@


1.42
log
@Low-Pri Prop-Rt.
@
text
@d58 3
a60 1
      void findRoutingMods (WitRtCandPerStack & theRtCandPers);
d62 1
a62 1
         // Sets theRtCandPers to be the set of routing modifications
d65 3
a67 1

a87 2
         //
         // modRtCandPers_.
d244 1
a244 1
      WitRtCandPerStack modRtCandPers_;
d251 1
a251 1
      WitRtCandPerStack lpprRtCandPers_;
d262 1
a262 1
         // If (theRtCand, thePer) is in lpprRtCandPers_, then
@


1.41
log
@Low-Pri Prop-Rt.
@
text
@a70 12
      void fundDeactivateForLPPR (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Records the fact that proportionate routing thru theRtCand in thePer
         // has been ruled out by a fundamental shortage.
         // Valid only in low-pri prop-rt mode.

      bool fundActForLPPR (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns true, iff proportionate routing thru theRtCand in thePer has
         // not been ruled out by a fundamental shortage.
         // Valid only in low-pri prop-rt mode.

a213 2
      void printLpprFundDeact (WitRtCand *, WitPeriod);

d251 1
a251 1
         // Non-Empty only in low-pri-prop-rt mode.
d259 1
a259 1
         // Only allocated in low-pri-prop-rt mode.
a307 7

      WitSchedule <WitRtCand, bool> fundActForLPPR_;
         //
         // In low-pri-prop-rt mode, fundActForLPPR_ (theRtCand) [thePer]
         // is true, iff proportionate routing thru theRtCand in thePer has not
         // been ruled out by a fundamental shortage.
         // Otherwise, not allocated.
@


1.40
log
@Low-Pri Prop-Rt.
@
text
@d77 6
d226 2
@


1.39
log
@Low-Pri Prop-Rt.
@
text
@d71 1
a71 1
      bool allowedForLPPR (WitRtCand * theRtCand, WitPeriod thePer);
d73 3
a75 3
         // Returns true, iff pen-exec currently allows routing thru
         // theRtCand in thePer for low-pri-prop-rt.
         // Valid only in low-pri-prop-rt mode.
d133 1
a133 1
      bool active (WitRtCand * theRtCand, WitPeriod thePer);
d136 1
a136 1
         // thePer.
d212 7
a218 7
      void printAnaHead    ();
      void printPreAn      (WitPart *,   WitPeriod);
      void printPrereq     (WitPart *,   WitPeriod);
      void printGap        ();
      void printAnalysis   (WitPart *,   WitPeriod);
      void printMods       ();
      void printAllForLPPR (WitRtSite *, WitPeriod);
d255 15
d315 1
a315 1
      WitSchedule <WitRtCand, bool> allowedForLPPR_;
d317 3
a319 3
         // In low-pri-prop-rt mode, allowedForLPPR_ (theRtCand) [thePer]
         // is true, iff pen-exec currently allows routing thru theRtCand in
         // thePer for low-pri-prop-rt.
@


1.38
log
@Low-Pri Prop-Rt.
@
text
@d162 5
a185 5
      double penThruRtSiteLPPR (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Analyzes theRtSite for a low-priority proportionate routing
         // explosion in thePer and returns the minimum penalty computed for it.

@


1.37
log
@Low-Pri Prop-Rt.
@
text
@d133 1
a133 1
      bool active (WitBillEntry * theBillEnt, WitPeriod thePer);
d135 1
a135 1
         // Returns true, iff theBillEnt is currently active for explosion in
d152 1
a152 1
      double analyzeMR (WitPart * thePart, WitPeriod expPer);
d154 1
a154 1
         // Analyzes thePart for a multi-route explosion in expPer and returns
d157 1
a157 1
      double analyzeHPPR (WitPart * thePart, WitPeriod expPer);
d159 7
a165 2
         // Analyzes thePart for a high-priority proportionate routing
         // explosion in expPer and returns the minimum penalty computed for it.
d181 1
a181 14
      void analyze (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitRtCand * &  minRtCand,
            double &       minPen);
         //
         // Does routing analysis for exploding theConsEnt in execPer.
         // Updates minRtCand and minPen, as appropriate.

      double penThruBomEntHPPR (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Does the high-priority proportionate routing case of penThruBomEnt.

      double analyzeLPPR (WitRtSite * theRtSite, WitPeriod thePer);
a202 13
      void updateMinRtCand (
            WitRtCand * &  minRtCand,
            double &       minPen,
            WitBillEntry * theBillEnt,
            double         thePen);
         //
         // Updates minRtCand and minPen to theBillEnt and thePen, as
         // appropriate.

      void addToMods (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Adds theRtCand and thePer to modRtCandPers_, if appropriate.

@


1.36
log
@Low-Pri Prop-Rt.
@
text
@d189 1
a189 1
      double analyzeLPPR (WitRtSitePtr theRtSite, WitPeriod thePer);
@


1.35
log
@Low-Pri Prop-Rt.
@
text
@a161 5
      double analyzeLPPR (WitPart * thePart, WitPeriod expPer);
         //
         // Analyzes thePart for a low-priority proportionate routing
         // explosion in expPer and returns the minimum penalty computed for it.

d183 1
a183 1
         // Updates minRtCand and min{en, as appropriate.
d189 1
a189 1
      double penThruBomEntLPPR (WitBomEntry * theBomEnt, WitPeriod execPer);
d191 2
a192 1
         // Does the low-priority proportionate routing case of penThruBomEnt.
d234 2
a235 2
      void printPreAn      (WitPart *,     WitPeriod);
      void printPrereq     (WitPart *,     WitPeriod);
d237 1
a237 1
      void printAnalysis   (WitPart *,     WitPeriod);
d239 1
a239 1
      void printAllForLPPR (WitRtSitePtr,  WitPeriod);
@


1.34
log
@Low-pri prop-rt.
@
text
@d237 7
a243 8
      void printAnaHead      ();
      void printPreAn        (WitPart *,     WitPeriod);
      void printPrereq       (WitPart *,     WitPeriod);
      void printGap          ();
      void printAnalysis     (WitPart *,     WitPeriod);
      void printMods         ();
      void printAllowedForPr (WitPart *,     WitPeriod);
      void printAllowedForPr (WitBomEntry *, WitPeriod);
@


1.33
log
@Low-pri prop-rt.
@
text
@d71 1
a71 1
      bool allowedForPr (WitRtCand * theRtCand, WitPeriod thePer);
d74 2
a75 2
         // theRtCand in thePer for prop-rt.
         // Valid only in pen-exec-over-prop-rt mode.
a176 4
      double penThruBomEntPR (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Does the proportionate routing case of penThruBomEnt.

d190 8
d205 2
a206 2
         // Returns true or false: true, iff explosion thru theBom in execPer is
         // blocked by the availability of pseudo-supply for netting thru the 
d238 2
a239 2
      void printPreAn        (WitPart *, WitPeriod);
      void printPrereq       (WitPart *, WitPeriod);
d241 1
a241 1
      void printAnalysis     (WitPart *, WitPeriod);
d243 2
a244 1
      void printAllowedForPr (WitPart *, WitPeriod);
d326 1
a326 1
      WitSchedule <WitRtCand, bool> allowedForPr_;
d328 1
a328 1
         // In pen-exec-over-prop-rt mode, allowedForPr_ (theRtCand) [thePer]
d330 1
a330 1
         // thePer for prop-rt.
@


1.32
log
@Low-Priority Prop Routing.
@
text
@d71 1
a71 1
      bool excludedForPr (WitRtCand * theRtCand, WitPeriod thePer);
d73 1
a73 1
         // Returns true, iff pen-exec currently excludes routing thru
d233 7
a239 6
      void printAnaHead  ();
      void printPreAn    (WitPart *, WitPeriod);
      void printPrereq   (WitPart *, WitPeriod);
      void printGap      ();
      void printAnalysis (WitPart *, WitPeriod);
      void printMods     ();
d321 1
a321 1
      WitSchedule <WitRtCand, bool> excludedForPr_;
d323 2
a324 2
         // In pen-exec-over-prop-rt mode, excludedForPr_ (theRtCand) [thePer]
         // is true, iff pen-exec currently excludes routing thru theRtCand in
@


1.31
log
@Continued implmentation of low priority proportionate routing.
@
text
@d152 1
a152 1
      double analyzePR (WitPart * thePart, WitPeriod expPer);
d154 1
a154 1
         // Analyzes thePart for a proportionate explosion in expPer and returns
d157 6
a162 1
      double analyzeMR (WitPart * thePart, WitPeriod expPer);
d164 2
a165 2
         // Analyzes thePart for a multi-route explosion in expPer and returns
         // the minimum penalty computed for it.
@


1.30
log
@Continued implementation of pen-exec override of prop-rt.
@
text
@d71 1
a71 1
      bool prohibitedForPr (WitRtCand * theRtCand, WitPeriod thePer);
d73 1
a73 1
         // Returns true, iff pen-exec currently prohibits routing thru
d315 1
a315 1
      WitSchedule <WitRtCand, bool> prohibitedForPr_;
d317 2
a318 2
         // In pen-exec-over-prop-rt mode, prohibitedForPr_ (theRtCand) [thePer]
         // is true, iff pen-exec currently prohibits routing thru theRtCand in
@


1.29
log
@Continued implementation of PIP.
@
text
@d71 6
d314 7
@


1.28
log
@Continued implementation of proportionate routing.
@
text
@d21 1
@


1.27
log
@Continued implementation of proportionate routing.
@
text
@d200 4
a203 4
            WitRtCand * & minRtCand,
            double &      minPen,
            WitRtCand *   theRtCand,
            double        thePen);
d205 1
a205 1
         // Updates minRtCand and minPen to theRtCand and thePen, as
@


1.26
log
@Continued implementation of proportionate routing.
@
text
@d126 1
a126 1
      bool active (WitRtCand * theRtCand, WitPeriod thePer);
d128 1
a128 1
         // Returns true, iff theRtCand is currently active for explosion in
@


1.25
log
@Continued implementation of proportionate routing.
@
text
@a168 7
      void updateTotPen (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double &       totPen);
         //
         // Updates totPen for prop routing thru theConsEnt in execPer.

@


1.24
log
@Continued implementation of proportionate routing.
@
text
@a97 5
      bool active (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns true, iff theRtCand is currently active for explosion in
         // thePer.

d126 5
d160 1
a160 1
      double penThruBomEntOrSubs (WitBomEntry * theBomEnt, WitPeriod execPer);
d164 15
@


1.23
log
@Continued implementation of proportionate routing.
@
text
@d98 5
d136 10
a145 16
      void defExpData (
            WitPart *        fillPart, 
            WitPeriod        fillPer, 
            WitPeriod &      expPer, 
            WitRtCandStack & theRtCands);
         //
         // If there is an explosion period and at least one explosion BOP entry
         // appropriate for filling requirements for fillPart in fillPer, 
         // this function sets expPer and theRtCands to the explosion period and
         // ordered list of RtCands for the explosion BOP entries. 
         // Otherwise sets theRtCands to the empty list.

      double analyzePR (
            WitPart *        thePart, 
            WitPeriod        expPer, 
            WitRtCandStack & theRtCands);
d149 5
a153 1
         // theRtCands is as computed by defExpData.
d164 9
@


1.22
log
@Continued implementation of proportionate routing.
@
text
@d143 8
a150 3
      void postAnalyze (WitPart * anaPart, WitPeriod anaPer);
         //
         // Records the fact that anaPart has been analyzed in anaPer.
d191 4
@


1.21
log
@Continued implementation of proportionate routing.
@
text
@d98 9
d135 1
a135 1
            WitBopEntStack & expBopEnts);
d139 3
a141 3
         // this function sets expPer and expBopEnts to the explosion period and
         // ordered list of explosion BOP entries. 
         // Otherwise sets expBopEnts to the empty list.
d218 4
@


1.20
log
@Continued implementation of proportionate routing.
@
text
@d57 5
a61 7
      void findRoutingMods (
            WitBopEntPerStack  & modBopEntPers,
            WitConsEntPerStack & modConsEntPers);
         //
         // Sets the args to be the set of routing modifications appropriate in
         // order to fill a small incremental requirement for topPart in topPer
         // at a heuristically minimum exec penalty.
d82 4
d117 1
a117 5
      double analyze (
            WitPart *            fillPart,
            WitPeriod            fillPer, 
            WitBopEntPerStack &  modBopEntPers,
            WitConsEntPerStack & modConsEntPers);
a120 2
         // See analyzeRoutings for the meaning of modBopEntPers and 
         // modConsEntPers.
d138 1
a138 4
      double penThruBopEnt (
            WitBopEntry *        theBopEnt, 
            WitPeriod            expPer,
            WitConsEntPerStack & modConsEntPers);
d141 1
a141 1
         // in expPer. See analyzeRoutings for the meaning of modConsEntPers.
d143 1
a143 4
      double penThruBomEntOrSubs (
            WitBomEntry *        theBomEnt, 
            WitPeriod            execPer,
            WitConsEntPerStack & modConsEntPers);
d146 1
a146 2
         // or one of its substitutes in expPer. See analyzeRoutings for the
         // meaning of modConsEntPers.
d165 13
d188 1
a188 2
 
      void printMods (const WitBopEntPerStack &, const WitConsEntPerStack &);
d213 7
@


1.19
log
@Internal changes.
@
text
@d201 1
a201 1
      WitPmrMgr * const myPmrMgr_;
d203 1
a203 5
         // The PmrMgr associated with this RtAnalyzer.

      WitCmrMgr * const myCmrMgr_;
         //
         // The CmrMgr associated with this RtAnalyzer.
@


1.18
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d65 1
a65 1
      void recCommitVol (double commitVol, WitBoolean byExp);
d69 2
a70 2
         // If byExp is TRUE, the commit was done by exploding; 
         // if it is FALSE, the commit was done by netting.
d84 1
a84 1
      WitBoolean inInitState ();
d86 1
a86 1
         // Returns TRUE, iff this RtAnalyzer is in its initial state.
d164 1
a164 1
      WitBoolean canPseudoNet (WitBomEntry * theBomEnt, WitPeriod execPer);
d166 1
a166 1
         // Returns TRUE or FALSE: TRUE, iff explosion thru theBom in execPer is
d170 1
a170 1
      WitBoolean canDirPseudoNet (WitConsEntry * theConsEnt, WitPeriod execPer);
d172 3
a174 3
         // Returns TRUE or FALSE: TRUE, iff explosion thru theConsEnt in
         // execPer is blocked by the availability of pseudo-supply for netting 
         // thru theConsEnt directly.
d178 1
a178 1
      // Valid only if printMode_ is TRUE.
d240 1
a240 1
      WitSchedule <WitPart, WitBoolean> minPenValid_;
d242 1
a242 1
         // minPenValid_ (thePart, thePer) is TRUE, iff 
d246 1
a246 1
      const WitBoolean printMode_;
d248 1
a248 1
         // TRUE, iff printing has been requested.
@


1.17
log
@Continued preliminary work on single source.
@
text
@a70 1
         // Valid only in path-counting mode.
d80 3
a82 3
      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------
a256 1
         // Only computed in path-counting mode.
@


1.16
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d227 1
a227 1
      WitSchedule (WitPart, int) nPrereqsToAna_;
d236 1
a236 1
      WitSchedule (WitPart, double) minPen_;
d241 1
a241 1
      WitSchedule (WitPart, WitBoolean) minPenValid_;
@


1.15
log
@Implemented class template PtrSched <*, *>.
@
text
@d39 1
a39 8
      WitRtAnalyzer (
            WitSelector * theSelector,
            WitPmrMgr *   thePmrMgr,
            WitCmrMgr *   theCmrMgr);
         //
         // mySelector_ <-- theSelector.
         // myPmrMgr    <-- thePmrMgr.
         // myCmrMgr_   <-- theCmrMgr.
d56 8
@


1.14
log
@Moved Stack template implementations to header files.
@
text
@d19 1
a175 18
      inline WitPartPerStack & dependents (WitPart * thePart, WitPeriod fillPer)
            //
            // dependents (thePart, fillPer) is the set of (Part, Period)s 
            // which depend directly on (thePart, fillPer) for their analysis.
         {
         return * dependentsPtr (thePart, fillPer);
         }

      inline WitPartPerStack * & dependentsPtr (
               WitPart * thePart,
               WitPeriod fillPer)
            //
            // dependentsPtr (thePart, fillPer) is the Ptr to 
            // dependents    (thePart, fillPer).
         {
         return (WitPartPerStack * &) dependentsPtrTl_ (thePart, fillPer);
         }

d221 1
a221 1
      WitSchedule (WitPart, WitTlObjPtr) dependentsPtrTl_;
d223 2
a224 1
         // Data for dependentsPtr (Part *, Period).
@


1.13
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d19 1
a19 1
#include <PairSt.h>
@


1.12
log
@Refactoring for selection splitting.
@
text
@d238 1
a238 1
      WitSchedule (WitPart, WitTlPtr) dependentsPtrTl_;
@


1.11
log
@Continued implementation of selection splitting with the new design.
@
text
@d40 2
a41 2
            WitProdRtr *  theProdRtr,
            WitConsRtr *  theConsRtr);
d44 2
a45 2
         // myProdRtr   <-- theProdRtr.
         // myConsRtr_  <-- theConsRtr.
d218 1
a218 1
      WitProdRtr * const myProdRtr_;
d220 1
a220 1
         // The ProdRtr associated with this RtAnalyzer.
d222 1
a222 1
      WitConsRtr * const myConsRtr_;
d224 1
a224 1
         // The ConsRtr associated with this RtAnalyzer.
@


1.10
log
@Coarse selection splitting.
@
text
@d57 1
a57 5
      void analyzeRoutings (
            WitPart *            thePart, 
            WitPeriod            thePer,
            WitBopEntPerStack &  modBopEntPers,
            WitConsEntPerStack & modConsEntPers);
d59 3
a61 7
         // Analyzes the routings:
         // Determines which modifications should be made to the current routing
         // in order to fill an infinitesimal incremental requirement for 
         // thePart in thePer at a heuristically minimal exec penalty. On
         // return, modBopEntPers and modConsEntPers are the set of
         // (BOP entry, Period)s and (Cons entry, Period)s to which the routing
         // is to be modified.
d198 1
a198 1
      void printAnaHead  (WitPart *, WitPeriod);
@


1.9
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d38 4
a41 1
      WitRtAnalyzer (WitMrMgr * theMrMgr, WitSelector * theSelector);
a42 1
         // myMrMgr_    <-- theMrMgr.
d44 2
d222 5
a226 1
      WitMrMgr * const myMrMgr_;
d228 1
a228 1
         // The MrMgr that owns this RtAnalyzer.
d230 1
a230 1
      WitSelector * const mySelector_;
d232 1
a232 1
         // The Selector associated with this RtAnalyzer.
@


1.8
log
@Further development of coarse selection splitting.
@
text
@d148 1
a148 2
            WitConsEntPerStack & modConsEntPers,
            WitPeriod            fillPer);
@


1.7
log
@Further development of coarse selection splitting.
@
text
@d19 1
a19 1
#include <Stack.h>
@


1.6
log
@Some minor modifications.
@
text
@d239 1
a239 1
      WitSchedule (WitPart, WitTypelessPtr) dependentsPtrTl_;
@


1.5
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d19 1
a19 1
#include <DynStack.h>
d130 4
a133 4
            WitPart *                      fillPart, 
            WitPeriod                      fillPer, 
            WitPeriod &                    expPer, 
            WitObjDynStack (WitBopEntry) & expBopEnts);
@


1.4
log
@Refactoring for selection splitting.
@
text
@d54 4
a57 4
            WitPart *               thePart, 
            WitPeriod               thePer,
            WitBopEntPerDynStack &  modBopEntPers,
            WitConsEntPerDynStack & modConsEntPers);
d73 1
a73 1
         // Only valid in path-counting mode.
d119 4
a122 4
            WitPart *               fillPart,
            WitPeriod               fillPer, 
            WitBopEntPerDynStack &  modBopEntPers,
            WitConsEntPerDynStack & modConsEntPers);
d146 4
a149 4
            WitBopEntry *           theBopEnt, 
            WitPeriod               expPer,
            WitConsEntPerDynStack & modConsEntPers,
            WitPeriod               fillPer);
d155 3
a157 3
            WitBomEntry *           theBomEnt, 
            WitPeriod               execPer,
            WitConsEntPerDynStack & modConsEntPers);
d180 1
a180 3
      inline WitPartPerDynStack & dependents (
               WitPart * thePart,
               WitPeriod fillPer)
d188 1
a188 1
      inline WitPartPerDynStack * & dependentsPtr (
d195 1
a195 1
         return (WitPartPerDynStack * &) dependentsPtrTl_ (thePart, fillPer);
d200 1
a200 1
      // Only valid if printMode_ is TRUE.
d209 1
a209 3
      void printMods (
         const WitBopEntPerDynStack &,
         const WitConsEntPerDynStack &);
d235 1
a235 1
      WitPartPerDynStack toPreAn_;
d248 1
a248 1
      WitPartPerDynStack toAnalyze_;
@


1.3
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d81 1
a81 3
      copyCtorAndAssignment (WitRtAnalyzer);
         //
         // Prevents unintentional copying and assignment.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d19 1
a19 1
#include <DynPer.h>
d54 4
a57 4
            WitPart *                       thePart, 
            WitPeriod                       thePer,
            WitDynPerStack (WitBopEntry) &  modBopEntPers,
            WitDynPerStack (WitConsEntry) & modConsEntPers);
d121 4
a124 4
            WitPart *                       fillPart,
            WitPeriod                       fillPer, 
            WitDynPerStack (WitBopEntry) &  modBopEntPers,
            WitDynPerStack (WitConsEntry) & modConsEntPers);
d132 4
a135 4
            WitPart *                   fillPart, 
            WitPeriod                   fillPer, 
            WitPeriod &                 expPer, 
            WitDynStack (WitBopEntry) & expBopEnts);
d148 4
a151 4
            WitBopEntry *                   theBopEnt, 
            WitPeriod                       expPer,
            WitDynPerStack (WitConsEntry) & modConsEntPers,
            WitPeriod                       fillPer);
d157 3
a159 3
            WitBomEntry *                   theBomEnt, 
            WitPeriod                       execPer,
            WitDynPerStack (WitConsEntry) & modConsEntPers);
d182 1
a182 1
      inline WitDynPerStack (WitPart) & dependents (
d192 1
a192 1
      inline WitDynPerStack (WitPart) * & dependentsPtr (
d199 1
a199 2
         return 
            (WitDynPerStack (WitPart) * &) dependentsPtrTl_ (thePart, fillPer);
d213 3
a215 3
      void printMods     (
         const WitDynPerStack (WitBopEntry) &,
         const WitDynPerStack (WitConsEntry) &);
d241 1
a241 1
      WitDynPerStack (WitPart) toPreAn_;
d254 1
a254 1
      WitDynPerStack (WitPart) toAnalyze_;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

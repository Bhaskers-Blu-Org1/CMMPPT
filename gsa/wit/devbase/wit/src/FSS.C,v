head	1.81;
access;
symbols
	sce_5_01_20080919:1.75
	latest_sce_4_20_20060523:1.61.0.2
	sce_4_20_20060523:1.61
	latest_sce4_20_OSL:1.60.0.2
	sce_4_20_OSL:1.60
	sce_410_withVa:1.59
	sce_4_05_20040511:1.57
	sce_4_00_20040201:1.42
	nextGenBranch:1.38.0.2
	nextGenRoot:1.38
	sce_3_30_20030627:1.37
	EndRw-branch:1.31.0.4
	Root-of-EndRw:1.31
	rwToStl:1.31.0.2
	latest_sce_3_10_20010924:1.16.0.2
	sce_3_10_20010924:1.16
	latest_sce_3_00_20010601:1.14.0.4
	sce_3_00_20010601:1.14
	latest_sce_2_31_20010308:1.14.0.2
	sce_2_31_20010308:1.14
	latest_sce_2_31_20001003:1.9.0.2
	sce_2_31_20001003:1.9
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.81
date	2011.09.28.23.49.21;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2011.09.24.00.27.39;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2011.08.30.20.17.29;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2010.09.17.22.20.52;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2010.09.10.22.10.38;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2010.03.16.22.42.24;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.14.17.18.54;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.08.18.26.08;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.24.18.52.21;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.22.20.44.25;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.14.19.05.39;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.14.16.18.38;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.11.20.43.55;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.02.28.20.04.55;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.02.27.19.59.30;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.02.10.00.08.13;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.08.22.47.34;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.02.08.00.14.25;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.01.09.19.14.14;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.02.17.33.58;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.28.20.14.35;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.02.03.21.20.28;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.04.30.23.27.43;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.24.22.21.29;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.23.19.14.23;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.22.16.37.18;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.05.22.19.58;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.04.16.44.29;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.03.22.13.05;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.03.20.05.06;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.03.19.07.27;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.20.15.37.35;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.11.18.29.12;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.01.20.53.59;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.25.23.49.55;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.23.21.23.20;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.23.18.12.33;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.19.16.48.16;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.23.20.47.16;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.02.23.40.39;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.02.22.18.26;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.30.20.37.25;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.10.07.21.46.35;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.11.18.53.07;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.06.18.53.37;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.05.21.19.58;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.05.19.31.30;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.04.23.07.19;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.03.22.35.17;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.03.16.01.47;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.29.14.32.39;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.07.20.14.55;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.03.23.16.37;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.01.14.25.54;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.22.14.32.07;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.18.14.02.32;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.28.00.12.57;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.18.50.56;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.20.20.07.03;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.15.19.01.49;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.28.22.13.35;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.22.16.18.25;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.05.19.05.29;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.21.20.03.22;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.25.20.12.31;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.29.21.22.43;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.18.00.15.58;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.25.19.17.44;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.24.19.55.21;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.21.17.42.48;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.30;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.46;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches;
next	;


desc
@@


1.81
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "FSS.C"
//
// Contains the implemention of the following classes:
//
// FSS.
// FssMrpExp.
//------------------------------------------------------------------------------

#include <FSS.h>
#include <FssMrp.h>
#include <Post.h>
#include <GlobalComp.h>
#include <Material.h>
#include <Demand.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <BoundSet.h>
#include <Timing.h>
#include <Variant.h>
#include <MsgFac.h>
#include <ObjStack.h>

//------------------------------------------------------------------------------
// Implementation of class FSS.
//
// Class FSS is responsible for computing the Focussed Shortage Schedule.
// This is done by the compute member function.
//
// The focus data consists of either:
//    the focus horizons (theDemand->focusHorizon (), for each Demand), or
//    the FSS shipment schedule (theDemand->fssShipVol () for each Demand).
// If myGlobalComp ()->useFocusHorizons () is true, then, as a preliminary step,
// compute computes the FSS shipment schedule automatically, based on
// the focus horizons. Otherwise, the FSS shipment schedule is assumed to be
// user-specified.
//
// The Focussed Shortage Schedule is computed by defining a certain MRP
// problem, invoking WIT-MRP on it and taking the resulting requirements
// schedule as the Focussed Shortage Schedule. The input for the MRP is defined
// by the incremental availability schedule for the MRP: mrpIncAvail. Positive
// values of mrpIncAvail (thePart, thePer) are interpreted as supply for
// thePart;
// negative values are interpreted as demand for it. An instance of class
// WitFssMrpExp is created and its mrp function is called, causing it to
// perform MRP, using mrpIncAvail for its supply and demand and storing the
// resulting requirement schedule back in FSS.
//
// Note: for purposes of defining the MRP problem for FSS, there is no need
// to distinguish between multiple demands for the same part, so things like
// demand schedules and shipment schedules are defined for Parts instead of
// Demands.
//
// To define the MRP problem, an "unimplosion" problem is defined, an
// unimplosion is performed on it and then the MRP problem is defined from the
// result. (Unimplosion is defined below.) The data for the unimplosion problem
// is the same as the data from the original implosion problem and its
// solution, except that the shipment schedule is replaced by the "achieved FSS
// shipment schedule", defined for any Part in any period as:
//
//    achFssShipVol[thePer] = min (fssShipVol[thePer], shipVol[thePer])
//
// This is the amount of the fssShipVol that was achieved by the implosion
// shipment schedule. The rest of the shipment schedule is initially
// discarded as scrap. This scrap constitutes over-production in the implosion
// solution relative to the FSS shipment schedule. The task of unimplosion is
// to undo this over-production wherever possible, so as to free up the
// resources that were consumed for over-production and make them available to
// the FSS MRP.
//
// The unimplosion algorithm is a heuristic for doing this. It works roughly
// like an MRP explosion with negative demand. In the spirit of MRP, JIT, the
// WIT implosion heuristic, etc., the idea is to produce as little as possible
// and as late as possible, while still meeting demands (in this case, the
// achieved FSS shipment schedule). For unimplosion, this implies reducing
// production ("unimploding") as much as possible and as early as possible.
// The Operations are examined in reverse order. A Operation, uiOpn will
// be unimploded only if:
//
//    It's non-coproducing
//    Its BOP contains a Part (uiPart) with significantly positive productRate.
//       (thePart will be unique.)
//
// If uiPart is a Material, the scrap for thePart in all periods is rolled back
// as early in time as possible to make it available for early unimplosion. The
// execution periods, execPer, for uiOpn are then considered in order. If
// uiPart is a Material, the scrap from any previous period is rolled forward to
// the impactPeriod
// for execPer. Then deltaExecVol is computed, the maximum possible reduction in
// uiOpn's execVol such that uiPart's scrapVol will remain
// nonnegative and there will be no increased violation of uiOpn's
// execution lower bound. (FSS is allowed to violate lower bounds on execution,
// but by no more than the amount (if any) by which the implosion solution does
// so. Thus the lower bound for FSS purposes is:
// min (exec softLB[thePer], execVol[thePer]).) The scrapVols of uiPart and
// Parts in the BOM are updated accordingly. If a BomEntry has substitutes, the
// reduction in execution must be allocated among them. The reduction volume is
// allocated to the subs for theBomEnt in reverse preference order, so that
// the higher preference subs tend to keep their subVols.
//
// After the unimplosion is performed, several schedules can be computed,
// leading up to the computation of mrpIncAvail, which defines the FSS MRP.
// First is the non-supply incremental availability schedule, nonSupIncAvail.
// For any Material, nonSupIncAvail[thePer] is the change in availability of the
// Material in thePer, excluding supply. It is computed as:
//
// nonSupIncAvail   [thePer] =
//      scrapVol    [thePer]
//    + (stockVol   [thePer]     - fssStockLB[thePer])
//    - (stockVol   [thePer - 1] - fssStockLB[thePer - 1])
//    - supplyVol ()[thePer]
//
// If we ignore the "fssStockLB" terms and the supplyVol term, we just have
// the normal formula for incremental availability. The supplyVol term is the
// necessary adjustment to exclude supply.
//
// The two "fssStockLB" terms reflect the fact that FSS will not violate stock
// lower bounds any more than the implosion solution did. This implies a stock
// lower bound for FSS purposes of:
//
//    fssStockLB[thePer] = min (stock softLB[thePer], stockVol[thePer])
//
// Thus in thePer, only (stockVol[thePer] - fssStockLB[thePer]) units of stock
// are actually available, and this explains the two fssStockLB terms.
//
// nonSupIncAvail is used to compute the minimum supply availability schedule,
// minSupAvail. For any Material, minSupAvail[thePer] is the availability of the
// Material in thePer, using the minumum possible supply to insure
// availability is non-negative. It is computed as:
//
// minSupAvail[-1] = 0
//
// For each period, t:
//
//   minSupAvail[thePer] = 
//      positive part of (minSupAvail[thePer - 1] + nonSupIncAvail[thePer])
//
// minSupAvail is used to compute the supply consumption schedule,
// supplyConsVol. For any Material, supplyConsVol[thePer] is the amount of
// supply of the Material that is consumed in thePer. It is computed as:
//
//   supplyConsVol[thePer] = 
//      negative part of (minSupAvail[thePer - 1] + nonSupIncAvail[thePer])
//
// In other words, any time (minSupAvail[thePer - 1] + nonSupIncAvail[thePer]) 
// is
// negative, - (minSupAvail[thePer - 1] + nonSupIncAvail[thePer]) units of
// supply are
// being consumed in order to keep availability (minSupAvail) from going 
// negative.
//
// Finally, once supplyConsVol has been computed, mrpIncAvail is computed as
// follows:
//
// mrpIncAvail[thePer] =
//      supplyVol ()[thePer]
//    - supplyConsVol[thePer]
//    - (fssShipVol[thePer] - achFssShipVol)
//
// In other words, the original supply is nominally available to the FSS MRP,
// but any time supply is consumed by the (unimploded) implosion solution, that
// consumption is accounted for in the FSS MRP, either by reducing supply
// (when mrpIncAvail[thePer] >= 0) or increasing demand (when 
// mrpIncAvail[thePer] < 0).
// The other demand term, (fssShipVol[thePer] - achFssShipVol) (which is always
// >= 0), is the part of fssShipVol that is not achieved by the implosion
// solution.
//
// Note that by putting supply into the FSS MRP in the period in which it is
// actually supplied (with supplyVol) and then taking it back out in the period
// in which it is consumed (with supplyConsVol), the FSS MRP is being given
// access to the invervening stocks of supply. This allows FSS to report
// shortages in later periods than would otherwise be possible, while still
// satisfying the "feasibility" requirement of FSS.
//
// The above describes how mrpIncAvail is computed in principle; in practice,
// the computation is streamlined in a number of ways:
//
// * shipVol and fssShipVol for Materials (rather than Demands) are not
//   explicitly maintained.
// * achFssShipVol is not explicitly maintained.
// * unimplosion only maintains a scrap schedule and a stock schedule,
//   called uiScrapVol_ and uiStockVol_. The production schedule itself doesn't
//   need to be maintained.
// * nonSupIncAvail is not explicitly stored.
// * minSupAvail and supplyConsVol are only computed for the current Material
//   and period and are not stored away as schedules.
//------------------------------------------------------------------------------

WitFSS::WitFSS (WitProblem * theProblem):
      WitProbAssoc   (theProblem),

      computed_      (false),
      uploadingSoln_ (false),
      fssExecVol_    (),
      fssSubVol_     ()
   {
   }

//------------------------------------------------------------------------------

WitFSS::~WitFSS ()
   {
   }

//------------------------------------------------------------------------------
// compute.
// Computes the Focussed Shortage Schedule.
// The following approach is used:
// New supply and demand schedules are computed, based on the implosion
//    solution and the focus.
// MRP is invoked on the new supply and demand schedules.
// The resulting requirements schedule is stored as the Focussed Shortage
// Schedule.
//------------------------------------------------------------------------------

void WitFSS::compute ()
   {
   WitDemand * theDemand;

   WitTimer::enterSection ("fss");

   if (not myPostprocessor ()->postprocessed ())
      myMsgFac () ("unpostprocessedFssSmsg");

   if (not myProblem ()->currentVariant ()->internalSoln ())
      myMsgFac () ("fssWithUserSolnSmsg");

   myMsgFac () ("compFSSMsg");

   if (myGlobalComp ()->useFocusHorizons ())
      forEachDemand (theDemand, myProblem ())
         theDemand->compFssShipVol ();

   initSoln ();

   defineMrp ();

   doMrp ();

   fssExecVol_.clear ();
   fssSubVol_ .clear ();

   computed_ = true;

   WitTimer::leaveSection ("fss");
   }

//------------------------------------------------------------------------------
// compFssShipVol ()
//
// Local Variables:
//
// cumShipVolThePer:      Cumulative shipment volume in thePer.
// cDFHorizon:            Cumulative demand volume at the focus horizon of
//                        theDemand
// cumFssShipVolT:        Cumulative of fssShipVol ()[thePer].
// cumFssShipVolThePer_1: Cumulative of fssShipVol ()[thePer - 1].
//------------------------------------------------------------------------------

void WitFSS::compFssShipVol (
      WitDemand *     theDemand,
      WitDblFlexVec & fssShipVolRef)
   {
   double      cumShipVolThePer;
   double      cDFHorizon;
   WitPeriod   thePer;
   double      cumFssShipVolThePer;
   double      cumFssShipVolThePer_1;

   witAssert (myGlobalComp ()->useFocusHorizons ());

   cumShipVolThePer = 0.0;

   cDFHorizon =
      (theDemand->focusHorizon () >= 0)?
         theDemand->cumDemandVol ()[theDemand->focusHorizon ()]:
         0.0;

   cumFssShipVolThePer = 0.0;

   forEachPeriod (thePer, myProblem ())
      {
      cumShipVolThePer += theDemand->shipVol ()[thePer];

      cumFssShipVolThePer_1 = cumFssShipVolThePer;

      cumFssShipVolThePer =
         (thePer <= theDemand->focusHorizon ())?
            theDemand->cumDemandVol ()[thePer]:
            max (cDFHorizon, cumShipVolThePer);

      fssShipVolRef.elemRef (thePer) =
         cumFssShipVolThePer - cumFssShipVolThePer_1;
      }
   }

//------------------------------------------------------------------------------

double WitFSS::mrpSupplyVol (WitPart * thePart, WitPeriod thePer) const
   {
   return positivePart (mrpIncAvail_ (thePart)[thePer]);
   }

//------------------------------------------------------------------------------

double WitFSS::mrpDemandVol (WitPart * thePart, WitPeriod thePer) const
   {
   return positivePart (- mrpIncAvail_ (thePart)[thePer]);
   }

//------------------------------------------------------------------------------

void WitFSS::uncompute ()
   {
   computed_ = false;
   }

//------------------------------------------------------------------------------

void WitFSS::initSoln ()
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   fssExecVol_.allocate (myProblem (), 0.0);
   fssSubVol_ .allocate (myProblem (), 0.0);

   forEachOperation (theOpn, myProblem ())
      fssExecVol_ (theOpn) = theOpn->execVol ();

   forEachSubEntry (theSub, myProblem ())
      fssSubVol_  (theSub) = theSub->subVol ();
   }

//------------------------------------------------------------------------------

void WitFSS::defineMrp ()
   {
   uiScrapVol_.allocate (myProblem (), 0.0);
   uiStockVol_.allocate (myProblem (), 0.0);

   defineUnimplode ();

   unimplode ();

   compMrpIncAvail ();

   uiScrapVol_.clear ();
   uiStockVol_.clear ();
   }

//------------------------------------------------------------------------------

void WitFSS::defineUnimplode ()
   {
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;
   int           maxNSubs;
   WitBomEntry * theBomEnt;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         uiScrapVol_ (thePart)[thePer] = thePart->scrapVol ()[thePer] +
            positivePart (- deltaFssShipVol (thePart, thePer));
               //
               // shipVol - achFssShipVol
               // Scrapping any shipVol that's in excess of achFssShipVol.
               // This causes unimplosion to be performed relative to
               // achFssShipVol.

         if (uiScrapVol_ (thePart)[thePer] < 0.0)
             uiScrapVol_ (thePart)[thePer] = 0.0;
             //
             // A negative scrapVol is a constraint violation that is
             // presumed to be an insignificant numerical error and therefore
             // ignored.
         }

   forEachMaterial (theMat, myProblem ())
      uiStockVol_ (theMat) = theMat->stockVol ();

   maxNSubs = 0;

   forEachBomEntry (theBomEnt, myProblem ())
      setToMax (maxNSubs, theBomEnt->mySubEntries ().nElements ());
   }

//------------------------------------------------------------------------------

double WitFSS::deltaFssShipVol (WitPart * thePart, WitPeriod thePer)
   {
   WitDemand * theDemand;
   double      delta;

   delta = 0.0;

   forEachEl (theDemand, thePart->myDemands ())
      delta +=
         theDemand->fssShipVol ()[thePer] -
         theDemand->shipVol    ()[thePer];

   return delta;
   }

//------------------------------------------------------------------------------
// unimplode.
//
// deltaExecVol is the amount by which an execVol will be reduced.
//------------------------------------------------------------------------------

void WitFSS::unimplode ()
   {
   WitOperation * uiOpn;
   bool           isCoprod;
   WitBopEntry *  uiBopEnt;
   WitPart *      uiPart;
   WitMaterial *  uiMat;
   WitPeriod      execPer;
   WitPeriod      scrapPer;
   WitBopEntry *  theBopEnt;

   WitObjStack <WitOperation> reversedOpns (myProblem ());

   revCopyInto (reversedOpns, myCompMgr ()->allOperations ());

   while (reversedOpns.pop (uiOpn))
      {
      isCoprod = false;

      forEachPeriod (execPer, myProblem ())
         if (uiOpn->isCoproducing (execPer))
            isCoprod = true;

      if (isCoprod)
         continue;

      uiBopEnt = NULL;

      forEachEl (theBopEnt, uiOpn->bop ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->productRate ()[execPer] > 0.0)
               {
               uiBopEnt = theBopEnt;

               break;
               }

      if (uiBopEnt == NULL)
         continue;

      uiPart = uiBopEnt->myPart ();

      uiMat  = uiPart->thisMat ();

      if (uiMat != NULL)
         uiMat->rollBackScrap (uiStockVol_ (uiMat), uiScrapVol_ (uiMat));

      scrapPer = 0;

      forEachPeriod (execPer, myProblem ())
         unimplode (uiOpn, uiBopEnt, uiPart, execPer, scrapPer);
      }
   }

//------------------------------------------------------------------------------

void WitFSS::unimplode (
      WitOperation * uiOpn,
      WitBopEntry *  uiBopEnt,
      WitPart *      uiPart,
      WitPeriod      execPer,
      WitPeriod &    scrapPer)
   {
   WitPeriod     prodPer;
   WitMaterial * uiMat;
   double        deltaExecVol;
   double        oldExecVol;

   if (uiBopEnt->effProdRate ()[execPer] < .01)
      return;

   deltaExecVol =
      positivePart (
         + fssExecVol_ (uiOpn)[execPer]
         - uiOpn->execBounds ()->softLB ()[execPer]);

   if (deltaExecVol < FLOAT_EPSILON)
      return;

   prodPer = uiBopEnt->impactPeriod ()[execPer];

   uiMat   = uiPart->thisMat ();

   if (uiMat != NULL)
      rollOverScrap (uiMat, scrapPer, prodPer);

   setToMin (
      deltaExecVol,
      uiScrapVol_ (uiPart)[prodPer] / uiBopEnt->effProdRate ()[execPer]);

   if (deltaExecVol < FLOAT_EPSILON)
      return;

   oldExecVol   = fssExecVol_ (uiOpn)[execPer];

   deltaExecVol = - uiOpn->lotSizeDelta (execPer, oldExecVol, - deltaExecVol);

   if (deltaExecVol < FLOAT_EPSILON)
      return;

   fssExecVol_ (uiOpn)[execPer] -= deltaExecVol;

   if (uiBopEnt->inEffect (execPer))
      uiScrapVol_ (uiPart)[prodPer] -=
         deltaExecVol * uiBopEnt->effProdRate ()[execPer];

   unimplodeBom (uiOpn, execPer, deltaExecVol);
   }

//------------------------------------------------------------------------------

void WitFSS::rollOverScrap (
      WitMaterial * theMat,
      WitPeriod &   scrapPer,
      WitPeriod     prodPer)
   {
   double carryOver;
      //
      // Scrap volume carried over as stock from thePer - 1 to thePer.

   double maxStockInc;
      //
      // The amount by which stockVol can be increased without violating its
      // hardUB.

   while (scrapPer < prodPer)
      {
      ++ scrapPer;

      if (not theMat->canStock (scrapPer - 1))
         continue;

      carryOver = uiScrapVol_ (theMat)[scrapPer - 1];

      if (theMat->stockBounds ()->hardUBIsFinite (scrapPer - 1))
         {
         maxStockInc =
            positivePart (
               + theMat->stockBounds ()->hardUB ()[scrapPer - 1]
               - uiStockVol_ (theMat)[scrapPer - 1]);

         carryOver = min (carryOver, maxStockInc);
         }

      if (carryOver <= FLOAT_EPSILON)
         continue;

      uiScrapVol_ (theMat)[scrapPer - 1] -= carryOver;
      uiStockVol_ (theMat)[scrapPer - 1] += carryOver;
      uiScrapVol_ (theMat)[scrapPer]     += carryOver;
      }
   }

//------------------------------------------------------------------------------

void WitFSS::unimplodeBom (
      WitOperation * uiOpn,
      WitPeriod      execPer,
      double         deltaExecVol)
   {
   WitBomEntry * theBomEnt;
   WitPeriod     consPer;

   forEachEl (theBomEnt, uiOpn->bom ())
      if (theBomEnt->inEffect (execPer))
         {
         consPer = theBomEnt->impactPeriod ()[execPer];

         uiScrapVol_ (theBomEnt->myPart ())[consPer] +=
            deltaExecVol * theBomEnt->effConsRate ()[execPer];

         unimplodeSubs (theBomEnt, execPer, deltaExecVol);
         }
   }

//------------------------------------------------------------------------------
// unimplodeSubs.
// Reduces the subs for theBomEnt in thePer for a reduction of
// deltaExecVol in the execVol of theBomEnt->myOperation ().
//
// The reduction volume is allocated to the subs for theBomEnt in decreasing
// aversion order, so that the highest aversion subs are unimploded first.
//------------------------------------------------------------------------------

void WitFSS::unimplodeSubs (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol)
   {
   WitSubEntry * theSub;      // SubEntry being unimploded.
   double        unallocVol;  // The amount of deltaExecVol that has not yet
                              // been allocated to any Sub for a particular
                              // bomEntry.
   double        deltaSubVol; // The amount of deltaExecVol allocated to a
                              // particular sub.
   WitPeriod     consPer;     // Consumption period.

   unallocVol = deltaExecVol;
   consPer    = theBomEnt->impactPeriod ()[execPer];


   WitObjStack <WitSubEntry> reversedSubEntries (myProblem ());
      //
      // The Subs for theBomEnt, in reverse order.

   revCopyInto (reversedSubEntries, theBomEnt->mySubEntries ());

   while (reversedSubEntries.pop (theSub))
      {
      if (not theSub->inEffect (execPer))
         continue;

      if (fssSubVol_ (theSub)[execPer] < FLOAT_EPSILON)
         continue;

      if (fssSubVol_ (theSub)[execPer] < unallocVol)
         {
         deltaSubVol = fssSubVol_ (theSub)[execPer];

         fssSubVol_ (theSub)[execPer] = 0.0;

         unallocVol -= deltaSubVol;
         }
      else
         {
         deltaSubVol = unallocVol;

         fssSubVol_ (theSub)[execPer] -= deltaSubVol;

         unallocVol = 0.0;
         }

      uiScrapVol_ (theSub->myPart ())[consPer] +=
         deltaSubVol * theSub->effConsRate ()[execPer];

      if (unallocVol < FLOAT_EPSILON)
         break;
      }
   }

//------------------------------------------------------------------------------

void WitFSS::compMrpIncAvail ()
   {
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;

   double uiStockVolThePer_1;
      //
      // uiStockVol_[thePer - 1], or 0.0, if thePer == 0.

   double fssStockLBThePer_1;
      //
      // Lower bound on stockVol for a material in thePer - 1 for FSS purposes.

   double fssStockLBThePer;
      //
      // Lower bound on stockVol for a material in thePer for FSS purposes.

   double minSupAvail;
      //
      // Minimum supply availability.
      // The availability of theMat in thePer, using the minumum
      // necessary supply. When this becomes negative, supply is consumed to
      // compensate make it zero.

   double supplyConsVol;
      //
      // Supply Consumption volume for theMat in thePer.

   //--------------------------------------------------------------------------

   mrpIncAvail_.allocate (myProblem (), 0.0);

   forEachPart (thePart, this)
      if (thePart->thisCap () != NULL)
         mrpIncAvail_ (thePart) = uiScrapVol_ (thePart);

   forEachMaterial (theMat, myProblem ())
      {
      fssStockLBThePer = 0.0;
      minSupAvail      = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         uiStockVolThePer_1 =
            (thePer > 0)?
               uiStockVol_ (theMat)[thePer - 1]:
               0.0;

         fssStockLBThePer_1 = fssStockLBThePer;

         fssStockLBThePer =
            min (
               theMat->stockBounds ()->softLB ()[thePer],
               theMat->stockVol ()[thePer]);
                  //
                  // Note that the actual stockVol (and not uiStockVol_) is
                  // appropriate for defining FSS Stock LB.

         minSupAvail +=
            + uiScrapVol_ (theMat)[thePer]
            + uiStockVol_ (theMat)[thePer]
            - fssStockLBThePer
            - uiStockVolThePer_1
            + fssStockLBThePer_1
            - theMat->supplyVol ()[thePer];

         if (minSupAvail < - FLOAT_EPSILON)
            {
            supplyConsVol = - minSupAvail;
            minSupAvail   = 0.0;
            }
         else supplyConsVol = 0.0;

         mrpIncAvail_ (theMat)[thePer] =
            theMat->supplyVol ()[thePer] - supplyConsVol;
         }
      }

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         mrpIncAvail_ (thePart)[thePer] -=
            positivePart (deltaFssShipVol (thePart, thePer));
               //
               // fssShipVol - achFssShipVol
   }

//------------------------------------------------------------------------------

void WitFSS::doMrp ()
   {
   WitFssMrpExp
      theFssMrpExp (
         myProblem (),
         this,
         uploadingSoln_,
         fssExecVol_,
         fssSubVol_);

   theFssMrpExp.mrp ();

   mrpIncAvail_.clear ();
   }

//------------------------------------------------------------------------------
// Implementation of class FssMrpExp.
//------------------------------------------------------------------------------

WitFssMrpExp::WitFssMrpExp (
         WitProblem *                         theProblem,
         WitFSS *                             theFSS,
         bool &                               uploadingSolnArg,
         WitSchedule <WitOperation, double> & fssExecVolArg,
         WitSchedule <WitSubEntry,  double> & fssSubVolArg):

      WitMrpExp      (theProblem),

      myFSS_         (theFSS),
      uploadingSoln_ (uploadingSolnArg),
      fssExecVol_    (fssExecVolArg),
      fssSubVol_     (fssSubVolArg)
   {
   }

//------------------------------------------------------------------------------

WitFssMrpExp::~WitFssMrpExp ()
   {
   }

//------------------------------------------------------------------------------

double WitFssMrpExp::supplyVol (WitPart * thePart, WitPeriod thePer) 
   {
   return myFSS_->mrpSupplyVol (thePart, thePer);
   }

//------------------------------------------------------------------------------

double WitFssMrpExp::demandVol (WitPart * thePart, WitPeriod thePer)
   {
   return myFSS_->mrpDemandVol (thePart, thePer);
   }

//------------------------------------------------------------------------------

double & WitFssMrpExp::execVol (WitOperation * theOpn, WitPeriod thePer)
   {
   return fssExecVol_ (theOpn)[thePer];
   }

//------------------------------------------------------------------------------

double & WitFssMrpExp::subVol (WitSubEntry * theSub, WitPeriod thePer)
   {
   return fssSubVol_ (theSub)[thePer];
   }

//------------------------------------------------------------------------------

void WitFssMrpExp::finishDerived ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   uploadingSoln_ = true;

   forEachPart (thePart, myProblem ())
      thePart->storeFssFocShortageVol (myReqVol () (thePart));

   forEachOperation (theOpn, myProblem ())
      theOpn->storeFssFssExecVol      (fssExecVol_ (theOpn));

   forEachSubEntry (theSub, myProblem ())
      theSub->storeFssFssSubVol       (fssSubVol_  (theSub));

   uploadingSoln_ = false;
   }
@


1.80
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.79
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d145 1
a145 1
//   minSupAvail[thePer] =
d152 1
a152 1
//   supplyConsVol[thePer] =
d155 1
a155 1
// In other words, any time (minSupAvail[thePer - 1] + nonSupIncAvail[thePer])
d159 1
a159 1
// being consumed in order to keep availability (minSupAvail) from going
d173 1
a173 1
// (when mrpIncAvail[thePer] >= 0) or increasing demand (when
d201 1
a201 1
WitProbAssoc   (theProblem),
d203 6
a208 6
computed_      (false),
uploadingSoln_ (false),
fssExecVol_    (),
fssSubVol_     ()
{
}
d213 2
a214 2
{
}
d228 2
a229 2
{
WitDemand * theDemand;
d231 1
a231 1
WitTimer::enterSection ("fss");
d233 2
a234 2
if (not myPostprocessor ()->postprocessed ())
myMsgFac () ("unpostprocessedFssSmsg");
d236 2
a237 2
if (not myProblem ()->currentVariant ()->internalSoln ())
myMsgFac () ("fssWithUserSolnSmsg");
d239 1
a239 1
myMsgFac () ("compFSSMsg");
d241 3
a243 3
if (myGlobalComp ()->useFocusHorizons ())
forEachDemand (theDemand, myProblem ())
theDemand->compFssShipVol ();
d245 1
a245 1
initSoln ();
d247 1
a247 1
defineMrp ();
d249 1
a249 1
doMrp ();
d251 2
a252 2
fssExecVol_.clear ();
fssSubVol_ .clear ();
d254 1
a254 1
computed_ = true;
d256 2
a257 2
WitTimer::leaveSection ("fss");
}
d272 35
a306 35
WitDemand *     theDemand,
WitDblFlexVec & fssShipVolRef)
{
double      cumShipVolThePer;
double      cDFHorizon;
WitPeriod   thePer;
double      cumFssShipVolThePer;
double      cumFssShipVolThePer_1;

witAssert (myGlobalComp ()->useFocusHorizons ());

cumShipVolThePer = 0.0;

cDFHorizon =
(theDemand->focusHorizon () >= 0)?
theDemand->cumDemandVol ()[theDemand->focusHorizon ()]:
0.0;

cumFssShipVolThePer = 0.0;

forEachPeriod (thePer, myProblem ())
{
cumShipVolThePer += theDemand->shipVol ()[thePer];

cumFssShipVolThePer_1 = cumFssShipVolThePer;

cumFssShipVolThePer =
(thePer <= theDemand->focusHorizon ())?
theDemand->cumDemandVol ()[thePer]:
max (cDFHorizon, cumShipVolThePer);

fssShipVolRef.elemRef (thePer) =
cumFssShipVolThePer - cumFssShipVolThePer_1;
}
}
d311 3
a313 3
{
return positivePart (mrpIncAvail_ (thePart)[thePer]);
}
d318 3
a320 3
{
return positivePart (- mrpIncAvail_ (thePart)[thePer]);
}
d325 3
a327 3
{
computed_ = false;
}
d332 13
a344 13
{
WitOperation * theOpn;
WitSubEntry *  theSub;

fssExecVol_.allocate (myProblem (), 0.0);
fssSubVol_ .allocate (myProblem (), 0.0);

forEachOperation (theOpn, myProblem ())
fssExecVol_ (theOpn) = theOpn->execVol ();

forEachSubEntry (theSub, myProblem ())
fssSubVol_  (theSub) = theSub->subVol ();
}
d349 3
a351 3
{
uiScrapVol_.allocate (myProblem (), 0.0);
uiStockVol_.allocate (myProblem (), 0.0);
d353 1
a353 1
defineUnimplode ();
d355 1
a355 1
unimplode ();
d357 1
a357 1
compMrpIncAvail ();
d359 3
a361 3
uiScrapVol_.clear ();
uiStockVol_.clear ();
}
d366 34
a399 34
{
WitPart *     thePart;
WitMaterial * theMat;
WitPeriod     thePer;
int           maxNSubs;
WitBomEntry * theBomEnt;

forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
{
uiScrapVol_ (thePart)[thePer] = thePart->scrapVol ()[thePer] +
positivePart (- deltaFssShipVol (thePart, thePer));
//
// shipVol - achFssShipVol
// Scrapping any shipVol that's in excess of achFssShipVol.
// This causes unimplosion to be performed relative to
// achFssShipVol.

if (uiScrapVol_ (thePart)[thePer] < 0.0)
uiScrapVol_ (thePart)[thePer] = 0.0;
//
// A negative scrapVol is a constraint violation that is
// presumed to be an insignificant numerical error and therefore
// ignored.
}

forEachMaterial (theMat, myProblem ())
uiStockVol_ (theMat) = theMat->stockVol ();

maxNSubs = 0;

forEachBomEntry (theBomEnt, myProblem ())
setToMax (maxNSubs, theBomEnt->mySubEntries ().nElements ());
}
d404 10
a413 10
{
WitDemand * theDemand;
double      delta;

delta = 0.0;

forEachEl (theDemand, thePart->myDemands ())
delta +=
theDemand->fssShipVol ()[thePer] -
theDemand->shipVol    ()[thePer];
d415 2
a416 2
return delta;
}
d425 9
a433 9
{
WitOperation * uiOpn;
bool           isCoprod;
WitBopEntry *  uiBopEnt;
WitPart *      uiPart;
WitMaterial *  uiMat;
WitPeriod      execPer;
WitPeriod      scrapPer;
WitBopEntry *  theBopEnt;
d435 1
a435 1
WitObjStack <WitOperation> reversedOpns (myProblem ());
d437 1
a437 1
revCopyInto (reversedOpns, myCompMgr ()->allOperations ());
d439 3
a441 3
while (reversedOpns.pop (uiOpn))
{
isCoprod = false;
d443 3
a445 3
forEachPeriod (execPer, myProblem ())
if (uiOpn->isCoproducing (execPer))
isCoprod = true;
d447 2
a448 2
if (isCoprod)
continue;
d450 1
a450 1
uiBopEnt = NULL;
d452 5
a456 5
forEachEl (theBopEnt, uiOpn->bop ())
forEachPeriod (execPer, myProblem ())
if (theBopEnt->productRate ()[execPer] > 0.0)
{
uiBopEnt = theBopEnt;
d458 2
a459 2
break;
}
d461 2
a462 2
if (uiBopEnt == NULL)
continue;
d464 1
a464 1
uiPart = uiBopEnt->myPart ();
d466 1
a466 1
uiMat  = uiPart->thisMat ();
d468 2
a469 2
if (uiMat != NULL)
uiMat->rollBackScrap (uiStockVol_ (uiMat), uiScrapVol_ (uiMat));
d471 1
a471 1
scrapPer = 0;
d473 4
a476 4
forEachPeriod (execPer, myProblem ())
unimplode (uiOpn, uiBopEnt, uiPart, execPer, scrapPer);
}
}
d481 10
a490 10
WitOperation * uiOpn,
WitBopEntry *  uiBopEnt,
WitPart *      uiPart,
WitPeriod      execPer,
WitPeriod &    scrapPer)
{
WitPeriod     prodPer;
WitMaterial * uiMat;
double        deltaExecVol;
double        oldExecVol;
d492 2
a493 2
if (uiBopEnt->effProdRate ()[execPer] < .01)
return;
d495 4
a498 4
deltaExecVol =
positivePart (
+ fssExecVol_ (uiOpn)[execPer]
- uiOpn->execBounds ()->softLB ()[execPer]);
d500 2
a501 2
if (deltaExecVol < FLOAT_EPSILON)
return;
d503 1
a503 1
prodPer = uiBopEnt->impactPeriod ()[execPer];
d505 1
a505 1
uiMat   = uiPart->thisMat ();
d507 2
a508 2
if (uiMat != NULL)
rollOverScrap (uiMat, scrapPer, prodPer);
d510 3
a512 3
setToMin (
deltaExecVol,
uiScrapVol_ (uiPart)[prodPer] / uiBopEnt->effProdRate ()[execPer]);
d514 2
a515 2
if (deltaExecVol < FLOAT_EPSILON)
return;
d517 1
a517 1
oldExecVol   = fssExecVol_ (uiOpn)[execPer];
d519 1
a519 1
deltaExecVol = - uiOpn->lotSizeDelta (execPer, oldExecVol, - deltaExecVol);
d521 2
a522 2
if (deltaExecVol < FLOAT_EPSILON)
return;
d524 1
a524 1
fssExecVol_ (uiOpn)[execPer] -= deltaExecVol;
d526 3
a528 3
if (uiBopEnt->inEffect (execPer))
uiScrapVol_ (uiPart)[prodPer] -=
deltaExecVol * uiBopEnt->effProdRate ()[execPer];
d530 2
a531 2
unimplodeBom (uiOpn, execPer, deltaExecVol);
}
d536 40
a575 40
WitMaterial * theMat,
WitPeriod &   scrapPer,
WitPeriod     prodPer)
{
double carryOver;
//
// Scrap volume carried over as stock from thePer - 1 to thePer.

double maxStockInc;
//
// The amount by which stockVol can be increased without violating its
// hardUB.

while (scrapPer < prodPer)
{
++ scrapPer;

if (not theMat->canStock (scrapPer - 1))
continue;

carryOver = uiScrapVol_ (theMat)[scrapPer - 1];

if (theMat->stockBounds ()->hardUBIsFinite (scrapPer - 1))
{
maxStockInc =
positivePart (
+ theMat->stockBounds ()->hardUB ()[scrapPer - 1]
- uiStockVol_ (theMat)[scrapPer - 1]);

carryOver = min (carryOver, maxStockInc);
}

if (carryOver <= FLOAT_EPSILON)
continue;

uiScrapVol_ (theMat)[scrapPer - 1] -= carryOver;
uiStockVol_ (theMat)[scrapPer - 1] += carryOver;
uiScrapVol_ (theMat)[scrapPer]     += carryOver;
}
}
d580 18
a597 18
WitOperation * uiOpn,
WitPeriod      execPer,
double         deltaExecVol)
{
WitBomEntry * theBomEnt;
WitPeriod     consPer;

forEachEl (theBomEnt, uiOpn->bom ())
if (theBomEnt->inEffect (execPer))
{
consPer = theBomEnt->impactPeriod ()[execPer];

uiScrapVol_ (theBomEnt->myPart ())[consPer] +=
deltaExecVol * theBomEnt->effConsRate ()[execPer];

unimplodeSubs (theBomEnt, execPer, deltaExecVol);
}
}
d609 54
a662 54
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol)
{
WitSubEntry * theSub;      // SubEntry being unimploded.
double        unallocVol;  // The amount of deltaExecVol that has not yet
// been allocated to any Sub for a particular
// bomEntry.
double        deltaSubVol; // The amount of deltaExecVol allocated to a
// particular sub.
WitPeriod     consPer;     // Consumption period.

unallocVol = deltaExecVol;
consPer    = theBomEnt->impactPeriod ()[execPer];


WitObjStack <WitSubEntry> reversedSubEntries (myProblem ());
//
// The Subs for theBomEnt, in reverse order.

revCopyInto (reversedSubEntries, theBomEnt->mySubEntries ());

while (reversedSubEntries.pop (theSub))
{
if (not theSub->inEffect (execPer))
continue;

if (fssSubVol_ (theSub)[execPer] < FLOAT_EPSILON)
continue;

if (fssSubVol_ (theSub)[execPer] < unallocVol)
{
deltaSubVol = fssSubVol_ (theSub)[execPer];

fssSubVol_ (theSub)[execPer] = 0.0;

unallocVol -= deltaSubVol;
}
else
{
deltaSubVol = unallocVol;

fssSubVol_ (theSub)[execPer] -= deltaSubVol;

unallocVol = 0.0;
}

uiScrapVol_ (theSub->myPart ())[consPer] +=
deltaSubVol * theSub->effConsRate ()[execPer];

if (unallocVol < FLOAT_EPSILON)
break;
}
}
d667 85
a751 85
{
WitPart *     thePart;
WitMaterial * theMat;
WitPeriod     thePer;

double uiStockVolThePer_1;
//
// uiStockVol_[thePer - 1], or 0.0, if thePer == 0.

double fssStockLBThePer_1;
//
// Lower bound on stockVol for a material in thePer - 1 for FSS purposes.

double fssStockLBThePer;
//
// Lower bound on stockVol for a material in thePer for FSS purposes.

double minSupAvail;
//
// Minimum supply availability.
// The availability of theMat in thePer, using the minumum
// necessary supply. When this becomes negative, supply is consumed to
// compensate make it zero.

double supplyConsVol;
//
// Supply Consumption volume for theMat in thePer.

//--------------------------------------------------------------------------

mrpIncAvail_.allocate (myProblem (), 0.0);

forEachPart (thePart, this)
if (thePart->thisCap () != NULL)
mrpIncAvail_ (thePart) = uiScrapVol_ (thePart);

forEachMaterial (theMat, myProblem ())
{
fssStockLBThePer = 0.0;
minSupAvail      = 0.0;

forEachPeriod (thePer, myProblem ())
{
uiStockVolThePer_1 =
(thePer > 0)?
uiStockVol_ (theMat)[thePer - 1]:
0.0;

fssStockLBThePer_1 = fssStockLBThePer;

fssStockLBThePer =
min (
theMat->stockBounds ()->softLB ()[thePer],
theMat->stockVol ()[thePer]);
//
// Note that the actual stockVol (and not uiStockVol_) is
// appropriate for defining FSS Stock LB.

minSupAvail +=
+ uiScrapVol_ (theMat)[thePer]
+ uiStockVol_ (theMat)[thePer]
- fssStockLBThePer
- uiStockVolThePer_1
+ fssStockLBThePer_1
- theMat->supplyVol ()[thePer];

if (minSupAvail < - FLOAT_EPSILON)
{
supplyConsVol = - minSupAvail;
minSupAvail   = 0.0;
}
else supplyConsVol = 0.0;

mrpIncAvail_ (theMat)[thePer] =
theMat->supplyVol ()[thePer] - supplyConsVol;
}
}

forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
mrpIncAvail_ (thePart)[thePer] -=
positivePart (deltaFssShipVol (thePart, thePer));
//
// fssShipVol - achFssShipVol
}
d756 8
a763 8
{
WitFssMrpExp
theFssMrpExp (
myProblem (),
this,
uploadingSoln_,
fssExecVol_,
fssSubVol_);
d765 1
a765 1
theFssMrpExp.mrp ();
d767 2
a768 2
mrpIncAvail_.clear ();
}
d775 14
a788 14
WitProblem *                         theProblem,
WitFSS *                             theFSS,
bool &                               uploadingSolnArg,
WitSchedule <WitOperation, double> & fssExecVolArg,
WitSchedule <WitSubEntry,  double> & fssSubVolArg):

WitMrpExp      (theProblem),

myFSS_         (theFSS),
uploadingSoln_ (uploadingSolnArg),
fssExecVol_    (fssExecVolArg),
fssSubVol_     (fssSubVolArg)
{
}
d793 2
a794 2
{
}
d798 4
a801 4
double WitFssMrpExp::supplyVol (WitPart * thePart, WitPeriod thePer)
{
return myFSS_->mrpSupplyVol (thePart, thePer);
}
d806 3
a808 3
{
return myFSS_->mrpDemandVol (thePart, thePer);
}
d813 3
a815 3
{
return fssExecVol_ (theOpn)[thePer];
}
d820 3
a822 3
{
return fssSubVol_ (theSub)[thePer];
}
d827 4
a830 4
{
WitPart *      thePart;
WitOperation * theOpn;
WitSubEntry *  theSub;
d832 1
a832 1
uploadingSoln_ = true;
d834 2
a835 2
forEachPart (thePart, myProblem ())
thePart->storeFssFocShortageVol (myReqVol () (thePart));
d837 2
a838 2
forEachOperation (theOpn, myProblem ())
theOpn->storeFssFssExecVol      (fssExecVol_ (theOpn));
d840 2
a841 2
forEachSubEntry (theSub, myProblem ())
theSub->storeFssFssSubVol       (fssSubVol_  (theSub));
d843 2
a844 2
uploadingSoln_ = false;
}
@


1.78
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d145 1
a145 1
//   minSupAvail[thePer] = 
d152 1
a152 1
//   supplyConsVol[thePer] = 
d155 1
a155 1
// In other words, any time (minSupAvail[thePer - 1] + nonSupIncAvail[thePer]) 
d159 1
a159 1
// being consumed in order to keep availability (minSupAvail) from going 
d173 1
a173 1
// (when mrpIncAvail[thePer] >= 0) or increasing demand (when 
d201 1
a201 1
      WitProbAssoc   (theProblem),
d203 6
a208 6
      computed_      (false),
      uploadingSoln_ (false),
      fssExecVol_    (),
      fssSubVol_     ()
   {
   }
d213 2
a214 2
   {
   }
d228 2
a229 2
   {
   WitDemand * theDemand;
d231 1
a231 1
   WitTimer::enterSection ("fss");
d233 2
a234 2
   if (not myPostprocessor ()->postprocessed ())
      myMsgFac () ("unpostprocessedFssSmsg");
d236 2
a237 2
   if (not myProblem ()->currentVariant ()->internalSoln ())
      myMsgFac () ("fssWithUserSolnSmsg");
d239 1
a239 1
   myMsgFac () ("compFSSMsg");
d241 3
a243 3
   if (myGlobalComp ()->useFocusHorizons ())
      forEachDemand (theDemand, myProblem ())
         theDemand->compFssShipVol ();
d245 1
a245 1
   initSoln ();
d247 1
a247 1
   defineMrp ();
d249 1
a249 1
   doMrp ();
d251 2
a252 2
   fssExecVol_.clear ();
   fssSubVol_ .clear ();
d254 1
a254 1
   computed_ = true;
d256 2
a257 2
   WitTimer::leaveSection ("fss");
   }
d272 35
a306 35
      WitDemand *     theDemand,
      WitDblFlexVec & fssShipVolRef)
   {
   double      cumShipVolThePer;
   double      cDFHorizon;
   WitPeriod   thePer;
   double      cumFssShipVolThePer;
   double      cumFssShipVolThePer_1;

   witAssert (myGlobalComp ()->useFocusHorizons ());

   cumShipVolThePer = 0.0;

   cDFHorizon =
      (theDemand->focusHorizon () >= 0)?
         theDemand->cumDemandVol ()[theDemand->focusHorizon ()]:
         0.0;

   cumFssShipVolThePer = 0.0;

   forEachPeriod (thePer, myProblem ())
      {
      cumShipVolThePer += theDemand->shipVol ()[thePer];

      cumFssShipVolThePer_1 = cumFssShipVolThePer;

      cumFssShipVolThePer =
         (thePer <= theDemand->focusHorizon ())?
            theDemand->cumDemandVol ()[thePer]:
            max (cDFHorizon, cumShipVolThePer);

      fssShipVolRef.elemRef (thePer) =
         cumFssShipVolThePer - cumFssShipVolThePer_1;
      }
   }
d311 3
a313 3
   {
   return positivePart (mrpIncAvail_ (thePart)[thePer]);
   }
d318 3
a320 3
   {
   return positivePart (- mrpIncAvail_ (thePart)[thePer]);
   }
d325 3
a327 3
   {
   computed_ = false;
   }
d332 13
a344 13
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   fssExecVol_.allocate (myProblem (), 0.0);
   fssSubVol_ .allocate (myProblem (), 0.0);

   forEachOperation (theOpn, myProblem ())
      fssExecVol_ (theOpn) = theOpn->execVol ();

   forEachSubEntry (theSub, myProblem ())
      fssSubVol_  (theSub) = theSub->subVol ();
   }
d349 3
a351 3
   {
   uiScrapVol_.allocate (myProblem (), 0.0);
   uiStockVol_.allocate (myProblem (), 0.0);
d353 1
a353 1
   defineUnimplode ();
d355 1
a355 1
   unimplode ();
d357 1
a357 1
   compMrpIncAvail ();
d359 3
a361 3
   uiScrapVol_.clear ();
   uiStockVol_.clear ();
   }
d366 34
a399 34
   {
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;
   int           maxNSubs;
   WitBomEntry * theBomEnt;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         uiScrapVol_ (thePart)[thePer] = thePart->scrapVol ()[thePer] +
            positivePart (- deltaFssShipVol (thePart, thePer));
               //
               // shipVol - achFssShipVol
               // Scrapping any shipVol that's in excess of achFssShipVol.
               // This causes unimplosion to be performed relative to
               // achFssShipVol.

         if (uiScrapVol_ (thePart)[thePer] < 0.0)
             uiScrapVol_ (thePart)[thePer] = 0.0;
             //
             // A negative scrapVol is a constraint violation that is
             // presumed to be an insignificant numerical error and therefore
             // ignored.
         }

   forEachMaterial (theMat, myProblem ())
      uiStockVol_ (theMat) = theMat->stockVol ();

   maxNSubs = 0;

   forEachBomEntry (theBomEnt, myProblem ())
      setToMax (maxNSubs, theBomEnt->mySubEntries ().nElements ());
   }
d404 10
a413 10
   {
   WitDemand * theDemand;
   double      delta;

   delta = 0.0;

   forEachEl (theDemand, thePart->myDemands ())
      delta +=
         theDemand->fssShipVol ()[thePer] -
         theDemand->shipVol    ()[thePer];
d415 2
a416 2
   return delta;
   }
d425 9
a433 9
   {
   WitOperation * uiOpn;
   bool           isCoprod;
   WitBopEntry *  uiBopEnt;
   WitPart *      uiPart;
   WitMaterial *  uiMat;
   WitPeriod      execPer;
   WitPeriod      scrapPer;
   WitBopEntry *  theBopEnt;
d435 1
a435 1
   WitObjStack <WitOperation> reversedOpns (myProblem ());
d437 1
a437 1
   revCopyInto (reversedOpns, myCompMgr ()->allOperations ());
d439 3
a441 3
   while (reversedOpns.pop (uiOpn))
      {
      isCoprod = false;
d443 3
a445 3
      forEachPeriod (execPer, myProblem ())
         if (uiOpn->isCoproducing (execPer))
            isCoprod = true;
d447 2
a448 2
      if (isCoprod)
         continue;
d450 1
a450 1
      uiBopEnt = NULL;
d452 5
a456 5
      forEachEl (theBopEnt, uiOpn->bop ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->productRate ()[execPer] > 0.0)
               {
               uiBopEnt = theBopEnt;
d458 2
a459 2
               break;
               }
d461 2
a462 2
      if (uiBopEnt == NULL)
         continue;
d464 1
a464 1
      uiPart = uiBopEnt->myPart ();
d466 1
a466 1
      uiMat  = uiPart->thisMat ();
d468 2
a469 2
      if (uiMat != NULL)
         uiMat->rollBackScrap (uiStockVol_ (uiMat), uiScrapVol_ (uiMat));
d471 1
a471 1
      scrapPer = 0;
d473 4
a476 4
      forEachPeriod (execPer, myProblem ())
         unimplode (uiOpn, uiBopEnt, uiPart, execPer, scrapPer);
      }
   }
d481 10
a490 10
      WitOperation * uiOpn,
      WitBopEntry *  uiBopEnt,
      WitPart *      uiPart,
      WitPeriod      execPer,
      WitPeriod &    scrapPer)
   {
   WitPeriod     prodPer;
   WitMaterial * uiMat;
   double        deltaExecVol;
   double        oldExecVol;
d492 2
a493 2
   if (uiBopEnt->effProdRate ()[execPer] < .01)
      return;
d495 4
a498 4
   deltaExecVol =
      positivePart (
         + fssExecVol_ (uiOpn)[execPer]
         - uiOpn->execBounds ()->softLB ()[execPer]);
d500 2
a501 2
   if (deltaExecVol < FLOAT_EPSILON)
      return;
d503 1
a503 1
   prodPer = uiBopEnt->impactPeriod ()[execPer];
d505 1
a505 1
   uiMat   = uiPart->thisMat ();
d507 2
a508 2
   if (uiMat != NULL)
      rollOverScrap (uiMat, scrapPer, prodPer);
d510 3
a512 3
   setToMin (
      deltaExecVol,
      uiScrapVol_ (uiPart)[prodPer] / uiBopEnt->effProdRate ()[execPer]);
d514 2
a515 2
   if (deltaExecVol < FLOAT_EPSILON)
      return;
d517 1
a517 1
   oldExecVol   = fssExecVol_ (uiOpn)[execPer];
d519 1
a519 1
   deltaExecVol = - uiOpn->lotSizeDelta (execPer, oldExecVol, - deltaExecVol);
d521 2
a522 2
   if (deltaExecVol < FLOAT_EPSILON)
      return;
d524 1
a524 1
   fssExecVol_ (uiOpn)[execPer] -= deltaExecVol;
d526 3
a528 3
   if (uiBopEnt->inEffect (execPer))
      uiScrapVol_ (uiPart)[prodPer] -=
         deltaExecVol * uiBopEnt->effProdRate ()[execPer];
d530 2
a531 2
   unimplodeBom (uiOpn, execPer, deltaExecVol);
   }
d536 40
a575 40
      WitMaterial * theMat,
      WitPeriod &   scrapPer,
      WitPeriod     prodPer)
   {
   double carryOver;
      //
      // Scrap volume carried over as stock from thePer - 1 to thePer.

   double maxStockInc;
      //
      // The amount by which stockVol can be increased without violating its
      // hardUB.

   while (scrapPer < prodPer)
      {
      ++ scrapPer;

      if (not theMat->canStock (scrapPer - 1))
         continue;

      carryOver = uiScrapVol_ (theMat)[scrapPer - 1];

      if (theMat->stockBounds ()->hardUBIsFinite (scrapPer - 1))
         {
         maxStockInc =
            positivePart (
               + theMat->stockBounds ()->hardUB ()[scrapPer - 1]
               - uiStockVol_ (theMat)[scrapPer - 1]);

         carryOver = min (carryOver, maxStockInc);
         }

      if (carryOver <= FLOAT_EPSILON)
         continue;

      uiScrapVol_ (theMat)[scrapPer - 1] -= carryOver;
      uiStockVol_ (theMat)[scrapPer - 1] += carryOver;
      uiScrapVol_ (theMat)[scrapPer]     += carryOver;
      }
   }
d580 18
a597 18
      WitOperation * uiOpn,
      WitPeriod      execPer,
      double         deltaExecVol)
   {
   WitBomEntry * theBomEnt;
   WitPeriod     consPer;

   forEachEl (theBomEnt, uiOpn->bom ())
      if (theBomEnt->inEffect (execPer))
         {
         consPer = theBomEnt->impactPeriod ()[execPer];

         uiScrapVol_ (theBomEnt->myPart ())[consPer] +=
            deltaExecVol * theBomEnt->effConsRate ()[execPer];

         unimplodeSubs (theBomEnt, execPer, deltaExecVol);
         }
   }
d609 54
a662 54
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol)
   {
   WitSubEntry * theSub;      // SubEntry being unimploded.
   double        unallocVol;  // The amount of deltaExecVol that has not yet
                              // been allocated to any Sub for a particular
                              // bomEntry.
   double        deltaSubVol; // The amount of deltaExecVol allocated to a
                              // particular sub.
   WitPeriod     consPer;     // Consumption period.

   unallocVol = deltaExecVol;
   consPer    = theBomEnt->impactPeriod ()[execPer];


   WitObjStack <WitSubEntry> reversedSubEntries (myProblem ());
      //
      // The Subs for theBomEnt, in reverse order.

   revCopyInto (reversedSubEntries, theBomEnt->mySubEntries ());

   while (reversedSubEntries.pop (theSub))
      {
      if (not theSub->inEffect (execPer))
         continue;

      if (fssSubVol_ (theSub)[execPer] < FLOAT_EPSILON)
         continue;

      if (fssSubVol_ (theSub)[execPer] < unallocVol)
         {
         deltaSubVol = fssSubVol_ (theSub)[execPer];

         fssSubVol_ (theSub)[execPer] = 0.0;

         unallocVol -= deltaSubVol;
         }
      else
         {
         deltaSubVol = unallocVol;

         fssSubVol_ (theSub)[execPer] -= deltaSubVol;

         unallocVol = 0.0;
         }

      uiScrapVol_ (theSub->myPart ())[consPer] +=
         deltaSubVol * theSub->effConsRate ()[execPer];

      if (unallocVol < FLOAT_EPSILON)
         break;
      }
   }
d667 85
a751 85
   {
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;

   double uiStockVolThePer_1;
      //
      // uiStockVol_[thePer - 1], or 0.0, if thePer == 0.

   double fssStockLBThePer_1;
      //
      // Lower bound on stockVol for a material in thePer - 1 for FSS purposes.

   double fssStockLBThePer;
      //
      // Lower bound on stockVol for a material in thePer for FSS purposes.

   double minSupAvail;
      //
      // Minimum supply availability.
      // The availability of theMat in thePer, using the minumum
      // necessary supply. When this becomes negative, supply is consumed to
      // compensate make it zero.

   double supplyConsVol;
      //
      // Supply Consumption volume for theMat in thePer.

   //--------------------------------------------------------------------------

   mrpIncAvail_.allocate (myProblem (), 0.0);

   forEachPart (thePart, this)
      if (thePart->thisCap () != NULL)
         mrpIncAvail_ (thePart) = uiScrapVol_ (thePart);

   forEachMaterial (theMat, myProblem ())
      {
      fssStockLBThePer = 0.0;
      minSupAvail      = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         uiStockVolThePer_1 =
            (thePer > 0)?
               uiStockVol_ (theMat)[thePer - 1]:
               0.0;

         fssStockLBThePer_1 = fssStockLBThePer;

         fssStockLBThePer =
            min (
               theMat->stockBounds ()->softLB ()[thePer],
               theMat->stockVol ()[thePer]);
                  //
                  // Note that the actual stockVol (and not uiStockVol_) is
                  // appropriate for defining FSS Stock LB.

         minSupAvail +=
            + uiScrapVol_ (theMat)[thePer]
            + uiStockVol_ (theMat)[thePer]
            - fssStockLBThePer
            - uiStockVolThePer_1
            + fssStockLBThePer_1
            - theMat->supplyVol ()[thePer];

         if (minSupAvail < - FLOAT_EPSILON)
            {
            supplyConsVol = - minSupAvail;
            minSupAvail   = 0.0;
            }
         else supplyConsVol = 0.0;

         mrpIncAvail_ (theMat)[thePer] =
            theMat->supplyVol ()[thePer] - supplyConsVol;
         }
      }

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         mrpIncAvail_ (thePart)[thePer] -=
            positivePart (deltaFssShipVol (thePart, thePer));
               //
               // fssShipVol - achFssShipVol
   }
d756 8
a763 8
   {
   WitFssMrpExp
      theFssMrpExp (
         myProblem (),
         this,
         uploadingSoln_,
         fssExecVol_,
         fssSubVol_);
d765 1
a765 1
   theFssMrpExp.mrp ();
d767 2
a768 2
   mrpIncAvail_.clear ();
   }
d775 14
a788 14
         WitProblem *                         theProblem,
         WitFSS *                             theFSS,
         bool &                               uploadingSolnArg,
         WitSchedule <WitOperation, double> & fssExecVolArg,
         WitSchedule <WitSubEntry,  double> & fssSubVolArg):

      WitMrpExp      (theProblem),

      myFSS_         (theFSS),
      uploadingSoln_ (uploadingSolnArg),
      fssExecVol_    (fssExecVolArg),
      fssSubVol_     (fssSubVolArg)
   {
   }
d793 2
a794 2
   {
   }
d798 4
a801 4
double WitFssMrpExp::supplyVol (WitPart * thePart, WitPeriod thePer) 
   {
   return myFSS_->mrpSupplyVol (thePart, thePer);
   }
d806 3
a808 3
   {
   return myFSS_->mrpDemandVol (thePart, thePer);
   }
d813 3
a815 3
   {
   return fssExecVol_ (theOpn)[thePer];
   }
d820 3
a822 3
   {
   return fssSubVol_ (theSub)[thePer];
   }
d827 4
a830 4
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitSubEntry *  theSub;
d832 1
a832 1
   uploadingSoln_ = true;
d834 2
a835 2
   forEachPart (thePart, myProblem ())
      thePart->storeFssFocShortageVol (myReqVol () (thePart));
d837 2
a838 2
   forEachOperation (theOpn, myProblem ())
      theOpn->storeFssFssExecVol      (fssExecVol_ (theOpn));
d840 2
a841 2
   forEachSubEntry (theSub, myProblem ())
      theSub->storeFssFssSubVol       (fssSubVol_  (theSub));
d843 2
a844 2
   uploadingSoln_ = false;
   }
@


1.77
log
@Heuristic Adjustment
@
text
@d519 1
a519 2
   deltaExecVol =
      - uiOpn->lotSizeDelta (execPer, oldExecVol, - deltaExecVol, true);
@


1.76
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d25 1
a25 1
#include <Opn.h>
@


1.75
log
@Stochastic Implosion
@
text
@d22 1
a22 1
#include <Global.h>
@


1.74
log
@Stochastic Implosion
@
text
@d24 3
d201 1
a201 1
      WitProbAssoc    (theProblem),
d203 4
a206 5
      computed_       (false),
      passRefsComp_   (NULL),
      focShortageVol_ (),
      fssExecVol_     (),
      fssSubVol_      ()
a216 21

void WitFSS::receivePartRefs (WitDblFlexVec & focShortageVolRef)
   {
   focShortageVol_.setMapFor (passRefsComp ()->thisPart (), focShortageVolRef);
   }

//------------------------------------------------------------------------------

void WitFSS::receiveOperationRefs (WitDblFlexVec & fssExecVolRef)
   {
   fssExecVol_.setMapFor (passRefsComp ()->thisOpn (), fssExecVolRef);
   }

//------------------------------------------------------------------------------

void WitFSS::receiveSubEntryRefs (WitDblFlexVec & fssSubVolRef)
   {
   fssSubVol_.setMapFor (passRefsComp ()->thisSub (), fssSubVolRef);
   }

//------------------------------------------------------------------------------
d251 3
d336 2
a337 8
   focShortageVol_.allocate (myProblem ());
   fssExecVol_    .allocate (myProblem ());
   fssSubVol_     .allocate (myProblem ());

   forEachEl (passRefsComp_, myCompMgr ()->allComponents ())
      passRefsComp_->passFssRefs ();

   passRefsComp_ = NULL;
d497 1
a497 1
         + uiOpn->fssExecVol ()[execPer]
d517 1
a517 1
   oldExecVol   = uiOpn->fssExecVol ()[execPer];
d525 1
a525 1
   fssExecVol_ (uiOpn).elemRef (execPer) -= deltaExecVol;
d637 1
a637 1
      if (theSub->fssSubVol ()[execPer] < FLOAT_EPSILON)
d640 1
a640 1
      if (theSub->fssSubVol ()[execPer] < unallocVol)
d642 1
a642 1
         deltaSubVol = theSub->fssSubVol ()[execPer];
d644 1
a644 1
         fssSubVol_ (theSub).elemRef (execPer) = 0.0;
d652 1
a652 1
         fssSubVol_ (theSub).elemRef (execPer) -= deltaSubVol;
d762 1
a762 1
         focShortageVol_,
d768 1
a768 4
   mrpIncAvail_   .clear ();
   focShortageVol_.clear ();
   fssExecVol_    .clear ();
   fssSubVol_     .clear ();
d776 12
a787 12
         WitProblem *                              theProblem,
         WitFSS *                                  theFSS,
         WitRefMap <WitPart,      WitDblFlexVec> & focShortageVolRef,
         WitRefMap <WitOperation, WitDblFlexVec> & fssExecVolRef,
         WitRefMap <WitSubEntry,  WitDblFlexVec> & fssSubVolRef):

      WitMrpExp       (theProblem),

      myFSS_          (theFSS),
      focShortageVol_ (focShortageVolRef),
      fssExecVol_     (fssExecVolRef),
      fssSubVol_      (fssSubVolRef)
d815 1
a815 1
   return fssExecVol_ (theOpn).elemRef (thePer);
d822 1
a822 1
   return fssSubVol_ (theSub).elemRef (thePer);
d829 5
a833 1
   WitPart * thePart;
d836 9
a844 1
      focShortageVol_ (thePart) = myReqVol ()(thePart);
@


1.73
log
@Stochastic Implosion
@
text
@d216 1
a216 1
void WitFSS::receivePartRefs (WitDblFlexVec & focShortageVolArg)
d218 1
a218 1
   focShortageVol_.setMapFor (passRefsComp ()->thisPart (), focShortageVolArg);
d223 1
a223 1
void WitFSS::receiveOperationRefs (WitDblFlexVec & fssExecVolArg)
d225 1
a225 1
   fssExecVol_.setMapFor (passRefsComp ()->thisOpn (), fssExecVolArg);
d230 1
a230 1
void WitFSS::receiveSubEntryRefs (WitDblFlexVec & fssSubVolArg)
d232 1
a232 1
   fssSubVol_.setMapFor (passRefsComp ()->thisSub (), fssSubVolArg);
d289 1
a289 1
      WitDblFlexVec & fssShipVolArg)
d319 1
a319 1
      fssShipVolArg.elemRef (thePer) =
d803 3
a805 3
         WitRefMap <WitPart,      WitDblFlexVec> & focShortageVolArg,
         WitRefMap <WitOperation, WitDblFlexVec> & fssExecVolArg,
         WitRefMap <WitSubEntry,  WitDblFlexVec> & fssSubVolArg):
d810 3
a812 3
      focShortageVol_ (focShortageVolArg),
      fssExecVol_     (fssExecVolArg),
      fssSubVol_      (fssSubVolArg)
@


1.72
log
@Stochastic Implosion
@
text
@d201 1
a201 1
      passDataComp_   (NULL),
d216 1
a216 1
void WitFSS::receivePartData (WitDblFlexVec & focShortageVolArg)
d218 1
a218 1
   focShortageVol_.setMapFor (passDataComp ()->thisPart (), focShortageVolArg);
d223 1
a223 1
void WitFSS::receiveOperationData (WitDblFlexVec & fssExecVolArg)
d225 1
a225 1
   fssExecVol_.setMapFor (passDataComp ()->thisOpn (), fssExecVolArg);
d230 1
a230 1
void WitFSS::receiveSubEntryData (WitDblFlexVec & fssSubVolArg)
d232 1
a232 1
   fssSubVol_.setMapFor (passDataComp ()->thisSub (), fssSubVolArg);
d356 2
a357 2
   forEachEl (passDataComp_, myCompMgr ()->allComponents ())
      passDataComp_->passFssData ();
d359 1
a359 1
   passDataComp_ = NULL;
@


1.71
log
@Stochastic Implosion
@
text
@d201 1
d216 1
a216 1
void WitFSS::receiveData (WitPart * thePart, WitDblFlexVec & focShortageVolArg)
d218 1
a218 1
   focShortageVol_.setMapFor (thePart, focShortageVolArg);
d223 1
a223 1
void WitFSS::receiveData (WitOperation * theOpn, WitDblFlexVec & fssExecVolArg)
d225 1
a225 1
   fssExecVol_.setMapFor (theOpn, fssExecVolArg);
d230 1
a230 1
void WitFSS::receiveData (WitSubEntry * theSub, WitDblFlexVec & fssSubVolArg)
d232 1
a232 1
   fssSubVol_.setMapFor (theSub, fssSubVolArg);
a348 1
   WitComponent * theComp;
d356 4
a359 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->passFssData ();
@


1.70
log
@Stochastic Implosion
@
text
@d214 21
a324 21
void WitFSS::receiveData (WitPart * thePart, WitDblFlexVec & focShortageVolArg)
   {
   focShortageVol_.setMapFor (thePart, focShortageVolArg);
   }

//------------------------------------------------------------------------------

void WitFSS::receiveData (WitOperation * theOpn, WitDblFlexVec & fssExecVolArg)
   {
   fssExecVol_.setMapFor (theOpn, fssExecVolArg);
   }

//------------------------------------------------------------------------------

void WitFSS::receiveData (WitSubEntry * theSub, WitDblFlexVec & fssSubVolArg)
   {
   fssSubVol_.setMapFor (theSub, fssSubVolArg);
   }

//------------------------------------------------------------------------------

@


1.69
log
@Stochastic Implosion
@
text
@a25 1
#include <FssAccess.h>
d198 6
a203 2
      WitProbAssoc (theProblem),
      computed_    (false)
d226 2
d239 2
a240 1
      compFssShipVols ();
d254 10
d265 3
a267 1
double WitFSS::mrpSupplyVol (WitPart * thePart, WitPeriod thePer) const
d269 31
a299 1
   return positivePart (mrpIncAvail_ (thePart)[thePer]);
d304 1
a304 1
double WitFSS::mrpDemandVol (WitPart * thePart, WitPeriod thePer) const
d306 1
a306 1
   return positivePart (- mrpIncAvail_ (thePart)[thePer]);
d311 1
a311 1
void WitFSS::uncompute ()
d313 1
a313 1
   computed_ = false;
a316 10
// compFssShipVols ()
//
// Local Variables:
//
// cumShipVolThePer:      Cumulative shipment volume in thePer.
// cDFHorizon:            Cumulative demand volume at the focus horizon of
//                        theDemand
// cumFssShipVolT:        Cumulative of fssShipVol ()[thePer].
// cumFssShipVolThePer_1: Cumulative of fssShipVol ()[thePer - 1].
//------------------------------------------------------------------------------
d318 1
a318 1
void WitFSS::compFssShipVols ()
d320 2
a321 7
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      cumShipVolThePer;
   double      cDFHorizon;
   double      cumFssShipVolThePer;
   double      cumFssShipVolThePer_1;
   double      fsVol;
d323 1
a323 3
   forEachDemand (theDemand, myProblem ())
      {
      cumShipVolThePer = 0.0;
d325 4
a328 4
      cDFHorizon =
         (theDemand->focusHorizon () >= 0)?
            theDemand->cumDemandVol ()[theDemand->focusHorizon ()]:
            0.0;
d330 1
a330 1
      cumFssShipVolThePer = 0.0;
d332 4
a335 3
      forEachPeriod (thePer, myProblem ())
         {
         cumShipVolThePer += theDemand->shipVol ()[thePer];
d337 1
a337 1
         cumFssShipVolThePer_1 = cumFssShipVolThePer;
d339 3
a341 9
         cumFssShipVolThePer =
            (thePer <= theDemand->focusHorizon ())?
               theDemand->cumDemandVol ()[thePer]:
               max (cDFHorizon, cumShipVolThePer);

         WitFssAccess::fssShipVol (theDemand).elemRef (thePer) =
            cumFssShipVolThePer - cumFssShipVolThePer_1;
         }
      }
d348 1
d352 7
d360 1
a360 1
      WitFssAccess::fssExecVol (theOpn) = theOpn->execVol ();
d363 1
a363 1
      WitFssAccess::fssSubVol  (theSub) = theSub->subVol ();
d545 1
a545 1
   WitFssAccess::fssExecVol (uiOpn).elemRef (execPer) -= deltaExecVol;
d664 1
a664 1
         WitFssAccess::fssSubVol (theSub).elemRef (execPer) = 0.0;
d672 1
a672 1
         WitFssAccess::fssSubVol (theSub).elemRef (execPer) -= deltaSubVol;
d778 7
a784 1
   WitFssMrpExp theFssMrpExp (myProblem (), this);
d788 4
a791 1
   mrpIncAvail_.clear ();
d798 13
a810 5
WitFssMrpExp::WitFssMrpExp (WitProblem * theProblem, WitFSS * theFSS):

      WitMrpExp (theProblem),

      myFSS_    (theFSS)
d838 1
a838 1
   return WitFssAccess::fssExecVol (theOpn).elemRef (thePer);
d845 1
a845 1
   return WitFssAccess::fssSubVol (theSub).elemRef (thePer);
d855 1
a855 1
      WitFssAccess::focShortageVol (thePart) = myReqVol ()(thePart);
@


1.68
log
@[disallowed backlog]
@
text
@d785 1
a785 1
WitDblFlexVec & WitFssMrpExp::execVol (WitOperation * theOpn)
d787 1
a787 1
   return WitFssAccess::fssExecVol (theOpn);
d792 1
a792 1
WitDblFlexVec & WitFssMrpExp::subVol (WitSubEntry * theSub)
d794 1
a794 1
   return WitFssAccess::fssSubVol (theSub);
@


1.67
log
@Rescinded all changed made since 1/31/07.
@
text
@d26 1
a197 10
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec    WitDemand::* WitFSS::fssShipVol_ = NULL;
WitDblFlexVec WitOperation::* WitFSS::fssExecVol_ = NULL;
WitDblFlexVec  WitSubEntry::* WitFSS::fssSubVol_  = NULL;

//------------------------------------------------------------------------------

a268 32

void WitFSS::receiveDMPs (WitDblFlexVec WitPart::* focShortageVolArg)
   {
   WitFssMrpExp::receiveDMPs (focShortageVolArg);
   }

//------------------------------------------------------------------------------

void WitFSS::receiveDMPs (WitDblFlexVec WitDemand::* fssShipVolArg)
   {
   fssShipVol_ = fssShipVolArg;
   }

//------------------------------------------------------------------------------

void WitFSS::receiveDMPs (WitDblFlexVec WitOperation::* fssExecVolArg)
   {
   fssExecVol_ = fssExecVolArg;

   WitFssMrpExp::receiveDMPs (fssExecVolArg);
   }

//------------------------------------------------------------------------------

void WitFSS::receiveDMPs (WitDblFlexVec WitSubEntry::* fssSubVolArg)
   {
   fssSubVol_ = fssSubVolArg;

   WitFssMrpExp::receiveDMPs (fssSubVolArg);
   }

//------------------------------------------------------------------------------
d312 1
a312 1
         (theDemand->*fssShipVol_).elemRef (thePer) =
d326 1
a326 1
      theOpn->*fssExecVol_ = theOpn->execVol ();
d329 1
a329 1
      theSub->*fssSubVol_ = theSub->subVol ();
d511 1
a511 1
   (uiOpn->*fssExecVol_).elemRef (execPer) -= deltaExecVol;
d630 1
a630 1
         (theSub->*fssSubVol_).elemRef (execPer) = 0.0;
d638 1
a638 1
         (theSub->*fssSubVol_).elemRef (execPer) -= deltaSubVol;
a754 10
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec      WitPart::* WitFssMrpExp::focShortageVol_ = NULL;
WitDblFlexVec WitOperation::* WitFssMrpExp::fssExecVol_     = NULL;
WitDblFlexVec  WitSubEntry::* WitFssMrpExp::fssSubVol_      = NULL;

//------------------------------------------------------------------------------

a770 21
void WitFssMrpExp::receiveDMPs (WitDblFlexVec WitPart::* focShortageVolArg)
   {
   focShortageVol_ = focShortageVolArg;
   }

//------------------------------------------------------------------------------

void WitFssMrpExp::receiveDMPs (WitDblFlexVec WitOperation::* fssExecVolArg)
   {
   fssExecVol_ = fssExecVolArg;
   }

//------------------------------------------------------------------------------

void WitFssMrpExp::receiveDMPs (WitDblFlexVec WitSubEntry::* fssSubVolArg)
   {
   fssSubVol_ = fssSubVolArg;
   }

//------------------------------------------------------------------------------

d787 1
a787 1
   return theOpn->*fssExecVol_;
d794 1
a794 1
   return theSub->*fssSubVol_;
d804 1
a804 1
      thePart->*focShortageVol_ = myReqVol ()(thePart);
@


1.66
log
@[disallowed backlog]
@
text
@a27 1
#include <IVRealArg.h>
d197 2
a198 6
WitFSS::WitFSS (WitProblem * theProblem):
      WitProbAssoc (theProblem),
      computed_    (false)
   {
   }

d201 3
a203 3
WitFSS::~WitFSS ()
   {
   }
d207 3
a209 1
void WitFSS::compDefFssShipVols ()
a210 4
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      theDemand->fssShipVol_ () = theDemand->shipVol ();
d215 1
a215 3
void WitFSS::setFssShipVol (
      WitDemand *          theDemand,
      const WitIVRealArg & theValue)
a216 7
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   uncompute ();

   theDemand->fssShipVol_ () = theValue;
d278 32
d353 2
a354 3
         theDemand->fssShipVol_ ().elemRef (thePer) =
              cumFssShipVolThePer
            - cumFssShipVolThePer_1;
d367 1
a367 1
      theOpn->fssExecVol_ () = theOpn->execVol ();
d370 1
a370 1
      theSub->fssSubVol_ () = theSub->subVol ();
d552 1
a552 1
   uiOpn->fssExecVol_ ().elemRef (execPer) -= deltaExecVol;
d671 1
a671 1
         theSub->fssSubVol_ ().elemRef (execPer) = 0.0;
d679 1
a679 1
         theSub->fssSubVol_ ().elemRef (execPer) -= deltaSubVol;
d796 10
d822 21
d859 1
a859 1
   return theOpn->fssExecVol_ ();
d866 1
a866 1
   return theSub->fssSubVol_ ();
d876 1
a876 1
      thePart->focShortageVol_ () = myReqVol ()(thePart);
@


1.65
log
@[disallowed backlog]
@
text
@a197 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec WitSubEntry::* WitFSS::fssSubVol_ = NULL;

//------------------------------------------------------------------------------

d217 1
a217 1
      theDemand->fssShipVol_.forUpdate () = theDemand->shipVol ();
d232 1
a232 1
   theDemand->fssShipVol_.forUpdate () = theValue;
a293 9

void WitFSS::receiveDMPs (WitDblFlexVec WitSubEntry::* fssSubVolArg)
   {
   fssSubVol_ = fssSubVolArg;

   WitFssMrpExp::receiveDMPs (fssSubVolArg);
   }

//------------------------------------------------------------------------------
d337 1
a337 1
         theDemand->fssShipVol_->elemRef (thePer) =
d352 1
a352 1
      theOpn->fssExecVol_.forUpdate () = theOpn->execVol ();
d355 1
a355 1
      theSub->*fssSubVol_ = theSub->subVol ();
d537 1
a537 1
   uiOpn->fssExecVol_->elemRef (execPer) -= deltaExecVol;
d656 1
a656 1
         (theSub->*fssSubVol_).elemRef (execPer) = 0.0;
d664 1
a664 1
         (theSub->*fssSubVol_).elemRef (execPer) -= deltaSubVol;
a780 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec WitSubEntry::* WitFssMrpExp::fssSubVol_ = NULL;

//------------------------------------------------------------------------------

a796 7
void WitFssMrpExp::receiveDMPs (WitDblFlexVec WitSubEntry::* fssSubVolArg)
   {
   fssSubVol_ = fssSubVolArg;
   }

//------------------------------------------------------------------------------

d813 1
a813 1
   return theOpn->fssExecVol_.forUpdate ();
d820 1
a820 1
   return theSub->*fssSubVol_;
d830 1
a830 1
      thePart->focShortageVol_.forUpdate () = myReqVol ()(thePart);
@


1.64
log
@[disallowed backlog]
@
text
@d28 1
d202 1
a202 3
WitDblFlexVec    WitDemand::* WitFSS::fssShipVol_ = NULL;
WitDblFlexVec WitOperation::* WitFSS::fssExecVol_ = NULL;
WitDblFlexVec  WitSubEntry::* WitFSS::fssSubVol_  = NULL;
d219 25
a302 16
void WitFSS::receiveDMPs (WitDblFlexVec WitDemand::* fssShipVolArg)
   {
   fssShipVol_ = fssShipVolArg;
   }

//------------------------------------------------------------------------------

void WitFSS::receiveDMPs (WitDblFlexVec WitOperation::* fssExecVolArg)
   {
   fssExecVol_ = fssExecVolArg;

   WitFssMrpExp::receiveDMPs (fssExecVolArg);
   }

//------------------------------------------------------------------------------

d354 3
a356 2
         (theDemand->*fssShipVol_).elemRef (thePer) =
            cumFssShipVolThePer - cumFssShipVolThePer_1;
d369 1
a369 1
      theOpn->*fssExecVol_ = theOpn->execVol ();
d554 1
a554 1
   (uiOpn->*fssExecVol_).elemRef (execPer) -= deltaExecVol;
d802 1
a802 2
WitDblFlexVec WitOperation::* WitFssMrpExp::fssExecVol_     = NULL;
WitDblFlexVec  WitSubEntry::* WitFssMrpExp::fssSubVol_      = NULL;
a821 7
void WitFssMrpExp::receiveDMPs (WitDblFlexVec WitOperation::* fssExecVolArg)
   {
   fssExecVol_ = fssExecVolArg;
   }

//------------------------------------------------------------------------------

d845 1
a845 1
   return theOpn->*fssExecVol_;
@


1.63
log
@witCopy<Object>Data
@
text
@a278 7
void WitFSS::receiveDMPs (WitDblFlexVec WitPart::* focShortageVolArg)
   {
   WitFssMrpExp::receiveDMPs (focShortageVolArg);
   }

//------------------------------------------------------------------------------

a792 1
WitDblFlexVec      WitPart::* WitFssMrpExp::focShortageVol_ = NULL;
a813 7
void WitFssMrpExp::receiveDMPs (WitDblFlexVec WitPart::* focShortageVolArg)
   {
   focShortageVol_ = focShortageVolArg;
   }

//------------------------------------------------------------------------------

d861 1
a861 1
      thePart->*focShortageVol_ = myReqVol ()(thePart);
@


1.62
log
@App controlled opt implosion.
@
text
@d728 1
a728 1
      if (thePart->isaCapacity ())
@


1.61
log
@Updated the copyright date on all source files.
@
text
@d21 1
d234 1
a234 1
   if (not myProblem ()->postprocessed ())
@


1.60
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.59
log
@Revised mappingIndex code.
@
text
@d196 10
a240 2
   loadData ();

a249 2
   clearLoadedData ();

d278 1
a278 3
void WitFSS::loadDataFrom (
      WitPart *       thePart,
      WitDblFlexVec & focShortageVolArg)
d280 1
a280 1
   focShortageVol_.setMapFor (thePart, focShortageVolArg);
d285 1
a285 3
void WitFSS::loadDataFrom (
      WitDemand *     theDemand,
      WitDblFlexVec & fssShipVolArg)
d287 1
a287 1
   fssShipVol_.setMapFor (theDemand, fssShipVolArg);
d292 1
a292 3
void WitFSS::loadDataFrom (
      WitOperation *  theOpn,
      WitDblFlexVec & fssExecVolArg)
d294 1
a294 4
   fssExecVol_.setMapFor (theOpn, fssExecVolArg);
   }

//------------------------------------------------------------------------------
d296 1
a296 5
void WitFSS::loadDataFrom (
     WitSubEntry *   theSub,
     WitDblFlexVec & fssSubVolArg)
   {
   fssSubVol_.setMapFor (theSub, fssSubVolArg);
d301 1
a301 1
void WitFSS::loadData ()
d303 1
a303 12
   WitComponent * theComp;

   focShortageVol_.allocate (myProblem ());
   fssShipVol_    .allocate (myProblem ());
   fssExecVol_    .allocate (myProblem ());
   fssSubVol_     .allocate (myProblem ());

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->loadFss ();
   }

//------------------------------------------------------------------------------
d305 1
a305 6
void WitFSS::clearLoadedData ()
   {
   focShortageVol_.clear ();
   fssShipVol_    .clear ();
   fssExecVol_    .clear ();
   fssSubVol_     .clear ();
d352 1
a352 1
         fssShipVol_ (theDemand).elemRef (thePer) =
d366 1
a366 1
      fssExecVol_ (theOpn) = theOpn->execVol ();
d369 1
a369 1
      fssSubVol_ (theSub) = theSub->subVol ();
d551 1
a551 1
   fssExecVol_ (uiOpn).elemRef (execPer) -= deltaExecVol;
d670 1
a670 1
         fssSubVol_ (theSub).elemRef (execPer) = 0.0;
d678 1
a678 1
         fssSubVol_ (theSub).elemRef (execPer) -= deltaSubVol;
d784 1
a784 6
   WitFssMrpExp theFssMrpExp (
      myProblem (),
      this,
      focShortageVol_,
      fssExecVol_,
      fssSubVol_);
a792 1
// Declared in FssMrp.h.
d795 15
a809 13
WitFssMrpExp::WitFssMrpExp (
         WitProblem *                                    theProblem,
         WitFSS *                                        theFSS,
         const WitRefMap <WitPart,      WitDblFlexVec> & focShortageVolArg,
         const WitRefMap <WitOperation, WitDblFlexVec> & fssExecVolArg,
         const WitRefMap <WitSubEntry,  WitDblFlexVec> & fssSubVolArg):

      WitMrpExp       (theProblem),

      focShortageVol_ (focShortageVolArg),
      fssExecVol_     (fssExecVolArg),
      fssSubVol_      (fssSubVolArg),
      myFSS_          (theFSS)
d821 21
d858 1
a858 1
   return fssExecVol_ (theOpn);
d865 1
a865 1
   return fssSubVol_ (theSub);
d875 1
a875 1
      focShortageVol_ (thePart) = myReqVol ()(thePart);
@


1.58
log
@pegged Critical List.
@
text
@a28 1
#include <MapIdxI.h>
@


1.57
log
@PIP.
@
text
@d826 5
a830 5
         WitProblem *                              theProblem,
         WitFSS *                                  theFSS,
         WitRefMap <WitPart,      WitDblFlexVec> & focShortageVolArg,
         WitRefMap <WitOperation, WitDblFlexVec> & fssExecVolArg,
         WitRefMap <WitSubEntry,  WitDblFlexVec> & fssSubVolArg):
@


1.56
log
@Double Precision.
@
text
@d443 1
a443 1
      theMat->stockVol ().copyInto (uiStockVol_ (theMat));
@


1.55
log
@Double Precision.
@
text
@d443 1
a443 1
      theMat->stockVol ().convCopyInto (uiStockVol_ (theMat));
@


1.54
log
@Double Precision.
@
text
@d882 1
a882 1
      focShortageVol_ (thePart).convCopy (myReqVol ()(thePart));
@


1.53
log
@Double Precision.
@
text
@d390 1
a390 1
      fssExecVol_ (theOpn).copy (theOpn->execVol ());
d393 1
a393 1
      fssSubVol_ (theSub).copy (theSub->subVol ());
d752 1
a752 1
         mrpIncAvail_ (thePart).copy (uiScrapVol_ (thePart));
@


1.52
log
@Double Precision.
@
text
@d274 2
a275 2
      WitPart *             thePart,
      WitFlexVec <double> & focShortageVolArg)
d283 2
a284 2
      WitDemand *           theDemand,
      WitFlexVec <double> & fssShipVolArg)
d292 2
a293 2
      WitOperation *        theOpn,
      WitFlexVec <double> & fssExecVolArg)
d301 2
a302 2
     WitSubEntry *         theSub,
     WitFlexVec <double> & fssSubVolArg)
d826 5
a830 5
         WitProblem *                                     theProblem,
         WitFSS *                                         theFSS,
         WitRefMap <WitPart,      WitFlexVec <double> > & focShortageVolArg,
         WitRefMap <WitOperation, WitFlexVec <double> > & fssExecVolArg,
         WitRefMap <WitSubEntry,  WitFlexVec <double> > & fssSubVolArg):
d863 1
a863 1
WitFlexVec <double> & WitFssMrpExp::execVol (WitOperation * theOpn)
d870 1
a870 1
WitFlexVec <double> & WitFssMrpExp::subVol (WitSubEntry * theSub)
@


1.51
log
@Double Precision.
@
text
@d273 3
a275 1
void WitFSS::loadDataFrom (WitPart * thePart, WitRealVec & focShortageVolArg)
d282 3
a284 1
void WitFSS::loadDataFrom (WitDemand * theDemand, WitRealVec & fssShipVolArg)
d291 3
a293 1
void WitFSS::loadDataFrom (WitOperation * theOpn, WitRealVec & fssExecVolArg)
d300 3
a302 1
void WitFSS::loadDataFrom (WitSubEntry * theSub, WitRealVec & fssSubVolArg)
d376 2
a377 3
         fsVol = cumFssShipVolThePer - cumFssShipVolThePer_1;

         fssShipVol_ (theDemand).setElem (thePer, fsVol);
d390 1
a390 1
      fssExecVol_ (theOpn).convCopy (theOpn->execVol ());
d393 1
a393 1
      fssSubVol_ (theSub).convCopy (theSub->subVol ());
d575 1
a575 1
   fssExecVol_ (uiOpn).incElem (execPer, - deltaExecVol);
d694 1
a694 1
         fssSubVol_ (theSub).setElem (execPer, 0.0);
d702 1
a702 1
         fssSubVol_ (theSub).incElem (execPer, - deltaSubVol);
d826 5
a830 5
         WitProblem *                           theProblem,
         WitFSS *                               theFSS,
         WitRefMap <WitPart,      WitRealVec> & focShortageVolArg,
         WitRefMap <WitOperation, WitRealVec> & fssExecVolArg,
         WitRefMap <WitSubEntry,  WitRealVec> & fssSubVolArg):
d863 1
a863 1
WitRealVec & WitFssMrpExp::execVol (WitOperation * theOpn)
d870 1
a870 1
WitRealVec & WitFssMrpExp::subVol (WitSubEntry * theSub)
@


1.50
log
@Double Precision.
@
text
@d280 1
a280 1
void WitFSS::loadDataFrom (WitDemand * theDemand, WitRealTVc & fssShipVolArg)
@


1.49
log
@Double Precision.
@
text
@d280 1
a280 1
void WitFSS::loadDataFrom (WitDemand * theDemand, WitRealVec & fssShipVolArg)
@


1.48
log
@Double Precision.
@
text
@d287 1
a287 3
void WitFSS::loadDataFrom (
      WitOperation *       theOpn, 
      WitFlexVec <float> & fssExecVolArg)
d294 1
a294 3
void WitFSS::loadDataFrom (
      WitSubEntry *        theSub, 
      WitFlexVec <float> & fssSubVolArg)
d383 1
a383 1
      convCopy (fssExecVol_ (theOpn), theOpn->execVol ());
d386 1
a386 1
      convCopy (fssSubVol_ (theSub), theSub->subVol ());
d568 1
a568 1
   fssExecVol_ (uiOpn).elemRef (execPer) -= deltaExecVol;
d685 5
a689 3
         deltaSubVol                           = theSub->fssSubVol ()[execPer];
         fssSubVol_ (theSub).elemRef (execPer) = 0.0;
         unallocVol                           -= deltaSubVol;
d693 5
a697 3
         deltaSubVol                            = unallocVol;
         fssSubVol_ (theSub).elemRef (execPer) -= deltaSubVol;
         unallocVol                             = 0.0;
d819 5
a823 5
         WitProblem *                                    theProblem,
         WitFSS *                                        theFSS,
         WitRefMap <WitPart,      WitRealVec> &          focShortageVolArg,
         WitRefMap <WitOperation, WitFlexVec <float> > & fssExecVolArg,
         WitRefMap <WitSubEntry,  WitFlexVec <float> > & fssSubVolArg):
d856 1
a856 1
float & WitFssMrpExp::execVol (WitOperation * theOpn, WitPeriod execPer)
d858 1
a858 1
   return fssExecVol_ (theOpn).elemRef (execPer);
d863 1
a863 1
float & WitFssMrpExp::subVol (WitSubEntry * theSub, WitPeriod execPer)
d865 1
a865 1
   return fssSubVol_ (theSub).elemRef (execPer);
@


1.47
log
@Double Precision.
@
text
@d440 1
a440 1
      theMat->stockVol ().copyIntoDblTVec (uiStockVol_ (theMat));
d875 1
a875 1
      focShortageVol_ (thePart).copyDblTVec (myReqVol ()(thePart));
@


1.46
log
@Double Precision.
@
text
@d387 1
a387 1
      copyInto (fssExecVol_ (theOpn), theOpn->execVol ());
d390 1
a390 1
      copyInto (fssSubVol_ (theSub), theSub->subVol ());
@


1.45
log
@Double Precision.
@
text
@d280 1
a280 3
void WitFSS::loadDataFrom (
      WitDemand *          theDemand,
      WitTVec <float> &    fssShipVolArg)
d348 1
d372 3
a374 2
         fssShipVol_ (theDemand)[thePer] = 
            cumFssShipVolThePer - cumFssShipVolThePer_1;
d459 2
a460 2
         doubleFromFloat (theDemand->fssShipVol ()[thePer]) -
                          theDemand->shipVol    ()[thePer];
@


1.44
log
@Double Precision.
@
text
@d763 1
a763 1
               doubleFromFloat (theMat->stockBounds ()->softLB ()[thePer]),
@


1.43
log
@Continued double precision.
@
text
@d273 1
a273 3
void WitFSS::loadDataFrom (
      WitPart *            thePart,
      WitFlexVec <float> & focShortageVolArg)
d440 1
a440 1
      copyInto (uiStockVol_ (theMat), theMat->stockVol ());
d763 1
a763 1
               theMat->stockBounds ()->softLB ()[thePer],
d821 1
a821 1
         WitRefMap <WitPart,      WitFlexVec <float> > & focShortageVolArg,
d875 1
a875 1
      copyInto (focShortageVol_ (thePart), myReqVol ()(thePart));
@


1.42
log
@Removed a bad function overload.
@
text
@d461 2
a462 2
         static_cast <double> (theDemand->fssShipVol ()[thePer]) -
         static_cast <double> (theDemand->shipVol    ()[thePer]);
@


1.41
log
@Continued implementation of post-implosion pegging.
@
text
@d515 1
a515 1
      uiMat  = uiPart->myMat ();
d554 1
a554 1
   uiMat   = uiPart->myMat ();
@


1.40
log
@Continued implementation of post-implosion pegging.
@
text
@a28 1
#include <RefMapI.h>
@


1.39
log
@Continued implementation of post-implosion pegging.
@
text
@a28 1
#include <ScheduleI.h>
d30 1
@


1.38
log
@An attempt to fix another link error from the Windows compiler.
@
text
@a30 1
#include <FlexVecI.h>
@


1.37
log
@Continued implementation of opt with COIN.
@
text
@d488 1
a488 1
   reversedOpns.revCopyOf (myCompMgr ()->allOperations ());
d681 1
a681 1
   reversedSubEntries.revCopyOf (theBomEnt->mySubEntries ());
@


1.36
log
@Continued implementation of proportionate routing.
@
text
@d224 1
a224 1
   WitTimingEvent theEvent ("fss");
d248 2
@


1.35
log
@Changed some C style casts to C++ style.
@
text
@d515 1
a515 1
      uiPart->getMaterial (uiMat);
d554 1
a554 1
   uiPart->getMaterial (uiMat);
@


1.34
log
@Internal changes.
@
text
@d461 2
a462 2
         (double) theDemand->fssShipVol ()[thePer] -
         (double) theDemand->shipVol    ()[thePer];
@


1.33
log
@Internal changes.
@
text
@d226 1
a226 1
   if (! myProblem ()->postprocessed ())
d229 1
a229 1
   if (! myProblem ()->currentVariant ()->internalSoln ())
d603 1
a603 1
      if (! theMat->canStock (scrapPer - 1))
d683 1
a683 1
      if (! theSub->inEffect (execPer))
@


1.32
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d42 1
a42 1
// If myGlobalComp ()->useFocusHorizons () is TRUE, then, as a preliminary step,
d201 1
a201 1
      computed_    (witFALSE)
d247 1
a247 1
   computed_ = witTRUE;
d268 1
a268 1
   computed_ = witFALSE;
d476 1
a476 1
   WitBoolean     isCoprod;
d490 1
a490 1
      isCoprod = witFALSE;
d494 1
a494 1
            isCoprod = witTRUE;
d569 1
a569 1
      - uiOpn->lotSizeDelta (execPer, oldExecVol, - deltaExecVol, witTRUE);
@


1.31
log
@Continued implementation of 2-level lot sizes.
@
text
@d230 1
a230 1
      myMsgFac () ("inputFssSmsg");
@


1.30
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a538 1
   double        negDeltaExecVol;
d566 1
a566 1
   oldExecVol      = uiOpn->fssExecVol ()[execPer];
d568 2
a569 5
   negDeltaExecVol = - deltaExecVol;  

   uiOpn->lotSizeDelta (execPer, oldExecVol, negDeltaExecVol, witTRUE, witTRUE);

   deltaExecVol = - negDeltaExecVol;  
@


1.29
log
@Continued implementation of Single-Source.
@
text
@d27 1
d31 1
a31 1
#include <MsgFac.h>
@


1.28
log
@Continued implementation of single-source.
@
text
@a21 1
#include <Schedule.h>
d28 1
d200 1
a200 4
      computed_    (witFALSE),
      uiScrapVol_  (* new WitSchedule <WitPart,     double>),
      uiStockVol_  (* new WitSchedule <WitMaterial, double>),
      mrpIncAvail_ (* new WitSchedule <WitPart,     double>)
a207 3
   delete & uiScrapVol_;
   delete & uiStockVol_;
   delete & mrpIncAvail_;
@


1.27
log
@Continued implementation of single-source.
@
text
@d259 1
a259 1
   return positivePart (mrpIncAvail_ (thePart, thePer));
d266 1
a266 1
   return positivePart (- mrpIncAvail_ (thePart, thePer));
d430 1
a430 1
         uiScrapVol_ (thePart, thePer) = thePart->scrapVol ()[thePer] +
d438 2
a439 2
         if (uiScrapVol_ (thePart, thePer) < 0.0)
             uiScrapVol_ (thePart, thePer) = 0.0;
d567 1
a567 1
      uiScrapVol_ (uiPart, prodPer) / uiBopEnt->effProdRate ()[execPer]);
d586 1
a586 1
      uiScrapVol_ (uiPart, prodPer) -=
d615 1
a615 1
      carryOver = uiScrapVol_ (theMat, scrapPer - 1);
d622 1
a622 1
               - uiStockVol_ (theMat, scrapPer - 1));
d630 3
a632 3
      uiScrapVol_ (theMat, scrapPer - 1) -= carryOver;
      uiStockVol_ (theMat, scrapPer - 1) += carryOver;
      uiScrapVol_ (theMat, scrapPer)     += carryOver;
d767 1
a767 1
               uiStockVol_ (theMat, thePer - 1):
d781 2
a782 2
            + uiScrapVol_ (theMat, thePer)
            + uiStockVol_ (theMat, thePer)
d795 1
a795 1
         mrpIncAvail_ (theMat, thePer) =
d802 1
a802 1
         mrpIncAvail_ (thePart, thePer) -=
@


1.26
log
@Continued implementation of single-source.
@
text
@d199 5
a203 9
      WitProbAssoc    (theProblem),
      focShortageVol_ (),
      fssShipVol_     (),
      fssExecVol_     (),
      fssSubVol_      (),
      computed_       (witFALSE),
      uiScrapVol_     (* new WitSchedule <WitPart,     double>),
      uiStockVol_     (* new WitSchedule <WitMaterial, double>),
      mrpIncAvail_    (* new WitSchedule <WitPart,     double>)
@


1.25
log
@Continued implementation of single-source.
@
text
@d29 1
a29 1
#include <RefMap.h>
d200 4
a203 4
      focShortageVol_ (* new WitRefMap <WitPart,      WitFlexVec <float> >), 
      fssShipVol_     (* new WitRefMap <WitDemand,    WitTVec    <float> >), 
      fssExecVol_     (* new WitRefMap <WitOperation, WitFlexVec <float> >), 
      fssSubVol_      (* new WitRefMap <WitSubEntry,  WitFlexVec <float> >), 
a214 4
   delete & focShortageVol_;
   delete & fssShipVol_;
   delete & fssExecVol_;
   delete & fssSubVol_;
@


1.24
log
@Continued implementation of single-source.
@
text
@d29 1
d199 9
a207 7
      WitProbAssoc (theProblem),

      computed_    (witFALSE),
      myAccFlag_   (new WitAccFlag),
      uiScrapVol_  (* new WitSchedule <WitPart,     double>),
      uiStockVol_  (* new WitSchedule <WitMaterial, double>),
      mrpIncAvail_ (* new WitSchedule <WitPart,     double>)
d215 6
a221 2
   delete & uiStockVol_;
   delete & uiScrapVol_;
d247 2
d258 2
d285 61
d388 1
a388 1
         fssShipVol (theDemand)[thePer] = 
d402 1
a402 1
      copyInto (fssExecVol (theOpn), theOpn->execVol ());
d405 1
a405 1
      copyInto (fssSubVol (theSub), theSub->subVol ());
d560 1
a560 1
         + fssExecVol (uiOpn)[execPer]
d580 1
a580 1
   oldExecVol      = fssExecVol (uiOpn)[execPer];
d591 1
a591 1
   fssExecVol (uiOpn).elemRef (execPer) -= deltaExecVol;
d703 1
a703 1
      if (fssSubVol (theSub)[execPer] < FLOAT_EPSILON)
d706 1
a706 1
      if (fssSubVol (theSub)[execPer] < unallocVol)
d708 3
a710 3
         deltaSubVol                          = fssSubVol (theSub)[execPer];
         fssSubVol (theSub).elemRef (execPer) = 0.0;
         unallocVol                          -= deltaSubVol;
d714 3
a716 3
         deltaSubVol                           = unallocVol;
         fssSubVol (theSub).elemRef (execPer) -= deltaSubVol;
         unallocVol                            = 0.0;
d820 6
a825 1
   WitFssMrpExp theFssMrpExp (myProblem (), this, myAccFlag_);
d838 12
a849 8
         WitProblem * theProblem,
         WitFSS *     theFSS,
         WitAccFlag * theAccFlag):

      WitMrpExp  (theProblem),

      myFSS_     (theFSS),
      myAccFlag_ (theAccFlag)
d877 1
a877 1
   return fssExecVol (theOpn).elemRef (execPer);
d884 1
a884 1
   return fssSubVol (theSub).elemRef (execPer);
d894 1
a894 1
      copyInto (focShortageVol (thePart), myReqVol ()(thePart));
@


1.23
log
@Continued implementation of single-source.
@
text
@d22 1
a199 2
      fssExecVol_  (),
      fssSubVol_   (),
d201 2
a202 2
      myFssMrpExp_ (NULL),
      uiScrapVol_  (),
d204 1
a204 1
      mrpIncAvail_ ()
a205 2
   myFssMrpExp_ =
      new WitFssMrpExp (myProblem (), this, fssExecVol_, fssSubVol_);
d212 1
d214 1
a214 8
   delete   myFssMrpExp_;
   }

//------------------------------------------------------------------------------

const WitTVec <double> & WitFSS::focShortageVol (WitPart * thePart)
   {
   return myFssMrpExp_->myReqVol () (thePart);
a229 2
   WitDemand * theDemand;

a239 3
   fssExecVol_.allocate (myProblem (), 0.0);
   fssSubVol_ .allocate (myProblem (), 0.0);

d241 1
a241 2
      forEachDemand (theDemand, myProblem ())
         theDemand->compFssShipVol ();
d247 1
a247 5
   myFssMrpExp_->mrp ();

   mrpIncAvail_.clear ();
   fssSubVol_  .clear ();
   fssExecVol_ .clear ();
d274 49
d330 1
a330 1
      copyInto (fssExecVol_ (theOpn), theOpn->execVol ());
d333 1
a333 1
      copyInto (fssSubVol_ (theSub), theSub->subVol ());
d488 1
a488 1
         + fssExecVol_ (uiOpn, execPer)
d508 1
a508 1
   oldExecVol      = fssExecVol_ (uiOpn, execPer);
d519 1
a519 1
   fssExecVol_ (uiOpn, execPer) -= deltaExecVol;
d631 1
a631 1
      if (fssSubVol_ (theSub, execPer) < FLOAT_EPSILON)
d634 1
a634 1
      if (fssSubVol_ (theSub, execPer) < unallocVol)
d636 3
a638 3
         deltaSubVol                  = fssSubVol_ (theSub, execPer);
         fssSubVol_ (theSub, execPer) = 0.0;
         unallocVol                  -= deltaSubVol;
d642 3
a644 3
         deltaSubVol                   = unallocVol;
         fssSubVol_ (theSub, execPer) -= deltaSubVol;
         unallocVol                    = 0.0;
d745 11
d757 1
d761 3
a763 12
         WitProblem *                        theProblem,
         WitFSS *                            theFSS,
         WitSchedule <WitOperation, float> & fssExecVolRef,
         WitSchedule <WitSubEntry, float> &  fssSubVolRef):

      WitMrpExp   (theProblem),

      fssExecVol_ (fssExecVolRef),
      fssSubVol_  (fssSubVolRef),
      myFSS_      (theFSS)
   {
   }
d765 1
a765 1
//------------------------------------------------------------------------------
d767 2
a768 1
WitFssMrpExp::~WitFssMrpExp ()
d774 1
a774 1
void WitFssMrpExp::initDerived ()
d796 1
a796 1
   return fssExecVol_ (theOpn, execPer);
d803 1
a803 1
   return fssSubVol_ (theSub, execPer);
d810 1
a810 1
   WitComponent * theComp;
d812 2
a813 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importFssResults ();
@


1.22
log
@Continued preliminary work on single source.
@
text
@a21 1
#include <Schedule.h>
d199 2
d202 2
a203 2
      myAccFlag_   (new WitAccFlag),
      uiScrapVol_  (* new WitSchedule <WitPart,     double>),
d205 1
a205 1
      mrpIncAvail_ (* new WitSchedule <WitPart,     double>)
d207 2
a214 1
   delete & mrpIncAvail_;
d216 8
a223 1
   delete & uiScrapVol_;
d239 2
d251 3
d255 2
a256 1
      compFssShipVols ();
d262 5
a266 1
   doMrp ();
a292 49
// compFssShipVols ()
//
// Local Variables:
//
// cumShipVolThePer:      Cumulative shipment volume in thePer.
// cDFHorizon:            Cumulative demand volume at the focus horizon of
//                        theDemand
// cumFssShipVolT:        Cumulative of fssShipVol ()[thePer].
// cumFssShipVolThePer_1: Cumulative of fssShipVol ()[thePer - 1].
//------------------------------------------------------------------------------

void WitFSS::compFssShipVols ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      cumShipVolThePer;
   double      cDFHorizon;
   double      cumFssShipVolThePer;
   double      cumFssShipVolThePer_1;

   forEachDemand (theDemand, myProblem ())
      {
      cumShipVolThePer = 0.0;

      cDFHorizon =
         (theDemand->focusHorizon () >= 0)?
            theDemand->cumDemandVol ()[theDemand->focusHorizon ()]:
            0.0;

      cumFssShipVolThePer = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumShipVolThePer += theDemand->shipVol ()[thePer];

         cumFssShipVolThePer_1 = cumFssShipVolThePer;

         cumFssShipVolThePer =
            (thePer <= theDemand->focusHorizon ())?
               theDemand->cumDemandVol ()[thePer]:
               max (cDFHorizon, cumShipVolThePer);

         fssShipVol (theDemand)[thePer] = 
            cumFssShipVolThePer - cumFssShipVolThePer_1;
         }
      }
   }

//------------------------------------------------------------------------------
d300 1
a300 1
      copyInto (fssExecVol (theOpn), theOpn->execVol ());
d303 1
a303 1
      copyInto (fssSubVol (theSub), theSub->subVol ());
d458 1
a458 1
         + fssExecVol (uiOpn)[execPer]
d478 1
a478 1
   oldExecVol      = fssExecVol (uiOpn)[execPer];
d489 1
a489 1
   fssExecVol (uiOpn).elemRef (execPer) -= deltaExecVol;
d601 1
a601 1
      if (fssSubVol (theSub)[execPer] < FLOAT_EPSILON)
d604 1
a604 1
      if (fssSubVol (theSub)[execPer] < unallocVol)
d606 3
a608 3
         deltaSubVol                          = fssSubVol (theSub)[execPer];
         fssSubVol (theSub).elemRef (execPer) = 0.0;
         unallocVol                          -= deltaSubVol;
d612 3
a614 3
         deltaSubVol                           = unallocVol;
         fssSubVol (theSub).elemRef (execPer) -= deltaSubVol;
         unallocVol                            = 0.0;
d715 2
d718 11
a728 1
void WitFSS::doMrp ()
a729 5
   WitFssMrpExp theFssMrpExp (myProblem (), this, myAccFlag_);

   theFssMrpExp.mrp ();

   mrpIncAvail_.clear ();
a732 3
// Implementation of class FssMrpExp.
// Declared in FssMrp.h.
//------------------------------------------------------------------------------
d734 1
a734 9
WitFssMrpExp::WitFssMrpExp (
         WitProblem * theProblem,
         WitFSS *     theFSS,
         WitAccFlag * theAccFlag):

      WitMrpExp  (theProblem),

      myFSS_     (theFSS),
      myAccFlag_ (theAccFlag)
d740 1
a740 1
WitFssMrpExp::~WitFssMrpExp ()
d762 1
a762 1
   return fssExecVol (theOpn).elemRef (execPer);
d769 1
a769 1
   return fssSubVol (theSub).elemRef (execPer);
d776 1
a776 1
   WitPart * thePart;
d778 2
a779 2
   forEachPart (thePart, myProblem ())
      copyInto (focShortageVol (thePart), myReqVol ()(thePart));
@


1.21
log
@Continued preliminary work on single source.
@
text
@d22 4
d28 1
a29 1
#include <ObjStack.h>
d202 3
a204 3
      uiScrapVol_  (),
      uiStockVol_  (),
      mrpIncAvail_ ()
d212 3
@


1.20
log
@Preliminary work on single source.
@
text
@d685 1
a685 1
         mrpIncAvail_ (thePart) = uiScrapVol_ (thePart);
@


1.19
log
@Continued implementation of object iteration.
@
text
@d420 1
a420 1
   reverseCopyInto (reversedOpns, myCompMgr ()->allOperations ());
d617 1
a617 1
   reverseCopyInto (reversedSubEntries, theBomEnt->mySubEntries ());
@


1.18
log
@Began implementation of object iteration.
@
text
@d449 1
a449 1
      uiMat  = uiPart->myMat ();
d489 1
a489 1
   uiMat   = uiPart->myMat ();
@


1.17
log
@Continued development of Selective Stock Reallocation.
@
text
@d21 1
d24 1
@


1.16
log
@Continued implementation of selective stock reallocation.
@
text
@d447 3
a449 1
      if (uiPart->getMyMaterial (uiMat))
d487 3
a489 1
   if (uiPart->getMyMaterial (uiMat))
a650 1
   WitCapacity * theCap;
d681 3
a683 2
   forEachCapacity (theCap, myProblem ())
      mrpIncAvail_ (theCap) = uiScrapVol_ (theCap);
@


1.15
log
@Converted several generic classes into class templates.
@
text
@d447 1
a447 1
      if (uiPart->isaMaterial (uiMat))
d485 1
a485 1
   if (uiPart->isaMaterial (uiMat))
@


1.14
log
@Fixed some bugs in coarse selection splitting.
@
text
@d416 1
a416 1
   WitObjStack (WitOperation) reversedOpns (myProblem ());
d607 1
a607 1
   WitObjStack (WitSubEntry) reversedSubEntries (myProblem ());
@


1.13
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d420 1
a420 1
   while (reversedOpns.get (uiOpn))
d613 1
a613 1
   while (reversedSubEntries.get (theSub))
@


1.12
log
@Further development of coarse selection splitting.
@
text
@d420 1
a420 1
   while (reversedOpns.pop (uiOpn))
d613 1
a613 1
   while (reversedSubEntries.pop (theSub))
@


1.11
log
@Some minor modifications.
@
text
@d23 1
a23 1
#include <Stack.h>
@


1.10
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d23 1
a23 1
#include <DynStack.h>
d416 1
a416 1
   WitObjDynStack (WitOperation) reversedOpns (myProblem ());
d607 1
a607 1
   WitObjDynStack (WitSubEntry) reversedSubEntries (myProblem ());
@


1.9
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d321 1
a321 1
      copyTo (fssExecVol (theOpn), theOpn->execVol ());
d324 1
a324 1
      copyTo (fssSubVol (theSub), theSub->subVol ());
d374 1
a374 1
      copyTo (uiStockVol_ (theMat), theMat->stockVol ());
d416 1
a416 1
   WitDynStack (WitOperation) reversedOpns (myProblem ());
d418 1
a418 1
   reversedOpns.reverseCopyOf (myCompMgr ()->allOperations ());
d607 1
a607 1
   WitDynStack (WitSubEntry) reversedSubEntries (myProblem ());
d611 1
a611 1
   reversedSubEntries.reverseCopyOf (theBomEnt->mySubEntries ());
d800 1
a800 1
      copyTo (focShortageVol (thePart), myReqVol ()(thePart));
@


1.8
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d78 1
a78 1
// The Operations are examined in reverse order. A Operation, uiOperation will
d82 1
a82 1
//    Its BOP contains a Part (uiPart) with significantly positive prodRate.
d87 1
a87 1
// execution periods, execPer, for uiOperation are then considered in order. If
d91 2
a92 2
// uiOperation's execVol such that uiPart's scrapVol will remain
// nonnegative and there will be no increased violation of uiOperation's
d407 2
a408 1
   WitOperation * uiOperation;
d411 1
a411 1
   WitMaterial *  uiMaterial;
d420 1
a420 1
   while (reversedOpns.pop (uiOperation))
d422 7
a428 1
      if (uiOperation->isCoproducing ())
d433 8
a440 3
      forEachEl (theBopEnt, uiOperation->bop ())
         if (theBopEnt->prodRate () > 0.0)
            uiBopEnt = theBopEnt;
d447 2
a448 4
      if (uiPart->isaMaterial (uiMaterial))
         uiMaterial->rollBackScrap (
            uiStockVol_ (uiMaterial),
            uiScrapVol_ (uiMaterial));
d453 1
a453 1
         unimplode (uiOperation, uiBopEnt, uiPart, execPer, scrapPer);
d460 1
a460 1
      WitOperation * uiOperation,
d467 1
a467 1
   WitMaterial * uiMaterial;
d477 2
a478 2
         + fssExecVol (uiOperation)[execPer]
         - uiOperation->execBounds ()->softLB ()[execPer]);
d485 2
a486 2
   if (uiPart->isaMaterial (uiMaterial))
      rollOverScrap (uiMaterial, scrapPer, prodPer);
d495 1
a495 1
   oldExecVol      = fssExecVol (uiOperation)[execPer];
d499 1
a499 6
   uiOperation->lotSizeDelta (
      execPer,
      oldExecVol,
      negDeltaExecVol,
      witTRUE,
      witTRUE);
d506 1
a506 1
   fssExecVol (uiOperation).elemRef (execPer) -= deltaExecVol;
d512 1
a512 1
   unimplodeBom (uiOperation, execPer, deltaExecVol);
d562 1
a562 1
      WitOperation * uiOperation,
d569 1
a569 1
   forEachEl (theBomEnt, uiOperation->bom ())
d575 1
a575 1
            deltaExecVol * theBomEnt->effUsageRate ();
d635 1
a635 1
         deltaSubVol * theSub->effUsageRate ();
@


1.7
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d321 1
a321 1
      fssExecVol (theOpn) = theOpn->execVol ();
d324 1
a324 1
      fssSubVol (theSub) = theSub->subVol ();
d374 1
a374 1
      copy (uiStockVol_ (theMat), theMat->stockVol ());
d795 1
a795 1
      copy (focShortageVol (thePart), myReqVol ()(thePart));
@


1.6
log
@Changed some more of the FSS and MRP stuff from float to double to fix a
   numerical problem.
@
text
@d23 1
d192 1
a192 1
      WitProbAssoc   (theProblem),
d194 5
a198 6
      computed_      (witFALSE),
      myAccFlag_     (new WitAccFlag),
      uiScrapVol_    (),
      uiStockVol_    (),
      mrpIncAvail_   (),
      theSubEntries_ ()
a379 2

   theSubEntries_.resize (maxNSubs);
d415 1
a415 3
   WitDenseList (WitOperation) allOperationsDense;

   allOperationsDense.resize (myCompMgr ()->nOperations ());
d417 1
a417 1
   copy (allOperationsDense, myCompMgr ()->allOperations ());
d419 1
a419 1
   forEachElDenseBackwards (uiOperation, allOperationsDense)
a444 2

   theSubEntries_.resize (0);
d596 1
a596 1
   WitPeriod     consPer;    // Consumption period.
a600 1
   copy (theSubEntries_, theBomEnt->mySubEntries ());
d602 7
a608 1
   forEachElDenseBackwards (theSub, theSubEntries_)
@


1.5
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d245 1
a245 1
float WitFSS::mrpSupplyVol (WitPart * thePart, WitPeriod thePer) const
d252 1
a252 1
float WitFSS::mrpDemandVol (WitPart * thePart, WitPeriod thePer) const
d491 1
a491 1
   oldExecVol   = fssExecVol (uiOperation)[execPer];
d675 1
a675 1
      copy (mrpIncAvail_ (theCap), uiScrapVol_ (theCap));  
d763 1
a763 1
float WitFssMrpExp::supplyVol (WitPart * thePart, WitPeriod thePer) 
d770 1
a770 1
float WitFssMrpExp::demandVol (WitPart * thePart, WitPeriod thePer)
@


1.4
log
@Continued implementation of stock reallocation.
@
text
@d247 1
a247 1
   return WitUtil::positivePart (mrpIncAvail_ (thePart, thePer));
d254 1
a254 1
   return WitUtil::positivePart (- mrpIncAvail_ (thePart, thePer));
d305 1
a305 1
               WitUtil::max (cDFHorizon, cumShipVolThePer);
d358 1
a358 1
            WitUtil::positivePart (- deltaFssShipVol (thePart, thePer));
d379 1
a379 1
      WitUtil::setToMax (maxNSubs, theBomEnt->mySubEntries ().nElements ());
d472 1
a472 1
      WitUtil::positivePart (
d484 1
a484 1
   WitUtil::setToMin (
d544 1
a544 1
            WitUtil::positivePart (
d548 1
a548 1
         carryOver = WitUtil::min (carryOver, maxStockInc);
d692 1
a692 1
            WitUtil::min (
d722 1
a722 1
            WitUtil::positivePart (deltaFssShipVol (thePart, thePer));
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d282 1
a282 1
   double      cumFssShipVolT;
d294 1
a294 1
      cumFssShipVolT = 0.0;
d300 1
a300 1
         cumFssShipVolThePer_1 = cumFssShipVolT;
d302 1
a302 1
         cumFssShipVolT =
d308 1
a308 1
            cumFssShipVolT - cumFssShipVolThePer_1;
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d379 1
a379 1
      WitUtil::updateToMax (maxNSubs, theBomEnt->mySubEntries ().nElements ());
d484 1
a484 1
   WitUtil::updateToMin (
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.46;
access;
symbols
	sce_5_01_20080919:1.42
	latest_sce_4_20_20060523:1.42.0.2
	sce_4_20_20060523:1.42
	latest_sce4_20_OSL:1.41.0.2
	sce_4_20_OSL:1.41
	sce_410_withVa:1.41
	sce_4_05_20040511:1.39
	sce_4_00_20040201:1.38
	nextGenBranch:1.38.0.2
	nextGenRoot:1.38
	sce_3_30_20030627:1.38
	EndRw-branch:1.36.0.4
	Root-of-EndRw:1.36
	rwToStl:1.36.0.2
	latest_sce_3_10_20010924:1.22.0.2
	sce_3_10_20010924:1.22
	latest_sce_3_00_20010601:1.14.0.2
	sce_3_00_20010601:1.14;
locks; strict;
comment	@ * @;


1.46
date	2011.09.28.23.50.26;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.24.00.28.42;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.08.30.20.18.13;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.22.21.55.32;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.02.17.34.13;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.19.23.50.58;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.13.21.25.17;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.10.22.53.21;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.11.19.08.31;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.02.22.18.51;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.13.21.31.43;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.15.21.21.39;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.12.21.02.05;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.11.15.36.32;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.09.16.05.54;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.05.20.43.59;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.12.18.01.08;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.26.15.17.18;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.20.22.28.07;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.09.00.43.49;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.10.22.06.59;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.20.00.00.18;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.19.16.17.12;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.17.16.25.43;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.28.19.19.02;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.27.21.12.14;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.24.22.03.23;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.20.15.16.35;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.17.22.00.12;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.17.20.49.20;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.03.20.07.31;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.20.20.07.07;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.30.21.16.50;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.25.22.59.14;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.25.14.53.28;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.10.22.31.15;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.24.23.09.59;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.06.19.22.11;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.03.19.23.06;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.30.18.54.48;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.26.20.28.08;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.23.19.43.25;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.21.21.55.48;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.20.21.04.00;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.13.22.12.06;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.12.19.48.09;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef SplitterH
#define SplitterH

//------------------------------------------------------------------------------
// Header file: "Splitter.h"
//
// Contains the declaration of class Splitter.
//------------------------------------------------------------------------------

#include <ObjStack.h>
#include <Assoc.h>

//------------------------------------------------------------------------------
// Class Splitter
//
// Performs selection splitting.
// 
// Implemented in SelSplit.C.
//------------------------------------------------------------------------------

class WitSplitter: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSplitter (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitSplitter ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void commitMaxQty (double & netQty);
         //
         // Commits the heuristically maximum possible quantity of topPart_ 
         // in topPer_.

      void preCommit ();
         //
         // Performs the actions to be taken for selection splitting at the
         // beginning of a commit.

      void postTempCommit (bool success);
         //
         // Performs the actions to be taken for selection splitting, just
         // after a temp-commit.

      WitSelMgr * lowestBddSelMgr ();
         //
         // Finds and returns the bounded SplitMgr owned by mySelector_ that's
         // lowest in the explosion logic, if any; otherwise returns NULL.

      void recordFlow (WitSelPt * theSelPt, double incFlowVol);
         //
         // See FlowMonitor.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitSelector *,  mySelector)
      accessFunc (WitSplitCntr *, mySplitCntr)
      accessFunc (bool,           splitCommActive)

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      bool splitCommitNeeded ();
         //
         // Returns true, iff a split-commit needs to be performed.

      void splitCommit (bool & unresFound);
         //
         // Does a split-commit.
         // On return:
         //    unresFound is true, iff an unresolveable shortage was found.

      void buildZeroPts (bool & unresFound, bool & splitFound);
         //
         // Builds up the zeroPts_ set.
         // On return:
         //    unresFound is true, iff an unresolveable shortage was found.
         //    splitFound is true, iff an opportunity to split selections was
         //       found.

      void clearSplitItr ();
         //
         // Clears data associated with one iteration of the splitCommit loop.

      bool addChgPtsToZeroPts ();
         //
         // Adds the SplitPts corresponding to the current hypothetical
         // modification and alteration points to zeroPts_.
         // Returns true, iff at least one SplitPt was added.

      void splitSels ();
         //
         // Finds the lowest zero pt at which to split the selections and does
         // so there.

      bool resAltOrRest ();
         //
         // Returns true, iff the most recent failing temp-commit generated
         // either a resolving alteration or a restriction shortage.

      WitSplitPt * findLowestZeroPt ();
         //
         // Finds and returns the lowest element of zeroPts_.

      void searchForFlow (WitSplitPt * searchPt, double theFlowVol);
         //
         // Does an extended binary search on the flow thru searchPt, assuming
         // theFlowVol fails.

      bool tempCommForSearch (WitSplitPt * searchPt, double searchVol);
         //
         // Does a temp-commit if 1 unit of top level vol, discarding all flow
         // thru the zero points and discarding all flow above searchVol thru
         // theSplitPt.

      bool tempCommDiscZeroPts ();
         //
         // Does a temp-commit if 1 unit of top level vol, discarding all flow
         // thru the zero points.

      void splitChgPts ();
         //
         // Splits the selections at each current mod point/alt point based on
         // the flow resulting from doing a temp-commit.

      void findChgSplitPts (WitObjStack <WitSplitPt> & chgSplitPts);
         //
         // Sets chgSplitPts to be the set of SplitPts corresponding to the
         // modifications that would result if (hypothetically) ps-sup were
         // updated, creating them, if necessary.

      void findHypoChanges (WitObjStack <WitSelPt> & chgSelPts);
         //
         // In pen-exec mode, sets chgSelPts to be the set of modifications and
         // alterations that would result if (hypothetically) the following
         // updates performed, based on the most recent failing temp-commit:
         // * Update ps-sup.
         // * Discard the current selection at the current resolving alteration
         //   (if any).
         //
         // In non-pen-exec mode, sets chgSelPts to be the current resolving
         // alteration, if any.

      void findHypoChangesPE (WitObjStack <WitSelPt> & chgSelPts);
         //
         // Does the pen-exec case of findHypoChanges.

      //------------------------------------------------------------------------

      accessNonNull (WitPenExMgr *, myPenExMgr)

      noCopyCtorAssign (WitSplitter);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector that owns this Splitter.

      WitFlowMonitor * myFlowMonitor_;
         //
         // The FlowMonitor owned by this Splitter.

      WitSplitCntr * mySplitCntr_;
         //
         // The SplitCntr owned by this Splitter.

      WitPenExMgr * myPenExMgr_;
         //
         // The PenExMgr associated with this Splitter, if any; otherwise NULL.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      bool penExec_;
         //
         // true, iff the penalized execution technique is to be used.

      const double splitRes_;
         //
         // Split Resolution.

      WitObjStack <WitSplitPt> zeroPts_;
         //
         // The set of SplitPts that are to discard all flow.

      bool splitCommActive_;
         //
         // true, iff an invocation of splitCommit () is currently in progress.

      WitObjStack <WitSplitPt> mySplitPts_;
         //
         // The SplitPts owned by this Splitter.
   };

#endif
@


1.45
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.44
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d26 1
a26 1
//
d31 2
a32 50
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitSplitter (WitSelector *);

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitSplitter ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void commitMaxQty (double & netQty);
//
// Commits the heuristically maximum possible quantity of topPart_
// in topPer_.

void preCommit ();
//
// Performs the actions to be taken for selection splitting at the
// beginning of a commit.

void postTempCommit (bool success);
//
// Performs the actions to be taken for selection splitting, just
// after a temp-commit.

WitSelMgr * lowestBddSelMgr ();
//
// Finds and returns the bounded SplitMgr owned by mySelector_ that's
// lowest in the explosion logic, if any; otherwise returns NULL.

void recordFlow (WitSelPt * theSelPt, double incFlowVol);
//
// See FlowMonitor.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (WitSelector *,  mySelector)
accessFunc (WitSplitCntr *, mySplitCntr)
accessFunc (bool,           splitCommActive)
d34 193
a226 145
private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

bool splitCommitNeeded ();
//
// Returns true, iff a split-commit needs to be performed.

void splitCommit (bool & unresFound);
//
// Does a split-commit.
// On return:
//    unresFound is true, iff an unresolveable shortage was found.

void buildZeroPts (bool & unresFound, bool & splitFound);
//
// Builds up the zeroPts_ set.
// On return:
//    unresFound is true, iff an unresolveable shortage was found.
//    splitFound is true, iff an opportunity to split selections was
//       found.

void clearSplitItr ();
//
// Clears data associated with one iteration of the splitCommit loop.

bool addChgPtsToZeroPts ();
//
// Adds the SplitPts corresponding to the current hypothetical
// modification and alteration points to zeroPts_.
// Returns true, iff at least one SplitPt was added.

void splitSels ();
//
// Finds the lowest zero pt at which to split the selections and does
// so there.

bool resAltOrRest ();
//
// Returns true, iff the most recent failing temp-commit generated
// either a resolving alteration or a restriction shortage.

WitSplitPt * findLowestZeroPt ();
//
// Finds and returns the lowest element of zeroPts_.

void searchForFlow (WitSplitPt * searchPt, double theFlowVol);
//
// Does an extended binary search on the flow thru searchPt, assuming
// theFlowVol fails.

bool tempCommForSearch (WitSplitPt * searchPt, double searchVol);
//
// Does a temp-commit if 1 unit of top level vol, discarding all flow
// thru the zero points and discarding all flow above searchVol thru
// theSplitPt.

bool tempCommDiscZeroPts ();
//
// Does a temp-commit if 1 unit of top level vol, discarding all flow
// thru the zero points.

void splitChgPts ();
//
// Splits the selections at each current mod point/alt point based on
// the flow resulting from doing a temp-commit.

void findChgSplitPts (WitObjStack <WitSplitPt> & chgSplitPts);
//
// Sets chgSplitPts to be the set of SplitPts corresponding to the
// modifications that would result if (hypothetically) ps-sup were
// updated, creating them, if necessary.

void findHypoChanges (WitObjStack <WitSelPt> & chgSelPts);
//
// In pen-exec mode, sets chgSelPts to be the set of modifications and
// alterations that would result if (hypothetically) the following
// updates performed, based on the most recent failing temp-commit:
// * Update ps-sup.
// * Discard the current selection at the current resolving alteration
//   (if any).
//
// In non-pen-exec mode, sets chgSelPts to be the current resolving
// alteration, if any.

void findHypoChangesPE (WitObjStack <WitSelPt> & chgSelPts);
//
// Does the pen-exec case of findHypoChanges.

//------------------------------------------------------------------------

accessNonNull (WitPenExMgr *, myPenExMgr)

noCopyCtorAssign (WitSplitter);

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Associations.
//------------------------------------------------------------------------

WitSelector * const mySelector_;
//
// The Selector that owns this Splitter.

WitFlowMonitor * myFlowMonitor_;
//
// The FlowMonitor owned by this Splitter.

WitSplitCntr * mySplitCntr_;
//
// The SplitCntr owned by this Splitter.

WitPenExMgr * myPenExMgr_;
//
// The PenExMgr associated with this Splitter, if any; otherwise NULL.

//------------------------------------------------------------------------
// Other private member data.
//------------------------------------------------------------------------

bool penExec_;
//
// true, iff the penalized execution technique is to be used.

const double splitRes_;
//
// Split Resolution.

WitObjStack <WitSplitPt> zeroPts_;
//
// The set of SplitPts that are to discard all flow.

bool splitCommActive_;
//
// true, iff an invocation of splitCommit () is currently in progress.

WitObjStack <WitSplitPt> mySplitPts_;
//
// The SplitPts owned by this Splitter.
};
@


1.43
log
@Selection Recovery.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d26 1
a26 1
// 
d31 50
a80 2
   {
   public:
d82 145
a226 193
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSplitter (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitSplitter ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void commitMaxQty (double & netQty);
         //
         // Commits the heuristically maximum possible quantity of topPart_ 
         // in topPer_.

      void preCommit ();
         //
         // Performs the actions to be taken for selection splitting at the
         // beginning of a commit.

      void postTempCommit (bool success);
         //
         // Performs the actions to be taken for selection splitting, just
         // after a temp-commit.

      WitSelMgr * lowestBddSelMgr ();
         //
         // Finds and returns the bounded SplitMgr owned by mySelector_ that's
         // lowest in the explosion logic, if any; otherwise returns NULL.

      void recordFlow (WitSelPt * theSelPt, double incFlowVol);
         //
         // See FlowMonitor.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitSelector *,  mySelector)
      accessFunc (WitSplitCntr *, mySplitCntr)
      accessFunc (bool,           splitCommActive)

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      bool splitCommitNeeded ();
         //
         // Returns true, iff a split-commit needs to be performed.

      void splitCommit (bool & unresFound);
         //
         // Does a split-commit.
         // On return:
         //    unresFound is true, iff an unresolveable shortage was found.

      void buildZeroPts (bool & unresFound, bool & splitFound);
         //
         // Builds up the zeroPts_ set.
         // On return:
         //    unresFound is true, iff an unresolveable shortage was found.
         //    splitFound is true, iff an opportunity to split selections was
         //       found.

      void clearSplitItr ();
         //
         // Clears data associated with one iteration of the splitCommit loop.

      bool addChgPtsToZeroPts ();
         //
         // Adds the SplitPts corresponding to the current hypothetical
         // modification and alteration points to zeroPts_.
         // Returns true, iff at least one SplitPt was added.

      void splitSels ();
         //
         // Finds the lowest zero pt at which to split the selections and does
         // so there.

      bool resAltOrRest ();
         //
         // Returns true, iff the most recent failing temp-commit generated
         // either a resolving alteration or a restriction shortage.

      WitSplitPt * findLowestZeroPt ();
         //
         // Finds and returns the lowest element of zeroPts_.

      void searchForFlow (WitSplitPt * searchPt, double theFlowVol);
         //
         // Does an extended binary search on the flow thru searchPt, assuming
         // theFlowVol fails.

      bool tempCommForSearch (WitSplitPt * searchPt, double searchVol);
         //
         // Does a temp-commit if 1 unit of top level vol, discarding all flow
         // thru the zero points and discarding all flow above searchVol thru
         // theSplitPt.

      bool tempCommDiscZeroPts ();
         //
         // Does a temp-commit if 1 unit of top level vol, discarding all flow
         // thru the zero points.

      void splitChgPts ();
         //
         // Splits the selections at each current mod point/alt point based on
         // the flow resulting from doing a temp-commit.

      void findChgSplitPts (WitObjStack <WitSplitPt> & chgSplitPts);
         //
         // Sets chgSplitPts to be the set of SplitPts corresponding to the
         // modifications that would result if (hypothetically) ps-sup were
         // updated, creating them, if necessary.

      void findHypoChanges (WitObjStack <WitSelPt> & chgSelPts);
         //
         // In pen-exec mode, sets chgSelPts to be the set of modifications and
         // alterations that would result if (hypothetically) the following
         // updates performed, based on the most recent failing temp-commit:
         // * Update ps-sup.
         // * Discard the current selection at the current resolving alteration
         //   (if any).
         //
         // In non-pen-exec mode, sets chgSelPts to be the current resolving
         // alteration, if any.

      void findHypoChangesPE (WitObjStack <WitSelPt> & chgSelPts);
         //
         // Does the pen-exec case of findHypoChanges.

      //------------------------------------------------------------------------

      accessNonNull (WitPenExMgr *, myPenExMgr)

      noCopyCtorAssign (WitSplitter);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector that owns this Splitter.

      WitFlowMonitor * myFlowMonitor_;
         //
         // The FlowMonitor owned by this Splitter.

      WitSplitCntr * mySplitCntr_;
         //
         // The SplitCntr owned by this Splitter.

      WitPenExMgr * myPenExMgr_;
         //
         // The PenExMgr associated with this Splitter, if any; otherwise NULL.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      bool penExec_;
         //
         // true, iff the penalized execution technique is to be used.

      const double splitRes_;
         //
         // Split Resolution.

      WitObjStack <WitSplitPt> zeroPts_;
         //
         // The set of SplitPts that are to discard all flow.

      bool splitCommActive_;
         //
         // true, iff an invocation of splitCommit () is currently in progress.

      WitObjStack <WitSplitPt> mySplitPts_;
         //
         // The SplitPts owned by this Splitter.
   };
@


1.42
log
@Updated the copyright date on all source files.
@
text
@d94 1
a94 1
         // Does a split-commit for SSPE.
@


1.41
log
@Low-Pri Prop-Rt.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.40
log
@Low-Pri Prop-Rt.
@
text
@a173 5
      // Safe internal access functions.
      //------------------------------------------------------------------------

      accessNonNull (WitExpRest *,    myExpRest)
      accessNonNull (WitRtAnalyzer *, myRtAnalyzer)
d175 1
a175 1
      //------------------------------------------------------------------------
d199 1
a199 5
      WitExpRest * myExpRest_;
         //
         // The ExpRest associated with this Splitter.

      WitRtAnalyzer * myRtAnalyzer_;
d201 1
a201 1
         // The RtAnalyzer associated with this Splitter.
@


1.39
log
@Double Precision.
@
text
@d26 2
@


1.38
log
@Continued implementation of proportionate routing.
@
text
@d218 1
a218 1
      const float splitRes_;
@


1.37
log
@Internal changes.
@
text
@d128 1
a128 1
      double findSplitBound (WitSplitPt * searchPt, double theFlowVol);
d130 2
a131 7
         // Computes and returns the split bound for searchPt, given
         // theFlowVol.

      double binarySearch (WitSplitPt * searchPt, double theFlowVol);
         //
         // Computes and returns the split bound for searchPt, given
         // theFlowVol, using a binary search.
d144 1
a144 1
      void splitChgPts (WitSplitPt * searchPt, double splitBound);
d147 1
a147 2
         // the flow resulting from doing a temp-commit, applying splitBound at
         // searchPt.
@


1.36
log
@Continued implementation of single source.
@
text
@d58 1
a58 1
      void postTempCommit (WitBoolean success);
d78 1
a78 1
      accessFunc (WitBoolean,     splitCommActive)
d86 1
a86 1
      WitBoolean splitCommitNeeded ();
d88 1
a88 1
         // Returns TRUE, iff a split-commit needs to be performed.
d90 1
a90 1
      void splitCommit (WitBoolean & unresFound);
d94 1
a94 1
         //    unresFound is TRUE, iff an unresolveable shortage was found.
d96 1
a96 1
      void buildZeroPts (WitBoolean & unresFound, WitBoolean & splitFound);
d100 2
a101 2
         //    unresFound is TRUE, iff an unresolveable shortage was found.
         //    splitFound is TRUE, iff an opportunity to split selections was
d108 1
a108 1
      WitBoolean addChgPtsToZeroPts ();
d112 1
a112 1
         // Returns TRUE, iff at least one SplitPt was added.
d119 1
a119 1
      WitBoolean resAltOrRest ();
d121 1
a121 1
         // Returns TRUE, iff the most recent failing temp-commit generated
d138 1
a138 1
      WitBoolean tempCommForSearch (WitSplitPt * searchPt, double searchVol);
d144 1
a144 1
      WitBoolean tempCommDiscZeroPts ();
d220 1
a220 1
      WitBoolean penExec_;
d222 1
a222 1
         // TRUE, iff the penalized execution technique is to be used.
d232 1
a232 1
      WitBoolean splitCommActive_;
d234 1
a234 1
         // TRUE, iff an invocation of splitCommit () is currently in progress.
@


1.35
log
@Continued implementation of sel-split for pen-exec.
@
text
@d25 1
a25 1
// Performs selection splitting for penalized execution.
@


1.34
log
@Continued implementation of sel-split for pen-exec.
@
text
@a18 1
#include <PairStack.h>
d20 1
d63 5
d70 1
a70 3
         // Records the fact that incFlowVol additional units are being flowed
         // thru theSelPt.
         // No-op, if not in flow-monitoring mode.
a118 26
      void startFlowMon ();
         //
         // Initiates flow-monitoring mode.

      void finishFlowMon ();
         //
         // Concludes flow-monitoring mode.

      WitBoolean splitIsNeeded (
            WitSelPt * theSelPt, 
            WitBoolean compToSuccess,
            double &   flowGap);
         //
         // Returns TRUE, iff the selection needs to be split at theSelPt. 
         // If compToSuccess is TRUE, the failing flow will be compared to the
         // successful flow; otherwise it will be compared to 0.
         // On Return, flowGap will be the flow gap at theSelPt.
         // Valid only in flow-monitoring mode.

      double flowThruSelPt (
            WitSelPt *               theSelPt,
            const WitSelPtDblStack & theFlowPairs);
         //
         // Returns the total flow through theSelPt, that's recorded in
         // theFlowPairs.

d200 4
a234 21

      WitBoolean flowMonMode_;
         //
         // TRUE, iff this Splitter is in flow-monitoring mode.

      WitSelPtDblStack curFlowPairs_;
         //
         // For each SelPt, theSelPt the total flowVol thru theSelPt during the
         // current temp-commit is given by:
         //
         //    sum over (theSelPt, incFlowVol) in curFlowPairs_ of incFlowVol.

      WitSelPtDblStack okFlowPairs_;
         //
         // Same as curFlowPairs_, but for the most recent successful 
         // temp-commit, if any.

      WitSelPtDblStack failFlowPairs_;
         //
         // Same as curFlowPairs_, but for the most recent failing temp-commit,
         // if any.
@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@a20 1
#include <Mapping.h>
d25 1
a25 3
// Responsible for the abstract aspects of selection splitting.
//
// Implemented in SelSplit.C.
a29 2
      friend WitSplitMgr;

d48 5
d58 1
a58 1
      void postCommit ();
d60 2
a61 6
         // Performs the actions to be taken for selection splitting at the
         // end of a commit.

      void startFlowMon ();
         //
         // Initiates flow-monitoring mode.
d69 15
a83 1
      void finishFlowMon ();
d85 1
a85 1
         // Concludes flow-monitoring mode.
d87 1
a87 1
      void recCommitItr (WitPart * thePart);
d89 3
a91 3
         // Records the fact that an iteration of the commit loop for thePart is
         // about to begin.
         // Valid only in fastMode.
d93 1
a93 1
      WitBoolean skipCommitItr (WitPart * thePart);
d95 5
a99 3
         // Returns TRUE, iff an iteration of the commit loop for thePart should
         // be skipped.
         // Valid only in fastMode.
d101 1
a101 1
      void recSplitExp (WitSplitPt * theSplitPt);
d103 1
a103 3
         // Records the fact that a split explosion is being initiated at
         // theSplitPt.
         // Valid only in fastMode.
d105 1
a105 1
      void postTempCommit (WitBoolean success);
d107 3
a109 2
         // Performs the actions to be taken for selection splitting, just
         // after a temp-commit.
d111 1
a111 1
      void alterSelections ();
d113 2
a114 2
         // Alters the selections, as appropriate, temporarily splitting as
         // needed.
d116 3
a118 3
      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------
d120 3
a122 9
      accessFunc (WitSelector *, mySelector)
      accessFunc (WitBoolean,    fastMode)
      accessFunc (WitBoolean,    splitCommActive)

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------
d142 6
a147 1
      void splitCommit (WitSelPt * theSelPt);
d149 1
a149 1
         // Does a split-commit on theSelPt.
d151 1
a151 4
      void splitItr (
            WitBoolean & tempCommOK, 
            WitBoolean & resFound,
            WitBoolean & splitDone);
d153 13
a165 6
         // Does one iteration of a split-commit.
         // On return:
         //    tempCommOK is TRUE, iff the initial temp-commit was successful.
         //    resFound is TRUE, iff a resolving alteration was found and 
         //       performed.
         //    splitDone is TRUE, iff a selection was split.
d167 1
a167 1
      void splitSelection (WitSelPt * theSelPt, double theFlowVol);
d169 2
a170 2
         // Attempts to split the selection at theSelPt.
         // theFlowVol is the flowVol thru theSelPt on the temp-commit-1.
d172 1
a172 1
      double findSplitBound (WitSplitPt * theSplitPt, double theFlowVol);
d174 3
a176 2
         // Computes and returns the split bound for theSplitPt, given
         // theFlowVol.
d178 1
a178 1
      void initNetSplitLists ();
d180 3
a182 2
         // Sets all the net splits lists for this Splitter to the corresponding
         // split lists.
d184 8
a191 1
      void restoreToSearchPart ();
d193 2
a194 4
         // Restores heuristic allocation to the state it was in at the
         // beginning of the searchPart_'s iteration in the loop in 
         // HeurAtor::innerCommit.
         // Valid only in fastMode.
d196 1
a196 1
      void restoreAllVals ();
d198 10
a207 2
         // Restores heuristic allocation to the state it was in at the
         // beigging of the commit.
d215 4
d223 20
d247 1
a247 1
      WitBoolean fastMode_;
d249 1
a249 1
         // TRUE, iff the special code to increase speed is to be used.
a278 37

      WitSplitCntr * mySplitCntr_;
         //
         // The SplitCntr owned by this Splitter.

      //------------------------------------------------------------------------
      // The remaining data members are valid only in fast mode.
      //------------------------------------------------------------------------

      WitBoolean firstTCActive_;
         //
         // TRUE, iff the tempCommit at the beginning of splitItr is currently
         // in progress.

      WitObjStack <WitSplitPt> nettedSplitPts_;
         //
         // The set of SplitPts owned by this Splitter whose net split list is
         // no longer the same as its split list.

      int nCurNettedPts_;
         //
         // # elements in nettedSplitPts_.

      WitMapping (WitPart, int) nSavedDbls_;
      WitMapping (WitPart, int) nSavedPers_;
      WitMapping (WitPart, int) nNettedPts_;
         //
         // nSavedDbls_ (thePart) == HeurAtor::myDblArch_->nSavedVals () at the
         // beginning of the thePart's iteration in the loop in 
         // HeurAtor::innerCommit.
         // nSavedPers_ is similar, but for myPerArch_.
         // nNettedPts_ is similar, but for nCurNettedPts_.

      WitPart * searchPart_;
         //
         // The fill Part corresponding to the search point, during
         // splitSelection; otherwise NULL.
@


1.32
log
@Continued implementation of sel-split for pen-exec,
@
text
@d33 1
a33 1
      friend WitSsPeMgr;
@


1.31
log
@Continued implementation of sel-split for pen-exec.
@
text
@a76 4
      void resetFlowMon ();
         //
         // Clears flow-monitoring data.

d119 4
a122 1
      WitBoolean splitIsNeeded (WitSelPt * theSelPt, double & flowGap);
d125 2
@


1.30
log
@Continued implementation of sel-split for pen-exec.
@
text
@d81 1
a81 1
      void recCommitItr (WitPart * thePart, WitBoolean & skipItr);
d84 7
a90 2
         // about to begin. On return, skipItr is TRUE, iff the iteration
         // should be skipped.
d95 1
a95 1
         // Records the fact that a spliot explosion is being initiated at
@


1.29
log
@Continued implementation of sel-split for pen-exec.
@
text
@d77 4
@


1.28
log
@Continued implementation of sel-split for pen-exec.
@
text
@a76 4
      void resetFlowMon ();
         //
         // Puts flow-monitoring mode into its initial state.

@


1.27
log
@Fixed a subtle bug in sel-split for stock reallocation.
Continued implementation of sel-split for pen-exec.
@
text
@d77 4
@


1.26
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d82 1
d88 1
d105 1
d163 1
d184 4
d217 8
a252 4

      WitSplitCntr * mySplitCntr_;
         //
         // The SplitCntr owned by this Splitter.
@


1.25
log
@Fixed bug regarding booleans for sel-split for stock reallocation.
@
text
@d33 2
d73 4
a126 4

      void finishFlowMon ();
         //
         // Concludes flow-monitoring mode.
@


1.24
log
@Initial implementation of selection splitting for multi-route.
@
text
@d111 7
@


1.23
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d67 1
a67 1
         // Records the fact that incFlowVol additional units are bring flowed
@


1.22
log
@Refactoring for constrained stock reallocation.
@
text
@d226 2
a227 2
         // The fill Part corresponding to the search point, during EBS;
         // otherwise NULL.
@


1.21
log
@Fixed a latent bug.
@
text
@a156 17
      void countSplits1 (WitBoolean tempCommOK);
      void countSplits2 (WitBoolean tempCommOK);
         //
         // Does counting of split info for debugging purposes, cases 1 & 2.

      void initItrCounts ();
         //
         // Intializes nSplitComsForIdx_, etc.

      void countItrs (int nItrs, WitBoolean success);
         //
         // Updates nSplitComsForIdx_.

      void printCounts ();
         //
         // Prints splitting count info.

d229 1
a229 43
      //------------------------------------------------------------------------
      // Data for debugging output.
      //------------------------------------------------------------------------

      int nCurSplits_;
         //
         // # of splits defined in current call to splitCommit.

      int nSplitsDone_;
         //
         // # of splits actually committed.

      int nSplitsDiscarded_;
         //
         // # of splits defined but never used.

      int nUnsplitCaseA_;
      int nUnsplitCaseB_;
      int nUnsplitCaseC_;
      int nUnsplitCaseD_;
      int nUnsplitCaseE_;
         //
         // # of unsplit resolving alterations, cases A through G.

      int nSplitSplitComs_;
         //
         // # of calls to splitCommit in which at least one split was done.

      int nUnsplitSplitComs_;
         //
         // # of calls to splitCommit in which no split was done.

      WitVector (int) maxNItrsForIdx_;
         //
         // Split-com set[theIdx] is defined to be the set of split-coms such
         // that maxNItrsForIdx_[theIdx - 1] < nItrs <= maxNItrsForIdx_[theIdx].

      WitVector (int) nSplitSCforIdx_;
         //
         // nSplitSCforIdx_  [theIdx] == # split   split-coms in 
         // split-com set[theIdx].

      WitVector (int) nUnsplitSCforIdx_;
d231 1
a231 2
         // nUnsplitSCforIdx_[theIdx] == # unsplit split-coms in 
         // split-com set[theIdx].
@


1.20
log
@Refactoring for constrained stock reallocation.
@
text
@d53 7
a59 2
         // Performs the actions to be taken for selection splitting, just
         // before a commit.
d71 1
a71 1
      WitBoolean skipCommitItr (WitPart * thePart);
d73 3
a75 3
         // Records the fact that an iteration of the commit loop has just
         // begun for thePart. 
         // Returns TRUE, iff the iteration should be skipped.
d77 1
a77 1
      WitBoolean skipRestore ();
d79 2
a80 2
         // Returns TRUE, iff the state restoration at the end of commit should
         // be skipped.
d136 11
a146 1
      void restoreAllExcept (int nDblsToLeave, int nPersToLeave);
d148 8
a155 1
         // Restores heuristic allocation to the state indicated by the args.
d222 9
d233 1
d238 2
a239 1
         // nSavedDbls_ is similar, but for myPerArch_.
@


1.19
log
@Removed special sel-split timing code.
@
text
@d51 5
@


1.18
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d112 1
a112 2
            WitBoolean & splitDone,
            WitBoolean   inLoop);
a119 2
         // inLoop is TRUE, iff this function is being called from the sel-split
         //    loop.
@


1.17
log
@Implemented an iteration upper bound for selection splitting.
@
text
@d21 1
a21 1
#include <Assoc.h>
d61 11
d129 4
d193 22
a217 1
         // For debugging output.
a221 1
         // For debugging output.
a225 1
         // For debugging output.
a233 1
         // For debugging output.
a237 1
         // For debugging output.
a241 1
         // For debugging output.
@


1.16
log
@Moved Stack template implementations to header files.
@
text
@d101 2
a102 1
            WitBoolean & splitDone);
d110 2
d123 12
d211 15
@


1.15
log
@Converted several generic classes into class templates.
@
text
@d19 1
a19 1
#include <PairSt.h>
@


1.14
log
@Refactoring for sel-split for multi-exec.
@
text
@d159 1
a159 1
      WitObjStack (WitSplitPt) mySplitPts_;
@


1.13
log
@Various refactorings for sel-split for multi-exec.
@
text
@a70 5
      void applySearchVolAsNeeded (WitSplitPt * theSplitPt, double & splitVol);
         //
         // If this Splitter is currently searching on theSplitPt, this function
         // applies netSearchVol_ to splitVol.

d75 2
a76 1
      accessFunc (WitBoolean, splitCommActive)
a114 5
      WitBoolean tempCommForSearch (WitSplitPt * theSplitPt, double searchVol);
         //
         // Does a temp-commit if 1 unit of top level vol for splitting the
         // selection at theSplitPt, applying searchVol at theSplitPt.

a157 10

      WitSplitPt * searchPt_;
         //
         // The SplitPt whose splitBound is being determined by an EBS, if any;
         // otherwise NULL.

      double netSearchVol_;
         //
         // During a call to tempCommit1, this is the searchVol that was
         // passed, netted against any flow; otherwise -1.
@


1.12
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d71 1
a71 1
      void applySearchVol (double & splitVol);
d73 2
a74 6
         // Applies netSearchVol_ to splitVol.

      inline WitBoolean isSearchingAt (WitSelPt * theSelPt)
         {
         return (searchPt_ != NULL) && (theSelPt == searchPt_);
         }
d119 1
a119 1
      WitBoolean tempCommForSearch (WitSelPt * theSelPt, double searchVol);
d122 1
a122 1
         // selection at theSelPt, applying searchVol at theSelPt.
d168 1
a168 1
      WitSelPt * searchPt_;
d170 1
a170 1
         // The SelPt whose splitBound is being determined by an EBS, if any;
@


1.11
log
@Renamed AltPt classes to SelPt classes.
@
text
@d20 1
d26 3
a28 1
// Responsible for generic aspects of selection splitting.
d181 4
@


1.10
log
@Added various counts to the debugging output of selection splitting.
@
text
@d52 1
a52 1
      void recordFlow (WitAltPt * theAltPt, double incFlowVol);
d55 1
a55 1
         // thru theAltPt.
d72 1
a72 1
      inline WitBoolean isSearchingAt (WitAltPt * theAltPt)
d74 1
a74 1
         return (searchPt_ != NULL) && (theAltPt == searchPt_);
d89 1
a89 1
      WitBoolean splitIsNeeded (WitAltPt * theAltPt, double & flowGap);
d91 2
a92 2
         // Returns TRUE, iff the selection needs to be split at theAltPt. 
         // On Return, flowGap will be the flow gap at theAltPt.
d95 1
a95 1
      void splitCommit (WitAltPt * theAltPt);
d97 1
a97 1
         // Does a split-commit on theAltPt.
d115 1
a115 1
      void splitSelection (WitAltPt * theAltPt, double theFlowVol);
d117 2
a118 2
         // Attempts to split the selection at theAltPt.
         // theFlowVol is the flowVol thru theAltPt on the temp-commit-1.
d120 1
a120 1
      WitBoolean tempCommForSearch (WitAltPt * theAltPt, double searchVol);
d123 1
a123 1
         // selection at theAltPt, applying searchVol at theAltPt.
d152 1
a152 1
      WitAltPtDblStack curFlowPairs_;
d154 1
a154 1
         // For each AltPt, theAltPt the total flowVol thru theAltPt during the
d157 1
a157 1
         //    sum over (theAltPt, incFlowVol) in curFlowPairs_ of incFlowVol.
d159 1
a159 1
      WitAltPtDblStack okFlowPairs_;
d164 1
a164 1
      WitAltPtDblStack failFlowPairs_;
d169 1
a169 1
      WitAltPt * searchPt_;
d171 1
a171 1
         // The AltPt whose splitBound is being determined by an EBS, if any;
@


1.9
log
@Re-worked the controls for selection splitting.
@
text
@d115 1
a115 1
      WitBoolean splitSelection (WitAltPt * theAltPt, double theFlowVol);
a117 1
         // Returns TRUE, iff the attempt was successful.
d125 5
d178 34
@


1.8
log
@Continued implementation of selection splitting.
@
text
@d136 4
@


1.7
log
@Continued implementation of selection splitting.
@
text
@d68 1
a68 1
      void applySearchVolIA (WitAltPt * theAltPt, double & netToSplitVol);
d70 1
a70 2
         // If theAltPt is the searchPt, netSearchVol_ is applied to
         // netToSplitVol.
d77 6
d135 4
@


1.6
log
@Continued implementation of selection splitting.
@
text
@d68 1
a68 1
      void boundBySearchVol (double & splitVol);
d70 2
a71 1
         // Bounds splitVol by netSearchVol_ and reduces netSearchVol_.
@


1.5
log
@Continued implementation of selection splitting with the new design.
@
text
@d48 4
d56 1
d63 1
a63 1
      WitBoolean splitCommitIfNeeded (WitAltPt * theAltPt);
d65 2
a66 6
         // Does a split-commit on theAltPt, if one is needed.
         // Returns TRUE, iff a split-commit was done.

      void clearFlows ();
         //
         // Clears the flow data.
d83 1
a83 1
      WitBoolean checkForSplit (WitAltPt * theAltPt, double & flowGap);
d85 11
a95 2
         // Determines whether or not the selection needs to be split at
         // theAltPt. Returns TRUE, iff it does.
a108 5
      WitBoolean tempCommit1 (WitAltPt * theAltPt, double searchVol);
         //
         // Does a temp-commit if 1 unit of top level vol for splitting the
         // selection at theAltPt, applying searchVol at theAltPt.

d115 5
d129 4
@


1.4
log
@Continued implementation of selection splitting with the new design.
@
text
@d67 1
a67 1
      void netWithSearchVol (double & splitVol);
d69 1
a69 1
         // Nets splitVol with netSearchVol_.
a85 1
         // Clears the flow data.
@


1.3
log
@Continued implementation of selection splitting with the new design.
@
text
@d58 1
a58 1
      WitBoolean checkForSplit (WitAltPt * theAltPt, double & flowGap);
d60 2
a61 3
         // Determines whether or not the selection needs to be split at
         // theAltPt. Returns TRUE, iff it does.
         // Clears the flow data.
a66 5
      void splitSelection (WitAltPt * theAltPt, double theFlowVol);
         //
         // Splits the selection at theAltPt.
         // theFlowVol is the flowVol thru theAltPt on the temp-commit-1.

d82 18
d104 6
@


1.2
log
@Continued implementation of selection splitting.
@
text
@d36 1
a36 1
      WitSplitter (WitProblem *);
d58 1
a58 3
      void clearSplit ();

      WitBoolean checkForSplit (WitAltPt * theAltPt);
d67 2
a68 5
         
      inline WitBoolean splitNeeded ()
         {
         return (splitAltPt_ != NULL);
         }
d70 2
a71 1
         // Returns TRUE, iff the selection currently needs to be split.
d73 3
a75 3
      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------
d77 4
a80 1
      accessFunc (WitAltPt *, splitAltPt)
d88 5
d99 4
d120 6
a125 1
      WitAltPt * splitAltPt_;
d127 2
a128 2
         // The AltPt currently under consideration for selection splitting, if
         // any, else NULL.
@


1.1
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d58 3
a60 1
      WitBoolean needsToSplit (WitAltPt * theAltPt);
d62 3
a64 2
         // Returns TRUE, iff the selection is to be split at theAltPt.
         // Clear the flow data.
d69 13
d111 5
@


head	1.237;
access;
symbols
	sce_5_01_20080919:1.190
	latest_sce_4_20_20060523:1.172.0.2
	sce_4_20_20060523:1.172
	latest_sce4_20_OSL:1.171.0.2
	sce_4_20_OSL:1.171
	sce_410_withVa:1.167
	sce_4_05_20040511:1.136
	sce_4_00_20040201:1.132
	nextGenBranch:1.117.0.2
	nextGenRoot:1.117
	sce_3_30_20030627:1.115
	EndRw-branch:1.70.0.2
	Root-of-EndRw:1.70
	rwToStl:1.67.0.2
	latest_sce_3_10_20010924:1.16.0.2
	sce_3_10_20010924:1.16;
locks; strict;
comment	@ * @;


1.237
date	2011.09.28.23.49.24;	author rjw;	state Exp;
branches;
next	1.236;

1.236
date	2011.09.24.00.27.44;	author rjw;	state Exp;
branches;
next	1.235;

1.235
date	2011.08.30.20.17.32;	author rjw;	state Exp;
branches;
next	1.234;

1.234
date	2010.09.29.22.21.21;	author rjw;	state Exp;
branches;
next	1.233;

1.233
date	2010.09.28.22.38.18;	author rjw;	state Exp;
branches;
next	1.232;

1.232
date	2010.09.24.18.17.21;	author rjw;	state Exp;
branches;
next	1.231;

1.231
date	2010.09.24.15.46.14;	author rjw;	state Exp;
branches;
next	1.230;

1.230
date	2010.09.24.00.16.26;	author rjw;	state Exp;
branches;
next	1.229;

1.229
date	2010.09.22.20.21.52;	author rjw;	state Exp;
branches;
next	1.228;

1.228
date	2010.09.21.21.19.13;	author rjw;	state Exp;
branches;
next	1.227;

1.227
date	2010.09.17.22.20.53;	author rjw;	state Exp;
branches;
next	1.226;

1.226
date	2010.09.13.21.13.19;	author rjw;	state Exp;
branches;
next	1.225;

1.225
date	2010.09.10.23.22.43;	author rjw;	state Exp;
branches;
next	1.224;

1.224
date	2010.09.10.23.17.47;	author rjw;	state Exp;
branches;
next	1.223;

1.223
date	2010.09.10.20.30.57;	author rjw;	state Exp;
branches;
next	1.222;

1.222
date	2010.09.10.20.12.07;	author rjw;	state Exp;
branches;
next	1.221;

1.221
date	2010.09.10.16.03.49;	author rjw;	state Exp;
branches;
next	1.220;

1.220
date	2010.09.07.23.50.33;	author rjw;	state Exp;
branches;
next	1.219;

1.219
date	2010.09.02.18.58.24;	author rjw;	state Exp;
branches;
next	1.218;

1.218
date	2010.09.01.20.25.24;	author rjw;	state Exp;
branches;
next	1.217;

1.217
date	2010.08.13.21.28.08;	author rjw;	state Exp;
branches;
next	1.216;

1.216
date	2010.08.12.23.18.15;	author rjw;	state Exp;
branches;
next	1.215;

1.215
date	2010.08.10.20.42.35;	author rjw;	state Exp;
branches;
next	1.214;

1.214
date	2010.07.30.20.20.13;	author rjw;	state Exp;
branches;
next	1.213;

1.213
date	2010.07.23.23.18.20;	author rjw;	state Exp;
branches;
next	1.212;

1.212
date	2010.07.02.18.53.10;	author rjw;	state Exp;
branches;
next	1.211;

1.211
date	2010.07.01.22.41.20;	author rjw;	state Exp;
branches;
next	1.210;

1.210
date	2010.06.29.23.25.14;	author rjw;	state Exp;
branches;
next	1.209;

1.209
date	2010.06.29.22.32.31;	author rjw;	state Exp;
branches;
next	1.208;

1.208
date	2010.06.25.19.44.13;	author rjw;	state Exp;
branches;
next	1.207;

1.207
date	2010.06.25.15.42.52;	author rjw;	state Exp;
branches;
next	1.206;

1.206
date	2010.06.24.18.19.58;	author rjw;	state Exp;
branches;
next	1.205;

1.205
date	2010.06.22.19.25.20;	author rjw;	state Exp;
branches;
next	1.204;

1.204
date	2010.06.21.22.06.46;	author rjw;	state Exp;
branches;
next	1.203;

1.203
date	2010.06.21.19.45.29;	author rjw;	state Exp;
branches;
next	1.202;

1.202
date	2010.06.21.17.36.30;	author rjw;	state Exp;
branches;
next	1.201;

1.201
date	2010.06.18.23.11.14;	author rjw;	state Exp;
branches;
next	1.200;

1.200
date	2010.06.18.18.03.49;	author rjw;	state Exp;
branches;
next	1.199;

1.199
date	2010.06.18.17.47.45;	author rjw;	state Exp;
branches;
next	1.198;

1.198
date	2010.06.18.16.26.06;	author rjw;	state Exp;
branches;
next	1.197;

1.197
date	2010.06.18.14.41.17;	author rjw;	state Exp;
branches;
next	1.196;

1.196
date	2010.06.17.22.04.44;	author rjw;	state Exp;
branches;
next	1.195;

1.195
date	2010.06.17.19.13.22;	author rjw;	state Exp;
branches;
next	1.194;

1.194
date	2010.06.17.18.50.54;	author rjw;	state Exp;
branches;
next	1.193;

1.193
date	2010.06.17.16.17.14;	author rjw;	state Exp;
branches;
next	1.192;

1.192
date	2010.06.16.21.41.26;	author rjw;	state Exp;
branches;
next	1.191;

1.191
date	2009.10.06.21.06.11;	author rjw;	state Exp;
branches;
next	1.190;

1.190
date	2007.11.12.20.27.37;	author rjw;	state Exp;
branches;
next	1.189;

1.189
date	2007.11.12.16.30.12;	author rjw;	state Exp;
branches;
next	1.188;

1.188
date	2007.11.09.00.40.46;	author rjw;	state Exp;
branches;
next	1.187;

1.187
date	2007.11.08.19.16.39;	author rjw;	state Exp;
branches;
next	1.186;

1.186
date	2007.03.08.17.02.54;	author rjw;	state Exp;
branches;
next	1.185;

1.185
date	2007.03.05.21.01.52;	author rjw;	state Exp;
branches;
next	1.184;

1.184
date	2007.02.28.20.04.57;	author rjw;	state Exp;
branches;
next	1.183;

1.183
date	2007.02.27.21.03.04;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2007.02.27.19.59.31;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2007.02.10.00.08.14;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2007.02.08.22.47.34;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2006.12.27.20.19.29;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2006.11.22.21.45.06;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2006.09.27.22.17.33;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2006.09.27.20.10.16;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2006.09.25.23.05.35;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2006.09.25.21.11.58;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2006.09.22.22.57.42;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2006.05.02.17.34.00;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2006.03.24.20.49.13;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2006.03.02.21.55.49;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2006.03.01.19.23.24;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2005.08.19.21.42.05;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2005.08.19.21.38.02;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2005.03.28.20.14.35;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2005.03.02.23.56.51;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2005.03.02.23.17.53;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2005.03.02.22.34.36;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2005.03.02.21.59.45;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2005.02.08.22.33.25;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2005.02.03.21.31.35;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2005.02.03.21.20.29;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2005.02.02.17.26.53;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2005.02.01.22.39.20;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2005.01.31.23.59.29;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2005.01.28.19.34.26;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2005.01.27.21.03.27;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2005.01.26.23.50.32;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2005.01.19.23.50.58;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2005.01.18.22.45.41;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2005.01.11.21.07.57;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2005.01.10.22.34.47;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2005.01.01.00.43.13;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2004.12.31.22.28.29;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2004.12.31.20.38.13;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2004.12.31.19.52.25;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2004.12.23.17.24.20;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2004.12.13.23.35.47;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2004.12.06.22.38.15;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2004.11.12.21.03.45;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2004.11.09.16.52.49;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2004.11.09.16.38.38;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.16.15.55.34;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2004.04.30.19.33.59;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2004.03.24.22.21.30;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2004.02.05.16.39.43;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2004.01.19.23.26.51;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2003.12.31.21.44.53;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2003.12.23.16.18.46;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2003.12.17.22.29.59;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2003.12.17.16.53.52;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2003.12.15.23.22.31;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2003.11.11.18.29.12;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2003.10.31.15.37.54;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2003.10.10.18.20.02;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2003.10.01.20.53.59;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2003.09.30.15.40.53;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2003.09.29.23.29.40;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2003.09.25.23.49.55;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2003.09.24.23.08.17;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2003.07.23.21.23.20;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2003.07.10.15.51.46;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2003.05.09.18.55.39;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2003.05.02.18.26.45;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2003.05.01.22.42.30;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2003.04.30.21.07.47;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2003.04.29.19.55.28;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2003.04.29.14.27.45;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2003.04.21.17.11.06;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2003.04.18.19.55.48;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2003.04.17.23.34.19;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.15.20.50.09;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.14.23.31.38;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2003.04.14.22.00.34;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.11.19.08.25;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2003.04.01.22.39.32;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2003.04.01.20.34.25;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2003.03.28.23.05.30;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2003.03.21.23.36.50;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2003.03.19.16.48.17;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2003.03.06.20.28.18;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2003.03.04.19.08.02;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2003.03.03.21.07.27;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2003.03.01.01.17.30;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2003.02.28.20.47.33;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2003.02.27.19.20.18;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2003.02.26.21.42.53;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2003.02.25.21.07.40;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2003.02.25.19.16.54;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2003.02.24.23.44.30;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2003.02.21.18.56.24;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2003.02.16.23.58.09;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2003.02.07.20.20.48;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2003.01.31.21.28.54;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2003.01.29.19.16.45;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2003.01.02.23.40.41;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2003.01.02.22.18.29;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2002.12.24.22.50.46;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2002.12.23.20.44.45;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2002.12.20.22.47.59;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2002.12.19.17.15.20;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2002.12.17.21.32.45;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2002.12.13.00.07.56;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2002.12.04.22.38.56;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2002.12.04.19.17.56;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2002.12.03.00.43.27;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.26.23.28.47;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2002.11.22.21.17.58;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2002.11.21.22.53.54;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2002.11.15.20.27.08;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2002.10.30.23.47.29;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2002.10.18.22.23.54;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2002.10.17.19.11.08;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2002.10.16.22.30.19;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2002.10.07.21.46.36;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2002.10.04.21.26.27;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2002.09.26.19.05.25;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2002.09.11.18.53.08;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2002.08.02.19.04.12;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2002.07.25.22.47.30;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2002.07.25.17.43.52;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2002.07.19.16.10.49;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.16.15.05.56;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2002.07.12.23.36.13;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2002.07.12.20.09.38;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.11.22.48.27;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.09.19.52.32;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.06.18.53.38;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.05.21.19.59;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.05.19.31.32;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2002.05.21.19.10.25;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.17.21.45.01;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.16.23.32.06;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.13.21.31.39;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.10.18.02.11;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.08.19.21.50;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.07.20.14.57;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.01.14.25.55;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.04.22.14.32.08;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.04.18.14.02.33;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.04.15.21.21.35;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.04.12.21.01.59;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.11.15.36.28;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.08.17.28.21;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.05.20.43.57;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.03.16.34.54;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.27.17.18.31;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.22.21.23.21;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.15.23.17.29;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.09.00.43.48;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.12.01.08.44;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.10.22.06.53;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.28.18.09.15;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.27.23.15.39;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.19.16.17.10;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.17.16.25.41;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.07.23.03.54;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.05.20.53.57;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.05.18.55.27;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.03.18.55.11;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.28.00.12.57;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.18.50.57;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.16.21.42.30;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.12.21.19.51;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.04.15.44.37;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.27.21.12.12;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.24.22.03.20;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.17.22.00.09;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.14.20.43.54;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.06.17.31.07;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.03.18.40.42;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.17.55.08;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.14.55.30;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.30.15.12.10;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.28.00.48.34;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.27.21.28.39;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.25.16.08.15;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.237
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "HeurAtor.C"
//
// Contains the implementation of class HeurAtor.
//------------------------------------------------------------------------------

#include <HeurAtor.h>
#include <HeurAllMgr.h>
#include <AvailSched.h>
#include <ReqSched.h>
#include <HeurCrit.h>
#include <PclBldr.h>
#include <HeurModifier.h>
#include <RtMgr.h>
#include <RtCand.h>
#include <Selector.h>
#include <MrMgr.h>
#include <PrMgr.h>
#include <BaMgr.h>
#include <MeMgr.h>
#include <SsrMgr.h>
#include <PenExMgr.h>
#include <SglSrcMgr.h>
#include <Pegger.h>
#include <PipMgr.h>
#include <Material.h>
#include <BopEntry.h>
#include <BoundSet.h>
#include <Post.h>
#include <FeasChkr.h>
#include <Variant.h>
#include <MsgFac.h>
#include <DataRepos.h>
#include <FixedPer.h>

//------------------------------------------------------------------------------
// Implementation of class HeurAtor
//------------------------------------------------------------------------------

WitHeurAtor::WitHeurAtor (
         WitProblem * theProblem,
         WitPegger *  thePegger,
         bool         forOpt):

      WitProbAssoc      (theProblem),

      myAvailSched_     (NULL),
      myReqSched_       (NULL),
      myHeurCritList_   (NULL),
      myPclBldr_        (NULL),
      myHeurModifier_   (NULL),
      mySelector_       (NULL),
      myMrMgr_          (NULL),
      myPrMgr_          (NULL),
      myBaMgr_          (NULL),
      myMeMgr_          (NULL),
      mySsrMgr_         (NULL),
      myPenExMgr_       (NULL),
      mySglSrcMgr_      (NULL),
      myPegger_         (NULL),
      tempCommRepos_    (NULL),
      multiRoute_       (false),
      buildAhead_       (false),
      multiExec_        (false),
      penExec_          (false),
      selSplit_         (false),
      sglSrc_           (false),
      perfPegging_      (false),
      userHeurStart_    (false),
      finiteExecBounds_ (false),
      leadTimeBounds_   (false),
      ltbMinPer_        (0),
      tempCommActive_   (false),
      permCommActive_   (false),
      blocked_          (),
      hasSubsToNet_     (myProblem (), false),
      searchInc_        (1.0),
      topPart_          (NULL),
      topPer_           (-1),
      nMaxCommits_      (0),
      nSelCommits_      (0),
      nBsearches_       (0),
      nTempComms_       (0),
      nPermComms_       (0),
      nComms_           (0),
      failedOn1_        (false)
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   if (not forOpt)
      userHeurStart_ = myGlobalComp ()->userHeurStart ();

   if (userHeurStart_)
      myProblem ()->myPostprocessor ()->myFeasChkr ()->verifyUhsFeas ();

   if (not forOpt)
      if (myGlobalComp ()->computeCriticalList ())
         myHeurCritList_ = new WitHeurCritList (myProblem ());

   if (not forOpt)
      if (myGlobalComp ()->pgdCritListMode ())
         myPclBldr_ = new WitPclBldr (myProblem ());

   myAvailSched_ = new WitAvailSched (this);
   myReqSched_   = new WitReqSched   (myProblem ());

   if (myGlobalComp ()->modHeurAlloc ())
      myHeurModifier_ = new WitHeurModifier (myAvailSched_);

   if (myGlobalComp ()->skipFailures ())
      initBlocked ();

   forEachSubEntry (theSub, myProblem ())
      if (theSub->netAllowed ())
         hasSubsToNet_ (theSub->myBomEnt ()) = true;

   setUpSelection ();

   if (myGlobalComp ()->penExec ())
      if (not multiRoute_)
         myMsgFac () ("penExecWoMultiRouteWmsg");

   if (WitSglSrcMgr::sglSrcReq (myProblem ()))
      if (not multiRoute_)
         myMsgFac () ("sglSrcWoMultiRouteWmsg");

   if (not userHeurStart_)
      initSoln ();

   forEachOperation (theOpn, myProblem ())
      if (theOpn->execBounds ()->hardUB () != -1.0)
         {
         finiteExecBounds_ = true;

         break;
         }

   compLeadTimeBounds ();

   if (leadTimeBounds_)
      setUpLeadTimeBounds ();

   if (not forOpt)
      if (myGlobalComp ()->perfPegging ())
         {
         witAssert (thePegger != NULL);

         perfPegging_ = true;

         myPegger_    = thePegger;

         myPegger_->setUpPeggedHeurAlloc (this);
         }

   if (myGlobalComp ()->pipSeqFromHeur ())
      myProblem ()->myPipMgr ()->clearShipSeq ();

   tempCommRepos_ = new WitDataRepos (theProblem);

   myMsgFac () ("heurAllActiveMsg");
   }

//------------------------------------------------------------------------------

WitHeurAtor::~WitHeurAtor ()
   {
   if (myGlobalComp ()->modHeurAlloc ())
      myHeurModifier ()->checkFeasibility ();

   if (DEVELOPMENT)
      {
      myMsgFac ()    ("nMaxCommitsMsg", nMaxCommits_);
      
      if (multiSel ())
         myMsgFac () ("nSelCommitsMsg", nSelCommits_);

      myMsgFac () ("nCommsMsg",
         nBsearches_,
         nTempComms_,
         nPermComms_,
         nComms_);
      }

   if (perfPegging_)
      myPegger_->shutDownPeggedHeurAlloc ();

   delete tempCommRepos_;
   delete mySelector_;
   delete myReqSched_;
   delete myHeurModifier_;
   delete myPclBldr_;
   delete myHeurCritList_;
   delete myAvailSched_;

   myMsgFac () ("heurAllInactiveMsg");
   }

//------------------------------------------------------------------------------

double WitHeurAtor::incHeurAlloc (
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      double      desIncVol,
      bool        asapMultiExec)
   {
   double demandedIncVol;
   double netQty;
   double incVol;

   witAssert (desIncVol >= 0.0);
   witAssert (thePer >= 0);
   witAssert (thePer < nPeriods ());

   if (myGlobalComp ()->modHeurAlloc ())
      myHeurModifier ()->checkFeasibility ();

   if (desIncVol <= NET_TOL)
      return 0.0;

   demandedIncVol = compDemandedIncVol (theDemand, thePer, desIncVol);

   if (demandedIncVol <= NET_TOL)
      return 0.0;

   preIncHeurAlloc (theDemand, thePer, asapMultiExec);

   netQty = demandedIncVol;

   if (theDemand->buildAheadUB ()[thePer] == 0)
      commitMaxQty (theDemand->demandedPart (), thePer, netQty);
   else
      doBaByDemand (theDemand,                  thePer, netQty);

   incVol = demandedIncVol - positivePart (netQty);

   postIncHeurAlloc (theDemand, thePer, desIncVol, incVol);

   return incVol;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::enforceStockSLBs ()
   {
   WitPart * thePart;

   WitObjStack <WitPart> reversedParts (myProblem ());

   myMsgFac () ("enfStockSLBsMsg");

   if (myGlobalComp ()->prefHighStockSLBs ())
      {
      revCopyInto (reversedParts, myCompMgr ()->allParts ());

      while (reversedParts.pop (thePart))
         enforceStockSLBs (thePart);
      }
   else
      forEachPart (thePart, myProblem ())
         enforceStockSLBs (thePart);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::commitMaxQtySel (double & netQty)
   {
   double maxQty;

   maxQty = findMaxQty (netQty);

   if (maxQty >= NET_TOL)
      {
      permCommit (maxQty);

      netQty -= maxQty;

      witAssert (netQty >= 0.0);

      if (penExec_)
         mySelector ()->recCommitVol (maxQty);
      }

   if (critListMode ())
      myHeurCritList ()->postCmqs ();

   if (pclMode ())
      myPclBldr ()->     postCmqs ();
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::tempCommit (double qty)
   {
   bool success;

   witAssert (not permCommActive_);
   witAssert (not tempCommActive_);

   nTempComms_ ++;

   tempCommActive_ = true;

   success         = commit (qty);

   if (not success)
      failedOn1_ = (qty == 1.0);

   if (multiSel ())
      mySelector ()->postTempCommit (success);

   tempCommActive_ = false;

   return success;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::permCommit1SS ()
   {
   witAssert (selSplit_);

   permCommit (1.0);

   myAvailSched_->addToIncAvailVol (topPart (), topPer (), 1.0);
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::incAvailPos (WitPart * thePart, WitPeriod thePer)
   {
   return (myAvailSched_->incAvailVol (thePart, thePer) > NET_TOL);
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::selectiveSR (WitMaterial * theMat)
   {
   return myAvailSched_->selectiveSR (theMat);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::saveVal (int & theVar)
   {
   if (tempCommActive_)
      tempCommRepos_->saveVal (theVar);

   else if (sglSrc_)
      mySglSrcMgr ()->saveAllocVal (theVar);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::saveVal (double & theVar)
   {
   if (tempCommActive_)
      tempCommRepos_->saveVal (theVar);

   else if (sglSrc_)
      mySglSrcMgr ()->saveAllocVal (theVar);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::saveExecVol (WitOperation * theOpn, WitPeriod thePer)
   {
   if (tempCommActive_)
      tempCommRepos_->saveExecVol (theOpn, thePer);

   else if (sglSrc_)
      mySglSrcMgr ()->saveExecVol (theOpn, thePer);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::saveSubVol (WitSubEntry * theSub, WitPeriod thePer)
   {
   if (tempCommActive_)
      tempCommRepos_->saveSubVol (theSub, thePer);

   else if (sglSrc_)
      mySglSrcMgr ()->saveSubVol (theSub, thePer);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::printAvailSched ()
   {
   myAvailSched_->print ();
   }

//------------------------------------------------------------------------------

void WitHeurAtor::initBlocked ()
   {
   WitDemand * theDemand;
   WitPart *   thePart;

   blocked_.allocate1D (myProblem ());

   forEachDemand (theDemand, myProblem ())
      {
      thePart = theDemand->demandedPart ();

      if (blocked_ (thePart).isAllocated ())
         continue;

      if (theDemand->demandVol () == 0.0)
         continue;

      blocked_ (thePart).allocate (myProblem (), false);
      }
   }

//------------------------------------------------------------------------------

void WitHeurAtor::setUpSelection ()
   {
   if (not WitSelector::instNeededFor (this))
      return;

   mySelector_ = new WitSelector (this);

   multiRoute_ = mySelector ()->multiRoute ();
   buildAhead_ = mySelector ()->buildAhead ();
   multiExec_  = mySelector ()->multiExec  ();
   penExec_    = mySelector ()->penExec    ();
   selSplit_   = mySelector ()->selSplit   ();
   sglSrc_     = mySelector ()->sglSrc     ();

   if (multiRoute_)
      myMrMgr_ = mySelector ()->myMrMgr ();

   if (mySelector ()->propRtg ())
      myPrMgr_ = mySelector ()->myPrMgr ();

   if (buildAhead_)
      myBaMgr_  = mySelector ()->myBaMgr ();

   if (multiExec_)
      myMeMgr_  = mySelector ()->myMeMgr ();

   if (mySelector ()->selectiveSR ())
      {
      mySsrMgr_ = mySelector ()->mySsrMgr ();

      myAvailSched_->attachSsrMgr ();
      }

   if (penExec_)
      myPenExMgr_ = mySelector ()->myPenExMgr ();

   if (sglSrc_)
      mySglSrcMgr_ = mySelector ()->mySglSrcMgr ();
   }

//------------------------------------------------------------------------------

void WitHeurAtor::initSoln ()
   {
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   if (critListMode ())
      myHeurCritList ()->initSoln ();

   if (pclMode ())
      myPclBldr ()->initSoln ();

   forEachDemand (theDemand, myProblem ())
      theDemand->clearShipVolForHeur ();

   forEachOperation (theOpn, myProblem ())
      theOpn->clearExecVolForHeur ();

   forEachSubEntry (theSub, myProblem ())
      theSub->clearSubVolForHeur ();
   }

//------------------------------------------------------------------------------

void WitHeurAtor::compLeadTimeBounds ()
   {
   WitPart * thePart;

   leadTimeBounds_ = false;

   forEachPart (thePart, myProblem ())
      {
      if (thePart->boundedLeadTimes ())
         {
         leadTimeBounds_ = true;

         return;
         }
      }
   }

//------------------------------------------------------------------------------

void WitHeurAtor::setUpLeadTimeBounds ()
   {
   myMsgFac () ("leadTimeBoundsMsg");

   if (myGlobalComp ()->skipFailures ())
      {
      myMsgFac () ("boolAttReqForLtbSmsg", "skipFailures", false);
      }

   if (not myGlobalComp ()->selectionRecovery ())
      {
      myMsgFac () ("boolAttReqForLtbSmsg", "selectionRecovery", true);
      }
   }

//------------------------------------------------------------------------------

double WitHeurAtor::compDemandedIncVol (
      WitDemand * theDemand,
      WitPeriod   thePer,
      double      desIncVol)
   {
   double incVolUB;

   if (theDemand->shipLateAllowed ())
      incVolUB = minUnmetCumDem (theDemand, thePer);
   else
      incVolUB =
           theDemand->demandVol ()[thePer]
         - theDemand->shipVol   ()[thePer];

   return min (desIncVol, incVolUB);
   }

//------------------------------------------------------------------------------

double WitHeurAtor::minUnmetCumDem (WitDemand * theDemand, WitPeriod thePer)
   {
   double    unmetCD;
   WitPeriod othPer;
   double    minUnmetCD;

   unmetCD = theDemand->cumDemandVol ()[thePer];

   for (othPer = 0; othPer <= thePer; othPer ++)
      unmetCD -= theDemand->shipVol ()[othPer];

   minUnmetCD = unmetCD;

   for (othPer = thePer + 1; othPer < nPeriods (); othPer ++)
      {
      unmetCD +=
           theDemand->demandVol ()[othPer] 
         - theDemand->shipVol   ()[othPer];

      setToMin (minUnmetCD, unmetCD);
      }

   return minUnmetCD;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::preIncHeurAlloc (
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      bool        asapMultiExec)
   {
   if (perfPegging_)
      myPegger_->setUpPeggedIncAlloc (theDemand, thePer);

   if (pclMode ())
      myPclBldr ()->preIncAlloc (theDemand, thePer);

   if (myGlobalComp ()->twoWayMultiExec ())
      myMeMgr ()->setInitDirIsAsap (asapMultiExec);
   else
      witAssert (not asapMultiExec);

   if (leadTimeBounds_)
      ltbMinPer_ =
         thePer - theDemand->leadTimeUB ()[thePer];

   searchInc_ = theDemand->searchInc ();
   }

//------------------------------------------------------------------------------

void WitHeurAtor::doBaByDemand (
      WitDemand * theDemand, 
      WitPeriod   lastPer,
      double &    netQty)
   {
   WitPart * thePart;
   WitPeriod firstPer;
   WitPeriod thePer;

   thePart  = theDemand->demandedPart ();

   firstPer = max (0, lastPer - theDemand->buildAheadUB ()[lastPer]);

   for (thePer = firstPer; thePer < lastPer; thePer ++)
      if (not thePart->canStock (thePer))
         firstPer = thePer + 1;

   if (theDemand->prefBuildAhead ())
      for (thePer = firstPer; thePer <= lastPer; thePer ++)
         {
         commitMaxQty (thePart, thePer, netQty);

         if (netQty <= NET_TOL)
            break;
         }
   else
      for (thePer = lastPer; thePer >= firstPer; thePer --)
         {
         commitMaxQty (thePart, thePer, netQty);

         if (netQty <= NET_TOL)
            break;
         }
   }

//------------------------------------------------------------------------------

void WitHeurAtor::postIncHeurAlloc (
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      double      desIncVol,
      double      incVol)
   {
   if (incVol >= NET_TOL)
      theDemand->incShipVolForHeur (thePer, incVol);

   if (myGlobalComp ()->printIncAlloc ())
      if (myMsgFac ().mayIssue ("incAllocMsg"))
         myMsgFac () ("incAllocMsg",
            theDemand->demandedPartName (),
            theDemand->demandName (),
            thePer,
            desIncVol,
            incVol);

   searchInc_ = 1.0;

   if (leadTimeBounds_)
      ltbMinPer_ = 0;

   if (penExec_)
      myPenExMgr ()->replenishPsSups ();

   if (multiSel ())
      if (myGlobalComp ()->selectionRecovery ())
         mySelector ()->recoverInitState ();

   if (perfPegging_)
      myPegger_->shutDownPeggedIncAlloc ();

   if (myGlobalComp ()->pipSeqFromHeur ())
      if (myProblem ()->heurVariant ()->isCurrent ())
         if (incVol > NET_TOL)
            myProblem ()->
               myPipMgr ()->
                  appendToShipSeq (theDemand, thePer, incVol);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::enforceStockSLBs (WitPart * thePart)
   {
   WitMaterial * theMat;
   WitPeriod     thePer;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (theMat->stockBounds ()->softLB () != 0.0)
         forEachPeriod (thePer, myProblem ())
            if (not theMat->mandEC ()[thePer])
               if (theMat->stockBounds ()->softLB ()[thePer] >= NET_TOL)
                  enforceStockSLB (theMat, thePer);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::enforceStockSLB (WitMaterial * theMat, WitPeriod thePer)
   {
   double unachVol;
   double netVol;
   double commitVol;

   myAvailSched_->reserveAchStSLB (theMat, thePer, unachVol);

   if (unachVol < NET_TOL)
      return;

   netVol = unachVol;

   commitMaxQty (theMat, thePer, netVol);

   commitVol = unachVol - netVol;

   if (commitVol >= NET_TOL)
      if (thePer < lastPeriod ())
         myAvailSched_->addToIncAvailVol (theMat, thePer + 1, commitVol);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::commitMaxQty (
      WitPart * thePart, 
      WitPeriod thePer,
      double &  netQty)
   {
   if (myGlobalComp ()->skipFailures ())
      if (blocked_ (thePart).isAllocated ())
         if (blocked_ (thePart)[thePer])
            return;

   if (DEVELOPMENT)
      nMaxCommits_ ++;

   witAssert (topPart_ == NULL);

   topPart_ = thePart;
   topPer_  = thePer;

   if (sglSrc_)
      mySglSrcMgr ()->commitMaxQty (netQty);

   else if (multiSel ())
      mySelector ()->commitMaxQty (netQty);

   else
      commitMaxQtySel (netQty);

   topPer_  = -1;
   topPart_ = NULL;

   if (myGlobalComp ()->skipFailures ())
      if (blocked_ (thePart).isAllocated ())
         if (netQty > SEARCH_TOL * searchInc ())
            blocked_ (thePart)[thePer] = true;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::permCommit (double qty)
   {
   bool success;

   witAssert (not tempCommActive_);
   witAssert (not permCommActive_);

   permCommActive_ = true;

   nPermComms_ ++;

   if (sglSrc_)
      mySglSrcMgr ()->recPermCommit ();

   success = commit (qty);

   permCommActive_ = false;

   if (not success)
      myMsgFac () ("permCommitFailedFmsg", 
         topPart ()->partName (), 
         topPer (), 
         qty);

   if (selPrintLevelAt (3))
      fprintf (msgFile (),
         "\n"
         "Permanent Commit: Part %s, Period %d, Qty: %.3f\n",
         topPart_->partName ().myCstring (),
         topPer_,
         qty);
   }

//------------------------------------------------------------------------------

double WitHeurAtor::findMaxQty (double desQty)
   {
   bool success;

   failedOn1_ = false;

   if (DEVELOPMENT)
      if (multiSel ())
         {
         nSelCommits_ ++;

         if (selPrintLevelAt (3))
            mySelector ()->printCommitMaxQtySel ();
         }

   if (desQty <=  SEARCH_TOL * searchInc ())
      return 0.0;

   if (desQty <= (1.0 + SEARCH_TOL) * searchInc ())
      {
      success = tempCommit (desQty);

      return
         success?
            desQty:
            0.0;
      }

   success = tempCommit (searchInc ());

   if (not success)
      return 0.0;

   success = tempCommit (desQty);

   if (success)
      return desQty;

   return binarySearch (desQty);
   }

//------------------------------------------------------------------------------
// HeurAtor::binarySearch (...).
//
// Local variables:
//    failMult: the smallest quantity for which tempCommit is known (or assumed)
//              to return failure.
//    okMult:   the largest quantity for which tempCommit is known (or assumed)
//              to return success.
//    curMult:  the current quantity to be tried in tempCommit.
//
// failMult, okMult, and curMult are all expressed as multiples of searchInc.
//------------------------------------------------------------------------------

double WitHeurAtor::binarySearch (double desQty)
   {
   double failMult;
   double okMult;
   double curMult;
   bool   success;

   if (DEVELOPMENT)
      nBsearches_ ++;

   failMult = ceil (desQty / searchInc () - SEARCH_TOL);

   okMult   = 1.0;

   while (failMult > okMult + 1.0 + SEARCH_TOL)
      {
      curMult = floor (((okMult + failMult) / 2.0) + SEARCH_TOL);

      success = tempCommit (curMult * searchInc ());

      if (success)
         okMult   = curMult;
      else
         failMult = curMult;
      }

   return (okMult * searchInc ());
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::commit (double qty)
   {
   bool success;

   witAssert (tempCommActive_ or permCommActive_);

   nComms_ ++;

   if (selSplit_)
      mySelector ()->preCommitSS ();

   success = innerCommit (qty);

   myReqSched_->clear ();

   tempCommRepos_->restore ();

   if (multiSel ())
      mySelector ()->postCommit ();

   return success;
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::innerCommit (double qty)
   {
   WitPtrVecItr <WitPart> theItr;
   WitPart *              fillPart;
   WitPeriod              fillPer;
   double                 theReqVol;
   bool                   fillOK;

   if (qty <= NET_TOL)
      return true;

   myReqSched_->addTo (topPart (), topPer (), qty);

   topPart ()->belowList ().attachItr (theItr);

   while (theItr.advance (fillPart))
      for (fillPer =  myReqSched_->firstPer (fillPart); 
           fillPer <= myReqSched_->lastPer  (fillPart);
           fillPer ++)
         {
         theReqVol = myReqSched_->reqVol (fillPart, fillPer);

         if (theReqVol <= NET_TOL)
            continue;

         fillOK = fillReq (fillPart, fillPer, theReqVol);

         if (not fillOK)
            return false;
         }

   return true;
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::fillReq (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    theReqVol)
   {
   double        netReqVol;
   WitMaterial * theMat;
   bool          bddSsrSplit;

   witAssert (theReqVol > NET_TOL);

   netReqVol   = theReqVol;

   theMat      = thePart->thisMat ();

   bddSsrSplit = false;

   if (theMat == NULL)
      myAvailSched_->netWithIncAvail (thePart, fillPer, netReqVol);

   else if (myAvailSched_->eitherSR (theMat))
      netAndRollReq                 (theMat,  fillPer, netReqVol, bddSsrSplit);

   else
      myAvailSched_->netMatWoSR     (theMat,  fillPer, netReqVol);

   if (multiSel ())
      if (netReqVol < theReqVol)
         if (not bddSsrSplit)
            mySelector ()->recFillByCons (thePart, fillPer);

   if (netReqVol <= NET_TOL)
      return true;

   if (multiSel ())
      mySelector ()->recFillNetRec (thePart, fillPer);

   return fillNetReq (thePart, fillPer, netReqVol);
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::fillNetReq (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    netReqVol)
   {
   WitPeriod expPer;

   witAssert (netReqVol > NET_TOL);

   if (selSplit_)
      if (buildAhead_)
         if (myBaMgr ()->selIsSplit (thePart, fillPer))
            return fillNetReqBASS (thePart, fillPer, netReqVol);

   if (penExec_)
      myPenExMgr ()->recExpBeyondNet (thePart, fillPer, false);

   if (buildAhead_)
      expPer = myBaMgr ()->selExpPer (thePart, fillPer);
   else
      expPer = thePart->explosionPeriod (fillPer);

   if (not thePart->explodeable (expPer))
      {
      if (multiSel ())
         mySelector ()->recFundShortage (thePart, fillPer);

      recClShortage (thePart, fillPer);

      return false;
      }

   if (thePart->boundedLeadTimes ())
      if (expPer < ltbMinPer_)
         {
         if (multiSel ())
            mySelector ()->recLTBoundShortage  (thePart, fillPer);

         recClShortage (thePart, fillPer);

         return false;
         }

   if (sglSrc_)
      if (mySglSrcMgr ()->expProhibited (thePart, expPer))
         {
         mySelector ()->recFundShortage (thePart, fillPer);

         return false;
         }

   return explodePart (thePart, expPer, netReqVol, fillPer);
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::fillNetReqBASS (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    netReqVol)
   {
   bool           expOK;
   WitPerDblStack theSplitPairs (myProblem ());
   double         unbddVol;
   WitFixedPer *  theFixedPer;
   double         expVol;
   WitPeriod      expPer;

   witAssert (selSplit_);

   witAssert (netReqVol > NET_TOL);

   witAssert (myBaMgr ()->selIsSplit (thePart, fillPer));

   if (penExec_)
      myPenExMgr ()->recExpBeyondNet (thePart, fillPer, false);

   expOK = true;

   myBaMgr ()->
      defineSplit (thePart, fillPer, netReqVol, theSplitPairs, unbddVol);

   myBaMgr ()->setBoundedSplit (true);

   while (theSplitPairs.pop (theFixedPer, expVol))
      {
      expPer = theFixedPer->myPer ();

      expOK  = explodePartSS (thePart, expPer, expVol, fillPer);

      if (not expOK)
         break;
      }

   myBaMgr ()->setBoundedSplit (false);

   if (expOK)
      if (unbddVol > 0.0)
         {
         expPer = myBaMgr ()->selExpPer (thePart, fillPer);

         expOK  = explodePartSS (thePart, expPer, unbddVol, fillPer);
         }

   return expOK;
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodePart (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   if (selSplit_)
      return explodePartSS (thePart, expPer, expVol, fillPer);

   if (thePart->propRtg ()[expPer])
      return explodePartPR (thePart, expPer, expVol, fillPer);

   theBopEnt = expBopEntry (thePart,   expPer);
   execPer   = execPerFor  (theBopEnt, expPer);

   return explodeBopEnt (theBopEnt, execPer, expVol, fillPer);
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodePartSS (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;

   witAssert (selSplit_);
   witAssert (expVol > NET_TOL);

   if (buildAhead_)
      myBaMgr ()->recExpMatSS (thePart, fillPer, expVol);

   if (thePart->boundedLeadTimes ())
      if (expPer < ltbMinPer_)
         {
         mySelector ()->recLTBoundShortage  (thePart, fillPer);

         recClShortage (thePart, fillPer);

         return false;
         }

   if (thePart->propRtg ()[expPer])
      {
      if (myPrMgr ()->selIsSplit (thePart, expPer))
         return explodePartPRSS (thePart, expPer, expVol, fillPer);

      return    explodePartPR   (thePart, expPer, expVol, fillPer);
      }

   if (multiRoute_)
      if (myMrMgr ()->selIsSplit (thePart, expPer))
         return explodePartMRSS (thePart, expPer, expVol, fillPer);

   theBopEnt = expBopEntry (thePart, expPer);

   return explodeBopEntSS (theBopEnt, expPer, expVol, fillPer);
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodePartPRSS (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   double            unbddVol;
   WitRtCand *       theRtCand;
   double            propExpVol;
   WitBopEntry *     theBopEnt;
   bool              expOK;

   myPrMgr ()->defineSplit (thePart, expPer, expVol, theExpPairs, unbddVol);

   while (theExpPairs.pop (theRtCand, propExpVol))
      {
      theBopEnt = theRtCand->myBopEnt ();

      myPrMgr ()->mySelMgrForProd ()->setBoundedSplit (true);

      expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);

      myPrMgr ()->mySelMgrForProd ()->setBoundedSplit (false);

      if (not expOK)
         return false;
      }

   if (unbddVol <= NET_TOL)
      return true;

   return explodePartPR (thePart, expPer, unbddVol, fillPer);
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodePartMRSS (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   bool              expOK;
   WitRtCandDblStack theSplitPairs (myProblem ());
   double            unbddVol;
   WitRtCand *       theRtCand;
   double            splitExpVol;
   WitBopEntry *     theBopEnt;

   witAssert (expVol > NET_TOL);

   expOK = true;

   myMrMgr ()->defineSplit (thePart, expPer, expVol, theSplitPairs, unbddVol);

   myMrMgr ()->mySelMgrForProd ()->setBoundedSplit (true);

   while (theSplitPairs.pop (theRtCand, splitExpVol))
      {
      theBopEnt = theRtCand->myBopEnt ();

      expOK     = explodeBopEntSS (theBopEnt, expPer, splitExpVol, fillPer);

      if (not expOK)
         break;
      }

   myMrMgr ()->mySelMgrForProd ()->setBoundedSplit (false);

   if (expOK)
      if (unbddVol > 0.0)
         {
         theBopEnt = expBopEntry (thePart, expPer);

         expOK     = explodeBopEntSS (theBopEnt, expPer, unbddVol, fillPer);
         }

   return expOK;
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodePartPR (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            propExpVol;
   WitBopEntry *     theBopEnt;
   WitPeriod         execPer;
   bool              expOK;

   if (selSplit_)
      myPrMgr ()->recordFlowSS (thePart, expPer, expVol);

   myPrMgr ()->definePropExp (thePart, expPer, expVol, theExpPairs);

   while (theExpPairs.pop (theRtCand, propExpVol))
      {
      theBopEnt = theRtCand->myBopEnt ();

      if (selSplit_)
         expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);
      else
         {
         execPer = execPerFor (theBopEnt, expPer);

         expOK   = explodeBopEnt (theBopEnt, execPer, propExpVol, fillPer);
         }

      if (! expOK)
         return false;
      }

   return true;
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodeBopEntSS (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol,
      WitPeriod     fillPer)
   {
   WitPeriod execPer;

   witAssert (selSplit_);

   if (multiRoute_)
      myMrMgr ()->recordFlowSS (theBopEnt, expPer, expVol);

   if (multiExec_)
      if (myMeMgr ()->selIsSplit (theBopEnt, expPer))
         return explodeBopEntMESS (theBopEnt, expPer, expVol, fillPer);

   execPer = execPerFor (theBopEnt, expPer);

   return explodeBopEnt (theBopEnt, execPer, expVol, fillPer);
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodeBopEntMESS (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol,
      WitPeriod     fillPer)
   {
   bool           expOK;
   WitPerDblStack theSplitPairs (myProblem ());
   double         unbddVol;
   WitFixedPer *  theFixedPer;
   double         splitExpVol;
   WitPeriod      execPer;

   witAssert (myMeMgr ()->selIsSplit (theBopEnt, expPer));

   expOK = true;

   myMeMgr ()->
      defineSplit (theBopEnt, expPer, expVol, theSplitPairs, unbddVol);

   myMeMgr ()->setBoundedSplit (true);

   while (theSplitPairs.pop (theFixedPer, splitExpVol))
      {
      execPer = theFixedPer->myPer ();

      expOK   = explodeBopEnt (theBopEnt, execPer, splitExpVol, fillPer);

      if (not expOK)
         break;
      }

   myMeMgr ()->setBoundedSplit (false);

   if (expOK)
      if (unbddVol > 0.0)
         {
         execPer = execPerFor (theBopEnt, expPer);

         expOK   = explodeBopEnt (theBopEnt, execPer, unbddVol, fillPer);
         }

   return expOK;
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodeBopEnt (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        qty,
      WitPeriod     fillPer)
   {
   WitOperation * theOpn;
   double         oldExecVol;
   double         deltaExecVol;
   bool           execBoundOK;

   witAssert (qty > NET_TOL);

   if (selSplit_)
      if (multiExec_)
         myMeMgr ()->recBopEntExecPerSS (theBopEnt, execPer, qty);

   if (sglSrc_)
      mySglSrcMgr ()->recExp (theBopEnt);

   theOpn       = theBopEnt->myOperation ();

   oldExecVol   = theOpn->execVol ()[execPer];

   deltaExecVol = qty / theBopEnt->effProdRate ()[execPer];

   deltaExecVol = theOpn->lotSizeDelta (execPer, oldExecVol, deltaExecVol);

   if (deltaExecVol < NET_TOL)
      return true;

   execBoundOK =
      checkExecBound (theBopEnt, execPer, oldExecVol, deltaExecVol, fillPer);

   if (not execBoundOK)
      return false;

   if (penExec_)
      if (not myPenExMgr ()->restExpAllowed (theBopEnt, fillPer))
         {
         mySelector ()->recShortage ();

         if (critListMode ())
            myHeurCritList ()->recRestShortage ();

         if (pclMode ())
            myPclBldr ()->recRestShortage ();

         return false;
         }

   if (sglSrc_)
      if (mySglSrcMgr ()->expProhibited (theOpn, execPer))
         {
         mySelector ()->recFundShortage (theBopEnt->myPart (), fillPer);

         return false;
         }

   innerExplodeBopEnt (theBopEnt, execPer, qty, deltaExecVol, fillPer);

   return true;
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::checkExecBound (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        oldExecVol,
      double        deltaExecVol,
      WitPeriod     fillPer)
   {
   bool execBoundOK;

   if (not finiteExecBounds_)
      return true;

   execBoundOK =
      theBopEnt->
         myOperation ()->
            execBounds ()->
               hardUBisSatisfied (execPer, oldExecVol + deltaExecVol);

   if (not execBoundOK)
      {
      if (multiSel ())
         mySelector ()->recExecBoundShortage (theBopEnt, execPer, fillPer);

      recClShortage (theBopEnt->myPart (), fillPer);
      }

   return execBoundOK;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::recClShortage (WitPart * thePart, WitPeriod fillPer)
   {
   if (critListMode ())
      myHeurCritList ()->recFundShortage (thePart, fillPer);

   if (pclMode ())
      myPclBldr ()->     recFundShortage (thePart, fillPer);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::innerExplodeBopEnt (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        qty,
      double        deltaExecVol,
      WitPeriod     fillPer)
   {
   WitOperation * theOpn;
   double         execVolVal;
   WitBomEntry *  theBomEnt;

   witAssert (deltaExecVol >= NET_TOL);

   theOpn = theBopEnt->myOperation ();

   saveExecVol (theOpn, execPer);

   execVolVal = theOpn->execVol ()[execPer] + deltaExecVol;

   theOpn->storeHeurExecVol (execPer, execVolVal);

   if (perfPegging_)
      if (permCommActive_)
         myPegger_->pegDeltaVol (theOpn, execPer, deltaExecVol);

   forEachEl (theBomEnt, theOpn->bom ())
      {
      explodeBomEntry (
         theBomEnt, 
         execPer, 
         deltaExecVol, 
         fillPer, 
         theBopEnt);

      if (penExec_)
         myPenExMgr ()->postExpBomEnt ();
      }

   explodeBopEntries (theBopEnt, execPer, deltaExecVol);

   myAvailSched_->addToIncAvailVol (theBopEnt->myPart (), fillPer, - qty);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::explodeBopEntries (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        deltaExecVol)
   {
   WitOperation * theOpn;
   WitBopEntry *  prodBopEnt;
   double         deltaProdVol;
   WitPart *      prodPart;
   WitPeriod      prodPer;

   theOpn = theBopEnt->myOperation ();

   forEachEl (prodBopEnt, theOpn->bop ())
      {
      deltaProdVol = deltaExecVol * prodBopEnt->effProdRate ()[execPer];

      if (deltaProdVol <= NET_TOL)
         continue;

      prodPart = prodBopEnt->myPart ();
      prodPer  = prodBopEnt->impactPeriod ()[execPer];

      myAvailSched_->addToIncAvailVol (prodPart, prodPer, deltaProdVol);

      if (penExec_)
         if (prodBopEnt != theBopEnt)
            if (permCommActive_)
               myPenExMgr ()->reqPsSupRep (prodPart, prodPer);
      }
   }

//------------------------------------------------------------------------------

void WitHeurAtor::netAndRollReq (
      WitMaterial * theMat,
      WitPeriod     thePer,
      double &      netReqVol,
      bool &        bddSsrSplit)
   {
   WitPeriod rollPer;
   double    rollVol;

   witAssert (myAvailSched_->eitherSR (theMat));

   rollPer =
      myAvailSched_->netAndRoll (
         theMat,
         thePer,
         netReqVol,
         rollVol,
         bddSsrSplit);

   if (rollPer < 0)
      return;

   myReqSched_->addTo (theMat, rollPer, rollVol);

   if (multiSel ())
      if (tempCommActive_)
         mySelector ()->rollReq (theMat, thePer, rollPer, rollVol);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::explodeBomEntry (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitConsEntry * theConsEnt;

   witAssert (deltaExecVol >= NET_TOL);

   if (not theBomEnt->inEffect (execPer))
      return;

   netConsEntries (theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);

   if (deltaExecVol < NET_TOL )
      return;

   if (theBomEnt->propRtg ()[execPer])
      {
      if (myPrMgr ()->selIsSplit (theBomEnt, execPer))
         explodeBomEntryPRSS (
            theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
      else
         explodeBomEntryPR (
            theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);

      return;
      }

   if (multiRoute_)
      if (myMrMgr ()->selIsSplit (theBomEnt, execPer))
         {
         explodeBomEntryMRSS (
            theBomEnt,
            execPer,
            deltaExecVol,
            fillPer,
            theBopEnt); 

         return;
         }

   theConsEnt = 
      multiRoute_?
         myMrMgr ()->selConsEnt (theBomEnt, execPer):
         theBomEnt;

   explodeConsEntry (
      theConsEnt,
      execPer, 
      deltaExecVol,
      fillPer, 
      theBopEnt);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::explodeBomEntryMRSS (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitRtCandDblStack theSplitPairs (myProblem ());
   double            unbddVol;
   WitRtCand *       theRtCand;
   double            splitExecVol;
   WitConsEntry *    theConsEnt;

   witAssert (deltaExecVol >= NET_TOL);

   myMrMgr ()->
      defineSplit (theBomEnt, execPer, deltaExecVol, theSplitPairs, unbddVol);

   myMrMgr ()->mySelMgrForCons ()->setBoundedSplit (true);

   while (theSplitPairs.pop (theRtCand, splitExecVol))
      {
      theConsEnt = theRtCand->myConsEnt ();

      explodeConsEntry (theConsEnt, execPer, splitExecVol, fillPer, theBopEnt);
      }

   myMrMgr ()->mySelMgrForCons ()->setBoundedSplit (false);

   if (unbddVol > 0.0)
      {
      theConsEnt = myMrMgr ()->selConsEnt (theBomEnt, execPer);

      explodeConsEntry (theConsEnt, execPer, unbddVol, fillPer, theBopEnt);
      }
   }

//------------------------------------------------------------------------------

void WitHeurAtor::netConsEntries (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double &      netExecQty,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitSubEntry * theSub;

   if (not hasSubsToNet_ (theBomEnt))
      return;

   if (sglSrc_)
      if (theBomEnt->singleSource ())
         return;

   if (theBomEnt->propRtg ()[execPer])
      return;

   netConsEntry (theBomEnt, execPer, netExecQty, fillPer, theBopEnt);
      //
      // First net possible usage of prime from supply.

   if (netExecQty < NET_TOL)
      return;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      netSubEntry (theSub, execPer, netExecQty, fillPer, theBopEnt);

      if (netExecQty < NET_TOL)
         return;
      }
   }

//------------------------------------------------------------------------------

void WitHeurAtor::netSubEntry (
      WitSubEntry * theSub,
      WitPeriod     execPer,
      double &      netExecQty,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   double oldExecQty;
   double deltaVol;
   double subVolVal;

   if (not theSub->netAllowed ())
      return;

   if (not theSub->inEffect (execPer))
      return;

   oldExecQty = netExecQty;

   netConsEntry (theSub, execPer, netExecQty, fillPer, theBopEnt);

   if (permCommActive_)
      {
      deltaVol = positivePart (oldExecQty - netExecQty);

      if (deltaVol > NET_TOL)
         {
         saveSubVol (theSub, execPer);

         subVolVal = theSub->subVol ()[execPer] + deltaVol;

         theSub->storeHeurSubVol (execPer, subVolVal);

         if (perfPegging_)
            myPegger_->pegDeltaVol (theSub, execPer, deltaVol);
         }
      }
   }

//------------------------------------------------------------------------------

void WitHeurAtor::netConsEntry (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double &       netExecQty,
      WitPeriod      fillPer,
      WitBopEntry *  theBopEnt)
   {
   double    reqConsQty;
   WitPart * consPart;
   WitPeriod consPer;
   double    netConsQty;

   witAssert (netExecQty > 0.0);

   reqConsQty = theConsEnt->effConsRate ()[execPer] * netExecQty;
   consPart   = theConsEnt->myPart ();
   consPer    = theConsEnt->impactPeriod ()[execPer];

   if (theConsEnt->effConsRate ()[execPer] >= FLOAT_EPSILON)
      {
      netConsQty = reqConsQty;

      myAvailSched_->netWoSR (consPart, consPer, netConsQty);

      netExecQty = netConsQty / theConsEnt->effConsRate ()[execPer];

      if (netExecQty <= NET_TOL)
         netExecQty = 0.0;
      else if (penExec_)
         myPenExMgr ()->recExpBeyondNet (consPart, consPer, true);

      if (multiSel ())
         if (tempCommActive_)
            if (reqConsQty - netConsQty > NET_TOL)
               mySelector ()->placeReqs (
                  theBopEnt,
                  theConsEnt,
                  execPer,
                  fillPer,
                  true);
      }
   else
      {
      if (theConsEnt->effConsRate ()[execPer] <= - FLOAT_EPSILON )
         myAvailSched_->addToIncAvailVol (consPart, consPer, - reqConsQty);

      netExecQty = 0.0;
      }
   }

//------------------------------------------------------------------------------

void WitHeurAtor::explodeBomEntryPRSS (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   double            unbddVol;
   WitRtCand *       theRtCand;
   double            propDeltaVol;

   myPrMgr ()->
      defineSplit (theBomEnt, execPer, deltaExecVol, theExpPairs, unbddVol);

   myPrMgr ()->mySelMgrForCons ()->setBoundedSplit (true);

   while (theExpPairs.pop (theRtCand, propDeltaVol))
      explodeConsEntry (
         theRtCand->myConsEnt (),
         execPer, 
         propDeltaVol,
         fillPer, 
         theBopEnt);

   myPrMgr ()->mySelMgrForCons ()->setBoundedSplit (false);

   if (unbddVol <= NET_TOL)
      return;

   explodeBomEntryPR (theBomEnt, execPer, unbddVol, fillPer, theBopEnt);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::explodeBomEntryPR (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            propDeltaVol;

   if (selSplit_)
      myPrMgr ()->recordFlowSS (theBomEnt, execPer, deltaExecVol);

   myPrMgr ()->definePropExp (theBomEnt, execPer, deltaExecVol, theExpPairs);
   
   while (theExpPairs.pop (theRtCand, propDeltaVol))
      explodeConsEntry (
         theRtCand->myConsEnt (),
         execPer, 
         propDeltaVol,
         fillPer, 
         theBopEnt);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::explodeConsEntry (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         netExecQty,
      WitPeriod      fillPer,
      WitBopEntry *  theBopEnt)
   {
   WitPeriod consPer;
   double    consumedQty;
   WitPart * consPart;

   witAssert (netExecQty > 0.0);

   if (sglSrc_)
      mySglSrcMgr ()->recExp (theConsEnt);

   consPer     = theConsEnt->impactPeriod ()[execPer];
   consumedQty = theConsEnt->effConsRate ()[execPer] * netExecQty;
   consPart    = theConsEnt->myPart ();

   if (consumedQty > NET_TOL)
      {
      myReqSched_->addTo (consPart, consPer, consumedQty);

      if (multiSel ())
         if (tempCommActive_)
            mySelector ()->placeReqs (
               theBopEnt,
               theConsEnt,
               execPer,
               fillPer,
               false);
      }

   if (consumedQty < - NET_TOL)
      myAvailSched_->addToIncAvailVol (consPart, consPer, - consumedQty);

   explodeSub (theConsEnt, execPer, netExecQty);

   if (selSplit_)
      if (multiRoute_)
         myMrMgr ()->recordFlowSS (theConsEnt, execPer, netExecQty);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::explodeSub (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         netExecQty)
   {
   WitSubEntry * theSub;
   double        subVolVal;

   theSub = theConsEnt->thisSub ();

   if (theSub == NULL)
      return;

   if (not permCommActive_)
      return;

   saveSubVol (theSub, execPer);

   subVolVal = theSub->subVol ()[execPer] + netExecQty;

   theSub->storeHeurSubVol (execPer, subVolVal);

   if (perfPegging_)
      myPegger_->pegDeltaVol (theSub, execPer, netExecQty);
   }

//------------------------------------------------------------------------------

WitBopEntry * WitHeurAtor::expBopEntry (WitPart * thePart, WitPeriod expPer)
   {
   return
      multiRoute_? 
         myMrMgr ()->selBopEnt (thePart, expPer):
         thePart->expBopEntry (expPer);
   }

//------------------------------------------------------------------------------

WitPeriod WitHeurAtor::execPerFor (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   return
      multiExec_?
         myMeMgr ()->selExecPer (theBopEnt, expPer):
         theBopEnt ->expExecPeriod ()[expPer];
   }
@


1.236
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.235
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d50 114
a163 114
WitProblem * theProblem,
WitPegger *  thePegger,
bool         forOpt):

WitProbAssoc      (theProblem),

myAvailSched_     (NULL),
myReqSched_       (NULL),
myHeurCritList_   (NULL),
myPclBldr_        (NULL),
myHeurModifier_   (NULL),
mySelector_       (NULL),
myMrMgr_          (NULL),
myPrMgr_          (NULL),
myBaMgr_          (NULL),
myMeMgr_          (NULL),
mySsrMgr_         (NULL),
myPenExMgr_       (NULL),
mySglSrcMgr_      (NULL),
myPegger_         (NULL),
tempCommRepos_    (NULL),
multiRoute_       (false),
buildAhead_       (false),
multiExec_        (false),
penExec_          (false),
selSplit_         (false),
sglSrc_           (false),
perfPegging_      (false),
userHeurStart_    (false),
finiteExecBounds_ (false),
leadTimeBounds_   (false),
ltbMinPer_        (0),
tempCommActive_   (false),
permCommActive_   (false),
blocked_          (),
hasSubsToNet_     (myProblem (), false),
searchInc_        (1.0),
topPart_          (NULL),
topPer_           (-1),
nMaxCommits_      (0),
nSelCommits_      (0),
nBsearches_       (0),
nTempComms_       (0),
nPermComms_       (0),
nComms_           (0),
failedOn1_        (false)
{
WitOperation * theOpn;
WitSubEntry *  theSub;

if (not forOpt)
userHeurStart_ = myGlobalComp ()->userHeurStart ();

if (userHeurStart_)
myProblem ()->myPostprocessor ()->myFeasChkr ()->verifyUhsFeas ();

if (not forOpt)
if (myGlobalComp ()->computeCriticalList ())
myHeurCritList_ = new WitHeurCritList (myProblem ());

if (not forOpt)
if (myGlobalComp ()->pgdCritListMode ())
myPclBldr_ = new WitPclBldr (myProblem ());

myAvailSched_ = new WitAvailSched (this);
myReqSched_   = new WitReqSched   (myProblem ());

if (myGlobalComp ()->modHeurAlloc ())
myHeurModifier_ = new WitHeurModifier (myAvailSched_);

if (myGlobalComp ()->skipFailures ())
initBlocked ();

forEachSubEntry (theSub, myProblem ())
if (theSub->netAllowed ())
hasSubsToNet_ (theSub->myBomEnt ()) = true;

setUpSelection ();

if (myGlobalComp ()->penExec ())
if (not multiRoute_)
myMsgFac () ("penExecWoMultiRouteWmsg");

if (WitSglSrcMgr::sglSrcReq (myProblem ()))
if (not multiRoute_)
myMsgFac () ("sglSrcWoMultiRouteWmsg");

if (not userHeurStart_)
initSoln ();

forEachOperation (theOpn, myProblem ())
if (theOpn->execBounds ()->hardUB () != -1.0)
{
finiteExecBounds_ = true;

break;
}

compLeadTimeBounds ();

if (leadTimeBounds_)
setUpLeadTimeBounds ();

if (not forOpt)
if (myGlobalComp ()->perfPegging ())
{
witAssert (thePegger != NULL);

perfPegging_ = true;

myPegger_    = thePegger;

myPegger_->setUpPeggedHeurAlloc (this);
}
d165 2
a166 2
if (myGlobalComp ()->pipSeqFromHeur ())
myProblem ()->myPipMgr ()->clearShipSeq ();
d168 1
a168 1
tempCommRepos_ = new WitDataRepos (theProblem);
d170 2
a171 2
myMsgFac () ("heurAllActiveMsg");
}
d176 28
a203 28
{
if (myGlobalComp ()->modHeurAlloc ())
myHeurModifier ()->checkFeasibility ();

if (DEVELOPMENT)
{
myMsgFac ()    ("nMaxCommitsMsg", nMaxCommits_);

if (multiSel ())
myMsgFac () ("nSelCommitsMsg", nSelCommits_);

myMsgFac () ("nCommsMsg",
nBsearches_,
nTempComms_,
nPermComms_,
nComms_);
}

if (perfPegging_)
myPegger_->shutDownPeggedHeurAlloc ();

delete tempCommRepos_;
delete mySelector_;
delete myReqSched_;
delete myHeurModifier_;
delete myPclBldr_;
delete myHeurCritList_;
delete myAvailSched_;
d205 2
a206 2
myMsgFac () ("heurAllInactiveMsg");
}
d211 8
a218 8
WitDemand * theDemand,
WitPeriod   thePer,
double      desIncVol,
bool        asapMultiExec)
{
double demandedIncVol;
double netQty;
double incVol;
d220 3
a222 3
witAssert (desIncVol >= 0.0);
witAssert (thePer >= 0);
witAssert (thePer < nPeriods ());
d224 2
a225 2
if (myGlobalComp ()->modHeurAlloc ())
myHeurModifier ()->checkFeasibility ();
d227 2
a228 2
if (desIncVol <= NET_TOL)
return 0.0;
d230 1
a230 1
demandedIncVol = compDemandedIncVol (theDemand, thePer, desIncVol);
d232 2
a233 2
if (demandedIncVol <= NET_TOL)
return 0.0;
d235 1
a235 1
preIncHeurAlloc (theDemand, thePer, asapMultiExec);
d237 1
a237 1
netQty = demandedIncVol;
d239 4
a242 4
if (theDemand->buildAheadUB ()[thePer] == 0)
commitMaxQty (theDemand->demandedPart (), thePer, netQty);
else
doBaByDemand (theDemand,                  thePer, netQty);
d244 1
a244 1
incVol = demandedIncVol - positivePart (netQty);
d246 1
a246 1
postIncHeurAlloc (theDemand, thePer, desIncVol, incVol);
d248 2
a249 2
return incVol;
}
d254 2
a255 2
{
WitPart * thePart;
d257 1
a257 1
WitObjStack <WitPart> reversedParts (myProblem ());
d259 1
a259 1
myMsgFac () ("enfStockSLBsMsg");
d261 11
a271 11
if (myGlobalComp ()->prefHighStockSLBs ())
{
revCopyInto (reversedParts, myCompMgr ()->allParts ());

while (reversedParts.pop (thePart))
enforceStockSLBs (thePart);
}
else
forEachPart (thePart, myProblem ())
enforceStockSLBs (thePart);
}
d276 2
a277 2
{
double maxQty;
d279 1
a279 1
maxQty = findMaxQty (netQty);
d281 3
a283 3
if (maxQty >= NET_TOL)
{
permCommit (maxQty);
d285 1
a285 1
netQty -= maxQty;
d287 1
a287 1
witAssert (netQty >= 0.0);
d289 3
a291 3
if (penExec_)
mySelector ()->recCommitVol (maxQty);
}
d293 2
a294 2
if (critListMode ())
myHeurCritList ()->postCmqs ();
d296 3
a298 3
if (pclMode ())
myPclBldr ()->     postCmqs ();
}
d303 2
a304 2
{
bool success;
d306 2
a307 2
witAssert (not permCommActive_);
witAssert (not tempCommActive_);
d309 1
a309 1
nTempComms_ ++;
d311 1
a311 1
tempCommActive_ = true;
d313 1
a313 1
success         = commit (qty);
d315 2
a316 2
if (not success)
failedOn1_ = (qty == 1.0);
d318 2
a319 2
if (multiSel ())
mySelector ()->postTempCommit (success);
d321 1
a321 1
tempCommActive_ = false;
d323 2
a324 2
return success;
}
d329 2
a330 2
{
witAssert (selSplit_);
d332 1
a332 1
permCommit (1.0);
d334 2
a335 2
myAvailSched_->addToIncAvailVol (topPart (), topPer (), 1.0);
}
d340 3
a342 3
{
return (myAvailSched_->incAvailVol (thePart, thePer) > NET_TOL);
}
d347 3
a349 3
{
return myAvailSched_->selectiveSR (theMat);
}
d354 7
a360 7
{
if (tempCommActive_)
tempCommRepos_->saveVal (theVar);

else if (sglSrc_)
mySglSrcMgr ()->saveAllocVal (theVar);
}
d365 7
a371 7
{
if (tempCommActive_)
tempCommRepos_->saveVal (theVar);

else if (sglSrc_)
mySglSrcMgr ()->saveAllocVal (theVar);
}
d376 7
a382 7
{
if (tempCommActive_)
tempCommRepos_->saveExecVol (theOpn, thePer);

else if (sglSrc_)
mySglSrcMgr ()->saveExecVol (theOpn, thePer);
}
d387 7
a393 7
{
if (tempCommActive_)
tempCommRepos_->saveSubVol (theSub, thePer);

else if (sglSrc_)
mySglSrcMgr ()->saveSubVol (theSub, thePer);
}
d398 3
a400 3
{
myAvailSched_->print ();
}
d405 3
a407 3
{
WitDemand * theDemand;
WitPart *   thePart;
d409 1
a409 1
blocked_.allocate1D (myProblem ());
d411 3
a413 3
forEachDemand (theDemand, myProblem ())
{
thePart = theDemand->demandedPart ();
d415 2
a416 2
if (blocked_ (thePart).isAllocated ())
continue;
d418 2
a419 2
if (theDemand->demandVol () == 0.0)
continue;
d421 3
a423 3
blocked_ (thePart).allocate (myProblem (), false);
}
}
d428 3
a430 3
{
if (not WitSelector::instNeededFor (this))
return;
d432 1
a432 1
mySelector_ = new WitSelector (this);
d434 6
a439 6
multiRoute_ = mySelector ()->multiRoute ();
buildAhead_ = mySelector ()->buildAhead ();
multiExec_  = mySelector ()->multiExec  ();
penExec_    = mySelector ()->penExec    ();
selSplit_   = mySelector ()->selSplit   ();
sglSrc_     = mySelector ()->sglSrc     ();
d441 2
a442 2
if (multiRoute_)
myMrMgr_ = mySelector ()->myMrMgr ();
d444 2
a445 2
if (mySelector ()->propRtg ())
myPrMgr_ = mySelector ()->myPrMgr ();
d447 2
a448 2
if (buildAhead_)
myBaMgr_  = mySelector ()->myBaMgr ();
d450 2
a451 2
if (multiExec_)
myMeMgr_  = mySelector ()->myMeMgr ();
d453 3
a455 3
if (mySelector ()->selectiveSR ())
{
mySsrMgr_ = mySelector ()->mySsrMgr ();
d457 2
a458 2
myAvailSched_->attachSsrMgr ();
}
d460 2
a461 2
if (penExec_)
myPenExMgr_ = mySelector ()->myPenExMgr ();
d463 3
a465 3
if (sglSrc_)
mySglSrcMgr_ = mySelector ()->mySglSrcMgr ();
}
d470 20
a489 20
{
WitDemand *    theDemand;
WitOperation * theOpn;
WitSubEntry *  theSub;

if (critListMode ())
myHeurCritList ()->initSoln ();

if (pclMode ())
myPclBldr ()->initSoln ();

forEachDemand (theDemand, myProblem ())
theDemand->clearShipVolForHeur ();

forEachOperation (theOpn, myProblem ())
theOpn->clearExecVolForHeur ();

forEachSubEntry (theSub, myProblem ())
theSub->clearSubVolForHeur ();
}
d494 2
a495 2
{
WitPart * thePart;
d497 1
a497 1
leadTimeBounds_ = false;
d499 10
a508 10
forEachPart (thePart, myProblem ())
{
if (thePart->boundedLeadTimes ())
{
leadTimeBounds_ = true;

return;
}
}
}
d513 2
a514 2
{
myMsgFac () ("leadTimeBoundsMsg");
d516 10
a525 10
if (myGlobalComp ()->skipFailures ())
{
myMsgFac () ("boolAttReqForLtbSmsg", "skipFailures", false);
}

if (not myGlobalComp ()->selectionRecovery ())
{
myMsgFac () ("boolAttReqForLtbSmsg", "selectionRecovery", true);
}
}
d530 12
a541 12
WitDemand * theDemand,
WitPeriod   thePer,
double      desIncVol)
{
double incVolUB;

if (theDemand->shipLateAllowed ())
incVolUB = minUnmetCumDem (theDemand, thePer);
else
incVolUB =
theDemand->demandVol ()[thePer]
- theDemand->shipVol   ()[thePer];
d543 2
a544 2
return min (desIncVol, incVolUB);
}
d549 4
a552 4
{
double    unmetCD;
WitPeriod othPer;
double    minUnmetCD;
d554 1
a554 1
unmetCD = theDemand->cumDemandVol ()[thePer];
d556 2
a557 2
for (othPer = 0; othPer <= thePer; othPer ++)
unmetCD -= theDemand->shipVol ()[othPer];
d559 1
a559 1
minUnmetCD = unmetCD;
d561 5
a565 5
for (othPer = thePer + 1; othPer < nPeriods (); othPer ++)
{
unmetCD +=
theDemand->demandVol ()[othPer]
- theDemand->shipVol   ()[othPer];
d567 2
a568 2
setToMin (minUnmetCD, unmetCD);
}
d570 2
a571 2
return minUnmetCD;
}
d576 18
a593 18
WitDemand * theDemand,
WitPeriod   thePer,
bool        asapMultiExec)
{
if (perfPegging_)
myPegger_->setUpPeggedIncAlloc (theDemand, thePer);

if (pclMode ())
myPclBldr ()->preIncAlloc (theDemand, thePer);

if (myGlobalComp ()->twoWayMultiExec ())
myMeMgr ()->setInitDirIsAsap (asapMultiExec);
else
witAssert (not asapMultiExec);

if (leadTimeBounds_)
ltbMinPer_ =
thePer - theDemand->leadTimeUB ()[thePer];
d595 2
a596 2
searchInc_ = theDemand->searchInc ();
}
d601 33
a633 33
WitDemand * theDemand,
WitPeriod   lastPer,
double &    netQty)
{
WitPart * thePart;
WitPeriod firstPer;
WitPeriod thePer;

thePart  = theDemand->demandedPart ();

firstPer = max (0, lastPer - theDemand->buildAheadUB ()[lastPer]);

for (thePer = firstPer; thePer < lastPer; thePer ++)
if (not thePart->canStock (thePer))
firstPer = thePer + 1;

if (theDemand->prefBuildAhead ())
for (thePer = firstPer; thePer <= lastPer; thePer ++)
{
commitMaxQty (thePart, thePer, netQty);

if (netQty <= NET_TOL)
break;
}
else
for (thePer = lastPer; thePer >= firstPer; thePer --)
{
commitMaxQty (thePart, thePer, netQty);

if (netQty <= NET_TOL)
break;
}
}
d638 39
a676 39
WitDemand * theDemand,
WitPeriod   thePer,
double      desIncVol,
double      incVol)
{
if (incVol >= NET_TOL)
theDemand->incShipVolForHeur (thePer, incVol);

if (myGlobalComp ()->printIncAlloc ())
if (myMsgFac ().mayIssue ("incAllocMsg"))
myMsgFac () ("incAllocMsg",
theDemand->demandedPartName (),
theDemand->demandName (),
thePer,
desIncVol,
incVol);

searchInc_ = 1.0;

if (leadTimeBounds_)
ltbMinPer_ = 0;

if (penExec_)
myPenExMgr ()->replenishPsSups ();

if (multiSel ())
if (myGlobalComp ()->selectionRecovery ())
mySelector ()->recoverInitState ();

if (perfPegging_)
myPegger_->shutDownPeggedIncAlloc ();

if (myGlobalComp ()->pipSeqFromHeur ())
if (myProblem ()->heurVariant ()->isCurrent ())
if (incVol > NET_TOL)
myProblem ()->
myPipMgr ()->
appendToShipSeq (theDemand, thePer, incVol);
}
d681 13
a693 13
{
WitMaterial * theMat;
WitPeriod     thePer;

theMat = thePart->thisMat ();

if (theMat != NULL)
if (theMat->stockBounds ()->softLB () != 0.0)
forEachPeriod (thePer, myProblem ())
if (not theMat->mandEC ()[thePer])
if (theMat->stockBounds ()->softLB ()[thePer] >= NET_TOL)
enforceStockSLB (theMat, thePer);
}
d698 4
a701 4
{
double unachVol;
double netVol;
double commitVol;
d703 1
a703 1
myAvailSched_->reserveAchStSLB (theMat, thePer, unachVol);
d705 2
a706 2
if (unachVol < NET_TOL)
return;
d708 1
a708 1
netVol = unachVol;
d710 1
a710 1
commitMaxQty (theMat, thePer, netVol);
d712 1
a712 1
commitVol = unachVol - netVol;
d714 4
a717 4
if (commitVol >= NET_TOL)
if (thePer < lastPeriod ())
myAvailSched_->addToIncAvailVol (theMat, thePer + 1, commitVol);
}
d722 34
a755 34
WitPart * thePart,
WitPeriod thePer,
double &  netQty)
{
if (myGlobalComp ()->skipFailures ())
if (blocked_ (thePart).isAllocated ())
if (blocked_ (thePart)[thePer])
return;

if (DEVELOPMENT)
nMaxCommits_ ++;

witAssert (topPart_ == NULL);

topPart_ = thePart;
topPer_  = thePer;

if (sglSrc_)
mySglSrcMgr ()->commitMaxQty (netQty);

else if (multiSel ())
mySelector ()->commitMaxQty (netQty);

else
commitMaxQtySel (netQty);

topPer_  = -1;
topPart_ = NULL;

if (myGlobalComp ()->skipFailures ())
if (blocked_ (thePart).isAllocated ())
if (netQty > SEARCH_TOL * searchInc ())
blocked_ (thePart)[thePer] = true;
}
d760 2
a761 2
{
bool success;
d763 2
a764 2
witAssert (not tempCommActive_);
witAssert (not permCommActive_);
d766 1
a766 1
permCommActive_ = true;
d768 1
a768 1
nPermComms_ ++;
d770 2
a771 2
if (sglSrc_)
mySglSrcMgr ()->recPermCommit ();
d773 1
a773 1
success = commit (qty);
d775 1
a775 1
permCommActive_ = false;
d777 5
a781 5
if (not success)
myMsgFac () ("permCommitFailedFmsg",
topPart ()->partName (),
topPer (),
qty);
d783 8
a790 8
if (selPrintLevelAt (3))
fprintf (msgFile (),
"\n"
"Permanent Commit: Part %s, Period %d, Qty: %.3f\n",
topPart_->partName ().myCstring (),
topPer_,
qty);
}
d795 2
a796 2
{
bool success;
d798 1
a798 1
failedOn1_ = false;
d800 4
a803 4
if (DEVELOPMENT)
if (multiSel ())
{
nSelCommits_ ++;
d805 3
a807 3
if (selPrintLevelAt (3))
mySelector ()->printCommitMaxQtySel ();
}
d809 2
a810 2
if (desQty <=  SEARCH_TOL * searchInc ())
return 0.0;
d812 3
a814 3
if (desQty <= (1.0 + SEARCH_TOL) * searchInc ())
{
success = tempCommit (desQty);
d816 5
a820 5
return
success?
desQty:
0.0;
}
d822 1
a822 1
success = tempCommit (searchInc ());
d824 2
a825 2
if (not success)
return 0.0;
d827 1
a827 1
success = tempCommit (desQty);
d829 2
a830 2
if (success)
return desQty;
d832 2
a833 2
return binarySearch (desQty);
}
d849 5
a853 5
{
double failMult;
double okMult;
double curMult;
bool   success;
d855 2
a856 2
if (DEVELOPMENT)
nBsearches_ ++;
d858 1
a858 1
failMult = ceil (desQty / searchInc () - SEARCH_TOL);
d860 1
a860 1
okMult   = 1.0;
d862 3
a864 3
while (failMult > okMult + 1.0 + SEARCH_TOL)
{
curMult = floor (((okMult + failMult) / 2.0) + SEARCH_TOL);
d866 1
a866 1
success = tempCommit (curMult * searchInc ());
d868 5
a872 5
if (success)
okMult   = curMult;
else
failMult = curMult;
}
d874 2
a875 2
return (okMult * searchInc ());
}
d880 2
a881 2
{
bool success;
d883 1
a883 1
witAssert (tempCommActive_ or permCommActive_);
d885 1
a885 1
nComms_ ++;
d887 2
a888 2
if (selSplit_)
mySelector ()->preCommitSS ();
d890 1
a890 1
success = innerCommit (qty);
d892 1
a892 1
myReqSched_->clear ();
d894 1
a894 1
tempCommRepos_->restore ();
d896 2
a897 2
if (multiSel ())
mySelector ()->postCommit ();
d899 2
a900 2
return success;
}
d905 29
a933 29
{
WitPtrVecItr <WitPart> theItr;
WitPart *              fillPart;
WitPeriod              fillPer;
double                 theReqVol;
bool                   fillOK;

if (qty <= NET_TOL)
return true;

myReqSched_->addTo (topPart (), topPer (), qty);

topPart ()->belowList ().attachItr (theItr);

while (theItr.advance (fillPart))
for (fillPer =  myReqSched_->firstPer (fillPart);
fillPer <= myReqSched_->lastPer  (fillPart);
fillPer ++)
{
theReqVol = myReqSched_->reqVol (fillPart, fillPer);

if (theReqVol <= NET_TOL)
continue;

fillOK = fillReq (fillPart, fillPer, theReqVol);

if (not fillOK)
return false;
}
d935 2
a936 2
return true;
}
d941 7
a947 7
WitPart * thePart,
WitPeriod fillPer,
double    theReqVol)
{
double        netReqVol;
WitMaterial * theMat;
bool          bddSsrSplit;
d949 1
a949 1
witAssert (theReqVol > NET_TOL);
d951 1
a951 1
netReqVol   = theReqVol;
d953 1
a953 1
theMat      = thePart->thisMat ();
d955 1
a955 1
bddSsrSplit = false;
d957 2
a958 2
if (theMat == NULL)
myAvailSched_->netWithIncAvail (thePart, fillPer, netReqVol);
d960 2
a961 2
else if (myAvailSched_->eitherSR (theMat))
netAndRollReq                 (theMat,  fillPer, netReqVol, bddSsrSplit);
d963 2
a964 2
else
myAvailSched_->netMatWoSR     (theMat,  fillPer, netReqVol);
d966 4
a969 4
if (multiSel ())
if (netReqVol < theReqVol)
if (not bddSsrSplit)
mySelector ()->recFillByCons (thePart, fillPer);
d971 2
a972 2
if (netReqVol <= NET_TOL)
return true;
d974 2
a975 2
if (multiSel ())
mySelector ()->recFillNetRec (thePart, fillPer);
d977 2
a978 2
return fillNetReq (thePart, fillPer, netReqVol);
}
d983 46
a1028 46
WitPart * thePart,
WitPeriod fillPer,
double    netReqVol)
{
WitPeriod expPer;

witAssert (netReqVol > NET_TOL);

if (selSplit_)
if (buildAhead_)
if (myBaMgr ()->selIsSplit (thePart, fillPer))
return fillNetReqBASS (thePart, fillPer, netReqVol);

if (penExec_)
myPenExMgr ()->recExpBeyondNet (thePart, fillPer, false);

if (buildAhead_)
expPer = myBaMgr ()->selExpPer (thePart, fillPer);
else
expPer = thePart->explosionPeriod (fillPer);

if (not thePart->explodeable (expPer))
{
if (multiSel ())
mySelector ()->recFundShortage (thePart, fillPer);

recClShortage (thePart, fillPer);

return false;
}

if (thePart->boundedLeadTimes ())
if (expPer < ltbMinPer_)
{
if (multiSel ())
mySelector ()->recLTBoundShortage  (thePart, fillPer);

recClShortage (thePart, fillPer);

return false;
}

if (sglSrc_)
if (mySglSrcMgr ()->expProhibited (thePart, expPer))
{
mySelector ()->recFundShortage (thePart, fillPer);
d1030 2
a1031 2
return false;
}
d1033 2
a1034 2
return explodePart (thePart, expPer, netReqVol, fillPer);
}
d1039 10
a1048 10
WitPart * thePart,
WitPeriod fillPer,
double    netReqVol)
{
bool           expOK;
WitPerDblStack theSplitPairs (myProblem ());
double         unbddVol;
WitFixedPer *  theFixedPer;
double         expVol;
WitPeriod      expPer;
d1050 1
a1050 1
witAssert (selSplit_);
d1052 1
a1052 1
witAssert (netReqVol > NET_TOL);
d1054 1
a1054 1
witAssert (myBaMgr ()->selIsSplit (thePart, fillPer));
d1056 2
a1057 2
if (penExec_)
myPenExMgr ()->recExpBeyondNet (thePart, fillPer, false);
d1059 1
a1059 1
expOK = true;
d1061 2
a1062 2
myBaMgr ()->
defineSplit (thePart, fillPer, netReqVol, theSplitPairs, unbddVol);
d1064 1
a1064 1
myBaMgr ()->setBoundedSplit (true);
d1066 3
a1068 3
while (theSplitPairs.pop (theFixedPer, expVol))
{
expPer = theFixedPer->myPer ();
d1070 1
a1070 1
expOK  = explodePartSS (thePart, expPer, expVol, fillPer);
d1072 3
a1074 3
if (not expOK)
break;
}
d1076 1
a1076 1
myBaMgr ()->setBoundedSplit (false);
d1078 4
a1081 4
if (expOK)
if (unbddVol > 0.0)
{
expPer = myBaMgr ()->selExpPer (thePart, fillPer);
d1083 2
a1084 2
expOK  = explodePartSS (thePart, expPer, unbddVol, fillPer);
}
d1086 2
a1087 2
return expOK;
}
d1092 10
a1101 10
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer)
{
WitBopEntry * theBopEnt;
WitPeriod     execPer;

if (selSplit_)
return explodePartSS (thePart, expPer, expVol, fillPer);
d1103 2
a1104 2
if (thePart->propRtg ()[expPer])
return explodePartPR (thePart, expPer, expVol, fillPer);
d1106 2
a1107 2
theBopEnt = expBopEntry (thePart,   expPer);
execPer   = execPerFor  (theBopEnt, expPer);
d1109 2
a1110 2
return explodeBopEnt (theBopEnt, execPer, expVol, fillPer);
}
d1115 6
a1120 6
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer)
{
WitBopEntry * theBopEnt;
d1122 2
a1123 2
witAssert (selSplit_);
witAssert (expVol > NET_TOL);
d1125 2
a1126 2
if (buildAhead_)
myBaMgr ()->recExpMatSS (thePart, fillPer, expVol);
d1128 4
a1131 4
if (thePart->boundedLeadTimes ())
if (expPer < ltbMinPer_)
{
mySelector ()->recLTBoundShortage  (thePart, fillPer);
d1133 1
a1133 1
recClShortage (thePart, fillPer);
d1135 2
a1136 2
return false;
}
d1138 4
a1141 4
if (thePart->propRtg ()[expPer])
{
if (myPrMgr ()->selIsSplit (thePart, expPer))
return explodePartPRSS (thePart, expPer, expVol, fillPer);
d1143 2
a1144 2
return    explodePartPR   (thePart, expPer, expVol, fillPer);
}
d1146 3
a1148 3
if (multiRoute_)
if (myMrMgr ()->selIsSplit (thePart, expPer))
return explodePartMRSS (thePart, expPer, expVol, fillPer);
d1150 1
a1150 1
theBopEnt = expBopEntry (thePart, expPer);
d1152 2
a1153 2
return explodeBopEntSS (theBopEnt, expPer, expVol, fillPer);
}
d1158 27
a1184 27
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer)
{
WitRtCandDblStack theExpPairs (myProblem ());
double            unbddVol;
WitRtCand *       theRtCand;
double            propExpVol;
WitBopEntry *     theBopEnt;
bool              expOK;

myPrMgr ()->defineSplit (thePart, expPer, expVol, theExpPairs, unbddVol);

while (theExpPairs.pop (theRtCand, propExpVol))
{
theBopEnt = theRtCand->myBopEnt ();

myPrMgr ()->mySelMgrForProd ()->setBoundedSplit (true);

expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);

myPrMgr ()->mySelMgrForProd ()->setBoundedSplit (false);

if (not expOK)
return false;
}
d1186 2
a1187 2
if (unbddVol <= NET_TOL)
return true;
d1189 2
a1190 2
return explodePartPR (thePart, expPer, unbddVol, fillPer);
}
d1195 11
a1205 11
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer)
{
bool              expOK;
WitRtCandDblStack theSplitPairs (myProblem ());
double            unbddVol;
WitRtCand *       theRtCand;
double            splitExpVol;
WitBopEntry *     theBopEnt;
d1207 1
a1207 1
witAssert (expVol > NET_TOL);
d1209 1
a1209 1
expOK = true;
d1211 1
a1211 1
myMrMgr ()->defineSplit (thePart, expPer, expVol, theSplitPairs, unbddVol);
d1213 1
a1213 1
myMrMgr ()->mySelMgrForProd ()->setBoundedSplit (true);
d1215 3
a1217 3
while (theSplitPairs.pop (theRtCand, splitExpVol))
{
theBopEnt = theRtCand->myBopEnt ();
d1219 1
a1219 1
expOK     = explodeBopEntSS (theBopEnt, expPer, splitExpVol, fillPer);
d1221 3
a1223 3
if (not expOK)
break;
}
d1225 1
a1225 1
myMrMgr ()->mySelMgrForProd ()->setBoundedSplit (false);
d1227 4
a1230 4
if (expOK)
if (unbddVol > 0.0)
{
theBopEnt = expBopEntry (thePart, expPer);
d1232 2
a1233 2
expOK     = explodeBopEntSS (theBopEnt, expPer, unbddVol, fillPer);
}
d1235 2
a1236 2
return expOK;
}
d1241 33
a1273 33
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer)
{
WitRtCandDblStack theExpPairs (myProblem ());
WitRtCand *       theRtCand;
double            propExpVol;
WitBopEntry *     theBopEnt;
WitPeriod         execPer;
bool              expOK;

if (selSplit_)
myPrMgr ()->recordFlowSS (thePart, expPer, expVol);

myPrMgr ()->definePropExp (thePart, expPer, expVol, theExpPairs);

while (theExpPairs.pop (theRtCand, propExpVol))
{
theBopEnt = theRtCand->myBopEnt ();

if (selSplit_)
expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);
else
{
execPer = execPerFor (theBopEnt, expPer);

expOK   = explodeBopEnt (theBopEnt, execPer, propExpVol, fillPer);
}

if (! expOK)
return false;
}
d1275 2
a1276 2
return true;
}
d1281 15
a1295 15
WitBopEntry * theBopEnt,
WitPeriod     expPer,
double        expVol,
WitPeriod     fillPer)
{
WitPeriod execPer;

witAssert (selSplit_);

if (multiRoute_)
myMrMgr ()->recordFlowSS (theBopEnt, expPer, expVol);

if (multiExec_)
if (myMeMgr ()->selIsSplit (theBopEnt, expPer))
return explodeBopEntMESS (theBopEnt, expPer, expVol, fillPer);
d1297 1
a1297 1
execPer = execPerFor (theBopEnt, expPer);
d1299 2
a1300 2
return explodeBopEnt (theBopEnt, execPer, expVol, fillPer);
}
d1305 11
a1315 11
WitBopEntry * theBopEnt,
WitPeriod     expPer,
double        expVol,
WitPeriod     fillPer)
{
bool           expOK;
WitPerDblStack theSplitPairs (myProblem ());
double         unbddVol;
WitFixedPer *  theFixedPer;
double         splitExpVol;
WitPeriod      execPer;
d1317 1
a1317 1
witAssert (myMeMgr ()->selIsSplit (theBopEnt, expPer));
d1319 1
a1319 1
expOK = true;
d1321 2
a1322 2
myMeMgr ()->
defineSplit (theBopEnt, expPer, expVol, theSplitPairs, unbddVol);
d1324 1
a1324 1
myMeMgr ()->setBoundedSplit (true);
d1326 3
a1328 3
while (theSplitPairs.pop (theFixedPer, splitExpVol))
{
execPer = theFixedPer->myPer ();
d1330 1
a1330 1
expOK   = explodeBopEnt (theBopEnt, execPer, splitExpVol, fillPer);
d1332 3
a1334 3
if (not expOK)
break;
}
d1336 1
a1336 1
myMeMgr ()->setBoundedSplit (false);
d1338 4
a1341 4
if (expOK)
if (unbddVol > 0.0)
{
execPer = execPerFor (theBopEnt, expPer);
d1343 2
a1344 2
expOK   = explodeBopEnt (theBopEnt, execPer, unbddVol, fillPer);
}
d1346 2
a1347 2
return expOK;
}
d1352 9
a1360 9
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        qty,
WitPeriod     fillPer)
{
WitOperation * theOpn;
double         oldExecVol;
double         deltaExecVol;
bool           execBoundOK;
d1362 1
a1362 1
witAssert (qty > NET_TOL);
d1364 3
a1366 3
if (selSplit_)
if (multiExec_)
myMeMgr ()->recBopEntExecPerSS (theBopEnt, execPer, qty);
d1368 2
a1369 2
if (sglSrc_)
mySglSrcMgr ()->recExp (theBopEnt);
d1371 1
a1371 1
theOpn       = theBopEnt->myOperation ();
d1373 1
a1373 1
oldExecVol   = theOpn->execVol ()[execPer];
d1375 1
a1375 1
deltaExecVol = qty / theBopEnt->effProdRate ()[execPer];
d1377 1
a1377 1
deltaExecVol = theOpn->lotSizeDelta (execPer, oldExecVol, deltaExecVol);
d1379 2
a1380 2
if (deltaExecVol < NET_TOL)
return true;
d1382 2
a1383 2
execBoundOK =
checkExecBound (theBopEnt, execPer, oldExecVol, deltaExecVol, fillPer);
d1385 2
a1386 2
if (not execBoundOK)
return false;
d1388 4
a1391 4
if (penExec_)
if (not myPenExMgr ()->restExpAllowed (theBopEnt, fillPer))
{
mySelector ()->recShortage ();
d1393 2
a1394 2
if (critListMode ())
myHeurCritList ()->recRestShortage ();
d1396 2
a1397 2
if (pclMode ())
myPclBldr ()->recRestShortage ();
d1399 2
a1400 2
return false;
}
d1402 4
a1405 4
if (sglSrc_)
if (mySglSrcMgr ()->expProhibited (theOpn, execPer))
{
mySelector ()->recFundShortage (theBopEnt->myPart (), fillPer);
d1407 2
a1408 2
return false;
}
d1410 1
a1410 1
innerExplodeBopEnt (theBopEnt, execPer, qty, deltaExecVol, fillPer);
d1412 2
a1413 2
return true;
}
d1418 21
a1438 21
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        oldExecVol,
double        deltaExecVol,
WitPeriod     fillPer)
{
bool execBoundOK;

if (not finiteExecBounds_)
return true;

execBoundOK =
theBopEnt->
myOperation ()->
execBounds ()->
hardUBisSatisfied (execPer, oldExecVol + deltaExecVol);

if (not execBoundOK)
{
if (multiSel ())
mySelector ()->recExecBoundShortage (theBopEnt, execPer, fillPer);
d1440 2
a1441 2
recClShortage (theBopEnt->myPart (), fillPer);
}
d1443 2
a1444 2
return execBoundOK;
}
d1449 7
a1455 7
{
if (critListMode ())
myHeurCritList ()->recFundShortage (thePart, fillPer);

if (pclMode ())
myPclBldr ()->     recFundShortage (thePart, fillPer);
}
d1460 36
a1495 36
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        qty,
double        deltaExecVol,
WitPeriod     fillPer)
{
WitOperation * theOpn;
double         execVolVal;
WitBomEntry *  theBomEnt;

witAssert (deltaExecVol >= NET_TOL);

theOpn = theBopEnt->myOperation ();

saveExecVol (theOpn, execPer);

execVolVal = theOpn->execVol ()[execPer] + deltaExecVol;

theOpn->storeHeurExecVol (execPer, execVolVal);

if (perfPegging_)
if (permCommActive_)
myPegger_->pegDeltaVol (theOpn, execPer, deltaExecVol);

forEachEl (theBomEnt, theOpn->bom ())
{
explodeBomEntry (
theBomEnt,
execPer,
deltaExecVol,
fillPer,
theBopEnt);

if (penExec_)
myPenExMgr ()->postExpBomEnt ();
}
d1497 1
a1497 1
explodeBopEntries (theBopEnt, execPer, deltaExecVol);
d1499 2
a1500 2
myAvailSched_->addToIncAvailVol (theBopEnt->myPart (), fillPer, - qty);
}
d1505 30
a1534 30
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        deltaExecVol)
{
WitOperation * theOpn;
WitBopEntry *  prodBopEnt;
double         deltaProdVol;
WitPart *      prodPart;
WitPeriod      prodPer;

theOpn = theBopEnt->myOperation ();

forEachEl (prodBopEnt, theOpn->bop ())
{
deltaProdVol = deltaExecVol * prodBopEnt->effProdRate ()[execPer];

if (deltaProdVol <= NET_TOL)
continue;

prodPart = prodBopEnt->myPart ();
prodPer  = prodBopEnt->impactPeriod ()[execPer];

myAvailSched_->addToIncAvailVol (prodPart, prodPer, deltaProdVol);

if (penExec_)
if (prodBopEnt != theBopEnt)
if (permCommActive_)
myPenExMgr ()->reqPsSupRep (prodPart, prodPer);
}
}
d1539 27
a1565 27
WitMaterial * theMat,
WitPeriod     thePer,
double &      netReqVol,
bool &        bddSsrSplit)
{
WitPeriod rollPer;
double    rollVol;

witAssert (myAvailSched_->eitherSR (theMat));

rollPer =
myAvailSched_->netAndRoll (
theMat,
thePer,
netReqVol,
rollVol,
bddSsrSplit);

if (rollPer < 0)
return;

myReqSched_->addTo (theMat, rollPer, rollVol);

if (multiSel ())
if (tempCommActive_)
mySelector ()->rollReq (theMat, thePer, rollPer, rollVol);
}
d1570 55
a1624 55
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol,
WitPeriod     fillPer,
WitBopEntry * theBopEnt)
{
WitConsEntry * theConsEnt;

witAssert (deltaExecVol >= NET_TOL);

if (not theBomEnt->inEffect (execPer))
return;

netConsEntries (theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);

if (deltaExecVol < NET_TOL )
return;

if (theBomEnt->propRtg ()[execPer])
{
if (myPrMgr ()->selIsSplit (theBomEnt, execPer))
explodeBomEntryPRSS (
theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
else
explodeBomEntryPR (
theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);

return;
}

if (multiRoute_)
if (myMrMgr ()->selIsSplit (theBomEnt, execPer))
{
explodeBomEntryMRSS (
theBomEnt,
execPer,
deltaExecVol,
fillPer,
theBopEnt);

return;
}

theConsEnt =
multiRoute_?
myMrMgr ()->selConsEnt (theBomEnt, execPer):
theBomEnt;

explodeConsEntry (
theConsEnt,
execPer,
deltaExecVol,
fillPer,
theBopEnt);
}
d1629 35
a1663 35
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol,
WitPeriod     fillPer,
WitBopEntry * theBopEnt)
{
WitRtCandDblStack theSplitPairs (myProblem ());
double            unbddVol;
WitRtCand *       theRtCand;
double            splitExecVol;
WitConsEntry *    theConsEnt;

witAssert (deltaExecVol >= NET_TOL);

myMrMgr ()->
defineSplit (theBomEnt, execPer, deltaExecVol, theSplitPairs, unbddVol);

myMrMgr ()->mySelMgrForCons ()->setBoundedSplit (true);

while (theSplitPairs.pop (theRtCand, splitExecVol))
{
theConsEnt = theRtCand->myConsEnt ();

explodeConsEntry (theConsEnt, execPer, splitExecVol, fillPer, theBopEnt);
}

myMrMgr ()->mySelMgrForCons ()->setBoundedSplit (false);

if (unbddVol > 0.0)
{
theConsEnt = myMrMgr ()->selConsEnt (theBomEnt, execPer);

explodeConsEntry (theConsEnt, execPer, unbddVol, fillPer, theBopEnt);
}
}
d1668 33
a1700 33
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double &      netExecQty,
WitPeriod     fillPer,
WitBopEntry * theBopEnt)
{
WitSubEntry * theSub;

if (not hasSubsToNet_ (theBomEnt))
return;

if (sglSrc_)
if (theBomEnt->singleSource ())
return;

if (theBomEnt->propRtg ()[execPer])
return;

netConsEntry (theBomEnt, execPer, netExecQty, fillPer, theBopEnt);
//
// First net possible usage of prime from supply.

if (netExecQty < NET_TOL)
return;

forEachEl (theSub, theBomEnt->mySubEntries ())
{
netSubEntry (theSub, execPer, netExecQty, fillPer, theBopEnt);

if (netExecQty < NET_TOL)
return;
}
}
d1705 37
a1741 37
WitSubEntry * theSub,
WitPeriod     execPer,
double &      netExecQty,
WitPeriod     fillPer,
WitBopEntry * theBopEnt)
{
double oldExecQty;
double deltaVol;
double subVolVal;

if (not theSub->netAllowed ())
return;

if (not theSub->inEffect (execPer))
return;

oldExecQty = netExecQty;

netConsEntry (theSub, execPer, netExecQty, fillPer, theBopEnt);

if (permCommActive_)
{
deltaVol = positivePart (oldExecQty - netExecQty);

if (deltaVol > NET_TOL)
{
saveSubVol (theSub, execPer);

subVolVal = theSub->subVol ()[execPer] + deltaVol;

theSub->storeHeurSubVol (execPer, subVolVal);

if (perfPegging_)
myPegger_->pegDeltaVol (theSub, execPer, deltaVol);
}
}
}
d1746 48
a1793 48
WitConsEntry * theConsEnt,
WitPeriod      execPer,
double &       netExecQty,
WitPeriod      fillPer,
WitBopEntry *  theBopEnt)
{
double    reqConsQty;
WitPart * consPart;
WitPeriod consPer;
double    netConsQty;

witAssert (netExecQty > 0.0);

reqConsQty = theConsEnt->effConsRate ()[execPer] * netExecQty;
consPart   = theConsEnt->myPart ();
consPer    = theConsEnt->impactPeriod ()[execPer];

if (theConsEnt->effConsRate ()[execPer] >= FLOAT_EPSILON)
{
netConsQty = reqConsQty;

myAvailSched_->netWoSR (consPart, consPer, netConsQty);

netExecQty = netConsQty / theConsEnt->effConsRate ()[execPer];

if (netExecQty <= NET_TOL)
netExecQty = 0.0;
else if (penExec_)
myPenExMgr ()->recExpBeyondNet (consPart, consPer, true);

if (multiSel ())
if (tempCommActive_)
if (reqConsQty - netConsQty > NET_TOL)
mySelector ()->placeReqs (
theBopEnt,
theConsEnt,
execPer,
fillPer,
true);
}
else
{
if (theConsEnt->effConsRate ()[execPer] <= - FLOAT_EPSILON )
myAvailSched_->addToIncAvailVol (consPart, consPer, - reqConsQty);

netExecQty = 0.0;
}
}
d1798 23
a1820 23
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol,
WitPeriod     fillPer,
WitBopEntry * theBopEnt)
{
WitRtCandDblStack theExpPairs (myProblem ());
double            unbddVol;
WitRtCand *       theRtCand;
double            propDeltaVol;

myPrMgr ()->
defineSplit (theBomEnt, execPer, deltaExecVol, theExpPairs, unbddVol);

myPrMgr ()->mySelMgrForCons ()->setBoundedSplit (true);

while (theExpPairs.pop (theRtCand, propDeltaVol))
explodeConsEntry (
theRtCand->myConsEnt (),
execPer,
propDeltaVol,
fillPer,
theBopEnt);
d1822 1
a1822 1
myPrMgr ()->mySelMgrForCons ()->setBoundedSplit (false);
d1824 2
a1825 2
if (unbddVol <= NET_TOL)
return;
d1827 2
a1828 2
explodeBomEntryPR (theBomEnt, execPer, unbddVol, fillPer, theBopEnt);
}
d1833 23
a1855 23
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol,
WitPeriod     fillPer,
WitBopEntry * theBopEnt)
{
WitRtCandDblStack theExpPairs (myProblem ());
WitRtCand *       theRtCand;
double            propDeltaVol;

if (selSplit_)
myPrMgr ()->recordFlowSS (theBomEnt, execPer, deltaExecVol);

myPrMgr ()->definePropExp (theBomEnt, execPer, deltaExecVol, theExpPairs);

while (theExpPairs.pop (theRtCand, propDeltaVol))
explodeConsEntry (
theRtCand->myConsEnt (),
execPer,
propDeltaVol,
fillPer,
theBopEnt);
}
d1860 42
a1901 42
WitConsEntry * theConsEnt,
WitPeriod      execPer,
double         netExecQty,
WitPeriod      fillPer,
WitBopEntry *  theBopEnt)
{
WitPeriod consPer;
double    consumedQty;
WitPart * consPart;

witAssert (netExecQty > 0.0);

if (sglSrc_)
mySglSrcMgr ()->recExp (theConsEnt);

consPer     = theConsEnt->impactPeriod ()[execPer];
consumedQty = theConsEnt->effConsRate ()[execPer] * netExecQty;
consPart    = theConsEnt->myPart ();

if (consumedQty > NET_TOL)
{
myReqSched_->addTo (consPart, consPer, consumedQty);

if (multiSel ())
if (tempCommActive_)
mySelector ()->placeReqs (
theBopEnt,
theConsEnt,
execPer,
fillPer,
false);
}

if (consumedQty < - NET_TOL)
myAvailSched_->addToIncAvailVol (consPart, consPer, - consumedQty);

explodeSub (theConsEnt, execPer, netExecQty);

if (selSplit_)
if (multiRoute_)
myMrMgr ()->recordFlowSS (theConsEnt, execPer, netExecQty);
}
d1906 6
a1911 6
WitConsEntry * theConsEnt,
WitPeriod      execPer,
double         netExecQty)
{
WitSubEntry * theSub;
double        subVolVal;
d1913 1
a1913 1
theSub = theConsEnt->thisSub ();
d1915 2
a1916 2
if (theSub == NULL)
return;
d1918 2
a1919 2
if (not permCommActive_)
return;
d1921 1
a1921 1
saveSubVol (theSub, execPer);
d1923 1
a1923 1
subVolVal = theSub->subVol ()[execPer] + netExecQty;
d1925 1
a1925 1
theSub->storeHeurSubVol (execPer, subVolVal);
d1927 3
a1929 3
if (perfPegging_)
myPegger_->pegDeltaVol (theSub, execPer, netExecQty);
}
d1934 6
a1939 6
{
return
multiRoute_?
myMrMgr ()->selBopEnt (thePart, expPer):
thePart->expBopEntry (expPer);
}
d1944 6
a1949 6
{
return
multiExec_?
myMeMgr ()->selExecPer (theBopEnt, expPer):
theBopEnt ->expExecPeriod ()[expPer];
}
@


1.234
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d50 114
a163 114
         WitProblem * theProblem,
         WitPegger *  thePegger,
         bool         forOpt):

      WitProbAssoc      (theProblem),

      myAvailSched_     (NULL),
      myReqSched_       (NULL),
      myHeurCritList_   (NULL),
      myPclBldr_        (NULL),
      myHeurModifier_   (NULL),
      mySelector_       (NULL),
      myMrMgr_          (NULL),
      myPrMgr_          (NULL),
      myBaMgr_          (NULL),
      myMeMgr_          (NULL),
      mySsrMgr_         (NULL),
      myPenExMgr_       (NULL),
      mySglSrcMgr_      (NULL),
      myPegger_         (NULL),
      tempCommRepos_    (NULL),
      multiRoute_       (false),
      buildAhead_       (false),
      multiExec_        (false),
      penExec_          (false),
      selSplit_         (false),
      sglSrc_           (false),
      perfPegging_      (false),
      userHeurStart_    (false),
      finiteExecBounds_ (false),
      leadTimeBounds_   (false),
      ltbMinPer_        (0),
      tempCommActive_   (false),
      permCommActive_   (false),
      blocked_          (),
      hasSubsToNet_     (myProblem (), false),
      searchInc_        (1.0),
      topPart_          (NULL),
      topPer_           (-1),
      nMaxCommits_      (0),
      nSelCommits_      (0),
      nBsearches_       (0),
      nTempComms_       (0),
      nPermComms_       (0),
      nComms_           (0),
      failedOn1_        (false)
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   if (not forOpt)
      userHeurStart_ = myGlobalComp ()->userHeurStart ();

   if (userHeurStart_)
      myProblem ()->myPostprocessor ()->myFeasChkr ()->verifyUhsFeas ();

   if (not forOpt)
      if (myGlobalComp ()->computeCriticalList ())
         myHeurCritList_ = new WitHeurCritList (myProblem ());

   if (not forOpt)
      if (myGlobalComp ()->pgdCritListMode ())
         myPclBldr_ = new WitPclBldr (myProblem ());

   myAvailSched_ = new WitAvailSched (this);
   myReqSched_   = new WitReqSched   (myProblem ());

   if (myGlobalComp ()->modHeurAlloc ())
      myHeurModifier_ = new WitHeurModifier (myAvailSched_);

   if (myGlobalComp ()->skipFailures ())
      initBlocked ();

   forEachSubEntry (theSub, myProblem ())
      if (theSub->netAllowed ())
         hasSubsToNet_ (theSub->myBomEnt ()) = true;

   setUpSelection ();

   if (myGlobalComp ()->penExec ())
      if (not multiRoute_)
         myMsgFac () ("penExecWoMultiRouteWmsg");

   if (WitSglSrcMgr::sglSrcReq (myProblem ()))
      if (not multiRoute_)
         myMsgFac () ("sglSrcWoMultiRouteWmsg");

   if (not userHeurStart_)
      initSoln ();

   forEachOperation (theOpn, myProblem ())
      if (theOpn->execBounds ()->hardUB () != -1.0)
         {
         finiteExecBounds_ = true;

         break;
         }

   compLeadTimeBounds ();

   if (leadTimeBounds_)
      setUpLeadTimeBounds ();

   if (not forOpt)
      if (myGlobalComp ()->perfPegging ())
         {
         witAssert (thePegger != NULL);

         perfPegging_ = true;

         myPegger_    = thePegger;

         myPegger_->setUpPeggedHeurAlloc (this);
         }
d165 2
a166 2
   if (myGlobalComp ()->pipSeqFromHeur ())
      myProblem ()->myPipMgr ()->clearShipSeq ();
d168 1
a168 1
   tempCommRepos_ = new WitDataRepos (theProblem);
d170 2
a171 2
   myMsgFac () ("heurAllActiveMsg");
   }
d176 28
a203 28
   {
   if (myGlobalComp ()->modHeurAlloc ())
      myHeurModifier ()->checkFeasibility ();

   if (DEVELOPMENT)
      {
      myMsgFac ()    ("nMaxCommitsMsg", nMaxCommits_);
      
      if (multiSel ())
         myMsgFac () ("nSelCommitsMsg", nSelCommits_);

      myMsgFac () ("nCommsMsg",
         nBsearches_,
         nTempComms_,
         nPermComms_,
         nComms_);
      }

   if (perfPegging_)
      myPegger_->shutDownPeggedHeurAlloc ();

   delete tempCommRepos_;
   delete mySelector_;
   delete myReqSched_;
   delete myHeurModifier_;
   delete myPclBldr_;
   delete myHeurCritList_;
   delete myAvailSched_;
d205 2
a206 2
   myMsgFac () ("heurAllInactiveMsg");
   }
d211 8
a218 8
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      double      desIncVol,
      bool        asapMultiExec)
   {
   double demandedIncVol;
   double netQty;
   double incVol;
d220 3
a222 3
   witAssert (desIncVol >= 0.0);
   witAssert (thePer >= 0);
   witAssert (thePer < nPeriods ());
d224 2
a225 2
   if (myGlobalComp ()->modHeurAlloc ())
      myHeurModifier ()->checkFeasibility ();
d227 2
a228 2
   if (desIncVol <= NET_TOL)
      return 0.0;
d230 1
a230 1
   demandedIncVol = compDemandedIncVol (theDemand, thePer, desIncVol);
d232 2
a233 2
   if (demandedIncVol <= NET_TOL)
      return 0.0;
d235 1
a235 1
   preIncHeurAlloc (theDemand, thePer, asapMultiExec);
d237 1
a237 1
   netQty = demandedIncVol;
d239 4
a242 4
   if (theDemand->buildAheadUB ()[thePer] == 0)
      commitMaxQty (theDemand->demandedPart (), thePer, netQty);
   else
      doBaByDemand (theDemand,                  thePer, netQty);
d244 1
a244 1
   incVol = demandedIncVol - positivePart (netQty);
d246 1
a246 1
   postIncHeurAlloc (theDemand, thePer, desIncVol, incVol);
d248 2
a249 2
   return incVol;
   }
d254 2
a255 2
   {
   WitPart * thePart;
d257 1
a257 1
   WitObjStack <WitPart> reversedParts (myProblem ());
d259 1
a259 1
   myMsgFac () ("enfStockSLBsMsg");
d261 11
a271 11
   if (myGlobalComp ()->prefHighStockSLBs ())
      {
      revCopyInto (reversedParts, myCompMgr ()->allParts ());

      while (reversedParts.pop (thePart))
         enforceStockSLBs (thePart);
      }
   else
      forEachPart (thePart, myProblem ())
         enforceStockSLBs (thePart);
   }
d276 2
a277 2
   {
   double maxQty;
d279 1
a279 1
   maxQty = findMaxQty (netQty);
d281 3
a283 3
   if (maxQty >= NET_TOL)
      {
      permCommit (maxQty);
d285 1
a285 1
      netQty -= maxQty;
d287 1
a287 1
      witAssert (netQty >= 0.0);
d289 3
a291 3
      if (penExec_)
         mySelector ()->recCommitVol (maxQty);
      }
d293 2
a294 2
   if (critListMode ())
      myHeurCritList ()->postCmqs ();
d296 3
a298 3
   if (pclMode ())
      myPclBldr ()->     postCmqs ();
   }
d303 2
a304 2
   {
   bool success;
d306 2
a307 2
   witAssert (not permCommActive_);
   witAssert (not tempCommActive_);
d309 1
a309 1
   nTempComms_ ++;
d311 1
a311 1
   tempCommActive_ = true;
d313 1
a313 1
   success         = commit (qty);
d315 2
a316 2
   if (not success)
      failedOn1_ = (qty == 1.0);
d318 2
a319 2
   if (multiSel ())
      mySelector ()->postTempCommit (success);
d321 1
a321 1
   tempCommActive_ = false;
d323 2
a324 2
   return success;
   }
d329 2
a330 2
   {
   witAssert (selSplit_);
d332 1
a332 1
   permCommit (1.0);
d334 2
a335 2
   myAvailSched_->addToIncAvailVol (topPart (), topPer (), 1.0);
   }
d340 3
a342 3
   {
   return (myAvailSched_->incAvailVol (thePart, thePer) > NET_TOL);
   }
d347 3
a349 3
   {
   return myAvailSched_->selectiveSR (theMat);
   }
d354 7
a360 7
   {
   if (tempCommActive_)
      tempCommRepos_->saveVal (theVar);

   else if (sglSrc_)
      mySglSrcMgr ()->saveAllocVal (theVar);
   }
d365 7
a371 7
   {
   if (tempCommActive_)
      tempCommRepos_->saveVal (theVar);

   else if (sglSrc_)
      mySglSrcMgr ()->saveAllocVal (theVar);
   }
d376 7
a382 7
   {
   if (tempCommActive_)
      tempCommRepos_->saveExecVol (theOpn, thePer);

   else if (sglSrc_)
      mySglSrcMgr ()->saveExecVol (theOpn, thePer);
   }
d387 7
a393 7
   {
   if (tempCommActive_)
      tempCommRepos_->saveSubVol (theSub, thePer);

   else if (sglSrc_)
      mySglSrcMgr ()->saveSubVol (theSub, thePer);
   }
d398 3
a400 3
   {
   myAvailSched_->print ();
   }
d405 3
a407 3
   {
   WitDemand * theDemand;
   WitPart *   thePart;
d409 1
a409 1
   blocked_.allocate1D (myProblem ());
d411 3
a413 3
   forEachDemand (theDemand, myProblem ())
      {
      thePart = theDemand->demandedPart ();
d415 2
a416 2
      if (blocked_ (thePart).isAllocated ())
         continue;
d418 2
a419 2
      if (theDemand->demandVol () == 0.0)
         continue;
d421 3
a423 3
      blocked_ (thePart).allocate (myProblem (), false);
      }
   }
d428 3
a430 3
   {
   if (not WitSelector::instNeededFor (this))
      return;
d432 1
a432 1
   mySelector_ = new WitSelector (this);
d434 6
a439 6
   multiRoute_ = mySelector ()->multiRoute ();
   buildAhead_ = mySelector ()->buildAhead ();
   multiExec_  = mySelector ()->multiExec  ();
   penExec_    = mySelector ()->penExec    ();
   selSplit_   = mySelector ()->selSplit   ();
   sglSrc_     = mySelector ()->sglSrc     ();
d441 2
a442 2
   if (multiRoute_)
      myMrMgr_ = mySelector ()->myMrMgr ();
d444 2
a445 2
   if (mySelector ()->propRtg ())
      myPrMgr_ = mySelector ()->myPrMgr ();
d447 2
a448 2
   if (buildAhead_)
      myBaMgr_  = mySelector ()->myBaMgr ();
d450 2
a451 2
   if (multiExec_)
      myMeMgr_  = mySelector ()->myMeMgr ();
d453 3
a455 3
   if (mySelector ()->selectiveSR ())
      {
      mySsrMgr_ = mySelector ()->mySsrMgr ();
d457 2
a458 2
      myAvailSched_->attachSsrMgr ();
      }
d460 2
a461 2
   if (penExec_)
      myPenExMgr_ = mySelector ()->myPenExMgr ();
d463 3
a465 3
   if (sglSrc_)
      mySglSrcMgr_ = mySelector ()->mySglSrcMgr ();
   }
d470 20
a489 20
   {
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   if (critListMode ())
      myHeurCritList ()->initSoln ();

   if (pclMode ())
      myPclBldr ()->initSoln ();

   forEachDemand (theDemand, myProblem ())
      theDemand->clearShipVolForHeur ();

   forEachOperation (theOpn, myProblem ())
      theOpn->clearExecVolForHeur ();

   forEachSubEntry (theSub, myProblem ())
      theSub->clearSubVolForHeur ();
   }
d494 2
a495 2
   {
   WitPart * thePart;
d497 1
a497 1
   leadTimeBounds_ = false;
d499 10
a508 10
   forEachPart (thePart, myProblem ())
      {
      if (thePart->boundedLeadTimes ())
         {
         leadTimeBounds_ = true;

         return;
         }
      }
   }
d513 2
a514 2
   {
   myMsgFac () ("leadTimeBoundsMsg");
d516 10
a525 10
   if (myGlobalComp ()->skipFailures ())
      {
      myMsgFac () ("boolAttReqForLtbSmsg", "skipFailures", false);
      }

   if (not myGlobalComp ()->selectionRecovery ())
      {
      myMsgFac () ("boolAttReqForLtbSmsg", "selectionRecovery", true);
      }
   }
d530 12
a541 12
      WitDemand * theDemand,
      WitPeriod   thePer,
      double      desIncVol)
   {
   double incVolUB;

   if (theDemand->shipLateAllowed ())
      incVolUB = minUnmetCumDem (theDemand, thePer);
   else
      incVolUB =
           theDemand->demandVol ()[thePer]
         - theDemand->shipVol   ()[thePer];
d543 2
a544 2
   return min (desIncVol, incVolUB);
   }
d549 4
a552 4
   {
   double    unmetCD;
   WitPeriod othPer;
   double    minUnmetCD;
d554 1
a554 1
   unmetCD = theDemand->cumDemandVol ()[thePer];
d556 2
a557 2
   for (othPer = 0; othPer <= thePer; othPer ++)
      unmetCD -= theDemand->shipVol ()[othPer];
d559 1
a559 1
   minUnmetCD = unmetCD;
d561 5
a565 5
   for (othPer = thePer + 1; othPer < nPeriods (); othPer ++)
      {
      unmetCD +=
           theDemand->demandVol ()[othPer] 
         - theDemand->shipVol   ()[othPer];
d567 2
a568 2
      setToMin (minUnmetCD, unmetCD);
      }
d570 2
a571 2
   return minUnmetCD;
   }
d576 18
a593 18
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      bool        asapMultiExec)
   {
   if (perfPegging_)
      myPegger_->setUpPeggedIncAlloc (theDemand, thePer);

   if (pclMode ())
      myPclBldr ()->preIncAlloc (theDemand, thePer);

   if (myGlobalComp ()->twoWayMultiExec ())
      myMeMgr ()->setInitDirIsAsap (asapMultiExec);
   else
      witAssert (not asapMultiExec);

   if (leadTimeBounds_)
      ltbMinPer_ =
         thePer - theDemand->leadTimeUB ()[thePer];
d595 2
a596 2
   searchInc_ = theDemand->searchInc ();
   }
d601 33
a633 33
      WitDemand * theDemand, 
      WitPeriod   lastPer,
      double &    netQty)
   {
   WitPart * thePart;
   WitPeriod firstPer;
   WitPeriod thePer;

   thePart  = theDemand->demandedPart ();

   firstPer = max (0, lastPer - theDemand->buildAheadUB ()[lastPer]);

   for (thePer = firstPer; thePer < lastPer; thePer ++)
      if (not thePart->canStock (thePer))
         firstPer = thePer + 1;

   if (theDemand->prefBuildAhead ())
      for (thePer = firstPer; thePer <= lastPer; thePer ++)
         {
         commitMaxQty (thePart, thePer, netQty);

         if (netQty <= NET_TOL)
            break;
         }
   else
      for (thePer = lastPer; thePer >= firstPer; thePer --)
         {
         commitMaxQty (thePart, thePer, netQty);

         if (netQty <= NET_TOL)
            break;
         }
   }
d638 39
a676 39
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      double      desIncVol,
      double      incVol)
   {
   if (incVol >= NET_TOL)
      theDemand->incShipVolForHeur (thePer, incVol);

   if (myGlobalComp ()->printIncAlloc ())
      if (myMsgFac ().mayIssue ("incAllocMsg"))
         myMsgFac () ("incAllocMsg",
            theDemand->demandedPartName (),
            theDemand->demandName (),
            thePer,
            desIncVol,
            incVol);

   searchInc_ = 1.0;

   if (leadTimeBounds_)
      ltbMinPer_ = 0;

   if (penExec_)
      myPenExMgr ()->replenishPsSups ();

   if (multiSel ())
      if (myGlobalComp ()->selectionRecovery ())
         mySelector ()->recoverInitState ();

   if (perfPegging_)
      myPegger_->shutDownPeggedIncAlloc ();

   if (myGlobalComp ()->pipSeqFromHeur ())
      if (myProblem ()->heurVariant ()->isCurrent ())
         if (incVol > NET_TOL)
            myProblem ()->
               myPipMgr ()->
                  appendToShipSeq (theDemand, thePer, incVol);
   }
d681 13
a693 13
   {
   WitMaterial * theMat;
   WitPeriod     thePer;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (theMat->stockBounds ()->softLB () != 0.0)
         forEachPeriod (thePer, myProblem ())
            if (not theMat->mandEC ()[thePer])
               if (theMat->stockBounds ()->softLB ()[thePer] >= NET_TOL)
                  enforceStockSLB (theMat, thePer);
   }
d698 4
a701 4
   {
   double unachVol;
   double netVol;
   double commitVol;
d703 1
a703 1
   myAvailSched_->reserveAchStSLB (theMat, thePer, unachVol);
d705 2
a706 2
   if (unachVol < NET_TOL)
      return;
d708 1
a708 1
   netVol = unachVol;
d710 1
a710 1
   commitMaxQty (theMat, thePer, netVol);
d712 1
a712 1
   commitVol = unachVol - netVol;
d714 4
a717 4
   if (commitVol >= NET_TOL)
      if (thePer < lastPeriod ())
         myAvailSched_->addToIncAvailVol (theMat, thePer + 1, commitVol);
   }
d722 34
a755 34
      WitPart * thePart, 
      WitPeriod thePer,
      double &  netQty)
   {
   if (myGlobalComp ()->skipFailures ())
      if (blocked_ (thePart).isAllocated ())
         if (blocked_ (thePart)[thePer])
            return;

   if (DEVELOPMENT)
      nMaxCommits_ ++;

   witAssert (topPart_ == NULL);

   topPart_ = thePart;
   topPer_  = thePer;

   if (sglSrc_)
      mySglSrcMgr ()->commitMaxQty (netQty);

   else if (multiSel ())
      mySelector ()->commitMaxQty (netQty);

   else
      commitMaxQtySel (netQty);

   topPer_  = -1;
   topPart_ = NULL;

   if (myGlobalComp ()->skipFailures ())
      if (blocked_ (thePart).isAllocated ())
         if (netQty > SEARCH_TOL * searchInc ())
            blocked_ (thePart)[thePer] = true;
   }
d760 2
a761 2
   {
   bool success;
d763 2
a764 2
   witAssert (not tempCommActive_);
   witAssert (not permCommActive_);
d766 1
a766 1
   permCommActive_ = true;
d768 1
a768 1
   nPermComms_ ++;
d770 2
a771 2
   if (sglSrc_)
      mySglSrcMgr ()->recPermCommit ();
d773 1
a773 1
   success = commit (qty);
d775 1
a775 1
   permCommActive_ = false;
d777 5
a781 5
   if (not success)
      myMsgFac () ("permCommitFailedFmsg", 
         topPart ()->partName (), 
         topPer (), 
         qty);
d783 8
a790 8
   if (selPrintLevelAt (3))
      fprintf (msgFile (),
         "\n"
         "Permanent Commit: Part %s, Period %d, Qty: %.3f\n",
         topPart_->partName ().myCstring (),
         topPer_,
         qty);
   }
d795 2
a796 2
   {
   bool success;
d798 1
a798 1
   failedOn1_ = false;
d800 4
a803 4
   if (DEVELOPMENT)
      if (multiSel ())
         {
         nSelCommits_ ++;
d805 3
a807 3
         if (selPrintLevelAt (3))
            mySelector ()->printCommitMaxQtySel ();
         }
d809 2
a810 2
   if (desQty <=  SEARCH_TOL * searchInc ())
      return 0.0;
d812 3
a814 3
   if (desQty <= (1.0 + SEARCH_TOL) * searchInc ())
      {
      success = tempCommit (desQty);
d816 5
a820 5
      return
         success?
            desQty:
            0.0;
      }
d822 1
a822 1
   success = tempCommit (searchInc ());
d824 2
a825 2
   if (not success)
      return 0.0;
d827 1
a827 1
   success = tempCommit (desQty);
d829 2
a830 2
   if (success)
      return desQty;
d832 2
a833 2
   return binarySearch (desQty);
   }
d849 5
a853 5
   {
   double failMult;
   double okMult;
   double curMult;
   bool   success;
d855 2
a856 2
   if (DEVELOPMENT)
      nBsearches_ ++;
d858 1
a858 1
   failMult = ceil (desQty / searchInc () - SEARCH_TOL);
d860 1
a860 1
   okMult   = 1.0;
d862 3
a864 3
   while (failMult > okMult + 1.0 + SEARCH_TOL)
      {
      curMult = floor (((okMult + failMult) / 2.0) + SEARCH_TOL);
d866 1
a866 1
      success = tempCommit (curMult * searchInc ());
d868 5
a872 5
      if (success)
         okMult   = curMult;
      else
         failMult = curMult;
      }
d874 2
a875 2
   return (okMult * searchInc ());
   }
d880 2
a881 2
   {
   bool success;
d883 1
a883 1
   witAssert (tempCommActive_ or permCommActive_);
d885 1
a885 1
   nComms_ ++;
d887 2
a888 2
   if (selSplit_)
      mySelector ()->preCommitSS ();
d890 1
a890 1
   success = innerCommit (qty);
d892 1
a892 1
   myReqSched_->clear ();
d894 1
a894 1
   tempCommRepos_->restore ();
d896 2
a897 2
   if (multiSel ())
      mySelector ()->postCommit ();
d899 2
a900 2
   return success;
   }
d905 29
a933 29
   {
   WitPtrVecItr <WitPart> theItr;
   WitPart *              fillPart;
   WitPeriod              fillPer;
   double                 theReqVol;
   bool                   fillOK;

   if (qty <= NET_TOL)
      return true;

   myReqSched_->addTo (topPart (), topPer (), qty);

   topPart ()->belowList ().attachItr (theItr);

   while (theItr.advance (fillPart))
      for (fillPer =  myReqSched_->firstPer (fillPart); 
           fillPer <= myReqSched_->lastPer  (fillPart);
           fillPer ++)
         {
         theReqVol = myReqSched_->reqVol (fillPart, fillPer);

         if (theReqVol <= NET_TOL)
            continue;

         fillOK = fillReq (fillPart, fillPer, theReqVol);

         if (not fillOK)
            return false;
         }
d935 2
a936 2
   return true;
   }
d941 7
a947 7
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    theReqVol)
   {
   double        netReqVol;
   WitMaterial * theMat;
   bool          bddSsrSplit;
d949 1
a949 1
   witAssert (theReqVol > NET_TOL);
d951 1
a951 1
   netReqVol   = theReqVol;
d953 1
a953 1
   theMat      = thePart->thisMat ();
d955 1
a955 1
   bddSsrSplit = false;
d957 2
a958 2
   if (theMat == NULL)
      myAvailSched_->netWithIncAvail (thePart, fillPer, netReqVol);
d960 2
a961 2
   else if (myAvailSched_->eitherSR (theMat))
      netAndRollReq                 (theMat,  fillPer, netReqVol, bddSsrSplit);
d963 2
a964 2
   else
      myAvailSched_->netMatWoSR     (theMat,  fillPer, netReqVol);
d966 4
a969 4
   if (multiSel ())
      if (netReqVol < theReqVol)
         if (not bddSsrSplit)
            mySelector ()->recFillByCons (thePart, fillPer);
d971 2
a972 2
   if (netReqVol <= NET_TOL)
      return true;
d974 2
a975 2
   if (multiSel ())
      mySelector ()->recFillNetRec (thePart, fillPer);
d977 2
a978 2
   return fillNetReq (thePart, fillPer, netReqVol);
   }
d983 46
a1028 46
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    netReqVol)
   {
   WitPeriod expPer;

   witAssert (netReqVol > NET_TOL);

   if (selSplit_)
      if (buildAhead_)
         if (myBaMgr ()->selIsSplit (thePart, fillPer))
            return fillNetReqBASS (thePart, fillPer, netReqVol);

   if (penExec_)
      myPenExMgr ()->recExpBeyondNet (thePart, fillPer, false);

   if (buildAhead_)
      expPer = myBaMgr ()->selExpPer (thePart, fillPer);
   else
      expPer = thePart->explosionPeriod (fillPer);

   if (not thePart->explodeable (expPer))
      {
      if (multiSel ())
         mySelector ()->recFundShortage (thePart, fillPer);

      recClShortage (thePart, fillPer);

      return false;
      }

   if (thePart->boundedLeadTimes ())
      if (expPer < ltbMinPer_)
         {
         if (multiSel ())
            mySelector ()->recLTBoundShortage  (thePart, fillPer);

         recClShortage (thePart, fillPer);

         return false;
         }

   if (sglSrc_)
      if (mySglSrcMgr ()->expProhibited (thePart, expPer))
         {
         mySelector ()->recFundShortage (thePart, fillPer);
d1030 2
a1031 2
         return false;
         }
d1033 2
a1034 2
   return explodePart (thePart, expPer, netReqVol, fillPer);
   }
d1039 10
a1048 10
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    netReqVol)
   {
   bool           expOK;
   WitPerDblStack theSplitPairs (myProblem ());
   double         unbddVol;
   WitFixedPer *  theFixedPer;
   double         expVol;
   WitPeriod      expPer;
d1050 1
a1050 1
   witAssert (selSplit_);
d1052 1
a1052 1
   witAssert (netReqVol > NET_TOL);
d1054 1
a1054 1
   witAssert (myBaMgr ()->selIsSplit (thePart, fillPer));
d1056 2
a1057 2
   if (penExec_)
      myPenExMgr ()->recExpBeyondNet (thePart, fillPer, false);
d1059 1
a1059 1
   expOK = true;
d1061 2
a1062 2
   myBaMgr ()->
      defineSplit (thePart, fillPer, netReqVol, theSplitPairs, unbddVol);
d1064 1
a1064 1
   myBaMgr ()->setBoundedSplit (true);
d1066 3
a1068 3
   while (theSplitPairs.pop (theFixedPer, expVol))
      {
      expPer = theFixedPer->myPer ();
d1070 1
a1070 1
      expOK  = explodePartSS (thePart, expPer, expVol, fillPer);
d1072 3
a1074 3
      if (not expOK)
         break;
      }
d1076 1
a1076 1
   myBaMgr ()->setBoundedSplit (false);
d1078 4
a1081 4
   if (expOK)
      if (unbddVol > 0.0)
         {
         expPer = myBaMgr ()->selExpPer (thePart, fillPer);
d1083 2
a1084 2
         expOK  = explodePartSS (thePart, expPer, unbddVol, fillPer);
         }
d1086 2
a1087 2
   return expOK;
   }
d1092 10
a1101 10
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   if (selSplit_)
      return explodePartSS (thePart, expPer, expVol, fillPer);
d1103 2
a1104 2
   if (thePart->propRtg ()[expPer])
      return explodePartPR (thePart, expPer, expVol, fillPer);
d1106 2
a1107 2
   theBopEnt = expBopEntry (thePart,   expPer);
   execPer   = execPerFor  (theBopEnt, expPer);
d1109 2
a1110 2
   return explodeBopEnt (theBopEnt, execPer, expVol, fillPer);
   }
d1115 6
a1120 6
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;
d1122 2
a1123 2
   witAssert (selSplit_);
   witAssert (expVol > NET_TOL);
d1125 2
a1126 2
   if (buildAhead_)
      myBaMgr ()->recExpMatSS (thePart, fillPer, expVol);
d1128 4
a1131 4
   if (thePart->boundedLeadTimes ())
      if (expPer < ltbMinPer_)
         {
         mySelector ()->recLTBoundShortage  (thePart, fillPer);
d1133 1
a1133 1
         recClShortage (thePart, fillPer);
d1135 2
a1136 2
         return false;
         }
d1138 4
a1141 4
   if (thePart->propRtg ()[expPer])
      {
      if (myPrMgr ()->selIsSplit (thePart, expPer))
         return explodePartPRSS (thePart, expPer, expVol, fillPer);
d1143 2
a1144 2
      return    explodePartPR   (thePart, expPer, expVol, fillPer);
      }
d1146 3
a1148 3
   if (multiRoute_)
      if (myMrMgr ()->selIsSplit (thePart, expPer))
         return explodePartMRSS (thePart, expPer, expVol, fillPer);
d1150 1
a1150 1
   theBopEnt = expBopEntry (thePart, expPer);
d1152 2
a1153 2
   return explodeBopEntSS (theBopEnt, expPer, expVol, fillPer);
   }
d1158 27
a1184 27
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   double            unbddVol;
   WitRtCand *       theRtCand;
   double            propExpVol;
   WitBopEntry *     theBopEnt;
   bool              expOK;

   myPrMgr ()->defineSplit (thePart, expPer, expVol, theExpPairs, unbddVol);

   while (theExpPairs.pop (theRtCand, propExpVol))
      {
      theBopEnt = theRtCand->myBopEnt ();

      myPrMgr ()->mySelMgrForProd ()->setBoundedSplit (true);

      expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);

      myPrMgr ()->mySelMgrForProd ()->setBoundedSplit (false);

      if (not expOK)
         return false;
      }
d1186 2
a1187 2
   if (unbddVol <= NET_TOL)
      return true;
d1189 2
a1190 2
   return explodePartPR (thePart, expPer, unbddVol, fillPer);
   }
d1195 11
a1205 11
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   bool              expOK;
   WitRtCandDblStack theSplitPairs (myProblem ());
   double            unbddVol;
   WitRtCand *       theRtCand;
   double            splitExpVol;
   WitBopEntry *     theBopEnt;
d1207 1
a1207 1
   witAssert (expVol > NET_TOL);
d1209 1
a1209 1
   expOK = true;
d1211 1
a1211 1
   myMrMgr ()->defineSplit (thePart, expPer, expVol, theSplitPairs, unbddVol);
d1213 1
a1213 1
   myMrMgr ()->mySelMgrForProd ()->setBoundedSplit (true);
d1215 3
a1217 3
   while (theSplitPairs.pop (theRtCand, splitExpVol))
      {
      theBopEnt = theRtCand->myBopEnt ();
d1219 1
a1219 1
      expOK     = explodeBopEntSS (theBopEnt, expPer, splitExpVol, fillPer);
d1221 3
a1223 3
      if (not expOK)
         break;
      }
d1225 1
a1225 1
   myMrMgr ()->mySelMgrForProd ()->setBoundedSplit (false);
d1227 4
a1230 4
   if (expOK)
      if (unbddVol > 0.0)
         {
         theBopEnt = expBopEntry (thePart, expPer);
d1232 2
a1233 2
         expOK     = explodeBopEntSS (theBopEnt, expPer, unbddVol, fillPer);
         }
d1235 2
a1236 2
   return expOK;
   }
d1241 33
a1273 33
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            propExpVol;
   WitBopEntry *     theBopEnt;
   WitPeriod         execPer;
   bool              expOK;

   if (selSplit_)
      myPrMgr ()->recordFlowSS (thePart, expPer, expVol);

   myPrMgr ()->definePropExp (thePart, expPer, expVol, theExpPairs);

   while (theExpPairs.pop (theRtCand, propExpVol))
      {
      theBopEnt = theRtCand->myBopEnt ();

      if (selSplit_)
         expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);
      else
         {
         execPer = execPerFor (theBopEnt, expPer);

         expOK   = explodeBopEnt (theBopEnt, execPer, propExpVol, fillPer);
         }

      if (! expOK)
         return false;
      }
d1275 2
a1276 2
   return true;
   }
d1281 15
a1295 15
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol,
      WitPeriod     fillPer)
   {
   WitPeriod execPer;

   witAssert (selSplit_);

   if (multiRoute_)
      myMrMgr ()->recordFlowSS (theBopEnt, expPer, expVol);

   if (multiExec_)
      if (myMeMgr ()->selIsSplit (theBopEnt, expPer))
         return explodeBopEntMESS (theBopEnt, expPer, expVol, fillPer);
d1297 1
a1297 1
   execPer = execPerFor (theBopEnt, expPer);
d1299 2
a1300 2
   return explodeBopEnt (theBopEnt, execPer, expVol, fillPer);
   }
d1305 11
a1315 11
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol,
      WitPeriod     fillPer)
   {
   bool           expOK;
   WitPerDblStack theSplitPairs (myProblem ());
   double         unbddVol;
   WitFixedPer *  theFixedPer;
   double         splitExpVol;
   WitPeriod      execPer;
d1317 1
a1317 1
   witAssert (myMeMgr ()->selIsSplit (theBopEnt, expPer));
d1319 1
a1319 1
   expOK = true;
d1321 2
a1322 2
   myMeMgr ()->
      defineSplit (theBopEnt, expPer, expVol, theSplitPairs, unbddVol);
d1324 1
a1324 1
   myMeMgr ()->setBoundedSplit (true);
d1326 3
a1328 3
   while (theSplitPairs.pop (theFixedPer, splitExpVol))
      {
      execPer = theFixedPer->myPer ();
d1330 1
a1330 1
      expOK   = explodeBopEnt (theBopEnt, execPer, splitExpVol, fillPer);
d1332 3
a1334 3
      if (not expOK)
         break;
      }
d1336 1
a1336 1
   myMeMgr ()->setBoundedSplit (false);
d1338 4
a1341 4
   if (expOK)
      if (unbddVol > 0.0)
         {
         execPer = execPerFor (theBopEnt, expPer);
d1343 2
a1344 2
         expOK   = explodeBopEnt (theBopEnt, execPer, unbddVol, fillPer);
         }
d1346 2
a1347 2
   return expOK;
   }
d1352 9
a1360 9
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        qty,
      WitPeriod     fillPer)
   {
   WitOperation * theOpn;
   double         oldExecVol;
   double         deltaExecVol;
   bool           execBoundOK;
d1362 1
a1362 1
   witAssert (qty > NET_TOL);
d1364 3
a1366 3
   if (selSplit_)
      if (multiExec_)
         myMeMgr ()->recBopEntExecPerSS (theBopEnt, execPer, qty);
d1368 2
a1369 2
   if (sglSrc_)
      mySglSrcMgr ()->recExp (theBopEnt);
d1371 1
a1371 1
   theOpn       = theBopEnt->myOperation ();
d1373 1
a1373 1
   oldExecVol   = theOpn->execVol ()[execPer];
d1375 1
a1375 1
   deltaExecVol = qty / theBopEnt->effProdRate ()[execPer];
d1377 1
a1377 1
   deltaExecVol = theOpn->lotSizeDelta (execPer, oldExecVol, deltaExecVol);
d1379 2
a1380 2
   if (deltaExecVol < NET_TOL)
      return true;
d1382 2
a1383 2
   execBoundOK =
      checkExecBound (theBopEnt, execPer, oldExecVol, deltaExecVol, fillPer);
d1385 2
a1386 2
   if (not execBoundOK)
      return false;
d1388 4
a1391 4
   if (penExec_)
      if (not myPenExMgr ()->restExpAllowed (theBopEnt, fillPer))
         {
         mySelector ()->recShortage ();
d1393 2
a1394 2
         if (critListMode ())
            myHeurCritList ()->recRestShortage ();
d1396 2
a1397 2
         if (pclMode ())
            myPclBldr ()->recRestShortage ();
d1399 2
a1400 2
         return false;
         }
d1402 4
a1405 4
   if (sglSrc_)
      if (mySglSrcMgr ()->expProhibited (theOpn, execPer))
         {
         mySelector ()->recFundShortage (theBopEnt->myPart (), fillPer);
d1407 2
a1408 2
         return false;
         }
d1410 1
a1410 1
   innerExplodeBopEnt (theBopEnt, execPer, qty, deltaExecVol, fillPer);
d1412 2
a1413 2
   return true;
   }
d1418 21
a1438 21
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        oldExecVol,
      double        deltaExecVol,
      WitPeriod     fillPer)
   {
   bool execBoundOK;

   if (not finiteExecBounds_)
      return true;

   execBoundOK =
      theBopEnt->
         myOperation ()->
            execBounds ()->
               hardUBisSatisfied (execPer, oldExecVol + deltaExecVol);

   if (not execBoundOK)
      {
      if (multiSel ())
         mySelector ()->recExecBoundShortage (theBopEnt, execPer, fillPer);
d1440 2
a1441 2
      recClShortage (theBopEnt->myPart (), fillPer);
      }
d1443 2
a1444 2
   return execBoundOK;
   }
d1449 7
a1455 7
   {
   if (critListMode ())
      myHeurCritList ()->recFundShortage (thePart, fillPer);

   if (pclMode ())
      myPclBldr ()->     recFundShortage (thePart, fillPer);
   }
d1460 36
a1495 36
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        qty,
      double        deltaExecVol,
      WitPeriod     fillPer)
   {
   WitOperation * theOpn;
   double         execVolVal;
   WitBomEntry *  theBomEnt;

   witAssert (deltaExecVol >= NET_TOL);

   theOpn = theBopEnt->myOperation ();

   saveExecVol (theOpn, execPer);

   execVolVal = theOpn->execVol ()[execPer] + deltaExecVol;

   theOpn->storeHeurExecVol (execPer, execVolVal);

   if (perfPegging_)
      if (permCommActive_)
         myPegger_->pegDeltaVol (theOpn, execPer, deltaExecVol);

   forEachEl (theBomEnt, theOpn->bom ())
      {
      explodeBomEntry (
         theBomEnt, 
         execPer, 
         deltaExecVol, 
         fillPer, 
         theBopEnt);

      if (penExec_)
         myPenExMgr ()->postExpBomEnt ();
      }
d1497 1
a1497 1
   explodeBopEntries (theBopEnt, execPer, deltaExecVol);
d1499 2
a1500 2
   myAvailSched_->addToIncAvailVol (theBopEnt->myPart (), fillPer, - qty);
   }
d1505 30
a1534 30
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        deltaExecVol)
   {
   WitOperation * theOpn;
   WitBopEntry *  prodBopEnt;
   double         deltaProdVol;
   WitPart *      prodPart;
   WitPeriod      prodPer;

   theOpn = theBopEnt->myOperation ();

   forEachEl (prodBopEnt, theOpn->bop ())
      {
      deltaProdVol = deltaExecVol * prodBopEnt->effProdRate ()[execPer];

      if (deltaProdVol <= NET_TOL)
         continue;

      prodPart = prodBopEnt->myPart ();
      prodPer  = prodBopEnt->impactPeriod ()[execPer];

      myAvailSched_->addToIncAvailVol (prodPart, prodPer, deltaProdVol);

      if (penExec_)
         if (prodBopEnt != theBopEnt)
            if (permCommActive_)
               myPenExMgr ()->reqPsSupRep (prodPart, prodPer);
      }
   }
d1539 27
a1565 27
      WitMaterial * theMat,
      WitPeriod     thePer,
      double &      netReqVol,
      bool &        bddSsrSplit)
   {
   WitPeriod rollPer;
   double    rollVol;

   witAssert (myAvailSched_->eitherSR (theMat));

   rollPer =
      myAvailSched_->netAndRoll (
         theMat,
         thePer,
         netReqVol,
         rollVol,
         bddSsrSplit);

   if (rollPer < 0)
      return;

   myReqSched_->addTo (theMat, rollPer, rollVol);

   if (multiSel ())
      if (tempCommActive_)
         mySelector ()->rollReq (theMat, thePer, rollPer, rollVol);
   }
d1570 55
a1624 55
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitConsEntry * theConsEnt;

   witAssert (deltaExecVol >= NET_TOL);

   if (not theBomEnt->inEffect (execPer))
      return;

   netConsEntries (theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);

   if (deltaExecVol < NET_TOL )
      return;

   if (theBomEnt->propRtg ()[execPer])
      {
      if (myPrMgr ()->selIsSplit (theBomEnt, execPer))
         explodeBomEntryPRSS (
            theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
      else
         explodeBomEntryPR (
            theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);

      return;
      }

   if (multiRoute_)
      if (myMrMgr ()->selIsSplit (theBomEnt, execPer))
         {
         explodeBomEntryMRSS (
            theBomEnt,
            execPer,
            deltaExecVol,
            fillPer,
            theBopEnt); 

         return;
         }

   theConsEnt = 
      multiRoute_?
         myMrMgr ()->selConsEnt (theBomEnt, execPer):
         theBomEnt;

   explodeConsEntry (
      theConsEnt,
      execPer, 
      deltaExecVol,
      fillPer, 
      theBopEnt);
   }
d1629 35
a1663 35
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitRtCandDblStack theSplitPairs (myProblem ());
   double            unbddVol;
   WitRtCand *       theRtCand;
   double            splitExecVol;
   WitConsEntry *    theConsEnt;

   witAssert (deltaExecVol >= NET_TOL);

   myMrMgr ()->
      defineSplit (theBomEnt, execPer, deltaExecVol, theSplitPairs, unbddVol);

   myMrMgr ()->mySelMgrForCons ()->setBoundedSplit (true);

   while (theSplitPairs.pop (theRtCand, splitExecVol))
      {
      theConsEnt = theRtCand->myConsEnt ();

      explodeConsEntry (theConsEnt, execPer, splitExecVol, fillPer, theBopEnt);
      }

   myMrMgr ()->mySelMgrForCons ()->setBoundedSplit (false);

   if (unbddVol > 0.0)
      {
      theConsEnt = myMrMgr ()->selConsEnt (theBomEnt, execPer);

      explodeConsEntry (theConsEnt, execPer, unbddVol, fillPer, theBopEnt);
      }
   }
d1668 33
a1700 33
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double &      netExecQty,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitSubEntry * theSub;

   if (not hasSubsToNet_ (theBomEnt))
      return;

   if (sglSrc_)
      if (theBomEnt->singleSource ())
         return;

   if (theBomEnt->propRtg ()[execPer])
      return;

   netConsEntry (theBomEnt, execPer, netExecQty, fillPer, theBopEnt);
      //
      // First net possible usage of prime from supply.

   if (netExecQty < NET_TOL)
      return;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      netSubEntry (theSub, execPer, netExecQty, fillPer, theBopEnt);

      if (netExecQty < NET_TOL)
         return;
      }
   }
d1705 37
a1741 37
      WitSubEntry * theSub,
      WitPeriod     execPer,
      double &      netExecQty,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   double oldExecQty;
   double deltaVol;
   double subVolVal;

   if (not theSub->netAllowed ())
      return;

   if (not theSub->inEffect (execPer))
      return;

   oldExecQty = netExecQty;

   netConsEntry (theSub, execPer, netExecQty, fillPer, theBopEnt);

   if (permCommActive_)
      {
      deltaVol = positivePart (oldExecQty - netExecQty);

      if (deltaVol > NET_TOL)
         {
         saveSubVol (theSub, execPer);

         subVolVal = theSub->subVol ()[execPer] + deltaVol;

         theSub->storeHeurSubVol (execPer, subVolVal);

         if (perfPegging_)
            myPegger_->pegDeltaVol (theSub, execPer, deltaVol);
         }
      }
   }
d1746 48
a1793 48
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double &       netExecQty,
      WitPeriod      fillPer,
      WitBopEntry *  theBopEnt)
   {
   double    reqConsQty;
   WitPart * consPart;
   WitPeriod consPer;
   double    netConsQty;

   witAssert (netExecQty > 0.0);

   reqConsQty = theConsEnt->effConsRate ()[execPer] * netExecQty;
   consPart   = theConsEnt->myPart ();
   consPer    = theConsEnt->impactPeriod ()[execPer];

   if (theConsEnt->effConsRate ()[execPer] >= FLOAT_EPSILON)
      {
      netConsQty = reqConsQty;

      myAvailSched_->netWoSR (consPart, consPer, netConsQty);

      netExecQty = netConsQty / theConsEnt->effConsRate ()[execPer];

      if (netExecQty <= NET_TOL)
         netExecQty = 0.0;
      else if (penExec_)
         myPenExMgr ()->recExpBeyondNet (consPart, consPer, true);

      if (multiSel ())
         if (tempCommActive_)
            if (reqConsQty - netConsQty > NET_TOL)
               mySelector ()->placeReqs (
                  theBopEnt,
                  theConsEnt,
                  execPer,
                  fillPer,
                  true);
      }
   else
      {
      if (theConsEnt->effConsRate ()[execPer] <= - FLOAT_EPSILON )
         myAvailSched_->addToIncAvailVol (consPart, consPer, - reqConsQty);

      netExecQty = 0.0;
      }
   }
d1798 23
a1820 23
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   double            unbddVol;
   WitRtCand *       theRtCand;
   double            propDeltaVol;

   myPrMgr ()->
      defineSplit (theBomEnt, execPer, deltaExecVol, theExpPairs, unbddVol);

   myPrMgr ()->mySelMgrForCons ()->setBoundedSplit (true);

   while (theExpPairs.pop (theRtCand, propDeltaVol))
      explodeConsEntry (
         theRtCand->myConsEnt (),
         execPer, 
         propDeltaVol,
         fillPer, 
         theBopEnt);
d1822 1
a1822 1
   myPrMgr ()->mySelMgrForCons ()->setBoundedSplit (false);
d1824 2
a1825 2
   if (unbddVol <= NET_TOL)
      return;
d1827 2
a1828 2
   explodeBomEntryPR (theBomEnt, execPer, unbddVol, fillPer, theBopEnt);
   }
d1833 23
a1855 23
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            propDeltaVol;

   if (selSplit_)
      myPrMgr ()->recordFlowSS (theBomEnt, execPer, deltaExecVol);

   myPrMgr ()->definePropExp (theBomEnt, execPer, deltaExecVol, theExpPairs);
   
   while (theExpPairs.pop (theRtCand, propDeltaVol))
      explodeConsEntry (
         theRtCand->myConsEnt (),
         execPer, 
         propDeltaVol,
         fillPer, 
         theBopEnt);
   }
d1860 42
a1901 42
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         netExecQty,
      WitPeriod      fillPer,
      WitBopEntry *  theBopEnt)
   {
   WitPeriod consPer;
   double    consumedQty;
   WitPart * consPart;

   witAssert (netExecQty > 0.0);

   if (sglSrc_)
      mySglSrcMgr ()->recExp (theConsEnt);

   consPer     = theConsEnt->impactPeriod ()[execPer];
   consumedQty = theConsEnt->effConsRate ()[execPer] * netExecQty;
   consPart    = theConsEnt->myPart ();

   if (consumedQty > NET_TOL)
      {
      myReqSched_->addTo (consPart, consPer, consumedQty);

      if (multiSel ())
         if (tempCommActive_)
            mySelector ()->placeReqs (
               theBopEnt,
               theConsEnt,
               execPer,
               fillPer,
               false);
      }

   if (consumedQty < - NET_TOL)
      myAvailSched_->addToIncAvailVol (consPart, consPer, - consumedQty);

   explodeSub (theConsEnt, execPer, netExecQty);

   if (selSplit_)
      if (multiRoute_)
         myMrMgr ()->recordFlowSS (theConsEnt, execPer, netExecQty);
   }
d1906 6
a1911 6
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         netExecQty)
   {
   WitSubEntry * theSub;
   double        subVolVal;
d1913 1
a1913 1
   theSub = theConsEnt->thisSub ();
d1915 2
a1916 2
   if (theSub == NULL)
      return;
d1918 2
a1919 2
   if (not permCommActive_)
      return;
d1921 1
a1921 1
   saveSubVol (theSub, execPer);
d1923 1
a1923 1
   subVolVal = theSub->subVol ()[execPer] + netExecQty;
d1925 1
a1925 1
   theSub->storeHeurSubVol (execPer, subVolVal);
d1927 3
a1929 3
   if (perfPegging_)
      myPegger_->pegDeltaVol (theSub, execPer, netExecQty);
   }
d1934 6
a1939 6
   {
   return
      multiRoute_? 
         myMrMgr ()->selBopEnt (thePart, expPer):
         thePart->expBopEntry (expPer);
   }
d1944 6
a1949 6
   {
   return
      multiExec_?
         myMeMgr ()->selExecPer (theBopEnt, expPer):
         theBopEnt ->expExecPeriod ()[expPer];
   }
@


1.233
log
@Modifiable Heuristic Allocation
@
text
@d177 3
@


1.232
log
@Modifiable heuristic allocation
@
text
@d222 1
a222 1
      myHeurModifier ()->delayedFeasCheck ();
@


1.231
log
@Heuristic Adjustment
@
text
@d22 1
a22 1
#include <HeurAdjuster.h>
d60 1
a60 1
      myHeurAdjuster_   (NULL),
d117 2
a118 2
   if (myGlobalComp ()->heurAdjustEnabled ())
      myHeurAdjuster_ = new WitHeurAdjuster (myAvailSched_);
d197 1
a197 1
   delete myHeurAdjuster_;
d221 2
a222 2
   if (myGlobalComp ()->heurAdjustEnabled ())
      myHeurAdjuster ()->delayedFeasCheck ();
@


1.230
log
@Heuristic Adjustment
@
text
@d221 3
@


1.229
log
@Heuristic Adjustment
@
text
@d22 1
d60 1
d117 3
d197 1
a246 12
void WitHeurAtor::adjustIncAvailVol (
      WitPart * thePart, 
      WitPeriod thePer, 
      double    deltaAvailVol)
   {
   witAssert (myProblem ()->myHeurAllMgr ()->heurAdjustActive ());

   myAvailSched_->addToIncAvailVol (thePart, thePer, deltaAvailVol);
   }

//------------------------------------------------------------------------------

@


1.228
log
@Heuristic Adjustment
@
text
@a17 1
#include <HeurAdjuster.h>
d246 1
a246 1
   witAssert (myProblem ()->myHeurAdjuster ()->active ());
@


1.227
log
@Heuristic Adjustment
@
text
@d18 1
a18 1
#include <HeurAdjMgr.h>
d247 1
a247 1
   witAssert (myProblem ()->myHeurAdjMgr ()->active ());
@


1.226
log
@Heuristic Adjustment
@
text
@d1378 1
a1378 2
   deltaExecVol =
      theOpn->lotSizeDelta (execPer, oldExecVol, deltaExecVol, true);
@


1.225
log
@Heuristic Adjustment
@
text
@d398 7
@


1.224
log
@Heuristic Adjustment
@
text
@a397 7
void WitHeurAtor::updateForAdjust ()
   {
   myAvailSched_->updateForAdjust ();
   }

//------------------------------------------------------------------------------

@


1.223
log
@Heuristic Adjustment
@
text
@d245 1
a245 1
      double    deltaVol)
d249 1
a249 1
   myAvailSched_->addToIncAvailVol (thePart, thePer, deltaVol);
@


1.222
log
@Heuristic Adjustment
@
text
@d19 1
a19 1
#include <AvSched.h>
@


1.221
log
@Heuristic Adjustment
@
text
@d18 1
d242 4
a245 4
void WitHeurAtor::adjustForShipVol (
      WitDemand * theDemand,
      WitPeriod   shipPer,
      double      deltaShipVol)
d247 3
a249 1
   myAvailSched_->adjustForShipVol (theDemand, shipPer, deltaShipVol);
@


1.220
log
@Heuristic Adjustment
@
text
@d241 10
@


1.219
log
@Pause/Resume
@
text
@d385 7
@


1.218
log
@Pause / Resume
@
text
@a76 1
      paused_           (false),
@


1.217
log
@Lead Time Bounds
@
text
@d77 1
@


1.216
log
@Lead Time Bounds.
@
text
@a505 6

   if (multiSel ())
      {
      if (sglSrc_)
         myMsgFac () ("ltbCaseNyaSmsg", "single source");
      }
@


1.215
log
@Lead Time Bounds
@
text
@a508 3
      if (penExec_)
         myMsgFac () ("ltbCaseNyaSmsg", "penalized execution");

@


1.214
log
@Selection Recovery
@
text
@a508 3
      if (mySelector ()->propRtg ())
         myMsgFac () ("ltbCaseNyaSmsg", "proportionate routing");

@


1.213
log
@Lead Time Bounds.
@
text
@d658 1
a658 1
         mySelector ()->recoverSelections ();
@


1.212
log
@Selection recovery.
@
text
@a516 3

      if (selSplit_)
         myMsgFac () ("ltbCaseNyaSmsg", "selection splitting");
d954 2
a955 1
      netAndRollReq                  (theMat,  fillPer, netReqVol, bddSsrSplit);
d957 1
a957 1
      myAvailSched_->netMatWoSR      (theMat,  fillPer, netReqVol);
d1121 10
@


1.211
log
@Name change: "selection reuse" has becomne "selection recovery".
@
text
@d661 1
a661 1
         mySelector ()->restoreConfig ();
@


1.210
log
@Selection reuse.
@
text
@d502 1
a502 1
   if (not myGlobalComp ()->selectionReuse ())
d504 1
a504 1
      myMsgFac () ("boolAttReqForLtbSmsg", "selectionReuse", true);
d660 1
a660 1
      if (myGlobalComp ()->selectionReuse ())
@


1.209
log
@Selection reuse.
@
text
@d801 2
a802 1
         mySelector ()->printCommitMaxQtySelIA ();
@


1.208
log
@Selection reuse.
@
text
@d779 1
a779 1
   if (myGlobalComp ()->selPrintLevel () >= 3)
@


1.207
log
@Selection reuse.
@
text
@d642 9
d660 2
a661 3
      if    (myGlobalComp ()->selectionReuse ())
         if (myGlobalComp ()->newSelReuse    ())
            mySelector ()->restoreConfig ();
a671 9

   if (myGlobalComp ()->printIncAlloc ())
      if (myMsgFac ().mayIssue ("incAllocMsg"))
         myMsgFac () ("incAllocMsg",
            theDemand->demandedPartName (),
            theDemand->demandName (),
            thePer,
            desIncVol,
            incVol);
@


1.206
log
@Selection reuse
@
text
@d650 4
a653 3
   if (myGlobalComp ()->selectionReuse ())
      if (multiSel ())
         mySelector ()->restoreConfig ();
@


1.205
log
@Lead Time Bounds
@
text
@d650 4
@


1.204
log
@Lead Time Bounds
@
text
@a508 3
      if (mySelector ()->selectiveSR ())
         myMsgFac () ("ltbCaseNyaSmsg", "stock reallocation");

@


1.203
log
@Lead Time Bounds.
@
text
@a508 3
      if (multiExec_)
         myMsgFac () ("ltbCaseNyaSmsg", "multiple execution periods");

a514 3
      if (myGlobalComp ()->twoWayMultiExec ())
         myMsgFac () ("ltbCaseNyaSmsg", "two-way multiple execution periods");

@


1.202
log
@Lead Time BOunds.
@
text
@a508 3
      if (multiRoute_)
         myMsgFac () ("ltbCaseNyaSmsg", "multiple routes");

@


1.201
log
@Lead Time Bounds
@
text
@d506 27
@


1.200
log
@Lead Time Bounds.
@
text
@d981 4
a984 1
      recFundShortage (thePart, fillPer);
d992 4
a995 1
         recFundShortage (thePart, fillPer);
a1204 14
void WitHeurAtor::recFundShortage (WitPart * thePart, WitPeriod fillPer)
   {
   if (multiSel ())
      mySelector ()->    recFundShortage (thePart, fillPer);

   if (critListMode ())
      myHeurCritList ()->recFundShortage (thePart, fillPer);

   if (pclMode ())
      myPclBldr ()->     recFundShortage (thePart, fillPer);
   }

//------------------------------------------------------------------------------

d1406 1
a1406 5
      if (critListMode ())
         myHeurCritList ()->recFundShortage (theBopEnt->myPart (), fillPer);

      if (pclMode ())
         myPclBldr ()->     recFundShortage (theBopEnt->myPart (), fillPer);
d1414 11
@


1.199
log
@Lead Time BOonds
@
text
@d476 1
a476 1
   WitMaterial * theMat;
d480 1
a480 1
   forEachMaterial (theMat, myProblem ())
d482 1
a482 1
      if (theMat->boundedLeadTime ())
d986 1
a986 1
   if (thePart->boundedLeadTime ())
@


1.198
log
@Lead Time Bounds.
@
text
@d986 8
d1371 1
a1371 1
            myPclBldr ()->     recRestShortage ();
@


1.197
log
@Lead Time Bounds
@
text
@d1325 1
a1325 1
   double         newExecVol;
d1348 2
a1349 3
   if (finiteExecBounds_)
      {
      newExecVol = oldExecVol + deltaExecVol;
d1351 2
a1352 3
      if (not checkExecBounds (theBopEnt, execPer, newExecVol, fillPer))
         return false;
      }
d1383 1
a1383 1
bool WitHeurAtor::checkExecBounds (
d1386 2
a1387 1
      double        theExecVol,
d1390 1
a1390 1
   WitOperation * theOpn;
d1392 2
a1393 1
   theOpn = theBopEnt->myOperation ();
d1395 5
a1399 2
   if (theOpn->execBounds ()->hardUBisSatisfied (execPer, theExecVol))
      return true;
d1401 4
a1404 2
   if (multiSel ())
      mySelector ()->recExecBoundShortage (theBopEnt, execPer, fillPer);
d1406 2
a1407 2
   if (critListMode ())
      myHeurCritList ()->recFundShortage (theBopEnt->myPart (), fillPer);
d1409 3
a1411 2
   if (pclMode ())
      myPclBldr ()->     recFundShortage (theBopEnt->myPart (), fillPer);
d1413 1
a1413 1
   return false;
@


1.196
log
@Lead Time Bounds
@
text
@d962 1
a962 4
   bool          expPerFound;
   WitPeriod     expPer;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
d974 4
a977 1
   expPerFound = findExpPer (thePart, fillPer, expPer);
d979 1
a979 1
   if (not expPerFound)
d994 1
a994 10
   if (selSplit_)
      return explodePartSS (thePart, expPer, netReqVol, fillPer);

   if (thePart->propRtg ()[expPer])
      return explodePartPR (thePart, expPer, netReqVol, fillPer);

   theBopEnt = expBopEntry (thePart,   expPer);
   execPer   = execPerFor  (theBopEnt, expPer);

   return explode (theBopEnt, execPer, netReqVol, fillPer);
d1052 23
a1190 22
bool WitHeurAtor::findExpPer (
      WitPart *   thePart, 
      WitPeriod   fillPer, 
      WitPeriod & expPer) 
   {
   expPer =
      buildAhead_? 
         myBaMgr ()->selExpPer (thePart, fillPer):
         thePart   ->explosionPeriod    (fillPer);

   if (not thePart->explodeable (expPer))
      return false;

   if (leadTimeBounds_)
      if (expPer < ltbMinPer_)
         return false;

   return true;
   }

//------------------------------------------------------------------------------

d1233 1
a1233 1
         expOK   = explode (theBopEnt, execPer, propExpVol, fillPer);
d1264 1
a1264 1
   return explode (theBopEnt, execPer, expVol, fillPer);
d1295 1
a1295 1
      expOK   = explode (theBopEnt, execPer, splitExpVol, fillPer);
d1308 1
a1308 1
         expOK   = explode (theBopEnt, execPer, unbddVol, fillPer);
d1316 1
a1316 1
bool WitHeurAtor::explode (
d1378 1
a1378 1
   innerExplode (theBopEnt, execPer, qty, deltaExecVol, fillPer);
d1412 1
a1412 1
void WitHeurAtor::innerExplode (
@


1.195
log
@Lead Time Bounds
@
text
@d79 1
d201 1
a201 1
double WitHeurAtor::inc (
a206 1
   double incVolUB;
d218 1
a218 6
   if (theDemand->shipLateAllowed ())
      incVolUB = minUnmetCumDem (theDemand, thePer);
   else
      incVolUB =
           theDemand->demandVol ()[thePer]
         - theDemand->shipVol   ()[thePer];
d220 1
a220 1
   if (incVolUB <= NET_TOL)
d223 1
a223 14
   demandedIncVol = min (desIncVol, incVolUB);

   if (perfPegging_)
      myPegger_->setUpPeggedIncAlloc (theDemand, thePer);

   if (pclMode ())
      myPclBldr ()->preIncAlloc (theDemand, thePer);

   if (myGlobalComp ()->twoWayMultiExec ())
      myMeMgr ()->setInitDirIsAsap (asapMultiExec);
   else
      witAssert (not asapMultiExec);

   searchInc_ = theDemand->searchInc ();
d225 1
a225 1
   netQty     = demandedIncVol;
d234 1
a234 26
   if (incVol >= NET_TOL)
      theDemand->incShipVolForHeur (thePer, incVol);

   searchInc_ = 1.0;

   if (penExec_)
      myPenExMgr ()->replenishPsSups ();

   if (perfPegging_)
      myPegger_->shutDownPeggedIncAlloc ();

   if (myGlobalComp ()->pipSeqFromHeur ())
      if (myProblem ()->heurVariant ()->isCurrent ())
         if (incVol > NET_TOL)
            myProblem ()->
               myPipMgr ()->
                  appendToShipSeq (theDemand, thePer, incVol);

   if (myGlobalComp ()->printIncAlloc ())
      if (myMsgFac ().mayIssue ("incAllocMsg"))
         myMsgFac () ("incAllocMsg",
            theDemand->demandedPartName (),
            theDemand->demandName (),
            thePer,
            desIncVol,
            incVol);
d510 19
d556 25
d618 39
d980 3
d984 1
d1187 11
a1197 2
   if (thePart->explodeable (expPer))
      return true;
d1199 2
a1208 2

   return false;
@


1.194
log
@Lead Time Bounds
@
text
@d542 6
a547 1
      myMsgFac () ("ltbSkipFailuresSmsg");
@


1.193
log
@Bounded Lead Times
@
text
@d539 5
@


1.192
log
@Bounded lead times.
@
text
@d78 1
a78 1
      boundedLTs_       (false),
d142 1
a142 1
   compBoundedLTs ();
d144 2
a145 2
   if (boundedLTs_)
      setUpBoundedLTs ();
d517 1
a517 1
void WitHeurAtor::compBoundedLTs ()
d521 1
a521 1
   boundedLTs_ = false;
d525 1
a525 1
      if (theMat->boundedLeadTimes ())
d527 1
a527 1
         boundedLTs_ = true;
d536 1
a536 1
void WitHeurAtor::setUpBoundedLTs ()
d538 1
a538 1
   myMsgFac () ("boundedLTsMsg");
@


1.191
log
@Fixed bug: Printing of incHeurAlloc data is no longer controlled by the
           timesPrint mesg attribute.
@
text
@d78 1
d142 5
d517 26
@


1.190
log
@Stochastic Implosion
@
text
@d264 8
a271 7
   if (myMsgFac ().mayIssue ("incAllocMsg"))
      myMsgFac () ("incAllocMsg",
         theDemand->demandedPartName (),
         theDemand->demandName (),
         thePer,
         desIncVol,
         incVol);
@


1.189
log
@Stochastic Implosion
@
text
@a36 1
#include <HeurAccess.h>
@


1.188
log
@Stochastic Implosion
@
text
@d42 1
a42 1
#include <Repos.h>
d403 1
a403 1
      tempCommRepos_->saveHeurExecVol (theOpn, thePer);
d406 12
a417 1
      mySglSrcMgr ()->saveExecVol     (theOpn, thePer);
d1597 1
a1597 1
         saveVal (WitHeurAccess::subVol (theSub).elemRef (execPer));
d1787 1
a1787 1
   saveVal (WitHeurAccess::subVol (theSub).elemRef (execPer));
@


1.187
log
@Stochastic Implosion
@
text
@d400 11
d492 1
a492 1
      WitHeurAccess::execVol (theOpn) = 0.0;
d495 1
a495 1
      WitHeurAccess::subVol (theSub) = 0.0;
d1322 1
d1329 3
a1331 1
   saveVal (WitHeurAccess::execVol (theOpn).elemRef (execPer));
d1333 1
a1333 1
   WitHeurAccess::execVol (theOpn).elemRef (execPer) += deltaExecVol;
d1568 1
d1588 3
a1590 1
         WitHeurAccess::subVol (theSub).elemRef (execPer) += deltaVol;
d1766 1
d1778 3
a1780 1
   WitHeurAccess::subVol (theSub).elemRef (execPer) += netExecQty;
@


1.186
log
@[disallowed backlog]
@
text
@d248 1
a248 1
      WitHeurAccess::shipVol (theDemand).elemRef (thePer) += incVol;
d478 1
a478 1
      WitHeurAccess::shipVol (theDemand) = 0.0;
@


1.185
log
@[disallowed backlog]
@
text
@d213 1
a213 1
   if (theDemand->backlogAllowed ())
@


1.184
log
@[disallowed backlog]
@
text
@d201 1
d213 6
a218 4
   demandedIncVol = min (desIncVol, minUnmetCumDem (theDemand, thePer));
      //
      // demandedIncVol is desIncVol reduced so as not to exceed cumulative
      // demand.
d220 1
a220 1
   if (demandedIncVol <= NET_TOL)
d223 2
@


1.183
log
@[disallowed backlog]
@
text
@d37 1
a48 10
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec    WitDemand::* WitHeurAtor::shipVol_ = NULL;
WitDblFlexVec WitOperation::* WitHeurAtor::execVol_ = NULL;
WitDblFlexVec  WitSubEntry::* WitHeurAtor::subVol_  = NULL;

//------------------------------------------------------------------------------

d243 1
a243 1
      (theDemand->*shipVol_).elemRef (thePer) += incVol;
a394 30
void WitHeurAtor::receiveDMPs (WitDblFlexVec WitDemand::* shipVolArg)
   {
   shipVol_ = shipVolArg;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::receiveDMPs (WitDblFlexVec WitOperation::* execVolArg)
   {
   execVol_ = execVolArg;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::receiveDMPs (WitDblFlexVec WitSubEntry::* subVolArg)
   {
   subVol_ = subVolArg;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::receiveDMPs (
      WitList <WitPartPer> WitGlobalComp::* criticalListArg,
      WitList <WitPclEl>   WitGlobalComp::* pgdCritListArg)
   {
   WitPclBldr::receiveDMPs (pgdCritListArg);
   }

//------------------------------------------------------------------------------

d473 1
a473 1
      theDemand->*shipVol_ = 0.0;
d476 1
a476 1
      theOpn->*execVol_ = 0.0;
d479 1
a479 1
      theSub->*subVol_ = 0.0;
d1312 1
a1312 1
   saveVal ((theOpn->*execVol_).elemRef (execPer));
d1314 1
a1314 1
   (theOpn->*execVol_).elemRef (execPer) += deltaExecVol;
d1566 1
a1566 1
         saveVal ((theSub->*subVol_).elemRef (execPer));
d1568 1
a1568 1
         (theSub->*subVol_).elemRef (execPer) += deltaVol;
d1753 1
a1753 1
   saveVal ((theSub->*subVol_).elemRef (execPer));
d1755 1
a1755 1
   (theSub->*subVol_).elemRef (execPer) += netExecQty;
@


1.182
log
@Rescinded all changed made since 1/31/07.
@
text
@d429 1
a429 2
   WitHeurCritList::receiveDMPs (criticalListArg);
   WitPclBldr     ::receiveDMPs (pgdCritListArg);
@


1.181
log
@[disallowed backlog]
@
text
@d48 10
d252 1
a252 1
      theDemand->shipVol_ ().elemRef (thePer) += incVol;
d404 21
d513 1
a513 1
      theDemand->shipVol_ () = 0.0;
d516 1
a516 1
      theOpn->execVol_ () = 0.0;
d519 1
a519 1
      theSub->subVol_ () = 0.0;
d1352 1
a1352 1
   saveVal (theOpn->execVol_ ().elemRef (execPer));
d1354 1
a1354 1
   theOpn->execVol_ ().elemRef (execPer) += deltaExecVol;
d1606 1
a1606 1
         saveVal (theSub->subVol_ ().elemRef (execPer));
d1608 1
a1608 1
         theSub->subVol_ ().elemRef (execPer) += deltaVol;
d1793 1
a1793 1
   saveVal (theSub->subVol_ ().elemRef (execPer));
d1795 1
a1795 1
   theSub->subVol_ ().elemRef (execPer) += netExecQty;
@


1.180
log
@[disallowed backlog]
@
text
@a47 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec WitSubEntry::* WitHeurAtor::subVol_ = NULL;

//------------------------------------------------------------------------------

d242 1
a242 1
      theDemand->shipVol_->elemRef (thePer) += incVol;
a393 7
void WitHeurAtor::receiveDMPs (WitDblFlexVec WitSubEntry::* subVolArg)
   {
   subVol_ = subVolArg;
   }

//------------------------------------------------------------------------------

d482 1
a482 1
      theDemand->shipVol_.forUpdate () = 0.0;
d485 1
a485 1
      theOpn->execVol_.forUpdate () = 0.0;
d488 1
a488 1
      theSub->*subVol_ = 0.0;
d1321 1
a1321 1
   saveVal (theOpn->execVol_->elemRef (execPer));
d1323 1
a1323 1
   theOpn->execVol_->elemRef (execPer) += deltaExecVol;
d1575 1
a1575 1
         saveVal ((theSub->*subVol_).elemRef (execPer));
d1577 1
a1577 1
         (theSub->*subVol_).elemRef (execPer) += deltaVol;
d1762 1
a1762 1
   saveVal ((theSub->*subVol_).elemRef (execPer));
d1764 1
a1764 1
   (theSub->*subVol_).elemRef (execPer) += netExecQty;
@


1.179
log
@External opt implosion.
@
text
@d52 1
a52 3
WitDblFlexVec    WitDemand::* WitHeurAtor::shipVol_ = NULL;
WitDblFlexVec WitOperation::* WitHeurAtor::execVol_ = NULL;
WitDblFlexVec  WitSubEntry::* WitHeurAtor::subVol_  = NULL;
d250 1
a250 1
      (theDemand->*shipVol_).elemRef (thePer) += incVol;
a401 14
void WitHeurAtor::receiveDMPs (WitDblFlexVec WitDemand::* shipVolArg)
   {
   shipVol_ = shipVolArg;
   }

//------------------------------------------------------------------------------

void WitHeurAtor::receiveDMPs (WitDblFlexVec WitOperation::* execVolArg)
   {
   execVol_ = execVolArg;
   }

//------------------------------------------------------------------------------

d497 1
a497 1
      theDemand->*shipVol_ = 0.0;
d500 1
a500 1
      theOpn->*execVol_ = 0.0;
d1336 1
a1336 1
   saveVal ((theOpn->*execVol_).elemRef (execPer));
d1338 1
a1338 1
   (theOpn->*execVol_).elemRef (execPer) += deltaExecVol;
@


1.178
log
@external opt implosion.
@
text
@d263 1
a263 1
      if (myProblem ()->myHeurVariant ()->isCurrent ())
@


1.177
log
@Heuristic search increment.
@
text
@d38 1
d110 1
a110 1
      myProblem ()->myPostprocessor ()->verifyUhsFeas ();
@


1.176
log
@Heuristic search increment.
@
text
@d91 1
a91 1
      searchInc_        (0.0),
d253 1
a253 1
   searchInc_ = 0.0;
d660 1
a660 1
         if (netQty > SEARCH_TOL)
d715 1
a715 1
   if (desQty <= SEARCH_TOL)
d718 1
a718 1
   if (desQty <= searchInc_ * (1.0 + SEARCH_TOL))
d728 1
a728 1
   success = tempCommit (searchInc_);
d764 1
a764 1
   failMult = ceil (desQty / searchInc_ - SEARCH_TOL);
d772 1
a772 1
      success = tempCommit (curMult * searchInc_);
d780 1
a780 1
   return (okMult * searchInc_);
@


1.175
log
@Heuristic search increment.
@
text
@d91 1
d239 3
a241 1
   netQty = demandedIncVol;
d253 2
d718 1
a718 1
   if (desQty <= myGlobalComp ()->heurSearchInc () * (1.0 + SEARCH_TOL))
d728 1
a728 1
   success = tempCommit (myGlobalComp ()->heurSearchInc ());
d751 1
a751 2
// failMult, okMult, and curMult are all expressed as multiples of
// heurSearchInc.
d764 1
a764 1
   failMult = ceil (desQty / myGlobalComp ()->heurSearchInc () - SEARCH_TOL);
d772 1
a772 1
      success = tempCommit (curMult * myGlobalComp ()->heurSearchInc ());
d780 1
a780 1
   return (okMult * myGlobalComp ()->heurSearchInc ());
@


1.174
log
@Heuristic search increment.
@
text
@d713 1
a713 1
   if (desQty <= 1.0 + SEARCH_TOL)
a715 2
         //
         // The desired quantity is the smallest amount allowed.
d723 1
a723 1
   success = tempCommit (1);
a726 2
         //
         // 1 is infeasible.
a731 2
         //
         // The desired quantity is feasible.
@


1.173
log
@Heuristic search increment.
@
text
@a299 1
   double oldNetQty;
a301 8
   if (penExec_)
      oldNetQty = netQty;

   myAvailSched_->netWoSR (topPart (), topPer (), netQty);

   if (penExec_)
      mySelector ()->recCommitVol (oldNetQty - netQty, false);

d313 1
a313 1
         mySelector ()->recCommitVol (maxQty, true);
@


1.172
log
@Updated the copyright date on all source files.
@
text
@d752 12
d767 4
a770 4
   double  failQty;
   double  okQty;
   double  tryQty;
   bool    success;
d775 1
a775 1
   failQty = ceil (desQty - SEARCH_TOL);
d777 1
a777 1
   okQty   = 1.0;
d779 1
a779 1
   while (failQty - okQty > 1.5)
d781 1
a781 1
      tryQty  = floor (((okQty + failQty) / 2.0) + SEARCH_TOL);
d783 1
a783 1
      success = tempCommit (tryQty);
d786 1
a786 1
         okQty   = tryQty;
d788 1
a788 1
         failQty = tryQty;
d791 1
a791 1
   return okQty;
@


1.171
log
@Fixed bugs:
   witWriteData didn't write problem.compPrices.
   witWriteData didn't write problem.accMethod.
   witCopyData  didn't copy  problem.solverLogFileName.
   witCopyData  didn't copy  problem.accMethod.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.170
log
@[shared-resource pegging]
@
text
@d626 1
a626 1
      if (thePer < nPeriods () - 1)
@


1.169
log
@[shared-resource pegging]
@
text
@a39 1
#include <Dense.h>
@


1.168
log
@[multi-thread]
@
text
@d812 5
a816 4
   WitPart * fillPart;
   WitPeriod fillPer;
   double    theReqVol;
   bool      fillOK;
d823 3
a825 1
   forEachElDense (fillPart, topPart ()->belowList ())
@


1.167
log
@Trivial update.
@
text
@d48 10
d59 3
a61 8
               WitProblem *                              theProblem,
               WitPegger *                               thePegger,
               bool                                      forOpt,
         const WitRefMap <WitDemand,    WitDblFlexVec> & shipVolArg,
         const WitRefMap <WitOperation, WitDblFlexVec> & execVolArg,
         const WitRefMap <WitSubEntry,  WitDblFlexVec> & subVolArg,
               WitList   <WitPartPer>                  & criticalListArg,
               WitList   <WitPclEl>                    & pgdCritListArg):
a64 4
      shipVol_          (shipVolArg),
      execVol_          (execVolArg),
      subVol_           (subVolArg),
      criticalList_     (criticalListArg),
d113 1
a113 1
         myHeurCritList_ = new WitHeurCritList (myProblem (), criticalList_);
d117 1
a117 1
         myPclBldr_ = new WitPclBldr (myProblem (), pgdCritListArg);
d249 1
a249 1
      shipVol_ (theDemand).elemRef (thePer) += incVol;
d408 31
d517 1
a517 1
      shipVol_ (theDemand) = 0.0;
d520 1
a520 1
      execVol_ (theOpn) = 0.0;
d523 1
a523 1
      subVol_ (theSub) = 0.0;
d1348 1
a1348 1
   saveVal (execVol_ (theOpn).elemRef (execPer));
d1350 1
a1350 1
   execVol_ (theOpn).elemRef (execPer) += deltaExecVol;
d1602 1
a1602 1
         saveVal (subVol_ (theSub).elemRef (execPer));
d1604 1
a1604 1
         subVol_ (theSub).elemRef (execPer) += deltaVol;
d1789 1
a1789 1
   saveVal (subVol_ (theSub).elemRef (execPer));
d1791 1
a1791 1
   subVol_ (theSub).elemRef (execPer) += netExecQty;
@


1.166
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@a495 2
#include <Session.h>

@


1.165
log
@Revised mappingIndex code.
@
text
@d496 2
@


1.164
log
@Vector PropRtg.
@
text
@a42 1
#include <MapIdxI.h>
@


1.163
log
@Vector PropRtg.
@
text
@d448 1
a448 1
   if (mySelector ()->propRouting ())
@


1.162
log
@Vector PropRtg.
@
text
@d143 1
a143 1
      if (not (theOpn->execBounds ()->hardUB () == -1.0))
d569 1
a569 1
      if (not (theMat->stockBounds ()->softLB () == 0.0))
@


1.161
log
@Vector Prop-Rtg.
@
text
@d889 1
a889 1
   if (thePart->propRt ()[expPer])
d967 1
a967 1
   if (thePart->propRt ()[expPer])
d1429 1
a1429 1
   if (theBomEnt->propRt ()[execPer])
d1524 1
a1524 1
   if (theBomEnt->propRt ()[execPer])
@


1.160
log
@Pegged Critical List.
@
text
@d889 1
a889 1
   if (thePart->propRouting ())
d967 1
a967 1
   if (thePart->propRouting ())
d1429 1
a1429 1
   if (theBomEnt->propRouting ())
d1524 1
a1524 1
   if (theBomEnt->propRouting ())
@


1.159
log
@Pegged Critical List.
@
text
@d327 1
a327 2
      if (not (penExec_ and myPenExMgr ()->failRestShortOnly ()))
         myHeurCritList ()->appendCulprit ();
d330 1
a330 1
      myPclBldr ()->postCmqs ();
d1083 1
a1083 1
      mySelector ()->recFundShortage (thePart, fillPer);
d1086 1
a1086 1
      myHeurCritList ()->setCulprit (thePart, fillPer);
d1089 1
a1089 1
      myPclBldr ()->recFundShortage (thePart, fillPer);
d1252 3
d1256 1
a1256 1
            myPclBldr ()->recRestShortage ();
d1293 1
a1293 1
      myHeurCritList ()->setCulprit (theBopEnt->myPart (), fillPer);
d1296 1
a1296 1
      myPclBldr ()->recFundShortage (theBopEnt->myPart (), fillPer);
@


1.158
log
@pegged Critical List.
@
text
@d116 1
a116 1
      if (myGlobalComp ()->pgdCritListNeeded ())
@


1.157
log
@Pegged Critical List
@
text
@d21 1
a21 1
#include <PclMgr.h>
d50 8
a57 7
         WitProblem *                              theProblem,
         WitPegger *                               thePegger,
         bool                                      forOpt,
         WitRefMap <WitDemand,    WitDblFlexVec> & shipVolArg,
         WitRefMap <WitOperation, WitDblFlexVec> & execVolArg,
         WitRefMap <WitSubEntry,  WitDblFlexVec> & subVolArg,
         WitRef    <WitList <WitPartPer> >       & criticalListArg):
d68 1
a68 1
      myPclMgr_         (NULL),
d117 1
a117 1
         myPclMgr_ = myProblem ()->myHeurAllMgr ()->myPclMgr ();
d194 1
d231 2
a232 2
   if (pgdCritListMode ())
      myPclMgr ()->preIncAlloc (theDemand, thePer);
d330 2
a331 2
   if (pgdCritListMode ())
      myPclMgr ()->postCmqs ();
d483 2
a484 2
   if (pgdCritListMode ())
      myPclMgr ()->initSoln ();
d1089 2
a1090 2
   if (pgdCritListMode ())
      myPclMgr ()->recFundShortage (thePart, fillPer);
d1253 2
a1254 2
         if (pgdCritListMode ())
            myPclMgr ()->recRestShortage ();
d1293 2
a1294 2
   if (pgdCritListMode ())
      myPclMgr ()->recFundShortage (theBopEnt->myPart (), fillPer);
@


1.156
log
@Pegged critical list.
@
text
@d115 1
a115 1
      if (myGlobalComp ()->compPgdCritList ())
d1252 1
a1252 1
            myPclMgr ()->recNonFundShortage ();
@


1.155
log
@Pegged Critical List.
@
text
@d1088 1
a1088 1
      myPclMgr ()->setBlockPt (thePart, fillPer);
d1251 3
d1292 1
a1292 1
      myPclMgr ()->setBlockPt (theBopEnt->myPart (), fillPer);
@


1.154
log
@Tie Breaking Prop-Rt.
@
text
@d17 1
d21 1
d67 1
d114 4
d229 3
d325 2
a326 4
      {
      if (penExec_)
         if (myPenExMgr ()->failRestShortOnly ())
            return;
d328 2
a329 2
      myHeurCritList ()->appendCulprit ();
      }
a465 4
   if (selSplit_)
      if (critListMode ())
         myMsgFac () ("critListSelSplitSmsg");

d481 3
d1087 3
d1288 3
@


1.153
log
@Pegged critical list.
@
text
@d31 1
a31 1
#include <PipSysMgr.h>
d155 1
a155 1
      myProblem ()->myPipSysMgr ()->clearShipSeq ();
d248 3
a250 4
            myProblem ()->myPipSysMgr ()->appendToShipSeq (
               theDemand,
               thePer,
               incVol);
@


1.152
log
@Pegged critical list.
@
text
@d1137 1
a1137 1
      myMrMgr ()->recordFlowSS (theBopEnt->myRtCand (), expPer, expVol);
d1719 1
a1719 2
         myMrMgr ()->
            recordFlowSS (theConsEnt->myRtCand (), execPer, netExecQty);
@


1.151
log
@Low-Pri Prop-Rt.
@
text
@d962 1
a962 1
      if (myPrMgr ()->selIsSplit (thePart->myRtSite (), expPer))
d964 2
a965 2
      else
         return explodePartPR   (thePart, expPer, expVol, fillPer);
d969 1
a969 1
      if (myMrMgr ()->selIsSplit (thePart->myRtSite (), expPer))
d992 1
a992 6
   myPrMgr ()->defineSplit (
      thePart->myRtSite (),
      expPer,
      expVol,
      theExpPairs,
      unbddVol);
d1033 1
a1033 6
   myMrMgr ()->defineSplit (
      thePart->myRtSite (),
      expPer,
      expVol,
      theSplitPairs,
      unbddVol);
d1100 1
a1100 1
      myPrMgr ()->recordFlowSS (thePart->myRtSite (), expPer, expVol);
d1102 1
a1102 2
   myPrMgr ()->
      definePropExp (thePart->myRtSite (), expPer, expVol, theExpPairs);
d1137 1
a1137 4
      myMrMgr ()->recordFlowSS (
         theBopEnt->myPart ()->myRtSite (),
         expPer,
         expVol);
d1412 1
a1412 1
      if (myPrMgr ()->selIsSplit (theBomEnt->myRtSite (), execPer))
d1423 1
a1423 1
      if (myMrMgr ()->selIsSplit (theBomEnt->myRtSite (), execPer))
d1437 1
a1437 1
         myMrMgr ()->selRtCand (theBomEnt->myRtSite (), execPer)->myConsEnt ():
d1465 2
a1466 6
   myMrMgr ()->defineSplit (
      theBomEnt->myRtSite (),
      execPer,
      deltaExecVol,
      theSplitPairs,
      unbddVol);
d1481 1
a1481 4
      theConsEnt =
         myMrMgr ()->
            selRtCand (theBomEnt->myRtSite (), execPer)->
               myConsEnt ();
d1629 1
a1629 6
      defineSplit (
         theBomEnt->myRtSite (),
         execPer,
         deltaExecVol,
         theExpPairs,
         unbddVol);
d1663 1
a1663 2
      myPrMgr ()->
         recordFlowSS (theBomEnt->myRtSite (), execPer, deltaExecVol);
d1665 1
a1665 5
   myPrMgr ()->definePropExp (
      theBomEnt->myRtSite (),
      execPer,
      deltaExecVol,
      theExpPairs);
d1719 2
a1720 4
         myMrMgr ()->recordFlowSS (
            theConsEnt->myBomEnt ()->myRtSite (),
            execPer,
            netExecQty);
d1754 1
a1754 1
         myMrMgr ()->selRtCand (thePart->myRtSite (), expPer)->myBopEnt ():
@


1.150
log
@Low-Pri Prop-Rt.
@
text
@d28 1
a28 1
#include <ExpRest.h>
d71 1
a71 1
      myExpRest_        (NULL),
d240 1
a240 1
      myExpRest ()->replenishPsSups ();
d318 1
a318 1
         if (myExpRest ()->failRestShortOnly ())
d457 1
a457 1
      myExpRest_ = mySelector ()->myExpRest ();
d864 1
a864 1
      myExpRest ()->recExpBeyondNet (thePart, fillPer, false);
d912 1
a912 1
      myExpRest ()->recExpBeyondNet (thePart, fillPer, false);
d1252 1
a1252 1
      if (not myExpRest ()->restExpAllowed (theBopEnt, fillPer))
d1330 1
a1330 1
         myExpRest ()->postExpBomEnt ();
d1368 1
a1368 1
               myExpRest ()->reqPsSupRep (prodPart, prodPer);
d1614 1
a1614 1
         myExpRest ()->recExpBeyondNet (consPart, consPer, true);
@


1.149
log
@Low-Pri Prop-Rt.
@
text
@d1003 1
a1003 1
      myPrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (true);
d1007 1
a1007 1
      myPrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
d1045 1
a1045 1
   myMrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (true);
d1057 1
a1057 1
   myMrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
d1486 1
a1486 1
   myMrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (true);
d1495 1
a1495 1
   myMrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
d1657 1
a1657 1
   myPrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (true);
d1667 1
a1667 1
   myPrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
@


1.148
log
@Low-Pri Prop-Rt.
@
text
@d74 1
a74 1
      tempModeRepos_    (NULL),
d84 2
a85 1
      tempMode_         (false),
d157 1
a157 1
   tempModeRepos_ = new WitDataRepos (theProblem);
d183 1
a183 1
   delete tempModeRepos_;
d331 2
a332 1
   witAssert (not tempMode_);
d336 1
a336 1
   tempMode_ = true;
d338 1
a338 1
   success   = commit (qty);
d346 1
a346 1
   tempMode_ = false;
d380 2
a381 2
   if (tempMode_)
      tempModeRepos_->saveVal (theVar);
d391 2
a392 2
   if (tempMode_)
      tempModeRepos_->saveVal (theVar);
d637 4
a640 1
   witAssert (not tempMode_);
d649 2
d747 1
a747 3
#if 0

double WitHeurAtor::binarySearch (double desQty)
a748 3
   int  failIntQty;
   int  okIntQty;
   int  tryIntQty;
d751 1
a751 29
   if (DEVELOPMENT)
      nBsearches_ ++;

   failIntQty = static_cast <int> (ceil (desQty - SEARCH_TOL));

   okIntQty   = 1;

   while (failIntQty - okIntQty > 1)
      {
      tryIntQty = (okIntQty + failIntQty) / 2;

      success   = tempCommit (tryIntQty);

      if (success)
         okIntQty   = tryIntQty;
      else
         failIntQty = tryIntQty;
      }

   return okIntQty;
   }

#endif

//------------------------------------------------------------------------------

bool WitHeurAtor::commit (double qty)
   {
   bool success;
d762 1
a762 1
   tempModeRepos_->restore ();
d1317 1
a1317 1
      if (not tempMode_)
d1367 1
a1367 1
            if (not tempMode_)
d1399 1
a1399 1
      if (tempMode_)
d1567 1
a1567 1
   if (not tempMode_)
d1617 1
a1617 1
         if (tempMode_)
d1734 1
a1734 1
         if (tempMode_)
d1770 1
a1770 1
   if (tempMode_)
@


1.147
log
@Low-Pri Prop-Rt.
@
text
@a23 1
#include <PoMgr.h>
a66 1
      myPoMgr_          (NULL),
d439 1
a439 6
      {
      if (myGlobalComp ()->newPropRt ())
         myPrMgr_ = mySelector ()->myPrMgr ();
      else
         myPoMgr_ = mySelector ()->myPoMgr ();
      }
d988 2
a989 7
      if (myGlobalComp ()->newPropRt ())
         {
         if (myPrMgr ()->selIsSplit (thePart->myRtSite (), expPer))
            return explodePartPRSS (thePart, expPer, expVol, fillPer);
         else
            return explodePartPR   (thePart, expPer, expVol, fillPer);
         }
d991 1
a991 6
         {
         if (myPoMgr ()->selIsSplit (thePart->myRtSite (), expPer))
            return explodePartPRSS (thePart, expPer, expVol, fillPer);
         else
            return explodePartPR   (thePart, expPer, expVol, fillPer);
         }
d1018 6
a1023 14
   if (myGlobalComp ()->newPropRt ())
      myPrMgr ()->defineSplit (
         thePart->myRtSite (),
         expPer,
         expVol,
         theExpPairs,
         unbddVol);
   else
      myPoMgr ()->defineSplit (
         thePart->myRtSite (),
         expPer,
         expVol,
         theExpPairs,
         unbddVol);
d1029 1
a1029 3
      if (myGlobalComp ()->newPropRt ())
         {
         myPrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (true);
d1031 1
a1031 1
         expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);
d1033 1
a1033 10
         myPrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
         }
      else
         {
         myPoMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (true);

         expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);

         myPoMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
         }
d1135 2
a1136 15
   if (myGlobalComp ()->newPropRt ())
      {
      if (selSplit_)
         myPrMgr ()->recordFlowSS (thePart->myRtSite (), expPer, expVol);

      myPrMgr ()->definePropExp (
         thePart->myRtSite (),
         expPer,
         expVol,
         theExpPairs);
      }
   else
      {
      if (selSplit_)
         myPoMgr ()->recordFlowSS (thePart->myRtSite (), expPer, expVol);
d1138 2
a1139 6
      myPoMgr ()->definePropExp (
         thePart->myRtSite (),
         expPer,
         expVol,
         theExpPairs);
      }
d1452 3
a1454 11
      if (myGlobalComp ()->newPropRt ())
         {
         if (myPrMgr ()->selIsSplit (theBomEnt->myRtSite (), execPer))
            explodeBomEntryPRSS (
               theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
         else
            explodeBomEntryPR (
               theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);

         return;
         }
d1456 2
a1457 7
         {
         if (myPoMgr ()->selIsSplit (theBomEnt->myRtSite (), execPer))
            explodeBomEntryPRSS (
               theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
         else
            explodeBomEntryPR (
               theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
d1459 1
a1459 2
         return;
         }
d1675 7
a1681 21
   if (myGlobalComp ()->newPropRt ())
      {
      myPrMgr ()->
         defineSplit (
            theBomEnt->myRtSite (),
            execPer,
            deltaExecVol,
            theExpPairs,
            unbddVol);

      myPrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (true);
      }
   else
      {
      myPoMgr ()->
         defineSplit (
            theBomEnt->myRtSite (),
            execPer,
            deltaExecVol,
            theExpPairs,
            unbddVol);
d1683 1
a1683 2
      myPoMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (true);
      }
d1693 1
a1693 4
   if (myGlobalComp ()->newPropRt ())
      myPrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
   else
      myPoMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
d1714 3
a1716 5
   if (myGlobalComp ()->newPropRt ())
      {
      if (selSplit_)
         myPrMgr ()->
            recordFlowSS (theBomEnt->myRtSite (), execPer, deltaExecVol);
d1718 5
a1722 18
      myPrMgr ()->definePropExp (
         theBomEnt->myRtSite (),
         execPer,
         deltaExecVol,
         theExpPairs);
      }
   else
      {
      if (selSplit_)
         myPoMgr ()->
            recordFlowSS (theBomEnt->myRtSite (), execPer, deltaExecVol);

      myPoMgr ()->definePropExp (
         theBomEnt->myRtSite (),
         execPer,
         deltaExecVol,
         theExpPairs);
      }
@


1.146
log
@Low-Pri Prop-Rt.
@
text
@d1056 1
a1056 3
         myPrMgr ()->
            mySelMgrFor (prodRtCase)->
               setBoundedSplit (true);
d1060 1
a1060 3
         myPrMgr ()->
            mySelMgrFor (prodRtCase)->
               setBoundedSplit (false);
d1064 1
a1064 3
         myPoMgr ()->
            mySelMgrFor (prodRtCase)->
               setBoundedSplit (true);
d1068 1
a1068 3
         myPoMgr ()->
            mySelMgrFor (prodRtCase)->
               setBoundedSplit (false);
d1107 1
a1107 3
   myMrMgr ()->
      mySelMgrFor (prodRtCase)->
         setBoundedSplit (true);
d1119 1
a1119 3
   myMrMgr ()->
      mySelMgrFor (prodRtCase)->
         setBoundedSplit (false);
d1579 1
a1579 3
   myMrMgr ()->
      mySelMgrFor (consRtCase)->
         setBoundedSplit (true);
d1588 1
a1588 3
   myMrMgr ()->
      mySelMgrFor (consRtCase)->
         setBoundedSplit (false);
d1752 1
a1752 3
      myPrMgr ()->
         mySelMgrFor (consRtCase)->
            setBoundedSplit (true);
d1764 1
a1764 3
      myPoMgr ()->
         mySelMgrFor (consRtCase)->
            setBoundedSplit (true);
d1776 1
a1776 3
      myPrMgr ()->
         mySelMgrFor (consRtCase)->
            setBoundedSplit (false);
d1778 1
a1778 3
      myPoMgr ()->
         mySelMgrFor (consRtCase)->
            setBoundedSplit (false);
@


1.145
log
@Low-Pri Prop-Rt.
@
text
@d1099 1
a1099 1
   bool              lastUnbdd;
d1102 1
d1113 1
a1113 1
      lastUnbdd);
d1121 1
a1121 5
      if (theSplitPairs.isEmpty ())
         if (lastUnbdd)
            myMrMgr ()->
               mySelMgrFor (prodRtCase)->
                  setBoundedSplit (false);
d1123 1
a1123 2
      expOK =
         explodeBopEntSS (theRtCand->myBopEnt (), expPer, splitExpVol, fillPer);
d1133 8
d1577 1
a1577 1
   bool              lastUnbdd;
d1580 1
d1589 1
a1589 1
      lastUnbdd);
d1597 1
a1597 5
      if (theSplitPairs.isEmpty ())
         if (lastUnbdd)
            myMrMgr ()->
               mySelMgrFor (consRtCase)->
                  setBoundedSplit (false);
d1599 1
a1599 6
      explodeConsEntry (
         theRtCand->myConsEnt (),
         execPer, 
         splitExecVol,
         fillPer, 
         theBopEnt);
d1605 10
@


1.144
log
@Low-Pri Prop-Rt.
@
text
@d956 3
a958 1
      expOK = explodePartSS (thePart, theFixedPer->myPer (), expVol, fillPer);
d1259 1
a1259 1
   bool           lastUnbdd;
d1262 1
d1269 1
a1269 1
      defineSplit (theBopEnt, expPer, expVol, theSplitPairs, lastUnbdd);
d1275 1
a1275 3
      if (theSplitPairs.isEmpty ())
         if (lastUnbdd)
            myMeMgr ()->setBoundedSplit (false);
d1277 1
a1277 1
      expOK = explode (theBopEnt, theFixedPer->myPer (), splitExpVol, fillPer);
d1285 8
@


1.143
log
@Low-Pri Prop-Rt.
@
text
@d931 1
d933 1
a933 2
   bool           lastUnbdd;
   bool           expOK;
d936 1
d949 2
a950 2
   myBaMgr ()->defineSplit (
      thePart, fillPer, netReqVol, theSplitPairs, lastUnbdd);
a955 4
      if (theSplitPairs.isEmpty ())
         if (lastUnbdd)
            myBaMgr ()->setBoundedSplit (false);

d964 8
d1054 3
a1056 1
         myPrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (true);
d1060 3
a1062 1
         myPrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
d1066 3
a1068 1
         myPoMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (true);
d1072 3
a1074 1
         myPoMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
d1112 3
a1114 1
   myMrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (true);
d1120 3
a1122 1
            myMrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
d1131 3
a1133 1
   myMrMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
d1265 2
a1266 2
   myMeMgr ()->defineSplit (
      theBopEnt, expPer, expVol, theSplitPairs, lastUnbdd);
d1577 3
a1579 1
   myMrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (true);
d1585 3
a1587 1
            myMrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
d1597 3
a1599 1
   myMrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
d1753 3
a1755 1
      myPrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (true);
d1767 3
a1769 1
      myPoMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (true);
d1781 3
a1783 1
      myPrMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
d1785 3
a1787 1
      myPoMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
@


1.142
log
@Low-Pri Prop-Rt.
@
text
@d25 1
d69 1
d441 6
a446 1
      myPoMgr_ = mySelector ()->myPoMgr ();
d988 7
a994 2
      if (myPoMgr ()->selIsSplit (thePart->myRtSite (), expPer))
         return explodePartPRSS (thePart, expPer, expVol, fillPer);
d996 6
a1001 1
         return explodePartPR   (thePart, expPer, expVol, fillPer);
d1028 14
a1041 6
   myPoMgr ()->defineSplit (
      thePart->myRtSite (),
      expPer,
      expVol,
      theExpPairs,
      unbddVol);
d1047 3
a1049 1
      myPoMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (true);
d1051 1
a1051 1
      expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);
d1053 10
a1062 1
      myPoMgr ()->mySelMgrFor (prodRtCase)->setBoundedSplit (false);
d1158 15
a1172 2
   if (selSplit_)
      myPoMgr ()->recordFlowSS (thePart->myRtSite (), expPer, expVol);
d1174 6
a1179 5
   myPoMgr ()->definePropExp (
      thePart->myRtSite (),
      expPer,
      expVol,
      theExpPairs);
d1485 11
a1495 3
      if (myPoMgr ()->selIsSplit (theBomEnt->myRtSite (), execPer))
         explodeBomEntryPRSS (
            theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
d1497 7
a1503 2
         explodeBomEntryPR (
            theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
d1505 2
a1506 1
      return;
d1718 9
a1726 7
   myPoMgr ()->
      defineSplit (
         theBomEnt->myRtSite (),
         execPer,
         deltaExecVol,
         theExpPairs,
         unbddVol);
d1728 14
a1741 1
   myPoMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (true);
d1751 4
a1754 1
   myPoMgr ()->mySelMgrFor (consRtCase)->setBoundedSplit (false);
d1775 17
a1791 2
   if (selSplit_)
      myPoMgr ()->recordFlowSS (theBomEnt->myRtSite (), execPer, deltaExecVol);
d1793 6
a1798 5
   myPoMgr ()->definePropExp (
      theBomEnt->myRtSite (),
      execPer,
      deltaExecVol,
      theExpPairs);
@


1.141
log
@Low-Pri Prop-Rt.
@
text
@d1022 1
a1022 1
      myPoMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (true);
d1026 1
a1026 1
      myPoMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (false);
d1063 1
a1063 1
   myMrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (true);
d1069 1
a1069 1
            myMrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (false);
d1078 1
a1078 1
   myMrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (false);
d1494 1
a1494 1
   myMrMgr ()->mySelMgr (consRtCase)->setBoundedSplit (true);
d1500 1
a1500 1
            myMrMgr ()->mySelMgr (consRtCase)->setBoundedSplit (false);
d1510 1
a1510 1
   myMrMgr ()->mySelMgr (consRtCase)->setBoundedSplit (false);
d1662 1
a1662 1
   myPoMgr ()->mySelMgr (consRtCase)->setBoundedSplit (true);
d1672 1
a1672 1
   myPoMgr ()->mySelMgr (consRtCase)->setBoundedSplit (false);
@


1.140
log
@Low-Pri Prop-Rt.
@
text
@d24 1
a24 1
#include <PrMgr.h>
d67 1
a67 1
      myPrMgr_          (NULL),
d439 1
a439 1
      myPrMgr_ = mySelector ()->myPrMgr ();
d981 1
a981 1
      if (myPrMgr ()->selIsSplit (thePart->myRtSite (), expPer))
d1011 1
a1011 1
   myPrMgr ()->defineSplit (
d1022 1
a1022 1
      myPrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (true);
d1026 1
a1026 1
      myPrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (false);
d1123 1
a1123 1
      myPrMgr ()->recordFlowSS (thePart->myRtSite (), expPer, expVol);
d1125 1
a1125 1
   myPrMgr ()->definePropExp (
d1435 1
a1435 1
      if (myPrMgr ()->selIsSplit (theBomEnt->myRtSite (), execPer))
d1654 1
a1654 1
   myPrMgr ()->
d1662 1
a1662 1
   myPrMgr ()->mySelMgr (consRtCase)->setBoundedSplit (true);
d1672 1
a1672 1
   myPrMgr ()->mySelMgr (consRtCase)->setBoundedSplit (false);
d1694 1
a1694 1
      myPrMgr ()->recordFlowSS (theBomEnt->myRtSite (), execPer, deltaExecVol);
d1696 1
a1696 1
   myPrMgr ()->definePropExp (
@


1.139
log
@Added some debugging code.
@
text
@a22 1
#include <RtSitePtr.h>
d981 1
a981 1
      if (myPrMgr ()->selIsSplit (thePart, expPer))
d988 1
a988 1
      if (myMrMgr ()->selIsSplit (thePart, expPer))
d1011 6
a1016 1
   myPrMgr ()->defineSplit (thePart, expPer, expVol, theExpPairs, unbddVol);
d1056 6
a1061 1
   myMrMgr ()->defineSplit (thePart, expPer, expVol, theSplitPairs, lastUnbdd);
d1123 1
a1123 1
      myPrMgr ()->recordFlowSS (thePart, expPer, expVol);
d1125 5
a1129 1
   myPrMgr ()->definePropExp (thePart, expPer, expVol, theExpPairs);
d1164 4
a1167 1
      myMrMgr ()->recordFlowSS (theBopEnt->myPart (), expPer, expVol);
d1435 1
a1435 1
      if (myPrMgr ()->selIsSplit (theBomEnt, execPer))
d1446 1
a1446 1
      if (myMrMgr ()->selIsSplit (theBomEnt, execPer))
d1460 1
a1460 1
         myMrMgr ()->selRtCand (theBomEnt, execPer)->myConsEnt ():
d1488 5
a1492 1
      theBomEnt, execPer, deltaExecVol, theSplitPairs, lastUnbdd);
d1655 6
a1660 1
      defineSplit (theBomEnt, execPer, deltaExecVol, theExpPairs, unbddVol);
d1694 1
a1694 1
      myPrMgr ()->recordFlowSS (theBomEnt, execPer, deltaExecVol);
d1696 5
a1700 1
   myPrMgr ()->definePropExp (theBomEnt, execPer, deltaExecVol, theExpPairs);
d1755 3
a1757 1
            theConsEnt->myBomEnt (), execPer, netExecQty);
d1791 1
a1791 1
         myMrMgr ()->selRtCand (thePart, expPer)->myBopEnt ():
@


1.138
log
@Corrected a numberical problem in netting.
@
text
@a650 2
#if 0

a657 2

#endif
@


1.137
log
@Minor change to BomEntry netting.
@
text
@d650 12
@


1.136
log
@Fixed an integer overflow problem in the heuristic's binary search.
@
text
@d87 1
a87 1
      netAllowed_       (myProblem (), false),
d119 1
a119 1
         netAllowed_ (theSub->myBomEnt ()) = true;
d1496 1
a1496 4
   if (not netAllowed_ (theBomEnt))
      return;

   if (not theBomEnt->hasSubsInEffect ()[execPer])
@


1.135
log
@Double Precision.
@
text
@d704 33
d763 2
@


1.134
log
@Double Precision.
@
text
@d478 1
a478 1
      shipVol_ (theDemand).setToScalar (0.0);
d481 1
a481 1
      execVol_ (theOpn).setToScalar (0.0);
d484 1
a484 1
      subVol_ (theSub).setToScalar (0.0);
@


1.133
log
@Removed the "pip" attribute.
@
text
@d49 7
a55 7
         WitProblem *                                     theProblem,
         WitPegger *                                      thePegger,
         bool                                             forOpt,
         WitRefMap <WitDemand,    WitFlexVec <double> > & shipVolArg,
         WitRefMap <WitOperation, WitFlexVec <double> > & execVolArg,
         WitRefMap <WitSubEntry,  WitFlexVec <double> > & subVolArg,
         WitRef    <WitList <WitPartPer> >              & criticalListArg):
@


1.132
log
@Continued implementation of PIP.
@
text
@d154 1
a154 1
   if (myGlobalComp ()->pipSeqFromHeur () or myGlobalComp ()->pip ())
d245 1
a245 1
   if (myGlobalComp ()->pipSeqFromHeur () or myGlobalComp ()->pip ())
@


1.131
log
@Continued implementation of PIP.
@
text
@d154 1
a154 1
   if (myGlobalComp ()->heurPipSeq () or myGlobalComp ()->pip ())
d245 1
a245 1
   if (myGlobalComp ()->heurPipSeq () or myGlobalComp ()->pip ())
@


1.130
log
@Continued implementation of PIP.
@
text
@d32 1
a32 1
#include <PipMgr.h>
d155 1
a155 1
      myProblem ()->myPipMgr ()->clearShipSeq ();
d248 1
a248 1
            myProblem ()->myPipMgr ()->appendToShipSeq (
@


1.129
log
@Continued implementation of PIP.
@
text
@d154 1
a154 1
   if (myGlobalComp ()->pip ())
d245 1
a245 1
   if (myGlobalComp ()->pip ())
d248 1
a248 1
            myProblem ()->myPipMgr ()->recIncShipVol (
@


1.128
log
@Continued implementation of PIP.
@
text
@d32 1
a32 1
#include <PipInt.h>
d155 1
a155 1
      myProblem ()->myPipInt ()->clearShipSeq ();
d248 1
a248 1
            myProblem ()->myPipInt ()->recIncShipVol (
@


1.127
log
@Continued implementation of PIP.
@
text
@d155 1
a155 1
      myProblem ()->myPipInt ()->clearTargs ();
@


1.126
log
@Removed a bad function overload.
@
text
@d55 1
a55 1
         WitRef    <WitList <WitDatedPart> >            & criticalListArg):
@


1.125
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d558 1
a558 1
   theMat = thePart->myMat ();
d802 1
a802 1
   theMat      = thePart->myMat ();
d1698 1
a1698 1
   theSub = theConsEnt->mySub ();
@


1.124
log
@Continued implementation of post-implosion pegging.
@
text
@d154 1
a154 1
   if (myGlobalComp ()->perfPIPegging ())
d245 1
a245 1
   if (myGlobalComp ()->perfPIPegging ())
@


1.123
log
@Continued implementation of post-implosion pegging.
@
text
@d769 3
a771 3
      for ( fillPer =  myReqSched_->firstPer (fillPart); 
            fillPer <= myReqSched_->lastPer  (fillPart);
            fillPer ++)
@


1.122
log
@Continued implementation of post-implosion pegging.
@
text
@a40 1
#include <RefMapI.h>
@


1.121
log
@Continued implementation of post-implosion pegging.
@
text
@a40 1
#include <ScheduleI.h>
d43 1
@


1.120
log
@Contined implementation of post-implosion pegging.
@
text
@d32 1
a32 1
#include <PIPegInt.h>
d156 1
a156 1
      myProblem ()->myPIPegInt ()->clearTargs ();
d249 1
a249 1
            myProblem ()->myPIPegInt ()->recIncShipVol (
@


1.119
log
@Continued implementation of post-implosion pegging.
@
text
@d155 3
d248 5
a252 1
         myProblem ()->myPIPegInt ()->recIncShipVol (theDemand, thePer, incVol);
@


1.118
log
@Continued implementation of Post-Implosion Pegging.
@
text
@a42 1
#include <FlexVecI.h>
@


1.117
log
@An attempt to fix another link error from the Windows compiler.
@
text
@d32 1
d37 1
d243 4
@


1.116
log
@Made changes to eliminate some of the warning messages.
@
text
@d265 1
a265 1
      reversedParts.revCopyOf (myCompMgr ()->allParts ());
@


1.115
log
@Attempt to fix syntax errors from GCC compiler.
@
text
@d701 1
a701 1
   failIntQty = ceil (desQty - SEARCH_TOL);
@


1.114
log
@Continued implementation of proportionate routing.
@
text
@d23 1
a23 1
#include <RtSiteComp.h>
@


1.113
log
@Continued implementation of proportionate routing.
@
text
@d1365 6
a1370 1
      explodeBomEntryPR (theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);
d1571 35
d1616 3
@


1.112
log
@Continued implementation of proportionate routing.
@
text
@d951 1
a951 1
   WitRtCandDblStack theSplitPairs (myProblem ());
d954 2
a955 1
   double            splitVol;
d958 1
a958 1
   myPrMgr ()->defineSplit (thePart, expPer, expVol, theSplitPairs, unbddVol);
d960 1
a960 1
   while (theSplitPairs.pop (theRtCand, splitVol))
d962 7
a968 1
      expOK = explodeRtCandPRSS (theRtCand, expPer, splitVol, fillPer);
a977 35
   }

//------------------------------------------------------------------------------

bool WitHeurAtor::explodeRtCandPRSS (
      WitRtCand * theRtCand,
      WitPeriod   expPer,
      double      splitVol,
      WitPeriod   fillPer)
   {
   bool              expOK;
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       expRtCand;
   double            propExpVol;
   WitBopEntry *     theBopEnt;

   expOK = true;

   myPrMgr ()->defineSplitPropExp (theRtCand, expPer, splitVol, theExpPairs);

   myPrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (true);

   while (theExpPairs.pop (expRtCand, propExpVol))
      {
      theBopEnt = expRtCand->myBopEnt ();

      expOK     = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);

      if (not expOK)
         break;
      }

   myPrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (false);

   return expOK;
@


1.111
log
@Continued implementation of proportionate routing.
@
text
@d951 1
a951 1
   WitRtCandDblStack theExpPairs (myProblem ());
d954 30
a985 2
   WitPeriod         execPer;
   bool              expOK;
d989 3
a991 1
   myPrMgr ()->defineSplit (thePart, expPer, expVol, theExpPairs, unbddVol);
d993 1
a993 1
   while (theExpPairs.pop (theRtCand, propExpVol))
d995 1
a995 3
      theBopEnt = theRtCand->myBopEnt ();

      execPer   = execPerFor (theBopEnt, expPer);
d997 1
a997 5
      myPrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (true);

      expOK = explodeBopEntSS (theBopEnt, expPer, propExpVol, fillPer);

      myPrMgr ()->mySelMgr (prodRtCase)->setBoundedSplit (false);
d1000 1
a1000 1
         return false;
d1003 1
a1003 2
   if (unbddVol <= NET_TOL)
      return true;
d1005 1
a1005 1
   return explodePartPR (thePart, expPer, unbddVol, fillPer);
@


1.110
log
@Continued implementation of proportionate routing.
@
text
@d23 1
d924 1
a924 2
      if (tempMode_)
         myBaMgr ()->recExpMatSS (thePart, fillPer, expVol);
d928 1
a928 1
      if (myPrMgr ()->selIsSplit (thePart->myRtSite (), expPer))
d935 1
a935 1
      if (myMrMgr ()->selIsSplit (thePart->myRtSite (), expPer))
d961 1
a961 2
   myPrMgr ()->
      defineSplit (thePart->myRtSite (), expPer, expVol, theExpPairs, unbddVol);
d1003 1
a1003 2
   myMrMgr ()->defineSplit (
      thePart->myRtSite (), expPer, expVol, theSplitPairs, lastUnbdd);
d1065 1
a1065 2
      if (tempMode_)
         myPrMgr ()->recordFlowSS (thePart->myRtSite (), expPer, expVol);
d1067 1
a1067 2
   myPrMgr ()->
      definePropExp (thePart->myRtSite (), expPer, expVol, theExpPairs);
d1097 1
a1097 2
   WitRtSite * theRtSite;
   WitPeriod   execPer;
d1102 1
a1102 6
      if (tempMode_)
         {
         theRtSite = theBopEnt->myPart ()->myRtSite ();

         myMrMgr ()->recordFlowSS (theRtSite, expPer, expVol);
         }
d1170 1
a1170 2
         if (tempMode_)
            myMeMgr ()->recBopEntExecPerSS (theBopEnt, execPer, qty);
d1173 1
a1173 1
      mySglSrcMgr ()->recExp (theBopEnt->myRtCand ());
d1376 1
a1376 1
      if (myMrMgr ()->selIsSplit (theBomEnt->myRtSite (), execPer))
d1390 1
a1390 1
         myMrMgr ()->selRtCand (theBomEnt->myRtSite (), execPer)->myConsEnt ():
d1418 1
a1418 1
      theBomEnt->myRtSite (), execPer, deltaExecVol, theSplitPairs, lastUnbdd);
d1582 1
a1582 5
   myPrMgr ()->definePropExp (
      theBomEnt->myRtSite (),
      execPer,
      deltaExecVol,
      theExpPairs);
d1602 3
a1604 4
   WitPeriod   consPer;
   double      consumedQty;
   WitPart *   consPart;
   WitRtSite * theRtSite;
d1609 1
a1609 1
      mySglSrcMgr ()->recExp (theConsEnt->myRtCand ());
d1636 2
a1637 6
         if (tempMode_)
            {
            theRtSite = theConsEnt->myBomEnt ()->myRtSite ();

            myMrMgr ()->recordFlowSS (theRtSite, execPer, netExecQty);
            }
d1671 1
a1671 1
         myMrMgr ()->selRtCand (thePart->myRtSite (), expPer)->myBopEnt ():
@


1.109
log
@Continued implementation of proportionate routing.
@
text
@d922 2
a923 2
   if (tempMode_)
      if (buildAhead_)
d926 8
d945 43
d1053 42
d1101 2
a1102 1
   WitPeriod execPer;
d1106 7
a1112 3
   if (tempMode_)
      if (multiRoute_)
         myMrMgr ()->recordFlowSS (theBopEnt->myRtCand (), expPer, expVol);
a1164 33
bool WitHeurAtor::explodePartPR (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer)
   {
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            propExpVol;
   WitBopEntry *     theBopEnt;
   WitPeriod         execPer;
   bool              expOK;

   myPrMgr ()->
      definePropExp (thePart->myRtSite (), expPer, expVol, theExpPairs);

   while (theExpPairs.pop (theRtCand, propExpVol))
      {
      theBopEnt = theRtCand->myBopEnt ();

      execPer   = execPerFor (theBopEnt, expPer);

      expOK     = explode (theBopEnt, execPer, propExpVol, fillPer);

      if (! expOK)
         return false;
      }

   return true;
   }

//------------------------------------------------------------------------------

d1179 2
a1180 2
      if (tempMode_)
         if (multiExec_)
d1617 4
a1620 3
   WitPeriod consPer;
   double    consumedQty;
   WitPart * consPart;
d1650 8
a1657 7
   if (tempMode_)
      if (selSplit_)
         if (multiRoute_)
            myMrMgr ()->recordFlowSS (
               theConsEnt->myRtCand (),
               execPer,
               netExecQty);
@


1.108
log
@Continued implementation of proportionate routing.
@
text
@d1073 6
a1078 5
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   double        normShare;
   double        propExpVol;
   bool          expOK;
d1080 2
a1081 1
   witAssert (thePart->propRouting ());
d1083 3
a1085 4
   forEachEl (theBopEnt, thePart->producingBopEntries ())
      if (myPrMgr ()->active (theBopEnt, expPer))
         {
         execPer    = execPerFor (theBopEnt, expPer);
d1087 1
a1087 1
         normShare  = myPrMgr ()->normExpShare (theBopEnt, expPer);
d1089 1
a1089 1
         propExpVol = expVol * normShare;
d1091 3
a1093 5
         expOK      = explode (theBopEnt, execPer, propExpVol, fillPer);

         if (! expOK)
            return false;
         }
d1524 3
a1526 3
   WitSubEntry * theSub;

   witAssert (theBomEnt->propRouting ());
d1528 2
a1529 2
   explodeConsEntryPR (
      theBomEnt,
d1532 3
a1534 30
      fillPer,
      theBopEnt);

   forEachEl (theSub, theBomEnt->mySubEntries ())
      explodeConsEntryPR (
         theSub,
         execPer,
         deltaExecVol,
         fillPer,
         theBopEnt);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::explodeConsEntryPR (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         deltaExecVol,
      WitPeriod      fillPer,
      WitBopEntry *  theBopEnt)
   {
   double normShare;
   double propDeltaVol;

   if (myPrMgr ()->active (theConsEnt, execPer))
      {
      normShare    = myPrMgr ()->normExpShare (theConsEnt, execPer);

      propDeltaVol = deltaExecVol * normShare;

d1536 1
a1536 1
         theConsEnt,
a1540 1
      }
@


1.107
log
@Continued implementation of proportionate routing.
Fixed a bug in selection splitting for selective stock reallocation.
@
text
@a1275 2
   bddSsrSplit = false;

d1291 1
a1291 1
         mySelector ()->rollReq (theMat, thePer, rollPer, rollVol, bddSsrSplit);
@


1.106
log
@Continued implementation of proportionate routing.
@
text
@d784 1
d788 1
a788 1
   netReqVol = theReqVol;
d790 3
a792 1
   theMat = thePart->myMat ();
d795 1
a795 1
       myAvailSched_->netWithIncAvail (thePart, fillPer, netReqVol);
d798 1
a798 1
                      netAndRollReq   (theMat,  fillPer, netReqVol);
d800 1
a800 1
       myAvailSched_->netMatWoSR      (theMat,  fillPer, netReqVol);
d804 2
a805 1
         mySelector ()->recFillByCons (thePart, fillPer);
d1268 2
a1269 1
      double &      netReqVol)
d1276 9
a1284 1
   rollPer = myAvailSched_->netAndRoll (theMat, thePer, netReqVol, rollVol);
d1293 1
a1293 1
         mySelector ()->rollReq (theMat, thePer, rollPer, rollVol);
@


1.105
log
@Continued implementation of proportionate routing.
@
text
@a943 1
   WitBopEntry *     theBopEnt;
d952 1
a952 1
   myMrMgr ()->setProdBoundedSplit (true);
d958 1
a958 1
            myMrMgr ()->setProdBoundedSplit (false);
d960 2
a961 3
      theBopEnt = theRtCand->myBillEnt ()->myBopEnt ();

      expOK     = explodeBopEntSS (theBopEnt, expPer, splitExpVol, fillPer);
d967 1
a967 1
   myMrMgr ()->setProdBoundedSplit (false);
d1010 1
a1010 1
         myMrMgr ()->recExpPartSS (theBopEnt->myPart (), expPer, expVol);
d1326 1
a1326 1
         myMrMgr ()->selConsEnt (theBomEnt, execPer):
a1349 1
   WitConsEntry *    theConsEnt;
d1356 1
a1356 1
   myMrMgr ()->setConsBoundedSplit (true);
d1362 1
a1362 3
            myMrMgr ()->setConsBoundedSplit (false);

      theConsEnt = theRtCand->myBillEnt ()->myConsEnt ();
d1365 1
a1365 1
         theConsEnt,
d1372 1
a1372 1
   myMrMgr ()->setConsBoundedSplit (false);
d1605 2
a1606 2
            myMrMgr ()->recExpBomEntSS (
               theConsEnt->myBomEnt (),
d1642 1
a1642 1
         myMrMgr ()->selBopEnt (thePart, expPer):
@


1.104
log
@Continued implementation of proportionate routing.
@
text
@a1005 1
   bool      expOK;
a1006 1
   double    splitExpVol;
d1014 24
a1037 3
   if (multiExec_ and myMeMgr ()->selIsSplit (theBopEnt, expPer))
      {
      myMeMgr ()->startSplitExp (theBopEnt, expPer, expVol);
d1039 1
a1039 1
      expOK = true;
d1041 2
a1042 3
      while (myMeMgr ()->findNextSplit (execPer, splitExpVol))
         {
         expOK = explode (theBopEnt, execPer, splitExpVol, fillPer);
d1044 1
a1044 3
         if (not expOK)
            break;
         }
d1046 1
a1046 3
      myMeMgr ()->finishSplitExp ();
      }
   else
d1048 3
a1050 1
      execPer = execPerFor (theBopEnt, expPer);
d1052 4
a1055 1
      expOK   = explode (theBopEnt, execPer, expVol, fillPer);
d1057 2
@


1.103
log
@Continued implementation of proportionate routing.
@
text
@d41 1
d866 5
a870 3
   bool      expOK;
   WitPeriod expPer;
   double    expVol;
d881 4
a884 1
   myBaMgr ()->startSplitExp (thePart, fillPer, netReqVol);
d886 1
a886 1
   expOK = true;
d888 1
a888 1
   while (myBaMgr ()->findNextSplit (expPer, expVol))
d890 5
a894 1
      expOK = explodePartSS (thePart, expPer, expVol, fillPer);
d900 1
a900 1
   myBaMgr ()->finishSplitExp ();
@


1.102
log
@Continued implementation of proportionate routing.
@
text
@d84 2
d97 1
d115 4
d901 1
a901 1
      WitPeriod fillPer) 
a902 1
   bool          expOK;
a903 1
   double        splitExpVol;
d912 25
a936 3
   if (multiRoute_ and myMrMgr ()->selIsSplit (thePart, expPer))
      {
      myMrMgr ()->startSplitExp (thePart, expPer, expVol);
d938 1
a938 1
      expOK = true;
d940 2
a941 3
      while (myMrMgr ()->findNextSplit (theBopEnt, splitExpVol))
         {
         expOK = explodeBopEntSS (theBopEnt, expPer, splitExpVol, fillPer);
d943 1
a943 3
         if (not expOK)
            break;
         }
d945 1
a945 3
      myMrMgr ()->finishProdSplitExp ();
      }
   else
d947 5
a951 1
      theBopEnt = expBopEntry (thePart, expPer);
d953 4
a956 1
      expOK     = explodeBopEntSS (theBopEnt, expPer, expVol, fillPer);
d959 2
d1275 7
d1283 1
a1283 1
      if (myMrMgr ()->selIsSplit (theBomEnt, execPer))
d1285 1
a1285 1
         explodeBomEntrySS (
d1290 1
a1290 1
            theBopEnt);
a1294 7
   if (theBomEnt->propRouting ())
      {
      explodeBomEntryPR (theBomEnt, execPer, deltaExecVol, fillPer, theBopEnt);

      return;
      }

d1303 1
a1303 1
      deltaExecVol, 
d1310 1
a1310 1
void WitHeurAtor::explodeBomEntrySS (
d1317 12
a1328 2
   WitConsEntry * theConsEnt;
   double         splitExecVol;
d1330 5
a1334 2
   witAssert (multiRoute_);
   witAssert (selSplit_);
d1336 1
a1336 1
   myMrMgr ()->startSplitExp (theBomEnt, execPer, deltaExecVol);
a1337 1
   while (myMrMgr ()->findNextSplit (theConsEnt, splitExecVol))
d1344 1
d1346 1
a1346 1
   myMrMgr ()->finishConsSplitExp ();
d1359 3
@


1.101
log
@Continued implementation of proportionate routing.
@
text
@a74 1
      propRouting_      (false),
d407 1
a407 1
   mySelector_  = new WitSelector (this);
d409 6
a414 7
   multiRoute_  = mySelector ()->multiRoute  ();
   propRouting_ = mySelector ()->propRouting ();
   buildAhead_  = mySelector ()->buildAhead  ();
   multiExec_   = mySelector ()->multiExec   ();
   penExec_     = mySelector ()->penExec     ();
   selSplit_    = mySelector ()->selSplit    ();
   sglSrc_      = mySelector ()->sglSrc      ();
d419 1
a419 1
   if (propRouting_)
d842 2
a843 3
   if (propRouting_)
      if (myPrMgr ()->propRouting (thePart, expPer))
         return explodePartPR (thePart, expPer, netReqVol, fillPer);
d1015 1
a1015 1
   witAssert (myPrMgr ()->propRouting (thePart, expPer));
d1257 3
a1259 9
   if (propRouting_)
      if (myPrMgr ()->propRouting (theBomEnt, execPer))
         {
         explodeBomEntryPR (
            theBomEnt,
            execPer,
            deltaExecVol,
            fillPer,
            theBopEnt);
d1261 2
a1262 2
         return;
         }
d1443 1
a1443 1
   witAssert (myPrMgr ()->propRouting (theBomEnt, execPer));
@


1.100
log
@Continued implementation of proportionate routing.
@
text
@a23 1
#include <MrSecMgr.h>
a24 1
#include <PrSecMgr.h>
d65 2
a66 4
      myPmrMgr_         (NULL),
      myCmrMgr_         (NULL),
      myPprMgr_         (NULL),
      myCprMgr_         (NULL),
d419 1
a419 4
      {
      myPmrMgr_ = mySelector ()->myMrMgr ()->myPmrMgr ();
      myCmrMgr_ = mySelector ()->myMrMgr ()->myCmrMgr ();
      }
d422 1
a422 4
      {
      myPprMgr_ = mySelector ()->myPrMgr ()->myPprMgr ();
      myCprMgr_ = mySelector ()->myPrMgr ()->myCprMgr ();
      }
d845 1
a845 1
      if (myPprMgr ()->propRouting (thePart, expPer))
d910 1
a910 1
   if (multiRoute_ and myPmrMgr ()->selIsSplit (thePart, expPer))
d912 1
a912 1
      myPmrMgr ()->startSplitExp (thePart, expPer, expVol);
d916 1
a916 1
      while (myPmrMgr ()->findNextSplit (theBopEnt, splitExpVol))
d924 1
a924 1
      myPmrMgr ()->finishSplitExp ();
d976 1
a976 1
         myPmrMgr ()->recExpPartSS (theBopEnt->myPart (), expPer, expVol);
d1018 1
a1018 1
   witAssert (myPprMgr ()->propRouting (thePart, expPer));
d1021 1
a1021 1
      if (myPprMgr ()->active (theBopEnt, expPer))
d1025 1
a1025 1
         normShare  = myPprMgr ()->normExpShare (theBopEnt, expPer);
d1248 1
a1248 1
      if (myCmrMgr ()->selIsSplit (theBomEnt, execPer))
d1261 1
a1261 1
      if (myCprMgr ()->propRouting (theBomEnt, execPer))
d1275 1
a1275 1
         myCmrMgr ()->selConsEnt (theBomEnt, execPer):
d1301 1
a1301 1
   myCmrMgr ()->startSplitExp (theBomEnt, execPer, deltaExecVol);
d1303 1
a1303 1
   while (myCmrMgr ()->findNextSplit (theConsEnt, splitExecVol))
d1311 1
a1311 1
   myCmrMgr ()->finishSplitExp ();
d1452 1
a1452 1
   witAssert (myCprMgr ()->propRouting (theBomEnt, execPer));
d1482 1
a1482 1
   if (myCprMgr ()->active (theConsEnt, execPer))
d1484 1
a1484 1
      normShare    = myCprMgr ()->normExpShare (theConsEnt, execPer);
d1541 1
a1541 1
            myCmrMgr ()->recExpBomEntSS (
d1578 1
a1578 1
         myPmrMgr ()->selBopEnt (thePart, expPer):
@


1.99
log
@Continued implementation of propotionate routing.
@
text
@d1031 3
a1033 4
      if (theBopEnt->expEligible (expPer))
         if (myPprMgr ()->active (theBopEnt, expPer))
            {
            execPer    = execPerFor (theBopEnt, expPer);
d1035 1
a1035 1
            normShare  = myPprMgr ()->normExpShare (theBopEnt, expPer);
d1037 1
a1037 1
            propExpVol = expVol * normShare;
d1039 1
a1039 1
            expOK      = explode (theBopEnt, execPer, propExpVol, fillPer);
d1041 3
a1043 3
            if (! expOK)
               return false;
            }
d1492 3
a1494 4
   if (theConsEnt->inEffect (execPer))
      if (myCprMgr ()->active (theConsEnt, execPer))
         {
         normShare    = myCprMgr ()->normExpShare (theConsEnt, execPer);
d1496 1
a1496 1
         propDeltaVol = deltaExecVol * normShare;
d1498 7
a1504 7
         explodeConsEntry (
            theConsEnt,
            execPer, 
            propDeltaVol,
            fillPer, 
            theBopEnt);
         }
@


1.98
log
@Continued implementation of proportionate routing.
@
text
@d24 1
a24 1
#include <MrSelMgr.h>
d26 1
a26 1
#include <PrSelMgr.h>
d67 4
a70 4
      myPmrSelMgr_      (NULL),
      myCmrSelMgr_      (NULL),
      myPprSelMgr_      (NULL),
      myCprSelMgr_      (NULL),
d424 2
a425 2
      myPmrSelMgr_ = mySelector ()->myMrMgr ()->myPmrSelMgr ();
      myCmrSelMgr_ = mySelector ()->myMrMgr ()->myCmrSelMgr ();
d430 2
a431 2
      myPprSelMgr_ = mySelector ()->myPrMgr ()->myPprSelMgr ();
      myCprSelMgr_ = mySelector ()->myPrMgr ()->myCprSelMgr ();
d855 1
a855 1
      if (myPprSelMgr ()->propRouting (thePart, expPer))
d920 1
a920 1
   if (multiRoute_ and myPmrSelMgr ()->selIsSplit (thePart, expPer))
d922 1
a922 1
      myPmrSelMgr ()->startSplitExp (thePart, expPer, expVol);
d926 1
a926 1
      while (myPmrSelMgr ()->findNextSplit (theBopEnt, splitExpVol))
d934 1
a934 1
      myPmrSelMgr ()->finishSplitExp ();
d986 1
a986 1
         myPmrSelMgr ()->recExpPartSS (theBopEnt->myPart (), expPer, expVol);
d1028 1
a1028 1
   witAssert (myPprSelMgr ()->propRouting (thePart, expPer));
d1032 1
a1032 1
         if (myPprSelMgr ()->active (theBopEnt, expPer))
d1036 1
a1036 1
            normShare  = myPprSelMgr ()->normExpShare (theBopEnt, expPer);
d1259 1
a1259 1
      if (myCmrSelMgr ()->selIsSplit (theBomEnt, execPer))
d1272 1
a1272 1
      if (myCprSelMgr ()->propRouting (theBomEnt, execPer))
d1286 1
a1286 1
         myCmrSelMgr ()->selConsEnt (theBomEnt, execPer):
d1312 1
a1312 1
   myCmrSelMgr ()->startSplitExp (theBomEnt, execPer, deltaExecVol);
d1314 1
a1314 1
   while (myCmrSelMgr ()->findNextSplit (theConsEnt, splitExecVol))
d1322 1
a1322 1
   myCmrSelMgr ()->finishSplitExp ();
d1463 1
a1463 1
   witAssert (myCprSelMgr ()->propRouting (theBomEnt, execPer));
d1494 1
a1494 1
      if (myCprSelMgr ()->active (theConsEnt, execPer))
d1496 1
a1496 1
         normShare    = myCprSelMgr ()->normExpShare (theConsEnt, execPer);
d1553 1
a1553 1
            myCmrSelMgr ()->recExpBomEntSS (
d1590 1
a1590 1
         myPmrSelMgr ()->selBopEnt (thePart, expPer):
@


1.97
log
@Continued implementation of proportionate routing.
@
text
@d21 1
d24 1
d26 1
d67 4
a70 3
      myPmrMgr_         (NULL),
      myCmrMgr_         (NULL),
      myPrMgr_          (NULL),
d424 2
a425 2
      myPmrMgr_ = mySelector ()->myPmrMgr ();
      myCmrMgr_ = mySelector ()->myCmrMgr ();
d429 4
a432 1
      myPrMgr_ = mySelector ()->myPrMgr ();
d550 1
a550 1
   thePart->getMaterial (theMat);
d793 1
a793 1
   thePart->getMaterial (theMat);
d855 1
a855 1
      if (myPrMgr ()->propRouting (thePart->myRtSite (), expPer))
d920 1
a920 1
   if (multiRoute_ and myPmrMgr ()->selIsSplit (thePart, expPer))
d922 1
a922 1
      myPmrMgr ()->startSplitExp (thePart, expPer, expVol);
d926 1
a926 1
      while (myPmrMgr ()->findNextSplit (theBopEnt, splitExpVol))
d934 1
a934 1
      myPmrMgr ()->finishSplitExp ();
d986 1
a986 1
         myPmrMgr ()->recPartExpPerSS (theBopEnt->myPart (), expPer, expVol);
d1028 1
a1028 1
   witAssert (myPrMgr ()->propRouting (thePart->myRtSite (), expPer));
d1032 1
a1032 1
         if (myPrMgr ()->active (theBopEnt->myRtCand (), expPer))
d1036 1
a1036 2
            normShare  =
               myPrMgr ()->normExpShare (theBopEnt->myRtCand (), expPer);
d1259 1
a1259 1
      if (myCmrMgr ()->selIsSplit (theBomEnt, execPer))
d1272 1
a1272 1
      if (myPrMgr ()->propRouting (theBomEnt->myRtSite (), execPer))
d1286 1
a1286 1
         myCmrMgr ()->selConsEntry (theBomEnt, execPer):
d1312 1
a1312 1
   myCmrMgr ()->startSplitExp (theBomEnt, execPer, deltaExecVol);
d1314 1
a1314 1
   while (myCmrMgr ()->findNextSplit (theConsEnt, splitExecVol))
d1322 1
a1322 1
   myCmrMgr ()->finishSplitExp ();
d1463 1
a1463 1
   witAssert (myPrMgr ()->propRouting (theBomEnt->myRtSite (), execPer));
d1494 1
a1494 1
      if (myPrMgr ()->active (theConsEnt->myRtCand (), execPer))
d1496 1
a1496 2
         normShare    =
            myPrMgr ()->normExpShare (theConsEnt->myRtCand (), execPer);
d1553 1
a1553 1
            myCmrMgr ()->recExpBomEntSS (
d1568 1
a1568 1
   theConsEnt->getSubEntry (theSub);
d1590 2
a1591 2
         myPmrMgr ()->selBopEntry (thePart, expPer):
         thePart    ->expBopEntry          (expPer);
d1600 2
a1601 2
         myMeMgr ()->selExecPer    (theBopEnt, expPer):
         theBopEnt ->expExecPeriod ()         [expPer];
@


1.96
log
@Continued implementation of proportionate routing.
@
text
@a62 1
      myRtMgr_          (NULL),
a108 1
   myRtMgr_      = new WitRtMgr      (myProblem ());
a173 1
   delete myRtMgr_;
d1064 1
a1064 1
      mySglSrcMgr ()->recExp (theBopEnt);
d1520 1
a1520 1
      mySglSrcMgr ()->recExp (theConsEnt);
@


1.95
log
@Continued implementation of proportionate routing.
@
text
@d1255 9
a1263 7
   if (multiRoute_ and myCmrMgr ()->selIsSplit (theBomEnt, execPer))
      explodeBomEntrySS (
         theBomEnt,
         execPer,
         deltaExecVol,
         fillPer,
         theBopEnt);
d1265 2
a1266 3
   else if (
                propRouting_
            and myPrMgr ()->propRouting (theBomEnt->myRtSite (), execPer))
d1268 9
a1276 12
      explodeBomEntryPR (
         theBomEnt,
         execPer,
         deltaExecVol,
         fillPer,
         theBopEnt);
   else
      {
      theConsEnt = 
         multiRoute_?
            myCmrMgr ()->selConsEntry (theBomEnt, execPer):
            theBomEnt;
d1278 14
a1291 7
      explodeConsEntry (
         theConsEnt,
         execPer, 
         deltaExecVol, 
         fillPer, 
         theBopEnt);
      }
@


1.94
log
@Continued implementation of proportionate routing.
@
text
@d23 1
a23 1
#include <OpMgr1.h>
a66 2
      myProdOpMgr_      (NULL),
      myConsOpMgr_      (NULL),
a75 1
      oldPr_            (false),
a413 1
   oldPr_       = mySelector ()->oldPr       ();
a426 6
   if (oldPr_)
      {
      myProdOpMgr_ = mySelector ()->myProdOpMgr ();
      myConsOpMgr_ = mySelector ()->myConsOpMgr ();
      }

d850 3
a852 3
   if (oldPr_)
      if (myProdOpMgr ()->propRouting (thePart, expPer))
         return explodePartOldPR (thePart, expPer, netReqVol, fillPer);
d1012 1
a1012 1
bool WitHeurAtor::explodePartOldPR (
d1024 1
a1024 1
   witAssert (myProdOpMgr ()->propRouting (thePart, expPer));
d1028 1
a1028 1
         if (myProdOpMgr ()->active (theBopEnt, expPer))
d1032 2
a1033 1
            normShare  = myProdOpMgr ()->normExpShare (theBopEnt, expPer);
d1263 4
a1266 1
   else if (oldPr_ and myConsOpMgr ()->propRouting (theBomEnt, execPer))
d1455 1
a1455 1
   witAssert (myConsOpMgr ()->propRouting (theBomEnt, execPer));
d1486 1
a1486 1
      if (myConsOpMgr ()->active (theConsEnt, execPer))
d1488 2
a1489 1
         normShare    = myConsOpMgr ()->normExpShare (theConsEnt, execPer);
@


1.93
log
@Continued implementation of proportionate routing.
@
text
@d862 1
a862 1
         return explodePartPR (thePart, expPer, netReqVol, fillPer);
d1022 1
a1022 1
bool WitHeurAtor::explodePartPR (
@


1.92
log
@Continued implementation of proportionate routing.
@
text
@d69 1
d78 1
d417 1
d431 1
a431 1
   if (propRouting_)
d437 3
d860 1
a860 1
   if (propRouting_)
d1272 1
a1272 1
   else if (propRouting_ and myConsOpMgr ()->propRouting (theBomEnt, execPer))
@


1.91
log
@Continued implementation of proportionate routing.
@
text
@d23 1
a23 1
#include <PrMgr.h>
d67 2
a68 2
      myProdPrMgr_      (NULL),
      myConsPrMgr_      (NULL),
d430 2
a431 2
      myProdPrMgr_ = mySelector ()->myProdPrMgr ();
      myConsPrMgr_ = mySelector ()->myConsPrMgr ();
d855 1
a855 1
      if (myProdPrMgr ()->propRouting (thePart, expPer))
d1028 1
a1028 1
   witAssert (myProdPrMgr ()->propRouting (thePart, expPer));
d1032 1
a1032 1
         if (myProdPrMgr ()->active (theBopEnt, expPer))
d1036 1
a1036 1
            normShare  = myProdPrMgr ()->normExpShare (theBopEnt, expPer);
d1266 1
a1266 1
   else if (propRouting_ and myConsPrMgr ()->propRouting (theBomEnt, execPer))
d1455 1
a1455 1
   witAssert (myConsPrMgr ()->propRouting (theBomEnt, execPer));
d1486 1
a1486 1
      if (myConsPrMgr ()->active (theConsEnt, execPer))
d1488 1
a1488 1
         normShare    = myConsPrMgr ()->normExpShare (theConsEnt, execPer);
@


1.90
log
@Continued implementation of proportionate routing.
@
text
@d20 1
d63 1
d110 2
a111 2

   myReqSched_   = new WitReqSched (myProblem ());
d177 1
@


1.89
log
@Continued implementation of proportionate routing.
@
text
@a37 1
#include <RefI.h>
@


1.88
log
@Continued implementation of proportionate routing.
@
text
@d1030 1
a1030 1
         if (myProdPrMgr ()->included (theBopEnt, expPer))
d1484 1
a1484 1
      if (myConsPrMgr ()->included (theConsEnt, execPer))
@


1.87
log
@Continued implementation of proportionate routing.
@
text
@d67 1
d427 1
d429 2
d1030 3
a1032 4
         if (theBopEnt->expShare () > 0.0)
            if (myProdPrMgr ()->included (theBopEnt, expPer))
               {
               execPer    = execPerFor (theBopEnt, expPer);
d1034 1
a1034 1
               normShare  = myProdPrMgr ()->normExpShare (theBopEnt, expPer);
d1036 1
a1036 1
               propExpVol = expVol * normShare;
d1038 1
a1038 1
               expOK      = explode (theBopEnt, execPer, propExpVol, fillPer);
d1040 3
a1042 3
               if (! expOK)
                  return false;
               }
d1263 8
d1333 3
d1444 57
d1508 3
a1510 4
   WitPeriod     consPer;
   double        consumedQty;
   WitPart *     consPart;
   WitSubEntry * theSub;
d1538 1
a1538 15
   if (not tempMode_)
      if (multiRoute_)
         {
         theConsEnt->getSubEntry (theSub);

         if (theSub != NULL)
            {
            saveVal (subVol_ (theSub).elemRef (execPer));

            subVol_ (theSub).elemRef (execPer) += netExecQty;

            if (perfPegging_)
               myPegger_->pegDeltaVol (theSub, execPer, netExecQty);
            }
         }
d1547 25
@


1.86
log
@Continued implementation of proportionate routing.
@
text
@d66 1
a66 1
      myPprMgr_         (NULL),
d426 1
a426 1
      myPprMgr_ = mySelector ()->myPprMgr ();
d849 1
a849 1
      if (myPprMgr ()->propRouting (thePart, expPer))
d1022 1
a1022 1
   witAssert (myPprMgr ()->propRouting (thePart, expPer));
d1027 1
a1027 1
            if (myPprMgr ()->included (theBopEnt, expPer))
d1031 1
a1031 1
               normShare  = myPprMgr ()->normExpShare (theBopEnt, expPer);
@


1.85
log
@Continued implementation of proportionate routing.
@
text
@d66 1
a66 1
      myPrMgr_          (NULL),
d426 1
a426 1
      myPrMgr_  = mySelector ()->myPrMgr ();
d849 1
a849 1
      if (myPrMgr ()->propRouting (thePart, expPer))
d1022 1
a1022 1
   witAssert (myPrMgr ()->propRouting (thePart, expPer));
d1027 1
a1027 1
            if (myPrMgr ()->included (theBopEnt, expPer))
d1031 1
a1031 1
               normShare  = myPrMgr ()->normExpShare (theBopEnt, expPer);
@


1.84
log
@Continued implementation of proportionate routing.
@
text
@d849 1
a849 1
      if (myPrMgr ()->propRouting (thePart))
d1022 1
a1022 1
   witAssert (myPrMgr ()->propRouting (thePart));
@


1.83
log
@Continued implementation of Proportionate Routing.
@
text
@d22 1
d66 1
d75 1
d409 1
a409 1
   mySelector_ = new WitSelector (this);
d411 7
a417 6
   multiRoute_ = mySelector ()->multiRoute ();
   buildAhead_ = mySelector ()->buildAhead ();
   multiExec_  = mySelector ()->multiExec  ();
   penExec_    = mySelector ()->penExec    ();
   selSplit_   = mySelector ()->selSplit   ();
   sglSrc_     = mySelector ()->sglSrc     ();
d425 3
d429 1
a429 1
      myBaMgr_ = mySelector ()->myBaMgr ();
d432 1
a432 1
      myMeMgr_ = mySelector ()->myMeMgr ();
d848 4
d1006 36
@


1.82
log
@Internal changes.
@
text
@a91 1
   WitMaterial *  theMat;
a92 1
   bool           selSRneeded;
d111 1
a111 50
   multiRoute_ = myGlobalComp ()->multiRoute ();

   forEachMaterial (theMat, myProblem ())
      if (theMat->nstnBaNeeded () or theMat->buildAsap ())
         {
         buildAhead_ = true;

         break;
         }

   multiExec_  = myGlobalComp ()->multiExecNeeded ();

   selSRneeded = false;

   forEachMaterial (theMat, myProblem ())
      if (myAvailSched_->selectiveSR (theMat))
         {
         selSRneeded = true;

         break;
         }

   if (multiRoute_ or buildAhead_ or multiExec_ or selSRneeded)
      {
      mySelector_ = new WitSelector (this);

      penExec_    = mySelector ()->penExec ();
      }

   if (multiRoute_)
      {
      myPmrMgr_ = mySelector ()->myPmrMgr ();
      myCmrMgr_ = mySelector ()->myCmrMgr ();
      }

   if (buildAhead_)
      myBaMgr_    = mySelector ()->myBaMgr ();

   if (multiExec_)
      myMeMgr_    = mySelector ()->myMeMgr ();

   if (selSRneeded)
      {
      mySsrMgr_   = mySelector ()->mySsrMgr ();

      myAvailSched_->attachSsrMgr ();
      }

   if (penExec_)
      myExpRest_  = mySelector ()->myExpRest ();
a131 13
   if (multiSel ())
      selSplit_ = mySelector ()->selSplit ();

   if (selSplit_)
      if (critListMode ())
         myMsgFac () ("critListSelSplitSmsg");

   if (multiSel ())
      sglSrc_      = mySelector ()->sglSrc ();

   if (sglSrc_)
      mySglSrcMgr_ = mySelector ()->mySglSrcMgr ();

d397 46
@


1.81
log
@Internal changes.
@
text
@d96 1
a96 1
   if (! forOpt)
d102 1
a102 1
   if (! forOpt)
d116 1
a116 1
      if (theMat->nstnBaNeeded () || theMat->buildAsap ())
d123 1
a123 1
   multiExec_ = myGlobalComp ()->multiExecNeeded ();
d135 1
a135 1
   if (multiRoute_ || buildAhead_ || multiExec_ || selSRneeded)
d165 1
a165 1
      if (! multiRoute_)
d169 1
a169 1
      if (! multiRoute_)
d172 1
a172 1
   if (! userHeurStart_)
d176 1
a176 1
      if (! (theOpn->execBounds ()->hardUB () == -1.0))
d196 1
a196 1
   if (! forOpt)
d276 1
a276 1
      witAssert (! asapMultiExec);
d374 1
a374 1
   witAssert (! tempMode_);
d382 1
a382 1
   if (! success)
d527 1
a527 1
      if (! thePart->canStock (thePer))
d558 1
a558 1
      if (! (theMat->stockBounds ()->softLB () == 0.0))
d560 1
a560 1
            if (! theMat->mandEC ()[thePer])
d633 1
a633 1
   witAssert (! tempMode_);
d642 1
a642 1
   if (! success)
d682 1
a682 1
   if (! success)
d777 1
a777 1
         if (! fillOK)
d845 1
a845 1
   if (! expPerFound)
d893 1
a893 1
      if (! expOK)
d921 1
a921 1
   if (multiRoute_ && myPmrMgr ()->selIsSplit (thePart, expPer))
d931 1
a931 1
         if (! expOK)
d989 1
a989 1
   if (multiExec_ && myMeMgr ()->selIsSplit (theBopEnt, expPer))
d999 1
a999 1
         if (! expOK)
d1054 1
a1054 1
      if (! checkExecBounds (theBopEnt, execPer, newExecVol, fillPer))
d1059 1
a1059 1
      if (! myExpRest ()->restExpAllowed (theBopEnt, fillPer))
d1124 1
a1124 1
      if (! tempMode_)
d1174 1
a1174 1
            if (! tempMode_)
d1216 1
a1216 1
   if (! theBomEnt->inEffect (execPer))
d1224 1
a1224 1
   if (multiRoute_ && myCmrMgr ()->selIsSplit (theBomEnt, execPer))
d1286 1
a1286 1
   if (! theBomEnt->hasSubsInEffect ()[execPer])
d1321 1
a1321 1
   if (! theSub->netAllowed ())
d1324 1
a1324 1
   if (! theSub->inEffect (execPer))
d1331 1
a1331 1
   if (! tempMode_)
d1439 1
a1439 1
   if (! tempMode_)
@


1.80
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d47 1
a47 1
         WitBoolean                                       forOpt,
d72 10
a81 10
      multiRoute_       (witFALSE),
      buildAhead_       (witFALSE),
      multiExec_        (witFALSE),
      penExec_          (witFALSE),
      selSplit_         (witFALSE),
      sglSrc_           (witFALSE),
      perfPegging_      (witFALSE),
      userHeurStart_    (witFALSE),
      finiteExecBounds_ (witFALSE),
      tempMode_         (witFALSE),
d90 1
a90 1
      failedOn1_        (witFALSE)
d94 1
a94 1
   WitBoolean     selSRneeded;
d118 1
a118 1
         buildAhead_ = witTRUE;
d125 1
a125 1
   selSRneeded = witFALSE;
d130 1
a130 1
         selSRneeded = witTRUE;
d178 1
a178 1
         finiteExecBounds_ = witTRUE;
d201 1
a201 1
         perfPegging_ = witTRUE;
d249 1
a249 1
      WitBoolean  asapMultiExec)
d342 1
a342 1
      mySelector ()->recCommitVol (oldNetQty - netQty, witFALSE);
d355 1
a355 1
         mySelector ()->recCommitVol (maxQty, witTRUE);
d370 1
a370 1
WitBoolean WitHeurAtor::tempCommit (double qty)
d372 1
a372 1
   WitBoolean success;
d378 1
a378 1
   tempMode_ = witTRUE;
d388 1
a388 1
   tempMode_ = witFALSE;
d406 1
a406 1
WitBoolean WitHeurAtor::incAvailPos (WitPart * thePart, WitPeriod thePer)
d413 1
a413 1
WitBoolean WitHeurAtor::selectiveSR (WitMaterial * theMat)
d459 1
a459 1
      blocked_ (thePart).allocate (myProblem (), witFALSE);
d624 1
a624 1
            blocked_ (thePart)[thePer] = witTRUE;
d631 1
a631 1
   WitBoolean success;
d653 1
a653 1
   WitBoolean success;
d655 1
a655 1
   failedOn1_ = witFALSE;
d701 4
a704 4
   int        failIntQty;
   int        okIntQty;
   int        tryIntQty;
   WitBoolean success;
d730 1
a730 1
WitBoolean WitHeurAtor::commit (double qty)
d732 1
a732 1
   WitBoolean success;
d753 1
a753 1
WitBoolean WitHeurAtor::innerCommit (double qty)
d755 4
a758 4
   WitPart *  fillPart;
   WitPeriod  fillPer;
   double     theReqVol;
   WitBoolean fillOK;
d761 1
a761 1
      return witTRUE;
d778 1
a778 1
            return witFALSE;
d781 1
a781 1
   return witTRUE;
d786 1
a786 1
WitBoolean WitHeurAtor::fillReq (
d813 1
a813 1
      return witTRUE;
d823 1
a823 1
WitBoolean WitHeurAtor::fillNetReq (
d828 1
a828 1
   WitBoolean    expPerFound;
d841 1
a841 1
      myExpRest ()->recExpBeyondNet (thePart, fillPer, witFALSE);
d846 1
a846 1
      return witFALSE;
d853 1
a853 1
         return witFALSE;
d867 1
a867 1
WitBoolean WitHeurAtor::fillNetReqBASS (
d872 3
a874 3
   WitBoolean expOK;
   WitPeriod  expPer;
   double     expVol;
d883 1
a883 1
      myExpRest ()->recExpBeyondNet (thePart, fillPer, witFALSE);
d887 1
a887 1
   expOK = witTRUE;
d904 1
a904 1
WitBoolean WitHeurAtor::explodePartSS (
d910 1
a910 1
   WitBoolean    expOK;
d925 1
a925 1
      expOK = witTRUE;
d949 1
a949 1
WitBoolean WitHeurAtor::findExpPer (
d960 1
a960 1
      return witTRUE;
d968 1
a968 1
   return witFALSE;
d973 1
a973 1
WitBoolean WitHeurAtor::explodeBopEntSS (
d979 3
a981 3
   WitBoolean expOK;
   WitPeriod  execPer;
   double     splitExpVol;
d993 1
a993 1
      expOK = witTRUE;
d1017 1
a1017 1
WitBoolean WitHeurAtor::explode (
d1045 1
a1045 1
      theOpn->lotSizeDelta (execPer, oldExecVol, deltaExecVol, witTRUE);
d1048 1
a1048 1
      return witTRUE;
d1055 1
a1055 1
         return witFALSE;
d1063 1
a1063 1
         return witFALSE;
d1071 1
a1071 1
         return witFALSE;
d1076 1
a1076 1
   return witTRUE;
d1081 1
a1081 1
WitBoolean WitHeurAtor::checkExecBounds (
d1092 1
a1092 1
      return witTRUE;
d1100 1
a1100 1
   return witFALSE;
d1378 1
a1378 1
         myExpRest ()->recExpBeyondNet (consPart, consPer, witTRUE);
d1388 1
a1388 1
                  witTRUE);
d1433 1
a1433 1
               witFALSE);
@


1.79
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d31 1
d79 1
d97 6
d172 1
a172 1
   if (! myGlobalComp ()->userHeurStart ())
@


1.78
log
@Continued implementation of heuristic implosion from an initial solution.
Fixed a bug in build-ahead by demand.
Removed RWClient.C.
@
text
@d164 1
a164 1
   if (! myGlobalComp ()->heurInitSoln ())
@


1.77
log
@Continued implementation of heuristic initial solution.
@
text
@a511 1
   WitPeriod initPer;
d518 4
d523 1
a523 6
      {
      for (initPer = lastPer; initPer > firstPer; -- initPer)
         if (! thePart->canStock (initPer - 1))
            break;

      for (thePer = initPer; thePer <= lastPer; ++ thePer)
a529 1
      }
d531 1
a531 1
      for (thePer = lastPer; thePer >= firstPer; -- thePer)
a535 3
            break;
      
         if (! thePart->canStock (thePer - 1))
@


1.76
log
@Removed implementation of single-source by the old algorithm.
@
text
@a41 2
// Non-inlines.
//------------------------------------------------------------------------------
d164 1
a164 1
   if (! myGlobalComp ()->initHeurSoln ())
d713 1
a713 1
      tryIntQty  = (okIntQty + failIntQty) / 2;
d715 1
a715 1
      success    = tempCommit (tryIntQty);
@


1.75
log
@Continued implementation of single-source by the new algorithm.
@
text
@a25 1
#include <OldSglMgr.h>
a69 1
      myOldSglMgr_      (NULL),
a77 1
      oldSglSrc_        (witFALSE),
d162 1
a162 1
   if (WitOldSglMgr::sglSrcReq (myProblem ()))
a184 6
      oldSglSrc_   = mySelector ()->oldSglSrc ();

   if (oldSglSrc_)
      myOldSglMgr_ = mySelector ()->myOldSglMgr ();

   if (multiSel ())
a418 3
   else if (oldSglSrc_)
      myOldSglMgr ()->saveAllocVal (theVar);

a429 3
   else if (oldSglSrc_)
      myOldSglMgr ()->saveAllocVal (theVar);

d609 1
a609 4
   if (oldSglSrc_)
      myOldSglMgr ()->commitMaxQty (netQty);

   else if (sglSrc_)
a847 4
   if (oldSglSrc_)
      if (myOldSglMgr ()->findPmrMisMatch (thePart, expPer, fillPer))
         return witFALSE;

a1075 4
   if (oldSglSrc_)
      if (myOldSglMgr ()->checkCmrMisMatch ())
         return witFALSE;

a1218 3
   if (oldSglSrc_)
      myOldSglMgr ()->noteCmrMisMatch (theBomEnt, execPer, fillPer, theBopEnt);

a1287 4

   if (oldSglSrc_)
      if (myOldSglMgr ()->sglSrcMode (theBomEnt))
         return;
@


1.74
log
@Continued implementation of single-source by the new algorithm.
@
text
@d1058 1
a1058 2
      if (! tempMode_)
         mySglSrcMgr ()->recPermExp (theBopEnt);
d1449 1
a1449 2
      if (! tempMode_)
         mySglSrcMgr ()->recPermExp (theConsEnt);
@


1.73
log
@Continued implementation of single-source with the new algorithm.
@
text
@d1324 1
a1324 1
      if (mySglSrcMgr ()->sglSrcMode (theBomEnt))
a1422 5

      if (sglSrc_)
         if (! tempMode_)
            if (reqConsQty - netConsQty > NET_TOL)
               mySglSrcMgr ()->recPermExpNet (theConsEnt);
a1426 1
         {
a1428 5
         if (sglSrc_)
            if (! tempMode_)
               mySglSrcMgr ()->recPermExpNet (theConsEnt);
         }

d1451 1
a1451 1
         mySglSrcMgr ()->recPermExpNet (theConsEnt);
@


1.72
log
@Continued implementation of single-source by the new algorithm.
@
text
@a852 4
   if (sglSrc_)
      if (! tempMode_)
         mySglSrcMgr ()->recFillNetReq (thePart);

d1052 2
a1053 2
   if (tempMode_)
      if (selSplit_)
d1057 4
a1248 4
   if (sglSrc_)
      if (! tempMode_)
         mySglSrcMgr ()->recExp (theBomEnt);

d1416 1
a1416 1
            if (reqConsQty - netExecQty > NET_TOL)
d1423 5
d1432 1
d1435 5
d1457 6
@


1.71
log
@Continued implementation of single-source by the new algorithm.
@
text
@d655 3
@


1.70
log
@Continued implementation of single-source with the new algorithm.
Fixed a null pointer bug in single-source with the old algorithm.
@
text
@d1085 9
a1093 1
                                                                         
d1246 4
d1322 4
@


1.69
log
@Continued implementation of single-source with the new algorithm.
@
text
@d871 8
@


1.68
log
@Began implementation of the new single-source algorithm.
@
text
@d27 1
d72 1
d81 1
d165 1
a165 1
   if (WitOldSglMgr::hasSglSrcComp (myProblem ()))
d188 1
a188 1
      oldSglSrc_ = mySelector ()->oldSglSrc ();
d193 6
d430 3
d444 3
d627 3
d850 4
d1301 1
a1301 1
      if (mySelector_->myOldSglMgr ()->sglSrcMode (theBomEnt))
@


1.67
log
@Fixed the "interference bug" in Single-Source.
@
text
@d26 1
a26 1
#include <SglSrcMgr.h>
d70 1
a70 1
      mySglSrcMgr_      (NULL),
d78 1
a78 1
      singleSource_     (witFALSE),
d162 1
a162 1
   if (WitSglSrcMgr::hasSglSrcComp (myProblem ()))
d185 1
a185 1
      singleSource_ = mySelector ()->singleSource ();
d187 2
a188 2
   if (singleSource_)
      mySglSrcMgr_ = mySelector ()->mySglSrcMgr ();
d419 2
a420 2
   else if (singleSource_)
      mySglSrcMgr ()->saveAllocVal (theVar);
d430 2
a431 2
   else if (singleSource_)
      mySglSrcMgr ()->saveAllocVal (theVar);
d609 2
a610 2
   if (singleSource_)
      mySglSrcMgr ()->commitMaxQty (netQty);
d845 2
a846 2
   if (singleSource_)
      if (mySglSrcMgr ()->findPmrMisMatch (thePart, expPer, fillPer))
d1058 2
a1059 2
   if (singleSource_)
      if (mySglSrcMgr ()->checkCmrMisMatch ())
d1205 2
a1206 2
   if (singleSource_)
      mySglSrcMgr ()->noteCmrMisMatch (theBomEnt, execPer, fillPer, theBopEnt);
d1278 2
a1279 2
   if (singleSource_)
      if (mySelector_->mySglSrcMgr ()->sglSrcMode (theBomEnt))
@


1.66
log
@Continued implementation of heuristic implosion from an initial solution.
Added some debugging code to Single-Source.
@
text
@a41 40

//------------------------------------------------------------------------------
// Inlines.
//------------------------------------------------------------------------------

inline WitPeriod WitHeurAtor::expPerFor (
      WitPart * thePart, 
      WitPeriod fillPer)
   {
   return
      buildAhead_? 
         myBaMgr ()->selExpPer (thePart, fillPer):
         thePart   ->explosionPeriod    (fillPer);
   }

//------------------------------------------------------------------------------

inline WitBopEntry * WitHeurAtor::expBopEntry (
      WitPart * thePart, 
      WitPeriod expPer)
   {
   return
      multiRoute_? 
         myPmrMgr ()->selBopEntry (thePart, expPer):
         thePart    ->expBopEntry          (expPer);
   }

//------------------------------------------------------------------------------

inline WitPeriod WitHeurAtor::execPerFor (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer)
   {
   return
      multiExec_?
         myMeMgr ()->selExecPer    (theBopEnt, expPer):
         theBopEnt ->expExecPeriod ()         [expPer];
   }

//------------------------------------------------------------------------------
d70 1
d187 3
d420 1
a420 1
      mySelector ()->mySglSrcMgr ()->saveAllocVal (theVar);
d431 1
a431 1
      mySelector ()->mySglSrcMgr ()->saveAllocVal (theVar);
d610 1
a610 1
      mySelector ()->mySglSrcMgr ()->commitMaxQty (netQty);
d845 4
d947 4
a950 1
   expPer = expPerFor (thePart, fillPer);
d1058 4
d1205 3
d1446 20
@


1.65
log
@Fixed a cumulative shipment bug in heuristic allocation.
@
text
@d205 1
a205 1
   if (! myGlobalComp ()->heurInitSoln ())
d524 1
a524 1
   for (othPer = 0; othPer < thePer; othPer ++)
@


1.64
log
@Began implementation of heuristic implosion from an initial solution.
@
text
@d292 4
a295 7
   demandedIncVol =
      min (
         desIncVol,
         theDemand->cumDemandVol ()[thePer] - cumShipVol (theDemand, thePer));
            //
            // demandedIncVol is desIncVol reduced so as not to exceed
            // cumulative demand.
d516 1
a516 1
double WitHeurAtor::cumShipVol (WitDemand * theDemand, WitPeriod thePer)
d518 8
a525 2
   WitPeriod otherPer;
   double    theCumShipVol;
d527 1
a527 1
   theCumShipVol = 0.0;
d529 8
a536 2
   for (otherPer = 0; otherPer <= thePer; ++ otherPer)
      theCumShipVol += theDemand->shipVol ()[otherPer];
d538 1
a538 1
   return theCumShipVol;
@


1.63
log
@Continued implementation of 2-level lot sizes.
@
text
@d205 2
a206 1
   initSoln ();
@


1.62
log
@Continued implementation of 2-level lot sizes.
@
text
@d1053 2
a1054 1
   theOpn->lotSizeDelta (execPer, oldExecVol, deltaExecVol, witTRUE, witTRUE);
@


1.61
log
@Began implementation of multi-level lot sizes.
@
text
@a675 2
   double     minQty;
   double     incQty;
d691 1
a691 3
   defSearchGrid (minQty, incQty);

   if (desQty <= minQty + SEARCH_TOL)
d703 1
a703 1
   success = tempCommit (minQty);
d708 1
a708 1
         // The smallest amount allowed is infeasible.
d717 1
a717 1
   return binarySearch (desQty, minQty, incQty);
d722 1
a722 1
void WitHeurAtor::defSearchGrid (double & minQty, double & incQty)
d724 3
a726 66
   WitPeriod      expPer;
   WitBopEntry *  theBopEnt;
   WitPeriod      execPer;
   WitOperation * theOpn;
   double         theEffProdRate;

   minQty = 1.0;
   incQty = 1.0;
      //
      // Default values.

   if (! myGlobalComp ()->lotSizesExist ())
      return;

   expPer = expPerFor (topPart (), topPer ());

   if (! topPart ()->explodeable (expPer))
      return;

   theBopEnt = expBopEntry (topPart (), expPer);
   execPer   = execPerFor  (theBopEnt,  expPer);

   theOpn    = theBopEnt->myOperation ();

   if (! theOpn->lotSizeMode (execPer))
      return;

   theEffProdRate = theBopEnt->effProdRate ()[execPer];

   incQty = theOpn->incLotSize ()[execPer] * theEffProdRate;

   if (theOpn->execVol ()[execPer] > FLOAT_EPSILON)
      minQty = incQty;
   else
      {
      minQty = theOpn->minLotSize ()[execPer] * theEffProdRate;

      if (minQty == 0.0)
         minQty = incQty;
      }

   if (! (isAnInteger (minQty) && isAnInteger (incQty)))
      {
      minQty = 1.0;
      incQty = 1.0;
      }
   }

//------------------------------------------------------------------------------

WitBoolean WitHeurAtor::isAnInteger (double theDbl)
   {
   return (theDbl - floor (theDbl + FLOAT_EPSILON) <= FLOAT_EPSILON);
   }

//------------------------------------------------------------------------------

double WitHeurAtor::binarySearch (
      double desQty,
      double minQty,
      double incQty)
   {
   int        upperGP;
   int        lowerGP;
   int        midGP;
   double     qty;
d732 1
a732 7
   upperGP =
      myGlobalComp ()->lotSizeGridPoint (
         minQty,
         incQty,
         desQty,
         witTRUE,
         witTRUE);
d734 1
a734 1
   lowerGP = 0;
d736 1
a736 1
   while (upperGP - lowerGP > 1)
d738 1
a738 3
      midGP   = (lowerGP + upperGP) / 2;

      qty     = WitOperation::compLotSizeQty (minQty, incQty, midGP);
d740 1
a740 1
      success = tempCommit (qty);
d743 1
a743 1
         lowerGP = midGP;
d745 1
a745 1
         upperGP = midGP;
d748 1
a748 3
   qty = WitOperation::compLotSizeQty (minQty, incQty, lowerGP);

   return qty;
@


1.60
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d21 1
a21 2
#include <PmrMgr.h>
#include <CmrMgr.h>
d1027 1
a1027 1
      myPmrMgr ()->mySelMgr ()->finishSplitExp ();
d1349 1
a1349 1
   myCmrMgr ()->mySelMgr ()->finishSplitExp ();
@


1.59
log
@Fixed a bug in selection splitting discovered by Fukunaga.
@
text
@d32 1
d38 1
a38 1
#include <MsgFac.h>
@


1.58
log
@Continued implementation of single-source.
@
text
@d1009 3
a1011 2
   if (buildAhead_)
      myBaMgr ()->recExpMatSS (thePart, fillPer, expVol);
d1074 3
a1076 2
   if (multiRoute_)
      myPmrMgr ()->recPartExpPerSS (theBopEnt->myPart (), expPer, expVol);
d1119 4
a1122 3
   if (selSplit_)
      if (multiExec_)
         myMeMgr ()->recBopEntExecPerSS (theBopEnt, execPer, qty);
d1527 7
a1533 6
   if (selSplit_)
      if (multiRoute_)
         myCmrMgr ()->recExpBomEntSS (
            theConsEnt->myBomEnt (),
            execPer,
            netExecQty);
@


1.57
log
@Continued implementation of single-source.
@
text
@d1293 1
a1293 8
   if (theBomEnt->hasSubsInEffect ()[execPer])
      {
      netConsEntries (
         theBomEnt,
         execPer,
         deltaExecVol,
         fillPer,
         theBopEnt);
d1295 2
a1296 3
      if (deltaExecVol < NET_TOL )
         return;
      }
d1359 7
@


1.56
log
@Continued implementation of Single-Source.
@
text
@d201 1
a201 1
   if (WitSglSrcMgr::singleSourceNeeded (myProblem ()))
d203 1
a203 1
         myMsgFac () ("sglSrcWoMultiRouteSmsg");
@


1.55
log
@Continued implementation of Single-Source.
@
text
@d191 1
a191 1
      myAvailSched_->assocSsrMgr ();
a444 7
void WitHeurAtor::resConsStock (WitMaterial * theMat, WitPeriod thePer)
   {
   myAvailSched_->resConsStock (theMat, thePer);
   }

//------------------------------------------------------------------------------

d595 1
a595 1
   double unresVol;
d599 1
a599 3
   myAvailSched_->reserveAllocedStSLB (theMat, thePer);

   unresVol = myAvailSched_->unresStSLB (theMat, thePer);
d601 1
a601 1
   if (unresVol < NET_TOL)
d604 1
a604 1
   netVol = unresVol;
d608 1
a608 1
   commitVol = unresVol - netVol;
d610 3
a612 5
   if (commitVol < NET_TOL)
      return;

   myAvailSched_->addToIncAvailVol (theMat, thePer,             commitVol);
   myAvailSched_->reserveStock     (theMat, thePer, thePer + 1, commitVol);
d891 1
a892 1
   double        netReqVol;
d901 1
a901 1
      myAvailSched_->netWithIncAvail (thePart, fillPer, netReqVol);
d903 4
a906 8
   else if (myAvailSched_->uncondSR (theMat))
                     netAndRollReq   (theMat,  fillPer, netReqVol);

   else if (myAvailSched_->selectiveSR (theMat))
                     netAndRollReq   (theMat,  fillPer, netReqVol);

   else 
      myAvailSched_->netWoSRAndRes   (theMat,  fillPer, netReqVol);
d1216 1
a1216 5
   myAvailSched_->alloc (
      theBopEnt->myPart (),
      theBopEnt->impactPeriod ()[execPer],
      fillPer, 
      qty);
d1263 1
a1263 3
   witAssert (
         myAvailSched_->uncondSR    (theMat)
      || myAvailSched_->selectiveSR (theMat));
@


1.54
log
@Continued implementation of Single-Source.
@
text
@a549 3
   if (singleSource_)
      myMsgFac () ("nyiWithSglSrcSmsg", "Build-ahead by demand");

@


1.53
log
@Continued implementation of Single-Source.
@
text
@d117 1
a117 1
      sglSrc_           (witFALSE),
d223 1
a223 1
      sglSrc_ = mySelector ()->singleSource ();
d234 1
a234 1
         myPegger_->setUpPeggedHeurAlloc ();
d464 1
a464 1
   else if (sglSrc_)
d475 1
a475 1
   else if (sglSrc_)
d550 1
a550 1
   if (sglSrc_)
d649 1
a649 1
   if (sglSrc_)
@


1.52
log
@Continued implementation of Single-Source.
@
text
@a27 1
#include <PegSite.h>
@


1.51
log
@Continued implementation of single-source.
@
text
@d29 1
a29 1
#include <PegMgr.h>
d88 1
a88 1
         WitPegMgr *                                      thePegMgr,
d111 1
a111 1
      myPegMgr_         (NULL),
d229 1
a229 1
         witAssert (thePegMgr != NULL);
d233 1
a233 1
         myPegMgr_    = thePegMgr;
d235 1
a235 1
         myPegMgr_->setUpPeggedHeurAlloc ();
d262 1
a262 1
      myPegMgr_->shutDownPeggedHeurAlloc ();
d304 1
a304 1
      theDemand->myPegSite ()->setUpPeggedIncAlloc (thePer, myPegMgr_);
d327 1
a327 1
      myPegMgr_->shutDownPeggedIncAlloc ();
d1218 1
a1218 1
         myPegMgr_->pegDeltaVol (theOpn, execPer, deltaExecVol);
d1442 1
a1442 1
            myPegMgr_->pegDeltaVol (theSub, execPer, deltaVol);
d1546 1
a1546 1
               myPegMgr_->pegDeltaVol (theSub, execPer, netExecQty);
@


1.50
log
@Continued implementation of Single-Source.
@
text
@d112 1
a112 1
      tempModeRepos_    (* new WitDataRepos (theProblem)),
d238 2
d264 5
a268 5
   delete & tempModeRepos_;
   delete   mySelector_;
   delete   myReqSched_;
   delete   myHeurCritList_;
   delete   myAvailSched_;
d463 1
a463 1
      tempModeRepos_.saveVal (theVar);
d474 1
a474 1
      tempModeRepos_.saveVal (theVar);
d858 1
a858 1
   tempModeRepos_.restore ();
@


1.49
log
@Continued implementation of single-source.
@
text
@a32 1
#include <Schedule.h>
d35 1
a35 1
#include <MsgFac.h>
d38 1
a121 1
      blocked_          (* new WitSchedule <WitPart, WitPeriod>),
a261 1
   delete & blocked_;
@


1.48
log
@Continued implementation of single-source.
@
text
@d639 1
a639 1
         if (blocked_ (thePart, thePer))
d665 1
a665 1
            blocked_ (thePart, thePer) = witTRUE;
@


1.47
log
@Continued implementation of single-source.
@
text
@d37 2
d87 7
a93 4
         WitProblem * theProblem,
         WitAccFlag * theAccFlag,
         WitPegMgr *  thePegMgr,
         WitBoolean   forOpt):
d97 4
a112 1
      myAccFlag_        (theAccFlag),
d139 1
a139 1
         myHeurCritList_ = new WitHeurCritList (myProblem (), myAccFlag_);
d321 1
a321 1
      shipVol (theDemand).elemRef (thePer) += incVol;
d515 1
a515 1
      shipVol (theDemand).setToScalar (0.0);
d518 1
a518 1
      execVol (theOpn).setToScalar (0.0);
d521 1
a521 1
      subVol (theSub).setToScalar (0.0);
d1212 1
a1212 1
   saveVal (execVol (theOpn).elemRef (execPer));
d1214 1
a1214 1
   execVol (theOpn).elemRef (execPer) += deltaExecVol;
d1437 1
a1437 1
         saveVal (subVol (theSub).elemRef (execPer));
d1439 1
a1439 1
         subVol (theSub).elemRef (execPer) += deltaVol;
d1541 1
a1541 1
            saveVal (subVol (theSub).elemRef (execPer));
d1543 1
a1543 1
            subVol (theSub).elemRef (execPer) += netExecQty;
@


1.46
log
@Continued implementation of single-source.
@
text
@d643 1
a643 1
      mySelector ()->mySglSrcMgr ()->commitMaxQtyTest (netQty);
@


1.45
log
@Continued implementation of single source.
@
text
@d195 4
d217 1
a217 1
      sglSrc_ = mySelector ()->sglSrc ();
@


1.44
log
@Continued implementation of single source.
@
text
@d110 1
d212 3
d453 2
a454 2
   else if (myGlobalComp ()->sglSrc ())
      mySelector ()->mySglSrcMgr ()->saveVal (theVar);
d464 2
a465 2
   else if (myGlobalComp ()->sglSrc ())
      mySelector ()->mySglSrcMgr ()->saveVal (theVar);
d539 1
a539 1
   if (myGlobalComp ()->sglSrc ())
d638 6
a643 7
   if (multiSel ())
      {
      if (myGlobalComp ()->sglSrc ())
         mySelector ()->mySglSrcMgr ()->commitMaxQtyTest (netQty);
      else
         mySelector ()->commitMaxQty (netQty);
      }
d1529 2
@


1.43
log
@Continued implementation of single source.
@
text
@d27 1
d103 1
a103 1
      myDataRepos_      (* new WitDataRepos (theProblem)),
d248 1
a248 1
   delete & myDataRepos_;
d444 22
d535 3
d635 6
a640 1
      mySelector ()->commitMaxQty (netQty);
d841 3
a843 3
   myDataRepos_  .restore ();
   myAvailSched_->restore ();
   myReqSched_  ->clear ();
d1197 1
a1197 2
   if (tempMode_)
      myDataRepos_.saveVal (execVol (theOpn).elemRef (execPer));
d1422 2
@


1.42
log
@Preliminary work on single source.
@
text
@d34 1
a34 1
#include <Archive.h>
a90 2
      myDblArch_        (NULL),
      myPerArch_        (NULL),
d102 1
a126 3
   myDblArch_ = new WitArchive <double>    (theProblem);
   myPerArch_ = new WitArchive <WitPeriod> (theProblem);

d133 1
a133 1
   myReqSched_   = new WitReqSched   (this);
d247 1
a251 2
   delete   myDblArch_;
   delete   myPerArch_;
d808 1
a808 1
   success  = innerCommit (qty);
d810 3
a812 2
   myDblArch_->restore ();
   myPerArch_->restore ();
d1167 1
a1167 1
      myDblArch_->saveVal (execVol (theOpn).elemRef (execPer));
@


1.41
log
@Continued preliminary work on single source.
@
text
@d481 1
a481 1
      shipVol (theDemand) = 0.0;
d484 1
a484 1
      execVol (theOpn) = 0.0;
d487 1
a487 1
      subVol (theSub) = 0.0;
@


1.40
log
@Preliminary work on single source.
@
text
@d29 4
d113 1
a113 1
      blocked_          (),
d250 7
a256 6
   delete mySelector_;
   delete myReqSched_;
   delete myHeurCritList_;
   delete myAvailSched_;
   delete myDblArch_;
   delete myPerArch_;
@


1.39
log
@Continued implementation of object iteration.
@
text
@d335 1
a335 1
      reverseCopyInto (reversedParts, myCompMgr ()->allParts ());
@


1.38
log
@Began implementation of object iteration.
@
text
@d550 1
a550 1
   theMat = thePart->myMat ();
d866 1
a866 1
   theMat    = thePart->myMat ();
d1486 6
a1491 3
   if (multiRoute_)
      if (theConsEnt->isaSubEntry ())
         if (! tempMode_)
a1492 2
            theSub = theConsEnt->asaSubEntry ();

d1498 1
@


1.37
log
@Continued implementation of sel-split for pen-exec.
@
text
@d31 1
d135 1
a135 1
   if (skipFailures ())
d595 1
a595 1
   if (skipFailures ())
d616 1
a616 1
   if (skipFailures ())
@


1.36
log
@Continued implementation of sel-split for pen-exec.
@
text
@d809 2
a810 2
   myDblArch_->restoreAllVals ();
   myPerArch_->restoreAllVals ();
@


1.35
log
@Continued implementation of sel-split for pen-exec.
@
text
@a20 1
#include <Splitter.h>
a91 1
      mySplitter_       (NULL),
a205 3
      {
      mySplitter_ = mySelector ()->mySplitter ();

a207 1
      }
d805 1
a805 1
      mySplitter ()->preCommit ();
a832 10
      {
      if (selSplit_)
         if (mySplitter ()->fastMode ())
            {
            if (mySplitter ()->skipCommitItr (fillPart))
               continue;

            mySplitter ()->recCommitItr (fillPart);
            }

a846 1
      }
@


1.34
log
@Continued implementation of sel-split for pen-exec.
@
text
@a806 1
   WitBoolean needRestore;
d813 1
a813 1
   success     = innerCommit (qty);
d815 2
a816 15
   needRestore = witTRUE;

   if (selSplit_)
      if (! penExec_)
         {
         mySplitter ()->postCommit ();

         needRestore = witFALSE;
         }

   if (needRestore)
      {
      myDblArch_->restoreAllVals ();
      myPerArch_->restoreAllVals ();
      }
@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@a27 1
#include <SsPeMgr1.h>
d812 3
a814 6
      {
      if (penExec_)
         mySelector ()->mySsPeMgr ()->preCommit ();
      else
         mySplitter ()->preCommit ();
      }
d816 1
a816 1
   success = innerCommit (qty);
d819 1
a819 4
      {
      if (penExec_)
         needRestore = mySelector ()->mySsPeMgr ()->restoreNeeded ();
      else
a824 3
      }
   else
      needRestore = witTRUE;
d855 1
a855 2
         {
         if (penExec_)
d857 2
a858 4
            if (mySelector ()->mySsPeMgr ()->fastMode ())
               {
               if (mySelector ()->mySsPeMgr ()->skipCommitItr (fillPart))
                  continue;
d860 1
a860 2
               mySelector ()->mySsPeMgr ()->recCommitItr (fillPart);
               }
a861 9
         else
            if (mySplitter ()->fastMode ())
               {
               if (mySplitter ()->skipCommitItr (fillPart))
                  continue;

               mySplitter ()->recCommitItr (fillPart);
               }
         }
@


1.32
log
@Continued implementation of sel-split for pen-exec.
@
text
@d28 1
d808 1
d813 6
a818 1
      mySplitter ()->preCommit ();
d823 10
a832 1
      mySplitter ()->postCommit ();
d834 3
a853 1
   WitBoolean skipItr;
d865 2
a866 1
         if (mySplitter ()->fastMode ())
d868 4
a871 1
            mySplitter ()->recCommitItr (fillPart, skipItr);
d873 2
a874 2
            if (skipItr)
               continue;
d876 9
@


1.31
log
@Continued implementation of sel-split for pen-exec.
@
text
@d115 5
a119 1
      nBsearches_       (0)
d241 5
a245 1
      myMsgFac ()    ("nBsearchesMsg",  nBsearches_);
a357 1
      {
d360 1
a360 1
      myAvailSched_->netWoSR (topPart (), topPer (), netQty);
d362 1
a363 3
      }
   else
      myAvailSched_->netWoSR (topPart (), topPer (), netQty);
d397 2
d403 3
d635 2
d654 2
d807 2
@


1.30
log
@Continued implementation of sel-split for pen-exec.
@
text
@d1278 8
a1285 9
   if (myCompMgr ()->hasSubEntries ())
      if (theBomEnt->hasSubsInEffect ()[execPer])
         {
         netConsEntries (
            theBomEnt,
            execPer,
            deltaExecVol,
            fillPer,
            theBopEnt);
d1287 3
a1289 3
         if (deltaExecVol < NET_TOL )
            return;
         }
@


1.29
log
@Continued implementation of sel-split for pen-exec.
@
text
@d1269 1
a1269 1
      WitBopEntry * theExpBopEntry)
d1281 6
a1286 1
         netConsEntries (theBomEnt, execPer, deltaExecVol);
d1298 1
a1298 1
         theExpBopEntry);
d1311 1
a1311 1
         theExpBopEntry);
d1322 1
a1322 1
      WitBopEntry * theExpBopEntry)
d1338 1
a1338 1
         theExpBopEntry);
d1348 3
a1350 1
      double &      netExecQty)
d1354 1
a1354 1
   netConsEntry (theBomEnt, netExecQty, execPer);
d1363 1
a1363 1
      netSubEntry (theSub, execPer, netExecQty);
d1375 3
a1377 1
      double &      netExecQty)
d1390 1
a1390 1
   netConsEntry (theSub, netExecQty, execPer);
d1410 1
d1412 2
a1413 1
      WitPeriod      execPer)
d1438 10
d1465 1
a1465 1
      WitBopEntry *  theExpBopEntry)
d1483 1
a1483 1
               theExpBopEntry,
d1486 2
a1487 1
               fillPer);
@


1.28
log
@Fixed a subtle bug in sel-split for stock reallocation.
Continued implementation of sel-split for pen-exec.
@
text
@d1029 1
a1029 1
      mySelector ()->recordShortage (thePart, fillPer);
d1120 3
d1124 1
d1147 1
a1147 1
      mySelector ()->recordExecBoundShortage (theBopEnt, execPer, fillPer);
@


1.27
log
@Refactored build-ahead by demand.
@
text
@d831 3
a833 2
         {
         mySplitter ()->recCommitItr (fillPart, skipItr);
d835 3
a837 3
         if (skipItr)
            continue;
         }
@


1.26
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d261 3
a263 7
   WitPart *  thePart;
   double     demandedIncVol;
   WitBoolean prefBA;
   WitPeriod  firstPer;
   double     incVol;

   thePart = theDemand->demandedPart ();
a285 2
   prefBA = theDemand->prefBuildAhead ();

d291 1
a291 1
   firstPer = max (0, thePer - theDemand->buildAheadUB ()[thePer]);
d293 6
a298 1
   incVol = resAlloc (thePart, thePer, demandedIncVol, firstPer, prefBA);
d497 4
a500 6
double WitHeurAtor::resAlloc (
      WitPart *  thePart,
      WitPeriod  lastPer,
      double     qty,
      WitPeriod  firstPer,
      WitBoolean prefBA)
d502 2
a505 1
   double    netQty;
d507 1
a507 1
   netQty = qty;
d509 3
a511 6
   if (firstPer == lastPer)
      {
      if (netQty > NET_TOL)
         commitMaxQty (thePart, lastPer, netQty);
      }
   else if (prefBA)
d519 2
a522 2
      
         commitMaxQty (thePart, thePer, netQty);
d528 2
a532 2
         commitMaxQty (thePart, thePer, netQty);

a535 2

   return qty - positivePart (netQty);
@


1.25
log
@More improvements to pen-exec.
@
text
@d121 2
a122 2
   myDblArch_ = new WitDblArch (theProblem);
   myPerArch_ = new WitPerArch (theProblem);
a205 4

      if (penExec_)
         if (! myGlobalComp ()->allowSSPE ())
            myMsgFac () ("penExecSelSplitSmsg");
@


1.24
log
@Added allowSSPE dev param.
Switched pen-exec to single-shortage logic.
Made pen-exec exploit sparse penalties.
@
text
@a915 1
   WitBoolean    restExpOK;
d928 3
a932 3
   if (penExec_)
      myExpRest ()->recRestExp (thePart, fillPer, restExpOK);

a951 1
   WitBoolean restExpOK;
d963 1
a963 1
      myExpRest ()->recRestExp (thePart, fillPer, restExpOK);
d1129 2
a1130 3
      if (theOpn->execPenalty () > 0.0)
         if (myExpRest ()->unanReqs (theBopEnt->myPart (), fillPer))
            return witFALSE;
d1132 3
a1134 1
   return innerExplode (theBopEnt, execPer, qty, deltaExecVol, fillPer);
d1163 1
a1163 1
WitBoolean WitHeurAtor::innerExplode (
a1169 1
   WitBoolean     expOK;
a1174 2
   expOK  = witTRUE;

d1193 1
a1193 2
         theBopEnt,
         expOK);
d1196 1
a1196 1
         myExpRest ()->expBomEnt ();
a1205 2

   return expOK;
d1275 1
a1275 2
      WitBopEntry * theExpBopEntry,
      WitBoolean &  expOK)
d1287 1
a1287 1
         netConsEntries (theBomEnt, execPer, deltaExecVol, expOK);
a1290 3

         if (! expOK)
            return;
d1349 1
a1349 2
      double &      netExecQty,
      WitBoolean &  expOK)
d1353 1
a1353 1
   netConsEntry (theBomEnt, netExecQty, execPer, expOK);
a1359 3
   if (! expOK)
      return;

d1362 1
a1362 1
      netSubEntry (theSub, execPer, netExecQty, expOK);
a1365 3

      if (! expOK)
         return;
d1374 1
a1374 2
      double &      netExecQty,
      WitBoolean &  expOK)
d1387 1
a1387 1
   netConsEntry (theSub, netExecQty, execPer, expOK);
d1408 1
a1408 2
      WitPeriod      execPer,
      WitBoolean &   expOK)
d1432 1
a1432 1
         myExpRest ()->recRestNet (consPart, consPer);
@


1.23
log
@Initial implementation of selection splitting for multi-route.
@
text
@d208 2
a209 1
         myMsgFac () ("penExecSelSplitSmsg");
d355 1
d358 1
a358 1
   myAvailSched_->netWoSR (topPart (), topPer (), netQty);
a359 1
   if (penExec_)
d361 3
d860 2
a861 3
         if (! penExec_)
            if (! fillOK)
               return witFALSE;
a864 4
   if (penExec_)
      if (myExpRest ()->curShort ())
         return witFALSE;

d906 1
a906 4
   if (selSplit_)
      return fillNetReqSS  (thePart, fillPer, netReqVol);
   else 
      return fillNetReqNss (thePart, fillPer, netReqVol);
d911 1
a911 1
WitBoolean WitHeurAtor::fillNetReqNss (
d917 1
d923 7
a929 1
   witAssert (! selSplit_);
d934 1
a934 1
   if (! findExpPer (thePart, fillPer, expPer))
d936 3
a938 4
      
   if (penExec_)
      if (! restExpOK)
         return witFALSE;
a947 30
WitBoolean WitHeurAtor::fillNetReqSS (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    netReqVol)
   {
   WitBoolean restExpOK;
   WitPeriod  expPer;

   witAssert (netReqVol > NET_TOL);
   witAssert (selSplit_);

   if (buildAhead_)
      if (myBaMgr ()->selIsSplit (thePart, fillPer))
         return fillNetReqBASS (thePart, fillPer, netReqVol);

   if (penExec_)
      myExpRest ()->recRestExp (thePart, fillPer, restExpOK);

   if (! findExpPer (thePart, fillPer, expPer))
      return witFALSE;
      
   if (penExec_)
      if (! restExpOK)
         return witFALSE;

   return explodePartSS (thePart, expPer, netReqVol, fillPer);
   }

//------------------------------------------------------------------------------

a964 1
      {
a966 4
      if (! restExpOK)
         return witFALSE;
      }

d1130 5
d1191 1
d1200 4
d1452 1
a1452 1
         myExpRest ()->recRestExp (consPart, consPer, expOK);
@


1.22
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d1097 1
a1097 1
      myPmrMgr ()->recBopEntExpPerSS (theBopEnt, expPer, expVol);
d1534 4
a1537 1
         myCmrMgr ()->recExpConsEntSS (theConsEnt, execPer, netExecQty);
@


1.21
log
@Made stock reallocation use ssr vs. usr on a part-by-part basis.
@
text
@d177 1
d180 3
d418 1
a418 1
void WitHeurAtor::resConsStock (WitMaterial * theMat, WitPeriod fromPer)
d420 1
a420 1
   myAvailSched_->resConsStock (theMat, fromPer);
d425 1
a425 1
WitBoolean WitHeurAtor::incAvailPos (WitPart * thePart, WitPeriod thePer)
d427 1
a427 1
   return (myAvailSched_->incAvailVol (thePart, thePer) > NET_TOL);
d1295 1
a1295 1
         mySelector ()->rollReq (theMat, thePer, rollPer);
@


1.20
log
@Changed selStockRe attribute to stockReallocation (fullSR, internally).
@
text
@a104 1
      fullSR_           (witFALSE),
d119 1
d147 1
a147 1
   fullSR_    = myGlobalComp ()->fullSR ();
d149 9
a157 1
   if (multiRoute_ || buildAhead_ || multiExec_ || fullSR_)
d176 1
a176 1
   if (fullSR_)
a187 3
   if (pureUncondSR ())
      myMsgFac () ("pureUncondSRMsg");

d428 7
d884 1
a884 1
   else if (pureUncondSR () || fullSR_)
d886 4
d1278 3
a1280 1
   witAssert (pureUncondSR () || fullSR_);
@


1.19
log
@Replaced uncondStockRe attribute with the old stockRealloc attribute.
@
text
@d105 1
a105 1
      selStockRe_       (witFALSE),
d145 1
a145 1
   multiExec_  = myGlobalComp ()->multiExecNeeded ();
d147 1
a147 1
   selStockRe_ = myGlobalComp ()->selStockRe ();
d149 1
a149 1
   if (multiRoute_ || buildAhead_ || multiExec_ || selStockRe_)
d168 2
a169 2
   if (selStockRe_)
      mySsrMgr_    = mySelector ()->mySsrMgr ();
d872 1
a872 1
   else if (pureUncondSR () || selStockRe_)
d1262 1
a1262 1
   witAssert (pureUncondSR () || selStockRe_);
@


1.18
log
@Renamed mandatory stock reallocation to unconditional stock reallocation.
@
text
@d180 2
a181 2
   if (uncondStockRe ())
      myMsgFac () ("uncondStockReMsg");
d872 1
a872 1
   else if (uncondStockRe () || selStockRe_)
d1262 1
a1262 1
   witAssert (uncondStockRe () || selStockRe_);
@


1.17
log
@Continued development of Selective Stock Reallocation.
@
text
@d180 2
a181 2
   if (mandStockRe ())
      myMsgFac () ("mandStockReMsg");
d872 1
a872 1
   else if (mandStockRe () || selStockRe_)
d1262 1
a1262 1
   witAssert (mandStockRe () || selStockRe_);
@


1.16
log
@Continued implementation of selective stock reallocation.
@
text
@d536 3
a538 1
   if (thePart->getMyMaterial (theMat))
d860 2
a861 1
   double netReqVol;
d867 7
a873 2
   if (mandStockRe () || selStockRe_)
      netAndRollReq                (thePart, fillPer, netReqVol);
d875 1
a875 1
      myAvailSched_->netWoSRAndRes (thePart, fillPer, netReqVol);
d1255 3
a1257 3
      WitPart * thePart,
      WitPeriod thePer,
      double &  netReqVol)
d1259 2
a1260 3
   WitPeriod     rollPer;
   double        rollVol;
   WitMaterial * theMat;
d1264 1
a1264 1
   rollPer = myAvailSched_->netAndRoll (thePart, thePer, netReqVol, rollVol);
d1269 1
a1269 1
   myReqSched_->addTo (thePart, rollPer, rollVol);
a1272 5
         {
         thePart->getMyMaterial (theMat);

         witAssert (theMat != NULL);

a1273 1
         }
@


1.15
log
@Continued implementation of selective stock reallocation.
@
text
@d409 14
d536 1
a536 1
   if (thePart->isaMaterial (theMat))
d1251 3
a1253 2
   WitPeriod rollPer;
   double    rollVol;
d1266 7
a1272 1
         mySelector ()->rollReq (thePart, thePer, rollPer);
@


1.14
log
@Tightly integrated stock reallocation and stock non-reallocation in preparation
for selective stock reallocation.
@
text
@d26 1
d98 1
d147 1
a147 1
   selStockRe_ = myGlobalComp ()->selStockRealloc ();
d168 3
d180 2
a181 2
   if (stockRealloc ())
      myMsgFac () ("stockReallocMsg");
d347 1
a347 1
   myAvailSched_->net (topPart (), topPer (), netQty);
d850 2
a851 2
   if (stockRealloc ())
      netAndRollReq                  (thePart, fillPer, netReqVol);
d853 1
a853 1
      myAvailSched_->netWithPrealloc (thePart, fillPer, netReqVol);
d1187 5
a1191 8
   if (stockRealloc ())
      myAvailSched_->addToIncAvailVol (theBopEnt->myPart (), fillPer, - qty);
   else
      myAvailSched_->allocWithRes (
         theBopEnt->myPart (),
         theBopEnt->impactPeriod ()[execPer],
         fillPer, 
         qty);
d1240 1
a1240 1
   witAssert (stockRealloc ());
d1424 1
a1424 1
      myAvailSched_->net (consPart, consPer, netConsQty);
@


1.13
log
@Continuing implementation of selective stock reallocation.
@
text
@d342 1
a342 1
   myAvailSched_->netWithPreAll (topPart (), topPer (), netQty);
d399 1
a399 1
   myAvailSched_->addToIncAvail (topPart (), topPer (), 1.0);
d520 3
a522 1
            enforceStockSLB (theMat, thePer);
d529 1
a529 3
   double slb;
   double availVol;
   double violVol;
d531 1
d533 1
a533 2
   if (theMat->mandEC ()[thePer])
      return;
d535 1
a535 1
   slb = theMat->stockBounds ()->softLB ()[thePer];
d537 1
a537 1
   if (slb < NET_TOL)
d540 1
a540 1
   availVol = myAvailSched_->availToNet (theMat, thePer, slb);
d542 1
a542 2
   myAvailSched_->addToIncAvail     (theMat, thePer, - availVol);
   myAvailSched_->addToNextIncAvail (theMat, thePer,   availVol);
d544 1
a544 1
   violVol = slb - availVol;
d546 1
a546 1
   if (violVol < NET_TOL)
d549 2
a550 7
   myAvailSched_->addToNextIncAvail (theMat, thePer, violVol);

   netVol = violVol;

   commitMaxQty (theMat, thePer, netVol);

   myAvailSched_->addToNextIncAvail (theMat, thePer, - netVol);
d846 3
a848 3
      netAndRollReq (thePart, fillPer, netReqVol);
   else
      myAvailSched_->netWithPreAll (thePart, fillPer, netReqVol);
a1154 4
   WitBopEntry *  prodBopEnt;
   double         deltaProdVol;
   WitPart *      prodPart;
   WitPeriod      prodPer;
d1180 29
d1219 1
a1219 1
      myAvailSched_->addToIncAvail (prodPart, prodPer, deltaProdVol);
d1224 1
a1224 3
               myExpRest ()->reqPsSupRep (
                  prodBopEnt->myPart (),
                  prodBopEnt->impactPeriod ()[execPer]);
a1225 4

   myAvailSched_->addToIncAvail (theBopEnt->myPart (), fillPer, - qty);

   return expOK;
d1422 1
a1422 1
      myAvailSched_->netWithPreAll (consPart, consPer, netConsQty);
d1434 1
a1434 1
         myAvailSched_->addToIncAvail (consPart, consPer, - reqConsQty);
d1472 1
a1472 1
      myAvailSched_->addToIncAvail (consPart, consPer, - consumedQty);
@


1.12
log
@Fixed a latent bug.
@
text
@d103 1
d133 1
a133 3
   multiRoute_  = myGlobalComp ()->multiRoute ();

   multiExec_   = myGlobalComp ()->multiExecNeeded ();
d143 5
a147 1
   if (multiRoute_ || buildAhead_ || multiExec_)
@


1.11
log
@Refactoring for constrained stock reallocation.
@
text
@a110 1
      committing_       (witFALSE),
a766 4
   witAssert (! committing_);

   committing_ = witTRUE;

d770 1
a770 1
   success     = innerCommit (qty);
d772 3
a774 1
   if (! (selSplit_ && mySplitter ()->skipRestore ()))
a782 2
   committing_ = witFALSE;

d792 1
d804 4
a807 1
         if (mySplitter ()->skipCommitItr (fillPart))
d809 1
@


1.10
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d772 3
@


1.9
log
@Created and used Archive template.
@
text
@d21 1
d30 1
d86 2
d92 1
d114 1
a114 2
      nBsearches_       (0),
      execVolArch_      (theProblem)
d119 3
d128 1
a128 1
   myReqSched_   = new WitReqSched (this);
d189 2
d234 2
a383 4
   execVolArch_.restoreAllVals ();

   myAvailSched_->restore ();

d510 49
d774 5
a778 1
   myReqSched_->clear ();
d803 5
d823 1
d1167 1
a1167 1
      execVolArch_.saveVal (execVol (theOpn).elemRef (execPer));
a1469 49
   }

//------------------------------------------------------------------------------

void WitHeurAtor::enforceStockSLBs (WitPart * thePart)
   {
   WitMaterial * theMat;
   WitPeriod     thePer;

   if (thePart->isaMaterial (theMat))
      if (! (theMat->stockBounds ()->softLB () == 0.0))
         forEachPeriod (thePer, myProblem ())
            enforceStockSLB (theMat, thePer);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::enforceStockSLB (WitMaterial * theMat, WitPeriod thePer)
   {
   double slb;
   double availVol;
   double violVol;
   double netVol;

   if (theMat->mandEC ()[thePer])
      return;

   slb = theMat->stockBounds ()->softLB ()[thePer];

   if (slb < NET_TOL)
      return;

   availVol = myAvailSched_->availToNet (theMat, thePer, slb);

   myAvailSched_->addToIncAvail     (theMat, thePer, - availVol);
   myAvailSched_->addToNextIncAvail (theMat, thePer,   availVol);

   violVol = slb - availVol;

   if (violVol < NET_TOL)
      return;

   myAvailSched_->addToNextIncAvail (theMat, thePer, violVol);

   netVol = violVol;

   commitMaxQty (theMat, thePer, netVol);

   myAvailSched_->addToNextIncAvail (theMat, thePer, - netVol);
@


1.8
log
@Minor change.
@
text
@a18 1
#include <AllMode.h>
a72 7

inline WitAvailSched * WitHeurAtor::curAvailSched ()
   {
   return myAllocMode_->curAvailSched ();
   }

//------------------------------------------------------------------------------
d84 1
a84 1
      myAllocMode_      (NULL),
d102 1
d109 2
a110 1
      nBsearches_       (0)
d119 1
a119 1
   myAllocMode_ = new WitAllocMode (this, myAccFlag_);
d121 1
a121 1
   myReqSched_  = new WitReqSched (this);
d224 1
a224 1
   delete myAllocMode_;
d329 1
a329 1
   curAvailSched ()->netWithPreAll (topPart (), topPer (), netQty);
d364 3
a366 1
   myAllocMode_->enterTempMode ();
d368 1
a368 1
   success = commit (qty);
d373 5
a377 1
   myAllocMode_->leaveTempMode ();
d390 1
a390 1
   curAvailSched ()->addToIncAvail (topPart (), topPer (), 1.0);
d541 1
a541 1
   witAssert (myAllocMode_->perm ());
d637 1
a637 1
   if (myAllocMode_->curExecVol (theOpn, execPer) > FLOAT_EPSILON)
d718 2
d740 1
a740 1
   myReqSched_->init (qty);
d782 1
a782 1
      curAvailSched ()->netWithPreAll (thePart, fillPer, netReqVol);
d1033 1
a1033 1
   oldExecVol   = myAllocMode_->curExecVol (theOpn, execPer);
d1100 4
a1103 1
   myAllocMode_->incExecVol (theOpn, execPer, deltaExecVol);
d1106 1
a1106 1
      if (myAllocMode_->perm ())
d1128 1
a1128 1
      curAvailSched ()->addToIncAvail (prodPart, prodPer, deltaProdVol);
d1132 1
a1132 1
            if (myAllocMode_->perm ())
d1138 1
a1138 1
   curAvailSched ()->addToIncAvail (theBopEnt->myPart (), fillPer, - qty);
d1155 1
a1155 1
   rollPer = curAvailSched ()->netAndRoll (thePart, thePer, netReqVol, rollVol);
d1163 1
a1163 1
      if (myAllocMode_->temp ())
d1300 1
a1300 1
   if (myAllocMode_->perm ())
d1337 1
a1337 1
      curAvailSched ()->netWithPreAll (consPart, consPer, netConsQty);
d1349 1
a1349 1
         curAvailSched ()->addToIncAvail (consPart, consPer, - reqConsQty);
d1378 1
a1378 1
         if (myAllocMode_->temp ())
d1387 1
a1387 1
      curAvailSched ()->addToIncAvail (consPart, consPer, - consumedQty);
d1391 1
a1391 1
         if (myAllocMode_->perm ())
d1436 1
a1436 1
   availVol = curAvailSched ()->availToNet (theMat, thePer, slb);
d1438 2
a1439 2
   curAvailSched ()->addToIncAvail     (theMat, thePer, - availVol);
   curAvailSched ()->addToNextIncAvail (theMat, thePer,   availVol);
d1446 1
a1446 1
   curAvailSched ()->addToNextIncAvail (theMat, thePer, violVol);
d1452 1
a1452 1
   curAvailSched ()->addToNextIncAvail (theMat, thePer, - netVol);
@


1.7
log
@Continued implementation of pegging.
@
text
@d108 1
a108 1
      peggingNeeded_    (witFALSE),
d196 1
a196 1
      if (myGlobalComp ()->peggingNeeded ())
d200 1
a200 1
         peggingNeeded_ = witTRUE;
d202 1
a202 1
         myPegMgr_      = thePegMgr;
d224 1
a224 1
   if (peggingNeeded_)
d269 1
a269 1
   if (peggingNeeded_)
d289 1
a289 1
   if (peggingNeeded_)
d1100 1
a1100 1
   if (peggingNeeded_)
d1303 1
a1303 1
         if (peggingNeeded_)
d1392 1
a1392 1
            if (peggingNeeded_)
@


1.6
log
@Minor changes.
@
text
@d108 1
a108 1
      pegging_          (witFALSE),
d196 1
a196 1
      if (myGlobalComp ()->pegging ())
d200 1
a200 1
         pegging_  = witTRUE;
d202 1
a202 1
         myPegMgr_ = thePegMgr;
d224 1
a224 1
   if (pegging_)
d269 1
a269 1
   if (pegging_)
d289 1
a289 1
   if (pegging_)
d1100 1
a1100 1
   if (pegging_)
d1303 1
a1303 1
         if (pegging_)
d1392 1
a1392 1
            if (pegging_)
@


1.5
log
@Continued implementation of pegging.
@
text
@d1299 3
a1301 1
      subVol (theSub).elemRef (execPer) += deltaVol;
d1303 3
a1305 2
      if (pegging_)
         myPegMgr_->pegDeltaVol (theSub, execPer, deltaVol);
@


1.4
log
@Continued implementation of pegging.
@
text
@d28 1
a28 1
#include <Pegger.h>
d87 1
d101 1
a101 2
      myOpnPegger_      (NULL),
      mySubPegger_      (NULL),
d198 1
a198 1
         pegging_     = witTRUE;
d200 1
a200 2
         myOpnPegger_ = new WitPegger <WitOperation> (myProblem ());
         mySubPegger_ = new WitPegger <WitSubEntry>  (myProblem ());
d202 3
a204 1
         myMsgFac () ("peggingMsg");
d224 3
a226 2
   delete mySubPegger_;
   delete myOpnPegger_;
d270 1
a270 4
      {
      theDemand->myOpnPegSite ()->setUpPeggedIncAlloc (thePer);
      theDemand->mySubPegSite ()->setUpPeggedIncAlloc (thePer);
      }
d290 1
a290 4
      {
      mySubPegger_->shutDownPeggedIncAlloc ();
      myOpnPegger_->shutDownPeggedIncAlloc ();
      }
a304 18
void WitHeurAtor::setUpPeggedIncAlloc (WitObjStack <WitOpnPegEl> & thePegEls)
   {
   witAssert (pegging_);

   myOpnPegger_->setUpPeggedIncAlloc (thePegEls);
   }

//------------------------------------------------------------------------------

void WitHeurAtor::setUpPeggedIncAlloc (WitObjStack <WitSubPegEl> & thePegEls)
   {
   witAssert (pegging_);

   mySubPegger_->setUpPeggedIncAlloc (thePegEls);
   }

//------------------------------------------------------------------------------

d1102 1
a1102 1
         myOpnPegger_->pegDeltaVol (theOpn, execPer, deltaExecVol);
d1302 1
a1302 1
         mySubPegger_->pegDeltaVol (theSub, execPer, deltaVol);
d1390 1
a1390 1
               mySubPegger_->pegDeltaVol (theSub, execPer, netExecQty);
@


1.3
log
@Continued implementation of pegging.
@
text
@d108 1
a108 1
      perfPegging_      (witFALSE),
d196 1
a196 1
      if (myGlobalComp ()->perfPegging ())
d198 1
a198 1
         perfPegging_ = witTRUE;
d267 1
a267 1
   if (perfPegging_)
d290 1
a290 1
   if (perfPegging_)
d311 1
a311 1
   witAssert (perfPegging_);
d320 1
a320 1
   witAssert (perfPegging_);
d1122 1
a1122 1
   if (perfPegging_)
d1323 1
a1323 1
      if (perfPegging_)
d1411 1
a1411 1
            if (perfPegging_)
@


1.2
log
@Continued implementation of pegging.
@
text
@d108 1
a108 1
      doPegging_        (witFALSE),
d196 1
a196 1
      if (myGlobalComp ()->doPegging ())
d198 1
a198 1
         doPegging_   = witTRUE;
d202 2
d267 1
a267 1
   if (doPegging_)
d290 1
a290 1
   if (doPegging_)
d311 1
a311 1
   witAssert (doPegging_);
d320 1
a320 1
   witAssert (doPegging_);
d1122 1
a1122 1
   if (doPegging_)
d1323 1
a1323 1
      if (doPegging_)
d1411 1
a1411 1
            if (doPegging_)
@


1.1
log
@Initial implementation of pegging.
@
text
@d100 2
a101 1
      myPegger_         (NULL),
d198 1
a198 1
         doPegging_  = witTRUE;
d200 2
a201 1
         myPegger_   = new WitPegger (myProblem ());
d221 2
a222 1
   delete myPegger_;
d266 4
a269 1
      theDemand->myPegSite ()->startIncHeurAlloc (thePer);
d289 4
a292 1
      myPegger_->finishIncHeurAlloc ();
d307 18
d1122 1
a1122 1
         myPegger_->recIncExecVol (theOpn, execPer, deltaExecVol);
d1303 1
d1316 8
a1323 2
      subVol (theSub).elemRef (execPer) += 
         positivePart (oldExecQty - netExecQty);
d1376 4
a1379 3
   WitPeriod consPer;
   double    consumedQty;
   WitPart * consPart;
d1404 8
a1411 1
            subVol (theConsEnt->asaSubEntry ()).elemRef (execPer) += netExecQty;
@


head	1.38;
access;
symbols
	sce_5_01_20080919:1.34
	latest_sce_4_20_20060523:1.32.0.2
	sce_4_20_20060523:1.32
	latest_sce4_20_OSL:1.31.0.2
	sce_4_20_OSL:1.31
	sce_410_withVa:1.28
	sce_4_05_20040511:1.27
	sce_4_00_20040201:1.27
	nextGenBranch:1.21.0.2
	nextGenRoot:1.21
	sce_3_30_20030627:1.21
	EndRw-branch:1.16.0.2
	Root-of-EndRw:1.16
	rwToStl:1.15.0.2
	latest_sce_3_10_20010924:1.9.0.2
	sce_3_10_20010924:1.9;
locks; strict;
comment	@ * @;


1.38
date	2011.09.28.23.49.52;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2011.09.24.00.28.13;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2011.08.30.20.17.53;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.10.22.10.40;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.12.20.27.37;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.28.20.04.58;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.02.17.34.07;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.03.16.48.12;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.05.22.24.09;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.30.22.50.00;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.28.20.14.36;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.24.20.12.34;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.11.18.29.14;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.01.15.59.26;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.26.16.06.04;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.25.20.44.43;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.22.23.13.52;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.19.16.48.23;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.27.23.26.13;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.02.23.40.47;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.17.21.32.50;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.05.19.32.53;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.15.20.27.12;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.04.19.14.57;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.12.23.36.14;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.12.20.09.39;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.11.22.48.30;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.14.02.40;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.12.21.02.02;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.21.22.36.31;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.21.17.31.46;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.03.23.37.56;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.22.02.27;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.17.55.08;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.01.14.55.31;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.28.00.48.35;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.27.21.28.40;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.25.16.08.18;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Pegging.C"
//
// Contains the implementation of the following classes:
//
//    Pegger
//    PegEl
//    FixedPegEl
//------------------------------------------------------------------------------

#include <Pegger.h>
#include <PegEl.h>
#include <HeurAllMgr.h>
#include <CompMgr.h>
#include <Demand.h>
#include <Part.h>
#include <Operation.h>
#include <SubEntry.h>
#include <HeurAtor.h>
#include <Selector.h>
#include <SglSrcMgr.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class Pegger.
//------------------------------------------------------------------------------

WitPegger::WitPegger (WitProblem * theProblem):
      WitProbAssoc     (theProblem),

      myHeurAtor_      (NULL),
      curDemand_       (NULL),
      curShipPer_      (-1),
      myPegElStack_    (theProblem),
      curOpnPegEls_    (),
      curSubPegEls_    (),
      nonEmptyDemPers_ (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitPegger::~WitPegger ()
   {
   clear ();
   }

//------------------------------------------------------------------------------

void WitPegger::setUpPeggedHeurAlloc (WitHeurAtor * theHeurAtor)
   {
   WitDemand * theDemand;

   witAssert (myHeurAtor_ == NULL);
   witAssert (curDemand_  == NULL);

   clear ();

   myHeurAtor_ = theHeurAtor;

   curOpnPegEls_.allocate (myProblem ());
   curSubPegEls_.allocate (myProblem ());

   myMsgFac () ("concPeggingMsg");
   }

//------------------------------------------------------------------------------

void WitPegger::setUpPeggedIncAlloc (WitDemand * theDemand, WitPeriod shipPer)
   {
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;

   witAssert (myHeurAtor_ != NULL);
   witAssert (curDemand_  == NULL);

   curDemand_  = theDemand;
   curShipPer_ = shipPer;

   curDemand_->extractPegEls (curShipPer_, myPegElStack_);

   myPegElStack_.attachItr (theItr);

   while (theItr.advance (thePegEl))
      curPegElsPtrFor (thePegEl) = thePegEl;
   }

//------------------------------------------------------------------------------

void WitPegger::pegDeltaVol (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         deltaVol)
   {
   WitPegEl * thePegEl;

   if (curDemand_ == NULL)
      return;

   thePegEl = curOpnPegEls_.myPtrAt (theOpn, execPer);
   
   pegDeltaVol (theOpn, execPer, thePegEl, deltaVol);
   }

//------------------------------------------------------------------------------

void WitPegger::pegDeltaVol (
      WitSubEntry * theSub,
      WitPeriod     execPer,
      double        deltaVol)
   {
   WitPegEl * thePegEl;

   if (curDemand_ == NULL)
      return;

   thePegEl = curSubPegEls_.myPtrAt (theSub, execPer);
   
   pegDeltaVol (theSub, execPer, thePegEl, deltaVol);
   }

//------------------------------------------------------------------------------

void WitPegger::shutDownPeggedIncAlloc ()
   {
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;

   witAssert (myHeurAtor_ != NULL);
   witAssert (curDemand_  != NULL);

   myPegElStack_.attachItr (theItr);

   while (theItr.advance (thePegEl))
      curPegElsPtrFor (thePegEl) = NULL;

   if (myHeurAtor_->multiSel ())
      if (myHeurAtor_->mySelector ()->sglSrc ())
         deleteZeroPegEls ();

   curDemand_->receivePegEls (curShipPer_, myPegElStack_);

   curDemand_  = NULL;
   curShipPer_ = -1;
   }

//------------------------------------------------------------------------------

void WitPegger::shutDownPeggedHeurAlloc ()
   {
   witAssert (myHeurAtor_ != NULL);
   witAssert (curDemand_  == NULL);

   curSubPegEls_.clear ();
   curOpnPegEls_.clear ();

   myHeurAtor_ = NULL;
   }

//------------------------------------------------------------------------------

void WitPegger::clear ()
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;

   while (nonEmptyDemPers_.pop (theDemand, shipPer))
      theDemand->clearPegging (shipPer);
   }

//------------------------------------------------------------------------------

void WitPegger::print ()
   {
   WitDemand *                 theDemand;
   WitPeriod                   shipPer;
   WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());

   fprintf (myProblem ()->solnFile (),
      "\n\n"
      "Concurrent Pegging:\n");

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theDemand->getMyFixedPegEls (shipPer, theFixedPegEls);

         if (theFixedPegEls.isEmpty ())
            continue;

         fprintf (myProblem ()->solnFile (),
            "\n\n"
            "Part %s, Demand %s, Ship Per %d:\n",
            theDemand->demandedPartName ().myCstring (),
            theDemand->demandName ().myCstring (),
            shipPer);

         printOpnPegEls (theFixedPegEls);
         printSubPegEls (theFixedPegEls);
         }

   fprintf (myProblem ()->solnFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitPegger::pegDeltaVol (
      WitDelComp * theDelComp,
      WitPeriod    execPer,
      WitPegEl *   thePegEl,
      double       deltaVol)
   {
   witAssert (curDemand_ != NULL);

   witAssert (deltaVol >= NET_TOL);

   if (thePegEl == NULL)
      {
      thePegEl = new WitPegEl (theDelComp, execPer);

      if (myPegElStack_.isEmpty ())
         nonEmptyDemPers_.push (curDemand_, curShipPer_);

      myPegElStack_.push (thePegEl);

      curPegElsPtrFor (thePegEl) = thePegEl;
      }

   if (myHeurAtor_->multiSel ())
      if (myHeurAtor_->mySelector ()->sglSrc ())
         thePegEl->saveStateIn (myHeurAtor_->mySelector ()->mySglSrcMgr ());

   thePegEl->pegDeltaVol (deltaVol);
   }

//------------------------------------------------------------------------------

void WitPegger::deleteZeroPegEls ()
   {
   WitObjStack <WitPegEl> tempPegElStack (myProblem ());
   WitPegEl *             thePegEl;

   while (myPegElStack_.pop (thePegEl))
      if (thePegEl->peggedVol () == 0.0)
         delete thePegEl;
      else
         tempPegElStack.push (thePegEl);

   myPegElStack_.revCopyFrom (tempPegElStack);
   }

//------------------------------------------------------------------------------

void WitPegger::printOpnPegEls (
      const WitObjStack <WitFixedPegEl> & theFixedPegEls)
   {
   WitObjStItr <WitFixedPegEl> theItr;
   WitFixedPegEl *             theFixedPegEl;
   WitOperation *              theOpn;

   fprintf (myProblem ()->solnFile (), "\n   Opn  Per   ExecVol\n");

   theFixedPegEls.attachItr (theItr);

   while (theItr.advance (theFixedPegEl))
      {
      theOpn = theFixedPegEl->myOpn ();

      if (theOpn != NULL)
         fprintf (myProblem ()->solnFile (),
            "   %-3s  %-3d %9.3f\n",
            theOpn  ->operationName ().myCstring (),
            theFixedPegEl->myExecPer (),
            theFixedPegEl->peggedVol ());
      }
   }

//------------------------------------------------------------------------------

void WitPegger::printSubPegEls (
      const WitObjStack <WitFixedPegEl> & theFixedPegEls)
   {
   WitObjStItr <WitFixedPegEl> theItr;
   WitFixedPegEl *             theFixedPegEl;
   WitSubEntry *               theSub;

   fprintf (
      myProblem ()->solnFile (), 
      "\n   Opn  B-E  Sub  Part  Per   ExecVol\n");

   theFixedPegEls.attachItr (theItr);

   while (theItr.advance (theFixedPegEl))
      {
      theSub = theFixedPegEl->mySub ();

      if (theSub != NULL)
         fprintf (myProblem ()->solnFile (),
            "   %-3s  %-3d  %-3d  %-4s  %-3d %9.3f\n",
            theSub  ->myOperationName ().myCstring (),
            theSub  ->myBomEntIndex (),
            theSub  ->localIndex (),
            theSub  ->myPart ()->partName ().myCstring (),
            theFixedPegEl->myExecPer (),
            theFixedPegEl->peggedVol ());
      }
   }

//------------------------------------------------------------------------------

WitPegEl * & WitPegger::curPegElsPtrFor (WitPegEl * thePegEl)
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   theOpn = thePegEl->myOpn ();

   if (theOpn != NULL)
      return curOpnPegEls_.myPtrAt (theOpn, thePegEl->myExecPer ());

   theSub = thePegEl->mySub ();

   witAssert (theSub != NULL);

   return    curSubPegEls_.myPtrAt (theSub, thePegEl->myExecPer ());
   }

//------------------------------------------------------------------------------
// Implementation of class PegEl.
//------------------------------------------------------------------------------

WitPegEl::WitPegEl (WitDelComp * theDelComp, WitPeriod execPer):
      myDelComp_    (theDelComp),
      myExecPer_    (execPer),
      peggedVol_    (0.0),
      myFixedPegEl_ (NULL)
   {
   witAssert ((myOpn () != NULL) or (mySub () != NULL));

   myFixedPegEl_ = new WitFixedPegEl (this);
   }

//------------------------------------------------------------------------------

WitPegEl::~WitPegEl ()
   {
   delete myFixedPegEl_;
   }

//------------------------------------------------------------------------------

void WitPegEl::saveStateIn (WitSglSrcMgr * theSglSrcMgr)
   {
   theSglSrcMgr->saveAllocVal (peggedVol_);
   }

//------------------------------------------------------------------------------

void WitPegEl::pegDeltaVol (double deltaVol)
   {
   peggedVol_ += deltaVol;
   }

//------------------------------------------------------------------------------

WitOperation * WitPegEl::myOpn () const
   {
   return myDelComp_->thisOpn ();
   }

//------------------------------------------------------------------------------

WitSubEntry * WitPegEl::mySub () const
   {
   return myDelComp_->thisSub ();
   }

//------------------------------------------------------------------------------
// Implementation of class FixedPegEl.
//------------------------------------------------------------------------------

WitFixedPegEl::WitFixedPegEl (WitPegEl * thePegEl):
      myPegEl_ (thePegEl)
   {
   }

//------------------------------------------------------------------------------

WitFixedPegEl::~WitFixedPegEl ()
   {
   }

@


1.37
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.36
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d38 1
a38 1
WitProbAssoc     (theProblem),
d40 9
a48 9
myHeurAtor_      (NULL),
curDemand_       (NULL),
curShipPer_      (-1),
myPegElStack_    (theProblem),
curOpnPegEls_    (),
curSubPegEls_    (),
nonEmptyDemPers_ (theProblem)
{
}
d53 3
a55 3
{
clear ();
}
d60 2
a61 2
{
WitDemand * theDemand;
d63 2
a64 2
witAssert (myHeurAtor_ == NULL);
witAssert (curDemand_  == NULL);
d66 1
a66 1
clear ();
d68 1
a68 1
myHeurAtor_ = theHeurAtor;
d70 2
a71 2
curOpnPegEls_.allocate (myProblem ());
curSubPegEls_.allocate (myProblem ());
d73 2
a74 2
myMsgFac () ("concPeggingMsg");
}
d79 3
a81 3
{
WitObjStItr <WitPegEl> theItr;
WitPegEl *             thePegEl;
d83 2
a84 2
witAssert (myHeurAtor_ != NULL);
witAssert (curDemand_  == NULL);
d86 2
a87 2
curDemand_  = theDemand;
curShipPer_ = shipPer;
d89 1
a89 1
curDemand_->extractPegEls (curShipPer_, myPegElStack_);
d91 1
a91 1
myPegElStack_.attachItr (theItr);
d93 3
a95 3
while (theItr.advance (thePegEl))
curPegElsPtrFor (thePegEl) = thePegEl;
}
d100 13
a112 13
WitOperation * theOpn,
WitPeriod      execPer,
double         deltaVol)
{
WitPegEl * thePegEl;

if (curDemand_ == NULL)
return;

thePegEl = curOpnPegEls_.myPtrAt (theOpn, execPer);

pegDeltaVol (theOpn, execPer, thePegEl, deltaVol);
}
d117 13
a129 13
WitSubEntry * theSub,
WitPeriod     execPer,
double        deltaVol)
{
WitPegEl * thePegEl;

if (curDemand_ == NULL)
return;

thePegEl = curSubPegEls_.myPtrAt (theSub, execPer);

pegDeltaVol (theSub, execPer, thePegEl, deltaVol);
}
d134 3
a136 3
{
WitObjStItr <WitPegEl> theItr;
WitPegEl *             thePegEl;
d138 2
a139 2
witAssert (myHeurAtor_ != NULL);
witAssert (curDemand_  != NULL);
d141 1
a141 1
myPegElStack_.attachItr (theItr);
d143 2
a144 2
while (theItr.advance (thePegEl))
curPegElsPtrFor (thePegEl) = NULL;
d146 3
a148 3
if (myHeurAtor_->multiSel ())
if (myHeurAtor_->mySelector ()->sglSrc ())
deleteZeroPegEls ();
d150 1
a150 1
curDemand_->receivePegEls (curShipPer_, myPegElStack_);
d152 3
a154 3
curDemand_  = NULL;
curShipPer_ = -1;
}
d159 3
a161 3
{
witAssert (myHeurAtor_ != NULL);
witAssert (curDemand_  == NULL);
d163 2
a164 2
curSubPegEls_.clear ();
curOpnPegEls_.clear ();
d166 2
a167 2
myHeurAtor_ = NULL;
}
d172 7
a178 7
{
WitDemand * theDemand;
WitPeriod   shipPer;

while (nonEmptyDemPers_.pop (theDemand, shipPer))
theDemand->clearPegging (shipPer);
}
d183 27
a209 27
{
WitDemand *                 theDemand;
WitPeriod                   shipPer;
WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());

fprintf (myProblem ()->solnFile (),
"\n\n"
"Concurrent Pegging:\n");

forEachDemand (theDemand, myProblem ())
forEachPeriod (shipPer, myProblem ())
{
theDemand->getMyFixedPegEls (shipPer, theFixedPegEls);

if (theFixedPegEls.isEmpty ())
continue;

fprintf (myProblem ()->solnFile (),
"\n\n"
"Part %s, Demand %s, Ship Per %d:\n",
theDemand->demandedPartName ().myCstring (),
theDemand->demandName ().myCstring (),
shipPer);

printOpnPegEls (theFixedPegEls);
printSubPegEls (theFixedPegEls);
}
d211 2
a212 2
fprintf (myProblem ()->solnFile (), "\n");
}
d217 6
a222 6
WitDelComp * theDelComp,
WitPeriod    execPer,
WitPegEl *   thePegEl,
double       deltaVol)
{
witAssert (curDemand_ != NULL);
d224 1
a224 1
witAssert (deltaVol >= NET_TOL);
d226 3
a228 3
if (thePegEl == NULL)
{
thePegEl = new WitPegEl (theDelComp, execPer);
d230 2
a231 2
if (myPegElStack_.isEmpty ())
nonEmptyDemPers_.push (curDemand_, curShipPer_);
d233 1
a233 1
myPegElStack_.push (thePegEl);
d235 2
a236 2
curPegElsPtrFor (thePegEl) = thePegEl;
}
d238 3
a240 3
if (myHeurAtor_->multiSel ())
if (myHeurAtor_->mySelector ()->sglSrc ())
thePegEl->saveStateIn (myHeurAtor_->mySelector ()->mySglSrcMgr ());
d242 2
a243 2
thePegEl->pegDeltaVol (deltaVol);
}
d248 9
a256 9
{
WitObjStack <WitPegEl> tempPegElStack (myProblem ());
WitPegEl *             thePegEl;

while (myPegElStack_.pop (thePegEl))
if (thePegEl->peggedVol () == 0.0)
delete thePegEl;
else
tempPegElStack.push (thePegEl);
d258 2
a259 2
myPegElStack_.revCopyFrom (tempPegElStack);
}
d264 22
a285 22
const WitObjStack <WitFixedPegEl> & theFixedPegEls)
{
WitObjStItr <WitFixedPegEl> theItr;
WitFixedPegEl *             theFixedPegEl;
WitOperation *              theOpn;

fprintf (myProblem ()->solnFile (), "\n   Opn  Per   ExecVol\n");

theFixedPegEls.attachItr (theItr);

while (theItr.advance (theFixedPegEl))
{
theOpn = theFixedPegEl->myOpn ();

if (theOpn != NULL)
fprintf (myProblem ()->solnFile (),
"   %-3s  %-3d %9.3f\n",
theOpn  ->operationName ().myCstring (),
theFixedPegEl->myExecPer (),
theFixedPegEl->peggedVol ());
}
}
d290 27
a316 27
const WitObjStack <WitFixedPegEl> & theFixedPegEls)
{
WitObjStItr <WitFixedPegEl> theItr;
WitFixedPegEl *             theFixedPegEl;
WitSubEntry *               theSub;

fprintf (
myProblem ()->solnFile (),
"\n   Opn  B-E  Sub  Part  Per   ExecVol\n");

theFixedPegEls.attachItr (theItr);

while (theItr.advance (theFixedPegEl))
{
theSub = theFixedPegEl->mySub ();

if (theSub != NULL)
fprintf (myProblem ()->solnFile (),
"   %-3s  %-3d  %-3d  %-4s  %-3d %9.3f\n",
theSub  ->myOperationName ().myCstring (),
theSub  ->myBomEntIndex (),
theSub  ->localIndex (),
theSub  ->myPart ()->partName ().myCstring (),
theFixedPegEl->myExecPer (),
theFixedPegEl->peggedVol ());
}
}
d321 3
a323 3
{
WitOperation * theOpn;
WitSubEntry *  theSub;
d325 1
a325 1
theOpn = thePegEl->myOpn ();
d327 2
a328 2
if (theOpn != NULL)
return curOpnPegEls_.myPtrAt (theOpn, thePegEl->myExecPer ());
d330 1
a330 1
theSub = thePegEl->mySub ();
d332 1
a332 1
witAssert (theSub != NULL);
d334 2
a335 2
return    curSubPegEls_.myPtrAt (theSub, thePegEl->myExecPer ());
}
d342 6
a347 6
myDelComp_    (theDelComp),
myExecPer_    (execPer),
peggedVol_    (0.0),
myFixedPegEl_ (NULL)
{
witAssert ((myOpn () != NULL) or (mySub () != NULL));
d349 2
a350 2
myFixedPegEl_ = new WitFixedPegEl (this);
}
d355 3
a357 3
{
delete myFixedPegEl_;
}
d362 3
a364 3
{
theSglSrcMgr->saveAllocVal (peggedVol_);
}
d369 3
a371 3
{
peggedVol_ += deltaVol;
}
d376 3
a378 3
{
return myDelComp_->thisOpn ();
}
d383 3
a385 3
{
return myDelComp_->thisSub ();
}
d392 3
a394 3
myPegEl_ (thePegEl)
{
}
d399 2
a400 2
{
}
@


1.35
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d38 1
a38 1
      WitProbAssoc     (theProblem),
d40 9
a48 9
      myHeurAtor_      (NULL),
      curDemand_       (NULL),
      curShipPer_      (-1),
      myPegElStack_    (theProblem),
      curOpnPegEls_    (),
      curSubPegEls_    (),
      nonEmptyDemPers_ (theProblem)
   {
   }
d53 3
a55 3
   {
   clear ();
   }
d60 2
a61 2
   {
   WitDemand * theDemand;
d63 2
a64 2
   witAssert (myHeurAtor_ == NULL);
   witAssert (curDemand_  == NULL);
d66 1
a66 1
   clear ();
d68 1
a68 1
   myHeurAtor_ = theHeurAtor;
d70 2
a71 2
   curOpnPegEls_.allocate (myProblem ());
   curSubPegEls_.allocate (myProblem ());
d73 2
a74 2
   myMsgFac () ("concPeggingMsg");
   }
d79 3
a81 3
   {
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;
d83 2
a84 2
   witAssert (myHeurAtor_ != NULL);
   witAssert (curDemand_  == NULL);
d86 2
a87 2
   curDemand_  = theDemand;
   curShipPer_ = shipPer;
d89 1
a89 1
   curDemand_->extractPegEls (curShipPer_, myPegElStack_);
d91 1
a91 1
   myPegElStack_.attachItr (theItr);
d93 3
a95 3
   while (theItr.advance (thePegEl))
      curPegElsPtrFor (thePegEl) = thePegEl;
   }
d100 13
a112 13
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         deltaVol)
   {
   WitPegEl * thePegEl;

   if (curDemand_ == NULL)
      return;

   thePegEl = curOpnPegEls_.myPtrAt (theOpn, execPer);
   
   pegDeltaVol (theOpn, execPer, thePegEl, deltaVol);
   }
d117 13
a129 13
      WitSubEntry * theSub,
      WitPeriod     execPer,
      double        deltaVol)
   {
   WitPegEl * thePegEl;

   if (curDemand_ == NULL)
      return;

   thePegEl = curSubPegEls_.myPtrAt (theSub, execPer);
   
   pegDeltaVol (theSub, execPer, thePegEl, deltaVol);
   }
d134 3
a136 3
   {
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;
d138 2
a139 2
   witAssert (myHeurAtor_ != NULL);
   witAssert (curDemand_  != NULL);
d141 1
a141 1
   myPegElStack_.attachItr (theItr);
d143 2
a144 2
   while (theItr.advance (thePegEl))
      curPegElsPtrFor (thePegEl) = NULL;
d146 3
a148 3
   if (myHeurAtor_->multiSel ())
      if (myHeurAtor_->mySelector ()->sglSrc ())
         deleteZeroPegEls ();
d150 1
a150 1
   curDemand_->receivePegEls (curShipPer_, myPegElStack_);
d152 3
a154 3
   curDemand_  = NULL;
   curShipPer_ = -1;
   }
d159 3
a161 3
   {
   witAssert (myHeurAtor_ != NULL);
   witAssert (curDemand_  == NULL);
d163 2
a164 2
   curSubPegEls_.clear ();
   curOpnPegEls_.clear ();
d166 2
a167 2
   myHeurAtor_ = NULL;
   }
d172 7
a178 7
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;

   while (nonEmptyDemPers_.pop (theDemand, shipPer))
      theDemand->clearPegging (shipPer);
   }
d183 27
a209 27
   {
   WitDemand *                 theDemand;
   WitPeriod                   shipPer;
   WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());

   fprintf (myProblem ()->solnFile (),
      "\n\n"
      "Concurrent Pegging:\n");

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theDemand->getMyFixedPegEls (shipPer, theFixedPegEls);

         if (theFixedPegEls.isEmpty ())
            continue;

         fprintf (myProblem ()->solnFile (),
            "\n\n"
            "Part %s, Demand %s, Ship Per %d:\n",
            theDemand->demandedPartName ().myCstring (),
            theDemand->demandName ().myCstring (),
            shipPer);

         printOpnPegEls (theFixedPegEls);
         printSubPegEls (theFixedPegEls);
         }
d211 2
a212 2
   fprintf (myProblem ()->solnFile (), "\n");
   }
d217 6
a222 6
      WitDelComp * theDelComp,
      WitPeriod    execPer,
      WitPegEl *   thePegEl,
      double       deltaVol)
   {
   witAssert (curDemand_ != NULL);
d224 1
a224 1
   witAssert (deltaVol >= NET_TOL);
d226 3
a228 3
   if (thePegEl == NULL)
      {
      thePegEl = new WitPegEl (theDelComp, execPer);
d230 2
a231 2
      if (myPegElStack_.isEmpty ())
         nonEmptyDemPers_.push (curDemand_, curShipPer_);
d233 1
a233 1
      myPegElStack_.push (thePegEl);
d235 2
a236 2
      curPegElsPtrFor (thePegEl) = thePegEl;
      }
d238 3
a240 3
   if (myHeurAtor_->multiSel ())
      if (myHeurAtor_->mySelector ()->sglSrc ())
         thePegEl->saveStateIn (myHeurAtor_->mySelector ()->mySglSrcMgr ());
d242 2
a243 2
   thePegEl->pegDeltaVol (deltaVol);
   }
d248 9
a256 9
   {
   WitObjStack <WitPegEl> tempPegElStack (myProblem ());
   WitPegEl *             thePegEl;

   while (myPegElStack_.pop (thePegEl))
      if (thePegEl->peggedVol () == 0.0)
         delete thePegEl;
      else
         tempPegElStack.push (thePegEl);
d258 2
a259 2
   myPegElStack_.revCopyFrom (tempPegElStack);
   }
d264 22
a285 22
      const WitObjStack <WitFixedPegEl> & theFixedPegEls)
   {
   WitObjStItr <WitFixedPegEl> theItr;
   WitFixedPegEl *             theFixedPegEl;
   WitOperation *              theOpn;

   fprintf (myProblem ()->solnFile (), "\n   Opn  Per   ExecVol\n");

   theFixedPegEls.attachItr (theItr);

   while (theItr.advance (theFixedPegEl))
      {
      theOpn = theFixedPegEl->myOpn ();

      if (theOpn != NULL)
         fprintf (myProblem ()->solnFile (),
            "   %-3s  %-3d %9.3f\n",
            theOpn  ->operationName ().myCstring (),
            theFixedPegEl->myExecPer (),
            theFixedPegEl->peggedVol ());
      }
   }
d290 27
a316 27
      const WitObjStack <WitFixedPegEl> & theFixedPegEls)
   {
   WitObjStItr <WitFixedPegEl> theItr;
   WitFixedPegEl *             theFixedPegEl;
   WitSubEntry *               theSub;

   fprintf (
      myProblem ()->solnFile (), 
      "\n   Opn  B-E  Sub  Part  Per   ExecVol\n");

   theFixedPegEls.attachItr (theItr);

   while (theItr.advance (theFixedPegEl))
      {
      theSub = theFixedPegEl->mySub ();

      if (theSub != NULL)
         fprintf (myProblem ()->solnFile (),
            "   %-3s  %-3d  %-3d  %-4s  %-3d %9.3f\n",
            theSub  ->myOperationName ().myCstring (),
            theSub  ->myBomEntIndex (),
            theSub  ->localIndex (),
            theSub  ->myPart ()->partName ().myCstring (),
            theFixedPegEl->myExecPer (),
            theFixedPegEl->peggedVol ());
      }
   }
d321 3
a323 3
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;
d325 1
a325 1
   theOpn = thePegEl->myOpn ();
d327 2
a328 2
   if (theOpn != NULL)
      return curOpnPegEls_.myPtrAt (theOpn, thePegEl->myExecPer ());
d330 1
a330 1
   theSub = thePegEl->mySub ();
d332 1
a332 1
   witAssert (theSub != NULL);
d334 2
a335 2
   return    curSubPegEls_.myPtrAt (theSub, thePegEl->myExecPer ());
   }
d342 6
a347 6
      myDelComp_    (theDelComp),
      myExecPer_    (execPer),
      peggedVol_    (0.0),
      myFixedPegEl_ (NULL)
   {
   witAssert ((myOpn () != NULL) or (mySub () != NULL));
d349 2
a350 2
   myFixedPegEl_ = new WitFixedPegEl (this);
   }
d355 3
a357 3
   {
   delete myFixedPegEl_;
   }
d362 3
a364 3
   {
   theSglSrcMgr->saveAllocVal (peggedVol_);
   }
d369 3
a371 3
   {
   peggedVol_ += deltaVol;
   }
d376 3
a378 3
   {
   return myDelComp_->thisOpn ();
   }
d383 3
a385 3
   {
   return myDelComp_->thisSub ();
   }
d392 3
a394 3
      myPegEl_ (thePegEl)
   {
   }
d399 2
a400 2
   {
   }
@


1.34
log
@Stochastic Implosion
@
text
@d26 1
a26 1
#include <Opn.h>
@


1.33
log
@[disallowed backlog]
@
text
@a27 1
#include <HeurAccess.h>
a30 1
#include <ObjStack.h>
a36 7
inline WitObjStack <WitPegEl> & WitPegger::curPegElStack ()
   {
   return WitHeurAccess::myPegElsFor (curDemand_) (curShipPer_);
   }

//------------------------------------------------------------------------------

d43 1
d89 3
a91 1
   curPegElStack ().attachItr (theItr);
d141 1
a141 1
   curPegElStack ().attachItr (theItr);
d150 2
d230 1
a230 1
      if (curPegElStack ().isEmpty ())
d233 1
a233 1
      curPegElStack ().push (thePegEl);
d252 1
a252 1
   while (curPegElStack ().pop (thePegEl))
d258 1
a258 1
   curPegElStack ().revCopyFrom (tempPegElStack);
@


1.32
log
@Updated the copyright date on all source files.
@
text
@a26 1
#include <SglSrcMgr.h>
d28 1
d31 1
a38 9
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitPtrTVec <WitObjStack <WitPegEl> > WitDemand::* WitPegger::myPegElsFor_ =
                                                                          NULL;

//------------------------------------------------------------------------------

d41 1
a41 1
   return (curDemand_->*myPegElsFor_) (curShipPer_);
a219 8
void WitPegger::receiveDMPs (
      WitPtrTVec <WitObjStack <WitPegEl> > WitDemand::* myPegElsForArg)
   {
   myPegElsFor_ = myPegElsForArg;
   }

//------------------------------------------------------------------------------

@


1.31
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.30
log
@[shared-resource pegging]
@
text
@d105 1
a105 1
   curPegElStack ().attach (theItr);
d155 1
a155 1
   curPegElStack ().attach (theItr);
d292 1
a292 1
   theFixedPegEls.attach (theItr);
d320 1
a320 1
   theFixedPegEls.attach (theItr);
@


1.29
log
@[multi-thread]
@
text
@d105 1
a105 1
   theItr.attachTo (curPegElStack ());
d155 1
a155 1
   theItr.attachTo (curPegElStack ());
d292 1
a292 1
   theItr.attachTo (theFixedPegEls);
d320 1
a320 1
   theItr.attachTo (theFixedPegEls);
@


1.28
log
@Revised mappingIndex code.
@
text
@d38 9
d49 1
a49 1
   return myPegEls_.myElemAt (curDemand_, curShipPer_);
a57 1
      myPegEls_        (),
a85 1
   myPegEls_    .allocate (myProblem ());
a88 3
   forEachDemand (theDemand, myProblem ())
      theDemand->loadPegging ();

a93 12
void WitPegger::loadDataFrom (
      WitDemand *                                  theDemand,
      const WitPtrTVec <WitObjStack <WitPegEl> > & thePegElStPtrTVec)
   {
   WitPeriod shipPer;

   forEachPeriod (shipPer, myProblem ())
      myPegEls_.myPtrAt (theDemand, shipPer) = thePegElStPtrTVec[shipPer];
   }

//------------------------------------------------------------------------------

a176 1
   myPegEls_    .clear ();
d228 8
@


1.27
log
@Continued implementation of PIP.
@
text
@a32 1
#include <MapIdxI.h>
@


1.26
log
@Removed a bad function overload.
@
text
@d280 1
a280 1
   tempPegElStack.revCopyInto (curPegElStack ());
@


1.25
log
@Continued implementation of post-implosion pegging.
@
text
@d399 1
a399 1
   return myDelComp_->myOpn ();
d406 1
a406 1
   return myDelComp_->mySub ();
@


1.24
log
@Corrected a file inclusion AIX porting bug.
@
text
@d212 1
a212 1
      "Pegging:\n");
@


1.23
log
@Continued implementation of post-implosion pegging.
@
text
@d33 1
@


1.22
log
@Continued implementation of post-implosion pegging.
@
text
@a32 1
#include <PtrSchedI.h>
@


1.21
log
@Continued implementation of proportionate routing.
@
text
@d86 1
a86 1
   myMsgFac () ("peggingMsg");
@


1.20
log
@Removed all const_casts from WIT.
@
text
@d399 1
a399 5
   WitOperation * theOpn;

   myDelComp_->getOperation (theOpn);

   return theOpn;
d406 1
a406 5
   WitSubEntry * theSub;

   myDelComp_->getSubEntry (theSub);

   return theSub;
@


1.19
log
@Internal changes.
@
text
@d13 1
a13 1
// Contains the implementation of the following classes and templates:
d17 1
d206 3
a208 3
   WitDemand *                  theDemand;
   WitPeriod                    shipPer;
   WitObjStack <const WitPegEl> thePegEls (myProblem ());
d217 1
a217 1
         theDemand->getMyPegEls (shipPer, thePegEls);
d219 1
a219 1
         if (thePegEls.isEmpty ())
d229 2
a230 2
         printOpnPegEls (thePegEls);
         printSubPegEls (thePegEls);
d285 2
a286 1
void WitPegger::printOpnPegEls (const WitObjStack <const WitPegEl> & thePegEls)
d288 3
a290 3
   WitObjStItr <const WitPegEl> theItr;
   const WitPegEl *             thePegEl;
   WitOperation *               theOpn;
d294 1
a294 1
   theItr.attachTo (thePegEls);
d296 1
a296 1
   while (theItr.advance (thePegEl))
d298 1
a298 1
      theOpn = thePegEl->myOpn ();
d304 2
a305 2
            thePegEl->myExecPer (),
            thePegEl->peggedVol ());
d311 2
a312 1
void WitPegger::printSubPegEls (const WitObjStack <const WitPegEl> & thePegEls)
d314 3
a316 3
   WitObjStItr <const WitPegEl> theItr;
   const WitPegEl *             thePegEl;
   WitSubEntry *                theSub;
d322 1
a322 1
   theItr.attachTo (thePegEls);
d324 1
a324 1
   while (theItr.advance (thePegEl))
d326 1
a326 1
      theSub = thePegEl->mySub ();
d335 2
a336 2
            thePegEl->myExecPer (),
            thePegEl->peggedVol ());
d364 4
a367 3
      myDelComp_ (theDelComp),
      myExecPer_ (execPer),
      peggedVol_ (0.0)
d370 2
d378 1
d416 16
@


1.18
log
@Removed implementation of single-source by the old algorithm.
@
text
@d365 1
a365 1
   witAssert ((myOpn () != NULL) || (mySub () != NULL));
@


1.17
log
@Continued implementation of single-source by the new algorithm.
@
text
@a25 1
#include <OldSglMgr.h>
a168 4
      if (myHeurAtor_->mySelector ()->oldSglSrc ())
         deleteZeroPegEls ();

   if (myHeurAtor_->multiSel ())
a259 4
      if (myHeurAtor_->mySelector ()->oldSglSrc ())
         thePegEl->saveStateIn (myHeurAtor_->mySelector ()->myOldSglMgr ());

   if (myHeurAtor_->multiSel ())
a371 7
   }

//------------------------------------------------------------------------------

void WitPegEl::saveStateIn (WitOldSglMgr * theOldSglMgr)
   {
   theOldSglMgr->saveAllocVal (peggedVol_);
@


1.16
log
@Began implementation of the new single-source algorithm.
@
text
@d27 1
d173 4
d268 4
d388 7
@


1.15
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d26 1
a26 1
#include <SglSrcMgr.h>
d169 1
a169 1
      if (myHeurAtor_->mySelector ()->singleSource ())
d260 2
a261 2
      if (myHeurAtor_->mySelector ()->singleSource ())
         thePegEl->saveStateIn (myHeurAtor_->mySelector ()->mySglSrcMgr ());
d376 1
a376 1
void WitPegEl::saveStateIn (WitSglSrcMgr * theSglSrcMgr)
d378 1
a378 1
   theSglSrcMgr->saveAllocVal (peggedVol_);
@


1.14
log
@Continued implementation of Single-Source.
@
text
@d32 1
d36 7
@


1.13
log
@Continued implementation of Single-Source.
@
text
@d26 1
d28 2
d40 1
a40 1
      active_          (witFALSE),
d59 1
a59 1
void WitPegger::setUpPeggedHeurAlloc ()
d63 2
a64 2
   witAssert (! active_);
   witAssert (curDemand_ == NULL);
d68 1
a68 1
   active_ = witTRUE;
d99 2
a100 3
   witAssert (active_);

   witAssert (curDemand_ == NULL);
d152 2
a153 2
   witAssert (active_);
   witAssert (curDemand_ != NULL);
d160 4
d172 2
a173 2
   witAssert (active_);
   witAssert (curDemand_ == NULL);
d179 1
a179 1
   active_ = witFALSE;
d251 4
d260 16
d364 7
@


1.12
log
@Continued implementation of Single-Source.
@
text
@a14 1
//    PegSite
a18 1
#include <PegSite.h>
a30 72
// Implementation of class PegSite.
//------------------------------------------------------------------------------

WitPegSite::WitPegSite (WitProblem * theProblem):
      WitProbAssoc (theProblem),

      myPegElsFor_ (theProblem)
   {
   WitPeriod shipPer;

   forEachPeriod (shipPer, myProblem ())
      myPegElsFor_[shipPer] = new WitObjStack <WitPegEl> (myProblem ());
   }

//------------------------------------------------------------------------------

WitPegSite::~WitPegSite ()
   {
   deleteContents (myPegElsFor_);
   }

//------------------------------------------------------------------------------

void WitPegSite::addPegEl (WitPeriod shipPer, WitPegEl * thePegEl)
   {
   myPegElsFor_ (shipPer).push (thePegEl);
   }

//------------------------------------------------------------------------------

void WitPegSite::getMyOpnPegEls (
      WitPeriod                      shipPer,
      WitObjStack <const WitPegEl> & thePegEls)
   {
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;

   thePegEls.clear ();

   theItr.attachTo (myPegElsFor_ (shipPer));

   while (theItr.advance (thePegEl))
      if (thePegEl->myOpn () != NULL)
         thePegEls.push (thePegEl);
   }

//------------------------------------------------------------------------------

void WitPegSite::getMySubPegEls (
      WitPeriod                       shipPer,
      WitObjStack <const WitPegEl > & thePegEls)
   {
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;

   thePegEls.clear ();

   theItr.attachTo (myPegElsFor_ (shipPer));

   while (theItr.advance (thePegEl))
      if (thePegEl->mySub () != NULL)
         thePegEls.push (thePegEl);
   }

//------------------------------------------------------------------------------

void WitPegSite::clear (WitPeriod shipPer)
   {
   deleteContents (myPegElsFor_ (shipPer));
   }

//------------------------------------------------------------------------------
d35 1
a35 1
      WitProbAssoc   (theProblem),
d37 7
a43 7
      active_        (witFALSE),
      nonEmptyPairs_ (theProblem),
      thePegSiteFor_ (),
      curPegSite_    (NULL),
      curShipPer_    (-1),
      curOpnPegEls_  (),
      curSubPegEls_  ()
d61 1
a61 1
   witAssert (curPegSite_ == NULL);
d67 3
a69 3
   thePegSiteFor_.allocate (myProblem ());
   curOpnPegEls_ .allocate (myProblem ());
   curSubPegEls_ .allocate (myProblem ());
d79 3
a81 1
void WitPegger::loadDataFrom (WitDemand * theDemand, WitPegSite * thePegSite)
d83 1
a83 2
   witAssert (thePegSiteFor_ (theDemand) == NULL);
   witAssert (thePegSite                 != NULL);
d85 2
a86 1
   thePegSiteFor_ (theDemand) = thePegSite;
d98 1
a98 1
   witAssert (curPegSite_ == NULL);
d100 1
a100 1
   curPegSite_ = thePegSiteFor_ (theDemand);
d103 1
a103 1
   theItr.attachTo (curPegSite_->myPegElsFor (shipPer));
d118 1
a118 1
   if (curPegSite_ == NULL)
d135 1
a135 1
   if (curPegSite_ == NULL)
d151 1
a151 1
   witAssert (curPegSite_ != NULL);
d153 1
a153 1
   theItr.attachTo (curPegSite_->myPegElsFor (curShipPer_));
d158 1
a158 1
   curPegSite_ = NULL;
d167 1
a167 1
   witAssert (curPegSite_ == NULL);
d169 3
a171 3
   curSubPegEls_ .clear ();
   curOpnPegEls_ .clear ();
   thePegSiteFor_.clear ();
d180 2
a181 2
   WitPegSite * thePegSite;
   WitPeriod    shipPer;
d183 2
a184 2
   while (nonEmptyPairs_.pop (thePegSite, shipPer))
      thePegSite->clear (shipPer);
d193 1
a193 2
   WitObjStack <const WitPegEl> theOpnPegEls (myProblem ());
   WitObjStack <const WitPegEl> theSubPegEls (myProblem ());
d202 1
a202 2
         theDemand->getMyOpnPegEls (shipPer, theOpnPegEls);
         theDemand->getMySubPegEls (shipPer, theSubPegEls);
d204 2
a205 3
         if (theOpnPegEls.isEmpty ())
            if (theSubPegEls.isEmpty ())
               continue;
d214 2
a215 5
         if (theOpnPegEls.isNonEmpty ())
            printOpnPegEls (theOpnPegEls);

         if (theSubPegEls.isNonEmpty ())
            printSubPegEls (theSubPegEls);
d229 1
a229 1
   witAssert (curPegSite_ != NULL);
d237 2
a238 2
      if (curPegSite_->myPegElsFor (curShipPer_).isEmpty ())
         nonEmptyPairs_.push (curPegSite_, curShipPer_);
d240 1
a240 1
      curPegSite_->addPegEl (curShipPer_, thePegEl);
d250 1
a250 1
void WitPegger::printOpnPegEls (WitObjStack <const WitPegEl> & thePegEls)
d252 3
a254 1
   const WitPegEl * thePegEl;
d258 3
a260 1
   while (thePegEls.pop (thePegEl))
d262 1
a262 1
      stronglyAssert (thePegEl->myOpn () != NULL);
d264 6
a269 5
      fprintf (myProblem ()->solnFile (),
         "   %-3s  %-3d %9.3f\n",
         thePegEl->myOpn ()->operationName ().myCstring (),
         thePegEl->myExecPer (),
         thePegEl->peggedVol ());
d275 1
a275 1
void WitPegger::printSubPegEls (WitObjStack <const WitPegEl> & thePegEls)
d277 3
a279 2
   const WitPegEl * thePegEl;
   WitSubEntry *    theSub;
d285 3
a287 1
   while (thePegEls.pop (thePegEl))
d291 9
a299 10
      stronglyAssert (theSub != NULL);

      fprintf (myProblem ()->solnFile (),
         "   %-3s  %-3d  %-3d  %-4s  %-3d %9.3f\n",
         theSub  ->myOperationName ().myCstring (),
         theSub  ->myBomEntIndex (),
         theSub  ->localIndex (),
         theSub  ->myPart ()->partName ().myCstring (),
         thePegEl->myExecPer (),
         thePegEl->peggedVol ());
@


1.11
log
@Began implementation of object iteration.
@
text
@d16 2
a17 2
//    PegMgr
//    Pegger <AllocComp>
a20 1
#include <PegMgr.h>
d29 1
d37 1
a37 1
      WitProbAssoc    (theProblem),
d39 1
a39 2
      myOpnPegElsFor_ (theProblem),
      mySubPegElsFor_ (theProblem)
d44 1
a44 7
      {
      myOpnPegElsFor_[shipPer] = 
         new WitObjStack <WitPegEl <WitOperation> > (myProblem ());

      mySubPegElsFor_[shipPer] = 
         new WitObjStack <WitPegEl <WitSubEntry>  > (myProblem ());
      }
d51 1
a51 2
   deleteContents (mySubPegElsFor_);
   deleteContents (myOpnPegElsFor_);
d56 1
a56 1
void WitPegSite::setUpPeggedIncAlloc (WitPeriod shipPer, WitPegMgr * thePegMgr)
d58 1
a58 3
   thePegMgr->setUpPeggedIncAlloc (
      myOpnPegElsFor_ (shipPer),
      mySubPegElsFor_ (shipPer));
d64 2
a65 2
      WitPeriod                                      shipPer,
      WitObjStack <const WitPegEl <WitOperation> > & thePegEls)
d67 10
a76 1
   myOpnPegElsFor_ (shipPer).revCopyIntoConst (thePegEls);
d82 18
a99 2
      WitPeriod                                     shipPer,
      WitObjStack <const WitPegEl <WitSubEntry> > & thePegEls)
d101 1
a101 1
   mySubPegElsFor_ (shipPer).revCopyIntoConst (thePegEls);
d105 1
a105 1
// Implementation of class PegMgr.
d108 2
a109 2
WitPegMgr::WitPegMgr (WitProblem * theProblem):
      WitProbAssoc (theProblem),
d111 7
a117 2
      myOpnPegger_ (NULL),
      mySubPegger_ (NULL)
a118 2
   myOpnPegger_ = new WitPegger <WitOperation> (theProblem);
   mySubPegger_ = new WitPegger <WitSubEntry>  (theProblem);
d123 1
a123 1
WitPegMgr::~WitPegMgr ()
d125 1
a125 2
   delete mySubPegger_;
   delete myOpnPegger_;
d130 1
a130 1
void WitPegMgr::setUpPeggedHeurAlloc ()
d132 15
a146 2
   myOpnPegger_->setUpPeggedHeurAlloc ();
   mySubPegger_->setUpPeggedHeurAlloc ();
d153 11
a163 3
void WitPegMgr::setUpPeggedIncAlloc (
      WitObjStack <WitPegEl <WitOperation> > & theOpnPegEls,
      WitObjStack <WitPegEl <WitSubEntry>  > & theSubPegEls)
d165 14
a178 2
   myOpnPegger_->setUpPeggedIncAlloc (theOpnPegEls);
   mySubPegger_->setUpPeggedIncAlloc (theSubPegEls);
d183 1
a183 1
void WitPegMgr::pegDeltaVol (
d188 8
a195 1
   myOpnPegger_->pegDeltaVol (theOpn, execPer, deltaVol);
d200 1
a200 1
void WitPegMgr::pegDeltaVol (
d205 8
a212 1
   mySubPegger_->pegDeltaVol (theSub, execPer, deltaVol);
d217 1
a217 1
void WitPegMgr::shutDownPeggedIncAlloc ()
d219 13
a231 2
   myOpnPegger_->shutDownPeggedIncAlloc ();
   mySubPegger_->shutDownPeggedIncAlloc ();
d236 1
a236 1
void WitPegMgr::shutDownPeggedHeurAlloc ()
d238 8
a245 2
   mySubPegger_->shutDownPeggedHeurAlloc ();
   myOpnPegger_->shutDownPeggedHeurAlloc ();
d250 1
a250 1
void WitPegMgr::clear ()
d252 5
a256 2
   myOpnPegger_->clear ();
   mySubPegger_->clear ();
d261 1
a261 1
void WitPegMgr::print ()
d263 4
a266 4
   WitDemand *                     theDemand;
   WitPeriod                       shipPer;
   WitObjStack <const WitOpnPegEl> theOpnPegEls (myProblem ());
   WitObjStack <const WitSubPegEl> theSubPegEls (myProblem ());
d275 2
a276 2
         theDemand->myPegSite ()->getMyOpnPegEls (shipPer, theOpnPegEls);
         theDemand->myPegSite ()->getMySubPegEls (shipPer, theSubPegEls);
d290 1
a290 1
            print (theOpnPegEls);
d293 1
a293 1
            print (theSubPegEls);
d301 5
a305 1
void WitPegMgr::print (WitObjStack <const WitOpnPegEl> & thePegEls)
d307 24
a330 1
   const WitOpnPegEl * thePegEl;
d335 3
d340 1
a340 1
         thePegEl->myAllocComp ()->operationName ().myCstring (),
d343 1
d348 1
a348 1
void WitPegMgr::print (WitObjStack <const WitSubPegEl> & thePegEls)
d350 2
a351 2
   const WitSubPegEl * thePegEl;
   WitSubEntry *       theSub;
d359 3
a361 1
      theSub = thePegEl->myAllocComp ();
a374 2
// Implementation of template class Pegger <AllocComp>.
//------------------------------------------------------------------------------
d376 1
a376 3
template <class AllocComp>
      inline WitPegEl <AllocComp> * & WitPegger <AllocComp>::
         curPegElsPtrFor (WitPegEl <AllocComp> * thePegEl)
d378 2
a379 2
   return curPegEls_.myPtrAt (thePegEl->myAllocComp (), thePegEl->myExecPer ());
   }
d381 1
a381 1
//------------------------------------------------------------------------------
d383 2
a384 3
template <class AllocComp>
      WitPegger <AllocComp>::WitPegger (WitProblem * theProblem):
         WitProbAssoc         (theProblem),
d386 1
a386 6
         active_              (witFALSE),
         nonEmptyPegElStPtrs_ (theProblem),
         curPegElStPtr_       (NULL),
         curPegEls_           ()
   {
   }
d388 1
a388 1
//------------------------------------------------------------------------------
d390 1
a390 4
template <class AllocComp>
      WitPegger <AllocComp>::~WitPegger ()
   {
   clear ();
d394 2
d397 4
a400 2
template <class AllocComp>
      void WitPegger <AllocComp>::setUpPeggedHeurAlloc ()
d402 1
a402 8
   witAssert (! active_);
   witAssert (curPegElStPtr_ == NULL);

   clear ();

   active_ = witTRUE;

   curPegEls_.allocate (myProblem ());
d407 1
a407 3
template <class AllocComp>
      void WitPegger <AllocComp>::setUpPeggedIncAlloc (
         WitObjStack <WitPegEl <AllocComp> > & thePegEls)
a408 12
   WitObjStItr <WitPegEl <AllocComp> > theItr;
   WitPegEl <AllocComp> *              thePegEl;

   witAssert (active_);
   witAssert (curPegElStPtr_ == NULL);

   curPegElStPtr_ = & thePegEls;

   theItr.attachTo (thePegEls);

   while (theItr.advance (thePegEl))
      curPegElsPtrFor (thePegEl) = thePegEl;
d413 1
a413 5
template <class AllocComp>
      void WitPegger <AllocComp>::pegDeltaVol (
         AllocComp * theAllocComp,
         WitPeriod   execPer,
         double      deltaVol)
d415 1
a415 24
   WitPegEl <AllocComp> * thePegEl;

   witAssert (active_);

   witAssert (deltaVol >= NET_TOL);

   if (curPegElStPtr_ == NULL)
      return;

   thePegEl = curPegEls_.myPtrAt (theAllocComp, execPer);
   
   if (thePegEl == NULL)
      {
      thePegEl = new WitPegEl <AllocComp> (theAllocComp, execPer);

      if (curPegElStPtr_->isEmpty ())
         nonEmptyPegElStPtrs_.push (curPegElStPtr_);

      curPegElStPtr_->push (thePegEl);

      curPegElsPtrFor (thePegEl) = thePegEl;
      }

   thePegEl->pegDeltaVol (deltaVol);
d420 1
a420 2
template <class AllocComp>
      void WitPegger <AllocComp>::shutDownPeggedIncAlloc ()
d422 1
a422 7
   WitObjStItr <WitPegEl <AllocComp> > theItr;
   WitPegEl <AllocComp> *              thePegEl;

   witAssert (active_);
   witAssert (curPegElStPtr_ != NULL);

   theItr.attachTo (* curPegElStPtr_);
d424 1
a424 2
   while (theItr.advance (thePegEl))
      curPegElsPtrFor (thePegEl) = NULL;
d426 1
a426 1
   curPegElStPtr_ = NULL;
d431 1
a431 2
template <class AllocComp>
      void WitPegger <AllocComp>::shutDownPeggedHeurAlloc ()
d433 1
a433 9
   witAssert (active_);
   witAssert (curPegElStPtr_ == NULL);

   curPegEls_.clear ();

   active_ = witFALSE;
   }

//------------------------------------------------------------------------------
d435 1
a435 4
template <class AllocComp>
      void WitPegger <AllocComp>::clear ()
   {
   WitObjStack <WitPegEl <AllocComp> > * thePegElStPtr;
d437 1
a437 2
   while (nonEmptyPegElStPtrs_.pop (thePegElStPtr))
      deleteContents (* thePegElStPtr);
@


1.10
log
@Continued implementation of sel-split for pen-exec.
@
text
@a22 1

d26 5
@


1.9
log
@Moved pegging output to comprehensive implosion solution output.
Fixed bug: Pegging was being attempted during stock bounds enforcement.
@
text
@d201 1
a201 1
         if (! theOpnPegEls.isEmpty ())
d204 1
a204 1
         if (! theSubPegEls.isEmpty ())
@


1.8
log
@Refactoring for constrained stock reallocation.
@
text
@d172 82
a330 1
   witAssert (curPegElStPtr_ != NULL);
d333 3
@


1.7
log
@Minor chnages.
@
text
@d54 2
a55 10
   WitPeriod shipPer;

   forEachPeriod (shipPer, myProblem ())
      {
      witAssert (mySubPegElsFor_ (shipPer).isEmpty ());
      witAssert (myOpnPegElsFor_ (shipPer).isEmpty ());

      delete mySubPegElsFor_[shipPer];
      delete myOpnPegElsFor_[shipPer];
      }
a307 1
   WitPegEl <AllocComp> *                thePegEl;
d310 1
a310 2
      while (thePegElStPtr->pop (thePegEl))
         delete thePegEl;
@


1.6
log
@Fixed a bug (pegging clearing).
@
text
@d259 1
a259 1
   witAssert (deltaVol > 0.0);
@


1.5
log
@Minor changes.
@
text
@d219 2
@


1.4
log
@Continued implementation of pegging.
@
text
@d257 2
@


1.3
log
@Continued implementation of pegging.
@
text
@d15 3
a17 7
//    PegSiteI <AllocComp>
//    PegMgrI  <AllocComp>
//    PeggerI  <AllocComp>
//
//    PegSite  <Operation>
//    PegMgr   <Operation>
//    Pegger   <Operation>
a25 1
#include <ObjStack.h>
d29 1
a29 1
// Implementation of class PegSiteI <AllocComp>.
d32 2
a33 3
template <class AllocComp>
      WitPegSiteI <AllocComp>::WitPegSiteI (WitProblem * theProblem):
         WitProbAssoc (theProblem),
d35 2
a36 1
         myPegElsFor_ (myProblem ())
d41 7
a47 2
      myPegElsFor_[shipPer] = 
         new WitObjStack <WitPegEl <AllocComp> > (myProblem ());
d52 1
a52 2
template <class AllocComp>
      WitPegSiteI <AllocComp>::~WitPegSiteI ()
d58 2
a59 1
      witAssert (myPegElsFor_ (shipPer).isEmpty ());
d61 2
a62 1
      delete myPegElsFor_[shipPer];
d68 21
a88 4
template <class AllocComp>
      void WitPegSiteI <AllocComp>::getMyPegEls (
         WitPeriod                         shipPer,
         WitObjStack <const WitPegEl <AllocComp> > & thePegEls)
d90 9
a98 2
   WitObjStItr <WitPegEl <AllocComp> > theItr;
   WitPegEl <AllocComp> *              thePegEl;
d100 6
a105 1
   thePegEls.clear ();
d107 1
a107 1
   theItr.attachTo (myPegElsFor_ (shipPer));
d109 4
a112 2
   while (theItr.advance (thePegEl))
      thePegEls.push (thePegEl);
d117 1
a117 2
template <class AllocComp>
      void WitPegSiteI <AllocComp>::setUpPeggedIncAlloc (WitPeriod shipPer)
d119 4
a122 1
   myProblem ()->myHeurAllMgr ()->setUpPeggedIncAlloc (myPegElsFor_ (shipPer));
d126 9
a134 1
// Implementation of class template PegMgrI <AllocComp>.
d137 4
a140 4
template <class AllocComp>
      WitPegMgrI <AllocComp>::WitPegMgrI (WitProblem * theProblem):
         WitProbAssoc         (theProblem),
         nonEmptyPegElStPtrs_ (theProblem)
d142 1
d147 4
a150 2
template <class AllocComp>
      WitPegMgrI <AllocComp>::~WitPegMgrI ()
d152 1
a152 1
   clear ();
d157 1
a157 3
template <class AllocComp>
      void WitPegMgrI <AllocComp>::setUpPeggedIncAlloc (
         WitObjStack <WitPegEl <AllocComp> > & thePegEls)
d159 2
a160 2
   if (thePegEls.isEmpty ())
      nonEmptyPegElStPtrs_.push (& thePegEls);
d165 1
a165 2
template <class AllocComp>
      void WitPegMgrI <AllocComp>::clear ()
d167 5
a171 2
   WitObjStack <WitPegEl <AllocComp> > * thePegElStPtr;
   WitPegEl <AllocComp> *                thePegEl;
d173 4
a176 3
   while (nonEmptyPegElStPtrs_.pop (thePegElStPtr))
      while (thePegElStPtr->pop (thePegEl))
         delete thePegEl;
d180 1
a180 1
// Implementation of class template PeggerI <AllocComp>.
d184 1
a184 1
      inline WitPegEl <AllocComp> * & WitPeggerI <AllocComp>::
d193 2
a194 2
      WitPeggerI <AllocComp>::WitPeggerI (WitProblem * theProblem):
         WitProbAssoc   (theProblem),
d196 4
a199 2
         curPegElStPtr_ (NULL),
         curPegEls_     (theProblem)
a200 1
   myProblem ()->myHeurAllMgr ()->clearPegging ();
d206 1
a206 1
      WitPeggerI <AllocComp>::~WitPeggerI ()
d208 1
d214 14
a227 1
      void WitPeggerI <AllocComp>::setUpPeggedIncAlloc (
d233 1
d247 1
a247 1
      void WitPeggerI <AllocComp>::pegDeltaVol (
d254 1
d263 3
d277 1
a277 1
      void WitPeggerI <AllocComp>::shutDownPeggedIncAlloc ()
d282 1
d294 11
a304 112
// Macro implementPeggingWrappers (AllocComp)
// Implementation macro for the wrapper template classes for pegging.
//
// This macro implements the following template classes non-parametrically:
//
//    PegSite <AllocComp>
//    PegMgr  <AllocComp>
//    Pegger  <AllocComp>
//------------------------------------------------------------------------------

#define implementPeggingWrappers(AllocComp)                                    \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Implementation of template class PegSite <AllocComp>.                     */\
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPegSite <AllocComp>::WitPegSite (WitProblem * theProblem):                  \
      WitPegSiteI <AllocComp> (theProblem)                                     \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPegSite <AllocComp>::~WitPegSite ()                                         \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPegSite <AllocComp>::getMyPegEls (                                     \
      WitPeriod                         shipPer,                               \
      WitObjStack <const WitPegEl <AllocComp> > & thePegEls)                   \
   {                                                                           \
   WitPegSiteI <AllocComp>::getMyPegEls (shipPer, thePegEls);                  \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPegSite <AllocComp>::setUpPeggedIncAlloc (WitPeriod shipPer)           \
   {                                                                           \
   WitPegSiteI <AllocComp>::setUpPeggedIncAlloc (shipPer);                     \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Implementation of template class PegMgr <AllocComp>.                      */\
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPegMgr <AllocComp>::WitPegMgr (WitProblem * theProblem):                    \
      WitPegMgrI <AllocComp> (theProblem)                                      \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPegMgr <AllocComp>::~WitPegMgr ()                                           \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPegMgr <AllocComp>::setUpPeggedIncAlloc (                              \
      WitObjStack <WitPegEl <AllocComp> > & thePegEls)                         \
   {                                                                           \
   WitPegMgrI <AllocComp>::setUpPeggedIncAlloc (thePegEls);                    \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPegMgr <AllocComp>::clear ()                                           \
   {                                                                           \
   WitPegMgrI <AllocComp>::clear ();                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Implementation of template class Pegger <AllocComp>.                      */\
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPegger <AllocComp>::WitPegger (WitProblem * theProblem):                    \
      WitPeggerI <AllocComp> (theProblem)                                      \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitPegger <AllocComp>::~WitPegger ()                                           \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPegger <AllocComp>::setUpPeggedIncAlloc (                              \
      WitObjStack <WitPegEl <AllocComp> > & thePegEls)                         \
   {                                                                           \
   WitPeggerI <AllocComp>::setUpPeggedIncAlloc (thePegEls);                    \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPegger <AllocComp>::pegDeltaVol (                                      \
      AllocComp * theAllocComp,                                                \
      WitPeriod   execPer,                                                     \
      double      deltaVol)                                                    \
   {                                                                           \
   WitPeggerI <AllocComp>::pegDeltaVol (theAllocComp, execPer, deltaVol);      \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitPegger <AllocComp>::shutDownPeggedIncAlloc ()                          \
   {                                                                           \
   WitPeggerI <AllocComp>::shutDownPeggedIncAlloc ();                          \
   }                                                                           \
a306 3
// Invocation of the implementation macro for the wrapper template classes for
// pegging.
//------------------------------------------------------------------------------
d308 10
a317 2
implementPeggingWrappers (WitOperation)
implementPeggingWrappers (WitSubEntry)
@


1.2
log
@Continued implementation of pegging.
@
text
@d240 2
d271 2
d301 2
d341 2
a342 1
// Invocation of the implementation macro for the wrapper template classes.
@


1.1
log
@Initial implementation of pegging.
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d15 7
a21 4
//    PegSite
//    PegMgr
//    Pegger
//    PegEl
d27 1
d34 1
a34 1
// Implementation of class PegSite.
d37 3
a39 2
WitPegSite::WitPegSite (WitProblem * theProblem):
      WitProbAssoc (theProblem),
d41 1
a41 1
      myPegElsFor_ (myProblem ())
d46 2
a47 1
      myPegElsFor_[shipPer] = new WitObjStack <WitPegEl> (myProblem ());
d52 2
a53 1
WitPegSite::~WitPegSite ()
d67 4
a70 3
void WitPegSite::getMyPegEls (
      WitPeriod                      shipPer,
      WitObjStack <const WitPegEl> & thePegEls)
d72 2
a73 2
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;
d85 2
a86 1
void WitPegSite::startIncHeurAlloc (WitPeriod shipPer)
d88 1
a88 2
   myProblem ()->myHeurAllMgr ()->myPegMgr ()->startIncHeurAlloc (
      myPegElsFor_ (shipPer));
d92 1
a92 1
// Implementation of class PegMgr.
d95 4
a98 4
WitPegMgr::WitPegMgr (WitProblem * theProblem):
      WitProbAssoc         (theProblem),
      myPegger_            (NULL),
      nonEmptyPegElStPtrs_ (theProblem)
d104 2
a105 1
WitPegMgr::~WitPegMgr ()
d112 3
a114 1
void WitPegMgr::startHeurAlloc (WitPegger * thePegger)
a115 14
   witAssert ( myPegger_ == NULL);
   witAssert (thePegger  != NULL);

   myPegger_ = thePegger;

   clear ();
   }

//------------------------------------------------------------------------------

void WitPegMgr::startIncHeurAlloc (WitObjStack <WitPegEl> & thePegEls)
   {
   witAssert (myPegger_ != NULL);

a117 11
   
   myPegger_->startIncHeurAlloc (thePegEls);
   }

//------------------------------------------------------------------------------

void WitPegMgr::finishHeurAlloc ()
   {
   witAssert (myPegger_ != NULL);

   myPegger_ = NULL;
d122 2
a123 1
void WitPegMgr::clear ()
d125 2
a126 2
   WitObjStack <WitPegEl> * thePegElStPtr;
   WitPegEl *               thePegEl;
d134 1
a134 1
// Implementation of class Pegger.
d137 3
a139 1
inline WitPegEl * & WitPegger::curPegElsPtrFor (WitPegEl * thePegEl)
d141 1
a141 1
   return curPegEls_.myPtrAt (thePegEl->myOpn (), thePegEl->myExecPer ());
d146 3
a148 2
WitPegger::WitPegger (WitProblem * theProblem):
      WitProbAssoc   (theProblem),
d150 2
a151 2
      curPegElStPtr_ (NULL),
      curPegEls_     (theProblem)
d153 1
a153 1
   myProblem ()->myHeurAllMgr ()->myPegMgr ()->startHeurAlloc (this);
d158 2
a159 1
WitPegger::~WitPegger ()
a160 1
   myProblem ()->myHeurAllMgr ()->myPegMgr ()->finishHeurAlloc ();
d165 3
a167 1
void WitPegger::startIncHeurAlloc (WitObjStack <WitPegEl> & thePegEls)
d169 2
a170 2
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;
d184 5
a188 4
void WitPegger::recIncExecVol (
      WitOperation * theOpn,
      WitPeriod      execPer,
      double         deltaVol)
d190 1
a190 1
   WitPegEl * thePegEl;
d194 1
a194 1
   thePegEl = curPegEls_.myPtrAt (theOpn, execPer);
d198 1
a198 1
      thePegEl = new WitPegEl (theOpn, execPer);
d205 1
a205 1
   thePegEl->recIncExecVol (deltaVol);
d210 2
a211 1
void WitPegger::finishIncHeurAlloc ()
d213 2
a214 2
   WitObjStItr <WitPegEl> theItr;
   WitPegEl *             thePegEl;
d227 106
a332 9
// Implementation of class PegEl.
//------------------------------------------------------------------------------

WitPegEl::WitPegEl (WitOperation * theOpn, WitPeriod execPer):
      myOpn_        (theOpn),
      myExecPer_    (execPer),
      deltaExecVol_ (0.0)
   {
   }
d335 1
a335 5

WitPegEl::~WitPegEl ()
   {
   }

d338 2
a339 4
void WitPegEl::recIncExecVol (double deltaVol)
   {
   deltaExecVol_ += deltaVol;
   }
@


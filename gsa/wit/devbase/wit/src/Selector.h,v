head	1.130;
access;
symbols
	sce_5_01_20080919:1.109
	latest_sce_4_20_20060523:1.108.0.2
	sce_4_20_20060523:1.108
	latest_sce4_20_OSL:1.107.0.2
	sce_4_20_OSL:1.107
	sce_410_withVa:1.107
	sce_4_05_20040511:1.96
	sce_4_00_20040201:1.96
	nextGenBranch:1.96.0.2
	nextGenRoot:1.96
	sce_3_30_20030627:1.96
	EndRw-branch:1.71.0.2
	Root-of-EndRw:1.71
	rwToStl:1.69.0.2
	latest_sce_3_10_20010924:1.45.0.2
	sce_3_10_20010924:1.45
	latest_sce_3_00_20010601:1.39.0.2
	sce_3_00_20010601:1.39
	latest_sce_2_31_20010308:1.22.0.2
	sce_2_31_20010308:1.22
	latest_sce_2_31_20001003:1.6.0.2
	sce_2_31_20001003:1.6
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.130
date	2011.09.28.23.50.11;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2011.09.24.00.28.38;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2011.08.30.20.18.10;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2010.08.03.23.38.23;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2010.07.30.20.20.15;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2010.07.27.23.18.55;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2010.07.26.17.48.44;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2010.07.16.22.37.44;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2010.07.13.17.41.30;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2010.07.02.18.53.11;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2010.07.01.22.41.21;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2010.06.29.23.25.15;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2010.06.25.15.42.52;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2010.06.24.23.37.33;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2010.06.24.18.19.59;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2010.06.24.17.48.41;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2010.06.23.18.55.12;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.18.23.11.16;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2010.06.18.20.04.12;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2010.06.17.17.46.26;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2010.06.14.21.15.15;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2006.09.25.21.11.59;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2006.05.02.17.34.12;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2005.03.02.23.56.52;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2005.01.26.23.50.33;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2005.01.21.23.01.51;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2005.01.19.23.50.58;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2005.01.10.22.34.49;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2004.12.28.19.21.20;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2004.12.22.23.36.28;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2004.12.22.22.27.10;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2004.12.21.22.13.50;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2004.12.06.22.38.17;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2004.11.23.20.50.07;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2003.05.06.20.22.45;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2003.04.18.19.55.50;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2003.04.17.23.34.21;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2003.04.14.22.00.37;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2003.03.19.16.48.28;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2003.03.06.20.28.22;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2003.03.03.21.40.09;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2003.03.03.21.07.34;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2003.02.28.20.47.40;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2003.02.27.19.20.24;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2003.02.27.17.21.27;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2003.02.25.22.17.11;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2003.02.24.23.44.33;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2003.02.21.18.56.28;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2003.02.18.23.19.18;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2003.02.18.20.11.01;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2003.02.16.23.58.12;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2003.02.14.20.13.02;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2003.02.13.23.06.33;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2003.02.11.18.21.21;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2003.02.10.20.53.54;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2003.01.31.21.28.58;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2003.01.29.19.16.49;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2003.01.02.22.18.48;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2002.12.17.21.32.51;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.21.22.53.59;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2002.11.15.20.27.13;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2002.10.30.23.47.32;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2002.07.22.19.33.59;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.24.23.00.07;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.17.21.45.05;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.16.23.32.10;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.13.21.31.42;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2002.05.07.20.15.05;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.01.14.26.01;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2002.04.15.21.21.39;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.12.21.02.04;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2002.04.11.15.36.31;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.05.20.43.59;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.29.23.47.11;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.26.15.10.33;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.22.21.23.24;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.15.23.17.31;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.14.20.04.03;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2002.03.07.23.24.30;	author bobw;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.07.16.57.29;	author bobw;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.14.23.56.08;	author bobw;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.10.22.06.58;	author bobw;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.17.16.25.42;	author bobw;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.01.00.25.40;	author bobw;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.17.16.12.48;	author bobw;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.19.18.51.00;	author bobw;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.16.21.42.32;	author bobw;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.04.15.44.40;	author bobw;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.25.16.08.20;	author bobw;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.20.20.07.06;	author bobw;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.11.19.29.12;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.17.15.11.17;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.10.22.31.14;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.10.17.58.19;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.08.21.35.45;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.03.18.50.37;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.30.21.29.42;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.25.20.54.37;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.24.23.09.58;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.26.20.28.08;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.23.19.43.25;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.21.21.55.48;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.20.21.04.00;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.16.00.22.58;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.13.22.12.06;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.12.19.48.09;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.08.21.08.27;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.08.16.37.07;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.09.22.55.48;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.06.15.46.37;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.29.19.26.11;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.26.21.46.03;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.20.00.44.22;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.15.19.01.52;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.11.16.35.11;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.04.22.27.54;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.03.15.56.50;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.28.22.13.39;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.22.16.18.27;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.13.19.57.26;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.05.19.05.32;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.04.22.07.39;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.22.23.11.48;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.21.20.03.28;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.14.20.27.32;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.24.19.55.27;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.19.22.35.35;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.31.19.25.08;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.56;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches;
next	;


desc
@@


1.130
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef SelectorH
#define SelectorH

//------------------------------------------------------------------------------
// Header file: "Selector.h"
//
// Contains the declaration of class Selector.
//------------------------------------------------------------------------------

#include <ObjStack.h>
#include <PtrTVec.h>
#include <Assoc.h>

//------------------------------------------------------------------------------
// Class Selector
//
// Owner and governing class of the "multiple selections" subsystem.
// The multiple selections subsystem is responsible for implementing the
// multiple selections technique of heuristic allocation. This is a general
// technique that includes the following techniques as special cases:
//
//    multiple routes
//    build-ahead
//    multiple execution periods
//    selective stock reallocation
//    proportionate routing
//
// Thus the multiple selections subsystem is responsible for selecting each of
// the following:
//
//    Which  BopEntry to use when exploding through a Part     (for multiRoute).
//    Which ConsEntry to use when exploding through a BomEntry (for multiRoute).
//    Which explosion period to use when filling demand at a buildNstn or
//       buildAsap Material (for build-ahead).
//    Which execution period to use when explosing through a BopEntry in a
//       particular period (for multi-exec).
//    Whether or not to use stock reallocation for a particular Material in a
//       particular period (for selective stock reallocation).
//    What set of BopEntries to use when exploding through a Part (for 
//       prop-routing).
//    What set of ConsEntries to use when exploding through a BomEntry (for 
//       prop-routing).
//
// These selections are called the "selection configuration" or just the
// "configuration".
//
// In addition, the multiple selections subsystem is responsible for the
// following extensions to the multiple selections technique:
//
//    penalized execution
//    selection splitting
//    single source
//
// Each of the particular cases of the multiple selections technique and its
// extensions is handled by its own subsystem.
//
// The Selector's specific responsibilities are as follows:
//
//    Owning the main objects of the multiple selections subsystem.
//    Co-ordinating abstract aspects of the multiple selections technique.
//------------------------------------------------------------------------------

class WitSelector: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSelector (WitHeurAtor *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitSelector ();

      //------------------------------------------------------------------------
      // Modeless selection functions.
      //------------------------------------------------------------------------

      WitPeriod modelessExpPer (WitPart * thePart, WitPeriod fillPer);
         //
         // Same as selExpPer, except that it's valid independent of build-ahead
         // mode.

      WitPeriod modelessExecPer (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Same as selExecPer, except that it's valid independent of 
         // multi-exec mode.

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static bool instNeededFor (WitHeurAtor * theHeurAtor);
         //
         // Returns TRUE, iff a Selector is needed for theHeurAtor.

      void commitMaxQty (double & netQty);
         //
         // Commits the heuristically maximum possible quantity of topPart_ 
         // in topPer_.

      void printCommitMaxQtySel ();
         //
         // Prints a heading for commitMaxQtySel.

      void preCommitSS ();
         //
         // Performs the actions to be taken for selection splitting at the
         // beginning of a commit.

      void postCommit ();
         //
         // Performs the actions to be taken for selection, just after a commit.

      void postTempCommit (bool success);
         //
         // Performs the actions to be taken for selection, just after a 
         // temp-commit.

      void alterSelections ();
         //
         // Alters the selections, as appropriate.
         // Valid only in non-sel-split mode.

      void alterSelSS ();
         //
         // Alters the selection, as appropriate.
         // Valid only in sel-split mode.

      void alterSelection (WitAltPt * theAltPt);
         //
         // Alters the selection at theAltPt, printing as needed.

      void recFillByCons (WitPart * thePart, WitPeriod fillPer);
         //
         // Records that fact that supply was consumed to fill reqs for thePart
         // in fillPer, if appropriate.

      void recFillNetRec (WitPart * thePart, WitPeriod fillPer);
         //
         // Records the fact that net reqs for thePart are being filled in
         // fillPer.

      void rollReq (
            WitMaterial * theMat,
            WitPeriod     fromPer,
            WitPeriod     toPer,
            double        rollVol);
         //
         // Records the fact rollVol units of requirements for theMat is being
         // rolled over from fromPer to toPer.
         // Valid only in stock reallocation mode.

      void placeReqs (
            WitBopEntry *  theBopEnt,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitPeriod      fillPer,
            bool           forNetting);
         //
         // Records the fact that an explosion thru theBopEnt and theConsEnt
         // in execution period execPer to fill requirements in fillPer caused
         // requirements to be placed. 
         // If forNetting is true, then ConsEntry netting is being recorded
         // instead of actual requirement placement.

      void recExecBoundShortage (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            WitPeriod     fillPer);
         //
         // Records the fact that tempCommit failed due to a hard UB on an
         // execVol when exploding thru theBopEnt with execution period 
         // execPer to fill demand in fillPer.

      void recLTBoundShortage (WitPart * thePart, WitPeriod fillPer);
         //
         // Records the fact that tempCommit failed due to a lead time UB when
         // exploding thru thePart to fill demand in fillPer.

      void recFundShortage (WitPart * thePart, WitPeriod fillPer);
         //
         // Records the fact that tempCommit failed, due to insufficient
         // availability of thePart in fillPer. (A fundamemtal shortage)

      void recShortage ();
         //
         // Records the fact that tempCommit failed, for any reason.

      void recCommitVol (double commitVol);
         //
         // See RtAnalyzer::recCommitVol.

      void prepCmqSel ();
         //
         // Prepares for a call to HeurAtor::commitMaxQtySel.

      void recordFlowSS (WitSelPt * theSelPt, double incFlowVol);
         //
         // See WitFlowMonitor::recordFlow.

      bool splitCommActive ();
         //
         // See Splitter::splitCommActive.

      void recoverInitState ();
         //
         // Restores the selection configuration to its initial state.
         // Valid only in selection recovery mode.
         //
         // Implementation in progress.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc    (WitHeurAtor *,  myHeurAtor)
      accessFunc    (bool,           failResAlt)
      accessFunc    (bool,           multiRoute)
      accessFunc    (bool,           penExec)
      accessFunc    (bool,           tbprMode)
      accessFunc    (int,            nAlts)

      accessNonNull (WitRtMgr *,     myRtMgr)
      accessNonNull (WitMrMgr *,     myMrMgr)
      accessNonNull (WitPrMgr *,     myPrMgr)
      accessNonNull (WitBaMgr *,     myBaMgr)
      accessNonNull (WitMeMgr *,     myMeMgr)
      accessNonNull (WitSsrMgr *,    mySsrMgr)
      accessNonNull (WitPenExMgr *,  myPenExMgr)
      accessNonNull (WitSglSrcMgr *, mySglSrcMgr)

      accessFunc    (const WitObjStack <WitAltPt> &,   pendingAlts)
      accessFunc    (const WitList <WitSelMgr> &,      mySelMgrs)
      accessFunc    (const WitPtrTVec <WitFixedPer> &, myFixedPer)

      inline bool propRtg ()
         {
         return (myPrMgr_ != NULL);
         }

      inline bool buildAhead ()
         {
         return (myBaMgr_ != NULL);
         }

      inline bool multiExec ()
         {
         return (myMeMgr_ != NULL);
         }

      inline bool selectiveSR ()
         {
         return (mySsrMgr_ != NULL);
         }

      inline bool selSplit ()
         {
         return (mySplitter_ != NULL);
         }

      inline bool sglSrc ()
         {
         return (mySglSrcMgr_ != NULL);
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitSelector);

      void buildSelMgrs ();
         //
         // Builds the SelMgrs to be owned by this Selector.

      void collectSelMgrs ();
         //
         // Collects each of the SelMgrs owned by this Selector, in downward
         // order.

      void collect (WitSelMgr * theSelMgr);
         //
         // If theSelMgr is not NULL, it is appended to mySelMgrs_.

      bool selSplitNeeded ();
         //
         // Returns true, iff selection splitting is to be performed.

      void innerPlaceReqs (
            WitBopEntry *  theBopEnt,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitPeriod      fillPer,
            WitReqPt *     theReqPt,
            bool           forNetting);
         //
         // Records the fact that an explosion thru theBopEnt and theConsEnt
         // in execution period execPer to fill requirements in fillPer caused
         // requirements to be placed at a location represented by theReqPt.
         // If forNetting is true, then ConsEntry netting is being recorded
         // instead of actual requirement placement.

      void getResAltFromNet (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            WitReqPt *    theReqPt);
         //
         // If any of the ConsEnts for theBomEnt was eligible for netting in
         // execPer and corresponding ReqPt has a resolving alt, the state of
         // that ReqPt is copied into theReqPt.

      bool copyResAlt (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitReqPt *     theReqPt);
         //
         // If theConsEnt was eligible for netting in execPer and corresponding
         // ReqPt has a resolving alt, the state of that ReqPt is copied into
         // theReqPt.

      bool getPendingAlt (WitAltPt * & theAltPt);
         //
         // If pendingAlts_ is non-empty, this function pops the top element off
         // of it, sets the corresponding SelPt to non-pending, and returns
         // true; otherwise this function returns false.

      void printPreAlt ();
         //
         // Does printing appropriate just prior to altering the selection
         // configuration.

      void printInit ();
         //
         // Prints this Selector in its initial state, as appropriate.

      void countAlts ();
         //
         // Print statistics regards the # of alterations.

      inline WitReqPt * myReqPt (WitPart * thePart, WitPeriod thePer);
         //
         // Returns the ReqPt associated with thePart in thePer.

      accessNonNull (WitSplitter *, mySplitter)

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitHeurAtor * const myHeurAtor_;
         //
         // The HeurAtor that owns this Selector.

      WitRtMgr * myRtMgr_;
         //
         // The RtMgr owned by this Selector.

      WitMrMgr * myMrMgr_;
         //
         // The MrMgr owned by this Selector in multi-route mode;
         // otherwise NULL.

      WitPrMgr * myPrMgr_;
         //
         // The PrMgr owned by this Selector in new prop-routing mode;
         // otherwise NULL.

      WitPenExMgr * myPenExMgr_;
         //
         // The PenExMgr owned by this Selector in pen-exec mode;
         // otherwise NULL.

      WitSglSrcMgr * mySglSrcMgr_;
         //
         // The SglSrcMgr owned by this Selector in new single-source mode;
         // otherwise NULL.

      WitReqPtMgr * myReqPtMgr_;
         //
         // The ReqPtMgr owned by this Selector.

      WitSplitter * mySplitter_;
         //
         // The Splitter owned by this Selector, in sel-split for pen-exec
         // mode; otherwise NULL.

      //------------------------------------------------------------------------
      // SelMgrs.
      //------------------------------------------------------------------------

      WitBaMgr * myBaMgr_;
         //
         // The BaMgr owned by this Selector, if any; otherwise NULL.

      WitMeMgr * myMeMgr_;
         //
         // The MeMgr owned by this Selector, if any; otherwise NULL.

      WitSsrMgr * mySsrMgr_;
         //
         // The SsrMgr owned by this Selector, if any; otherwise NULL.

      WitList <WitSelMgr> mySelMgrs_;
         //
         // The SelMgrs owned by this Selector.
         // They are listed in "downward BOM" order, which is the order in which
         // they need to be traversed, when placing requirements (placeReqs ()).

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitObjStack <WitAltPt> pendingAlts_;
         //
         // The AltPts at which the selection configuration is to be altered.

      WitList <int> altCounts_;
         //
         // Only used if selPrintLevel () >= 1.
         // Each element of altCounts corresponds to a batch of alterations.
         // Its value is the # of alterations in the batch.

      bool curResAlt_;
         //
         // true, iff the current temp-commit failed and a resolving alteration
         // to the configuration was found.

      bool failResAlt_;
         //
         // true, iff a resolving alteration to the configuration was found for
         // the most recent failing temp-commit.

      WitMapping <WitMaterial, WitPeriod> & lastConsResAltPer_;
         //
         // lastConsResAltPer_ (theMat) is the last Period in which:
         //    * reqs for theMat were filled by consuming supply, and
         //    * the corresponding ReqPt has a resolving alteration.

      WitObjStack <WitMaterial> nonNegLCRAPMats_;
         //
         // The set of Materials, theMat, for which lastConsResAltPer_ (theMat)
         // is non-negative.

      bool multiRoute_;
         //
         // true, iff the multiple routes technique is to be used.

      bool penExec_;
         //
         // true, iff the penalized execution technique is to be used.

      bool tbprMode_;
         //
         // true, iff the tie breaking prop-rt technique is to be used.

      int nAlts_;
         //
         // # Alterations performed (debugging output).

      WitPtrTVec <WitFixedPer> myFixedPer_;
         //
         // myFixedPer_[thePer]->myPer () == thePer.
   };

#endif
@


1.129
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.128
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d48 1
a48 1
//    What set of BopEntries to use when exploding through a Part (for
d50 1
a50 1
//    What set of ConsEntries to use when exploding through a BomEntry (for
d73 2
a74 191
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitSelector (WitHeurAtor *);

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

virtual ~WitSelector ();

//------------------------------------------------------------------------
// Modeless selection functions.
//------------------------------------------------------------------------

WitPeriod modelessExpPer (WitPart * thePart, WitPeriod fillPer);
//
// Same as selExpPer, except that it's valid independent of build-ahead
// mode.

WitPeriod modelessExecPer (WitBopEntry * theBopEnt, WitPeriod expPer);
//
// Same as selExecPer, except that it's valid independent of
// multi-exec mode.

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

static bool instNeededFor (WitHeurAtor * theHeurAtor);
//
// Returns TRUE, iff a Selector is needed for theHeurAtor.

void commitMaxQty (double & netQty);
//
// Commits the heuristically maximum possible quantity of topPart_
// in topPer_.

void printCommitMaxQtySel ();
//
// Prints a heading for commitMaxQtySel.

void preCommitSS ();
//
// Performs the actions to be taken for selection splitting at the
// beginning of a commit.

void postCommit ();
//
// Performs the actions to be taken for selection, just after a commit.

void postTempCommit (bool success);
//
// Performs the actions to be taken for selection, just after a
// temp-commit.

void alterSelections ();
//
// Alters the selections, as appropriate.
// Valid only in non-sel-split mode.

void alterSelSS ();
//
// Alters the selection, as appropriate.
// Valid only in sel-split mode.

void alterSelection (WitAltPt * theAltPt);
//
// Alters the selection at theAltPt, printing as needed.

void recFillByCons (WitPart * thePart, WitPeriod fillPer);
//
// Records that fact that supply was consumed to fill reqs for thePart
// in fillPer, if appropriate.

void recFillNetRec (WitPart * thePart, WitPeriod fillPer);
//
// Records the fact that net reqs for thePart are being filled in
// fillPer.

void rollReq (
WitMaterial * theMat,
WitPeriod     fromPer,
WitPeriod     toPer,
double        rollVol);
//
// Records the fact rollVol units of requirements for theMat is being
// rolled over from fromPer to toPer.
// Valid only in stock reallocation mode.

void placeReqs (
WitBopEntry *  theBopEnt,
WitConsEntry * theConsEnt,
WitPeriod      execPer,
WitPeriod      fillPer,
bool           forNetting);
//
// Records the fact that an explosion thru theBopEnt and theConsEnt
// in execution period execPer to fill requirements in fillPer caused
// requirements to be placed.
// If forNetting is true, then ConsEntry netting is being recorded
// instead of actual requirement placement.

void recExecBoundShortage (
WitBopEntry * theBopEnt,
WitPeriod     execPer,
WitPeriod     fillPer);
//
// Records the fact that tempCommit failed due to a hard UB on an
// execVol when exploding thru theBopEnt with execution period
// execPer to fill demand in fillPer.

void recLTBoundShortage (WitPart * thePart, WitPeriod fillPer);
//
// Records the fact that tempCommit failed due to a lead time UB when
// exploding thru thePart to fill demand in fillPer.

void recFundShortage (WitPart * thePart, WitPeriod fillPer);
//
// Records the fact that tempCommit failed, due to insufficient
// availability of thePart in fillPer. (A fundamemtal shortage)

void recShortage ();
//
// Records the fact that tempCommit failed, for any reason.

void recCommitVol (double commitVol);
//
// See RtAnalyzer::recCommitVol.

void prepCmqSel ();
//
// Prepares for a call to HeurAtor::commitMaxQtySel.

void recordFlowSS (WitSelPt * theSelPt, double incFlowVol);
//
// See WitFlowMonitor::recordFlow.

bool splitCommActive ();
//
// See Splitter::splitCommActive.

void recoverInitState ();
//
// Restores the selection configuration to its initial state.
// Valid only in selection recovery mode.
//
// Implementation in progress.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc    (WitHeurAtor *,  myHeurAtor)
accessFunc    (bool,           failResAlt)
accessFunc    (bool,           multiRoute)
accessFunc    (bool,           penExec)
accessFunc    (bool,           tbprMode)
accessFunc    (int,            nAlts)

accessNonNull (WitRtMgr *,     myRtMgr)
accessNonNull (WitMrMgr *,     myMrMgr)
accessNonNull (WitPrMgr *,     myPrMgr)
accessNonNull (WitBaMgr *,     myBaMgr)
accessNonNull (WitMeMgr *,     myMeMgr)
accessNonNull (WitSsrMgr *,    mySsrMgr)
accessNonNull (WitPenExMgr *,  myPenExMgr)
accessNonNull (WitSglSrcMgr *, mySglSrcMgr)

accessFunc    (const WitObjStack <WitAltPt> &,   pendingAlts)
accessFunc    (const WitList <WitSelMgr> &,      mySelMgrs)
accessFunc    (const WitPtrTVec <WitFixedPer> &, myFixedPer)

inline bool propRtg ()
{
return (myPrMgr_ != NULL);
}

inline bool buildAhead ()
{
return (myBaMgr_ != NULL);
}

inline bool multiExec ()
{
return (myMeMgr_ != NULL);
}
d76 408
a483 219
inline bool selectiveSR ()
{
return (mySsrMgr_ != NULL);
}

inline bool selSplit ()
{
return (mySplitter_ != NULL);
}

inline bool sglSrc ()
{
return (mySglSrcMgr_ != NULL);
}

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitSelector);

void buildSelMgrs ();
//
// Builds the SelMgrs to be owned by this Selector.

void collectSelMgrs ();
//
// Collects each of the SelMgrs owned by this Selector, in downward
// order.

void collect (WitSelMgr * theSelMgr);
//
// If theSelMgr is not NULL, it is appended to mySelMgrs_.

bool selSplitNeeded ();
//
// Returns true, iff selection splitting is to be performed.

void innerPlaceReqs (
WitBopEntry *  theBopEnt,
WitConsEntry * theConsEnt,
WitPeriod      execPer,
WitPeriod      fillPer,
WitReqPt *     theReqPt,
bool           forNetting);
//
// Records the fact that an explosion thru theBopEnt and theConsEnt
// in execution period execPer to fill requirements in fillPer caused
// requirements to be placed at a location represented by theReqPt.
// If forNetting is true, then ConsEntry netting is being recorded
// instead of actual requirement placement.

void getResAltFromNet (
WitBomEntry * theBomEnt,
WitPeriod     execPer,
WitReqPt *    theReqPt);
//
// If any of the ConsEnts for theBomEnt was eligible for netting in
// execPer and corresponding ReqPt has a resolving alt, the state of
// that ReqPt is copied into theReqPt.

bool copyResAlt (
WitConsEntry * theConsEnt,
WitPeriod      execPer,
WitReqPt *     theReqPt);
//
// If theConsEnt was eligible for netting in execPer and corresponding
// ReqPt has a resolving alt, the state of that ReqPt is copied into
// theReqPt.

bool getPendingAlt (WitAltPt * & theAltPt);
//
// If pendingAlts_ is non-empty, this function pops the top element off
// of it, sets the corresponding SelPt to non-pending, and returns
// true; otherwise this function returns false.

void printPreAlt ();
//
// Does printing appropriate just prior to altering the selection
// configuration.

void printInit ();
//
// Prints this Selector in its initial state, as appropriate.

void countAlts ();
//
// Print statistics regards the # of alterations.

inline WitReqPt * myReqPt (WitPart * thePart, WitPeriod thePer);
//
// Returns the ReqPt associated with thePart in thePer.

accessNonNull (WitSplitter *, mySplitter)

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Associations.
//------------------------------------------------------------------------

WitHeurAtor * const myHeurAtor_;
//
// The HeurAtor that owns this Selector.

WitRtMgr * myRtMgr_;
//
// The RtMgr owned by this Selector.

WitMrMgr * myMrMgr_;
//
// The MrMgr owned by this Selector in multi-route mode;
// otherwise NULL.

WitPrMgr * myPrMgr_;
//
// The PrMgr owned by this Selector in new prop-routing mode;
// otherwise NULL.

WitPenExMgr * myPenExMgr_;
//
// The PenExMgr owned by this Selector in pen-exec mode;
// otherwise NULL.

WitSglSrcMgr * mySglSrcMgr_;
//
// The SglSrcMgr owned by this Selector in new single-source mode;
// otherwise NULL.

WitReqPtMgr * myReqPtMgr_;
//
// The ReqPtMgr owned by this Selector.

WitSplitter * mySplitter_;
//
// The Splitter owned by this Selector, in sel-split for pen-exec
// mode; otherwise NULL.

//------------------------------------------------------------------------
// SelMgrs.
//------------------------------------------------------------------------

WitBaMgr * myBaMgr_;
//
// The BaMgr owned by this Selector, if any; otherwise NULL.

WitMeMgr * myMeMgr_;
//
// The MeMgr owned by this Selector, if any; otherwise NULL.

WitSsrMgr * mySsrMgr_;
//
// The SsrMgr owned by this Selector, if any; otherwise NULL.

WitList <WitSelMgr> mySelMgrs_;
//
// The SelMgrs owned by this Selector.
// They are listed in "downward BOM" order, which is the order in which
// they need to be traversed, when placing requirements (placeReqs ()).

//------------------------------------------------------------------------
// Other private member data.
//------------------------------------------------------------------------

WitObjStack <WitAltPt> pendingAlts_;
//
// The AltPts at which the selection configuration is to be altered.

WitList <int> altCounts_;
//
// Only used if selPrintLevel () >= 1.
// Each element of altCounts corresponds to a batch of alterations.
// Its value is the # of alterations in the batch.

bool curResAlt_;
//
// true, iff the current temp-commit failed and a resolving alteration
// to the configuration was found.

bool failResAlt_;
//
// true, iff a resolving alteration to the configuration was found for
// the most recent failing temp-commit.

WitMapping <WitMaterial, WitPeriod> & lastConsResAltPer_;
//
// lastConsResAltPer_ (theMat) is the last Period in which:
//    * reqs for theMat were filled by consuming supply, and
//    * the corresponding ReqPt has a resolving alteration.

WitObjStack <WitMaterial> nonNegLCRAPMats_;
//
// The set of Materials, theMat, for which lastConsResAltPer_ (theMat)
// is non-negative.

bool multiRoute_;
//
// true, iff the multiple routes technique is to be used.

bool penExec_;
//
// true, iff the penalized execution technique is to be used.

bool tbprMode_;
//
// true, iff the tie breaking prop-rt technique is to be used.

int nAlts_;
//
// # Alterations performed (debugging output).

WitPtrTVec <WitFixedPer> myFixedPer_;
//
// myFixedPer_[thePer]->myPer () == thePer.
};
@


1.127
log
@Selection Recovery
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d48 1
a48 1
//    What set of BopEntries to use when exploding through a Part (for 
d50 1
a50 1
//    What set of ConsEntries to use when exploding through a BomEntry (for 
d73 191
a263 2
   {
   public:
d265 219
a483 408
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSelector (WitHeurAtor *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitSelector ();

      //------------------------------------------------------------------------
      // Modeless selection functions.
      //------------------------------------------------------------------------

      WitPeriod modelessExpPer (WitPart * thePart, WitPeriod fillPer);
         //
         // Same as selExpPer, except that it's valid independent of build-ahead
         // mode.

      WitPeriod modelessExecPer (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Same as selExecPer, except that it's valid independent of 
         // multi-exec mode.

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static bool instNeededFor (WitHeurAtor * theHeurAtor);
         //
         // Returns TRUE, iff a Selector is needed for theHeurAtor.

      void commitMaxQty (double & netQty);
         //
         // Commits the heuristically maximum possible quantity of topPart_ 
         // in topPer_.

      void printCommitMaxQtySel ();
         //
         // Prints a heading for commitMaxQtySel.

      void preCommitSS ();
         //
         // Performs the actions to be taken for selection splitting at the
         // beginning of a commit.

      void postCommit ();
         //
         // Performs the actions to be taken for selection, just after a commit.

      void postTempCommit (bool success);
         //
         // Performs the actions to be taken for selection, just after a 
         // temp-commit.

      void alterSelections ();
         //
         // Alters the selections, as appropriate.
         // Valid only in non-sel-split mode.

      void alterSelSS ();
         //
         // Alters the selection, as appropriate.
         // Valid only in sel-split mode.

      void alterSelection (WitAltPt * theAltPt);
         //
         // Alters the selection at theAltPt, printing as needed.

      void recFillByCons (WitPart * thePart, WitPeriod fillPer);
         //
         // Records that fact that supply was consumed to fill reqs for thePart
         // in fillPer, if appropriate.

      void recFillNetRec (WitPart * thePart, WitPeriod fillPer);
         //
         // Records the fact that net reqs for thePart are being filled in
         // fillPer.

      void rollReq (
            WitMaterial * theMat,
            WitPeriod     fromPer,
            WitPeriod     toPer,
            double        rollVol);
         //
         // Records the fact rollVol units of requirements for theMat is being
         // rolled over from fromPer to toPer.
         // Valid only in stock reallocation mode.

      void placeReqs (
            WitBopEntry *  theBopEnt,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitPeriod      fillPer,
            bool           forNetting);
         //
         // Records the fact that an explosion thru theBopEnt and theConsEnt
         // in execution period execPer to fill requirements in fillPer caused
         // requirements to be placed. 
         // If forNetting is true, then ConsEntry netting is being recorded
         // instead of actual requirement placement.

      void recExecBoundShortage (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            WitPeriod     fillPer);
         //
         // Records the fact that tempCommit failed due to a hard UB on an
         // execVol when exploding thru theBopEnt with execution period 
         // execPer to fill demand in fillPer.

      void recLTBoundShortage (WitPart * thePart, WitPeriod fillPer);
         //
         // Records the fact that tempCommit failed due to a lead time UB when
         // exploding thru thePart to fill demand in fillPer.

      void recFundShortage (WitPart * thePart, WitPeriod fillPer);
         //
         // Records the fact that tempCommit failed, due to insufficient
         // availability of thePart in fillPer. (A fundamemtal shortage)

      void recShortage ();
         //
         // Records the fact that tempCommit failed, for any reason.

      void recCommitVol (double commitVol);
         //
         // See RtAnalyzer::recCommitVol.

      void prepCmqSel ();
         //
         // Prepares for a call to HeurAtor::commitMaxQtySel.

      void recordFlowSS (WitSelPt * theSelPt, double incFlowVol);
         //
         // See WitFlowMonitor::recordFlow.

      bool splitCommActive ();
         //
         // See Splitter::splitCommActive.

      void recoverInitState ();
         //
         // Restores the selection configuration to its initial state.
         // Valid only in selection recovery mode.
         //
         // Implementation in progress.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc    (WitHeurAtor *,  myHeurAtor)
      accessFunc    (bool,           failResAlt)
      accessFunc    (bool,           multiRoute)
      accessFunc    (bool,           penExec)
      accessFunc    (bool,           tbprMode)
      accessFunc    (int,            nAlts)

      accessNonNull (WitRtMgr *,     myRtMgr)
      accessNonNull (WitMrMgr *,     myMrMgr)
      accessNonNull (WitPrMgr *,     myPrMgr)
      accessNonNull (WitBaMgr *,     myBaMgr)
      accessNonNull (WitMeMgr *,     myMeMgr)
      accessNonNull (WitSsrMgr *,    mySsrMgr)
      accessNonNull (WitPenExMgr *,  myPenExMgr)
      accessNonNull (WitSglSrcMgr *, mySglSrcMgr)

      accessFunc    (const WitObjStack <WitAltPt> &,   pendingAlts)
      accessFunc    (const WitList <WitSelMgr> &,      mySelMgrs)
      accessFunc    (const WitPtrTVec <WitFixedPer> &, myFixedPer)

      inline bool propRtg ()
         {
         return (myPrMgr_ != NULL);
         }

      inline bool buildAhead ()
         {
         return (myBaMgr_ != NULL);
         }

      inline bool multiExec ()
         {
         return (myMeMgr_ != NULL);
         }

      inline bool selectiveSR ()
         {
         return (mySsrMgr_ != NULL);
         }

      inline bool selSplit ()
         {
         return (mySplitter_ != NULL);
         }

      inline bool sglSrc ()
         {
         return (mySglSrcMgr_ != NULL);
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitSelector);

      void buildSelMgrs ();
         //
         // Builds the SelMgrs to be owned by this Selector.

      void collectSelMgrs ();
         //
         // Collects each of the SelMgrs owned by this Selector, in downward
         // order.

      void collect (WitSelMgr * theSelMgr);
         //
         // If theSelMgr is not NULL, it is appended to mySelMgrs_.

      bool selSplitNeeded ();
         //
         // Returns true, iff selection splitting is to be performed.

      void innerPlaceReqs (
            WitBopEntry *  theBopEnt,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitPeriod      fillPer,
            WitReqPt *     theReqPt,
            bool           forNetting);
         //
         // Records the fact that an explosion thru theBopEnt and theConsEnt
         // in execution period execPer to fill requirements in fillPer caused
         // requirements to be placed at a location represented by theReqPt.
         // If forNetting is true, then ConsEntry netting is being recorded
         // instead of actual requirement placement.

      void getResAltFromNet (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            WitReqPt *    theReqPt);
         //
         // If any of the ConsEnts for theBomEnt was eligible for netting in
         // execPer and corresponding ReqPt has a resolving alt, the state of
         // that ReqPt is copied into theReqPt.

      bool copyResAlt (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitReqPt *     theReqPt);
         //
         // If theConsEnt was eligible for netting in execPer and corresponding
         // ReqPt has a resolving alt, the state of that ReqPt is copied into
         // theReqPt.

      bool getPendingAlt (WitAltPt * & theAltPt);
         //
         // If pendingAlts_ is non-empty, this function pops the top element off
         // of it, sets the corresponding SelPt to non-pending, and returns
         // true; otherwise this function returns false.

      void printPreAlt ();
         //
         // Does printing appropriate just prior to altering the selection
         // configuration.

      void printInit ();
         //
         // Prints this Selector in its initial state, as appropriate.

      void countAlts ();
         //
         // Print statistics regards the # of alterations.

      inline WitReqPt * myReqPt (WitPart * thePart, WitPeriod thePer);
         //
         // Returns the ReqPt associated with thePart in thePer.

      accessNonNull (WitSplitter *, mySplitter)

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitHeurAtor * const myHeurAtor_;
         //
         // The HeurAtor that owns this Selector.

      WitRtMgr * myRtMgr_;
         //
         // The RtMgr owned by this Selector.

      WitMrMgr * myMrMgr_;
         //
         // The MrMgr owned by this Selector in multi-route mode;
         // otherwise NULL.

      WitPrMgr * myPrMgr_;
         //
         // The PrMgr owned by this Selector in new prop-routing mode;
         // otherwise NULL.

      WitPenExMgr * myPenExMgr_;
         //
         // The PenExMgr owned by this Selector in pen-exec mode;
         // otherwise NULL.

      WitSglSrcMgr * mySglSrcMgr_;
         //
         // The SglSrcMgr owned by this Selector in new single-source mode;
         // otherwise NULL.

      WitReqPtMgr * myReqPtMgr_;
         //
         // The ReqPtMgr owned by this Selector.

      WitSplitter * mySplitter_;
         //
         // The Splitter owned by this Selector, in sel-split for pen-exec
         // mode; otherwise NULL.

      //------------------------------------------------------------------------
      // SelMgrs.
      //------------------------------------------------------------------------

      WitBaMgr * myBaMgr_;
         //
         // The BaMgr owned by this Selector, if any; otherwise NULL.

      WitMeMgr * myMeMgr_;
         //
         // The MeMgr owned by this Selector, if any; otherwise NULL.

      WitSsrMgr * mySsrMgr_;
         //
         // The SsrMgr owned by this Selector, if any; otherwise NULL.

      WitList <WitSelMgr> mySelMgrs_;
         //
         // The SelMgrs owned by this Selector.
         // They are listed in "downward BOM" order, which is the order in which
         // they need to be traversed, when placing requirements (placeReqs ()).

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitObjStack <WitAltPt> pendingAlts_;
         //
         // The AltPts at which the selection configuration is to be altered.

      WitList <int> altCounts_;
         //
         // Only used if selPrintLevel () >= 1.
         // Each element of altCounts corresponds to a batch of alterations.
         // Its value is the # of alterations in the batch.

      bool curResAlt_;
         //
         // true, iff the current temp-commit failed and a resolving alteration
         // to the configuration was found.

      bool failResAlt_;
         //
         // true, iff a resolving alteration to the configuration was found for
         // the most recent failing temp-commit.

      WitMapping <WitMaterial, WitPeriod> & lastConsResAltPer_;
         //
         // lastConsResAltPer_ (theMat) is the last Period in which:
         //    * reqs for theMat were filled by consuming supply, and
         //    * the corresponding ReqPt has a resolving alteration.

      WitObjStack <WitMaterial> nonNegLCRAPMats_;
         //
         // The set of Materials, theMat, for which lastConsResAltPer_ (theMat)
         // is non-negative.

      bool multiRoute_;
         //
         // true, iff the multiple routes technique is to be used.

      bool penExec_;
         //
         // true, iff the penalized execution technique is to be used.

      bool tbprMode_;
         //
         // true, iff the tie breaking prop-rt technique is to be used.

      int nAlts_;
         //
         // # Alterations performed (debugging output).

      WitPtrTVec <WitFixedPer> myFixedPer_;
         //
         // myFixedPer_[thePer]->myPer () == thePer.
   };
@


1.126
log
@Selection Recovery
@
text
@a304 4
      void setUpSelRec ();
         //
         // Sets up selection recovery.

@


1.125
log
@Selection Recovery
@
text
@d219 1
a219 1
      void recoverSelections ();
d221 1
a221 2
         // Restores the selection configuration to its original state,
         // recovering all discarded selection candidates.
@


1.124
log
@Selection Recovery.
@
text
@a218 7
      void recAlteredSelPO (WitSelPt * theSelPt);
         //
         // Records the fact that selection configuration has been altered at
         // theSelPt.
         // Valid only in selection recovery mode.
         // (Old approach)

a480 6
      WitObjStack <WitSelPt> alteredSelPtO_;
         //
         // The SelPts that have been altered from their initial selection
         // Valid only in selection recovery mode.
         // (Old approach)

@


1.123
log
@Selection Recovery
@
text
@d231 2
a232 1
         // (Implementation in progress.)
@


1.122
log
@Selection Recovery.
@
text
@d219 1
a219 1
      void recAlteredSelPt (WitSelPt * theSelPt);
d224 1
d487 1
a487 1
      WitObjStack <WitSelPt> alteredSelPts_;
d491 1
@


1.121
log
@Selection recovery.
@
text
@d311 1
a311 1
      void setUpRecovery ();
@


1.120
log
@Name change: "selection reuse" has becomne "selection recovery".
@
text
@d225 1
a225 1
      void restoreConfig ();
d227 2
a228 1
         // Restores the selection configuration to its original state.
@


1.119
log
@Selection reuse.
@
text
@d223 1
a223 1
         // Valid only in selection reuse mode.
d228 1
a228 1
         // Valid only in selection reuse mode.
d310 1
a310 1
      void setUpReuse ();
d312 1
a312 1
         // Sets up selection reuse.
d488 1
a488 1
         // Valid only in selection reuse mode.
@


1.118
log
@Selection reuse.
@
text
@d115 1
a115 1
      void printCommitMaxQtySelIA ();
d117 1
a117 1
         // Prints a heading for commitMaxQtySel, if appropriate.
d352 1
a352 1
      void printPreAltIA ();
@


1.117
log
@Selection reuse.
@
text
@d223 1
a223 1
         // No-op, if not in reuse mode.
d227 2
a228 1
         // Retores the selection configuration to its original state.
d488 1
a488 1
         // Valid only in reuse mode.
@


1.116
log
@Selection reuse
@
text
@d219 6
d484 5
@


1.115
log
@Selection reuse.
@
text
@d219 5
@


1.114
log
@Selection Reuse.
@
text
@d298 4
@


1.113
log
@Lead Time Bounds
@
text
@a289 4
      void checkForVacuousSelReuse ();
         //
         // Issues warnings for vacuous cases of selection reuse.

@


1.112
log
@Lead Time Bounds
@
text
@d185 1
a185 1
         // Records the fact that tempCommit failed, due to a hard UB on an
d189 5
@


1.111
log
@Selection Reuse.
@
text
@d280 5
@


1.110
log
@Selection Reuse.
@
text
@d280 1
a280 1
      void validateSelReuse ();
d282 1
a282 1
         // Verifies that the data is compatable with selection reuse.
@


1.109
log
@Heuristic search increment.
@
text
@d280 4
@


1.108
log
@Updated the copyright date on all source files.
@
text
@d198 1
a198 1
      void recCommitVol (double commitVol, bool byExp);
@


1.107
log
@Vector PropRtg.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.106
log
@Pegged critical list.
@
text
@d238 1
a238 1
      inline bool propRouting ()
@


1.105
log
@Changed terminology from "low priority proportionate routing" to
"tie breaking proportionate routing".
@
text
@d26 4
a29 6
// Responsible, along with the HeurAtor, for implementing the "multiple
// selections" technique of heuristic allocation. The multiple selections
// technique is a general technique the includes both the multiple routes
// technique and the ASAP build-ahead technique as special cases. The Selector
// is responsible for making the selections. Specifically, it is responsible for
// selecting:
d31 21
a51 4
//    Which  BopEntry to use when exploding thru a Part     (for multiRoute).
//    Which ConsEntry to use when exploding thru a BomEntry (for multiRoute).
//    Which explosion period to use when filling demand at a buildAsap Material.
//       (for ASAP build-ahead).
d56 14
a69 1
// The selections for multiRoute are called the "routing".
@


1.104
log
@Low-Pri Prop-Rt.
@
text
@d194 1
a194 1
      accessFunc    (bool,           lpprMode)
d427 1
a427 1
      bool lpprMode_;
d429 1
a429 1
         // true, iff the low-pri prop-rt technique is to be used.
@


1.103
log
@Low-Pri Prop-Rt.
@
text
@d190 15
a204 16
      accessFunc    (WitHeurAtor *,   myHeurAtor)
      accessFunc    (bool,            failResAlt)
      accessFunc    (bool,            multiRoute)
      accessFunc    (bool,            penExec)
      accessFunc    (bool,            lpprMode)
      accessFunc    (int,             nAlts)

      accessNonNull (WitRtMgr *,      myRtMgr)
      accessNonNull (WitMrMgr *,      myMrMgr)
      accessNonNull (WitPrMgr *,      myPrMgr)
      accessNonNull (WitBaMgr *,      myBaMgr)
      accessNonNull (WitMeMgr *,      myMeMgr)
      accessNonNull (WitSsrMgr *,     mySsrMgr)
      accessNonNull (WitExpRest *,    myExpRest)
      accessNonNull (WitRtAnalyzer *, myRtAnalyzer)
      accessNonNull (WitSglSrcMgr *,  mySglSrcMgr)
d343 1
a343 1
      WitExpRest * myExpRest_;
d345 1
a345 6
         // The ExpRest owned by this Selector in pen-exec mode;
         // otherwise NULL.

      WitRtAnalyzer * myRtAnalyzer_;
         //
         // The RtAnalyzer owned by this Selector in pen-exec mode;
@


1.102
log
@Low-Pri Prop-Rt.
@
text
@a198 1
      accessNonNull (WitPoMgr *,      myPoMgr)
d213 1
a213 1
         return (myPoMgr_ != NULL) or (myPrMgr_ != NULL);
a338 5
      WitPoMgr * myPoMgr_;
         //
         // The PoMgr owned by this Selector in old prop-routing mode;
         // otherwise NULL.

@


1.101
log
@Low-Pri Prop-Rt.
@
text
@d115 1
a115 1
      void alterSelection (WitSelAlt * theSelAlt);
d117 1
a117 1
         // Alters the selection with theSelAlt, printing as needed.
d208 1
a208 1
      accessFunc    (const WitObjStack <WitSelAlt> &,  pendingAlts)
d294 1
a294 1
      bool getPendingAlt (WitSelAlt * & theSelAlt);
d400 1
a400 1
      WitObjStack <WitSelAlt> pendingAlts_;
d402 1
a402 1
         // The SelAlts with which the configuration is to be altered.
@


1.100
log
@Low-Pri Prop-Rt.
@
text
@d200 1
d214 1
a214 1
         return (myPoMgr_ != NULL);
@


1.99
log
@Low-Pri Prop-Rt.
@
text
@d341 6
a346 1
         // The PoMgr owned by this Selector in prop-routing mode;
@


1.98
log
@Low-Pri Prop-Rt.
@
text
@d115 1
a115 1
      void alterSelection (WitSelPt * theSelPt);
d117 1
a117 1
         // Alters the selection at theSelPt, printing as needed.
d207 1
a208 1
      accessFunc    (const WitObjStack <WitSelPt> &,   pendingPts)
d293 1
a293 1
      bool getPendingPt (WitSelPt * & theSelPt);
d295 3
a297 3
         // If pendingPts_ is non-empty, pops the top element off of 
         // pendingPts_, sets theSelPt to it,  sets theSelPt to non-pending, and
         // returns true; otherwise returns false.
d394 1
a394 1
      WitObjStack <WitSelPt> pendingPts_;
d396 1
a396 1
         // The SelPts at which the configuration is to be altered.
@


1.97
log
@Low-Pri Prop-Rt.
@
text
@d199 1
a199 1
      accessNonNull (WitPrMgr *,      myPrMgr)
d213 1
a213 1
         return (myPrMgr_ != NULL);
d339 1
a339 1
      WitPrMgr * myPrMgr_;
d341 1
a341 1
         // The PrMgr owned by this Selector in prop-routing mode;
@


1.96
log
@Continued implementation of proportionate routing.
@
text
@d194 1
d433 4
@


1.95
log
@Continued implementation of proportionate routing.
@
text
@a259 4
      void applyPropRtRest ();
         //
         // Applies the restrictions on the use of proportationate routing.

@


1.94
log
@Continued implementation of proportionate routing.
Fixed a bug in selection splitting for selective stock reallocation.
@
text
@d133 1
a133 2
            double        rollVol,
            bool          bddSsrSplit);
a137 1
         // bddSsrSplit is true, iff the rollVol is for a bounded split of SSR.
@


1.93
log
@Continued implementation of proportionate routing.
@
text
@d133 2
a134 1
            double        rollVol);
d139 1
@


1.92
log
@Continued implementation of proportionate routing.
@
text
@d20 1
d206 3
a208 2
      accessFunc    (const WitList <WitSelMgr> &,    mySelMgrs)
      accessFunc    (const WitObjStack <WitSelPt> &, pendingPts)
d439 4
@


1.91
log
@Continued implementation of proportionate routing.
@
text
@d196 1
a196 2
      accessNonNull (WitPmrMgr *,     myPmrMgr)
      accessNonNull (WitCmrMgr *,     myCmrMgr)
a249 4
      static bool multiRouteNeededFor (WitProblem * theProblem);
         //
         // Returns true, iff multi-route is to be performed on theProblem.

d335 5
a371 8

      WitPmrMgr * myPmrMgr_;
         //
         // The PmrMgr owned by this Selector, if any; otherwise NULL.

      WitCmrMgr * myCmrMgr_;
         //
         // The CmrMgr owned by this Selector, if any; otherwise NULL.
@


1.90
log
@Continued implementation of proportionate routing.
@
text
@a189 1
      accessFunc    (WitRtMgr *,      myRtMgr)
d195 1
d336 1
a336 1
      WitRtMgr * const myRtMgr_;
d338 1
a338 1
         // The RtMgr for this Selector.
@


1.89
log
@Continued implementation of proportionate routing.
@
text
@a195 2
      accessNonNull (WitProdOrMgr *,  myProdOrMgr)
      accessNonNull (WitConsOrMgr *,  myConsOrMgr)
a250 5
      static bool oldRtNeededFor (WitProblem * theProblem);
         //
         // Returns true, iff the routing element subsystem is needed for
         // theProblem.

a338 10

      WitProdOrMgr * myProdOrMgr_;
         //
         // The ProdOrMgr owned by this Selector in routing mode;
         // otherwise NULL.

      WitConsOrMgr * myConsOrMgr_;
         //
         // The ConsOrMgr owned by this Selector in routing mode;
         // otherwise NULL.
@


1.88
log
@Continued implementation of proportionate routing.
@
text
@a192 1
      accessFunc    (bool,            oldPr)
a199 2
      accessNonNull (WitProdOpMgr *,  myProdOpMgr)
      accessNonNull (WitConsOpMgr *,  myConsOpMgr)
d262 1
a262 6
      static bool oldPrNeededFor (WitProblem * theProblem);
         //
         // Returns true, iff old proportionate routing is to be performed on
         // theProblem.

      void include (WitSelMgr * theSelMgr);
a397 8
      WitProdOpMgr * myProdOpMgr_;
         //
         // The ProdOpMgr owned by this Selector, if any; otherwise NULL.

      WitConsOpMgr * myConsOpMgr_;
         //
         // The ConsOpMgr owned by this Selector, if any; otherwise NULL.

a453 4

      bool oldPr_;
         //
         // true, iff the old proportionate routing technique is to be used.
@


1.87
log
@Continued implementation of proportionate routing.
@
text
@d190 1
d193 1
a193 1
      accessFunc    (bool,            propRouting)
d203 1
d214 5
d256 1
a256 1
      static bool routingNeededFor (WitProblem * theProblem);
d265 1
a265 1
      static bool propRtNeededFor (WitProblem * theProblem);
d267 1
a267 1
         // Returns true, iff proportionate routing is to be performed on
d351 4
d365 5
d471 1
a471 1
      bool propRouting_;
d473 1
a473 1
         // true, iff the proportionate routing technique is to be used.
@


1.86
log
@Continued implementation of proportionate routing.
@
text
@d200 2
a201 2
      accessNonNull (WitProdPrMgr *,  myProdPrMgr)
      accessNonNull (WitConsPrMgr *,  myConsPrMgr)
d390 1
a390 1
      WitProdPrMgr * myProdPrMgr_;
d392 1
a392 1
         // The ProdPrMgr owned by this Selector, if any; otherwise NULL.
d394 1
a394 1
      WitConsPrMgr * myConsPrMgr_;
d396 1
a396 1
         // The ConsPrMgr owned by this Selector, if any; otherwise NULL.
@


1.85
log
@Continued implementation of proportionate routing.
@
text
@d254 4
d262 4
@


1.84
log
@Continued implementation of proportionate routing.
@
text
@d196 2
a197 2
      accessNonNull (WitProdRtMgr *,  myProdRtMgr)
      accessNonNull (WitConsRtMgr *,  myConsRtMgr)
d336 1
a336 1
      WitProdRtMgr * myProdRtMgr_;
d338 1
a338 1
         // The ProdRtMgr owned by this Selector in routing mode;
d341 1
a341 1
      WitConsRtMgr * myConsRtMgr_;
d343 1
a343 1
         // The ConsRtMgr owned by this Selector in routing mode;
@


1.83
log
@Continued implementation of proportionate routing.
@
text
@d192 1
d201 1
a211 5
      inline bool propRouting ()
         {
         return (myProdPrMgr_ != NULL);
         }

d249 10
d386 4
d446 4
@


1.82
log
@Continued implementation of proportionate routing.
@
text
@d199 1
a199 1
      accessNonNull (WitPprMgr *,     myPprMgr)
d212 1
a212 1
         return (myPprMgr_ != NULL);
d375 1
a375 1
      WitPprMgr * myPprMgr_;
d377 1
a377 1
         // The PprMgr owned by this Selector, if any; otherwise NULL.
@


1.81
log
@Continued implementation of proportionate routing.
@
text
@d196 1
d332 5
@


1.80
log
@Continued implementation of proportionate routing.
@
text
@d195 1
a195 1
      accessNonNull (WitRtMgr *,      myRtMgr)
d328 1
a328 1
      WitRtMgr * myRtMgr_;
d330 2
a331 1
         // The RtMgr owned by this Selector in routing mode; otherwise NULL.
@


1.79
log
@Continued implementation of proportionate routing.
@
text
@d198 1
a198 1
      accessNonNull (WitPrMgr *,      myPrMgr)
d211 1
a211 1
         return (myPrMgr_ != NULL);
d368 1
a368 1
      WitPrMgr * myPrMgr_;
d370 1
a370 1
         // The PrMgr owned by this Selector, if any; otherwise NULL.
@


1.78
log
@Continued implementation of proportionate routing.
@
text
@a184 4
      static bool propRouting (WitPart * thePart);
         //
         // Returns true, iff proportionate routing is to be used at thePart.

@


1.77
log
@Continued implementation of proportionate routing.
@
text
@d199 1
@


1.76
log
@Continued implementation of Proportionate Routing.
@
text
@d331 4
@


1.75
log
@Continued implementation of proportionate routing.
@
text
@d185 4
@


1.74
log
@Continued implementation of Proportionate Routing.
@
text
@d197 1
d208 5
d254 4
d362 4
@


1.73
log
@Internal changes.
@
text
@d77 4
d191 1
@


1.72
log
@Removed implementation of single-source by the old algorithm.
@
text
@d95 1
a95 1
      void postTempCommit (WitBoolean success);
d139 1
a139 1
            WitBoolean     forNetting);
d144 1
a144 1
         // If forNetting is TRUE, then ConsEntry netting is being recorded
d165 1
a165 1
      void recCommitVol (double commitVol, WitBoolean byExp);
d177 1
a177 1
      WitBoolean splitCommActive ();
d186 2
a187 2
      accessFunc    (WitBoolean,      failResAlt)
      accessFunc    (WitBoolean,      penExec)
d202 1
a202 1
      inline WitBoolean buildAhead ()
d207 1
a207 1
      inline WitBoolean multiExec ()
d212 1
a212 1
      inline WitBoolean selectiveSR ()
d217 1
a217 1
      inline WitBoolean selSplit ()
d222 1
a222 1
      inline WitBoolean sglSrc ()
d239 1
a239 1
      WitBoolean selSplitNeeded ();
d241 1
a241 1
         // Returns TRUE, iff selection splitting is to be performed.
d249 1
a249 1
            WitBoolean     forNetting);
d254 1
a254 1
         // If forNetting is TRUE, then ConsEntry netting is being recorded
d266 1
a266 1
      WitBoolean copyResAlt (
d275 1
a275 1
      WitBoolean getPendingPt (WitSelPt * & theSelPt);
d279 1
a279 1
         // returns TRUE; otherwise returns FALSE.
d380 1
a380 1
      WitBoolean curResAlt_;
d382 1
a382 1
         // TRUE, iff the current temp-commit failed and a resolving alteration
d385 1
a385 1
      WitBoolean failResAlt_;
d387 1
a387 1
         // TRUE, iff a resolving alteration to the configuration was found for
d401 1
a401 1
      WitBoolean multiRoute_;
d403 1
a403 1
         // TRUE, iff the multiple routes technique is to be used.
d405 1
a405 1
      WitBoolean penExec_;
d407 1
a407 1
         // TRUE, iff the penalized execution technique is to be used.
@


1.71
log
@Continued implementation of single-source with the new algorithm.
@
text
@a196 1
      accessNonNull (WitOldSglMgr *,  myOldSglMgr)
a221 5
      inline WitBoolean oldSglSrc ()
         {
         return (myOldSglMgr_ != NULL);
         }

a319 5
         // otherwise NULL.

      WitOldSglMgr * myOldSglMgr_;
         //
         // The OldSglMgr owned by this Selector in old single-source mode;
@


1.70
log
@Began implementation of the new single-source algorithm.
@
text
@d198 1
d228 5
d330 6
a335 1
         // The OldSglMgr owned by this Selector in single-source mode;
@


1.69
log
@Fixed the "interference bug" in Single-Source.
@
text
@d197 1
a197 1
      accessNonNull (WitSglSrcMgr *,  mySglSrcMgr)
d222 1
a222 1
      inline WitBoolean singleSource ()
d224 1
a224 1
         return (mySglSrcMgr_ != NULL);
d322 1
a322 1
      WitSglSrcMgr * mySglSrcMgr_;
d324 1
a324 1
         // The SglSrcMgr owned by this Selector in single-source mode;
@


1.68
log
@Continued implementation of Single-Source.
@
text
@d156 1
a156 1
      void recFundShortage (WitPart * thePart, WitPeriod thePer);
d159 1
a159 1
         // availability of thePart in thePer. (A fundamemtal shortage)
d169 1
a169 1
      void resetResAlt ();
d171 1
a171 1
         // Sets failResAlt_ to FALSE.
@


1.67
log
@Continued implementation of single-source.
@
text
@d105 1
a105 1
      WitBoolean getPendingPt (WitSelPt * & theSelPt);
d107 2
a108 3
         // If pendingPts_ is non-empty, pops the top element off of 
         // pendingPts_, sets theSelPt to it,  sets theSelPt to non-pending, and
         // returns TRUE; otherwise returns FALSE.
d275 6
a296 4

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------
@


1.66
log
@Continued implementation of single-source.
@
text
@d100 5
a274 5

      void alterSelections ();
         //
         // Alters the selections, as appropriate.
         // Valid only in non-sel-split mode.
@


1.65
log
@Continued implementation of single source.
@
text
@d198 15
d218 1
a218 1
      inline WitBoolean sglSrc ()
a234 4
      WitBoolean ssrNeeded ();
         //
         // Returns TRUE, iff selective stock reallocation is needed.

a291 14

      inline WitBoolean buildAhead ()
         {
         return (myBaMgr_ != NULL);
         }
         // 
         // Returns TRUE, iff global build-ahead is to be used.

      inline WitBoolean multiExec ()
         {
         return (myMeMgr_ != NULL);
         }
         // 
         // Returns TRUE, iff multi-exec is to be used.
@


1.64
log
@Continued implementation of single source.
@
text
@d203 5
@


1.63
log
@Continued preliminary work on single source.
@
text
@d193 1
d317 5
@


1.62
log
@Preliminary work on single source.
@
text
@a19 1
#include <Mapping.h>
d381 1
a381 1
      WitMapping (WitMaterial, WitPeriod) lastConsResAltPer_;
@


1.61
log
@Continued implementation of sel-split for pen-exec.
@
text
@d195 1
a195 1
      accessFunc    (const WitList (WitSelMgr) &,    mySelMgrs)
d352 1
a352 1
      WitList (WitSelMgr) mySelMgrs_;
d366 1
a366 1
      WitList (int) altCounts_;
@


1.60
log
@Continued implementation of sel-split for pen-exec.
@
text
@d172 1
a172 1
         // See Splitter::recordFlow.
d223 1
a223 1
      void placeReqsNss (
a235 1
         // Valid in non-selection-splitting mode only.
a254 20
      void placeReqsSS (
            WitBopEntry *  theBopEnt,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitPeriod      fillPer,
            WitReqPt *     theReqPt,
            WitBoolean     forNetting);
         //
         // Records the fact that an explosion thru theBopEnt and theConsEnt
         // in execution period execPer to fill requirements in fillPer caused
         // requirements to be placed at a location represented by theReqPt.
         // If forNetting is TRUE, then ConsEntry netting is being recorded
         // instead of actual requirement placement.
         // Valid in selection-splitting mode only.

      WitBoolean findUnbndSelMgrs ();
         //     
         // Sets unbndSelMgrs_.
         // Returns TRUE, iff at least one bounded split was found.

a391 10

      WitObjStack <WitSelMgr> revSelMgrs_;
         //
         // The SelMgrs owned by this Selector, in upward order.
         // Used in sel-split.

      WitObjStack <WitSelMgr> unbndSelMgrs_;
         //
         // During placeReqsSS, this is the SelMgrs owned by this Selector, that
         // have no bounded split below them, in downward order.
@


1.59
log
@Continued implementation of sel-split for pen-exec.
@
text
@a45 2
      friend WitSplitMgr;

d87 5
d166 12
d182 15
a196 14
      accessFunc    (WitHeurAtor *,               myHeurAtor)
      accessFunc    (WitBoolean,                  penExec)
      accessFunc    (const WitList (WitSelMgr) &, mySelMgrs)
      accessFunc    (int,                         nAlts)

      accessNonNull (WitPmrMgr *,                 myPmrMgr)
      accessNonNull (WitCmrMgr *,                 myCmrMgr)
      accessNonNull (WitBaMgr *,                  myBaMgr)
      accessNonNull (WitMeMgr *,                  myMeMgr)
      accessNonNull (WitSsrMgr *,                 mySsrMgr)
      accessNonNull (WitExpRest *,                myExpRest)
      accessNonNull (WitRtAnalyzer *,             myRtAnalyzer)
      accessNonNull (WitSplitter *,               mySplitter)
      accessNonNull (WitSplitMgr *,               mySplitMgr)
d313 6
d346 1
a346 6
         // The Splitter owned by this Selector, in sel-split mode; 
         // otherwise NULL.

      WitSplitMgr * mySplitMgr_;
         //
         // The SplitMgr owned by this Selector, in sel-split for pen-exec
@


1.58
log
@Continued implementation of sel-split for pen-exec.
@
text
@d46 1
a46 1
      friend WitSsPeMgr;
d180 1
a180 1
      accessNonNull (WitSsPeMgr *,                mySsPeMgr)
d327 1
a327 1
      WitSsPeMgr * mySsPeMgr_;
d329 2
a330 2
         // The SsPeMgr owned by this Selector, in sel-split for pen-exec mode; 
         // otherwise NULL.
@


1.57
log
@Continued implementation of sel-split for pen-exec.
@
text
@d180 1
@


1.56
log
@Continued implementation sel-split for pen-exec.
@
text
@a88 5
      void printPreAltIA ();
         //
         // Does printing appropriate just prior to altering the selection
         // configuration.

d263 5
@


1.55
log
@Continued implementation of sel-split for pen-exec.
@
text
@d226 18
@


1.54
log
@Continued implementation of sel-split for pen-exec.
@
text
@d137 2
a138 1
            WitPeriod      fillPer);
d143 2
d216 2
a217 1
            WitReqPt *     theReqPt);
d222 2
d231 2
a232 1
            WitReqPt *     theReqPt);
d237 2
d241 5
d377 10
@


1.53
log
@Continued implementation of sel-split for pen-exec,
@
text
@d143 1
a143 1
      void recordExecBoundShortage (
d152 1
a152 1
      void recordShortage (WitPart * thePart, WitPeriod thePer);
d157 4
d204 1
a204 1
      void setUpSelSplit ();
d206 1
a206 2
         // Determines whether or not selection splitting is to be performed
         // and if so, sets up selection splitting.
@


1.52
log
@Continued implementation of sel-split fpr pen-exec.
@
text
@a160 7
      void mergeSplitBopEnts (
            WitPart *        thePart,
            WitPeriod        expPer,
            WitBopEntStack & expBopEnts);
         //
         // See SsPeMgr::mergeSplitBopEnts.

@


1.51
log
@Continued implementation of sel-split for pen-exec.
@
text
@d161 7
@


1.50
log
@Continued implementation of sel-split for pen-exec.
@
text
@d98 1
a98 1
      void postTempCommit (WitBoolean & success);
d101 1
a101 1
         // temp-commit, updating success, if appropriate.
@


1.49
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d98 1
a98 1
      void postTempCommit (WitBoolean success);
d101 1
a101 1
         // temp-commit.
@


1.48
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d46 2
d288 6
a293 1
         // The Splitter owned by this Selector, in sel-split mide; 
@


1.47
log
@Changed some comments.
@
text
@d121 5
a125 1
      void rollReq (WitMaterial * theMat, WitPeriod fromPer, WitPeriod toPer);
d127 2
a128 2
         // Records the fact a requirement for theMat is being rolled over
         // from fromPer to toPer.
@


1.46
log
@Fixed a NULL pointer bug.
@
text
@d32 1
d37 4
a40 1
// These selections are called the "selection scheme".
d89 2
a90 2
         // Does printing appropriate just prior to altering the selection 
         // scheme.
d321 1
a321 1
         // The SelPts at which the selection scheme is to be altered.
d332 1
a332 1
         // to the selection scheme was found.
d336 2
a337 2
         // TRUE, iff a resolving alteration to the selection scheme was found
         // for the most recent failing temp-commit.
@


1.45
log
@Continued implementation of selective stock reallocation.
@
text
@d186 1
a186 1
      void recordSelMgr (WitSelMgr * theSelMgr);
d188 1
a188 1
         // Adds theSelMgr to mySelMgrs_, if not NULL.
@


1.44
log
@Continued implementation of selective stock reallocation.
@
text
@d117 1
a117 1
      void rollReq (WitPart * thePart, WitPeriod fromPer, WitPeriod toPer);
d119 1
a119 1
         // Records the fact a requirement for thePart is being rolled over
d194 24
@


1.43
log
@Continuing implementation of selective stock reallocation.
@
text
@d164 1
@


1.42
log
@Initial implementation of pegging.
@
text
@d276 4
@


1.41
log
@Converted several generic classes into class templates.
@
text
@d26 1
a26 1
// Responsible, along with the HeurAllPerf, for implementing the "multiple
d48 1
a48 1
      WitSelector (WitHeurAllPerf *);
d155 1
a155 1
      accessFunc    (WitHeurAllPerf *,            myHeurAllPerf)
d233 1
a233 1
      WitHeurAllPerf * const myHeurAllPerf_;
d235 1
a235 1
         // The HeurAllPerf that owns this Selector.
@


1.40
log
@Refactoring.
@
text
@d286 1
a286 1
      WitObjStack (WitSelPt) pendingPts_;
d312 1
a312 1
      WitObjStack (WitMaterial) nonNegLCRAPMats_;
@


1.39
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@d60 1
a60 1
      WitPeriod modelessExpPeriod (WitPart * thePart, WitPeriod fillPer);
d62 2
a63 2
         // Same as selExpPeriod, except that it's valid independent of
         // build-ahead mode.
d65 1
a65 1
      WitPeriod modelessExecPeriod (WitBopEntry * theBopEnt, WitPeriod expPer);
d67 1
a67 1
         // Same as selExecPeriod, except that it's valid independent of 
@


1.38
log
@Renamed AltPt classes to SelPt classes.
@
text
@d189 5
@


1.37
log
@Removed class MePrinter.
@
text
@d97 1
a97 1
      WitBoolean getPendingPt (WitAltPt * & theAltPt);
d100 1
a100 1
         // pendingPts_, sets theAltPt to it,  sets theAltPt to non-pending, and
d103 1
a103 1
      void alterSelection (WitAltPt * theAltPt);
d105 1
a105 1
         // Alters the selection at theAltPt, printing as needed.
d281 1
a281 1
      WitObjStack (WitAltPt) pendingPts_;
d283 1
a283 1
         // The AltPts at which the selection scheme is to be altered.
@


1.36
log
@Removed class MeAltPt.
Changed name of class MeSelPt to MeAltPt.
Implemented de-selection of colliding MeAltPts.
@
text
@a201 5
      WitMePrinter * myMePrinter ();
         //
         // Returns the MePrinter for printing the multi-exec subsystem for this
         // Selector. Valid only in multi-exec mode.

@


1.35
log
@Added incAllocMsg.
@
text
@a87 4
      void printPostAltIA ();
         //
         // Does printing appropriate just after altering the selection scheme.

@


1.34
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@a192 4
      void printCommitMaxQtyIA ();
         //
         // Prints a heading for commitMaxQty, if appropriate.

@


1.33
log
@Refactoring for selection splitting.
@
text
@a176 7
      inline static WitSelector * altPrtInst ()
         {
         witAssert (altPrtInst_ != NULL);

         return altPrtInst_;
         }

a331 5

      static WitSelector * altPrtInst_;
         //
         // The instance of this class which is currently doing alteration
         // printing, if any, else NULL.
@


1.32
log
@Added various counts to the debugging output of selection splitting.
@
text
@d164 2
a165 2
      accessNonNull (WitProdRtr *,                myProdRtr)
      accessNonNull (WitConsRtr *,                myConsRtr)
d275 1
a275 1
      WitProdRtr * myProdRtr_;
d277 1
a277 1
         // The ProdRtr owned by this Selector, if any; otherwise NULL.
d279 1
a279 1
      WitConsRtr * myConsRtr_;
d281 1
a281 1
         // The ConsRtr owned by this Selector, if any; otherwise NULL.
@


1.31
log
@Continued implementation of selection splitting.
@
text
@d162 1
d344 4
@


1.30
log
@Continued implementation of selection splitting with the new design.
@
text
@d74 1
a74 1
      void initMultiSelLoop ();
d76 2
a77 1
         // Takes action appropriate just before the multi-selection loop.
d79 1
a79 1
      WitBoolean contMultiSelLoop ();
d81 6
a86 3
         // Takes action appropriate just before a potential iteration of the 
         // multi-selection loop. 
         // Returns TRUE, iff an iteration should be performed.
d88 1
a88 1
      void printCommitMaxQtySelIA ();
d90 1
a90 1
         // Prints a heading for commitMaxQtySel, if appropriate.
d199 5
a203 1
      WitBoolean findFreshScheme ();
d205 2
a206 2
         // Attempts to find a selection scheme suitable for the current 
         // allocation. Returns TRUE, iff it succeeds.
a211 9
      void printPreAlt ();
         //
         // Does printing appropriate just prior to altering the selection 
         // scheme.

      void printPostAlt ();
         //
         // Does printing appropriate just after altering the selection scheme.

a337 4

      WitBoolean mslInitState_;
         //
         // TRUE, iff the multi-selection loop is in its initial state.
@


1.29
log
@Continued implementation of selection splitting with the new design.
@
text
@d103 4
d172 7
a208 5
      void print (WitAltPt * theAltPt);
         //
         // Prints as appropriate just after altering the selection scheme at
         // theAltPoint.

d343 5
@


1.28
log
@Continued implementation of selection splitting with the new design.
@
text
@d74 1
a74 1
      void initMultiSelLoop (WitPart * thePart, WitPeriod thePer);
d84 1
a84 1
      void printCommitMaxQtySelIA (WitPart * thePart, WitPeriod thePer);
a96 5
      WitBoolean tempCommit1SS ();
         //
         // Does a temp-commit if 1 unit of top level vol for selection 
         // splitting.
                                                                                
d151 11
a161 44
      accessFunc (WitHeurAllPerf *, myHeurAllPerf)
      accessFunc (WitBoolean,       penExec)

      inline WitProdRtr * myProdRtr ()
         {
         witAssert (multiRoute_);

         return myProdRtr_;
         }

      inline WitConsRtr * myConsRtr ()
         {
         witAssert (multiRoute_);

         return myConsRtr_;
         }

      inline WitBaMgr * myBaMgr ()
         {
         witAssert (buildAhead ());

         return myBaMgr_;
         }
 
      inline WitMeMgr * myMeMgr ()
         {
         witAssert (multiExec ());

         return myMeMgr_;
         }

      inline WitExpRest * myExpRest ()
         {
         witAssert (penExec_);

         return myExpRest_;
         }

      inline WitSplitter * mySplitter ()
         {
         witAssert (mySplitter_ != NULL);

         return mySplitter_;
         }
a183 6
      void modifyRouting (WitPart * thePart, WitPeriod thePer);
         //
         // Modifies the current routing as appropriate in order to fill a small
         // incremental requirement for thePart in thePer at a heuristically
         // minimal exec penalty.

a188 14
      void splitCommit (WitAltPt * theAltPt);
         //
         // Does a split-commit on theAltPt.
         // Valid only in sel-split mode.

      void splitItr (WitBoolean & tempCommOK, WitBoolean & resFound);
         //
         // Does one iteration of a split-commit.
         // On return:
         //    tempCommOK is TRUE, iff the initial temp-commit was successful.
         //    resFound is TRUE, iff a resolving alteration was found and 
         //       performed.
         // Valid only in sel-split mode.

a332 10

      WitPart * mslPart_;
         //
         // The top-level Part for the multi-selection loop, during the loop;
         // otherwise NULL.

      WitPeriod mslPer_;
         //
         // The top-level Period for the multi-selection loop, during the loop;
         // otherwise -1.
@


1.27
log
@Continued implementation of selection splitting.
@
text
@d74 1
a74 1
      void prepCommitMaxQtyMultiSel (WitPart * thePart, WitPeriod thePer);
d76 3
a78 4
         // Takes action appropriate at the start of a call to
         // HeurAllPerf::commitMaxQtyMultiSel.
         
      void prepCommitMaxQtySel (WitPart * thePart, WitPeriod thePer);
d80 3
a82 2
         // Takes actions for selection appropriate just prior to calling
         // commitMaxQtySel.
a87 20
      WitBoolean findFreshScheme ();
         //
         // Attempts to find a selection scheme suitable for the current 
         // allocation. Returns TRUE, iff it succeeds.

      void splitCommit ();
         //
         // Does a split-commit.
         // Valid only in sel-split mode.

      void splitItr (WitBoolean & resFound, WitBoolean & needToSplit);
         //
         // Does one iteration of a split-commit.
         // On return:
         //    resFound is TRUE, iff a resolving alteration was found.
         //    needToSplit is TRUE, iff the selection needs to be split.
         //    If resFound is TRUE and needToSplit is FALSE, splitItr will have
         //       carried out the resolving alteration.
         // Valid only in sel-split mode.

d96 5
d102 6
d196 1
a196 1
         witAssert (selSplit ());
d228 19
d391 14
@


1.26
log
@Continued implementation of selection splitting.
@
text
@d81 3
a83 3
         // Takes action appropriate at the start of a call to
         // HeurAllPerf::commitMaxQtySel.
         
d94 13
d108 1
a108 1
      void postCommit (WitBoolean tempMode, WitBoolean success);
d112 5
d353 6
a358 1
      WitBoolean resolvingAlt_;
d360 2
a361 2
         // TRUE, iff the current planned selection scheme alteration has the
         // potential to resolve the current shortage.
@


1.25
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d74 1
a74 1
      void printHeadingIA (WitPart * thePart, WitPeriod thePer);
d76 7
a82 2
         // Prints a heading for selecting for thePart in thePer, if
         // appropriate.
d93 2
a138 6
      void modifyRouting (WitPart * thePart, WitPeriod thePer);
         //
         // Modifies the current routing as appropriate in order to fill a small
         // incremental requirement for thePart in thePer at a heuristically
         // minimal exec penalty.

d213 6
a221 4

      WitBoolean innerFindFresh ();
         //
         // Does most of thw work of findFreshScheme.
@


1.24
log
@Made multi-select trace-back for netting active even without selection
splitting.
@
text
@a147 1
      accessFunc (WitBoolean,       selSplit)
d184 12
d216 4
d287 5
a354 4

      WitBoolean selSplit_;
         //
         // TRUE, iff selection splitting is to be performed.
@


1.23
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@a95 1
         // Valid only in sel-split mode.
d97 1
a97 1
      void recFillNetRecSS (WitPart * thePart, WitPeriod fillPer);
d317 11
a338 12

      WitMapping (WitMaterial, WitPeriod) lastConsResAltPer_;
         //
         // lastConsResAltPer_ (theMat) is the last Period in which:
         //    * reqs for theMat were filled by consuming supply, and
         //    * the corresponding ReqPt has a resolving alteration.
         // Valid only in sel-split mode.

      WitObjStack (WitMaterial) nonNegLCRAPMats_;
         //
         // The set of Materials, theMat, for which lastConsResAltPer_ (theMat)
         // is non-negative.
@


1.22
log
@Fixed a particularly difficult bug in coarse selection splitting.
@
text
@a142 5
      void postPermCommitSS ();
         //
         // Performs the actions to be taken for sel-split, just after a perm
         // commit.

d147 3
a149 1
      accessFunc (WitBoolean, penExec)
d296 2
@


1.21
log
@Implemented coarse selection splitting for penalized execution.
@
text
@d20 1
d92 11
d330 12
@


1.20
log
@Continued development of coarse selection splitting.
@
text
@a86 5
      WitBoolean freshSchemeAvail ();
         //
         // Returns TRUE iff a fresh selection scheme would be found by
         // findFreshScheme.

d172 1
a172 1
         witAssert (penExec ());
@


1.19
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@a55 32
      // Mode-dependent selection functions.
      //------------------------------------------------------------------------

      WitBopEntry * selBopEntry (WitPart * thePart, WitPeriod thePer);
         //
         // Returns the currently selected BopEntry to
         // be used for explosions in order to produce thePart in thePer.
         // Invalid, if thePart is not explodeable in thePer.
         // Valid only in multi-route mode.

      WitConsEntry * selConsEntry (WitBomEntry * theBomEnt, WitPeriod thePer);
         //
         // Returns the currently selected 
         // ConsEntry to be used when exploding theBomEnt in thePer. It may
         // be either theBomEnt itself or one of the SubEntries associated 
         // with it. Invalid, if theBomEnt is not in effect in thePer.
         // Valid only in multi-route mode.

      WitPeriod selExpPeriod (WitPart * thePart, WitPeriod fillPer);
         //
         // Returns the currently selected explosion period to be used when
         // filling requirements for thePart in fillPer, or fillPer, if there
         // is none.
         // Valid only in build-ahead mode.

      WitPeriod selExecPeriod (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Returns the currently selected execution period to be used when
         // exploding theBopEnt->myPart () in period expPer.
         // Valid only in multi-exec mode.

      //------------------------------------------------------------------------
a72 4
      void setInitDirIsAsap (WitBoolean theValue);
         //
         // See MeMgr::setInitDirIsAsap.

a125 5
      void print (WitMeAltPt * theMeAltPt);
         // 
         // Prints theMeAltPt, which should be owned within this Selector.
         // To be called by theMeAltPt.

d136 5
d142 1
a142 1
      // Selection splitting functions.
d145 1
a145 7
      WitBoolean pmrSelIsSplit (WitPart *,     WitPeriod);
      WitBoolean cmrSelIsSplit (WitBomEntry *, WitPeriod);
      WitBoolean  baSelIsSplit (WitPart *,     WitPeriod);
      WitBoolean  meSelIsSplit (WitBopEntry *, WitPeriod);
         //
         // Valid only in sel-split mode.
         // See: ProdRtr, ConsRtr, BaMgr, MeMgr.
d147 3
a149 6
      void startPmrSplitExp (WitPart *,     WitPeriod, double);
      void startCmrSplitExp (WitBomEntry *, WitPeriod, double);
      void  startBaSplitExp (WitPart *,     WitPeriod, double);
      void  startMeSplitExp (WitBopEntry *, WitPeriod, double);
         //
         // See: ProdRtr, ConsRtr, BaMgr, MeMgr.
d151 2
a152 6
      WitBoolean findNextPmrSplit (WitBopEntry * &,  double &);
      WitBoolean findNextCmrSplit (WitConsEntry * &, double &);
      WitBoolean  findNextBaSplit (WitPeriod &,      double &);
      WitBoolean  findNextMeSplit (WitPeriod &,      double &);
         //
         // See: ProdRtr, ConsRtr, BaMgr, MeMgr.
d154 3
a156 6
      void finishPmrSplitExp ();
      void finishCmrSplitExp ();
      void  finishBaSplitExp ();
      void  finishMeSplitExp ();
         //
         // See: ProdRtr, ConsRtr, BaMgr, MeMgr.
d158 2
a159 6
      void recBopEntExpPerSS  (WitBopEntry *,  WitPeriod, double);
      void recExpConsEntSS    (WitConsEntry *, WitPeriod, double);
      void recExpMatSS        (WitPart *,      WitPeriod, double, WitPeriod);
      void recBopEntExecPerSS (WitBopEntry *,  WitPeriod, double);
         //
         // See: ProdRtr, ConsRtr, BaMgr, MeMgr.
d161 3
a163 4
      void postPermCommitSS ();
         //
         // Performs the actions to be taken for sel-split, just after a perm
         // commit.
d165 6
a170 3
      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------
d172 2
a173 1
      accessFunc (WitBoolean, penExec)
a228 21
      inline WitConsRtr * myConsRtr ()
         {
         witAssert (multiRoute_);

         return myConsRtr_;
         }

      inline WitProdRtr * myProdRtr ()
         {
         witAssert (multiRoute_);

         return myProdRtr_;
         }

      inline WitBaMgr * myBaMgr ()
         {
         witAssert (buildAhead ());

         return myBaMgr_;
         }
 
a235 7
      inline WitMeMgr * myMeMgr ()
         {
         witAssert (multiExec ());

         return myMeMgr_;
         }
 
@


1.18
log
@Implemented and used class SelMgr.
@
text
@d181 8
a188 1
      void startBaSplitExp  (WitPart *,     WitPeriod, double);
d191 2
d194 1
a194 4
         // See:
         //    BaMgr.
         //    ProdRtr.
         //    ConsRtr.
a195 1
      WitBoolean findNextBaSplit  (WitPeriod &,      double &);
d198 2
d201 1
a201 4
         // See:
         //    BaMgr.
         //    ProdRtr.
         //    ConsRtr.
a202 1
      void finishBaSplitExp  ();
d205 2
d208 1
a208 12
         // See:
         //    BaMgr.
         //    ProdRtr.
         //    ConsRtr.

      void recExpMatSS (
            WitPart * thePart,
            WitPeriod expPer, 
            double    expVol,
            WitPeriod fillPer);
         //
         // See BaMgr::recExpMatSS.
d210 4
a213 4
      void recExpBopEntSS (
            WitBopEntry * theBopEnt, 
            WitPeriod     expPer, 
            double        expVol);
d215 1
a215 8
         // See ProdRtr::recExpBopEntSS.

      void recExpConsEntSS (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double         deltaExecVol);
         //
         // See ConsRtr::recExpBopEntSS.
a220 10

      WitBoolean  baSelIsSplit (WitPart *,     WitPeriod);
      WitBoolean pmrSelIsSplit (WitPart *,     WitPeriod);
      WitBoolean cmrSelIsSplit (WitBomEntry *, WitPeriod);
         //
         // Valid only in sel-split mode.
         // See:
         //      BaMgr. Valid only in build-ahead mode.
         //    ProdRtr. Valid only in multi-route mode.
         //    ConsRtr. Valid only in multi-route mode.
@


1.17
log
@Fixed some bugs in coarse selection splitting.
@
text
@a36 2
//
// Uses sequential alteration.
d47 1
a47 4
      WitSelector (WitProblem * theProblem, WitBoolean reqBuildAhead);
         //
         // ProbAssoc <<< theProblem.
         // reqBuildAhead is TRUE iff build-ahead by material is requested.
a55 13
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitBoolean, penExec)

      inline WitExpRest * myExpRest ()
         {
         witAssert (penExec ());

         return myExpRest_;
         }

      //------------------------------------------------------------------------
a117 10
      void prtBaSelSplit  (WitPart *,      WitPeriod, 
                                           WitPeriod, WitBoolean, double);
      void prtPmrSelSplit (WitBopEntry *,  WitPeriod, WitBoolean, double);
      void prtCmrSelSplit (WitConsEntry *, WitPeriod, WitBoolean, double);
         //
         // See:
         //    BaMgr
         //    ProdRtr
         //    ConsRtr

d181 27
d241 16
a256 16
         //      BaMgr::selIsSplit. Valid only in build-ahead mode.
         //    ProdRtr::selIsSplit. Valid only in multi-route mode.
         //    ConsRtr::selIsSplit. Valid only in multi-route mode.

      void  getBaSplitList (WitPart *,     WitPeriod, WitPerDblStack &);
      void getPmrSplitList (WitPart *,     WitPeriod, WitBopEntDblStack &);
      void getCmrSplitList (WitBomEntry *, WitPeriod, WitConsEntDblStack &);
         //
         // See:
         //      BaMgr::getSplitList 
         //    ProdRtr::getSplitList 
         //    ConsRtr::getSplitList 

      void  setBaHadFinSplit (WitBoolean);
      void setPmrHadFinSplit (WitBoolean);
      void setCmrHadFinSplit (WitBoolean);
d266 5
a270 1
      void buildHelpers (WitBoolean reqBuildAhead);
d272 1
a272 2
         // Builds the various "helper" objects owned by this Selector.
         // reqBuildAhead is TRUE iff build-ahead by material is requested.
a300 11
      void innerPlaceReqs (
            WitBopEntry *  theBopEnt,
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            WitPeriod      fillPer,
            WitReqPt *     theReqPt);
         //
         // Records the fact that an explosion thru theBopEnt and theConsEnt
         // in execution period execPer to fill requirements in fillPer caused
         // requirements to be placed at theReqPt.

d355 22
d393 1
a393 1
      WitExpRest * myExpRest_;
d395 1
a395 11
         // The ExpRest owned by this Selector in pen-exec mode;
         // otherwise NULL.

      WitRtAnalyzer * myRtAnalyzer_;
         //
         // The RtAnalyzer owned by this Selector in pen-exec mode;
         // otherwise NULL.

      WitReqPtMgr * myReqPtMgr_;
         //
         // The ReqPtMgr owned by this Selector.
a426 15

      WitBoolean baHadFinSplit_;
         //
         // TRUE, iff the current build-ahead selection had a finite splitVol. 
         // FALSE, if not in build-ahead sel-split mode.

      WitBoolean pmrHadFinSplit_;
         //
         // TRUE, iff the current production multi-route selection had a finite
         // splitVol. FALSE, if not in multi-route sel-split mode.

      WitBoolean cmrHadFinSplit_;
         //
         // TRUE, iff the current consumption multi-route selection had a finite
         // splitVol. FALSE, if not in multi-route sel-split mode.
@


1.16
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d136 9
a144 32
      void prtRtSplitAtPart (WitPart * thePart, WitPeriod expPer);
         //
         // See ProdRtr.

      void prtRtSplitToBopEnt (
            WitBopEntry * theBopEnt,
            WitBoolean    splitFound,
            double        splitVol);
         //
         // See ProdRtr.

      void prtRtSplitAtBomEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // See ConsRtr.

      void prtRtSplitToConsEnt (
            WitConsEntry * theConsEnt,
            WitBoolean     splitFound,
            double         splitVol);
         //
         // See ConsRtr.

      void prtBpsSplitAt (WitPart * thePart, WitPeriod fillPer);
         //
         // See BaMgr.

      void prtBpsSplitTo (
            WitPeriod  expPer, 
            WitBoolean splitFound,
            double     splitVol);
         //
         // See BaMgr.
a210 1
            WitPeriod fillPer, 
d212 2
a213 1
            double    expVol);
d236 22
a257 31
      void getBaSplitList (WitPart *, WitPeriod, WitPerDblStack &);
         //
         // See BaMgr::getSplitList.

      WitBoolean routingIsSplit (WitPart *, WitPeriod);
         //
         // See ProdRtr::routingIsSplit.
         // Valid only in multi-route   mode.
         // Valid even in non-sel-split mode.

      WitBoolean routingIsSplit (WitBomEntry *, WitPeriod);
         //
         // See ConsRtr::routingIsSplit.
         // Valid only in multi-route   mode.
         // Valid even in non-sel-split mode.

      void getMrSplitList (WitPart *, WitPeriod, WitBopEntDblStack &);
         //
         // See ProdRtr::getSplitList.

      void setExpBopEntIsSplit (WitBoolean);
         //
         // See ProdRtr::setExpBopEntIsSplit.

      void getMrSplitList (WitBomEntry *, WitPeriod, WitConsEntDblStack &);
         //
         // See ConsRtr::getSplitList.

      void setExpConsEntIsSplit (WitBoolean);
         //
         // See ConsRtr::setExpConsEntIsSplit.
d424 15
@


1.15
log
@Coarse selection splitting.
@
text
@d136 1
a136 1
      void prtRtSplitAtBomEntIA (WitBomEntry * theBomEnt, WitPeriod execPer);
d138 1
a138 1
         // Prints data for a routing split at a BOM entry, if appropriate.
d140 12
a151 1
      void prtRtSplitToConsEntIA (
d156 1
a156 1
         // Prints data for a routing split to a cons entry, if appropriate.
d158 1
a158 1
      void prtRtSplitAtPartIA (WitPart * thePart, WitPeriod expPer);
d160 1
a160 1
         // Prints data for a routing split at a Part, if appropriate.
d162 4
a165 4
      void prtRtSplitToBopEntIA (
            WitBopEntry * theBopEnt,
            WitBoolean    splitFound,
            double        splitVol);
d167 1
a167 1
         // Prints data for a routing split to a BOP entry, if appropriate.
a212 5
      void print (WitBaAltPt * theBaAltPt);
         // 
         // Prints theBaAltPt, which should be owned within this Selector.
         // To be called by theBaAltPt.

d232 8
d245 1
a245 2
         // Records the fact expVol units were exploded thru theBopEnt in
         // expPer.
d252 1
a252 2
         // Records the fact deltaExecVol units were exploded thru theConsEnt in
         // execPer.
d259 5
a263 1
      WitBoolean routingIsSplit (WitPart * thePart, WitPeriod expPer);
d269 1
a269 1
      WitBoolean routingIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer);
@


1.14
log
@Fixed some bugs in coarse selection splitting.
@
text
@d249 1
a249 1
         // See MrMgr::routingIsSplit.
d255 1
a255 1
         // See MrMgr::routingIsSplit.
d261 1
a261 1
         // See MrMgr::getSplitList.
d265 1
a265 1
         // See MrMgr::setExpBopEntIsSplit.
d269 1
a269 1
         // See MrMgr::getSplitList.
d273 1
a273 5
         // See MrMgr::setExpConsEntIsSplit.

      WitBoolean ssmrForBopEnts ();
         //
         // See MrMgr::ssmrForBopEnts ();
d330 1
a330 1
      inline WitMrMgr * myMrMgr ()
d332 1
a332 1
         witAssert (multiRoute ());
d334 1
a334 1
         return myMrMgr_;
d337 1
a337 1
      inline WitBoolean multiRoute ()
d339 3
a341 1
         return (myMrMgr_ != NULL);
a342 2
         //
         // Returns TRUE, iff the multiple routes technique is to be used.
d380 1
a380 1
      WitMrMgr * myMrMgr_;
d382 5
a386 1
         // The MrMgr owned by this Selector, if any; otherwise NULL.
d396 10
a409 5
      WitExpRest * myExpRest_;
         //
         // The ExpRest associated with this Selector, if any; 
         // otherwise NULL. Non-null, iff penExec () is TRUE.

d428 4
@


1.13
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d263 4
d270 4
@


1.12
log
@Further development of coarse selection splitting.
@
text
@d99 1
a99 4
      WitPeriod selExecPeriod (
            WitBopEntry * theBopEnt, 
            WitPeriod     expPer,
            WitPeriod     fillPer);
d102 1
a102 2
         // exploding theBopEnt->myPart () in period expPer, from fill period
         // fillPer.
d114 1
a114 4
      WitPeriod modelessExecPeriod (
            WitBopEntry * theBopEnt, 
            WitPeriod     expPer,
            WitPeriod     fillPer);
d136 5
a140 3
      void printSelSplitIA (
            WitBomEntry *  theBomEnt,
            WitPeriod      execPer,
d145 12
a156 1
         // Prints selection splitting data, if appropriate.
d226 8
d240 1
a240 1
         // thePer.
d247 17
a263 1
      void getSplitList (WitBomEntry *, WitPeriod, WitConsEntDblStack &);
d266 4
@


1.11
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@d19 1
a19 1
#include <Stack.h>
@


1.10
log
@Some minor modifications.
@
text
@a126 8
      // Selection functions for selection splitting.
      //------------------------------------------------------------------------

      void getSplitList (WitBomEntry *, WitPeriod, WitConsEntDblStack &);
         //
         // See MrMgr::getSplitList.

      //------------------------------------------------------------------------
d157 1
a157 7
      WitBoolean splitting ();
         //
         // Returns TRUE if this Selector is splitting the current selection.
         // (This means that another extended binary search will be needed.)
         // Valid only in sel split mode.

      void postTempCommit (WitBoolean success);
d159 2
a160 2
         // To be called at the end of each temp commit, with success indicating
         // its result.
d162 1
a162 1
      void postPermCommitSS ();
d164 1
a164 3
         // Performs the actions to be taken for sel-split, just after a perm
         // commit.
         // Valid only in sel-split mode.
a181 7
      void setMrSplitVol (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        theValue);
         //
         // Sets the multi-route splitVol at theBomEnt in execPer to theValue.

d215 21
@


1.9
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d19 1
a19 1
#include <DynStack.h>
d369 1
a369 1
      WitObjDynStack (WitAltPt) pendingPts_;
@


1.8
log
@Refactoring for selection splitting.
@
text
@d82 1
a82 1
         // Only valid in multi-route mode.
d90 1
a90 1
         // Only valid in multi-route mode.
d97 1
a97 1
         // Only valid in build-ahead mode.
d107 1
a107 1
         // Only valid in multi-exec mode.
d130 1
a130 1
      void findSelConsEntries (WitBomEntry * theBomEnt, WitPeriod execPer);
d132 1
a132 8
         // See MrMgr::findSelConsEntries.

      void findNextConsEntry (
            WitConsEntry * & theConsEnt,
            WitBoolean &     splitVolFinite,
            double &         splitVolVal);
         //
         // See MrMgr::findNextConsEntry.
d151 9
d169 1
a169 1
         // Only valid in sel split mode.
d176 6
d198 7
d387 4
@


1.7
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d230 1
a230 3
      copyCtorAndAssignment (WitSelector);
         //
         // Prevents unintentional copying and assignment.
@


1.6
log
@Outer API: Merged all no-longer-documented functions into one section.
Outer API: Moved build-ahead by demand functions into the no-longer-documented
   section.
Simplified the rules for two-way multiple execution periods.
@
text
@d127 15
d163 6
d356 1
a356 1
      WitDynStack (WitAltPt) pendingPts_;
@


1.5
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d130 1
a130 5
      void preIncForTwme (
            WitBoolean asapMultiExec, 
            WitBoolean prefBA,
            WitPart *  thePart,
            WitPeriod  thePer);
d132 1
a132 1
         // See MeDirMgr::preInc.
a142 4
      void printPostCommitMaxQtySelIA ();
         //
         // Prints as appropriate for just after commentmaxQtySel.

d146 1
a146 1
         // allocation . Returns TRUE, iff it succeeds.
a152 4
      void resetCurMeDirs (WitPeriod thePer);
         //
         // See MeDirMgr::resetCurMeDirs.

d163 1
a163 2
            WitPeriod      fillPer,
            WitBoolean     tempMode);
a167 1
         // tempMode indicates the allocation mode.
a301 7
      inline WitMeDirMgr * myMeDirMgr ()
         {
         witAssert (myMeDirMgr_ != NULL);

         return myMeDirMgr_;
         }

a329 5

      WitMeDirMgr * myMeDirMgr_;
         //
         // The MeDirMgr associated with this Selector, if any; 
         // otherwise NULL. Non-null, iff multiExec () is TRUE.
@


1.4
log
@Continued implementation of stock re-allocation.
@
text
@d169 1
a169 1
         // Valid only in inc or non-inc stock re-allocation mode.
@


1.3
log
@Fixed bug:
   Stock re-allocation caused selection trace-back to malfunction.
@
text
@d165 1
a165 1
      void rollReqs (WitPart * thePart, WitPeriod thePer);
d167 3
a169 2
         // Records the fact the requirements for thePart are being rolled over
         // from thePer - 1 to thePer. Used only in surplus mode.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d165 5
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.78;
access;
symbols
	sce_5_01_20080919:1.72
	latest_sce_4_20_20060523:1.48.0.2
	sce_4_20_20060523:1.48
	latest_sce4_20_OSL:1.47.0.2
	sce_4_20_OSL:1.47
	sce_410_withVa:1.43
	sce_4_05_20040511:1.42
	sce_4_00_20040201:1.25
	nextGenBranch:1.23.0.2
	nextGenRoot:1.23
	sce_3_30_20030627:1.23
	EndRw-branch:1.15.0.4
	Root-of-EndRw:1.15
	rwToStl:1.15.0.2
	latest_sce_3_10_20010924:1.8.0.2
	sce_3_10_20010924:1.8
	latest_sce_3_00_20010601:1.7.0.2
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.78
date	2011.09.28.23.49.05;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2011.09.24.00.27.23;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2011.08.30.20.17.18;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2010.09.10.22.10.37;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2010.03.16.22.42.24;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2009.12.25.00.10.46;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.25.19.37.56;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.12.06.22.01.20;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.11.15.17.15.32;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.31.20.39.45;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.05.21.05.59;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.05.16.15.22;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.01.20.31.29;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.01.18.50.54;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.30.16.01.18;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.10.21.58.10;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.25.19.56.53;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.04.22.08.17;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.03.22.04.03;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.02.23.01.14;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.03.23.19.33.07;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.27.22.59.28;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.27.19.59.30;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.10.00.08.13;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.08.22.47.33;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.01.15.22.25.29;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.09.21.15.42.25;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.02.18.06.00;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.02.17.33.55;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.23.15.55.32;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.02.28.20.38.39;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.02.28.19.43.04;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.30.21.57.54;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.24.23.23.55;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.07.22.15.14;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.05.21.16.50;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.30.15.57.19;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.13.21.50.12;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.01.21.05.11;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.31.22.56.07;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.29.23.21.27;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.24.22.21.28;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.23.19.14.22;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.05.22.19.56;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.04.19.53.25;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.12.19.13.38;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.05.21.24.56;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.04.22.31.26;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.30.23.07.51;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.11.18.29.11;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.25.23.49.54;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.18.21.12.47;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.19.16.48.13;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.21.18.56.23;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.14.20.12.54;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.13.23.06.25;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.31.21.28.53;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.27.21.17.15;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.22.18.20;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.11.18.53.05;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.04.23.07.17;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.08.19.21.47;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.25.19.14.49;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.24.18.26.05;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.22.14.32.03;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.18.14.02.27;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.02.02.11.27;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.29.22.11.25;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.20.00.44.15;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.04.22.27.48;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.21.20.03.20;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.25.20.12.30;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.22;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches;
next	;


desc
@@


1.78
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "BopEntry.C"
//
// Contains the implementation of class BopEntry.
// Contains the implementation of class template ExecPerSched <Entry>.
//------------------------------------------------------------------------------

#include <BopEntry.h>
#include <CompMgr.h>
#include <GlobalComp.h>
#include <Part.h>
#include <Operation.h>
#include <DataWrit.h>
#include <Pre.h>
#include <wit.h>
#include <ObjStack.h>
#include <IVRealArg.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class BopEntry.
//------------------------------------------------------------------------------

WitBopEntry::WitBopEntry (WitOperation * theOpn, WitPart * thePart):

      WitBillEntry   (thePart, theOpn->bop ().nElements ()),

      mappingIndex_  (myCompMgr ()->nBopEntries ()),
      myOperation_   (theOpn),

      productRate_   (myProblem (), defProductRate ()),
      expAllowed_    (defExpAllowed ()),
      expAversion_   (defExpAversion ()),
      meSelSplit_    (defMeSelSplit ()),

      effProdRate_   (myProblem (), 0.0),
      expExecPeriod_ (myProblem (), -1)
   {
   witAssert (theOpn->myCompMgr () == thePart->myCompMgr ());

   myCompMgr   ()->insert (this);
   myOperation ()->insert (this);
   myPart      ()->insert (this);
   }

//------------------------------------------------------------------------------

WitBopEntry::~WitBopEntry ()
   {
   }

//------------------------------------------------------------------------------

int WitBopEntry::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nBopEntries ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitBopEntry::setProductRate (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetUnpreAttr ();

   productRate_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBopEntry::setExpAllowed (bool theValue)
   {
   prepSetUnpreAttr ();

   expAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBopEntry::setExpAversion (double theValue)
   {
   prepSetUnpreAttr ();

   expAversion_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBopEntry::setMeSelSplit (bool theValue)
   {
   prepSetUnpostAttr ();

   meSelSplit_ = theValue;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitBopEntry::storePreEffProdRate (const WitTVec <double> & theTVec)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   effProdRate_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitBopEntry::storePreExpExecPeriod (const WitTVec <WitPeriod> & theTVec)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   expExecPeriod_ = theTVec;
   }

//------------------------------------------------------------------------------

bool WitBopEntry::inserted ()
   {
   return (myOperation ()->bop ().contains (this));
   }

//------------------------------------------------------------------------------

void WitBopEntry::identifyInstance ()
   {
   if (myMsgFac ().mayIssue ("bopEntryInstIDMsg"))
      myMsgFac () ("bopEntryInstIDMsg",
         myOperationName (),
         localIndex (),
         myPartName ());
   }

//------------------------------------------------------------------------------

void WitBopEntry::writeSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("bopEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (localIndex      ());
   }

//------------------------------------------------------------------------------

void WitBopEntry::copySelfInto (WitCompMgr * theCompMgr)
   {
   WitOperation * theOpn;
   WitPart *      thePart;
   WitBopEntry *  theBopEnt;

   theOpn    = theCompMgr->myMatchFor (myOperation ());
   thePart   = theCompMgr->myMatchFor (myPart      ());

   theBopEnt = new WitBopEntry (theOpn, thePart);

   theBopEnt->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitBopEntry::recount ()
   {
   recountBillEntry ();

   mappingIndex_ = myCompMgr ()->nBopEntries ();

   myCompMgr ()->recountBopEntry (this);
   }

//------------------------------------------------------------------------------

void WitBopEntry::unpreprocess ()
   {
   expExecPeriod_ = -1;
   effProdRate_   =  0.0;

   WitBillEntry::unpreprocess ();
   }

//------------------------------------------------------------------------------

WitBopEntry * WitBopEntry::thisBopEnt ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitMsgFrag WitBopEntry::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("bopEntryFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitBopEntry::apiObjItrState ()
   {
   return WitAT_BOP_ENTRY;
   }

//------------------------------------------------------------------------------

void WitBopEntry::display ()
   {
   myMsgFac () ("bopEntryDdMsg",
      myOperationName (),
      localIndex (),
      myPartName (),
      mappingIndex_,
      expAllowed (),
      expAversion (),
      meSelSplit ());

   myProblem ()->display ("productRateDdMsg", productRate_);

   if (myPreprocessor ()->preprocessed ())
      {
      myProblem ()->display ("effProdRateDdMsg", effProdRate_);

      if (expAllowed ())
         myMsgFac () ("expExecPeriodDdMsg", expExecPeriod_);
      }

   WitBillEntry::display ();
   }

//------------------------------------------------------------------------------

void WitBopEntry::copyAttrsFrom (WitBopEntry * theBopEnt)
   {
   WitBillEntry::copyAttrsFrom (theBopEnt);

   productRate_ = theBopEnt->productRate_;
   expAllowed_  = theBopEnt->expAllowed_;
   expAversion_ = theBopEnt->expAversion_;
   meSelSplit_  = theBopEnt->meSelSplit_;
   }

//------------------------------------------------------------------------------

bool WitBopEntry::execPerOKForExp (WitPeriod execPer)
   {
   return effProdRate_[execPer] >= myGlobalComp ()->expCutoff ();
   }

//------------------------------------------------------------------------------

void WitBopEntry::getAllInstances (
      WitProblem *                theProblem,
      WitObjStack <WitBopEntry> & theBopEntries)
   {
   WitBopEntry * theBopEnt;

   theBopEntries.clear ();

   forEachBopEntry (theBopEnt, theProblem)
      theBopEntries.push (theBopEnt);

   theBopEntries.reverse ();
   }

//------------------------------------------------------------------------------

WitOperation * WitBopEntry::derivedOperation ()
   {
   return myOperation ();
   }

//------------------------------------------------------------------------------

void WitBopEntry::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("bopEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeStringValue  (myPartName ());
   }

//------------------------------------------------------------------------------

void WitBopEntry::writeDataAttrs ()
   {
   WitBillEntry::writeDataAttrs ();

   writeOffset ();

   myDataWriter ()->writeVector (
      "productRate",
      productRate (),
      defProductRate ());

   myDataWriter ()->writeBool (
      "expAllowed",
      expAllowed (),
      defExpAllowed ());

   myDataWriter ()->writeDouble (
      "expAversion",
      expAversion (),
      defExpAversion ());

   myDataWriter ()->writeBool (
      "meSelSplit",
      meSelSplit (),
      defMeSelSplit ());
   }

//------------------------------------------------------------------------------

void WitBopEntry::findPrereqs (WitDelComp * & prereq1, WitDelComp * & prereq2)
   {
   prereq1 = myOperation ();
   prereq2 = myPart ();
   }
@


1.77
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.76
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d36 1
a36 1
WitBillEntry   (thePart, theOpn->bop ().nElements ()),
d38 2
a39 2
mappingIndex_  (myCompMgr ()->nBopEntries ()),
myOperation_   (theOpn),
d41 14
a54 14
productRate_   (myProblem (), defProductRate ()),
expAllowed_    (defExpAllowed ()),
expAversion_   (defExpAversion ()),
meSelSplit_    (defMeSelSplit ()),

effProdRate_   (myProblem (), 0.0),
expExecPeriod_ (myProblem (), -1)
{
witAssert (theOpn->myCompMgr () == thePart->myCompMgr ());

myCompMgr   ()->insert (this);
myOperation ()->insert (this);
myPart      ()->insert (this);
}
d59 2
a60 2
{
}
d65 3
a67 3
{
return theProblem->myCompMgr ()->nBopEntries ();
}
d74 2
a75 2
{
witAssert (theValue != NULL);
d77 1
a77 1
witAssert (theValue.isNonNeg (nPeriods ()));
d79 1
a79 1
prepSetUnpreAttr ();
d81 2
a82 2
productRate_ = theValue;
}
d87 2
a88 2
{
prepSetUnpreAttr ();
d90 2
a91 2
expAllowed_ = theValue;
}
d96 2
a97 2
{
prepSetUnpreAttr ();
d99 2
a100 2
expAversion_ = theValue;
}
d105 2
a106 2
{
prepSetUnpostAttr ();
d108 2
a109 2
meSelSplit_ = theValue;
}
d116 2
a117 2
{
witAssert (myPreprocessor ()->preprocessing ());
d119 2
a120 2
effProdRate_ = theTVec;
}
d125 2
a126 2
{
witAssert (myPreprocessor ()->preprocessing ());
d128 2
a129 2
expExecPeriod_ = theTVec;
}
d134 3
a136 3
{
return (myOperation ()->bop ().contains (this));
}
d141 7
a147 7
{
if (myMsgFac ().mayIssue ("bopEntryInstIDMsg"))
myMsgFac () ("bopEntryInstIDMsg",
myOperationName (),
localIndex (),
myPartName ());
}
d152 6
a157 6
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("bopEntry");
myDataWriter ()->writeStringValue  (myOperationName ());
myDataWriter ()->writeIntValue     (localIndex      ());
}
d162 4
a165 4
{
WitOperation * theOpn;
WitPart *      thePart;
WitBopEntry *  theBopEnt;
d167 2
a168 2
theOpn    = theCompMgr->myMatchFor (myOperation ());
thePart   = theCompMgr->myMatchFor (myPart      ());
d170 1
a170 1
theBopEnt = new WitBopEntry (theOpn, thePart);
d172 2
a173 2
theBopEnt->copyAttrsFrom (this);
}
d178 2
a179 2
{
recountBillEntry ();
d181 1
a181 1
mappingIndex_ = myCompMgr ()->nBopEntries ();
d183 2
a184 2
myCompMgr ()->recountBopEntry (this);
}
d189 3
a191 3
{
expExecPeriod_ = -1;
effProdRate_   =  0.0;
d193 2
a194 2
WitBillEntry::unpreprocess ();
}
d199 3
a201 3
{
return this;
}
d206 3
a208 3
{
return myMsgFac ().myFrag ("bopEntryFrag");
}
d213 3
a215 3
{
return WitAT_BOP_ENTRY;
}
d220 19
a238 19
{
myMsgFac () ("bopEntryDdMsg",
myOperationName (),
localIndex (),
myPartName (),
mappingIndex_,
expAllowed (),
expAversion (),
meSelSplit ());

myProblem ()->display ("productRateDdMsg", productRate_);

if (myPreprocessor ()->preprocessed ())
{
myProblem ()->display ("effProdRateDdMsg", effProdRate_);

if (expAllowed ())
myMsgFac () ("expExecPeriodDdMsg", expExecPeriod_);
}
d240 2
a241 2
WitBillEntry::display ();
}
d246 2
a247 2
{
WitBillEntry::copyAttrsFrom (theBopEnt);
d249 5
a253 5
productRate_ = theBopEnt->productRate_;
expAllowed_  = theBopEnt->expAllowed_;
expAversion_ = theBopEnt->expAversion_;
meSelSplit_  = theBopEnt->meSelSplit_;
}
d258 3
a260 3
{
return effProdRate_[execPer] >= myGlobalComp ()->expCutoff ();
}
d265 4
a268 4
WitProblem *                theProblem,
WitObjStack <WitBopEntry> & theBopEntries)
{
WitBopEntry * theBopEnt;
d270 1
a270 1
theBopEntries.clear ();
d272 2
a273 2
forEachBopEntry (theBopEnt, theProblem)
theBopEntries.push (theBopEnt);
d275 2
a276 2
theBopEntries.reverse ();
}
d281 3
a283 3
{
return myOperation ();
}
d288 6
a293 6
{
myDataWriter ()->writeFirstKeyWord ("add");
myDataWriter ()->writeKeyWord      ("bopEntry");
myDataWriter ()->writeStringValue  (myOperationName ());
myDataWriter ()->writeStringValue  (myPartName ());
}
d298 2
a299 2
{
WitBillEntry::writeDataAttrs ();
d301 1
a301 1
writeOffset ();
d303 20
a322 20
myDataWriter ()->writeVector (
"productRate",
productRate (),
defProductRate ());

myDataWriter ()->writeBool (
"expAllowed",
expAllowed (),
defExpAllowed ());

myDataWriter ()->writeDouble (
"expAversion",
expAversion (),
defExpAversion ());

myDataWriter ()->writeBool (
"meSelSplit",
meSelSplit (),
defMeSelSplit ());
}
d327 4
a330 4
{
prereq1 = myOperation ();
prereq2 = myPart ();
}
@


1.75
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d36 1
a36 1
      WitBillEntry   (thePart, theOpn->bop ().nElements ()),
d38 2
a39 2
      mappingIndex_  (myCompMgr ()->nBopEntries ()),
      myOperation_   (theOpn),
d41 14
a54 14
      productRate_   (myProblem (), defProductRate ()),
      expAllowed_    (defExpAllowed ()),
      expAversion_   (defExpAversion ()),
      meSelSplit_    (defMeSelSplit ()),

      effProdRate_   (myProblem (), 0.0),
      expExecPeriod_ (myProblem (), -1)
   {
   witAssert (theOpn->myCompMgr () == thePart->myCompMgr ());

   myCompMgr   ()->insert (this);
   myOperation ()->insert (this);
   myPart      ()->insert (this);
   }
d59 2
a60 2
   {
   }
d65 3
a67 3
   {
   return theProblem->myCompMgr ()->nBopEntries ();
   }
d74 2
a75 2
   {
   witAssert (theValue != NULL);
d77 1
a77 1
   witAssert (theValue.isNonNeg (nPeriods ()));
d79 1
a79 1
   prepSetUnpreAttr ();
d81 2
a82 2
   productRate_ = theValue;
   }
d87 2
a88 2
   {
   prepSetUnpreAttr ();
d90 2
a91 2
   expAllowed_ = theValue;
   }
d96 2
a97 2
   {
   prepSetUnpreAttr ();
d99 2
a100 2
   expAversion_ = theValue;
   }
d105 2
a106 2
   {
   prepSetUnpostAttr ();
d108 2
a109 2
   meSelSplit_ = theValue;
   }
d116 2
a117 2
   {
   witAssert (myPreprocessor ()->preprocessing ());
d119 2
a120 2
   effProdRate_ = theTVec;
   }
d125 2
a126 2
   {
   witAssert (myPreprocessor ()->preprocessing ());
d128 2
a129 2
   expExecPeriod_ = theTVec;
   }
d134 3
a136 3
   {
   return (myOperation ()->bop ().contains (this));
   }
d141 7
a147 7
   {
   if (myMsgFac ().mayIssue ("bopEntryInstIDMsg"))
      myMsgFac () ("bopEntryInstIDMsg",
         myOperationName (),
         localIndex (),
         myPartName ());
   }
d152 6
a157 6
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("bopEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (localIndex      ());
   }
d162 4
a165 4
   {
   WitOperation * theOpn;
   WitPart *      thePart;
   WitBopEntry *  theBopEnt;
d167 2
a168 2
   theOpn    = theCompMgr->myMatchFor (myOperation ());
   thePart   = theCompMgr->myMatchFor (myPart      ());
d170 1
a170 1
   theBopEnt = new WitBopEntry (theOpn, thePart);
d172 2
a173 2
   theBopEnt->copyAttrsFrom (this);
   }
d178 2
a179 2
   {
   recountBillEntry ();
d181 1
a181 1
   mappingIndex_ = myCompMgr ()->nBopEntries ();
d183 2
a184 2
   myCompMgr ()->recountBopEntry (this);
   }
d189 3
a191 3
   {
   expExecPeriod_ = -1;
   effProdRate_   =  0.0;
d193 2
a194 2
   WitBillEntry::unpreprocess ();
   }
d199 3
a201 3
   {
   return this;
   }
d206 3
a208 3
   {
   return myMsgFac ().myFrag ("bopEntryFrag");
   }
d213 3
a215 3
   {
   return WitAT_BOP_ENTRY;
   }
d220 19
a238 19
   {
   myMsgFac () ("bopEntryDdMsg",
      myOperationName (),
      localIndex (),
      myPartName (),
      mappingIndex_,
      expAllowed (),
      expAversion (),
      meSelSplit ());

   myProblem ()->display ("productRateDdMsg", productRate_);

   if (myPreprocessor ()->preprocessed ())
      {
      myProblem ()->display ("effProdRateDdMsg", effProdRate_);

      if (expAllowed ())
         myMsgFac () ("expExecPeriodDdMsg", expExecPeriod_);
      }
d240 2
a241 2
   WitBillEntry::display ();
   }
d246 2
a247 2
   {
   WitBillEntry::copyAttrsFrom (theBopEnt);
d249 5
a253 5
   productRate_ = theBopEnt->productRate_;
   expAllowed_  = theBopEnt->expAllowed_;
   expAversion_ = theBopEnt->expAversion_;
   meSelSplit_  = theBopEnt->meSelSplit_;
   }
d258 3
a260 3
   {
   return effProdRate_[execPer] >= myGlobalComp ()->expCutoff ();
   }
d265 4
a268 4
      WitProblem *                theProblem,
      WitObjStack <WitBopEntry> & theBopEntries)
   {
   WitBopEntry * theBopEnt;
d270 1
a270 1
   theBopEntries.clear ();
d272 2
a273 2
   forEachBopEntry (theBopEnt, theProblem)
      theBopEntries.push (theBopEnt);
d275 2
a276 2
   theBopEntries.reverse ();
   }
d281 3
a283 3
   {
   return myOperation ();
   }
d288 6
a293 6
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("bopEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeStringValue  (myPartName ());
   }
d298 2
a299 2
   {
   WitBillEntry::writeDataAttrs ();
d301 1
a301 1
   writeOffset ();
d303 20
a322 20
   myDataWriter ()->writeVector (
      "productRate",
      productRate (),
      defProductRate ());

   myDataWriter ()->writeBool (
      "expAllowed",
      expAllowed (),
      defExpAllowed ());

   myDataWriter ()->writeDouble (
      "expAversion",
      expAversion (),
      defExpAversion ());

   myDataWriter ()->writeBool (
      "meSelSplit",
      meSelSplit (),
      defMeSelSplit ());
   }
d327 4
a330 4
   {
   prereq1 = myOperation ();
   prereq2 = myPart ();
   }
@


1.74
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d21 1
a21 1
#include <Opn.h>
@


1.73
log
@Multi-Objective Mode
@
text
@d19 1
a19 1
#include <Global.h>
@


1.72
log
@Object name change.
@
text
@d151 10
@


1.71
log
@Stochastic Implosion
@
text
@d36 1
a36 2
      WitBillEntry   (  preconstruct (theOpn, thePart),
                        theOpn->bop ().nElements ()),
d49 2
a269 14
WitPart * WitBopEntry::preconstruct (
      WitOperation * theOpn,
      WitPart *      thePart)
   {
   witAssert (theOpn  != NULL);
   witAssert (thePart != NULL);

   witAssert (theOpn->myCompMgr () == thePart->myCompMgr ());

   return thePart;
   }

//------------------------------------------------------------------------------

@


1.70
log
@Stochastic Implosion
@
text
@d152 6
a157 1
   WitBopEntry * theBopEnt;
d159 1
a159 4
   theBopEnt =
      new WitBopEntry (
         theCompMgr->match (myOperation ()),
         theCompMgr->match (myPart ()));
@


1.69
log
@Stochastic Implosion
@
text
@d114 18
a174 9
void WitBopEntry::passPreRefs ()
   {
   WitBillEntry::passPreRefs ();

   myPreprocessor ()->receiveRefs (this, effProdRate_, expExecPeriod_);
   }

//------------------------------------------------------------------------------

@


1.68
log
@Stochastic Implosion
@
text
@d13 2
a14 4
// Contains the implementation of the following classes:
//
//    BopEntry
//    ExecPerSched
a17 1
#include <ExecPerSch.h>
d25 1
d31 2
d242 16
a322 83

//------------------------------------------------------------------------------
// Implementation of class ExecPerSched.
//------------------------------------------------------------------------------

WitExecPerSched::WitExecPerSched (WitProblem * theProblem):

      WitProbAssoc  (theProblem),

      firstExecPer_ (theProblem, -1),
      lastExecPer_  (theProblem, -2)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   bool          multiExecPers;
   WitPeriod     expPer;

   forEachBopEntry (theBopEnt, myProblem ())
      {
      multiExecPers = false;

      if (theBopEnt->expAllowed ())
         forEachPeriod (execPer, myProblem ())
            {
            if (not theBopEnt->execPerOKForExp (execPer))
               continue;

            expPer = theBopEnt->impactPeriod ()[execPer];

            if (firstExecPer_ (theBopEnt)[expPer] == -1)
               firstExecPer_ (theBopEnt)[expPer] = execPer;
            else
               multiExecPers = true;

            lastExecPer_ (theBopEnt)[expPer] = execPer;
            }

      if (not multiExecPers)
         {
         firstExecPer_ (theBopEnt).clear ();
         lastExecPer_  (theBopEnt).clear ();
         }
      }
   }

//------------------------------------------------------------------------------

WitExecPerSched::~WitExecPerSched ()
   {
   }

//------------------------------------------------------------------------------

bool WitExecPerSched::hasMultiExec (WitBopEntry * theBopEnt)
   {
   return (firstExecPer_ (theBopEnt).isAllocated ());
   }

//------------------------------------------------------------------------------

void WitExecPerSched::getExecPerRange (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      WitPeriod &   execPerFirst,
      WitPeriod &   execPerLast)
   {
   if (firstExecPer_ (theBopEnt).isAllocated ())
      {
      execPerFirst = firstExecPer_ (theBopEnt)[expPer];
      execPerLast  = lastExecPer_  (theBopEnt)[expPer];
      }
   else if (theBopEnt->expEligible (expPer))
      {
      execPerFirst = theBopEnt->expExecPeriod ()[expPer];

      execPerLast  = execPerFirst;
      }
   else
      {
      execPerFirst = -1;
      execPerLast  = -2;
      }
   }
@


1.67
log
@Stochastic Implosion
@
text
@a26 1
#include <PreData.h>
a165 10
void WitBopEntry::importPreData ()
   {
   WitBillEntry::importPreData ();

   effProdRate_   = expPreData ()->effProdRate   () (this);
   expExecPeriod_ = expPreData ()->expExecPeriod () (this);
   }

//------------------------------------------------------------------------------

@


1.66
log
@Stochastic Implosion
@
text
@d158 9
@


1.65
log
@Stochastic Implosion
@
text
@d162 2
a163 1
   effProdRate_ = expPreData ()->effProdRate () (this);
d239 1
a239 1
   return effProdRate ()[execPer] >= myGlobalComp ()->expCutoff ();
@


1.64
log
@Stochastic Implosion
@
text
@d27 1
d161 2
@


1.63
log
@Stochastic Implosion
@
text
@d157 7
@


1.62
log
@Stochastic Implosion
@
text
@a131 40
WitMsgFrag WitBopEntry::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("bopEntryFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitBopEntry::apiObjItrState ()
   {
   return WitAT_BOP_ENTRY;
   }

//------------------------------------------------------------------------------

void WitBopEntry::display ()
   {
   myMsgFac () ("bopEntryDdMsg",
      myOperationName (),
      localIndex (),
      myPartName (),
      mappingIndex_,
      expAllowed (),
      expAversion (),
      meSelSplit ());

   myProblem ()->display ("productRateDdMsg", productRate_);

   if (myPreprocessor ()->preprocessed ())
      {
      myProblem ()->display ("effProdRateDdMsg", effProdRate_);

      if (expAllowed ())
         myMsgFac () ("expExecPeriodDdMsg", expExecPeriod_);
      }

   WitBillEntry::display ();
   }

//------------------------------------------------------------------------------

d174 40
@


1.61
log
@Stochastic implosion.
@
text
@d78 1
a78 1
   settingUnpreAttr ();
d87 1
a87 1
   settingUnpreAttr ();
d96 1
a96 1
   settingUnpreAttr ();
d105 1
a105 1
   settingUnpostAttr ();
@


1.60
log
@Stochastic Implosion.
@
text
@d78 1
a78 1
   myPreprocessor ()->unpreprocess ();
d87 1
a87 1
   myPreprocessor ()->unpreprocess ();
d96 1
a96 1
   myPreprocessor ()->unpreprocess ();
d105 1
a105 1
   myProblem ()->resetSoln ();
@


1.59
log
@Stochastic Implosion.
@
text
@a49 2
   forbidAddStochAct ();

@


1.58
log
@Stochastic implosion.
@
text
@d29 1
d50 1
a50 1
   forbidAddStochAct ("bopEntryFrag");
a122 7
WitMsgFragID WitBopEntry::classFragID ()
   {
   return "bopEntryFrag";
   }

//------------------------------------------------------------------------------

d134 7
@


1.57
log
@Removed an extraneous data member.
@
text
@d49 2
@


1.56
log
@[disallowed backlog]
@
text
@a43 1
      pipShare_      (myProblem (), defPipShare ()),
a219 1
   pipShare_    = theBopEnt->pipShare_;
@


1.55
log
@Rescinded all changed made since 1/31/07.
@
text
@a233 8
void WitBopEntry::transmitDMPs ()
   {
   WitPreprocessor::receiveDMPs (& WitBopEntry::expExecPeriod_,
                                 & WitBopEntry::effProdRate_);
   }

//------------------------------------------------------------------------------

@


1.54
log
@[disallowed backlog]
@
text
@a37 3
      effProdRate_   (myProblem ()),
      expExecPeriod_ (),

d45 4
a48 1
      meSelSplit_    (defMeSelSplit ())
d161 1
a161 1
      myProblem ()->display ("effProdRateDdMsg", effProdRate ());
d164 1
a164 1
         myMsgFac () ("expExecPeriodDdMsg", expExecPeriod ());
d197 10
d234 8
@


1.53
log
@[disallowed backlog]
@
text
@d38 3
d48 1
a48 4
      meSelSplit_    (defMeSelSplit ()),

      effProdRate_   (myProblem (), 0.0),
      expExecPeriod_ (myProblem (), -1)
d161 1
a161 1
      myProblem ()->display ("effProdRateDdMsg", effProdRate_);
d164 1
a164 1
         myMsgFac () ("expExecPeriodDdMsg", expExecPeriod_);
a196 8
void WitBopEntry::unpreprocess ()
   {
   expExecPeriod_ = -1;
   effProdRate_   =  0.0;
   }

//------------------------------------------------------------------------------

a223 8
void WitBopEntry::transmitDMPs ()
   {
   WitPreprocessor::receiveDMPs (& WitBopEntry::expExecPeriod_,
                                 & WitBopEntry::effProdRate_);
   }

//------------------------------------------------------------------------------

@


1.52
log
@witCopy<Object>Data
@
text
@a200 2

   WitBillEntry::unpreprocess ();
@


1.51
log
@App controlled opt implosion.
@
text
@d214 13
a301 13
void WitBopEntry::copyAttrsFrom (WitBopEntry * theBopEnt)
   {
   WitBillEntry::copyAttrsFrom (theBopEnt);

   productRate_ = theBopEnt->productRate_;
   expAllowed_  = theBopEnt->expAllowed_;
   expAversion_ = theBopEnt->expAversion_;
   pipShare_    = theBopEnt->pipShare_;
   meSelSplit_  = theBopEnt->meSelSplit_;
   }

//------------------------------------------------------------------------------

@


1.50
log
@App controlled opt implosion.
@
text
@a25 1
#include <DataAlt.h>
d28 1
d74 7
a80 1
   productRate_ = prepNonNegDblVec (theValue, preprocAlt ());
d87 3
a89 1
   expAllowed_ = prepBool (theValue, preprocAlt ());
d96 3
a98 1
   expAversion_ = prepDouble (theValue, preprocAlt ());
d105 3
a107 1
   meSelSplit_ = prepBool (theValue, postprocAlt ());
@


1.49
log
@GPIP migration.
@
text
@d147 1
a147 1
   if (myProblem ()->preprocessed ())
@


1.48
log
@Updated the copyright date on all source files.
@
text
@a92 7
void WitBopEntry::setPipShare (const WitIVRealArg & theValue)
   {
   pipShare_ = prepNonNegDblVec (theValue, postprocAlt ());
   }

//------------------------------------------------------------------------------

a146 2
   myProblem ()->display ("pipShareDdMsg", pipShare_);

a268 5
   myDataWriter ()->writeVector (
      "pipShare",
      pipShare (),
      defPipShare ());

@


1.47
log
@Fixed a bug:
   subEntry.netAllowed was not being copied by witCopyData ().
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.46
log
@[shared-resource pegging]
@
text
@d295 1
a299 1
   productRate_ = theBopEnt->productRate_;
@


1.45
log
@[shared-resource pegging]
@
text
@d362 7
@


1.44
log
@[multi-thread]
@
text
@d13 4
a16 1
// Contains the implementation of class BopEntry.
d19 2
a24 1
#include <BopEntry.h>
d309 76
@


1.43
log
@Vector PropRt.
@
text
@d207 1
a207 1
void WitBopEntry::loadPre ()
d209 1
a209 3
   WitBillEntry::loadPre ();

   myPreprocessor ()->loadDataFrom (this, expExecPeriod_, effProdRate_);
d214 1
a214 1
bool WitBopEntry::execPerOKForExp (WitPeriod execPer)
d216 2
a217 1
   return effProdRate ()[execPer] >= myGlobalComp ()->expCutoff ();
@


1.42
log
@PIP.
@
text
@d68 1
a68 1
void WitBopEntry::setProductRate (const WitInVecRA & theValue)
d89 1
a89 1
void WitBopEntry::setPipShare (const WitInVecRA & theValue)
@


1.41
log
@PIP.
@
text
@d40 1
a40 1
      pipShare_      (defPipShare ()),
d89 1
a89 1
void WitBopEntry::setPipShare (double theValue)
d91 1
a91 1
   pipShare_ = prepNonNegDouble (theValue, preprocAlt ());
a145 1
      pipShare (),
d150 2
d275 1
a275 1
   myDataWriter ()->writeDouble (
@


1.40
log
@Continued implementation of PIP.
@
text
@d149 1
a149 1
   myProblem ()->display ("productRateDdMsg", productRate ());
d153 1
a153 1
      myProblem ()->display ("effProdRateDdMsg", effProdRate ());
d156 1
a156 1
         myMsgFac () ("expExecPeriodDdMsg", expExecPeriod ());
@


1.39
log
@Double Precision.
@
text
@d40 1
d89 7
d146 1
d274 5
d291 5
a295 4
   expAllowed_  = theBopEnt->expAllowed  ();
   expAversion_ = theBopEnt->expAversion ();
   meSelSplit_  = theBopEnt->meSelSplit  ();
   productRate_ = theBopEnt->productRate ();
@


1.38
log
@Double Precision.
@
text
@d69 1
a69 1
   productRate_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
d182 2
a183 2
   expExecPeriod_.setToScalar (-1);
   effProdRate_  .setToScalar (0.0);
@


1.37
log
@Double Precision.
@
text
@d277 1
a277 1
   expAllowed_  = theBopEnt->expAllowed ();
d279 2
a280 3
   meSelSplit_  = theBopEnt->meSelSplit ();

   productRate_.copy (theBopEnt->productRate ());
@


1.36
log
@Double Precision.
@
text
@a66 7
void WitBopEntry::setProductRate (const float * theValue)
   {
   productRate_.convCopy (prepNonNegDblVec (theValue, preprocAlt ()));
   }

//------------------------------------------------------------------------------

@


1.35
log
@Double Precision.
@
text
@d74 7
@


1.34
log
@Double Precision.
@
text
@d69 1
a69 1
   productRate_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
@


1.33
log
@Double Precision.
@
text
@d69 1
a69 1
   convCopy (productRate_, prepNonNegFloatVec (theValue, preprocAlt ()));
@


1.32
log
@Double Precision.
@
text
@d69 1
a69 1
   productRate_.convCopy (prepNonNegFloatVec (theValue, preprocAlt ()));
@


1.31
log
@Double Precision.
@
text
@d144 1
a144 1
       myMsgFac () ("effProdRateDdMsg", effProdRate ());
@


1.30
log
@Double Precision.
@
text
@d69 1
a69 1
   productRate_.copyCVec (prepNonNegFloatVec (theValue, preprocAlt ()));
@


1.29
log
@Continued double precision.
@
text
@d69 1
a69 1
   productRate_.copyCvector (prepNonNegFloatVec (theValue, preprocAlt ()));
@


1.28
log
@Continued double precision.
@
text
@d81 1
a81 1
void WitBopEntry::setExpAversion (StrDbl theValue)
d83 1
a83 1
   expAversion_ = prepStrDbl (theValue, preprocAlt ());
d260 1
a260 1
   myDataWriter ()->writeStrDbl (
@


1.27
log
@Continued double precision.
@
text
@d208 1
a208 1
   return (effProdRate ()[execPer] >= myGlobalComp ()->expCutoff ());
@


1.26
log
@Continued double precision.
@
text
@d81 1
a81 1
void WitBopEntry::setExpAversion (double theValue)
d83 1
a83 1
   expAversion_ = prepDouble (theValue, preprocAlt ());
d260 1
a260 1
   myDataWriter ()->writeDouble (
@


1.25
log
@Removed a bad function overload.
@
text
@d81 1
a81 1
void WitBopEntry::setExpAversion (float theValue)
d83 1
a83 1
   expAversion_ = prepFloat (theValue, preprocAlt ());
d260 1
a260 1
   myDataWriter ()->writeFloat (
@


1.24
log
@Continued implementation of post-implosion pegging.
@
text
@d190 1
a190 1
WitBopEntry * WitBopEntry::myBopEnt ()
@


1.23
log
@Made modifications to improve the speed of witPurgeData.
@
text
@a25 1
#include <FlexVecI.h>
@


1.22
log
@Continued implementation of proportionate routing.
@
text
@d114 5
a118 4
   myMsgFac () ("bopEntryInstIDMsg",
      myOperationName (),
      localIndex (),
      myPartName ());
@


1.21
log
@Continued implementation of proportionate routing.
@
text
@d190 1
a190 1
void WitBopEntry::getBopEntry (WitBopEntry * & theBopEnt)
d192 1
a192 1
   theBopEnt = this;
@


1.20
log
@Continued implementation of proportionate routing.
@
text
@a40 1
      expShare_      (defExpShare ()),
a88 10
void WitBopEntry::setExpShare (float theValue)
   {
   if (DEBUG_MODE)
      witAssert (theValue >= 1.0 - FLOAT_EPSILON);

   expShare_ = prepFloat (theValue, postprocAlt ());
   }

//------------------------------------------------------------------------------

a137 1
      expShare (),
a264 5
   myDataWriter ()->writeFloat (
      "expShare",
      expShare (),
      defExpShare ());

a278 1
   expShare_    = theBopEnt->expShare ();
@


1.19
log
@Continued implementation of proportionate routing.
@
text
@d93 1
a93 2
      if (theValue != 0.0)
         witAssert (theValue >= 1.0 - FLOAT_EPSILON);
@


1.18
log
@Continued implementation of proportionate routing.
@
text
@d59 7
@


1.17
log
@Began implementation of Proportionate Routing.
@
text
@d41 1
a41 1
      expFactor_     (defExpFactor ()),
d83 1
a83 1
void WitBopEntry::setExpFactor (float theValue)
a84 2
   witAssert (myGlobalComp ()->allowPR ());

d87 1
a87 1
         witAssert (theValue >= 0.01 - FLOAT_EPSILON);
d89 1
a89 1
   expFactor_ = prepFloat (theValue, postprocAlt ());
d143 1
a143 1
      expFactor (),
d272 3
a274 3
      "expFactor",
      expFactor (),
      defExpFactor ());
d290 1
a290 1
   expFactor_   = theBopEnt->expFactor ();
@


1.16
log
@Internal changes.
@
text
@d41 1
d83 13
d145 1
d273 5
d292 1
@


1.15
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d68 1
a68 1
void WitBopEntry::setExpAllowed (WitBoolean theValue)
d70 1
a70 1
   expAllowed_ = prepBoolean (theValue, preprocAlt ());
d82 1
a82 1
void WitBopEntry::setMeSelSplit (WitBoolean theValue)
d84 1
a84 1
   meSelSplit_ = prepBoolean (theValue, postprocAlt ());
d91 1
a91 1
WitBoolean WitBopEntry::inserted ()
d199 1
a199 1
WitBoolean WitBopEntry::execPerOKForExp (WitPeriod execPer)
d248 1
a248 1
   myDataWriter ()->writeBoolean (
d258 1
a258 1
   myDataWriter ()->writeBoolean (
@


1.14
log
@Continued implementation of single-source.
@
text
@d26 1
@


1.13
log
@Preliminary work on single source.
@
text
@d23 1
d172 10
d185 9
@


1.12
log
@Continued implementation of object iteration.
@
text
@d61 1
a61 1
   productRate_ = prepNonNegFloatVec (theValue, preprocAlt ());
a248 1
   productRate_ = theBopEnt->productRate ();
d252 2
@


1.11
log
@Continued implementation of object iteration.
@
text
@d113 1
a113 1
WitAttr WitBopEntry::apiItrState ()
@


1.10
log
@Continued implementation of object iteration.
@
text
@d115 1
a115 1
   return WitITR_AT_BOP_ENTRY;
@


1.9
log
@Began implementation of object iteration.
@
text
@d23 1
d113 7
d167 7
@


1.8
log
@Continued development of selection splitting for multi-exec.
@
text
@d17 4
d23 1
d159 7
@


1.7
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@a75 2
   witAssert (myGlobalComp ()->meSelSplitOK ());

@


1.6
log
@Implemented and used class SelMgr.
@
text
@d33 1
d73 9
d117 2
a118 1
      expAversion ());
d211 5
d227 1
@


1.5
log
@Coarse selection splitting.
@
text
@a219 6

//------------------------------------------------------------------------------

implementClearContents (WitBopEntry)
   //
   // See RWClient.h.
@


1.4
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d140 1
a140 1
   setBillEntryIndex ();
d144 1
a144 1
   myCompMgr ()->recount (this);
@


1.3
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d124 1
a124 1
void WitBopEntry::copyInto (WitCompMgr * theCompMgr)
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d30 1
a30 1
      prodRate_      (defProdRate ()),
d52 1
a52 1
void WitBopEntry::setProdRate (float theValue)
d54 1
a54 1
   prodRate_ = prepNonNegFloat (theValue, preprocAlt ());
a105 1
      prodRate (),
d109 1
a109 1
   WitBillEntry::display ();
d118 2
d186 4
a189 4
   myDataWriter ()->writeFloat (
      "prodRate",
      prodRate (),
      defProdRate ());
d208 1
a208 1
   prodRate_    = theBopEnt->prodRate ();
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

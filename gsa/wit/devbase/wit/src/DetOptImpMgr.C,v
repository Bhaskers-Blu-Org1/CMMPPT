head	1.58;
access;
symbols
	sce_5_01_20080919:1.6;
locks; strict;
comment	@ * @;


1.58
date	2011.09.28.23.49.17;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2011.09.24.00.27.33;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2011.08.30.20.17.26;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2011.08.25.23.27.00;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2011.03.02.00.21.10;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2011.02.18.22.28.14;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2011.02.18.00.32.25;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2011.01.06.00.08.18;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.14.00.22.49;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2010.12.09.00.34.40;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2010.12.04.00.29.44;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.03.17.19.03;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.17.20.20.52;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2010.11.12.22.23.19;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2010.10.29.22.24.57;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2010.10.18.21.56.51;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2010.10.14.16.07.27;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2010.10.12.22.02.21;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2010.10.12.19.48.27;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2010.10.07.15.41.00;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.10.22.10.37;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.01.16.28.23;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2010.08.19.18.00.12;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.18.22.46.35;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.28.14.40.36;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.21.18.17.56;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.21.15.28.01;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.20.23.39.49;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.19.20.34.10;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.14.21.20.55;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.12.18.38.06;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.11.22.26.27;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.24.21.31.02;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.18.22.35.02;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2010.03.16.22.42.24;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2010.03.16.21.13.29;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.16.20.39.21;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.16.20.22.38;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.13.00.35.50;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.23.20.03.25;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2010.02.20.00.11.05;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.14.22.57.54;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.08.22.51.54;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.07.23.59.13;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.04.23.21.33;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.31.20.45.09;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.14.22.54.54;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.14.21.34.54;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.19.20.46.06;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.18.19.00.01;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.17.22.54.48;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.13.19.01.24;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.27.23.43.42;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.27.23.19.09;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.13.20.17.38;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.07.20.10.22;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.03.22.04.10;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.01.22.41.56;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "DetOptImpMgr.C"
//
// Contains the implementation of class DetOptImpMgr.
//------------------------------------------------------------------------------

#include <DetOptImpMgr.h>
#include <ExtOptMgr.h>
#include <StochImpMgr.h>
#include <MultiObjMgr.h>
#include <Objective.h>
#include <OptStarter.h>
#include <DetImpOP.h>
#include <DetVars.h>
#include <DetCons.h>
#include <HeurImp.h>
#include <wit/src/Variant.h>
#include <Pre.h>
#include <Post.h>
#include <Part.h>
#include <Demand.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <BoundSet.h>
#include <PtrVecSort.h>
#include <wit.h>
#include <Timing.h>
#include <MsgFrag.h>
#include <MsgFac.h>

typedef struct std::pair <WitPart *, WitPeriod> WitPartPer;

//------------------------------------------------------------------------------
// Implementation of class DetOptImpMgr.
//------------------------------------------------------------------------------

WitDetOptImpMgr::WitDetOptImpMgr (WitProblem * theProblem):

      WitProbAssoc   (theProblem),

      myDetImpOP_    (NULL),
      extOptActive_  (false),
      myExtOptMgr_   (NULL),
      accelerated_   (false),
      clearingSoln_  (false),
      uploadingSoln_ (false),
      revCritList_   (myProblem ()),
      potential_     ()
   {                
   }

//------------------------------------------------------------------------------

WitDetOptImpMgr::~WitDetOptImpMgr ()
   {
   shutDown ();

   delete myExtOptMgr_;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::shutDown ()
   {
   if (myDetImpOP_ == NULL)
      return;

   if (accelerated ())
      {
      accelerated_ =
         myMsgFac ().displayStateChange (
            "unaccStateMsg",
            accelerated (),
            false);

      myOptComp ()->crashOptStarter ()->beChosen ();
      }

   delete myDetImpOP_;

   myDetImpOP_ = NULL;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::implode ()
   {
   WitTimer::enterSection ("opt-prob");

   myMsgFac () ("optImpMsg");

   myOptComp ()->requireCplex ();

   if (myOptComp ()->multiObjMode ())
      myOptComp ()->myMultiObjMgr ()->validateData ();

   startOptImp  ();

   myDetImpOP ()->solve ();

   myProblem ()->optVariant ()->becomesCurrent ();

   finishOptImp ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::evalObjectives ()
   {
   WitTimer::enterSection ("opt-prob");

   myProblem ()->inputVariant ()->becomesCurrent ();

   myPreprocessor ()->preprocess ();

   setUpOptProblem ();

   if (myOptComp ()->printOptProblem ())
      myDetImpOP ()->print ();

   myPostprocessor ()->postprocess ();

   if (not myGlobalComp ()->feasible ())
      myMsgFac () ("infeasObjWmsg");

   myDetImpOP ()->calcInitSoln ();

   compObjectives ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

bool WitDetOptImpMgr::boundsObjUsed () const
   {
   return myDetImpOP ()->slbvVarsExist ();
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::startExtOpt ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (not myGlobalComp ()->computeCriticalList ());
   stronglyAssert (not myOptComp    ()->compPrices          ());
   stronglyAssert (not myOptComp    ()->accAfterOptImp      ());
   stronglyAssert (not myOptComp    ()->multiObjMode        ());
   stronglyAssert (not extOptActive_);

   myMsgFac () ("startExtOptMsg");

   extOptActive_ = true;

   startOptImp ();

   myExtOptMgr_ = new WitExtOptMgr (myDetImpOP ());

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::finishExtOpt ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (extOptActive_);

   stronglyAssert (myExtOptMgr_->solnProvided ());

   myMsgFac () ("finishExtOptMsg");

   delete myExtOptMgr_;

   myExtOptMgr_ = NULL;

   myProblem ()->extOptVariant ()->becomesCurrent ();

   finishOptImp ();

   extOptActive_ = false;

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::shutDownExtOpt ()
   {
   WitTimer::enterSection ("opt-prob");

   stronglyAssert (extOptActive_);

   myMsgFac () ("shutDownExtOptMsg");

   delete myExtOptMgr_;

   myExtOptMgr_ = NULL;

   shutDown ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::startOptImp ()
   {
   WitComponent * theComp;

   myProblem ()->resetSoln ();

   if (myCompMgr ()->nParts () == 0)
      myMsgFac () ("noPartsSmsg");

   if (myOptComp ()->mipMode ())
      validateMipMode ();

   myPreprocessor ()->preprocess ();

   if (not extOptActive_)
      compInitSoln ();

   setUpOptProblem ();

   if (not extOptActive_)
      if (myOptComp ()->optInitMethod ()->external ())
         compInitOptSoln ();

   clearingSoln_ = true;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->clearOptSoln ();

   clearingSoln_ = false;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::finishOptImp ()
   {
   if (myOptComp ()->printOptSoln ())
      myDetImpOP ()->writeSoln ("opSoln.out");

   buildCritList ();

   uploadSoln ();

   compObjectives ();

   myOptComp ()->writeObjValue ();

   if (myGlobalComp ()->inputPauses ())
      myProblem ()->pauseForInput ("at the conclusion of opt implosion");

   if (myOptComp ()->accAfterOptImp ())
      {
      accelerated_ =
         myMsgFac ().displayStateChange (
            "accStateMsg",
            accelerated (),
            true);

      myOptComp ()->accOptStarter ()->beChosen ();
      }
   else
      shutDown ();

   myPostprocessor ()->postprocess ();
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::validateMipMode ()
   {
   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "computeCriticalList");

   if (myOptComp ()->compPrices ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "compPrices");

   if (myOptComp ()->accAfterOptImp ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "accAfterOptImp");
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::compInitSoln ()
   {
   myOptComp ()->optInitMethod ()->display ();

   if (myOptComp ()->heurOptStarter ()->isChosen ())
      {
      if (myOptComp ()->multiObjMode ())
         heurImpOnFirstObj ();
      else
         myProblem ()->myHeurImploder ()->implodeForOpt ();
      }
   else if (myOptComp ()->accOptStarter ()->isChosen ())
      {
      witAssert (accelerated ());
      }
   else if (myOptComp ()->schedOptStarter ()->isChosen ())
      {
      myPostprocessor ()->postprocess ();
      }
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::heurImpOnFirstObj ()
   {
   WitObjective * savedObj;
   WitObjective * firstObj;

   savedObj = myOptComp ()->myMultiObjMgr ()->currentObjective ();
   firstObj = myOptComp ()->myMultiObjMgr ()->myObjectives     ().first ();

   myOptComp ()->myMultiObjMgr ()->setCurrentObjective (firstObj);

   myProblem ()->myHeurImploder ()->implodeForOpt ();

   myOptComp ()->myMultiObjMgr ()->setCurrentObjective (savedObj);
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::setUpOptProblem ()
   {
   if (myDetImpOP_ == NULL)
      {
      myMsgFac () ("genLpMipProbMsg",
         myMsgFac ().myFrag (myOptComp ()->mipMode ()? "mipFrag": "lpFrag"));

      myDetImpOP_ = new WitDetImpOP (myProblem ());

      myDetImpOP ()->generateFixed ();
      }
   else
      myMsgFac () ("updateOptProblemMsg");

   myDetImpOP ()->generateFlexible ();
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::compInitOptSoln ()
   {
   myDetImpOP ()->calcInitSoln ();

   if (DEVELOPMENT)
      {
      compObjectives ();

      myMsgFac () ("initObjMsg");

      myOptComp ()->writeObjValue ();
      }

   if (myOptComp ()->printInitSoln ())
      myDetImpOP ()->writeSoln ("initSoln.out");
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::compObjectives ()
   {
   if (myOptComp ()->multiObjMode ())
      {
      compMultiObj ();
      }
   else
      {
      compSglObj ();
      }
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::compSglObj ()
   {
   double      objValue;
   double      boundsValue;
   WitOptVar * theOptVar;

   witAssert (not myOptComp ()->multiObjMode ());

   uploadingSoln_ = true;

   objValue       = myDetImpOP ()->compObjValue ();

   myOptComp ()->storeOptObjValue (objValue);

   if (myDetImpOP ()->slbvVarsExist ())
      {
      boundsValue = 0.0;

      forEachEl (theOptVar, myDetImpOP ()->myOptVars ())
         {
         if (theOptVar->mandDetVar ()->isSlbvVar ())
            boundsValue += theOptVar->primalValue ();
         }

      myOptComp ()->storeOptBoundsValue (boundsValue);
      }

   uploadingSoln_ = false;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::compMultiObj ()
   {
   WitObjective * theObj;
   double         objValue;
   double         boundsValue;

   witAssert (myOptComp ()->multiObjMode ());

   uploadingSoln_ = true;

   forEachEl (theObj, myOptComp ()->myMultiObjMgr ()->myObjectives ())
      {
      objValue = myDetImpOP ()->myMultiObjVar (theObj)->primalValue ();

      theObj->storeOptObjValue (objValue);
      }

   if (myDetImpOP ()->slbvVarsExist ())
      {
      boundsValue = - myDetImpOP ()->myNtbvVar ()->primalValue ();

      myOptComp ()->storeOptBoundsValue (boundsValue);
      }

   uploadingSoln_ = false;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::uploadSoln ()
   {
   WitOptVar *      theOptVar;
   WitPart *        thePart;
   WitPeriod        thePer;
   WitResourceCon * theResCon;

   uploadingSoln_ = true;

   forEachEl (theOptVar, myDetImpOP ()->myOptVars ())
      {
      if (not extOptActive_)
         if (theOptVar->primalValue () <= 0.0)
            continue;

      theOptVar->mandDetVar ()->uploadSoln ();
      }

   if (myOptComp ()->compPrices ())
      forEachPart (thePart, myProblem ())
         forEachPeriod (thePer, myProblem ())
            {
            theResCon = myDetImpOP ()->myResourceCon (thePart, thePer);

            if (theResCon != NULL)
               thePart->storeOptShadowPrice (thePer, theResCon->dualValue ());
            }

   myGlobalComp ()->receiveOptRevCritList (revCritList_);

   uploadingSoln_ = false;
   }

//------------------------------------------------------------------------------

double WitDetOptImpMgr::solnValue (const WitOptVar * theOptVar)
   {
   if (theOptVar == NULL)
      return 0.0;

   else if (extOptActive_)
      return theOptVar->primalValue ();

   else
      return positivePart (theOptVar->primalValue ());
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::buildCritList ()
   {
   double                    criticalEpsilon;
   WitPart *                 thePart;
   WitTVec <bool>            producible (myProblem (), false);
   WitPeriod                 execPer;
   WitPeriod                 thePer;
   WitBopEntry *             theBopEnt;
   int                       theIdx;
   WitPartPer *              thePartPer;
   WitPtrVec    <WitPartPer> criticalVec;
   WitPtrVecItr <WitPartPer> theItr;

   stronglyAssert (revCritList_.isEmpty ());

   if (not myGlobalComp ()->computeCriticalList ())
      return;

   myMsgFac () ("formCriticalListMsg");

   criticalEpsilon = .001;

   potential_.allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      producible = false;

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->inEffect (execPer))
               producible[theBopEnt->impactPeriod ()[execPer]] = true;

      forEachPeriod (thePer, myProblem ())
         {
         if (producible[thePer])
            continue;

         potential_ (thePart)[thePer] =
            myDetImpOP ()->myResourceCon (thePart, thePer)->dualValue ();

         if (potential_ (thePart)[thePer] <= criticalEpsilon)
            continue;

         revCritList_.push (thePart, thePer);
         }
      }

   criticalVec.resize (revCritList_.nElements ());

   theIdx = -1;

   while (revCritList_.pop (thePart, thePer))
      {
      theIdx ++;

      criticalVec[theIdx] = new WitPartPer (thePart, thePer);
      }

   sort (
        criticalVec,
      & WitDetOptImpMgr::comparePotential,
        this);

   criticalVec.attachItr (theItr);

   while (theItr.advance (thePartPer))
      {
      revCritList_.push (thePartPer->first, thePartPer->second);

      delete thePartPer;
      }

   criticalVec.clear ();
   potential_ .clear ();
   }

//------------------------------------------------------------------------------

bool WitDetOptImpMgr::comparePotential (
      WitPartPer * thePartPer1,
      WitPartPer * thePartPer2)
   {
   WitPart * thePart1;
   WitPart * thePart2;
   WitPeriod thePer1;
   WitPeriod thePer2;
   double    thePot1;
   double    thePot2;

   thePart1  = thePartPer1->first;
   thePart2  = thePartPer2->first;

   thePer1   = thePartPer1->second;
   thePer2   = thePartPer2->second;

   thePot1   = potential_ (thePart1)[thePer1];
   thePot2   = potential_ (thePart2)[thePer2];

   return (thePot1 > thePot2);
   }
@


1.57
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.56
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d51 1
a51 1
WitProbAssoc   (theProblem),
d53 10
a62 10
myDetImpOP_    (NULL),
extOptActive_  (false),
myExtOptMgr_   (NULL),
accelerated_   (false),
clearingSoln_  (false),
uploadingSoln_ (false),
revCritList_   (myProblem ()),
potential_     ()
{
}
d67 2
a68 2
{
shutDown ();
d70 2
a71 2
delete myExtOptMgr_;
}
d76 11
a86 11
{
if (myDetImpOP_ == NULL)
return;

if (accelerated ())
{
accelerated_ =
myMsgFac ().displayStateChange (
"unaccStateMsg",
accelerated (),
false);
d88 2
a89 2
myOptComp ()->crashOptStarter ()->beChosen ();
}
d91 1
a91 1
delete myDetImpOP_;
d93 2
a94 2
myDetImpOP_ = NULL;
}
d99 2
a100 2
{
WitTimer::enterSection ("opt-prob");
d102 1
a102 1
myMsgFac () ("optImpMsg");
d104 1
a104 1
myOptComp ()->requireCplex ();
d106 2
a107 2
if (myOptComp ()->multiObjMode ())
myOptComp ()->myMultiObjMgr ()->validateData ();
d109 1
a109 1
startOptImp  ();
d111 1
a111 1
myDetImpOP ()->solve ();
d113 1
a113 1
myProblem ()->optVariant ()->becomesCurrent ();
d115 1
a115 1
finishOptImp ();
d117 2
a118 2
WitTimer::leaveSection ("opt-prob");
}
d123 2
a124 2
{
WitTimer::enterSection ("opt-prob");
d126 1
a126 1
myProblem ()->inputVariant ()->becomesCurrent ();
d128 1
a128 1
myPreprocessor ()->preprocess ();
d130 1
a130 1
setUpOptProblem ();
d132 2
a133 2
if (myOptComp ()->printOptProblem ())
myDetImpOP ()->print ();
d135 1
a135 1
myPostprocessor ()->postprocess ();
d137 2
a138 2
if (not myGlobalComp ()->feasible ())
myMsgFac () ("infeasObjWmsg");
d140 1
a140 1
myDetImpOP ()->calcInitSoln ();
d142 1
a142 1
compObjectives ();
d144 2
a145 2
WitTimer::leaveSection ("opt-prob");
}
d150 3
a152 3
{
return myDetImpOP ()->slbvVarsExist ();
}
d157 2
a158 2
{
WitTimer::enterSection ("opt-prob");
d160 5
a164 5
stronglyAssert (not myGlobalComp ()->computeCriticalList ());
stronglyAssert (not myOptComp    ()->compPrices          ());
stronglyAssert (not myOptComp    ()->accAfterOptImp      ());
stronglyAssert (not myOptComp    ()->multiObjMode        ());
stronglyAssert (not extOptActive_);
d166 1
a166 1
myMsgFac () ("startExtOptMsg");
d168 1
a168 1
extOptActive_ = true;
d170 1
a170 1
startOptImp ();
d172 1
a172 1
myExtOptMgr_ = new WitExtOptMgr (myDetImpOP ());
d174 2
a175 2
WitTimer::leaveSection ("opt-prob");
}
d180 2
a181 2
{
WitTimer::enterSection ("opt-prob");
d183 1
a183 1
stronglyAssert (extOptActive_);
d185 1
a185 1
stronglyAssert (myExtOptMgr_->solnProvided ());
d187 1
a187 1
myMsgFac () ("finishExtOptMsg");
d189 1
a189 1
delete myExtOptMgr_;
d191 1
a191 1
myExtOptMgr_ = NULL;
d193 1
a193 1
myProblem ()->extOptVariant ()->becomesCurrent ();
d195 1
a195 1
finishOptImp ();
d197 1
a197 1
extOptActive_ = false;
d199 2
a200 2
WitTimer::leaveSection ("opt-prob");
}
d205 2
a206 2
{
WitTimer::enterSection ("opt-prob");
d208 1
a208 1
stronglyAssert (extOptActive_);
d210 1
a210 1
myMsgFac () ("shutDownExtOptMsg");
d212 1
a212 1
delete myExtOptMgr_;
d214 1
a214 1
myExtOptMgr_ = NULL;
d216 1
a216 1
shutDown ();
d218 2
a219 2
WitTimer::leaveSection ("opt-prob");
}
d224 2
a225 2
{
WitComponent * theComp;
d227 1
a227 1
myProblem ()->resetSoln ();
d229 2
a230 2
if (myCompMgr ()->nParts () == 0)
myMsgFac () ("noPartsSmsg");
d232 2
a233 2
if (myOptComp ()->mipMode ())
validateMipMode ();
d235 1
a235 1
myPreprocessor ()->preprocess ();
d237 2
a238 2
if (not extOptActive_)
compInitSoln ();
d240 1
a240 1
setUpOptProblem ();
d242 3
a244 3
if (not extOptActive_)
if (myOptComp ()->optInitMethod ()->external ())
compInitOptSoln ();
d246 1
a246 1
clearingSoln_ = true;
d248 2
a249 2
forEachEl (theComp, myCompMgr ()->allComponents ())
theComp->clearOptSoln ();
d251 2
a252 2
clearingSoln_ = false;
}
d257 3
a259 3
{
if (myOptComp ()->printOptSoln ())
myDetImpOP ()->writeSoln ("opSoln.out");
d261 1
a261 1
buildCritList ();
d263 1
a263 1
uploadSoln ();
d265 1
a265 1
compObjectives ();
d267 1
a267 1
myOptComp ()->writeObjValue ();
d269 2
a270 2
if (myGlobalComp ()->inputPauses ())
myProblem ()->pauseForInput ("at the conclusion of opt implosion");
d272 7
a278 7
if (myOptComp ()->accAfterOptImp ())
{
accelerated_ =
myMsgFac ().displayStateChange (
"accStateMsg",
accelerated (),
true);
d280 4
a283 4
myOptComp ()->accOptStarter ()->beChosen ();
}
else
shutDown ();
d285 2
a286 2
myPostprocessor ()->postprocess ();
}
d291 10
a300 10
{
if (myGlobalComp ()->computeCriticalList ())
myMsgFac () ("invalidAttrForMipModeSmsg", "computeCriticalList");

if (myOptComp ()->compPrices ())
myMsgFac () ("invalidAttrForMipModeSmsg", "compPrices");

if (myOptComp ()->accAfterOptImp ())
myMsgFac () ("invalidAttrForMipModeSmsg", "accAfterOptImp");
}
d305 2
a306 2
{
myOptComp ()->optInitMethod ()->display ();
d308 16
a323 16
if (myOptComp ()->heurOptStarter ()->isChosen ())
{
if (myOptComp ()->multiObjMode ())
heurImpOnFirstObj ();
else
myProblem ()->myHeurImploder ()->implodeForOpt ();
}
else if (myOptComp ()->accOptStarter ()->isChosen ())
{
witAssert (accelerated ());
}
else if (myOptComp ()->schedOptStarter ()->isChosen ())
{
myPostprocessor ()->postprocess ();
}
}
d328 3
a330 3
{
WitObjective * savedObj;
WitObjective * firstObj;
d332 2
a333 2
savedObj = myOptComp ()->myMultiObjMgr ()->currentObjective ();
firstObj = myOptComp ()->myMultiObjMgr ()->myObjectives     ().first ();
d335 1
a335 1
myOptComp ()->myMultiObjMgr ()->setCurrentObjective (firstObj);
d337 1
a337 1
myProblem ()->myHeurImploder ()->implodeForOpt ();
d339 2
a340 2
myOptComp ()->myMultiObjMgr ()->setCurrentObjective (savedObj);
}
d345 12
a356 12
{
if (myDetImpOP_ == NULL)
{
myMsgFac () ("genLpMipProbMsg",
myMsgFac ().myFrag (myOptComp ()->mipMode ()? "mipFrag": "lpFrag"));

myDetImpOP_ = new WitDetImpOP (myProblem ());

myDetImpOP ()->generateFixed ();
}
else
myMsgFac () ("updateOptProblemMsg");
d358 2
a359 2
myDetImpOP ()->generateFlexible ();
}
d364 2
a365 2
{
myDetImpOP ()->calcInitSoln ();
d367 3
a369 3
if (DEVELOPMENT)
{
compObjectives ();
d371 1
a371 1
myMsgFac () ("initObjMsg");
d373 2
a374 2
myOptComp ()->writeObjValue ();
}
d376 3
a378 3
if (myOptComp ()->printInitSoln ())
myDetImpOP ()->writeSoln ("initSoln.out");
}
d383 10
a392 10
{
if (myOptComp ()->multiObjMode ())
{
compMultiObj ();
}
else
{
compSglObj ();
}
}
d397 4
a400 4
{
double      objValue;
double      boundsValue;
WitOptVar * theOptVar;
d402 1
a402 1
witAssert (not myOptComp ()->multiObjMode ());
d404 1
a404 1
uploadingSoln_ = true;
d406 1
a406 1
objValue       = myDetImpOP ()->compObjValue ();
d408 1
a408 1
myOptComp ()->storeOptObjValue (objValue);
d410 3
a412 3
if (myDetImpOP ()->slbvVarsExist ())
{
boundsValue = 0.0;
d414 5
a418 5
forEachEl (theOptVar, myDetImpOP ()->myOptVars ())
{
if (theOptVar->mandDetVar ()->isSlbvVar ())
boundsValue += theOptVar->primalValue ();
}
d420 2
a421 2
myOptComp ()->storeOptBoundsValue (boundsValue);
}
d423 2
a424 2
uploadingSoln_ = false;
}
d429 4
a432 4
{
WitObjective * theObj;
double         objValue;
double         boundsValue;
d434 1
a434 1
witAssert (myOptComp ()->multiObjMode ());
d436 1
a436 1
uploadingSoln_ = true;
d438 3
a440 3
forEachEl (theObj, myOptComp ()->myMultiObjMgr ()->myObjectives ())
{
objValue = myDetImpOP ()->myMultiObjVar (theObj)->primalValue ();
d442 2
a443 2
theObj->storeOptObjValue (objValue);
}
d445 3
a447 3
if (myDetImpOP ()->slbvVarsExist ())
{
boundsValue = - myDetImpOP ()->myNtbvVar ()->primalValue ();
d449 2
a450 2
myOptComp ()->storeOptBoundsValue (boundsValue);
}
d452 2
a453 2
uploadingSoln_ = false;
}
d458 26
a483 26
{
WitOptVar *      theOptVar;
WitPart *        thePart;
WitPeriod        thePer;
WitResourceCon * theResCon;

uploadingSoln_ = true;

forEachEl (theOptVar, myDetImpOP ()->myOptVars ())
{
if (not extOptActive_)
if (theOptVar->primalValue () <= 0.0)
continue;

theOptVar->mandDetVar ()->uploadSoln ();
}

if (myOptComp ()->compPrices ())
forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
{
theResCon = myDetImpOP ()->myResourceCon (thePart, thePer);

if (theResCon != NULL)
thePart->storeOptShadowPrice (thePer, theResCon->dualValue ());
}
d485 1
a485 1
myGlobalComp ()->receiveOptRevCritList (revCritList_);
d487 2
a488 2
uploadingSoln_ = false;
}
d493 10
a502 10
{
if (theOptVar == NULL)
return 0.0;

else if (extOptActive_)
return theOptVar->primalValue ();

else
return positivePart (theOptVar->primalValue ());
}
d507 11
a517 11
{
double                    criticalEpsilon;
WitPart *                 thePart;
WitTVec <bool>            producible (myProblem (), false);
WitPeriod                 execPer;
WitPeriod                 thePer;
WitBopEntry *             theBopEnt;
int                       theIdx;
WitPartPer *              thePartPer;
WitPtrVec    <WitPartPer> criticalVec;
WitPtrVecItr <WitPartPer> theItr;
d519 1
a519 1
stronglyAssert (revCritList_.isEmpty ());
d521 2
a522 2
if (not myGlobalComp ()->computeCriticalList ())
return;
d524 1
a524 1
myMsgFac () ("formCriticalListMsg");
d526 1
a526 1
criticalEpsilon = .001;
d528 1
a528 1
potential_.allocate (myProblem (), 0.0);
d530 3
a532 3
forEachPart (thePart, myProblem ())
{
producible = false;
d534 4
a537 4
forEachEl (theBopEnt, thePart->producingBopEntries ())
forEachPeriod (execPer, myProblem ())
if (theBopEnt->inEffect (execPer))
producible[theBopEnt->impactPeriod ()[execPer]] = true;
d539 4
a542 4
forEachPeriod (thePer, myProblem ())
{
if (producible[thePer])
continue;
d544 2
a545 2
potential_ (thePart)[thePer] =
myDetImpOP ()->myResourceCon (thePart, thePer)->dualValue ();
d547 2
a548 2
if (potential_ (thePart)[thePer] <= criticalEpsilon)
continue;
d550 3
a552 3
revCritList_.push (thePart, thePer);
}
}
d554 1
a554 1
criticalVec.resize (revCritList_.nElements ());
d556 1
a556 1
theIdx = -1;
d558 3
a560 3
while (revCritList_.pop (thePart, thePer))
{
theIdx ++;
d562 2
a563 2
criticalVec[theIdx] = new WitPartPer (thePart, thePer);
}
d565 4
a568 4
sort (
criticalVec,
& WitDetOptImpMgr::comparePotential,
this);
d570 1
a570 1
criticalVec.attachItr (theItr);
d572 3
a574 3
while (theItr.advance (thePartPer))
{
revCritList_.push (thePartPer->first, thePartPer->second);
d576 2
a577 2
delete thePartPer;
}
d579 3
a581 3
criticalVec.clear ();
potential_ .clear ();
}
d586 12
a597 12
WitPartPer * thePartPer1,
WitPartPer * thePartPer2)
{
WitPart * thePart1;
WitPart * thePart2;
WitPeriod thePer1;
WitPeriod thePer2;
double    thePot1;
double    thePot2;

thePart1  = thePartPer1->first;
thePart2  = thePartPer2->first;
d599 2
a600 2
thePer1   = thePartPer1->second;
thePer2   = thePartPer2->second;
d602 2
a603 2
thePot1   = potential_ (thePart1)[thePer1];
thePot2   = potential_ (thePart2)[thePer2];
d605 2
a606 2
return (thePot1 > thePot2);
}
@


1.55
log
@Removed COIN from WIT.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d51 1
a51 1
      WitProbAssoc   (theProblem),
d53 10
a62 10
      myDetImpOP_    (NULL),
      extOptActive_  (false),
      myExtOptMgr_   (NULL),
      accelerated_   (false),
      clearingSoln_  (false),
      uploadingSoln_ (false),
      revCritList_   (myProblem ()),
      potential_     ()
   {                
   }
d67 2
a68 2
   {
   shutDown ();
d70 2
a71 2
   delete myExtOptMgr_;
   }
d76 11
a86 11
   {
   if (myDetImpOP_ == NULL)
      return;

   if (accelerated ())
      {
      accelerated_ =
         myMsgFac ().displayStateChange (
            "unaccStateMsg",
            accelerated (),
            false);
d88 2
a89 2
      myOptComp ()->crashOptStarter ()->beChosen ();
      }
d91 1
a91 1
   delete myDetImpOP_;
d93 2
a94 2
   myDetImpOP_ = NULL;
   }
d99 2
a100 2
   {
   WitTimer::enterSection ("opt-prob");
d102 1
a102 1
   myMsgFac () ("optImpMsg");
d104 1
a104 1
   myOptComp ()->requireCplex ();
d106 2
a107 2
   if (myOptComp ()->multiObjMode ())
      myOptComp ()->myMultiObjMgr ()->validateData ();
d109 1
a109 1
   startOptImp  ();
d111 1
a111 1
   myDetImpOP ()->solve ();
d113 1
a113 1
   myProblem ()->optVariant ()->becomesCurrent ();
d115 1
a115 1
   finishOptImp ();
d117 2
a118 2
   WitTimer::leaveSection ("opt-prob");
   }
d123 2
a124 2
   {
   WitTimer::enterSection ("opt-prob");
d126 1
a126 1
   myProblem ()->inputVariant ()->becomesCurrent ();
d128 1
a128 1
   myPreprocessor ()->preprocess ();
d130 1
a130 1
   setUpOptProblem ();
d132 2
a133 2
   if (myOptComp ()->printOptProblem ())
      myDetImpOP ()->print ();
d135 1
a135 1
   myPostprocessor ()->postprocess ();
d137 2
a138 2
   if (not myGlobalComp ()->feasible ())
      myMsgFac () ("infeasObjWmsg");
d140 1
a140 1
   myDetImpOP ()->calcInitSoln ();
d142 1
a142 1
   compObjectives ();
d144 2
a145 2
   WitTimer::leaveSection ("opt-prob");
   }
d150 3
a152 3
   {
   return myDetImpOP ()->slbvVarsExist ();
   }
d157 2
a158 2
   {
   WitTimer::enterSection ("opt-prob");
d160 5
a164 5
   stronglyAssert (not myGlobalComp ()->computeCriticalList ());
   stronglyAssert (not myOptComp    ()->compPrices          ());
   stronglyAssert (not myOptComp    ()->accAfterOptImp      ());
   stronglyAssert (not myOptComp    ()->multiObjMode        ());
   stronglyAssert (not extOptActive_);
d166 1
a166 1
   myMsgFac () ("startExtOptMsg");
d168 1
a168 1
   extOptActive_ = true;
d170 1
a170 1
   startOptImp ();
d172 1
a172 1
   myExtOptMgr_ = new WitExtOptMgr (myDetImpOP ());
d174 2
a175 2
   WitTimer::leaveSection ("opt-prob");
   }
d180 2
a181 2
   {
   WitTimer::enterSection ("opt-prob");
d183 1
a183 1
   stronglyAssert (extOptActive_);
d185 1
a185 1
   stronglyAssert (myExtOptMgr_->solnProvided ());
d187 1
a187 1
   myMsgFac () ("finishExtOptMsg");
d189 1
a189 1
   delete myExtOptMgr_;
d191 1
a191 1
   myExtOptMgr_ = NULL;
d193 1
a193 1
   myProblem ()->extOptVariant ()->becomesCurrent ();
d195 1
a195 1
   finishOptImp ();
d197 1
a197 1
   extOptActive_ = false;
d199 2
a200 2
   WitTimer::leaveSection ("opt-prob");
   }
d205 2
a206 2
   {
   WitTimer::enterSection ("opt-prob");
d208 1
a208 1
   stronglyAssert (extOptActive_);
d210 1
a210 1
   myMsgFac () ("shutDownExtOptMsg");
d212 1
a212 1
   delete myExtOptMgr_;
d214 1
a214 1
   myExtOptMgr_ = NULL;
d216 1
a216 1
   shutDown ();
d218 2
a219 2
   WitTimer::leaveSection ("opt-prob");
   }
d224 2
a225 2
   {
   WitComponent * theComp;
d227 1
a227 1
   myProblem ()->resetSoln ();
d229 2
a230 2
   if (myCompMgr ()->nParts () == 0)
      myMsgFac () ("noPartsSmsg");
d232 2
a233 2
   if (myOptComp ()->mipMode ())
      validateMipMode ();
d235 1
a235 1
   myPreprocessor ()->preprocess ();
d237 2
a238 2
   if (not extOptActive_)
      compInitSoln ();
d240 1
a240 1
   setUpOptProblem ();
d242 3
a244 3
   if (not extOptActive_)
      if (myOptComp ()->optInitMethod ()->external ())
         compInitOptSoln ();
d246 1
a246 1
   clearingSoln_ = true;
d248 2
a249 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->clearOptSoln ();
d251 2
a252 2
   clearingSoln_ = false;
   }
d257 3
a259 3
   {
   if (myOptComp ()->printOptSoln ())
      myDetImpOP ()->writeSoln ("opSoln.out");
d261 1
a261 1
   buildCritList ();
d263 1
a263 1
   uploadSoln ();
d265 1
a265 1
   compObjectives ();
d267 1
a267 1
   myOptComp ()->writeObjValue ();
d269 2
a270 2
   if (myGlobalComp ()->inputPauses ())
      myProblem ()->pauseForInput ("at the conclusion of opt implosion");
d272 7
a278 7
   if (myOptComp ()->accAfterOptImp ())
      {
      accelerated_ =
         myMsgFac ().displayStateChange (
            "accStateMsg",
            accelerated (),
            true);
d280 4
a283 4
      myOptComp ()->accOptStarter ()->beChosen ();
      }
   else
      shutDown ();
d285 2
a286 2
   myPostprocessor ()->postprocess ();
   }
d291 10
a300 10
   {
   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "computeCriticalList");

   if (myOptComp ()->compPrices ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "compPrices");

   if (myOptComp ()->accAfterOptImp ())
      myMsgFac () ("invalidAttrForMipModeSmsg", "accAfterOptImp");
   }
d305 2
a306 2
   {
   myOptComp ()->optInitMethod ()->display ();
d308 16
a323 16
   if (myOptComp ()->heurOptStarter ()->isChosen ())
      {
      if (myOptComp ()->multiObjMode ())
         heurImpOnFirstObj ();
      else
         myProblem ()->myHeurImploder ()->implodeForOpt ();
      }
   else if (myOptComp ()->accOptStarter ()->isChosen ())
      {
      witAssert (accelerated ());
      }
   else if (myOptComp ()->schedOptStarter ()->isChosen ())
      {
      myPostprocessor ()->postprocess ();
      }
   }
d328 3
a330 3
   {
   WitObjective * savedObj;
   WitObjective * firstObj;
d332 2
a333 2
   savedObj = myOptComp ()->myMultiObjMgr ()->currentObjective ();
   firstObj = myOptComp ()->myMultiObjMgr ()->myObjectives     ().first ();
d335 1
a335 1
   myOptComp ()->myMultiObjMgr ()->setCurrentObjective (firstObj);
d337 1
a337 1
   myProblem ()->myHeurImploder ()->implodeForOpt ();
d339 2
a340 2
   myOptComp ()->myMultiObjMgr ()->setCurrentObjective (savedObj);
   }
d345 12
a356 12
   {
   if (myDetImpOP_ == NULL)
      {
      myMsgFac () ("genLpMipProbMsg",
         myMsgFac ().myFrag (myOptComp ()->mipMode ()? "mipFrag": "lpFrag"));

      myDetImpOP_ = new WitDetImpOP (myProblem ());

      myDetImpOP ()->generateFixed ();
      }
   else
      myMsgFac () ("updateOptProblemMsg");
d358 2
a359 2
   myDetImpOP ()->generateFlexible ();
   }
d364 2
a365 2
   {
   myDetImpOP ()->calcInitSoln ();
d367 3
a369 3
   if (DEVELOPMENT)
      {
      compObjectives ();
d371 1
a371 1
      myMsgFac () ("initObjMsg");
d373 2
a374 2
      myOptComp ()->writeObjValue ();
      }
d376 3
a378 3
   if (myOptComp ()->printInitSoln ())
      myDetImpOP ()->writeSoln ("initSoln.out");
   }
d383 10
a392 10
   {
   if (myOptComp ()->multiObjMode ())
      {
      compMultiObj ();
      }
   else
      {
      compSglObj ();
      }
   }
d397 4
a400 4
   {
   double      objValue;
   double      boundsValue;
   WitOptVar * theOptVar;
d402 1
a402 1
   witAssert (not myOptComp ()->multiObjMode ());
d404 1
a404 1
   uploadingSoln_ = true;
d406 1
a406 1
   objValue       = myDetImpOP ()->compObjValue ();
d408 1
a408 1
   myOptComp ()->storeOptObjValue (objValue);
d410 3
a412 3
   if (myDetImpOP ()->slbvVarsExist ())
      {
      boundsValue = 0.0;
d414 5
a418 5
      forEachEl (theOptVar, myDetImpOP ()->myOptVars ())
         {
         if (theOptVar->mandDetVar ()->isSlbvVar ())
            boundsValue += theOptVar->primalValue ();
         }
d420 2
a421 2
      myOptComp ()->storeOptBoundsValue (boundsValue);
      }
d423 2
a424 2
   uploadingSoln_ = false;
   }
d429 4
a432 4
   {
   WitObjective * theObj;
   double         objValue;
   double         boundsValue;
d434 1
a434 1
   witAssert (myOptComp ()->multiObjMode ());
d436 1
a436 1
   uploadingSoln_ = true;
d438 3
a440 3
   forEachEl (theObj, myOptComp ()->myMultiObjMgr ()->myObjectives ())
      {
      objValue = myDetImpOP ()->myMultiObjVar (theObj)->primalValue ();
d442 2
a443 2
      theObj->storeOptObjValue (objValue);
      }
d445 3
a447 3
   if (myDetImpOP ()->slbvVarsExist ())
      {
      boundsValue = - myDetImpOP ()->myNtbvVar ()->primalValue ();
d449 2
a450 2
      myOptComp ()->storeOptBoundsValue (boundsValue);
      }
d452 2
a453 2
   uploadingSoln_ = false;
   }
d458 26
a483 26
   {
   WitOptVar *      theOptVar;
   WitPart *        thePart;
   WitPeriod        thePer;
   WitResourceCon * theResCon;

   uploadingSoln_ = true;

   forEachEl (theOptVar, myDetImpOP ()->myOptVars ())
      {
      if (not extOptActive_)
         if (theOptVar->primalValue () <= 0.0)
            continue;

      theOptVar->mandDetVar ()->uploadSoln ();
      }

   if (myOptComp ()->compPrices ())
      forEachPart (thePart, myProblem ())
         forEachPeriod (thePer, myProblem ())
            {
            theResCon = myDetImpOP ()->myResourceCon (thePart, thePer);

            if (theResCon != NULL)
               thePart->storeOptShadowPrice (thePer, theResCon->dualValue ());
            }
d485 1
a485 1
   myGlobalComp ()->receiveOptRevCritList (revCritList_);
d487 2
a488 2
   uploadingSoln_ = false;
   }
d493 10
a502 10
   {
   if (theOptVar == NULL)
      return 0.0;

   else if (extOptActive_)
      return theOptVar->primalValue ();

   else
      return positivePart (theOptVar->primalValue ());
   }
d507 11
a517 11
   {
   double                    criticalEpsilon;
   WitPart *                 thePart;
   WitTVec <bool>            producible (myProblem (), false);
   WitPeriod                 execPer;
   WitPeriod                 thePer;
   WitBopEntry *             theBopEnt;
   int                       theIdx;
   WitPartPer *              thePartPer;
   WitPtrVec    <WitPartPer> criticalVec;
   WitPtrVecItr <WitPartPer> theItr;
d519 1
a519 1
   stronglyAssert (revCritList_.isEmpty ());
d521 2
a522 2
   if (not myGlobalComp ()->computeCriticalList ())
      return;
d524 1
a524 1
   myMsgFac () ("formCriticalListMsg");
d526 1
a526 1
   criticalEpsilon = .001;
d528 1
a528 1
   potential_.allocate (myProblem (), 0.0);
d530 3
a532 3
   forEachPart (thePart, myProblem ())
      {
      producible = false;
d534 4
a537 4
      forEachEl (theBopEnt, thePart->producingBopEntries ())
         forEachPeriod (execPer, myProblem ())
            if (theBopEnt->inEffect (execPer))
               producible[theBopEnt->impactPeriod ()[execPer]] = true;
d539 4
a542 4
      forEachPeriod (thePer, myProblem ())
         {
         if (producible[thePer])
            continue;
d544 2
a545 2
         potential_ (thePart)[thePer] =
            myDetImpOP ()->myResourceCon (thePart, thePer)->dualValue ();
d547 2
a548 2
         if (potential_ (thePart)[thePer] <= criticalEpsilon)
            continue;
d550 3
a552 3
         revCritList_.push (thePart, thePer);
         }
      }
d554 1
a554 1
   criticalVec.resize (revCritList_.nElements ());
d556 1
a556 1
   theIdx = -1;
d558 3
a560 3
   while (revCritList_.pop (thePart, thePer))
      {
      theIdx ++;
d562 2
a563 2
      criticalVec[theIdx] = new WitPartPer (thePart, thePer);
      }
d565 4
a568 4
   sort (
        criticalVec,
      & WitDetOptImpMgr::comparePotential,
        this);
d570 1
a570 1
   criticalVec.attachItr (theItr);
d572 3
a574 3
   while (theItr.advance (thePartPer))
      {
      revCritList_.push (thePartPer->first, thePartPer->second);
d576 2
a577 2
      delete thePartPer;
      }
d579 3
a581 3
   criticalVec.clear ();
   potential_ .clear ();
   }
d586 12
a597 12
      WitPartPer * thePartPer1,
      WitPartPer * thePartPer2)
   {
   WitPart * thePart1;
   WitPart * thePart2;
   WitPeriod thePer1;
   WitPeriod thePer2;
   double    thePot1;
   double    thePot2;

   thePart1  = thePartPer1->first;
   thePart2  = thePartPer2->first;
d599 2
a600 2
   thePer1   = thePartPer1->second;
   thePer2   = thePartPer2->second;
d602 2
a603 2
   thePot1   = potential_ (thePart1)[thePer1];
   thePot2   = potential_ (thePart2)[thePer2];
d605 2
a606 2
   return (thePot1 > thePot2);
   }
@


1.54
log
@Added severe error for selecting a solver that's not embedded.
@
text
@d88 1
a88 4
      if (myOptComp ()->cplexSelected ())
         myOptComp ()->crashOptStarter ()->beChosen ();
      else
         myOptComp ()->heurOptStarter  ()->beChosen ();
d104 1
a104 1
   myOptComp ()->requireSolver ();
@


1.53
log
@Fixed a bug in optInitMethod
@
text
@d107 1
a107 1
   myOptComp ()->validateSolver ();
@


1.52
log
@CPLEX
@
text
@d77 2
a78 6
   if (myDetImpOP_ != NULL)
      {
      delete myDetImpOP_;

      myDetImpOP_ = NULL;
      }
d81 1
a87 2
   if (myOptComp ()->accOptStarter ()->isChosen ())
      {
d93 4
@


1.51
log
@Allowed intExecVols, etc. with mipMode == false.
@
text
@a84 4
      {
      if (myOptComp ()->accOptStarter ()->isChosen ())
         myOptComp ()->heurOptStarter ()->beChosen ();

d90 7
@


1.50
log
@CPLEX
@
text
@a234 2
   else
      myPreprocessor ()->verifyNoIntCons ();
@


1.49
log
@CPLEX
@
text
@a106 3
   if (myOptComp ()->cplexSelected ())
      validateForCplex ();

a223 10
void WitDetOptImpMgr::validateForCplex ()
   {
   if (myOptComp ()->multiObjMode ())
      if (not myOptComp ()->allowMultiCplex ())
         myMsgFac () ("cplexSolveNyaSmsg",
            "Optimizing implosion in multiple objectives mode");
   }

//------------------------------------------------------------------------------

@


1.48
log
@CPLEX
@
text
@a232 4

   if (myOptComp ()->multiObjMode ()) 
      if (myOptComp ()->mipMode ())
         myMsgFac () ("cplexSolveTermSmsg");
@


1.47
log
@CPLEX
@
text
@d230 7
a236 2
      myMsgFac () ("cplexSolveNyaSmsg",
         "Optimizing implosion in multiple objectives mode");
@


1.46
log
@CPLEX
@
text
@a228 4
   if (not myOptComp ()->allowMipCplex ())
      if (myOptComp ()->mipMode ())
         myMsgFac () ("cplexSolveNyaSmsg", "Optimizing implosion in MIP mode");

@


1.45
log
@CPLEX
@
text
@d229 3
a231 2
   if (myOptComp ()->mipMode ())
      myMsgFac () ("cplexSolveNyaSmsg", "Optimizing implosion in MIP mode");
@


1.44
log
@CPLEX
@
text
@a228 4
   if (myOptComp ()->accAfterOptImp ())
      if (not myOptComp ()->accCplexAllowed ())
         myMsgFac () ("cplexSolveNyaSmsg", "Accelerated optimizing implosion");

@


1.43
log
@CPLEX
@
text
@d230 2
a231 1
      myMsgFac () ("cplexSolveNyaSmsg", "Accelerated optimizing implosion");
@


1.42
log
@CPLEX
@
text
@a255 3
   if (myOptComp ()->mipMode ())
      useCrashStartForMip ();

a324 14
void WitDetOptImpMgr::useCrashStartForMip ()
   {
   if (not myOptComp ()->crashOptStarter ()->isChosen ())
      {
      myMsgFac () ("changeOptInitForMipMsg",
         myOptComp ()->optInitMethod ()->myApiAttr (),
         WitCRASH_OPT_INIT_METHOD);

      myOptComp ()->crashOptStarter ()->beChosen ();
      }
   }

//------------------------------------------------------------------------------

@


1.41
log
@CPLEX
@
text
@d105 1
a105 5
   if    (not myOptComp ()->coinSelected  ())
      if (not myOptComp ()->cplexSelected ())
         {
         myMsgFac () ("optImpWoSolverSmsg");
         }
@


1.40
log
@CPLEX
@
text
@d105 5
a109 1
   stronglyAssert (solverEmbedded ());
@


1.39
log
@CPLEX
@
text
@d107 1
a107 1
   if (myOptComp ()->solverIsCplex ())
@


1.38
log
@Heuristic Adjustment
@
text
@a228 3
   if (not myOptComp ()->cplexAllowed ())
      myMsgFac () ("cplexSolveNyaSmsg", "Optimizing implosion");

@


1.37
log
@pause/resume
@
text
@d31 1
a31 1
#include <Opn.h>
@


1.36
log
@CPLEX
@
text
@d296 1
a296 1
   if (myGlobalComp ()->pauses ())
@


1.35
log
@CPLEX
@
text
@d22 1
a22 1
#include <DetImpOM.h>
d53 1
a53 1
      myDetImpOM_    (NULL),
d77 1
a77 1
   if (myDetImpOM_ != NULL)
d79 1
a79 1
      delete myDetImpOM_;
d81 1
a81 1
      myDetImpOM_ = NULL;
d115 1
a115 1
   myDetImpOM ()->solve ();
d134 1
a134 1
   setUpOptModel ();
d136 2
a137 2
   if (myOptComp ()->printOptModel ())
      myDetImpOM ()->print ();
d144 1
a144 1
   myDetImpOM ()->calcInitSoln ();
d155 1
a155 1
   return myDetImpOM ()->slbvVarsExist ();
d176 1
a176 1
   myExtOptMgr_ = new WitExtOptMgr (myDetImpOM ());
d267 1
a267 1
   setUpOptModel ();
d286 1
a286 1
      myDetImpOM ()->writeSoln ("opSoln.out");
d385 1
a385 1
void WitDetOptImpMgr::setUpOptModel ()
d387 1
a387 1
   if (myDetImpOM_ == NULL)
d392 1
a392 1
      myDetImpOM_ = new WitDetImpOM (myProblem ());
d394 1
a394 1
      myDetImpOM ()->generateFixed ();
d397 1
a397 1
      myMsgFac () ("updateOptModelMsg");
d399 1
a399 1
   myDetImpOM ()->generateFlexible ();
d406 1
a406 1
   myDetImpOM ()->calcInitSoln ();
d418 1
a418 1
      myDetImpOM ()->writeSoln ("initSoln.out");
d447 1
a447 1
   objValue       = myDetImpOM ()->compObjValue ();
d451 1
a451 1
   if (myDetImpOM ()->slbvVarsExist ())
d455 1
a455 1
      forEachEl (theOptVar, myDetImpOM ()->myOptVars ())
d481 1
a481 1
      objValue = myDetImpOM ()->myMultiObjVar (theObj)->primalValue ();
d486 1
a486 1
   if (myDetImpOM ()->slbvVarsExist ())
d488 1
a488 1
      boundsValue = - myDetImpOM ()->myNtbvVar ()->primalValue ();
d507 1
a507 1
   forEachEl (theOptVar, myDetImpOM ()->myOptVars ())
d520 1
a520 1
            theResCon = myDetImpOM ()->myResourceCon (thePart, thePer);
d586 1
a586 1
            myDetImpOM ()->myResourceCon (thePart, thePer)->dualValue ();
@


1.34
log
@CPLEX
@
text
@d103 1
a103 4
   if (myOptComp ()->solverIsCplex ())
      if (not myOptComp ()->cplexAllowed ())
         myMsgFac () ("cplexSolveNyaSmsg",
            myMsgFac ().myFrag ("optImpFrag"));
d107 2
a108 1
   myMsgFac () ("optImpMsg");
d227 18
@


1.33
log
@CPLEX
@
text
@d108 1
a108 1
   stronglyAssert (WitOptComp::solverEmbedded ());
@


1.32
log
@CPLEX
@
text
@d103 4
a106 3
   if (not COIN_EMBEDDED)
      if (CPLEX_EMBEDDED)
         myMsgFac () ("optWCplexWoCoinSmsg");
@


1.31
log
@CPLEX
@
text
@d103 2
a104 2
   if (not WitOptComp::coinEmbedded ())
      if (WitOptComp::cplexEmbedded ())
@


1.30
log
@Preparing for embedded CPLEX.
@
text
@d103 4
@


1.29
log
@Revising the build procedure.
@
text
@d103 1
a103 1
   stronglyAssert (SOLVER_EMBEDDED);
@


1.28
log
@Revising the build procedure.
@
text
@d103 1
a103 1
   stronglyAssert (COIN_EMBEDDED);
@


1.27
log
@Revising the build process.
@
text
@d103 1
a103 1
   stronglyAssert (WIT_EMBEDS_COIN);
@


1.26
log
@Removed OptObj classes.
@
text
@d103 1
a103 1
   stronglyAssert (WitOptComp::optImpAllowed ());
@


1.25
log
@Removed class BoundsObj.
@
text
@a24 1
#include <DetObjs.h>
d418 2
a419 2
   double      objValueVal;
   double      boundsValueVal;
d426 1
a426 1
   objValueVal    = myDetImpOM ()->mainObj ()->myValue ();
d428 1
a428 1
   myOptComp ()->storeOptObjValue (objValueVal);
d432 1
a432 1
      boundsValueVal = 0.0;
d437 1
a437 1
            boundsValueVal += theOptVar->primalValue ();
d440 1
a440 1
      myOptComp ()->storeOptBoundsValue (boundsValueVal);
d451 2
a452 2
   double         objValueVal;
   double         boundsValueVal;
d460 1
a460 1
      objValueVal = myDetImpOM ()->myMultiObjVar (theObj)->primalValue ();
d462 1
a462 1
      theObj->storeOptObjValue (objValueVal);
d467 1
a467 1
      boundsValueVal = - myDetImpOM ()->myNtbvVar ()->primalValue ();
d469 1
a469 1
      myOptComp ()->storeOptBoundsValue (boundsValueVal);
@


1.24
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d419 3
a421 2
   double objValueVal;
   double boundsValueVal;
d433 7
a439 1
      boundsValueVal = myDetImpOM ()->myBoundsObj ()->myValue ();
@


1.23
log
@Multi-Obj Mode
@
text
@d35 1
a35 1
#include <Global.h>
@


1.22
log
@Multi-Obj Mode
@
text
@d461 1
a461 1
      boundsValueVal = myDetImpOM ()->myNtbvVar ()->primalValue ();
@


1.21
log
@Multi-Obj Mode
@
text
@d461 1
a461 1
      boundsValueVal = myDetImpOM ()->myTbvVar ()->primalValue ();
@


1.20
log
@Multi-Obj Mode
@
text
@d424 2
d428 2
d431 1
a432 2
   else
      boundsValueVal = 0.0;
d434 2
a435 4
   uploadingSoln_ = true;

   myOptComp ()->storeOptObjValue    (objValueVal);
   myOptComp ()->storeOptBoundsValue (boundsValueVal);
d460 1
a461 2
   else
      boundsValueVal = 0.0;
d463 2
a464 1
   myOptComp ()->storeOptBoundsValue (boundsValueVal);
@


1.19
log
@Multi-Obj Mode
@
text
@d426 4
a429 4
   boundsValueVal = 
      myDetImpOM ()->slbvVarsExist ()?
         myDetImpOM ()->myBoundsObj ()->myValue ():
         0.0;
d445 1
d458 7
@


1.18
log
@Implemented: optInitMethed is changed to crash in MIP mode.
@
text
@d325 1
a325 1
void WitDetOptImpMgr::compInitSoln () const
d330 15
a344 1
      myProblem ()->myHeurImploder ()->implodeForOpt ();
d346 13
a358 2
   if (myOptComp ()->accOptStarter ()->isChosen ())
      witAssert (accelerated ());
d360 1
a360 2
   if (myOptComp ()->schedOptStarter ()->isChosen ())
      myPostprocessor ()->postprocess ();
@


1.17
log
@Multi-objective mode.
@
text
@d39 1
d239 3
d311 14
@


1.16
log
@Multi-objective mode
@
text
@d328 1
a328 4
         myMsgFac ().myFrag (
            myOptComp ()->mipMode ()?
               "mipFrag":
               "lpFrag"));
@


1.15
log
@Multi-objective mode
@
text
@d407 2
@


1.14
log
@Multi-objective mode
@
text
@a149 15
void WitDetOptImpMgr::compObj2Values (
      double & revValue,
      double & invValue,
      double & servValue,
      double & subValue)
      const
   {
   revValue  = 0.0;
   invValue  = 0.0;
   servValue = 0.0;
   subValue  = 0.0;
   }

//------------------------------------------------------------------------------

d366 14
d383 2
d394 16
a409 1
   if (not myOptComp ()->multiObjMode ())
d411 3
a413 1
      myOptComp ()->storeOptObjValue (objValueVal);
a415 2
   myOptComp ()->storeOptBoundsValue (boundsValueVal);

@


1.13
log
@Multi-objective mode
@
text
@d279 4
a286 4
   buildCritList ();

   uploadSoln ();

d381 2
a382 4
   double         objValueVal;
   double         boundsValueVal;
   WitObjective * theObj;
   double         dummyObjValueVal;
d393 1
a393 1
   if (myOptComp ()->multiObjMode ())
d395 1
a395 6
      forEachEl (theObj, myOptComp ()->myMultiObjMgr ()->myObjectives ())
         {
         dummyObjValueVal = objValueVal + theObj->objectiveSeqNo ();

         theObj->storeOptObjValue (dummyObjValueVal);
         }
a396 2
   else
      myOptComp ()->storeOptObjValue (objValueVal);
@


1.12
log
@Multi-Objective Mode.
@
text
@d20 1
d281 1
a281 1
   myMsgFac () ("objValueMsg", myOptComp ()->objValue ());
d370 1
a370 1
      myMsgFac () ("objValueMsg", myOptComp ()->objValue ());
d381 4
a384 2
   double objValueVal;
   double boundsValueVal;
d395 12
a406 1
   myOptComp ()->storeOptObjValue    (objValueVal);
@


1.11
log
@Multi-Objective Mode.
@
text
@d176 3
a178 2
   stronglyAssert (not myOptComp    ()->compPrices ());
   stronglyAssert (not myOptComp    ()->accAfterOptImp ());
@


1.10
log
@Removing objective #2.
@
text
@d19 1
d106 3
@


1.9
log
@Removing objective #2.
@
text
@d275 1
a275 1
   myMsgFac () ("obj1ValueMsg", myOptComp ()->objValue ());
d364 1
a364 1
      myMsgFac () ("obj1ValueMsg", myOptComp ()->objValue ());
@


1.8
log
@Removing objective #2.
@
text
@d375 2
a376 3
   double       objValueVal;
   double       boundsValueVal;
   WitObjFunc * theObjFunc;
@


1.7
log
@Removing objective #2.
@
text
@a241 2
   objChoice ()->validateForOptImp ();

d275 1
a275 1
   objChoice ()->writeValues ();
a348 2
   objChoice ()->finalPreprocess ();

d364 1
a364 1
      objChoice ()->writeValues ();
a391 5

   forEachEl (theObjFunc, myOptComp ()->allObjFuncs ())
      theObjFunc->initValues ();

   objChoice ()->compValues ();
@


1.6
log
@Stochastic Implosion
@
text
@d152 4
a155 4
   revValue  = myDetImpOM ()-> myRevObj ()->myValue ();
   invValue  = myDetImpOM ()-> myInvObj ()->myValue ();
   servValue = myDetImpOM ()->myServObj ()->myValue ();
   subValue  = myDetImpOM ()-> mySubObj ()->myValue ();
@


1.5
log
@Stochastic Implosion
@
text
@d20 1
a20 1
#include <DetImpOP.h>
d51 1
a51 1
      myDetImpOP_    (NULL),
d75 1
a75 1
   if (myDetImpOP_ != NULL)
d77 1
a77 1
      delete myDetImpOP_;
d79 1
a79 1
      myDetImpOP_ = NULL;
d107 1
a107 1
   myDetImpOP ()->solve ();
d129 1
a129 1
      myDetImpOP ()->print ();
d136 1
a136 1
   myDetImpOP ()->calcInitSoln ();
d152 4
a155 4
   revValue  = myDetImpOP ()-> myRevObj ()->myValue ();
   invValue  = myDetImpOP ()-> myInvObj ()->myValue ();
   servValue = myDetImpOP ()->myServObj ()->myValue ();
   subValue  = myDetImpOP ()-> mySubObj ()->myValue ();
d162 1
a162 1
   return myDetImpOP ()->slbvVarsExist ();
d182 1
a182 1
   myExtOptMgr_ = new WitExtOptMgr (myDetImpOP ());
d273 1
a273 1
      myDetImpOP ()->writeSoln ("opSoln.out");
d336 1
a336 1
   if (myDetImpOP_ == NULL)
d344 1
a344 1
      myDetImpOP_ = new WitDetImpOP (myProblem ());
d346 1
a346 1
      myDetImpOP ()->generateFixed ();
d353 1
a353 1
   myDetImpOP ()->generateFlexible ();
d360 1
a360 1
   myDetImpOP ()->calcInitSoln ();
d372 1
a372 1
      myDetImpOP ()->writeSoln ("initSoln.out");
d383 1
a383 1
   objValueVal    = myDetImpOP ()->mainObj ()->myValue ();
d386 2
a387 2
      myDetImpOP ()->slbvVarsExist ()?
         myDetImpOP ()->myBoundsObj ()->myValue ():
d414 1
a414 1
   forEachEl (theOptVar, myDetImpOP ()->myOptVars ())
d427 1
a427 1
            theResCon = myDetImpOP ()->myResourceCon (thePart, thePer);
d493 1
a493 1
            myDetImpOP ()->myResourceCon (thePart, thePer)->dualValue ();
@


1.4
log
@Stochastic Implosion
@
text
@d126 1
a126 1
   setUpOptProb ();
d128 1
a128 1
   if (myOptComp ()->printOptProb ())
d254 1
a254 1
   setUpOptProb ();
d334 1
a334 1
void WitDetOptImpMgr::setUpOptProb ()
d349 1
a349 1
      myMsgFac () ("updateOptProbMsg");
@


1.3
log
@Stochastic Implosion
@
text
@d55 3
a57 4
      exportingSoln_ (false),
      exportTVec_    (),
      exportingObjs_ (false),
      criticalList_  (myProblem ()),
d233 1
a233 1
void WitDetOptImpMgr::exportObjs (double & objValueRef, double & boundsValueRef)
d235 1
a235 82
   stronglyAssert (exportingObjs_);

   objValueRef    = myDetImpOP ()->mainObj ()->myValue ();

   boundsValueRef = 
      myDetImpOP ()->slbvVarsExist ()?
         myDetImpOP ()->myBoundsObj ()->myValue ():
         0.0;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::exportSoln (
      WitGlobalComp *,
      WitPartPerStack & revCritListRef)
   {
   stronglyAssert (exportingSoln_);

   revCritListRef.revCopyFrom (criticalList_);
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::exportSoln (
      WitPart *       thePart,
      WitDblFlexVec & scrapVolRef,
      WitDblFlexVec & shadowPriceRef)
   {
   WitPeriod        thePer;
   WitResourceCon * theResCon;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->myScrapVar (thePart, thePer));

   scrapVolRef = exportTVec_;

   if (myOptComp ()->compPrices ())
      {
      forEachPeriod (thePer, myProblem ())
         {
         theResCon = myDetImpOP ()->myResourceCon (thePart, thePer);

         exportTVec_[thePer] =
            (theResCon != NULL)?
                theResCon->dualValue ():
                0.0;
         }

      shadowPriceRef = exportTVec_;
      }
   else
      shadowPriceRef = 0.0;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::exportSoln (
      WitMaterial *   theMat,
      WitDblFlexVec & stockVolRef)
   {
   WitPeriod thePer;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
          solnValue (myDetImpOP ()->myStockVar (theMat, thePer));

   stockVolRef = exportTVec_;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::exportSoln (
      WitDemand *      theDemand,
      WitDblFlexVec &     shipVolRef,
      WitDblFlexVec &  cumShipVolRef)
   {
   WitPeriod thePer;
a236 53
   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->myShipVar (theDemand, thePer));

   shipVolRef = exportTVec_;

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->myCumShipVar (theDemand, thePer));

   cumShipVolRef = exportTVec_;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::exportSoln (
      WitOperation *  theOpn,
      WitDblFlexVec & execVolRef)
   {
   WitPeriod thePer;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->myExecVar (theOpn, thePer));

   execVolRef = exportTVec_;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::exportSoln (
      WitSubEntry *   theSub,
      WitDblFlexVec & subVolRef)
   {
   WitPeriod thePer;

   stronglyAssert (exportingSoln_);

   forEachPeriod (thePer, myProblem ())
      exportTVec_[thePer] =
         solnValue (myDetImpOP ()->mySubVar (theSub, thePer));

   subVolRef = exportTVec_;
   }

//------------------------------------------------------------------------------

void WitDetOptImpMgr::startOptImp ()
   {
d259 7
d281 1
a281 3
   exportSoln ();

   criticalList_.clear ();
d379 2
d383 8
a390 1
   exportingObjs_ = true;
d392 2
a393 1
   myOptComp ()->importObjs ();
d395 1
a395 1
   exportingObjs_ = false;
d405 1
a405 1
void WitDetOptImpMgr::exportSoln ()
d407 4
a410 1
   WitComponent * theComp;
d412 1
a412 1
   exportTVec_.allocate (myProblem (), 0.0);
d414 8
a421 1
   exportingSoln_ = true;
d423 9
a431 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importOptSoln ();
d433 1
a433 1
   exportingSoln_ = false;
d435 1
a435 1
   exportTVec_.clear ();
d467 1
a467 1
   stronglyAssert (criticalList_.isEmpty ());
d498 1
a498 1
         criticalList_.push (thePart, thePer);
d502 1
a502 1
   criticalVec.resize (criticalList_.nElements ());
d506 1
a506 1
   while (criticalList_.pop (thePart, thePer))
d522 1
a522 1
      criticalList_.push (thePartPer->first, thePartPer->second);
d527 2
a528 3
   criticalVec  .clear   ();
   potential_   .clear   ();
   criticalList_.reverse ();
@


1.2
log
@Stochastic Implosion
@
text
@a145 7
void WitDetOptImpMgr::compObj1Values (double & primaryValue) const
   {
   primaryValue = myDetImpOP ()->myPrimaryObj ()->myValue ();
   }

//------------------------------------------------------------------------------

@


1.1
log
@Stochastic Implosion
@
text
@a118 29
void WitDetOptImpMgr::verifyNoIntCons ()
   {
   WitOperation * theOpn;
   WitSubEntry *  theSub;
   WitDemand *    theDemand;

   stronglyAssert (not myOptComp ()->mipMode ());

   forEachOperation (theOpn, myProblem ())
      if (theOpn->intExecVols ())
         myMsgFac () ("intExecVolsWoMipModeSmsg",
            theOpn->operationName ());

   forEachSubEntry (theSub, myProblem ())
      if (theSub->intSubVols ())
         myMsgFac () ("intSubVolsWoMipModeSmsg",
            theSub->myOperationName (),
            theSub->myBomEnt ()->localIndex (),
            theSub->             localIndex ());

   forEachDemand (theDemand, myProblem ())
      if (theDemand->intShipVols ())
         myMsgFac () ("intShipVolsWoMipModeSmsg",
            theDemand->demandedPartName (),
            theDemand->demandName ());
   }

//------------------------------------------------------------------------------

d389 1
a389 1
      verifyNoIntCons ();
@


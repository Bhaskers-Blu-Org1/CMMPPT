head	1.40;
access;
symbols
	sce_5_01_20080919:1.37
	latest_sce_4_20_20060523:1.26.0.2
	sce_4_20_20060523:1.26
	latest_sce4_20_OSL:1.25.0.2
	sce_4_20_OSL:1.25
	sce_410_withVa:1.24
	sce_4_05_20040511:1.24
	sce_4_00_20040201:1.17
	nextGenBranch:1.17.0.2
	nextGenRoot:1.17
	sce_3_30_20030627:1.17
	EndRw-branch:1.16.0.4
	Root-of-EndRw:1.16
	rwToStl:1.16.0.2
	latest_sce_3_10_20010924:1.7.0.6
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.7.0.4
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.7.0.2
	sce_2_31_20010308:1.7
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2011.09.28.23.49.21;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.09.24.00.27.40;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.08.30.20.17.29;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.14.17.18.54;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.08.18.26.08;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.24.18.52.21;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.22.20.44.25;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.14.19.05.39;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.14.16.18.38;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.28.20.04.55;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.27.19.59.30;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.10.00.08.13;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.08.22.47.34;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.08.00.14.25;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.02.17.33.58;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.24.22.21.29;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.23.19.14.23;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.22.16.37.18;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.05.22.19.58;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.03.22.13.05;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.03.19.07.27;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.02.22.18.26;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.06.18.53.37;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.04.23.07.20;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.03.22.35.17;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.03.16.01.48;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.29.21.35.45;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.29.14.32.39;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.08.19.21.49;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.07.20.14.56;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.03.23.16.37;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.04.22.07.36;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.22.23.11.40;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.20.12.31;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.18.00.15.59;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.25.19.17.44;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.47;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef FSSH
#define FSSH

//------------------------------------------------------------------------------
// Header file: "FSS.h"
//
// Contains the declaration of class FSS.
//------------------------------------------------------------------------------

#include <Assoc.h>
#include <Schedule.h>

//------------------------------------------------------------------------------
// class FSS.
//
// Responsible for computing the Focussed Shortage Schedule.
//------------------------------------------------------------------------------

class WitFSS: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitFSS (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitFSS ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool, computed)
      accessFunc (bool, uploadingSoln)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void compute ();
         //
         // Computes the Focussed Shortage Schedule for the current inputs.
         // It is an error to call this function when
         // myProblem ()->postprocessed () is false.

      void compFssShipVol (
            WitDemand *     theDemand,
            WitDblFlexVec & fssShipVolRef);
         //
         // Computes the fssShipVol of theDemand in useFocusHorizons mode and
         // sets fssShipVolRef to it.

      double mrpSupplyVol (WitPart * thePart, WitPeriod thePer) const;
         //
         // Returns the supplyVol for thePart in thePer for the MRP problem.
         // Valid only during MRP for FSS.

      double mrpDemandVol (WitPart * thePart, WitPeriod thePer) const;
         //
         // Returns the demandVol for thePart in thePer for the MRP problem.
         // Valid only during MRP for FSS.

      void uncompute ();
         //
         // Puts this FSS into an uncomputed state.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitFSS);

      void initSoln ();
         //
         // Initializes the FSS solution.

      void defineMrp ();
         //
         // Sets up the data for the MRP problem.

      void defineUnimplode ();
         //
         // Defines the unimplosion problem.

      double deltaFssShipVol (WitPart * thePart, WitPeriod thePer);
         //
         // Returns sum over all demands for thePart in thePer of:
         //    fssShipVol[thePer] - shipVol[thePer]

      void unimplode ();
         //
         // Finds a reduced execution sched for meeting the desired, achieved
         // shipment sched.

      void unimplode (
            WitOperation * uiOpn,
            WitBopEntry *  uiBopEnt,
            WitPart *      uiPart,
            WitPeriod      execPer,
            WitPeriod &    scrapPer);
         //
         // Reduces the execVol of uiOpn in period execPer as appropriate
         // for unimplosion.

      void rollOverScrap (
            WitMaterial * theMat,
            WitPeriod &   scrapPer,
            WitPeriod     prodPer);
         //
         // Rolls scrap from period scrapPer to prodPer as appropriate for
         // unimplosion. scrapPer is updated to prodPer.
         // No-op, if scrapPer >= prodPer.

      void unimplodeBom (
            WitOperation * uiOpn,
            WitPeriod      execPer,
            double         deltaExecVol);
         //
         // Reduces the BomEntries and Subs for uiOpn corresponding to
         // a reduction of deltaExecVol in the execVol in period execPer.

      void unimplodeSubs (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol);
         //
         // Reduces the subs for theBomEnt corresponding to a reduction of
         // deltaExecVol in the execVol of theBomEnt->myOperation () in
         // period execPer.

      void compMrpIncAvail ();
         //
         // Computes mrpIncAvail_.

      void doMrp ();
         //
         // Does MRP for FSS.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      bool computed_;
         //
         // true iff the Focussed Shortage Schedule has been computed and the
         // input data for FSS has not been updated since then.

      bool uploadingSoln_;
         //
         // True, iff the FSS subsystem is currently uploading the FSS solution.

      WitSchedule <WitPart, double> uiScrapVol_;
         //
         // Scrap sched for unimplode.

      WitSchedule <WitMaterial, double> uiStockVol_;
         //
         // Stock sched for unimplode.

      WitSchedule <WitPart, double> mrpIncAvail_;
         //
         // The incremental availability schedule for the MRP.
         //
         // If mrpIncAvail_ (thePart, thePer) == x > 0.0,
         //    then x additional units of thePart become available in thePer.
         //
         // If mrpIncAvail_ (thePart, thePer) == - x < 0.0,
         //    then x fewer units of thePart are available in thePer than in
         //    thePer - 1.

      //------------------------------------------------------------------------
      // FSS solution Schedules.
      //------------------------------------------------------------------------

      WitSchedule <WitOperation, double> fssExecVol_;
      WitSchedule <WitSubEntry,  double> fssSubVol_;
   };

#endif
@


1.39
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.38
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d29 2
a30 74
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitFSS (WitProblem * theProblem);
//
// ProbAssoc <<< theProblem.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitFSS ();

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (bool, computed)
accessFunc (bool, uploadingSoln)

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void compute ();
//
// Computes the Focussed Shortage Schedule for the current inputs.
// It is an error to call this function when
// myProblem ()->postprocessed () is false.

void compFssShipVol (
WitDemand *     theDemand,
WitDblFlexVec & fssShipVolRef);
//
// Computes the fssShipVol of theDemand in useFocusHorizons mode and
// sets fssShipVolRef to it.

double mrpSupplyVol (WitPart * thePart, WitPeriod thePer) const;
//
// Returns the supplyVol for thePart in thePer for the MRP problem.
// Valid only during MRP for FSS.

double mrpDemandVol (WitPart * thePart, WitPeriod thePer) const;
//
// Returns the demandVol for thePart in thePer for the MRP problem.
// Valid only during MRP for FSS.

void uncompute ();
//
// Puts this FSS into an uncomputed state.

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitFSS);

void initSoln ();
//
// Initializes the FSS solution.

void defineMrp ();
//
// Sets up the data for the MRP problem.

void defineUnimplode ();
//
// Defines the unimplosion problem.
d32 165
a196 93
double deltaFssShipVol (WitPart * thePart, WitPeriod thePer);
//
// Returns sum over all demands for thePart in thePer of:
//    fssShipVol[thePer] - shipVol[thePer]

void unimplode ();
//
// Finds a reduced execution sched for meeting the desired, achieved
// shipment sched.

void unimplode (
WitOperation * uiOpn,
WitBopEntry *  uiBopEnt,
WitPart *      uiPart,
WitPeriod      execPer,
WitPeriod &    scrapPer);
//
// Reduces the execVol of uiOpn in period execPer as appropriate
// for unimplosion.

void rollOverScrap (
WitMaterial * theMat,
WitPeriod &   scrapPer,
WitPeriod     prodPer);
//
// Rolls scrap from period scrapPer to prodPer as appropriate for
// unimplosion. scrapPer is updated to prodPer.
// No-op, if scrapPer >= prodPer.

void unimplodeBom (
WitOperation * uiOpn,
WitPeriod      execPer,
double         deltaExecVol);
//
// Reduces the BomEntries and Subs for uiOpn corresponding to
// a reduction of deltaExecVol in the execVol in period execPer.

void unimplodeSubs (
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol);
//
// Reduces the subs for theBomEnt corresponding to a reduction of
// deltaExecVol in the execVol of theBomEnt->myOperation () in
// period execPer.

void compMrpIncAvail ();
//
// Computes mrpIncAvail_.

void doMrp ();
//
// Does MRP for FSS.

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

bool computed_;
//
// true iff the Focussed Shortage Schedule has been computed and the
// input data for FSS has not been updated since then.

bool uploadingSoln_;
//
// True, iff the FSS subsystem is currently uploading the FSS solution.

WitSchedule <WitPart, double> uiScrapVol_;
//
// Scrap sched for unimplode.

WitSchedule <WitMaterial, double> uiStockVol_;
//
// Stock sched for unimplode.

WitSchedule <WitPart, double> mrpIncAvail_;
//
// The incremental availability schedule for the MRP.
//
// If mrpIncAvail_ (thePart, thePer) == x > 0.0,
//    then x additional units of thePart become available in thePer.
//
// If mrpIncAvail_ (thePart, thePer) == - x < 0.0,
//    then x fewer units of thePart are available in thePer than in
//    thePer - 1.

//------------------------------------------------------------------------
// FSS solution Schedules.
//------------------------------------------------------------------------

WitSchedule <WitOperation, double> fssExecVol_;
WitSchedule <WitSubEntry,  double> fssSubVol_;
};
@


1.37
log
@Stochastic Implosion
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d29 74
a102 2
   {
   public:
d104 93
a196 165
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitFSS (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitFSS ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool, computed)
      accessFunc (bool, uploadingSoln)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void compute ();
         //
         // Computes the Focussed Shortage Schedule for the current inputs.
         // It is an error to call this function when
         // myProblem ()->postprocessed () is false.

      void compFssShipVol (
            WitDemand *     theDemand,
            WitDblFlexVec & fssShipVolRef);
         //
         // Computes the fssShipVol of theDemand in useFocusHorizons mode and
         // sets fssShipVolRef to it.

      double mrpSupplyVol (WitPart * thePart, WitPeriod thePer) const;
         //
         // Returns the supplyVol for thePart in thePer for the MRP problem.
         // Valid only during MRP for FSS.

      double mrpDemandVol (WitPart * thePart, WitPeriod thePer) const;
         //
         // Returns the demandVol for thePart in thePer for the MRP problem.
         // Valid only during MRP for FSS.

      void uncompute ();
         //
         // Puts this FSS into an uncomputed state.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitFSS);

      void initSoln ();
         //
         // Initializes the FSS solution.

      void defineMrp ();
         //
         // Sets up the data for the MRP problem.

      void defineUnimplode ();
         //
         // Defines the unimplosion problem.

      double deltaFssShipVol (WitPart * thePart, WitPeriod thePer);
         //
         // Returns sum over all demands for thePart in thePer of:
         //    fssShipVol[thePer] - shipVol[thePer]

      void unimplode ();
         //
         // Finds a reduced execution sched for meeting the desired, achieved
         // shipment sched.

      void unimplode (
            WitOperation * uiOpn,
            WitBopEntry *  uiBopEnt,
            WitPart *      uiPart,
            WitPeriod      execPer,
            WitPeriod &    scrapPer);
         //
         // Reduces the execVol of uiOpn in period execPer as appropriate
         // for unimplosion.

      void rollOverScrap (
            WitMaterial * theMat,
            WitPeriod &   scrapPer,
            WitPeriod     prodPer);
         //
         // Rolls scrap from period scrapPer to prodPer as appropriate for
         // unimplosion. scrapPer is updated to prodPer.
         // No-op, if scrapPer >= prodPer.

      void unimplodeBom (
            WitOperation * uiOpn,
            WitPeriod      execPer,
            double         deltaExecVol);
         //
         // Reduces the BomEntries and Subs for uiOpn corresponding to
         // a reduction of deltaExecVol in the execVol in period execPer.

      void unimplodeSubs (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol);
         //
         // Reduces the subs for theBomEnt corresponding to a reduction of
         // deltaExecVol in the execVol of theBomEnt->myOperation () in
         // period execPer.

      void compMrpIncAvail ();
         //
         // Computes mrpIncAvail_.

      void doMrp ();
         //
         // Does MRP for FSS.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      bool computed_;
         //
         // true iff the Focussed Shortage Schedule has been computed and the
         // input data for FSS has not been updated since then.

      bool uploadingSoln_;
         //
         // True, iff the FSS subsystem is currently uploading the FSS solution.

      WitSchedule <WitPart, double> uiScrapVol_;
         //
         // Scrap sched for unimplode.

      WitSchedule <WitMaterial, double> uiStockVol_;
         //
         // Stock sched for unimplode.

      WitSchedule <WitPart, double> mrpIncAvail_;
         //
         // The incremental availability schedule for the MRP.
         //
         // If mrpIncAvail_ (thePart, thePer) == x > 0.0,
         //    then x additional units of thePart become available in thePer.
         //
         // If mrpIncAvail_ (thePart, thePer) == - x < 0.0,
         //    then x fewer units of thePart are available in thePer than in
         //    thePer - 1.

      //------------------------------------------------------------------------
      // FSS solution Schedules.
      //------------------------------------------------------------------------

      WitSchedule <WitOperation, double> fssExecVol_;
      WitSchedule <WitSubEntry,  double> fssSubVol_;
   };
@


1.36
log
@Stochastic Implosion
@
text
@d19 1
a19 4
#include <Part.h>
#include <Demand.h>
#include <Opn.h>
#include <SubEntry.h>
a20 1
#include <RefMap.h>
d51 1
a51 11

      //------------------------------------------------------------------------
      // Reference receiving functions.
      // Each of these functions stores its arguments on the assumption that
      // they are references to the similarly named data members of the
      // Component for which passFssRefs () is currently being called.
      //------------------------------------------------------------------------

      void receivePartRefs      (WitDblFlexVec & focShortageVolRef);
      void receiveOperationRefs (WitDblFlexVec &     fssExecVolRef);
      void receiveSubEntryRefs  (WitDblFlexVec &      fssSubVolRef);
a157 2
      accessNonNull (WitComponent *, passRefsComp)

d167 4
a189 5
      WitComponent * passRefsComp_;
         //
         // The Component for which passFssRefs is currently being called, if
         // any; otherwise NULL.

d191 1
a191 1
      // References to Component data.
d194 2
a195 3
      WitRefMap <WitPart,      WitDblFlexVec> focShortageVol_;
      WitRefMap <WitOperation, WitDblFlexVec> fssExecVol_;
      WitRefMap <WitSubEntry,  WitDblFlexVec> fssSubVol_;
@


1.35
log
@Stochastic Implosion
@
text
@d63 3
a65 3
      void receivePartRefs      (WitDblFlexVec & focShortageVolArg);
      void receiveOperationRefs (WitDblFlexVec &     fssExecVolArg);
      void receiveSubEntryRefs  (WitDblFlexVec &      fssSubVolArg);
d79 1
a79 1
            WitDblFlexVec & fssShipVolArg);
d82 1
a82 1
         // sets fssShipVolArg to it.
@


1.34
log
@Stochastic Implosion
@
text
@d57 4
a60 4
      // Data receiving functions.
      // Each of these functions stores its reference arguments on the
      // assumption that they are references to the similarly named data members
      // of passDataComp_;
d63 3
a65 3
      void receivePartData      (WitDblFlexVec & focShortageVolArg);
      void receiveOperationData (WitDblFlexVec & fssExecVolArg);
      void receiveSubEntryData  (WitDblFlexVec & fssSubVolArg);
d172 1
a172 1
      accessNonNull (WitComponent *, passDataComp)
d202 1
a202 1
      WitComponent * passDataComp_;
d204 1
a204 1
         // The Component for which passFssData is currently being called, if
@


1.33
log
@Stochastic Implosion
@
text
@d60 1
a60 1
      // of the Component argument.
d63 3
a65 11
      void receiveData (
            WitPart *       thePart,
            WitDblFlexVec & focShortageVolArg);

      void receiveData (
            WitOperation *  theOpn,
            WitDblFlexVec & fssExecVolArg);

      void receiveData (
            WitSubEntry *   theSub,
            WitDblFlexVec & fssSubVolArg);
d172 2
d202 5
@


1.32
log
@Stochastic Implosion
@
text
@d57 19
a91 12
      void receiveData (WitPart * thePart, WitDblFlexVec & focShortageVolArg);
         //
         // Stores focShortageVolArg as thePart->focShortageVol_.

      void receiveData (WitOperation * theOpn, WitDblFlexVec & fssExecVolArg);
         //
         // Stores fssExecVolArg as theOpn->fssExecVol_.

      void receiveData (WitSubEntry * theSub, WitDblFlexVec & fssSubVolArg);
         //
         // Stores fssSubVolArg as theSub->fssSubVol_.

@


1.31
log
@[disallowed backlog]
@
text
@d24 1
d66 19
a106 4
      void compFssShipVols ();
         //
         // For each Demand, computes fssShipVol from focusHorizon.

d200 8
@


1.30
log
@Rescinded all changed made since 1/31/07.
@
text
@a78 11
      //------------------------------------------------------------------------
      // Functions for receiving data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      //------------------------------------------------------------------------

      static void receiveDMPs (WitDblFlexVec      WitPart::* focShortageVolArg);
      static void receiveDMPs (WitDblFlexVec    WitDemand::* fssShipVolArg);
      static void receiveDMPs (WitDblFlexVec WitOperation::* fssExecVolArg);
      static void receiveDMPs (WitDblFlexVec  WitSubEntry::* fssSubVolArg);

a160 15
      //------------------------------------------------------------------------
      // Data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      // E.g., theOpn->*fssExecVol_ == theOpn->fssExecVol_.
      //------------------------------------------------------------------------

      static WitDblFlexVec    WitDemand::* fssShipVol_;
      static WitDblFlexVec WitOperation::* fssExecVol_;
      static WitDblFlexVec  WitSubEntry::* fssSubVol_;

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

@


1.29
log
@[disallowed backlog]
@
text
@a58 8
      void compDefFssShipVols ();
         //
         // Sets fssShipVols to its default value for all Demands.

      void setFssShipVol (WitDemand * theDemand, const WitIVRealArg &);
         //
         // Sets theDemand->fssShipVol_.

d79 11
d179 3
a181 1
      static WitDblFlexVec WitSubEntry::* fssSubVol_;
@


1.28
log
@[disallowed backlog]
@
text
@a86 8
      //------------------------------------------------------------------------
      // Functions for receiving data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      //------------------------------------------------------------------------

      static void receiveDMPs (WitDblFlexVec  WitSubEntry::* fssSubVolArg);

@


1.27
log
@[disallowed backlog]
@
text
@d59 8
a92 2
      static void receiveDMPs (WitDblFlexVec    WitDemand::* fssShipVolArg);
      static void receiveDMPs (WitDblFlexVec WitOperation::* fssExecVolArg);
d184 1
a184 3
      static WitDblFlexVec    WitDemand::* fssShipVol_;
      static WitDblFlexVec WitOperation::* fssExecVol_;
      static WitDblFlexVec  WitSubEntry::* fssSubVol_;
@


1.26
log
@Updated the copyright date on all source files.
@
text
@a84 1
      static void receiveDMPs (WitDblFlexVec      WitPart::* focShortageVolArg);
@


1.25
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.24
log
@Double Precision.
@
text
@a23 1
#include <RefMap.h>
d80 3
a82 1
      // Data loading functions.
d85 4
a88 15
      void loadDataFrom (
            WitPart *       thePart,
            WitDblFlexVec & focShortageVolArg);

      void loadDataFrom (
            WitDemand *     theDemand,
            WitDblFlexVec & fssShipVolArg);

      void loadDataFrom (
            WitOperation *  theOpn, 
            WitDblFlexVec & fssExecVolArg);

      void loadDataFrom (
            WitSubEntry *   theSub, 
            WitDblFlexVec & fssSubVolArg);
a97 8
      void loadData ();
         //
         // Loads the data to be loaded from the components.

      void clearLoadedData ();
         //
         // Clears the data that was loaded from the components.

d173 4
a176 1
      // Mappings to data loaded in from Components.
d179 3
a181 4
      WitRefMap <WitPart,      WitDblFlexVec> focShortageVol_;
      WitRefMap <WitDemand,    WitDblFlexVec> fssShipVol_;
      WitRefMap <WitOperation, WitDblFlexVec> fssExecVol_;
      WitRefMap <WitSubEntry,  WitDblFlexVec> fssSubVol_;
@


1.23
log
@Double Precision.
@
text
@d85 2
a86 2
            WitPart *             thePart,
            WitFlexVec <double> & focShortageVolArg);
d89 2
a90 2
            WitDemand *           theDemand,
            WitFlexVec <double> & fssShipVolArg);
d93 2
a94 2
            WitOperation *        theOpn, 
            WitFlexVec <double> & fssExecVolArg);
d97 2
a98 2
            WitSubEntry *         theSub, 
            WitFlexVec <double> & fssSubVolArg);
d194 4
a197 4
      WitRefMap <WitPart,      WitFlexVec <double> > focShortageVol_;
      WitRefMap <WitDemand,    WitFlexVec <double> > fssShipVol_;
      WitRefMap <WitOperation, WitFlexVec <double> > fssExecVol_;
      WitRefMap <WitSubEntry,  WitFlexVec <double> > fssSubVol_;
@


1.22
log
@Double Precision.
@
text
@d85 2
a86 2
            WitPart *      thePart,
            WitRealVec &   focShortageVolArg);
d89 2
a90 2
            WitDemand *    theDemand,
            WitRealVec &   fssShipVolArg);
d93 2
a94 2
            WitOperation * theOpn, 
            WitRealVec &   fssExecVolArg);
d97 2
a98 2
            WitSubEntry *  theSub, 
            WitRealVec &   fssSubVolArg);
d194 4
a197 4
      WitRefMap <WitPart,      WitRealVec> focShortageVol_;
      WitRefMap <WitDemand,    WitRealVec> fssShipVol_;
      WitRefMap <WitOperation, WitRealVec> fssExecVol_;
      WitRefMap <WitSubEntry,  WitRealVec> fssSubVol_;
@


1.21
log
@Double Precision.
@
text
@d90 1
a90 1
            WitRealTVc &   fssShipVolArg);
d195 1
a195 1
      WitRefMap <WitDemand,    WitRealTVc> fssShipVol_;
@


1.20
log
@Double Precision.
@
text
@d90 1
a90 1
            WitRealVec &   fssShipVolArg);
d195 1
a195 1
      WitRefMap <WitDemand,    WitRealVec> fssShipVol_;
@


1.19
log
@Double Precision.
@
text
@d85 2
a86 2
            WitPart *            thePart,
            WitRealVec &         focShortageVolArg);
d89 2
a90 2
            WitDemand *          theDemand,
            WitRealVec &         fssShipVolArg);
d93 2
a94 2
            WitOperation *       theOpn, 
            WitFlexVec <float> & fssExecVolArg);
d97 2
a98 2
            WitSubEntry *        theSub, 
            WitFlexVec <float> & fssSubVolArg);
d194 4
a197 4
      WitRefMap <WitPart,      WitRealVec>          focShortageVol_;
      WitRefMap <WitDemand,    WitRealVec>          fssShipVol_;
      WitRefMap <WitOperation, WitFlexVec <float> > fssExecVol_;
      WitRefMap <WitSubEntry,  WitFlexVec <float> > fssSubVol_;
@


1.18
log
@Double Precision.
@
text
@d90 1
a90 1
            WitTVec <float> &    fssShipVolArg);
d195 1
a195 1
      WitRefMap <WitDemand,    WitTVec    <float> > fssShipVol_;
@


1.17
log
@Internal changes.
@
text
@d86 1
a86 1
            WitFlexVec <float> & focShortageVolArg);
d194 1
a194 1
      WitRefMap <WitPart,      WitFlexVec <float> > focShortageVol_;
@


1.16
log
@Continued implementation of Single-Source.
@
text
@d54 1
a54 1
      accessFunc (WitBoolean, computed)
d64 1
a64 1
         // myProblem ()->postprocessed () is FALSE.
d203 1
a203 1
      WitBoolean computed_;
d205 1
a205 1
         // TRUE iff the Focussed Shortage Schedule has been computed and the
@


1.15
log
@Continued implementation of single-source.
@
text
@d23 1
d208 1
a208 1
      WitSchedule <WitPart, double> & uiScrapVol_;
d212 1
a212 1
      WitSchedule <WitMaterial, double> & uiStockVol_;
d216 1
a216 1
      WitSchedule <WitPart, double> & mrpIncAvail_;
@


1.14
log
@Continued implementation of single-source.
@
text
@d23 1
d193 4
a196 4
      WitRefMap <WitPart,      WitFlexVec <float> > & focShortageVol_;
      WitRefMap <WitDemand,    WitTVec    <float> > & fssShipVol_;
      WitRefMap <WitOperation, WitFlexVec <float> > & fssExecVol_;
      WitRefMap <WitSubEntry,  WitFlexVec <float> > & fssSubVol_;
@


1.13
log
@Continued implementation of single-source.
@
text
@a22 1
#include <AccFlag.h>
d52 1
a52 2
      accessFunc (const WitAccFlag *, myAccFlag)
      accessFunc (WitBoolean,         computed)
a77 2
   private:

d79 1
a79 1
      // Private member functions.
d82 15
a96 3
      //------------------------------------------------------------------------
      // Component data access functions.
      //------------------------------------------------------------------------
d98 1
a98 4
      refAccess (WitPart,      WitFlexVec <float>, focShortageVol)
      refAccess (WitDemand,    WitTVec <float>,    fssShipVol)
      refAccess (WitOperation, WitFlexVec <float>, fssExecVol)
      refAccess (WitSubEntry,  WitFlexVec <float>, fssSubVol)
d101 1
a101 1
      // Other private member functions.
d106 8
d188 13
a204 4

      WitAccFlag * const myAccFlag_;
         //
         // the AccFlag for this FSS.
@


1.12
log
@Continued implementation of single-source.
@
text
@d23 1
a23 1
#include <Schedule.h>
d53 2
a54 10
      accessFunc (WitBoolean, computed)

      //------------------------------------------------------------------------
      // Result export functions.
      //------------------------------------------------------------------------

      accessMap (const WitTVec <float> &, fssExecVol, WitOperation)
      accessMap (const WitTVec <float> &, fssSubVol,  WitSubEntry)

      const WitTVec <double> & focShortageVol (WitPart *);
d87 9
d101 4
d167 4
a174 11
      //------------------------------------------------------------------------
      // Result data.
      //------------------------------------------------------------------------

      WitSchedule <WitOperation, float> fssExecVol_;
      WitSchedule <WitSubEntry,  float> fssSubVol_;

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

d180 1
a180 1
      WitFssMrpExp * myFssMrpExp_;
d182 1
a182 1
         // The FssMrpExp owned by this FSS.
d184 1
a184 1
      WitSchedule <WitPart, double> uiScrapVol_;
d192 1
a192 1
      WitSchedule <WitPart, double> mrpIncAvail_;
@


1.11
log
@Continued implementation of single-source.
@
text
@d56 1
a56 1
      // Result exporting functions.
@


1.10
log
@Preliminary work on single source.
@
text
@d23 1
a23 1
#include <AccFlag.h>
d53 10
a62 2
      accessFunc (const WitAccFlag *, myAccFlag)
      accessFunc (WitBoolean,         computed)
a94 9
      // Component data access functions.
      //------------------------------------------------------------------------

      refAccess (WitPart,      WitFlexVec <float>, focShortageVol)
      refAccess (WitDemand,    WitTVec <float>,    fssShipVol)
      refAccess (WitOperation, WitFlexVec <float>, fssExecVol)
      refAccess (WitSubEntry,  WitFlexVec <float>, fssSubVol)

      //------------------------------------------------------------------------
a99 4
      void compFssShipVols ();
         //
         // For each Demand, computes fssShipVol from focusHorizon.

d162 10
a171 3
      void doMrp ();
         //
         // Does MRP for FSS.
d174 1
a174 1
      // Private member data.
d182 1
a182 1
      WitAccFlag * const myAccFlag_;
d184 1
a184 1
         // the AccFlag for this FSS.
d186 1
a186 1
      WitSchedule <WitPart, double> & uiScrapVol_;
d194 1
a194 1
      WitSchedule <WitPart, double> & mrpIncAvail_;
@


1.9
log
@Continued preliminary work on single source.
@
text
@d90 1
a90 1
      refAccess (WitPart,      WitFlexVec (float), focShortageVol)
d92 2
a93 2
      refAccess (WitOperation, WitFlexVec (float), fssExecVol)
      refAccess (WitSubEntry,  WitFlexVec (float), fssSubVol)
@


1.8
log
@Continued preliminary work on single source.
@
text
@d19 4
a22 1
#include <Schedule.h>
d184 1
a184 1
      WitSchedule (WitPart, double) uiScrapVol_;
d188 1
a188 1
      WitSchedule (WitMaterial, double) uiStockVol_;
d192 1
a192 1
      WitSchedule (WitPart, double) mrpIncAvail_;
@


1.7
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d88 1
a88 1
      refAccess (WitDemand,    WitTVec (float),    fssShipVol)
@


1.6
log
@Refactoring for selection splitting.
@
text
@d66 1
a66 1
         // Only valid during MRP for FSS.
d71 1
a71 1
         // Only valid during MRP for FSS.
@


1.5
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d96 1
a96 3
      copyCtorAndAssignment (WitFSS);
         //
         // Prevents unintentional copying and assignment.
@


1.4
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d127 1
a127 1
            WitOperation * uiOperation,
d133 1
a133 1
         // Reduces the execVol of uiOperation in period execPer as appropriate
d146 1
a146 1
            WitOperation * uiOperation,
d150 1
a150 1
         // Reduces the BomEntries and Subs for uiOperation corresponding to
@


1.3
log
@Changed some more of the FSS and MRP stuff from float to double to fix a
   numerical problem.
@
text
@a200 4

      WitDenseList (WitSubEntry) theSubEntries_;
         //
         // DenseList of theBomEnt->mySubEntries (), for some BomEntry.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d63 1
a63 1
      float mrpSupplyVol (WitPart * thePart, WitPeriod thePer) const;
d68 1
a68 1
      float mrpDemandVol (WitPart * thePart, WitPeriod thePer) const;
d191 1
a191 1
      WitSchedule (WitPart, float) mrpIncAvail_;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

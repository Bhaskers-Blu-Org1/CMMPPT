head	1.238;
access;
symbols
	sce_5_01_20080919:1.189
	latest_sce_4_20_20060523:1.151.0.2
	sce_4_20_20060523:1.151
	latest_sce4_20_OSL:1.143.0.2
	sce_4_20_OSL:1.143
	sce_410_withVa:1.128
	sce_4_05_20040511:1.107
	sce_4_00_20040201:1.97
	nextGenBranch:1.83.0.2
	nextGenRoot:1.83
	sce_3_30_20030627:1.78
	EndRw-branch:1.65.0.2
	Root-of-EndRw:1.65
	rwToStl:1.64.0.2
	latest_sce_3_10_20010924:1.33.0.2
	sce_3_10_20010924:1.33
	latest_sce_3_00_20010601:1.27.0.2
	sce_3_00_20010601:1.27
	latest_sce_2_31_20010308:1.15.0.2
	sce_2_31_20010308:1.15
	latest_sce_2_31_20001003:1.9.0.2
	sce_2_31_20001003:1.9
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.238
date	2011.09.28.23.49.49;	author rjw;	state Exp;
branches;
next	1.237;

1.237
date	2011.09.24.00.28.10;	author rjw;	state Exp;
branches;
next	1.236;

1.236
date	2011.08.30.20.17.51;	author rjw;	state Exp;
branches;
next	1.235;

1.235
date	2011.08.25.23.27.04;	author rjw;	state Exp;
branches;
next	1.234;

1.234
date	2011.01.25.00.23.00;	author rjw;	state Exp;
branches;
next	1.233;

1.233
date	2011.01.24.23.57.08;	author rjw;	state Exp;
branches;
next	1.232;

1.232
date	2011.01.12.23.09.30;	author rjw;	state Exp;
branches;
next	1.231;

1.231
date	2011.01.06.23.31.28;	author rjw;	state Exp;
branches;
next	1.230;

1.230
date	2010.12.14.00.22.49;	author rjw;	state Exp;
branches;
next	1.229;

1.229
date	2010.12.04.00.29.44;	author rjw;	state Exp;
branches;
next	1.228;

1.228
date	2010.12.03.17.19.04;	author rjw;	state Exp;
branches;
next	1.227;

1.227
date	2010.11.17.20.20.53;	author rjw;	state Exp;
branches;
next	1.226;

1.226
date	2010.10.19.20.13.46;	author rjw;	state Exp;
branches;
next	1.225;

1.225
date	2010.10.12.22.02.21;	author rjw;	state Exp;
branches;
next	1.224;

1.224
date	2010.10.12.19.48.28;	author rjw;	state Exp;
branches;
next	1.223;

1.223
date	2010.10.07.15.41.00;	author rjw;	state Exp;
branches;
next	1.222;

1.222
date	2010.09.01.16.28.24;	author rjw;	state Exp;
branches;
next	1.221;

1.221
date	2010.08.31.23.12.52;	author rjw;	state Exp;
branches;
next	1.220;

1.220
date	2010.08.24.16.30.30;	author rjw;	state Exp;
branches;
next	1.219;

1.219
date	2010.08.19.18.00.14;	author rjw;	state Exp;
branches;
next	1.218;

1.218
date	2010.08.03.23.50.02;	author rjw;	state Exp;
branches;
next	1.217;

1.217
date	2010.07.01.22.41.21;	author rjw;	state Exp;
branches;
next	1.216;

1.216
date	2010.06.28.18.37.15;	author rjw;	state Exp;
branches;
next	1.215;

1.215
date	2010.06.28.18.10.52;	author rjw;	state Exp;
branches;
next	1.214;

1.214
date	2010.06.28.17.53.39;	author rjw;	state Exp;
branches;
next	1.213;

1.213
date	2010.06.24.23.37.33;	author rjw;	state Exp;
branches;
next	1.212;

1.212
date	2010.06.22.20.26.09;	author rjw;	state Exp;
branches;
next	1.211;

1.211
date	2010.06.22.19.55.35;	author rjw;	state Exp;
branches;
next	1.210;

1.210
date	2010.06.17.16.29.47;	author rjw;	state Exp;
branches;
next	1.209;

1.209
date	2010.06.16.15.38.42;	author rjw;	state Exp;
branches;
next	1.208;

1.208
date	2010.06.10.23.26.09;	author rjw;	state Exp;
branches;
next	1.207;

1.207
date	2010.06.10.21.19.01;	author rjw;	state Exp;
branches;
next	1.206;

1.206
date	2010.05.28.14.40.36;	author rjw;	state Exp;
branches;
next	1.205;

1.205
date	2010.05.20.23.18.43;	author rjw;	state Exp;
branches;
next	1.204;

1.204
date	2010.05.19.20.34.10;	author rjw;	state Exp;
branches;
next	1.203;

1.203
date	2010.05.14.21.20.56;	author rjw;	state Exp;
branches;
next	1.202;

1.202
date	2010.05.12.18.38.07;	author rjw;	state Exp;
branches;
next	1.201;

1.201
date	2010.05.11.22.26.27;	author rjw;	state Exp;
branches;
next	1.200;

1.200
date	2010.03.26.22.22.53;	author rjw;	state Exp;
branches;
next	1.199;

1.199
date	2010.03.16.22.42.27;	author rjw;	state Exp;
branches;
next	1.198;

1.198
date	2010.03.09.20.12.24;	author rjw;	state Exp;
branches;
next	1.197;

1.197
date	2010.03.05.00.10.15;	author rjw;	state Exp;
branches;
next	1.196;

1.196
date	2010.03.04.23.44.30;	author rjw;	state Exp;
branches;
next	1.195;

1.195
date	2010.03.04.22.18.36;	author rjw;	state Exp;
branches;
next	1.194;

1.194
date	2010.03.03.20.10.29;	author rjw;	state Exp;
branches;
next	1.193;

1.193
date	2010.02.01.22.10.14;	author rjw;	state Exp;
branches;
next	1.192;

1.192
date	2009.11.12.17.36.36;	author rjw;	state Exp;
branches;
next	1.191;

1.191
date	2009.10.06.21.06.12;	author rjw;	state Exp;
branches;
next	1.190;

1.190
date	2008.11.12.19.52.25;	author rjw;	state Exp;
branches;
next	1.189;

1.189
date	2008.03.01.00.01.03;	author rjw;	state Exp;
branches;
next	1.188;

1.188
date	2008.02.27.23.19.11;	author rjw;	state Exp;
branches;
next	1.187;

1.187
date	2008.01.08.17.20.39;	author rjw;	state Exp;
branches;
next	1.186;

1.186
date	2007.10.02.22.23.05;	author rjw;	state Exp;
branches;
next	1.185;

1.185
date	2007.08.17.21.47.43;	author rjw;	state Exp;
branches;
next	1.184;

1.184
date	2007.07.17.22.10.26;	author rjw;	state Exp;
branches;
next	1.183;

1.183
date	2007.07.13.23.05.32;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2007.07.05.18.37.55;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2007.06.29.15.25.49;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2007.05.25.20.55.51;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2007.05.14.20.25.16;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2007.05.14.19.48.41;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2007.05.09.22.44.27;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2007.05.08.23.21.20;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2007.05.04.18.43.46;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2007.04.30.21.52.09;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2007.04.20.19.44.49;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2007.03.28.22.14.32;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2007.03.09.20.13.06;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2007.03.08.22.47.18;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2007.03.02.22.22.36;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2007.02.28.23.09.07;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2007.01.29.21.52.03;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2006.10.05.20.54.53;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2006.09.29.22.56.40;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2006.09.29.18.40.59;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2006.09.21.17.16.36;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2006.09.08.20.00.59;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2006.09.07.20.49.24;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2006.08.30.16.37.35;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2006.08.18.22.29.01;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2006.08.18.18.43.39;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2006.08.17.21.21.32;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2006.08.16.15.49.18;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2006.08.03.18.59.32;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2006.08.02.15.57.06;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2006.07.27.23.02.47;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2006.06.09.15.23.21;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2006.05.22.16.02.41;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2006.05.10.14.45.13;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2006.05.09.14.58.30;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2006.05.08.19.51.24;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2006.05.02.17.34.06;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2006.04.21.20.06.32;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2006.04.18.14.31.03;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2006.04.17.20.21.30;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2006.03.21.20.47.35;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2006.03.20.23.47.33;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2006.03.20.21.54.31;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2006.03.17.23.16.39;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.10.23.23.30;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2006.03.08.23.57.11;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.06.23.10.15;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2006.01.04.23.07.39;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2005.11.10.20.33.08;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2005.10.18.20.56.22;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2005.09.14.22.44.10;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2005.09.14.21.54.45;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2005.09.13.19.31.57;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2005.09.08.21.16.36;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2005.09.08.19.29.44;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2005.09.07.19.29.52;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2005.09.06.21.30.28;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2005.09.06.20.43.26;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2005.09.01.21.45.03;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2005.06.16.19.19.12;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2005.06.14.20.35.13;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2005.05.17.17.30.44;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2005.03.16.17.00.31;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2005.03.02.22.34.36;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2005.02.10.18.38.30;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2005.02.03.23.35.58;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2005.01.31.23.59.30;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2005.01.17.23.43.10;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2005.01.10.21.35.23;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2004.12.22.22.27.10;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2004.12.02.21.25.41;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2004.11.09.23.08.00;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2004.11.06.00.30.34;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2004.11.04.20.42.27;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2004.10.12.21.29.50;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2004.05.17.22.15.18;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2004.05.05.15.26.31;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2004.02.27.21.00.29;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2004.02.26.20.40.26;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2004.02.17.20.23.47;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.14.00.45.35;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.11.21.54.02;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.11.21.30.55;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2004.01.30.20.09.48;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.05.23.37.33;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2003.12.29.20.59.23;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2003.12.23.16.18.47;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2003.12.15.23.22.32;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2003.12.04.22.44.56;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2003.12.04.16.20.41;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2003.10.31.15.37.54;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2003.10.09.21.31.51;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2003.09.22.20.27.02;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2003.09.04.19.32.47;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2003.09.03.18.09.57;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2003.08.01.23.05.39;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2003.08.01.21.01.38;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2003.07.29.21.07.35;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2003.07.28.23.37.47;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2003.07.28.20.34.13;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2003.07.18.21.13.38;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2003.07.09.20.56.44;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2003.07.08.20.59.29;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2003.07.08.19.24.11;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.20.19.03.28;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2003.05.30.18.19.14;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2003.05.28.22.19.32;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2003.05.13.22.00.04;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2003.05.06.21.04.50;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2003.04.11.19.35.38;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2003.01.27.21.17.19;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2003.01.02.23.40.46;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2003.01.02.22.18.41;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2002.12.20.22.48.00;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2002.12.19.17.15.22;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2002.12.17.17.01.43;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.21.22.53.58;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2002.10.18.22.23.56;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2002.10.16.22.30.20;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2002.10.09.18.42.12;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2002.09.30.21.36.38;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2002.09.11.19.53.56;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2002.09.09.16.04.38;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2002.08.29.17.57.51;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2002.08.26.22.49.06;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2002.08.23.21.00.39;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2002.08.23.18.09.14;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.22.14.01.48;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.19.23.25.07;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.15.20.03.47;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2002.08.14.16.09.49;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2002.08.08.17.33.34;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.25.17.43.53;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.17.21.45.03;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2002.05.13.21.31.41;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.08.21.58.56;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.01.14.25.59;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.24.20.05.30;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.04.22.14.32.11;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.04.18.14.02.39;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2002.04.15.22.02.51;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.29.23.47.10;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.27.23.15.40;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.20.18.50.06;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.19.16.17.11;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.12.17.19.22.51;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.09.21.42.27;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.28.21.42.40;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.21.22.36.30;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.29.17.12.03;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.28.00.48.35;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.25.16.08.17;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.17.20.49.19;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.02.02.11.28;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.29.22.11.27;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.17.20.02.20;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.17.15.11.16;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.15.15.30.27;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.07.15.58.57;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.03.22.55.46;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.03.20.47.26;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.03.18.50.36;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.24.17.48.33;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.10.21.59.34;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.06.19.22.10;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.08.16.37.07;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.26.21.46.02;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.20.00.44.20;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.04.22.07.38;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.21.20.03.26;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.13.21.03.55;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.06.18.45.08;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.18.00.16.00;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.08.21.56.13;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.02.20.43.14;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.24.19.55.25;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.01.00.35.43;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.30.16.33.08;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.07.16.56.37;	author fasano;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.29.22.58.06;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.28;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.28;	author wit;	state Exp;
branches;
next	;


desc
@@


1.238
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "ParamMgr.C"
//
// Contains the implementation of class ParamMgr.
//------------------------------------------------------------------------------

#include <ParamMgr.h>
#include <Param.h>
#include <SaeMgr.h>
#include <WitRun.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <OptStarter.h>
#include <StochImpMgr.h>
#include <CompMgr.h>
#include <MsgFac.h>

#include <stdlib.h>

//------------------------------------------------------------------------------
// Macro useDosFileNames.
//
// true, iff DOS file names are to be used.
//------------------------------------------------------------------------------

#ifdef DOS_FILE_NAMES

#define useDosFileNames true

#else

#define useDosFileNames false

#endif

//------------------------------------------------------------------------------
// Implementation of class ParamMgr.
//------------------------------------------------------------------------------

inline WitGlobalComp * WitParamMgr::myGlobalComp ()
   {
   return myProblem ()->myCompMgr ()->myGlobalComp ();
   }

//------------------------------------------------------------------------------

inline WitOptComp * WitParamMgr::myOptComp ()
   {
   return myProblem ()->myCompMgr ()->myOptComp ();
   }

//------------------------------------------------------------------------------

inline WitProblem * WitParamMgr::myProblem ()
   {
   return myWitRun_->mySession()->myProblem ();
   }

//------------------------------------------------------------------------------

WitParamMgr::WitParamMgr (WitRun * theWitRun, int argc, char * argv[]):

      myWitRun_         (theWitRun),
      myMsgFac_         (theWitRun->myMsgFac ()),

      fileName_         (compParamIFName (argc, argv)),

             allParams_ (),
       allNonDevParams_ (),
          allDevParams_ (),
       allStringParams_ (),
          allIntParams_ (),
       allDoubleParams_ (),
       allChoiceParams_ (),
      allBoolParams_    (),

      pCurrentParams_   (NULL)
   {
   }

//------------------------------------------------------------------------------

WitParamMgr::~WitParamMgr ()
   {
   while (not allParams_.isEmpty ())
      delete allParams_.get ();
   }

//------------------------------------------------------------------------------

void WitParamMgr::procParams ()
   {
   buildNonDevParams ();
   buildDevParams    ();

   readParams ();

   applyNonDevParams ();
   applyDevParams    ();

   printParams ();
   }

//------------------------------------------------------------------------------

void WitParamMgr::store (WitParam * theParam)
   {
   if (DEBUG_MODE)
      {
      WitParam * dupParam;

      dupParam = 
         allParams_.find (
            & WitParam::itsName,
              theParam->myName ().myCstring ());

      witAssert (dupParam == NULL);
      }
      //
      // Verify that the name is not duplicated.

   allParams_      .append (theParam);
   pCurrentParams_->append (theParam);
   }

//------------------------------------------------------------------------------

const WitString & WitParamMgr::stringParamVal (const char * paramName)
   {
   WitStringParam * theStringParam;

   theStringParam =
      allStringParams_.find (& WitStringParam::itsName, paramName);

   witAssert (theStringParam != NULL);

   return theStringParam->myValue ();
   }

//------------------------------------------------------------------------------

int WitParamMgr::intParamVal (const char * paramName)
   {
   WitIntParam * theIntParam;

   theIntParam = allIntParams_.find (& WitIntParam::itsName, paramName);

   witAssert (theIntParam != NULL);

   return theIntParam->myValue ();
   }

//------------------------------------------------------------------------------

double WitParamMgr::doubleParamVal (const char * paramName)
   {
   WitDoubleParam * theDoubleParam;

   theDoubleParam =
      allDoubleParams_.find (& WitDoubleParam::itsName, paramName);

   witAssert (theDoubleParam != NULL);

   return theDoubleParam->myValue ();
   }

//------------------------------------------------------------------------------

const WitString & WitParamMgr::choiceParamVal (const char * paramName)
   {
   WitChoiceParam * theChoiceParam;

   theChoiceParam =
      allChoiceParams_.find (& WitChoiceParam::itsName, paramName);

   witAssert (theChoiceParam != NULL);

   return theChoiceParam->myValue ();
   }

//------------------------------------------------------------------------------

bool WitParamMgr::boolParamVal (const char * paramName)
   {
   WitChoiceParam * theBoolParam;

   theBoolParam = allBoolParams_.find (& WitChoiceParam::itsName, paramName);

   witAssert (theBoolParam != NULL);

   return (theBoolParam->myValue () == "yes");
   }

//------------------------------------------------------------------------------

const char * WitParamMgr::compParamIFName (int argc, char * argv[])
   {
   return
      (argc > 1)?      argv[1]:
      useDosFileNames? "run.par":
                       "run.params";
   }

//------------------------------------------------------------------------------

void WitParamMgr::buildNonDevParams ()
   {
   pCurrentParams_ = & allNonDevParams_;

   buildStringParam (
      "data_ifname",
      "Name of data input file",
      useDosFileNames? "wit.dat": "wit.data");

   buildStringParam (
      "log_ofname",
      "Name of status log output file",
      "wit.log");

   buildStringParam (
      "echo_ofname",
      "Name of echo output file",
      "echo.out");

   buildStringParam (
      "pre_ofname",
      "Name of pre-processing output file",
      "pre.out");

   buildStringParam (
      "solver_ofname",
      "Name of solver log output file",
      myOptComp ()->solverLogFileName ().myCstring ());

   buildStringParam (
      "soln_ofname",
      "Name of comprehensive soln. output file",
      "soln.out");

   buildStringParam (
      "exec_ofname",
      "Name of execution schedule output file",
      "exec.out");

   buildStringParam (
      "ship_ofname",
      "Name of shipment schedule output file",
      "ship.out");

   buildStringParam (
      "mrpsup_ofname",
      "Name of MRP supply schedule output file",
      "mrpsup.out");

   buildStringParam (
      "critical_ofname",
      "Name of critical part sched output file",
      "critical.out");

   buildBoolParam (
      "print_echo",
      "Print echo of data?",
      false);

   buildBoolParam (
      "print_pre",
      "Print pre-processed data?",
      false);

   buildBoolParam (
      "print_global",
      "Print global data?",
      false);

   buildBoolParam (
      "print_exec",
      "Print execution schedule?",
      true);

   buildBoolParam (
      "print_ship",
      "Print shipment schedule?",
      true);

   buildBoolParam (
      "print_soln",
      "Print comprehensive implosion solution?",
      false);

   buildActionParam ();

   buildBoolParam (
      "auto_pri",
      "Automatically generate priorities?",
      myGlobalComp ()->autoPriority ());

   buildIntParam (
      "n_critical",
      "# of critical parts to list",
      -1, -1,
      0);

   buildIntParam (
      "equitability",
      "Equitable allocation precision",
      1, 100,
      myGlobalComp ()->equitability ());

   buildIntParam (
      "outputPrecision",
      "Precision of prod and ship sched files",
      0, -1,
      myGlobalComp ()->outputPrecision ());

   pCurrentParams_ = NULL;
   }

//------------------------------------------------------------------------------

void WitParamMgr::buildDevParams ()
   {
   int       theIdx;
   WitString tempParName;
   WitString tempParText;

   pCurrentParams_ = & allDevParams_;

   buildStringParam (
      "data_ifname2",
      "Name of 2nd input data file",
      "");

   buildBoolParam (
      "printOptProblem",
      "Print the optimization problem?",
      myOptComp ()->printOptProblem ());

   buildBoolParam (
      "printMatByCols",
      "Print matrix in column major format?",
      myOptComp ()->printMatByCols ());

   buildBoolParam (
      "printInitSoln",
      "Print initial optimization solution?",
      myOptComp ()->printInitSoln ());

   buildBoolParam (
      "printOptSoln",
      "Print final optimization solution?",
      myOptComp ()->printOptSoln ());

   buildBoolParam (
      "printMps",
      "Print an MPS file of the opt problem?",
      myOptComp ()->printMps ());

   buildBoolParam (
      "skipScreening",
      "Skip screening of the opt problem?",
      myOptComp ()->skipScreening ());

   buildOptInitMethodParam ();

   buildBoolParam (
      "writeData",
      "Write an input data file?",
      false);

   buildStringParam (
      "data_ofname",
      "Name of input data file to be written",
      "data.out");

   buildBoolParam (
      "writeSolnData",
      "Write a solution data file?",
      false);

   buildStringParam (
      "sdata_ofname",
      "Name of soln data file to be written",
      "soln.data");

   buildBoolParam (
      "readDataMsgs",
      "Issue API info msgs during readData?",
      myGlobalComp ()->readDataMsgs ());

   buildBoolParam (
      "printEqAlloc",
      "Print equitable allocation targets?",
      myGlobalComp ()->printEqAlloc ());

   buildIntParam (
      "selPrintLevel",
      "Print level for multi-select",
      0, 4,
      myGlobalComp ()->selPrintLevel ());

   buildBoolParam (
      "makeVolServ",
      "Make the obj func vol serv?",
      false);

   buildBoolParam (
      "compVolServ",
      "Compute volume serviceability?",
      false);

   buildBoolParam (
      "crashOnFatal",
      "Crash after issuing a fatal error msg?",
      false);

   buildBoolParam (
      "twmeByDemand",
      "Two-way multi-exec by demand?",
      myGlobalComp ()->twmeByDemand ());

   buildBoolParam (
      "prtIncAlloc",
      "Print incHeurAlloc data?",
      false);

   buildDoubleParam (
      "splitTol",
      "Selection splitting tolerance",
      1e-6,
      1.0);

   buildDoubleParam (
      "splitRes",
      "Selection splitting resolution",
      1e-6,
      1.0);

   buildIntParam (
      "splitItrUB",
      "Split iteration upper bound",
      1, -1,
      myGlobalComp ()->splitItrUB ());

   buildBoolParam (
      "invokePip",
      "Invoke Post-Implosion Pegging?",
      false);

   buildBoolParam (
      "inputPauses",
      "Pause for user input?",
      myGlobalComp ()->inputPauses ());

   buildBoolParam (
      "prtPipMaxRatio",
      "Print PIP max ratio data?",
      myGlobalComp ()->prtPipMaxRatio ());

   buildBoolParam (
      "printDebug",
      "Print debugging data?",
      myGlobalComp ()->printDebug ());

   buildBoolParam (
      "printExcessVol",
      "Print excessVol?",
      myGlobalComp ()->printExcessVol ());

   buildBoolParam (
      "newPipPggOrder",
      "Use new PIP pegging order?",
      myGlobalComp ()->newPipPggOrder ());

      // Build tempPars.
      //
   for (theIdx = 1; theIdx <= myGlobalComp ()->nTempPars (); theIdx ++)
      {
      getTempParName (theIdx, tempParName);
      getTempParText (theIdx, tempParText);

      buildStringParam (
         tempParName.myCstring (),
         tempParText.myCstring (),
         myGlobalComp ()->tempPar (theIdx).myCstring ());
      }

   pCurrentParams_ = NULL;
   }

//------------------------------------------------------------------------------

void WitParamMgr::buildActionParam ()
   {
   WitChoiceParam * const theParam =
      buildChoiceParam (
         "action",
         "Action to be performed");

   theParam->addChoice ("preproc");
   theParam->addChoice ("mrp");
   theParam->addChoice ("heur");
   theParam->addChoice ("opt");
   theParam->addChoice ("stoch");

   if (DEVELOPMENT)
      theParam->addChoice ("eval");

   theParam->choose ("opt");
   }

//------------------------------------------------------------------------------

void WitParamMgr::buildOptInitMethodParam ()
   {
   WitChoiceParam * optInitParam;
   WitOptStarter *  theOptStarter;

   optInitParam =
      buildChoiceParam (
         "optInitMethod",
         "Override value for optInitMethod");

   optInitParam->addChoice ("none");

   forEachEl (theOptStarter, myOptComp ()->allOptStarters ())
      optInitParam->addChoice (theOptStarter->paramValue ().myCstring ());

   optInitParam->choose ("none");
   }

//------------------------------------------------------------------------------

void WitParamMgr::buildStringParam (
      const char * theName,
      const char * theText,
      const char * initValue)
   {
   allStringParams_.append (
      new WitStringParam (theName, theText, initValue, this));
   }

//------------------------------------------------------------------------------

void WitParamMgr::buildIntParam (
      const char * theName,
      const char * theText,
      int          theLB,
      int          theUB,
      int          initValue)
   {
   allIntParams_.append (
      new WitIntParam (theName, theText, theLB, theUB, initValue, this));
   }

//------------------------------------------------------------------------------

void WitParamMgr::buildDoubleParam (
      const char * theName,
      const char * theText,
      double       theLB,
      double       initValue)
   {
   allDoubleParams_.append (
      new WitDoubleParam (theName, theText, theLB, initValue, this));
   }

//------------------------------------------------------------------------------

WitChoiceParam * WitParamMgr::buildChoiceParam (
      const char * theName,
      const char * theText)
   {
   WitChoiceParam * theChoiceParam;

   theChoiceParam = new WitChoiceParam (theName, theText, this);

   allChoiceParams_.append (theChoiceParam);

   return theChoiceParam;
   }

//------------------------------------------------------------------------------

void WitParamMgr::buildBoolParam (
      const char * theName,
      const char * theText,
      bool         initValue)
   {
   WitChoiceParam * theBoolParam;

   theBoolParam = new WitChoiceParam (theName, theText, this);

   allBoolParams_.append (theBoolParam);

   theBoolParam->addChoice ("yes");
   theBoolParam->addChoice ("no");

   theBoolParam->choose (initValue? "yes": "no");
   }

//------------------------------------------------------------------------------

void WitParamMgr::readParams ()
   {
   FILE *     paramFile;
   int        fscanfRC;
   WitString  paramName  (80);
   WitString  valueToken (80);
   WitParam * theParam;

   WitList <WitParam> * pAllValidParams =
      DEVELOPMENT?
        &allParams_:
        &allNonDevParams_;

   myMsgFac () ("readParamsMsg");

   paramFile =
      myWitRun_->mySession ()->openFile (fileName ().myCstring (), "r");

   while (true)
      {
      fscanfRC = fscanf (paramFile, "%80s", paramName.myCstringForUpdate ());

      if (fscanfRC == EOF)
         break;

      if (fscanfRC == 0)
         myMsgFac () ("paramReadErrorReadProblemName", fileName ());

      theParam = 
         pAllValidParams->find (WitParam::itsName, paramName.myCstring ());

      if (theParam == NULL)
         myMsgFac () ("unrecParamSmsg", fileName (), paramName);

      fscanfRC = fscanf (paramFile, "%80s", valueToken.myCstringForUpdate ());

      if (fscanfRC == EOF)
         myMsgFac () ("paramReadErrorEofName", fileName (), paramName);

      if (fscanfRC == 0)
         myMsgFac () ("paramReadErrorReadProblemValue", fileName (), paramName);

      theParam->parse (valueToken);
      }

   fclose (paramFile);
   }

//------------------------------------------------------------------------------

void WitParamMgr::applyNonDevParams ()
   {
   myWitRun_->
      witSetMesgFileName (true, stringParamVal ("log_ofname").myCstring ());

   myWitRun_->mySession ()->printHeading ();

   if (DEVELOPMENT)
      printEnv ();

   myWitRun_->
      witSetSolverLogFileName (stringParamVal ("solver_ofname").myCstring ());

   myWitRun_->witSetAutoPriority (boolParamVal ("auto_pri"));

   myWitRun_->witSetComputeCriticalList (intParamVal ("n_critical") != 0);

   myWitRun_->witSetEquitability (intParamVal ("equitability"));

   myWitRun_->witSetOutputPrecision (intParamVal("outputPrecision"));
   }

//------------------------------------------------------------------------------

void WitParamMgr::printEnv ()
   {
   const char * hostName;
   const char * curDir;

   hostName = getenv ("SHORT_HOST");
   curDir   = getenv ("PWD");

   if (hostName != NULL)
      myMsgFac () ("hostNameMsg", hostName);

   if (curDir != NULL)
      myMsgFac () ("curDirectoryMsg", curDir);
   }

//------------------------------------------------------------------------------

void WitParamMgr::applyDevParams ()
   {
   double    splitTol;
   double    splitRes;
   int       theIdx;
   WitString tempParName;

   myOptComp    ()->setPrintOptProblem (boolParamVal ("printOptProblem"));
   myOptComp    ()->setPrintMatByCols  (boolParamVal ("printMatByCols"));
   myOptComp    ()->setPrintInitSoln   (boolParamVal ("printInitSoln"));
   myOptComp    ()->setPrintOptSoln    (boolParamVal ("printOptSoln"));
   myOptComp    ()->setPrintMps        (boolParamVal ("printMps"));
   myOptComp    ()->setSkipScreening   (boolParamVal ("skipScreening"));

   myGlobalComp ()->setPrintIncAlloc   (boolParamVal ("prtIncAlloc"));
   myGlobalComp ()->setPrintEqAlloc    (boolParamVal ("printEqAlloc"));
   myGlobalComp ()->setSelPrintLevel   (intParamVal  ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand    (boolParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB      (intParamVal  ("splitItrUB"));
   myGlobalComp ()->setInputPauses     (boolParamVal ("inputPauses"));
   myGlobalComp ()->setPrtPipMaxRatio  (boolParamVal ("prtPipMaxRatio"));
   myGlobalComp ()->setPrintDebug      (boolParamVal ("printDebug"));
   myGlobalComp ()->setPrintExcessVol  (boolParamVal ("printExcessVol"));
   myGlobalComp ()->setNewPipPggOrder  (boolParamVal ("newPipPggOrder"));

   splitTol = doubleParamVal ("splitTol");
   splitRes = doubleParamVal ("splitRes");

   if (splitTol < splitRes)
      myMsgFac () ("genericSmsg", "splitTol < splitRes");

   myGlobalComp ()->setSplitTol (splitTol);
   myGlobalComp ()->setSplitRes (splitRes);

   myMsgFac ().setCrashOnFatal (boolParamVal ("crashOnFatal"));

   for (theIdx = 1; theIdx <= myGlobalComp ()->nTempPars (); theIdx ++)
      {
      getTempParName (theIdx, tempParName);

      myGlobalComp ()->setTempPar (
         theIdx, 
         stringParamVal (tempParName.myCstring ()));
      }
   }

//------------------------------------------------------------------------------

void WitParamMgr::printParams ()
   {
   WitParam * theParam;

   myMsgFac () ("nonDevParamHeadingMsg", fileName ());

   forEachEl (theParam, allNonDevParams_)
      theParam->print ();

   if (DEVELOPMENT)
      {
      myMsgFac () ("devParamHeadingMsg");

      forEachEl (theParam, allDevParams_)
         theParam->print ();
      }

   myMsgFac () ("blankMsg");
   }

//------------------------------------------------------------------------------

void WitParamMgr::getTempParName (int theIdx, WitString & theString)
   {
   theString.resize (100);

   sprintf (theString.myCstringForUpdate (), "tempPar%d", theIdx);
   }

//------------------------------------------------------------------------------

void WitParamMgr::getTempParText (int theIdx, WitString & theString)
   {
   theString.resize (100);

   sprintf (
      theString.myCstringForUpdate (),
      "Temporary development parameter #%d",
      theIdx);
   }
@


1.237
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.236
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d50 3
a52 3
{
return myProblem ()->myCompMgr ()->myGlobalComp ();
}
d57 3
a59 3
{
return myProblem ()->myCompMgr ()->myOptComp ();
}
d64 3
a66 3
{
return myWitRun_->mySession()->myProblem ();
}
d72 2
a73 2
myWitRun_         (theWitRun),
myMsgFac_         (theWitRun->myMsgFac ()),
d75 1
a75 1
fileName_         (compParamIFName (argc, argv)),
d77 12
a88 12
allParams_ (),
allNonDevParams_ (),
allDevParams_ (),
allStringParams_ (),
allIntParams_ (),
allDoubleParams_ (),
allChoiceParams_ (),
allBoolParams_    (),

pCurrentParams_   (NULL)
{
}
d93 4
a96 4
{
while (not allParams_.isEmpty ())
delete allParams_.get ();
}
d101 3
a103 3
{
buildNonDevParams ();
buildDevParams    ();
d105 1
a105 1
readParams ();
d107 2
a108 2
applyNonDevParams ();
applyDevParams    ();
d110 2
a111 2
printParams ();
}
d116 18
a133 18
{
if (DEBUG_MODE)
{
WitParam * dupParam;

dupParam =
allParams_.find (
& WitParam::itsName,
theParam->myName ().myCstring ());

witAssert (dupParam == NULL);
}
//
// Verify that the name is not duplicated.

allParams_      .append (theParam);
pCurrentParams_->append (theParam);
}
d138 2
a139 2
{
WitStringParam * theStringParam;
d141 2
a142 2
theStringParam =
allStringParams_.find (& WitStringParam::itsName, paramName);
d144 1
a144 1
witAssert (theStringParam != NULL);
d146 2
a147 2
return theStringParam->myValue ();
}
d152 2
a153 2
{
WitIntParam * theIntParam;
d155 1
a155 1
theIntParam = allIntParams_.find (& WitIntParam::itsName, paramName);
d157 1
a157 1
witAssert (theIntParam != NULL);
d159 2
a160 2
return theIntParam->myValue ();
}
d165 2
a166 2
{
WitDoubleParam * theDoubleParam;
d168 2
a169 2
theDoubleParam =
allDoubleParams_.find (& WitDoubleParam::itsName, paramName);
d171 1
a171 1
witAssert (theDoubleParam != NULL);
d173 2
a174 2
return theDoubleParam->myValue ();
}
d179 2
a180 2
{
WitChoiceParam * theChoiceParam;
d182 2
a183 2
theChoiceParam =
allChoiceParams_.find (& WitChoiceParam::itsName, paramName);
d185 1
a185 1
witAssert (theChoiceParam != NULL);
d187 2
a188 2
return theChoiceParam->myValue ();
}
d193 2
a194 2
{
WitChoiceParam * theBoolParam;
d196 1
a196 1
theBoolParam = allBoolParams_.find (& WitChoiceParam::itsName, paramName);
d198 1
a198 1
witAssert (theBoolParam != NULL);
d200 2
a201 2
return (theBoolParam->myValue () == "yes");
}
d206 6
a211 6
{
return
(argc > 1)?      argv[1]:
useDosFileNames? "run.par":
"run.params";
}
d216 2
a217 2
{
pCurrentParams_ = & allNonDevParams_;
d219 104
a322 104
buildStringParam (
"data_ifname",
"Name of data input file",
useDosFileNames? "wit.dat": "wit.data");

buildStringParam (
"log_ofname",
"Name of status log output file",
"wit.log");

buildStringParam (
"echo_ofname",
"Name of echo output file",
"echo.out");

buildStringParam (
"pre_ofname",
"Name of pre-processing output file",
"pre.out");

buildStringParam (
"solver_ofname",
"Name of solver log output file",
myOptComp ()->solverLogFileName ().myCstring ());

buildStringParam (
"soln_ofname",
"Name of comprehensive soln. output file",
"soln.out");

buildStringParam (
"exec_ofname",
"Name of execution schedule output file",
"exec.out");

buildStringParam (
"ship_ofname",
"Name of shipment schedule output file",
"ship.out");

buildStringParam (
"mrpsup_ofname",
"Name of MRP supply schedule output file",
"mrpsup.out");

buildStringParam (
"critical_ofname",
"Name of critical part sched output file",
"critical.out");

buildBoolParam (
"print_echo",
"Print echo of data?",
false);

buildBoolParam (
"print_pre",
"Print pre-processed data?",
false);

buildBoolParam (
"print_global",
"Print global data?",
false);

buildBoolParam (
"print_exec",
"Print execution schedule?",
true);

buildBoolParam (
"print_ship",
"Print shipment schedule?",
true);

buildBoolParam (
"print_soln",
"Print comprehensive implosion solution?",
false);

buildActionParam ();

buildBoolParam (
"auto_pri",
"Automatically generate priorities?",
myGlobalComp ()->autoPriority ());

buildIntParam (
"n_critical",
"# of critical parts to list",
-1, -1,
0);

buildIntParam (
"equitability",
"Equitable allocation precision",
1, 100,
myGlobalComp ()->equitability ());

buildIntParam (
"outputPrecision",
"Precision of prod and ship sched files",
0, -1,
myGlobalComp ()->outputPrecision ());
d324 2
a325 2
pCurrentParams_ = NULL;
}
d330 165
a494 165
{
int       theIdx;
WitString tempParName;
WitString tempParText;

pCurrentParams_ = & allDevParams_;

buildStringParam (
"data_ifname2",
"Name of 2nd input data file",
"");

buildBoolParam (
"printOptProblem",
"Print the optimization problem?",
myOptComp ()->printOptProblem ());

buildBoolParam (
"printMatByCols",
"Print matrix in column major format?",
myOptComp ()->printMatByCols ());

buildBoolParam (
"printInitSoln",
"Print initial optimization solution?",
myOptComp ()->printInitSoln ());

buildBoolParam (
"printOptSoln",
"Print final optimization solution?",
myOptComp ()->printOptSoln ());

buildBoolParam (
"printMps",
"Print an MPS file of the opt problem?",
myOptComp ()->printMps ());

buildBoolParam (
"skipScreening",
"Skip screening of the opt problem?",
myOptComp ()->skipScreening ());

buildOptInitMethodParam ();

buildBoolParam (
"writeData",
"Write an input data file?",
false);

buildStringParam (
"data_ofname",
"Name of input data file to be written",
"data.out");

buildBoolParam (
"writeSolnData",
"Write a solution data file?",
false);

buildStringParam (
"sdata_ofname",
"Name of soln data file to be written",
"soln.data");

buildBoolParam (
"readDataMsgs",
"Issue API info msgs during readData?",
myGlobalComp ()->readDataMsgs ());

buildBoolParam (
"printEqAlloc",
"Print equitable allocation targets?",
myGlobalComp ()->printEqAlloc ());

buildIntParam (
"selPrintLevel",
"Print level for multi-select",
0, 4,
myGlobalComp ()->selPrintLevel ());

buildBoolParam (
"makeVolServ",
"Make the obj func vol serv?",
false);

buildBoolParam (
"compVolServ",
"Compute volume serviceability?",
false);

buildBoolParam (
"crashOnFatal",
"Crash after issuing a fatal error msg?",
false);

buildBoolParam (
"twmeByDemand",
"Two-way multi-exec by demand?",
myGlobalComp ()->twmeByDemand ());

buildBoolParam (
"prtIncAlloc",
"Print incHeurAlloc data?",
false);

buildDoubleParam (
"splitTol",
"Selection splitting tolerance",
1e-6,
1.0);

buildDoubleParam (
"splitRes",
"Selection splitting resolution",
1e-6,
1.0);

buildIntParam (
"splitItrUB",
"Split iteration upper bound",
1, -1,
myGlobalComp ()->splitItrUB ());

buildBoolParam (
"invokePip",
"Invoke Post-Implosion Pegging?",
false);

buildBoolParam (
"inputPauses",
"Pause for user input?",
myGlobalComp ()->inputPauses ());

buildBoolParam (
"prtPipMaxRatio",
"Print PIP max ratio data?",
myGlobalComp ()->prtPipMaxRatio ());

buildBoolParam (
"printDebug",
"Print debugging data?",
myGlobalComp ()->printDebug ());

buildBoolParam (
"printExcessVol",
"Print excessVol?",
myGlobalComp ()->printExcessVol ());

buildBoolParam (
"newPipPggOrder",
"Use new PIP pegging order?",
myGlobalComp ()->newPipPggOrder ());

// Build tempPars.
//
for (theIdx = 1; theIdx <= myGlobalComp ()->nTempPars (); theIdx ++)
{
getTempParName (theIdx, tempParName);
getTempParText (theIdx, tempParText);

buildStringParam (
tempParName.myCstring (),
tempParText.myCstring (),
myGlobalComp ()->tempPar (theIdx).myCstring ());
}
d496 2
a497 2
pCurrentParams_ = NULL;
}
d502 11
a512 11
{
WitChoiceParam * const theParam =
buildChoiceParam (
"action",
"Action to be performed");

theParam->addChoice ("preproc");
theParam->addChoice ("mrp");
theParam->addChoice ("heur");
theParam->addChoice ("opt");
theParam->addChoice ("stoch");
d514 2
a515 2
if (DEVELOPMENT)
theParam->addChoice ("eval");
d517 2
a518 2
theParam->choose ("opt");
}
d523 8
a530 8
{
WitChoiceParam * optInitParam;
WitOptStarter *  theOptStarter;

optInitParam =
buildChoiceParam (
"optInitMethod",
"Override value for optInitMethod");
d532 1
a532 1
optInitParam->addChoice ("none");
d534 2
a535 2
forEachEl (theOptStarter, myOptComp ()->allOptStarters ())
optInitParam->addChoice (theOptStarter->paramValue ().myCstring ());
d537 2
a538 2
optInitParam->choose ("none");
}
d543 7
a549 7
const char * theName,
const char * theText,
const char * initValue)
{
allStringParams_.append (
new WitStringParam (theName, theText, initValue, this));
}
d554 9
a562 9
const char * theName,
const char * theText,
int          theLB,
int          theUB,
int          initValue)
{
allIntParams_.append (
new WitIntParam (theName, theText, theLB, theUB, initValue, this));
}
d567 8
a574 8
const char * theName,
const char * theText,
double       theLB,
double       initValue)
{
allDoubleParams_.append (
new WitDoubleParam (theName, theText, theLB, initValue, this));
}
d579 4
a582 4
const char * theName,
const char * theText)
{
WitChoiceParam * theChoiceParam;
d584 1
a584 1
theChoiceParam = new WitChoiceParam (theName, theText, this);
d586 1
a586 1
allChoiceParams_.append (theChoiceParam);
d588 2
a589 2
return theChoiceParam;
}
d594 5
a598 5
const char * theName,
const char * theText,
bool         initValue)
{
WitChoiceParam * theBoolParam;
d600 1
a600 1
theBoolParam = new WitChoiceParam (theName, theText, this);
d602 1
a602 1
allBoolParams_.append (theBoolParam);
d604 2
a605 2
theBoolParam->addChoice ("yes");
theBoolParam->addChoice ("no");
d607 2
a608 2
theBoolParam->choose (initValue? "yes": "no");
}
d613 6
a618 6
{
FILE *     paramFile;
int        fscanfRC;
WitString  paramName  (80);
WitString  valueToken (80);
WitParam * theParam;
d620 4
a623 4
WitList <WitParam> * pAllValidParams =
DEVELOPMENT?
&allParams_:
&allNonDevParams_;
d625 1
a625 1
myMsgFac () ("readParamsMsg");
d627 2
a628 2
paramFile =
myWitRun_->mySession ()->openFile (fileName ().myCstring (), "r");
d630 3
a632 3
while (true)
{
fscanfRC = fscanf (paramFile, "%80s", paramName.myCstringForUpdate ());
d634 2
a635 2
if (fscanfRC == EOF)
break;
d637 2
a638 2
if (fscanfRC == 0)
myMsgFac () ("paramReadErrorReadProblemName", fileName ());
d640 2
a641 2
theParam =
pAllValidParams->find (WitParam::itsName, paramName.myCstring ());
d643 2
a644 2
if (theParam == NULL)
myMsgFac () ("unrecParamSmsg", fileName (), paramName);
d646 1
a646 1
fscanfRC = fscanf (paramFile, "%80s", valueToken.myCstringForUpdate ());
d648 2
a649 2
if (fscanfRC == EOF)
myMsgFac () ("paramReadErrorEofName", fileName (), paramName);
d651 2
a652 2
if (fscanfRC == 0)
myMsgFac () ("paramReadErrorReadProblemValue", fileName (), paramName);
d654 2
a655 2
theParam->parse (valueToken);
}
d657 2
a658 2
fclose (paramFile);
}
d663 3
a665 3
{
myWitRun_->
witSetMesgFileName (true, stringParamVal ("log_ofname").myCstring ());
d667 1
a667 1
myWitRun_->mySession ()->printHeading ();
d669 2
a670 2
if (DEVELOPMENT)
printEnv ();
d672 2
a673 2
myWitRun_->
witSetSolverLogFileName (stringParamVal ("solver_ofname").myCstring ());
d675 1
a675 1
myWitRun_->witSetAutoPriority (boolParamVal ("auto_pri"));
d677 1
a677 1
myWitRun_->witSetComputeCriticalList (intParamVal ("n_critical") != 0);
d679 1
a679 1
myWitRun_->witSetEquitability (intParamVal ("equitability"));
d681 2
a682 2
myWitRun_->witSetOutputPrecision (intParamVal("outputPrecision"));
}
d687 13
a699 13
{
const char * hostName;
const char * curDir;

hostName = getenv ("SHORT_HOST");
curDir   = getenv ("PWD");

if (hostName != NULL)
myMsgFac () ("hostNameMsg", hostName);

if (curDir != NULL)
myMsgFac () ("curDirectoryMsg", curDir);
}
d704 44
a747 44
{
double    splitTol;
double    splitRes;
int       theIdx;
WitString tempParName;

myOptComp    ()->setPrintOptProblem (boolParamVal ("printOptProblem"));
myOptComp    ()->setPrintMatByCols  (boolParamVal ("printMatByCols"));
myOptComp    ()->setPrintInitSoln   (boolParamVal ("printInitSoln"));
myOptComp    ()->setPrintOptSoln    (boolParamVal ("printOptSoln"));
myOptComp    ()->setPrintMps        (boolParamVal ("printMps"));
myOptComp    ()->setSkipScreening   (boolParamVal ("skipScreening"));

myGlobalComp ()->setPrintIncAlloc   (boolParamVal ("prtIncAlloc"));
myGlobalComp ()->setPrintEqAlloc    (boolParamVal ("printEqAlloc"));
myGlobalComp ()->setSelPrintLevel   (intParamVal  ("selPrintLevel"));
myGlobalComp ()->setTwmeByDemand    (boolParamVal ("twmeByDemand"));
myGlobalComp ()->setSplitItrUB      (intParamVal  ("splitItrUB"));
myGlobalComp ()->setInputPauses     (boolParamVal ("inputPauses"));
myGlobalComp ()->setPrtPipMaxRatio  (boolParamVal ("prtPipMaxRatio"));
myGlobalComp ()->setPrintDebug      (boolParamVal ("printDebug"));
myGlobalComp ()->setPrintExcessVol  (boolParamVal ("printExcessVol"));
myGlobalComp ()->setNewPipPggOrder  (boolParamVal ("newPipPggOrder"));

splitTol = doubleParamVal ("splitTol");
splitRes = doubleParamVal ("splitRes");

if (splitTol < splitRes)
myMsgFac () ("genericSmsg", "splitTol < splitRes");

myGlobalComp ()->setSplitTol (splitTol);
myGlobalComp ()->setSplitRes (splitRes);

myMsgFac ().setCrashOnFatal (boolParamVal ("crashOnFatal"));

for (theIdx = 1; theIdx <= myGlobalComp ()->nTempPars (); theIdx ++)
{
getTempParName (theIdx, tempParName);

myGlobalComp ()->setTempPar (
theIdx,
stringParamVal (tempParName.myCstring ()));
}
}
d752 2
a753 2
{
WitParam * theParam;
d755 1
a755 1
myMsgFac () ("nonDevParamHeadingMsg", fileName ());
d757 2
a758 2
forEachEl (theParam, allNonDevParams_)
theParam->print ();
d760 3
a762 3
if (DEVELOPMENT)
{
myMsgFac () ("devParamHeadingMsg");
d764 3
a766 3
forEachEl (theParam, allDevParams_)
theParam->print ();
}
d768 2
a769 2
myMsgFac () ("blankMsg");
}
d774 2
a775 2
{
theString.resize (100);
d777 2
a778 2
sprintf (theString.myCstringForUpdate (), "tempPar%d", theIdx);
}
d783 2
a784 2
{
theString.resize (100);
d786 5
a790 5
sprintf (
theString.myCstringForUpdate (),
"Temporary development parameter #%d",
theIdx);
}
@


1.235
log
@Removed COIN from WIT.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d50 3
a52 3
   {
   return myProblem ()->myCompMgr ()->myGlobalComp ();
   }
d57 3
a59 3
   {
   return myProblem ()->myCompMgr ()->myOptComp ();
   }
d64 3
a66 3
   {
   return myWitRun_->mySession()->myProblem ();
   }
d72 2
a73 2
      myWitRun_         (theWitRun),
      myMsgFac_         (theWitRun->myMsgFac ()),
d75 1
a75 1
      fileName_         (compParamIFName (argc, argv)),
d77 12
a88 12
             allParams_ (),
       allNonDevParams_ (),
          allDevParams_ (),
       allStringParams_ (),
          allIntParams_ (),
       allDoubleParams_ (),
       allChoiceParams_ (),
      allBoolParams_    (),

      pCurrentParams_   (NULL)
   {
   }
d93 4
a96 4
   {
   while (not allParams_.isEmpty ())
      delete allParams_.get ();
   }
d101 3
a103 3
   {
   buildNonDevParams ();
   buildDevParams    ();
d105 1
a105 1
   readParams ();
d107 2
a108 2
   applyNonDevParams ();
   applyDevParams    ();
d110 2
a111 2
   printParams ();
   }
d116 18
a133 18
   {
   if (DEBUG_MODE)
      {
      WitParam * dupParam;

      dupParam = 
         allParams_.find (
            & WitParam::itsName,
              theParam->myName ().myCstring ());

      witAssert (dupParam == NULL);
      }
      //
      // Verify that the name is not duplicated.

   allParams_      .append (theParam);
   pCurrentParams_->append (theParam);
   }
d138 2
a139 2
   {
   WitStringParam * theStringParam;
d141 2
a142 2
   theStringParam =
      allStringParams_.find (& WitStringParam::itsName, paramName);
d144 1
a144 1
   witAssert (theStringParam != NULL);
d146 2
a147 2
   return theStringParam->myValue ();
   }
d152 2
a153 2
   {
   WitIntParam * theIntParam;
d155 1
a155 1
   theIntParam = allIntParams_.find (& WitIntParam::itsName, paramName);
d157 1
a157 1
   witAssert (theIntParam != NULL);
d159 2
a160 2
   return theIntParam->myValue ();
   }
d165 2
a166 2
   {
   WitDoubleParam * theDoubleParam;
d168 2
a169 2
   theDoubleParam =
      allDoubleParams_.find (& WitDoubleParam::itsName, paramName);
d171 1
a171 1
   witAssert (theDoubleParam != NULL);
d173 2
a174 2
   return theDoubleParam->myValue ();
   }
d179 2
a180 2
   {
   WitChoiceParam * theChoiceParam;
d182 2
a183 2
   theChoiceParam =
      allChoiceParams_.find (& WitChoiceParam::itsName, paramName);
d185 1
a185 1
   witAssert (theChoiceParam != NULL);
d187 2
a188 2
   return theChoiceParam->myValue ();
   }
d193 2
a194 2
   {
   WitChoiceParam * theBoolParam;
d196 1
a196 1
   theBoolParam = allBoolParams_.find (& WitChoiceParam::itsName, paramName);
d198 1
a198 1
   witAssert (theBoolParam != NULL);
d200 2
a201 2
   return (theBoolParam->myValue () == "yes");
   }
d206 6
a211 6
   {
   return
      (argc > 1)?      argv[1]:
      useDosFileNames? "run.par":
                       "run.params";
   }
d216 2
a217 2
   {
   pCurrentParams_ = & allNonDevParams_;
d219 104
a322 104
   buildStringParam (
      "data_ifname",
      "Name of data input file",
      useDosFileNames? "wit.dat": "wit.data");

   buildStringParam (
      "log_ofname",
      "Name of status log output file",
      "wit.log");

   buildStringParam (
      "echo_ofname",
      "Name of echo output file",
      "echo.out");

   buildStringParam (
      "pre_ofname",
      "Name of pre-processing output file",
      "pre.out");

   buildStringParam (
      "solver_ofname",
      "Name of solver log output file",
      myOptComp ()->solverLogFileName ().myCstring ());

   buildStringParam (
      "soln_ofname",
      "Name of comprehensive soln. output file",
      "soln.out");

   buildStringParam (
      "exec_ofname",
      "Name of execution schedule output file",
      "exec.out");

   buildStringParam (
      "ship_ofname",
      "Name of shipment schedule output file",
      "ship.out");

   buildStringParam (
      "mrpsup_ofname",
      "Name of MRP supply schedule output file",
      "mrpsup.out");

   buildStringParam (
      "critical_ofname",
      "Name of critical part sched output file",
      "critical.out");

   buildBoolParam (
      "print_echo",
      "Print echo of data?",
      false);

   buildBoolParam (
      "print_pre",
      "Print pre-processed data?",
      false);

   buildBoolParam (
      "print_global",
      "Print global data?",
      false);

   buildBoolParam (
      "print_exec",
      "Print execution schedule?",
      true);

   buildBoolParam (
      "print_ship",
      "Print shipment schedule?",
      true);

   buildBoolParam (
      "print_soln",
      "Print comprehensive implosion solution?",
      false);

   buildActionParam ();

   buildBoolParam (
      "auto_pri",
      "Automatically generate priorities?",
      myGlobalComp ()->autoPriority ());

   buildIntParam (
      "n_critical",
      "# of critical parts to list",
      -1, -1,
      0);

   buildIntParam (
      "equitability",
      "Equitable allocation precision",
      1, 100,
      myGlobalComp ()->equitability ());

   buildIntParam (
      "outputPrecision",
      "Precision of prod and ship sched files",
      0, -1,
      myGlobalComp ()->outputPrecision ());
d324 2
a325 2
   pCurrentParams_ = NULL;
   }
d330 165
a494 165
   {
   int       theIdx;
   WitString tempParName;
   WitString tempParText;

   pCurrentParams_ = & allDevParams_;

   buildStringParam (
      "data_ifname2",
      "Name of 2nd input data file",
      "");

   buildBoolParam (
      "printOptProblem",
      "Print the optimization problem?",
      myOptComp ()->printOptProblem ());

   buildBoolParam (
      "printMatByCols",
      "Print matrix in column major format?",
      myOptComp ()->printMatByCols ());

   buildBoolParam (
      "printInitSoln",
      "Print initial optimization solution?",
      myOptComp ()->printInitSoln ());

   buildBoolParam (
      "printOptSoln",
      "Print final optimization solution?",
      myOptComp ()->printOptSoln ());

   buildBoolParam (
      "printMps",
      "Print an MPS file of the opt problem?",
      myOptComp ()->printMps ());

   buildBoolParam (
      "skipScreening",
      "Skip screening of the opt problem?",
      myOptComp ()->skipScreening ());

   buildOptInitMethodParam ();

   buildBoolParam (
      "writeData",
      "Write an input data file?",
      false);

   buildStringParam (
      "data_ofname",
      "Name of input data file to be written",
      "data.out");

   buildBoolParam (
      "writeSolnData",
      "Write a solution data file?",
      false);

   buildStringParam (
      "sdata_ofname",
      "Name of soln data file to be written",
      "soln.data");

   buildBoolParam (
      "readDataMsgs",
      "Issue API info msgs during readData?",
      myGlobalComp ()->readDataMsgs ());

   buildBoolParam (
      "printEqAlloc",
      "Print equitable allocation targets?",
      myGlobalComp ()->printEqAlloc ());

   buildIntParam (
      "selPrintLevel",
      "Print level for multi-select",
      0, 4,
      myGlobalComp ()->selPrintLevel ());

   buildBoolParam (
      "makeVolServ",
      "Make the obj func vol serv?",
      false);

   buildBoolParam (
      "compVolServ",
      "Compute volume serviceability?",
      false);

   buildBoolParam (
      "crashOnFatal",
      "Crash after issuing a fatal error msg?",
      false);

   buildBoolParam (
      "twmeByDemand",
      "Two-way multi-exec by demand?",
      myGlobalComp ()->twmeByDemand ());

   buildBoolParam (
      "prtIncAlloc",
      "Print incHeurAlloc data?",
      false);

   buildDoubleParam (
      "splitTol",
      "Selection splitting tolerance",
      1e-6,
      1.0);

   buildDoubleParam (
      "splitRes",
      "Selection splitting resolution",
      1e-6,
      1.0);

   buildIntParam (
      "splitItrUB",
      "Split iteration upper bound",
      1, -1,
      myGlobalComp ()->splitItrUB ());

   buildBoolParam (
      "invokePip",
      "Invoke Post-Implosion Pegging?",
      false);

   buildBoolParam (
      "inputPauses",
      "Pause for user input?",
      myGlobalComp ()->inputPauses ());

   buildBoolParam (
      "prtPipMaxRatio",
      "Print PIP max ratio data?",
      myGlobalComp ()->prtPipMaxRatio ());

   buildBoolParam (
      "printDebug",
      "Print debugging data?",
      myGlobalComp ()->printDebug ());

   buildBoolParam (
      "printExcessVol",
      "Print excessVol?",
      myGlobalComp ()->printExcessVol ());

   buildBoolParam (
      "newPipPggOrder",
      "Use new PIP pegging order?",
      myGlobalComp ()->newPipPggOrder ());

      // Build tempPars.
      //
   for (theIdx = 1; theIdx <= myGlobalComp ()->nTempPars (); theIdx ++)
      {
      getTempParName (theIdx, tempParName);
      getTempParText (theIdx, tempParText);

      buildStringParam (
         tempParName.myCstring (),
         tempParText.myCstring (),
         myGlobalComp ()->tempPar (theIdx).myCstring ());
      }
d496 2
a497 2
   pCurrentParams_ = NULL;
   }
d502 11
a512 11
   {
   WitChoiceParam * const theParam =
      buildChoiceParam (
         "action",
         "Action to be performed");

   theParam->addChoice ("preproc");
   theParam->addChoice ("mrp");
   theParam->addChoice ("heur");
   theParam->addChoice ("opt");
   theParam->addChoice ("stoch");
d514 2
a515 2
   if (DEVELOPMENT)
      theParam->addChoice ("eval");
d517 2
a518 2
   theParam->choose ("opt");
   }
d523 8
a530 8
   {
   WitChoiceParam * optInitParam;
   WitOptStarter *  theOptStarter;

   optInitParam =
      buildChoiceParam (
         "optInitMethod",
         "Override value for optInitMethod");
d532 1
a532 1
   optInitParam->addChoice ("none");
d534 2
a535 2
   forEachEl (theOptStarter, myOptComp ()->allOptStarters ())
      optInitParam->addChoice (theOptStarter->paramValue ().myCstring ());
d537 2
a538 2
   optInitParam->choose ("none");
   }
d543 7
a549 7
      const char * theName,
      const char * theText,
      const char * initValue)
   {
   allStringParams_.append (
      new WitStringParam (theName, theText, initValue, this));
   }
d554 9
a562 9
      const char * theName,
      const char * theText,
      int          theLB,
      int          theUB,
      int          initValue)
   {
   allIntParams_.append (
      new WitIntParam (theName, theText, theLB, theUB, initValue, this));
   }
d567 8
a574 8
      const char * theName,
      const char * theText,
      double       theLB,
      double       initValue)
   {
   allDoubleParams_.append (
      new WitDoubleParam (theName, theText, theLB, initValue, this));
   }
d579 4
a582 4
      const char * theName,
      const char * theText)
   {
   WitChoiceParam * theChoiceParam;
d584 1
a584 1
   theChoiceParam = new WitChoiceParam (theName, theText, this);
d586 1
a586 1
   allChoiceParams_.append (theChoiceParam);
d588 2
a589 2
   return theChoiceParam;
   }
d594 5
a598 5
      const char * theName,
      const char * theText,
      bool         initValue)
   {
   WitChoiceParam * theBoolParam;
d600 1
a600 1
   theBoolParam = new WitChoiceParam (theName, theText, this);
d602 1
a602 1
   allBoolParams_.append (theBoolParam);
d604 2
a605 2
   theBoolParam->addChoice ("yes");
   theBoolParam->addChoice ("no");
d607 2
a608 2
   theBoolParam->choose (initValue? "yes": "no");
   }
d613 6
a618 6
   {
   FILE *     paramFile;
   int        fscanfRC;
   WitString  paramName  (80);
   WitString  valueToken (80);
   WitParam * theParam;
d620 4
a623 4
   WitList <WitParam> * pAllValidParams =
      DEVELOPMENT?
        &allParams_:
        &allNonDevParams_;
d625 1
a625 1
   myMsgFac () ("readParamsMsg");
d627 2
a628 2
   paramFile =
      myWitRun_->mySession ()->openFile (fileName ().myCstring (), "r");
d630 3
a632 3
   while (true)
      {
      fscanfRC = fscanf (paramFile, "%80s", paramName.myCstringForUpdate ());
d634 2
a635 2
      if (fscanfRC == EOF)
         break;
d637 2
a638 2
      if (fscanfRC == 0)
         myMsgFac () ("paramReadErrorReadProblemName", fileName ());
d640 2
a641 2
      theParam = 
         pAllValidParams->find (WitParam::itsName, paramName.myCstring ());
d643 2
a644 2
      if (theParam == NULL)
         myMsgFac () ("unrecParamSmsg", fileName (), paramName);
d646 1
a646 1
      fscanfRC = fscanf (paramFile, "%80s", valueToken.myCstringForUpdate ());
d648 2
a649 2
      if (fscanfRC == EOF)
         myMsgFac () ("paramReadErrorEofName", fileName (), paramName);
d651 2
a652 2
      if (fscanfRC == 0)
         myMsgFac () ("paramReadErrorReadProblemValue", fileName (), paramName);
d654 2
a655 2
      theParam->parse (valueToken);
      }
d657 2
a658 2
   fclose (paramFile);
   }
d663 3
a665 3
   {
   myWitRun_->
      witSetMesgFileName (true, stringParamVal ("log_ofname").myCstring ());
d667 1
a667 1
   myWitRun_->mySession ()->printHeading ();
d669 2
a670 2
   if (DEVELOPMENT)
      printEnv ();
d672 2
a673 2
   myWitRun_->
      witSetSolverLogFileName (stringParamVal ("solver_ofname").myCstring ());
d675 1
a675 1
   myWitRun_->witSetAutoPriority (boolParamVal ("auto_pri"));
d677 1
a677 1
   myWitRun_->witSetComputeCriticalList (intParamVal ("n_critical") != 0);
d679 1
a679 1
   myWitRun_->witSetEquitability (intParamVal ("equitability"));
d681 2
a682 2
   myWitRun_->witSetOutputPrecision (intParamVal("outputPrecision"));
   }
d687 13
a699 13
   {
   const char * hostName;
   const char * curDir;

   hostName = getenv ("SHORT_HOST");
   curDir   = getenv ("PWD");

   if (hostName != NULL)
      myMsgFac () ("hostNameMsg", hostName);

   if (curDir != NULL)
      myMsgFac () ("curDirectoryMsg", curDir);
   }
d704 44
a747 44
   {
   double    splitTol;
   double    splitRes;
   int       theIdx;
   WitString tempParName;

   myOptComp    ()->setPrintOptProblem (boolParamVal ("printOptProblem"));
   myOptComp    ()->setPrintMatByCols  (boolParamVal ("printMatByCols"));
   myOptComp    ()->setPrintInitSoln   (boolParamVal ("printInitSoln"));
   myOptComp    ()->setPrintOptSoln    (boolParamVal ("printOptSoln"));
   myOptComp    ()->setPrintMps        (boolParamVal ("printMps"));
   myOptComp    ()->setSkipScreening   (boolParamVal ("skipScreening"));

   myGlobalComp ()->setPrintIncAlloc   (boolParamVal ("prtIncAlloc"));
   myGlobalComp ()->setPrintEqAlloc    (boolParamVal ("printEqAlloc"));
   myGlobalComp ()->setSelPrintLevel   (intParamVal  ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand    (boolParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB      (intParamVal  ("splitItrUB"));
   myGlobalComp ()->setInputPauses     (boolParamVal ("inputPauses"));
   myGlobalComp ()->setPrtPipMaxRatio  (boolParamVal ("prtPipMaxRatio"));
   myGlobalComp ()->setPrintDebug      (boolParamVal ("printDebug"));
   myGlobalComp ()->setPrintExcessVol  (boolParamVal ("printExcessVol"));
   myGlobalComp ()->setNewPipPggOrder  (boolParamVal ("newPipPggOrder"));

   splitTol = doubleParamVal ("splitTol");
   splitRes = doubleParamVal ("splitRes");

   if (splitTol < splitRes)
      myMsgFac () ("genericSmsg", "splitTol < splitRes");

   myGlobalComp ()->setSplitTol (splitTol);
   myGlobalComp ()->setSplitRes (splitRes);

   myMsgFac ().setCrashOnFatal (boolParamVal ("crashOnFatal"));

   for (theIdx = 1; theIdx <= myGlobalComp ()->nTempPars (); theIdx ++)
      {
      getTempParName (theIdx, tempParName);

      myGlobalComp ()->setTempPar (
         theIdx, 
         stringParamVal (tempParName.myCstring ()));
      }
   }
d752 2
a753 2
   {
   WitParam * theParam;
d755 1
a755 1
   myMsgFac () ("nonDevParamHeadingMsg", fileName ());
d757 2
a758 2
   forEachEl (theParam, allNonDevParams_)
      theParam->print ();
d760 3
a762 3
   if (DEVELOPMENT)
      {
      myMsgFac () ("devParamHeadingMsg");
d764 3
a766 3
      forEachEl (theParam, allDevParams_)
         theParam->print ();
      }
d768 2
a769 2
   myMsgFac () ("blankMsg");
   }
d774 2
a775 2
   {
   theString.resize (100);
d777 2
a778 2
   sprintf (theString.myCstringForUpdate (), "tempPar%d", theIdx);
   }
d783 2
a784 2
   {
   theString.resize (100);
d786 5
a790 5
   sprintf (
      theString.myCstringForUpdate (),
      "Temporary development parameter #%d",
      theIdx);
   }
@


1.234
log
@CPLEX Parameters
@
text
@a342 5
      "selectCplex",
      "Select CPLEX as the solver?",
      false);

   buildBoolParam (
a452 12
   buildIntParam (
      "acc-method",
      "Solve method for acc mode with COIN?",
      0, 3,
      myOptComp ()->accMethod ());

   buildIntParam (
      "coin-log-level",
      "Log level for COIN messages",
      0, 4,
      myOptComp ()->coinLogLevel ());

a715 2
   myOptComp    ()->setAccMethod       (intParamVal  ("acc-method"));
   myOptComp    ()->setCoinLogLevel    (intParamVal  ("coin-log-level"));
a738 3
   if (boolParamVal ("selectCplex"))
      myOptComp ()->setCplexSelected (true);

@


1.233
log
@CPLEX Parameters
@
text
@a376 7
   buildIntParam (
      "cpxSimDisplay",
      "CPLEX parameter CPX_PARAM_SIMDISPLAY",
      0,
      2,
      myOptComp ()->cpxSimDisplay ());

a732 1
   myOptComp    ()->setCpxSimDisplay   (intParamVal  ("cpxSimDisplay"));
@


1.232
log
@CPX Param Specs
@
text
@a383 5
   buildBoolParam (
      "allowCpxParSpec",
      "Allow CPLEX parameter specification?",
      myOptComp ()->allowCpxParSpec ());

a740 1
   myOptComp    ()->setAllowCpxParSpec (boolParamVal ("allowCpxParSpec"));
@


1.231
log
@CPX Params
@
text
@d385 3
a387 3
      "allowCpxParams",
      "Allow control of CPLEX parameters?",
      myOptComp ()->allowCpxParams ());
d746 1
a746 1
   myOptComp    ()->setAllowCpxParams  (boolParamVal ("allowCpxParams"));
@


1.230
log
@CPLEX
@
text
@d384 5
d746 1
@


1.229
log
@CPLEX
@
text
@a376 5
   buildBoolParam (
      "allowMultiCplex",
      "Allow multi-objective mode with CPLEX?",
      myOptComp ()->allowMultiCplex ());

a739 1
   myOptComp    ()->setAllowMultiCplex (boolParamVal ("allowMultiCplex"));
@


1.228
log
@CPLEX
@
text
@d377 5
d745 1
@


1.227
log
@CPLEX
@
text
@a383 5
   buildBoolParam (
      "allowMipCplex",
      "Allow MIP mode with CPLEX selected?",
      myOptComp ()->allowMipCplex ());

a740 1
   myOptComp    ()->setAllowMipCplex   (boolParamVal ("allowMipCplex"));
@


1.226
log
@CPLEX
@
text
@d384 5
d746 1
@


1.225
log
@CPLEX
@
text
@d548 2
a549 1
   const char * theCstring;
d551 1
a551 1
   WitChoiceParam * const theParam =
d554 1
a554 1
         "Method for initiallizing opt implosion");
d556 1
a556 1
   WitOptStarter * theOptStarter;
d559 1
a559 1
      theParam->addChoice (theOptStarter->paramValue ().myCstring ());
d561 1
a561 8
   theCstring = 
      myProblem ()->
         myCompMgr ()->
            myOptComp ()->
               optInitMethod ()->
                  paramValue ().myCstring ();

   theParam->choose (theCstring);
d729 14
a742 23
   WitOptStarter * theOptStarter;
   double          splitTol;
   double          splitRes;
   int             theIdx;
   WitString       tempParName;

   myOptComp ()->setPrintOptProblem (boolParamVal   ("printOptProblem"));
   myOptComp ()->setPrintMatByCols  (boolParamVal   ("printMatByCols"));
   myOptComp ()->setPrintInitSoln   (boolParamVal   ("printInitSoln"));
   myOptComp ()->setPrintOptSoln    (boolParamVal   ("printOptSoln"));
   myOptComp ()->setPrintMps        (boolParamVal   ("printMps"));
   myOptComp ()->setSkipScreening   (boolParamVal   ("skipScreening"));
   myOptComp ()->setCpxSimDisplay   (intParamVal    ("cpxSimDisplay"));

   myOptComp ()->setAccMethod       (intParamVal    ("acc-method"));
   myOptComp ()->setCoinLogLevel    (intParamVal    ("coin-log-level"));

   theOptStarter =
      myOptComp ()->allOptStarters ().find (
         & WitOptStarter::paramValue,
           choiceParamVal ("optInitMethod").myCstring ());

   theOptStarter->beChosen ();
@


1.224
log
@CPLEX
@
text
@d535 2
a536 6

   if (solverEmbedded ())
      theParam->addChoice ("opt");

   if (solverEmbedded ())
      theParam->addChoice ("stoch");
d541 1
a541 1
   theParam->choose (solverEmbedded ()? "opt": "heur");
d782 1
a782 1
      myOptComp ()->setCplexSelectedTrue ();
@


1.223
log
@CPLEX
@
text
@d343 2
a344 2
      "solverIsCplex",
      "Use CPLEX as the solver?",
d785 2
a786 2
   if (boolParamVal ("solverIsCplex"))
      myOptComp ()->setSolverIsCplexTrue ();
@


1.222
log
@pause/resume
@
text
@a342 5
      "cplexAllowed",
      "Allow opt/stoch implosion with CPLEX?",
      myOptComp ()->cplexAllowed ());

   buildBoolParam (
a744 1
   myOptComp ()->setCplexAllowed    (boolParamVal   ("cplexAllowed"));
@


1.221
log
@CPLEX
@
text
@d488 1
a488 1
      "pauses",
d490 1
a490 1
      myGlobalComp ()->pauses ());
d774 1
a774 1
   myGlobalComp ()->setPauses          (boolParamVal ("pauses"));
@


1.220
log
@CPLEX
@
text
@d348 5
d791 3
@


1.219
log
@CPLEX
@
text
@d377 7
d752 1
@


1.218
log
@Selection Recovery.
@
text
@d348 3
a350 3
      "printOptModel",
      "Print the optimization model?",
      myOptComp ()->printOptModel ());
d738 7
a744 7
   myOptComp ()->setCplexAllowed   (boolParamVal   ("cplexAllowed"));
   myOptComp ()->setPrintOptModel  (boolParamVal   ("printOptModel"));
   myOptComp ()->setPrintMatByCols (boolParamVal   ("printMatByCols"));
   myOptComp ()->setPrintInitSoln  (boolParamVal   ("printInitSoln"));
   myOptComp ()->setPrintOptSoln   (boolParamVal   ("printOptSoln"));
   myOptComp ()->setPrintMps       (boolParamVal   ("printMps"));
   myOptComp ()->setSkipScreening  (boolParamVal   ("skipScreening"));
d746 2
a747 2
   myOptComp ()->setAccMethod      (intParamVal    ("acc-method"));
   myOptComp ()->setCoinLogLevel   (intParamVal    ("coin-log-level"));
@


1.217
log
@Name change: "selection reuse" has becomne "selection recovery".
@
text
@a495 5
      "newSelRec",
      "Use new aspects of selection recovery?",
      myGlobalComp ()->newSelRec ());

   buildBoolParam (
a764 1
   myGlobalComp ()->setNewSelRec       (boolParamVal ("newSelRec"));
@


1.216
log
@Removed sizeof test.
Added explicit implementation of WitVector <char>.
@
text
@d496 3
a498 3
      "newSelReuse",
      "Perform new aspects of selection reuse?",
      myGlobalComp ()->newSelReuse ());
d770 1
a770 1
   myGlobalComp ()->setNewSelReuse     (boolParamVal ("newSelReuse"));
@


1.215
log
@size test
@
text
@a713 16

   if (stringParamVal ("critical_ofname") == "sizeof")
      {
      fprintf (myGlobalComp ()->msgFile (),
         "\n"
         "sizeof (char):         %d\n"
         "sizeof (bool):         %d\n"
         "sizeof (int):          %d\n"
         "sizeof (double):       %d\n"
         "sizeof (const char *): %d\n\n",
          sizeof (char),
          sizeof (bool),
          sizeof (int),
          sizeof (double),
          sizeof (const char *));
      }
@


1.214
log
@Temporary size print.
@
text
@d714 16
a807 16

   if (myGlobalComp ()->tempParIsSet (1))
      {
      fprintf (myGlobalComp ()->msgFile (),
         "\n"
         "sizeof (char):         %d\n"
         "sizeof (bool):         %d\n"
         "sizeof (int):          %d\n"
         "sizeof (double):       %d\n"
         "sizeof (const char *): %d\n\n",
          sizeof (char),
          sizeof (bool),
          sizeof (int),
          sizeof (double),
          sizeof (const char *));
      }
@


1.213
log
@Selection reuse.
@
text
@d792 16
@


1.212
log
@Selection Reuse.
@
text
@d496 5
d770 1
@


1.211
log
@Lead Time Bounds
@
text
@a399 5
      "selReuseAllowed",
      "Selection reuse allowed?",
      myGlobalComp ()->selReuseAllowed ());

   buildBoolParam (
a755 1
   myGlobalComp ()->setSelReuseAllowed (boolParamVal ("selReuseAllowed"));
@


1.210
log
@Lead Time Bounds.
@
text
@a404 5
      "ltbAllowed",
      "Lead time bounds allowed?",
      myGlobalComp ()->ltbAllowed ());

   buildBoolParam (
a761 1
   myGlobalComp ()->setLtbAllowed      (boolParamVal ("ltbAllowed"));
@


1.209
log
@Bounded Lead Times
@
text
@d405 3
a407 3
      "bltAllowed",
      "Bounded lead times allowed?",
      myGlobalComp ()->bltAllowed ());
d767 1
a767 1
   myGlobalComp ()->setBltAllowed      (boolParamVal ("bltAllowed"));
@


1.208
log
@Changed a development parameter.
@
text
@d405 5
d767 1
@


1.207
log
@Production Horizons.
@
text
@d400 3
a402 3
      "horizonsAllowed",
      "Allow production horizons?",
      myGlobalComp ()->horizonsAllowed ());
d761 1
a761 1
   myGlobalComp ()->setHorizonsAllowed (boolParamVal ("horizonsAllowed"));
@


1.206
log
@CPLEX
@
text
@d400 5
d761 11
a771 11
   myGlobalComp ()->setReadDataMsgs   (boolParamVal   ("readDataMsgs"));
   myGlobalComp ()->setPrintIncAlloc  (boolParamVal   ("prtIncAlloc"));
   myGlobalComp ()->setPrintEqAlloc   (boolParamVal   ("printEqAlloc"));
   myGlobalComp ()->setSelPrintLevel  (intParamVal    ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand   (boolParamVal   ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB     (intParamVal    ("splitItrUB"));
   myGlobalComp ()->setPauses         (boolParamVal   ("pauses"));
   myGlobalComp ()->setPrtPipMaxRatio (boolParamVal   ("prtPipMaxRatio"));
   myGlobalComp ()->setPrintDebug     (boolParamVal   ("printDebug"));
   myGlobalComp ()->setPrintExcessVol (boolParamVal   ("printExcessVol"));
   myGlobalComp ()->setNewPipPggOrder (boolParamVal   ("newPipPggOrder"));
@


1.205
log
@CPLEX
@
text
@d529 1
a529 1
   if (WitOptComp::solverEmbedded ())
d532 1
a532 1
   if (WitOptComp::solverEmbedded ())
d538 1
a538 1
   theParam->choose (WitOptComp::solverEmbedded ()? "opt": "heur");
@


1.204
log
@Preparing for embedded CPLEX.
@
text
@d343 5
d738 1
@


1.203
log
@Revising the build procedure.
@
text
@d524 1
a524 1
   if (SOLVER_EMBEDDED)
d527 1
a527 1
   if (SOLVER_EMBEDDED)
d533 1
a533 1
   theParam->choose (SOLVER_EMBEDDED? "opt": "heur");
@


1.202
log
@Revising the build procedure.
@
text
@d524 1
a524 1
   if (COIN_EMBEDDED)
d527 1
a527 1
   if (COIN_EMBEDDED)
d533 1
a533 1
   theParam->choose (COIN_EMBEDDED? "opt": "heur");
@


1.201
log
@Revising the build process.
@
text
@d524 1
a524 1
   if (WIT_EMBEDS_COIN)
d527 1
a527 1
   if (WIT_EMBEDS_COIN)
d533 1
a533 1
   theParam->choose (WIT_EMBEDS_COIN? "opt": "heur");
@


1.200
log
@Multi-Obj Mode
@
text
@d524 1
a524 1
   if (WitOptComp::optImpAllowed ())
d527 1
a527 1
   if (WitOptComp::optImpAllowed ())
d533 1
a533 1
   theParam->choose (WitOptComp::optImpAllowed ()? "opt": "heur");
@


1.199
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@a494 6
   buildDoubleParam (
      "multiObjTol",
      "Multi-objective optimality tolerance",
      0.0,
      myOptComp ()->multiObjTol ());

a742 2
   myOptComp ()->setMultiObjTol    (doubleParamVal ("multiObjTol"));

@


1.198
log
@Multi-Obj Mode
@
text
@d20 1
a20 1
#include <Global.h>
@


1.197
log
@Multi-Obj Mode
@
text
@d499 1
a499 1
      0.0);
@


1.196
log
@Multi-Obj Mode
@
text
@d495 6
d739 9
a747 6
   myOptComp ()->setPrintOptModel  (boolParamVal ("printOptModel"));
   myOptComp ()->setPrintMatByCols (boolParamVal ("printMatByCols"));
   myOptComp ()->setPrintInitSoln  (boolParamVal ("printInitSoln"));
   myOptComp ()->setPrintOptSoln   (boolParamVal ("printOptSoln"));
   myOptComp ()->setPrintMps       (boolParamVal ("printMps"));
   myOptComp ()->setSkipScreening  (boolParamVal ("skipScreening"));
d749 1
a749 2
   myOptComp ()->setAccMethod      (intParamVal  ("acc-method"));
   myOptComp ()->setCoinLogLevel   (intParamVal  ("coin-log-level"));
@


1.195
log
@Multi-Obj Mode
@
text
@d441 1
a441 1
   buildStringParam (
d444 2
a445 1
      "1.0");
d728 1
a760 1
   myGlobalComp ()->setSplitTol       (doubleParamVal ("splitTol"));
d762 2
a763 1
   splitRes = 0.0;
d765 1
a765 6
   sscanf (stringParamVal ("splitRes").myCstring (), "%lf", & splitRes);

   if (splitRes < .0000009)
      myMsgFac () ("genericSmsg", "Invalid splitRes control paramater.");

   if (myGlobalComp ()->splitTol () < splitRes)
d768 1
@


1.194
log
@Added display of constraint violations > FEAS_TOL.
@
text
@d82 1
d139 3
a141 1
   WitStringParam * const theStringParam =
d153 3
a155 2
   WitIntParam * const theIntParam =
      allIntParams_.find (& WitIntParam::itsName, paramName);
d164 14
d180 3
a182 1
   WitChoiceParam * const theChoiceParam =
d435 1
a435 1
   buildStringParam (
d438 2
a439 1
      "1.0");
d582 13
a594 7
      new WitIntParam (
         theName,
         theText,
         theLB,
         theUB,
         initValue,
         this));
d665 1
a665 1
         myMsgFac () ("paramReadErrorInvalidParm", fileName (), paramName);
a726 1
   double          splitTol;
d748 12
a759 21
   myGlobalComp ()->setReadDataMsgs   (boolParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintIncAlloc  (boolParamVal ("prtIncAlloc"));
   myGlobalComp ()->setPrintEqAlloc   (boolParamVal ("printEqAlloc"));
   myGlobalComp ()->setSelPrintLevel  (intParamVal  ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand   (boolParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB     (intParamVal  ("splitItrUB"));
   myGlobalComp ()->setPauses         (boolParamVal ("pauses"));
   myGlobalComp ()->setPrtPipMaxRatio (boolParamVal ("prtPipMaxRatio"));
   myGlobalComp ()->setPrintDebug     (boolParamVal ("printDebug"));
   myGlobalComp ()->setPrintExcessVol (boolParamVal ("printExcessVol"));
   myGlobalComp ()->setNewPipPggOrder (boolParamVal ("newPipPggOrder"));

   splitTol = 0.0;

   sscanf (stringParamVal ("splitTol").myCstring (), "%lf", & splitTol);

   if (splitTol < .0000009)
      myMsgFac () ("genericSmsg", "Invalid splitTol control paramater.");

   myGlobalComp ()->setSplitTol (splitTol);

d768 1
a768 1
   if (splitTol < splitRes)
@


1.193
log
@Multi-objective mode
@
text
@a383 5
   buildBoolParam (
      "reportIncViol",
      "Report increases to maxViolation?",
      myGlobalComp ()->reportIncViol ());

a724 1
   myGlobalComp ()->setReportIncViol  (boolParamVal ("reportIncViol"));
@


1.192
log
@Multi-obj mode.
@
text
@a448 5
      "allowMultiObj",
      "Allow multiple objectives mode?",
      myOptComp ()->allowMultiObj ());

   buildBoolParam (
a718 1
   myOptComp ()->setAllowMultiObj  (boolParamVal ("allowMultiObj"));
@


1.191
log
@Fixed bug: Printing of incHeurAlloc data is no longer controlled by the
           timesPrint mesg attribute.
@
text
@d449 5
d724 1
@


1.190
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@d728 1
a739 3
   if (boolParamVal ("prtIncAlloc"))
      myMsgFac ().setMaxTimesIssued ("incAllocMsg", -1);

@


1.189
log
@Stochastic Implosion
@
text
@d27 2
@


1.188
log
@Stochastic Implosion
@
text
@a475 5
   buildBoolParam (
      "allowStageByPer",
      "Allow stage-by-period mode?",
      myProblem ()->myStochImpMgr ()->allowStageByPer ());

a736 4
   myProblem ()->
      myStochImpMgr ()->
         setAllowStageByPer (boolParamVal ("allowStageByPer"));

@


1.187
log
@Stochastic Implosion
@
text
@d321 3
a323 3
      "printOptProb",
      "Print the optimization problem?",
      myOptComp ()->printOptProb ());
d713 1
a713 1
   myOptComp ()->setPrintOptProb   (boolParamVal ("printOptProb"));
@


1.186
log
@Stochastic Implosion
@
text
@d23 1
d476 5
d742 4
@


1.185
log
@Stochastic Implosion
@
text
@a22 1
#include <StochImpMgr.h>
a474 5
   buildBoolParam (
      "stochImpAllowed",
      "Allow stochastic implosion?",
      myProblem ()->myStochImpMgr ()->stochImpAllowed ());

a735 4
   myProblem ()->
      myStochImpMgr ()->
         setStochImpAllowed (boolParamVal ("stochImpAllowed"));

@


1.184
log
@ASAP Pegging Order.
@
text
@a480 5
   buildBoolParam (
      "singleStochLP",
      "Use a single LP for stoch implosion?",
      myProblem ()->myStochImpMgr ()->singleStochLP ());

a745 4
   myProblem ()->
      myStochImpMgr ()->
         setSingleStochLP (boolParamVal ("singleStochLP"));

@


1.183
log
@ASAP pegging order
@
text
@a485 5
   buildBoolParam (
      "allowAsapPip",
      "Allow PIP with ASAP pegging order?",
      myGlobalComp ()->allowAsapPip ());

a745 1
   myGlobalComp ()->setAllowAsapPip   (boolParamVal ("allowAsapPip"));
@


1.182
log
@ASAP Pegging Order
@
text
@d486 5
d642 1
a642 1
   for (;;)
d751 1
@


1.181
log
@ASAP Pegging Order
@
text
@a471 5
      "useNewMatPgg",
      "Use the new material pegging algorithm?",
      myGlobalComp ()->useNewMatPgg ());

   buildBoolParam (
a744 1
   myGlobalComp ()->setUseNewMatPgg   (boolParamVal ("useNewMatPgg"));
@


1.180
log
@Stochastic Implosion
@
text
@d472 5
d750 1
@


1.179
log
@Stochastic Implosion.
@
text
@d481 5
d751 4
@


1.178
log
@Stochastic Implosion
@
text
@a480 5
   buildBoolParam (
      "sglStochLP",
      "Single stochastic LP problem?",
      false);

@


1.177
log
@Stochastic Implosion
@
text
@d481 5
@


1.176
log
@Stochastic Implosion
@
text
@a476 5
      "printAttData",
      "Print attribute data?",
      false);

   buildBoolParam (
@


1.175
log
@Stochastic Implosion
@
text
@d477 5
@


1.174
log
@Stochastic Implosion
@
text
@d476 5
d513 2
a514 3
   if (DEVELOPMENT)
      if (WitOptComp::optImpAllowed ())
         theParam->addChoice ("stoch");
d742 3
a744 2
   if (choiceParamVal ("action") == "stoch")
      myProblem ()->myStochImpMgr ()->setStochImpAllowed (true);
@


1.173
log
@Stochastic Implosion
@
text
@d23 1
a23 1
#include <StochMgr.h>
d739 1
a739 1
      myProblem ()->myStochMgr ()->setStochImpAllowed (true);
@


1.172
log
@Stochastic implosion.
@
text
@a475 5
   buildBoolParam (
      "stochImpAllowed",
      "Allow stochastic implosion?",
      myProblem ()->myStochMgr ()->stochImpAllowed ());

d509 4
d738 2
a739 3
   myProblem ()->
      myStochMgr ()->
         setStochImpAllowed (boolParamVal ("stochImpAllowed"));
a765 1

@


1.171
log
@[disallowed scrap]
@
text
@d23 1
d476 5
d739 4
@


1.170
log
@[disallowing scrap]
@
text
@a470 5
      "allowSA",
      "allow scrapAllowed?",
      myGlobalComp ()->allowSA ());

   buildBoolParam (
a730 1
   myGlobalComp ()->setAllowSA        (boolParamVal ("allowSA"));
@


1.169
log
@[disallowed backlog]
@
text
@d471 5
d736 1
@


1.168
log
@[disallowed backlog]
@
text
@a470 5
      "allowDBL",
      "Allow disallowBackLog?",
      myGlobalComp ()->allowDBL ());

   buildBoolParam (
a730 1
   myGlobalComp ()->setAllowDBL       (boolParamVal ("allowDBL"));
@


1.167
log
@[backlog avoidance]
@
text
@d471 3
a473 3
      "allowBLA",
      "Allow backLogAllowed?",
      myGlobalComp ()->allowBLA ());
d736 1
a736 1
   myGlobalComp ()->setAllowBLA       (boolParamVal ("allowBLA"));
@


1.166
log
@App controlled opt implosion.
@
text
@d471 5
d736 1
@


1.165
log
@App controlled opt implosion.
@
text
@d504 1
a504 1
   if (OPT_IMP_MODE)
d510 1
a510 1
   theParam->choose (OPT_IMP_MODE? "opt": "heur");
@


1.164
log
@App controlled opt implosion.
@
text
@a21 1
#include <OptImp.h>
a59 7
inline WitOptImploder * WitParamMgr::myOptImploder ()
   {
   return myProblem ()->myOptImploder ();
   }

//------------------------------------------------------------------------------

d341 1
a341 1
      "Print an MPS file of the model?",
d344 5
d709 1
@


1.163
log
@App controlled opt implosion.
@
text
@d330 1
a330 1
      myOptImploder ()->printOptProb ());
d335 1
a335 1
      myOptImploder ()->printMatByCols ());
d340 1
a340 1
      myOptImploder ()->printInitSoln ());
d345 1
a345 1
      myOptImploder ()->printOptSoln ());
d350 1
a350 1
      myOptImploder ()->printMps ());
d707 5
a711 5
   myOptImploder ()->setPrintOptProb   (boolParamVal ("printOptProb"));
   myOptImploder ()->setPrintMatByCols (boolParamVal ("printMatByCols"));
   myOptImploder ()->setPrintInitSoln  (boolParamVal ("printInitSoln"));
   myOptImploder ()->setPrintOptSoln   (boolParamVal ("printOptSoln"));
   myOptImploder ()->setPrintMps       (boolParamVal ("printMps"));
d713 2
a714 2
   myOptComp ()->setAccMethod    (intParamVal  ("acc-method"));
   myOptComp ()->setCoinLogLevel (intParamVal  ("coin-log-level"));
@


1.162
log
@NSTN residual.
@
text
@a468 5
      "allowIntVars",
      "Allow integer variables?",
      myGlobalComp ()->allowIntVars ());

   buildBoolParam (
a731 1
   myGlobalComp ()->setAllowIntVars   (boolParamVal ("allowIntVars"));
@


1.161
log
@NSTN residualVol.
@
text
@a473 5
      "allowNstnRes",
      "Allow NSTN residualVol?",
      myGlobalComp ()->allowNstnRes ());

   buildBoolParam (
a737 1
   myGlobalComp ()->setAllowNstnRes   (boolParamVal ("allowNstnRes"));
@


1.160
log
@NSTN residualVols.
@
text
@d479 5
d744 1
@


1.159
log
@App controlled opt implode.
@
text
@d474 5
d738 1
@


1.158
log
@App controlled opt implosion.
@
text
@d507 1
a507 1
   if (myOptImploder ()->optImpMode ())
d513 1
a513 1
   theParam->choose (myOptImploder ()->optImpMode ()? "opt": "heur");
@


1.157
log
@Integrality constraints.
@
text
@d328 3
a330 3
      "printOptModel",
      "Print the opt model?",
      myOptImploder ()->printOptModel ());
d707 1
a707 1
   myOptImploder ()->setPrintOptModel  (boolParamVal ("printOptModel"));
@


1.156
log
@Opt implosion with integrality constraints.
@
text
@a351 6
   buildIntParam (
      "stopOpt",
      "When to stop optimization",
      0, 2,
      myOptImploder ()->stopOpt ());

a715 9
   if (   intParamVal ("stopOpt")    != 0)
      if (intParamVal ("n_critical") != 0)
         myMsgFac () ("paramReadErrorConflict",
            fileName (),
            "stopOpt", "!= 0",
            "n_critical", "!= 0");

   myOptImploder ()->setStopOpt (intParamVal("stopOpt"));

@


1.155
log
@GPIP migration.
@
text
@d475 5
d747 1
@


1.154
log
@GPIP migration.
@
text
@d465 3
a467 3
      "prtGpipMaxRatio",
      "Print Group PIP max ratio data?",
      myGlobalComp ()->prtGpipMaxRatio ());
d733 10
a742 10
   myGlobalComp ()->setReadDataMsgs    (boolParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc    (boolParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol   (boolParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel   (intParamVal  ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand    (boolParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB      (intParamVal  ("splitItrUB"));
   myGlobalComp ()->setPauses          (boolParamVal ("pauses"));
   myGlobalComp ()->setPrtGpipMaxRatio (boolParamVal ("prtGpipMaxRatio"));
   myGlobalComp ()->setPrintDebug      (boolParamVal ("printDebug"));
   myGlobalComp ()->setNewPipPggOrder  (boolParamVal ("newPipPggOrder"));
@


1.153
log
@Changed the default value of groupPipMode to true.
@
text
@a464 5
      "groupPipMode",
      "Override to Group PIP mode?",
      false);

   buildBoolParam (
@


1.152
log
@New PIP pegging order.
@
text
@d466 1
a466 1
      "Use Group Post-Implosion Pegging?",
a744 1
   myGlobalComp ()->setGroupPipMode    (boolParamVal ("groupPipMode"));
@


1.151
log
@New PIP pegging order.
@
text
@a483 5
   buildBoolParam (
      "allowGpipNpo",
      "Allow GPIP with the new pegging order?",
      myGlobalComp ()->allowGpipNpo ());

a748 1
   myGlobalComp ()->setAllowGpipNpo    (boolParamVal ("allowGpipNpo"));
@


1.150
log
@New PIP pegging order.
@
text
@d484 5
d754 1
@


1.149
log
@New PIP pegging order.
@
text
@d480 3
a482 3
      "allowNewPipOrd",
      "Allow new PIP pegging order?",
      false);
d748 1
a748 1
   myGlobalComp ()->setAllowNewPipOrd  (boolParamVal ("allowNewPipOrd"));
@


1.148
log
@New PIP pegging order.
@
text
@d475 3
a477 3
      "printGpip",
      "Print Group PIP?",
      myGlobalComp ()->printGpip ());
d747 1
a747 1
   myGlobalComp ()->setPrintGpip       (boolParamVal ("printGpip"));
@


1.147
log
@Updated the copyright date on all source files.
@
text
@d479 5
d748 1
@


1.146
log
@Removed some more OSL items.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.145
log
@Removed access to the oslMesgFileName attribute.
@
text
@d333 3
a335 3
      "printOslVecs",
      "Print vectors that get passed to OSL?",
      myOptImploder ()->printOslVecs ());
a352 6
      "printMask",
      "Have OSL print soln and use this mask?",
      0, 1023,
      myOptImploder ()->printMask ());

   buildIntParam (
d708 5
a712 6
   myOptImploder ()->setPrintOptModel (boolParamVal ("printOptModel"));
   myOptImploder ()->setPrintOslVecs  (boolParamVal ("printOslVecs"));
   myOptImploder ()->setPrintInitSoln (boolParamVal ("printInitSoln"));
   myOptImploder ()->setPrintOptSoln  (boolParamVal ("printOptSoln"));
   myOptImploder ()->setPrintMps      (boolParamVal ("printMps"));
   myOptImploder ()->setPrintMask     (intParamVal  ("printMask"));
@


1.144
log
@Modified code for OSL and COIN log file names.
@
text
@a224 5
      "osl_ofname",
      "(No longer meaningful)",
      myOptComp ()->oslMesgFileName ().myCstring ());

   buildStringParam (
a675 3
      witSetOslMesgFileName (stringParamVal ("osl_ofname").myCstring ());

   myWitRun_->
@


1.143
log
@GPIP
@
text
@d226 1
a226 1
      "Name of OSL log output file",
d230 5
d683 3
@


1.142
log
@GPIP
@
text
@d471 5
d747 1
@


1.141
log
@GPIP
@
text
@a470 5
      "allowGpipMode",
      "Allow Group PIP Mode?",
      myGlobalComp ()->allowGpipMode ());

   buildBoolParam (
a741 1
   myGlobalComp ()->setAllowGpipMode   (boolParamVal ("allowGpipMode"));
a744 3
   if (boolParamVal ("allowGpipMode"))
      myGlobalComp ()->setGroupPipMode (true);

@


1.140
log
@GPIP
@
text
@d476 5
d740 10
a749 9
   myGlobalComp ()->setReadDataMsgs  (boolParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc  (boolParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol (boolParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel (intParamVal  ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand  (boolParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB    (intParamVal  ("splitItrUB"));
   myGlobalComp ()->setPauses        (boolParamVal ("pauses"));
   myGlobalComp ()->setAllowGpipMode (boolParamVal ("allowGpipMode"));
   myGlobalComp ()->setPrintGpip     (boolParamVal ("printGpip"));
@


1.139
log
@GPIP
@
text
@d745 3
@


1.138
log
@[shared-resource pegging]
@
text
@d471 3
a473 3
      "allowSrpMode",
      "Allow Shared-Resource Pegging Mode?",
      myGlobalComp ()->allowSrpMode ());
d476 3
a478 3
      "printSrpDB",
      "Print SRP debugging data?",
      myGlobalComp ()->printSrpDB ());
d742 2
a743 2
   myGlobalComp ()->setAllowSrpMode  (boolParamVal ("allowSrpMode"));
   myGlobalComp ()->setPrintSrpDB    (boolParamVal ("printSrpDB"));
@


1.137
log
@[shared-resource pegging]
@
text
@a479 5
   buildBoolParam (
      "newPip",
      "Use new PIP classes?",
      myGlobalComp ()->newPip ());

a743 1
   myGlobalComp ()->setNewPip        (boolParamVal ("newPip"));
@


1.136
log
@[shared-resource pegging]
@
text
@d480 5
d749 1
@


1.135
log
@Began [shared-resource pegging]
@
text
@d475 5
d743 1
@


1.134
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d470 5
d737 1
@


1.133
log
@[multi-thread]
@
text
@d615 2
a616 1
   paramFile = myWitRun_->mySession ()->openFile (fileName (), "r");
@


1.132
log
@[multi-thread]
@
text
@a767 2

   witAssert (not myGlobalComp ()->tempParIsSet (1));
@


1.131
log
@[multi-thread]
@
text
@d768 2
@


1.130
log
@[multi-thread]
@
text
@d615 1
a615 1
   paramFile = openFile (fileName (), "r");
@


1.129
log
@[multi-thread]
@
text
@d47 1
a47 1
inline WitRun * WitParamMgr::myWitRun ()
d49 1
a49 1
   return mySaeMgr_->myWitRun ();
d54 1
a54 1
inline WitGlobalComp * WitParamMgr::myGlobalComp ()
d56 1
a56 1
   return mySaeMgr_->myCompMgr ()->myGlobalComp ();
d61 1
a61 1
inline WitOptComp * WitParamMgr::myOptComp ()
d63 1
a63 1
   return mySaeMgr_->myCompMgr ()->myOptComp ();
d68 1
a68 1
inline WitOptImploder * WitParamMgr::myOptImploder ()
d70 1
a70 1
   return mySaeMgr_->myOptImploder ();
d75 1
a75 1
WitParamMgr::WitParamMgr (WitSaeMgr * theSaeMgr, int argc, char * argv[]):
d77 2
a78 2
      mySaeMgr_         (theSaeMgr),
      myMsgFac_         (theSaeMgr->myMsgFac ()),
d512 2
d524 8
a531 3
   theParam->choose (
      mySaeMgr_->myCompMgr ()->myOptComp ()->optInitMethod ()->
         paramValue ().myCstring ());
d651 2
a652 3
   myWitRun ()->witSetMesgFileName (
      true, 
      stringParamVal ("log_ofname").myCstring ());
d654 1
a654 1
   myWitRun ()->mySession ()->printHeading ();
d659 2
a660 2
   myWitRun ()->witSetOslMesgFileName (
      stringParamVal ("osl_ofname").myCstring ());
d662 1
a662 1
   myWitRun ()->witSetAutoPriority (boolParamVal ("auto_pri"));
d664 1
a664 1
   myWitRun ()->witSetComputeCriticalList (intParamVal ("n_critical") != 0);
d666 1
a666 1
   myWitRun ()->witSetEquitability (intParamVal ("equitability"));
d668 1
a668 1
   myWitRun ()->witSetOutputPrecision (intParamVal("outputPrecision"));
@


1.128
log
@[multi-thread]
@
text
@d18 1
a18 1
#include <AloneRun.h>
d49 1
a49 1
   return myAloneRun ()->myWitRun ();
d56 1
a56 1
   return myAloneRun ()->myCompMgr ()->myGlobalComp ();
d63 1
a63 1
   return myAloneRun ()->myCompMgr ()->myOptComp ();
d70 1
a70 1
   return myAloneRun ()->myOptImploder ();
d75 4
a78 3
WitParamMgr::WitParamMgr (WitAloneRun * theAloneRun, int argc, char * argv[]):
      myAloneRun_       (theAloneRun),
      myMsgFac_         (theAloneRun->myMsgFac ()),
d523 1
a523 1
      myAloneRun ()->myCompMgr ()->myOptComp ()->optInitMethod ()->
@


1.127
log
@[multi-thread]
@
text
@a365 15
      "resetBounds",
      "Set all bound sets to default state?",
      false);

   buildBoolParam (
      "reOpt",
      "Do a re-opt-implosion?",
      false);

   buildBoolParam (
      "doAction",
      "Perform action given by 'action'?",
      true);

   buildBoolParam (
a416 10
      "sparseFss",
      "Print FSS in a sparse format?",
      false);

   buildBoolParam (
      "fssFromInput",
      "Use input for FSS from input data?",
      false);

   buildBoolParam (
a421 15
      "purge",
      "Do a Component purge?",
      false);

   buildBoolParam (
      "copy",
      "Test data copying?",
      false);

   buildBoolParam (
      "clearLS",
      "Clear lot sizes?",
      false);

   buildBoolParam (
a426 5
      "allNstn",
      "Use NSTN build-ahead for all non-ASAPs?",
      false);

   buildBoolParam (
a430 5
   buildBoolParam (
      "selSplitAll",
      "Set all sel-split bools to true?",
      false);

@


1.126
log
@[multi-thread]
@
text
@a810 3

   if (myGlobalComp ()->tempParIsSet (1))
      myWitRun ()->witExhaustMemory ();
@


1.125
log
@[multi-thread]
@
text
@a811 2
#if 0

a813 2

#endif
@


1.124
log
@Cut-over to the new interpretation of pipShare.
@
text
@d811 7
@


1.123
log
@Began work on the new interpretation of pipShare.
@
text
@a518 5
   buildBoolParam (
      "newPipShare",
      "Use new pipShare interpretation?",
      myGlobalComp ()->newPipShare ());

a773 1
   myGlobalComp ()->setNewPipShare   (boolParamVal ("newPipShare"));
@


1.122
log
@Made opt implosion use COIN unconditionally when COIN_BUILD is defined.
@
text
@d519 5
d779 1
@


1.121
log
@Vector PropRtg.
@
text
@a496 5
   buildBoolParam (
      "opt-with-coin",
      "Solve the optimization model with COIN?",
      false);

a747 1
   myOptComp ()->setSolverIsCoin (boolParamVal ("opt-with-coin"));
@


1.120
log
@Vector PropRtg.
@
text
@a523 5
   buildBoolParam (
      "allowVecPR",
      "Allow use of vector propRtg attribute?",
      myGlobalComp ()->allowVecPR ());

a779 1
   myGlobalComp ()->setAllowVecPR    (boolParamVal ("allowVecPR"));
@


1.119
log
@Vector propRt.
@
text
@d526 1
a526 1
      "Allow use of vector propRt attribute?",
@


1.118
log
@Pegged Critical List.
@
text
@d524 5
d785 1
@


1.117
log
@Pegged Critical List.
@
text
@a523 5
   buildBoolParam (
      "allowPCL",
      "Allow pegged critical list?",
      myGlobalComp ()->allowPCL ());

a779 1
   myGlobalComp ()->setAllowPCL      (boolParamVal ("allowPCL"));
@


1.116
log
@Low-Pri Prop-Rt.
@
text
@d524 5
d785 1
@


1.115
log
@Low-Pri Prop-Rt.
@
text
@a523 5
   buildBoolParam (
      "allowLPPR",
      "Allow lowPriPropRt to be set?",
      myGlobalComp ()->allowLPPR ());

a779 1
   myGlobalComp ()->setAllowLPPR     (boolParamVal ("allowLPPR"));
@


1.114
log
@Low-Pri Prop-Rt.
@
text
@a528 5
   buildBoolParam (
      "newPropRt",
      "Use the new version of prop. routing?",
      myGlobalComp ()->newPropRt ());

a785 1
   myGlobalComp ()->setNewPropRt     (boolParamVal ("newPropRt"));
@


1.113
log
@Low-Pri Prop-Rt.
@
text
@d529 5
d791 1
@


1.112
log
@Continued implmentation of low priority proportionate routing.
@
text
@d525 1
a525 1
      "allowLowPriPR",
d527 1
a527 1
      myGlobalComp ()->allowLowPriPR ());
d785 1
a785 1
   myGlobalComp ()->setAllowLowPriPR (boolParamVal ("allowLowPriPR"));
@


1.111
log
@Continued implementation of pen-exec override of prop-rt.
@
text
@d525 3
a527 3
      "allowPeOverPr",
      "Allow penExecOverPropRt to be set?",
      myGlobalComp ()->allowPeOverPr ());
d785 1
a785 1
   myGlobalComp ()->setAllowPeOverPr (boolParamVal ("allowPeOverPr"));
@


1.110
log
@Began work on [propRouting as penExec tie-breaker].
@
text
@d525 1
a525 1
      "peOverPrAllowed",
d527 1
a527 1
      myGlobalComp ()->peOverPrAllowed ());
d778 8
a785 8
   myGlobalComp ()->setReadDataMsgs    (boolParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc    (boolParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol   (boolParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel   (intParamVal  ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand    (boolParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB      (intParamVal  ("splitItrUB"));
   myGlobalComp ()->setPauses          (boolParamVal ("pauses"));
   myGlobalComp ()->setPeOverPrAllowed (boolParamVal ("peOverPrAllowed"));
@


1.109
log
@Added "solverIsCoin" attribute.
@
text
@d524 5
d778 8
a785 7
   myGlobalComp ()->setReadDataMsgs  (boolParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc  (boolParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol (boolParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel (intParamVal  ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand  (boolParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB    (intParamVal  ("splitItrUB"));
   myGlobalComp ()->setPauses        (boolParamVal ("pauses"));
@


1.108
log
@PIP.
@
text
@d753 1
a753 1
   myOptComp ()->setOptWithCoin  (boolParamVal ("opt-with-coin"));
@


1.107
log
@PIP.
@
text
@a523 5
   buildBoolParam (
      "allowMultiPip",
      "Allow PIP with multiple outputs?",
      myGlobalComp ()->allowMultiPip ());

a779 1
   myGlobalComp ()->setAllowMultiPip (boolParamVal ("allowMultiPip"));
@


1.106
log
@PIP.
@
text
@d525 1
a525 1
      "allowMoPip",
d527 1
a527 1
      myGlobalComp ()->allowMoPip ());
d785 1
a785 1
   myGlobalComp ()->setAllowMoPip    (boolParamVal ("allowMoPip"));
@


1.105
log
@Double Precision.
@
text
@d524 5
d785 1
@


1.104
log
@Double Precision.
@
text
@d741 2
a742 2
   float           splitTol;
   float           splitRes;
d786 1
a786 1
   sscanf (stringParamVal ("splitTol").myCstring (), "%f", & splitTol);
d796 1
a796 1
   sscanf (stringParamVal ("splitRes").myCstring (), "%f", & splitRes);
@


1.103
log
@Double Precision.
@
text
@a24 1
#include <RealVec.h>
a109 2
   setDoubleMode     ();

a523 5
   buildBoolParam (
      "doubleMode",
      "Double precision mode?",
      WitRealVec::doubleMode ());

a691 14
   }

//------------------------------------------------------------------------------

void WitParamMgr::setDoubleMode ()
   {
   if (not boolParamVal ("doubleMode"))
      return;

   myWitRun ()->mySession ()->deactivate ();

   WitRealVec::setDoubleMode (true);

   myWitRun ()->mySession ()->activate ();
@


1.102
log
@Continued double precision.
@
text
@d25 1
d530 1
a530 1
      WitSession::doubleMode ());
d711 1
a711 1
   myWitRun ()->mySession ()->setDoubleMode (true);
@


1.101
log
@Continued double precision.
@
text
@d110 1
a110 1
   applyDoubleParam ();
d527 1
a527 1
      "double",
d529 1
a529 1
      WitSession::doublePrecision ());
d703 1
a703 1
void WitParamMgr::applyDoubleParam ()
d705 1
a705 1
   if (not boolParamVal ("double"))
d710 1
a710 1
   myWitRun ()->mySession ()->setDoublePrecision (true);
@


1.100
log
@Continued double precision.
@
text
@d529 1
a529 1
      myWitRun ()->mySession ()->doublePrecision ());
@


1.99
log
@Continued double precision.
@
text
@d13 1
a13 4
// Contains the implementation of the following classes:
//
//    ParamMgr.
//    Ticker.
a422 6
   buildIntParam (
      "tickDelta",
      "Delta for printing ticks",
      0, -1,
      WitTicker::tickDelta ());

a801 4
// myWitRun ()->mySession ()->setDoublePrecision (boolParamVal ("double"));

   WitTicker::setTickDelta           (intParamVal  ("tickDelta"));

a881 53

//------------------------------------------------------------------------------
// Implementation of class Ticker.
//------------------------------------------------------------------------------

WitTicker::WitTicker (const char * eventNameVal, WitProblem * theProblem):
      WitProbAssoc (theProblem),

      eventName_   (eventNameVal),
      nTicks_      (0),
      prtTick_     (tickDelta_)
   {
   }

//------------------------------------------------------------------------------

WitTicker::~WitTicker ()
   {
   }

//------------------------------------------------------------------------------

void WitTicker::setTickDelta (int theValue)
   {
   witAssert (theValue >= 0);

   tickDelta_ = theValue;
   }

//------------------------------------------------------------------------------

bool WitTicker::tick ()
   {
   if (tickDelta_ == 0)
      return false;

   nTicks_ ++;

   if (nTicks_ >= prtTick_)
      {
      prtTick_ += tickDelta_;

      printf ("# %-12s %d\n", eventName_, nTicks_);

      return true;
      }

   return false;
   }

//------------------------------------------------------------------------------

int WitTicker::tickDelta_ = 0;
@


1.98
log
@Began implementation of double precision.
@
text
@d113 2
d535 5
d712 14
d810 2
@


1.97
log
@Continued implementation of PIP.
@
text
@d528 5
d788 1
@


1.96
log
@Continued implementation of PIP.
@
text
@a527 6
   buildBoolParam (
      "testPipSeq",
      "Use the test PIP shipment sequence?",
      false);


@


1.95
log
@Continued implementation of PIP.
@
text
@a523 5
      "allowPipSeq",
      "Enable PIP ship sequence capability?",
      myGlobalComp ()->allowPipSeq ());

   buildBoolParam (
a788 1
   myGlobalComp ()->setAllowPipSeq   (boolParamVal ("allowPipSeq"));
@


1.94
log
@Continued implementation of PIP.
@
text
@a510 10
   buildBoolParam (
      "revPipSeq",
      "Reverse the PIP shipment sequence?",
      myGlobalComp ()->revPipSeq ());

   buildBoolParam (
      "allowShipSeq",
      "Enable PIP ship sequence capability?",
      myGlobalComp ()->allowShipSeq ());

d523 15
d794 1
a794 2
   myGlobalComp ()->setRevPipSeq     (boolParamVal ("revPipSeq"));
   myGlobalComp ()->setAllowShipSeq  (boolParamVal ("allowShipSeq"));
@


1.93
log
@Continued implementation of PIP.
@
text
@d516 5
d790 1
@


1.92
log
@Continued implementation of PIP.
@
text
@a515 5
   buildBoolParam (
      "allowSideEffs",
      "Allow unexplodable side-effects in PIP?",
      myGlobalComp ()->allowSideEffs ());

a784 1
   myGlobalComp ()->setAllowSideEffs (boolParamVal ("allowSideEffs"));
@


1.91
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d516 5
d790 1
@


1.90
log
@Continued implementation of post-implosion pegging.
@
text
@a511 5
      "allowPIP",
      "Allow post-implosion pegging?",
      myGlobalComp ()->allowPIP ());

   buildBoolParam (
a783 1
   myGlobalComp ()->setAllowPIP      (boolParamVal ("allowPIP"));
@


1.89
log
@Began implementation of post-implosion pegging.
@
text
@d516 5
d790 1
@


1.88
log
@Continued implementation of opt with COIN.
@
text
@d511 5
d784 1
@


1.87
log
@Continued implementation of opt with COIN.
@
text
@a231 5
      "solver_ofname",
      "Name of solver's log output file",
      myOptComp ()->solverLogFileName ().myCstring ());

   buildStringParam (
a708 3

   myWitRun ()->witSetSolverLogFileName (
      stringParamVal ("solver_ofname").myCstring ());
@


1.86
log
@Continued implementation of opt with COIN.
@
text
@d232 3
a234 3
      "coin_ofname",
      "Name of COIN log output file",
      myOptComp ()->coinLogFileName ().myCstring ());
d517 6
d715 2
a716 2
   myWitRun ()->witSetCoinLogFileName (
      stringParamVal ("coin_ofname").myCstring ());
d762 1
@


1.85
log
@Continued implementation of opt with COIN.
@
text
@d516 6
d755 2
a756 1
   myOptComp ()->setOptWithCoin (boolParamVal ("opt-with-coin"));
@


1.84
log
@Continued implementation of opt with COIN.
@
text
@d234 1
a234 1
      myOptComp ()->coinMesgFileName ().myCstring ());
d703 1
a703 1
   myWitRun ()->witSetCoinMesgFileName (
@


1.83
log
@Continued implementation of opt with COIN.
@
text
@d511 5
a515 1
   buildOptSolveMethodParam ();
a575 15
void WitParamMgr::buildOptSolveMethodParam ()
   {
   WitChoiceParam * theParam;

   theParam =
      buildChoiceParam ("optSolveMethod", "Method for solving opt implosion");

   theParam->addChoice ("osl-dir");
   theParam->addChoice ("clp-osi");

   theParam->choose    ("osl-dir");
   }

//------------------------------------------------------------------------------

d749 1
a749 9
   if      (choiceParamVal ("optSolveMethod") == "osl-dir")
      myOptComp ()->setMyOptSolveMethod (oslDirMethod);

   else if (choiceParamVal ("optSolveMethod") == "clp-osi")
      myOptComp ()->setMyOptSolveMethod (clpOsiMethod);

   else
      stronglyAssert (false);

@


1.82
log
@Continued implementation of opt with COIN.
@
text
@a579 1
   theParam->addChoice ("osl-osi");
a761 3

   else if (choiceParamVal ("optSolveMethod") == "osl-osi")
      myOptComp ()->setMyOptSolveMethod (oslOsiMethod);
@


1.81
log
@Continued implementation of opt with COIN.
@
text
@d232 5
d714 3
@


1.80
log
@Removed temporary control parameter undoc1.
@
text
@d576 1
a576 1
   theParam->addChoice ("clp");
d759 2
a760 2
   else if (choiceParamVal ("optSolveMethod") == "clp")
      myOptComp ()->setMyOptSolveMethod (clpMethod);
@


1.79
log
@Fixed a bug with the stopOpt parameter.
Fixed a timing bug.
@
text
@a310 5
   buildBoolParam (
      "undoc1",
      "Undocumented parameter",
      false);

a716 2

   myOptComp ()->setSkipPreSolve (boolParamVal ("undoc1"));
@


1.78
log
@Fixed range bug in control param "stopOpt".
@
text
@d368 1
a368 1
      0, 1,
@


1.77
log
@Added a temporary undocumented control parameter to turn off ekk_preSolve.
@
text
@d368 1
a368 1
      0, 2,
@


1.76
log
@Continued implementation of opt with COIN.
@
text
@d311 5
d722 2
@


1.75
log
@Continued implementation of opt with COIN.
@
text
@d574 2
a575 2
   theParam->addChoice ("dirOsl");
   theParam->addChoice ("osiOsl");
d578 1
a578 1
   theParam->choose    ("dirOsl");
d753 2
a754 2
   if      (choiceParamVal ("optSolveMethod") == "dirOsl")
      myOptComp ()->setMyOptSolveMethod (dirOslMethod);
d756 2
a757 2
   else if (choiceParamVal ("optSolveMethod") == "osiOsl")
      myOptComp ()->setMyOptSolveMethod (osiOslMethod);
@


1.74
log
@Continued implementation of opt with COIN.
@
text
@d506 1
a506 4
   buildBoolParam (
      "useCoin",
      "Use COIN solvers for opt implosion?",
      myGlobalComp ()->useCoin ());
d567 16
d753 13
a787 1
   myGlobalComp ()->setUseCoin       (boolParamVal ("useCoin"));
@


1.73
log
@Continued implementation of proportionate routing.
@
text
@d506 5
d762 1
@


1.72
log
@Modifications for Linux port.
@
text
@a505 5
   buildBoolParam (
      "allowPR",
      "Allow proportionate routing?",
      myGlobalComp ()->allowPR ());

a756 1
   myGlobalComp ()->setAllowPR       (boolParamVal ("allowPR"));
@


1.71
log
@Began implementation of Proportionate Routing.
@
text
@d128 3
a130 1
         allParams_.find (WitParam::itsName, theParam->myName ().myCstring ());
d146 1
a146 1
      allStringParams_.find (WitStringParam::itsName, paramName);
d158 1
a158 1
      allIntParams_.find (WitIntParam::itsName, paramName);
d170 1
a170 1
      allChoiceParams_.find (WitChoiceParam::itsName, paramName);
d183 1
a183 1
   theBoolParam = allBoolParams_.find (WitChoiceParam::itsName, paramName);
d751 2
a752 2
         WitOptStarter::paramValue,
         choiceParamVal ("optInitMethod").myCstring ());
@


1.70
log
@Internal changes.
@
text
@d504 5
d760 1
@


1.69
log
@Internal changes.
@
text
@d100 1
a100 1
   while (! allParams_.isEmpty ())
@


1.68
log
@Continued implementation of heuristic implosion from an initial solution.
Fixed a bug in build-ahead by demand.
Removed RWClient.C.
@
text
@d33 1
a33 1
// TRUE, iff DOS file names are to be used.
d38 1
a38 1
#define useDosFileNames witTRUE
d42 1
a42 1
#define useDosFileNames witFALSE
d90 1
a90 1
      allBooleanParams_ (),
d177 1
a177 1
WitBoolean WitParamMgr::booleanParamVal (const char * paramName)
d179 1
a179 2
   WitChoiceParam * const theBooleanParam =
      allBooleanParams_.find (WitChoiceParam::itsName, paramName);
d181 1
a181 1
   witAssert (theBooleanParam != NULL);
d183 3
a185 1
   return (theBooleanParam->myValue () == "yes");
d254 1
a254 1
   buildBooleanParam (
d257 1
a257 1
      witFALSE);
d259 1
a259 1
   buildBooleanParam (
d262 1
a262 1
      witFALSE);
d264 1
a264 1
   buildBooleanParam (
d267 1
a267 1
      witFALSE);
d269 1
a269 1
   buildBooleanParam (
d272 1
a272 1
      witTRUE);
d274 1
a274 1
   buildBooleanParam (
d277 1
a277 1
      witTRUE);
d279 1
a279 1
   buildBooleanParam (
d282 1
a282 1
      witFALSE);
d286 1
a286 1
   buildBooleanParam (
d327 1
a327 1
   buildBooleanParam (
d332 1
a332 1
   buildBooleanParam (
d337 1
a337 1
   buildBooleanParam (
d342 1
a342 1
   buildBooleanParam (
d347 1
a347 1
   buildBooleanParam (
d366 1
a366 1
   buildBooleanParam (
d369 1
a369 1
      witFALSE);
d371 1
a371 1
   buildBooleanParam (
d374 1
a374 1
      witFALSE);
d376 1
a376 1
   buildBooleanParam (
d379 1
a379 1
      witTRUE);
d381 1
a381 1
   buildBooleanParam (
d384 1
a384 1
      witFALSE);
d391 1
a391 1
   buildBooleanParam (
d394 1
a394 1
      witFALSE);
d401 1
a401 1
   buildBooleanParam (
d406 1
a406 1
   buildBooleanParam (
d411 1
a411 1
   buildBooleanParam (
d428 1
a428 1
   buildBooleanParam (
d431 1
a431 1
      witFALSE);
d433 1
a433 1
   buildBooleanParam (
d436 1
a436 1
      witFALSE);
d438 1
a438 1
   buildBooleanParam (
d441 1
a441 1
      witFALSE);
d443 1
a443 1
   buildBooleanParam (
d446 1
a446 1
      witFALSE);
d448 1
a448 1
   buildBooleanParam (
d451 1
a451 1
      witFALSE);
d453 1
a453 1
   buildBooleanParam (
d456 1
a456 1
      witFALSE);
d458 1
a458 1
   buildBooleanParam (
d461 1
a461 1
      witFALSE);
d463 1
a463 1
   buildBooleanParam (
d466 1
a466 1
      witFALSE);
d468 1
a468 1
   buildBooleanParam (
d473 1
a473 1
   buildBooleanParam (
d476 1
a476 1
      witFALSE);
d478 1
a478 1
   buildBooleanParam (
d481 1
a481 1
      witFALSE);
d483 1
a483 1
   buildBooleanParam (
d485 2
a486 2
      "Set all sel-split booleans to TRUE?",
      witFALSE);
d608 1
a608 1
void WitParamMgr::buildBooleanParam (
d611 1
a611 1
      WitBoolean   initValue)
d613 1
a613 1
   WitChoiceParam * theBooleanParam;
d615 1
a615 1
   theBooleanParam = new WitChoiceParam (theName, theText, this);
d617 1
a617 1
   allBooleanParams_.append (theBooleanParam);
d619 2
a620 2
   theBooleanParam->addChoice ("yes");
   theBooleanParam->addChoice ("no");
d622 1
a622 1
   theBooleanParam->choose (initValue? "yes": "no");
d679 1
a679 1
      witTRUE, 
d690 1
a690 1
   myWitRun ()->witSetAutoPriority (booleanParamVal ("auto_pri"));
d726 6
a731 6
   myOptImploder ()->setPrintOptModel (booleanParamVal ("printOptModel"));
   myOptImploder ()->setPrintOslVecs  (booleanParamVal ("printOslVecs"));
   myOptImploder ()->setPrintInitSoln (booleanParamVal ("printInitSoln"));
   myOptImploder ()->setPrintOptSoln  (booleanParamVal ("printOptSoln"));
   myOptImploder ()->setPrintMps      (booleanParamVal ("printMps"));
   myOptImploder ()->setPrintMask     (intParamVal     ("printMask"));
d749 6
a754 6
   myGlobalComp ()->setReadDataMsgs  (booleanParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc  (booleanParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol (booleanParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel (intParamVal     ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand  (booleanParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB    (intParamVal     ("splitItrUB"));
d756 1
a756 1
   WitTicker::setTickDelta           (intParamVal     ("tickDelta"));
d758 1
a758 1
   if (booleanParamVal ("prtIncAlloc"))
d784 1
a784 1
   myMsgFac ().setCrashOnFatal (booleanParamVal ("crashOnFatal"));
d869 1
a869 1
WitBoolean WitTicker::tick ()
d872 1
a872 1
      return witFALSE;
d882 1
a882 1
      return witTRUE;
d885 1
a885 1
   return witFALSE;
@


1.67
log
@Continued implementation of heuristic initial solution.
@
text
@a472 5
      "allowHIS",
      "Allow heurInitSoln?",
      myGlobalComp ()->allowHIS ());

   buildBooleanParam (
a752 1
   myGlobalComp ()->setAllowHIS      (booleanParamVal ("allowHIS"));
@


1.66
log
@Cut-over single-source to use the new algorithm.
@
text
@d473 3
a475 3
      "allowIHS",
      "Allow initHeurSoln?",
      myGlobalComp ()->allowIHS ());
d758 1
a758 1
   myGlobalComp ()->setAllowIHS      (booleanParamVal ("allowIHS"));
@


1.65
log
@Continued implementation of single-source with the new algorithm.
@
text
@a477 5
      "sglSrcNewAlg",
      "Use new algorithm for single-source?",
      myGlobalComp ()->sglSrcNewAlg ());

   buildBooleanParam (
a758 1
   myGlobalComp ()->setSglSrcNewAlg  (booleanParamVal ("sglSrcNewAlg"));
@


1.64
log
@Continued implementation of heuristic implosion from an initial solution.
Added some debugging code to Single-Source.
@
text
@d478 5
d764 1
@


1.63
log
@Began implementation of heuristic implosion from an initial solution.
@
text
@d473 3
a475 3
      "allowHIS",
      "Allow heurInitSoln?",
      myGlobalComp ()->allowHIS ());
d758 1
a758 1
   myGlobalComp ()->setAllowHIS      (booleanParamVal ("allowHIS"));
@


1.62
log
@Continued implementation of 2-level lot sizes.
@
text
@d473 5
d758 1
@


1.61
log
@Continued implementation of two-level lot sizes.
@
text
@a502 5
   buildBooleanParam (
      "allowTlls",
      "Allow two-level lot sizes?",
      myGlobalComp ()->allowTlls ());

a753 1
   myGlobalComp ()->setAllowTlls     (booleanParamVal ("allowTlls"));
@


1.60
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d503 5
d759 1
@


1.59
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a502 5
   buildBooleanParam (
      "allowMLS",
      "Allow minLotSize for opt implosion?",
      myOptComp ()->allowMLS ());

a753 1
   myOptComp    ()->setAllowMLS      (booleanParamVal ("allowMLS"));
@


1.58
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d503 5
d759 1
@


1.57
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a502 5
   buildBooleanParam (
      "allowOWLS",
      "Allow optWithLotSizes?",
      myOptComp ()->allowOWLS ());

a753 1
   myOptComp    ()->setAllowOWLS     (booleanParamVal ("allowOWLS"));
@


1.56
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d327 3
a329 3
      "printMpModel",
      "Print the MP model?",
      myOptImploder ()->printMpModel ());
d338 1
a338 1
      "Print initial MP solution?",
d342 3
a344 3
      "printMpSoln",
      "Print final MP solution?",
      myOptImploder ()->printMpSoln ());
d730 1
a730 1
   myOptImploder ()->setPrintMpModel  (booleanParamVal ("printMpModel"));
d733 1
a733 1
   myOptImploder ()->setPrintMpSoln   (booleanParamVal ("printMpSoln"));
@


1.55
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d327 3
a329 3
      "printLpModel",
      "Print the LP model?",
      myOptImploder ()->printLpModel ());
d338 1
a338 1
      "Print initial LP solution?",
d342 3
a344 3
      "printLpSoln",
      "Print final LP solution?",
      myOptImploder ()->printLpSoln ());
d730 1
a730 1
   myOptImploder ()->setPrintLpModel  (booleanParamVal ("printLpModel"));
d733 1
a733 1
   myOptImploder ()->setPrintLpSoln   (booleanParamVal ("printLpSoln"));
@


1.54
log
@Began implementation of opt implosion with lot sizes.
@
text
@d23 2
d26 1
@


1.53
log
@Fixed a CPU time problem in opt implosion with OSL V3.
@
text
@d500 5
d756 1
@


1.52
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d357 1
a357 1
      0, 1,
@


1.51
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d357 1
a357 1
      0, 2,
@


1.50
log
@Continued implementation of opt implosion with OSL V3.
@
text
@a371 34
   buildIntParam (
      "alteredAttr",
      "Choice of       altered attribute",
      0, 3,
      0);
         //
         // Determines which attribute to alter for re-opt-implosion test.
         // 0: none.
         // 1: supplyVol.
         // 2: grossRev.
         // 3: cumShipBounds.

   buildStringParam (
      "alteredPart",
      "Part   name for altered attribute",
      "");

   buildStringParam (
      "alteredDemand",
      "Demand name for altered attribute",
      "");

   buildIntParam (
      "alteredPeriod",
      "Period      for altered attribute",
      0, -1,
      0);

   buildIntParam (
      "alteredValue",
      "New value of    altered attribute",
      0, -1,
      0);

@


1.49
log
@Continued implementation of single-source.
@
text
@d344 3
a346 3
      "dumpMps",
      "Dump an MPS deck of the model?",
      myOptImploder ()->dumpMps ());
d760 1
a760 1
   myOptImploder ()->setDumpMps       (booleanParamVal ("dumpMps"));
@


1.48
log
@Continued implementation of single-source.
@
text
@a533 5
   buildBooleanParam (
      "allowSglSrc",
      "Allow single-source?",
      myGlobalComp ()->allowSglSrc ());

a784 1
   myGlobalComp ()->setAllowSglSrc   (booleanParamVal ("allowSglSrc"));
@


1.47
log
@Continued implementation of single source.
@
text
@d535 3
a537 3
      "sglSrc",
      "Do single-source?",
      myGlobalComp ()->sglSrc ());
d790 1
a790 1
   myGlobalComp ()->setSglSrc        (booleanParamVal ("sglSrc"));
@


1.46
log
@Preliminary work on single source.
@
text
@d534 5
d790 1
@


1.45
log
@Preliminary work on single source.
@
text
@d312 3
a314 1
   int i;
d536 5
a540 1
   for (i = 1; i <= myGlobalComp ()->nTempPars (); ++ i)
d542 4
a545 3
         tempParName              (i).myCstring (),
         tempParText              (i).myCstring (),
         myGlobalComp ()->tempPar (i).myCstring ());
d753 2
a754 1
   int             i;
d816 4
a819 1
   for (i = 1; i <= myGlobalComp ()->nTempPars (); ++ i)
d821 3
a823 2
         i, 
         stringParamVal (tempParName (i).myCstring ()));
d850 1
a850 1
WitString WitParamMgr::tempParName (int index)
d852 1
a852 1
   WitString theName (100);
d854 1
a854 3
   sprintf (theName.myCstringForUpdate (), "tempPar%d", index);

   return theName;
d859 1
a859 1
WitString WitParamMgr::tempParText (int index)
d861 1
a861 1
   WitString theText (100);
d864 1
a864 1
      theText.myCstringForUpdate (),
d866 1
a866 3
      index);

   return theText;
@


1.44
log
@Continued implementation of object iteration.
@
text
@d658 1
a658 1
   WitList (WitParam) * pAllValidParams =
@


1.43
log
@Continued implementation of object iteration.
@
text
@a531 5
   buildBooleanParam (
      "allowObjItr",
      "Allow object iteration?",
      myGlobalComp ()->allowObjItr ());

a776 1
   myGlobalComp ()->setAllowObjItr   (booleanParamVal ("allowObjItr"));
@


1.42
log
@Began implementation of object iteration.
@
text
@d532 5
d782 1
@


1.41
log
@Continued implementation of sel-split for pen-exec.
@
text
@d25 1
@


1.40
log
@Continued implementation of sel-split for pen-exec.
@
text
@a530 5
   buildBooleanParam (
      "allowSSPE",
      "Allow sel-split for pen-exec?",
      myGlobalComp ()->allowSSPE ());

a775 1
   myGlobalComp ()->setAllowSSPE     (booleanParamVal ("allowSSPE"));
@


1.39
log
@Added allowSSPE dev param.
Switched pen-exec to single-shortage logic.
Made pen-exec exploit sparse penalties.
@
text
@d528 1
a528 1
      0, -1,
@


1.38
log
@Finished implementation of selection splitting for multi-route.
@
text
@d531 5
d781 1
@


1.37
log
@Initial implementation of selection splitting for multi-route.
@
text
@a530 5
   buildBooleanParam (
      "allowNewSS",
      "Allow new controls for sel-split?",
      myGlobalComp ()->allowNewSS ());

d770 6
a775 7
   myGlobalComp ()->setReadDataMsgs    (booleanParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc    (booleanParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol   (booleanParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel   (intParamVal     ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand    (booleanParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB      (intParamVal     ("splitItrUB"));
   myGlobalComp ()->setAllowNewSS      (booleanParamVal ("allowNewSS"));
@


1.36
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d531 5
d775 7
a781 6
   myGlobalComp ()->setReadDataMsgs  (booleanParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc  (booleanParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol (booleanParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel (intParamVal     ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand  (booleanParamVal ("twmeByDemand"));
   myGlobalComp ()->setSplitItrUB    (intParamVal     ("splitItrUB"));
@


1.35
log
@Began implementation of selection splitting for stock reallocation.
@
text
@a530 5
   buildBooleanParam (
      "allowSRSS",
      "Allow Sel-Split for Stock Reallocation?",
      myGlobalComp ()->allowSRSS ());

a775 1
   myGlobalComp ()->setAllowSRSS     (booleanParamVal ("allowSRSS"));
@


1.34
log
@Removed allowSSR development control parameter.
@
text
@d531 5
d781 1
@


1.33
log
@Moved pegging output to comprehensive implosion solution output.
Fixed bug: Pegging was being attempted during stock bounds enforcement.
@
text
@a530 5
   buildBooleanParam (
      "allowSSR",
      "Allow selective stock reallocation?",
      myGlobalComp ()->allowSSR ());

a775 1
   myGlobalComp ()->setAllowSSR      (booleanParamVal ("allowSSR"));
@


1.32
log
@Began implemention of constrained stock reallocation.
@
text
@a531 5
      "prtPegging",
      "Print pegging?",
      witFALSE);

   buildBooleanParam (
@


1.31
log
@Continued implementation of pegging.
@
text
@d536 5
d786 1
@


1.30
log
@Initial implementation of pegging.
@
text
@d532 3
a534 3
      "allowPegging",
      "Allow pegging?",
      myGlobalComp ()->allowPegging ());
a780 1
   myGlobalComp ()->setAllowPegging  (booleanParamVal ("allowPegging"));
@


1.29
log
@Implemented an iteration upper bound for selection splitting.
@
text
@d531 5
d781 1
@


1.28
log
@Continued development of selection splitting for multi-exec.
@
text
@d517 1
a517 1
      "selection splitting tolerance",
d522 1
a522 1
      "selection splitting resolution",
d525 6
d775 1
@


1.27
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@a500 5
      "meSelSplitOK",
      "Allow meSelSplit to be set?",
      myGlobalComp ()->meSelSplitOK ());

   buildBooleanParam (
a768 1
   myGlobalComp ()->setMeSelSplitOK  (booleanParamVal ("meSelSplitOK"));
@


1.26
log
@Removed allowSS development parameter.
@
text
@d501 5
d774 1
@


1.25
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a510 5
      "allowSS",
      "Allow sel-split boolean to be set?",
      myGlobalComp ()->allowSS ());

   buildBooleanParam (
a768 1
   myGlobalComp ()->setAllowSS       (booleanParamVal ("allowSS"));
@


1.24
log
@Implemented timing wrap-around adjustment.
@
text
@d511 8
a518 3
      "selSplit",
      "Perform selection splitting?",
      myGlobalComp ()->selSplit ());
a529 6
   buildIntParam (
      "heurTimingDelta",
      "Timing delta for heuristic allocation",
      0, -1,
      myGlobalComp ()->heurTimingDelta ());

d769 6
a774 7
   myGlobalComp ()->setReadDataMsgs    (booleanParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc    (booleanParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol   (booleanParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel   (intParamVal     ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand    (booleanParamVal ("twmeByDemand"));
   myGlobalComp ()->setSelSplit        (booleanParamVal ("selSplit"));
   myGlobalComp ()->setHeurTimingDelta (intParamVal     ("heurTimingDelta"));
@


1.23
log
@Implemented Ticker class.
Disallowed sel-split w multi-exec.
@
text
@d525 6
d770 7
a776 6
   myGlobalComp ()->setReadDataMsgs  (booleanParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc  (booleanParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol (booleanParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel (intParamVal     ("selPrintLevel"));
   myGlobalComp ()->setTwmeByDemand  (booleanParamVal ("twmeByDemand"));
   myGlobalComp ()->setSelSplit      (booleanParamVal ("selSplit"));
@


1.22
log
@Implemented incAlloc count.
@
text
@d13 4
a16 1
// Contains the implementation of class ParamMgr.
d450 2
a451 2
      "incCountDelta",
      "Delta for printing #calls to incAlloc",
d453 1
a453 1
      myGlobalComp ()->incCountDelta ());
a767 1
   myGlobalComp ()->setIncCountDelta (intParamVal     ("incCountDelta"));
d771 2
d853 53
@


1.21
log
@Implemented tick printing for incHeurAlloc.
@
text
@d446 5
a450 4
   buildBooleanParam (
      "incAllocTicks",
      "Print ticks for incHeurAlloc?",
      myGlobalComp ()->incAllocTicks ());
d765 1
a765 1
   myGlobalComp ()->setIncAllocTicks (booleanParamVal ("incAllocTicks"));
@


1.20
log
@Added incAllocMsg.
@
text
@d447 5
d764 1
@


1.19
log
@Minor change.
@
text
@d497 5
d762 2
@


1.18
log
@Continuing development of selection splitting.
@
text
@d504 1
a504 1
      "1.0E-4");
d509 1
a509 1
      "1.0E-4");
@


1.17
log
@Re-worked the controls for selection splitting.
@
text
@d502 5
d509 1
a509 1
      "1.0");
d723 1
d757 11
d772 1
a772 1
   if (splitRes < .0009)
d775 3
d779 1
@


1.16
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d497 8
a504 3
      "allowSS",
      "Allow selection splitting?",
      myGlobalComp ()->allowSS ());
d718 1
d749 10
a758 1
   myGlobalComp ()->setAllowSS       (booleanParamVal ("allowSS"));
@


1.15
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@a491 5
      "selSplit",
      "Perform selection splitting?",
      myGlobalComp ()->selSplit ());

   buildBooleanParam (
d496 5
d743 1
a743 1
   myGlobalComp ()->setSelSplit      (booleanParamVal ("selSplit"));
@


1.14
log
@Implemented and used class SelMgr.
@
text
@d487 3
a489 3
      "twmeIsAsap",
      "Two-way multi-exec is ASAP?",
      myGlobalComp ()->twmeIsAsap ());
d742 1
a742 1
   myGlobalComp ()->setTwmeIsAsap    (booleanParamVal ("twmeIsAsap"));
@


1.13
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d93 2
a94 1
   allParams_.clearContents ();
@


1.12
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d256 5
d442 1
a442 1
      0, 3,
@


1.11
log
@Implemented respectStockSLBs and prefHighStockSLBs global attributes.
@
text
@d486 5
d732 6
a737 5
   myGlobalComp ()->setReadDataMsgs      (booleanParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc      (booleanParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol     (booleanParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel     (intParamVal     ("selPrintLevel"));
   myGlobalComp ()->setTwmeIsAsap        (booleanParamVal ("twmeIsAsap"));
@


1.10
log
@

Revised stand-alone FSS capabilties in development mode.
Modified some stock soft-lower bound controls.
Fixed bug: BOP entry productRate attribute could not be read.
@
text
@a485 5
      "respectStSLBs",
      "Respect stock soft lower bounds?",
      myGlobalComp ()->respectStockSLBs ());

   buildBooleanParam (
d727 5
a731 6
   myGlobalComp ()->setReadDataMsgs     (booleanParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc     (booleanParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol    (booleanParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel    (intParamVal     ("selPrintLevel"));
   myGlobalComp ()->setTwmeIsAsap       (booleanParamVal ("twmeIsAsap"));
   myGlobalComp ()->setRespectStockSLBs (booleanParamVal ("respectStSLBs"));
@


1.9
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@a419 5
      "fssTest",
      "Do an FSS test?",
      witFALSE);

   buildBooleanParam (
a449 5
   buildStringParam (
      "fss_ifname",
      "Name of FSS input data file",
      "");

d456 5
d486 3
a488 8
      "enforceStSLBs",
      "Enforce stock soft lower bounds?",
      myGlobalComp ()->enforceStSLBs ());

   buildBooleanParam (
      "emptyFss",
      "Perform FSS with an empty focus?",
      witFALSE);
d732 6
a737 6
   myGlobalComp ()->setReadDataMsgs  (booleanParamVal ("readDataMsgs"));
   myGlobalComp ()->setPrintEqAlloc  (booleanParamVal ("printEqAlloc"));
   myGlobalComp ()->setReportIncViol (booleanParamVal ("reportIncViol"));
   myGlobalComp ()->setSelPrintLevel (intParamVal     ("selPrintLevel"));
   myGlobalComp ()->setTwmeIsAsap    (booleanParamVal ("twmeIsAsap"));
   myGlobalComp ()->setEnforceStSLBs (booleanParamVal ("enforceStSLBs"));
@


1.8
log
@Finished implementing stock reallocation.
@
text
@d491 5
d747 1
@


1.7
log
@Made HeurAllPerf::findMaxQty test desQty when it's < minQty.
   This fixed a "commit failed" error, by making the heuristic function
   properly in cases in which commit fails at a lower desQty than one in which
   it succeeds.
Moved top-level net into commitMaxQtySel.
@
text
@a490 15
      "stockRealloc",
      "Perform stock reallocation?",
      myGlobalComp ()->stockRealloc ());

   buildBooleanParam (
      "emulatedSF",
      "Use emulated stock freezing?",
      myGlobalComp ()->emulatedSF ());

   buildBooleanParam (
      "trackInterval",
      "Track ReqVol intervals w/o stock re?",
      myGlobalComp ()->trackInterval ());

   buildBooleanParam (
a741 3
   myGlobalComp ()->setStockRealloc  (booleanParamVal ("stockRealloc"));
   myGlobalComp ()->setEmulatedSF    (booleanParamVal ("emulatedSF"));
   myGlobalComp ()->setTrackInterval (booleanParamVal ("trackInterval"));
@


1.6
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d496 10
d510 5
d758 2
@


1.5
log
@Minor update to stock re-allocation.
@
text
@d457 1
a457 1
      "Name of fss input data file",
d491 8
a498 3
      "stockReAlloc",
      "Perform stock re-allocation?",
      myGlobalComp ()->stockReAlloc ());
d633 1
a633 1
   paramFile = WitUtil::openFile (fileName (), "r");
d742 1
a742 1
   myGlobalComp ()->setStockReAlloc  (booleanParamVal ("stockReAlloc"));
@


1.4
log
@Initial implementation of stock re-allocation.
@
text
@d491 3
a493 8
      "usingNetSupp",
      "Use net supply as availability model?",
      myGlobalComp ()->usingNetSupp ());

   buildBooleanParam (
      "usingSurplus",
      "Use surplus    as availability model?",
      myGlobalComp ()->usingSurplus ());
a731 5
   if (booleanParamVal ("usingNetSupp"))
      if (booleanParamVal ("usingSurplus"))
         myMsgFac () ("genericSmsg",
            "usingNetSupp and usingSurplus may not be TRUE simultaueously.");

d737 1
a737 2
   myGlobalComp ()->setUsingNetSupp  (booleanParamVal ("usingNetSupp"));
   myGlobalComp ()->setUsingSurplus  (booleanParamVal ("usingSurplus"));
@


1.3
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d490 10
d737 5
d747 2
@


1.2
log
@Updating ParamMgr.C fix which was made by Bob in implode directoy
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
d119 1
a119 1
      dupParam =
@


1.1
log
@Initial revision
@
text
@d117 1
a117 1
      WitParam * theParam;
d119 1
a119 1
      theParam = 
d122 1
a122 1
      witAssert (theParam == NULL);
@


1.1.1.1
log
@Import wit
@
text
@@

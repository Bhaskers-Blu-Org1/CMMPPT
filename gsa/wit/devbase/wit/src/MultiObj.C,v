head	1.42;
access;
symbols;
locks; strict;
comment	@ * @;


1.42
date	2011.09.28.23.49.38;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.24.00.28.00;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.08.30.20.17.42;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.19.00.20.50;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.11.22.08.27;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.02.20.18.47;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.29.21.34.22;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.26.22.22.53;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2010.03.16.21.13.29;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.16.20.22.38;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2010.02.12.22.33.09;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.29.23.53.00;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.29.23.22.52;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.28.23.16.58;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.28.20.10.12;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.25.19.45.18;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.16.00.09.08;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.14.22.30.16;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.31.20.45.09;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.30.23.08.00;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.28.23.07.44;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.24.22.58.55;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.17.23.37.38;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.17.22.57.27;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.16.23.21.43;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.15.21.43.50;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.14.21.34.54;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.12.00.47.37;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.11.23.06.41;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.11.19.02.17;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.10.23.48.07;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.10.23.15.12;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2009.12.10.22.38.29;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.09.23.23.16;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2009.12.09.22.51.31;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.09.00.15.33;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.08.20.10.13;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.04.23.30.52;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.02.20.06.07;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2009.12.01.23.34.38;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.26.00.24.09;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "MultiObj.C"
//
// Contains the implementation of the following classes:
//
//    MultiObjMgr
//    Objective
//------------------------------------------------------------------------------

#include <MultiObjMgr.h>
#include <Objective.h>
#include <OptComp.h>
#include <GlobalComp.h>
#include <CompMgr.h>
#include <DetOptImpMgr.h>
#include <DataWrit.h>
#include <Pre.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class MultiObjMgr.
//------------------------------------------------------------------------------

WitMultiObjMgr::WitMultiObjMgr (WitProblem * theProblem):

      WitProbAssoc      (theProblem),
      myObjectives_     (),
      currentObjective_ (NULL),
      multiObjTol_      (defMultiObjTol ())
   {
   WitObjective * theObj;

   theObj            = new WitObjective (this, "Default");

   myObjectives_.append (theObj);

   currentObjective_ = theObj;
   }

//------------------------------------------------------------------------------

WitMultiObjMgr::~WitMultiObjMgr ()
   {
   clearObjectives ();
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::copyAttrsFrom (WitMultiObjMgr * theMultiObjMgr)
   {
   WitObjective * srcObj;
   const char *   theObjName;
   WitObjective * dstObj;

   currentObjective_ = NULL;

   clearObjectives ();

   forEachEl (srcObj, theMultiObjMgr->myObjectives_)
      {
      theObjName = srcObj->myObjName ().myCstring ();

      dstObj     = new WitObjective (this, theObjName);

      myObjectives_.append (dstObj);

      dstObj->copyAttrsFrom (srcObj);

      if (theMultiObjMgr->currentObjective_ == srcObj)
         {
         currentObjective_ = dstObj;
         }
      }

   stronglyAssert (currentObjective_ != NULL);

   multiObjTol_ = theMultiObjMgr->multiObjTol_;
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::writeDataAttrs ()
   {
   WitString      theObjListSpec;
   WitObjective * theObj;

   getObjectiveListSpec (theObjListSpec);

   myDataWriter ()->writeString (
        "objectiveListSpec",
            theObjListSpec,
      defObjectiveListSpec ());

   myDataWriter ()->writeDouble (
        "multiObjTol",
         multiObjTol (),
      defMultiObjTol ());

   forEachEl (theObj, myObjectives_)
      {
      theObj->writeDataAttrs ();
      }
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::writeMultiObjVecs ()
   {
   WitObjective * theObj;
   WitComponent * theComp;

   forEachEl (theObj, myObjectives_)
      {
      theObj->writeObjNameAsCurrent ();

      forEachEl (theComp, myCompMgr ()->allComponents ())
         {
         theComp->writeMultiObjVecs (theObj);
         }
      }

   currentObjective_->writeObjNameAsCurrent ();
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::display ()
   {
   WitObjective * theObj;
   WitString      theObjListSpec;

   myMsgFac () ("objHeadingDdMsg");

   forEachEl (theObj, myObjectives_)
      {
      theObj->display ();
      }

   getObjectiveListSpec (theObjListSpec);

   myMsgFac () ("multiObjAttDdMsg",
      theObjListSpec,
      currentObjective_->myObjName (),
      multiObjTol_);
   }

//------------------------------------------------------------------------------

WitObjective * WitMultiObjMgr::findObjective (const char * theObjName)
   {
   WitObjective * theObj;

   forEachEl (theObj, myObjectives_)
      {
      if (theObj->myObjName () == theObjName)
         {
         return theObj;
         }
      }

   return NULL;
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::validateData ()
   {
   if (myGlobalComp ()->computeCriticalList ())
      {
      myMsgFac () ("globAttMultiObjOptImpSmsg", "computeCriticalList");
      }

   if (myOptComp ()->compPrices ())
      {
      myMsgFac () ("globAttMultiObjOptImpSmsg", "compPrices");
      }

   if (myOptComp ()->accAfterOptImp ())
      {
      myMsgFac () ("globAttMultiObjOptImpSmsg", "accAfterOptImp");
      }

   checkUniqueRanks ();
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::writeObjValues ()
   {
   WitObjective * theObj;

   myMsgFac () ("blankMsg");

   if (myOptComp ()->boundsValueValid ())
      {
      myMsgFac () ("boundsValueMsg", myOptComp ()->boundsValue ());
      }

   forEachEl (theObj, myObjectives_)
      {
      myMsgFac () ("multiObjValueMsg",
         theObj->myObjName (),
         theObj->objValue  ());
      }
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::setObjectiveList (
      const WitVector <const char *> & theObjNames)
   {
   int            theIdx;
   WitObjective * theObj;

   stronglyAssert (myCompMgr ()->nNodes () == 0);

   stronglyAssert (theObjNames.length () >= 1);

   myProblem ()->prepSetUnpreAttr ();

   clearObjectives ();

   for (theIdx = 0; theIdx < theObjNames.length (); theIdx ++)
      {
      theObj = new WitObjective (this, theObjNames[theIdx]);

      myObjectives_.append (theObj);
      }

   currentObjective_ = myObjectives_.first ();
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::setCurrentObjective (WitObjective * theObj)
   {
   witAssert (theObj->myProblem () == myProblem ());

   myProblem ()->prepSetNonUnpostAttr ();

   currentObjective_ = theObj;
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::setMultiObjTol (double theValue)
   {
   stronglyAssert (theValue >= 0.0);

   stronglyAssert (theValue <= 0.001001);

   multiObjTol_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::getObjectiveListSpec (WitString & theObjListSpec)
   {
   int            theStrLength;
   WitObjective * theObj;
   char *         curPos;

   theStrLength = -1;

   forEachEl (theObj, myObjectives_)
      {
      theStrLength += theObj->myObjName ().length () + 1;
      }

   theObjListSpec.resize (theStrLength);
   
   curPos = theObjListSpec.myCstringForUpdate ();

   forEachEl (theObj, myObjectives_)
      {
      if (theObj != myObjectives_.first ())
         {
         * curPos = '|';

         curPos ++;
         }

      theObj->myObjName ().copyInto (curPos);

      curPos += theObj->myObjName ().length ();
      }

   stronglyAssert (curPos == theObjListSpec.myCstring () + theStrLength);
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::clearObjectives ()
   {
   currentObjective_ = NULL;

   while (not myObjectives_.isEmpty ())
      {
      delete myObjectives_.get ();
      }
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::checkUniqueRanks ()
   {
   WitPtrVec <WitObjective> theObjsByRank;
   WitObjective *           theObj;
   int                      theRank;

   theObjsByRank.resize (myObjectives_.nElements () + 1);

   forEachEl (theObj, myObjectives_)
      {
      theRank = theObj->objectiveRank ();

      if (theObjsByRank[theRank] != NULL)
         {
         myMsgFac () ("dupRankSmsg",
            theObjsByRank[theRank]->myObjName (),
            theObj                ->myObjName (),
            theRank);
         }

      theObjsByRank[theRank] = theObj;
      }
   }

//------------------------------------------------------------------------------
// Implementation of class Objective.
//------------------------------------------------------------------------------

WitObjective::WitObjective (
      WitMultiObjMgr * theMultiObjMgr,
      const char *     theObjName):

      WitProbAssoc   (theMultiObjMgr),
      myMultiObjMgr_ (theMultiObjMgr),
      mappingIndex_  (-1),
      myObjName_     (theObjName),
      objectiveRank_ (),
      objValue_      (0.0)
   {
   stronglyAssert (not myPreprocessor ()->preprocessed ());

   stronglyAssert (myMultiObjMgr_->findObjective (theObjName) == NULL);

   stronglyAssert (not containsVBar (theObjName));

   mappingIndex_  = theMultiObjMgr->myObjectives ().nElements ();

   objectiveRank_ = defObjectiveRank ();
   }

//------------------------------------------------------------------------------

WitObjective::~WitObjective ()
   {
   }

//------------------------------------------------------------------------------

void WitObjective::copyAttrsFrom (WitObjective * theObjective)
   {
   objectiveRank_ = theObjective->objectiveRank_;
   }

//------------------------------------------------------------------------------

void WitObjective::writeDataAttrs ()
   {
   myMsgFac () ("blankMsg");

   myDataWriter ()->writeString ("currentObjective", myObjName_, "");

   myDataWriter ()->writeInt (
        "objectiveRank",
         objectiveRank (),
      defObjectiveRank ());
   }

//------------------------------------------------------------------------------

void WitObjective::writeObjNameAsCurrent ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
   myDataWriter ()->writeString       ("currentObjective", myObjName_);
   myDataWriter ()->writeEndCommand   ();
   }

//------------------------------------------------------------------------------

void WitObjective::display ()
   {
   myMsgFac () ("objectiveDdMsg", objectiveRank_, myObjName_);
   }

//------------------------------------------------------------------------------

bool WitObjective::containsVBar (const char * theCstring)
   {
   return (strpbrk (theCstring, "|") != NULL);
   }

//------------------------------------------------------------------------------

void WitObjective::storeOptObjValue (double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   objValue_ = theValue;
   }

//------------------------------------------------------------------------------

bool WitObjective::hasNegativeCosts ()
   {
   WitObjective * savedObj;
   bool           hasNegCosts;

   savedObj    = myMultiObjMgr_->currentObjective ();

   myMultiObjMgr_->setCurrentObjective (this);

   hasNegCosts = myOptComp ()->negativeCostsExist ();

   myMultiObjMgr_->setCurrentObjective (savedObj);

   return hasNegCosts;
   }

//------------------------------------------------------------------------------

int WitObjective::nInstances (WitProblem * theProblem)
   {
   return
      theProblem->myOptComp ()->myMultiObjMgr ()->myObjectives ().nElements ();
   }

//------------------------------------------------------------------------------

int WitObjective::defObjectiveRank ()
   {
   return mappingIndex_ + 1;
   }

//------------------------------------------------------------------------------

void WitObjective::setObjectiveRank (int theRank)
   {
   stronglyAssert (theRank >= 1);
   stronglyAssert (theRank <= myMultiObjMgr_->myObjectives ().nElements ());

   objectiveRank_ = theRank;
   }
@


1.41
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.40
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d35 6
a40 6
WitProbAssoc      (theProblem),
myObjectives_     (),
currentObjective_ (NULL),
multiObjTol_      (defMultiObjTol ())
{
WitObjective * theObj;
d42 1
a42 1
theObj            = new WitObjective (this, "Default");
d44 1
a44 1
myObjectives_.append (theObj);
d46 2
a47 2
currentObjective_ = theObj;
}
d52 3
a54 3
{
clearObjectives ();
}
d59 4
a62 4
{
WitObjective * srcObj;
const char *   theObjName;
WitObjective * dstObj;
d64 1
a64 1
currentObjective_ = NULL;
d66 1
a66 1
clearObjectives ();
d68 3
a70 3
forEachEl (srcObj, theMultiObjMgr->myObjectives_)
{
theObjName = srcObj->myObjName ().myCstring ();
d72 1
a72 1
dstObj     = new WitObjective (this, theObjName);
d74 1
a74 1
myObjectives_.append (dstObj);
d76 1
a76 1
dstObj->copyAttrsFrom (srcObj);
d78 5
a82 5
if (theMultiObjMgr->currentObjective_ == srcObj)
{
currentObjective_ = dstObj;
}
}
d84 1
a84 1
stronglyAssert (currentObjective_ != NULL);
d86 2
a87 2
multiObjTol_ = theMultiObjMgr->multiObjTol_;
}
d92 21
a112 21
{
WitString      theObjListSpec;
WitObjective * theObj;

getObjectiveListSpec (theObjListSpec);

myDataWriter ()->writeString (
"objectiveListSpec",
theObjListSpec,
defObjectiveListSpec ());

myDataWriter ()->writeDouble (
"multiObjTol",
multiObjTol (),
defMultiObjTol ());

forEachEl (theObj, myObjectives_)
{
theObj->writeDataAttrs ();
}
}
d117 13
a129 13
{
WitObjective * theObj;
WitComponent * theComp;

forEachEl (theObj, myObjectives_)
{
theObj->writeObjNameAsCurrent ();

forEachEl (theComp, myCompMgr ()->allComponents ())
{
theComp->writeMultiObjVecs (theObj);
}
}
d131 2
a132 2
currentObjective_->writeObjNameAsCurrent ();
}
d137 18
a154 18
{
WitObjective * theObj;
WitString      theObjListSpec;

myMsgFac () ("objHeadingDdMsg");

forEachEl (theObj, myObjectives_)
{
theObj->display ();
}

getObjectiveListSpec (theObjListSpec);

myMsgFac () ("multiObjAttDdMsg",
theObjListSpec,
currentObjective_->myObjName (),
multiObjTol_);
}
d159 2
a160 2
{
WitObjective * theObj;
d162 7
a168 7
forEachEl (theObj, myObjectives_)
{
if (theObj->myObjName () == theObjName)
{
return theObj;
}
}
d170 2
a171 2
return NULL;
}
d176 15
a190 15
{
if (myGlobalComp ()->computeCriticalList ())
{
myMsgFac () ("globAttMultiObjOptImpSmsg", "computeCriticalList");
}

if (myOptComp ()->compPrices ())
{
myMsgFac () ("globAttMultiObjOptImpSmsg", "compPrices");
}

if (myOptComp ()->accAfterOptImp ())
{
myMsgFac () ("globAttMultiObjOptImpSmsg", "accAfterOptImp");
}
d192 2
a193 2
checkUniqueRanks ();
}
d198 2
a199 2
{
WitObjective * theObj;
d201 1
a201 1
myMsgFac () ("blankMsg");
d203 12
a214 12
if (myOptComp ()->boundsValueValid ())
{
myMsgFac () ("boundsValueMsg", myOptComp ()->boundsValue ());
}

forEachEl (theObj, myObjectives_)
{
myMsgFac () ("multiObjValueMsg",
theObj->myObjName (),
theObj->objValue  ());
}
}
d219 4
a222 4
const WitVector <const char *> & theObjNames)
{
int            theIdx;
WitObjective * theObj;
d224 1
a224 1
stronglyAssert (myCompMgr ()->nNodes () == 0);
d226 1
a226 1
stronglyAssert (theObjNames.length () >= 1);
d228 1
a228 1
myProblem ()->prepSetUnpreAttr ();
d230 1
a230 1
clearObjectives ();
d232 3
a234 3
for (theIdx = 0; theIdx < theObjNames.length (); theIdx ++)
{
theObj = new WitObjective (this, theObjNames[theIdx]);
d236 2
a237 2
myObjectives_.append (theObj);
}
d239 2
a240 2
currentObjective_ = myObjectives_.first ();
}
d245 2
a246 2
{
witAssert (theObj->myProblem () == myProblem ());
d248 1
a248 1
myProblem ()->prepSetNonUnpostAttr ();
d250 2
a251 2
currentObjective_ = theObj;
}
d256 2
a257 2
{
stronglyAssert (theValue >= 0.0);
d259 1
a259 1
stronglyAssert (theValue <= 0.001001);
d261 2
a262 2
multiObjTol_ = theValue;
}
d267 24
a290 24
{
int            theStrLength;
WitObjective * theObj;
char *         curPos;

theStrLength = -1;

forEachEl (theObj, myObjectives_)
{
theStrLength += theObj->myObjName ().length () + 1;
}

theObjListSpec.resize (theStrLength);

curPos = theObjListSpec.myCstringForUpdate ();

forEachEl (theObj, myObjectives_)
{
if (theObj != myObjectives_.first ())
{
* curPos = '|';

curPos ++;
}
d292 1
a292 1
theObj->myObjName ().copyInto (curPos);
d294 2
a295 2
curPos += theObj->myObjName ().length ();
}
d297 2
a298 2
stronglyAssert (curPos == theObjListSpec.myCstring () + theStrLength);
}
d303 2
a304 2
{
currentObjective_ = NULL;
d306 5
a310 5
while (not myObjectives_.isEmpty ())
{
delete myObjectives_.get ();
}
}
d315 22
a336 22
{
WitPtrVec <WitObjective> theObjsByRank;
WitObjective *           theObj;
int                      theRank;

theObjsByRank.resize (myObjectives_.nElements () + 1);

forEachEl (theObj, myObjectives_)
{
theRank = theObj->objectiveRank ();

if (theObjsByRank[theRank] != NULL)
{
myMsgFac () ("dupRankSmsg",
theObjsByRank[theRank]->myObjName (),
theObj                ->myObjName (),
theRank);
}

theObjsByRank[theRank] = theObj;
}
}
d343 2
a344 2
WitMultiObjMgr * theMultiObjMgr,
const char *     theObjName):
d346 8
a353 8
WitProbAssoc   (theMultiObjMgr),
myMultiObjMgr_ (theMultiObjMgr),
mappingIndex_  (-1),
myObjName_     (theObjName),
objectiveRank_ (),
objValue_      (0.0)
{
stronglyAssert (not myPreprocessor ()->preprocessed ());
d355 1
a355 1
stronglyAssert (myMultiObjMgr_->findObjective (theObjName) == NULL);
d357 1
a357 1
stronglyAssert (not containsVBar (theObjName));
d359 1
a359 1
mappingIndex_  = theMultiObjMgr->myObjectives ().nElements ();
d361 2
a362 2
objectiveRank_ = defObjectiveRank ();
}
d367 2
a368 2
{
}
d373 3
a375 3
{
objectiveRank_ = theObjective->objectiveRank_;
}
d380 2
a381 2
{
myMsgFac () ("blankMsg");
d383 1
a383 1
myDataWriter ()->writeString ("currentObjective", myObjName_, "");
d385 5
a389 5
myDataWriter ()->writeInt (
"objectiveRank",
objectiveRank (),
defObjectiveRank ());
}
d394 6
a399 6
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("problem");
myDataWriter ()->writeString       ("currentObjective", myObjName_);
myDataWriter ()->writeEndCommand   ();
}
d404 3
a406 3
{
myMsgFac () ("objectiveDdMsg", objectiveRank_, myObjName_);
}
d411 3
a413 3
{
return (strpbrk (theCstring, "|") != NULL);
}
d418 2
a419 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d421 2
a422 2
objValue_ = theValue;
}
d427 3
a429 3
{
WitObjective * savedObj;
bool           hasNegCosts;
d431 1
a431 1
savedObj    = myMultiObjMgr_->currentObjective ();
d433 1
a433 1
myMultiObjMgr_->setCurrentObjective (this);
d435 1
a435 1
hasNegCosts = myOptComp ()->negativeCostsExist ();
d437 1
a437 1
myMultiObjMgr_->setCurrentObjective (savedObj);
d439 2
a440 2
return hasNegCosts;
}
d445 4
a448 4
{
return
theProblem->myOptComp ()->myMultiObjMgr ()->myObjectives ().nElements ();
}
d453 3
a455 3
{
return mappingIndex_ + 1;
}
d460 3
a462 3
{
stronglyAssert (theRank >= 1);
stronglyAssert (theRank <= myMultiObjMgr_->myObjectives ().nElements ());
d464 2
a465 2
objectiveRank_ = theRank;
}
@


1.39
log
@CPLEX Parameters
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d35 6
a40 6
      WitProbAssoc      (theProblem),
      myObjectives_     (),
      currentObjective_ (NULL),
      multiObjTol_      (defMultiObjTol ())
   {
   WitObjective * theObj;
d42 1
a42 1
   theObj            = new WitObjective (this, "Default");
d44 1
a44 1
   myObjectives_.append (theObj);
d46 2
a47 2
   currentObjective_ = theObj;
   }
d52 3
a54 3
   {
   clearObjectives ();
   }
d59 4
a62 4
   {
   WitObjective * srcObj;
   const char *   theObjName;
   WitObjective * dstObj;
d64 1
a64 1
   currentObjective_ = NULL;
d66 1
a66 1
   clearObjectives ();
d68 3
a70 3
   forEachEl (srcObj, theMultiObjMgr->myObjectives_)
      {
      theObjName = srcObj->myObjName ().myCstring ();
d72 1
a72 1
      dstObj     = new WitObjective (this, theObjName);
d74 1
a74 1
      myObjectives_.append (dstObj);
d76 1
a76 1
      dstObj->copyAttrsFrom (srcObj);
d78 5
a82 5
      if (theMultiObjMgr->currentObjective_ == srcObj)
         {
         currentObjective_ = dstObj;
         }
      }
d84 1
a84 1
   stronglyAssert (currentObjective_ != NULL);
d86 2
a87 2
   multiObjTol_ = theMultiObjMgr->multiObjTol_;
   }
d92 21
a112 21
   {
   WitString      theObjListSpec;
   WitObjective * theObj;

   getObjectiveListSpec (theObjListSpec);

   myDataWriter ()->writeString (
        "objectiveListSpec",
            theObjListSpec,
      defObjectiveListSpec ());

   myDataWriter ()->writeDouble (
        "multiObjTol",
         multiObjTol (),
      defMultiObjTol ());

   forEachEl (theObj, myObjectives_)
      {
      theObj->writeDataAttrs ();
      }
   }
d117 13
a129 13
   {
   WitObjective * theObj;
   WitComponent * theComp;

   forEachEl (theObj, myObjectives_)
      {
      theObj->writeObjNameAsCurrent ();

      forEachEl (theComp, myCompMgr ()->allComponents ())
         {
         theComp->writeMultiObjVecs (theObj);
         }
      }
d131 2
a132 2
   currentObjective_->writeObjNameAsCurrent ();
   }
d137 18
a154 18
   {
   WitObjective * theObj;
   WitString      theObjListSpec;

   myMsgFac () ("objHeadingDdMsg");

   forEachEl (theObj, myObjectives_)
      {
      theObj->display ();
      }

   getObjectiveListSpec (theObjListSpec);

   myMsgFac () ("multiObjAttDdMsg",
      theObjListSpec,
      currentObjective_->myObjName (),
      multiObjTol_);
   }
d159 2
a160 2
   {
   WitObjective * theObj;
d162 7
a168 7
   forEachEl (theObj, myObjectives_)
      {
      if (theObj->myObjName () == theObjName)
         {
         return theObj;
         }
      }
d170 2
a171 2
   return NULL;
   }
d176 15
a190 15
   {
   if (myGlobalComp ()->computeCriticalList ())
      {
      myMsgFac () ("globAttMultiObjOptImpSmsg", "computeCriticalList");
      }

   if (myOptComp ()->compPrices ())
      {
      myMsgFac () ("globAttMultiObjOptImpSmsg", "compPrices");
      }

   if (myOptComp ()->accAfterOptImp ())
      {
      myMsgFac () ("globAttMultiObjOptImpSmsg", "accAfterOptImp");
      }
d192 2
a193 2
   checkUniqueRanks ();
   }
d198 2
a199 2
   {
   WitObjective * theObj;
d201 1
a201 1
   myMsgFac () ("blankMsg");
d203 12
a214 12
   if (myOptComp ()->boundsValueValid ())
      {
      myMsgFac () ("boundsValueMsg", myOptComp ()->boundsValue ());
      }

   forEachEl (theObj, myObjectives_)
      {
      myMsgFac () ("multiObjValueMsg",
         theObj->myObjName (),
         theObj->objValue  ());
      }
   }
d219 4
a222 4
      const WitVector <const char *> & theObjNames)
   {
   int            theIdx;
   WitObjective * theObj;
d224 1
a224 1
   stronglyAssert (myCompMgr ()->nNodes () == 0);
d226 1
a226 1
   stronglyAssert (theObjNames.length () >= 1);
d228 1
a228 1
   myProblem ()->prepSetUnpreAttr ();
d230 1
a230 1
   clearObjectives ();
d232 3
a234 3
   for (theIdx = 0; theIdx < theObjNames.length (); theIdx ++)
      {
      theObj = new WitObjective (this, theObjNames[theIdx]);
d236 2
a237 2
      myObjectives_.append (theObj);
      }
d239 2
a240 2
   currentObjective_ = myObjectives_.first ();
   }
d245 2
a246 2
   {
   witAssert (theObj->myProblem () == myProblem ());
d248 1
a248 1
   myProblem ()->prepSetNonUnpostAttr ();
d250 2
a251 2
   currentObjective_ = theObj;
   }
d256 2
a257 2
   {
   stronglyAssert (theValue >= 0.0);
d259 1
a259 1
   stronglyAssert (theValue <= 0.001001);
d261 2
a262 2
   multiObjTol_ = theValue;
   }
d267 24
a290 24
   {
   int            theStrLength;
   WitObjective * theObj;
   char *         curPos;

   theStrLength = -1;

   forEachEl (theObj, myObjectives_)
      {
      theStrLength += theObj->myObjName ().length () + 1;
      }

   theObjListSpec.resize (theStrLength);
   
   curPos = theObjListSpec.myCstringForUpdate ();

   forEachEl (theObj, myObjectives_)
      {
      if (theObj != myObjectives_.first ())
         {
         * curPos = '|';

         curPos ++;
         }
d292 1
a292 1
      theObj->myObjName ().copyInto (curPos);
d294 2
a295 2
      curPos += theObj->myObjName ().length ();
      }
d297 2
a298 2
   stronglyAssert (curPos == theObjListSpec.myCstring () + theStrLength);
   }
d303 2
a304 2
   {
   currentObjective_ = NULL;
d306 5
a310 5
   while (not myObjectives_.isEmpty ())
      {
      delete myObjectives_.get ();
      }
   }
d315 22
a336 22
   {
   WitPtrVec <WitObjective> theObjsByRank;
   WitObjective *           theObj;
   int                      theRank;

   theObjsByRank.resize (myObjectives_.nElements () + 1);

   forEachEl (theObj, myObjectives_)
      {
      theRank = theObj->objectiveRank ();

      if (theObjsByRank[theRank] != NULL)
         {
         myMsgFac () ("dupRankSmsg",
            theObjsByRank[theRank]->myObjName (),
            theObj                ->myObjName (),
            theRank);
         }

      theObjsByRank[theRank] = theObj;
      }
   }
d343 2
a344 2
      WitMultiObjMgr * theMultiObjMgr,
      const char *     theObjName):
d346 8
a353 8
      WitProbAssoc   (theMultiObjMgr),
      myMultiObjMgr_ (theMultiObjMgr),
      mappingIndex_  (-1),
      myObjName_     (theObjName),
      objectiveRank_ (),
      objValue_      (0.0)
   {
   stronglyAssert (not myPreprocessor ()->preprocessed ());
d355 1
a355 1
   stronglyAssert (myMultiObjMgr_->findObjective (theObjName) == NULL);
d357 1
a357 1
   stronglyAssert (not containsVBar (theObjName));
d359 1
a359 1
   mappingIndex_  = theMultiObjMgr->myObjectives ().nElements ();
d361 2
a362 2
   objectiveRank_ = defObjectiveRank ();
   }
d367 2
a368 2
   {
   }
d373 3
a375 3
   {
   objectiveRank_ = theObjective->objectiveRank_;
   }
d380 2
a381 2
   {
   myMsgFac () ("blankMsg");
d383 1
a383 1
   myDataWriter ()->writeString ("currentObjective", myObjName_, "");
d385 5
a389 5
   myDataWriter ()->writeInt (
        "objectiveRank",
         objectiveRank (),
      defObjectiveRank ());
   }
d394 6
a399 6
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
   myDataWriter ()->writeString       ("currentObjective", myObjName_);
   myDataWriter ()->writeEndCommand   ();
   }
d404 3
a406 3
   {
   myMsgFac () ("objectiveDdMsg", objectiveRank_, myObjName_);
   }
d411 3
a413 3
   {
   return (strpbrk (theCstring, "|") != NULL);
   }
d418 2
a419 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d421 2
a422 2
   objValue_ = theValue;
   }
d427 3
a429 3
   {
   WitObjective * savedObj;
   bool           hasNegCosts;
d431 1
a431 1
   savedObj    = myMultiObjMgr_->currentObjective ();
d433 1
a433 1
   myMultiObjMgr_->setCurrentObjective (this);
d435 1
a435 1
   hasNegCosts = myOptComp ()->negativeCostsExist ();
d437 1
a437 1
   myMultiObjMgr_->setCurrentObjective (savedObj);
d439 2
a440 2
   return hasNegCosts;
   }
d445 4
a448 4
   {
   return
      theProblem->myOptComp ()->myMultiObjMgr ()->myObjectives ().nElements ();
   }
d453 3
a455 3
   {
   return mappingIndex_ + 1;
   }
d460 3
a462 3
   {
   stronglyAssert (theRank >= 1);
   stronglyAssert (theRank <= myMultiObjMgr_->myObjectives ().nElements ());
d464 2
a465 2
   objectiveRank_ = theRank;
   }
@


1.38
log
@CPX Params
@
text
@d397 1
a397 1
   myDataWriter ()->writeString       ("currentObjective", myObjName_, "");
@


1.37
log
@Multi-Obj Mode
@
text
@d112 1
a112 1
  }
@


1.36
log
@Multi-Obj Mode
@
text
@d187 5
@


1.35
log
@Multi-Obj Mode
@
text
@d187 1
a187 1
   checkUniqueSeqNos ();
d309 1
a309 1
void WitMultiObjMgr::checkUniqueSeqNos ()
d311 1
a311 1
   WitPtrVec <WitObjective> theObjsBySeqNo;
d313 1
a313 1
   int                      theSeqNo;
d315 1
a315 1
   theObjsBySeqNo.resize (myObjectives_.nElements () + 1);
d319 1
a319 1
      theSeqNo = theObj->objectiveSeqNo ();
d321 1
a321 1
      if (theObjsBySeqNo[theSeqNo] != NULL)
d323 4
a326 4
         myMsgFac () ("dupSeqNoSmsg",
            theObjsBySeqNo[theSeqNo]->myObjName (),
            theObj                  ->myObjName (),
            theSeqNo);
d329 1
a329 1
      theObjsBySeqNo[theSeqNo] = theObj;
d341 6
a346 6
      WitProbAssoc    (theMultiObjMgr),
      myMultiObjMgr_  (theMultiObjMgr),
      mappingIndex_   (-1),
      myObjName_      (theObjName),
      objectiveSeqNo_ (),
      objValue_       (0.0)
d354 1
a354 1
   mappingIndex_   = theMultiObjMgr->myObjectives ().nElements ();
d356 1
a356 1
   objectiveSeqNo_ = defObjectiveSeqNo ();
d369 1
a369 1
   objectiveSeqNo_ = theObjective->objectiveSeqNo_;
d381 3
a383 3
        "objectiveSeqNo",
         objectiveSeqNo (),
      defObjectiveSeqNo ());
d400 1
a400 1
   myMsgFac () ("objectiveDdMsg", objectiveSeqNo_, myObjName_);
d447 1
a447 1
int WitObjective::defObjectiveSeqNo ()
d454 1
a454 1
void WitObjective::setObjectiveSeqNo (int theSeqNo)
d456 2
a457 2
   stronglyAssert (theSeqNo >= 1);
   stronglyAssert (theSeqNo <= myMultiObjMgr_->myObjectives ().nElements ());
d459 1
a459 1
   objectiveSeqNo_ = theSeqNo;
@


1.34
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d37 2
a38 1
      currentObjective_ (NULL)
d85 2
d103 5
d152 2
a153 1
      currentObjective_->myObjName ());
d250 11
@


1.33
log
@Multi-Obj Mode
@
text
@d22 1
a22 1
#include <Global.h>
@


1.32
log
@Multi-Obj Mode
@
text
@d191 1
a191 3
      myMsgFac () ("multiObjValueMsg",
         "Negative Total Bounds Violation",
         myOptComp ()->boundsValue ());
@


1.31
log
@Multi-Obj mode
@
text
@d189 7
@


1.30
log
@Multi-objective mode
@
text
@a167 5
   if (myOptComp ()->mipMode ())
      {
      myMsgFac () ("globAttMultiObjOptImpSmsg", "mipMode");
      }

@


1.29
log
@Multi-objective mode
@
text
@d69 1
a69 1
      theObjName = srcObj->objectiveName ().myCstring ();
d144 1
a144 1
      currentObjective_->objectiveName ());
d155 1
a155 1
      if (theObj->objectiveName () == theObjName)
d197 2
a198 2
         theObj->objectiveName (),
         theObj->objValue      ());
d251 1
a251 1
      theStrLength += theObj->objectiveName ().length () + 1;
d267 1
a267 1
      theObj->objectiveName ().copyInto (curPos);
d269 1
a269 1
      curPos += theObj->objectiveName ().length ();
d304 2
a305 2
            theObjsBySeqNo[theSeqNo]->objectiveName (),
            theObj                  ->objectiveName (),
d324 1
a324 1
      objectiveName_  (theObjName),
d358 1
a358 4
   myDataWriter ()->writeString (
      "currentObjective",
      objectiveName_,
      "");
d372 1
a372 1
   myDataWriter ()->writeString       ("currentObjective", objectiveName_, "");
d380 1
a380 8
   myMsgFac () ("objectiveDdMsg", objectiveSeqNo_, objectiveName_);
   }

//------------------------------------------------------------------------------

bool WitObjective::allDigits (const char * theCstring)
   {
   return (strspn (theCstring, "0123456789") == strlen (theCstring));
@


1.28
log
@Multi-objective mode
@
text
@d26 1
d41 1
a41 1
   theObj            = new WitObjective (this);
a58 1
   WitListItr     theItr (myObjectives_);
d60 1
d63 1
a63 1
   setNObjectives (theMultiObjMgr->nObjectives ());
d65 1
a65 1
   currentObjective_ = NULL;
d69 5
a73 1
      myObjectives_.advance (theItr, dstObj);
a209 18
   setNObjectives (theObjNames.length ());

   theIdx = -1;

   forEachEl (theObj, myObjectives_)
      {
      theIdx ++;

      theObj->setObjectiveName (theObjNames[theIdx]);
      }
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::setNObjectives (int theInt)
   {
   WitObjective * theObj;

d212 1
a212 1
   stronglyAssert (theInt >= 1);
d218 1
a218 1
   while (nObjectives () < theInt)
d220 1
a220 1
      theObj = new WitObjective (this);
d295 1
a295 1
   theObjsBySeqNo.resize (nObjectives () + 1);
d317 3
a319 1
WitObjective::WitObjective (WitMultiObjMgr * theMultiObjMgr):
d324 1
a324 2
      defaultName_    (),
      objectiveName_  (),
d328 3
a330 1
   char theBuffer[10];
d332 1
a332 1
   mappingIndex_   = theMultiObjMgr->nObjectives ();
d334 1
a334 1
   sprintf (theBuffer, "%d", mappingIndex_ + 1);
a335 2
   defaultName_    = theBuffer;
   objectiveName_  = defaultName_;
a348 1
   objectiveName_  = theObjective->objectiveName_;
d431 2
a432 1
   return theProblem->myOptComp ()->myMultiObjMgr ()->nObjectives ();
a443 14
void WitObjective::setObjectiveName (const char * theObjName)
   {
   stronglyAssert (myMultiObjMgr_->findObjective (theObjName) == NULL);

   stronglyAssert (not allDigits    (theObjName));
   stronglyAssert (not containsVBar (theObjName));

   myProblem ()->prepSetNonUnpostAttr ();

   objectiveName_ = theObjName;
   }

//------------------------------------------------------------------------------

d447 1
a447 1
   stronglyAssert (theSeqNo <= myMultiObjMgr_->nObjectives ());
@


1.27
log
@Multi-objective mode.
@
text
@d34 3
a36 4
      WitProbAssoc       (theProblem),
      myObjectives_      (),
      currentObjective_  (NULL),
      objectiveListSpec_ (defObjectiveListSpec ())
a78 2

   objectiveListSpec_ = theMultiObjMgr->objectiveListSpec_;
d85 1
d88 6
a93 4
   myDataWriter ()->writeInt (
        "nObjectives",
         nObjectives (),
      defNObjectives ());
d126 1
d135 2
d138 1
a138 1
      objectiveListSpec_,
a198 36
void WitMultiObjMgr::compObjectiveListSpec ()
   {
   int            theStrLength;
   WitObjective * theObj;
   char *         curPos;

   theStrLength = -1;

   forEachEl (theObj, myObjectives_)
      {
      theStrLength += theObj->objectiveName ().length () + 1;
      }

   objectiveListSpec_.resize (theStrLength);
   
   curPos = objectiveListSpec_.myCstringForUpdate ();

   forEachEl (theObj, myObjectives_)
      {
      if (theObj != myObjectives_.first ())
         {
         * curPos = '|';

         curPos ++;
         }

      strcpy (curPos, theObj->objectiveName ().myCstring ());

      curPos += theObj->objectiveName ().length ();
      }

   stronglyAssert (curPos == objectiveListSpec_.myCstring () + theStrLength);
   }

//------------------------------------------------------------------------------

a214 2

   compObjectiveListSpec ();
a238 2

   compObjectiveListSpec ();
d254 36
d373 1
a373 1
      defaultName_,
a375 5
   myDataWriter ()->writeString (
      "objectiveName",
      objectiveName_,
      defaultName_.myCstring ());

a465 2

   myMultiObjMgr_->compObjectiveListSpec ();
@


1.26
log
@Multi-objective mode
@
text
@d233 1
a233 2
      int                  nObjNames,
      const char * const * theObjNames)
d238 1
a238 1
   setNObjectives (nObjNames);
@


1.25
log
@Multi-objective mode
@
text
@a25 1
#include <PtrVec.h>
d34 4
a37 3
      WitProbAssoc      (theProblem),
      myObjectives_     (),
      currentObjective_ (NULL)
d59 2
a60 1
   int            theIdx;
a61 1
   WitObjective * srcObj;
d67 1
a67 3
   theIdx = -1;

   forEachEl (dstObj, myObjectives_)
d69 1
a69 3
      theIdx ++;

      srcObj = theMultiObjMgr->myObjectives_.at (theIdx);
d80 2
d127 1
a127 1
   myMsgFac () ("multiObjAttDdMsg", nObjectives ());
d134 3
a136 1
   myMsgFac () ("curObjDdMsg", currentObjective_->objectiveName ());
d141 1
a141 1
WitObjective * WitMultiObjMgr::findObjective (const WitString & theObjName)
d196 59
d275 2
d381 1
a381 1
      defaultName_);
d408 1
a408 1
bool WitObjective::validObjName (const WitString & theObjName)
d410 8
a417 2
   return
      (strspn (theObjName.myCstring (), "0123456789") != theObjName.length ());
d463 1
a463 1
void WitObjective::setObjectiveName (const WitString & theObjName)
d467 2
a468 1
   stronglyAssert (validObjName (theObjName));
d473 2
@


1.24
log
@Multi-objective mode
@
text
@d364 18
@


1.23
log
@Multi-objective mode
@
text
@d170 5
@


1.22
log
@Multi-Objective Mode
@
text
@d175 16
@


1.21
log
@Multi-Objective Mode
@
text
@d24 1
d257 2
a258 1
      objectiveSeqNo_ ()
d334 9
@


1.20
log
@Multi-Objective Mode
@
text
@d104 1
a104 1
void WitMultiObjMgr::writeObjVecs ()
d115 1
a115 1
         theComp->writeObjVecs (theObj);
@


1.19
log
@Multi-Objective Mode
@
text
@d100 8
d109 9
a117 1
   myMsgFac () ("blankMsg");
d119 2
a120 5
   myDataWriter ()->writeString (
      "currentObjective",
       currentObjective_->objectiveName (),
      "");
  }
d307 10
@


1.18
log
@Multi-Objective Mode
@
text
@a14 1
//    ObjVec
a18 1
#include <ObjVec.h>
a28 14
// Implementation of class ObjVec.
//------------------------------------------------------------------------------

WitObjVec::WitObjVec ()
   {
   }

//------------------------------------------------------------------------------

WitObjVec::~WitObjVec ()
   {
   }

//------------------------------------------------------------------------------
@


1.17
log
@Multi-Objective Mode
@
text
@d27 1
d51 1
a51 2
      myObjectives_     (1),
      nObjectives_      (0),
d54 3
a56 1
   myObjectives_[0]  = new WitObjective (this);
d58 1
a58 1
   nObjectives_      = 1;
d60 1
a60 1
   currentObjective_ = myObjectives_[0];
d82 3
a84 1
   for (theIdx = 0; theIdx < nObjectives_; theIdx ++)
d86 3
a88 2
      dstObj =                 myObjectives_[theIdx];
      srcObj = theMultiObjMgr->myObjectives_[theIdx];
d105 1
a105 1
   int theIdx;
d112 1
a112 1
   for (theIdx = 0; theIdx < nObjectives_; theIdx ++)
d114 1
a114 1
      myObjectives_[theIdx]->writeDataAttrs ();
d129 1
a129 1
   int theIdx;
d133 1
a133 1
   for (theIdx = 0; theIdx < nObjectives_; theIdx ++)
d135 1
a135 1
      myObjectives_[theIdx]->display ();
a144 1
   int            theIdx;
d147 1
a147 1
   for (theIdx = 0; theIdx < nObjectives_; theIdx ++)
a148 2
      theObj = myObjectives_[theIdx];

d179 1
a179 1
   WitPtrVec <WitObjective> theObjectives;
d189 1
a189 3
   theObjectives.resize (theInt);

   while (nObjectives_ < theInt)
d191 1
a191 1
      theObjectives[nObjectives_] = new WitObjective (this);
d193 1
a193 1
      nObjectives_ ++;
d196 1
a196 5
   myObjectives_.resize (nObjectives_);

   myObjectives_     = theObjectives;

   currentObjective_ = myObjectives_[0];
a213 3
   int            theIdx;
   WitObjective * theObj;

d216 1
a216 1
   for (theIdx = 0; theIdx < nObjectives_; theIdx ++)
d218 1
a218 1
      delete myObjectives_[theIdx];
a219 4

   myObjectives_.clear ();

   nObjectives_ = 0;
a226 1
   int                      theIdx;
d230 1
a230 1
   theObjsBySeqNo.resize (nObjectives_ + 1);
d232 1
a232 1
   for (theIdx = 0; theIdx < nObjectives_; theIdx ++)
a233 2
      theObj   = myObjectives_[theIdx];
      
d263 1
a263 1
   mappingIndex_  = theMultiObjMgr->nObjectives ();
@


1.16
log
@Multi-Objective Mode.
@
text
@d15 1
d20 1
d30 14
@


1.15
log
@Multi-Objective Mode.
@
text
@d22 1
d144 4
a147 4
   WitPtrVec <WitObjective> theObjsBySeqNo;
   int                      theIdx;
   WitObjective *           theObj;
   int                      theSeqNo;
d149 1
a149 3
   theObjsBySeqNo.resize (nObjectives_ + 1);

   for (theIdx = 0; theIdx < nObjectives_; theIdx ++)
d151 2
a152 3
      theObj   = myObjectives_[theIdx];
      
      theSeqNo = theObj->objectiveSeqNo ();
d154 1
a154 10
      if (theObjsBySeqNo[theSeqNo] != NULL)
         {
         myMsgFac () ("dupSeqNoSmsg",
            theObjsBySeqNo[theSeqNo]->objectiveName (),
            theObj                  ->objectiveName (),
            theSeqNo);
         }

      theObjsBySeqNo[theSeqNo] = theObj;
      }
d218 29
@


1.14
log
@Multi-Objective Mode.
@
text
@a52 41
void WitMultiObjMgr::setNObjectives (int theInt)
   {
   WitPtrVec <WitObjective> theObjectives;

   stronglyAssert (myCompMgr ()->nNodes () == 0);

   stronglyAssert (theInt >= 1);

   myProblem ()->prepSetUnpreAttr ();

   clearObjectives ();

   theObjectives.resize (theInt);

   while (nObjectives_ < theInt)
      {
      theObjectives[nObjectives_] = new WitObjective (this);

      nObjectives_ ++;
      }

   myObjectives_.resize (nObjectives_);

   myObjectives_     = theObjectives;

   currentObjective_ = myObjectives_[0];
   }

//------------------------------------------------------------------------------

void WitMultiObjMgr::setCurrentObjective (WitObjective * theObj)
   {
   witAssert (theObj->myProblem () == myProblem ());

   myProblem ()->prepSetNonUnpostAttr ();

   currentObjective_ = theObj;
   }

//------------------------------------------------------------------------------

d95 2
d141 70
d270 1
a270 2
   if (objectiveName_ == defaultName_)
      return;
d280 6
a285 1
      "");
d329 10
@


1.13
log
@Multi-Objective Mode.
@
text
@d33 2
a34 1
      myObjectives_     (),
d37 5
a41 1
   currentObjective_ = new WitObjective (this);
d55 2
d65 3
a67 1
   while (nObjectives () < theInt)
d69 3
a71 1
      new WitObjective (this);
d74 5
a78 1
   currentObjective_ = myObjectives_.first ();
d97 1
a97 1
   WitObjective * theObj;
d102 1
a102 1
   currentObjective_ = theMultiObjMgr->currentObjective_;
d104 1
a104 3
   theIdx            = -1;

   forEachEl (theObj, myObjectives_)
d106 2
a107 1
      theIdx ++;
d109 1
a109 1
      srcObj = theMultiObjMgr->myObjectives_.at (theIdx);
d111 4
a114 1
      theObj->copyAttrsFrom (srcObj);
d116 2
d124 1
a124 1
   WitObjective * theObj;
d131 1
a131 1
   forEachEl (theObj, myObjectives_)
d133 1
a133 1
      theObj->writeDataAttrs ();
d146 1
a146 1
   WitObjective * theObj;
d150 1
a150 1
   forEachEl (theObj, myObjectives_)
d152 1
a152 1
      theObj->display ();
d162 1
d165 1
a165 1
   forEachEl (theObj, myObjectives_)
d167 2
a179 9
void WitMultiObjMgr::store (WitObjective * theObj)
   {
   stronglyAssert (findObjective (theObj->objectiveName ()) == NULL);

   myObjectives_.append (theObj);
   }

//------------------------------------------------------------------------------

d182 1
d187 4
a190 2
   forEachEl (theObj, myObjectives_)
      delete theObj;
d193 2
a218 2

   myMultiObjMgr_->store (this);
@


1.12
log
@Multi-Objective Mode
@
text
@d50 1
a50 1
   witAssert (myCompMgr ()->nNodes () == 0);
d52 1
a52 1
   witAssert (theInt >= 1);
d160 1
a160 1
   witAssert (findObjective (theObj->objectiveName ()) == NULL);
d185 6
a190 5
      WitProbAssoc   (theMultiObjMgr),
      myMultiObjMgr_ (theMultiObjMgr),
      mappingIndex_  (-1),
      defaultName_   (),
      objectiveName_ ()
d198 3
a200 2
   defaultName_   = theBuffer;
   objectiveName_ = defaultName_;
d215 2
a216 1
   objectiveName_ = theObjective->objectiveName_;
d241 1
a241 1
   myMsgFac () ("objectiveDdMsg", objectiveName_);
d261 7
d270 1
a270 1
   witAssert (myMultiObjMgr_->findObjective (theObjName) == NULL);
d272 1
a272 1
   witAssert (validObjName (theObjName));
@


1.11
log
@Multi-Objective Mode
@
text
@d54 2
a67 9
void WitMultiObjMgr::store (WitObjective * theObj)
   {
   witAssert (findObjective (theObj->objectiveName ()) == NULL);

   myObjectives_.append (theObj);
   }

//------------------------------------------------------------------------------

d72 2
d158 9
d264 2
@


1.10
log
@Multi-Objective Mode
@
text
@d191 1
a191 1
   sprintf (theBuffer, "#%d", mappingIndex_ + 1);
d241 2
a242 8
   int theSpan;

   if (theObjName[0] != '#')
      return true;

   theSpan = strspn (theObjName.myCstring () + 1, "0123456789");

   return (theSpan != theObjName.length () - 1);
@


1.9
log
@Multi-Objective Mode
@
text
@d110 2
d117 5
d183 3
a185 2
      objectiveName_ (),
      mappingIndex_  (-1)
d193 2
a194 1
   objectiveName_ = theBuffer;
d214 18
@


1.8
log
@Multi-Objective Mode
@
text
@d212 14
d237 2
@


1.7
log
@Multi-Objective Mode.
@
text
@d21 1
d36 1
a36 7
   WitObjective * theObj;

   theObj            = new WitObjective (this, 1);

   myObjectives_.append (theObj);

   currentObjective_ = theObj;
a49 3
   int            theIdx;
   WitObjective * theObj;

d56 1
a56 1
   for (theIdx = 0; theIdx < theInt; theIdx ++)
d58 1
a58 3
      theObj = new WitObjective (this, theIdx + 1);

      myObjectives_.append (theObj);
d66 9
d172 1
a172 1
WitObjective::WitObjective (WitMultiObjMgr * theMultiObjMgr, int theSeqNo):
d176 2
a177 1
      objectiveName_ ()
d181 3
a183 1
   sprintf (theBuffer, "#%d", theSeqNo);
d186 2
d212 7
@


1.6
log
@Multi-objective mode.
@
text
@d32 1
a32 1
      myObjectives_     (1),
d35 5
a39 1
   myObjectives_[0]  = new WitObjective (this, 1);
d41 1
a41 1
   currentObjective_ = myObjectives_[0];
d55 2
a56 1
   int theIdx;
a63 2
   myObjectives_.resize (theInt);

d66 3
a68 1
      myObjectives_[theIdx] = new WitObjective (this, theIdx + 1);
d71 1
a71 1
   currentObjective_ = myObjectives_[0];
d89 1
d95 3
a97 1
   for (theIdx = 0; theIdx < nObjectives (); theIdx ++)
d99 1
a99 1
      theObj = theMultiObjMgr->myObjectives_[theIdx];
d101 3
a103 1
      myObjectives_[theIdx]->copyAttrsFrom (theObj);
d126 1
a126 1
   int theIdx;
d130 1
a130 1
   for (theIdx = 0; theIdx < nObjectives (); theIdx ++)
d132 1
a132 1
      myObjectives_[theIdx]->display ();
d142 1
a142 4
   WitPtrVecItr <WitObjective> theItr;
   WitObjective *              theObj;

   myObjectives_.attachItr (theItr);
d144 1
a144 1
   while (theItr.advance (theObj))
d159 1
a159 1
   int theIdx;
d163 2
a164 6
   for (theIdx = 0; theIdx < nObjectives (); theIdx ++)
      {
      delete myObjectives_[theIdx];

      myObjectives_[theIdx] = NULL;
      }
@


1.5
log
@Multi-objective mode.
@
text
@d35 1
a35 1
   myObjectives_[0]  = new WitObjective (myProblem (), 1);
d63 1
a63 1
      myObjectives_[theIdx] = new WitObjective (myProblem (), theIdx + 1);
d170 1
a170 1
WitObjective::WitObjective (WitProblem * theProblem, int theSeqNo):
d172 2
a173 1
      WitProbAssoc   (theProblem),
d202 9
@


1.4
log
@Multi-obj mode.
@
text
@d130 20
d192 1
@


1.3
log
@Multi-Obj mode.
@
text
@d31 3
a33 2
      WitProbAssoc  (theProblem),
      myObjectives_ (1)
d35 3
a37 1
   myObjectives_[0] = new WitObjective (myProblem (), 1);
d55 2
d65 11
d87 2
d105 6
a110 1
   }
d125 1
a125 1
   myMsgFac () ("blankMsg");
d134 2
@


1.2
log
@multi-objective mode
@
text
@d23 1
d34 1
a34 1
   myObjectives_[0] = new WitObjective (myProblem ());
d58 1
a58 1
      myObjectives_[theIdx] = new WitObjective (myProblem ());
d81 1
a81 1
void WitMultiObjMgr::writeData ()
a82 3
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

a86 2

   myDataWriter ()->writeEndCommand ();
d91 1
a91 1
void WitMultiObjMgr::writeDataAttrs ()
d93 10
a102 4
   myDataWriter ()->writeInt (
        "nObjectives",
         nObjectives (),
      defNObjectives ());
d125 1
a125 1
WitObjective::WitObjective (WitProblem * theProblem):
d127 2
a128 1
      WitProbAssoc (theProblem)
d130 5
d148 7
@


1.1
log
@Multi-objective mode.
@
text
@d95 10
@


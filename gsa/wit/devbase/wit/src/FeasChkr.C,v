head	1.25;
access;
symbols
	sce_5_01_20080919:1.15;
locks; strict;
comment	@ * @;


1.25
date	2011.09.28.23.49.21;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2011.09.24.00.27.40;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2011.08.30.20.17.30;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.17.22.20.52;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.17.16.36.40;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.16.22.40.25;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.10.22.10.38;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.16.22.42.25;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.03.20.10.28;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.03.19.16.49;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.12.06.22.53.01;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.07.21.50.12;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.09.19.10.58;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.08.17.02.54;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.05.21.01.51;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.02.22.11.01;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.02.20.56.21;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.27.21.03.03;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.27.20.19.29;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.27.19.55.08;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.06.19.52.46;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.01.21.36.34;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.01.19.55.17;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.22.22.54.29;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.22.21.45.06;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "FeasChkr.C"
//
// Contains the implementation of the following class:
//
//    FeasChkr
//------------------------------------------------------------------------------

#include <FeasChkr.h>
#include <Post.h>
#include <OptComp.h>
#include <GlobalComp.h>
#include <Material.h>
#include <Operation.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <Demand.h>
#include <BoundSet.h>
#include <CompMgr.h>
#include <wit/src/Variant.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class FeasChkr.
//------------------------------------------------------------------------------

WitFeasChkr::WitFeasChkr (WitProblem * theProblem):

      WitProbAssoc  (theProblem),

      maxViolation_ (0.0)
   {
   }

//------------------------------------------------------------------------------

WitFeasChkr::~WitFeasChkr ()
   {
   }

//------------------------------------------------------------------------------

void WitFeasChkr::compFeasible ()
   {
   maxViolation_ = 0.0;

   checkFeasReq ();

   if (myProblem ()->currentVariant ()->respectsOptCons ())
      checkFeasAllBounds ();
   else
      checkFeasLimitedBounds ();

   if (myProblem ()->currentVariant ()->respectsLotSizes ())
      checkFeasLotSizes ();

   if (myProblem ()->currentVariant ()->respectsOptCons ())
      {
      checkDisScrap ();

      checkIntegrality ();
      }

   if (DEVELOPMENT)
      myMsgFac () ("maxViolationMsg", maxViolation ());

   myGlobalComp ()->storePostFeasible (maxViolation_ <= FEAS_TOL);

   if (not myGlobalComp ()->feasible ())
      {
      if (myProblem ()->extOptVariant ()->isCurrent ())
         myMsgFac () ("infeasExtOptWmsg", maxViolation ());

      else if (DEVELOPMENT)
         if (myProblem ()->currentVariant ()->internalSoln ())
            myMsgFac () (
               "infeasWmsg",
               myMsgFac ().myFrag (
                  myProblem ()->currentVariant ()->myFragID ()),
                  maxViolation ());
      }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::unpostprocess ()
   {
   maxViolation_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitFeasChkr::verifyUhsFeas ()
   {
   stronglyAssert (myGlobalComp ()->userHeurStart ());

   verifyUhsNonExecCon   ();
   verifyUhsSubCon       ();
   verifyUhsCumDemandCon ();
   verifyUhsExecHUBCon   ();
   verifyUhsLotSizeCon   ();
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkFeasReq ()
   {
   checkScrapVolNonneg   ();
   checkStockVolNonneg   ();
   checkExecVolNonneg    ();
   checkSubVolNonneg     ();
   checkShipVolNonneg    ();
   checkCumShipVolNonneg ();

   checkStockVols        ();
   checkExecVols         ();
   checkNonSubVols       ();
   checkShipVols         ();
   checkCumShipVols      ();
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkScrapVolNonneg ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - thePart->scrapVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "scrapVol");

            myMsgFac () ("maxViolObjectMsg", "Part:", thePart->partName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkStockVolNonneg ()
   {
   WitMaterial * theMat;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachMaterial (theMat, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theMat->stockVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "stockVol");

            myMsgFac () ("maxViolObjectMsg", "Part:", theMat->partName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkExecVolNonneg ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theOpn->execVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "execVol");

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theOpn->operationName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkSubVolNonneg ()
   {
   WitSubEntry * theSub;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theSub->subVol()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "subVol");

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theSub->myOperationName ());

            myMsgFac () ("maxViolIndexMsg",
               "BOM Entry #:",
               theSub->myBomEnt ()->localIndex ());

            myMsgFac () ("maxViolIndexMsg",
               "Sub Entry #:",
               theSub->localIndex ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkShipVolNonneg ()
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theViol = - theDemand->shipVol ()[shipPer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "shipVol");

            myMsgFac () ("maxViolObjectMsg",
               "Part:",
               theDemand->demandedPartName ());

            myMsgFac () ("maxViolObjectMsg",
               "Demand:",
               theDemand->demandName ());

            myMsgFac () ("maxViolPeriodMsg", shipPer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkCumShipVolNonneg ()
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theViol = - theDemand->cumShipVol ()[shipPer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "cumShipVol");

            myMsgFac () ("maxViolObjectMsg",
               "Part:",
               theDemand->demandedPartName ());

            myMsgFac () ("maxViolObjectMsg",
               "Demand:",
               theDemand->demandName ());

            myMsgFac () ("maxViolPeriodMsg", shipPer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkStockVols ()
   {
   WitMaterial * theMat;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachMaterial (theMat, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theMat->canStock (thePer))
            {
            theViol = theMat->stockVol ()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolMandECFrag"));

               myMsgFac () ("maxViolObjectMsg", "Part:", theMat->partName ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkExecVols ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theOpn->executable ()[thePer])
            {
            theViol = theOpn->execVol ()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolExecutableFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theOpn->operationName ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkNonSubVols ()
   {
   WitBomEntry * theBomEnt;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         forEachPeriod (thePer, myProblem ())
            {
            theViol = - theBomEnt->nonSubVol()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolTotSubVolFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theBomEnt->myOperationName ());

               myMsgFac () ("maxViolIndexMsg",
                  "BOM Entry #:",
                  theBomEnt->localIndex ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkShipVols ()
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      if (not theDemand->shipLateAllowed ())
         forEachPeriod (shipPer, myProblem ())
            {
            theViol = 
                 theDemand->shipVol   ()[shipPer]
               - theDemand->demandVol ()[shipPer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolShipVolFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  theDemand->demandedPartName ());

               myMsgFac () ("maxViolObjectMsg",
                  "Demand:",
                  theDemand->demandName ());

               myMsgFac () ("maxViolPeriodMsg", shipPer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkCumShipVols ()
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      if (theDemand->shipLateAllowed ())
         forEachPeriod (shipPer, myProblem ())
            {
            theViol = 
                 theDemand->cumShipVol   ()[shipPer]
               - theDemand->cumDemandVol ()[shipPer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolCumShipVolFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  theDemand->demandedPartName ());

               myMsgFac () ("maxViolObjectMsg",
                  "Demand:",
                  theDemand->demandName ());

               myMsgFac () ("maxViolPeriodMsg", shipPer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkFeasAllBounds ()
   {
   WitComponent * theComp;
   WitBoundSet *  theBoundSet;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      theBoundSet = theComp->myBoundSet ();

      if (theBoundSet != NULL)
         {
         checkFeasHardLB (theBoundSet);
         checkFeasHardUB (theBoundSet);
         }
      }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkFeasLimitedBounds ()
   {
   WitOperation * theOpn;

   forEachOperation (theOpn, myProblem ())
      checkFeasHardUB (theOpn->execBounds ());
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkFeasHardLB (WitBoundSet * theBoundSet)
   {
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPeriod (thePer, myProblem ())
      {
      theViol = 
           theBoundSet->hardLB ()  [thePer]
         - theBoundSet->boundedVal (thePer);

      recordViolation (theViol, reportNeeded);

      if (reportNeeded)
         {
         myMsgFac () ("maxViolConstraintMsg",
            myMsgFac ().myFrag ("maxViolHardLBFrag"));

         myMsgFac () ("maxViolIndexMsg",
            "Boundset #:",
            theBoundSet->mappingIndex ());

         myMsgFac () ("maxViolPeriodMsg", thePer);
         }
      }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkFeasHardUB (WitBoundSet * theBoundSet)
   {
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPeriod (thePer, myProblem ())
      if (theBoundSet->hardUBIsFinite (thePer))
         {
         theViol = 
              theBoundSet->boundedVal (thePer)
            - theBoundSet->hardUB ()  [thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("maxViolConstraintMsg",
               myMsgFac ().myFrag ("maxViolHardUBFrag"));

            myMsgFac () ("maxViolIndexMsg",
               "Boundset #:",
               theBoundSet->mappingIndex ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkFeasLotSizes ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         theViol = lotSizeViol (theOpn, execPer);

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("maxViolConstraintMsg",
               myMsgFac ().myFrag ("maxViolLotSizeFrag"));

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theOpn->operationName ());

            myMsgFac () ("maxViolPeriodMsg", execPer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkDisScrap ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPart (thePart, myProblem ())
      if (not thePart->scrapAllowed ())
         forEachPeriod (thePer, myProblem ())
            {
            theViol = thePart->scrapVol ()[thePer];
            
            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("disScrapConstraintViolMsg");

               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  thePart->partName ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkIntegrality ()
   {
   if (not myOptComp ()->mipMode ())
      return;

   checkExecVolInt ();
   checkSubVolInt  ();
   checkShipVolInt ();
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkExecVolInt ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->intExecVols ())
         forEachPeriod (execPer, myProblem ())
            {
            theViol = integralityViol (theOpn->execVol ()[execPer]);

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("intConstraintViolMsg", "execVol");

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theOpn->operationName ());

               myMsgFac () ("maxViolPeriodMsg", execPer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkSubVolInt ()
   {
   WitSubEntry * theSub;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachSubEntry (theSub, myProblem ())
      if (theSub->intSubVols ())
         forEachPeriod (thePer, myProblem ())
            {
            theViol = integralityViol (theSub->subVol()[thePer]);

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("intConstraintViolMsg", "subVol");

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theSub->myOperationName ());

               myMsgFac () ("maxViolIndexMsg",
                  "BOM Entry #:",
                  theSub->myBomEnt ()->localIndex ());

               myMsgFac () ("maxViolIndexMsg",
                  "Sub Entry #:",
                  theSub->localIndex ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::checkShipVolInt ()
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      if (theDemand->intShipVols ())
         forEachPeriod (shipPer, myProblem ())
            {
            theViol = integralityViol (theDemand->shipVol ()[shipPer]);

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("intConstraintViolMsg", "shipVol");

               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  theDemand->demandedPartName ());

               myMsgFac () ("maxViolObjectMsg",
                  "Demand:",
                  theDemand->demandName ());

               myMsgFac () ("maxViolPeriodMsg", shipPer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::recordViolation (
      double theViolation,
      bool & reportNeeded)
   {
   reportNeeded = false;

   if (theViolation > maxViolation_)
      {
      maxViolation_ = theViolation;

      if (theViolation > FEAS_TOL)
         {
         myMsgFac () ("maxViolHeadingMsg", FEAS_TOL);
         myMsgFac () ("maxViolViolMsg",    theViolation);

         reportNeeded = true;
         }
      }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::verifyUhsNonExecCon ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theOpn->executable ()[thePer])
            if (theOpn->execVol ()[thePer] > 0.0)
               myMsgFac () ("uhsNonExecConViolSmsg", 
                  theOpn->operationName (),
                  thePer,
                  theOpn->execVol ()[thePer]);
   }

//------------------------------------------------------------------------------

void WitFeasChkr::verifyUhsSubCon ()
   {
   WitTVec <double> nonSubVolVec;
   WitBomEntry *    theBomEnt;
   WitPeriod        thePer;
   double           maxViol;
   WitBomEntry *    mvBomEnt;
   WitPeriod        mvPer;

   nonSubVolVec.allocate (myProblem (), 0.0);

   maxViol  = FEAS_TOL;
   mvBomEnt = NULL;
   mvPer    = -1;

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         {
         myPostprocessor ()->compNonSubVol (theBomEnt, nonSubVolVec);

         forEachPeriod (thePer, myProblem ())
            if (- nonSubVolVec[thePer] > maxViol)
               {
               maxViol  = - nonSubVolVec[thePer];
               mvBomEnt = theBomEnt;
               mvPer    = thePer;
               }
         }

   if (mvBomEnt != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsSubConViolWmsg",
         maxViol,
         mvBomEnt->myOperationName (),
         mvBomEnt->localIndex (),
         mvPer,
         mvBomEnt->myOperation ()->execVol ()[mvPer],
         mvBomEnt->myOperation ()->execVol ()[mvPer] + maxViol);
      }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::verifyUhsCumDemandCon ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      cumDemandVolVal;
   double      cumShipVolVal;
   double      maxViol;
   WitDemand * mvDemand;
   WitPeriod   mvPer;
   double      mvCumDemVol;

   maxViol     = FEAS_TOL;
   mvDemand    = NULL;
   mvPer       = -1;
   mvCumDemVol = 0.0;

   forEachDemand (theDemand, myProblem ())
      {
      cumDemandVolVal = 0.0;
      cumShipVolVal   = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumDemandVolVal += theDemand->demandVol ()[thePer];
         cumShipVolVal   += theDemand->shipVol ()[thePer];

         if (cumShipVolVal - cumDemandVolVal > maxViol)
            {
            maxViol     = cumShipVolVal - cumDemandVolVal;
            mvDemand    = theDemand;
            mvPer       = thePer;
            mvCumDemVol = cumDemandVolVal;
            }
         }
      }

   if (mvDemand != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsCumDemandConViolWmsg",
         maxViol,
         mvDemand->demandedPartName (),
         mvDemand->demandName (),
         mvPer,
         mvCumDemVol + maxViol,
         mvCumDemVol);
      }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::verifyUhsExecHUBCon ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         hardUBVal;
   double         maxViol;
   WitOperation * mvOpn;
   WitPeriod      mvPer;

   maxViol = FEAS_TOL;
   mvOpn   = NULL;
   mvPer   = -1;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theOpn->execBounds ()->hardUBIsFinite (thePer))
            {
            hardUBVal = theOpn->execBounds ()->hardUB ()[thePer];

            if (theOpn->execVol ()[thePer] - hardUBVal > maxViol)
               {
               maxViol = theOpn->execVol ()[thePer] - hardUBVal;
               mvOpn   = theOpn;
               mvPer   = thePer;
               }
            }

   if (mvOpn != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsExecHUBConViolWmsg",
         maxViol,
         mvOpn->operationName (),
         mvPer,
         mvOpn->execVol ()[mvPer],
         mvOpn->execBounds ()->hardUB ()[mvPer]);
      }
   }

//------------------------------------------------------------------------------

void WitFeasChkr::verifyUhsLotSizeCon ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         maxViol;
   WitOperation * mvOpn;
   WitPeriod      mvPer;

   maxViol = FEAS_TOL;
   mvOpn   = NULL;
   mvPer   = -1;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (lotSizeViol (theOpn, execPer) > maxViol)
            {
            maxViol = lotSizeViol (theOpn, execPer);
            mvOpn   = theOpn;
            mvPer   = execPer;
            }

   if (mvOpn != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsLotSizeConViolWmsg",
         maxViol,
         mvOpn->operationName (),
         mvPer,
         mvOpn->execVol ()[mvPer]);
      }
   }

//------------------------------------------------------------------------------

double WitFeasChkr::lotSizeViol (WitOperation * theOpn, WitPeriod execPer)
   {
   double theExecVol;
   double lsDelta;

   theExecVol = theOpn->execVol ()[execPer];

   lsDelta    = theOpn->lotSizeDelta (execPer, theExecVol, 0.0);

   return positivePart (lsDelta);
   }

//------------------------------------------------------------------------------

double WitFeasChkr::integralityViol (double theValue)
   {
   return
      min (      theValue  - floor (theValue),
           ceil (theValue) -        theValue);
   }
@


1.24
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.23
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d39 1
a39 1
WitProbAssoc  (theProblem),
d41 3
a43 3
maxViolation_ (0.0)
{
}
d48 2
a49 2
{
}
d54 2
a55 2
{
maxViolation_ = 0.0;
d57 1
a57 1
checkFeasReq ();
d59 34
a92 34
if (myProblem ()->currentVariant ()->respectsOptCons ())
checkFeasAllBounds ();
else
checkFeasLimitedBounds ();

if (myProblem ()->currentVariant ()->respectsLotSizes ())
checkFeasLotSizes ();

if (myProblem ()->currentVariant ()->respectsOptCons ())
{
checkDisScrap ();

checkIntegrality ();
}

if (DEVELOPMENT)
myMsgFac () ("maxViolationMsg", maxViolation ());

myGlobalComp ()->storePostFeasible (maxViolation_ <= FEAS_TOL);

if (not myGlobalComp ()->feasible ())
{
if (myProblem ()->extOptVariant ()->isCurrent ())
myMsgFac () ("infeasExtOptWmsg", maxViolation ());

else if (DEVELOPMENT)
if (myProblem ()->currentVariant ()->internalSoln ())
myMsgFac () (
"infeasWmsg",
myMsgFac ().myFrag (
myProblem ()->currentVariant ()->myFragID ()),
maxViolation ());
}
}
d97 3
a99 3
{
maxViolation_ = 0.0;
}
d104 2
a105 2
{
stronglyAssert (myGlobalComp ()->userHeurStart ());
d107 6
a112 6
verifyUhsNonExecCon   ();
verifyUhsSubCon       ();
verifyUhsCumDemandCon ();
verifyUhsExecHUBCon   ();
verifyUhsLotSizeCon   ();
}
d117 14
a130 14
{
checkScrapVolNonneg   ();
checkStockVolNonneg   ();
checkExecVolNonneg    ();
checkSubVolNonneg     ();
checkShipVolNonneg    ();
checkCumShipVolNonneg ();

checkStockVols        ();
checkExecVols         ();
checkNonSubVols       ();
checkShipVols         ();
checkCumShipVols      ();
}
d135 23
a157 23
{
WitPart * thePart;
WitPeriod thePer;
double    theViol;
bool      reportNeeded;

forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
{
theViol = - thePart->scrapVol ()[thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("nonnegConstraintViolMsg", "scrapVol");

myMsgFac () ("maxViolObjectMsg", "Part:", thePart->partName ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d162 23
a184 23
{
WitMaterial * theMat;
WitPeriod     thePer;
double        theViol;
bool          reportNeeded;

forEachMaterial (theMat, myProblem ())
forEachPeriod (thePer, myProblem ())
{
theViol = - theMat->stockVol ()[thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("nonnegConstraintViolMsg", "stockVol");

myMsgFac () ("maxViolObjectMsg", "Part:", theMat->partName ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d189 25
a213 25
{
WitOperation * theOpn;
WitPeriod      thePer;
double         theViol;
bool           reportNeeded;

forEachOperation (theOpn, myProblem ())
forEachPeriod (thePer, myProblem ())
{
theViol = - theOpn->execVol ()[thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("nonnegConstraintViolMsg", "execVol");

myMsgFac () ("maxViolObjectMsg",
"Operation:",
theOpn->operationName ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d218 33
a250 33
{
WitSubEntry * theSub;
WitPeriod     thePer;
double        theViol;
bool          reportNeeded;

forEachSubEntry (theSub, myProblem ())
forEachPeriod (thePer, myProblem ())
{
theViol = - theSub->subVol()[thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("nonnegConstraintViolMsg", "subVol");

myMsgFac () ("maxViolObjectMsg",
"Operation:",
theSub->myOperationName ());

myMsgFac () ("maxViolIndexMsg",
"BOM Entry #:",
theSub->myBomEnt ()->localIndex ());

myMsgFac () ("maxViolIndexMsg",
"Sub Entry #:",
theSub->localIndex ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d255 29
a283 29
{
WitDemand * theDemand;
WitPeriod   shipPer;
double      theViol;
bool        reportNeeded;

forEachDemand (theDemand, myProblem ())
forEachPeriod (shipPer, myProblem ())
{
theViol = - theDemand->shipVol ()[shipPer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("nonnegConstraintViolMsg", "shipVol");

myMsgFac () ("maxViolObjectMsg",
"Part:",
theDemand->demandedPartName ());

myMsgFac () ("maxViolObjectMsg",
"Demand:",
theDemand->demandName ());

myMsgFac () ("maxViolPeriodMsg", shipPer);
}
}
}
d288 29
a316 29
{
WitDemand * theDemand;
WitPeriod   shipPer;
double      theViol;
bool        reportNeeded;

forEachDemand (theDemand, myProblem ())
forEachPeriod (shipPer, myProblem ())
{
theViol = - theDemand->cumShipVol ()[shipPer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("nonnegConstraintViolMsg", "cumShipVol");

myMsgFac () ("maxViolObjectMsg",
"Part:",
theDemand->demandedPartName ());

myMsgFac () ("maxViolObjectMsg",
"Demand:",
theDemand->demandName ());

myMsgFac () ("maxViolPeriodMsg", shipPer);
}
}
}
d321 25
a345 25
{
WitMaterial * theMat;
WitPeriod     thePer;
double        theViol;
bool          reportNeeded;

forEachMaterial (theMat, myProblem ())
forEachPeriod (thePer, myProblem ())
if (not theMat->canStock (thePer))
{
theViol = theMat->stockVol ()[thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("maxViolConstraintMsg",
myMsgFac ().myFrag ("maxViolMandECFrag"));

myMsgFac () ("maxViolObjectMsg", "Part:", theMat->partName ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d350 27
a376 27
{
WitOperation * theOpn;
WitPeriod      thePer;
double         theViol;
bool           reportNeeded;

forEachOperation (theOpn, myProblem ())
forEachPeriod (thePer, myProblem ())
if (not theOpn->executable ()[thePer])
{
theViol = theOpn->execVol ()[thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("maxViolConstraintMsg",
myMsgFac ().myFrag ("maxViolExecutableFrag"));

myMsgFac () ("maxViolObjectMsg",
"Operation:",
theOpn->operationName ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d381 31
a411 31
{
WitBomEntry * theBomEnt;
WitPeriod     thePer;
double        theViol;
bool          reportNeeded;

forEachBomEntry (theBomEnt, myProblem ())
if (not theBomEnt->mySubEntries ().isEmpty ())
forEachPeriod (thePer, myProblem ())
{
theViol = - theBomEnt->nonSubVol()[thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("maxViolConstraintMsg",
myMsgFac ().myFrag ("maxViolTotSubVolFrag"));

myMsgFac () ("maxViolObjectMsg",
"Operation:",
theBomEnt->myOperationName ());

myMsgFac () ("maxViolIndexMsg",
"BOM Entry #:",
theBomEnt->localIndex ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d416 33
a448 33
{
WitDemand * theDemand;
WitPeriod   shipPer;
double      theViol;
bool        reportNeeded;

forEachDemand (theDemand, myProblem ())
if (not theDemand->shipLateAllowed ())
forEachPeriod (shipPer, myProblem ())
{
theViol =
theDemand->shipVol   ()[shipPer]
- theDemand->demandVol ()[shipPer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("maxViolConstraintMsg",
myMsgFac ().myFrag ("maxViolShipVolFrag"));

myMsgFac () ("maxViolObjectMsg",
"Part:",
theDemand->demandedPartName ());

myMsgFac () ("maxViolObjectMsg",
"Demand:",
theDemand->demandName ());

myMsgFac () ("maxViolPeriodMsg", shipPer);
}
}
}
d453 33
a485 33
{
WitDemand * theDemand;
WitPeriod   shipPer;
double      theViol;
bool        reportNeeded;

forEachDemand (theDemand, myProblem ())
if (theDemand->shipLateAllowed ())
forEachPeriod (shipPer, myProblem ())
{
theViol =
theDemand->cumShipVol   ()[shipPer]
- theDemand->cumDemandVol ()[shipPer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("maxViolConstraintMsg",
myMsgFac ().myFrag ("maxViolCumShipVolFrag"));

myMsgFac () ("maxViolObjectMsg",
"Part:",
theDemand->demandedPartName ());

myMsgFac () ("maxViolObjectMsg",
"Demand:",
theDemand->demandName ());

myMsgFac () ("maxViolPeriodMsg", shipPer);
}
}
}
d490 15
a504 15
{
WitComponent * theComp;
WitBoundSet *  theBoundSet;

forEachEl (theComp, myCompMgr ()->allComponents ())
{
theBoundSet = theComp->myBoundSet ();

if (theBoundSet != NULL)
{
checkFeasHardLB (theBoundSet);
checkFeasHardUB (theBoundSet);
}
}
}
d509 2
a510 2
{
WitOperation * theOpn;
d512 3
a514 3
forEachOperation (theOpn, myProblem ())
checkFeasHardUB (theOpn->execBounds ());
}
d519 26
a544 26
{
WitPeriod thePer;
double    theViol;
bool      reportNeeded;

forEachPeriod (thePer, myProblem ())
{
theViol =
theBoundSet->hardLB ()  [thePer]
- theBoundSet->boundedVal (thePer);

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("maxViolConstraintMsg",
myMsgFac ().myFrag ("maxViolHardLBFrag"));

myMsgFac () ("maxViolIndexMsg",
"Boundset #:",
theBoundSet->mappingIndex ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d549 27
a575 27
{
WitPeriod thePer;
double    theViol;
bool      reportNeeded;

forEachPeriod (thePer, myProblem ())
if (theBoundSet->hardUBIsFinite (thePer))
{
theViol =
theBoundSet->boundedVal (thePer)
- theBoundSet->hardUB ()  [thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("maxViolConstraintMsg",
myMsgFac ().myFrag ("maxViolHardUBFrag"));

myMsgFac () ("maxViolIndexMsg",
"Boundset #:",
theBoundSet->mappingIndex ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d580 26
a605 26
{
WitOperation * theOpn;
WitPeriod      execPer;
double         theViol;
bool           reportNeeded;

forEachOperation (theOpn, myProblem ())
forEachPeriod (execPer, myProblem ())
{
theViol = lotSizeViol (theOpn, execPer);

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("maxViolConstraintMsg",
myMsgFac ().myFrag ("maxViolLotSizeFrag"));

myMsgFac () ("maxViolObjectMsg",
"Operation:",
theOpn->operationName ());

myMsgFac () ("maxViolPeriodMsg", execPer);
}
}
}
d610 26
a635 26
{
WitPart * thePart;
WitPeriod thePer;
double    theViol;
bool      reportNeeded;

forEachPart (thePart, myProblem ())
if (not thePart->scrapAllowed ())
forEachPeriod (thePer, myProblem ())
{
theViol = thePart->scrapVol ()[thePer];

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("disScrapConstraintViolMsg");

myMsgFac () ("maxViolObjectMsg",
"Part:",
thePart->partName ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d640 8
a647 8
{
if (not myOptComp ()->mipMode ())
return;

checkExecVolInt ();
checkSubVolInt  ();
checkShipVolInt ();
}
d652 26
a677 26
{
WitOperation * theOpn;
WitPeriod      execPer;
double         theViol;
bool           reportNeeded;

forEachOperation (theOpn, myProblem ())
if (theOpn->intExecVols ())
forEachPeriod (execPer, myProblem ())
{
theViol = integralityViol (theOpn->execVol ()[execPer]);

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("intConstraintViolMsg", "execVol");

myMsgFac () ("maxViolObjectMsg",
"Operation:",
theOpn->operationName ());

myMsgFac () ("maxViolPeriodMsg", execPer);
}
}
}
d682 34
a715 34
{
WitSubEntry * theSub;
WitPeriod     thePer;
double        theViol;
bool          reportNeeded;

forEachSubEntry (theSub, myProblem ())
if (theSub->intSubVols ())
forEachPeriod (thePer, myProblem ())
{
theViol = integralityViol (theSub->subVol()[thePer]);

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("intConstraintViolMsg", "subVol");

myMsgFac () ("maxViolObjectMsg",
"Operation:",
theSub->myOperationName ());

myMsgFac () ("maxViolIndexMsg",
"BOM Entry #:",
theSub->myBomEnt ()->localIndex ());

myMsgFac () ("maxViolIndexMsg",
"Sub Entry #:",
theSub->localIndex ());

myMsgFac () ("maxViolPeriodMsg", thePer);
}
}
}
d720 30
a749 30
{
WitDemand * theDemand;
WitPeriod   shipPer;
double      theViol;
bool        reportNeeded;

forEachDemand (theDemand, myProblem ())
if (theDemand->intShipVols ())
forEachPeriod (shipPer, myProblem ())
{
theViol = integralityViol (theDemand->shipVol ()[shipPer]);

recordViolation (theViol, reportNeeded);

if (reportNeeded)
{
myMsgFac () ("intConstraintViolMsg", "shipVol");

myMsgFac () ("maxViolObjectMsg",
"Part:",
theDemand->demandedPartName ());

myMsgFac () ("maxViolObjectMsg",
"Demand:",
theDemand->demandName ());

myMsgFac () ("maxViolPeriodMsg", shipPer);
}
}
}
d754 18
a771 18
double theViolation,
bool & reportNeeded)
{
reportNeeded = false;

if (theViolation > maxViolation_)
{
maxViolation_ = theViolation;

if (theViolation > FEAS_TOL)
{
myMsgFac () ("maxViolHeadingMsg", FEAS_TOL);
myMsgFac () ("maxViolViolMsg",    theViolation);

reportNeeded = true;
}
}
}
d776 13
a788 13
{
WitOperation * theOpn;
WitPeriod      thePer;

forEachOperation (theOpn, myProblem ())
forEachPeriod (thePer, myProblem ())
if (not theOpn->executable ()[thePer])
if (theOpn->execVol ()[thePer] > 0.0)
myMsgFac () ("uhsNonExecConViolSmsg",
theOpn->operationName (),
thePer,
theOpn->execVol ()[thePer]);
}
d793 41
a833 41
{
WitTVec <double> nonSubVolVec;
WitBomEntry *    theBomEnt;
WitPeriod        thePer;
double           maxViol;
WitBomEntry *    mvBomEnt;
WitPeriod        mvPer;

nonSubVolVec.allocate (myProblem (), 0.0);

maxViol  = FEAS_TOL;
mvBomEnt = NULL;
mvPer    = -1;

forEachBomEntry (theBomEnt, myProblem ())
if (not theBomEnt->mySubEntries ().isEmpty ())
{
myPostprocessor ()->compNonSubVol (theBomEnt, nonSubVolVec);

forEachPeriod (thePer, myProblem ())
if (- nonSubVolVec[thePer] > maxViol)
{
maxViol  = - nonSubVolVec[thePer];
mvBomEnt = theBomEnt;
mvPer    = thePer;
}
}

if (mvBomEnt != NULL)
{
myMsgFac () ("uhsConViolIntroWmsg");

myMsgFac () ("uhsSubConViolWmsg",
maxViol,
mvBomEnt->myOperationName (),
mvBomEnt->localIndex (),
mvPer,
mvBomEnt->myOperation ()->execVol ()[mvPer],
mvBomEnt->myOperation ()->execVol ()[mvPer] + maxViol);
}
}
d838 48
a885 48
{
WitDemand * theDemand;
WitPeriod   thePer;
double      cumDemandVolVal;
double      cumShipVolVal;
double      maxViol;
WitDemand * mvDemand;
WitPeriod   mvPer;
double      mvCumDemVol;

maxViol     = FEAS_TOL;
mvDemand    = NULL;
mvPer       = -1;
mvCumDemVol = 0.0;

forEachDemand (theDemand, myProblem ())
{
cumDemandVolVal = 0.0;
cumShipVolVal   = 0.0;

forEachPeriod (thePer, myProblem ())
{
cumDemandVolVal += theDemand->demandVol ()[thePer];
cumShipVolVal   += theDemand->shipVol ()[thePer];

if (cumShipVolVal - cumDemandVolVal > maxViol)
{
maxViol     = cumShipVolVal - cumDemandVolVal;
mvDemand    = theDemand;
mvPer       = thePer;
mvCumDemVol = cumDemandVolVal;
}
}
}

if (mvDemand != NULL)
{
myMsgFac () ("uhsConViolIntroWmsg");

myMsgFac () ("uhsCumDemandConViolWmsg",
maxViol,
mvDemand->demandedPartName (),
mvDemand->demandName (),
mvPer,
mvCumDemVol + maxViol,
mvCumDemVol);
}
}
d890 38
a927 38
{
WitOperation * theOpn;
WitPeriod      thePer;
double         hardUBVal;
double         maxViol;
WitOperation * mvOpn;
WitPeriod      mvPer;

maxViol = FEAS_TOL;
mvOpn   = NULL;
mvPer   = -1;

forEachOperation (theOpn, myProblem ())
forEachPeriod (thePer, myProblem ())
if (theOpn->execBounds ()->hardUBIsFinite (thePer))
{
hardUBVal = theOpn->execBounds ()->hardUB ()[thePer];

if (theOpn->execVol ()[thePer] - hardUBVal > maxViol)
{
maxViol = theOpn->execVol ()[thePer] - hardUBVal;
mvOpn   = theOpn;
mvPer   = thePer;
}
}

if (mvOpn != NULL)
{
myMsgFac () ("uhsConViolIntroWmsg");

myMsgFac () ("uhsExecHUBConViolWmsg",
maxViol,
mvOpn->operationName (),
mvPer,
mvOpn->execVol ()[mvPer],
mvOpn->execBounds ()->hardUB ()[mvPer]);
}
}
d932 31
a962 31
{
WitOperation * theOpn;
WitPeriod      execPer;
double         maxViol;
WitOperation * mvOpn;
WitPeriod      mvPer;

maxViol = FEAS_TOL;
mvOpn   = NULL;
mvPer   = -1;

forEachOperation (theOpn, myProblem ())
forEachPeriod (execPer, myProblem ())
if (lotSizeViol (theOpn, execPer) > maxViol)
{
maxViol = lotSizeViol (theOpn, execPer);
mvOpn   = theOpn;
mvPer   = execPer;
}

if (mvOpn != NULL)
{
myMsgFac () ("uhsConViolIntroWmsg");

myMsgFac () ("uhsLotSizeConViolWmsg",
maxViol,
mvOpn->operationName (),
mvPer,
mvOpn->execVol ()[mvPer]);
}
}
d967 3
a969 3
{
double theExecVol;
double lsDelta;
d971 1
a971 1
theExecVol = theOpn->execVol ()[execPer];
d973 1
a973 1
lsDelta    = theOpn->lotSizeDelta (execPer, theExecVol, 0.0);
d975 2
a976 2
return positivePart (lsDelta);
}
d981 5
a985 5
{
return
min (      theValue  - floor (theValue),
ceil (theValue) -        theValue);
}
@


1.22
log
@Heuristic Adjustment
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d39 1
a39 1
      WitProbAssoc  (theProblem),
d41 3
a43 3
      maxViolation_ (0.0)
   {
   }
d48 2
a49 2
   {
   }
d54 2
a55 2
   {
   maxViolation_ = 0.0;
d57 1
a57 1
   checkFeasReq ();
d59 34
a92 34
   if (myProblem ()->currentVariant ()->respectsOptCons ())
      checkFeasAllBounds ();
   else
      checkFeasLimitedBounds ();

   if (myProblem ()->currentVariant ()->respectsLotSizes ())
      checkFeasLotSizes ();

   if (myProblem ()->currentVariant ()->respectsOptCons ())
      {
      checkDisScrap ();

      checkIntegrality ();
      }

   if (DEVELOPMENT)
      myMsgFac () ("maxViolationMsg", maxViolation ());

   myGlobalComp ()->storePostFeasible (maxViolation_ <= FEAS_TOL);

   if (not myGlobalComp ()->feasible ())
      {
      if (myProblem ()->extOptVariant ()->isCurrent ())
         myMsgFac () ("infeasExtOptWmsg", maxViolation ());

      else if (DEVELOPMENT)
         if (myProblem ()->currentVariant ()->internalSoln ())
            myMsgFac () (
               "infeasWmsg",
               myMsgFac ().myFrag (
                  myProblem ()->currentVariant ()->myFragID ()),
                  maxViolation ());
      }
   }
d97 3
a99 3
   {
   maxViolation_ = 0.0;
   }
d104 2
a105 2
   {
   stronglyAssert (myGlobalComp ()->userHeurStart ());
d107 6
a112 6
   verifyUhsNonExecCon   ();
   verifyUhsSubCon       ();
   verifyUhsCumDemandCon ();
   verifyUhsExecHUBCon   ();
   verifyUhsLotSizeCon   ();
   }
d117 14
a130 14
   {
   checkScrapVolNonneg   ();
   checkStockVolNonneg   ();
   checkExecVolNonneg    ();
   checkSubVolNonneg     ();
   checkShipVolNonneg    ();
   checkCumShipVolNonneg ();

   checkStockVols        ();
   checkExecVols         ();
   checkNonSubVols       ();
   checkShipVols         ();
   checkCumShipVols      ();
   }
d135 23
a157 23
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - thePart->scrapVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "scrapVol");

            myMsgFac () ("maxViolObjectMsg", "Part:", thePart->partName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }
d162 23
a184 23
   {
   WitMaterial * theMat;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachMaterial (theMat, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theMat->stockVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "stockVol");

            myMsgFac () ("maxViolObjectMsg", "Part:", theMat->partName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }
d189 25
a213 25
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theOpn->execVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "execVol");

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theOpn->operationName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }
d218 33
a250 33
   {
   WitSubEntry * theSub;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theSub->subVol()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "subVol");

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theSub->myOperationName ());

            myMsgFac () ("maxViolIndexMsg",
               "BOM Entry #:",
               theSub->myBomEnt ()->localIndex ());

            myMsgFac () ("maxViolIndexMsg",
               "Sub Entry #:",
               theSub->localIndex ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }
d255 29
a283 29
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theViol = - theDemand->shipVol ()[shipPer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "shipVol");

            myMsgFac () ("maxViolObjectMsg",
               "Part:",
               theDemand->demandedPartName ());

            myMsgFac () ("maxViolObjectMsg",
               "Demand:",
               theDemand->demandName ());

            myMsgFac () ("maxViolPeriodMsg", shipPer);
            }
         }
   }
d288 29
a316 29
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (shipPer, myProblem ())
         {
         theViol = - theDemand->cumShipVol ()[shipPer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "cumShipVol");

            myMsgFac () ("maxViolObjectMsg",
               "Part:",
               theDemand->demandedPartName ());

            myMsgFac () ("maxViolObjectMsg",
               "Demand:",
               theDemand->demandName ());

            myMsgFac () ("maxViolPeriodMsg", shipPer);
            }
         }
   }
d321 25
a345 25
   {
   WitMaterial * theMat;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachMaterial (theMat, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theMat->canStock (thePer))
            {
            theViol = theMat->stockVol ()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolMandECFrag"));

               myMsgFac () ("maxViolObjectMsg", "Part:", theMat->partName ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }
d350 27
a376 27
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theOpn->executable ()[thePer])
            {
            theViol = theOpn->execVol ()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolExecutableFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theOpn->operationName ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }
d381 31
a411 31
   {
   WitBomEntry * theBomEnt;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         forEachPeriod (thePer, myProblem ())
            {
            theViol = - theBomEnt->nonSubVol()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolTotSubVolFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theBomEnt->myOperationName ());

               myMsgFac () ("maxViolIndexMsg",
                  "BOM Entry #:",
                  theBomEnt->localIndex ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }
d416 33
a448 33
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      if (not theDemand->shipLateAllowed ())
         forEachPeriod (shipPer, myProblem ())
            {
            theViol = 
                 theDemand->shipVol   ()[shipPer]
               - theDemand->demandVol ()[shipPer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolShipVolFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  theDemand->demandedPartName ());

               myMsgFac () ("maxViolObjectMsg",
                  "Demand:",
                  theDemand->demandName ());

               myMsgFac () ("maxViolPeriodMsg", shipPer);
               }
            }
   }
d453 33
a485 33
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      if (theDemand->shipLateAllowed ())
         forEachPeriod (shipPer, myProblem ())
            {
            theViol = 
                 theDemand->cumShipVol   ()[shipPer]
               - theDemand->cumDemandVol ()[shipPer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolCumShipVolFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  theDemand->demandedPartName ());

               myMsgFac () ("maxViolObjectMsg",
                  "Demand:",
                  theDemand->demandName ());

               myMsgFac () ("maxViolPeriodMsg", shipPer);
               }
            }
   }
d490 15
a504 15
   {
   WitComponent * theComp;
   WitBoundSet *  theBoundSet;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      theBoundSet = theComp->myBoundSet ();

      if (theBoundSet != NULL)
         {
         checkFeasHardLB (theBoundSet);
         checkFeasHardUB (theBoundSet);
         }
      }
   }
d509 2
a510 2
   {
   WitOperation * theOpn;
d512 3
a514 3
   forEachOperation (theOpn, myProblem ())
      checkFeasHardUB (theOpn->execBounds ());
   }
d519 26
a544 26
   {
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPeriod (thePer, myProblem ())
      {
      theViol = 
           theBoundSet->hardLB ()  [thePer]
         - theBoundSet->boundedVal (thePer);

      recordViolation (theViol, reportNeeded);

      if (reportNeeded)
         {
         myMsgFac () ("maxViolConstraintMsg",
            myMsgFac ().myFrag ("maxViolHardLBFrag"));

         myMsgFac () ("maxViolIndexMsg",
            "Boundset #:",
            theBoundSet->mappingIndex ());

         myMsgFac () ("maxViolPeriodMsg", thePer);
         }
      }
   }
d549 27
a575 27
   {
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPeriod (thePer, myProblem ())
      if (theBoundSet->hardUBIsFinite (thePer))
         {
         theViol = 
              theBoundSet->boundedVal (thePer)
            - theBoundSet->hardUB ()  [thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("maxViolConstraintMsg",
               myMsgFac ().myFrag ("maxViolHardUBFrag"));

            myMsgFac () ("maxViolIndexMsg",
               "Boundset #:",
               theBoundSet->mappingIndex ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }
d580 26
a605 26
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         theViol = lotSizeViol (theOpn, execPer);

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("maxViolConstraintMsg",
               myMsgFac ().myFrag ("maxViolLotSizeFrag"));

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theOpn->operationName ());

            myMsgFac () ("maxViolPeriodMsg", execPer);
            }
         }
   }
d610 26
a635 26
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPart (thePart, myProblem ())
      if (not thePart->scrapAllowed ())
         forEachPeriod (thePer, myProblem ())
            {
            theViol = thePart->scrapVol ()[thePer];
            
            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("disScrapConstraintViolMsg");

               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  thePart->partName ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }
d640 8
a647 8
   {
   if (not myOptComp ()->mipMode ())
      return;

   checkExecVolInt ();
   checkSubVolInt  ();
   checkShipVolInt ();
   }
d652 26
a677 26
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->intExecVols ())
         forEachPeriod (execPer, myProblem ())
            {
            theViol = integralityViol (theOpn->execVol ()[execPer]);

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("intConstraintViolMsg", "execVol");

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theOpn->operationName ());

               myMsgFac () ("maxViolPeriodMsg", execPer);
               }
            }
   }
d682 34
a715 34
   {
   WitSubEntry * theSub;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachSubEntry (theSub, myProblem ())
      if (theSub->intSubVols ())
         forEachPeriod (thePer, myProblem ())
            {
            theViol = integralityViol (theSub->subVol()[thePer]);

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("intConstraintViolMsg", "subVol");

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theSub->myOperationName ());

               myMsgFac () ("maxViolIndexMsg",
                  "BOM Entry #:",
                  theSub->myBomEnt ()->localIndex ());

               myMsgFac () ("maxViolIndexMsg",
                  "Sub Entry #:",
                  theSub->localIndex ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }
d720 30
a749 30
   {
   WitDemand * theDemand;
   WitPeriod   shipPer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      if (theDemand->intShipVols ())
         forEachPeriod (shipPer, myProblem ())
            {
            theViol = integralityViol (theDemand->shipVol ()[shipPer]);

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("intConstraintViolMsg", "shipVol");

               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  theDemand->demandedPartName ());

               myMsgFac () ("maxViolObjectMsg",
                  "Demand:",
                  theDemand->demandName ());

               myMsgFac () ("maxViolPeriodMsg", shipPer);
               }
            }
   }
d754 18
a771 18
      double theViolation,
      bool & reportNeeded)
   {
   reportNeeded = false;

   if (theViolation > maxViolation_)
      {
      maxViolation_ = theViolation;

      if (theViolation > FEAS_TOL)
         {
         myMsgFac () ("maxViolHeadingMsg", FEAS_TOL);
         myMsgFac () ("maxViolViolMsg",    theViolation);

         reportNeeded = true;
         }
      }
   }
d776 13
a788 13
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theOpn->executable ()[thePer])
            if (theOpn->execVol ()[thePer] > 0.0)
               myMsgFac () ("uhsNonExecConViolSmsg", 
                  theOpn->operationName (),
                  thePer,
                  theOpn->execVol ()[thePer]);
   }
d793 41
a833 41
   {
   WitTVec <double> nonSubVolVec;
   WitBomEntry *    theBomEnt;
   WitPeriod        thePer;
   double           maxViol;
   WitBomEntry *    mvBomEnt;
   WitPeriod        mvPer;

   nonSubVolVec.allocate (myProblem (), 0.0);

   maxViol  = FEAS_TOL;
   mvBomEnt = NULL;
   mvPer    = -1;

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         {
         myPostprocessor ()->compNonSubVol (theBomEnt, nonSubVolVec);

         forEachPeriod (thePer, myProblem ())
            if (- nonSubVolVec[thePer] > maxViol)
               {
               maxViol  = - nonSubVolVec[thePer];
               mvBomEnt = theBomEnt;
               mvPer    = thePer;
               }
         }

   if (mvBomEnt != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsSubConViolWmsg",
         maxViol,
         mvBomEnt->myOperationName (),
         mvBomEnt->localIndex (),
         mvPer,
         mvBomEnt->myOperation ()->execVol ()[mvPer],
         mvBomEnt->myOperation ()->execVol ()[mvPer] + maxViol);
      }
   }
d838 48
a885 48
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      cumDemandVolVal;
   double      cumShipVolVal;
   double      maxViol;
   WitDemand * mvDemand;
   WitPeriod   mvPer;
   double      mvCumDemVol;

   maxViol     = FEAS_TOL;
   mvDemand    = NULL;
   mvPer       = -1;
   mvCumDemVol = 0.0;

   forEachDemand (theDemand, myProblem ())
      {
      cumDemandVolVal = 0.0;
      cumShipVolVal   = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumDemandVolVal += theDemand->demandVol ()[thePer];
         cumShipVolVal   += theDemand->shipVol ()[thePer];

         if (cumShipVolVal - cumDemandVolVal > maxViol)
            {
            maxViol     = cumShipVolVal - cumDemandVolVal;
            mvDemand    = theDemand;
            mvPer       = thePer;
            mvCumDemVol = cumDemandVolVal;
            }
         }
      }

   if (mvDemand != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsCumDemandConViolWmsg",
         maxViol,
         mvDemand->demandedPartName (),
         mvDemand->demandName (),
         mvPer,
         mvCumDemVol + maxViol,
         mvCumDemVol);
      }
   }
d890 38
a927 38
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         hardUBVal;
   double         maxViol;
   WitOperation * mvOpn;
   WitPeriod      mvPer;

   maxViol = FEAS_TOL;
   mvOpn   = NULL;
   mvPer   = -1;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theOpn->execBounds ()->hardUBIsFinite (thePer))
            {
            hardUBVal = theOpn->execBounds ()->hardUB ()[thePer];

            if (theOpn->execVol ()[thePer] - hardUBVal > maxViol)
               {
               maxViol = theOpn->execVol ()[thePer] - hardUBVal;
               mvOpn   = theOpn;
               mvPer   = thePer;
               }
            }

   if (mvOpn != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsExecHUBConViolWmsg",
         maxViol,
         mvOpn->operationName (),
         mvPer,
         mvOpn->execVol ()[mvPer],
         mvOpn->execBounds ()->hardUB ()[mvPer]);
      }
   }
d932 31
a962 31
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         maxViol;
   WitOperation * mvOpn;
   WitPeriod      mvPer;

   maxViol = FEAS_TOL;
   mvOpn   = NULL;
   mvPer   = -1;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (lotSizeViol (theOpn, execPer) > maxViol)
            {
            maxViol = lotSizeViol (theOpn, execPer);
            mvOpn   = theOpn;
            mvPer   = execPer;
            }

   if (mvOpn != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsLotSizeConViolWmsg",
         maxViol,
         mvOpn->operationName (),
         mvPer,
         mvOpn->execVol ()[mvPer]);
      }
   }
d967 3
a969 3
   {
   double theExecVol;
   double lsDelta;
d971 1
a971 1
   theExecVol = theOpn->execVol ()[execPer];
d973 1
a973 1
   lsDelta    = theOpn->lotSizeDelta (execPer, theExecVol, 0.0);
d975 2
a976 2
   return positivePart (lsDelta);
   }
d981 5
a985 5
   {
   return
      min (      theValue  - floor (theValue),
           ceil (theValue) -        theValue);
   }
@


1.21
log
@Heuristic Adjustment
@
text
@a964 7
// lotSizeViol (theOpn, execPer)
//
// If the execVol is at or just above a lot-size grid point, the lot-size
// violation is taken to be 0 (where "just above" is defined by the lotSizeTol
// attribute). Otherwise the violation is taken to be the delta to the next grid
// point above the execVol.
//------------------------------------------------------------------------------
d969 1
a969 1
   double deltaWTol;
d973 1
a973 11
   deltaWTol  = theOpn->lotSizeDelta (execPer, theExecVol, 0.0, true);

   if (deltaWTol <= 0.0)
      return 0.0;
   else
      return    theOpn->lotSizeDelta (execPer, theExecVol, 0.0, false);
   }

//------------------------------------------------------------------------------

#if 0
d975 1
a975 23
double WitFeasChkr::lotSizeViol (WitOperation * theOpn, WitPeriod execPer)
   {
   double upDelta;
   double downDelta;

   upDelta =
      theOpn->lotSizeDelta (
         execPer,
         theOpn->execVol ()[execPer],
         0.0,
         false);

   downDelta =
      theOpn->lotSizeDelta (
         execPer,
         theOpn->execVol ()[execPer],
         - 0.5,
         false);

   return min (fabs (upDelta), fabs (downDelta));
      //
      // The error is the minimum of the distance to the nearest lot-size
      // grid point above the execVol and the nearest one below it.
a977 2
#endif

@


1.20
log
@Heuristic Adjustment
@
text
@d965 26
d1017 2
d1024 2
a1025 3
      min (
         theValue        - floor (theValue),
         ceil (theValue) - theValue);
@


1.19
log
@Heuristic Adjustment
@
text
@d107 2
a108 3
   verifyUhsNonExecCon ();

   verifyUhsSubCon ();
d110 2
a111 2
   verifyUhsExecHUBCon ();
   verifyUhsLotSizeCon ();
@


1.18
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d23 1
a23 1
#include <Opn.h>
@


1.17
log
@Added display of constraint violations > FEAS_TOL.
@
text
@d21 1
a21 1
#include <Global.h>
@


1.16
log
@Reduced message 903 from severe to warning.
@
text
@a73 3
   if (myGlobalComp ()->reportIncViol ())
      fprintf (msgFile (), "\n");

d764 1
a764 1
      if (myGlobalComp ()->reportIncViol ())
d766 2
a767 1
         myMsgFac () ("maxViolHeadingMsg", maxViolation_);
@


1.15
log
@Stochastic Implosion
@
text
@d82 7
a88 7
   if (myProblem ()->extOptVariant ()->isCurrent ())
      if (not myGlobalComp ()->feasible ())
         myMsgFac () ("infeasExtOptSmsg", maxViolation ());

   if (DEVELOPMENT)
      if (myProblem ()->currentVariant ()->internalSoln ())
         if (not myGlobalComp ()->feasible ())
d94 1
@


1.14
log
@Stochastic Implosion
@
text
@d494 2
a495 2
   WitComponent *      theComp;
   const WitBoundSet * theBoundSet;
d521 1
a521 1
void WitFeasChkr::checkFeasHardLB (const WitBoundSet * theBoundSet)
d551 1
a551 1
void WitFeasChkr::checkFeasHardUB (const WitBoundSet * theBoundSet)
@


1.13
log
@[disallowed scrap]
@
text
@a28 1
#include <PostAccess.h>
d80 1
a80 2
   WitPostAccess::feasible (myGlobalComp ()) =
      (maxViolation_ <= FEAS_TOL);
d100 1
a100 3
   WitPostAccess::feasible (myGlobalComp ()) = false;

   maxViolation_                             = 0.0;
d796 8
a803 5
   WitBomEntry * theBomEnt;
   WitPeriod     thePer;
   double        maxViol;
   WitBomEntry * mvBomEnt;
   WitPeriod     mvPer;
a808 2
   WitDblFlexVec nonSubVolVec (myProblem (), 0.0);

@


1.12
log
@[disallowed backlog]
@
text
@d69 3
d73 1
d616 30
@


1.11
log
@[disallowed backlog]
@
text
@d426 1
a426 1
      if (not theDemand->backlogAllowed ())
d463 1
a463 1
      if (theDemand->backlogAllowed ())
@


1.10
log
@[disallowed backlog]
@
text
@a68 3
      {
      checkShipVols ();

a69 1
      }
d131 1
d418 1
a418 1
void WitFeasChkr::checkCumShipVols ()
d426 6
a431 5
      forEachPeriod (shipPer, myProblem ())
         {
         theViol = 
              theDemand->cumShipVol   ()[shipPer]
            - theDemand->cumDemandVol ()[shipPer];
d433 1
a433 1
         recordViolation (theViol, reportNeeded);
d435 4
a438 4
         if (reportNeeded)
            {
            myMsgFac () ("maxViolConstraintMsg",
               myMsgFac ().myFrag ("maxViolCumShipVolFrag"));
d440 3
a442 3
            myMsgFac () ("maxViolObjectMsg",
               "Part:",
               theDemand->demandedPartName ());
d444 3
a446 3
            myMsgFac () ("maxViolObjectMsg",
               "Demand:",
               theDemand->demandName ());
d448 2
a449 1
            myMsgFac () ("maxViolPeriodMsg", shipPer);
a450 1
         }
d455 1
a455 1
void WitFeasChkr::checkShipVols ()
d463 1
a463 1
      if (not theDemand->backlogAllowed ())
d467 2
a468 2
                 theDemand->shipVol   ()[shipPer]
               - theDemand->demandVol ()[shipPer];
d475 1
a475 1
                  myMsgFac ().myFrag ("maxViolShipVolFrag"));
@


1.9
log
@[disallowed backlog]
@
text
@d465 1
a465 1
      if (theDemand->disallowBacklog ())
@


1.8
log
@[disallowed backlog]
@
text
@d60 1
a60 1
   if (myProblem ()->currentVariant ()->respectsAllBounds ())
d68 4
a71 1
   if (myProblem ()->currentVariant ()->respectsIntegrality ())
d73 1
d457 37
@


1.7
log
@External opt implosion.
@
text
@d20 1
a21 1
#include <OptComp.h>
d29 1
a37 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

bool WitGlobalComp::* WitFeasChkr::feasible_ = NULL;

//------------------------------------------------------------------------------

d77 2
a78 1
   myGlobalComp ()->*feasible_ = (maxViolation_ <= FEAS_TOL);
d98 3
a100 2
   myGlobalComp ()->*feasible_ = false;
   maxViolation_               = 0.0;
a118 7
void WitFeasChkr::receiveDMPs (bool WitGlobalComp::* feasibleArg)
   {
   feasible_ = feasibleArg;
   }

//------------------------------------------------------------------------------

@


1.6
log
@External optimizing implosion.
@
text
@d86 1
a86 1
   if (myProblem ()->myExtOptVariant ()->isCurrent ())
@


1.5
log
@External opt implosion.
@
text
@d86 4
@


1.4
log
@External opt implosion.
@
text
@d583 1
a583 1
   if (not myOptComp ()->allowIntCons ())
@


1.3
log
@External opt implosion.
@
text
@d583 1
a583 1
   if (not myOptComp ()->enforceIntCons ())
@


1.2
log
@External opt implosion.
@
text
@d21 1
d583 3
@


1.1
log
@external opt implosion.
@
text
@d253 1
a253 1
               "Substitute #:",
d266 1
a266 1
   WitPeriod   thePer;
d271 1
a271 1
      forEachPeriod (thePer, myProblem ())
d273 1
a273 1
         theViol = - theDemand->shipVol ()[thePer];
d289 1
a289 1
            myMsgFac () ("maxViolPeriodMsg", thePer);
d299 1
a299 1
   WitPeriod   thePer;
d304 1
a304 1
      forEachPeriod (thePer, myProblem ())
d306 1
a306 1
         theViol = - theDemand->cumShipVol ()[thePer];
d322 1
a322 1
            myMsgFac () ("maxViolPeriodMsg", thePer);
d427 1
a427 1
   WitPeriod   thePer;
d432 1
a432 1
      forEachPeriod (thePer, myProblem ())
d435 2
a436 2
              theDemand->cumShipVol   ()[thePer]
            - theDemand->cumDemandVol ()[thePer];
d453 1
a453 1
            myMsgFac () ("maxViolPeriodMsg", thePer);
d582 9
d600 1
a600 1
            theViol = integralityViolation (theOpn->execVol ()[execPer]);
d619 72
d929 1
a929 1
double WitFeasChkr::integralityViolation (double theValue)
@


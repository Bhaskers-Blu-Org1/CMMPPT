head	1.40;
access;
symbols
	sce_5_01_20080919:1.36
	latest_sce_4_20_20060523:1.17.0.2
	sce_4_20_20060523:1.17
	latest_sce4_20_OSL:1.16.0.2
	sce_4_20_OSL:1.16
	sce_410_withVa:1.16
	sce_4_05_20040511:1.16
	sce_4_00_20040201:1.8
	nextGenBranch:1.8.0.2
	nextGenRoot:1.8
	sce_3_30_20030627:1.8
	EndRw-branch:1.6.0.4
	Root-of-EndRw:1.6
	rwToStl:1.6.0.2
	latest_sce_3_10_20010924:1.4.0.6
	sce_3_10_20010924:1.4
	latest_sce_3_00_20010601:1.4.0.4
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.4.0.2
	sce_2_31_20010308:1.4
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2011.09.28.23.49.06;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2011.09.24.00.27.24;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2011.08.30.20.17.19;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.25.00.10.46;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.02.17.48.36;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.28.23.53.36;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.18.22.40.58;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.07.23.51.48;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.04.20.25.27;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.12.06.22.53.00;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.06.22.01.21;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.29.15.35.01;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.28.23.23.44;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.28.20.34.27;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.27.21.05.00;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.18.23.14.44;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.11.19.16.56;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.02.18.32.42;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.01.19.52.16;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.28.23.32.57;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.28.22.08.25;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.10.14.44.06;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.30.21.43.08;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.02.17.33.55;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.26.22.29.41;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.24.22.21.28;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.23.19.14.23;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.20.00.12.11;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.10.22.53.18;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.04.16.31.45;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.03.20.05.06;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.13.23.06.26;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.02.22.18.20;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.11.18.53.05;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.08.19.21.47;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.04.22.07.34;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.22.23.11.37;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.24;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef BoundSetH
#define BoundSetH

//------------------------------------------------------------------------------
// Header file: "BoundSet.h"
//
// Contains the declaration of class BoundSet.
//------------------------------------------------------------------------------

#include <FlexVec.h>
#include <Assoc.h>

//------------------------------------------------------------------------------
// class BoundSet
// The set of bounds on a time vector of variables.
//
// The following relationships are required:
//               0.0 <= hardLB_[thePer] <  +infinity.
//               0.0 <= softLB_[thePer] <  +infinity.
//               0.0 <= hardUB_[thePer] <= +infinity.
//   hardLB_[thePer] <= softLB_[thePer] <= hardUB_[thePer].
//
// The BoundSet member functions verify these relationships.
//
// Infinite values of hardUB are represented as negative numbers. If possible,
// code that uses BoundSets should not explicitly depend on this representation
// of infinity. Instead, to test whether or not a number x is <= the hardUB in
// thePer, use hardUBisSatisfied (thePer, x). To test whether or not the hardUB
// in thePer is finite, use hardUBIsFinite (thePer).
// Typically, BoundSets are manipulated thru pointers and not references,
// because they are used to index into schedules.
//
// Class Hierarchy:
//
// ProbAssoc
//    BoundSet
//       StockBoundSet
//       CumShipBoundSet
//       ExecBoundSet
//------------------------------------------------------------------------------

class WitBoundSet: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitBoundSet (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitBoundSet ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const WitDblFlexVec &, hardLB)
      accessFunc (const WitDblFlexVec &, softLB)
      accessFunc (const WitDblFlexVec &, hardUB)

      //------------------------------------------------------------------------
      // Mapping functions
      //------------------------------------------------------------------------

      decMappingIndex (WitBoundSet)

      static int nInstances (WitProblem *);

      //------------------------------------------------------------------------
      // Default value functions.
      //------------------------------------------------------------------------

      defaultValue (double defHardLB,  0.0)
      defaultValue (double defSoftLB,  0.0)
      defaultValue (double defHardUB, -1.0)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual double boundedVal (WitPeriod thePer) = 0;
         //
         // Returns the element indexed by thePer in the Vector bounded by this
         // BoundSet.

      virtual const char * myAttName () = 0;
         //
         // Returns the attribute name for this BoundSet.

      virtual WitDelComp * myDelComp () = 0;
         //
         // Returns the DelComp that owns this BoundSet.

      bool isAtDefault ();
         //
         // Returns true iff the vectors of this BoundSet are at their default
         // values.

      bool hardUBIsFinite (WitPeriod thePer);
         //
         // Returns true iff the hard upper bound for thePer represents a
         // finite number.

      bool hardUBisSatisfied (WitPeriod thePer, double theDbl);
         //
         // Returns true iff theDbl <= the hardUB of this BoundSet in thePer,
         // where the hardUB may be infinite.

      void set (
            const WitDblFlexVec & hardLBval,
            const WitDblFlexVec & softLBval,
            const WitDblFlexVec & hardUBval);
         //
         // Sets the vectors of this BoundSet to the arguments.

      //------------------------------------------------------------------------
      // storeStoch<Attr> functions.
      // Each of these functions sets the value of indicated attribute to the
      // value of the argument.
      // Valid only when the stochastic implosion subsystem is uploading data.
      //------------------------------------------------------------------------

      void storeStochHardLB (const WitDblFlexVec &);
      void storeStochSoftLB (const WitDblFlexVec &);
      void storeStochHardUB (const WitDblFlexVec &);

      //------------------------------------------------------------------------

      void copyAttrsFrom (WitBoundSet * theBoundSet);
         //
         // Copies the vectors of theBoundSet into this BoundSet.

      static bool seqError (
            const WitDblFlexVec & hardLBArg,
            const WitDblFlexVec & softLBArg,
            const WitDblFlexVec & hardUBArg,
            WitPeriod             thePer);
         //
         // Returns true, iff the vectors fail to satisfy the condition:
         //
         //    0.0 <= hardLBArg <= softLBArg <= hardUBArg,
         //
         // where negative values of hardUBArg are interpreted as +infinity.

      bool hasPositiveHardLB ();
         //
         // Returns true iff this BoundSet has a positive hardLB.

      void writeData ();
         //
         // Writes this BoundSet to the input data output file, if needed.

      void writeSetClause ();
         //
         // Writes a "set" clause for this BoundSet to an input data file.

      void display ();
         //
         // Displays the input data for this BoundSet.

      void writeSoln ();
         //
         // Prints the comprehensive implosion solution for this BoundSet.

      void reindex ();
         //
         // Recomputes mappingIndex for this BoundSet.
         // Valid only if myCompMgr () is reindexing this BoundSet.

      virtual WitBoundSet * myMatchIn (WitCompMgr * theCompMgr) = 0;
         //
         // Finds and returns the BoundSet in theCompMgr whose DelComp has
         // the same ID as the DelComp that owns this BoundSet.
         // Checks that such a BoundSet exists.

      virtual WitNode * stageNode () = 0;
         //
         // Returns the Node whose stage determines the stage for this BoundSet.
         // (for stochastic implosion).

      virtual void issueStage0MMCompMsg () = 0;
         //
         // Issues a msg identifying myDelComp () for a stage 0 attribute
         // mismatch situation.

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      virtual WitMsgID headingMsgID () = 0;
         //
         // Returns the MsgID to be used for displaying this BoundSet.

      virtual const char * boundedVectorName () = 0;
         //
         // Returns the attribute name of the Vector Bounded by this BoundSet.

      virtual void idObjectForSoln () = 0;
         //
         // Writes identification of the object bounded by this BoundSet to
         // myProblem ()->solnFile ().

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitBoundSet);

      bool unaccNeeded (
            const WitDblFlexVec & hardLBArg,
            const WitDblFlexVec & softLBArg);
         //
         // Returns true, if it is necessary to shut down opt implosion when
         // setting the hard and soft lower bounds to hardLBArg and softLBArg.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      int mappingIndex_;
         //
         // Mapping index: see Mapping.h.
         // == # BoundSets constructed before this BoundSet.

      WitDblFlexVec hardLB_;
         //
         // Hard lower bound vector.

      WitDblFlexVec softLB_;
         //
         // Soft lower bound vector.

      WitDblFlexVec hardUB_;
         //
         // Hard upper bound vector.
   };

#endif
@


1.39
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.38
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d52 2
a53 112
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitBoundSet (WitProblem * theProblem);
//
// ProbAssoc <<< theProblem.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

virtual ~WitBoundSet ();

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (const WitDblFlexVec &, hardLB)
accessFunc (const WitDblFlexVec &, softLB)
accessFunc (const WitDblFlexVec &, hardUB)

//------------------------------------------------------------------------
// Mapping functions
//------------------------------------------------------------------------

decMappingIndex (WitBoundSet)

static int nInstances (WitProblem *);

//------------------------------------------------------------------------
// Default value functions.
//------------------------------------------------------------------------

defaultValue (double defHardLB,  0.0)
defaultValue (double defSoftLB,  0.0)
defaultValue (double defHardUB, -1.0)

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

virtual double boundedVal (WitPeriod thePer) = 0;
//
// Returns the element indexed by thePer in the Vector bounded by this
// BoundSet.

virtual const char * myAttName () = 0;
//
// Returns the attribute name for this BoundSet.

virtual WitDelComp * myDelComp () = 0;
//
// Returns the DelComp that owns this BoundSet.

bool isAtDefault ();
//
// Returns true iff the vectors of this BoundSet are at their default
// values.

bool hardUBIsFinite (WitPeriod thePer);
//
// Returns true iff the hard upper bound for thePer represents a
// finite number.

bool hardUBisSatisfied (WitPeriod thePer, double theDbl);
//
// Returns true iff theDbl <= the hardUB of this BoundSet in thePer,
// where the hardUB may be infinite.

void set (
const WitDblFlexVec & hardLBval,
const WitDblFlexVec & softLBval,
const WitDblFlexVec & hardUBval);
//
// Sets the vectors of this BoundSet to the arguments.

//------------------------------------------------------------------------
// storeStoch<Attr> functions.
// Each of these functions sets the value of indicated attribute to the
// value of the argument.
// Valid only when the stochastic implosion subsystem is uploading data.
//------------------------------------------------------------------------

void storeStochHardLB (const WitDblFlexVec &);
void storeStochSoftLB (const WitDblFlexVec &);
void storeStochHardUB (const WitDblFlexVec &);

//------------------------------------------------------------------------

void copyAttrsFrom (WitBoundSet * theBoundSet);
//
// Copies the vectors of theBoundSet into this BoundSet.

static bool seqError (
const WitDblFlexVec & hardLBArg,
const WitDblFlexVec & softLBArg,
const WitDblFlexVec & hardUBArg,
WitPeriod             thePer);
//
// Returns true, iff the vectors fail to satisfy the condition:
//
//    0.0 <= hardLBArg <= softLBArg <= hardUBArg,
//
// where negative values of hardUBArg are interpreted as +infinity.

bool hasPositiveHardLB ();
//
// Returns true iff this BoundSet has a positive hardLB.
d55 202
a256 92
void writeData ();
//
// Writes this BoundSet to the input data output file, if needed.

void writeSetClause ();
//
// Writes a "set" clause for this BoundSet to an input data file.

void display ();
//
// Displays the input data for this BoundSet.

void writeSoln ();
//
// Prints the comprehensive implosion solution for this BoundSet.

void reindex ();
//
// Recomputes mappingIndex for this BoundSet.
// Valid only if myCompMgr () is reindexing this BoundSet.

virtual WitBoundSet * myMatchIn (WitCompMgr * theCompMgr) = 0;
//
// Finds and returns the BoundSet in theCompMgr whose DelComp has
// the same ID as the DelComp that owns this BoundSet.
// Checks that such a BoundSet exists.

virtual WitNode * stageNode () = 0;
//
// Returns the Node whose stage determines the stage for this BoundSet.
// (for stochastic implosion).

virtual void issueStage0MMCompMsg () = 0;
//
// Issues a msg identifying myDelComp () for a stage 0 attribute
// mismatch situation.

protected:

//------------------------------------------------------------------------
// Protected member functions.
//------------------------------------------------------------------------

virtual WitMsgID headingMsgID () = 0;
//
// Returns the MsgID to be used for displaying this BoundSet.

virtual const char * boundedVectorName () = 0;
//
// Returns the attribute name of the Vector Bounded by this BoundSet.

virtual void idObjectForSoln () = 0;
//
// Writes identification of the object bounded by this BoundSet to
// myProblem ()->solnFile ().

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitBoundSet);

bool unaccNeeded (
const WitDblFlexVec & hardLBArg,
const WitDblFlexVec & softLBArg);
//
// Returns true, if it is necessary to shut down opt implosion when
// setting the hard and soft lower bounds to hardLBArg and softLBArg.

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

int mappingIndex_;
//
// Mapping index: see Mapping.h.
// == # BoundSets constructed before this BoundSet.

WitDblFlexVec hardLB_;
//
// Hard lower bound vector.

WitDblFlexVec softLB_;
//
// Soft lower bound vector.

WitDblFlexVec hardUB_;
//
// Hard upper bound vector.
};
@


1.37
log
@Multi-Objective Mode
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d52 112
a163 2
   {
   public:
d165 92
a256 202
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitBoundSet (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitBoundSet ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (const WitDblFlexVec &, hardLB)
      accessFunc (const WitDblFlexVec &, softLB)
      accessFunc (const WitDblFlexVec &, hardUB)

      //------------------------------------------------------------------------
      // Mapping functions
      //------------------------------------------------------------------------

      decMappingIndex (WitBoundSet)

      static int nInstances (WitProblem *);

      //------------------------------------------------------------------------
      // Default value functions.
      //------------------------------------------------------------------------

      defaultValue (double defHardLB,  0.0)
      defaultValue (double defSoftLB,  0.0)
      defaultValue (double defHardUB, -1.0)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual double boundedVal (WitPeriod thePer) = 0;
         //
         // Returns the element indexed by thePer in the Vector bounded by this
         // BoundSet.

      virtual const char * myAttName () = 0;
         //
         // Returns the attribute name for this BoundSet.

      virtual WitDelComp * myDelComp () = 0;
         //
         // Returns the DelComp that owns this BoundSet.

      bool isAtDefault ();
         //
         // Returns true iff the vectors of this BoundSet are at their default
         // values.

      bool hardUBIsFinite (WitPeriod thePer);
         //
         // Returns true iff the hard upper bound for thePer represents a
         // finite number.

      bool hardUBisSatisfied (WitPeriod thePer, double theDbl);
         //
         // Returns true iff theDbl <= the hardUB of this BoundSet in thePer,
         // where the hardUB may be infinite.

      void set (
            const WitDblFlexVec & hardLBval,
            const WitDblFlexVec & softLBval,
            const WitDblFlexVec & hardUBval);
         //
         // Sets the vectors of this BoundSet to the arguments.

      //------------------------------------------------------------------------
      // storeStoch<Attr> functions.
      // Each of these functions sets the value of indicated attribute to the
      // value of the argument.
      // Valid only when the stochastic implosion subsystem is uploading data.
      //------------------------------------------------------------------------

      void storeStochHardLB (const WitDblFlexVec &);
      void storeStochSoftLB (const WitDblFlexVec &);
      void storeStochHardUB (const WitDblFlexVec &);

      //------------------------------------------------------------------------

      void copyAttrsFrom (WitBoundSet * theBoundSet);
         //
         // Copies the vectors of theBoundSet into this BoundSet.

      static bool seqError (
            const WitDblFlexVec & hardLBArg,
            const WitDblFlexVec & softLBArg,
            const WitDblFlexVec & hardUBArg,
            WitPeriod             thePer);
         //
         // Returns true, iff the vectors fail to satisfy the condition:
         //
         //    0.0 <= hardLBArg <= softLBArg <= hardUBArg,
         //
         // where negative values of hardUBArg are interpreted as +infinity.

      bool hasPositiveHardLB ();
         //
         // Returns true iff this BoundSet has a positive hardLB.

      void writeData ();
         //
         // Writes this BoundSet to the input data output file, if needed.

      void writeSetClause ();
         //
         // Writes a "set" clause for this BoundSet to an input data file.

      void display ();
         //
         // Displays the input data for this BoundSet.

      void writeSoln ();
         //
         // Prints the comprehensive implosion solution for this BoundSet.

      void reindex ();
         //
         // Recomputes mappingIndex for this BoundSet.
         // Valid only if myCompMgr () is reindexing this BoundSet.

      virtual WitBoundSet * myMatchIn (WitCompMgr * theCompMgr) = 0;
         //
         // Finds and returns the BoundSet in theCompMgr whose DelComp has
         // the same ID as the DelComp that owns this BoundSet.
         // Checks that such a BoundSet exists.

      virtual WitNode * stageNode () = 0;
         //
         // Returns the Node whose stage determines the stage for this BoundSet.
         // (for stochastic implosion).

      virtual void issueStage0MMCompMsg () = 0;
         //
         // Issues a msg identifying myDelComp () for a stage 0 attribute
         // mismatch situation.

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      virtual WitMsgID headingMsgID () = 0;
         //
         // Returns the MsgID to be used for displaying this BoundSet.

      virtual const char * boundedVectorName () = 0;
         //
         // Returns the attribute name of the Vector Bounded by this BoundSet.

      virtual void idObjectForSoln () = 0;
         //
         // Writes identification of the object bounded by this BoundSet to
         // myProblem ()->solnFile ().

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitBoundSet);

      bool unaccNeeded (
            const WitDblFlexVec & hardLBArg,
            const WitDblFlexVec & softLBArg);
         //
         // Returns true, if it is necessary to shut down opt implosion when
         // setting the hard and soft lower bounds to hardLBArg and softLBArg.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      int mappingIndex_;
         //
         // Mapping index: see Mapping.h.
         // == # BoundSets constructed before this BoundSet.

      WitDblFlexVec hardLB_;
         //
         // Hard lower bound vector.

      WitDblFlexVec softLB_;
         //
         // Soft lower bound vector.

      WitDblFlexVec hardUB_;
         //
         // Hard upper bound vector.
   };
@


1.36
log
@Removed many conversions of string constant to char *.
@
text
@a109 5
      virtual void writeCompSetClause () = 0;
         //
         // Writes (to an input data file) a "set" clause the Component that
         // owns this BoundSet.

d169 4
@


1.35
log
@Stochastic Implosion
@
text
@d102 1
a102 1
      virtual WitAttr myAttName () = 0;
d213 1
a213 1
      virtual WitAttr boundedVectorName () = 0;
@


1.34
log
@Stochastic Implosion
@
text
@d193 1
a193 1
      virtual int objectStage () = 0;
d195 2
a196 2
         // Returns the stage index of this BoundSet.
         // Valid only stochastic mode.
@


1.33
log
@Stochastic Implosion
@
text
@d193 1
a193 1
      virtual int stageIndex () = 0;
@


1.32
log
@Stochastic Implosion
@
text
@d193 6
a198 1
      virtual void issueStage0MisMatchDelCompMsg () = 0;
@


1.31
log
@Stochastic Implosion
@
text
@d193 5
@


1.30
log
@Stochastic Implosion
@
text
@d97 1
a97 1
      virtual double boundedVal (WitPeriod thePer) const = 0;
d102 1
a102 1
      virtual WitAttr myAttName () const = 0;
d106 1
a106 1
      virtual WitDelComp * myDelComp () const = 0;
d110 1
a110 1
      virtual void writeCompSetClause () const = 0;
d115 1
a115 1
      bool isAtDefault () const;
d120 1
a120 1
      bool hardUBIsFinite (WitPeriod thePer) const;
d125 1
a125 1
      bool hardUBisSatisfied (WitPeriod thePer, double theDbl) const;
d150 1
a150 1
      void copyAttrsFrom (const WitBoundSet * theBoundSet);
d166 1
a166 1
      bool hasPositiveHardLB () const;
d174 1
a174 1
      void display () const;
d178 1
a178 1
      void writeSoln () const;
d199 1
a199 1
      virtual WitMsgID headingMsgID () const = 0;
d203 1
a203 1
      virtual WitAttr boundedVectorName () const = 0;
d207 1
a207 1
      virtual void idObjectForSoln () const = 0;
d222 1
a222 2
            const WitDblFlexVec & softLBArg)
            const;
@


1.29
log
@Stochastic Implosion
@
text
@d187 6
@


1.28
log
@Stochastic Implosion
@
text
@d110 5
@


1.27
log
@Stochastic Implosion
@
text
@d106 1
a106 1
      virtual WitComponent * myComp () const = 0;
d108 1
a108 1
         // Returns the Component that owns this BoundSet.
@


1.26
log
@Stochastic Implosion
@
text
@d165 1
a165 1
      void writeData () const;
@


1.25
log
@Stochastic Implosion
@
text
@a181 5
      virtual void writeStochDataSetClause () = 0;
         //
         // Writes a "set" clause for this BoundSet to an input data file for
         // stochastic implosion.

@


1.24
log
@Stochastic Implosion
@
text
@d106 1
a106 1
      virtual WitNode * myNode () = 0;
d108 1
a108 1
         // Returns the Node associated with this BoundSet.
@


1.23
log
@Stochastic Implosion
@
text
@a186 5
      virtual void issueStage0MisMatchMsg () = 0;
         //
         // Issues a msg identifying this BoundSet theOwner for a stage 0
         // attribute mismatch situation in stochastic implosion.

@


1.22
log
@Stochastic Implosion
@
text
@d139 3
a141 3
      void storeStochHardLB (const WitTVec <double> &);
      void storeStochSoftLB (const WitTVec <double> &);
      void storeStochHardUB (const WitTVec <double> &);
@


1.21
log
@Stochastic Implosion
@
text
@d182 5
@


1.20
log
@Stochastic Implosion
@
text
@d106 4
d182 5
@


1.19
log
@Stochastic Implosion
@
text
@d102 1
a102 1
      virtual WitAttr apiAttr () const = 0;
d104 1
a104 1
         // Returns the API attribute name for this BoundSet.
d128 14
a141 1
      void set (const WitBoundSet * theBoundSet);
@


1.18
log
@[backlog avoidance]
@
text
@d46 3
@


1.17
log
@Updated the copyright date on all source files.
@
text
@d139 1
a139 1
         // where negative values of hardLBArg are interpreted as +infinity.
@


1.16
log
@Double Precision.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.15
log
@Double Precision.
@
text
@d119 3
a121 3
            const float * hardLBval,
            const float * softLBval,
            const float * hardUBval);
d123 1
a123 2
         // Assigns the vectors of this BoundSet to the arguments.
         // Vectors must not be NULL.
d129 5
a133 6
      bool seqError (
            const float * hardLBval,
            const float * softLBval,
            const float * hardUBval,
            WitPeriod     thePer)
            const;
d137 1
a137 1
         //    0.0 <= hardLBval <= softLBval <= hardUBval,
d139 1
a139 1
         // where negative values of hardLBval are interpreted as +infinity.
a144 13
      static inline float elem (                                            
            const WitDblFlexVec & theFlexVec,
            const float *         theCVec,
            WitPeriod             thePer)
         {                                                                     
         return                                                                
            (theCVec == NULL)?                                              
               fltFromDbl (theFlexVec[thePer]):
               theCVec[thePer];                                             
         }                                                                     
         //
         // Useful for API purposes.

d189 4
a192 1
      bool unaccNeeded (const float * newHardLB, const float * newSoftLB) const;
d195 1
a195 1
         // setting the hard and soft lower bounds to hardLBval and softLBval.
@


1.14
log
@Double Precision.
@
text
@d70 3
a72 3
      accessFunc (const WitFlexVec <double> &, hardLB)
      accessFunc (const WitFlexVec <double> &, softLB)
      accessFunc (const WitFlexVec <double> &, hardUB)
d148 3
a150 3
            const WitFlexVec <double> & theFlexVec,
            const float *               theCVec,
            WitPeriod                   thePer)
d218 1
a218 1
      WitFlexVec <double> hardLB_;
d222 1
a222 1
      WitFlexVec <double> softLB_;
d226 1
a226 1
      WitFlexVec <double> hardUB_;
@


1.13
log
@Double Precision.
@
text
@d19 1
a19 1
#include <RealVec.h>
d70 3
a72 3
      accessFunc (const WitRealVec &, hardLB)
      accessFunc (const WitRealVec &, softLB)
      accessFunc (const WitRealVec &, hardUB)
d148 3
a150 3
            const WitRealVec & theRealVec,
            const float *      theCVec,
            WitPeriod          thePer)
d154 1
a154 1
               fltFromDbl (theRealVec[thePer]):
d218 1
a218 1
      WitRealVec hardLB_;
d222 1
a222 1
      WitRealVec softLB_;
d226 1
a226 1
      WitRealVec hardUB_;
@


1.12
log
@Double Precision.
@
text
@d20 1
@


1.11
log
@Double Precision.
@
text
@d85 3
a87 3
      defaultValue (float defHardLB,  0.0)
      defaultValue (float defSoftLB,  0.0)
      defaultValue (float defHardUB, -1.0)
d93 1
a93 1
      virtual float boundedVal (WitPeriod thePer) const = 0;
d112 1
a112 1
      bool hardUBisSatisfied (WitPeriod thePer, float theFlt) const;
d114 1
a114 1
         // Returns true iff theFlt <= the hardUB of this BoundSet in thePer,
@


1.10
log
@Double Precision.
@
text
@d153 1
a153 1
               floatFromDouble (theRealVec[thePer]):
@


1.9
log
@Double Precision.
@
text
@d148 1
a148 1
            const float *      theCvector,
d152 1
a152 1
            (theCvector == NULL)?                                              
d154 1
a154 1
               theCvector[thePer];                                             
@


1.8
log
@Continued implementation of proportionate routing.
@
text
@d19 1
a19 1
#include <FlexVec.h>
d26 4
a29 4
//          0.0 <= hardLB_[t] <  +infinity.
//          0.0 <= softLB_[t] <  +infinity.
//          0.0 <= hardUB_[t] <= +infinity.
//   hardLB_[t] <= softLB_[t] <= hardUB_[t].
d36 2
a37 2
// period t, use hardUBisSatisfied (t, x). To test whether or not the hardUB in
// period t is finite, use hardUBIsFinite (t).
d69 3
a71 3
      accessFunc (const WitFlexVec <float> &, hardLB)
      accessFunc (const WitFlexVec <float> &, softLB)
      accessFunc (const WitFlexVec <float> &, hardUB)
d93 1
a93 1
      virtual float boundedVal (WitPeriod t) const = 0;
d95 2
a96 1
         // Returns the t-th element of the Vector bounded by this BoundSet.
d107 1
a107 1
      bool hardUBIsFinite (WitPeriod t) const;
d109 1
a109 1
         // Returns true iff the hard upper bound for period t represents a
d112 1
a112 1
      bool hardUBisSatisfied (WitPeriod t, float x) const;
d114 1
a114 1
         // Returns true iff x <= the hardUB of this BoundSet in period t,
d147 3
a149 3
            const WitFlexVec <float> & theFlexVec,
            const float *              theCvector,
            WitPeriod                  thePer)
d153 1
a153 1
               theFlexVec[thePer]:                                             
d217 1
a217 1
      WitFlexVec <float> hardLB_;
d219 1
a219 1
         // TVec storing hard lower bounds.
d221 1
a221 1
      WitFlexVec <float> softLB_;
d223 1
a223 1
         // TVec storing soft lower bounds.
d225 1
a225 1
      WitFlexVec <float> hardUB_;
d227 1
a227 1
         // TVec storing hard upper bounds.
@


1.7
log
@Internal changes.
@
text
@d73 4
d78 2
@


1.6
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d95 1
a95 1
      WitBoolean isAtDefault () const;
d97 1
a97 1
         // Returns TRUE iff the vectors of this BoundSet are at their default
d100 1
a100 1
      WitBoolean hardUBIsFinite (WitPeriod t) const;
d102 1
a102 1
         // Returns TRUE iff the hard upper bound for period t represents a
d105 1
a105 1
      WitBoolean hardUBisSatisfied (WitPeriod t, float x) const;
d107 1
a107 1
         // Returns TRUE iff x <= the hardUB of this BoundSet in period t,
d122 1
a122 1
      WitBoolean seqError (
d129 1
a129 1
         // Returns TRUE, iff the vectors fail to satisfy the condition:
d135 1
a135 1
      WitBoolean hasPositiveHardLB () const;
d137 1
a137 1
         // Returns TRUE iff this BoundSet has a positive hardLB.
d196 1
a196 4
      WitBoolean unaccNeeded (
            const float * newHardLB,
            const float * newSoftLB)
            const;
d198 1
a198 1
         // Returns TRUE, if it is necessary to shut down opt implosion when
@


1.5
log
@Preliminary work on single source.
@
text
@d201 1
a201 1
         // Returns TRUE, if it is necessary to do an unaccelerate when
@


1.4
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d69 3
a71 3
      accessFunc (const WitFlexVec (float) &, hardLB)
      accessFunc (const WitFlexVec (float) &, softLB)
      accessFunc (const WitFlexVec (float) &, hardUB)
d140 1
a140 1
            const WitFlexVec (float) & theFlexVec,
d213 1
a213 1
      WitFlexVec (float) hardLB_;
d217 1
a217 1
      WitFlexVec (float) softLB_;
d221 1
a221 1
      WitFlexVec (float) hardUB_;
@


1.3
log
@Refactoring for selection splitting.
@
text
@d167 1
a167 1
         // Only valid if myCompMgr () is reindexing this BoundSet.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d194 1
a194 3
      copyCtorAndAssignment (WitBoundSet);
         //
         // Prevents unintentional copying and assignment.
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

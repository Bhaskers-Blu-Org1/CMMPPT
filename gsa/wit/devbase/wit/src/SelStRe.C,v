head	1.86;
access;
symbols
	sce_5_01_20080919:1.68
	latest_sce_4_20_20060523:1.68.0.2
	sce_4_20_20060523:1.68
	latest_sce4_20_OSL:1.67.0.2
	sce_4_20_OSL:1.67
	sce_410_withVa:1.67
	sce_4_05_20040511:1.44
	sce_4_00_20040201:1.44
	nextGenBranch:1.41.0.2
	nextGenRoot:1.41
	sce_3_30_20030627:1.41
	EndRw-branch:1.29.0.4
	Root-of-EndRw:1.29
	rwToStl:1.29.0.2
	latest_sce_3_10_20010924:1.6.0.2
	sce_3_10_20010924:1.6;
locks; strict;
comment	@ * @;


1.86
date	2011.09.28.23.50.11;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2011.09.24.00.28.37;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2011.08.30.20.18.10;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2010.09.28.19.25.17;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2010.07.30.20.20.15;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2010.07.29.21.03.12;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2010.07.28.21.40.40;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.28.19.27.46;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.27.23.07.06;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.27.18.12.34;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.26.17.48.44;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.16.22.37.43;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2010.07.16.22.26.42;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2010.07.13.17.41.30;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2010.07.02.22.56.26;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2010.07.02.19.15.50;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.18.23.11.15;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2010.03.16.22.42.28;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.02.17.34.12;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.03.28.20.14.38;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2005.01.15.00.20.08;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2005.01.13.17.24.21;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2005.01.11.21.07.58;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.06.20.34.10;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.01.01.00.43.14;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.12.31.18.28.29;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.12.28.22.34.27;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.12.28.19.21.19;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.12.22.19.57.26;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.12.21.22.13.49;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.12.20.21.13.10;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.12.20.18.36.24;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.12.17.21.53.01;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.12.16.23.35.17;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.12.15.23.50.11;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.12.15.20.20.51;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.12.14.22.37.11;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.13.23.35.48;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.13.20.31.15;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.10.16.49.45;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.09.22.06.07;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.09.21.34.12;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.11.11.18.29.15;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.26.16.06.07;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.25.20.44.44;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.05.16.10.02;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.29.14.27.50;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.17.23.34.20;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.11.19.08.29;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.19.16.48.27;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.07.21.34.19;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.14.20.13.01;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.07.23.29.12;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.31.21.28.57;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.29.19.16.48;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.02.23.40.49;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.02.22.18.48;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.04.19.14.59;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.22.19.33.58;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.19.16.10.51;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.02.21.53.07;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.24.23.00.07;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.17.21.45.04;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.07.20.15.04;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.22.14.32.13;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.18.14.02.44;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.15.21.21.38;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.12.21.02.03;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.11.15.36.30;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.22.21.23.23;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.20.22.51.19;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.19.16.20.58;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.09.00.43.49;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.20.00.00.18;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.19.16.17.12;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.17.16.25.42;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.07.23.03.55;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.05.20.53.58;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.28.00.13.00;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.24.22.45.19;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.21.16.53.31;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.19.19.18.53;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.19.18.50.59;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.17.18.56.29;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.16.21.42.31;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.04.15.44.39;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.86
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "SelStRe.C"
//
// Contains the implementation of the following classes:
//
//    SsrMgr.
//    SsrPt.
//    SsrCand.
//------------------------------------------------------------------------------

#include <SsrMgr.h>
#include <SsrCand.h>
#include <SsrPt.h>
#include <DetAltPt.h>
#include <SplitPt.h>
#include <SglSrcMgr.h>
#include <Selector.h>
#include <HeurAtor.h>
#include <GlobalComp.h>
#include <Material.h>
#include <BopEntry.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class SsrMgr.
//------------------------------------------------------------------------------

WitSsrMgr::WitSsrMgr (WitSelector * theSelector):

      WitSelMgr        (theSelector),
      mySsrPts_        (),
      srWasDonePts_    (myProblem ()),
      srSelSplit_      (false),
      myRecoveryPairs_ (myProblem ())
   {
   WitMaterial * theMat;
   WitPeriod     fromPer;
   WitPeriod     expPer;

   if (DEVELOPMENT)
      myMsgFac () ("selSRMsg");

   mySsrPts_.allocate1D (myProblem ());

   forEachMaterial (theMat, myProblem ())
      {
      if (not mySelector ()->myHeurAtor ()->selectiveSR (theMat))
         continue;

      mySsrPts_.myPtrTVecAt (theMat).allocate (myProblem ());

      for (fromPer = 1; fromPer < nPeriods (); fromPer ++)
         {
         expPer = theMat->explosionPeriod (fromPer);

         if (theMat->explodeable (expPer))
            mySsrPts_.myPtrAt (theMat, fromPer) =
               new WitSsrPt (theMat, fromPer, this);
         }
      }

   srSelSplit_ =
         myGlobalComp ()->selSplit      ()
      or myGlobalComp ()->nonMrSelSplit () 
      or myGlobalComp ()->srSelSplit    ();
   }

//------------------------------------------------------------------------------

WitSsrMgr::~WitSsrMgr ()
   {
   WitMaterial * theMat;
   WitPeriod     fromPer;

   forEachMaterial (theMat, myProblem ())
      if (mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
         forEachPeriod (fromPer, myProblem ())
            delete mySsrPts_.myPtrAt (theMat, fromPer);
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::instNeededFor (WitHeurAtor * theHeurAtor)
   {
   WitMaterial * theMat;

   forEachMaterial (theMat, theHeurAtor->myProblem ())
      if (theHeurAtor->selectiveSR (theMat))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::srAllowedFrom (WitMaterial * theMat, WitPeriod thePer)
   {
   WitSsrPt * theSsrPt;

   if (not mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
      return false;

   theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);

   if (theSsrPt == NULL)
      return false;

   if (theSsrPt->isSplit ())
      return true;

   return theSsrPt->srAllowed ();
   }

//------------------------------------------------------------------------------

void WitSsrMgr::recordSR (WitMaterial * theMat, WitPeriod thePer, double srVol)
   {
   WitSsrPt * theSsrPt;

   theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);

   witAssert (theSsrPt != NULL);

   witAssert (theSsrPt->srAllowed () or theSsrPt->isSplit ());

   if (srSelSplit_)
      theSsrPt->recordFlowSS (srVol);

   if (theSsrPt->srWasDone ())
      return;

   theSsrPt->setSrWasDone (true);

   srWasDonePts_.push (theSsrPt);
   }

//------------------------------------------------------------------------------

void WitSsrMgr::postTempCommit ()
   {
   WitSsrPt * theSsrPt;

   while (srWasDonePts_.pop (theSsrPt))
      theSsrPt->setSrWasDone (false);
   }

//------------------------------------------------------------------------------

void WitSsrMgr::print (WitMaterial * theMat)
   {
   WitPeriod  fromPer;
   WitSsrPt * theSsrPt;

   fprintf (msgFile (),
      "\n"
      "Part %s:\n\n"
      "   Per   S.R. Allowed?\n",
      theMat->partName ().myCstring ());

   forEachPeriod (fromPer, myProblem ())
      {
      theSsrPt = mySsrPts_.myPtrAt (theMat, fromPer);

      if (theSsrPt != NULL)
         fprintf (msgFile (), "   %3d   %s\n",
            fromPer,
            theSsrPt->srAllowed ()?
               "Yes":
               "No");
      }
   }

//------------------------------------------------------------------------------

void WitSsrMgr::storeRecoveryPair (WitMaterial * theMat, WitPeriod fromPer)
   {
   myRecoveryPairs_.push (theMat, fromPer);
   }

//------------------------------------------------------------------------------

void WitSsrMgr::recoverInitState ()
   {
   WitMaterial * theMat;
   WitPeriod     fromPer;

   while (myRecoveryPairs_.pop (theMat, fromPer))
      {
      mySsrPts_.myPtrAt (theMat, fromPer)->recoverInitState ();
      }
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::selSplitNeeded ()
   {
   return srSelSplit_;
   }

//------------------------------------------------------------------------------

void WitSsrMgr::adjReqAndRollForSS (
      WitMaterial * theMat,
      WitPeriod     rollPer,
      double &      theReqVol,
      double &      rollVol,
      bool &        bddSplit)
   {
   WitSsrPt * theSsrPt;
   double     srAllVol;
   double     srNotAllVol;

   witAssert (rollVol >= NET_TOL);

   if (not srSelSplit_)
      return;

   if (rollPer < 0)
      return;
   
   theSsrPt = mySsrPts_.myPtrAt (theMat, rollPer);

   if (theSsrPt == NULL)
      return;

   if (not theSsrPt->isSplit ())
      return;

   theSsrPt->defineSplit (rollVol, srAllVol, srNotAllVol);

   if (srAllVol == 0.0)
      {
      rollVol = 0.0;

      return;
      }

   bddSplit = true;

   if (srAllVol >= rollVol)
      return;

   rollVol    = srAllVol;

   theReqVol += srNotAllVol;
   }

//------------------------------------------------------------------------------

WitAltPt * WitSsrMgr::myAltPtFor (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod,
      WitPeriod     fillPer)
   {
   return myAltPtFor (theBopEnt->myPart (), fillPer);
   }

//------------------------------------------------------------------------------

WitAltPt * WitSsrMgr::myAltPtFor (WitPart * thePart, WitPeriod fillPer)
   {
   WitMaterial * theMat;
   WitSsrPt *    theSsrPt;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (hasanSsrPtFor (theMat, fillPer))
         {
         theSsrPt = mySsrPts_.myPtrAt (theMat, fillPer);

         if (theSsrPt->srAllowed ())
            return theSsrPt->myDetAltPt ();
         }

   return NULL;
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::validForLTBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

const char * WitSsrMgr::selCaseName ()
   {
   return "Stock Reallocation";
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::hasanSsrPtFor (WitMaterial * theMat, WitPeriod fromPer)
   {
   return
      mySsrPts_.myPtrTVecAt (theMat).isAllocated ()?
         (mySsrPts_.myPtrAt (theMat, fromPer) != NULL):
         false;
   }

//------------------------------------------------------------------------------
// Implementation of class SsrPt.
//------------------------------------------------------------------------------

WitSsrPt::WitSsrPt (
         WitMaterial * theMat,
         WitPeriod     fromPer,
         WitSsrMgr *   theSsrMgr):

      WitDetSelPt (),

      myMat_      (theMat),
      myFromPer_  (fromPer),
      mySsrMgr_   (theSsrMgr),
      srAllowed_  (true),
      srWasDone_  (false)
   {
   }

//------------------------------------------------------------------------------

WitSsrPt::~WitSsrPt ()
   {
   }

//------------------------------------------------------------------------------

void WitSsrPt::defineSplit (
      double   rollVol,
      double & srAllVol,
      double & srNotAllVol)
   {
   WitSelCandDblStack theSplitPairs (mySsrMgr_->myProblem ());
   double             unbddVol;
   bool               splitFound;
   WitSelCand *       theSelCand;
   double             splitVol;
   bool               srAllowedVal;

   witAssert (rollVol >= NET_TOL);

   witAssert (isSplit ());

   srAllVol    = 0.0;
   srNotAllVol = 0.0;

   mySplitPt ()->defineSplit (rollVol, theSplitPairs, unbddVol);

   theSplitPairs.reverse ();

   splitFound = theSplitPairs.pop (theSelCand, splitVol);

   if (not splitFound)
      {
      srAllVol = unbddVol;

      return;
      }

   if (DEBUG_MODE)
      {
      theSelCand->getSsrData (srAllowedVal);

      witAssert (srAllowedVal);
      }

   srAllVol   = splitVol;

   splitFound = theSplitPairs.pop (theSelCand, splitVol);

   if (not splitFound)
      {
      srNotAllVol = unbddVol;

      return;
      }

   if (DEBUG_MODE)
      {
      theSelCand->getSsrData (srAllowedVal);

      witAssert (not srAllowedVal);
      }

   srNotAllVol = splitVol;

   witAssert (theSplitPairs.isEmpty ());
   }

//------------------------------------------------------------------------------

void WitSsrPt::setSrWasDone (bool theValue)
   {
   witAssert (theValue != srWasDone_);

   srWasDone_ = theValue;
   }

//------------------------------------------------------------------------------

void WitSsrPt::recoverInitState ()
   {
   srAllowed_ = true;

   if (mySelMgr ()->selPrintLevelAt (3))
      printRecovery ();
   }

//------------------------------------------------------------------------------

WitSelMgr * WitSsrPt::mySelMgr ()
   {
   return mySsrMgr_;
   }

//------------------------------------------------------------------------------

void WitSsrPt::prtID ()        
   {
   fprintf (mySsrMgr_->msgFile (),
      "   Part:             %s\n"
      "   From Per:         %d\n",
      myMat_->partName ().myCstring (),
      myFromPer_);
   }

//------------------------------------------------------------------------------

bool WitSsrPt::splittable ()   
   {
   return mySsrMgr_->srSelSplit ();
   }

//------------------------------------------------------------------------------

void WitSsrPt::getSortData (WitPart * & thePart, WitPeriod & thePer)
   {
   thePart = myMat_;
   thePer  = myFromPer_;
   }

//------------------------------------------------------------------------------

WitSelCand * WitSsrPt::newSelCand ()
   {
   return new WitSsrCand (srAllowed_, mySsrMgr_->myProblem ());
   }

//------------------------------------------------------------------------------

bool WitSsrPt::hasResAlt ()
   {
   witAssert (mySsrMgr_->mySelector ()->myHeurAtor ()->tempCommActive ());

   if (srAllowed ())
      if (srWasDone_)
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitSsrPt::alterSelection ()
   {
   witAssert (srAllowed_);

   setSrAllowed (false);
   }

//------------------------------------------------------------------------------

void WitSsrPt::storeRecoveryPt ()
   {
   mySsrMgr_->storeRecoveryPair (myMat_, myFromPer_);
   }

//------------------------------------------------------------------------------

void WitSsrPt::tempAlterSel ()
   {
   witAssert (srAllowed_);

   setSrAllowed (false);
   }

//------------------------------------------------------------------------------

void WitSsrPt::cancelTempAlt ()
   {
   witAssert (not srAllowed_);

   setSrAllowed (true);
   }

//------------------------------------------------------------------------------

void WitSsrPt::printAlteration ()
   {
   mySsrMgr_->print (myMat_);
   }

//------------------------------------------------------------------------------

void WitSsrPt::setSrAllowed (bool srAllowedVal)
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (srAllowed_);

   srAllowed_ = srAllowedVal;
   }

//------------------------------------------------------------------------------

void WitSsrPt::printRecovery ()
   {
   fprintf (mySsrMgr_->msgFile (),
      "   Selective Stock Reallocation Period Recovered:\n"
      "      Part:     %s\n"
      "      From Per: %d\n\n",
      myMat_->partName ().myCstring (),
      myFromPer_);
   }

//------------------------------------------------------------------------------
// Implementation of class SsrCand.
//------------------------------------------------------------------------------

WitSsrCand::WitSsrCand (bool srAllowedVal, WitProblem * theProblem):

      WitSelCand (theProblem),
      srAllowed_ (srAllowedVal)
   {
   }

//------------------------------------------------------------------------------

WitSsrCand::~WitSsrCand ()
   {
   }

//------------------------------------------------------------------------------

void WitSsrCand::prtID ()
   {
   fprintf (msgFile (), "      SR Allowed?    %s\n", srAllowed_? "Yes": "No");
   }

//------------------------------------------------------------------------------

void WitSsrCand::getSsrData (bool & srAllowedVal)
   {
   srAllowedVal = srAllowed_;
   }
@


1.85
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.84
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d39 37
a75 37
WitSelMgr        (theSelector),
mySsrPts_        (),
srWasDonePts_    (myProblem ()),
srSelSplit_      (false),
myRecoveryPairs_ (myProblem ())
{
WitMaterial * theMat;
WitPeriod     fromPer;
WitPeriod     expPer;

if (DEVELOPMENT)
myMsgFac () ("selSRMsg");

mySsrPts_.allocate1D (myProblem ());

forEachMaterial (theMat, myProblem ())
{
if (not mySelector ()->myHeurAtor ()->selectiveSR (theMat))
continue;

mySsrPts_.myPtrTVecAt (theMat).allocate (myProblem ());

for (fromPer = 1; fromPer < nPeriods (); fromPer ++)
{
expPer = theMat->explosionPeriod (fromPer);

if (theMat->explodeable (expPer))
mySsrPts_.myPtrAt (theMat, fromPer) =
new WitSsrPt (theMat, fromPer, this);
}
}

srSelSplit_ =
myGlobalComp ()->selSplit      ()
or myGlobalComp ()->nonMrSelSplit ()
or myGlobalComp ()->srSelSplit    ();
}
d80 9
a88 9
{
WitMaterial * theMat;
WitPeriod     fromPer;

forEachMaterial (theMat, myProblem ())
if (mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
forEachPeriod (fromPer, myProblem ())
delete mySsrPts_.myPtrAt (theMat, fromPer);
}
d93 2
a94 2
{
WitMaterial * theMat;
d96 3
a98 3
forEachMaterial (theMat, theHeurAtor->myProblem ())
if (theHeurAtor->selectiveSR (theMat))
return true;
d100 2
a101 2
return false;
}
d106 2
a107 2
{
WitSsrPt * theSsrPt;
d109 2
a110 2
if (not mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
return false;
d112 1
a112 1
theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);
d114 2
a115 2
if (theSsrPt == NULL)
return false;
d117 2
a118 2
if (theSsrPt->isSplit ())
return true;
d120 2
a121 2
return theSsrPt->srAllowed ();
}
d126 2
a127 2
{
WitSsrPt * theSsrPt;
d129 1
a129 1
theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);
d131 1
a131 1
witAssert (theSsrPt != NULL);
d133 1
a133 1
witAssert (theSsrPt->srAllowed () or theSsrPt->isSplit ());
d135 2
a136 2
if (srSelSplit_)
theSsrPt->recordFlowSS (srVol);
d138 2
a139 2
if (theSsrPt->srWasDone ())
return;
d141 1
a141 1
theSsrPt->setSrWasDone (true);
d143 2
a144 2
srWasDonePts_.push (theSsrPt);
}
d149 2
a150 2
{
WitSsrPt * theSsrPt;
d152 3
a154 3
while (srWasDonePts_.pop (theSsrPt))
theSsrPt->setSrWasDone (false);
}
d159 22
a180 22
{
WitPeriod  fromPer;
WitSsrPt * theSsrPt;

fprintf (msgFile (),
"\n"
"Part %s:\n\n"
"   Per   S.R. Allowed?\n",
theMat->partName ().myCstring ());

forEachPeriod (fromPer, myProblem ())
{
theSsrPt = mySsrPts_.myPtrAt (theMat, fromPer);

if (theSsrPt != NULL)
fprintf (msgFile (), "   %3d   %s\n",
fromPer,
theSsrPt->srAllowed ()?
"Yes":
"No");
}
}
d185 3
a187 3
{
myRecoveryPairs_.push (theMat, fromPer);
}
d192 9
a200 9
{
WitMaterial * theMat;
WitPeriod     fromPer;

while (myRecoveryPairs_.pop (theMat, fromPer))
{
mySsrPts_.myPtrAt (theMat, fromPer)->recoverInitState ();
}
}
d205 3
a207 3
{
return srSelSplit_;
}
d212 9
a220 11
WitMaterial * theMat,
WitPeriod     rollPer,
double &      theReqVol,
double &      rollVol,
bool &        bddSplit)
{
WitSsrPt * theSsrPt;
double     srAllVol;
double     srNotAllVol;

witAssert (rollVol >= NET_TOL);
d222 1
a222 2
if (not srSelSplit_)
return;
d224 2
a225 2
if (rollPer < 0)
return;
d227 4
a230 1
theSsrPt = mySsrPts_.myPtrAt (theMat, rollPer);
d232 2
a233 2
if (theSsrPt == NULL)
return;
d235 2
a236 2
if (not theSsrPt->isSplit ())
return;
d238 1
a238 1
theSsrPt->defineSplit (rollVol, srAllVol, srNotAllVol);
d240 3
a242 3
if (srAllVol == 0.0)
{
rollVol = 0.0;
d244 2
a245 2
return;
}
d247 1
a247 1
bddSplit = true;
d249 2
a250 2
if (srAllVol >= rollVol)
return;
d252 1
a252 1
rollVol    = srAllVol;
d254 2
a255 2
theReqVol += srNotAllVol;
}
d260 7
a266 7
WitBopEntry * theBopEnt,
WitConsEntry *,
WitPeriod,
WitPeriod     fillPer)
{
return myAltPtFor (theBopEnt->myPart (), fillPer);
}
d271 14
a284 14
{
WitMaterial * theMat;
WitSsrPt *    theSsrPt;

theMat = thePart->thisMat ();

if (theMat != NULL)
if (hasanSsrPtFor (theMat, fillPer))
{
theSsrPt = mySsrPts_.myPtrAt (theMat, fillPer);

if (theSsrPt->srAllowed ())
return theSsrPt->myDetAltPt ();
}
d286 2
a287 2
return NULL;
}
d292 3
a294 3
{
return true;
}
d299 3
a301 3
{
return true;
}
d306 3
a308 3
{
return true;
}
d313 3
a315 3
{
return "Stock Reallocation";
}
d320 6
a325 6
{
return
mySsrPts_.myPtrTVecAt (theMat).isAllocated ()?
(mySsrPts_.myPtrAt (theMat, fromPer) != NULL):
false;
}
d332 13
a344 13
WitMaterial * theMat,
WitPeriod     fromPer,
WitSsrMgr *   theSsrMgr):

WitDetSelPt (),

myMat_      (theMat),
myFromPer_  (fromPer),
mySsrMgr_   (theSsrMgr),
srAllowed_  (true),
srWasDone_  (false)
{
}
d349 2
a350 2
{
}
d355 10
a364 10
double   rollVol,
double & srAllVol,
double & srNotAllVol)
{
WitSelCandDblStack theSplitPairs (mySsrMgr_->myProblem ());
double             unbddVol;
bool               splitFound;
WitSelCand *       theSelCand;
double             splitVol;
bool               srAllowedVal;
d366 1
a366 1
witAssert (rollVol >= NET_TOL);
d368 1
a368 1
witAssert (isSplit ());
d370 2
a371 2
srAllVol    = 0.0;
srNotAllVol = 0.0;
d373 1
a373 1
mySplitPt ()->defineSplit (rollVol, theSplitPairs, unbddVol);
d375 1
a375 1
theSplitPairs.reverse ();
d377 1
a377 1
splitFound = theSplitPairs.pop (theSelCand, splitVol);
d379 3
a381 3
if (not splitFound)
{
srAllVol = unbddVol;
d383 2
a384 2
return;
}
d386 3
a388 3
if (DEBUG_MODE)
{
theSelCand->getSsrData (srAllowedVal);
d390 2
a391 2
witAssert (srAllowedVal);
}
d393 1
a393 1
srAllVol   = splitVol;
d395 1
a395 1
splitFound = theSplitPairs.pop (theSelCand, splitVol);
d397 3
a399 3
if (not splitFound)
{
srNotAllVol = unbddVol;
d401 2
a402 2
return;
}
d404 3
a406 3
if (DEBUG_MODE)
{
theSelCand->getSsrData (srAllowedVal);
d408 2
a409 2
witAssert (not srAllowedVal);
}
d411 1
a411 1
srNotAllVol = splitVol;
d413 2
a414 2
witAssert (theSplitPairs.isEmpty ());
}
d419 2
a420 2
{
witAssert (theValue != srWasDone_);
d422 2
a423 2
srWasDone_ = theValue;
}
d428 2
a429 2
{
srAllowed_ = true;
d431 3
a433 3
if (mySelMgr ()->selPrintLevelAt (3))
printRecovery ();
}
d438 3
a440 3
{
return mySsrMgr_;
}
d444 8
a451 8
void WitSsrPt::prtID ()
{
fprintf (mySsrMgr_->msgFile (),
"   Part:             %s\n"
"   From Per:         %d\n",
myMat_->partName ().myCstring (),
myFromPer_);
}
d455 4
a458 4
bool WitSsrPt::splittable ()
{
return mySsrMgr_->srSelSplit ();
}
d463 4
a466 4
{
thePart = myMat_;
thePer  = myFromPer_;
}
d471 3
a473 3
{
return new WitSsrCand (srAllowed_, mySsrMgr_->myProblem ());
}
d478 2
a479 2
{
witAssert (mySsrMgr_->mySelector ()->myHeurAtor ()->tempCommActive ());
d481 3
a483 3
if (srAllowed ())
if (srWasDone_)
return true;
d485 2
a486 2
return false;
}
d491 2
a492 2
{
witAssert (srAllowed_);
d494 2
a495 2
setSrAllowed (false);
}
d500 3
a502 3
{
mySsrMgr_->storeRecoveryPair (myMat_, myFromPer_);
}
d507 2
a508 2
{
witAssert (srAllowed_);
d510 2
a511 2
setSrAllowed (false);
}
d516 2
a517 2
{
witAssert (not srAllowed_);
d519 2
a520 2
setSrAllowed (true);
}
d525 3
a527 3
{
mySsrMgr_->print (myMat_);
}
d532 3
a534 3
{
if (mySelMgr ()->mySelector ()->sglSrc ())
mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (srAllowed_);
d536 2
a537 2
srAllowed_ = srAllowedVal;
}
d542 8
a549 8
{
fprintf (mySsrMgr_->msgFile (),
"   Selective Stock Reallocation Period Recovered:\n"
"      Part:     %s\n"
"      From Per: %d\n\n",
myMat_->partName ().myCstring (),
myFromPer_);
}
d557 4
a560 4
WitSelCand (theProblem),
srAllowed_ (srAllowedVal)
{
}
d565 2
a566 2
{
}
d571 3
a573 3
{
fprintf (msgFile (), "      SR Allowed?    %s\n", srAllowed_? "Yes": "No");
}
d578 3
a580 3
{
srAllowedVal = srAllowed_;
}
@


1.83
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d39 37
a75 37
      WitSelMgr        (theSelector),
      mySsrPts_        (),
      srWasDonePts_    (myProblem ()),
      srSelSplit_      (false),
      myRecoveryPairs_ (myProblem ())
   {
   WitMaterial * theMat;
   WitPeriod     fromPer;
   WitPeriod     expPer;

   if (DEVELOPMENT)
      myMsgFac () ("selSRMsg");

   mySsrPts_.allocate1D (myProblem ());

   forEachMaterial (theMat, myProblem ())
      {
      if (not mySelector ()->myHeurAtor ()->selectiveSR (theMat))
         continue;

      mySsrPts_.myPtrTVecAt (theMat).allocate (myProblem ());

      for (fromPer = 1; fromPer < nPeriods (); fromPer ++)
         {
         expPer = theMat->explosionPeriod (fromPer);

         if (theMat->explodeable (expPer))
            mySsrPts_.myPtrAt (theMat, fromPer) =
               new WitSsrPt (theMat, fromPer, this);
         }
      }

   srSelSplit_ =
         myGlobalComp ()->selSplit      ()
      or myGlobalComp ()->nonMrSelSplit () 
      or myGlobalComp ()->srSelSplit    ();
   }
d80 9
a88 9
   {
   WitMaterial * theMat;
   WitPeriod     fromPer;

   forEachMaterial (theMat, myProblem ())
      if (mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
         forEachPeriod (fromPer, myProblem ())
            delete mySsrPts_.myPtrAt (theMat, fromPer);
   }
d93 2
a94 2
   {
   WitMaterial * theMat;
d96 3
a98 3
   forEachMaterial (theMat, theHeurAtor->myProblem ())
      if (theHeurAtor->selectiveSR (theMat))
         return true;
d100 2
a101 2
   return false;
   }
d106 2
a107 2
   {
   WitSsrPt * theSsrPt;
d109 2
a110 2
   if (not mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
      return false;
d112 1
a112 1
   theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);
d114 2
a115 2
   if (theSsrPt == NULL)
      return false;
d117 2
a118 2
   if (theSsrPt->isSplit ())
      return true;
d120 2
a121 2
   return theSsrPt->srAllowed ();
   }
d126 2
a127 2
   {
   WitSsrPt * theSsrPt;
d129 1
a129 1
   theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);
d131 1
a131 1
   witAssert (theSsrPt != NULL);
d133 1
a133 1
   witAssert (theSsrPt->srAllowed () or theSsrPt->isSplit ());
d135 2
a136 2
   if (srSelSplit_)
      theSsrPt->recordFlowSS (srVol);
d138 2
a139 2
   if (theSsrPt->srWasDone ())
      return;
d141 1
a141 1
   theSsrPt->setSrWasDone (true);
d143 2
a144 2
   srWasDonePts_.push (theSsrPt);
   }
d149 2
a150 2
   {
   WitSsrPt * theSsrPt;
d152 3
a154 3
   while (srWasDonePts_.pop (theSsrPt))
      theSsrPt->setSrWasDone (false);
   }
d159 22
a180 22
   {
   WitPeriod  fromPer;
   WitSsrPt * theSsrPt;

   fprintf (msgFile (),
      "\n"
      "Part %s:\n\n"
      "   Per   S.R. Allowed?\n",
      theMat->partName ().myCstring ());

   forEachPeriod (fromPer, myProblem ())
      {
      theSsrPt = mySsrPts_.myPtrAt (theMat, fromPer);

      if (theSsrPt != NULL)
         fprintf (msgFile (), "   %3d   %s\n",
            fromPer,
            theSsrPt->srAllowed ()?
               "Yes":
               "No");
      }
   }
d185 3
a187 3
   {
   myRecoveryPairs_.push (theMat, fromPer);
   }
d192 9
a200 9
   {
   WitMaterial * theMat;
   WitPeriod     fromPer;

   while (myRecoveryPairs_.pop (theMat, fromPer))
      {
      mySsrPts_.myPtrAt (theMat, fromPer)->recoverInitState ();
      }
   }
d205 3
a207 3
   {
   return srSelSplit_;
   }
d212 11
a222 9
      WitMaterial * theMat,
      WitPeriod     rollPer,
      double &      theReqVol,
      double &      rollVol,
      bool &        bddSplit)
   {
   WitSsrPt * theSsrPt;
   double     srAllVol;
   double     srNotAllVol;
d224 2
a225 1
   witAssert (rollVol >= NET_TOL);
d227 2
a228 2
   if (not srSelSplit_)
      return;
d230 1
a230 4
   if (rollPer < 0)
      return;
   
   theSsrPt = mySsrPts_.myPtrAt (theMat, rollPer);
d232 2
a233 2
   if (theSsrPt == NULL)
      return;
d235 2
a236 2
   if (not theSsrPt->isSplit ())
      return;
d238 1
a238 1
   theSsrPt->defineSplit (rollVol, srAllVol, srNotAllVol);
d240 3
a242 3
   if (srAllVol == 0.0)
      {
      rollVol = 0.0;
d244 2
a245 2
      return;
      }
d247 1
a247 1
   bddSplit = true;
d249 2
a250 2
   if (srAllVol >= rollVol)
      return;
d252 1
a252 1
   rollVol    = srAllVol;
d254 2
a255 2
   theReqVol += srNotAllVol;
   }
d260 7
a266 7
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod,
      WitPeriod     fillPer)
   {
   return myAltPtFor (theBopEnt->myPart (), fillPer);
   }
d271 14
a284 14
   {
   WitMaterial * theMat;
   WitSsrPt *    theSsrPt;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (hasanSsrPtFor (theMat, fillPer))
         {
         theSsrPt = mySsrPts_.myPtrAt (theMat, fillPer);

         if (theSsrPt->srAllowed ())
            return theSsrPt->myDetAltPt ();
         }
d286 2
a287 2
   return NULL;
   }
d292 3
a294 3
   {
   return true;
   }
d299 3
a301 3
   {
   return true;
   }
d306 3
a308 3
   {
   return true;
   }
d313 3
a315 3
   {
   return "Stock Reallocation";
   }
d320 6
a325 6
   {
   return
      mySsrPts_.myPtrTVecAt (theMat).isAllocated ()?
         (mySsrPts_.myPtrAt (theMat, fromPer) != NULL):
         false;
   }
d332 13
a344 13
         WitMaterial * theMat,
         WitPeriod     fromPer,
         WitSsrMgr *   theSsrMgr):

      WitDetSelPt (),

      myMat_      (theMat),
      myFromPer_  (fromPer),
      mySsrMgr_   (theSsrMgr),
      srAllowed_  (true),
      srWasDone_  (false)
   {
   }
d349 2
a350 2
   {
   }
d355 10
a364 10
      double   rollVol,
      double & srAllVol,
      double & srNotAllVol)
   {
   WitSelCandDblStack theSplitPairs (mySsrMgr_->myProblem ());
   double             unbddVol;
   bool               splitFound;
   WitSelCand *       theSelCand;
   double             splitVol;
   bool               srAllowedVal;
d366 1
a366 1
   witAssert (rollVol >= NET_TOL);
d368 1
a368 1
   witAssert (isSplit ());
d370 2
a371 2
   srAllVol    = 0.0;
   srNotAllVol = 0.0;
d373 1
a373 1
   mySplitPt ()->defineSplit (rollVol, theSplitPairs, unbddVol);
d375 1
a375 1
   theSplitPairs.reverse ();
d377 1
a377 1
   splitFound = theSplitPairs.pop (theSelCand, splitVol);
d379 3
a381 3
   if (not splitFound)
      {
      srAllVol = unbddVol;
d383 2
a384 2
      return;
      }
d386 3
a388 3
   if (DEBUG_MODE)
      {
      theSelCand->getSsrData (srAllowedVal);
d390 2
a391 2
      witAssert (srAllowedVal);
      }
d393 1
a393 1
   srAllVol   = splitVol;
d395 1
a395 1
   splitFound = theSplitPairs.pop (theSelCand, splitVol);
d397 3
a399 3
   if (not splitFound)
      {
      srNotAllVol = unbddVol;
d401 2
a402 2
      return;
      }
d404 3
a406 3
   if (DEBUG_MODE)
      {
      theSelCand->getSsrData (srAllowedVal);
d408 2
a409 2
      witAssert (not srAllowedVal);
      }
d411 1
a411 1
   srNotAllVol = splitVol;
d413 2
a414 2
   witAssert (theSplitPairs.isEmpty ());
   }
d419 2
a420 2
   {
   witAssert (theValue != srWasDone_);
d422 2
a423 2
   srWasDone_ = theValue;
   }
d428 2
a429 2
   {
   srAllowed_ = true;
d431 3
a433 3
   if (mySelMgr ()->selPrintLevelAt (3))
      printRecovery ();
   }
d438 3
a440 3
   {
   return mySsrMgr_;
   }
d444 8
a451 8
void WitSsrPt::prtID ()        
   {
   fprintf (mySsrMgr_->msgFile (),
      "   Part:             %s\n"
      "   From Per:         %d\n",
      myMat_->partName ().myCstring (),
      myFromPer_);
   }
d455 4
a458 4
bool WitSsrPt::splittable ()   
   {
   return mySsrMgr_->srSelSplit ();
   }
d463 4
a466 4
   {
   thePart = myMat_;
   thePer  = myFromPer_;
   }
d471 3
a473 3
   {
   return new WitSsrCand (srAllowed_, mySsrMgr_->myProblem ());
   }
d478 2
a479 2
   {
   witAssert (mySsrMgr_->mySelector ()->myHeurAtor ()->tempCommActive ());
d481 3
a483 3
   if (srAllowed ())
      if (srWasDone_)
         return true;
d485 2
a486 2
   return false;
   }
d491 2
a492 2
   {
   witAssert (srAllowed_);
d494 2
a495 2
   setSrAllowed (false);
   }
d500 3
a502 3
   {
   mySsrMgr_->storeRecoveryPair (myMat_, myFromPer_);
   }
d507 2
a508 2
   {
   witAssert (srAllowed_);
d510 2
a511 2
   setSrAllowed (false);
   }
d516 2
a517 2
   {
   witAssert (not srAllowed_);
d519 2
a520 2
   setSrAllowed (true);
   }
d525 3
a527 3
   {
   mySsrMgr_->print (myMat_);
   }
d532 3
a534 3
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (srAllowed_);
d536 2
a537 2
   srAllowed_ = srAllowedVal;
   }
d542 8
a549 8
   {
   fprintf (mySsrMgr_->msgFile (),
      "   Selective Stock Reallocation Period Recovered:\n"
      "      Part:     %s\n"
      "      From Per: %d\n\n",
      myMat_->partName ().myCstring (),
      myFromPer_);
   }
d557 4
a560 4
      WitSelCand (theProblem),
      srAllowed_ (srAllowedVal)
   {
   }
d565 2
a566 2
   {
   }
d571 3
a573 3
   {
   fprintf (msgFile (), "      SR Allowed?    %s\n", srAllowed_? "Yes": "No");
   }
d578 3
a580 3
   {
   srAllowedVal = srAllowed_;
   }
@


1.82
log
@Selection Recovery
@
text
@a26 1
#include <RecoverySet.h>
a37 1
      WitSelMgr      (theSelector),
d39 5
a43 4
      mySsrPts_      (),
      srWasDonePts_  (myProblem ()),
      srSelSplit_    (false),
      myRecoverySet_ (NULL)
a74 5

   if (myGlobalComp ()->selectionRecovery ())
      {
      myRecoverySet_ = new WitRecoverySet <WitSsrMgr, WitMaterial> (this);
      }
a83 2
   delete myRecoverySet_;

d184 8
a191 1
void WitSsrMgr::recoverInitState (WitMaterial * theMat, WitPeriod thePer)
d193 7
a199 1
   mySsrPts_.myPtrAt (theMat, thePer)->recoverInitState ();
d501 1
a501 1
   mySsrMgr_->myRecoverySet ()->storeRecoveryPt (myMat_, myFromPer_);
@


1.81
log
@Selection Recovery
@
text
@d27 1
a27 1
#include <AltSet.h>
d39 1
a39 1
      WitSelMgr     (theSelector),
d41 4
a44 4
      mySsrPts_     (),
      srWasDonePts_ (myProblem ()),
      srSelSplit_   (false),
      myAltSet_     (NULL)
d79 1
a79 1
      myAltSet_ = new WitAltSet <WitSsrMgr, WitMaterial> (this);
d90 1
a90 1
   delete myAltSet_;
d192 1
a192 1
void WitSsrMgr::recoverInitSel (WitMaterial * theMat, WitPeriod thePer)
d194 1
a194 1
   mySsrPts_.myPtrAt (theMat, thePer)->recoverInitSel ();
d422 1
a422 1
void WitSsrPt::recoverInitSel ()
d494 1
a494 1
void WitSsrPt::recAltForRecovery ()
d496 1
a496 1
   mySsrMgr_->myAltSet ()->recAltForRecovery (myMat_, myFromPer_);
@


1.80
log
@Selection Recovery
@
text
@d494 1
a494 1
void WitSsrPt::recordAlteration ()
d496 1
a496 1
   mySsrMgr_->myAltSet ()->recordAlteration (myMat_, myFromPer_);
@


1.79
log
@Selection Recovery
@
text
@a52 5
   if (myGlobalComp ()->selectionRecovery ())
      {
      myAltSet_ = new WitAltSet <WitSsrMgr, WitMaterial> (this);
      }

d76 5
@


1.78
log
@Selection Recovery
@
text
@d494 7
a531 5

   if (mySelMgr ()->myGlobalComp ()->selectionRecovery ())
      {
      mySsrMgr_->myAltSet ()->recordAlteration (myMat_, myFromPer_);
      }
@


1.77
log
@Selection Recovery
@
text
@d27 1
d43 2
a44 1
      srSelSplit_   (false)
d53 5
d90 2
d192 7
a471 22
void WitSsrPt::printRecoverO ()
   {
   if (srAllowed_)
      return;

   fprintf (mySsrMgr_->msgFile (),
      "   Selective Stock Reallocation Period Recovered:\n"
      "      Part:     %s\n"
      "      From Per: %d\n\n",
      myMat_->partName ().myCstring (),
      myFromPer_);
   }

//------------------------------------------------------------------------------

void WitSsrPt::recoverInitSeO ()
   {
   srAllowed_ = true;
   }

//------------------------------------------------------------------------------

d527 3
a529 1
      recAlteratOld ();
@


1.76
log
@Selection Recovery.
@
text
@d406 10
d537 12
@


1.75
log
@Selection Recovery
@
text
@a297 6
void WitSsrMgr::recoverSelections ()
   {
   }

//------------------------------------------------------------------------------

@


1.74
log
@Selection Recovery
@
text
@d529 1
a529 1
      recAlteration ();
@


1.73
log
@Selection Recovery.
@
text
@d298 6
d452 1
a452 1
void WitSsrPt::printRecovery ()
d467 1
a467 1
void WitSsrPt::recoverInitSel ()
@


1.72
log
@Selection Recovery.
@
text
@d446 1
a446 8
void WitSsrPt::recoverInitSel ()
   {
   srAllowed_ = true;
   }

//------------------------------------------------------------------------------

void WitSsrPt::prtRecInitSel ()
d461 7
@


1.71
log
@Selection Recovery.
@
text
@a396 10
void WitSsrPt::setSrAllowed (bool srAllowedVal)
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (srAllowed_);

   srAllowed_ = srAllowedVal;
   }

//------------------------------------------------------------------------------

d448 1
a448 1
   stronglyAssert (false);
d455 9
a463 1
   stronglyAssert (false);
d514 13
@


1.70
log
@Lead Time Bounds
@
text
@d456 14
@


1.69
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d244 7
d254 1
a254 1
   theMat = theBopEnt->myPart ()->thisMat ();
d284 7
@


1.68
log
@Updated the copyright date on all source files.
@
text
@d28 1
a28 1
#include <Global.h>
@


1.67
log
@Revised mappingIndex code.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.66
log
@Low-Pri Prop-Rt.
@
text
@a31 1
#include <MapIdxI.h>
@


1.65
log
@Low-Pri Prop-Rt.
@
text
@a402 7
void WitSsrPt::printSelection ()
   {
   mySsrMgr_->print (myMat_);
   }

//------------------------------------------------------------------------------

d482 7
@


1.64
log
@Low-Pri Prop-Rt.
@
text
@d481 1
a481 1
void WitSsrPt::cancelTempAlt (WitSelCand * theSelCand)
a482 2
   witAssert (theSelCand == NULL);

a488 7

bool WitSsrPt::cancelNeedsSelCand ()
   {
   return false;
   }

//------------------------------------------------------------------------------
@


1.63
log
@Low-Pri Prop-Rt.
@
text
@d452 1
a452 1
   witAssert (mySsrMgr_->mySelector ()->myHeurAtor ()->tempMode ());
@


1.62
log
@Low-Pri Prop-Rt.
@
text
@a434 15
void WitSsrPt::restoreSelTo (WitSelCand * theSelCand)
   {
   bool srAllowedVal;

   theSelCand->getSsrData (srAllowedVal);

   witAssert (srAllowedVal);

   witAssert (not srAllowed_);

   setSrAllowed (true);
   }

//------------------------------------------------------------------------------

d480 18
@


1.61
log
@Low-Pri Prop-Rt.
@
text
@d435 15
d460 1
a460 1
   return new WitSsrCand (this);
d498 1
a498 1
WitSsrCand::WitSsrCand (WitSsrPt * theSsrPt):
d500 2
a501 3
      WitSelCand (theSsrPt->mySsrMgr ()->myProblem ()),
      mySsrPt_   (theSsrPt),
      srAllowed_ (theSsrPt->srAllowed ())
a519 11
void WitSsrCand::restoreSelToThis ()
   {
   witAssert (srAllowed_);

   witAssert (not mySsrPt_->srAllowed ());

   mySsrPt_->setSrAllowed (true);
   }

//------------------------------------------------------------------------------

@


1.60
log
@Low-Pri Prop-Rt.
@
text
@d198 3
a200 7
   WitSsrPt *         theSsrPt;
   WitSelCandDblStack theSplitPairs (myProblem ());
   bool               lastUnbdd;
   bool               splitFound;
   WitSelCand *       theSelCand;
   double             splitVol;
   bool               srAllowedVal;
d218 1
a218 3
   theSsrPt->mySplitPt ()->defineSplit (rollVol, theSplitPairs, lastUnbdd);

   theSplitPairs.reverse ();
d220 1
a220 3
   splitFound = theSplitPairs.pop (theSelCand, splitVol);

   if (not splitFound)
d229 1
a229 8
   if (DEBUG_MODE)
      {
      theSelCand->getSsrData (srAllowedVal);

      witAssert (srAllowedVal);
      }

   if (splitVol >= rollVol)
d232 1
a232 1
   rollVol    = splitVol;
d234 1
a234 15
   splitFound = theSplitPairs.pop (theSelCand, splitVol);

   if (not splitFound)
      return;

   if (DEBUG_MODE)
      {
      theSelCand->getSsrData (srAllowedVal);

      witAssert (not srAllowedVal);
      }

   theReqVol += splitVol;

   witAssert (theSplitPairs.isEmpty ());
d320 64
a505 7
void WitSsrCand::updateToCurSel ()
   {
   srAllowed_ = mySsrPt_->srAllowed ();
   }

//------------------------------------------------------------------------------

@


1.59
log
@Low-Pri Prop-Rt.
@
text
@d23 1
d285 1
a285 1
            return theSsrPt->myAltPt ();
a367 13
bool WitSsrPt::hasResAlt ()
   {
   witAssert (mySsrMgr_->mySelector ()->myHeurAtor ()->tempMode ());

   if (srAllowed ())
      if (srWasDone_)
         return true;

   return false;
   }

//------------------------------------------------------------------------------

d415 13
@


1.58
log
@Low-Pri Prop-Rt.
@
text
@d267 1
a267 1
WitSelAlt * WitSsrMgr::mySelAltFor (
d284 1
a284 1
            return theSsrPt->mySelAlt ();
@


1.57
log
@Low-Pri Prop-Rt.
@
text
@d420 1
a420 1
void WitSsrPt::tempAlterSel ()
d422 1
a422 3
   witAssert (srAllowed_);

   setSrAllowed (false);
d427 1
a427 1
WitSelCand * WitSsrPt::newSelCand ()
d429 3
a431 1
   return new WitSsrCand (this);
d436 1
a436 1
void WitSsrPt::alterSelection ()
@


1.56
log
@Low-Pri Prop-Rt.
@
text
@d267 1
a267 1
WitSelPt * WitSsrMgr::mySelPtForAlt (
d284 1
a284 1
            return theSsrPt;
a379 9
void WitSsrPt::alterSelection ()
   {
   witAssert (srAllowed_);

   setSrAllowed (false);
   }

//------------------------------------------------------------------------------

d435 9
@


1.55
log
@Low-Pri Prop-Rt.
@
text
@d330 1
a330 1
      WitSelPt   (),
d332 5
a336 5
      myMat_     (theMat),
      myFromPer_ (fromPer),
      mySsrMgr_  (theSsrMgr),
      srAllowed_ (true),
      srWasDone_ (false)
@


1.54
log
@Low-Pri Prop-Rt.
@
text
@d203 1
d236 6
a241 1
   witAssert (theSelCand->mySsrCand ()->srAllowed ());
d253 6
a258 1
   witAssert (not theSelCand->mySsrCand ()->srAllowed ());
d488 1
a488 1
WitSsrCand * WitSsrCand::mySsrCand ()
d490 1
a490 1
   return this;
@


1.53
log
@Low-Pri Prop-Rt.
@
text
@a301 7
WitSelCand * WitSsrMgr::newSelCand ()
   {
   return new WitSsrCand (this);
   }

//------------------------------------------------------------------------------

d427 1
a427 1
void WitSsrPt::setToMyCurSel (WitSelCand * theSelCand)
d429 1
a429 1
   theSelCand->setToCurSelOf (this);
d436 1
a436 1
WitSsrCand::WitSsrCand (WitSsrMgr * theSsrMgr):
d438 3
a440 3
      WitSelCand (theSsrMgr),
      mySsrPt_   (NULL),
      srAllowed_ (true)
d459 7
a467 2
   witAssert (active ());

a478 2
   witAssert (active ());

a480 10

//------------------------------------------------------------------------------

void WitSsrCand::setToCurSelOf (WitSsrPt * theSsrPt)
   {
   witAssert (active ());

   mySsrPt_   = theSsrPt;
   srAllowed_ = theSsrPt->srAllowed ();
   }
@


1.52
log
@Low-Pri Prop-Rt.
@
text
@d344 10
a433 11
void WitSsrPt::restoreSel (WitSelCand * theSelCand)
   {
   witAssert (theSelCand->mySsrCand ()->srAllowed ());

   witAssert (not srAllowed_);

   setSrAllowed (true);
   }

//------------------------------------------------------------------------------

a439 10

void WitSsrPt::setSrAllowed (bool srAllowedVal)
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (srAllowed_);

   srAllowed_ = srAllowedVal;
   }

//------------------------------------------------------------------------------
d446 1
d466 13
d492 1
@


1.51
log
@Low-Pri Prop-Rt.
@
text
@d435 1
a435 1
void WitSsrPt::setToCurSel (WitSelCand * theSelCand)
d437 1
a437 1
   theSelCand->mySsrCand ()->setToCurSel (this);
d469 1
a469 1
void WitSsrCand::setToCurSel (WitSsrPt * theSsrPt)
d471 1
a471 3
   witAssert (active ());

   srAllowed_ = theSsrPt->srAllowed ();
d476 1
a476 1
void WitSsrCand::prtID ()
d478 3
a480 1
   fprintf (msgFile (), "      SR Allowed?    %s\n", srAllowed_? "Yes": "No");
d485 1
a485 1
WitSsrCand * WitSsrCand::mySsrCand ()
d489 1
a489 1
   return this;
@


1.50
log
@Low-Pri Prop-Rt.
@
text
@d471 2
d487 2
@


1.49
log
@Low-Pri Prop-Rt.
@
text
@d38 1
a38 1
      WitSelMgr          (theSelector),
d40 3
a42 5
      mySsrCandForSR_    (NULL),
      mySsrCandForNonSR_ (NULL),
      mySsrPts_          (),
      srWasDonePts_      (myProblem ()),
      srSelSplit_        (false)
a50 3
   mySsrCandForSR_    = new WitSsrCand (true,  this);
   mySsrCandForNonSR_ = new WitSsrCand (false, this);

a86 3

   delete mySsrCandForNonSR_;
   delete mySsrCandForSR_;
d235 1
a235 1
   witAssert (theSelCand == mySsrCandForSR_);
d247 1
a247 1
   witAssert (theSelCand == mySsrCandForNonSR_);
d302 7
a399 10
WitSelCand * WitSsrPt::curSelCand ()
   {
   return
      srAllowed_?
         mySsrMgr_->mySsrCandForSR    ():
         mySsrMgr_->mySsrCandForNonSR ();
   }

//------------------------------------------------------------------------------

d426 2
d430 4
a433 1
   witAssert (theSelCand == mySsrMgr_->mySsrCandForSR ());
d435 3
a437 1
   setSrAllowed (true);
d454 2
a455 1
WitSsrCand::WitSsrCand (bool srAllowedVal, WitSsrMgr * theSsrMgr):
d457 5
d463 1
a463 1
      srAllowed_ (srAllowedVal)
d469 1
a469 1
WitSsrCand::~WitSsrCand ()
d471 1
@


1.48
log
@Low-Pri Prop-Rt.
@
text
@d53 2
a54 2
   mySsrCandForSR_    = new WitSsrCand (true,  myProblem ());
   mySsrCandForNonSR_ = new WitSsrCand (false, myProblem ());
d458 2
a459 2
WitSsrCand::WitSsrCand (bool srAllowedVal, WitProblem * theProblem):
      WitSelCand (theProblem),
@


1.47
log
@Low-Pri Prop-Rt.
@
text
@d24 1
d53 2
a54 2
   mySsrCandForSR_    = new WitSsrCand (true,  this);
   mySsrCandForNonSR_ = new WitSsrCand (false, this);
d332 1
a334 1
   select (theSsrMgr->mySsrCandForSR ());
a353 7
bool WitSsrPt::srAllowed ()
   {
   return selSelCand ()->mySsrCand ()->srAllowed ();
   }

//------------------------------------------------------------------------------

d369 1
a369 1
   witAssert (srAllowed ());
d371 1
a371 1
   select (mySsrMgr_->mySsrCandForNonSR ());
d403 4
a406 1
   return selSelCand ();
d428 1
a428 1
   witAssert (srAllowed ());
d430 1
a430 1
   select (mySsrMgr_->mySsrCandForNonSR ());
d437 1
a437 1
   witAssert (not srAllowed ());
d441 11
a451 1
   select (theSelCand);
d458 2
a459 2
WitSsrCand::WitSsrCand (bool srAllowedVal, WitSsrMgr * theSsrMgr):
      WitSelCand (theSsrMgr->myProblem ()),
@


1.46
log
@Low-Pri Prop-Rt.
@
text
@d16 1
a17 1
//    SsrPt.
a97 46
WitSelPt * WitSsrMgr::mySelPtForAlt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod,
      WitPeriod     fillPer)
   {
   WitMaterial * theMat;
   WitSsrPt *    theSsrPt;

   theMat = theBopEnt->myPart ()->thisMat ();

   if (theMat != NULL)
      if (hasanSsrPtFor (theMat, fillPer))
         {
         theSsrPt = mySsrPts_.myPtrAt (theMat, fillPer);

         if (theSsrPt->srAllowed ())
            return theSsrPt;
         }

   return NULL;
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitSsrMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

const char * WitSsrMgr::selCaseName ()
   {
   return "Stock Reallocation";
   }

//------------------------------------------------------------------------------

d263 5
a267 1
bool WitSsrMgr::hasanSsrPtFor (WitMaterial * theMat, WitPeriod fromPer)
d269 15
a283 4
   return
      mySsrPts_.myPtrTVecAt (theMat).isAllocated ()?
         (mySsrPts_.myPtrAt (theMat, fromPer) != NULL):
         false;
a286 2
// Implementation of class SsrCand.
//------------------------------------------------------------------------------
d288 1
a288 4
WitSsrCand::WitSsrCand (bool srAllowedVal, WitSsrMgr * theSsrMgr):
      WitSelCand (theSsrMgr->myProblem ()),

      srAllowed_ (srAllowedVal)
d290 1
d295 1
a295 1
WitSsrCand::~WitSsrCand ()
d297 1
d302 1
a302 1
void WitSsrCand::prtID ()
d304 1
a304 1
   fprintf (msgFile (), "      SR Allowed?    %s\n", srAllowed_? "Yes": "No");
d309 1
a309 1
WitSsrCand * WitSsrCand::mySsrCand ()
d311 4
a314 1
   return this;
d446 31
@


1.45
log
@Low-Pri Prop-Rt.
@
text
@d375 16
a476 17

//------------------------------------------------------------------------------

void WitSsrPt::setSrWasDone (bool theValue)
   {
   witAssert (theValue != srWasDone_);

   srWasDone_ = theValue;
   }

//------------------------------------------------------------------------------

bool WitSsrPt::srAllowed ()
   {
   return selSelCand ()->mySsrCand ()->srAllowed ();
   }

@


1.44
log
@Removed a bad function overload.
@
text
@d422 7
@


1.43
log
@Corrected a file inclusion AIX porting bug.
@
text
@d107 1
a107 1
   theMat = theBopEnt->myPart ()->myMat ();
@


1.42
log
@Continued implementation of post-implosion pegging.
@
text
@d30 1
@


1.41
log
@Continued implementation of proportionate routing.
@
text
@a29 1
#include <PtrSchedI.h>
@


1.40
log
@Continued implementation of proportionate routing.
@
text
@a436 7
WitPeriod WitSsrPt::myPeriod ()
   {
   return myFromPer_;
   }

//------------------------------------------------------------------------------

@


1.39
log
@Continued implementation of proportionate routing.
Fixed a bug in selection splitting for selective stock reallocation.
@
text
@d188 1
a188 1
      mySelector ()->recordFlowSS (theSsrPt, srVol);
@


1.38
log
@Continued implementation of proportionate routing.
@
text
@d23 1
d247 2
a248 1
      double &      rollVol)
d250 8
a257 4
   WitSsrPt *   theSsrPt;
   bool         splitFound;
   WitSelCand * theSelCand;
   double       splitVol;
d273 12
a284 3
   startSplitExpAbs (theSsrPt, rollVol);
   
   splitFound = findNextSplitAbs (theSelCand, splitVol);
d286 1
a286 3
   if (DEBUG_MODE)
      if (not splitFound)
         witAssert (splitVol == 0.0);
d290 6
a295 3
   if (splitVol < rollVol)
      {
      rollVol    = splitVol;
d297 2
a298 1
      splitFound = findNextSplitAbs (theSelCand, splitVol);
d300 1
a300 3
      if (splitFound)
         {
         witAssert (theSelCand == mySsrCandForNonSR_);
d302 1
a302 3
         theReqVol += splitVol;
         }
      }
d304 1
a304 1
   finishSplitExp ();
@


1.37
log
@Continued implementation of proportionate routing.
@
text
@d187 1
a187 1
      recordFlowSS (theSsrPt, srVol);
@


1.36
log
@Continued implementation of proportionate routing.
@
text
@d106 1
a106 1
   theBopEnt->myPart ()->getMaterial (theMat);
@


1.35
log
@Continued implementation of proportionate routing.
@
text
@d325 1
a325 1
   fprintf (msgFile (), "   SR Allowed?  %s\n", srAllowed_? "Yes": "No");
d401 2
a402 2
      "   Part:        %s\n"
      "   From Per:    %d\n",
@


1.34
log
@Continued implementation of proportionate routing.
@
text
@d309 1
a309 1
      WitSelCand (theSsrMgr),
@


1.33
log
@Continued implementation of proportionate routing.
@
text
@d97 1
a97 1
WitSelPt * WitSsrMgr::mySelPt (
@


1.32
log
@Continued implementation of Proportionate Routing.
@
text
@d21 1
d457 8
@


1.31
log
@Internal changes.
@
text
@d142 1
a142 1
bool WitSsrMgr::ssrNeeded (WitHeurAtor * theHeurAtor)
@


1.30
log
@Internal changes.
@
text
@d57 1
a57 1
      if (! mySelector ()->myHeurAtor ()->selectiveSR (theMat))
d74 2
a75 2
      || myGlobalComp ()->nonMrSelSplit () 
      || myGlobalComp ()->srSelSplit    ();
d159 1
a159 1
   if (! mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
d183 1
a183 1
   witAssert (theSsrPt->srAllowed () || theSsrPt->isSplit ());
d252 1
a252 1
   if (! srSelSplit_)
d263 1
a263 1
   if (! theSsrPt->isSplit ())
d271 1
a271 1
      if (! splitFound)
d441 1
a441 1
   witAssert (! srAllowed ());
@


1.29
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d41 1
a41 1
      srSelSplit_        (witFALSE)
d50 2
a51 2
   mySsrCandForSR_    = new WitSsrCand (witTRUE,  this);
   mySsrCandForNonSR_ = new WitSsrCand (witFALSE, this);
d121 1
a121 1
WitBoolean WitSsrMgr::validForNetting ()
d123 1
a123 1
   return witTRUE;
d128 1
a128 1
WitBoolean WitSsrMgr::validForExecBounds ()
d130 1
a130 1
   return witTRUE;
d142 1
a142 1
WitBoolean WitSsrMgr::ssrNeeded (WitHeurAtor * theHeurAtor)
d148 1
a148 1
         return witTRUE;
d150 1
a150 1
   return witFALSE;
d155 1
a155 1
WitBoolean WitSsrMgr::srAllowedFrom (WitMaterial * theMat, WitPeriod thePer)
d160 1
a160 1
      return witFALSE;
d165 1
a165 1
      return witFALSE;
d168 1
a168 1
      return witTRUE;
d191 1
a191 1
   theSsrPt->setSrWasDone (witTRUE);
d203 1
a203 1
      theSsrPt->setSrWasDone (witFALSE);
d234 1
a234 1
WitBoolean WitSsrMgr::selSplitNeeded ()
d248 1
a248 1
   WitBoolean   splitFound;
d295 1
a295 1
WitBoolean WitSsrMgr::hasanSsrPtFor (WitMaterial * theMat, WitPeriod fromPer)
d300 1
a300 1
         witFALSE;
d307 1
a307 1
WitSsrCand::WitSsrCand (WitBoolean srAllowedVal, WitSsrMgr * theSsrMgr):
d348 1
a348 1
      srWasDone_ (witFALSE)
d361 1
a361 1
WitBoolean WitSsrPt::hasResAlt ()
d367 1
a367 1
         return witTRUE;
d369 1
a369 1
   return witFALSE;
d408 1
a408 1
WitBoolean WitSsrPt::splittable ()   
d450 1
a450 1
void WitSsrPt::setSrWasDone (WitBoolean theValue)
@


1.28
log
@Continued implementation of Single-Source.
@
text
@d28 1
@


1.27
log
@Continued implementation of Single-Source.
@
text
@d362 2
@


1.26
log
@Continued implementation of Single-Source.
@
text
@d166 3
a374 4
   if (! isSplit ())
      mySsrMgr_->
         mySelector ()->myHeurAtor ()->resConsStock (myMat_, myFromPer_);

a451 9
   }

//------------------------------------------------------------------------------

void WitSsrPt::postSplit ()
   {
   if (! srAllowed ())
      mySsrMgr_->
         mySelector ()->myHeurAtor ()->resConsStock (myMat_, myFromPer_);
@


1.25
log
@Continued implementation of single-source.
@
text
@d421 7
@


1.24
log
@Continued implementation of single-source.
@
text
@d99 1
a99 2
      WitPeriod     fillPer,
      WitBoolean &  resFound)
a111 3
            {
            resFound = theSsrPt->srWasDone ();

a112 1
            }
a114 2
   resFound = witFALSE;

d353 11
@


1.23
log
@Continued preliminary work on single source.
@
text
@d148 13
@


1.22
log
@Continued implementation of object iteration.
@
text
@d25 2
@


1.21
log
@Began implementation of object iteration.
@
text
@d103 1
a103 1
   theMat = theBopEnt->myPart ()->myMat ();
@


1.20
log
@Continued implementation of sel-split for pen-exec.
@
text
@d24 2
@


1.19
log
@Continued implementation of sel-split for pen-exec.
@
text
@d392 1
a392 4
void WitSsrPt::getSortData (
      WitPart * & thePart,
      int &       caseIdx,
      WitPeriod & thePer)
a394 1
   caseIdx = 4;
@


1.18
log
@Continued implementation of sel-split for pen-exec.
@
text
@a23 1
#include <Splitter.h>
d172 1
a172 1
      mySplitter ()->recordFlow (theSsrPt, srVol);
a387 7
   }

//------------------------------------------------------------------------------

WitPart * WitSsrPt::myFillPart ()
   {
   return myMat_;
@


1.17
log
@Continued implementation of sel-split for pen-exec.
@
text
@d400 4
a403 1
WitPart * WitSsrPt::mySortPart ()
d405 3
a407 8
   return myMat_;
   }

//------------------------------------------------------------------------------

int WitSsrPt::caseIndex ()
   {
   return 4;
@


1.16
log
@Continued implementation of sel-split for pen-exec.
@
text
@d124 7
@


1.15
log
@Continued implementation of sel-split for pen-exec.
@
text
@d250 3
a252 1
   witAssert (splitFound);
d393 1
a393 1
WitPart * WitSsrPt::sortPart ()
d403 20
@


1.14
log
@Fixed a subtle bug in sel-split for stock reallocation.
Continued implementation of sel-split for pen-exec.
@
text
@d391 14
@


1.13
log
@Fixed bug regarding booleans for sel-split for stock reallocation.
@
text
@d343 3
a345 1
   mySsrMgr_->mySelector ()->myHeurAtor ()->resConsStock (myMat_, myFromPer_);
d396 9
@


1.12
log
@Initial implementation of selection splitting for multi-route.
@
text
@d36 2
a37 1
      srWasDonePts_      (myProblem ())
d67 5
d165 1
a165 1
   if (myGlobalComp ()->srSelSplit ())
d216 1
a216 7
   if (myGlobalComp ()->selSplit ())
      return witTRUE;

   if (myGlobalComp ()->nonMrSelSplit ())
      return witTRUE;

   return myGlobalComp ()->srSelSplit ();
d232 1
a232 1
   if (! myGlobalComp ()->srSelSplit ())
d377 1
a377 7
   if (mySsrMgr_->myGlobalComp ()->selSplit ())
      return witTRUE;

   if (mySsrMgr_->myGlobalComp ()->nonMrSelSplit ())
      return witTRUE;

   return myMat_->myGlobalComp ()->srSelSplit ();
@


1.11
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d210 6
d377 6
@


1.10
log
@Made stock reallocation use ssr vs. usr on a part-by-part basis.
@
text
@d24 1
d127 1
a127 1
   return "Selective Stock Reallocation";
d136 7
a142 3
   if (mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
      {
      theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);
d144 1
a144 5
      if (theSsrPt != NULL)
         return theSsrPt->srAllowed ();
      }
         
   return witFALSE;
d149 1
a149 1
void WitSsrMgr::recordSrFrom (WitMaterial * theMat, WitPeriod thePer)
d153 3
a155 1
   witAssert (srAllowedFrom (theMat, thePer));
d157 4
a160 1
   theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);
d210 53
a262 1
   return witFALSE;
d296 1
a296 1
   myMsgFac () ("internalErrorFmsg", "WitSsrCand::prtID");
d360 5
a364 1
   WitMsgFacility::current () ("internalErrorFmsg", "WitSsrPt::prtID");
d371 1
a371 1
   return witFALSE;
d378 1
a378 3
   WitMsgFacility::current () ("internalErrorFmsg", "WitSsrPt::myFillPart");

   return NULL;
@


1.9
log
@Changed selStockRe attribute to stockReallocation (fullSR, internally).
@
text
@d41 2
a42 1
   myMsgFac () ("fullSRMsg");
d51 1
a51 1
      if (theMat->producingBopEntries ().isEmpty ())
@


1.8
log
@Continued development of Selective Stock Reallocation.
@
text
@d41 1
a41 1
   myMsgFac () ("selStockReMsg");
@


1.7
log
@Fixed bug in SSR:
   Needed to reserve stock when it was getting consumed in a period where
   stock reallocation was disallowed.

Fixed bug in SSR:
   Failed to create SsrPt in periods where explosion was not allowed, but
   requirements could still be filled by exploding in an earlier period.

Put implementation of class AvailSched into its own .C file.
@
text
@d94 3
a96 1
   if (theBopEnt->myPart ()->getMyMaterial (theMat))
@


1.6
log
@Fixed bug:
   Selective Stock Reallocation was doing unrequested build-ahead.
@
text
@d39 1
d56 4
a59 1
         if (theMat->explodeable (fromPer))
d62 1
@


1.5
log
@Added non-resolving alteration to selective stock reallocation.
@
text
@a139 16
WitBoolean WitSsrMgr::srAllowedTo (WitMaterial * theMat, WitPeriod thePer)
   {
   WitSsrPt * theSsrPt;

   witAssert (mySsrPts_.myPtrTVecAt (theMat).isAllocated ());

   theSsrPt = mySsrPts_.myPtrAt (theMat, thePer);

   return
      (theSsrPt != NULL)?
         theSsrPt->srAllowed ():
         witTRUE;
   }

//------------------------------------------------------------------------------

@


1.4
log
@Continued implementation of selective stock reallocation.
@
text
@d94 1
a94 1
         if (theSsrPt->srWasDone ())
d96 1
a96 1
            resFound = witTRUE;
@


1.3
log
@Continued implmentation of selective stock reallocation.
@
text
@d22 2
d34 2
a35 1
      mySsrPts_          ()
d56 2
a57 1
            mySsrPts_.myPtrAt (theMat, fromPer) = new WitSsrPt (this);
d80 1
a80 1
      WitBopEntry *,
d83 2
a84 2
      WitPeriod,
      WitBoolean & resFound)
d86 16
d123 1
a123 1
WitBoolean WitSsrMgr::srAllowed (WitPart * thePart, WitPeriod fromPer)
d125 1
a125 2
   WitMaterial * theMat;
   WitSsrPt *    theSsrPt;
d127 3
a129 4
   if (thePart->isaMaterial (theMat))
      if (mySsrPts_.myPtrTVecAt (theMat).isAllocated ())
         {
         theSsrPt = mySsrPts_.myPtrAt (theMat, fromPer);
d131 3
a133 3
         if (theSsrPt != NULL)
            return theSsrPt->selSsrCand ()->srAllowed ();
         }
d140 70
d260 11
a270 2
WitSsrPt::WitSsrPt (WitSsrMgr * theSsrMgr):
      WitSelPt ()
d285 5
a289 1
   WitMsgFacility::current () ("internalErrorFmsg", "WitSsrPt::alterSelection");
d296 1
a296 1
   WitMsgFacility::current () ("internalErrorFmsg", "WitSsrPt::printSelection");
d303 1
a303 3
   WitMsgFacility::current () ("internalErrorFmsg", "WitSsrPt::mySelMgr");

   return NULL;
a316 2
   WitMsgFacility::current () ("internalErrorFmsg", "WitSsrPt::splittable");

d327 9
@


1.2
log
@Continued implementation of selective stock reallocation.
@
text
@d163 1
a163 1
WitBoolean WitSsrCand::isanSsrCand ()
d165 1
a165 1
   return witTRUE;
@


1.1
log
@Continuing implementation of selective stock reallocation.
@
text
@d16 2
d21 1
d28 5
a32 1
      WitSelMgr (theSelector)
d34 3
d38 17
d61 10
d103 19
d125 105
@


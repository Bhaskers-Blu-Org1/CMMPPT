head	1.103;
access;
symbols
	sce_5_01_20080919:1.96
	latest_sce_4_20_20060523:1.49.0.2
	sce_4_20_20060523:1.49
	latest_sce4_20_OSL:1.48.0.2
	sce_4_20_OSL:1.48
	sce_410_withVa:1.48
	sce_4_05_20040511:1.41
	sce_4_00_20040201:1.15
	nextGenBranch:1.14.0.2
	nextGenRoot:1.14
	sce_3_30_20030627:1.14
	EndRw-branch:1.11.0.4
	Root-of-EndRw:1.11
	rwToStl:1.11.0.2
	latest_sce_3_10_20010924:1.4.0.2
	sce_3_10_20010924:1.4
	latest_sce_3_00_20010601:1.3.0.6
	sce_3_00_20010601:1.3
	latest_sce_2_31_20010308:1.3.0.4
	sce_2_31_20010308:1.3
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.103
date	2011.09.28.23.50.47;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2011.09.24.00.29.03;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2011.08.30.20.18.28;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.09.10.22.10.43;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2009.11.19.20.46.07;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2009.11.13.19.01.27;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2008.11.12.19.52.26;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2008.02.25.22.35.11;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2008.02.25.19.37.58;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.25.16.36.34;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2008.02.22.23.18.20;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2008.01.18.22.41.01;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.09.22.33.57;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2008.01.09.21.17.28;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2008.01.09.19.35.49;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.02.21.13.33;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.22.19.58.54;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.10.17.14.58.47;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.10.15.21.50.36;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.10.02.22.23.07;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.08.29.16.24.25;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.08.01.22.41.59;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.18.21.53.31;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.18.20.43.39;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.05.21.15.20.11;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.05.17.17.37.01;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.16.22.16.47;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.03.22.05.29;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.03.19.36.17;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.04.26.20.45.31;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.23.20.20.01;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.04.22.08.19;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.02.23.01.17;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.02.21.21.20;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.01.16.16.53.45;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.16.16.27.40;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.16.00.25.06;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.15.23.06.08;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.15.22.25.31;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.01.15.21.15.16;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2006.12.27.22.45.41;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.20.17.04.53;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.18.00.09.23;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2006.11.17.17.22.01;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2006.11.17.16.57.48;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.14.23.10.27;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.02.23.07.14;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.12.20.48.12;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2006.09.19.17.50.56;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2006.08.24.20.50.28;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2006.08.22.21.26.56;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.08.17.22.50.39;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.08.16.21.57.13;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.08.16.15.49.19;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.02.17.34.17;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.08.19.21.38.04;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.13.21.18.47;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.13.16.48.48;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.21.21.49.27;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.24.23.23.58;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.08.20.36.19;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.12.19.43.32;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.05.15.43.59;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.19.22.16.30;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.09.21.24.27;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.06.18.16.58;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.02.23.45.20;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.02.20.54.17;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.01.21.05.13;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.31.22.56.08;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.30.00.05.33;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.29.22.25.14;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.27.00.08.20;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.26.22.29.41;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.25.22.00.37;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.25.21.21.59;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.25.20.35.03;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.25.19.59.38;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.04.16.31.47;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.03.22.36.23;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.26.18.59.43;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.24.19.37.23;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.20.22.46.03;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.20.15.37.37;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.12.19.13.41;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.06.00.17.34;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.29.22.06.17;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.11.18.29.15;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.19.16.48.30;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.16.22.50.41;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.02.22.18.58;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.10.19.21.20;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.30.21.36.42;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.09.20.49.51;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.03.23.16.45;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.25.19.14.56;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.24.18.26.13;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.18.14.02.49;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.31.00.26.27;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.29;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.23;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.34;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.34;	author wit;	state Exp;
branches;
next	;


desc
@@


1.103
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "opnApi.C"
//
// Inner API functions relating to Operations.
//------------------------------------------------------------------------------

#include <WitRun.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <ApiCall.h>
#include <ISRealArg.h>
#include <OSRealArg.h>
#include <IVRealArg.h>
#include <OVRealArg.h>
#include <Pre.h>
#include <DetOptImpMgr.h>
#include <ExtOptMgr.h>
#include <StochImpMgr.h>
#include <CompMgr.h>
#include <Operation.h>
#include <BoundSet.h>
#include <MsgFrag.h>
#include <MsgFac.h>

#include <stdlib.h>

//------------------------------------------------------------------------------
// setGetOperationInit
// Initilization of wit[GS]etOperation* functions.
//------------------------------------------------------------------------------

WitOperation * WitRun::setGetOperationInit (const char * operationName)
   {
   WitOperation * theOpn;

   forbidNullArg (operationName, "operationName");

   if (myMsgFac ().mayIssue ("operationNameMsg"))
      myMsgFac () ("operationNameMsg", operationName);

   theOpn = getOperationP (operationName);

   myInputID ()->setMyOperation (theOpn);

   return theOpn;
   }

//------------------------------------------------------------------------------

void WitRun::witAddOperation (const char * operationNameParm)
   {
   myApiMgr_->startInnerFunc ();

   forbidNullArg (operationNameParm, "operationName");

   if (myMsgFac ().mayIssue ("operationNameAdMsg"))
      myMsgFac () ("operationNameAdMsg", operationNameParm);

   if (myCompMgr ()->findOperation(operationNameParm) != NULL)
      myMsgFac () ("dupOperationApMsg", operationNameParm);

   if (isNullCstring (operationNameParm))
      myMsgFac () ("nullStringSmsg", "operationName");

   addingDelComp ("operationFrag");

   new WitOperation (operationNameParm, myCompMgr ());
   }

//------------------------------------------------------------------------------

void WitRun::witCopyOperationData (
      const char * dupOperationName,
      WitRun *     origWitRun,
      const char * origOperationName)
   {
   startCopyObjData (origWitRun);

   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("operationFrag"));

   WitOperationApiCall dupCall  (this,        dupOperationName);

   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("operationFrag"));

   WitOperationApiCall origCall (origWitRun, origOperationName);

   if (dupCall.myOperation () == origCall.myOperation ())
      myMsgFac () ("copyObjectToSelfSmsg",
         myMsgFac ().myFrag ("operationFrag"));

   dupCall.myOperation ()->copyAttrsFrom (origCall.myOperation ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetObjItrOperation (char * * operationName)
   {
   WitOperation * theOpn;

   myApiMgr_->startInnerFunc ();

   theOpn =
      curItrDelCompForGet (WitAT_OPERATION, "operationFrag")->
         thisOpn ();

   stronglyAssert (theOpn != NULL);

   apiGet (operationName, "operationName", theOpn->operationName ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationAppData (
      const char * operationName,
      void * *     appData)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (appData, "appData", theCall.myOperation ()->appData ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationCycleTime34 (
      const char *         operationName,
      const WitOVRealArg & cycleTime34)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (cycleTime34, "cycleTime34", theCall.myOperation ()->cycleTime34 ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExecBounds (
      const char *         operationName,
      const WitOVRealArg & hardlbP,
      const WitOVRealArg & softlbP,
      const WitOVRealArg & hardubP)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (hardlbP, softlbP, hardubP, theCall.myOperation ()->execBounds ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExecCost (
      const char *         operationName,
      const WitOVRealArg & execCost)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
      execCost, 
      "execCost", 
      theCall.myOperation ()->execCost ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExecPenalty (
      const char *         operationName,
      const WitOSRealArg & execPenalty)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (execPenalty, "execPenalty", theCall.myOperation ()->execPenalty ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExecSlbConIndex (
      const char * operationName,
      const int    thePer,
      int *        execSlbConIndex)
   {
   WitOperationApiCall theCall (this, operationName);

   prepGetIndex (thePer);

   apiGet (
       execSlbConIndex,
      "execSlbConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            execSlbConIndex (theCall.myOperation (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExecSlbvVarIndex (
      const char * operationName,
      const int    thePer,
      int *        execSlbvVarIndex)
   {
   WitOperationApiCall theCall (this, operationName);

   prepGetIndex (thePer);

   apiGet (
       execSlbvVarIndex,
      "execSlbvVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            execSlbvVarIndex (theCall.myOperation (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExecVarIndex (
      const char * operationName,
      const int    thePer,
      int *        execVarIndex)
   {
   WitOperationApiCall theCall (this, operationName);

   prepGetIndex (thePer);

   apiGet (
       execVarIndex,
      "execVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            execVarIndex (theCall.myOperation (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExecVol (
      const char *         operationName,
      const WitOVRealArg & execVol)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (execVol, "execVol", theCall.myOperation ()->execVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExecutable (
      const char *   operationName,
      WitBoolean * * executable)
   {
   WitOperationApiCall theCall (this, operationName);

   myProblem ()->myPreprocessor ()->preprocess ();

   apiGet (
      executable,
      "executable",
      theCall.myOperation ()->executable ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationExists (
      const char * operationNameParm,
      WitBoolean * exists)
   {
   myApiMgr_->startInnerFunc ();

   if (myCompMgr ()->findOperation (operationNameParm) != NULL)
      {
      myMsgFac () ("operationDoesExist", operationNameParm);

      * exists = true;
      }
   else
      {
      myMsgFac () ("operationDoesNotExist", operationNameParm);

      * exists = false;
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationFssExecVol (
      const char *         operationName,
      const WitOVRealArg & fssExecVol)
   {
   WitOperationApiCall theCall (this, operationName);

   forbidStochMode ();

   myProblem ()->computeFssIfNeeded ();

   apiGet (fssExecVol, "fssExecVol", theCall.myOperation ()->fssExecVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationIncLotSize (
      const char *         operationName,
      const WitOVRealArg & incLotSize)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (incLotSize, "incLotSize", theCall.myOperation ()->incLotSize ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationIncLotSize2 (
      const char *         operationName,
      const WitOVRealArg & incLotSize2)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (incLotSize2, "incLotSize2", theCall.myOperation ()->incLotSize2 ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationIntExecVols (
      const char * operationName,
      WitBoolean * intExecVols)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
       intExecVols,
      "intExecVols", 
      theCall.myOperation ()->intExecVols ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationLotSize2Thresh (
      const char *         operationName,
      const WitOVRealArg & lotSize2Thresh)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
      lotSize2Thresh, 
      "lotSize2Thresh", 
      theCall.myOperation ()->lotSize2Thresh ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationMinLotSize (
      const char *         operationName,
      const WitOVRealArg & minLotSize)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (minLotSize, "minLotSize", theCall.myOperation ()->minLotSize ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationMinLotSize2 (
      const char *         operationName,
      const WitOVRealArg & minLotSize2)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (minLotSize2, "minLotSize2", theCall.myOperation ()->minLotSize2 ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationMrpExecVol (
      const char *         operationName,
      const WitOVRealArg & mrpExecVol)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (mrpExecVol, "mrpExecVol", theCall.myOperation ()->mrpExecVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationNBomEntries (
      const char * operationName,
      int *        nBomEntries)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
      nBomEntries,
      "nBomEntries",
      theCall.myOperation ()->bom ().nElements ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationNBopEntries (
      const char * operationName,
      int *        nBopEntries)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
      nBopEntries,
      "nBopEntries",
      theCall.myOperation ()->bop ().nElements ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationObj1ExecCost (
      const char *         operationName,
      const WitOVRealArg & obj1ExecCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "operation",
         "obj1ExecCost",
         "execCost");

   witGetOperationExecCost (operationName, obj1ExecCost);
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationObjectStage (
      const char * operationName,
      int *        objectStage)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.getObjectStage (objectStage);
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperations (
      int  *     lenOperationList,
      char * * * operationList)
   {
   WitOperation * theOpn;
   int            i;

   myApiMgr_->startInnerFunc ();

   * lenOperationList = myCompMgr ()->nOperations ();

   apiAlloc (operationList, * lenOperationList);

   i = 0;

   forEachOperation (theOpn, myProblem ())
      (* operationList)[i++] = theOpn->operationName ().apiDupCstring ();
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationSelForDel (
      const char * operationName,
      WitBoolean * selForDel)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (selForDel, "selForDel", theCall.myOperation ()->selForDel ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationTwoLevelLotSizes (
      const char * operationName,
      WitBoolean * twoLevelLotSizes)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
       twoLevelLotSizes,
      "twoLevelLotSizes", 
      theCall.myOperation ()->twoLevelLotSizes ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationYield (
      const char * operationName,
      int * *      yield)
   {
   double *  yieldRateCVec;
   WitPeriod thePer;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getPre50AttrMsg"))
      myMsgFac () (
         "getPre50AttrMsg",
         apiFuncName (),
         "operation",
         "yield",
         "yieldRate");

   witGetOperationYieldRate (operationName, & yieldRateCVec);

   forbidNullArg (yield, "yield");

   apiAlloc (yield, nPeriods ());

   forEachPeriod (thePer, myProblem ())
      (* yield)[thePer] = fracToPercent (yieldRateCVec[thePer]);

   free (yieldRateCVec);
   }

//------------------------------------------------------------------------------

void WitRun::witGetOperationYieldRate (
      const char *         operationName,
      const WitOVRealArg & yieldRate)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (yieldRate, "yieldRate", theCall.myOperation ()->yieldRate ());
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationAppData (
      const char * operationName,
      void *       appData)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.setAppData (appData);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationCycleTime34 (
      const char *         operationName,
      const WitIVRealArg & cycleTime34)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.setCycleTime34 (cycleTime34);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationExecBounds (
      const char *         operationName,
      const WitIVRealArg & hardLB,
      const WitIVRealArg & softLB,
      const WitIVRealArg & hardUB)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.setBoundSet (
      theCall.myOperation ()->execBounds (), 
      hardLB, 
      softLB, 
      hardUB);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationExecCost (
      const char *         operationName,
      const WitIVRealArg & execCost)
   {
   WitOperationApiCall theCall (this, operationName);
   WitPeriod           thePer;

   theCall.prepDblVec ("execCost", execCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (execCost[thePer] < 0.0)
            myMsgFac () (
               "negOperationCostWmsg",
               "execCost",
               operationName,
               execCost[thePer],
               thePer);

      theCall.myOperation ()->setExecCost (execCost);
      }
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationExecPenalty (
      const char *         operationName,
      const WitISRealArg & execPenalty)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDouble (
      "execPenalty", 
      theCall.myOperation ()->execPenalty (),
      execPenalty);

   if (theCall.argsOK ())
      theCall.myOperation ()->setExecPenalty (execPenalty);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationExecVol (
      const char *         operationName,
      const WitIVRealArg & execVol)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("execVol", execVol);

   if (theCall.argsOK ())
      theCall.myOperation ()->setExecVol (execVol);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationIncLotSize (
      const char *         operationName,
      const WitIVRealArg & incLotSize)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("incLotSize", incLotSize);

   if (theCall.argsOK ())
      theCall.myOperation ()->setIncLotSize (incLotSize);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationIncLotSize2 (
      const char *         operationName,
      const WitIVRealArg & incLotSize2)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("incLotSize2", incLotSize2);

   if (theCall.argsOK ())
      theCall.myOperation ()->setIncLotSize2 (incLotSize2);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationIntExecVols (
      const char * operationName,
      WitBoolean   intExecVols)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepBool (
                             "intExecVols", 
      theCall.myOperation ()->intExecVols (), 
                              intExecVols);

   theCall.myOperation ()->setIntExecVols (asaBool (intExecVols));
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationLotSize2Thresh (
      const char *         operationName,
      const WitIVRealArg & lotSize2Thresh)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("lotSize2Thresh", lotSize2Thresh);

   if (theCall.argsOK ())
      theCall.myOperation ()->setLotSize2Thresh (lotSize2Thresh);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationMinLotSize (
      const char *         operationName,
      const WitIVRealArg & minLotSize)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("minLotSize", minLotSize);

   if (theCall.argsOK ())
      theCall.myOperation ()->setMinLotSize (minLotSize);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationMinLotSize2 (
      const char *         operationName,
      const WitIVRealArg & minLotSize2)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("minLotSize2", minLotSize2);

   if (theCall.argsOK ())
      theCall.myOperation ()->setMinLotSize2 (minLotSize2);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationObj1ExecCost (
      const char *         operationName,
      const WitIVRealArg & obj1ExecCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "operation",
         "obj1ExecCost",
         "execCost");

   witSetOperationExecCost (operationName, obj1ExecCost);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationObjectStage (
      const char * operationName,
      int          objectStage)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.setObjectStage (objectStage);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationOperationName (
      const char * operationName,
      const char * newName)
   {
   WitOperationApiCall theCall (this, operationName);

   forbidNullArg (newName, "newName");

   if (isNullCstring (newName))
      myMsgFac () ("nullStringSmsg", "newName");

   if (myCompMgr ()->findOperation (newName))
      myMsgFac () ("setNodeNameToDupSmsg",
         "witSetOperationOperationName",
         myMsgFac ().myFrag ("operationFrag"),
         newName);

   theCall.prepString (
                             "operationName",
      theCall.myOperation ()->operationName (),
                                    newName);

   if (theCall.argsOK ())
      theCall.myOperation ()->setOperationName (newName);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationSelForDel (
      const char * operationName,
      WitBoolean   selForDel)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.setSelForDel (selForDel);
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationTwoLevelLotSizes (
      const char * operationName,
      WitBoolean   twoLevelLotSizes)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.myOperation ()->setTwoLevelLotSizes (asaBool (twoLevelLotSizes));
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationYield (
      const char * operationName,
      const int *  yield)
   {
   WitTVec <double> yieldRateTVec (myProblem (), 0.0);
   WitPeriod        thePer;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setPre50AttrMsg"))
      myMsgFac () (
         "setPre50AttrMsg",
         apiFuncName (),
         "operation",
         "yield",
         "yieldRate");

   forbidNullArg (yield, "yield");

   forEachPeriod (thePer, myProblem ())
      yieldRateTVec[thePer] = percentToFrac (yield[thePer]);

   witSetOperationYieldRate (operationName, yieldRateTVec.myCVec ());
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationYieldRate (
      const char *         operationName,
      const WitIVRealArg & yieldRate)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.setYieldRate (yieldRate);
   }

//------------------------------------------------------------------------------
// getOperationP
// Return pointer to operation.  If not defined issue message.
//------------------------------------------------------------------------------

WitOperation * WitRun::getOperationP (const char * operationName)
   {
   WitOperation * operationP;

   operationP = myCompMgr ()->findOperation (operationName);

   if (operationP == NULL)
      myMsgFac () ("undefinedOperationMsg", operationName);

   return operationP;
   }
@


1.102
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.101
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d42 2
a43 2
{
WitOperation * theOpn;
d45 1
a45 1
forbidNullArg (operationName, "operationName");
d47 2
a48 2
if (myMsgFac ().mayIssue ("operationNameMsg"))
myMsgFac () ("operationNameMsg", operationName);
d50 1
a50 1
theOpn = getOperationP (operationName);
d52 1
a52 1
myInputID ()->setMyOperation (theOpn);
d54 2
a55 2
return theOpn;
}
d60 2
a61 2
{
myApiMgr_->startInnerFunc ();
d63 1
a63 1
forbidNullArg (operationNameParm, "operationName");
d65 2
a66 2
if (myMsgFac ().mayIssue ("operationNameAdMsg"))
myMsgFac () ("operationNameAdMsg", operationNameParm);
d68 2
a69 2
if (myCompMgr ()->findOperation(operationNameParm) != NULL)
myMsgFac () ("dupOperationApMsg", operationNameParm);
d71 2
a72 2
if (isNullCstring (operationNameParm))
myMsgFac () ("nullStringSmsg", "operationName");
d74 1
a74 1
addingDelComp ("operationFrag");
d76 2
a77 2
new WitOperation (operationNameParm, myCompMgr ());
}
d82 5
a86 5
const char * dupOperationName,
WitRun *     origWitRun,
const char * origOperationName)
{
startCopyObjData (origWitRun);
d88 1
a88 1
myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("operationFrag"));
d90 1
a90 1
WitOperationApiCall dupCall  (this,        dupOperationName);
d92 1
a92 1
myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("operationFrag"));
d94 1
a94 1
WitOperationApiCall origCall (origWitRun, origOperationName);
d96 3
a98 3
if (dupCall.myOperation () == origCall.myOperation ())
myMsgFac () ("copyObjectToSelfSmsg",
myMsgFac ().myFrag ("operationFrag"));
d100 2
a101 2
dupCall.myOperation ()->copyAttrsFrom (origCall.myOperation ());
}
d106 2
a107 2
{
WitOperation * theOpn;
d109 1
a109 1
myApiMgr_->startInnerFunc ();
d111 3
a113 3
theOpn =
curItrDelCompForGet (WitAT_OPERATION, "operationFrag")->
thisOpn ();
d115 1
a115 1
stronglyAssert (theOpn != NULL);
d117 2
a118 2
apiGet (operationName, "operationName", theOpn->operationName ());
}
d123 4
a126 4
const char * operationName,
void * *     appData)
{
WitOperationApiCall theCall (this, operationName);
d128 2
a129 2
apiGet (appData, "appData", theCall.myOperation ()->appData ());
}
d134 4
a137 4
const char *         operationName,
const WitOVRealArg & cycleTime34)
{
WitOperationApiCall theCall (this, operationName);
d139 2
a140 2
apiGet (cycleTime34, "cycleTime34", theCall.myOperation ()->cycleTime34 ());
}
d145 6
a150 6
const char *         operationName,
const WitOVRealArg & hardlbP,
const WitOVRealArg & softlbP,
const WitOVRealArg & hardubP)
{
WitOperationApiCall theCall (this, operationName);
d152 2
a153 2
apiGet (hardlbP, softlbP, hardubP, theCall.myOperation ()->execBounds ());
}
d158 10
a167 10
const char *         operationName,
const WitOVRealArg & execCost)
{
WitOperationApiCall theCall (this, operationName);

apiGet (
execCost,
"execCost",
theCall.myOperation ()->execCost ());
}
d172 4
a175 4
const char *         operationName,
const WitOSRealArg & execPenalty)
{
WitOperationApiCall theCall (this, operationName);
d177 2
a178 2
apiGet (execPenalty, "execPenalty", theCall.myOperation ()->execPenalty ());
}
d183 15
a197 15
const char * operationName,
const int    thePer,
int *        execSlbConIndex)
{
WitOperationApiCall theCall (this, operationName);

prepGetIndex (thePer);

apiGet (
execSlbConIndex,
"execSlbConIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
execSlbConIndex (theCall.myOperation (), thePer));
}
d202 15
a216 15
const char * operationName,
const int    thePer,
int *        execSlbvVarIndex)
{
WitOperationApiCall theCall (this, operationName);

prepGetIndex (thePer);

apiGet (
execSlbvVarIndex,
"execSlbvVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
execSlbvVarIndex (theCall.myOperation (), thePer));
}
d221 15
a235 15
const char * operationName,
const int    thePer,
int *        execVarIndex)
{
WitOperationApiCall theCall (this, operationName);

prepGetIndex (thePer);

apiGet (
execVarIndex,
"execVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
execVarIndex (theCall.myOperation (), thePer));
}
d240 4
a243 4
const char *         operationName,
const WitOVRealArg & execVol)
{
WitOperationApiCall theCall (this, operationName);
d245 2
a246 2
apiGet (execVol, "execVol", theCall.myOperation ()->execVol ());
}
d251 12
a262 12
const char *   operationName,
WitBoolean * * executable)
{
WitOperationApiCall theCall (this, operationName);

myProblem ()->myPreprocessor ()->preprocess ();

apiGet (
executable,
"executable",
theCall.myOperation ()->executable ());
}
d267 18
a284 18
const char * operationNameParm,
WitBoolean * exists)
{
myApiMgr_->startInnerFunc ();

if (myCompMgr ()->findOperation (operationNameParm) != NULL)
{
myMsgFac () ("operationDoesExist", operationNameParm);

* exists = true;
}
else
{
myMsgFac () ("operationDoesNotExist", operationNameParm);

* exists = false;
}
}
d289 4
a292 4
const char *         operationName,
const WitOVRealArg & fssExecVol)
{
WitOperationApiCall theCall (this, operationName);
d294 1
a294 1
forbidStochMode ();
d296 1
a296 1
myProblem ()->computeFssIfNeeded ();
d298 2
a299 2
apiGet (fssExecVol, "fssExecVol", theCall.myOperation ()->fssExecVol ());
}
d304 4
a307 4
const char *         operationName,
const WitOVRealArg & incLotSize)
{
WitOperationApiCall theCall (this, operationName);
d309 2
a310 2
apiGet (incLotSize, "incLotSize", theCall.myOperation ()->incLotSize ());
}
d315 4
a318 4
const char *         operationName,
const WitOVRealArg & incLotSize2)
{
WitOperationApiCall theCall (this, operationName);
d320 2
a321 2
apiGet (incLotSize2, "incLotSize2", theCall.myOperation ()->incLotSize2 ());
}
d326 10
a335 10
const char * operationName,
WitBoolean * intExecVols)
{
WitOperationApiCall theCall (this, operationName);

apiGet (
intExecVols,
"intExecVols",
theCall.myOperation ()->intExecVols ());
}
d340 10
a349 10
const char *         operationName,
const WitOVRealArg & lotSize2Thresh)
{
WitOperationApiCall theCall (this, operationName);

apiGet (
lotSize2Thresh,
"lotSize2Thresh",
theCall.myOperation ()->lotSize2Thresh ());
}
d354 4
a357 4
const char *         operationName,
const WitOVRealArg & minLotSize)
{
WitOperationApiCall theCall (this, operationName);
d359 2
a360 2
apiGet (minLotSize, "minLotSize", theCall.myOperation ()->minLotSize ());
}
d365 4
a368 4
const char *         operationName,
const WitOVRealArg & minLotSize2)
{
WitOperationApiCall theCall (this, operationName);
d370 2
a371 2
apiGet (minLotSize2, "minLotSize2", theCall.myOperation ()->minLotSize2 ());
}
d376 4
a379 4
const char *         operationName,
const WitOVRealArg & mrpExecVol)
{
WitOperationApiCall theCall (this, operationName);
d381 2
a382 2
apiGet (mrpExecVol, "mrpExecVol", theCall.myOperation ()->mrpExecVol ());
}
d387 10
a396 10
const char * operationName,
int *        nBomEntries)
{
WitOperationApiCall theCall (this, operationName);

apiGet (
nBomEntries,
"nBomEntries",
theCall.myOperation ()->bom ().nElements ());
}
d401 10
a410 10
const char * operationName,
int *        nBopEntries)
{
WitOperationApiCall theCall (this, operationName);

apiGet (
nBopEntries,
"nBopEntries",
theCall.myOperation ()->bop ().nElements ());
}
d415 12
a426 12
const char *         operationName,
const WitOVRealArg & obj1ExecCost)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
myMsgFac () (
"getAttrNewNameMsg",
apiFuncName (),
"operation",
"obj1ExecCost",
"execCost");
d428 2
a429 2
witGetOperationExecCost (operationName, obj1ExecCost);
}
d434 4
a437 4
const char * operationName,
int *        objectStage)
{
WitOperationApiCall theCall (this, operationName);
d439 2
a440 2
theCall.getObjectStage (objectStage);
}
d445 5
a449 5
int  *     lenOperationList,
char * * * operationList)
{
WitOperation * theOpn;
int            i;
d451 1
a451 1
myApiMgr_->startInnerFunc ();
d453 1
a453 1
* lenOperationList = myCompMgr ()->nOperations ();
d455 1
a455 1
apiAlloc (operationList, * lenOperationList);
d457 1
a457 1
i = 0;
d459 3
a461 3
forEachOperation (theOpn, myProblem ())
(* operationList)[i++] = theOpn->operationName ().apiDupCstring ();
}
d466 4
a469 4
const char * operationName,
WitBoolean * selForDel)
{
WitOperationApiCall theCall (this, operationName);
d471 2
a472 2
apiGet (selForDel, "selForDel", theCall.myOperation ()->selForDel ());
}
d477 10
a486 10
const char * operationName,
WitBoolean * twoLevelLotSizes)
{
WitOperationApiCall theCall (this, operationName);

apiGet (
twoLevelLotSizes,
"twoLevelLotSizes",
theCall.myOperation ()->twoLevelLotSizes ());
}
d491 5
a495 5
const char * operationName,
int * *      yield)
{
double *  yieldRateCVec;
WitPeriod thePer;
d497 1
a497 1
myApiMgr_->startInnerFunc ();
d499 7
a505 7
if (myMsgFac ().mayIssue ("getPre50AttrMsg"))
myMsgFac () (
"getPre50AttrMsg",
apiFuncName (),
"operation",
"yield",
"yieldRate");
d507 1
a507 1
witGetOperationYieldRate (operationName, & yieldRateCVec);
d509 1
a509 1
forbidNullArg (yield, "yield");
d511 1
a511 1
apiAlloc (yield, nPeriods ());
d513 2
a514 2
forEachPeriod (thePer, myProblem ())
(* yield)[thePer] = fracToPercent (yieldRateCVec[thePer]);
d516 2
a517 2
free (yieldRateCVec);
}
d522 4
a525 4
const char *         operationName,
const WitOVRealArg & yieldRate)
{
WitOperationApiCall theCall (this, operationName);
d527 2
a528 2
apiGet (yieldRate, "yieldRate", theCall.myOperation ()->yieldRate ());
}
d533 4
a536 4
const char * operationName,
void *       appData)
{
WitOperationApiCall theCall (this, operationName);
d538 2
a539 2
theCall.setAppData (appData);
}
d544 4
a547 4
const char *         operationName,
const WitIVRealArg & cycleTime34)
{
WitOperationApiCall theCall (this, operationName);
d549 2
a550 2
theCall.setCycleTime34 (cycleTime34);
}
d555 13
a567 13
const char *         operationName,
const WitIVRealArg & hardLB,
const WitIVRealArg & softLB,
const WitIVRealArg & hardUB)
{
WitOperationApiCall theCall (this, operationName);

theCall.setBoundSet (
theCall.myOperation ()->execBounds (),
hardLB,
softLB,
hardUB);
}
d572 22
a593 22
const char *         operationName,
const WitIVRealArg & execCost)
{
WitOperationApiCall theCall (this, operationName);
WitPeriod           thePer;

theCall.prepDblVec ("execCost", execCost);

if (theCall.argsOK ())
{
forEachPeriod (thePer, myProblem ())
if (execCost[thePer] < 0.0)
myMsgFac () (
"negOperationCostWmsg",
"execCost",
operationName,
execCost[thePer],
thePer);

theCall.myOperation ()->setExecCost (execCost);
}
}
d598 13
a610 13
const char *         operationName,
const WitISRealArg & execPenalty)
{
WitOperationApiCall theCall (this, operationName);

theCall.prepNonNegDouble (
"execPenalty",
theCall.myOperation ()->execPenalty (),
execPenalty);

if (theCall.argsOK ())
theCall.myOperation ()->setExecPenalty (execPenalty);
}
d615 10
a624 10
const char *         operationName,
const WitIVRealArg & execVol)
{
WitOperationApiCall theCall (this, operationName);

theCall.prepNonNegDblVec ("execVol", execVol);

if (theCall.argsOK ())
theCall.myOperation ()->setExecVol (execVol);
}
d629 10
a638 10
const char *         operationName,
const WitIVRealArg & incLotSize)
{
WitOperationApiCall theCall (this, operationName);

theCall.prepNonNegDblVec ("incLotSize", incLotSize);

if (theCall.argsOK ())
theCall.myOperation ()->setIncLotSize (incLotSize);
}
d643 10
a652 10
const char *         operationName,
const WitIVRealArg & incLotSize2)
{
WitOperationApiCall theCall (this, operationName);

theCall.prepNonNegDblVec ("incLotSize2", incLotSize2);

if (theCall.argsOK ())
theCall.myOperation ()->setIncLotSize2 (incLotSize2);
}
d657 9
a665 9
const char * operationName,
WitBoolean   intExecVols)
{
WitOperationApiCall theCall (this, operationName);

theCall.prepBool (
"intExecVols",
theCall.myOperation ()->intExecVols (),
intExecVols);
d667 2
a668 2
theCall.myOperation ()->setIntExecVols (asaBool (intExecVols));
}
d673 10
a682 10
const char *         operationName,
const WitIVRealArg & lotSize2Thresh)
{
WitOperationApiCall theCall (this, operationName);

theCall.prepNonNegDblVec ("lotSize2Thresh", lotSize2Thresh);

if (theCall.argsOK ())
theCall.myOperation ()->setLotSize2Thresh (lotSize2Thresh);
}
d687 10
a696 10
const char *         operationName,
const WitIVRealArg & minLotSize)
{
WitOperationApiCall theCall (this, operationName);

theCall.prepNonNegDblVec ("minLotSize", minLotSize);

if (theCall.argsOK ())
theCall.myOperation ()->setMinLotSize (minLotSize);
}
d701 10
a710 10
const char *         operationName,
const WitIVRealArg & minLotSize2)
{
WitOperationApiCall theCall (this, operationName);

theCall.prepNonNegDblVec ("minLotSize2", minLotSize2);

if (theCall.argsOK ())
theCall.myOperation ()->setMinLotSize2 (minLotSize2);
}
d715 12
a726 12
const char *         operationName,
const WitIVRealArg & obj1ExecCost)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
myMsgFac () (
"setAttrNewNameMsg",
apiFuncName (),
"operation",
"obj1ExecCost",
"execCost");
d728 2
a729 2
witSetOperationExecCost (operationName, obj1ExecCost);
}
d734 4
a737 4
const char * operationName,
int          objectStage)
{
WitOperationApiCall theCall (this, operationName);
d739 2
a740 2
theCall.setObjectStage (objectStage);
}
d745 24
a768 24
const char * operationName,
const char * newName)
{
WitOperationApiCall theCall (this, operationName);

forbidNullArg (newName, "newName");

if (isNullCstring (newName))
myMsgFac () ("nullStringSmsg", "newName");

if (myCompMgr ()->findOperation (newName))
myMsgFac () ("setNodeNameToDupSmsg",
"witSetOperationOperationName",
myMsgFac ().myFrag ("operationFrag"),
newName);

theCall.prepString (
"operationName",
theCall.myOperation ()->operationName (),
newName);

if (theCall.argsOK ())
theCall.myOperation ()->setOperationName (newName);
}
d773 4
a776 4
const char * operationName,
WitBoolean   selForDel)
{
WitOperationApiCall theCall (this, operationName);
d778 2
a779 2
theCall.setSelForDel (selForDel);
}
d784 4
a787 4
const char * operationName,
WitBoolean   twoLevelLotSizes)
{
WitOperationApiCall theCall (this, operationName);
d789 2
a790 2
theCall.myOperation ()->setTwoLevelLotSizes (asaBool (twoLevelLotSizes));
}
d795 15
a809 15
const char * operationName,
const int *  yield)
{
WitTVec <double> yieldRateTVec (myProblem (), 0.0);
WitPeriod        thePer;

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setPre50AttrMsg"))
myMsgFac () (
"setPre50AttrMsg",
apiFuncName (),
"operation",
"yield",
"yieldRate");
d811 1
a811 1
forbidNullArg (yield, "yield");
d813 2
a814 2
forEachPeriod (thePer, myProblem ())
yieldRateTVec[thePer] = percentToFrac (yield[thePer]);
d816 2
a817 2
witSetOperationYieldRate (operationName, yieldRateTVec.myCVec ());
}
d822 4
a825 4
const char *         operationName,
const WitIVRealArg & yieldRate)
{
WitOperationApiCall theCall (this, operationName);
d827 2
a828 2
theCall.setYieldRate (yieldRate);
}
d836 2
a837 2
{
WitOperation * operationP;
d839 1
a839 1
operationP = myCompMgr ()->findOperation (operationName);
d841 2
a842 2
if (operationP == NULL)
myMsgFac () ("undefinedOperationMsg", operationName);
d844 2
a845 2
return operationP;
}
@


1.100
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d42 2
a43 2
   {
   WitOperation * theOpn;
d45 1
a45 1
   forbidNullArg (operationName, "operationName");
d47 2
a48 2
   if (myMsgFac ().mayIssue ("operationNameMsg"))
      myMsgFac () ("operationNameMsg", operationName);
d50 1
a50 1
   theOpn = getOperationP (operationName);
d52 1
a52 1
   myInputID ()->setMyOperation (theOpn);
d54 2
a55 2
   return theOpn;
   }
d60 2
a61 2
   {
   myApiMgr_->startInnerFunc ();
d63 1
a63 1
   forbidNullArg (operationNameParm, "operationName");
d65 2
a66 2
   if (myMsgFac ().mayIssue ("operationNameAdMsg"))
      myMsgFac () ("operationNameAdMsg", operationNameParm);
d68 2
a69 2
   if (myCompMgr ()->findOperation(operationNameParm) != NULL)
      myMsgFac () ("dupOperationApMsg", operationNameParm);
d71 2
a72 2
   if (isNullCstring (operationNameParm))
      myMsgFac () ("nullStringSmsg", "operationName");
d74 1
a74 1
   addingDelComp ("operationFrag");
d76 2
a77 2
   new WitOperation (operationNameParm, myCompMgr ());
   }
d82 5
a86 5
      const char * dupOperationName,
      WitRun *     origWitRun,
      const char * origOperationName)
   {
   startCopyObjData (origWitRun);
d88 1
a88 1
   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("operationFrag"));
d90 1
a90 1
   WitOperationApiCall dupCall  (this,        dupOperationName);
d92 1
a92 1
   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("operationFrag"));
d94 1
a94 1
   WitOperationApiCall origCall (origWitRun, origOperationName);
d96 3
a98 3
   if (dupCall.myOperation () == origCall.myOperation ())
      myMsgFac () ("copyObjectToSelfSmsg",
         myMsgFac ().myFrag ("operationFrag"));
d100 2
a101 2
   dupCall.myOperation ()->copyAttrsFrom (origCall.myOperation ());
   }
d106 2
a107 2
   {
   WitOperation * theOpn;
d109 1
a109 1
   myApiMgr_->startInnerFunc ();
d111 3
a113 3
   theOpn =
      curItrDelCompForGet (WitAT_OPERATION, "operationFrag")->
         thisOpn ();
d115 1
a115 1
   stronglyAssert (theOpn != NULL);
d117 2
a118 2
   apiGet (operationName, "operationName", theOpn->operationName ());
   }
d123 4
a126 4
      const char * operationName,
      void * *     appData)
   {
   WitOperationApiCall theCall (this, operationName);
d128 2
a129 2
   apiGet (appData, "appData", theCall.myOperation ()->appData ());
   }
d134 4
a137 4
      const char *         operationName,
      const WitOVRealArg & cycleTime34)
   {
   WitOperationApiCall theCall (this, operationName);
d139 2
a140 2
   apiGet (cycleTime34, "cycleTime34", theCall.myOperation ()->cycleTime34 ());
   }
d145 6
a150 6
      const char *         operationName,
      const WitOVRealArg & hardlbP,
      const WitOVRealArg & softlbP,
      const WitOVRealArg & hardubP)
   {
   WitOperationApiCall theCall (this, operationName);
d152 2
a153 2
   apiGet (hardlbP, softlbP, hardubP, theCall.myOperation ()->execBounds ());
   }
d158 10
a167 10
      const char *         operationName,
      const WitOVRealArg & execCost)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
      execCost, 
      "execCost", 
      theCall.myOperation ()->execCost ());
   }
d172 4
a175 4
      const char *         operationName,
      const WitOSRealArg & execPenalty)
   {
   WitOperationApiCall theCall (this, operationName);
d177 2
a178 2
   apiGet (execPenalty, "execPenalty", theCall.myOperation ()->execPenalty ());
   }
d183 15
a197 15
      const char * operationName,
      const int    thePer,
      int *        execSlbConIndex)
   {
   WitOperationApiCall theCall (this, operationName);

   prepGetIndex (thePer);

   apiGet (
       execSlbConIndex,
      "execSlbConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            execSlbConIndex (theCall.myOperation (), thePer));
   }
d202 15
a216 15
      const char * operationName,
      const int    thePer,
      int *        execSlbvVarIndex)
   {
   WitOperationApiCall theCall (this, operationName);

   prepGetIndex (thePer);

   apiGet (
       execSlbvVarIndex,
      "execSlbvVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            execSlbvVarIndex (theCall.myOperation (), thePer));
   }
d221 15
a235 15
      const char * operationName,
      const int    thePer,
      int *        execVarIndex)
   {
   WitOperationApiCall theCall (this, operationName);

   prepGetIndex (thePer);

   apiGet (
       execVarIndex,
      "execVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            execVarIndex (theCall.myOperation (), thePer));
   }
d240 4
a243 4
      const char *         operationName,
      const WitOVRealArg & execVol)
   {
   WitOperationApiCall theCall (this, operationName);
d245 2
a246 2
   apiGet (execVol, "execVol", theCall.myOperation ()->execVol ());
   }
d251 12
a262 12
      const char *   operationName,
      WitBoolean * * executable)
   {
   WitOperationApiCall theCall (this, operationName);

   myProblem ()->myPreprocessor ()->preprocess ();

   apiGet (
      executable,
      "executable",
      theCall.myOperation ()->executable ());
   }
d267 18
a284 18
      const char * operationNameParm,
      WitBoolean * exists)
   {
   myApiMgr_->startInnerFunc ();

   if (myCompMgr ()->findOperation (operationNameParm) != NULL)
      {
      myMsgFac () ("operationDoesExist", operationNameParm);

      * exists = true;
      }
   else
      {
      myMsgFac () ("operationDoesNotExist", operationNameParm);

      * exists = false;
      }
   }
d289 4
a292 4
      const char *         operationName,
      const WitOVRealArg & fssExecVol)
   {
   WitOperationApiCall theCall (this, operationName);
d294 1
a294 1
   forbidStochMode ();
d296 1
a296 1
   myProblem ()->computeFssIfNeeded ();
d298 2
a299 2
   apiGet (fssExecVol, "fssExecVol", theCall.myOperation ()->fssExecVol ());
   }
d304 4
a307 4
      const char *         operationName,
      const WitOVRealArg & incLotSize)
   {
   WitOperationApiCall theCall (this, operationName);
d309 2
a310 2
   apiGet (incLotSize, "incLotSize", theCall.myOperation ()->incLotSize ());
   }
d315 4
a318 4
      const char *         operationName,
      const WitOVRealArg & incLotSize2)
   {
   WitOperationApiCall theCall (this, operationName);
d320 2
a321 2
   apiGet (incLotSize2, "incLotSize2", theCall.myOperation ()->incLotSize2 ());
   }
d326 10
a335 10
      const char * operationName,
      WitBoolean * intExecVols)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
       intExecVols,
      "intExecVols", 
      theCall.myOperation ()->intExecVols ());
   }
d340 10
a349 10
      const char *         operationName,
      const WitOVRealArg & lotSize2Thresh)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
      lotSize2Thresh, 
      "lotSize2Thresh", 
      theCall.myOperation ()->lotSize2Thresh ());
   }
d354 4
a357 4
      const char *         operationName,
      const WitOVRealArg & minLotSize)
   {
   WitOperationApiCall theCall (this, operationName);
d359 2
a360 2
   apiGet (minLotSize, "minLotSize", theCall.myOperation ()->minLotSize ());
   }
d365 4
a368 4
      const char *         operationName,
      const WitOVRealArg & minLotSize2)
   {
   WitOperationApiCall theCall (this, operationName);
d370 2
a371 2
   apiGet (minLotSize2, "minLotSize2", theCall.myOperation ()->minLotSize2 ());
   }
d376 4
a379 4
      const char *         operationName,
      const WitOVRealArg & mrpExecVol)
   {
   WitOperationApiCall theCall (this, operationName);
d381 2
a382 2
   apiGet (mrpExecVol, "mrpExecVol", theCall.myOperation ()->mrpExecVol ());
   }
d387 10
a396 10
      const char * operationName,
      int *        nBomEntries)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
      nBomEntries,
      "nBomEntries",
      theCall.myOperation ()->bom ().nElements ());
   }
d401 10
a410 10
      const char * operationName,
      int *        nBopEntries)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
      nBopEntries,
      "nBopEntries",
      theCall.myOperation ()->bop ().nElements ());
   }
d415 12
a426 12
      const char *         operationName,
      const WitOVRealArg & obj1ExecCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "operation",
         "obj1ExecCost",
         "execCost");
d428 2
a429 2
   witGetOperationExecCost (operationName, obj1ExecCost);
   }
d434 4
a437 4
      const char * operationName,
      int *        objectStage)
   {
   WitOperationApiCall theCall (this, operationName);
d439 2
a440 2
   theCall.getObjectStage (objectStage);
   }
d445 5
a449 5
      int  *     lenOperationList,
      char * * * operationList)
   {
   WitOperation * theOpn;
   int            i;
d451 1
a451 1
   myApiMgr_->startInnerFunc ();
d453 1
a453 1
   * lenOperationList = myCompMgr ()->nOperations ();
d455 1
a455 1
   apiAlloc (operationList, * lenOperationList);
d457 1
a457 1
   i = 0;
d459 3
a461 3
   forEachOperation (theOpn, myProblem ())
      (* operationList)[i++] = theOpn->operationName ().apiDupCstring ();
   }
d466 4
a469 4
      const char * operationName,
      WitBoolean * selForDel)
   {
   WitOperationApiCall theCall (this, operationName);
d471 2
a472 2
   apiGet (selForDel, "selForDel", theCall.myOperation ()->selForDel ());
   }
d477 10
a486 10
      const char * operationName,
      WitBoolean * twoLevelLotSizes)
   {
   WitOperationApiCall theCall (this, operationName);

   apiGet (
       twoLevelLotSizes,
      "twoLevelLotSizes", 
      theCall.myOperation ()->twoLevelLotSizes ());
   }
d491 5
a495 5
      const char * operationName,
      int * *      yield)
   {
   double *  yieldRateCVec;
   WitPeriod thePer;
d497 1
a497 1
   myApiMgr_->startInnerFunc ();
d499 7
a505 7
   if (myMsgFac ().mayIssue ("getPre50AttrMsg"))
      myMsgFac () (
         "getPre50AttrMsg",
         apiFuncName (),
         "operation",
         "yield",
         "yieldRate");
d507 1
a507 1
   witGetOperationYieldRate (operationName, & yieldRateCVec);
d509 1
a509 1
   forbidNullArg (yield, "yield");
d511 1
a511 1
   apiAlloc (yield, nPeriods ());
d513 2
a514 2
   forEachPeriod (thePer, myProblem ())
      (* yield)[thePer] = fracToPercent (yieldRateCVec[thePer]);
d516 2
a517 2
   free (yieldRateCVec);
   }
d522 4
a525 4
      const char *         operationName,
      const WitOVRealArg & yieldRate)
   {
   WitOperationApiCall theCall (this, operationName);
d527 2
a528 2
   apiGet (yieldRate, "yieldRate", theCall.myOperation ()->yieldRate ());
   }
d533 4
a536 4
      const char * operationName,
      void *       appData)
   {
   WitOperationApiCall theCall (this, operationName);
d538 2
a539 2
   theCall.setAppData (appData);
   }
d544 4
a547 4
      const char *         operationName,
      const WitIVRealArg & cycleTime34)
   {
   WitOperationApiCall theCall (this, operationName);
d549 2
a550 2
   theCall.setCycleTime34 (cycleTime34);
   }
d555 13
a567 13
      const char *         operationName,
      const WitIVRealArg & hardLB,
      const WitIVRealArg & softLB,
      const WitIVRealArg & hardUB)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.setBoundSet (
      theCall.myOperation ()->execBounds (), 
      hardLB, 
      softLB, 
      hardUB);
   }
d572 22
a593 22
      const char *         operationName,
      const WitIVRealArg & execCost)
   {
   WitOperationApiCall theCall (this, operationName);
   WitPeriod           thePer;

   theCall.prepDblVec ("execCost", execCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (execCost[thePer] < 0.0)
            myMsgFac () (
               "negOperationCostWmsg",
               "execCost",
               operationName,
               execCost[thePer],
               thePer);

      theCall.myOperation ()->setExecCost (execCost);
      }
   }
d598 13
a610 13
      const char *         operationName,
      const WitISRealArg & execPenalty)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDouble (
      "execPenalty", 
      theCall.myOperation ()->execPenalty (),
      execPenalty);

   if (theCall.argsOK ())
      theCall.myOperation ()->setExecPenalty (execPenalty);
   }
d615 10
a624 10
      const char *         operationName,
      const WitIVRealArg & execVol)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("execVol", execVol);

   if (theCall.argsOK ())
      theCall.myOperation ()->setExecVol (execVol);
   }
d629 10
a638 10
      const char *         operationName,
      const WitIVRealArg & incLotSize)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("incLotSize", incLotSize);

   if (theCall.argsOK ())
      theCall.myOperation ()->setIncLotSize (incLotSize);
   }
d643 10
a652 10
      const char *         operationName,
      const WitIVRealArg & incLotSize2)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("incLotSize2", incLotSize2);

   if (theCall.argsOK ())
      theCall.myOperation ()->setIncLotSize2 (incLotSize2);
   }
d657 9
a665 9
      const char * operationName,
      WitBoolean   intExecVols)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepBool (
                             "intExecVols", 
      theCall.myOperation ()->intExecVols (), 
                              intExecVols);
d667 2
a668 2
   theCall.myOperation ()->setIntExecVols (asaBool (intExecVols));
   }
d673 10
a682 10
      const char *         operationName,
      const WitIVRealArg & lotSize2Thresh)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("lotSize2Thresh", lotSize2Thresh);

   if (theCall.argsOK ())
      theCall.myOperation ()->setLotSize2Thresh (lotSize2Thresh);
   }
d687 10
a696 10
      const char *         operationName,
      const WitIVRealArg & minLotSize)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("minLotSize", minLotSize);

   if (theCall.argsOK ())
      theCall.myOperation ()->setMinLotSize (minLotSize);
   }
d701 10
a710 10
      const char *         operationName,
      const WitIVRealArg & minLotSize2)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDblVec ("minLotSize2", minLotSize2);

   if (theCall.argsOK ())
      theCall.myOperation ()->setMinLotSize2 (minLotSize2);
   }
d715 12
a726 12
      const char *         operationName,
      const WitIVRealArg & obj1ExecCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "operation",
         "obj1ExecCost",
         "execCost");
d728 2
a729 2
   witSetOperationExecCost (operationName, obj1ExecCost);
   }
d734 4
a737 4
      const char * operationName,
      int          objectStage)
   {
   WitOperationApiCall theCall (this, operationName);
d739 2
a740 2
   theCall.setObjectStage (objectStage);
   }
d745 24
a768 24
      const char * operationName,
      const char * newName)
   {
   WitOperationApiCall theCall (this, operationName);

   forbidNullArg (newName, "newName");

   if (isNullCstring (newName))
      myMsgFac () ("nullStringSmsg", "newName");

   if (myCompMgr ()->findOperation (newName))
      myMsgFac () ("setNodeNameToDupSmsg",
         "witSetOperationOperationName",
         myMsgFac ().myFrag ("operationFrag"),
         newName);

   theCall.prepString (
                             "operationName",
      theCall.myOperation ()->operationName (),
                                    newName);

   if (theCall.argsOK ())
      theCall.myOperation ()->setOperationName (newName);
   }
d773 4
a776 4
      const char * operationName,
      WitBoolean   selForDel)
   {
   WitOperationApiCall theCall (this, operationName);
d778 2
a779 2
   theCall.setSelForDel (selForDel);
   }
d784 4
a787 4
      const char * operationName,
      WitBoolean   twoLevelLotSizes)
   {
   WitOperationApiCall theCall (this, operationName);
d789 2
a790 2
   theCall.myOperation ()->setTwoLevelLotSizes (asaBool (twoLevelLotSizes));
   }
d795 15
a809 15
      const char * operationName,
      const int *  yield)
   {
   WitTVec <double> yieldRateTVec (myProblem (), 0.0);
   WitPeriod        thePer;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setPre50AttrMsg"))
      myMsgFac () (
         "setPre50AttrMsg",
         apiFuncName (),
         "operation",
         "yield",
         "yieldRate");
d811 1
a811 1
   forbidNullArg (yield, "yield");
d813 2
a814 2
   forEachPeriod (thePer, myProblem ())
      yieldRateTVec[thePer] = percentToFrac (yield[thePer]);
d816 2
a817 2
   witSetOperationYieldRate (operationName, yieldRateTVec.myCVec ());
   }
d822 4
a825 4
      const char *         operationName,
      const WitIVRealArg & yieldRate)
   {
   WitOperationApiCall theCall (this, operationName);
d827 2
a828 2
   theCall.setYieldRate (yieldRate);
   }
d836 2
a837 2
   {
   WitOperation * operationP;
d839 1
a839 1
   operationP = myCompMgr ()->findOperation (operationName);
d841 2
a842 2
   if (operationP == NULL)
      myMsgFac () ("undefinedOperationMsg", operationName);
d844 2
a845 2
   return operationP;
   }
@


1.99
log
@Removing objective #2.
@
text
@d29 1
a29 1
#include <Opn.h>
@


1.98
log
@Removing objective #2.
@
text
@d585 1
a585 1
               "negOperationObj1CostCoef",
@


1.97
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@a432 13
void WitRun::witGetOperationObj2AuxCost (
      const char *         operationName,
      const WitOSRealArg & obj2AuxCost)
   {
   myApiMgr_->startInnerFunc ();

   WitOperationApiCall theCall (this, operationName);

   apiGet (obj2AuxCost, "obj2AuxCost", theCall.myOperation ()->obj2AuxCost ());
   }

//------------------------------------------------------------------------------

a732 17
void WitRun::witSetOperationObj2AuxCost (
      const char *         operationName,
      const WitISRealArg & obj2AuxCost)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.prepNonNegDouble (
      "obj2AuxCost", 
      theCall.myOperation ()->obj2AuxCost (),
      obj2AuxCost);

   if (theCall.argsOK ())
      theCall.myOperation ()->setObj2AuxCost (obj2AuxCost);
   }

//------------------------------------------------------------------------------

@


1.96
log
@Object name change.
@
text
@d34 2
@


1.95
log
@Object name change.
@
text
@d70 1
a70 1
      myMsgFac () ("nullNameSmsg", operationNameParm);
d778 2
d781 1
a781 1
      myMsgFac () ("nullNameSmsg", newName);
@


1.94
log
@Object name change.
@
text
@d69 1
a69 1
   if (isNullString (operationNameParm))
d778 1
a778 1
   if (isNullString (newName))
@


1.93
log
@Object name changing.
@
text
@d793 1
a793 1
      myCompMgr ()->setOperationName (theCall.myOperation (), newName);
@


1.92
log
@Stochastic Implosion
@
text
@d772 26
@


1.91
log
@Stochastic Implosion
@
text
@d444 11
a486 11
void WitRun::witGetOperationStageIndex (
      const char * operationName,
      int *        stageIndex)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.getStageIndex (stageIndex);
   }

//------------------------------------------------------------------------------

d761 1
a761 1
void WitRun::witSetOperationSelForDel (
d763 1
a763 1
      WitBoolean   selForDel)
d767 1
a767 1
   theCall.setSelForDel (selForDel);
d772 1
a772 1
void WitRun::witSetOperationStageIndex (
d774 1
a774 1
      int          stageIndex)
d778 1
a778 1
   theCall.setStageIndex (stageIndex);
@


1.90
log
@Stochastic Implosion
@
text
@d482 1
a482 13
   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "stageIndex",
         myMsgFac ().myFrag ("operationFrag"));

   if (myStochImpMgr ()->stochMode ())
      if (not myStochImpMgr ()->stageByObject ())
         myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

   apiGet (
      stageIndex,
      "stageIndex",
      myStochImpMgr ()->stageIndex (theCall.myOperation ()));
@


1.89
log
@Stochastic Implosion
@
text
@a789 4
   if (myStochImpMgr ()->stochMode ())
      if (not myStochImpMgr ()->stageByObject ())
         myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

@


1.88
log
@Stochastic Implosion
@
text
@d487 4
d790 4
@


1.87
log
@Stochastic Implosion
@
text
@d292 2
@


1.86
log
@Stochastic Implosion
@
text
@d474 1
a474 1
void WitRun::witGetOperationStageNo (
d476 1
a476 1
      int *        stageNo)
d482 1
a482 1
         "stageNo",
d486 3
a488 3
      stageNo,
      "stageNo",
      myStochImpMgr ()->stageNo (theCall.myOperation ()));
d778 1
a778 1
void WitRun::witSetOperationStageNo (
d780 1
a780 1
      int          stageNo)
d784 1
a784 1
   theCall.setStageNo (stageNo);
@


1.85
log
@Stochastic Implosion
@
text
@d784 1
a784 20
   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "stageNo",
         myMsgFac ().myFrag ("operationFrag"));

   if (myStochImpMgr ()->stochSolnMode ())
      myMsgFac () ("setObjStochSolnSmsg",
         "stageNo",
         myMsgFac ().myFrag ("operationFrag"));

   theCall.prepRangedInt (
                       "stageNo", 
      myStochImpMgr ()->stageNo (theCall.myOperation ()),
                        stageNo,
                        0,
                        1);

   if (theCall.argsOK ())
      myStochImpMgr ()->
         setStageNo (theCall.myOperation (), stageNo);
@


1.84
log
@Stochastic Implosion
@
text
@a242 2
   theCall.prepGetStochSolnAttr ("execVol");

@


1.83
log
@Stochastic Implosion
@
text
@a481 3
   if (not myStochImpMgr ()->stochImpAllowed ())
      myMsgFac () ("attNYASmsg", "stageNo");

a785 3
   if (not myStochImpMgr ()->stochImpAllowed ())
      myMsgFac () ("attNYASmsg", "stageNo");

@


1.82
log
@Stochastic Implosion
@
text
@a443 22
void WitRun::witGetOperationRecourseStage (
      const char * operationName,
      WitBoolean * recourseStage)
   {
   WitOperationApiCall theCall (this, operationName);

   if (not myStochImpMgr ()->stochImpAllowed ())
      myMsgFac () ("attNYASmsg", "recourseStage");

   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "recourseStage",
         myMsgFac ().myFrag ("operationFrag"));

   apiGet (
      recourseStage,
      "recourseStage",
      myStochImpMgr ()->recourseStage (theCall.myOperation ()));
   }

//------------------------------------------------------------------------------

d476 22
d772 12
a783 1
void WitRun::witSetOperationRecourseStage (
d785 1
a785 1
      WitBoolean   recourseStage)
d790 1
a790 1
      myMsgFac () ("attNYASmsg", "recourseStage");
d794 1
a794 1
         "recourseStage",
d799 1
a799 1
         "recourseStage",
d802 6
a807 4
   theCall.prepBool (    
                       "recourseStage", 
      myStochImpMgr ()->recourseStage (theCall.myOperation ()),
                        recourseStage);
d811 1
a811 12
         setRecourseStage (theCall.myOperation (), asaBool (recourseStage));
   }

//------------------------------------------------------------------------------

void WitRun::witSetOperationSelForDel (
      const char * operationName,
      WitBoolean   selForDel)
   {
   WitOperationApiCall theCall (this, operationName);

   theCall.setSelForDel (selForDel);
@


1.81
log
@Stochastic Implosion
@
text
@d25 1
a25 1
#include <OptImp.h>
d192 1
a192 1
      myOptImploder ()->
d211 1
a211 1
      myOptImploder ()->
d230 1
a230 1
      myOptImploder ()->
@


1.80
log
@Stochastic Implosion
@
text
@a790 2
   theCall.prepStochSolnModeAttr ();

@


1.79
log
@Stochastic Implosion
@
text
@d450 1
a450 1
   if (not myProblem ()->myStochImpMgr ()->stochImpAllowed ())
d453 1
a453 1
   if (not myProblem ()->myStochImpMgr ()->stochMode ())
d461 1
a461 1
      myProblem ()->myStochImpMgr ()->recourseStage (theCall.myOperation ()));
d778 1
a778 1
   if (not myProblem ()->myStochImpMgr ()->stochImpAllowed ())
d781 1
a781 1
   if (not myProblem ()->myStochImpMgr ()->stochMode ())
d786 5
d794 3
a796 3
                                     "recourseStage", 
      myProblem ()->myStochImpMgr ()->recourseStage (theCall.myOperation ()),
                                      recourseStage);
d799 2
a800 5
      myProblem ()->
         myStochImpMgr ()->
            setRecourseStage (
               theCall.myOperation (),
               asaBool (recourseStage));
@


1.78
log
@Stochastic Implosion
@
text
@d453 1
a453 1
   if (not myProblem ()->myStochImpMgr ()->stochDataMode ())
d781 1
a781 1
   if (not myProblem ()->myStochImpMgr ()->stochDataMode ())
@


1.77
log
@Stochastic Implosion
@
text
@a457 2
   theCall.prepGetStochAttr ();

@


1.76
log
@Stochastic Implosion.
@
text
@d27 1
d444 24
d774 31
@


1.75
log
@Stochastic Implosion
@
text
@d242 2
a244 2

   theCall.issueScenMsg ();
@


1.74
log
@Stochastic Implosion
@
text
@a618 2
   theCall.prepStochAttr ();

@


1.73
log
@Stochastic Implosion
@
text
@d243 2
d619 2
@


1.72
log
@Stochastic Implosion.
@
text
@d265 1
a265 1
      WitBoolean * exist)
d269 1
a269 1
   if (myCompMgr ()->findOperation (operationNameParm) == NULL)
d271 1
a271 1
      myMsgFac () ("operationDoesNotExist", operationNameParm);
d273 1
a273 1
      * exist = false;
d277 1
a277 1
      myMsgFac () ("operationDoesExist", operationNameParm);
d279 1
a279 1
      * exist = true;
@


1.71
log
@Stochastic implosion.
@
text
@d71 2
@


1.70
log
@Stochastic implosion.
@
text
@a70 2
   forbidAddStochAct ("operationFrag");

@


1.69
log
@witCopy<Object>Data
@
text
@d71 2
@


1.68
log
@witCopy<Object>Data
@
text
@d83 1
a83 1
   myMsgFac () ( "dupObjectMsg", myMsgFac ().myFrag ("operationFrag"));
@


1.67
log
@witCopy<Object>Data
@
text
@d83 1
a83 1
   myMsgFac () ("dupObjectMsg",  myMsgFac ().myFrag ("operationFrag"));
d85 1
a85 1
   WitOperationApiCall dupCall (this,      dupOperationName);
d95 1
a95 3
   dupCall.myOperation ()->
      copyAttrsFrom (
         origCall.myOperation ());
@


1.66
log
@witCopy<Object>Data
@
text
@d77 3
a79 3
      const char * dstOperationName,
      WitRun *     srcWitRun,
      const char * srcOperationName)
d81 1
a81 1
   startCopyObjData (srcWitRun);
d83 1
a83 1
   myMsgFac () ("dstObjectMsg", myMsgFac ().myFrag ("operationFrag"));
d85 1
a85 1
   WitOperationApiCall dstCall (this,      dstOperationName);
d87 1
a87 1
   myMsgFac () ("srcObjectMsg", myMsgFac ().myFrag ("operationFrag"));
d89 1
a89 1
   WitOperationApiCall srcCall (srcWitRun, srcOperationName);
d91 1
a91 1
   if (dstCall.myOperation () == srcCall.myOperation ())
d95 1
a95 1
   dstCall.myOperation ()->
d97 1
a97 1
         srcCall.myOperation ());
@


1.65
log
@witCopy<Object>Data
@
text
@d83 2
d86 3
@


1.64
log
@witCopy<Object>Data.
@
text
@a84 2
   WitOperation *      dstOpn;
   WitOperation *      srcOpn;
d86 1
a86 4
   dstOpn = dstCall.myOperation ();
   srcOpn = srcCall.myOperation ();

   if (dstOpn == srcOpn)
d90 3
a92 1
   dstOpn->copyAttrsFrom (srcOpn);
@


1.63
log
@External opt implosion.
@
text
@d30 1
d76 24
@


1.62
log
@External opt implosion.
@
text
@d26 1
a26 1
#include <ExtOptHand.h>
d165 1
a165 1
         myExtOptHandler ()->
d184 1
a184 1
         myExtOptHandler ()->
d203 1
a203 1
         myExtOptHandler ()->
@


1.61
log
@External opt implosion.
@
text
@d152 19
@


1.60
log
@External opt implosion.
@
text
@d152 4
a155 3
void WitRun::witGetOperationExecutable (
      const char *   operationName,
      WitBoolean * * executable)
d159 1
a159 1
   myProblem ()->myPreprocessor ()->preprocess ();
d162 5
a166 3
      executable,
      "executable",
      theCall.myOperation ()->executable ());
d174 1
a174 1
      int *        execIndex)
d181 2
a182 2
       execIndex,
      "execIndex",
d201 16
@


1.59
log
@External opt implosion.
@
text
@d171 1
a171 1
      int *        colIndex)
d178 2
a179 2
       colIndex,
      "colIndex",
@


1.58
log
@External opt implosion.
@
text
@d175 1
a175 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
@


1.57
log
@External opt implosion.
@
text
@d25 2
d168 23
@


1.56
log
@External opt implosion.
@
text
@d55 2
d77 5
a81 1
   theOpn = curItrDelCompForGet (WitAT_OPERATION, "operationFrag")->thisOpn ();
d181 2
a201 1

d327 2
d346 2
d362 2
d408 2
d629 2
d690 2
@


1.55
log
@App controlled opt implosion.
@
text
@d227 1
a227 1
void WitRun::witGetOperationIntConExecVols (
d229 1
a229 1
      WitBoolean * intConExecVols)
d234 3
a236 3
       intConExecVols,
      "intConExecVols", 
      theCall.myOperation ()->intConExecVols ());
d552 1
a552 1
void WitRun::witSetOperationIntConExecVols (
d554 1
a554 1
      WitBoolean   intConExecVols)
d559 3
a561 3
                             "intConExecVols", 
      theCall.myOperation ()->intConExecVols (), 
                              intConExecVols);
d563 1
a563 1
   theCall.myOperation ()->setIntConExecVols (asaBool (intConExecVols));
@


1.54
log
@App controlled opt implosion.
@
text
@d24 1
d150 1
a150 1
   myProblem ()->preprocess ();
@


1.53
log
@App controlled opt implosion.
@
text
@a53 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a71 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a86 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a97 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a110 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a121 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a135 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a146 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a162 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a173 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a194 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a207 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a218 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a229 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a243 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a257 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a268 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a279 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a290 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a304 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a318 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a335 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a346 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a365 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a376 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a390 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a419 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a430 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a441 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a454 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a469 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a495 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a512 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a526 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a540 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a554 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a570 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a584 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a598 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a612 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a629 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a646 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a657 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a668 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a693 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

@


1.52
log
@Integrality constraints.
@
text
@d54 4
d76 4
d95 4
d110 4
d127 4
d142 4
d160 4
d175 4
d195 4
d210 4
d235 4
d252 4
d267 4
d282 4
d300 4
d318 4
d333 4
d348 4
d363 4
d381 4
d399 4
d420 4
d435 4
d458 4
d473 4
d491 4
d524 4
d539 4
d554 4
d571 4
d590 4
d620 4
d641 4
d659 4
d677 4
d695 4
d715 4
d733 4
d751 4
d769 4
d790 4
d811 4
d826 4
d841 4
d870 4
@


1.51
log
@Integrality constraints.
@
text
@d226 1
a226 1
void WitRun::witGetOperationIntExecVols (
d228 1
a228 1
      WitBoolean * intExecVols)
d233 3
a235 3
       intExecVols,
      "intExecVols", 
      theCall.myOperation ()->intExecVols ());
d551 1
a551 1
void WitRun::witSetOperationIntExecVols (
d553 1
a553 1
      WitBoolean   intExecVols)
d558 3
a560 3
                             "intExecVols", 
      theCall.myOperation ()->intExecVols (), 
                              intExecVols);
d562 1
a562 1
   theCall.myOperation ()->setIntExecVols (asaBool (intExecVols));
@


1.50
log
@Opt implosion with integrality constraints.
@
text
@a28 2
#include <Global.h>

d557 4
a560 2
   if (not myGlobalComp ()->allowIntVars ())
      myMsgFac () ("attNYASmsg", "intExecVols");
@


1.49
log
@Updated the copyright date on all source files.
@
text
@d29 2
d228 14
d553 14
@


1.48
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.47
log
@[exceptions]
@
text
@a16 1
#include <ProEpilog.h>
d52 1
a52 1
WitReturnCode WitRun::witAddOperation (const char * operationNameParm)
a53 2
   PROLOG ("witAddOperation");

a65 2

   EPILOG;
d70 1
a70 1
WitReturnCode WitRun::witGetObjItrOperation (char * * operationName)
a73 2
   PROLOG ("witGetObjItrOperation");

a78 2

   EPILOG;
d83 1
a83 1
WitReturnCode WitRun::witGetOperationAppData (
a86 2
   PROLOG ("witGetOperationAppData");

a89 2

   EPILOG;
d94 1
a94 1
WitReturnCode WitRun::witGetOperationCycleTime34 (
a97 2
   PROLOG ("witGetOperationCycleTime34");

a100 2

   EPILOG;
d105 1
a105 1
WitReturnCode WitRun::witGetOperationExecBounds (
a110 2
   PROLOG ("witGetOperationExecBounds");

a113 2

   EPILOG;
d118 1
a118 1
WitReturnCode WitRun::witGetOperationExecCost (
a121 2
   PROLOG ("witGetOperationExecCost");

a127 2

   EPILOG;
d132 1
a132 1
WitReturnCode WitRun::witGetOperationExecPenalty (
a135 2
   PROLOG ("witGetOperationExecPenalty");

a138 2

   EPILOG;
d143 1
a143 1
WitReturnCode WitRun::witGetOperationExecutable (
a146 2
   PROLOG ("witGetOperationExecutable");

a154 2

   EPILOG;
d159 1
a159 1
WitReturnCode WitRun::witGetOperationExecVol (
a162 2
   PROLOG ("witGetOperationExecVol");

a165 2

   EPILOG;
d170 1
a170 1
WitReturnCode WitRun::witGetOperationExists (
a173 2
   PROLOG ("witGetOperationExists");

a185 2

   EPILOG;
d190 1
a190 1
WitReturnCode WitRun::witGetOperationFssExecVol (
a194 2
   PROLOG ("witGetOperationFssExecVol");

a199 2

   EPILOG;
d204 1
a204 1
WitReturnCode WitRun::witGetOperationIncLotSize (
a207 2
   PROLOG ("witGetOperationIncLotSize");

a210 2

   EPILOG;
d215 1
a215 1
WitReturnCode WitRun::witGetOperationIncLotSize2 (
a218 2
   PROLOG ("witGetOperationIncLotSize2");

a221 2

   EPILOG;
d226 1
a226 1
WitReturnCode WitRun::witGetOperationLotSize2Thresh (
a229 2
   PROLOG ("witGetOperationLotSize2Thresh");

a235 2

   EPILOG;
d240 1
a240 1
WitReturnCode WitRun::witGetOperationMinLotSize (
a243 2
   PROLOG ("witGetOperationMinLotSize");

a246 2

   EPILOG;
d251 1
a251 1
WitReturnCode WitRun::witGetOperationMinLotSize2 (
a254 2
   PROLOG ("witGetOperationMinLotSize2");

a257 2

   EPILOG;
d262 1
a262 1
WitReturnCode WitRun::witGetOperationMrpExecVol (
a265 2
   PROLOG ("witGetOperationMrpExecVol");

a268 2

   EPILOG;
d273 1
a273 1
WitReturnCode WitRun::witGetOperationNBomEntries (
a276 2
   PROLOG ("witGetOperationNBomEntries");

a282 2

   EPILOG;
d287 1
a287 1
WitReturnCode WitRun::witGetOperationNBopEntries (
a290 2
   PROLOG ("witGetOperationNBopEntries");

a296 2

   EPILOG;
d301 1
a301 1
WitReturnCode WitRun::witGetOperationObj1ExecCost (
a304 2
   PROLOG ("witGetOperationObj1ExecCost");

a313 2

   EPILOG;
d318 1
a318 1
WitReturnCode WitRun::witGetOperationObj2AuxCost (
a321 2
   PROLOG ("witGetOperationObj2AuxCost");

a324 2

   EPILOG;
d329 1
a329 1
WitReturnCode WitRun::witGetOperations (
a335 2
   PROLOG ("witGetOperations");

a343 2

  EPILOG;
d348 1
a348 1
WitReturnCode WitRun::witGetOperationSelForDel (
a351 2
   PROLOG ("witGetOperationSelForDel");

a354 2

   EPILOG;
d359 1
a359 1
WitReturnCode WitRun::witGetOperationTwoLevelLotSizes (
a362 2
   PROLOG ("witGetOperationTwoLevelLotSizes");

a368 2

   EPILOG;
d373 1
a373 1
WitReturnCode WitRun::witGetOperationYield (
a376 2
   PROLOG ("witGetOperationYield");

a397 2

   EPILOG;
d402 1
a402 1
WitReturnCode WitRun::witGetOperationYieldRate (
a405 2
   PROLOG ("witGetOperationYieldRate");

a408 2

   EPILOG;
d413 1
a413 1
WitReturnCode WitRun::witSetOperationAppData (
a416 2
   PROLOG ("witSetOperationAppData");

a419 2

   EPILOG;
d424 1
a424 1
WitReturnCode WitRun::witSetOperationCycleTime34 (
a427 2
   PROLOG ("witSetOperationCycleTime34");

a430 2

   EPILOG;
d435 1
a435 1
WitReturnCode WitRun::witSetOperationExecBounds (
a440 2
   PROLOG ("witSetOperationExecBounds");

a447 2

   EPILOG;
d452 1
a452 1
WitReturnCode WitRun::witSetOperationExecCost (
a455 2
   PROLOG ("witSetOperationExecCost");

a473 2

   EPILOG;
d478 1
a478 1
WitReturnCode WitRun::witSetOperationExecPenalty (
a481 2
   PROLOG ("witSetOperationExecPenalty");

a490 2

   EPILOG;
d495 1
a495 1
WitReturnCode WitRun::witSetOperationExecVol (
a498 2
   PROLOG ("witSetOperationExecVol");

a504 2

   EPILOG;
d509 1
a509 1
WitReturnCode WitRun::witSetOperationIncLotSize (
a512 2
   PROLOG ("witSetOperationIncLotSize");

a518 2

   EPILOG;
d523 1
a523 1
WitReturnCode WitRun::witSetOperationIncLotSize2 (
a526 2
   PROLOG ("witSetOperationIncLotSize2");

a532 2

   EPILOG;
d537 1
a537 1
WitReturnCode WitRun::witSetOperationLotSize2Thresh (
a540 2
   PROLOG ("witSetOperationLotSize2Thresh");

a546 2

   EPILOG;
d551 1
a551 1
WitReturnCode WitRun::witSetOperationMinLotSize (
a554 2
   PROLOG ("witSetOperationMinLotSize");

a560 2

   EPILOG;
d565 1
a565 1
WitReturnCode WitRun::witSetOperationMinLotSize2 (
a568 2
   PROLOG ("witSetOperationMinLotSize2");

a574 2

   EPILOG;
d579 1
a579 1
WitReturnCode WitRun::witSetOperationObj1ExecCost (
a582 2
   PROLOG ("witSetOperationObj1ExecCost");

a591 2

   EPILOG;
d596 1
a596 1
WitReturnCode WitRun::witSetOperationObj2AuxCost (
a599 2
   PROLOG ("witSetOperationObj2AuxCost");

a608 2

   EPILOG;
d613 1
a613 1
WitReturnCode WitRun::witSetOperationSelForDel (
a616 2
   PROLOG ("witSetOperationSelForDel");

a619 2

   EPILOG;
d624 1
a624 1
WitReturnCode WitRun::witSetOperationTwoLevelLotSizes (
a627 2
   PROLOG ("witSetOperationTwoLevelLotSizes");

a630 2

   EPILOG;
d635 1
a635 1
WitReturnCode WitRun::witSetOperationYield (
a641 2
   PROLOG ("witSetOperationYield");

a655 2

   EPILOG;
d660 1
a660 1
WitReturnCode WitRun::witSetOperationYieldRate (
a663 2
   PROLOG ("witSetOperationYieldRate");

a666 2

   EPILOG;
@


1.46
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@d17 1
d19 1
d46 1
a46 1
   myInputId ()->setMyOperation (theOpn);
@


1.45
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d137 18
d382 7
a388 1
   WitOperationApiCall theCall (this, operationName);
d390 1
a390 4
   apiGet (
      obj1ExecCost, 
      "obj1ExecCost", 
      theCall.myOperation ()->obj1ExecCost ());
d567 30
d732 7
a738 4
   WitOperationApiCall theCall (this, operationName);
   WitPeriod           thePer;

   theCall.prepDblVec ("obj1ExecCost", obj1ExecCost);
d740 1
a740 13
   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (obj1ExecCost[thePer] < 0.0)
            myMsgFac () (
               "negOperationObj1CostCoef",
               "obj1ExecCost",
               operationName,
               obj1ExecCost[thePer],
               thePer);

      theCall.myOperation ()->setObj1ExecCost (obj1ExecCost);
      }
@


1.44
log
@Vector PropRt.
@
text
@d366 1
a366 1
   apiGetObj1Vector (
d684 1
a684 1
   theCall.prepObj1Vec ("obj1ExecCost", obj1ExecCost);
@


1.43
log
@Pegged Critical List.
@
text
@d19 4
a22 4
#include <InScalRA.h>
#include <OutScalRA.h>
#include <InVecRA.h>
#include <OutVecRA.h>
d106 2
a107 2
      const char *        operationName,
      const WitOutVecRA & cycleTime34)
d121 4
a124 4
      const char *        operationName,
      const WitOutVecRA & hardlbP,
      const WitOutVecRA & softlbP,
      const WitOutVecRA & hardubP)
d139 1
a139 1
      const WitOutScalRA & execPenalty)
d173 2
a174 2
      const char *        operationName,
      const WitOutVecRA & execVol)
d212 2
a213 2
      const char *        operationName,
      const WitOutVecRA & fssExecVol)
d230 2
a231 2
      const char *        operationName,
      const WitOutVecRA & incLotSize)
d245 2
a246 2
      const char *        operationName,
      const WitOutVecRA & incLotSize2)
d260 2
a261 2
      const char *        operationName,
      const WitOutVecRA & lotSize2Thresh)
d278 2
a279 2
      const char *        operationName,
      const WitOutVecRA & minLotSize)
d293 2
a294 2
      const char *        operationName,
      const WitOutVecRA & minLotSize2)
d308 2
a309 2
      const char *        operationName,
      const WitOutVecRA & mrpExecVol)
d359 2
a360 2
      const char *        operationName,
      const WitOutVecRA & obj1ExecCost)
d378 1
a378 1
      const WitOutScalRA & obj2AuxCost)
d481 2
a482 2
      const char *        operationName,
      const WitOutVecRA & yieldRate)
d511 2
a512 2
      const char *       operationName,
      const WitInVecRA & cycleTime34)
d526 4
a529 4
      const char *       operationName,
      const WitInVecRA & hardLB,
      const WitInVecRA & softLB,
      const WitInVecRA & hardUB)
d547 2
a548 2
      const char *        operationName,
      const WitInScalRA & execPenalty)
d568 2
a569 2
      const char *       operationName,
      const WitInVecRA & execVol)
d586 2
a587 2
      const char *       operationName,
      const WitInVecRA & incLotSize)
d604 2
a605 2
      const char *       operationName,
      const WitInVecRA & incLotSize2)
d622 2
a623 2
      const char *       operationName,
      const WitInVecRA & lotSize2Thresh)
d640 2
a641 2
      const char *       operationName,
      const WitInVecRA & minLotSize)
d658 2
a659 2
      const char *       operationName,
      const WitInVecRA & minLotSize2)
d676 2
a677 2
      const char *       operationName,
      const WitInVecRA & obj1ExecCost)
d706 2
a707 2
      const char *        operationName,
      const WitInScalRA & obj2AuxCost)
d786 2
a787 2
      const char *       operationName,
      const WitInVecRA & yieldRate)
@


1.42
log
@Minor change.
@
text
@d407 1
a407 1
      (* operationList)[i++] = dupCstring (theOpn->operationName ());
@


1.41
log
@Removed portableFree.
@
text
@a25 1
#include <wit.h>
@


1.40
log
@Double Precision.
@
text
@d474 1
a474 1
   portableFree (yieldRateCVec);
@


1.39
log
@Double Precision.
@
text
@d454 1
a454 1
   float *   theYieldRate;
d465 1
a465 1
   witGetOperationYieldRate (operationName, & theYieldRate);
d472 1
a472 1
      (* yield)[thePer] = fracToPercent (dblFromFlt (theYieldRate[thePer]));
d474 1
a474 1
   portableFree (theYieldRate);
d761 2
a762 2
   WitTVec <float> theYieldRate (myProblem (), 0.0);
   WitPeriod       t;
d776 2
a777 2
   forEachPeriod (t, myProblem ())
      theYieldRate[t] = fltFromDbl (percentToFrac (yield[t]));
d779 1
a779 1
   witSetOperationYieldRate (operationName, theYieldRate.myCVec ());
@


1.38
log
@Double Precision.
@
text
@d107 2
a108 2
      const char * operationName,
      float * *    cycleTime34)
d512 2
a513 2
      const char *  operationName,
      const float * cycleTime34)
@


1.37
log
@Double Precision.
@
text
@d403 1
a403 1
   apiAlloc (* operationList, * lenOperationList);
d469 1
a469 1
   apiAlloc (* yield, nPeriods ());
@


1.36
log
@Double Precision.
@
text
@d107 2
a108 2
      const char *        operationName,
      const WitOutVecRA & cycleTime34)
d512 2
a513 2
      const char *       operationName,
      const WitInVecRA & cycleTime34)
@


1.35
log
@Double Precision.
@
text
@d22 1
d107 2
a108 2
      const char * operationName,
      float * *    cycleTime34)
d213 2
a214 2
      const char * operationName,
      float * *    fssExecVol)
d231 2
a232 2
      const char * operationName,
      float * *    incLotSize)
d246 2
a247 2
      const char * operationName,
      float * *    incLotSize2)
d261 2
a262 2
      const char * operationName,
      float * *    lotSize2Thresh)
d279 2
a280 2
      const char * operationName,
      float * *    minLotSize)
d294 2
a295 2
      const char * operationName,
      float * *    minLotSize2)
d309 2
a310 2
      const char * operationName,
      float * *    mrpExecVol)
d360 2
a361 2
      const char * operationName,
      float * *    obj1ExecCost)
d455 1
a455 1
   WitPeriod t;
d471 2
a472 2
   forEachPeriod (t, myProblem ())
      (* yield)[t] = fracToPercent (dblFromFlt (theYieldRate[t]));
d482 2
a483 2
      const char * operationName,
      float * *    yieldRate)
@


1.34
log
@Double Precision.
@
text
@d511 2
a512 2
      const char *  operationName,
      const float * cycleTime34)
d586 2
a587 2
      const char *  operationName,
      const float * incLotSize)
d604 2
a605 2
      const char *  operationName,
      const float * incLotSize2)
d622 2
a623 2
      const char *  operationName,
      const float * lotSize2Thresh)
d640 2
a641 2
      const char *  operationName,
      const float * minLotSize)
d658 2
a659 2
      const char *  operationName,
      const float * minLotSize2)
d676 2
a677 2
      const char *  operationName,
      const float * obj1ExecCost)
d786 2
a787 2
      const char *  operationName,
      const float * yieldRate)
@


1.33
log
@Double Precision.
@
text
@d173 2
a174 2
      const char * operationName,
      float * *    execVol)
d568 2
a569 2
      const char *  operationName,
      const float * execVol)
@


1.32
log
@Double Precision.
@
text
@d366 1
a366 1
   witGetObj1Vector (
@


1.31
log
@Double Precision.
@
text
@d575 1
a575 1
   theCall.prepNonNegFloatVec ("execVol", execVol);
d593 1
a593 1
   theCall.prepNonNegFloatVec ("incLotSize", incLotSize);
d611 1
a611 1
   theCall.prepNonNegFloatVec ("incLotSize2", incLotSize2);
d629 1
a629 1
   theCall.prepNonNegFloatVec ("lotSize2Thresh", lotSize2Thresh);
d647 1
a647 1
   theCall.prepNonNegFloatVec ("minLotSize", minLotSize);
d665 1
a665 1
   theCall.prepNonNegFloatVec ("minLotSize2", minLotSize2);
@


1.30
log
@Double Precision.
@
text
@d121 4
a124 4
      const char * operationName,
      float * *    hardlbP,
      float * *    softlbP,
      float * *    hardubP)
d526 4
a529 4
      const char *  operationName,
      const float * hardLB,
      const float * softLB,
      const float * hardUB)
@


1.29
log
@Double Precision.
@
text
@d21 1
@


1.28
log
@Double Precision.
@
text
@d534 1
a534 1
   theCall.prepBoundSet (
a538 3

   if (theCall.argsOK ())
      theCall.myOperation ()->execBounds ()->set (hardLB, softLB, hardUB);
@


1.27
log
@Double Precision.
@
text
@d137 2
a138 2
      const char * operationName,
      WitOutScalRA execPenalty)
d376 2
a377 2
      const char * operationName,
      WitOutScalRA obj2AuxCost)
@


1.26
log
@Double Precision.
@
text
@d549 2
a550 2
      const char * operationName,
      WitInScalRA  execPenalty)
d708 2
a709 2
      const char * operationName,
      WitInScalRA  obj2AuxCost)
@


1.25
log
@Double Precision.
@
text
@d751 1
a751 1
   theCall.myOperation ()->setTwoLevelLotSizes (twoLevelLotSizes);
@


1.24
log
@Double Precision.
@
text
@d153 1
a153 1
      witBoolean * * executable)
d188 1
a188 1
      witBoolean * exist)
d415 1
a415 1
      witBoolean * selForDel)
d430 1
a430 1
      witBoolean * twoLevelLotSizes)
d730 1
a730 1
      witBoolean   selForDel)
d745 1
a745 1
      witBoolean   twoLevelLotSizes)
@


1.23
log
@Double Precision.
@
text
@d470 1
a470 1
      (* yield)[t] = fracToPercent (doubleFromFloat (theYieldRate[t]));
d778 1
a778 1
      theYieldRate[t] = floatFromDouble (percentToFrac (yield[t]));
@


1.22
log
@Double Precision.
@
text
@d780 1
a780 1
   witSetOperationYieldRate (operationName, theYieldRate.myCvector ());
@


1.21
log
@Continued double precision.
@
text
@d138 1
a138 1
      OutScalRA    execPenalty)
d377 1
a377 1
      OutScalRA    obj2AuxCost)
d550 1
a550 1
      InScalRA     execPenalty)
d709 1
a709 1
      InScalRA     obj2AuxCost)
@


1.20
log
@Continued double precision.
@
text
@d19 2
a20 2
#include <RealSInArg.h>
#include <RealSOutArg.h>
d138 1
a138 1
      RealSOutArg  execPenalty)
d377 1
a377 1
      RealSOutArg  obj2AuxCost)
d550 1
a550 1
      RealSInArg   execPenalty)
d709 1
a709 1
      RealSInArg   obj2AuxCost)
@


1.19
log
@Continued double precision.
@
text
@d19 2
d138 1
a138 1
      float *      execPenalty)
d377 1
a377 1
      float *      obj2AuxCost)
d470 1
a470 1
      (* yield)[t] = fracToPercent (theYieldRate[t]);
d550 1
a550 1
      float        execPenalty)
d562 1
a562 1
      theCall.myOperation ()->setExecPenalty (doubleFromFloat (execPenalty));
d709 1
a709 1
      float        obj2AuxCost)
d721 1
a721 1
      theCall.myOperation ()->setObj2AuxCost (doubleFromFloat (obj2AuxCost));
d778 1
a778 1
      theYieldRate[t] = percentToFrac (yield[t]);
@


1.18
log
@Continued double precision.
@
text
@d560 1
a560 2
      theCall.myOperation ()->setExecPenalty (
         static_cast <double> (execPenalty));
d719 1
a719 2
      theCall.myOperation ()->setObj2AuxCost (
         static_cast <double> (obj2AuxCost));
@


1.17
log
@Continued double precision.
@
text
@d554 1
a554 1
   theCall.prepNonNegStrDbl (
d560 2
a561 1
      theCall.myOperation ()->setExecPenalty (StrDbl::convFloat (execPenalty));
d714 1
a714 1
   theCall.prepNonNegStrDbl (
d720 2
a721 1
      theCall.myOperation ()->setObj2AuxCost (StrDbl::convFloat (obj2AuxCost));
@


1.16
log
@Fixed a bug in stock reallocation that surfaced as a problem with build-ahead.
@
text
@d554 1
a554 1
   theCall.prepNonNegFloat (
d560 1
a560 1
      theCall.myOperation ()->setExecPenalty (execPenalty);
d713 1
a713 1
   theCall.prepNonNegFloat (
d719 1
a719 1
      theCall.myOperation ()->setObj2AuxCost (obj2AuxCost);
@


1.15
log
@Removed a bad function overload.
@
text
@d184 1
a184 1
WitReturnCode WitRun::witGetOperationExists(
@


1.14
log
@Continued implementation of proportionate routing.
@
text
@d76 1
a76 1
   theOpn = curItrDelCompForGet (WitAT_OPERATION, "operationFrag")->myOpn ();
@


1.13
log
@Added a function to convert from witBoolean to bool.
@
text
@d76 1
a76 2
   curItrDelCompForGet (WitAT_OPERATION, "operationFrag")->
      getOperation (theOpn);
@


1.12
log
@Internal changes.
@
text
@d160 1
a160 1
   apiGetBoolVec (
@


1.11
log
@Continued implementation of two-level lot sizes.
@
text
@d152 1
a152 1
      WitBoolean * * executable)
d160 4
a163 1
   apiGet (executable, "executable", theCall.myOperation ()->executable ());
d187 1
a187 1
      WitBoolean * exist)
d195 1
a195 1
      * exist = witFALSE;
d201 1
a201 1
      * exist = witTRUE;
d414 1
a414 1
      WitBoolean * selForDel)
d429 1
a429 1
      WitBoolean * twoLevelLotSizes)
d729 1
a729 1
      WitBoolean   selForDel)
d744 1
a744 1
      WitBoolean   twoLevelLotSizes)
@


1.10
log
@Continued implementation of two-level lot sizes.
@
text
@d424 18
d627 1
a627 1
   theCall.prepFloatVec ("lotSize2Thresh", lotSize2Thresh);
d733 15
@


1.9
log
@Continued implementation of Single-Source.
@
text
@d239 33
d287 15
d583 36
d631 18
@


1.8
log
@Continued preliminary work on single source.
@
text
@a19 1
#include <DelCompItr.h>
@


1.7
log
@Continued implementation of object iteration.
@
text
@d624 1
a624 1
   WitTVec (float) theYieldRate (myProblem (), 0.0);
@


1.6
log
@Continued implementation of object iteration.
@
text
@d71 1
a71 1
WitReturnCode WitRun::witGetItrOperation (char * * operationName)
d75 1
a75 1
   PROLOG ("witGetItrOperation");
@


1.5
log
@Began implementation of object iteration.
@
text
@d20 1
d23 1
d65 18
@


1.4
log
@Refactoring for constrained stock reallocation.
@
text
@d11 1
a11 1
// Source file: "opnApi.c"
d18 1
d20 3
a22 1
#include <ApiCall.h>
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d74 1
a74 1
   apiGet (appData, "appData", theCall ()->appData ());
d89 1
a89 1
   apiGet (cycleTime34, "cycleTime34", theCall ()->cycleTime34 ());
d106 1
a106 1
   apiGet (hardlbP, softlbP, hardubP, theCall ()->execBounds ());
d121 1
a121 1
   apiGet (execPenalty, "execPenalty", theCall ()->execPenalty ());
d138 1
a138 1
   apiGet (executable, "executable", theCall ()->executable ());
d153 1
a153 1
   apiGet (execVol, "execVol", theCall ()->execVol ());
d195 1
a195 1
   apiGet (fssExecVol, "fssExecVol", theCall ()->fssExecVol ());
d210 1
a210 1
   apiGet (incLotSize, "incLotSize", theCall ()->incLotSize ());
d225 1
a225 1
   apiGet (minLotSize, "minLotSize", theCall ()->minLotSize ());
d240 1
a240 1
   apiGet (mrpExecVol, "mrpExecVol", theCall ()->mrpExecVol ());
d255 4
a258 1
   apiGet (nBomEntries, "nBomEntries", theCall ()->bom ().nElements ());
d273 4
a276 1
   apiGet (nBopEntries, "nBopEntries", theCall ()->bop ().nElements ());
d294 1
a294 1
      theCall ()->obj1ExecCost ());
d309 1
a309 1
   apiGet (obj2AuxCost, "obj2AuxCost", theCall ()->obj2AuxCost ());
d347 1
a347 1
   apiGet (selForDel, "selForDel", theCall ()->selForDel ());
d395 1
a395 1
   apiGet (yieldRate, "yieldRate", theCall ()->yieldRate ());
d442 5
a446 1
   theCall.prepBoundSet (theCall ()->execBounds (), hardLB, softLB, hardUB);
d449 1
a449 1
      theCall ()->execBounds ()->set (hardLB, softLB, hardUB);
d466 1
a466 1
      theCall ()->execPenalty (),
d470 1
a470 1
      theCall ()->setExecPenalty (execPenalty);
d488 1
a488 1
      theCall ()->setExecVol (execVol);
d506 1
a506 1
      theCall ()->setIncLotSize (incLotSize);
d524 1
a524 1
      theCall ()->setMinLotSize (minLotSize);
d553 1
a553 1
      theCall ()->setObj1ExecCost (obj1ExecCost);
d571 1
a571 1
      theCall ()->obj2AuxCost (),
d575 1
a575 1
      theCall ()->setObj2AuxCost (obj2AuxCost);
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d56 1
a56 1
   if (WitUtil::isNullString (operationNameParm))
d372 1
a372 1
      (* yield)[t] = WitUtil::fracToPercent (theYieldRate[t]);
d374 1
a374 1
   WitUtil::portableFree (theYieldRate);
d607 1
a607 1
      theYieldRate[t] = WitUtil::percentToFrac (yield[t]);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.211;
access;
symbols
	sce_5_01_20080919:1.169
	latest_sce_4_20_20060523:1.167.0.2
	sce_4_20_20060523:1.167
	latest_sce4_20_OSL:1.166.0.2
	sce_4_20_OSL:1.166
	sce_410_withVa:1.166
	sce_4_05_20040511:1.146
	sce_4_00_20040201:1.144
	nextGenBranch:1.142.0.2
	nextGenRoot:1.142
	sce_3_30_20030627:1.141
	EndRw-branch:1.105.0.2
	Root-of-EndRw:1.105
	rwToStl:1.103.0.2
	latest_sce_3_10_20010924:1.62.0.2
	sce_3_10_20010924:1.62
	latest_sce_3_00_20010601:1.51.0.2
	sce_3_00_20010601:1.51
	latest_sce_2_31_20010308:1.27.0.2
	sce_2_31_20010308:1.27
	latest_sce_2_31_20001003:1.8.0.2
	sce_2_31_20001003:1.8
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.211
date	2011.09.28.23.50.11;	author rjw;	state Exp;
branches;
next	1.210;

1.210
date	2011.09.24.00.28.37;	author rjw;	state Exp;
branches;
next	1.209;

1.209
date	2011.08.30.20.18.10;	author rjw;	state Exp;
branches;
next	1.208;

1.208
date	2010.09.28.19.25.17;	author rjw;	state Exp;
branches;
next	1.207;

1.207
date	2010.08.03.23.38.23;	author rjw;	state Exp;
branches;
next	1.206;

1.206
date	2010.08.03.23.04.24;	author rjw;	state Exp;
branches;
next	1.205;

1.205
date	2010.07.30.20.20.15;	author rjw;	state Exp;
branches;
next	1.204;

1.204
date	2010.07.30.16.07.52;	author rjw;	state Exp;
branches;
next	1.203;

1.203
date	2010.07.29.21.03.13;	author rjw;	state Exp;
branches;
next	1.202;

1.202
date	2010.07.28.21.40.40;	author rjw;	state Exp;
branches;
next	1.201;

1.201
date	2010.07.28.19.27.47;	author rjw;	state Exp;
branches;
next	1.200;

1.200
date	2010.07.27.23.18.55;	author rjw;	state Exp;
branches;
next	1.199;

1.199
date	2010.07.27.23.07.07;	author rjw;	state Exp;
branches;
next	1.198;

1.198
date	2010.07.27.22.15.44;	author rjw;	state Exp;
branches;
next	1.197;

1.197
date	2010.07.27.20.57.56;	author rjw;	state Exp;
branches;
next	1.196;

1.196
date	2010.07.26.21.47.12;	author rjw;	state Exp;
branches;
next	1.195;

1.195
date	2010.07.26.17.48.44;	author rjw;	state Exp;
branches;
next	1.194;

1.194
date	2010.07.22.21.55.32;	author rjw;	state Exp;
branches;
next	1.193;

1.193
date	2010.07.16.22.37.44;	author rjw;	state Exp;
branches;
next	1.192;

1.192
date	2010.07.16.22.26.42;	author rjw;	state Exp;
branches;
next	1.191;

1.191
date	2010.07.14.18.45.10;	author rjw;	state Exp;
branches;
next	1.190;

1.190
date	2010.07.13.17.41.30;	author rjw;	state Exp;
branches;
next	1.189;

1.189
date	2010.07.02.23.25.39;	author rjw;	state Exp;
branches;
next	1.188;

1.188
date	2010.07.02.18.53.11;	author rjw;	state Exp;
branches;
next	1.187;

1.187
date	2010.07.01.22.41.21;	author rjw;	state Exp;
branches;
next	1.186;

1.186
date	2010.06.29.23.25.15;	author rjw;	state Exp;
branches;
next	1.185;

1.185
date	2010.06.29.22.32.32;	author rjw;	state Exp;
branches;
next	1.184;

1.184
date	2010.06.29.19.56.42;	author rjw;	state Exp;
branches;
next	1.183;

1.183
date	2010.06.25.19.44.13;	author rjw;	state Exp;
branches;
next	1.182;

1.182
date	2010.06.25.15.42.52;	author rjw;	state Exp;
branches;
next	1.181;

1.181
date	2010.06.24.23.37.33;	author rjw;	state Exp;
branches;
next	1.180;

1.180
date	2010.06.24.18.19.58;	author rjw;	state Exp;
branches;
next	1.179;

1.179
date	2010.06.24.17.48.41;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2010.06.23.18.55.12;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2010.06.21.17.36.30;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2010.06.18.23.11.15;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2010.06.18.20.42.53;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2010.06.18.20.04.12;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2010.06.17.18.38.44;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2010.06.17.17.46.26;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2010.06.14.21.15.14;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2010.03.16.22.42.28;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2007.08.01.21.28.05;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2006.09.25.21.11.58;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2006.05.02.17.34.12;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2005.03.28.20.14.38;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2005.03.02.23.56.52;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2005.03.02.23.17.53;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2005.01.27.23.13.45;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2005.01.27.21.32.52;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2005.01.21.23.01.51;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2005.01.19.23.50.58;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2005.01.18.22.45.42;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2005.01.15.00.20.08;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2005.01.11.21.07.58;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2005.01.10.22.34.49;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2004.12.28.22.34.27;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2004.12.28.19.21.19;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2004.12.22.23.36.28;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2004.12.22.22.27.10;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2004.12.21.22.13.49;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2004.12.13.23.35.48;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2004.12.09.20.13.38;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2004.12.06.22.38.16;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2004.11.23.20.50.07;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2004.04.21.19.25.25;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2004.03.10.22.53.21;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2003.11.11.18.29.15;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2003.07.10.22.58.17;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2003.07.03.19.05.02;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2003.05.06.20.22.44;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2003.04.29.19.55.32;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2003.04.18.19.55.49;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2003.04.17.23.34.21;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2003.04.15.20.50.14;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2003.04.14.22.00.36;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2003.04.11.19.08.30;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2003.04.01.20.34.31;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2003.03.21.23.36.55;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2003.03.21.21.35.32;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2003.03.19.16.48.27;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2003.03.06.20.28.22;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2003.03.03.21.40.09;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2003.03.03.21.07.33;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2003.02.28.20.47.39;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2003.02.27.19.20.23;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2003.02.27.17.21.26;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2003.02.25.22.17.10;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2003.02.24.23.44.33;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2003.02.21.18.56.27;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2003.02.19.21.47.34;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2003.02.18.23.19.18;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2003.02.18.20.11.01;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2003.02.16.23.58.12;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2003.02.14.20.13.01;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2003.02.11.18.21.20;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2003.02.10.20.53.53;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2003.02.07.23.29.12;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2003.01.31.21.28.58;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2003.01.29.19.16.49;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2003.01.23.20.47.20;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2003.01.02.23.40.50;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.02.22.18.48;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2002.12.17.21.32.51;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2002.11.26.23.28.50;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2002.11.21.22.53.58;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2002.11.15.20.27.12;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2002.10.30.23.47.31;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2002.09.26.19.05.31;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2002.09.11.18.53.17;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2002.07.25.17.43.54;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2002.07.23.15.18.31;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2002.07.22.19.33.58;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2002.07.15.19.34.02;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2002.07.02.21.53.08;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2002.07.02.19.20.59;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2002.06.17.17.29.27;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2002.05.28.19.44.58;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2002.05.24.23.00.07;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2002.05.21.19.10.27;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2002.05.17.21.45.04;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2002.05.16.23.32.09;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2002.05.15.20.46.12;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2002.05.13.21.31.41;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2002.05.07.20.15.04;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2002.05.02.20.53.16;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2002.04.22.14.32.13;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2002.04.18.14.02.44;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2002.04.15.21.21.38;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2002.04.12.21.02.04;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2002.04.11.15.36.30;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2002.04.05.20.43.58;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2002.03.29.23.47.11;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2002.03.26.15.10.32;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2002.03.22.21.23.23;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2002.03.15.23.17.31;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2002.03.14.20.04.03;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2002.03.07.23.24.30;	author bobw;	state Exp;
branches;
next	1.72;

1.72
date	2002.02.07.16.57.29;	author bobw;	state Exp;
branches;
next	1.71;

1.71
date	2002.01.19.01.49.05;	author bobw;	state Exp;
branches;
next	1.70;

1.70
date	2002.01.14.23.56.08;	author bobw;	state Exp;
branches;
next	1.69;

1.69
date	2002.01.10.22.06.58;	author bobw;	state Exp;
branches;
next	1.68;

1.68
date	2001.12.27.23.15.40;	author bobw;	state Exp;
branches;
next	1.67;

1.67
date	2001.12.17.16.25.42;	author bobw;	state Exp;
branches;
next	1.66;

1.66
date	2001.10.17.16.12.47;	author bobw;	state Exp;
branches;
next	1.65;

1.65
date	2001.10.07.23.03.56;	author bobw;	state Exp;
branches;
next	1.64;

1.64
date	2001.10.05.20.53.58;	author bobw;	state Exp;
branches;
next	1.63;

1.63
date	2001.09.28.00.13.00;	author bobw;	state Exp;
branches;
next	1.62;

1.62
date	2001.09.19.18.50.59;	author bobw;	state Exp;
branches;
next	1.61;

1.61
date	2001.09.16.21.42.31;	author bobw;	state Exp;
branches;
next	1.60;

1.60
date	2001.09.04.15.44.39;	author bobw;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.28.20.30.27;	author bobw;	state Exp;
branches;
next	1.58;

1.58
date	2001.08.24.22.03.23;	author bobw;	state Exp;
branches;
next	1.57;

1.57
date	2001.07.25.16.08.20;	author bobw;	state Exp;
branches;
next	1.56;

1.56
date	2001.07.17.20.49.20;	author bobw;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.12.17.57.02;	author bobw;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.06.16.13.39;	author bobw;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.03.22.50.42;	author bobw;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.11.19.29.12;	author bobw;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.17.15.11.17;	author bobw;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.10.22.31.14;	author bobw;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.10.17.58.19;	author bobw;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.08.21.35.45;	author bobw;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.03.18.50.36;	author bobw;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.03.15.28.39;	author bobw;	state Exp;
branches;
next	1.45;

1.45
date	2001.04.30.21.29.42;	author bobw;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.25.20.54.37;	author bobw;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.24.23.09.58;	author bobw;	state Exp;
branches;
next	1.42;

1.42
date	2001.04.10.21.59.35;	author bobw;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.06.23.23.53;	author bobw;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.06.19.22.11;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.03.19.23.06;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.30.18.54.48;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.26.20.28.08;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.23.19.43.25;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.22.14.53.59;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.21.21.55.48;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.20.21.04.00;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.16.00.22.58;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.13.22.12.06;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.12.19.48.08;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.08.21.08.27;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.08.16.37.07;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.09.22.55.48;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.06.15.46.37;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.01.16.24.45;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.31.23.17.46;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.30.23.34.38;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.29.19.26.11;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.26.21.46.03;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.24.20.05.57;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.20.00.44.22;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.15.19.01.52;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.11.16.35.11;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.04.22.27.54;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.03.15.56.50;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.28.22.13.39;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.22.16.18.27;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.15.23.45.59;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.13.19.57.26;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.04.22.07.39;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.21.20.03.28;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.14.20.27.32;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.08.21.56.14;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.24.19.55.27;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.19.22.35.35;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.01.00.35.43;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.31.19.25.08;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.55;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches;
next	;


desc
@@


1.211
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Selector.C"
//
// Contains the implementation of class Selector.
//------------------------------------------------------------------------------

#include <Selector.h>
#include <SelPt.h>
#include <AltPt.h>
#include <ReqPt.h>
#include <ReqPtMgr.h>
#include <RtMgr.h>
#include <SglSrcMgr.h>
#include <MrMgr.h>
#include <MrCoord.h>
#include <PrCoord.h>
#include <PenExMgr.h>
#include <BaMgr.h>
#include <MeMgr.h>
#include <SsrMgr.h>
#include <PrMgr.h>
#include <Splitter.h>
#include <HeurAtor.h>
#include <Mapping.h>
#include <FixedPer.h>
#include <GlobalComp.h>
#include <Material.h>
#include <BopEntry.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class Selector.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Inlines.
//------------------------------------------------------------------------------

inline WitReqPt * WitSelector::myReqPt (WitPart * thePart, WitPeriod thePer)
   {
   return myReqPtMgr_->myReqPt (thePart, thePer);
   }

//------------------------------------------------------------------------------
// Non-inlines.
//------------------------------------------------------------------------------

WitSelector::WitSelector (WitHeurAtor * theHeurAtor):

      WitProbAssoc       (theHeurAtor),
      myHeurAtor_        (theHeurAtor),
      myRtMgr_           (NULL),
      myMrMgr_           (NULL),
      myPrMgr_           (NULL),
      myPenExMgr_        (NULL),
      mySglSrcMgr_       (NULL),
      myReqPtMgr_        (NULL),
      mySplitter_        (NULL),
      myBaMgr_           (NULL),
      myMeMgr_           (NULL),
      mySsrMgr_          (NULL),
      mySelMgrs_         (),
      pendingAlts_       (myProblem ()),
      altCounts_         (),
      curResAlt_         (false),
      failResAlt_        (false),
      lastConsResAltPer_ (* new WitMapping <WitMaterial, WitPeriod>),
      nonNegLCRAPMats_   (myProblem ()),
      multiRoute_        (false),
      penExec_           (false),
      tbprMode_          (false),
      nAlts_             (0),
      myFixedPer_        (myProblem ())
   {
   WitPeriod thePer;

   if (DEVELOPMENT)
      myMsgFac () ("multiSelMsg");

   lastConsResAltPer_.allocate (myProblem (), -1);

   if (  WitMrMgr::instNeededFor (myProblem ()) or
         WitPrMgr::instNeededFor (myProblem ()))
      myRtMgr_ = new WitRtMgr (this);

   buildSelMgrs ();

   collectSelMgrs ();

   myReqPtMgr_ = new WitReqPtMgr (myProblem ());

   if (myGlobalComp ()->multiRoute ())
      if (myGlobalComp ()->penExec ())
         if (WitPrMgr::instNeededFor (myProblem ()))
            if (myGlobalComp ()->tieBreakPropRt ())
               tbprMode_ = true;

   if (multiRoute_)
      penExec_ = myGlobalComp ()->penExec ();

   if (penExec_)
      myPenExMgr_ = new WitPenExMgr (this);

   if (selSplitNeeded ())
      mySplitter_ = new WitSplitter (this);

   if (multiRoute_)
      if (WitSglSrcMgr::sglSrcReq (myProblem ()))
         mySglSrcMgr_ = new WitSglSrcMgr (this);

   if (myGlobalComp ()->selectionRecovery ())
      myMsgFac () ("selectionRecoveryMsg");

   if (selPrintLevelAt (3))
      printInit ();

   forEachPeriod (thePer, myProblem ())
      myFixedPer_[thePer] = new WitFixedPer (thePer);
   }

//------------------------------------------------------------------------------

WitSelector::~WitSelector ()
   {
   WitPeriod thePer;

   if (selPrintLevelAt (1))
      if (not selSplit ())
         countAlts ();

   delete & lastConsResAltPer_;
   delete   mySplitter_;
   delete   myReqPtMgr_;
   delete   mySglSrcMgr_;

   if (penExec_)
      delete myPenExMgr_;

   mySelMgrs_.clear ();

   delete mySsrMgr_;
   delete myMeMgr_;
   delete myBaMgr_;
   delete myPrMgr_;
   delete myMrMgr_;
   delete myRtMgr_;

   forEachPeriod (thePer, myProblem ())
      delete myFixedPer_[thePer];
   }

//------------------------------------------------------------------------------

WitPeriod WitSelector::modelessExpPer (WitPart * thePart, WitPeriod fillPer)
   {
   return
      buildAhead ()?
         myBaMgr ()->selExpPer (thePart, fillPer):
         thePart->explosionPeriod       (fillPer);
   }

//------------------------------------------------------------------------------

WitPeriod WitSelector::modelessExecPer (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer)
   {
   return
      multiExec ()?
         myMeMgr ()->selExecPer   (theBopEnt, expPer):
         theBopEnt->expExecPeriod ()         [expPer];
   }

//------------------------------------------------------------------------------

bool WitSelector::instNeededFor (WitHeurAtor * theHeurAtor)
   {
   WitProblem * theProblem;

   theProblem = theHeurAtor->myProblem ();

   if (WitPrMgr::instNeededFor (theProblem))
      return true;

   return
          WitMrMgr::instNeededFor (theProblem)
      or  WitBaMgr::instNeededFor (theProblem)
      or  WitMeMgr::instNeededFor (theProblem)
      or WitSsrMgr::instNeededFor (theHeurAtor);
   }

//------------------------------------------------------------------------------

void WitSelector::commitMaxQty (double & netQty)
   {
   bool restShortOnly;

   if (selSplit ())
      {
      mySplitter ()->commitMaxQty (netQty);

      return;
      }

   while (true)
      {
      prepCmqSel ();

      myHeurAtor_->commitMaxQtySel (netQty);

      if (penExec_)
         {
         restShortOnly = myPenExMgr ()->failRestShortOnly ();

         myPenExMgr ()->updatePsSup ();

         if (restShortOnly)
            continue;
         }

      alterSelections ();

      if (not failResAlt_)
         return;
      }
   }

//------------------------------------------------------------------------------

void WitSelector::printCommitMaxQtySel ()
   {
   fprintf (msgFile (),
      "\n"
      "Commit Max Qty Selected: Part %s, Period %d\n",
      myHeurAtor_->topPart ()->partName ().myCstring (),
      myHeurAtor_->topPer ());
   }

//------------------------------------------------------------------------------

void WitSelector::preCommitSS ()
   {
   mySplitter ()->preCommit ();
   }

//------------------------------------------------------------------------------

void WitSelector::postCommit ()
   {
   WitMaterial * theMat;

   while (nonNegLCRAPMats_.pop (theMat))
      lastConsResAltPer_ (theMat) = -1;
   }

//------------------------------------------------------------------------------

void WitSelector::postTempCommit (bool success)
   {
   if (not success)
      failResAlt_ = curResAlt_;

   curResAlt_ = false;

   myReqPtMgr_->reset ();

   if (selectiveSR ())
      mySsrMgr ()->postTempCommit ();

   if (penExec_)
      myPenExMgr ()->postTempCommit (success);

   if (selSplit ())
      mySplitter ()->postTempCommit (success);
   }

//------------------------------------------------------------------------------

void WitSelector::alterSelections ()
   {
   WitAltPt * theAltPt;

   stronglyAssert (not selSplit ());

   if (pendingAlts_.isEmpty ())
      return;

   if (selPrintLevelAt (1))
      printPreAlt ();

   while (getPendingAlt (theAltPt))
      alterSelection (theAltPt);
   }

//------------------------------------------------------------------------------

void WitSelector::alterSelSS ()
   {
   WitAltPt * theAltPt;

   stronglyAssert (selSplit ());

   if (getPendingAlt (theAltPt))
      {
      witAssert (pendingAlts_.isEmpty ());

      alterSelection (theAltPt);
      }
   }

//------------------------------------------------------------------------------

void WitSelector::alterSelection (WitAltPt * theAltPt)
   {
   theAltPt->alterSelection ();

   if (selPrintLevelAt (1))
      nAlts_ ++;

   if (selPrintLevelAt (2))
      theAltPt->printAlteration ();

   if (myGlobalComp ()->selectionRecovery ())
      theAltPt->storeRecoveryPt ();
   }

//------------------------------------------------------------------------------

void WitSelector::recFillByCons (WitPart * thePart, WitPeriod fillPer)
   {
   WitMaterial * theMat;

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return;

   stronglyAssert (fillPer > lastConsResAltPer_ (theMat));

   if (not myReqPt (thePart, fillPer)->hasResAlt ())
      return;

   if (lastConsResAltPer_ (theMat) == -1)
      nonNegLCRAPMats_.push (theMat);

   lastConsResAltPer_ (theMat) = fillPer;
   }

//------------------------------------------------------------------------------

void WitSelector::recFillNetRec (WitPart * thePart, WitPeriod fillPer)
   {
   WitMaterial * theMat;
   WitReqPt *    fillReqPt;
   WitPeriod     srcPer;
   WitPeriod     stockPer;

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return;

   if (fillPer == 0)
      return;

   srcPer = lastConsResAltPer_ (theMat);

   if (srcPer < 0)
      return;

   fillReqPt = myReqPt (thePart, fillPer);

   if (fillReqPt->hasResAlt ())
      return;

   stronglyAssert (srcPer < fillPer);

   if (theMat->mandEC () != false)
      for (stockPer = srcPer; stockPer < fillPer; stockPer ++)
         if (theMat->mandEC ()[stockPer])
            return;

   fillReqPt->setSource (myReqPt (thePart, srcPer));
   }

//------------------------------------------------------------------------------

void WitSelector::rollReq (
      WitMaterial * theMat,
      WitPeriod     fromPer,
      WitPeriod     toPer,
      double        rollVol)
   {
   WitReqPt * toReqPt;

   if (penExec_)
      myPenExMgr ()->placeReqs (theMat, fromPer, theMat, toPer);

   toReqPt = myReqPt (theMat, toPer);

   if (not toReqPt->hasResAlt ())
      if (myHeurAtor_->selectiveSR (theMat))
         mySsrMgr ()->recordSR (theMat, toPer, rollVol);
   }

//------------------------------------------------------------------------------

void WitSelector::placeReqs (
      WitBopEntry *  theBopEnt,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod      fillPer,
      bool           forNetting)
   {  
   WitPart *  consPart;
   WitPeriod  consPer;
   WitReqPt * theReqPt;

   consPart = theConsEnt->myPart ();
   consPer  = theConsEnt->impactPeriod ()[execPer];

   if (penExec_)
      myPenExMgr ()->placeReqs (
         theBopEnt->myPart (),
         fillPer,
         consPart,
         consPer);

   theReqPt = myReqPt (consPart, consPer);

   innerPlaceReqs (
      theBopEnt,
      theConsEnt,
      execPer,
      fillPer, 
      theReqPt,
      forNetting);
   }

//------------------------------------------------------------------------------

void WitSelector::recExecBoundShortage (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      WitPeriod     fillPer)
   {
   WitPart *   prodPart;
   WitReqPt *  theReqPt;
   WitSelMgr * theSelMgr;
   WitAltPt *  theAltPt;

   prodPart = theBopEnt->myPart ();

   theReqPt = myReqPt (prodPart, fillPer);

   forEachEl (theSelMgr, mySelMgrs_)
      {
      if (not theSelMgr->validForExecBounds ())
         continue;

      theAltPt = theSelMgr->myAltPtFor (theBopEnt, NULL, execPer, fillPer);

      if (theAltPt == NULL)
         continue;

      if (selSplit ())
         if (not theAltPt->hasResAlt ())
            continue;

      if (sglSrc ())
         if (theAltPt->mySelPt ()->sglSrcMode ())
            continue;

      theReqPt->putDirectAlt (theAltPt);
      }

   recFundShortage (prodPart, fillPer);
   }

//------------------------------------------------------------------------------

void WitSelector::recLTBoundShortage (WitPart * thePart, WitPeriod fillPer)
   {
   WitReqPt *  theReqPt;
   WitSelMgr * theSelMgr;
   WitAltPt *  theAltPt;

   theReqPt = myReqPt (thePart, fillPer);

   forEachEl (theSelMgr, mySelMgrs_)
      {
      if (not theSelMgr->validForLTBounds ())
         continue;

      theAltPt = theSelMgr->myAltPtFor (thePart, fillPer);

      if (theAltPt == NULL)
         continue;

      if (selSplit ())
         if (not theAltPt->hasResAlt ())
            continue;

      if (sglSrc ())
         if (theAltPt->mySelPt ()->sglSrcMode ())
            continue;

      theReqPt->putDirectAlt (theAltPt);
      }

   recFundShortage (thePart, fillPer);
   }

//------------------------------------------------------------------------------

void WitSelector::recFundShortage (WitPart * thePart, WitPeriod fillPer)
   {
   WitReqPt * theReqPt;
   WitAltPt * theAltPt;

   if (penExec_)
      myPenExMgr ()->recordFundShortage ();

   recShortage ();

   theReqPt   = myReqPt (thePart, fillPer);

   curResAlt_ = theReqPt->hasResAlt ();

   while (theReqPt != NULL)
      {
      while (theReqPt->getDirectAlt (theAltPt))
         if (not theAltPt->pending ())
            {  
            pendingAlts_.push (theAltPt);

            theAltPt->setPending (true);
            }

      theReqPt = theReqPt->source ();
      }

   if (pendingAlts_.isEmpty ())
      stronglyAssert (not curResAlt_);
   }

//------------------------------------------------------------------------------

void WitSelector::recShortage ()
   {
   WitAltPt * theAltPt;

   while (getPendingAlt (theAltPt));

   curResAlt_ = false;
   }

//------------------------------------------------------------------------------

void WitSelector::recCommitVol (double commitVol)
   {
   myPenExMgr ()->recCommitVol (commitVol);
   }

//------------------------------------------------------------------------------

void WitSelector::prepCmqSel ()
   {
   failResAlt_ = false;

   if (penExec_)
      myPenExMgr ()->modifyRouting ();
   }

//------------------------------------------------------------------------------

void WitSelector::recordFlowSS (WitSelPt * theSelPt, double incFlowVol)
   {
   if (myHeurAtor_->tempCommActive ())
      mySplitter ()->recordFlow (theSelPt, incFlowVol);
   }

//------------------------------------------------------------------------------

bool WitSelector::splitCommActive ()
   {
   return mySplitter ()->splitCommActive ();
   }

//------------------------------------------------------------------------------

void WitSelector::recoverInitState ()
   {
   witAssert (myGlobalComp ()->selectionRecovery ());

   if (selPrintLevelAt (3))
      fprintf (msgFile (),
         "\n"
         "Recovering the initial selection configuration:\n\n");

   if (multiRoute_)
      myMrMgr  ()->recoverInitState ();

   if (buildAhead ())
      myBaMgr  ()->recoverInitState ();

   if (multiExec ())
      myMeMgr  ()->recoverInitState ();

   if (selectiveSR ())
      mySsrMgr ()->recoverInitState ();

   if (propRtg ())
      myPrMgr  ()->recoverInitState ();
   }

//------------------------------------------------------------------------------

void WitSelector::buildSelMgrs ()
   {
   if (WitMrMgr::instNeededFor (myProblem ()))
      {
      myMrMgr_    = new WitMrMgr (this);

      multiRoute_ = true;
      }

   if (WitBaMgr::instNeededFor (myProblem ()))
      myBaMgr_ = new WitBaMgr (this);

   if (WitMeMgr::instNeededFor (myProblem ()))
      myMeMgr_ = new WitMeMgr (this);

   if (WitSsrMgr::instNeededFor (myHeurAtor_))
      mySsrMgr_ = new WitSsrMgr (this);

   if (WitPrMgr::instNeededFor (myProblem ()))
      myPrMgr_ = new WitPrMgr (this);
   }

//------------------------------------------------------------------------------

void WitSelector::collectSelMgrs ()
   {
   collect (mySsrMgr_);
   collect (myBaMgr_);

   if (multiRoute_)
      collect (myMrMgr ()->mySelMgrForProd ());

   if (propRtg ())
      collect (myPrMgr ()->mySelMgrForProd ());

   collect (myMeMgr_);

   if (multiRoute_)
      collect (myMrMgr ()->mySelMgrForCons ());

   if (propRtg ())
      collect (myPrMgr ()->mySelMgrForCons ());
   }

//------------------------------------------------------------------------------

void WitSelector::collect (WitSelMgr * theSelMgr)
   {
   if (theSelMgr == NULL)
      return;

   theSelMgr->setIndex ();

   mySelMgrs_.append (theSelMgr);
   }

//------------------------------------------------------------------------------

bool WitSelector::selSplitNeeded ()
   {
   WitSelMgr * theSelMgr;

   forEachEl (theSelMgr, mySelMgrs_)
      if (theSelMgr->selSplitNeeded ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitSelector::innerPlaceReqs (
      WitBopEntry *  theBopEnt,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod      fillPer,
      WitReqPt *     theReqPt,
      bool           forNetting)
   {
   bool        priorAlt;
   WitSelMgr * lbSelMgr;
   WitSelMgr * theSelMgr;
   WitReqPt *  theSource;
   WitAltPt *  theAltPt;

   priorAlt = theReqPt->hasAlt ();

   if (selSplit ())
      lbSelMgr = mySplitter ()->lowestBddSelMgr ();

   if ((not selSplit ()) or (lbSelMgr == NULL))
      {
      theSource = myReqPt (theBopEnt->myPart (), fillPer);

      if (theSource->hasResAlt ())
         priorAlt = false;

      if (not priorAlt)
         theReqPt->setSource (theSource);
      }

   forEachEl (theSelMgr, mySelMgrs_)
      {
      if (selSplit ())
         if (lbSelMgr != NULL)
            if (not theSelMgr->isLowerThan (lbSelMgr))
               continue;

      if (forNetting)
         if (not theSelMgr->validForNetting ())
            continue;

      theAltPt = 
         theSelMgr->myAltPtFor (theBopEnt, theConsEnt, execPer, fillPer);

      if (theAltPt == NULL)
         continue;

      if (selSplit ())
         if (not theAltPt->hasResAlt ())
            continue;

      if (sglSrc ())
         if (theAltPt->mySelPt ()->sglSrcMode ())
            continue;

      if (theAltPt->hasResAlt ())
         priorAlt = false;

      if (not priorAlt)
         theReqPt->putDirectAlt (theAltPt);
      }

   getResAltFromNet (theConsEnt->myBomEnt (), execPer, theReqPt);
   }

//------------------------------------------------------------------------------

void WitSelector::getResAltFromNet (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      WitReqPt *    theReqPt)
   {
   WitSubEntry * theSub;
   bool          resFound;

   if (theReqPt->hasResAlt ())
      return;

   if (not theBomEnt->hasSubsInEffect ()[execPer])
      return;

   resFound = copyResAlt (theBomEnt, execPer, theReqPt);

   if (resFound)
      return;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->netAllowed ())
         if (theSub->inEffect (execPer))
            {
            resFound = copyResAlt (theSub, execPer, theReqPt);

            if (resFound)
               return;
            }
   }

//------------------------------------------------------------------------------

bool WitSelector::copyResAlt (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitReqPt *     theReqPt)
   {
   WitPart *  consPart;
   WitPeriod  consPer;
   WitReqPt * consReqPt;

   if (theConsEnt->effConsRate ()[execPer] < FLOAT_EPSILON)
      return false;

   consPart  = theConsEnt->myPart ();
   consPer   = theConsEnt->impactPeriod ()[execPer];

   consReqPt = myReqPt (consPart, consPer);

   if (not consReqPt->hasResAlt ())
      return false;

   theReqPt->copyStateOf (consReqPt);

   return true;
   }

//------------------------------------------------------------------------------

bool WitSelector::getPendingAlt (WitAltPt * & theAltPt)
   {
   if (pendingAlts_.pop (theAltPt))
      {
      theAltPt->setPending (false);

      return true;
      }
   else
      return false;
   }

//------------------------------------------------------------------------------

void WitSelector::printPreAlt ()
   {
   if (pendingAlts_.isEmpty ())
      return;

   if (selPrintLevelAt (2))
      fprintf (msgFile (),
         "\n"
         "------------------------------------\n"
         "Altering the Selection Configuration\n"
         "------------------------------------\n\n"
         "Alteration potentially resolves shortage? %s\n",
         myMsgFac ().boolText (failResAlt_));

   altCounts_.append (new int (pendingAlts_.nElements ()));
   }

//------------------------------------------------------------------------------

void WitSelector::printInit ()
   {
   if (multiRoute_)
      myMrMgr    ()->print ();

   if (buildAhead ())
      myBaMgr    ()->print ();
   
   if (multiExec ())
      myMeMgr    ()->print ();

   if (propRtg ())
      myPrMgr    ()->print ();

   if (penExec_)
      myPenExMgr ()->print ();
   }

//------------------------------------------------------------------------------

void WitSelector::countAlts ()
   {
   int    maxAltCount;
   int *  altCountPtr;
   int    altCount;
   int    totAlts;
   int    totBatches;
   double altsPerBatch;

   WitVector <int> nBatches;

   maxAltCount = 0;

   forEachEl (altCountPtr, altCounts_)
      setToMax (maxAltCount, * altCountPtr);

   nBatches.resize (maxAltCount + 1, 0);
   
   totAlts    = 0;
   totBatches = 0;

   while (not altCounts_.isEmpty ())
      {
      altCountPtr = altCounts_.get ();

      nBatches[* altCountPtr] ++;

      totAlts    += * altCountPtr;
      totBatches ++;

      delete altCountPtr;
      }
   
   fprintf (msgFile (), "\n");

   for (altCount = 0; altCount <= maxAltCount; altCount ++)
      if (nBatches[altCount] > 0)
         fprintf (msgFile (),
            "# Alts: %3d  # Batches: %7d\n",
            altCount,
            nBatches[altCount]);

   altsPerBatch = 
      (totBatches > 0)?
         static_cast <double> (totAlts) / static_cast <double> (totBatches):
         0;

   fprintf (msgFile (),
      "\n"
      "# Alterations:    %7d\n"
      "# Batches:        %7d\n"
      "# Alts Per Batch: %10.2f\n\n",
      totAlts,
      totBatches,
      altsPerBatch);
   }
@


1.210
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.209
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d49 3
a51 3
{
return myReqPtMgr_->myReqPt (thePart, thePer);
}
d59 70
a128 70
WitProbAssoc       (theHeurAtor),
myHeurAtor_        (theHeurAtor),
myRtMgr_           (NULL),
myMrMgr_           (NULL),
myPrMgr_           (NULL),
myPenExMgr_        (NULL),
mySglSrcMgr_       (NULL),
myReqPtMgr_        (NULL),
mySplitter_        (NULL),
myBaMgr_           (NULL),
myMeMgr_           (NULL),
mySsrMgr_          (NULL),
mySelMgrs_         (),
pendingAlts_       (myProblem ()),
altCounts_         (),
curResAlt_         (false),
failResAlt_        (false),
lastConsResAltPer_ (* new WitMapping <WitMaterial, WitPeriod>),
nonNegLCRAPMats_   (myProblem ()),
multiRoute_        (false),
penExec_           (false),
tbprMode_          (false),
nAlts_             (0),
myFixedPer_        (myProblem ())
{
WitPeriod thePer;

if (DEVELOPMENT)
myMsgFac () ("multiSelMsg");

lastConsResAltPer_.allocate (myProblem (), -1);

if (  WitMrMgr::instNeededFor (myProblem ()) or
WitPrMgr::instNeededFor (myProblem ()))
myRtMgr_ = new WitRtMgr (this);

buildSelMgrs ();

collectSelMgrs ();

myReqPtMgr_ = new WitReqPtMgr (myProblem ());

if (myGlobalComp ()->multiRoute ())
if (myGlobalComp ()->penExec ())
if (WitPrMgr::instNeededFor (myProblem ()))
if (myGlobalComp ()->tieBreakPropRt ())
tbprMode_ = true;

if (multiRoute_)
penExec_ = myGlobalComp ()->penExec ();

if (penExec_)
myPenExMgr_ = new WitPenExMgr (this);

if (selSplitNeeded ())
mySplitter_ = new WitSplitter (this);

if (multiRoute_)
if (WitSglSrcMgr::sglSrcReq (myProblem ()))
mySglSrcMgr_ = new WitSglSrcMgr (this);

if (myGlobalComp ()->selectionRecovery ())
myMsgFac () ("selectionRecoveryMsg");

if (selPrintLevelAt (3))
printInit ();

forEachPeriod (thePer, myProblem ())
myFixedPer_[thePer] = new WitFixedPer (thePer);
}
d133 2
a134 2
{
WitPeriod thePer;
d136 24
a159 24
if (selPrintLevelAt (1))
if (not selSplit ())
countAlts ();

delete & lastConsResAltPer_;
delete   mySplitter_;
delete   myReqPtMgr_;
delete   mySglSrcMgr_;

if (penExec_)
delete myPenExMgr_;

mySelMgrs_.clear ();

delete mySsrMgr_;
delete myMeMgr_;
delete myBaMgr_;
delete myPrMgr_;
delete myMrMgr_;
delete myRtMgr_;

forEachPeriod (thePer, myProblem ())
delete myFixedPer_[thePer];
}
d164 6
a169 6
{
return
buildAhead ()?
myBaMgr ()->selExpPer (thePart, fillPer):
thePart->explosionPeriod       (fillPer);
}
d174 8
a181 8
WitBopEntry * theBopEnt,
WitPeriod     expPer)
{
return
multiExec ()?
myMeMgr ()->selExecPer   (theBopEnt, expPer):
theBopEnt->expExecPeriod ()         [expPer];
}
d186 2
a187 2
{
WitProblem * theProblem;
d189 1
a189 1
theProblem = theHeurAtor->myProblem ();
d191 2
a192 2
if (WitPrMgr::instNeededFor (theProblem))
return true;
d194 6
a199 6
return
WitMrMgr::instNeededFor (theProblem)
or  WitBaMgr::instNeededFor (theProblem)
or  WitMeMgr::instNeededFor (theProblem)
or WitSsrMgr::instNeededFor (theHeurAtor);
}
d204 2
a205 2
{
bool restShortOnly;
d207 3
a209 3
if (selSplit ())
{
mySplitter ()->commitMaxQty (netQty);
d211 2
a212 2
return;
}
d214 3
a216 3
while (true)
{
prepCmqSel ();
d218 1
a218 1
myHeurAtor_->commitMaxQtySel (netQty);
d220 3
a222 3
if (penExec_)
{
restShortOnly = myPenExMgr ()->failRestShortOnly ();
d224 1
a224 1
myPenExMgr ()->updatePsSup ();
d226 3
a228 3
if (restShortOnly)
continue;
}
d230 1
a230 1
alterSelections ();
d232 4
a235 4
if (not failResAlt_)
return;
}
}
d240 7
a246 7
{
fprintf (msgFile (),
"\n"
"Commit Max Qty Selected: Part %s, Period %d\n",
myHeurAtor_->topPart ()->partName ().myCstring (),
myHeurAtor_->topPer ());
}
d251 3
a253 3
{
mySplitter ()->preCommit ();
}
d258 2
a259 2
{
WitMaterial * theMat;
d261 3
a263 3
while (nonNegLCRAPMats_.pop (theMat))
lastConsResAltPer_ (theMat) = -1;
}
d268 3
a270 3
{
if (not success)
failResAlt_ = curResAlt_;
d272 1
a272 1
curResAlt_ = false;
d274 1
a274 1
myReqPtMgr_->reset ();
d276 2
a277 2
if (selectiveSR ())
mySsrMgr ()->postTempCommit ();
d279 2
a280 2
if (penExec_)
myPenExMgr ()->postTempCommit (success);
d282 3
a284 3
if (selSplit ())
mySplitter ()->postTempCommit (success);
}
d289 2
a290 2
{
WitAltPt * theAltPt;
d292 1
a292 1
stronglyAssert (not selSplit ());
d294 2
a295 2
if (pendingAlts_.isEmpty ())
return;
d297 2
a298 2
if (selPrintLevelAt (1))
printPreAlt ();
d300 3
a302 3
while (getPendingAlt (theAltPt))
alterSelection (theAltPt);
}
d307 2
a308 2
{
WitAltPt * theAltPt;
d310 1
a310 1
stronglyAssert (selSplit ());
d312 7
a318 7
if (getPendingAlt (theAltPt))
{
witAssert (pendingAlts_.isEmpty ());

alterSelection (theAltPt);
}
}
d323 2
a324 2
{
theAltPt->alterSelection ();
d326 2
a327 2
if (selPrintLevelAt (1))
nAlts_ ++;
d329 2
a330 2
if (selPrintLevelAt (2))
theAltPt->printAlteration ();
d332 3
a334 3
if (myGlobalComp ()->selectionRecovery ())
theAltPt->storeRecoveryPt ();
}
d339 2
a340 2
{
WitMaterial * theMat;
d342 1
a342 1
theMat = thePart->thisMat ();
d344 2
a345 2
if (theMat == NULL)
return;
d347 1
a347 1
stronglyAssert (fillPer > lastConsResAltPer_ (theMat));
d349 2
a350 2
if (not myReqPt (thePart, fillPer)->hasResAlt ())
return;
d352 2
a353 2
if (lastConsResAltPer_ (theMat) == -1)
nonNegLCRAPMats_.push (theMat);
d355 2
a356 2
lastConsResAltPer_ (theMat) = fillPer;
}
d361 5
a365 5
{
WitMaterial * theMat;
WitReqPt *    fillReqPt;
WitPeriod     srcPer;
WitPeriod     stockPer;
d367 1
a367 1
theMat = thePart->thisMat ();
d369 2
a370 2
if (theMat == NULL)
return;
d372 2
a373 2
if (fillPer == 0)
return;
d375 1
a375 1
srcPer = lastConsResAltPer_ (theMat);
d377 2
a378 2
if (srcPer < 0)
return;
d380 1
a380 1
fillReqPt = myReqPt (thePart, fillPer);
d382 2
a383 2
if (fillReqPt->hasResAlt ())
return;
d385 1
a385 1
stronglyAssert (srcPer < fillPer);
d387 4
a390 4
if (theMat->mandEC () != false)
for (stockPer = srcPer; stockPer < fillPer; stockPer ++)
if (theMat->mandEC ()[stockPer])
return;
d392 2
a393 2
fillReqPt->setSource (myReqPt (thePart, srcPer));
}
d398 16
a413 16
WitMaterial * theMat,
WitPeriod     fromPer,
WitPeriod     toPer,
double        rollVol)
{
WitReqPt * toReqPt;

if (penExec_)
myPenExMgr ()->placeReqs (theMat, fromPer, theMat, toPer);

toReqPt = myReqPt (theMat, toPer);

if (not toReqPt->hasResAlt ())
if (myHeurAtor_->selectiveSR (theMat))
mySsrMgr ()->recordSR (theMat, toPer, rollVol);
}
d418 30
a447 30
WitBopEntry *  theBopEnt,
WitConsEntry * theConsEnt,
WitPeriod      execPer,
WitPeriod      fillPer,
bool           forNetting)
{
WitPart *  consPart;
WitPeriod  consPer;
WitReqPt * theReqPt;

consPart = theConsEnt->myPart ();
consPer  = theConsEnt->impactPeriod ()[execPer];

if (penExec_)
myPenExMgr ()->placeReqs (
theBopEnt->myPart (),
fillPer,
consPart,
consPer);

theReqPt = myReqPt (consPart, consPer);

innerPlaceReqs (
theBopEnt,
theConsEnt,
execPer,
fillPer,
theReqPt,
forNetting);
}
d452 30
a481 30
WitBopEntry * theBopEnt,
WitPeriod     execPer,
WitPeriod     fillPer)
{
WitPart *   prodPart;
WitReqPt *  theReqPt;
WitSelMgr * theSelMgr;
WitAltPt *  theAltPt;

prodPart = theBopEnt->myPart ();

theReqPt = myReqPt (prodPart, fillPer);

forEachEl (theSelMgr, mySelMgrs_)
{
if (not theSelMgr->validForExecBounds ())
continue;

theAltPt = theSelMgr->myAltPtFor (theBopEnt, NULL, execPer, fillPer);

if (theAltPt == NULL)
continue;

if (selSplit ())
if (not theAltPt->hasResAlt ())
continue;

if (sglSrc ())
if (theAltPt->mySelPt ()->sglSrcMode ())
continue;
d483 2
a484 2
theReqPt->putDirectAlt (theAltPt);
}
d486 2
a487 2
recFundShortage (prodPart, fillPer);
}
d492 4
a495 4
{
WitReqPt *  theReqPt;
WitSelMgr * theSelMgr;
WitAltPt *  theAltPt;
d497 1
a497 1
theReqPt = myReqPt (thePart, fillPer);
d499 4
a502 4
forEachEl (theSelMgr, mySelMgrs_)
{
if (not theSelMgr->validForLTBounds ())
continue;
d504 1
a504 1
theAltPt = theSelMgr->myAltPtFor (thePart, fillPer);
d506 2
a507 2
if (theAltPt == NULL)
continue;
d509 3
a511 3
if (selSplit ())
if (not theAltPt->hasResAlt ())
continue;
d513 3
a515 3
if (sglSrc ())
if (theAltPt->mySelPt ()->sglSrcMode ())
continue;
d517 2
a518 2
theReqPt->putDirectAlt (theAltPt);
}
d520 2
a521 2
recFundShortage (thePart, fillPer);
}
d526 3
a528 3
{
WitReqPt * theReqPt;
WitAltPt * theAltPt;
d530 2
a531 2
if (penExec_)
myPenExMgr ()->recordFundShortage ();
d533 1
a533 1
recShortage ();
d535 1
a535 1
theReqPt   = myReqPt (thePart, fillPer);
d537 1
a537 1
curResAlt_ = theReqPt->hasResAlt ();
d539 6
a544 6
while (theReqPt != NULL)
{
while (theReqPt->getDirectAlt (theAltPt))
if (not theAltPt->pending ())
{
pendingAlts_.push (theAltPt);
d546 2
a547 2
theAltPt->setPending (true);
}
d549 2
a550 2
theReqPt = theReqPt->source ();
}
d552 3
a554 3
if (pendingAlts_.isEmpty ())
stronglyAssert (not curResAlt_);
}
d559 2
a560 2
{
WitAltPt * theAltPt;
d562 1
a562 1
while (getPendingAlt (theAltPt));
d564 2
a565 2
curResAlt_ = false;
}
d570 3
a572 3
{
myPenExMgr ()->recCommitVol (commitVol);
}
d577 2
a578 2
{
failResAlt_ = false;
d580 3
a582 3
if (penExec_)
myPenExMgr ()->modifyRouting ();
}
d587 4
a590 4
{
if (myHeurAtor_->tempCommActive ())
mySplitter ()->recordFlow (theSelPt, incFlowVol);
}
d595 3
a597 3
{
return mySplitter ()->splitCommActive ();
}
d602 2
a603 2
{
witAssert (myGlobalComp ()->selectionRecovery ());
d605 4
a608 4
if (selPrintLevelAt (3))
fprintf (msgFile (),
"\n"
"Recovering the initial selection configuration:\n\n");
d610 2
a611 2
if (multiRoute_)
myMrMgr  ()->recoverInitState ();
d613 2
a614 2
if (buildAhead ())
myBaMgr  ()->recoverInitState ();
d616 2
a617 2
if (multiExec ())
myMeMgr  ()->recoverInitState ();
d619 2
a620 2
if (selectiveSR ())
mySsrMgr ()->recoverInitState ();
d622 3
a624 3
if (propRtg ())
myPrMgr  ()->recoverInitState ();
}
d629 20
a648 20
{
if (WitMrMgr::instNeededFor (myProblem ()))
{
myMrMgr_    = new WitMrMgr (this);

multiRoute_ = true;
}

if (WitBaMgr::instNeededFor (myProblem ()))
myBaMgr_ = new WitBaMgr (this);

if (WitMeMgr::instNeededFor (myProblem ()))
myMeMgr_ = new WitMeMgr (this);

if (WitSsrMgr::instNeededFor (myHeurAtor_))
mySsrMgr_ = new WitSsrMgr (this);

if (WitPrMgr::instNeededFor (myProblem ()))
myPrMgr_ = new WitPrMgr (this);
}
d653 3
a655 3
{
collect (mySsrMgr_);
collect (myBaMgr_);
d657 2
a658 2
if (multiRoute_)
collect (myMrMgr ()->mySelMgrForProd ());
d660 2
a661 2
if (propRtg ())
collect (myPrMgr ()->mySelMgrForProd ());
d663 1
a663 1
collect (myMeMgr_);
d665 2
a666 2
if (multiRoute_)
collect (myMrMgr ()->mySelMgrForCons ());
d668 3
a670 3
if (propRtg ())
collect (myPrMgr ()->mySelMgrForCons ());
}
d675 3
a677 3
{
if (theSelMgr == NULL)
return;
d679 1
a679 1
theSelMgr->setIndex ();
d681 2
a682 2
mySelMgrs_.append (theSelMgr);
}
d687 2
a688 2
{
WitSelMgr * theSelMgr;
d690 3
a692 3
forEachEl (theSelMgr, mySelMgrs_)
if (theSelMgr->selSplitNeeded ())
return true;
d694 2
a695 2
return false;
}
d700 60
a759 60
WitBopEntry *  theBopEnt,
WitConsEntry * theConsEnt,
WitPeriod      execPer,
WitPeriod      fillPer,
WitReqPt *     theReqPt,
bool           forNetting)
{
bool        priorAlt;
WitSelMgr * lbSelMgr;
WitSelMgr * theSelMgr;
WitReqPt *  theSource;
WitAltPt *  theAltPt;

priorAlt = theReqPt->hasAlt ();

if (selSplit ())
lbSelMgr = mySplitter ()->lowestBddSelMgr ();

if ((not selSplit ()) or (lbSelMgr == NULL))
{
theSource = myReqPt (theBopEnt->myPart (), fillPer);

if (theSource->hasResAlt ())
priorAlt = false;

if (not priorAlt)
theReqPt->setSource (theSource);
}

forEachEl (theSelMgr, mySelMgrs_)
{
if (selSplit ())
if (lbSelMgr != NULL)
if (not theSelMgr->isLowerThan (lbSelMgr))
continue;

if (forNetting)
if (not theSelMgr->validForNetting ())
continue;

theAltPt =
theSelMgr->myAltPtFor (theBopEnt, theConsEnt, execPer, fillPer);

if (theAltPt == NULL)
continue;

if (selSplit ())
if (not theAltPt->hasResAlt ())
continue;

if (sglSrc ())
if (theAltPt->mySelPt ()->sglSrcMode ())
continue;

if (theAltPt->hasResAlt ())
priorAlt = false;

if (not priorAlt)
theReqPt->putDirectAlt (theAltPt);
}
d761 2
a762 2
getResAltFromNet (theConsEnt->myBomEnt (), execPer, theReqPt);
}
d767 28
a794 28
WitBomEntry * theBomEnt,
WitPeriod     execPer,
WitReqPt *    theReqPt)
{
WitSubEntry * theSub;
bool          resFound;

if (theReqPt->hasResAlt ())
return;

if (not theBomEnt->hasSubsInEffect ()[execPer])
return;

resFound = copyResAlt (theBomEnt, execPer, theReqPt);

if (resFound)
return;

forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->netAllowed ())
if (theSub->inEffect (execPer))
{
resFound = copyResAlt (theSub, execPer, theReqPt);

if (resFound)
return;
}
}
d799 7
a805 7
WitConsEntry * theConsEnt,
WitPeriod      execPer,
WitReqPt *     theReqPt)
{
WitPart *  consPart;
WitPeriod  consPer;
WitReqPt * consReqPt;
d807 2
a808 2
if (theConsEnt->effConsRate ()[execPer] < FLOAT_EPSILON)
return false;
d810 2
a811 2
consPart  = theConsEnt->myPart ();
consPer   = theConsEnt->impactPeriod ()[execPer];
d813 1
a813 1
consReqPt = myReqPt (consPart, consPer);
d815 2
a816 2
if (not consReqPt->hasResAlt ())
return false;
d818 1
a818 1
theReqPt->copyStateOf (consReqPt);
d820 2
a821 2
return true;
}
d826 10
a835 10
{
if (pendingAlts_.pop (theAltPt))
{
theAltPt->setPending (false);

return true;
}
else
return false;
}
d840 12
a851 12
{
if (pendingAlts_.isEmpty ())
return;

if (selPrintLevelAt (2))
fprintf (msgFile (),
"\n"
"------------------------------------\n"
"Altering the Selection Configuration\n"
"------------------------------------\n\n"
"Alteration potentially resolves shortage? %s\n",
myMsgFac ().boolText (failResAlt_));
d853 2
a854 2
altCounts_.append (new int (pendingAlts_.nElements ()));
}
d859 16
a874 16
{
if (multiRoute_)
myMrMgr    ()->print ();

if (buildAhead ())
myBaMgr    ()->print ();

if (multiExec ())
myMeMgr    ()->print ();

if (propRtg ())
myPrMgr    ()->print ();

if (penExec_)
myPenExMgr ()->print ();
}
d879 55
a933 55
{
int    maxAltCount;
int *  altCountPtr;
int    altCount;
int    totAlts;
int    totBatches;
double altsPerBatch;

WitVector <int> nBatches;

maxAltCount = 0;

forEachEl (altCountPtr, altCounts_)
setToMax (maxAltCount, * altCountPtr);

nBatches.resize (maxAltCount + 1, 0);

totAlts    = 0;
totBatches = 0;

while (not altCounts_.isEmpty ())
{
altCountPtr = altCounts_.get ();

nBatches[* altCountPtr] ++;

totAlts    += * altCountPtr;
totBatches ++;

delete altCountPtr;
}

fprintf (msgFile (), "\n");

for (altCount = 0; altCount <= maxAltCount; altCount ++)
if (nBatches[altCount] > 0)
fprintf (msgFile (),
"# Alts: %3d  # Batches: %7d\n",
altCount,
nBatches[altCount]);

altsPerBatch =
(totBatches > 0)?
static_cast <double> (totAlts) / static_cast <double> (totBatches):
0;

fprintf (msgFile (),
"\n"
"# Alterations:    %7d\n"
"# Batches:        %7d\n"
"# Alts Per Batch: %10.2f\n\n",
totAlts,
totBatches,
altsPerBatch);
}
@


1.208
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d49 3
a51 3
   {
   return myReqPtMgr_->myReqPt (thePart, thePer);
   }
d59 70
a128 70
      WitProbAssoc       (theHeurAtor),
      myHeurAtor_        (theHeurAtor),
      myRtMgr_           (NULL),
      myMrMgr_           (NULL),
      myPrMgr_           (NULL),
      myPenExMgr_        (NULL),
      mySglSrcMgr_       (NULL),
      myReqPtMgr_        (NULL),
      mySplitter_        (NULL),
      myBaMgr_           (NULL),
      myMeMgr_           (NULL),
      mySsrMgr_          (NULL),
      mySelMgrs_         (),
      pendingAlts_       (myProblem ()),
      altCounts_         (),
      curResAlt_         (false),
      failResAlt_        (false),
      lastConsResAltPer_ (* new WitMapping <WitMaterial, WitPeriod>),
      nonNegLCRAPMats_   (myProblem ()),
      multiRoute_        (false),
      penExec_           (false),
      tbprMode_          (false),
      nAlts_             (0),
      myFixedPer_        (myProblem ())
   {
   WitPeriod thePer;

   if (DEVELOPMENT)
      myMsgFac () ("multiSelMsg");

   lastConsResAltPer_.allocate (myProblem (), -1);

   if (  WitMrMgr::instNeededFor (myProblem ()) or
         WitPrMgr::instNeededFor (myProblem ()))
      myRtMgr_ = new WitRtMgr (this);

   buildSelMgrs ();

   collectSelMgrs ();

   myReqPtMgr_ = new WitReqPtMgr (myProblem ());

   if (myGlobalComp ()->multiRoute ())
      if (myGlobalComp ()->penExec ())
         if (WitPrMgr::instNeededFor (myProblem ()))
            if (myGlobalComp ()->tieBreakPropRt ())
               tbprMode_ = true;

   if (multiRoute_)
      penExec_ = myGlobalComp ()->penExec ();

   if (penExec_)
      myPenExMgr_ = new WitPenExMgr (this);

   if (selSplitNeeded ())
      mySplitter_ = new WitSplitter (this);

   if (multiRoute_)
      if (WitSglSrcMgr::sglSrcReq (myProblem ()))
         mySglSrcMgr_ = new WitSglSrcMgr (this);

   if (myGlobalComp ()->selectionRecovery ())
      myMsgFac () ("selectionRecoveryMsg");

   if (selPrintLevelAt (3))
      printInit ();

   forEachPeriod (thePer, myProblem ())
      myFixedPer_[thePer] = new WitFixedPer (thePer);
   }
d133 2
a134 2
   {
   WitPeriod thePer;
d136 24
a159 24
   if (selPrintLevelAt (1))
      if (not selSplit ())
         countAlts ();

   delete & lastConsResAltPer_;
   delete   mySplitter_;
   delete   myReqPtMgr_;
   delete   mySglSrcMgr_;

   if (penExec_)
      delete myPenExMgr_;

   mySelMgrs_.clear ();

   delete mySsrMgr_;
   delete myMeMgr_;
   delete myBaMgr_;
   delete myPrMgr_;
   delete myMrMgr_;
   delete myRtMgr_;

   forEachPeriod (thePer, myProblem ())
      delete myFixedPer_[thePer];
   }
d164 6
a169 6
   {
   return
      buildAhead ()?
         myBaMgr ()->selExpPer (thePart, fillPer):
         thePart->explosionPeriod       (fillPer);
   }
d174 8
a181 8
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer)
   {
   return
      multiExec ()?
         myMeMgr ()->selExecPer   (theBopEnt, expPer):
         theBopEnt->expExecPeriod ()         [expPer];
   }
d186 2
a187 2
   {
   WitProblem * theProblem;
d189 1
a189 1
   theProblem = theHeurAtor->myProblem ();
d191 2
a192 2
   if (WitPrMgr::instNeededFor (theProblem))
      return true;
d194 6
a199 6
   return
          WitMrMgr::instNeededFor (theProblem)
      or  WitBaMgr::instNeededFor (theProblem)
      or  WitMeMgr::instNeededFor (theProblem)
      or WitSsrMgr::instNeededFor (theHeurAtor);
   }
d204 2
a205 2
   {
   bool restShortOnly;
d207 3
a209 3
   if (selSplit ())
      {
      mySplitter ()->commitMaxQty (netQty);
d211 2
a212 2
      return;
      }
d214 3
a216 3
   while (true)
      {
      prepCmqSel ();
d218 1
a218 1
      myHeurAtor_->commitMaxQtySel (netQty);
d220 3
a222 3
      if (penExec_)
         {
         restShortOnly = myPenExMgr ()->failRestShortOnly ();
d224 1
a224 1
         myPenExMgr ()->updatePsSup ();
d226 3
a228 3
         if (restShortOnly)
            continue;
         }
d230 1
a230 1
      alterSelections ();
d232 4
a235 4
      if (not failResAlt_)
         return;
      }
   }
d240 7
a246 7
   {
   fprintf (msgFile (),
      "\n"
      "Commit Max Qty Selected: Part %s, Period %d\n",
      myHeurAtor_->topPart ()->partName ().myCstring (),
      myHeurAtor_->topPer ());
   }
d251 3
a253 3
   {
   mySplitter ()->preCommit ();
   }
d258 2
a259 2
   {
   WitMaterial * theMat;
d261 3
a263 3
   while (nonNegLCRAPMats_.pop (theMat))
      lastConsResAltPer_ (theMat) = -1;
   }
d268 3
a270 3
   {
   if (not success)
      failResAlt_ = curResAlt_;
d272 1
a272 1
   curResAlt_ = false;
d274 1
a274 1
   myReqPtMgr_->reset ();
d276 2
a277 2
   if (selectiveSR ())
      mySsrMgr ()->postTempCommit ();
d279 2
a280 2
   if (penExec_)
      myPenExMgr ()->postTempCommit (success);
d282 3
a284 3
   if (selSplit ())
      mySplitter ()->postTempCommit (success);
   }
d289 2
a290 2
   {
   WitAltPt * theAltPt;
d292 1
a292 1
   stronglyAssert (not selSplit ());
d294 2
a295 2
   if (pendingAlts_.isEmpty ())
      return;
d297 2
a298 2
   if (selPrintLevelAt (1))
      printPreAlt ();
d300 3
a302 3
   while (getPendingAlt (theAltPt))
      alterSelection (theAltPt);
   }
d307 2
a308 2
   {
   WitAltPt * theAltPt;
d310 1
a310 1
   stronglyAssert (selSplit ());
d312 7
a318 7
   if (getPendingAlt (theAltPt))
      {
      witAssert (pendingAlts_.isEmpty ());

      alterSelection (theAltPt);
      }
   }
d323 2
a324 2
   {
   theAltPt->alterSelection ();
d326 2
a327 2
   if (selPrintLevelAt (1))
      nAlts_ ++;
d329 2
a330 2
   if (selPrintLevelAt (2))
      theAltPt->printAlteration ();
d332 3
a334 3
   if (myGlobalComp ()->selectionRecovery ())
      theAltPt->storeRecoveryPt ();
   }
d339 2
a340 2
   {
   WitMaterial * theMat;
d342 1
a342 1
   theMat = thePart->thisMat ();
d344 2
a345 2
   if (theMat == NULL)
      return;
d347 1
a347 1
   stronglyAssert (fillPer > lastConsResAltPer_ (theMat));
d349 2
a350 2
   if (not myReqPt (thePart, fillPer)->hasResAlt ())
      return;
d352 2
a353 2
   if (lastConsResAltPer_ (theMat) == -1)
      nonNegLCRAPMats_.push (theMat);
d355 2
a356 2
   lastConsResAltPer_ (theMat) = fillPer;
   }
d361 5
a365 5
   {
   WitMaterial * theMat;
   WitReqPt *    fillReqPt;
   WitPeriod     srcPer;
   WitPeriod     stockPer;
d367 1
a367 1
   theMat = thePart->thisMat ();
d369 2
a370 2
   if (theMat == NULL)
      return;
d372 2
a373 2
   if (fillPer == 0)
      return;
d375 1
a375 1
   srcPer = lastConsResAltPer_ (theMat);
d377 2
a378 2
   if (srcPer < 0)
      return;
d380 1
a380 1
   fillReqPt = myReqPt (thePart, fillPer);
d382 2
a383 2
   if (fillReqPt->hasResAlt ())
      return;
d385 1
a385 1
   stronglyAssert (srcPer < fillPer);
d387 4
a390 4
   if (theMat->mandEC () != false)
      for (stockPer = srcPer; stockPer < fillPer; stockPer ++)
         if (theMat->mandEC ()[stockPer])
            return;
d392 2
a393 2
   fillReqPt->setSource (myReqPt (thePart, srcPer));
   }
d398 16
a413 16
      WitMaterial * theMat,
      WitPeriod     fromPer,
      WitPeriod     toPer,
      double        rollVol)
   {
   WitReqPt * toReqPt;

   if (penExec_)
      myPenExMgr ()->placeReqs (theMat, fromPer, theMat, toPer);

   toReqPt = myReqPt (theMat, toPer);

   if (not toReqPt->hasResAlt ())
      if (myHeurAtor_->selectiveSR (theMat))
         mySsrMgr ()->recordSR (theMat, toPer, rollVol);
   }
d418 30
a447 30
      WitBopEntry *  theBopEnt,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod      fillPer,
      bool           forNetting)
   {  
   WitPart *  consPart;
   WitPeriod  consPer;
   WitReqPt * theReqPt;

   consPart = theConsEnt->myPart ();
   consPer  = theConsEnt->impactPeriod ()[execPer];

   if (penExec_)
      myPenExMgr ()->placeReqs (
         theBopEnt->myPart (),
         fillPer,
         consPart,
         consPer);

   theReqPt = myReqPt (consPart, consPer);

   innerPlaceReqs (
      theBopEnt,
      theConsEnt,
      execPer,
      fillPer, 
      theReqPt,
      forNetting);
   }
d452 30
a481 30
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      WitPeriod     fillPer)
   {
   WitPart *   prodPart;
   WitReqPt *  theReqPt;
   WitSelMgr * theSelMgr;
   WitAltPt *  theAltPt;

   prodPart = theBopEnt->myPart ();

   theReqPt = myReqPt (prodPart, fillPer);

   forEachEl (theSelMgr, mySelMgrs_)
      {
      if (not theSelMgr->validForExecBounds ())
         continue;

      theAltPt = theSelMgr->myAltPtFor (theBopEnt, NULL, execPer, fillPer);

      if (theAltPt == NULL)
         continue;

      if (selSplit ())
         if (not theAltPt->hasResAlt ())
            continue;

      if (sglSrc ())
         if (theAltPt->mySelPt ()->sglSrcMode ())
            continue;
d483 2
a484 2
      theReqPt->putDirectAlt (theAltPt);
      }
d486 2
a487 2
   recFundShortage (prodPart, fillPer);
   }
d492 4
a495 4
   {
   WitReqPt *  theReqPt;
   WitSelMgr * theSelMgr;
   WitAltPt *  theAltPt;
d497 1
a497 1
   theReqPt = myReqPt (thePart, fillPer);
d499 4
a502 4
   forEachEl (theSelMgr, mySelMgrs_)
      {
      if (not theSelMgr->validForLTBounds ())
         continue;
d504 1
a504 1
      theAltPt = theSelMgr->myAltPtFor (thePart, fillPer);
d506 2
a507 2
      if (theAltPt == NULL)
         continue;
d509 3
a511 3
      if (selSplit ())
         if (not theAltPt->hasResAlt ())
            continue;
d513 3
a515 3
      if (sglSrc ())
         if (theAltPt->mySelPt ()->sglSrcMode ())
            continue;
d517 2
a518 2
      theReqPt->putDirectAlt (theAltPt);
      }
d520 2
a521 2
   recFundShortage (thePart, fillPer);
   }
d526 3
a528 3
   {
   WitReqPt * theReqPt;
   WitAltPt * theAltPt;
d530 2
a531 2
   if (penExec_)
      myPenExMgr ()->recordFundShortage ();
d533 1
a533 1
   recShortage ();
d535 1
a535 1
   theReqPt   = myReqPt (thePart, fillPer);
d537 1
a537 1
   curResAlt_ = theReqPt->hasResAlt ();
d539 6
a544 6
   while (theReqPt != NULL)
      {
      while (theReqPt->getDirectAlt (theAltPt))
         if (not theAltPt->pending ())
            {  
            pendingAlts_.push (theAltPt);
d546 2
a547 2
            theAltPt->setPending (true);
            }
d549 2
a550 2
      theReqPt = theReqPt->source ();
      }
d552 3
a554 3
   if (pendingAlts_.isEmpty ())
      stronglyAssert (not curResAlt_);
   }
d559 2
a560 2
   {
   WitAltPt * theAltPt;
d562 1
a562 1
   while (getPendingAlt (theAltPt));
d564 2
a565 2
   curResAlt_ = false;
   }
d570 3
a572 3
   {
   myPenExMgr ()->recCommitVol (commitVol);
   }
d577 2
a578 2
   {
   failResAlt_ = false;
d580 3
a582 3
   if (penExec_)
      myPenExMgr ()->modifyRouting ();
   }
d587 4
a590 4
   {
   if (myHeurAtor_->tempCommActive ())
      mySplitter ()->recordFlow (theSelPt, incFlowVol);
   }
d595 3
a597 3
   {
   return mySplitter ()->splitCommActive ();
   }
d602 2
a603 2
   {
   witAssert (myGlobalComp ()->selectionRecovery ());
d605 4
a608 4
   if (selPrintLevelAt (3))
      fprintf (msgFile (),
         "\n"
         "Recovering the initial selection configuration:\n\n");
d610 2
a611 2
   if (multiRoute_)
      myMrMgr  ()->recoverInitState ();
d613 2
a614 2
   if (buildAhead ())
      myBaMgr  ()->recoverInitState ();
d616 2
a617 2
   if (multiExec ())
      myMeMgr  ()->recoverInitState ();
d619 2
a620 2
   if (selectiveSR ())
      mySsrMgr ()->recoverInitState ();
d622 3
a624 3
   if (propRtg ())
      myPrMgr  ()->recoverInitState ();
   }
d629 20
a648 20
   {
   if (WitMrMgr::instNeededFor (myProblem ()))
      {
      myMrMgr_    = new WitMrMgr (this);

      multiRoute_ = true;
      }

   if (WitBaMgr::instNeededFor (myProblem ()))
      myBaMgr_ = new WitBaMgr (this);

   if (WitMeMgr::instNeededFor (myProblem ()))
      myMeMgr_ = new WitMeMgr (this);

   if (WitSsrMgr::instNeededFor (myHeurAtor_))
      mySsrMgr_ = new WitSsrMgr (this);

   if (WitPrMgr::instNeededFor (myProblem ()))
      myPrMgr_ = new WitPrMgr (this);
   }
d653 3
a655 3
   {
   collect (mySsrMgr_);
   collect (myBaMgr_);
d657 2
a658 2
   if (multiRoute_)
      collect (myMrMgr ()->mySelMgrForProd ());
d660 2
a661 2
   if (propRtg ())
      collect (myPrMgr ()->mySelMgrForProd ());
d663 1
a663 1
   collect (myMeMgr_);
d665 2
a666 2
   if (multiRoute_)
      collect (myMrMgr ()->mySelMgrForCons ());
d668 3
a670 3
   if (propRtg ())
      collect (myPrMgr ()->mySelMgrForCons ());
   }
d675 3
a677 3
   {
   if (theSelMgr == NULL)
      return;
d679 1
a679 1
   theSelMgr->setIndex ();
d681 2
a682 2
   mySelMgrs_.append (theSelMgr);
   }
d687 2
a688 2
   {
   WitSelMgr * theSelMgr;
d690 3
a692 3
   forEachEl (theSelMgr, mySelMgrs_)
      if (theSelMgr->selSplitNeeded ())
         return true;
d694 2
a695 2
   return false;
   }
d700 60
a759 60
      WitBopEntry *  theBopEnt,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod      fillPer,
      WitReqPt *     theReqPt,
      bool           forNetting)
   {
   bool        priorAlt;
   WitSelMgr * lbSelMgr;
   WitSelMgr * theSelMgr;
   WitReqPt *  theSource;
   WitAltPt *  theAltPt;

   priorAlt = theReqPt->hasAlt ();

   if (selSplit ())
      lbSelMgr = mySplitter ()->lowestBddSelMgr ();

   if ((not selSplit ()) or (lbSelMgr == NULL))
      {
      theSource = myReqPt (theBopEnt->myPart (), fillPer);

      if (theSource->hasResAlt ())
         priorAlt = false;

      if (not priorAlt)
         theReqPt->setSource (theSource);
      }

   forEachEl (theSelMgr, mySelMgrs_)
      {
      if (selSplit ())
         if (lbSelMgr != NULL)
            if (not theSelMgr->isLowerThan (lbSelMgr))
               continue;

      if (forNetting)
         if (not theSelMgr->validForNetting ())
            continue;

      theAltPt = 
         theSelMgr->myAltPtFor (theBopEnt, theConsEnt, execPer, fillPer);

      if (theAltPt == NULL)
         continue;

      if (selSplit ())
         if (not theAltPt->hasResAlt ())
            continue;

      if (sglSrc ())
         if (theAltPt->mySelPt ()->sglSrcMode ())
            continue;

      if (theAltPt->hasResAlt ())
         priorAlt = false;

      if (not priorAlt)
         theReqPt->putDirectAlt (theAltPt);
      }
d761 2
a762 2
   getResAltFromNet (theConsEnt->myBomEnt (), execPer, theReqPt);
   }
d767 28
a794 28
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      WitReqPt *    theReqPt)
   {
   WitSubEntry * theSub;
   bool          resFound;

   if (theReqPt->hasResAlt ())
      return;

   if (not theBomEnt->hasSubsInEffect ()[execPer])
      return;

   resFound = copyResAlt (theBomEnt, execPer, theReqPt);

   if (resFound)
      return;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->netAllowed ())
         if (theSub->inEffect (execPer))
            {
            resFound = copyResAlt (theSub, execPer, theReqPt);

            if (resFound)
               return;
            }
   }
d799 7
a805 7
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitReqPt *     theReqPt)
   {
   WitPart *  consPart;
   WitPeriod  consPer;
   WitReqPt * consReqPt;
d807 2
a808 2
   if (theConsEnt->effConsRate ()[execPer] < FLOAT_EPSILON)
      return false;
d810 2
a811 2
   consPart  = theConsEnt->myPart ();
   consPer   = theConsEnt->impactPeriod ()[execPer];
d813 1
a813 1
   consReqPt = myReqPt (consPart, consPer);
d815 2
a816 2
   if (not consReqPt->hasResAlt ())
      return false;
d818 1
a818 1
   theReqPt->copyStateOf (consReqPt);
d820 2
a821 2
   return true;
   }
d826 10
a835 10
   {
   if (pendingAlts_.pop (theAltPt))
      {
      theAltPt->setPending (false);

      return true;
      }
   else
      return false;
   }
d840 12
a851 12
   {
   if (pendingAlts_.isEmpty ())
      return;

   if (selPrintLevelAt (2))
      fprintf (msgFile (),
         "\n"
         "------------------------------------\n"
         "Altering the Selection Configuration\n"
         "------------------------------------\n\n"
         "Alteration potentially resolves shortage? %s\n",
         myMsgFac ().boolText (failResAlt_));
d853 2
a854 2
   altCounts_.append (new int (pendingAlts_.nElements ()));
   }
d859 16
a874 16
   {
   if (multiRoute_)
      myMrMgr    ()->print ();

   if (buildAhead ())
      myBaMgr    ()->print ();
   
   if (multiExec ())
      myMeMgr    ()->print ();

   if (propRtg ())
      myPrMgr    ()->print ();

   if (penExec_)
      myPenExMgr ()->print ();
   }
d879 55
a933 55
   {
   int    maxAltCount;
   int *  altCountPtr;
   int    altCount;
   int    totAlts;
   int    totBatches;
   double altsPerBatch;

   WitVector <int> nBatches;

   maxAltCount = 0;

   forEachEl (altCountPtr, altCounts_)
      setToMax (maxAltCount, * altCountPtr);

   nBatches.resize (maxAltCount + 1, 0);
   
   totAlts    = 0;
   totBatches = 0;

   while (not altCounts_.isEmpty ())
      {
      altCountPtr = altCounts_.get ();

      nBatches[* altCountPtr] ++;

      totAlts    += * altCountPtr;
      totBatches ++;

      delete altCountPtr;
      }
   
   fprintf (msgFile (), "\n");

   for (altCount = 0; altCount <= maxAltCount; altCount ++)
      if (nBatches[altCount] > 0)
         fprintf (msgFile (),
            "# Alts: %3d  # Batches: %7d\n",
            altCount,
            nBatches[altCount]);

   altsPerBatch = 
      (totBatches > 0)?
         static_cast <double> (totAlts) / static_cast <double> (totBatches):
         0;

   fprintf (msgFile (),
      "\n"
      "# Alterations:    %7d\n"
      "# Batches:        %7d\n"
      "# Alts Per Batch: %10.2f\n\n",
      totAlts,
      totBatches,
      altsPerBatch);
   }
@


1.207
log
@Selection Recovery
@
text
@a16 1
#include <RecoverySet.h>
d611 1
a611 1
      myMrMgr  ()->                  recoverInitState ();
d614 1
a614 1
      myBaMgr  ()->                  recoverInitState ();
d617 1
a617 1
      myMeMgr  ()->myRecoverySet ()->recoverInitState ();
d620 1
a620 1
      mySsrMgr ()->myRecoverySet ()->recoverInitState ();
d623 1
a623 1
      myPrMgr  ()->                  recoverInitState ();
@


1.206
log
@Selection Recovery
@
text
@d122 1
a122 1
      setUpSelRec ();
a699 9
void WitSelector::setUpSelRec ()
   {
   myMsgFac () ("selectionRecoveryMsg");

   myMsgFac () ("selRecoveryNFIWmsg");
   }

//------------------------------------------------------------------------------

@


1.205
log
@Selection Recovery
@
text
@a701 3
   if (sglSrc ())
      myMsgFac () ("selRecCaseNyaSmsg", "single source");

@


1.204
log
@Selection Recovery
@
text
@a13 2
// Contains the implementation of class template AltSet <Owner, Site>, with
//    explicit instantiation
d17 1
a17 1
#include <AltSet.h>
d334 1
a334 1
      theAltPt->recAltForRecovery ();
d602 1
a602 1
void WitSelector::recoverSelections ()
d609 1
a609 1
         "Recovering discarded selection candidates:\n\n");
d612 1
a612 1
      myMrMgr  ()->             recoverSelections ();
d615 1
a615 1
      myBaMgr  ()->             recoverSelections ();
d618 1
a618 1
      myMeMgr  ()->myAltSet ()->recoverSelections ();
d621 1
a621 1
      mySsrMgr ()->myAltSet ()->recoverSelections ();
d624 1
a624 1
      myPrMgr  ()->             recoverSelections ();
a946 61

//------------------------------------------------------------------------------
// Implementation of class template AltSet <Owner, Site>.
//------------------------------------------------------------------------------

template <typename Owner, typename Site> 
      WitAltSet <Owner, Site>::WitAltSet (Owner * theOwner):

      myOwner_      (theOwner),
      alteredPairs_ (theOwner->myProblem ()),
      alteredAt_    (theOwner->myProblem (), false)
   {
   witAssert (theOwner->myGlobalComp ()->selectionRecovery ());
   }

//------------------------------------------------------------------------------

template <typename Owner, typename Site> 
      WitAltSet <Owner, Site>::~WitAltSet ()
   {
   }
 
//------------------------------------------------------------------------------

template <typename Owner, typename Site> 
      void WitAltSet <Owner, Site>::recAltForRecovery (
         Site *    theSite,
         WitPeriod thePer)
   {
   if (alteredAt_ (theSite)[thePer])
      return;

   alteredAt_ (theSite)[thePer] = true;

   alteredPairs_.push (theSite, thePer);
   }

//------------------------------------------------------------------------------

template <typename Owner, typename Site> 
      void WitAltSet <Owner, Site>::recoverSelections ()
   {
   Site *    theSite;
   WitPeriod thePer;

   while (alteredPairs_.pop (theSite, thePer))
      {
      myOwner_->recoverInitSel (theSite, thePer);

      alteredAt_ (theSite)[thePer] = false;
      }
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template AltSet <Owner, Site>.
//------------------------------------------------------------------------------

template class WitAltSet <WitMrCoord, WitRtSite>;
template class WitAltSet <WitMeMgr,   WitBopEntry>;
template class WitAltSet <WitSsrMgr,  WitMaterial>;
template class WitAltSet <WitPrCoord, WitRtCand>;
@


1.203
log
@Selection Recovery
@
text
@a703 3
   if (tbprMode_)
      myMsgFac () ("selRecCaseNyaSmsg", "tie breaking proportionate routing");

@


1.202
log
@Selection Recovery
@
text
@d336 1
a336 1
      theAltPt->recordAlteration ();
d704 2
a705 2
   if (penExec_)
      myMsgFac () ("selRecCaseNyaSmsg", "penalized execution");
d977 1
a977 1
      void WitAltSet <Owner, Site>::recordAlteration (
@


1.201
log
@Selection Recovery
@
text
@d28 1
d624 3
a703 3
   if (propRtg ())
      myMsgFac () ("selRecCaseNyaSmsg", "proportionate routing");

d1012 1
@


1.200
log
@Selection Recovery
@
text
@d333 3
@


1.199
log
@Selection Recovery
@
text
@a82 1
      alteredSelPtO_     (myProblem ()),
a599 9
void WitSelector::recAlteredSelPO (WitSelPt * theSelPt)
   {
   witAssert (myGlobalComp ()->selectionRecovery ());

   alteredSelPtO_.push (theSelPt);
   }

//------------------------------------------------------------------------------

a601 2
   WitSelPt * theSelPt;

a608 8
   while (alteredSelPtO_.pop (theSelPt))
      {
      if (selPrintLevelAt (3))
         theSelPt->printRecoverO ();

      theSelPt->recoverInitSeO ();
      }

d610 1
a610 1
      myMrMgr ()->recoverSelections ();
d613 1
a613 1
      myBaMgr ()->recoverSelections ();
d616 1
a616 1
      myMeMgr ()->myAltSet ()->recoverSelections ();
a618 1
      {
a619 1
      }
@


1.198
log
@Selection Recovery
@
text
@d637 5
d1029 1
@


1.197
log
@Selection Recovery
@
text
@d27 1
d1022 2
a1023 1
template class WitAltSet <WitMeMgr, WitBopEntry>;
@


1.196
log
@Selection Recovery
@
text
@d14 2
d19 1
d42 4
d635 1
a635 1
      myMeMgr ()->recoverSelections ();
d964 58
@


1.195
log
@Selection Recovery.
@
text
@d604 1
a604 2
   WitSelMgr * theSelMgr;
   WitSelPt *  theSelPt;
a612 3
   forEachEl (theSelMgr, mySelMgrs_)
      theSelMgr->specSelRecoverO ();

d621 3
@


1.194
log
@Selection Recovery.
@
text
@d625 5
a629 2
   forEachEl (theSelMgr, mySelMgrs_)
      theSelMgr->recoverSelections ();
@


1.193
log
@Selection Recovery
@
text
@d115 3
a122 3

   if (myGlobalComp ()->selectionRecovery ())
      setUpSelRec ();
a712 3
   if (selSplit ())
      myMsgFac () ("selRecCaseNyaSmsg", "selection splitting");

@


1.192
log
@Selection Recovery
@
text
@d75 1
a75 1
      alteredSelPts_     (myProblem ()),
d593 1
a593 1
void WitSelector::recAlteredSelPt (WitSelPt * theSelPt)
d597 1
a597 1
   alteredSelPts_.push (theSelPt);
d617 1
a617 1
   while (alteredSelPts_.pop (theSelPt))
@


1.191
log
@Selection Recovery.
@
text
@d615 1
a615 3
      {
      theSelMgr->specSelRecovery ();
      }
d620 1
a620 1
         theSelPt->printRecovery ();
d622 1
a622 1
      theSelPt->recoverInitSel ();
d624 3
@


1.190
log
@Selection Recovery.
@
text
@d703 2
a704 3
   if (not myGlobalComp ()->newSelRec ())
      if (propRtg ())
         myMsgFac () ("selRecCaseNyaSmsg", "proportionate routing");
@


1.189
log
@Selection Recovery.
@
text
@d122 1
a122 1
      setUpRecovery ();
d622 1
a622 1
         theSelPt->prtRecInitSel ();
d701 1
a701 1
void WitSelector::setUpRecovery ()
d703 3
a705 2
   if (propRtg ())
      myMsgFac () ("selRecCaseNyaSmsg", "proportionate routing");
@


1.188
log
@Selection recovery.
@
text
@d704 1
a704 1
      myMsgFac () ("sruCaseNyaSmsg", "proportionate routing");
d707 1
a707 1
      myMsgFac () ("sruCaseNyaSmsg", "penalized execution");
d710 1
a710 1
      myMsgFac () ("sruCaseNyaSmsg", "single source");
d713 1
a713 1
      myMsgFac () ("sruCaseNyaSmsg", "selection splitting");
@


1.187
log
@Name change: "selection reuse" has becomne "selection recovery".
@
text
@d602 1
a602 1
void WitSelector::restoreConfig ()
d612 1
a612 1
         "Restoring the selection configuration:\n\n");
d616 1
a616 1
      theSelMgr->restoreSpecConfig ();
d622 1
a622 1
         theSelPt->prtRestInitSel ();
d624 1
a624 1
      theSelPt->restoreInitSel ();
@


1.186
log
@Selection reuse.
@
text
@d121 2
a122 2
   if (myGlobalComp ()->selectionReuse ())
      setUpReuse ();
d595 1
a595 1
   witAssert (myGlobalComp ()->selectionReuse ());
d607 1
a607 1
   witAssert (myGlobalComp ()->selectionReuse ());
d701 1
a701 1
void WitSelector::setUpReuse ()
d715 1
a715 1
   myMsgFac () ("selectionReuseMsg");
d717 1
a717 1
   myMsgFac () ("selReuseNFIWmsg");
@


1.185
log
@Selection reuse.
@
text
@d115 1
a115 1
   if (selPrintLevelAt (1))
d234 1
a234 1
void WitSelector::printCommitMaxQtySelIA ()
d236 5
a240 6
   if (selPrintLevelAt (3))
      fprintf (msgFile (),
         "\n"
         "Commit Max Qty Selected: Part %s, Period %d\n",
         myHeurAtor_->topPart ()->partName ().myCstring (),
         myHeurAtor_->topPer ());
d292 2
a293 1
   printPreAltIA ();
d862 1
a862 1
void WitSelector::printPreAltIA ()
a863 3
   if (not selPrintLevelAt (1))
      return;

d883 2
a884 4
   if (selPrintLevelAt (3))
      {
      if (multiRoute_)
         myMrMgr ()->print ();
d886 2
a887 2
      if (buildAhead ())
         myBaMgr ()->print ();
d889 2
a890 2
      if (multiExec ())
         myMeMgr ()->print ();
d892 2
a893 2
      if (propRtg ())
         myPrMgr ()->print ();
d895 2
a896 3
      if (penExec_)
         myPenExMgr ()->print ();
      }
@


1.184
log
@Selection Reuse.
@
text
@d115 1
a115 1
   if (myGlobalComp ()->selPrintLevel () >= 1)
d131 1
a131 1
   if (myGlobalComp ()->selPrintLevel () >= 1)
d236 1
a236 1
   if (myGlobalComp ()->selPrintLevel () >= 3)
d321 1
a321 1
   if (myGlobalComp ()->selPrintLevel () >= 1)
d324 1
a324 1
   if (myGlobalComp ()->selPrintLevel () >= 2)
d609 1
a609 1
   if (myGlobalComp ()->selPrintLevel () >= 3)
d621 1
a621 1
      if (myGlobalComp ()->selPrintLevel () >= 3)
d864 1
a864 1
   if (myGlobalComp ()->selPrintLevel () < 1)
d870 1
a870 1
   if (myGlobalComp ()->selPrintLevel () >= 2)
d886 1
a886 1
   if (myGlobalComp ()->selPrintLevel () >= 3)
@


1.183
log
@Selection reuse.
@
text
@d621 3
a627 1

@


1.182
log
@Selection reuse.
@
text
@a595 1
   witAssert (myGlobalComp ()->newSelReuse    ());
a607 1
   witAssert (myGlobalComp ()->newSelReuse    ());
d612 1
a612 1
         "Restoring the selection configuration.\n");
@


1.181
log
@Selection reuse.
@
text
@d595 4
a598 5
   if    (myGlobalComp ()->selectionReuse ())
      if (myGlobalComp ()->newSelReuse    ())
         {
         alteredSelPts_.push (theSelPt);
         }
d605 1
a606 4
   WitSelMgr * theSelMgr;

   if (not myGlobalComp ()->newSelReuse ())
      return;
d609 1
d616 1
a616 1
   while (alteredSelPts_.pop (theSelPt))
d618 1
a618 1
      theSelPt->restoreInitSel ();
d621 1
a621 1
   forEachEl (theSelMgr, mySelMgrs_)
d623 1
a623 1
      theSelMgr->restoreSpecConfig ();
@


1.180
log
@Selection reuse
@
text
@d75 1
d593 11
d606 6
d618 10
d630 1
@


1.179
log
@Selection reuse.
@
text
@d592 12
@


1.178
log
@Selection Reuse.
@
text
@d121 1
a121 1
      myMsgFac () ("selReuseNFIWmsg");
d663 21
@


1.177
log
@Lead Time BOunds.
@
text
@d121 1
a121 1
      checkForVacuousSelReuse ();
a637 32
void WitSelector::checkForVacuousSelReuse ()
   {
   if (buildAhead ())
      myMsgFac () ("vacSelReuseCaseWmsg", "NSTN and/or ASAP build-ahead");

   if (multiRoute_)
      myMsgFac () ("vacSelReuseCaseWmsg", "multiple routes");

   if (multiExec ())
      myMsgFac () ("vacSelReuseCaseWmsg", "multiple execution periods");

   if (selectiveSR ())
      myMsgFac () ("vacSelReuseCaseWmsg", "stock reallocation");

   if (propRtg ())
      myMsgFac () ("vacSelReuseCaseWmsg", "proportionate routing");

   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("vacSelReuseCaseWmsg", "two-way multiple execution periods");

   if (penExec_)
      myMsgFac () ("vacSelReuseCaseWmsg", "penalized execution");

   if (sglSrc ())
      myMsgFac () ("vacSelReuseCaseWmsg", "single source");

   if (selSplit ())
      myMsgFac () ("vacSelReuseCaseWmsg", "selection splitting");
   }

//------------------------------------------------------------------------------

@


1.176
log
@Lead Time Bounds
@
text
@d640 3
a645 3
   if (buildAhead ())
      myMsgFac () ("vacSelReuseCaseWmsg", "NSTN and/or ASAP build-ahead");

@


1.175
log
@Lead Time Bounds
@
text
@d482 34
@


1.174
log
@Lead Time Bounds
@
text
@a356 1
   bool          priorAlt;
d383 1
a383 3
   priorAlt = false;

   fillReqPt->setSource (myReqPt (thePart, srcPer), priorAlt);
d672 1
a672 1
   WitPart *   prodPart;
d682 1
a682 1
      prodPart = theBopEnt->myPart ();
d684 5
a688 1
      theReqPt->setSource (myReqPt (prodPart, fillPer), priorAlt);
@


1.173
log
@Selection Reuse.
@
text
@d91 2
d477 1
a477 1
      theReqPt->putDirectAltExecBounds (theAltPt);
d581 3
d585 2
d715 5
a719 1
      theReqPt->putDirectAlt (theAltPt, priorAlt);
@


1.172
log
@Selection Reuse.
@
text
@d606 1
a606 1
      myMsgFac () ("vacSelReuseCaseWmsg", "NSTN and ASAP build-ahead");
@


1.171
log
@Selection Reuse.
@
text
@d119 1
a119 1
      validateSelReuse ();
d600 1
a600 1
void WitSelector::validateSelReuse ()
d602 2
a603 2
   if (sglSrc ())
      myMsgFac () ("selReuseWithCapNYASmsg", "single source");
d605 2
a606 2
   if (selSplit ())
      myMsgFac () ("selReuseWithCapNYASmsg", "selection splitting");
d608 2
a609 3
   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("selReuseWithCapNYASmsg",
         "two-way multiple execution periods");
d611 2
a612 2
   if (penExec_)
      myMsgFac () ("selReuseWithCapNYASmsg", "penalized execution");
d614 2
a615 2
   if (buildAhead ())
      myMsgFac () ("selReuseWithCapNYASmsg", "NSTN and ASAP build-ahead");
d617 2
a618 2
   if (multiRoute_)
      myMsgFac () ("selReuseWithCapNYASmsg", "multiple routes");
d620 2
a621 2
   if (multiExec ())
      myMsgFac () ("selReuseWithCapNYASmsg", "multiple execution periods");
d623 2
a624 2
   if (selectiveSR ())
      myMsgFac () ("selReuseWithCapNYASmsg", "stock reallocation");
d626 2
a627 2
   if (propRtg ())
      myMsgFac () ("selReuseWithCapNYASmsg", "proportionate routing");
@


1.170
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d117 3
d600 33
@


1.169
log
@Stochastic Implosion
@
text
@d33 1
a33 1
#include <Global.h>
@


1.168
log
@Heuristic search increment.
@
text
@d53 1
a53 2
      WitProbAssoc       (theHeurAtor->myProblem ()),
 
@


1.167
log
@Updated the copyright date on all source files.
@
text
@d525 1
a525 1
void WitSelector::recCommitVol (double commitVol, bool byExp)
d527 1
a527 1
   myPenExMgr ()->recCommitVol (commitVol, byExp);
@


1.166
log
@Revised mappingIndex code.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.165
log
@Vector PropRtg.
@
text
@a35 1
#include <MapIdxI.h>
@


1.164
log
@Vector PropRtg.
@
text
@d585 1
a585 1
   if (propRouting ())
d593 1
a593 1
   if (propRouting ())
d791 1
a791 1
      if (propRouting ())
@


1.163
log
@Tie breaking prop-rt.
@
text
@d376 1
a376 1
   if (not (theMat->mandEC () == false))
@


1.162
log
@Pegged Critical List.
@
text
@a24 1
#include <RtAn.h>
@


1.161
log
@Changed terminology from "low priority proportionate routing" to
"tie breaking proportionate routing".
@
text
@d88 3
a90 1
   myRtMgr_ = new WitRtMgr (this);
@


1.160
log
@Low-Pri Prop-Rt.
@
text
@d77 1
a77 1
      lpprMode_          (false),
d97 2
a98 2
            if (myGlobalComp ()->lowPriPropRt ())
               lpprMode_ = true;
@


1.159
log
@Low-Pri Prop-Rt.
@
text
@d24 1
a24 1
#include <ExpRest.h>
d34 1
d61 1
a61 2
      myExpRest_         (NULL),
      myRtAnalyzer_      (NULL),
d104 1
a104 7
      {
      myMsgFac () ("penExecMsg");

      myExpRest_    = new WitExpRest    (myHeurAtor_);

      myRtAnalyzer_ = new WitRtAnalyzer (this);
      }
d136 1
a136 4
      {
      delete myRtAnalyzer_;
      delete myExpRest_;
      }
d212 1
a212 1
         restShortOnly = myExpRest ()->failRestShortOnly ();
d214 1
a214 1
         myExpRest ()->updatePsSup ();
d271 1
a271 1
      myExpRest ()->postTempCommit (success);
d396 1
a396 1
      myExpRest ()->placeReqs (theMat, fromPer, theMat, toPer);
d422 1
a422 1
      myExpRest ()->placeReqs (
d487 1
a487 1
      myExpRest ()->recordFundShortage ();
d527 1
a527 1
   myRtAnalyzer ()->recCommitVol (commitVol, byExp);
d537 1
a537 1
      myRtAnalyzer ()->modifyRouting ();
d794 1
a794 1
         myExpRest ()->print ();
@


1.158
log
@Low-Pri Prop-Rt.
@
text
@d591 1
a591 1
      collect (myMrMgr ()->mySelMgrFor (prodRtCase));
d594 1
a594 1
      collect (myPrMgr ()->mySelMgrFor (prodRtCase));
d599 1
a599 1
      collect (myMrMgr ()->mySelMgrFor (consRtCase));
d602 1
a602 1
      collect (myPrMgr ()->mySelMgrFor (consRtCase));
@


1.157
log
@Low-Pri Prop-Rt.
@
text
@d329 1
a329 1
      theAltPt->mySelPt ()->printSelection ();
@


1.156
log
@Low-Pri Prop-Rt.
@
text
@d553 1
a553 1
   if (myHeurAtor_->tempMode ())
@


1.155
log
@Low-Pri Prop-Rt.
@
text
@a28 1
#include <PoMgr.h>
a58 1
      myPoMgr_           (NULL),
d94 5
a98 16
   if (myGlobalComp ()->newPropRt ())
      {
      if (myGlobalComp ()->multiRoute ())
         if (myGlobalComp ()->penExec ())
            if (WitPrMgr::instNeededFor (myProblem ()))
               if (myGlobalComp ()->lowPriPropRt ())
                  lpprMode_ = true;
      }
   else
      {
      if (myGlobalComp ()->multiRoute ())
         if (myGlobalComp ()->penExec ())
            if (WitPoMgr::instNeededFor (myProblem ()))
               if (myGlobalComp ()->lowPriPropRt ())
                  lpprMode_ = true;
      }
a152 1
   delete myPoMgr_;
d190 2
a191 10
   if (theProblem->myGlobalComp ()->newPropRt ())
      {
      if (WitPrMgr::instNeededFor (theProblem))
         return true;
      }
   else
      {
      if (WitPoMgr::instNeededFor (theProblem))
         return true;
      }
d584 2
a585 10
   if (myGlobalComp ()->newPropRt ())
      {
      if (WitPrMgr::instNeededFor (myProblem ()))
         myPrMgr_ = new WitPrMgr (this);
      }
   else
      {
      if (WitPoMgr::instNeededFor (myProblem ()))
         myPoMgr_ = new WitPoMgr (this);
      }
d594 1
a594 6
      {
      if (myGlobalComp ()->newPropRt ())
         collect (myPrMgr ()->mySelMgrFor (prodRtCase));
      else
         collect (myPoMgr ()->mySelMgrFor (prodRtCase));
      }
d602 1
a602 6
      {
      if (myGlobalComp ()->newPropRt ())
         collect (myPrMgr ()->mySelMgrFor (consRtCase));
      else
         collect (myPoMgr ()->mySelMgrFor (consRtCase));
      }
d800 1
a800 6
         {
         if (myGlobalComp ()->newPropRt ())
            myPrMgr ()->print ();
         else
            myPoMgr ()->print ();
         }
@


1.154
log
@Low-Pri Prop-Rt.
@
text
@d497 1
a497 1
         if (not theAltPt->mySelPt ()->hasResAlt ())
d716 1
a716 1
         if (not theAltPt->mySelPt ()->hasResAlt ())
@


1.153
log
@Low-Pri Prop-Rt.
@
text
@d18 1
a18 1
#include <SelAlt.h>
d312 1
a312 1
   WitSelAlt * theSelAlt;
d321 2
a322 2
   while (getPendingAlt (theSelAlt))
      alterSelection (theSelAlt);
d329 1
a329 1
   WitSelAlt * theSelAlt;
d333 1
a333 1
   if (getPendingAlt (theSelAlt))
d337 1
a337 1
      alterSelection (theSelAlt);
d343 1
a343 1
void WitSelector::alterSelection (WitSelAlt * theSelAlt)
d345 1
a345 1
   theSelAlt->alterSelection ();
d351 1
a351 1
      theSelAlt->mySelPt ()->printSelection ();
d480 1
a480 1
   WitSelAlt * theSelAlt;
d491 1
a491 1
      theSelAlt = theSelMgr->mySelAltFor (theBopEnt, NULL, execPer, fillPer);
d493 1
a493 1
      if (theSelAlt == NULL)
d497 1
a497 1
         if (not theSelAlt->mySelPt ()->hasResAlt ())
d501 1
a501 1
         if (theSelAlt->mySelPt ()->sglSrcMode ())
d504 1
a504 1
      theReqPt->putDirectAltExecBounds (theSelAlt);
d514 2
a515 2
   WitReqPt *  theReqPt;
   WitSelAlt * theSelAlt;
d528 2
a529 2
      while (theReqPt->getDirectAlt (theSelAlt))
         if (not theSelAlt->pending ())
d531 1
a531 1
            pendingAlts_.push (theSelAlt);
d533 1
a533 1
            theSelAlt->setPending (true);
d547 1
a547 1
   WitSelAlt * theSelAlt;
d549 1
a549 1
   while (getPendingAlt (theSelAlt));
d684 1
a684 1
   WitSelAlt * theSelAlt;
d709 2
a710 2
      theSelAlt =
         theSelMgr->mySelAltFor (theBopEnt, theConsEnt, execPer, fillPer);
d712 1
a712 1
      if (theSelAlt == NULL)
d716 1
a716 1
         if (not theSelAlt->mySelPt ()->hasResAlt ())
d720 1
a720 1
         if (theSelAlt->mySelPt ()->sglSrcMode ())
d723 1
a723 1
      theReqPt->putDirectAlt (theSelAlt, priorAlt);
d790 1
a790 1
bool WitSelector::getPendingAlt (WitSelAlt * & theSelAlt)
d792 1
a792 1
   if (pendingAlts_.pop (theSelAlt))
d794 1
a794 1
      theSelAlt->setPending (false);
@


1.152
log
@Low-Pri Prop-Rt.
@
text
@d204 11
d219 1
a219 3
      or WitSsrMgr::instNeededFor (theHeurAtor)
      or  WitPoMgr::instNeededFor (theProblem)
      or  WitPrMgr::instNeededFor (theProblem);
d606 10
a615 5
   if (WitPoMgr::instNeededFor (myProblem ()))
      myPoMgr_ = new WitPoMgr (this);

   if (WitPrMgr::instNeededFor (myProblem ()))
      myPrMgr_ = new WitPrMgr (this);
d624 6
a629 1
      collect (myPoMgr ()->mySelMgrFor (prodRtCase));
d637 6
a642 1
      collect (myPoMgr ()->mySelMgrFor (consRtCase));
a832 3
      if (propRouting ())
         myPoMgr ()->print ();

d839 8
@


1.151
log
@Low-Pri Prop-Rt.
@
text
@a25 1
#include <PoMgr.h>
d29 2
d61 1
d96 16
a111 5
   if (myGlobalComp ()->multiRoute ())
      if (myGlobalComp ()->penExec ())
         if (WitPoMgr::instNeededFor (myProblem ()))
            if (myGlobalComp ()->lowPriPropRt ())
               lpprMode_ = true;
d165 1
a205 1
      or  WitPoMgr::instNeededFor (theProblem)
d208 3
a210 1
      or WitSsrMgr::instNeededFor (theHeurAtor);
a587 3
   if (WitPoMgr::instNeededFor (myProblem ()))
      myPoMgr_ = new WitPoMgr (this);

d597 6
@


1.150
log
@Low-Pri Prop-Rt.
@
text
@d18 1
d69 1
a69 1
      pendingPts_        (myProblem ()),
d288 1
a288 1
   WitSelPt * theSelPt;
d292 1
a292 1
   if (pendingPts_.isEmpty ())
d297 2
a298 2
   while (getPendingPt (theSelPt))
      alterSelection (theSelPt);
d305 1
a305 1
   WitSelPt * theSelPt;
d309 1
a309 1
   if (getPendingPt (theSelPt))
d311 1
a311 1
      witAssert (pendingPts_.isEmpty ());
d313 1
a313 1
      alterSelection (theSelPt);
d319 1
a319 1
void WitSelector::alterSelection (WitSelPt * theSelPt)
d321 1
a321 1
   theSelPt->alterSelection ();
d327 1
a327 1
      theSelPt->printSelection ();
d456 1
a456 1
   WitSelPt *  theSelPt;
d467 1
a467 2
      theSelPt = 
         theSelMgr->mySelPtForAlt (theBopEnt, NULL, execPer, fillPer);
d469 1
a469 1
      if (theSelPt == NULL)
d473 1
a473 1
         if (not theSelPt->hasResAlt ())
d477 1
a477 1
         if (theSelPt->sglSrcMode ())
d480 1
a480 1
      theReqPt->putDirectPointExecBounds (theSelPt);
d490 2
a491 2
   WitReqPt * theReqPt;
   WitSelPt * theSelPt;
d504 2
a505 2
      while (theReqPt->getDirectPoint (theSelPt))
         if (not theSelPt->pending ())
d507 1
a507 1
            pendingPts_.push (theSelPt);
d509 1
a509 1
            theSelPt->setPending (true);
d515 1
a515 1
   if (pendingPts_.isEmpty ())
d523 1
a523 1
   WitSelPt * theSelPt;
d525 1
a525 1
   while (getPendingPt (theSelPt));
d642 1
a642 1
   WitSelPt *  theSelPt;
d667 2
a668 2
      theSelPt =
         theSelMgr->mySelPtForAlt (theBopEnt, theConsEnt, execPer, fillPer);
d670 1
a670 1
      if (theSelPt == NULL)
d674 1
a674 1
         if (not theSelPt->hasResAlt ())
d678 1
a678 1
         if (theSelPt->sglSrcMode ())
d681 1
a681 1
      theReqPt->putDirectPoint (theSelPt, priorAlt);
d748 1
a748 1
bool WitSelector::getPendingPt (WitSelPt * & theSelPt)
d750 1
a750 1
   if (pendingPts_.pop (theSelPt))
d752 1
a752 1
      theSelPt->setPending (false);
d767 1
a767 1
   if (pendingPts_.isEmpty ())
d779 1
a779 1
   altCounts_.append (new int (pendingPts_.nElements ()));
@


1.149
log
@Atttempt to fix a compiler warning on gcc V3.3.3.
@
text
@d589 1
a589 1
      collect (myMrMgr ()->mySelMgr (prodRtCase));
d592 1
a592 1
      collect (myPoMgr ()->mySelMgr (prodRtCase));
d597 1
a597 1
      collect (myMrMgr ()->mySelMgr (consRtCase));
d600 1
a600 1
      collect (myPoMgr ()->mySelMgr (consRtCase));
@


1.148
log
@Low-Pri Prop-Rt.
@
text
@d35 1
@


1.147
log
@Low-Pri Prop-Rt.
@
text
@d25 1
a25 1
#include <PrMgr.h>
d57 1
a57 1
      myPrMgr_           (NULL),
d94 1
a94 1
         if (WitPrMgr::instNeededFor (myProblem ()))
d150 1
a150 1
   delete myPrMgr_;
d190 1
a190 1
      or  WitPrMgr::instNeededFor (theProblem)
d572 2
a573 2
   if (WitPrMgr::instNeededFor (myProblem ()))
      myPrMgr_ = new WitPrMgr (this);
d591 1
a591 1
      collect (myPrMgr ()->mySelMgr (prodRtCase));
d599 1
a599 1
      collect (myPrMgr ()->mySelMgr (consRtCase));
d791 1
a791 1
         myPrMgr ()->print ();
@


1.146
log
@Fixed a memory leak.
@
text
@d75 1
d92 6
@


1.145
log
@Double Precision.
@
text
@d121 2
d146 3
@


1.144
log
@Removed a bad function overload.
@
text
@d796 6
a801 6
   int   maxAltCount;
   int * altCountPtr;
   int   altCount;
   int   totAlts;
   int   totBatches;
   float altsPerBatch;
d838 1
a838 1
         static_cast <float> (totAlts) / static_cast <float> (totBatches):
@


1.143
log
@Continued implementation of post-implosion pegging.
@
text
@d322 1
a322 1
   theMat = thePart->myMat ();
d348 1
a348 1
   theMat = thePart->myMat ();
@


1.142
log
@Added some optional warnings on Linux.
@
text
@a35 1
#include <FlexVecI.h>
@


1.141
log
@Fixed a NULL pointer bug that crashed WIT on Linux, but was undetected on AIX.
@
text
@a121 2
   WitPeriod thePer;

d799 1
a799 1
   int   nAlts;
d830 2
a831 2
   for (nAlts = 0; nAlts <= maxAltCount; nAlts ++)
      if (nBatches[nAlts] > 0)
d834 2
a835 2
            nAlts,
            nBatches[nAlts]);
@


1.140
log
@Continued implementation of proportionate routing.
@
text
@d263 2
a264 2
   if (myGlobalComp ()->stockReallocation ())
      mySsrMgr_->postTempCommit ();
d398 1
a398 1
         mySsrMgr_->recordSR (theMat, toPer, rollVol);
@


1.139
log
@Continued implementation of proportionate routing.
@
text
@a110 3
   if (propRouting ())
      applyPropRtRest ();

a615 8
   }

//------------------------------------------------------------------------------

void WitSelector::applyPropRtRest ()
   {
   if (sglSrc ())
      myMsgFac () ("propRtWithNYISmsg", "single-source");
@


1.138
log
@Continued implementation of proportionate routing.
@
text
@d544 2
a545 1
   mySplitter ()->recordFlow (theSelPt, incFlowVol);
@


1.137
log
@Continued implementation of proportionate routing.
Fixed a bug in selection splitting for selective stock reallocation.
@
text
@d335 5
a339 4
   if (myReqPt (thePart, fillPer)->hasResAlt ())
      {
      if (lastConsResAltPer_ (theMat) == -1)
         nonNegLCRAPMats_.push (theMat);
d341 1
a341 2
      lastConsResAltPer_ (theMat) = fillPer;
      }
d390 1
a390 2
      double        rollVol,
      bool          bddSsrSplit)
a391 1
   WitReqPt * fromReqPt;
a392 1
   bool       priorAlt;
d399 3
a401 12
   if (toReqPt->hasResAlt ())
      return;

   priorAlt  = toReqPt->hasAlt ();

   fromReqPt = myReqPt (theMat, fromPer);

   if (not bddSsrSplit)
      toReqPt->setSource (fromReqPt, priorAlt);

   if (myHeurAtor_->selectiveSR (theMat))
      mySsrMgr_->recordSR (theMat, toPer, rollVol);
@


1.136
log
@Continued implementation of proportionate routing.
@
text
@d390 2
a391 1
      double        rollVol)
d409 2
a410 1
   toReqPt->setSource (fromReqPt, priorAlt);
@


1.135
log
@Continued implementation of proportionate routing.
@
text
@d591 1
a591 1
      collect (myMrMgr ()->mySelMgrForProd ());
d594 1
a594 1
      collect (myPrMgr ()->mySelMgrForProd ());
d599 1
a599 1
      collect (myMrMgr ()->mySelMgrForCons ());
d602 1
a602 1
      collect (myPrMgr ()->mySelMgrForCons ());
@


1.134
log
@Continued implementation of proportionate routing.
@
text
@d32 1
d76 2
a77 1
      nAlts_             (0)
d79 2
d116 3
d125 2
@


1.133
log
@Continued implementation of proportionate routing.
@
text
@a624 3
   if (selSplit ())
      myMsgFac () ("propRtWithNYISmsg", "selection splitting");
      
@


1.132
log
@Continued implementation of propotionate routing.
@
text
@a22 1
#include <MrSecMgr.h>
a25 1
#include <PrSecMgr.h>
d582 1
a582 1
      collect (myMrMgr ()->myPmrMgr ());
d585 1
a585 1
      collect (myPrMgr ()->myPprMgr ());
d590 1
a590 1
      collect (myMrMgr ()->myCmrMgr ());
d593 1
a593 1
      collect (myPrMgr ()->myCprMgr ());
@


1.131
log
@Continued implementation of proportionate routing.
@
text
@d23 1
a23 1
#include <MrSelMgr.h>
d27 1
a27 1
#include <PrSelMgr.h>
d584 1
a584 1
      collect (myMrMgr ()->myPmrSelMgr ());
d587 1
a587 1
      collect (myPrMgr ()->myPprSelMgr ());
d592 1
a592 1
      collect (myMrMgr ()->myCmrSelMgr ());
d595 1
a595 1
      collect (myPrMgr ()->myCprSelMgr ());
@


1.130
log
@Continued implementation of proportionate routing.
@
text
@a631 3
      
   if (penExec ())
      myMsgFac () ("propRtWithNYISmsg", "penalized execution");
@


1.129
log
@Continued implementation of proportionate routing.
@
text
@d23 1
d27 1
d58 1
a64 2
      myPmrMgr_          (NULL),
      myCmrMgr_          (NULL),
d141 1
a141 2
   delete myCmrMgr_;
   delete myPmrMgr_;
d176 1
a176 1
              multiRouteNeededFor (theProblem)
d321 1
a321 1
   thePart->getMaterial (theMat);
d347 1
a347 1
   thePart->getMaterial (theMat);
d561 1
a561 1
   if (multiRouteNeededFor (myProblem ()))
d563 1
a563 5
      myPmrMgr_ = new WitPmrMgr (this);
      myCmrMgr_ = new WitCmrMgr (this);

      myPmrMgr_->setUp ();
      myCmrMgr_->setUp ();
d582 3
a584 1
   collect (myPmrMgr_);
d587 1
a587 1
      collect (myPrMgr ()->mySelMgrForProd ());
d590 3
a592 1
   collect (myCmrMgr_);
d595 1
a595 8
      collect (myPrMgr ()->mySelMgrForCons ());
   }

//------------------------------------------------------------------------------

bool WitSelector::multiRouteNeededFor (WitProblem * theProblem)
   {
   return theProblem->myGlobalComp ()->multiRoute ();
d798 1
a798 4
         {
         myPmrMgr ()->printHasAlt ();
         myCmrMgr ()->printHasAlt ();
         }
@


1.128
log
@Continued implementation of proportionate routing.
@
text
@d20 1
d55 1
a55 1
      myRtMgr_           (theHeurAtor->myRtMgr ()),
d83 2
d142 1
d177 1
a177 1
      or  WitPrMgr::instNeededFor (theHeurAtor->myRtMgr ())
d572 1
a572 1
   if (WitPrMgr::instNeededFor (myHeurAtor_->myRtMgr ()))
@


1.127
log
@Continued implementation of proportionate routing.
@
text
@a20 1
#include <OrMgr1.h>
a54 2
      myProdOrMgr_       (NULL),
      myConsOrMgr_       (NULL),
a81 6
   if (oldRtNeededFor (myProblem ()))
      {
      myProdOrMgr_ = WitProdOrMgr::newInstance (myProblem ());
      myConsOrMgr_ = WitConsOrMgr::newInstance (myProblem ());
      }

a138 3

   delete myConsOrMgr_;
   delete myProdOrMgr_;
a595 7
bool WitSelector::oldRtNeededFor (WitProblem * theProblem)
   {
   return false;
   }

//------------------------------------------------------------------------------

a799 6
      if (myProdOrMgr_ != NULL)
         myProdOrMgr_->print ();

      if (myConsOrMgr_ != NULL)
         myConsOrMgr_->print ();

@


1.126
log
@Continued implementation of proportionate routing.
@
text
@a25 1
#include <OpMgr1.h>
a65 2
      myProdOpMgr_       (NULL),
      myConsOpMgr_       (NULL),
a76 1
      oldPr_             (false),
d114 1
a114 1
   if (oldPr ())
a145 2
   delete myConsOpMgr_;
   delete myProdOpMgr_;
d185 1
a185 1
      or           oldPrNeededFor (theProblem)
a579 8
   if (oldPrNeededFor (myProblem ()))
      {
      myProdOpMgr_ = new WitProdOpMgr (this);
      myConsOpMgr_ = new WitConsOpMgr (this);

      oldPr_       = true;
      }

d592 3
a594 4
   include (mySsrMgr_);
   include (myBaMgr_);
   include (myPmrMgr_);
   include (myProdOpMgr_);
d597 1
a597 1
      include (myPrMgr ()->mySelMgrForProd ());
d599 2
a600 3
   include (myMeMgr_);
   include (myCmrMgr_);
   include (myConsOpMgr_);
d603 1
a603 1
      include (myPrMgr ()->mySelMgrForCons ());
d610 1
a610 1
   return oldPrNeededFor (theProblem);
d622 1
a622 19
bool WitSelector::oldPrNeededFor (WitProblem * theProblem)
   {
   WitPart *     thePart;
   WitBomEntry * theBomEnt;

   forEachPart (thePart, theProblem)
      if (thePart->propRouting ())
         return true;

   forEachBomEntry (theBomEnt, theProblem)
      if (theBomEnt->propRouting ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitSelector::include (WitSelMgr * theSelMgr)
a828 6
         }

      if (oldPr ())
         {
         myProdOpMgr ()->print ();
         myConsOpMgr ()->print ();
@


1.125
log
@Continued implementation of proportionate routing.
@
text
@d25 1
d56 1
d59 1
d80 1
a80 1
      propRouting_       (false),
d89 1
a89 1
   if (routingNeededFor (myProblem ()))
d118 1
a118 1
   if (propRouting ())
d149 1
d191 1
a191 1
      or          propRtNeededFor (theProblem)
d586 1
a586 1
   if (propRtNeededFor (myProblem ()))
d591 1
a591 1
      propRouting_ = true;
d594 3
d610 4
d617 3
d624 1
a624 1
bool WitSelector::routingNeededFor (WitProblem * theProblem)
d626 1
a626 1
   return propRtNeededFor (theProblem);
d638 1
a638 1
bool WitSelector::propRtNeededFor (WitProblem * theProblem)
d865 1
a865 1
      if (propRouting ())
d870 3
@


1.124
log
@Continued implementation of proportionate routing.
@
text
@d25 1
a25 1
#include <PrMgr.h>
d64 2
a65 2
      myProdPrMgr_       (NULL),
      myConsPrMgr_       (NULL),
d146 2
a147 2
   delete myConsPrMgr_;
   delete myProdPrMgr_;
d584 2
a585 2
      myProdPrMgr_ = new WitProdPrMgr (this);
      myConsPrMgr_ = new WitConsPrMgr (this);
d602 1
a602 1
   include (myProdPrMgr_);
d605 1
a605 1
   include (myConsPrMgr_);
d853 2
a854 2
         myProdPrMgr ()->print ();
         myConsPrMgr ()->print ();
@


1.123
log
@Continued implementation of proportionate routing.
@
text
@d186 5
a190 6
            WitPmrMgr::instNeededFor (theProblem)
      or    WitCmrMgr::instNeededFor (theProblem)
      or             propRtNeededFor (theProblem)
      or     WitBaMgr::instNeededFor (theProblem)
      or     WitMeMgr::instNeededFor (theProblem)
      or    WitSsrMgr::instNeededFor (theHeurAtor);
d571 1
a571 15
   if (WitSsrMgr::instNeededFor (myHeurAtor_))
      {
      mySsrMgr_ = new WitSsrMgr (this);

      mySelMgrs_.append (mySsrMgr_);
      }

   if (WitBaMgr::instNeededFor (myProblem ()))
      {
      myBaMgr_ = new WitBaMgr (this);

      mySelMgrs_.append (myBaMgr_);
      }

   if (WitPmrMgr::instNeededFor (myProblem ()))
d574 1
a574 2

      mySelMgrs_.append (myPmrMgr_);
d577 1
d585 1
a585 2

      mySelMgrs_.append (myProdPrMgr_);
d590 3
a593 1
      {
d596 2
a597 2
      mySelMgrs_.append (myMeMgr_);
      }
d599 8
a606 3
   if (WitCmrMgr::instNeededFor (myProblem ()))
      {
      myCmrMgr_ = new WitCmrMgr (this);
d608 1
a608 1
      mySelMgrs_.append (myCmrMgr_);
d610 3
a612 13
      myCmrMgr_->setUp ();

      multiRoute_ = true;
      }

   if (propRtNeededFor (myProblem ()))
      {
      myConsPrMgr_ = new WitConsPrMgr (this);

      mySelMgrs_.append (myConsPrMgr_);

      propRouting_ = true;
      }
d617 1
a617 1
bool WitSelector::routingNeededFor (WitProblem * theProblem)
d619 1
a619 1
   return propRtNeededFor (theProblem);
d638 12
@


1.122
log
@Continued implementation of proportionate routing.
@
text
@d21 1
a21 1
#include <RtMgr.h>
d55 2
a56 2
      myProdRtMgr_       (NULL),
      myConsRtMgr_       (NULL),
d88 2
a89 2
      myProdRtMgr_ = WitProdRtMgr::newInstance (myProblem ());
      myConsRtMgr_ = WitConsRtMgr::newInstance (myProblem ());
d151 2
a152 2
   delete myConsRtMgr_;
   delete myProdRtMgr_;
d846 2
a847 2
      if (myProdRtMgr_ != NULL)
         myProdRtMgr_->print ();
d849 2
a850 2
      if (myConsRtMgr_ != NULL)
         myConsRtMgr_->print ();
@


1.121
log
@Continued implementation of proportionate routing.
@
text
@d65 1
d77 1
d86 1
a86 1
   if (WitProdPrMgr::instNeededFor (myProblem ()))
d146 1
d188 1
a188 1
      or WitProdPrMgr::instNeededFor (theProblem)
d597 1
a597 1
   if (WitProdPrMgr::instNeededFor (myProblem ()))
d602 2
d623 34
d859 1
d861 2
@


1.120
log
@Continued implementation of proportionate routing.
@
text
@d64 1
a64 1
      myPprMgr_          (NULL),
d84 1
a84 1
   if (WitPprMgr::instNeededFor (myProblem ()))
d144 1
a144 1
   delete myPprMgr_;
d183 6
a188 6
         WitPmrMgr::instNeededFor (theProblem)
      or WitCmrMgr::instNeededFor (theProblem)
      or WitPprMgr::instNeededFor (theProblem)
      or  WitBaMgr::instNeededFor (theProblem)
      or  WitMeMgr::instNeededFor (theProblem)
      or WitSsrMgr::instNeededFor (theHeurAtor);
d594 1
a594 1
   if (WitPprMgr::instNeededFor (myProblem ()))
d596 1
a596 1
      myPprMgr_ = new WitPprMgr (this);
d598 1
a598 1
      mySelMgrs_.append (myPprMgr_);
d820 1
a820 1
         myPprMgr ()->print ();
@


1.119
log
@Continued implementation of proportionate routing.
@
text
@d807 6
@


1.118
log
@Continued implementation of proportionate routing.
@
text
@d56 1
d85 1
d87 2
d148 1
@


1.117
log
@Continued implementation of proportionate routing.
@
text
@d55 1
a55 1
      myRtMgr_           (NULL),
d84 1
a84 1
      myRtMgr_ = new WitRtMgr (myProblem ());
d144 1
a144 1
   delete myRtMgr_;
@


1.116
log
@Continued implementation of proportionate routing.
@
text
@d63 1
a63 1
      myPrMgr_           (NULL),
d83 1
a83 1
   if (WitPrMgr::instNeededFor (myProblem ()))
d140 1
a140 1
   delete myPrMgr_;
d180 1
a180 1
      or  WitPrMgr::instNeededFor (theProblem)
d589 1
a589 1
   if (WitPrMgr::instNeededFor (myProblem ()))
d591 1
a591 1
      myPrMgr_ = new WitPrMgr (this);
d593 1
a593 1
      mySelMgrs_.append (myPrMgr_);
d809 1
a809 1
         myPrMgr ()->print ();
@


1.115
log
@Continued implementation of proportionate routing.
@
text
@d52 1
a52 1
      WitProbAssoc       (theHeurAtor),
a557 7
   }

//------------------------------------------------------------------------------

bool WitSelector::propRouting (WitPart * thePart)
   {
   return WitPrMgr::propRouting (thePart);
@


1.114
log
@Continued implementation of Proportionate Routing.
@
text
@d21 1
d55 1
d83 3
d143 2
@


1.113
log
@Continued implementation of proportionate routing.
@
text
@d555 7
d800 1
a800 1
   if (myGlobalComp ()->selPrintLevel () >= 2)
d802 6
a819 7

   if (myGlobalComp ()->selPrintLevel () >= 3)
      if (multiRoute_)
         {
         myPmrMgr ()->printHasAlt ();
         myCmrMgr ()->printHasAlt ();
         }
@


1.112
log
@Continued implementation of proportionate routing.
@
text
@d459 1
a459 1
         theSelMgr->mySelPt (theBopEnt, NULL, execPer, fillPer);
d674 2
a675 1
      theSelPt = theSelMgr->mySelPt (theBopEnt, theConsEnt, execPer, fillPer);
d795 3
@


1.111
log
@Continued implementation of Proportionate Routing.
@
text
@d24 1
d61 1
a80 2
   multiRoute_ = myGlobalComp ()->multiRoute ();

d104 3
d135 1
d173 1
d578 9
d603 2
d619 14
@


1.110
log
@Changed some C style casts to C++ style.
@
text
@d160 16
d552 1
a552 1
   if (WitSsrMgr::ssrNeeded (myHeurAtor_))
d559 1
a559 1
   if (myHeurAtor_->buildAhead ())
d566 1
a566 1
   if (multiRoute_)
d575 1
a575 1
   if (myGlobalComp ()->multiExecNeeded ())
d582 1
a582 1
   if (multiRoute_)
@


1.109
log
@Internal changes.
@
text
@d812 1
a812 1
         ((float) totAlts) / (float) totBatches:
@


1.108
log
@Internal changes.
@
text
@d113 1
a113 1
      if (! selSplit ())
d189 1
a189 1
      if (! failResAlt_)
d227 1
a227 1
   if (! success)
d250 1
a250 1
   stronglyAssert (! selSplit ());
d342 1
a342 1
   if (! (theMat->mandEC () == false))
d434 1
a434 1
      if (! theSelMgr->validForExecBounds ())
d444 1
a444 1
         if (! theSelPt->hasResAlt ())
d476 1
a476 1
         if (! theSelPt->pending ())
d487 1
a487 1
      stronglyAssert (! curResAlt_);
d610 1
a610 1
   if ((! selSplit ()) || (lbSelMgr == NULL))
d621 1
a621 1
            if (! theSelMgr->isLowerThan (lbSelMgr))
d625 1
a625 1
         if (! theSelMgr->validForNetting ())
d634 1
a634 1
         if (! theSelPt->hasResAlt ())
d660 1
a660 1
   if (! theBomEnt->hasSubsInEffect ()[execPer])
d698 1
a698 1
   if (! consReqPt->hasResAlt ())
d789 1
a789 1
   while (! altCounts_.isEmpty ())
@


1.107
log
@Removed implementation of single-source by the old algorithm.
@
text
@d66 2
a67 2
      curResAlt_         (witFALSE),
      failResAlt_        (witFALSE),
d70 2
a71 2
      multiRoute_        (witFALSE),
      penExec_           (witFALSE),
d162 1
a162 1
   WitBoolean restShortOnly;
d171 1
a171 1
   while (witTRUE)
d225 1
a225 1
void WitSelector::postTempCommit (WitBoolean success)
d230 1
a230 1
   curResAlt_ = witFALSE;
d320 1
a320 1
   WitBoolean    priorAlt;
d342 1
a342 1
   if (! (theMat->mandEC () == witFALSE))
d347 1
a347 1
   priorAlt = witFALSE;
d362 1
a362 1
   WitBoolean priorAlt;
d389 1
a389 1
      WitBoolean     forNetting)
d480 1
a480 1
            theSelPt->setPending (witTRUE);
d498 1
a498 1
   curResAlt_ = witFALSE;
d503 1
a503 1
void WitSelector::recCommitVol (double commitVol, WitBoolean byExp)
d512 1
a512 1
   failResAlt_ = witFALSE;
d527 1
a527 1
WitBoolean WitSelector::splitCommActive ()
d578 1
a578 1
WitBoolean WitSelector::selSplitNeeded ()
d584 1
a584 1
         return witTRUE;
d586 1
a586 1
   return witFALSE;
d597 1
a597 1
      WitBoolean     forNetting)
d599 1
a599 1
   WitBoolean  priorAlt;
d655 1
a655 1
   WitBoolean    resFound;
d681 1
a681 1
WitBoolean WitSelector::copyResAlt (
d691 1
a691 1
      return witFALSE;
d699 1
a699 1
      return witFALSE;
d703 1
a703 1
   return witTRUE;
d708 1
a708 1
WitBoolean WitSelector::getPendingPt (WitSelPt * & theSelPt)
d712 1
a712 1
      theSelPt->setPending (witFALSE);
d714 1
a714 1
      return witTRUE;
d717 1
a717 1
      return witFALSE;
d737 1
a737 1
         myMsgFac ().booleanText (failResAlt_));
@


1.106
log
@Continued implementation of single-source by the new algorithm.
@
text
@a19 1
#include <OldSglMgr.h>
a54 1
      myOldSglMgr_       (NULL),
d101 2
a102 12
      {
      if (myGlobalComp ()->sglSrcNewAlg ())
         {
         if (WitSglSrcMgr::sglSrcReq (myProblem ()))
            mySglSrcMgr_ = new WitSglSrcMgr (this);
         }
      else
         {
         if (WitOldSglMgr::sglSrcReq (myProblem ()))
            myOldSglMgr_ = new WitOldSglMgr (this);
         }
      }
a119 1
   delete   myOldSglMgr_;
d187 1
a187 4
      if (oldSglSrc ())
         myOldSglMgr ()->alterSelections ();
      else
         alterSelections ();
d273 1
a273 4
      if (oldSglSrc ())
         myOldSglMgr ()->alterSelection (theSelPt);
      else
         alterSelection (theSelPt);
a446 8
      if (oldSglSrc ())
         {
         myOldSglMgr ()->placeReqs (theSelPt);

         if (myOldSglMgr ()->mustSkip (theSelPt))
            continue;
         }

a515 3

   if (oldSglSrc ())
      myOldSglMgr ()->prepCmqSel ();
a635 8

      if (oldSglSrc ())
         {
         myOldSglMgr ()->placeReqs (theSelPt);

         if (myOldSglMgr ()->mustSkip (theSelPt))
            continue;
         }
@


1.105
log
@Continued implementation of single-source with the new algorithm.
@
text
@d475 1
a475 1
         if (mySglSrcMgr ()->sglSrcMode (theSelPt))
d676 1
a676 1
         if (mySglSrcMgr ()->sglSrcMode (theSelPt))
@


1.104
log
@Began implementation of the new single-source algorithm.
@
text
@d21 1
d57 1
d103 12
a114 2
      if (WitOldSglMgr::hasSglSrcComp (myProblem ()))
         myOldSglMgr_ = new WitOldSglMgr (this);
d131 1
d474 4
d674 4
@


1.103
log
@Fixed the "interference bug" in Single-Source.
@
text
@d20 1
a20 1
#include <SglSrcMgr.h>
d55 1
a55 1
      mySglSrcMgr_       (NULL),
d101 2
a102 2
      if (WitSglSrcMgr::hasSglSrcComp (myProblem ()))
         mySglSrcMgr_ = new WitSglSrcMgr (this);
d119 1
a119 1
   delete   mySglSrcMgr_;
d187 2
a188 2
      if (singleSource ())
         mySglSrcMgr ()->alterSelections ();
d276 2
a277 2
      if (singleSource ())
         mySglSrcMgr ()->alterSelection (theSelPt);
d453 1
a453 1
      if (singleSource ())
d455 1
a455 1
         mySglSrcMgr ()->placeReqs (theSelPt);
d457 1
a457 1
         if (mySglSrcMgr ()->mustSkip (theSelPt))
d527 2
a528 2
   if (singleSource ())
      mySglSrcMgr ()->prepCmqSel ();
d650 1
a650 1
      if (singleSource ())
d652 1
a652 1
         mySglSrcMgr ()->placeReqs (theSelPt);
d654 1
a654 1
         if (mySglSrcMgr ()->mustSkip (theSelPt))
@


1.102
log
@Began implementation of multi-level lot sizes.
@
text
@d173 1
a173 4
      resetResAlt ();

      if (penExec_)
         myRtAnalyzer ()->modifyRouting ();
d469 1
a469 1
void WitSelector::recFundShortage (WitPart * thePart, WitPeriod thePer)
d479 1
a479 1
   theReqPt   = myReqPt (thePart, thePer);
d520 1
a520 1
void WitSelector::resetResAlt ()
d523 6
@


1.101
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d21 1
a21 2
#include <PmrMgr.h>
#include <CmrMgr.h>
d564 3
a566 1
      mySelMgrs_.append (myPmrMgr_->mySelMgr ());
d580 3
a582 1
      mySelMgrs_.append (myCmrMgr_->mySelMgr ());
@


1.100
log
@Continued implementation of single-source.
@
text
@d34 1
@


1.99
log
@Continued implementation of single-source.
@
text
@d100 3
a102 2
   if (WitSglSrcMgr::singleSourceNeeded (myProblem ()))
      mySglSrcMgr_ = new WitSglSrcMgr (this);
@


1.98
log
@Continued implementation of Single-Source.
@
text
@d278 4
a281 1
      alterSelection (theSelPt);
@


1.97
log
@Continued implementation of Single-Source.
@
text
@d268 1
a268 1
WitBoolean WitSelector::getPendingPt (WitSelPt * & theSelPt)
d270 5
a274 1
   if (pendingPts_.pop (theSelPt))
d276 1
a276 1
      theSelPt->setPending (witFALSE);
d278 1
a278 1
      return witTRUE;
a279 2
   else
      return witFALSE;
d710 14
@


1.96
log
@Continued implementation of Single-Source.
@
text
@d450 8
@


1.95
log
@Continued implementation of Single-Source.
@
text
@a407 3
   if (singleSource ())
      mySglSrcMgr ()->placeReqs (theBopEnt, theConsEnt, execPer);

d630 3
d635 1
@


1.94
log
@Continued implementation of Single-Source.
@
text
@d409 1
a409 1
      mySglSrcMgr ()->placeReqs (theBopEnt, execPer);
@


1.93
log
@Continued implementation of single-source.
@
text
@d408 3
@


1.92
log
@Continued implementation of single-source.
@
text
@d711 3
a713 3
         "-----------------------------\n"
         "Altering the Selection Scheme\n"
         "-----------------------------\n\n"
@


1.91
log
@Continued implementation of single-source.
@
text
@d189 4
a192 1
      alterSelections ();
d251 17
a428 1
   WitBoolean  resFound;
d441 1
a441 1
         theSelMgr->mySelPt (theBopEnt, NULL, execPer, fillPer, resFound);
d447 1
a447 1
         if (! resFound)
d450 1
a450 1
      theReqPt->putDirectPointExecBounds (theSelPt, resFound);
a595 1
   WitBoolean  resFound;
d620 1
a620 7
      theSelPt = 
         theSelMgr->mySelPt (
            theBopEnt, 
            theConsEnt, 
            execPer, 
            fillPer, 
            resFound);
d626 1
a626 1
         if (! resFound)
d630 1
a630 1
         if (theSelPt->sglSrcMode ())
d633 1
a633 1
      theReqPt->putDirectPoint (theSelPt, resFound, priorAlt);
a695 17
   }

//------------------------------------------------------------------------------

void WitSelector::alterSelections ()
   {
   WitSelPt * theSelPt;

   stronglyAssert (! selSplit ());

   if (pendingPts_.isEmpty ())
      return;

   printPreAltIA ();

   while (getPendingPt (theSelPt))
      alterSelection (theSelPt);
@


1.90
log
@Continued implementation of single-source.
@
text
@d617 4
@


1.89
log
@Continued implementation of single source.
@
text
@d100 1
a100 26
   if (myGlobalComp ()->sglSrc ())
      {
      if (myGlobalComp ()->perfPegging ())
         myMsgFac () ("nyiWithSglSrcSmsg", "Pegging");

      if (penExec_)
         myMsgFac () ("nyiWithSglSrcSmsg", "Penalized execution");

      if (selSplit ())
         myMsgFac () ("nyiWithSglSrcSmsg", "Selection splitting");

      if (myGlobalComp ()->computeCriticalList ())
         myMsgFac () ("nyiWithSglSrcSmsg", "Critical parts list");

      if (nPeriods () > 1)
         myMsgFac () ("nyiWithSglSrcSmsg", "nPeriods > 1");

      if (buildAhead ())
         myMsgFac () ("nyiWithSglSrcSmsg", "Build-Ahead");

      if (multiExec ())
         myMsgFac () ("nyiWithSglSrcSmsg", "Multi-Exec");

      if (mySsrMgr_ != NULL)
         myMsgFac () ("nyiWithSglSrcSmsg", "Selective stock reallocation");

a101 1
      }
d513 1
a513 1
   if (ssrNeeded ())
a546 13
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::ssrNeeded ()
   {
   WitMaterial * theMat;

   forEachMaterial (theMat, myProblem ())
      if (myHeurAtor_->selectiveSR (theMat))
         return witTRUE;

   return witFALSE;
@


1.88
log
@Corrected a problem with multi-route.
@
text
@d114 12
a289 3
   if (mySglSrcMgr_ != NULL)
      myMsgFac () ("nyiWithSglSrcSmsg", "Altering the selection");

@


1.87
log
@Continued implementation of single source.
@
text
@d407 7
a413 8
   if (! theReqPt->hasResAlt ())
      innerPlaceReqs (
         theBopEnt,
         theConsEnt,
         execPer,
         fillPer, 
         theReqPt,
         forNetting);
@


1.86
log
@Continued preliminary work on single source.
@
text
@d20 1
d55 1
d100 17
d130 3
a132 4

   delete mySplitter_;

   delete myReqPtMgr_;
d278 3
@


1.85
log
@Preliminary work on single source.
@
text
@d29 3
d66 1
a66 1
      lastConsResAltPer_ (myProblem (), -1),
d75 2
d109 2
@


1.84
log
@Continued implementation of object iteration.
@
text
@d752 8
a759 7
   int             maxAltCount;
   int *           altCountPtr;
   int             nAlts;
   WitVector (int) nBatches;
   int             totAlts;
   int             totBatches;
   float           altsPerBatch;
@


1.83
log
@Began implementation of object iteration.
@
text
@d268 1
a268 1
   theMat = thePart->myMat ();
d294 1
a294 1
   theMat = thePart->myMat ();
@


1.82
log
@Continued implementation of sel-split for pen-exec.
@
text
@d29 1
@


1.81
log
@Continued implementation of sel-split for pen-exec.
@
text
@a63 2
      revSelMgrs_        (myProblem ()),
      unbndSelMgrs_      (myProblem ()),
a89 1
      {
a91 3
      reverseCopyInto (revSelMgrs_, mySelMgrs_);
      }

d378 2
a379 5
   if (theReqPt->hasResAlt ())
      return;

   if (selSplit ())
      placeReqsSS (
a385 8
   else
      placeReqsNss (
         theBopEnt,
         theConsEnt,
         execPer,
         fillPer,
         theReqPt,
         forNetting);
d413 3
d418 1
a418 1
            theSelPt = NULL;
d566 1
a566 1
void WitSelector::placeReqsNss (
d575 2
d578 1
a578 1
   WitSelMgr * theSelMgr;
a579 1
   WitSelPt *  theSelPt;
d581 1
a581 1
   stronglyAssert (! selSplit ());
d583 2
a584 1
   priorAlt = theReqPt->hasAlt ();
d586 3
a588 1
   prodPart = theBopEnt->myPart ();
d590 2
a591 1
   theReqPt->setSource (myReqPt (prodPart, fillPer), priorAlt);
d595 5
d610 8
a617 1
            resFound);     
a681 76
   }

//------------------------------------------------------------------------------

void WitSelector::placeReqsSS (
      WitBopEntry *  theBopEnt,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod      fillPer,
      WitReqPt *     theReqPt,
      WitBoolean     forNetting)
   {
   WitBoolean  priorAlt;
   WitBoolean  bsFound;
   WitSelMgr * theSelMgr;
   WitPart *   prodPart;
   WitSelPt *  theSelPt;
   WitBoolean  resFound;

   stronglyAssert (selSplit ());

   priorAlt = theReqPt->hasAlt ();

   bsFound  = findUnbndSelMgrs ();

   if (! bsFound)
      {
      prodPart = theBopEnt->myPart ();

      theReqPt->setSource (myReqPt (prodPart, fillPer), priorAlt);
      }

   while (unbndSelMgrs_.pop (theSelMgr))
      {
      if (forNetting)
         if (! theSelMgr->validForNetting ())
            continue;

      theSelPt = 
         theSelMgr->mySelPt (
            theBopEnt, 
            theConsEnt, 
            execPer, 
            fillPer, 
            resFound);     

      if (! resFound)
         theSelPt = NULL;

      theReqPt->putDirectPoint (theSelPt, resFound, priorAlt);
      }

   getResAltFromNet (theConsEnt->myBomEnt (), execPer, theReqPt);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::findUnbndSelMgrs ()
   {
   WitSelMgr * theSelMgr;

   WitObjStItr <WitSelMgr> theItr;

   unbndSelMgrs_.clear ();

   theItr.attachTo (revSelMgrs_);

   while (theItr.advance (theSelMgr))
      {
      if (theSelMgr->boundedSplit ())
         return witTRUE;

      unbndSelMgrs_.push (theSelMgr);
      }

   return witFALSE;
@


1.80
log
@Continued implementation of sel-split for pen-exec.
@
text
@a27 1
#include <SplitMgr1.h>
a51 1
      mySplitMgr_        (NULL),
a94 2
      mySplitMgr_ = new WitSplitMgr (this);

a109 2
   delete mySplitMgr_;

d159 1
a159 1
      mySplitMgr ()->commitMaxQty (netQty);
d166 1
a166 1
      failResAlt_ = witFALSE;
a170 3
      if (selSplit ())
         mySplitter ()->startFlowMon ();

d183 1
a183 4
      if (selSplit ())
         mySplitter ()->alterSelections ();
      else
         alterSelections ();
d204 7
d489 21
@


1.79
log
@Continued implementation of sel-split for pen-exec.
@
text
@d28 1
a28 1
#include <SsPeMgr1.h>
d53 1
a53 1
      mySsPeMgr_         (NULL),
d97 1
a97 2
      if (penExec_)
         mySsPeMgr_ = new WitSsPeMgr (this);
d114 1
a114 1
   delete mySsPeMgr_;
d163 3
a165 4
   if (penExec_)
      if (selSplit ())
         {
         mySsPeMgr_->commitMaxQty (netQty);
d167 2
a168 2
         return;
         }
@


1.78
log
@Continued implementation of sel-split for pen-exec.
@
text
@d285 1
a285 1
   witAssert (fillPer > lastConsResAltPer_ (theMat));
d324 1
a324 1
   witAssert (srcPer < fillPer);
d476 2
a477 3
   if (DEBUG_MODE)
      if (pendingPts_.isEmpty ())
         witAssert (! curResAlt_);
d580 1
a580 1
   witAssert (! selSplit ());
d684 1
a684 1
   witAssert (selSplit ());
d749 1
a749 1
   witAssert (! selSplit ());
@


1.77
log
@Continued implementation sel-split for pen-exec.
@
text
@d112 2
a113 1
      countAlts ();
a217 23
void WitSelector::printPreAltIA ()
   {
   if (myGlobalComp ()->selPrintLevel () < 1)
      return;

   if (pendingPts_.isEmpty ())
      return;

   if (myGlobalComp ()->selPrintLevel () >= 2)
      fprintf (msgFile (),
         "\n"
         "-----------------------------\n"
         "Altering the Selection Scheme\n"
         "-----------------------------\n\n"
         "Alteration potentially resolves shortage? %s\n",
         myMsgFac ().booleanText (failResAlt_));

   if (myGlobalComp ()->selPrintLevel () >= 1)
      altCounts_.append (new int (pendingPts_.nElements ()));
   }

//------------------------------------------------------------------------------

d759 22
@


1.76
log
@Continued implementation of sel-split for pen-exec.
@
text
@d627 61
d722 4
d739 2
@


1.75
log
@Continued implementation of sel-split for pen-exec.
@
text
@d66 2
d99 2
d394 3
a396 2
      WitPeriod      fillPer)
   {
d417 7
a423 1
      placeReqsSS  (theBopEnt, theConsEnt, execPer, fillPer, theReqPt);
d425 7
a431 1
      placeReqsNss (theBopEnt, theConsEnt, execPer, fillPer, theReqPt);
d594 2
a595 1
      WitReqPt *     theReqPt)
d613 4
d636 2
a637 1
      WitReqPt *     theReqPt)
d639 2
a640 1
   int         nBnddSplitsBelow;
a641 1
   WitBoolean  priorAlt;
d643 1
a644 1
   WitSelPt *  theSelPt;
d648 1
a648 1
   priorAlt         = theReqPt->hasAlt ();
d650 1
a650 1
   nBnddSplitsBelow = 0;
d652 1
a652 5
   forEachEl (theSelMgr, mySelMgrs_)
      if (theSelMgr->boundedSplit ())
         nBnddSplitsBelow ++;

   if (nBnddSplitsBelow == 0)
d659 1
a659 1
   forEachEl (theSelMgr, mySelMgrs_)
d661 22
a682 9
      if (nBnddSplitsBelow == 0)
         {
         theSelPt = 
            theSelMgr->mySelPt (
               theBopEnt, 
               theConsEnt, 
               execPer, 
               fillPer, 
               resFound);     
d684 1
a684 2
         if (! resFound)
            theSelPt = NULL;
d686 1
a686 2
         theReqPt->putDirectPoint (theSelPt, resFound, priorAlt);
         }
d688 2
d691 3
a693 1
         nBnddSplitsBelow --;
d695 2
@


1.74
log
@Continued implementation of sel-split for pen-exec,
@
text
@a76 2
   setUpSelSplit ();

d89 5
d95 1
a95 1
      if (selSplit ())
d419 1
a419 1
void WitSelector::recordExecBoundShortage (
d449 1
a449 1
   recordShortage (prodPart, fillPer);
d454 1
a454 1
void WitSelector::recordShortage (WitPart * thePart, WitPeriod thePer)
d462 1
a462 1
   while (getPendingPt (theSelPt));
d488 11
d559 1
a559 1
void WitSelector::setUpSelSplit ()
d565 1
a565 2
         {
         mySplitter_ = new WitSplitter (this);
d567 1
a567 2
         return;
         }
@


1.73
log
@Continued implementation of sel-split fpr pen-exec.
@
text
@a491 13
void WitSelector::mergeSplitBopEnts (
      WitPart *        thePart,
      WitPeriod        expPer,
      WitBopEntStack & expBopEnts)
   {
   witAssert (penExec_);
   witAssert (selSplit ());

   mySsPeMgr_->mergeSplitBopEnts (thePart, expPer, expBopEnts);
   }

//------------------------------------------------------------------------------

@


1.72
log
@Continued implementation of sel-split for pen-exec.
@
text
@d492 13
@


1.71
log
@Implemented alteration in sel-split for pen-exec.
@
text
@d180 1
a180 1
         myExpRest ()->updatePsSup (witTRUE);
d243 1
a243 1
void WitSelector::postTempCommit (WitBoolean & success)
a255 4
      {
      if (selSplit ())
         mySsPeMgr_->postTempCommit (success);

a256 1
      }
@


1.70
log
@Continued implementation of sel-split for pen-exec.
@
text
@a153 1
   WitBoolean finished;
d156 8
d178 6
a183 18
         if (selSplit ())
            {
            mySsPeMgr_->doSSPE (finished);

            if (finished)
               return;
            else
               continue;
            }
         else
            {
            restShortOnly = myExpRest ()->failRestShortOnly ();

            myExpRest ()->updatePsSup (witTRUE);

            if (restShortOnly)
               continue;
            }
@


1.69
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d184 1
a184 1
            myExpRest ()->updatePsSup ();
d248 1
a248 1
void WitSelector::postTempCommit (WitBoolean success)
d261 6
a266 1
      myExpRest ()-> postTempCommit (success);
@


1.68
log
@Added allowSSPE dev param.
Switched pen-exec to single-shortage logic.
Made pen-exec exploit sparse penalties.
@
text
@d16 1
a26 1
#include <Selector.h>
d28 1
d53 1
d90 4
a93 1
      myRtAnalyzer_ = new WitRtAnalyzer (this, myPmrMgr (), myCmrMgr ());
d107 2
d154 3
d170 20
a189 2
         if (myExpRest ()->updatePsSup ())
            continue;
@


1.67
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d340 3
d373 7
a429 1
   WitBoolean firstFindShortage;
d434 1
a434 6
      {
      myExpRest ()->recordFundShortage (firstFindShortage);

      if (! firstFindShortage)
         return;
      }
@


1.66
log
@Fixed a NULL pointer bug.
@
text
@d331 1
a331 1
      WitMaterial * theMat, 
d333 2
a334 1
      WitPeriod     toPer)
d352 1
a352 1
      mySsrMgr_->recordSrFrom (theMat, toPer);
@


1.65
log
@Made stock reallocation use ssr vs. usr on a part-by-part basis.
@
text
@d71 2
d466 1
a466 3
   WitMaterial * theMat;

   if (myGlobalComp ()->multiRoute ())
d468 1
a468 1
      multiRoute_ = witTRUE;
d470 1
a470 2
      myPmrMgr_   = new WitPmrMgr (this);
      myCmrMgr_   = new WitCmrMgr (this);
d474 1
d477 10
d488 1
d491 2
a492 4
   forEachMaterial (theMat, myProblem ())
      if (myHeurAtor_->selectiveSR (theMat))
         {
         mySsrMgr_ = new WitSsrMgr (this);
d494 3
a496 2
         break;
         }
d498 2
a499 5
   recordSelMgr (mySsrMgr_);
   recordSelMgr (myBaMgr_);
   recordSelMgr (myPmrMgr_->mySelMgr ());
   recordSelMgr (myMeMgr_);
   recordSelMgr (myCmrMgr_->mySelMgr ());
d504 1
a504 1
void WitSelector::recordSelMgr (WitSelMgr * theSelMgr)
d506 7
a512 2
   if (theSelMgr != NULL)
      mySelMgrs_.append (theSelMgr);
@


1.64
log
@Changed selStockRe attribute to stockReallocation (fullSR, internally).
@
text
@d69 1
a69 1
      myMsgFac () ("multiSelectionsMsg");
d227 1
a227 1
   if (myGlobalComp ()->fullSR ())
d348 1
a348 1
   if (myGlobalComp ()->fullSR ())
d464 2
d470 2
a471 2
      myPmrMgr_ = new WitPmrMgr (this);
      myCmrMgr_ = new WitCmrMgr (this);
d480 7
a486 2
   if (myGlobalComp ()->fullSR ())
      mySsrMgr_ = new WitSsrMgr (this);
@


1.63
log
@Continued development of Selective Stock Reallocation.
@
text
@d227 1
a227 1
   if (myGlobalComp ()->selStockRe ())
d348 1
a348 1
   if (myGlobalComp ()->selStockRe ())
d478 1
a478 1
   if (myGlobalComp ()->selStockRe ())
@


1.62
log
@Continued implementation of selective stock reallocation.
@
text
@d270 3
a272 1
   if (! thePart->getMyMaterial (theMat))
d296 3
a298 1
   if (! thePart->getMyMaterial (theMat))
@


1.61
log
@Continued implementation of selective stock reallocation.
@
text
@d227 3
d270 1
a270 1
   if (! thePart->isaMaterial (theMat))
d294 1
a294 1
   if (! thePart->isaMaterial (theMat))
d325 3
a327 3
      WitPart * thePart, 
      WitPeriod fromPer, 
      WitPeriod toPer)
d333 1
a333 1
   toReqPt = myReqPt (thePart, toPer);
d340 1
a340 1
   fromReqPt = myReqPt (thePart, fromPer);
d343 3
d356 3
a358 9
   WitPart *   consPart;
   WitPeriod   consPer;
   WitReqPt *  theReqPt;
   int         nBnddSplitsBelow;
   WitSelMgr * theSelMgr;
   WitBoolean  priorAlt;
   WitPart *   prodPart;
   WitBoolean  resFound;
   WitSelPt *  theSelPt;
a367 2
   nBnddSplitsBelow = 0;

d369 3
a371 36
      forEachEl (theSelMgr, mySelMgrs_)
         if (theSelMgr->boundedSplit ())
            nBnddSplitsBelow ++;

   priorAlt = theReqPt->hasAlt ();

   if (nBnddSplitsBelow == 0)
      {
      prodPart = theBopEnt->myPart ();

      theReqPt->setSource (myReqPt (prodPart, fillPer), priorAlt);
      }

   forEachEl (theSelMgr, mySelMgrs_)
      {
      if (nBnddSplitsBelow == 0)
         {
         theSelPt = 
            theSelMgr->mySelPt (
               theBopEnt, 
               theConsEnt, 
               execPer, 
               fillPer, 
               resFound);     

         if (selSplit ())
            if (! resFound)
               theSelPt = NULL;

         theReqPt->putDirectPoint (theSelPt, resFound, priorAlt);
         }

      if (selSplit ())
         if (theSelMgr->boundedSplit ())
            nBnddSplitsBelow --;
      }
d505 93
@


1.60
log
@Continuing implementation of selective stock reallocation.
@
text
@d509 1
a509 1
   if (myGlobalComp ()->selStockRealloc ())
@


1.59
log
@Refactoring for constrained stock reallocation.
@
text
@d25 1
d56 1
d112 1
d509 4
@


1.58
log
@Refactoring for constrained stock reallocation.
@
text
@d108 6
a113 2
   while (! mySelMgrs_.isEmpty ())
      delete mySelMgrs_.get ();
@


1.57
log
@Initial implementation of pegging.
@
text
@a202 1
   WitSelMgr *   theSelMgr;
a206 4

   if (selSplit ())
      forEachEl (theSelMgr, mySelMgrs_)
         theSelMgr->postCommitSS ();
@


1.56
log
@Implemented an iteration upper bound for selection splitting.
@
text
@d27 1
a27 1
#include <HeurAllP.h>
d42 1
a42 1
WitSelector::WitSelector (WitHeurAllPerf * theHeurAllPerf):
d44 1
a44 1
      WitProbAssoc       (theHeurAllPerf),
d46 1
a46 1
      myHeurAllPerf_     (theHeurAllPerf),
d82 1
a82 1
      myExpRest_    = new WitExpRest    (myHeurAllPerf_);
d148 1
a148 1
      myHeurAllPerf_->commitMaxQtySel (netQty);
d172 2
a173 2
         myHeurAllPerf_->topPart ()->partName ().myCstring (),
         myHeurAllPerf_->topPer ());
d501 1
a501 1
   if (myHeurAllPerf_->buildAhead ())
@


1.55
log
@Templatized consumption multi-route.
@
text
@a492 2
   WitSelMgr * theSelMgr;

@


1.54
log
@Minor modification.
@
text
@d512 1
a512 1
   recordSelMgr (myCmrMgr_);
@


1.53
log
@An attempt to fix the link trouble on Windows for the multi-route templates.
@
text
@d510 1
a510 1
   recordSelMgr (myPmrMgr_->thisSelMgr ());
@


1.52
log
@Refactoring.
@
text
@d510 1
a510 1
   recordSelMgr (myPmrMgr_);
@


1.51
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@d114 1
a114 1
WitPeriod WitSelector::modelessExpPeriod (WitPart * thePart, WitPeriod fillPer)
d118 2
a119 2
         myBaMgr ()->selExpPeriod (thePart,    fillPer):
         thePart->explosionPeriod             (fillPer);
d124 1
a124 1
WitPeriod WitSelector::modelessExecPeriod (
d130 2
a131 2
         myMeMgr ()->selExecPeriod (theBopEnt, expPer):
         theBopEnt->expExecPeriod ()          [expPer];
a560 6
      if (multiRoute_)
         {
         myPmrMgr ()->printMultiChoices ();
         myCmrMgr ()->printMultiChoices ();
         }
   
@


1.50
log
@Renamed AltPt classes to SelPt classes.
@
text
@d71 2
a512 3

   if (myGlobalComp ()->selSplit ())
      mySplitter_ = new WitSplitter (this);
d521 15
@


1.49
log
@Removed class MePrinter.
@
text
@d16 1
a16 1
#include <AltPt.h>
d232 1
a232 1
WitBoolean WitSelector::getPendingPt (WitAltPt * & theAltPt)
d234 1
a234 1
   if (pendingPts_.pop (theAltPt))
d236 1
a236 1
      theAltPt->setPending (witFALSE);
d246 1
a246 1
void WitSelector::alterSelection (WitAltPt * theAltPt)
d248 1
a248 1
   theAltPt->alterSelection ();
d254 1
a254 1
      theAltPt->printSelection ();
d354 1
a354 1
   WitAltPt *  theAltPt;
d384 2
a385 2
         theAltPt = 
            theSelMgr->myAltPt (
d394 1
a394 1
               theAltPt = NULL;
d396 1
a396 1
         theReqPt->putDirectPoint (theAltPt, resFound, priorAlt);
d416 1
a416 1
   WitAltPt *  theAltPt;
d427 2
a428 2
      theAltPt = 
         theSelMgr->myAltPt (theBopEnt, NULL, execPer, fillPer, resFound);
d432 1
a432 1
            theAltPt = NULL;
d434 1
a434 1
      theReqPt->putDirectPointExecBounds (theAltPt, resFound);
d446 1
a446 1
   WitAltPt * theAltPt;
d456 1
a456 1
   while (getPendingPt (theAltPt));
d464 2
a465 2
      while (theReqPt->getDirectPoint (theAltPt))
         if (! theAltPt->pending ())
d467 1
a467 1
            pendingPts_.push (theAltPt);
d469 1
a469 1
            theAltPt->setPending (witTRUE);
d528 1
a528 1
   WitAltPt * theAltPt;
d537 2
a538 2
   while (getPendingPt (theAltPt))
      alterSelection (theAltPt);
@


1.48
log
@Removed class MeAltPt.
Changed name of class MeSelPt to MeAltPt.
Implemented de-selection of colliding MeAltPts.
@
text
@a24 1
#include <MePtr.h>
d557 1
a557 1
         myMePrinter ()->print ();
a626 7
   }

//------------------------------------------------------------------------------

WitMePrinter * WitSelector::myMePrinter ()
   {
   return myMeMgr ()->myMePrinter ();
@


1.47
log
@Added incAllocMsg.
@
text
@a195 16

   if (myGlobalComp ()->selPrintLevel () >= 2)
      if (multiExec ())
         myMePrinter ()->preprintAlts ();
   }

//------------------------------------------------------------------------------

void WitSelector::printPostAltIA ()
   {
   if (myGlobalComp ()->selPrintLevel () < 1)
      return;

   if (myGlobalComp ()->selPrintLevel () >= 2)
      if (multiExec ())
         myMePrinter ()->printAlts ();
a539 5

   if (multiExec ())
      myMeMgr ()->finishAlteration ();

   printPostAltIA ();
@


1.46
log
@Fixed a bug on multi-exec.
@
text
@a136 2
   printCommitMaxQtyIA ();

a538 12
   }

//------------------------------------------------------------------------------

void WitSelector::printCommitMaxQtyIA ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 2)
      fprintf (msgFile (),
         "\n"
         "SELECTING FOR PART %s IN PERIOD %d\n",
         myHeurAllPerf_->topPart ()->partName ().myCstring (),
         myHeurAllPerf_->topPer ());
@


1.45
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@d571 3
@


1.44
log
@Refactoring for selection splitting.
@
text
@a30 6
// Static Data Members.
//------------------------------------------------------------------------------

WitSelector * WitSelector::altPrtInst_ = NULL;

//------------------------------------------------------------------------------
a186 4
   witAssert (altPrtInst_ == NULL);

   altPrtInst_ = this;

a213 4

   witAssert (altPrtInst_ == this);

   altPrtInst_ = NULL;
@


1.43
log
@Added various counts to the debugging output of selection splitting.
@
text
@d19 2
a20 2
#include <ProdRtr.h>
#include <ConsRtr.h>
d58 2
a59 2
      myProdRtr_         (NULL),
      myConsRtr_         (NULL),
d89 1
a89 1
      myRtAnalyzer_ = new WitRtAnalyzer (this, myProdRtr (), myConsRtr ());
d530 2
a531 2
      myProdRtr_  = new WitProdRtr (this);
      myConsRtr_  = new WitConsRtr (this);
d541 1
a541 1
   recordSelMgr (myProdRtr_);
d543 1
a543 1
   recordSelMgr (myConsRtr_);
d596 2
a597 2
         myProdRtr ()->printMultiChoices ();
         myConsRtr ()->printMultiChoices ();
d613 2
a614 2
         myProdRtr ()->printHasAlt ();
         myConsRtr ()->printHasAlt ();
@


1.42
log
@Continuing development of selection splitting.
@
text
@d70 2
a71 1
      penExec_           (witFALSE)
d282 3
@


1.41
log
@Continuing development of selection splitting.
@
text
@d13 1
a13 8
// Contains the implementation of the following classes:
//
//    Selector
//    SelMgr
//    Splitter
//    ReqPtMgr
//    ReqPt
//    AltPt
a28 5
#include <AllMode.h>

//------------------------------------------------------------------------------
// Implementation of class Selector.
//------------------------------------------------------------------------------
a676 614
   }

//------------------------------------------------------------------------------
// Implementation of class SelMgr.
//------------------------------------------------------------------------------

WitSelMgr::~WitSelMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitSelMgr::finishSplitExp ()
   {
   witAssert (splitExpActive_);

   boundedSplit_ = witFALSE;
                            
   if (DEBUG_MODE)
      splitExpActive_ = witFALSE;
   }

//------------------------------------------------------------------------------

WitSelMgr::WitSelMgr (WitSelector * theSelector):
      WitProbAssoc     (theSelector),

      mySelector_      (theSelector),
      selSplit_        (myGlobalComp ()->selSplit ()),
      boundedSplit_    (witFALSE),
      splitExpActive_  (witFALSE),
      splitListItr_    (),
      netToSplitVol_   (0.0),
      unbnddSplitObj_  (NULL),
      splitAtSearchPt_ (witFALSE)
   {
   }

//------------------------------------------------------------------------------

void WitSelMgr::startSplitExpAbs (
      const WitTlDblStack & splitList,
      WitTl *               unbnddObj,
      double                toSplitVol,
      WitAltPt *            theAltPt)
   {
   witAssert (selSplit_);
   witAssert (! splitExpActive_);
   witAssert (! boundedSplit ());
   witAssert (unbnddObj != NULL);
   witAssert (toSplitVol > NET_TOL);

   if (DEBUG_MODE)
      splitExpActive_ = witTRUE;

   splitListItr_.attachTo (splitList);

   netToSplitVol_   = toSplitVol;
   unbnddSplitObj_  = unbnddObj;

   splitAtSearchPt_ = mySplitter ()->isSearchingAt (theAltPt);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelMgr::findNextSplitAbs (WitTl * & splitObj, double & splitVol)
   {
   double splitBound;

   witAssert (selSplit_);
   witAssert (splitExpActive_);

   if (netToSplitVol_ <=  NET_TOL)
      return witFALSE;

   while (witTRUE)
      {
      boundedSplit_ = splitListItr_.advance (splitObj, splitBound);

      if (! boundedSplit_)
         {
         splitObj       = unbnddSplitObj_;
         splitVol       = netToSplitVol_;
         netToSplitVol_ = 0.0;

         if (splitAtSearchPt_)
            mySplitter ()->applySearchVol (splitVol);

         break;
         }

      adjustSplitBound (splitObj, splitBound);

      if (splitBound > NET_TOL)
         {
         splitVol        = min (splitBound, netToSplitVol_);

         netToSplitVol_ -= splitVol;

         break;
         }
      }

   prtSelSplitIA (splitObj, splitVol, splitBound);

   return witTRUE;
   }

//------------------------------------------------------------------------------

void WitSelMgr::prtSelSplitIA (
      WitTl * splitObj, 
      double  splitVol, 
      double  splitBound)
   {
   witAssert (selSplit_);

   if (myGlobalComp ()->selPrintLevel () < 4)
      return;

   if (mySelector_->myHeurAllPerf ()->myAllocMode ()->temp ())
      return;

   prtSelSplit (splitObj);
               
   fprintf    (msgFile (), "   SplitVol:    %.3f\n", splitVol);
               
   if (! boundedSplit_)
      fprintf (msgFile (), "   Split Bound: None\n");

   else if (splitBound == splitVol)
      fprintf (msgFile (), "   Split Bound: Same\n");
   else
      fprintf (msgFile (), "   Split Bound: %.3f\n", splitBound);
   }

//------------------------------------------------------------------------------
// Implementation of class Splitter.
//------------------------------------------------------------------------------

WitSplitter::WitSplitter (WitSelector * theSelector):
      WitProbAssoc     (theSelector),

      mySelector_      (theSelector),
      splitRes_        (myGlobalComp ()->splitRes ()),
      splitCommActive_ (witFALSE),
      flowMonMode_     (witFALSE),
       curFlowPairs_   (myProblem ()),
        okFlowPairs_   (myProblem ()),
      failFlowPairs_   (myProblem ()),
      searchPt_        (NULL),
      netSearchVol_    (-1.0)
   {
   myMsgFac () ("selSplitMsg");
   }

//------------------------------------------------------------------------------

WitSplitter::~WitSplitter ()
   {
   }

//------------------------------------------------------------------------------

void WitSplitter::startFlowMon ()
   {
   witAssert (! flowMonMode_);

   flowMonMode_ = witTRUE;
   }

//------------------------------------------------------------------------------

void WitSplitter::recordFlow (WitAltPt * theAltPt, double incFlowVol)
   {
   witAssert (theAltPt->splittable ());

   if (flowMonMode_)
      if (! theAltPt->mySelMgr (mySelector_)->boundedSplit ())
         curFlowPairs_.push (theAltPt, incFlowVol);
   }

//------------------------------------------------------------------------------

void WitSplitter::postTempCommit (WitBoolean success)
   {
   if (flowMonMode_)
      {
      if (success)
           okFlowPairs_.takeContents (curFlowPairs_);
      else
         failFlowPairs_.takeContents (curFlowPairs_);
      }
   }

//------------------------------------------------------------------------------

void WitSplitter::alterSelections ()
   {
   WitAltPt * theAltPt;
   double     dummyFlowGap;
   WitBoolean splitNeeded;

   mySelector_->printPreAltIA ();

   if (! mySelector_->getPendingPt (theAltPt))
      {
      finishFlowMon ();

      return;
      }

   splitNeeded = splitIsNeeded (theAltPt, dummyFlowGap);

   finishFlowMon ();

   if (splitNeeded)
      splitCommit (theAltPt);
   else
      mySelector_->alterSelection (theAltPt);

   mySelector_->printPostAltIA ();
   }

//------------------------------------------------------------------------------

void WitSplitter::applySearchVol (double & splitVol)
   {
   if (netSearchVol_ < splitVol)
      {
      splitVol       = netSearchVol_;

      netSearchVol_  = 0.0;
      }
   else
      netSearchVol_ -= splitVol;
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::splitIsNeeded (WitAltPt * theAltPt, double & flowGap)
   {
   WitPairStItr (WitAltPt, double) theItr;
   WitAltPt *                      curAltPt;
   double                          incFlowVol;

   witAssert (flowMonMode_);
   witAssert (theAltPt != NULL);

   flowGap = 0.0;

   if (! theAltPt->splittable ())
      return witFALSE;

   theItr.attachTo (failFlowPairs_);

   while (theItr.advance (curAltPt, incFlowVol))
      if (curAltPt == theAltPt)
         flowGap += incFlowVol;

   theItr.attachTo (okFlowPairs_);

   while (theItr.advance (curAltPt, incFlowVol))
      if (curAltPt == theAltPt)
         flowGap -= incFlowVol;

   return (flowGap > splitRes_ + SEARCH_TOL);
   }

//------------------------------------------------------------------------------

void WitSplitter::splitCommit (WitAltPt * theAltPt)
   {
   WitBoolean  tempCommOK;
   WitBoolean  resFound;
   WitBoolean  splitDone;
   WitSelMgr * theSelMgr;

   witAssert (! splitCommActive_);

   splitCommActive_ = witTRUE;

   splitItr (tempCommOK, resFound, splitDone);

   if (tempCommOK || ! resFound)
      mySelector_->alterSelection (theAltPt);
   else if (splitDone)
      {
      while (resFound)
         splitItr (tempCommOK, resFound, splitDone);

      if (tempCommOK)
         mySelector_->myHeurAllPerf ()->permCommit1SS ();
      }

   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      theSelMgr->postSplitCommit ();

   splitCommActive_ = witFALSE;
   }

//------------------------------------------------------------------------------

void WitSplitter::finishFlowMon ()
   {
   witAssert (flowMonMode_);

     okFlowPairs_.clear ();
   failFlowPairs_.clear ();

   flowMonMode_ = witFALSE;
   }

//------------------------------------------------------------------------------

void WitSplitter::splitItr (
      WitBoolean & tempCommOK, 
      WitBoolean & resFound,
      WitBoolean & splitDone)
   {
   WitAltPt * theAltPt;
   double     theFlowVol;

   resFound   = witFALSE;
   splitDone  = witFALSE;

   startFlowMon ();

   tempCommOK = mySelector_->myHeurAllPerf ()->tempCommit (1.0);

   if (tempCommOK)
      {
      finishFlowMon ();

      return;
      }

   resFound = mySelector_->getPendingPt (theAltPt);

   if (! resFound)
      {
      finishFlowMon ();

      return;
      }

   splitDone = splitIsNeeded (theAltPt, theFlowVol);

   finishFlowMon ();

   if (splitDone)
      splitSelection (theAltPt, theFlowVol);

   mySelector_->alterSelection (theAltPt);
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::splitSelection (WitAltPt * theAltPt, double theFlowVol)
   {
   int        upperGP;
   int        lowerGP;
   int        midGP;
   WitBoolean success;

   success = tempCommForSearch (theAltPt, splitRes_);

   if (! success)
      return witFALSE;

   lowerGP = 1;
   upperGP = ceil (theFlowVol / splitRes_);

   witAssert (upperGP >= 2);

   midGP = 1;

   while (upperGP - lowerGP > 1)
      {
      midGP      = (lowerGP + upperGP) / 2;

      success    = tempCommForSearch (theAltPt, midGP * splitRes_);

      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
      }

   theAltPt->splitSelection (lowerGP * splitRes_);

   return witTRUE;
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::tempCommForSearch (
      WitAltPt * theAltPt, 
      double     searchVol)
   {
   WitBoolean tempCommOK;
   WitAltPt * tracePt;

   witAssert (theAltPt  != NULL);
   witAssert (searchPt_ == NULL);

   searchPt_     = theAltPt;
   netSearchVol_ = searchVol;

   tempCommOK    = mySelector_->myHeurAllPerf ()->tempCommit (1.0);

   netSearchVol_ = -1.0;
   searchPt_     = NULL;

   if (tempCommOK)
      return witTRUE;

   if (! mySelector_->getPendingPt (tracePt))
      return witTRUE;

   if (tracePt != theAltPt)
      return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------
// Implementation of class ReqPtMgr.
//------------------------------------------------------------------------------

WitReqPtMgr::WitReqPtMgr (WitProblem * theProblem):
      WitProbAssoc  (theProblem),

      myReqPtTl_    (),
      allocedSlots_ (myProblem ()),
      unusedPoints_ (myProblem ())
   {
   myReqPtTl_.allocate (myProblem (), NULL);
   }

//------------------------------------------------------------------------------

WitReqPtMgr::~WitReqPtMgr ()
   {
   WitReqPt * thePoint;

   reset ();

   while (unusedPoints_.pop (thePoint))
      delete thePoint;
   }

//------------------------------------------------------------------------------

WitReqPt * WitReqPtMgr::myReqPt (WitPart * thePart, WitPeriod thePer)
   {
   WitReqPt * & thePointRef = myReqPtRef (thePart, thePer);

   if (thePointRef == NULL)
      {
      if (! unusedPoints_.pop (thePointRef))
         thePointRef = new WitReqPt (myProblem ());

      allocedSlots_.push (& thePointRef);
      }

   return thePointRef;
   }

//------------------------------------------------------------------------------

void WitReqPtMgr::reset ()
   {
   WitReqPtPtr * thePtr;

   while (allocedSlots_.pop (thePtr))
      {
      WitReqPt * & thePointRef = * thePtr;

      thePointRef->reset ();

      unusedPoints_.push (thePointRef);

      thePointRef = NULL;
      }
   }

//------------------------------------------------------------------------------
// Implementation of class ReqPt.
//------------------------------------------------------------------------------

WitReqPt::WitReqPt (WitProblem * theProblem):
      directPts_ (theProblem),
      source_    (NULL),
      hasResAlt_ (witFALSE)
   {
   }

//------------------------------------------------------------------------------

WitReqPt::~WitReqPt ()
   {
   }

//------------------------------------------------------------------------------

WitBoolean WitReqPt::hasAlt ()
   {
   return (source_ != NULL) || (! directPts_.isEmpty ());
   }

//------------------------------------------------------------------------------

void WitReqPt::setSource (WitReqPt * theSource, WitBoolean & priorAlt)
   {
   witAssert (theSource != NULL);

   if (! theSource->hasAlt ())
      return;

   if (theSource->hasResAlt ())
      {
      reset ();
            
      hasResAlt_ = witTRUE;
      priorAlt   = witFALSE;
      }        
   else 
      if (priorAlt)
         return;

   source_ = theSource;
   }

//------------------------------------------------------------------------------

void WitReqPt::putDirectPoint (
      WitAltPt *   theAltPt,
      WitBoolean   resFound,
      WitBoolean & priorAlt)
   {
   if (theAltPt == NULL)
      return;

   if (resFound)
      {
      reset ();
            
      hasResAlt_ = witTRUE;
      priorAlt   = witFALSE;
      }        
   else
      if (priorAlt)
         return;

   directPts_.push (theAltPt);
   }

//------------------------------------------------------------------------------

void WitReqPt::putDirectPointExecBounds (
      WitAltPt * theAltPt,
      WitBoolean resFound)
   {
   if (theAltPt == NULL)
      return;

   if (resFound)
      {
      reset ();
            
      hasResAlt_ = witTRUE;
      }        

   directPts_.push (theAltPt);
   }

//------------------------------------------------------------------------------

void WitReqPt::reset ()
   {
   directPts_.clear ();

   source_    = NULL;
   hasResAlt_ = witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitReqPt::getDirectPoint (WitAltPt * & theAltPt)
   {
   return directPts_.pop (theAltPt);
   }

//------------------------------------------------------------------------------
// Implementation of class AltPt.
//------------------------------------------------------------------------------

WitAltPt::WitAltPt ():
      pending_ (witFALSE)
   {
   }

//------------------------------------------------------------------------------

WitAltPt::~WitAltPt ()
   {
   }

//------------------------------------------------------------------------------

void WitAltPt::setPending (WitBoolean theValue)
   {
   pending_ = theValue;
@


1.40
log
@Re-worked the controls for selection splitting.
@
text
@d864 2
d939 3
@


1.39
log
@Continued implementation of selection splitting.
@
text
@d253 1
a253 2
         if (theSelMgr->selSplit ())
            theSelMgr->postCommitSS ();
d553 2
a554 8
   if (myGlobalComp ()->allowSS ())
      forEachEl (theSelMgr, mySelMgrs_)
         if (theSelMgr->selSplit ())
            {
            mySplitter_ = new WitSplitter (this);

            break;
            }
d713 1
a713 1
WitSelMgr::WitSelMgr (WitSelector * theSelector, WitBoolean selSplitVal):
d717 1
a717 1
      selSplit_        (selSplitVal),
d833 1
a935 3
   if (! theAltPt->splittable ())
      return witFALSE;

d950 1
a950 1
   return (flowGap > theAltPt->splitRes () + SEARCH_TOL);
d980 1
a980 2
      if (theSelMgr->selSplit ())
         theSelMgr->postSplitCommit ();
a1043 1
   double     splitResVal;
d1049 1
a1049 5
   witAssert (theAltPt->splittable ());

   splitResVal = theAltPt->splitRes ();

   success     = tempCommForSearch (theAltPt, splitResVal);
d1055 1
a1055 1
   upperGP = ceil (theFlowVol / splitResVal);
d1065 1
a1065 1
      success    = tempCommForSearch (theAltPt, midGP * splitResVal);
d1073 1
a1073 1
   theAltPt->splitSelection (lowerGP * splitResVal);
@


1.38
log
@Continued implementation of selection splitting.
@
text
@d721 1
a721 1
      WitProbAssoc    (theSelector),
d723 8
a730 7
      mySelector_     (theSelector),
      selSplit_       (selSplitVal),
      boundedSplit_   (witFALSE),
      splitExpActive_ (witFALSE),
      splitListItr_   (),
      netToSplitVol_  (0.0),
      unbnddSplitObj_ (NULL)
d753 2
a754 2
   netToSplitVol_  = toSplitVol;
   unbnddSplitObj_ = unbnddObj;
d756 1
a756 1
   mySplitter ()->applySearchVolIA (theAltPt, netToSplitVol_);
d781 3
d824 1
a824 1
      fprintf (msgFile (), "   Split Bound: Infinity\n");
d837 1
a837 1
      WitProbAssoc   (theSelector),
d839 8
a846 7
      mySelector_    (theSelector),
      flowMonMode_   (witFALSE),
       curFlowPairs_ (myProblem ()),
        okFlowPairs_ (myProblem ()),
      failFlowPairs_ (myProblem ()),
      searchPt_      (NULL),
      netSearchVol_  (-1.0)
d871 2
a872 1
      curFlowPairs_.push (theAltPt, incFlowVol);
d919 1
a919 1
void WitSplitter::applySearchVolIA (WitAltPt * theAltPt, double & netToSplitVol)
d921 1
a921 4
   if (theAltPt != searchPt_)
      return;

   if (netSearchVol_ < netToSplitVol)
d923 1
a923 1
      netToSplitVol  = netSearchVol_;
d928 1
a928 1
      netSearchVol_ -= netToSplitVol;
d971 4
d978 2
d981 2
a982 1
      mySelector_->alterSelection (theAltPt);
d984 2
a985 1
      return;
a987 9
   if (! splitDone)
      return;

   while (resFound)
      splitItr (tempCommOK, resFound, splitDone);

   if (tempCommOK)
      mySelector_->myHeurAllPerf ()->permCommit1SS ();

d990 3
a992 1
         theSelMgr->clearSplitSched ();
@


1.37
log
@Continued implementation of selection splitting.
@
text
@d729 1
a729 2
      unbnddSplitObj_ (NULL),
      atSearchPt_     (witFALSE)
a753 1
   atSearchPt_     = mySplitter ()->isSearchingAt (theAltPt);
d755 1
a755 1
   witAssert ((! splitList.isEmpty ()) || atSearchPt_);
d770 1
a770 3
   splitBound = 0.0;

   while (splitBound <= NET_TOL)
d780 1
a780 6
         if (atSearchPt_)
            mySplitter ()->boundBySearchVol (splitVol);

         prtSelSplitIA (splitObj, splitVol, splitBound);

         return witTRUE;
a783 1
      }
d785 5
a789 1
   splitVol        = min (splitBound, netToSplitVol_);
d791 3
a793 1
   netToSplitVol_ -= splitVol;
d913 1
a913 1
void WitSplitter::boundBySearchVol (double & splitVol)
d915 4
a918 1
   if (netSearchVol_ < splitVol)
d920 1
a920 1
      splitVol       = netSearchVol_;
d925 1
a925 1
      netSearchVol_ -= splitVol;
@


1.36
log
@Continued implementation of selection splitting with the new design.
@
text
@d82 1
a82 2
      penExec_           (witFALSE),
      mslInitState_      (witFALSE)
d152 1
a152 1
void WitSelector::initMultiSelLoop ()
d154 1
a154 1
   witAssert (! mslInitState_);
d156 27
a182 1
   mslInitState_ = witTRUE;
d184 3
a186 1
   if (myGlobalComp ()->selPrintLevel () >= 2)
d189 1
a189 1
         "SELECTING FOR PART %s IN PERIOD %d\n",
d196 1
a196 1
WitBoolean WitSelector::contMultiSelLoop ()
d198 2
a199 3
   if (! mslInitState_)
      if (! findFreshScheme ())
         return witFALSE;
d201 2
a202 2
   mslInitState_ = witFALSE;
   failResAlt_   = witFALSE;
d204 15
a218 2
   if (penExec_)
      myRtAnalyzer ()->modifyRouting ();
d220 3
a222 1
   return witTRUE;
d227 1
a227 1
void WitSelector::printCommitMaxQtySelIA ()
d229 10
a238 6
   if (myGlobalComp ()->selPrintLevel () >= 3)
      fprintf (msgFile (),
         "\n"
         "Commit Max Qty Selected: Part %s, Period %d\n",
         myHeurAllPerf_->topPart ()->partName ().myCstring (),
         myHeurAllPerf_->topPer ());
d574 13
a586 1
WitBoolean WitSelector::findFreshScheme ()
a587 2
   WitBoolean pseudoShortOnly;
   WitBoolean printNeeded;
d590 1
a590 7
   if (penExec_)
      {
      myExpRest ()->update (pseudoShortOnly);
      
      if (pseudoShortOnly)
         return witTRUE;
      }
d592 2
a593 3
   printNeeded = 
         (myGlobalComp ()->selPrintLevel () >= 1)
      && (! pendingPts_.isEmpty ());
d595 1
a595 2
   if (printNeeded)
      printPreAlt ();
a597 9
      {
      if (selSplit ())
         {
         witAssert (failResAlt_);
         
         if (mySplitter ()->splitCommitIfNeeded (theAltPt))
            break;
         }

a598 1
      }
d600 1
a600 7
   if (printNeeded)
      printPostAlt ();

   if (selSplit ())
      mySplitter ()->clearFlows ();

   return failResAlt_;
a634 38
void WitSelector::printPreAlt ()
   {
   witAssert (altPrtInst_ == NULL);

   altPrtInst_ = this;

   if (myGlobalComp ()->selPrintLevel () >= 2)
      fprintf (msgFile (),
         "\n"
         "-----------------------------\n"
         "Altering the Selection Scheme\n"
         "-----------------------------\n\n"
         "Alteration potentially resolves shortage? %s\n",
         myMsgFac ().booleanText (failResAlt_));

   if (myGlobalComp ()->selPrintLevel () >= 1)
      altCounts_.append (new int (pendingPts_.nElements ()));

   if (myGlobalComp ()->selPrintLevel () >= 2)
      if (multiExec ())
         myMePrinter ()->preprintAlts ();
   }

//------------------------------------------------------------------------------

void WitSelector::printPostAlt ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 2)
      if (multiExec ())
         myMePrinter ()->printAlts ();

   witAssert (altPrtInst_ == this);

   altPrtInst_ = NULL;
   }

//------------------------------------------------------------------------------

d840 1
d858 9
d869 1
a869 1
   if (mySelector_->myHeurAllPerf ()->myAllocMode ()->temp ())
d877 7
a883 4
   if (success)
        okFlowPairs_.takeContents (curFlowPairs_);
   else
      failFlowPairs_.takeContents (curFlowPairs_);
d888 1
a888 1
WitBoolean WitSplitter::splitCommitIfNeeded (WitAltPt * theAltPt)
d890 3
a892 8
   double      dummyFlowGap;
   WitBoolean  splitNeeded;
   WitBoolean  tempCommOK;
   WitBoolean  resFound;
   WitBoolean  splitDone;
   WitSelMgr * theSelMgr;

   splitNeeded = checkForSplit (theAltPt, dummyFlowGap);
d894 1
a894 4
   clearFlows ();

   if (! splitNeeded)
      return witFALSE;
d896 1
a896 3
   splitItr (tempCommOK, resFound, splitDone);

   if (tempCommOK || ! resFound)
d898 1
a898 1
      mySelector_->alterSelection (theAltPt);
d900 1
a900 1
      return witTRUE;
d903 1
a903 5
   if (! splitDone)
      return witTRUE;

   while (resFound)
      splitItr (tempCommOK, resFound, splitDone);
d905 1
a905 2
   if (tempCommOK)
      mySelector_->myHeurAllPerf ()->permCommit1SS ();
d907 4
a910 3
   forEachEl (theSelMgr, mySelector_->mySelMgrs ())
      if (theSelMgr->selSplit ())
         theSelMgr->clearSplitSched ();
d912 1
a912 9
   return witTRUE;
   }

//------------------------------------------------------------------------------

void WitSplitter::clearFlows ()
   {
     okFlowPairs_.clear ();
   failFlowPairs_.clear ();
d931 1
a931 1
WitBoolean WitSplitter::checkForSplit (WitAltPt * theAltPt, double & flowGap)
d937 1
d962 44
d1017 2
d1023 1
a1023 1
      clearFlows ();
d1028 1
a1028 1
   resFound   = mySelector_->getPendingPt (theAltPt);
d1032 1
a1032 1
      clearFlows ();
d1037 1
a1037 1
   splitDone  = checkForSplit (theAltPt, theFlowVol);
d1039 1
a1039 1
   clearFlows ();
a1048 30
WitBoolean WitSplitter::tempCommit1 (WitAltPt * theAltPt, double searchVol)
   {
   WitBoolean tempCommOK;
   WitAltPt * tracePt;

   witAssert (theAltPt  != NULL);
   witAssert (searchPt_ == NULL);

   searchPt_     = theAltPt;
   netSearchVol_ = searchVol;

   tempCommOK    = mySelector_->myHeurAllPerf ()->tempCommit (1.0);

   netSearchVol_ = -1.0;
   searchPt_     = NULL;

   if (tempCommOK)
      return witTRUE;

   if (! mySelector_->getPendingPt (tracePt))
      return witTRUE;

   if (tracePt != theAltPt)
      return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

d1061 1
a1061 1
   success     = tempCommit1 (theAltPt, splitResVal);
d1077 1
a1077 1
      success    = tempCommit1 (theAltPt, midGP * splitResVal);
d1088 32
@


1.35
log
@Fixed a bug in selection splitting.
@
text
@d43 6
d246 10
d553 3
d557 2
a558 3
            return witTRUE;

      theAltPt->alterSelection ();
d560 1
a560 2
      if (printNeeded)
         print (theAltPt);
d606 4
a628 8
void WitSelector::print (WitAltPt * theAltPt)
   {
   if (myGlobalComp ()->selPrintLevel () >= 2)
      theAltPt->printSelection (this);
   }

//------------------------------------------------------------------------------

d634 4
d792 1
a792 1
            mySplitter ()->netWithSearchVol (splitVol);
d828 1
a828 1
   fprintf    (msgFile (), "      SplitVol:    %.3f\n", splitVol);
d831 1
a831 1
      fprintf (msgFile (), "      Split Bound: Infinity\n");
d834 1
a834 1
      fprintf (msgFile (), "      Split Bound: Same\n");
d836 1
a836 1
      fprintf (msgFile (), "      Split Bound: %.3f\n", splitBound);
d866 2
a867 1
   curFlowPairs_.push (theAltPt, incFlowVol);
d885 1
d891 5
a895 1
   if (! checkForSplit (theAltPt, dummyFlowGap))
d902 1
a902 1
      theAltPt->alterSelection ();
d933 1
a933 1
void WitSplitter::netWithSearchVol (double & splitVol)
d935 8
a942 1
   net (splitVol, netSearchVol_);
d949 3
a951 2
   WitAltPt * curAltPt;
   double     incFlowVol;
d960 3
a962 1
   while (failFlowPairs_.pop (curAltPt, incFlowVol))
d966 3
a968 1
   while (  okFlowPairs_.pop (curAltPt, incFlowVol))
d991 3
d995 1
d1008 2
d1013 1
a1013 1
   theAltPt->alterSelection ();
@


1.34
log
@Continued implementation of selection splitting with the new design.
@
text
@d891 1
a891 1
      mySelector_->myHeurAllPerf ()->permCommit (1.0);
@


1.33
log
@Continued implementation of selection splitting with the new design.
@
text
@a76 2
      mslPart_           (NULL),
      mslPer_            (-1),
d147 1
a147 1
void WitSelector::initMultiSelLoop (WitPart * thePart, WitPeriod thePer)
a148 2
   witAssert (mslPart_ == NULL);

a150 2
   mslPart_      = thePart;
   mslPer_       = thePer;
d157 2
a158 2
         thePart->partName ().myCstring (),
         thePer);
a164 2
   witAssert (mslPart_ != NULL);

a166 3
         {
         mslPart_ = NULL;

a167 1
         }
d173 1
a173 1
      modifyRouting (mslPart_, mslPer_);
d180 1
a180 1
void WitSelector::printCommitMaxQtySelIA (WitPart * thePart, WitPeriod thePer)
d186 2
a187 2
         thePart->partName ().myCstring (),
         thePer);
a225 9
WitBoolean WitSelector::tempCommit1SS ()
   {
   witAssert (mslPart_ != NULL);

   return myHeurAllPerf_->tempCommit1SS (mslPart_, mslPer_);
   }

//------------------------------------------------------------------------------

d465 1
a465 1
   myRtAnalyzer_->recCommitVol (commitVol, byExp);
a512 19
void WitSelector::modifyRouting (WitPart * thePart, WitPeriod thePer)
   {
   WitBopEntPerStack  theBopEntPers  (myProblem ());
   WitConsEntPerStack theConsEntPers (myProblem ());

   witAssert (penExec_);

   myRtAnalyzer_->analyzeRoutings (
      thePart, 
      thePer, 
      theBopEntPers,
      theConsEntPers);

   myProdRtr ()->modifyRouting (theBopEntPers);
   myConsRtr ()->modifyRouting (theConsEntPers);
   }

//------------------------------------------------------------------------------

a517 1
   double     dummyFlowGap;
d537 1
a537 9
         {
         witAssert (pendingPts_.isEmpty ());

         witAssert (failResAlt_);

         if (mySplitter ()->checkForSplit (theAltPt, dummyFlowGap))
            {
            splitCommit (theAltPt);

a538 2
            }
         }
a556 51
void WitSelector::splitCommit (WitAltPt * theAltPt)
   {
   witAssert (selSplit ());

   theAltPt->alterSelection ();

   if (myGlobalComp ()->selPrintLevel () >= 1)
      {
      print (theAltPt);

      printPostAlt ();
      }
   }

//------------------------------------------------------------------------------

void WitSelector::splitItr (WitBoolean & tempCommOK, WitBoolean & resFound)
   {
   WitAltPt * theAltPt;
   double     theFlowVol;

   witAssert (selSplit ());

   resFound   = witFALSE;

   tempCommOK = tempCommit1SS ();

   if (tempCommOK)
      return;

   resFound = failResAlt_;

   if (! resFound)
      {
      mySplitter ()->clearFlows ();

      return;
      }

   witAssert (pendingPts_.nElements () == 1);

   getPendingPt (theAltPt);

   if (mySplitter ()->checkForSplit (theAltPt, theFlowVol))
      mySplitter ()->splitSelection (theAltPt, theFlowVol);

   theAltPt->alterSelection ();
   }

//------------------------------------------------------------------------------

d864 53
d942 4
a945 1
void WitSplitter::clearFlows ()
d947 2
a948 3
     okFlowPairs_.clear ();
   failFlowPairs_.clear ();
   }
d950 2
a951 1
//------------------------------------------------------------------------------
d953 1
a953 7
void WitSplitter::splitSelection (WitAltPt * theAltPt, double theFlowVol)
   {
   double     splitResVal;
   int        upperGP;
   int        lowerGP;
   int        midGP;
   WitBoolean success;
d955 1
a955 7
   witAssert (theAltPt->splittable ());

   splitResVal = theAltPt->splitRes ();

   success     = tempCommit1 (theAltPt, splitResVal);

   if (! success)
d958 1
a958 4
   lowerGP = 1;
   upperGP = ceil (theFlowVol / splitResVal);

   witAssert (upperGP >= 2);
d960 1
a960 3
   midGP = 1;

   while (upperGP - lowerGP > 1)
d962 1
a962 1
      midGP      = (lowerGP + upperGP) / 2;
d964 1
a964 6
      success    = tempCommit1 (theAltPt, midGP * splitResVal);

      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
d967 1
a967 2
   theAltPt->splitSelection (lowerGP * splitResVal);
   }
d969 2
a970 1
//------------------------------------------------------------------------------
d972 1
a972 3
void WitSplitter::netWithSearchVol (double & splitVol)
   {
   net (splitVol, netSearchVol_);
d988 1
a988 1
   tempCommOK    = mySelector_->tempCommit1SS ();
d1003 43
@


1.32
log
@Continued implementation of selection splitting.
@
text
@d76 4
a79 1
      penExec_           (witFALSE)
d149 1
a149 1
void WitSelector::prepCommitMaxQtyMultiSel (WitPart * thePart, WitPeriod thePer)
d151 8
d169 1
a169 1
void WitSelector::prepCommitMaxQtySel (WitPart * thePart, WitPeriod thePer)
d171 12
a182 1
   failResAlt_ = witFALSE;
d185 3
a187 1
      modifyRouting (thePart, thePer);
a203 108
WitBoolean WitSelector::findFreshScheme ()
   {
   WitBoolean pseudoShortOnly;
   WitBoolean printNeeded;
   WitAltPt * theAltPt;

   if (selSplit ())
      mySplitter ()->clearSplit ();

   if (penExec_)
      {
      myExpRest ()->update (pseudoShortOnly);
      
      if (pseudoShortOnly)
         return witTRUE;
      }

   printNeeded = 
         (myGlobalComp ()->selPrintLevel () >= 1)
      && (! pendingPts_.isEmpty ());

   if (printNeeded)
      printPreAlt ();

   while (pendingPts_.pop (theAltPt))
      {
      theAltPt->setPending (witFALSE);

      if (selSplit ())
         {
         witAssert (pendingPts_.isEmpty ());

         witAssert (failResAlt_);

         if (mySplitter ()->checkForSplit (theAltPt))
            return witTRUE;
         }

      theAltPt->alterSelection ();

      if (printNeeded)
         print (theAltPt);
      }

   if (printNeeded)
      printPostAlt ();

   if (selSplit ())
      mySplitter ()->clearFlows ();

   return failResAlt_;
   }

//------------------------------------------------------------------------------

void WitSelector::splitCommit ()
   {
   WitAltPt * theAltPt;

   witAssert (selSplit ());

   witAssert (mySplitter ()->splitNeeded ());

   theAltPt = mySplitter ()->splitAltPt ();
   
   theAltPt->alterSelection ();

   theAltPt->setPending (witFALSE);

   if (myGlobalComp ()->selPrintLevel () >= 1)
      {
      print (theAltPt);

      printPostAlt ();
      }
   }

//------------------------------------------------------------------------------

void WitSelector::splitItr (WitBoolean & resFound, WitBoolean & needToSplit)
   {
   WitAltPt * theAltPt;

   witAssert (selSplit ());

   resFound    = failResAlt_;

   needToSplit = witFALSE;

   if (resFound)
      {
      witAssert (pendingPts_.nElements () == 1);

      pendingPts_.pop (theAltPt);

      theAltPt->setPending (witFALSE);

      needToSplit = mySplitter ()->checkForSplit (theAltPt);

      if (! needToSplit)
         theAltPt->alterSelection ();
      }

   mySplitter ()->clearFlows ();
   }

//------------------------------------------------------------------------------

d238 23
d458 1
a458 2
   while (pendingPts_.pop (theAltPt))
      theAltPt->setPending (witFALSE);
d518 1
a518 1
            mySplitter_ = new WitSplitter (myProblem ());
d553 106
d821 2
a822 1
      unbnddSplitObj_ (NULL)
d831 2
a832 1
      double                toSplitVol)
d834 1
a835 1
   witAssert (! splitList.isEmpty ());
d847 3
d858 1
d876 3
d887 1
a887 1
   splitVol = min (splitBound, netToSplitVol_);
d903 2
d928 2
a929 2
WitSplitter::WitSplitter (WitProblem * theProblem):
      WitProbAssoc   (theProblem),
d931 1
d935 2
a936 1
      splitAltPt_    (NULL)
d966 1
a966 8
void WitSplitter::clearSplit ()
   {
   splitAltPt_ = NULL;
   }

//------------------------------------------------------------------------------

WitBoolean WitSplitter::checkForSplit (WitAltPt * theAltPt)
a967 1
   double     theGap;
a972 2
   splitAltPt_ = NULL;

d976 1
a976 1
   theGap = 0.0;
d980 1
a980 1
         theGap += incFlowVol;
d984 1
a984 4
         theGap -= incFlowVol;

   if (theGap > theAltPt->splitRes () + SEARCH_TOL)
      splitAltPt_ = theAltPt;
d986 1
a986 1
   return (splitAltPt_ != NULL);
d995 78
@


1.31
log
@Continued implementation of selection splitting.
@
text
@d71 2
a72 1
      resolvingAlt_      (witFALSE),
d160 1
a160 1
   resolvingAlt_ = witFALSE;
d206 2
d212 2
a219 2
      theAltPt->setPending (witFALSE);

d230 1
a230 1
   return resolvingAlt_;
d259 1
a259 1
void WitSelector::postCommit (WitBoolean tempMode, WitBoolean success)
d261 7
a267 2
   WitSelMgr *   theSelMgr;
   WitMaterial * theMat;
d269 1
a269 1
   if (tempMode)
d271 5
a275 1
      myReqPtMgr_->reset ();
d277 4
a280 2
      if (penExec_)
         myExpRest ()->postTempCommit (success);
d283 10
a296 1
      {
d300 12
d313 5
a317 3
      if (tempMode)
         mySplitter ()->postTempCommit (success);
      }
d522 1
a522 1
   theReqPt      = myReqPt (thePart, thePer);
d524 1
a524 1
   resolvingAlt_ = theReqPt->hasResAlt ();
d541 1
a541 1
         witAssert (! resolvingAlt_);
d654 1
a654 1
         myMsgFac ().booleanText (resolvingAlt_));
@


1.30
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d145 1
a145 1
void WitSelector::printHeadingIA (WitPart * thePart, WitPeriod thePer)
d157 10
d181 3
a183 1
   WitBoolean schemeIsFresh;
d185 38
a222 1
   schemeIsFresh = innerFindFresh ();
d227 25
a251 1
   return schemeIsFresh;
a500 1
   }
d502 3
a504 17
//------------------------------------------------------------------------------

void WitSelector::modifyRouting (WitPart * thePart, WitPeriod thePer)
   {
   WitBopEntPerStack  theBopEntPers  (myProblem ());
   WitConsEntPerStack theConsEntPers (myProblem ());

   witAssert (penExec_);

   myRtAnalyzer_->analyzeRoutings (
      thePart, 
      thePer, 
      theBopEntPers,
      theConsEntPers);

   myProdRtr ()->modifyRouting (theBopEntPers);
   myConsRtr ()->modifyRouting (theConsEntPers);
d559 19
a607 45
WitBoolean WitSelector::innerFindFresh ()
   {
   WitBoolean pseudoShortOnly;
   WitBoolean printNeeded;
   WitAltPt * theAltPt;

   if (penExec_)
      {
      myExpRest ()->update (pseudoShortOnly);
      
      if (pseudoShortOnly)
         return witTRUE;
      }

   if (pendingPts_.isEmpty ())
      return witFALSE;

   printNeeded = (myGlobalComp ()->selPrintLevel () >= 1);

   if (printNeeded)
      printPreAlt ();

   while (pendingPts_.pop (theAltPt))
      {
      if (selSplit ())
         if (mySplitter ()->needsToSplit (theAltPt))
            {
            }

      theAltPt->alterSelection ();

      theAltPt->setPending (witFALSE);

      if (printNeeded)
         print (theAltPt);
      }

   if (printNeeded)
      printPostAlt ();

   return resolvingAlt_;
   }

//------------------------------------------------------------------------------

d841 2
a842 1
      failFlowPairs_ (myProblem ())
d872 8
a879 1
WitBoolean WitSplitter::needsToSplit (WitAltPt * theAltPt)
d885 4
d902 4
a905 1
   return (theGap > theAltPt->splitRes () + SEARCH_TOL);
@


1.29
log
@Made multi-select trace-back for netting active even without selection
splitting.
@
text
@d17 1
d34 1
d63 1
d75 1
a75 2
      penExec_           (witFALSE),
      selSplit_          (witFALSE)
a95 3
   if (selSplit_)
      myMsgFac () ("selSplitMsg");

d107 2
d171 1
a171 3
   WitBoolean pseudoShortOnly;
   WitBoolean printNeeded;
   WitAltPt * theAltPt;
d173 1
a173 10
   if (penExec_)
      {
      myExpRest ()->update (pseudoShortOnly);
      
      if (pseudoShortOnly)
         return witTRUE;
      }

   if (pendingPts_.isEmpty ())
      return witFALSE;
d175 2
a176 1
   printNeeded = (myGlobalComp ()->selPrintLevel () >= 1);
d178 1
a178 17
   if (printNeeded)
      printPreAlt ();

   while (pendingPts_.pop (theAltPt))
      {
      theAltPt->alterSelection ();

      theAltPt->setPending (witFALSE);

      if (printNeeded)
         print (theAltPt);
      }

   if (printNeeded)
      printPostAlt ();

   return resolvingAlt_;
d199 2
a200 1
   if (selSplit_)
d202 6
a207 1
         theSelMgr->postCommitSS ();
d319 1
a319 1
   if (selSplit_)
d345 4
d352 1
a352 1
      if (selSplit_)
d383 4
d460 2
d480 9
d495 2
a496 7
   if (theSelMgr == NULL)
      return;

   mySelMgrs_.append (theSelMgr);

   if (myGlobalComp ()->allowSS ())
      selSplit_ = selSplit_ || theSelMgr->selSplit ();
d531 45
d798 69
@


1.28
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d69 2
d73 1
a73 3
      selSplit_          (witFALSE),
      lastConsResAltPer_ (),
      nonNegLCRAPMats_   (myProblem ())
a94 1
      {
a96 3
      lastConsResAltPer_.allocate (myProblem (), -1);
      }

d221 3
a224 1
      {
a226 4

      while (nonNegLCRAPMats_.pop (theMat))
         lastConsResAltPer_ (theMat) = -1;
      }
a234 2
   witAssert (selSplit_);

d251 1
a251 1
void WitSelector::recFillNetRecSS (WitPart * thePart, WitPeriod fillPer)
a257 2

   witAssert (selSplit_);
@


1.27
log
@Fixed a particularly difficult bug in coarse selection splitting.
@
text
@a21 1
#include <Selector.h>
d32 1
a77 5
   selSplit_ = myGlobalComp ()->selSplit ();

   if (selSplit_)
      lastConsResAltPer_.allocate (myProblem (), -1);

d94 7
d174 3
a176 8
   WitSelMgr * theSelMgr;
   WitBoolean  pseudoShortOnly;
   WitBoolean  printNeeded;
   WitAltPt *  theAltPt;

   if (selSplit_)
      forEachEl (theSelMgr, mySelMgrs_)
         theSelMgr->preAltAttSS ();
a186 5
      {
      if (selSplit_)
         forEachEl (theSelMgr, mySelMgrs_)
            theSelMgr->postAltAttSS ();

a187 1
      }
a203 4
   if (selSplit_)
      forEachEl (theSelMgr, mySelMgrs_)
         theSelMgr->postAltAttSS ();

d228 1
a228 1
         theSelMgr->postCommitSS (tempMode && success);
a478 12
void WitSelector::postPermCommitSS ()
   {
   WitSelMgr * theSelMgr;

   witAssert (selSplit_);

   forEachEl (theSelMgr, mySelMgrs_)
      theSelMgr->postPermCommitSS ();
   }

//------------------------------------------------------------------------------

d485 2
a486 2
      myProdRtr_  = new WitProdRtr (myHeurAllPerf_);
      myConsRtr_  = new WitConsRtr (myHeurAllPerf_);
d490 1
a490 1
      myBaMgr_ = new WitBaMgr (myHeurAllPerf_);
d493 1
a493 1
      myMeMgr_ = new WitMeMgr (myHeurAllPerf_);
d505 7
a511 2
   if (theSelMgr != NULL)
      mySelMgrs_.append (theSelMgr);
d669 2
a670 2
WitSelMgr::WitSelMgr (WitHeurAllPerf * theHeurAllPerf):
      WitProbAssoc    (theHeurAllPerf),
d672 2
a673 2
      myHeurAllPerf_  (theHeurAllPerf),
      selSplit_       (myGlobalComp ()->selSplit ()),
d754 1
a754 1
   if (myHeurAllPerf ()->myAllocMode ()->temp ())
a832 13
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Inlines.
//------------------------------------------------------------------------------

inline WitBoolean WitReqPt::selSplit ()
   {
   return directPts_.myProblem ()->myGlobalComp ()->selSplit ();
   }

//------------------------------------------------------------------------------
// Non-inlines.
@


1.26
log
@Implemented coarse selection splitting for penalized execution.
@
text
@d55 1
a55 1
      WitProbAssoc   (theHeurAllPerf),
d57 17
a73 15
      myHeurAllPerf_ (theHeurAllPerf),
      myExpRest_     (NULL),
      myRtAnalyzer_  (NULL),
      myReqPtMgr_    (NULL),
      myProdRtr_     (NULL),
      myConsRtr_     (NULL),
      myBaMgr_       (NULL),
      myMeMgr_       (NULL),
      mySelMgrs_     (),
      pendingPts_    (myProblem ()),
      altCounts_     (),
      resolvingAlt_  (witFALSE),
      multiRoute_    (witFALSE),
      penExec_       (witFALSE),
      selSplit_      (witFALSE)
d80 3
d227 2
a228 1
   WitSelMgr * theSelMgr;
d239 1
d242 66
d894 15
a908 3
   if (theSource->hasAlt ())
      if (updateOK (theSource->hasResAlt (), priorAlt))
         source_ = theSource;
d918 15
a932 3
   if (theAltPt != NULL)
      if (updateOK (resFound, priorAlt))
         directPts_.push (theAltPt);
a968 21
   }

//------------------------------------------------------------------------------

WitBoolean WitReqPt::updateOK (WitBoolean resFound, WitBoolean & priorAlt)
   {
   witAssert (! (priorAlt && hasResAlt_));

   if (priorAlt)
      if (! resFound)
         return witFALSE;

   if (resFound)
      {
      reset ();
            
      hasResAlt_ = witTRUE;
      priorAlt   = witFALSE;
      }        

   return witTRUE;
@


1.25
log
@Further implementation of coarse selection splitting.
@
text
@d83 1
a83 1
      penExec_  = myGlobalComp ()->penExec ();
d176 1
a176 1
   if (penExec ())
a219 7
WitBoolean WitSelector::freshSchemeAvail ()
   {
   return (! pendingPts_.isEmpty ()) && resolvingAlt_;
   }

//------------------------------------------------------------------------------

d228 1
a228 1
      if (penExec ())
d362 1
a362 1
   if (penExec ())
d479 1
a479 1
      if (penExec ())
@


1.24
log
@Further implementation of coarse selection splitting.
@
text
@d630 1
a630 1
      splitList_      (myProblem ()),
d639 1
a639 1
      const WitTlDblStack & rawSplitList,
a642 4
   WitPairStItr (WitTl, double) theItr;
   WitTl *                      splitObj;
   double                       splitBound;

d644 1
a644 1
   witAssert (! rawSplitList.isEmpty ());
d652 1
a652 6
   splitList_.clear ();

   theItr.attachTo (rawSplitList);

   while (theItr.advance (splitObj, splitBound))
      splitList_.push    (splitObj, splitBound);
d673 1
a673 1
      boundedSplit_ = splitList_.pop (splitObj, splitBound);
@


1.23
log
@Allowed coarse selection splitting with execution bounds.
@
text
@a367 1
   double     splitVol;
d631 2
a632 2
      unbnddSplitObj_ (NULL),
      unbnddSplitVol_ (0.0)
a642 1
   double                       netToSplitVol;
d645 1
a645 1
   double                       splitVol;
d648 1
a648 1

a649 1

a650 1

a657 2
   netToSplitVol = toSplitVol;

d660 2
a661 3
   while (theItr.advance (splitObj, splitVol))
      {
      adjustSplitVol (splitObj, splitVol);
d663 3
a665 2
      if (splitVol <= NET_TOL)
         continue;
d667 1
a667 3
      if (netToSplitVol <= splitVol + NET_TOL)
         {
         splitList_.push (splitObj, min (netToSplitVol, splitVol));
d669 3
a671 1
         unbnddSplitObj_ = NULL;
d673 1
a673 2
         return;
         }
d675 2
a676 1
      netToSplitVol -= splitVol;
d678 1
a678 2
      splitList_.push (splitObj, splitVol);
      }
d680 3
a682 3
   unbnddSplitObj_ = unbnddObj;
   unbnddSplitVol_ = netToSplitVol;
   }
d684 5
a688 1
//------------------------------------------------------------------------------
d690 1
a690 3
WitBoolean WitSelMgr::findNextSplitAbs (WitTl * & splitObj, double & splitVol)
   {
   boundedSplit_ = splitList_.pop (splitObj, splitVol);
d692 2
a693 4
   if (! boundedSplit_)
      {
      if (unbnddSplitObj_ == NULL)
         return witFALSE;
d695 1
a695 3
      splitObj        = unbnddSplitObj_;
      splitVol        = unbnddSplitVol_;
      unbnddSplitObj_ = NULL;
d698 5
a702 1
   prtSelSplitIA (splitObj, splitVol);
d709 4
a712 1
void WitSelMgr::prtSelSplitIA (WitTl * splitObj, double splitVol)
d722 9
a730 5
   fprintf (msgFile (),
      "      SplitVol:    %.3f\n" 
      "                   %s\n",
      splitVol,
      boundedSplit_? "Bounded": "Unbounded");
@


1.22
log
@Continued development of coarse selection splitting.
@
text
@d348 3
a350 4
      if (theSelMgr->validForExecBounds ())
         {
         theAltPt = 
            theSelMgr->myAltPt (theBopEnt, NULL, execPer, fillPer, resFound);
d352 5
a356 2
         theReqPt->putDirectPointExecBounds (theAltPt, resFound);
         }
@


1.21
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@a118 30
WitBopEntry * WitSelector::selBopEntry (WitPart * thePart, WitPeriod thePer)
   {
   return myProdRtr ()->selBopEntry (thePart, thePer);
   }

//------------------------------------------------------------------------------

WitConsEntry * WitSelector::selConsEntry (
      WitBomEntry * theBomEnt, 
      WitPeriod     thePer)
   {
   return myConsRtr ()->selConsEntry (theBomEnt, thePer);
   }

//------------------------------------------------------------------------------

WitPeriod WitSelector::selExpPeriod (WitPart * thePart, WitPeriod fillPer)
   {
   return myBaMgr ()->selExpPeriod (thePart, fillPer);
   }

//------------------------------------------------------------------------------

WitPeriod WitSelector::selExecPeriod (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   return myMeMgr ()->selExecPeriod (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

d123 2
a124 2
         selExpPeriod (thePart,    fillPer):
         thePart->explosionPeriod (fillPer);
d135 2
a136 9
         selExecPeriod (theBopEnt, expPer):
         theBopEnt->expExecPeriod ()[expPer];
   }

//------------------------------------------------------------------------------

void WitSelector::setInitDirIsAsap (WitBoolean theValue)
   {
   myMeMgr ()->setInitDirIsAsap (theValue);
a398 7
void WitSelector::print (WitMeAltPt * theMeAltPt)
   {
   myMePrinter ()->print (theMeAltPt);
   }

//------------------------------------------------------------------------------

a424 193
WitBoolean WitSelector::pmrSelIsSplit (WitPart * thePart, WitPeriod expPer)
   {
   witAssert (selSplit_);

   return myProdRtr ()->selIsSplit (thePart, expPer);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::cmrSelIsSplit (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer)
   {
   witAssert (selSplit_);

   return myConsRtr ()->selIsSplit (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::baSelIsSplit (WitPart * thePart, WitPeriod fillPer)
   {
   witAssert (selSplit_);

   return myBaMgr ()->selIsSplit (thePart, fillPer);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::meSelIsSplit (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   return myMeMgr ()->selIsSplit (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

void WitSelector::startPmrSplitExp (
      WitPart * thePart, 
      WitPeriod expPer,
      double    theReqVol)
   {
   myProdRtr ()->startSplitExp (thePart, expPer, theReqVol);
   }

//------------------------------------------------------------------------------

void WitSelector::startCmrSplitExp (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer,
      double        theExecVol)
   {
   myConsRtr ()->startSplitExp (theBomEnt, execPer, theExecVol);
   }

//------------------------------------------------------------------------------

void WitSelector::startBaSplitExp (
      WitPart * thePart,
      WitPeriod fillPer,
      double    reqVol)
   {
   myBaMgr ()->startSplitExp (thePart, fillPer, reqVol);
   }

//------------------------------------------------------------------------------

void WitSelector::startMeSplitExp (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol)
   {
   myMeMgr ()->startSplitExp (theBopEnt, expPer, expVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::findNextPmrSplit (
      WitBopEntry * & theBopEnt, 
      double &        expVol)
   {
   return myProdRtr ()->findNextSplit (theBopEnt, expVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::findNextCmrSplit (
      WitConsEntry * & theConsEnt, 
      double &         splitExecVol)
   {
   return myConsRtr ()->findNextSplit (theConsEnt, splitExecVol);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::findNextBaSplit (
      WitPeriod & expPer, 
      double &    splitExpVol)
   {
   return myBaMgr ()->findNextSplit (expPer, splitExpVol);
   }
 
//------------------------------------------------------------------------------

WitBoolean WitSelector::findNextMeSplit (
      WitPeriod & execPer, 
      double &    splitExpVol)
   {
   return myMeMgr ()->findNextSplit (execPer, splitExpVol);
   }

//------------------------------------------------------------------------------

void WitSelector::finishPmrSplitExp ()
   {
   myProdRtr ()->finishSplitExp ();
   }

//------------------------------------------------------------------------------

void WitSelector::finishCmrSplitExp ()
   {
   myConsRtr ()->finishSplitExp ();
   }

//------------------------------------------------------------------------------

void WitSelector::finishBaSplitExp ()
   {
   myBaMgr ()->finishSplitExp ();
   }

//------------------------------------------------------------------------------

void WitSelector::finishMeSplitExp ()
   {
   myMeMgr ()->finishSplitExp ();
   }

//------------------------------------------------------------------------------

void WitSelector::recBopEntExpPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer, 
      double        expVol)
   {
   witAssert (selSplit_);
   witAssert (multiRoute_);

   myProdRtr ()->recBopEntExpPerSS (theBopEnt, expPer, expVol);
   }

//------------------------------------------------------------------------------

void WitSelector::recExpConsEntSS (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         deltaExecVol)
   {
   witAssert (selSplit_);
   witAssert (multiRoute_);

   myConsRtr ()->recExpConsEntSS (theConsEnt, execPer, deltaExecVol);
   }

//------------------------------------------------------------------------------

void WitSelector::recExpMatSS (
      WitPart * thePart,
      WitPeriod expPer, 
      double    expVol,
      WitPeriod fillPer) 
   {
   witAssert (selSplit_);
   witAssert (buildAhead ());

   myBaMgr ()->recExpMatSS (thePart, expPer, expVol, fillPer);
   }

//------------------------------------------------------------------------------

void WitSelector::recBopEntExecPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod     execPer, 
      double        expVol)
   {
   witAssert (selSplit_);
   witAssert (multiExec ());

   myMeMgr ()->recBopEntExecPerSS (theBopEnt, execPer, expVol);
   }

//------------------------------------------------------------------------------

d626 1
@


1.20
log
@Further development of coarse selection splitting.
@
text
@d469 12
a480 4
void WitSelector::startBaSplitExp (
      WitPart * thePart,
      WitPeriod fillPer,
      double    reqVol)
d482 3
a484 1
   myBaMgr ()->startSplitExp (thePart, fillPer, reqVol);
d489 1
a489 3
WitBoolean WitSelector::findNextBaSplit (
      WitPeriod & expPer, 
      double &    splitExpVol)
d491 3
a493 1
   return myBaMgr ()->findNextSplit (expPer, splitExpVol);
d495 1
a495 1
 
d498 1
a498 1
void WitSelector::finishBaSplitExp ()
d500 1
a500 1
   myBaMgr ()->finishSplitExp ();
d515 30
d554 3
a556 1
void WitSelector::finishPmrSplitExp ()
d558 1
a558 1
   myProdRtr ()->finishSplitExp ();
d563 12
a574 4
void WitSelector::startCmrSplitExp (
      WitBomEntry * theBomEntry, 
      WitPeriod     execPer,
      double        theExecVol)
d576 1
a576 1
   myConsRtr ()->startSplitExp (theBomEntry, execPer, theExecVol);
d581 1
a581 3
WitBoolean WitSelector::findNextCmrSplit (
      WitConsEntry * & theConsEnt, 
      double &         splitExecVol)
d583 1
a583 1
   return myConsRtr ()->findNextSplit (theConsEnt, splitExecVol);
d595 1
a595 5
void WitSelector::recExpMatSS (
      WitPart * thePart,
      WitPeriod expPer, 
      double    expVol,
      WitPeriod fillPer) 
d597 4
a600 2
   witAssert (selSplit_);
   witAssert (buildAhead ());
d602 3
a604 1
   myBaMgr ()->recExpMatSS (thePart, expPer, expVol, fillPer);
d609 1
a609 1
void WitSelector::recExpBopEntSS (
d617 1
a617 1
   myProdRtr ()->recExpBopEntSS (theBopEnt, expPer, expVol);
d635 5
a639 1
void WitSelector::postPermCommitSS ()
a640 2
   WitSelMgr * theSelMgr;

d642 1
d644 1
a644 2
   forEachEl (theSelMgr, mySelMgrs_)
      theSelMgr->postPermCommitSS ();
d649 4
a652 1
WitBoolean WitSelector::baSelIsSplit (WitPart * thePart, WitPeriod fillPer)
d655 1
d657 1
a657 1
   return myBaMgr ()->selIsSplit (thePart, fillPer);
d662 1
a662 1
WitBoolean WitSelector::pmrSelIsSplit (WitPart * thePart, WitPeriod expPer)
d664 1
a664 6
   witAssert (selSplit_);

   return myProdRtr ()->selIsSplit (thePart, expPer);
   }

//------------------------------------------------------------------------------
a665 4
WitBoolean WitSelector::cmrSelIsSplit (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer)
   {
d668 2
a669 1
   return myConsRtr ()->selIsSplit (theBomEnt, execPer);
@


1.19
log
@Implemented and used class SelMgr.
@
text
@d34 1
d315 1
a315 1
   int         nFinSplitsBelow;
d330 1
a330 1
   nFinSplitsBelow = 0;
d334 2
a335 2
         if (theSelMgr->hadFinSplit ())
            nFinSplitsBelow ++;
d339 1
a339 1
   if (nFinSplitsBelow == 0)
d348 1
a348 1
      if (nFinSplitsBelow == 0)
d362 2
a363 2
         if (theSelMgr->hadFinSplit ())
            nFinSplitsBelow --;
d792 1
a792 1
// Implementation of class DirAssoc.
d801 12
d814 66
a879 1
      WitProbAssoc   (theHeurAllPerf),
d881 1
a881 2
      myHeurAllPerf_ (theHeurAllPerf),
      hadFinSplit_   (witFALSE)
d883 15
d902 1
a902 1
void WitSelMgr::setHadFinSplit (WitBoolean theValue)
d904 13
a916 1
   hadFinSplit_ = theValue;
@


1.18
log
@Fixed some bugs in coarse selection splitting.
@
text
@d16 1
d33 1
a33 1
#include <PairSt.h>
d52 1
a52 1
WitSelector::WitSelector (WitProblem * theProblem, WitBoolean reqBuildAhead):
d54 1
a54 1
      WitProbAssoc    (theProblem),
d56 15
a70 16
      myProdRtr_      (NULL),
      myConsRtr_      (NULL),
      myBaMgr_        (NULL),
      myMeMgr_        (NULL),
      myExpRest_      (NULL),
      myRtAnalyzer_   (NULL),
      myReqPtMgr_     (NULL),
      pendingPts_     (myProblem ()),
      altCounts_      (),
      resolvingAlt_   (witFALSE),
      multiRoute_     (witFALSE),
      penExec_        (witFALSE),
      selSplit_       (witFALSE),
      baHadFinSplit_  (witFALSE),
      pmrHadFinSplit_ (witFALSE),
      cmrHadFinSplit_ (witFALSE)
d77 15
a91 1
   buildHelpers (reqBuildAhead);
d112 2
a113 11
   if (multiExec ())
      delete myMeMgr ();

   if (buildAhead ())
      delete myBaMgr ();

   if (multiRoute_)
      {
      delete myConsRtr ();
      delete myProdRtr ();
      }
a200 34
void WitSelector::prtBaSelSplit (
      WitPart *  thePart, 
      WitPeriod  fillPer,
      WitPeriod  expPer, 
      WitBoolean finSplit,
      double     splitVol)
   {
   myBaMgr ()->prtSelSplit (thePart, fillPer, expPer, finSplit, splitVol);
   }

//------------------------------------------------------------------------------

void WitSelector::prtPmrSelSplit (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      WitBoolean    finSplit,
      double        splitVol)
   {
   myProdRtr ()->prtSelSplit (theBopEnt, expPer, finSplit, splitVol);
   }

//------------------------------------------------------------------------------

void WitSelector::prtCmrSelSplit (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitBoolean     finSplit,
      double         splitVol)
   {
   myConsRtr ()->prtSelSplit (theConsEnt, execPer, finSplit, splitVol);
   }

//------------------------------------------------------------------------------

d203 4
a206 3
   WitBoolean pseudoShortOnly;
   WitBoolean printNeeded;
   WitAltPt * theAltPt;
d209 2
a210 10
      {
      if (multiRoute_)
         {
         myProdRtr ()->preAltAttSS ();
         myConsRtr ()->preAltAttSS ();
         }

      if (buildAhead ())
         myBaMgr   ()->preAltAttSS ();
      }
d223 2
a224 10
         {
         if (multiRoute_)
            {
            myProdRtr ()->postAltAttSS ();
            myConsRtr ()->postAltAttSS ();
            }

         if (buildAhead ())
            myBaMgr   ()->postAltAttSS ();
         }
d245 2
a246 10
      {
      if (multiRoute_)
         {
         myProdRtr ()->postAltAttSS ();
         myConsRtr ()->postAltAttSS ();
         }

      if (buildAhead ())
         myBaMgr   ()->postAltAttSS ();
      }
d265 2
d276 2
a277 10
      {
      if (multiRoute_)
         {
         myProdRtr ()->postCommitSS (tempMode && success);
         myConsRtr ()->postCommitSS (tempMode && success);
         }

      if (buildAhead ())
         myBaMgr   ()->postCommitSS (tempMode && success);
      }
d311 9
a319 3
   WitPart *  consPart;
   WitPeriod  consPer;
   WitReqPt * theReqPt;
d326 38
a363 2
   if (! theReqPt->hasResAlt ())
      innerPlaceReqs (theBopEnt, theConsEnt, execPer, fillPer, theReqPt);
d373 5
a377 6
   WitReqPt * theReqPt;
   WitAltPt * theAltPt;
   WitBoolean resFound;

   WitPart *  prodPart;
   WitPeriod  prodPer;
a380 3
   if (multiRoute_ || multiExec ())
      prodPer = theBopEnt->impactPeriod ()[execPer];

d383 5
a387 3
   if (buildAhead ())
      {
      theAltPt = myBaMgr ()->myAltPt (prodPart, fillPer, resFound);
d389 2
a390 16
      theReqPt->putDirectPointExecBounds (theAltPt, resFound);
      }

   if (multiRoute_)
      {
      theAltPt = myProdRtr ()->myAltPt (prodPart, prodPer, resFound);

      theReqPt->putDirectPointExecBounds (theAltPt, resFound);
      }

   if (multiExec ())
      {
      theAltPt = myMeMgr ()->myAltPt (theBopEnt, prodPer, resFound);

      theReqPt->putDirectPointExecBounds (theAltPt, resFound);
      }
d468 78
d588 2
d592 2
a593 8
   if (multiRoute_)
      {
      myProdRtr ()->postPermCommitSS ();
      myConsRtr ()->postPermCommitSS ();
      }

   if (buildAhead ())
      myBaMgr   ()->postPermCommitSS ();
d627 1
a627 4
void WitSelector::getBaSplitList (
      WitPart *        thePart,
      WitPeriod        fillPer,
      WitPerDblStack & splitList)
d629 3
a631 5
   if (buildAhead ())
      myBaMgr ()->getSplitList (thePart, fillPer, splitList);
   else
      splitList.clear ();
   }
d633 3
a635 1
//------------------------------------------------------------------------------
d637 2
a638 7
void WitSelector::getPmrSplitList (
      WitPart *           thePart,
      WitPeriod           expPer,
      WitBopEntDblStack & splitList)
   {
   myProdRtr ()->getSplitList (thePart, expPer, splitList);
   }
d640 2
a641 1
//------------------------------------------------------------------------------
d643 4
a646 15
void WitSelector::getCmrSplitList (
      WitBomEntry *        theBomEnt, 
      WitPeriod            execPer,
      WitConsEntDblStack & splitList)
   {
   myConsRtr ()->getSplitList (theBomEnt, execPer, splitList);
   }

//------------------------------------------------------------------------------

void WitSelector::setBaHadFinSplit (WitBoolean theValue)
   {
   witAssert (theValue == ! baHadFinSplit_);

   baHadFinSplit_ = theValue;
d651 1
a651 1
void WitSelector::setPmrHadFinSplit (WitBoolean theValue)
d653 2
a654 44
   witAssert (theValue == ! pmrHadFinSplit_);

   pmrHadFinSplit_ = theValue;
   }

//------------------------------------------------------------------------------

void WitSelector::setCmrHadFinSplit (WitBoolean theValue)
   {
   witAssert (theValue == ! cmrHadFinSplit_);

   cmrHadFinSplit_ = theValue;
   }

//------------------------------------------------------------------------------

void WitSelector::buildHelpers (WitBoolean reqBuildAhead)
   {
   myReqPtMgr_ = new WitReqPtMgr (myProblem ());

   if (myGlobalComp ()->multiRoute ())
      {
      multiRoute_ = witTRUE;

      myProdRtr_  = new WitProdRtr (myProblem ());
      myConsRtr_  = new WitConsRtr (myProblem ());

      penExec_    = myGlobalComp ()->penExec ();

      if (penExec_)
         {
         myMsgFac () ("penExecMsg");

         myExpRest_    = new WitExpRest    (myProblem ());

         myRtAnalyzer_ = new WitRtAnalyzer (this, myProdRtr (), myConsRtr ());
         }
      }

   if (reqBuildAhead)
      myBaMgr_ = new WitBaMgr (myProblem ());

   if (myGlobalComp ()->multiExecNeeded ())
      myMeMgr_ = new WitMeMgr (myProblem ());
d791 2
d794 1
a794 6
void WitSelector::innerPlaceReqs (
      WitBopEntry *  theBopEnt,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitPeriod      fillPer,
      WitReqPt *     theReqPt)
d796 1
a796 6
   WitBoolean    priorAlt;
   WitPart *     prodPart;
   WitPeriod     prodPer;
   WitAltPt *    theAltPt;
   WitBoolean    resFound;
   WitBomEntry * theBomEnt;
d798 1
a798 2
   if (cmrHadFinSplit_)
      return;
d800 2
a801 1
   priorAlt = theReqPt->hasAlt ();
d803 4
a806 1
   prodPart = theBopEnt->myPart ();
d808 1
a808 2
   if (multiRoute_ || multiExec ())
      prodPer = theBopEnt->impactPeriod ()[execPer];
d810 3
a812 37
   if (! pmrHadFinSplit_)
      {
      if (! baHadFinSplit_)
         {
         theReqPt->setSource (myReqPt (prodPart, fillPer), priorAlt);

         if (buildAhead ())
            {
            theAltPt = myBaMgr ()->myAltPt (prodPart, fillPer, resFound);

            theReqPt->putDirectPoint (theAltPt, resFound, priorAlt);
            }
         }

      if (multiRoute_)
         {
         theAltPt = myProdRtr ()->myAltPt (prodPart, prodPer, resFound);

         theReqPt->putDirectPoint (theAltPt, resFound, priorAlt);
         }
      }

   if (multiExec ())
      {
      theAltPt = myMeMgr ()->myAltPt (theBopEnt, prodPer, resFound);

      theReqPt->putDirectPoint (theAltPt, resFound, priorAlt);
      }

   if (multiRoute_)
      {
      theBomEnt = theConsEnt->myBomEntry ();

      theAltPt  = myConsRtr ()->myAltPt (theBomEnt, execPer, resFound);

      theReqPt->putDirectPoint (theAltPt, resFound, priorAlt);
      }
@


1.17
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d53 1
a53 1
      WitProbAssoc  (theProblem),
d55 16
a70 13
      myProdRtr_    (NULL),
      myConsRtr_    (NULL),
      myBaMgr_      (NULL),
      myMeMgr_      (NULL),
      myExpRest_    (NULL),
      myRtAnalyzer_ (NULL),
      myReqPtMgr_   (NULL),
      pendingPts_   (myProblem ()),
      altCounts_    (),
      resolvingAlt_ (witFALSE),
      multiRoute_   (witFALSE),
      penExec_      (witFALSE),
      selSplit_     (witFALSE)
d196 6
a201 1
void WitSelector::prtRtSplitAtPart (WitPart * thePart, WitPeriod expPer)
d203 1
a203 1
   myProdRtr ()->prtRtSplitAtPart (thePart, expPer);
d208 1
a208 1
void WitSelector::prtRtSplitToBopEnt (
d210 2
a211 1
      WitBoolean    splitFound,
d214 1
a214 1
   myProdRtr ()->prtRtSplitToBopEnt (theBopEnt, splitFound, splitVol);
d219 1
a219 10
void WitSelector::prtRtSplitAtBomEnt (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   myConsRtr ()->prtRtSplitAtBomEnt (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitSelector::prtRtSplitToConsEnt (
d221 2
a222 1
      WitBoolean     splitFound,
d225 1
a225 18
   myConsRtr ()->prtRtSplitToConsEnt (theConsEnt, splitFound, splitVol);
   }

//------------------------------------------------------------------------------

void WitSelector::prtBpsSplitAt (WitPart * thePart, WitPeriod fillPer)
   {
   myBaMgr ()->prtBpsSplitAt (thePart, fillPer);
   }

//------------------------------------------------------------------------------

void WitSelector::prtBpsSplitTo (
      WitPeriod  expPer, 
      WitBoolean splitFound,
      double     splitVol)
   {
   myBaMgr ()->prtBpsSplitTo (expPer, splitFound, splitVol);
d278 1
a278 1
   while (pendingPts_.get (theAltPt))
d444 1
a444 1
   while (pendingPts_.get (theAltPt))
d456 1
a456 1
            pendingPts_.put (theAltPt);
a501 1
      WitPeriod fillPer, 
d503 2
a504 1
      double    expVol)
d509 1
a509 1
   myBaMgr ()->recExpMatSS (thePart, fillPer, expPer, expVol);
d556 1
a556 4
void WitSelector::getBaSplitList (
      WitPart *        thePart,
      WitPeriod        fillPer,
      WitPerDblStack & splitList)
d558 3
a560 4
   if (buildAhead ())
      myBaMgr ()->getSplitList (thePart, fillPer, splitList);
   else
      splitList.clear ();
d565 1
a565 1
WitBoolean WitSelector::routingIsSplit (WitPart * thePart, WitPeriod expPer)
d567 1
a567 3
   if (selSplit_)
      if (multiRoute_)
         return myProdRtr ()->routingIsSplit (thePart, expPer);
d569 1
a569 1
   return witFALSE;
d574 1
a574 1
WitBoolean WitSelector::routingIsSplit (
d578 16
a593 4
   return
      selSplit_?
         myConsRtr ()->routingIsSplit (theBomEnt, execPer):
         witFALSE;
d598 1
a598 1
void WitSelector::getMrSplitList (
d608 4
a611 1
void WitSelector::setExpBopEntIsSplit (WitBoolean theValue)
d613 1
a613 1
   myProdRtr ()->setExpBopEntIsSplit (theValue);
d618 1
a618 4
void WitSelector::getMrSplitList (
      WitBomEntry *        theBomEnt, 
      WitPeriod            execPer,
      WitConsEntDblStack & splitList)
d620 3
a622 1
   myConsRtr ()->getSplitList (theBomEnt, execPer, splitList);
d627 1
a627 1
void WitSelector::setExpConsEntIsSplit (WitBoolean theValue)
d629 12
a640 1
   myConsRtr ()->setExpConsEntIsSplit (theValue);
d824 3
d834 5
a838 1
   theReqPt->setSource (myReqPt (prodPart, fillPer), priorAlt);
d840 3
a842 3
   if (buildAhead ())
      {
      theAltPt = myBaMgr ()->myAltPt (prodPart, fillPer, resFound);
d844 3
a846 2
      theReqPt->putDirectPoint (theAltPt, resFound, priorAlt);
      }
d848 3
a850 3
   if (multiRoute_)
      {
      theAltPt = myProdRtr ()->myAltPt (prodPart, prodPer, resFound);
d852 2
a853 1
      theReqPt->putDirectPoint (theAltPt, resFound, priorAlt);
d895 1
a895 1
   while (unusedPoints_.get (thePoint))
d907 1
a907 1
      if (! unusedPoints_.get (thePointRef))
d910 1
a910 1
      allocedSlots_.put (& thePointRef);
d922 1
a922 1
   while (allocedSlots_.get (thePtr))
d928 1
a928 1
      unusedPoints_.put (thePointRef);
d991 1
a991 1
         directPts_.put (theAltPt);
d1010 1
a1010 1
   directPts_.put (theAltPt);
d1027 1
a1027 1
   return directPts_.get (theAltPt);
@


1.16
log
@Coarse selection splitting.
@
text
@d193 18
a210 1
void WitSelector::prtRtSplitAtBomEntIA (
d214 1
a214 12
   if (myGlobalComp ()->selPrintLevel () < 4)
      return;

   fprintf (msgFile (),
      "\n"
      "Routing Split at a BOM Entry:\n"
      "   Operation:   %s\n"
      "   BOM Entry #: %d\n"
      "   Exec Per:    %d\n",
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex (),
      execPer);
d219 1
a219 1
void WitSelector::prtRtSplitToConsEntIA (
d224 1
a224 22
   if (myGlobalComp ()->selPrintLevel () < 4)
      return;

   fprintf (msgFile (), 
      "\n"
      "   Routing:\n");
                  
   if (theConsEnt == theConsEnt->myBomEntry ())
      fprintf (msgFile (), 
         "      Self\n");
   else
      fprintf (msgFile (), 
         "      Sub #:    %d\n", 
         theConsEnt->localIndex ());
                  
   if (splitFound)
      fprintf (msgFile (),
         "      SplitVol: %.3f\n", 
         splitVol);
   else
      fprintf (msgFile (),
         "      SplitVol: Infinity\n");
d229 1
a229 1
void WitSelector::prtRtSplitAtPartIA (WitPart * thePart, WitPeriod expPer)
d231 1
a231 10
   if (myGlobalComp ()->selPrintLevel () < 4)
      return;

   fprintf (msgFile (),
      "\n"
      "Routing Split at a Part:\n"
      "   Part:    %s\n"
      "   Exp Per: %d\n",
      thePart->partName ().myCstring (),
      expPer);
d236 4
a239 4
void WitSelector::prtRtSplitToBopEntIA (
      WitBopEntry * theBopEnt,
      WitBoolean    splitFound,
      double        splitVol)
d241 1
a241 17
   if (myGlobalComp ()->selPrintLevel () < 4)
      return;

   fprintf (msgFile (),
      "\n"
      "   Routing:\n"
      "      Operation:   %s\n"
      "      BOP Entry #: %d\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex ());
               
   if (splitFound)
      fprintf (msgFile (),
         "      SplitVol:    %.3f\n", splitVol);
   else
      fprintf (msgFile (),
         "      SplitVol:    Infinity\n");
d253 1
d260 4
d275 1
d282 4
d305 1
d312 4
d342 1
d348 4
a482 7
void WitSelector::print (WitBaAltPt * theBaAltPt)
   {
   myBaMgr ()->print (theBaAltPt);
   }

//------------------------------------------------------------------------------

d516 14
d565 16
d587 5
a591 4
   return
      selSplit_?
         myProdRtr ()->routingIsSplit (thePart, expPer):
         witFALSE;
d611 1
a611 1
      WitBopEntDblStack & theSplitList)
d613 1
a613 1
   myProdRtr ()->getSplitList (thePart, expPer, theSplitList);
d628 1
a628 1
      WitConsEntDblStack & theSplitList)
d630 1
a630 1
   myConsRtr ()->getSplitList (theBomEnt, execPer, theSplitList);
@


1.15
log
@Fixed some bugs in coarse selection splitting.
@
text
@d25 2
a26 1
#include <MrMgr.h>
d55 2
a56 1
      myMrMgr_      (NULL),
d59 2
a61 1
      myExpRest_    (NULL),
d65 1
d89 6
d101 5
a105 2
   if (multiRoute ())
      delete myMrMgr ();
d112 1
a112 1
   return myMrMgr ()->selBopEntry (thePart, thePer);
d121 1
a121 1
   return myMrMgr ()->selConsEntry (theBomEnt, thePer);
d293 5
a297 2
      if (multiRoute ())
         myMrMgr ()->preAltAttSS ();
d310 5
a314 2
         if (multiRoute ())
            myMrMgr ()->postAltAttSS ();
d335 5
a339 2
      if (multiRoute ())
         myMrMgr ()->postAltAttSS ();
d367 5
a371 2
      if (multiRoute ())
         myMrMgr ()->postCommitSS (tempMode && success);
d434 1
a434 1
   if (multiRoute () || multiExec ())
d446 1
a446 1
   if (multiRoute ())
d448 1
a448 1
      theAltPt = myMrMgr ()->myAltPt (prodPart, prodPer, resFound);
d519 13
a531 1
   myMrMgr ()->modifyRouting (thePart, thePer);
d538 1
a538 1
   myMrMgr ()->recCommitVol (commitVol, byExp);
d549 1
a549 1
   witAssert (multiRoute ());
d551 1
a551 1
   myMrMgr ()->recExpBopEntSS (theBopEnt, expPer, expVol);
d562 1
a562 1
   witAssert (multiRoute ());
d564 1
a564 1
   myMrMgr ()->recExpConsEntSS (theConsEnt, execPer, deltaExecVol);
d573 5
a577 2
   if (multiRoute ())
      myMrMgr ()->postPermCommitSS ();
d586 1
a586 1
         myMrMgr ()->routingIsSplit (thePart, expPer):
d598 1
a598 1
         myMrMgr ()->routingIsSplit (theBomEnt, execPer):
d609 1
a609 1
   myMrMgr ()->getSplitList (thePart, expPer, theSplitList);
d616 1
a616 1
   myMrMgr ()->setExpBopEntIsSplit (theValue);
d626 1
a626 1
   myMrMgr ()->getSplitList (theBomEnt, execPer, theSplitList);
d633 1
a633 8
   myMrMgr ()->setExpConsEntIsSplit (theValue);
   }

//------------------------------------------------------------------------------

WitBoolean WitSelector::ssmrForBopEnts ()
   {
   return myMrMgr ()->ssmrForBopEnts ();
d644 1
a644 1
      myMrMgr_ = new WitMrMgr (this);
d646 6
a651 1
      if (myMrMgr ()->penExec ())
d653 5
a657 2
         penExec_   = witTRUE;
         myExpRest_ = myMrMgr ()->myExpRest ();
d674 5
a678 2
      if (multiRoute ())
         myMrMgr ()->printMultiChoices ();
d691 5
a695 2
      if (multiRoute ())
         myMrMgr ()->printHasAlt ();
d821 1
a821 1
   if (multiRoute () || multiExec ())
d833 1
a833 1
   if (multiRoute ())
d835 1
a835 1
      theAltPt = myMrMgr ()->myAltPt (prodPart, prodPer, resFound);
d847 1
a847 1
   if (multiRoute ())
d851 1
a851 1
      theAltPt  = myMrMgr ()->myAltPt (theBomEnt, execPer, resFound);
@


1.14
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d574 7
d587 7
@


1.13
log
@Further development of coarse selection splitting.
@
text
@d120 1
a120 4
WitPeriod WitSelector::selExecPeriod (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer,
      WitPeriod     fillPer)
d122 1
a122 1
   return myMeMgr ()->selExecPeriod (theBopEnt, expPer, fillPer);
d139 1
a139 2
      WitPeriod     expPer,
      WitPeriod     fillPer)
d143 1
a143 1
         selExecPeriod (theBopEnt, expPer, fillPer):
d180 3
a182 6
void WitSelector::printSelSplitIA (
      WitBomEntry *  theBomEnt,
      WitPeriod      execPer,
      WitConsEntry * theConsEnt,
      WitBoolean     splitFound,
      double         splitVol)
d189 4
a192 4
      "Split Explosion:\n"
      "   Operation:    %s\n"
      "   BOM Entry #:  %d\n"
      "   Exec Per:     %d\n",
d196 19
a214 3
               
   if (theConsEnt == theBomEnt)
      fprintf (msgFile (), "      Selection: Self\n");
d217 2
a218 1
         "      Selection: Sub #%d\n", theConsEnt->localIndex ());
d222 44
a265 1
         "      SplitVol:  %.3f\n", splitVol);
d268 1
a268 1
         "      SplitVol:  Infinity\n");
d305 1
a305 1
   while (pendingPts_.pop (theAltPt))
d430 1
a430 1
      theAltPt = myMeMgr ()->myAltPt (theBopEnt, prodPer, fillPer, resFound);
d455 1
a455 1
   while (pendingPts_.pop (theAltPt))
d467 1
a467 1
            pendingPts_.push (theAltPt);
d506 13
a534 1
   witAssert (multiRoute ());
d542 33
a574 1
void WitSelector::getSplitList (
d584 7
d781 1
a781 1
      theAltPt = myMeMgr ()->myAltPt (theBopEnt, prodPer, fillPer, resFound);
d818 1
a818 1
   while (unusedPoints_.pop (thePoint))
d830 1
a830 1
      if (! unusedPoints_.pop (thePointRef))
d833 1
a833 1
      allocedSlots_.push (& thePointRef);
d845 1
a845 1
   while (allocedSlots_.pop (thePtr))
d851 1
a851 1
      unusedPoints_.push (thePointRef);
d914 1
a914 1
         directPts_.push (theAltPt);
d933 1
a933 1
   directPts_.push (theAltPt);
d950 1
a950 1
   return directPts_.pop (theAltPt);
@


1.12
log
@Futher development of selection splitting.
@
text
@d31 1
@


1.11
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@d226 2
a227 1
      myMrMgr ()->preAltAttSS ();
d240 2
a241 1
         myMrMgr ()->postAltAttSS ();
d262 2
a263 1
      myMrMgr ()->postAltAttSS ();
d291 2
a292 1
      myMrMgr ()->postCommitSS (tempMode && success);
d458 1
d468 1
d470 2
a471 1
   myMrMgr ()->postPermCommitSS ();
@


1.10
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@a151 10
void WitSelector::getSplitList (
      WitBomEntry *        theBomEnt, 
      WitPeriod            execPer,
      WitConsEntDblStack & theSplitList)
   {
   myMrMgr ()->getSplitList (theBomEnt, execPer, theSplitList);
   }

//------------------------------------------------------------------------------

d225 3
d270 1
a270 1
WitBoolean WitSelector::splitting ()
d277 1
a277 1
void WitSelector::postTempCommit (WitBoolean success)
d279 7
a285 1
   myReqPtMgr_->reset ();
d288 1
a288 15
      if (multiRoute ())
         myMrMgr ()->postTempCommitSS (success);

   if (penExec ())
      myExpRest ()->postTempCommit (success);
   }

//------------------------------------------------------------------------------

void WitSelector::postPermCommitSS ()
   {
   witAssert (myGlobalComp ()->selSplit ());

   if (multiRoute ())
      myMrMgr ()->postPermCommitSS ();
a336 13
void WitSelector::setMrSplitVol (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        theValue)
   {
   witAssert (selSplit_);
   witAssert (multiRoute ());

   myMrMgr ()->setSplitVol (theBomEnt, execPer, theValue);
   }

//------------------------------------------------------------------------------

d444 31
@


1.9
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d61 2
a62 1
      penExec_      (witFALSE)
d67 2
d152 4
a155 3
void WitSelector::findSelConsEntries (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer)
d157 1
a157 1
   myMrMgr ()->findSelConsEntries (theBomEnt, execPer);
a161 10
void WitSelector::findNextConsEntry (
      WitConsEntry * & theConsEnt,
      WitBoolean &     splitVolFinite,
      double &         splitVolVal)
   {
   myMrMgr ()->findNextConsEntry (theConsEnt, splitVolFinite, splitVolVal);
   }
 
//------------------------------------------------------------------------------

d193 36
d244 4
d249 1
d266 3
d279 1
a279 1
   return myMrMgr ()->splitting ();
d288 4
d298 10
d352 13
d415 1
d746 13
d770 7
@


1.8
log
@Outer API: Merged all no-longer-documented functions into one section.
Outer API: Moved build-ahead by demand functions into the no-longer-documented
   section.
Simplified the rules for two-way multiple execution periods.
@
text
@d149 19
d235 7
@


1.7
log
@Finished implementing stock reallocation.
@
text
@a29 1
#include <MeDirMgr.h>
d61 1
a61 2
      penExec_      (witFALSE),
      myMeDirMgr_   (NULL)
d149 1
a149 5
void WitSelector::preIncForTwme (
      WitBoolean asapMultiExec, 
      WitBoolean prefBA,
      WitPart *  thePart,
      WitPeriod  thePer)
d151 1
a151 1
   myMeDirMgr ()->preInc (asapMultiExec, prefBA, thePart, thePer);
a179 10
void WitSelector::printPostCommitMaxQtySelIA ()
   {
   witAssert (myGlobalComp ()->twoWayMultiExec ());

   if (myGlobalComp ()->selPrintLevel () >= 3)
      myMePrinter ()->printMeDirMgr ();
   }

//------------------------------------------------------------------------------

a229 9
void WitSelector::resetCurMeDirs (WitPeriod thePer)
   {
   witAssert (myGlobalComp ()->twoWayMultiExec ());

   myMeDirMgr ()->resetCurMeDirs (thePer);
   }

//------------------------------------------------------------------------------

d257 1
a257 2
      WitPeriod      fillPer,
      WitBoolean     tempMode)
d266 1
a266 3
   if (tempMode)
      {
      theReqPt = myReqPt (consPart, consPer);
d268 2
a269 6
      if (! theReqPt->hasResAlt ())
         innerPlaceReqs (theBopEnt, theConsEnt, execPer, fillPer, theReqPt);
      }

   if (myGlobalComp ()->twoWayMultiExec ())
      myMeDirMgr ()->placeReqs (theBopEnt, execPer, fillPer, consPart, consPer);
d403 1
a403 5
      {
      myMeMgr_    = new WitMeMgr (myProblem ());

      myMeDirMgr_ = myMeMgr ()->myMeDirMgr ();
      }
@


1.6
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@a263 2
   witAssert (myGlobalComp ()->stockRealloc ());

@


1.5
log
@Continued implementation of stock re-allocation.
@
text
@d264 1
a264 1
   witAssert (myGlobalComp ()->stockReAlloc ());
d521 1
a521 1
      WitUtil::setToMax (maxAltCount, * altCountPtr);
@


1.4
log
@Minor update to stock re-allocation.
@
text
@d255 4
a258 1
void WitSelector::rollReqs (WitPart * thePart, WitPeriod thePer)
d260 2
a261 2
   WitReqPt * srcReqPt;
   WitReqPt * rollReqPt;
a264 2
   witAssert (thePer > 0);
   witAssert (thePart->canStock (thePer - 1));
d266 1
a266 1
   rollReqPt = myReqPt (thePart, thePer);
d268 1
a268 1
   if (rollReqPt->hasResAlt ())
d271 1
a271 1
   priorAlt  = rollReqPt->hasAlt ();
d273 1
a273 1
   srcReqPt  = myReqPt (thePart, thePer - 1);
d275 1
a275 1
   rollReqPt->setSource (srcReqPt, priorAlt);
d521 1
a521 1
      WitUtil::updateToMax (maxAltCount, * altCountPtr);
@


1.3
log
@Fixed bug:
   Stock re-allocation caused selection trace-back to malfunction.
@
text
@d261 1
a261 1
   witAssert (myGlobalComp ()->usingSurplus ());
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d255 24
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

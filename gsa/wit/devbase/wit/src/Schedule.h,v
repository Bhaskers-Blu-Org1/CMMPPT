head	1.43;
access;
symbols
	sce_5_01_20080919:1.40
	latest_sce_4_20_20060523:1.37.0.2
	sce_4_20_20060523:1.37
	latest_sce4_20_OSL:1.36.0.2
	sce_4_20_OSL:1.36
	sce_410_withVa:1.32
	sce_4_05_20040511:1.30
	sce_4_00_20040201:1.29
	nextGenBranch:1.26.0.2
	nextGenRoot:1.26
	sce_3_30_20030627:1.26
	EndRw-branch:1.23.0.4
	Root-of-EndRw:1.23
	rwToStl:1.23.0.2
	latest_sce_3_10_20010924:1.13.0.2
	sce_3_10_20010924:1.13
	latest_sce_3_00_20010601:1.12.0.2
	sce_3_00_20010601:1.12
	latest_sce_2_31_20010308:1.11.0.2
	sce_2_31_20010308:1.11
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2011.09.28.23.50.09;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.24.00.28.35;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.08.30.20.18.09;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.22.15.46.52;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.11.15.56.46;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.16.22.52.05;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.02.17.34.12;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.21.15.44.15;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.17.17.07.18;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.15.21.27.24;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.15.19.55.21;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.28.20.14.38;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.24.18.42.04;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.10.22.53.21;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.09.22.44.06;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.01.21.05.05;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.01.19.41.11;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.23.20.47.19;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.15.21.01.26;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.13.22.22.13;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.04.19.14.59;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.06.18.53.42;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.05.21.20.02;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.10.18.02.13;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.08.21.58.58;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.07.20.15.04;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.03.23.16.42;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.02.20.53.15;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.01.14.26.01;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.18.14.02.43;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.21.44.45;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.25.14.53.27;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.11.16.35.11;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.04.22.27.53;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.28.22.13.39;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.20.20.08.37;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.23.45.58;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.06.19.58.41;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.23.11.48;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.27;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.34;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.54;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef ScheduleH
#define ScheduleH

//------------------------------------------------------------------------------
// Header file: "Schedule.h"
//
// Contains the declaration of class template Schedule <DomEl, RangeEl>.
//------------------------------------------------------------------------------

#include <CompMgr.h>
#include <TVec.h>
#include <PtrVec.h>

//------------------------------------------------------------------------------
// Class template Schedule <DomEl, RangeEl>
//
// An instance of class template Schedule <DomEl, RangeEl>
// represents a mapping whose domain is the Cartesian product of
//    the set of all instances of DomEl belonging to a Problem, and
//    the set of all periods belonging to that Problem
// and whose range is the set of all instances of RangeEl.
// For example, the declaration
//
//    WitSchedule <WitPart, double> tempSupplyVol (myProblem);
//
// declares tempSupplyVol to be a mapping from
//
//    {(thePart, t) | thePart is a Part in myProblem and t is a period in
//                    myProblem}
//
// into the set of all doubles. It is used by invoking the () operator, which
// returns a TVec <double> and then indexing into that TVec <double>. Thus if
// tempSupplyVol represent a temporary supply schedule, then
//
//    tempSupplyVol (thePart)[thePer] = 43.9;
//
// sets the temporary supply volume scheduled for thePart in thePer to 43.9.
//
// This class is implemented using a PtrVec <TVec <RangeEl> >
// which is indexed by using the NonClass template function: 
// mappingIndex (DomEl *).
//
// This is a value-based collection class; its methods make heavy use
// of the copy constructor for RangeEl. However, instances of DomEl
// are accessed through pointers.
//------------------------------------------------------------------------------

template <typename DomEl, typename RangeEl>
      class WitSchedule
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSchedule ();

      WitSchedule (WitProblem * theProblem, RangeEl theRangeEl);
         //
         // Constructs a Schedule for mapping the DomEl instances
         // and periods in theProblem into RangeEl.
         // Sets every element of this Schedule to theRangeEl.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitSchedule ();

      //------------------------------------------------------------------------
      // Public member operators.
      //------------------------------------------------------------------------

      inline const WitTVec <RangeEl> & operator () (
            const DomEl * theObject)
            const;
         //
         // Returns the TVec of values for theObject (const).

      inline WitTVec <RangeEl> & operator () (const DomEl * theObject);
         //
         // Returns the TVec of values for theObject (non-const).

      void operator = (const WitSchedule & theSchedule);

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      inline int domainSize () const;
         //
         // Returns # DomEl instances scheduled.

      void clear ();
         //
         // Resizes this Schedule to cover 0 instances.

      void allocate (WitProblem * theProblem, RangeEl theRangeEl);
         //
         // Resizes this Schedule for mapping the DomEl instances
         // and periods in theProblem into RangeEl. For each instance of
         // DomEl, and each period, the value of this Schedule will
         // be set to theRangeEl.

      void allocate1D (WitProblem * theProblem);
         //
         // Allocates the Vector of row Vector pointers, but not the row
         // Vectors.

      inline const WitTVec <RangeEl> & myTVecAt (int theIdx) const
         {
         return myTVecs_.myElemAt (theIdx);
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtor (WitSchedule);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitPtrVec <WitTVec <RangeEl> > myTVecs_;
         //
         // For each instance of DomEl, theInstance,
         // myTVecs_ (theInstance->mappingIndex ()) is the TVec <RangeEl>
         // that stores the value of this Schedule for theInstance in each
         // period.
   };

//------------------------------------------------------------------------------
// Implementation of inlines.
//------------------------------------------------------------------------------

template <typename DomEl, typename RangeEl>
      inline const WitTVec <RangeEl> &
         WitSchedule <DomEl, RangeEl>::operator () (const DomEl * theObject)
            const
   {
   witAssert (theObject != NULL);

   return myTVecs_.myElemAt (theObject->mappingIndex ());
   }

//------------------------------------------------------------------------------

template <typename DomEl, typename RangeEl>
      inline WitTVec <RangeEl> &
         WitSchedule <DomEl, RangeEl>::operator () (const DomEl * theObject)
   {
   witAssert (theObject != NULL);

   return myTVecs_.myElemAt (theObject->mappingIndex ());
   }

//------------------------------------------------------------------------------

template <typename DomEl, typename RangeEl>
      inline int WitSchedule <DomEl, RangeEl>::domainSize () const
   {
   return myTVecs_.length ();
   }

//------------------------------------------------------------------------------

#endif
@


1.42
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.41
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d49 1
a49 1
// which is indexed by using the NonClass template function:
d58 86
a143 86
class WitSchedule
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitSchedule ();

WitSchedule (WitProblem * theProblem, RangeEl theRangeEl);
//
// Constructs a Schedule for mapping the DomEl instances
// and periods in theProblem into RangeEl.
// Sets every element of this Schedule to theRangeEl.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitSchedule ();

//------------------------------------------------------------------------
// Public member operators.
//------------------------------------------------------------------------

inline const WitTVec <RangeEl> & operator () (
const DomEl * theObject)
const;
//
// Returns the TVec of values for theObject (const).

inline WitTVec <RangeEl> & operator () (const DomEl * theObject);
//
// Returns the TVec of values for theObject (non-const).

void operator = (const WitSchedule & theSchedule);

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

inline int domainSize () const;
//
// Returns # DomEl instances scheduled.

void clear ();
//
// Resizes this Schedule to cover 0 instances.

void allocate (WitProblem * theProblem, RangeEl theRangeEl);
//
// Resizes this Schedule for mapping the DomEl instances
// and periods in theProblem into RangeEl. For each instance of
// DomEl, and each period, the value of this Schedule will
// be set to theRangeEl.

void allocate1D (WitProblem * theProblem);
//
// Allocates the Vector of row Vector pointers, but not the row
// Vectors.

inline const WitTVec <RangeEl> & myTVecAt (int theIdx) const
{
return myTVecs_.myElemAt (theIdx);
}

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtor (WitSchedule);

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

WitPtrVec <WitTVec <RangeEl> > myTVecs_;
//
// For each instance of DomEl, theInstance,
// myTVecs_ (theInstance->mappingIndex ()) is the TVec <RangeEl>
// that stores the value of this Schedule for theInstance in each
// period.
};
d150 5
a154 5
inline const WitTVec <RangeEl> &
WitSchedule <DomEl, RangeEl>::operator () (const DomEl * theObject)
const
{
witAssert (theObject != NULL);
d156 2
a157 2
return myTVecs_.myElemAt (theObject->mappingIndex ());
}
d162 4
a165 4
inline WitTVec <RangeEl> &
WitSchedule <DomEl, RangeEl>::operator () (const DomEl * theObject)
{
witAssert (theObject != NULL);
d167 2
a168 2
return myTVecs_.myElemAt (theObject->mappingIndex ());
}
d173 4
a176 4
inline int WitSchedule <DomEl, RangeEl>::domainSize () const
{
return myTVecs_.length ();
}
@


1.40
log
@Stochastic Implosion
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d49 1
a49 1
// which is indexed by using the NonClass template function: 
d58 86
a143 86
      class WitSchedule
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSchedule ();

      WitSchedule (WitProblem * theProblem, RangeEl theRangeEl);
         //
         // Constructs a Schedule for mapping the DomEl instances
         // and periods in theProblem into RangeEl.
         // Sets every element of this Schedule to theRangeEl.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitSchedule ();

      //------------------------------------------------------------------------
      // Public member operators.
      //------------------------------------------------------------------------

      inline const WitTVec <RangeEl> & operator () (
            const DomEl * theObject)
            const;
         //
         // Returns the TVec of values for theObject (const).

      inline WitTVec <RangeEl> & operator () (const DomEl * theObject);
         //
         // Returns the TVec of values for theObject (non-const).

      void operator = (const WitSchedule & theSchedule);

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      inline int domainSize () const;
         //
         // Returns # DomEl instances scheduled.

      void clear ();
         //
         // Resizes this Schedule to cover 0 instances.

      void allocate (WitProblem * theProblem, RangeEl theRangeEl);
         //
         // Resizes this Schedule for mapping the DomEl instances
         // and periods in theProblem into RangeEl. For each instance of
         // DomEl, and each period, the value of this Schedule will
         // be set to theRangeEl.

      void allocate1D (WitProblem * theProblem);
         //
         // Allocates the Vector of row Vector pointers, but not the row
         // Vectors.

      inline const WitTVec <RangeEl> & myTVecAt (int theIdx) const
         {
         return myTVecs_.myElemAt (theIdx);
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtor (WitSchedule);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitPtrVec <WitTVec <RangeEl> > myTVecs_;
         //
         // For each instance of DomEl, theInstance,
         // myTVecs_ (theInstance->mappingIndex ()) is the TVec <RangeEl>
         // that stores the value of this Schedule for theInstance in each
         // period.
   };
d150 5
a154 5
      inline const WitTVec <RangeEl> &
         WitSchedule <DomEl, RangeEl>::operator () (const DomEl * theObject)
            const
   {
   witAssert (theObject != NULL);
d156 2
a157 2
   return myTVecs_.myElemAt (theObject->mappingIndex ());
   }
d162 4
a165 4
      inline WitTVec <RangeEl> &
         WitSchedule <DomEl, RangeEl>::operator () (const DomEl * theObject)
   {
   witAssert (theObject != NULL);
d167 2
a168 2
   return myTVecs_.myElemAt (theObject->mappingIndex ());
   }
d173 4
a176 4
      inline int WitSchedule <DomEl, RangeEl>::domainSize () const
   {
   return myTVecs_.length ();
   }
@


1.39
log
@Stochastic Implosion
@
text
@d120 5
@


1.38
log
@Stochastic Implosion
@
text
@d151 1
a151 1
   return myTVecs_ (theObject->mappingIndex ());
d162 1
a162 1
   return myTVecs_ (theObject->mappingIndex ());
@


1.37
log
@Updated the copyright date on all source files.
@
text
@d94 2
d126 1
a126 1
      noCopyCtorAssign (WitSchedule);
d132 1
a132 1
      WitPtrVec <WitTVec <RangeEl> > myVector_;
d135 1
a135 1
         // myVector_ (theInstance->mappingIndex ()) is the TVec <RangeEl>
d151 1
a151 1
   return myVector_ (theObject->mappingIndex ());
d162 1
a162 1
   return myVector_ (theObject->mappingIndex ());
d170 1
a170 1
   return myVector_.length ();
@


1.36
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.35
log
@[shared-resource pegging]
@
text
@d98 1
a98 1
      inline WitSiz domainSize () const;
d166 1
a166 1
      inline WitSiz WitSchedule <DomEl, RangeEl>::domainSize () const
@


1.34
log
@[shared-resource pegging]
@
text
@d98 1
a98 1
      inline size_t domainSize () const;
d166 1
a166 1
      inline size_t WitSchedule <DomEl, RangeEl>::domainSize () const
@


1.33
log
@[shared-resource pegging]
@
text
@d48 1
a48 1
// This class is implemented using a WitVector <TlObjPtr>
a51 2
// The TlObjPtrs stored by this Vector are really of type WitTVec <RangeEl> *.
//
@


1.32
log
@Revised mappingIndex code.
@
text
@d70 1
a70 1
      WitSchedule (WitProblem * theProblem, RangeEl initValue);
d74 1
a74 1
         // Sets every element of this Schedule to theValue.
d108 1
a108 1
      void allocate (WitProblem * theProblem, RangeEl theValue);
d113 1
a113 1
         // be set to theValue.
@


1.31
log
@Revised mappingIndex code.
@
text
@a21 1
#include <MapIdx.h>
@


1.30
log
@Double Precision.
@
text
@d152 1
a152 1
   return myVector_ (mappingIndex (theObject));
d163 1
a163 1
   return myVector_ (mappingIndex (theObject));
@


1.29
log
@Continued implementation of PIP.
@
text
@d34 1
a34 1
//    WitSchedule <WitPart, float> tempSupplyVol (myProblem);
d41 2
a42 2
// into the set of all floats. It is used by invoking the () operator, which
// returns a TVec <float> and then indexing into that TVec <float>. Thus if
d45 1
a45 1
//    tempSupplyVol (thePart)[t] = 43.9;
d47 1
a47 1
// sets the temporary supply volume scheduled for thePart in period t to 43.9.
@


1.28
log
@Continued implementation of PIP.
@
text
@d50 1
a50 1
// which is indexed by using the global template function: 
@


1.27
log
@Continued implementation of post-implosion pegging.
@
text
@d61 1
a61 1
      class WitSchedule: public WitUtil
@


1.26
log
@Changed some C style casts to C++ style.
@
text
@d16 1
a16 1
// Contains the declaration of class template Schedule <DomainType, RangeType>.
d22 1
d25 1
a25 1
// Class template Schedule <DomainType, RangeType>
d27 1
a27 1
// An instance of class template Schedule <DomainType, RangeType>
d29 1
a29 1
//    the set of all instances of DomainType belonging to a Problem, and
d31 1
a31 1
// and whose range is the set of all instances of RangeType.
d50 2
a51 2
// which is indexed by using the function: 
// DomainType::mappingIndex ().
d53 1
a53 1
// The TlObjPtrs stored by this Vector are really of type WitTVec <RangeType> *.
d56 1
a56 1
// of the copy constructor for RangeType. However, instances of DomainType
d60 1
a60 1
template <typename DomainType, typename RangeType>
d71 1
a71 1
      WitSchedule (WitProblem * theProblem, RangeType initValue);
d73 2
a74 2
         // Constructs a Schedule for mapping the DomainType instances
         // and periods in theProblem into RangeType.
d87 2
a88 2
      inline const WitTVec <RangeType> & operator () (
            const DomainType * theObject)
d93 1
a93 2
      inline WitTVec <RangeType> & operator () (
            const DomainType * theObject);
d103 1
a103 1
         // Returns # DomainType instances scheduled.
d109 1
a109 1
      void allocate (WitProblem * theProblem, RangeType theValue);
d111 3
a113 3
         // Resizes this Schedule for mapping the DomainType instances
         // and periods in theProblem into RangeType. For each instance of
         // DomainType, and each period, the value of this Schedule will
d133 1
a133 1
      WitPtrVec <WitTVec <RangeType> > myVector_;
d135 2
a136 2
         // For each instance of DomainType, theInstance,
         // myVector_ (theInstance->mappingIndex ()) is the TVec <RangeType>
d140 35
@


1.25
log
@Various internal changes.
@
text
@d41 1
a41 1
// returns a TVec (float) and then indexing into that TVec (float). Thus if
@


1.24
log
@Various internal changes.
@
text
@d127 1
a127 7
      WitSchedule (
            const WitSchedule <DomainType, RangeType> &);

      void operator = (
            const WitSchedule <DomainType, RangeType> &);
         //
         // See noCopyCtorAssign in macs.h.
@


1.23
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d59 1
a59 1
template <class DomainType, class RangeType>
@


1.22
log
@Continued implementation of Single-Source.
@
text
@a120 13
      RangeType ifAny (const DomainType * theObject, WitPeriod thePer) const;
         //
         // Returns (* this)(theObject)[thePer], if that portion of this
         // Schedule has been allocated, otherwise NULL.

      void insert (
            RangeType          theValue,
            const DomainType * theObject,
            WitPeriod          thePer);
         //
         // Stores theValue in (* this)(theObject)[thePer], allocating as
         // necessary.

@


1.21
log
@Continued implementation of single-source.
@
text
@d121 1
a121 4
      inline RangeType ifAny (
            const DomainType * theObject,
            WitPeriod          thePer)
            const;
d156 1
a156 1
         // that stores the value of this Schedule for theInstance in each 
a158 146

//------------------------------------------------------------------------------
// Implementation of class template Schedule <DomainType, RangeType>
//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      WitSchedule <DomainType, RangeType>::WitSchedule ():
         myVector_ ()
   {
   ifDebug (DomainType * theObject);

   ifDebug (DomainType::verifyMappingIndex (theObject));
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      WitSchedule <DomainType, RangeType>::WitSchedule (
            WitProblem * theProblem, RangeType initValue):
         myVector_ ()
   {
   allocate (theProblem, initValue);
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      WitSchedule <DomainType, RangeType>::~WitSchedule ()
   {
   clear ();
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      inline const WitTVec <RangeType> &
         WitSchedule <DomainType, RangeType>::operator () (
            const DomainType * theObject) const
   {
   witAssert (theObject != NULL);

   return myVector_ (theObject->mappingIndex ());
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      inline WitTVec <RangeType> &
         WitSchedule <DomainType, RangeType>::
            operator () (const DomainType * theObject)
   {
   witAssert (theObject != NULL);

   return myVector_ (theObject->mappingIndex ());
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      inline size_t WitSchedule <DomainType, RangeType>::domainSize () const
   {
   return myVector_.length ();
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      void WitSchedule <DomainType, RangeType>::clear ()
   {
   int i;

   for (i = 0; i < domainSize (); ++i)
      delete myVector_[i];

   myVector_.clear ();
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      void WitSchedule <DomainType, RangeType>::allocate (
         WitProblem * theProblem,
         RangeType    theValue)
   {
   int i;

   allocate1D (theProblem);

   for (i = 0; i < domainSize (); ++i)
      myVector_ (i).allocate (theProblem, theValue);
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      void WitSchedule <DomainType, RangeType>::allocate1D (
         WitProblem * theProblem)
   {
   int i;
   int nInst;

   nInst = theProblem->myCompMgr ()->nInstances ((DomainType *) NULL);

   clear ();

   myVector_.resize (nInst);

   for (i = 0; i < domainSize (); ++i)
      myVector_[i] = new WitTVec <RangeType>;
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      inline RangeType WitSchedule <DomainType, RangeType>::ifAny (
         const DomainType * theObject,
         WitPeriod          thePer)
         const
   {
   if (domainSize () == 0)
      return (RangeType) NULL;

   if ((* this)(theObject).length () == 0)
      return (RangeType) NULL;

   return (* this) (theObject)[thePer];
   }

//------------------------------------------------------------------------------

template <class DomainType, class RangeType>
      void WitSchedule <DomainType, RangeType>::insert (
         RangeType          theValue,
         const DomainType * theObject,
         WitPeriod          thePer)
   {
   if (domainSize () == 0)
      allocate1D (theObject->myProblem ());

   if ((* this)(theObject).length () == 0)
      (* this)(theObject).allocate (
         theObject->myProblem (),
         (RangeType) NULL);

   (* this) (theObject)[thePer] = theValue;
   }
@


1.20
log
@Continued implementation of single source.
@
text
@a96 20
      inline RangeType operator () (
            const DomainType * theObject,
            WitPeriod          thePer)
            const
         {
         return (* this) (theObject)[thePer];
         }
         //
         // Returns the value corresponding to theObject in thePer (const).

      inline RangeType & operator () (
            const DomainType * theObject,
            WitPeriod          thePer)
         {
         return (* this) (theObject)[thePer];
         }
         //
         // Returns the value corresponding to theObject in thePer
         // (non-const).

d121 4
a124 1
      inline RangeType ifAny (const DomainType * theObject, WitPeriod t) const;
d126 1
a126 1
         // Returns (* this)(theObject)[t], if that portion of this
d132 1
a132 1
            WitPeriod          t);
d134 1
a134 1
         // Stores theValue in (* this)(theObject)[t], allocating as
d278 1
a278 1
         WitPeriod          t)
d287 1
a287 1
   return (* this) (theObject, t);
d296 1
a296 1
         WitPeriod          t)
d306 1
a306 1
   (* this) (theObject, t) = theValue;
@


1.19
log
@Preliminary work on single source.
@
text
@d121 1
a121 1
      size_t domainSize () const;
d141 1
a141 1
      RangeType ifAny (const DomainType * theObject, WitPeriod t) const;
d185 1
a185 1
      inline WitSchedule <DomainType, RangeType>::WitSchedule ():
d196 1
a196 1
      inline WitSchedule <DomainType, RangeType>::WitSchedule (
d206 1
a206 1
      inline WitSchedule <DomainType, RangeType>::~WitSchedule ()
d246 1
a246 1
      inline void WitSchedule <DomainType, RangeType>::clear ()
d259 1
a259 1
      inline void WitSchedule <DomainType, RangeType>::allocate (
d274 1
a274 1
      inline void WitSchedule <DomainType, RangeType>::allocate1D (
d310 1
a310 1
      inline void WitSchedule <DomainType, RangeType>::insert (
@


1.18
log
@Continued preliminary work on single source.
@
text
@d21 1
a167 10
      inline WitTVec <RangeType> *   vectorEl (int theIndex) const
         {
         return (WitTVec <RangeType> *  ) myVector_[theIndex];
         }

      inline WitTVec <RangeType> * & vectorEl (int theIndex)
         {
         return (WitTVec <RangeType> * &) myVector_[theIndex];
         }

d172 1
a172 1
      WitVector <WitTlObjPtr> myVector_;
d175 3
a177 7
         // myVector_ (theInstance->mappingIndex ()) is a pointer to the
         // TVec (RangeType) that stores the value of this
         // Schedule for theInstance in each period.
         // The type argument to Vector is TlObj *, so as to
         // avoid the need to declare and implement something like
         // Vector (TVec (RangeType) *), which would be getting a
         // little out of hand.
d220 1
a220 1
   return * vectorEl (theObject->mappingIndex ());
d232 1
a232 1
   return * vectorEl (theObject->mappingIndex ());
d251 1
a251 1
      delete vectorEl (i);
d268 1
a268 1
      vectorEl (i)->allocate (theProblem, theValue);
d284 1
a284 1
   myVector_.resize (nInst, NULL);
d287 1
a287 1
      vectorEl (i) = new WitTVec <RangeType>;
@


1.17
log
@Continued preliminary work on single source.
@
text
@d16 1
a16 1
// Contains the declaration of class Schedule (DomainType, RangeType).
d20 1
a20 7
#include <Material.h>
#include <Demand.h>
#include <Opn.h>
#include <ConsEnt.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <BoundSet.h>
d23 1
a23 1
// generic class Schedule (DomainType, RangeType)
d25 1
a25 1
// Each instance of generic class Schedule (DomainType, RangeType)
d32 1
a32 1
//    WitSchedule (WitPart, float) tempSupplyVol (myProblem);
a55 29
//
// To declare and implement Schedule (YourDomain, YourRange),
//
// 1. Be sure the following two functions are declared and implemented:
//
//    inline int YourDomain::mappingIndex () const;
//       //
//       // Returns an index that distinguishes theObject from all other
//       // instances of YourDomain in theObject's Problem.
//
//    int CompMgr::nInstances (const YourDomain *) const;
//       //
//       // Returns the # of instances of YourDomain in the CompMgr.
//
// 2. Next follow instructions in TVec.h called "To declare and implement
//    TVec (YourType)", where YourType = YourRange.
//
// 3. Finally look for the following line in this file, Mapping.h:
//
//       declare2 (WitSchedule, YourDomain, YourRange)
//
//    If it already exists, Schedule (YourDomain, YourRange) has already
//    been implemented and no further action is required. Otherwise, you must
//    add this line. In this case, you must also add the following line to
//    Mapping.C:
//
//       implement2 (WitSchedule, YourDomain, YourRange)
//
// Implemented in Mapping.C.
d58 245
d304 16
a319 1
// Generic class declaration macro.
d322 16
a337 197
#define WitScheduledeclare2(DomainType, RangeType)                             \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitSchedule (DomainType, RangeType): public WitUtil                      \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitSchedule (DomainType, RangeType) ();                                  \
         /*                                                                  */\
         /* Constructs an empty WitSchedule (one that does not map any       */\
         /* instances of DomainType).                                        */\
                                                                               \
      WitSchedule (DomainType, RangeType) (                                    \
            WitProblem * theProblem,                                           \
            RangeType    initValue);                                           \
         /*                                                                  */\
         /* Constructs a Schedule for mapping the DomainType instances       */\
         /* and periods in theProblem into RangeType.                        */\
         /* Sets every element of this Schedule to theValue.                 */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitSchedule (DomainType, RangeType) ();                                 \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Public member operators.                                            */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline const WitTVec <RangeType> & operator () (                         \
            const DomainType * theObject)                                      \
            const;                                                             \
         /*                                                                  */\
         /* Returns the TVec of values for theObject (const).                */\
                                                                               \
      inline WitTVec <RangeType> & operator () (                               \
            const DomainType * theObject);                                     \
         /*                                                                  */\
         /* Returns the TVec of values for theObject (non-const).            */\
                                                                               \
      inline RangeType operator () (                                           \
            const DomainType * theObject,                                      \
            WitPeriod          thePer)                                         \
            const                                                              \
         {                                                                     \
         return (* this) (theObject)[thePer];                                  \
         }                                                                     \
         /*                                                                  */\
         /* Returns the value corresponding to theObject in thePer (const).  */\
                                                                               \
      inline RangeType & operator () (                                         \
            const DomainType * theObject,                                      \
            WitPeriod          thePer)                                         \
         {                                                                     \
         return (* this) (theObject)[thePer];                                  \
         }                                                                     \
         /*                                                                  */\
         /* Returns the value corresponding to theObject in thePer           */\
         /* (non-const).                                                     */\
                                                                               \
      void operator = (                                                        \
            const WitSchedule (DomainType, RangeType) & theSchedule);          \
         /*                                                                  */\
         /* Copies the elements of theSchedule into the corresponding        */\
         /* elements of this Schedule.                                       */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Other public member functions.                                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      size_t domainSize () const;                                              \
         /*                                                                  */\
         /* Returns # DomainType instances scheduled.                        */\
                                                                               \
      void clear ();                                                           \
         /*                                                                  */\
         /* Resizes this Schedule to cover 0 instances.                      */\
                                                                               \
      void allocate (WitProblem * theProblem, RangeType theValue);             \
         /*                                                                  */\
         /* Resizes this Schedule for mapping the DomainType instances       */\
         /* and periods in theProblem into RangeType. For each instance of   */\
         /* DomainType, and each period, the value of this Schedule will     */\
         /* be set to theValue.                                              */\
                                                                               \
      void allocate1D (WitProblem * theProblem);                               \
         /*                                                                  */\
         /* Allocates the Vector of row Vector pointers, but not the row     */\
         /* Vectors.                                                         */\
                                                                               \
      RangeType ifAny (const DomainType * theObject, WitPeriod t) const;       \
         /*                                                                  */\
         /* Returns (* this)(theObject)[t], if that portion of this          */\
         /* Schedule has been allocated, otherwise NULL.                     */\
                                                                               \
      void insert (                                                            \
            RangeType          theValue,                                       \
            const DomainType * theObject,                                      \
            WitPeriod          t);                                             \
         /*                                                                  */\
         /* Stores theValue in (* this)(theObject)[t], allocating as         */\
         /* necessary.                                                       */\
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtor (WitSchedule (DomainType, RangeType));                        \
                                                                               \
      inline WitTVec <RangeType> *   vectorEl (int theIndex) const             \
         {                                                                     \
         return (WitTVec <RangeType> *  ) myVector_[theIndex];                 \
         }                                                                     \
                                                                               \
      inline WitTVec <RangeType> * & vectorEl (int theIndex)                   \
         {                                                                     \
         return (WitTVec <RangeType> * &) myVector_[theIndex];                 \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member data.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitVector <WitTlObjPtr> myVector_;                                       \
         /*                                                                  */\
         /* For each instance of DomainType, theInstance,                    */\
         /* myVector_ (theInstance->mappingIndex ()) is a pointer to the     */\
         /* TVec (RangeType) that stores the value of this                   */\
         /* Schedule for theInstance in each period.                         */\
         /* The type argument to Vector is TlObj *, so as to                 */\
         /* avoid the need to declare and implement something like           */\
         /* Vector (TVec (RangeType) *), which would be getting a            */\
         /* little out of hand.                                              */\
   };                                                                          \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Implementations of inlines.                                               */\
/*---------------------------------------------------------------------------*/\
                                                                               \
inline const WitTVec <RangeType> &                                             \
      WitSchedule (DomainType, RangeType)::operator () (                       \
         const DomainType * theObject) const                                   \
   {                                                                           \
   witAssert (theObject != NULL);                                              \
                                                                               \
   return * vectorEl (theObject->mappingIndex ());                             \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
inline WitTVec <RangeType> &                                                   \
   WitSchedule (DomainType, RangeType)::                                       \
      operator () (const DomainType * theObject)                               \
   {                                                                           \
   witAssert (theObject != NULL);                                              \
                                                                               \
   return * vectorEl (theObject->mappingIndex ());                             \
   }                                                                           \

//------------------------------------------------------------------------------
// Declarations of all specific cases of the generic classes declared in this
// file.
//------------------------------------------------------------------------------

declare2 (WitSchedule, WitPart,      int)
declare2 (WitSchedule, WitDemand,    int)

declare2 (WitSchedule, WitNode,      float)
declare2 (WitSchedule, WitPart,      float)
declare2 (WitSchedule, WitMaterial,  float)
declare2 (WitSchedule, WitOperation, float)
declare2 (WitSchedule, WitDemand,    float)
declare2 (WitSchedule, WitBillEntry, float)
declare2 (WitSchedule, WitSubEntry,  float)

declare2 (WitSchedule, WitPart,      double)
declare2 (WitSchedule, WitMaterial,  double)
declare2 (WitSchedule, WitOperation, double)
declare2 (WitSchedule, WitDemand,    double)
declare2 (WitSchedule, WitConsEntry, double)
declare2 (WitSchedule, WitBopEntry,  double)

declare2 (WitSchedule, WitPart,      WitTlObjPtr)
declare2 (WitSchedule, WitMaterial,  WitTlObjPtr)
declare2 (WitSchedule, WitOperation, WitTlObjPtr)
declare2 (WitSchedule, WitBomEntry,  WitTlObjPtr)
declare2 (WitSchedule, WitSubEntry,  WitTlObjPtr)
declare2 (WitSchedule, WitDemand,    WitTlObjPtr)
declare2 (WitSchedule, WitBoundSet,  WitTlObjPtr)
@


1.16
log
@Preliminary work on single source.
@
text
@d57 1
a57 1
// The TlObjPtrs stored by this Vector are really of type WitTVec (RangeType) *.
d132 1
a132 1
      inline const WitTVec (RangeType) & operator () (                         \
d138 1
a138 1
      inline WitTVec (RangeType) & operator () (                               \
d214 1
a214 1
      inline WitTVec (RangeType) *   vectorEl (int theIndex) const             \
d216 1
a216 1
         return (WitTVec (RangeType) *  ) myVector_[theIndex];                 \
d219 1
a219 1
      inline WitTVec (RangeType) * & vectorEl (int theIndex)                   \
d221 1
a221 1
         return (WitTVec (RangeType) * &) myVector_[theIndex];                 \
d244 1
a244 1
inline const WitTVec (RangeType) &                                             \
d255 1
a255 1
inline WitTVec (RangeType) &                                                   \
@


1.15
log
@Preliminary work on single source.
@
text
@d53 1
a53 1
// This class is implemented using a WitVector (DomainType, TlPtr)
d57 1
a57 2
// The TlPtrs stored by this WitVector are really of type
// WitTVec (RangeType) *.
d228 1
a228 1
      WitVector (WitTlObjPtr) myVector_;                                       \
@


1.14
log
@Began implementation of object iteration.
@
text
@a163 4
      void operator = (RangeType theValue);                                    \
         /*                                                                  */\
         /* Sets every element of this Schedule to theValue.                 */\
                                                                               \
@


1.13
log
@Implemented class template PtrSched <*, *>.
@
text
@d20 7
@


1.12
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@a289 1
declare2 (WitSchedule, WitBopEntry,  WitTlObjPtr)
@


1.11
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d226 1
a226 1
      WitVector (WitTlPtr) myVector_;                                          \
d232 1
a232 1
         /* The type argument to Vector is Tl * so as to                     */\
d285 8
a292 8
declare2 (WitSchedule, WitPart,      WitTlPtr)
declare2 (WitSchedule, WitMaterial,  WitTlPtr)
declare2 (WitSchedule, WitOperation, WitTlPtr)
declare2 (WitSchedule, WitBomEntry,  WitTlPtr)
declare2 (WitSchedule, WitSubEntry,  WitTlPtr)
declare2 (WitSchedule, WitBopEntry,  WitTlPtr)
declare2 (WitSchedule, WitDemand,    WitTlPtr)
declare2 (WitSchedule, WitBoundSet,  WitTlPtr)
@


1.10
log
@Coarse selection splitting.
@
text
@d186 1
a186 1
      void partiallyAllocate (WitProblem * theProblem);                        \
@


1.9
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d282 2
a283 1
declare2 (WitSchedule, WitBillEntry, double)
@


1.8
log
@Further development of coarse selection splitting.
@
text
@d263 2
a264 1
// Declarations of all specific cases of generic class Schedule.
d282 1
a282 1
declare2 (WitSchedule, WitBomEntry,  double)
@


1.7
log
@Futher development of selection splitting.
@
text
@d46 1
a46 1
// This class is implemented using a WitVector (DomainType, WitTypelessPtr)
d50 1
a50 1
// The WitTypelessPtrs stored by this WitVector are really of type
d226 1
a226 1
      WitVector (WitTypelessPtr) myVector_;                                    \
d232 1
a232 1
         /* The type argument to WitVector is WitTypelessPtr so as to        */\
d234 1
a234 1
         /* WitVector (WitTVec (RangeType) *), which would be getting a      */\
d283 8
a290 8
declare2 (WitSchedule, WitPart,      WitTypelessPtr)
declare2 (WitSchedule, WitMaterial,  WitTypelessPtr)
declare2 (WitSchedule, WitOperation, WitTypelessPtr)
declare2 (WitSchedule, WitBomEntry,  WitTypelessPtr)
declare2 (WitSchedule, WitSubEntry,  WitTypelessPtr)
declare2 (WitSchedule, WitBopEntry,  WitTypelessPtr)
declare2 (WitSchedule, WitDemand,    WitTypelessPtr)
declare2 (WitSchedule, WitBoundSet,  WitTypelessPtr)
@


1.6
log
@Some minor changes.
@
text
@d281 1
@


1.5
log
@Refactoring for selection splitting.
@
text
@d70 1
a70 1
// 2. Next follow instructions in Vector.h called "To declare and implement
d210 1
a210 4
      WitSchedule (DomainType, RangeType) (                                    \
         const WitSchedule (DomainType, RangeType) &);                         \
         /*                                                                  */\
         /* Not Implemented: Prevents unintentional copying.                 */\
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d157 1
a157 1
      WitSchedule (DomainType, RangeType) & operator = (RangeType theValue);   \
d161 1
a161 1
      WitSchedule (DomainType, RangeType) & operator = (                       \
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d95 1
a95 1
class WitSchedule (DomainType, RangeType)                                      \
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d157 1
a157 1
      WitSchedule(DomainType, RangeType) & operator = (RangeType theValue);    \
d161 2
a162 2
      WitSchedule(DomainType, RangeType) & operator = (                        \
            const WitSchedule(DomainType, RangeType) & theSchedule);           \
d210 2
a211 2
      WitSchedule(DomainType, RangeType) (                                     \
         const WitSchedule(DomainType, RangeType) &);                          \
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

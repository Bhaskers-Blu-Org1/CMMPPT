head	1.80;
access;
symbols
	sce_5_01_20080919:1.74
	latest_sce_4_20_20060523:1.47.0.2
	sce_4_20_20060523:1.47
	latest_sce4_20_OSL:1.46.0.2
	sce_4_20_OSL:1.46
	sce_410_withVa:1.42
	sce_4_05_20040511:1.40
	sce_4_00_20040201:1.39
	nextGenBranch:1.34.0.2
	nextGenRoot:1.34
	sce_3_30_20030627:1.34
	EndRw-branch:1.28.0.4
	Root-of-EndRw:1.28
	rwToStl:1.28.0.2
	latest_sce_3_10_20010924:1.13.0.2
	sce_3_10_20010924:1.13
	latest_sce_3_00_20010601:1.5.0.4
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.80
date	2011.09.28.23.49.08;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2011.09.24.00.27.25;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2011.08.30.20.17.20;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2011.02.09.23.31.39;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2010.09.10.22.10.37;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2010.03.16.22.42.24;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.25.22.35.09;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.25.19.37.57;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.25.16.36.33;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.22.23.55.49;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.22.23.18.18;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2008.02.22.21.36.09;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2008.02.21.23.58.46;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.12.11.22.00.27;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.12.06.22.53.00;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.12.06.22.01.21;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.15.17.15.32;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.05.21.05.59;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.05.16.15.22;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.30.16.01.18;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.30.21.34.58;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.04.22.15.34;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.04.20.04.39;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.02.23.01.14;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.28.20.04.55;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.27.22.59.29;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.27.21.03.03;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.27.19.59.30;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.10.00.08.13;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.08.22.47.33;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.08.00.14.24;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.21.15.42.25;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.19.19.17.06;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.02.17.33.56;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.02.03.16.48.12;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.05.22.24.08;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.30.21.57.54;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.09.26.23.02.17;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.07.20.23.43;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.28.19.34.25;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.13.21.50.12;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.31.21.44.53;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.23.16.18.46;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.17.22.29.59;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.17.21.23.00;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.11.18.29.12;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.11.19.35.37;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.19.16.48.13;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.13.23.06.26;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.23.19.13.19;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.02.23.40.37;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.02.22.18.21;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.23.18.09.10;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.22.21.16.19;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.09.20.49.48;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.28.19.40.14;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.04.23.07.18;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.03.16.01.46;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.30.20.08.57;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.07.20.14.53;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.02.20.53.10;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.01.14.25.53;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.25.19.14.49;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.24.20.05.29;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.24.18.26.05;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.22.14.32.04;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.18.14.02.28;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.06.17.31.06;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.03.18.40.40;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.30.15.12.08;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.28.00.48.32;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.27.21.28.38;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.25.16.08.13;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.21.18.24.30;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.01.19.23.32;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.04.22.27.48;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.06.19.58.36;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.22.23.11.37;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.26;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches;
next	;


desc
@@


1.80
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "CompMgr.C"
//
// Contains the implementation of the following classes:
//
//    CompMgr.
//    DelCompItr.
//------------------------------------------------------------------------------

#include <CompMgr.h>
#include <DelCompItr.h>
#include <NodeTable.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Material.h>
#include <Capacity.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Demand.h>
#include <BoundSet.h>
#include <HeurAllMgr.h>
#include <Pre.h>
#include <PipMgr.h>
#include <ApiMgr.h>
#include <MsgFac.h>
#include <PtrVec.h>

//------------------------------------------------------------------------------
// Implementation of class CompMgr.
//------------------------------------------------------------------------------

WitCompMgr::WitCompMgr (WitProblem * theProblem):

      myProblem_        (theProblem),
      myMsgFac_         (theProblem->myMsgFac ()),

      myGlobalComp_     (NULL),
      myOptComp_        (NULL),
      allParts_         (),
      allOperations_    (),

      allComponents_    (),
      myPartTable_      (NULL),
      myOpnTable_       (NULL),

      nParts_           (0),
      nMaterials_       (0),
      nOperations_      (0),
      nBomEntries_      (0),
      nSubEntries_      (0),
      nBopEntries_      (0),
      nDemands_         (0),
      nBoundSets_       (0),

      cachedDemand_     (NULL),
      cachedBomEntry_   (NULL),
      cachedSubEntry_   (NULL),
      cachedBopEntry_   (NULL),

      myDelCompItr_     (NULL),
      purging_          (false),
      recountingComp_   (NULL),
      deletingComp_     (NULL),
      clearingDepLists_ (false),
      settingNodeName_  (false)
   {
   myPartTable_   = new WitDerNodeTable <WitPart>      (myProblem_);
   myOpnTable_    = new WitDerNodeTable <WitOperation> (myProblem_);
   myDelCompItr_  = new WitDelCompItr                  (myProblem_);
   }

//------------------------------------------------------------------------------

WitCompMgr::~WitCompMgr ()
   {
   delete myDelCompItr_;
   delete myPartTable_;
   delete myOpnTable_;

   myPartTable_ = NULL;
   myOpnTable_  = NULL;

   clearCaches ();
   deleteComps ();
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitGlobalComp * theGlobalComp)
   {
   insertComp (theGlobalComp);

   witAssert (myGlobalComp_ == NULL);

   myGlobalComp_ = theGlobalComp;
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitOptComp * theOptComp)
   {
   insertComp (theOptComp);

   witAssert (myOptComp_ == NULL);

   myOptComp_ = theOptComp;
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitMaterial * theMat)
   {
   insertPart (theMat);

   ++ nMaterials_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitCapacity * theCap)
   {
   insertPart (theCap);
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitOperation * theOpn)
   {
   insertComp            (theOpn);
   myOpnTable_  ->insert (theOpn);
   allOperations_.append (theOpn);

   ++ nOperations_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitBomEntry * theBomEnt)
   {
   insertComp (theBomEnt);

   cachedBomEntry_ = theBomEnt;

   ++ nBomEntries_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitSubEntry * theSub)
   {
   insertComp (theSub);

   cachedSubEntry_ = theSub;

   ++ nSubEntries_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitBopEntry * theBopEnt)
   {
   insertComp (theBopEnt);

   cachedBopEntry_ = theBopEnt;

   ++ nBopEntries_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::insert (WitDemand * theDemand)
   {
   insertComp (theDemand);

   cachedDemand_ = theDemand;

   ++ nDemands_;
   }

//------------------------------------------------------------------------------

WitPart * WitCompMgr::myMatchFor (WitPart * thePart)
   {
   WitPart * matchPart;

   matchPart = findPart (thePart->partName ().myCstring ());

   witAssert (matchPart != NULL);

   return matchPart;
   }

//------------------------------------------------------------------------------

WitMaterial * WitCompMgr::myMatchFor (WitMaterial * theMat)
   {
   WitPart *     thePart;
   WitMaterial * matchMat;

   thePart   = theMat;

   matchMat  = myMatchFor (thePart)->thisMat ();

   witAssert (matchMat != NULL);

   return matchMat;
   }

//------------------------------------------------------------------------------

WitDemand * WitCompMgr::myMatchFor (WitDemand * theDemand)
   {
   WitPart *    matchPart;
   const char * theDemName;
   WitDemand *  matchDemand;

   matchPart   = myMatchFor (theDemand->demandedPart ());

   theDemName  = theDemand->demandName ().myCstring ();

   matchDemand = findDemand (matchPart, theDemName);

   witAssert (matchDemand != NULL);

   return matchDemand;
   }

//------------------------------------------------------------------------------

WitOperation * WitCompMgr::myMatchFor (WitOperation * theOpn)
   {
   WitOperation * matchOperation;

   matchOperation = findOperation (theOpn->operationName ().myCstring ());

   witAssert (matchOperation != NULL);

   return matchOperation;
   }

//------------------------------------------------------------------------------

WitSubEntry * WitCompMgr::myMatchFor (WitSubEntry * theSub)
   {
   WitOperation * matchOperation;
   WitBomEntry *  matchBomEnt;
   WitSubEntry *  matchSub;

   matchOperation = myMatchFor (theSub->myOperation ());

   matchBomEnt    = findBomEntry (matchOperation, theSub->myBomEntIndex ());

   witAssert (matchBomEnt != NULL);

   matchSub       = findSubEntry (matchBomEnt,    theSub->localIndex ());

   witAssert (matchSub    != NULL);

   return matchSub;
   }

//------------------------------------------------------------------------------

WitBoundSet * WitCompMgr::myMatchFor (WitBoundSet * theBoundSet)
   {
   return theBoundSet->myMatchIn (this);
   }

//------------------------------------------------------------------------------

WitPart * WitCompMgr::findPart (const char * theName) const
   {
   return myPartTable_->findDerNode (theName);
   }

//------------------------------------------------------------------------------

WitOperation * WitCompMgr::findOperation (const char * theName) const
   {
   return myOpnTable_->findDerNode (theName);
   }

//------------------------------------------------------------------------------

WitBomEntry * WitCompMgr::findBomEntry (WitOperation * theOpn, int theIndex)
   {
   WitBomEntry * theBomEnt;

   witAssert (theOpn->myCompMgr () == this);

   if (cachedBomEntry_ != NULL)
      if (   cachedBomEntry_->myOperation () == theOpn)
         if (cachedBomEntry_->localIndex  () == theIndex)
            return cachedBomEntry_;

   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->localIndex () == theIndex)
         {
         cachedBomEntry_ = theBomEnt;

         return cachedBomEntry_;
         }

   return NULL;
   }

//------------------------------------------------------------------------------

WitSubEntry * WitCompMgr::findSubEntry (WitBomEntry * theBomEnt, int theIndex)
   {
   WitSubEntry * theSub;

   witAssert (theBomEnt->myCompMgr () == this);

   if (cachedSubEntry_ != NULL)
      if (   cachedSubEntry_->myBomEnt () == theBomEnt)
         if (cachedSubEntry_->localIndex () == theIndex)
            return cachedSubEntry_;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->localIndex () == theIndex)
         {
         cachedSubEntry_ = theSub;

         return cachedSubEntry_;
         }

   return NULL;
   }

//------------------------------------------------------------------------------

WitBopEntry * WitCompMgr::findBopEntry (WitOperation * theOpn, int theIndex)
   {
   WitBopEntry * theBopEnt;

   witAssert (theOpn->myCompMgr () == this);

   if (cachedBopEntry_ != NULL)
      if (   cachedBopEntry_->myOperation () == theOpn)
         if (cachedBopEntry_->localIndex  () == theIndex)
            return cachedBopEntry_;

   forEachEl (theBopEnt, theOpn->bop ())
      if (theBopEnt->localIndex () == theIndex)
         {
         cachedBopEntry_ = theBopEnt;

         return cachedBopEntry_;
         }

   return NULL;
   }

//------------------------------------------------------------------------------

WitDemand * WitCompMgr::findDemand (WitPart * thePart, const char * theName)
   {
   WitDemand * theDemand;

   witAssert (thePart->myCompMgr () == this);

   if (cachedDemand_ != NULL)
      if (cachedDemand_->demandedPart () == thePart)
         if (cachedDemand_->demandName () == theName)
            return cachedDemand_;

   cachedDemand_ =
      thePart->myDemands ().find (& WitDemand::demandName, theName);

   return cachedDemand_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountGlobalComp (WitGlobalComp * theGlobalComp)
   {
   recountComponent (theGlobalComp);
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountOptComp (WitOptComp * theOptComp)
   {
   recountComponent (theOptComp);
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountMaterial (WitMaterial * theMat)
   {
   recountPart (theMat);

   ++ nMaterials_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountCapacity (WitCapacity * theCap)
   {
   recountPart (theCap);
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountOperation (WitOperation * theOpn)
   {
   recountComponent (theOpn);

   ++ nOperations_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountBomEntry (WitBomEntry * theBomEnt)
   {
   recountConsEntry (theBomEnt);

   ++ nBomEntries_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountSubEntry (WitSubEntry * theSub)
   {
   recountConsEntry (theSub);

   ++ nSubEntries_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountBopEntry (WitBopEntry * theBopEnt)
   {
   recountComponent (theBopEnt);

   ++ nBopEntries_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountDemand (WitDemand * theDemand)
   {
   recountComponent (theDemand);

   ++ nDemands_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::setPartName (WitPart * thePart, const char * theName)
   {
   myPartTable_->remove (thePart);

   setNodeName (thePart, theName);

   myPartTable_->insert (thePart);
   }

//------------------------------------------------------------------------------

void WitCompMgr::setOperationName (WitOperation * theOpn, const char * theName)
   {
   myOpnTable_->remove (theOpn);

   setNodeName (theOpn, theName);

   myOpnTable_->insert (theOpn);
   }

//------------------------------------------------------------------------------

int WitCompMgr::nBoundSetsSpecified () const
   {
   int            nSpec;
   WitComponent * theComp;
   WitBoundSet *  theBoundSet;

   nSpec = 0;

   forEachEl (theComp, allComponents ())
      {
      theBoundSet = theComp->myBoundSet ();

      if (theBoundSet != NULL)
         if (not theBoundSet->isAtDefault ())
            ++ nSpec;
      }

   return nSpec;
   }

//------------------------------------------------------------------------------

void WitCompMgr::purgeData ()
   {
   WitComponent * theComp;
   WitDelComp   * theDelComp;
   int            nUserSel;
   int            nTotSel;
   int            nDelCompsBefore;

   WitList <WitComponent> remainingComps;
      //
      // The List of all Components not deleted by this purge.

   WitList <WitComponent> selComps;
      //
      // The List of all Components to be deleted, in reverse creation order.

   if (myDelCompItr_->active ())
      myMsgFac () ("purgeWhileItrActSmsg");

   if (myGlobalComp ()->perfPegging ())
      myProblem ()->myHeurAllMgr ()->clearPegging ();

   myProblem ()->myPipMgr ()->clearShipSeq ();

   myGlobalComp ()->clearPgdCritList ();

   myMsgFac () ("purgeDataMsg");
   myMsgFac ().divide ();

   nUserSel = nSelForDel ();

   if (nUserSel == 0)
      {
      myMsgFac () ("noSelForDelsMsg");
      myMsgFac ().divide ();

      return;
      }

   myProblem ()->myPreprocessor ()->unpreprocess ();

   nDelCompsBefore = nDelComps ();

   purging_        = true;

   forEachEl (theComp, allComponents ())
      {
      theDelComp = theComp->thisDelComp ();

      if (theDelComp != NULL)
         theDelComp->identifyOrAutoSel ();
      }

   nTotSel = nSelForDel ();

   myMsgFac () ("delCompsMsg", nUserSel, nTotSel - nUserSel, nTotSel);

   forEachEl (theComp, allComponents ())
      theComp->purgeCompLists ();

   purgeCompLists ();

   clearCaches ();

   forEachEl (theComp, allComponents ())
      {
      theDelComp = theComp->thisDelComp ();

      if ((theDelComp != NULL) and theDelComp->selForDel ())
         selComps.prepend (theComp);
      else
         remainingComps.append (theComp);
      }

   allComponents_ = remainingComps;

   while (not selComps.isEmpty ())
      deleteComp (selComps.get ());

   WitBillEntry::reLocalIndex (myProblem ());

   recountComps ();

   purging_ = false;

   witAssert (nDelCompsBefore - nTotSel == nDelComps ());

   myMsgFac () ("purgeCompleteMsg",
      nDelCompsBefore,
      nTotSel,
      nDelComps ());
   }

//------------------------------------------------------------------------------

bool WitCompMgr::isReindexing (WitBoundSet * theBoundSet) const
   {
   if (recountingComp_ != NULL)
      if (theBoundSet == recountingComp_->myBoundSet ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitCompMgr::isDeleting (WitComponent * theComp) const
   {
   return (theComp == deletingComp_);
   }

//------------------------------------------------------------------------------

void WitCompMgr::storePreSortedNodes (const WitList <WitNode> & theNodes)
   {
   WitNode *      theNode;
   WitPart *      thePart;
   WitOperation * theOpn;

   witAssert (myProblem ()->myPreprocessor ()->preprocessing ());

   allParts_     .clear ();
   allOperations_.clear ();

   forEachEl (theNode, theNodes)
      {     
      thePart = theNode->thisPart ();

      if (thePart != NULL)
         allParts_.append (thePart);

      theOpn = theNode->thisOpn ();

      if (theOpn != NULL)
         allOperations_.append (theOpn);
      }
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountComponent (WitComponent * theComp)
   {
   witAssert (theComp == recountingComp_);

   recountingComp_ = NULL;
      //
      // Prevents this function from being called more than once for the same
      // Component.
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountPart (WitPart * thePart)
   {
   recountComponent (thePart);

   ++ nParts_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountBillEntry (WitBillEntry * theBillEnt)
   {
   recountComponent (theBillEnt);
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountConsEntry (WitConsEntry * theConsEnt)
   {
   recountBillEntry (theConsEnt);
   }

//------------------------------------------------------------------------------

void WitCompMgr::insertPart (WitPart * thePart)
   {
   insertComp           (thePart);
   myPartTable_->insert (thePart);
   allParts_.    append (thePart);

   ++ nParts_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::insertComp (WitComponent * theComp)
   {
   witAssert (theComp->myCompMgr () == this);

   witAssert (not theComp->inserted ());

   allComponents_.append (theComp);

   if (theComp->myBoundSet () != NULL)
      ++ nBoundSets_;
   }

//------------------------------------------------------------------------------

void WitCompMgr::setNodeName (WitNode * theNode, const char * theName)
   {
   witAssert (theName != NULL);

   witAssert (not isNullCstring (theName));

   myProblem ()->prepSetNonUnpostAttr ();

   settingNodeName_ = true;

   theNode->storeCompMgrNodeName (theName);

   settingNodeName_ = false;
   }

//------------------------------------------------------------------------------

int WitCompMgr::nSelForDel () const
   {
   WitComponent * theComp;
   WitDelComp   * theDelComp;
   int            nSel;

   nSel = 0;

   forEachEl (theComp, allComponents ())
      {
      theDelComp = theComp->thisDelComp ();

      if (theDelComp != NULL)
         if (theDelComp->selForDel ())
            ++ nSel;
      }

   return nSel;
   }

//------------------------------------------------------------------------------

void WitCompMgr::purgeCompLists ()
   {
   myPartTable_->purge ();

   WitDelComp::purgeSelComps (allParts_);

   myOpnTable_->purge ();

   WitDelComp::purgeSelComps (allOperations_);
   }

//------------------------------------------------------------------------------

void WitCompMgr::clearCaches ()
   {
   cachedDemand_   = NULL;
   cachedBomEntry_ = NULL;
   cachedSubEntry_ = NULL;
   cachedBopEntry_ = NULL;
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountComps ()
   {
   WitComponent * theComp;

   nParts_      = 0;
   nMaterials_  = 0;
   nOperations_ = 0;
   nBomEntries_ = 0;
   nSubEntries_ = 0;
   nBopEntries_ = 0;
   nDemands_    = 0;
   nBoundSets_  = 0;

   forEachEl (theComp, allComponents ())
      {
      recountingComp_ = theComp;

      if (theComp->myBoundSet () != NULL)
         {
         theComp->reindexBoundSet ();

         ++ nBoundSets_;
         }

      theComp->recount ();

      witAssert (recountingComp_ == NULL);
      }

   if (nParts_ + nOperations_ == 0)
      myProblem ()->clearTVecs ();
   }

//------------------------------------------------------------------------------

void WitCompMgr::deleteComps ()
   {
   WitPtrVec <WitComponent> indexedComp;
   WitComponent *           theComp;
   int                      i;


   indexedComp.resize (allComponents ().nElements ());

   i = -1;

   clearingDepLists_ = true;

   forEachEl (theComp, allComponents ())
      {
      theComp->clearDepLists ();

      indexedComp[++ i] = theComp;
      }

   clearingDepLists_ = false;

   allComponents_.clear ();

   for (i = indexedComp.length () - 1; i >= 0; -- i)
      {
      deleteComp (indexedComp[i]);

      indexedComp[i] = NULL;
      }
   }

//------------------------------------------------------------------------------

void WitCompMgr::deleteComp (WitComponent * theComp)
   {
   deletingComp_ = theComp;
   delete          theComp;
   deletingComp_ = NULL;
   }

//------------------------------------------------------------------------------
// Implementation of class DelCompItr.
//------------------------------------------------------------------------------

WitDelCompItr::WitDelCompItr (WitProblem * theProblem):
      WitProbAssoc    (theProblem),

      myDelCompStack_ (theProblem),
      myStItr_        (),
      curDelComp_     (NULL)
   {
   myDelCompStack_.attachItr (myStItr_);
   }

//------------------------------------------------------------------------------

WitDelCompItr::~WitDelCompItr ()
   {
   }

//------------------------------------------------------------------------------

void WitDelCompItr::reset ()
   {
   curDelComp_ = NULL;

   myDelCompStack_.attachItr (myStItr_);

   myDelCompStack_.clear ();
   }

//------------------------------------------------------------------------------

void WitDelCompItr::advance ()
   {
   bool foundDelComp;

   if (curDelComp_ == NULL)
      setup ();

   foundDelComp = myStItr_.advance (curDelComp_);

   if (foundDelComp)
      {
      if (myMsgFac ().mayIssue ("advancedToObjMsg"))
         myMsgFac () ("advancedToObjMsg");

      curDelComp_->identify ();
      }
   else
      {
      if (myMsgFac ().mayIssue ("advancedToEndMsg"))
         myMsgFac () ("advancedToEndMsg");

      reset ();
      }
   }

//------------------------------------------------------------------------------

WitAttr WitDelCompItr::apiObjItrState ()
   {
   return
      active ()?
         curDelComp ()->apiObjItrState ():
         WitINACTIVE;
   }

//------------------------------------------------------------------------------

void WitDelCompItr::setup ()
   {
   WitComponent * theComp;
   WitDelComp *   theDelComp;

   stronglyAssert (myDelCompStack_.isEmpty ());

   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      theDelComp = theComp->thisDelComp ();

      if (theDelComp != NULL)
         myDelCompStack_.push (theDelComp);
      }

   myDelCompStack_.reverse ();

   myDelCompStack_.attachItr (myStItr_);
   }
@


1.79
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.78
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d44 2
a45 2
myProblem_        (theProblem),
myMsgFac_         (theProblem->myMsgFac ()),
d47 34
a80 34
myGlobalComp_     (NULL),
myOptComp_        (NULL),
allParts_         (),
allOperations_    (),

allComponents_    (),
myPartTable_      (NULL),
myOpnTable_       (NULL),

nParts_           (0),
nMaterials_       (0),
nOperations_      (0),
nBomEntries_      (0),
nSubEntries_      (0),
nBopEntries_      (0),
nDemands_         (0),
nBoundSets_       (0),

cachedDemand_     (NULL),
cachedBomEntry_   (NULL),
cachedSubEntry_   (NULL),
cachedBopEntry_   (NULL),

myDelCompItr_     (NULL),
purging_          (false),
recountingComp_   (NULL),
deletingComp_     (NULL),
clearingDepLists_ (false),
settingNodeName_  (false)
{
myPartTable_   = new WitDerNodeTable <WitPart>      (myProblem_);
myOpnTable_    = new WitDerNodeTable <WitOperation> (myProblem_);
myDelCompItr_  = new WitDelCompItr                  (myProblem_);
}
d85 11
a95 11
{
delete myDelCompItr_;
delete myPartTable_;
delete myOpnTable_;

myPartTable_ = NULL;
myOpnTable_  = NULL;

clearCaches ();
deleteComps ();
}
d100 2
a101 2
{
insertComp (theGlobalComp);
d103 1
a103 1
witAssert (myGlobalComp_ == NULL);
d105 2
a106 2
myGlobalComp_ = theGlobalComp;
}
d111 2
a112 2
{
insertComp (theOptComp);
d114 1
a114 1
witAssert (myOptComp_ == NULL);
d116 2
a117 2
myOptComp_ = theOptComp;
}
d122 2
a123 2
{
insertPart (theMat);
d125 2
a126 2
++ nMaterials_;
}
d131 3
a133 3
{
insertPart (theCap);
}
d138 4
a141 4
{
insertComp            (theOpn);
myOpnTable_  ->insert (theOpn);
allOperations_.append (theOpn);
d143 2
a144 2
++ nOperations_;
}
d149 2
a150 2
{
insertComp (theBomEnt);
d152 1
a152 1
cachedBomEntry_ = theBomEnt;
d154 2
a155 2
++ nBomEntries_;
}
d160 2
a161 2
{
insertComp (theSub);
d163 1
a163 1
cachedSubEntry_ = theSub;
d165 2
a166 2
++ nSubEntries_;
}
d171 2
a172 2
{
insertComp (theBopEnt);
d174 1
a174 1
cachedBopEntry_ = theBopEnt;
d176 2
a177 2
++ nBopEntries_;
}
d182 2
a183 2
{
insertComp (theDemand);
d185 1
a185 1
cachedDemand_ = theDemand;
d187 2
a188 2
++ nDemands_;
}
d193 2
a194 2
{
WitPart * matchPart;
d196 1
a196 1
matchPart = findPart (thePart->partName ().myCstring ());
d198 1
a198 1
witAssert (matchPart != NULL);
d200 2
a201 2
return matchPart;
}
d206 3
a208 3
{
WitPart *     thePart;
WitMaterial * matchMat;
d210 1
a210 1
thePart   = theMat;
d212 1
a212 1
matchMat  = myMatchFor (thePart)->thisMat ();
d214 1
a214 1
witAssert (matchMat != NULL);
d216 2
a217 2
return matchMat;
}
d222 4
a225 4
{
WitPart *    matchPart;
const char * theDemName;
WitDemand *  matchDemand;
d227 1
a227 1
matchPart   = myMatchFor (theDemand->demandedPart ());
d229 1
a229 1
theDemName  = theDemand->demandName ().myCstring ();
d231 1
a231 1
matchDemand = findDemand (matchPart, theDemName);
d233 1
a233 1
witAssert (matchDemand != NULL);
d235 2
a236 2
return matchDemand;
}
d241 2
a242 2
{
WitOperation * matchOperation;
d244 1
a244 1
matchOperation = findOperation (theOpn->operationName ().myCstring ());
d246 1
a246 1
witAssert (matchOperation != NULL);
d248 2
a249 2
return matchOperation;
}
d254 4
a257 4
{
WitOperation * matchOperation;
WitBomEntry *  matchBomEnt;
WitSubEntry *  matchSub;
d259 1
a259 1
matchOperation = myMatchFor (theSub->myOperation ());
d261 1
a261 1
matchBomEnt    = findBomEntry (matchOperation, theSub->myBomEntIndex ());
d263 1
a263 1
witAssert (matchBomEnt != NULL);
d265 1
a265 1
matchSub       = findSubEntry (matchBomEnt,    theSub->localIndex ());
d267 1
a267 1
witAssert (matchSub    != NULL);
d269 2
a270 2
return matchSub;
}
d275 3
a277 3
{
return theBoundSet->myMatchIn (this);
}
d282 3
a284 3
{
return myPartTable_->findDerNode (theName);
}
d289 3
a291 3
{
return myOpnTable_->findDerNode (theName);
}
d296 2
a297 2
{
WitBomEntry * theBomEnt;
d299 1
a299 1
witAssert (theOpn->myCompMgr () == this);
d301 9
a309 9
if (cachedBomEntry_ != NULL)
if (   cachedBomEntry_->myOperation () == theOpn)
if (cachedBomEntry_->localIndex  () == theIndex)
return cachedBomEntry_;

forEachEl (theBomEnt, theOpn->bom ())
if (theBomEnt->localIndex () == theIndex)
{
cachedBomEntry_ = theBomEnt;
d311 2
a312 2
return cachedBomEntry_;
}
d314 2
a315 2
return NULL;
}
d320 2
a321 2
{
WitSubEntry * theSub;
d323 1
a323 1
witAssert (theBomEnt->myCompMgr () == this);
d325 9
a333 9
if (cachedSubEntry_ != NULL)
if (   cachedSubEntry_->myBomEnt () == theBomEnt)
if (cachedSubEntry_->localIndex () == theIndex)
return cachedSubEntry_;

forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->localIndex () == theIndex)
{
cachedSubEntry_ = theSub;
d335 2
a336 2
return cachedSubEntry_;
}
d338 2
a339 2
return NULL;
}
d344 2
a345 2
{
WitBopEntry * theBopEnt;
d347 1
a347 1
witAssert (theOpn->myCompMgr () == this);
d349 9
a357 9
if (cachedBopEntry_ != NULL)
if (   cachedBopEntry_->myOperation () == theOpn)
if (cachedBopEntry_->localIndex  () == theIndex)
return cachedBopEntry_;

forEachEl (theBopEnt, theOpn->bop ())
if (theBopEnt->localIndex () == theIndex)
{
cachedBopEntry_ = theBopEnt;
d359 2
a360 2
return cachedBopEntry_;
}
d362 2
a363 2
return NULL;
}
d368 2
a369 2
{
WitDemand * theDemand;
d371 1
a371 1
witAssert (thePart->myCompMgr () == this);
d373 4
a376 4
if (cachedDemand_ != NULL)
if (cachedDemand_->demandedPart () == thePart)
if (cachedDemand_->demandName () == theName)
return cachedDemand_;
d378 2
a379 2
cachedDemand_ =
thePart->myDemands ().find (& WitDemand::demandName, theName);
d381 2
a382 2
return cachedDemand_;
}
d387 3
a389 3
{
recountComponent (theGlobalComp);
}
d394 3
a396 3
{
recountComponent (theOptComp);
}
d401 2
a402 2
{
recountPart (theMat);
d404 2
a405 2
++ nMaterials_;
}
d410 3
a412 3
{
recountPart (theCap);
}
d417 2
a418 2
{
recountComponent (theOpn);
d420 2
a421 2
++ nOperations_;
}
d426 2
a427 2
{
recountConsEntry (theBomEnt);
d429 2
a430 2
++ nBomEntries_;
}
d435 2
a436 2
{
recountConsEntry (theSub);
d438 2
a439 2
++ nSubEntries_;
}
d444 2
a445 2
{
recountComponent (theBopEnt);
d447 2
a448 2
++ nBopEntries_;
}
d453 2
a454 2
{
recountComponent (theDemand);
d456 2
a457 2
++ nDemands_;
}
d462 2
a463 2
{
myPartTable_->remove (thePart);
d465 1
a465 1
setNodeName (thePart, theName);
d467 2
a468 2
myPartTable_->insert (thePart);
}
d473 2
a474 2
{
myOpnTable_->remove (theOpn);
d476 1
a476 1
setNodeName (theOpn, theName);
d478 2
a479 2
myOpnTable_->insert (theOpn);
}
d484 15
a498 15
{
int            nSpec;
WitComponent * theComp;
WitBoundSet *  theBoundSet;

nSpec = 0;

forEachEl (theComp, allComponents ())
{
theBoundSet = theComp->myBoundSet ();

if (theBoundSet != NULL)
if (not theBoundSet->isAtDefault ())
++ nSpec;
}
d500 2
a501 2
return nSpec;
}
d506 6
a511 6
{
WitComponent * theComp;
WitDelComp   * theDelComp;
int            nUserSel;
int            nTotSel;
int            nDelCompsBefore;
d513 3
a515 3
WitList <WitComponent> remainingComps;
//
// The List of all Components not deleted by this purge.
d517 3
a519 3
WitList <WitComponent> selComps;
//
// The List of all Components to be deleted, in reverse creation order.
d521 2
a522 2
if (myDelCompItr_->active ())
myMsgFac () ("purgeWhileItrActSmsg");
d524 2
a525 2
if (myGlobalComp ()->perfPegging ())
myProblem ()->myHeurAllMgr ()->clearPegging ();
d527 1
a527 1
myProblem ()->myPipMgr ()->clearShipSeq ();
d529 1
a529 1
myGlobalComp ()->clearPgdCritList ();
d531 2
a532 2
myMsgFac () ("purgeDataMsg");
myMsgFac ().divide ();
d534 1
a534 1
nUserSel = nSelForDel ();
d536 4
a539 4
if (nUserSel == 0)
{
myMsgFac () ("noSelForDelsMsg");
myMsgFac ().divide ();
d541 2
a542 2
return;
}
d544 1
a544 1
myProblem ()->myPreprocessor ()->unpreprocess ();
d546 1
a546 1
nDelCompsBefore = nDelComps ();
d548 1
a548 1
purging_        = true;
d550 3
a552 3
forEachEl (theComp, allComponents ())
{
theDelComp = theComp->thisDelComp ();
d554 3
a556 3
if (theDelComp != NULL)
theDelComp->identifyOrAutoSel ();
}
d558 1
a558 1
nTotSel = nSelForDel ();
d560 1
a560 1
myMsgFac () ("delCompsMsg", nUserSel, nTotSel - nUserSel, nTotSel);
d562 2
a563 2
forEachEl (theComp, allComponents ())
theComp->purgeCompLists ();
d565 1
a565 1
purgeCompLists ();
d567 1
a567 1
clearCaches ();
d569 3
a571 3
forEachEl (theComp, allComponents ())
{
theDelComp = theComp->thisDelComp ();
d573 5
a577 5
if ((theDelComp != NULL) and theDelComp->selForDel ())
selComps.prepend (theComp);
else
remainingComps.append (theComp);
}
d579 1
a579 1
allComponents_ = remainingComps;
d581 2
a582 2
while (not selComps.isEmpty ())
deleteComp (selComps.get ());
d584 1
a584 1
WitBillEntry::reLocalIndex (myProblem ());
d586 1
a586 1
recountComps ();
d588 1
a588 1
purging_ = false;
d590 1
a590 1
witAssert (nDelCompsBefore - nTotSel == nDelComps ());
d592 5
a596 5
myMsgFac () ("purgeCompleteMsg",
nDelCompsBefore,
nTotSel,
nDelComps ());
}
d601 4
a604 4
{
if (recountingComp_ != NULL)
if (theBoundSet == recountingComp_->myBoundSet ())
return true;
d606 2
a607 2
return false;
}
d612 3
a614 3
{
return (theComp == deletingComp_);
}
d619 4
a622 4
{
WitNode *      theNode;
WitPart *      thePart;
WitOperation * theOpn;
d624 1
a624 1
witAssert (myProblem ()->myPreprocessor ()->preprocessing ());
d626 2
a627 2
allParts_     .clear ();
allOperations_.clear ();
d629 3
a631 3
forEachEl (theNode, theNodes)
{
thePart = theNode->thisPart ();
d633 2
a634 2
if (thePart != NULL)
allParts_.append (thePart);
d636 1
a636 1
theOpn = theNode->thisOpn ();
d638 4
a641 4
if (theOpn != NULL)
allOperations_.append (theOpn);
}
}
d646 2
a647 2
{
witAssert (theComp == recountingComp_);
d649 5
a653 5
recountingComp_ = NULL;
//
// Prevents this function from being called more than once for the same
// Component.
}
d658 2
a659 2
{
recountComponent (thePart);
d661 2
a662 2
++ nParts_;
}
d667 3
a669 3
{
recountComponent (theBillEnt);
}
d674 3
a676 3
{
recountBillEntry (theConsEnt);
}
d681 4
a684 4
{
insertComp           (thePart);
myPartTable_->insert (thePart);
allParts_.    append (thePart);
d686 2
a687 2
++ nParts_;
}
d692 2
a693 2
{
witAssert (theComp->myCompMgr () == this);
d695 1
a695 1
witAssert (not theComp->inserted ());
d697 1
a697 1
allComponents_.append (theComp);
d699 3
a701 3
if (theComp->myBoundSet () != NULL)
++ nBoundSets_;
}
d706 2
a707 2
{
witAssert (theName != NULL);
d709 1
a709 1
witAssert (not isNullCstring (theName));
d711 1
a711 1
myProblem ()->prepSetNonUnpostAttr ();
d713 1
a713 1
settingNodeName_ = true;
d715 1
a715 1
theNode->storeCompMgrNodeName (theName);
d717 2
a718 2
settingNodeName_ = false;
}
d723 15
a737 15
{
WitComponent * theComp;
WitDelComp   * theDelComp;
int            nSel;

nSel = 0;

forEachEl (theComp, allComponents ())
{
theDelComp = theComp->thisDelComp ();

if (theDelComp != NULL)
if (theDelComp->selForDel ())
++ nSel;
}
d739 2
a740 2
return nSel;
}
d745 2
a746 2
{
myPartTable_->purge ();
d748 1
a748 1
WitDelComp::purgeSelComps (allParts_);
d750 1
a750 1
myOpnTable_->purge ();
d752 2
a753 2
WitDelComp::purgeSelComps (allOperations_);
}
d758 6
a763 6
{
cachedDemand_   = NULL;
cachedBomEntry_ = NULL;
cachedSubEntry_ = NULL;
cachedBopEntry_ = NULL;
}
d768 2
a769 2
{
WitComponent * theComp;
d771 28
a798 28
nParts_      = 0;
nMaterials_  = 0;
nOperations_ = 0;
nBomEntries_ = 0;
nSubEntries_ = 0;
nBopEntries_ = 0;
nDemands_    = 0;
nBoundSets_  = 0;

forEachEl (theComp, allComponents ())
{
recountingComp_ = theComp;

if (theComp->myBoundSet () != NULL)
{
theComp->reindexBoundSet ();

++ nBoundSets_;
}

theComp->recount ();

witAssert (recountingComp_ == NULL);
}

if (nParts_ + nOperations_ == 0)
myProblem ()->clearTVecs ();
}
d803 4
a806 4
{
WitPtrVec <WitComponent> indexedComp;
WitComponent *           theComp;
int                      i;
d809 1
a809 1
indexedComp.resize (allComponents ().nElements ());
d811 1
a811 1
i = -1;
d813 1
a813 1
clearingDepLists_ = true;
d815 3
a817 3
forEachEl (theComp, allComponents ())
{
theComp->clearDepLists ();
d819 2
a820 2
indexedComp[++ i] = theComp;
}
d822 1
a822 1
clearingDepLists_ = false;
d824 1
a824 1
allComponents_.clear ();
d826 3
a828 3
for (i = indexedComp.length () - 1; i >= 0; -- i)
{
deleteComp (indexedComp[i]);
d830 3
a832 3
indexedComp[i] = NULL;
}
}
d837 5
a841 5
{
deletingComp_ = theComp;
delete          theComp;
deletingComp_ = NULL;
}
d848 1
a848 1
WitProbAssoc    (theProblem),
d850 6
a855 6
myDelCompStack_ (theProblem),
myStItr_        (),
curDelComp_     (NULL)
{
myDelCompStack_.attachItr (myStItr_);
}
d860 2
a861 2
{
}
d866 2
a867 2
{
curDelComp_ = NULL;
d869 1
a869 1
myDelCompStack_.attachItr (myStItr_);
d871 2
a872 2
myDelCompStack_.clear ();
}
d877 2
a878 2
{
bool foundDelComp;
d880 2
a881 2
if (curDelComp_ == NULL)
setup ();
d883 1
a883 1
foundDelComp = myStItr_.advance (curDelComp_);
d885 15
a899 15
if (foundDelComp)
{
if (myMsgFac ().mayIssue ("advancedToObjMsg"))
myMsgFac () ("advancedToObjMsg");

curDelComp_->identify ();
}
else
{
if (myMsgFac ().mayIssue ("advancedToEndMsg"))
myMsgFac () ("advancedToEndMsg");

reset ();
}
}
d904 6
a909 6
{
return
active ()?
curDelComp ()->apiObjItrState ():
WitINACTIVE;
}
d914 3
a916 3
{
WitComponent * theComp;
WitDelComp *   theDelComp;
d918 1
a918 1
stronglyAssert (myDelCompStack_.isEmpty ());
d920 3
a922 3
forEachEl (theComp, myCompMgr ()->allComponents ())
{
theDelComp = theComp->thisDelComp ();
d924 3
a926 3
if (theDelComp != NULL)
myDelCompStack_.push (theDelComp);
}
d928 1
a928 1
myDelCompStack_.reverse ();
d930 2
a931 2
myDelCompStack_.attachItr (myStItr_);
}
@


1.77
log
@CPLEX
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d44 2
a45 2
      myProblem_        (theProblem),
      myMsgFac_         (theProblem->myMsgFac ()),
d47 34
a80 34
      myGlobalComp_     (NULL),
      myOptComp_        (NULL),
      allParts_         (),
      allOperations_    (),

      allComponents_    (),
      myPartTable_      (NULL),
      myOpnTable_       (NULL),

      nParts_           (0),
      nMaterials_       (0),
      nOperations_      (0),
      nBomEntries_      (0),
      nSubEntries_      (0),
      nBopEntries_      (0),
      nDemands_         (0),
      nBoundSets_       (0),

      cachedDemand_     (NULL),
      cachedBomEntry_   (NULL),
      cachedSubEntry_   (NULL),
      cachedBopEntry_   (NULL),

      myDelCompItr_     (NULL),
      purging_          (false),
      recountingComp_   (NULL),
      deletingComp_     (NULL),
      clearingDepLists_ (false),
      settingNodeName_  (false)
   {
   myPartTable_   = new WitDerNodeTable <WitPart>      (myProblem_);
   myOpnTable_    = new WitDerNodeTable <WitOperation> (myProblem_);
   myDelCompItr_  = new WitDelCompItr                  (myProblem_);
   }
d85 11
a95 11
   {
   delete myDelCompItr_;
   delete myPartTable_;
   delete myOpnTable_;

   myPartTable_ = NULL;
   myOpnTable_  = NULL;

   clearCaches ();
   deleteComps ();
   }
d100 2
a101 2
   {
   insertComp (theGlobalComp);
d103 1
a103 1
   witAssert (myGlobalComp_ == NULL);
d105 2
a106 2
   myGlobalComp_ = theGlobalComp;
   }
d111 2
a112 2
   {
   insertComp (theOptComp);
d114 1
a114 1
   witAssert (myOptComp_ == NULL);
d116 2
a117 2
   myOptComp_ = theOptComp;
   }
d122 2
a123 2
   {
   insertPart (theMat);
d125 2
a126 2
   ++ nMaterials_;
   }
d131 3
a133 3
   {
   insertPart (theCap);
   }
d138 4
a141 4
   {
   insertComp            (theOpn);
   myOpnTable_  ->insert (theOpn);
   allOperations_.append (theOpn);
d143 2
a144 2
   ++ nOperations_;
   }
d149 2
a150 2
   {
   insertComp (theBomEnt);
d152 1
a152 1
   cachedBomEntry_ = theBomEnt;
d154 2
a155 2
   ++ nBomEntries_;
   }
d160 2
a161 2
   {
   insertComp (theSub);
d163 1
a163 1
   cachedSubEntry_ = theSub;
d165 2
a166 2
   ++ nSubEntries_;
   }
d171 2
a172 2
   {
   insertComp (theBopEnt);
d174 1
a174 1
   cachedBopEntry_ = theBopEnt;
d176 2
a177 2
   ++ nBopEntries_;
   }
d182 2
a183 2
   {
   insertComp (theDemand);
d185 1
a185 1
   cachedDemand_ = theDemand;
d187 2
a188 2
   ++ nDemands_;
   }
d193 2
a194 2
   {
   WitPart * matchPart;
d196 1
a196 1
   matchPart = findPart (thePart->partName ().myCstring ());
d198 1
a198 1
   witAssert (matchPart != NULL);
d200 2
a201 2
   return matchPart;
   }
d206 3
a208 3
   {
   WitPart *     thePart;
   WitMaterial * matchMat;
d210 1
a210 1
   thePart   = theMat;
d212 1
a212 1
   matchMat  = myMatchFor (thePart)->thisMat ();
d214 1
a214 1
   witAssert (matchMat != NULL);
d216 2
a217 2
   return matchMat;
   }
d222 4
a225 4
   {
   WitPart *    matchPart;
   const char * theDemName;
   WitDemand *  matchDemand;
d227 1
a227 1
   matchPart   = myMatchFor (theDemand->demandedPart ());
d229 1
a229 1
   theDemName  = theDemand->demandName ().myCstring ();
d231 1
a231 1
   matchDemand = findDemand (matchPart, theDemName);
d233 1
a233 1
   witAssert (matchDemand != NULL);
d235 2
a236 2
   return matchDemand;
   }
d241 2
a242 2
   {
   WitOperation * matchOperation;
d244 1
a244 1
   matchOperation = findOperation (theOpn->operationName ().myCstring ());
d246 1
a246 1
   witAssert (matchOperation != NULL);
d248 2
a249 2
   return matchOperation;
   }
d254 4
a257 4
   {
   WitOperation * matchOperation;
   WitBomEntry *  matchBomEnt;
   WitSubEntry *  matchSub;
d259 1
a259 1
   matchOperation = myMatchFor (theSub->myOperation ());
d261 1
a261 1
   matchBomEnt    = findBomEntry (matchOperation, theSub->myBomEntIndex ());
d263 1
a263 1
   witAssert (matchBomEnt != NULL);
d265 1
a265 1
   matchSub       = findSubEntry (matchBomEnt,    theSub->localIndex ());
d267 1
a267 1
   witAssert (matchSub    != NULL);
d269 2
a270 2
   return matchSub;
   }
d275 3
a277 3
   {
   return theBoundSet->myMatchIn (this);
   }
d282 3
a284 3
   {
   return myPartTable_->findDerNode (theName);
   }
d289 3
a291 3
   {
   return myOpnTable_->findDerNode (theName);
   }
d296 2
a297 2
   {
   WitBomEntry * theBomEnt;
d299 1
a299 1
   witAssert (theOpn->myCompMgr () == this);
d301 9
a309 9
   if (cachedBomEntry_ != NULL)
      if (   cachedBomEntry_->myOperation () == theOpn)
         if (cachedBomEntry_->localIndex  () == theIndex)
            return cachedBomEntry_;

   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->localIndex () == theIndex)
         {
         cachedBomEntry_ = theBomEnt;
d311 2
a312 2
         return cachedBomEntry_;
         }
d314 2
a315 2
   return NULL;
   }
d320 2
a321 2
   {
   WitSubEntry * theSub;
d323 1
a323 1
   witAssert (theBomEnt->myCompMgr () == this);
d325 9
a333 9
   if (cachedSubEntry_ != NULL)
      if (   cachedSubEntry_->myBomEnt () == theBomEnt)
         if (cachedSubEntry_->localIndex () == theIndex)
            return cachedSubEntry_;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->localIndex () == theIndex)
         {
         cachedSubEntry_ = theSub;
d335 2
a336 2
         return cachedSubEntry_;
         }
d338 2
a339 2
   return NULL;
   }
d344 2
a345 2
   {
   WitBopEntry * theBopEnt;
d347 1
a347 1
   witAssert (theOpn->myCompMgr () == this);
d349 9
a357 9
   if (cachedBopEntry_ != NULL)
      if (   cachedBopEntry_->myOperation () == theOpn)
         if (cachedBopEntry_->localIndex  () == theIndex)
            return cachedBopEntry_;

   forEachEl (theBopEnt, theOpn->bop ())
      if (theBopEnt->localIndex () == theIndex)
         {
         cachedBopEntry_ = theBopEnt;
d359 2
a360 2
         return cachedBopEntry_;
         }
d362 2
a363 2
   return NULL;
   }
d368 2
a369 2
   {
   WitDemand * theDemand;
d371 1
a371 1
   witAssert (thePart->myCompMgr () == this);
d373 4
a376 4
   if (cachedDemand_ != NULL)
      if (cachedDemand_->demandedPart () == thePart)
         if (cachedDemand_->demandName () == theName)
            return cachedDemand_;
d378 2
a379 2
   cachedDemand_ =
      thePart->myDemands ().find (& WitDemand::demandName, theName);
d381 2
a382 2
   return cachedDemand_;
   }
d387 3
a389 3
   {
   recountComponent (theGlobalComp);
   }
d394 3
a396 3
   {
   recountComponent (theOptComp);
   }
d401 2
a402 2
   {
   recountPart (theMat);
d404 2
a405 2
   ++ nMaterials_;
   }
d410 3
a412 3
   {
   recountPart (theCap);
   }
d417 2
a418 2
   {
   recountComponent (theOpn);
d420 2
a421 2
   ++ nOperations_;
   }
d426 2
a427 2
   {
   recountConsEntry (theBomEnt);
d429 2
a430 2
   ++ nBomEntries_;
   }
d435 2
a436 2
   {
   recountConsEntry (theSub);
d438 2
a439 2
   ++ nSubEntries_;
   }
d444 2
a445 2
   {
   recountComponent (theBopEnt);
d447 2
a448 2
   ++ nBopEntries_;
   }
d453 2
a454 2
   {
   recountComponent (theDemand);
d456 2
a457 2
   ++ nDemands_;
   }
d462 2
a463 2
   {
   myPartTable_->remove (thePart);
d465 1
a465 1
   setNodeName (thePart, theName);
d467 2
a468 2
   myPartTable_->insert (thePart);
   }
d473 2
a474 2
   {
   myOpnTable_->remove (theOpn);
d476 1
a476 1
   setNodeName (theOpn, theName);
d478 2
a479 2
   myOpnTable_->insert (theOpn);
   }
d484 15
a498 15
   {
   int            nSpec;
   WitComponent * theComp;
   WitBoundSet *  theBoundSet;

   nSpec = 0;

   forEachEl (theComp, allComponents ())
      {
      theBoundSet = theComp->myBoundSet ();

      if (theBoundSet != NULL)
         if (not theBoundSet->isAtDefault ())
            ++ nSpec;
      }
d500 2
a501 2
   return nSpec;
   }
d506 6
a511 6
   {
   WitComponent * theComp;
   WitDelComp   * theDelComp;
   int            nUserSel;
   int            nTotSel;
   int            nDelCompsBefore;
d513 3
a515 3
   WitList <WitComponent> remainingComps;
      //
      // The List of all Components not deleted by this purge.
d517 3
a519 3
   WitList <WitComponent> selComps;
      //
      // The List of all Components to be deleted, in reverse creation order.
d521 2
a522 2
   if (myDelCompItr_->active ())
      myMsgFac () ("purgeWhileItrActSmsg");
d524 2
a525 2
   if (myGlobalComp ()->perfPegging ())
      myProblem ()->myHeurAllMgr ()->clearPegging ();
d527 1
a527 1
   myProblem ()->myPipMgr ()->clearShipSeq ();
d529 1
a529 1
   myGlobalComp ()->clearPgdCritList ();
d531 2
a532 2
   myMsgFac () ("purgeDataMsg");
   myMsgFac ().divide ();
d534 1
a534 1
   nUserSel = nSelForDel ();
d536 4
a539 4
   if (nUserSel == 0)
      {
      myMsgFac () ("noSelForDelsMsg");
      myMsgFac ().divide ();
d541 2
a542 2
      return;
      }
d544 1
a544 1
   myProblem ()->myPreprocessor ()->unpreprocess ();
d546 1
a546 1
   nDelCompsBefore = nDelComps ();
d548 1
a548 1
   purging_        = true;
d550 3
a552 3
   forEachEl (theComp, allComponents ())
      {
      theDelComp = theComp->thisDelComp ();
d554 3
a556 3
      if (theDelComp != NULL)
         theDelComp->identifyOrAutoSel ();
      }
d558 1
a558 1
   nTotSel = nSelForDel ();
d560 1
a560 1
   myMsgFac () ("delCompsMsg", nUserSel, nTotSel - nUserSel, nTotSel);
d562 2
a563 2
   forEachEl (theComp, allComponents ())
      theComp->purgeCompLists ();
d565 1
a565 1
   purgeCompLists ();
d567 1
a567 1
   clearCaches ();
d569 3
a571 3
   forEachEl (theComp, allComponents ())
      {
      theDelComp = theComp->thisDelComp ();
d573 5
a577 5
      if ((theDelComp != NULL) and theDelComp->selForDel ())
         selComps.prepend (theComp);
      else
         remainingComps.append (theComp);
      }
d579 1
a579 1
   allComponents_ = remainingComps;
d581 2
a582 2
   while (not selComps.isEmpty ())
      deleteComp (selComps.get ());
d584 1
a584 1
   WitBillEntry::reLocalIndex (myProblem ());
d586 1
a586 1
   recountComps ();
d588 1
a588 1
   purging_ = false;
d590 1
a590 1
   witAssert (nDelCompsBefore - nTotSel == nDelComps ());
d592 5
a596 5
   myMsgFac () ("purgeCompleteMsg",
      nDelCompsBefore,
      nTotSel,
      nDelComps ());
   }
d601 4
a604 4
   {
   if (recountingComp_ != NULL)
      if (theBoundSet == recountingComp_->myBoundSet ())
         return true;
d606 2
a607 2
   return false;
   }
d612 3
a614 3
   {
   return (theComp == deletingComp_);
   }
d619 4
a622 4
   {
   WitNode *      theNode;
   WitPart *      thePart;
   WitOperation * theOpn;
d624 1
a624 1
   witAssert (myProblem ()->myPreprocessor ()->preprocessing ());
d626 2
a627 2
   allParts_     .clear ();
   allOperations_.clear ();
d629 3
a631 3
   forEachEl (theNode, theNodes)
      {     
      thePart = theNode->thisPart ();
d633 2
a634 2
      if (thePart != NULL)
         allParts_.append (thePart);
d636 1
a636 1
      theOpn = theNode->thisOpn ();
d638 4
a641 4
      if (theOpn != NULL)
         allOperations_.append (theOpn);
      }
   }
d646 2
a647 2
   {
   witAssert (theComp == recountingComp_);
d649 5
a653 5
   recountingComp_ = NULL;
      //
      // Prevents this function from being called more than once for the same
      // Component.
   }
d658 2
a659 2
   {
   recountComponent (thePart);
d661 2
a662 2
   ++ nParts_;
   }
d667 3
a669 3
   {
   recountComponent (theBillEnt);
   }
d674 3
a676 3
   {
   recountBillEntry (theConsEnt);
   }
d681 4
a684 4
   {
   insertComp           (thePart);
   myPartTable_->insert (thePart);
   allParts_.    append (thePart);
d686 2
a687 2
   ++ nParts_;
   }
d692 2
a693 2
   {
   witAssert (theComp->myCompMgr () == this);
d695 1
a695 1
   witAssert (not theComp->inserted ());
d697 1
a697 1
   allComponents_.append (theComp);
d699 3
a701 3
   if (theComp->myBoundSet () != NULL)
      ++ nBoundSets_;
   }
d706 2
a707 2
   {
   witAssert (theName != NULL);
d709 1
a709 1
   witAssert (not isNullCstring (theName));
d711 1
a711 1
   myProblem ()->prepSetNonUnpostAttr ();
d713 1
a713 1
   settingNodeName_ = true;
d715 1
a715 1
   theNode->storeCompMgrNodeName (theName);
d717 2
a718 2
   settingNodeName_ = false;
   }
d723 15
a737 15
   {
   WitComponent * theComp;
   WitDelComp   * theDelComp;
   int            nSel;

   nSel = 0;

   forEachEl (theComp, allComponents ())
      {
      theDelComp = theComp->thisDelComp ();

      if (theDelComp != NULL)
         if (theDelComp->selForDel ())
            ++ nSel;
      }
d739 2
a740 2
   return nSel;
   }
d745 2
a746 2
   {
   myPartTable_->purge ();
d748 1
a748 1
   WitDelComp::purgeSelComps (allParts_);
d750 1
a750 1
   myOpnTable_->purge ();
d752 2
a753 2
   WitDelComp::purgeSelComps (allOperations_);
   }
d758 6
a763 6
   {
   cachedDemand_   = NULL;
   cachedBomEntry_ = NULL;
   cachedSubEntry_ = NULL;
   cachedBopEntry_ = NULL;
   }
d768 2
a769 2
   {
   WitComponent * theComp;
d771 28
a798 28
   nParts_      = 0;
   nMaterials_  = 0;
   nOperations_ = 0;
   nBomEntries_ = 0;
   nSubEntries_ = 0;
   nBopEntries_ = 0;
   nDemands_    = 0;
   nBoundSets_  = 0;

   forEachEl (theComp, allComponents ())
      {
      recountingComp_ = theComp;

      if (theComp->myBoundSet () != NULL)
         {
         theComp->reindexBoundSet ();

         ++ nBoundSets_;
         }

      theComp->recount ();

      witAssert (recountingComp_ == NULL);
      }

   if (nParts_ + nOperations_ == 0)
      myProblem ()->clearTVecs ();
   }
d803 4
a806 4
   {
   WitPtrVec <WitComponent> indexedComp;
   WitComponent *           theComp;
   int                      i;
d809 1
a809 1
   indexedComp.resize (allComponents ().nElements ());
d811 1
a811 1
   i = -1;
d813 1
a813 1
   clearingDepLists_ = true;
d815 3
a817 3
   forEachEl (theComp, allComponents ())
      {
      theComp->clearDepLists ();
d819 2
a820 2
      indexedComp[++ i] = theComp;
      }
d822 1
a822 1
   clearingDepLists_ = false;
d824 1
a824 1
   allComponents_.clear ();
d826 3
a828 3
   for (i = indexedComp.length () - 1; i >= 0; -- i)
      {
      deleteComp (indexedComp[i]);
d830 3
a832 3
      indexedComp[i] = NULL;
      }
   }
d837 5
a841 5
   {
   deletingComp_ = theComp;
   delete          theComp;
   deletingComp_ = NULL;
   }
d848 1
a848 1
      WitProbAssoc    (theProblem),
d850 6
a855 6
      myDelCompStack_ (theProblem),
      myStItr_        (),
      curDelComp_     (NULL)
   {
   myDelCompStack_.attachItr (myStItr_);
   }
d860 2
a861 2
   {
   }
d866 2
a867 2
   {
   curDelComp_ = NULL;
d869 1
a869 1
   myDelCompStack_.attachItr (myStItr_);
d871 2
a872 2
   myDelCompStack_.clear ();
   }
d877 2
a878 2
   {
   bool foundDelComp;
d880 2
a881 2
   if (curDelComp_ == NULL)
      setup ();
d883 1
a883 1
   foundDelComp = myStItr_.advance (curDelComp_);
d885 15
a899 15
   if (foundDelComp)
      {
      if (myMsgFac ().mayIssue ("advancedToObjMsg"))
         myMsgFac () ("advancedToObjMsg");

      curDelComp_->identify ();
      }
   else
      {
      if (myMsgFac ().mayIssue ("advancedToEndMsg"))
         myMsgFac () ("advancedToEndMsg");

      reset ();
      }
   }
d904 6
a909 6
   {
   return
      active ()?
         curDelComp ()->apiObjItrState ():
         WitINACTIVE;
   }
d914 3
a916 3
   {
   WitComponent * theComp;
   WitDelComp *   theDelComp;
d918 1
a918 1
   stronglyAssert (myDelCompStack_.isEmpty ());
d920 3
a922 3
   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      theDelComp = theComp->thisDelComp ();
d924 3
a926 3
      if (theDelComp != NULL)
         myDelCompStack_.push (theDelComp);
      }
d928 1
a928 1
   myDelCompStack_.reverse ();
d930 2
a931 2
   myDelCompStack_.attachItr (myStItr_);
   }
@


1.76
log
@Heuristic Adjustment
@
text
@d103 2
d114 2
@


1.75
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d26 1
a26 1
#include <Opn.h>
@


1.74
log
@Object name change.
@
text
@d22 1
a22 1
#include <Global.h>
@


1.73
log
@Object name change.
@
text
@d707 2
@


1.72
log
@Object name change.
@
text
@d705 1
a705 1
   witAssert (not isNullString (theName));
@


1.71
log
@Object Name Changing.
@
text
@d75 1
a75 1
      nameChangeNode_   (NULL)
d703 1
a703 1
   nameChangeNode_ = theNode;
d705 1
a705 1
   theNode->setNodeName (theName);
d707 5
a711 1
   nameChangeNode_ = NULL;
@


1.70
log
@Object name changing.
@
text
@d147 2
a148 1
   cache      (theBomEnt);
d158 2
a159 1
   cache      (theSub);
d169 2
a170 1
   cache      (theBopEnt);
d180 2
a181 1
   cache      (theDemand);
a292 1
   WitBomEntry * theCachedBomEntry;
d297 4
a300 6
   theCachedBomEntry = cachedBomEntry ();

   if (theCachedBomEntry != NULL)
      if (   theCachedBomEntry->myOperation () == theOpn)
         if (theCachedBomEntry->localIndex  () == theIndex)
            return theCachedBomEntry;
d304 5
a308 1
         return cache (theBomEnt);
a316 1
   WitSubEntry * theCachedSubEntry;
d321 4
a324 6
   theCachedSubEntry = cachedSubEntry ();

   if (theCachedSubEntry != NULL)
      if (   theCachedSubEntry->myBomEnt () == theBomEnt)
         if (theCachedSubEntry->localIndex () == theIndex)
            return theCachedSubEntry;
d328 5
a332 1
         return cache (theSub);
a340 1
   WitBopEntry * theCachedBopEntry;
d345 4
a348 6
   theCachedBopEntry = cachedBopEntry ();

   if (theCachedBopEntry != NULL)
      if (   theCachedBopEntry->myOperation () == theOpn)
         if (theCachedBopEntry->localIndex  () == theIndex)
            return theCachedBopEntry;
d352 5
a356 1
         return cache (theBopEnt);
d365 1
a365 1
   WitDemand * theCachedDemand;
d369 4
a372 1
   theCachedDemand = cachedDemand_;
d374 2
a375 4
   if (theCachedDemand != NULL)
      if (theCachedDemand->demandedPart () == thePart)
         if (theCachedDemand->demandName () == theName)
            return theCachedDemand;
d377 1
a377 1
   return cache (thePart->myDemands ().find (& WitDemand::demandName, theName));
a640 22
WitDemand * WitCompMgr::cache (WitDemand * theDemand)
   {
   return cachedDemand_ = theDemand;
   }

WitBomEntry * WitCompMgr::cache (WitBomEntry * theBomEnt)
   {
   return cachedBomEntry_ = theBomEnt;
   }

WitSubEntry * WitCompMgr::cache (WitSubEntry * theSub)
   {
   return cachedSubEntry_ = theSub;
   }

WitBopEntry * WitCompMgr::cache (WitBopEntry * theBopEnt)
   {
   return cachedBopEntry_ = theBopEnt;
   }

//------------------------------------------------------------------------------

@


1.69
log
@Object name changing.
@
text
@d453 1
a453 1
   nameChangeNode_ = thePart;
d455 2
a456 1
   thePart->setNodeName (theName);
d458 9
a466 3
   nameChangeNode_ = NULL;
   
   myPartTable_->insert (thePart);
d715 11
@


1.68
log
@Object name change.
@
text
@d74 2
a75 1
      clearingDepLists_ (false)
d449 15
@


1.67
log
@Stochastic Implosion
@
text
@d54 1
a54 1
      myOperationTable_ (NULL),
d76 3
a78 3
   myPartTable_      = new WitNodeTable  (myProblem_);
   myOperationTable_ = new WitNodeTable  (myProblem_);
   myDelCompItr_     = new WitDelCompItr (myProblem_);
d87 1
a87 1
   delete myOperationTable_;
d89 2
a90 2
   myPartTable_      = NULL;
   myOperationTable_ = NULL;
d134 3
a136 3
   insertComp                (theOpn);
   myOperationTable_->insert (theOpn);
   allOperations_.    append (theOpn);
d274 1
a274 1
   return static_cast <WitPart *> (myPartTable_->namedNode (theName));
d281 1
a281 1
   return static_cast <WitOperation *> (myOperationTable_->namedNode (theName));
d720 1
a720 1
   myOperationTable_->purge ();
@


1.66
log
@Stochastic Implosion
@
text
@d196 16
d244 21
@


1.65
log
@Stochastic Implosion
@
text
@d413 3
a415 3
   int                 nSpec;
   WitComponent *      theComp;
   const WitBoundSet * theBoundSet;
d528 1
a528 1
bool WitCompMgr::isReindexing (const WitBoundSet * theBoundSet) const
@


1.64
log
@Stochastic Implosion
@
text
@d183 1
a183 1
WitPart * WitCompMgr::match (WitPart * thePart)
d196 20
a215 1
WitOperation * WitCompMgr::match (WitOperation * theOpn)
d228 7
@


1.63
log
@Stochastic Implosion
@
text
@d520 1
a520 1
void WitCompMgr::passPreRefs ()
d522 21
a542 3
   myProblem ()->
      myPreprocessor ()->
         receiveRefs (this, allParts_, allOperations_);
@


1.62
log
@Stochastic Implosion
@
text
@a32 1
#include <PreData.h>
a528 17
void WitCompMgr::importPreData ()
   {
   allParts_ =
      myProblem ()->
         myPreprocessor ()->
            expPreData ()->
               allParts ();

   allOperations_ =
      myProblem ()->
         myPreprocessor ()->
            expPreData ()->
               allOperations ();
   }

//------------------------------------------------------------------------------

@


1.61
log
@Stochastic Implosion
@
text
@d521 9
a531 2
#if 1

a542 2

#endif
@


1.60
log
@Stochastic Implosion
@
text
@d33 1
d521 21
@


1.59
log
@Stochastic Implosion.
@
text
@d39 1
a39 1
// Implemenation of class CompMgr.
@


1.58
log
@Stochastic implosion.
@
text
@a31 1
#include <StochMgr.h>
a425 3
   if (myProblem ()->myStochMgr ()->active ())
      myMsgFac () ("purgeStochActSmsg");

@


1.57
log
@Stochastic implosion.
@
text
@d428 1
a428 1
      myMsgFac () ("purgeWhileStochActSmsg");
@


1.56
log
@[disallowed backlog]
@
text
@d32 1
d427 3
@


1.55
log
@[disallowed backlog]
@
text
@a41 4
bool WitCompMgr::transAllDMPsDone_ = false;

//------------------------------------------------------------------------------

a384 19
void WitCompMgr::transmitAllDMPs ()
   {
   if (transAllDMPsDone_)
      return;

   transAllDMPsDone_ = true;

   stronglyAssert (not WitApiMgr::multiThread ());

   WitGlobalComp::transmitDMPs ();
   WitPart      ::transmitDMPs ();
   WitMaterial  ::transmitDMPs ();
   WitDemand    ::transmitDMPs ();
   WitOperation ::transmitDMPs ();
   WitSubEntry  ::transmitDMPs ();
   }

//------------------------------------------------------------------------------

@


1.54
log
@[disallowed backlog]
@
text
@a402 3
   WitBillEntry ::transmitDMPs ();
   WitConsEntry ::transmitDMPs ();
   WitBomEntry  ::transmitDMPs ();
a403 1
   WitBopEntry  ::transmitDMPs ();
@


1.53
log
@Rescinded all changed made since 1/31/07.
@
text
@a397 1
   WitCompMgr   ::transmitDMPs ();
a750 8

void WitCompMgr::transmitDMPs ()
   {
   WitPreprocessor::receiveDMPs (& WitCompMgr::allParts_,
                                 & WitCompMgr::allOperations_);
   }

//------------------------------------------------------------------------------
@


1.52
log
@[disallowed backlog]
@
text
@d400 2
d403 3
d407 2
@


1.51
log
@[disallowed backlog]
@
text
@a401 2
   WitSubEntry  ::transmitDMPs ();
   WitBopEntry  ::transmitDMPs ();
@


1.50
log
@[disallowed backlog]
@
text
@a399 1
   WitMaterial  ::transmitDMPs ();
a400 3
   WitOperation ::transmitDMPs ();
   WitBillEntry ::transmitDMPs ();
   WitConsEntry ::transmitDMPs ();
@


1.49
log
@App controlled opt implosion.
@
text
@a399 1
   WitPart      ::transmitDMPs ();
@


1.48
log
@Replaced WIT's hash tables with std:maps.
@
text
@a31 1
#include <DataAlt.h>
d474 1
a474 1
   myProblem ()->preprocAlt ()->incur ();
@


1.47
log
@Updated the copyright date on all source files.
@
text
@d21 1
a21 1
#include <Hash.h>
d58 2
a59 2
      myPartTable_      (new WitHashTable (theProblem)),
      myOperationTable_ (new WitHashTable (theProblem)),
d81 3
a83 1
   myDelCompItr_ = new WitDelCompItr (myProblem_);
@


1.46
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.45
log
@[shared-resource pegging]
@
text
@d769 1
a769 1
   myDelCompStack_.attach (myStItr_);
d784 1
a784 1
   myDelCompStack_.attach (myStItr_);
d845 1
a845 1
   myDelCompStack_.attach (myStItr_);
@


1.44
log
@[multi-thread]
@
text
@d769 1
a769 1
   myStItr_.attachTo (myDelCompStack_);
d784 1
a784 1
   myStItr_.attachTo (myDelCompStack_);
d845 1
a845 1
   myStItr_.attachTo (myDelCompStack_);
@


1.43
log
@[multi-thread]
@
text
@d19 1
d35 1
a35 1
#include <wit.h>
d43 1
a43 1
bool WitCompMgr::dataTransmitted_ = false;
d388 1
a388 1
void WitCompMgr::transmitData ()
d390 1
a390 1
   if (dataTransmitted_)
d393 1
a393 1
   dataTransmitted_ = true;
d395 1
a395 4
   WitPart::transmitData ();
   }

//------------------------------------------------------------------------------
d397 11
a407 5
void WitCompMgr::loadPre ()
   {
   myProblem_->myPreprocessor ()->loadDataFromCompMgr (
      allParts_,
      allOperations_);
d751 8
@


1.42
log
@Pegged Critical List
@
text
@d42 4
d387 12
@


1.41
log
@Tie Breaking Prop-Rt.
@
text
@d438 2
@


1.40
log
@Double Precision.
@
text
@d33 1
a33 1
#include <PipSysMgr.h>
d436 1
a436 1
   myProblem ()->myPipSysMgr ()->clearShipSeq ();
@


1.39
log
@Continued implementation of PIP.
@
text
@d486 1
a486 1
   allComponents_.copy (remainingComps);
@


1.38
log
@Continued implementation of PIP.
@
text
@d33 1
a33 1
#include <PipMgr.h>
d436 1
a436 1
   myProblem ()->myPipMgr ()->clearShipSeq ();
@


1.37
log
@Continued implementation of PIP.
@
text
@d436 1
a436 2
   if (myGlobalComp ()->pip ())
      myProblem ()->myPipMgr ()->clearShipSeq ();
@


1.36
log
@Continued implementation of PIP.
@
text
@d33 1
a33 1
#include <PipInt.h>
d437 1
a437 1
      myProblem ()->myPipInt ()->clearShipSeq ();
@


1.35
log
@Removed a bad function overload.
@
text
@d33 1
d435 3
@


1.34
log
@Modifications for Linux port.
@
text
@d456 1
a456 1
      theDelComp = theComp->myDelComp ();
d475 1
a475 1
      theDelComp = theComp->myDelComp ();
d614 1
a614 1
      theDelComp = theComp->myDelComp ();
d804 1
a804 1
      theDelComp = theComp->myDelComp ();
@


1.33
log
@Continued implementation of proportionate routing.
@
text
@d302 1
a302 1
   return cache (thePart->myDemands ().find (WitDemand::demandName, theName));
@


1.32
log
@Continued implementation of proportionate routing.
@
text
@d456 1
a456 1
      theComp->getDelComp (theDelComp);
d475 1
a475 1
      theComp->getDelComp (theDelComp);
d614 1
a614 1
      theComp->getDelComp (theDelComp);
d804 1
a804 1
      theComp->getDelComp (theDelComp);
@


1.31
log
@Replaced some C style casts with C++ style casts.
@
text
@a94 52
int WitCompMgr::nInstances (WitNode *) const
   {
   return nNodes ();
   }

int WitCompMgr::nInstances (WitPart *) const
   {
   return nParts ();
   }

int WitCompMgr::nInstances (WitOperation *) const
   {
   return nOperations ();
   }

int WitCompMgr::nInstances (WitMaterial * ) const
   {
   return nMaterials ();
   }

int WitCompMgr::nInstances (WitBillEntry *) const
   {
   return nBillEntries ();
   }

int WitCompMgr::nInstances (WitBomEntry * ) const
   {
   return nBomEntries ();
   }

int WitCompMgr::nInstances (WitSubEntry * ) const
   {
   return nSubEntries ();
   }

int WitCompMgr::nInstances (WitBopEntry * ) const
   {
   return nBopEntries ();
   }

int WitCompMgr::nInstances (WitDemand *   ) const
   {
   return nDemands ();
   }

int WitCompMgr::nInstances (const WitBoundSet * ) const
   {
   return nBoundSets ();
   }

//------------------------------------------------------------------------------

@


1.30
log
@Internal changes.
@
text
@d260 1
a260 1
   return (WitPart *) myPartTable_->namedNode (theName);
d267 1
a267 1
   return (WitOperation *) myOperationTable_->namedNode (theName);
@


1.29
log
@Internal changes.
@
text
@d456 1
a456 1
         if (! theBoundSet->isAtDefault ())
d529 1
a529 1
      if ((theDelComp != NULL) && theDelComp->selForDel ())
d537 1
a537 1
   while (! selComps.isEmpty ())
d646 1
a646 1
   witAssert (! theComp->inserted ());
@


1.28
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d70 1
a70 1
      purging_          (witFALSE),
d73 1
a73 1
      clearingDepLists_ (witFALSE)
d504 1
a504 1
   purging_ = witTRUE;
d544 1
a544 1
   purging_ = witFALSE;
d556 1
a556 1
WitBoolean WitCompMgr::isReindexing (const WitBoundSet * theBoundSet) const
d560 1
a560 1
         return witTRUE;
d562 1
a562 1
   return witFALSE;
d567 1
a567 1
WitBoolean WitCompMgr::isDeleting (WitComponent * theComp) const
d747 1
a747 1
   clearingDepLists_ = witTRUE;
d756 1
a756 1
   clearingDepLists_ = witFALSE;
d812 1
a812 1
   WitBoolean foundDelComp;
@


1.27
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d22 1
a22 1
#include <Demand.h>
d28 1
a29 1
#include <OptComp.h>
@


1.26
log
@Continued implementation of Single-Source.
@
text
@d21 1
d23 1
d25 1
d27 1
@


1.25
log
@Continued implementation of Single-Source.
@
text
@a31 1
#include <ObjStack.h>
d780 2
a781 2
      myDelCompStack_ (* new WitObjStack <WitDelComp> (theProblem)),
      myStItr_        (* new WitObjStItr <WitDelComp>),
a790 2
   delete & myStItr_;
   delete & myDelCompStack_;
@


1.24
log
@Continued implementation of single-source.
@
text
@d726 3
@


1.23
log
@Continued implementation of single-source.
@
text
@d431 9
a768 7
   }

//------------------------------------------------------------------------------

WitBoolean WitCompMgr::preprocAcc () const
   {
   return myProblem ()->myPreprocessor ()->myAccFlag ()->accessing (this);
@


1.22
log
@Continued implementation of single-source.
@
text
@a430 25
void WitCompMgr::importSortedNodes ()
   {
   WitNode *      theNode;
   WitPart *      thePart;
   WitOperation * theOpn;

   allParts_     .clear ();
   allOperations_.clear ();

   forEachEl (theNode, myProblem_->myPreprocessor ()->sortedNodes ())
      {     
      theNode->getPart (thePart);

      if (thePart != NULL)
         allParts_.append (thePart);

      theNode->getOperation (theOpn);

      if (theOpn != NULL)
         allOperations_.append (theOpn);
      }
   }

//------------------------------------------------------------------------------

@


1.21
log
@Continued preliminary work on single source.
@
text
@d431 25
@


1.20
log
@Preliminary work on single source.
@
text
@d23 2
@


1.19
log
@Preliminary work on single source.
@
text
@d521 1
a521 1
   allComponents_.copyOf (remainingComps);
@


1.18
log
@Continued implementation of object iteration.
@
text
@d459 1
a459 1
   WitList (WitComponent) remainingComps;
d463 1
a463 1
   WitList (WitComponent) selComps;
d521 1
a521 1
   allComponents_ = remainingComps;
@


1.17
log
@Continued implementation of object iteration.
@
text
@d829 1
a829 1
WitAttr WitDelCompItr::curApiItrState ()
d833 1
a833 1
         curDelComp ()->apiItrState ():
@


1.16
log
@Continued implementation of object iteration.
@
text
@a843 3
   if (! myGlobalComp ()->allowObjItr ())
      myMsgFac () ("genericSmsg", "Object iteration is not yet available.");

@


1.15
log
@Continued implementation of object iteration.
@
text
@d27 1
d468 1
a468 1
      myMsgFac () ("purgeDuringItrSmsg");
a792 3
   if (curDelComp_ == NULL)
      return;

d804 2
d809 13
a821 1
   myStItr_.advance (curDelComp_);
a822 1
   if (curDelComp_ == NULL)
d824 11
@


1.14
log
@Began implementation of object iteration.
@
text
@d13 4
a16 1
// Contains the implementation of class CompMgr.
d19 1
d29 1
d32 2
d63 1
d69 1
d76 1
d466 2
d492 4
a495 1
      if (theComp->isADelComp (theDelComp))
d497 1
d511 4
a514 1
      if (theComp->isADelComp (theDelComp) && theDelComp->selForDel ())
d518 1
d650 4
a653 1
      if (theComp->isADelComp (theDelComp))
d656 1
d764 74
@


1.13
log
@Minor change.
@
text
@d18 1
d23 1
@


1.12
log
@Continued implementation of pegging.
@
text
@d455 1
a455 1
   if (myGlobalComp ()->peggingNeeded ())
@


1.11
log
@Continued implementation of pegging.
@
text
@d455 1
a455 1
   if (myGlobalComp ()->pegging ())
@


1.10
log
@Continued implementation of pegging.
@
text
@d455 1
a455 1
   if (myGlobalComp ()->perfPegging ())
@


1.9
log
@Continued implementation of pegging.
@
text
@d455 1
a455 1
   if (myGlobalComp ()->doPegging ())
@


1.8
log
@Initial implementation of pegging.
@
text
@a19 1
#include <PegMgr.h>
d456 1
a456 1
      myProblem ()->myHeurAllMgr ()->myPegMgr ()->clear ();
@


1.7
log
@More templates.
@
text
@d19 2
d455 3
@


1.6
log
@Continued development of selection splitting for multi=exec.
@
text
@d690 1
a690 1
   WitPtrVec (WitComponent) indexedComp;
@


1.5
log
@Coarse selection splitting.
@
text
@d286 1
a286 1
      if (   theCachedSubEntry->myBomEntry () == theBomEnt)
@


1.4
log
@Some minor changes.
@
text
@d340 1
a340 1
void WitCompMgr::recount (WitComponent * theComp)
d342 4
a345 1
   witAssert (theComp == recountingComp_);
d347 3
a349 4
   recountingComp_ = NULL;
      //
      // Prevents this function from being called more than once for the same
      // Component.
d354 1
a354 1
void WitCompMgr::recount (WitMaterial * theMat)
d363 1
a363 1
void WitCompMgr::recount (WitCapacity * theCap)
d370 1
a370 1
void WitCompMgr::recount (WitOperation * theOpn)
d372 1
a372 1
   recountComp (theOpn);
d379 1
a379 1
void WitCompMgr::recount (WitBomEntry * theBomEnt)
d381 1
a381 1
   recountComp (theBomEnt);
d388 1
a388 1
void WitCompMgr::recount (WitSubEntry * theSub)
d390 1
a390 1
   recountComp (theSub);
d397 1
a397 1
void WitCompMgr::recount (WitBopEntry * theBopEnt)
d399 1
a399 1
   recountComp (theBopEnt);
d406 1
a406 1
void WitCompMgr::recount (WitDemand * theDemand)
d408 1
a408 1
   recountComp (theDemand);
d555 35
a683 9
   }

//------------------------------------------------------------------------------

void WitCompMgr::recountPart (WitPart * thePart)
   {
   recountComp (thePart);

   ++ nParts_;
@


1.3
log
@Refactoring for selection splitting.
@
text
@d21 1
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@a51 2
      indexedCompTl_    (),

d661 4
a664 2
   WitComponent * theComp;
   int            i;
d666 1
a666 1
   indexedCompTl_.resize (allComponents ().nElements (), NULL);
d676 1
a676 1
      indexedComp (++ i) = theComp;
d683 1
a683 1
   for (i = indexedCompTl_.length () - 1; i >= 0; -- i)
d685 1
a685 1
      deleteComp (indexedComp (i));
d687 1
a687 1
      indexedComp (i) = NULL;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.139;
access;
symbols
	sce_5_01_20080919:1.116
	latest_sce_4_20_20060523:1.115.0.2
	sce_4_20_20060523:1.115
	latest_sce4_20_OSL:1.114.0.2
	sce_4_20_OSL:1.114
	sce_410_withVa:1.114
	sce_4_05_20040511:1.92
	sce_4_00_20040201:1.92
	nextGenBranch:1.89.0.2
	nextGenRoot:1.89
	sce_3_30_20030627:1.88
	EndRw-branch:1.75.0.2
	Root-of-EndRw:1.75
	rwToStl:1.73.0.2
	latest_sce_3_10_20010924:1.55.0.2
	sce_3_10_20010924:1.55
	latest_sce_3_00_20010601:1.36.0.2
	sce_3_00_20010601:1.36
	latest_sce_2_31_20010308:1.14.0.2
	sce_2_31_20010308:1.14
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.139
date	2011.09.28.23.49.07;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2011.09.24.00.27.24;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2011.08.30.20.17.19;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2010.07.30.20.20.13;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2010.07.29.21.03.11;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2010.07.28.21.40.39;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2010.07.28.19.27.46;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2010.07.26.17.48.43;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2010.07.21.18.50.14;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2010.07.16.22.26.40;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2010.07.15.23.49.24;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2010.07.14.19.25.18;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2010.07.13.17.41.29;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2010.07.02.18.53.10;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2010.07.01.22.41.20;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2010.06.29.22.32.30;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2010.06.29.19.56.41;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2010.06.25.22.16.58;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2010.06.25.19.44.13;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2010.06.25.15.42.51;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2010.06.24.23.37.32;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2010.06.18.23.11.14;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2010.03.16.22.42.24;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2006.05.02.17.33.55;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2005.03.28.20.14.35;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2005.01.15.00.20.07;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2005.01.13.17.24.20;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2005.01.06.20.34.08;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2005.01.01.00.43.12;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2004.12.31.19.52.24;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2004.12.31.18.28.28;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2004.12.28.22.34.26;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2004.12.28.19.21.18;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2004.12.22.19.57.26;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2004.12.21.22.13.48;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2004.12.20.21.13.09;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2004.12.20.18.36.24;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2004.12.17.21.53.00;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2004.12.16.23.35.16;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2004.12.15.23.50.10;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2004.12.15.20.20.50;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2004.12.14.22.37.09;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2004.12.13.23.35.47;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2004.12.10.21.58.31;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2004.12.10.16.49.43;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2004.12.09.21.34.11;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2003.11.11.20.42.46;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2003.11.11.18.29.11;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2003.10.02.20.46.43;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2003.07.10.22.58.16;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2003.05.05.16.09.59;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2003.04.29.14.27.44;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2003.04.14.22.00.33;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2003.04.11.19.08.24;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2003.04.01.20.34.24;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2003.03.19.16.48.13;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2003.03.07.21.34.14;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2003.02.14.20.12.55;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2003.02.07.23.29.08;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2003.01.29.19.16.45;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2003.01.02.23.40.37;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2003.01.02.22.18.20;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2002.12.17.21.32.44;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2002.11.21.22.53.53;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2002.11.15.20.27.07;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2002.09.11.18.53.05;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2002.08.02.17.03.33;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2002.08.01.20.16.34;	author austel;	state Exp;
branches;
next	1.70;

1.70
date	2002.07.02.21.53.01;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.14.15.49.50;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2002.05.24.23.00.02;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.07.20.14.53;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2002.04.22.14.32.03;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2002.04.18.14.02.27;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2002.04.15.21.21.34;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2002.04.12.21.01.58;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2002.04.11.15.36.27;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2002.03.22.21.23.20;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.20.22.51.16;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.19.16.20.55;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.15.23.17.28;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2001.12.19.16.17.08;	author bobw;	state Exp;
branches;
next	1.56;

1.56
date	2001.09.28.00.12.56;	author bobw;	state Exp;
branches;
next	1.55;

1.55
date	2001.09.19.18.50.56;	author bobw;	state Exp;
branches;
next	1.54;

1.54
date	2001.09.17.18.56.27;	author bobw;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.30.20.29.22;	author bobw;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.24.22.03.19;	author bobw;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.23.21.13.52;	author bobw;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.22.20.41.47;	author bobw;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.21.17.31.44;	author bobw;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.17.22.00.08;	author bobw;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.14.20.43.53;	author bobw;	state Exp;
branches;
next	1.46;

1.46
date	2001.07.25.16.08.12;	author bobw;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.06.23.36.00;	author bobw;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.03.20.07.29;	author bobw;	state Exp;
branches;
next	1.43;

1.43
date	2001.07.03.17.00.57;	author bobw;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.19.14.42.50;	author bobw;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.15.20.53.35;	author bobw;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.14.17.41.52;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.13.20.30.22;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.11.19.29.09;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.01.19.23.31;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.30.21.16.48;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.29.22.11.25;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.25.22.59.11;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.25.14.53.22;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.17.15.11.13;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.10.22.31.11;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.30.21.29.40;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.24.23.09.57;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.06.23.23.51;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.06.19.22.08;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.04.21.54.17;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.03.19.23.03;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.30.23.29.55;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.30.21.23.07;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.30.18.54.47;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.29.00.10.15;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.27.20.07.26;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.23.19.43.23;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.21.21.55.45;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.20.21.03.57;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.12.19.48.06;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.08.16.37.03;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.01.16.24.43;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.31.23.17.45;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.31.00.09.24;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.29.19.26.09;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.27.00.24.37;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.26.21.46.00;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.24.20.05.56;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.20.00.44.15;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.15.19.01.49;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.11.16.35.07;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.37;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.19;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.25;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches;
next	;


desc
@@


1.139
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "BuildAhd.C"
//
// Contains the implementation of the following classes:
//
//    BaMgr.
//    BaDir.
//    NstnBaDir.
//    AsapBaDir.
//    BaMat.
//    BaPt.
//    BaCand.
//------------------------------------------------------------------------------

#include <HeurAtor.h>
#include <Selector.h>
#include <BaMgr.h>
#include <BaCand.h>
#include <BaDir.h>
#include <BaMat.h>
#include <BaPt.h>
#include <DetAltPt.h>
#include <SglSrcMgr.h>
#include <SplitPt.h>
#include <GlobalComp.h>
#include <Material.h>
#include <BopEntry.h>
#include <MsgFac.h>
#include <PairStack.h>

//------------------------------------------------------------------------------
// Implementation of class BaMgr.
//------------------------------------------------------------------------------

WitBaMgr::WitBaMgr (WitSelector * theSelector):
      WitSelMgr       (theSelector),

      myBaDirForNstn_ (NULL),
      myBaDirForAsap_ (NULL),
      myBaMatFor_     (myProblem ()),
      pairsToReject_  (myProblem ()),
      savedExpPer_    (-1),
      alteredBaMats_  (myProblem ()),
      baAlteredAt_    ()
   {
   bool          nstnMatExists;
   bool          asapMatExists;
   WitMaterial * theMat;

   myBaDirForNstn_ = new WitNstnBaDir (this);
   myBaDirForAsap_ = new WitAsapBaDir (this);

   nstnMatExists   = false;
   asapMatExists   = false;

   forEachMaterial (theMat, myProblem ())
      if (not theMat->producingBopEntries ().isEmpty ())
         {
         if      (theMat->nstnBaNeeded ())
            {
            myBaMatFor_ (theMat) = new WitBaMat (theMat, myBaDirForNstn_, this);

            nstnMatExists        = true;
            }

         else if (theMat->buildAsap ())
            {
            myBaMatFor_ (theMat) = new WitBaMat (theMat, myBaDirForAsap_, this);

            asapMatExists        = true;
            }
         }

   if (myGlobalComp ()->selectionRecovery ())
      baAlteredAt_.allocate (myProblem (), false);

   if (nstnMatExists)
      myMsgFac () ("nstnMsg");

   if (asapMatExists)
      myMsgFac () ("asapMsg");
   }

//------------------------------------------------------------------------------

WitBaMgr::~WitBaMgr ()
   {
   WitMaterial * theMat;

   forEachMaterial (theMat, myProblem ())
      delete myBaMatFor_ (theMat);

   delete myBaDirForAsap_;
   delete myBaDirForNstn_;
   }

//------------------------------------------------------------------------------

bool WitBaMgr::instNeededFor (WitProblem * theProblem)
   {
   WitMaterial * theMat;

   forEachMaterial (theMat, theProblem)
      if (theMat->nstnBaNeeded () or theMat->buildAsap ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

WitPeriod WitBaMgr::selExpPer (WitPart * thePart, WitPeriod fillPer)
   {
   WitBaMat * theBaMat;
   WitPeriod  expPer;

   expPer = selExpPer (thePart, fillPer, theBaMat);

   return 
      (expPer >= 0)?
         expPer:
         thePart->explosionPeriod (fillPer);
   }

//------------------------------------------------------------------------------

void WitBaMgr::print ()
   {
   WitMaterial * theMat;
   WitBaMat *    theBaMat;

   fprintf (msgFile (),
      "\n"
      "Build-Ahead Period Selections:\n");

   forEachMaterial (theMat, myProblem ())
      {
      theBaMat = myBaMatFor_ (theMat);

      if (theBaMat != NULL)
         theBaMat->print ();
      }
   }

//------------------------------------------------------------------------------

void WitBaMgr::saveExpPer (WitPeriod expPer)
   {
   witAssert (savedExpPer_ == -1);
   witAssert (expPer       != -1);

   savedExpPer_ = expPer;
   }

//------------------------------------------------------------------------------

void WitBaMgr::retrieveExpPer (WitPeriod & expPer)
   {
   witAssert (savedExpPer_ != -1);

   expPer       = savedExpPer_;
   savedExpPer_ = -1;
   }

//------------------------------------------------------------------------------

void WitBaMgr::storeRecoveryPt (WitBaMat * theBaMat)
   {
   witAssert (myGlobalComp ()->selectionRecovery ());

   if (baAlteredAt_ (theBaMat->myMaterial ()))
      return;

   baAlteredAt_ (theBaMat->myMaterial ()) = true;

   alteredBaMats_.push (theBaMat);
   }

//------------------------------------------------------------------------------

void WitBaMgr::recoverInitState ()
   {
   WitBaMat * theBaMat;

   while (alteredBaMats_.pop (theBaMat))
      if (baAlteredAt_ (theBaMat->myMaterial ()))
         {
         theBaMat->recoverInitState ();

         baAlteredAt_ (theBaMat->myMaterial ()) = false;
         }
   }

//------------------------------------------------------------------------------

bool WitBaMgr::selSplitNeeded ()
   {
   WitMaterial * theMat;

   if (myGlobalComp ()->selSplit ())
      return true;

   if (myGlobalComp ()->nonMrSelSplit ())
      return true;

   forEachMaterial (theMat, myProblem ())
      if (theMat->nstnBaNeeded () or theMat->buildAsap ())
         if (theMat->baSelSplit ())
            return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitBaMgr::selIsSplit (WitPart * thePart, WitPeriod fillPer)
   {
   WitBaPt * theBaPt;

   if (not selSplit ())
      return false;

   theBaPt = myBaPt (thePart, fillPer);

   if (theBaPt == NULL)
      return false;

   return theBaPt->isSplit ();
   }

//------------------------------------------------------------------------------

void WitBaMgr::defineSplit (
      WitPart *        thePart,
      WitPeriod        fillPer,
      double           reqVol,
      WitPerDblStack & theSplitPairs,
      double &         unbddVol)
   {
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitPeriod          expPer;
   WitFixedPer *      theFixedPer;

   witAssert (selIsSplit (thePart, fillPer));

   myBaPt (thePart, fillPer)->
      mySplitPt ()->
         defineSplit (reqVol, theAbsSplitPairs, unbddVol);

   theSplitPairs.clear ();

   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      theSelCand->getBaData (expPer);

      theFixedPer = mySelector ()->myFixedPer ()[expPer];

      theSplitPairs.push (theFixedPer, splitVol);
      }
   }

//------------------------------------------------------------------------------

void WitBaMgr::recExpMatSS (WitPart * thePart, WitPeriod fillPer, double expVol)
   {
   WitBaPt * theBaPt;

   witAssert (selSplit ());

   if (thePart == mySelector ()->myHeurAtor ()->topPart ())
      return;

   theBaPt = myBaPt (thePart, fillPer);

   if (theBaPt != NULL)
      theBaPt->recordFlowSS (expVol);
   }

//------------------------------------------------------------------------------

void WitBaMgr::postSplitCommit ()
   {
   WitBaMat * theBaMat;
   WitPeriod  expPer;

   witAssert (selSplit ());

   while (pairsToReject_.pop (theBaMat, expPer))
      theBaMat->reject (expPer);
   }

//------------------------------------------------------------------------------

void WitBaMgr::deferRejection (WitBaMat * theBaMat, WitPeriod expPer)
   {
   witAssert (selSplit ());

   witAssert (mySelector ()->splitCommActive ());

   pairsToReject_.push (theBaMat, expPer);
   }

//------------------------------------------------------------------------------

WitAltPt * WitBaMgr::myAltPtFor (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod,
      WitPeriod     fillPer)
   {
   return myAltPtFor (theBopEnt->myPart (), fillPer);
   }

//------------------------------------------------------------------------------

WitAltPt * WitBaMgr::myAltPtFor (WitPart * thePart, WitPeriod fillPer)
   {
   WitBaMat * theBaMat;
   WitPeriod  expPer;

   expPer = selExpPer (thePart, fillPer, theBaMat);

   if (expPer < 0)
      return NULL;

   return theBaMat->myBaPt ()[fillPer]->myDetAltPt ();
   }

//------------------------------------------------------------------------------

bool WitBaMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitBaMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitBaMgr::validForLTBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

const char * WitBaMgr::selCaseName ()
   {
   return "Build-Ahead";
   }

//------------------------------------------------------------------------------

WitPeriod WitBaMgr::selExpPer (
      WitPart *    thePart, 
      WitPeriod    fillPer,
      WitBaMat * & theBaMat)
   {
   WitMaterial * theMat;

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return -1;

   theBaMat = myBaMatFor_ (theMat);

   if (theBaMat == NULL)
      return -1;

   return theBaMat->myBaPt ()[fillPer]->selExpPer ();
   }

//------------------------------------------------------------------------------

WitBaPt * WitBaMgr::myBaPt (WitPart * thePart, WitPeriod fillPer)
   {
   WitMaterial * theMat;
   WitBaMat *    theBaMat;

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return NULL;

   theBaMat = myBaMatFor_ (theMat);

   if (theBaMat == NULL)
      return NULL;

   return theBaMat->myBaPt ()[fillPer];
   }

//------------------------------------------------------------------------------
// Implementation of class BaDir.
//------------------------------------------------------------------------------

WitBaDir::~WitBaDir ()
   {
   }

//------------------------------------------------------------------------------

WitBaDir::WitBaDir (WitBaMgr * theBaMgr):

      WitProbAssoc (theBaMgr),
      myBaMgr_     (theBaMgr)
   {
   }

//------------------------------------------------------------------------------
// Implementation of class NstnBaDir.
//------------------------------------------------------------------------------

WitNstnBaDir::WitNstnBaDir (WitBaMgr * theBaMgr):
      WitBaDir (theBaMgr)
   {
   }

//------------------------------------------------------------------------------

WitNstnBaDir::~WitNstnBaDir ()
   {
   }

//------------------------------------------------------------------------------

void WitNstnBaDir::findInitExpPers (
      WitMaterial *,
      WitTVec <WitPeriod> & expPerVec)
   {
   WitPeriod fillPer;

   forEachPeriod (fillPer, myProblem ())
      expPerVec[fillPer] = fillPer;
   }

//------------------------------------------------------------------------------

WitPeriod WitNstnBaDir::findInitExpPer (WitMaterial * theMat, WitPeriod fillPer)
   {
   return fillPer;
   }

//------------------------------------------------------------------------------

void WitNstnBaDir::advanceExpPer (
      WitMaterial * theMat,
      WitPeriod     fillPer, 
      WitPeriod &   expPer)
   {
   expPer --;

   if (expPer >= 0) 
      if (expPer >= fillPer - theMat->buildAheadUB ()[fillPer])
         if (not theMat->mandEC ()[expPer])
            return;

   expPer = -1;
   }

//------------------------------------------------------------------------------
// Implementation of class AsapBaDir.
//------------------------------------------------------------------------------

WitAsapBaDir::WitAsapBaDir (WitBaMgr * theBaMgr):
      WitBaDir (theBaMgr)
   {
   }

//------------------------------------------------------------------------------

WitAsapBaDir::~WitAsapBaDir ()
   {
   }

//------------------------------------------------------------------------------

void WitAsapBaDir::findInitExpPers (
      WitMaterial *         theMat,
      WitTVec <WitPeriod> & expPerVec)
   {
   WitPeriod fillPer;
   WitPeriod firstStockPer;

   firstStockPer = 0;

   forEachPeriod (fillPer, myProblem ())
      {
      expPerVec[fillPer] =
         max (firstStockPer, fillPer - theMat->buildAheadUB ()[fillPer]);

      if (theMat->mandEC ()[fillPer])
         firstStockPer = fillPer + 1;
      }
   }

//------------------------------------------------------------------------------

WitPeriod WitAsapBaDir::findInitExpPer (WitMaterial * theMat, WitPeriod fillPer)
   {
   WitPeriod expPer;

   if (theMat->mandEC () == false)
      {
      return max (0, fillPer - theMat->buildAheadUB ()[fillPer]);
      }

   for (expPer = fillPer; ; expPer --)
      {
      if (expPer == 0)
         return expPer;

      if (expPer == fillPer - theMat->buildAheadUB ()[fillPer])
         return expPer;
      
      if (theMat->mandEC ()[expPer - 1])
         return expPer;
      }
   }

//------------------------------------------------------------------------------

void WitAsapBaDir::advanceExpPer (
      WitMaterial *,
      WitPeriod     fillPer, 
      WitPeriod &   expPer)
   {
   expPer ++;

   if (expPer > fillPer)
      expPer = -1;
   }

//------------------------------------------------------------------------------
// Implementation of class BaMat.
//------------------------------------------------------------------------------

WitBaMat::WitBaMat (
         WitMaterial * theMat, 
         WitBaDir *    theBaDir, 
         WitBaMgr *    theBaMgr):

      WitProbAssoc (theMat),
      myMaterial_  (theMat),
      myBaDir_     (theBaDir),
      myBaMgr_     (theBaMgr),
      myBaPt_      (myProblem ()),
      useable_     (myProblem (), true)
   {
   WitPeriod fillPer;

   forEachPeriod (fillPer, myProblem ())
      myBaPt_[fillPer] = new WitBaPt (this, fillPer);

   WitBaPt::setInitSelExpPers (this);

   rejectUnexplodablePers ();
   }

//------------------------------------------------------------------------------

WitBaMat::~WitBaMat ()
   {
   deleteContents (myBaPt_);
   }

//------------------------------------------------------------------------------

void WitBaMat::findInitExpPers (WitTVec <WitPeriod> & expPerVec)
   {
   myBaDir_->findInitExpPers (myMaterial_, expPerVec);
   }

//------------------------------------------------------------------------------

void WitBaMat::reject (WitPeriod expPer)
   {
   if (not useable_[expPer])
      return;

   if (myBaMgr_->mySelector ()->sglSrc ())
      myBaMgr_->mySelector ()->mySglSrcMgr ()->saveConfigVal (useable_[expPer]);

   useable_[expPer] = false;

   deselect (expPer);
   }

//------------------------------------------------------------------------------

WitPeriod WitBaMat::nextUseableExpPer (WitPeriod fillPer)
   {
   WitPeriod expPer;

   expPer = myBaPt_[fillPer]->selExpPer ();

   while (true)
      {
      myBaDir_->advanceExpPer (myMaterial_, fillPer, expPer);

      if (expPer < 0)
         return -1;

      if (useable_[expPer])
         return expPer;
      }

   return -1; 
      //                       
      // Avoids a compiler warning.
   }

//------------------------------------------------------------------------------

WitPeriod WitBaMat::findInitExpPer (WitPeriod fillPer)
   {
   return myBaDir_->findInitExpPer (myMaterial_, fillPer);
   }

//------------------------------------------------------------------------------

void WitBaMat::print ()
   {
   WitPeriod fillPer;
   WitPeriod expPer;

   fprintf (msgFile (),
      "\n"
      "Build-Ahead Material %s:\n\n"
      "    Exp Per   Useable?\n",
      myMaterial_->partName ().myCstring ());

   forEachPeriod (expPer, myProblem ())
      fprintf (msgFile (), 
         "    %7d   %7s\n",
         expPer,
         myMsgFac ().boolText (useable_[expPer]));
   
   fprintf (msgFile (), 
      "\n"
      "   Fill Per   Exp Per\n");

   forEachPeriod (fillPer, myProblem ())
      {
      fprintf (msgFile (), "   %8d", fillPer);

      expPer = myBaPt ()[fillPer]->selExpPer ();

      if (expPer >= 0)
         fprintf (msgFile (), "   %7d\n", expPer);
      else
         fprintf (msgFile (), "         *\n");
      }
   }

//------------------------------------------------------------------------------

void WitBaMat::recoverInitState ()
   {
   useable_ = true;

   WitBaPt::setInitSelExpPers (this);

   rejectUnexplodablePers ();

   if (selPrintLevelAt (3))
      printRecovery ();
   }

//------------------------------------------------------------------------------

void WitBaMat::rejectUnexplodablePers ()
   {
   WitPeriod expPer;

   forEachPeriod (expPer, myProblem ())
      if (not myMaterial_->explodeable (expPer))
         {
         useable_[expPer] = false;

         deselect (expPer);
         }
   }

//------------------------------------------------------------------------------

void WitBaMat::deselect (WitPeriod expPer)
   {
   WitPeriod fillPer;

   for (fillPer = expPer; fillPer < nPeriods (); fillPer ++)
      if (myBaPt_[fillPer]->selExpPer () == expPer)
          myBaPt_[fillPer]->advanceSel ();
   }

//------------------------------------------------------------------------------

void WitBaMat::printRecovery ()
   {
   fprintf (msgFile (),
      "   Initial build-ahead configuration recovered for part %s.\n\n",
      myMaterial_->partName ().myCstring ());
   }

//------------------------------------------------------------------------------
// Implementation of class BaPt.
//------------------------------------------------------------------------------

WitBaPt::WitBaPt (WitBaMat * theBaMat, WitPeriod fillPer):

      WitDetSelPt (),

      myBaMat_    (theBaMat),
      myFillPer_  (fillPer),
      selExpPer_  (-1)
   {
   }

//------------------------------------------------------------------------------

WitBaPt::~WitBaPt ()
   {
   }

//------------------------------------------------------------------------------

void WitBaPt::setInitSelExpPers (WitBaMat * theBaMat)
   {
   WitTVec <WitPeriod> expPerVec (theBaMat->myProblem (), -1);
   WitPeriod           fillPer;

   theBaMat->findInitExpPers (expPerVec);

   forEachPeriod (fillPer, theBaMat->myProblem ())
      {
      theBaMat->myBaPt ()[fillPer]->selExpPer_ = expPerVec[fillPer];
      }
   }

//------------------------------------------------------------------------------

void WitBaPt::advanceSel ()
   {
   select (myBaMat_->nextUseableExpPer (myFillPer_));
   }

//------------------------------------------------------------------------------

void WitBaPt::select (WitPeriod expPer)
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (selExpPer_);

   selExpPer_ = expPer;
   }

//------------------------------------------------------------------------------

WitSelMgr * WitBaPt::mySelMgr ()
   {
   return myBaMat_->myBaMgr ();
   }

//------------------------------------------------------------------------------

void WitBaPt::prtID ()
   {
   fprintf (myBaMat_->myBaMgr ()->msgFile (),
      "   Part:             %s\n"
      "   Fill Per:         %d\n",
      myBaMat_->myMaterial ()->partName ().myCstring (),
      myFillPer_);
   }

//------------------------------------------------------------------------------

bool WitBaPt::splittable ()
   {
   if (myBaMat_->myBaMgr ()->myGlobalComp ()->selSplit ())
      return true;

   if (myBaMat_->myBaMgr ()->myGlobalComp ()->nonMrSelSplit ())
      return true;

   return myBaMat_->myMaterial ()->baSelSplit ();
   }

//------------------------------------------------------------------------------

void WitBaPt::getSortData (WitPart * & thePart, WitPeriod & thePer)
   {
   thePart = myBaMat_->myMaterial ();
   thePer  = myFillPer_;
   }

//------------------------------------------------------------------------------

WitSelCand * WitBaPt::newSelCand ()
   {
   return new WitBaCand (selExpPer_, myBaMat_->myProblem ());
   }

//------------------------------------------------------------------------------

bool WitBaPt::hasResAlt ()
   {
   WitPeriod expPer;

   expPer = myBaMat_->nextUseableExpPer (myFillPer_);

   return (expPer >= 0);
   }

//------------------------------------------------------------------------------

void WitBaPt::alterSelection ()
   {
   WitBaMgr * theBaMgr;

   witAssert (selExpPer_ >= 0);

   theBaMgr = myBaMat_->myBaMgr ();

   if (theBaMgr->selSplit () and theBaMgr->mySelector ()->splitCommActive ())
      {
      theBaMgr->deferRejection (myBaMat_, selExpPer_);

      advanceSel ();
      }
   else
      myBaMat_->reject (selExpPer_);
   }

//------------------------------------------------------------------------------

void WitBaPt::storeRecoveryPt ()
   {
   myBaMat_->myBaMgr ()->storeRecoveryPt (myBaMat_);
   }

//------------------------------------------------------------------------------

void WitBaPt::tempAlterSel ()
   {
   myBaMat_->myBaMgr ()->saveExpPer (selExpPer_);

   advanceSel ();
   }

//------------------------------------------------------------------------------

void WitBaPt::cancelTempAlt ()
   {
   WitPeriod expPer;

   myBaMat_->myBaMgr ()->retrieveExpPer (expPer);

   select (expPer);
   }

//------------------------------------------------------------------------------

void WitBaPt::printAlteration ()
   {
   myBaMat_->print ();
   }

//------------------------------------------------------------------------------
// Implementation of class BaCand.
//------------------------------------------------------------------------------

WitBaCand::WitBaCand (WitPeriod expPer, WitProblem * theProblem):

      WitSelCand (theProblem),
      myExpPer_  (expPer)
   {
   }

//------------------------------------------------------------------------------

WitBaCand::~WitBaCand ()
   {
   }

//------------------------------------------------------------------------------

void WitBaCand::prtID ()
   {
   fprintf (msgFile (), "      Exp Period:    %d\n", myExpPer_);
   }

//------------------------------------------------------------------------------

void WitBaCand::getBaData (WitPeriod & expPer)
   {
   expPer = myExpPer_;
   }
@


1.138
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.137
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d45 1
a45 1
WitSelMgr       (theSelector),
d47 45
a91 45
myBaDirForNstn_ (NULL),
myBaDirForAsap_ (NULL),
myBaMatFor_     (myProblem ()),
pairsToReject_  (myProblem ()),
savedExpPer_    (-1),
alteredBaMats_  (myProblem ()),
baAlteredAt_    ()
{
bool          nstnMatExists;
bool          asapMatExists;
WitMaterial * theMat;

myBaDirForNstn_ = new WitNstnBaDir (this);
myBaDirForAsap_ = new WitAsapBaDir (this);

nstnMatExists   = false;
asapMatExists   = false;

forEachMaterial (theMat, myProblem ())
if (not theMat->producingBopEntries ().isEmpty ())
{
if      (theMat->nstnBaNeeded ())
{
myBaMatFor_ (theMat) = new WitBaMat (theMat, myBaDirForNstn_, this);

nstnMatExists        = true;
}

else if (theMat->buildAsap ())
{
myBaMatFor_ (theMat) = new WitBaMat (theMat, myBaDirForAsap_, this);

asapMatExists        = true;
}
}

if (myGlobalComp ()->selectionRecovery ())
baAlteredAt_.allocate (myProblem (), false);

if (nstnMatExists)
myMsgFac () ("nstnMsg");

if (asapMatExists)
myMsgFac () ("asapMsg");
}
d96 2
a97 2
{
WitMaterial * theMat;
d99 2
a100 2
forEachMaterial (theMat, myProblem ())
delete myBaMatFor_ (theMat);
d102 3
a104 3
delete myBaDirForAsap_;
delete myBaDirForNstn_;
}
d109 2
a110 2
{
WitMaterial * theMat;
d112 3
a114 3
forEachMaterial (theMat, theProblem)
if (theMat->nstnBaNeeded () or theMat->buildAsap ())
return true;
d116 2
a117 2
return false;
}
d122 11
a132 11
{
WitBaMat * theBaMat;
WitPeriod  expPer;

expPer = selExpPer (thePart, fillPer, theBaMat);

return
(expPer >= 0)?
expPer:
thePart->explosionPeriod (fillPer);
}
d137 16
a152 16
{
WitMaterial * theMat;
WitBaMat *    theBaMat;

fprintf (msgFile (),
"\n"
"Build-Ahead Period Selections:\n");

forEachMaterial (theMat, myProblem ())
{
theBaMat = myBaMatFor_ (theMat);

if (theBaMat != NULL)
theBaMat->print ();
}
}
d157 3
a159 3
{
witAssert (savedExpPer_ == -1);
witAssert (expPer       != -1);
d161 2
a162 2
savedExpPer_ = expPer;
}
d167 2
a168 2
{
witAssert (savedExpPer_ != -1);
d170 3
a172 3
expPer       = savedExpPer_;
savedExpPer_ = -1;
}
d177 2
a178 2
{
witAssert (myGlobalComp ()->selectionRecovery ());
d180 2
a181 2
if (baAlteredAt_ (theBaMat->myMaterial ()))
return;
d183 1
a183 1
baAlteredAt_ (theBaMat->myMaterial ()) = true;
d185 2
a186 2
alteredBaMats_.push (theBaMat);
}
d191 2
a192 2
{
WitBaMat * theBaMat;
d194 8
a201 8
while (alteredBaMats_.pop (theBaMat))
if (baAlteredAt_ (theBaMat->myMaterial ()))
{
theBaMat->recoverInitState ();

baAlteredAt_ (theBaMat->myMaterial ()) = false;
}
}
d206 2
a207 2
{
WitMaterial * theMat;
d209 2
a210 2
if (myGlobalComp ()->selSplit ())
return true;
d212 2
a213 2
if (myGlobalComp ()->nonMrSelSplit ())
return true;
d215 4
a218 4
forEachMaterial (theMat, myProblem ())
if (theMat->nstnBaNeeded () or theMat->buildAsap ())
if (theMat->baSelSplit ())
return true;
d220 2
a221 2
return false;
}
d226 2
a227 2
{
WitBaPt * theBaPt;
d229 2
a230 2
if (not selSplit ())
return false;
d232 1
a232 1
theBaPt = myBaPt (thePart, fillPer);
d234 2
a235 2
if (theBaPt == NULL)
return false;
d237 2
a238 2
return theBaPt->isSplit ();
}
d243 29
a271 29
WitPart *        thePart,
WitPeriod        fillPer,
double           reqVol,
WitPerDblStack & theSplitPairs,
double &         unbddVol)
{
WitSelCandDblStack theAbsSplitPairs (myProblem ());
WitSelCand *       theSelCand;
double             splitVol;
WitPeriod          expPer;
WitFixedPer *      theFixedPer;

witAssert (selIsSplit (thePart, fillPer));

myBaPt (thePart, fillPer)->
mySplitPt ()->
defineSplit (reqVol, theAbsSplitPairs, unbddVol);

theSplitPairs.clear ();

while (theAbsSplitPairs.pop (theSelCand, splitVol))
{
theSelCand->getBaData (expPer);

theFixedPer = mySelector ()->myFixedPer ()[expPer];

theSplitPairs.push (theFixedPer, splitVol);
}
}
d276 2
a277 2
{
WitBaPt * theBaPt;
d279 1
a279 1
witAssert (selSplit ());
d281 2
a282 2
if (thePart == mySelector ()->myHeurAtor ()->topPart ())
return;
d284 1
a284 1
theBaPt = myBaPt (thePart, fillPer);
d286 3
a288 3
if (theBaPt != NULL)
theBaPt->recordFlowSS (expVol);
}
d293 9
a301 9
{
WitBaMat * theBaMat;
WitPeriod  expPer;

witAssert (selSplit ());

while (pairsToReject_.pop (theBaMat, expPer))
theBaMat->reject (expPer);
}
d306 2
a307 2
{
witAssert (selSplit ());
d309 1
a309 1
witAssert (mySelector ()->splitCommActive ());
d311 2
a312 2
pairsToReject_.push (theBaMat, expPer);
}
d317 7
a323 7
WitBopEntry * theBopEnt,
WitConsEntry *,
WitPeriod,
WitPeriod     fillPer)
{
return myAltPtFor (theBopEnt->myPart (), fillPer);
}
d328 3
a330 3
{
WitBaMat * theBaMat;
WitPeriod  expPer;
d332 1
a332 1
expPer = selExpPer (thePart, fillPer, theBaMat);
d334 2
a335 2
if (expPer < 0)
return NULL;
d337 2
a338 2
return theBaMat->myBaPt ()[fillPer]->myDetAltPt ();
}
d343 3
a345 3
{
return true;
}
d350 3
a352 3
{
return true;
}
d357 3
a359 3
{
return true;
}
d364 3
a366 3
{
return "Build-Ahead";
}
d371 5
a375 5
WitPart *    thePart,
WitPeriod    fillPer,
WitBaMat * & theBaMat)
{
WitMaterial * theMat;
d377 1
a377 1
theMat = thePart->thisMat ();
d379 2
a380 2
if (theMat == NULL)
return -1;
d382 1
a382 1
theBaMat = myBaMatFor_ (theMat);
d384 2
a385 2
if (theBaMat == NULL)
return -1;
d387 2
a388 2
return theBaMat->myBaPt ()[fillPer]->selExpPer ();
}
d393 3
a395 3
{
WitMaterial * theMat;
WitBaMat *    theBaMat;
d397 1
a397 1
theMat = thePart->thisMat ();
d399 2
a400 2
if (theMat == NULL)
return NULL;
d402 1
a402 1
theBaMat = myBaMatFor_ (theMat);
d404 2
a405 2
if (theBaMat == NULL)
return NULL;
d407 2
a408 2
return theBaMat->myBaPt ()[fillPer];
}
d415 2
a416 2
{
}
d422 4
a425 4
WitProbAssoc (theBaMgr),
myBaMgr_     (theBaMgr)
{
}
d432 3
a434 3
WitBaDir (theBaMgr)
{
}
d439 2
a440 2
{
}
d445 8
a452 8
WitMaterial *,
WitTVec <WitPeriod> & expPerVec)
{
WitPeriod fillPer;

forEachPeriod (fillPer, myProblem ())
expPerVec[fillPer] = fillPer;
}
d457 3
a459 3
{
return fillPer;
}
d464 10
a473 10
WitMaterial * theMat,
WitPeriod     fillPer,
WitPeriod &   expPer)
{
expPer --;

if (expPer >= 0)
if (expPer >= fillPer - theMat->buildAheadUB ()[fillPer])
if (not theMat->mandEC ()[expPer])
return;
d475 2
a476 2
expPer = -1;
}
d483 3
a485 3
WitBaDir (theBaMgr)
{
}
d490 2
a491 2
{
}
d496 17
a512 17
WitMaterial *         theMat,
WitTVec <WitPeriod> & expPerVec)
{
WitPeriod fillPer;
WitPeriod firstStockPer;

firstStockPer = 0;

forEachPeriod (fillPer, myProblem ())
{
expPerVec[fillPer] =
max (firstStockPer, fillPer - theMat->buildAheadUB ()[fillPer]);

if (theMat->mandEC ()[fillPer])
firstStockPer = fillPer + 1;
}
}
d517 2
a518 2
{
WitPeriod expPer;
d520 17
a536 17
if (theMat->mandEC () == false)
{
return max (0, fillPer - theMat->buildAheadUB ()[fillPer]);
}

for (expPer = fillPer; ; expPer --)
{
if (expPer == 0)
return expPer;

if (expPer == fillPer - theMat->buildAheadUB ()[fillPer])
return expPer;

if (theMat->mandEC ()[expPer - 1])
return expPer;
}
}
d541 9
a549 9
WitMaterial *,
WitPeriod     fillPer,
WitPeriod &   expPer)
{
expPer ++;

if (expPer > fillPer)
expPer = -1;
}
d556 12
a567 12
WitMaterial * theMat,
WitBaDir *    theBaDir,
WitBaMgr *    theBaMgr):

WitProbAssoc (theMat),
myMaterial_  (theMat),
myBaDir_     (theBaDir),
myBaMgr_     (theBaMgr),
myBaPt_      (myProblem ()),
useable_     (myProblem (), true)
{
WitPeriod fillPer;
d569 2
a570 2
forEachPeriod (fillPer, myProblem ())
myBaPt_[fillPer] = new WitBaPt (this, fillPer);
d572 1
a572 1
WitBaPt::setInitSelExpPers (this);
d574 2
a575 2
rejectUnexplodablePers ();
}
d580 3
a582 3
{
deleteContents (myBaPt_);
}
d587 3
a589 3
{
myBaDir_->findInitExpPers (myMaterial_, expPerVec);
}
d594 3
a596 3
{
if (not useable_[expPer])
return;
d598 2
a599 2
if (myBaMgr_->mySelector ()->sglSrc ())
myBaMgr_->mySelector ()->mySglSrcMgr ()->saveConfigVal (useable_[expPer]);
d601 1
a601 1
useable_[expPer] = false;
d603 2
a604 2
deselect (expPer);
}
d609 2
a610 8
{
WitPeriod expPer;

expPer = myBaPt_[fillPer]->selExpPer ();

while (true)
{
myBaDir_->advanceExpPer (myMaterial_, fillPer, expPer);
d612 1
a612 2
if (expPer < 0)
return -1;
d614 15
a628 8
if (useable_[expPer])
return expPer;
}

return -1;
//
// Avoids a compiler warning.
}
d633 3
a635 3
{
return myBaDir_->findInitExpPer (myMaterial_, fillPer);
}
d640 32
a671 32
{
WitPeriod fillPer;
WitPeriod expPer;

fprintf (msgFile (),
"\n"
"Build-Ahead Material %s:\n\n"
"    Exp Per   Useable?\n",
myMaterial_->partName ().myCstring ());

forEachPeriod (expPer, myProblem ())
fprintf (msgFile (),
"    %7d   %7s\n",
expPer,
myMsgFac ().boolText (useable_[expPer]));

fprintf (msgFile (),
"\n"
"   Fill Per   Exp Per\n");

forEachPeriod (fillPer, myProblem ())
{
fprintf (msgFile (), "   %8d", fillPer);

expPer = myBaPt ()[fillPer]->selExpPer ();

if (expPer >= 0)
fprintf (msgFile (), "   %7d\n", expPer);
else
fprintf (msgFile (), "         *\n");
}
}
d676 2
a677 2
{
useable_ = true;
d679 1
a679 1
WitBaPt::setInitSelExpPers (this);
d681 1
a681 1
rejectUnexplodablePers ();
d683 3
a685 3
if (selPrintLevelAt (3))
printRecovery ();
}
d690 2
a691 2
{
WitPeriod expPer;
d693 8
a700 8
forEachPeriod (expPer, myProblem ())
if (not myMaterial_->explodeable (expPer))
{
useable_[expPer] = false;

deselect (expPer);
}
}
d705 2
a706 2
{
WitPeriod fillPer;
d708 4
a711 4
for (fillPer = expPer; fillPer < nPeriods (); fillPer ++)
if (myBaPt_[fillPer]->selExpPer () == expPer)
myBaPt_[fillPer]->advanceSel ();
}
d716 5
a720 5
{
fprintf (msgFile (),
"   Initial build-ahead configuration recovered for part %s.\n\n",
myMaterial_->partName ().myCstring ());
}
d728 1
a728 1
WitDetSelPt (),
d730 5
a734 5
myBaMat_    (theBaMat),
myFillPer_  (fillPer),
selExpPer_  (-1)
{
}
d739 2
a740 2
{
}
d745 11
a755 11
{
WitTVec <WitPeriod> expPerVec (theBaMat->myProblem (), -1);
WitPeriod           fillPer;

theBaMat->findInitExpPers (expPerVec);

forEachPeriod (fillPer, theBaMat->myProblem ())
{
theBaMat->myBaPt ()[fillPer]->selExpPer_ = expPerVec[fillPer];
}
}
d760 3
a762 3
{
select (myBaMat_->nextUseableExpPer (myFillPer_));
}
d767 3
a769 3
{
if (mySelMgr ()->mySelector ()->sglSrc ())
mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (selExpPer_);
d771 2
a772 2
selExpPer_ = expPer;
}
d777 3
a779 3
{
return myBaMat_->myBaMgr ();
}
d784 7
a790 7
{
fprintf (myBaMat_->myBaMgr ()->msgFile (),
"   Part:             %s\n"
"   Fill Per:         %d\n",
myBaMat_->myMaterial ()->partName ().myCstring (),
myFillPer_);
}
d795 3
a797 3
{
if (myBaMat_->myBaMgr ()->myGlobalComp ()->selSplit ())
return true;
d799 2
a800 2
if (myBaMat_->myBaMgr ()->myGlobalComp ()->nonMrSelSplit ())
return true;
d802 2
a803 2
return myBaMat_->myMaterial ()->baSelSplit ();
}
d808 4
a811 4
{
thePart = myBaMat_->myMaterial ();
thePer  = myFillPer_;
}
d816 3
a818 3
{
return new WitBaCand (selExpPer_, myBaMat_->myProblem ());
}
d823 2
a824 2
{
WitPeriod expPer;
d826 1
a826 1
expPer = myBaMat_->nextUseableExpPer (myFillPer_);
d828 2
a829 2
return (expPer >= 0);
}
d834 2
a835 2
{
WitBaMgr * theBaMgr;
d837 1
a837 1
witAssert (selExpPer_ >= 0);
d839 1
a839 1
theBaMgr = myBaMat_->myBaMgr ();
d841 9
a849 9
if (theBaMgr->selSplit () and theBaMgr->mySelector ()->splitCommActive ())
{
theBaMgr->deferRejection (myBaMat_, selExpPer_);

advanceSel ();
}
else
myBaMat_->reject (selExpPer_);
}
d854 3
a856 3
{
myBaMat_->myBaMgr ()->storeRecoveryPt (myBaMat_);
}
d861 2
a862 2
{
myBaMat_->myBaMgr ()->saveExpPer (selExpPer_);
d864 2
a865 2
advanceSel ();
}
d870 2
a871 2
{
WitPeriod expPer;
d873 1
a873 1
myBaMat_->myBaMgr ()->retrieveExpPer (expPer);
d875 2
a876 2
select (expPer);
}
d881 3
a883 3
{
myBaMat_->print ();
}
d891 4
a894 4
WitSelCand (theProblem),
myExpPer_  (expPer)
{
}
d899 2
a900 2
{
}
d905 3
a907 3
{
fprintf (msgFile (), "      Exp Period:    %d\n", myExpPer_);
}
d912 3
a914 3
{
expPer = myExpPer_;
}
@


1.136
log
@Selection Recovery
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d45 1
a45 1
      WitSelMgr       (theSelector),
d47 45
a91 45
      myBaDirForNstn_ (NULL),
      myBaDirForAsap_ (NULL),
      myBaMatFor_     (myProblem ()),
      pairsToReject_  (myProblem ()),
      savedExpPer_    (-1),
      alteredBaMats_  (myProblem ()),
      baAlteredAt_    ()
   {
   bool          nstnMatExists;
   bool          asapMatExists;
   WitMaterial * theMat;

   myBaDirForNstn_ = new WitNstnBaDir (this);
   myBaDirForAsap_ = new WitAsapBaDir (this);

   nstnMatExists   = false;
   asapMatExists   = false;

   forEachMaterial (theMat, myProblem ())
      if (not theMat->producingBopEntries ().isEmpty ())
         {
         if      (theMat->nstnBaNeeded ())
            {
            myBaMatFor_ (theMat) = new WitBaMat (theMat, myBaDirForNstn_, this);

            nstnMatExists        = true;
            }

         else if (theMat->buildAsap ())
            {
            myBaMatFor_ (theMat) = new WitBaMat (theMat, myBaDirForAsap_, this);

            asapMatExists        = true;
            }
         }

   if (myGlobalComp ()->selectionRecovery ())
      baAlteredAt_.allocate (myProblem (), false);

   if (nstnMatExists)
      myMsgFac () ("nstnMsg");

   if (asapMatExists)
      myMsgFac () ("asapMsg");
   }
d96 2
a97 2
   {
   WitMaterial * theMat;
d99 2
a100 2
   forEachMaterial (theMat, myProblem ())
      delete myBaMatFor_ (theMat);
d102 3
a104 3
   delete myBaDirForAsap_;
   delete myBaDirForNstn_;
   }
d109 2
a110 2
   {
   WitMaterial * theMat;
d112 3
a114 3
   forEachMaterial (theMat, theProblem)
      if (theMat->nstnBaNeeded () or theMat->buildAsap ())
         return true;
d116 2
a117 2
   return false;
   }
d122 11
a132 11
   {
   WitBaMat * theBaMat;
   WitPeriod  expPer;

   expPer = selExpPer (thePart, fillPer, theBaMat);

   return 
      (expPer >= 0)?
         expPer:
         thePart->explosionPeriod (fillPer);
   }
d137 16
a152 16
   {
   WitMaterial * theMat;
   WitBaMat *    theBaMat;

   fprintf (msgFile (),
      "\n"
      "Build-Ahead Period Selections:\n");

   forEachMaterial (theMat, myProblem ())
      {
      theBaMat = myBaMatFor_ (theMat);

      if (theBaMat != NULL)
         theBaMat->print ();
      }
   }
d157 3
a159 3
   {
   witAssert (savedExpPer_ == -1);
   witAssert (expPer       != -1);
d161 2
a162 2
   savedExpPer_ = expPer;
   }
d167 2
a168 2
   {
   witAssert (savedExpPer_ != -1);
d170 3
a172 3
   expPer       = savedExpPer_;
   savedExpPer_ = -1;
   }
d177 2
a178 2
   {
   witAssert (myGlobalComp ()->selectionRecovery ());
d180 2
a181 2
   if (baAlteredAt_ (theBaMat->myMaterial ()))
      return;
d183 1
a183 1
   baAlteredAt_ (theBaMat->myMaterial ()) = true;
d185 2
a186 2
   alteredBaMats_.push (theBaMat);
   }
d191 2
a192 2
   {
   WitBaMat * theBaMat;
d194 8
a201 8
   while (alteredBaMats_.pop (theBaMat))
      if (baAlteredAt_ (theBaMat->myMaterial ()))
         {
         theBaMat->recoverInitState ();

         baAlteredAt_ (theBaMat->myMaterial ()) = false;
         }
   }
d206 2
a207 2
   {
   WitMaterial * theMat;
d209 2
a210 2
   if (myGlobalComp ()->selSplit ())
      return true;
d212 2
a213 2
   if (myGlobalComp ()->nonMrSelSplit ())
      return true;
d215 4
a218 4
   forEachMaterial (theMat, myProblem ())
      if (theMat->nstnBaNeeded () or theMat->buildAsap ())
         if (theMat->baSelSplit ())
            return true;
d220 2
a221 2
   return false;
   }
d226 2
a227 2
   {
   WitBaPt * theBaPt;
d229 2
a230 2
   if (not selSplit ())
      return false;
d232 1
a232 1
   theBaPt = myBaPt (thePart, fillPer);
d234 2
a235 2
   if (theBaPt == NULL)
      return false;
d237 2
a238 2
   return theBaPt->isSplit ();
   }
d243 29
a271 29
      WitPart *        thePart,
      WitPeriod        fillPer,
      double           reqVol,
      WitPerDblStack & theSplitPairs,
      double &         unbddVol)
   {
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitPeriod          expPer;
   WitFixedPer *      theFixedPer;

   witAssert (selIsSplit (thePart, fillPer));

   myBaPt (thePart, fillPer)->
      mySplitPt ()->
         defineSplit (reqVol, theAbsSplitPairs, unbddVol);

   theSplitPairs.clear ();

   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      theSelCand->getBaData (expPer);

      theFixedPer = mySelector ()->myFixedPer ()[expPer];

      theSplitPairs.push (theFixedPer, splitVol);
      }
   }
d276 2
a277 2
   {
   WitBaPt * theBaPt;
d279 1
a279 1
   witAssert (selSplit ());
d281 2
a282 2
   if (thePart == mySelector ()->myHeurAtor ()->topPart ())
      return;
d284 1
a284 1
   theBaPt = myBaPt (thePart, fillPer);
d286 3
a288 3
   if (theBaPt != NULL)
      theBaPt->recordFlowSS (expVol);
   }
d293 9
a301 9
   {
   WitBaMat * theBaMat;
   WitPeriod  expPer;

   witAssert (selSplit ());

   while (pairsToReject_.pop (theBaMat, expPer))
      theBaMat->reject (expPer);
   }
d306 2
a307 2
   {
   witAssert (selSplit ());
d309 1
a309 1
   witAssert (mySelector ()->splitCommActive ());
d311 2
a312 2
   pairsToReject_.push (theBaMat, expPer);
   }
d317 7
a323 7
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod,
      WitPeriod     fillPer)
   {
   return myAltPtFor (theBopEnt->myPart (), fillPer);
   }
d328 3
a330 3
   {
   WitBaMat * theBaMat;
   WitPeriod  expPer;
d332 1
a332 1
   expPer = selExpPer (thePart, fillPer, theBaMat);
d334 2
a335 2
   if (expPer < 0)
      return NULL;
d337 2
a338 2
   return theBaMat->myBaPt ()[fillPer]->myDetAltPt ();
   }
d343 3
a345 3
   {
   return true;
   }
d350 3
a352 3
   {
   return true;
   }
d357 3
a359 3
   {
   return true;
   }
d364 3
a366 3
   {
   return "Build-Ahead";
   }
d371 5
a375 5
      WitPart *    thePart, 
      WitPeriod    fillPer,
      WitBaMat * & theBaMat)
   {
   WitMaterial * theMat;
d377 1
a377 1
   theMat = thePart->thisMat ();
d379 2
a380 2
   if (theMat == NULL)
      return -1;
d382 1
a382 1
   theBaMat = myBaMatFor_ (theMat);
d384 2
a385 2
   if (theBaMat == NULL)
      return -1;
d387 2
a388 2
   return theBaMat->myBaPt ()[fillPer]->selExpPer ();
   }
d393 3
a395 3
   {
   WitMaterial * theMat;
   WitBaMat *    theBaMat;
d397 1
a397 1
   theMat = thePart->thisMat ();
d399 2
a400 2
   if (theMat == NULL)
      return NULL;
d402 1
a402 1
   theBaMat = myBaMatFor_ (theMat);
d404 2
a405 2
   if (theBaMat == NULL)
      return NULL;
d407 2
a408 2
   return theBaMat->myBaPt ()[fillPer];
   }
d415 2
a416 2
   {
   }
d422 4
a425 4
      WitProbAssoc (theBaMgr),
      myBaMgr_     (theBaMgr)
   {
   }
d432 3
a434 3
      WitBaDir (theBaMgr)
   {
   }
d439 2
a440 2
   {
   }
d445 8
a452 8
      WitMaterial *,
      WitTVec <WitPeriod> & expPerVec)
   {
   WitPeriod fillPer;

   forEachPeriod (fillPer, myProblem ())
      expPerVec[fillPer] = fillPer;
   }
d457 3
a459 3
   {
   return fillPer;
   }
d464 10
a473 10
      WitMaterial * theMat,
      WitPeriod     fillPer, 
      WitPeriod &   expPer)
   {
   expPer --;

   if (expPer >= 0) 
      if (expPer >= fillPer - theMat->buildAheadUB ()[fillPer])
         if (not theMat->mandEC ()[expPer])
            return;
d475 2
a476 2
   expPer = -1;
   }
d483 3
a485 3
      WitBaDir (theBaMgr)
   {
   }
d490 2
a491 2
   {
   }
d496 17
a512 17
      WitMaterial *         theMat,
      WitTVec <WitPeriod> & expPerVec)
   {
   WitPeriod fillPer;
   WitPeriod firstStockPer;

   firstStockPer = 0;

   forEachPeriod (fillPer, myProblem ())
      {
      expPerVec[fillPer] =
         max (firstStockPer, fillPer - theMat->buildAheadUB ()[fillPer]);

      if (theMat->mandEC ()[fillPer])
         firstStockPer = fillPer + 1;
      }
   }
d517 2
a518 2
   {
   WitPeriod expPer;
d520 17
a536 17
   if (theMat->mandEC () == false)
      {
      return max (0, fillPer - theMat->buildAheadUB ()[fillPer]);
      }

   for (expPer = fillPer; ; expPer --)
      {
      if (expPer == 0)
         return expPer;

      if (expPer == fillPer - theMat->buildAheadUB ()[fillPer])
         return expPer;
      
      if (theMat->mandEC ()[expPer - 1])
         return expPer;
      }
   }
d541 9
a549 9
      WitMaterial *,
      WitPeriod     fillPer, 
      WitPeriod &   expPer)
   {
   expPer ++;

   if (expPer > fillPer)
      expPer = -1;
   }
d556 12
a567 12
         WitMaterial * theMat, 
         WitBaDir *    theBaDir, 
         WitBaMgr *    theBaMgr):

      WitProbAssoc (theMat),
      myMaterial_  (theMat),
      myBaDir_     (theBaDir),
      myBaMgr_     (theBaMgr),
      myBaPt_      (myProblem ()),
      useable_     (myProblem (), true)
   {
   WitPeriod fillPer;
d569 2
a570 2
   forEachPeriod (fillPer, myProblem ())
      myBaPt_[fillPer] = new WitBaPt (this, fillPer);
d572 1
a572 1
   WitBaPt::setInitSelExpPers (this);
d574 2
a575 2
   rejectUnexplodablePers ();
   }
d580 3
a582 3
   {
   deleteContents (myBaPt_);
   }
d587 3
a589 3
   {
   myBaDir_->findInitExpPers (myMaterial_, expPerVec);
   }
d594 3
a596 3
   {
   if (not useable_[expPer])
      return;
d598 2
a599 2
   if (myBaMgr_->mySelector ()->sglSrc ())
      myBaMgr_->mySelector ()->mySglSrcMgr ()->saveConfigVal (useable_[expPer]);
d601 1
a601 1
   useable_[expPer] = false;
d603 2
a604 2
   deselect (expPer);
   }
d609 8
a616 2
   {
   WitPeriod expPer;
d618 2
a619 1
   expPer = myBaPt_[fillPer]->selExpPer ();
d621 8
a628 15
   while (true)
      {
      myBaDir_->advanceExpPer (myMaterial_, fillPer, expPer);

      if (expPer < 0)
         return -1;

      if (useable_[expPer])
         return expPer;
      }

   return -1; 
      //                       
      // Avoids a compiler warning.
   }
d633 3
a635 3
   {
   return myBaDir_->findInitExpPer (myMaterial_, fillPer);
   }
d640 32
a671 32
   {
   WitPeriod fillPer;
   WitPeriod expPer;

   fprintf (msgFile (),
      "\n"
      "Build-Ahead Material %s:\n\n"
      "    Exp Per   Useable?\n",
      myMaterial_->partName ().myCstring ());

   forEachPeriod (expPer, myProblem ())
      fprintf (msgFile (), 
         "    %7d   %7s\n",
         expPer,
         myMsgFac ().boolText (useable_[expPer]));
   
   fprintf (msgFile (), 
      "\n"
      "   Fill Per   Exp Per\n");

   forEachPeriod (fillPer, myProblem ())
      {
      fprintf (msgFile (), "   %8d", fillPer);

      expPer = myBaPt ()[fillPer]->selExpPer ();

      if (expPer >= 0)
         fprintf (msgFile (), "   %7d\n", expPer);
      else
         fprintf (msgFile (), "         *\n");
      }
   }
d676 2
a677 2
   {
   useable_ = true;
d679 1
a679 1
   WitBaPt::setInitSelExpPers (this);
d681 1
a681 1
   rejectUnexplodablePers ();
d683 3
a685 3
   if (selPrintLevelAt (3))
      printRecovery ();
   }
d690 2
a691 2
   {
   WitPeriod expPer;
d693 8
a700 8
   forEachPeriod (expPer, myProblem ())
      if (not myMaterial_->explodeable (expPer))
         {
         useable_[expPer] = false;

         deselect (expPer);
         }
   }
d705 2
a706 2
   {
   WitPeriod fillPer;
d708 4
a711 4
   for (fillPer = expPer; fillPer < nPeriods (); fillPer ++)
      if (myBaPt_[fillPer]->selExpPer () == expPer)
          myBaPt_[fillPer]->advanceSel ();
   }
d716 5
a720 5
   {
   fprintf (msgFile (),
      "   Initial build-ahead configuration recovered for part %s.\n\n",
      myMaterial_->partName ().myCstring ());
   }
d728 1
a728 1
      WitDetSelPt (),
d730 5
a734 5
      myBaMat_    (theBaMat),
      myFillPer_  (fillPer),
      selExpPer_  (-1)
   {
   }
d739 2
a740 2
   {
   }
d745 11
a755 11
   {
   WitTVec <WitPeriod> expPerVec (theBaMat->myProblem (), -1);
   WitPeriod           fillPer;

   theBaMat->findInitExpPers (expPerVec);

   forEachPeriod (fillPer, theBaMat->myProblem ())
      {
      theBaMat->myBaPt ()[fillPer]->selExpPer_ = expPerVec[fillPer];
      }
   }
d760 3
a762 3
   {
   select (myBaMat_->nextUseableExpPer (myFillPer_));
   }
d767 3
a769 3
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (selExpPer_);
d771 2
a772 2
   selExpPer_ = expPer;
   }
d777 3
a779 3
   {
   return myBaMat_->myBaMgr ();
   }
d784 7
a790 7
   {
   fprintf (myBaMat_->myBaMgr ()->msgFile (),
      "   Part:             %s\n"
      "   Fill Per:         %d\n",
      myBaMat_->myMaterial ()->partName ().myCstring (),
      myFillPer_);
   }
d795 3
a797 3
   {
   if (myBaMat_->myBaMgr ()->myGlobalComp ()->selSplit ())
      return true;
d799 2
a800 2
   if (myBaMat_->myBaMgr ()->myGlobalComp ()->nonMrSelSplit ())
      return true;
d802 2
a803 2
   return myBaMat_->myMaterial ()->baSelSplit ();
   }
d808 4
a811 4
   {
   thePart = myBaMat_->myMaterial ();
   thePer  = myFillPer_;
   }
d816 3
a818 3
   {
   return new WitBaCand (selExpPer_, myBaMat_->myProblem ());
   }
d823 2
a824 2
   {
   WitPeriod expPer;
d826 1
a826 1
   expPer = myBaMat_->nextUseableExpPer (myFillPer_);
d828 2
a829 2
   return (expPer >= 0);
   }
d834 2
a835 2
   {
   WitBaMgr * theBaMgr;
d837 1
a837 1
   witAssert (selExpPer_ >= 0);
d839 1
a839 1
   theBaMgr = myBaMat_->myBaMgr ();
d841 9
a849 9
   if (theBaMgr->selSplit () and theBaMgr->mySelector ()->splitCommActive ())
      {
      theBaMgr->deferRejection (myBaMat_, selExpPer_);

      advanceSel ();
      }
   else
      myBaMat_->reject (selExpPer_);
   }
d854 3
a856 3
   {
   myBaMat_->myBaMgr ()->storeRecoveryPt (myBaMat_);
   }
d861 2
a862 2
   {
   myBaMat_->myBaMgr ()->saveExpPer (selExpPer_);
d864 2
a865 2
   advanceSel ();
   }
d870 2
a871 2
   {
   WitPeriod expPer;
d873 1
a873 1
   myBaMat_->myBaMgr ()->retrieveExpPer (expPer);
d875 2
a876 2
   select (expPer);
   }
d881 3
a883 3
   {
   myBaMat_->print ();
   }
d891 4
a894 4
      WitSelCand (theProblem),
      myExpPer_  (expPer)
   {
   }
d899 2
a900 2
   {
   }
d905 3
a907 3
   {
   fprintf (msgFile (), "      Exp Period:    %d\n", myExpPer_);
   }
d912 3
a914 3
   {
   expPer = myExpPer_;
   }
@


1.135
log
@Selection Recovery
@
text
@d176 1
a176 1
void WitBaMgr::recAltForRecovery (WitBaMat * theBaMat)
d190 1
a190 1
void WitBaMgr::recoverSelections ()
d718 1
a718 1
      "   Initial build-ahead selections recovered for part %s.\n\n",
d853 1
a853 1
void WitBaPt::recAltForRecovery ()
d855 1
a855 1
   myBaMat_->myBaMgr ()->recAltForRecovery (myBaMat_);
@


1.134
log
@Selection Recovery
@
text
@d176 1
a176 1
void WitBaMgr::recordAlteration (WitBaMat * theBaMat)
d853 1
a853 1
void WitBaPt::recordAlteration ()
d855 1
a855 1
   myBaMat_->myBaMgr ()->recordAlteration (myBaMat_);
@


1.133
log
@Selection Recovery
@
text
@a61 3
   if (myGlobalComp ()->selectionRecovery ())
      baAlteredAt_.allocate (myProblem (), false);

d83 3
@


1.132
log
@Selection Recovery.
@
text
@a603 3

   if (myGlobalComp ()->selectionRecovery ())
      myBaMgr_->recordAlteration (this);
a771 3

   if (mySelMgr ()->myGlobalComp ()->selectionRecovery ())
      myBaMat_->myBaMgr ()->recordAlteration (myBaMat_);
d853 7
@


1.131
log
@Selection Recovery.
@
text
@d190 15
a369 15
void WitBaMgr::recoverSelections ()
   {
   WitBaMat * theBaMat;

   while (alteredBaMats_.pop (theBaMat))
      if (baAlteredAt_ (theBaMat->myMaterial ()))
         {
         theBaMat->recoverInitState ();

         baAlteredAt_ (theBaMat->myMaterial ()) = false;
         }
   }

//------------------------------------------------------------------------------

@


1.130
log
@Selection Recovery
@
text
@a363 3
         if (selPrintLevelAt (3))
            theBaMat->printRecovery ();

a684 1
   }
d686 2
a687 7
//------------------------------------------------------------------------------

void WitBaMat::printRecovery ()
   {
   fprintf (msgFile (),
      "   Initial build-ahead selections recovered for part %s.\n\n",
      myMaterial_->partName ().myCstring ());
d717 9
@


1.129
log
@Re-implemented selection recovery for build-ahead.
@
text
@d355 1
a355 1
void WitBaMgr::specSelRecovery ()
a827 14
void WitBaPt::printRecovery ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitBaPt::recoverInitSel ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

@


1.128
log
@Selection Recovery.
@
text
@d52 2
a53 1
      rejectedPairs_  (myProblem ())
d62 3
d176 14
a300 10
void WitBaMgr::recRejection (WitBaMat * theBaMat, WitPeriod expPer)
   {
   witAssert (    myGlobalComp ()->selectionRecovery ());
   witAssert (not myGlobalComp ()->newSelRec         ());

   rejectedPairs_.push (theBaMat, expPer);
   }

//------------------------------------------------------------------------------

a357 1
   WitPeriod  expPer;
d359 2
a360 3
   if (not myGlobalComp ()->newSelRec ())
      {
      while (rejectedPairs_.pop (theBaMat, expPer))
d362 2
d365 1
a365 1
            theBaMat->prtRecover (expPer);
d367 1
a367 1
         theBaMat->recover (expPer);
a368 1
      }
a570 1
   WitPeriod expPer;
d572 2
a573 3
   WitTVec <WitPeriod> expPerVec (myProblem (), -1);

   myBaDir_->findInitExpPers (myMaterial_, expPerVec);
d575 1
a575 2
   forEachPeriod (fillPer, myProblem ())
      myBaPt_[fillPer] = new WitBaPt (this, fillPer, expPerVec[fillPer]);
d577 1
a577 3
   forEachPeriod (expPer, myProblem ())
      if (not myMaterial_->explodeable (expPer))
         reject (expPer);
d589 7
a597 2
   WitPeriod fillPer;

d606 1
a606 3
   for (fillPer = expPer; fillPer < nPeriods (); fillPer ++)
      if (myBaPt_[fillPer]->selExpPer () == expPer)
          myBaPt_[fillPer]->advanceSel ();
d609 1
a609 2
      if (not myGlobalComp ()->newSelRec ())
         myBaMgr_->recRejection (this, expPer);
d681 1
a681 1
void WitBaMat::recover (WitPeriod expPer)
d683 3
a685 1
   witAssert (not myGlobalComp ()->newSelRec ());
d687 1
a687 1
   useable_[expPer] = true;
d692 1
a692 1
void WitBaMat::prtRecover (WitPeriod expPer)
d694 19
a712 1
   witAssert (not myGlobalComp ()->newSelRec ());
d714 5
a718 2
   if (useable_[expPer])
      return;
d720 3
a722 6
   fprintf (msgFile (),
      "   Explosion Period Recovered:\n"
      "      Part:     %s\n"
      "      Exp  Per: %d\n\n",
      myMaterial_->partName ().myCstring (),
      expPer);
d729 1
a729 1
WitBaPt::WitBaPt (WitBaMat * theBaMat, WitPeriod fillPer, WitPeriod expPer):
d735 1
a735 1
      selExpPer_  (expPer)
d747 15
d777 1
a777 2
      if (not mySelMgr ()->myGlobalComp ()->newSelRec ())
         recAlteration ();
d830 1
a830 17
   WitPeriod initExpPer;

   witAssert (not myBaMat_->myGlobalComp ()->newSelRec ());

   initExpPer = myBaMat_->findInitExpPer (myFillPer_);

   if (selExpPer_ == initExpPer)
      return;

   fprintf (myBaMat_->msgFile (),
      "   Initial Build-Ahead Selection Recovered:\n"
      "      Part:     %s\n"
      "      Fill Per: %d\n"
      "      Exp  Per: %d\n\n",
      myBaMat_->myMaterial ()->partName ().myCstring (),
      myFillPer_,
      initExpPer);
d837 1
a837 3
   witAssert (not myBaMat_->myGlobalComp ()->newSelRec ());

   selExpPer_ = myBaMat_->findInitExpPer (myFillPer_);
@


1.127
log
@Selection Recovery.
@
text
@d285 2
a286 1
   witAssert (myGlobalComp ()->selectionRecovery ());
d352 1
a352 1
   while (rejectedPairs_.pop (theBaMat, expPer))
d354 4
a357 2
      if (selPrintLevelAt (3))
         theBaMat->prtRecover (expPer);
d359 2
a360 1
      theBaMat->recover (expPer);
d604 2
a605 1
      myBaMgr_->recRejection (this, expPer);
d679 2
d688 2
d738 2
a739 1
      recAlteration ();
d794 2
d815 2
@


1.126
log
@Selection recovery.
@
text
@d780 1
a780 8
void WitBaPt::recoverInitSel ()
   {
   selExpPer_ = myBaMat_->findInitExpPer (myFillPer_);
   }

//------------------------------------------------------------------------------

void WitBaPt::prtRecInitSel ()
d801 7
@


1.125
log
@Name change: "selection reuse" has becomne "selection recovery".
@
text
@d346 1
a346 1
void WitBaMgr::restoreSpecConfig ()
d354 1
a354 1
         theBaMat->prtRestore (expPer);
d356 1
a356 1
      theBaMat->restore (expPer);
d672 1
a672 1
void WitBaMat::restore (WitPeriod expPer)
d679 1
a679 1
void WitBaMat::prtRestore (WitPeriod expPer)
d685 1
a685 1
      "   Explosion Period Restored:\n"
d780 1
a780 1
void WitBaPt::restoreInitSel ()
d787 1
a787 1
void WitBaPt::prtRestInitSel ()
d797 1
a797 1
      "   Initial Build-Ahead Selection Restored:\n"
@


1.124
log
@Selection reuse.
@
text
@d285 1
a285 1
   witAssert (myGlobalComp ()->selectionReuse ());
d599 1
a599 1
   if (myGlobalComp ()->selectionReuse ())
d728 1
a728 1
   if (mySelMgr ()->myGlobalComp ()->selectionReuse ())
@


1.123
log
@Selection Reuse.
@
text
@d353 1
a353 1
      if (myGlobalComp ()->selPrintLevel () >= 3)
@


1.122
log
@Selection Reuse
@
text
@d353 3
d674 2
a675 1
   witAssert (myGlobalComp ()->selectionReuse ());
d677 1
a677 10
   if (myGlobalComp ()->selPrintLevel () >= 3)
      if (not useable_[expPer])
         {
         fprintf (msgFile (),
            "   Explosion Period Restored:\n"
            "      Part:     %s\n"
            "      Exp  Per: %d\n\n",
            myMaterial_->partName ().myCstring (),
            expPer);
         }
d679 11
a689 1
   useable_[expPer] = true;
d729 1
a729 1
      mySelMgr ()->mySelector ()->recAlteredSelPt (this);
d782 7
d796 8
a803 13
   selExpPer_ = initExpPer;

   if (myBaMat_->myGlobalComp ()->selPrintLevel () >= 3)
      {
      fprintf (myBaMat_->msgFile (),
         "   Initial Build-Ahead Selection Restored:\n"
         "      Part:     %s\n"
         "      Fill Per: %d\n"
         "      Exp  Per: %d\n\n",
         myBaMat_->myMaterial ()->partName ().myCstring (),
         myFillPer_,
         selExpPer_);
      }
@


1.121
log
@Selection reuse.
@
text
@d509 5
@


1.120
log
@Selection reuse.
@
text
@a285 1
   witAssert (myGlobalComp ()->newSelReuse    ());
d511 1
a511 1
      if (expPer == 0);
d591 2
a592 5
   if    (myGlobalComp ()->selectionReuse ())
      if (myGlobalComp ()->newSelReuse    ())
         {
         myBaMgr_->recRejection (this, expPer);
         }
a666 1
   witAssert (myGlobalComp ()->newSelReuse    ());
d674 1
a674 1
            "      Exp  Per: %d\n",
d718 2
a719 5
   if    (mySelMgr ()->myGlobalComp ()->selectionReuse ())
      if (mySelMgr ()->myGlobalComp ()->newSelReuse    ())
         {
         mySelMgr ()->mySelector ()->recAlteredSelPt (this);
         }
d787 1
a787 1
         "      Exp  Per: %d\n",
@


1.119
log
@Selection reuse.
@
text
@d51 2
a52 1
      savedExpPer_    (-1)
d283 10
d349 7
d591 6
d667 21
d723 5
a727 1
   mySelMgr ()->mySelector ()->recAlteredSelPt (this);
d789 1
a789 1
   if (myBaMat_->myBaMgr ()->myGlobalComp ()->selPrintLevel () >= 3)
d791 1
a791 1
      fprintf (myBaMat_->myBaMgr ()->msgFile (),
@


1.118
log
@Lead Time Bounds
@
text
@d336 6
d416 1
a416 1
void WitNstnBaDir::findInitSelExpPers (
d428 7
d467 1
a467 1
void WitAsapBaDir::findInitSelExpPers (
d488 19
d539 1
a539 1
   myBaDir_->findInitSelExpPers (myMaterial_, expPerVec);
d601 7
d677 2
d729 26
@


1.117
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d288 7
d298 1
a298 1
   expPer = selExpPer (theBopEnt->myPart (), fillPer, theBaMat);
d322 7
@


1.116
log
@Stochastic Implosion
@
text
@d34 1
a34 1
#include <Global.h>
@


1.115
log
@Updated the copyright date on all source files.
@
text
@a372 1
      WitProbAssoc (theBaMgr->myProblem ()),
d374 1
d481 1
a481 2
      WitProbAssoc (theMat->myProblem ()),

@


1.114
log
@Revised mappingIndex code.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.113
log
@Low-Pri Prop-Rt.
@
text
@a38 1
#include <MapIdxI.h>
@


1.112
log
@Low-Pri Prop-Rt.
@
text
@a629 7
void WitBaPt::printSelection ()
   {
   myBaMat_->print ();
   }

//------------------------------------------------------------------------------

d726 7
@


1.111
log
@Low-Pri Prop-Rt.
@
text
@d51 2
a52 1
      pairsToReject_  (myProblem ())
d152 20
d716 2
d723 1
a723 1
void WitBaPt::cancelTempAlt (WitSelCand * theSelCand)
d727 1
a727 3
   witAssert (theSelCand != NULL);

   theSelCand->getBaData (expPer);
a732 7

bool WitBaPt::cancelNeedsSelCand ()
   {
   return true;
   }

//------------------------------------------------------------------------------
@


1.110
log
@Low-Pri Prop-Rt.
@
text
@a646 11
void WitBaPt::restoreSelTo (WitSelCand * theSelCand)
   {
   WitPeriod expPer;

   theSelCand->getBaData (expPer);

   select (expPer);
   }

//------------------------------------------------------------------------------

d699 20
@


1.109
log
@Low-Pri Prop-Rt.
@
text
@d647 11
d668 1
a668 1
   return new WitBaCand (this);
d713 1
a713 1
WitBaCand::WitBaCand (WitBaPt * theBaPt):
d715 2
a716 3
      WitSelCand (theBaPt->myBaMat ()->myProblem ()),
      myBaPt_    (theBaPt),
      myExpPer_  (theBaPt->selExpPer ())
a734 7
void WitBaCand::restoreSelToThis ()
   {
   myBaPt_->select (myExpPer_);
   }

//------------------------------------------------------------------------------

@


1.108
log
@Low-Pri Prop-Rt.
@
text
@d193 1
a193 1
      bool &           lastUnbdd)
a195 1
   double             unbddVol;
a206 2
   lastUnbdd = (unbddVol > 0.0);

a208 9
   if (lastUnbdd)
      {
      expPer      = selExpPer (thePart, fillPer);

      theFixedPer = mySelector ()->myFixedPer ()[expPer];

      theSplitPairs.push (theFixedPer, unbddVol);
      }

@


1.107
log
@Low-Pri Prop-Rt.
@
text
@a194 1
   WitSplitPt *       theSplitPt;
d196 1
d204 3
a206 1
   theSplitPt = myBaPt (thePart, fillPer)->mySplitPt ();
d208 1
a208 1
   theSplitPt->defineSplit (reqVol, theAbsSplitPairs, lastUnbdd);
d212 9
a736 7
void WitBaCand::updateToCurSel ()
   {
   myExpPer_ = myBaPt_->selExpPer ();
   }

//------------------------------------------------------------------------------

@


1.106
log
@Low-Pri Prop-Rt.
@
text
@d31 1
d277 1
a277 1
   return theBaMat->myBaPt ()[fillPer]->myAltPt ();
a609 11
bool WitBaPt::hasResAlt ()
   {
   WitPeriod expPer;

   expPer = myBaMat_->nextUseableExpPer (myFillPer_);

   return (expPer >= 0);
   }

//------------------------------------------------------------------------------

d663 11
@


1.105
log
@Low-Pri Prop-Rt.
@
text
@d262 1
a262 1
WitSelAlt * WitBaMgr::mySelAltFor (
d276 1
a276 1
   return theBaMat->myBaPt ()[fillPer]->mySelAlt ();
@


1.104
log
@Low-Pri Prop-Rt.
@
text
@a665 7
void WitBaPt::tempAlterSel ()
   {
   advanceSel ();
   }

//------------------------------------------------------------------------------

d692 7
@


1.103
log
@Low-Pri Prop-Rt.
@
text
@d262 1
a262 1
WitSelPt * WitBaMgr::mySelPtForAlt (
d276 1
a276 1
   return theBaMat->myBaPt ()[fillPer];
a619 20
void WitBaPt::alterSelection ()
   {
   WitBaMgr * theBaMgr;

   witAssert (selExpPer_ >= 0);

   theBaMgr = myBaMat_->myBaMgr ();

   if (theBaMgr->selSplit () and theBaMgr->mySelector ()->splitCommActive ())
      {
      theBaMgr->deferRejection (myBaMat_, selExpPer_);

      advanceSel ();
      }
   else
      myBaMat_->reject (selExpPer_);
   }

//------------------------------------------------------------------------------

d679 20
@


1.102
log
@Low-Pri Prop-Rt.
@
text
@d576 1
a576 1
      WitSelPt   (),
d578 3
a580 3
      myBaMat_   (theBaMat),
      myFillPer_ (fillPer),
      selExpPer_ (expPer)
@


1.101
log
@Low-Pri Prop-Rt.
@
text
@d211 1
a211 1
      expPer      = theSelCand->myBaCand ()->myExpPer ();
d739 1
a739 1
WitBaCand * WitBaCand::myBaCand ()
d741 1
a741 1
   return this;
@


1.100
log
@Low-Pri Prop-Rt.
@
text
@a301 7
WitSelCand * WitBaMgr::newSelCand ()
   {
   return new WitBaCand (this);
   }

//------------------------------------------------------------------------------

d693 1
a693 1
void WitBaPt::setToMyCurSel (WitSelCand * theSelCand)
d695 1
a695 1
   theSelCand->setToCurSelOf (this);
d702 1
a702 1
WitBaCand::WitBaCand (WitBaMgr * theBaMgr):
d704 3
a706 3
      WitSelCand (theBaMgr),
      myBaPt_    (NULL),
      myExpPer_  (-1)
d725 1
a725 1
void WitBaCand::restoreSelToThis ()
d727 1
a727 3
   witAssert (active ());

   myBaPt_->select (myExpPer_);
d732 1
a732 1
WitBaCand * WitBaCand::myBaCand ()
d734 1
a734 3
   witAssert (active ());

   return this;
d739 1
a739 1
void WitBaCand::setToCurSelOf (WitBaPt * theBaPt)
d741 1
a741 4
   witAssert (active ());

   myBaPt_   = theBaPt;
   myExpPer_ = theBaPt->selExpPer ();
@


1.99
log
@Low-Pri Prop-Rt.
@
text
@d599 17
a699 7
void WitBaPt::restoreSel (WitSelCand * theSelCand)
   {
   select (theSelCand->myBaCand ()->myExpPer ());
   }

//------------------------------------------------------------------------------

a705 17

void WitBaPt::select (WitPeriod expPer)
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (selExpPer_);

   selExpPer_ = expPer;
   }

//------------------------------------------------------------------------------

void WitBaPt::advanceSel ()
   {
   select (myBaMat_->nextUseableExpPer (myFillPer_));
   }

//------------------------------------------------------------------------------
d712 1
d732 9
d754 1
@


1.98
log
@Low-Pri Prop-Rt.
@
text
@d690 1
a690 1
void WitBaPt::setToCurSel (WitSelCand * theSelCand)
d692 1
a692 1
   theSelCand->myBaCand ()->setToCurSel (this);
d731 1
a731 1
void WitBaCand::setToCurSel (WitBaPt * theBaPt)
d733 1
a733 3
   witAssert (active ());

   myExpPer_ = theBaPt->selExpPer ();
d738 1
a738 1
void WitBaCand::prtID ()
d740 3
a742 1
   fprintf (msgFile (), "      Exp Period:    %d\n", myExpPer_);
d747 1
a747 1
WitBaCand * WitBaCand::myBaCand ()
d751 1
a751 1
   return this;
@


1.97
log
@Low-Pri Prop-Rt.
@
text
@d733 2
d749 2
@


1.96
log
@Low-Pri Prop-Rt.
@
text
@a46 1
      myBaCandFor_    (myProblem ()),
a51 1
   WitPeriod     expPer;
a55 3
   forEachPeriod (expPer, myProblem ())
      myBaCandFor_[expPer] = new WitBaCand (expPer, this);

a97 2

   deleteContents (myBaCandFor_);
d302 7
a654 9
WitSelCand * WitBaPt::curSelCand ()
   {
   witAssert (selExpPer_ >= 0);

   return myBaMat_->myBaMgr ()->myBaCandFor ()[selExpPer_];
   }

//------------------------------------------------------------------------------

d690 7
d716 1
a716 1
WitBaCand::WitBaCand (WitPeriod expPer, WitBaMgr * theBaMgr):
d719 5
d725 1
a725 1
      myExpPer_  (expPer)
d731 1
a731 1
WitBaCand::~WitBaCand ()
d733 1
@


1.95
log
@Low-Pri Prop-Rt.
@
text
@d59 1
a59 1
      myBaCandFor_[expPer] = new WitBaCand (expPer, myProblem ());
d718 1
a718 1
WitBaCand::WitBaCand (WitPeriod expPer, WitProblem * theProblem):
d720 1
a720 1
      WitSelCand (theProblem),
@


1.94
log
@Low-Pri Prop-Rt.
@
text
@d47 1
a47 1
      myBaCand_       (myProblem ()),
d59 1
a59 1
      myBaCand_[expPer] = new WitBaCand (expPer, this);
d104 1
a104 1
   deleteContents (myBaCand_);
a314 1
   WitBaCand *   theBaCand;
d326 1
a326 6
   theBaCand = theBaMat->myBaPt ()[fillPer]->selBaCand ();

   if (theBaCand == NULL)
      return -1;

   return theBaCand->myExpPer ();
d383 1
a383 1
void WitNstnBaDir::findInitSelBaCands (
d385 1
a385 1
      WitPtrTVec <WitBaCand> & selBaCandVec)
d390 1
a390 1
      selBaCandVec[fillPer] = myBaMgr ()->myBaCand ()[fillPer];
d427 3
a429 3
void WitAsapBaDir::findInitSelBaCands (
      WitMaterial *            theMat,
      WitPtrTVec <WitBaCand> & selBaCandVec)
a432 1
   WitPeriod expPer;
d438 2
a439 3
      expPer = max (fillPer - theMat->buildAheadUB ()[fillPer], firstStockPer);

      selBaCandVec[fillPer] = myBaMgr ()->myBaCand ()[expPer];
a445 1

d479 1
a479 1
   WitPtrTVec <WitBaCand> theBaCandVec (myProblem ());
d481 1
a481 1
   myBaDir_->findInitSelBaCands (myMaterial_, theBaCandVec);
d484 1
a484 1
      myBaPt_[fillPer] = new WitBaPt (this, fillPer, theBaCandVec[fillPer]);
d502 1
a502 3
   WitSelector * theSelector;
   WitBaCand *   theBaCand;
   WitPeriod     fillPer;
d507 2
a508 4
   theSelector = myBaMgr_->mySelector ();

   if (theSelector->sglSrc ())
      theSelector->mySglSrcMgr ()->saveConfigVal (useable_[expPer]);
a511 2
   theBaCand        = myBaMgr ()->myBaCand ()[expPer];

d513 1
a513 1
      if (myBaPt_[fillPer]->selBaCand () == theBaCand)
d519 1
a519 3
WitBaCand * WitBaMat::nextUseableBaCand (
      WitPeriod   fillPer, 
      WitBaCand * theBaCand)
d523 1
a523 1
   expPer = theBaCand->myExpPer ();
d530 1
a530 1
         return NULL;
d533 1
a533 1
         return myBaMgr_->myBaCand ()[expPer];
d536 1
a536 1
   return NULL; 
d545 2
a546 3
   WitPeriod   fillPer;
   WitPeriod   expPer;
   WitBaCand * theBaCand;
d568 1
a568 1
      theBaCand = myBaPt ()[fillPer]->selBaCand ();
d570 2
a571 2
      if (theBaCand != NULL)
         fprintf (msgFile (), "   %7d\n", theBaCand->myExpPer ());
d581 1
a581 4
WitBaPt::WitBaPt (
         WitBaMat *  theBaMat,
         WitPeriod   fillPer,
         WitBaCand * theBaCand):
d586 2
a587 1
      myFillPer_ (fillPer)
a588 1
   select (theBaCand);
d601 1
a601 3
   WitBaCand * theBaCand;

   witAssert (selBaCand () != NULL);
d603 1
a603 1
   theBaCand = myBaMat_->nextUseableBaCand (myFillPer_, selBaCand ());
d605 1
a605 1
   return (theBaCand != NULL);
d614 1
a614 1
   witAssert (selBaCand () != NULL);
d620 1
a620 1
      theBaMgr->deferRejection (myBaMat_, selBaCand ()->myExpPer ());
d625 1
a625 1
      myBaMat_->reject (selBaCand ()->myExpPer ());
d657 3
a659 1
   return selSelCand ();
d694 9
a702 2
   if (DEBUG_MODE)
      theSelCand->myBaCand ();
d704 1
a704 1
   select (theSelCand);
d711 1
a711 1
   select (myBaMat_->nextUseableBaCand (myFillPer_, selBaCand ()));
d718 1
a718 1
WitBaCand::WitBaCand (WitPeriod expPer, WitBaMgr * theBaMgr):
d720 1
a720 1
      WitSelCand (theBaMgr->myProblem ()),
d722 1
a722 2
      myExpPer_  (expPer),
      myBaMgr_   (theBaMgr)
@


1.93
log
@Low-Pri Prop-Rt.
@
text
@a15 1
//    BaCand.
d21 1
a136 40
WitSelPt * WitBaMgr::mySelPtForAlt (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod,
      WitPeriod     fillPer)
   {
   WitBaMat * theBaMat;
   WitPeriod  expPer;

   expPer = selExpPer (theBopEnt->myPart (), fillPer, theBaMat);

   if (expPer < 0)
      return NULL;

   return theBaMat->myBaPt ()[fillPer];
   }

//------------------------------------------------------------------------------

bool WitBaMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitBaMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

const char * WitBaMgr::selCaseName ()
   {
   return "Build-Ahead";
   }

//------------------------------------------------------------------------------

d269 40
a355 33
// Implementation of class BaCand.
//------------------------------------------------------------------------------

WitBaCand::WitBaCand (WitPeriod expPer, WitBaMgr * theBaMgr):

      WitSelCand (theBaMgr->myProblem ()),

      myExpPer_  (expPer),
      myBaMgr_   (theBaMgr)
   {
   }

//------------------------------------------------------------------------------

WitBaCand::~WitBaCand ()
   {
   }

//------------------------------------------------------------------------------

void WitBaCand::prtID ()
   {
   fprintf (msgFile (), "      Exp Period:    %d\n", myExpPer_);
   }

//------------------------------------------------------------------------------

WitBaCand * WitBaCand::myBaCand ()
   {
   return this;
   }

//------------------------------------------------------------------------------
d727 33
@


1.92
log
@Minor corrections.
@
text
@d711 7
@


1.91
log
@Removed a bad function overload.
@
text
@d143 2
a144 3
   WitBaMat *  theBaMat;
   WitPeriod   expPer;
   WitBaCand * theBaCand;
d146 1
a146 1
   expPer   = selExpPer (theBopEnt->myPart (), fillPer, theBaMat);
a149 2

   theBaCand = theBaMat->nextUseableBaCand (fillPer, myBaCand_[expPer]);
@


1.90
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d320 1
a320 1
   theMat = thePart->myMat ();
d345 1
a345 1
   theMat = thePart->myMat ();
@


1.89
log
@Added some optional warnings on Linux.
@
text
@a36 1
#include <PtrMapI.h>
d38 1
@


1.88
log
@Continued implementation of proportionate routing.
@
text
@d426 1
a426 1
      WitMaterial *            theMat,
@


1.87
log
@Continued implementation of proportionate routing.
@
text
@a734 7
WitPeriod WitBaPt::myPeriod ()
   {
   return myFillPer_;
   }

//------------------------------------------------------------------------------

@


1.86
log
@Continued implementation of proportionate routing.
@
text
@d282 2
a283 4
   if (theBaPt == NULL)
      return;

   mySelector ()->recordFlowSS (theBaPt, expVol);
@


1.85
log
@Continued implementation of proportionate routing.
@
text
@d237 6
a242 4
void WitBaMgr::startSplitExp (
      WitPart * thePart,
      WitPeriod fillPer,
      double    reqVol)
d244 6
a249 1
   WitBaPt * theBaPt;
d253 1
a253 1
   theBaPt = myBaPt (thePart, fillPer);
d255 1
a255 2
   startSplitExpAbs (theBaPt, reqVol);
   }
d257 1
a257 1
//------------------------------------------------------------------------------
d259 3
a261 8
bool WitBaMgr::findNextSplit (WitPeriod & expPer, double & splitExpVol)
   {
   WitSelCand * theSelCand;
   bool         splitFound;

   witAssert (selSplit ());

   splitFound = findNextSplitAbs (theSelCand, splitExpVol);
d263 1
a263 4
   expPer     =
      splitFound?
         theSelCand->myBaCand ()->myExpPer ():
         -1;
d265 2
a266 1
   return splitFound;
@


1.84
log
@Continued implementation of proportionate routing.
@
text
@d32 1
d220 1
a220 4
void WitBaMgr::startSplitExp (
      WitPart * thePart,
      WitPeriod fillPer,
      double    reqVol)
d224 2
a225 1
   witAssert (selIsSplit (thePart, fillPer));
d229 4
a232 1
   startSplitExpAbs (theBaPt, reqVol);
d237 4
a240 1
bool WitBaMgr::selIsSplit (WitPart * thePart, WitPeriod fillPer)
d244 1
a244 2
   if (not selSplit ())
      return false;
d248 1
a248 4
   if (theBaPt == NULL)
      return false;

   return theBaPt->isSplit ();
d286 1
a286 1
   recordFlowSS (theBaPt, expVol);
@


1.83
log
@Continued implementation of proportionate routing.
@
text
@d219 4
a222 1
bool WitBaMgr::selIsSplit (WitPart * thePart, WitPeriod fillPer)
d226 1
a226 2
   if (not selSplit ())
      return false;
d230 1
a230 4
   if (theBaPt == NULL)
      return false;

   return theBaPt->isSplit ();
d235 1
a235 4
void WitBaMgr::startSplitExp (
      WitPart * thePart,
      WitPeriod fillPer,
      double    reqVol)
d239 2
a240 1
   witAssert (selIsSplit (thePart, fillPer));
d244 4
a247 1
   startSplitExpAbs (theBaPt, reqVol);
@


1.82
log
@Continued implementation of proportionate routing.
@
text
@d322 1
a322 1
   thePart->getMaterial (theMat);
d347 1
a347 1
   thePart->getMaterial (theMat);
@


1.81
log
@Continued implementation of proportionate routing.
@
text
@d383 1
a383 1
   fprintf (msgFile (), "   Exp Period:  %d\n", myExpPer_);
d708 2
a709 2
      "   Part:        %s\n"
      "   Fill Per:    %d\n",
@


1.80
log
@Continued implementation of proportionate routing.
@
text
@d366 1
a366 1
      WitSelCand (theBaMgr),
d404 1
a404 1
      WitProbAssoc (theBaMgr),
d515 1
a515 1
      WitProbAssoc (theMat),
@


1.79
log
@Continued implementation of Proportionate Routing.
@
text
@d136 1
a136 1
WitSelPt * WitBaMgr::mySelPt (
@


1.78
log
@Internal changes.
@
text
@d108 13
@


1.77
log
@Internal changes.
@
text
@d67 1
a67 1
      if (! theMat->producingBopEntries ().isEmpty ())
d197 1
a197 1
      if (theMat->nstnBaNeeded () || theMat->buildAsap ())
d210 1
a210 1
   if (! selSplit ())
d435 1
a435 1
         if (! theMat->mandEC ()[expPer])
d521 1
a521 1
      if (! myMaterial_->explodeable (expPer))
d540 1
a540 1
   if (! useable_[expPer])
d666 1
a666 1
   if (theBaMgr->selSplit () && theBaMgr->mySelector ()->splitCommActive ())
@


1.76
log
@Removed implementation of single-source by the old algorithm.
@
text
@d53 2
a54 2
   WitBoolean    nstnMatExists;
   WitBoolean    asapMatExists;
d63 2
a64 2
   nstnMatExists   = witFALSE;
   asapMatExists   = witFALSE;
d73 1
a73 1
            nstnMatExists        = witTRUE;
d80 1
a80 1
            asapMatExists        = witTRUE;
d145 1
a145 1
WitBoolean WitBaMgr::validForNetting ()
d147 1
a147 1
   return witTRUE;
d152 1
a152 1
WitBoolean WitBaMgr::validForExecBounds ()
d154 1
a154 1
   return witTRUE;
d186 1
a186 1
WitBoolean WitBaMgr::selSplitNeeded ()
d191 1
a191 1
      return witTRUE;
d194 1
a194 1
      return witTRUE;
d199 1
a199 1
            return witTRUE;
d201 1
a201 1
   return witFALSE;
d206 1
a206 1
WitBoolean WitBaMgr::selIsSplit (WitPart * thePart, WitPeriod fillPer)
d211 1
a211 1
      return witFALSE;
d216 1
a216 1
      return witFALSE;
d239 1
a239 1
WitBoolean WitBaMgr::findNextSplit (WitPeriod & expPer, double & splitExpVol)
d242 1
a242 1
   WitBoolean   splitFound;
d508 1
a508 1
      useable_     (myProblem (), witTRUE)
d548 1
a548 1
   useable_[expPer] = witFALSE;
d567 1
a567 1
   while (witTRUE)
d601 1
a601 1
         myMsgFac ().booleanText (useable_[expPer]));
d645 1
a645 1
WitBoolean WitBaPt::hasResAlt ()
d703 1
a703 1
WitBoolean WitBaPt::splittable ()
d706 1
a706 1
      return witTRUE;
d709 1
a709 1
      return witTRUE;
@


1.75
log
@Continued implementation of single-source with the new algorithm.
@
text
@a30 1
#include <OldSglMgr.h>
a543 3

   if (theSelector->oldSglSrc ())
      theSelector->myOldSglMgr ()->saveConfigVal (useable_[expPer]);
@


1.74
log
@Began implementation of the new single-source algorithm.
@
text
@d32 1
d548 3
@


1.73
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d31 1
a31 1
#include <SglSrcMgr.h>
d545 2
a546 2
   if (theSelector->singleSource ())
      theSelector->mySglSrcMgr ()->saveConfigVal (useable_[expPer]);
@


1.72
log
@Began implementation of optimizing implosion with OSL V3.
@
text
@d36 1
@


1.71
log
@More minor changes for vacpp.

The compiler complains if member functions are passed without an ampersand:

1589c1589
<          WitRun::witSetOperationYield,
---
>          &WitRun::witSetOperationYield,

It complains if "friend" declarations don't also have the word "class":
diff -r1.1 MsgFrag.h
39,40c39,40
<       friend WitMsgArg;
<       friend WitMsgFacility;
---
>       friend class WitMsgArg;
>       friend class WitMsgFacility;

It now can't figure out that a statement after a loop may not be executed!
diff -r1.70 BuildAhd.C
575a576
>    return NULL; // unreachable, but compiler complains


It also complained about missing "template<>" in many cases,
but since this seems odd, we are just suppressing the message for now
(see config/p_power64v5).  This is an example of a change that was NOT
made, but (presumably) would have to be to avoid the compiler warning.
diff -r1.47 ConsMR.C
180a181
> template<>
@
text
@d576 4
a579 1
   return NULL; // unreachable, but compiler complains
@


1.70
log
@Continued implementation of Single-Source.
@
text
@d576 1
@


1.69
log
@Continued implementation of Single-Source.
@
text
@d719 7
@


1.68
log
@Continued implementation of single-source.
@
text
@d31 1
d535 3
a537 2
   WitBaCand * theBaCand;
   WitPeriod   fillPer;
d541 5
@


1.67
log
@Continued preliminary work on single source.
@
text
@d125 1
a125 2
      WitPeriod     fillPer,
      WitBoolean &  resFound)
a130 2
   resFound = witFALSE;

a137 2
   resFound  = (theBaCand != NULL);

d629 13
@


1.66
log
@Continued implementation of object iteration.
@
text
@d32 2
@


1.65
log
@Began implementation of object iteration.
@
text
@d310 1
a310 1
   theMat = thePart->myMat ();
d335 1
a335 1
   theMat = thePart->myMat ();
@


1.64
log
@Continued implementation of sel-split for pen-exec.
@
text
@d31 2
@


1.63
log
@Continued implementation of sel-split for pen-exec.
@
text
@d692 1
a692 4
void WitBaPt::getSortData (
      WitPart * & thePart,
      int &       caseIdx,
      WitPeriod & thePer)
a694 1
   caseIdx = 3;
@


1.62
log
@Continued implementation of sel-split for pen-exec.
@
text
@d24 2
a30 2
#include <Splitter.h>
#include <HeurAtor.h>
d271 1
a271 1
   mySplitter ()->recordFlow (theBaPt, expVol);
d293 1
a293 1
   witAssert (mySplitter ()->splitCommActive ());
d642 1
a642 1
   if (theBaMgr->selSplit () && theBaMgr->mySplitter ()->splitCommActive ())
a687 7
   }

//------------------------------------------------------------------------------

WitPart * WitBaPt::myFillPart ()
   {
   return myBaMat_->myMaterial ();
@


1.61
log
@Continued implementation of sel-split for pen-exec.
@
text
@d699 4
a702 1
WitPart * WitBaPt::mySortPart ()
d704 3
a706 8
   return myBaMat_->myMaterial ();
   }

//------------------------------------------------------------------------------

int WitBaPt::caseIndex ()
   {
   return 3;
@


1.60
log
@Continued implementation of sel-split for pen-exec.
@
text
@d144 7
@


1.59
log
@Continued implementation of sel-split for pen-exec.
@
text
@d692 1
a692 1
WitPart * WitBaPt::sortPart ()
@


1.58
log
@Continued implementation of sel-split for pen-exec.
@
text
@d692 1
a692 1
int WitBaPt::sspeIndex ()
d694 8
a701 1
   return (myBaMat_->myMaterial ()->sortedPartIndex () * 10) + 1;
@


1.57
log
@Initial implementation of selection splitting for multi-route.
@
text
@d692 24
@


1.56
log
@Continued development of Selective Stock Reallocation.
@
text
@d182 6
d674 6
@


1.55
log
@Continued implementation of selective stock reallocation.
@
text
@d295 3
a297 1
   if (! thePart->getMyMaterial (theMat))
d320 3
a322 1
   if (! thePart->getMyMaterial (theMat))
@


1.54
log
@Continued implmentation of selective stock reallocation.
@
text
@d295 1
a295 1
   if (! thePart->isaMaterial (theMat))
d318 1
a318 1
   if (! thePart->isaMaterial (theMat))
@


1.53
log
@Refactoring for constrained stock reallocation.
@
text
@d236 1
a236 1
         WitBaCand::safeCast (theSelCand)->myExpPer ():
d357 1
a357 1
WitBoolean WitBaCand::isaBaCand ()
d359 1
a359 1
   return witTRUE;
@


1.52
log
@Refactoring for constrained stock reallocation.
@
text
@d21 1
a21 1
//    BaSelPt.
d28 1
a28 1
#include <BaSelPt.h>
d139 1
a139 1
   return theBaMat->myBaSelPt ()[fillPer];
d194 1
a194 1
   WitBaSelPt * theBaSelPt;
d199 1
a199 1
   theBaSelPt = myBaSelPt (thePart, fillPer);
d201 1
a201 1
   if (theBaSelPt == NULL)
d204 1
a204 1
   return theBaSelPt->isSplit ();
d214 1
a214 1
   WitBaSelPt * theBaSelPt;
d218 1
a218 1
   theBaSelPt = myBaSelPt (thePart, fillPer);
d220 1
a220 1
   startSplitExpAbs (theBaSelPt, reqVol);
d246 1
a246 1
   WitBaSelPt * theBaSelPt;
d253 1
a253 1
   theBaSelPt = myBaSelPt (thePart, fillPer);
d255 1
a255 1
   if (theBaSelPt == NULL)
d258 1
a258 1
   mySplitter ()->recordFlow (theBaSelPt, expVol);
d303 1
a303 1
   theBaCand = theBaMat->myBaSelPt ()[fillPer]->selBaCand ();
d313 1
a313 1
WitBaSelPt * WitBaMgr::myBaSelPt (WitPart * thePart, WitPeriod fillPer)
d326 1
a326 1
   return theBaMat->myBaSelPt ()[fillPer];
d489 1
a489 1
      myBaSelPt_   (myProblem ()),
d500 1
a500 2
      myBaSelPt_[fillPer] = 
         new WitBaSelPt (this, fillPer, theBaCandVec[fillPer]);
d511 1
a511 1
   deleteContents (myBaSelPt_);
d529 2
a530 2
      if (myBaSelPt_[fillPer]->selBaCand () == theBaCand)
          myBaSelPt_[fillPer]->advanceSel ();
d583 1
a583 1
      theBaCand = myBaSelPt ()[fillPer]->selBaCand ();
d593 1
a593 1
// Implementation of class BaSelPt.
d596 1
a596 1
WitBaSelPt::WitBaSelPt (
d611 1
a611 1
WitBaSelPt::~WitBaSelPt ()
d617 1
a617 1
void WitBaSelPt::alterSelection ()
d637 1
a637 1
void WitBaSelPt::printSelection ()
d644 1
a644 1
WitSelMgr * WitBaSelPt::mySelMgr ()
d651 1
a651 1
void WitBaSelPt::prtID ()
d662 1
a662 1
WitBoolean WitBaSelPt::splittable ()
d669 1
a669 1
WitPart * WitBaSelPt::myFillPart ()
d676 1
a676 1
void WitBaSelPt::advanceSel ()
@


1.51
log
@Refactoring for constrained stock reallocation.
@
text
@a31 1
#include <DblSpSch.h>
a262 6
void WitBaMgr::postCommitSS ()
   {
   }

//------------------------------------------------------------------------------

a286 6
void WitBaMgr::setUpDerivedSS ()
   {
   }

//------------------------------------------------------------------------------

a665 6
   }

//------------------------------------------------------------------------------

void WitBaSelPt::adjustSplitBound (WitSelCand *, double &)
   {
@


1.50
log
@Refactoring for constrained stock reallocation.
@
text
@a158 11
void WitBaMgr::prtSelCandID (WitTlObj * theTlObj)
   {
   WitFixedPer * theFixedPer;

   theFixedPer = (WitFixedPer *) theTlObj;

   fprintf (msgFile (), "   Exp Period:  %d\n", theFixedPer->myPeriod ());
   }

//------------------------------------------------------------------------------

d228 2
a229 2
   WitTlObj * theTlObj;
   WitBoolean splitFound;
d233 1
a233 3
   expPer     = -1;

   splitFound = findNextSplitAbs (theTlObj, splitExpVol);
d235 4
a238 2
   if (splitFound)
      expPer  = ((WitFixedPer *) theTlObj)->myPeriod ();
d363 7
a630 16
WitTlObj * WitBaSelPt::selectedObj ()
   {
   WitPeriod     expPer;
   WitFixedPer * theFixedPer;

   witAssert (selBaCand () != NULL);

   expPer      = selBaCand ()->myExpPer ();

   theFixedPer = myBaMat_->myProblem ()->myFixedPer ()[expPer];

   return (WitTlObj *) theFixedPer;
   }

//------------------------------------------------------------------------------

d683 1
a683 1
void WitBaSelPt::adjustSplitBound (WitTlObj *, double &)
@


1.49
log
@Refactoring for constrained stock reallocation.
@
text
@d136 1
a136 3
   theBaCand = myBaCand_[expPer];

   theBaMat->advanceToUseableBaCand (fillPer, theBaCand);
d373 7
d553 3
a555 3
void WitBaMat::advanceToUseableBaCand (
      WitPeriod     fillPer, 
      WitBaCand * & theBaCand)
d566 1
a566 5
         {
         theBaCand = NULL;

         return;
         }
d569 1
a569 5
         {
         theBaCand = myBaMgr_->myBaCand ()[expPer];

         return;
         }
d622 1
a622 2
      myFillPer_ (fillPer),
      selBaCand_ (theBaCand)
d624 1
d640 1
a640 1
   witAssert (selBaCand_ != NULL);
d642 1
a642 1
   expPer = selBaCand_->myExpPer ();
d655 1
a655 1
   witAssert (selBaCand_ != NULL);
d661 1
a661 1
      theBaMgr->deferRejection (myBaMat_, selBaCand_->myExpPer ());
d666 1
a666 1
      myBaMat_->reject (selBaCand_->myExpPer ());
d718 1
a718 1
   myBaMat_->advanceToUseableBaCand (myFillPer_, selBaCand_);
@


1.48
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@a90 1
   WitPeriod     expPer;
d98 1
a98 2
   forEachPeriod (expPer, myProblem ())
      delete myBaCand_[expPer];
d524 1
a524 4
   WitPeriod fillPer;

   forEachPeriod (fillPer, myProblem ())
      delete myBaSelPt_[fillPer];
@


1.47
log
@Created and used Archive template.
@
text
@d717 7
@


1.46
log
@Initial implementation of pegging.
@
text
@a30 1
#include <AllMode.h>
@


1.45
log
@Replaced Mapping (*, WitTlObjPtr) with PtrMap <*, *>.
@
text
@d30 1
a30 1
#include <HeurAllP.h>
d267 1
a267 1
   if (thePart == mySelector ()->myHeurAllPerf ()->topPart ())
@


1.44
log
@Moved Stack template implementations to header files.
@
text
@d45 1
a45 1
      myBaMatTl_      (myProblem (), NULL),
d67 1
a67 1
            myBaMat (theMat) = new WitBaMat (theMat, myBaDirForNstn_, this);
d69 1
a69 1
            nstnMatExists    = witTRUE;
d74 1
a74 1
            myBaMat (theMat) = new WitBaMat (theMat, myBaDirForAsap_, this);
d76 1
a76 1
            asapMatExists    = witTRUE;
d95 1
a95 1
      delete myBaMat (theMat);
d186 1
a186 1
      theBaMat = myBaMat (theMat);
d327 1
a327 1
   theBaMat = myBaMat (theMat);
d350 1
a350 1
   theBaMat = myBaMat (theMat);
@


1.43
log
@Refactoring build-ahead.
@
text
@d32 1
a32 1
#include <PairSt.h>
@


1.42
log
@Minor changes.
@
text
@d56 2
a57 2
   myBaDirForNstn_ = new WitNstnBaDir (myProblem ());
   myBaDirForAsap_ = new WitAsapBaDir (myProblem ());
d128 3
a130 3
   WitBaMat *   theBaMat;
   WitPeriod    expPer;
   WitBaSelPt * theBaSelPt;
d139 1
a139 1
   theBaSelPt = theBaMat->myBaSelPt ()[fillPer];
d141 1
a141 1
   theBaMat->advanceToUseableExpPer (fillPer, expPer);
d143 1
a143 1
   resFound   = (expPer >= 0);
d145 1
a145 1
   return theBaSelPt;
d322 1
d332 6
a337 1
   return theBaMat->selExpPer ()[fillPer];
d387 4
a390 2
WitBaDir::WitBaDir (WitProblem * theProblem):
      WitProbAssoc (theProblem)
d398 2
a399 2
WitNstnBaDir::WitNstnBaDir (WitProblem * theProblem):
      WitBaDir (theProblem)
d411 3
a413 3
void WitNstnBaDir::findInitExpPers (
      WitMaterial *         theMat,
      WitTVec (WitPeriod) & selExpPerVec)
d418 1
a418 1
      selExpPerVec[fillPer] = fillPer;
d442 2
a443 2
WitAsapBaDir::WitAsapBaDir (WitProblem * theProblem):
      WitBaDir (theProblem)
d455 3
a457 3
void WitAsapBaDir::findInitExpPers (
      WitMaterial *         theMat,
      WitTVec (WitPeriod) & selExpPerVec)
d461 1
d467 3
a469 2
      selExpPerVec[fillPer] = 
         max (fillPer - theMat->buildAheadUB ()[fillPer], firstStockPer);
d476 1
a504 1
      selExpPer_   (myProblem (), -1),
d510 4
d515 2
a516 3
      myBaSelPt_[fillPer] = new WitBaSelPt (this, fillPer);

   myBaDir_->findInitExpPers (myMaterial_, selExpPer_);
a534 16
void WitBaMat::alterSelection (WitPeriod fillPer)
   {
   witAssert (selExpPer_[fillPer] >= 0);

   if (myBaMgr_->selSplit () && myBaMgr_->mySplitter ()->splitCommActive ())
      {
      myBaMgr_->deferRejection (this, selExpPer_[fillPer]);

      advanceToUseableExpPer (fillPer, selExpPer_[fillPer]);
      }
   else
      reject (selExpPer_[fillPer]);
   }

//------------------------------------------------------------------------------

d537 2
a538 1
   WitPeriod fillPer;
d545 2
d548 2
a549 2
      if (selExpPer_[fillPer] == expPer)
         advanceToUseableExpPer (fillPer, selExpPer_[fillPer]);
d554 3
a556 1
void WitBaMat::advanceToUseableExpPer (WitPeriod fillPer, WitPeriod & expPer)
d558 4
d567 3
d571 1
d574 3
d578 1
d586 3
a588 2
   WitPeriod fillPer;
   WitPeriod expPer;
d610 1
a610 1
      expPer = selExpPer ()[fillPer];
d612 2
a613 2
      if (expPer >= 0)
         fprintf (msgFile (), "   %7d\n", expPer);
d623 4
a626 1
WitBaSelPt::WitBaSelPt (WitBaMat * theBaMat, WitPeriod fillPer):
d631 2
a632 1
      myFillPer_ (fillPer)
d649 1
a649 1
   expPer = myBaMat_->selExpPer ()[myFillPer_];
d651 1
a651 1
   witAssert (expPer >= 0);
d662 14
a675 1
   myBaMat_->alterSelection (myFillPer_);
d714 7
@


1.41
log
@Removed indexes from production multi-route.
Other refactoring.
@
text
@a109 1
   WitBoolean resFound;
@


1.40
log
@Created class SelCand and classes derived from it.
@
text
@d16 1
a21 1
//    BaCand.
d25 1
a28 1
#include <BaCand.h>
d42 1
d48 1
d53 3
d92 1
d99 3
d354 19
a681 19
   {
   }

//------------------------------------------------------------------------------
// Implementation of class BaCand.
//------------------------------------------------------------------------------

WitBaCand::WitBaCand (WitPeriod expPer, WitBaMgr * theBaMgr):

      WitSelCand (theBaMgr),

      myExpPer_  (expPer),
      myBaMgr_   (theBaMgr)
   {
   }

//------------------------------------------------------------------------------

WitBaCand::~WitBaCand ()
@


1.39
log
@Fixed bug in two-way multi-exec:
   NSTN and ASAP multi-exec collisions were not being adequately detected.
@
text
@d21 1
d28 1
d654 19
@


1.38
log
@Refactoring.
@
text
@d626 1
a626 1
WitSelMgr * WitBaSelPt::mySelMgr (WitSelector * theSelector)
d628 1
a628 1
   return theSelector->myBaMgr ();
@


1.37
log
@Continued development of selection splitting for multi=exec.
@
text
@d95 1
a95 1
WitPeriod WitBaMgr::selExpPeriod (WitPart * thePart, WitPeriod fillPer)
d321 1
a321 1
   return theBaMat->selExpPeriod ()[fillPer];
d459 1
a459 1
      WitProbAssoc  (theMat),
d461 6
a466 6
      myMaterial_   (theMat),
      myBaDir_      (theBaDir),
      myBaMgr_      (theBaMgr),
      myBaSelPt_    (myProblem ()),
      selExpPeriod_ (myProblem (), -1),
      useable_      (myProblem (), witTRUE)
d474 1
a474 1
   myBaDir_->findInitExpPers (myMaterial_, selExpPeriod_);
d495 1
a495 1
   witAssert (selExpPeriod_[fillPer] >= 0);
d499 1
a499 1
      myBaMgr_->deferRejection (this, selExpPeriod_[fillPer]);
d501 1
a501 1
      advanceToUseableExpPer (fillPer, selExpPeriod_[fillPer]);
d504 1
a504 1
      reject (selExpPeriod_[fillPer]);
d519 2
a520 2
      if (selExpPeriod_[fillPer] == expPer)
         advanceToUseableExpPer (fillPer, selExpPeriod_[fillPer]);
d566 1
a566 1
      expPer = selExpPeriod ()[fillPer];
d581 1
a581 1
      WitSelPt    (),
d583 2
a584 2
      myBaMat_    (theBaMat),
      fillPeriod_ (fillPer)
d601 1
a601 1
   expPer = myBaMat_->selExpPeriod ()[fillPeriod_];
d614 1
a614 1
   myBaMat_->alterSelection (fillPeriod_);
d639 1
a639 1
      fillPeriod_);
@


1.36
log
@Refactoring for sel-split for multi-exec.
@
text
@d147 18
d633 1
a633 1
WitBoolean WitBaSelPt::splittable ()
d635 5
a639 1
   return myBaMat_->myMaterial ()->baSelSplit ();
d644 1
a644 1
void WitBaSelPt::adjustSplitBound (WitTlObj *, double &)
d646 1
d651 1
a651 18
void WitBaSelPt::prtSplitting (double splitBound)
   {
   fprintf (myBaMat_->myBaMgr ()->msgFile (), 
      "\n" 
      "Splitting the Build-Ahead Selection:\n"
      "   Part:        %s\n"
      "   Fill Per:    %d\n"
      "   Exp Period:  %d\n"
      "   Split Bound: %.3f\n",
      myBaMat_->myMaterial ()->partName ().myCstring (),
      fillPeriod_,
      myBaMat_->selExpPeriod ()[fillPeriod_],
      splitBound);
   }

//------------------------------------------------------------------------------

void WitBaSelPt::prtSplitExp (WitTlObj * splitObj)
a652 13
   WitFixedPer * theFixedPer;

   theFixedPer = (WitFixedPer *) splitObj;

   fprintf (myBaMat_->myBaMgr ()->msgFile (),
      "\n"
      "Split Selection for Build-Ahead:\n"
      "   Part:        %s\n"
      "   Fill Per:    %d\n"
      "   Exp Period:  %d\n",
      myBaMat_->myMaterial ()->partName ().myCstring (),
      fillPeriod_,
      theFixedPer->myPeriod ());
@


1.35
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@d226 1
a226 1
      expPer  = asaPer (theTlObj);
@


1.34
log
@Various refactorings for sel-split for multi-exec.
@
text
@d101 1
a101 1
   expPer = intSelExpPer (thePart, fillPer, theBaMat);
d124 1
a124 1
   expPer   = intSelExpPer (theBopEnt->myPart (), fillPer, theBaMat);
d288 1
a288 8
void WitBaMgr::adjustSplitBound (WitTlObj *, double &)
   {
   witAssert (selSplit ());
   }

//------------------------------------------------------------------------------

WitPeriod WitBaMgr::intSelExpPer (
d491 16
a522 16
void WitBaMat::reject (WitPeriod expPer)
   {
   WitPeriod fillPer;

   if (! useable_[expPer])
      return;

   useable_[expPer] = witFALSE;

   for (fillPer = expPer; fillPer < nPeriods (); fillPer ++)
      if (selExpPeriod_[fillPer] == expPer)
         advanceToUseableExpPer (fillPer, selExpPeriod_[fillPer]);
   }

//------------------------------------------------------------------------------

d618 6
@


1.33
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@a42 2
      splitExpMat_    (NULL),
      splitFillPer_   (-1),
d183 1
a183 3
   WitMaterial * theMat;
   WitBaMat *    theBaMat;
   WitBaSelPt *  theBaSelPt;
d188 1
a188 9
   if (! thePart->isaMaterial (theMat))
      return witFALSE;

   theBaMat = myBaMat (theMat);

   if (theBaMat == NULL)
      return witFALSE;

   theBaSelPt = theBaMat->myBaSelPt ()[fillPer];
d203 1
a203 4
   WitMaterial * theMat;
   WitBaMat *    theBaMat;
   WitPeriod     expPer;
   WitBaSelPt *  theBaSelPt;
d207 1
a207 1
   splitFillPer_ = fillPer;
d209 1
a209 10
   thePart->isaMaterial (theMat);

   theBaMat   = myBaMat (theMat);

   expPer     = theBaMat->selExpPeriod ()[fillPer];
   theBaSelPt = theBaMat->myBaSelPt    ()[fillPer];

   startSplitExpAbs (theBaSelPt, asaTlObj (expPer), reqVol);

   splitExpMat_ = theMat;
d233 1
a233 5
void WitBaMgr::recExpMatSS (
      WitPart * thePart,
      WitPeriod expPer, 
      double    expVol,
      WitPeriod fillPer) 
d235 1
a235 3
   WitMaterial * theMat;
   WitBaMat *    theBaMat;
   WitBaSelPt *  theBaSelPt;
d239 1
a239 1
   if (! thePart->isaMaterial (theMat))
d242 1
a242 1
   theBaMat = myBaMat (theMat);
d244 1
a244 4
   if (theBaMat == NULL)
      return;

   if (thePart == mySelector ()->myHeurAllPerf ()->topPart ())
a246 2
   theBaSelPt = theBaMat->myBaSelPt ()[fillPer];

a294 19
void WitBaMgr::prtSplitExp (WitTlObj * theTlObj)
   {
   WitFixedPer * theFixedPer;

   witAssert (selSplit ());

   fprintf (msgFile (),
      "\n"
      "Split Selection for Build-Ahead:\n"
      "   Part:        %s\n"
      "   Fill Per:    %d\n"
      "   Exp Period:  %d\n",
      splitExpMat_->partName ().myCstring (),
      splitFillPer_,
      asaPer (theTlObj));
   }

//------------------------------------------------------------------------------

d585 1
a585 1
WitTlObj * WitBaSelPt::selection ()
d642 19
@


1.32
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a42 1
      splitSched_     (myProblem ()),
d187 1
d200 1
a200 2
   if (! splitSched_ (theMat, fillPer).isEmpty ())
      return witTRUE;
d202 1
a202 1
   if (theBaMat->selExpPeriod ()[fillPer] < 0)
d205 1
a205 4
   if (mySplitter ()->isSearchingAt (theBaMat->myBaSelPt ()[fillPer]))
      return witTRUE;

   return witFALSE;
d226 1
a226 5
   witAssert (theMat != NULL);

   theBaMat = myBaMat (theMat);

   witAssert (theBaMat != NULL);
d229 1
d231 1
a231 7
   theBaSelPt = theBaMat->myBaSelPt ()[fillPer];

   startSplitExpAbs (
      splitSched_ (theMat, fillPer),
      asaTlObj (expPer),
      reqVol,
      theBaSelPt);
d240 1
a240 1
   WitTl *    theTlObj;
a299 2
   splitSched_.clear ();

a305 24
void WitBaMgr::splitSelection (
      WitMaterial * theMat,
      WitPeriod     fillPer,
      WitPeriod     expPer,
      double        splitBound)
   {
   splitSched_.slowAppend (theMat, fillPer, asaTlObj (expPer), splitBound);

   if (myGlobalComp ()->selPrintLevel () >= 3)
      fprintf (msgFile (), 
         "\n" 
         "Splitting the Build-Ahead Selection:\n"
         "   Part:        %s\n"
         "   Fill Per:    %d\n"
         "   Exp Period:  %d\n"
         "   Split Bound: %.3f\n",
         theMat->partName ().myCstring (),
         fillPer,
         expPer,
         splitBound);
   }

//------------------------------------------------------------------------------

a318 9
   WitMaterial * theMat;

   witAssert (selSplit ());

   splitSched_.allocate1D ();

   forEachMaterial (theMat, myProblem ())
      if (myBaMat (theMat) != NULL)
         splitSched_.allocateRow (theMat);
d323 1
a323 1
void WitBaMgr::adjustSplitBound (WitTl *, double &)
d330 1
a330 1
void WitBaMgr::prtSelSplit (WitTl * theTlObj)
d368 18
a551 11
void WitBaMat::splitSelection (WitPeriod fillPer, double splitBound)
   {
   myBaMgr_->splitSelection (
      myMaterial_,
      fillPer,
      selExpPeriod_[fillPer],
      splitBound);
   }

//------------------------------------------------------------------------------

d639 1
a639 1
void WitBaSelPt::alterSelection ()
d641 10
a650 1
   myBaMat_->alterSelection (fillPeriod_);
d655 1
a655 1
void WitBaSelPt::splitSelection (double splitBound)
d657 1
a657 1
   myBaMat_->splitSelection (fillPeriod_, splitBound);
d681 16
@


1.31
log
@Renamed AltPt classes to SelPt classes.
@
text
@a42 1
      expPairs_       (myProblem ()),
a80 3

   if (selSplit ())
      setupSelSplit ();
d170 14
d278 1
a278 1
   WitFixedPer * fillFixedPer;
d280 1
a280 2
   if (! selSplit ())
      return;
d290 2
a291 1
   fillFixedPer = myProblem ()->myFixedPer ()[fillPer];
d293 1
a293 1
   expPairs_.push (theMat, expPer, fillFixedPer, expVol);
d295 1
a295 2
   if (thePart != mySelector ()->myHeurAllPerf ()->topPart ())
      mySplitter ()->recordFlow (theBaMat->myBaSelPt ()[fillPer], expVol);
a301 3
   witAssert (selSplit ());

   expPairs_.clear ();
d356 1
a356 1
void WitBaMgr::setupSelSplit ()
a362 1
   expPairs_  .allocate1D ();
a365 1
         {
a366 2
         expPairs_  .allocateRow (theMat);
         }
d710 1
a710 1
   return witTRUE;
@


1.30
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@d20 1
a20 1
//    BaAltPt.
d26 1
a26 1
#include <BaAltPt.h>
d118 1
a118 1
WitAltPt * WitBaMgr::myAltPt (
d127 1
a127 1
   WitBaAltPt * theBaAltPt;
d136 1
a136 1
   theBaAltPt = theBaMat->myBaAltPt ()[fillPer];
d142 1
a142 1
   return theBaAltPt;
d161 1
a161 1
      "Global Build-Ahead Period Selections:\n");
d196 1
a196 1
   if (mySplitter ()->isSearchingAt (theBaMat->myBaAltPt ()[fillPer]))
d212 1
a212 1
   WitBaAltPt *  theBaAltPt;
d228 1
a228 1
   theBaAltPt = theBaMat->myBaAltPt ()[fillPer];
d234 1
a234 1
      theBaAltPt);
d286 1
a286 1
      mySplitter ()->recordFlow (theBaMat->myBaAltPt ()[fillPer], expVol);
d535 1
a535 1
      myBaAltPt_    (myProblem ()),
d543 1
a543 1
      myBaAltPt_[fillPer] = new WitBaAltPt (this, fillPer);
d559 1
a559 1
      delete myBaAltPt_[fillPer];
d658 1
a658 1
// Implementation of class BaAltPt.
d661 1
a661 1
WitBaAltPt::WitBaAltPt (WitBaMat * theBaMat, WitPeriod fillPer):
d663 1
a663 1
      WitAltPt    (),
d672 1
a672 1
WitBaAltPt::~WitBaAltPt ()
d678 1
a678 1
void WitBaAltPt::alterSelection ()
d685 1
a685 1
void WitBaAltPt::splitSelection (double splitBound)
d692 1
a692 1
void WitBaAltPt::printSelection ()
d699 1
a699 1
WitSelMgr * WitBaAltPt::mySelMgr (WitSelector * theSelector)
d706 1
a706 1
WitBoolean WitBaAltPt::splittable ()
@


1.29
log
@Added various counts to the debugging output of selection splitting.
@
text
@a211 1
   WitFixedPer * theFixedPer;
d222 1
a222 1
   theBaMat  = myBaMat (theMat);
d226 1
a226 1
   expPer      = theBaMat->selExpPeriod ()[fillPer];
d228 1
a228 3
   theFixedPer = myProblem ()->myFixedPer ()[expPer];

   theBaAltPt  = theBaMat->myBaAltPt ()[fillPer];
d232 1
a232 1
      (WitTl *) theFixedPer,
d243 2
a244 3
   WitFixedPer * theFixedPer;
   WitTl *       theTlObj;
   WitBoolean    splitFound;
d248 1
a248 1
   splitFound = findNextSplitAbs ((WitTl * &) theFixedPer, splitExpVol);
d250 4
a253 1
   expPer     = theFixedPer->myPeriod ();
d321 1
a321 5
   WitTl * theTlObj;

   theTlObj = (WitTl *) myProblem ()->myFixedPer ()[expPer];

   splitSched_.slowAppend (theMat, fillPer, theTlObj, splitBound);
a381 2
   theFixedPer = (WitFixedPer *) theTlObj;

d390 1
a390 1
      theFixedPer->myPeriod ());
@


1.28
log
@Continuing development of selection splitting.
@
text
@d328 1
a328 1
   if (myGlobalComp ()->selPrintLevel () >= 4)
@


1.27
log
@Re-worked the controls for selection splitting.
@
text
@d286 2
a287 1
   mySplitter ()->recordFlow (theBaMat->myBaAltPt ()[fillPer], expVol);
d710 8
@


1.26
log
@Refactoring build-ahead for selection splitting.
@
text
@d38 1
a38 1
      WitSelMgr       (theSelector, selSplitNeeded (theSelector->myProblem ())),
a353 16
WitBoolean WitBaMgr::selSplitNeeded (WitProblem * theProblem)
   {
   WitMaterial * theMat;

   if (! theProblem->myGlobalComp ()->allowSS ())
      return witFALSE;

   forEachMaterial (theMat, theProblem)
      if (theMat->baSplitRes () > 0.0)
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

a707 7
   }

//------------------------------------------------------------------------------

float WitBaAltPt::splitRes ()
   {
   return myBaMat_->myMaterial ()->baSplitRes ();
@


1.25
log
@Continued implementation of selection splitting.
@
text
@a558 1
      lastFillPer_  (myProblem (), -1),
a568 3
   forEachPeriod (fillPer, myProblem ())
      lastFillPer_[selExpPeriod_[fillPer]] = fillPer;

d594 1
a594 1
      advanceSelExpPer (fillPer);
d638 1
a638 1
   for (fillPer = expPer; fillPer <= lastFillPer_[expPer]; fillPer ++)
d640 1
a640 3
         advanceSelExpPer (fillPer);

   lastFillPer_[expPer] = -1;
d653 1
a653 1
      "    Exp Per   Useable?   Last FP\n",
a656 1
      {
d658 1
a658 1
         "    %7d   %7s ",
a660 6

      if (lastFillPer_[expPer] >= 0)
         fprintf (msgFile (), "   %7d\n", lastFillPer_[expPer]);
      else
         fprintf (msgFile (), "         *\n");
      }
a676 10
   }

//------------------------------------------------------------------------------

void WitBaMat::advanceSelExpPer (WitPeriod fillPer)
   {
   advanceToUseableExpPer (fillPer, selExpPeriod_[fillPer]);

   if (selExpPeriod_[fillPer] >= 0)
      setToMax (lastFillPer_[selExpPeriod_[fillPer]], fillPer);
@


1.24
log
@Removed lazy evaluation from build-ahead.
@
text
@d46 2
a47 1
      splitFillPer_   (-1)
d53 2
a54 2
   myBaDirForNstn_ = new WitNstnBaDir (this);
   myBaDirForAsap_ = new WitAsapBaDir (this);
d64 1
a64 1
            myBaMat (theMat) = new WitBaMat (theMat, myBaDirForNstn_);
d71 1
a71 1
            myBaMat (theMat) = new WitBaMat (theMat, myBaDirForAsap_);
d300 1
a300 1
void WitBaMgr::clearSplitSched ()
d302 3
d308 3
d343 11
d445 2
a446 4
WitBaDir::WitBaDir (WitBaMgr * theBaMgr):
      WitProbAssoc (theBaMgr),

      myBaMgr_     (theBaMgr)
a449 1

d454 2
a455 2
WitNstnBaDir::WitNstnBaDir (WitBaMgr * theBaMgr):
      WitBaDir (theBaMgr)
d498 2
a499 2
WitAsapBaDir::WitAsapBaDir (WitBaMgr * theBaMgr):
      WitBaDir (theBaMgr)
d547 4
a550 1
WitBaMat::WitBaMat (WitMaterial * theMat, WitBaDir * theBaDir):
d556 1
d575 1
a575 5
         {
         useable_[expPer] = witFALSE;

         advanceAllFrom (expPer);
         }
d594 3
a596 1
   useable_[selExpPeriod_[fillPer]] = witFALSE;
d598 4
a601 1
   advanceAllFrom (selExpPeriod_[fillPer]);
d608 1
a608 1
   myBaDir_->myBaMgr ()->splitSelection (
d633 18
d694 1
a694 1
void WitBaMat::advanceAllFrom (WitPeriod expPer)
d696 1
a696 3
   WitPeriod fillPer;

   witAssert (! useable_[expPer]);
d698 2
a699 10
   for (fillPer = expPer; fillPer <= lastFillPer_[expPer]; fillPer ++)
      if (selExpPeriod_[fillPer] == expPer)
         {
         advanceToUseableExpPer (fillPer, selExpPeriod_[fillPer]);

         if (selExpPeriod_[fillPer] >= 0)
            setToMax (lastFillPer_[selExpPeriod_[fillPer]], fillPer);
         }

   lastFillPer_[expPer] = -1;
d740 7
@


1.23
log
@Refactoring build-ahead for selection splitting.
@
text
@d192 1
a192 1
   if (theBaMat->selExpPeriod (fillPer) < 0)
d226 1
a226 1
   expPer      = theBaMat->selExpPeriod (fillPer);
d414 1
a414 1
   return theBaMat->selExpPeriod (fillPer);
d540 2
a541 1
      useable_      (myProblem (), witFALSE)
d551 3
d555 6
a560 1
      useable_ [expPer] = myMaterial_->explodeable (expPer);
a574 13
WitPeriod WitBaMat::selExpPeriod (WitPeriod fillPer)
   {
   WitPeriod & expPer = selExpPeriod_[fillPer];

   if (expPer >= 0)
      if (! useable_[expPer])
         advanceToUseableExpPer (fillPer, expPer);

   return expPer;
   }

//------------------------------------------------------------------------------

d581 1
a581 1
   advanceToUseableExpPer (fillPer, selExpPeriod_[fillPer]);
d588 1
a588 1
   myBaDir ()->myBaMgr ()->splitSelection (
d621 1
a621 1
      "    Exp Per   Useable?\n",
d625 1
d627 1
a627 1
         "    %7d   %7s\n",
d630 6
d645 1
a645 1
      expPer = selExpPeriod (fillPer);
d650 1
a650 1
         fprintf (msgFile (), "      None\n");
d652 20
@


1.22
log
@Continued implementation of selection splitting.
@
text
@d192 1
a192 1
   if (theBaMat->myBaAltPt ()[fillPer]->selExpPeriod () < 0)
a209 1
   WitBaAltPt *  theBaAltPt;
d212 1
d226 1
a226 3
   theBaAltPt  = theBaMat->myBaAltPt ()[fillPer];

   expPer      = theBaAltPt->selExpPeriod ();
d230 2
d414 1
a414 1
   return theBaMat->myBaAltPt ()[fillPer]->selExpPeriod ();
d452 3
a454 3
void WitNstnBaDir::buildBaAltPts (
      WitBaMat * theBaMat, 
      WitPtrTVec (WitBaAltPt) & theBaAltPtVec)
a457 2
   witAssert (theBaMat->myBaDir () == this);

d459 1
a459 1
      theBaAltPtVec[fillPer] = new WitBaAltPt (theBaMat, fillPer, fillPer);
d496 3
a498 3
void WitAsapBaDir::buildBaAltPts (
      WitBaMat * theBaMat, 
      WitPtrTVec (WitBaAltPt) & theBaAltPtVec)
d500 2
a501 8
   WitMaterial * theMat;
   WitPeriod     fillPer;
   WitPeriod     firstStockPer;
   WitPeriod     expPer;

   witAssert (theBaMat->myBaDir () == this);

   theMat        = theBaMat->myMaterial ();
d507 2
a508 3
      expPer = max (fillPer - theMat->buildAheadUB ()[fillPer], firstStockPer);

      theBaAltPtVec[fillPer] = new WitBaAltPt (theBaMat, fillPer, expPer);
d534 1
a534 1
      WitProbAssoc (theMat),
d536 5
a540 4
      myMaterial_  (theMat),
      myBaDir_     (theBaDir),
      myBaAltPt_   (myProblem ()),
      useable_     (myProblem (), witFALSE)
d542 1
d545 5
a551 2

   myBaDir_->buildBaAltPts (this, myBaAltPt_);
d566 1
a566 1
void WitBaMat::reject (WitPeriod expPer)
d568 1
a568 1
   witAssert (useable_[expPer]);
d570 27
a596 1
   useable_[expPer] = witFALSE;
d619 1
a620 1
   WitPeriod fillPer;
d642 1
a642 1
      expPer = myBaAltPt ()[fillPer]->selExpPeriod ();
d655 6
a660 10
WitBaAltPt::WitBaAltPt (
         WitBaMat * theBaMat, 
         WitPeriod  fillPer, 
         WitPeriod  initExpPer):

      WitAltPt      (),

      myBaMat_      (theBaMat),
      fillPeriod_   (fillPer),
      selExpPeriod_ (initExpPer)
d674 1
a674 5
   witAssert (selExpPeriod_ >= 0);

   myBaMat_->reject (selExpPeriod_);

   myBaMat_->advanceToUseableExpPer (fillPeriod_, selExpPeriod_);
d681 1
a681 5
   myBaMat_->myBaDir ()->myBaMgr ()->splitSelection (
      myBaMat_->myMaterial (),
      fillPeriod_,
      selExpPeriod_,
      splitBound);
a695 11
   }

//------------------------------------------------------------------------------

WitPeriod WitBaAltPt::selExpPeriod ()
   {
   if (selExpPeriod_ >= 0)
      if (! myBaMat_->useable ()[selExpPeriod_])
         myBaMat_->advanceToUseableExpPer (fillPeriod_, selExpPeriod_);

   return selExpPeriod_;
@


1.21
log
@Re-factoring for selection splitting.
@
text
@d107 2
d110 1
a110 1
      hasExpPer (thePart, fillPer, theBaMat, expPer)?
d128 3
a130 1
   resFound   = witFALSE;
d132 1
a132 1
   if (! hasExpPer (theBopEnt->myPart (), fillPer, theBaMat, expPer))
d137 3
a139 1
   resFound   = theBaMat->nextUseableExpPerExists (fillPer, expPer);
a176 1
   WitPeriod     expPer;
d192 1
a192 1
   if (! theBaMat->myBaAltPt ()[fillPer]->hasExpPer (expPer))
d270 10
a279 4
   if (selSplit ())
      if (thePart->isaMaterial (theMat))
         {
         theBaMat = myBaMat (theMat);
d281 1
a281 9
         if (theBaMat != NULL)
            {
            fillFixedPer = myProblem ()->myFixedPer ()[fillPer];

            if (!  expPairs_ (theMat, expPer).isEmpty ())
               if (expPairs_ (theMat, expPer).firstObject () != fillFixedPer)
                  myMsgFac () ("genericSmsg", 
                     "Build-ahead from 2 fill periods to 1 explosion period is "
                     "not yet allowed in selection splitting.");
d283 1
a283 1
            expPairs_.push (theMat, expPer, fillFixedPer, expVol);
d285 1
a285 3
            mySplitter ()->recordFlow (theBaMat->myBaAltPt ()[fillPer], expVol);
            }
         }
d399 1
a399 1
WitBoolean WitBaMgr::hasExpPer (
d402 1
a402 2
      WitBaMat * & theBaMat,
      WitPeriod &  expPer)
d407 1
a407 1
      return witFALSE;
d412 1
a412 1
      return witFALSE;
d414 1
a414 1
   return theBaMat->myBaAltPt ()[fillPer]->hasExpPer (expPer);
d466 1
a466 1
WitBoolean WitNstnBaDir::updatedExpPerIsValid (
d476 1
a476 1
            return witTRUE;
d478 1
a478 1
   return witFALSE;
d526 1
a526 1
WitBoolean WitAsapBaDir::updatedExpPerIsValid (
d533 2
a534 1
   return (expPer <= fillPer);
d579 1
a579 3
WitBoolean WitBaMat::nextUseableExpPerExists (
      WitPeriod   fillPer, 
      WitPeriod & expPer)
d581 7
a587 1
   while (myBaDir_->updatedExpPerIsValid (myMaterial_, fillPer, expPer))
d589 2
a590 3
         return witTRUE;

   return witFALSE;
d620 3
a622 1
      if (myBaAltPt ()[fillPer]->hasExpPer (expPer))
d659 2
d690 1
a690 1
WitBoolean WitBaAltPt::hasExpPer (WitPeriod & expPer)
d692 3
a694 11
   expPer = selExpPeriod_;

   if (expPer == -1)
      return witFALSE;

   if (myBaMat_->useable ()[expPer])
      return witTRUE;

   if (myBaMat_->nextUseableExpPerExists (fillPeriod_, expPer))
      {
      selExpPeriod_ = expPer;
d696 1
a696 8
      return witTRUE;
      }
   else
      {
      selExpPeriod_ = -1;

      return witFALSE;
      }
@


1.20
log
@Re-factoring build-ahead for selection splitting.
@
text
@d46 1
a46 2
      splitFillPer_   (-1),
      searchFillPer_  (-1)
d126 1
a126 1
   resFound = witFALSE;
d131 1
a131 1
   theBaAltPt = theBaMat->myBaAltPt ()[expPer];
d187 1
a187 1
   if (! theBaMat->hasExpPer (fillPer, expPer))
d190 1
a190 1
   if (mySplitter ()->isSearchingAt (theBaMat->myBaAltPt ()[expPer]))
d207 1
d217 1
a217 1
   theBaMat   = myBaMat (theMat);
d221 1
a221 1
   theBaAltPt = NULL;
d223 1
a223 3
   if (theBaMat->hasExpPer (fillPer, expPer))
      {
      theBaAltPt = theBaMat->myBaAltPt ()[expPer];
d225 1
a225 3
      if (mySplitter ()->isSearchingAt (theBaAltPt))
         searchFillPer_ = fillPer;
      }
d228 2
a229 2
      splitSched_            (theMat, fillPer),
      itsTlPtr (selExpPeriod (theMat, fillPer)),
d240 3
a242 2
   WitTl *    theTlObj;
   WitBoolean splitFound;
d246 1
a246 1
   splitFound = findNextSplitAbs (theTlObj, splitExpVol);
d248 1
a248 1
   expPer     = itsPer (theTlObj);
d282 1
a282 1
            mySplitter ()->recordFlow (theBaMat->myBaAltPt ()[expPer], expVol);
d307 5
a311 1
void WitBaMgr::splitSelection (WitBaAltPt * theBaAltPt, double splitBound)
d313 1
a313 4
   WitMaterial * theMat;
   WitTl *       theTlObj;

   theMat   = theBaAltPt->myBaMat ()->myMaterial ();
d315 1
a315 1
   theTlObj = (WitTl *) myProblem ()->myFixedPer ()[theBaAltPt->expPeriod ()];
d317 1
a317 1
   splitSched_.slowAppend (theMat, searchFillPer_, theTlObj, splitBound);
d328 2
a329 2
         searchFillPer_,
         theBaAltPt->expPeriod (),
d379 2
d383 2
d393 1
a393 1
      itsPer (theTlObj));
d414 1
a414 1
   return theBaMat->hasExpPer (fillPer, expPer);
d452 3
a454 3
void WitNstnBaDir::initExpPeriod (
      WitMaterial *         theMat,
      WitTVec (WitPeriod) & expPeriodRef)
d458 1
a458 1
   witAssert (theMat->nstnBaNeeded ());
d461 1
a461 1
      expPeriodRef[fillPer] = fillPer;
d498 3
a500 3
void WitAsapBaDir::initExpPeriod (
      WitMaterial *         theMat,
      WitTVec (WitPeriod) & expPeriodRef)
d502 8
a509 3
   WitPeriod fillPer;
   WitPeriod firstStockPer;
   WitPeriod firstBaPer;
d511 1
a511 1
   witAssert (theMat->buildAsap ());
d515 1
a515 2
      if ((fillPer == 0) || (theMat->mandEC ()[fillPer - 1]))
         firstStockPer = fillPer;
d517 1
a517 1
      firstBaPer = fillPer - theMat->buildAheadUB ()[fillPer];
d519 2
a520 1
      expPeriodRef[fillPer] = max (firstStockPer, firstBaPer);
d547 1
a547 1
      expPeriod_   (myProblem (), -1)
d549 1
a549 1
   WitPeriod thePer;
d551 2
a552 2
   forEachPeriod (thePer, myProblem ())
      myBaAltPt_[thePer] = new WitBaAltPt (this, thePer);
d554 1
a554 1
   myBaDir_->initExpPeriod (myMaterial_, expPeriod_);
d561 1
a561 1
   WitPeriod thePer;
d563 2
a564 2
   forEachPeriod (thePer, myProblem ())
      delete myBaAltPt_[thePer];
d569 1
a569 1
WitBoolean WitBaMat::hasExpPer (WitPeriod fillPer, WitPeriod & expPer)
d571 1
a571 17
   expPer = expPeriod_[fillPer];

   if (expPer == -1)
      return witFALSE;

   if (myBaAltPt_[expPer]->useable ())
      return witTRUE;

   if (nextUseableExpPerExists (fillPer, expPer))
      {
      expPeriod_[fillPer] = expPer;

      return witTRUE;
      }
   else
      {
      expPeriod_[fillPer] = -1;
d573 1
a573 2
      return witFALSE;
      }
d583 1
a583 1
      if (myBaAltPt_[expPer]->useable ())
d593 2
a594 3
   WitPeriod    expPer;
   WitPeriod    fillPer;
   WitBaAltPt * theBaAltPt;
a602 3
      {
      theBaAltPt = myBaAltPt_[expPer];
      
d606 1
a606 2
         myMsgFac ().booleanText (theBaAltPt->useable ()));
      }  
d616 1
a616 1
      if (hasExpPer (fillPer, expPer))
d627 10
a636 6
WitBaAltPt::WitBaAltPt (WitBaMat * theBaMat, WitPeriod thePer):

      WitAltPt   (),
      myBaMat_   (theBaMat),
      expPeriod_ (thePer),
      useable_   (witFALSE)
a637 3
   witAssert (theBaMat != NULL);

   useable_ = theBaMat->myMaterial ()->explodeable (thePer);
d650 3
a652 1
   useable_ = witFALSE;
d659 5
a663 1
   myBaMat_->myBaDir ()->myBaMgr ()->splitSelection (this, splitBound);
d678 26
@


1.19
log
@Continued implementation of selection splitting with the new design.
@
text
@d16 3
a19 2
//    NstnMat.
//    AsapMat.
d24 1
d38 1
a38 1
      WitSelMgr      (theSelector, selSplitNeeded (theSelector->myProblem ())),
d40 8
a47 6
      myBaMatTl_     (myProblem (), NULL),
      expPairs_      (myProblem ()),
      splitSched_    (myProblem ()),
      splitExpMat_   (NULL),
      splitFillPer_  (-1),
      searchFillPer_ (-1)
d53 5
a57 2
   nstnMatExists = witFALSE;
   asapMatExists = witFALSE;
d64 1
a64 1
            myBaMat (theMat) = new WitNstnMat (theMat, this);
d71 1
a71 1
            myBaMat (theMat) = new WitAsapMat (theMat, this);
d95 3
d416 114
d533 19
d592 1
a592 1
   while (updatedExpPerIsValid (fillPer, expPer))
a638 94

WitBaMat::WitBaMat (WitMaterial * theMat, WitBaMgr * theBaMgr):
      WitProbAssoc (theMat),

      myMaterial_  (theMat),
      myBaMgr_     (theBaMgr),
      myBaAltPt_   (myProblem ()),
      expPeriod_   (myProblem (), -1)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      myBaAltPt_[thePer] = new WitBaAltPt (this, thePer);
   }

//------------------------------------------------------------------------------
// Implementation of class NstnMat.
//------------------------------------------------------------------------------

WitNstnMat::WitNstnMat (WitMaterial * theMat, WitBaMgr * theBaMgr):
      WitBaMat (theMat, theBaMgr)
   {
   WitPeriod fillPer;

   witAssert (myMaterial ()->nstnBaNeeded ());

   forEachPeriod (fillPer, myProblem ())
      expPeriod ()[fillPer] = fillPer;
   }

//------------------------------------------------------------------------------

WitNstnMat::~WitNstnMat ()
   {
   }

//------------------------------------------------------------------------------

WitBoolean WitNstnMat::updatedExpPerIsValid (
      WitPeriod   fillPer, 
      WitPeriod & expPer)
   {
   expPer --;

   if (expPer >= 0) 
      if (expPer >= fillPer - myMaterial ()->buildAheadUB ()[fillPer])
         if (! myMaterial ()->mandEC ()[expPer])
            return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------
// Implementation of class AsapMat.
//------------------------------------------------------------------------------

WitAsapMat::WitAsapMat (WitMaterial * theMat, WitBaMgr * theBaMgr):
      WitBaMat (theMat, theBaMgr)
   {
   WitPeriod fillPer;
   WitPeriod firstStockPer;
   WitPeriod firstBaPer;

   witAssert (myMaterial ()->buildAsap ());

   forEachPeriod (fillPer, myProblem ())
      {
      if ((fillPer == 0) || (myMaterial ()->mandEC ()[fillPer - 1]))
         firstStockPer = fillPer;

      firstBaPer = fillPer - myMaterial ()->buildAheadUB ()[fillPer];

      expPeriod ()[fillPer] = max (firstStockPer, firstBaPer);
      }
   }

//------------------------------------------------------------------------------

WitAsapMat::~WitAsapMat ()
   {
   }

//------------------------------------------------------------------------------

WitBoolean WitAsapMat::updatedExpPerIsValid (
      WitPeriod   fillPer, 
      WitPeriod & expPer)
   {
   expPer ++;

   return (expPer <= fillPer);
   }

//------------------------------------------------------------------------------
d671 1
a671 1
   myBaMat_->myBaMgr ()->splitSelection (this, splitBound);
@


1.18
log
@Continued implementation of selection splitting with the new design.
@
text
@d310 13
d376 3
a378 4
      "   Part:           %s\n"
      "   Fill Per:       %d\n"
      "   Selection:\n"
      "      Exp Period:  %d\n",
d466 2
a467 2
      "   Build-Ahead Material %s:\n\n"
      "       Exp Per   Useable?\n",
d475 1
a475 1
         "       %7d   %7s\n",
d482 1
a482 1
      "      Fill Per   Exp Per\n");
d486 1
a486 1
      fprintf (msgFile (), "      %8d", fillPer);
d627 1
a627 1
void WitBaAltPt::printSelection (WitSelector *)
@


1.17
log
@Continued implementation of selection splitting with the new design.
@
text
@d291 9
@


1.16
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d25 3
a29 4
#include <HeurAllP.h>
#include <AllMode.h>
#include <Selector.h>
#include <Splitter.h>
d36 1
a36 1
      WitSelMgr     (theSelector, selSplitNeeded (theSelector->myProblem ())),
d38 6
a43 5
      myBaMatTl_    (myProblem (), NULL),
      expPairs_     (myProblem ()),
      splitSched_   (myProblem ()),
      splitExpMat_  (NULL),
      splitFillPer_ (-1)
d161 13
d175 8
a182 4
   if (selSplit ())
      if (thePart->isaMaterial (theMat))
         if (myBaMat (theMat) != NULL)
            return ! splitSched_ (theMat, fillPer).isEmpty ();
d195 3
d205 16
d224 2
a225 1
      reqVol);
d256 1
a256 1
   WitBaAltPt *  theBaAltPt;
d265 1
a265 6
            if (fillPer > 0)
               expPairs_.push (
                  theMat, 
                  expPer, 
                  myProblem ()->myFixedPer ()[fillPer], 
                  expVol);
d267 5
a271 1
            theBaAltPt = theBaMat->myBaAltPt ()[expPer];
d273 3
a275 1
            mySelector ()->mySplitter ()->recordFlow (theBaAltPt, expVol);
d291 14
d595 7
@


1.15
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d30 1
d107 1
a107 1
      WitBopEntry *  theBopEnt,
d110 2
a111 2
      WitPeriod      fillPer,
      WitBoolean &   resFound)
d162 4
a165 5
   witAssert (selSplit ());

   if (thePart->isaMaterial (theMat))
      if (myBaMat (theMat) != NULL)
         return ! splitSched_ (theMat, fillPer).isEmpty ();
d218 7
d226 10
a235 1
   witAssert (selSplit ());
d237 3
a239 8
   if (fillPer > 0)
      if (thePart->isaMaterial (theMat))
         if (myBaMat (theMat) != NULL)
            expPairs_.push (
               theMat, 
               expPer, 
               myProblem ()->myFixedPer ()[fillPer], 
               expVol);
d550 7
@


1.14
log
@Further implementation of coarse selection splitting.
@
text
@a24 1
#include <Selector.h>
d29 1
d35 2
a36 2
WitBaMgr::WitBaMgr (WitHeurAllPerf * theHeurAllPerf):
      WitSelMgr     (theHeurAllPerf),
d233 1
a233 22
void WitBaMgr::postCommitSS (WitBoolean tempSuccess)
   {
   witAssert (selSplit ());

   if (tempSuccess)
      expPairs_.saveAndClear ();
   else
      expPairs_.clear ();
   }

//------------------------------------------------------------------------------

void WitBaMgr::preAltAttSS ()
   {
   witAssert (selSplit ());

   expPairs_.restore ();
   }

//------------------------------------------------------------------------------

void WitBaMgr::postAltAttSS ()
d242 1
a242 1
void WitBaMgr::postPermCommitSS ()
d244 1
a244 1
   witAssert (selSplit ());
d246 2
a247 4
   expPairs_  .clear ();
   expPairs_  .saveAndClear ();
   splitSched_.clear ();
   }
d249 3
a251 1
//------------------------------------------------------------------------------
d253 1
a253 22
void WitBaMgr::splitSel (WitMaterial * theMat, WitPeriod expPer)
   {
   WitPairStItr (WitFixedPer, double) theItr;
   WitFixedPer *                      fillFixedPer;
   double                             expVol;

   witAssert (selSplit ());

   const WitPairStack (WitFixedPer, double) & expPairStack = 
      expPairs_ (theMat, expPer);

   if (expPairStack.isEmpty ())
      return;

   theItr.attachTo (expPairStack);

   while (theItr.advance (fillFixedPer, expVol))
      splitSched_.slowAppend (
         theMat, 
         fillFixedPer->myPeriod (), 
         itsTlPtr (expPer), 
         expVol);
a412 7
void WitBaMat::splitSel (WitPeriod expPer)
   {
   myBaMgr_->splitSel (myMaterial_, expPer);
   }

//------------------------------------------------------------------------------

a530 3
   if (myBaMat_->myGlobalComp ()->selSplit ())
      myBaMat_->splitSel (expPeriod_);

@


1.13
log
@Further implementation of coarse selection splitting.
@
text
@d291 1
a291 1
      splitSched_.push (
@


1.12
log
@Removed coarse selection splitting for build-ahead in fill period 0.
@
text
@d319 1
a319 1
void WitBaMgr::adjustSplitVol (WitTl *, double &)
@


1.11
log
@Continued development of coarse selection splitting.
@
text
@d221 8
a228 7
   if (thePart->isaMaterial (theMat))
      if (myBaMat (theMat) != NULL)
         expPairs_.push (
            theMat, 
            expPer, 
            myProblem ()->myFixedPer ()[fillPer], 
            expVol);
@


1.10
log
@Further implementation of coarse selection splitting.
@
text
@d75 1
a75 1
   if (myGlobalComp ()->selSplit ())
d161 2
d200 2
d219 2
d234 2
d246 2
d255 2
d264 2
d279 2
d303 2
d320 1
d327 2
@


1.9
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d220 1
a220 1
            myProblem ()->samePerPtr (fillPer), 
d261 2
a262 2
   WitPairStItr (WitConstPer, double) theItr;
   const WitPeriod *                  fillPerPtr;
d265 1
a265 1
   const WitPairStack (WitConstPer, double) & expPairStack = 
d273 6
a278 2
   while (theItr.advance (fillPerPtr, expVol))
      splitSched_.push (theMat, * fillPerPtr, itsTlPtr (expPer), expVol);
@


1.8
log
@Further development of coarse selection splitting.
@
text
@d157 13
d185 1
a185 1
      aTlPtrTo (selExpPeriod (theMat, fillPer)),
d200 1
a200 1
   expPer     = pointedPer (theTlObj);
a258 13
WitBoolean WitBaMgr::selIsSplit (WitPart * thePart, WitPeriod fillPer)
   {
   WitMaterial * theMat;

   if (thePart->isaMaterial (theMat))
      if (myBaMat (theMat) != NULL)
         return ! splitSched_ (theMat, fillPer).isEmpty ();

   return witFALSE;
   }

//------------------------------------------------------------------------------

d274 1
a274 1
      splitSched_.push (theMat, * fillPerPtr, aTlPtrTo (expPer), expVol);
d313 1
a313 1
      pointedPer (theTlObj));
@


1.7
log
@Implemented and used class SelMgr.
@
text
@d36 1
a36 1
      WitSelMgr       (theHeurAllPerf),
d38 5
a42 8
      myBaMatTl_      (myProblem (), NULL),
      splitSched_     (myProblem ()),
      expPairs_       (myProblem ()),
      splitExpActive_ (witFALSE),
      splitExpMat_    (NULL),
      splitFillPer_   (-1),
      splitNetReqVol_ (0.0),
      splitList_      (myProblem ())
d162 1
a162 4
   WitMaterial *                      theMat;
   WitPairStItr (WitConstPer, double) theItr;
   const WitPeriod *                  thePerPtr;
   double                             splitVol;
d164 1
a164 3
   witAssert (! splitExpActive_);

   witAssert (! hadFinSplit ());
d166 1
a166 1
   witAssert (selIsSplit (thePart, fillPer));
d170 4
a173 10
   if (DEBUG_MODE)
      splitExpActive_ = witTRUE;

   splitExpMat_    = theMat;
   splitFillPer_   = fillPer;
   splitNetReqVol_ = reqVol;

   splitList_.clear ();

   theItr.attachTo (splitSched_ (theMat, fillPer));
d175 1
a175 2
   while (theItr.advance (thePerPtr, splitVol))
      splitList_.push (thePerPtr, splitVol);
d182 2
a183 3
   WitBoolean        finSplit;
   const WitPeriod * thePerPtr;
   double            splitVol;
d185 1
a185 2
   if (splitNetReqVol_ <= NET_TOL)
      return witFALSE;
d187 1
a187 19
   finSplit = splitList_.pop (thePerPtr, splitVol);

   expPer =
      finSplit?
         * thePerPtr:
         selExpPeriod (splitExpMat_, splitFillPer_);

   witAssert (splitExpMat_->explodeable (expPer));

   if (finSplit && (splitVol < splitNetReqVol_))
      {
      splitExpVol      = splitVol;
      splitNetReqVol_ -= splitVol;
      }
   else
      {
      splitExpVol     = splitNetReqVol_;
      splitNetReqVol_ = 0.0;
      }
d189 1
a189 18
   if (myGlobalComp ()->selPrintLevel () >= 4)
      prtSelSplit (expPer, finSplit, splitVol);

   setHadFinSplit (finSplit);

   return witTRUE;
   }
 
//------------------------------------------------------------------------------

void WitBaMgr::finishSplitExp ()
   {
   witAssert (splitExpActive_);

   setHadFinSplit (witFALSE);

   if (DEBUG_MODE)
      splitExpActive_ = witFALSE;
a261 1
   const WitPeriod *                  expPerPtr;
a270 2
   expPerPtr = myProblem ()->samePerPtr (expPer);

d274 1
a274 1
      splitSched_.push (theMat, * fillPerPtr, expPerPtr, expVol);
d296 1
a296 4
void WitBaMgr::prtSelSplit (
      WitPeriod  expPer, 
      WitBoolean finSplit,
      double     splitVol)
d298 1
a298 1
   witAssert (myGlobalComp ()->selPrintLevel () >= 4);
d300 1
a300 2
   if (myHeurAllPerf ()->myAllocMode ()->temp ())
      return;
d302 2
d307 2
a308 2
      "   Part:          %s\n"
      "   Fill Per:      %d\n"
d310 1
a310 1
      "      Exp Period: %d\n",
d313 1
a313 8
      expPer);
               
   if (finSplit)
      fprintf (msgFile (),
         "      SplitVol:   %.3f\n", splitVol);
   else
      fprintf (msgFile (),
         "      SplitVol:   Infinity\n");
@


1.6
log
@Fixed some bugs in coarse selection splitting.
@
text
@d28 2
d35 2
a36 2
WitBaMgr::WitBaMgr (WitProblem * theProblem):
      WitProbAssoc  (theProblem),
d38 8
a45 3
      myBaMatTl_    (myProblem (), NULL),
      mySplitSched_ (myProblem ()),
      expPairs_     (myProblem ())
d109 5
a113 3
      WitPart *    thePart,
      WitPeriod    fillPer,
      WitBoolean & resFound)
d121 1
a121 1
   if (! hasExpPer (thePart, fillPer, theBaMat, expPer))
d133 7
d160 86
d291 3
a293 3
   expPairs_    .clear ();
   expPairs_    .saveAndClear ();
   mySplitSched_.clear ();
d304 1
a304 1
         return ! mySplitSched_ (theMat, fillPer).isEmpty ();
d329 1
a329 1
      mySplitSched_.push (theMat, * fillPerPtr, expPerPtr, expVol);
d334 1
a334 4
void WitBaMgr::getSplitList (
      WitPart *        thePart,
      WitPeriod        fillPer,
      WitPerDblStack & splitList)
d336 1
a336 4
   WitMaterial *                      theMat;
   WitPairStItr (WitConstPer, double) theItr;
   const WitPeriod *                  thePerPtr;
   double                             splitVol;
d338 2
a339 1
   splitList.clear ();
d341 6
a346 10
   if (! thePart->isaMaterial (theMat))
      return;

   if (myBaMat (theMat) == NULL)
      return;

   theItr.attachTo (mySplitSched_ (theMat, fillPer));

   while (theItr.advance (thePerPtr, splitVol))
      splitList.push (thePerPtr, splitVol);
a351 2
      WitPart *  thePart, 
      WitPeriod  fillPer,
d358 3
d368 2
a369 2
      thePart->partName ().myCstring (),
      fillPer,
a377 17
   }

//------------------------------------------------------------------------------

void WitBaMgr::setupSelSplit ()
   {
   WitMaterial * theMat;

   mySplitSched_.allocate1D ();
   expPairs_    .allocate1D ();

   forEachMaterial (theMat, myProblem ())
      if (myBaMat (theMat) != NULL)
         {
         mySplitSched_.allocateRow (theMat);
         expPairs_    .allocateRow (theMat);
         }
@


1.5
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@a145 1
      WitPeriod fillPer, 
d147 2
a148 1
      double    expVol)
d154 1
a154 1
         expPairs_.put (
d196 13
d227 1
a227 1
      mySplitSched_.put (theMat, * fillPerPtr, expPerPtr, expVol);
d253 1
a253 1
      splitList.put (thePerPtr, splitVol);
d258 6
a263 1
void WitBaMgr::prtBpsSplitAt (WitPart * thePart, WitPeriod fillPer)
d269 5
a273 3
      "Build Period Selection Split:\n"
      "   Part:     %s\n"
      "   Fill Per: %d\n",
d275 2
a276 16
      fillPer);
   }

//------------------------------------------------------------------------------

void WitBaMgr::prtBpsSplitTo (
      WitPeriod  expPer, 
      WitBoolean splitFound,
      double     splitVol)
   {
   witAssert (myGlobalComp ()->selPrintLevel () >= 4);

   fprintf (msgFile (),
         "\n"
         "      Exp Period: %d\n",
         expPer);
d278 1
a278 1
   if (splitFound)
@


1.4
log
@Refactoring for selection splitting.
@
text
@d26 2
d34 1
a34 1
      WitProbAssoc (theProblem),
d36 3
a38 1
      myBaMatTl_   (myProblem (), NULL)
d52 1
a52 1
            myBaMat (theMat) = new WitNstnMat (theMat);
d59 1
a59 1
            myBaMat (theMat) = new WitAsapMat (theMat);
d70 3
a123 11
void WitBaMgr::print (WitBaAltPt * theBaAltPt)
   {
   WitMaterial * theMat;

   forEachMaterial (theMat, myProblem ())
      if (myBaMat (theMat) != NULL)
         myBaMat (theMat)->print (theBaAltPt);
   }

//------------------------------------------------------------------------------

d144 155
a321 15
WitBaMat::WitBaMat (WitMaterial * theMat):
      WitProbAssoc (theMat),

      myMaterial_  (theMat),
      myBaAltPt_   (myProblem ()),
      expPeriod_   (myProblem (), -1)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      myBaAltPt_[thePer] = new WitBaAltPt (this, thePer);
   }

//------------------------------------------------------------------------------

a370 15
void WitBaMat::print (WitBaAltPt * theBaAltPt)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      if (myBaAltPt_[thePer] == theBaAltPt)
         {
         print ();

         return;
         }
   }

//------------------------------------------------------------------------------

d409 23
d435 2
a436 2
WitNstnMat::WitNstnMat (WitMaterial * theMat):
      WitBaMat (theMat)
d472 2
a473 2
WitAsapMat::WitAsapMat (WitMaterial * theMat):
      WitBaMat (theMat)
d515 4
a518 3
      WitAltPt (),

      useable_ (witFALSE)
d535 3
d543 1
a543 1
void WitBaAltPt::printSelection (WitSelector * theSelector)
d545 1
a545 1
   theSelector->print (this);
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d108 1
a108 1
   theBaAltPt = theBaMat->myBaAltPt (expPer);
d175 1
a175 1
      myBaAltPtTl_ (myProblem (), NULL),
d181 1
a181 1
      myBaAltPtRef (thePer) = new WitBaAltPt (this, thePer);
d191 1
a191 1
      delete myBaAltPt (thePer);
d203 1
a203 1
   if (myBaAltPt (expPer)->useable ())
d227 1
a227 1
      if (myBaAltPt (expPer)->useable ())
d240 1
a240 1
      if (myBaAltPt (thePer) == theBaAltPt)
d264 1
a264 1
      theBaAltPt = myBaAltPt (expPer);
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d344 1
a344 1
      expPeriod ()[fillPer] = WitUtil::max (firstStockPer, firstBaPer);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

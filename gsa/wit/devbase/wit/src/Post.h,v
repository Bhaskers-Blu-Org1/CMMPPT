head	1.58;
access;
symbols
	sce_5_01_20080919:1.55
	latest_sce_4_20_20060523:1.37.0.2
	sce_4_20_20060523:1.37
	latest_sce4_20_OSL:1.36.0.2
	sce_4_20_OSL:1.36
	sce_410_withVa:1.34
	sce_4_05_20040511:1.33
	sce_4_00_20040201:1.23
	nextGenBranch:1.19.0.2
	nextGenRoot:1.19
	sce_3_30_20030627:1.19
	EndRw-branch:1.14.0.4
	Root-of-EndRw:1.14
	rwToStl:1.14.0.2
	latest_sce_3_10_20010924:1.4.0.6
	sce_3_10_20010924:1.4
	latest_sce_3_00_20010601:1.4.0.4
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.4.0.2
	sce_2_31_20010308:1.4
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2011.09.28.23.49.56;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2011.09.24.00.28.19;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2011.08.30.20.17.57;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.07.21.50.13;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.28.22.52.10;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.28.20.04.59;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.27.21.03.05;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.27.19.59.33;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.08.22.47.36;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.07.00.13.09;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.02.21.36.41;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.01.16.31.02;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.31.23.30.59;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.31.21.58.02;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.22.21.45.07;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.22.17.24.35;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2006.09.07.21.29.23;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2006.09.07.20.49.24;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2006.09.06.23.07.07;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2006.09.06.21.17.05;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2006.09.05.21.11.06;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.02.17.34.08;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.30.21.57.57;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.26.23.02.18;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.03.21.20.30;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.23.19.14.25;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.22.16.37.18;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.10.22.53.21;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.05.00.06.54;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.03.22.13.06;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.03.19.07.28;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.02.23.52.14;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.18.21.53.52;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.15.18.12.02;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.11.18.37.26;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.09.22.44.06;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.01.22.38.12;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.15.23.13.15;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.15.21.01.23;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.13.22.22.11;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.22.18.43;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.24.22.50.49;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.16.22.30.21;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.05.21.20.00;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.04.23.07.23;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.22.35.21;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.03.16.01.51;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.30.20.09.00;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.29.21.35.47;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.08.19.21.55;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.03.23.16.41;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.18.14.02.41;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.46;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.21.22.46;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.45;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef PostH
#define PostH

//------------------------------------------------------------------------------
// Header file: "Post.h"
//
// Contains the declaration of class Postprocessor.
//------------------------------------------------------------------------------

#include <Assoc.h>

//------------------------------------------------------------------------------
// class Postprocessor
//
// Responsible for performing postprocessing.
//------------------------------------------------------------------------------

class WitPostprocessor: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPostprocessor (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitPostprocessor ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void postprocess ();
         //
         // Performs postprocessing based on the current production and
         // shipment schedules and myProblem ()->currentVariant ().

      void unpostprocess ();
         //
         // Does unpostprocessing for myProblem ().

      void compNonSubVol (
            WitBomEntry *      theBomEnt,
            WitTVec <double> & nonSubVolVec);
         //
         // Computes the value for theBomEnt->nonSubVol_[execPer] and stores it
         // in nonSubVolVec.

      void compProdVol (WitPart * thePart, WitTVec <double> & prodVolVec);
         //
         // Computes the value for thePart->prodVol and stores it in prodVolVec.

      double compExcessVol (WitPart * thePart, WitPeriod thePer);
         //
         // Computes and returns the excessVol for thePart in thePer.
         // This is the amount by which thePart->supplyVol ()[thePer] could be
         // decreased while keeping the solution feasible.
         // Valid only in postprocessed mode.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool,          postprocessing)
      accessFunc (bool,          postprocessed)
      accessFunc (WitFeasChkr *, myFeasChkr)

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPostprocessor);

      void compNonSubVols ();
         //
         // Computes nonSubVol_ for each BomEntry.

      void compConsVols ();
         //
         // Computes consVol for each Part.

      void compProdVols ();
         //
         // Computes prodVol for each Part.

      void compCapacityScrapVols ();
         //
         // Computes scrapVol for each Capacity.

      void compMaterialStockScrapVols ();
         //
         // Computes stockVol and scrapVol for each Material.

      double unstockedScrapVol (WitPart * thePart, WitPeriod t);
         //
         // Computes and returns what thePart->scrapVol ()[t] would be if
         // stocking were not allowed. (May return a negative number.)

      void compCumShipVols ();
         //
         // Computes cumShipVol_ for each Demand.

      void compCapResidVols ();
         //
         // Computes residualVol_ for each Capacity.

      void compMatResidVolsAsap ();
         //
         // Computes residualVol_ for each Material in nstnResidual == false
         // mode.

      void compMatResidVolsNstn ();
         //
         // Computes residualVol_ for each Material in nstnResidual == true
         // mode.

      double compCumConsVol (
            WitMaterial *      theMat, 
            WitTVec <double> & unstockConsVol);
         //
         // Computes and returns the cumulative generalized consumption volume
         // for theMat in period 0.
         // Stores the portion that cannot be carried over as stock in each
         // period in unstockConsVol.

      double stockBndGap (
            WitMaterial * theMat,
            WitPeriod     thePer,
            bool &        gapIsFinite);
         //
         // Returns the gap between the upper and lower bounds and stock for
         // theMat in thePer.
         // On return, gapIsFinite is true, iff the gap is finite.
         //    If it is false, the return valued is to be ignored.

      double stockLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Returns min (stock softLB, stockVol).

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      bool postprocessing_;
         //
         // true, iff postprocessing is currently being performed.

      bool postprocessed_;
         //
         // true, iff postprocessing has been performed and the
         // input data and implosion solution has not been updated since.

      WitFeasChkr * myFeasChkr_;
         //
         // The FeasChkr owned by this Postprocessor.
   };

#endif
@


1.57
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.56
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d28 2
a29 2
{
public:
d31 144
a174 144
//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitPostprocessor (WitProblem * theProblem);
//
// ProbAssoc <<< theProblem.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitPostprocessor ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void postprocess ();
//
// Performs postprocessing based on the current production and
// shipment schedules and myProblem ()->currentVariant ().

void unpostprocess ();
//
// Does unpostprocessing for myProblem ().

void compNonSubVol (
WitBomEntry *      theBomEnt,
WitTVec <double> & nonSubVolVec);
//
// Computes the value for theBomEnt->nonSubVol_[execPer] and stores it
// in nonSubVolVec.

void compProdVol (WitPart * thePart, WitTVec <double> & prodVolVec);
//
// Computes the value for thePart->prodVol and stores it in prodVolVec.

double compExcessVol (WitPart * thePart, WitPeriod thePer);
//
// Computes and returns the excessVol for thePart in thePer.
// This is the amount by which thePart->supplyVol ()[thePer] could be
// decreased while keeping the solution feasible.
// Valid only in postprocessed mode.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (bool,          postprocessing)
accessFunc (bool,          postprocessed)
accessFunc (WitFeasChkr *, myFeasChkr)

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitPostprocessor);

void compNonSubVols ();
//
// Computes nonSubVol_ for each BomEntry.

void compConsVols ();
//
// Computes consVol for each Part.

void compProdVols ();
//
// Computes prodVol for each Part.

void compCapacityScrapVols ();
//
// Computes scrapVol for each Capacity.

void compMaterialStockScrapVols ();
//
// Computes stockVol and scrapVol for each Material.

double unstockedScrapVol (WitPart * thePart, WitPeriod t);
//
// Computes and returns what thePart->scrapVol ()[t] would be if
// stocking were not allowed. (May return a negative number.)

void compCumShipVols ();
//
// Computes cumShipVol_ for each Demand.

void compCapResidVols ();
//
// Computes residualVol_ for each Capacity.

void compMatResidVolsAsap ();
//
// Computes residualVol_ for each Material in nstnResidual == false
// mode.

void compMatResidVolsNstn ();
//
// Computes residualVol_ for each Material in nstnResidual == true
// mode.

double compCumConsVol (
WitMaterial *      theMat,
WitTVec <double> & unstockConsVol);
//
// Computes and returns the cumulative generalized consumption volume
// for theMat in period 0.
// Stores the portion that cannot be carried over as stock in each
// period in unstockConsVol.

double stockBndGap (
WitMaterial * theMat,
WitPeriod     thePer,
bool &        gapIsFinite);
//
// Returns the gap between the upper and lower bounds and stock for
// theMat in thePer.
// On return, gapIsFinite is true, iff the gap is finite.
//    If it is false, the return valued is to be ignored.

double stockLB (WitMaterial * theMat, WitPeriod thePer);
//
// Returns min (stock softLB, stockVol).

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

bool postprocessing_;
//
// true, iff postprocessing is currently being performed.

bool postprocessed_;
//
// true, iff postprocessing has been performed and the
// input data and implosion solution has not been updated since.

WitFeasChkr * myFeasChkr_;
//
// The FeasChkr owned by this Postprocessor.
};
@


1.55
log
@Stochastic Implosion
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d28 2
a29 2
   {
   public:
d31 144
a174 144
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPostprocessor (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitPostprocessor ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void postprocess ();
         //
         // Performs postprocessing based on the current production and
         // shipment schedules and myProblem ()->currentVariant ().

      void unpostprocess ();
         //
         // Does unpostprocessing for myProblem ().

      void compNonSubVol (
            WitBomEntry *      theBomEnt,
            WitTVec <double> & nonSubVolVec);
         //
         // Computes the value for theBomEnt->nonSubVol_[execPer] and stores it
         // in nonSubVolVec.

      void compProdVol (WitPart * thePart, WitTVec <double> & prodVolVec);
         //
         // Computes the value for thePart->prodVol and stores it in prodVolVec.

      double compExcessVol (WitPart * thePart, WitPeriod thePer);
         //
         // Computes and returns the excessVol for thePart in thePer.
         // This is the amount by which thePart->supplyVol ()[thePer] could be
         // decreased while keeping the solution feasible.
         // Valid only in postprocessed mode.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool,          postprocessing)
      accessFunc (bool,          postprocessed)
      accessFunc (WitFeasChkr *, myFeasChkr)

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPostprocessor);

      void compNonSubVols ();
         //
         // Computes nonSubVol_ for each BomEntry.

      void compConsVols ();
         //
         // Computes consVol for each Part.

      void compProdVols ();
         //
         // Computes prodVol for each Part.

      void compCapacityScrapVols ();
         //
         // Computes scrapVol for each Capacity.

      void compMaterialStockScrapVols ();
         //
         // Computes stockVol and scrapVol for each Material.

      double unstockedScrapVol (WitPart * thePart, WitPeriod t);
         //
         // Computes and returns what thePart->scrapVol ()[t] would be if
         // stocking were not allowed. (May return a negative number.)

      void compCumShipVols ();
         //
         // Computes cumShipVol_ for each Demand.

      void compCapResidVols ();
         //
         // Computes residualVol_ for each Capacity.

      void compMatResidVolsAsap ();
         //
         // Computes residualVol_ for each Material in nstnResidual == false
         // mode.

      void compMatResidVolsNstn ();
         //
         // Computes residualVol_ for each Material in nstnResidual == true
         // mode.

      double compCumConsVol (
            WitMaterial *      theMat, 
            WitTVec <double> & unstockConsVol);
         //
         // Computes and returns the cumulative generalized consumption volume
         // for theMat in period 0.
         // Stores the portion that cannot be carried over as stock in each
         // period in unstockConsVol.

      double stockBndGap (
            WitMaterial * theMat,
            WitPeriod     thePer,
            bool &        gapIsFinite);
         //
         // Returns the gap between the upper and lower bounds and stock for
         // theMat in thePer.
         // On return, gapIsFinite is true, iff the gap is finite.
         //    If it is false, the return valued is to be ignored.

      double stockLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Returns min (stock softLB, stockVol).

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      bool postprocessing_;
         //
         // true, iff postprocessing is currently being performed.

      bool postprocessed_;
         //
         // true, iff postprocessing has been performed and the
         // input data and implosion solution has not been updated since.

      WitFeasChkr * myFeasChkr_;
         //
         // The FeasChkr owned by this Postprocessor.
   };
@


1.54
log
@[disallowed backlog]
@
text
@d59 2
a60 2
            WitBomEntry *   theBomEnt,
            WitDblFlexVec & nonSubVolVec);
d80 2
a82 1
      accessFunc (bool,          postprocessed)
d162 1
a162 1
      WitFeasChkr * myFeasChkr_;
d164 1
a164 1
         // The FeasChkr owned by this Postprocessor.
d170 4
@


1.53
log
@[disallowed backlog]
@
text
@d116 4
@


1.52
log
@[disallowed backlog]
@
text
@a76 14
      // Functions for receiving data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      //------------------------------------------------------------------------

      static void receiveDMPs (WitDblFlexVec     WitPart::* consVolArg,
                               WitDblFlexVec     WitPart::* prodVolArg,
                               WitDblFlexVec     WitPart::* scrapVolArg,
                               WitDblFlexVec     WitPart::* residualVolArg);
      static void receiveDMPs (WitDblFlexVec WitMaterial::* stockVolArg);
      static void receiveDMPs (WitDblFlexVec   WitDemand::* cumShipVolArg,
                               WitDblFlexVec   WitDemand::* fssShipVolArg);
                                                 
      //------------------------------------------------------------------------
a156 19
      //------------------------------------------------------------------------
      // Data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      // E.g., thePart->*consVol_ == thePart->consVol_.
      //------------------------------------------------------------------------

      static WitDblFlexVec     WitPart::* consVol_;
      static WitDblFlexVec     WitPart::* prodVol_;
      static WitDblFlexVec     WitPart::* scrapVol_;
      static WitDblFlexVec     WitPart::* residualVol_;
      static WitDblFlexVec WitMaterial::* stockVol_;
      static WitDblFlexVec   WitDemand::* cumShipVol_;
      static WitDblFlexVec   WitDemand::* fssShipVol_;

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

d159 1
a159 1
         // The FesChkr owned by this Postprocessor.
@


1.51
log
@Rescinded all changed made since 1/31/07.
@
text
@a88 1
      static void receiveDMPs (WitDblFlexVec WitBomEntry::* nonSubVolArg);
a184 1
      static WitDblFlexVec WitBomEntry::* nonSubVol_;
@


1.50
log
@[disallowed backlog]
@
text
@d82 7
a130 4
      void compCumShipVols ();
         //
         // Computes cumShipVol for each Demand, as needed.

d179 7
@


1.49
log
@[disallowed backlog]
@
text
@a81 3
      static void receiveDMPs (WitDblFlexVec WitMaterial::* stockVolArg);
      static void receiveDMPs (WitDblFlexVec   WitDemand::* cumShipVolArg,
                               WitDblFlexVec   WitDemand::* fssShipVolArg);
a175 3
      static WitDblFlexVec WitMaterial::* stockVol_;
      static WitDblFlexVec   WitDemand::* cumShipVol_;
      static WitDblFlexVec   WitDemand::* fssShipVol_;
@


1.48
log
@Disallowed backlog.
@
text
@a81 3
      static void receiveDMPs (WitDblFlexVec     WitPart::* consVolArg,
                               WitDblFlexVec     WitPart::* scrapVolArg,
                               WitDblFlexVec     WitPart::* residualVolArg);
a178 3
      static WitDblFlexVec     WitPart::* consVol_;
      static WitDblFlexVec     WitPart::* scrapVol_;
      static WitDblFlexVec     WitPart::* residualVol_;
@


1.47
log
@[disAllowed backlog]
@
text
@d82 1
a82 2
      static void receiveDMPs (WitDblFlexVec     WitPart::* prodVolArg,
                               WitDblFlexVec     WitPart::* consVolArg,
a181 1
      static WitDblFlexVec     WitPart::* prodVol_;
@


1.46
log
@[backlog avoidance]
@
text
@d82 2
a83 1
      static void receiveDMPs (WitDblFlexVec     WitPart::* consVolArg,
d183 1
@


1.45
log
@[backlog avoidance]
@
text
@d130 4
@


1.44
log
@external opt implosion.
@
text
@a82 1
                               WitDblFlexVec     WitPart::* prodVolArg,
a178 1
      static WitDblFlexVec     WitPart::* prodVol_;
@


1.43
log
@External optimizing implosion.
@
text
@a57 5
      void verifyUhsFeas ();
         //
         // Verifies the feasibility of the current solution, assuming that it
         // is the user-specified heuristic starting solution.

d82 8
a89 9
      static void receiveDMPs (WitDblFlexVec       WitPart::* consVolArg,
                               WitDblFlexVec       WitPart::* prodVolArg,
                               WitDblFlexVec       WitPart::* scrapVolArg,
                               WitDblFlexVec       WitPart::* residualVolArg);
      static void receiveDMPs (WitDblFlexVec   WitMaterial::* stockVolArg);
      static void receiveDMPs (WitDblFlexVec     WitDemand::* cumShipVolArg,
                               WitDblFlexVec     WitDemand::* fssShipVolArg);
      static void receiveDMPs (WitDblFlexVec   WitBomEntry::* nonSubVolArg);
      static void receiveDMPs (bool          WitGlobalComp::* feasibleArg);
d95 2
a96 3
      accessFunc (bool,   postprocessed)
      accessFunc (double, maxViolation)
      accessFunc (bool,   reportIncViol)
a105 4
      bool solnIsNonnegative ();
         //
         // Returns true, iff the implosion solution is all non-negative.

a167 89
      void compFeasible ();
         //
         // Computes maxViolation_, feasible_.

      void checkFeasReq ();
         //
         // Records as maxViolation: max violation of all "required"
         // contraints, i.e., those that apply regardless of the Variant.

      void checkScrapVolNonneg   ();
      void checkStockVolNonneg   ();
      void checkExecVolNonneg    ();
      void checkSubVolNonneg     ();
      void checkShipVolNonneg    ();
      void checkCumShipVolNonneg ();
         // 
         // Records violations of nonnegativity for each solution attribute.

      void checkStockVols ();
         //
         // Records violations of stockVol == 0, when stock is not allowed.

      void checkExecVols ();
         //
         // Records violations of execVol == 0, when the operation is not
         // executable.

      void checkNonSubVols ();
         //
         // Records violations of nonSubVol >= 0.

      void checkCumShipVols ();
         //
         // Records violations of cumShipVol <= cumDemandVol.

      void checkFeasAllBounds ();
         //
         // Records max bound violation for all bounds.

      void checkFeasLimitedBounds ();
         //
         // Records:
         //    max bound violation for the "limited" subset of bounds
         //    (those respected by heuristic implosion).

      void checkFeasHardLB (const WitBoundSet * theBoundSet);
         //
         // Records hard LB violation for theBoundset.

      void checkFeasHardUB (const WitBoundSet * theBoundSet);
         //
         // Records hard UB violation for theBoundset.

      void checkFeasLotSizes ();
         //
         // Records max lot size violation.

      void checkIntegrality ();
         //
         // Records max integrality violation.

      void recordViolation (double theViolation, bool & reportNeeded);
         //
         // maxViolation_ = max (maxViolation_, theViolation)
         // On return, reportNeeded is true, iff an increase to maxViolation_ is
         // to be reported.

      void verifyUhsNonExecCon ();
      void verifyUhsSubCon ();
      void verifyUhsCumDemandCon ();
      void verifyUhsExecHUBCon ();
      void verifyUhsLotSizeCon ();
         //
         // Each of these function tests the current solution for satisfaction
         // of a specific class of constraints, assuming that the current
         // solution is the user-specified heuristic starting solution.
         // If a violation is found, a warning is issued.
         // Exception: In verifyUhsNonExecCon, if a violation is found, a severe
         // error is issued.

      double lotSizeViol (WitOperation * theOpn, WitPeriod execPer);
         //
         // Computes and returns the amount by which theOpn->execVol ()[execPer]
         // violates the lot-size constraint.

      double integralityViolation (double theValue);
         //
         // Returns the distance from theValue to the nearest integer.

d179 8
a186 9
      static WitDblFlexVec       WitPart::* consVol_;
      static WitDblFlexVec       WitPart::* prodVol_;
      static WitDblFlexVec       WitPart::* scrapVol_;
      static WitDblFlexVec       WitPart::* residualVol_;
      static WitDblFlexVec   WitMaterial::* stockVol_;
      static WitDblFlexVec     WitDemand::* cumShipVol_;
      static WitDblFlexVec     WitDemand::* fssShipVol_;
      static WitDblFlexVec   WitBomEntry::* nonSubVol_;
      static bool          WitGlobalComp::* feasible_;
d192 4
a199 10

      double maxViolation_;
         //
         // The maximum constraint violation in the solution.

      bool reportIncViol_;
         //
         // Development control parameter.
         // If true, postprocessing will print each constraint violation that
         // increases the value of maxViolation_.
@


1.42
log
@NSTN residualVol.
@
text
@d188 26
d226 1
a226 1
         // Records hard LB violation for theBoundset)
d230 1
a230 1
         // Records hard UB violation for theBoundset)
d234 1
a234 1
         // Records max lot size violation)
d236 1
a236 1
      bool recordViolation (double theViolation);
d238 1
a238 2
         // maxViolation_ = max (maxViolation_, theViolation)
         // Returns true, iff an increase to maxViolation_ is to be reported.
d240 1
a240 1
      void displayViolConstraint (WitMsgFragID theFragID);
d242 3
a244 2
         // Issues a msg indicating the nature of a violated constaint.
         // theFragID indicates the constraint.
d264 4
@


1.41
log
@NSTN residualVol.
@
text
@d151 1
a151 1
      void compMatResidVolsNstnV1 ();
a154 1
         // Version 1: Incremental stock lower bounds are used.
d156 1
a156 20
      double compCumConsVolV1 (
            WitMaterial *      theMat, 
            WitTVec <double> & unstockConsVol);
         //
         // Computes and returns the cumulative generalized consumption volume
         // for theMat in period 0.
         // Stores the portion that cannot be carried over as stock in each
         // period in unstockConsVol.

      double incStockLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Returns the stockLB[thePer] - stockLB[thePer - 1].

      void compMatResidVolsNstnV2 ();
         //
         // Computes residualVol_ for each Material in nstnResidual == true
         // mode.
         // Version 2: Absolute stock lower bounds are used.

      double compCumConsVolV2 (
@


1.40
log
@NSTN residualVol.
@
text
@d155 1
d174 1
@


1.39
log
@NSTN residualVol.
@
text
@d151 1
a151 1
      void compMatResidVolsNstn ();
d156 1
a156 1
      double compCumConsVol (
d165 32
a255 17
      double incStockLB (WitPart * thePart, WitPeriod thePer);
         //
         // Returns the stockLB[thePer] - stockLB[thePer - 1], where:
         //    stockLB[thePer] = 0, if thePart is a Capacity.
         //                    = 0, if thePer == -1
         //                    = min (stock softLB, stockVol), otherwise.

      double stockBndGap (
            WitMaterial * theMat,
            WitPeriod     thePer,
            bool &        gapIsFinite);
         //
         // Returns the gap between the upper and lower bounds and stock for
         // theMat in thePer.
         // On return, gapIsFinite is true, iff the gap is finite.
         //    If it is false, the return valued is to be ignored.

@


1.38
log
@NSTN residualVols
@
text
@d156 9
d226 1
a226 2
         // Computes and returns the stockLB[thePer] - stockLB[thePer - 1],
         // where:
d231 10
@


1.37
log
@Updated the copyright date on all source files.
@
text
@d74 7
d89 3
a91 3
                               WitDblFlexVec       WitPart::* scrapVolArg);
      static void receiveDMPs (WitDblFlexVec   WitMaterial::* stockVolArg,
                               WitDblFlexVec   WitMaterial::* residualVolArg);
d142 5
a146 1
      void compResidualVols ();
d148 7
a154 1
         // Computes residualVol_ for each Part.
d215 8
d237 1
a238 1
      static WitDblFlexVec   WitMaterial::* residualVol_;
@


1.36
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.35
log
@[multi-thread]
@
text
@a19 2
#include <RefMap.h>
#include <Ref.h>
a31 5
      //------------------------------------------------------------------------

      static void receiveData (WitDblFlexVec WitPart::* consVolPtrArg);

      //------------------------------------------------------------------------
d75 3
a77 1
      // Data loading functions.
d80 10
a89 23
      void loadDataFrom (
            WitPart *       thePart,
            WitDblFlexVec & consVolArg,
            WitDblFlexVec & prodVolArg,
            WitDblFlexVec & scrapVolArg);

      void loadDataFrom (
            WitMaterial *   theMat,
            WitDblFlexVec & stockVolArg,
            WitDblFlexVec & residualVolArg);

      void loadDataFrom (
            WitDemand *     theDemand,
            WitDblFlexVec & cumShipVolArg,
            WitDblFlexVec & fssShipVolArg);

      void loadDataFrom (
            WitBomEntry *   theBomEnt,
            WitDblFlexVec & nonSubVolArg);

      void loadDataFromGlobalComp (
            bool                & feasibleArg);

a105 8
      void loadData ();
         //
         // Loads the data to be loaded from the components.

      void clearLoadedData ();
         //
         // Clears the data that was loaded from the components.

d203 4
a206 15
      // Mappings to data loaded in from Components.
      //------------------------------------------------------------------------

      WitRefMap <WitPart,     WitDblFlexVec> consVol_;
      WitRefMap <WitPart,     WitDblFlexVec> prodVol_;
      WitRefMap <WitPart,     WitDblFlexVec> scrapVol_;
      WitRefMap <WitMaterial, WitDblFlexVec> stockVol_;
      WitRefMap <WitMaterial, WitDblFlexVec> residualVol_;
      WitRefMap <WitDemand,   WitDblFlexVec> cumShipVol_;
      WitRefMap <WitDemand,   WitDblFlexVec> fssShipVol_;
      WitRefMap <WitBomEntry, WitDblFlexVec> nonSubVol_;

      WitRef    <bool>                       feasible_;

      //------------------------------------------------------------------------
d209 9
a217 1
      static WitDblFlexVec WitPart::* consVolPtr_;
@


1.34
log
@pegged Critical List.
@
text
@d34 5
a52 8
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool,   postprocessed)
      accessFunc (double, maxViolation)
      accessFunc (bool,   reportIncViol)

      //------------------------------------------------------------------------
d108 8
d244 5
@


1.33
log
@Double Precision.
@
text
@d236 1
a236 1
      WitRef    <bool>                              feasible_;
@


1.32
log
@Double Precision.
@
text
@d74 2
a75 2
            WitBomEntry *         theBomEnt,
            WitFlexVec <double> & nonSubVolVec);
d89 4
a92 4
            WitPart *             thePart,
            WitFlexVec <double> & consVolArg,
            WitFlexVec <double> & prodVolArg,
            WitFlexVec <double> & scrapVolArg);
d95 3
a97 3
            WitMaterial *         theMat,
            WitFlexVec <double> & stockVolArg,
            WitFlexVec <double> & residualVolArg);
d100 3
a102 3
            WitDemand *           theDemand,
            WitFlexVec <double> & cumShipVolArg,
            WitFlexVec <double> & fssShipVolArg);
d105 2
a106 2
            WitBomEntry *         theBomEnt,
            WitFlexVec <double> & nonSubVolArg);
d227 8
a234 8
      WitRefMap <WitPart,     WitFlexVec <double> > consVol_;
      WitRefMap <WitPart,     WitFlexVec <double> > prodVol_;
      WitRefMap <WitPart,     WitFlexVec <double> > scrapVol_;
      WitRefMap <WitMaterial, WitFlexVec <double> > stockVol_;
      WitRefMap <WitMaterial, WitFlexVec <double> > residualVol_;
      WitRefMap <WitDemand,   WitFlexVec <double> > cumShipVol_;
      WitRefMap <WitDemand,   WitFlexVec <double> > fssShipVol_;
      WitRefMap <WitBomEntry, WitFlexVec <double> > nonSubVol_;
@


1.31
log
@Double Precision.
@
text
@d90 3
a92 3
            WitRealVec &          consVolArg,
            WitRealVec &          prodVolArg,
            WitRealVec &          scrapVolArg);
d96 2
a97 2
            WitRealVec &          stockVolArg,
            WitRealVec &          residualVolArg);
d101 2
a102 2
            WitRealVec &          cumShipVolArg,
            WitRealVec &          fssShipVolArg);
d227 7
a233 7
      WitRefMap <WitPart,     WitRealVec          > consVol_;
      WitRefMap <WitPart,     WitRealVec          > prodVol_;
      WitRefMap <WitPart,     WitRealVec          > scrapVol_;
      WitRefMap <WitMaterial, WitRealVec          > stockVol_;
      WitRefMap <WitMaterial, WitRealVec          > residualVol_;
      WitRefMap <WitDemand,   WitRealVec          > cumShipVol_;
      WitRefMap <WitDemand,   WitRealVec          > fssShipVol_;
@


1.30
log
@Double Precision.
@
text
@d96 1
a96 1
            WitRealTVc &          stockVolArg,
d101 2
a102 2
            WitRealVec  &         cumShipVolArg,
            WitRealTVc &          fssShipVolArg);
d230 1
a230 1
      WitRefMap <WitMaterial, WitRealTVc          > stockVol_;
d233 1
a233 1
      WitRefMap <WitDemand,   WitRealTVc          > fssShipVol_;
@


1.29
log
@Double Precision.
@
text
@d96 1
a96 1
            WitRealVec &          stockVolArg,
d102 1
a102 1
            WitRealVec &          fssShipVolArg);
d230 1
a230 1
      WitRefMap <WitMaterial, WitRealVec          > stockVol_;
d233 1
a233 1
      WitRefMap <WitDemand,   WitRealVec          > fssShipVol_;
@


1.28
log
@Double Precision.
@
text
@d51 3
a53 3
      accessFunc (bool,  postprocessed)
      accessFunc (float, maxViolation)
      accessFunc (bool,  reportIncViol)
d191 1
a191 1
      bool recordViolation (float theViolation);
d247 1
a247 1
      float maxViolation_;
@


1.27
log
@Double Precision.
@
text
@d101 1
a101 1
            WitFlexVec <float>  & cumShipVolArg,
d232 1
a232 1
      WitRefMap <WitDemand,   WitFlexVec <float>  > cumShipVol_;
@


1.26
log
@Double Precision.
@
text
@d102 1
a102 1
            WitTVec    <float>  & fssShipVolArg);
d233 1
a233 1
      WitRefMap <WitDemand,   WitTVec    <float>  > fssShipVol_;
@


1.25
log
@Double Precision.
@
text
@d91 2
a92 2
            WitFlexVec <float>  & prodVolArg,
            WitFlexVec <float>  & scrapVolArg);
d96 2
a97 2
            WitTVec    <float>  & stockVolArg,
            WitFlexVec <float>  & residualVolArg);
d228 4
a231 4
      WitRefMap <WitPart,     WitFlexVec <float>  > prodVol_;
      WitRefMap <WitPart,     WitFlexVec <float>  > scrapVol_;
      WitRefMap <WitMaterial, WitTVec    <float>  > stockVol_;
      WitRefMap <WitMaterial, WitFlexVec <float>  > residualVol_;
@


1.24
log
@Replaced the severe error for most constraint violations in the
   user-specified heuristic starting solution with a warning.
@
text
@d90 1
a90 1
            WitFlexVec <float>  & consVolArg,
d227 1
a227 1
      WitRefMap <WitPart,     WitFlexVec <float>  > consVol_;
@


1.23
log
@Continued implementation of PIP.
@
text
@d210 3
@


1.22
log
@Continued implementation of PIP.
@
text
@a254 22
//------------------------------------------------------------------------------
// NonClass function template incConsVol.
//
// Assumes:
//    consVolArg is a  consVol vector for theConsEnt->myPart ().
//    execVolArg is an execVol vector for theConsEnt-> myOperation ().
// Increments consVolArg corresponding to consumption due to theConsEntry 
// resulting from execVolArg.
//------------------------------------------------------------------------------

namespace WitNonClass
{

template <typename VecType> 
   void incConsVol (
      WitConsEntry *     theConsEnt,
      WitTVec <double> & consVolArg,
      const VecType    & execVolArg);

// Leaving namespace NonClass.
}

@


1.21
log
@Continued implementation of PIP.
@
text
@d266 10
a275 7
   {
   template <typename VecType> 
      void incConsVol (
         WitConsEntry *     theConsEnt,
         WitTVec <double> & consVolArg,
         const VecType    & execVolArg);
   }
@


1.20
log
@Continued implementation of PIP.
@
text
@d19 1
a19 4
#include <Demand.h>
#include <Global.h>
#include <Material.h>
#include <BomEntry.h>
d256 1
a256 1
// Global function template incConsVol.
d265 3
a267 1
template <typename VecType> 
d271 1
a271 8
         const VecType    & execVolArg)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, theConsEnt->myProblem ())
      if (theConsEnt->inEffect (thePer))
         consVolArg[theConsEnt->impactPeriod ()[thePer]] += 
            theConsEnt->effConsRate ()[thePer] * execVolArg[thePer];
@


1.19
log
@Tried to fix some syntax errors from the MS compiler.
@
text
@d268 1
a268 1
template <class VecType> 
@


1.18
log
@Various internal changes.
@
text
@a86 14
      template <typename VecType> 
         void incConsVol (
            WitConsEntry *     theConsEnt,
            WitTVec <double> & consVolArg,
            const VecType    & execVolArg);
         //
         // Assumes:
         //    consVolArg is a  consVol vector for theConsEnt->myPart ().
         //    execVolArg is an execVol vector for theConsEnt->myOperation ().
         // Increments consVolArg corresponding to consumption due to 
         // theConsEntry resulting from execVolArg.
         //
         // Implemented in this file.

d259 7
a265 1
// Implementation of template functions.
d268 2
a269 2
template <typename VecType> 
      void WitPostprocessor::incConsVol (
d276 1
a276 1
   forEachPeriod (thePer, myProblem ())
@


1.17
log
@Various internal changes.
@
text
@d87 14
d273 1
a273 7
// Global function template incConsVol.
//
// Assumes:
//    consVolArg is a  consVol vector for theConsEnt->myPart ().
//    execVolArg is an execVol vector for theConsEnt-> myOperation ().
// Increments consVolArg corresponding to consumption due to theConsEntry 
// resulting from execVolArg.
d277 1
a277 1
      void incConsVol (
d284 1
a284 1
   forEachPeriod (thePer, theConsEnt->myProblem ())
@


1.16
log
@Internal changes.
@
text
@d268 1
a268 1
template <class VecType> 
@


1.15
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d54 3
a56 3
      accessFunc (WitBoolean, postprocessed)
      accessFunc (float,      maxViolation)
      accessFunc (WitBoolean, reportIncViol)
d112 1
a112 1
            WitBoolean          & feasibleArg);
d130 1
a130 1
      WitBoolean solnIsNonnegative ();
d132 1
a132 1
         // Returns TRUE, iff the implosion solution is all non-negative.
d194 1
a194 1
      WitBoolean recordViolation (float theViolation);
d197 1
a197 1
         // Returns TRUE, iff an increase to maxViolation_ is to be reported.
d236 1
a236 1
      WitRef    <WitBoolean>                        feasible_;
d242 1
a242 1
      WitBoolean postprocessed_;
d244 1
a244 1
         // TRUE, iff postprocessing has been performed and the
d251 1
a251 1
      WitBoolean reportIncViol_;
d254 1
a254 1
         // If TRUE, postprocessing will print each constraint violation that
@


1.14
log
@Began implementation of heuristic implosion from an initial solution.
@
text
@d71 5
d203 15
@


1.13
log
@Continued implementation of single-source.
@
text
@d71 11
@


1.12
log
@Continued implementation of single-source.
@
text
@d227 24
@


1.11
log
@Continued implementation of single-source.
@
text
@d23 2
d114 1
a114 1
      WitBoolean solnIsNonnegative () const;
d118 1
a118 1
      void compNonSubVols () const;
d122 1
a122 1
      void compConsVols () const;
d126 1
a126 1
      void compProdVols () const;
d130 1
a130 1
      void compCapacityScrapVols () const;
d134 1
a134 1
      void compMaterialStockScrapVols () const;
d138 1
a138 1
      double unstockedScrapVol (WitPart * thePart, WitPeriod t) const;
d143 1
a143 1
      void compResidualVols () const;
d149 1
a149 1
         // Computes maxViolation_, feasible ().
d183 1
a183 1
      void displayViolConstraint (WitMsgFragID theFragID) const;
a187 7
      inline WitBoolean & feasible ()
         {
         witAssert (feasiblePtr_ != NULL);

         return * feasiblePtr_;
         }

d196 8
a203 8
      WitRefMap <WitPart,     WitFlexVec <float>  > & consVol_;
      WitRefMap <WitPart,     WitFlexVec <float>  > & prodVol_;
      WitRefMap <WitPart,     WitFlexVec <float>  > & scrapVol_;
      WitRefMap <WitMaterial, WitTVec    <float>  > & stockVol_;
      WitRefMap <WitMaterial, WitFlexVec <float>  > & residualVol_;
      WitRefMap <WitDemand,   WitFlexVec <float>  > & cumShipVol_;
      WitRefMap <WitDemand,   WitTVec    <float>  > & fssShipVol_;
      WitRefMap <WitBomEntry, WitFlexVec <double> > & nonSubVol_;
d205 1
a205 1
      WitBoolean *                                    feasiblePtr_;
@


1.10
log
@Continued implementation of single-source.
@
text
@a22 1
#include <AccFlag.h>
d52 3
a54 4
      accessFunc (const WitAccFlag *, myAccFlag)
      accessFunc (WitBoolean,         postprocessed)
      accessFunc (float,              maxViolation)
      accessFunc (WitBoolean,         reportIncViol)
a68 2
   private:

d70 1
a70 1
      // Private member functions.
d73 19
a91 3
      //------------------------------------------------------------------------
      // Component data access functions.
      //------------------------------------------------------------------------
d93 4
a96 9
      refAccess (WitGlobalComp, WitBoolean,          feasible)
      refAccess (WitPart,       WitFlexVec <float>,  consVol)
      refAccess (WitPart,       WitFlexVec <float>,  prodVol)
      refAccess (WitPart,       WitFlexVec <float>,  scrapVol)
      refAccess (WitMaterial,   WitTVec    <float>,  stockVol)
      refAccess (WitMaterial,   WitFlexVec <float>,  residualVol)
      refAccess (WitDemand,     WitFlexVec <float>,  cumShipVol)
      refAccess (WitDemand,     WitTVec    <float>,  fssShipVol)
      refAccess (WitBomEntry,   WitFlexVec <double>, nonSubVol)
d99 1
a99 1
      // Other private member functions.
d104 8
d186 7
d197 18
a214 3
      WitAccFlag * const myAccFlag_;
         //
         // The AccFlag for this Preprocessor.
@


1.9
log
@Continued implementation of single-source.
@
text
@d23 1
a23 7
#include <Schedule.h>

//------------------------------------------------------------------------------
// FEAS_TOL, the tolerance for feasibility.
//------------------------------------------------------------------------------

#define FEAS_TOL 1.0E-03
d53 4
a56 3
      accessFunc (WitBoolean, postprocessed)
      accessFunc (float,      maxViolation)
      accessFunc (WitBoolean, reportIncViol)
d77 18
d97 1
a97 1
      WitBoolean solnIsNonnegative ();
d101 1
a101 1
      void findViols ();
d103 30
a132 1
         // Computes maxViolation_.
d166 1
a166 1
      void displayViolConstraint (WitMsgFragID theFragID);
d174 4
@


1.8
log
@Continued implementation of single-source.
@
text
@a63 14
      // Result export functions.
      //------------------------------------------------------------------------

      accessMap (const WitTVec <float>  &, consVol,     WitPart)
      accessMap (const WitTVec <float>  &, prodVol,     WitPart)
      accessMap (const WitTVec <float>  &, scrapVol,    WitPart)
      accessMap (const WitTVec <float>  &, stockVol,    WitMaterial)
      accessMap (const WitTVec <float>  &, residualVol, WitMaterial)
      accessMap (const WitTVec <float>  &, cumShipVol,  WitDemand)
      accessMap (const WitTVec <double> &, nonSubVol,   WitBomEntry)

      WitBoolean feasible ();

      //------------------------------------------------------------------------
a83 3
      void allocateScheds ();
      void clearScheds ();

a87 38
      void compNonSubVols ();
         //
         // Computes nonSubVol_ for each BomEntry.

      void compConsVols ();
         //
         // Computes consVol for each Part.

      void compProdVols ();
         //
         // Computes prodVol for each Part.

      void importSecScheds ();
         //
         // Imports the values of scrapVol_ stockVol_ and cumShipVol_ from the
         // actual Components.

      void compCapacityScrapVols ();
         //
         // Computes scrapVol for each Capacity.

      void compMaterialStockScrapVols ();
         //
         // Computes stockVol and scrapVol for each Material.

      void compCumShipVols ();
         //
         // Computes cumShipVol for each Demand.

      double unstockedScrapVol (WitPart * thePart, WitPeriod t);
         //
         // Computes and returns what thePart->scrapVol ()[t] would be if
         // stocking were not allowed. (May return a negative number.)

      void compResidualVols ();
         //
         // Computes residualVol_ for each Part.

a130 16
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Result data.
      //------------------------------------------------------------------------

      WitSchedule <WitPart,     float>  consVol_;
      WitSchedule <WitPart,     float>  prodVol_;
      WitSchedule <WitPart,     float>  scrapVol_;
      WitSchedule <WitMaterial, float>  stockVol_;
      WitSchedule <WitMaterial, float>  residualVol_;
      WitSchedule <WitDemand,   float>  cumShipVol_;
      WitSchedule <WitBomEntry, double> nonSubVol_;

      //------------------------------------------------------------------------
      // Other private member data.
@


1.7
log
@Preliminary work on single source.
@
text
@d23 7
a29 1
#include <AccFlag.h>
d59 17
a75 4
      accessFunc (const WitAccFlag *, myAccFlag)
      accessFunc (WitBoolean,         postprocessed)
      accessFunc (float,              maxViolation)
      accessFunc (WitBoolean,         reportIncViol)
d96 1
a96 17
      //------------------------------------------------------------------------
      // Component data access functions.
      //------------------------------------------------------------------------

      refAccess (WitGlobalComp, WitBoolean,          feasible)
      refAccess (WitPart,       WitFlexVec <float>,  consVol)
      refAccess (WitPart,       WitFlexVec <float>,  prodVol)
      refAccess (WitPart,       WitFlexVec <float>,  scrapVol)
      refAccess (WitMaterial,   WitTVec    <float>,  stockVol)
      refAccess (WitMaterial,   WitFlexVec <float>,  residualVol)
      refAccess (WitDemand,     WitFlexVec <float>,  cumShipVol)
      refAccess (WitDemand,     WitTVec    <float>,  fssShipVol)
      refAccess (WitBomEntry,   WitFlexVec <double>, nonSubVol)

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------
d98 2
a99 1
      noCopyCtorAssign (WitPostprocessor);
d101 1
a101 1
      WitBoolean solnIsNonnegative () const;
d105 1
a105 1
      void compNonSubVols () const;
d109 1
a109 1
      void compConsVols () const;
d113 1
a113 1
      void compProdVols () const;
d117 6
a122 1
      void compCapacityScrapVols () const;
d126 1
a126 1
      void compMaterialStockScrapVols () const;
d130 5
a134 1
      double unstockedScrapVol (WitPart * thePart, WitPeriod t) const;
d139 1
a139 1
      void compResidualVols () const;
d143 1
a143 1
      void compFeasible ();
d145 1
a145 1
         // Computes maxViolation_, feasible ().
d179 1
a179 1
      void displayViolConstraint (WitMsgFragID theFragID) const;
d188 15
a202 3
      WitAccFlag * const myAccFlag_;
         //
         // The AccFlag for this Preprocessor.
@


1.6
log
@Continued preliminary work on single source.
@
text
@d82 8
a89 8
      refAccess (WitPart,       WitFlexVec (float),  consVol)
      refAccess (WitPart,       WitFlexVec (float),  prodVol)
      refAccess (WitPart,       WitFlexVec (float),  scrapVol)
      refAccess (WitMaterial,   WitTVec <float>,     stockVol)
      refAccess (WitMaterial,   WitFlexVec (float),  residualVol)
      refAccess (WitDemand,     WitFlexVec (float),  cumShipVol)
      refAccess (WitDemand,     WitTVec <float>,     fssShipVol)
      refAccess (WitBomEntry,   WitFlexVec (double), nonSubVol)
@


1.5
log
@Began implementation of object iteration.
@
text
@d85 1
a85 1
      refAccess (WitMaterial,   WitTVec (float),     stockVol)
d88 1
a88 1
      refAccess (WitDemand,     WitTVec (float),     fssShipVol)
@


1.4
log
@Refactoring for selection splitting.
@
text
@d20 3
@


1.3
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d92 1
a92 3
      copyCtorAndAssignment (WitPostprocessor);
         //
         // Prevents unintentional copying and assignment.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d78 9
a86 9
      refAccess (WitGlobalComp, WitBoolean,         feasible)
      refAccess (WitPart,       WitFlexVec (float), consVol)
      refAccess (WitPart,       WitFlexVec (float), prodVol)
      refAccess (WitPart,       WitFlexVec (float), scrapVol)
      refAccess (WitMaterial,   WitTVec (float),    stockVol)
      refAccess (WitMaterial,   WitFlexVec (float), residualVol)
      refAccess (WitDemand,     WitFlexVec (float), cumShipVol)
      refAccess (WitDemand,     WitTVec (float),    fssShipVol)
      refAccess (WitBomEntry,   WitTVec (float),    nonSubVol)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

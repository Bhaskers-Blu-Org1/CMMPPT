head	1.46;
access;
symbols
	sce_5_01_20080919:1.39;
locks; strict;
comment	@ * @;


1.46
date	2011.09.28.23.50.29;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.24.00.28.44;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.08.30.20.18.14;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2010.09.10.22.10.42;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2010.08.19.18.00.14;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2010.03.24.21.31.03;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2010.03.23.22.45.21;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.02.28.00.00.43;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.02.13.20.22.56;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.11.22.00.28;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.08.18.56.36;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.01.22.20.08;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.26.14.36.17;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.25.21.03.05;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.21.16.44.41;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.20.22.17.57;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.19.17.41.35;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.14.15.44.41;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.10.21.01.35;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.07.20.25.12;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.07.20.10.23;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.07.15.19.30;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.06.18.59.14;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.05.22.23.58;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.05.18.03.57;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.04.23.01.56;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.04.22.20.12;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.04.19.22.09;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.24.22.14.01;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.24.20.17.24;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.24.15.48.08;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.22.23.24.09;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.22.22.45.30;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.22.22.16.16;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.16.21.27.41;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.15.22.10.55;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.15.22.02.08;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.15.21.36.43;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.15.19.15.33;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.14.21.20.19;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.14.15.03.01;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.09.20.45.06;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.09.20.17.42;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.09.19.30.37;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.07.17.47.14;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "StVars.C"
//
// Implementation the following classes:
//
//    StScrapVar
//    StNonSubVar
//    StSubVar
//    StShipVar
//    StBddVar
//    StExecVar
//    StStockVar
//    StCumShipVar
//    StShipVar
//    StSlbvVar
//------------------------------------------------------------------------------

#include <StVars.h>
#include <StCons.h>
#include <StochImpOP.h>
#include <StochModeMgr.h>
#include <Scenario.h>
#include <ScenAttMgr.h>
#include <ScenInputAtt.h>
#include <ScenSolnAtt.h>
#include <OptComp.h>
#include <Material.h>
#include <Operation.h>
#include <Demand.h>
#include <SubEntry.h>

#include <float.h>

//------------------------------------------------------------------------------
// Implementation of class StScrapVar.
//------------------------------------------------------------------------------

WitStScrapVar::WitStScrapVar (WitPart * thePart, WitStochLoc * theStochLoc):

      WitStochVar (theStochLoc),
      myPart_     (thePart)
   {
   }

//------------------------------------------------------------------------------

WitStScrapVar::~WitStScrapVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStScrapVar::compObjCoeff ()
   {
   double scrapCostVal;

   scrapCostVal =
      myScenAttMgr ()->
         scrapCost ()->
            myValueFor (myPart_, firstScenario ())[myPer ()];

   return - scrapCostVal * totalProb ();
   }

//------------------------------------------------------------------------------

void WitStScrapVar::uploadSolnTo (WitScenario * theScenario)
   {
   myScenAttMgr ()->
      scrapVol ()->
         storeValueFor (myPart_, theScenario, myPer (), primalValue ());
   }

//------------------------------------------------------------------------------

double WitStScrapVar::upperBoundVal ()
   {
   return DBL_MAX;
   }

//------------------------------------------------------------------------------

double WitStScrapVar::lowerBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

const char * WitStScrapVar::classText ()
   {
   return "Scrap";
   }

//------------------------------------------------------------------------------

void WitStScrapVar::printItem ()
   {
   myStochImpOP ()->printItem (myPart_);
   }

//------------------------------------------------------------------------------
// Implementation of class StNonSubVar.
//------------------------------------------------------------------------------

WitStNonSubVar::WitStNonSubVar (
         WitBomEntry * theBomEnt,
         WitStochLoc * theStochLoc):

      WitStochVar (theStochLoc),
      myBomEnt_   (theBomEnt)
   {
   }

//------------------------------------------------------------------------------

WitStNonSubVar::~WitStNonSubVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStNonSubVar::compObjCoeff ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

void WitStNonSubVar::uploadSolnTo (WitScenario *)
   {
   }

//------------------------------------------------------------------------------

double WitStNonSubVar::upperBoundVal ()
   {
   return DBL_MAX;
   }

//------------------------------------------------------------------------------

double WitStNonSubVar::lowerBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

const char * WitStNonSubVar::classText ()
   {
   return "Non-Sub";
   }

//------------------------------------------------------------------------------

void WitStNonSubVar::printItem ()
   {
   myStochImpOP ()->printItem (myBomEnt_);
   }

//------------------------------------------------------------------------------
// Implementation of class StSubVar.
//------------------------------------------------------------------------------

WitStSubVar::WitStSubVar (WitSubEntry * theSub, WitStochLoc * theStochLoc):

      WitStochVar (theStochLoc),
      mySub_      (theSub)
   {
   }

//------------------------------------------------------------------------------

WitStSubVar::~WitStSubVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStSubVar::compObjCoeff ()
   {
   double subCostVal;

   subCostVal =
      myScenAttMgr ()->
         subCost ()->
            myValueFor (mySub_, firstScenario ())[myPer ()];

   return - subCostVal * totalProb ();
   }

//------------------------------------------------------------------------------

void WitStSubVar::uploadSolnTo (WitScenario * theScenario)
   {
   myScenAttMgr ()->
      subVol ()->
         storeValueFor (mySub_, theScenario, myPer (), primalValue ());
   }

//------------------------------------------------------------------------------

double WitStSubVar::upperBoundVal ()
   {
   return DBL_MAX;
   }

//------------------------------------------------------------------------------

double WitStSubVar::lowerBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

const char * WitStSubVar::classText ()
   {
   return "Substitute";
   }

//------------------------------------------------------------------------------

void WitStSubVar::printItem ()
   {
   myStochImpOP ()->printItem (mySub_);
   }

//------------------------------------------------------------------------------
// Implementation of class StShipVar.
//------------------------------------------------------------------------------

WitStShipVar::WitStShipVar (WitDemand * theDemand, WitStochLoc * theStochLoc):

      WitStochVar (theStochLoc),
      myDemand_   (theDemand)
   {
   }

//------------------------------------------------------------------------------

WitStShipVar::~WitStShipVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStShipVar::compObjCoeff ()
   {
   double shipRewardVal;

   shipRewardVal =
      myScenAttMgr ()->
         shipReward ()->
            myValueFor (myDemand_, firstScenario ())[myPer ()];

   return shipRewardVal * totalProb ();
   }

//------------------------------------------------------------------------------

void WitStShipVar::uploadSolnTo (WitScenario * theScenario)
   {
   myScenAttMgr ()->
      shipVol ()->
         storeValueFor (myDemand_, theScenario, myPer (), primalValue ());
   }

//------------------------------------------------------------------------------

double WitStShipVar::upperBoundVal ()
   {
   if (myDemand_->shipLateAllowed ())
      return DBL_MAX;
   else
      return
         myScenAttMgr ()->
            demandVol ()->
               myValueFor (myDemand_, firstScenario ())[myPer ()];
   }

//------------------------------------------------------------------------------

double WitStShipVar::lowerBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

const char * WitStShipVar::classText ()
   {
   return "Shipment";
   }

//------------------------------------------------------------------------------

void WitStShipVar::printItem ()
   {
   myStochImpOP ()->printItem (myDemand_);
   }

//------------------------------------------------------------------------------
// Implementation of class StBddVar.
//------------------------------------------------------------------------------

void WitStBddVar::genStSlbvVarIfNeeded ()
   {
   double softLBVal;

   softLBVal =
      myScenAttMgr ()->
         softLB ()->
            myValueFor (myBoundSet (), firstScenario ())[myPer ()];

   if (softLBVal > hardLB () + FLOAT_EPSILON)
      new WitStSlbvVar (this);
   }

//------------------------------------------------------------------------------

WitStBddVar::WitStBddVar (WitStochLoc * theStochLoc):

      WitStochVar (theStochLoc)
   {
   }

//------------------------------------------------------------------------------

WitStBddVar::~WitStBddVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStBddVar::hardLB ()
   {
   return
      myScenAttMgr ()->
         hardLB ()->
            myValueFor (myBoundSet (), firstScenario ())[myPer ()];
   }

//------------------------------------------------------------------------------

double WitStBddVar::hardUB ()
   {
   double hardUBVal;

   hardUBVal =
      myScenAttMgr ()->
         hardUB ()->
            myValueFor (myBoundSet (), firstScenario ())[myPer ()];

   if (hardUBVal >= 0.0)
      return hardUBVal;
   else
      return DBL_MAX;
   }

//------------------------------------------------------------------------------
// Implementation of class StExecVar.
//------------------------------------------------------------------------------

WitStExecVar::WitStExecVar (WitOperation * theOpn, WitStochLoc * theStochLoc):

      WitStBddVar (theStochLoc),
      myOpn_      (theOpn)
   {
   }

//------------------------------------------------------------------------------

WitStExecVar::~WitStExecVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStExecVar::compObjCoeff ()
   {
   double execCostVal;

   execCostVal =
      myScenAttMgr ()->
         execCost ()->
            myValueFor (myOpn_, firstScenario ())[myPer ()];

   return - execCostVal * totalProb ();
   }

//------------------------------------------------------------------------------

void WitStExecVar::uploadSolnTo (WitScenario * theScenario)
   {
   myScenAttMgr ()->
      execVol ()->
         storeValueFor (myOpn_, theScenario, myPer (), primalValue ());
   }

//------------------------------------------------------------------------------

WitBoundSet * WitStExecVar::myBoundSet ()
   {
   return myOpn_->execBounds ();
   }

//------------------------------------------------------------------------------

double WitStExecVar::upperBoundVal ()
   {
   return hardUB ();
   }

//------------------------------------------------------------------------------

double WitStExecVar::lowerBoundVal ()
   {
   return hardLB ();
   }

//------------------------------------------------------------------------------

const char * WitStExecVar::classText ()
   {
   return "Execution";
   }

//------------------------------------------------------------------------------

void WitStExecVar::printItem ()
   {
   myStochImpOP ()->printItem (myOpn_);
   }

//------------------------------------------------------------------------------
// Implementation of class StStockVar.
//------------------------------------------------------------------------------

WitStStockVar::WitStStockVar (WitMaterial * theMat, WitStochLoc * theStochLoc):

      WitStBddVar (theStochLoc),
      myMat_      (theMat)
   {
   }

//------------------------------------------------------------------------------

WitStStockVar::~WitStStockVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStStockVar::compObjCoeff ()
   {
   double stockCostVal;

   stockCostVal =
      myScenAttMgr ()->
         stockCost ()->
            myValueFor (myMat_, firstScenario ())[myPer ()];

   return - stockCostVal * totalProb ();
   }

//------------------------------------------------------------------------------

void WitStStockVar::uploadSolnTo (WitScenario * theScenario)
   {
   myScenAttMgr ()->
      stockVol ()->
         storeValueFor (myMat_, theScenario, myPer (), primalValue ());
   }

//------------------------------------------------------------------------------

WitBoundSet * WitStStockVar::myBoundSet ()
   {
   return myMat_->stockBounds ();
   }

//------------------------------------------------------------------------------

double WitStStockVar::upperBoundVal ()
   {
   return hardUB ();
   }

//------------------------------------------------------------------------------

double WitStStockVar::lowerBoundVal ()
   {
   return hardLB ();
   }

//------------------------------------------------------------------------------

const char * WitStStockVar::classText ()
   {
   return "Stock";
   }

//------------------------------------------------------------------------------

void WitStStockVar::printItem ()
   {
   myStochImpOP ()->printItem (myMat_);
   }

//------------------------------------------------------------------------------
// Implementation of class StCumShipVar.
//------------------------------------------------------------------------------

WitStCumShipVar::WitStCumShipVar (
         WitDemand *   theDemand,
         WitStochLoc * theStochLoc):

      WitStBddVar (theStochLoc),
      myDemand_   (theDemand)
   {
   }

//------------------------------------------------------------------------------

WitStCumShipVar::~WitStCumShipVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStCumShipVar::compObjCoeff ()
   {
   double cumShipRewardVal;

   cumShipRewardVal =
      myScenAttMgr ()->
         cumShipReward ()->
            myValueFor (myDemand_, firstScenario ())[myPer ()];

   return cumShipRewardVal * totalProb ();
   }

//------------------------------------------------------------------------------

void WitStCumShipVar::uploadSolnTo (WitScenario * theScenario)
   {
   myScenAttMgr ()->
      cumShipVol ()->
         storeValueFor (myDemand_, theScenario, myPer (), primalValue ());
   }

//------------------------------------------------------------------------------

WitBoundSet * WitStCumShipVar::myBoundSet ()
   {
   return myDemand_->cumShipBounds ();
   }

//------------------------------------------------------------------------------

double WitStCumShipVar::upperBoundVal ()
   {
   return
      min (
         myScenGroup ()->cumDemandVol () (myDemand_)[myPer ()],
         hardUB ());
   }

//------------------------------------------------------------------------------

double WitStCumShipVar::lowerBoundVal ()
   {
   return hardLB ();
   }

//------------------------------------------------------------------------------

const char * WitStCumShipVar::classText ()
   {
   return "Cum. Ship";
   }

//------------------------------------------------------------------------------

void WitStCumShipVar::printItem ()
   {
   myStochImpOP ()->printItem (myDemand_);
   }

//------------------------------------------------------------------------------
// Implementation of class StShipVar.
//------------------------------------------------------------------------------

WitStSlbvVar::WitStSlbvVar (WitStBddVar * theBddVar):

      WitStochVar (theBddVar->myStochLoc ()),
      myBddVar_   (theBddVar)
   {
   }

//------------------------------------------------------------------------------

WitStSlbvVar::~WitStSlbvVar ()
   {
   }

//------------------------------------------------------------------------------

double WitStSlbvVar::compObjCoeff ()
   {
   return - myStochLoc ()->myOptComp ()->wbounds () * totalProb ();
   }

//------------------------------------------------------------------------------

void WitStSlbvVar::genStSlbConIfNeeded ()
   {
   new WitStSlbCon (this);
   }

//------------------------------------------------------------------------------

double WitStSlbvVar::stBoundsCoeffVal ()
   {
   return totalProb ();
   }

//------------------------------------------------------------------------------

void WitStSlbvVar::uploadSolnTo (WitScenario *)
   {
   }

//------------------------------------------------------------------------------

bool WitStSlbvVar::isStSlbvVar ()
   {
   return true;
   }

//------------------------------------------------------------------------------

double WitStSlbvVar::upperBoundVal ()
   {
   return DBL_MAX;
   }

//------------------------------------------------------------------------------

double WitStSlbvVar::lowerBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

const char * WitStSlbvVar::classText ()
   {
   return "S. L. B. V.";
   }

//------------------------------------------------------------------------------

void WitStSlbvVar::printItem ()
   {
   myStochImpOP ()->printItem (myBddVar_);
   }
@


1.45
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.44
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d49 4
a52 4
WitStochVar (theStochLoc),
myPart_     (thePart)
{
}
d57 2
a58 2
{
}
d63 2
a64 2
{
double scrapCostVal;
d66 4
a69 4
scrapCostVal =
myScenAttMgr ()->
scrapCost ()->
myValueFor (myPart_, firstScenario ())[myPer ()];
d71 2
a72 2
return - scrapCostVal * totalProb ();
}
d77 5
a81 5
{
myScenAttMgr ()->
scrapVol ()->
storeValueFor (myPart_, theScenario, myPer (), primalValue ());
}
d86 3
a88 3
{
return DBL_MAX;
}
d93 3
a95 3
{
return 0.0;
}
d100 3
a102 3
{
return "Scrap";
}
d107 3
a109 3
{
myStochImpOP ()->printItem (myPart_);
}
d116 2
a117 2
WitBomEntry * theBomEnt,
WitStochLoc * theStochLoc):
d119 4
a122 4
WitStochVar (theStochLoc),
myBomEnt_   (theBomEnt)
{
}
d127 2
a128 2
{
}
d133 3
a135 3
{
return 0.0;
}
d140 2
a141 2
{
}
d146 3
a148 3
{
return DBL_MAX;
}
d153 3
a155 3
{
return 0.0;
}
d160 3
a162 3
{
return "Non-Sub";
}
d167 3
a169 3
{
myStochImpOP ()->printItem (myBomEnt_);
}
d177 4
a180 4
WitStochVar (theStochLoc),
mySub_      (theSub)
{
}
d185 2
a186 2
{
}
d191 2
a192 2
{
double subCostVal;
d194 4
a197 4
subCostVal =
myScenAttMgr ()->
subCost ()->
myValueFor (mySub_, firstScenario ())[myPer ()];
d199 2
a200 2
return - subCostVal * totalProb ();
}
d205 5
a209 5
{
myScenAttMgr ()->
subVol ()->
storeValueFor (mySub_, theScenario, myPer (), primalValue ());
}
d214 3
a216 3
{
return DBL_MAX;
}
d221 3
a223 3
{
return 0.0;
}
d228 3
a230 3
{
return "Substitute";
}
d235 3
a237 3
{
myStochImpOP ()->printItem (mySub_);
}
d245 4
a248 4
WitStochVar (theStochLoc),
myDemand_   (theDemand)
{
}
d253 2
a254 2
{
}
d259 2
a260 2
{
double shipRewardVal;
d262 4
a265 4
shipRewardVal =
myScenAttMgr ()->
shipReward ()->
myValueFor (myDemand_, firstScenario ())[myPer ()];
d267 2
a268 2
return shipRewardVal * totalProb ();
}
d273 5
a277 5
{
myScenAttMgr ()->
shipVol ()->
storeValueFor (myDemand_, theScenario, myPer (), primalValue ());
}
d282 9
a290 9
{
if (myDemand_->shipLateAllowed ())
return DBL_MAX;
else
return
myScenAttMgr ()->
demandVol ()->
myValueFor (myDemand_, firstScenario ())[myPer ()];
}
d295 3
a297 3
{
return 0.0;
}
d302 3
a304 3
{
return "Shipment";
}
d309 3
a311 3
{
myStochImpOP ()->printItem (myDemand_);
}
d318 2
a319 2
{
double softLBVal;
d321 8
a328 8
softLBVal =
myScenAttMgr ()->
softLB ()->
myValueFor (myBoundSet (), firstScenario ())[myPer ()];

if (softLBVal > hardLB () + FLOAT_EPSILON)
new WitStSlbvVar (this);
}
d334 3
a336 3
WitStochVar (theStochLoc)
{
}
d341 2
a342 2
{
}
d347 6
a352 6
{
return
myScenAttMgr ()->
hardLB ()->
myValueFor (myBoundSet (), firstScenario ())[myPer ()];
}
d357 2
a358 2
{
double hardUBVal;
d360 10
a369 10
hardUBVal =
myScenAttMgr ()->
hardUB ()->
myValueFor (myBoundSet (), firstScenario ())[myPer ()];

if (hardUBVal >= 0.0)
return hardUBVal;
else
return DBL_MAX;
}
d377 4
a380 4
WitStBddVar (theStochLoc),
myOpn_      (theOpn)
{
}
d385 2
a386 2
{
}
d391 2
a392 2
{
double execCostVal;
d394 4
a397 4
execCostVal =
myScenAttMgr ()->
execCost ()->
myValueFor (myOpn_, firstScenario ())[myPer ()];
d399 2
a400 2
return - execCostVal * totalProb ();
}
d405 5
a409 5
{
myScenAttMgr ()->
execVol ()->
storeValueFor (myOpn_, theScenario, myPer (), primalValue ());
}
d414 3
a416 3
{
return myOpn_->execBounds ();
}
d421 3
a423 3
{
return hardUB ();
}
d428 3
a430 3
{
return hardLB ();
}
d435 3
a437 3
{
return "Execution";
}
d442 3
a444 3
{
myStochImpOP ()->printItem (myOpn_);
}
d452 4
a455 4
WitStBddVar (theStochLoc),
myMat_      (theMat)
{
}
d460 2
a461 2
{
}
d466 2
a467 2
{
double stockCostVal;
d469 4
a472 4
stockCostVal =
myScenAttMgr ()->
stockCost ()->
myValueFor (myMat_, firstScenario ())[myPer ()];
d474 2
a475 2
return - stockCostVal * totalProb ();
}
d480 5
a484 5
{
myScenAttMgr ()->
stockVol ()->
storeValueFor (myMat_, theScenario, myPer (), primalValue ());
}
d489 3
a491 3
{
return myMat_->stockBounds ();
}
d496 3
a498 3
{
return hardUB ();
}
d503 3
a505 3
{
return hardLB ();
}
d510 3
a512 3
{
return "Stock";
}
d517 3
a519 3
{
myStochImpOP ()->printItem (myMat_);
}
d526 2
a527 2
WitDemand *   theDemand,
WitStochLoc * theStochLoc):
d529 4
a532 4
WitStBddVar (theStochLoc),
myDemand_   (theDemand)
{
}
d537 2
a538 2
{
}
d543 2
a544 2
{
double cumShipRewardVal;
d546 4
a549 4
cumShipRewardVal =
myScenAttMgr ()->
cumShipReward ()->
myValueFor (myDemand_, firstScenario ())[myPer ()];
d551 2
a552 2
return cumShipRewardVal * totalProb ();
}
d557 5
a561 5
{
myScenAttMgr ()->
cumShipVol ()->
storeValueFor (myDemand_, theScenario, myPer (), primalValue ());
}
d566 3
a568 3
{
return myDemand_->cumShipBounds ();
}
d573 6
a578 6
{
return
min (
myScenGroup ()->cumDemandVol () (myDemand_)[myPer ()],
hardUB ());
}
d583 3
a585 3
{
return hardLB ();
}
d590 3
a592 3
{
return "Cum. Ship";
}
d597 3
a599 3
{
myStochImpOP ()->printItem (myDemand_);
}
d607 4
a610 4
WitStochVar (theBddVar->myStochLoc ()),
myBddVar_   (theBddVar)
{
}
d615 2
a616 2
{
}
d621 3
a623 3
{
return - myStochLoc ()->myOptComp ()->wbounds () * totalProb ();
}
d628 3
a630 3
{
new WitStSlbCon (this);
}
d635 3
a637 3
{
return totalProb ();
}
d642 2
a643 2
{
}
d648 3
a650 3
{
return true;
}
d655 3
a657 3
{
return DBL_MAX;
}
d662 3
a664 3
{
return 0.0;
}
d669 3
a671 3
{
return "S. L. B. V.";
}
d676 3
a678 3
{
myStochImpOP ()->printItem (myBddVar_);
}
@


1.43
log
@Heuristic Adjustment
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d49 4
a52 4
      WitStochVar (theStochLoc),
      myPart_     (thePart)
   {
   }
d57 2
a58 2
   {
   }
d63 2
a64 2
   {
   double scrapCostVal;
d66 4
a69 4
   scrapCostVal =
      myScenAttMgr ()->
         scrapCost ()->
            myValueFor (myPart_, firstScenario ())[myPer ()];
d71 2
a72 2
   return - scrapCostVal * totalProb ();
   }
d77 5
a81 5
   {
   myScenAttMgr ()->
      scrapVol ()->
         storeValueFor (myPart_, theScenario, myPer (), primalValue ());
   }
d86 3
a88 3
   {
   return DBL_MAX;
   }
d93 3
a95 3
   {
   return 0.0;
   }
d100 3
a102 3
   {
   return "Scrap";
   }
d107 3
a109 3
   {
   myStochImpOP ()->printItem (myPart_);
   }
d116 2
a117 2
         WitBomEntry * theBomEnt,
         WitStochLoc * theStochLoc):
d119 4
a122 4
      WitStochVar (theStochLoc),
      myBomEnt_   (theBomEnt)
   {
   }
d127 2
a128 2
   {
   }
d133 3
a135 3
   {
   return 0.0;
   }
d140 2
a141 2
   {
   }
d146 3
a148 3
   {
   return DBL_MAX;
   }
d153 3
a155 3
   {
   return 0.0;
   }
d160 3
a162 3
   {
   return "Non-Sub";
   }
d167 3
a169 3
   {
   myStochImpOP ()->printItem (myBomEnt_);
   }
d177 4
a180 4
      WitStochVar (theStochLoc),
      mySub_      (theSub)
   {
   }
d185 2
a186 2
   {
   }
d191 2
a192 2
   {
   double subCostVal;
d194 4
a197 4
   subCostVal =
      myScenAttMgr ()->
         subCost ()->
            myValueFor (mySub_, firstScenario ())[myPer ()];
d199 2
a200 2
   return - subCostVal * totalProb ();
   }
d205 5
a209 5
   {
   myScenAttMgr ()->
      subVol ()->
         storeValueFor (mySub_, theScenario, myPer (), primalValue ());
   }
d214 3
a216 3
   {
   return DBL_MAX;
   }
d221 3
a223 3
   {
   return 0.0;
   }
d228 3
a230 3
   {
   return "Substitute";
   }
d235 3
a237 3
   {
   myStochImpOP ()->printItem (mySub_);
   }
d245 4
a248 4
      WitStochVar (theStochLoc),
      myDemand_   (theDemand)
   {
   }
d253 2
a254 2
   {
   }
d259 2
a260 2
   {
   double shipRewardVal;
d262 4
a265 4
   shipRewardVal =
      myScenAttMgr ()->
         shipReward ()->
            myValueFor (myDemand_, firstScenario ())[myPer ()];
d267 2
a268 2
   return shipRewardVal * totalProb ();
   }
d273 5
a277 5
   {
   myScenAttMgr ()->
      shipVol ()->
         storeValueFor (myDemand_, theScenario, myPer (), primalValue ());
   }
d282 9
a290 9
   {
   if (myDemand_->shipLateAllowed ())
      return DBL_MAX;
   else
      return
         myScenAttMgr ()->
            demandVol ()->
               myValueFor (myDemand_, firstScenario ())[myPer ()];
   }
d295 3
a297 3
   {
   return 0.0;
   }
d302 3
a304 3
   {
   return "Shipment";
   }
d309 3
a311 3
   {
   myStochImpOP ()->printItem (myDemand_);
   }
d318 2
a319 2
   {
   double softLBVal;
d321 8
a328 8
   softLBVal =
      myScenAttMgr ()->
         softLB ()->
            myValueFor (myBoundSet (), firstScenario ())[myPer ()];

   if (softLBVal > hardLB () + FLOAT_EPSILON)
      new WitStSlbvVar (this);
   }
d334 3
a336 3
      WitStochVar (theStochLoc)
   {
   }
d341 2
a342 2
   {
   }
d347 6
a352 6
   {
   return
      myScenAttMgr ()->
         hardLB ()->
            myValueFor (myBoundSet (), firstScenario ())[myPer ()];
   }
d357 2
a358 2
   {
   double hardUBVal;
d360 10
a369 10
   hardUBVal =
      myScenAttMgr ()->
         hardUB ()->
            myValueFor (myBoundSet (), firstScenario ())[myPer ()];

   if (hardUBVal >= 0.0)
      return hardUBVal;
   else
      return DBL_MAX;
   }
d377 4
a380 4
      WitStBddVar (theStochLoc),
      myOpn_      (theOpn)
   {
   }
d385 2
a386 2
   {
   }
d391 2
a392 2
   {
   double execCostVal;
d394 4
a397 4
   execCostVal =
      myScenAttMgr ()->
         execCost ()->
            myValueFor (myOpn_, firstScenario ())[myPer ()];
d399 2
a400 2
   return - execCostVal * totalProb ();
   }
d405 5
a409 5
   {
   myScenAttMgr ()->
      execVol ()->
         storeValueFor (myOpn_, theScenario, myPer (), primalValue ());
   }
d414 3
a416 3
   {
   return myOpn_->execBounds ();
   }
d421 3
a423 3
   {
   return hardUB ();
   }
d428 3
a430 3
   {
   return hardLB ();
   }
d435 3
a437 3
   {
   return "Execution";
   }
d442 3
a444 3
   {
   myStochImpOP ()->printItem (myOpn_);
   }
d452 4
a455 4
      WitStBddVar (theStochLoc),
      myMat_      (theMat)
   {
   }
d460 2
a461 2
   {
   }
d466 2
a467 2
   {
   double stockCostVal;
d469 4
a472 4
   stockCostVal =
      myScenAttMgr ()->
         stockCost ()->
            myValueFor (myMat_, firstScenario ())[myPer ()];
d474 2
a475 2
   return - stockCostVal * totalProb ();
   }
d480 5
a484 5
   {
   myScenAttMgr ()->
      stockVol ()->
         storeValueFor (myMat_, theScenario, myPer (), primalValue ());
   }
d489 3
a491 3
   {
   return myMat_->stockBounds ();
   }
d496 3
a498 3
   {
   return hardUB ();
   }
d503 3
a505 3
   {
   return hardLB ();
   }
d510 3
a512 3
   {
   return "Stock";
   }
d517 3
a519 3
   {
   myStochImpOP ()->printItem (myMat_);
   }
d526 2
a527 2
         WitDemand *   theDemand,
         WitStochLoc * theStochLoc):
d529 4
a532 4
      WitStBddVar (theStochLoc),
      myDemand_   (theDemand)
   {
   }
d537 2
a538 2
   {
   }
d543 2
a544 2
   {
   double cumShipRewardVal;
d546 4
a549 4
   cumShipRewardVal =
      myScenAttMgr ()->
         cumShipReward ()->
            myValueFor (myDemand_, firstScenario ())[myPer ()];
d551 2
a552 2
   return cumShipRewardVal * totalProb ();
   }
d557 5
a561 5
   {
   myScenAttMgr ()->
      cumShipVol ()->
         storeValueFor (myDemand_, theScenario, myPer (), primalValue ());
   }
d566 3
a568 3
   {
   return myDemand_->cumShipBounds ();
   }
d573 6
a578 6
   {
   return
      min (
         myScenGroup ()->cumDemandVol () (myDemand_)[myPer ()],
         hardUB ());
   }
d583 3
a585 3
   {
   return hardLB ();
   }
d590 3
a592 3
   {
   return "Cum. Ship";
   }
d597 3
a599 3
   {
   myStochImpOP ()->printItem (myDemand_);
   }
d607 4
a610 4
      WitStochVar (theBddVar->myStochLoc ()),
      myBddVar_   (theBddVar)
   {
   }
d615 2
a616 2
   {
   }
d621 3
a623 3
   {
   return - myStochLoc ()->myOptComp ()->wbounds () * totalProb ();
   }
d628 3
a630 3
   {
   new WitStSlbCon (this);
   }
d635 3
a637 3
   {
   return totalProb ();
   }
d642 2
a643 2
   {
   }
d648 3
a650 3
   {
   return true;
   }
d655 3
a657 3
   {
   return DBL_MAX;
   }
d662 3
a664 3
   {
   return 0.0;
   }
d669 3
a671 3
   {
   return "S. L. B. V.";
   }
d676 3
a678 3
   {
   myStochImpOP ()->printItem (myBddVar_);
   }
@


1.42
log
@CPLEX
@
text
@d37 1
a37 1
#include <Opn.h>
@


1.41
log
@Removed OptObj classes.
@
text
@d29 1
a29 1
#include <StochImpOM.h>
d108 1
a108 1
   myStochImpOM ()->printItem (myPart_);
d168 1
a168 1
   myStochImpOM ()->printItem (myBomEnt_);
d236 1
a236 1
   myStochImpOM ()->printItem (mySub_);
d310 1
a310 1
   myStochImpOM ()->printItem (myDemand_);
d443 1
a443 1
   myStochImpOM ()->printItem (myOpn_);
d518 1
a518 1
   myStochImpOM ()->printItem (myMat_);
d598 1
a598 1
   myStochImpOM ()->printItem (myDemand_);
d677 1
a677 1
   myStochImpOM ()->printItem (myBddVar_);
@


1.40
log
@Removed class StBoundsObj.
@
text
@d62 1
a62 1
double WitStScrapVar::stochCoeffVal ()
d132 1
a132 1
double WitStNonSubVar::stochCoeffVal ()
d190 1
a190 1
double WitStSubVar::stochCoeffVal ()
d258 1
a258 1
double WitStShipVar::stochCoeffVal ()
d390 1
a390 1
double WitStExecVar::stochCoeffVal ()
d465 1
a465 1
double WitStStockVar::stochCoeffVal ()
d542 1
a542 1
double WitStCumShipVar::stochCoeffVal ()
d620 1
a620 1
void WitStSlbvVar::genStSlbConIfNeeded ()
d622 1
a622 1
   new WitStSlbCon (this);
d627 1
a627 1
double WitStSlbvVar::stochCoeffVal ()
d629 1
a629 1
   return - myStochLoc ()->myOptComp ()->wbounds () * totalProb ();
@


1.39
log
@Stochastic Implosion
@
text
@d24 1
d647 7
@


1.38
log
@Stochastic Implosion
@
text
@d28 1
a28 1
#include <StochImpOP.h>
d107 1
a107 1
   myStochImpOP ()->printItem (myPart_);
d167 1
a167 1
   myStochImpOP ()->printItem (myBomEnt_);
d235 1
a235 1
   myStochImpOP ()->printItem (mySub_);
d309 1
a309 1
   myStochImpOP ()->printItem (myDemand_);
d442 1
a442 1
   myStochImpOP ()->printItem (myOpn_);
d517 1
a517 1
   myStochImpOP ()->printItem (myMat_);
d597 1
a597 1
   myStochImpOP ()->printItem (myDemand_);
d669 1
a669 1
   myStochImpOP ()->printItem (myBddVar_);
@


1.37
log
@Stochastic Implosion
@
text
@d604 1
a604 1
WitStSlbvVar::WitStSlbvVar (WitStBddVar * theStBddVar):
d606 2
a607 2
      WitStochVar (theStBddVar->myStochLoc ()),
      myStBddVar_ (theStBddVar)
d669 1
a669 1
   myStochImpOP ()->printItem (myStBddVar_);
@


1.36
log
@Stochastic Implosion
@
text
@d63 8
a70 1
   return - myPart_->scrapCost ()[myPer ()] * totalProb ();
d191 8
a198 1
   return - mySub_->subCost ()[myPer ()] * totalProb ();
d259 8
a266 1
   return myDemand_->shipReward ()[myPer ()] * totalProb ();
d391 8
a398 1
   return - myOpn_->execCost ()[myPer ()] * totalProb ();
d466 8
a473 1
   return - myMat_->stockCost ()[myPer ()] * totalProb ();
d543 8
a550 1
   return myDemand_->cumShipReward ()[myPer ()] * totalProb ();
@


1.35
log
@Stochastic Implosion
@
text
@d29 1
d31 1
d70 3
a72 1
   theScenario->scrapVol ()->storeValueFor (myPart_, myPer (), primalValue ());
d191 3
a193 1
   theScenario->subVol ()->storeValueFor (mySub_, myPer (), primalValue ());
d252 3
a254 1
   theScenario->shipVol ()->storeValueFor (myDemand_, myPer (), primalValue ());
d264 4
a267 1
      return firstScenario ()->demandVol ()->myValueFor (myDemand_)[myPer ()];
d297 1
a297 1
   double softLB;
d299 4
a302 1
   softLB = firstScenario ()->softLB ()->myValueFor (myBoundSet ())[myPer ()];
d304 1
a304 1
   if (softLB > hardLB () + FLOAT_EPSILON)
d326 4
a329 1
   return firstScenario ()->hardLB ()->myValueFor (myBoundSet ())[myPer ()];
d339 3
a341 1
      firstScenario ()->hardUB ()->myValueFor (myBoundSet ())[myPer ()];
d377 3
a379 1
   theScenario->execVol ()->storeValueFor (myOpn_, myPer (), primalValue ());
d445 3
a447 1
   theScenario->stockVol ()->storeValueFor (myMat_, myPer (), primalValue ());
d515 1
a515 1
   theScenario->
d517 1
a517 1
         storeValueFor (myDemand_, myPer (), primalValue ());
@


1.34
log
@Stochastic Implosion
@
text
@a36 1
#include <BoundSet.h>
d288 1
a288 1
   softLB = myBoundSet ()->softLB ()[myPer ()];
d312 1
a312 1
   return myBoundSet ()->hardLB ()[myPer ()];
d319 9
a327 4
   return
      myBoundSet ()->hardUBIsFinite (myPer ())?
         myBoundSet ()->hardUB ()[myPer ()]:
         DBL_MAX;
@


1.33
log
@Stochastic Implosion
@
text
@d30 2
d69 1
a69 1
   theScenario->storeScrapVol (myPart_, myPer (), primalValue ());
d188 1
a188 1
   theScenario->storeSubVol (mySub_, myPer (), primalValue ());
d247 1
a247 1
   theScenario->storeShipVol (myDemand_, myPer (), primalValue ());
d257 1
a257 1
      return firstScenario ()->demandVol (myDemand_, myPer ());
d354 1
a354 1
   theScenario->storeExecVol (myOpn_, myPer (), primalValue ());
d420 1
a420 1
   theScenario->storeStockVol (myMat_, myPer (), primalValue ());
d488 3
a490 1
   theScenario->storeCumShipVol (myDemand_, myPer (), primalValue ());
@


1.32
log
@Stochastic Implosion
@
text
@a29 3
#include <ScenAttMgr.h>
#include <ScenInputAtt.h>
#include <ScenSolnAtt.h>
d65 1
a65 1
void WitStScrapVar::uploadSoln ()
d67 1
a67 3
   myScenAttMgr ()->
      scrapVol ()->
         storeValue (myPart_, myScenarios (), myPer (), primalValue ());
d126 1
a126 1
void WitStNonSubVar::uploadSoln ()
d184 1
a184 1
void WitStSubVar::uploadSoln ()
d186 1
a186 3
   myScenAttMgr ()->
      subVol ()->
         storeValue (mySub_, myScenarios (), myPer (), primalValue ());
d243 1
a243 1
void WitStShipVar::uploadSoln ()
d245 1
a245 3
   myScenAttMgr ()->
      shipVol ()->
         storeValue (myDemand_, myScenarios (), myPer (), primalValue ());
d255 1
a255 4
      return
         myScenAttMgr ()->
            demandVol ()->
               myValue (myDemand_, myScenGroup ()->firstScenario ())[myPer ()];
d350 1
a350 1
void WitStExecVar::uploadSoln ()
d352 1
a352 3
   myScenAttMgr ()->
      execVol ()->
         storeValue (myOpn_, myScenarios (), myPer (), primalValue ());
d416 1
a416 1
void WitStStockVar::uploadSoln ()
d418 1
a418 3
   myScenAttMgr ()->
      stockVol ()->
         storeValue (myMat_, myScenarios (), myPer (), primalValue ());
d484 1
a484 1
void WitStCumShipVar::uploadSoln ()
d486 1
a486 3
   myScenAttMgr ()->
      cumShipVol ()->
         storeValue (myDemand_, myScenarios (), myPer (), primalValue ());
d567 1
a567 1
void WitStSlbvVar::uploadSoln ()
@


1.31
log
@Stochastic Implosion
@
text
@d72 1
a72 1
         storeValue (myScenarios (), myPart_, myPer (), primalValue ());
d193 1
a193 1
         storeValue (myScenarios (), mySub_, myPer (), primalValue ());
d254 1
a254 1
         storeValue (myScenarios (), myDemand_, myPer (), primalValue ());
d366 1
a366 1
         storeValue (myScenarios (), myOpn_, myPer (), primalValue ());
d434 1
a434 1
         storeValue (myScenarios (), myMat_, myPer (), primalValue ());
d504 1
a504 1
         storeValue (myScenarios (), myDemand_, myPer (), primalValue ());
@


1.30
log
@Stochastic Implosion
@
text
@d31 1
d265 3
a267 3
         myScenGroup ()->
            firstScenario ()->
               demandVolAcc (myDemand_)[myPer ()];
@


1.29
log
@Stochastic Implosion
@
text
@d30 2
d69 3
a71 4
   WitScenario * theScenario;

   forEachEl (theScenario, myScenGroup ()->myScenarios ())
      theScenario->storeScrapVol (myPart_, myPer (), primalValue ());
d159 1
a159 1
   myScenGroup ()->myStochImpOP ()->printItem (myBomEnt_);
d190 3
a192 4
   WitScenario * theScenario;

   forEachEl (theScenario, myScenGroup ()->myScenarios ())
      theScenario->storeSubVol (mySub_, myPer (), primalValue ());
d251 3
a253 4
   WitScenario * theScenario;

   forEachEl (theScenario, myScenGroup ()->myScenarios ())
      theScenario->storeShipVol (myDemand_, myPer (), primalValue ());
d363 3
a365 4
   WitScenario * theScenario;

   forEachEl (theScenario, myScenGroup ()->myScenarios ())
      theScenario->storeExecVol (myOpn_, myPer (), primalValue ());
d431 3
a433 4
   WitScenario * theScenario;

   forEachEl (theScenario, myScenGroup ()->myScenarios ())
      theScenario->storeStockVol (myMat_, myPer (), primalValue ());
d501 3
a503 4
   WitScenario * theScenario;

   forEachEl (theScenario, myScenGroup ()->myScenarios ())
      theScenario->storeCumShipVol (myDemand_, myPer (), primalValue ());
d572 1
a572 1
   return - myStochImpOP ()->myOptComp ()->wbounds () * totalProb ();
@


1.28
log
@Stochastic Implosion
@
text
@d265 3
a267 1
         myScenGroup ()->firstScenario ()->demandVol () (myDemand_)[myPer ()];
@


1.27
log
@Stochastic Implosion
@
text
@d70 1
a70 1
      theScenario->loadInScrapVol (myPart_, myPer (), primalValue ());
d192 1
a192 1
      theScenario->loadInSubVol (mySub_, myPer (), primalValue ());
d254 1
a254 1
      theScenario->loadInShipVol (myDemand_, myPer (), primalValue ());
d365 1
a365 1
      theScenario->loadInExecVol (myOpn_, myPer (), primalValue ());
d434 1
a434 1
      theScenario->loadInStockVol (myMat_, myPer (), primalValue ());
d505 1
a505 1
      theScenario->loadInCumShipVol (myDemand_, myPer (), primalValue ());
@


1.26
log
@Stochastic Implosion
@
text
@d519 4
a522 8
   double cumDemVol;

   cumDemVol =
      myScenGroup ()->
         firstScenario ()->
            cumDemandVol () (myDemand_)[myPer ()];

   return min (cumDemVol, hardUB ());
@


1.25
log
@Stochastic Implosion
@
text
@a64 7
double WitStScrapVar::stPrimaryCoeffVal ()
   {
   return - myPart_->scrapCost ()[myPer ()] * totalProb ();
   }

//------------------------------------------------------------------------------

a128 7
double WitStNonSubVar::stPrimaryCoeffVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

a186 7
double WitStSubVar::stPrimaryCoeffVal ()
   {
   return - mySub_->subCost ()[myPer ()] * totalProb ();
   }

//------------------------------------------------------------------------------

a248 7
double WitStShipVar::stPrimaryCoeffVal ()
   {
   return myDemand_->shipReward ()[myPer ()] * totalProb ();
   }

//------------------------------------------------------------------------------

a359 7
double WitStExecVar::stPrimaryCoeffVal ()
   {
   return - myOpn_->execCost ()[myPer ()] * totalProb ();
   }

//------------------------------------------------------------------------------

a428 7
double WitStStockVar::stPrimaryCoeffVal ()
   {
   return - myMat_->stockCost ()[myPer ()] * totalProb ();
   }

//------------------------------------------------------------------------------

a499 7
double WitStCumShipVar::stPrimaryCoeffVal ()
   {
   return myDemand_->cumShipReward ()[myPer ()] * totalProb ();
   }

//------------------------------------------------------------------------------

a582 7
double WitStSlbvVar::stPrimaryCoeffVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

@


1.24
log
@Stochastic Implosion
@
text
@d58 7
d129 7
d194 7
d263 7
d381 7
d457 7
d535 7
d625 7
@


1.23
log
@Stochastic Implosion
@
text
@d58 1
a58 1
double WitStScrapVar::stochCoeffVal ()
d60 1
a60 1
   return - myPart_->scrapCost ()[myPer ()];
d122 1
a122 1
double WitStNonSubVar::stochCoeffVal ()
d180 1
a180 1
double WitStSubVar::stochCoeffVal ()
d182 1
a182 1
   return - mySub_->subCost ()[myPer ()];
d242 1
a242 1
double WitStShipVar::stochCoeffVal ()
d244 1
a244 1
   return myDemand_->shipReward ()[myPer ()];
d353 1
a353 1
double WitStExecVar::stochCoeffVal ()
d355 1
a355 1
   return - myOpn_->execCost ()[myPer ()];
d422 1
a422 1
double WitStStockVar::stochCoeffVal ()
d424 1
a424 1
   return - myMat_->stockCost ()[myPer ()];
d493 1
a493 1
double WitStCumShipVar::stochCoeffVal ()
d495 1
a495 1
   return myDemand_->cumShipReward ()[myPer ()];
d576 1
a576 1
double WitStSlbvVar::stochCoeffVal ()
d578 8
a585 1
   return - myStochLoc ()->myOptComp ()->wbounds ();
@


1.22
log
@Stochastic Implosion
@
text
@d27 1
d569 7
@


1.21
log
@Stochastic Implosion
@
text
@d23 1
d29 1
a73 7
void WitStScrapVar::printItem ()
   {
   myStochImpOP ()->printItem (myPart_);
   }

//------------------------------------------------------------------------------

d94 7
a133 7
void WitStNonSubVar::printItem ()
   {
   myScenGroup ()->myStochImpOP ()->printItem (myBomEnt_);
   }

//------------------------------------------------------------------------------

d154 7
a195 7
void WitStSubVar::printItem ()
   {
   myStochImpOP ()->printItem (mySub_);
   }

//------------------------------------------------------------------------------

d216 7
a257 7
void WitStShipVar::printItem ()
   {
   myStochImpOP ()->printItem (myDemand_);
   }

//------------------------------------------------------------------------------

d282 7
d292 12
a368 7
void WitStExecVar::printItem ()
   {
   myStochImpOP ()->printItem (myOpn_);
   }

//------------------------------------------------------------------------------

d396 7
a437 7
void WitStStockVar::printItem ()
   {
   myStochImpOP ()->printItem (myMat_);
   }

//------------------------------------------------------------------------------

d465 7
a508 7
void WitStCumShipVar::printItem ()
   {
   myStochImpOP ()->printItem (myDemand_);
   }

//------------------------------------------------------------------------------

d541 65
@


1.20
log
@Stochastic Implosion
@
text
@d303 17
d362 7
d371 1
a371 4
   return
      (myOpn_->execBounds ()->hardUBIsFinite (myPer ()))?
         myOpn_->execBounds ()->hardUB () [myPer ()]:
         + DBL_MAX;
d378 1
a378 1
   return myOpn_->execBounds ()->hardLB () [myPer ()];
d431 7
d440 1
a440 4
   return
      (myMat_->stockBounds ()->hardUBIsFinite (myPer ()))?
         myMat_->stockBounds ()->hardUB () [myPer ()]:
         + DBL_MAX;
d447 1
a447 1
   return myMat_->stockBounds ()->hardLB () [myPer ()];
d502 7
d511 1
a511 1
   double hardUB;
d513 4
a516 4
   hardUB =
      (myDemand_->cumShipBounds ()->hardUBIsFinite (myPer ()))?
         myDemand_->cumShipBounds ()->hardUB () [myPer ()]:
         + DBL_MAX;
d518 1
a518 6
   return
      min (
         myScenGroup ()->
            firstScenario ()->
               cumDemandVol () (myDemand_)[myPer ()],
         hardUB);
d525 1
a525 1
   return myDemand_->cumShipBounds ()->hardLB () [myPer ()];
@


1.19
log
@Stochastic Implosion
@
text
@d19 1
d287 16
d308 1
a308 1
      WitStochVar (theStochLoc),
d373 1
a373 1
      WitStochVar (theStochLoc),
d440 1
a440 1
      WitStochVar (theStochLoc),
@


1.18
log
@Stochastic Implosion
@
text
@d16 4
a20 1
//    StShipVar
a21 3
//    StExecVar
//    StNonSubVar
//    StSubVar
d98 1
a98 1
// Implementation of class StStockVar.
d101 3
a103 1
WitStStockVar::WitStStockVar (WitMaterial * theMat, WitStochLoc * theStochLoc):
d106 1
a106 1
      myMat_      (theMat)
d112 1
a112 1
WitStStockVar::~WitStStockVar ()
d118 1
a118 1
double WitStStockVar::stochCoeffVal ()
d120 1
a120 1
   return - myMat_->stockCost ()[myPer ()];
d125 1
a125 1
void WitStStockVar::uploadSoln ()
a126 4
   WitScenario * theScenario;

   forEachEl (theScenario, myScenGroup ()->myScenarios ())
      theScenario->loadInStockVol (myMat_, myPer (), primalValue ());
d131 1
a131 1
void WitStStockVar::printItem ()
d133 1
a133 1
   myStochImpOP ()->printItem (myMat_);
d138 1
a138 1
double WitStStockVar::upperBoundVal ()
d140 1
a140 4
   return
      (myMat_->stockBounds ()->hardUBIsFinite (myPer ()))?
         myMat_->stockBounds ()->hardUB () [myPer ()]:
         + DBL_MAX;
d145 1
a145 1
double WitStStockVar::lowerBoundVal ()
d147 1
a147 1
   return myMat_->stockBounds ()->hardLB () [myPer ()];
d152 1
a152 1
const char * WitStStockVar::classText ()
d154 1
a154 1
   return "Stock";
d158 1
a158 1
// Implementation of class StShipVar.
d161 1
a161 1
WitStShipVar::WitStShipVar (WitDemand * theDemand, WitStochLoc * theStochLoc):
d164 1
a164 1
      myDemand_   (theDemand)
d170 1
a170 1
WitStShipVar::~WitStShipVar ()
d176 1
a176 1
double WitStShipVar::stochCoeffVal ()
d178 1
a178 1
   return myDemand_->shipReward ()[myPer ()];
d183 1
a183 1
void WitStShipVar::uploadSoln ()
d188 1
a188 1
      theScenario->loadInShipVol (myDemand_, myPer (), primalValue ());
d193 1
a193 1
void WitStShipVar::printItem ()
d195 1
a195 1
   myStochImpOP ()->printItem (myDemand_);
d200 1
a200 1
double WitStShipVar::upperBoundVal ()
d202 1
a202 5
   if (myDemand_->shipLateAllowed ())
      return DBL_MAX;
   else
      return
         myScenGroup ()->firstScenario ()->demandVol () (myDemand_)[myPer ()];
d207 1
a207 1
double WitStShipVar::lowerBoundVal ()
d214 1
a214 1
const char * WitStShipVar::classText ()
d216 1
a216 1
   return "Shipment";
d220 1
a220 1
// Implementation of class StCumShipVar.
d223 1
a223 3
WitStCumShipVar::WitStCumShipVar (
         WitDemand *   theDemand,
         WitStochLoc * theStochLoc):
d232 1
a232 1
WitStCumShipVar::~WitStCumShipVar ()
d238 1
a238 1
double WitStCumShipVar::stochCoeffVal ()
d240 1
a240 1
   return myDemand_->cumShipReward ()[myPer ()];
d245 1
a245 1
void WitStCumShipVar::uploadSoln ()
d250 1
a250 1
      theScenario->loadInCumShipVol (myDemand_, myPer (), primalValue ());
d255 1
a255 1
void WitStCumShipVar::printItem ()
d262 1
a262 1
double WitStCumShipVar::upperBoundVal ()
d264 5
a268 13
   double hardUB;

   hardUB =
      (myDemand_->cumShipBounds ()->hardUBIsFinite (myPer ()))?
         myDemand_->cumShipBounds ()->hardUB () [myPer ()]:
         + DBL_MAX;

   return
      min (
         myScenGroup ()->
            firstScenario ()->
               cumDemandVol () (myDemand_)[myPer ()],
         hardUB);
d273 1
a273 1
double WitStCumShipVar::lowerBoundVal ()
d275 1
a275 1
   return myDemand_->cumShipBounds ()->hardLB () [myPer ()];
d280 1
a280 1
const char * WitStCumShipVar::classText ()
d282 1
a282 1
   return "Cum. Ship";
d351 1
a351 1
// Implementation of class StNonSubVar.
d354 1
a354 3
WitStNonSubVar::WitStNonSubVar (
         WitBomEntry * theBomEnt,
         WitStochLoc * theStochLoc):
d357 1
a357 1
      myBomEnt_   (theBomEnt)
d363 1
a363 1
WitStNonSubVar::~WitStNonSubVar ()
d369 1
a369 1
double WitStNonSubVar::stochCoeffVal ()
d371 1
a371 1
   return 0.0;
d376 1
a376 1
void WitStNonSubVar::uploadSoln ()
d378 4
d386 1
a386 1
void WitStNonSubVar::printItem ()
d388 1
a388 1
   myScenGroup ()->myStochImpOP ()->printItem (myBomEnt_);
d393 1
a393 1
double WitStNonSubVar::upperBoundVal ()
d395 4
a398 1
   return DBL_MAX;
d403 1
a403 1
double WitStNonSubVar::lowerBoundVal ()
d405 1
a405 1
   return 0.0;
d410 1
a410 1
const char * WitStNonSubVar::classText ()
d412 1
a412 1
   return "Non-Sub";
d416 1
a416 1
// Implementation of class StSubVar.
d419 3
a421 1
WitStSubVar::WitStSubVar (WitSubEntry * theSub, WitStochLoc * theStochLoc):
d424 1
a424 1
      mySub_      (theSub)
d430 1
a430 1
WitStSubVar::~WitStSubVar ()
d436 1
a436 1
double WitStSubVar::stochCoeffVal ()
d438 1
a438 1
   return - mySub_->subCost ()[myPer ()];
d443 1
a443 1
void WitStSubVar::uploadSoln ()
d448 1
a448 1
      theScenario->loadInSubVol (mySub_, myPer (), primalValue ());
d453 1
a453 1
void WitStSubVar::printItem ()
d455 1
a455 1
   myStochImpOP ()->printItem (mySub_);
d460 1
a460 1
double WitStSubVar::upperBoundVal ()
d462 13
a474 1
   return DBL_MAX;
d479 1
a479 1
double WitStSubVar::lowerBoundVal ()
d481 1
a481 1
   return 0.0;
d486 1
a486 1
const char * WitStSubVar::classText ()
d488 1
a488 1
   return "Substitute";
@


1.17
log
@Stochastic Implosion
@
text
@d31 1
d142 4
a145 1
   return DBL_MAX;
d152 1
a152 1
   return 0.0;
d275 7
d283 5
a287 1
      myScenGroup ()->firstScenario ()->cumDemandVol () (myDemand_)[myPer ()];
d294 1
a294 1
   return 0.0;
d349 4
a352 1
   return DBL_MAX;
d359 1
a359 1
   return 0.0;
@


1.16
log
@Stochastic Implosion
@
text
@a25 1
#include <ScenSet.h>
d64 1
a64 1
   forEachEl (theScenario, myScenSet ()->myScenarios ())
d126 1
a126 1
   forEachEl (theScenario, myScenSet ()->myScenarios ())
d188 1
a188 1
   forEachEl (theScenario, myScenSet ()->myScenarios ())
d206 2
a207 1
      return myScenSet ()->firstScenario ()->demandVol () (myDemand_)[myPer ()];
d256 1
a256 1
   forEachEl (theScenario, myScenSet ()->myScenarios ())
d271 2
a272 1
   return myScenSet ()->firstScenario ()->cumDemandVol () (myDemand_)[myPer ()];
d319 1
a319 1
   forEachEl (theScenario, myScenSet ()->myScenarios ())
d387 1
a387 1
   myScenSet ()->myStochImpOP ()->printItem (myBomEnt_);
d441 1
a441 1
   forEachEl (theScenario, myScenSet ()->myScenarios ())
@


1.15
log
@Stochastic Implosion
@
text
@d63 4
a66 4
   myStochLoc ()->
      myScenSet ()->
         myScenario ()->
            loadInScrapVol (myPart_, myPer (), primalValue ());
d73 1
a73 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myPart_);
d125 4
a128 4
   myStochLoc ()->
      myScenSet ()->
         myScenario ()->
            loadInStockVol (myMat_, myPer (), primalValue ());
d135 1
a135 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myMat_);
d187 4
a190 4
   myStochLoc ()->
      myScenSet ()->
         myScenario ()->
            loadInShipVol (myDemand_, myPer (), primalValue ());
d197 1
a197 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myDemand_);
d207 1
a207 5
      return
         myStochLoc ()->
            myScenSet ()->
               myScenario ()->
                  demandVol () (myDemand_)[myPer ()];
d254 4
a257 4
   myStochLoc ()->
      myScenSet ()->
         myScenario ()->
            loadInCumShipVol (myDemand_, myPer (), primalValue ());
d264 1
a264 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myDemand_);
d271 1
a271 4
   return
      myStochLoc ()->
         myScenSet ()->
            myScenario ()->cumDemandVol () (myDemand_)[myPer ()];
d316 4
a319 4
   myStochLoc ()->
      myScenSet ()->
         myScenario ()->
            loadInExecVol (myOpn_, myPer (), primalValue ());
d326 1
a326 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myOpn_);
d386 1
a386 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myBomEnt_);
d438 4
a441 4
   myStochLoc ()->
      myScenSet ()->
         myScenario ()->
            loadInSubVol (mySub_, myPer (), primalValue ());
d448 1
a448 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (mySub_);
@


1.14
log
@Stochastic Implosion
@
text
@d26 1
a26 1
#include <ScenPer.h>
d39 1
a39 1
WitStScrapVar::WitStScrapVar (WitPart * thePart, WitScenPer * theScenPer):
d41 1
a41 1
      WitStochVar (theScenPer),
d63 4
a66 1
   myScenario ()->loadInScrapVol (myPart_, myPer (), primalValue ());
d73 1
a73 1
   myStochImpOP ()->printItem (myPart_);
d101 1
a101 1
WitStStockVar::WitStStockVar (WitMaterial * theMat, WitScenPer * theScenPer):
d103 1
a103 1
      WitStochVar (theScenPer),
d125 4
a128 1
   myScenario ()->loadInStockVol (myMat_, myPer (), primalValue ());
d135 1
a135 1
   myStochImpOP ()->printItem (myMat_);
d163 1
a163 1
WitStShipVar::WitStShipVar (WitDemand * theDemand, WitScenPer * theScenPer):
d165 1
a165 1
      WitStochVar (theScenPer),
d187 4
a190 1
   myScenario ()->loadInShipVol (myDemand_, myPer (), primalValue ());
d197 1
a197 1
   myStochImpOP ()->printItem (myDemand_);
d204 8
a211 4
   return
      myDemand_->shipLateAllowed ()?
         DBL_MAX:
         myScenario ()->demandVol () (myDemand_)[myPer ()];
d233 2
a234 2
         WitDemand *  theDemand,
         WitScenPer * theScenPer):
d236 1
a236 1
      WitStochVar (theScenPer),
d258 4
a261 1
   myScenario ()->loadInCumShipVol (myDemand_, myPer (), primalValue ());
d268 1
a268 1
   myStochImpOP ()->printItem (myDemand_);
d275 4
a278 1
   return myScenario ()->cumDemandVol () (myDemand_)[myPer ()];
d299 1
a299 1
WitStExecVar::WitStExecVar (WitOperation * theOpn, WitScenPer * theScenPer):
d301 1
a301 1
      WitStochVar (theScenPer),
d323 4
a326 1
   myScenario ()->loadInExecVol (myOpn_, myPer (), primalValue ());
d333 1
a333 1
   myStochImpOP ()->printItem (myOpn_);
d363 1
a363 1
         WitScenPer *  theScenPer):
d365 1
a365 1
      WitStochVar (theScenPer),
d393 1
a393 1
   myStochImpOP ()->printItem (myBomEnt_);
d421 1
a421 1
WitStSubVar::WitStSubVar (WitSubEntry * theSub, WitScenPer * theScenPer):
d423 1
a423 1
      WitStochVar (theScenPer),
d445 4
a448 1
   myScenario ()->loadInSubVol (mySub_, myPer (), primalValue ());
d455 1
a455 1
   myStochImpOP ()->printItem (mySub_);
@


1.13
log
@Stochastic Implosion
@
text
@a25 1
#include <StochLoc.h>
a43 1
   myStochLoc ()->store (this);
a102 1
   myStochLoc ()->store (this);
a161 1
   myStochLoc ()->store (this);
a225 1
   myStochLoc ()->store (this);
a284 1
   myStochLoc ()->store (this);
a345 1
   myStochLoc ()->store (this);
a403 1
   myStochLoc ()->store (this);
@


1.12
log
@Stochastic Implosion
@
text
@d26 1
a26 1
#include <ScenSetPer.h>
d45 1
a45 1
   myScenSetPer ()->store (this);
d105 1
a105 1
   myScenSetPer ()->store (this);
d165 1
a165 1
   myScenSetPer ()->store (this);
d230 1
a230 1
   myScenSetPer ()->store (this);
d290 1
a290 1
   myScenSetPer ()->store (this);
d352 1
a352 1
   myScenSetPer ()->store (this);
d411 1
a411 1
   myScenSetPer ()->store (this);
@


1.11
log
@Stochastic Implosion
@
text
@d26 1
d45 1
d105 1
d165 1
d230 1
d290 1
d352 1
d411 1
@


1.10
log
@Stochastic Implosion
@
text
@a16 1
//    StExecVar
d19 3
d31 1
d63 1
a63 1
   myScenario ()->setScrapVol (myPart_, myPer (), primalValue ());
d122 1
a122 1
   myScenario ()->setStockVol (myMat_, myPer (), primalValue ());
d154 123
d304 1
a304 1
   myScenario ()->setExecVol (myOpn_, myPer (), primalValue ());
d336 1
a336 1
// Implementation of class StShipVar.
d339 3
a341 1
WitStShipVar::WitStShipVar (WitDemand * theDemand, WitScenPer * theScenPer):
d344 1
a344 1
      myDemand_   (theDemand)
d350 1
a350 1
WitStShipVar::~WitStShipVar ()
d356 1
a356 1
double WitStShipVar::stochCoeffVal ()
d358 1
a358 1
   return myDemand_->shipReward ()[myPer ()];
d363 1
a363 1
void WitStShipVar::uploadSoln ()
a364 1
   myScenario ()->setShipVol (myDemand_, myPer (), primalValue ());
d369 1
a369 1
void WitStShipVar::printItem ()
d371 1
a371 1
   myStochImpOP ()->printItem (myDemand_);
d376 1
a376 1
double WitStShipVar::upperBoundVal ()
d378 1
a378 4
   return
      myDemand_->shipLateAllowed ()?
         DBL_MAX:
         myScenario ()->demandVol () (myDemand_)[myPer ()];
d383 1
a383 1
double WitStShipVar::lowerBoundVal ()
d390 1
a390 1
const char * WitStShipVar::classText ()
d392 1
a392 1
   return "Shipment";
d396 1
a396 1
// Implementation of class StCumShipVar.
d399 1
a399 3
WitStCumShipVar::WitStCumShipVar (
         WitDemand *  theDemand,
         WitScenPer * theScenPer):
d402 1
a402 1
      myDemand_   (theDemand)
d408 1
a408 1
WitStCumShipVar::~WitStCumShipVar ()
d414 1
a414 1
double WitStCumShipVar::stochCoeffVal ()
d416 1
a416 1
   return myDemand_->cumShipReward ()[myPer ()];
d421 1
a421 1
void WitStCumShipVar::uploadSoln ()
d423 1
a423 1
   myScenario ()->setCumShipVol (myDemand_, myPer (), primalValue ());
d428 1
a428 1
void WitStCumShipVar::printItem ()
d430 1
a430 1
   myStochImpOP ()->printItem (myDemand_);
d435 1
a435 1
double WitStCumShipVar::upperBoundVal ()
d437 1
a437 1
   return myScenario ()->cumDemandVol () (myDemand_)[myPer ()];
d442 1
a442 1
double WitStCumShipVar::lowerBoundVal ()
d449 1
a449 1
const char * WitStCumShipVar::classText ()
d451 1
a451 1
   return "Cum. Ship";
@


1.9
log
@Stochastic Implosion
@
text
@d53 1
a53 3
   return
        (- myPart_->scrapCost ()[myPer ()])
      * myScenario ()->scenarioProb ();
d112 1
a112 3
   return
        (- myMat_->stockCost ()[myPer ()])
      * myScenario ()->scenarioProb ();
d171 1
a171 3
   return
        (- myOpn_->execCost ()[myPer ()])
      * myScenario ()->scenarioProb ();
d230 1
a230 3
   return
        myDemand_->shipReward ()[myPer ()]
      * myScenario ()->scenarioProb ();
d294 1
a294 3
   return
        myDemand_->cumShipReward ()[myPer ()]
      * myScenario ()->scenarioProb ();
@


1.8
log
@Stochastic Implosion
@
text
@d74 1
a74 1
double WitStScrapVar::compUpperBound ()
d81 1
a81 1
double WitStScrapVar::compLowerBound ()
d135 1
a135 1
double WitStStockVar::compUpperBound ()
d142 1
a142 1
double WitStStockVar::compLowerBound ()
d196 1
a196 1
double WitStExecVar::compUpperBound ()
d203 1
a203 1
double WitStExecVar::compLowerBound ()
d257 1
a257 1
double WitStShipVar::compUpperBound ()
d267 1
a267 1
double WitStShipVar::compLowerBound ()
d323 1
a323 1
double WitStCumShipVar::compUpperBound ()
d330 1
a330 1
double WitStCumShipVar::compLowerBound ()
@


1.7
log
@Stochastic Implosion
@
text
@d16 1
d26 1
a26 1
#include <Part.h>
d94 61
@


1.6
log
@Stochastic Implosion
@
text
@d29 2
d73 14
d134 14
a171 12
void WitStShipVar::compBounds ()
   {
   if (myDemand_->shipLateAllowed ())
      WitOptVar::compBounds ();
   else
      setBoundsTo (
         0.0,
         myScenario ()->demandVol () (myDemand_)[myPer ()]);
   }

//------------------------------------------------------------------------------

d195 17
a237 9
void WitStCumShipVar::compBounds ()
   {
   setBoundsTo (
      0.0,
      myScenario ()->cumDemandVol () (myDemand_)[myPer ()]);
   }

//------------------------------------------------------------------------------

d261 14
@


1.5
log
@Stochastic Implosion
@
text
@d205 3
a207 9
   double    cumDemVol;
   WitPeriod thePer;

   cumDemVol = 0.0;

   for (thePer = 0; thePer <= myPer (); thePer ++)
      cumDemVol += myScenario ()->demandVol () (myDemand_)[thePer];

   setBoundsTo (0.0, cumDemVol);
@


1.4
log
@Stochastic Implosion
@
text
@d17 2
d27 1
d122 123
@


1.3
log
@Stochastic Implosion
@
text
@d54 7
d101 7
@


1.2
log
@Stochastic Implosion
@
text
@d45 1
a45 1
double WitStScrapVar::stochCoeffVal () const
d54 1
a54 1
void WitStScrapVar::printItem () const
d85 1
a85 1
double WitStExecVar::stochCoeffVal () const
d94 1
a94 1
void WitStExecVar::printItem () const
@


1.1
log
@Stochastic Implosion
@
text
@d61 1
a61 1
const char * WitStScrapVar::classText () const
d101 1
a101 1
const char * WitStExecVar::classText () const
@


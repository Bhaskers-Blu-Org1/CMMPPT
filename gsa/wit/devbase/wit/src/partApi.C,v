head	1.179;
access;
symbols
	sce_5_01_20080919:1.165
	latest_sce_4_20_20060523:1.102.0.2
	sce_4_20_20060523:1.102
	latest_sce4_20_OSL:1.101.0.2
	sce_4_20_OSL:1.101
	sce_410_withVa:1.96
	sce_4_05_20040511:1.77
	sce_4_00_20040201:1.41
	nextGenBranch:1.39.0.2
	nextGenRoot:1.39
	sce_3_30_20030627:1.39
	EndRw-branch:1.33.0.4
	Root-of-EndRw:1.33
	rwToStl:1.33.0.2
	latest_sce_3_10_20010924:1.16.0.2
	sce_3_10_20010924:1.16
	latest_sce_3_00_20010601:1.11.0.2
	sce_3_00_20010601:1.11
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.179
date	2011.09.28.23.50.48;	author rjw;	state Exp;
branches;
next	1.178;

1.178
date	2011.09.24.00.29.03;	author rjw;	state Exp;
branches;
next	1.177;

1.177
date	2011.08.30.20.18.28;	author rjw;	state Exp;
branches;
next	1.176;

1.176
date	2010.06.22.19.55.35;	author rjw;	state Exp;
branches;
next	1.175;

1.175
date	2010.06.18.18.03.50;	author rjw;	state Exp;
branches;
next	1.174;

1.174
date	2010.06.18.14.15.18;	author rjw;	state Exp;
branches;
next	1.173;

1.173
date	2010.06.17.16.29.47;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2010.06.17.16.17.15;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2010.06.16.18.33.38;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2010.03.16.22.42.29;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2009.12.05.00.10.21;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2009.11.19.20.46.07;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2009.11.13.19.01.28;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2008.11.12.19.52.26;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2008.07.02.17.48.38;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2008.02.25.22.35.11;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2008.02.25.19.37.58;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2008.02.25.16.36.34;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2008.02.22.23.18.20;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2008.02.22.21.36.11;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2008.01.18.22.41.01;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2008.01.09.22.33.57;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2008.01.09.21.17.28;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2008.01.09.19.35.49;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2007.11.29.19.18.04;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2007.11.02.21.13.33;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2007.10.22.19.58.54;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2007.10.17.14.58.47;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2007.10.15.21.50.36;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2007.10.12.21.45.15;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2007.10.11.19.16.58;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2007.10.02.22.23.07;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2007.08.29.16.24.25;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2007.08.01.22.42.00;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2007.07.17.22.10.26;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2007.07.16.20.15.01;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2007.07.16.18.12.34;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2007.06.18.21.53.31;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2007.06.18.20.43.39;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2007.06.15.17.44.36;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2007.06.14.21.38.32;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2007.06.13.23.12.32;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2007.05.21.15.20.12;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2007.05.17.17.37.01;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2007.05.16.22.16.47;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2007.05.03.22.05.30;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2007.04.26.22.35.18;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2007.04.23.20.20.01;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2007.04.04.22.08.19;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2007.04.02.23.01.17;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2007.04.02.21.21.20;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2007.03.09.20.13.07;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2007.03.08.22.47.19;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2007.01.16.16.53.45;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2007.01.16.16.27.40;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2007.01.16.00.25.06;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2007.01.15.23.06.08;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2007.01.15.21.15.16;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2007.01.12.23.50.21;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2007.01.12.20.00.38;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2007.01.11.18.38.32;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2007.01.09.21.07.49;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2007.01.09.19.14.16;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2007.01.09.15.55.26;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2006.12.27.22.45.41;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2006.11.20.17.04.53;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2006.11.17.20.53.57;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2006.11.17.17.22.02;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2006.11.17.16.57.48;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2006.11.14.23.10.27;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2006.11.02.23.07.14;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2006.11.01.17.31.47;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2006.09.19.17.50.56;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2006.09.07.20.49.24;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2006.09.05.21.11.06;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2006.08.24.20.50.28;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2006.08.22.21.26.56;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2006.05.02.17.34.17;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2006.03.02.21.55.49;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2006.03.01.19.23.25;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2005.09.20.20.37.38;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2005.09.13.19.38.08;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2005.09.12.22.17.33;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2005.09.01.21.45.04;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2005.08.24.18.24.25;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2005.08.23.19.45.20;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2005.08.19.21.38.04;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2005.08.11.20.54.50;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2005.07.13.21.18.47;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2005.06.13.16.48.48;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2005.03.21.21.49.27;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2005.03.16.17.00.31;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2005.03.04.00.00.29;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.03.03.21.25.12;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2005.03.02.23.17.53;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2005.03.02.22.34.37;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2005.03.02.21.59.47;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2005.02.25.21.26.10;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2005.02.24.23.23.58;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.02.10.18.38.31;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.02.08.20.36.19;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2004.05.12.19.43.32;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.05.15.43.59;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.04.14.21.25.36;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.04.09.21.24.27;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.04.09.15.52.47;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.07.20.56.29;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.07.19.21.32;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.06.18.16.58;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.06.15.42.18;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.04.05.20.06.11;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.04.02.20.54.17;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.01.21.05.13;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.03.31.22.56.08;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.30.23.46.55;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.03.30.21.10.08;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.30.18.57.05;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.30.00.05.34;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.29.22.25.14;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.26.22.29.41;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.26.17.03.33;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.25.22.00.37;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.25.21.43.33;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.25.21.21.59;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.25.20.35.03;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.25.19.59.38;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.24.17.03.32;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.24.16.50.35;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.04.16.31.47;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.03.22.36.23;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.02.23.52.14;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.02.26.18.59.43;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.24.19.37.23;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.20.22.46.03;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.20.15.37.37;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.12.19.13.41;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.06.00.17.34;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.11.18.29.16;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.25.23.49.57;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.03.19.16.48.31;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.14.20.13.05;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.02.23.40.55;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.02.22.18.59;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.26.23.28.52;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.25.15.15.22;	author rwToStl;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.11.18.53.18;	author rjw;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2002.08.02.17.03.37;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.01.20.16.36;	author austel;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.25.17.43.55;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.09.20.49.51;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.09.19.52.39;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.24.22.02.28;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.21.19.10.28;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.17.21.45.08;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.08.19.21.59;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.03.23.16.45;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.03.19.58.31;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.25.19.14.56;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.24.18.26.13;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.22.14.32.16;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.18.14.02.50;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.28.00.13.00;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.18.51.00;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.31.00.26.27;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.29.21.37.23;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.25.16.08.22;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.01.19.23.36;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.17.20.02.20;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.17.15.11.20;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.06.19.22.12;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.12.19.48.09;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.16.37.08;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.06.19.58.42;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.20.12.37;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.30;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.35;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.24;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.34;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.33.2.1
date	2002.11.08.16.11.34;	author rwToStl;	state Exp;
branches;
next	;

1.1.1.1
date	2000.02.24.13.53.34;	author wit;	state Exp;
branches;
next	;


desc
@@


1.179
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "partApi.C"
//
// Inner API functions relating to Parts.
//------------------------------------------------------------------------------

#include <WitRun.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <ApiCall.h>
#include <ISRealArg.h>
#include <OSRealArg.h>
#include <IVRealArg.h>
#include <OVRealArg.h>
#include <OTDARealArg.h>
#include <Pre.h>
#include <DetOptImpMgr.h>
#include <ExtOptMgr.h>
#include <StochImpMgr.h>
#include <CompMgr.h>
#include <Demand.h>
#include <Material.h>
#include <Capacity.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <GlobalComp.h>
#include <Post.h>
#include <BoundSet.h>
#include <MsgFrag.h>
#include <MsgFac.h>

#include <float.h>
#include <stdlib.h>

//------------------------------------------------------------------------------
// setGetPartInit
// Initialization of witSetPart* functions.
//------------------------------------------------------------------------------

WitPart * WitRun::setGetPartInit (const char * partName)
   {
   WitPart * thePart;

   forbidNullArg (partName, "partName");

   if (myMsgFac ().mayIssue ("partNameMsg"))
      myMsgFac () ("partNameMsg", partName);

   thePart = getPartP (partName);

   myInputID ()->setMyPart (thePart);

   return thePart;
   }

//------------------------------------------------------------------------------

WitMaterial * WitRun::setGetMaterialInit (
      const char * partName,
      const char * theAttName)
   {
   WitPart *     thePart;
   WitMaterial * theMat;

   thePart = setGetPartInit (partName);

   theMat  = thePart->thisMat ();

   if (theMat == NULL)
      {
      myInputID ()->setMyAttName (theAttName);

      myMsgFac () ("materialReqdSmsg");
      }

   return theMat;
   }

//------------------------------------------------------------------------------

void WitRun::witAddPart (
      const char * partName,
      WitAttr      partCategory)
   {
   myApiMgr_->startInnerFunc ();

   forbidNullArg (partName, "partName");

   if (wit34Compatible ())
      addPart34     (partName, partCategory);
   else
      addPartPost34 (partName, partCategory);
   }

//------------------------------------------------------------------------------

void WitRun::witAddPartWithOperation (
      const char * partAndOperationName)
   {
   myApiMgr_->startInnerFunc ();

   witAddPart (partAndOperationName, WitMATERIAL);

   witAddOperation (partAndOperationName);

   witAddBopEntry (partAndOperationName, partAndOperationName);
   }

//------------------------------------------------------------------------------

void WitRun::witCopyPartData (
      const char * dupPartName,
      WitRun *     origWitRun,
      const char * origPartName)
   {
   startCopyObjData (origWitRun);

   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("partFrag"));

   WitPartApiCall dupCall (this,      dupPartName);

   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("partFrag"));

   WitPartApiCall origCall (origWitRun, origPartName);

   WitPart *  dupPart;
   WitPart * origPart;

    dupPart =  dupCall.myPart ();
   origPart = origCall.myPart ();

   if (dupPart == origPart)
      myMsgFac () ("copyObjectToSelfSmsg", myMsgFac ().myFrag ("partFrag"));

   if      ((dupPart->thisMat () != NULL) and (origPart->thisMat () != NULL))
      {
      dupPart->thisMat ()->copyAttrsFrom (origPart->thisMat ());
      }
   else if ((dupPart->thisCap () != NULL) and (origPart->thisCap () != NULL))
      {
      dupPart->thisCap ()->copyAttrsFrom (origPart->thisCap ());
      }
   else
      myMsgFac () ("copyPartCatMismatchSmsg",
          dupPart->partName     (),
          dupPart->categoryFrag (),
         origPart->partName     (),
         origPart->categoryFrag ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetFocusShortageVol (
      int   *                lenList,
      char  * * *            partList,
      const WitOTDARealArg & shortageVolList)
   {
   int       nShortParts;
   WitPart * thePart;
   int       theIdx;

   myApiMgr_->startInnerFunc ();

   forbidNullArg (lenList,         "lenList");
   forbidNullArg (partList,        "partList");
   forbidNullArg (shortageVolList, "shortageVolList");

   forbidStochMode ();

   myProblem ()->computeFssIfNeeded ();

   nShortParts = 0;

   forEachPart (thePart, myProblem ())
      if (thePart->focShortageVol () != 0.0)
         nShortParts ++;

   * lenList = nShortParts;

   apiAlloc (partList, nShortParts);

   shortageVolList.apiAlloc (nShortParts, nPeriods ());

   theIdx = -1;

   forEachPart (thePart, myProblem ())
      if (thePart->focShortageVol () != 0.0)
         {
         theIdx ++;

         (* partList)[theIdx] = thePart->partName ().apiDupCstring ();

         shortageVolList.copyIntoRow (theIdx, thePart->focShortageVol ());
         }
   }

//------------------------------------------------------------------------------

void WitRun::witGetObjItrPart (char * * partName)
   {
   WitPart * thePart;

   myApiMgr_->startInnerFunc ();

   thePart =
      curItrDelCompForGet (WitAT_PART, "partFrag")->
         thisPart ();

   stronglyAssert (thePart != NULL);

   apiGet (partName, "partName", thePart->partName ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartAppData (
      const char * partName,
      void * *     appData)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (appData, "appData", theCall.myPart ()->appData ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartAsapPipOrder (
      const char * partName,
      WitBoolean * asapPipOrder)
   {
   WitMaterialApiCall theCall (this, partName, "asapPipOrder");

   apiGet (
                             asapPipOrder, 
                            "asapPipOrder", 
      theCall.myMaterial ()->asapPipOrder ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartBaSelSplit (
      const char * partName,
      WitBoolean * baSelSplit)
   {
   WitMaterialApiCall theCall (this, partName, "baSelSplit");

   apiGet (baSelSplit, "baSelSplit", theCall.myMaterial ()->baSelSplit ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartBelowList (
      const char * partName,
      int *        lenList,
      char * * *   partNameList)
   {
   WitPartApiCall theCall (this, partName);

   forbidNullArg (lenList,      "lenList");
   forbidNullArg (partNameList, "partNameList");

   int &                  lenListRef      = * lenList;
   char * * &             partNameListRef = * partNameList;
   WitPart *              thePart;
   WitPtrVecItr <WitPart> theItr;

   myProblem ()->myPreprocessor ()->preprocess ();

   lenListRef = theCall.myPart ()->belowList ().length ();

   apiAlloc (partNameList, lenListRef);

   theCall.myPart ()->belowList ().attachItr (theItr);

   while (theItr.advance (thePart))
      partNameListRef[theItr.myIdx ()] = thePart->partName ().apiDupCstring ();
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartBoundedLeadTimes (
      const char * partName,
      WitBoolean * boundedLeadTimes)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
                         boundedLeadTimes, 
                        "boundedLeadTimes", 
      theCall.myPart ()->boundedLeadTimes ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartBuildAheadUB (
      const char * partName,
      int * *      buildAheadUB)
   {
   WitMaterialApiCall theCall (this, partName, "buildAheadUB");

   apiGet (                  buildAheadUB, 
                            "buildAheadUB", 
      theCall.myMaterial ()->buildAheadUB ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartBuildAheadLimit (
      const char * partName,
      int *        buildAheadLimit)
   {
   int * buildAheadUBval;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "part",
         "buildAheadLimit",
         "buildAheadUB");

   witGetPartBuildAheadUB (partName, & buildAheadUBval);

   forbidNullArg (buildAheadLimit, "buildAheadLimit");

   * buildAheadLimit = buildAheadUBval[0];

   free (buildAheadUBval);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartBuildAsap (
      const char * partName,
      WitBoolean * buildAsap)
   {
   WitMaterialApiCall theCall (this, partName, "buildAsap");

   apiGet (buildAsap, "buildAsap", theCall.myMaterial ()->buildAsap ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartBuildNstn (
      const char * partName,
      WitBoolean * buildNstn)
   {
   WitMaterialApiCall theCall (this, partName, "buildNstn");

   apiGet (buildNstn, "buildNstn", theCall.myMaterial ()->buildNstn ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartCategory (
      const char * partName,
      WitAttr * category)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (category, "category", theCall.myPart ()->apiCategory ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartConsVol (
      const char *         partName,
      const WitOVRealArg & consVol)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (consVol, "consVol", theCall.myPart ()->consVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartConsumingBomEntry (
      const char * partName,
      int          consIndex,
      char * *     consumingOperationName,
      int *        bomEntryIndex)
   {
   WitPartApiCall theCall (this, partName);

   WitBomEntry *  theBomEnt;

   if (consIndex < 0 or
       consIndex >= theCall.myPart ()->consumingBomEntries ().nElements ())
      myMsgFac () ("bomEntryConsIndexRangeSmsg",
         consIndex,
         0,
         theCall.myPart ()->consumingBomEntries ().nElements ());

   theBomEnt = theCall.myPart ()->consumingBomEntries ().at (consIndex);

   * consumingOperationName = theBomEnt->myOperationName ().apiDupCstring ();
   * bomEntryIndex          = theBomEnt->localIndex ();
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartConsumingSubsBomEntry (
      const char * partName,
      int          consIndex,
      char * *     consumingOperationName,
      int *        bomEntryIndex,
      int *        subsBomEntryIndex)
   {
   WitSubEntry * theSub;

   WitPartApiCall theCall (this, partName);

      // Make sure consIndex is valid.
      //
   if (consIndex < 0 or
       consIndex >= theCall.myPart ()->consumingSubEntries ().nElements ())
      myMsgFac () ("subEntryConsIndexRangeSmsg",
         consIndex,
         0,
         theCall.myPart ()->consumingSubEntries ().nElements ());

   theSub = theCall.myPart ()->consumingSubEntries ().at (consIndex);

   * consumingOperationName = theSub->myOperationName ().apiDupCstring ();
   * bomEntryIndex          = theSub->myBomEntIndex ();
   * subsBomEntryIndex      = theSub->localIndex ();
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartCycleTime (
      const char *         partName,
      const WitOVRealArg & inpVal)
   {
   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      myMsgFac () ("getting34AttributeWithCompatibilityCycleTime",
         apiFuncName ());

      witGetOperationCycleTime34 (partName, inpVal);
      }
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityCycleTime",
         apiFuncName ());
   }

//------------------------------------------------------------------------------
// Return a list of all demand names for a material part.
// If the part is a capacity, there is no list of demands; in this case, an
// empty list is returned (for upward compatability).
//------------------------------------------------------------------------------

void WitRun::witGetPartDemands (
      const char * partName,
      int  *       lenDemandList,
      char * * *   demandList)
   {
   WitDemand * theDemand;
   int         i;

   WitPartApiCall theCall (this, partName);

   apiGet (
      lenDemandList, 
      "lenDemandList", 
      theCall.myPart ()->myDemands ().nElements ());

   apiAlloc (demandList, * lenDemandList);

   i = 0;

   forEachEl (theDemand, theCall.myPart ()->myDemands ())
      (* demandList)[i++] = theDemand->demandName ().apiDupCstring ();
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartExcessVol (
      const char *         partName,
      const WitOVRealArg & excessVol)
   {
   WitPeriod thePer;

   WitPartApiCall theCall (this, partName);

   forbidNullArg (excessVol, "excessVol");

   apiAlloc (excessVol, nPeriods ());

   forEachPeriod (thePer, myProblem ())
      excessVol[thePer] =
         myProblem ()->
            myPostprocessor ()->
               compExcessVol (theCall.myPart (), thePer);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartExists (
      const char * partNameParm,
      WitBoolean * exists)
   {
   myApiMgr_->startInnerFunc ();

   if (myCompMgr ()->findPart (partNameParm) != NULL)
      {
      myMsgFac () ("partDoesExist", partNameParm);

      * exists = true;
      }
   else
      {
      myMsgFac () ("partDoesNotExist", partNameParm);

      * exists = false;
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartFocusShortageVol (
      const char *         partName,
      const WitOVRealArg & focusShortageVol)
   {
   WitPartApiCall theCall (this, partName);

   forbidStochMode ();

   myProblem ()->computeFssIfNeeded ();

   apiGet (              focusShortageVol, 
                        "focusShortageVol", 
      theCall.myPart ()->focShortageVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartIncLotSize (
      const char *         partName,
      const WitOVRealArg & incLotSize)
   {
   myApiMgr_->startInnerFunc ();

   prepGet34Attr ("Part", "incLotSize", "Operation", "incLotSize");

   witGetOperationIncLotSize (partName, incLotSize);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartMinLotSize (
      const char *         partName,
      const WitOVRealArg & minLotSize)
   {
   myApiMgr_->startInnerFunc ();

   prepGet34Attr ("Part", "minLotSize", "Operation", "minLotSize");

   witGetOperationMinLotSize (partName, minLotSize);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartMrpConsVol (
      const char *         partName,
      const WitOVRealArg & mrpConsVol)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (mrpConsVol, "mrpConsVol", theCall.myPart ()->mrpConsVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartMrpExcessVol (
      const char *         partName,
      const WitOVRealArg & mrpExcessVol)
   {
   WitPeriod thePer;

   WitPartApiCall theCall (this, partName);

   forbidNullArg (mrpExcessVol, "mrpExcessVol");

   apiAlloc (mrpExcessVol, nPeriods ());

   forEachPeriod (thePer, myProblem ())
      mrpExcessVol[thePer] =
         min (
            theCall.myPart ()->mrpResidualVol ()[thePer],
            theCall.myPart ()->supplyVol      ()[thePer]);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartMrpProdVol (
      const char *         partName,
      const WitOVRealArg & mrpProdVol)
   {
   myApiMgr_->startInnerFunc ();

   prepGet34Attr ("Part", "mrpProdVol", "Operation", "mrpExecVol");

   witGetOperationMrpExecVol (partName, mrpProdVol);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartMrpResidualVol (
      const char *         partName,
      const WitOVRealArg & mrpResidualVol)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (              mrpResidualVol, 
                        "mrpResidualVol", 
      theCall.myPart ()->mrpResidualVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartNBomEntries (
      const char * partName,
      int *        inpVal)
   {
   WitPart * partP;

   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      partP = setGetPartInit (partName);

         // If part is not a product, then return 0, otherwise get nBomEntries
         // from operation.
         //
      if (partP->apiCategory() != WitPRODUCT)
         {
         myMsgFac () ("getting34AttributeNBomEntriesForNonProduct",
            partName,
            partP->categoryFrag ());

         * inpVal = 0;
         }
      else
         {
         myMsgFac () ("getting34AttributeWithCompatibilityMode",
            apiFuncName (),
            "Part",
            "nBomEntries",
            "Operation",
            "nBomEntries");

         witGetOperationNBomEntries (partName, inpVal);
         }

      myInputID ()->setMyPart (NULL);
      }
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         "Part",
         "nBomEntries",
         "Operation",
         "nBomEntries");
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartNConsumingBomEntries (
      const char * partName,
      int *        nConsumingBomEntries)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
       nConsumingBomEntries,
      "nConsumingBomEntries",
      theCall.myPart ()->consumingBomEntries ().nElements ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartNConsumingSubsBomEntries (
      const char * partName,
      int *        nConsumingSubsBomEntries)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
       nConsumingSubsBomEntries,
      "nConsumingSubsBomEntries",
      theCall.myPart ()->consumingSubEntries ().nElements ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartNProducingBopEntries (
      const char * partName,
      int * nProducingBopEntries)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
       nProducingBopEntries,
      "nProducingBopEntries",
      theCall.myPart ()->producingBopEntries ().nElements ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartObjectStage (
      const char * partName,
      int *        objectStage)
   {
   WitPartApiCall theCall (this, partName);

   theCall.getObjectStage (objectStage);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartObj1ScrapCost (
      const char *         partName,
      const WitOVRealArg & obj1ScrapCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "part",
         "obj1ScrapCost",
         "scrapCost");

   witGetPartScrapCost (partName, obj1ScrapCost);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartObj1StockCost (
      const char *         partName,
      const WitOVRealArg & obj1StockCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "part",
         "obj1StockCost",
         "stockCost");

   witGetPartStockCost (partName, obj1StockCost);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartObj1ProdCost (
      const char *         partName,
      const WitOVRealArg & obj1ProdCost)
   {
   myApiMgr_->startInnerFunc ();

   prepGet34Attr ("Part", "obj1ProdCost", "Operation", "obj1ExecCost");

   witGetOperationObj1ExecCost (partName, obj1ProdCost);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartProdBounds (
      const char *         partName,
      const WitOVRealArg & hardLB,
      const WitOVRealArg & softLB,
      const WitOVRealArg & hardUB)
   {
   myApiMgr_->startInnerFunc ();

   prepGet34Attr ("Part", "prodBounds", "Operation", "execBounds");

   witGetOperationExecBounds (partName, hardLB, softLB, hardUB);
   }

//------------------------------------------------------------------------------
// prodVol, an attribute which has a new meaning with Wit V4.0.
// Wit V3.4 provides set and get functions.
// Wit V4.0 only provides a get function.
//------------------------------------------------------------------------------

void WitRun::witGetPartProdVol (
      const char *         partName,
      const WitOVRealArg & prodVol)
   {
   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      prepGet34Attr ("Part", "prodVol", "Operation", "execVol");

      witGetOperationExecVol (partName, prodVol);
      }
   else
      {
      WitPartApiCall theCall (this, partName);

      apiGet (prodVol, "prodVol", theCall.myPart ()->prodVol ());
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartProducingBopEntry (
      const char * partName,
      int          prodIndex,
      char * *     producingOperationName,
      int *        bopEntryIndex)
   {
   WitBopEntry * theBopEnt;

   WitPartApiCall theCall (this, partName);

   if (prodIndex < 0 or
       prodIndex >= theCall.myPart ()->producingBopEntries ().nElements ())
      myMsgFac () ("bopEntryProdIndexRangeSmsg",
         prodIndex,
         0,
         theCall.myPart ()->producingBopEntries ().nElements ());

   theBopEnt = theCall.myPart ()->producingBopEntries ().at (prodIndex);

   * producingOperationName = theBopEnt->myOperationName ().apiDupCstring ();
   * bopEntryIndex          = theBopEnt->localIndex ();
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartReqVol (
      const char *         partName,
      const WitOVRealArg & reqVol)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (reqVol, "reqVol", theCall.myPart ()->reqVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartResidualVol (
      const char *         partName,
      const WitOVRealArg & residualVol)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (residualVol, "residualVol", theCall.myPart ()->residualVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartResourceConIndex (
      const char * partName,
      const int    thePer,
      int *        resourceConIndex)
   {
   WitPartApiCall theCall (this, partName);

   prepGetIndex (thePer);

   apiGet (
       resourceConIndex,
      "resourceConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            resourceConIndex (theCall.myPart (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartScrapVarIndex (
      const char * partName,
      const int    thePer,
      int *        scrapVarIndex)
   {
   WitPartApiCall theCall (this, partName);

   prepGetIndex (thePer);

   apiGet (
       scrapVarIndex,
      "scrapVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            scrapVarIndex (theCall.myPart (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartPropRouting (
      const char * partName,
      WitBoolean * propRouting)
   {
   WitPartApiCall theCall (this, partName);

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "part",
         "propRouting",
         "propRtg");

   apiGet (propRouting, "propRouting", theCall.myPart ()->propRtg ()[0]);
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartPropRtg (
      const char *   partName,
      WitBoolean * * propRtg)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (propRtg, "propRtg", theCall.myPart ()->propRtg ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetParts (
      int  *     lenPartList,
      char * * * partList)
   {
   WitPart * partj;
   int       theIdx;

   myApiMgr_->startInnerFunc ();

   theIdx = 0;

   * lenPartList = myCompMgr ()->nParts ();

   apiAlloc (partList, * lenPartList);

   forEachPart (partj, myProblem ())
      (* partList)[theIdx ++] = partj->partName ().apiDupCstring ();
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartScrapAllowed (
      const char * partName,
      WitBoolean * scrapAllowed)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (scrapAllowed, "scrapAllowed", theCall.myPart ()->scrapAllowed ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartScrapCost (
      const char *         partName,
      const WitOVRealArg & scrapCost)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
       scrapCost,
      "scrapCost",
      theCall.myPart ()->scrapCost ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartScrapVol (
      const char *         partName,
      const WitOVRealArg & scrapVol)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (scrapVol, "scrapVol", theCall.myPart ()->scrapVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartSelForDel (
      const char * partName,
      WitBoolean * selForDel)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (selForDel, "selForDel", theCall.myPart ()->selForDel ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartShadowPrice (
      const char *         partName,
      const WitOVRealArg & shadowPrice)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (shadowPrice, "shadowPrice", theCall.myPart ()->shadowPrice ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartSingleSource (
      const char * partName,
      WitBoolean * singleSource)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (singleSource, "singleSource", theCall.myPart ()->singleSource ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartStockBounds (
      const char *         partName,
      const WitOVRealArg & hardLB,
      const WitOVRealArg & softLB,
      const WitOVRealArg & hardUB)
   {
   WitMaterialApiCall theCall (this, partName, "stockBounds");

   apiGet (hardLB, softLB, hardUB, theCall.myMaterial ()->stockBounds ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartStockCost (
      const char *         partName,
      const WitOVRealArg & stockCost)
   {
   WitMaterialApiCall theCall (this, partName, "stockCost");

   apiGet (
       stockCost,
      "stockCost",
      theCall.myMaterial ()->stockCost ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartStockSlbConIndex (
      const char * partName,
      const int    thePer,
      int *        stockSlbConIndex)
   {
   WitMaterialApiCall theCall (this, partName, "stockSlbConIndex");

   prepGetIndex (thePer);

   apiGet (
       stockSlbConIndex,
      "stockSlbConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            stockSlbConIndex (theCall.myMaterial (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartStockSlbvVarIndex (
      const char * partName,
      const int    thePer,
      int *        stockSlbvVarIndex)
   {
   WitMaterialApiCall theCall (this, partName, "stockSlbvVarIndex");

   prepGetIndex (thePer);

   apiGet (
       stockSlbvVarIndex,
      "stockSlbvVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            stockSlbvVarIndex (theCall.myMaterial (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartStockVarIndex (
      const char * partName,
      const int    thePer,
      int *        stockVarIndex)
   {
   WitMaterialApiCall theCall (this, partName, "stockVarIndex");

   prepGetIndex (thePer);

   apiGet (
       stockVarIndex,
      "stockVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            stockVarIndex (theCall.myMaterial (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartStockVol (
      const char *         partName,
      const WitOVRealArg & stockVol)
   {
   WitMaterialApiCall theCall (this, partName, "stockVol");

   apiGet (stockVol, "stockVol", theCall.myMaterial ()->stockVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartSupplyVol (
      const char *         partName,
      const WitOVRealArg & supplyVol)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (supplyVol, "supplyVol", theCall.myPart ()->supplyVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetPartYield (
      const char * partName,
      int * *      yield)
   {
   myApiMgr_->startInnerFunc ();

   prepGet34Attr ("Part", "yield", "Operation", "yield");

   witGetOperationYield (partName, yield);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartAppData (
      const char * partName,
      void *       appData)
   {
   WitPartApiCall theCall (this, partName);

   theCall.setAppData (appData);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartAsapPipOrder (
      const char * partName,
      WitBoolean   asapPipOrder)
   {
   WitMaterialApiCall theCall (this, partName, "asapPipOrder");

   theCall.prepBool (    
                            "asapPipOrder", 
      theCall.myMaterial ()->asapPipOrder (), 
                             asapPipOrder);

   if (theCall.argsOK ())
      theCall.myMaterial ()->setAsapPipOrder (asaBool (asapPipOrder));
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartBaSelSplit (
      const char * partName,
      WitBoolean   baSelSplit)
   {
   WitMaterialApiCall theCall (this, partName, "baSelSplit");

   theCall.prepBool (    
                            "baSelSplit", 
      theCall.myMaterial ()->baSelSplit (), 
                             baSelSplit);

   if (theCall.argsOK ())
      theCall.myMaterial ()->setBaSelSplit (asaBool (baSelSplit));
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartBoundedLeadTimes (
      const char * partName,
      WitBoolean   boundedLeadTimes)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepBool (    
                        "boundedLeadTimes", 
      theCall.myPart ()->boundedLeadTimes (), 
                         boundedLeadTimes);

   if (theCall.argsOK ())
      theCall.myPart ()->setBoundedLeadTimes (asaBool (boundedLeadTimes));
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartBuildAheadUB (
      const char * partName,
      const int *  buildAheadUB)
   {
   WitMaterialApiCall theCall (this, partName, "buildAheadUB");

   theCall.prepBuildAheadUB (buildAheadUB);

   if (theCall.argsOK ())
      theCall.myMaterial ()->setBuildAheadUB (buildAheadUB);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartBuildAheadLimit (
      const char * partName,
      int          buildAheadLimit)
   {
   WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "part",
         "buildAheadLimit",
         "buildAheadUB");

   buildAheadUBVec = buildAheadLimit;

   witSetPartBuildAheadUB (partName, buildAheadUBVec.myCVec ());

   myApiMgr ()->releaseTempVecs ();
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartBuildAsap (
      const char * partName,
      WitBoolean   buildAsap)
   {
   WitMaterialApiCall theCall (this, partName, "buildAsap");

   theCall.prepBa (
      "buildAsap", 
      theCall.myMaterial ()->buildAsap (), 
      buildAsap, 
      "buildNstn");

   if (theCall.argsOK ())
      theCall.myMaterial ()->setBuildAsap (asaBool (buildAsap));
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartBuildNstn (
      const char * partName,
      WitBoolean   buildNstn)
   {
   WitMaterialApiCall theCall (this, partName, "buildNstn");

   theCall.prepBa (
      "buildNstn", 
      theCall.myMaterial ()->buildNstn (), 
      buildNstn, 
      "buildAsap");

   if (theCall.argsOK ())
      theCall.myMaterial ()->setBuildNstn (asaBool (buildNstn));
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartCycleTime (
      const char *         partName,
      const WitIVRealArg & inpVal)
   {
   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      myMsgFac () ("setting34AttributeWithCompatibilityCycleTime",
         apiFuncName ());

      witSetOperationCycleTime34 (partName, inpVal);
      }
   else
      myMsgFac () ("setting34AttributeWithoutCompatibilityCycleTime",
         apiFuncName ());
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartIncLotSize (
      const char *         partName,
      const WitIVRealArg & incLotSize)
   {
   myApiMgr_->startInnerFunc ();

   prepSet34Attr ("Part", "incLotSize", "Operation", "incLotSize");

   witSetOperationIncLotSize (partName, incLotSize);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartMinLotSize (
      const char *         partName,
      const WitIVRealArg & minLotSize)
   {
   myApiMgr_->startInnerFunc ();

   prepSet34Attr ("Part", "minLotSize", "Operation", "minLotSize");

   witSetOperationMinLotSize (partName, minLotSize);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartObj1ProdCost (
      const char *         partName,
      const WitIVRealArg & obj1ProdCost)
   {
   myApiMgr_->startInnerFunc ();

   prepSet34Attr ("Part", "obj1ProdCost", "Operation", "obj1ExecCost");

   witSetOperationObj1ExecCost (partName, obj1ProdCost);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartObj1ScrapCost (
      const char *         partName,
      const WitIVRealArg & obj1ScrapCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "part",
         "obj1ScrapCost",
         "scrapCost");

   witSetPartScrapCost (partName, obj1ScrapCost);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartObj1StockCost (
      const char *         partName,
      const WitIVRealArg & obj1StockCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "part",
         "obj1StockCost",
         "stockCost");

   witSetPartStockCost (partName, obj1StockCost);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartObjectStage (
      const char * partName,
      int          objectStage)
   {
   WitPartApiCall theCall (this, partName);

   theCall.setObjectStage (objectStage);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartPartName (
      const char * partName,
      const char * newName)
   {
   WitPartApiCall theCall (this, partName);

   forbidNullArg (newName, "newName");

   if (isNullCstring (newName))
      myMsgFac () ("nullStringSmsg", "newName");

   if (myCompMgr ()->findPart (newName))
      myMsgFac () ("setNodeNameToDupSmsg",
         "witSetPartPartName",
         myMsgFac ().myFrag ("partFrag"),
         newName);

   theCall.prepString (
                        "partName",
      theCall.myPart ()->partName (),
                          newName);

   if (theCall.argsOK ())
      theCall.myPart ()->setPartName (newName);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartProdBounds (
    const char *         partName,
    const WitIVRealArg & hardLB,
    const WitIVRealArg & softLB,
    const WitIVRealArg & hardUB)
   {
   myApiMgr_->startInnerFunc ();

   prepSet34Attr ("Part", "prodBounds", "Operation", "execBounds");

   witSetOperationExecBounds (partName, hardLB, softLB, hardUB);
   }

//------------------------------------------------------------------------------
// prodVol, an attribute which has a new meaning with Wit V4.0.
// Wit V3.4 provides set and get functions.
// Wit V4.0 only provides a get function.
//------------------------------------------------------------------------------

void WitRun::witSetPartProdVol (
      const char *         partName,
      const WitIVRealArg & prodVol)
   {
   myApiMgr_->startInnerFunc ();

   prepSet34Attr ("Part", "prodVol", "Operation", "execVol");

   witSetOperationExecVol (partName, prodVol);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartPropRouting (
      const char * partName,
      WitBoolean   propRouting)
   {
   WitTVec <WitBoolean> & propRtgVec = myApiMgr ()->reserveTempBooleanVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "part",
         "propRouting",
         "propRtg");

   propRtgVec = propRouting;

   witSetPartPropRtg (partName, propRtgVec.myCVec ());

   myApiMgr ()->releaseTempVecs ();
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartPropRtg (
      const char *       partName,
      const WitBoolean * propRtg)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepBoolVec ("propRtg", propRtg);

   if (theCall.argsOK ())
      theCall.myPart ()->setPropRtg (propRtg);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartScrapAllowed (
      const char * partName, WitBoolean scrapAllowed)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepBool (    
                        "scrapAllowed", 
      theCall.myPart ()->scrapAllowed (), 
                         scrapAllowed);

   if (theCall.argsOK ())
      theCall.myPart ()->setScrapAllowed (asaBool (scrapAllowed));
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartScrapCost (
      const char *         partName,
      const WitIVRealArg & scrapCost)
   {
   WitPeriod thePer;

   WitPartApiCall theCall (this, partName);

   theCall.prepDblVec ("scrapCost", scrapCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (scrapCost[thePer] < 0.0)
            myMsgFac () (
               "negPartCostWmsg",
               "scrapCost",
               partName,
               scrapCost[thePer],
               thePer);

      theCall.myPart ()->setScrapCost (scrapCost);
      }
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartSelForDel (
      const char * partName,
      WitBoolean   selForDel)
   {
   WitPartApiCall theCall (this, partName);

   theCall.setSelForDel (selForDel);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartSingleSource (
      const char * partName, WitBoolean singleSource)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepBool (    
                        "singleSource", 
      theCall.myPart ()->singleSource (), 
                         singleSource);

   if (theCall.argsOK ())
      theCall.myPart ()->setSingleSource (asaBool (singleSource));
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartStockBounds (
      const char *         partName,
      const WitIVRealArg & hardLB,
      const WitIVRealArg & softLB,
      const WitIVRealArg & hardUB)
   {
   WitMaterialApiCall theCall (this, partName, "stockBounds");

   theCall.setBoundSet (
      theCall.myMaterial ()->stockBounds (), 
      hardLB, 
      softLB, 
      hardUB);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartStockCost (
      const char *         partName,
      const WitIVRealArg & stockCost)
   {
   WitMaterialApiCall theCall (this, partName, "stockCost");
   WitPeriod          thePer;

   theCall.prepDblVec ("stockCost", stockCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (stockCost[thePer] < 0.0)
            myMsgFac () (
               "negPartCostWmsg",
               "stockCost",
               partName,
               stockCost[thePer],
               thePer);

      theCall.myMaterial ()->setStockCost (stockCost);
      }
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartSupplyVol (
      const char *         partName,
      const WitIVRealArg & supplyVol)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepNonNegDblVec ("supplyVol", supplyVol);

   if (theCall.argsOK ())
      theCall.myPart ()->setSupplyVol (supplyVol);
   }

//------------------------------------------------------------------------------

void WitRun::witSetPartYield (
      const char * partName,
      const int *  yield)
   {
   myApiMgr_->startInnerFunc ();

   prepSet34Attr ("Part", "yield", "Operation", "yield");

   witSetOperationYield (partName, yield);
   }

//------------------------------------------------------------------------------

WitPart * WitRun::addPart34 (const char * partName, WitAttr partCategory)
   {
   if (partCategory == WitPRODUCT)
      {
      myMsgFac () ("addProductPartWith34Compatability", apiFuncName ());

      addPartPost34 (partName, WitMATERIAL);

      witAddOperation (partName);

      witAddBopEntry (partName, partName);
      }
   else if (partCategory == WitRAW)
      {
      myMsgFac () ("addRawPartWith34Compatability", apiFuncName ());

      addPartPost34 (partName, WitMATERIAL);
      }
   else if (partCategory == WitCAPACITY)
      addPartPost34 (partName, WitCAPACITY);

   else if (partCategory == WitMATERIAL)
      addPartPost34 (partName, WitMATERIAL);

   else
      myMsgFac () ("unknownPartCategorySmsg", partCategory);

   return getPartP (partName);
   }

//------------------------------------------------------------------------------

WitPart * WitRun::addPartPost34 (const char * partName, WitAttr partCategory)
   {
   if (myMsgFac ().mayIssue ("partNameTypeApMsg"))
      myMsgFac () ("partNameTypeApMsg", partName, partCategory);

   if      (partCategory == WitCAPACITY)
      partCategory = WitCAPACITY;
   else if (partCategory == WitMATERIAL)
      partCategory = WitMATERIAL;
   else
      myMsgFac () ("unknownPartCategorySmsg", partCategory);

   if (isNullCstring (partName))
      myMsgFac () ("nullStringSmsg", "partName");

   if (myCompMgr ()->findPart (partName))
      myMsgFac () ("dupPartApMsg", partName);

   addingDelComp ("partFrag");

   if (partCategory == WitCAPACITY)
      return new WitCapacity (partName, myCompMgr ());
   else
      return new WitMaterial (partName, myCompMgr ());
   }

//------------------------------------------------------------------------------
// getPartP
// Return pointer to part.  If not defined issue message.
//------------------------------------------------------------------------------

WitPart * WitRun::getPartP (const char * partName)
   {
   WitPart * partP;

   partP = myCompMgr ()->findPart (partName);

   if (partP == NULL)
      myMsgFac () ("undefinedPartMsg", partName);

   return partP;
   }
@


1.178
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.177
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d51 2
a52 2
{
WitPart * thePart;
d54 1
a54 1
forbidNullArg (partName, "partName");
d56 2
a57 2
if (myMsgFac ().mayIssue ("partNameMsg"))
myMsgFac () ("partNameMsg", partName);
d59 1
a59 1
thePart = getPartP (partName);
d61 1
a61 1
myInputID ()->setMyPart (thePart);
d63 2
a64 2
return thePart;
}
d69 5
a73 5
const char * partName,
const char * theAttName)
{
WitPart *     thePart;
WitMaterial * theMat;
d75 1
a75 1
thePart = setGetPartInit (partName);
d77 1
a77 1
theMat  = thePart->thisMat ();
d79 3
a81 3
if (theMat == NULL)
{
myInputID ()->setMyAttName (theAttName);
d83 2
a84 2
myMsgFac () ("materialReqdSmsg");
}
d86 2
a87 2
return theMat;
}
d92 12
a103 12
const char * partName,
WitAttr      partCategory)
{
myApiMgr_->startInnerFunc ();

forbidNullArg (partName, "partName");

if (wit34Compatible ())
addPart34     (partName, partCategory);
else
addPartPost34 (partName, partCategory);
}
d108 3
a110 3
const char * partAndOperationName)
{
myApiMgr_->startInnerFunc ();
d112 1
a112 1
witAddPart (partAndOperationName, WitMATERIAL);
d114 1
a114 1
witAddOperation (partAndOperationName);
d116 2
a117 2
witAddBopEntry (partAndOperationName, partAndOperationName);
}
d122 38
a159 38
const char * dupPartName,
WitRun *     origWitRun,
const char * origPartName)
{
startCopyObjData (origWitRun);

myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("partFrag"));

WitPartApiCall dupCall (this,      dupPartName);

myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("partFrag"));

WitPartApiCall origCall (origWitRun, origPartName);

WitPart *  dupPart;
WitPart * origPart;

dupPart =  dupCall.myPart ();
origPart = origCall.myPart ();

if (dupPart == origPart)
myMsgFac () ("copyObjectToSelfSmsg", myMsgFac ().myFrag ("partFrag"));

if      ((dupPart->thisMat () != NULL) and (origPart->thisMat () != NULL))
{
dupPart->thisMat ()->copyAttrsFrom (origPart->thisMat ());
}
else if ((dupPart->thisCap () != NULL) and (origPart->thisCap () != NULL))
{
dupPart->thisCap ()->copyAttrsFrom (origPart->thisCap ());
}
else
myMsgFac () ("copyPartCatMismatchSmsg",
dupPart->partName     (),
dupPart->categoryFrag (),
origPart->partName     (),
origPart->categoryFrag ());
}
d164 7
a170 7
int   *                lenList,
char  * * *            partList,
const WitOTDARealArg & shortageVolList)
{
int       nShortParts;
WitPart * thePart;
int       theIdx;
d172 1
a172 1
myApiMgr_->startInnerFunc ();
d174 3
a176 3
forbidNullArg (lenList,         "lenList");
forbidNullArg (partList,        "partList");
forbidNullArg (shortageVolList, "shortageVolList");
d178 1
a178 1
forbidStochMode ();
d180 1
a180 1
myProblem ()->computeFssIfNeeded ();
d182 1
a182 1
nShortParts = 0;
d184 3
a186 3
forEachPart (thePart, myProblem ())
if (thePart->focShortageVol () != 0.0)
nShortParts ++;
d188 1
a188 1
* lenList = nShortParts;
d190 1
a190 1
apiAlloc (partList, nShortParts);
d192 1
a192 1
shortageVolList.apiAlloc (nShortParts, nPeriods ());
d194 1
a194 1
theIdx = -1;
d196 4
a199 4
forEachPart (thePart, myProblem ())
if (thePart->focShortageVol () != 0.0)
{
theIdx ++;
d201 1
a201 1
(* partList)[theIdx] = thePart->partName ().apiDupCstring ();
d203 3
a205 3
shortageVolList.copyIntoRow (theIdx, thePart->focShortageVol ());
}
}
d210 2
a211 2
{
WitPart * thePart;
d213 1
a213 1
myApiMgr_->startInnerFunc ();
d215 3
a217 3
thePart =
curItrDelCompForGet (WitAT_PART, "partFrag")->
thisPart ();
d219 1
a219 1
stronglyAssert (thePart != NULL);
d221 2
a222 2
apiGet (partName, "partName", thePart->partName ());
}
d227 4
a230 4
const char * partName,
void * *     appData)
{
WitPartApiCall theCall (this, partName);
d232 2
a233 2
apiGet (appData, "appData", theCall.myPart ()->appData ());
}
d238 10
a247 10
const char * partName,
WitBoolean * asapPipOrder)
{
WitMaterialApiCall theCall (this, partName, "asapPipOrder");

apiGet (
asapPipOrder,
"asapPipOrder",
theCall.myMaterial ()->asapPipOrder ());
}
d252 4
a255 4
const char * partName,
WitBoolean * baSelSplit)
{
WitMaterialApiCall theCall (this, partName, "baSelSplit");
d257 2
a258 2
apiGet (baSelSplit, "baSelSplit", theCall.myMaterial ()->baSelSplit ());
}
d263 5
a267 5
const char * partName,
int *        lenList,
char * * *   partNameList)
{
WitPartApiCall theCall (this, partName);
d269 2
a270 2
forbidNullArg (lenList,      "lenList");
forbidNullArg (partNameList, "partNameList");
d272 4
a275 4
int &                  lenListRef      = * lenList;
char * * &             partNameListRef = * partNameList;
WitPart *              thePart;
WitPtrVecItr <WitPart> theItr;
d277 1
a277 1
myProblem ()->myPreprocessor ()->preprocess ();
d279 1
a279 1
lenListRef = theCall.myPart ()->belowList ().length ();
d281 1
a281 1
apiAlloc (partNameList, lenListRef);
d283 1
a283 1
theCall.myPart ()->belowList ().attachItr (theItr);
d285 3
a287 3
while (theItr.advance (thePart))
partNameListRef[theItr.myIdx ()] = thePart->partName ().apiDupCstring ();
}
d292 10
a301 10
const char * partName,
WitBoolean * boundedLeadTimes)
{
WitPartApiCall theCall (this, partName);

apiGet (
boundedLeadTimes,
"boundedLeadTimes",
theCall.myPart ()->boundedLeadTimes ());
}
d306 9
a314 9
const char * partName,
int * *      buildAheadUB)
{
WitMaterialApiCall theCall (this, partName, "buildAheadUB");

apiGet (                  buildAheadUB,
"buildAheadUB",
theCall.myMaterial ()->buildAheadUB ());
}
d319 4
a322 4
const char * partName,
int *        buildAheadLimit)
{
int * buildAheadUBval;
d324 1
a324 1
myApiMgr_->startInnerFunc ();
d326 7
a332 7
if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
myMsgFac () (
"getVecAttrAsScalMsg",
apiFuncName (),
"part",
"buildAheadLimit",
"buildAheadUB");
d334 1
a334 1
witGetPartBuildAheadUB (partName, & buildAheadUBval);
d336 1
a336 1
forbidNullArg (buildAheadLimit, "buildAheadLimit");
d338 1
a338 1
* buildAheadLimit = buildAheadUBval[0];
d340 2
a341 2
free (buildAheadUBval);
}
d346 4
a349 4
const char * partName,
WitBoolean * buildAsap)
{
WitMaterialApiCall theCall (this, partName, "buildAsap");
d351 2
a352 2
apiGet (buildAsap, "buildAsap", theCall.myMaterial ()->buildAsap ());
}
d357 4
a360 4
const char * partName,
WitBoolean * buildNstn)
{
WitMaterialApiCall theCall (this, partName, "buildNstn");
d362 2
a363 2
apiGet (buildNstn, "buildNstn", theCall.myMaterial ()->buildNstn ());
}
d368 4
a371 4
const char * partName,
WitAttr * category)
{
WitPartApiCall theCall (this, partName);
d373 2
a374 2
apiGet (category, "category", theCall.myPart ()->apiCategory ());
}
d379 4
a382 4
const char *         partName,
const WitOVRealArg & consVol)
{
WitPartApiCall theCall (this, partName);
d384 2
a385 2
apiGet (consVol, "consVol", theCall.myPart ()->consVol ());
}
d390 21
a410 21
const char * partName,
int          consIndex,
char * *     consumingOperationName,
int *        bomEntryIndex)
{
WitPartApiCall theCall (this, partName);

WitBomEntry *  theBomEnt;

if (consIndex < 0 or
consIndex >= theCall.myPart ()->consumingBomEntries ().nElements ())
myMsgFac () ("bomEntryConsIndexRangeSmsg",
consIndex,
0,
theCall.myPart ()->consumingBomEntries ().nElements ());

theBomEnt = theCall.myPart ()->consumingBomEntries ().at (consIndex);

* consumingOperationName = theBomEnt->myOperationName ().apiDupCstring ();
* bomEntryIndex          = theBomEnt->localIndex ();
}
d415 25
a439 25
const char * partName,
int          consIndex,
char * *     consumingOperationName,
int *        bomEntryIndex,
int *        subsBomEntryIndex)
{
WitSubEntry * theSub;

WitPartApiCall theCall (this, partName);

// Make sure consIndex is valid.
//
if (consIndex < 0 or
consIndex >= theCall.myPart ()->consumingSubEntries ().nElements ())
myMsgFac () ("subEntryConsIndexRangeSmsg",
consIndex,
0,
theCall.myPart ()->consumingSubEntries ().nElements ());

theSub = theCall.myPart ()->consumingSubEntries ().at (consIndex);

* consumingOperationName = theSub->myOperationName ().apiDupCstring ();
* bomEntryIndex          = theSub->myBomEntIndex ();
* subsBomEntryIndex      = theSub->localIndex ();
}
d444 16
a459 16
const char *         partName,
const WitOVRealArg & inpVal)
{
myApiMgr_->startInnerFunc ();

if (wit34Compatible ())
{
myMsgFac () ("getting34AttributeWithCompatibilityCycleTime",
apiFuncName ());

witGetOperationCycleTime34 (partName, inpVal);
}
else
myMsgFac () ("getting34AttributeWithoutCompatibilityCycleTime",
apiFuncName ());
}
d468 21
a488 21
const char * partName,
int  *       lenDemandList,
char * * *   demandList)
{
WitDemand * theDemand;
int         i;

WitPartApiCall theCall (this, partName);

apiGet (
lenDemandList,
"lenDemandList",
theCall.myPart ()->myDemands ().nElements ());

apiAlloc (demandList, * lenDemandList);

i = 0;

forEachEl (theDemand, theCall.myPart ()->myDemands ())
(* demandList)[i++] = theDemand->demandName ().apiDupCstring ();
}
d493 17
a509 17
const char *         partName,
const WitOVRealArg & excessVol)
{
WitPeriod thePer;

WitPartApiCall theCall (this, partName);

forbidNullArg (excessVol, "excessVol");

apiAlloc (excessVol, nPeriods ());

forEachPeriod (thePer, myProblem ())
excessVol[thePer] =
myProblem ()->
myPostprocessor ()->
compExcessVol (theCall.myPart (), thePer);
}
d514 18
a531 18
const char * partNameParm,
WitBoolean * exists)
{
myApiMgr_->startInnerFunc ();

if (myCompMgr ()->findPart (partNameParm) != NULL)
{
myMsgFac () ("partDoesExist", partNameParm);

* exists = true;
}
else
{
myMsgFac () ("partDoesNotExist", partNameParm);

* exists = false;
}
}
d536 13
a548 13
const char *         partName,
const WitOVRealArg & focusShortageVol)
{
WitPartApiCall theCall (this, partName);

forbidStochMode ();

myProblem ()->computeFssIfNeeded ();

apiGet (              focusShortageVol,
"focusShortageVol",
theCall.myPart ()->focShortageVol ());
}
d553 4
a556 4
const char *         partName,
const WitOVRealArg & incLotSize)
{
myApiMgr_->startInnerFunc ();
d558 1
a558 1
prepGet34Attr ("Part", "incLotSize", "Operation", "incLotSize");
d560 2
a561 2
witGetOperationIncLotSize (partName, incLotSize);
}
d566 4
a569 4
const char *         partName,
const WitOVRealArg & minLotSize)
{
myApiMgr_->startInnerFunc ();
d571 1
a571 1
prepGet34Attr ("Part", "minLotSize", "Operation", "minLotSize");
d573 2
a574 2
witGetOperationMinLotSize (partName, minLotSize);
}
d579 4
a582 4
const char *         partName,
const WitOVRealArg & mrpConsVol)
{
WitPartApiCall theCall (this, partName);
d584 2
a585 2
apiGet (mrpConsVol, "mrpConsVol", theCall.myPart ()->mrpConsVol ());
}
d590 17
a606 17
const char *         partName,
const WitOVRealArg & mrpExcessVol)
{
WitPeriod thePer;

WitPartApiCall theCall (this, partName);

forbidNullArg (mrpExcessVol, "mrpExcessVol");

apiAlloc (mrpExcessVol, nPeriods ());

forEachPeriod (thePer, myProblem ())
mrpExcessVol[thePer] =
min (
theCall.myPart ()->mrpResidualVol ()[thePer],
theCall.myPart ()->supplyVol      ()[thePer]);
}
d611 4
a614 4
const char *         partName,
const WitOVRealArg & mrpProdVol)
{
myApiMgr_->startInnerFunc ();
d616 1
a616 1
prepGet34Attr ("Part", "mrpProdVol", "Operation", "mrpExecVol");
d618 2
a619 2
witGetOperationMrpExecVol (partName, mrpProdVol);
}
d624 9
a632 9
const char *         partName,
const WitOVRealArg & mrpResidualVol)
{
WitPartApiCall theCall (this, partName);

apiGet (              mrpResidualVol,
"mrpResidualVol",
theCall.myPart ()->mrpResidualVol ());
}
d637 44
a680 44
const char * partName,
int *        inpVal)
{
WitPart * partP;

myApiMgr_->startInnerFunc ();

if (wit34Compatible ())
{
partP = setGetPartInit (partName);

// If part is not a product, then return 0, otherwise get nBomEntries
// from operation.
//
if (partP->apiCategory() != WitPRODUCT)
{
myMsgFac () ("getting34AttributeNBomEntriesForNonProduct",
partName,
partP->categoryFrag ());

* inpVal = 0;
}
else
{
myMsgFac () ("getting34AttributeWithCompatibilityMode",
apiFuncName (),
"Part",
"nBomEntries",
"Operation",
"nBomEntries");

witGetOperationNBomEntries (partName, inpVal);
}

myInputID ()->setMyPart (NULL);
}
else
myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
apiFuncName (),
"Part",
"nBomEntries",
"Operation",
"nBomEntries");
}
d685 10
a694 10
const char * partName,
int *        nConsumingBomEntries)
{
WitPartApiCall theCall (this, partName);

apiGet (
nConsumingBomEntries,
"nConsumingBomEntries",
theCall.myPart ()->consumingBomEntries ().nElements ());
}
d699 10
a708 10
const char * partName,
int *        nConsumingSubsBomEntries)
{
WitPartApiCall theCall (this, partName);

apiGet (
nConsumingSubsBomEntries,
"nConsumingSubsBomEntries",
theCall.myPart ()->consumingSubEntries ().nElements ());
}
d713 10
a722 10
const char * partName,
int * nProducingBopEntries)
{
WitPartApiCall theCall (this, partName);

apiGet (
nProducingBopEntries,
"nProducingBopEntries",
theCall.myPart ()->producingBopEntries ().nElements ());
}
d727 4
a730 4
const char * partName,
int *        objectStage)
{
WitPartApiCall theCall (this, partName);
d732 2
a733 2
theCall.getObjectStage (objectStage);
}
d738 12
a749 12
const char *         partName,
const WitOVRealArg & obj1ScrapCost)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
myMsgFac () (
"getAttrNewNameMsg",
apiFuncName (),
"part",
"obj1ScrapCost",
"scrapCost");
d751 2
a752 2
witGetPartScrapCost (partName, obj1ScrapCost);
}
d757 12
a768 12
const char *         partName,
const WitOVRealArg & obj1StockCost)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
myMsgFac () (
"getAttrNewNameMsg",
apiFuncName (),
"part",
"obj1StockCost",
"stockCost");
d770 2
a771 2
witGetPartStockCost (partName, obj1StockCost);
}
d776 4
a779 4
const char *         partName,
const WitOVRealArg & obj1ProdCost)
{
myApiMgr_->startInnerFunc ();
d781 1
a781 1
prepGet34Attr ("Part", "obj1ProdCost", "Operation", "obj1ExecCost");
d783 2
a784 2
witGetOperationObj1ExecCost (partName, obj1ProdCost);
}
d789 6
a794 6
const char *         partName,
const WitOVRealArg & hardLB,
const WitOVRealArg & softLB,
const WitOVRealArg & hardUB)
{
myApiMgr_->startInnerFunc ();
d796 1
a796 1
prepGet34Attr ("Part", "prodBounds", "Operation", "execBounds");
d798 2
a799 2
witGetOperationExecBounds (partName, hardLB, softLB, hardUB);
}
d808 18
a825 18
const char *         partName,
const WitOVRealArg & prodVol)
{
myApiMgr_->startInnerFunc ();

if (wit34Compatible ())
{
prepGet34Attr ("Part", "prodVol", "Operation", "execVol");

witGetOperationExecVol (partName, prodVol);
}
else
{
WitPartApiCall theCall (this, partName);

apiGet (prodVol, "prodVol", theCall.myPart ()->prodVol ());
}
}
d830 21
a850 21
const char * partName,
int          prodIndex,
char * *     producingOperationName,
int *        bopEntryIndex)
{
WitBopEntry * theBopEnt;

WitPartApiCall theCall (this, partName);

if (prodIndex < 0 or
prodIndex >= theCall.myPart ()->producingBopEntries ().nElements ())
myMsgFac () ("bopEntryProdIndexRangeSmsg",
prodIndex,
0,
theCall.myPart ()->producingBopEntries ().nElements ());

theBopEnt = theCall.myPart ()->producingBopEntries ().at (prodIndex);

* producingOperationName = theBopEnt->myOperationName ().apiDupCstring ();
* bopEntryIndex          = theBopEnt->localIndex ();
}
d855 4
a858 4
const char *         partName,
const WitOVRealArg & reqVol)
{
WitPartApiCall theCall (this, partName);
d860 2
a861 2
apiGet (reqVol, "reqVol", theCall.myPart ()->reqVol ());
}
d866 4
a869 4
const char *         partName,
const WitOVRealArg & residualVol)
{
WitPartApiCall theCall (this, partName);
d871 2
a872 2
apiGet (residualVol, "residualVol", theCall.myPart ()->residualVol ());
}
d877 15
a891 15
const char * partName,
const int    thePer,
int *        resourceConIndex)
{
WitPartApiCall theCall (this, partName);

prepGetIndex (thePer);

apiGet (
resourceConIndex,
"resourceConIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
resourceConIndex (theCall.myPart (), thePer));
}
d896 15
a910 15
const char * partName,
const int    thePer,
int *        scrapVarIndex)
{
WitPartApiCall theCall (this, partName);

prepGetIndex (thePer);

apiGet (
scrapVarIndex,
"scrapVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
scrapVarIndex (theCall.myPart (), thePer));
}
d915 12
a926 12
const char * partName,
WitBoolean * propRouting)
{
WitPartApiCall theCall (this, partName);

if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
myMsgFac () (
"getVecAttrAsScalMsg",
apiFuncName (),
"part",
"propRouting",
"propRtg");
d928 2
a929 2
apiGet (propRouting, "propRouting", theCall.myPart ()->propRtg ()[0]);
}
d934 4
a937 4
const char *   partName,
WitBoolean * * propRtg)
{
WitPartApiCall theCall (this, partName);
d939 2
a940 2
apiGet (propRtg, "propRtg", theCall.myPart ()->propRtg ());
}
d945 5
a949 5
int  *     lenPartList,
char * * * partList)
{
WitPart * partj;
int       theIdx;
d951 1
a951 1
myApiMgr_->startInnerFunc ();
d953 1
a953 1
theIdx = 0;
d955 1
a955 1
* lenPartList = myCompMgr ()->nParts ();
d957 1
a957 1
apiAlloc (partList, * lenPartList);
d959 3
a961 3
forEachPart (partj, myProblem ())
(* partList)[theIdx ++] = partj->partName ().apiDupCstring ();
}
d966 4
a969 4
const char * partName,
WitBoolean * scrapAllowed)
{
WitPartApiCall theCall (this, partName);
d971 2
a972 2
apiGet (scrapAllowed, "scrapAllowed", theCall.myPart ()->scrapAllowed ());
}
d977 10
a986 10
const char *         partName,
const WitOVRealArg & scrapCost)
{
WitPartApiCall theCall (this, partName);

apiGet (
scrapCost,
"scrapCost",
theCall.myPart ()->scrapCost ());
}
d991 4
a994 4
const char *         partName,
const WitOVRealArg & scrapVol)
{
WitPartApiCall theCall (this, partName);
d996 2
a997 2
apiGet (scrapVol, "scrapVol", theCall.myPart ()->scrapVol ());
}
d1002 4
a1005 4
const char * partName,
WitBoolean * selForDel)
{
WitPartApiCall theCall (this, partName);
d1007 2
a1008 2
apiGet (selForDel, "selForDel", theCall.myPart ()->selForDel ());
}
d1013 4
a1016 4
const char *         partName,
const WitOVRealArg & shadowPrice)
{
WitPartApiCall theCall (this, partName);
d1018 2
a1019 2
apiGet (shadowPrice, "shadowPrice", theCall.myPart ()->shadowPrice ());
}
d1024 4
a1027 4
const char * partName,
WitBoolean * singleSource)
{
WitPartApiCall theCall (this, partName);
d1029 2
a1030 2
apiGet (singleSource, "singleSource", theCall.myPart ()->singleSource ());
}
d1035 6
a1040 6
const char *         partName,
const WitOVRealArg & hardLB,
const WitOVRealArg & softLB,
const WitOVRealArg & hardUB)
{
WitMaterialApiCall theCall (this, partName, "stockBounds");
d1042 2
a1043 2
apiGet (hardLB, softLB, hardUB, theCall.myMaterial ()->stockBounds ());
}
d1048 10
a1057 10
const char *         partName,
const WitOVRealArg & stockCost)
{
WitMaterialApiCall theCall (this, partName, "stockCost");

apiGet (
stockCost,
"stockCost",
theCall.myMaterial ()->stockCost ());
}
d1062 15
a1076 15
const char * partName,
const int    thePer,
int *        stockSlbConIndex)
{
WitMaterialApiCall theCall (this, partName, "stockSlbConIndex");

prepGetIndex (thePer);

apiGet (
stockSlbConIndex,
"stockSlbConIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
stockSlbConIndex (theCall.myMaterial (), thePer));
}
d1081 15
a1095 15
const char * partName,
const int    thePer,
int *        stockSlbvVarIndex)
{
WitMaterialApiCall theCall (this, partName, "stockSlbvVarIndex");

prepGetIndex (thePer);

apiGet (
stockSlbvVarIndex,
"stockSlbvVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
stockSlbvVarIndex (theCall.myMaterial (), thePer));
}
d1100 15
a1114 15
const char * partName,
const int    thePer,
int *        stockVarIndex)
{
WitMaterialApiCall theCall (this, partName, "stockVarIndex");

prepGetIndex (thePer);

apiGet (
stockVarIndex,
"stockVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
stockVarIndex (theCall.myMaterial (), thePer));
}
d1119 4
a1122 4
const char *         partName,
const WitOVRealArg & stockVol)
{
WitMaterialApiCall theCall (this, partName, "stockVol");
d1124 2
a1125 2
apiGet (stockVol, "stockVol", theCall.myMaterial ()->stockVol ());
}
d1130 4
a1133 4
const char *         partName,
const WitOVRealArg & supplyVol)
{
WitPartApiCall theCall (this, partName);
d1135 2
a1136 2
apiGet (supplyVol, "supplyVol", theCall.myPart ()->supplyVol ());
}
d1141 4
a1144 4
const char * partName,
int * *      yield)
{
myApiMgr_->startInnerFunc ();
d1146 1
a1146 1
prepGet34Attr ("Part", "yield", "Operation", "yield");
d1148 2
a1149 2
witGetOperationYield (partName, yield);
}
d1154 4
a1157 4
const char * partName,
void *       appData)
{
WitPartApiCall theCall (this, partName);
d1159 2
a1160 2
theCall.setAppData (appData);
}
d1165 13
a1177 13
const char * partName,
WitBoolean   asapPipOrder)
{
WitMaterialApiCall theCall (this, partName, "asapPipOrder");

theCall.prepBool (
"asapPipOrder",
theCall.myMaterial ()->asapPipOrder (),
asapPipOrder);

if (theCall.argsOK ())
theCall.myMaterial ()->setAsapPipOrder (asaBool (asapPipOrder));
}
d1182 13
a1194 13
const char * partName,
WitBoolean   baSelSplit)
{
WitMaterialApiCall theCall (this, partName, "baSelSplit");

theCall.prepBool (
"baSelSplit",
theCall.myMaterial ()->baSelSplit (),
baSelSplit);

if (theCall.argsOK ())
theCall.myMaterial ()->setBaSelSplit (asaBool (baSelSplit));
}
d1199 13
a1211 13
const char * partName,
WitBoolean   boundedLeadTimes)
{
WitPartApiCall theCall (this, partName);

theCall.prepBool (
"boundedLeadTimes",
theCall.myPart ()->boundedLeadTimes (),
boundedLeadTimes);

if (theCall.argsOK ())
theCall.myPart ()->setBoundedLeadTimes (asaBool (boundedLeadTimes));
}
d1216 10
a1225 10
const char * partName,
const int *  buildAheadUB)
{
WitMaterialApiCall theCall (this, partName, "buildAheadUB");

theCall.prepBuildAheadUB (buildAheadUB);

if (theCall.argsOK ())
theCall.myMaterial ()->setBuildAheadUB (buildAheadUB);
}
d1230 14
a1243 14
const char * partName,
int          buildAheadLimit)
{
WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
myMsgFac () (
"setVecAttrToScalMsg",
apiFuncName (),
"part",
"buildAheadLimit",
"buildAheadUB");
d1245 1
a1245 1
buildAheadUBVec = buildAheadLimit;
d1247 1
a1247 1
witSetPartBuildAheadUB (partName, buildAheadUBVec.myCVec ());
d1249 2
a1250 2
myApiMgr ()->releaseTempVecs ();
}
d1255 14
a1268 14
const char * partName,
WitBoolean   buildAsap)
{
WitMaterialApiCall theCall (this, partName, "buildAsap");

theCall.prepBa (
"buildAsap",
theCall.myMaterial ()->buildAsap (),
buildAsap,
"buildNstn");

if (theCall.argsOK ())
theCall.myMaterial ()->setBuildAsap (asaBool (buildAsap));
}
d1273 14
a1286 14
const char * partName,
WitBoolean   buildNstn)
{
WitMaterialApiCall theCall (this, partName, "buildNstn");

theCall.prepBa (
"buildNstn",
theCall.myMaterial ()->buildNstn (),
buildNstn,
"buildAsap");

if (theCall.argsOK ())
theCall.myMaterial ()->setBuildNstn (asaBool (buildNstn));
}
d1291 16
a1306 16
const char *         partName,
const WitIVRealArg & inpVal)
{
myApiMgr_->startInnerFunc ();

if (wit34Compatible ())
{
myMsgFac () ("setting34AttributeWithCompatibilityCycleTime",
apiFuncName ());

witSetOperationCycleTime34 (partName, inpVal);
}
else
myMsgFac () ("setting34AttributeWithoutCompatibilityCycleTime",
apiFuncName ());
}
d1311 4
a1314 4
const char *         partName,
const WitIVRealArg & incLotSize)
{
myApiMgr_->startInnerFunc ();
d1316 1
a1316 1
prepSet34Attr ("Part", "incLotSize", "Operation", "incLotSize");
d1318 2
a1319 2
witSetOperationIncLotSize (partName, incLotSize);
}
d1324 4
a1327 4
const char *         partName,
const WitIVRealArg & minLotSize)
{
myApiMgr_->startInnerFunc ();
d1329 1
a1329 1
prepSet34Attr ("Part", "minLotSize", "Operation", "minLotSize");
d1331 2
a1332 2
witSetOperationMinLotSize (partName, minLotSize);
}
d1337 4
a1340 4
const char *         partName,
const WitIVRealArg & obj1ProdCost)
{
myApiMgr_->startInnerFunc ();
d1342 1
a1342 1
prepSet34Attr ("Part", "obj1ProdCost", "Operation", "obj1ExecCost");
d1344 2
a1345 2
witSetOperationObj1ExecCost (partName, obj1ProdCost);
}
d1350 12
a1361 12
const char *         partName,
const WitIVRealArg & obj1ScrapCost)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
myMsgFac () (
"setAttrNewNameMsg",
apiFuncName (),
"part",
"obj1ScrapCost",
"scrapCost");
d1363 2
a1364 2
witSetPartScrapCost (partName, obj1ScrapCost);
}
d1369 12
a1380 12
const char *         partName,
const WitIVRealArg & obj1StockCost)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
myMsgFac () (
"setAttrNewNameMsg",
apiFuncName (),
"part",
"obj1StockCost",
"stockCost");
d1382 2
a1383 2
witSetPartStockCost (partName, obj1StockCost);
}
d1388 4
a1391 4
const char * partName,
int          objectStage)
{
WitPartApiCall theCall (this, partName);
d1393 2
a1394 2
theCall.setObjectStage (objectStage);
}
d1399 24
a1422 24
const char * partName,
const char * newName)
{
WitPartApiCall theCall (this, partName);

forbidNullArg (newName, "newName");

if (isNullCstring (newName))
myMsgFac () ("nullStringSmsg", "newName");

if (myCompMgr ()->findPart (newName))
myMsgFac () ("setNodeNameToDupSmsg",
"witSetPartPartName",
myMsgFac ().myFrag ("partFrag"),
newName);

theCall.prepString (
"partName",
theCall.myPart ()->partName (),
newName);

if (theCall.argsOK ())
theCall.myPart ()->setPartName (newName);
}
d1427 6
a1432 6
const char *         partName,
const WitIVRealArg & hardLB,
const WitIVRealArg & softLB,
const WitIVRealArg & hardUB)
{
myApiMgr_->startInnerFunc ();
d1434 1
a1434 1
prepSet34Attr ("Part", "prodBounds", "Operation", "execBounds");
d1436 2
a1437 2
witSetOperationExecBounds (partName, hardLB, softLB, hardUB);
}
d1446 4
a1449 4
const char *         partName,
const WitIVRealArg & prodVol)
{
myApiMgr_->startInnerFunc ();
d1451 1
a1451 1
prepSet34Attr ("Part", "prodVol", "Operation", "execVol");
d1453 2
a1454 2
witSetOperationExecVol (partName, prodVol);
}
d1459 14
a1472 14
const char * partName,
WitBoolean   propRouting)
{
WitTVec <WitBoolean> & propRtgVec = myApiMgr ()->reserveTempBooleanVec ();

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
myMsgFac () (
"setVecAttrToScalMsg",
apiFuncName (),
"part",
"propRouting",
"propRtg");
d1474 1
a1474 1
propRtgVec = propRouting;
d1476 1
a1476 1
witSetPartPropRtg (partName, propRtgVec.myCVec ());
d1478 2
a1479 2
myApiMgr ()->releaseTempVecs ();
}
d1484 10
a1493 10
const char *       partName,
const WitBoolean * propRtg)
{
WitPartApiCall theCall (this, partName);

theCall.prepBoolVec ("propRtg", propRtg);

if (theCall.argsOK ())
theCall.myPart ()->setPropRtg (propRtg);
}
d1498 12
a1509 12
const char * partName, WitBoolean scrapAllowed)
{
WitPartApiCall theCall (this, partName);

theCall.prepBool (
"scrapAllowed",
theCall.myPart ()->scrapAllowed (),
scrapAllowed);

if (theCall.argsOK ())
theCall.myPart ()->setScrapAllowed (asaBool (scrapAllowed));
}
d1514 23
a1536 23
const char *         partName,
const WitIVRealArg & scrapCost)
{
WitPeriod thePer;

WitPartApiCall theCall (this, partName);

theCall.prepDblVec ("scrapCost", scrapCost);

if (theCall.argsOK ())
{
forEachPeriod (thePer, myProblem ())
if (scrapCost[thePer] < 0.0)
myMsgFac () (
"negPartCostWmsg",
"scrapCost",
partName,
scrapCost[thePer],
thePer);

theCall.myPart ()->setScrapCost (scrapCost);
}
}
d1541 4
a1544 4
const char * partName,
WitBoolean   selForDel)
{
WitPartApiCall theCall (this, partName);
d1546 2
a1547 2
theCall.setSelForDel (selForDel);
}
d1552 12
a1563 12
const char * partName, WitBoolean singleSource)
{
WitPartApiCall theCall (this, partName);

theCall.prepBool (
"singleSource",
theCall.myPart ()->singleSource (),
singleSource);

if (theCall.argsOK ())
theCall.myPart ()->setSingleSource (asaBool (singleSource));
}
d1568 13
a1580 13
const char *         partName,
const WitIVRealArg & hardLB,
const WitIVRealArg & softLB,
const WitIVRealArg & hardUB)
{
WitMaterialApiCall theCall (this, partName, "stockBounds");

theCall.setBoundSet (
theCall.myMaterial ()->stockBounds (),
hardLB,
softLB,
hardUB);
}
d1585 22
a1606 22
const char *         partName,
const WitIVRealArg & stockCost)
{
WitMaterialApiCall theCall (this, partName, "stockCost");
WitPeriod          thePer;

theCall.prepDblVec ("stockCost", stockCost);

if (theCall.argsOK ())
{
forEachPeriod (thePer, myProblem ())
if (stockCost[thePer] < 0.0)
myMsgFac () (
"negPartCostWmsg",
"stockCost",
partName,
stockCost[thePer],
thePer);

theCall.myMaterial ()->setStockCost (stockCost);
}
}
d1611 10
a1620 10
const char *         partName,
const WitIVRealArg & supplyVol)
{
WitPartApiCall theCall (this, partName);

theCall.prepNonNegDblVec ("supplyVol", supplyVol);

if (theCall.argsOK ())
theCall.myPart ()->setSupplyVol (supplyVol);
}
d1625 4
a1628 4
const char * partName,
const int *  yield)
{
myApiMgr_->startInnerFunc ();
d1630 1
a1630 1
prepSet34Attr ("Part", "yield", "Operation", "yield");
d1632 2
a1633 2
witSetOperationYield (partName, yield);
}
d1638 19
a1656 19
{
if (partCategory == WitPRODUCT)
{
myMsgFac () ("addProductPartWith34Compatability", apiFuncName ());

addPartPost34 (partName, WitMATERIAL);

witAddOperation (partName);

witAddBopEntry (partName, partName);
}
else if (partCategory == WitRAW)
{
myMsgFac () ("addRawPartWith34Compatability", apiFuncName ());

addPartPost34 (partName, WitMATERIAL);
}
else if (partCategory == WitCAPACITY)
addPartPost34 (partName, WitCAPACITY);
d1658 2
a1659 2
else if (partCategory == WitMATERIAL)
addPartPost34 (partName, WitMATERIAL);
d1661 2
a1662 2
else
myMsgFac () ("unknownPartCategorySmsg", partCategory);
d1664 2
a1665 2
return getPartP (partName);
}
d1670 24
a1693 24
{
if (myMsgFac ().mayIssue ("partNameTypeApMsg"))
myMsgFac () ("partNameTypeApMsg", partName, partCategory);

if      (partCategory == WitCAPACITY)
partCategory = WitCAPACITY;
else if (partCategory == WitMATERIAL)
partCategory = WitMATERIAL;
else
myMsgFac () ("unknownPartCategorySmsg", partCategory);

if (isNullCstring (partName))
myMsgFac () ("nullStringSmsg", "partName");

if (myCompMgr ()->findPart (partName))
myMsgFac () ("dupPartApMsg", partName);

addingDelComp ("partFrag");

if (partCategory == WitCAPACITY)
return new WitCapacity (partName, myCompMgr ());
else
return new WitMaterial (partName, myCompMgr ());
}
d1701 2
a1702 2
{
WitPart * partP;
d1704 1
a1704 1
partP = myCompMgr ()->findPart (partName);
d1706 2
a1707 2
if (partP == NULL)
myMsgFac () ("undefinedPartMsg", partName);
d1709 2
a1710 2
return partP;
}
@


1.176
log
@Lead Time Bounds
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d51 2
a52 2
   {
   WitPart * thePart;
d54 1
a54 1
   forbidNullArg (partName, "partName");
d56 2
a57 2
   if (myMsgFac ().mayIssue ("partNameMsg"))
      myMsgFac () ("partNameMsg", partName);
d59 1
a59 1
   thePart = getPartP (partName);
d61 1
a61 1
   myInputID ()->setMyPart (thePart);
d63 2
a64 2
   return thePart;
   }
d69 5
a73 5
      const char * partName,
      const char * theAttName)
   {
   WitPart *     thePart;
   WitMaterial * theMat;
d75 1
a75 1
   thePart = setGetPartInit (partName);
d77 1
a77 1
   theMat  = thePart->thisMat ();
d79 3
a81 3
   if (theMat == NULL)
      {
      myInputID ()->setMyAttName (theAttName);
d83 2
a84 2
      myMsgFac () ("materialReqdSmsg");
      }
d86 2
a87 2
   return theMat;
   }
d92 12
a103 12
      const char * partName,
      WitAttr      partCategory)
   {
   myApiMgr_->startInnerFunc ();

   forbidNullArg (partName, "partName");

   if (wit34Compatible ())
      addPart34     (partName, partCategory);
   else
      addPartPost34 (partName, partCategory);
   }
d108 3
a110 3
      const char * partAndOperationName)
   {
   myApiMgr_->startInnerFunc ();
d112 1
a112 1
   witAddPart (partAndOperationName, WitMATERIAL);
d114 1
a114 1
   witAddOperation (partAndOperationName);
d116 2
a117 2
   witAddBopEntry (partAndOperationName, partAndOperationName);
   }
d122 38
a159 38
      const char * dupPartName,
      WitRun *     origWitRun,
      const char * origPartName)
   {
   startCopyObjData (origWitRun);

   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("partFrag"));

   WitPartApiCall dupCall (this,      dupPartName);

   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("partFrag"));

   WitPartApiCall origCall (origWitRun, origPartName);

   WitPart *  dupPart;
   WitPart * origPart;

    dupPart =  dupCall.myPart ();
   origPart = origCall.myPart ();

   if (dupPart == origPart)
      myMsgFac () ("copyObjectToSelfSmsg", myMsgFac ().myFrag ("partFrag"));

   if      ((dupPart->thisMat () != NULL) and (origPart->thisMat () != NULL))
      {
      dupPart->thisMat ()->copyAttrsFrom (origPart->thisMat ());
      }
   else if ((dupPart->thisCap () != NULL) and (origPart->thisCap () != NULL))
      {
      dupPart->thisCap ()->copyAttrsFrom (origPart->thisCap ());
      }
   else
      myMsgFac () ("copyPartCatMismatchSmsg",
          dupPart->partName     (),
          dupPart->categoryFrag (),
         origPart->partName     (),
         origPart->categoryFrag ());
   }
d164 7
a170 7
      int   *                lenList,
      char  * * *            partList,
      const WitOTDARealArg & shortageVolList)
   {
   int       nShortParts;
   WitPart * thePart;
   int       theIdx;
d172 1
a172 1
   myApiMgr_->startInnerFunc ();
d174 3
a176 3
   forbidNullArg (lenList,         "lenList");
   forbidNullArg (partList,        "partList");
   forbidNullArg (shortageVolList, "shortageVolList");
d178 1
a178 1
   forbidStochMode ();
d180 1
a180 1
   myProblem ()->computeFssIfNeeded ();
d182 1
a182 1
   nShortParts = 0;
d184 3
a186 3
   forEachPart (thePart, myProblem ())
      if (thePart->focShortageVol () != 0.0)
         nShortParts ++;
d188 1
a188 1
   * lenList = nShortParts;
d190 1
a190 1
   apiAlloc (partList, nShortParts);
d192 1
a192 1
   shortageVolList.apiAlloc (nShortParts, nPeriods ());
d194 1
a194 1
   theIdx = -1;
d196 4
a199 4
   forEachPart (thePart, myProblem ())
      if (thePart->focShortageVol () != 0.0)
         {
         theIdx ++;
d201 1
a201 1
         (* partList)[theIdx] = thePart->partName ().apiDupCstring ();
d203 3
a205 3
         shortageVolList.copyIntoRow (theIdx, thePart->focShortageVol ());
         }
   }
d210 2
a211 2
   {
   WitPart * thePart;
d213 1
a213 1
   myApiMgr_->startInnerFunc ();
d215 3
a217 3
   thePart =
      curItrDelCompForGet (WitAT_PART, "partFrag")->
         thisPart ();
d219 1
a219 1
   stronglyAssert (thePart != NULL);
d221 2
a222 2
   apiGet (partName, "partName", thePart->partName ());
   }
d227 4
a230 4
      const char * partName,
      void * *     appData)
   {
   WitPartApiCall theCall (this, partName);
d232 2
a233 2
   apiGet (appData, "appData", theCall.myPart ()->appData ());
   }
d238 10
a247 10
      const char * partName,
      WitBoolean * asapPipOrder)
   {
   WitMaterialApiCall theCall (this, partName, "asapPipOrder");

   apiGet (
                             asapPipOrder, 
                            "asapPipOrder", 
      theCall.myMaterial ()->asapPipOrder ());
   }
d252 4
a255 4
      const char * partName,
      WitBoolean * baSelSplit)
   {
   WitMaterialApiCall theCall (this, partName, "baSelSplit");
d257 2
a258 2
   apiGet (baSelSplit, "baSelSplit", theCall.myMaterial ()->baSelSplit ());
   }
d263 5
a267 5
      const char * partName,
      int *        lenList,
      char * * *   partNameList)
   {
   WitPartApiCall theCall (this, partName);
d269 2
a270 2
   forbidNullArg (lenList,      "lenList");
   forbidNullArg (partNameList, "partNameList");
d272 4
a275 4
   int &                  lenListRef      = * lenList;
   char * * &             partNameListRef = * partNameList;
   WitPart *              thePart;
   WitPtrVecItr <WitPart> theItr;
d277 1
a277 1
   myProblem ()->myPreprocessor ()->preprocess ();
d279 1
a279 1
   lenListRef = theCall.myPart ()->belowList ().length ();
d281 1
a281 1
   apiAlloc (partNameList, lenListRef);
d283 1
a283 1
   theCall.myPart ()->belowList ().attachItr (theItr);
d285 3
a287 3
   while (theItr.advance (thePart))
      partNameListRef[theItr.myIdx ()] = thePart->partName ().apiDupCstring ();
   }
d292 10
a301 10
      const char * partName,
      WitBoolean * boundedLeadTimes)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
                         boundedLeadTimes, 
                        "boundedLeadTimes", 
      theCall.myPart ()->boundedLeadTimes ());
   }
d306 9
a314 9
      const char * partName,
      int * *      buildAheadUB)
   {
   WitMaterialApiCall theCall (this, partName, "buildAheadUB");

   apiGet (                  buildAheadUB, 
                            "buildAheadUB", 
      theCall.myMaterial ()->buildAheadUB ());
   }
d319 4
a322 4
      const char * partName,
      int *        buildAheadLimit)
   {
   int * buildAheadUBval;
d324 1
a324 1
   myApiMgr_->startInnerFunc ();
d326 7
a332 7
   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "part",
         "buildAheadLimit",
         "buildAheadUB");
d334 1
a334 1
   witGetPartBuildAheadUB (partName, & buildAheadUBval);
d336 1
a336 1
   forbidNullArg (buildAheadLimit, "buildAheadLimit");
d338 1
a338 1
   * buildAheadLimit = buildAheadUBval[0];
d340 2
a341 2
   free (buildAheadUBval);
   }
d346 4
a349 4
      const char * partName,
      WitBoolean * buildAsap)
   {
   WitMaterialApiCall theCall (this, partName, "buildAsap");
d351 2
a352 2
   apiGet (buildAsap, "buildAsap", theCall.myMaterial ()->buildAsap ());
   }
d357 4
a360 4
      const char * partName,
      WitBoolean * buildNstn)
   {
   WitMaterialApiCall theCall (this, partName, "buildNstn");
d362 2
a363 2
   apiGet (buildNstn, "buildNstn", theCall.myMaterial ()->buildNstn ());
   }
d368 4
a371 4
      const char * partName,
      WitAttr * category)
   {
   WitPartApiCall theCall (this, partName);
d373 2
a374 2
   apiGet (category, "category", theCall.myPart ()->apiCategory ());
   }
d379 4
a382 4
      const char *         partName,
      const WitOVRealArg & consVol)
   {
   WitPartApiCall theCall (this, partName);
d384 2
a385 2
   apiGet (consVol, "consVol", theCall.myPart ()->consVol ());
   }
d390 21
a410 21
      const char * partName,
      int          consIndex,
      char * *     consumingOperationName,
      int *        bomEntryIndex)
   {
   WitPartApiCall theCall (this, partName);

   WitBomEntry *  theBomEnt;

   if (consIndex < 0 or
       consIndex >= theCall.myPart ()->consumingBomEntries ().nElements ())
      myMsgFac () ("bomEntryConsIndexRangeSmsg",
         consIndex,
         0,
         theCall.myPart ()->consumingBomEntries ().nElements ());

   theBomEnt = theCall.myPart ()->consumingBomEntries ().at (consIndex);

   * consumingOperationName = theBomEnt->myOperationName ().apiDupCstring ();
   * bomEntryIndex          = theBomEnt->localIndex ();
   }
d415 25
a439 25
      const char * partName,
      int          consIndex,
      char * *     consumingOperationName,
      int *        bomEntryIndex,
      int *        subsBomEntryIndex)
   {
   WitSubEntry * theSub;

   WitPartApiCall theCall (this, partName);

      // Make sure consIndex is valid.
      //
   if (consIndex < 0 or
       consIndex >= theCall.myPart ()->consumingSubEntries ().nElements ())
      myMsgFac () ("subEntryConsIndexRangeSmsg",
         consIndex,
         0,
         theCall.myPart ()->consumingSubEntries ().nElements ());

   theSub = theCall.myPart ()->consumingSubEntries ().at (consIndex);

   * consumingOperationName = theSub->myOperationName ().apiDupCstring ();
   * bomEntryIndex          = theSub->myBomEntIndex ();
   * subsBomEntryIndex      = theSub->localIndex ();
   }
d444 16
a459 16
      const char *         partName,
      const WitOVRealArg & inpVal)
   {
   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      myMsgFac () ("getting34AttributeWithCompatibilityCycleTime",
         apiFuncName ());

      witGetOperationCycleTime34 (partName, inpVal);
      }
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityCycleTime",
         apiFuncName ());
   }
d468 21
a488 21
      const char * partName,
      int  *       lenDemandList,
      char * * *   demandList)
   {
   WitDemand * theDemand;
   int         i;

   WitPartApiCall theCall (this, partName);

   apiGet (
      lenDemandList, 
      "lenDemandList", 
      theCall.myPart ()->myDemands ().nElements ());

   apiAlloc (demandList, * lenDemandList);

   i = 0;

   forEachEl (theDemand, theCall.myPart ()->myDemands ())
      (* demandList)[i++] = theDemand->demandName ().apiDupCstring ();
   }
d493 17
a509 17
      const char *         partName,
      const WitOVRealArg & excessVol)
   {
   WitPeriod thePer;

   WitPartApiCall theCall (this, partName);

   forbidNullArg (excessVol, "excessVol");

   apiAlloc (excessVol, nPeriods ());

   forEachPeriod (thePer, myProblem ())
      excessVol[thePer] =
         myProblem ()->
            myPostprocessor ()->
               compExcessVol (theCall.myPart (), thePer);
   }
d514 18
a531 18
      const char * partNameParm,
      WitBoolean * exists)
   {
   myApiMgr_->startInnerFunc ();

   if (myCompMgr ()->findPart (partNameParm) != NULL)
      {
      myMsgFac () ("partDoesExist", partNameParm);

      * exists = true;
      }
   else
      {
      myMsgFac () ("partDoesNotExist", partNameParm);

      * exists = false;
      }
   }
d536 13
a548 13
      const char *         partName,
      const WitOVRealArg & focusShortageVol)
   {
   WitPartApiCall theCall (this, partName);

   forbidStochMode ();

   myProblem ()->computeFssIfNeeded ();

   apiGet (              focusShortageVol, 
                        "focusShortageVol", 
      theCall.myPart ()->focShortageVol ());
   }
d553 4
a556 4
      const char *         partName,
      const WitOVRealArg & incLotSize)
   {
   myApiMgr_->startInnerFunc ();
d558 1
a558 1
   prepGet34Attr ("Part", "incLotSize", "Operation", "incLotSize");
d560 2
a561 2
   witGetOperationIncLotSize (partName, incLotSize);
   }
d566 4
a569 4
      const char *         partName,
      const WitOVRealArg & minLotSize)
   {
   myApiMgr_->startInnerFunc ();
d571 1
a571 1
   prepGet34Attr ("Part", "minLotSize", "Operation", "minLotSize");
d573 2
a574 2
   witGetOperationMinLotSize (partName, minLotSize);
   }
d579 4
a582 4
      const char *         partName,
      const WitOVRealArg & mrpConsVol)
   {
   WitPartApiCall theCall (this, partName);
d584 2
a585 2
   apiGet (mrpConsVol, "mrpConsVol", theCall.myPart ()->mrpConsVol ());
   }
d590 17
a606 17
      const char *         partName,
      const WitOVRealArg & mrpExcessVol)
   {
   WitPeriod thePer;

   WitPartApiCall theCall (this, partName);

   forbidNullArg (mrpExcessVol, "mrpExcessVol");

   apiAlloc (mrpExcessVol, nPeriods ());

   forEachPeriod (thePer, myProblem ())
      mrpExcessVol[thePer] =
         min (
            theCall.myPart ()->mrpResidualVol ()[thePer],
            theCall.myPart ()->supplyVol      ()[thePer]);
   }
d611 4
a614 4
      const char *         partName,
      const WitOVRealArg & mrpProdVol)
   {
   myApiMgr_->startInnerFunc ();
d616 1
a616 1
   prepGet34Attr ("Part", "mrpProdVol", "Operation", "mrpExecVol");
d618 2
a619 2
   witGetOperationMrpExecVol (partName, mrpProdVol);
   }
d624 9
a632 9
      const char *         partName,
      const WitOVRealArg & mrpResidualVol)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (              mrpResidualVol, 
                        "mrpResidualVol", 
      theCall.myPart ()->mrpResidualVol ());
   }
d637 44
a680 44
      const char * partName,
      int *        inpVal)
   {
   WitPart * partP;

   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      partP = setGetPartInit (partName);

         // If part is not a product, then return 0, otherwise get nBomEntries
         // from operation.
         //
      if (partP->apiCategory() != WitPRODUCT)
         {
         myMsgFac () ("getting34AttributeNBomEntriesForNonProduct",
            partName,
            partP->categoryFrag ());

         * inpVal = 0;
         }
      else
         {
         myMsgFac () ("getting34AttributeWithCompatibilityMode",
            apiFuncName (),
            "Part",
            "nBomEntries",
            "Operation",
            "nBomEntries");

         witGetOperationNBomEntries (partName, inpVal);
         }

      myInputID ()->setMyPart (NULL);
      }
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         "Part",
         "nBomEntries",
         "Operation",
         "nBomEntries");
   }
d685 10
a694 10
      const char * partName,
      int *        nConsumingBomEntries)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
       nConsumingBomEntries,
      "nConsumingBomEntries",
      theCall.myPart ()->consumingBomEntries ().nElements ());
   }
d699 10
a708 10
      const char * partName,
      int *        nConsumingSubsBomEntries)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
       nConsumingSubsBomEntries,
      "nConsumingSubsBomEntries",
      theCall.myPart ()->consumingSubEntries ().nElements ());
   }
d713 10
a722 10
      const char * partName,
      int * nProducingBopEntries)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
       nProducingBopEntries,
      "nProducingBopEntries",
      theCall.myPart ()->producingBopEntries ().nElements ());
   }
d727 4
a730 4
      const char * partName,
      int *        objectStage)
   {
   WitPartApiCall theCall (this, partName);
d732 2
a733 2
   theCall.getObjectStage (objectStage);
   }
d738 12
a749 12
      const char *         partName,
      const WitOVRealArg & obj1ScrapCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "part",
         "obj1ScrapCost",
         "scrapCost");
d751 2
a752 2
   witGetPartScrapCost (partName, obj1ScrapCost);
   }
d757 12
a768 12
      const char *         partName,
      const WitOVRealArg & obj1StockCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "part",
         "obj1StockCost",
         "stockCost");
d770 2
a771 2
   witGetPartStockCost (partName, obj1StockCost);
   }
d776 4
a779 4
      const char *         partName,
      const WitOVRealArg & obj1ProdCost)
   {
   myApiMgr_->startInnerFunc ();
d781 1
a781 1
   prepGet34Attr ("Part", "obj1ProdCost", "Operation", "obj1ExecCost");
d783 2
a784 2
   witGetOperationObj1ExecCost (partName, obj1ProdCost);
   }
d789 6
a794 6
      const char *         partName,
      const WitOVRealArg & hardLB,
      const WitOVRealArg & softLB,
      const WitOVRealArg & hardUB)
   {
   myApiMgr_->startInnerFunc ();
d796 1
a796 1
   prepGet34Attr ("Part", "prodBounds", "Operation", "execBounds");
d798 2
a799 2
   witGetOperationExecBounds (partName, hardLB, softLB, hardUB);
   }
d808 18
a825 18
      const char *         partName,
      const WitOVRealArg & prodVol)
   {
   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      prepGet34Attr ("Part", "prodVol", "Operation", "execVol");

      witGetOperationExecVol (partName, prodVol);
      }
   else
      {
      WitPartApiCall theCall (this, partName);

      apiGet (prodVol, "prodVol", theCall.myPart ()->prodVol ());
      }
   }
d830 21
a850 21
      const char * partName,
      int          prodIndex,
      char * *     producingOperationName,
      int *        bopEntryIndex)
   {
   WitBopEntry * theBopEnt;

   WitPartApiCall theCall (this, partName);

   if (prodIndex < 0 or
       prodIndex >= theCall.myPart ()->producingBopEntries ().nElements ())
      myMsgFac () ("bopEntryProdIndexRangeSmsg",
         prodIndex,
         0,
         theCall.myPart ()->producingBopEntries ().nElements ());

   theBopEnt = theCall.myPart ()->producingBopEntries ().at (prodIndex);

   * producingOperationName = theBopEnt->myOperationName ().apiDupCstring ();
   * bopEntryIndex          = theBopEnt->localIndex ();
   }
d855 4
a858 4
      const char *         partName,
      const WitOVRealArg & reqVol)
   {
   WitPartApiCall theCall (this, partName);
d860 2
a861 2
   apiGet (reqVol, "reqVol", theCall.myPart ()->reqVol ());
   }
d866 4
a869 4
      const char *         partName,
      const WitOVRealArg & residualVol)
   {
   WitPartApiCall theCall (this, partName);
d871 2
a872 2
   apiGet (residualVol, "residualVol", theCall.myPart ()->residualVol ());
   }
d877 15
a891 15
      const char * partName,
      const int    thePer,
      int *        resourceConIndex)
   {
   WitPartApiCall theCall (this, partName);

   prepGetIndex (thePer);

   apiGet (
       resourceConIndex,
      "resourceConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            resourceConIndex (theCall.myPart (), thePer));
   }
d896 15
a910 15
      const char * partName,
      const int    thePer,
      int *        scrapVarIndex)
   {
   WitPartApiCall theCall (this, partName);

   prepGetIndex (thePer);

   apiGet (
       scrapVarIndex,
      "scrapVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            scrapVarIndex (theCall.myPart (), thePer));
   }
d915 12
a926 12
      const char * partName,
      WitBoolean * propRouting)
   {
   WitPartApiCall theCall (this, partName);

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "part",
         "propRouting",
         "propRtg");
d928 2
a929 2
   apiGet (propRouting, "propRouting", theCall.myPart ()->propRtg ()[0]);
   }
d934 4
a937 4
      const char *   partName,
      WitBoolean * * propRtg)
   {
   WitPartApiCall theCall (this, partName);
d939 2
a940 2
   apiGet (propRtg, "propRtg", theCall.myPart ()->propRtg ());
   }
d945 5
a949 5
      int  *     lenPartList,
      char * * * partList)
   {
   WitPart * partj;
   int       theIdx;
d951 1
a951 1
   myApiMgr_->startInnerFunc ();
d953 1
a953 1
   theIdx = 0;
d955 1
a955 1
   * lenPartList = myCompMgr ()->nParts ();
d957 1
a957 1
   apiAlloc (partList, * lenPartList);
d959 3
a961 3
   forEachPart (partj, myProblem ())
      (* partList)[theIdx ++] = partj->partName ().apiDupCstring ();
   }
d966 4
a969 4
      const char * partName,
      WitBoolean * scrapAllowed)
   {
   WitPartApiCall theCall (this, partName);
d971 2
a972 2
   apiGet (scrapAllowed, "scrapAllowed", theCall.myPart ()->scrapAllowed ());
   }
d977 10
a986 10
      const char *         partName,
      const WitOVRealArg & scrapCost)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (
       scrapCost,
      "scrapCost",
      theCall.myPart ()->scrapCost ());
   }
d991 4
a994 4
      const char *         partName,
      const WitOVRealArg & scrapVol)
   {
   WitPartApiCall theCall (this, partName);
d996 2
a997 2
   apiGet (scrapVol, "scrapVol", theCall.myPart ()->scrapVol ());
   }
d1002 4
a1005 4
      const char * partName,
      WitBoolean * selForDel)
   {
   WitPartApiCall theCall (this, partName);
d1007 2
a1008 2
   apiGet (selForDel, "selForDel", theCall.myPart ()->selForDel ());
   }
d1013 4
a1016 4
      const char *         partName,
      const WitOVRealArg & shadowPrice)
   {
   WitPartApiCall theCall (this, partName);
d1018 2
a1019 2
   apiGet (shadowPrice, "shadowPrice", theCall.myPart ()->shadowPrice ());
   }
d1024 4
a1027 4
      const char * partName,
      WitBoolean * singleSource)
   {
   WitPartApiCall theCall (this, partName);
d1029 2
a1030 2
   apiGet (singleSource, "singleSource", theCall.myPart ()->singleSource ());
   }
d1035 6
a1040 6
      const char *         partName,
      const WitOVRealArg & hardLB,
      const WitOVRealArg & softLB,
      const WitOVRealArg & hardUB)
   {
   WitMaterialApiCall theCall (this, partName, "stockBounds");
d1042 2
a1043 2
   apiGet (hardLB, softLB, hardUB, theCall.myMaterial ()->stockBounds ());
   }
d1048 10
a1057 10
      const char *         partName,
      const WitOVRealArg & stockCost)
   {
   WitMaterialApiCall theCall (this, partName, "stockCost");

   apiGet (
       stockCost,
      "stockCost",
      theCall.myMaterial ()->stockCost ());
   }
d1062 15
a1076 15
      const char * partName,
      const int    thePer,
      int *        stockSlbConIndex)
   {
   WitMaterialApiCall theCall (this, partName, "stockSlbConIndex");

   prepGetIndex (thePer);

   apiGet (
       stockSlbConIndex,
      "stockSlbConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            stockSlbConIndex (theCall.myMaterial (), thePer));
   }
d1081 15
a1095 15
      const char * partName,
      const int    thePer,
      int *        stockSlbvVarIndex)
   {
   WitMaterialApiCall theCall (this, partName, "stockSlbvVarIndex");

   prepGetIndex (thePer);

   apiGet (
       stockSlbvVarIndex,
      "stockSlbvVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            stockSlbvVarIndex (theCall.myMaterial (), thePer));
   }
d1100 15
a1114 15
      const char * partName,
      const int    thePer,
      int *        stockVarIndex)
   {
   WitMaterialApiCall theCall (this, partName, "stockVarIndex");

   prepGetIndex (thePer);

   apiGet (
       stockVarIndex,
      "stockVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            stockVarIndex (theCall.myMaterial (), thePer));
   }
d1119 4
a1122 4
      const char *         partName,
      const WitOVRealArg & stockVol)
   {
   WitMaterialApiCall theCall (this, partName, "stockVol");
d1124 2
a1125 2
   apiGet (stockVol, "stockVol", theCall.myMaterial ()->stockVol ());
   }
d1130 4
a1133 4
      const char *         partName,
      const WitOVRealArg & supplyVol)
   {
   WitPartApiCall theCall (this, partName);
d1135 2
a1136 2
   apiGet (supplyVol, "supplyVol", theCall.myPart ()->supplyVol ());
   }
d1141 4
a1144 4
      const char * partName,
      int * *      yield)
   {
   myApiMgr_->startInnerFunc ();
d1146 1
a1146 1
   prepGet34Attr ("Part", "yield", "Operation", "yield");
d1148 2
a1149 2
   witGetOperationYield (partName, yield);
   }
d1154 4
a1157 4
      const char * partName,
      void *       appData)
   {
   WitPartApiCall theCall (this, partName);
d1159 2
a1160 2
   theCall.setAppData (appData);
   }
d1165 13
a1177 13
      const char * partName,
      WitBoolean   asapPipOrder)
   {
   WitMaterialApiCall theCall (this, partName, "asapPipOrder");

   theCall.prepBool (    
                            "asapPipOrder", 
      theCall.myMaterial ()->asapPipOrder (), 
                             asapPipOrder);

   if (theCall.argsOK ())
      theCall.myMaterial ()->setAsapPipOrder (asaBool (asapPipOrder));
   }
d1182 13
a1194 13
      const char * partName,
      WitBoolean   baSelSplit)
   {
   WitMaterialApiCall theCall (this, partName, "baSelSplit");

   theCall.prepBool (    
                            "baSelSplit", 
      theCall.myMaterial ()->baSelSplit (), 
                             baSelSplit);

   if (theCall.argsOK ())
      theCall.myMaterial ()->setBaSelSplit (asaBool (baSelSplit));
   }
d1199 13
a1211 13
      const char * partName,
      WitBoolean   boundedLeadTimes)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepBool (    
                        "boundedLeadTimes", 
      theCall.myPart ()->boundedLeadTimes (), 
                         boundedLeadTimes);

   if (theCall.argsOK ())
      theCall.myPart ()->setBoundedLeadTimes (asaBool (boundedLeadTimes));
   }
d1216 10
a1225 10
      const char * partName,
      const int *  buildAheadUB)
   {
   WitMaterialApiCall theCall (this, partName, "buildAheadUB");

   theCall.prepBuildAheadUB (buildAheadUB);

   if (theCall.argsOK ())
      theCall.myMaterial ()->setBuildAheadUB (buildAheadUB);
   }
d1230 14
a1243 14
      const char * partName,
      int          buildAheadLimit)
   {
   WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "part",
         "buildAheadLimit",
         "buildAheadUB");
d1245 1
a1245 1
   buildAheadUBVec = buildAheadLimit;
d1247 1
a1247 1
   witSetPartBuildAheadUB (partName, buildAheadUBVec.myCVec ());
d1249 2
a1250 2
   myApiMgr ()->releaseTempVecs ();
   }
d1255 14
a1268 14
      const char * partName,
      WitBoolean   buildAsap)
   {
   WitMaterialApiCall theCall (this, partName, "buildAsap");

   theCall.prepBa (
      "buildAsap", 
      theCall.myMaterial ()->buildAsap (), 
      buildAsap, 
      "buildNstn");

   if (theCall.argsOK ())
      theCall.myMaterial ()->setBuildAsap (asaBool (buildAsap));
   }
d1273 14
a1286 14
      const char * partName,
      WitBoolean   buildNstn)
   {
   WitMaterialApiCall theCall (this, partName, "buildNstn");

   theCall.prepBa (
      "buildNstn", 
      theCall.myMaterial ()->buildNstn (), 
      buildNstn, 
      "buildAsap");

   if (theCall.argsOK ())
      theCall.myMaterial ()->setBuildNstn (asaBool (buildNstn));
   }
d1291 16
a1306 16
      const char *         partName,
      const WitIVRealArg & inpVal)
   {
   myApiMgr_->startInnerFunc ();

   if (wit34Compatible ())
      {
      myMsgFac () ("setting34AttributeWithCompatibilityCycleTime",
         apiFuncName ());

      witSetOperationCycleTime34 (partName, inpVal);
      }
   else
      myMsgFac () ("setting34AttributeWithoutCompatibilityCycleTime",
         apiFuncName ());
   }
d1311 4
a1314 4
      const char *         partName,
      const WitIVRealArg & incLotSize)
   {
   myApiMgr_->startInnerFunc ();
d1316 1
a1316 1
   prepSet34Attr ("Part", "incLotSize", "Operation", "incLotSize");
d1318 2
a1319 2
   witSetOperationIncLotSize (partName, incLotSize);
   }
d1324 4
a1327 4
      const char *         partName,
      const WitIVRealArg & minLotSize)
   {
   myApiMgr_->startInnerFunc ();
d1329 1
a1329 1
   prepSet34Attr ("Part", "minLotSize", "Operation", "minLotSize");
d1331 2
a1332 2
   witSetOperationMinLotSize (partName, minLotSize);
   }
d1337 4
a1340 4
      const char *         partName,
      const WitIVRealArg & obj1ProdCost)
   {
   myApiMgr_->startInnerFunc ();
d1342 1
a1342 1
   prepSet34Attr ("Part", "obj1ProdCost", "Operation", "obj1ExecCost");
d1344 2
a1345 2
   witSetOperationObj1ExecCost (partName, obj1ProdCost);
   }
d1350 12
a1361 12
      const char *         partName,
      const WitIVRealArg & obj1ScrapCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "part",
         "obj1ScrapCost",
         "scrapCost");
d1363 2
a1364 2
   witSetPartScrapCost (partName, obj1ScrapCost);
   }
d1369 12
a1380 12
      const char *         partName,
      const WitIVRealArg & obj1StockCost)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "part",
         "obj1StockCost",
         "stockCost");
d1382 2
a1383 2
   witSetPartStockCost (partName, obj1StockCost);
   }
d1388 4
a1391 4
      const char * partName,
      int          objectStage)
   {
   WitPartApiCall theCall (this, partName);
d1393 2
a1394 2
   theCall.setObjectStage (objectStage);
   }
d1399 24
a1422 24
      const char * partName,
      const char * newName)
   {
   WitPartApiCall theCall (this, partName);

   forbidNullArg (newName, "newName");

   if (isNullCstring (newName))
      myMsgFac () ("nullStringSmsg", "newName");

   if (myCompMgr ()->findPart (newName))
      myMsgFac () ("setNodeNameToDupSmsg",
         "witSetPartPartName",
         myMsgFac ().myFrag ("partFrag"),
         newName);

   theCall.prepString (
                        "partName",
      theCall.myPart ()->partName (),
                          newName);

   if (theCall.argsOK ())
      theCall.myPart ()->setPartName (newName);
   }
d1427 6
a1432 6
    const char *         partName,
    const WitIVRealArg & hardLB,
    const WitIVRealArg & softLB,
    const WitIVRealArg & hardUB)
   {
   myApiMgr_->startInnerFunc ();
d1434 1
a1434 1
   prepSet34Attr ("Part", "prodBounds", "Operation", "execBounds");
d1436 2
a1437 2
   witSetOperationExecBounds (partName, hardLB, softLB, hardUB);
   }
d1446 4
a1449 4
      const char *         partName,
      const WitIVRealArg & prodVol)
   {
   myApiMgr_->startInnerFunc ();
d1451 1
a1451 1
   prepSet34Attr ("Part", "prodVol", "Operation", "execVol");
d1453 2
a1454 2
   witSetOperationExecVol (partName, prodVol);
   }
d1459 14
a1472 14
      const char * partName,
      WitBoolean   propRouting)
   {
   WitTVec <WitBoolean> & propRtgVec = myApiMgr ()->reserveTempBooleanVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "part",
         "propRouting",
         "propRtg");
d1474 1
a1474 1
   propRtgVec = propRouting;
d1476 1
a1476 1
   witSetPartPropRtg (partName, propRtgVec.myCVec ());
d1478 2
a1479 2
   myApiMgr ()->releaseTempVecs ();
   }
d1484 10
a1493 10
      const char *       partName,
      const WitBoolean * propRtg)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepBoolVec ("propRtg", propRtg);

   if (theCall.argsOK ())
      theCall.myPart ()->setPropRtg (propRtg);
   }
d1498 12
a1509 12
      const char * partName, WitBoolean scrapAllowed)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepBool (    
                        "scrapAllowed", 
      theCall.myPart ()->scrapAllowed (), 
                         scrapAllowed);

   if (theCall.argsOK ())
      theCall.myPart ()->setScrapAllowed (asaBool (scrapAllowed));
   }
d1514 23
a1536 23
      const char *         partName,
      const WitIVRealArg & scrapCost)
   {
   WitPeriod thePer;

   WitPartApiCall theCall (this, partName);

   theCall.prepDblVec ("scrapCost", scrapCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (scrapCost[thePer] < 0.0)
            myMsgFac () (
               "negPartCostWmsg",
               "scrapCost",
               partName,
               scrapCost[thePer],
               thePer);

      theCall.myPart ()->setScrapCost (scrapCost);
      }
   }
d1541 4
a1544 4
      const char * partName,
      WitBoolean   selForDel)
   {
   WitPartApiCall theCall (this, partName);
d1546 2
a1547 2
   theCall.setSelForDel (selForDel);
   }
d1552 12
a1563 12
      const char * partName, WitBoolean singleSource)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepBool (    
                        "singleSource", 
      theCall.myPart ()->singleSource (), 
                         singleSource);

   if (theCall.argsOK ())
      theCall.myPart ()->setSingleSource (asaBool (singleSource));
   }
d1568 13
a1580 13
      const char *         partName,
      const WitIVRealArg & hardLB,
      const WitIVRealArg & softLB,
      const WitIVRealArg & hardUB)
   {
   WitMaterialApiCall theCall (this, partName, "stockBounds");

   theCall.setBoundSet (
      theCall.myMaterial ()->stockBounds (), 
      hardLB, 
      softLB, 
      hardUB);
   }
d1585 22
a1606 22
      const char *         partName,
      const WitIVRealArg & stockCost)
   {
   WitMaterialApiCall theCall (this, partName, "stockCost");
   WitPeriod          thePer;

   theCall.prepDblVec ("stockCost", stockCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (stockCost[thePer] < 0.0)
            myMsgFac () (
               "negPartCostWmsg",
               "stockCost",
               partName,
               stockCost[thePer],
               thePer);

      theCall.myMaterial ()->setStockCost (stockCost);
      }
   }
d1611 10
a1620 10
      const char *         partName,
      const WitIVRealArg & supplyVol)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepNonNegDblVec ("supplyVol", supplyVol);

   if (theCall.argsOK ())
      theCall.myPart ()->setSupplyVol (supplyVol);
   }
d1625 4
a1628 4
      const char * partName,
      const int *  yield)
   {
   myApiMgr_->startInnerFunc ();
d1630 1
a1630 1
   prepSet34Attr ("Part", "yield", "Operation", "yield");
d1632 2
a1633 2
   witSetOperationYield (partName, yield);
   }
d1638 19
a1656 19
   {
   if (partCategory == WitPRODUCT)
      {
      myMsgFac () ("addProductPartWith34Compatability", apiFuncName ());

      addPartPost34 (partName, WitMATERIAL);

      witAddOperation (partName);

      witAddBopEntry (partName, partName);
      }
   else if (partCategory == WitRAW)
      {
      myMsgFac () ("addRawPartWith34Compatability", apiFuncName ());

      addPartPost34 (partName, WitMATERIAL);
      }
   else if (partCategory == WitCAPACITY)
      addPartPost34 (partName, WitCAPACITY);
d1658 2
a1659 2
   else if (partCategory == WitMATERIAL)
      addPartPost34 (partName, WitMATERIAL);
d1661 2
a1662 2
   else
      myMsgFac () ("unknownPartCategorySmsg", partCategory);
d1664 2
a1665 2
   return getPartP (partName);
   }
d1670 24
a1693 24
   {
   if (myMsgFac ().mayIssue ("partNameTypeApMsg"))
      myMsgFac () ("partNameTypeApMsg", partName, partCategory);

   if      (partCategory == WitCAPACITY)
      partCategory = WitCAPACITY;
   else if (partCategory == WitMATERIAL)
      partCategory = WitMATERIAL;
   else
      myMsgFac () ("unknownPartCategorySmsg", partCategory);

   if (isNullCstring (partName))
      myMsgFac () ("nullStringSmsg", "partName");

   if (myCompMgr ()->findPart (partName))
      myMsgFac () ("dupPartApMsg", partName);

   addingDelComp ("partFrag");

   if (partCategory == WitCAPACITY)
      return new WitCapacity (partName, myCompMgr ());
   else
      return new WitMaterial (partName, myCompMgr ());
   }
d1701 2
a1702 2
   {
   WitPart * partP;
d1704 1
a1704 1
   partP = myCompMgr ()->findPart (partName);
d1706 2
a1707 2
   if (partP == NULL)
      myMsgFac () ("undefinedPartMsg", partName);
d1709 2
a1710 2
   return partP;
   }
@


1.175
log
@Lead Time Bounds.
@
text
@a1203 3
   if (not myGlobalComp ()->ltbAllowed ())
      myMsgFac () ("attNyaSmsg", "boundedLeadTimes");

@


1.174
log
@Lead Time Bounds.
@
text
@d291 1
a291 1
void WitRun::witGetPartBoundedLeadTime (
d293 1
a293 1
      WitBoolean * boundedLeadTime)
d298 3
a300 3
                         boundedLeadTime, 
                        "boundedLeadTime", 
      theCall.myPart ()->boundedLeadTime ());
d1198 1
a1198 1
void WitRun::witSetPartBoundedLeadTime (
d1200 1
a1200 1
      WitBoolean   boundedLeadTime)
d1205 1
a1205 1
      myMsgFac () ("attNyaSmsg", "boundedLeadTime");
d1208 3
a1210 3
                        "boundedLeadTime", 
      theCall.myPart ()->boundedLeadTime (), 
                         boundedLeadTime);
d1213 1
a1213 1
      theCall.myPart ()->setBoundedLeadTime (asaBool (boundedLeadTime));
@


1.173
log
@Lead Time Bounds.
@
text
@d295 1
a295 1
   WitMaterialApiCall theCall (this, partName, "boundedLeadTime");
d298 3
a300 3
                             boundedLeadTime, 
                            "boundedLeadTime", 
      theCall.myMaterial ()->boundedLeadTime ());
d1202 1
a1202 1
   WitMaterialApiCall theCall (this, partName, "boundedLeadTime");
d1208 3
a1210 3
                            "boundedLeadTime", 
      theCall.myMaterial ()->boundedLeadTime (), 
                             boundedLeadTime);
d1213 1
a1213 1
      theCall.myMaterial ()->setBoundedLeadTime (asaBool (boundedLeadTime));
@


1.172
log
@Bounded Lead Times
@
text
@d1204 1
a1204 1
   if (not myGlobalComp ()->bltAllowed ())
@


1.171
log
@Bounded Lead Times
@
text
@d291 1
a291 1
void WitRun::witGetPartBoundedLeadTimes (
d293 1
a293 1
      WitBoolean * boundedLeadTimes)
d295 1
a295 1
   WitMaterialApiCall theCall (this, partName, "boundedLeadTimes");
d298 3
a300 3
                             boundedLeadTimes, 
                            "boundedLeadTimes", 
      theCall.myMaterial ()->boundedLeadTimes ());
d1198 1
a1198 1
void WitRun::witSetPartBoundedLeadTimes (
d1200 1
a1200 1
      WitBoolean   boundedLeadTimes)
d1202 1
a1202 1
   WitMaterialApiCall theCall (this, partName, "boundedLeadTimes");
d1205 1
a1205 1
      myMsgFac () ("attNyaSmsg", "boundedLeadTimes");
d1208 3
a1210 3
                            "boundedLeadTimes", 
      theCall.myMaterial ()->boundedLeadTimes (), 
                             boundedLeadTimes);
d1213 1
a1213 1
      theCall.myMaterial ()->setBoundedLeadTimes (asaBool (boundedLeadTimes));
@


1.170
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d291 14
d1198 20
@


1.169
log
@Multi-obj mode.
@
text
@d36 1
a36 1
#include <Global.h>
@


1.168
log
@Removing objective #2.
@
text
@d935 1
a935 1
   int       i;
d939 1
a939 1
   i = 0;
d946 1
a946 1
      (* partList)[i++] = partj->partName ().apiDupCstring ();
@


1.167
log
@Removing objective #2.
@
text
@d1497 1
a1497 1
               "negPartObj1CostCoef",
d1567 1
a1567 1
               "negPartObj1CostCoef",
@


1.166
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@a1125 11
void WitRun::witGetPartUnitCost (
      const char *         partName,
      const WitOSRealArg & unitCost)
   {
   WitPartApiCall theCall (this, partName);

   apiGet (unitCost, "unitCost", theCall.myPart ()->unitCost ());
   }

//------------------------------------------------------------------------------

a1592 17
void WitRun::witSetPartUnitCost (
      const char *         partName,
      const WitISRealArg & unitCost)
   {
   WitPartApiCall theCall (this, partName);

   theCall.prepNonNegDouble (
                        "unitCost", 
      theCall.myPart ()->unitCost (), 
                         unitCost);

   if (theCall.argsOK ())
      theCall.myPart ()->setUnitCost (unitCost);
   }

//------------------------------------------------------------------------------

@


1.165
log
@Removed many conversions of string constant to char *.
@
text
@d43 1
@


1.164
log
@Object name change.
@
text
@a65 3
// setGetMaterialInit
// Initilization of some witSetPart* functions.
//------------------------------------------------------------------------------
d69 1
a69 1
      WitAttr      theAttr)
d80 1
a80 1
      myInputID ()->setMyAttr (theAttr);
@


1.163
log
@Object name change.
@
text
@d1386 2
d1389 1
a1389 1
      myMsgFac () ("nullNameSmsg", newName);
d1681 1
a1681 1
      myMsgFac () ("nullNameSmsg", partName);
@


1.162
log
@Object name change.
@
text
@d1386 1
a1386 1
   if (isNullString (newName))
d1678 1
a1678 1
   if (isNullString (partName))
@


1.161
log
@Object name changing.
@
text
@d1401 1
a1401 1
      myCompMgr ()->setPartName (theCall.myPart (), newName);
@


1.160
log
@Object name changing.
@
text
@d1381 2
a1382 2
      const char * oldPartName,
      const char * newPartName)
d1384 1
a1384 1
   WitPartApiCall theCall (this, oldPartName);
d1386 2
a1387 2
   if (isNullString (newPartName))
      myMsgFac () ("nullNameSmsg", newPartName);
d1389 5
a1393 2
   if (myCompMgr ()->findPart (newPartName))
      myMsgFac () ("setPartNameToDupSmsg", newPartName);
d1398 1
a1398 1
                      newPartName);
d1401 1
a1401 1
      myCompMgr ()->setPartName (theCall.myPart (), newPartName);
@


1.159
log
@Stochastic Implosion
@
text
@d1380 23
@


1.158
log
@Stochastic Implosion
@
text
@d714 11
a1021 11
void WitRun::witGetPartStageIndex (
      const char * partName,
      int *        stageIndex)
   {
   WitPartApiCall theCall (this, partName);

   theCall.getStageIndex (stageIndex);
   }

//------------------------------------------------------------------------------

d1369 11
a1520 11
void WitRun::witSetPartStageIndex (
      const char * partName,
      int          stageIndex)
   {
   WitPartApiCall theCall (this, partName);

   theCall.setStageIndex (stageIndex);
   }

//------------------------------------------------------------------------------

@


1.157
log
@Stochastic Implosion
@
text
@d1017 1
a1017 13
   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "stageIndex",
         myMsgFac ().myFrag ("partFrag"));

   if (myStochImpMgr ()->stochMode ())
      if (not myStochImpMgr ()->stageByObject ())
         myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

   apiGet (
      stageIndex,
      "stageIndex",
      myStochImpMgr ()->stageIndex (theCall.myPart ()));
@


1.156
log
@Stochastic Implosion
@
text
@a1527 4
   if (myStochImpMgr ()->stochMode ())
      if (not myStochImpMgr ()->stageByObject ())
         myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

@


1.155
log
@Stochastic Implosion
@
text
@d1022 4
d1528 4
@


1.154
log
@Stochastic Implosion
@
text
@d1578 1
a1578 1
   theCall.prepSetPartSupplyVol (supplyVol);
@


1.153
log
@Stochastic Implosion
@
text
@d180 2
d529 2
a530 2
      // If focused shortage volumes have not been computed, then compute.
      //
@


1.152
log
@Stochastic Implosion
@
text
@d1009 1
a1009 1
void WitRun::witGetPartStageNo (
d1011 1
a1011 1
      int *        stageNo)
d1017 1
a1017 1
         "stageNo",
d1021 3
a1023 3
      stageNo,
      "stageNo",
      myStochImpMgr ()->stageNo (theCall.myPart ()));
d1516 1
a1516 1
void WitRun::witSetPartStageNo (
d1518 1
a1518 1
      int          stageNo)
d1522 1
a1522 1
   theCall.setStageNo (stageNo);
@


1.151
log
@Stochastic Implosion
@
text
@d1522 1
a1522 20
   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "stageNo",
         myMsgFac ().myFrag ("partFrag"));

   if (myStochImpMgr ()->stochSolnMode ())
      myMsgFac () ("setObjStochSolnSmsg",
         "stageNo",
         myMsgFac ().myFrag ("partFrag"));

   theCall.prepRangedInt (
                       "stageNo", 
      myStochImpMgr ()->stageNo (theCall.myPart ()),
                        stageNo,
                        0,
                        1);

   if (theCall.argsOK ())
      myStochImpMgr ()->
         setStageNo (theCall.myPart (), stageNo);
@


1.150
log
@Stochastic Implosion
@
text
@a369 2
   theCall.prepGetStochSolnAttr ("consVol");

a485 2
   theCall.prepGetStochSolnAttr ("excessVol");

a797 2
      theCall.prepGetStochSolnAttr ("prodVol");

a845 2
   theCall.prepGetStochSolnAttr ("residualVol");

a970 2
   theCall.prepGetStochSolnAttr ("scrapVol");

a1117 2
   theCall.prepGetStochSolnAttr ("stockVol");

@


1.149
log
@Stochastic Implosion
@
text
@d370 2
d488 2
d802 2
d852 2
@


1.148
log
@Stochastic Implosion
@
text
@d1599 1
a1599 1
   theCall.prepNonNegDblVec ("supplyVol", supplyVol);
@


1.147
log
@Stochastic Implosion
@
text
@a1016 3
   if (not myStochImpMgr ()->stochImpAllowed ())
      myMsgFac () ("attNYASmsg", "stageNo");

a1525 3
   if (not myStochImpMgr ()->stochImpAllowed ())
      myMsgFac () ("attNYASmsg", "stageNo");

@


1.146
log
@Stochastic Implosion
@
text
@a918 22
void WitRun::witGetPartRecourseStage (
      const char * partName,
      WitBoolean * recourseStage)
   {
   WitPartApiCall theCall (this, partName);

   if (not myStochImpMgr ()->stochImpAllowed ())
      myMsgFac () ("attNYASmsg", "recourseStage");

   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "recourseStage",
         myMsgFac ().myFrag ("partFrag"));

   apiGet (
      recourseStage,
      "recourseStage",
      myStochImpMgr ()->recourseStage (theCall.myPart ()));
   }

//------------------------------------------------------------------------------

d1011 22
a1452 31
void WitRun::witSetPartRecourseStage (
      const char * partName,
      WitBoolean   recourseStage)
   {
   WitPartApiCall theCall (this, partName);

   if (not myStochImpMgr ()->stochImpAllowed ())
      myMsgFac () ("attNYASmsg", "recourseStage");

   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "recourseStage",
         myMsgFac ().myFrag ("partFrag"));

   if (myStochImpMgr ()->stochSolnMode ())
      myMsgFac () ("setObjStochSolnSmsg",
         "recourseStage",
         myMsgFac ().myFrag ("partFrag"));

   theCall.prepBool (    
                       "recourseStage", 
      myStochImpMgr ()->recourseStage (theCall.myPart ()),
                        recourseStage);

   if (theCall.argsOK ())
      myStochImpMgr ()->
         setRecourseStage (theCall.myPart (), asaBool (recourseStage));
   }

//------------------------------------------------------------------------------

d1523 33
@


1.145
log
@ASAP Pegging Order.
@
text
@d26 1
a26 1
#include <OptImp.h>
d863 1
a863 1
      myOptImploder ()->
d882 1
a882 1
      myOptImploder ()->
d1072 1
a1072 1
      myOptImploder ()->
d1091 1
a1091 1
      myOptImploder ()->
d1110 1
a1110 1
      myOptImploder ()->
@


1.144
log
@ASAP Pegging Order
@
text
@a1186 3
   if (not myGlobalComp ()->allowAsapPip ())
      myMsgFac () ("attNYASmsg", "asapPipOrder");

@


1.143
log
@ASAP Pegging Order
@
text
@d237 1
a237 1
void WitRun::witGetPartAsapPip (
d239 1
a239 1
      WitBoolean * asapPip)
d241 1
a241 1
   WitMaterialApiCall theCall (this, partName, "asapPip");
d243 4
a246 1
   apiGet (asapPip, "asapPip", theCall.myMaterial ()->asapPip ());
d1176 1
a1176 1
void WitRun::witSetPartAsapPip (
d1178 1
a1178 1
      WitBoolean   asapPip)
d1180 1
a1180 1
   WitMaterialApiCall theCall (this, partName, "asapPip");
d1183 3
a1185 3
                            "asapPip", 
      theCall.myMaterial ()->asapPip (), 
                             asapPip);
d1188 1
a1188 1
      myMsgFac () ("attNYASmsg", "asapPip");
d1191 1
a1191 1
      theCall.myMaterial ()->setAsapPip (asaBool (asapPip));
@


1.142
log
@Stochastic Implosion
@
text
@d237 11
d1173 20
@


1.141
log
@Stochastic Implosion
@
text
@a1440 2
   theCall.prepStochSolnModeAttr ();

@


1.140
log
@Stochastic Implosion
@
text
@d911 1
a911 1
   if (not myProblem ()->myStochImpMgr ()->stochImpAllowed ())
d914 1
a914 1
   if (not myProblem ()->myStochImpMgr ()->stochMode ())
d922 1
a922 1
      myProblem ()->myStochImpMgr ()->recourseStage (theCall.myPart ()));
d1428 1
a1428 1
   if (not myProblem ()->myStochImpMgr ()->stochImpAllowed ())
d1431 1
a1431 1
   if (not myProblem ()->myStochImpMgr ()->stochMode ())
d1436 5
d1444 3
a1446 3
                                     "recourseStage", 
      myProblem ()->myStochImpMgr ()->recourseStage (theCall.myPart ()),
                                      recourseStage);
d1449 2
a1450 5
      myProblem ()->
         myStochImpMgr ()->
            setRecourseStage (
               theCall.myPart (),
               asaBool (recourseStage));
@


1.139
log
@Stochastic Implosion
@
text
@a1121 2
   theCall.prepGetStochAttr ();

@


1.138
log
@Stochastic Implosion
@
text
@a1573 2
   theCall.prepStochModeAttr ();

@


1.137
log
@Stochastic Implosion
@
text
@d1122 2
d1574 2
@


1.136
log
@Stochastic Implosion
@
text
@d914 1
a914 1
   if (not myProblem ()->myStochImpMgr ()->stochDataMode ())
d1431 1
a1431 1
   if (not myProblem ()->myStochImpMgr ()->stochDataMode ())
@


1.135
log
@Stochastic Implosion
@
text
@a918 2
   theCall.prepGetStochAttr ();

@


1.134
log
@Stochastic Implosion.
@
text
@d28 1
d905 24
d1424 31
@


1.133
log
@Stochastic Implosion
@
text
@d956 2
a958 2

   theCall.issueScenMsg ();
d1086 2
a1088 2

   theCall.issueScenMsg ();
@


1.132
log
@Stochastic Implosion
@
text
@d957 2
d1087 2
@


1.131
log
@Stochastic Implosion.
@
text
@d486 1
a486 1
      WitBoolean * exist)
d490 1
a490 1
   if (myCompMgr ()->findPart (partNameParm) == NULL)
d492 1
a492 1
      myMsgFac () ("partDoesNotExist", partNameParm);
d494 1
a494 1
      * exist = false;
d498 1
a498 1
      myMsgFac () ("partDoesExist", partNameParm);
d500 1
a500 1
      * exist = true;
@


1.130
log
@Stochastic implosion.
@
text
@d1602 2
@


1.129
log
@Stochastic implosion.
@
text
@a1601 2
   forbidAddStochAct ("partFrag");

@


1.128
log
@[disallowed scrap]
@
text
@d1602 2
@


1.127
log
@[disallowing scrap]
@
text
@a1399 3
   if (not myGlobalComp ()->allowSA ())
      myMsgFac () ("attNYASmsg", "scrapAllowed");

@


1.126
log
@witCopy<Object>Data
@
text
@d925 11
d1395 19
@


1.125
log
@witCopy<Object>Data
@
text
@d129 1
a129 1
   myMsgFac () ("dupObjectMsg",  myMsgFac ().myFrag ("partFrag"));
@


1.124
log
@witCopy<Object>Data
@
text
@d140 1
a140 1
    dupPart = dupCall.myPart ();
d147 3
a149 4
      dupPart->
         thisMat ()->
            copyAttrsFrom (origPart->thisMat ());

d151 3
a153 4
      dupPart->
         thisCap ()->
            copyAttrsFrom (origPart->thisCap ());

@


1.123
log
@witCopy<Object>Data
@
text
@d123 3
a125 3
      const char * dstPartName,
      WitRun *     srcWitRun,
      const char * srcPartName)
d127 1
a127 1
   startCopyObjData (srcWitRun);
d129 1
a129 1
   myMsgFac () ("dstObjectMsg", myMsgFac ().myFrag ("partFrag"));
d131 1
a131 1
   WitPartApiCall dstCall (this,      dstPartName);
d133 1
a133 1
   myMsgFac () ("srcObjectMsg", myMsgFac ().myFrag ("partFrag"));
d135 1
a135 1
   WitPartApiCall srcCall (srcWitRun, srcPartName);
d137 2
a138 2
   WitPart * dstPart;
   WitPart * srcPart;
d140 2
a141 2
   dstPart = dstCall.myPart ();
   srcPart = srcCall.myPart ();
d143 1
a143 1
   if (dstPart == srcPart)
d146 2
a147 2
   if      ((dstPart->thisMat () != NULL) and (srcPart->thisMat () != NULL))
      dstPart->
d149 1
a149 1
            copyAttrsFrom (srcPart->thisMat ());
d151 2
a152 2
   else if ((dstPart->thisCap () != NULL) and (srcPart->thisCap () != NULL))
      dstPart->
d154 1
a154 1
            copyAttrsFrom (srcPart->thisCap ());
d158 4
a161 4
         dstPart->partName     (),
         srcPart->partName     (),
         dstPart->categoryFrag (),
         srcPart->categoryFrag ());
@


1.122
log
@witCopy<Object>Data.
@
text
@d129 2
d132 3
d136 3
a138 2
   WitPart *      dstPart;
   WitPart *      srcPart;
@


1.121
log
@witCopy<Object>Data
@
text
@d138 1
a138 1
      myMsgFac () ("copyObjectToSelfSmsg");
@


1.120
log
@witCopy<Object>Data
@
text
@d127 1
a127 3
   myApiMgr_->allowPreInit      ();
   myApiMgr_->allowExtOptActive ();
   myApiMgr_->startInnerFunc    ();
d129 4
a132 2
   if (not mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg",   "witCopyPartData", "dstWitRun");
d134 2
a135 2
   if (myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", "witCopyPartData", "dstWitRun");
d137 2
a138 1
   forbidNullArg (srcWitRun, "srcWitRun");
d140 4
a143 1
   myApiMgr_->start2WitRunFunc (srcWitRun->myApiMgr_);
d145 4
a148 2
   if (not srcWitRun->mySession_->active ())
      myMsgFac () ("uninitWitRun2Smsg",   "witCopyPartData", "srcWitRun");
d150 6
a155 4
   if (srcWitRun->myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptActiveWR2Smsg", "witCopyPartData", "srcWitRun");

   copyPartData (dstPartName, srcWitRun, srcPartName);
a1592 40

//------------------------------------------------------------------------------

void WitRun::copyPartData (
      const char * dstPartName,
      WitRun *     srcWitRun,
      const char * srcPartName)
   {
   WitPartApiCall dstCall (this,      dstPartName);
   WitPartApiCall srcCall (srcWitRun, srcPartName);
   WitPart *      dstPart;
   WitPart *      srcPart;

   dstPart = dstCall.myPart ();
   srcPart = srcCall.myPart ();

   if (not myGlobalComp ()->allowCopyObjData ())
      myMsgFac () ("funcNYASmsg", "witCopyPartData");

   if (dstPart == srcPart)
      myMsgFac () ("copyObjectToSelfSmsg");

   if      ((dstPart->thisMat () != NULL) and (srcPart->thisMat () != NULL))
      dstPart->
         thisMat ()->
            copyAttrsFrom (srcPart->thisMat ());

   else if ((dstPart->thisCap () != NULL) and (srcPart->thisCap () != NULL))
      dstPart->
         thisCap ()->
            copyAttrsFrom (srcPart->thisCap ());

   else
      myMsgFac () ("copyPartCatMismatchSmsg",
         dstPart->partName     (),
         srcPart->partName     (),
         dstPart->categoryFrag (),
         srcPart->categoryFrag ());
   }

@


1.119
log
@witCopy<Object>Data
@
text
@d141 2
a142 10
   try
      {
      if (not srcWitRun->mySession_->active ())
         myMsgFac () ("uninitWitRun2Smsg",   "witCopyPartData", "srcWitRun");

      if (srcWitRun->myOptImploder ()->extOptActive ())
         myMsgFac () ("extOptActiveWR2Smsg", "witCopyPartData", "srcWitRun");

      copyPartData (dstPartName, srcWitRun, srcPartName);
      }
d144 2
a145 8
   catch (...)
      {
      srcWitRun->myApiMgr_->setPrevApiAbort ();

      myApiMgr_->finish2WitRunFunc (srcWitRun->myApiMgr_);

      throw;
      }
d147 1
a147 1
   myApiMgr_->finish2WitRunFunc (srcWitRun->myApiMgr_);
@


1.118
log
@witCopy<Object>Data
@
text
@d127 18
a144 4
   WitPartApiCall dstCall (this,      dstPartName);
   WitPartApiCall srcCall (srcWitRun, srcPartName);
   WitPart *      dstPart;
   WitPart *      srcPart;
d146 2
a147 2
   dstPart = dstCall.myPart ();
   srcPart = srcCall.myPart ();
d149 2
a150 2
   if (not myGlobalComp ()->allowCopyObjData ())
      myMsgFac () ("funcNYASmsg", "witCopyPartData");
d152 3
a154 2
   if (dstPart == srcPart)
      myMsgFac () ("copyObjectToSelfSmsg");
d156 1
a156 4
   if      ((dstPart->thisMat () != NULL) and (srcPart->thisMat () != NULL))
      dstPart->
         thisMat ()->
            copyAttrsFrom (srcPart->thisMat ());
d158 2
a159 4
   else if ((dstPart->thisCap () != NULL) and (srcPart->thisCap () != NULL))
      dstPart->
         thisCap ()->
            copyAttrsFrom (srcPart->thisCap ());
d161 1
a161 6
   else
      myMsgFac () ("copyPartCatMismatchSmsg",
         dstPart->partName     (),
         srcPart->partName     (),
         dstPart->categoryFrag (),
         srcPart->categoryFrag ());
d1599 40
@


1.117
log
@witCopy<Object>Data
@
text
@d142 4
a145 2
      {
      }
d147 4
a150 2
      {
      }
@


1.116
log
@witCopy<Object>Data
@
text
@d129 5
d138 1
a138 1
   if (dstCall.myPart () == srcCall.myPart ())
d140 13
d619 1
a619 1
            myMsgFac ().myFrag (partP->categoryFragID ()));
@


1.115
log
@External opt implosion.
@
text
@d122 17
@


1.114
log
@External opt implosion.
@
text
@d27 1
a27 1
#include <ExtOptHand.h>
d807 1
a807 1
         myExtOptHandler ()->
d826 1
a826 1
         myExtOptHandler ()->
d981 1
a981 1
         myExtOptHandler ()->
d1000 1
a1000 1
         myExtOptHandler ()->
d1019 1
a1019 1
         myExtOptHandler ()->
@


1.113
log
@External opt implosion.
@
text
@d968 38
@


1.112
log
@External opt implosion.
@
text
@d73 10
a82 1
   myInputID ()->setMyAttr (theAttr);
d84 4
a87 1
   return requiredMaterial (setGetPartInit (partName));
a1516 14

//------------------------------------------------------------------------------

WitMaterial * WitRun::requiredMaterial (WitPart * thePart) const
   {
   WitMaterial * theMat;

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      myMsgFac () ("materialReqdSmsg");

   return theMat;
   }
@


1.111
log
@External opt implosion.
@
text
@d785 1
a785 1
      int *        rowIndex)
d792 2
a793 2
       rowIndex,
      "rowIndex",
d804 1
a804 1
      int *        colIndex)
d811 2
a812 2
       colIndex,
      "colIndex",
d959 1
a959 1
      int *        colIndex)
d966 2
a967 2
       colIndex,
      "colIndex",
@


1.110
log
@External opt implosion.
@
text
@d789 1
a789 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d808 1
a808 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d963 1
a963 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
@


1.109
log
@External opt implosion.
@
text
@d805 23
d964 23
@


1.108
log
@External opt implosion.
@
text
@d84 2
d99 2
d119 2
d158 5
a162 1
   thePart = curItrDelCompForGet (WitAT_PART, "partFrag")->thisPart ();
d241 2
d338 2
a341 2
   WitSubEntry *  theSub;

d364 2
a388 2
   WitPartApiCall theCall (this, partName);

d392 2
d413 2
a415 1
   WitPeriod      thePer;
d434 2
d473 2
d486 2
d510 2
a512 1
   WitPeriod      thePer;
d531 2
d559 2
d647 2
d666 2
d685 2
d700 2
d717 2
d741 2
a744 2
   WitBopEntry *  theBopEnt;

d789 6
d842 2
d978 2
d1035 2
d1094 2
d1114 2
d1127 2
d1140 2
d1153 2
d1172 2
d1193 2
d1210 2
d1225 2
d1262 2
a1264 1
   WitPeriod      thePer;
d1390 2
@


1.107
log
@App controlled opt implosion.
@
text
@d26 2
d746 17
@


1.106
log
@NSTN residualVol.
@
text
@d25 1
d196 1
a196 1
   myProblem ()->preprocess ();
@


1.105
log
@NSTN residualVols
@
text
@d498 1
a498 1
               }
@


1.104
log
@App controlled opt implosion.
@
text
@d33 1
d405 3
a407 3
         min (
            theCall.myPart ()->residualVol ()[thePer],
            theCall.myPart ()->supplyVol   ()[thePer]);
@


1.103
log
@App controlled opt implosion.
@
text
@a79 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a92 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a106 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a145 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a160 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a171 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a183 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a211 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a224 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a249 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a260 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a271 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a282 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a295 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a321 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a347 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a370 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a394 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a414 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a434 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a451 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a462 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a473 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a484 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a504 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a515 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a528 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a574 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a588 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a602 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a616 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a633 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a650 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a663 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a678 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a700 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a723 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a734 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a745 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a764 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a775 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a794 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a808 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a819 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a830 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a841 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a854 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a865 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a879 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a890 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a901 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a912 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a923 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a934 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a951 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a965 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a988 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1006 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1024 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1042 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1053 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1064 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1075 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1092 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1111 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1126 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1137 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1160 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1174 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1200 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1210 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1229 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1244 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1270 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1284 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1301 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

@


1.102
log
@Updated the copyright date on all source files.
@
text
@d80 4
d97 4
d115 4
d158 4
d177 4
d192 4
d208 4
d240 4
d257 4
d286 4
d301 4
d316 4
d331 4
d348 4
d378 4
d408 4
d435 4
d463 4
d487 4
d511 4
d532 4
d547 4
d562 4
d577 4
d601 4
d616 4
d633 4
d683 4
d701 4
d719 4
d737 4
d758 4
d779 4
d796 4
d815 4
d841 4
d868 4
d883 4
d898 4
d921 4
d936 4
d959 4
d977 4
d992 4
d1007 4
d1022 4
d1039 4
d1054 4
d1072 4
d1087 4
d1102 4
d1117 4
d1132 4
d1147 4
d1168 4
d1186 4
d1213 4
d1235 4
d1257 4
d1279 4
d1294 4
d1309 4
d1324 4
d1345 4
d1368 4
d1387 4
d1402 4
d1429 4
d1447 4
d1477 4
d1491 4
d1514 4
d1533 4
d1563 4
d1581 4
d1602 4
@


1.101
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.100
log
@[shared-resource pegging]
@
text
@a33 1
#include <Dense.h>
@


1.99
log
@[multi-thread]
@
text
@d190 4
a193 4
   int &      lenListRef      = * lenList;
   char * * & partNameListRef = * partNameList;
   WitPart *  thePart;
   int        i;
d197 1
a197 4
   const WitDenseList <WitPart> & belowListRef = 
      theCall.myPart ()->belowList ();

   lenListRef = belowListRef.nElements ();
d201 1
a201 1
   i = 0;
d203 2
a204 2
   forEachElDense (thePart, belowListRef)
      partNameListRef[i++] = thePart->partName ().apiDupCstring ();
@


1.98
log
@[multi-thread]
@
text
@d456 1
a456 1
   prepGet34Attr ("Part", WitNincLotSize, "Operation", WitNincLotSize);
d467 1
a467 1
   prepGet34Attr ("Part", WitNminLotSize, "Operation", WitNminLotSize);
d1047 1
a1047 1
   prepSet34Attr ("Part", WitNincLotSize, "Operation", WitNincLotSize);
d1058 1
a1058 1
   prepSet34Attr ("Part", WitNminLotSize, "Operation", WitNminLotSize);
@


1.97
log
@Removed code supporting the variable-argument-list API functions.
@
text
@a38 1
#include <ctype.h>
@


1.96
log
@[multi-thread]
@
text
@a91 83
void WitRun::witAddPartVa (
      const char * partName,
      WitAttr      partCategory,
      va_list      argp)
   {
   WitPart * thePart;
   WitAttr   theAttr;
   float *   hardlbP;
   float *   softlbP;
   float *   hardubP;

   witAddPart (partName, partCategory);

   if (argp == NULL)
      return;

   thePart = myCompMgr ()->findPart (partName);

   //--------------------------------------------------
   // Loop once for each attribute in calling sequence.
   //--------------------------------------------------

   for (theAttr  = va_arg (argp, WitAttr);
        theAttr != NULL;
        theAttr  = va_arg (argp, WitAttr))
      {
      if (theAttr == WitNsupplyVol)
         witSetPartSupplyVol (partName, va_arg (argp, float *));

      else if (theAttr == WitNobj1StockCost)
         {
         requiredMaterial (thePart);

         witSetPartObj1StockCost (partName, va_arg (argp, float *));
         }

      else if (theAttr == WitNstockBounds)
         {
         hardlbP = va_arg (argp, float *);
         softlbP = va_arg (argp, float *);
         hardubP = va_arg (argp, float *);

         requiredMaterial (thePart);

         witSetPartStockBounds (partName, hardlbP, softlbP, hardubP);
         }

      else if (theAttr == WitNunitCost)
         witSetPartUnitCost (partName, va_arg (argp, double));

      else if (theAttr == WitNcycleTime)
         witSetPartCycleTime (partName, va_arg (argp, float *));

      else if (theAttr == WitNyield)
         witSetPartYield (partName, va_arg (argp, int *));

      else if (theAttr == WitNincLotSize)
         witSetPartIncLotSize (partName, va_arg (argp, float *));

      else if (theAttr == WitNminLotSize)
         witSetPartMinLotSize (partName,  va_arg (argp, float *));

      else if (theAttr == WitNobj1ProdCost)
         witSetPartObj1ProdCost (partName, va_arg (argp, float *));

      else if (theAttr == WitNprodBounds)
         {
         hardlbP = va_arg (argp, float *);
         softlbP = va_arg (argp, float *);
         hardubP = va_arg (argp, float *);

         witSetPartProdBounds (partName, hardlbP, softlbP, hardubP);
         }
       else if (theAttr == WitNobj1ScrapCost)
         witSetPartObj1ScrapCost (partName, va_arg (argp, float *));

      else
         myMsgFac () ("undefinedAttrErrorMsg");
      }
   }

//------------------------------------------------------------------------------

@


1.95
log
@[multi-thread]
@
text
@a39 1
#include <stdarg.h>
@


1.94
log
@[multi-thread]
@
text
@d80 2
a81 2
      const char * partNameParm,
      WitAttr      partCategoryParm)
d83 1
a83 1
   forbidNullArg (partNameParm, "partName");
d86 1
a86 1
      addPart34     (partNameParm, partCategoryParm);
d88 1
a88 1
      addPartPost34 (partNameParm, partCategoryParm);
d94 2
a95 2
      const char * partNameParm,
      WitAttr      partCategoryParm,
d99 1
a99 1
   WitAttr   attr;
d104 1
a104 1
   witAddPart (partNameParm, partCategoryParm);
d106 2
a107 1
   thePart = myCompMgr ()->findPart (partNameParm);
d109 1
a109 3
   witAssert (thePart != NULL);

   myInputID ()->setMyPart (thePart);
d115 8
a122 4
   if (argp != NULL)
      for (attr  = va_arg (argp, WitAttr);
           attr != NULL;
           attr  = va_arg (argp, WitAttr))
d124 1
a124 77
         if (attr == WitNsupplyVol)
            witSetPartSupplyVol (
               thePart->partName ().myCstring (), 
               va_arg (argp, float *));

         else if (attr == WitNobj1StockCost)
            {
            requiredMaterial (thePart);

            witSetPartObj1StockCost (
               thePart->partName ().myCstring (),
               va_arg (argp, float *));
            }

         else if (attr == WitNstockBounds)
            {
            hardlbP = va_arg (argp, float *);
            softlbP = va_arg (argp, float *);
            hardubP = va_arg (argp, float *);

            requiredMaterial (thePart);

            witSetPartStockBounds (
               thePart->partName ().myCstring (),
               hardlbP,
               softlbP,
               hardubP);
            }


         else if (attr == WitNunitCost)
            witSetPartUnitCost (
               thePart->partName ().myCstring (), 
               va_arg (argp, double));

         else if (attr == WitNcycleTime)
            witSetPartCycleTime (
               thePart->partName ().myCstring (), 
               va_arg (argp, float *));

         else if (attr == WitNyield)
            witSetPartYield (
               thePart->partName ().myCstring (), 
               va_arg (argp, int *));

         else if (attr == WitNincLotSize)
            witSetPartIncLotSize (
               thePart->partName ().myCstring (), 
               va_arg (argp, float *));

         else if (attr == WitNminLotSize)
            witSetPartMinLotSize (
               thePart->partName ().myCstring (), 
               va_arg (argp, float *));

         else if (attr == WitNobj1ProdCost)
            witSetPartObj1ProdCost (
               thePart->partName ().myCstring (),
               va_arg (argp, float *));

         else if (attr == WitNprodBounds)
            {
            hardlbP = va_arg (argp, float *);
            softlbP = va_arg (argp, float *);
            hardubP = va_arg (argp, float *);

            witSetPartProdBounds (
               thePart->partName ().myCstring (),
               hardlbP,
               softlbP,
               hardubP);
            }

         else if (attr == WitNobj1ScrapCost)
            witSetPartObj1ScrapCost (
               thePart->partName ().myCstring (),
               va_arg (argp, float *));
d126 37
a162 3
         else
            myMsgFac () ("undefinedAttrErrorMsg");
      }
d164 4
a167 3
   //------------
   // End of Loop
   //------------
d169 3
a171 1
   myInputID ()->setMyPart (NULL);
@


1.93
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d40 1
@


1.92
log
@[multi-thread]
@
text
@a16 1
#include <ProEpilog.h>
d78 1
a78 1
WitReturnCode WitRun::witAddPart (
a81 2
   PROLOG ("witAddPart");

a87 2

   EPILOG;
d92 1
a92 1
WitReturnCode WitRun::witAddPartVa (
a102 2
   PROLOG ("witAddPartVa");

a206 2

   EPILOG;
d211 1
a211 1
WitReturnCode WitRun::witAddPartWithOperation (
a213 2
   PROLOG ("witAddPartWithOperation");

a218 2

   EPILOG;
d223 1
a223 1
WitReturnCode WitRun::witGetFocusShortageVol (
a231 2
   PROLOG ("witGetFocusShortageVol");

a260 2

   EPILOG;
d265 1
a265 1
WitReturnCode WitRun::witGetObjItrPart (char * * partName)
a268 2
   PROLOG ("witGetObjItrPart");

a273 2

   EPILOG;
d278 1
a278 1
WitReturnCode WitRun::witGetPartAppData (
a281 2
   PROLOG ("witGetPartAppData");

a284 2

   EPILOG;
d289 1
a289 1
WitReturnCode WitRun::witGetPartBaSelSplit (
a292 2
   PROLOG ("witGetPartBaSelSplit");

a295 2

   EPILOG;
d300 1
a300 1
WitReturnCode WitRun::witGetPartBelowList (
a304 2
   PROLOG ("witGetPartBelowList");

a327 2

   EPILOG;
d332 1
a332 1
WitReturnCode WitRun::witGetPartBuildAheadUB (
a335 2
   PROLOG ("witGetPartBuildAheadUB");

a340 2

   EPILOG;
d345 1
a345 1
WitReturnCode WitRun::witGetPartBuildAheadLimit (
a348 2
   PROLOG ("witGetPartBuildAheadLimit");

a365 2

   EPILOG;
d370 1
a370 1
WitReturnCode WitRun::witGetPartBuildAsap (
a373 2
   PROLOG ("witGetPartBuildAsap");

a376 2

   EPILOG;
d381 1
a381 1
WitReturnCode WitRun::witGetPartBuildNstn (
a384 2
   PROLOG ("witGetPartBuildNstn");

a387 2

   EPILOG;
d392 1
a392 1
WitReturnCode WitRun::witGetPartCategory (
a395 2
   PROLOG ("witGetPartCategory");

a398 2

   EPILOG;
d403 1
a403 1
WitReturnCode WitRun::witGetPartConsVol (
a406 2
   PROLOG ("witGetPartConsVol");

a409 2

   EPILOG;
d414 1
a414 1
WitReturnCode WitRun::witGetPartConsumingBomEntry (
a419 2
   PROLOG ("witGetPartConsumingBomEntry");

a434 2

   EPILOG;
d439 1
a439 1
WitReturnCode WitRun::witGetPartConsumingSubsBomEntry (
a445 2
   PROLOG ("witGetPartConsumingSubsBomEntry");

a463 2

   EPILOG;
d468 1
a468 1
WitReturnCode WitRun::witGetPartCycleTime (
a471 2
   PROLOG ("witGetPartCycleTime");

a481 2

   EPILOG;
d490 1
a490 1
WitReturnCode WitRun::witGetPartDemands (
a494 2
   PROLOG ("witGetPartDemands");

d511 1
a511 3

  EPILOG;
  }
d515 1
a515 1
WitReturnCode WitRun::witGetPartExcessVol (
a518 2
   PROLOG ("witGetPartExcessVol");

a530 2

   EPILOG;
d535 1
a535 1
WitReturnCode WitRun::witGetPartExists (
a538 2
   PROLOG ("witGetPartExists");

a550 2

   EPILOG;
d555 1
a555 1
WitReturnCode WitRun::witGetPartFocusShortageVol (
a558 2
   PROLOG ("witGetPartFocusShortageVol");

a567 2

   EPILOG;
d572 1
a572 1
WitReturnCode WitRun::witGetPartIncLotSize (
a575 2
   PROLOG ("witGetPartIncLotSize");

a578 2

   EPILOG;
d583 1
a583 1
WitReturnCode WitRun::witGetPartMinLotSize (
a586 2
   PROLOG ("witGetPartMinLotSize");

a589 2

   EPILOG;
d594 1
a594 1
WitReturnCode WitRun::witGetPartMrpConsVol (
a597 2
   PROLOG ("witGetPartMrpConsVol");

a600 2

   EPILOG;
d605 1
a605 1
WitReturnCode WitRun::witGetPartMrpExcessVol (
a608 2
   PROLOG ("witGetPartMrpExcessVol");

d621 1
a621 3
            
   EPILOG;
   }
d625 1
a625 1
WitReturnCode WitRun::witGetPartMrpProdVol (
a628 2
   PROLOG ("witGetPartMrpProdVol");

a631 2

   EPILOG;
d636 1
a636 1
WitReturnCode WitRun::witGetPartMrpResidualVol (
a639 2
   PROLOG ("witGetPartMrpResidualVol");

a644 2

   EPILOG;
d649 1
a649 1
WitReturnCode WitRun::witGetPartNBomEntries (
a654 3
   PROLOG ("witGetPartNBomEntries");


a690 2

   EPILOG;
d695 1
a695 1
WitReturnCode WitRun::witGetPartNConsumingBomEntries (
a698 2
   PROLOG ("witGetPartNConsumingBomEntries");

a704 2

   EPILOG;
d709 1
a709 1
WitReturnCode WitRun::witGetPartNConsumingSubsBomEntries (
a712 2
   PROLOG ("witGetPartNConsumingSubsBomEntries");

a718 2

   EPILOG;
d723 1
a723 1
WitReturnCode WitRun::witGetPartNProducingBopEntries (
a726 2
   PROLOG ("witGetPartNProducingBopEntries");

a732 2

   EPILOG;
d737 1
a737 1
WitReturnCode WitRun::witGetPartObj1ScrapCost (
a740 2
   PROLOG ("witGetPartObj1ScrapCost");

a749 2

   EPILOG;
d754 1
a754 1
WitReturnCode WitRun::witGetPartObj1StockCost (
a757 2
   PROLOG ("witGetPartObj1StockCost");

a766 2

   EPILOG;
d771 1
a771 1
WitReturnCode WitRun::witGetPartObj1ProdCost (
a774 2
   PROLOG ("witGetPartObj1ProdCost");

a777 2

   EPILOG;
d782 1
a782 1
WitReturnCode WitRun::witGetPartProdBounds (
a787 2
   PROLOG ("witGetPartProdBounds");

a790 2

   EPILOG;
d799 1
a799 1
WitReturnCode WitRun::witGetPartProdVol (
a802 2
   PROLOG ("witGetPartProdVol");

a814 2

   EPILOG;
d819 1
a819 1
WitReturnCode WitRun::witGetPartProducingBopEntry (
a824 2
   PROLOG ("witGetPartProducingBopEntry");

a839 2

   EPILOG;
d844 1
a844 1
WitReturnCode WitRun::witGetPartReqVol (
a847 2
   PROLOG ("witGetPartReqVol");

a850 2

   EPILOG;
d855 1
a855 1
WitReturnCode WitRun::witGetPartResidualVol (
a858 2
   PROLOG ("witGetPartResidualVol");

a861 2

   EPILOG;
d866 1
a866 1
WitReturnCode WitRun::witGetPartPropRouting (
a869 2
   PROLOG ("witGetPartPropRouting");

a880 2

   EPILOG;
d885 1
a885 1
WitReturnCode WitRun::witGetPartPropRtg (
a888 2
   PROLOG ("witGetPartPropRtg");

a891 2

   EPILOG;
d896 1
a896 1
WitReturnCode WitRun::witGetParts (
a899 2
   PROLOG ("witGetParts");

a910 2

   EPILOG;
d915 1
a915 1
WitReturnCode WitRun::witGetPartScrapCost (
a918 2
   PROLOG ("witGetPartScrapCost");

a924 2

   EPILOG;
d929 1
a929 1
WitReturnCode WitRun::witGetPartScrapVol (
a932 2
   PROLOG ("witGetPartScrapVol");

a935 2

   EPILOG;
d940 1
a940 1
WitReturnCode WitRun::witGetPartSelForDel (
a943 2
   PROLOG ("witGetPartSelForDel");

a946 2

   EPILOG;
d951 1
a951 1
WitReturnCode WitRun::witGetPartShadowPrice (
a954 2
   PROLOG ("witGetPartShadowPrice");

a957 2

   EPILOG;
d962 1
a962 1
WitReturnCode WitRun::witGetPartSingleSource (
a965 2
   PROLOG ("witGetPartSingleSource");

a968 2

   EPILOG;
d973 1
a973 1
WitReturnCode WitRun::witGetPartStockBounds (
a978 2
   PROLOG ("witGetPartStockBounds");

a981 2

   EPILOG;
d986 1
a986 1
WitReturnCode WitRun::witGetPartStockCost (
a989 2
   PROLOG ("witGetPartStockCost");

a995 2

   EPILOG;
d1000 1
a1000 1
WitReturnCode WitRun::witGetPartStockVol (
a1003 2
   PROLOG ("witGetPartStockVol");

a1006 2

   EPILOG;
d1011 1
a1011 1
WitReturnCode WitRun::witGetPartSupplyVol (
a1014 2
   PROLOG ("witGetPartSupplyVol");

a1017 2

   EPILOG;
d1022 1
a1022 1
WitReturnCode WitRun::witGetPartUnitCost (
a1025 2
   PROLOG ("witGetPartUnitCost");

a1028 2

   EPILOG;
d1033 1
a1033 1
WitReturnCode WitRun::witGetPartYield (
a1036 2
   PROLOG ("witGetPartYield");

a1039 2

   EPILOG;
d1044 1
a1044 1
WitReturnCode WitRun::witSetPartAppData (
a1047 2
   PROLOG ("witSetPartAppData");

a1050 2

   EPILOG;
d1055 1
a1055 1
WitReturnCode WitRun::witSetPartBaSelSplit (
a1058 2
   PROLOG ("witSetPartBaSelSplit");

a1067 2

   EPILOG;
d1072 1
a1072 1
WitReturnCode WitRun::witSetPartBuildAheadUB (
a1075 2
   PROLOG ("witSetPartBuildAheadUB");

a1081 2

   EPILOG;
d1086 1
a1086 1
WitReturnCode WitRun::witSetPartBuildAheadLimit (
a1089 2
   PROLOG ("witSetPartBuildAheadLimit");

a1104 2

   EPILOG;
d1109 1
a1109 1
WitReturnCode WitRun::witSetPartBuildAsap (
a1112 2
   PROLOG ("witSetPartBuildAsap");

a1122 2

   EPILOG;
d1127 1
a1127 1
WitReturnCode WitRun::witSetPartBuildNstn (
a1130 2
   PROLOG ("witSetPartBuildNstn");

a1140 2

   EPILOG;
d1145 1
a1145 1
WitReturnCode WitRun::witSetPartCycleTime (
a1148 2
   PROLOG ("witSetPartCycleTime");

a1158 2

   EPILOG;
d1163 1
a1163 1
WitReturnCode WitRun::witSetPartIncLotSize (
a1166 2
   PROLOG ("witSetPartIncLotSize");

a1169 2

   EPILOG;
d1174 1
a1174 1
WitReturnCode WitRun::witSetPartMinLotSize (
a1177 2
   PROLOG ("witSetPartMinLotSize");

a1180 2

   EPILOG;
d1185 1
a1185 1
WitReturnCode WitRun::witSetPartObj1ProdCost (
a1188 2
   PROLOG ("witSetPartObj1ProdCost");

a1191 2

   EPILOG;
d1196 1
a1196 1
WitReturnCode WitRun::witSetPartObj1ScrapCost (
a1199 2
   PROLOG ("witSetPartObj1ScrapCost");

a1208 2

   EPILOG;
d1213 1
a1213 1
WitReturnCode WitRun::witSetPartObj1StockCost (
a1216 2
   PROLOG ("witSetPartObj1StockCost");

a1225 2

   EPILOG;
d1230 1
a1230 1
WitReturnCode WitRun::witSetPartProdBounds (
a1235 2
   PROLOG ("witSetPartProdBounds");

a1238 2

   EPILOG;
d1247 1
a1247 1
WitReturnCode WitRun::witSetPartProdVol (
a1250 2
   PROLOG ("witSetPartProdVol");

a1253 2

   EPILOG;
d1258 1
a1258 1
WitReturnCode WitRun::witSetPartPropRouting (
a1261 2
   PROLOG ("witSetPartPropRouting");

a1276 2

   EPILOG;
d1281 1
a1281 1
WitReturnCode WitRun::witSetPartPropRtg (
a1284 2
   PROLOG ("witSetPartPropRtg");

a1290 2

   EPILOG;
d1295 1
a1295 1
WitReturnCode WitRun::witSetPartScrapCost (
a1298 2
   PROLOG ("witSetPartScrapCost");

a1316 2

   EPILOG;
d1321 1
a1321 1
WitReturnCode WitRun::witSetPartSelForDel (
a1324 2
   PROLOG ("witSetPartSelForDel");

a1327 2

   EPILOG;
d1332 1
a1332 1
WitReturnCode WitRun::witSetPartSingleSource (
a1334 2
   PROLOG ("witSetPartSingleSource");

a1343 2

   EPILOG;
d1348 1
a1348 1
WitReturnCode WitRun::witSetPartStockBounds (
a1353 2
   PROLOG ("witSetPartStockBounds");

a1360 2

   EPILOG;
d1365 1
a1365 1
WitReturnCode WitRun::witSetPartStockCost (
a1368 2
   PROLOG ("witSetPartStockCost");

a1386 2

   EPILOG;
d1391 1
a1391 1
WitReturnCode WitRun::witSetPartSupplyVol (
a1394 2
   PROLOG ("witSetPartSupplyVol");

a1400 2

   EPILOG;
d1405 1
a1405 1
WitReturnCode WitRun::witSetPartUnitCost (
a1408 2
   PROLOG ("witSetPartUnitCost");

a1417 2

   EPILOG;
d1422 1
a1422 1
WitReturnCode WitRun::witSetPartYield (
a1425 2
   PROLOG ("witSetPartYield");

a1428 2

   EPILOG;
@


1.91
log
@[exceptions]
@
text
@d85 6
a90 1
   witAddPartVa (partNameParm, partCategoryParm, NULL);
d102 5
a106 6
   WitAttr       attr;
   WitPart *     newPart;
   float *       hardlbP;
   float *       softlbP;
   float *       hardubP;
   static int    recursionDepth = 0;
d110 1
a110 1
   forbidNullArg (partNameParm, "partName");
d112 1
a112 1
   recursionDepth ++;
d114 1
a114 4
   newPart =
      (recursionDepth == 1 and wit34Compatible ())?
         addPart34     (partNameParm, partCategoryParm):
         addPartPost34 (partNameParm, partCategoryParm);
d116 1
a116 1
   myInputID ()->setMyPart (newPart);
d129 1
a129 1
               newPart->partName ().myCstring (), 
d134 1
a134 1
            requiredMaterial (newPart);
d137 1
a137 1
               newPart->partName ().myCstring (),
d147 1
a147 1
            requiredMaterial (newPart);
d150 1
a150 1
               newPart->partName ().myCstring (),
d159 1
a159 1
               newPart->partName ().myCstring (), 
d164 1
a164 1
               newPart->partName ().myCstring (), 
d169 1
a169 1
               newPart->partName ().myCstring (), 
d174 1
a174 1
               newPart->partName ().myCstring (), 
d179 1
a179 1
               newPart->partName ().myCstring (), 
d184 1
a184 1
               newPart->partName ().myCstring (),
d194 1
a194 1
               newPart->partName ().myCstring (),
d202 1
a202 1
               newPart->partName ().myCstring (),
a214 2
   recursionDepth--;

d225 1
a225 1
   witAddPartVa (partAndOperationName, WitMATERIAL, NULL);
d1749 5
a1753 1
      witAddPartWithOperation (partName);
d1759 1
a1759 1
      witAddPartVa (partName, WitMATERIAL, NULL);
d1762 1
a1762 1
      witAddPartVa (partName, WitCAPACITY, NULL);
d1765 1
a1765 1
      witAddPartVa (partName, WitMATERIAL, NULL);
@


1.90
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@d17 1
d19 1
d58 1
a58 1
   myInputId ()->setMyPart (thePart);
d72 1
a72 1
   myInputId ()->setMyAttr (theAttr);
d115 1
a115 1
   myInputId ()->setMyPart (newPart);
d212 1
a212 1
   myInputId ()->setMyPart (NULL);
d795 1
a795 1
      myInputId ()->setMyPart (NULL);
@


1.89
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d868 7
a874 1
   WitPartApiCall theCall (this, partName);
d876 1
a876 4
   apiGet (
       obj1ScrapCost,
      "obj1ScrapCost",
      theCall.myPart ()->obj1ScrapCost ());
d889 7
a895 1
   WitMaterialApiCall theCall (this, partName, "obj1StockCost");
d897 1
a897 4
   apiGet (
       obj1StockCost,
      "obj1StockCost",
      theCall.myMaterial ()->obj1StockCost ());
d1084 18
d1179 18
d1455 7
a1461 15
   WitPartApiCall theCall (this, partName);
   WitPeriod      thePer;

   theCall.prepDblVec ("obj1ScrapCost", obj1ScrapCost);

   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (obj1ScrapCost[thePer] < 0.0)
            myMsgFac () (
               "negPartObj1CostCoef",
               "obj1ScrapCost",
               partName,
               obj1ScrapCost[thePer],
               thePer);
d1463 1
a1463 2
      theCall.myPart ()->setObj1ScrapCost (obj1ScrapCost);
      }
d1476 7
a1482 4
   WitMaterialApiCall theCall (this, partName, "obj1StockCost");
   WitPeriod          thePer;

   theCall.prepDblVec ("obj1StockCost", obj1StockCost);
d1484 1
a1484 13
   if (theCall.argsOK ())
      {
      forEachPeriod (thePer, myProblem ())
         if (obj1StockCost[thePer] < 0.0)
            myMsgFac () (
               "negPartObj1CostCoef",
               "obj1StockCost",
               partName,
               obj1StockCost[thePer],
               thePer);

      theCall.myMaterial ()->setObj1StockCost (obj1StockCost);
      }
d1572 30
d1658 30
@


1.88
log
@Vector PropRtg.
@
text
@d870 1
a870 1
   apiGetObj1Vector (
d888 1
a888 1
   apiGetObj1Vector (
d1416 1
a1416 1
   theCall.prepObj1Vec ("obj1ScrapCost", obj1ScrapCost);
d1446 1
a1446 1
   theCall.prepObj1Vec ("obj1StockCost", obj1StockCost);
@


1.87
log
@Vector PropRtg.
@
text
@d1025 8
a1047 3
   if (not myGlobalComp ()->allowVecPR ())
      myMsgFac () ("propRtgNYISmsg");

d1509 11
a1519 1
   WitPartApiCall theCall (this, partName);
d1521 1
a1521 4
   theCall.prepBool (    
                        "propRouting",
      theCall.myPart ()->propRtg ()[0],
                         propRouting);
d1523 1
a1523 2
   if (theCall.argsOK ())
      theCall.myPart ()->setPropRouting (asaBool (propRouting));
a1537 3
   if (not myGlobalComp ()->allowVecPR ())
      myMsgFac () ("propRtgNYISmsg");

@


1.86
log
@Vector PropRtg.
@
text
@d1270 1
a1270 1
   WitTVec <int> & tempIntVecRef = myApiMgr ()->reserveTempIntVec ();
d1280 1
a1280 1
   tempIntVecRef = buildAheadLimit;
d1282 1
a1282 1
   witSetPartBuildAheadUB (partName, tempIntVecRef.myCVec ());
a1529 3
   if (not hasSingleValue (propRtg, nPeriods ()))
      myMsgFac () ("propRtgNonSglSmsg");

@


1.85
log
@Vector PropRtg.
@
text
@d1025 1
a1025 1
   apiGet (propRouting, "propRouting", theCall.myPart ()->propRouting ());
d1507 2
a1508 2
                        "propRouting", 
      theCall.myPart ()->propRouting (), 
@


1.84
log
@Vector PropRtg.
@
text
@d255 2
a256 2
      if (not (thePart->focShortageVol () == 0.0))
         ++ nShortParts;
d267 1
a267 1
      if (not (thePart->focShortageVol () == 0.0))
a280 28
#if 0

   {
   WitPart * thePart;
   int       theIdx;
   Elem *    shortVolCVec;

   apiAlloc (shortageVolList, * lenList);

   theIdx = -1;

   forEachPart (thePart, theWitRun->myProblem ())
      if (not (thePart->focShortageVol () == 0.0))
         {
         theIdx ++;

         apiAlloc (& shortVolCVec, theWitRun->nPeriods ());

         thePart->focShortageVol ().copyInto (shortVolCVec);

         (* shortageVolList)[theIdx] = shortVolCVec;
         }
   }

#endif

//------------------------------------------------------------------------------

@


1.83
log
@Vector Prop-Rtg.
@
text
@d1060 1
a1060 1
WitReturnCode WitRun::witGetPartPropRt (
d1062 1
a1062 1
      WitBoolean * * propRt)
d1064 1
a1064 1
   PROLOG ("witGetPartPropRt");
d1069 1
a1069 1
      myMsgFac () ("propRtNYISmsg");
d1071 1
a1071 1
   apiGet (propRt, "propRt", theCall.myPart ()->propRt ());
d1547 1
a1547 1
WitReturnCode WitRun::witSetPartPropRt (
d1549 1
a1549 1
      const WitBoolean * propRt)
d1551 1
a1551 1
   PROLOG ("witSetPartPropRt");
d1556 1
a1556 1
      myMsgFac () ("propRtNYISmsg");
d1558 2
a1559 2
   if (not hasSingleValue (propRt, nPeriods ()))
      myMsgFac () ("propRtNonSglSmsg");
d1561 1
a1561 1
   theCall.prepBoolVec ("propRt", propRt);
d1564 1
a1564 1
      theCall.myPart ()->setPropRt (propRt);
@


1.82
log
@Vector PropRt.
@
text
@d1558 3
@


1.81
log
@Vector PropRt.
@
text
@d1527 2
a1528 1
      const char * partName, WitBoolean propRouting)
d1548 2
a1549 1
      const char * partName, const WitBoolean * propRt)
@


1.80
log
@Vector propRt.
@
text
@d19 5
a23 5
#include <InScalRA.h>
#include <OutScalRA.h>
#include <InVecRA.h>
#include <OutVecRA.h>
#include <Out2DARA.h>
d236 3
a238 3
      int   *             lenList,
      char  * * *         partList,
      const WitOut2DARA & shortageVolList)
d484 2
a485 2
      const char *        partName,
      const WitOutVecRA & consVol)
d561 2
a562 2
      const char *        partName,
      const WitOutVecRA & inpVal)
d616 2
a617 2
      const char *        partName,
      const WitOutVecRA & excessVol)
d664 2
a665 2
      const char *        partName,
      const WitOutVecRA & focusShortageVol)
d685 2
a686 2
      const char *        partName,
      const WitOutVecRA & incLotSize)
d700 2
a701 2
      const char *        partName,
      const WitOutVecRA & minLotSize)
d715 2
a716 2
      const char *        partName,
      const WitOutVecRA & mrpConsVol)
d730 2
a731 2
      const char *        partName,
      const WitOutVecRA & mrpExcessVol)
d754 2
a755 2
      const char *        partName,
      const WitOutVecRA & mrpProdVol)
d769 2
a770 2
      const char *        partName,
      const WitOutVecRA & mrpResidualVol)
d891 2
a892 2
      const char *        partName,
      const WitOutVecRA & obj1ScrapCost)
d909 2
a910 2
      const char *        partName,
      const WitOutVecRA & obj1StockCost)
d927 2
a928 2
      const char *        partName,
      const WitOutVecRA & obj1ProdCost)
d942 4
a945 4
      const char *        partName,
      const WitOutVecRA & hardLB,
      const WitOutVecRA & softLB,
      const WitOutVecRA & hardUB)
d963 2
a964 2
      const char *        partName,
      const WitOutVecRA & prodVol)
d1016 2
a1017 2
      const char *        partName,
      const WitOutVecRA & reqVol)
d1031 2
a1032 2
      const char *        partName,
      const WitOutVecRA & residualVol)
d1102 2
a1103 2
      const char *        partName,
      const WitOutVecRA & scrapVol)
d1132 2
a1133 2
      const char *        partName,
      const WitOutVecRA & shadowPrice)
d1162 4
a1165 4
      const char *        partName,
      const WitOutVecRA & hardLB,
      const WitOutVecRA & softLB,
      const WitOutVecRA & hardUB)
d1179 2
a1180 2
      const char *        partName,
      const WitOutVecRA & stockVol)
d1194 2
a1195 2
      const char *        partName,
      const WitOutVecRA & supplyVol)
d1210 1
a1210 1
      const WitOutScalRA & unitCost)
d1364 2
a1365 2
      const char *       partName,
      const WitInVecRA & inpVal)
d1386 2
a1387 2
      const char *       partName,
      const WitInVecRA & incLotSize)
d1401 2
a1402 2
      const char *       partName,
      const WitInVecRA & minLotSize)
d1416 2
a1417 2
      const char *       partName,
      const WitInVecRA & obj1ProdCost)
d1431 2
a1432 2
      const char *       partName,
      const WitInVecRA & obj1ScrapCost)
d1461 2
a1462 2
      const char *       partName,
      const WitInVecRA & obj1StockCost)
d1491 4
a1494 4
    const char *       partName,
    const WitInVecRA & hardLB,
    const WitInVecRA & softLB,
    const WitInVecRA & hardUB)
d1512 2
a1513 2
      const char *       partName,
      const WitInVecRA & prodVol)
d1602 4
a1605 4
      const char *       partName,
      const WitInVecRA & hardLB,
      const WitInVecRA & softLB,
      const WitInVecRA & hardUB)
d1623 2
a1624 2
      const char *       partName,
      const WitInVecRA & supplyVol)
d1641 2
a1642 2
      const char *        partName,
      const WitInScalRA & unitCost)
@


1.79
log
@Pegged Critical List.
@
text
@d1060 18
d1546 20
@


1.78
log
@Minor change.
@
text
@d271 1
a271 1
         (* partList)[theIdx] = dupCstring (thePart->partName ());
d385 1
a385 1
      partNameListRef[i++] = dupCstring (thePart->partName ());
d519 1
a519 1
   * consumingOperationName = dupCstring (theBomEnt->myOperationName ());
d551 1
a551 1
   * consumingOperationName = dupCstring (theSub->myOperationName ());
d608 1
a608 1
      (* demandList)[i++] = dupCstring (theDemand->demandName ());
d1007 1
a1007 1
   * producingOperationName = dupCstring (theBopEnt->myOperationName ());
d1076 1
a1076 1
      (* partList)[i++] = dupCstring (partj->partName ());
@


1.77
log
@Removed portableFree.
@
text
@a32 1
#include <wit.h>
@


1.76
log
@Double Precision.
@
text
@d432 1
a432 1
   portableFree (buildAheadUBval);
@


1.75
log
@Double Precision.
@
text
@d274 1
a274 1
         shortageVolList.convCopyIntoRow (theIdx, thePart->focShortageVol ());
d300 1
a300 1
         thePart->focShortageVol ().convCopyInto (shortVolCVec);
@


1.74
log
@Double Precision.
@
text
@d1291 1
a1291 1
   tempIntVecRef.setToScalar (buildAheadLimit);
@


1.73
log
@Double Precision.
@
text
@d562 2
a563 2
      const char * partName,
      float * *    inpVal)
d686 2
a687 2
      const char * partName,
      float * *    incLotSize)
d701 2
a702 2
      const char * partName,
      float * *    minLotSize)
d755 2
a756 2
      const char * partName,
      float * *    mrpProdVol)
d928 2
a929 2
      const char * partName,
      float * *    obj1ProdCost)
d943 4
a946 4
      const char * partName,
      float * *    hardLB,
      float * *    softLB,
      float * *    hardUB)
d1347 2
a1348 2
      const char *  partName,
      const float * inpVal)
d1369 2
a1370 2
      const char *  partName,
      const float * incLotSize)
d1384 2
a1385 2
      const char * partName,
      const float * minLotSize)
d1399 2
a1400 2
      const char *  partName,
      const float * obj1ProdCost)
d1474 4
a1477 4
    const char *  partName,
    const float * hardLB,
    const float * softLB,
    const float * hardUB)
d1495 2
a1496 2
      const char *  partName,
      const float * prodVol)
@


1.72
log
@Double Precision.
@
text
@d23 1
d237 3
a239 3
      int   *     lenList,
      char  * * * partList,
      float * * * shortageVolList)
d241 4
d247 26
a272 1
   getFSSTypeInd (lenList, partList, shortageVolList);
d274 2
a275 1
   getFSSTypeDep (this, lenList, shortageVolList);
d282 2
a283 4
WitReturnCode WitRun::witGetFocusShortageVolDbl (
      int    *     lenList,
      char   * * * partList,
      double * * * shortageVolList)
d285 12
a296 1
   PROLOG ("witGetFocusShortageVolDbl");
d298 1
a298 1
   getFSSTypeInd (lenList, partList, shortageVolList);
d300 1
a300 1
   getFSSTypeDep (this, lenList, shortageVolList);
d302 2
a303 1
   EPILOG;
d306 2
a1720 78

//------------------------------------------------------------------------------

void WitRun::getFSSTypeInd (
      int *      lenList,
      char * * * partList,
      void *     shortageVolList)
   {
   int       nShortParts;
   WitPart * thePart;
   int       theIdx;

   forbidNullArg (lenList,         "lenList");
   forbidNullArg (partList,        "partList");
   forbidNullArg (shortageVolList, "shortageVolList");

   myProblem ()->computeFssIfNeeded ();

   nShortParts = 0;

   forEachPart (thePart, myProblem ())
      if (not (thePart->focShortageVol () == 0.0))
         ++ nShortParts;

   * lenList = nShortParts;

   apiAlloc (partList, nShortParts);

   theIdx = -1;

   forEachPart (thePart, myProblem ())
      if (not (thePart->focShortageVol () == 0.0))
         {
         theIdx ++;

         (* partList)[theIdx] = dupCstring (thePart->partName ());
         }
   }

//------------------------------------------------------------------------------
// Implementation and explicit instantiation of function template
// NonClass::getFSSTypeDep.
//------------------------------------------------------------------------------

template <typename Elem> 
      void WitNonClass::getFSSTypeDep (
         WitRun *   theWitRun,
         int  *     lenList,
         Elem * * * shortageVolList)
   {
   WitPart * thePart;
   int       theIdx;
   Elem *    shortVolCVec;

   apiAlloc (shortageVolList, * lenList);

   theIdx = -1;

   forEachPart (thePart, theWitRun->myProblem ())
      if (not (thePart->focShortageVol () == 0.0))
         {
         theIdx ++;

         apiAlloc (& shortVolCVec, theWitRun->nPeriods ());

         thePart->focShortageVol ().convCopyInto (shortVolCVec);

         (* shortageVolList)[theIdx] = shortVolCVec;
         }
   }

//------------------------------------------------------------------------------

template
   void WitNonClass::getFSSTypeDep <float>  (WitRun *, int *, float  * * *);

template
   void WitNonClass::getFSSTypeDep <double> (WitRun *, int *, double * * *);
@


1.71
log
@Double Precision.
@
text
@a239 3
   WitPart * thePart;
   int       theIdx;

d242 1
a242 5
   getFSS (lenList, partList);

   forbidNullArg (shortageVolList, "shortageVolList");

   apiAlloc (shortageVolList, * lenList);
d244 1
a244 11
   theIdx = -1;

   forEachPart (thePart, myProblem ())
      if (not (thePart->focShortageVol () == 0.0))
         {
         theIdx ++;

         apiAlloc (& ((* shortageVolList)[theIdx]), nPeriods ());

         thePart->focShortageVol ().convCopyInto ((* shortageVolList)[theIdx]);
         }
a255 3
   WitPart * thePart;
   int       theIdx;

d258 1
a258 7
   getFSS (lenList, partList);

   forbidNullArg (shortageVolList, "shortageVolList");

   apiAlloc (shortageVolList, * lenList);

   theIdx = -1;
d260 1
a260 9
   forEachPart (thePart, myProblem ())
      if (not (thePart->focShortageVol () == 0.0))
         {
         theIdx ++;

         apiAlloc (& ((* shortageVolList)[theIdx]), nPeriods ());

         thePart->focShortageVol ().convCopyInto ((* shortageVolList)[theIdx]);
         }
d1681 4
a1684 1
void WitRun::getFSS (int * lenList, char * * * partList)
d1690 3
a1692 2
   forbidNullArg (lenList,  "lenList");
   forbidNullArg (partList, "partList");
d1716 40
@


1.70
log
@Double Precision.
@
text
@d240 2
a241 3
   WitPart * parti;
   int       i;
   WitPeriod t;
d245 2
a246 2
   forbidNullArg (lenList,         "lenList");
   forbidNullArg (partList,        "partList");
d249 3
a251 1
   * lenList = 0;
d253 26
a278 1
   myProblem ()->computeFssIfNeeded ();
d280 1
a280 3
   forEachPart (parti, myProblem ())
      if (not (parti->focShortageVol () == 0.0))
         ++ *lenList;
a281 1
   apiAlloc (partList,        * lenList);
d284 1
a284 1
   i = 0;
d286 2
a287 2
   forEachPart (parti, myProblem ())
      if (not (parti->focShortageVol () == 0.0))
d289 1
a289 3
         (* partList)[i] = dupCstring (parti->partName ());

         apiAlloc (& ((* shortageVolList)[i]), nPeriods ());
d291 1
a291 2
         forEachPeriod (t, myProblem ())
            (* shortageVolList)[i][t] = parti->focShortageVol ()[t];
d293 1
a293 1
         i++;
d1711 34
@


1.69
log
@Double Precision.
@
text
@d258 2
a259 2
   apiAlloc (* partList,        * lenList);
   apiAlloc (* shortageVolList, * lenList);
d268 1
a268 1
         apiAlloc ((* shortageVolList)[i], nPeriods ());
d340 4
a343 4
   int &          lenListRef      = * lenList;
   char * * &     partNameListRef = * partNameList;
   WitPart *      thePart;
   int            i;
d352 1
a352 1
   apiAlloc (partNameListRef, lenListRef);
d575 1
a575 1
   apiAlloc (* demandList, * lenDemandList);
d598 1
a598 1
   excessVol.apiAlloc (nPeriods ());
d712 1
a712 1
   mrpExcessVol.apiAlloc (nPeriods ());
d1045 1
a1045 1
   apiAlloc (* partList, * lenPartList);
@


1.68
log
@Double Precision.
@
text
@d596 1
a596 1
   forbidNullArg (excessVol.asaTlPtr (), "excessVol");
d710 1
a710 1
   forbidNullArg (mrpExcessVol.asaTlPtr (), "mrpExcessVol");
@


1.67
log
@Double Precision.
@
text
@a594 1
   double         exVolVal;
d601 1
a601 2
      {
      exVolVal =
a605 3
      excessVol.setElem (thePer, exVolVal);
      }

a708 1
   double         mrpExVolVal;
d715 1
a715 2
      {
      mrpExVolVal =
a718 3

      mrpExcessVol.setElem (thePer, mrpExVolVal);
      }
@


1.66
log
@Double Precision.
@
text
@d588 2
a589 2
      const char * partName,
      float * *    excessVol)
d595 3
d599 1
a599 1
   apiGet (excessVol, "excessVol", theCall.myPart ()->residualVol ());
d602 8
a609 3
      setToMin (
         (* excessVol)[thePer], 
         fltFromDbl (theCall.myPart ()->supplyVol ()[thePer]));
d641 2
a642 2
      const char * partName,
      float * *    focusShortageVol)
d692 2
a693 2
      const char * partName,
      float * * mrpConsVol)
d707 2
a708 2
      const char * partName,
      float * *    mrpExcessVol)
d714 1
d716 3
a718 1
   apiGet (mrpExcessVol, "mrpExcessVol", theCall.myPart ()->mrpResidualVol ());
d721 5
a725 3
      setToMin (
         (* mrpExcessVol)[thePer], 
         fltFromDbl (theCall.myPart ()->supplyVol ()[thePer]));
d727 3
d751 2
a752 2
      const char * partName,
      float * *    mrpResidualVol)
d891 2
a892 2
      const char * partName,
      float * *    obj1StockCost)
d997 3
a999 1
WitReturnCode WitRun::witGetPartReqVol (const char * partName, float * * reqVol)
d1013 2
a1014 2
      const char * partName,
      float * *    residualVol)
d1143 2
a1144 2
      const char * partName,
      float * *    stockVol)
@


1.65
log
@Double Precision.
@
text
@a1314 1

d1407 2
a1408 2
      const char *  partName,
      const float * obj1StockCost)
@


1.64
log
@Double Precision.
@
text
@d929 2
a930 2
      const char * partName,
      float * *    prodVol)
d1048 2
a1049 2
      const char * partName,
      float * *    scrapVol)
@


1.63
log
@Double Precision.
@
text
@d657 7
a663 9
   return
      getPart34Attribute (
         partName,
         "witGetPartIncLotSize",
         WitNincLotSize,
         "Operation",
         WitNincLotSize,
         & WitRun::witGetOperationIncLotSize,
         incLotSize);
d672 7
a678 9
   return
      getPart34Attribute (
         partName,
         "witGetPartMinLotSize",
         WitNminLotSize,
         "Operation",
         WitNminLotSize,
         & WitRun::witGetOperationMinLotSize,
         minLotSize);
d685 1
a685 1
      float ** mrpConsVol)
d723 7
a729 9
   return
      getPart34Attribute (
         partName,
         "witGetPartMrpProdVol",
         "mrpProdVol",
         "Operation",
         "mrpExecVol",
         & WitRun::witGetOperationMrpExecVol,
         mrpProdVol);
d896 7
a902 9
   return
      getPart34Attribute (
         partName,
         "witGetPartObj1ProdCost",
         WitNobj1ProdCost,
         "Operation",
         "obj1ExecCost",
         & WitRun::witGetOperationObj1ExecCost,
         obj1ProdCost);
d913 7
a919 11
   return
      getPart34Attribute (
         partName,
         "witGetPartProdBounds",
         WitNprodBounds,
         "Operation",
         "execBounds",
         & WitRun::witGetOperationExecBounds,
         hardLB,
         softLB,
         hardUB);
d932 2
d935 5
a939 9
      return
         getPart34Attribute (
            partName,
            "witGetPartProdVol",
            WitNprodVol,
            "Operation",
            "execVol",
            & WitRun::witGetOperationExecVol,
            prodVol);
a941 2
      PROLOG ("witGetPartProdVol");

d945 1
d947 1
a947 2
      EPILOG;
      }
d1173 7
a1179 9
   return
      getPart34Attribute (
         partName,
         "witGetPartYield",
         WitNyield,
         "Operation",
         WitNyield,
         & WitRun::witGetOperationYield,
         yield);
d1336 7
a1342 9
   return
      setPart34Attribute (
         partName,
         "witSetPartIncLotSize",
         WitNincLotSize,
         "Operation",
         WitNincLotSize,
         & WitRun::witSetOperationIncLotSize,
         incLotSize);
d1351 7
a1357 9
   return
      setPart34Attribute (
         partName,
         "witSetPartMinLotSize",
         WitNminLotSize,
         "Operation",
         WitNminLotSize,
         & WitRun::witSetOperationMinLotSize,
         minLotSize);
d1366 7
a1372 9
   return
      setPart34Attribute (
         partName,
         "witSetPartObj1ProdCost",
         WitNobj1ProdCost,
         "Operation",
         "obj1ExecCost",
         & WitRun::witSetOperationObj1ExecCost,
         obj1ProdCost);
d1443 7
a1449 11
   return
      setPart34Attribute (
         partName,
         "witSetPartProdBounds",
         WitNprodBounds,
         "Operation",
         "execBounds",
         & WitRun::witSetOperationExecBounds,
         hardLB,
         softLB,
         hardUB);
d1462 7
a1468 9
   return
      setPart34Attribute (
         partName,
         "witSetPartProdVol",
         WitNprodVol,
         "Operation",
         "execVol",
         & WitRun::witSetOperationExecVol,
         prodVol);
d1592 7
a1598 9
   return
      setPart34Attribute (
         partName,
         "witSetPartYield",
         WitNyield,
         "Operation",
         WitNyield,
         & WitRun::witSetOperationYield,
         yield);
a1669 232
   }

//------------------------------------------------------------------------------
// getPart34Attribute
// Do the work of the witGetPart* functions for attributes that
// were moved from class Part to class Operation in Wit V4.0.
//------------------------------------------------------------------------------

WitReturnCode WitRun::getPart34Attribute(
      const char * partName,
      const char * witApiName,
      const char * the34Attribute,
      const char * the40Object,
      const char * the40Attribute,
      WitReturnCode (WitRun::*equivalentMethod) (const char *, int * *),
      int * *     retVal)
   {
   PROLOG (witApiName);

   if (wit34Compatible ())
      {
      myMsgFac () ("getting34AttributeWithCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

      (this->*equivalentMethod) (partName, retVal);
      }
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::getPart34Attribute(
      const char * partName,
      const char * witApiName,
      const char * the34Attribute,
      const char * the40Object,
      const char * the40Attribute,
      WitReturnCode (WitRun::*equivalentMethod) (const char *, float * *),
      float * *    retVal)
   {
   PROLOG (witApiName);

   if (wit34Compatible ())
      {
      myMsgFac () ("getting34AttributeWithCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

      (this->*equivalentMethod) (partName, retVal);
      }
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::getPart34Attribute (
   const char * partName,
   const char * witApiName,
   const char * the34Attribute,
   const char * the40Object,
   const char * the40Attribute,
   WitReturnCode (WitRun::*equivalentMethod) (
      const char *,
      const WitOutVecRA &,
      const WitOutVecRA &,
      const WitOutVecRA &),

   const WitOutVecRA & hardLB,
   const WitOutVecRA & softLB,
   const WitOutVecRA & hardUB)
   {
   PROLOG (witApiName);

   if (wit34Compatible ())
      {
      myMsgFac () ("getting34AttributeWithCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

      (this->*equivalentMethod) (partName, hardLB, softLB, hardUB);
      }
   else
      myMsgFac () ("getting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

   EPILOG;
   }

//------------------------------------------------------------------------------
// setPart34Attribute
// Do the work of the witSetPart* functions for attributes that
// were moved from class Part to class Operation in Wit V4.0.
//------------------------------------------------------------------------------

WitReturnCode WitRun::setPart34Attribute(
   const char * partName,
   const char * witApiName,
   const char * the34Attribute,
   const char * the40Object,
   const char * the40Attribute,
   WitReturnCode (WitRun::*equivalentMethod) (const char *, const int *),
   const int *  inpVal)
   {
   PROLOG (witApiName);

   if (wit34Compatible ())
      {
      myMsgFac () ("setting34AttributeWithCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

      (this->*equivalentMethod) (partName, inpVal);
      }
   else
      myMsgFac () ("setting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::setPart34Attribute(
   const char *  partName,
   const char *  witApiName,
   const char *  the34Attribute,
   const char *  the40Object,
   const char *  the40Attribute,
   WitReturnCode (WitRun::*equivalentMethod) (const char *, const float *),
   const float * inpVal)
   {
   PROLOG (witApiName);

   if (wit34Compatible ())
      {
      myMsgFac () ("setting34AttributeWithCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

      (this->*equivalentMethod) (partName, inpVal);
      }
   else
      myMsgFac () ("setting34AttributeWithoutCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::setPart34Attribute(
   const char *  partName,
   const char *  witApiName,
   const char *  the34Attribute,
   const char *  the40Object,
   const char *  the40Attribute,
   WitReturnCode (WitRun::*equivalentMethod) (
      const char *,
      const WitInVecRA &,
      const WitInVecRA &,
      const WitInVecRA &),

   const WitInVecRA & hardLB,
   const WitInVecRA & softLB,
   const WitInVecRA & hardUB)
   {
   PROLOG (witApiName);

   if (wit34Compatible ())
      {
      myMsgFac () ("setting34AttributeWithCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

      (this->*equivalentMethod) (partName, hardLB, softLB, hardUB);
      }
   else
      myMsgFac () ("setting34AttributeWithCompatibilityMode",
         apiFuncName (),
         "Part",
         the34Attribute,
         the40Object,
         the40Attribute);

   EPILOG;
@


1.62
log
@Double Precision.
@
text
@d456 2
a457 2
      const char * partName,
      float * *    consVol)
@


1.61
log
@Double Precision.
@
text
@d1094 2
a1095 2
      const char * partName,
      float * *    shadowPrice)
@


1.60
log
@Double Precision.
@
text
@d863 2
a864 2
      const char * partName,
      float * *    obj1ScrapCost)
d870 1
a870 1
   witGetObj1Vector (
d888 1
a888 1
   witGetObj1Vector (
d1402 2
a1403 2
      const char *  partName,
      const float * obj1ScrapCost)
@


1.59
log
@Double Precision.
@
text
@d22 1
d1124 4
a1127 4
      const char * partName,
      float * *    hardLB,
      float * *    softLB,
      float * *    hardUB)
d1559 4
a1562 4
      const char *  partName,
      const float * hardLB,
      const float * softLB,
      const float * hardUB)
d1780 1
a1780 1
WitReturnCode WitRun::getPart34Attribute(
d1788 7
a1794 7
      float * *,
      float * *,
      float * *),

   float * *    hardLB,
   float * *    softLB,
   float * *    hardUB)
d1904 7
a1910 7
      const float *,
      const float *,
      const float *),

   const float * hardLB,
   const float * softLB,
   const float * hardUB)
@


1.58
log
@Double Precision.
@
text
@d1567 1
a1567 1
   theCall.prepBoundSet (
a1571 3

   if (theCall.argsOK ())
      theCall.myMaterial ()->stockBounds ()->set (hardLB, softLB, hardUB);
@


1.57
log
@Double Precision.
@
text
@d1155 2
a1156 2
      const char * partName,
      float * *    supplyVol)
@


1.56
log
@Double Precision.
@
text
@d1170 2
a1171 2
      const char * partName,
      WitOutScalRA unitCost)
@


1.55
log
@Double Precision.
@
text
@d1297 1
a1297 1
      theCall.myMaterial ()->setBuildAsap (buildAsap);
d1319 1
a1319 1
      theCall.myMaterial ()->setBuildNstn (buildNstn);
@


1.54
log
@Double Precision.
@
text
@d1600 2
a1601 2
      const char * partName,
      WitInScalRA  unitCost)
@


1.53
log
@Double Precision.
@
text
@d1230 1
a1230 1
      theCall.myMaterial ()->setBaSelSplit (baSelSplit);
d1515 1
a1515 1
      theCall.myPart ()->setPropRouting (propRouting);
d1550 1
a1550 1
      theCall.myPart ()->setSingleSource (singleSource);
@


1.52
log
@Double Precision.
@
text
@d314 1
a314 1
      witBoolean * baSelSplit)
d411 1
a411 1
      witBoolean * buildAsap)
d426 1
a426 1
      witBoolean * buildNstn)
d609 1
a609 1
      witBoolean * exist)
d1026 1
a1026 1
      witBoolean * propRouting)
d1079 1
a1079 1
      witBoolean * selForDel)
d1109 1
a1109 1
      witBoolean * singleSource)
d1218 1
a1218 1
      witBoolean   baSelSplit)
d1284 1
a1284 1
      witBoolean   buildAsap)
d1306 1
a1306 1
      witBoolean   buildNstn)
d1503 1
a1503 1
      const char * partName, witBoolean propRouting)
d1524 1
a1524 1
      witBoolean   selForDel)
d1538 1
a1538 1
      const char * partName, witBoolean singleSource)
@


1.51
log
@Double Precision.
@
text
@d1582 2
a1583 2
      const char * partName,
      WitInVecRA   supplyVol)
@


1.50
log
@Double Precision.
@
text
@d21 1
d1582 2
a1583 2
      const char *  partName,
      const float * supplyVol)
d1589 1
a1589 1
   theCall.prepNonNegFloatVec ("supplyVol", supplyVol);
@


1.49
log
@Double Precision.
@
text
@d597 3
a599 2
      setToMin ((* excessVol)[thePer],
         floatFromDouble (theCall.myPart ()->supplyVol ()[thePer]));
d714 1
a714 1
         floatFromDouble (theCall.myPart ()->supplyVol ()[thePer]));
@


1.48
log
@Double Precision.
@
text
@d1271 1
a1271 1
   witSetPartBuildAheadUB (partName, tempIntVecRef.myCvector ());
@


1.47
log
@Double Precision.
@
text
@d597 2
a598 1
      setToMin ((* excessVol)[thePer], theCall.myPart ()->supplyVol ()[thePer]);
d713 1
a713 1
         theCall.myPart ()->supplyVol ()[thePer]);
@


1.46
log
@Continued double precision.
@
text
@d1168 1
a1168 1
      OutScalRA    unitCost)
d1598 1
a1598 1
      InScalRA     unitCost)
@


1.45
log
@Continued double precision.
@
text
@d19 2
a20 2
#include <RealSInArg.h>
#include <RealSOutArg.h>
d1168 1
a1168 1
      RealSOutArg  unitCost)
d1598 1
a1598 1
      RealSInArg   unitCost)
@


1.44
log
@Continued double precision.
@
text
@d19 2
d1168 1
a1168 1
      float *      unitCost)
d1596 3
a1598 1
WitReturnCode WitRun::witSetPartUnitCost (const char * partName, float unitCost)
d1610 1
a1610 1
      theCall.myPart ()->setUnitCost (doubleFromFloat (unitCost));
@


1.43
log
@Continued double precision.
@
text
@d1606 1
a1606 1
      theCall.myPart ()->setUnitCost (static_cast <double> (unitCost));
@


1.42
log
@Continued double precision.
@
text
@d1600 1
a1600 1
   theCall.prepNonNegStrDbl (
d1606 1
a1606 1
      theCall.myPart ()->setUnitCost (StrDbl::convFloat (unitCost));
@


1.41
log
@Removed a bad function overload.
@
text
@d1600 1
a1600 1
   theCall.prepNonNegFloat (
d1606 1
a1606 1
      theCall.myPart ()->setUnitCost (unitCost);
@


1.40
log
@Continued implementation of post-implosion pegging.
@
text
@d283 1
a283 1
   thePart = curItrDelCompForGet (WitAT_PART, "partFrag")->myPart ();
d1937 1
a1937 1
   theMat = thePart->myMat ();
@


1.39
log
@Continued implementation of proportionate routing.
@
text
@a31 1
#include <FlexVecI.h>
@


1.38
log
@Continued implementation of proportionate routing.
@
text
@d284 1
a284 1
   curItrDelCompForGet (WitAT_PART, "partFrag")->getPart (thePart);
d1938 1
a1938 1
   thePart->getMaterial (theMat);
@


1.37
log
@Internal changes.
@
text
@d1020 16
a1035 1
WitReturnCode WitRun::witGetParts(
d1426 30
d1498 2
a1499 3
WitReturnCode WitRun::witSetPartObj1StockCost (
      const char *  partName,
      const float * obj1StockCost)
d1501 1
a1501 1
   PROLOG ("witSetPartObj1StockCost");
d1503 1
a1503 2
   WitMaterialApiCall theCall (this, partName, "obj1StockCost");
   WitPeriod          thePer;
d1505 4
a1508 1
   theCall.prepObj1Vec ("obj1StockCost", obj1StockCost);
d1511 1
a1511 12
      {
      forEachPeriod (thePer, myProblem ())
         if (obj1StockCost[thePer] < 0.0)
            myMsgFac () (
               "negPartObj1CostCoef",
               "obj1StockCost",
               partName,
               obj1StockCost[thePer],
               thePer);

      theCall.myMaterial ()->setObj1StockCost (obj1StockCost);
      }
@


1.36
log
@Internal changes.
@
text
@d106 1
a106 1
      (recursionDepth == 1 && wit34Compatible ())?
d252 1
a252 1
      if (! (parti->focShortageVol () == 0.0))
d261 1
a261 1
      if (! (parti->focShortageVol () == 0.0))
d479 1
a479 1
   if (consIndex < 0 ||
d511 1
a511 1
   if (consIndex < 0 ||
d975 1
a975 1
   if (prodIndex < 0 ||
@


1.35
log
@Continued implementation of single-source by the new algorithm.
@
text
@d312 1
a312 1
      WitBoolean * baSelSplit)
d409 1
a409 1
      WitBoolean * buildAsap)
d424 1
a424 1
      WitBoolean * buildNstn)
d605 1
a605 1
      WitBoolean * exist)
d613 1
a613 1
      * exist = witFALSE;
d619 1
a619 1
      * exist = witTRUE;
d1060 1
a1060 1
      WitBoolean * selForDel)
d1090 1
a1090 1
      WitBoolean * singleSource)
d1199 1
a1199 1
      WitBoolean   baSelSplit)
d1205 1
a1205 1
   theCall.prepBoolean (    
d1265 1
a1265 1
      WitBoolean   buildAsap)
d1287 1
a1287 1
      WitBoolean   buildNstn)
d1485 1
a1485 1
      WitBoolean   selForDel)
d1499 1
a1499 1
      const char * partName, WitBoolean singleSource)
d1505 1
a1505 1
   theCall.prepBoolean (    
@


1.34
log
@modications to change rogueWave tools.h++ to STL
@
text
@a250 1
   // end 
@


1.33
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d251 1
@


1.33.2.1
log
@Migration from Roguewave tools.h++ to STL
@
text
@a250 1
   // end 
@


1.32
log
@Began implementation of optimizing implosion with OSL V3.
@
text
@d32 1
@


1.31
log
@More minor changes for vacpp.

The compiler complains if member functions are passed without an ampersand:

1589c1589
<          WitRun::witSetOperationYield,
---
>          &WitRun::witSetOperationYield,

It complains if "friend" declarations don't also have the word "class":
diff -r1.1 MsgFrag.h
39,40c39,40
<       friend WitMsgArg;
<       friend WitMsgFacility;
---
>       friend class WitMsgArg;
>       friend class WitMsgFacility;

It now can't figure out that a statement after a loop may not be executed!
diff -r1.70 BuildAhd.C
575a576
>    return NULL; // unreachable, but compiler complains


It also complained about missing "template<>" in many cases,
but since this seems odd, we are just suppressing the message for now
(see config/p_power64v5).  This is an example of a change that was NOT
made, but (presumably) would have to be to avoid the compiler warning.
diff -r1.47 ConsMR.C
180a181
> template<>
@
text
@d658 1
a658 1
         &WitRun::witGetOperationIncLotSize,
d675 1
a675 1
         &WitRun::witGetOperationMinLotSize,
d728 1
a728 1
         &WitRun::witGetOperationMrpExecVol,
d903 1
a903 1
         &WitRun::witGetOperationObj1ExecCost,
d922 1
a922 1
         &WitRun::witGetOperationExecBounds,
d946 1
a946 1
            &WitRun::witGetOperationExecVol,
d1175 1
a1175 1
         &WitRun::witGetOperationYield,
d1340 1
a1340 1
         &WitRun::witSetOperationIncLotSize,
d1357 1
a1357 1
         &WitRun::witSetOperationMinLotSize,
d1374 1
a1374 1
         &WitRun::witSetOperationObj1ExecCost,
d1423 1
a1423 1
         &WitRun::witSetOperationExecBounds,
d1446 1
a1446 1
         &WitRun::witSetOperationExecVol,
d1589 1
a1589 1
         &WitRun::witSetOperationYield,
@


1.30
log
@Continued implementation of single-source.
@
text
@d658 1
a658 1
         WitRun::witGetOperationIncLotSize,
d675 1
a675 1
         WitRun::witGetOperationMinLotSize,
d728 1
a728 1
         WitRun::witGetOperationMrpExecVol,
d903 1
a903 1
         WitRun::witGetOperationObj1ExecCost,
d922 1
a922 1
         WitRun::witGetOperationExecBounds,
d946 1
a946 1
            WitRun::witGetOperationExecVol,
d1175 1
a1175 1
         WitRun::witGetOperationYield,
d1340 1
a1340 1
         WitRun::witSetOperationIncLotSize,
d1357 1
a1357 1
         WitRun::witSetOperationMinLotSize,
d1374 1
a1374 1
         WitRun::witSetOperationObj1ExecCost,
d1423 1
a1423 1
         WitRun::witSetOperationExecBounds,
d1446 1
a1446 1
         WitRun::witSetOperationExecVol,
d1589 1
a1589 1
         WitRun::witSetOperationYield,
@


1.29
log
@Continued implementation of Single-Source.
@
text
@a1503 4
   if (! myGlobalComp ()->allowSglSrc ())
      myMsgFac () ("genericSmsg",
         "The Single-Source technique is not yet available.");

@


1.28
log
@Continued implementation of single-source.
@
text
@a18 1
#include <DelCompItr.h>
@


1.27
log
@Continued implementation of Single-Source.
@
text
@d31 1
d772 1
a772 1
            myMsgFac ()[partP->categoryFragID ()]);
@


1.26
log
@Continued implementation of single-source.
@
text
@d1506 1
a1506 2
         "Single-source is not allowed unless the allowSglSrc control "
         "parameter is TRUE.");
@


1.25
log
@Continued implementation of single-source.
@
text
@d1506 1
a1506 1
         "Single-source is not allowed, unless the allowSglSrc control "
@


1.24
log
@Preliminary work on single source.
@
text
@d27 1
d1019 23
d1057 15
d1087 15
a1148 38
WitReturnCode WitRun::witGetParts(
      int  *     lenPartList,
      char * * * partList)
   {
   PROLOG ("witGetParts");

   WitPart * partj;
   int       i;

   i = 0;

   * lenPartList = myCompMgr ()->nParts ();

   apiAlloc (* partList, * lenPartList);

   forEachPart (partj, myProblem ())
      (* partList)[i++] = dupCstring (partj->partName ());

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witGetPartSelForDel (
      const char * partName,
      WitBoolean * selForDel)
   {
   PROLOG ("witGetPartSelForDel");

   WitPartApiCall theCall (this, partName);

   apiGet (selForDel, "selForDel", theCall.myPart ()->selForDel ());

   EPILOG;
   }

//------------------------------------------------------------------------------

d1482 40
a1557 15

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witSetPartSelForDel (
      const char * partName,
      WitBoolean   selForDel)
   {
   PROLOG ("witSetPartSelForDel");

   WitPartApiCall theCall (this, partName);

   theCall.setSelForDel (selForDel);
@


1.23
log
@Continued preliminary work on single source.
@
text
@d1235 1
a1235 1
   tempIntVecRef.setTo (buildAheadLimit);
@


1.22
log
@More preliminary work on single source.
@
text
@d1225 1
a1225 1
   WitTVec (int) & tempIntVecRef = myApiMgr ()->reserveTempIntVec ();
d1235 1
a1235 1
   tempIntVecRef = buildAheadLimit;
@


1.21
log
@Continued implementation of object iteration.
@
text
@d342 1
a342 1
   const WitDenseList (WitPart) & belowListRef = 
@


1.20
log
@Continued implementation of object iteration.
@
text
@d276 1
a276 1
WitReturnCode WitRun::witGetItrPart (char * * partName)
d280 1
a280 1
   PROLOG ("witGetItrPart");
@


1.19
log
@Continued implementation of object iteration.
@
text
@d28 1
d270 17
@


1.18
log
@Began implementation of object iteration.
@
text
@d19 1
d1848 1
a1848 1
   theMat = thePart->myMat ();
@


1.17
log
@Continued development of Selective Stock Reallocation.
@
text
@d11 1
a11 1
// Source file: "partApi.c"
d18 1
d20 7
a26 1
#include <ApiCall.h>
d28 1
@


1.16
log
@Continued implementation of selective stock reallocation.
@
text
@d1839 3
a1841 1
   if (! thePart->getMyMaterial (theMat))
@


1.15
log
@Refactoring for constrained stock reallocation.
@
text
@d1839 1
a1839 1
   if (! thePart->isaMaterial (theMat))
@


1.14
log
@Added shadowPrice and compPrices attributes.
@
text
@d274 1
a274 1
   apiGet (appData, "appData", theCall ()->appData ());
d289 1
a289 1
   apiGet (baSelSplit, "baSelSplit", theCall ()->baSelSplit ());
d315 2
a316 1
   const WitDenseList (WitPart) & belowListRef = theCall ()->belowList ();
d340 3
a342 1
   apiGet (buildAheadUB, "buildAheadUB", theCall ()->buildAheadUB ());
d386 1
a386 1
   apiGet (buildAsap, "buildAsap", theCall ()->buildAsap ());
d401 1
a401 1
   apiGet (buildNstn, "buildNstn", theCall ()->buildNstn ());
d416 1
a416 1
   apiGet (category, "category", theCall ()->apiCategory ());
d431 1
a431 1
   apiGet (consVol, "consVol", theCall ()->consVol ());
d451 1
a451 1
       consIndex >= theCall ()->consumingBomEntries ().nElements ())
d455 1
a455 1
         theCall ()->consumingBomEntries ().nElements ());
d457 1
a457 1
   theBomEnt = theCall ()->consumingBomEntries ().at (consIndex);
d483 1
a483 1
       consIndex >= theCall ()->consumingSubEntries ().nElements ())
d487 1
a487 1
         theCall ()->consumingSubEntries ().nElements ());
d489 1
a489 1
   theSub = theCall ()->consumingSubEntries ().at (consIndex);
d541 1
a541 1
      theCall ()->myDemands ().nElements ());
d547 1
a547 1
   forEachEl (theDemand, theCall ()->myDemands ())
d564 1
a564 1
   apiGet (excessVol, "excessVol", theCall ()->residualVol ());
d567 1
a567 1
      setToMin ((* excessVol)[thePer], theCall ()->supplyVol ()[thePer]);
d610 3
a612 1
   apiGet (focusShortageVol, "focusShortageVol", theCall ()->focShortageVol ());
d661 1
a661 1
   apiGet (mrpConsVol, "mrpConsVol", theCall ()->mrpConsVol ());
d677 1
a677 1
   apiGet (mrpExcessVol, "mrpExcessVol", theCall ()->mrpResidualVol ());
d680 3
a682 1
      setToMin ((* mrpExcessVol)[thePer], theCall ()->supplyVol ()[thePer]);
d714 3
a716 1
   apiGet (mrpResidualVol, "mrpResidualVol", theCall ()->mrpResidualVol ());
d785 1
a785 1
      theCall ()->consumingBomEntries ().nElements ());
d803 1
a803 1
      theCall ()->consumingSubEntries ().nElements ());
d821 1
a821 1
      theCall ()->producingBopEntries ().nElements ());
d839 1
a839 1
      theCall ()->obj1ScrapCost ());
d857 1
a857 1
      theCall ()->obj1StockCost ());
d926 1
a926 1
      apiGet (prodVol, "prodVol", theCall ()->prodVol ());
d947 1
a947 1
       prodIndex >= theCall ()->producingBopEntries ().nElements ())
d951 1
a951 1
         theCall ()->producingBopEntries ().nElements ());
d953 1
a953 1
   theBopEnt = theCall ()->producingBopEntries ().at (prodIndex);
d969 1
a969 1
   apiGet (reqVol, "reqVol", theCall ()->reqVol ());
d984 1
a984 1
   apiGet (residualVol, "residualVol", theCall ()->residualVol ());
d999 1
a999 1
   apiGet (scrapVol, "scrapVol", theCall ()->scrapVol ());
d1014 1
a1014 1
   apiGet (shadowPrice, "shadowPrice", theCall ()->shadowPrice ());
d1031 1
a1031 1
   apiGet (hardLB, softLB, hardUB, theCall ()->stockBounds ());
d1046 1
a1046 1
   apiGet (stockVol, "stockVol", theCall ()->stockVol ());
d1061 1
a1061 1
   apiGet (supplyVol, "supplyVol", theCall ()->supplyVol ());
d1099 1
a1099 1
   apiGet (selForDel, "selForDel", theCall ()->selForDel ());
d1114 1
a1114 1
   apiGet (unitCost, "unitCost", theCall ()->unitCost ());
d1161 4
a1164 1
   theCall.prepBoolean ("baSelSplit", theCall ()->baSelSplit (), baSelSplit);
d1167 1
a1167 1
      theCall ()->setBaSelSplit (baSelSplit);
d1185 1
a1185 1
      theCall ()->setBuildAheadUB (buildAheadUB);
d1229 1
a1229 1
      theCall ()->buildAsap (), 
d1234 1
a1234 1
      theCall ()->setBuildAsap (buildAsap);
d1251 1
a1251 1
      theCall ()->buildNstn (), 
d1256 1
a1256 1
      theCall ()->setBuildNstn (buildNstn);
d1359 1
a1359 1
      theCall ()->setObj1ScrapCost (obj1ScrapCost);
d1431 1
a1431 1
      theCall ()->setObj1StockCost (obj1StockCost);
d1449 5
a1453 1
   theCall.prepBoundSet (theCall ()->stockBounds (), hardLB, softLB, hardUB);
d1456 1
a1456 1
      theCall ()->stockBounds ()->set (hardLB, softLB, hardUB);
d1474 1
a1474 1
      theCall ()->setSupplyVol (supplyVol);
d1502 4
a1505 1
   theCall.prepNonNegFloat ("unitCost", theCall ()->unitCost (), unitCost);
d1508 1
a1508 1
      theCall ()->setUnitCost (unitCost);
@


1.13
log
@Initial implementation of pegging.
@
text
@d997 15
@


1.12
log
@Continued development of selection splitting for multi=exec.
@
text
@d523 1
a523 1
WitReturnCode WitRun::witGetPartDemands(
d535 4
a538 1
   * lenDemandList = theCall ()->myDemands ().nElements ();
@


1.11
log
@Removed allowSS development parameter.
@
text
@d489 1
a489 1
   * bomEntryIndex          = theSub->myBomEntryIndex ();
@


1.10
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a1135 3
   if (! myGlobalComp ()->allowSS ())
      myMsgFac () ("ssAttrNotAllowedSmsg");

@


1.9
log
@Re-worked the controls for selection splitting.
@
text
@d27 1
a27 1
// Initilization of witSetPart* functions.
d281 15
d1120 21
@


1.8
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@a1110 15
WitReturnCode WitRun::witSetPartBaSplitRes (
      const char * partName,
      float        baSplitRes)
   {
   PROLOG ("witSetPartBaSplitRes");

   WitMaterialApiCall theCall (this, partName, "baSplitRes");

   theCall.setBaSplitRes (baSplitRes);

   EPILOG;
   }

//------------------------------------------------------------------------------

@


1.7
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d51 3
a53 1
WitMaterial * WitRun::setGetMaterialInit (const char * partName)
d55 2
d322 1
a322 1
   WitMaterialApiCall theCall (this, partName);
d366 1
a366 1
   WitMaterialApiCall theCall (this, partName);
d381 1
a381 1
   WitMaterialApiCall theCall (this, partName);
d825 1
a825 1
   WitMaterialApiCall theCall (this, partName);
d987 1
a987 1
   WitMaterialApiCall theCall (this, partName);
d1002 1
a1002 1
   WitMaterialApiCall theCall (this, partName);
d1117 1
a1117 1
   WitMaterialApiCall theCall (this, partName);
d1132 1
a1132 1
   WitMaterialApiCall theCall (this, partName);
d1177 1
a1177 1
   WitMaterialApiCall theCall (this, partName);
d1199 1
a1199 1
   WitMaterialApiCall theCall (this, partName);
d1367 1
a1367 1
   WitMaterialApiCall theCall (this, partName);
d1399 1
a1399 1
   WitMaterialApiCall theCall (this, partName);
@


1.6
log
@Some minor changes.
@
text
@d1107 15
@


1.5
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d20 1
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d1130 1
a1130 1
   WitTVec (int) & tempVecRef = myApiMgr ()->useTempVec ();
d1140 1
a1140 1
   tempVecRef = buildAheadLimit;
d1142 1
a1142 1
   witSetPartBuildAheadUB (partName, tempVecRef.myCvector ());
d1144 1
a1144 1
   myApiMgr ()->releaseTempVec ();
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d348 1
a348 1
   WitUtil::portableFree (buildAheadUBval);
d541 1
a541 3
      WitUtil::setToMin (
         (* excessVol)[thePer], 
         theCall ()->supplyVol ()[thePer]);
d652 1
a652 3
      WitUtil::setToMin (
         (* mrpExcessVol)[thePer], 
         theCall ()->supplyVol ()[thePer]);
d1497 1
a1497 1
   if (WitUtil::isNullString (partName))
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d541 1
a541 1
      WitUtil::updateToMin (
d654 1
a654 1
      WitUtil::updateToMin (
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.70;
access;
symbols
	sce_5_01_20080919:1.66
	latest_sce_4_20_20060523:1.41.0.2
	sce_4_20_20060523:1.41
	latest_sce4_20_OSL:1.40.0.2
	sce_4_20_OSL:1.40
	sce_410_withVa:1.38
	sce_4_05_20040511:1.35
	sce_4_00_20040201:1.30
	nextGenBranch:1.30.0.2
	nextGenRoot:1.30
	sce_3_30_20030627:1.30
	EndRw-branch:1.26.0.4
	Root-of-EndRw:1.26
	rwToStl:1.26.0.2
	latest_sce_3_10_20010924:1.11.0.2
	sce_3_10_20010924:1.11
	latest_sce_3_00_20010601:1.8.0.2
	sce_3_00_20010601:1.8
	latest_sce_2_31_20010308:1.7.0.2
	sce_2_31_20010308:1.7
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.70
date	2011.09.28.23.49.59;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2011.09.24.00.28.22;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2011.08.30.20.17.59;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2011.01.06.00.08.24;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.15.17.15.35;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.30.21.44.18;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.08.03.22.04.10;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.08.18.26.10;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.05.21.06.01;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.05.18.48.32;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.05.16.15.24;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.04.21.40.00;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.04.19.34.01;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.04.19.05.56;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.01.22.25.07;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.30.22.05.51;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.30.21.02.11;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.30.16.01.20;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.03.08.17.02.55;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.05.21.32.10;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.27.22.59.30;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.27.21.03.05;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.27.19.59.33;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.13.23.40.13;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.10.00.08.15;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.08.22.47.36;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.08.00.14.26;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.07.22.14.54;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.07.19.55.37;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.02.17.34.09;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.01.19.23.25;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.30.21.57.57;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.04.00.02.47;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.09.14.20.02.34;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.07.15.18.26;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.24.22.21.33;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.23.19.14.25;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.22.16.37.19;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.05.22.19.58;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.16.20.19.10;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.16.16.34.32;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.15.21.01.23;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.02.22.18.44;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.30.21.36.39;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.23.18.09.16;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.22.22.42.22;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.22.21.16.22;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.06.18.53.41;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.04.23.07.23;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.03.16.01.52;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.30.20.09.01;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.08.19.21.55;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.07.20.15.02;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.03.23.16.41;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.03.19.58.30;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.02.20.53.15;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.01.14.26.00;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.18.14.02.41;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.17.22.00.11;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.06.23.36.02;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.21.18.24.33;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.25.14.53.26;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.20.20.08.36;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.06.19.58.40;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.23.11.46;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.12.35;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.21.22.46;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.47;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef PreH
#define PreH

//------------------------------------------------------------------------------
// Header file: "Pre.h"
//
// Contains the declaration of class Preprocessor.
//------------------------------------------------------------------------------

#include <Assoc.h>

class WitNodeSorter;
class WitOffsetProc;
class WitBelowLister;

//------------------------------------------------------------------------------
// Class Preprocessor
//
// Responsible for performing preprocessing.
//------------------------------------------------------------------------------

class WitPreprocessor: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPreprocessor (WitProblem *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitPreprocessor ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool, preprocessing)
      accessFunc (bool, preprocessed)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void preprocess ();
         //
         // Performs preprocessing for myProblem ().

      void getExpCycle (
            WitObjStack <WitPart> &      theParts,
            WitObjStack <WitOperation> & theOpns);
         //
         // If the Problem contains at least one explodeable cycle, this
         // function retrieves one of them;
         // If not, this function empties the argument Stacks.

      void unpreprocess ();
         //
         // Does unpreprocessing for myProblem ().

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPreprocessor);

      void setUp ();
         //
         // Sets up preprocessing.

      void shutDown ();
         //
         // Shuts down preprocessing.

      void checkMaxNameLength ();
         //
         // Issues a warning is the is a name longer than the nominal limit.

      void updateLongestName (
            const WitString & theName,
            int &             maxNameLength,
            WitString &       theLongestName);
         //
         // Updates maxNameLength and theLongestName to account for theName.

      void validateBLA ();
         //
         // Verifies data for Demands with shipLateAllowed_ == false.
                                                     
      void procLotSizes ();
         //
         // Processes lot size data.

      void compHasSubsInEffect ();
         //
         // Computes hasSubsInEffect_ for all BomEntries.

      void compEffConsRates ();
         //
         // Computes effConsRates.

      void compEffConsRate (
            WitConsEntry *     theConsEnt,
            WitTVec <double> & effConsRateVec);
         //
         // Computes theConsEnt->effConsRate_.
         // Uses effConsRateVec as a working vector.

      void checkMinLotSize (WitBomEntry * theBomEnt);
         //
         // If theBomEnt->myPart () is a capacity, this function issues a
         // warning if the minLotSize of theBomEnt->myOperation () consumes
         // more than supplyVol of theBomEnt->myPart ().

      void compEffProdRates ();
         //
         // Computes effProdRate_ for each BopEntry.

      void chooseExpExecPeriods ();
         //
         // Computes expExecPeriod_ for each BopEntry.

      void checkSmallEffProdRates ();
         //
         // Finds the smallest effProdRate of an explodeable BopEntry, and if
         // it is below the default explosion cutoff, issues a warning.

      void sortSubEntries ();
         //
         // Sorts the SubEntries of each BomEntry in order of non-decreasing
         // expNetAversion.

      void sortBopEntries ();
         //
         // For each Part, thePart, sorts thePart->producingBopEntries in order
         // of non-decreasing expAversion.

      void chooseExpBopEntries ();
         //
         // Sets thePart->expBopEntry () for all Parts.

      void findExpPerGaps ();
         //
         // Sets thePart->expPerGaps () for all Parts.

      void findMandECs ();
         //
         // Determines mandEC for each Material in myProblem ().

      void setDirectMandECs (WitBomEntry * theBomEnt);
         //
         // Sets mandatory ECs directly from theBomEnt.

      void propMandECs (WitConsEntry * theConsEnt);
         //
         // Propagates the mandatory ECs from theConsEnt->myPart () to the bop
         // of theConsEnt->myOperation ().

      void setMandECs (WitOperation * theOpn, WitPeriod thePer);
         //
         // For each Material in the bop of theOpn, sets mandEC_
         // corresponding to a mandatory EC on theOpn in period t.

      accessNonNull (WitNodeSorter *,  myNodeSorter)
      accessNonNull (WitOffsetProc *,  myOffsetProc)
      accessNonNull (WitBelowLister *, myBelowLister)

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      bool preprocessing_;
         //
         // true, iff preprocessing is currently being performed.

      bool preprocessed_;
         //
         // true iff myProblem () is in a preprocessed state.

      WitNodeSorter * myNodeSorter_;
         //
         // The NodeSorter owned by this Preprocessor during processing;
         // otherwise NULL.

      WitOffsetProc * myOffsetProc_;
         //
         // The OffsetProc owned by this Preprocessor during processing;
         // otherwise NULL.

      WitBelowLister * myBelowLister_;
         //
         // The BelowLister owned by this Preprocessor during processing;
         // otherwise NULL.
   };

#endif
@


1.69
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.68
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d32 2
a33 2
{
public:
d35 175
a209 175
//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitPreprocessor (WitProblem *);

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitPreprocessor ();

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (bool, preprocessing)
accessFunc (bool, preprocessed)

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void preprocess ();
//
// Performs preprocessing for myProblem ().

void getExpCycle (
WitObjStack <WitPart> &      theParts,
WitObjStack <WitOperation> & theOpns);
//
// If the Problem contains at least one explodeable cycle, this
// function retrieves one of them;
// If not, this function empties the argument Stacks.

void unpreprocess ();
//
// Does unpreprocessing for myProblem ().

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitPreprocessor);

void setUp ();
//
// Sets up preprocessing.

void shutDown ();
//
// Shuts down preprocessing.

void checkMaxNameLength ();
//
// Issues a warning is the is a name longer than the nominal limit.

void updateLongestName (
const WitString & theName,
int &             maxNameLength,
WitString &       theLongestName);
//
// Updates maxNameLength and theLongestName to account for theName.

void validateBLA ();
//
// Verifies data for Demands with shipLateAllowed_ == false.

void procLotSizes ();
//
// Processes lot size data.

void compHasSubsInEffect ();
//
// Computes hasSubsInEffect_ for all BomEntries.

void compEffConsRates ();
//
// Computes effConsRates.

void compEffConsRate (
WitConsEntry *     theConsEnt,
WitTVec <double> & effConsRateVec);
//
// Computes theConsEnt->effConsRate_.
// Uses effConsRateVec as a working vector.

void checkMinLotSize (WitBomEntry * theBomEnt);
//
// If theBomEnt->myPart () is a capacity, this function issues a
// warning if the minLotSize of theBomEnt->myOperation () consumes
// more than supplyVol of theBomEnt->myPart ().

void compEffProdRates ();
//
// Computes effProdRate_ for each BopEntry.

void chooseExpExecPeriods ();
//
// Computes expExecPeriod_ for each BopEntry.

void checkSmallEffProdRates ();
//
// Finds the smallest effProdRate of an explodeable BopEntry, and if
// it is below the default explosion cutoff, issues a warning.

void sortSubEntries ();
//
// Sorts the SubEntries of each BomEntry in order of non-decreasing
// expNetAversion.

void sortBopEntries ();
//
// For each Part, thePart, sorts thePart->producingBopEntries in order
// of non-decreasing expAversion.

void chooseExpBopEntries ();
//
// Sets thePart->expBopEntry () for all Parts.

void findExpPerGaps ();
//
// Sets thePart->expPerGaps () for all Parts.

void findMandECs ();
//
// Determines mandEC for each Material in myProblem ().

void setDirectMandECs (WitBomEntry * theBomEnt);
//
// Sets mandatory ECs directly from theBomEnt.

void propMandECs (WitConsEntry * theConsEnt);
//
// Propagates the mandatory ECs from theConsEnt->myPart () to the bop
// of theConsEnt->myOperation ().

void setMandECs (WitOperation * theOpn, WitPeriod thePer);
//
// For each Material in the bop of theOpn, sets mandEC_
// corresponding to a mandatory EC on theOpn in period t.

accessNonNull (WitNodeSorter *,  myNodeSorter)
accessNonNull (WitOffsetProc *,  myOffsetProc)
accessNonNull (WitBelowLister *, myBelowLister)

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

bool preprocessing_;
//
// true, iff preprocessing is currently being performed.

bool preprocessed_;
//
// true iff myProblem () is in a preprocessed state.

WitNodeSorter * myNodeSorter_;
//
// The NodeSorter owned by this Preprocessor during processing;
// otherwise NULL.

WitOffsetProc * myOffsetProc_;
//
// The OffsetProc owned by this Preprocessor during processing;
// otherwise NULL.

WitBelowLister * myBelowLister_;
//
// The BelowLister owned by this Preprocessor during processing;
// otherwise NULL.
};
@


1.67
log
@Allowed intExecVols, etc. with mipMode == false.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d32 2
a33 2
   {
   public:
d35 175
a209 175
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPreprocessor (WitProblem *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitPreprocessor ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool, preprocessing)
      accessFunc (bool, preprocessed)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void preprocess ();
         //
         // Performs preprocessing for myProblem ().

      void getExpCycle (
            WitObjStack <WitPart> &      theParts,
            WitObjStack <WitOperation> & theOpns);
         //
         // If the Problem contains at least one explodeable cycle, this
         // function retrieves one of them;
         // If not, this function empties the argument Stacks.

      void unpreprocess ();
         //
         // Does unpreprocessing for myProblem ().

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPreprocessor);

      void setUp ();
         //
         // Sets up preprocessing.

      void shutDown ();
         //
         // Shuts down preprocessing.

      void checkMaxNameLength ();
         //
         // Issues a warning is the is a name longer than the nominal limit.

      void updateLongestName (
            const WitString & theName,
            int &             maxNameLength,
            WitString &       theLongestName);
         //
         // Updates maxNameLength and theLongestName to account for theName.

      void validateBLA ();
         //
         // Verifies data for Demands with shipLateAllowed_ == false.
                                                     
      void procLotSizes ();
         //
         // Processes lot size data.

      void compHasSubsInEffect ();
         //
         // Computes hasSubsInEffect_ for all BomEntries.

      void compEffConsRates ();
         //
         // Computes effConsRates.

      void compEffConsRate (
            WitConsEntry *     theConsEnt,
            WitTVec <double> & effConsRateVec);
         //
         // Computes theConsEnt->effConsRate_.
         // Uses effConsRateVec as a working vector.

      void checkMinLotSize (WitBomEntry * theBomEnt);
         //
         // If theBomEnt->myPart () is a capacity, this function issues a
         // warning if the minLotSize of theBomEnt->myOperation () consumes
         // more than supplyVol of theBomEnt->myPart ().

      void compEffProdRates ();
         //
         // Computes effProdRate_ for each BopEntry.

      void chooseExpExecPeriods ();
         //
         // Computes expExecPeriod_ for each BopEntry.

      void checkSmallEffProdRates ();
         //
         // Finds the smallest effProdRate of an explodeable BopEntry, and if
         // it is below the default explosion cutoff, issues a warning.

      void sortSubEntries ();
         //
         // Sorts the SubEntries of each BomEntry in order of non-decreasing
         // expNetAversion.

      void sortBopEntries ();
         //
         // For each Part, thePart, sorts thePart->producingBopEntries in order
         // of non-decreasing expAversion.

      void chooseExpBopEntries ();
         //
         // Sets thePart->expBopEntry () for all Parts.

      void findExpPerGaps ();
         //
         // Sets thePart->expPerGaps () for all Parts.

      void findMandECs ();
         //
         // Determines mandEC for each Material in myProblem ().

      void setDirectMandECs (WitBomEntry * theBomEnt);
         //
         // Sets mandatory ECs directly from theBomEnt.

      void propMandECs (WitConsEntry * theConsEnt);
         //
         // Propagates the mandatory ECs from theConsEnt->myPart () to the bop
         // of theConsEnt->myOperation ().

      void setMandECs (WitOperation * theOpn, WitPeriod thePer);
         //
         // For each Material in the bop of theOpn, sets mandEC_
         // corresponding to a mandatory EC on theOpn in period t.

      accessNonNull (WitNodeSorter *,  myNodeSorter)
      accessNonNull (WitOffsetProc *,  myOffsetProc)
      accessNonNull (WitBelowLister *, myBelowLister)

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      bool preprocessing_;
         //
         // true, iff preprocessing is currently being performed.

      bool preprocessed_;
         //
         // true iff myProblem () is in a preprocessed state.

      WitNodeSorter * myNodeSorter_;
         //
         // The NodeSorter owned by this Preprocessor during processing;
         // otherwise NULL.

      WitOffsetProc * myOffsetProc_;
         //
         // The OffsetProc owned by this Preprocessor during processing;
         // otherwise NULL.

      WitBelowLister * myBelowLister_;
         //
         // The BelowLister owned by this Preprocessor during processing;
         // otherwise NULL.
   };
@


1.66
log
@Stochastic Implosion
@
text
@a73 5
      void verifyNoIntCons ();
         //
         // Verifies that no integrality constraints have been specified.
         // (Non-MIP mode)

@


1.65
log
@witGetExpCycle
@
text
@a19 2
#include <Ref.h>
#include <RefMap.h>
d51 1
a78 41
      //------------------------------------------------------------------------
      // Reference receiving functions.
      // Each of these functions stores its reference arguments on the
      // assumption that they refer to the similarly named data members of the
      // first argument.
      //------------------------------------------------------------------------

      void receiveRefs (WitCompMgr *,
                        WitList <WitPart>        & allPartsRef,
                        WitList <WitOperation>   & allOperationsRef);

      void receiveRefs (WitGlobalComp *,
                        bool                     & lotSizesExistRef);

      void receiveRefs (WitPart *,
                        bool                     & expPerGapsRef,
                        WitList <WitBopEntry>    & producingBopEntriesRef,
                        WitPtrTVec <WitBopEntry> & expBopEntryRef,
                        int                      & sortedPartIndexRef,
                        WitPtrVec <WitPart>      & belowListRef);

      void receiveRefs (WitMaterial *,
                        WitFlexVec <bool>        & mandECRef);

      void receiveRefs (WitOperation *,
                        WitTVec <bool>           & executableRef);

      void receiveRefs (WitBillEntry *,
                        WitTVec <WitPeriod>      & impactPeriodRef);

      void receiveRefs (WitConsEntry *,
                        WitDblFlexVec            & effConsRateRef);

      void receiveRefs (WitBomEntry *,
                        WitFlexVec <bool>        & hasSubsInEffectRef,
                        WitList <WitSubEntry>    & mySubEntriesRef);

      void receiveRefs (WitBopEntry *,
                        WitDblFlexVec            & effProdRateRef,
                        WitTVec <WitPeriod>      & expExecPeriodRef);

a90 4
      void acquireRefs ();
         //
         // Acquires references to all preprocessing data.

d118 1
a118 1
      void compEffConsRate (WitConsEntry * theConsEnt);
d120 8
a127 1
         // Computes effConsRate (theConsEnt).
d135 1
a135 1
      void compEffProdRate (WitBopEntry * theBopEnt);
d137 1
a137 1
         // Computes theBopEnt->effProdRate_.
d139 1
a139 1
      void chooseExpExecPeriods (WitBopEntry * theBopEnt);
d141 1
a141 1
         // Sets theBopEnt->expExecPeriod_.
d192 4
a213 15

      //------------------------------------------------------------------------
      // Reference holders to the data to be computed by this Preprocessor.
      //------------------------------------------------------------------------

      WitRef                  <bool>                      lotSizesExist_;
      WitRefMap <WitPart,      bool                     > expPerGaps_;
      WitRefMap <WitPart,      WitList <WitBopEntry>    > producingBopEntries_;
      WitRefMap <WitPart,      WitPtrTVec <WitBopEntry> > expBopEntry_;
      WitRefMap <WitMaterial,  WitFlexVec <bool>        > mandEC_;
      WitRefMap <WitConsEntry, WitDblFlexVec            > effConsRate_;
      WitRefMap <WitBomEntry,  WitFlexVec <bool>        > hasSubsInEffect_;
      WitRefMap <WitBomEntry,  WitList <WitSubEntry>    > mySubEntries_;
      WitRefMap <WitBopEntry,  WitDblFlexVec            > effProdRate_;
      WitRefMap <WitBopEntry,  WitTVec <WitPeriod>      > expExecPeriod_;
@


1.64
log
@Stochastic Implosion
@
text
@d63 8
@


1.63
log
@Stochastic Implosion
@
text
@d67 5
@


1.62
log
@Stochastic Implosion
@
text
@d75 2
a76 2
                        WitList <WitPart>        & allPartsArg,
                        WitList <WitOperation>   & allOperationsArg);
d79 1
a79 1
                        bool                     & lotSizesExistArg);
d82 5
a86 5
                        bool                     & expPerGapsArg,
                        WitList <WitBopEntry>    & producingBopEntriesArg,
                        WitPtrTVec <WitBopEntry> & expBopEntryArg,
                        int                      & sortedPartIndexArg,
                        WitPtrVec <WitPart>      & belowListArg);
d89 1
a89 1
                        WitFlexVec <bool>        & mandECArg);
d92 1
a92 1
                        WitTVec <bool>           & executableArg);
d95 1
a95 1
                        WitTVec <WitPeriod>      & impactPeriodArg);
d98 1
a98 1
                        WitDblFlexVec            & effConsRateArg);
d101 2
a102 2
                        WitFlexVec <bool>        & hasSubsInEffectArg,
                        WitList <WitSubEntry>    & mySubEntriesArg);
d105 2
a106 2
                        WitDblFlexVec            & effProdRateArg,
                        WitTVec <WitPeriod>      & expExecPeriodArg);
@


1.61
log
@Stochastic Implosion
@
text
@a54 2
      accessNonNull (const WitPreData *, expPreData)

a209 5
      void exportData ();
         //
         // Exports the working version of the preprocessing data to the owners
         // of the original preprocessing data.

a217 10
      WitPreData * myPreData_;
         //
         // The PreData owned by this Preprocessor during processing;
         // otherwise NULL.

      const WitPreData * expPreData_;
         //
         // The PreData owned by this Preprocessor during data export;
         // otherwise NULL.

@


1.60
log
@Stochastic Implosion
@
text
@d122 4
@


1.59
log
@Stochastic Implosion
@
text
@d69 41
d254 1
a254 2
      WitRef    <bool>                                    lotSizesExist_;

d256 3
a258 1

a259 3
      WitRefMap <WitBopEntry,  WitDblFlexVec            > effProdRate_;

      WitRefMap <WitMaterial,  WitFlexVec <bool>        > mandEC_;
a260 4

      WitRefMap <WitBopEntry,  WitFlexVec <WitPeriod>   > expExecPeriod_;

      WitRefMap <WitPart,      WitList <WitBopEntry>    > producingBopEntries_;
d262 2
a263 2

      WitRefMap <WitPart,      WitPtrTVec <WitBopEntry> > expBopEntry_;
@


1.58
log
@Stochastic Implosion
@
text
@d77 8
a95 9
      void sortNodesIfNeeded ();
         //
         // Does a topological sort of the Nodes of theProblem, unless they
         // are already in order.

      void roundOffsets ();
         //
         // Computes impact periods.

a166 4
      void buildBelow ();
         //
         // Builds the below list for each Part in myProblem ().

d172 4
d194 15
@


1.57
log
@Stochastic Implosion
@
text
@d213 2
@


1.56
log
@Stochastic Implosion
@
text
@d20 2
d194 19
@


1.55
log
@Stochastic Implosion
@
text
@a106 9
      void preprocess (WitBomEntry * theBomEnt);
         //
         // Performs some preprocessing operations on theBomEnt.
         // Currently, this includes:
         //    compImpactPeriod for each SubEntry.
         //    Computing hasSubsInEffect.
         //    Computing effConsRate for this BomEntry and its subEntries.
         //    Checking minLotSize.

a116 7
      void preprocess (WitBopEntry * theBopEnt);
         //
         // Performs some preprocessing operations on theBopEnt.
         // Currently, this includes:
         //    Computing effProdRate.
         //    Choosing  expExecPeriods.

@


1.54
log
@Stochastic Implosion
@
text
@a51 1
      accessFunc (bool, optPreprocessed)
a62 4
      void optPreprocess ();
         //
         // Performs preprocessing for myProblem () for an optimizing implosion.

a190 4
      void unoptPreprocess ();
         //
         // Undoes opt-preprocessing for myProblem ().

a207 4

      bool optPreprocessed_;
         //
         // true iff myProblem () is in an opt-preprocessed state.
@


1.53
log
@Stochastic Implosion
@
text
@a195 9
      void compExecPeriods ();
         //
         // Computes execPeriod_ and firstEPIndex_ for all BillEntries in
         // myProblem ().

      void compExecPeriod (WitBillEntry * theBillEnt);
         //
         // Computes theBillEnt->execPeriod_ and theBillEnt->firstEPIndex_.

a220 20

      bool execPeriodsComputed_;
         //
         // true, iff execPeriod has been computed for the BillEntries.

      WitTVec <int> tempNExecPeriods_;
         //
         // A temporary Vector used by compExecPeriod, for a BillEntry.
         // For any period, thePer, tempNExecPeriods[thePer] is the # of 
         // execution periods found whose impact period for the BillEntry is
         // thePer.

      WitPtrTVec <WitVector <WitPeriod> > & tempExecPeriod_;
         //
         // A temporary Vector used by compExecPeriod, for an BillEntry.
         // For any period, thePer, 
         //    for i = 0, ..., tempNExecPeriods[thePer] - 1,
         //       tempExecPeriod[thePer][[i] is a period, execPer (unique among
         //       tempExecPeriod[thePer]), such that 
         //       impactPeriod ()[execPer] == thePer.
@


1.52
log
@[disallowed backlog]
@
text
@d54 2
d91 9
d187 9
d213 1
a213 5
      WitNodeSorter * myNodeSorter_;
         //
         // The NodeSorter for this Preprocessor.

      WitOffsetProc * myOffsetProc_;
d215 2
a216 1
         // The OffsetProc for this Preprocessor.
d218 1
a218 1
      WitBelowLister * myBelowLister_;
d220 2
a221 1
         // The BelowLister for this Preprocessor.
@


1.51
log
@[disallowed backlog]
@
text
@d91 1
a91 1
         // Verifies data for Demands with backlogAllowed_ == false.
@


1.50
log
@[disallowed backlog]
@
text
@d89 4
@


1.49
log
@[disallowed backlog]
@
text
@a69 38
      //------------------------------------------------------------------------
      // Functions for receiving data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      //------------------------------------------------------------------------

      static void receiveDMPs (
         bool                     WitGlobalComp::* lotSizesExistArg);

      static void receiveDMPs (
         bool                           WitPart::* expPerGapsArg,
         WitList    <WitBopEntry>       WitPart::* producingBopEntriesArg,
         WitPtrTVec <WitBopEntry>       WitPart::* expBopEntryArg,
         int                            WitPart::* sortedPartIndexArg,
         WitPtrVec  <WitPart>           WitPart::* belowListArg);

      static void receiveDMPs (
         WitFlexVec <bool>          WitMaterial::* mandECArg);

      static void receiveDMPs (
         WitTVec <bool>      WitOperation::* executableArg);

      static void receiveDMPs (
         WitVector  <int>          WitBillEntry::* firstEPIndexArg,
         WitVector  <WitPeriod>    WitBillEntry::* execPeriodArg,
         WitTVec <WitPeriod>       WitBillEntry::* impactPeriodArg);

      static void receiveDMPs (
         WitDblFlexVec             WitConsEntry::* effConsRateArg);

      static void receiveDMPs (
         WitFlexVec <bool>          WitBomEntry::* hasSubsInEffectArg,
         WitList    <WitSubEntry>   WitBomEntry::* mySubEntriesArg);

      static void receiveDMPs (
         WitTVec    <WitPeriod>     WitBopEntry::* expExecPeriodArg,
         WitDblFlexVec              WitBopEntry::* effProdRateArg);

a188 24
      //------------------------------------------------------------------------
      // Data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      // E.g., theBopEnt->*effProdRate_ == theBopEnt->effProdRate_.
      //------------------------------------------------------------------------

      static bool                     WitGlobalComp::* lotSizesExist_;
      static bool                           WitPart::* expPerGaps_;
      static WitList    <WitBopEntry>       WitPart::* producingBopEntries_;
      static WitPtrTVec <WitBopEntry>       WitPart::* expBopEntry_;
      static WitFlexVec <bool>          WitMaterial::* mandEC_;
      static WitVector  <int>          WitBillEntry::* firstEPIndex_;
      static WitVector  <WitPeriod>    WitBillEntry::* execPeriod_;
      static WitDblFlexVec             WitConsEntry::* effConsRate_;
      static WitFlexVec <bool>          WitBomEntry::* hasSubsInEffect_;
      static WitList    <WitSubEntry>   WitBomEntry::* mySubEntries_;
      static WitTVec    <WitPeriod>     WitBopEntry::* expExecPeriod_;
      static WitDblFlexVec              WitBopEntry::* effProdRate_;

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

@


1.48
log
@Rescinded all changed made since 1/31/07.
@
text
@a107 4
      static void receiveDMPs (
         WitList <WitPart>      WitCompMgr::* allPartsArg,
         WitList <WitOperation> WitCompMgr::* allOperationsArg);

@


1.47
log
@[disallowed backlog]
@
text
@d77 25
a101 1
         WitFlexVec <bool>          WitBomEntry::*,
d105 4
d167 1
a167 1
         // Computes theBopEnt->effProdRatN_.
d171 1
a171 1
         // Sets theBopEnt->expExecPerioN_.
d178 10
d216 1
a216 1
         // Computes execPeriod_ and firstEPIndeN_ for all BillEntries in
d221 1
a221 1
         // Computes theBillEnt->execPeriod_ and theBillEnt->firstEPIndeN_.
d227 23
a249 3
      void unpreprocess (WitBillEntry * theBillEnt);
         //
         // Does unpreprocessing for theBillEnt.
d252 1
a252 1
      // Private member data.
@


1.46
log
@[disallowed backlog]
@
text
@a76 3
         bool                     WitGlobalComp::* lotSizesExistArg);

      static void receiveDMPs (
a196 13
      //------------------------------------------------------------------------
      // Data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      // E.g., theBopEnt->*effProdRate_ == theBopEnt->effProdRate_.
      //------------------------------------------------------------------------

      static bool WitGlobalComp::* lotSizesExist_;

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

@


1.45
log
@[disallowed backlog]
@
text
@d80 1
a80 1
         WitFlexVec <bool>          WitBomEntry::* hasSubsInEffectArg,
a83 4
         WitTVec    <WitPeriod>     WitBopEntry::* expExecPeriodArg,
         WitDblFlexVec              WitBopEntry::* effProdRateArg);

      static void receiveDMPs (
d142 1
a142 1
         // Computes theBopEnt->effProdRate_.
d146 1
a146 1
         // Sets theBopEnt->expExecPeriod_.
a152 5
      void sortSubEntries ();
         //
         // Sorts the SubEntries of each BomEntry in order of non-decreasing
         // expNetAversion.

d207 1
a207 5
      static bool                     WitGlobalComp::* lotSizesExist_;
      static WitFlexVec <bool>          WitBomEntry::* hasSubsInEffect_;
      static WitList    <WitSubEntry>   WitBomEntry::* mySubEntries_;
      static WitTVec    <WitPeriod>     WitBopEntry::* expExecPeriod_;
      static WitDblFlexVec              WitBopEntry::* effProdRate_;
@


1.44
log
@[disallowed backlog]
@
text
@a79 14
         WitFlexVec <bool>          WitMaterial::* mandECArg);

      static void receiveDMPs (
         WitTVec <bool>            WitOperation::* executableArg);

      static void receiveDMPs (
         WitVector  <int>          WitBillEntry::* firstEPIndexArg,
         WitVector  <WitPeriod>    WitBillEntry::* execPeriodArg,
         WitTVec <WitPeriod>       WitBillEntry::* impactPeriodArg);

      static void receiveDMPs (
         WitDblFlexVec             WitConsEntry::* effConsRateArg);

      static void receiveDMPs (
d190 1
a190 1
         // Computes execPeriod_ and firstEPIndex_ for all BillEntries in
d195 1
a195 1
         // Computes theBillEnt->execPeriod_ and theBillEnt->firstEPIndex_.
d201 4
a216 4
      static WitFlexVec <bool>          WitMaterial::* mandEC_;
      static WitVector  <int>          WitBillEntry::* firstEPIndex_;
      static WitVector  <WitPeriod>    WitBillEntry::* execPeriod_;
      static WitDblFlexVec             WitConsEntry::* effConsRate_;
@


1.43
log
@[disallowed backlog]
@
text
@a79 7
         bool                           WitPart::*,
         WitList    <WitBopEntry>       WitPart::* producingBopEntriesArg,
         WitPtrTVec <WitBopEntry>       WitPart::*,
         int                            WitPart::*,
         WitPtrVec  <WitPart>           WitPart::*);

      static void receiveDMPs (
a175 5
      void sortBopEntries ();
         //
         // For each Part, thePart, sorts thePart->producingBopEntries in order
         // of non-decreasing expAversion.

a226 1
      static WitList    <WitBopEntry>       WitPart::* producingBopEntries_;
@


1.42
log
@[disallowed backlog]
@
text
@d80 1
a80 1
         bool                           WitPart::* expPerGapsArg,
d82 1
a82 1
         WitPtrTVec <WitBopEntry>       WitPart::* expBopEntryArg,
d84 1
a84 1
         WitPtrVec  <WitPart>           WitPart::* belowListArg);
d90 1
a90 1
         WitTVec <bool>      WitOperation::* executableArg);
a238 1
      static bool                           WitPart::* expPerGaps_;
a239 1
      static WitPtrTVec <WitBopEntry>       WitPart::* expBopEntry_;
@


1.41
log
@Updated the copyright date on all source files.
@
text
@d83 1
a83 1
         int                            WitPart::* sortedPartIndexArg,
@


1.40
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.39
log
@[multi-thread]
@
text
@d84 1
a84 1
         WitDenseList <WitPart>         WitPart::* belowListArg);
@


1.38
log
@Low-Pri Prop-Rt.
@
text
@a18 2
#include <RefMap.h>
#include <Ref.h>
d71 40
a110 48
      // Data loading functions.
      //------------------------------------------------------------------------

      void loadDataFrom (
            WitPart *,      
            int                       & sortedPartIndexArg,
            bool                      & expPerGapsArg,
            WitList    <WitBopEntry>  & producingBopEntriesArg,
            WitPtrTVec <WitBopEntry>  & expBopEntryArg,
            WitDenseList <WitPart>    & belowListArg);

      void loadDataFrom (
            WitMaterial *,  
            WitFlexVec <bool>         & mandECArg);

      void loadDataFrom (
            WitOperation *, 
            WitTVec    <bool>         & executableArg);

      void loadDataFrom (
            WitBillEntry *, 
            WitTVec    <WitPeriod>    & impactPeriodArg);

      void loadDataFrom (
            WitConsEntry *, 
            WitDblFlexVec             & effConsRateArg);

      void loadDataFrom (
            WitBomEntry *,  
            WitFlexVec <bool>         & hasSubsInEffectArg,
            WitList    <WitSubEntry>  & mySubEntriesArg);

      void loadDataFrom (
            WitBopEntry *,  
            WitTVec    <WitPeriod>    & expExecPeriodArg,
            WitDblFlexVec             & effProdRateArg);

      void loadDataFromCompMgr (
            WitList    <WitPart>      & allPartsArg,
            WitList    <WitOperation> & allOperationsArg);

      void loadDataFromGlobalComp (
            bool                      & lotSizesExistArg);

      void loadOptPreDataFrom (
            WitBillEntry *, 
            WitVector  <int>          & firstEPIndexArg,
            WitVector  <WitPeriod>    & execPeriodArg);
a119 8
      void loadData ();
         //
         // Loads the data to be loaded from the components.

      void clearLoadedData ();
         //
         // Clears the data that was loaded in from the components.

d232 18
a249 16
      // Mappings to data loaded in from Components, etc.
      //------------------------------------------------------------------------

      WitRefMap <WitPart,      bool                     > expPerGaps_;
      WitRefMap <WitPart,      WitList    <WitBopEntry> > producingBopEntries_;
      WitRefMap <WitPart,      WitPtrTVec <WitBopEntry> > expBopEntry_;
      WitRefMap <WitMaterial,  WitFlexVec <bool>        > mandEC_;
      WitRefMap <WitBillEntry, WitVector  <int>         > firstEPIndex_;
      WitRefMap <WitBillEntry, WitVector  <WitPeriod>   > execPeriod_;
      WitRefMap <WitConsEntry, WitDblFlexVec            > effConsRate_;
      WitRefMap <WitBomEntry,  WitFlexVec <bool>        > hasSubsInEffect_;
      WitRefMap <WitBomEntry,  WitList    <WitSubEntry> > mySubEntries_;
      WitRefMap <WitBopEntry,  WitTVec    <WitPeriod>   > expExecPeriod_;
      WitRefMap <WitBopEntry,  WitDblFlexVec            > effProdRate_;

      WitRef                  <bool                     > lotSizesExist_;
@


1.37
log
@Fixed a bug in the sorting of BOP entries that produce each part.
@
text
@a71 7
      static int nProdEntsBefore (WitBopEntry * theBopEnt);
         //
         // When sortBopEntries is executing, returns
         // # BopEnts that appear earlier in
         // theBopEnt->myPart ()->producingBopEntries () than theBopEnt.
         // Invalid, when sortBopEntries is not executing.

a309 4

      static WitMapping <WitBopEntry, int> * nProdEntsBeforePtr_;
         //
         // Data for nProdEntsBefore ().
@


1.36
log
@Fixed a bug in the screening of the optimization model.
@
text
@d72 7
d317 4
@


1.35
log
@Double Precision.
@
text
@a78 1
            WitFlexVec <bool>         & isCoproducedArg,
a231 8
      void setIsCoproduced ();
         //
         // Sets isCoproduced_ for each Part in myProblem ().

      void setCoprod (WitBillEntry * theEnt, WitPeriod execPer);
         //
         // Sets isCoproduced_ to true for execPer, as appropriate.

d253 11
a263 12
      WitRefMap <WitPart,      WitFlexVec <bool>         > isCoproduced_;
      WitRefMap <WitPart,      bool                      > expPerGaps_;
      WitRefMap <WitPart,      WitList    <WitBopEntry>  > producingBopEntries_;
      WitRefMap <WitPart,      WitPtrTVec <WitBopEntry>  > expBopEntry_;
      WitRefMap <WitMaterial,  WitFlexVec <bool>         > mandEC_;
      WitRefMap <WitBillEntry, WitVector  <int>          > firstEPIndex_;
      WitRefMap <WitBillEntry, WitVector  <WitPeriod>    > execPeriod_;
      WitRefMap <WitConsEntry, WitDblFlexVec             > effConsRate_;
      WitRefMap <WitBomEntry,  WitFlexVec <bool>         > hasSubsInEffect_;
      WitRefMap <WitBomEntry,  WitList    <WitSubEntry>  > mySubEntries_;
      WitRefMap <WitBopEntry,  WitTVec    <WitPeriod>    > expExecPeriod_;
      WitRefMap <WitBopEntry,  WitDblFlexVec             > effProdRate_;
d265 1
a265 1
      WitRef                  <bool                      > lotSizesExist_;
@


1.34
log
@Double Precision.
@
text
@d99 1
a99 1
            WitFlexVec <double>       & effConsRateArg);
d109 1
a109 1
            WitFlexVec <double>       & effProdRateArg);
d269 1
a269 1
      WitRefMap <WitConsEntry, WitFlexVec <double>       > effConsRate_;
d273 1
a273 1
      WitRefMap <WitBopEntry,  WitFlexVec <double>       > effProdRate_;
@


1.33
log
@Double Precision.
@
text
@d99 1
a99 1
            WitRealVec                & effConsRateArg);
d109 1
a109 1
            WitRealVec                & effProdRateArg);
d269 1
a269 1
      WitRefMap <WitConsEntry, WitRealVec                > effConsRate_;
d273 1
a273 1
      WitRefMap <WitBopEntry,  WitRealVec                > effProdRate_;
@


1.32
log
@Double Precision.
@
text
@d109 1
a109 1
            WitRealTVc                & effProdRateArg);
d273 1
a273 1
      WitRefMap <WitBopEntry,  WitRealTVc                > effProdRate_;
@


1.31
log
@Double Precision.
@
text
@d109 1
a109 1
            WitRealVec                & effProdRateArg);
d273 1
a273 1
      WitRefMap <WitBopEntry,  WitRealVec                > effProdRate_;
@


1.30
log
@Attempt to fix a syntax error from the MS compiler.
@
text
@d99 1
a99 1
            WitFlexVec <float>        & effConsRateArg);
d109 1
a109 1
            WitTVec    <float>        & effProdRateArg);
d269 1
a269 1
      WitRefMap <WitConsEntry, WitFlexVec <float>        > effConsRate_;
d273 1
a273 1
      WitRefMap <WitBopEntry,  WitTVec    <float>        > effProdRate_;
@


1.29
log
@Attempt to fix a syntax error from the MS compiler in Pre.C.
@
text
@a206 27
      //------------------------------------------------------------------------
      // In the following template functions, the SortEntry template argument
      // is to be either SubEntry or BopEntry.
      //------------------------------------------------------------------------

      template <typename SortEntry> 
            bool orderedByAversion (const WitList <SortEntry> & theList);
         //
         // Returns true, iff the elements of theList are ordered consistently
         // with the aversion function declared above.

      template <typename SortEntry> 
            void sortByAversion (
               WitList      <SortEntry> & theList,
               WitDenseList <SortEntry> & theDenseList);
         //
         // Sorts the elements of theList according to the aversion function.
         // Uses theDenseList as a temporary work area for the sort.

      //------------------------------------------------------------------------

      static int compareAversion (WitSubEntry *, WitSubEntry *);
      static int compareAversion (WitBopEntry *, WitBopEntry *);
         //
         // Sort compare function based on expNetAversion and expAversion,
         // respectively.

@


1.28
log
@Various internal changes.
@
text
@a206 5
      inline static float aversion (WitSubEntry *);
      inline static float aversion (WitBopEntry *);
         //
         // Aversion functions used by the following template functions.

d226 4
a229 4
      template <typename SortEntry> 
            static int compareAversion (
               SortEntry * theSortEntry1,
               SortEntry * theSortEntry2);
d231 2
a232 3
         // Sort compare function based on the aversion function.

      //------------------------------------------------------------------------
@


1.27
log
@Internal changes.
@
text
@d207 33
@


1.26
log
@Continued implementation of two-level lot sizes.
@
text
@d53 2
a54 2
      accessFunc (WitBoolean, preprocessed)
      accessFunc (WitBoolean, optPreprocessed)
d79 2
a80 2
            WitFlexVec <WitBoolean>   & isCoproducedArg,
            WitBoolean                & expPerGapsArg,
d87 1
a87 1
            WitFlexVec <WitBoolean>   & mandECArg);
d91 1
a91 1
            WitTVec    <WitBoolean>   & executableArg);
d103 1
a103 1
            WitFlexVec <WitBoolean>   & hasSubsInEffectArg,
d116 1
a116 1
            WitBoolean                & lotSizesExistArg);
d239 1
a239 1
         // Sets isCoproduced_ to TRUE for execPer, as appropriate.
d262 2
a263 2
      WitRefMap <WitPart,      WitFlexVec <WitBoolean>   > isCoproduced_;
      WitRefMap <WitPart,      WitBoolean                > expPerGaps_;
d266 1
a266 1
      WitRefMap <WitMaterial,  WitFlexVec <WitBoolean>   > mandEC_;
d270 1
a270 1
      WitRefMap <WitBomEntry,  WitFlexVec <WitBoolean>   > hasSubsInEffect_;
d275 1
a275 1
      WitRef                  <WitBoolean                > lotSizesExist_;
d293 1
a293 1
      WitBoolean preprocessed_;
d295 1
a295 1
         // TRUE iff myProblem () is in a preprocessed state.
d297 1
a297 1
      WitBoolean optPreprocessed_;
d299 1
a299 1
         // TRUE iff myProblem () is in an opt-preprocessed state.
d301 1
a301 1
      WitBoolean execPeriodsComputed_;
d303 1
a303 1
         // TRUE, iff execPeriod has been computed for the BillEntries.
@


1.25
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d150 1
a150 1
      void compLotSizesExist ();
d152 1
a152 1
         // Computes myProblem ()->lotSizesExist_.
@


1.24
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d41 1
a41 3
      WitPreprocessor (WitProblem * theProblem);
         //
         // ProbAssoc <<< theProblem.
@


1.23
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a18 1
#include <Schedule.h>
d24 1
a151 65
      void roundOffsets ();
         //
         // Computes impact periods by applying a special rounding algorithm on
         // offsets, designed to avoid cumulative round-off errors.
         // Data computed:
         //    impactPeriod for each BomEntry and each BopEntry.
         //    executeable for each Operation.

      void truncateOffsets ();
         //
         // Computes truncOffset_;

      void truncateOffset (WitBillEntry * theBillEnt);
         //
         // Computes truncOffset_ (theBillEnt).

      inline float workOffset (WitBillEntry * theBillEnt, WitPeriod thePer);

      WitBoolean roundOffsets (WitOperation * theOpn, WitPeriod thePer);
         //
         // Computes impactPeriods for the BomEntries and BopEntries of
         // theOpn in period t.
         // Also checks for the various conditions under which execution of
         // theOpn is to be forbidden in period t.
         // If any such condition occurs, computation is terminated and FALSE
         // is returned, indicating forbidden execution.
         // Otherwise TRUE is returned.

      WitBoolean compImpactPeriod (WitConsEntry * theConsEnt, WitPeriod thePer);
         //
         // Computes theConsEnt->impactPeriod_[thePer].
         // If this functions discovers that execution of
         // theConsEnt->myOperation () in thePer is to be forbidden, the
         // computation is aborted and the function returns FALSE.
         // Otherwise returns TRUE.

      void copyImpactPeriod (WitSubEntry * theSub, WitPeriod thePer);
         //
         // Copies impactPeriod to theSub from its BomEntry.

      WitBoolean compImpactPeriod (WitBopEntry * theBopEnt, WitPeriod thePer);
         //
         // CompImpactPeriod for a BopEntry.

      static int ltRoundDown (float leadTime);
         //
         // Returns leadTime rounded down to an int with some numerical fuzz.

      void resetExec (WitOperation * theOpn, WitPeriod thePer);
         //
         // Turns off impactPeriods and floatCumLead given theOpn cannot
         // be executed in period t.

      void updateProdCumLeads (
            WitOperation *         theOpn,
            WitTVec <float> &      leadToImpact,
            WitTVec <WitBoolean> & hasImpact);
         //
         // Updates floatCumLead_ for the Parts produced by theOpn.
         // For a given BopEntry, and Period thePer:
         //    hadImpact[thePer] is TRUE, iff the BopEntry has an 
         //       impactPeriod == thePer
         //    leadToImpact[thePer] is the float cum lead time for impactPeriod 
         //       thePer, if any.

a268 2
      WitRefMap <WitOperation, WitTVec    <WitBoolean>   > executable_;
      WitRefMap <WitBillEntry, WitTVec    <WitPeriod>    > impactPeriod_;
d287 4
a301 15

      WitSchedule <WitBillEntry, float> truncOffset_;
         //
         // If truncOffsets is TRUE,
         //    truncOffset_ (theBillEnt)[thePer] is 
         //    theBillEnt->offset ()[thePer], truncated to avoid a negative
         //    impact Period.
         // Otherwise not allocated.

      WitSchedule <WitNode, float> floatCumLead_;
         //
         // floatCumLead_ (theNode)[thePer] is the float cumulative lead time of
         // theNode for execution in thePer, if theNode is an Operation or
         // production in thePer, if theNode is a Part.
         // Allocated and used by roundOffsets ().
@


1.22
log
@Continued implementation of Single-Source.
@
text
@a18 6
#include <PtrMap.h>
#include <Global.h>
#include <Material.h>
#include <Opn.h>
#include <BomEntry.h>
#include <BopEntry.h>
d22 1
d24 1
d139 1
a139 1
         // Clears the data that was loaded from the components.
a151 40
      void sortNodesIfNeeded ();
         //
         // Does a topological sort of the Nodes of theProblem, unless they
         // are already in order.

      inline const WitList <WitNode> & successors (WitNode * theNode);
         //
         // successors (theNode) is a List of all Nodes, otherNode, such that
         // there is an BillEntry from theNode to otherNode, so that otherNode
         // must be higher in the BOM than theNode. otherNode will be listed
         // once in successors (theNode) for each BillEntry connecting theNode
         // to otherNode.

      void defineAllNodesSuccessors ();
         //
         // Sets up allNodes and successorsVector.

      WitBoolean nodesInOrder ();
         //
         // Returns TRUE, iff the Parts and Operations are already in order.

      void sortNodes ();
         //
         // Sorts allNodes, checks for cycles, and stores the result in
         // myProblem ().

      void sortNodes (WitList <WitNode> & sortedNodes);
         //
         // Sorts allNodes and stores the result in sortedNodes.

      void constructCycle ();
         //
         // Constructs and displays a cycle in the BOM structure.
         // Assumes that the set of unsorted Nodes is non-empty and that each
         // node in this set has a predecessor in the BOM in this set.
         // This is precisely the condition that occurs when the topological
         // sort (sortNodes) fails. Under this condition, a cycle can be found
         // (and is found) by following a path of unsorted predecessor Nodes
         // until a repeat is found.

a328 1
      WitRefMap <WitPart,      int                       > sortedPartIndex_;
a332 1
      WitRefMap <WitPart,      WitDenseList <WitPart>    > belowList_;
a343 2
      WitRef                  <WitList    <WitPart>      > allParts_;
      WitRef                  <WitList    <WitOperation> > allOperations_;
d350 4
a364 18

      WitList <WitNode> allNodes_;
         //
         // All the Nodes in myProblem.

      WitPtrVec <WitList <WitNode> > & successorsVector_;
         //
         // Data for successors ().

      WitMapping <WitNode, WitBoolean> & sorted_;
         //
         // sorted_ (theNode) is TRUE, iff theNode has been sorted.

      WitPtrMap <WitNode, WitNode> unsortedPredFor_;
         //
         // During constructCycle, unsortedPredFor_ (theNode)
         // is an unsorted predecessor of theNode. By assumption, this exists
         // for each unsorted Node during constructCycle.
@


1.21
log
@Continued implementation of single-source.
@
text
@d25 1
d428 1
a428 1
      WitSchedule <WitBillEntry, float> & truncOffset_;
d436 1
a436 1
      WitSchedule <WitNode, float> & floatCumLead_;
@


1.20
log
@Continued implementation of single-source.
@
text
@a20 1
#include <AccFlag.h>
d25 2
d58 2
a59 3
      accessFunc (const WitAccFlag *, myAccFlag)
      accessFunc (WitBoolean,         preprocessed)
      accessFunc (WitBoolean,         optPreprocessed)
a76 2
   private:

d78 1
a78 1
      // Private member functions.
d81 46
a126 3
      //------------------------------------------------------------------------
      // Component data access functions.
      //------------------------------------------------------------------------
d128 1
a128 19
      refAccess (WitCompMgr,    WitList    <WitPart>,      allParts)
      refAccess (WitCompMgr,    WitList    <WitOperation>, allOperations)
      refAccess (WitGlobalComp, WitBoolean,                lotSizesExist)
      refAccess (WitPart,       int,                       sortedPartIndex)
      refAccess (WitPart,       WitFlexVec <WitBoolean>,   isCoproduced)
      refAccess (WitPart,       WitBoolean,                expPerGaps)
      refAccess (WitPart,       WitList    <WitBopEntry>,  producingBopEntries)
      refAccess (WitPart,       WitPtrTVec <WitBopEntry>,  expBopEntry)
      refAccess (WitMaterial,   WitFlexVec <WitBoolean>,   mandEC)
      refAccess (WitOperation,  WitTVec    <WitBoolean>,   executable)
      refAccess (WitBillEntry,  WitTVec    <WitPeriod>,    impactPeriod)
      refAccess (WitBillEntry,  WitVector  <int>,          firstEPIndex)
      refAccess (WitBillEntry,  WitVector  <WitPeriod>,    execPeriod)
      refAccess (WitConsEntry,  WitFlexVec <float>,        effConsRate)
      refAccess (WitBomEntry,   WitFlexVec <double>,       nonSubVol)
      refAccess (WitBomEntry,   WitFlexVec <WitBoolean>,   hasSubsInEffect)
      refAccess (WitBomEntry,   WitList    <WitSubEntry>,  mySubEntries)
      refAccess (WitBopEntry,   WitTVec    <WitPeriod>,    expExecPeriod)
      refAccess (WitBopEntry,   WitTVec    <float>,        effProdRate)
d131 1
a131 1
      // Other private member functions.
d136 8
a271 1
         //    Allocating nonSubVol.
d364 7
a370 3
      void unpreprocessConsEntry (WitConsEntry * theConsEnt);
         //
         // Puts theConsEnt into an unpreprocessed state.
d372 20
a391 3
      void unpreprocessBillEntry (WitBillEntry * theBillEnt);
         //
         // Puts theBillEnt into an unpreprocessed state.
d394 1
a394 1
      // Private member data.
a395 4

      WitAccFlag * const myAccFlag_;
         //
         // The AccFlag for this Preprocessor.
@


1.19
log
@Continued implementation of single-source.
@
text
@a61 6
      // Result export functions.
      //------------------------------------------------------------------------

      accessFunc (const WitList <WitNode> &, sortedNodes)

      //------------------------------------------------------------------------
d87 3
d150 1
a150 1
      void innerSortNodes ();
d152 1
a152 1
         // Sorts allNodes and stores the result in sortedNodes_.
d229 4
a343 12
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Result data.
      //------------------------------------------------------------------------

      WitList <WitNode> sortedNodes_;
         //
         // The sorted List of all Nodes.

      //------------------------------------------------------------------------
      // Other private member data.
@


1.18
log
@Preliminary work on single source.
@
text
@d62 6
a92 3
      refAccess (WitCompMgr,    WitList    <WitPart>,      allParts)
      refAccess (WitCompMgr,    WitList    <WitOperation>, allOperations)
      refAccess (WitGlobalComp, WitBoolean,                lotSizesExist)
d153 1
a153 1
      void sortNodes (WitList <WitNode> & sortedNodes);
d155 1
a155 1
         // Sorts allNodes and stores the result in sortedNodes.
a231 4
      void compLotSizesExist ();
         //
         // Computes myProblem ()->lotSizesExist_.

d343 12
@


1.17
log
@Continued preliminary work on single source.
@
text
@d87 19
a105 19
      refAccess (WitCompMgr,    WitList <WitPart>,        allParts)
      refAccess (WitCompMgr,    WitList <WitOperation>,   allOperations)
      refAccess (WitGlobalComp, WitBoolean,               lotSizesExist)
      refAccess (WitPart,       int,                      sortedPartIndex)
      refAccess (WitPart,       WitFlexVec (WitBoolean),  isCoproduced)
      refAccess (WitPart,       WitBoolean,               expPerGaps)
      refAccess (WitPart,       WitList <WitBopEntry>,    producingBopEntries)
      refAccess (WitPart,       WitPtrTVec <WitBopEntry>, expBopEntry)
      refAccess (WitMaterial,   WitFlexVec (WitBoolean),  mandEC)
      refAccess (WitOperation,  WitTVec <WitBoolean>,     executable)
      refAccess (WitBillEntry,  WitTVec <WitPeriod>,      impactPeriod)
      refAccess (WitBillEntry,  WitVector <int>,          firstEPIndex)
      refAccess (WitBillEntry,  WitVector <WitPeriod>,    execPeriod)
      refAccess (WitConsEntry,  WitFlexVec (float),       effConsRate)
      refAccess (WitBomEntry,   WitFlexVec (double),      nonSubVol)
      refAccess (WitBomEntry,   WitFlexVec (WitBoolean),  hasSubsInEffect)
      refAccess (WitBomEntry,   WitList <WitSubEntry>,    mySubEntries)
      refAccess (WitBopEntry,   WitTVec <WitPeriod>,      expExecPeriod)
      refAccess (WitBopEntry,   WitTVec <float>,          effProdRate)
@


1.16
log
@Continued preliminary work on single source.
@
text
@a19 2
#include <Mapping.h>
#include <Schedule.h>
d22 4
d180 1
a180 7
      inline float workOffset (WitBillEntry * theBillEnt, WitPeriod thePer)
         {
         return
            myGlobalComp ()->truncOffsets ()?
               truncOffset_ (theBillEnt, thePer):
               theBillEnt->offset ()[thePer];
         }
d370 1
a370 1
      WitMapping (WitNode, WitBoolean) sorted_;
d372 1
a372 1
         // sorted (theNode) is TRUE, iff theNode has been sorted.
d380 1
a380 1
      WitSchedule (WitBillEntry, float) truncOffset_;
d388 1
a388 1
      WitSchedule (WitNode, float) floatCumLead_;
@


1.15
log
@More preliminary work on single source.
@
text
@d94 2
a95 2
      refAccess (WitOperation,  WitTVec (WitBoolean),     executable)
      refAccess (WitBillEntry,  WitTVec (WitPeriod),      impactPeriod)
d102 2
a103 2
      refAccess (WitBopEntry,   WitTVec (WitPeriod),      expExecPeriod)
      refAccess (WitBopEntry,   WitTVec (float),          effProdRate)
d223 2
a224 2
            WitTVec (float) &      leadToImpact,
            WitTVec (WitBoolean) & hasImpact);
d403 1
a403 1
      WitTVec (int) tempNExecPeriods_;
@


1.14
log
@Preliminary work on single source.
@
text
@a27 28
// Macro declareAversionSort (SortEntry)
//
// SortEntry = WitSubEntry or WitBopEntry.
//
// To be invoked in the private section of the Preprocessor declaration.
// Declares functions to sort SortEntries by aversion.
//------------------------------------------------------------------------------

#define declareAversionSort(SortEntry)                                         \
                                                                               \
   WitBoolean orderedByAversion (const WitList <SortEntry> & theList);         \
      /*                                                                     */\
      /* Returns TRUE, iff theList is in order of non-decreasing aversion.   */\
                                                                               \
   void sortByAversion (                                                       \
         WitList      <SortEntry> & theList,                                   \
         WitDenseList (SortEntry) & theDenseList);                             \
      /*                                                                     */\
      /* Sorts theList in order of non-decreasing aversion.                  */\
      /* Uses theDenseList to implement the sort.                            */\
                                                                               \
   static int compareAversion (                                                \
         SortEntry * theSortEntry1,                                            \
         SortEntry * theSortEntry2);                                           \
      /*                                                                     */\
      /* Compare function for sorting SortEntries by non-decreasing aversion.*/\

//------------------------------------------------------------------------------
a290 13
      declareAversionSort (WitSubEntry)
      declareAversionSort (WitBopEntry)

      inline static float aversion (const WitSubEntry * theSub)
         {
         return theSub->expNetAversion ();
         }

      inline static float aversion (const WitBopEntry * theBopEnt)
         {
         return theBopEnt->expAversion ();
         }

d420 1
a420 1
 #endif
@


1.13
log
@Preliminary work on single source.
@
text
@d124 2
a125 2
      refAccess (WitBillEntry,  WitVector (int),          firstEPIndex)
      refAccess (WitBillEntry,  WitVector (WitPeriod),    execPeriod)
d451 1
a451 1
      WitPtrTVec <WitVector (WitPeriod)> & tempExecPeriod_;
@


1.12
log
@Began implementation of object iteration.
@
text
@d38 1
a38 1
   WitBoolean orderedByAversion (const WitList (SortEntry) & theList);         \
d43 1
a43 1
         WitList      (SortEntry) & theList,                                   \
d113 2
a114 2
      refAccess (WitCompMgr,    WitList (WitPart),        allParts)
      refAccess (WitCompMgr,    WitList (WitOperation),   allOperations)
d119 1
a119 1
      refAccess (WitPart,       WitList (WitBopEntry),    producingBopEntries)
d129 1
a129 1
      refAccess (WitBomEntry,   WitList (WitSubEntry),    mySubEntries)
d155 1
a155 1
      inline const WitList (WitNode) & successors (WitNode * theNode);
d176 1
a176 1
      void sortNodes (WitList (WitNode) & sortedNodes);
d407 1
a407 1
      WitList (WitNode) allNodes_;
d411 1
a411 1
      WitPtrVec <WitList (WitNode)> & successorsVector_;
@


1.11
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d22 1
@


1.10
log
@Replaced Mapping (*, WitTlObjPtr) with PtrMap <*, *>.
@
text
@d115 1
@


1.9
log
@More templates.
@
text
@d19 1
a187 5
      inline WitNode * & unsortedPred (WitNode * theNode)
         {
         return (WitNode * &) unsortedPredTl_ (theNode);
         }

d417 1
a417 1
      WitMapping (WitNode, WitTlObjPtr) unsortedPredTl_;
d419 1
a419 1
         // During constructCycle, (WitNode *) unsortedPredTl_ (theNode)
@


1.8
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d117 1
a117 1
      refAccess (WitPart,       WitPtrTVec (WitBopEntry), expBopEntry)
d413 1
a413 1
      WitPtrVec (WitList (WitNode)) & successorsVector_;
d453 1
a453 1
      WitPtrTVec (WitVector (WitPeriod)) & tempExecPeriod_;
@


1.7
log
@Further development of coarse selection splitting.
@
text
@d421 1
a421 1
      WitMapping (WitNode, WitTlPtr) unsortedPredTl_;
@


1.6
log
@Some minor changes.
@
text
@d421 1
a421 1
      WitMapping (WitNode, WitTypelessPtr) unsortedPredTl_;
@


1.5
log
@Refactoring for selection splitting.
@
text
@d152 1
a152 4
      inline const WitList (WitNode) & successors (WitNode * theNode)
         {
         return successorsVector_[theNode->nodeIndex ()];
         }
d413 1
a413 1
      WitRefVector (WitList (WitNode)) successorsVector_;
d453 1
a453 1
      WitRefVector (WitVector (WitPeriod)) tempExecPeriod_;
@


1.4
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d117 1
a117 1
      refAccess (WitPart,       WitTVec (WitTypelessPtr), expBopEntryTl)
d134 1
a134 3
      copyCtorAndAssignment (WitPreprocessor);
         //
         // Prevents unintentional copying and assignment.
a339 5

      inline WitBopEntry * & expBopEntry (WitPart * thePart, WitPeriod thePer)
         {
         return (WitBopEntry * &) expBopEntryTl (thePart)[thePer];
         }
@


1.3
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d114 1
a114 1
      refAccess (WitPart,       WitBoolean,               isCoproduced)
d123 1
a123 1
      refAccess (WitConsEntry,  float,                    effUsageRate)
d283 1
a283 1
         //    Computing effUsageRate for this BomEntry and its subEntries.
d286 1
a286 1
      void compEffUsageRate (WitConsEntry * theConsEnt);
d288 1
a288 1
         // Computes effUsageRate_ (theConsEnt).
d373 4
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d124 1
a124 1
      refAccess (WitBomEntry,   WitTVec (float),          nonSubVol)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

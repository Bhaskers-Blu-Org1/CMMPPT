head	1.35;
access;
symbols
	sce_5_01_20080919:1.28
	latest_sce_4_20_20060523:1.25.0.2
	sce_4_20_20060523:1.25
	latest_sce4_20_OSL:1.24.0.2
	sce_4_20_OSL:1.24
	sce_410_withVa:1.22
	sce_4_05_20040511:1.21
	sce_4_00_20040201:1.18
	nextGenBranch:1.17.0.2
	nextGenRoot:1.17
	sce_3_30_20030627:1.17
	EndRw-branch:1.14.0.4
	Root-of-EndRw:1.14
	rwToStl:1.14.0.2
	latest_sce_3_10_20010924:1.10.0.2
	sce_3_10_20010924:1.10
	latest_sce_3_00_20010601:1.8.0.4
	sce_3_00_20010601:1.8
	latest_sce_2_31_20010308:1.8.0.2
	sce_2_31_20010308:1.8
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2011.09.28.23.49.19;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2011.09.24.00.27.37;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2011.08.30.20.17.28;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.28.22.38.18;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.24.22.57.29;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.17.22.04.44;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2010.03.16.22.42.24;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2006.09.27.20.10.16;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.26.21.29.44;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.11.22.53.41;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.02.17.33.57;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.03.16.48.12;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.05.22.24.08;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.28.20.14.35;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.10.22.53.18;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.04.16.31.45;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.20.15.37.35;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.23.20.47.15;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.23.40.39;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.02.22.18.25;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.06.18.53.36;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.05.21.19.57;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.07.20.14.54;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.14.02.31;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.25.16.08.13;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.03.20.07.29;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.11.16.35.08;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.05.19.05.29;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.04.22.07.35;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.22;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.21;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.29;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.43;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "EqAll.C"
//
// Contains the implementation of class EqAllocator.
//------------------------------------------------------------------------------

#include <EqAll.h>
#include <HeurAllMgr.h>
#include <HeurModifier.h>
#include <DataWrit.h>
#include <GlobalComp.h>
#include <Demand.h>
#include <PairStack.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class EqAllocator
//------------------------------------------------------------------------------

WitEqAllocator::WitEqAllocator (WitProblem * theProblem):
      WitProbAssoc   (theProblem),

      active_        (false),
      desIncVol_     (),
      incVol_        (),
      prevDesVol_    (),
      firstIndex_    (),
      asapMultiExec_ ()
   {
   }

//------------------------------------------------------------------------------

WitEqAllocator::~WitEqAllocator ()
   {
   deactivate ();
   }

//------------------------------------------------------------------------------

void WitEqAllocator::setAsapMultiExec (
      WitDemand * theDemand, 
      WitPeriod   shipPer,
      bool        theValue)
   {
   witAssert (myGlobalComp ()->twoWayMultiExec ());

   asapMultiExec_ (theDemand)[shipPer] = theValue;
   }

//------------------------------------------------------------------------------

bool WitEqAllocator::containsDup (
      const WitDemPerStack & theDemPers,
      int &                  firstDupIndex,
      int &                  secondDupIndex)
   {
   bool         dupFound;
   int          targetIndex;
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;

   witAssert (active_);

   dupFound = false;

   if (firstIndex_.domainSize () == 0)
      firstIndex_.allocate (myProblem (), -1);

   targetIndex = -1;

   theDemPers.attachItr (theItr);

   while (theItr.advance (theDemand, thePer))
      {
      ++ targetIndex;

      if (firstIndex_ (theDemand)[thePer] >= 0)
         {
         dupFound       = true;
         firstDupIndex  = firstIndex_ (theDemand)[thePer];
         secondDupIndex = targetIndex;

         break;
         }

      firstIndex_ (theDemand)[thePer] = targetIndex;
      }

   theDemPers.attachItr (theItr);

   while (theItr.advance (theDemand, thePer))
      firstIndex_ (theDemand)[thePer] = -1;

   return dupFound;
   }

//------------------------------------------------------------------------------

void WitEqAllocator::activate ()
   {
   if (active_)
      return;

   witAssert (myProblem ()->myHeurAllMgr ()->active ());

   desIncVol_ .allocate (myProblem (), 0.0);
   incVol_    .allocate (myProblem (), 0.0);
   prevDesVol_.allocate (myProblem (), 0.0);

   if (myGlobalComp ()->twoWayMultiExec ())
      asapMultiExec_.allocate (myProblem (), false);

   active_ = true;
   }

//------------------------------------------------------------------------------

void WitEqAllocator::heurAllocIsReset ()
   {
   deactivate ();
   }

//------------------------------------------------------------------------------

void WitEqAllocator::eqAlloc (const WitDemPerStack & theDemPers)
   {
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          firstIndex;
   int          secondIndex;

   witAssert (active_);
   witAssert (not theDemPers.isEmpty ());

   witAssert (not containsDup (theDemPers, firstIndex, secondIndex));

   if (myGlobalComp ()->modHeurAlloc ())
      {
      myProblem ()->myHeurModifier ()->checkFeasibility ();
      }

   if (myGlobalComp ()->forcedMultiEq () or multiSigDDs (theDemPers))
      eqAllocMulti (theDemPers);
   else
      {
      theDemPers.attachItr (theItr);

      while (theItr.advance (theDemand, thePer))
         incVol_ (theDemand)[thePer] =
            myProblem ()->myHeurAllMgr ()->incHeurAlloc (
               theDemand,
               thePer,
               desIncVol_ (theDemand)[thePer],
               asapMultiExec (theDemand, thePer));
      }
   }

//------------------------------------------------------------------------------

void WitEqAllocator::print (const WitDemPerStack & theDemPers)
   {
   int          theIndex;
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    shipPer;

   theIndex = -1;

   theDemPers.attachItr (theItr);

   while (theItr.advance (theDemand, shipPer))
      {
      myMsgFac () ("targetNumMsg", ++ theIndex);

      myMsgFac () ("partNameMsg", theDemand->demandedPartName ());
      myMsgFac () ("demandNameMsg", theDemand->demandName ());

      if (myGlobalComp ()->twoWayMultiExec ())
         myProblem ()->myHeurAllMgr ()->
            printMeDir (asapMultiExec_ (theDemand)[shipPer]);

      myMsgFac () ("incHeurDataMsg",
         shipPer,
         desIncVol_ (theDemand)[shipPer],
         incVol_    (theDemand)[shipPer]);
      }
   }

//------------------------------------------------------------------------------

void WitEqAllocator::setDesIncVol (
      WitDemand * theDemand, 
      WitPeriod   shipPer, 
      double       theValue)
   {
   witAssert (theValue >= 0.0);

   desIncVol_ (theDemand)[shipPer] = theValue;
   }

//------------------------------------------------------------------------------

double WitEqAllocator::incVol (WitDemand * theDemand, WitPeriod shipPer)
   {
   return incVol_ (theDemand)[shipPer];
   }

//------------------------------------------------------------------------------

void WitEqAllocator::deactivate ()
   {
   if (not active_)
      return;

   firstIndex_   .clear ();
   prevDesVol_   .clear ();
   incVol_       .clear ();
   desIncVol_    .clear ();
   asapMultiExec_.clear ();

   active_ = false;
   }

//------------------------------------------------------------------------------

bool WitEqAllocator::multiSigDDs (const WitDemPerStack & theDemPers)
   {
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          nSigPairs;

   nSigPairs = 0;

   theDemPers.attachItr (theItr);

   while (theItr.advance (theDemand, thePer))
      if (desIncVol_   (theDemand)[thePer] > NET_TOL)
         if (++ nSigPairs > 1)
            return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitEqAllocator::eqAllocMulti (const WitDemPerStack & theDemPers)
   {
   int          equit;
   double       curSearchInc;
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          itNo;
   double       fraction;
   double       totDesVol;
   double       newDesVol;

   equit = myGlobalComp ()->equitability ();

   theDemPers.attachItr (theItr);

   while (theItr.advance (theDemand, thePer))
      incVol_ (theDemand)[thePer] = 0.0;

   for (itNo = 1; itNo <= equit; itNo ++)
      {
      fraction =
           static_cast <double> (itNo)
         / static_cast <double> (equit);

      theDemPers.attachItr (theItr);

      while (theItr.advance (theDemand, thePer))
         {
         curSearchInc = theDemand->searchInc ();

         totDesVol    = desIncVol_ (theDemand)[thePer];

         newDesVol    =
              ceil (fraction * totDesVol / curSearchInc - .001)
            * curSearchInc;

         setToMin (newDesVol, totDesVol);

         incVol_ (theDemand)[thePer] +=
            myProblem ()->myHeurAllMgr ()->incHeurAlloc (
               theDemand,
               thePer,
               newDesVol - prevDesVol_ (theDemand)[thePer],
               asapMultiExec (theDemand, thePer));

         prevDesVol_ (theDemand)[thePer] = newDesVol;
         }
      }

   while (theItr.advance (theDemand, thePer))
      prevDesVol_ (theDemand)[thePer] = 0.0;
   }

//------------------------------------------------------------------------------

bool WitEqAllocator::asapMultiExec (WitDemand * theDemand, WitPeriod shipPer)
   {
   return
      myGlobalComp ()->twoWayMultiExec ()?
         asapMultiExec_ (theDemand)[shipPer]:
         false;
   }
@


1.34
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.33
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d30 1
a30 1
WitProbAssoc   (theProblem),
d32 8
a39 8
active_        (false),
desIncVol_     (),
incVol_        (),
prevDesVol_    (),
firstIndex_    (),
asapMultiExec_ ()
{
}
d44 3
a46 3
{
deactivate ();
}
d51 5
a55 5
WitDemand * theDemand,
WitPeriod   shipPer,
bool        theValue)
{
witAssert (myGlobalComp ()->twoWayMultiExec ());
d57 2
a58 2
asapMultiExec_ (theDemand)[shipPer] = theValue;
}
d63 9
a71 9
const WitDemPerStack & theDemPers,
int &                  firstDupIndex,
int &                  secondDupIndex)
{
bool         dupFound;
int          targetIndex;
WitDemPerItr theItr;
WitDemand *  theDemand;
WitPeriod    thePer;
d73 1
a73 1
witAssert (active_);
d75 1
a75 1
dupFound = false;
d77 2
a78 2
if (firstIndex_.domainSize () == 0)
firstIndex_.allocate (myProblem (), -1);
d80 1
a80 1
targetIndex = -1;
d82 1
a82 1
theDemPers.attachItr (theItr);
d84 3
a86 3
while (theItr.advance (theDemand, thePer))
{
++ targetIndex;
d88 5
a92 5
if (firstIndex_ (theDemand)[thePer] >= 0)
{
dupFound       = true;
firstDupIndex  = firstIndex_ (theDemand)[thePer];
secondDupIndex = targetIndex;
d94 2
a95 2
break;
}
d97 2
a98 2
firstIndex_ (theDemand)[thePer] = targetIndex;
}
d100 1
a100 1
theDemPers.attachItr (theItr);
d102 2
a103 2
while (theItr.advance (theDemand, thePer))
firstIndex_ (theDemand)[thePer] = -1;
d105 2
a106 2
return dupFound;
}
d111 3
a113 3
{
if (active_)
return;
d115 1
a115 1
witAssert (myProblem ()->myHeurAllMgr ()->active ());
d117 3
a119 3
desIncVol_ .allocate (myProblem (), 0.0);
incVol_    .allocate (myProblem (), 0.0);
prevDesVol_.allocate (myProblem (), 0.0);
d121 2
a122 2
if (myGlobalComp ()->twoWayMultiExec ())
asapMultiExec_.allocate (myProblem (), false);
d124 2
a125 2
active_ = true;
}
d130 3
a132 3
{
deactivate ();
}
d137 32
a168 32
{
WitDemPerItr theItr;
WitDemand *  theDemand;
WitPeriod    thePer;
int          firstIndex;
int          secondIndex;

witAssert (active_);
witAssert (not theDemPers.isEmpty ());

witAssert (not containsDup (theDemPers, firstIndex, secondIndex));

if (myGlobalComp ()->modHeurAlloc ())
{
myProblem ()->myHeurModifier ()->checkFeasibility ();
}

if (myGlobalComp ()->forcedMultiEq () or multiSigDDs (theDemPers))
eqAllocMulti (theDemPers);
else
{
theDemPers.attachItr (theItr);

while (theItr.advance (theDemand, thePer))
incVol_ (theDemand)[thePer] =
myProblem ()->myHeurAllMgr ()->incHeurAlloc (
theDemand,
thePer,
desIncVol_ (theDemand)[thePer],
asapMultiExec (theDemand, thePer));
}
}
d173 27
a199 27
{
int          theIndex;
WitDemPerItr theItr;
WitDemand *  theDemand;
WitPeriod    shipPer;

theIndex = -1;

theDemPers.attachItr (theItr);

while (theItr.advance (theDemand, shipPer))
{
myMsgFac () ("targetNumMsg", ++ theIndex);

myMsgFac () ("partNameMsg", theDemand->demandedPartName ());
myMsgFac () ("demandNameMsg", theDemand->demandName ());

if (myGlobalComp ()->twoWayMultiExec ())
myProblem ()->myHeurAllMgr ()->
printMeDir (asapMultiExec_ (theDemand)[shipPer]);

myMsgFac () ("incHeurDataMsg",
shipPer,
desIncVol_ (theDemand)[shipPer],
incVol_    (theDemand)[shipPer]);
}
}
d204 5
a208 5
WitDemand * theDemand,
WitPeriod   shipPer,
double       theValue)
{
witAssert (theValue >= 0.0);
d210 2
a211 2
desIncVol_ (theDemand)[shipPer] = theValue;
}
d216 3
a218 3
{
return incVol_ (theDemand)[shipPer];
}
d223 9
a231 9
{
if (not active_)
return;

firstIndex_   .clear ();
prevDesVol_   .clear ();
incVol_       .clear ();
desIncVol_    .clear ();
asapMultiExec_.clear ();
d233 2
a234 2
active_ = false;
}
d239 14
a252 14
{
WitDemPerItr theItr;
WitDemand *  theDemand;
WitPeriod    thePer;
int          nSigPairs;

nSigPairs = 0;

theDemPers.attachItr (theItr);

while (theItr.advance (theDemand, thePer))
if (desIncVol_   (theDemand)[thePer] > NET_TOL)
if (++ nSigPairs > 1)
return true;
d254 2
a255 2
return false;
}
d260 52
a311 52
{
int          equit;
double       curSearchInc;
WitDemPerItr theItr;
WitDemand *  theDemand;
WitPeriod    thePer;
int          itNo;
double       fraction;
double       totDesVol;
double       newDesVol;

equit = myGlobalComp ()->equitability ();

theDemPers.attachItr (theItr);

while (theItr.advance (theDemand, thePer))
incVol_ (theDemand)[thePer] = 0.0;

for (itNo = 1; itNo <= equit; itNo ++)
{
fraction =
static_cast <double> (itNo)
/ static_cast <double> (equit);

theDemPers.attachItr (theItr);

while (theItr.advance (theDemand, thePer))
{
curSearchInc = theDemand->searchInc ();

totDesVol    = desIncVol_ (theDemand)[thePer];

newDesVol    =
ceil (fraction * totDesVol / curSearchInc - .001)
* curSearchInc;

setToMin (newDesVol, totDesVol);

incVol_ (theDemand)[thePer] +=
myProblem ()->myHeurAllMgr ()->incHeurAlloc (
theDemand,
thePer,
newDesVol - prevDesVol_ (theDemand)[thePer],
asapMultiExec (theDemand, thePer));

prevDesVol_ (theDemand)[thePer] = newDesVol;
}
}

while (theItr.advance (theDemand, thePer))
prevDesVol_ (theDemand)[thePer] = 0.0;
}
d316 6
a321 6
{
return
myGlobalComp ()->twoWayMultiExec ()?
asapMultiExec_ (theDemand)[shipPer]:
false;
}
@


1.32
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d30 1
a30 1
      WitProbAssoc   (theProblem),
d32 8
a39 8
      active_        (false),
      desIncVol_     (),
      incVol_        (),
      prevDesVol_    (),
      firstIndex_    (),
      asapMultiExec_ ()
   {
   }
d44 3
a46 3
   {
   deactivate ();
   }
d51 5
a55 5
      WitDemand * theDemand, 
      WitPeriod   shipPer,
      bool        theValue)
   {
   witAssert (myGlobalComp ()->twoWayMultiExec ());
d57 2
a58 2
   asapMultiExec_ (theDemand)[shipPer] = theValue;
   }
d63 9
a71 9
      const WitDemPerStack & theDemPers,
      int &                  firstDupIndex,
      int &                  secondDupIndex)
   {
   bool         dupFound;
   int          targetIndex;
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
d73 1
a73 1
   witAssert (active_);
d75 1
a75 1
   dupFound = false;
d77 2
a78 2
   if (firstIndex_.domainSize () == 0)
      firstIndex_.allocate (myProblem (), -1);
d80 1
a80 1
   targetIndex = -1;
d82 1
a82 1
   theDemPers.attachItr (theItr);
d84 3
a86 3
   while (theItr.advance (theDemand, thePer))
      {
      ++ targetIndex;
d88 5
a92 5
      if (firstIndex_ (theDemand)[thePer] >= 0)
         {
         dupFound       = true;
         firstDupIndex  = firstIndex_ (theDemand)[thePer];
         secondDupIndex = targetIndex;
d94 2
a95 2
         break;
         }
d97 2
a98 2
      firstIndex_ (theDemand)[thePer] = targetIndex;
      }
d100 1
a100 1
   theDemPers.attachItr (theItr);
d102 2
a103 2
   while (theItr.advance (theDemand, thePer))
      firstIndex_ (theDemand)[thePer] = -1;
d105 2
a106 2
   return dupFound;
   }
d111 3
a113 3
   {
   if (active_)
      return;
d115 1
a115 1
   witAssert (myProblem ()->myHeurAllMgr ()->active ());
d117 3
a119 3
   desIncVol_ .allocate (myProblem (), 0.0);
   incVol_    .allocate (myProblem (), 0.0);
   prevDesVol_.allocate (myProblem (), 0.0);
d121 2
a122 2
   if (myGlobalComp ()->twoWayMultiExec ())
      asapMultiExec_.allocate (myProblem (), false);
d124 2
a125 2
   active_ = true;
   }
d130 3
a132 3
   {
   deactivate ();
   }
d137 32
a168 32
   {
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          firstIndex;
   int          secondIndex;

   witAssert (active_);
   witAssert (not theDemPers.isEmpty ());

   witAssert (not containsDup (theDemPers, firstIndex, secondIndex));

   if (myGlobalComp ()->modHeurAlloc ())
      {
      myProblem ()->myHeurModifier ()->checkFeasibility ();
      }

   if (myGlobalComp ()->forcedMultiEq () or multiSigDDs (theDemPers))
      eqAllocMulti (theDemPers);
   else
      {
      theDemPers.attachItr (theItr);

      while (theItr.advance (theDemand, thePer))
         incVol_ (theDemand)[thePer] =
            myProblem ()->myHeurAllMgr ()->incHeurAlloc (
               theDemand,
               thePer,
               desIncVol_ (theDemand)[thePer],
               asapMultiExec (theDemand, thePer));
      }
   }
d173 27
a199 27
   {
   int          theIndex;
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    shipPer;

   theIndex = -1;

   theDemPers.attachItr (theItr);

   while (theItr.advance (theDemand, shipPer))
      {
      myMsgFac () ("targetNumMsg", ++ theIndex);

      myMsgFac () ("partNameMsg", theDemand->demandedPartName ());
      myMsgFac () ("demandNameMsg", theDemand->demandName ());

      if (myGlobalComp ()->twoWayMultiExec ())
         myProblem ()->myHeurAllMgr ()->
            printMeDir (asapMultiExec_ (theDemand)[shipPer]);

      myMsgFac () ("incHeurDataMsg",
         shipPer,
         desIncVol_ (theDemand)[shipPer],
         incVol_    (theDemand)[shipPer]);
      }
   }
d204 5
a208 5
      WitDemand * theDemand, 
      WitPeriod   shipPer, 
      double       theValue)
   {
   witAssert (theValue >= 0.0);
d210 2
a211 2
   desIncVol_ (theDemand)[shipPer] = theValue;
   }
d216 3
a218 3
   {
   return incVol_ (theDemand)[shipPer];
   }
d223 9
a231 9
   {
   if (not active_)
      return;

   firstIndex_   .clear ();
   prevDesVol_   .clear ();
   incVol_       .clear ();
   desIncVol_    .clear ();
   asapMultiExec_.clear ();
d233 2
a234 2
   active_ = false;
   }
d239 14
a252 14
   {
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          nSigPairs;

   nSigPairs = 0;

   theDemPers.attachItr (theItr);

   while (theItr.advance (theDemand, thePer))
      if (desIncVol_   (theDemand)[thePer] > NET_TOL)
         if (++ nSigPairs > 1)
            return true;
d254 2
a255 2
   return false;
   }
d260 52
a311 52
   {
   int          equit;
   double       curSearchInc;
   WitDemPerItr theItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          itNo;
   double       fraction;
   double       totDesVol;
   double       newDesVol;

   equit = myGlobalComp ()->equitability ();

   theDemPers.attachItr (theItr);

   while (theItr.advance (theDemand, thePer))
      incVol_ (theDemand)[thePer] = 0.0;

   for (itNo = 1; itNo <= equit; itNo ++)
      {
      fraction =
           static_cast <double> (itNo)
         / static_cast <double> (equit);

      theDemPers.attachItr (theItr);

      while (theItr.advance (theDemand, thePer))
         {
         curSearchInc = theDemand->searchInc ();

         totDesVol    = desIncVol_ (theDemand)[thePer];

         newDesVol    =
              ceil (fraction * totDesVol / curSearchInc - .001)
            * curSearchInc;

         setToMin (newDesVol, totDesVol);

         incVol_ (theDemand)[thePer] +=
            myProblem ()->myHeurAllMgr ()->incHeurAlloc (
               theDemand,
               thePer,
               newDesVol - prevDesVol_ (theDemand)[thePer],
               asapMultiExec (theDemand, thePer));

         prevDesVol_ (theDemand)[thePer] = newDesVol;
         }
      }

   while (theItr.advance (theDemand, thePer))
      prevDesVol_ (theDemand)[thePer] = 0.0;
   }
d316 6
a321 6
   {
   return
      myGlobalComp ()->twoWayMultiExec ()?
         asapMultiExec_ (theDemand)[shipPer]:
         false;
   }
@


1.31
log
@Modifiable Heuristic Allocation
@
text
@d150 3
a152 3
      myProblem ()->
         myHeurModifier ()->
            delayedFeasCheck ();
@


1.30
log
@Lead Time Bounds
@
text
@d18 1
d149 5
@


1.29
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d156 1
a156 1
            myProblem ()->myHeurAllMgr ()->inc (
d293 1
a293 1
            myProblem ()->myHeurAllMgr ()->inc (
@


1.28
log
@Heuristic search increment.
@
text
@d19 1
a19 1
#include <Global.h>
@


1.27
log
@Heuristic search increment.
@
text
@d256 1
a256 1
   double       searchInc;
d265 1
a265 3
   equit     = myGlobalComp ()->equitability ();

   searchInc = myGlobalComp ()->heurSearchInc ();
d282 3
a284 1
         totDesVol = desIncVol_ (theDemand)[thePer];
d286 3
a288 3
         newDesVol =
              ceil (fraction * totDesVol / searchInc - .001)
            * searchInc;
@


1.26
log
@Minor improvement to equitable allocation.
@
text
@d255 2
a256 1
   int          eq;
d260 1
a260 1
   int          iter;
d262 1
d265 3
a267 1
   eq = myGlobalComp ()->equitability ();
d274 1
a274 1
   for (iter = 1; iter <= eq; ++ iter)
d276 3
a278 1
      fraction = static_cast <double> (iter) / static_cast <double> (eq);
d284 5
a288 1
         newDesVol = desIncVol_ (theDemand)[thePer];
d290 1
a290 7
         setToMin (
            newDesVol,
            ceil (fraction * newDesVol - .001));
               //
               // The desired new value for incVol is the given fraction
               // of the total desIncVol, rounded up, but no more than
               // the total desIncVol.
@


1.25
log
@Updated the copyright date on all source files.
@
text
@d34 1
d116 3
a118 2
   desIncVol_.allocate (myProblem (), 0.0);
   incVol_   .allocate (myProblem (), 0.0);
d222 1
d261 1
a261 1
   double       desNewIncVol;
d278 1
a278 1
         desNewIncVol = desIncVol_ (theDemand)[thePer];
d281 2
a282 2
            desNewIncVol,
            ceil (fraction * desNewIncVol - .001));
d292 1
a292 1
               desNewIncVol - incVol_ (theDemand)[thePer],
d294 2
d298 3
@


1.24
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.23
log
@[shared-resource pegging]
@
text
@d80 1
a80 1
   theDemPers.attach (theItr);
d98 1
a98 1
   theDemPers.attach (theItr);
d150 1
a150 1
      theDemPers.attach (theItr);
d173 1
a173 1
   theDemPers.attach (theItr);
d238 1
a238 1
   theDemPers.attach (theItr);
d262 1
a262 1
   theDemPers.attach (theItr);
d271 1
a271 1
      theDemPers.attach (theItr);
@


1.22
log
@Revised mappingIndex code.
@
text
@d80 1
a80 1
   theItr.attachTo (theDemPers); 
d98 1
a98 1
   theItr.attachTo (theDemPers);
d150 1
a150 1
      theItr.attachTo (theDemPers);
d173 1
a173 1
   theItr.attachTo (theDemPers);
d238 1
a238 1
   theItr.attachTo (theDemPers);
d262 1
a262 1
   theItr.attachTo (theDemPers);
d271 1
a271 1
      theItr.attachTo (theDemPers);
@


1.21
log
@Double Precision.
@
text
@a22 1
#include <MapIdxI.h>
@


1.20
log
@Double Precision.
@
text
@d199 1
a199 1
      float       theValue)
d258 2
a259 2
   float        fraction;
   float        desNewIncVol;
d270 1
a270 1
      fraction = static_cast <float> (iter) / static_cast <float> (eq);
d280 1
a280 1
            fltFromDbl (ceil (fraction * desNewIncVol - .001)));
@


1.19
log
@Continued double precision.
@
text
@d280 1
a280 1
            floatFromDouble (ceil (fraction * desNewIncVol - .001)));
@


1.18
log
@Continued implementation of post-implosion pegging.
@
text
@d280 1
a280 1
            static_cast <float> (ceil (fraction * desNewIncVol - .001)));
@


1.17
log
@Changed some C style casts to C++ style.
@
text
@a21 1
#include <ScheduleI.h>
d23 1
@


1.16
log
@Internal changes.
@
text
@d270 1
a270 1
      fraction = (float) iter / (float) eq;
d278 3
a280 1
         setToMin (desNewIncVol, (float) ceil (fraction * desNewIncVol - .001));
@


1.15
log
@Internal changes.
@
text
@d143 1
a143 1
   witAssert (! theDemPers.isEmpty ());
d145 1
a145 1
   witAssert (! containsDup (theDemPers, firstIndex, secondIndex));
d147 1
a147 1
   if (myGlobalComp ()->forcedMultiEq () || multiSigDDs (theDemPers))
d217 1
a217 1
   if (! active_)
@


1.14
log
@Continued implementation of Single-Source.
@
text
@d32 1
a32 1
      active_        (witFALSE),
d52 1
a52 1
      WitBoolean  theValue)
d61 1
a61 1
WitBoolean WitEqAllocator::containsDup (
d66 1
a66 1
   WitBoolean   dupFound;
d74 1
a74 1
   dupFound = witFALSE;
d89 1
a89 1
         dupFound       = witTRUE;
d120 1
a120 1
      asapMultiExec_.allocate (myProblem (), witFALSE);
d122 1
a122 1
   active_ = witTRUE;
d225 1
a225 1
   active_ = witFALSE;
d230 1
a230 1
WitBoolean WitEqAllocator::multiSigDDs (const WitDemPerStack & theDemPers)
d244 1
a244 1
            return witTRUE;
d246 1
a246 1
   return witFALSE;
d296 1
a296 3
WitBoolean WitEqAllocator::asapMultiExec (
      WitDemand * theDemand, 
      WitPeriod   shipPer)
d301 1
a301 1
         witFALSE;
@


1.13
log
@Continued implementation of single-source.
@
text
@d22 1
d192 19
@


1.12
log
@Continued preliminary work on single source.
@
text
@d55 1
a55 1
   asapMultiExec_ (theDemand, shipPer) = theValue;
d86 1
a86 1
      if (firstIndex_ (theDemand, thePer) >= 0)
d89 1
a89 1
         firstDupIndex  = firstIndex_ (theDemand, thePer);
d95 1
a95 1
      firstIndex_ (theDemand, thePer) = targetIndex;
d101 1
a101 1
      firstIndex_ (theDemand, thePer) = -1;
d153 1
a153 1
         incVol_ (theDemand, thePer) =
d157 1
a157 1
               desIncVol_ (theDemand, thePer),
d184 1
a184 1
            printMeDir (asapMultiExec_ (theDemand, shipPer));
d188 2
a189 2
         desIncVol_ (theDemand, shipPer),
         incVol_    (theDemand, shipPer));
d222 1
a222 1
      if (desIncVol_   (theDemand, thePer) > NET_TOL)
d246 1
a246 1
      incVol_ (theDemand, thePer) = 0.0;
d256 1
a256 1
         desNewIncVol = desIncVol_ (theDemand, thePer);
d264 1
a264 1
         incVol_ (theDemand, thePer) +=
d268 1
a268 1
               desNewIncVol - incVol_ (theDemand, thePer),
d282 1
a282 1
         asapMultiExec_ (theDemand, shipPer):
@


1.11
log
@Began implementation of object iteration.
@
text
@d20 1
@


1.10
log
@Initial implementation of pegging.
@
text
@d19 1
d21 1
d43 12
@


1.9
log
@Moved Stack template implementations to header files.
@
text
@d17 1
a17 1
#include <HeurAll.h>
d98 1
a98 1
   witAssert (myProblem ()->myHeurAllocator ()->active ());
d139 1
a139 1
            myProblem ()->myHeurAllocator ()->inc (
d168 1
a168 1
         myProblem ()->myHeurAllocator ()->
d250 1
a250 1
            myProblem ()->myHeurAllocator ()->inc (
@


1.8
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d19 1
a19 1
#include <PairSt.h>
@


1.7
log
@Some minor modifications.
@
text
@d19 1
a19 1
#include <StackItr.h>
@


1.6
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d19 1
a19 1
#include <DynItr.h>
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d46 9
a54 9
      const WitDemPerDynStack & theDemPers,
      int &                     firstDupIndex,
      int &                     secondDupIndex)
   {
   WitBoolean      dupFound;
   int             targetIndex;
   WitDemPerDynItr theItr;
   WitDemand *     theDemand;
   WitPeriod       thePer;
d65 3
a67 1
   for (theItr = theDemPers; theItr (theDemand, thePer);)
d83 3
a85 1
   for (theItr = theDemPers; theItr (theDemand, thePer);)
d118 1
a118 1
void WitEqAllocator::eqAlloc (const WitDemPerDynStack & theDemPers)
d120 5
a124 5
   WitDemPerDynItr theItr;
   WitDemand *     theDemand;
   WitPeriod       thePer;
   int             firstIndex;
   int             secondIndex;
d134 4
a137 1
      for (theItr = theDemPers; theItr (theDemand, thePer);)
d144 1
d149 1
a149 1
void WitEqAllocator::print (const WitDemPerDynStack & theDemPers)
d151 4
a154 4
   int             theIndex;
   WitDemPerDynItr theItr;
   WitDemand *     theDemand;
   WitPeriod       shipPer;
d158 3
a160 1
   for (theItr = theDemPers; theItr (theDemand, shipPer);)
d195 1
a195 1
WitBoolean WitEqAllocator::multiSigDDs (const WitDemPerDynStack & theDemPers)
d197 4
a200 4
   WitDemPerDynItr theItr;
   WitDemand *     theDemand;
   WitPeriod       thePer;
   int             nSigPairs;
d204 3
a206 1
   for (theItr = theDemPers; theItr (theDemand, thePer);)
d216 1
a216 1
void WitEqAllocator::eqAllocMulti (const WitDemPerDynStack & theDemPers)
d218 7
a224 7
   int             eq;
   WitDemPerDynItr theItr;
   WitDemand *     theDemand;
   WitPeriod       thePer;
   int             iter;
   float           fraction;
   float           desNewIncVol;
d228 3
a230 1
   for (theItr = theDemPers; theItr (theDemand, thePer);)
d237 3
a239 1
      for (theItr = theDemPers; theItr (theDemand, thePer);)
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d19 1
a19 1
#include <DynPer.h>
d46 9
a54 9
      const WitDemPerStack & theDemPers,
      int &                  firstDupIndex,
      int &                  secondDupIndex)
   {
   WitBoolean   dupFound;
   int          targetIndex;
   WitDemPerItr theDemPerItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
d65 1
a65 1
   for (theDemPerItr = theDemPers; theDemPerItr (theDemand, thePer);)
d81 1
a81 1
   for (theDemPerItr = theDemPers; theDemPerItr (theDemand, thePer);)
d114 1
a114 1
void WitEqAllocator::eqAlloc (const WitDemPerStack & theDemPers)
d116 5
a120 5
   WitDemPerItr theDemPerItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          firstIndex;
   int          secondIndex;
d130 1
a130 1
      for (theDemPerItr = theDemPers; theDemPerItr (theDemand, thePer);)
d141 1
a141 1
void WitEqAllocator::print (const WitDemPerStack & theDemPers)
d143 4
a146 4
   int          theIndex;
   WitDemPerItr theDemPerItr;
   WitDemand *  theDemand;
   WitPeriod    shipPer;
d150 1
a150 1
   for (theDemPerItr = theDemPers; theDemPerItr (theDemand, shipPer);)
d185 1
a185 1
WitBoolean WitEqAllocator::multiSigDDs (const WitDemPerStack & theDemPers)
d187 4
a190 4
   WitDemPerItr theDemPerItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          nSigPairs;
d194 1
a194 1
   for (theDemPerItr = theDemPers; theDemPerItr (theDemand, thePer);)
d204 1
a204 1
void WitEqAllocator::eqAllocMulti (const WitDemPerStack & theDemPers)
d206 7
a212 7
   int          eq;
   WitDemPerItr theDemPerItr;
   WitDemand *  theDemand;
   WitPeriod    thePer;
   int          iter;
   float        fraction;
   float        desNewIncVol;
d216 1
a216 1
   for (theDemPerItr = theDemPers; theDemPerItr (theDemand, thePer);)
d223 1
a223 1
      for (theDemPerItr = theDemPers; theDemPerItr (theDemand, thePer);)
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d227 1
a227 3
         WitUtil::setToMin (
            desNewIncVol,
            (float) ceil (fraction * desNewIncVol - .001));
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d227 1
a227 1
         WitUtil::updateToMin (
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

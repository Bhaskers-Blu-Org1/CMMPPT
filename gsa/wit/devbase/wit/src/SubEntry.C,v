head	1.106;
access;
symbols
	sce_5_01_20080919:1.87
	latest_sce_4_20_20060523:1.44.0.2
	sce_4_20_20060523:1.44
	latest_sce4_20_OSL:1.43.0.2
	sce_4_20_OSL:1.43
	sce_410_withVa:1.41
	sce_4_05_20040511:1.38
	sce_4_00_20040201:1.25
	nextGenBranch:1.23.0.2
	nextGenRoot:1.23
	sce_3_30_20030627:1.23
	EndRw-branch:1.19.0.4
	Root-of-EndRw:1.19
	rwToStl:1.19.0.2
	latest_sce_3_10_20010924:1.7.0.2
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.6.0.4
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.106
date	2011.09.28.23.50.35;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2011.09.24.00.28.50;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2011.08.30.20.18.19;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2011.02.18.22.28.22;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2010.09.24.18.17.22;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2010.09.24.15.46.15;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.09.22.20.21.53;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2010.09.21.21.19.13;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.09.10.20.12.07;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.09.09.20.07.59;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.03.16.22.42.29;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2010.01.06.20.42.41;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.30.18.30.37;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.29.23.24.33;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2009.12.29.21.59.14;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2009.12.25.00.10.48;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2009.11.18.19.00.02;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2009.11.17.22.54.50;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2009.11.13.19.01.26;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2008.02.25.19.37.57;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.12.11.22.00.28;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.12.06.22.01.22;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.11.15.17.15.35;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.14.17.18.55;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.13.23.02.17;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.13.20.17.40;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.09.00.40.48;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.10.15.21.50.36;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.10.02.18.32.44;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.28.22.08.27;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.11.18.55.20;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.09.11.18.09.18;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.08.01.22.41.59;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.08.18.09.41;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.06.16.28.02;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.25.18.39.11;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.24.18.52.22;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.22.20.58.38;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.22.20.44.26;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.22.15.46.53;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.14.19.05.40;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.14.16.18.39;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.11.20.43.56;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.10.21.58.11;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.10.17.22.15;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.04.23.27.12;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.03.20.05.15;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.30.21.52.10;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.26.21.32.27;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.25.19.56.55;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.05.20.23.52;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.04.22.08.18;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.03.22.04.04;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.02.23.01.16;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.28.20.04.59;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.27.19.59.33;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.10.00.08.15;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.15.22.25.30;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.10.12.20.48.11;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.09.21.15.42.27;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.17.22.50.37;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.08.16.15.49.18;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.02.17.34.14;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.23.15.55.33;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.30.21.57.57;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.06.13.16.48.47;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.02.24.23.23.57;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.13.21.50.14;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.01.21.05.12;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.31.22.56.08;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.24.22.21.33;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.23.19.14.26;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.05.22.19.59;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.04.19.53.27;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.04.16.44.30;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.03.22.36.22;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.11.18.29.15;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.18.21.12.49;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.19.16.48.29;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.13.23.06.34;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.02.22.18.53;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.11.18.53.17;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.23.18.09.17;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.05.19.31.37;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.03.22.35.22;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.03.16.01.52;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.14.32.42;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.28.19.44.59;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.19.21.56;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.25.19.14.52;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.24.18.26.08;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.22.14.32.14;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.14.02.45;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.01.19.23.36;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.20.00.44.22;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.04.22.27.54;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.21.20.03.28;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.21.22.47;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.59;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches;
next	;


desc
@@


1.106
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "SubEntry.C"
//
// Contains the implementation of class SubEntry.
//------------------------------------------------------------------------------

#include <SubEntry.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Part.h>
#include <CompMgr.h>
#include <DataWrit.h>
#include <HeurAllMgr.h>
#include <HeurModifier.h>
#include <OptStarter.h>
#include <DetOptImpMgr.h>
#include <OrigMrp.h>
#include <FSS.h>
#include <StochImpMgr.h>
#include <wit.h>
#include <IVRealArg.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------

WitSubEntry::WitSubEntry (WitBomEntry * theBomEnt, WitPart * thePart):

      WitConsEntry    (thePart, theBomEnt->mySubEntries ().nElements ()),

      mappingIndex_   (myCompMgr ()->nSubEntries ()),
      myBomEnt_       (theBomEnt),

      subCost_        (myProblem (), defSubCost ()),
      intSubVols_     (defIntSubVols ()),
      expAllowed_     (defExpAllowed ()),
      netAllowed_     (defNetAllowed ()),
      mrpNetAllowed_  (defMrpNetAllowed ()),
      expNetAversion_ (defExpNetAversion ()),
      subVol_         (myProblem (), 0.0),
      mrpSubVol_      (myProblem (), 0.0),
      fssSubVol_      (myProblem (), 0.0)
   {
   witAssert (theBomEnt->myCompMgr () == thePart->myCompMgr ());

   myCompMgr ()->insert (this);
   myBomEnt  ()->insert (this);
   myPart    ()->insert (this);
   }

//------------------------------------------------------------------------------

WitSubEntry::~WitSubEntry ()
   {
   }

//------------------------------------------------------------------------------

const WitDblFlexVec & WitSubEntry::offset ()
   {
   return
      myGlobalComp ()->independentOffsets ()?
         WitBillEntry::offset ():
         myBomEnt ()->offset ();
   }

//------------------------------------------------------------------------------

int WitSubEntry::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nSubEntries ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitSubEntry::setSubCost (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   prepSetScenSpecAttr ("subCost");

   subCost_.curDblFlexVec () = theValue;
   }

//------------------------------------------------------------------------------

void WitSubEntry::setIntSubVols (bool theValue)
   {
   prepSetUnpreAttr ();

   intSubVols_ = theValue;
   }

//------------------------------------------------------------------------------

void WitSubEntry::setExpAllowed (bool theValue)
   {
   prepSetUnpreAttr ();

   expAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitSubEntry::setNetAllowed (bool theValue)
   {
   prepSetUnpreAttr ();

   netAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitSubEntry::setMrpNetAllowed (bool theValue)
   {
   prepSetUnpostAttr ();

   mrpNetAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitSubEntry::setExpNetAversion (double theValue)
   {
   prepSetUnpostAttr ();

   expNetAversion_ = theValue;
   }

//------------------------------------------------------------------------------

void WitSubEntry::setSubVol (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   if (myProblem ()->myHeurAllMgr ()->modifiable ())
      {
      prepSetNonUnpostAttr ();

      myProblem ()->myHeurModifier ()->modifyForSubVol (this, theValue);
      }
   else
      {
      myDetOptImpMgr ()->shutDown ();

      myOptComp ()->schedOptStarter ()->beChosen ();

      prepSetUnpostAttr ();
      }

   subVol_ = theValue;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitSubEntry::storeHeurSubVol (WitPeriod thePer, double theValue)
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   subVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitSubEntry::storeOptSubVol (WitPeriod thePer, double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   subVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitSubEntry::storeStochSubCost (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   subCost_.curDblFlexVec () = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitSubEntry::storeStochSubVol (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   subVol_ = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitSubEntry::storeMrpMrpSubVol (const WitTVec <double> & theTVec)
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());

   mrpSubVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitSubEntry::storeFssFssSubVol (const WitTVec <double> & theTVec)
   {
   witAssert (myFSS ()->uploadingSoln ());

   fssSubVol_ = theTVec;
   }

//------------------------------------------------------------------------------

bool WitSubEntry::inserted ()
   {
   return (myBomEnt ()->mySubEntries ().contains (this));
   }

//------------------------------------------------------------------------------

void WitSubEntry::writeMultiObjVecs (WitObjective * theObj)
   {
   subCost_.writeDataMulti ("subCost", this, theObj);
   }

//------------------------------------------------------------------------------

void WitSubEntry::identifyInstance ()
   {
   if (myMsgFac ().mayIssue ("subEntryInstIDMsg"))
      myMsgFac () ("subEntryInstIDMsg",
         myOperationName (),
         myBomEnt ()->localIndex (),
         myBomEnt ()->myPartName (),
         localIndex (),
         myPartName ());
   }

//------------------------------------------------------------------------------

void WitSubEntry::writeSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("subEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (myBomEntIndex   ());
   myDataWriter ()->writeIntValue     (localIndex      ());
   }

//------------------------------------------------------------------------------

void WitSubEntry::copySelfInto (WitCompMgr * theCompMgr)
   {
   WitOperation * theOpn;
   WitPart *      thePart;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;

   theOpn    = theCompMgr->myMatchFor (myOperation ());
   thePart   = theCompMgr->myMatchFor (myPart      ());

   theBomEnt = theCompMgr->findBomEntry (theOpn, myBomEntIndex ());

   theSub    = new WitSubEntry (theBomEnt, thePart);

   theSub->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitSubEntry::recount ()
   {
   recountConsEntry ();

   mappingIndex_ = myCompMgr ()->nSubEntries ();

   myCompMgr ()->recountSubEntry (this);
   }

//------------------------------------------------------------------------------

void WitSubEntry::clearOptSoln  ()
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());

   subVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitSubEntry::clearStochSoln ()
   {
   WitComponent::clearStochSoln ();

   subVol_ = 0.0;
   }

//------------------------------------------------------------------------------

WitSubEntry * WitSubEntry::thisSub ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitMsgFrag WitSubEntry::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("subEntryFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitSubEntry::apiObjItrState ()
   {
   return WitAT_SUB_ENTRY;
   }

//------------------------------------------------------------------------------

bool WitSubEntry::storesOffset ()
   {
   return myGlobalComp ()->independentOffsets ();
   }

//------------------------------------------------------------------------------

void WitSubEntry::writeSolnData ()
   {
   if (subVol () == defSubVol ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("subEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (myBomEntIndex ());
   myDataWriter ()->writeIntValue     (localIndex ());

   myDataWriter ()->writeVector       ("subVol", subVol (), defSubVol ());

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitSubEntry::copyAttrsFrom (WitSubEntry * theSub)
   {
   WitConsEntry::copyAttrsFrom (theSub);

   subCost_        = theSub->subCost_;
   intSubVols_     = theSub->intSubVols_;
   expAllowed_     = theSub->expAllowed_;
   netAllowed_     = theSub->netAllowed_;
   mrpNetAllowed_  = theSub->mrpNetAllowed_;
   expNetAversion_ = theSub->expNetAversion_;
   }

//------------------------------------------------------------------------------

void WitSubEntry::display ()
   {
   myMsgFac () ("subEntryDdMsg",
      myOperationName (),
      myBomEntIndex (),
      myBomEnt ()->myPartName (),
      localIndex (),
      myPartName (),
      mappingIndex_,
      intSubVols (),
      expAllowed (),
      netAllowed (),
      mrpNetAllowed (),
      expNetAversion ());

   myProblem ()->display ("subCostDdMsg", subCost_);

   WitConsEntry::display ();
   }

//------------------------------------------------------------------------------

void WitSubEntry::clearSubVolForHeur ()
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());

   subVol_ = 0.0;
   }

//------------------------------------------------------------------------------

WitOperation * WitSubEntry::derivedOperation ()
   {
   return myOperation ();
   }

//------------------------------------------------------------------------------

WitBomEntry * WitSubEntry::derivedBomEntry ()
   {
   return myBomEnt ();
   }

//------------------------------------------------------------------------------

void WitSubEntry::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("subEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (myBomEntIndex ());
   myDataWriter ()->writeStringValue  (myPartName ());
   }

//------------------------------------------------------------------------------

void WitSubEntry::writeDataAttrs ()
   {
   WitConsEntry::writeDataAttrs ();

   if (myGlobalComp ()->independentOffsets ())
      writeOffset ();

   myDataWriter ()->writeObjVec (
        "subCost",
         subCost_,
      defSubCost ());

   myDataWriter ()->writeBool (
        "intSubVols",
         intSubVols (),
      defIntSubVols ());

   myDataWriter ()->writeBool (
        "expAllowed",
         expAllowed (),
      defExpAllowed ());

   myDataWriter ()->writeBool (
        "netAllowed",
         netAllowed (),
      defNetAllowed ());

   myDataWriter ()->writeBool (
        "mrpNetAllowed",
         mrpNetAllowed (),
      defMrpNetAllowed ());

   myDataWriter ()->writeDouble (
        "expNetAversion",
         expNetAversion (),
      defExpNetAversion ());
   }

//------------------------------------------------------------------------------

void WitSubEntry::findPrereqs (WitDelComp * & prereq1, WitDelComp * & prereq2)
   {
   prereq1 = myBomEnt ();
   prereq2 = myPart ();
   }
@


1.105
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.104
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d38 1
a38 1
WitConsEntry    (thePart, theBomEnt->mySubEntries ().nElements ()),
d40 2
a41 2
mappingIndex_   (myCompMgr ()->nSubEntries ()),
myBomEnt_       (theBomEnt),
d43 16
a58 16
subCost_        (myProblem (), defSubCost ()),
intSubVols_     (defIntSubVols ()),
expAllowed_     (defExpAllowed ()),
netAllowed_     (defNetAllowed ()),
mrpNetAllowed_  (defMrpNetAllowed ()),
expNetAversion_ (defExpNetAversion ()),
subVol_         (myProblem (), 0.0),
mrpSubVol_      (myProblem (), 0.0),
fssSubVol_      (myProblem (), 0.0)
{
witAssert (theBomEnt->myCompMgr () == thePart->myCompMgr ());

myCompMgr ()->insert (this);
myBomEnt  ()->insert (this);
myPart    ()->insert (this);
}
d63 2
a64 2
{
}
d69 6
a74 6
{
return
myGlobalComp ()->independentOffsets ()?
WitBillEntry::offset ():
myBomEnt ()->offset ();
}
d79 3
a81 3
{
return theProblem->myCompMgr ()->nSubEntries ();
}
d88 2
a89 2
{
witAssert (theValue != NULL);
d91 1
a91 1
prepSetScenSpecAttr ("subCost");
d93 2
a94 2
subCost_.curDblFlexVec () = theValue;
}
d99 2
a100 2
{
prepSetUnpreAttr ();
d102 2
a103 2
intSubVols_ = theValue;
}
d108 2
a109 2
{
prepSetUnpreAttr ();
d111 2
a112 2
expAllowed_ = theValue;
}
d117 2
a118 2
{
prepSetUnpreAttr ();
d120 2
a121 2
netAllowed_ = theValue;
}
d126 2
a127 2
{
prepSetUnpostAttr ();
d129 2
a130 2
mrpNetAllowed_ = theValue;
}
d135 2
a136 2
{
prepSetUnpostAttr ();
d138 2
a139 2
expNetAversion_ = theValue;
}
d144 2
a145 2
{
witAssert (theValue != NULL);
d147 1
a147 1
witAssert (theValue.isNonNeg (nPeriods ()));
d149 3
a151 3
if (myProblem ()->myHeurAllMgr ()->modifiable ())
{
prepSetNonUnpostAttr ();
d153 5
a157 5
myProblem ()->myHeurModifier ()->modifyForSubVol (this, theValue);
}
else
{
myDetOptImpMgr ()->shutDown ();
d159 1
a159 1
myOptComp ()->schedOptStarter ()->beChosen ();
d161 2
a162 2
prepSetUnpostAttr ();
}
d164 2
a165 2
subVol_ = theValue;
}
d172 2
a173 2
{
witAssert (myHeurAllMgr ()->updatingSoln ());
d175 2
a176 2
subVol_.elemRef (thePer) = theValue;
}
d181 2
a182 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d184 2
a185 2
subVol_.elemRef (thePer) = theValue;
}
d190 2
a191 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d193 2
a194 2
subCost_.curDblFlexVec () = theFlexVec;
}
d199 2
a200 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d202 2
a203 2
subVol_ = theFlexVec;
}
d208 2
a209 2
{
witAssert (myOrigMrpExp ()->uploadingSoln ());
d211 2
a212 2
mrpSubVol_ = theTVec;
}
d217 2
a218 2
{
witAssert (myFSS ()->uploadingSoln ());
d220 2
a221 2
fssSubVol_ = theTVec;
}
d226 3
a228 3
{
return (myBomEnt ()->mySubEntries ().contains (this));
}
d233 3
a235 3
{
subCost_.writeDataMulti ("subCost", this, theObj);
}
d240 9
a248 9
{
if (myMsgFac ().mayIssue ("subEntryInstIDMsg"))
myMsgFac () ("subEntryInstIDMsg",
myOperationName (),
myBomEnt ()->localIndex (),
myBomEnt ()->myPartName (),
localIndex (),
myPartName ());
}
d253 7
a259 7
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("subEntry");
myDataWriter ()->writeStringValue  (myOperationName ());
myDataWriter ()->writeIntValue     (myBomEntIndex   ());
myDataWriter ()->writeIntValue     (localIndex      ());
}
d264 5
a268 5
{
WitOperation * theOpn;
WitPart *      thePart;
WitBomEntry *  theBomEnt;
WitSubEntry *  theSub;
d270 2
a271 2
theOpn    = theCompMgr->myMatchFor (myOperation ());
thePart   = theCompMgr->myMatchFor (myPart      ());
d273 1
a273 1
theBomEnt = theCompMgr->findBomEntry (theOpn, myBomEntIndex ());
d275 1
a275 1
theSub    = new WitSubEntry (theBomEnt, thePart);
d277 2
a278 2
theSub->copyAttrsFrom (this);
}
d283 2
a284 2
{
recountConsEntry ();
d286 1
a286 1
mappingIndex_ = myCompMgr ()->nSubEntries ();
d288 2
a289 2
myCompMgr ()->recountSubEntry (this);
}
d294 2
a295 2
{
witAssert (myDetOptImpMgr ()->clearingSoln ());
d297 2
a298 2
subVol_ = 0.0;
}
d303 2
a304 2
{
WitComponent::clearStochSoln ();
d306 2
a307 2
subVol_ = 0.0;
}
d312 3
a314 3
{
return this;
}
d319 3
a321 3
{
return myMsgFac ().myFrag ("subEntryFrag");
}
d326 3
a328 3
{
return WitAT_SUB_ENTRY;
}
d333 3
a335 3
{
return myGlobalComp ()->independentOffsets ();
}
d340 9
a348 9
{
if (subVol () == defSubVol ())
return;

myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("subEntry");
myDataWriter ()->writeStringValue  (myOperationName ());
myDataWriter ()->writeIntValue     (myBomEntIndex ());
myDataWriter ()->writeIntValue     (localIndex ());
d350 1
a350 1
myDataWriter ()->writeVector       ("subVol", subVol (), defSubVol ());
d352 2
a353 2
myDataWriter ()->writeEndCommand ();
}
d358 2
a359 2
{
WitConsEntry::copyAttrsFrom (theSub);
d361 7
a367 7
subCost_        = theSub->subCost_;
intSubVols_     = theSub->intSubVols_;
expAllowed_     = theSub->expAllowed_;
netAllowed_     = theSub->netAllowed_;
mrpNetAllowed_  = theSub->mrpNetAllowed_;
expNetAversion_ = theSub->expNetAversion_;
}
d372 13
a384 13
{
myMsgFac () ("subEntryDdMsg",
myOperationName (),
myBomEntIndex (),
myBomEnt ()->myPartName (),
localIndex (),
myPartName (),
mappingIndex_,
intSubVols (),
expAllowed (),
netAllowed (),
mrpNetAllowed (),
expNetAversion ());
d386 1
a386 1
myProblem ()->display ("subCostDdMsg", subCost_);
d388 2
a389 2
WitConsEntry::display ();
}
d394 2
a395 2
{
witAssert (myHeurAllMgr ()->updatingSoln ());
d397 2
a398 2
subVol_ = 0.0;
}
d403 3
a405 3
{
return myOperation ();
}
d410 3
a412 3
{
return myBomEnt ();
}
d417 7
a423 7
{
myDataWriter ()->writeFirstKeyWord ("add");
myDataWriter ()->writeKeyWord      ("subEntry");
myDataWriter ()->writeStringValue  (myOperationName ());
myDataWriter ()->writeIntValue     (myBomEntIndex ());
myDataWriter ()->writeStringValue  (myPartName ());
}
d428 2
a429 2
{
WitConsEntry::writeDataAttrs ();
d431 2
a432 2
if (myGlobalComp ()->independentOffsets ())
writeOffset ();
d434 30
a463 30
myDataWriter ()->writeObjVec (
"subCost",
subCost_,
defSubCost ());

myDataWriter ()->writeBool (
"intSubVols",
intSubVols (),
defIntSubVols ());

myDataWriter ()->writeBool (
"expAllowed",
expAllowed (),
defExpAllowed ());

myDataWriter ()->writeBool (
"netAllowed",
netAllowed (),
defNetAllowed ());

myDataWriter ()->writeBool (
"mrpNetAllowed",
mrpNetAllowed (),
defMrpNetAllowed ());

myDataWriter ()->writeDouble (
"expNetAversion",
expNetAversion (),
defExpNetAversion ());
}
d468 4
a471 4
{
prereq1 = myBomEnt ();
prereq2 = myPart ();
}
@


1.103
log
@Fixed a bug in optInitMethod
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d38 1
a38 1
      WitConsEntry    (thePart, theBomEnt->mySubEntries ().nElements ()),
d40 2
a41 2
      mappingIndex_   (myCompMgr ()->nSubEntries ()),
      myBomEnt_       (theBomEnt),
d43 16
a58 16
      subCost_        (myProblem (), defSubCost ()),
      intSubVols_     (defIntSubVols ()),
      expAllowed_     (defExpAllowed ()),
      netAllowed_     (defNetAllowed ()),
      mrpNetAllowed_  (defMrpNetAllowed ()),
      expNetAversion_ (defExpNetAversion ()),
      subVol_         (myProblem (), 0.0),
      mrpSubVol_      (myProblem (), 0.0),
      fssSubVol_      (myProblem (), 0.0)
   {
   witAssert (theBomEnt->myCompMgr () == thePart->myCompMgr ());

   myCompMgr ()->insert (this);
   myBomEnt  ()->insert (this);
   myPart    ()->insert (this);
   }
d63 2
a64 2
   {
   }
d69 6
a74 6
   {
   return
      myGlobalComp ()->independentOffsets ()?
         WitBillEntry::offset ():
         myBomEnt ()->offset ();
   }
d79 3
a81 3
   {
   return theProblem->myCompMgr ()->nSubEntries ();
   }
d88 2
a89 2
   {
   witAssert (theValue != NULL);
d91 1
a91 1
   prepSetScenSpecAttr ("subCost");
d93 2
a94 2
   subCost_.curDblFlexVec () = theValue;
   }
d99 2
a100 2
   {
   prepSetUnpreAttr ();
d102 2
a103 2
   intSubVols_ = theValue;
   }
d108 2
a109 2
   {
   prepSetUnpreAttr ();
d111 2
a112 2
   expAllowed_ = theValue;
   }
d117 2
a118 2
   {
   prepSetUnpreAttr ();
d120 2
a121 2
   netAllowed_ = theValue;
   }
d126 2
a127 2
   {
   prepSetUnpostAttr ();
d129 2
a130 2
   mrpNetAllowed_ = theValue;
   }
d135 2
a136 2
   {
   prepSetUnpostAttr ();
d138 2
a139 2
   expNetAversion_ = theValue;
   }
d144 2
a145 2
   {
   witAssert (theValue != NULL);
d147 1
a147 1
   witAssert (theValue.isNonNeg (nPeriods ()));
d149 3
a151 3
   if (myProblem ()->myHeurAllMgr ()->modifiable ())
      {
      prepSetNonUnpostAttr ();
d153 5
a157 5
      myProblem ()->myHeurModifier ()->modifyForSubVol (this, theValue);
      }
   else
      {
      myDetOptImpMgr ()->shutDown ();
d159 1
a159 1
      myOptComp ()->schedOptStarter ()->beChosen ();
d161 2
a162 2
      prepSetUnpostAttr ();
      }
d164 2
a165 2
   subVol_ = theValue;
   }
d172 2
a173 2
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());
d175 2
a176 2
   subVol_.elemRef (thePer) = theValue;
   }
d181 2
a182 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d184 2
a185 2
   subVol_.elemRef (thePer) = theValue;
   }
d190 2
a191 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d193 2
a194 2
   subCost_.curDblFlexVec () = theFlexVec;
   }
d199 2
a200 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d202 2
a203 2
   subVol_ = theFlexVec;
   }
d208 2
a209 2
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());
d211 2
a212 2
   mrpSubVol_ = theTVec;
   }
d217 2
a218 2
   {
   witAssert (myFSS ()->uploadingSoln ());
d220 2
a221 2
   fssSubVol_ = theTVec;
   }
d226 3
a228 3
   {
   return (myBomEnt ()->mySubEntries ().contains (this));
   }
d233 3
a235 3
   {
   subCost_.writeDataMulti ("subCost", this, theObj);
   }
d240 9
a248 9
   {
   if (myMsgFac ().mayIssue ("subEntryInstIDMsg"))
      myMsgFac () ("subEntryInstIDMsg",
         myOperationName (),
         myBomEnt ()->localIndex (),
         myBomEnt ()->myPartName (),
         localIndex (),
         myPartName ());
   }
d253 7
a259 7
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("subEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (myBomEntIndex   ());
   myDataWriter ()->writeIntValue     (localIndex      ());
   }
d264 5
a268 5
   {
   WitOperation * theOpn;
   WitPart *      thePart;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
d270 2
a271 2
   theOpn    = theCompMgr->myMatchFor (myOperation ());
   thePart   = theCompMgr->myMatchFor (myPart      ());
d273 1
a273 1
   theBomEnt = theCompMgr->findBomEntry (theOpn, myBomEntIndex ());
d275 1
a275 1
   theSub    = new WitSubEntry (theBomEnt, thePart);
d277 2
a278 2
   theSub->copyAttrsFrom (this);
   }
d283 2
a284 2
   {
   recountConsEntry ();
d286 1
a286 1
   mappingIndex_ = myCompMgr ()->nSubEntries ();
d288 2
a289 2
   myCompMgr ()->recountSubEntry (this);
   }
d294 2
a295 2
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());
d297 2
a298 2
   subVol_ = 0.0;
   }
d303 2
a304 2
   {
   WitComponent::clearStochSoln ();
d306 2
a307 2
   subVol_ = 0.0;
   }
d312 3
a314 3
   {
   return this;
   }
d319 3
a321 3
   {
   return myMsgFac ().myFrag ("subEntryFrag");
   }
d326 3
a328 3
   {
   return WitAT_SUB_ENTRY;
   }
d333 3
a335 3
   {
   return myGlobalComp ()->independentOffsets ();
   }
d340 9
a348 9
   {
   if (subVol () == defSubVol ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("subEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (myBomEntIndex ());
   myDataWriter ()->writeIntValue     (localIndex ());
d350 1
a350 1
   myDataWriter ()->writeVector       ("subVol", subVol (), defSubVol ());
d352 2
a353 2
   myDataWriter ()->writeEndCommand ();
   }
d358 2
a359 2
   {
   WitConsEntry::copyAttrsFrom (theSub);
d361 7
a367 7
   subCost_        = theSub->subCost_;
   intSubVols_     = theSub->intSubVols_;
   expAllowed_     = theSub->expAllowed_;
   netAllowed_     = theSub->netAllowed_;
   mrpNetAllowed_  = theSub->mrpNetAllowed_;
   expNetAversion_ = theSub->expNetAversion_;
   }
d372 13
a384 13
   {
   myMsgFac () ("subEntryDdMsg",
      myOperationName (),
      myBomEntIndex (),
      myBomEnt ()->myPartName (),
      localIndex (),
      myPartName (),
      mappingIndex_,
      intSubVols (),
      expAllowed (),
      netAllowed (),
      mrpNetAllowed (),
      expNetAversion ());
d386 1
a386 1
   myProblem ()->display ("subCostDdMsg", subCost_);
d388 2
a389 2
   WitConsEntry::display ();
   }
d394 2
a395 2
   {
   witAssert (myHeurAllMgr ()->updatingSoln ());
d397 2
a398 2
   subVol_ = 0.0;
   }
d403 3
a405 3
   {
   return myOperation ();
   }
d410 3
a412 3
   {
   return myBomEnt ();
   }
d417 7
a423 7
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("subEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (myBomEntIndex ());
   myDataWriter ()->writeStringValue  (myPartName ());
   }
d428 2
a429 2
   {
   WitConsEntry::writeDataAttrs ();
d431 2
a432 2
   if (myGlobalComp ()->independentOffsets ())
      writeOffset ();
d434 30
a463 30
   myDataWriter ()->writeObjVec (
        "subCost",
         subCost_,
      defSubCost ());

   myDataWriter ()->writeBool (
        "intSubVols",
         intSubVols (),
      defIntSubVols ());

   myDataWriter ()->writeBool (
        "expAllowed",
         expAllowed (),
      defExpAllowed ());

   myDataWriter ()->writeBool (
        "netAllowed",
         netAllowed (),
      defNetAllowed ());

   myDataWriter ()->writeBool (
        "mrpNetAllowed",
         mrpNetAllowed (),
      defMrpNetAllowed ());

   myDataWriter ()->writeDouble (
        "expNetAversion",
         expNetAversion (),
      defExpNetAversion ());
   }
d468 4
a471 4
   {
   prereq1 = myBomEnt ();
   prereq2 = myPart ();
   }
@


1.102
log
@Modifiable heuristic allocation
@
text
@d157 2
@


1.101
log
@Heuristic Adjustment
@
text
@d23 1
a23 1
#include <HeurAdjuster.h>
d149 1
a149 1
   if (myProblem ()->myHeurAllMgr ()->adjustMode ())
d153 1
a153 1
      myProblem ()->myHeurAdjuster ()->adjustForSubVol (this, theValue);
@


1.100
log
@Heuristic Adjustment
@
text
@d149 1
a149 1
   if (myProblem ()->myHeurAllMgr ()->heurAdjustActive ())
@


1.99
log
@Heuristic Adjustment
@
text
@d149 1
a149 1
   if (myProblem ()->myHeurAdjuster ()->active ())
@


1.98
log
@Heuristic Adjustment
@
text
@d23 1
a23 1
#include <HeurAdjMgr.h>
d149 1
a149 1
   if (myProblem ()->myHeurAdjMgr ()->active ())
d153 1
a153 1
      myProblem ()->myHeurAdjMgr ()->adjustForSubVol (this, theValue);
@


1.97
log
@Heuristic Adjustment
@
text
@d152 2
@


1.96
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d23 1
d149 7
a155 1
   myOptComp ()->schedOptStarter ()->beChosen ();
d157 2
a158 1
   prepSetUnpostAttr ();
@


1.95
log
@Multi-objective mode
@
text
@d17 1
a17 1
#include <Global.h>
@


1.94
log
@Multi-Objective Mode
@
text
@d42 1
a42 1
      subCostObjVec_  (myProblem (), defSubCost ()),
d92 1
a92 1
   subCostObjVec_ = theValue;
d181 1
a181 1
   subCostObjVec_ = theFlexVec;
d222 1
a222 1
   subCostObjVec_.writeDataMulti ("subCost", this, theObj);
d349 1
a349 1
   subCostObjVec_  = theSub->subCostObjVec_;
d374 1
a374 1
   myProblem ()->display ("subCostDdMsg", subCostObjVec_);
d424 1
a424 1
         subCostObjVec_,
@


1.93
log
@Multi-Objective Mode
@
text
@d42 1
a42 1
      subCost_        (myProblem (), defSubCost ()),
d92 1
a92 1
   subCost_ = theValue;
d181 1
a181 1
   subCost_ = theFlexVec;
d222 1
a222 1
   subCost_.writeDataMulti ("subCost", this, theObj);
d349 1
a349 1
   subCost_        = theSub->subCost_;
d374 1
a374 1
   myProblem ()->display ("subCostDdMsg", subCost_);
d424 1
a424 1
         subCost_,
@


1.92
log
@Multi-Objective Mode
@
text
@d42 1
a42 1
      subCost_        (myProblem ()),
@


1.91
log
@Multi-Objective Mode
@
text
@d42 1
a42 1
      subCost_        (myProblem (), defSubCost ()),
d220 7
d374 1
a374 1
   myProblem ()->display ("subCostDdMsg", subCost ());
d422 3
a424 3
   myDataWriter ()->writeVector (
       "subCost",
        subCost (),
@


1.90
log
@Removing objective #2.
@
text
@d233 11
@


1.89
log
@Removing objective #2.
@
text
@a22 1
#include <ObjFunc.h>
@


1.88
log
@Removing objective #2.
@
text
@d357 1
a357 1
   objChoice ()->displayForObj1 ("subCostDdMsg", subCost ());
@


1.87
log
@Object name change.
@
text
@a42 1
      obj2SubPenalty_ (defObj2SubPenalty ()),
a86 11
void WitSubEntry::setObj2SubPenalty (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   obj2SubPenalty_ = theValue;
   }

//------------------------------------------------------------------------------

a331 1
   obj2SubPenalty_ = theSub->obj2SubPenalty_;
a358 2
   objChoice ()->displayForObj2 ("obj2SubPenaltyDdMsg", obj2SubPenalty ());

a404 5
   myDataWriter ()->writeDouble (
        "obj2SubPenalty",
         obj2SubPenalty (),
      defObj2SubPenalty ());

@


1.86
log
@Stochastic Implosion
@
text
@d38 1
a38 2
      WitConsEntry    (  preconstruct (theBomEnt, thePart),
                         theBomEnt->mySubEntries ().nElements ()),
d54 2
a387 12
WitPart * WitSubEntry::preconstruct (WitBomEntry * theBomEnt, WitPart * thePart)
   {
   witAssert (theBomEnt != NULL);
   witAssert (thePart   != NULL);

   witAssert (theBomEnt->myCompMgr () == thePart->myCompMgr ());

   return thePart;
   }

//------------------------------------------------------------------------------

@


1.85
log
@Stochastic Implosion
@
text
@d102 1
a102 1
   prepSetUnpostAttr ();
d189 9
@


1.84
log
@Stochastic Implosion
@
text
@d238 4
a241 2
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
d243 2
a244 4
   theBomEnt =
      theCompMgr->findBomEntry (
         theCompMgr->match (myOperation ()),
         myBomEntIndex ());
d246 3
a248 1
   theSub = new WitSubEntry (theBomEnt, theCompMgr->match (myPart ()));
@


1.83
log
@Stochastic Implosion
@
text
@d189 1
a189 1
void WitSubEntry::storeStochSubVol (const WitDblFlexVec & theValue)
d193 1
a193 1
   subVol_ = theValue;
d198 1
a198 1
void WitSubEntry::storeMrpMrpSubVol (const WitTVec <double> & theValue)
d202 1
a202 1
   mrpSubVol_ = theValue;
d207 1
a207 1
void WitSubEntry::storeFssFssSubVol (const WitTVec <double> & theValue)
d211 1
a211 1
   fssSubVol_ = theValue;
@


1.82
log
@Stochastic Implosion
@
text
@d207 9
a272 7
void WitSubEntry::passFssRefs ()
   {
   myFSS ()->receiveSubEntryRefs (fssSubVol_);
   }

//------------------------------------------------------------------------------

@


1.81
log
@Stochastic Implosion
@
text
@d198 9
a263 7
void WitSubEntry::passMrpRefs ()
   {
   myOrigMrpExp ()->receiveSubEntryRefs (mrpSubVol_);
   }

//------------------------------------------------------------------------------

@


1.80
log
@Stochastic Implosion
@
text
@d180 9
d246 5
a250 3
void WitSubEntry::importOptSoln ()
   {
   myDetOptImpMgr ()->exportSoln (this, subVol_);
@


1.79
log
@Stochastic Implosion
@
text
@d22 1
d171 9
d352 9
@


1.78
log
@Stochastic Implosion
@
text
@d248 9
@


1.77
log
@Stochastic Implosion
@
text
@d170 1
a170 1
void WitSubEntry::storeStochSubVol (const WitTVec <double> & theValue)
@


1.76
log
@Stochastic Implosion
@
text
@d172 3
a174 1
   storeStochAttr (subVol_, theValue);
@


1.75
log
@Stochastic Implosion
@
text
@d170 1
a170 1
void WitSubEntry::loadInStochSubVol (const WitTVec <double> & theValue)
d172 1
a172 1
   loadInStochAttr (subVol_, theValue);
@


1.74
log
@Stochastic Implosion
@
text
@d170 7
a231 7
void WitSubEntry::importStochSoln ()
   {
   myStochImpMgr ()->exportSoln (this, subVol_);
   }

//------------------------------------------------------------------------------

@


1.73
log
@Stochastic Implosion
@
text
@d24 1
a24 1
#include <OptImp.h>
d220 1
a220 1
   myOptImploder ()->exportSoln (this, subVol_);
@


1.72
log
@Stochastic Implosion
@
text
@d218 1
a218 1
void WitSubEntry::acquireOptSoln ()
d220 1
a220 1
   myOptImploder ()->provideSoln (this, subVol_);
d225 1
a225 1
void WitSubEntry::passMrpRefs ()
d227 1
a227 1
   myOrigMrpExp ()->receiveSubEntryRefs (mrpSubVol_);
d232 1
a232 1
void WitSubEntry::passFssRefs ()
d234 1
a234 1
   myFSS ()->receiveSubEntryRefs (fssSubVol_);
d239 1
a239 1
void WitSubEntry::passStochRefs ()
d241 1
a241 1
   myStochImpMgr ()->receiveSubEntryRefs (subVol_);
@


1.71
log
@Stochastic Implosion
@
text
@d220 1
a220 1
   myOptImploder ()->provideSubEntrySoln (subVol_);
@


1.70
log
@Stochastic Implosion
@
text
@d218 1
a218 1
void WitSubEntry::importOptImpSoln (WitPeriod thePer)
d220 1
a220 1
   subVol_.elemRef (thePer) = myOptImploder ()->subVol (this, thePer);
@


1.69
log
@Stochastic Implosion
@
text
@d225 1
a225 1
void WitSubEntry::passMrpData ()
d227 1
a227 1
   myOrigMrpExp ()->receiveSubEntryData (mrpSubVol_);
d232 1
a232 1
void WitSubEntry::passFssData ()
d234 1
a234 1
   myFSS ()->receiveSubEntryData (fssSubVol_);
d239 1
a239 1
void WitSubEntry::passStochData ()
d241 1
a241 2
   myStochImpMgr ()->
      receiveSubEntryData (subVol_);
@


1.68
log
@Stochastic Implosion
@
text
@d227 1
a227 1
   myOrigMrpExp ()->receiveData (this, mrpSubVol_);
@


1.67
log
@Stochastic Implosion
@
text
@d234 1
a234 1
   myFSS ()->receiveData (this, fssSubVol_);
@


1.66
log
@Stochastic Implosion
@
text
@d239 1
a239 1
void WitSubEntry::clearStochSoln ()
d241 2
a242 8
   subVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitSubEntry::restoreStochSoln ()
   {
   subVol_ = myStochImpMgr ()->subVol (this);
@


1.65
log
@Stochastic Implosion
@
text
@d225 1
a225 1
void WitSubEntry::importMrpSoln ()
d227 1
a227 1
   mrpSubVol_ = myOrigMrpExp ()->mrpSubVol (this);
@


1.64
log
@Stochastic Implosion
@
text
@d26 1
d232 7
@


1.63
log
@Stochastic Implosion
@
text
@d25 1
d224 7
@


1.62
log
@Stochastic Implosion
@
text
@a187 14
WitMsgFrag WitSubEntry::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("subEntryFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitSubEntry::apiObjItrState ()
   {
   return WitAT_SUB_ENTRY;
   }

//------------------------------------------------------------------------------

d244 14
@


1.61
log
@Stochastic Implosion
@
text
@d24 1
d230 7
@


1.60
log
@Stochastic Implosion
@
text
@d24 1
d229 14
@


1.59
log
@Stochastic Implosion
@
text
@a23 1
#include <StochImpMgr.h>
a156 2
   myStochImpMgr ()->prepSetStochAttr ();

@


1.58
log
@Stochastic Implosion
@
text
@d24 1
a24 1
#include <StochMgr.h>
d158 1
a158 1
   myStochMgr ()->prepSetStochAttr ();
@


1.57
log
@Stochastic Implosion
@
text
@d24 1
d158 2
@


1.56
log
@Stochastic implosion.
@
text
@d86 1
a86 1
   settingUnpostAttr ();
d97 1
a97 1
   settingUnpostAttr ();
d106 1
a106 1
   settingUnpreAttr ();
d115 1
a115 1
   settingUnpreAttr ();
d124 1
a124 1
   settingUnpreAttr ();
d133 1
a133 1
   settingUnpostAttr ();
d142 1
a142 1
   settingUnpostAttr ();
d157 1
a157 1
   settingUnpostAttr ();
@


1.55
log
@Stochastic Implosion.
@
text
@a22 1
#include <Pre.h>
d86 1
a86 1
   myProblem ()->resetSoln ();
d97 1
a97 1
   myProblem ()->resetSoln ();
d106 1
a106 1
   myPreprocessor ()->unpreprocess ();
d115 1
a115 1
   myPreprocessor ()->unpreprocess ();
d124 1
a124 1
   myPreprocessor ()->unpreprocess ();
d133 1
a133 1
   myProblem ()->resetSoln ();
d142 1
a142 1
   myProblem ()->resetSoln ();
d157 1
a157 1
   myProblem ()->resetSoln ();
@


1.54
log
@Stochastic Implosion.
@
text
@a50 2
   forbidAddStochAct ();

@


1.53
log
@Stochastic implosion.
@
text
@d27 1
d51 1
a51 1
   forbidAddStochAct ("subEntryFrag");
a175 7
WitMsgFragID WitSubEntry::classFragID ()
   {
   return "subEntryFrag";
   }

//------------------------------------------------------------------------------

d189 7
@


1.52
log
@[disallowed backlog]
@
text
@d50 2
@


1.51
log
@Rescinded all changed made since 1/31/07.
@
text
@d16 1
d19 1
a23 4
#include <FSS.h>
#include <OrigMrp.h>
#include <HeurAllMgr.h>
#include <OptImp.h>
a298 10
void WitSubEntry::transmitDMPs ()
   {
   WitHeurAllMgr ::receiveDMPs (& WitSubEntry::subVol_);
   WitOptImploder::receiveDMPs (& WitSubEntry::subVol_);
   WitOrigMrpExp ::receiveDMPs (& WitSubEntry::mrpSubVol_);
   WitFSS        ::receiveDMPs (& WitSubEntry::fssSubVol_);
   }

//------------------------------------------------------------------------------

@


1.50
log
@[disallowed backlog]
@
text
@a37 4
      subVol_         (myProblem ()),
      mrpSubVol_      (myProblem ()),
      fssSubVol_      (myProblem ()),

d47 4
a50 1
      expNetAversion_ (defExpNetAversion ())
d153 9
a161 1
   myOptImploder ()->setSubVol (this, theValue);
d301 10
@


1.49
log
@witCopy<Object>Data
@
text
@d38 4
d51 1
a51 4
      expNetAversion_ (defExpNetAversion ()),
      subVol_         (myProblem (), 0.0),
      mrpSubVol_      (myProblem (), 0.0),
      fssSubVol_      (myProblem (), 0.0)
d154 1
a154 9
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   myOptComp ()->schedOptStarter ()->beChosen ();

   myProblem ()->resetSoln ();

   subVol_ = theValue;
a293 10
void WitSubEntry::transmitDMPs ()
   {
   WitHeurAllMgr ::receiveDMPs (& WitSubEntry::subVol_);
   WitOptImploder::receiveDMPs (& WitSubEntry::subVol_);
   WitOrigMrpExp ::receiveDMPs (& WitSubEntry::mrpSubVol_);
   WitFSS        ::receiveDMPs (& WitSubEntry::fssSubVol_);
   }

//------------------------------------------------------------------------------

@


1.48
log
@External opt implosion.
@
text
@d262 15
a392 15
void WitSubEntry::copyAttrsFrom (WitSubEntry * theSub)
   {
   WitConsEntry::copyAttrsFrom (theSub);

   obj2SubPenalty_ = theSub->obj2SubPenalty_;
   subCost_        = theSub->subCost_;
   intSubVols_     = theSub->intSubVols_;
   expAllowed_     = theSub->expAllowed_;
   netAllowed_     = theSub->netAllowed_;
   mrpNetAllowed_  = theSub->mrpNetAllowed_;
   expNetAversion_ = theSub->expNetAversion_;
   }

//------------------------------------------------------------------------------

@


1.47
log
@App controlled opt implosion.
@
text
@d43 1
a43 1
      intConSubVols_  (defIntConSubVols ()),
d106 1
a106 1
void WitSubEntry::setIntConSubVols (bool theValue)
d110 1
a110 1
   intConSubVols_ = theValue;
d271 1
a271 1
      intConSubVols (),
d351 3
a353 3
        "intConSubVols",
         intConSubVols (),
      defIntConSubVols ());
d384 1
a384 1
   intConSubVols_  = theSub->intConSubVols_;
@


1.46
log
@Integrality constraints.
@
text
@d17 1
a19 1
#include <DataAlt.h>
d26 1
d28 1
d86 5
a90 1
   obj2SubPenalty_ = prepNonNegDouble (theValue, postprocAlt ());
d97 5
a101 1
   subCost_ = prepDblVec (theValue, postprocAlt ());
d108 3
a110 1
   intConSubVols_ = prepBool (theValue, preprocAlt ());
d117 3
a119 1
   expAllowed_ = prepBool (theValue, preprocAlt ());
d126 3
a128 1
   netAllowed_ = prepBool (theValue, preprocAlt ());
d135 3
a137 1
   mrpNetAllowed_ = prepBool (theValue, postprocAlt ());
d144 3
a146 1
   expNetAversion_ = prepDouble (theValue, postprocAlt ());
d153 9
a161 1
   subVol_ = prepSchedVec (theValue, postprocAlt ());
@


1.45
log
@Opt implosion with integrality constraints.
@
text
@d41 1
a41 1
      intSubVols_     (defIntSubVols ()),
d96 1
a96 1
void WitSubEntry::setIntSubVols (bool theValue)
d98 1
a98 1
   intSubVols_ = prepBool (theValue, preprocAlt ());
d243 1
a243 1
      intSubVols (),
d323 3
a325 3
        "intSubVols",
         intSubVols (),
      defIntSubVols ());
d356 1
a356 1
   intSubVols_     = theSub->intSubVols_;
@


1.44
log
@Updated the copyright date on all source files.
@
text
@d41 1
d96 7
d243 1
d323 5
d356 1
@


1.43
log
@Fixed a bug:
   subEntry.netAllowed was not being copied by witCopyData ().
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.42
log
@[multi-thread]
@
text
@d341 1
d343 1
a345 1
   subCost_        = theSub->subCost_;
@


1.41
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@a200 28
void WitSubEntry::loadMrp ()
   {
   myOrigMrpExp ()->loadDataFrom (this, mrpSubVol_);
   }

//------------------------------------------------------------------------------

void WitSubEntry::loadFss ()
   {
   myFSS ()->loadDataFrom (this, fssSubVol_);
   }

//------------------------------------------------------------------------------

void WitSubEntry::loadHeur ()
   {
   myHeurAllMgr ()->loadDataFrom (this, subVol_);
   }

//------------------------------------------------------------------------------

void WitSubEntry::loadOpt ()
   {
   myOptImploder ()->loadDataFrom (this, subVol_);
   }

//------------------------------------------------------------------------------

d249 10
@


1.40
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d40 1
a40 1
      obj1SubCost_    (myProblem (), defObj1SubCost ()),
d88 1
a88 1
void WitSubEntry::setObj1SubCost (const WitIVRealArg & theValue)
d90 1
a90 1
   obj1SubCost_ = prepDblVec (theValue, postprocAlt ());
d268 1
a268 1
   objChoice ()->displayForObj1 ("obj1SubDdMsg", obj1SubCost ());
d327 3
a329 3
       "obj1SubCost",
        obj1SubCost (),
      defObj1SubCost ());
d358 5
a362 5
   obj2SubPenalty_ = theSub->obj2SubPenalty ();
   expAllowed_     = theSub->expAllowed     ();
   mrpNetAllowed_  = theSub->mrpNetAllowed  ();
   expNetAversion_ = theSub->expNetAversion ();
   obj1SubCost_    = theSub->obj1SubCost ();
@


1.39
log
@Vector PropRt.
@
text
@d90 1
a90 1
   obj1SubCost_ = prepObj1DblVec (theValue, postprocAlt ());
@


1.38
log
@Double Precision.
@
text
@d88 1
a88 1
void WitSubEntry::setObj1SubCost (const WitInVecRA & theValue)
d123 1
a123 1
void WitSubEntry::setSubVol (const WitInVecRA & theValue)
@


1.37
log
@Double Precision.
@
text
@d90 1
a90 1
   obj1SubCost_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
d125 1
a125 1
   subVol_.convCopy (prepSchedVec (theValue, postprocAlt ()));
@


1.36
log
@Double Precision.
@
text
@d362 1
a362 2

   obj1SubCost_.copy (theSub->obj1SubCost ());
@


1.35
log
@Double Precision.
@
text
@a87 7
void WitSubEntry::setObj1SubCost (const float * theValue)
   {
   obj1SubCost_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
   }

//------------------------------------------------------------------------------

a118 7
   }

//------------------------------------------------------------------------------

void WitSubEntry::setSubVol (const float * theValue)
   {
   subVol_.convCopy (prepSchedVec (theValue, postprocAlt ()));
@


1.34
log
@Double Precision.
@
text
@d95 7
d131 7
@


1.33
log
@Double Precision.
@
text
@d90 1
a90 1
   obj1SubCost_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
@


1.32
log
@Double Precision.
@
text
@d62 1
a62 1
const WitFlexVec <double> & WitSubEntry::offset ()
d90 1
a90 1
   convCopy (obj1SubCost_, prepObj1FloatVec (theValue, postprocAlt ()));
d125 1
a125 1
   convCopy (subVol_, prepSchedVec (theValue, postprocAlt ()));
@


1.31
log
@Double Precision.
@
text
@d62 1
a62 1
const WitRealVec & WitSubEntry::offset ()
d90 1
a90 1
   obj1SubCost_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
@


1.30
log
@Double Precision.
@
text
@d62 1
a62 1
const WitFlexVec <float> & WitSubEntry::offset ()
@


1.29
log
@Double Precision.
@
text
@d90 1
a90 1
   obj1SubCost_.copyCVec (prepObj1FloatVec (theValue, postprocAlt ()));
@


1.28
log
@Double Precision.
@
text
@d125 1
a125 1
   copyInto (subVol_, prepSchedVec (theValue, postprocAlt ()));
@


1.27
log
@Continued double precision.
@
text
@d90 1
a90 1
   obj1SubCost_.copyCvector (prepObj1FloatVec (theValue, postprocAlt ()));
@


1.26
log
@Continued double precision.
@
text
@d81 1
a81 1
void WitSubEntry::setObj2SubPenalty (StrDbl theValue)
d83 1
a83 1
   obj2SubPenalty_ = prepNonNegStrDbl (theValue, postprocAlt ());
d116 1
a116 1
void WitSubEntry::setExpNetAversion (StrDbl theValue)
d118 1
a118 1
   expNetAversion_ = prepStrDbl (theValue, postprocAlt ());
d321 1
a321 1
   myDataWriter ()->writeStrDbl (
d346 1
a346 1
   myDataWriter ()->writeStrDbl (
@


1.25
log
@Removed a bad function overload.
@
text
@d81 1
a81 1
void WitSubEntry::setObj2SubPenalty (float theValue)
d83 1
a83 1
   obj2SubPenalty_ = prepNonNegFloat (theValue, postprocAlt ());
d116 1
a116 1
void WitSubEntry::setExpNetAversion (float theValue)
d118 1
a118 1
   expNetAversion_ = prepFloat (theValue, postprocAlt ());
d321 1
a321 1
   myDataWriter ()->writeFloat (
d346 1
a346 1
   myDataWriter ()->writeFloat (
@


1.24
log
@Continued implementation of post-implosion pegging.
@
text
@d194 1
a194 1
WitSubEntry * WitSubEntry::mySub ()
@


1.23
log
@Made modifications to improve the speed of witPurgeData.
@
text
@a27 1
#include <FlexVecI.h>
@


1.22
log
@Continued implementation of proportionate routing.
@
text
@d149 7
a155 6
   myMsgFac () ("subEntryInstIDMsg",
      myOperationName (),
      myBomEnt ()->localIndex (),
      myBomEnt ()->myPartName (),
      localIndex (),
      myPartName ());
@


1.21
log
@Continued implementation of proportionate routing.
@
text
@d194 1
a194 1
void WitSubEntry::getSubEntry (WitSubEntry * & theSub)
d196 1
a196 1
   theSub = this;
@


1.20
log
@Internal changes.
@
text
@d72 7
@


1.19
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d89 1
a89 1
void WitSubEntry::setExpAllowed (WitBoolean theValue)
d91 1
a91 1
   expAllowed_ = prepBoolean (theValue, preprocAlt ());
d96 1
a96 1
void WitSubEntry::setNetAllowed (WitBoolean theValue)
d98 1
a98 1
   netAllowed_ = prepBoolean (theValue, preprocAlt ());
d103 1
a103 1
void WitSubEntry::setMrpNetAllowed (WitBoolean theValue)
d105 1
a105 1
   mrpNetAllowed_ = prepBoolean (theValue, postprocAlt ());
d126 1
a126 1
WitBoolean WitSubEntry::inserted ()
d222 1
a222 1
WitBoolean WitSubEntry::storesOffset ()
d324 1
a324 1
   myDataWriter ()->writeBoolean (
d329 1
a329 1
   myDataWriter ()->writeBoolean (
d334 1
a334 1
   myDataWriter ()->writeBoolean (
@


1.18
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d28 1
@


1.17
log
@Continued implementation of single-source.
@
text
@d16 1
d20 1
@


1.16
log
@Continued implementation of single-source.
@
text
@d22 1
d201 14
@


1.15
log
@Continued implementation of single-source.
@
text
@d20 2
d186 14
@


1.14
log
@Continued implementation of single-source.
@
text
@a19 2
#include <FSS.h>
#include <OrigMrp.h>
a183 15
   }

//------------------------------------------------------------------------------

void WitSubEntry::importMrpResults ()
   {
   if (mrpNetAllowed_)
      mrpSubVol_.copyTVec (myOrigMrpExp ()->mrpSubVol (this));
   }

//------------------------------------------------------------------------------

void WitSubEntry::importFssResults ()
   {
   fssSubVol_.copyTVec (myFSS ()->fssSubVol (this));
@


1.13
log
@Continued implementation of single-source.
@
text
@d20 1
d194 7
@


1.12
log
@Preliminary work on single source.
@
text
@d20 1
d185 8
@


1.11
log
@Continued implementation of object iteration.
@
text
@d57 1
a57 1
const WitFlexVec (float) & WitSubEntry::offset ()
d78 1
a78 1
   obj1SubCost_ = prepObj1FloatVec (theValue, postprocAlt ());
a317 1
   obj1SubCost_    = theSub->obj1SubCost    ();
d321 2
@


1.10
log
@Continued implementation of object iteration.
@
text
@d146 1
a146 1
WitAttr WitSubEntry::apiItrState ()
@


1.9
log
@Continued implementation of object iteration.
@
text
@d148 1
a148 1
   return WitITR_AT_SUB_ENTRY;
@


1.8
log
@Began implementation of object iteration.
@
text
@d21 1
d146 7
d181 1
a181 1
WitBoolean WitSubEntry::storesOffset ()
d183 1
a183 1
   return myGlobalComp ()->independentOffsets ();
d188 1
a188 1
WitBoolean WitSubEntry::isaSubEntry ()
d190 1
a190 1
   return witTRUE;
@


1.7
log
@Continued development of selection splitting for multi=exec.
@
text
@d21 1
@


1.6
log
@Implemented and used class SelMgr.
@
text
@d30 1
a30 1
      myBomEntry_     (theBomEnt),
d42 3
a44 3
   myCompMgr  ()->insert (this);
   myBomEntry ()->insert (this);
   myPart     ()->insert (this);
d59 2
a60 2
         WitBillEntry:: offset ():
         myBomEntry ()->offset ();
d120 1
a120 1
   return (myBomEntry ()->mySubEntries ().contains (this));
d136 2
a137 2
      myBomEntry ()->localIndex (),
      myBomEntry ()->myPartName (),
d152 1
a152 1
         myBomEntryIndex ());
d194 1
a194 1
   myDataWriter ()->writeIntValue     (myBomEntryIndex ());
d208 2
a209 2
      myBomEntryIndex (),
      myBomEntry ()->myPartName (),
d248 1
a248 1
   return myBomEntry ();
d258 1
a258 1
   myDataWriter ()->writeIntValue     (myBomEntryIndex ());
d319 1
a319 1
   prereq1 = myBomEntry ();
@


1.5
log
@Coarse selection splitting.
@
text
@a321 6

//------------------------------------------------------------------------------

implementClearContents (WitSubEntry)
   //
   // See RWClient.h.
@


1.4
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d163 1
a163 1
   setBillEntryIndex ();
d167 1
a167 1
   myCompMgr ()->recount (this);
@


1.3
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d111 1
a111 1
   copyTo (subVol_, prepSchedVec (theValue, postprocAlt ()));
d144 1
a144 1
void WitSubEntry::copyInto (WitCompMgr * theCompMgr)
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d111 1
a111 1
   subVol_ = prepSchedVec (theValue, postprocAlt ());
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

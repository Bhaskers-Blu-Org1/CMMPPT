head	1.164;
access;
symbols
	sce_5_01_20080919:1.147
	latest_sce_4_20_20060523:1.103.0.2
	sce_4_20_20060523:1.103
	latest_sce4_20_OSL:1.102.0.2
	sce_4_20_OSL:1.102
	sce_410_withVa:1.94
	sce_4_05_20040511:1.85
	sce_4_00_20040201:1.60
	nextGenBranch:1.46.0.2
	nextGenRoot:1.46
	sce_3_30_20030627:1.45
	EndRw-branch:1.40.0.4
	Root-of-EndRw:1.40
	rwToStl:1.40.0.2
	latest_sce_3_10_20010924:1.24.0.2
	sce_3_10_20010924:1.24
	latest_sce_3_00_20010601:1.16.0.2
	sce_3_00_20010601:1.16
	latest_sce_2_31_20010308:1.15.0.2
	sce_2_31_20010308:1.15
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.164
date	2011.09.28.23.49.59;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2011.09.24.00.28.23;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2011.08.30.20.18.00;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2011.01.18.23.27.20;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2010.09.24.18.17.22;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2010.09.22.20.21.53;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2010.09.21.21.19.13;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2010.09.10.22.10.40;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2010.09.07.16.38.59;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2010.09.02.18.58.25;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2010.09.01.16.28.24;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2010.03.16.22.42.27;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2010.01.25.19.45.19;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2009.12.29.20.17.18;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2009.11.17.22.54.49;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2009.10.07.22.08.37;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2009.07.07.22.05.35;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2008.01.21.21.47.17;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2007.12.03.19.41.33;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2007.11.29.21.12.31;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2007.11.14.17.18.55;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2007.10.22.19.20.37;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2007.10.02.22.23.05;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2007.08.28.17.38.35;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2007.08.10.19.20.21;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2007.08.01.22.41.58;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2007.06.20.22.10.26;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2007.06.20.19.07.53;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2007.06.19.21.45.50;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2007.06.18.22.28.42;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2007.06.18.19.53.32;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2007.06.14.16.09.36;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2007.05.30.22.05.51;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2007.05.21.15.20.10;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2007.05.09.22.44.27;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2007.05.08.20.11.22;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2007.04.30.21.52.09;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2007.04.30.19.32.31;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2007.04.27.21.02.01;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2007.04.24.20.07.50;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2007.04.23.21.03.20;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2007.04.20.20.51.13;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2007.04.13.20.07.58;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2007.04.09.16.05.08;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2007.04.06.19.34.18;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2007.04.05.20.23.52;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2007.04.04.20.04.40;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2007.04.02.23.01.15;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2007.04.02.21.21.19;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2007.03.28.22.14.32;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2007.03.22.20.01.16;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2007.01.09.21.07.48;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2007.01.09.19.14.16;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2006.12.27.20.19.30;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2006.12.27.19.55.08;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2006.11.22.21.45.07;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2006.09.21.15.42.27;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2006.09.19.17.50.55;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2006.09.18.23.02.52;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2006.09.18.22.27.40;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2006.05.02.17.34.09;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2006.03.21.20.47.35;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2006.01.09.20.02.30;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2005.11.16.20.42.15;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2005.11.15.21.45.26;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2005.11.15.21.27.23;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2005.10.18.20.56.22;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2005.09.13.19.38.08;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2005.09.13.19.31.57;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2005.09.07.19.29.52;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2005.08.25.21.47.39;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2005.02.24.19.46.27;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2005.02.10.19.46.47;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2005.02.03.21.31.35;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2005.02.03.21.20.30;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2005.02.02.17.26.53;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2005.01.31.23.59.30;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.01.28.19.34.27;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2004.04.16.21.32.56;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.14.21.25.36;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2004.03.24.22.21.33;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2004.03.24.19.17.33;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2004.03.23.19.14.25;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2004.03.22.21.45.51;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.03.22.16.37.19;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.03.19.22.55.23;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.03.16.23.29.50;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.03.11.16.59.09;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.03.11.16.36.18;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.03.04.19.53.27;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.03.20.05.07;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.02.19.17.52;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.02.16.19.31;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.02.27.21.00.29;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.02.26.20.40.26;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.02.17.20.23.47;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.02.14.00.45.35;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.02.10.23.57.45;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.30.20.09.48;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2003.12.31.23.18.57;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.31.21.44.53;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.12.29.16.25.32;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.24.20.12.34;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.23.16.18.47;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.17.22.30.00;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.12.19.49.44;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.11.21.56.33;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.09.22.44.06;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.10.31.15.37.55;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.10.01.15.59.26;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.30.15.40.55;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.24.23.08.17;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.10.22.58.17;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.23.18.12.38;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.14.22.00.35;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.09.23.29.46;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.02.23.40.48;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.02.22.18.45;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.09.11.18.53.15;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.23.18.09.16;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.22.21.16.22;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.08.15.20.03.47;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.07.20.12.56;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.09.19.52.35;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.28.19.40.15;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.26.18.42.53;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.26.18.28.38;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.21.21.52.20;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.16.23.32.08;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.08.19.21.55;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.07.20.15.02;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.22.14.32.12;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.18.14.02.42;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.28.00.13.00;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.21.22.36.31;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.29.21.37.21;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.23.21.13.54;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.21.17.31.46;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.25.16.08.18;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.03.20.07.30;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.21.18.24.33;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.20.20.07.05;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.17.15.11.16;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.27.00.24.39;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.20.00.44.21;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.11.16.35.10;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.22.16.18.26;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.20.20.22.27;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.13.19.57.26;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.05.19.05.31;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.04.22.07.38;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.22.23.11.47;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.21.20.03.26;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.29.21.22.46;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.26;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.16.33.09;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.47;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.29;	author wit;	state Exp;
branches;
next	;


desc
@@


1.164
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Problem.C"
//
// Contains the implementation of class Problem.
//------------------------------------------------------------------------------

#include <HeurImp.h>
#include <EqAll.h>
#include <HeurAllMgr.h>
#include <DetOptImpMgr.h>
#include <StochImpMgr.h>
#include <OrigMrp.h>
#include <PipMgr.h>
#include <DataRead.h>
#include <DataWrit.h>
#include <SolnWrit.h>
#include <Timing.h>
#include <Pre.h>
#include <Post.h>
#include <FeasChkr.h>
#include <FSS.h>
#include <LinkMgr.h>
#include <WitRun.h>
#include <ApiMgr.h>
#include <wit/src/Variant.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Material.h>
#include <Demand.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <BoundSet.h>
#include <CpxParSpecMgr.h>
#include <FlexVec.h>
#include <TempMsgFile.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class Problem.
//------------------------------------------------------------------------------

WitProblem::WitProblem (WitSession * theSession):
      mySession_            (theSession),

      myCompMgr_            (NULL),
      myPreprocessor_       (NULL),
      myPostprocessor_      (NULL),
      myHeurImploder_       (NULL),
      myEqAllocator_        (NULL),
      myHeurAllMgr_         (NULL),
      myDetOptImpMgr_       (NULL),
      myStochImpMgr_        (NULL),
      myPipMgr_             (NULL),
      myOrigMrpExp_         (NULL),
      myFSS_                (NULL),
      myDataReader_         (NULL),
      myDataWriter_         (NULL),
      mySolnWriter_         (NULL),

      myMsgFac_             (theSession->myMsgFac ()),
      myWitRun_             (theSession->myWitRun ()),
      myApiMgr_             (theSession->myApiMgr ()),
      solnFile_             (NULL),
      nPeriods_             (WitGlobalComp::defNPeriods ()),
      lastPeriod_           (nPeriods_ - 1),
      myObjLinkMgr_         (NULL),
      myIntPairLinkMgr_     (NULL),
      myBoolPairLinkMgr_    (NULL),
      myDblPairLinkMgr_     (NULL),
      myVoidPtrPairLinkMgr_ (NULL),
      myTripLinkMgr_        (NULL),
      optVariant_           (NULL),
      extOptVariant_        (NULL),
      heurVariant_          (NULL),
      heurOptVariant_       (NULL),
      inputVariant_         (NULL),
      allVariants_          (),
      currentVariant_       (NULL),
      scalarFlexVAsst_      (NULL),
      vectorFlexVAsst_      (NULL),
      dispDoubleVector_     (),
      dispIntVector_        (),
      dispBoolVector_       ()
   {
   scalarFlexVAsst_      = new WitFlexVAsst (this, false);
   vectorFlexVAsst_      = new WitFlexVAsst (this, true);

   myObjLinkMgr_         = new WitObjLinkMgr           (this);
   myIntPairLinkMgr_     = new WitPairLinkMgr <int>    (this);
   myBoolPairLinkMgr_    = new WitPairLinkMgr <bool>   (this);
   myDblPairLinkMgr_     = new WitPairLinkMgr <double> (this);
   myVoidPtrPairLinkMgr_ = new WitPairLinkMgr <void *> (this);
   myTripLinkMgr_        = new WitTripLinkMgr          (this);

   myPreprocessor_       = new WitPreprocessor  (this);
   myPostprocessor_      = new WitPostprocessor (this);
   myHeurImploder_       = new WitHeurImploder  (this);
   myEqAllocator_        = new WitEqAllocator   (this);
   myHeurAllMgr_         = new WitHeurAllMgr    (this);
   myDetOptImpMgr_       = new WitDetOptImpMgr  (this);
   myStochImpMgr_        = new WitStochImpMgr   (this);
   myPipMgr_             = new WitPipMgr        (this);
   myOrigMrpExp_         = new WitOrigMrpExp    (this);
   myFSS_                = new WitFSS           (this);
   myDataReader_         = new WitDataReader    (this);
   myDataWriter_         = new WitDataWriter    (this);
   mySolnWriter_         = new WitSolnWriter    (this);

   setUpVariants ();

   myCompMgr_            = new WitCompMgr       (this);

   myGlobalComp_         = new WitGlobalComp    (myCompMgr ());
   myOptComp_            = new WitOptComp       (myCompMgr ());
   }

//------------------------------------------------------------------------------

WitProblem::~WitProblem ()
   {
   myStochImpMgr_->setStochMode (false);

   myPreprocessor_->unpreprocess ();

   while (not allVariants_.isEmpty ())
      delete allVariants_.get ();

   delete myFSS_;
   delete mySolnWriter_;
   delete myDataWriter_;
   delete myDataReader_;
   delete myOrigMrpExp_;
   delete myPipMgr_;
   delete myStochImpMgr_;
   delete myDetOptImpMgr_;
   delete myHeurAllMgr_;
   delete myEqAllocator_;
   delete myHeurImploder_;
   delete myPostprocessor_;
   delete myPreprocessor_;

   myOptComp_    = NULL;
   myGlobalComp_ = NULL;

   delete myCompMgr_;

   WitAbsLinkMgr::deleteInstance (myTripLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myVoidPtrPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myDblPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myBoolPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myIntPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myObjLinkMgr_);

   delete scalarFlexVAsst_;
   delete vectorFlexVAsst_;
   }

//------------------------------------------------------------------------------

bool WitProblem::wit34Compatible ()
   {
   return myCompMgr ()->myGlobalComp ()->wit34Compatible ();
   }

//------------------------------------------------------------------------------

WitHeurModifier * WitProblem::myHeurModifier ()
   {
   return myHeurAllMgr_->myHeurModifier ();
   }

//------------------------------------------------------------------------------

void WitProblem::store (WitVariant * theVariant)
   {
   allVariants_.append (theVariant);
   }

//------------------------------------------------------------------------------

void WitProblem::setUpVariants ()
   {
   optVariant_     = new WitVariant (this);
   extOptVariant_  = new WitVariant (this);
   heurVariant_    = new WitVariant (this);
   heurOptVariant_ = new WitVariant (this);
   inputVariant_   = new WitVariant (this);

   WitVariant * theVariant;

   forEachEl (theVariant, allVariants_)
      theVariant->configure ();

   currentVariant_ = inputVariant ();
   }

//------------------------------------------------------------------------------

void WitProblem::makeCurrent (WitVariant * theVariant)
   {
   resetSoln ();

   currentVariant_ = theVariant;
   }

//------------------------------------------------------------------------------

void WitProblem::allocTVecs ()
   {
   if (dispDoubleVector_.isAllocated ())
      return;

   dispDoubleVector_.allocate (this, 0.0);
   dispIntVector_   .allocate (this, 0);
   dispBoolVector_  .allocate (this, false);
   }

//------------------------------------------------------------------------------

void WitProblem::clearTVecs ()
   {
   if (not dispDoubleVector_.isAllocated ())
      return;

   dispDoubleVector_.clear ();
   dispIntVector_   .clear ();
   dispBoolVector_  .clear ();
   }

//------------------------------------------------------------------------------

void WitProblem::updateNPeriods ()
   {
   nPeriods_   = myGlobalComp ()->nPeriods ();

   lastPeriod_ = nPeriods_ - 1;

   scalarFlexVAsst_->updateNPeriods ();
   vectorFlexVAsst_->updateNPeriods ();
   }

//------------------------------------------------------------------------------

void WitProblem::displayData (const char * filename)
   {
   WitTimer::enterSection ("extra");

   myMsgFac () ("witFileParam",
      (filename == NULL)?
         myMsgFac ().fileName ().myCstring ():
         filename);

   WitTempMsgFile theTemp (myMsgFac (), filename);

   mySession ()->printHeading ();

   myMsgFac () ("fileHeadingDdMsg");

   displayGlobalData ();

   if (myStochImpMgr_->stochMode ())
      myStochImpMgr_->displayDataStochMode ();
   else
      displayNonGlobalData ();

   myPipMgr_->displayShipSeq ();

   WitTimer::leaveSection ("extra");
   }

//------------------------------------------------------------------------------

void WitProblem::displayGlobalData ()
   {
   WitPart *      thePart;
   int            nCapacities;
   WitOperation * theOpn;
   int            nPosPens;

   myMsgFac () ("globalHeadingDdMsg");

   myMsgFac () ("titleMsg", myCompMgr ()->myGlobalComp ()->title ());
   myMsgFac () ("dimenHeadingDdMsg");

   nCapacities = 0;

   forEachPart (thePart, this)
      if (thePart->thisCap () != NULL)
         ++ nCapacities;

   myMsgFac () ("categorySizeDdMsg",
      myMsgFac ().myFrag ("capacityFrag"),
      nCapacities);

   myMsgFac () ("categorySizeDdMsg",
      myMsgFac ().myFrag ("materialFrag"),
      myCompMgr ()->nMaterials ());

   myMsgFac () ("dimenDataDdMsg",
      myCompMgr ()->nParts (),
      myCompMgr ()->nOperations (),
      myCompMgr ()->nDemands (),
                    nPeriods (),
      myCompMgr ()->nBoundSetsSpecified (),
      myCompMgr ()->nBoundSets (),
      myCompMgr ()->nBomEntries (),
      myCompMgr ()->nSubEntries (),
      myCompMgr ()->nBopEntries (),
      myCompMgr ()->nDelComps ());

   nPosPens = 0;

   forEachOperation (theOpn, this)
      if (theOpn->execPenalty () > 0.0)
         nPosPens ++;

   myMsgFac () ("globalDataDdMsg",
                                     wit34Compatible     (),
      myCompMgr ()->myGlobalComp ()->independentOffsets  (),
      myCompMgr ()->myGlobalComp ()->execEmptyBom        (),
      myCompMgr ()->myGlobalComp ()->computeCriticalList (),
      myCompMgr ()->myGlobalComp ()->pgdCritListMode     (),
      myCompMgr ()->myGlobalComp ()->hashTableSize       (),
      myCompMgr ()->myGlobalComp ()->roundReqVols        (),
      myCompMgr ()->myGlobalComp ()->outputPrecision     (),
      myCompMgr ()->myGlobalComp ()->useFocusHorizons    (),
                                     nPosPens,
      myPreprocessor ()->            preprocessed        ());

   if (myPreprocessor_->preprocessed ())
      myMsgFac () ("preprocDataDdMsg",
         myCompMgr ()->myGlobalComp ()->lotSizesExist ());

   myCompMgr ()->myGlobalComp ()->display ();
   myCompMgr ()->myOptComp    ()->display ();

   myStochImpMgr_->displayGlobalData ();

   myCompMgr ()->myOptComp ()->myCpxParSpecMgr ()->display ();
   }

//------------------------------------------------------------------------------

void WitProblem::displayNonGlobalData ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
   WitDemand *    theDemand;

   myMsgFac () ("partHeadingDdMsg");

   forEachPart (thePart, this)
      thePart->display ();

   myMsgFac () ("demandHeadingDdMsg");

   forEachDemand (theDemand, this)
      theDemand->display ();

   myMsgFac () ("operationHeadingDdMsg");

   forEachOperation (theOpn, this)
      theOpn->display ();

   myMsgFac () ("bomEntryHeadingDdMsg");

   forEachBomEntry (theBomEnt, this)
      theBomEnt->display ();

   myMsgFac () ("subHeadingDdMsg");

   forEachSubEntry (theSub, this)
      theSub->display ();

   myMsgFac () ("bopEntryHeadingDdMsg");

   forEachBopEntry (theBopEnt, this)
      theBopEnt->display ();
   }

//------------------------------------------------------------------------------

void WitProblem::display (
      WitMsgID              theMsgID,
      const WitDblFlexVec & theFlexVec)
   {
   dispDoubleVector_ = theFlexVec;

   myMsgFac () (theMsgID, dispDoubleVector_);
   }

//------------------------------------------------------------------------------

void WitProblem::display (
      WitMsgID                 theMsgID,
      const WitFlexVec <int> & theFlexVec)
   {
   dispIntVector_ = theFlexVec;
                    
   myMsgFac () (theMsgID, dispIntVector_);
   }

//------------------------------------------------------------------------------

void WitProblem::display (
      WitMsgID                  theMsgID,
      const WitFlexVec <bool> & theFlexVec)
   {
   dispBoolVector_ = theFlexVec;

   myMsgFac () (theMsgID, dispBoolVector_);
   }

//------------------------------------------------------------------------------

void WitProblem::display (WitMsgID theMsgID, const WitObjVec & theObjVec)
   {
   theObjVec.display (theMsgID, this);
   }

//------------------------------------------------------------------------------

void WitProblem::displayBoundVec (
      WitMsgFragID          theFragID,
      const WitDblFlexVec & theFlexVec)
   {
   dispDoubleVector_ = theFlexVec;

   myMsgFac () ("boundDataDdMsg",
      myMsgFac ().myFrag (theFragID), dispDoubleVector_);
   }

//------------------------------------------------------------------------------

void WitProblem::copyProblemInto (WitProblem * theProblem)
   {
   WitComponent * theComp;

   myPreprocessor_->preprocess ();

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->copySelfInto (theProblem->myCompMgr ());

   theProblem->myStochImpMgr_->copyAttrsFrom (myStochImpMgr_);
   }

//------------------------------------------------------------------------------

void WitProblem::prepSetUnpreAttr ()
   {
   stronglyAssert (not myStochImpMgr ()->stochMode ());

   myPreprocessor_->unpreprocess ();
   }

//------------------------------------------------------------------------------

void WitProblem::prepSetUnpostAttr ()
   {
   stronglyAssert (not myStochImpMgr ()->stochMode ());

   resetSoln ();
   }

//------------------------------------------------------------------------------

void WitProblem::prepSetNonUnpostAttr ()
   {
   stronglyAssert (not myStochImpMgr ()->stochMode ());
   }

//------------------------------------------------------------------------------

void WitProblem::prepSetStochModeAttr (const char * theAttName)
   {
   if (myStochImpMgr ()->stochMode ())
      myStochImpMgr ()->prepSetStochModeAttr (theAttName);

   resetSoln ();
   }

//------------------------------------------------------------------------------

void WitProblem::resetSoln ()
   {
   currentVariant_ = inputVariant ();

   myPostprocessor_->unpostprocess ();

   myHeurAllMgr ()->reset ();
   }

//------------------------------------------------------------------------------

void WitProblem::writeSoln (const char * fileName)
   {
   myPostprocessor_->postprocess ();

   WitTimer::enterSection ("extra");

   solnFile_ = mySession_->openFile (fileName, "w");

   mySession ()->writeHeading (solnFile ());

   fprintf (solnFile (), "Comprehensive Implosion Solution.\n\n");

   fprintf (solnFile (),
      "Solution provided by: %s.\n\n",
      myMsgFac ().fragText (currentVariant ()->myFragID ()));

   if (    (myStochImpMgr_->stochMode ())
       and (myStochImpMgr_->stochSolnMode ()))
      writeStochSoln ();
   else
      writeSolnInt ();

   fclose (solnFile ());

   solnFile_ = NULL;

   WitTimer::leaveSection ("extra");
   }

//------------------------------------------------------------------------------

#define SOLN_EPSILON  0.0005
   //
   // Values must exceed this amount in order to appear in the comprehensive
   // solution output.

//------------------------------------------------------------------------------

void WitProblem::writeSolnValue (double val)
   {
   if (fabs (val) >= SOLN_EPSILON)
      fprintf (solnFile (), "  %11.3f", val);
   else
      fprintf (solnFile (), "             ");
   }

//------------------------------------------------------------------------------

void WitProblem::writeMrpSoln (const char * fileName)
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitBomEntry  * theBomEnt;

   WitTimer::enterSection ("extra");

   solnFile_ = mySession_->openFile (fileName, "w");

   mySession ()->writeHeading (solnFile ());

   fprintf (solnFile (), "Comprehensive MRP Solution.\n\n");

   fprintf (solnFile (), "\n\nComprehensive MRP Solution for Parts:\n");

   forEachPart (thePart, this)
      thePart->writeMrpSoln ();

   fprintf (solnFile (), "\n\nComprehensive MRP Solution for Operations:\n");

   forEachOperation (theOpn, this)
      theOpn->writeMrpSoln ();

   if (myCompMgr ()->hasSubEntries ())
      {
      fprintf (solnFile (),
         "\n\nComprehensive MRP Solution for Substitutes:\n");

      forEachBomEntry (theBomEnt, this)
         theBomEnt->writeMrpSubSoln ();
      }

   fclose (solnFile ());

   solnFile_ = NULL;

   WitTimer::leaveSection ("extra");
   }

//------------------------------------------------------------------------------

void WitProblem::computeFssIfNeeded ()
   {
   if (not myFSS ()->computed ())
      myFSS ()->compute ();
   }

//------------------------------------------------------------------------------

void WitProblem::pauseForInput (const char * theText)
   {
   int  retVal;
   char theCstring[2];

   printf (
      "\n"
      "------------------------------------------------------\n"
      "Pausing execution %s.\n"
      "------------------------------------------------------\n"
      "\n"
      "To continue,\n"
      "   type one non-blank character,\n"
      "   followed by \"enter\".\n"
      "\n",
      theText);

   retVal = scanf ("%1s", theCstring);
      //
      // The return value is stored in retVal to avoid a compiler warning on
      // some platforms.

   printf (
      "\n"
      "------------------------------------------------------\n"
      "Resuming execution.\n"
      "------------------------------------------------------\n"
      "\n");
   }

//------------------------------------------------------------------------------

void WitProblem::writeStochSoln ()
   {
   int origScenIdx;
   int theIdx;

   stronglyAssert (myStochImpMgr_->stochSolnMode ());

   origScenIdx = myStochImpMgr_->currentScenario ();

   for (theIdx = 0; theIdx < myStochImpMgr_->nScenarios (); theIdx ++)
      {
      myStochImpMgr_->setCurrentScenario (theIdx);

      fprintf (solnFile (),
         "\n"
         "-------------------------------------------------"
         "------------------------------------------------\n"
         "Comprehensive Solution for Scenario #%d:\n"
         "-------------------------------------------------"
         "------------------------------------------------\n\n",
         theIdx);

      writeSolnInt ();
      }
      
   myStochImpMgr_->setCurrentScenario (origScenIdx);
   }

//------------------------------------------------------------------------------

void WitProblem::writeSolnInt ()
   {
   WitPart *      thePart;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;

   fprintf (solnFile (),
      "Solution is feasible?         %s\n",
      myMsgFac ().boolText (myCompMgr ()->myGlobalComp ()->feasible ()));

   fprintf (solnFile (),
      "Maximum constraint violation: %g\n",
      myPostprocessor ()->myFeasChkr ()->maxViolation ());

   fprintf (solnFile (), "\n\nComprehensive Solution for Parts:\n");

   forEachPart (thePart, this)
      thePart->writeSoln ();

   fprintf (solnFile (), "\n\nComprehensive Solution for Demands:\n");

   forEachDemand (theDemand, this)
      theDemand->writeSoln ();

   fprintf (solnFile (), "\n\nComprehensive Solution for Operations:\n");

   forEachOperation (theOpn, this)
      theOpn->writeSoln ();

   if (myCompMgr ()->hasSubEntries ())
      {
      fprintf (solnFile (), "\n\nComprehensive Solution for Substitutes:\n");

      forEachBomEntry (theBomEnt, this)
         theBomEnt->writeSubSoln ();
      }

   writeBoundsSoln  ();

   if (myOptComp ()->compPrices ())
      {
      fprintf (solnFile (), "\n\nShadow Prices:\n");

      forEachPart (thePart, this)
         thePart->writeDualSoln ();
      }

   if (DEVELOPMENT)
      if (myGlobalComp ()->perfPegging ())
         myHeurAllMgr_->printPegging ();

   if (DEVELOPMENT)
      myPipMgr_->printPegging ();

   if (DEVELOPMENT)
      if (myGlobalComp ()->pgdCritListMode ())
         myGlobalComp ()->writePdgCritList ();
   }

//------------------------------------------------------------------------------

void WitProblem::writeBoundsSoln ()
   {
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;

   fprintf (solnFile (), "\n\nComprehensive Solution for Bounds:\n");

   if (myCompMgr ()->nBoundSetsSpecified () == 0)
      {
      fprintf (solnFile (),
         "\n\nNo bound sets specified for this implosion problem.\n");

      return;
      }

   forEachMaterial (theMat, this)
      theMat->stockBounds ()->writeSoln ();

   forEachDemand (theDemand, this)
      theDemand->cumShipBounds ()->writeSoln ();

   forEachOperation (theOpn, this)
      theOpn->execBounds ()->writeSoln ();
   }
@


1.163
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.162
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d54 1
a54 1
mySession_            (theSession),
d56 71
a126 71
myCompMgr_            (NULL),
myPreprocessor_       (NULL),
myPostprocessor_      (NULL),
myHeurImploder_       (NULL),
myEqAllocator_        (NULL),
myHeurAllMgr_         (NULL),
myDetOptImpMgr_       (NULL),
myStochImpMgr_        (NULL),
myPipMgr_             (NULL),
myOrigMrpExp_         (NULL),
myFSS_                (NULL),
myDataReader_         (NULL),
myDataWriter_         (NULL),
mySolnWriter_         (NULL),

myMsgFac_             (theSession->myMsgFac ()),
myWitRun_             (theSession->myWitRun ()),
myApiMgr_             (theSession->myApiMgr ()),
solnFile_             (NULL),
nPeriods_             (WitGlobalComp::defNPeriods ()),
lastPeriod_           (nPeriods_ - 1),
myObjLinkMgr_         (NULL),
myIntPairLinkMgr_     (NULL),
myBoolPairLinkMgr_    (NULL),
myDblPairLinkMgr_     (NULL),
myVoidPtrPairLinkMgr_ (NULL),
myTripLinkMgr_        (NULL),
optVariant_           (NULL),
extOptVariant_        (NULL),
heurVariant_          (NULL),
heurOptVariant_       (NULL),
inputVariant_         (NULL),
allVariants_          (),
currentVariant_       (NULL),
scalarFlexVAsst_      (NULL),
vectorFlexVAsst_      (NULL),
dispDoubleVector_     (),
dispIntVector_        (),
dispBoolVector_       ()
{
scalarFlexVAsst_      = new WitFlexVAsst (this, false);
vectorFlexVAsst_      = new WitFlexVAsst (this, true);

myObjLinkMgr_         = new WitObjLinkMgr           (this);
myIntPairLinkMgr_     = new WitPairLinkMgr <int>    (this);
myBoolPairLinkMgr_    = new WitPairLinkMgr <bool>   (this);
myDblPairLinkMgr_     = new WitPairLinkMgr <double> (this);
myVoidPtrPairLinkMgr_ = new WitPairLinkMgr <void *> (this);
myTripLinkMgr_        = new WitTripLinkMgr          (this);

myPreprocessor_       = new WitPreprocessor  (this);
myPostprocessor_      = new WitPostprocessor (this);
myHeurImploder_       = new WitHeurImploder  (this);
myEqAllocator_        = new WitEqAllocator   (this);
myHeurAllMgr_         = new WitHeurAllMgr    (this);
myDetOptImpMgr_       = new WitDetOptImpMgr  (this);
myStochImpMgr_        = new WitStochImpMgr   (this);
myPipMgr_             = new WitPipMgr        (this);
myOrigMrpExp_         = new WitOrigMrpExp    (this);
myFSS_                = new WitFSS           (this);
myDataReader_         = new WitDataReader    (this);
myDataWriter_         = new WitDataWriter    (this);
mySolnWriter_         = new WitSolnWriter    (this);

setUpVariants ();

myCompMgr_            = new WitCompMgr       (this);

myGlobalComp_         = new WitGlobalComp    (myCompMgr ());
myOptComp_            = new WitOptComp       (myCompMgr ());
}
d131 2
a132 2
{
myStochImpMgr_->setStochMode (false);
d134 1
a134 1
myPreprocessor_->unpreprocess ();
d136 2
a137 2
while (not allVariants_.isEmpty ())
delete allVariants_.get ();
d139 29
a167 29
delete myFSS_;
delete mySolnWriter_;
delete myDataWriter_;
delete myDataReader_;
delete myOrigMrpExp_;
delete myPipMgr_;
delete myStochImpMgr_;
delete myDetOptImpMgr_;
delete myHeurAllMgr_;
delete myEqAllocator_;
delete myHeurImploder_;
delete myPostprocessor_;
delete myPreprocessor_;

myOptComp_    = NULL;
myGlobalComp_ = NULL;

delete myCompMgr_;

WitAbsLinkMgr::deleteInstance (myTripLinkMgr_);
WitAbsLinkMgr::deleteInstance (myVoidPtrPairLinkMgr_);
WitAbsLinkMgr::deleteInstance (myDblPairLinkMgr_);
WitAbsLinkMgr::deleteInstance (myBoolPairLinkMgr_);
WitAbsLinkMgr::deleteInstance (myIntPairLinkMgr_);
WitAbsLinkMgr::deleteInstance (myObjLinkMgr_);

delete scalarFlexVAsst_;
delete vectorFlexVAsst_;
}
d172 3
a174 3
{
return myCompMgr ()->myGlobalComp ()->wit34Compatible ();
}
d179 3
a181 3
{
return myHeurAllMgr_->myHeurModifier ();
}
d186 3
a188 3
{
allVariants_.append (theVariant);
}
d193 6
a198 6
{
optVariant_     = new WitVariant (this);
extOptVariant_  = new WitVariant (this);
heurVariant_    = new WitVariant (this);
heurOptVariant_ = new WitVariant (this);
inputVariant_   = new WitVariant (this);
d200 1
a200 1
WitVariant * theVariant;
d202 2
a203 2
forEachEl (theVariant, allVariants_)
theVariant->configure ();
d205 2
a206 2
currentVariant_ = inputVariant ();
}
d211 2
a212 2
{
resetSoln ();
d214 2
a215 2
currentVariant_ = theVariant;
}
d220 8
a227 8
{
if (dispDoubleVector_.isAllocated ())
return;

dispDoubleVector_.allocate (this, 0.0);
dispIntVector_   .allocate (this, 0);
dispBoolVector_  .allocate (this, false);
}
d232 8
a239 8
{
if (not dispDoubleVector_.isAllocated ())
return;

dispDoubleVector_.clear ();
dispIntVector_   .clear ();
dispBoolVector_  .clear ();
}
d244 2
a245 2
{
nPeriods_   = myGlobalComp ()->nPeriods ();
d247 1
a247 1
lastPeriod_ = nPeriods_ - 1;
d249 3
a251 3
scalarFlexVAsst_->updateNPeriods ();
vectorFlexVAsst_->updateNPeriods ();
}
d256 2
a257 2
{
WitTimer::enterSection ("extra");
d259 4
a262 4
myMsgFac () ("witFileParam",
(filename == NULL)?
myMsgFac ().fileName ().myCstring ():
filename);
d264 1
a264 1
WitTempMsgFile theTemp (myMsgFac (), filename);
d266 1
a266 1
mySession ()->printHeading ();
d268 1
a268 1
myMsgFac () ("fileHeadingDdMsg");
d270 1
a270 1
displayGlobalData ();
d272 4
a275 4
if (myStochImpMgr_->stochMode ())
myStochImpMgr_->displayDataStochMode ();
else
displayNonGlobalData ();
d277 1
a277 1
myPipMgr_->displayShipSeq ();
d279 2
a280 2
WitTimer::leaveSection ("extra");
}
d285 59
a343 59
{
WitPart *      thePart;
int            nCapacities;
WitOperation * theOpn;
int            nPosPens;

myMsgFac () ("globalHeadingDdMsg");

myMsgFac () ("titleMsg", myCompMgr ()->myGlobalComp ()->title ());
myMsgFac () ("dimenHeadingDdMsg");

nCapacities = 0;

forEachPart (thePart, this)
if (thePart->thisCap () != NULL)
++ nCapacities;

myMsgFac () ("categorySizeDdMsg",
myMsgFac ().myFrag ("capacityFrag"),
nCapacities);

myMsgFac () ("categorySizeDdMsg",
myMsgFac ().myFrag ("materialFrag"),
myCompMgr ()->nMaterials ());

myMsgFac () ("dimenDataDdMsg",
myCompMgr ()->nParts (),
myCompMgr ()->nOperations (),
myCompMgr ()->nDemands (),
nPeriods (),
myCompMgr ()->nBoundSetsSpecified (),
myCompMgr ()->nBoundSets (),
myCompMgr ()->nBomEntries (),
myCompMgr ()->nSubEntries (),
myCompMgr ()->nBopEntries (),
myCompMgr ()->nDelComps ());

nPosPens = 0;

forEachOperation (theOpn, this)
if (theOpn->execPenalty () > 0.0)
nPosPens ++;

myMsgFac () ("globalDataDdMsg",
wit34Compatible     (),
myCompMgr ()->myGlobalComp ()->independentOffsets  (),
myCompMgr ()->myGlobalComp ()->execEmptyBom        (),
myCompMgr ()->myGlobalComp ()->computeCriticalList (),
myCompMgr ()->myGlobalComp ()->pgdCritListMode     (),
myCompMgr ()->myGlobalComp ()->hashTableSize       (),
myCompMgr ()->myGlobalComp ()->roundReqVols        (),
myCompMgr ()->myGlobalComp ()->outputPrecision     (),
myCompMgr ()->myGlobalComp ()->useFocusHorizons    (),
nPosPens,
myPreprocessor ()->            preprocessed        ());

if (myPreprocessor_->preprocessed ())
myMsgFac () ("preprocDataDdMsg",
myCompMgr ()->myGlobalComp ()->lotSizesExist ());
d345 2
a346 2
myCompMgr ()->myGlobalComp ()->display ();
myCompMgr ()->myOptComp    ()->display ();
d348 1
a348 1
myStochImpMgr_->displayGlobalData ();
d350 2
a351 2
myCompMgr ()->myOptComp ()->myCpxParSpecMgr ()->display ();
}
d356 7
a362 7
{
WitPart *      thePart;
WitOperation * theOpn;
WitBomEntry *  theBomEnt;
WitSubEntry *  theSub;
WitBopEntry *  theBopEnt;
WitDemand *    theDemand;
d364 1
a364 1
myMsgFac () ("partHeadingDdMsg");
d366 2
a367 2
forEachPart (thePart, this)
thePart->display ();
d369 1
a369 1
myMsgFac () ("demandHeadingDdMsg");
d371 2
a372 2
forEachDemand (theDemand, this)
theDemand->display ();
d374 1
a374 1
myMsgFac () ("operationHeadingDdMsg");
d376 2
a377 2
forEachOperation (theOpn, this)
theOpn->display ();
d379 1
a379 1
myMsgFac () ("bomEntryHeadingDdMsg");
d381 2
a382 2
forEachBomEntry (theBomEnt, this)
theBomEnt->display ();
d384 1
a384 1
myMsgFac () ("subHeadingDdMsg");
d386 2
a387 2
forEachSubEntry (theSub, this)
theSub->display ();
d389 1
a389 1
myMsgFac () ("bopEntryHeadingDdMsg");
d391 3
a393 3
forEachBopEntry (theBopEnt, this)
theBopEnt->display ();
}
d398 4
a401 4
WitMsgID              theMsgID,
const WitDblFlexVec & theFlexVec)
{
dispDoubleVector_ = theFlexVec;
d403 2
a404 2
myMsgFac () (theMsgID, dispDoubleVector_);
}
d409 7
a415 7
WitMsgID                 theMsgID,
const WitFlexVec <int> & theFlexVec)
{
dispIntVector_ = theFlexVec;

myMsgFac () (theMsgID, dispIntVector_);
}
d420 4
a423 4
WitMsgID                  theMsgID,
const WitFlexVec <bool> & theFlexVec)
{
dispBoolVector_ = theFlexVec;
d425 2
a426 2
myMsgFac () (theMsgID, dispBoolVector_);
}
d431 3
a433 3
{
theObjVec.display (theMsgID, this);
}
d438 8
a445 8
WitMsgFragID          theFragID,
const WitDblFlexVec & theFlexVec)
{
dispDoubleVector_ = theFlexVec;

myMsgFac () ("boundDataDdMsg",
myMsgFac ().myFrag (theFragID), dispDoubleVector_);
}
d450 2
a451 2
{
WitComponent * theComp;
d453 1
a453 1
myPreprocessor_->preprocess ();
d455 2
a456 2
forEachEl (theComp, myCompMgr ()->allComponents ())
theComp->copySelfInto (theProblem->myCompMgr ());
d458 2
a459 2
theProblem->myStochImpMgr_->copyAttrsFrom (myStochImpMgr_);
}
d464 2
a465 2
{
stronglyAssert (not myStochImpMgr ()->stochMode ());
d467 2
a468 2
myPreprocessor_->unpreprocess ();
}
d473 2
a474 2
{
stronglyAssert (not myStochImpMgr ()->stochMode ());
d476 2
a477 2
resetSoln ();
}
d482 3
a484 3
{
stronglyAssert (not myStochImpMgr ()->stochMode ());
}
d489 3
a491 3
{
if (myStochImpMgr ()->stochMode ())
myStochImpMgr ()->prepSetStochModeAttr (theAttName);
d493 2
a494 2
resetSoln ();
}
d499 2
a500 2
{
currentVariant_ = inputVariant ();
d502 1
a502 1
myPostprocessor_->unpostprocess ();
d504 2
a505 2
myHeurAllMgr ()->reset ();
}
d510 2
a511 2
{
myPostprocessor_->postprocess ();
d513 1
a513 1
WitTimer::enterSection ("extra");
d515 1
a515 1
solnFile_ = mySession_->openFile (fileName, "w");
d517 1
a517 1
mySession ()->writeHeading (solnFile ());
d519 1
a519 1
fprintf (solnFile (), "Comprehensive Implosion Solution.\n\n");
d521 3
a523 3
fprintf (solnFile (),
"Solution provided by: %s.\n\n",
myMsgFac ().fragText (currentVariant ()->myFragID ()));
d525 5
a529 5
if (    (myStochImpMgr_->stochMode ())
and (myStochImpMgr_->stochSolnMode ()))
writeStochSoln ();
else
writeSolnInt ();
d531 1
a531 1
fclose (solnFile ());
d533 1
a533 1
solnFile_ = NULL;
d535 2
a536 2
WitTimer::leaveSection ("extra");
}
d541 3
a543 3
//
// Values must exceed this amount in order to appear in the comprehensive
// solution output.
d548 6
a553 6
{
if (fabs (val) >= SOLN_EPSILON)
fprintf (solnFile (), "  %11.3f", val);
else
fprintf (solnFile (), "             ");
}
d558 4
a561 4
{
WitPart *      thePart;
WitOperation * theOpn;
WitBomEntry  * theBomEnt;
d563 1
a563 1
WitTimer::enterSection ("extra");
d565 1
a565 1
solnFile_ = mySession_->openFile (fileName, "w");
d567 1
a567 1
mySession ()->writeHeading (solnFile ());
d569 1
a569 1
fprintf (solnFile (), "Comprehensive MRP Solution.\n\n");
d571 1
a571 1
fprintf (solnFile (), "\n\nComprehensive MRP Solution for Parts:\n");
d573 2
a574 2
forEachPart (thePart, this)
thePart->writeMrpSoln ();
d576 1
a576 1
fprintf (solnFile (), "\n\nComprehensive MRP Solution for Operations:\n");
d578 2
a579 2
forEachOperation (theOpn, this)
theOpn->writeMrpSoln ();
d581 4
a584 4
if (myCompMgr ()->hasSubEntries ())
{
fprintf (solnFile (),
"\n\nComprehensive MRP Solution for Substitutes:\n");
d586 3
a588 3
forEachBomEntry (theBomEnt, this)
theBomEnt->writeMrpSubSoln ();
}
d590 1
a590 1
fclose (solnFile ());
d592 1
a592 1
solnFile_ = NULL;
d594 2
a595 2
WitTimer::leaveSection ("extra");
}
d600 4
a603 4
{
if (not myFSS ()->computed ())
myFSS ()->compute ();
}
d608 28
a635 28
{
int  retVal;
char theCstring[2];

printf (
"\n"
"------------------------------------------------------\n"
"Pausing execution %s.\n"
"------------------------------------------------------\n"
"\n"
"To continue,\n"
"   type one non-blank character,\n"
"   followed by \"enter\".\n"
"\n",
theText);

retVal = scanf ("%1s", theCstring);
//
// The return value is stored in retVal to avoid a compiler warning on
// some platforms.

printf (
"\n"
"------------------------------------------------------\n"
"Resuming execution.\n"
"------------------------------------------------------\n"
"\n");
}
d640 26
a665 26
{
int origScenIdx;
int theIdx;

stronglyAssert (myStochImpMgr_->stochSolnMode ());

origScenIdx = myStochImpMgr_->currentScenario ();

for (theIdx = 0; theIdx < myStochImpMgr_->nScenarios (); theIdx ++)
{
myStochImpMgr_->setCurrentScenario (theIdx);

fprintf (solnFile (),
"\n"
"-------------------------------------------------"
"------------------------------------------------\n"
"Comprehensive Solution for Scenario #%d:\n"
"-------------------------------------------------"
"------------------------------------------------\n\n",
theIdx);

writeSolnInt ();
}

myStochImpMgr_->setCurrentScenario (origScenIdx);
}
d670 5
a674 5
{
WitPart *      thePart;
WitDemand *    theDemand;
WitOperation * theOpn;
WitBomEntry *  theBomEnt;
d676 3
a678 3
fprintf (solnFile (),
"Solution is feasible?         %s\n",
myMsgFac ().boolText (myCompMgr ()->myGlobalComp ()->feasible ()));
d680 3
a682 3
fprintf (solnFile (),
"Maximum constraint violation: %g\n",
myPostprocessor ()->myFeasChkr ()->maxViolation ());
d684 1
a684 1
fprintf (solnFile (), "\n\nComprehensive Solution for Parts:\n");
d686 2
a687 2
forEachPart (thePart, this)
thePart->writeSoln ();
d689 1
a689 1
fprintf (solnFile (), "\n\nComprehensive Solution for Demands:\n");
d691 2
a692 2
forEachDemand (theDemand, this)
theDemand->writeSoln ();
d694 1
a694 1
fprintf (solnFile (), "\n\nComprehensive Solution for Operations:\n");
d696 2
a697 2
forEachOperation (theOpn, this)
theOpn->writeSoln ();
d699 3
a701 3
if (myCompMgr ()->hasSubEntries ())
{
fprintf (solnFile (), "\n\nComprehensive Solution for Substitutes:\n");
d703 3
a705 3
forEachBomEntry (theBomEnt, this)
theBomEnt->writeSubSoln ();
}
d707 1
a707 1
writeBoundsSoln  ();
d709 3
a711 3
if (myOptComp ()->compPrices ())
{
fprintf (solnFile (), "\n\nShadow Prices:\n");
d713 3
a715 3
forEachPart (thePart, this)
thePart->writeDualSoln ();
}
d717 3
a719 3
if (DEVELOPMENT)
if (myGlobalComp ()->perfPegging ())
myHeurAllMgr_->printPegging ();
d721 2
a722 2
if (DEVELOPMENT)
myPipMgr_->printPegging ();
d724 4
a727 4
if (DEVELOPMENT)
if (myGlobalComp ()->pgdCritListMode ())
myGlobalComp ()->writePdgCritList ();
}
d732 24
a755 24
{
WitMaterial *  theMat;
WitDemand *    theDemand;
WitOperation * theOpn;

fprintf (solnFile (), "\n\nComprehensive Solution for Bounds:\n");

if (myCompMgr ()->nBoundSetsSpecified () == 0)
{
fprintf (solnFile (),
"\n\nNo bound sets specified for this implosion problem.\n");

return;
}

forEachMaterial (theMat, this)
theMat->stockBounds ()->writeSoln ();

forEachDemand (theDemand, this)
theDemand->cumShipBounds ()->writeSoln ();

forEachOperation (theOpn, this)
theOpn->execBounds ()->writeSoln ();
}
@


1.161
log
@CPLEX Parameters
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d54 1
a54 1
      mySession_            (theSession),
d56 71
a126 71
      myCompMgr_            (NULL),
      myPreprocessor_       (NULL),
      myPostprocessor_      (NULL),
      myHeurImploder_       (NULL),
      myEqAllocator_        (NULL),
      myHeurAllMgr_         (NULL),
      myDetOptImpMgr_       (NULL),
      myStochImpMgr_        (NULL),
      myPipMgr_             (NULL),
      myOrigMrpExp_         (NULL),
      myFSS_                (NULL),
      myDataReader_         (NULL),
      myDataWriter_         (NULL),
      mySolnWriter_         (NULL),

      myMsgFac_             (theSession->myMsgFac ()),
      myWitRun_             (theSession->myWitRun ()),
      myApiMgr_             (theSession->myApiMgr ()),
      solnFile_             (NULL),
      nPeriods_             (WitGlobalComp::defNPeriods ()),
      lastPeriod_           (nPeriods_ - 1),
      myObjLinkMgr_         (NULL),
      myIntPairLinkMgr_     (NULL),
      myBoolPairLinkMgr_    (NULL),
      myDblPairLinkMgr_     (NULL),
      myVoidPtrPairLinkMgr_ (NULL),
      myTripLinkMgr_        (NULL),
      optVariant_           (NULL),
      extOptVariant_        (NULL),
      heurVariant_          (NULL),
      heurOptVariant_       (NULL),
      inputVariant_         (NULL),
      allVariants_          (),
      currentVariant_       (NULL),
      scalarFlexVAsst_      (NULL),
      vectorFlexVAsst_      (NULL),
      dispDoubleVector_     (),
      dispIntVector_        (),
      dispBoolVector_       ()
   {
   scalarFlexVAsst_      = new WitFlexVAsst (this, false);
   vectorFlexVAsst_      = new WitFlexVAsst (this, true);

   myObjLinkMgr_         = new WitObjLinkMgr           (this);
   myIntPairLinkMgr_     = new WitPairLinkMgr <int>    (this);
   myBoolPairLinkMgr_    = new WitPairLinkMgr <bool>   (this);
   myDblPairLinkMgr_     = new WitPairLinkMgr <double> (this);
   myVoidPtrPairLinkMgr_ = new WitPairLinkMgr <void *> (this);
   myTripLinkMgr_        = new WitTripLinkMgr          (this);

   myPreprocessor_       = new WitPreprocessor  (this);
   myPostprocessor_      = new WitPostprocessor (this);
   myHeurImploder_       = new WitHeurImploder  (this);
   myEqAllocator_        = new WitEqAllocator   (this);
   myHeurAllMgr_         = new WitHeurAllMgr    (this);
   myDetOptImpMgr_       = new WitDetOptImpMgr  (this);
   myStochImpMgr_        = new WitStochImpMgr   (this);
   myPipMgr_             = new WitPipMgr        (this);
   myOrigMrpExp_         = new WitOrigMrpExp    (this);
   myFSS_                = new WitFSS           (this);
   myDataReader_         = new WitDataReader    (this);
   myDataWriter_         = new WitDataWriter    (this);
   mySolnWriter_         = new WitSolnWriter    (this);

   setUpVariants ();

   myCompMgr_            = new WitCompMgr       (this);

   myGlobalComp_         = new WitGlobalComp    (myCompMgr ());
   myOptComp_            = new WitOptComp       (myCompMgr ());
   }
d131 2
a132 2
   {
   myStochImpMgr_->setStochMode (false);
d134 1
a134 1
   myPreprocessor_->unpreprocess ();
d136 2
a137 2
   while (not allVariants_.isEmpty ())
      delete allVariants_.get ();
d139 29
a167 29
   delete myFSS_;
   delete mySolnWriter_;
   delete myDataWriter_;
   delete myDataReader_;
   delete myOrigMrpExp_;
   delete myPipMgr_;
   delete myStochImpMgr_;
   delete myDetOptImpMgr_;
   delete myHeurAllMgr_;
   delete myEqAllocator_;
   delete myHeurImploder_;
   delete myPostprocessor_;
   delete myPreprocessor_;

   myOptComp_    = NULL;
   myGlobalComp_ = NULL;

   delete myCompMgr_;

   WitAbsLinkMgr::deleteInstance (myTripLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myVoidPtrPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myDblPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myBoolPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myIntPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myObjLinkMgr_);

   delete scalarFlexVAsst_;
   delete vectorFlexVAsst_;
   }
d172 3
a174 3
   {
   return myCompMgr ()->myGlobalComp ()->wit34Compatible ();
   }
d179 3
a181 3
   {
   return myHeurAllMgr_->myHeurModifier ();
   }
d186 3
a188 3
   {
   allVariants_.append (theVariant);
   }
d193 6
a198 6
   {
   optVariant_     = new WitVariant (this);
   extOptVariant_  = new WitVariant (this);
   heurVariant_    = new WitVariant (this);
   heurOptVariant_ = new WitVariant (this);
   inputVariant_   = new WitVariant (this);
d200 1
a200 1
   WitVariant * theVariant;
d202 2
a203 2
   forEachEl (theVariant, allVariants_)
      theVariant->configure ();
d205 2
a206 2
   currentVariant_ = inputVariant ();
   }
d211 2
a212 2
   {
   resetSoln ();
d214 2
a215 2
   currentVariant_ = theVariant;
   }
d220 8
a227 8
   {
   if (dispDoubleVector_.isAllocated ())
      return;

   dispDoubleVector_.allocate (this, 0.0);
   dispIntVector_   .allocate (this, 0);
   dispBoolVector_  .allocate (this, false);
   }
d232 8
a239 8
   {
   if (not dispDoubleVector_.isAllocated ())
      return;

   dispDoubleVector_.clear ();
   dispIntVector_   .clear ();
   dispBoolVector_  .clear ();
   }
d244 2
a245 2
   {
   nPeriods_   = myGlobalComp ()->nPeriods ();
d247 1
a247 1
   lastPeriod_ = nPeriods_ - 1;
d249 3
a251 3
   scalarFlexVAsst_->updateNPeriods ();
   vectorFlexVAsst_->updateNPeriods ();
   }
d256 2
a257 2
   {
   WitTimer::enterSection ("extra");
d259 4
a262 4
   myMsgFac () ("witFileParam",
      (filename == NULL)?
         myMsgFac ().fileName ().myCstring ():
         filename);
d264 1
a264 1
   WitTempMsgFile theTemp (myMsgFac (), filename);
d266 1
a266 1
   mySession ()->printHeading ();
d268 1
a268 1
   myMsgFac () ("fileHeadingDdMsg");
d270 1
a270 1
   displayGlobalData ();
d272 4
a275 4
   if (myStochImpMgr_->stochMode ())
      myStochImpMgr_->displayDataStochMode ();
   else
      displayNonGlobalData ();
d277 1
a277 1
   myPipMgr_->displayShipSeq ();
d279 2
a280 2
   WitTimer::leaveSection ("extra");
   }
d285 59
a343 59
   {
   WitPart *      thePart;
   int            nCapacities;
   WitOperation * theOpn;
   int            nPosPens;

   myMsgFac () ("globalHeadingDdMsg");

   myMsgFac () ("titleMsg", myCompMgr ()->myGlobalComp ()->title ());
   myMsgFac () ("dimenHeadingDdMsg");

   nCapacities = 0;

   forEachPart (thePart, this)
      if (thePart->thisCap () != NULL)
         ++ nCapacities;

   myMsgFac () ("categorySizeDdMsg",
      myMsgFac ().myFrag ("capacityFrag"),
      nCapacities);

   myMsgFac () ("categorySizeDdMsg",
      myMsgFac ().myFrag ("materialFrag"),
      myCompMgr ()->nMaterials ());

   myMsgFac () ("dimenDataDdMsg",
      myCompMgr ()->nParts (),
      myCompMgr ()->nOperations (),
      myCompMgr ()->nDemands (),
                    nPeriods (),
      myCompMgr ()->nBoundSetsSpecified (),
      myCompMgr ()->nBoundSets (),
      myCompMgr ()->nBomEntries (),
      myCompMgr ()->nSubEntries (),
      myCompMgr ()->nBopEntries (),
      myCompMgr ()->nDelComps ());

   nPosPens = 0;

   forEachOperation (theOpn, this)
      if (theOpn->execPenalty () > 0.0)
         nPosPens ++;

   myMsgFac () ("globalDataDdMsg",
                                     wit34Compatible     (),
      myCompMgr ()->myGlobalComp ()->independentOffsets  (),
      myCompMgr ()->myGlobalComp ()->execEmptyBom        (),
      myCompMgr ()->myGlobalComp ()->computeCriticalList (),
      myCompMgr ()->myGlobalComp ()->pgdCritListMode     (),
      myCompMgr ()->myGlobalComp ()->hashTableSize       (),
      myCompMgr ()->myGlobalComp ()->roundReqVols        (),
      myCompMgr ()->myGlobalComp ()->outputPrecision     (),
      myCompMgr ()->myGlobalComp ()->useFocusHorizons    (),
                                     nPosPens,
      myPreprocessor ()->            preprocessed        ());

   if (myPreprocessor_->preprocessed ())
      myMsgFac () ("preprocDataDdMsg",
         myCompMgr ()->myGlobalComp ()->lotSizesExist ());
d345 2
a346 2
   myCompMgr ()->myGlobalComp ()->display ();
   myCompMgr ()->myOptComp    ()->display ();
d348 1
a348 1
   myStochImpMgr_->displayGlobalData ();
d350 2
a351 2
   myCompMgr ()->myOptComp ()->myCpxParSpecMgr ()->display ();
   }
d356 7
a362 7
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
   WitDemand *    theDemand;
d364 1
a364 1
   myMsgFac () ("partHeadingDdMsg");
d366 2
a367 2
   forEachPart (thePart, this)
      thePart->display ();
d369 1
a369 1
   myMsgFac () ("demandHeadingDdMsg");
d371 2
a372 2
   forEachDemand (theDemand, this)
      theDemand->display ();
d374 1
a374 1
   myMsgFac () ("operationHeadingDdMsg");
d376 2
a377 2
   forEachOperation (theOpn, this)
      theOpn->display ();
d379 1
a379 1
   myMsgFac () ("bomEntryHeadingDdMsg");
d381 2
a382 2
   forEachBomEntry (theBomEnt, this)
      theBomEnt->display ();
d384 1
a384 1
   myMsgFac () ("subHeadingDdMsg");
d386 2
a387 2
   forEachSubEntry (theSub, this)
      theSub->display ();
d389 1
a389 1
   myMsgFac () ("bopEntryHeadingDdMsg");
d391 3
a393 3
   forEachBopEntry (theBopEnt, this)
      theBopEnt->display ();
   }
d398 4
a401 4
      WitMsgID              theMsgID,
      const WitDblFlexVec & theFlexVec)
   {
   dispDoubleVector_ = theFlexVec;
d403 2
a404 2
   myMsgFac () (theMsgID, dispDoubleVector_);
   }
d409 7
a415 7
      WitMsgID                 theMsgID,
      const WitFlexVec <int> & theFlexVec)
   {
   dispIntVector_ = theFlexVec;
                    
   myMsgFac () (theMsgID, dispIntVector_);
   }
d420 4
a423 4
      WitMsgID                  theMsgID,
      const WitFlexVec <bool> & theFlexVec)
   {
   dispBoolVector_ = theFlexVec;
d425 2
a426 2
   myMsgFac () (theMsgID, dispBoolVector_);
   }
d431 3
a433 3
   {
   theObjVec.display (theMsgID, this);
   }
d438 8
a445 8
      WitMsgFragID          theFragID,
      const WitDblFlexVec & theFlexVec)
   {
   dispDoubleVector_ = theFlexVec;

   myMsgFac () ("boundDataDdMsg",
      myMsgFac ().myFrag (theFragID), dispDoubleVector_);
   }
d450 2
a451 2
   {
   WitComponent * theComp;
d453 1
a453 1
   myPreprocessor_->preprocess ();
d455 2
a456 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->copySelfInto (theProblem->myCompMgr ());
d458 2
a459 2
   theProblem->myStochImpMgr_->copyAttrsFrom (myStochImpMgr_);
   }
d464 2
a465 2
   {
   stronglyAssert (not myStochImpMgr ()->stochMode ());
d467 2
a468 2
   myPreprocessor_->unpreprocess ();
   }
d473 2
a474 2
   {
   stronglyAssert (not myStochImpMgr ()->stochMode ());
d476 2
a477 2
   resetSoln ();
   }
d482 3
a484 3
   {
   stronglyAssert (not myStochImpMgr ()->stochMode ());
   }
d489 3
a491 3
   {
   if (myStochImpMgr ()->stochMode ())
      myStochImpMgr ()->prepSetStochModeAttr (theAttName);
d493 2
a494 2
   resetSoln ();
   }
d499 2
a500 2
   {
   currentVariant_ = inputVariant ();
d502 1
a502 1
   myPostprocessor_->unpostprocess ();
d504 2
a505 2
   myHeurAllMgr ()->reset ();
   }
d510 2
a511 2
   {
   myPostprocessor_->postprocess ();
d513 1
a513 1
   WitTimer::enterSection ("extra");
d515 1
a515 1
   solnFile_ = mySession_->openFile (fileName, "w");
d517 1
a517 1
   mySession ()->writeHeading (solnFile ());
d519 1
a519 1
   fprintf (solnFile (), "Comprehensive Implosion Solution.\n\n");
d521 3
a523 3
   fprintf (solnFile (),
      "Solution provided by: %s.\n\n",
      myMsgFac ().fragText (currentVariant ()->myFragID ()));
d525 5
a529 5
   if (    (myStochImpMgr_->stochMode ())
       and (myStochImpMgr_->stochSolnMode ()))
      writeStochSoln ();
   else
      writeSolnInt ();
d531 1
a531 1
   fclose (solnFile ());
d533 1
a533 1
   solnFile_ = NULL;
d535 2
a536 2
   WitTimer::leaveSection ("extra");
   }
d541 3
a543 3
   //
   // Values must exceed this amount in order to appear in the comprehensive
   // solution output.
d548 6
a553 6
   {
   if (fabs (val) >= SOLN_EPSILON)
      fprintf (solnFile (), "  %11.3f", val);
   else
      fprintf (solnFile (), "             ");
   }
d558 4
a561 4
   {
   WitPart *      thePart;
   WitOperation * theOpn;
   WitBomEntry  * theBomEnt;
d563 1
a563 1
   WitTimer::enterSection ("extra");
d565 1
a565 1
   solnFile_ = mySession_->openFile (fileName, "w");
d567 1
a567 1
   mySession ()->writeHeading (solnFile ());
d569 1
a569 1
   fprintf (solnFile (), "Comprehensive MRP Solution.\n\n");
d571 1
a571 1
   fprintf (solnFile (), "\n\nComprehensive MRP Solution for Parts:\n");
d573 2
a574 2
   forEachPart (thePart, this)
      thePart->writeMrpSoln ();
d576 1
a576 1
   fprintf (solnFile (), "\n\nComprehensive MRP Solution for Operations:\n");
d578 2
a579 2
   forEachOperation (theOpn, this)
      theOpn->writeMrpSoln ();
d581 4
a584 4
   if (myCompMgr ()->hasSubEntries ())
      {
      fprintf (solnFile (),
         "\n\nComprehensive MRP Solution for Substitutes:\n");
d586 3
a588 3
      forEachBomEntry (theBomEnt, this)
         theBomEnt->writeMrpSubSoln ();
      }
d590 1
a590 1
   fclose (solnFile ());
d592 1
a592 1
   solnFile_ = NULL;
d594 2
a595 2
   WitTimer::leaveSection ("extra");
   }
d600 4
a603 4
   {
   if (not myFSS ()->computed ())
      myFSS ()->compute ();
   }
d608 28
a635 28
   {
   int  retVal;
   char theCstring[2];

   printf (
      "\n"
      "------------------------------------------------------\n"
      "Pausing execution %s.\n"
      "------------------------------------------------------\n"
      "\n"
      "To continue,\n"
      "   type one non-blank character,\n"
      "   followed by \"enter\".\n"
      "\n",
      theText);

   retVal = scanf ("%1s", theCstring);
      //
      // The return value is stored in retVal to avoid a compiler warning on
      // some platforms.

   printf (
      "\n"
      "------------------------------------------------------\n"
      "Resuming execution.\n"
      "------------------------------------------------------\n"
      "\n");
   }
d640 26
a665 26
   {
   int origScenIdx;
   int theIdx;

   stronglyAssert (myStochImpMgr_->stochSolnMode ());

   origScenIdx = myStochImpMgr_->currentScenario ();

   for (theIdx = 0; theIdx < myStochImpMgr_->nScenarios (); theIdx ++)
      {
      myStochImpMgr_->setCurrentScenario (theIdx);

      fprintf (solnFile (),
         "\n"
         "-------------------------------------------------"
         "------------------------------------------------\n"
         "Comprehensive Solution for Scenario #%d:\n"
         "-------------------------------------------------"
         "------------------------------------------------\n\n",
         theIdx);

      writeSolnInt ();
      }
      
   myStochImpMgr_->setCurrentScenario (origScenIdx);
   }
d670 5
a674 5
   {
   WitPart *      thePart;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
d676 3
a678 3
   fprintf (solnFile (),
      "Solution is feasible?         %s\n",
      myMsgFac ().boolText (myCompMgr ()->myGlobalComp ()->feasible ()));
d680 3
a682 3
   fprintf (solnFile (),
      "Maximum constraint violation: %g\n",
      myPostprocessor ()->myFeasChkr ()->maxViolation ());
d684 1
a684 1
   fprintf (solnFile (), "\n\nComprehensive Solution for Parts:\n");
d686 2
a687 2
   forEachPart (thePart, this)
      thePart->writeSoln ();
d689 1
a689 1
   fprintf (solnFile (), "\n\nComprehensive Solution for Demands:\n");
d691 2
a692 2
   forEachDemand (theDemand, this)
      theDemand->writeSoln ();
d694 1
a694 1
   fprintf (solnFile (), "\n\nComprehensive Solution for Operations:\n");
d696 2
a697 2
   forEachOperation (theOpn, this)
      theOpn->writeSoln ();
d699 3
a701 3
   if (myCompMgr ()->hasSubEntries ())
      {
      fprintf (solnFile (), "\n\nComprehensive Solution for Substitutes:\n");
d703 3
a705 3
      forEachBomEntry (theBomEnt, this)
         theBomEnt->writeSubSoln ();
      }
d707 1
a707 1
   writeBoundsSoln  ();
d709 3
a711 3
   if (myOptComp ()->compPrices ())
      {
      fprintf (solnFile (), "\n\nShadow Prices:\n");
d713 3
a715 3
      forEachPart (thePart, this)
         thePart->writeDualSoln ();
      }
d717 3
a719 3
   if (DEVELOPMENT)
      if (myGlobalComp ()->perfPegging ())
         myHeurAllMgr_->printPegging ();
d721 2
a722 2
   if (DEVELOPMENT)
      myPipMgr_->printPegging ();
d724 4
a727 4
   if (DEVELOPMENT)
      if (myGlobalComp ()->pgdCritListMode ())
         myGlobalComp ()->writePdgCritList ();
   }
d732 24
a755 24
   {
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;

   fprintf (solnFile (), "\n\nComprehensive Solution for Bounds:\n");

   if (myCompMgr ()->nBoundSetsSpecified () == 0)
      {
      fprintf (solnFile (),
         "\n\nNo bound sets specified for this implosion problem.\n");

      return;
      }

   forEachMaterial (theMat, this)
      theMat->stockBounds ()->writeSoln ();

   forEachDemand (theDemand, this)
      theDemand->cumShipBounds ()->writeSoln ();

   forEachOperation (theOpn, this)
      theOpn->execBounds ()->writeSoln ();
   }
@


1.160
log
@Modifiable heuristic allocation
@
text
@d43 1
d349 2
@


1.159
log
@Heuristic Adjustment
@
text
@d177 1
a177 1
WitHeurAdjuster * WitProblem::myHeurAdjuster ()
d179 1
a179 1
   return myHeurAllMgr_->myHeurAdjuster ();
@


1.158
log
@Heuristic Adjustment
@
text
@a18 1
#include <HeurAdjuster.h>
a60 1
      myHeurAdjuster_       (NULL),
a109 1
   myHeurAdjuster_       = new WitHeurAdjuster  (this);
a145 1
   delete myHeurAdjuster_;
d177 7
@


1.157
log
@Heuristic Adjustment
@
text
@d19 1
a19 1
#include <HeurAdjMgr.h>
d62 1
a62 1
      myHeurAdjMgr_         (NULL),
d112 1
a112 1
   myHeurAdjMgr_         = new WitHeurAdjMgr    (this);
d149 1
a149 1
   delete myHeurAdjMgr_;
@


1.156
log
@Heuristic Adjustment
@
text
@d40 1
a40 1
#include <Opn.h>
@


1.155
log
@Pause/Resume
@
text
@d19 1
a19 1
#include <HeurPauseMgr.h>
d62 1
a62 1
      myHeurPauseMgr_       (NULL),
d112 1
a112 1
   myHeurPauseMgr_       = new WitHeurPauseMgr  (this);
d149 1
a149 1
   delete myHeurPauseMgr_;
@


1.154
log
@pause/resume
@
text
@d19 1
d62 1
d112 1
d149 1
@


1.153
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d600 1
a600 1
   char theCstring[10];
d607 5
a611 1
      "Enter any character to continue.\n",
d614 1
a614 1
   retVal = scanf ("%s", theCstring);
d620 2
@


1.152
log
@Multi-objective mode
@
text
@d35 1
a35 1
#include <Global.h>
@


1.151
log
@Multi-Objective Mode
@
text
@d499 1
a499 1
void WitProblem::writeSoln (const WitString & fileName)
d505 1
a505 1
   solnFile_ = mySession_->openFile (fileName.myCstring (), "w");
d547 1
a547 1
void WitProblem::writeMrpSoln (const WitString & fileName)
d555 1
a555 1
   solnFile_ = mySession_->openFile (fileName.myCstring (), "w");
@


1.150
log
@Removing objective #2.
@
text
@d420 7
@


1.149
log
@Made WIT operate in multi-thread mode unconditionally.
The multithread attribute in no longer meaningful.
@
text
@a491 7
void WitProblem::genPriorities ()
   {
   WitDemand::genPriorities (this);
   }

//------------------------------------------------------------------------------

@


1.148
log
@Attempt to accommodate a warning about the return value from scanf.
@
text
@d331 1
a331 2
      myPreprocessor ()->            preprocessed        (),
                          WitApiMgr::multiThread         ());
@


1.147
log
@Stochastic Implosion
@
text
@d600 1
d611 4
a614 1
   scanf ("%s", theCstring);
@


1.146
log
@Stochastic Implosion
@
text
@d627 1
a627 1
   origScenIdx = myStochImpMgr_->curScenarioIndex ();
d631 1
a631 1
      myStochImpMgr_->setCurScenarioIndex (theIdx);
d645 1
a645 1
   myStochImpMgr_->setCurScenarioIndex (origScenIdx);
@


1.145
log
@Stochastic Implosion
@
text
@d472 10
@


1.144
log
@Stochastic Implosion
@
text
@a471 15
void WitProblem::prepSetStochModeAttr (const char * theAttName)
   {
   if (myStochImpMgr ()->stochMode ())
      {
      stronglyAssert (myStochImpMgr ()->canSetInStochMode (theAttName));

      if (myStochImpMgr ()->stochSolnMode ())
         stronglyAssert (myStochImpMgr ()->canSetInStochSolnMode (theAttName));
      }

   resetSoln ();
   }

//------------------------------------------------------------------------------

@


1.143
log
@Stochastic Implosion
@
text
@a15 4
#include <Global.h>
#include <OptComp.h>
#include <Material.h>
#include <BopEntry.h>
d35 7
@


1.142
log
@Stochastic Implosion
@
text
@d629 1
a629 1
   origScenIdx = myStochImpMgr_->curScenarioNo ();
d633 1
a633 1
      myStochImpMgr_->setCurScenarioNo (theIdx);
d647 1
a647 1
   myStochImpMgr_->setCurScenarioNo (origScenIdx);
@


1.141
log
@Stochastic Implosion
@
text
@d128 1
a128 2
   if (myStochImpMgr_->stochImpAllowed ())
      myStochImpMgr_->setStochMode (false);
@


1.140
log
@Stochastic Implosion
@
text
@d630 1
a630 1
   origScenIdx = myStochImpMgr_->scenarioIndex ();
d634 1
a634 1
      myStochImpMgr_->setScenarioIndex (theIdx);
d648 1
a648 1
   myStochImpMgr_->setScenarioIndex (origScenIdx);
@


1.139
log
@Stochastic Implosion
@
text
@d637 6
a642 2
         "\n\n\n"
         "Comprehensive Solution for Scenario #%d:\n\n",
@


1.138
log
@Stochastic Implosion
@
text
@d23 1
a23 1
#include <OptImp.h>
d58 1
a58 1
      myOptImploder_        (NULL),
d107 1
a107 1
   myOptImploder_        = new WitOptImploder   (this);
d143 1
a143 1
   delete myOptImploder_;
@


1.137
log
@Stochastic Implosion
@
text
@a246 7
   WitPart *      thePart;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
   WitDemand *    theDemand;

d262 4
a265 29
   myMsgFac () ("partHeadingDdMsg");

   forEachPart (thePart, this)
      thePart->display ();

   myMsgFac () ("demandHeadingDdMsg");

   forEachDemand (theDemand, this)
      theDemand->display ();

   myMsgFac () ("operationHeadingDdMsg");

   forEachOperation (theOpn, this)
      theOpn->display ();

   myMsgFac () ("bomEntryHeadingDdMsg");

   forEachBomEntry (theBomEnt, this)
      theBomEnt->display ();

   myMsgFac () ("subHeadingDdMsg");

   forEachSubEntry (theSub, this)
      theSub->display ();

   myMsgFac () ("bopEntryHeadingDdMsg");

   forEachBopEntry (theBopEnt, this)
      theBopEnt->display ();
a268 2
   myStochImpMgr_->display ();

d338 44
@


1.136
log
@Stochastic Implosion
@
text
@d464 1
a464 1
      stronglyAssert (myStochImpMgr ()->attIsStochModeOK (theAttName));
d467 1
a467 1
         stronglyAssert (myStochImpMgr ()->attIsStochSolnModeOK (theAttName));
@


1.135
log
@Stochastic Implosion
@
text
@d464 1
a464 1
      stronglyAssert (myStochImpMgr ()->isStochModeAttName (theAttName));
d467 1
a467 1
         stronglyAssert (myStochImpMgr ()->isStochSolnModeAttName (theAttName));
@


1.134
log
@Stochastic Implosion
@
text
@d460 1
a460 1
void WitProblem::prepSetStochModeAttr ()
d463 2
a464 1
      stronglyAssert (not myStochImpMgr ()->stochSolnMode ());
d466 3
a468 2
   resetSoln ();
   }
a469 4
//------------------------------------------------------------------------------

void WitProblem::prepSetStochSolnModeAttr ()
   {
@


1.133
log
@Stochastic Implosion
@
text
@d462 10
@


1.132
log
@Stochastic Implosion
@
text
@d437 1
a437 1
   myStochImpMgr ()->prepSetAttr ();
d446 1
a446 1
   myStochImpMgr ()->prepSetAttr ();
d455 8
a462 1
   myStochImpMgr ()->prepSetAttr ();
@


1.131
log
@Stochastic Implosion
@
text
@a367 1
         myPreprocessor_->optPreprocessed (),
@


1.130
log
@Stochastic Implosion
@
text
@d129 1
a129 1
      myStochImpMgr_->setStochDataMode (false);
d495 1
a495 1
   if (    (myStochImpMgr_->stochDataMode ())
@


1.129
log
@Stochastic Implosion
@
text
@a30 1
#include <AttMgr.h>
a52 1
      myAttMgr_             (NULL),
a101 1
   myAttMgr_             = new WitAttMgr        (this);
a148 1
   delete myAttMgr_;
@


1.128
log
@Stochastic Implosion
@
text
@d31 1
d54 1
d104 1
d152 1
@


1.127
log
@Stochastic Implosion
@
text
@d24 1
a24 1
#include <StochMgr.h>
d59 1
a59 1
      myStochMgr_           (NULL),
d108 1
a108 1
   myStochMgr_           = new WitStochMgr      (this);
d128 2
a129 2
   if (myStochMgr_->stochImpAllowed ())
      myStochMgr_->setStochDataMode (false);
d142 1
a142 1
   delete myStochMgr_;
d301 1
a301 1
   myStochMgr_->display ();
d431 1
a431 1
   theProblem->myStochMgr_->copyAttrsFrom (myStochMgr_);
d438 1
a438 1
   myStochMgr ()->prepSetAttr ();
d447 1
a447 1
   myStochMgr ()->prepSetAttr ();
d456 1
a456 1
   myStochMgr ()->prepSetAttr ();
d495 2
a496 1
   if ((myStochMgr_->stochDataMode ()) and (myStochMgr_->stochSolnMode ()))
d604 1
a604 1
   stronglyAssert (myStochMgr_->stochSolnMode ());
d606 1
a606 1
   origScenIdx = myStochMgr_->scenarioIndex ();
d608 1
a608 1
   for (theIdx = 0; theIdx < myStochMgr_->nScenarios (); theIdx ++)
d610 1
a610 1
      myStochMgr_->setScenarioIndex (theIdx);
d620 1
a620 1
   myStochMgr_->setScenarioIndex (origScenIdx);
@


1.126
log
@Stochastic Implosion
@
text
@d495 1
a495 1
   if ((myStochMgr_->stochDataMode ()) and (myStochMgr_->stochSolnExists ()))
d603 1
a603 1
   stronglyAssert (myStochMgr_->stochSolnExists ());
@


1.125
log
@Stochastic Implosion
@
text
@a480 5
   WitPart *      thePart;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;

d495 4
a498 51
   fprintf (solnFile (),
      "Solution is feasible?         %s\n",
      myMsgFac ().boolText (myCompMgr ()->myGlobalComp ()->feasible ()));

   fprintf (solnFile (),
      "Maximum constraint violation: %g\n",
      myPostprocessor ()->myFeasChkr ()->maxViolation ());

   fprintf (solnFile (), "\n\nComprehensive Solution for Parts:\n");

   forEachPart (thePart, this)
      thePart->writeSoln ();

   fprintf (solnFile (), "\n\nComprehensive Solution for Demands:\n");

   forEachDemand (theDemand, this)
      theDemand->writeSoln ();

   fprintf (solnFile (), "\n\nComprehensive Solution for Operations:\n");

   forEachOperation (theOpn, this)
      theOpn->writeSoln ();

   if (myCompMgr ()->hasSubEntries ())
      {
      fprintf (solnFile (), "\n\nComprehensive Solution for Substitutes:\n");

      forEachBomEntry (theBomEnt, this)
         theBomEnt->writeSubSoln ();
      }

   writeBoundsSoln  ();

   if (myOptComp ()->compPrices ())
      {
      fprintf (solnFile (), "\n\nShadow Prices:\n");

      forEachPart (thePart, this)
         thePart->writeDualSoln ();
      }

   if (DEVELOPMENT)
      if (myGlobalComp ()->perfPegging ())
         myHeurAllMgr_->printPegging ();

   if (DEVELOPMENT)
      myPipMgr_->printPegging ();

   if (DEVELOPMENT)
      if (myGlobalComp ()->pgdCritListMode ())
         myGlobalComp ()->writePdgCritList ();
d598 88
@


1.124
log
@Stochastic Implosion
@
text
@d436 1
a436 1
void WitProblem::settingUnpreAttr ()
d438 1
a438 1
   myStochMgr ()->settingAttr ();
d445 1
a445 1
void WitProblem::settingUnpostAttr ()
d447 1
a447 1
   myStochMgr ()->settingAttr ();
d454 1
a454 1
void WitProblem::settingNonUnpostAttr ()
d456 1
a456 1
   myStochMgr ()->settingAttr ();
@


1.123
log
@Stochastic Implosion
@
text
@d438 2
d447 1
a447 4
   stronglyAssert (not myStochMgr ()->stochDataMode ());

   resetSoln ();
   }
a448 4
//------------------------------------------------------------------------------

void WitProblem::settingStochAttr ()
   {
d456 1
a456 1
   stronglyAssert (not myStochMgr ()->stochDataMode ());
@


1.122
log
@Stochastic Implosion
@
text
@d129 1
a129 1
      myStochMgr_->setStochasticMode (false);
d445 1
a445 1
   stronglyAssert (not myStochMgr ()->stochasticMode ());
d461 1
a461 1
   stronglyAssert (not myStochMgr ()->stochasticMode ());
@


1.121
log
@Stochastic Implosion
@
text
@d129 1
a129 1
      myStochMgr_->setStochImpMode (false);
d445 1
a445 1
   stronglyAssert (not myStochMgr ()->stochImpMode ());
d461 1
a461 1
   stronglyAssert (not myStochMgr ()->stochImpMode ());
@


1.120
log
@Stochastic implosion.
@
text
@d301 2
a372 2

   myStochMgr_                  ->display ();
@


1.119
log
@Stochastic implosion.
@
text
@d129 1
a129 1
      myStochMgr_->setActive (false);
d445 1
a445 1
   stronglyAssert (not myStochMgr ()->active ());
d461 1
a461 1
   stronglyAssert (not myStochMgr ()->active ());
@


1.118
log
@Stochastic implosion.
@
text
@d459 7
@


1.117
log
@Stochastic implosion.
@
text
@d436 23
a465 2

   myStochMgr ()->resetSoln ();
@


1.116
log
@Stochastic implosion.
@
text
@d443 2
@


1.115
log
@Stochastic implosion.
@
text
@d129 1
a129 1
      myStochMgr_->setStochImpActive (false);
@


1.114
log
@Stochastic implosion.
@
text
@d128 3
@


1.113
log
@Stochastic Implosion.
@
text
@d368 2
d427 2
@


1.112
log
@witCopy<Object>Data
@
text
@d24 1
d59 1
d108 1
d139 1
@


1.111
log
@witCopy<Object>Data
@
text
@a70 1
      copyingIntoProblem_   (NULL),
a418 2
   copyingIntoProblem_ = theProblem;

a420 2

   copyingIntoProblem_ = NULL;
@


1.110
log
@External opt implosion.
@
text
@d315 1
a315 1
      if (thePart->isaCapacity ())
@


1.109
log
@External optimizing implosion.
@
text
@d78 5
a82 5
      myOptVariant_         (NULL),
      myExtOptVariant_      (NULL),
      myHeurVariant_        (NULL),
      myHeurOptVariant_     (NULL),
      myInputVariant_       (NULL),
d178 5
a182 5
   myOptVariant_     = new WitVariant (this);
   myExtOptVariant_  = new WitVariant (this);
   myHeurVariant_    = new WitVariant (this);
   myHeurOptVariant_ = new WitVariant (this);
   myInputVariant_   = new WitVariant (this);
d189 1
a189 1
   currentVariant_ = myInputVariant ();
d432 1
a432 1
   currentVariant_ = myInputVariant ();
@


1.108
log
@external opt implosion.
@
text
@d79 1
d179 1
@


1.107
log
@App controlled opt implosion.
@
text
@d32 1
d473 1
a473 1
      myPostprocessor ()->maxViolation ());
@


1.106
log
@App controlled opt implosion.
@
text
@a36 1
#include <DataAlt.h>
a82 3
      noOpAlt_              (NULL),
      postprocAlt_          (NULL),
      preprocAlt_           (NULL),
a111 4
   noOpAlt_              = new WitDataAlt       (this);
   postprocAlt_          = new WitDataAlt       (this);
   preprocAlt_           = new WitDataAlt       (this);

d114 1
a114 1
   myCompMgr_          = new WitCompMgr       (this);
d116 2
a117 2
   myGlobalComp_       = new WitGlobalComp    (myCompMgr ());
   myOptComp_          = new WitOptComp       (myCompMgr ());
a140 3
   delete noOpAlt_;
   delete postprocAlt_;
   delete preprocAlt_;
d193 1
a193 1
   postprocAlt ()->incur ();
d427 1
a427 1
void WitProblem::incur (WitDataAlt * theDataAlt)
a428 5
   witAssert (theDataAlt->myProblem () == this);

   if (theDataAlt == noOpAlt ())
      return;

a433 3

   if (theDataAlt == preprocAlt ())
      myPreprocessor_->unpreprocess ();
@


1.105
log
@App controlled opt implosion.
@
text
@d132 1
a132 1
   unpreprocess ();
d363 1
a363 1
                                     preprocessed        (),
d366 1
a366 1
   if (preprocessed ())
d368 1
a368 1
         optPreprocessed (),
d426 1
a426 1
   preprocess ();
d447 1
a447 1
   unpostprocess ();
d452 1
a452 1
      unpreprocess ();
a463 63
bool WitProblem::preprocessed ()
   {
   return myPreprocessor_->preprocessed ();
   }

//------------------------------------------------------------------------------

void WitProblem::preprocess ()
   {
   myPreprocessor_->preprocess ();
   }

//------------------------------------------------------------------------------

bool WitProblem::optPreprocessed ()
   {
   return myPreprocessor_->optPreprocessed ();
   }

//------------------------------------------------------------------------------

void WitProblem::optPreprocess ()
   {
   myPreprocessor_->optPreprocess ();
   }

//------------------------------------------------------------------------------

void WitProblem::unpreprocess ()
   {
   myPreprocessor_->unpreprocess ();
   }

//------------------------------------------------------------------------------

void WitProblem::heurAllocIsReset ()
   {
   myEqAllocator ()->heurAllocIsReset ();
   }

//------------------------------------------------------------------------------

bool WitProblem::postprocessed ()
   {
   return myPostprocessor_->postprocessed ();
   }

//------------------------------------------------------------------------------

void WitProblem::postprocess ()
   {
   myPostprocessor_->postprocess ();
   }

//------------------------------------------------------------------------------

void WitProblem::unpostprocess ()
   {
   myPostprocessor_->unpostprocess ();
   }

//------------------------------------------------------------------------------

d471 1
a471 1
   postprocess ();
@


1.104
log
@App controlled opt implosion.
@
text
@d492 7
a697 7
void WitProblem::unpreprocess ()
   {
   myPreprocessor_->unpreprocess ();
   }

//------------------------------------------------------------------------------

@


1.103
log
@Updated the copyright date on all source files.
@
text
@d438 1
a438 1
void WitProblem::incur (const WitDataAlt * theDataAlt)
@


1.102
log
@GPIP
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.101
log
@[shared-resource pegging]
@
text
@d669 1
a669 1
void WitProblem::pauseForInput ()
d675 5
a679 3
      "--------------------------------\n"
      "Pausing execution.\n"
      "Enter any character to continue.\n");
d685 1
a685 1
      "--------------------------------\n"
@


1.100
log
@[shared-resource pegging]
@
text
@a72 1
      myDblDblLinkMgr_      (NULL),
a96 1
   myDblDblLinkMgr_      = new WitDblDblLinkMgr        (this);
a162 1
   WitAbsLinkMgr::deleteInstance (myDblDblLinkMgr_);
@


1.99
log
@[shared-resource pegging]
@
text
@d73 1
d98 1
d165 1
@


1.98
log
@[shared-resource pegging]
@
text
@d49 1
a49 1
      mySession_          (theSession),
d51 68
a118 68
      myCompMgr_          (NULL),
      myPreprocessor_     (NULL),
      myPostprocessor_    (NULL),
      myHeurImploder_     (NULL),
      myEqAllocator_      (NULL),
      myHeurAllMgr_       (NULL),
      myOptImploder_      (NULL),
      myPipMgr_           (NULL),
      myOrigMrpExp_       (NULL),
      myFSS_              (NULL),
      myDataReader_       (NULL),
      myDataWriter_       (NULL),
      mySolnWriter_       (NULL),

      myMsgFac_           (theSession->myMsgFac ()),
      myWitRun_           (theSession->myWitRun ()),
      myApiMgr_           (theSession->myApiMgr ()),
      solnFile_           (NULL),
      nPeriods_           (WitGlobalComp::defNPeriods ()),
      lastPeriod_         (nPeriods_ - 1),
      copyingIntoProblem_ (NULL),
      myObjLinkMgr_       (NULL),
      myIntPairLinkMgr_   (NULL),
      myBoolPairLinkMgr_  (NULL),
      myDblPairLinkMgr_   (NULL),
      myTlPtrPairLinkMgr_ (NULL),
      myTripLinkMgr_      (NULL),
      myOptVariant_       (NULL),
      myHeurVariant_      (NULL),
      myHeurOptVariant_   (NULL),
      myInputVariant_     (NULL),
      allVariants_        (),
      currentVariant_     (NULL),
      noOpAlt_            (NULL),
      postprocAlt_        (NULL),
      preprocAlt_         (NULL),
      scalarFlexVAsst_    (NULL),
      vectorFlexVAsst_    (NULL),
      dispDoubleVector_   (),
      dispIntVector_      (),
      dispBoolVector_     ()
   {
   scalarFlexVAsst_    = new WitFlexVAsst (this, false);
   vectorFlexVAsst_    = new WitFlexVAsst (this, true);

   myObjLinkMgr_       = new WitObjLinkMgr           (this);
   myIntPairLinkMgr_   = new WitPairLinkMgr <int>    (this);
   myBoolPairLinkMgr_  = new WitPairLinkMgr <bool>   (this);
   myDblPairLinkMgr_   = new WitPairLinkMgr <double> (this);
   myTlPtrPairLinkMgr_ = new WitPairLinkMgr <void *> (this);
   myTripLinkMgr_      = new WitTripLinkMgr          (this);

   myPreprocessor_     = new WitPreprocessor  (this);
   myPostprocessor_    = new WitPostprocessor (this);
   myHeurImploder_     = new WitHeurImploder  (this);
   myEqAllocator_      = new WitEqAllocator   (this);
   myHeurAllMgr_       = new WitHeurAllMgr    (this);
   myOptImploder_      = new WitOptImploder   (this);
   myPipMgr_           = new WitPipMgr        (this);
   myOrigMrpExp_       = new WitOrigMrpExp    (this);
   myFSS_              = new WitFSS           (this);
   myDataReader_       = new WitDataReader    (this);
   myDataWriter_       = new WitDataWriter    (this);
   mySolnWriter_       = new WitSolnWriter    (this);

   noOpAlt_            = new WitDataAlt       (this);
   postprocAlt_        = new WitDataAlt       (this);
   preprocAlt_         = new WitDataAlt       (this);
d159 1
a159 1
   WitAbsLinkMgr::deleteInstance (myTlPtrPairLinkMgr_);
@


1.97
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d96 6
a101 6
   myObjLinkMgr_       = new WitObjLinkMgr               (this);
   myIntPairLinkMgr_   = new WitPairLinkMgr <int>        (this);
   myBoolPairLinkMgr_  = new WitPairLinkMgr <bool>       (this);
   myDblPairLinkMgr_   = new WitPairLinkMgr <double>     (this);
   myTlPtrPairLinkMgr_ = new WitPairLinkMgr <WitTlObj *> (this);
   myTripLinkMgr_      = new WitTripLinkMgr              (this);
@


1.96
log
@[multi-thread]
@
text
@d531 1
a531 1
   solnFile_ = mySession_->openFile (fileName, "w");
d627 1
a627 1
   solnFile_ = mySession_->openFile (fileName, "w");
@


1.95
log
@[multi-thread]
@
text
@a43 2
#include <ctype.h>

@


1.94
log
@[multi-thread]
@
text
@d533 1
a533 1
   solnFile_ = openFile (fileName, "w");
d629 1
a629 1
   solnFile_ = openFile (fileName, "w");
@


1.93
log
@[multi-thread]
@
text
@d522 1
a522 1
void WitProblem::writeSoln (const WitString & fileName, bool fssInput)
a557 5
   if (fssInput)
      fprintf (solnFile (), "\nUse Focus Horizons?   %s\n",
         myMsgFac ().boolText (
            myCompMgr ()->myGlobalComp ()->useFocusHorizons ()));

d559 1
a559 1
      theDemand->writeSoln (fssInput);
@


1.92
log
@Vector Prop-Rt.
@
text
@d365 2
a366 1
                                     preprocessed        ());
@


1.91
log
@Vector PropRt.
@
text
@d92 2
a93 1
      dispIntVector_      ()
d220 1
d232 1
d404 1
a404 1
   WitPeriod thePer;
d406 1
a406 18
   forEachPeriod (thePer, this)
      dispIntVector_[thePer] = theFlexVec[thePer];

   myMsgFac () (theMsgID, dispIntVector_);
   }

//------------------------------------------------------------------------------

void WitProblem::display (
      WitMsgID               theMsgID,
      const WitTVec <bool> & theTVec)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, this)
      dispIntVector_[thePer] = theTVec[thePer];

   myMsgFac () (theMsgID, dispIntVector_);
@


1.90
log
@Pegged Critical List.
@
text
@d397 1
a397 1
void WitProblem::displayBoolVec (
d411 1
a411 1
void WitProblem::displayBoolVec (
@


1.89
log
@pegged Critical List.
@
text
@d356 1
a356 1
      myCompMgr ()->myGlobalComp ()->pgdCritListNeeded   (),
d610 1
a610 1
      if (myGlobalComp ()->pgdCritListNeeded ())
@


1.88
log
@Pegged Critical List
@
text
@a22 1
#include <PclMgr.h>
d611 1
a611 1
         myHeurAllMgr_->myPclMgr ()->print ();
@


1.87
log
@Pegged Critical List.
@
text
@d357 1
a357 1
      myCompMgr ()->myGlobalComp ()->compPgdCritList     (),
d611 1
a611 1
      if (myGlobalComp ()->compPgdCritList ())
@


1.86
log
@Tie Breaking Prop-Rt.
@
text
@d23 1
d357 1
d610 4
@


1.85
log
@PIP.
@
text
@d25 1
a25 1
#include <PipSysMgr.h>
d60 1
a60 1
      myPipSysMgr_        (NULL),
d110 1
a110 1
   myPipSysMgr_        = new WitPip::SysMgr   (this);
d143 1
a143 1
   delete myPipSysMgr_;
d300 1
a300 1
   myPipSysMgr_->displayShipSeq ();
d606 1
a606 1
      myPipSysMgr_->printPegging ();
@


1.84
log
@Double Precision.
@
text
@d378 1
a378 1
   theFlexVec.copyInto (dispDoubleVector_);
d389 2
a390 2
   theFlexVec.copyInto (dispIntVector_);

d428 1
a428 1
   theFlexVec.copyInto (dispDoubleVector_);
@


1.83
log
@Double Precision.
@
text
@a623 7
void WitProblem::writeSolnValue (float val)
   {
   writeSolnValue (dblFromFlt (val));
   }

//------------------------------------------------------------------------------

@


1.82
log
@Double Precision.
@
text
@d91 1
a91 1
      dispFloatVector_    (),
d214 1
a214 1
   if (dispFloatVector_.isAllocated ())
d217 2
a218 2
   dispFloatVector_.allocate (this, 0.0);
   dispIntVector_  .allocate (this, 0);
d225 1
a225 1
   if (not dispFloatVector_.isAllocated ())
d228 2
a229 2
   dispFloatVector_.clear ();
   dispIntVector_  .clear ();
d378 1
a378 1
   theFlexVec.copyInto (dispFloatVector_);
d380 1
a380 1
   myMsgFac () (theMsgID, dispFloatVector_);
d428 1
a428 1
   theFlexVec.copyInto (dispFloatVector_);
d431 1
a431 1
      myMsgFac ().myFrag (theFragID), dispFloatVector_);
@


1.81
log
@Double Precision.
@
text
@d378 1
a378 1
   theFlexVec.convCopyInto (dispFloatVector_);
d389 1
a389 1
   theFlexVec.convCopyInto (dispIntVector_);
d428 1
a428 1
   theFlexVec.convCopyInto (dispFloatVector_);
@


1.80
log
@Double Precision.
@
text
@d375 2
a376 2
      WitMsgID                    theMsgID,
      const WitFlexVec <double> & theFlexVec)
d378 1
a378 1
   convCopy (dispFloatVector_, theFlexVec);
d425 2
a426 2
      WitMsgFragID                theFragID,
      const WitFlexVec <double> & theFlexVec)
d428 1
a428 1
   convCopy (dispFloatVector_, theFlexVec);
@


1.79
log
@Double Precision.
@
text
@a374 11
      WitMsgID                   theMsgID,
      const WitFlexVec <float> & theFlexVec)
   {
   theFlexVec.convCopyInto (dispFloatVector_);

   myMsgFac () (theMsgID, dispFloatVector_);
   }

//------------------------------------------------------------------------------

void WitProblem::display (
a419 12
   }

//------------------------------------------------------------------------------

void WitProblem::displayBoundVec (
      WitMsgFragID               theFragID,
      const WitFlexVec <float> & theFlexVec)
   {
   theFlexVec.convCopyInto (dispFloatVector_);

   myMsgFac () ("boundDataDdMsg",
      myMsgFac ().myFrag (theFragID), dispFloatVector_);
@


1.78
log
@Double Precision.
@
text
@d39 1
a39 2
#include <RealVec.h>
#include <FlexVAsst.h>
d385 3
a387 1
void WitProblem::display (WitMsgID theMsgID, const WitRealVec & theRealVec)
d389 1
a389 1
   theRealVec.convCopyInto (dispFloatVector_);
d448 2
a449 2
      WitMsgFragID       theFragID,
      const WitRealVec & theRealVec)
d451 1
a451 1
   theRealVec.convCopyInto (dispFloatVector_);
@


1.77
log
@Double Precision.
@
text
@d40 1
d72 2
a73 2
      nPeriodsPtr_        (NULL),
      lastPeriodPtr_      (NULL),
d90 2
d95 3
d126 2
a127 4
   myGlobalComp_       = new WitGlobalComp (myCompMgr ());
   myOptComp_          = new WitOptComp    (myCompMgr ());
   nPeriodsPtr_        = & myCompMgr ()->myGlobalComp ()->nPeriods ();
   lastPeriodPtr_      = & myCompMgr ()->myGlobalComp ()->lastPeriod ();
d155 2
a156 4
   lastPeriodPtr_ = NULL;
   nPeriodsPtr_   = NULL;
   myOptComp_     = NULL;
   myGlobalComp_  = NULL;
d166 3
d231 12
@


1.76
log
@Double precision: Switched to the new vector storage techniques.
@
text
@d369 1
a369 3
void WitProblem::display (
      WitMsgID              theMsgID,
      const WitFltRealVec & theFltRealVec)
d371 1
a371 23
   theFltRealVec.convCopyInto (dispFloatVector_);

   myMsgFac () (theMsgID, dispFloatVector_);
   }

//------------------------------------------------------------------------------

void WitProblem::display (
      WitMsgID              theMsgID,
      const WitDblRealVec & theDblRealVec)
   {
   theDblRealVec.convCopyInto (dispFloatVector_);

   myMsgFac () (theMsgID, dispFloatVector_);
   }

//------------------------------------------------------------------------------

void WitProblem::display (
      WitMsgID              theMsgID,
      const WitFltRealTVc & theFltRealTVc)
   {
   theFltRealTVc.convCopyInto (dispFloatVector_);
@


1.75
log
@Double Precision.
@
text
@a123 6

   if (USE_DBL_STORAGE)
      myMsgFac () ("usingDblVecMsg");

   if (USE_COMPACT_VECS)
      myMsgFac () ("usingCompactVecMsg");
@


1.74
log
@Double Precision.
@
text
@d127 3
@


1.73
log
@Double Precision.
@
text
@d373 2
a374 2
      WitMsgID           theMsgID,
      const WitRealVec & theRealVec)
d376 23
a398 1
   theRealVec.convCopyInto (dispFloatVector_);
@


1.72
log
@Double Precision.
@
text
@d125 1
a125 1
   if (WitRealVec::usingDbl ())
@


1.71
log
@Double Precision.
@
text
@d124 3
@


1.70
log
@Double Precision.
@
text
@d362 1
a362 1
   theFlexVec.copyIntoTVec (dispFloatVector_);
d373 1
a373 1
   theRealVec.copyIntoFltTVec (dispFloatVector_);
d384 1
a384 1
   theFlexVec.copyIntoTVec (dispIntVector_);
d423 1
a423 1
   theFlexVec.copyIntoTVec (dispFloatVector_);
d435 1
a435 1
   theRealVec.copyIntoFltTVec (dispFloatVector_);
@


1.69
log
@Double Precision.
@
text
@d633 1
a633 1
   writeSolnValue (doubleFromFloat (val));
@


1.68
log
@Double Precision.
@
text
@d431 12
@


1.67
log
@Double Precision.
@
text
@d621 7
@


1.66
log
@Double Precision.
@
text
@d39 1
d363 11
@


1.65
log
@Double Precision.
@
text
@a33 1
#include <RealVec.h>
a48 4
int WitProblem::nInstances_ = 0;

//------------------------------------------------------------------------------

a122 2

   nInstances_ ++;
a130 2
   nInstances_ --;

a342 1
                         WitRealVec::doubleMode          (),
@


1.64
log
@Continued double precision.
@
text
@d34 1
a34 1
#include <Session.h>
d352 1
a352 1
                         WitSession::doubleMode          (),
@


1.63
log
@Continued double precision.
@
text
@d352 1
a352 1
                         WitSession::doublePrecision     (),
@


1.62
log
@Continued double precision.
@
text
@d352 1
a352 1
      mySession_->                   doublePrecision     (),
@


1.61
log
@Began implementation of double precision.
@
text
@d50 4
d128 2
d138 2
d352 1
@


1.60
log
@Added the PIP shipment sequence to the output of displayData.
@
text
@d668 20
@


1.59
log
@Continued implementation of PIP.
@
text
@d284 2
@


1.58
log
@Continued implementation of PIP.
@
text
@d25 1
a25 1
#include <PipMgr.h>
d60 1
a60 1
      myPipMgr_           (NULL),
d99 16
a114 16
   myPreprocessor_     = new WitPreprocessor   (this);
   myPostprocessor_    = new WitPostprocessor  (this);
   myHeurImploder_     = new WitHeurImploder   (this);
   myEqAllocator_      = new WitEqAllocator    (this);
   myHeurAllMgr_       = new WitHeurAllMgr     (this);
   myOptImploder_      = new WitOptImploder    (this);
   myPipMgr_           = new WitPip::SubsysMgr (this);
   myOrigMrpExp_       = new WitOrigMrpExp     (this);
   myFSS_              = new WitFSS            (this);
   myDataReader_       = new WitDataReader     (this);
   myDataWriter_       = new WitDataWriter     (this);
   mySolnWriter_       = new WitSolnWriter     (this);

   noOpAlt_            = new WitDataAlt        (this);
   postprocAlt_        = new WitDataAlt        (this);
   preprocAlt_         = new WitDataAlt        (this);
d118 1
a118 1
   myCompMgr_          = new WitCompMgr        (this);
d140 1
a140 1
   delete myPipMgr_;
d588 1
a588 1
      myPipMgr_->printPegging ();
@


1.57
log
@Continued implementation of PIP.
@
text
@d99 12
a110 12
   myPreprocessor_     = new WitPreprocessor  (this);
   myPostprocessor_    = new WitPostprocessor (this);
   myHeurImploder_     = new WitHeurImploder  (this);
   myEqAllocator_      = new WitEqAllocator   (this);
   myHeurAllMgr_       = new WitHeurAllMgr    (this);
   myOptImploder_      = new WitOptImploder   (this);
   myPipMgr_           = new WitPip::Mgr      (this);
   myOrigMrpExp_       = new WitOrigMrpExp    (this);
   myFSS_              = new WitFSS           (this);
   myDataReader_       = new WitDataReader    (this);
   myDataWriter_       = new WitDataWriter    (this);
   mySolnWriter_       = new WitSolnWriter    (this);
d112 3
a114 3
   noOpAlt_            = new WitDataAlt       (this);
   postprocAlt_        = new WitDataAlt       (this);
   preprocAlt_         = new WitDataAlt       (this);
d118 1
a118 1
   myCompMgr_          = new WitCompMgr       (this);
@


1.56
log
@Continued implementation of PIP.
@
text
@d79 1
d97 1
d158 1
@


1.55
log
@Continued implementation of PIP.
@
text
@d585 1
a585 2
      if (myGlobalComp ()->pip ())
         myPipMgr_->printPegging ();
@


1.54
log
@Continued implementation of PIP.
@
text
@d25 1
a25 1
#include <PipInt.h>
d60 1
a60 1
      myPipInt_           (NULL),
d103 1
a103 1
   myPipInt_           = new WitPip::Int      (this);
d138 1
a138 1
   delete myPipInt_;
d586 1
a586 1
         myPipInt_->printPegging ();
@


1.53
log
@Continued implementation of PIP.
@
text
@d103 1
a103 1
   myPipInt_           = new WitPIP::WitPipInt (this);
@


1.52
log
@Continued implementation of PIP.
@
text
@d103 1
a103 1
   myPipInt_           = new WitPipInt        (this);
@


1.51
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d16 1
d18 1
@


1.50
log
@Continued implementation of post-implosion pegging.
@
text
@d583 1
a583 1
      if (myGlobalComp ()->perfPIPegging ())
@


1.49
log
@Continued implementation of post-implosion pegging.
@
text
@d582 4
@


1.48
log
@Continued implementation of post-implosion pegging.
@
text
@d23 1
a23 1
#include <PIPegInt.h>
d58 1
a58 1
      myPIPegInt_         (NULL),
d101 1
a101 1
   myPIPegInt_         = new WitPIPegInt      (this);
d136 1
a136 1
   delete myPIPegInt_;
@


1.47
log
@Continued implementation of Post-Implosion Pegging.
@
text
@a40 1
#include <FlexVecI.h>
@


1.46
log
@Added some optional warnings on Linux.
@
text
@d23 1
d59 1
d102 1
d137 1
@


1.45
log
@Continued implementation of opt with COIN.
@
text
@a123 2
   WitPeriod thePer;

@


1.44
log
@Continued implementation of proportionate routing.
@
text
@d233 1
a233 1
   WitTimingEvent theEvent ("extra");
d277 2
a511 4
   postprocess ();

   WitTimingEvent theEvent ("extra");

d517 4
d584 2
a608 2
   WitTimingEvent theEvent ("extra");

d613 2
d643 2
@


1.43
log
@Updated the code to accomodate the following two VAC compiler warning messages:
   1540-0152
   1540-0080
@
text
@d86 1
a86 2
      dispIntVector_      (),
      ptrToPer_           ()
a145 8
   if (ptrToPer_.isAllocated ())
      {
      forEachPeriod (thePer, this)
         delete ptrToPer_[thePer];

      ptrToPer_.clear ();
      }

a206 2
   WitPeriod thePer;

a208 4
   ptrToPer_       .allocate (this, NULL);

   forEachPeriod (thePer, this)
      ptrToPer_[thePer] = new WitPeriod (thePer);
a217 5
   WitPeriod thePer;

   forEachPeriod (thePer, this)
      delete ptrToPer_[thePer];

a219 1
   ptrToPer_       .clear ();
@


1.42
log
@Internal changes.
@
text
@d257 1
a257 1
      filename == NULL?
@


1.41
log
@Internal changes.
@
text
@d129 1
a129 1
   while (! allVariants_.isEmpty ())
d230 1
a230 1
   if (! dispFloatVector_.isAllocated ())
d666 1
a666 1
   if (! myFSS ()->computed ())
@


1.40
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d73 1
d91 1
d164 1
d171 1
a171 1
WitBoolean WitProblem::wit34Compatible ()
d391 28
d473 1
a473 1
WitBoolean WitProblem::preprocessed ()
d487 1
a487 1
WitBoolean WitProblem::optPreprocessed ()
d508 1
a508 1
WitBoolean WitProblem::postprocessed ()
d529 1
a529 1
void WitProblem::writeSoln (const WitString & fileName, WitBoolean fssInput)
d552 1
a552 1
      myMsgFac ().booleanText (myCompMgr ()->myGlobalComp ()->feasible ()));
d567 1
a567 1
         myMsgFac ().booleanText (
@


1.39
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d40 1
@


1.38
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d16 1
@


1.37
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d16 1
@


1.36
log
@Continued implementation of opt implosion with OSL V3.
@
text
@a637 7
void WitProblem::closeFilesAtExit ()
   {
   myOptImploder ()->closeFilesAtExit ();
   }

//------------------------------------------------------------------------------

@


1.35
log
@Continued implementation of single-source.
@
text
@d562 3
a564 2
   if (myGlobalComp ()->perfPegging ())
      myHeurAllMgr_->printPegging ();
@


1.34
log
@Continued implementation of Single-Source.
@
text
@d35 2
d315 1
a315 1
      myMsgFac ()["capacityFrag"],
d319 1
a319 1
      myMsgFac ()["materialFrag"],
d391 2
a392 1
   myMsgFac () ("boundDataDdMsg", myMsgFac ()[theFragID], dispFloatVector_);
@


1.33
log
@Continued implementation of Single-Source.
@
text
@d81 1
a81 1
      samePerAs_          ()
d140 8
d210 3
a212 3
   dispFloatVector_.allocate (this,  0.0);
   dispIntVector_  .allocate (this,  0);
   samePerAs_      .allocate (this,  -1);
d215 18
a232 1
      samePerAs_[thePer] = thePer;
@


1.32
log
@Continued implementation of Single-Source.
@
text
@a66 1
      myPerLinkMgr_       (NULL),
a83 1
   myPerLinkMgr_       = new WitPerLinkMgr               (this);
a149 1
   WitAbsLinkMgr::deleteInstance (myPerLinkMgr_);
@


1.31
log
@Continued implementation of Single-Source.
@
text
@d81 2
a82 1
      dispIntVector_      ()
d203 2
d207 4
@


1.30
log
@Continued implementation of single source.
@
text
@d67 1
d84 1
d151 1
@


1.29
log
@Preliminary work on single source.
@
text
@d67 1
a67 1
      myPerPairLinkMgr_   (NULL),
d69 1
d82 20
a101 19
   myObjLinkMgr_     = new WitObjLinkMgr              (this);
   myPerPairLinkMgr_ = new WitPairLinkMgr <WitPeriod> (this);
   myDblPairLinkMgr_ = new WitPairLinkMgr <double>    (this);

   myPreprocessor_   = new WitPreprocessor  (this);
   myPostprocessor_  = new WitPostprocessor (this);
   myHeurImploder_   = new WitHeurImploder  (this);
   myEqAllocator_    = new WitEqAllocator   (this);
   myHeurAllMgr_     = new WitHeurAllMgr    (this);
   myOptImploder_    = new WitOptImploder   (this);
   myOrigMrpExp_     = new WitOrigMrpExp    (this);
   myFSS_            = new WitFSS           (this);
   myDataReader_     = new WitDataReader    (this);
   myDataWriter_     = new WitDataWriter    (this);
   mySolnWriter_     = new WitSolnWriter    (this);

   noOpAlt_          = new WitDataAlt       (this);
   postprocAlt_      = new WitDataAlt       (this);
   preprocAlt_       = new WitDataAlt       (this);
d105 1
a105 1
   myCompMgr_        = new WitCompMgr       (this);
d107 4
a110 4
   myGlobalComp_     = new WitGlobalComp (myCompMgr ());
   myOptComp_        = new WitOptComp    (myCompMgr ());
   nPeriodsPtr_      = & myCompMgr ()->myGlobalComp ()->nPeriods ();
   lastPeriodPtr_    = & myCompMgr ()->myGlobalComp ()->lastPeriod ();
d146 1
d148 1
a148 1
   WitAbsLinkMgr::deleteInstance (myPerPairLinkMgr_);
@


1.28
log
@Continued preliminary work on single source.
@
text
@d328 1
a328 1
      const WitFlexVec (float) & theFlexVec)
d330 1
a330 1
   theFlexVec.copySelfInto (dispFloatVector_);
d339 1
a339 1
      const WitFlexVec (int) & theFlexVec)
d341 1
a341 1
   theFlexVec.copySelfInto (dispIntVector_);
d350 1
a350 1
      const WitFlexVec (float) & theFlexVec)
d352 1
a352 1
   theFlexVec.copySelfInto (dispFloatVector_);
@


1.27
log
@Continued implementation of object iteration.
@
text
@d34 1
@


1.26
log
@Began implementation of object iteration.
@
text
@d74 1
a74 1
      noopAlt_            (NULL),
d96 1
a96 1
   noopAlt_          = new WitDataAlt       (this);
d132 1
a132 1
   delete noopAlt_;
d378 1
a378 1
   if (theDataAlt == noopAlt ())
@


1.25
log
@Continued development of Selective Stock Reallocation.
@
text
@d34 1
@


1.24
log
@Moved pegging output to comprehensive implosion solution output.
Fixed bug: Pegging was being attempted during stock bounds enforcement.
@
text
@d259 1
a259 1
   WitCapacity *  theCap;
d271 3
a273 2
   forEachCapacity (theCap, this)
      ++ nCapacities;
@


1.23
log
@Added shadowPrice and compPrices attributes.
@
text
@d521 3
@


1.22
log
@Refactoring for constrained stock reallocation.
@
text
@d513 8
@


1.21
log
@Refactoring for constrained stock reallocation.
@
text
@a33 2
#include <PtrTVec.h>
#include <FixedPer.h>
d77 1
a77 2
      dispIntVector_      (),
      myFixedPer_         (* new WitPtrTVec <WitFixedPer>)
a116 4
   deleteContents (myFixedPer_);

   delete & myFixedPer_;

a190 2
   WitPeriod thePer;

a195 4
   myFixedPer_     .allocate (this);

   forEachPeriod (thePer, this)
      myFixedPer_[thePer] = new WitFixedPer (thePer);
@


1.20
log
@Initial implementation of pegging.
@
text
@d120 1
a120 3
   if (myFixedPer_.isAllocated ())
      forEachPeriod (thePer, this)
         delete myFixedPer_[thePer];
@


1.19
log
@Moved Stack template implementations to header files.
@
text
@d18 1
a18 1
#include <HeurAll.h>
d51 1
a51 1
      myHeurAllocator_    (NULL),
d82 4
d90 1
a90 1
   myHeurAllocator_  = new WitHeurAllocator (this);
a101 4
   myObjLinkMgr_     = new WitObjLinkMgr              (this);
   myPerPairLinkMgr_ = new WitPairLinkMgr <WitPeriod> (this);
   myDblPairLinkMgr_ = new WitPairLinkMgr <double>    (this);

a125 4
   WitAbsLinkMgr::deleteInstance (myDblPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myPerPairLinkMgr_);
   WitAbsLinkMgr::deleteInstance (myObjLinkMgr_);

d135 1
a135 1
   delete myHeurAllocator_;
d150 4
d398 1
a398 1
   myHeurAllocator ()->reset ();
@


1.18
log
@More templates.
@
text
@d44 1
a44 1
      mySession_           (theSession),
d46 35
a80 35
      myCompMgr_           (NULL),
      myPreprocessor_      (NULL),
      myPostprocessor_     (NULL),
      myHeurImploder_      (NULL),
      myEqAllocator_       (NULL),
      myHeurAllocator_     (NULL),
      myOptImploder_       (NULL),
      myOrigMrpExp_        (NULL),
      myFSS_               (NULL),
      myDataReader_        (NULL),
      myDataWriter_        (NULL),
      mySolnWriter_        (NULL),

      myMsgFac_            (theSession->myMsgFac ()),
      myWitRun_            (theSession->myWitRun ()),
      myApiMgr_            (theSession->myApiMgr ()),
      solnFile_            (NULL),
      nPeriodsPtr_         (NULL),
      lastPeriodPtr_       (NULL),
      copyingIntoProblem_  (NULL),
      myObjLinkMgr_        (NULL),
      myPerPairLinkMgr_    (NULL),
      myDoublePairLinkMgr_ (NULL),
      myOptVariant_        (NULL),
      myHeurVariant_       (NULL),
      myHeurOptVariant_    (NULL),
      myInputVariant_      (NULL),
      allVariants_         (),
      currentVariant_      (NULL),
      noopAlt_             (NULL),
      postprocAlt_         (NULL),
      preprocAlt_          (NULL),
      dispFloatVector_     (),
      dispIntVector_       (),
      myFixedPer_          (* new WitPtrTVec <WitFixedPer>)
d82 19
a100 19
   myPreprocessor_      = new WitPreprocessor  (this);
   myPostprocessor_     = new WitPostprocessor (this);
   myHeurImploder_      = new WitHeurImploder  (this);
   myEqAllocator_       = new WitEqAllocator   (this);
   myHeurAllocator_     = new WitHeurAllocator (this);
   myOptImploder_       = new WitOptImploder   (this);
   myOrigMrpExp_        = new WitOrigMrpExp    (this);
   myFSS_               = new WitFSS           (this);
   myDataReader_        = new WitDataReader    (this);
   myDataWriter_        = new WitDataWriter    (this);
   mySolnWriter_        = new WitSolnWriter    (this);

   noopAlt_             = new WitDataAlt       (this);
   postprocAlt_         = new WitDataAlt       (this);
   preprocAlt_          = new WitDataAlt       (this);

   myObjLinkMgr_        = new WitObjLinkMgr              (this);
   myPerPairLinkMgr_    = new WitPairLinkMgr <WitPeriod> (this);
   myDoublePairLinkMgr_ = new WitPairLinkMgr <double>    (this);
d104 1
a104 1
   myCompMgr_           = new WitCompMgr       (this);
d106 4
a109 4
   myGlobalComp_        = new WitGlobalComp (myCompMgr ());
   myOptComp_           = new WitOptComp    (myCompMgr ());
   nPeriodsPtr_         = & myCompMgr ()->myGlobalComp ()->nPeriods ();
   lastPeriodPtr_       = & myCompMgr ()->myGlobalComp ()->lastPeriod ();
d126 1
a126 1
   WitAbsLinkMgr::deleteInstance (myDoublePairLinkMgr_);
a160 14
   }

//------------------------------------------------------------------------------

void WitProblem::getMyInstance (WitPairLinkMgr <WitPeriod> * & theInstance)
   {
   theInstance = myPerPairLinkMgr_;
   }

//------------------------------------------------------------------------------

void WitProblem::getMyInstance (WitPairLinkMgr <double> * & theInstance)
   {
   theInstance = myDoublePairLinkMgr_;
@


1.17
log
@Converted several generic classes into class templates.
@
text
@d80 1
a80 1
      myFixedPer_          (* new WitPtrTVec (WitFixedPer))
@


1.16
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@d99 2
a100 2
   myPerPairLinkMgr_    = new WitPairLinkMgr (WitPeriod) (this);
   myDoublePairLinkMgr_ = new WitPairLinkMgr (double)    (this);
d165 1
a165 1
void WitProblem::getMyInstance (WitPairLinkMgr (WitPeriod) * & theInstance)
d172 1
a172 1
void WitProblem::getMyInstance (WitPairLinkMgr (double) * & theInstance)
@


1.15
log
@Further implementation of coarse selection splitting.
@
text
@d102 1
a102 1
   setupVariants ();
d186 1
a186 1
void WitProblem::setupVariants ()
@


1.14
log
@Implemented and used class SelMgr.
@
text
@d35 1
d80 1
a80 1
      samePer_             (* new WitPtrTVec (WitPeriod))
d120 1
a120 1
   if (samePer_.isAllocated ())
d122 1
a122 1
         delete samePer_[thePer];
d124 1
a124 1
   delete & samePer_;
d221 1
a221 1
   samePer_        .allocate (this);
d224 1
a224 1
      samePer_[thePer] = new WitPeriod (thePer);
a616 7
   }

//------------------------------------------------------------------------------

const WitPeriod * WitProblem::samePerPtr (WitPeriod thePer)
   {
   return samePer_[thePer];
@


1.13
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d129 2
a130 1
   allVariants_.clearContents ();
@


1.12
log
@Further development of coarse selection splitting.
@
text
@d34 1
d78 2
a79 1
      dispIntVector_       ()
d119 6
d212 2
d219 4
d615 7
@


1.11
log
@Minor correction.
@
text
@d117 3
a119 3
   WitLinkMgr::deleteInstance (myDoublePairLinkMgr_);
   WitLinkMgr::deleteInstance (myPerPairLinkMgr_);
   WitLinkMgr::deleteInstance (myObjLinkMgr_);
@


1.10
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@a66 1
      myObjPerDblLinkMgr_  (NULL),
a97 1
   myObjPerDblLinkMgr_  = new WitObjPerDblLinkMgr        (this);
a116 1
   WitLinkMgr::deleteInstance (myObjPerDblLinkMgr_);
@


1.9
log
@Some minor modifications.
@
text
@d42 1
a42 1
      mySession_                (theSession),
d44 35
a78 34
      myCompMgr_                (NULL),
      myPreprocessor_           (NULL),
      myPostprocessor_          (NULL),
      myHeurImploder_           (NULL),
      myEqAllocator_            (NULL),
      myHeurAllocator_          (NULL),
      myOptImploder_            (NULL),
      myOrigMrpExp_             (NULL),
      myFSS_                    (NULL),
      myDataReader_             (NULL),
      myDataWriter_             (NULL),
      mySolnWriter_             (NULL),

      myMsgFac_                 (theSession->myMsgFac ()),
      myWitRun_                 (theSession->myWitRun ()),
      myApiMgr_                 (theSession->myApiMgr ()),
      solnFile_                 (NULL),
      nPeriodsPtr_              (NULL),
      lastPeriodPtr_            (NULL),
      copyingIntoProblem_       (NULL),
      myObjStackLinkMgr_        (NULL),
      myPerPairStackLinkMgr_    (NULL),
      myDoublePairStackLinkMgr_ (NULL),
      myOptVariant_             (NULL),
      myHeurVariant_            (NULL),
      myHeurOptVariant_         (NULL),
      myInputVariant_           (NULL),
      allVariants_              (),
      currentVariant_           (NULL),
      noopAlt_                  (NULL),
      postprocAlt_              (NULL),
      preprocAlt_               (NULL),
      dispFloatVector_          (),
      dispIntVector_            ()
d80 20
a99 19
   myPreprocessor_           = new WitPreprocessor  (this);
   myPostprocessor_          = new WitPostprocessor (this);
   myHeurImploder_           = new WitHeurImploder  (this);
   myEqAllocator_            = new WitEqAllocator   (this);
   myHeurAllocator_          = new WitHeurAllocator (this);
   myOptImploder_            = new WitOptImploder   (this);
   myOrigMrpExp_             = new WitOrigMrpExp    (this);
   myFSS_                    = new WitFSS           (this);
   myDataReader_             = new WitDataReader    (this);
   myDataWriter_             = new WitDataWriter    (this);
   mySolnWriter_             = new WitSolnWriter    (this);

   noopAlt_                  = new WitDataAlt       (this);
   postprocAlt_              = new WitDataAlt       (this);
   preprocAlt_               = new WitDataAlt       (this);

   myObjStackLinkMgr_        = new WitObjStackLinkMgr              (this);
   myPerPairStackLinkMgr_    = new WitPairStackLinkMgr (WitPeriod) (this);
   myDoublePairStackLinkMgr_ = new WitPairStackLinkMgr (double)    (this);
d103 1
a103 1
   myCompMgr_                = new WitCompMgr       (this);
d105 4
a108 4
   myGlobalComp_             = new WitGlobalComp (myCompMgr ());
   myOptComp_                = new WitOptComp    (myCompMgr ());
   nPeriodsPtr_              = & myCompMgr ()->myGlobalComp ()->nPeriods ();
   lastPeriodPtr_            = & myCompMgr ()->myGlobalComp ()->lastPeriod ();
d119 4
a122 3
   WitStackLinkMgr::deleteInstance (myDoublePairStackLinkMgr_);
   WitStackLinkMgr::deleteInstance (myPerPairStackLinkMgr_);
   WitStackLinkMgr::deleteInstance (myObjStackLinkMgr_);
d158 1
a158 1
void WitProblem::getMyInstance (WitPairStackLinkMgr (WitPeriod) * & theInstance)
d160 1
a160 1
   theInstance = myPerPairStackLinkMgr_;
d165 1
a165 1
void WitProblem::getMyInstance (WitPairStackLinkMgr (double) * & theInstance)
d167 1
a167 1
   theInstance = myDoublePairStackLinkMgr_;
@


1.8
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d28 1
a28 1
#include <DynMgr.h>
d42 1
a42 1
      mySession_              (theSession),
d44 34
a77 34
      myCompMgr_              (NULL),
      myPreprocessor_         (NULL),
      myPostprocessor_        (NULL),
      myHeurImploder_         (NULL),
      myEqAllocator_          (NULL),
      myHeurAllocator_        (NULL),
      myOptImploder_          (NULL),
      myOrigMrpExp_           (NULL),
      myFSS_                  (NULL),
      myDataReader_           (NULL),
      myDataWriter_           (NULL),
      mySolnWriter_           (NULL),

      myMsgFac_               (theSession->myMsgFac ()),
      myWitRun_               (theSession->myWitRun ()),
      myApiMgr_               (theSession->myApiMgr ()),
      solnFile_               (NULL),
      nPeriodsPtr_            (NULL),
      lastPeriodPtr_          (NULL),
      copyingIntoProblem_     (NULL),
      myObjDynLinkMgr_        (NULL),
      myPerPairDynLinkMgr_    (NULL),
      myDoublePairDynLinkMgr_ (NULL),
      myOptVariant_           (NULL),
      myHeurVariant_          (NULL),
      myHeurOptVariant_       (NULL),
      myInputVariant_         (NULL),
      allVariants_            (),
      currentVariant_         (NULL),
      noopAlt_                (NULL),
      postprocAlt_            (NULL),
      preprocAlt_             (NULL),
      dispFloatVector_        (),
      dispIntVector_          ()
d79 19
a97 19
   myPreprocessor_         = new WitPreprocessor  (this);
   myPostprocessor_        = new WitPostprocessor (this);
   myHeurImploder_         = new WitHeurImploder  (this);
   myEqAllocator_          = new WitEqAllocator   (this);
   myHeurAllocator_        = new WitHeurAllocator (this);
   myOptImploder_          = new WitOptImploder   (this);
   myOrigMrpExp_           = new WitOrigMrpExp    (this);
   myFSS_                  = new WitFSS           (this);
   myDataReader_           = new WitDataReader    (this);
   myDataWriter_           = new WitDataWriter    (this);
   mySolnWriter_           = new WitSolnWriter    (this);

   noopAlt_                = new WitDataAlt       (this);
   postprocAlt_            = new WitDataAlt       (this);
   preprocAlt_             = new WitDataAlt       (this);

   myObjDynLinkMgr_        = new WitObjDynLinkMgr              (this);
   myPerPairDynLinkMgr_    = new WitPairDynLinkMgr (WitPeriod) (this);
   myDoublePairDynLinkMgr_ = new WitPairDynLinkMgr (double)    (this);
d101 1
a101 1
   myCompMgr_              = new WitCompMgr       (this);
d103 4
a106 4
   myGlobalComp_           = new WitGlobalComp (myCompMgr ());
   myOptComp_              = new WitOptComp    (myCompMgr ());
   nPeriodsPtr_            = & myCompMgr ()->myGlobalComp ()->nPeriods ();
   lastPeriodPtr_          = & myCompMgr ()->myGlobalComp ()->lastPeriod ();
d117 3
a119 3
   WitDynLinkMgr::deleteInstance (myDoublePairDynLinkMgr_);
   WitDynLinkMgr::deleteInstance (myPerPairDynLinkMgr_);
   WitDynLinkMgr::deleteInstance (myObjDynLinkMgr_);
d155 1
a155 1
void WitProblem::getMyInstance (WitPairDynLinkMgr (WitPeriod) * & theInstance)
d157 1
a157 1
   theInstance = myPerPairDynLinkMgr_;
d162 1
a162 1
void WitProblem::getMyInstance (WitPairDynLinkMgr (double) * & theInstance)
d164 1
a164 1
   theInstance = myDoublePairDynLinkMgr_;
@


1.7
log
@Refactoring for selection splitting.
@
text
@d95 3
a97 4
   myObjDynLinkMgr_        = new WitObjDynLinkMgr;

   myPerPairDynLinkMgr_    = new WitPairDynLinkMgr (WitPeriod);
   myDoublePairDynLinkMgr_ = new WitPairDynLinkMgr (double);
d235 1
a235 4
   displayGlobal ();

   myCompMgr ()->myGlobalComp ()->display ();
   myCompMgr ()->myOptComp    ()->display ();
d270 66
a600 63
   }

//------------------------------------------------------------------------------

void WitProblem::displayGlobal ()
   {
   WitCapacity *  theCap;
   int            nCapacities;
   WitOperation * theOpn;
   int            nPosPens;

   myMsgFac () ("globalHeadingDdMsg");

   myMsgFac () ("titleMsg", myCompMgr ()->myGlobalComp ()->title ());
   myMsgFac () ("dimenHeadingDdMsg");

   nCapacities = 0;

   forEachCapacity (theCap, this)
      ++ nCapacities;

   myMsgFac () ("categorySizeDdMsg",
      myMsgFac ()["capacityFrag"],
      nCapacities);

   myMsgFac () ("categorySizeDdMsg",
      myMsgFac ()["materialFrag"],
      myCompMgr ()->nMaterials ());

   myMsgFac () ("dimenDataDdMsg",
      myCompMgr ()->nParts (),
      myCompMgr ()->nOperations (),
      myCompMgr ()->nDemands (),
                    nPeriods (),
      myCompMgr ()->nBoundSetsSpecified (),
      myCompMgr ()->nBoundSets (),
      myCompMgr ()->nBomEntries (),
      myCompMgr ()->nSubEntries (),
      myCompMgr ()->nBopEntries (),
      myCompMgr ()->nDelComps ());

   nPosPens = 0;

   forEachOperation (theOpn, this)
      if (theOpn->execPenalty () > 0.0)
         nPosPens ++;

   myMsgFac () ("globalDataDdMsg",
                                     wit34Compatible     (),
      myCompMgr ()->myGlobalComp ()->independentOffsets  (),
      myCompMgr ()->myGlobalComp ()->execEmptyBom        (),
      myCompMgr ()->myGlobalComp ()->computeCriticalList (),
      myCompMgr ()->myGlobalComp ()->hashTableSize       (),
      myCompMgr ()->myGlobalComp ()->roundReqVols        (),
      myCompMgr ()->myGlobalComp ()->outputPrecision     (),
      myCompMgr ()->myGlobalComp ()->useFocusHorizons    (),
                                     nPosPens,
                                     preprocessed        ());

   if (preprocessed ())
      myMsgFac () ("preprocDataDdMsg",
         optPreprocessed (),
         myCompMgr ()->myGlobalComp ()->lotSizesExist ());
@


1.6
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d42 1
a42 1
      mySession_           (theSession),
d44 34
a77 33
      myCompMgr_           (NULL),
      myPreprocessor_      (NULL),
      myPostprocessor_     (NULL),
      myHeurImploder_      (NULL),
      myEqAllocator_       (NULL),
      myHeurAllocator_     (NULL),
      myOptImploder_       (NULL),
      myOrigMrpExp_        (NULL),
      myFSS_               (NULL),
      myDataReader_        (NULL),
      myDataWriter_        (NULL),
      mySolnWriter_        (NULL),

      myMsgFac_            (theSession->myMsgFac ()),
      myWitRun_            (theSession->myWitRun ()),
      myApiMgr_            (theSession->myApiMgr ()),
      solnFile_            (NULL),
      nPeriodsPtr_         (NULL),
      lastPeriodPtr_       (NULL),
      copyingIntoProblem_  (NULL),
      myObjDynLinkMgr_     (NULL),
      myPerPairDynLinkMgr_ (NULL),
      myOptVariant_        (NULL),
      myHeurVariant_       (NULL),
      myHeurOptVariant_    (NULL),
      myInputVariant_      (NULL),
      allVariants_         (),
      currentVariant_      (NULL),
      noopAlt_             (NULL),
      postprocAlt_         (NULL),
      preprocAlt_          (NULL),
      dispFloatVector_     (),
      dispIntVector_       ()
d79 15
a93 15
   myPreprocessor_      = new WitPreprocessor  (this);
   myPostprocessor_     = new WitPostprocessor (this);
   myHeurImploder_      = new WitHeurImploder  (this);
   myEqAllocator_       = new WitEqAllocator   (this);
   myHeurAllocator_     = new WitHeurAllocator (this);
   myOptImploder_       = new WitOptImploder   (this);
   myOrigMrpExp_        = new WitOrigMrpExp    (this);
   myFSS_               = new WitFSS           (this);
   myDataReader_        = new WitDataReader    (this);
   myDataWriter_        = new WitDataWriter    (this);
   mySolnWriter_        = new WitSolnWriter    (this);

   noopAlt_             = new WitDataAlt       (this);
   postprocAlt_         = new WitDataAlt       (this);
   preprocAlt_          = new WitDataAlt       (this);
d95 1
a95 1
   myObjDynLinkMgr_     = new WitObjDynLinkMgr;
d97 2
a98 1
   myPerPairDynLinkMgr_ = new WitPairDynLinkMgr (WitPeriod);
d102 1
a102 1
   myCompMgr_           = new WitCompMgr       (this);
d104 4
a107 4
   myGlobalComp_        = new WitGlobalComp (myCompMgr ());
   myOptComp_           = new WitOptComp    (myCompMgr ());
   nPeriodsPtr_         = & myCompMgr ()->myGlobalComp ()->nPeriods ();
   lastPeriodPtr_       = & myCompMgr ()->myGlobalComp ()->lastPeriod ();
d118 1
d159 7
@


1.5
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d28 1
a28 1
#include <DynLink.h>
d42 1
a42 1
      mySession_          (theSession),
d44 53
a96 51
      myCompMgr_          (NULL),
      myPreprocessor_     (NULL),
      myPostprocessor_    (NULL),
      myHeurImploder_     (NULL),
      myEqAllocator_      (NULL),
      myHeurAllocator_    (NULL),
      myOptImploder_      (NULL),
      myOrigMrpExp_       (NULL),
      myFSS_              (NULL),
      myDataReader_       (NULL),
      myDataWriter_       (NULL),
      mySolnWriter_       (NULL),

      myMsgFac_           (theSession->myMsgFac ()),
      myWitRun_           (theSession->myWitRun ()),
      myApiMgr_           (theSession->myApiMgr ()),
      myDynLinkMgr_       (NULL),
      myDynPerLinkMgr_    (NULL),
      solnFile_           (NULL),
      nPeriodsPtr_        (NULL),
      lastPeriodPtr_      (NULL),
      copyingIntoProblem_ (NULL),
      myOptVariant_       (NULL),
      myHeurVariant_      (NULL),
      myHeurOptVariant_   (NULL),
      myInputVariant_     (NULL),
      allVariants_        (),
      currentVariant_     (NULL),
      noopAlt_            (NULL),
      postprocAlt_        (NULL),
      preprocAlt_         (NULL),
      dispFloatVector_    (),
      dispIntVector_      ()
   {
   myPreprocessor_  = new WitPreprocessor  (this);
   myPostprocessor_ = new WitPostprocessor (this);
   myHeurImploder_  = new WitHeurImploder  (this);
   myEqAllocator_   = new WitEqAllocator   (this);
   myHeurAllocator_ = new WitHeurAllocator (this);
   myOptImploder_   = new WitOptImploder   (this);
   myOrigMrpExp_    = new WitOrigMrpExp    (this);
   myFSS_           = new WitFSS           (this);
   myDataReader_    = new WitDataReader    (this);
   myDataWriter_    = new WitDataWriter    (this);
   mySolnWriter_    = new WitSolnWriter    (this);
   myDynLinkMgr_    = new WitDynLinkMgr;
   myDynPerLinkMgr_ = new WitDynPerLinkMgr;

   noopAlt_         = new WitDataAlt       (this);
   postprocAlt_     = new WitDataAlt       (this);
   preprocAlt_      = new WitDataAlt       (this);
d100 1
a100 1
   myCompMgr_       = new WitCompMgr       (this);
d102 4
a105 4
   myGlobalComp_    = new WitGlobalComp (myCompMgr ());
   myOptComp_       = new WitOptComp    (myCompMgr ());
   nPeriodsPtr_     = & myCompMgr ()->myGlobalComp ()->nPeriods ();
   lastPeriodPtr_   = & myCompMgr ()->myGlobalComp ()->lastPeriod ();
d116 3
a141 3

   delete myDynPerLinkMgr_;
   delete myDynLinkMgr_;
d153 7
d268 1
a268 1
   theFlexVec.copyInto (dispFloatVector_);
d279 1
a279 1
   theFlexVec.copyInto (dispIntVector_);
d290 1
a290 1
   theFlexVec.copyInto (dispFloatVector_);
d306 1
a306 1
      theComp->copyInto (theProblem->myCompMgr ());
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d227 5
a250 5

   myMsgFac () ("demandHeadingDdMsg");

   forEachDemand (theDemand, this)
      theDemand->display ();
d420 10
a442 10
   fprintf (solnFile (), "\n\nComprehensive Solution for Demands:\n");

   if (fssInput)
      fprintf (solnFile (), "\nUse Focus Horizons?   %s\n",
         myMsgFac ().booleanText (
            myCompMgr ()->myGlobalComp ()->useFocusHorizons ()));

   forEachDemand (theDemand, this)
      theDemand->writeSoln (fssInput);

d613 3
a617 3

   forEachDemand (theDemand, this)
      theDemand->cumShipBounds ()->writeSoln ();
@


1.3
log
@Initial implementation of stock re-allocation.
@
text
@d64 1
d103 1
d131 4
a134 3
   nPeriodsPtr_  = NULL;
   myOptComp_    = NULL;
   myGlobalComp_ = NULL;
d397 1
a397 1
   solnFile_ = WitUtil::openFile (fileName, "w");
d477 1
a477 1
   solnFile_ = WitUtil::openFile (fileName, "w");
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@a101 1

@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.42;
access;
symbols
	sce_5_01_20080919:1.37;
locks; strict;
comment	@ * @;


1.42
date	2011.09.28.23.50.28;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.24.00.28.43;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.08.30.20.18.14;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.10.22.10.42;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.19.18.00.14;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.28.00.00.43;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.02.13.23.22.24;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2008.02.13.20.22.55;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.13.16.50.44;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2008.02.12.22.04.04;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.07.18.41.40;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.01.21.33.06;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.18.22.40.59;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.09.19.35.48;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.28.23.45.47;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.12.28.18.29.18;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.22.19.58.53;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.08.18.56.36;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.01.22.20.08;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.26.14.36.17;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.25.21.03.05;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.20.22.17.57;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.14.15.44.41;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.06.18.59.13;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.04.22.20.12;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.30.19.39.01;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.30.17.34.35;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.24.22.14.01;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.24.20.17.24;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.24.15.48.07;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.22.22.45.30;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.22.22.16.16;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.16.21.27.41;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.15.22.02.08;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.15.21.36.42;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.15.19.15.33;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.14.15.03.01;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.10.20.42.57;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.09.20.17.42;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.09.19.30.36;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.07.17.47.14;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.07.17.35.36;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "StCons.C"
//
// Implementation the following classes:
//
//    StResCon
//    StSubCon
//    StShipCon
//    StSlbCon
//------------------------------------------------------------------------------

#include <StCons.h>
#include <Stage.h>
#include <StageMgr.h>
#include <Scenario.h>
#include <ScenAttMgr.h>
#include <ScenInputAtt.h>
#include <StochImpOP.h>
#include <StochLoc.h>
#include <StVars.h>
#include <StochImpMgr.h>
#include <StochModeMgr.h>
#include <Material.h>
#include <Demand.h>
#include <SubEntry.h>
#include <Operation.h>
#include <BopEntry.h>
#include <ExecPerSch.h>
#include <MsgFac.h>

#include <float.h>

//------------------------------------------------------------------------------
// Implementation of class StResCon.
//------------------------------------------------------------------------------

WitStResCon::WitStResCon (WitPart * thePart, WitStochLoc * theStochLoc):

      WitStochCon (theStochLoc),
      myPart_     (thePart)
   {
   }

//------------------------------------------------------------------------------

WitStResCon::~WitStResCon ()
   {
   }

//------------------------------------------------------------------------------

void WitStResCon::generateCoeffs ()
   {
   genPartCoeffs   ();
   genMatCoeffs    ();
   genDemandCoeffs ();
   genBomEntCoeffs ();
   genSubCoeffs    ();
   genBopEntCoeffs ();
   }

//------------------------------------------------------------------------------

double WitStResCon::upperBoundVal ()
   {
   return lowerBoundVal ();
   }

//------------------------------------------------------------------------------

double WitStResCon::lowerBoundVal ()
   {
   return
      myScenAttMgr ()->
         supplyVol ()->
            myValueFor (myPart_, firstScenario ())[myPer ()];
   }

//------------------------------------------------------------------------------

const char * WitStResCon::classText ()
   {
   return "Resource";
   }

//------------------------------------------------------------------------------

void WitStResCon::printItem ()
   {
   myStochImpOP ()->printItem (myPart_);
   }

//------------------------------------------------------------------------------

void WitStResCon::genPartCoeffs ()
   {
   WitStScrapVar * theScrapVar;

   theScrapVar = myStochLoc ()->myScrapVarFor (myPart_);

   if (theScrapVar != NULL)
      theScrapVar->incCoeff (1.0);
   }

//------------------------------------------------------------------------------

void WitStResCon::genMatCoeffs ()
   {
   WitMaterial *   theMat;
   WitStStockVar * theStockVar;
   WitStStockVar * prevPerStockVar;

   theMat = myPart_->thisMat ();

   if (theMat == NULL)
      return;

   theStockVar = myStochLoc ()->myStockVarFor (theMat);

   if (theStockVar != NULL)
       theStockVar->incCoeff (1.0);

   if (myPer () == 0)
      return;

   prevPerStockVar =
      findVarStochLocFor (theMat, myPer () - 1)->
         myStockVarFor   (theMat);

   if (prevPerStockVar != NULL)
       prevPerStockVar->incCoeff (-1.0);
   }

//------------------------------------------------------------------------------

void WitStResCon::genDemandCoeffs ()
   {
   WitDemand * theDemand;

   forEachEl (theDemand, myPart_->myDemands ())
      myStochLoc ()->myShipVarFor (theDemand)->incCoeff (1.0);
   }

//------------------------------------------------------------------------------

void WitStResCon::genBomEntCoeffs ()
   {
   WitBomEntry *  theBomEnt;
   WitOperation * theOpn;
   WitPeriod      execPerF;
   WitPeriod      execPerL;
   WitPeriod      execPer;
   WitStochLoc *  theStochLoc;
   WitOptVar *    theOptVar;
   double         theRate;

   forEachEl (theBomEnt, myPart_->consumingBomEntries ())
      {
      theOpn       = theBomEnt->myOperation ();

      getExecPerRange (theBomEnt, execPerF, execPerL);

      for (execPer = execPerL; execPer >= execPerF; execPer --)
         if (theBomEnt->impactPeriod ()[execPer] == myPer ())
            {
            theStochLoc = findVarStochLocFor (theOpn, execPer);

            if (theBomEnt->hasSubsInEffect ()[execPer])
               theOptVar = theStochLoc->myNonSubVarFor (theBomEnt);
            else
               theOptVar = theStochLoc->myExecVarFor   (theOpn);

            theRate = theBomEnt->effConsRate ()[execPer];

            theOptVar->incCoeff (theRate);
            }
      }
   }

//------------------------------------------------------------------------------

void WitStResCon::genSubCoeffs ()
   {
   WitSubEntry *  theSub;
   WitOperation * theOpn;
   WitPeriod      execPerF;
   WitPeriod      execPerL;
   WitPeriod      execPer;
   WitStSubVar *  theSubVar;
   double         theRate;

   forEachEl (theSub, myPart_->consumingSubEntries ())
      {
      theOpn = theSub->myOperation ();

      getExecPerRange (theSub, execPerF, execPerL);

      for (execPer = execPerL; execPer >= execPerF; execPer --)
         if (theSub->impactPeriod ()[execPer] == myPer ())
            {
            theSubVar =
               findVarStochLocFor (theOpn, execPer)->mySubVarFor (theSub);

            theRate   = theSub->effConsRate ()[execPer];

            theSubVar->incCoeff (theRate);
            }
      }
   }

//------------------------------------------------------------------------------

void WitStResCon::genBopEntCoeffs ()
   {
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitPeriod      execPerF;
   WitPeriod      execPerL;
   WitPeriod      execPer;
   WitStExecVar * theExecVar;
   double         theRate;

   forEachEl (theBopEnt, myPart_->producingBopEntries ())
      {
      theOpn = theBopEnt->myOperation ();

      getExecPerRange (theBopEnt, execPerF, execPerL);

      for (execPer = execPerL; execPer >= execPerF; execPer --)
         if (theBopEnt->impactPeriod ()[execPer] == myPer ())
            {
            theExecVar =
               findVarStochLocFor (theOpn, execPer)->myExecVarFor (theOpn);

            theRate      = theBopEnt->effProdRate ()[execPer];

            theExecVar->incCoeff (- theRate);
            }
      }
   }

//------------------------------------------------------------------------------

void WitStResCon::getExecPerRange (
      WitBillEntry * theBillEnt,
      WitPeriod &    execPerF,
      WitPeriod &    execPerL)
   {
   myStochImpOP ()->
      myExecPerSched ()->
         getExecPerRange (theBillEnt, myPer (), execPerF, execPerL);
   }

//------------------------------------------------------------------------------
// Implementation of class StSubCon.
//------------------------------------------------------------------------------

WitStSubCon::WitStSubCon (WitBomEntry * theBomEnt, WitStochLoc * theStochLoc):

      WitStochCon (theStochLoc),
      myBomEnt_   (theBomEnt)
   {
   }

//------------------------------------------------------------------------------

WitStSubCon::~WitStSubCon ()
   {
   }

//------------------------------------------------------------------------------

void WitStSubCon::generateCoeffs ()
   {
   WitSubEntry *  theSub;
   WitOperation * theOpn;

   theOpn = myBomEnt_->myOperation ();

   myStochLoc ()->      myNonSubVarFor (myBomEnt_)->incCoeff  (1.0);

   forEachEl (theSub, myBomEnt_->mySubEntries ())
      if (theSub->inEffect (myPer ()))
         myStochLoc ()->mySubVarFor    (theSub)   ->incCoeff  (1.0);

   myStochLoc ()->      myExecVarFor   (theOpn)   ->incCoeff (-1.0);
   }

//------------------------------------------------------------------------------

double WitStSubCon::upperBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

double WitStSubCon::lowerBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

const char * WitStSubCon::classText ()
   {
   return "Substitution";
   }

//------------------------------------------------------------------------------

void WitStSubCon::printItem ()
   {
   myStochImpOP ()->printItem (myBomEnt_);
   }

//------------------------------------------------------------------------------
// Implementation of class StShipCon.
//------------------------------------------------------------------------------

WitStShipCon::WitStShipCon (WitDemand * theDemand, WitStochLoc * theStochLoc):

      WitStochCon (theStochLoc),
      myDemand_   (theDemand)
   {
   }

//------------------------------------------------------------------------------

WitStShipCon::~WitStShipCon ()
   {
   }

//------------------------------------------------------------------------------

void WitStShipCon::generateCoeffs ()
   {
   WitStochLoc * theStochLoc;

   if (myPer () > 0)
      {
      theStochLoc =
         findVarStochLocFor (myDemand_->demandedPart (), myPer () - 1);

      theStochLoc->myCumShipVarFor (myDemand_)->incCoeff  (1.0);
      }

   myStochLoc () ->myShipVarFor    (myDemand_)->incCoeff  (1.0);
   myStochLoc () ->myCumShipVarFor (myDemand_)->incCoeff (-1.0);
   }

//------------------------------------------------------------------------------

double WitStShipCon::upperBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

double WitStShipCon::lowerBoundVal ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

const char * WitStShipCon::classText ()
   {
   return "Shipment";
   }

//------------------------------------------------------------------------------

void WitStShipCon::printItem ()
   {
   myStochImpOP ()->printItem (myDemand_);
   }

//------------------------------------------------------------------------------
// Implementation of class StSlbCon.
//------------------------------------------------------------------------------

WitStSlbCon::WitStSlbCon (WitStSlbvVar * theSlbvVar):

      WitStochCon (theSlbvVar->myStochLoc ()),
      mySlbvVar_  (theSlbvVar)
   {
   }

//------------------------------------------------------------------------------

WitStSlbCon::~WitStSlbCon ()
   {
   }

//------------------------------------------------------------------------------

void WitStSlbCon::generateCoeffs ()
   {
   myBddVar ()->incCoeff (1.0);
   mySlbvVar_ ->incCoeff (1.0);
   }

//------------------------------------------------------------------------------

double WitStSlbCon::upperBoundVal ()
   {
   return DBL_MAX;
   }

//------------------------------------------------------------------------------

double WitStSlbCon::lowerBoundVal ()
   {
   WitBoundSet * theBoundSet;

   theBoundSet = myBddVar ()->myBoundSet ();

   return
      myScenAttMgr ()->
         softLB ()->
            myValueFor (theBoundSet, firstScenario ())[myPer ()];
   }

//------------------------------------------------------------------------------

const char * WitStSlbCon::classText ()
   {
   return "S. L. B.";
   }

//------------------------------------------------------------------------------

void WitStSlbCon::printItem ()
   {
   myStochImpOP ()->printItem (myBddVar ());
   }

//------------------------------------------------------------------------------

WitStBddVar * WitStSlbCon::myBddVar ()
   {
   return mySlbvVar_->myBddVar ();
   }
@


1.41
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.40
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d48 4
a51 4
WitStochCon (theStochLoc),
myPart_     (thePart)
{
}
d56 2
a57 2
{
}
d62 8
a69 8
{
genPartCoeffs   ();
genMatCoeffs    ();
genDemandCoeffs ();
genBomEntCoeffs ();
genSubCoeffs    ();
genBopEntCoeffs ();
}
d74 3
a76 3
{
return lowerBoundVal ();
}
d81 6
a86 6
{
return
myScenAttMgr ()->
supplyVol ()->
myValueFor (myPart_, firstScenario ())[myPer ()];
}
d91 3
a93 3
{
return "Resource";
}
d98 3
a100 3
{
myStochImpOP ()->printItem (myPart_);
}
d105 2
a106 2
{
WitStScrapVar * theScrapVar;
d108 1
a108 1
theScrapVar = myStochLoc ()->myScrapVarFor (myPart_);
d110 3
a112 3
if (theScrapVar != NULL)
theScrapVar->incCoeff (1.0);
}
d117 4
a120 4
{
WitMaterial *   theMat;
WitStStockVar * theStockVar;
WitStStockVar * prevPerStockVar;
d122 1
a122 1
theMat = myPart_->thisMat ();
d124 2
a125 2
if (theMat == NULL)
return;
d127 1
a127 1
theStockVar = myStochLoc ()->myStockVarFor (theMat);
d129 2
a130 2
if (theStockVar != NULL)
theStockVar->incCoeff (1.0);
d132 2
a133 2
if (myPer () == 0)
return;
d135 3
a137 3
prevPerStockVar =
findVarStochLocFor (theMat, myPer () - 1)->
myStockVarFor   (theMat);
d139 3
a141 3
if (prevPerStockVar != NULL)
prevPerStockVar->incCoeff (-1.0);
}
d146 2
a147 2
{
WitDemand * theDemand;
d149 3
a151 3
forEachEl (theDemand, myPart_->myDemands ())
myStochLoc ()->myShipVarFor (theDemand)->incCoeff (1.0);
}
d156 32
a187 32
{
WitBomEntry *  theBomEnt;
WitOperation * theOpn;
WitPeriod      execPerF;
WitPeriod      execPerL;
WitPeriod      execPer;
WitStochLoc *  theStochLoc;
WitOptVar *    theOptVar;
double         theRate;

forEachEl (theBomEnt, myPart_->consumingBomEntries ())
{
theOpn       = theBomEnt->myOperation ();

getExecPerRange (theBomEnt, execPerF, execPerL);

for (execPer = execPerL; execPer >= execPerF; execPer --)
if (theBomEnt->impactPeriod ()[execPer] == myPer ())
{
theStochLoc = findVarStochLocFor (theOpn, execPer);

if (theBomEnt->hasSubsInEffect ()[execPer])
theOptVar = theStochLoc->myNonSubVarFor (theBomEnt);
else
theOptVar = theStochLoc->myExecVarFor   (theOpn);

theRate = theBomEnt->effConsRate ()[execPer];

theOptVar->incCoeff (theRate);
}
}
}
d192 27
a218 27
{
WitSubEntry *  theSub;
WitOperation * theOpn;
WitPeriod      execPerF;
WitPeriod      execPerL;
WitPeriod      execPer;
WitStSubVar *  theSubVar;
double         theRate;

forEachEl (theSub, myPart_->consumingSubEntries ())
{
theOpn = theSub->myOperation ();

getExecPerRange (theSub, execPerF, execPerL);

for (execPer = execPerL; execPer >= execPerF; execPer --)
if (theSub->impactPeriod ()[execPer] == myPer ())
{
theSubVar =
findVarStochLocFor (theOpn, execPer)->mySubVarFor (theSub);

theRate   = theSub->effConsRate ()[execPer];

theSubVar->incCoeff (theRate);
}
}
}
d223 27
a249 27
{
WitBopEntry *  theBopEnt;
WitOperation * theOpn;
WitPeriod      execPerF;
WitPeriod      execPerL;
WitPeriod      execPer;
WitStExecVar * theExecVar;
double         theRate;

forEachEl (theBopEnt, myPart_->producingBopEntries ())
{
theOpn = theBopEnt->myOperation ();

getExecPerRange (theBopEnt, execPerF, execPerL);

for (execPer = execPerL; execPer >= execPerF; execPer --)
if (theBopEnt->impactPeriod ()[execPer] == myPer ())
{
theExecVar =
findVarStochLocFor (theOpn, execPer)->myExecVarFor (theOpn);

theRate      = theBopEnt->effProdRate ()[execPer];

theExecVar->incCoeff (- theRate);
}
}
}
d254 8
a261 8
WitBillEntry * theBillEnt,
WitPeriod &    execPerF,
WitPeriod &    execPerL)
{
myStochImpOP ()->
myExecPerSched ()->
getExecPerRange (theBillEnt, myPer (), execPerF, execPerL);
}
d269 4
a272 4
WitStochCon (theStochLoc),
myBomEnt_   (theBomEnt)
{
}
d277 2
a278 2
{
}
d283 3
a285 3
{
WitSubEntry *  theSub;
WitOperation * theOpn;
d287 1
a287 1
theOpn = myBomEnt_->myOperation ();
d289 1
a289 1
myStochLoc ()->      myNonSubVarFor (myBomEnt_)->incCoeff  (1.0);
d291 3
a293 3
forEachEl (theSub, myBomEnt_->mySubEntries ())
if (theSub->inEffect (myPer ()))
myStochLoc ()->mySubVarFor    (theSub)   ->incCoeff  (1.0);
d295 2
a296 2
myStochLoc ()->      myExecVarFor   (theOpn)   ->incCoeff (-1.0);
}
d301 3
a303 3
{
return 0.0;
}
d308 3
a310 3
{
return 0.0;
}
d315 3
a317 3
{
return "Substitution";
}
d322 3
a324 3
{
myStochImpOP ()->printItem (myBomEnt_);
}
d332 4
a335 4
WitStochCon (theStochLoc),
myDemand_   (theDemand)
{
}
d340 2
a341 2
{
}
d346 2
a347 2
{
WitStochLoc * theStochLoc;
d349 11
a359 11
if (myPer () > 0)
{
theStochLoc =
findVarStochLocFor (myDemand_->demandedPart (), myPer () - 1);

theStochLoc->myCumShipVarFor (myDemand_)->incCoeff  (1.0);
}

myStochLoc () ->myShipVarFor    (myDemand_)->incCoeff  (1.0);
myStochLoc () ->myCumShipVarFor (myDemand_)->incCoeff (-1.0);
}
d364 3
a366 3
{
return 0.0;
}
d371 3
a373 3
{
return 0.0;
}
d378 3
a380 3
{
return "Shipment";
}
d385 3
a387 3
{
myStochImpOP ()->printItem (myDemand_);
}
d395 4
a398 4
WitStochCon (theSlbvVar->myStochLoc ()),
mySlbvVar_  (theSlbvVar)
{
}
d403 2
a404 2
{
}
d409 4
a412 4
{
myBddVar ()->incCoeff (1.0);
mySlbvVar_ ->incCoeff (1.0);
}
d417 3
a419 3
{
return DBL_MAX;
}
d424 2
a425 2
{
WitBoundSet * theBoundSet;
d427 1
a427 1
theBoundSet = myBddVar ()->myBoundSet ();
d429 5
a433 5
return
myScenAttMgr ()->
softLB ()->
myValueFor (theBoundSet, firstScenario ())[myPer ()];
}
d438 3
a440 3
{
return "S. L. B.";
}
d445 3
a447 3
{
myStochImpOP ()->printItem (myBddVar ());
}
d452 3
a454 3
{
return mySlbvVar_->myBddVar ();
}
@


1.39
log
@Heuristic Adjustment
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d48 4
a51 4
      WitStochCon (theStochLoc),
      myPart_     (thePart)
   {
   }
d56 2
a57 2
   {
   }
d62 8
a69 8
   {
   genPartCoeffs   ();
   genMatCoeffs    ();
   genDemandCoeffs ();
   genBomEntCoeffs ();
   genSubCoeffs    ();
   genBopEntCoeffs ();
   }
d74 3
a76 3
   {
   return lowerBoundVal ();
   }
d81 6
a86 6
   {
   return
      myScenAttMgr ()->
         supplyVol ()->
            myValueFor (myPart_, firstScenario ())[myPer ()];
   }
d91 3
a93 3
   {
   return "Resource";
   }
d98 3
a100 3
   {
   myStochImpOP ()->printItem (myPart_);
   }
d105 2
a106 2
   {
   WitStScrapVar * theScrapVar;
d108 1
a108 1
   theScrapVar = myStochLoc ()->myScrapVarFor (myPart_);
d110 3
a112 3
   if (theScrapVar != NULL)
      theScrapVar->incCoeff (1.0);
   }
d117 4
a120 4
   {
   WitMaterial *   theMat;
   WitStStockVar * theStockVar;
   WitStStockVar * prevPerStockVar;
d122 1
a122 1
   theMat = myPart_->thisMat ();
d124 2
a125 2
   if (theMat == NULL)
      return;
d127 1
a127 1
   theStockVar = myStochLoc ()->myStockVarFor (theMat);
d129 2
a130 2
   if (theStockVar != NULL)
       theStockVar->incCoeff (1.0);
d132 2
a133 2
   if (myPer () == 0)
      return;
d135 3
a137 3
   prevPerStockVar =
      findVarStochLocFor (theMat, myPer () - 1)->
         myStockVarFor   (theMat);
d139 3
a141 3
   if (prevPerStockVar != NULL)
       prevPerStockVar->incCoeff (-1.0);
   }
d146 2
a147 2
   {
   WitDemand * theDemand;
d149 3
a151 3
   forEachEl (theDemand, myPart_->myDemands ())
      myStochLoc ()->myShipVarFor (theDemand)->incCoeff (1.0);
   }
d156 32
a187 32
   {
   WitBomEntry *  theBomEnt;
   WitOperation * theOpn;
   WitPeriod      execPerF;
   WitPeriod      execPerL;
   WitPeriod      execPer;
   WitStochLoc *  theStochLoc;
   WitOptVar *    theOptVar;
   double         theRate;

   forEachEl (theBomEnt, myPart_->consumingBomEntries ())
      {
      theOpn       = theBomEnt->myOperation ();

      getExecPerRange (theBomEnt, execPerF, execPerL);

      for (execPer = execPerL; execPer >= execPerF; execPer --)
         if (theBomEnt->impactPeriod ()[execPer] == myPer ())
            {
            theStochLoc = findVarStochLocFor (theOpn, execPer);

            if (theBomEnt->hasSubsInEffect ()[execPer])
               theOptVar = theStochLoc->myNonSubVarFor (theBomEnt);
            else
               theOptVar = theStochLoc->myExecVarFor   (theOpn);

            theRate = theBomEnt->effConsRate ()[execPer];

            theOptVar->incCoeff (theRate);
            }
      }
   }
d192 27
a218 27
   {
   WitSubEntry *  theSub;
   WitOperation * theOpn;
   WitPeriod      execPerF;
   WitPeriod      execPerL;
   WitPeriod      execPer;
   WitStSubVar *  theSubVar;
   double         theRate;

   forEachEl (theSub, myPart_->consumingSubEntries ())
      {
      theOpn = theSub->myOperation ();

      getExecPerRange (theSub, execPerF, execPerL);

      for (execPer = execPerL; execPer >= execPerF; execPer --)
         if (theSub->impactPeriod ()[execPer] == myPer ())
            {
            theSubVar =
               findVarStochLocFor (theOpn, execPer)->mySubVarFor (theSub);

            theRate   = theSub->effConsRate ()[execPer];

            theSubVar->incCoeff (theRate);
            }
      }
   }
d223 27
a249 27
   {
   WitBopEntry *  theBopEnt;
   WitOperation * theOpn;
   WitPeriod      execPerF;
   WitPeriod      execPerL;
   WitPeriod      execPer;
   WitStExecVar * theExecVar;
   double         theRate;

   forEachEl (theBopEnt, myPart_->producingBopEntries ())
      {
      theOpn = theBopEnt->myOperation ();

      getExecPerRange (theBopEnt, execPerF, execPerL);

      for (execPer = execPerL; execPer >= execPerF; execPer --)
         if (theBopEnt->impactPeriod ()[execPer] == myPer ())
            {
            theExecVar =
               findVarStochLocFor (theOpn, execPer)->myExecVarFor (theOpn);

            theRate      = theBopEnt->effProdRate ()[execPer];

            theExecVar->incCoeff (- theRate);
            }
      }
   }
d254 8
a261 8
      WitBillEntry * theBillEnt,
      WitPeriod &    execPerF,
      WitPeriod &    execPerL)
   {
   myStochImpOP ()->
      myExecPerSched ()->
         getExecPerRange (theBillEnt, myPer (), execPerF, execPerL);
   }
d269 4
a272 4
      WitStochCon (theStochLoc),
      myBomEnt_   (theBomEnt)
   {
   }
d277 2
a278 2
   {
   }
d283 3
a285 3
   {
   WitSubEntry *  theSub;
   WitOperation * theOpn;
d287 1
a287 1
   theOpn = myBomEnt_->myOperation ();
d289 1
a289 1
   myStochLoc ()->      myNonSubVarFor (myBomEnt_)->incCoeff  (1.0);
d291 3
a293 3
   forEachEl (theSub, myBomEnt_->mySubEntries ())
      if (theSub->inEffect (myPer ()))
         myStochLoc ()->mySubVarFor    (theSub)   ->incCoeff  (1.0);
d295 2
a296 2
   myStochLoc ()->      myExecVarFor   (theOpn)   ->incCoeff (-1.0);
   }
d301 3
a303 3
   {
   return 0.0;
   }
d308 3
a310 3
   {
   return 0.0;
   }
d315 3
a317 3
   {
   return "Substitution";
   }
d322 3
a324 3
   {
   myStochImpOP ()->printItem (myBomEnt_);
   }
d332 4
a335 4
      WitStochCon (theStochLoc),
      myDemand_   (theDemand)
   {
   }
d340 2
a341 2
   {
   }
d346 2
a347 2
   {
   WitStochLoc * theStochLoc;
d349 11
a359 11
   if (myPer () > 0)
      {
      theStochLoc =
         findVarStochLocFor (myDemand_->demandedPart (), myPer () - 1);

      theStochLoc->myCumShipVarFor (myDemand_)->incCoeff  (1.0);
      }

   myStochLoc () ->myShipVarFor    (myDemand_)->incCoeff  (1.0);
   myStochLoc () ->myCumShipVarFor (myDemand_)->incCoeff (-1.0);
   }
d364 3
a366 3
   {
   return 0.0;
   }
d371 3
a373 3
   {
   return 0.0;
   }
d378 3
a380 3
   {
   return "Shipment";
   }
d385 3
a387 3
   {
   myStochImpOP ()->printItem (myDemand_);
   }
d395 4
a398 4
      WitStochCon (theSlbvVar->myStochLoc ()),
      mySlbvVar_  (theSlbvVar)
   {
   }
d403 2
a404 2
   {
   }
d409 4
a412 4
   {
   myBddVar ()->incCoeff (1.0);
   mySlbvVar_ ->incCoeff (1.0);
   }
d417 3
a419 3
   {
   return DBL_MAX;
   }
d424 2
a425 2
   {
   WitBoundSet * theBoundSet;
d427 1
a427 1
   theBoundSet = myBddVar ()->myBoundSet ();
d429 5
a433 5
   return
      myScenAttMgr ()->
         softLB ()->
            myValueFor (theBoundSet, firstScenario ())[myPer ()];
   }
d438 3
a440 3
   {
   return "S. L. B.";
   }
d445 3
a447 3
   {
   myStochImpOP ()->printItem (myBddVar ());
   }
d452 3
a454 3
   {
   return mySlbvVar_->myBddVar ();
   }
@


1.38
log
@CPLEX
@
text
@d35 1
a35 1
#include <Opn.h>
@


1.37
log
@Stochastic Implosion
@
text
@d27 1
a27 1
#include <StochImpOM.h>
d99 1
a99 1
   myStochImpOM ()->printItem (myPart_);
d258 1
a258 1
   myStochImpOM ()->
d323 1
a323 1
   myStochImpOM ()->printItem (myBomEnt_);
d386 1
a386 1
   myStochImpOM ()->printItem (myDemand_);
d446 1
a446 1
   myStochImpOM ()->printItem (myBddVar ());
@


1.36
log
@Stochastic Implosion
@
text
@d27 1
a27 1
#include <StochImpOP.h>
d99 1
a99 1
   myStochImpOP ()->printItem (myPart_);
d258 1
a258 1
   myStochImpOP ()->
d323 1
a323 1
   myStochImpOP ()->printItem (myBomEnt_);
d386 1
a386 1
   myStochImpOP ()->printItem (myDemand_);
d446 1
a446 1
   myStochImpOP ()->printItem (myBddVar ());
@


1.35
log
@Stochastic Implosion
@
text
@d106 1
a106 1
   WitStScrapVar * theStScrapVar;
d108 1
a108 1
   theStScrapVar = myStochLoc ()->myScrapVarFor (myPart_);
d110 2
a111 2
   if (theStScrapVar != NULL)
      theStScrapVar->incCoeff (1.0);
d119 2
a120 3
   WitStStockVar * theStStockVar;
   WitPeriod       prevPer;
   WitStStockVar * prevPerStStockVar;
d127 1
a127 1
   theStStockVar = myStochLoc ()->myStockVarFor (theMat);
d129 2
a130 2
   if (theStStockVar != NULL)
       theStStockVar->incCoeff (1.0);
d135 3
a137 1
   prevPer = myPer () - 1;
d139 2
a140 5
   prevPerStStockVar =
      findVarStochLocFor (theMat, prevPer)->myStockVarFor (theMat);

   if (prevPerStStockVar != NULL)
       prevPerStStockVar->incCoeff (-1.0);
d198 1
a198 1
   WitStSubVar *  theStSubVar;
d210 1
a210 1
            theStSubVar =
d213 1
a213 1
            theRate     = theSub->effConsRate ()[execPer];
d215 1
a215 1
            theStSubVar->incCoeff (theRate);
d229 1
a229 1
   WitStExecVar * theStExecVar;
d241 1
a241 1
            theStExecVar = 
d246 1
a246 1
            theStExecVar->incCoeff (- theRate);
a286 3
   if (not myStochLoc ()->myStochImpMgr ()->stageByObject ())
      myStochLoc ()->myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

d293 1
a293 1
         myStochLoc ()->mySubVarFor    (theSub)->   incCoeff  (1.0);
d295 1
a295 1
   myStochLoc ()->      myExecVarFor   (theOpn)->   incCoeff (-1.0);
a409 3
   if (not myStochLoc ()->myStochImpMgr ()->stageByObject ())
      myStochLoc ()->myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

@


1.34
log
@Stochastic Implosion
@
text
@d108 1
a108 1
   theStScrapVar = myStochLoc ()->myStScrapVarFor (myPart_);
d128 1
a128 1
   theStStockVar = myStochLoc ()->myStStockVarFor (theMat);
d139 1
a139 1
      findVarStochLocFor (theMat, prevPer)->myStStockVarFor (theMat);
d152 1
a152 1
      myStochLoc ()->myStShipVarFor (theDemand)->incCoeff (1.0);
d180 1
a180 1
               theOptVar = theStochLoc->myStNonSubVarFor (theBomEnt);
d182 1
a182 1
               theOptVar = theStochLoc->myStExecVarFor   (theOpn);
d213 1
a213 1
               findVarStochLocFor (theOpn, execPer)->myStSubVarFor (theSub);
d244 1
a244 1
               findVarStochLocFor (theOpn, execPer)->myStExecVarFor (theOpn);
d294 1
a294 1
   myStochLoc ()->      myStNonSubVarFor (myBomEnt_)->incCoeff  (1.0);
d298 1
a298 1
         myStochLoc ()->myStSubVarFor    (theSub)->   incCoeff  (1.0);
d300 1
a300 1
   myStochLoc ()->      myStExecVarFor   (theOpn)->   incCoeff (-1.0);
d359 1
a359 1
      theStochLoc->myStCumShipVarFor (myDemand_)->incCoeff  (1.0);
d362 2
a363 2
   myStochLoc () ->myStShipVarFor    (myDemand_)->incCoeff  (1.0);
   myStochLoc () ->myStCumShipVarFor (myDemand_)->incCoeff (-1.0);
d398 1
a398 1
WitStSlbCon::WitStSlbCon (WitStSlbvVar * theStSlbvVar):
d400 2
a401 2
      WitStochCon  (theStSlbvVar->myStochLoc ()),
      myStSlbvVar_ (theStSlbvVar)
d418 2
a419 2
   myStBddVar ()->incCoeff (1.0);
   myStSlbvVar_ ->incCoeff (1.0);
d435 1
a435 1
   theBoundSet = myStBddVar ()->myBoundSet ();
d454 1
a454 1
   myStochImpOP ()->printItem (myStBddVar ());
d459 1
a459 1
WitStBddVar * WitStSlbCon::myStBddVar ()
d461 1
a461 1
   return myStSlbvVar_->myStBddVar ();
@


1.33
log
@Stochastic Implosion
@
text
@a363 3

   if (not myStochLoc ()->myStochImpMgr ()->stageByObject ())
      myStochLoc ()->myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);
@


1.32
log
@Stochastic Implosion
@
text
@d33 1
a64 4

   if (not myStochLoc ()->myStochImpMgr ()->stageByObject ())
      myStochLoc ()->myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

d120 2
a121 2
   WitStochLoc *   prevStochLoc;
   WitStStockVar * prevStStockVar;
d136 1
a136 1
   prevStochLoc   = myScenGroup ()->findStochLocForVar (theMat, myPer () - 1);
d138 2
a139 1
   prevStStockVar = prevStochLoc->myStStockVarFor (theMat);
d141 2
a142 2
   if (prevStStockVar != NULL)
       prevStStockVar->incCoeff (-1.0);
a160 1
   WitScenGroup * theScenGroup;
a171 2
      theScenGroup = findScenGroupForOpn (theOpn);

d177 1
a177 1
            theStochLoc = theScenGroup->myStochLocFor (execPer);
d196 1
a196 1
   WitScenGroup * theScenGroup;
d205 1
a205 1
      theScenGroup = findScenGroupForOpn (theSub->myOperation ());
d213 1
a213 1
               theScenGroup->myStochLocFor (execPer)->myStSubVarFor (theSub);
a227 1
   WitScenGroup * theScenGroup;
d236 1
a236 3
      theOpn       = theBopEnt->myOperation ();

      theScenGroup = findScenGroupForOpn (theOpn);
d244 1
a244 1
               theScenGroup->myStochLocFor (execPer)->myStExecVarFor (theOpn);
a254 17
WitScenGroup * WitStResCon::findScenGroupForOpn (WitOperation * theOpn)
   {
   WitStage * theStage;

   if (not myStochLoc ()->myStochImpMgr ()->stageByObject ())
      myStochLoc ()->myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);

   theStage = myStochLoc ()->myStageMgr ()->objectStage (theOpn);

   return
      (theStage->myIndex () == 0)?
         myStochImpOP ()->stage0ScenGroup ():
         myScenGroup ();
   }

//------------------------------------------------------------------------------

d289 3
d352 2
d355 3
a357 3
      myScenGroup ()->
         myStochLocFor (myPer () - 1)->
                  myStCumShipVarFor (myDemand_)->incCoeff  (1.0);
d359 8
a366 2
   myStochLoc ()->myStShipVarFor    (myDemand_)->incCoeff  (1.0);
   myStochLoc ()->myStCumShipVarFor (myDemand_)->incCoeff (-1.0);
d418 3
@


1.31
log
@Stochastic Implosion
@
text
@d22 2
d265 1
a265 1
   int theOpnStage;
d270 1
a270 1
   theOpnStage = myStochLoc ()->myStochImpMgr ()->objectStage (theOpn);
d273 1
a273 1
      (theOpnStage == 0)?
@


1.30
log
@Stochastic Implosion
@
text
@d62 4
d121 2
d132 1
a132 1
      theStStockVar->incCoeff (1.0);
d137 3
a139 4
   theStStockVar =
      myScenGroup ()->
         myStochLocFor (myPer () - 1)->
            myStStockVarFor (theMat);
d141 2
a142 2
   if (theStStockVar != NULL)
      theStStockVar->incCoeff (-1.0);
d173 1
a173 1
      theScenGroup = findScenGroupFor (theOpn);
d208 1
a208 1
      theScenGroup = findScenGroupFor (theSub->myOperation ());
d242 1
a242 1
      theScenGroup = findScenGroupFor (theOpn);
d261 1
a261 1
WitScenGroup * WitStResCon::findScenGroupFor (WitOperation * theOpn)
d263 1
a263 1
   int theOpnStageIdx;
d268 1
a268 1
   theOpnStageIdx = myStochLoc ()->myStochImpMgr ()->objectStage (theOpn);
d271 1
a271 1
      (theOpnStageIdx == 0)?
@


1.29
log
@Stochastic Implosion
@
text
@d263 1
a263 1
   theOpnStageIdx = myStochLoc ()->myStochImpMgr ()->stageIndex (theOpn);
@


1.28
log
@Stochastic Implosion
@
text
@d35 1
d260 3
@


1.27
log
@Stochastic Implosion
@
text
@a154 1
   int            theOpnStageIdx;
d160 1
d165 1
a165 1
      theOpn         = theBomEnt->myOperation ();
d167 1
a167 6
      theOpnStageIdx = myStochLoc ()->myStochImpMgr ()->stageIndex (theOpn);

      theScenGroup   =
         (theOpnStageIdx == 0)?
            myStochImpOP ()->stage0ScenGroup ():
            myScenGroup ();
a175 2
            theRate     = theBomEnt->effConsRate ()[execPer];

d177 1
a177 1
               theStochLoc->myStNonSubVarFor (theBomEnt)->incCoeff (theRate);
d179 5
a183 1
               theStochLoc->myStExecVarFor   (theOpn)   ->incCoeff (theRate);
d192 7
a198 5
   WitSubEntry * theSub;
   WitPeriod     execPerF;
   WitPeriod     execPerL;
   WitPeriod     execPer;
   double        theRate;
d202 2
d209 2
a210 1
            theRate = theSub->effConsRate ()[execPer];
d212 3
a214 4
            myScenGroup ()->
               myStochLocFor (execPer)->
                  myStSubVarFor (theSub)->
                     incCoeff (theRate);
a224 1
   int            theOpnStageIdx;
d229 1
d234 1
a234 3
      theOpn         = theBopEnt->myOperation ();

      theOpnStageIdx = myStochLoc ()->myStochImpMgr ()->stageIndex (theOpn);
d236 1
a236 4
      theScenGroup   =
         (theOpnStageIdx == 0)?
            myStochImpOP ()->stage0ScenGroup ():
            myScenGroup ();
d243 4
a246 1
            theRate = theBopEnt->effProdRate ()[execPer];
d248 1
a248 4
            theScenGroup->
               myStochLocFor (execPer)->
                  myStExecVarFor (theOpn)->
                     incCoeff (- theRate);
d255 14
@


1.26
log
@Stochastic Implosion
@
text
@d155 2
d165 8
a172 1
      theOpn = theBomEnt->myOperation ();
d179 1
a179 1
            theStochLoc = myScenGroup ()->myStochLocFor (execPer);
d224 1
d233 3
a235 1
      theOpn = theBopEnt->myOperation ();
d237 4
a240 4
      if (myStochLoc ()->myStochImpMgr ()->stageIndex (theOpn) == 0)
         theScenGroup = myStochImpOP ()->stage0ScenGroup ();
      else
         theScenGroup = myScenGroup ();
@


1.25
log
@Stochastic Implosion
@
text
@d225 1
a225 1
      if (myStochLoc ()->myStochImpMgr ()->stageNo (theOpn) == 0)
@


1.24
log
@Stochastic Implosion
@
text
@d23 1
d78 4
a81 1
   return firstScenario ()->supplyVol ()->myValueFor (myPart_)[myPer ()];
d414 4
d419 1
a419 1
      firstScenario ()->
d421 1
a421 1
            myValueFor (myStBddVar ()->myBoundSet ())[myPer ()];
@


1.23
log
@Stochastic Implosion
@
text
@a32 1
#include <BoundSet.h>
d410 4
a413 1
   return myStBddVar ()->myBoundSet ()->softLB ()[myPer ()];
@


1.22
log
@Stochastic Implosion
@
text
@d23 1
d78 1
a78 1
   return firstScenario ()->supplyVol (myPart_, myPer ());
@


1.21
log
@Stochastic Implosion
@
text
@a27 2
#include <ScenAttMgr.h>
#include <ScenInputAtt.h>
d77 1
a77 6
   return
      myStochImpOP ()->
         myStochModeMgr ()->
            myScenAttMgr ()->
               supplyVol ()->
                  myValue (myPart_, myScenGroup ()->firstScenario ())[myPer ()];
@


1.20
log
@Stochastic Implosion
@
text
@d27 3
d72 1
a72 1
   return myScenGroup ()->firstScenario ()->supplyVolAcc (myPart_)[myPer ()];
d79 6
a84 1
   return myScenGroup ()->firstScenario ()->supplyVolAcc (myPart_)[myPer ()];
@


1.19
log
@Stochastic Implosion
@
text
@d69 1
a69 1
   return myScenGroup ()->firstScenario ()->supplyVol () (myPart_)[myPer ()];
d76 1
a76 1
   return myScenGroup ()->firstScenario ()->supplyVol () (myPart_)[myPer ()];
@


1.18
log
@Stochastic Implosion
@
text
@d18 1
d31 1
d34 2
d372 60
@


1.17
log
@Stochastic Implosion
@
text
@d16 1
a17 1
//    StSubCon
d249 1
a249 1
// Implementation of class StShipCon.
d252 1
a252 1
WitStShipCon::WitStShipCon (WitDemand * theDemand, WitStochLoc * theStochLoc):
d255 1
a255 1
      myDemand_   (theDemand)
d261 1
a261 1
WitStShipCon::~WitStShipCon ()
d267 1
a267 1
void WitStShipCon::generateCoeffs ()
d269 10
a278 4
   if (myPer () > 0)
      myScenGroup ()->
         myStochLocFor (myPer () - 1)->
                  myStCumShipVarFor (myDemand_)->incCoeff  (1.0);
d280 1
a280 2
   myStochLoc ()->myStShipVarFor    (myDemand_)->incCoeff  (1.0);
   myStochLoc ()->myStCumShipVarFor (myDemand_)->incCoeff (-1.0);
d285 1
a285 1
double WitStShipCon::upperBoundVal ()
d292 1
a292 1
double WitStShipCon::lowerBoundVal ()
d299 1
a299 1
const char * WitStShipCon::classText ()
d301 1
a301 1
   return "Shipment";
d306 1
a306 1
void WitStShipCon::printItem ()
d308 1
a308 1
   myStochImpOP ()->printItem (myDemand_);
d312 1
a312 1
// Implementation of class StSubCon.
d315 1
a315 1
WitStSubCon::WitStSubCon (WitBomEntry * theBomEnt, WitStochLoc * theStochLoc):
d318 1
a318 1
      myBomEnt_   (theBomEnt)
d324 1
a324 1
WitStSubCon::~WitStSubCon ()
d330 1
a330 1
void WitStSubCon::generateCoeffs ()
d332 4
a335 2
   WitSubEntry *  theSub;
   WitOperation * theOpn;
d337 2
a338 9
   theOpn = myBomEnt_->myOperation ();

   myStochLoc ()->      myStNonSubVarFor (myBomEnt_)->incCoeff  (1.0);

   forEachEl (theSub, myBomEnt_->mySubEntries ())
      if (theSub->inEffect (myPer ()))
         myStochLoc ()->myStSubVarFor    (theSub)->   incCoeff  (1.0);

   myStochLoc ()->      myStExecVarFor   (theOpn)->   incCoeff (-1.0);
d343 1
a343 1
double WitStSubCon::upperBoundVal ()
d350 1
a350 1
double WitStSubCon::lowerBoundVal ()
d357 1
a357 1
const char * WitStSubCon::classText ()
d359 1
a359 1
   return "Substitution";
d364 1
a364 1
void WitStSubCon::printItem ()
d366 1
a366 1
   myStochImpOP ()->printItem (myBomEnt_);
@


1.16
log
@Stochastic Implosion
@
text
@d25 1
d28 1
d121 4
a124 1
   theStStockVar = myStochLocForPer (myPer () - 1)->myStStockVarFor (theMat);
d149 2
a150 1
   WitStochVar *  theStochVar;
d161 4
d166 1
a166 2
               theStochVar = 
                  myStochLocForPer (execPer)->myStNonSubVarFor (theBomEnt);
d168 1
a168 4
               theStochVar = 
                  myStochLocForPer (execPer)->myStExecVarFor   (theOpn);

            theStochVar->incCoeff (theBomEnt->effConsRate ()[execPer]);
d181 1
d189 8
a196 3
            myStochLocForPer (execPer)->
               myStSubVarFor (theSub)->
                  incCoeff (theSub->effConsRate ()[execPer]);
a201 3
#include <StochImpMgr.h>
#include <Opn.h>

d206 1
d210 1
d216 4
a219 3
      stronglyAssert (
            myStochLoc ()->myStochImpMgr ()->stageNo (theOpn)
         == myStochLoc ()->myStochImpMgr ()->stageNo (myPart_));
d225 8
a232 3
            myStochLocForPer (execPer)->
               myStExecVarFor (theOpn)->
                  incCoeff (- theBopEnt->effProdRate ()[execPer]);
d270 2
a271 1
      myStochLocForPer (myPer () - 1)->
@


1.15
log
@Stochastic Implosion
@
text
@d190 3
d205 4
@


1.14
log
@Stochastic Implosion
@
text
@a22 1
#include <ScenSet.h>
d63 1
a63 1
   return myScenSet ()->firstScenario ()->supplyVol () (myPart_)[myPer ()];
d70 1
a70 1
   return myScenSet ()->firstScenario ()->supplyVol () (myPart_)[myPer ()];
@


1.13
log
@Stochastic Implosion
@
text
@d64 1
a64 5
   return
      myStochLoc ()->
         myScenSet ()->
            myScenario ()->
               supplyVol () (myPart_)[myPer ()];
d71 1
a71 5
   return
      myStochLoc ()->
         myScenSet ()->
            myScenario ()->
               supplyVol () (myPart_)[myPer ()];
d85 1
a85 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myPart_);
d220 3
a222 5
   myStochLoc ()->
      myScenSet ()->
         myStochImpOP ()->
            myExecPerSched ()->
               getExecPerRange (theBillEnt, myPer (), execPerF, execPerL);
d279 1
a279 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myDemand_);
d342 1
a342 1
   myStochLoc ()->myScenSet ()->myStochImpOP ()->printItem (myBomEnt_);
@


1.12
log
@Stochastic Implosion
@
text
@d35 1
a35 1
WitStResCon::WitStResCon (WitPart * thePart, WitScenPer * theScenPer):
d37 1
a37 1
      WitStochCon (theScenPer),
d64 5
a68 1
   return myScenario ()->supplyVol () (myPart_)[myPer ()];
d75 5
a79 1
   return myScenario ()->supplyVol () (myPart_)[myPer ()];
d93 1
a93 1
   myStochImpOP ()->printItem (myPart_);
d228 5
a232 3
   myStochImpOP ()->
      myExecPerSched ()->
         getExecPerRange (theBillEnt, myPer (), execPerF, execPerL);
d239 1
a239 1
WitStShipCon::WitStShipCon (WitDemand * theDemand, WitScenPer * theScenPer):
d241 1
a241 1
      WitStochCon (theScenPer),
d289 1
a289 1
   myStochImpOP ()->printItem (myDemand_);
d296 1
a296 1
WitStSubCon::WitStSubCon (WitBomEntry * theBomEnt, WitScenPer * theScenPer):
d298 1
a298 1
      WitStochCon (theScenPer),
d352 1
a352 1
   myStochImpOP ()->printItem (myBomEnt_);
@


1.11
log
@Stochastic Implosion
@
text
@d24 1
a24 1
#include <ScenSetPer.h>
d94 1
a94 1
   theStScrapVar = myScenSetPer ()->myStScrapVarFor (myPart_);
d112 1
a112 1
   theStStockVar = myScenSetPer ()->myStStockVarFor (theMat);
d120 1
a120 1
   theStStockVar = myScenSetPerForPer (myPer () - 1)->myStStockVarFor (theMat);
d133 1
a133 1
      myScenSetPer ()->myStShipVarFor (theDemand)->incCoeff (1.0);
d158 1
a158 1
                  myScenSetPerForPer (execPer)->myStNonSubVarFor (theBomEnt);
d161 1
a161 1
                  myScenSetPerForPer (execPer)->myStExecVarFor   (theOpn);
d183 1
a183 1
            myScenSetPerForPer (execPer)->
d207 1
a207 1
            myScenSetPerForPer (execPer)->
d247 2
a248 2
      myScenSetPerForPer (myPer () - 1)->
                    myStCumShipVarFor (myDemand_)->incCoeff  (1.0);
d250 2
a251 2
   myScenSetPer ()->myStShipVarFor    (myDemand_)->incCoeff  (1.0);
   myScenSetPer ()->myStCumShipVarFor (myDemand_)->incCoeff (-1.0);
d308 1
a308 1
   myScenSetPer ()->      myStNonSubVarFor (myBomEnt_)->incCoeff  (1.0);
d312 1
a312 1
         myScenSetPer ()->myStSubVarFor    (theSub)->   incCoeff  (1.0);
d314 1
a314 1
   myScenSetPer ()->      myStExecVarFor   (theOpn)->   incCoeff (-1.0);
@


1.10
log
@Stochastic Implosion
@
text
@d23 2
a24 1
#include <StOptElMgr.h>
d94 1
a94 2
   theStScrapVar =
      myStochImpOP ()->myStScrapVarFor (myPart_, myPer (), myScenario ());
d112 1
a112 2
   theStStockVar =
      myStochImpOP ()->myStStockVarFor (theMat, myPer (),     myScenario ());
d120 1
a120 2
   theStStockVar =
      myStochImpOP ()->myStStockVarFor (theMat, myPer () - 1, myScenario ());
d133 1
a133 3
      myStochImpOP ()->
         myStShipVarFor (theDemand, myPer (), myScenario ())->
            incCoeff (1.0);
d158 1
a158 2
                  myStochImpOP ()->
                     myStNonSubVarFor (theBomEnt, execPer, myScenario ());
d161 1
a161 2
                  myStochImpOP ()->
                     myStExecVarFor   (theOpn,    execPer, myScenario ());
d183 2
a184 2
            myStochImpOP ()->
               myStSubVarFor (theSub, execPer, myScenario ())->
a197 1
   WitStExecVar * theStExecVar;
d207 3
a209 6
            {
            theStExecVar =
               myStochImpOP ()->myStExecVarFor (theOpn, execPer, myScenario ());

            theStExecVar->incCoeff (- theBopEnt->effProdRate ()[execPer]);
            }
d247 2
a248 3
      myStochImpOP ()->
         myStCumShipVarFor (myDemand_, myPer () - 1, myScenario ())->
            incCoeff (1.0);
d250 2
a251 7
   myStochImpOP ()->
      myStShipVarFor (myDemand_, myPer (), myScenario ())->
         incCoeff (1.0);

   myStochImpOP ()->
      myStCumShipVarFor (myDemand_, myPer (), myScenario ())->
         incCoeff (-1.0);
d303 4
a306 1
   WitSubEntry * theSub;
d308 1
a308 3
   myStochImpOP ()->
      myStNonSubVarFor (myBomEnt_, myPer (), myScenario ())->
         incCoeff (1.0);
d312 1
a312 3
         myStochImpOP ()->
            myStSubVarFor (theSub, myPer (), myScenario ())->
               incCoeff (1.0);
d314 1
a314 3
   myStochImpOP ()->
      myStExecVarFor (myBomEnt_->myOperation (), myPer (), myScenario ())->
         incCoeff (-1.0);
@


1.9
log
@Stochastic Implosion
@
text
@d17 1
d26 1
a26 1
#include <BomEntry.h>
d55 1
d149 1
a149 1
   double         theCoeffVal;
d160 8
a167 1
            theCoeffVal = theBomEnt->effConsRate ()[execPer];
d169 20
d190 2
a191 3
               myStExecVarFor (theOpn, execPer, myScenario ())->
                  incCoeff (theCoeffVal);
            }
d204 1
a204 1
   double         theCoeffVal;
d215 2
a216 1
            theCoeffVal = - theBopEnt->effProdRate ()[execPer];
d218 1
a218 3
            myStochImpOP ()->
               myStExecVarFor (theOpn, execPer, myScenario ())->
                  incCoeff (theCoeffVal);
d297 66
@


1.8
log
@Stochastic Implosion
@
text
@d59 1
a59 1
double WitStResCon::compUpperBound ()
d66 1
a66 1
double WitStResCon::compLowerBound ()
d245 1
a245 1
double WitStShipCon::compUpperBound ()
d252 1
a252 1
double WitStShipCon::compLowerBound ()
@


1.7
log
@Stochastic Implosion
@
text
@d24 1
a24 1
#include <Part.h>
d51 1
d92 1
a92 2
      myStochImpOP ()->
         myStScrapVarFor (myPart_, myPer (), myScenario ());
d100 28
@


1.6
log
@Stochastic Implosion
@
text
@d58 1
a58 1
void WitStResCon::compBounds ()
d60 2
a61 1
   double supplyVolVal;
d63 1
a63 1
   supplyVolVal = myScenario ()->supplyVol () (myPart_)[myPer ()];
d65 3
a67 1
   setBoundsTo (supplyVolVal, supplyVolVal);
d217 8
a224 1
void WitStShipCon::compBounds ()
d226 1
a226 1
   setBoundsTo (0.0, 0.0);
@


1.5
log
@Stochastic Implosion
@
text
@d13 4
a16 1
// Contains the implementation of class StResCon.
d51 1
d53 1
d97 12
a115 1
   WitStExecVar * theStExecVar;
a126 4
            theStExecVar =
               myStochImpOP ()->
                  myStExecVarFor (theOpn, execPer, myScenario ());

d129 3
a131 1
            theStExecVar->incCoeff (theCoeffVal);
a144 1
   WitStExecVar * theStExecVar;
a155 4
            theStExecVar =
               myStochImpOP ()->
                  myStExecVarFor (theOpn, execPer, myScenario ());

d158 3
a160 1
            theStExecVar->incCoeff (theCoeffVal);
d176 56
@


1.4
log
@Stochastic Implosion
@
text
@d23 1
d47 33
a80 5
   WitBomEntry *   theBomEnt;
   WitOperation *  theOpn;
   WitPeriod       execPerF;
   WitPeriod       execPerL;
   WitPeriod       execPer;
d83 2
a84 1
      myStochImpOP ()->myStScrapVarFor (myPart_, myPer (), myScenario ());
d88 13
d110 9
a118 2
            myStochImpOP ()->myStExecVarFor (theOpn, execPer, myScenario ())->
               incCoeff (theBomEnt->effConsRate ()[execPer]);
d124 1
a124 1
void WitStResCon::compBounds ()
d126 7
a132 1
   double supplyVolVal;
d134 3
a136 1
   supplyVolVal = myScenario ()->supplyVol () (myPart_)[myPer ()];
d138 1
a138 2
   setBoundsTo (supplyVolVal, supplyVolVal);
   }
d140 6
a145 1
//------------------------------------------------------------------------------
d147 1
a147 4
const char * WitStResCon::classText ()
   {
   return "Resource";
   }
d149 3
a151 5
//------------------------------------------------------------------------------

void WitStResCon::printItem ()
   {
   myStochImpOP ()->printItem (myPart_);
@


1.3
log
@Stochastic Implosion
@
text
@d92 1
a92 1
void WitStResCon::printItem () const
@


1.2
log
@Stochastic Implosion
@
text
@d85 1
a85 1
const char * WitStResCon::classText () const
@


1.1
log
@Stochastic Implosion
@
text
@d20 1
a20 1
#include <StochVars.h>
@


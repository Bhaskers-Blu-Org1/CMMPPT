head	1.42;
access;
symbols
	sce_5_01_20080919:1.37
	latest_sce_4_20_20060523:1.29.0.2
	sce_4_20_20060523:1.29
	latest_sce4_20_OSL:1.28.0.2
	sce_4_20_OSL:1.28
	sce_410_withVa:1.21
	sce_4_05_20040511:1.12
	sce_4_00_20040201:1.10
	nextGenBranch:1.8.0.2
	nextGenRoot:1.8
	sce_3_30_20030627:1.8
	EndRw-branch:1.6.0.4
	Root-of-EndRw:1.6
	rwToStl:1.6.0.2
	latest_sce_3_10_20010924:1.3.0.8
	sce_3_10_20010924:1.3
	latest_sce_3_00_20010601:1.3.0.6
	sce_3_00_20010601:1.3
	latest_sce_2_31_20010308:1.3.0.4
	sce_2_31_20010308:1.3
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2011.09.28.23.50.46;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.24.00.29.02;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.08.30.20.18.27;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.09.18.13.39;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.09.15.24.23;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.02.17.48.38;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.08.18.38.25;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.02.23.07.14;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2006.09.15.23.09.42;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.29.15.31.54;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.29.15.01.47;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.24.20.50.28;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.22.21.26.56;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.02.17.34.17;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.16.16.52.56;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.07.20.01.12;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.07.19.49.10;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.18.20.56.22;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.19.14.49.33;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.14.21.54.46;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.13.19.31.58;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.19.21.38.04;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.12.19.35.30;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.14.18.16.50;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.13.21.18.47;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.11.22.53.50;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.07.15.16.24;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.05.22.04.25;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.12.21.50.59;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.12.19.43.31;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.25.21.43.33;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.25.19.59.38;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.08.19.27.44;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.01.21.05.06;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.02.23.40.55;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.02.22.18.58;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.09.19.52.38;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.24.18.26.12;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.18.14.02.49;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.29;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.22;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.34;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.34;	author wit;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "msgApi.C"
//
// Inner API functions relating to the message facility.
//------------------------------------------------------------------------------

#include <WitRun.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <Str.h>

//------------------------------------------------------------------------------

void WitRun::witGetMesgFile (FILE * * fileP)
   {
   myApiMgr_->startInnerFunc ();

   apiGet (fileP, "fileP", myMsgFac ().myFile ());

   myMsgFac () ("getAttrMsg", "mesgFile");
   }

//------------------------------------------------------------------------------

void WitRun::witSetMesgFileName (
      WitBoolean   quiet,
      const char * newFileName)
   {
   FILE * tempFile;
   int    fcloseResult;

   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgFileName");

      // open new message file
      //
   if (equalCstrings (newFileName, WitSTDOUT))
      {
      tempFile = stdout;
      }
   else
      tempFile =
         mySession_->
            openFile (newFileName, myMsgFac ().accessMode ().myCstring ());

   if (not quiet)
      myMsgFac () ("setStringAttrMsg",
         "mesgFileName",
         myMsgFac ().fileName (),
         newFileName);

      // close old message file
      //
   if (myMsgFac ().fileName () != WitSTDOUT)
      {
      fcloseResult = fclose (myMsgFac ().myFile ());

      if (fcloseResult != 0)
         myMsgFac () ("fcloseSmsg", myMsgFac ().fileName ());
      }

   myMsgFac ().setMyFile (tempFile, newFileName);

   myInputID ()->setMyAttName (NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witGetMesgFileName (char * * mesgFileName)
   {
   myApiMgr_->startInnerFunc ();

   apiGet (mesgFileName, "mesgFileName", myMsgFac ().fileName ());

   myMsgFac () ("getAttrMsg", "mesgFileName");
   }

//------------------------------------------------------------------------------

void WitRun::witSetMesgFileAccessMode (
      WitBoolean   quiet,
      const char * newMode )
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgFileAccessMode");

   if (not quiet)
      myMsgFac () ("setStringAttrMsg",
         "mesgFileAccessMode",
         myMsgFac ().accessMode (),
         newMode);

   myMsgFac ().setAccessMode (newMode);

   myInputID ()->setMyAttName (NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witGetMesgFileAccessMode (char * * mesgFileAccessMode)
   {
   myApiMgr_->startInnerFunc ();

   apiGet (mesgFileAccessMode, "mesgFileAccessMode", myMsgFac ().accessMode ());

   myMsgFac () ("getAttrMsg", "mesgFileAccessMode");
   }

//------------------------------------------------------------------------------

void WitRun::witSetMesgPrintNumber (
      WitBoolean quiet,
      int        messageNumber,
      WitBoolean mesgPrintMunber)
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgPrintNumber");

   if (myMsgFac ().isExtNumOfLevel (messageNumber))
      {
      if (not quiet)
         myMsgFac () ("setMsgTypeBoolAttrMsg",
            "mesgPrintNumber",
            myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
            mesgPrintMunber);

      myMsgFac ().setDisplayExternalNumberByLevel (
         messageNumber,
         asaBool (mesgPrintMunber));
      }
   else if (checkMsgExtNum (messageNumber))
      {
      if (not quiet)
         myMsgFac () (
            "setMsgBoolAttrMsg",
            "mesgPrintNumber",
            messageNumber,
            mesgPrintMunber);

      myMsgFac ().setDisplayExternalNumber (
         messageNumber,
         asaBool (mesgPrintMunber));
      }

   myInputID ()->setMyAttName (NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witGetMesgPrintNumber (
      int          messageNumber,
      WitBoolean * mesgPrintMunber)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () ("getAttrMsg", "mesgPrintNumber");

   if (checkMsgExtNum (messageNumber))
      apiGet (
         mesgPrintMunber,
         "mesgPrintMunber",
         myMsgFac ().displayExternalNumber (messageNumber));
   }

//------------------------------------------------------------------------------

void WitRun::witSetMesgStopRunning (
      WitBoolean quiet,
      int        messageNumber,
      WitBoolean mesgStopRunning)
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgStopRunning");

   if (    messageNumber != WitINFORMATIONAL_MESSAGES
       and messageNumber != WitWARNING_MESSAGES)
      {
      if (myMsgFac ().isExtNumOfLevel (messageNumber))
         {
         if (not quiet)
            {
            myMsgFac () ("setMsgTypeBoolAttrMsg",
               "mesgStopRunning",
               myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
               mesgStopRunning);

            if (mesgStopRunning)
               myMsgFac () ("setMsgType2ndBoolAttrMsg",
                  "mesgThrowErrorExc",
                  myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
                  "mesgStopRunning");
            }

         myMsgFac ().setStopRunningByLevel (
            messageNumber,
            asaBool (mesgStopRunning));
         }
      else if (checkMsgExtNum (messageNumber))
         {
         if (not quiet)
            {
            myMsgFac () (
               "setMsgBoolAttrMsg",
               "mesgStopRunning",
               messageNumber,
               mesgStopRunning);

            if (mesgStopRunning)
               if (myMsgFac ().throwErrorExc (messageNumber))
                  myMsgFac () ("setMsg2ndBoolAttrMsg",
                     "mesgThrowErrorExc",
                     messageNumber,
                     "mesgStopRunning");
            }

         myMsgFac ().setStopRunning (messageNumber, asaBool (mesgStopRunning));
         }
      }

   myInputID ()->setMyAttName (NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witGetMesgStopRunning (
      int          messageNumber,
      WitBoolean * mesgStopRunning)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () ("getAttrMsg", "mesgStopRunning");

   if (checkMsgExtNum (messageNumber))
      apiGet (
         mesgStopRunning,
          "mesgStopRunning",
          myMsgFac ().stopRunning (messageNumber));
   }

//------------------------------------------------------------------------------

void WitRun::witSetMesgThrowErrorExc (
      WitBoolean quiet,
      int        messageNumber,
      WitBoolean mesgThrowErrorExc)
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgThrowErrorExc");

   if (not ERROR_EXC_AVAIL)
      myMsgFac () ("errorExcNotAvailSmsg");

   if (    messageNumber != WitINFORMATIONAL_MESSAGES
       and messageNumber != WitWARNING_MESSAGES)
      {
      if (myMsgFac ().isExtNumOfLevel (messageNumber))
         {
         if (not quiet)
            {
            myMsgFac () ("setMsgTypeBoolAttrMsg",
               "mesgThrowErrorExc",
               myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
               mesgThrowErrorExc);

            if (mesgThrowErrorExc)
               myMsgFac () ("setMsgType2ndBoolAttrMsg",
                  "mesgStopRunning",
                  myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
                  "mesgThrowErrorExc");
            }

         myMsgFac ().setThrowErrorExcByLevel (
            messageNumber,
            asaBool (mesgThrowErrorExc));
         }
      else if (checkMsgExtNum (messageNumber))
         {
         if (not quiet)
            {
            myMsgFac () ("setMsgBoolAttrMsg",
               "mesgThrowErrorExc",
               messageNumber,
               mesgThrowErrorExc);

            if (mesgThrowErrorExc)
               if (myMsgFac ().stopRunning (messageNumber))
                  myMsgFac () ("setMsg2ndBoolAttrMsg",
                     "mesgStopRunning",
                     messageNumber,
                     "mesgThrowErrorExc");
            }

         myMsgFac ().
            setThrowErrorExc (messageNumber, asaBool (mesgThrowErrorExc));
         }
      }

   myInputID ()->setMyAttName (NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witGetMesgThrowErrorExc (
      int          messageNumber,
      WitBoolean * mesgThrowErrorExc)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () ("getAttrMsg", "mesgThrowErrorExc");

   if (checkMsgExtNum (messageNumber))
      apiGet (
         mesgThrowErrorExc,
          "mesgThrowErrorExc",
          myMsgFac ().throwErrorExc (messageNumber));
   }

//------------------------------------------------------------------------------

void WitRun::witSetMesgTimesPrint (
      WitBoolean quiet,
      int        messageNumber,
      int        mesgTimesPrint)
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgTimesPrint");

   int maxTimesIssued;
      //
      // Same as mesgTimesPrint, but negative == infinity.

      // Check range of mesgTimesPrint
      //
   if (mesgTimesPrint < 0 or mesgTimesPrint > UCHAR_MAX)
      myMsgFac () ("intLowEqUpEqImmSmsg", mesgTimesPrint, 0, UCHAR_MAX);

   maxTimesIssued =
      (mesgTimesPrint == UCHAR_MAX)?
         -1:
         mesgTimesPrint;

   if (myMsgFac ().isExtNumOfLevel (messageNumber))
      {
      if (not quiet)
         myMsgFac () ("chgMsgsTimesPrintSm",
            myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
            mesgTimesPrint);

      myMsgFac ().setMaxTimesIssuedByLevel (messageNumber, maxTimesIssued);
      }
   else if (checkMsgExtNum (messageNumber))
      {
      if (not quiet)
         myMsgFac () ("chgMsgTimesPrintSm", messageNumber, mesgTimesPrint);

      myMsgFac ().setMaxTimesIssued (messageNumber, maxTimesIssued);
      }

   myInputID ()->setMyAttName (NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witGetMesgTimesPrint (
      int   messageNumber,
      int * mesgTimesPrint)
   {
   int maxTimesIssued;
      //
      // Same as mesgTimesPrint, but negative == infinity.

   myApiMgr_->startInnerFunc ();

   myMsgFac () ("getAttrMsg", "mesgTimesPrint");

   if (checkMsgExtNum (messageNumber))
      {
      maxTimesIssued = myMsgFac ().maxTimesIssued (messageNumber);

      apiGet (
         mesgTimesPrint,
         "mesgTimesPrint",
         (maxTimesIssued < 0)?
            UCHAR_MAX:
            maxTimesIssued);
      }
   }

//------------------------------------------------------------------------------

void WitRun::witListUnissuedMsgs ()
   {
   myApiMgr_->startInnerFunc ();

   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", "witListUnissuedMsgs");

   myMsgFac ().listUnissuedMsgs ();
   }

//------------------------------------------------------------------------------

const char * WitRun::levelExtNumFragID (int theExtNum)
   {
   WitMsgID theMsgID;

   theMsgID =
      (theExtNum == WitINFORMATIONAL_MESSAGES)? "informationalMsgFrag":
      (theExtNum == WitWARNING_MESSAGES)?       "warningMsgFrag":
      (theExtNum == WitSEVERE_MESSAGES)?        "severeMsgFrag":
      (theExtNum == WitFATAL_MESSAGES)?         "fatalMsgFrag":
                                                NULL;

   witAssert (theMsgID != NULL);

   return theMsgID;
   }

//------------------------------------------------------------------------------

bool WitRun::checkMsgExtNum (int theExtNum)
   {
   bool theExtNumIsValid;

   theExtNumIsValid = myMsgFac ().isExtNumOfMsg (theExtNum);

   if (not theExtNumIsValid)
      myMsgFac () ("invalidExtNumWmsg", apiFuncName (), theExtNum);

   return theExtNumIsValid;
   }
@


1.41
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.40
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d26 2
a27 2
{
myApiMgr_->startInnerFunc ();
d29 1
a29 1
apiGet (fileP, "fileP", myMsgFac ().myFile ());
d31 2
a32 2
myMsgFac () ("getAttrMsg", "mesgFile");
}
d37 41
a77 12
WitBoolean   quiet,
const char * newFileName)
{
FILE * tempFile;
int    fcloseResult;

if (quiet)
myApiMgr_->skipCallMsg       ();

myApiMgr_->   allowPreInit      ();
myApiMgr_->   allowExtOptActive ();
myApiMgr_->   startInnerFunc    ();
d79 1
a79 1
myInputID ()->setMyAttName ("mesgFileName");
d81 2
a82 31
// open new message file
//
if (equalCstrings (newFileName, WitSTDOUT))
{
tempFile = stdout;
}
else
tempFile =
mySession_->
openFile (newFileName, myMsgFac ().accessMode ().myCstring ());

if (not quiet)
myMsgFac () ("setStringAttrMsg",
"mesgFileName",
myMsgFac ().fileName (),
newFileName);

// close old message file
//
if (myMsgFac ().fileName () != WitSTDOUT)
{
fcloseResult = fclose (myMsgFac ().myFile ());

if (fcloseResult != 0)
myMsgFac () ("fcloseSmsg", myMsgFac ().fileName ());
}

myMsgFac ().setMyFile (tempFile, newFileName);

myInputID ()->setMyAttName (NULL);
}
d87 2
a88 2
{
myApiMgr_->startInnerFunc ();
d90 1
a90 1
apiGet (mesgFileName, "mesgFileName", myMsgFac ().fileName ());
d92 2
a93 2
myMsgFac () ("getAttrMsg", "mesgFileName");
}
d98 17
a114 17
WitBoolean   quiet,
const char * newMode )
{
if (quiet)
myApiMgr_->skipCallMsg       ();

myApiMgr_->   allowPreInit      ();
myApiMgr_->   allowExtOptActive ();
myApiMgr_->   startInnerFunc    ();

myInputID ()->setMyAttName ("mesgFileAccessMode");

if (not quiet)
myMsgFac () ("setStringAttrMsg",
"mesgFileAccessMode",
myMsgFac ().accessMode (),
newMode);
d116 1
a116 1
myMsgFac ().setAccessMode (newMode);
d118 2
a119 2
myInputID ()->setMyAttName (NULL);
}
d124 2
a125 2
{
myApiMgr_->startInnerFunc ();
d127 1
a127 1
apiGet (mesgFileAccessMode, "mesgFileAccessMode", myMsgFac ().accessMode ());
d129 2
a130 2
myMsgFac () ("getAttrMsg", "mesgFileAccessMode");
}
d135 38
a172 38
WitBoolean quiet,
int        messageNumber,
WitBoolean mesgPrintMunber)
{
if (quiet)
myApiMgr_->skipCallMsg       ();

myApiMgr_->   allowPreInit      ();
myApiMgr_->   allowExtOptActive ();
myApiMgr_->   startInnerFunc    ();

myInputID ()->setMyAttName ("mesgPrintNumber");

if (myMsgFac ().isExtNumOfLevel (messageNumber))
{
if (not quiet)
myMsgFac () ("setMsgTypeBoolAttrMsg",
"mesgPrintNumber",
myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
mesgPrintMunber);

myMsgFac ().setDisplayExternalNumberByLevel (
messageNumber,
asaBool (mesgPrintMunber));
}
else if (checkMsgExtNum (messageNumber))
{
if (not quiet)
myMsgFac () (
"setMsgBoolAttrMsg",
"mesgPrintNumber",
messageNumber,
mesgPrintMunber);

myMsgFac ().setDisplayExternalNumber (
messageNumber,
asaBool (mesgPrintMunber));
}
d174 2
a175 2
myInputID ()->setMyAttName (NULL);
}
d180 13
a192 13
int          messageNumber,
WitBoolean * mesgPrintMunber)
{
myApiMgr_->startInnerFunc ();

myMsgFac () ("getAttrMsg", "mesgPrintNumber");

if (checkMsgExtNum (messageNumber))
apiGet (
mesgPrintMunber,
"mesgPrintMunber",
myMsgFac ().displayExternalNumber (messageNumber));
}
d197 57
a253 57
WitBoolean quiet,
int        messageNumber,
WitBoolean mesgStopRunning)
{
if (quiet)
myApiMgr_->skipCallMsg       ();

myApiMgr_->   allowPreInit      ();
myApiMgr_->   allowExtOptActive ();
myApiMgr_->   startInnerFunc    ();

myInputID ()->setMyAttName ("mesgStopRunning");

if (    messageNumber != WitINFORMATIONAL_MESSAGES
and messageNumber != WitWARNING_MESSAGES)
{
if (myMsgFac ().isExtNumOfLevel (messageNumber))
{
if (not quiet)
{
myMsgFac () ("setMsgTypeBoolAttrMsg",
"mesgStopRunning",
myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
mesgStopRunning);

if (mesgStopRunning)
myMsgFac () ("setMsgType2ndBoolAttrMsg",
"mesgThrowErrorExc",
myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
"mesgStopRunning");
}

myMsgFac ().setStopRunningByLevel (
messageNumber,
asaBool (mesgStopRunning));
}
else if (checkMsgExtNum (messageNumber))
{
if (not quiet)
{
myMsgFac () (
"setMsgBoolAttrMsg",
"mesgStopRunning",
messageNumber,
mesgStopRunning);

if (mesgStopRunning)
if (myMsgFac ().throwErrorExc (messageNumber))
myMsgFac () ("setMsg2ndBoolAttrMsg",
"mesgThrowErrorExc",
messageNumber,
"mesgStopRunning");
}

myMsgFac ().setStopRunning (messageNumber, asaBool (mesgStopRunning));
}
}
d255 2
a256 2
myInputID ()->setMyAttName (NULL);
}
d261 13
a273 13
int          messageNumber,
WitBoolean * mesgStopRunning)
{
myApiMgr_->startInnerFunc ();

myMsgFac () ("getAttrMsg", "mesgStopRunning");

if (checkMsgExtNum (messageNumber))
apiGet (
mesgStopRunning,
"mesgStopRunning",
myMsgFac ().stopRunning (messageNumber));
}
d278 60
a337 60
WitBoolean quiet,
int        messageNumber,
WitBoolean mesgThrowErrorExc)
{
if (quiet)
myApiMgr_->skipCallMsg       ();

myApiMgr_->   allowPreInit      ();
myApiMgr_->   allowExtOptActive ();
myApiMgr_->   startInnerFunc    ();

myInputID ()->setMyAttName ("mesgThrowErrorExc");

if (not ERROR_EXC_AVAIL)
myMsgFac () ("errorExcNotAvailSmsg");

if (    messageNumber != WitINFORMATIONAL_MESSAGES
and messageNumber != WitWARNING_MESSAGES)
{
if (myMsgFac ().isExtNumOfLevel (messageNumber))
{
if (not quiet)
{
myMsgFac () ("setMsgTypeBoolAttrMsg",
"mesgThrowErrorExc",
myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
mesgThrowErrorExc);

if (mesgThrowErrorExc)
myMsgFac () ("setMsgType2ndBoolAttrMsg",
"mesgStopRunning",
myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
"mesgThrowErrorExc");
}

myMsgFac ().setThrowErrorExcByLevel (
messageNumber,
asaBool (mesgThrowErrorExc));
}
else if (checkMsgExtNum (messageNumber))
{
if (not quiet)
{
myMsgFac () ("setMsgBoolAttrMsg",
"mesgThrowErrorExc",
messageNumber,
mesgThrowErrorExc);

if (mesgThrowErrorExc)
if (myMsgFac ().stopRunning (messageNumber))
myMsgFac () ("setMsg2ndBoolAttrMsg",
"mesgStopRunning",
messageNumber,
"mesgThrowErrorExc");
}

myMsgFac ().
setThrowErrorExc (messageNumber, asaBool (mesgThrowErrorExc));
}
}
d339 2
a340 2
myInputID ()->setMyAttName (NULL);
}
d345 13
a357 13
int          messageNumber,
WitBoolean * mesgThrowErrorExc)
{
myApiMgr_->startInnerFunc ();

myMsgFac () ("getAttrMsg", "mesgThrowErrorExc");

if (checkMsgExtNum (messageNumber))
apiGet (
mesgThrowErrorExc,
"mesgThrowErrorExc",
myMsgFac ().throwErrorExc (messageNumber));
}
d362 40
a401 12
WitBoolean quiet,
int        messageNumber,
int        mesgTimesPrint)
{
if (quiet)
myApiMgr_->skipCallMsg       ();

myApiMgr_->   allowPreInit      ();
myApiMgr_->   allowExtOptActive ();
myApiMgr_->   startInnerFunc    ();

myInputID ()->setMyAttName ("mesgTimesPrint");
d403 2
a404 3
int maxTimesIssued;
//
// Same as mesgTimesPrint, but negative == infinity.
d406 2
a407 29
// Check range of mesgTimesPrint
//
if (mesgTimesPrint < 0 or mesgTimesPrint > UCHAR_MAX)
myMsgFac () ("intLowEqUpEqImmSmsg", mesgTimesPrint, 0, UCHAR_MAX);

maxTimesIssued =
(mesgTimesPrint == UCHAR_MAX)?
-1:
mesgTimesPrint;

if (myMsgFac ().isExtNumOfLevel (messageNumber))
{
if (not quiet)
myMsgFac () ("chgMsgsTimesPrintSm",
myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
mesgTimesPrint);

myMsgFac ().setMaxTimesIssuedByLevel (messageNumber, maxTimesIssued);
}
else if (checkMsgExtNum (messageNumber))
{
if (not quiet)
myMsgFac () ("chgMsgTimesPrintSm", messageNumber, mesgTimesPrint);

myMsgFac ().setMaxTimesIssued (messageNumber, maxTimesIssued);
}

myInputID ()->setMyAttName (NULL);
}
d412 23
a434 23
int   messageNumber,
int * mesgTimesPrint)
{
int maxTimesIssued;
//
// Same as mesgTimesPrint, but negative == infinity.

myApiMgr_->startInnerFunc ();

myMsgFac () ("getAttrMsg", "mesgTimesPrint");

if (checkMsgExtNum (messageNumber))
{
maxTimesIssued = myMsgFac ().maxTimesIssued (messageNumber);

apiGet (
mesgTimesPrint,
"mesgTimesPrint",
(maxTimesIssued < 0)?
UCHAR_MAX:
maxTimesIssued);
}
}
d439 2
a440 2
{
myApiMgr_->startInnerFunc ();
d442 2
a443 2
if (not DEVELOPMENT)
myMsgFac () ("funcNotAvailSmsg", "witListUnissuedMsgs");
d445 2
a446 2
myMsgFac ().listUnissuedMsgs ();
}
d451 2
a452 2
{
WitMsgID theMsgID;
d454 6
a459 6
theMsgID =
(theExtNum == WitINFORMATIONAL_MESSAGES)? "informationalMsgFrag":
(theExtNum == WitWARNING_MESSAGES)?       "warningMsgFrag":
(theExtNum == WitSEVERE_MESSAGES)?        "severeMsgFrag":
(theExtNum == WitFATAL_MESSAGES)?         "fatalMsgFrag":
NULL;
d461 1
a461 1
witAssert (theMsgID != NULL);
d463 2
a464 2
return theMsgID;
}
d469 2
a470 2
{
bool theExtNumIsValid;
d472 1
a472 1
theExtNumIsValid = myMsgFac ().isExtNumOfMsg (theExtNum);
d474 2
a475 2
if (not theExtNumIsValid)
myMsgFac () ("invalidExtNumWmsg", apiFuncName (), theExtNum);
d477 2
a478 2
return theExtNumIsValid;
}
@


1.39
log
@When comparing a file name to WitSTDOUT, changed from pointer equality
to string equality.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d26 2
a27 2
   {
   myApiMgr_->startInnerFunc ();
d29 1
a29 1
   apiGet (fileP, "fileP", myMsgFac ().myFile ());
d31 2
a32 2
   myMsgFac () ("getAttrMsg", "mesgFile");
   }
d37 12
a48 41
      WitBoolean   quiet,
      const char * newFileName)
   {
   FILE * tempFile;
   int    fcloseResult;

   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgFileName");

      // open new message file
      //
   if (equalCstrings (newFileName, WitSTDOUT))
      {
      tempFile = stdout;
      }
   else
      tempFile =
         mySession_->
            openFile (newFileName, myMsgFac ().accessMode ().myCstring ());

   if (not quiet)
      myMsgFac () ("setStringAttrMsg",
         "mesgFileName",
         myMsgFac ().fileName (),
         newFileName);

      // close old message file
      //
   if (myMsgFac ().fileName () != WitSTDOUT)
      {
      fcloseResult = fclose (myMsgFac ().myFile ());

      if (fcloseResult != 0)
         myMsgFac () ("fcloseSmsg", myMsgFac ().fileName ());
      }
d50 1
a50 1
   myMsgFac ().setMyFile (tempFile, newFileName);
d52 31
a82 2
   myInputID ()->setMyAttName (NULL);
   }
d87 2
a88 2
   {
   myApiMgr_->startInnerFunc ();
d90 1
a90 1
   apiGet (mesgFileName, "mesgFileName", myMsgFac ().fileName ());
d92 2
a93 2
   myMsgFac () ("getAttrMsg", "mesgFileName");
   }
d98 17
a114 17
      WitBoolean   quiet,
      const char * newMode )
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgFileAccessMode");

   if (not quiet)
      myMsgFac () ("setStringAttrMsg",
         "mesgFileAccessMode",
         myMsgFac ().accessMode (),
         newMode);
d116 1
a116 1
   myMsgFac ().setAccessMode (newMode);
d118 2
a119 2
   myInputID ()->setMyAttName (NULL);
   }
d124 2
a125 2
   {
   myApiMgr_->startInnerFunc ();
d127 1
a127 1
   apiGet (mesgFileAccessMode, "mesgFileAccessMode", myMsgFac ().accessMode ());
d129 2
a130 2
   myMsgFac () ("getAttrMsg", "mesgFileAccessMode");
   }
d135 38
a172 38
      WitBoolean quiet,
      int        messageNumber,
      WitBoolean mesgPrintMunber)
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgPrintNumber");

   if (myMsgFac ().isExtNumOfLevel (messageNumber))
      {
      if (not quiet)
         myMsgFac () ("setMsgTypeBoolAttrMsg",
            "mesgPrintNumber",
            myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
            mesgPrintMunber);

      myMsgFac ().setDisplayExternalNumberByLevel (
         messageNumber,
         asaBool (mesgPrintMunber));
      }
   else if (checkMsgExtNum (messageNumber))
      {
      if (not quiet)
         myMsgFac () (
            "setMsgBoolAttrMsg",
            "mesgPrintNumber",
            messageNumber,
            mesgPrintMunber);

      myMsgFac ().setDisplayExternalNumber (
         messageNumber,
         asaBool (mesgPrintMunber));
      }
d174 2
a175 2
   myInputID ()->setMyAttName (NULL);
   }
d180 13
a192 13
      int          messageNumber,
      WitBoolean * mesgPrintMunber)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () ("getAttrMsg", "mesgPrintNumber");

   if (checkMsgExtNum (messageNumber))
      apiGet (
         mesgPrintMunber,
         "mesgPrintMunber",
         myMsgFac ().displayExternalNumber (messageNumber));
   }
d197 57
a253 57
      WitBoolean quiet,
      int        messageNumber,
      WitBoolean mesgStopRunning)
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgStopRunning");

   if (    messageNumber != WitINFORMATIONAL_MESSAGES
       and messageNumber != WitWARNING_MESSAGES)
      {
      if (myMsgFac ().isExtNumOfLevel (messageNumber))
         {
         if (not quiet)
            {
            myMsgFac () ("setMsgTypeBoolAttrMsg",
               "mesgStopRunning",
               myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
               mesgStopRunning);

            if (mesgStopRunning)
               myMsgFac () ("setMsgType2ndBoolAttrMsg",
                  "mesgThrowErrorExc",
                  myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
                  "mesgStopRunning");
            }

         myMsgFac ().setStopRunningByLevel (
            messageNumber,
            asaBool (mesgStopRunning));
         }
      else if (checkMsgExtNum (messageNumber))
         {
         if (not quiet)
            {
            myMsgFac () (
               "setMsgBoolAttrMsg",
               "mesgStopRunning",
               messageNumber,
               mesgStopRunning);

            if (mesgStopRunning)
               if (myMsgFac ().throwErrorExc (messageNumber))
                  myMsgFac () ("setMsg2ndBoolAttrMsg",
                     "mesgThrowErrorExc",
                     messageNumber,
                     "mesgStopRunning");
            }

         myMsgFac ().setStopRunning (messageNumber, asaBool (mesgStopRunning));
         }
      }
d255 2
a256 2
   myInputID ()->setMyAttName (NULL);
   }
d261 13
a273 13
      int          messageNumber,
      WitBoolean * mesgStopRunning)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () ("getAttrMsg", "mesgStopRunning");

   if (checkMsgExtNum (messageNumber))
      apiGet (
         mesgStopRunning,
          "mesgStopRunning",
          myMsgFac ().stopRunning (messageNumber));
   }
d278 60
a337 60
      WitBoolean quiet,
      int        messageNumber,
      WitBoolean mesgThrowErrorExc)
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgThrowErrorExc");

   if (not ERROR_EXC_AVAIL)
      myMsgFac () ("errorExcNotAvailSmsg");

   if (    messageNumber != WitINFORMATIONAL_MESSAGES
       and messageNumber != WitWARNING_MESSAGES)
      {
      if (myMsgFac ().isExtNumOfLevel (messageNumber))
         {
         if (not quiet)
            {
            myMsgFac () ("setMsgTypeBoolAttrMsg",
               "mesgThrowErrorExc",
               myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
               mesgThrowErrorExc);

            if (mesgThrowErrorExc)
               myMsgFac () ("setMsgType2ndBoolAttrMsg",
                  "mesgStopRunning",
                  myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
                  "mesgThrowErrorExc");
            }

         myMsgFac ().setThrowErrorExcByLevel (
            messageNumber,
            asaBool (mesgThrowErrorExc));
         }
      else if (checkMsgExtNum (messageNumber))
         {
         if (not quiet)
            {
            myMsgFac () ("setMsgBoolAttrMsg",
               "mesgThrowErrorExc",
               messageNumber,
               mesgThrowErrorExc);

            if (mesgThrowErrorExc)
               if (myMsgFac ().stopRunning (messageNumber))
                  myMsgFac () ("setMsg2ndBoolAttrMsg",
                     "mesgStopRunning",
                     messageNumber,
                     "mesgThrowErrorExc");
            }

         myMsgFac ().
            setThrowErrorExc (messageNumber, asaBool (mesgThrowErrorExc));
         }
      }
d339 2
a340 2
   myInputID ()->setMyAttName (NULL);
   }
d345 13
a357 13
      int          messageNumber,
      WitBoolean * mesgThrowErrorExc)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () ("getAttrMsg", "mesgThrowErrorExc");

   if (checkMsgExtNum (messageNumber))
      apiGet (
         mesgThrowErrorExc,
          "mesgThrowErrorExc",
          myMsgFac ().throwErrorExc (messageNumber));
   }
d362 12
a373 40
      WitBoolean quiet,
      int        messageNumber,
      int        mesgTimesPrint)
   {
   if (quiet)
      myApiMgr_->skipCallMsg       ();

   myApiMgr_->   allowPreInit      ();
   myApiMgr_->   allowExtOptActive ();
   myApiMgr_->   startInnerFunc    ();

   myInputID ()->setMyAttName ("mesgTimesPrint");

   int maxTimesIssued;
      //
      // Same as mesgTimesPrint, but negative == infinity.

      // Check range of mesgTimesPrint
      //
   if (mesgTimesPrint < 0 or mesgTimesPrint > UCHAR_MAX)
      myMsgFac () ("intLowEqUpEqImmSmsg", mesgTimesPrint, 0, UCHAR_MAX);

   maxTimesIssued =
      (mesgTimesPrint == UCHAR_MAX)?
         -1:
         mesgTimesPrint;

   if (myMsgFac ().isExtNumOfLevel (messageNumber))
      {
      if (not quiet)
         myMsgFac () ("chgMsgsTimesPrintSm",
            myMsgFac ().myFrag (levelExtNumFragID (messageNumber)),
            mesgTimesPrint);

      myMsgFac ().setMaxTimesIssuedByLevel (messageNumber, maxTimesIssued);
      }
   else if (checkMsgExtNum (messageNumber))
      {
      if (not quiet)
         myMsgFac () ("chgMsgTimesPrintSm", messageNumber, mesgTimesPrint);
d375 3
a377 2
      myMsgFac ().setMaxTimesIssued (messageNumber, maxTimesIssued);
      }
d379 29
a407 2
   myInputID ()->setMyAttName (NULL);
   }
d412 23
a434 23
      int   messageNumber,
      int * mesgTimesPrint)
   {
   int maxTimesIssued;
      //
      // Same as mesgTimesPrint, but negative == infinity.

   myApiMgr_->startInnerFunc ();

   myMsgFac () ("getAttrMsg", "mesgTimesPrint");

   if (checkMsgExtNum (messageNumber))
      {
      maxTimesIssued = myMsgFac ().maxTimesIssued (messageNumber);

      apiGet (
         mesgTimesPrint,
         "mesgTimesPrint",
         (maxTimesIssued < 0)?
            UCHAR_MAX:
            maxTimesIssued);
      }
   }
d439 2
a440 2
   {
   myApiMgr_->startInnerFunc ();
d442 2
a443 2
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", "witListUnissuedMsgs");
d445 2
a446 2
   myMsgFac ().listUnissuedMsgs ();
   }
d451 2
a452 2
   {
   WitMsgID theMsgID;
d454 6
a459 6
   theMsgID =
      (theExtNum == WitINFORMATIONAL_MESSAGES)? "informationalMsgFrag":
      (theExtNum == WitWARNING_MESSAGES)?       "warningMsgFrag":
      (theExtNum == WitSEVERE_MESSAGES)?        "severeMsgFrag":
      (theExtNum == WitFATAL_MESSAGES)?         "fatalMsgFrag":
                                                NULL;
d461 1
a461 1
   witAssert (theMsgID != NULL);
d463 2
a464 2
   return theMsgID;
   }
d469 2
a470 2
   {
   bool theExtNumIsValid;
d472 1
a472 1
   theExtNumIsValid = myMsgFac ().isExtNumOfMsg (theExtNum);
d474 2
a475 2
   if (not theExtNumIsValid)
      myMsgFac () ("invalidExtNumWmsg", apiFuncName (), theExtNum);
d477 2
a478 2
   return theExtNumIsValid;
   }
@


1.38
log
@Fixed bug:
   WIT would crash when changing the message file name from a name other than
   stdout.
@
text
@d54 2
a55 1
   if (newFileName == WitSTDOUT)
d57 1
@


1.37
log
@Removed many conversions of string constant to char *.
@
text
@d41 1
a60 8
      // close old message file
      //
   if (myMsgFac ().fileName () != WitSTDOUT)
      if (fclose (myMsgFac ().myFile ()) != 0)
         myMsgFac () ("fcloseSmsg", myMsgFac ().fileName ());

      // No more possible errors, so display message describing change
      //
d67 10
@


1.36
log
@witCopy<Object>Data
@
text
@d49 1
a49 1
   myInputID ()->setMyAttr ("mesgFileName");
d76 1
a76 1
   myInputID ()->setMyAttr (NULL);
d103 1
a103 1
   myInputID ()->setMyAttr ("mesgFileAccessMode");
d113 1
a113 1
   myInputID ()->setMyAttr (NULL);
d141 1
a141 1
   myInputID ()->setMyAttr ("mesgPrintNumber");
d169 1
a169 1
   myInputID ()->setMyAttr (NULL);
d203 1
a203 1
   myInputID ()->setMyAttr ("mesgStopRunning");
d250 1
a250 1
   myInputID ()->setMyAttr (NULL);
d284 1
a284 1
   myInputID ()->setMyAttr ("mesgThrowErrorExc");
d334 1
a334 1
   myInputID ()->setMyAttr (NULL);
d368 1
a368 1
   myInputID ()->setMyAttr ("mesgTimesPrint");
d401 1
a401 1
   myInputID ()->setMyAttr (NULL);
@


1.35
log
@External opt implosion.
@
text
@a432 9
void WitRun::witTestFatalMesg ()
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () ("witTestFatalMesgFmsg");
   }

//------------------------------------------------------------------------------

@


1.34
log
@App controlled opt implosion.
@
text
@d27 2
d42 7
a50 3
   if (not quiet)
      myMsgFac () ("witFuncCalled", apiFuncName ());

d83 2
d96 7
a105 3
      {
      myMsgFac () ("witFuncCalled", apiFuncName ());

a109 1
      }
d120 2
d134 7
a142 3
   if (not quiet)
      myMsgFac () ("witFuncCalled", apiFuncName ());

d178 2
d196 7
a204 3
   if (not quiet)
      myMsgFac () ("witFuncCalled", apiFuncName ());

d259 2
d277 7
a285 3
   if (not quiet)
      myMsgFac () ("witFuncCalled", apiFuncName ());

d343 2
d361 7
a373 3
   if (not quiet)
      myMsgFac () ("witFuncCalled", apiFuncName ());

d414 2
d435 2
d444 2
d454 1
a454 1
const char * WitRun::levelExtNumFragID (int theExtNum) const
d472 1
a472 1
bool WitRun::checkMsgExtNum (int theExtNum) const
@


1.33
log
@App controlled opt implosion.
@
text
@a324 2
#include <OptImp.h>

a348 12
   if (messageNumber == 602)
      if (mySession_->active ())
         {
         if (myMsgFac ().maxTimesIssued (602) == 103)
            if (mesgTimesPrint == 104)
               myOptImploder ()->setActive (true);

         if (myMsgFac ().maxTimesIssued (602) == 104)
            if (mesgTimesPrint == 103)
               myOptImploder ()->setActive (false);
         }

d406 1
a406 1
      myMsgFac () ("witListUnissuedMsgsSmsg");
@


1.32
log
@App controlled opt implosion.
@
text
@d352 10
a361 9
      {
      if (myMsgFac ().maxTimesIssued (602) == 103)
         if (mesgTimesPrint == 104)
            myOptImploder ()->setActive (true);

      if (myMsgFac ().maxTimesIssued (602) == 104)
         if (mesgTimesPrint == 103)
            myOptImploder ()->setActive (false);
      }
@


1.31
log
@App controlled opt implosion.
@
text
@d325 2
d351 11
@


1.30
log
@App controlled opt implosion.
@
text
@a26 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a37 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a76 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a87 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a108 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a120 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a160 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a176 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a235 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a251 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a313 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a329 4
   startInnerApiFunc (
      WitInitState  ::any,
      WitOptImpState::any);

a374 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a397 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a404 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

@


1.29
log
@Updated the copyright date on all source files.
@
text
@d27 4
d42 4
d85 4
d100 4
d125 4
d141 4
d185 4
d205 4
d268 4
d288 4
d354 4
d374 4
d423 4
d450 4
d461 4
@


1.28
log
@[shared-resource pegging]
Update to error exceptions.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.27
log
@Error exceptions.
@
text
@d257 2
a258 7
#ifdef NO_ERROR_EXC

   myMsgFac () ("errorExcNotAvailSmsg");
      //
      // The error exception capability is not available on this platform.

#endif
@


1.26
log
@Made the WitErrorExc capability unavailable on MS Visual C++ V6.
@
text
@d259 1
a259 1
   myMsgFac () ("throwErrorExcNotAllowedSmsg");
d261 1
a261 1
      // The ErrorExc capability is not available on this platform.
@


1.25
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d257 8
@


1.24
log
@Updated WIT's exception throwing capability.
@
text
@a22 2
#include <errno.h>

d50 3
a52 10
      {
      tempFile = fopen (newFileName, myMsgFac ().accessMode ().myCstring ());

      if (not tempFile)
         myMsgFac () ("fopenSmsg",
            newFileName,
            myMsgFac ().accessMode (),
            errno,
            strerror (errno));
      }
d395 1
a395 1
   stronglyAssert (false);
@


1.23
log
@[multi-thread]
@
text
@d205 1
a205 1
                  "mesgThrowException",
d225 1
a225 1
               if (myMsgFac ().throwException (messageNumber))
d227 1
a227 1
                     "mesgThrowException",
d256 1
a256 1
void WitRun::witSetMesgThrowException (
d259 1
a259 1
      WitBoolean mesgThrowException)
d261 1
a261 1
   myInputID ()->setMyAttr ("mesgThrowException");
d274 1
a274 1
               "mesgThrowException",
d276 1
a276 1
               mesgThrowException);
d278 1
a278 1
            if (mesgThrowException)
d282 1
a282 1
                  "mesgThrowException");
d285 1
a285 1
         myMsgFac ().setThrowExceptionByLevel (
d287 1
a287 1
            asaBool (mesgThrowException));
d294 1
a294 1
               "mesgThrowException",
d296 1
a296 1
               mesgThrowException);
d298 1
a298 1
            if (mesgThrowException)
d303 1
a303 1
                     "mesgThrowException");
d307 1
a307 1
            setThrowException (messageNumber, asaBool (mesgThrowException));
d316 1
a316 1
void WitRun::witGetMesgThrowException (
d318 1
a318 1
      WitBoolean * mesgThrowException)
d320 1
a320 1
   myMsgFac () ("getAttrMsg", "mesgThrowException");
d324 3
a326 3
         mesgThrowException,
          "mesgThrowException",
          myMsgFac ().throwException (messageNumber));
@


1.22
log
@[multi-thread]
@
text
@d404 1
a404 1
   myMsgFac () ("testFmsg");
@


1.21
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d60 1
a60 1
            WitNonClass::strerror (errno));
@


1.20
log
@[multi-threads]
@
text
@a16 1
#include <ProEpilog.h>
d27 1
a27 1
WitReturnCode WitRun::witGetMesgFile (FILE * * fileP)
a28 2
   PROLOG ("witGetMesgFile");

d31 1
a31 4
   if (myApiMgr ()->calledByApp ())
      myMsgFac () ("getAttrMsg", "mesgFile");

   EPILOG;
d36 1
a36 1
WitReturnCode WitRun::witSetMesgFileName (
a41 2
   QUIET_PROLOG ("witSetMesgFileName");

a79 2

   EPILOG;
d84 1
a84 1
WitReturnCode WitRun::witGetMesgFileName (char * * mesgFileName)
a85 2
   PROLOG ("witGetMesgFileName");

d88 1
a88 4
   if (myApiMgr ()->calledByApp ())
      myMsgFac () ("getAttrMsg", "mesgFileName");

   EPILOG;
d93 1
a93 1
WitReturnCode WitRun::witSetMesgFileAccessMode (
a96 2
   QUIET_PROLOG ("witSetMesgFileAccessMode");

a111 2

   EPILOG;
d116 1
a116 1
WitReturnCode WitRun::witGetMesgFileAccessMode (char * * mesgFileAccessMode)
a117 2
   PROLOG ("witGetMesgFileAccessMode");

d120 1
a120 4
   if (myApiMgr ()->calledByApp ())
      myMsgFac () ("getAttrMsg", "mesgFileAccessMode");

   EPILOG;
d125 1
a125 1
WitReturnCode WitRun::witSetMesgPrintNumber (
a129 2
   QUIET_PROLOG ("witSetMesgPrintNumber");

a161 2

   EPILOG;
d166 1
a166 1
WitReturnCode WitRun::witGetMesgPrintNumber (
d170 1
a170 4
   PROLOG ("witGetMesgPrintNumber");

   if (myApiMgr ()->calledByApp ())
      myMsgFac () ("getAttrMsg", "mesgPrintNumber");
a176 2

   EPILOG;
d181 1
a181 1
WitReturnCode WitRun::witSetMesgStopRunning (
a185 2
   QUIET_PROLOG ("witSetMesgStopRunning");

a236 2

   EPILOG;
d241 1
a241 1
WitReturnCode WitRun::witGetMesgStopRunning (
d245 1
a245 4
   PROLOG ("witGetMesgStopRunning");

   if (myApiMgr ()->calledByApp())
      myMsgFac () ("getAttrMsg", "mesgStopRunning");
a251 2

   EPILOG;
d256 1
a256 1
WitReturnCode WitRun::witSetMesgThrowException (
a260 2
   QUIET_PROLOG ("witSetMesgThrowException");

a311 2

   EPILOG;
d316 1
a316 1
WitReturnCode WitRun::witGetMesgThrowException (
d320 1
a320 4
   PROLOG ("witGetMesgThrowException");

   if (myApiMgr ()->calledByApp())
      myMsgFac () ("getAttrMsg", "mesgThrowException");
a326 2

   EPILOG;
d331 1
a331 1
WitReturnCode WitRun::witSetMesgTimesPrint (
a335 2
   QUIET_PROLOG ("witSetMesgTimesPrint");

a372 2

   EPILOG;
d377 1
a377 1
WitReturnCode WitRun::witGetMesgTimesPrint (
a380 2
   QUIET_PROLOG ("witGetMesgTimesPrint");

d385 1
a385 2
   if (myApiMgr ()->calledByApp ())
      myMsgFac () ("getAttrMsg", "mesgTimesPrint");
a397 2

   EPILOG;
d402 1
a402 1
WitReturnCode WitRun::witTestFatalMesg ()
a403 2
   PROLOG ("witTestFatalMesg");

a404 2

   EPILOG;
d409 1
a409 1
WitReturnCode WitRun::witListUnissuedMsgs ()
a410 2
   PROLOG ("witListUnissuedMsgs");

a414 2

   EPILOG;
@


1.19
log
@[exceptions]
@
text
@d34 1
a34 1
   if (myApiMgr ()->applicationCalled ())
d100 1
a100 1
   if (myApiMgr ()->applicationCalled ())
d141 1
a141 1
   if (myApiMgr ()->applicationCalled ())
d200 1
a200 1
   if (myApiMgr ()->applicationCalled ())
d284 1
a284 1
   if (myApiMgr ()->applicationCalled())
d368 1
a368 1
   if (myApiMgr ()->applicationCalled())
d442 1
a442 1
   if (myApiMgr ()->applicationCalled ())
@


1.18
log
@[exceptions]
@
text
@d164 1
a164 1
         myMsgFac () ("chgMsgsAttribBitSm",
d177 1
a177 1
            "chgMsgAttribBitSm",
d232 2
a233 1
            myMsgFac () ("chgMsgsAttribBitSm",
d238 8
a245 1
         myMsgFac ().setStopOnAbortByLevel (
d252 1
d254 1
a254 1
               "chgMsgAttribBitSm",
d259 9
a267 1
         myMsgFac ().setStopOnAbort (messageNumber, asaBool (mesgStopRunning));
d291 1
a291 1
          myMsgFac ().stopOnAbort (messageNumber));
d316 2
a317 1
            myMsgFac () ("chgMsgsAttribBitSm",
d322 7
d336 2
a337 2
            myMsgFac () (
               "chgMsgAttribBitSm",
d342 8
@


1.17
log
@[exceptions]
@
text
@d17 1
d19 1
d50 1
a50 1
   myInputId ()->setMyAttr ("mesgFileName");
d87 1
a87 1
   myInputId ()->setMyAttr (NULL);
d114 1
a114 1
   myInputId ()->setMyAttr ("mesgFileAccessMode");
d128 1
a128 1
   myInputId ()->setMyAttr (NULL);
d156 1
a156 1
   myInputId ()->setMyAttr ("mesgPrintNumber");
d187 1
a187 1
   myInputId ()->setMyAttr (NULL);
d221 1
a221 1
   myInputId ()->setMyAttr ("mesgStopRunning");
d254 1
a254 1
   myInputId ()->setMyAttr (NULL);
d288 1
a288 1
   myInputId ()->setMyAttr ("mesgThrowException");
d322 1
a322 1
   myInputId ()->setMyAttr (NULL);
d356 1
a356 1
   myInputId ()->setMyAttr ("mesgTimesPrint");
d392 1
a392 1
   myInputId ()->setMyAttr (NULL);
@


1.16
log
@[exceptions]
@
text
@d279 68
@


1.15
log
@[exceptions]
@
text
@d62 1
a62 1
         myMsgFac () ("fopenError",
d73 1
a73 1
         myMsgFac () ("fcloseError", myMsgFac ().fileName ());
@


1.14
log
@Added:
   WitFATAL_RC
   witTestFatalMesg
@
text
@d46 1
a46 1
   SHORT_PROLOG ("witSetMesgFileName", false);
d110 1
a110 1
   SHORT_PROLOG ("witSetMesgFileAccessMode", false);
d152 1
a152 1
   SHORT_PROLOG ("witSetMesgPrintNumber", false);
d217 1
a217 1
   SHORT_PROLOG ("witSetMesgStopRunning", false);
d284 1
a284 1
   SHORT_PROLOG ("witSetMesgTimesPrint", false);
d333 1
a333 1
   SHORT_PROLOG ("witGetMesgTimesPrint", false);
@


1.13
log
@Minor change.
@
text
@d359 11
d392 1
@


1.12
log
@Double Precision.
@
text
@a17 1
#include <wit.h>
@


1.11
log
@Double Precision.
@
text
@d170 1
a170 1
         mesgPrintMunber);
d181 3
a183 1
      myMsgFac ().setDisplayExternalNumber (messageNumber, mesgPrintMunber);
d236 3
a238 1
         myMsgFac ().setStopOnAbortByLevel (messageNumber, mesgStopRunning);
d249 1
a249 1
         myMsgFac ().setStopOnAbort (messageNumber, mesgStopRunning);
@


1.10
log
@Continued implementation of PIP.
@
text
@d42 1
a42 1
      witBoolean   quiet,
d108 1
a108 1
      witBoolean   quiet,
d149 1
a149 1
      witBoolean quiet,
d151 1
a151 1
      witBoolean mesgPrintMunber)
d193 1
a193 1
      witBoolean * mesgPrintMunber)
d212 1
a212 1
      witBoolean quiet,
d214 1
a214 1
      witBoolean mesgStopRunning)
d258 1
a258 1
      witBoolean * mesgStopRunning)
d277 1
a277 1
      witBoolean quiet,
@


1.9
log
@Continued implementation of PIP.
@
text
@d67 1
a67 1
            WitUtil::strerror (errno));
@


1.8
log
@Internal changes.
@
text
@d67 1
a67 1
            strerror (errno));
@


1.7
log
@Internal changes.
@
text
@d51 1
a51 1
   if (! quiet)
d62 1
a62 1
      if (! tempFile)
d78 1
a78 1
   if (! quiet)
d115 1
a115 1
   if (! quiet)
d157 1
a157 1
   if (! quiet)
d162 1
a162 1
      if (! quiet)
d174 1
a174 1
      if (! quiet)
d220 1
a220 1
   if (! quiet)
d223 2
a224 2
   if (  messageNumber != WitINFORMATIONAL_MESSAGES &&
         messageNumber != WitWARNING_MESSAGES)
d228 1
a228 1
         if (! quiet)
d238 1
a238 1
         if (! quiet)
d289 1
a289 1
   if (! quiet)
d294 1
a294 1
   if (mesgTimesPrint < 0 || mesgTimesPrint > UCHAR_MAX)
d304 1
a304 1
      if (! quiet)
d313 1
a313 1
      if (! quiet)
d360 1
a360 1
   if (! DEVELOPMENT)
d393 1
a393 1
   if (! theExtNumIsValid)
@


1.6
log
@Continued implementation of single-source.
@
text
@d42 1
a42 1
      WitBoolean   quiet,
d47 1
a47 1
   SHORT_PROLOG ("witSetMesgFileName", witFALSE);
d108 1
a108 1
      WitBoolean   quiet,
d111 1
a111 1
   SHORT_PROLOG ("witSetMesgFileAccessMode", witFALSE);
d149 1
a149 1
      WitBoolean quiet,
d151 1
a151 1
      WitBoolean mesgPrintMunber)
d153 1
a153 1
   SHORT_PROLOG ("witSetMesgPrintNumber", witFALSE);
d193 1
a193 1
      WitBoolean * mesgPrintMunber)
d212 1
a212 1
      WitBoolean quiet,
d214 1
a214 1
      WitBoolean mesgStopRunning)
d216 1
a216 1
   SHORT_PROLOG ("witSetMesgStopRunning", witFALSE);
d257 2
a258 2
      int    messageNumber,
      WitBoolean * mesgStopRunning)
d277 1
a277 1
      WitBoolean quiet,
d281 1
a281 1
   SHORT_PROLOG ("witSetMesgTimesPrint", witFALSE);
d330 1
a330 1
   SHORT_PROLOG ("witGetMesgTimesPrint", witFALSE);
d387 1
a387 1
WitBoolean WitRun::checkMsgExtNum (int theExtNum) const
d389 1
a389 1
   WitBoolean theExtNumIsValid;
@


1.5
log
@Continued implementation of object iteration.
@
text
@d19 1
d165 1
a165 1
            myMsgFac ()[levelExtNumFragID (messageNumber)],
d231 1
a231 1
               myMsgFac ()[levelExtNumFragID (messageNumber)],
d306 1
a306 1
            myMsgFac ()[levelExtNumFragID (messageNumber)],
@


1.4
log
@Began implementation of object iteration.
@
text
@d18 1
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d18 2
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d63 1
a63 1
            WitUtil::strerror (errno));
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.149;
access;
symbols
	sce_5_01_20080919:1.127
	latest_sce_4_20_20060523:1.114.0.2
	sce_4_20_20060523:1.114
	latest_sce4_20_OSL:1.113.0.2
	sce_4_20_OSL:1.113
	sce_410_withVa:1.110
	sce_4_05_20040511:1.100
	sce_4_00_20040201:1.97
	nextGenBranch:1.90.0.2
	nextGenRoot:1.90
	sce_3_30_20030627:1.90
	EndRw-branch:1.87.0.4
	Root-of-EndRw:1.87
	rwToStl:1.87.0.2
	latest_sce_3_10_20010924:1.77.0.2
	sce_3_10_20010924:1.77
	latest_sce_3_00_20010601:1.57.0.2
	sce_3_00_20010601:1.57
	latest_sce_2_31_20010308:1.35.0.2
	sce_2_31_20010308:1.35
	latest_sce_2_31_20001003:1.13.0.2
	sce_2_31_20001003:1.13
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.149
date	2011.09.28.23.49.24;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2011.09.24.00.27.43;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2011.08.30.20.17.32;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2010.09.24.18.17.21;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2010.09.24.15.46.14;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2010.09.24.00.16.25;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2010.09.22.20.21.52;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2010.09.21.21.19.13;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2010.09.13.21.13.19;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2010.09.10.23.22.43;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2010.09.10.23.17.46;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2010.09.10.20.12.06;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2010.09.10.16.03.49;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2010.09.07.23.50.33;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2010.09.07.19.52.01;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2010.09.07.16.38.58;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2010.09.02.23.09.22;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2010.09.02.22.06.00;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2010.09.02.20.16.24;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2010.09.02.18.58.24;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2010.09.01.20.25.24;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.17.22.04.44;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2007.11.12.20.27.37;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2007.11.12.16.30.11;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2007.11.09.00.40.46;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2007.11.08.19.16.39;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2007.05.10.20.08.49;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2007.02.28.20.04.57;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2007.02.27.21.03.04;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2007.02.27.19.59.31;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2007.02.10.00.08.13;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2007.02.08.22.47.34;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2006.12.27.20.19.29;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2006.05.02.17.33.59;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2006.01.18.21.42.59;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2005.09.30.22.50.00;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2005.03.28.20.14.35;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2005.02.08.22.33.25;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2005.02.07.20.23.43;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2005.02.04.21.17.33;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2005.02.04.00.01.36;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2005.02.03.21.20.29;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2005.02.02.17.26.52;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2005.02.01.22.39.20;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2005.01.31.23.59.29;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2005.01.28.19.34.26;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2004.04.19.23.02.18;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2004.03.24.22.21.30;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2004.02.05.16.39.43;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2003.12.31.21.44.53;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2003.12.24.23.25.55;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2003.12.23.16.18.46;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2003.12.15.23.22.31;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2003.10.16.17.37.31;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2003.10.01.20.53.59;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2003.02.25.21.07.40;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2003.01.02.23.40.40;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2003.01.02.22.18.28;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2002.07.12.20.09.37;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2002.07.11.22.48.26;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2002.07.09.19.52.31;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.06.18.53.37;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.05.21.19.58;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2002.06.05.19.31.31;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2002.05.10.18.02.10;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2002.05.07.20.14.56;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2002.04.18.14.02.33;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2001.09.24.22.45.19;	author bobw;	state Exp;
branches;
next	1.77;

1.77
date	2001.09.21.22.36.30;	author bobw;	state Exp;
branches;
next	1.76;

1.76
date	2001.09.21.16.53.29;	author bobw;	state Exp;
branches;
next	1.75;

1.75
date	2001.09.19.18.50.56;	author bobw;	state Exp;
branches;
next	1.74;

1.74
date	2001.09.16.21.42.30;	author bobw;	state Exp;
branches;
next	1.73;

1.73
date	2001.09.12.21.19.50;	author bobw;	state Exp;
branches;
next	1.72;

1.72
date	2001.08.17.22.00.09;	author bobw;	state Exp;
branches;
next	1.71;

1.71
date	2001.08.14.20.43.53;	author bobw;	state Exp;
branches;
next	1.70;

1.70
date	2001.08.06.17.31.07;	author bobw;	state Exp;
branches;
next	1.69;

1.69
date	2001.08.03.18.40.41;	author bobw;	state Exp;
branches;
next	1.68;

1.68
date	2001.08.01.14.55.29;	author bobw;	state Exp;
branches;
next	1.67;

1.67
date	2001.07.30.15.12.09;	author bobw;	state Exp;
branches;
next	1.66;

1.66
date	2001.07.28.00.48.33;	author bobw;	state Exp;
branches;
next	1.65;

1.65
date	2001.07.27.21.28.38;	author bobw;	state Exp;
branches;
next	1.64;

1.64
date	2001.07.25.16.08.14;	author bobw;	state Exp;
branches;
next	1.63;

1.63
date	2001.07.12.17.57.00;	author bobw;	state Exp;
branches;
next	1.62;

1.62
date	2001.07.06.16.13.37;	author bobw;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.03.22.50.41;	author bobw;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.20.20.07.03;	author bobw;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.19.14.42.51;	author bobw;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.11.19.29.10;	author bobw;	state Exp;
branches;
next	1.57;

1.57
date	2001.05.25.22.59.12;	author bobw;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.17.15.11.14;	author bobw;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.15.15.30.26;	author bobw;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.10.18.11.52;	author bobw;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.07.15.58.56;	author bobw;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.03.22.55.45;	author bobw;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.03.20.47.25;	author bobw;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.03.18.50.35;	author bobw;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.25.20.54.35;	author bobw;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.09.21.41.21;	author bobw;	state Exp;
branches;
next	1.47;

1.47
date	2001.04.06.23.23.52;	author bobw;	state Exp;
branches;
next	1.46;

1.46
date	2001.04.06.19.22.08;	author bobw;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.26.20.28.07;	author bobw;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.22.14.53.58;	author bobw;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.21.21.55.45;	author bobw;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.20.21.03.58;	author bobw;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.16.16.55.20;	author bobw;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.16.00.22.57;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.13.22.12.05;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.12.19.48.06;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.08.21.08.26;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.08.16.37.04;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.09.22.55.47;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.07.22.59.25;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.06.15.46.35;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.30.23.34.36;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.01.30.00.46.23;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.01.29.19.26.09;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.01.26.21.46.01;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.20.00.44.16;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.15.19.01.49;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.11.16.35.08;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.04.22.27.50;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.03.15.56.49;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.28.22.13.36;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.15.23.45.57;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.14.19.35.22;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.13.19.57.24;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.06.19.58.37;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.05.19.05.29;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.04.22.07.36;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.21.20.03.23;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.13.21.03.54;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.06.18.45.08;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.25.20.12.31;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.14.20.27.30;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.29.21.22.44;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.18.00.15.59;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.08.21.56.12;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.02.20.43.12;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.24.19.55.22;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.21.17.42.48;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.19.22.35.30;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.01.00.35.43;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.16.33.08;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.53;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches;
next	;


desc
@@


1.149
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "HeurAll.C"
//
// Contains the implementation of the following classes:
//
//    HeurAllMgr
//    ReqSched
//    HeurCritList
//    PclBldr
//    PclEl
//------------------------------------------------------------------------------

#include <HeurAllMgr.h>
#include <HeurAtor.h>
#include <EqAll.h>
#include <PclBldr.h>
#include <PclEl.h>
#include <HeurModifier.h>
#include <wit/src/Variant.h>
#include <Pre.h>
#include <Post.h>
#include <Pegger.h>
#include <ReqSched.h>
#include <HeurCrit.h>
#include <PipMgr.h>
#include <DataRepos.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class HeurAllMgr
//------------------------------------------------------------------------------

WitHeurAllMgr::WitHeurAllMgr (WitProblem * theProblem):

      WitProbAssoc  (theProblem),

      myHeurAtor_   (NULL),
      myPegger_     (NULL),
      updatingSoln_ (false)
   {
   }

//------------------------------------------------------------------------------

WitHeurAllMgr::~WitHeurAllMgr ()
   {
   reset ();

   delete myPegger_;
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::setUpPegging ()
   {
   WitDemand * theDemand;

   stronglyAssert (myGlobalComp ()->perfPegging ());

   stronglyAssert (myPegger_ == NULL);

   forEachDemand (theDemand, myProblem ())
      theDemand->setUpPegging ();

   myPegger_ = new WitPegger (myProblem ());
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::clearPegging ()
   {
   witAssert (myPegger_ != NULL);

   myPegger_->clear ();
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::shutDownPegging ()
   {
   WitDemand * theDemand;

   stronglyAssert (not myGlobalComp ()->perfPegging ());

   stronglyAssert (myPegger_ != NULL);

   delete myPegger_;

   myPegger_ = NULL;

   forEachDemand (theDemand, myProblem ())
      theDemand->shutDownPegging ();
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::start ()
   {
   start (false);
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::startForOpt ()
   {
   start (true);
   }

//------------------------------------------------------------------------------

double WitHeurAllMgr::incHeurAlloc (
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      double      desIncVol,
      bool        asapMultiExec)
   {
   double incVol;

   updatingSoln_ = true;

   incVol        =
      myHeurAtor ()->incHeurAlloc (theDemand, thePer, desIncVol, asapMultiExec);

   updatingSoln_ = false;

   return incVol;
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::reset ()
   {
   if (not active ())
      return;

   delete myHeurAtor_;

   myHeurAtor_ = NULL;

   myProblem ()->myEqAllocator ()->heurAllocIsReset ();
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::finish ()
   {
   if (myGlobalComp ()->respectStockSLBs ())
      {
      updatingSoln_ = true;

      myHeurAtor ()->enforceStockSLBs ();

      updatingSoln_ = false;
      }

   myPostprocessor ()->postprocess ();
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::printMeDir (bool asapMultiExec)
   {
   WitMsgFragID theMeDirFragID;

   theMeDirFragID = asapMultiExec? "asapFrag": "nstnFrag";

   if (myMsgFac ().mayIssue ("incHeurMeDirMsg"))
      myMsgFac () ("incHeurMeDirMsg", myMsgFac ().myFrag (theMeDirFragID));
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::printPegging ()
   {
   witAssert (myGlobalComp ()->perfPegging ());

   myPegger_->print ();
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::printAvailSched ()
   {
   myHeurAtor ()->printAvailSched ();
   }

//------------------------------------------------------------------------------

bool WitHeurAllMgr::modifiable ()
   {
   if (active ())
      if (myGlobalComp ()->modHeurAlloc ())
         return true;
         
   return false;
   }

//------------------------------------------------------------------------------

WitHeurModifier * WitHeurAllMgr::myHeurModifier ()
   {
   return myHeurAtor ()->myHeurModifier ();
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::start (bool forOpt)
   {
   myProblem ()->resetSoln ();

   if (forOpt)
      myProblem ()->heurOptVariant ()->becomesCurrent ();
   else
      myProblem ()->heurVariant    ()->becomesCurrent ();

   myPreprocessor ()->preprocess ();

   updatingSoln_ = true;

   myHeurAtor_   = new WitHeurAtor (myProblem (), myPegger_, forOpt);

   updatingSoln_ = false;
   }

//------------------------------------------------------------------------------
// Implementation of class ReqSched.
//------------------------------------------------------------------------------

WitReqSched::WitReqSched (WitProblem * theProblem):

      WitProbAssoc (theProblem),

      myDataRepos_ (NULL),
      reqVol_      (myProblem (), 0.0),
      firstPer_    (myProblem (), nPeriods ()),
      lastPer_     (myProblem (), -1)
   {
   myDataRepos_ = new WitDataRepos (myProblem ());
   }

//------------------------------------------------------------------------------

WitReqSched::~WitReqSched ()
   {
   delete myDataRepos_;
   }

//------------------------------------------------------------------------------

void WitReqSched::addTo (WitPart * thePart, WitPeriod thePer, double qty)
   {
   witAssert (qty > 0.0);

   myDataRepos_->saveVal (reqVol_ (thePart)[thePer]);

   reqVol_ (thePart)[thePer] += qty;

   if (thePer < firstPer_ (thePart))
      {
      myDataRepos_->saveVal (firstPer_ (thePart));

      firstPer_ (thePart) = thePer;
      }

   if (thePer > lastPer_ (thePart))
      {
      myDataRepos_->saveVal (lastPer_ (thePart));

      lastPer_ (thePart) = thePer;
      }
   }

//------------------------------------------------------------------------------

void WitReqSched::clear ()
   {
   myDataRepos_->restore ();
   }

//------------------------------------------------------------------------------
// Implementation of class HeurCritList.
//------------------------------------------------------------------------------

WitHeurCritList::WitHeurCritList (WitProblem * theProblem):

      WitProbAssoc   (theProblem),

      culpritPart_   (NULL),
      culpritPeriod_ (0)
   {
   listed_.allocate (myProblem (), false);
   }

//------------------------------------------------------------------------------

WitHeurCritList::~WitHeurCritList ()
   {
   }

//------------------------------------------------------------------------------

void WitHeurCritList::initSoln ()
   {
   myGlobalComp ()->clearRevCritListForHeur ();
   }

//------------------------------------------------------------------------------

void WitHeurCritList::recFundShortage (WitPart * thePart, WitPeriod thePer)
   {
   witAssert (thePart != NULL);

   culpritPart_   = thePart;
   culpritPeriod_ = thePer;
   }

//------------------------------------------------------------------------------

void WitHeurCritList::recRestShortage ()
   {
   culpritPart_   = NULL;
   culpritPeriod_ = -1;
   }

//------------------------------------------------------------------------------

void WitHeurCritList::postCmqs ()
   {
   if (culpritPart_ == NULL)
      return;

   if (listed_ (culpritPart_)[culpritPeriod_])
      return;

   myGlobalComp ()->addToRevCritListForHeur (culpritPart_, culpritPeriod_);

   listed_ (culpritPart_)[culpritPeriod_] = true;

   culpritPart_   = NULL;
   culpritPeriod_ = -1;
   }

//------------------------------------------------------------------------------
// Implementation of class PclBldr.
//------------------------------------------------------------------------------

WitPclBldr::WitPclBldr (WitProblem * theProblem):

      WitProbAssoc (theProblem),

      curDemand_   (NULL),
      curShipPer_  (-1),
      shortPart_   (NULL),
      shortPer_    (-1)
   {
   myMsgFac () ("pgdCritListMsg");
   }

//------------------------------------------------------------------------------

WitPclBldr::~WitPclBldr ()
   {
   }

//------------------------------------------------------------------------------

void WitPclBldr::initSoln ()
   {
   curDemand_  = NULL;
   curShipPer_ = -1;
   shortPart_  = NULL;
   shortPer_   = -1;

   myGlobalComp ()->clearPgdCritList ();
   }

//------------------------------------------------------------------------------

void WitPclBldr::preIncAlloc (WitDemand * theDemand, WitPeriod shipPer)
   {
   witAssert (theDemand  != NULL);
   witAssert (shipPer    != -1);
   witAssert (shortPart_ == NULL);
   witAssert (shortPer_  == -1);

   curDemand_  = theDemand;
   curShipPer_ = shipPer;
   }

//------------------------------------------------------------------------------

void WitPclBldr::recFundShortage (WitPart * thePart, WitPeriod thePer)
   {
   witAssert (thePart != NULL);
   witAssert (thePer  != -1);

   shortPart_ = thePart;
   shortPer_  = thePer;
   }

//------------------------------------------------------------------------------

void WitPclBldr::recRestShortage ()
   {
   shortPart_ = NULL;
   shortPer_  = -1;
   }

//------------------------------------------------------------------------------

void WitPclBldr::postCmqs ()
   {
   WitPclEl * thePclEl;

   if (shortPart_ == NULL)
      return;

   thePclEl   = new WitPclEl (shortPart_, shortPer_, curDemand_, curShipPer_);

   myGlobalComp ()->appendToPgdCritListForHeur (thePclEl);

   shortPart_ = NULL;
   shortPer_  = -1;
   }

//------------------------------------------------------------------------------
// Implementation of class WitPclEl.
//------------------------------------------------------------------------------

WitPclEl::WitPclEl (
         WitPart *   thePart,
         WitPeriod   shortPer,
         WitDemand * theDemand,
         WitPeriod   shipPer):

      critPart_  (thePart),
      critPer_   (shortPer),
      myDemand_  (theDemand),
      myShipPer_ (shipPer)
   {
   witAssert (thePart   != NULL);
   witAssert (shortPer  != -1);
   witAssert (theDemand != NULL);
   witAssert (shipPer   != -1);
   }

//------------------------------------------------------------------------------

WitPclEl::~WitPclEl ()
   {
   }
@


1.148
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.147
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d45 1
a45 1
WitProbAssoc  (theProblem),
d47 5
a51 5
myHeurAtor_   (NULL),
myPegger_     (NULL),
updatingSoln_ (false)
{
}
d56 2
a57 2
{
reset ();
d59 2
a60 2
delete myPegger_;
}
d65 2
a66 2
{
WitDemand * theDemand;
d68 1
a68 1
stronglyAssert (myGlobalComp ()->perfPegging ());
d70 1
a70 1
stronglyAssert (myPegger_ == NULL);
d72 2
a73 2
forEachDemand (theDemand, myProblem ())
theDemand->setUpPegging ();
d75 2
a76 2
myPegger_ = new WitPegger (myProblem ());
}
d81 2
a82 2
{
witAssert (myPegger_ != NULL);
d84 2
a85 2
myPegger_->clear ();
}
d90 2
a91 2
{
WitDemand * theDemand;
d93 1
a93 1
stronglyAssert (not myGlobalComp ()->perfPegging ());
d95 1
a95 1
stronglyAssert (myPegger_ != NULL);
d97 1
a97 1
delete myPegger_;
d99 1
a99 1
myPegger_ = NULL;
d101 3
a103 3
forEachDemand (theDemand, myProblem ())
theDemand->shutDownPegging ();
}
d108 3
a110 3
{
start (false);
}
d115 3
a117 3
{
start (true);
}
d122 8
a129 8
WitDemand * theDemand,
WitPeriod   thePer,
double      desIncVol,
bool        asapMultiExec)
{
double incVol;

updatingSoln_ = true;
d131 2
a132 2
incVol        =
myHeurAtor ()->incHeurAlloc (theDemand, thePer, desIncVol, asapMultiExec);
d134 1
a134 1
updatingSoln_ = false;
d136 2
a137 2
return incVol;
}
d142 3
a144 3
{
if (not active ())
return;
d146 1
a146 1
delete myHeurAtor_;
d148 1
a148 1
myHeurAtor_ = NULL;
d150 2
a151 2
myProblem ()->myEqAllocator ()->heurAllocIsReset ();
}
d156 4
a159 4
{
if (myGlobalComp ()->respectStockSLBs ())
{
updatingSoln_ = true;
d161 1
a161 1
myHeurAtor ()->enforceStockSLBs ();
d163 2
a164 2
updatingSoln_ = false;
}
d166 2
a167 2
myPostprocessor ()->postprocess ();
}
d172 2
a173 2
{
WitMsgFragID theMeDirFragID;
d175 1
a175 1
theMeDirFragID = asapMultiExec? "asapFrag": "nstnFrag";
d177 3
a179 3
if (myMsgFac ().mayIssue ("incHeurMeDirMsg"))
myMsgFac () ("incHeurMeDirMsg", myMsgFac ().myFrag (theMeDirFragID));
}
d184 2
a185 2
{
witAssert (myGlobalComp ()->perfPegging ());
d187 2
a188 2
myPegger_->print ();
}
d193 3
a195 3
{
myHeurAtor ()->printAvailSched ();
}
d200 7
a206 7
{
if (active ())
if (myGlobalComp ()->modHeurAlloc ())
return true;

return false;
}
d211 3
a213 3
{
return myHeurAtor ()->myHeurModifier ();
}
d218 2
a219 2
{
myProblem ()->resetSoln ();
d221 4
a224 4
if (forOpt)
myProblem ()->heurOptVariant ()->becomesCurrent ();
else
myProblem ()->heurVariant    ()->becomesCurrent ();
d226 1
a226 1
myPreprocessor ()->preprocess ();
d228 1
a228 1
updatingSoln_ = true;
d230 1
a230 1
myHeurAtor_   = new WitHeurAtor (myProblem (), myPegger_, forOpt);
d232 2
a233 2
updatingSoln_ = false;
}
d241 1
a241 1
WitProbAssoc (theProblem),
d243 7
a249 7
myDataRepos_ (NULL),
reqVol_      (myProblem (), 0.0),
firstPer_    (myProblem (), nPeriods ()),
lastPer_     (myProblem (), -1)
{
myDataRepos_ = new WitDataRepos (myProblem ());
}
d254 3
a256 3
{
delete myDataRepos_;
}
d261 2
a262 2
{
witAssert (qty > 0.0);
d264 1
a264 1
myDataRepos_->saveVal (reqVol_ (thePart)[thePer]);
d266 1
a266 1
reqVol_ (thePart)[thePer] += qty;
d268 3
a270 3
if (thePer < firstPer_ (thePart))
{
myDataRepos_->saveVal (firstPer_ (thePart));
d272 2
a273 2
firstPer_ (thePart) = thePer;
}
d275 3
a277 3
if (thePer > lastPer_ (thePart))
{
myDataRepos_->saveVal (lastPer_ (thePart));
d279 3
a281 3
lastPer_ (thePart) = thePer;
}
}
d286 3
a288 3
{
myDataRepos_->restore ();
}
d296 1
a296 1
WitProbAssoc   (theProblem),
d298 5
a302 5
culpritPart_   (NULL),
culpritPeriod_ (0)
{
listed_.allocate (myProblem (), false);
}
d307 2
a308 2
{
}
d313 3
a315 3
{
myGlobalComp ()->clearRevCritListForHeur ();
}
d320 2
a321 2
{
witAssert (thePart != NULL);
d323 3
a325 3
culpritPart_   = thePart;
culpritPeriod_ = thePer;
}
d330 4
a333 4
{
culpritPart_   = NULL;
culpritPeriod_ = -1;
}
d338 3
a340 3
{
if (culpritPart_ == NULL)
return;
d342 2
a343 2
if (listed_ (culpritPart_)[culpritPeriod_])
return;
d345 1
a345 1
myGlobalComp ()->addToRevCritListForHeur (culpritPart_, culpritPeriod_);
d347 1
a347 1
listed_ (culpritPart_)[culpritPeriod_] = true;
d349 3
a351 3
culpritPart_   = NULL;
culpritPeriod_ = -1;
}
d359 1
a359 1
WitProbAssoc (theProblem),
d361 7
a367 7
curDemand_   (NULL),
curShipPer_  (-1),
shortPart_   (NULL),
shortPer_    (-1)
{
myMsgFac () ("pgdCritListMsg");
}
d372 2
a373 2
{
}
d378 5
a382 5
{
curDemand_  = NULL;
curShipPer_ = -1;
shortPart_  = NULL;
shortPer_   = -1;
d384 2
a385 2
myGlobalComp ()->clearPgdCritList ();
}
d390 9
a398 9
{
witAssert (theDemand  != NULL);
witAssert (shipPer    != -1);
witAssert (shortPart_ == NULL);
witAssert (shortPer_  == -1);

curDemand_  = theDemand;
curShipPer_ = shipPer;
}
d403 7
a409 7
{
witAssert (thePart != NULL);
witAssert (thePer  != -1);

shortPart_ = thePart;
shortPer_  = thePer;
}
d414 4
a417 4
{
shortPart_ = NULL;
shortPer_  = -1;
}
d422 2
a423 2
{
WitPclEl * thePclEl;
d425 2
a426 2
if (shortPart_ == NULL)
return;
d428 1
a428 1
thePclEl   = new WitPclEl (shortPart_, shortPer_, curDemand_, curShipPer_);
d430 1
a430 1
myGlobalComp ()->appendToPgdCritListForHeur (thePclEl);
d432 3
a434 3
shortPart_ = NULL;
shortPer_  = -1;
}
d441 15
a455 15
WitPart *   thePart,
WitPeriod   shortPer,
WitDemand * theDemand,
WitPeriod   shipPer):

critPart_  (thePart),
critPer_   (shortPer),
myDemand_  (theDemand),
myShipPer_ (shipPer)
{
witAssert (thePart   != NULL);
witAssert (shortPer  != -1);
witAssert (theDemand != NULL);
witAssert (shipPer   != -1);
}
d460 2
a461 2
{
}
@


1.146
log
@Modifiable heuristic allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d45 1
a45 1
      WitProbAssoc  (theProblem),
d47 5
a51 5
      myHeurAtor_   (NULL),
      myPegger_     (NULL),
      updatingSoln_ (false)
   {
   }
d56 2
a57 2
   {
   reset ();
d59 2
a60 2
   delete myPegger_;
   }
d65 2
a66 2
   {
   WitDemand * theDemand;
d68 1
a68 1
   stronglyAssert (myGlobalComp ()->perfPegging ());
d70 1
a70 1
   stronglyAssert (myPegger_ == NULL);
d72 2
a73 2
   forEachDemand (theDemand, myProblem ())
      theDemand->setUpPegging ();
d75 2
a76 2
   myPegger_ = new WitPegger (myProblem ());
   }
d81 2
a82 2
   {
   witAssert (myPegger_ != NULL);
d84 2
a85 2
   myPegger_->clear ();
   }
d90 2
a91 2
   {
   WitDemand * theDemand;
d93 1
a93 1
   stronglyAssert (not myGlobalComp ()->perfPegging ());
d95 1
a95 1
   stronglyAssert (myPegger_ != NULL);
d97 1
a97 1
   delete myPegger_;
d99 1
a99 1
   myPegger_ = NULL;
d101 3
a103 3
   forEachDemand (theDemand, myProblem ())
      theDemand->shutDownPegging ();
   }
d108 3
a110 3
   {
   start (false);
   }
d115 3
a117 3
   {
   start (true);
   }
d122 8
a129 8
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      double      desIncVol,
      bool        asapMultiExec)
   {
   double incVol;

   updatingSoln_ = true;
d131 2
a132 2
   incVol        =
      myHeurAtor ()->incHeurAlloc (theDemand, thePer, desIncVol, asapMultiExec);
d134 1
a134 1
   updatingSoln_ = false;
d136 2
a137 2
   return incVol;
   }
d142 3
a144 3
   {
   if (not active ())
      return;
d146 1
a146 1
   delete myHeurAtor_;
d148 1
a148 1
   myHeurAtor_ = NULL;
d150 2
a151 2
   myProblem ()->myEqAllocator ()->heurAllocIsReset ();
   }
d156 4
a159 4
   {
   if (myGlobalComp ()->respectStockSLBs ())
      {
      updatingSoln_ = true;
d161 1
a161 1
      myHeurAtor ()->enforceStockSLBs ();
d163 2
a164 2
      updatingSoln_ = false;
      }
d166 2
a167 2
   myPostprocessor ()->postprocess ();
   }
d172 2
a173 2
   {
   WitMsgFragID theMeDirFragID;
d175 1
a175 1
   theMeDirFragID = asapMultiExec? "asapFrag": "nstnFrag";
d177 3
a179 3
   if (myMsgFac ().mayIssue ("incHeurMeDirMsg"))
      myMsgFac () ("incHeurMeDirMsg", myMsgFac ().myFrag (theMeDirFragID));
   }
d184 2
a185 2
   {
   witAssert (myGlobalComp ()->perfPegging ());
d187 2
a188 2
   myPegger_->print ();
   }
d193 3
a195 3
   {
   myHeurAtor ()->printAvailSched ();
   }
d200 7
a206 7
   {
   if (active ())
      if (myGlobalComp ()->modHeurAlloc ())
         return true;
         
   return false;
   }
d211 3
a213 3
   {
   return myHeurAtor ()->myHeurModifier ();
   }
d218 2
a219 2
   {
   myProblem ()->resetSoln ();
d221 4
a224 4
   if (forOpt)
      myProblem ()->heurOptVariant ()->becomesCurrent ();
   else
      myProblem ()->heurVariant    ()->becomesCurrent ();
d226 1
a226 1
   myPreprocessor ()->preprocess ();
d228 1
a228 1
   updatingSoln_ = true;
d230 1
a230 1
   myHeurAtor_   = new WitHeurAtor (myProblem (), myPegger_, forOpt);
d232 2
a233 2
   updatingSoln_ = false;
   }
d241 1
a241 1
      WitProbAssoc (theProblem),
d243 7
a249 7
      myDataRepos_ (NULL),
      reqVol_      (myProblem (), 0.0),
      firstPer_    (myProblem (), nPeriods ()),
      lastPer_     (myProblem (), -1)
   {
   myDataRepos_ = new WitDataRepos (myProblem ());
   }
d254 3
a256 3
   {
   delete myDataRepos_;
   }
d261 2
a262 2
   {
   witAssert (qty > 0.0);
d264 1
a264 1
   myDataRepos_->saveVal (reqVol_ (thePart)[thePer]);
d266 1
a266 1
   reqVol_ (thePart)[thePer] += qty;
d268 3
a270 3
   if (thePer < firstPer_ (thePart))
      {
      myDataRepos_->saveVal (firstPer_ (thePart));
d272 2
a273 2
      firstPer_ (thePart) = thePer;
      }
d275 3
a277 3
   if (thePer > lastPer_ (thePart))
      {
      myDataRepos_->saveVal (lastPer_ (thePart));
d279 3
a281 3
      lastPer_ (thePart) = thePer;
      }
   }
d286 3
a288 3
   {
   myDataRepos_->restore ();
   }
d296 1
a296 1
      WitProbAssoc   (theProblem),
d298 5
a302 5
      culpritPart_   (NULL),
      culpritPeriod_ (0)
   {
   listed_.allocate (myProblem (), false);
   }
d307 2
a308 2
   {
   }
d313 3
a315 3
   {
   myGlobalComp ()->clearRevCritListForHeur ();
   }
d320 2
a321 2
   {
   witAssert (thePart != NULL);
d323 3
a325 3
   culpritPart_   = thePart;
   culpritPeriod_ = thePer;
   }
d330 4
a333 4
   {
   culpritPart_   = NULL;
   culpritPeriod_ = -1;
   }
d338 3
a340 3
   {
   if (culpritPart_ == NULL)
      return;
d342 2
a343 2
   if (listed_ (culpritPart_)[culpritPeriod_])
      return;
d345 1
a345 1
   myGlobalComp ()->addToRevCritListForHeur (culpritPart_, culpritPeriod_);
d347 1
a347 1
   listed_ (culpritPart_)[culpritPeriod_] = true;
d349 3
a351 3
   culpritPart_   = NULL;
   culpritPeriod_ = -1;
   }
d359 1
a359 1
      WitProbAssoc (theProblem),
d361 7
a367 7
      curDemand_   (NULL),
      curShipPer_  (-1),
      shortPart_   (NULL),
      shortPer_    (-1)
   {
   myMsgFac () ("pgdCritListMsg");
   }
d372 2
a373 2
   {
   }
d378 5
a382 5
   {
   curDemand_  = NULL;
   curShipPer_ = -1;
   shortPart_  = NULL;
   shortPer_   = -1;
d384 2
a385 2
   myGlobalComp ()->clearPgdCritList ();
   }
d390 9
a398 9
   {
   witAssert (theDemand  != NULL);
   witAssert (shipPer    != -1);
   witAssert (shortPart_ == NULL);
   witAssert (shortPer_  == -1);

   curDemand_  = theDemand;
   curShipPer_ = shipPer;
   }
d403 7
a409 7
   {
   witAssert (thePart != NULL);
   witAssert (thePer  != -1);

   shortPart_ = thePart;
   shortPer_  = thePer;
   }
d414 4
a417 4
   {
   shortPart_ = NULL;
   shortPer_  = -1;
   }
d422 2
a423 2
   {
   WitPclEl * thePclEl;
d425 2
a426 2
   if (shortPart_ == NULL)
      return;
d428 1
a428 1
   thePclEl   = new WitPclEl (shortPart_, shortPer_, curDemand_, curShipPer_);
d430 1
a430 1
   myGlobalComp ()->appendToPgdCritListForHeur (thePclEl);
d432 3
a434 3
   shortPart_ = NULL;
   shortPer_  = -1;
   }
d441 15
a455 15
         WitPart *   thePart,
         WitPeriod   shortPer,
         WitDemand * theDemand,
         WitPeriod   shipPer):

      critPart_  (thePart),
      critPer_   (shortPer),
      myDemand_  (theDemand),
      myShipPer_ (shipPer)
   {
   witAssert (thePart   != NULL);
   witAssert (shortPer  != -1);
   witAssert (theDemand != NULL);
   witAssert (shipPer   != -1);
   }
d460 2
a461 2
   {
   }
@


1.145
log
@Heuristic Adjustment
@
text
@d27 1
a27 1
#include <HeurAdjuster.h>
d199 1
a199 1
bool WitHeurAllMgr::adjustMode ()
d202 1
a202 1
      if (myGlobalComp ()->heurAdjustEnabled ())
d210 1
a210 1
WitHeurAdjuster * WitHeurAllMgr::myHeurAdjuster ()
d212 1
a212 1
   return myHeurAtor ()->myHeurAdjuster ();
@


1.144
log
@Heuristic Adjustment
@
text
@a145 3
   if (heurAdjustActive ())
      myHeurAdjuster ()->finish ();

d199 1
a199 1
bool WitHeurAllMgr::heurAdjustActive ()
d203 1
a203 2
         if (myHeurAdjuster ()->active ())
            return true;
@


1.143
log
@Heuristic Adjustment
@
text
@d45 1
a45 1
      WitProbAssoc    (theProblem),
d47 3
a49 4
      myHeurAtor_     (NULL),
      myPegger_       (NULL),
      myHeurAdjuster_ (NULL),
      updatingSoln_   (false)
a140 10
void WitHeurAllMgr::adjustIncAvailVol (
      WitPart * thePart, 
      WitPeriod thePer, 
      double    deltaAvailVol)
   {
   myHeurAtor ()->adjustIncAvailVol (thePart, thePer, deltaAvailVol);
   }

//------------------------------------------------------------------------------

d147 1
a147 5
      myHeurAdjuster_->finish ();

   delete myHeurAdjuster_;

   myHeurAdjuster_ = NULL;
d151 1
a151 1
   myHeurAtor_     = NULL;
d204 13
a216 6
   if (myHeurAdjuster_ != NULL)
      {
      return myHeurAdjuster_->active ();
      }
   else
      return false;
a236 5

   if (myGlobalComp ()->heurAdjustEnabled ())
      {
      myHeurAdjuster_ = new WitHeurAdjuster (myProblem ());
      }
@


1.142
log
@Heuristic Adjustment
@
text
@d45 1
a45 1
      WitProbAssoc  (theProblem),
d47 4
a50 3
      myHeurAtor_   (NULL),
      myPegger_     (NULL),
      updatingSoln_ (false)
d157 6
a162 4
   if (myProblem ()->myHeurAdjuster ()->active ())
      {
      myProblem ()->myHeurAdjuster ()->finish ();
      }
d166 1
a166 1
   myHeurAtor_ = NULL;
d217 12
d245 5
@


1.141
log
@Heuristic Adjustment
@
text
@d27 1
a27 1
#include <HeurAdjMgr.h>
d156 1
a156 1
   if (myProblem ()->myHeurAdjMgr ()->active ())
d158 1
a158 1
      myProblem ()->myHeurAdjMgr ()->finish ();
@


1.140
log
@Heuristic Adjustment
@
text
@d207 7
@


1.139
log
@Heuristic Adjustment
@
text
@a140 7
void WitHeurAllMgr::updateForAdjust ()
   {
   myHeurAtor ()->updateForAdjust ();
   }

//------------------------------------------------------------------------------

@


1.138
log
@Heuristic Adjustment
@
text
@d151 1
a151 1
      double    deltaVol)
d153 1
a153 1
   myHeurAtor ()->adjustIncAvailVol (thePart, thePer, deltaVol);
@


1.137
log
@Heuristic Adjustment
@
text
@d148 4
a151 4
void WitHeurAllMgr::adjustForShipVol (
      WitDemand * theDemand,
      WitPeriod   shipPer,
      double      deltaShipVol)
d153 1
a153 3
   stronglyAssert (myProblem ()->myHeurAdjMgr ()->active ());

   myHeurAtor ()->adjustForShipVol (theDemand, shipPer, deltaShipVol);
@


1.136
log
@Heuristic Adjustment
@
text
@d148 12
@


1.135
log
@Heuristic Adjustment
@
text
@d141 7
@


1.134
log
@Heuristic Adjustment
@
text
@a15 1
//    HeurAdjMgr
a22 1
#include <HeurAdjMgr.h>
d27 1
a215 78
// Implementation of class HeurAdjMgr.
//------------------------------------------------------------------------------

WitHeurAdjMgr::WitHeurAdjMgr (WitProblem * theProblem):

      WitProbAssoc       (theProblem),
      heurAdjustAllowed_ (false),
      active_            (false)
   {
   }

//------------------------------------------------------------------------------

WitHeurAdjMgr::~WitHeurAdjMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitHeurAdjMgr::setHeurAdjustAllowed (bool theValue)
   {
   heurAdjustAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitHeurAdjMgr::start ()
   {
   stronglyAssert (heurAdjustAllowed_);

   checkPreconditions ();

   active_ = true;

   myMsgFac () ("heurAdjActiveMsg");
   }

//------------------------------------------------------------------------------

void WitHeurAdjMgr::finish ()
   {
   stronglyAssert (heurAdjustAllowed_);
   stronglyAssert (active_);

   active_ = false;

   myMsgFac () ("heurAdjInactiveMsg");
   }

//------------------------------------------------------------------------------

void WitHeurAdjMgr::checkPreconditions ()
   {
   verify (myHeurAllMgr ()->active (),              "heurAllocActive",   true);
   verify (                 active_,                "heurAdjustActive",  false);
   verify (myGlobalComp ()->selectionRecovery (),   "selectionRecovery", true);
   verify (myGlobalComp ()->skipFailures (),        "skipFailures",      false);
   verify (myGlobalComp ()->perfPegging (),         "perfPegging",       false);
   verify (myGlobalComp ()->computeCriticalList (), "computeCriticalList",
                                                                         false);
   verify (myGlobalComp ()->pgdCritListMode (),     "pgdCritListMode",   false);
   }

//------------------------------------------------------------------------------

void WitHeurAdjMgr::verify (
      bool         theAttVal,
      const char * theAttName,
      bool         theReqVal)
   {
   if (theAttVal != theReqVal)
      myMsgFac () ("globBoolAttReqSmsg",
         theAttName,
         theReqVal,
         "witStartHeurAdjust");
   }

//------------------------------------------------------------------------------
@


1.133
log
@Pause/Resume
@
text
@d16 1
a16 1
//    HeurPauseMgr
d24 1
a24 1
#include <HeurPauseMgr.h>
d147 5
d217 1
a217 1
// Implementation of class HeurPauseMgr.
d220 9
a228 1
WitHeurPauseMgr::WitHeurPauseMgr (WitProblem * theProblem):
d230 1
a230 3
      WitProbAssoc        (theProblem),
      pauseResumeAllowed_ (false),
      paused_             (false)
d236 1
a236 1
WitHeurPauseMgr::~WitHeurPauseMgr ()
d238 1
d243 1
a243 1
void WitHeurPauseMgr::setPauseResumeAllowed (bool theValue)
d245 7
a251 1
   pauseResumeAllowed_ = theValue;
d256 1
a256 1
void WitHeurPauseMgr::pause ()
d258 2
a259 1
   stronglyAssert (pauseResumeAllowed_);
d261 1
a261 1
   validatePause ();
d263 1
a263 1
   paused_ = true;
d268 1
a268 1
void WitHeurPauseMgr::validatePause ()
d271 1
a271 1
   verify (                 paused_,                "heurAllocPaused",   false);
a277 2

   myMsgFac () ("heurPauseTermSmsg");
d282 1
a282 1
void WitHeurPauseMgr::verify (
d288 4
a291 1
      myMsgFac () ("globBoolAttReqForPauseSmsg", theAttName, theReqVal);
@


1.132
log
@Pause/Resume
@
text
@d251 8
a258 2
   if (not myHeurAllMgr ()->active ())
      myMsgFac () ("globBoolAttReqForPauseSmsg", "heurAllocActive", true);
d264 11
@


1.131
log
@Pause/Resume
@
text
@d251 3
@


1.130
log
@Pause/Resume
@
text
@d237 18
@


1.129
log
@Pause / Resume
@
text
@d16 1
d24 1
a192 7
bool WitHeurAllMgr::paused ()
   {
   return active () and myHeurAtor ()->paused ();
   }

//------------------------------------------------------------------------------

d212 25
@


1.128
log
@Lead Time Bounds
@
text
@d191 7
@


1.127
log
@Stochastic Implosion
@
text
@d120 1
a120 1
double WitHeurAllMgr::inc (
d131 1
a131 1
      myHeurAtor ()->inc (theDemand, thePer, desIncVol, asapMultiExec);
@


1.126
log
@Stochastic Implosion
@
text
@a26 1
#include <HeurAccess.h>
@


1.125
log
@Stochastic Implosion
@
text
@d35 1
a35 1
#include <Repos.h>
@


1.124
log
@Stochastic Implosion
@
text
@d158 3
d163 3
@


1.123
log
@Stochastic Implosion
@
text
@d45 1
a45 1
      WitProbAssoc (theProblem),
d47 3
a49 2
      myHeurAtor_  (NULL),
      myPegger_    (NULL)
d127 10
a136 1
   return myHeurAtor ()->inc (theDemand, thePer, desIncVol, asapMultiExec);
d197 5
a201 1
   myHeurAtor_ = new WitHeurAtor (myProblem (), myPegger_, forOpt);
d283 1
a283 1
   WitHeurAccess::revCritList (myGlobalComp ()).clear ();
d314 1
a314 2
   WitHeurAccess::revCritList (myGlobalComp ()).
      push (culpritPart_, culpritPeriod_);
d397 1
a397 1
   thePclEl = new WitPclEl (shortPart_, shortPer_, curDemand_, curShipPer_);
d399 1
a399 1
   WitHeurAccess::pgdCritList (myGlobalComp ()).append (thePclEl);
@


1.122
log
@[disallowed backlog]
@
text
@d269 1
a269 2
   while (not WitHeurAccess::criticalList (myGlobalComp ()).isEmpty ())
      delete  WitHeurAccess::criticalList (myGlobalComp ()).get ();
a293 2
   WitPartPer * thePartPer;

d300 2
a301 3
   thePartPer = new WitPartPer (culpritPart_, culpritPeriod_);

   WitHeurAccess::criticalList (myGlobalComp ()).append (thePartPer);
@


1.121
log
@[disallowed backlog]
@
text
@a175 34
void WitHeurAllMgr::receiveDMPs (
      WitDblFlexVec                        WitDemand::* shipVolArg,
      WitPtrTVec <WitObjStack <WitPegEl> > WitDemand::* myPegElsForArg)
   {
   WitHeurAtor::receiveDMPs (shipVolArg);
   WitPegger  ::receiveDMPs (myPegElsForArg);
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::receiveDMPs (WitDblFlexVec WitOperation::* execVolArg)
   {
   WitHeurAtor::receiveDMPs (execVolArg);
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::receiveDMPs (WitDblFlexVec WitSubEntry::* subVolArg)
   {
   WitHeurAtor::receiveDMPs (subVolArg);
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::receiveDMPs (
      WitList <WitPartPer> WitGlobalComp::* criticalListArg,
      WitList <WitPclEl>   WitGlobalComp::* pgdCritListArg)
   {
   WitHeurAtor::receiveDMPs (criticalListArg,
                             pgdCritListArg);
   }

//------------------------------------------------------------------------------

a316 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitList <WitPclEl> WitGlobalComp::* WitPclBldr::pgdCritList_ = NULL;

//------------------------------------------------------------------------------

d390 1
a390 1
   (myGlobalComp ()->*pgdCritList_).append (thePclEl);
a396 8

void WitPclBldr::receiveDMPs (
      WitList <WitPclEl> WitGlobalComp::* pgdCritListArg)
   {
   pgdCritList_ = pgdCritListArg;
   }

//------------------------------------------------------------------------------
@


1.120
log
@Rescinded all changed made since 1/31/07.
@
text
@d27 1
a282 8
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitList <WitPartPer> WitGlobalComp::* WitHeurCritList::criticalList_ = NULL;

//------------------------------------------------------------------------------

d303 2
a304 2
   while (not (myGlobalComp ()->*criticalList_).isEmpty ())
      delete (myGlobalComp ()->*criticalList_).get ();
d339 1
a339 1
   (myGlobalComp ()->*criticalList_).append (thePartPer);
a347 8

void WitHeurCritList::receiveDMPs (
      WitList <WitPartPer> WitGlobalComp::* criticalListArg)
   {
   criticalList_ = criticalListArg;
   }

//------------------------------------------------------------------------------
@


1.119
log
@[disallowed backlog]
@
text
@d179 16
a194 1
   WitPegger::receiveDMPs (myPegElsForArg);
@


1.118
log
@[disallowed backlog]
@
text
@a183 7
void WitHeurAllMgr::receiveDMPs (WitDblFlexVec WitSubEntry::* subVolArg)
   {
   WitHeurAtor::receiveDMPs (subVolArg);
   }

//------------------------------------------------------------------------------

@


1.117
log
@External opt implosion.
@
text
@d179 1
a179 9
   WitHeurAtor::receiveDMPs (shipVolArg);
   WitPegger  ::receiveDMPs (myPegElsForArg);
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::receiveDMPs (WitDblFlexVec WitOperation::* execVolArg)
   {
   WitHeurAtor::receiveDMPs (execVolArg);
@


1.116
log
@App controlled opt implosion.
@
text
@d214 1
a214 1
      myProblem ()->myHeurOptVariant ()->becomesCurrent ();
d216 1
a216 1
      myProblem ()->myHeurVariant    ()->becomesCurrent ();
@


1.115
log
@App controlled opt implosion.
@
text
@a27 1
#include <DataAlt.h>
d211 1
a211 1
   postprocAlt ()->incur ();
@


1.114
log
@Updated the copyright date on all source files.
@
text
@d24 1
d29 2
d140 1
a140 1
   myProblem ()->heurAllocIsReset ();
d150 1
a150 1
   myProblem ()->postprocess ();
d219 1
a219 1
   myProblem ()->preprocess ();
@


1.113
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.112
log
@[multi-thread]
@
text
@a31 1
#include <PerPair.h>
@


1.111
log
@[multi-thread]
@
text
@d174 3
a176 12
void WitHeurAllMgr::loadPegDataFrom (
      WitDemand *                                  theDemand,
      const WitPtrTVec <WitObjStack <WitPegEl> > & thePegElStPtrTVec)
   {
   witAssert (myGlobalComp ()->perfPegging ());

   myPegger_->loadDataFrom (theDemand, thePegElStPtrTVec);
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::receiveDMPs (WitDblFlexVec WitDemand::* shipVolArg)
d179 1
@


1.110
log
@Revised mappingIndex code.
@
text
@a138 2

   clearLoadedData ();
a173 9
void WitHeurAllMgr::loadDataFrom (
      WitDemand *     theDemand,
      WitDblFlexVec & shipVolArg)
   {
   shipVol_.setMapFor (theDemand, shipVolArg);
   }

//------------------------------------------------------------------------------

d185 1
a185 3
void WitHeurAllMgr::loadDataFrom (
      WitOperation *  theOpn,
      WitDblFlexVec & execVolArg)
d187 1
a187 1
   execVol_.setMapFor (theOpn, execVolArg);
d192 1
a192 3
void WitHeurAllMgr::loadDataFrom (
      WitSubEntry *   theSub,
      WitDblFlexVec & subVolArg)
d194 1
a194 1
   subVol_.setMapFor (theSub, subVolArg);
d199 1
a199 3
void WitHeurAllMgr::loadDataFromGlobalComp (
      WitList <WitPartPer> & criticalListArg,
      WitList <WitPclEl> &   pgdCritListArg)
d201 11
a211 2
   criticalList_.attachTo (criticalListArg);
   pgdCritList_ .attachTo (pgdCritListArg);
d227 1
a227 36
   loadData ();

   myHeurAtor_ =
      new WitHeurAtor (
         myProblem (), 
         myPegger_, 
         forOpt,
         shipVol_,
         execVol_,
         subVol_,
         criticalList_ (),
         pgdCritList_ ());
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::loadData ()
   {
   WitComponent * theComp;
                 
   shipVol_.allocate (myProblem ());
   execVol_.allocate (myProblem ());
   subVol_ .allocate (myProblem ());

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->loadHeur ();
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::clearLoadedData ()
   {
   shipVol_     .clear ();
   execVol_     .clear ();
   subVol_      .clear ();
   criticalList_.clear ();
d289 9
a297 3
WitHeurCritList::WitHeurCritList (
         WitProblem *           theProblem,
         WitList <WitPartPer> & criticalListArg):
a300 1
      criticalList_  (criticalListArg),
d317 2
a318 2
   while (not criticalList_.isEmpty ())
      delete criticalList_.get ();
d353 1
a353 1
   criticalList_.append (thePartPer);
d362 8
d373 9
a381 3
WitPclBldr::WitPclBldr (
         WitProblem *         theProblem,
         WitList <WitPclEl> & pgdCritListArg):
d384 1
a384 1
      pgdCritList_ (pgdCritListArg),
d454 1
a454 1
   pgdCritList_.append (thePclEl);
d461 8
@


1.109
log
@Pegged Critical List.
@
text
@a35 1
#include <MapIdxI.h>
@


1.108
log
@Pegged Critical List
@
text
@d354 9
a362 1
void WitHeurCritList::setCulprit (WitPart * thePart, WitPeriod thePer)
d372 9
a380 1
void WitHeurCritList::appendCulprit ()
d396 2
a397 9
   culpritPart_ = NULL;
   }

//------------------------------------------------------------------------------

void WitHeurCritList::initSoln ()
   {
   while (not criticalList_.isEmpty ())
      delete criticalList_.get ();
@


1.107
log
@Pegged Critical List.
@
text
@d424 1
a424 2
   while (not pgdCritList_.isEmpty ())
      delete pgdCritList_.get ();
@


1.106
log
@Pegged Critical List.
@
text
@d469 1
a469 1
   thePclEl = new WitPclEl (curDemand_, curShipPer_, shortPart_, shortPer_);
d482 2
d485 1
a485 3
         WitPeriod   shipPer,
         WitPart *   thePart,
         WitPeriod   suppPer):
d487 2
d490 1
a490 3
      myShipPer_ (shipPer),
      critPart_  (thePart),
      critPer_   (suppPer)
d492 2
a495 2
   witAssert (thePart   != NULL);
   witAssert (suppPer   != -1);
@


1.105
log
@pegged Critical List.
@
text
@d406 1
@


1.104
log
@Pegged Critical List
@
text
@d18 1
a18 1
//    PclMgr
d24 1
a24 1
#include <PclMgr.h>
a28 1
#include <PclMgr.h>
d47 1
a47 2
      myPegger_    (NULL),
      myPclMgr_    (NULL)
a56 1
   delete myPclMgr_;
a104 24
void WitHeurAllMgr::setUpPcl ()
   {
   stronglyAssert (myGlobalComp ()->pgdCritListNeeded ());

   stronglyAssert (myPclMgr_ == NULL);

   myPclMgr_ = new WitPclMgr (myProblem ());
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::shutDownPcl ()
   {
   stronglyAssert (not myGlobalComp ()->pgdCritListNeeded ());

   stronglyAssert (myPclMgr_ != NULL);

   delete myPclMgr_;

   myPclMgr_ = NULL;
   }

//------------------------------------------------------------------------------

d216 2
a217 1
      WitList <WitPartPer> & criticalListArg)
d219 2
a220 1
   criticalList_.refTo (criticalListArg);
d246 2
a247 1
         criticalList_);
d334 2
a335 2
         WitProblem *                     theProblem,
         WitRef <WitList <WitPartPer> > & criticalListArg):
d376 1
a376 1
   criticalList_ ().append (thePartPer);
d387 2
a388 2
   while (not  criticalList_ ().isEmpty ())
      delete criticalList_ ().get ();
d392 1
a392 1
// Implementation of class PclMgr.
d395 3
a397 1
WitPclMgr::WitPclMgr (WitProblem * theProblem):
d399 6
a404 6
      WitProbAssoc    (theProblem),
      revPgdCritList_ (myProblem ()),
      curDemand_      (NULL),
      curShipPer_     (-1),
      shortPart_      (NULL),
      shortPer_       (-1)
d410 1
a410 1
WitPclMgr::~WitPclMgr ()
a411 1
   deleteContents (revPgdCritList_);
d416 1
a416 1
void WitPclMgr::initSoln ()
d423 2
a424 1
   deleteContents (revPgdCritList_);
d429 1
a429 1
void WitPclMgr::preIncAlloc (WitDemand * theDemand, WitPeriod shipPer)
d442 1
a442 1
void WitPclMgr::recFundShortage (WitPart * thePart, WitPeriod thePer)
d453 1
a453 1
void WitPclMgr::recRestShortage ()
d461 1
a461 1
void WitPclMgr::postCmqs ()
d470 1
a470 1
   revPgdCritList_.push (thePclEl);
a476 34

void WitPclMgr::getPgdCritList (WitObjStack <WitPclEl> & thePgdCritList)
   {
   thePgdCritList.revCopyFrom (revPgdCritList_);
   }

//------------------------------------------------------------------------------

void WitPclMgr::print ()
   {
   WitObjStack <WitPclEl> thePgdCritList (myProblem ());
   WitPclEl *             thePclEl;

   getPgdCritList (thePgdCritList);

   fprintf (solnFile (),
      "\n"
      "Pegged Critical List:\n"
      "\n"
      "   -------------------------\n"
      "   Part  Dem  Per  Part  Per\n"
      "   -------------------------\n");

   while (thePgdCritList.pop (thePclEl))
      fprintf (solnFile (),
         "   %4s  %3s  %3d  %4s  %3d\n",
         thePclEl->myDemand ()->demandedPartName ().myCstring (),
         thePclEl->myDemand ()->demandName ()      .myCstring (),
         thePclEl->myShipPer (),
         thePclEl->critPart ()->partName ()        .myCstring (),
         thePclEl->critPer ());
   }

//------------------------------------------------------------------------------
@


1.103
log
@Pegged critical list.
@
text
@d110 1
a110 1
   stronglyAssert (myGlobalComp ()->compPgdCritList ());
d121 1
a121 1
   stronglyAssert (not myGlobalComp ()->compPgdCritList ());
d453 4
a456 2
   witAssert (theDemand != NULL);
   witAssert (shipPer   != -1);
a459 2
   shortPart_  = NULL;
   shortPer_   = -1;
d475 1
a475 1
void WitPclMgr::recNonFundShortage ()
d547 4
@


1.102
log
@Pegged Critical List.
@
text
@d425 2
a426 2
      blockPart_      (NULL),
      blockPer_       (-1)
d443 2
a444 2
   blockPart_  = NULL;
   blockPer_   = -1;
d458 2
d464 1
a464 1
void WitPclMgr::setBlockPt (WitPart * thePart, WitPeriod thePer)
d469 10
a478 2
   blockPart_ = thePart;
   blockPer_  = thePer;
d487 1
a487 1
   if (blockPart_ == NULL)
d490 1
a490 1
   thePclEl = new WitPclEl (curDemand_, curShipPer_, blockPart_, blockPer_);
d494 2
a495 2
   blockPart_ = NULL;
   blockPer_  = -1;
@


1.101
log
@Tie Breaking Prop-Rt.
@
text
@d18 2
a19 2
//
// These classes belong to the heuristic allocation subsystem.
d24 2
d29 1
d48 2
a49 1
      myPegger_    (NULL)
d59 1
d69 1
a69 1
   witAssert (myGlobalComp ()->perfPegging ());
d71 1
a71 1
   witAssert (myPegger_ == NULL);
d94 1
a94 1
   witAssert (not myGlobalComp ()->perfPegging ());
d96 1
a96 1
   witAssert (myPegger_ != NULL);
d108 24
d414 130
@


1.100
log
@Fixed a bug in PIP that was revealed by testing double precision.
@
text
@d29 1
a29 1
#include <PipSysMgr.h>
@


1.99
log
@Double Precision.
@
text
@d296 1
a296 1
   witAssert (qty >= NET_TOL);
@


1.98
log
@Removed the "pip" attribute.
@
text
@d176 2
a177 2
      WitDemand *           theDemand,
      WitFlexVec <double> & shipVolArg)
d196 2
a197 2
      WitOperation *        theOpn,
      WitFlexVec <double> & execVolArg)
d205 2
a206 2
      WitSubEntry *         theSub,
      WitFlexVec <double> & subVolArg)
@


1.97
log
@Continued implementation of PIP.
@
text
@a149 4

   if (myGlobalComp ()->pip ())
      if (myProblem ()->myHeurVariant ()->isCurrent ())
         myProblem ()->myPipSysMgr ()->buildPegging ();
@


1.96
log
@Continued implementation of PIP.
@
text
@d29 1
a29 1
#include <PipMgr.h>
d153 1
a153 1
         myProblem ()->myPipMgr ()->buildPegging ();
@


1.95
log
@Continued implementation of PIP.
@
text
@d29 1
a30 1
#include <PipMgr.h>
@


1.94
log
@Continued implementation of PIP.
@
text
@d30 1
d150 4
@


1.93
log
@Continued implementation of post-implosion pegging.
@
text
@d29 1
a29 1
#include <Dated.h>
d213 1
a213 1
      WitList <WitDatedPart> & criticalListArg)
d328 2
a329 2
         WitProblem *                       theProblem,
         WitRef <WitList <WitDatedPart> > & criticalListArg):
d360 1
a360 1
   WitDatedPart * theDP;
d368 1
a368 1
   theDP = new WitDatedPart (culpritPart_, culpritPeriod_);
d370 1
a370 1
   criticalList_ ().append (theDP);
@


1.92
log
@Continued implementation of post-implosion pegging.
@
text
@a28 1
#include <Part.h>
@


1.91
log
@Continued implementation of post-implosion pegging.
@
text
@a31 1
#include <RefMapI.h>
@


1.90
log
@Continued implementation of proportionate routing.
@
text
@a31 1
#include <ScheduleI.h>
d35 1
@


1.89
log
@Internal changes.
@
text
@a33 1
#include <RefI.h>
@


1.88
log
@Internal changes.
@
text
@d91 1
a91 1
   witAssert (! myGlobalComp ()->perfPegging ());
d132 1
a132 1
   if (! active ())
d384 1
a384 1
   while (!  criticalList_ ().isEmpty ())
@


1.87
log
@Continued implementation of Single-Source.
@
text
@d107 1
a107 1
   start (witFALSE);
d114 1
a114 1
   start (witTRUE);
d123 1
a123 1
      WitBoolean  asapMultiExec)
d156 1
a156 1
void WitHeurAllMgr::printMeDir (WitBoolean asapMultiExec)
d223 1
a223 1
void WitHeurAllMgr::start (WitBoolean forOpt)
d340 1
a340 1
   listed_.allocate (myProblem (), witFALSE);
d375 1
a375 1
   listed_ (culpritPart_)[culpritPeriod_] = witTRUE;
@


1.86
log
@Continued implementation of Single-Source.
@
text
@d187 2
a188 2
      WitDemand *           theDemand,
      WitPegSite *          thePegSite)
d192 1
a192 1
   myPegger_->loadDataFrom (theDemand, thePegSite);
@


1.85
log
@Continued implementation of single-source.
@
text
@d26 1
a26 1
#include <PegMgr.h>
d47 1
a47 1
      myPegMgr_    (NULL)
d57 1
a57 1
   delete myPegMgr_;
d68 1
a68 1
   witAssert (myPegMgr_ == NULL);
d73 1
a73 1
   myPegMgr_ = new WitPegMgr (myProblem ());
d80 1
a80 1
   witAssert (myPegMgr_ != NULL);
d82 1
a82 1
   myPegMgr_->clear ();
d93 1
a93 1
   witAssert (myPegMgr_ != NULL);
d95 1
a95 1
   delete myPegMgr_;
d97 1
a97 1
   myPegMgr_ = NULL;
d172 1
a172 1
   myPegMgr_->print ();
d186 11
d239 1
a239 1
         myPegMgr_, 
@


1.84
log
@Continued implementation of Single-Source.
@
text
@d35 1
d163 1
a163 1
      myMsgFac () ("incHeurMeDirMsg", myMsgFac ()[theMeDirFragID]);
d268 1
a268 1
      myDataRepos_ (* new WitDataRepos (myProblem ())),
d273 1
d280 1
a280 1
   delete & myDataRepos_;
d289 1
a289 1
   myDataRepos_.saveVal (reqVol_ (thePart)[thePer]);
d295 1
a295 1
      myDataRepos_.saveVal (firstPer_ (thePart));
d302 1
a302 1
      myDataRepos_.saveVal (lastPer_ (thePart));
d312 1
a312 1
   myDataRepos_.restore ();
@


1.83
log
@Continued implementation of single-source.
@
text
@d32 1
d325 1
a325 2
      culpritPeriod_ (0),
      listed_        (* new WitSchedule <WitPart, WitBoolean>)
a333 1
   delete & listed_;
@


1.82
log
@Continued implementation of single-source.
@
text
@d356 1
a356 1
   if (listed_ (culpritPart_, culpritPeriod_))
d363 1
a363 1
   listed_ (culpritPart_, culpritPeriod_) = witTRUE;
@


1.81
log
@Continued implementation of single source.
@
text
@d32 2
a44 1
      myAccFlag_   (new WitAccFlag),
a55 1
   delete myAccFlag_;
d123 1
a123 3
   witAssert (active ());

   return myHeurAtor_->inc (theDemand, thePer, desIncVol, asapMultiExec);
d138 2
a145 2
   witAssert (active ());

d147 1
a147 1
      myHeurAtor_->enforceStockSLBs ();
d175 35
d221 35
a255 1
   myHeurAtor_ = new WitHeurAtor (myProblem (), myAccFlag_, myPegMgr_, forOpt);
d317 2
a318 2
         WitProblem * theProblem,
         WitAccFlag * theAccFlag):
d322 1
a322 1
      myAccFlag_     (theAccFlag),
d361 1
a361 1
   criticalList (myGlobalComp ()).append (theDP);
d372 2
a373 2
   while (!   criticalList (myGlobalComp ()).isEmpty ())
      delete criticalList (myGlobalComp ()).get ();
@


1.80
log
@Continued preliminary work on single source.
@
text
@d31 1
a31 1
#include <Archive.h>
d195 1
a195 1
WitReqSched::WitReqSched (WitHeurAtor * theHeurAtor):
d197 1
a197 1
      WitProbAssoc (theHeurAtor),
d199 1
a199 1
      myHeurAtor_  (theHeurAtor),
d210 1
d219 1
a219 1
   myHeurAtor_->myDblArch ()->saveVal (reqVol_ (thePart)[thePer]);
d225 1
a225 1
      myHeurAtor_->myPerArch ()->saveVal (firstPer_ (thePart));
d232 1
a232 1
      myHeurAtor_->myPerArch ()->saveVal (lastPer_ (thePart));
d236 7
@


1.79
log
@Began implementation of object iteration.
@
text
@d29 1
d250 1
a250 1
      listed_        (myProblem (), witFALSE)
d252 1
d259 1
@


1.78
log
@Fixed bug in SSR:
   Needed to reserve stock when it was getting consumed in a period where
   stock reallocation was disallowed.

Fixed bug in SSR:
   Failed to create SsrPt in periods where explosion was not allowed, but
   requirements could still be filled by exploding in an earlier period.

Put implementation of class AvailSched into its own .C file.
@
text
@d31 1
@


1.77
log
@Moved pegging output to comprehensive implosion solution output.
Fixed bug: Pegging was being attempted during stock bounds enforcement.
@
text
@a15 1
//    AvailSched
a26 2
#include <AvSched.h>
#include <SsrMgr.h>
a29 1
#include <Dense.h>
a186 438
   }

//------------------------------------------------------------------------------
// Implementation of class AvailSched.
//------------------------------------------------------------------------------

WitAvailSched::WitAvailSched (WitHeurAtor * theHeurAtor):

      WitProbAssoc    (theHeurAtor),

      myHeurAtor_     (theHeurAtor),
      incAvailVol_    (myProblem (), 0.0),
      lastDecPer_     (myProblem (), -1),
      incResStockVol_ (),
      mandStockRe_    (myGlobalComp ()->mandStockRe ()),
       selStockRe_    (myGlobalComp ()-> selStockRe ())
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      copyInto (incAvailVol_ (thePart), thePart->supplyVol ());

   if (respectStockSLBs ())
      incResStockVol_.allocate (myProblem (), 0.0);
   }

//------------------------------------------------------------------------------

WitAvailSched::~WitAvailSched ()
   {
   }

//------------------------------------------------------------------------------

void WitAvailSched::netWoSR (
      WitPart * thePart,
      WitPeriod reqPer,
      double &  theReqVol)
   {
   if (srAllowedFrom (thePart, reqPer))
      netWoSRWoRes  (thePart, reqPer, theReqVol);
   else
      netWoSRAndRes (thePart, reqPer, theReqVol);
   }

//------------------------------------------------------------------------------

void WitAvailSched::netWoSRAndRes (
      WitPart * thePart,
      WitPeriod reqPer,
      double &  theReqVol)
   {
   WitPeriod thePer;
   double    cumIncAv;
   double    deltaVol;

   witAssert (theReqVol >= NET_TOL);

   witAssert (! mandStockRe_);

   cumIncAv =
      selStockRe_?
         - allocedVol (thePart, reqPer):
         0.0;

   for (thePer = reqPer; thePer >= 0; thePer --)
      {
      if (thePer < reqPer)
         if (! thePart->canStock (thePer))
            return;

      cumIncAv += incAvailVol_ (thePart, thePer);

      if (cumIncAv < NET_TOL)
         continue;

      deltaVol   = min (theReqVol, cumIncAv);

      theReqVol -= deltaVol;

      allocWithRes (thePart, thePer, reqPer, deltaVol);

      if (theReqVol < NET_TOL)
         return;

      cumIncAv = 0.0;
      }
   }

//------------------------------------------------------------------------------

WitPeriod WitAvailSched::netAndRoll (
      WitPart * thePart, 
      WitPeriod reqPer,
      double &  theReqVol,
      double &  rollVol)
   {
   WitPeriod rollPer;

   witAssert (theReqVol >= NET_TOL);

   rollVol = availToNet (thePart, reqPer, theReqVol);

   if (rollVol < NET_TOL)
      return -1;

   theReqVol -= rollVol;

   addToIncAvailVol (thePart, reqPer, - rollVol);

   rollPer = rollPeriod (thePart, reqPer);

   if (rollPer >= 0)
      addToIncAvailVol (thePart, rollPer, rollVol);

   return rollPer;
   }

//------------------------------------------------------------------------------

void WitAvailSched::alloc (
      WitPart * thePart,
      WitPeriod resPer,
      WitPeriod allocPer,
      double    allocVol)
   {
   if (srAllowedFrom (thePart, allocPer))
      addToIncAvailVol (thePart, allocPer, - allocVol);
   else
      allocWithRes (
         thePart,
         resPer,
         allocPer,
         allocVol);
   }

//------------------------------------------------------------------------------

void WitAvailSched::resConsStock (WitMaterial * theMat, WitPeriod consPer)
   {
   WitPeriod resPer;
   double    resVol;

   witAssert (selStockRe_);

   resPer = consPer;

   while (incAvailVol_ (theMat, consPer) < - NET_TOL)
      {
      resPer --;

      if ((resPer < 0) || theMat->mandEC ()[resPer])
         {
         if (DEVELOPMENT)
            myMsgFac () ("unmatchedRedWmsg",
               theMat->partName (),
               consPer,
               - incAvailVol_ (theMat, consPer));

         return;
         }

      if (incAvailVol_ (theMat, resPer) < NET_TOL)
         continue;

      resVol =
         min (
              incAvailVol_ (theMat, resPer),
            - incAvailVol_ (theMat, consPer));

      reserveStock (theMat, resPer, consPer, resVol);
      }
   }

//------------------------------------------------------------------------------

void WitAvailSched::reserveStock (
      WitMaterial * theMat,
      WitPeriod     resPer,
      WitPeriod     relPer,
      double        resVol)
   {
   witAssert (resPer < relPer);

   addToIncAvailVol    (theMat, resPer, - resVol);

   if (relPer < nPeriods ())
      addToIncAvailVol (theMat, relPer,   resVol);

   if (! respectStockSLBs ())
      return;

   if (myHeurAtor_->tempMode ())
      return;

   incResStockVol_     (theMat, resPer) += resVol;

   if (relPer < nPeriods ())
      incResStockVol_  (theMat, relPer) -= resVol;
   }

//------------------------------------------------------------------------------

void WitAvailSched::addToIncAvailVol (
      WitPart * thePart, 
      WitPeriod thePer, 
      double    deltaVol)
   {
   WitMaterial * theMat;

   double & incAvailVolVar = incAvailVol_ (thePart, thePer);

   if (myHeurAtor_->tempMode ())
      myHeurAtor_->myDblArch ()->saveVal (incAvailVolVar);

   incAvailVolVar += deltaVol;

   if (incAvailVolVar < - NET_TOL)
      if (thePart->getMyMaterial (theMat))
         if (thePer > lastDecPer_ (theMat))
            {
            if (myHeurAtor_->tempMode ())
               myHeurAtor_->myPerArch ()->saveVal (lastDecPer_ (theMat));

            lastDecPer_ (theMat) = thePer;
            }
   }

//------------------------------------------------------------------------------

void WitAvailSched::reserveAllocedStSLB (WitMaterial * theMat, WitPeriod thePer)
   {
   double allVol;
   double unresVol;

   witAssert (respectStockSLBs ());

   if (! mandStockRe_)
      return;

   allVol = allocedVol (theMat, thePer);

   if (allVol < NET_TOL)
      return;

   unresVol = unresStSLB (theMat, thePer);

   if (unresVol < NET_TOL)
      return;

   reserveStock (theMat, thePer, thePer + 1,  min (allVol, unresVol));
   }

//------------------------------------------------------------------------------

double WitAvailSched::unresStSLB (WitMaterial * theMat, WitPeriod thePer)
   {
   double    unresVol;
   WitPeriod incPer;

   witAssert (respectStockSLBs ());

   unresVol = theMat->stockBounds ()->softLB ()[thePer];

   for (incPer = thePer; incPer >= 0; incPer --)
      {
      if (incPer < thePer)
         if (theMat->mandEC ()[incPer])
            break;

      unresVol -= incResStockVol_ (theMat, incPer);

      if (unresVol < NET_TOL)
         return 0.0;
      }

   return unresVol;
   }

//------------------------------------------------------------------------------

void WitAvailSched::netWoSRWoRes (
      WitPart * thePart,
      WitPeriod reqPer,
      double &  theReqVol)
   {
   double allVol;
   double totReqVol;
   double availVol;
   double deltaVol;

   witAssert (theReqVol >= NET_TOL);

   allVol    = allocedVol (thePart, reqPer);

   totReqVol = theReqVol + allVol;

   availVol  = availToNet (thePart, reqPer, totReqVol);

   deltaVol  = 
      (availVol == totReqVol)?
         theReqVol:
         availVol - allVol;

   if (deltaVol < NET_TOL)
      return;

   theReqVol -= deltaVol;

   addToIncAvailVol (thePart, reqPer, - deltaVol);
   }

//------------------------------------------------------------------------------

void WitAvailSched::allocWithRes (
      WitPart * thePart,
      WitPeriod resPer,
      WitPeriod allocPer,
      double    allocVol)
   {
   WitMaterial * theMat;

   witAssert (resPer <= allocPer);

   witAssert (! mandStockRe_);

   addToIncAvailVol (thePart, allocPer, - allocVol);

   if (resPer == allocPer)
      return;

   thePart->getMyMaterial (theMat);

   witAssert (theMat != NULL);

   reserveStock (theMat, resPer, allocPer,  allocVol);
   }

//------------------------------------------------------------------------------

double WitAvailSched::availToNet (
      WitPart * thePart, 
      WitPeriod reqPer,
      double    theReqVol)
   {
   double    availVol;
   WitPeriod thePer;
   double    theIncAvailVol;

   witAssert (theReqVol >= NET_TOL);

   availVol = 0.0;

   for (thePer = reqPer; thePer >= 0; thePer --)
      {
      if (thePer < reqPer)
         if (! thePart->canStock (thePer))
            return availVol;

      theIncAvailVol = incAvailVol_ (thePart, thePer);

      if (theIncAvailVol == 0.0)
         continue;

      availVol += theIncAvailVol;

      if (availVol >= theReqVol - NET_TOL)
         return theReqVol;
      }

   return availVol;
   }

//------------------------------------------------------------------------------

double WitAvailSched::allocedVol (WitPart * thePart, WitPeriod reqPer)
   {
   WitMaterial * theMat;
   double        curPreAllVol;
   double        maxPreAllVol;
   WitPeriod     thePer;

   if (! thePart->getMyMaterial (theMat))
      return 0.0;

   curPreAllVol = 0.0;
   maxPreAllVol = 0.0;

   for (thePer = reqPer + 1; thePer <= lastDecPer_ (theMat); thePer ++)
      {
      if (theMat->mandEC ()[thePer - 1])
         break;

      curPreAllVol -= incAvailVol_ (theMat, thePer);

      setToMax (maxPreAllVol, curPreAllVol);
      }

   return maxPreAllVol;
   }

//------------------------------------------------------------------------------

WitPeriod WitAvailSched::rollPeriod (WitPart * thePart, WitPeriod fromPer)
   {
   WitMaterial * theMat;
   WitPeriod     thePer;

   if (thePart->getMyMaterial (theMat))
      if (fromPer < lastDecPer_ (theMat))
         for (thePer = fromPer + 1; thePer < nPeriods (); thePer ++)
            {
            if (! thePart->canStock (thePer - 1))
               break;

            if (incAvailVol_ (thePart, thePer) < - NET_TOL)
               return thePer;
            }

   return -1;
   }

//------------------------------------------------------------------------------

WitBoolean WitAvailSched::srAllowedFrom (WitPart * thePart, WitPeriod thePer)
   {
   WitMaterial * theMat;

   if (mandStockRe_)
      return witTRUE;

   if (! selStockRe_)
      return witFALSE;

   if (! thePart->getMyMaterial (theMat))
      return witFALSE;

   return myHeurAtor_->mySsrMgr ()->srAllowedFrom (theMat, thePer);
@


1.76
log
@Fixed bug:
   Selective Stock Reallocation was doing unrequested build-ahead.
@
text
@d170 9
@


1.75
log
@Continued implementation of selective stock reallocation.
@
text
@d323 1
d327 1
a327 2
   if (incAvailVol_ (theMat, consPer) >= - NET_TOL)
      return;
d329 1
a329 3
   resPer = consPer - 1;

   while (witTRUE)
d331 1
a331 3
      witAssert (resPer >= 0);

      witAssert (! theMat->mandEC ()[resPer]);
d333 18
a350 2
      if (myHeurAtor_->mySsrMgr ()->srAllowedTo (theMat, resPer))
         break;
d352 1
a352 1
      resPer --;
a353 2

   reserveStock (theMat, resPer, consPer, - incAvailVol_ (theMat, consPer));
@


1.74
log
@Continued implementation of selective stock reallocation.
@
text
@d221 1
a221 1
   if (srAllowed (thePart, reqPer))
d308 1
a308 1
   if (srAllowed (thePart, allocPer))
d320 28
d390 1
a390 1
      if (thePart->isaMaterial (theMat))
d503 1
a503 1
   thePart->isaMaterial (theMat);
d554 1
a554 1
   if (! thePart->isaMaterial (theMat))
d580 1
a580 1
   if (thePart->isaMaterial (theMat))
d596 1
a596 1
WitBoolean WitAvailSched::srAllowed (WitPart * thePart, WitPeriod fromPer)
d598 12
a609 4
   return
      mandStockRe_? witTRUE:
      selStockRe_ ? myHeurAtor_->mySsrMgr ()->srAllowed (thePart, fromPer):
                    witFALSE;
@


1.73
log
@Tightly integrated stock reallocation and stock non-reallocation in preparation
for selective stock reallocation.
@
text
@d29 1
d195 3
a197 1
      incResStockVol_ ()
d216 1
a216 1
void WitAvailSched::net (
d221 2
a222 2
   if (myGlobalComp ()->stockRealloc ())
      netWoRealloc    (thePart, reqPer, theReqVol);
d224 1
a224 1
      netWithPrealloc (thePart, reqPer, theReqVol);
d229 1
a229 1
void WitAvailSched::netWithPrealloc (
d235 1
d240 1
a240 8
   for (thePer = reqPer; thePer >= 0; thePer --)
      {
      if (thePer < reqPer)
         if (! thePart->canStock (thePer))
            return;

      if (incAvailVol_ (thePart, thePer) < NET_TOL)
         continue;
d242 4
a245 25
      deltaVol   = min (theReqVol, incAvailVol_ (thePart, thePer));

      theReqVol -= deltaVol;

      allocWithRes (thePart, thePer, reqPer, deltaVol);

      if (theReqVol < NET_TOL)
         return;
      }
   }

//------------------------------------------------------------------------------

void WitAvailSched::netWithPreallocWoRealloc (
      WitPart * thePart,
      WitPeriod reqPer,
      double &  theReqVol)
   {
   WitPeriod thePer;
   double    cumIncAv;
   double    deltaVol;

   witAssert (theReqVol >= NET_TOL);

   cumIncAv = - allocedVol (thePart, reqPer);
d302 5
a306 4
double WitAvailSched::availToNet (
      WitPart * thePart, 
      WitPeriod reqPer,
      double    theReqVol)
d308 8
a315 52
   double    availVol;
   WitPeriod thePer;
   double    theIncAvailVol;

   witAssert (theReqVol >= NET_TOL);

   availVol = 0.0;

   for (thePer = reqPer; thePer >= 0; thePer --)
      {
      if (thePer < reqPer)
         if (! thePart->canStock (thePer))
            return availVol;

      theIncAvailVol = incAvailVol_ (thePart, thePer);

      if (theIncAvailVol == 0.0)
         continue;

      availVol += theIncAvailVol;

      if (availVol >= theReqVol - NET_TOL)
         return theReqVol;
      }

   return availVol;
   }

//------------------------------------------------------------------------------

void WitAvailSched::allocWithRes (
      WitPart *     thePart,
      WitPeriod     resPer,
      WitPeriod     allocPer,
      double        allocVol)
   {
   WitMaterial * theMat;

   witAssert (resPer <= allocPer);

   witAssert (! myGlobalComp ()->stockRealloc ());

   addToIncAvailVol (thePart, allocPer, - allocVol);

   if (resPer == allocPer)
      return;

   thePart->isaMaterial (theMat);

   witAssert (theMat != NULL);

   reserveStock (theMat, resPer, allocPer,  allocVol);
d381 1
a381 1
   if (! myGlobalComp ()->stockRealloc ())
d425 1
a425 1
void WitAvailSched::netWoRealloc (
d458 61
d564 10
@


1.72
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d189 1
a189 1
      WitProbAssoc (theHeurAtor),
d191 4
a194 3
      myHeurAtor_  (theHeurAtor),
      incAvail_    (myProblem (), 0.0),
      lastDecPer_  (myProblem (), -1)
d199 4
a202 1
      copyInto (incAvail_ (thePart), thePart->supplyVol ());
d213 46
a258 1
void WitAvailSched::netWithPreAll (
d263 3
a265 4
   double preAllVol;
   double totReqVol;
   double availVol;
   double deltaVol;
d269 9
a277 1
   preAllVol = preallocVol (thePart, reqPer);
d279 2
a280 1
   totReqVol = theReqVol + preAllVol;
d282 1
a282 1
   availVol  = availToNet (thePart, reqPer, totReqVol);
d284 1
a284 4
   deltaVol  = 
      (availVol == totReqVol)?
         theReqVol:
         availVol - preAllVol;
d286 1
a286 2
   if (deltaVol < NET_TOL)
      return;
d288 2
a289 1
   theReqVol -= deltaVol;
d291 2
a292 1
   addToIncAvail (thePart, reqPer, - deltaVol);
d314 1
a314 1
   addToIncAvail (thePart, reqPer, - rollVol);
d319 1
a319 1
      addToIncAvail (thePart, rollPer, rollVol);
d333 1
a333 1
   double    theIncAvail;
d345 1
a345 1
      theIncAvail = incAvail (thePart, thePer);
d347 1
a347 1
      if (theIncAvail == 0.0)
d350 1
a350 1
      availVol += theIncAvail;
d361 31
a391 4
void WitAvailSched::addToNextIncAvail (
      WitMaterial * theMat, 
      WitPeriod     thePer, 
      double        deltaVol)
d393 12
a404 1
   witAssert (! theMat->mandEC ()[thePer]);
d406 4
a409 2
   if (thePer < lastPeriod ())
      addToIncAvail (theMat, thePer + 1, deltaVol);
d414 1
a414 1
void WitAvailSched::addToIncAvail (
d421 1
a421 1
   double & incAvailVar = incAvail_ (thePart, thePer);
d424 1
a424 1
      myHeurAtor_->myDblArch ()->saveVal (incAvailVar);
d426 1
a426 1
   incAvailVar += deltaVol;
d428 1
a428 1
   if (incAvailVar < - NET_TOL)
d441 85
a525 1
double WitAvailSched::preallocVol (WitPart * thePart, WitPeriod reqPer)
a526 1
   WitPeriod     lastPer;
d532 2
a533 4
   lastPer = 
      thePart->isaMaterial (theMat)?
         lastDecPer_ (theMat):
         reqPer;
d538 1
a538 1
   for (thePer = reqPer + 1; thePer <= lastPer; thePer ++)
d540 1
a540 1
      if (! thePart->canStock (thePer - 1))
d543 1
a543 1
      curPreAllVol -= incAvail (thePart, thePer);
d565 1
a565 1
            if (incAvail (thePart, thePer) < - NET_TOL)
@


1.71
log
@Created and used Archive template.
@
text
@d33 1
d189 1
a189 1
      WitProbAssoc    (theHeurAtor),
d191 3
a193 5
      myHeurAtor_     (theHeurAtor),
      incAvail_       (myProblem (), 0.0),
      lastDecPer_     (myProblem (), -1),
      incAvailArch_   (myProblem ()),
      lastDecPerArch_ (myProblem ())
a208 8
void WitAvailSched::restore ()
   {
   incAvailArch_  .restoreAllVals ();
   lastDecPerArch_.restoreAllVals ();
   }

//------------------------------------------------------------------------------

d329 1
a329 1
      incAvailArch_.saveVal (incAvailVar);
d338 1
a338 1
               lastDecPerArch_.saveVal (lastDecPer_ (theMat));
d401 1
d407 1
a407 7
      lastPer_     (myProblem (), -1),
      reqVolArch_  (myProblem ()),
      flPerArch_   (myProblem ()),

      reqVolsToReset_   (myProblem ()),
      firstPersToReset_ (myProblem ()),
      lastPersToReset_  (myProblem ())
d423 1
a423 1
   reqVolArch_.saveVal (reqVol_ (thePart)[thePer]);
d429 1
a429 1
      flPerArch_.saveVal (firstPer_ (thePart));
d436 1
a436 1
      flPerArch_.saveVal (lastPer_ (thePart));
a439 8
   }

//------------------------------------------------------------------------------

void WitReqSched::clear ()
   {
   reqVolArch_.restoreAllVals ();
   flPerArch_ .restoreAllVals ();
@


1.70
log
@Minor change.
@
text
@a15 1
//    AllocMode
a27 1
#include <AllMode.h>
d183 1
a183 1
// Implementation of class AllocMode.
d186 1
a186 1
WitAllocMode::WitAllocMode (WitHeurAtor * theHeurAtor, WitAccFlag * theAccFlag):
d189 1
a189 2
      
      myAccFlag_      (theAccFlag),
d191 4
a194 6
      temp_           (witFALSE),
      tempExecVol_    (myProblem (), 0.0),
      alteredOpnPers_ (myProblem ()),
      permAvailSched_ (NULL),
      tempAvailSched_ (NULL),
      curAvailSched_  (NULL)
d196 1
a196 1
   WitAvailSched::construct (permAvailSched_, tempAvailSched_, myProblem ());
d198 2
a199 1
   curAvailSched_ = permAvailSched_;
d204 1
a204 30
WitAllocMode::~WitAllocMode ()
   {
   WitAvailSched::destruct (tempAvailSched_, permAvailSched_);
   }

//------------------------------------------------------------------------------

void WitAllocMode::enterTempMode ()
   {
   witAssert (! temp_);

   temp_          = witTRUE;
   curAvailSched_ = tempAvailSched_;

   resetTempData ();
   }

//------------------------------------------------------------------------------

void WitAllocMode::leaveTempMode ()
   {
   witAssert (temp_);

   temp_          = witFALSE;
   curAvailSched_ = permAvailSched_;
   }

//------------------------------------------------------------------------------

void WitAllocMode::resetTempData ()
a205 51
   WitOperation * theOpn;
   WitPeriod      thePer;

   tempAvailSched_->reset ();

   while (alteredOpnPers_.pop (theOpn, thePer))
      tempExecVol_ (theOpn, thePer) = execVol (theOpn)[thePer];
   }

//------------------------------------------------------------------------------

void WitAllocMode::incExecVol (
      WitOperation * theOpn,
      WitPeriod      thePer,
      double         delta)
   {
   if (temp_)
      tempExecVol_ (theOpn)         [thePer] += delta;
   else
      execVol      (theOpn).elemRef (thePer) += delta;

   alteredOpnPers_.push (theOpn, thePer);
   }

//------------------------------------------------------------------------------
// Implementation of class AvailSched.
//------------------------------------------------------------------------------

void WitAvailSched::construct (
      WitAvailSched * & firstAvailSched,
      WitAvailSched * & secondAvailSched,
      WitProblem *      theProblem)
   {
   firstAvailSched  = new WitAvailSched (theProblem);
   secondAvailSched = new WitAvailSched (theProblem);

   firstAvailSched-> companion_ = secondAvailSched;
   secondAvailSched->companion_ = firstAvailSched;
   }

//------------------------------------------------------------------------------

void WitAvailSched::destruct (
      WitAvailSched * & firstAvailSched,
      WitAvailSched * & secondAvailSched)
   {
   delete firstAvailSched;
   delete secondAvailSched;

   firstAvailSched  = NULL;
   secondAvailSched = NULL;
d210 1
a210 1
void WitAvailSched::reset ()
d212 2
a213 2
   resetOn (            altPPs_);
   resetOn (companion_->altPPs_);
d335 1
a335 1
   double & theIncAvailVal = incAvail_ (thePart, thePer);
d337 2
a338 2
   if (theIncAvailVal == companion_->incAvail (thePart, thePer))
      altPPs_.push (thePart, thePer);
d340 1
a340 1
   theIncAvailVal += deltaVol;
d342 1
a342 1
   if (theIncAvailVal < - NET_TOL)
d344 4
a347 2
         setToMax (lastDecPer_ (theMat), thePer);
   }
d349 2
a350 38
//------------------------------------------------------------------------------

WitAvailSched::WitAvailSched (WitProblem * theProblem):
      WitProbAssoc (theProblem),

      companion_   (NULL),

      incAvail_    (myProblem (), 0.0),
      lastDecPer_  (myProblem (), -1),
      altPPs_      (myProblem ())
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      copyInto (incAvail_ (thePart), thePart->supplyVol ());
   }

//------------------------------------------------------------------------------

WitAvailSched::~WitAvailSched ()
   {
   }

//------------------------------------------------------------------------------

void WitAvailSched::resetOn (WitPartPerStack & thePPs)
   {
   WitPart *     thePart;
   WitPeriod     thePer;
   WitMaterial * theMat;

   while (thePPs.pop (thePart, thePer))
      {
      incAvail_ (thePart, thePer) = companion_->incAvail (thePart, thePer);

      if (thePart->isaMaterial (theMat))
         lastDecPer_ (theMat) = companion_->lastDecPer_ (theMat);
      }
d415 7
a421 1
      lastPer_     (myProblem (), -1)
d433 1
a433 1
void WitReqSched::init (double qty)
d435 1
a435 4
   WitPart * topPartVal;
   WitPeriod topPerVal;
   WitPart * thePart;
   WitPeriod thePer;
d437 1
a437 2
   topPartVal = myHeurAtor_->topPart ();
   topPerVal  = myHeurAtor_->topPer  ();
d439 3
a441 1
   forEachElDense (thePart, topPartVal->belowList ())
d443 4
a446 2
      if (lastPer_ (thePart) == -1)
         continue;
d448 3
a450 4
      for ( thePer =  firstPer_ (thePart); 
            thePer <= lastPer_  (thePart);
            thePer ++)
         reqVol_ (thePart, thePer) = 0.0;
d452 1
a452 2
      firstPer_ (thePart) = nPeriods ();
      lastPer_  (thePart) = -1;
a453 4

   reqVol_   (topPartVal)[topPerVal] = qty;
   firstPer_ (topPartVal)            = topPerVal;
   lastPer_  (topPartVal)            = topPerVal;
d458 1
a458 1
void WitReqSched::addTo (WitPart * thePart, WitPeriod thePer, double qty)
d460 2
a461 6
   witAssert (qty >= NET_TOL);

   reqVol_ (thePart)[thePer] += qty;

   setToMin (firstPer_ (thePart), thePer);
   setToMax (lastPer_  (thePart), thePer);
@


1.69
log
@Continued implementation of pegging.
@
text
@d66 1
a66 1
   witAssert (myGlobalComp ()->peggingNeeded ());
d91 1
a91 1
   witAssert (! myGlobalComp ()->peggingNeeded ());
@


1.68
log
@Continued implementation of pegging.
@
text
@d66 1
a66 1
   witAssert (myGlobalComp ()->pegging ());
d91 1
a91 1
   witAssert (! myGlobalComp ()->pegging ());
@


1.67
log
@Continued implementation of pegging.
@
text
@d46 1
a46 2
      myOpnPegMgr_ (NULL),
      mySubPegMgr_ (NULL)
d56 1
a56 2
   delete mySubPegMgr_;
   delete myOpnPegMgr_;
d62 1
a62 1
void WitHeurAllMgr::startUpPegging ()
d68 1
a68 1
   witAssert (myOpnPegMgr_ == NULL);
d71 1
a71 1
      theDemand->startUpPegging ();
d73 1
a73 2
   myOpnPegMgr_ = new WitPegMgr <WitOperation> (myProblem ());
   mySubPegMgr_ = new WitPegMgr <WitSubEntry>  (myProblem ());
d80 1
a80 1
   witAssert (myOpnPegMgr_ != NULL);
d82 1
a82 2
   myOpnPegMgr_->clear ();
   mySubPegMgr_->clear ();
d93 1
a93 1
   witAssert (myOpnPegMgr_ != NULL);
d95 1
a95 2
   delete mySubPegMgr_;
   delete myOpnPegMgr_;
d97 1
a97 2
   mySubPegMgr_ = NULL;
   myOpnPegMgr_ = NULL;
a131 24
void WitHeurAllMgr::setUpPeggedIncAlloc (WitObjStack <WitOpnPegEl> & thePegEls)
   {
   witAssert (myOpnPegMgr_ != NULL);

   witAssert (active ());

   myOpnPegMgr_->setUpPeggedIncAlloc (thePegEls);
   myHeurAtor_ ->setUpPeggedIncAlloc (thePegEls);
   }

//------------------------------------------------------------------------------

void WitHeurAllMgr::setUpPeggedIncAlloc (WitObjStack <WitSubPegEl> & thePegEls)
   {
   witAssert (mySubPegMgr_ != NULL);

   witAssert (active ());

   mySubPegMgr_->setUpPeggedIncAlloc (thePegEls);
   myHeurAtor_ ->setUpPeggedIncAlloc (thePegEls);
   }

//------------------------------------------------------------------------------

d181 1
a181 1
   myHeurAtor_ = new WitHeurAtor (myProblem (), myAccFlag_, forOpt);
@


1.66
log
@Continued implementation of pegging.
@
text
@d68 1
a68 1
   witAssert (myGlobalComp ()->perfPegging ());
d95 1
a95 1
   witAssert (! myGlobalComp ()->perfPegging ());
@


1.65
log
@Continued implementation of pegging.
@
text
@d68 1
a68 1
   witAssert (myGlobalComp ()->doPegging ());
d95 1
a95 1
   witAssert (! myGlobalComp ()->doPegging ());
@


1.64
log
@Initial implementation of pegging.
@
text
@d46 2
a47 1
      myPegMgr_    (NULL)
d57 2
a58 1
   delete myPegMgr_;
d70 1
a70 1
   witAssert (myPegMgr_ == NULL);
d75 12
a86 1
   myPegMgr_ = new WitPegMgr (myProblem ());
d97 1
a97 1
   witAssert (myPegMgr_ != NULL);
d99 2
a100 1
   delete myPegMgr_;
d102 2
a103 1
   myPegMgr_ = NULL;
d134 24
@


1.63
log
@Templatized consumption multi-route.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d15 7
a21 2
//    HeurAllocator
//    HeurAllPerf
d24 2
a25 2
#include <HeurAll.h>
#include <HeurAllP.h>
d28 2
a31 1
#include <AllMode.h>
d33 1
a33 6
#include <Selector.h>
#include <PmrMgr.h>
#include <CmrMgr.h>
#include <BaMgr.h>
#include <MeMgr.h>
#include <ExpRest.h>
d37 1
a37 1
// Implementation of class HeurAllocator
d40 1
a40 1
WitHeurAllocator::WitHeurAllocator (WitProblem * theProblem):
d44 3
a46 2
      myPerf_      (NULL),
      myAccFlag_   (new WitAccFlag)
d52 1
a52 1
WitHeurAllocator::~WitHeurAllocator ()
d56 1
d62 35
a96 1
void WitHeurAllocator::start ()
d103 1
a103 1
void WitHeurAllocator::startForOpt ()
d110 1
a110 1
double WitHeurAllocator::inc (
d118 1
a118 1
   return myPerf_->inc (theDemand, thePer, desIncVol, asapMultiExec);
d123 1
a123 1
void WitHeurAllocator::reset ()
d128 1
a128 1
   delete myPerf_;
d130 1
a130 1
   myPerf_ = NULL;
d137 1
a137 1
void WitHeurAllocator::finish ()
d142 1
a142 1
      myPerf_->enforceStockSLBs ();
d149 1
a149 1
void WitHeurAllocator::printMeDir (WitBoolean asapMultiExec)
d161 1
a161 1
void WitHeurAllocator::start (WitBoolean forOpt)
d172 1
a172 1
   myPerf_ = new WitHeurAllPerf (myProblem (), myAccFlag_, forOpt);
d176 1
a176 1
// Implementation of class HeurAllPerf
d179 1
a179 3
//------------------------------------------------------------------------------
// Inlines.
//------------------------------------------------------------------------------
d181 10
a190 3
inline WitPeriod WitHeurAllPerf::expPerFor (
      WitPart * thePart, 
      WitPeriod fillPer)
d192 1
a192 19
   return
      buildAhead_? 
         myBaMgr ()->selExpPer (thePart, fillPer):
         thePart   ->explosionPeriod    (fillPer);
   }

//------------------------------------------------------------------------------

inline WitBopEntry * WitHeurAllPerf::expBopEntry (
      WitPart * thePart, 
      WitPeriod expPer)
   {
   return
      multiRoute_? 
         myPmrMgr ()->selBopEntry (thePart, expPer):
         thePart    ->expBopEntry          (expPer);
   }

//------------------------------------------------------------------------------
d194 1
a194 8
inline WitPeriod WitHeurAllPerf::execPerFor (
      WitBopEntry * theBopEnt, 
      WitPeriod     expPer)
   {
   return
      multiExec_?
         myMeMgr ()->selExecPer    (theBopEnt, expPer):
         theBopEnt ->expExecPeriod ()         [expPer];
d199 1
a199 1
inline WitAvailSched * WitHeurAllPerf::curAvailSched ()
d201 1
a201 1
   return myAllocMode_->curAvailSched ();
a204 2
// Non-inlines.
//------------------------------------------------------------------------------
d206 1
a206 26
WitHeurAllPerf::WitHeurAllPerf (
         WitProblem * theProblem,
         WitAccFlag * theAccFlag,
         WitBoolean   forOpt):

      WitProbAssoc      (theProblem),

      myAllocMode_      (NULL),
      myReqSched_       (NULL),
      myHeurCritList_   (NULL),
      mySelector_       (NULL),
      myExpRest_        (NULL),
      myAccFlag_        (theAccFlag),
      multiRoute_       (witFALSE),
      buildAhead_       (witFALSE),
      multiExec_        (witFALSE),
      penExec_          (witFALSE),
      selSplit_         (witFALSE),
      finiteExecBounds_ (witFALSE),
      blocked_          (),
      topPart_          (NULL),
      topPer_           (-1),
      committing_       (witFALSE),
      nMaxCommits_      (0),
      nSelCommits_      (0),
      nBsearches_       (0)
d208 1
a208 17
   WitMaterial *  theMat;
   WitOperation * theOpn;

   if (! forOpt)
      if (myGlobalComp ()->computeCriticalList ())
         myHeurCritList_ = new WitHeurCritList (myProblem (), myAccFlag_);

   myAllocMode_ = new WitAllocMode (this, myAccFlag_);

   myReqSched_  = new WitReqSched (this);

   if (skipFailures ())
      initBlocked ();

   multiRoute_  = myGlobalComp ()->multiRoute ();

   multiExec_   = myGlobalComp ()->multiExecNeeded ();
d210 2
a211 4
   forEachMaterial (theMat, myProblem ())
      if (theMat->nstnBaNeeded () || theMat->buildAsap ())
         {
         buildAhead_ = witTRUE;
d213 1
a213 55
         break;
         }

   if (multiRoute_ || buildAhead_ || multiExec_)
      {
      mySelector_ = new WitSelector (this);

      penExec_    = mySelector ()->penExec ();
      }

   if (multiRoute_)
      {
      myPmrMgr_ = mySelector ()->myPmrMgr ();
      myCmrMgr_ = mySelector ()->myCmrMgr ();
      }

   if (buildAhead_)
      myBaMgr_    = mySelector ()->myBaMgr ();

   if (multiExec_)
      myMeMgr_    = mySelector ()->myMeMgr ();

   if (penExec_)
      myExpRest_  = mySelector ()->myExpRest ();

   if (myGlobalComp ()->penExec ())
      if (! multiRoute_)
         myMsgFac () ("penExecWoMultiRouteWmsg");

   initSoln ();

   if (stockRealloc ())
      myMsgFac () ("stockReallocMsg");

   forEachOperation (theOpn, myProblem ())
      if (! (theOpn->execBounds ()->hardUB () == -1.0))
         {
         finiteExecBounds_ = witTRUE;

         break;
         }

   if (multiSel ())
      selSplit_ = mySelector ()->selSplit ();

   if (selSplit_)
      {
      if (penExec_)
         myMsgFac () ("penExecSelSplitSmsg");

      if (critListMode ())
         myMsgFac () ("critListSelSplitSmsg");
      }

   myMsgFac () ("heurAllActiveMsg");
d218 1
a218 1
WitHeurAllPerf::~WitHeurAllPerf ()
d220 1
a220 6
   if (DEVELOPMENT)
      {
      myMsgFac ()    ("nMaxCommitsMsg", nMaxCommits_);
      
      if (multiSel ())
         myMsgFac () ("nSelCommitsMsg", nSelCommits_);
d222 2
a223 9
      myMsgFac ()    ("nBsearchesMsg",  nBsearches_);
      }

   delete mySelector_;
   delete myReqSched_;
   delete myHeurCritList_;
   delete myAllocMode_;

   myMsgFac () ("heurAllInactiveMsg");
d228 1
a228 5
double WitHeurAllPerf::inc (
      WitDemand * theDemand, 
      WitPeriod   thePer, 
      double      desIncVol,
      WitBoolean  asapMultiExec)
d230 2
a231 36
   WitPart *  thePart;
   double     demandedIncVol;
   WitBoolean prefBA;
   WitPeriod  firstPer;
   double     incVol;

   thePart = theDemand->demandedPart ();

   witAssert (desIncVol >= 0.0);
   witAssert (thePer >= 0);
   witAssert (thePer < nPeriods ());

   if (desIncVol <= NET_TOL)
      return 0.0;

   demandedIncVol =
      min (
         desIncVol,
         theDemand->cumDemandVol ()[thePer] - cumShipVol (theDemand, thePer));
            //
            // demandedIncVol is desIncVol reduced so as not to exceed
            // cumulative demand.

   if (demandedIncVol <= NET_TOL)
      return 0.0;

   prefBA = theDemand->prefBuildAhead ();

   if (myGlobalComp ()->twoWayMultiExec ())
      myMeMgr ()->setInitDirIsAsap (asapMultiExec);
   else
      witAssert (! asapMultiExec);

   firstPer = max (0, thePer - theDemand->buildAheadUB ()[thePer]);

   incVol = resAlloc (thePart, thePer, demandedIncVol, firstPer, prefBA);
d233 1
a233 2
   if (incVol >= NET_TOL)
      shipVol (theDemand).elemRef (thePer) += incVol;
d235 2
a236 12
   if (penExec_)
      myExpRest ()->replenishPsSups ();

   if (myMsgFac ().mayIssue ("incAllocMsg"))
      myMsgFac () ("incAllocMsg",
         theDemand->demandedPartName (),
         theDemand->demandName (),
         thePer,
         desIncVol,
         incVol);

   return incVol;
d241 4
a244 1
void WitHeurAllPerf::enforceStockSLBs ()
d246 2
a247 13
   WitPart * thePart;

   WitObjStack <WitPart> reversedParts (myProblem ());

   myMsgFac () ("enfStockSLBsMsg");

   if (myGlobalComp ()->prefHighStockSLBs ())
      {
      reverseCopyInto (reversedParts, myCompMgr ()->allParts ());

      while (reversedParts.pop (thePart))
         enforceStockSLBs (thePart);
      }
d249 1
a249 5
      forEachPart (thePart, myProblem ())
         enforceStockSLBs (thePart);
   }

//------------------------------------------------------------------------------
d251 1
a251 35
void WitHeurAllPerf::commitMaxQtySel (double & netQty)
   {
   double oldNetQty;
   double maxQty;

   if (penExec_)
      oldNetQty = netQty;

   curAvailSched ()->netWithPreAll (topPart (), topPer (), netQty);

   if (penExec_)
      mySelector ()->recCommitVol (oldNetQty - netQty, witFALSE);

   maxQty = findMaxQty (netQty);

   if (maxQty >= NET_TOL)
      {
      permCommit (maxQty);

      netQty -= maxQty;

      witAssert (netQty >= 0.0);

      if (penExec_)
         mySelector ()->recCommitVol (maxQty, witTRUE);
      }

   if (critListMode ())
      {
      if (penExec_)
         if (myExpRest ()->failRestShortOnly ())
            return;

      myHeurCritList ()->appendCulprit ();
      }
d255 1
a255 17

WitBoolean WitHeurAllPerf::tempCommit (double qty)
   {
   WitBoolean success;

   myAllocMode_->enterTempMode ();

   success = commit (qty);

   if (multiSel ())
      mySelector ()->postTempCommit (success);

   myAllocMode_->leaveTempMode ();

   return success;
   }

d258 4
a261 1
void WitHeurAllPerf::permCommit1SS ()
d263 2
a264 3
   witAssert (selSplit_);

   permCommit (1.0);
d266 2
a267 1
   curAvailSched ()->addToIncAvail (topPart (), topPer (), 1.0);
d272 3
a274 1
void WitHeurAllPerf::initBlocked ()
d276 2
a277 2
   WitDemand * theDemand;
   WitPart *   thePart;
d279 2
a280 14
   blocked_.allocate1D (myProblem ());

   forEachDemand (theDemand, myProblem ())
      {
      thePart = theDemand->demandedPart ();

      if (blocked_ (thePart).isAllocated ())
         continue;

      if (theDemand->demandVol () == 0.0)
         continue;

      blocked_ (thePart).allocate (myProblem (), witFALSE);
      }
d285 1
a285 1
void WitHeurAllPerf::initSoln ()
d287 2
a288 15
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachDemand (theDemand, myProblem ())
      shipVol (theDemand) = 0.0;

   forEachOperation (theOpn, myProblem ())
      execVol (theOpn) = 0.0;

   forEachSubEntry (theSub, myProblem ())
      subVol (theSub) = 0.0;

   if (critListMode ())
      myHeurCritList ()->initSoln ();
d293 4
a296 1
double WitHeurAllPerf::cumShipVol (WitDemand * theDemand, WitPeriod thePer)
d298 4
a301 2
   WitPeriod otherPer;
   double    theCumShipVol;
d303 1
a303 1
   theCumShipVol = 0.0;
d305 1
a305 2
   for (otherPer = 0; otherPer <= thePer; ++ otherPer)
      theCumShipVol += theDemand->shipVol ()[otherPer];
d307 1
a307 2
   return theCumShipVol;
   }
d309 1
a309 1
//------------------------------------------------------------------------------
d311 4
a314 10
double WitHeurAllPerf::resAlloc (
      WitPart *  thePart,
      WitPeriod  lastPer,
      double     qty,
      WitPeriod  firstPer,
      WitBoolean prefBA)
   {
   WitPeriod initPer;
   WitPeriod thePer;
   double    netQty;
d316 2
a317 1
   netQty = qty;
d319 1
a319 30
   if (firstPer == lastPer)
      {
      if (netQty > NET_TOL)
         commitMaxQty (thePart, lastPer, netQty);
      }
   else if (prefBA)
      {
      for (initPer = lastPer; initPer > firstPer; -- initPer)
         if (! thePart->canStock (initPer - 1))
            break;

      for (thePer = initPer; thePer <= lastPer; ++ thePer)
         {
         if (netQty <= NET_TOL)
            break;
      
         commitMaxQty (thePart, thePer, netQty);
         }
      }
   else
      for (thePer = lastPer; thePer >= firstPer; -- thePer)
         {
         if (netQty <= NET_TOL)
            break;
      
         commitMaxQty (thePart, thePer, netQty);

         if (! thePart->canStock (thePer - 1))
            break;
         }
d321 1
a321 1
   return qty - positivePart (netQty);
d326 1
a326 1
void WitHeurAllPerf::commitMaxQty (
d328 3
a330 2
      WitPeriod thePer,
      double &  netQty)
d332 1
a332 4
   if (skipFailures ())
      if (blocked_ (thePart).isAllocated ())
         if (blocked_ (thePart, thePer))
            return;
d334 1
a334 2
   if (DEVELOPMENT)
      nMaxCommits_ ++;
d336 1
a336 1
   witAssert (topPart_ == NULL);
d338 2
a339 2
   topPart_ = thePart;
   topPer_  = thePer;
d341 1
a341 4
   if (multiSel ())
      mySelector ()->commitMaxQty (netQty);
   else
      commitMaxQtySel (netQty);
d343 1
a343 2
   topPer_  = -1;
   topPart_ = NULL;
d345 1
a345 5
   if (skipFailures ())
      if (blocked_ (thePart).isAllocated ())
         if (netQty > SEARCH_TOL)
            blocked_ (thePart, thePer) = witTRUE;
   }
d347 2
a348 5
//------------------------------------------------------------------------------

void WitHeurAllPerf::permCommit (double qty)
   {
   WitBoolean success;
d350 1
a350 9
   witAssert (myAllocMode_->perm ());

   success = commit (qty);

   if (! success)
      myMsgFac () ("permCommitFailedFmsg", 
         topPart ()->partName (), 
         topPer (), 
         qty);
d355 4
a358 1
double WitHeurAllPerf::findMaxQty (double desQty)
d360 3
a362 11
   double     minQty;
   double     incQty;
   WitBoolean success;

   if (DEVELOPMENT)
      if (multiSel ())
         {
         nSelCommits_ ++;

         mySelector ()->printCommitMaxQtySelIA ();
         }
d364 1
a364 2
   if (desQty <= SEARCH_TOL)
      return 0.0;
d366 1
a366 1
   defSearchGrid (minQty, incQty);
d368 1
a368 1
   if (desQty <= minQty + SEARCH_TOL)
d370 3
a372 9
      success = tempCommit (desQty);
         //
         // The desired quantity is the smallest amount allowed.

      return
         success?
            desQty:
            0.0;
      }
d374 1
a374 1
   success = tempCommit (minQty);
d376 2
a377 68
   if (! success)
      return 0.0;
         //
         // The smallest amount allowed is infeasible.

   success = tempCommit (desQty);

   if (success)
      return desQty;
         //
         // The desired quantity is feasible.

   return binarySearch (desQty, minQty, incQty);
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::defSearchGrid (double & minQty, double & incQty)
   {
   WitPeriod      expPer;
   WitBopEntry *  theBopEnt;
   WitPeriod      execPer;
   WitOperation * theOpn;
   double         theEffProdRate;

   minQty = 1.0;
   incQty = 1.0;
      //
      // Default values.

   if (! myGlobalComp ()->lotSizesExist ())
      return;

   expPer = expPerFor (topPart (), topPer ());

   if (! topPart ()->explodeable (expPer))
      return;

   theBopEnt = expBopEntry (topPart (), expPer);
   execPer   = execPerFor  (theBopEnt,  expPer);

   theOpn    = theBopEnt->myOperation ();

   if (! theOpn->lotSizeMode (execPer))
      return;

   theEffProdRate = theBopEnt->effProdRate ()[execPer];

   incQty = theOpn->incLotSize ()[execPer] * theEffProdRate;

   if (myAllocMode_->curExecVol (theOpn, execPer) > FLOAT_EPSILON)
      minQty = incQty;
   else
      {
      minQty = theOpn->minLotSize ()[execPer] * theEffProdRate;

      if (minQty == 0.0)
         minQty = incQty;
      }

   if (! (isAnInteger (minQty) && isAnInteger (incQty)))
      {
      minQty = 1.0;
      incQty = 1.0;
      }
   }

//------------------------------------------------------------------------------
d379 1
a379 38
WitBoolean WitHeurAllPerf::isAnInteger (double theDbl)
   {
   return (theDbl - floor (theDbl + FLOAT_EPSILON) <= FLOAT_EPSILON);
   }

//------------------------------------------------------------------------------

double WitHeurAllPerf::binarySearch (
      double desQty,
      double minQty,
      double incQty)
   {
   int        upperGP;
   int        lowerGP;
   int        midGP;
   double     qty;
   WitBoolean success;

   if (DEVELOPMENT)
      nBsearches_ ++;

   upperGP =
      myGlobalComp ()->lotSizeGridPoint (
         minQty,
         incQty,
         desQty,
         witTRUE,
         witTRUE);

   lowerGP = 0;

   while (upperGP - lowerGP > 1)
      {
      midGP   = (lowerGP + upperGP) / 2;

      qty     = WitOperation::compLotSizeQty (minQty, incQty, midGP);

      success = tempCommit (qty);
d381 2
a382 4
      if (success)
         lowerGP = midGP;
      else
         upperGP = midGP;
d385 1
a385 3
   qty = WitOperation::compLotSizeQty (minQty, incQty, lowerGP);

   return qty;
d390 4
a393 1
WitBoolean WitHeurAllPerf::commit (double qty)
d395 1
a395 7
   WitBoolean success;

   witAssert (! committing_);

   committing_ = witTRUE;

   success     = innerCommit (qty);
d397 2
a398 6
   if (multiSel ())
      mySelector ()->postCommit ();

   committing_ = witFALSE;

   return success;
d403 4
a406 1
WitBoolean WitHeurAllPerf::innerCommit (double qty)
d408 1
a408 9
   WitPart *  fillPart;
   WitPeriod  fillPer;
   double     theReqVol;
   WitBoolean fillOK;

   if (qty <= NET_TOL)
      return witTRUE;

   myReqSched_->init (qty);
d410 1
a410 6
   forEachElDense (fillPart, topPart ()->belowList ())
      for ( fillPer =  myReqSched_->firstPer (fillPart); 
            fillPer <= myReqSched_->lastPer  (fillPart);
            fillPer ++)
         {
         theReqVol = myReqSched_->reqVol (fillPart, fillPer);
d412 2
a413 2
         if (theReqVol <= NET_TOL)
            continue;
d415 1
a415 1
         fillOK = fillReq (fillPart, fillPer, theReqVol);
d417 3
a419 10
         if (! penExec_)
            if (! fillOK)
               return witFALSE;
         }

   if (penExec_)
      if (myExpRest ()->curShort ())
         return witFALSE;

   return witTRUE;
d424 2
a425 15
WitBoolean WitHeurAllPerf::fillReq (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    theReqVol)
   {
   double netReqVol;

   witAssert (theReqVol > NET_TOL);

   netReqVol = theReqVol;

   if (stockRealloc ())
      netAndRollReq (thePart, fillPer, netReqVol);
   else
      curAvailSched ()->netWithPreAll (thePart, fillPer, netReqVol);
d427 1
a427 17
   if (multiSel ())
      if (netReqVol < theReqVol)
         mySelector ()->recFillByCons (thePart, fillPer);

   if (netReqVol <= NET_TOL)
      return witTRUE;

   if (multiSel ())
      mySelector ()->recFillNetRec (thePart, fillPer);

   if (selSplit_)
      return fillNetReqSS  (thePart, fillPer, netReqVol);
   else 
      return fillNetReqNss (thePart, fillPer, netReqVol);
   }

//------------------------------------------------------------------------------
d429 3
a431 4
WitBoolean WitHeurAllPerf::fillNetReqNss (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    netReqVol)
d433 1
a433 20
   WitBoolean    restExpOK;
   WitPeriod     expPer;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   witAssert (netReqVol > NET_TOL);
   witAssert (! selSplit_);

   if (penExec_)
      myExpRest ()->recRestExp (thePart, fillPer, restExpOK);

   if (! findExpPer (thePart, fillPer, expPer))
      return witFALSE;
      
   if (penExec_)
      if (! restExpOK)
         return witFALSE;

   theBopEnt = expBopEntry (thePart,   expPer);
   execPer   = execPerFor  (theBopEnt, expPer);
d435 2
a436 1
   return explode (theBopEnt, execPer, netReqVol, fillPer);
d441 1
a441 4
WitBoolean WitHeurAllPerf::fillNetReqSS (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    netReqVol)
a442 21
   WitBoolean restExpOK;
   WitPeriod  expPer;

   witAssert (netReqVol > NET_TOL);
   witAssert (selSplit_);

   if (buildAhead_)
      if (myBaMgr ()->selIsSplit (thePart, fillPer))
         return fillNetReqBASS (thePart, fillPer, netReqVol);

   if (penExec_)
      myExpRest ()->recRestExp (thePart, fillPer, restExpOK);

   if (! findExpPer (thePart, fillPer, expPer))
      return witFALSE;
      
   if (penExec_)
      if (! restExpOK)
         return witFALSE;

   return explodePartSS (thePart, expPer, netReqVol, fillPer);
d447 1
a447 4
WitBoolean WitHeurAllPerf::fillNetReqBASS (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    netReqVol)
d449 3
a451 22
   WitBoolean restExpOK;
   WitBoolean expOK;
   WitPeriod  expPer;
   double     expVol;

   witAssert (selSplit_);

   witAssert (netReqVol > NET_TOL);

   witAssert (myBaMgr ()->selIsSplit (thePart, fillPer));

   if (penExec_)
      {
      myExpRest ()->recRestExp (thePart, fillPer, restExpOK);

      if (! restExpOK)
         return witFALSE;
      }

   myBaMgr ()->startSplitExp (thePart, fillPer, netReqVol);

   expOK = witTRUE;
d453 1
a453 1
   while (myBaMgr ()->findNextSplit (expPer, expVol))
d455 1
a455 1
      expOK = explodePartSS (thePart, expPer, expVol, fillPer);
d457 2
a458 2
      if (! expOK)
         break;
a459 4

   myBaMgr ()->finishSplitExp ();

   return expOK;
d464 1
a464 5
WitBoolean WitHeurAllPerf::explodePartSS (
      WitPart * thePart, 
      WitPeriod expPer,
      double    expVol,
      WitPeriod fillPer) 
d466 5
a470 3
   WitBoolean    expOK;
   WitBopEntry * theBopEnt;
   double        splitExpVol;
d472 4
a475 2
   witAssert (selSplit_);
   witAssert (expVol > NET_TOL);
d477 2
a478 2
   if (buildAhead_)
      myBaMgr ()->recExpMatSS (thePart, fillPer, expVol);
d480 1
a480 1
   if (multiRoute_ && myPmrMgr ()->selIsSplit (thePart, expPer))
d482 2
a483 1
      myPmrMgr ()->startSplitExp (thePart, expPer, expVol);
d485 1
a485 15
      expOK = witTRUE;

      while (myPmrMgr ()->findNextSplit (theBopEnt, splitExpVol))
         {
         expOK = explodeBopEntSS (theBopEnt, expPer, splitExpVol, fillPer);

         if (! expOK)
            break;
         }

      myPmrMgr ()->mySelMgr ()->finishSplitExp ();
      }
   else
      {
      theBopEnt = expBopEntry (thePart, expPer);
d487 1
a487 1
      expOK     = explodeBopEntSS (theBopEnt, expPer, expVol, fillPer);
d490 1
a490 1
   return expOK;
d495 1
a495 4
WitBoolean WitHeurAllPerf::findExpPer (
      WitPart *   thePart, 
      WitPeriod   fillPer, 
      WitPeriod & expPer) 
d497 2
a498 1
   expPer = expPerFor (thePart, fillPer);
d500 6
a505 5
   if (thePart->explodeable (expPer))
      return witTRUE;

   if (multiSel ())
      mySelector ()->recordShortage (thePart, fillPer);
d507 3
a509 2
   if (critListMode ())
      myHeurCritList ()->setCulprit (thePart, fillPer);
d511 1
a511 1
   return witFALSE;
d515 5
d521 4
a524 5
WitBoolean WitHeurAllPerf::explodeBopEntSS (
      WitBopEntry * theBopEnt,
      WitPeriod     expPer,
      double        expVol,
      WitPeriod     fillPer)
a525 33
   WitBoolean expOK;
   WitPeriod  execPer;
   double     splitExpVol;

   witAssert (selSplit_);

   if (multiRoute_)
      myPmrMgr ()->recBopEntExpPerSS (theBopEnt, expPer, expVol);

   if (multiExec_ && myMeMgr ()->selIsSplit (theBopEnt, expPer))
      {
      myMeMgr ()->startSplitExp (theBopEnt, expPer, expVol);

      expOK = witTRUE;

      while (myMeMgr ()->findNextSplit (execPer, splitExpVol))
         {
         expOK = explode (theBopEnt, execPer, splitExpVol, fillPer);

         if (! expOK)
            break;
         }

      myMeMgr ()->finishSplitExp ();
      }
   else
      {
      execPer = execPerFor (theBopEnt, expPer);

      expOK   = explode (theBopEnt, execPer, expVol, fillPer);
      }

   return expOK;
d530 1
a530 5
WitBoolean WitHeurAllPerf::explode (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        qty,
      WitPeriod     fillPer)
a531 31
   WitOperation * theOpn;
   double         oldExecVol;
   double         deltaExecVol;
   double         newExecVol;

   witAssert (qty > NET_TOL);

   if (selSplit_)
      if (multiExec_)
         myMeMgr ()->recBopEntExecPerSS (theBopEnt, execPer, qty);

   theOpn       = theBopEnt->myOperation ();

   oldExecVol   = myAllocMode_->curExecVol (theOpn, execPer);

   deltaExecVol = qty / theBopEnt->effProdRate ()[execPer];

   theOpn->lotSizeDelta (execPer, oldExecVol, deltaExecVol, witTRUE, witTRUE);

   if (deltaExecVol < NET_TOL)
      return witTRUE;

   if (finiteExecBounds_)
      {
      newExecVol = oldExecVol + deltaExecVol;

      if (! checkExecBounds (theBopEnt, execPer, newExecVol, fillPer))
         return witFALSE;
      }

   return innerExplode (theBopEnt, execPer, qty, deltaExecVol, fillPer);
d536 1
a536 5
WitBoolean WitHeurAllPerf::checkExecBounds (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        theExecVol,
      WitPeriod     fillPer)
d538 4
a541 6
   WitOperation * theOpn;

   theOpn = theBopEnt->myOperation ();

   if (theOpn->execBounds ()->hardUBisSatisfied (execPer, theExecVol))
      return witTRUE;
d543 2
a544 2
   if (multiSel ())
      mySelector ()->recordExecBoundShortage (theBopEnt, execPer, fillPer);
d546 1
a546 41
   if (critListMode ())
      myHeurCritList ()->setCulprit (theBopEnt->myPart (), fillPer);

   return witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitHeurAllPerf::innerExplode (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      double        qty,
      double        deltaExecVol,
      WitPeriod     fillPer)
   {
   WitBoolean     expOK;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitBopEntry *  prodBopEnt;
   double         deltaProdVol;
   WitPart *      prodPart;
   WitPeriod      prodPer;

   witAssert (deltaExecVol >= NET_TOL);

   expOK  = witTRUE;

   theOpn = theBopEnt->myOperation ();

   myAllocMode_->incExecVol (theOpn, execPer, deltaExecVol);

   forEachEl (theBomEnt, theOpn->bom ())
      explodeBomEntry (
         theBomEnt, 
         execPer, 
         deltaExecVol, 
         fillPer, 
         theBopEnt,
         expOK);

   forEachEl (prodBopEnt, theOpn->bop ())
d548 1
a548 3
      deltaProdVol = deltaExecVol * prodBopEnt->effProdRate ()[execPer];

      if (deltaProdVol <= NET_TOL)
d551 4
a554 4
      prodPart = prodBopEnt->myPart ();
      prodPer  = prodBopEnt->impactPeriod ()[execPer];

      curAvailSched ()->addToIncAvail (prodPart, prodPer, deltaProdVol);
d556 2
a557 6
      if (penExec_)
         if (prodBopEnt != theBopEnt)
            if (myAllocMode_->perm ())
               myExpRest ()->reqPsSupRep (
                  prodBopEnt->myPart (),
                  prodBopEnt->impactPeriod ()[execPer]);
d560 3
a562 3
   curAvailSched ()->addToIncAvail (theBopEnt->myPart (), fillPer, - qty);

   return expOK;
d567 1
a567 4
void WitHeurAllPerf::netAndRollReq (
      WitPart * thePart,
      WitPeriod thePer,
      double &  netReqVol)
d569 1
a569 2
   WitPeriod rollPer;
   double    rollVol;
d571 1
a571 1
   witAssert (stockRealloc ());
d573 2
a574 10
   rollPer = curAvailSched ()->netAndRoll (thePart, thePer, netReqVol, rollVol);

   if (rollPer < 0)
      return;

   myReqSched_->addTo (thePart, rollPer, rollVol);

   if (multiSel ())
      if (myAllocMode_->temp ())
         mySelector ()->rollReq (thePart, thePer, rollPer);
d578 2
d581 3
a583 9
void WitHeurAllPerf::explodeBomEntry (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theExpBopEntry,
      WitBoolean &  expOK)
   {
   WitConsEntry * theConsEnt;
d585 1
a585 1
   witAssert (deltaExecVol >= NET_TOL);
d587 5
a591 36
   if (! theBomEnt->inEffect (execPer))
      return;

   if (myCompMgr ()->hasSubEntries ())
      if (theBomEnt->hasSubsInEffect ()[execPer])
         {
         netConsEntries (theBomEnt, execPer, deltaExecVol, expOK);

         if (deltaExecVol < NET_TOL )
            return;

         if (! expOK)
            return;
         }

   if (multiRoute_ && myCmrMgr ()->selIsSplit (theBomEnt, execPer))
      explodeBomEntrySS (
         theBomEnt,
         execPer,
         deltaExecVol,
         fillPer,
         theExpBopEntry);
   else
      {
      theConsEnt = 
         multiRoute_?
            myCmrMgr ()->selConsEntry (theBomEnt, execPer):
            theBomEnt;

      explodeConsEntry (
         theConsEnt,
         execPer, 
         deltaExecVol, 
         fillPer, 
         theExpBopEntry);
      }
d596 1
a596 6
void WitHeurAllPerf::explodeBomEntrySS (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double        deltaExecVol,
      WitPeriod     fillPer,
      WitBopEntry * theExpBopEntry)
a597 17
   WitConsEntry * theConsEnt;
   double         splitExecVol;

   witAssert (multiRoute_);
   witAssert (selSplit_);

   myCmrMgr ()->startSplitExp (theBomEnt, execPer, deltaExecVol);

   while (myCmrMgr ()->findNextSplit (theConsEnt, splitExecVol))
      explodeConsEntry (
         theConsEnt,
         execPer, 
         splitExecVol,
         fillPer, 
         theExpBopEntry);

   myCmrMgr ()->mySelMgr ()->finishSplitExp ();
d602 1
a602 5
void WitHeurAllPerf::netConsEntries (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      double &      netExecQty,
      WitBoolean &  expOK)
d604 1
a604 8
   WitSubEntry * theSub;

   netConsEntry (theBomEnt, netExecQty, execPer, expOK);
      //
      // First net possible usage of prime from supply.

   if (netExecQty < NET_TOL)
      return;
d606 2
a607 13
   if (! expOK)
      return;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      netSubEntry (theSub, execPer, netExecQty, expOK);

      if (netExecQty < NET_TOL)
         return;

      if (! expOK)
         return;
      }
d612 1
a612 5
void WitHeurAllPerf::netSubEntry (
      WitSubEntry * theSub,
      WitPeriod     execPer,
      double &      netExecQty,
      WitBoolean &  expOK)
d614 1
a614 1
   double oldExecQty;
d616 1
a616 1
   if (! theSub->netAllowed ())
d619 1
a619 1
   if (! theSub->inEffect (execPer))
d622 1
a622 1
   oldExecQty = netExecQty;
d624 1
a624 1
   netConsEntry (theSub, netExecQty, execPer, expOK);
d626 1
a626 41
   if (myAllocMode_->perm ())
      subVol (theSub).elemRef (execPer) += 
         positivePart (oldExecQty - netExecQty);
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::netConsEntry (
      WitConsEntry * theConsEnt,
      double &       netExecQty,
      WitPeriod      execPer,
      WitBoolean &   expOK)
   {
   double    reqConsQty;
   WitPart * consPart;
   WitPeriod consPer;
   double    netConsQty;

   witAssert (netExecQty > 0.0);

   reqConsQty = theConsEnt->effConsRate ()[execPer] * netExecQty;
   consPart   = theConsEnt->myPart ();
   consPer    = theConsEnt->impactPeriod ()[execPer];

   if (theConsEnt->effConsRate ()[execPer] >= FLOAT_EPSILON)
      {
      netConsQty = reqConsQty;

      curAvailSched ()->netWithPreAll (consPart, consPer, netConsQty);

      netExecQty = netConsQty / theConsEnt->effConsRate ()[execPer];

      if (netExecQty <= NET_TOL)
         netExecQty = 0.0;
      else if (penExec_)
         myExpRest ()->recRestExp (consPart, consPer, expOK);
      }
   else
      {
      if (theConsEnt->effConsRate ()[execPer] <= - FLOAT_EPSILON )
         curAvailSched ()->addToIncAvail (consPart, consPer, - reqConsQty);
d628 1
a628 2
      netExecQty = 0.0;
      }
d633 1
a633 44
void WitHeurAllPerf::explodeConsEntry (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double         netExecQty,
      WitPeriod      fillPer,
      WitBopEntry *  theExpBopEntry)
   {
   WitPeriod consPer;
   double    consumedQty;
   WitPart * consPart;

   consPer     = theConsEnt->impactPeriod ()[execPer];
   consumedQty = theConsEnt->effConsRate ()[execPer] * netExecQty;
   consPart    = theConsEnt->myPart ();

   if (consumedQty > NET_TOL)
      {
      myReqSched_->addTo (consPart, consPer, consumedQty);

      if (multiSel ())
         if (myAllocMode_->temp ())
            mySelector ()->placeReqs (
               theExpBopEntry,
               theConsEnt,
               execPer,
               fillPer);
      }

   if (consumedQty < - NET_TOL)
      curAvailSched ()->addToIncAvail (consPart, consPer, - consumedQty);

   if (multiRoute_)
      if (theConsEnt->isaSubEntry ())
         if (myAllocMode_->perm ())
            subVol (theConsEnt->asaSubEntry ()).elemRef (execPer) += netExecQty;

   if (selSplit_)
      if (multiRoute_)
         myCmrMgr ()->recExpConsEntSS (theConsEnt, execPer, netExecQty);
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::enforceStockSLBs (WitPart * thePart)
d635 2
a636 43
   WitMaterial * theMat;
   WitPeriod     thePer;

   if (thePart->isaMaterial (theMat))
      if (! (theMat->stockBounds ()->softLB () == 0.0))
         forEachPeriod (thePer, myProblem ())
            enforceStockSLB (theMat, thePer);
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::enforceStockSLB (WitMaterial * theMat, WitPeriod thePer)
   {
   double slb;
   double availVol;
   double violVol;
   double netVol;

   if (theMat->mandEC ()[thePer])
      return;

   slb = theMat->stockBounds ()->softLB ()[thePer];

   if (slb < NET_TOL)
      return;

   availVol = curAvailSched ()->availToNet (theMat, thePer, slb);

   curAvailSched ()->addToIncAvail     (theMat, thePer, - availVol);
   curAvailSched ()->addToNextIncAvail (theMat, thePer,   availVol);

   violVol = slb - availVol;

   if (violVol < NET_TOL)
      return;

   curAvailSched ()->addToNextIncAvail (theMat, thePer, violVol);

   netVol = violVol;

   commitMaxQty (theMat, thePer, netVol);

   curAvailSched ()->addToNextIncAvail (theMat, thePer, - netVol);
@


1.62
log
@Minor modification.
@
text
@d1314 1
a1314 1
   myCmrMgr ()->finishSplitExp ();
@


1.61
log
@An attempt to fix the link trouble on Windows for the multi-route templates.
@
text
@d1013 1
a1013 1
      myPmrMgr ()->thisSelMgr ()->finishSplitExp ();
@


1.60
log
@Converted several generic classes into class templates.
@
text
@d1013 1
a1013 1
      myPmrMgr ()->finishSplitExp ();
@


1.59
log
@Minor changes.
@
text
@d388 1
a388 1
   WitObjStack (WitPart) reversedParts (myProblem ());
@


1.58
log
@Refactoring.
@
text
@a218 1
   WitPart *      thePart;
a1169 2
   WitPart *      thePart;
   WitPeriod      expPer;
@


1.57
log
@Various refactorings for sel-split for multi-exec.
@
text
@d146 1
a146 1
inline WitPeriod WitHeurAllPerf::expPeriod (
d152 2
a153 2
         myBaMgr ()->selExpPeriod (thePart, fillPer):
         thePart   ->explosionPeriod       (fillPer);
d170 1
a170 1
inline WitPeriod WitHeurAllPerf::expExecPeriod (
d176 1
a176 1
         myMeMgr ()->selExecPeriod (theBopEnt, expPer):
d700 1
a700 1
   expPer = expPeriod (topPart (), topPer ());
d705 2
a706 2
   theBopEnt = expBopEntry   (topPart (), expPer);
   execPer   = expExecPeriod (theBopEnt,  expPer);
d896 1
a896 1
   if (! findExpPeriod (thePart, fillPer, expPer))
d903 2
a904 2
   theBopEnt = expBopEntry   (thePart,   expPer);
   execPer   = expExecPeriod (theBopEnt, expPer);
d929 1
a929 1
   if (! findExpPeriod (thePart, fillPer, expPer))
d1028 1
a1028 1
WitBoolean WitHeurAllPerf::findExpPeriod (
d1033 1
a1033 1
   expPer = expPeriod (thePart, fillPer);
d1082 1
a1082 1
      execPer = expExecPeriod (theBopEnt, expPer);
@


1.56
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@d969 2
a970 1
   while (expOK && myBaMgr ()->findNextSplit (expPer, expVol))
d973 4
d998 1
a998 1
      myBaMgr ()->recExpMatSS (thePart, expPer, expVol, fillPer);
d1006 2
a1007 1
      while (expOK && myPmrMgr ()->findNextSplit (theBopEnt, splitExpVol))
d1010 4
d1070 2
a1071 1
      while (expOK && myMeMgr ()->findNextSplit (execPer, splitExpVol))
d1073 4
@


1.55
log
@Implemented timing wrap-around adjustment.
@
text
@a33 1
#include <Timing.h>
d216 1
a216 2
      nBsearches_       (0),
      nIncsSinceCharge_ (0)
a285 2
   else if (myGlobalComp ()->selSplit ())
      myMsgFac () ("selSplitWoMultiSelWmsg");
a333 12

   if (myGlobalComp ()->heurTimingDelta () > 0)
      {
      nIncsSinceCharge_ ++;

      if (nIncsSinceCharge_ >= myGlobalComp ()->heurTimingDelta ())
         {
         WitTimingEvent theEvent ("other");

         nIncsSinceCharge_ = 0;
         }
      }
@


1.54
log
@Re-instated co-existence of multi-exec and selection splitting.
@
text
@d34 1
d217 2
a218 1
      nBsearches_       (0)
d338 12
@


1.53
log
@Implemented Ticker class.
Disallowed sel-split w multi-exec.
@
text
@a295 3

      if (multiExec_)
         myMsgFac () ("multiExecSelSplitSmsg");
@


1.52
log
@Implemented incAlloc count.
@
text
@d216 1
a216 3
      nBsearches_       (0),
      nIncs_            (0),
      nextPrtInc_       (myGlobalComp ()->incCountDelta ())
d296 3
a344 13

   if (myGlobalComp ()->incCountDelta () > 0)
      {
      nIncs_ ++;

      if (nIncs_ >= nextPrtInc_)
         {
         nextPrtInc_ += myGlobalComp ()->incCountDelta ();

         fprintf (myMsgFac ().myFile (), "%d\n", nIncs_);
         fflush  (myMsgFac ().myFile ());
         }
      }
@


1.51
log
@Implemented tick printing for incHeurAlloc.
@
text
@d216 3
a218 1
      nBsearches_       (0)
d345 12
a356 2
   if (myGlobalComp ()->incAllocTicks ())
      fprintf (myMsgFac ().myFile (), "*\n");
@


1.50
log
@Added incAllocMsg.
@
text
@d343 3
@


1.49
log
@Refactoring for selection splitting.
@
text
@d374 8
@


1.48
log
@Continuing development of selection splitting.
@
text
@d28 2
a29 2
#include <ProdRtr.h>
#include <ConsRtr.h>
d164 2
a165 2
         myProdRtr ()->selBopEntry (thePart, expPer):
         thePart     ->expBopEntry          (expPer);
d254 2
a255 2
      myProdRtr_  = mySelector ()->myProdRtr ();
      myConsRtr_  = mySelector ()->myConsRtr ();
d989 1
a989 1
   if (multiRoute_ && myProdRtr ()->selIsSplit (thePart, expPer))
d991 1
a991 1
      myProdRtr ()->startSplitExp (thePart, expPer, expVol);
d995 1
a995 1
      while (expOK && myProdRtr ()->findNextSplit (theBopEnt, splitExpVol))
d998 1
a998 1
      myProdRtr ()->finishSplitExp ();
d1046 1
a1046 1
      myProdRtr ()->recBopEntExpPerSS (theBopEnt, expPer, expVol);
d1248 1
a1248 1
   if (multiRoute_ && myConsRtr ()->selIsSplit (theBomEnt, execPer))
d1259 1
a1259 1
            myConsRtr ()->selConsEntry (theBomEnt, execPer):
d1286 1
a1286 1
   myConsRtr ()->startSplitExp (theBomEnt, execPer, deltaExecVol);
d1288 1
a1288 1
   while (myConsRtr ()->findNextSplit (theConsEnt, splitExecVol))
d1296 1
a1296 1
   myConsRtr ()->finishSplitExp ();
d1437 1
a1437 1
         myConsRtr ()->recExpConsEntSS (theConsEnt, execPer, netExecQty);
@


1.47
log
@Continuing development of selection splitting.
@
text
@a295 4

      forEachMaterial (theMat, myProblem ())
         if (! (theMat->buildAheadUB () == lastPeriod ()))
            myMsgFac () ("buildAheadUBSelSplitSmsg");
@


1.46
log
@Re-worked the controls for selection splitting.
@
text
@a694 3
   if (selSplit_)
      return;

@


1.45
log
@Continued implementation of selection splitting.
@
text
@d284 6
a289 1
   if (myGlobalComp ()->allowSS ())
d292 1
a292 1
         myMsgFac () ("penExecAllowSSSmsg");
d295 1
a295 1
         myMsgFac () ("critListAllowSSSmsg");
d299 1
a299 4
            myMsgFac () ("buildAheadUBAllowSSSmsg");

      if (multiSel ())
         selSplit_ = mySelector ()->selSplit ();
@


1.44
log
@Fixed a bug in selection splitting.
@
text
@d403 39
d598 1
a598 6
      {
      mySelector ()->initMultiSelLoop ();

      while (mySelector ()->contMultiSelLoop ())
         commitMaxQtySel (netQty);
      }
a608 39
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::commitMaxQtySel (double & netQty)
   {
   double oldNetQty;
   double maxQty;

   if (penExec_)
      oldNetQty = netQty;

   curAvailSched ()->netWithPreAll (topPart (), topPer (), netQty);

   if (penExec_)
      mySelector ()->recCommitVol (oldNetQty - netQty, witFALSE);

   maxQty = findMaxQty (netQty);

   if (maxQty >= NET_TOL)
      {
      permCommit (maxQty);

      netQty -= maxQty;

      witAssert (netQty >= 0.0);

      if (penExec_)
         mySelector ()->recCommitVol (maxQty, witTRUE);
      }

   if (critListMode ())
      {
      if (penExec_)
         if (myExpRest ()->failRestShortOnly ())
            return;

      myHeurCritList ()->appendCulprit ();
      }
@


1.43
log
@Continued implementation of selection splitting with the new design.
@
text
@d199 1
a209 1
      myReqSched_       (NULL),
d421 1
a421 1
void WitHeurAllPerf::permCommit (double qty)
d423 1
a423 1
   WitBoolean success;
d425 1
a425 3
   witAssert (myAllocMode_->perm ());

   success = commit (qty);
d427 1
a427 5
   if (! success)
      myMsgFac () ("permCommitFailedFmsg", 
         topPart ()->partName (), 
         topPer (), 
         qty);
d614 17
@


1.42
log
@Continued implementation of selection splitting with the new design.
@
text
@d211 3
d228 1
a228 1
   myReqSched_  = new WitReqSched (myProblem ());
d403 1
a403 1
WitBoolean WitHeurAllPerf::tempCommit1SS (WitPart * thePart, WitPeriod thePer)
d405 15
a419 1
   witAssert (selSplit_);
d421 13
a433 1
   return tempCommit (thePart, thePer, 1.0);
d559 5
d565 6
a570 1
      commitMaxQtyMultiSel (thePart, thePer, netQty);
d572 4
a575 1
      commitMaxQtySel      (thePart, thePer, netQty);
d585 1
a585 17
void WitHeurAllPerf::commitMaxQtyMultiSel (
      WitPart * thePart, 
      WitPeriod thePer,
      double &  netQty)
   {
   mySelector ()->initMultiSelLoop (thePart, thePer);

   while (mySelector ()->contMultiSelLoop ())
      commitMaxQtySel (thePart, thePer, netQty);
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::commitMaxQtySel (
      WitPart * thePart,
      WitPeriod thePer,
      double &  netQty)
d587 2
a588 3
   double     oldNetQty;
   double     maxQty;
   WitBoolean success;
d593 1
a593 1
   curAvailSched ()->netWithPreAll (thePart, thePer, netQty);
d598 1
a598 1
   maxQty = findMaxQty (netQty, thePart, thePer);
d602 1
a602 4
      success = commit (thePart, thePer, maxQty);

      if (! success)
         myMsgFac () ("commitFailedFmsg", thePart->partName (), thePer, maxQty);
d624 1
a624 4
double WitHeurAllPerf::findMaxQty (
      double    desQty,
      WitPart * thePart,
      WitPeriod thePer)
d635 1
a635 1
         mySelector ()->printCommitMaxQtySelIA (thePart, thePer);
d641 1
a641 1
   defSearchGrid (thePart, thePer, minQty, incQty);
d645 1
a645 1
      success = tempCommit (thePart, thePer, desQty);
d655 1
a655 1
   success = tempCommit (thePart, thePer, minQty);
d662 1
a662 1
   success = tempCommit (thePart, thePer, desQty);
d669 1
a669 1
   return binarySearch (desQty, thePart, thePer, minQty, incQty);
d674 1
a674 5
void WitHeurAllPerf::defSearchGrid (
      WitPart * thePart,
      WitPeriod fillPer,
      double &  minQty,
      double &  incQty)
d693 1
a693 1
   expPer = expPeriod (thePart, fillPer);
d695 1
a695 1
   if (! thePart->explodeable (expPer))
d698 2
a699 2
   theBopEnt = expBopEntry   (thePart,   expPer);
   execPer   = expExecPeriod (theBopEnt, expPer);
d737 3
a739 5
      double    desQty,
      WitPart * thePart,
      WitPeriod thePer,
      double    minQty,
      double    incQty)
d766 1
a766 1
      success = tempCommit (thePart, thePer, qty);
d781 1
a781 4
WitBoolean WitHeurAllPerf::tempCommit (
      WitPart *  thePart,
      WitPeriod  thePer,
      double     qty)
d785 1
a785 11
   myAllocMode_->enterTempMode ();

   success = commit (thePart, thePer, qty);

   if (multiSel ())
      mySelector ()->postTempCommit (success);

   myAllocMode_->leaveTempMode ();

   return success;
   }
d787 1
a787 1
//------------------------------------------------------------------------------
d789 1
a789 8
WitBoolean WitHeurAllPerf::commit (
      WitPart * topPart, 
      WitPeriod topPer, 
      double    qty)
   {
   WitBoolean success;

   success = innerCommit (topPart, topPer, qty);
d794 2
d801 1
a801 4
WitBoolean WitHeurAllPerf::innerCommit (
      WitPart * topPart, 
      WitPeriod topPer, 
      double    qty)
d811 1
a811 1
   myReqSched_->init (topPart, topPer, qty);
d813 1
a813 1
   forEachElDense (fillPart, topPart->belowList ())
@


1.41
log
@Removed the possibility of a non-integer search grid from the heuristic.
@
text
@a32 1
#include <Splitter.h>
a201 1
      mySplitter_       (NULL),
d294 1
a294 4
         selSplit_   = mySelector ()->selSplit ();

      if (selSplit_)
         mySplitter_ = mySelector ()->mySplitter ();
d400 9
d548 1
a548 5
   mySelector ()->prepCommitMaxQtyMultiSel (thePart, thePer);

   while (witTRUE)
      {
      mySelector ()->prepCommitMaxQtySel (thePart, thePer);
d550 1
a551 8

      if (! mySelector ()->findFreshScheme ())
         break;

      if (selSplit_)
         if (mySplitter ()->splitNeeded ())
            splitCommitSS (thePart, thePer);
      }
a601 42
void WitHeurAllPerf::splitCommitSS (WitPart * thePart, WitPeriod thePer)
   {
   witAssert (selSplit_);

   witAssert (mySplitter ()->splitNeeded ());

   mySelector ()->splitCommit ();
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::splitItrSS (
      WitPart *    thePart,
      WitPeriod    thePer,
      WitBoolean & tempCommOK,
      WitBoolean & resFound)
   {
   WitBoolean needToSplit;

   witAssert (selSplit_);

   resFound   = witFALSE;

   tempCommOK = tempCommit (thePart, thePer, 1.0);

   if (tempCommOK)
      return;

   mySelector ()->splitItr (resFound, needToSplit);

   if (needToSplit)
      splitSelSS ();
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::splitSelSS ()
   {
   }

//------------------------------------------------------------------------------

d749 1
a749 1
      midGP   = (upperGP + lowerGP) / 2;
@


1.40
log
@Continued implementation of selection splitting.
@
text
@d580 1
a580 1
   maxQty = findMaxQty (netQty, 0.0, thePart, thePer);
a652 1
      double    knownQty,
d671 1
a671 1
   defSearchGrid (thePart, thePer, knownQty, minQty, incQty);
d682 1
a682 1
            knownQty;
d688 1
a688 1
      return knownQty;
a706 1
      double    knownQty,
d716 2
a717 2
   minQty = knownQty + 1.0;
   incQty =            1.0;
d745 1
a745 3
      minQty = knownQty + incQty;
   else if (knownQty > FLOAT_EPSILON)
      minQty = knownQty + incQty;
d753 13
@


1.39
log
@Continued implementation of selection splitting.
@
text
@d557 1
a557 1
            splitCommitSS ();
d609 1
a609 1
void WitHeurAllPerf::splitCommitSS ()
d620 31
d723 3
d819 3
d839 1
a839 1
      mySelector ()->postCommit (myAllocMode_->temp (), success);
@


1.38
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d33 1
d203 1
d296 4
a299 1
         selSplit_ = mySelector ()->selSplit ();
d544 1
a544 6
   double     maxQty;
   WitBoolean schemeIsFresh;

   mySelector ()->printHeadingIA (thePart, thePer);

   schemeIsFresh = witTRUE; 
d546 1
a546 1
   while (schemeIsFresh)
d548 1
a548 2
      if (penExec_)
         mySelector ()->modifyRouting (thePart, thePer);
d552 6
a557 1
      schemeIsFresh = mySelector ()->findFreshScheme ();
d605 11
@


1.37
log
@Made multi-select trace-back for netting active even without selection
splitting.
@
text
@d289 4
d1243 1
a1243 4
   if (   selSplit_
       && multiRoute_
       && myConsRtr ()->selIsSplit (theBomEnt, execPer))

@


1.36
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d847 1
a847 1
   if (selSplit_)
d854 3
a905 2

   mySelector ()->recFillNetRecSS (thePart, fillPer);
@


1.35
log
@Fixed a particularly difficult bug in coarse selection splitting.
@
text
@d281 1
a281 1
   if (myGlobalComp ()->selSplit ())
d283 2
a284 1
      selSplit_ = witTRUE;
d286 2
a287 1
      myMsgFac () ("selSplitMsg");
d289 2
a290 2
      if (! multiSel ())
         myMsgFac () ("selSplitWoMSSmsg");
d520 1
a520 1
      commitMaxQtySelNss   (thePart, thePer, netQty);
a539 7
   if (selSplit_)
      {
      netTopLevel (thePart, thePer, netQty);

      maxQty = 0.0;
      }

d547 1
a547 8
      if (selSplit_)
         {
         maxQty = findMaxQty (netQty, maxQty, thePart, thePer);

         appendCulpritIA ();
         }
      else
         commitMaxQtySelNss (thePart, thePer, netQty);
a550 8

   if (selSplit_)
      {
      if (maxQty >= NET_TOL)
         permCommit (thePart, thePer, netQty, maxQty);

      mySelector ()->postPermCommitSS ();
      }
d555 1
a555 1
void WitHeurAllPerf::commitMaxQtySelNss (
d560 2
a561 22
   double maxQty;

   witAssert (! selSplit_);

   netTopLevel (thePart, thePer, netQty);

   maxQty = findMaxQty (netQty, 0.0, thePart, thePer);

   if (maxQty >= NET_TOL)
      permCommit (thePart, thePer, netQty, maxQty);

   appendCulpritIA ();
   }

//------------------------------------------------------------------------------

void WitHeurAllPerf::permCommit (
      WitPart * thePart, 
      WitPeriod thePer,
      double &  netQty,
      double    maxQty)
   {
d564 2
a565 1
   witAssert (maxQty >= NET_TOL);
d567 1
a567 8
   success = commit (thePart, thePer, maxQty);

   if (! success)
      myMsgFac () ("commitFailedFmsg", thePart->partName (), thePer, maxQty);

   netQty -= maxQty;

   witAssert (netQty >= 0.0);
d570 1
a570 2
      mySelector ()->recCommitVol (maxQty, witTRUE);
   }
d572 1
a572 1
//------------------------------------------------------------------------------
d574 3
a576 4
void WitHeurAllPerf::appendCulpritIA ()
   {
   if (! critListMode ())
      return;
d578 2
a579 3
   if (penExec_)
      if (myExpRest ()->failRestShortOnly ())
         return;
d581 1
a581 2
   myHeurCritList ()->appendCulprit ();
   }
d583 1
a583 1
//------------------------------------------------------------------------------
d585 3
a587 6
void WitHeurAllPerf::netTopLevel (
      WitPart * thePart, 
      WitPeriod thePer,
      double &  netQty)
   {
   double oldNetQty;
d589 5
a593 2
   if (penExec_)
      oldNetQty = netQty;
d595 2
a596 4
   curAvailSched ()->netWithPreAll (thePart, thePer, netQty);

   if (penExec_)
      mySelector ()->recCommitVol (oldNetQty - netQty, witFALSE);
@


1.34
log
@Further implementation of coarse selection splitting.
@
text
@d888 1
a888 3
   double     netReqVol;
   WitBoolean restExpOK;
   WitPeriod  expPer;
d899 4
d906 3
a908 1
   if (! selSplit_)
d910 1
d912 11
a922 10
   if (buildAhead_)
      if (myBaMgr ()->selIsSplit (thePart, fillPer))
         {
         if (penExec_)
            {
            myExpRest ()->recRestExp (thePart, fillPer, restExpOK);

            if (! restExpOK)
               return witFALSE;
            }
d924 2
a925 2
         return fillNetReqBASS (thePart, fillPer, netReqVol);
         }
d937 4
a940 1
   return explodePartSS (thePart, expPer, netReqVol, fillPer);
d945 1
a945 1
WitBoolean WitHeurAllPerf::fillNetReqNss (
d950 2
a951 4
   WitBoolean    restExpOK;
   WitPeriod     expPer;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
d954 7
a960 1
   witAssert (! selSplit_);
d972 1
a972 4
   theBopEnt = expBopEntry   (thePart,   expPer);
   execPer   = expExecPeriod (theBopEnt, expPer);

   return explode (theBopEnt, execPer, netReqVol, fillPer);
d982 1
d992 8
@


1.33
log
@Implemented coarse selection splitting for penalized execution.
@
text
@d469 1
a469 1
         commitMaxQty (netQty, thePart, lastPer);
d482 1
a482 1
         commitMaxQty (netQty, thePart, thePer);
d491 1
a491 1
         commitMaxQty (netQty, thePart, thePer);
a502 1
      double &  netQty, 
d504 2
a505 1
      WitPeriod thePer)
d515 2
a516 4
   if (selSplit_)
      commitMaxQtySS          (netQty, thePart, thePer);
   else if (multiSel ())
      commitMaxQtyMultiSelNss (netQty, thePart, thePer);
d518 1
a518 1
      commitMaxQtySelNss      (netQty, thePart, thePer);
d528 1
a528 2
void WitHeurAllPerf::commitMaxQtyMultiSelNss (
      double &   netQty, 
d530 2
a531 1
      WitPeriod thePer)
d533 1
d536 5
a540 1
   witAssert (! selSplit_);
d542 2
a543 1
   mySelector ()->printHeadingIA (thePart, thePer);
d552 8
a559 1
      commitMaxQtySelNss (netQty, thePart, thePer);
d563 8
d575 4
a578 4
void WitHeurAllPerf::commitMaxQtySS (
      double &   netQty, 
      WitPart * thePart, 
      WitPeriod thePer)
d580 1
a580 4
   double     oldNetQty;
   double     maxQty;
   WitBoolean schemeIsFresh;
   WitBoolean success;
d582 1
a582 1
   witAssert (selSplit_);
d584 1
a584 1
   mySelector ()->printHeadingIA (thePart, thePer);
d586 1
a586 2
   if (penExec_)
      oldNetQty = netQty;
d588 2
a589 1
   curAvailSched ()->netWithPreAll (thePart, thePer, netQty);
d591 2
a592 2
   if (penExec_)
      mySelector ()->recCommitVol (oldNetQty - netQty, witFALSE);
d594 1
a594 1
   maxQty        = 0.0;
d596 7
a602 1
   schemeIsFresh = witTRUE; 
d604 1
a604 4
   while (schemeIsFresh)
      {
      if (penExec_)
         mySelector ()->modifyRouting (thePart, thePer);
d606 1
a606 2
      if (DEVELOPMENT)
         nSelCommits_ ++;
d608 2
a609 1
      mySelector ()->printCommitMaxQtySelIA (thePart, thePer);
d611 1
a611 1
      maxQty = findMaxQty (netQty, maxQty, thePart, thePer);
d613 1
a613 3
      if (critListMode ())
         if (! (penExec_ && myExpRest ()->failRestShortOnly ()))
            myHeurCritList ()->appendCulprit ();
d615 3
a617 2
      schemeIsFresh = mySelector ()->findFreshScheme ();
      }
d619 1
a619 3
   if (maxQty >= NET_TOL)
      {
      success = commit (thePart, thePer, maxQty);
d621 4
a624 10
      if (! success)
         myMsgFac () ("commitFailedFmsg", 
            thePart->partName (), 
            thePer, 
            maxQty);

      netQty -= maxQty;
   
      witAssert (netQty >= 0.0);
      }
d627 2
a628 1
      mySelector ()->recCommitVol (maxQty, witTRUE);
d630 1
a630 1
   mySelector ()->postPermCommitSS ();
d635 4
a638 4
void WitHeurAllPerf::commitMaxQtySelNss (
      double &  netQty,
      WitPart * thePart,
      WitPeriod thePer)
d640 1
a640 13
   double     oldNetQty;
   double     maxQty;
   WitBoolean success;

   witAssert (! selSplit_);

   if (multiSel ())
      {
      if (DEVELOPMENT)
         nSelCommits_ ++;

      mySelector ()->printCommitMaxQtySelIA (thePart, thePer);
      }
a648 26

   maxQty = findMaxQty (netQty, 0.0, thePart, thePer);

   if (maxQty >= NET_TOL)
      {
      success = commit (thePart, thePer, maxQty);

      if (! success)
         myMsgFac () ("commitFailedFmsg", thePart->partName (), thePer, maxQty);

      netQty -= maxQty;

      witAssert (netQty >= 0.0);
      }

   if (penExec_)
      mySelector ()->recCommitVol (maxQty, witTRUE);

   if (critListMode ())
      {
      if (penExec_)
         if (myExpRest ()->failRestShortOnly ())
            return;

      myHeurCritList ()->appendCulprit ();
      }
d663 8
d1510 1
a1510 1
   commitMaxQty (netVol, theMat, thePer);
@


1.32
log
@Allowed coarse selection splitting with execution bounds.
@
text
@a288 3

      if (penExec_)
         myMsgFac () ("selSplitPESmsg");
d516 1
a516 1
      commitMaxQtySS       (netQty, thePart, thePer);
d518 1
a518 1
      commitMaxQtyMultiSel (netQty, thePart, thePer);
d520 1
a520 1
      commitMaxQtySel      (netQty, thePart, thePer);
d530 1
a530 1
void WitHeurAllPerf::commitMaxQtyMultiSel (
d548 1
a548 1
      commitMaxQtySel (netQty, thePart, thePer);
d561 1
d563 1
d570 3
d575 4
a578 1
   maxQty = 0.0;
d580 3
a582 1
   while (witTRUE)
d584 3
d595 2
a596 1
         myHeurCritList ()->appendCulprit ();
d598 1
a598 4
      if (! mySelector ()->freshSchemeAvail ())
         break;

      mySelector ()->findFreshScheme ();
d616 3
a619 2

   mySelector ()->findFreshScheme ();
d624 1
a624 1
void WitHeurAllPerf::commitMaxQtySel (
d907 3
a909 2
   double    netReqVol;
   WitPeriod expPer;
d924 1
a924 1
      return fillNetReq (thePart, fillPer, netReqVol);
d928 11
a938 1
         return fillNetReqSplitBAS (thePart, fillPer, netReqVol);
d940 2
a941 2
   if (findExpPeriod (thePart, fillPer, expPer))
      return explodePartSS (thePart, expPer, netReqVol, fillPer);
d943 8
a950 1
   return witFALSE;
d955 1
a955 1
WitBoolean WitHeurAllPerf::fillNetReq (
d986 1
a986 1
WitBoolean WitHeurAllPerf::fillNetReqSplitBAS (
d994 2
@


1.31
log
@Implemented coarse selection splitting with the critical parts list.
@
text
@a291 3

      if (finiteExecBounds_)
         myMsgFac () ("selSplitEBSmsg");
@


1.30
log
@Continued development of coarse selection splitting.
@
text
@a292 3
      if (critListMode ())
         myMsgFac () ("selSplitCLSmsg");

d586 3
@


1.29
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d28 4
d152 2
a153 2
         mySelector ()->selExpPeriod (thePart, fillPer):
         thePart      ->explosionPeriod       (fillPer);
d164 2
a165 2
         mySelector ()->selBopEntry (thePart, expPer):
         thePart      ->expBopEntry          (expPer);
d176 2
a177 2
         mySelector ()->selExecPeriod (theBopEnt, expPer):
         theBopEnt    ->expExecPeriod ()         [expPer];
d249 12
d262 1
a262 1
      myExpRest_ = mySelector ()->myExpRest ();
d362 1
a362 1
      mySelector ()->setInitDirIsAsap (asapMultiExec);
d920 1
a920 1
      if (mySelector ()->baSelIsSplit (thePart, fillPer))
d973 1
a973 1
   witAssert (mySelector ()->baSelIsSplit (thePart, fillPer));
d975 1
a975 1
   mySelector ()->startBaSplitExp (thePart, fillPer, netReqVol);
d979 1
a979 1
   while (expOK && mySelector ()->findNextBaSplit (expPer, expVol))
d982 1
a982 1
   mySelector ()->finishBaSplitExp ();
d1003 1
a1003 1
      mySelector ()->recExpMatSS (thePart, expPer, expVol, fillPer);
d1005 1
a1005 1
   if (multiRoute_ && mySelector ()->pmrSelIsSplit (thePart, expPer))
d1007 1
a1007 1
      mySelector ()->startPmrSplitExp (thePart, expPer, expVol);
d1011 1
a1011 1
      while (expOK && mySelector ()->findNextPmrSplit (theBopEnt, splitExpVol))
d1014 1
a1014 1
      mySelector ()->finishPmrSplitExp ();
d1062 1
a1062 1
      mySelector ()->recBopEntExpPerSS (theBopEnt, expPer, expVol);
d1064 1
a1064 1
   if (multiExec_ && mySelector ()->meSelIsSplit (theBopEnt, expPer))
d1066 1
a1066 1
      mySelector ()->startMeSplitExp (theBopEnt, expPer, expVol);
d1070 1
a1070 1
      while (expOK && mySelector ()->findNextMeSplit (execPer, splitExpVol))
d1073 1
a1073 1
      mySelector ()->finishMeSplitExp ();
d1102 1
a1102 1
         mySelector ()->recBopEntExecPerSS (theBopEnt, execPer, qty);
d1266 1
a1266 1
       && mySelector ()->cmrSelIsSplit (theBomEnt, execPer))
d1278 1
a1278 1
            mySelector ()->selConsEntry (theBomEnt, execPer):
d1305 1
a1305 1
   mySelector ()->startCmrSplitExp (theBomEnt, execPer, deltaExecVol);
d1307 1
a1307 1
   while (mySelector ()->findNextCmrSplit (theConsEnt, splitExecVol))
d1315 1
a1315 1
   mySelector ()->finishCmrSplitExp ();
d1456 1
a1456 1
         mySelector ()->recExpConsEntSS (theConsEnt, execPer, netExecQty);
@


1.28
log
@Implemented and used class SelMgr.
@
text
@a273 3
      if (multiExec_)
         myMsgFac () ("selSplitMESmsg");

d951 1
a953 1
   WitBoolean expOK;
d959 2
d963 1
a963 4
   mySelector ()->startBaSplitExp (thePart, fillPer, netReqVol);

   while (mySelector ()->findNextBaSplit (expPer, expVol))
      {
a965 4
      if (! expOK)
         break;
      }

d991 2
d995 1
a995 4
      mySelector ()->startPmrSplitExp (thePart, expPer, expVol);

      while (mySelector ()->findNextPmrSplit (theBopEnt, splitExpVol))
         {
a997 4
         if (! expOK)
            break;
         }

a998 2

      return expOK;
d1004 1
a1004 1
      return explodeBopEntSS (theBopEnt, expPer, expVol, fillPer);
d1006 2
d1039 4
d1046 10
a1055 1
      mySelector ()->recExpBopEntSS (theBopEnt, expPer, expVol);
d1057 10
a1066 6
   return 
      explode (
         theBopEnt,
         theBopEnt->expExecPeriod ()[expPer],
         expVol,
         fillPer);
d1083 4
@


1.27
log
@Fixed some bugs in coarse selection splitting.
@
text
@d240 1
a240 1
      mySelector_ = new WitSelector (myProblem (), buildAhead_);
d361 1
a361 1
      myExpRest ()->replenishPsSups (myAllocMode_);
d954 3
a956 8
   WitPerDblStack splitList (myProblem ());
   double         unExpVol;
   WitBoolean     finSplit;
   WitConstPer *  expPerPtr;
   double         splitVol;
   double         expVol;
   WitPeriod      expPer;
   WitBoolean     expOK;
d959 1
d962 1
a962 1
   mySelector ()->getBaSplitList (thePart, fillPer, splitList);
d964 1
a964 1
   unExpVol = netReqVol;
d966 1
a966 1
   while (unExpVol > NET_TOL)
a967 31
      finSplit = splitList.pop (expPerPtr, splitVol);

      if (finSplit && (splitVol < unExpVol))
         {
         expVol    = splitVol;
         unExpVol -= splitVol;
         }
      else
         {
         expVol    = unExpVol;
         unExpVol  = 0.0;
         }

      if (finSplit)
         expPer = * expPerPtr;

      else if (! findExpPeriod (thePart, fillPer, expPer))
         return witFALSE;
   
      if (myGlobalComp ()->selPrintLevel () >= 4)
         if (myAllocMode_->perm ())
            mySelector ()->prtBaSelSplit (
               thePart,
               fillPer,
               expPer,
               finSplit,
               splitVol);

      if (finSplit)
         mySelector ()->setBaHadFinSplit (witTRUE);

a969 3
      if (finSplit)
         mySelector ()->setBaHadFinSplit (witFALSE);

d971 1
a971 1
         return witFALSE;
d974 3
a976 1
   return witTRUE;
d987 1
d989 1
d998 17
a1014 1
      return explodePartPmrSS (thePart, expPer, expVol, fillPer);
a1045 62
WitBoolean WitHeurAllPerf::explodePartPmrSS (
      WitPart * thePart, 
      WitPeriod expPer,
      double    netReqVol,
      WitPeriod fillPer)
   {
   WitBopEntry * theBopEnt;
   WitBoolean    expOK;
   WitBoolean    finSplit;
   double        splitVol;
   double        expVol;

   WitBopEntDblStack splitList (myProblem ());

   witAssert (multiRoute_);
   witAssert (selSplit_);

   mySelector ()->getPmrSplitList (thePart, expPer, splitList);

   while (netReqVol > NET_TOL)
      {
      finSplit = splitList.pop (theBopEnt, splitVol);

      if (finSplit && (splitVol < netReqVol))
         {
         expVol     = splitVol;
         netReqVol -= splitVol;
         }
      else
         {
         expVol    = netReqVol;
         netReqVol = 0.0;

         if (! finSplit)
            theBopEnt = mySelector ()->selBopEntry (thePart, expPer);
         }

      if (myGlobalComp ()->selPrintLevel () >= 4)
         if (myAllocMode_->perm ())
            mySelector ()->prtPmrSelSplit (
               theBopEnt, 
               expPer, 
               finSplit, 
               splitVol);

      if (finSplit)
         mySelector ()->setPmrHadFinSplit (witTRUE);

      expOK = explodeBopEntSS (theBopEnt, expPer, expVol, fillPer);

      if (finSplit)
         mySelector ()->setPmrHadFinSplit (witFALSE);

      if (! expOK)
         return witFALSE;
      }

   return witTRUE;
   }

//------------------------------------------------------------------------------

a1274 1
   double         unexpVol;
d1276 1
a1276 5
   double         splitVol;
   WitBoolean     finSplit;
   double         deltaConsEntVol;

   WitConsEntDblStack splitList (myProblem ());
d1281 1
a1281 32
   mySelector ()->getCmrSplitList (theBomEnt, execPer, splitList);

   unexpVol = deltaExecVol;

   while (unexpVol > NET_TOL)
      {
      finSplit = splitList.pop (theConsEnt, splitVol);

      if (finSplit && (splitVol < unexpVol))
         {
         deltaConsEntVol = splitVol;
         unexpVol       -= splitVol;
         }
      else
         {
         deltaConsEntVol = unexpVol;
         unexpVol        = 0.0;

         if (! finSplit)
            theConsEnt   = mySelector ()->selConsEntry (theBomEnt, execPer);
         }

      if (myGlobalComp ()->selPrintLevel () >= 4)
         if (myAllocMode_->perm ())
            mySelector ()->prtCmrSelSplit (
               theConsEnt, 
               execPer, 
               finSplit, 
               splitVol);

      if (finSplit)
         mySelector ()->setCmrHadFinSplit (witTRUE);
d1283 1
d1287 1
a1287 1
         deltaConsEntVol,
d1291 1
a1291 3
      if (finSplit)
         mySelector ()->setCmrHadFinSplit (witFALSE);
      }
@


1.26
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d380 1
a380 1
      while (reversedParts.get (thePart))
d888 2
a889 1
   double netReqVol;
d903 2
a904 2
   else if (selSplit_)
      return fillNetReqSS (thePart, fillPer, netReqVol);
d906 8
a913 2
   else
      return fillNetReq   (thePart, fillPer, netReqVol);
d923 1
a926 1
   WitBoolean    restExpOK;
d929 1
d934 1
a934 10
   expPer = expPeriod (thePart, fillPer);

   if (! thePart->explodeable (expPer))
      {
      if (multiSel ())
         mySelector ()->recordShortage (thePart, fillPer);

      if (critListMode ())
         myHeurCritList ()->setCulprit (thePart, fillPer);

d936 1
a936 2
      }

d949 1
a949 1
WitBoolean WitHeurAllPerf::fillNetReqSS (
a953 5
   double     unExpVol;
   WitPeriod  expPer;
   double     expVol;
   WitBoolean expOK;

d955 7
a962 1
   witAssert (selSplit_);
d964 1
a967 5
   if (myGlobalComp ()->selPrintLevel () >= 4)
      if (buildAhead_)
         if (myAllocMode_->perm ())
            mySelector ()->prtBpsSplitAt (thePart, fillPer);

d972 15
a986 2
      expOK = 
         defExpSplit (thePart, fillPer, splitList, unExpVol, expPer, expVol);
d988 1
a988 1
      if (! expOK)
d991 11
a1001 2
      if (buildAhead_)
         mySelector ()->recExpMatSS (thePart, fillPer, expPer, expVol);
d1003 1
a1003 6
      if (mySelector ()->routingIsSplit (thePart, expPer))
         expOK = explodePartSS (thePart, expPer, fillPer, expVol);
      else
         {
         if (multiRoute_)
            mySelector ()->setExpBopEntIsSplit (witFALSE);
d1005 2
a1006 7
         expOK =
            explodeBopEntSS (
               expBopEntry (thePart, expPer),
               expPer, 
               expVol, 
               fillPer);
         }
d1017 5
a1021 7
WitBoolean WitHeurAllPerf::defExpSplit (
      WitPart *        thePart, 
      WitPeriod        fillPer, 
      WitPerDblStack & splitList,
      double &         unExpVol,
      WitPeriod &      expPer,
      double &         expVol)
d1023 1
a1023 3
   WitConstPer * expPerPtr;
   double        splitVol;
   WitBoolean    splitFound;
d1026 1
d1028 2
a1029 1
   splitFound = splitList.get (expPerPtr, splitVol);
d1031 2
a1032 5
   if (splitFound && (splitVol < unExpVol))
      {
      expVol    = splitVol;
      unExpVol -= splitVol;
      }
d1035 3
a1037 2
      expVol    = unExpVol;
      unExpVol  = 0.0;
d1039 3
d1043 9
a1051 5
   if (splitFound)
      expPer = * expPerPtr;
   else
      {
      expPer = expPeriod (thePart, fillPer);
d1053 2
a1054 3
      if (! thePart->explodeable (expPer))
         {
         mySelector ()->recordShortage (thePart, fillPer);
d1056 2
a1057 8
         return witFALSE;
         }
      }
   
   if (buildAhead_)
      if (myGlobalComp ()->selPrintLevel () >= 4)
         if (myAllocMode_->perm ())
            mySelector ()->prtBpsSplitTo (expPer, splitFound, splitVol);
d1059 1
a1059 1
   return witTRUE;
d1064 1
a1064 1
WitBoolean WitHeurAllPerf::explodePartSS (
d1067 2
a1068 2
      WitPeriod fillPer, 
      double    netReqVol)
d1072 1
a1072 1
   WitBoolean    splitFound;
d1081 1
a1081 5
   if (myGlobalComp ()->selPrintLevel () >= 4)
      if (myAllocMode_->perm ())
         mySelector ()->prtRtSplitAtPart (thePart, expPer);

   mySelector ()->getMrSplitList (thePart, expPer, splitList);
d1085 1
a1085 1
      splitFound = splitList.get (theBopEnt, splitVol);
d1087 1
a1087 1
      if (splitFound && (splitVol < netReqVol))
d1097 1
a1097 1
         if (! splitFound)
d1103 5
a1107 1
            mySelector ()->prtRtSplitToBopEnt (theBopEnt, splitFound, splitVol);
d1109 2
a1110 1
      mySelector ()->setExpBopEntIsSplit (splitFound);
d1114 3
d1320 4
a1323 1
   if (multiRoute_ && mySelector ()->routingIsSplit (theBomEnt, execPer))
a1331 4
      if (selSplit_)
         if (multiRoute_)
            mySelector ()->setExpConsEntIsSplit (witFALSE);

d1358 1
a1358 1
   WitBoolean     splitFound;
d1366 1
a1366 5
   if (myGlobalComp ()->selPrintLevel () >= 4)
      if (myAllocMode_->perm ())
         mySelector ()->prtRtSplitAtBomEnt (theBomEnt, execPer);

   mySelector ()->getMrSplitList (theBomEnt, execPer, splitList);
d1372 1
a1372 1
      splitFound = splitList.get (theConsEnt, splitVol);
d1374 1
a1374 1
      if (splitFound && (splitVol < unexpVol))
d1384 1
a1384 1
         if (! splitFound)
d1390 4
a1393 3
            mySelector ()->prtRtSplitToConsEnt (
               theConsEnt,
               splitFound,
d1396 2
a1397 1
      mySelector ()->setExpConsEntIsSplit (splitFound);
d1405 3
@


1.25
log
@Coarse selection splitting.
@
text
@d138 40
d184 2
d271 2
a272 5
      if (! multiRoute_)
         myMsgFac () ("selSplitWoMRSmsg");

      if (buildAhead_)
         myMsgFac () ("selSplitBASmsg");
d298 1
a298 1
      if (selMode ())
d395 1
a395 1
   blocked_.partiallyAllocate (myProblem ());
d513 1
a513 1
   else if (selMode ())
d616 1
a616 1
   if (selMode ())
d714 1
a716 1
   WitBoolean     canExplode;
d728 1
a728 1
   canExplode = defExpCoords (thePart, fillPer, theBopEnt, execPer);
d730 1
a730 1
   if (! canExplode)
d733 4
a736 1
   theOpn = theBopEnt->myOperation ();
d834 1
a834 1
   if (selMode ())
d867 1
a867 4
         if (multiRoute_ && selSplit_)
            fillOK = fillReqSsmrbop (fillPart, fillPer, theReqVol);
         else
            fillOK = fillReq        (fillPart, fillPer, theReqVol);
d888 1
a888 5
   double        netReqVol;
   WitBoolean    canExplode;
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;
   WitBoolean    restExpOK;
d902 21
d926 1
a926 1
   canExplode = defExpCoords (thePart, fillPer, theBopEnt, execPer);
d928 1
a928 1
   if (! canExplode)
d930 1
a930 1
      if (selMode ())
d943 3
d951 4
a954 5
WitBoolean WitHeurAllPerf::defExpCoords (
      WitPart *       thePart, 
      WitPeriod       fillPer, 
      WitBopEntry * & theBopEnt,
      WitPeriod &     execPer)
d956 16
a971 1
   WitPeriod expPer;
d973 12
a984 4
   expPer  = 
      buildAhead_? 
         mySelector ()->selExpPeriod (thePart, fillPer):
         thePart      ->explosionPeriod       (fillPer);
d986 6
a991 2
   if (! thePart->explodeable (expPer))
      return witFALSE;
d993 7
a999 4
   theBopEnt =
      multiRoute_? 
         mySelector ()->selBopEntry (thePart, expPer):
         thePart      ->expBopEntry          (expPer);
d1001 3
a1003 4
   execPer =
      multiExec_?
         mySelector ()->selExecPeriod (theBopEnt, expPer):
         theBopEnt    ->expExecPeriod ()         [expPer];
d1010 7
a1016 4
WitBoolean WitHeurAllPerf::fillReqSsmrbop (
      WitPart * thePart, 
      WitPeriod fillPer, 
      double    theReqVol)
d1018 3
a1020 2
   double        netReqVol;
   WitPeriod     expPer;
a1021 1
   witAssert (multiRoute_);
a1022 1
   witAssert (theReqVol > NET_TOL);
d1024 1
a1024 1
   netReqVol = theReqVol;
d1026 5
a1030 2
   if (stockRealloc ())
      netAndRollReq (thePart, fillPer, netReqVol);
a1031 11
      curAvailSched ()->netWithPreAll (thePart, fillPer, netReqVol);

   if (netReqVol <= NET_TOL)
      return witTRUE;

   expPer  = 
      buildAhead_? 
         mySelector ()->selExpPeriod (thePart, fillPer):
         thePart      ->explosionPeriod       (fillPer);

   if (! thePart->explodeable (expPer))
d1033 2
a1034 3
      mySelector ()->recordShortage (thePart, fillPer);

      return witFALSE;
d1037 2
a1038 2
   if (mySelector ()->routingIsSplit (thePart, expPer))
      return explodePartSsmrbop (thePart, expPer, fillPer, netReqVol);
d1041 1
a1041 1
      mySelector ()->setExpBopEntIsSplit (witFALSE);
d1043 6
a1048 6
      return 
         explodeBopEntSsmrbop (
            mySelector ()->selBopEntry (thePart, expPer),
            expPer, 
            netReqVol, 
            fillPer);
d1050 7
d1061 1
a1061 1
WitBoolean WitHeurAllPerf::explodePartSsmrbop (
d1073 1
a1073 1
   WitBopEntDblStack theSplitList (myProblem ());
d1078 3
a1080 2
   if (myAllocMode_->perm ())
      mySelector ()->prtRtSplitAtPartIA (thePart, expPer);
d1082 1
a1082 1
   mySelector ()->getMrSplitList (thePart, expPer, theSplitList);
d1086 1
a1086 1
      splitFound = theSplitList.get (theBopEnt, splitVol);
d1102 3
a1104 2
      if (myAllocMode_->perm ())
         mySelector ()->prtRtSplitToBopEntIA (theBopEnt, splitFound, splitVol);
d1108 1
a1108 1
      expOK = explodeBopEntSsmrbop (theBopEnt, expPer, expVol, fillPer);
d1119 1
a1119 1
WitBoolean WitHeurAllPerf::explodeBopEntSsmrbop (
d1125 4
a1128 1
   mySelector ()->recExpBopEntSS (theBopEnt, expPer, expVol);
d1190 1
a1190 1
   if (selMode ())
d1279 1
a1279 1
   if (selMode ())
d1323 2
a1324 1
         mySelector ()->setExpConsEntIsSplit (witFALSE);
d1355 1
a1355 1
   WitConsEntDblStack theSplitList (myProblem ());
d1357 2
a1358 1
   witAssert (multiRoute_ && selSplit_);
d1360 3
a1362 2
   if (myAllocMode_->perm ())
      mySelector ()->prtRtSplitAtBomEntIA (theBomEnt, execPer);
d1364 1
a1364 1
   mySelector ()->getMrSplitList (theBomEnt, execPer, theSplitList);
d1370 1
a1370 1
      splitFound = theSplitList.get (theConsEnt, splitVol);
d1386 6
a1391 5
      if (myAllocMode_->perm ())
         mySelector ()->prtRtSplitToConsEntIA (
            theConsEnt,
            splitFound,
            splitVol);
d1523 1
a1523 1
      if (selMode ())
@


1.24
log
@Fixed some bugs in coarse selection splitting.
@
text
@d825 1
a825 1
         if (multiRoute_ && mySelector ()->ssmrForBopEnts ())
d932 1
a932 1
   witAssert (mySelector ()->ssmrForBopEnts ());
d989 1
a989 1
   witAssert (mySelector ()->ssmrForBopEnts ());
@


1.23
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d960 3
d969 1
d1017 2
d1230 3
d1296 2
@


1.22
log
@Futher development of selection splitting.
@
text
@d341 1
a341 1
      while (reversedParts.pop (thePart))
d825 4
a828 1
         fillOK = fillReq (fillPart, fillPer, theReqVol);
a852 1
   WitBoolean    fillOK;
d887 1
a887 3
   explode (theBopEnt, execPer, netReqVol, fillPer, fillOK);

   return fillOK;
d915 1
a915 1
         mySelector ()->selExecPeriod (theBopEnt, expPer, fillPer):
d923 120
a1042 1
void WitHeurAllPerf::explode (
d1046 1
a1046 2
      WitPeriod     fillPer,
      WitBoolean &  expOK)
d1051 1
a1054 2
   expOK        = witTRUE;

d1064 1
a1064 1
      return;
d1067 6
a1072 6
      checkExecBounds (
         theBopEnt,
         execPer,
         oldExecVol + deltaExecVol,
         fillPer,
         expOK);
d1074 1
a1074 2
   if (expOK)
      innerExplode (theBopEnt, execPer, qty, deltaExecVol, fillPer, expOK);
d1079 1
a1079 1
void WitHeurAllPerf::checkExecBounds (
d1083 1
a1083 2
      WitPeriod     fillPer,
      WitBoolean &  expOK)
d1089 2
a1090 4
   expOK = theOpn->execBounds ()->hardUBisSatisfied (execPer, theExecVol);

   if (expOK)
      return;
d1097 2
d1103 1
a1103 1
void WitHeurAllPerf::innerExplode (
d1108 1
a1108 2
      WitPeriod     fillPer,
      WitBoolean &  expOK)
d1110 1
d1158 2
d1215 1
a1215 1
   if (multiRoute_ && selSplit_)
d1257 4
a1260 1
   mySelector ()->getSplitList (theBomEnt, execPer, theSplitList);
d1266 1
a1266 1
      splitFound = theSplitList.pop (theConsEnt, splitVol);
d1282 2
a1283 4
      if (! myAllocMode_->temp ())
         mySelector ()->printSelSplitIA (
            theBomEnt,
            execPer,
@


1.21
log
@Implemented EBS lower bound adjustment for sel-split.
@
text
@d1098 1
a1098 1
   if (selSplit_)
d1137 2
@


1.20
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@d525 4
d536 1
a536 3
      curAvailSched ()->netWithPreAll (thePart, thePer, netQty);

      maxQty = findMaxQty (netQty, thePart, thePer);
d593 1
a593 1
   maxQty = findMaxQty (netQty, thePart, thePer);
d624 1
d635 1
a635 1
   defSearchGrid (thePart, thePer, minQty, incQty);
d646 1
a646 1
            0.0;
d652 1
a652 1
      return 0.0;
d671 1
d681 2
a682 2
   incQty = 1.0;
   minQty = 1.0;
d704 3
a706 1
      minQty = 0.0;
d708 1
d711 3
a713 4
      // Avoid searching on zero.
      //
   if (minQty == 0.0)
      minQty = incQty;
@


1.19
log
@Some minor changes.
@
text
@d472 3
a474 1
   if (selMode ())
d494 2
d513 51
d573 2
a592 4
   if (selSplit_)
      if (mySelector ()->splitting ())
         return;

a604 3
   if (selSplit_)
      mySelector ()->postPermCommitSS ();

a769 3
   if (selMode ())
      mySelector ()->postTempCommit (success);

d782 17
d1309 1
a1309 4
         mySelector ()->setMrSplitVol (
            theConsEnt->myBomEntry (), 
            execPer, 
            netExecQty);
@


1.18
log
@Some minor modifications.
@
text
@d29 1
@


1.17
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d332 1
a332 1
   WitObjDynStack (WitPart) reversedParts (myProblem ());
@


1.16
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d209 13
d242 3
a246 13
   initSoln ();

   if (stockRealloc ())
      myMsgFac () ("stockReallocMsg");

   forEachOperation (theOpn, myProblem ())
      if (! (theOpn->execBounds ()->hardUB () == -1.0))
         {
         finiteExecBounds_ = witTRUE;

         break;
         }

d551 3
d1028 1
a1028 1
      explodeSplitBomEntry (
d1052 1
a1052 1
void WitHeurAllPerf::explodeSplitBomEntry (
d1061 2
a1062 2
   WitBoolean     splitVolFinite;
   double         splitVolVal;
d1065 3
a1067 1
   mySelector ()->findSelConsEntries (theBomEnt, execPer);
d1073 1
a1073 4
      mySelector ()->findNextConsEntry (
         theConsEnt, 
         splitVolFinite, 
         splitVolVal);
d1075 1
a1075 1
      if (splitVolFinite && (splitVolVal < unexpVol))
d1077 2
a1078 2
         deltaConsEntVol = splitVolVal;
         unexpVol       -= splitVolVal;
d1084 3
d1089 8
d1241 7
@


1.15
log
@Implemented respectStockSLBs and prefHighStockSLBs global attributes.
@
text
@d160 1
d209 22
d329 1
a329 1
   WitDynStack (WitPart) reversedParts (myProblem ());
d335 1
a335 1
      reversedParts.reverseCopyOf (myCompMgr ()->allParts ());
d532 4
d997 1
a997 1
      double        netExecQty,
d1004 1
a1004 1
   witAssert (netExecQty >= NET_TOL);
d1012 1
a1012 1
         netConsEntries (theBomEnt, execPer, netExecQty, expOK);
d1014 1
a1014 1
         if (netExecQty < NET_TOL )
d1021 24
a1044 11
   theConsEnt = 
      multiRoute_?
         mySelector ()->selConsEntry (theBomEnt, execPer):
         theBomEnt;

   explodeConsEntry (
      theConsEnt,
      execPer, 
      netExecQty, 
      fillPer, 
      theExpBopEntry);
d1046 42
a1087 4
   if (multiRoute_)
      if (theConsEnt->isaSubEntry ())
         if (myAllocMode_->perm ())
            subVol (theConsEnt->asaSubEntry ()).elemRef (execPer) += netExecQty;
d1220 5
@


1.14
log
@

Revised stand-alone FSS capabilties in development mode.
Modified some stock soft-lower bound controls.
Fixed bug: BOP entry productRate attribute could not be read.
@
text
@d304 1
a304 3
   WitPart *     thePart;
   WitMaterial * theMat;
   WitPeriod     thePer;
d310 3
a312 1
   reversedParts.reverseCopyOf (myCompMgr ()->allParts ());
d314 6
a319 5
   while (reversedParts.pop (thePart))
      if (thePart->isaMaterial (theMat))
         if (! (theMat->stockBounds ()->softLB () == 0.0))
            forEachPeriod (thePer, myProblem ())
               enforceStockSLB (theMat, thePer);
d1142 13
@


1.13
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d99 1
a99 1
   if (myGlobalComp ()->enforceStSLBs ())
@


1.12
log
@Outer API: Merged all no-longer-documented functions into one section.
Outer API: Moved build-ahead by demand functions into the no-longer-documented
   section.
Simplified the rules for two-way multiple execution periods.
@
text
@d1083 1
a1083 1
   reqConsQty = theConsEnt->effUsageRate () * netExecQty;
d1087 1
a1087 1
   if (theConsEnt->effUsageRate () >= FLOAT_EPSILON)
d1093 1
a1093 1
      netExecQty = netConsQty / theConsEnt->effUsageRate ();
d1102 1
a1102 1
      if (theConsEnt->effUsageRate () <= - FLOAT_EPSILON )
d1123 1
a1123 1
   consumedQty = theConsEnt->effUsageRate () * netExecQty;
@


1.11
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d283 1
a283 1
      mySelector ()->preIncForTwme (asapMultiExec, prefBA, thePart, thePer);
a517 3

      if (myGlobalComp ()->twoWayMultiExec ())
         mySelector ()->printPostCommitMaxQtySelIA ();
a599 3
   if (myGlobalComp ()->twoWayMultiExec ())
      mySelector ()->resetCurMeDirs (fillPer);

a709 3
   if (myGlobalComp ()->twoWayMultiExec ())
      mySelector ()->resetCurMeDirs (topPer);

d1131 1
a1131 1
         if (myAllocMode_->temp () || myGlobalComp ()->twoWayMultiExec ())
d1136 1
a1136 2
               fillPer,
               myAllocMode_->temp ());
@


1.10
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@a162 3
      shipVolDupTl_     (),
      permExecVolDupTl_ (),
      subVolDupTl_      (),
d175 1
a175 1
   myAllocMode_ = new WitAllocMode (this);
a227 4
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

a237 9
   forEachDemand (theDemand, myProblem ())
      delete shipVolDup (theDemand);

   forEachOperation (theOpn, myProblem ())
      delete permExecVolDup (theOpn);

   forEachSubEntry (theSub, myProblem ())
      delete subVolDup (theSub);

d292 1
a292 1
      shipVolDup (theDemand)->inc (thePer, incVol);
a351 4
   shipVolDupTl_    .allocate (myProblem (), NULL);
   permExecVolDupTl_.allocate (myProblem (), NULL);
   subVolDupTl_     .allocate (myProblem (), NULL);

d353 1
a353 1
      shipVolDup (theDemand) = new WitDupTVec (shipVol (theDemand), 0.0);
d356 1
a356 1
      permExecVolDup (theOpn) = new WitDupTVec (execVol (theOpn), 0.0);
d359 1
a359 1
      subVolDup (theSub) = new WitDupTVec (subVol (theSub), 0.0);
d620 1
a620 1
   if (myAllocMode_->execVol (theOpn)[execPer] > FLOAT_EPSILON)
d844 1
a844 1
   oldExecVol   = myAllocMode_->execVol (theOpn)[execPer];
d1017 1
a1017 1
            subVolDup (theConsEnt->asaSubEntry ())->inc (execPer, netExecQty);
d1073 2
a1074 2
      subVolDup (theSub)->
         inc (execPer, positivePart (oldExecQty - netExecQty));
@


1.9
log
@Finished implementing stock reallocation.
@
text
@d99 3
d213 2
a214 2
   if (! stockRealloc ())
      myMsgFac () ("noStockReallocMsg");
d318 21
d457 3
a459 2
      if (blocked_ (thePart, thePer))
         return;
d470 3
a472 2
      if (netQty > SEARCH_TOL)
         blocked_ (thePart, thePer) = witTRUE;
d1171 36
@


1.8
log
@Made HeurAllPerf::findMaxQty test desQty when it's < minQty.
   This fixed a "commit failed" error, by making the heuristic function
   properly in cases in which commit fails at a lower desQty than one in which
   it succeeds.
Moved top-level net into commitMaxQtySel.
@
text
@d23 1
d211 1
a211 14
      {
      if (emulatedSF ())
         myMsgFac () ("genericSmsg", 
            "Emulated stock freezing is not allowed without stock "
            "reallocation");

      forEachPart (thePart, myProblem ())
         copy (
            myAllocMode_->curNetSuppForUpdate (thePart), 
            thePart->supplyVol ());
      }

   if (emulatedSF ())
      myMsgFac () ("emulatedSFMsg");
d495 1
a495 8
   if (stockRealloc ())
      curAvailSched ()->netWithPreAll (thePart, thePer, netQty);
   else
      netQty = 
         thePart->net (
            thePer, 
            netQty,
            myAllocMode_->curNetSuppForUpdate (thePart));
d755 1
a755 3
   if (emulatedSF ())
      curAvailSched ()->netWithPreAll (thePart, fillPer, netReqVol);
   else if (stockRealloc ())
d758 1
a758 5
      netReqVol = 
         thePart->net (
            fillPer, 
            netReqVol,
            myAllocMode_->curNetSuppForUpdate (thePart));
d930 1
a930 4
      if (stockRealloc ())
         curAvailSched ()->addToIncAvail (prodPart, prodPer, deltaProdVol);
      else
         myAllocMode_->curNetSuppForUpdate (prodPart)[prodPer] += deltaProdVol;
d940 1
a940 17
   if (stockRealloc ())
      curAvailSched ()->addToIncAvail (theBopEnt->myPart (), fillPer, - qty);
   else
      {
      thePart = theBopEnt->myPart ();

      expPer  = theBopEnt->impactPeriod ()[execPer];

      double & netSupplyVol = 
         myAllocMode_->curNetSuppForUpdate (thePart)[expPer];

      netSupplyVol -= qty;

      witAssert (netSupplyVol > - SEARCH_TOL);

      setToMax (netSupplyVol, 0.0);
      }
a953 1
   witAssert (! emulatedSF ());
d1094 1
a1094 8
      if (stockRealloc ())
         curAvailSched ()->netWithPreAll (consPart, consPer, netConsQty);
      else
         netConsQty =
            consPart->net (
               consPer,
               netConsQty,
               myAllocMode_->curNetSuppForUpdate (consPart));
d1106 1
a1106 6
         {
         if (stockRealloc ())
            curAvailSched ()->addToIncAvail (consPart, consPer, - reqConsQty);
         else
            myAllocMode_->curNetSuppForUpdate (consPart)[consPer] -= reqConsQty;
         }
d1144 1
a1144 6
      {
      if (stockRealloc ())
         curAvailSched ()->addToIncAvail (consPart, consPer, - consumedQty);
      else
         myAllocMode_->curNetSuppForUpdate (consPart)[consPer] -= consumedQty;
      }
@


1.7
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d210 6
d220 4
d397 1
a397 1
   WitPeriod firstStockPer;
a402 12
   if (stockRealloc ())
      curAvailSched ()->netWithPreAll (thePart, lastPer, netQty);
   else
      netQty = 
         thePart->net (
            lastPer, 
            netQty,
            myAllocMode_->curNetSuppForUpdate (thePart));

   if (penExec_)
      mySelector ()->recCommitVol (qty - netQty, witFALSE);

d408 1
a408 1
   else
d410 2
a411 2
      for (firstStockPer = lastPer; firstStockPer > firstPer; -- firstStockPer)
         if (! thePart->canStock (firstStockPer - 1))
d414 4
a417 5
      if (prefBA)
         for (thePer = firstStockPer; thePer <= lastPer; ++ thePer)
            {
            if (netQty <= NET_TOL)
               break;
d419 8
a426 7
            commitMaxQty (netQty, thePart, thePer);
            }
      else
         for (thePer = lastPer; thePer >= firstStockPer; -- thePer)
            {
            if (netQty <= NET_TOL)
               break;
d428 5
a432 3
            commitMaxQty (netQty, thePart, thePer);
            }
      }
d492 1
d504 15
d565 12
d582 1
a582 7
         // Lower end point is infeasible.

   if (desQty <= minQty + SEARCH_TOL)
      return min (desQty, minQty);
         //
         // Desired quantity is no larger than lower end point, which is
         // feasible.
d589 1
a589 1
         // Desired quantity is feasible.
d774 3
a776 1
   if (stockRealloc ())
d998 1
@


1.6
log
@Continued implementation of stock reallocation.
@
text
@d209 1
a209 1
   if (! stockReAlloc ())
d285 1
a285 1
      WitUtil::min (
d302 1
a302 1
   firstPer = WitUtil::max (0, thePer - theDemand->buildAheadUB ()[thePer]);
d393 1
a393 1
   if (stockReAlloc ())
d434 1
a434 1
   return qty - WitUtil::positivePart (netQty);
d557 1
a557 1
      return WitUtil::min (desQty, minQty);
d752 1
a752 1
   if (stockReAlloc ())
d931 1
a931 1
      if (stockReAlloc ())
d944 1
a944 1
   if (stockReAlloc ())
d959 1
a959 1
      WitUtil::setToMax (netSupplyVol, 0.0);
d973 1
a973 1
   witAssert (stockReAlloc ());
d1088 1
a1088 1
         inc (execPer, WitUtil::positivePart (oldExecQty - netExecQty));
d1114 1
a1114 1
      if (stockReAlloc ())
d1134 1
a1134 1
         if (stockReAlloc ())
d1177 1
a1177 1
      if (stockReAlloc ())
@


1.5
log
@Continued implementation of stock re-allocation.
@
text
@d23 1
d133 7
d157 1
a157 1
      myReqSched_       (myProblem ()),
d176 2
d254 1
d394 1
a394 1
      myAllocMode_->netWithPreAll (thePart, lastPer, netQty);
d705 1
a705 1
   myReqSched_.init (topPart, topPer, qty);
d711 2
a712 2
      for ( fillPer =  myReqSched_.firstPer (fillPart); 
            fillPer <= myReqSched_.lastPer  (fillPart);
d715 1
a715 1
         theReqVol = myReqSched_ (fillPart, fillPer);
d932 1
a932 1
         myAllocMode_->addToCurIncAvail    (prodPart, prodPer,    deltaProdVol);
d945 1
a945 1
      myAllocMode_->addToCurIncAvail (theBopEnt->myPart (), fillPer, - qty);
d975 1
a975 1
   rollPer = myAllocMode_->netAndRoll (thePart, thePer, netReqVol, rollVol);
d980 1
a980 1
   myReqSched_.addTo (thePart, rollPer, rollVol);
d1115 1
a1115 1
         myAllocMode_->netWithPreAll (consPart, consPer, netConsQty);
d1135 1
a1135 1
            myAllocMode_->addToCurIncAvail (consPart, consPer, - reqConsQty);
d1163 1
a1163 1
      myReqSched_.addTo (consPart, consPer, consumedQty);
d1178 1
a1178 1
         myAllocMode_->addToCurIncAvail    (consPart, consPer, -  consumedQty);
@


1.4
log
@Minor update to stock re-allocation.
@
text
@d16 1
a16 3
//    DupTVec
//    AllocMode
//    HeurCritList
a19 2
#include <AllMode.h>
#include <HeurCrit.h>
a21 1
#include <Dated.h>
d23 4
d129 1
a129 1
// Implementation of class DupTVec.
d132 25
a156 3
WitDupTVec::WitDupTVec (WitTVec (float) & theVec, double theValue):
      duplicate_ (),
      origVec_   (theVec)
d158 24
a181 1
   duplicate_.resize (origVec_.length (), theValue);
d183 31
a213 1
   origVec_ = theValue;
d218 1
a218 1
WitDupTVec::~WitDupTVec ()
d220 28
d252 5
a256 1
void WitDupTVec::copy (const WitTVec (double) & theVec)
d258 27
a284 1
   duplicate_ = theVec;
d286 16
a301 1
   ::copy (origVec_, duplicate_);
a304 2
// Implementation of class AllocMode.
//------------------------------------------------------------------------------
d306 1
a306 15
WitAllocMode::WitAllocMode (WitHeurAllPerf * thePerf):
      WitProbAssoc     (thePerf),
      
      myHeurAllPerf_   (thePerf),
      temp_            (witFALSE),
      permNetSupp_     (),
      tempNetSupp_     (),
      netSuppAltered_  (),
      netSuppAltParts_ (myProblem ()),
      tempExecVol_     (myProblem (), 0.0),
      alteredOpnPers_  (myProblem ()),
      permSurplus_     (),
      tempSurplus_     (),
      surplusAltered_  (),
      surpAltParts_    (myProblem ())
d308 6
a313 3
   if (stockReAlloc ())
      initSurplus ();
   else
d315 9
a323 3
      permNetSupp_   .allocate (myProblem (), 0.0);
      tempNetSupp_   .allocate (myProblem (), 0.0);
      netSuppAltered_.allocate (myProblem (), witFALSE);
d329 1
a329 1
WitAllocMode::~WitAllocMode ()
d331 19
d354 1
a354 1
void WitAllocMode::enterTempMode ()
d356 2
a357 1
   witAssert (! temp_);
d359 1
a359 1
   temp_ = witTRUE;
d361 4
a364 1
   resetTempData ();
d369 6
a374 1
void WitAllocMode::leaveTempMode ()
d376 14
a389 1
   witAssert (temp_);
d391 33
a423 1
   temp_ = witFALSE;
d428 4
a431 1
void WitAllocMode::resetTempData ()
d433 3
a435 3
   WitPart *      thePart;
   WitOperation * theOpn;
   WitPeriod      thePer;
d437 2
a438 4
   if (stockReAlloc ())
      while (surpAltParts_.pop (thePart))
         {
         tempSurplus_    (thePart) = permSurplus_ (thePart);
d440 2
a441 2
         surplusAltered_ (thePart) = witFALSE;
         }
d443 24
a466 3
      while (netSuppAltParts_.pop (thePart))
         {
         tempNetSupp_    (thePart) = permNetSupp_ (thePart);
d468 1
a468 2
         netSuppAltered_ (thePart) = witFALSE;
         }
d470 2
a471 3
   while (alteredOpnPers_.pop (theOpn, thePer))
      tempExecVol_ (theOpn, thePer) = 
         permExecVolDup (theOpn)->duplicate ()[thePer];
d476 4
a479 1
WitTVec (double) & WitAllocMode::curNetSuppForUpdate (WitPart * thePart)
d481 30
a510 1
   witAssert (! stockReAlloc ());
d512 1
a512 1
   if (! netSuppAltered_ (thePart))
d514 3
a516 1
      netSuppAltered_    (thePart) = witTRUE;
d518 1
a518 1
      netSuppAltParts_.push (thePart);
a519 5
                                   
   return 
      temp_?
         tempNetSupp_ (thePart):
         permNetSupp_ (thePart);
d524 4
a527 4
void WitAllocMode::incExecVol (
      WitOperation * theOpn,
      WitPeriod      thePer,
      double         delta)
d529 73
a601 2
   if (temp_)
      tempExecVol_   (theOpn)      [thePer] += delta;
d603 1
a603 1
      permExecVolDup (theOpn)->inc (thePer,    delta);
d605 4
a608 1
   alteredOpnPers_.push (theOpn, thePer);
d613 2
a614 1
void WitAllocMode::netOnGoingSurplus (
d616 20
a635 5
      WitPeriod initPer,
      double &  theReqVol)
   {
   double    deltaVol;
   WitPeriod thePer;
d637 1
a637 1
   witAssert (stockReAlloc ());
d639 3
a641 1
   deltaVol = theReqVol;
d643 1
a643 3
   for (thePer = initPer; thePer < nPeriods (); thePer ++)
      {
      WitUtil::updateToMin (deltaVol, curSurplus (thePart)[thePer]);
d645 1
a645 2
      if (deltaVol < NET_TOL)
         return;
d647 4
a650 2
      if (! thePart->canStock (thePer))
         break;
d653 1
a653 1
   WitTVec (double) & curSurplusVec = curSurplusForUpdate (thePart);
d655 11
a665 1
   theReqVol -= deltaVol;
d667 8
a674 3
   for (thePer = initPer; thePer < nPeriods (); thePer ++)
      {
      curSurplusVec[thePer] -= deltaVol;
d676 1
a676 3
      if (! thePart->canStock (thePer))
         break;
      }
d681 4
a684 4
void WitAllocMode::netAgainstSurplus (
      WitPart * thePart, 
      WitPeriod thePer, 
      double &  reqVol)
d686 33
a718 1
   witAssert (stockReAlloc ());
d720 1
a720 2
   if (curSurplus (thePart)[thePer] >= NET_TOL)
      WitUtil::net (reqVol, curSurplusForUpdate (thePart)[thePer]);
d725 1
a725 1
void WitAllocMode::incSurplus (
d727 2
a728 2
      WitPeriod initPer, 
      double    deltaVol)
d730 25
a754 1
   witAssert (stockReAlloc ());
d756 1
a756 2
   WitPeriod          thePer;
   WitTVec (double) & curSurplusVec = curSurplusForUpdate (thePart);
d758 1
a758 1
   for (thePer = initPer; thePer < nPeriods (); thePer ++)
d760 5
a764 1
      curSurplusVec[thePer] += deltaVol;
d766 1
a766 2
      if (! thePart->canStock (thePer))
         break;
d768 8
d780 5
a784 1
void WitAllocMode::initSurplus ()
d786 64
a849 3
   WitPart * thePart;
   WitPeriod thePer;
   double    surplusVal;
d851 8
a858 3
   permSurplus_   .allocate (myProblem (), 0.0);
   tempSurplus_   .allocate (myProblem (), 0.0);
   surplusAltered_.allocate (myProblem (), witFALSE);
d860 1
a860 3
   forEachPart (thePart, myProblem ())
      {
      surplusVal = 0.0;
d862 1
a862 3
      forEachPeriod (thePer, myProblem ())
         {
         surplusVal += thePart->supplyVol ()[thePer];
d864 2
a865 1
         permSurplus_ (thePart, thePer) = surplusVal;
d867 2
a868 4
         if (! thePart->canStock (thePer))
            surplusVal = 0.0;
         }
      }
d870 2
a871 1
   tempSurplus_ = permSurplus_;
d876 7
a882 1
WitTVec (double) & WitAllocMode::curSurplusForUpdate (WitPart * thePart)
d884 48
a931 1
   witAssert (stockReAlloc ());
d933 3
a935 1
   if (! surplusAltered_ (thePart))
d937 3
a939 1
      surplusAltered_    (thePart) = witTRUE;
d941 8
a948 1
      surpAltParts_.push (thePart);
a949 5
                                   
   return 
      temp_?
         tempSurplus_ (thePart):
         permSurplus_ (thePart);
a952 2
// Implementation of class HeurCritList.
//------------------------------------------------------------------------------
d954 14
a967 3
WitHeurCritList::WitHeurCritList (
         WitProblem * theProblem,
         WitAccFlag * theAccFlag):
d969 1
a969 1
      WitProbAssoc   (theProblem),
d971 3
a973 5
      myAccFlag_     (theAccFlag),
      culpritPart_   (NULL),
      culpritPeriod_ (0),
      listed_        (myProblem (), witFALSE)
   {
d978 7
a984 1
WitHeurCritList::~WitHeurCritList ()
d986 35
d1025 5
a1029 1
void WitHeurCritList::setCulprit (WitPart * thePart, WitPeriod thePer)
d1031 8
a1038 1
   witAssert (thePart != NULL);
d1040 13
a1052 2
   culpritPart_   = thePart;
   culpritPeriod_ = thePer;
d1057 5
a1061 1
void WitHeurCritList::appendCulprit ()
d1063 1
a1063 1
   WitDatedPart * theDP;
d1065 1
a1065 1
   if (culpritPart_ == NULL)
d1068 1
a1068 1
   if (listed_ (culpritPart_, culpritPeriod_))
d1071 1
a1071 1
   theDP = new WitDatedPart (culpritPart_, culpritPeriod_);
d1073 19
a1091 1
   criticalList (myGlobalComp ()).append (theDP);
d1093 1
a1093 1
   listed_ (culpritPart_, culpritPeriod_) = witTRUE;
d1095 36
a1130 1
   culpritPart_ = NULL;
d1135 36
a1170 3
void WitHeurCritList::initSoln ()
   {
   criticalList (myGlobalComp ()).clearContents ();
@


1.3
log
@Initial implementation of stock re-allocation.
@
text
@d177 3
a179 1
   if (usingNetSupp ())
a184 3

   if (usingSurplus ())
      initSurplus ();
d221 8
a228 1
   if (usingNetSupp ())
a235 8
   if (usingSurplus ())
      while (surpAltParts_.pop (thePart))
         {
         tempSurplus_    (thePart) = permSurplus_ (thePart);

         surplusAltered_ (thePart) = witFALSE;
         }

d245 1
a245 1
   witAssert (usingNetSupp ());
d285 1
a285 1
   witAssert (usingSurplus ());
d320 1
a320 1
   witAssert (usingSurplus ());
d333 1
a333 1
   witAssert (usingSurplus ());
d381 1
a381 1
   witAssert (usingSurplus ());
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d162 1
a162 1
      WitProbAssoc    (thePerf),
d164 12
a175 8
      myHeurAllPerf_  (thePerf),
      temp_           (witFALSE),
      permNetSupp_    (myProblem (), 0.0),
      tempNetSupp_    (myProblem (), 0.0),
      netSuppAltered_ (myProblem (), witFALSE),
      alteredParts_   (myProblem ()),
      tempExecVol_    (myProblem (), 0.0),
      alteredOpnPers_ (myProblem ())
d177 9
d222 12
a233 3
   while (alteredParts_.pop (thePart))
      {
      tempNetSupp_    (thePart) = permNetSupp_ (thePart);
d235 2
a236 2
      netSuppAltered_ (thePart) = witFALSE;
      }
d245 1
a245 1
void WitAllocMode::saveTempData ()
d247 1
a247 7
   WitPart *      thePart;
   WitOperation * theOpn;
   WitPeriod      thePer;

   while (alteredParts_.pop (thePart))
      {
      permNetSupp_    (thePart) = tempNetSupp_ (thePart);
a248 11
      netSuppAltered_ (thePart) = witFALSE;
      }

   while (alteredOpnPers_.pop (theOpn, thePer))
      permExecVolDup (theOpn)->set (thePer, tempExecVol_ (theOpn, thePer));
   }

//------------------------------------------------------------------------------

WitTVec (double) & WitAllocMode::netSuppForUpdate (WitPart * thePart)
   {
d253 1
a253 1
      alteredParts_.push (thePart);
d275 121
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.134;
access;
symbols
	sce_5_01_20080919:1.118
	latest_sce_4_20_20060523:1.61.0.2
	sce_4_20_20060523:1.61
	latest_sce4_20_OSL:1.58.0.2
	sce_4_20_OSL:1.58
	sce_410_withVa:1.57
	sce_4_05_20040511:1.48
	sce_4_00_20040201:1.21
	nextGenBranch:1.20.0.2
	nextGenRoot:1.20
	sce_3_30_20030627:1.20
	EndRw-branch:1.13.0.4
	Root-of-EndRw:1.13
	rwToStl:1.13.0.2
	latest_sce_3_10_20010924:1.9.0.2
	sce_3_10_20010924:1.9
	latest_sce_3_00_20010601:1.7.0.2
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.4.0.4
	sce_2_31_20010308:1.4
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.134
date	2011.09.28.23.49.00;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2011.09.24.00.27.17;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2011.08.30.20.17.14;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2011.01.13.00.38.39;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2010.09.10.22.10.37;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2010.06.23.18.25.15;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.22.23.30.54;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.16.20.56.28;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2010.03.26.22.22.52;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2010.03.16.22.42.23;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2010.03.16.21.22.15;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2010.03.13.00.35.49;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.25.19.45.17;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2009.12.24.19.14.52;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2009.12.14.21.34.54;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2009.12.08.21.44.06;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2008.07.02.17.48.33;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2008.03.03.21.41.14;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2008.02.07.18.41.39;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2008.01.18.22.40.57;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2008.01.11.21.47.41;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2008.01.09.22.33.56;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2008.01.09.21.17.27;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2008.01.04.20.25.27;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2007.12.06.22.52.59;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2007.11.29.21.12.30;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2007.11.29.19.18.03;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2007.11.29.16.24.42;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2007.11.28.23.23.44;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2007.11.27.22.24.42;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.10.26.15.48.13;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.10.22.19.58.51;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.10.18.23.14.43;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.17.14.58.47;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.15.21.50.33;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.10.12.23.04.57;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.10.11.19.16.55;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.09.28.22.08.24;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.09.27.19.57.40;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.08.28.17.38.33;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.08.01.22.41.55;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.20.19.07.53;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.06.19.21.45.50;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.06.18.21.53.31;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.06.15.22.15.25;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.06.15.17.44.35;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.06.14.21.38.31;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.05.21.15.20.09;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.03.22.05.29;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.05.03.19.36.16;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.30.21.52.08;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.04.30.20.10.32;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.04.30.19.52.04;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.04.30.19.32.30;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.04.25.23.30.29;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.04.25.20.39.59;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.04.23.22.46.03;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.04.23.21.03.19;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.04.20.20.51.13;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.04.19.14.52.48;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.04.18.23.09.41;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.16.21.32.57;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.16.17.53.22;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.16.17.41.28;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.10.20.49.29;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.10.20.10.15;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.10.16.33.21;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.09.16.05.07;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.04.22.08.17;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.04.20.04.38;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.04.16.16.01;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.03.22.04.02;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.02.23.07.12;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.16.21.52.55;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.16.14.51.30;	author gresh;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.02.17.33.53;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.21.15.37.51;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2005.07.13.21.18.46;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.11.22.53.49;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.08.20.48.19;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.21.21.49.25;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.24.23.23.54;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.20.23.22.32;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.20.20.28.09;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.11.04.16.30.13;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.13.19.21.34;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.20.18.25.21;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.04.19.22.16.27;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.19.18.25.17;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.13.21.50.12;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.09.21.24.26;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.09.19.37.56;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.06.15.42.16;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.02.23.45.20;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.01.21.05.11;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.29.23.21.27;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.29.22.25.14;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.27.00.08.20;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.26.22.29.41;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.25.20.35.02;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.25.19.59.37;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.24.23.06.32;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.24.16.50.34;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.04.16.31.45;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.20.15.37.35;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.19.21.21.27;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.12.19.13.38;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.07.00.12.09;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.06.00.17.32;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.04.22.31.26;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.04.18.57.49;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.30.23.07.50;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.05.20.18.23;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.07.18.06.13;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.21.18.56.21;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.14.20.12.53;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.31.21.28.52;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.27.21.17.15;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.02.23.40.35;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.02.22.18.17;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.23.18.09.09;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.09.19.52.29;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.14.02.25;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.29.23.47.06;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.31.00.26.25;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.01.19.23.30;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.06.19.22.07;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.12.19.48.02;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.16.37.03;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.12.28;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.18;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.14;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.18;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.18;	author wit;	state Exp;
branches;
next	;


desc
@@


1.134
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "ApiCall.C"
//
// Contains the implementation of the following classes:
//
//    ApiCall
//    GlobalCompApiCall
//    OptCompApiCall
//    StochApiCall
//    PartApiCall
//    MaterialApiCall
//    DemandApiCall
//    OperationApiCall
//    BomEntryApiCall
//    SubEntryApiCall
//    BopEntryApiCall
//------------------------------------------------------------------------------

#include <ApiCall.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <WitRun.h>
#include <IVRealArg.h>
#include <DetOptImpMgr.h>
#include <CompMgr.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Material.h>
#include <Operation.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <Demand.h>
#include <BoundSet.h>
#include <MultiObjMgr.h>
#include <StochImpMgr.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class ApiCall.
//------------------------------------------------------------------------------

inline WitInputID * WitApiCall::myInputID ()
   {
   return myApiMgr ()->myInputID ();
   }

//------------------------------------------------------------------------------

void WitApiCall::prepBool (
      const char * theAttName,
      bool         oldValue,
      WitBoolean   theValue)
   {
   prepSetAttr (theAttName);

   if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
      myMsgFac () ("setBooleanAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepInt (
      const char * theAttName,
      int          oldValue,
      int          theValue)
   {
   prepSetAttr (theAttName);

   if (myMsgFac ().mayIssue ("setIntAttrMsg"))
      myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepNonNegInt (
      const char * theAttName,
      int          oldValue,
      int          theValue)
   {
   prepSetAttr (theAttName);

   if (theValue < 0)
      {
      errorFound ();

      myMsgFac () ("intLowEqSmsg", theValue, 0);
      }
   else
      if (myMsgFac ().mayIssue ("setIntAttrMsg"))
         myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepImmPosInt (
      const char * theAttName,
      int          oldValue,
      int          theValue)
   {
   prepSetAttr (theAttName);

   if (theValue < 1)
      myMsgFac () ("intLowEqImmSmsg", theValue, 1);

   if (myMsgFac ().mayIssue ("setIntAttrMsg"))
      myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepRangedInt (
      const char * theAttName,
      int          oldValue,
      int          theValue,
      int          lb,
      int          ub)
   {
   prepSetAttr (theAttName);

   if ((theValue < lb) or (theValue > ub))
      {
      errorFound ();

      myMsgFac () ("intLowEqUpEqSmsg", theValue, lb, ub);
      }
   else
      if (myMsgFac ().mayIssue ("setIntAttrMsg"))
         myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepImmRangedInt (
      const char * theAttName,
      int          oldValue,
      int          theValue,
      int          lb,
      int          ub)
   {
   prepSetAttr (theAttName);

   if ((theValue < lb) or (theValue > ub))
      myMsgFac () ("intLowEqUpEqImmSmsg", theValue, lb, ub);
   else
      if (myMsgFac ().mayIssue ("setIntAttrMsg"))
         myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepDouble (
      const char * theAttName,
      double       oldValue,
      double       theValue)
   {
   prepSetAttr (theAttName);

   if (myMsgFac ().mayIssue ("setDblAttrMsg"))
      myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepNonNegDouble (
      const char * theAttName, 
      double       oldValue,
      double       theValue)
   {
   prepLBDouble (theAttName, oldValue, theValue, 0.0, 0.0);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepLBDouble (
      const char * theAttName, 
      double       oldValue, 
      double       theValue,
      double       lb,
      double       msgLB)
   {
   prepSetAttr (theAttName);

   if (theValue < lb)
      {
      errorFound ();

      myMsgFac () ("dblLowEqSmsg", theValue, msgLB);
      }
   else
      if (myMsgFac ().mayIssue ("setDblAttrMsg"))
         myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepNonNegUBDouble (
      const char * theAttName, 
      double       oldValue, 
      double       theValue,
      double       ub,
      double       msgUB)
   {
   prepSetAttr (theAttName);

   if (theValue < 0.0)
      myMsgFac () ("dblLowEqUpEqImmSmsg", theValue, 0.0, msgUB);

   if (theValue > ub)
      myMsgFac () ("dblLowEqUpEqImmSmsg", theValue, 0.0, msgUB);

   if (myMsgFac ().mayIssue ("setDblAttrMsg"))
      myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepPosDouble (
      const char * theAttName,
      double       oldValue,
      double       theValue)
   {
   prepSetAttr (theAttName);

   if (theValue <= 0.0)
      {
      errorFound ();

      myMsgFac () ("dblLowSmsg", theValue, 0.0);
      }
   else
      if (myMsgFac ().mayIssue ("setDblAttrMsg"))
         myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepBoolVec (
      const char *       theAttName,
      const WitBoolean * theValue)
   {
   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   if (myMsgFac ().mayIssue ("setVecBoolAttrMsg"))
      {
      WitMsgArg theMsgArg (theValue, nPeriods ());

      myMsgFac () ("setVecBoolAttrMsg", theAttName, theMsgArg);
      }
   }

//------------------------------------------------------------------------------

void WitApiCall::prepIntVec (
      const char * theAttName,
      const int *  theValue)
   {
   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
      {
      WitMsgArg theMsgArg (theValue, nPeriods ());

      myMsgFac () ("setVecIntAttrMsg", theAttName, theMsgArg);
      }
   }

//------------------------------------------------------------------------------

void WitApiCall::prepDblVec (
      const char *         theAttName,
      const WitIVRealArg & theValue)
   {
   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   theValue.issueSetDblVecMsg (theAttName, * this);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepNonNegDblVec (
      const char *         theAttName,
      const WitIVRealArg & theValue)
   {
   WitPeriod thePer;

   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   forEachPeriod (thePer, myProblem ())
      if (theValue[thePer] < 0.0)
         {
         errorFound (thePer);

         myMsgFac () ("dblLowEqSmsg", theValue[thePer], 0.0);
         }

   if (argsOK_)
      theValue.issueSetDblVecMsg (theAttName, * this);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepBuildAheadUB (const int * theValue)
   {
   WitPeriod thePer;

   prepSetAttr ("buildAheadUB");

   checkPeriodIntVec (theValue);

   for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
      {
      if (theValue[thePer + 1] > theValue[thePer] + 1)
         {
         errorFound (thePer);

         myMsgFac () ("selfConsistSmsg",
            "buildAheadUB[t+1] <= buildAheadUB[t] + 1",
            "buildAheadUB",
            thePer,
            theValue[thePer],
            thePer + 1,
            theValue[thePer + 1]);
         }
      }

   if (argsOK_)
      if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
         {
         WitMsgArg theMsgArg (theValue, nPeriods ());

         myMsgFac () ("setVecIntAttrMsg", "buildAheadUB", theMsgArg);
         }
   }

//------------------------------------------------------------------------------

void WitApiCall::prepLeadTimeUB (const int * theValue)
   {
   WitPeriod thePer;

   prepSetAttr ("leadTimeUB");

   checkPeriodIntVec (theValue);

   for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
      {
      if (theValue[thePer + 1] > theValue[thePer] + 1)
         {
         errorFound (thePer);

         myMsgFac () ("selfConsistSmsg",
            "leadTimeUB[t+1] <= leadTimeUB[t] + 1",
            "leadTimeUB",
            thePer,
            theValue[thePer],
            thePer + 1,
            theValue[thePer + 1]);
         }
      }

   if (argsOK_)
      if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
         {
         WitMsgArg theMsgArg (theValue, nPeriods ());

         myMsgFac () ("setVecIntAttrMsg", "leadTimeUB", theMsgArg);
         }
   }

//------------------------------------------------------------------------------

void WitApiCall::prepShipLateUB (const int * theValue)
   {
   WitPeriod thePer;

   prepSetAttr ("shipLateUB");

   checkPeriodIntVec (theValue);

   for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
      {
      if (theValue[thePer + 1] < theValue[thePer] - 1)
         {
         errorFound (thePer);

         myMsgFac () ("selfConsistSmsg",
            "shipLateUB[t+1] >= shipLateUB[t] - 1",
            "shipLateUB",
            thePer,
            theValue[thePer],
            thePer + 1,
            theValue[thePer + 1]);
         }
      }

   if (argsOK_)
      if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
         {
         WitMsgArg theMsgArg (theValue, nPeriods ());

         myMsgFac () ("setVecIntAttrMsg", "shipLateUB", theMsgArg);
         }
   }

//------------------------------------------------------------------------------

void WitApiCall::prepString (
      const char *      theAttName,
      const WitString & oldValue,
      const char *      theValue)
   {
   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   if (myMsgFac ().mayIssue ("setStringAttrMsg"))
      myMsgFac () ("setStringAttrMsg", theAttName, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::setAppData (void * appData)
   {
   prepSetAttr ("appData");

   if (argsOK ())
      myComponent ()->setAppData (appData);
   }

//------------------------------------------------------------------------------

void WitApiCall::setSelForDel (WitBoolean theValue)
   {
   prepBool ("selForDel", myDelComp ()->selForDel (), theValue);

   if (argsOK ())
      myDelComp ()->setSelForDel (asaBool (theValue));
   }

//------------------------------------------------------------------------------

void WitApiCall::setEarliestPeriod (int theValue)
   {
   prepRangedInt (
      "earliestPeriod",
      myBillEntry ()->earliestPeriod (),
      theValue,
      0,
      nPeriods ());

   if (argsOK ())
      myBillEntry ()->setEarliestPeriod (theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::setLatestPeriod (int theValue)
   {
   prepRangedInt (
      "latestPeriod",
      myBillEntry ()->latestPeriod (),
      theValue,
      0,
      lastPeriod ());

   if (argsOK ())
      myBillEntry ()->setLatestPeriod (theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::setRoutingShare (const WitIVRealArg & theValue)
   {
   WitPeriod thePer;

   prepSetAttr ("routingShare");

   forbidNullSetArg (theValue);

   forEachPeriod (thePer, myProblem ())
      if (theValue[thePer] < 1.0 - FLOAT_EPSILON)
         {
         errorFound (thePer);

         myMsgFac () ("routingShareRangeSmsg", theValue[thePer]);
         }

   if (argsOK ())
      {
      theValue.issueSetDblVecMsg ("routingShare", * this);

      myBillEntry ()->setRoutingShare (theValue);
      }
   }

//------------------------------------------------------------------------------

void WitApiCall::setOffset (const WitIVRealArg & theValue)
   {
   prepSetAttr ("offset");

   if (myBillEntry ()->storesOffset ())
      prepDblVec ("offset", theValue);
   else
      {
      errorFound ();

      myMsgFac () ("setSubOffsetSmsg");
      }

   if (argsOK ())
      myBillEntry ()->setOffset (theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::setObjectStage (int theValue)
   {
   WitNode * theNode;

   theNode = myComponent ()->thisNode ();

   witAssert (theNode != NULL);

   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "objectStage",
         theNode->objTypeMsgFrag ());

   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("objectStageWoStageByObjectSmsg",
         theNode->objTypeMsgFrag ());

   prepImmRangedInt (
                       "objectStage", 
      myStochImpMgr ()->objectStageIdx (theNode),
                        theValue,
                        0,
                        1);

   if (argsOK ())
      myStochImpMgr ()->setObjectStageIdx (theNode, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::getObjectStage (int * objectStage)
   {
   WitNode * theNode;

   theNode = myComponent ()->thisNode ();

   witAssert (theNode != NULL);

   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "objectStage",
         theNode->objTypeMsgFrag ());

   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("objectStageWoStageByObjectSmsg",
         theNode->objTypeMsgFrag ());

   myWitRun ()->
      apiGet (             objectStage,
                          "objectStage",
         myStochImpMgr ()->objectStageIdx (theNode));
   }

//------------------------------------------------------------------------------

void WitApiCall::setBoundSet (
      WitBoundSet *        theBoundSet,
      const WitIVRealArg & hardLBArg,
      const WitIVRealArg & softLBArg,
      const WitIVRealArg & hardUBArg)
   {
   WitPeriod thePer;

   WitDblFlexVec hardLBMrg (myProblem (), 0.0);
   WitDblFlexVec softLBMrg (myProblem (), 0.0);
   WitDblFlexVec hardUBMrg (myProblem (), 0.0);
      //
      // The merged values to which theBoundSet's vectors are to be set.

   prepSetAttr (theBoundSet->myAttName ());

   mergeBoundVecs (hardLBMrg, theBoundSet->hardLB (), hardLBArg);
   mergeBoundVecs (softLBMrg, theBoundSet->softLB (), softLBArg);
   mergeBoundVecs (hardUBMrg, theBoundSet->hardUB (), hardUBArg);

      // Check for errors.
      //
   forEachPeriod (thePer, myProblem ())
      if (WitBoundSet::seqError (hardLBMrg, softLBMrg, hardUBMrg, thePer))
         {
         errorFound (thePer);

         myMsgFac () ("boundSetRangeSmsg", 
            hardLBMrg[thePer],
            softLBMrg[thePer],
            hardUBMrg[thePer]);
         }

   if (not argsOK ())
      return;

   if (myMsgFac ().mayIssue ("setBoundVecAttrMsg"))
      {
      hardLBArg.issueBoundVecMsg (theBoundSet, "hardLowerBoundFrag", * this);
      softLBArg.issueBoundVecMsg (theBoundSet, "softLowerBoundFrag", * this);
      hardUBArg.issueBoundVecMsg (theBoundSet, "hardUpperBoundFrag", * this);
      }

   theBoundSet->set (hardLBMrg, softLBMrg, hardUBMrg);
   }

//------------------------------------------------------------------------------

void WitApiCall::reqNoPartsOrOpns (const char * theAttName)
   {
   if (myCompMgr ()->nNodes () == 0)
      return;

   myInputID ()->setMyAttName (theAttName);

   myMsgFac () ("noPartsOrOpnsRequiredSmsg",
      theAttName,
      myCompMgr ()->nParts (),
      myCompMgr ()->nOperations ());
   }

//------------------------------------------------------------------------------

void WitApiCall::issueSetDblVecMsg (
      const char *  theAttName,
      const float * theFltCVec)
   {
   if (myMsgFac ().mayIssue ("setVecDblAttrMsg"))
      {
      WitMsgArg theMsgArg (theFltCVec, nPeriods ());

      myMsgFac () ("setVecDblAttrMsg", theAttName, theMsgArg);
      }
   }

//------------------------------------------------------------------------------

void WitApiCall::issueSetDblVecMsg (
      const char *   theAttName,
      const double * theDblCVec)
   {
   if (myMsgFac ().mayIssue ("setVecDblAttrMsg"))
      {
      WitMsgArg theMsgArg (theDblCVec, nPeriods ());

      myMsgFac () ("setVecDblAttrMsg", theAttName, theMsgArg);
      }
   }

//------------------------------------------------------------------------------

void WitApiCall::issueBoundVecMsg (
      WitBoundSet * theBoundSet,
      const float * theFltCVec,
      WitMsgFragID  theFragID)
   {
   witAssert (myMsgFac ().mayIssue ("setBoundVecAttrMsg"));

   if (theFltCVec == NULL)
      return;

   WitMsgArg theMsgArg (theFltCVec, nPeriods ());

   myMsgFac () (
      "setBoundVecAttrMsg",
      theBoundSet->myAttName (),
      myMsgFac ().myFrag (theFragID),
      theMsgArg);
   }

//------------------------------------------------------------------------------

void WitApiCall::issueBoundVecMsg (
      WitBoundSet *  theBoundSet,
      const double * theDblCVec,
      WitMsgFragID   theFragID)
   {
   witAssert (myMsgFac ().mayIssue ("setBoundVecAttrMsg"));

   if (theDblCVec == NULL)
      return;

   WitMsgArg theMsgArg (theDblCVec, nPeriods ());

   myMsgFac () (
      "setBoundVecAttrMsg",
      theBoundSet->myAttName (),
      myMsgFac ().myFrag (theFragID),
      theMsgArg);
   }

//------------------------------------------------------------------------------

WitApiCall::WitApiCall (WitRun * theWitRun):
      WitProbAssoc (theProblemFor (theWitRun)),

      argsOK_        (true),
      prepSetCalled_ (false)
   {
   }

//------------------------------------------------------------------------------

WitApiCall::~WitApiCall ()
   {
   myInputID ()->setMyAttName   (NULL);
   myInputID ()->setErrorPeriod (-1);
   }

//------------------------------------------------------------------------------

WitDelComp * WitApiCall::myDelComp ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

WitBillEntry * WitApiCall::myBillEntry ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

WitConsEntry * WitApiCall::myConsEntry ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

void WitApiCall::forbidNullSetArg (const void * theArg)
   {
   if (theArg == NULL)
      myMsgFac () ("nullSetArgSmsg");
   }

//------------------------------------------------------------------------------

void WitApiCall::errorFound (WitPeriod thePer)
   {
   errorFound ();

   myInputID ()->setErrorPeriod (thePer);
   }

//------------------------------------------------------------------------------

void WitApiCall::errorFound ()
   {
   argsOK_ = false;
   }

//------------------------------------------------------------------------------

void WitApiCall::prepSetAttr (const char * theAttName)
   {
   if (DEBUG_MODE)
      prepSetCalled_ = true;

   myInputID ()->setMyAttName (theAttName);

   if (myStochImpMgr ()->stochMode ())
      prepSetAttrStochMode (theAttName);
   }

//------------------------------------------------------------------------------

WitProblem * WitApiCall::theProblemFor (WitRun * theWitRun)
   {
   theWitRun->myApiMgr ()->startInnerFunc ();

   return theWitRun->myProblem ();
   }

//------------------------------------------------------------------------------

void WitApiCall::checkPeriodIntVec (const int * theValue)
   {
   WitPeriod thePer;

   forbidNullSetArg (theValue);

   forEachPeriod (thePer, myProblem ())
      if ((theValue[thePer] < 0) or (theValue[thePer] > lastPeriod ()))
         {
         errorFound (thePer);

         myMsgFac () ("intLowEqUpEqSmsg", theValue[thePer], 0, lastPeriod ());
         }
   }

//------------------------------------------------------------------------------

void WitApiCall::mergeBoundVecs (
      WitDblFlexVec &       mergedVec,
      const WitDblFlexVec & oldVec,
      const WitIVRealArg &  theIVRealArg)
   {
   if (theIVRealArg != NULL)
      theIVRealArg.copyInto (mergedVec);
   else
      mergedVec = oldVec;
   }

//------------------------------------------------------------------------------

void WitApiCall::prepSetAttrStochMode (const char * theAttName)
   {
   WitDelComp * theDelComp;

   stronglyAssert (myStochImpMgr ()->stochMode ());

   theDelComp = myComponent ()->thisDelComp ();

   if (not myStochImpMgr ()->canSetInStochMode (theAttName))
      {
      if (theDelComp != NULL)
         myMsgFac () ("setObjStochModeSmsg",
            theAttName,
            theDelComp->objTypeMsgFrag ());
      else
         myMsgFac () ("setGlobStochModeSmsg", theAttName);
      }

   if (myStochImpMgr ()->stochSolnMode ())
      if (not myStochImpMgr ()->canSetInStochSolnMode (theAttName))
         {
         if (theDelComp != NULL)
            myMsgFac () ("setObjStochSolnSmsg",
               theAttName,
               theDelComp->objTypeMsgFrag ());
         else
            myMsgFac () ("setGlobStochSolnSmsg", theAttName);
         }
   }

//------------------------------------------------------------------------------
// Implementation of class GlobalCompApiCall.
//------------------------------------------------------------------------------

WitGlobalCompApiCall::WitGlobalCompApiCall (WitRun * theWitRun):
      WitApiCall (theWitRun)
   {
   }

//------------------------------------------------------------------------------

WitGlobalCompApiCall::~WitGlobalCompApiCall ()
   {
   }

//------------------------------------------------------------------------------

WitComponent * WitGlobalCompApiCall::myComponent ()
   {
   return myGlobalComp ();
   }

//------------------------------------------------------------------------------
// Implementation of class OptCompApiCall.
//------------------------------------------------------------------------------

WitOptCompApiCall::WitOptCompApiCall (WitRun * theWitRun):
      WitApiCall (theWitRun)
   {
   }

//------------------------------------------------------------------------------

WitOptCompApiCall::~WitOptCompApiCall ()
   {
   }

//------------------------------------------------------------------------------

void WitOptCompApiCall::reqMultiObjMode (const char * theAttName)
   {
   if (not myOptComp ()->multiObjMode ())
      myMsgFac () ("globNeedsMultiObjModeSmsg", theAttName);
   }

//------------------------------------------------------------------------------

WitMultiObjMgr * WitOptCompApiCall::myMultiObjMgr ()
   {
   return myOptComp ()->myMultiObjMgr ();
   }

//------------------------------------------------------------------------------

WitObjective * WitOptCompApiCall::currentObjective ()
   {
   return myMultiObjMgr ()->currentObjective ();
   }

//------------------------------------------------------------------------------

WitCpxParSpecMgr * WitOptCompApiCall::myCpxParSpecMgr ()
   {
   return myOptComp ()->myCpxParSpecMgr ();
   }

//------------------------------------------------------------------------------

WitComponent * WitOptCompApiCall::myComponent ()
   {
   return myOptComp ();
   }

//------------------------------------------------------------------------------
// Implementation of class StochApiCall.
//------------------------------------------------------------------------------

WitStochApiCall::WitStochApiCall (WitRun * theWitRun):
      WitApiCall (theWitRun)
   {
   }

//------------------------------------------------------------------------------

WitStochApiCall::~WitStochApiCall ()
   {
   }

//------------------------------------------------------------------------------

void WitStochApiCall::setPeriodStage (const int * periodStage)
   {
   WitPeriod thePer;

   prepSetAttr ("periodStage");

   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("globNeedsStochModeSmsg", "periodStage");

   if (myStochImpMgr ()->stageByObject ())
      myMsgFac () ("periodStageWStageByObjectSmsg");

   forbidNullSetArg (periodStage);

   forEachPeriod (thePer, myProblem ())
      if    (periodStage[thePer] != 0)
         if (periodStage[thePer] != 1)
            {
            myInputID ()->setErrorPeriod (thePer);

            myMsgFac () ("intLowEqUpEqImmSmsg", periodStage[thePer], 0, 1);
            }

   for (thePer = 1; thePer < nPeriods (); thePer ++)
      if    (periodStage[thePer - 1] == 1)
         if (periodStage[thePer    ] == 0)
            myMsgFac () ("perStageConflictSmsg", thePer - 1, thePer);

   if (argsOK ())
      {
      if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
         {
         WitMsgArg theMsgArg (periodStage, nPeriods ());

         myMsgFac () ("setVecIntAttrMsg", "periodStage", theMsgArg);
         }

      forEachPeriod (thePer, myProblem ())
         myStochImpMgr ()->setPeriodStageIdx (thePer, periodStage[thePer]);
      }
   }

//------------------------------------------------------------------------------

WitComponent * WitStochApiCall::myComponent ()
   {
   return myGlobalComp ();
   }

//------------------------------------------------------------------------------
// Implementation of class PartApiCall.
//------------------------------------------------------------------------------

WitPartApiCall::WitPartApiCall (WitRun * theWitRun, const char * partName):
      WitApiCall (theWitRun),

      myPart_    (theWitRun->setGetPartInit (partName))
   {
   }

//------------------------------------------------------------------------------

WitPartApiCall::~WitPartApiCall ()
   {
   myInputID ()->setMyPart (NULL);
   }

//------------------------------------------------------------------------------

WitComponent * WitPartApiCall::myComponent ()
   {
   return myPart_;
   }

//------------------------------------------------------------------------------

WitDelComp * WitPartApiCall::myDelComp ()
   {
   return myPart_;
   }

//------------------------------------------------------------------------------
// Implementation of class MaterialApiCall.
//------------------------------------------------------------------------------

WitMaterialApiCall::WitMaterialApiCall (
         WitRun *     theWitRun, 
         const char * partName,
         const char * theAttName):

      WitApiCall  (theWitRun),

      myMaterial_ (theWitRun->setGetMaterialInit (partName, theAttName))
   {
   }

//------------------------------------------------------------------------------

WitMaterialApiCall::~WitMaterialApiCall ()
   {
   myInputID ()->setMyPart (NULL);
   }

//------------------------------------------------------------------------------

void WitMaterialApiCall::prepBa (
      const char * theAttName,
      bool         oldValue,
      WitBoolean   theValue,
      const char * otherAttr)
   {
   prepBool (theAttName, oldValue, theValue);

   if (not oldValue)
      if (theValue)
         if (myMaterial_->buildNstn () or myMaterial_->buildAsap ())
            if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
               myMsgFac () ("setBooleanAttrMsg", otherAttr, true, false);
   }

//------------------------------------------------------------------------------

WitComponent * WitMaterialApiCall::myComponent ()
   {
   return myMaterial_;
   }

//------------------------------------------------------------------------------

WitDelComp * WitMaterialApiCall::myDelComp ()
   {
   return myMaterial_;
   }

//------------------------------------------------------------------------------
// Implementation of class DemandApiCall.
//------------------------------------------------------------------------------

WitDemandApiCall::WitDemandApiCall (
         WitRun *     theWitRun,
         const char * demandedPartName,
         const char * demandName):

      WitApiCall (theWitRun),

      myDemand_  (theWitRun->setGetDemandInit (demandedPartName, demandName))
   {
   }

//------------------------------------------------------------------------------

WitDemandApiCall::~WitDemandApiCall ()
   {
   myInputID ()->setMyPart   (NULL);
   myInputID ()->setMyDemand (NULL);
   }

//------------------------------------------------------------------------------

WitComponent * WitDemandApiCall::myComponent ()
   {
   return myDemand_;
   }

//------------------------------------------------------------------------------

WitDelComp * WitDemandApiCall::myDelComp ()
   {
   return myDemand_;
   }

//------------------------------------------------------------------------------
// Implementation of class OperationApiCall.
//------------------------------------------------------------------------------

WitOperationApiCall::WitOperationApiCall (
         WitRun *     theWitRun,
         const char * operationName):

      WitApiCall   (theWitRun),

      myOperation_ (theWitRun->setGetOperationInit (operationName))
   {
   }

//------------------------------------------------------------------------------

WitOperationApiCall::~WitOperationApiCall ()
   {
   myInputID ()->setMyOperation (NULL);
   }

//------------------------------------------------------------------------------

void WitOperationApiCall::setYieldRate (const WitIVRealArg & theValue)
   {
   WitPeriod thePer;

   prepSetAttr ("yieldRate");

   forbidNullSetArg (theValue);

   forEachPeriod (thePer, myProblem ())
      if (not WitOperation::validYieldRate (theValue[thePer]))
         {
         errorFound (thePer);

         myMsgFac () ("yieldRateRangeSmsg", theValue[thePer]);
         }

   if (argsOK ())
      {
      theValue.issueSetDblVecMsg ("yieldRate", * this);

      myOperation_->setYieldRate (theValue);
      }
   }

//------------------------------------------------------------------------------

void WitOperationApiCall::setCycleTime34 (const WitIVRealArg & theValue)
   {
   prepSetAttr ("cycleTime34");

   forbidNullSetArg (theValue);

   if (not wit34Compatible ())
      myMsgFac () ("settingCycleTime34WithoutCompatibility",
         myApiMgr ()->apiFuncName ());

   if (argsOK ())
      myOperation_->setCycleTime34 (theValue);
   }

//------------------------------------------------------------------------------

WitComponent * WitOperationApiCall::myComponent ()
   {
   return myOperation_;
   }

//------------------------------------------------------------------------------

WitDelComp * WitOperationApiCall::myDelComp ()
   {
   return myOperation_;
   }

//------------------------------------------------------------------------------
// Implementation of class BomEntryApiCall.
//------------------------------------------------------------------------------

WitBomEntryApiCall::WitBomEntryApiCall (
         WitRun *     theWitRun,
         const char * consumingOperationName,
         int          bomEntryIndex):

      WitApiCall (theWitRun),

      myBomEnt_  (NULL)
   {
   myBomEnt_ =
      theWitRun->setGetBomEntryInit (consumingOperationName, bomEntryIndex);
   }

//------------------------------------------------------------------------------

WitBomEntryApiCall::~WitBomEntryApiCall ()
   {
   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBomEntry  (NULL);
   }

//------------------------------------------------------------------------------

WitComponent * WitBomEntryApiCall::myComponent ()
   {
   return myBomEnt_;
   }

//------------------------------------------------------------------------------

WitDelComp * WitBomEntryApiCall::myDelComp ()
   {
   return myBomEnt_;
   }

//------------------------------------------------------------------------------

WitBillEntry * WitBomEntryApiCall::myBillEntry ()
   {
   return myBomEnt_;
   }

//------------------------------------------------------------------------------

WitConsEntry * WitBomEntryApiCall::myConsEntry ()
   {
   return myBomEnt_;
   }

//------------------------------------------------------------------------------
// Implementation of class SubEntryApiCall.
//------------------------------------------------------------------------------

WitSubEntryApiCall::WitSubEntryApiCall (
         WitRun *     theWitRun,
         const char * consumingOperationName,
         int          bomEntryIndex,
         int          subEntryIndex):

      WitApiCall (theWitRun),

      mySub_     (NULL)
   {
   mySub_ =
      theWitRun->setGetSubBomEntryInit (
         consumingOperationName,
         bomEntryIndex,
         subEntryIndex);
   }

//------------------------------------------------------------------------------

WitSubEntryApiCall::~WitSubEntryApiCall ()
   {
   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBomEntry  (NULL);
   myInputID ()->setMySubEntry  (NULL);
   }

//------------------------------------------------------------------------------

WitComponent * WitSubEntryApiCall::myComponent ()
   {
   return mySub_;
   }

//------------------------------------------------------------------------------

WitDelComp * WitSubEntryApiCall::myDelComp ()
   {
   return mySub_;
   }

//------------------------------------------------------------------------------

WitBillEntry * WitSubEntryApiCall::myBillEntry ()
   {
   return mySub_;
   }

//------------------------------------------------------------------------------

WitConsEntry * WitSubEntryApiCall::myConsEntry ()
   {
   return mySub_;
   }

//------------------------------------------------------------------------------
// Implementation of class BopEntryApiCall.
//------------------------------------------------------------------------------

WitBopEntryApiCall::WitBopEntryApiCall (
         WitRun *     theWitRun,
         const char * producingOperationName,
         int          bopEntryIndex):

      WitApiCall (theWitRun),

      myBopEnt_  (NULL)
   {
   myBopEnt_ =
      theWitRun->setGetBopEntryInit (producingOperationName, bopEntryIndex);
   }

//------------------------------------------------------------------------------

WitBopEntryApiCall::~WitBopEntryApiCall ()
   {
   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBopEntry  (NULL);
   }

//------------------------------------------------------------------------------

WitComponent * WitBopEntryApiCall::myComponent ()
   {
   return myBopEnt_;
   }

//------------------------------------------------------------------------------

WitDelComp * WitBopEntryApiCall::myDelComp ()
   {
   return myBopEnt_;
   }

//------------------------------------------------------------------------------

WitBillEntry * WitBopEntryApiCall::myBillEntry ()
   {
   return myBopEnt_;
   }
@


1.133
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.132
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d54 3
a56 3
{
return myApiMgr ()->myInputID ();
}
d61 9
a69 9
const char * theAttName,
bool         oldValue,
WitBoolean   theValue)
{
prepSetAttr (theAttName);

if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
myMsgFac () ("setBooleanAttrMsg", theAttName, oldValue, theValue);
}
d74 9
a82 9
const char * theAttName,
int          oldValue,
int          theValue)
{
prepSetAttr (theAttName);

if (myMsgFac ().mayIssue ("setIntAttrMsg"))
myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
}
d87 16
a102 16
const char * theAttName,
int          oldValue,
int          theValue)
{
prepSetAttr (theAttName);

if (theValue < 0)
{
errorFound ();

myMsgFac () ("intLowEqSmsg", theValue, 0);
}
else
if (myMsgFac ().mayIssue ("setIntAttrMsg"))
myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
}
d107 12
a118 12
const char * theAttName,
int          oldValue,
int          theValue)
{
prepSetAttr (theAttName);

if (theValue < 1)
myMsgFac () ("intLowEqImmSmsg", theValue, 1);

if (myMsgFac ().mayIssue ("setIntAttrMsg"))
myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
}
d123 18
a140 18
const char * theAttName,
int          oldValue,
int          theValue,
int          lb,
int          ub)
{
prepSetAttr (theAttName);

if ((theValue < lb) or (theValue > ub))
{
errorFound ();

myMsgFac () ("intLowEqUpEqSmsg", theValue, lb, ub);
}
else
if (myMsgFac ().mayIssue ("setIntAttrMsg"))
myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
}
d145 14
a158 14
const char * theAttName,
int          oldValue,
int          theValue,
int          lb,
int          ub)
{
prepSetAttr (theAttName);

if ((theValue < lb) or (theValue > ub))
myMsgFac () ("intLowEqUpEqImmSmsg", theValue, lb, ub);
else
if (myMsgFac ().mayIssue ("setIntAttrMsg"))
myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
}
d163 9
a171 9
const char * theAttName,
double       oldValue,
double       theValue)
{
prepSetAttr (theAttName);

if (myMsgFac ().mayIssue ("setDblAttrMsg"))
myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
}
d176 6
a181 6
const char * theAttName,
double       oldValue,
double       theValue)
{
prepLBDouble (theAttName, oldValue, theValue, 0.0, 0.0);
}
d186 18
a203 18
const char * theAttName,
double       oldValue,
double       theValue,
double       lb,
double       msgLB)
{
prepSetAttr (theAttName);

if (theValue < lb)
{
errorFound ();

myMsgFac () ("dblLowEqSmsg", theValue, msgLB);
}
else
if (myMsgFac ().mayIssue ("setDblAttrMsg"))
myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
}
d208 17
a224 17
const char * theAttName,
double       oldValue,
double       theValue,
double       ub,
double       msgUB)
{
prepSetAttr (theAttName);

if (theValue < 0.0)
myMsgFac () ("dblLowEqUpEqImmSmsg", theValue, 0.0, msgUB);

if (theValue > ub)
myMsgFac () ("dblLowEqUpEqImmSmsg", theValue, 0.0, msgUB);

if (myMsgFac ().mayIssue ("setDblAttrMsg"))
myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
}
d229 16
a244 16
const char * theAttName,
double       oldValue,
double       theValue)
{
prepSetAttr (theAttName);

if (theValue <= 0.0)
{
errorFound ();

myMsgFac () ("dblLowSmsg", theValue, 0.0);
}
else
if (myMsgFac ().mayIssue ("setDblAttrMsg"))
myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
}
d249 14
a262 14
const char *       theAttName,
const WitBoolean * theValue)
{
prepSetAttr (theAttName);

forbidNullSetArg (theValue);

if (myMsgFac ().mayIssue ("setVecBoolAttrMsg"))
{
WitMsgArg theMsgArg (theValue, nPeriods ());

myMsgFac () ("setVecBoolAttrMsg", theAttName, theMsgArg);
}
}
d267 14
a280 14
const char * theAttName,
const int *  theValue)
{
prepSetAttr (theAttName);

forbidNullSetArg (theValue);

if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
{
WitMsgArg theMsgArg (theValue, nPeriods ());

myMsgFac () ("setVecIntAttrMsg", theAttName, theMsgArg);
}
}
d285 4
a288 4
const char *         theAttName,
const WitIVRealArg & theValue)
{
prepSetAttr (theAttName);
d290 1
a290 1
forbidNullSetArg (theValue);
d292 2
a293 2
theValue.issueSetDblVecMsg (theAttName, * this);
}
d298 20
a317 20
const char *         theAttName,
const WitIVRealArg & theValue)
{
WitPeriod thePer;

prepSetAttr (theAttName);

forbidNullSetArg (theValue);

forEachPeriod (thePer, myProblem ())
if (theValue[thePer] < 0.0)
{
errorFound (thePer);

myMsgFac () ("dblLowEqSmsg", theValue[thePer], 0.0);
}

if (argsOK_)
theValue.issueSetDblVecMsg (theAttName, * this);
}
d322 2
a323 2
{
WitPeriod thePer;
d325 1
a325 1
prepSetAttr ("buildAheadUB");
d327 1
a327 1
checkPeriodIntVec (theValue);
d329 24
a352 24
for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
{
if (theValue[thePer + 1] > theValue[thePer] + 1)
{
errorFound (thePer);

myMsgFac () ("selfConsistSmsg",
"buildAheadUB[t+1] <= buildAheadUB[t] + 1",
"buildAheadUB",
thePer,
theValue[thePer],
thePer + 1,
theValue[thePer + 1]);
}
}

if (argsOK_)
if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
{
WitMsgArg theMsgArg (theValue, nPeriods ());

myMsgFac () ("setVecIntAttrMsg", "buildAheadUB", theMsgArg);
}
}
d357 2
a358 2
{
WitPeriod thePer;
d360 1
a360 1
prepSetAttr ("leadTimeUB");
d362 1
a362 1
checkPeriodIntVec (theValue);
d364 24
a387 24
for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
{
if (theValue[thePer + 1] > theValue[thePer] + 1)
{
errorFound (thePer);

myMsgFac () ("selfConsistSmsg",
"leadTimeUB[t+1] <= leadTimeUB[t] + 1",
"leadTimeUB",
thePer,
theValue[thePer],
thePer + 1,
theValue[thePer + 1]);
}
}

if (argsOK_)
if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
{
WitMsgArg theMsgArg (theValue, nPeriods ());

myMsgFac () ("setVecIntAttrMsg", "leadTimeUB", theMsgArg);
}
}
d392 2
a393 2
{
WitPeriod thePer;
d395 1
a395 1
prepSetAttr ("shipLateUB");
d397 1
a397 1
checkPeriodIntVec (theValue);
d399 24
a422 24
for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
{
if (theValue[thePer + 1] < theValue[thePer] - 1)
{
errorFound (thePer);

myMsgFac () ("selfConsistSmsg",
"shipLateUB[t+1] >= shipLateUB[t] - 1",
"shipLateUB",
thePer,
theValue[thePer],
thePer + 1,
theValue[thePer + 1]);
}
}

if (argsOK_)
if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
{
WitMsgArg theMsgArg (theValue, nPeriods ());

myMsgFac () ("setVecIntAttrMsg", "shipLateUB", theMsgArg);
}
}
d427 11
a437 11
const char *      theAttName,
const WitString & oldValue,
const char *      theValue)
{
prepSetAttr (theAttName);

forbidNullSetArg (theValue);

if (myMsgFac ().mayIssue ("setStringAttrMsg"))
myMsgFac () ("setStringAttrMsg", theAttName, oldValue, theValue);
}
d442 2
a443 2
{
prepSetAttr ("appData");
d445 3
a447 3
if (argsOK ())
myComponent ()->setAppData (appData);
}
d452 2
a453 2
{
prepBool ("selForDel", myDelComp ()->selForDel (), theValue);
d455 3
a457 3
if (argsOK ())
myDelComp ()->setSelForDel (asaBool (theValue));
}
d462 11
a472 11
{
prepRangedInt (
"earliestPeriod",
myBillEntry ()->earliestPeriod (),
theValue,
0,
nPeriods ());

if (argsOK ())
myBillEntry ()->setEarliestPeriod (theValue);
}
d477 11
a487 11
{
prepRangedInt (
"latestPeriod",
myBillEntry ()->latestPeriod (),
theValue,
0,
lastPeriod ());

if (argsOK ())
myBillEntry ()->setLatestPeriod (theValue);
}
d492 2
a493 2
{
WitPeriod thePer;
d495 1
a495 1
prepSetAttr ("routingShare");
d497 1
a497 1
forbidNullSetArg (theValue);
d499 4
a502 4
forEachPeriod (thePer, myProblem ())
if (theValue[thePer] < 1.0 - FLOAT_EPSILON)
{
errorFound (thePer);
d504 2
a505 2
myMsgFac () ("routingShareRangeSmsg", theValue[thePer]);
}
d507 3
a509 3
if (argsOK ())
{
theValue.issueSetDblVecMsg ("routingShare", * this);
d511 3
a513 3
myBillEntry ()->setRoutingShare (theValue);
}
}
d518 2
a519 2
{
prepSetAttr ("offset");
d521 12
a532 12
if (myBillEntry ()->storesOffset ())
prepDblVec ("offset", theValue);
else
{
errorFound ();

myMsgFac () ("setSubOffsetSmsg");
}

if (argsOK ())
myBillEntry ()->setOffset (theValue);
}
d537 2
a538 2
{
WitNode * theNode;
d540 1
a540 1
theNode = myComponent ()->thisNode ();
d542 1
a542 1
witAssert (theNode != NULL);
d544 19
a562 19
if (not myStochImpMgr ()->stochMode ())
myMsgFac () ("objNeedsStochModeSmsg",
"objectStage",
theNode->objTypeMsgFrag ());

if (not myStochImpMgr ()->stageByObject ())
myMsgFac () ("objectStageWoStageByObjectSmsg",
theNode->objTypeMsgFrag ());

prepImmRangedInt (
"objectStage",
myStochImpMgr ()->objectStageIdx (theNode),
theValue,
0,
1);

if (argsOK ())
myStochImpMgr ()->setObjectStageIdx (theNode, theValue);
}
d567 2
a568 2
{
WitNode * theNode;
d570 1
a570 1
theNode = myComponent ()->thisNode ();
d572 1
a572 1
witAssert (theNode != NULL);
d574 14
a587 14
if (not myStochImpMgr ()->stochMode ())
myMsgFac () ("objNeedsStochModeSmsg",
"objectStage",
theNode->objTypeMsgFrag ());

if (not myStochImpMgr ()->stageByObject ())
myMsgFac () ("objectStageWoStageByObjectSmsg",
theNode->objTypeMsgFrag ());

myWitRun ()->
apiGet (             objectStage,
"objectStage",
myStochImpMgr ()->objectStageIdx (theNode));
}
d592 41
a632 41
WitBoundSet *        theBoundSet,
const WitIVRealArg & hardLBArg,
const WitIVRealArg & softLBArg,
const WitIVRealArg & hardUBArg)
{
WitPeriod thePer;

WitDblFlexVec hardLBMrg (myProblem (), 0.0);
WitDblFlexVec softLBMrg (myProblem (), 0.0);
WitDblFlexVec hardUBMrg (myProblem (), 0.0);
//
// The merged values to which theBoundSet's vectors are to be set.

prepSetAttr (theBoundSet->myAttName ());

mergeBoundVecs (hardLBMrg, theBoundSet->hardLB (), hardLBArg);
mergeBoundVecs (softLBMrg, theBoundSet->softLB (), softLBArg);
mergeBoundVecs (hardUBMrg, theBoundSet->hardUB (), hardUBArg);

// Check for errors.
//
forEachPeriod (thePer, myProblem ())
if (WitBoundSet::seqError (hardLBMrg, softLBMrg, hardUBMrg, thePer))
{
errorFound (thePer);

myMsgFac () ("boundSetRangeSmsg",
hardLBMrg[thePer],
softLBMrg[thePer],
hardUBMrg[thePer]);
}

if (not argsOK ())
return;

if (myMsgFac ().mayIssue ("setBoundVecAttrMsg"))
{
hardLBArg.issueBoundVecMsg (theBoundSet, "hardLowerBoundFrag", * this);
softLBArg.issueBoundVecMsg (theBoundSet, "softLowerBoundFrag", * this);
hardUBArg.issueBoundVecMsg (theBoundSet, "hardUpperBoundFrag", * this);
}
d634 2
a635 2
theBoundSet->set (hardLBMrg, softLBMrg, hardUBMrg);
}
d640 11
a650 11
{
if (myCompMgr ()->nNodes () == 0)
return;

myInputID ()->setMyAttName (theAttName);

myMsgFac () ("noPartsOrOpnsRequiredSmsg",
theAttName,
myCompMgr ()->nParts (),
myCompMgr ()->nOperations ());
}
d655 10
a664 10
const char *  theAttName,
const float * theFltCVec)
{
if (myMsgFac ().mayIssue ("setVecDblAttrMsg"))
{
WitMsgArg theMsgArg (theFltCVec, nPeriods ());

myMsgFac () ("setVecDblAttrMsg", theAttName, theMsgArg);
}
}
d669 10
a678 10
const char *   theAttName,
const double * theDblCVec)
{
if (myMsgFac ().mayIssue ("setVecDblAttrMsg"))
{
WitMsgArg theMsgArg (theDblCVec, nPeriods ());

myMsgFac () ("setVecDblAttrMsg", theAttName, theMsgArg);
}
}
d683 17
a699 17
WitBoundSet * theBoundSet,
const float * theFltCVec,
WitMsgFragID  theFragID)
{
witAssert (myMsgFac ().mayIssue ("setBoundVecAttrMsg"));

if (theFltCVec == NULL)
return;

WitMsgArg theMsgArg (theFltCVec, nPeriods ());

myMsgFac () (
"setBoundVecAttrMsg",
theBoundSet->myAttName (),
myMsgFac ().myFrag (theFragID),
theMsgArg);
}
d704 17
a720 17
WitBoundSet *  theBoundSet,
const double * theDblCVec,
WitMsgFragID   theFragID)
{
witAssert (myMsgFac ().mayIssue ("setBoundVecAttrMsg"));

if (theDblCVec == NULL)
return;

WitMsgArg theMsgArg (theDblCVec, nPeriods ());

myMsgFac () (
"setBoundVecAttrMsg",
theBoundSet->myAttName (),
myMsgFac ().myFrag (theFragID),
theMsgArg);
}
d725 1
a725 1
WitProbAssoc (theProblemFor (theWitRun)),
d727 4
a730 4
argsOK_        (true),
prepSetCalled_ (false)
{
}
d735 4
a738 4
{
myInputID ()->setMyAttName   (NULL);
myInputID ()->setErrorPeriod (-1);
}
d743 2
a744 2
{
stronglyAssert (false);
d746 2
a747 2
return NULL;
}
d752 2
a753 2
{
stronglyAssert (false);
d755 2
a756 2
return NULL;
}
d761 2
a762 2
{
stronglyAssert (false);
d764 2
a765 2
return NULL;
}
d770 4
a773 4
{
if (theArg == NULL)
myMsgFac () ("nullSetArgSmsg");
}
d778 2
a779 2
{
errorFound ();
d781 2
a782 2
myInputID ()->setErrorPeriod (thePer);
}
d787 3
a789 3
{
argsOK_ = false;
}
d794 9
a802 9
{
if (DEBUG_MODE)
prepSetCalled_ = true;

myInputID ()->setMyAttName (theAttName);

if (myStochImpMgr ()->stochMode ())
prepSetAttrStochMode (theAttName);
}
d807 2
a808 2
{
theWitRun->myApiMgr ()->startInnerFunc ();
d810 2
a811 2
return theWitRun->myProblem ();
}
d816 2
a817 2
{
WitPeriod thePer;
d819 1
a819 1
forbidNullSetArg (theValue);
d821 8
a828 8
forEachPeriod (thePer, myProblem ())
if ((theValue[thePer] < 0) or (theValue[thePer] > lastPeriod ()))
{
errorFound (thePer);

myMsgFac () ("intLowEqUpEqSmsg", theValue[thePer], 0, lastPeriod ());
}
}
d833 9
a841 9
WitDblFlexVec &       mergedVec,
const WitDblFlexVec & oldVec,
const WitIVRealArg &  theIVRealArg)
{
if (theIVRealArg != NULL)
theIVRealArg.copyInto (mergedVec);
else
mergedVec = oldVec;
}
d846 2
a847 2
{
WitDelComp * theDelComp;
d849 1
a849 1
stronglyAssert (myStochImpMgr ()->stochMode ());
d851 1
a851 1
theDelComp = myComponent ()->thisDelComp ();
d853 21
a873 21
if (not myStochImpMgr ()->canSetInStochMode (theAttName))
{
if (theDelComp != NULL)
myMsgFac () ("setObjStochModeSmsg",
theAttName,
theDelComp->objTypeMsgFrag ());
else
myMsgFac () ("setGlobStochModeSmsg", theAttName);
}

if (myStochImpMgr ()->stochSolnMode ())
if (not myStochImpMgr ()->canSetInStochSolnMode (theAttName))
{
if (theDelComp != NULL)
myMsgFac () ("setObjStochSolnSmsg",
theAttName,
theDelComp->objTypeMsgFrag ());
else
myMsgFac () ("setGlobStochSolnSmsg", theAttName);
}
}
d880 3
a882 3
WitApiCall (theWitRun)
{
}
d887 2
a888 2
{
}
d893 3
a895 3
{
return myGlobalComp ();
}
d902 3
a904 3
WitApiCall (theWitRun)
{
}
d909 2
a910 2
{
}
d915 4
a918 4
{
if (not myOptComp ()->multiObjMode ())
myMsgFac () ("globNeedsMultiObjModeSmsg", theAttName);
}
d923 3
a925 3
{
return myOptComp ()->myMultiObjMgr ();
}
d930 3
a932 3
{
return myMultiObjMgr ()->currentObjective ();
}
d937 3
a939 3
{
return myOptComp ()->myCpxParSpecMgr ();
}
d944 3
a946 3
{
return myOptComp ();
}
d953 3
a955 3
WitApiCall (theWitRun)
{
}
d960 2
a961 2
{
}
d966 2
a967 2
{
WitPeriod thePer;
d969 1
a969 1
prepSetAttr ("periodStage");
d971 2
a972 2
if (not myStochImpMgr ()->stochMode ())
myMsgFac () ("globNeedsStochModeSmsg", "periodStage");
d974 32
a1005 32
if (myStochImpMgr ()->stageByObject ())
myMsgFac () ("periodStageWStageByObjectSmsg");

forbidNullSetArg (periodStage);

forEachPeriod (thePer, myProblem ())
if    (periodStage[thePer] != 0)
if (periodStage[thePer] != 1)
{
myInputID ()->setErrorPeriod (thePer);

myMsgFac () ("intLowEqUpEqImmSmsg", periodStage[thePer], 0, 1);
}

for (thePer = 1; thePer < nPeriods (); thePer ++)
if    (periodStage[thePer - 1] == 1)
if (periodStage[thePer    ] == 0)
myMsgFac () ("perStageConflictSmsg", thePer - 1, thePer);

if (argsOK ())
{
if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
{
WitMsgArg theMsgArg (periodStage, nPeriods ());

myMsgFac () ("setVecIntAttrMsg", "periodStage", theMsgArg);
}

forEachPeriod (thePer, myProblem ())
myStochImpMgr ()->setPeriodStageIdx (thePer, periodStage[thePer]);
}
}
d1010 3
a1012 3
{
return myGlobalComp ();
}
d1019 1
a1019 1
WitApiCall (theWitRun),
d1021 3
a1023 3
myPart_    (theWitRun->setGetPartInit (partName))
{
}
d1028 3
a1030 3
{
myInputID ()->setMyPart (NULL);
}
d1035 3
a1037 3
{
return myPart_;
}
d1042 3
a1044 3
{
return myPart_;
}
d1051 9
a1059 9
WitRun *     theWitRun,
const char * partName,
const char * theAttName):

WitApiCall  (theWitRun),

myMaterial_ (theWitRun->setGetMaterialInit (partName, theAttName))
{
}
d1064 3
a1066 3
{
myInputID ()->setMyPart (NULL);
}
d1071 13
a1083 13
const char * theAttName,
bool         oldValue,
WitBoolean   theValue,
const char * otherAttr)
{
prepBool (theAttName, oldValue, theValue);

if (not oldValue)
if (theValue)
if (myMaterial_->buildNstn () or myMaterial_->buildAsap ())
if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
myMsgFac () ("setBooleanAttrMsg", otherAttr, true, false);
}
d1088 3
a1090 3
{
return myMaterial_;
}
d1095 3
a1097 3
{
return myMaterial_;
}
d1104 9
a1112 9
WitRun *     theWitRun,
const char * demandedPartName,
const char * demandName):

WitApiCall (theWitRun),

myDemand_  (theWitRun->setGetDemandInit (demandedPartName, demandName))
{
}
d1117 4
a1120 4
{
myInputID ()->setMyPart   (NULL);
myInputID ()->setMyDemand (NULL);
}
d1125 3
a1127 3
{
return myDemand_;
}
d1132 3
a1134 3
{
return myDemand_;
}
d1141 2
a1142 2
WitRun *     theWitRun,
const char * operationName):
d1144 1
a1144 1
WitApiCall   (theWitRun),
d1146 3
a1148 3
myOperation_ (theWitRun->setGetOperationInit (operationName))
{
}
d1153 3
a1155 3
{
myInputID ()->setMyOperation (NULL);
}
d1160 2
a1161 2
{
WitPeriod thePer;
d1163 1
a1163 1
prepSetAttr ("yieldRate");
d1165 1
a1165 1
forbidNullSetArg (theValue);
d1167 4
a1170 4
forEachPeriod (thePer, myProblem ())
if (not WitOperation::validYieldRate (theValue[thePer]))
{
errorFound (thePer);
d1172 2
a1173 2
myMsgFac () ("yieldRateRangeSmsg", theValue[thePer]);
}
d1175 3
a1177 3
if (argsOK ())
{
theValue.issueSetDblVecMsg ("yieldRate", * this);
d1179 3
a1181 3
myOperation_->setYieldRate (theValue);
}
}
d1186 2
a1187 2
{
prepSetAttr ("cycleTime34");
d1189 1
a1189 1
forbidNullSetArg (theValue);
d1191 7
a1197 7
if (not wit34Compatible ())
myMsgFac () ("settingCycleTime34WithoutCompatibility",
myApiMgr ()->apiFuncName ());

if (argsOK ())
myOperation_->setCycleTime34 (theValue);
}
d1202 3
a1204 3
{
return myOperation_;
}
d1209 3
a1211 3
{
return myOperation_;
}
d1218 11
a1228 11
WitRun *     theWitRun,
const char * consumingOperationName,
int          bomEntryIndex):

WitApiCall (theWitRun),

myBomEnt_  (NULL)
{
myBomEnt_ =
theWitRun->setGetBomEntryInit (consumingOperationName, bomEntryIndex);
}
d1233 4
a1236 4
{
myInputID ()->setMyOperation (NULL);
myInputID ()->setMyBomEntry  (NULL);
}
d1241 3
a1243 3
{
return myBomEnt_;
}
d1248 3
a1250 3
{
return myBomEnt_;
}
d1255 3
a1257 3
{
return myBomEnt_;
}
d1262 3
a1264 3
{
return myBomEnt_;
}
d1271 15
a1285 15
WitRun *     theWitRun,
const char * consumingOperationName,
int          bomEntryIndex,
int          subEntryIndex):

WitApiCall (theWitRun),

mySub_     (NULL)
{
mySub_ =
theWitRun->setGetSubBomEntryInit (
consumingOperationName,
bomEntryIndex,
subEntryIndex);
}
d1290 5
a1294 5
{
myInputID ()->setMyOperation (NULL);
myInputID ()->setMyBomEntry  (NULL);
myInputID ()->setMySubEntry  (NULL);
}
d1299 3
a1301 3
{
return mySub_;
}
d1306 3
a1308 3
{
return mySub_;
}
d1313 3
a1315 3
{
return mySub_;
}
d1320 3
a1322 3
{
return mySub_;
}
d1329 11
a1339 11
WitRun *     theWitRun,
const char * producingOperationName,
int          bopEntryIndex):

WitApiCall (theWitRun),

myBopEnt_  (NULL)
{
myBopEnt_ =
theWitRun->setGetBopEntryInit (producingOperationName, bopEntryIndex);
}
d1344 4
a1347 4
{
myInputID ()->setMyOperation (NULL);
myInputID ()->setMyBopEntry  (NULL);
}
d1352 3
a1354 3
{
return myBopEnt_;
}
d1359 3
a1361 3
{
return myBopEnt_;
}
d1366 3
a1368 3
{
return myBopEnt_;
}
@


1.131
log
@CPLEX Param Specs.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d54 3
a56 3
   {
   return myApiMgr ()->myInputID ();
   }
d61 9
a69 9
      const char * theAttName,
      bool         oldValue,
      WitBoolean   theValue)
   {
   prepSetAttr (theAttName);

   if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
      myMsgFac () ("setBooleanAttrMsg", theAttName, oldValue, theValue);
   }
d74 9
a82 9
      const char * theAttName,
      int          oldValue,
      int          theValue)
   {
   prepSetAttr (theAttName);

   if (myMsgFac ().mayIssue ("setIntAttrMsg"))
      myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }
d87 16
a102 16
      const char * theAttName,
      int          oldValue,
      int          theValue)
   {
   prepSetAttr (theAttName);

   if (theValue < 0)
      {
      errorFound ();

      myMsgFac () ("intLowEqSmsg", theValue, 0);
      }
   else
      if (myMsgFac ().mayIssue ("setIntAttrMsg"))
         myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }
d107 12
a118 12
      const char * theAttName,
      int          oldValue,
      int          theValue)
   {
   prepSetAttr (theAttName);

   if (theValue < 1)
      myMsgFac () ("intLowEqImmSmsg", theValue, 1);

   if (myMsgFac ().mayIssue ("setIntAttrMsg"))
      myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }
d123 18
a140 18
      const char * theAttName,
      int          oldValue,
      int          theValue,
      int          lb,
      int          ub)
   {
   prepSetAttr (theAttName);

   if ((theValue < lb) or (theValue > ub))
      {
      errorFound ();

      myMsgFac () ("intLowEqUpEqSmsg", theValue, lb, ub);
      }
   else
      if (myMsgFac ().mayIssue ("setIntAttrMsg"))
         myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }
d145 14
a158 14
      const char * theAttName,
      int          oldValue,
      int          theValue,
      int          lb,
      int          ub)
   {
   prepSetAttr (theAttName);

   if ((theValue < lb) or (theValue > ub))
      myMsgFac () ("intLowEqUpEqImmSmsg", theValue, lb, ub);
   else
      if (myMsgFac ().mayIssue ("setIntAttrMsg"))
         myMsgFac () ("setIntAttrMsg", theAttName, oldValue, theValue);
   }
d163 9
a171 9
      const char * theAttName,
      double       oldValue,
      double       theValue)
   {
   prepSetAttr (theAttName);

   if (myMsgFac ().mayIssue ("setDblAttrMsg"))
      myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
   }
d176 6
a181 6
      const char * theAttName, 
      double       oldValue,
      double       theValue)
   {
   prepLBDouble (theAttName, oldValue, theValue, 0.0, 0.0);
   }
d186 18
a203 18
      const char * theAttName, 
      double       oldValue, 
      double       theValue,
      double       lb,
      double       msgLB)
   {
   prepSetAttr (theAttName);

   if (theValue < lb)
      {
      errorFound ();

      myMsgFac () ("dblLowEqSmsg", theValue, msgLB);
      }
   else
      if (myMsgFac ().mayIssue ("setDblAttrMsg"))
         myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
   }
d208 17
a224 17
      const char * theAttName, 
      double       oldValue, 
      double       theValue,
      double       ub,
      double       msgUB)
   {
   prepSetAttr (theAttName);

   if (theValue < 0.0)
      myMsgFac () ("dblLowEqUpEqImmSmsg", theValue, 0.0, msgUB);

   if (theValue > ub)
      myMsgFac () ("dblLowEqUpEqImmSmsg", theValue, 0.0, msgUB);

   if (myMsgFac ().mayIssue ("setDblAttrMsg"))
      myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
   }
d229 16
a244 16
      const char * theAttName,
      double       oldValue,
      double       theValue)
   {
   prepSetAttr (theAttName);

   if (theValue <= 0.0)
      {
      errorFound ();

      myMsgFac () ("dblLowSmsg", theValue, 0.0);
      }
   else
      if (myMsgFac ().mayIssue ("setDblAttrMsg"))
         myMsgFac () ("setDblAttrMsg", theAttName, oldValue, theValue);
   }
d249 14
a262 14
      const char *       theAttName,
      const WitBoolean * theValue)
   {
   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   if (myMsgFac ().mayIssue ("setVecBoolAttrMsg"))
      {
      WitMsgArg theMsgArg (theValue, nPeriods ());

      myMsgFac () ("setVecBoolAttrMsg", theAttName, theMsgArg);
      }
   }
d267 14
a280 14
      const char * theAttName,
      const int *  theValue)
   {
   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
      {
      WitMsgArg theMsgArg (theValue, nPeriods ());

      myMsgFac () ("setVecIntAttrMsg", theAttName, theMsgArg);
      }
   }
d285 4
a288 4
      const char *         theAttName,
      const WitIVRealArg & theValue)
   {
   prepSetAttr (theAttName);
d290 1
a290 1
   forbidNullSetArg (theValue);
d292 2
a293 2
   theValue.issueSetDblVecMsg (theAttName, * this);
   }
d298 20
a317 20
      const char *         theAttName,
      const WitIVRealArg & theValue)
   {
   WitPeriod thePer;

   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   forEachPeriod (thePer, myProblem ())
      if (theValue[thePer] < 0.0)
         {
         errorFound (thePer);

         myMsgFac () ("dblLowEqSmsg", theValue[thePer], 0.0);
         }

   if (argsOK_)
      theValue.issueSetDblVecMsg (theAttName, * this);
   }
d322 2
a323 2
   {
   WitPeriod thePer;
d325 1
a325 1
   prepSetAttr ("buildAheadUB");
d327 1
a327 1
   checkPeriodIntVec (theValue);
d329 24
a352 24
   for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
      {
      if (theValue[thePer + 1] > theValue[thePer] + 1)
         {
         errorFound (thePer);

         myMsgFac () ("selfConsistSmsg",
            "buildAheadUB[t+1] <= buildAheadUB[t] + 1",
            "buildAheadUB",
            thePer,
            theValue[thePer],
            thePer + 1,
            theValue[thePer + 1]);
         }
      }

   if (argsOK_)
      if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
         {
         WitMsgArg theMsgArg (theValue, nPeriods ());

         myMsgFac () ("setVecIntAttrMsg", "buildAheadUB", theMsgArg);
         }
   }
d357 2
a358 2
   {
   WitPeriod thePer;
d360 1
a360 1
   prepSetAttr ("leadTimeUB");
d362 1
a362 1
   checkPeriodIntVec (theValue);
d364 24
a387 24
   for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
      {
      if (theValue[thePer + 1] > theValue[thePer] + 1)
         {
         errorFound (thePer);

         myMsgFac () ("selfConsistSmsg",
            "leadTimeUB[t+1] <= leadTimeUB[t] + 1",
            "leadTimeUB",
            thePer,
            theValue[thePer],
            thePer + 1,
            theValue[thePer + 1]);
         }
      }

   if (argsOK_)
      if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
         {
         WitMsgArg theMsgArg (theValue, nPeriods ());

         myMsgFac () ("setVecIntAttrMsg", "leadTimeUB", theMsgArg);
         }
   }
d392 2
a393 2
   {
   WitPeriod thePer;
d395 1
a395 1
   prepSetAttr ("shipLateUB");
d397 1
a397 1
   checkPeriodIntVec (theValue);
d399 24
a422 24
   for (thePer = 0; thePer <= nPeriods () - 2; thePer ++)
      {
      if (theValue[thePer + 1] < theValue[thePer] - 1)
         {
         errorFound (thePer);

         myMsgFac () ("selfConsistSmsg",
            "shipLateUB[t+1] >= shipLateUB[t] - 1",
            "shipLateUB",
            thePer,
            theValue[thePer],
            thePer + 1,
            theValue[thePer + 1]);
         }
      }

   if (argsOK_)
      if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
         {
         WitMsgArg theMsgArg (theValue, nPeriods ());

         myMsgFac () ("setVecIntAttrMsg", "shipLateUB", theMsgArg);
         }
   }
d427 11
a437 11
      const char *      theAttName,
      const WitString & oldValue,
      const char *      theValue)
   {
   prepSetAttr (theAttName);

   forbidNullSetArg (theValue);

   if (myMsgFac ().mayIssue ("setStringAttrMsg"))
      myMsgFac () ("setStringAttrMsg", theAttName, oldValue, theValue);
   }
d442 2
a443 2
   {
   prepSetAttr ("appData");
d445 3
a447 3
   if (argsOK ())
      myComponent ()->setAppData (appData);
   }
d452 2
a453 2
   {
   prepBool ("selForDel", myDelComp ()->selForDel (), theValue);
d455 3
a457 3
   if (argsOK ())
      myDelComp ()->setSelForDel (asaBool (theValue));
   }
d462 11
a472 11
   {
   prepRangedInt (
      "earliestPeriod",
      myBillEntry ()->earliestPeriod (),
      theValue,
      0,
      nPeriods ());

   if (argsOK ())
      myBillEntry ()->setEarliestPeriod (theValue);
   }
d477 11
a487 11
   {
   prepRangedInt (
      "latestPeriod",
      myBillEntry ()->latestPeriod (),
      theValue,
      0,
      lastPeriod ());

   if (argsOK ())
      myBillEntry ()->setLatestPeriod (theValue);
   }
d492 2
a493 2
   {
   WitPeriod thePer;
d495 1
a495 1
   prepSetAttr ("routingShare");
d497 1
a497 1
   forbidNullSetArg (theValue);
d499 4
a502 4
   forEachPeriod (thePer, myProblem ())
      if (theValue[thePer] < 1.0 - FLOAT_EPSILON)
         {
         errorFound (thePer);
d504 2
a505 2
         myMsgFac () ("routingShareRangeSmsg", theValue[thePer]);
         }
d507 3
a509 3
   if (argsOK ())
      {
      theValue.issueSetDblVecMsg ("routingShare", * this);
d511 3
a513 3
      myBillEntry ()->setRoutingShare (theValue);
      }
   }
d518 2
a519 2
   {
   prepSetAttr ("offset");
d521 12
a532 12
   if (myBillEntry ()->storesOffset ())
      prepDblVec ("offset", theValue);
   else
      {
      errorFound ();

      myMsgFac () ("setSubOffsetSmsg");
      }

   if (argsOK ())
      myBillEntry ()->setOffset (theValue);
   }
d537 2
a538 2
   {
   WitNode * theNode;
d540 1
a540 1
   theNode = myComponent ()->thisNode ();
d542 1
a542 1
   witAssert (theNode != NULL);
d544 19
a562 19
   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "objectStage",
         theNode->objTypeMsgFrag ());

   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("objectStageWoStageByObjectSmsg",
         theNode->objTypeMsgFrag ());

   prepImmRangedInt (
                       "objectStage", 
      myStochImpMgr ()->objectStageIdx (theNode),
                        theValue,
                        0,
                        1);

   if (argsOK ())
      myStochImpMgr ()->setObjectStageIdx (theNode, theValue);
   }
d567 2
a568 2
   {
   WitNode * theNode;
d570 1
a570 1
   theNode = myComponent ()->thisNode ();
d572 1
a572 1
   witAssert (theNode != NULL);
d574 14
a587 14
   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("objNeedsStochModeSmsg",
         "objectStage",
         theNode->objTypeMsgFrag ());

   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("objectStageWoStageByObjectSmsg",
         theNode->objTypeMsgFrag ());

   myWitRun ()->
      apiGet (             objectStage,
                          "objectStage",
         myStochImpMgr ()->objectStageIdx (theNode));
   }
d592 41
a632 41
      WitBoundSet *        theBoundSet,
      const WitIVRealArg & hardLBArg,
      const WitIVRealArg & softLBArg,
      const WitIVRealArg & hardUBArg)
   {
   WitPeriod thePer;

   WitDblFlexVec hardLBMrg (myProblem (), 0.0);
   WitDblFlexVec softLBMrg (myProblem (), 0.0);
   WitDblFlexVec hardUBMrg (myProblem (), 0.0);
      //
      // The merged values to which theBoundSet's vectors are to be set.

   prepSetAttr (theBoundSet->myAttName ());

   mergeBoundVecs (hardLBMrg, theBoundSet->hardLB (), hardLBArg);
   mergeBoundVecs (softLBMrg, theBoundSet->softLB (), softLBArg);
   mergeBoundVecs (hardUBMrg, theBoundSet->hardUB (), hardUBArg);

      // Check for errors.
      //
   forEachPeriod (thePer, myProblem ())
      if (WitBoundSet::seqError (hardLBMrg, softLBMrg, hardUBMrg, thePer))
         {
         errorFound (thePer);

         myMsgFac () ("boundSetRangeSmsg", 
            hardLBMrg[thePer],
            softLBMrg[thePer],
            hardUBMrg[thePer]);
         }

   if (not argsOK ())
      return;

   if (myMsgFac ().mayIssue ("setBoundVecAttrMsg"))
      {
      hardLBArg.issueBoundVecMsg (theBoundSet, "hardLowerBoundFrag", * this);
      softLBArg.issueBoundVecMsg (theBoundSet, "softLowerBoundFrag", * this);
      hardUBArg.issueBoundVecMsg (theBoundSet, "hardUpperBoundFrag", * this);
      }
d634 2
a635 2
   theBoundSet->set (hardLBMrg, softLBMrg, hardUBMrg);
   }
d640 11
a650 11
   {
   if (myCompMgr ()->nNodes () == 0)
      return;

   myInputID ()->setMyAttName (theAttName);

   myMsgFac () ("noPartsOrOpnsRequiredSmsg",
      theAttName,
      myCompMgr ()->nParts (),
      myCompMgr ()->nOperations ());
   }
d655 10
a664 10
      const char *  theAttName,
      const float * theFltCVec)
   {
   if (myMsgFac ().mayIssue ("setVecDblAttrMsg"))
      {
      WitMsgArg theMsgArg (theFltCVec, nPeriods ());

      myMsgFac () ("setVecDblAttrMsg", theAttName, theMsgArg);
      }
   }
d669 10
a678 10
      const char *   theAttName,
      const double * theDblCVec)
   {
   if (myMsgFac ().mayIssue ("setVecDblAttrMsg"))
      {
      WitMsgArg theMsgArg (theDblCVec, nPeriods ());

      myMsgFac () ("setVecDblAttrMsg", theAttName, theMsgArg);
      }
   }
d683 17
a699 17
      WitBoundSet * theBoundSet,
      const float * theFltCVec,
      WitMsgFragID  theFragID)
   {
   witAssert (myMsgFac ().mayIssue ("setBoundVecAttrMsg"));

   if (theFltCVec == NULL)
      return;

   WitMsgArg theMsgArg (theFltCVec, nPeriods ());

   myMsgFac () (
      "setBoundVecAttrMsg",
      theBoundSet->myAttName (),
      myMsgFac ().myFrag (theFragID),
      theMsgArg);
   }
d704 17
a720 17
      WitBoundSet *  theBoundSet,
      const double * theDblCVec,
      WitMsgFragID   theFragID)
   {
   witAssert (myMsgFac ().mayIssue ("setBoundVecAttrMsg"));

   if (theDblCVec == NULL)
      return;

   WitMsgArg theMsgArg (theDblCVec, nPeriods ());

   myMsgFac () (
      "setBoundVecAttrMsg",
      theBoundSet->myAttName (),
      myMsgFac ().myFrag (theFragID),
      theMsgArg);
   }
d725 1
a725 1
      WitProbAssoc (theProblemFor (theWitRun)),
d727 4
a730 4
      argsOK_        (true),
      prepSetCalled_ (false)
   {
   }
d735 4
a738 4
   {
   myInputID ()->setMyAttName   (NULL);
   myInputID ()->setErrorPeriod (-1);
   }
d743 2
a744 2
   {
   stronglyAssert (false);
d746 2
a747 2
   return NULL;
   }
d752 2
a753 2
   {
   stronglyAssert (false);
d755 2
a756 2
   return NULL;
   }
d761 2
a762 2
   {
   stronglyAssert (false);
d764 2
a765 2
   return NULL;
   }
d770 4
a773 4
   {
   if (theArg == NULL)
      myMsgFac () ("nullSetArgSmsg");
   }
d778 2
a779 2
   {
   errorFound ();
d781 2
a782 2
   myInputID ()->setErrorPeriod (thePer);
   }
d787 3
a789 3
   {
   argsOK_ = false;
   }
d794 9
a802 9
   {
   if (DEBUG_MODE)
      prepSetCalled_ = true;

   myInputID ()->setMyAttName (theAttName);

   if (myStochImpMgr ()->stochMode ())
      prepSetAttrStochMode (theAttName);
   }
d807 2
a808 2
   {
   theWitRun->myApiMgr ()->startInnerFunc ();
d810 2
a811 2
   return theWitRun->myProblem ();
   }
d816 2
a817 2
   {
   WitPeriod thePer;
d819 1
a819 1
   forbidNullSetArg (theValue);
d821 8
a828 8
   forEachPeriod (thePer, myProblem ())
      if ((theValue[thePer] < 0) or (theValue[thePer] > lastPeriod ()))
         {
         errorFound (thePer);

         myMsgFac () ("intLowEqUpEqSmsg", theValue[thePer], 0, lastPeriod ());
         }
   }
d833 9
a841 9
      WitDblFlexVec &       mergedVec,
      const WitDblFlexVec & oldVec,
      const WitIVRealArg &  theIVRealArg)
   {
   if (theIVRealArg != NULL)
      theIVRealArg.copyInto (mergedVec);
   else
      mergedVec = oldVec;
   }
d846 2
a847 2
   {
   WitDelComp * theDelComp;
d849 1
a849 1
   stronglyAssert (myStochImpMgr ()->stochMode ());
d851 1
a851 1
   theDelComp = myComponent ()->thisDelComp ();
d853 21
a873 21
   if (not myStochImpMgr ()->canSetInStochMode (theAttName))
      {
      if (theDelComp != NULL)
         myMsgFac () ("setObjStochModeSmsg",
            theAttName,
            theDelComp->objTypeMsgFrag ());
      else
         myMsgFac () ("setGlobStochModeSmsg", theAttName);
      }

   if (myStochImpMgr ()->stochSolnMode ())
      if (not myStochImpMgr ()->canSetInStochSolnMode (theAttName))
         {
         if (theDelComp != NULL)
            myMsgFac () ("setObjStochSolnSmsg",
               theAttName,
               theDelComp->objTypeMsgFrag ());
         else
            myMsgFac () ("setGlobStochSolnSmsg", theAttName);
         }
   }
d880 3
a882 3
      WitApiCall (theWitRun)
   {
   }
d887 2
a888 2
   {
   }
d893 3
a895 3
   {
   return myGlobalComp ();
   }
d902 3
a904 3
      WitApiCall (theWitRun)
   {
   }
d909 2
a910 2
   {
   }
d915 4
a918 4
   {
   if (not myOptComp ()->multiObjMode ())
      myMsgFac () ("globNeedsMultiObjModeSmsg", theAttName);
   }
d923 3
a925 3
   {
   return myOptComp ()->myMultiObjMgr ();
   }
d930 3
a932 3
   {
   return myMultiObjMgr ()->currentObjective ();
   }
d937 3
a939 3
   {
   return myOptComp ()->myCpxParSpecMgr ();
   }
d944 3
a946 3
   {
   return myOptComp ();
   }
d953 3
a955 3
      WitApiCall (theWitRun)
   {
   }
d960 2
a961 2
   {
   }
d966 2
a967 2
   {
   WitPeriod thePer;
d969 1
a969 1
   prepSetAttr ("periodStage");
d971 2
a972 2
   if (not myStochImpMgr ()->stochMode ())
      myMsgFac () ("globNeedsStochModeSmsg", "periodStage");
d974 32
a1005 32
   if (myStochImpMgr ()->stageByObject ())
      myMsgFac () ("periodStageWStageByObjectSmsg");

   forbidNullSetArg (periodStage);

   forEachPeriod (thePer, myProblem ())
      if    (periodStage[thePer] != 0)
         if (periodStage[thePer] != 1)
            {
            myInputID ()->setErrorPeriod (thePer);

            myMsgFac () ("intLowEqUpEqImmSmsg", periodStage[thePer], 0, 1);
            }

   for (thePer = 1; thePer < nPeriods (); thePer ++)
      if    (periodStage[thePer - 1] == 1)
         if (periodStage[thePer    ] == 0)
            myMsgFac () ("perStageConflictSmsg", thePer - 1, thePer);

   if (argsOK ())
      {
      if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
         {
         WitMsgArg theMsgArg (periodStage, nPeriods ());

         myMsgFac () ("setVecIntAttrMsg", "periodStage", theMsgArg);
         }

      forEachPeriod (thePer, myProblem ())
         myStochImpMgr ()->setPeriodStageIdx (thePer, periodStage[thePer]);
      }
   }
d1010 3
a1012 3
   {
   return myGlobalComp ();
   }
d1019 1
a1019 1
      WitApiCall (theWitRun),
d1021 3
a1023 3
      myPart_    (theWitRun->setGetPartInit (partName))
   {
   }
d1028 3
a1030 3
   {
   myInputID ()->setMyPart (NULL);
   }
d1035 3
a1037 3
   {
   return myPart_;
   }
d1042 3
a1044 3
   {
   return myPart_;
   }
d1051 9
a1059 9
         WitRun *     theWitRun, 
         const char * partName,
         const char * theAttName):

      WitApiCall  (theWitRun),

      myMaterial_ (theWitRun->setGetMaterialInit (partName, theAttName))
   {
   }
d1064 3
a1066 3
   {
   myInputID ()->setMyPart (NULL);
   }
d1071 13
a1083 13
      const char * theAttName,
      bool         oldValue,
      WitBoolean   theValue,
      const char * otherAttr)
   {
   prepBool (theAttName, oldValue, theValue);

   if (not oldValue)
      if (theValue)
         if (myMaterial_->buildNstn () or myMaterial_->buildAsap ())
            if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
               myMsgFac () ("setBooleanAttrMsg", otherAttr, true, false);
   }
d1088 3
a1090 3
   {
   return myMaterial_;
   }
d1095 3
a1097 3
   {
   return myMaterial_;
   }
d1104 9
a1112 9
         WitRun *     theWitRun,
         const char * demandedPartName,
         const char * demandName):

      WitApiCall (theWitRun),

      myDemand_  (theWitRun->setGetDemandInit (demandedPartName, demandName))
   {
   }
d1117 4
a1120 4
   {
   myInputID ()->setMyPart   (NULL);
   myInputID ()->setMyDemand (NULL);
   }
d1125 3
a1127 3
   {
   return myDemand_;
   }
d1132 3
a1134 3
   {
   return myDemand_;
   }
d1141 2
a1142 2
         WitRun *     theWitRun,
         const char * operationName):
d1144 1
a1144 1
      WitApiCall   (theWitRun),
d1146 3
a1148 3
      myOperation_ (theWitRun->setGetOperationInit (operationName))
   {
   }
d1153 3
a1155 3
   {
   myInputID ()->setMyOperation (NULL);
   }
d1160 2
a1161 2
   {
   WitPeriod thePer;
d1163 1
a1163 1
   prepSetAttr ("yieldRate");
d1165 1
a1165 1
   forbidNullSetArg (theValue);
d1167 4
a1170 4
   forEachPeriod (thePer, myProblem ())
      if (not WitOperation::validYieldRate (theValue[thePer]))
         {
         errorFound (thePer);
d1172 2
a1173 2
         myMsgFac () ("yieldRateRangeSmsg", theValue[thePer]);
         }
d1175 3
a1177 3
   if (argsOK ())
      {
      theValue.issueSetDblVecMsg ("yieldRate", * this);
d1179 3
a1181 3
      myOperation_->setYieldRate (theValue);
      }
   }
d1186 2
a1187 2
   {
   prepSetAttr ("cycleTime34");
d1189 1
a1189 1
   forbidNullSetArg (theValue);
d1191 7
a1197 7
   if (not wit34Compatible ())
      myMsgFac () ("settingCycleTime34WithoutCompatibility",
         myApiMgr ()->apiFuncName ());

   if (argsOK ())
      myOperation_->setCycleTime34 (theValue);
   }
d1202 3
a1204 3
   {
   return myOperation_;
   }
d1209 3
a1211 3
   {
   return myOperation_;
   }
d1218 11
a1228 11
         WitRun *     theWitRun,
         const char * consumingOperationName,
         int          bomEntryIndex):

      WitApiCall (theWitRun),

      myBomEnt_  (NULL)
   {
   myBomEnt_ =
      theWitRun->setGetBomEntryInit (consumingOperationName, bomEntryIndex);
   }
d1233 4
a1236 4
   {
   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBomEntry  (NULL);
   }
d1241 3
a1243 3
   {
   return myBomEnt_;
   }
d1248 3
a1250 3
   {
   return myBomEnt_;
   }
d1255 3
a1257 3
   {
   return myBomEnt_;
   }
d1262 3
a1264 3
   {
   return myBomEnt_;
   }
d1271 15
a1285 15
         WitRun *     theWitRun,
         const char * consumingOperationName,
         int          bomEntryIndex,
         int          subEntryIndex):

      WitApiCall (theWitRun),

      mySub_     (NULL)
   {
   mySub_ =
      theWitRun->setGetSubBomEntryInit (
         consumingOperationName,
         bomEntryIndex,
         subEntryIndex);
   }
d1290 5
a1294 5
   {
   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBomEntry  (NULL);
   myInputID ()->setMySubEntry  (NULL);
   }
d1299 3
a1301 3
   {
   return mySub_;
   }
d1306 3
a1308 3
   {
   return mySub_;
   }
d1313 3
a1315 3
   {
   return mySub_;
   }
d1320 3
a1322 3
   {
   return mySub_;
   }
d1329 11
a1339 11
         WitRun *     theWitRun,
         const char * producingOperationName,
         int          bopEntryIndex):

      WitApiCall (theWitRun),

      myBopEnt_  (NULL)
   {
   myBopEnt_ =
      theWitRun->setGetBopEntryInit (producingOperationName, bopEntryIndex);
   }
d1344 4
a1347 4
   {
   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBopEntry  (NULL);
   }
d1352 3
a1354 3
   {
   return myBopEnt_;
   }
d1359 3
a1361 3
   {
   return myBopEnt_;
   }
d1366 3
a1368 3
   {
   return myBopEnt_;
   }
@


1.130
log
@Heuristic Adjustment
@
text
@d73 13
d936 7
@


1.129
log
@Lead Time Bounds
@
text
@d38 1
a38 1
#include <Opn.h>
@


1.128
log
@Lead Time Bounds.
@
text
@d316 1
a316 1
   for (thePer = 1; thePer < nPeriods (); thePer ++)
d318 1
a318 1
      if (theValue[thePer] > theValue[thePer - 1] + 1)
d323 1
a323 1
            "buildAheadUB[t] <= buildAheadUB[t-1] + 1",
a325 1
            thePer - 1,
d327 2
a328 1
            theValue[thePer - 1]);
d360 2
d363 1
a363 3
            thePer,
            theValue[thePer + 1],
            theValue[thePer]);
d386 1
a386 1
   for (thePer = 1; thePer < nPeriods (); thePer ++)
d388 1
a388 1
      if (theValue[thePer] < theValue[thePer - 1] - 1)
d393 1
a393 1
            "shipLateUB[t] >= shipLateUB[t-1] - 1",
a395 1
            thePer - 1,
d397 2
a398 1
            theValue[thePer - 1]);
@


1.127
log
@Bounded Lead Times
@
text
@d351 1
a351 1
   for (thePer = 1; thePer < nPeriods (); thePer ++)
d353 1
a353 1
      if (theValue[thePer] > theValue[thePer - 1] + 1)
d358 1
a358 1
            "leadTimeUB[t] <= leadTimeUB[t-1] + 1",
d360 1
d362 2
a363 3
            thePer - 1,
            theValue[thePer],
            theValue[thePer - 1]);
@


1.126
log
@Multi-Obj Mode
@
text
@d317 1
d330 1
d343 35
d387 1
d400 1
@


1.125
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d194 21
a483 24
void WitApiCall::setFalloutRate (double theValue)
   {
   prepSetAttr ("falloutRate");

   if ((theValue < 0.0) or (theValue > 0.99 + FLOAT_EPSILON))
      {
      errorFound ();

      myMsgFac () ("dblLowEqUpEqSmsg", theValue, 0.0, 0.99);
      }
   else
      if (myMsgFac ().mayIssue ("setDblAttrMsg"))
         myMsgFac () (
            "setDblAttrMsg", 
            "falloutRate", 
            myConsEntry ()->falloutRate (), 
            theValue);

   if (argsOK ())
      myConsEntry ()->setFalloutRate (theValue);
   }

//------------------------------------------------------------------------------

d862 8
@


1.124
log
@Multi-Obj Mode
@
text
@d35 1
a35 1
#include <Global.h>
@


1.123
log
@Multi-Obj Mode
@
text
@a574 13
   if (myOptComp ()->multiObjMode ())
      {
      forEachPeriod (thePer, myProblem ())
         {
         if (softLBMrg[thePer] > hardLBMrg[thePer])
            {
            myMsgFac () ("softLBMultiObjWmsg", 
               hardLBMrg[thePer],
               softLBMrg[thePer]);
            }
         }
      }

@


1.122
log
@Multi-objective mode
@
text
@d581 1
a581 3
            errorFound (thePer);

            myMsgFac () ("softLBMultiObjSmsg", 
@


1.121
log
@Multi-objective mode
@
text
@d100 1
a100 1
   if (theValue <= 0)
@


1.120
log
@Multi-Objective Mode.
@
text
@d575 15
@


1.119
log
@Multi-objective mode.
@
text
@d44 1
d872 7
@


1.118
log
@Removed many conversions of string constant to char *.
@
text
@d864 7
@


1.117
log
@Stochastic Implosion
@
text
@d59 4
a62 1
void WitApiCall::prepBool (WitAttr theAttr, bool oldValue, WitBoolean theValue)
d64 1
a64 1
   prepSetAttr (theAttr);
d67 1
a67 1
      myMsgFac () ("setBooleanAttrMsg", theAttr, oldValue, theValue);
d72 4
a75 1
void WitApiCall::prepNonNegInt (WitAttr theAttr, int oldValue, int theValue)
d77 1
a77 1
   prepSetAttr (theAttr);
d87 1
a87 1
         myMsgFac () ("setIntAttrMsg", theAttr, oldValue, theValue);
d92 4
a95 1
void WitApiCall::prepImmPosInt (WitAttr theAttr, int oldValue, int theValue)
d97 1
a97 1
   prepSetAttr (theAttr);
d103 1
a103 1
      myMsgFac () ("setIntAttrMsg", theAttr, oldValue, theValue);
d109 1
a109 1
      WitAttr      theAttr,
d115 1
a115 1
   prepSetAttr (theAttr);
d125 1
a125 1
         myMsgFac () ("setIntAttrMsg", theAttr, oldValue, theValue);
d131 1
a131 1
      WitAttr      theAttr,
d137 1
a137 1
   prepSetAttr (theAttr);
d143 1
a143 1
         myMsgFac () ("setIntAttrMsg", theAttr, oldValue, theValue);
d148 4
a151 1
void WitApiCall::prepDouble (WitAttr theAttr, double oldValue, double theValue)
d153 1
a153 1
   prepSetAttr (theAttr);
d156 1
a156 1
      myMsgFac () ("setDblAttrMsg", theAttr, oldValue, theValue);
d162 3
a164 3
      WitAttr theAttr, 
      double  oldValue,
      double  theValue)
d166 1
a166 1
   prepLBDouble (theAttr, oldValue, theValue, 0.0, 0.0);
d172 5
a176 5
      WitAttr theAttr, 
      double  oldValue, 
      double  theValue,
      double  lb,
      double  msgLB)
d178 1
a178 1
   prepSetAttr (theAttr);
d188 1
a188 1
         myMsgFac () ("setDblAttrMsg", theAttr, oldValue, theValue);
d194 3
a196 3
      WitAttr theAttr,
      double  oldValue,
      double  theValue)
d198 1
a198 1
   prepSetAttr (theAttr);
d208 1
a208 1
         myMsgFac () ("setDblAttrMsg", theAttr, oldValue, theValue);
d213 3
a215 1
void WitApiCall::prepBoolVec (WitAttr theAttr, const WitBoolean * theValue)
d217 1
a217 1
   prepSetAttr (theAttr);
d225 1
a225 1
      myMsgFac () ("setVecBoolAttrMsg", theAttr, theMsgArg);
d231 3
a233 1
void WitApiCall::prepIntVec (WitAttr theAttr, const int * theValue)
d235 1
a235 1
   prepSetAttr (theAttr);
d243 1
a243 1
      myMsgFac () ("setVecIntAttrMsg", theAttr, theMsgArg);
d249 3
a251 1
void WitApiCall::prepDblVec (WitAttr theAttr, const WitIVRealArg & theValue)
d253 1
a253 1
   prepSetAttr (theAttr);
d257 1
a257 1
   theValue.issueSetDblVecMsg (theAttr, * this);
d263 1
a263 1
      WitAttr              theAttr,
d268 1
a268 1
   prepSetAttr (theAttr);
d281 1
a281 1
      theValue.issueSetDblVecMsg (theAttr, * this);
d353 1
a353 1
      WitAttr           theAttr,
d357 1
a357 1
   prepSetAttr (theAttr);
d362 1
a362 1
      myMsgFac () ("setStringAttrMsg", theAttr, oldValue, theValue);
d589 1
a589 1
void WitApiCall::reqNoPartsOrOpns (WitAttr theAttr)
d594 1
a594 1
   myInputID ()->setMyAttr (theAttr);
d597 1
a597 1
      theAttr,
d604 3
a606 1
void WitApiCall::issueSetDblVecMsg (WitAttr theAttr, const float * theFltCVec)
d612 1
a612 1
      myMsgFac () ("setVecDblAttrMsg", theAttr, theMsgArg);
d618 3
a620 1
void WitApiCall::issueSetDblVecMsg (WitAttr theAttr, const double * theDblCVec)
d626 1
a626 1
      myMsgFac () ("setVecDblAttrMsg", theAttr, theMsgArg);
d686 1
a686 1
   myInputID ()->setMyAttr      (NULL);
d743 1
a743 1
void WitApiCall::prepSetAttr (WitAttr theAttr)
d748 1
a748 1
   myInputID ()->setMyAttr (theAttr);
d751 1
a751 1
      prepSetAttrStochMode (theAttr);
d795 1
a795 1
void WitApiCall::prepSetAttrStochMode (WitAttr theAttr)
d803 1
a803 1
   if (not myStochImpMgr ()->canSetInStochMode (theAttr))
d807 1
a807 1
            theAttr,
d810 1
a810 1
         myMsgFac () ("setGlobStochModeSmsg", theAttr);
d814 1
a814 1
      if (not myStochImpMgr ()->canSetInStochSolnMode (theAttr))
d818 1
a818 1
               theAttr,
d821 1
a821 1
            myMsgFac () ("setGlobStochSolnSmsg", theAttr);
d974 1
a974 1
         WitAttr      theAttr):
d978 1
a978 1
      myMaterial_ (theWitRun->setGetMaterialInit (partName, theAttr))
d992 4
a995 4
      WitAttr    theAttr,
      bool       oldValue,
      WitBoolean theValue,
      WitAttr    otherAttr)
d997 1
a997 1
   prepBool (theAttr, oldValue, theValue);
@


1.116
log
@Stochastic Implosion
@
text
@d864 44
@


1.115
log
@Stochastic Implosion
@
text
@d487 1
a487 1
      myStochImpMgr ()->objectStage (theNode),
d493 1
a493 1
      myStochImpMgr ()->setObjectStage (theNode, theValue);
d518 1
a518 1
         myStochImpMgr ()->objectStage (theNode));
@


1.114
log
@Stochastic Implosion
@
text
@d468 1
a468 1
void WitApiCall::setStageIndex (int theValue)
d478 1
a478 1
         "stageIndex",
d482 2
a483 1
      myMsgFac () ("stageIndexWoStageByObjectSmsg", theNode->objTypeMsgFrag ());
d486 2
a487 2
                       "stageIndex", 
      myStochImpMgr ()->stageIndex (theNode),
d493 1
a493 1
      myStochImpMgr ()->setStageIndex (theNode, theValue);
d498 1
a498 1
void WitApiCall::getStageIndex (int * stageIndex)
d508 1
a508 1
         "stageIndex",
d512 2
a513 1
      myMsgFac () ("stageIndexWoStageByObjectSmsg", theNode->objTypeMsgFrag ());
d516 3
a518 3
      apiGet (             stageIndex,
                          "stageIndex",
         myStochImpMgr ()->stageIndex (theNode));
@


1.113
log
@Stochastic Implosion
@
text
@d484 1
a484 1
   prepRangedInt (
@


1.112
log
@Stochastic Implosion
@
text
@d497 24
@


1.111
log
@Stochastic Implosion
@
text
@d481 3
@


1.110
log
@Stochastic Implosion
@
text
@a771 7

   if (myStochImpMgr ()->isScenSpec (theAttr))
      if (theDelComp != NULL)
         if (theDelComp->stageIndex () == 0)
            myMsgFac () ("setStage0AttSmsg",
               theAttr,
               theDelComp->objTypeMsgFrag ());
@


1.109
log
@Stochastic Implosion
@
text
@d582 3
a584 3
      const WitBoundSet * theBoundSet,
      const float *       theFltCVec,
      WitMsgFragID        theFragID)
d603 3
a605 3
      const WitBoundSet * theBoundSet,
      const double *      theDblCVec,
      WitMsgFragID        theFragID)
@


1.108
log
@Stochastic Implosion
@
text
@d500 1
a500 1
   WitPeriod     thePer;
a509 6
   if (myStochImpMgr ()->stochMode ())
      if (theBoundSet->myDelComp ()->stageIndex () == 0)
         myMsgFac () ("setStage0AttSmsg",
            theBoundSet->myAttName (),
            myDelComp ()->objTypeMsgFrag ());

@


1.107
log
@Stochastic Implosion
@
text
@d703 2
a706 2

   myInputID ()->setMyAttr (theAttr);
d756 2
a759 2
      theDelComp = myComponent ()->thisDelComp ();

a770 2
         theDelComp = myComponent ()->thisDelComp ();

d778 7
a872 13
void WitPartApiCall::prepSetPartSupplyVol (const WitIVRealArg & theValue)
   {
   prepNonNegDblVec ("supplyVol", theValue);

   if (myStochImpMgr ()->stochMode ())
      if (myStochImpMgr ()->stageIndex (myPart_) == 0)
         myMsgFac () ("setStage0AttSmsg",
            "supplyVol",
            myPart_->objTypeMsgFrag ());
   }

//------------------------------------------------------------------------------

a962 13
void WitDemandApiCall::prepSetDemandDemandVol (const WitIVRealArg & theValue)
   {
   prepNonNegDblVec ("demandVol", theValue);

   if (myStochImpMgr ()->stochMode ())
      if (myStochImpMgr ()->stageIndex (myDemand_->demandedPart ()) == 0)
         myMsgFac () ("setStage0AttSmsg",
            "demandVol",
            myDemand_->objTypeMsgFrag ());
   }

//------------------------------------------------------------------------------

@


1.106
log
@Stochastic Implosion
@
text
@d511 1
a511 1
      if (myStochImpMgr ()->stageIndex (theBoundSet->myDelComp ()) == 0)
@


1.105
log
@Stochastic Implosion
@
text
@d511 1
a511 1
      if (myStochImpMgr ()->stageIndex (theBoundSet) == 0)
@


1.104
log
@Stochastic Implosion
@
text
@d511 1
a511 1
      if (theBoundSet->myComp ()->stageIndex () == 0)
@


1.103
log
@Stochastic Implosion
@
text
@d237 2
@


1.102
log
@Stochastic Implosion
@
text
@d466 1
a466 1
void WitApiCall::setStageNo (int theValue)
d476 1
a476 1
         "stageNo",
d480 2
a481 2
                       "stageNo", 
      myStochImpMgr ()->stageNo (theNode),
d487 1
a487 1
      myStochImpMgr ()->setStageNo (theNode, theValue);
d509 1
a509 1
      if (theBoundSet->myComp ()->stageNo () == 0)
d871 1
a871 1
      if (myStochImpMgr ()->stageNo (myPart_) == 0)
d974 1
a974 1
      if (myStochImpMgr ()->stageNo (myDemand_->demandedPart ()) == 0)
@


1.101
log
@Stochastic Implosion
@
text
@d509 1
a509 1
      if (myStochImpMgr ()->stageNo (theBoundSet->myNode ()) == 0)
@


1.100
log
@Stochastic Implosion
@
text
@d466 26
@


1.99
log
@Stochastic Implosion
@
text
@a600 19
void WitApiCall::prepGetStochSolnAttr (WitAttr theAttr)
   {
   WitDelComp * theDelComp;

   if (myStochImpMgr ()->stochMode ())
      if (not myStochImpMgr ()->stochSolnMode ())
         {
         theDelComp = myComponent ()->thisDelComp ();

         stronglyAssert (theDelComp != NULL);

         myMsgFac () ("getObjStochSolnModeSmsg",
            theAttr,
            theDelComp->objTypeMsgFrag ());
         }
   }

//------------------------------------------------------------------------------

@


1.98
log
@Stochastic Implosion
@
text
@a770 3

   if (myStochImpMgr ()->isaScenSpecAtt (theAttr))
      myMsgFac () ("scenSpecificMsg", myStochImpMgr ()->curScenarioNo ());
@


1.97
log
@Stochastic Implosion
@
text
@d482 6
d862 13
d965 13
@


1.96
log
@Stochastic Implosion
@
text
@d480 1
a480 1
   prepSetAttr (theBoundSet->apiAttr ());
d567 1
a567 1
      theBoundSet->apiAttr (),
d588 1
a588 1
      theBoundSet->apiAttr (),
@


1.95
log
@Stochastic Implosion
@
text
@d766 1
a766 1
   if (myStochImpMgr ()->isScenSpecAtt (theAttr))
@


1.94
log
@Stochastic Implosion
@
text
@d767 1
a767 1
      myMsgFac () ("scenSpecificMsg", myStochImpMgr ()->scenarioIndex ());
@


1.93
log
@Stochastic Implosion
@
text
@d33 1
a33 1
#include <OptImp.h>
@


1.92
log
@Stochastic Implosion
@
text
@d741 1
a741 1
   if (not myStochImpMgr ()->attIsStochModeOK (theAttr))
d754 1
a754 1
      if (not myStochImpMgr ()->attIsStochSolnModeOK (theAttr))
d766 1
a766 1
   if (myStochImpMgr ()->attIsScenSpec (theAttr))
@


1.91
log
@Stochastic Implosion
@
text
@a599 1
      {
a609 3

      myMsgFac () ("scenSpecificMsg", myStochImpMgr ()->scenarioIndex ());
      }
d741 1
a741 1
   if (not myStochImpMgr ()->isStochModeAttName (theAttr))
d754 1
a754 1
      if (not myStochImpMgr ()->isStochSolnModeAttName (theAttr))
d766 1
a766 1
   if (myStochImpMgr ()->isSsiAttName (theAttr))
@


1.90
log
@Stochastic Implosion.
@
text
@a594 7
void WitApiCall::prepStochSolnModeAttr ()
   {
   stochSolnModeOK_ = true;
   }

//------------------------------------------------------------------------------

d621 2
a622 3
      argsOK_          (true),
      prepSetCalled_   (false),
      stochSolnModeOK_ (false)
d745 1
a745 4
   if (myStochImpMgr ()->isSsiAttName (theAttr))
      myMsgFac () ("scenSpecificMsg", myStochImpMgr ()->scenarioIndex ());

   else if (not stochSolnModeOK_)
d758 1
a758 1
      if (not stochSolnModeOK_)
d769 3
@


1.89
log
@Stochastic Implosion
@
text
@d753 1
a753 1
   if (myStochImpMgr ()->isSsiAttrName (theAttr))
@


1.88
log
@Stochastic Implosion
@
text
@a601 10
void WitApiCall::prepGetStochAttr ()
   {
   if (myStochImpMgr ()->stochMode ())
      {
      myMsgFac () ("scenSpecificMsg", myStochImpMgr ()->scenarioIndex ());
      }
   }

//------------------------------------------------------------------------------

@


1.87
log
@Stochastic Implosion
@
text
@a594 12
void WitApiCall::prepStochModeAttr ()
   {
   stochModeOK_ = true;

   if (myStochImpMgr ()->stochMode ())
      {
      myMsgFac () ("scenSpecificMsg", myStochImpMgr ()->scenarioIndex ());
      }
   }

//------------------------------------------------------------------------------

a596 1
   stochModeOK_     = true;
a639 1
      stochModeOK_     (false),
d763 4
a766 1
   if (not stochModeOK_)
@


1.86
log
@Stochastic Implosion.
@
text
@d595 1
a595 1
void WitApiCall::prepStochDataModeAttr ()
d597 1
a597 1
   stochDataModeOK_ = true;
d599 1
a599 1
   if (myStochImpMgr ()->stochDataMode ())
d609 1
a609 1
   stochDataModeOK_ = true;
d617 1
a617 1
   if (myStochImpMgr ()->stochDataMode ())
d629 1
a629 1
   if (myStochImpMgr ()->stochDataMode ())
d653 1
a653 1
      stochDataModeOK_ (false),
d724 1
a724 1
   if (myStochImpMgr ()->stochDataMode ())
d775 1
a775 1
   stronglyAssert (myStochImpMgr ()->stochDataMode ());
d777 1
a777 1
   if (not stochDataModeOK_)
@


1.85
log
@Stochastic Implosion
@
text
@d599 4
a602 1
   issueScenMsg ();
d615 1
a615 1
void WitApiCall::issueScenMsg ()
d618 1
d620 24
@


1.84
log
@Stochastic Implosion
@
text
@d595 1
a595 1
void WitApiCall::prepStochAttr ()
@


1.83
log
@Stochastic Implosion
@
text
@d44 1
a44 1
#include <StochMgr.h>
d614 2
a615 2
   if (myStochMgr ()->stochDataMode ())
      myMsgFac () ("scenSpecificMsg", myStochMgr ()->scenarioIndex ());
d696 1
a696 1
   if (myStochMgr ()->stochDataMode ())
d747 1
a747 1
   stronglyAssert (myStochMgr ()->stochDataMode ());
d761 1
a761 1
   if (myStochMgr ()->stochSolnMode ())
@


1.82
log
@Stochastic Implosion
@
text
@d597 1
a597 1
   prepStochDataModeAttr ();
a603 7
void WitApiCall::prepStochDataModeAttr ()
   {
   stochDataModeOK_ = true;
   }

//------------------------------------------------------------------------------

@


1.81
log
@Stochastic Implosion
@
text
@d611 8
d632 2
a633 1
      stochDataModeOK_ (false)
d768 4
a771 3
   else if (myStochMgr ()->stochSolnMode ())
      {
      theDelComp = myComponent ()->thisDelComp ();
d773 7
a779 7
      if (theDelComp != NULL)
         myMsgFac () ("setObjStochSolnSmsg",
            theAttr,
            theDelComp->objTypeMsgFrag ());
      else
         myMsgFac () ("setGlobStochSolnSmsg", theAttr);
      }
@


1.80
log
@Stochastic Implosion
@
text
@d759 1
a759 1
   else if (myStochMgr ()->stochSolnExists ())
@


1.79
log
@Stochastic Implosion
@
text
@d595 10
a604 1
void WitApiCall::prepSetStochDataModeAttr ()
d614 1
a614 1
      myMsgFac () ("scenSpecAttrMsg", myStochMgr ()->scenarioIndex ());
@


1.78
log
@Stochastic Implosion
@
text
@d595 1
a595 1
void WitApiCall::setsStochModeAttr ()
d597 1
a597 1
   stochModeSet_ = true;
d613 3
a615 3
      argsOK_        (true),
      prepSetCalled_ (false),
      stochModeSet_  (false)
d738 1
a738 1
   if (not stochModeSet_)
@


1.77
log
@Stochastic Implosion
@
text
@a681 2
   WitDelComp * theDelComp;

d686 1
a686 11
      if (not stochModeSet_)
         {
         theDelComp = myComponent ()->thisDelComp ();

         if (theDelComp != NULL)
            myMsgFac () ("setObjStochModeSmsg",
               theAttr,
               theDelComp->objTypeMsgFrag ());
         else
            myMsgFac () ("setGlobStochModeSmsg", theAttr);
         }
d731 33
@


1.76
log
@Stochastic Implosion
@
text
@d604 1
a604 1
   if (myStochMgr ()->stochasticMode ())
d687 1
a687 1
   if (myStochMgr ()->stochasticMode ())
@


1.75
log
@Stochastic Implosion
@
text
@d604 1
a604 1
   if (myStochMgr ()->stochImpMode ())
d687 1
a687 1
   if (myStochMgr ()->stochImpMode ())
@


1.74
log
@Stochastic Implosion
@
text
@a802 7
WitStochModeMgr * WitStochApiCall::myStochModeMgr ()
   {
   return myStochMgr ()->myStochModeMgr ();
   }

//------------------------------------------------------------------------------

@


1.73
log
@Stochastic Implosion
@
text
@a44 2
#include <StochMode.h>
#include <Scenario.h>
d605 1
a605 2
      myMsgFac () ("scenSpecAttrMsg",
         myStochMgr ()->myStochModeMgr ()->curScenario ()->myIndex ());
@


1.72
log
@Stochastic Implosion
@
text
@d45 1
a45 1
#include <StochProb.h>
d608 1
a608 1
         myStochMgr ()->myStochProb ()->curScenario ()->myIndex ());
d806 1
a806 1
WitStochProb * WitStochApiCall::myStochProb ()
d808 1
a808 1
   return myStochMgr ()->myStochProb ();
@


1.71
log
@Stochastic Implosion
@
text
@d597 1
a597 1
void WitApiCall::setsStochAttr ()
d599 1
a599 1
   funcSetsStochAttr_ = true;
d616 3
a618 3
      argsOK_            (true),
      prepSetCalled_     (false),
      funcSetsStochAttr_ (false)
d691 1
a691 1
      if (not funcSetsStochAttr_)
@


1.70
log
@Stochastic Implosion
@
text
@d45 2
d604 9
@


1.69
log
@Stochastic Implosion
@
text
@d795 1
a795 1
WitSIP * WitStochApiCall::mySIP ()
d797 1
a797 1
   return myStochMgr ()->mySIP ();
@


1.68
log
@Stochastic Implosion
@
text
@d18 1
d779 29
@


1.67
log
@Stochastic implosion.
@
text
@d120 18
@


1.66
log
@Stochastic Implosion.
@
text
@d660 1
a660 1
   if (myStochMgr ()->active ())
d666 1
a666 1
            myMsgFac () ("setObjStochActSmsg",
d670 1
a670 1
            myMsgFac () ("setGlobStochActSmsg", theAttr);
@


1.65
log
@Stochastic implosion.
@
text
@d576 1
a576 1
void WitApiCall::allowStochAct ()
d578 1
a578 1
   stochActAllowed_ = true;
d586 3
a588 3
      argsOK_          (true),
      prepSetCalled_   (false),
      stochActAllowed_ (false)
d661 1
a661 1
      if (not stochActAllowed_)
@


1.64
log
@Stochastic implosion.
@
text
@d576 1
a576 1
void WitApiCall::attrIsDiffable ()
d578 1
a578 1
   diffableAttr_ = true;
d586 3
a588 3
      argsOK_        (true),
      prepSetCalled_ (false),
      diffableAttr_  (false)
d661 1
a661 1
      if (not diffableAttr_)
@


1.63
log
@Stochastic Implosion.
@
text
@d60 1
a60 1
   callingPrep (theAttr);
d70 1
a70 1
   callingPrep (theAttr);
d87 1
a87 1
   callingPrep (theAttr);
d105 1
a105 1
   callingPrep (theAttr);
d122 1
a122 1
   callingPrep (theAttr);
d147 1
a147 1
   callingPrep (theAttr);
d167 1
a167 1
   callingPrep (theAttr);
d184 1
a184 1
   callingPrep (theAttr);
d200 1
a200 1
   callingPrep (theAttr);
d216 1
a216 1
   callingPrep (theAttr);
d229 1
a229 1
   callingPrep (theAttr);
d251 1
a251 1
   callingPrep ("buildAheadUB");
d284 1
a284 1
   callingPrep ("shipLateUB");
d318 1
a318 1
   callingPrep (theAttr);
d330 1
a330 1
   callingPrep ("appData");
d382 1
a382 1
   callingPrep ("routingShare");
d406 1
a406 1
   callingPrep ("offset");
d425 1
a425 1
   callingPrep ("falloutRate");
d461 1
a461 1
   callingPrep (theBoundSet->apiAttr ());
d576 7
d586 3
a588 2
      argsOK_      (true),
      prepCalled_  (false)
d653 1
a653 1
void WitApiCall::callingPrep (WitAttr theAttr)
d658 1
a658 1
      prepCalled_ = true;
d661 3
a663 2
      {
      theDelComp = myComponent ()->thisDelComp ();
d665 7
a671 7
      if (theDelComp != NULL)
         myMsgFac () ("setObjStochActSmsg",
            theAttr,
            theDelComp->objTypeMsgFrag ());
      else
         myMsgFac () ("setGlobStochActSmsg", theAttr);
      }
d908 1
a908 1
   callingPrep ("yieldRate");
d932 1
a932 1
   callingPrep ("cycleTime34");
@


1.62
log
@External opt implosion.
@
text
@d43 1
a57 18
WitApiCall::WitApiCall (WitRun * theWitRun):
      WitProbAssoc (theProblemFor (theWitRun)),

      argsOK_      (true),
      prepCalled_  (false)
   {
   }

//------------------------------------------------------------------------------

WitApiCall::~WitApiCall ()
   {
   myInputID ()->setMyAttr      (NULL);
   myInputID ()->setErrorPeriod (-1);
   }

//------------------------------------------------------------------------------

d576 5
a580 1
WitComponent * WitApiCall::myComponent ()
d582 3
a584 1
   stronglyAssert (false);
d586 4
a589 1
   return NULL;
d647 2
d652 12
@


1.61
log
@New PIP pegging order.
@
text
@d58 1
a58 1
      WitProbAssoc (theWitRun->myProblem ()),
d60 2
a61 2
      argsOK_     (true),
      prepCalled_ (false)
d663 9
@


1.60
log
@project changes
@
text
@a45 1

@


1.59
log
@Updated the copyright date on all source files.
@
text
@d46 1
@


1.58
log
@Fixed a bug that occurred when witCopyData issued a severe error.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.57
log
@[exceptions]
@
text
@d60 2
a61 3
      argsOK_      (true),
      prepCalled_  (false),
      argsChecked_ (false)
a70 5

   if (DEBUG_MODE)
      if (prepCalled_)
         if (not myApiMgr ()->abortingApiFunc ())
            witAssert (argsChecked_);
@


1.56
log
@[exceptions]
@
text
@d29 1
d50 1
a50 1
inline WitInputId * WitApiCall::myInputId ()
d52 1
a52 1
   return myApiMgr ()->myInputId ();
d70 2
a71 2
   myInputId ()->setMyAttr      (NULL);
   myInputId ()->setErrorPeriod (-1);
d523 1
a523 1
   myInputId ()->setMyAttr (theAttr);
d647 1
a647 1
   myInputId ()->setErrorPeriod (thePer);
d664 1
a664 1
   myInputId ()->setMyAttr (theAttr);
d756 1
a756 1
   myInputId ()->setMyPart (NULL);
d792 1
a792 1
   myInputId ()->setMyPart (NULL);
d845 2
a846 2
   myInputId ()->setMyPart   (NULL);
   myInputId ()->setMyDemand (NULL);
d881 1
a881 1
   myInputId ()->setMyOperation (NULL);
d961 2
a962 2
   myInputId ()->setMyOperation (NULL);
   myInputId ()->setMyBomEntry  (NULL);
d1018 3
a1020 3
   myInputId ()->setMyOperation (NULL);
   myInputId ()->setMyBomEntry  (NULL);
   myInputId ()->setMySubEntry  (NULL);
d1072 2
a1073 2
   myInputId ()->setMyOperation (NULL);
   myInputId ()->setMyBopEntry  (NULL);
@


1.55
log
@[exceptions]
@
text
@d74 1
a74 1
         if (not myApiMgr ()->returningToApp ())
@


1.54
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d74 1
a74 1
         if (not myApiMgr ()->directRetCalled ())
@


1.53
log
@Vector PropRt.
@
text
@a268 16
void WitApiCall::prepObj1Vec (WitAttr theAttr, const WitIVRealArg & theValue)
   {
   callingPrep (theAttr);

   if (not myOptComp ()->myObjFunc1 ()->isChosen ())
      {
      errorFound ();

      myMsgFac () ("reqObj1Smsg", objChoice ()->index ());
      }
   else
      theValue.issueSetDblVecMsg (theAttr, * this);
   }

//------------------------------------------------------------------------------

@


1.52
log
@Attempt to fix syntax errors from the gcc 3.4.1 compiler.
@
text
@d30 1
a30 1
#include <InVecRA.h>
d236 1
a236 1
void WitApiCall::prepDblVec (WitAttr theAttr, const WitInVecRA & theValue)
d245 3
a247 1
void WitApiCall::prepNonNegDblVec (WitAttr theAttr, const WitInVecRA & theValue)
d269 1
a269 1
void WitApiCall::prepObj1Vec (WitAttr theAttr, const WitInVecRA & theValue)
d416 1
a416 1
void WitApiCall::setRoutingShare (const WitInVecRA & theValue)
d442 1
a442 1
void WitApiCall::setOffset (const WitInVecRA & theValue)
d486 4
a489 4
      WitBoundSet *      theBoundSet,
      const WitInVecRA & hardLBArg,
      const WitInVecRA & softLBArg,
      const WitInVecRA & hardUBArg)
d704 1
a704 1
      const WitInVecRA &    theInVecRA)
d706 2
a707 2
   if (theInVecRA != NULL)
      theInVecRA.copyInto (mergedVec);
d901 1
a901 1
void WitOperationApiCall::setYieldRate (const WitInVecRA & theValue)
d927 1
a927 1
void WitOperationApiCall::setCycleTime34 (const WitInVecRA & theValue)
@


1.51
log
@An attempt to fix a syntax error on gcc 3.4.1.
@
text
@d211 5
a215 4
      myMsgFac () (
         "setVecBoolAttrMsg",
         theAttr,
         WitMsgArg (theValue, nPeriods ()));
a221 2
   WitMsgArg theMsgArg (theValue, nPeriods ());

d227 3
d231 1
a235 19
#if 0

void WitApiCall::prepIntVec (WitAttr theAttr, const int * theValue)
   {
   callingPrep (theAttr);

   forbidNullSetArg (theValue);

   if (myMsgFac ().mayIssue ("setVecIntAttrMsg"))
      myMsgFac () (
         "setVecIntAttrMsg",
         theAttr,
         WitMsgArg (theValue, nPeriods ()));
   }

#endif

//------------------------------------------------------------------------------

d307 5
a311 4
         myMsgFac () (
            "setVecIntAttrMsg",
            "buildAheadUB",
            WitMsgArg (theValue, nPeriods ()));
d340 5
a344 4
         myMsgFac () (
            "setVecIntAttrMsg",
            "shipLateUB",
            WitMsgArg (theValue, nPeriods ()));
d549 5
a553 3
      myMsgFac () ("setVecDblAttrMsg",
         theAttr,
         WitMsgArg (theFltCVec, nPeriods ()));
d561 5
a565 3
      myMsgFac () ("setVecDblAttrMsg",
         theAttr,
         WitMsgArg (theDblCVec, nPeriods ()));
d575 12
a586 6
   if (theFltCVec != NULL)
      myMsgFac () (
         "setBoundVecAttrMsg",
         theBoundSet->apiAttr (),
         myMsgFac ().myFrag (theFragID),
         WitMsgArg (theFltCVec, nPeriods ()));
d596 12
a607 6
   if (theDblCVec != NULL)
      myMsgFac () (
         "setBoundVecAttrMsg",
         theBoundSet->apiAttr (),
         myMsgFac ().myFrag (theFragID),
         WitMsgArg (theDblCVec, nPeriods ()));
@


1.50
log
@Initial work on [vector propRouting attribute].
@
text
@d221 16
d248 2
@


1.49
log
@Fixed a bug in the ApiCall dtor in mesgStopRunning = false mode.
@
text
@d204 15
@


1.48
log
@Double Precision.
@
text
@d74 2
a75 1
         witAssert (argsChecked_);
@


1.47
log
@Double Precision.
@
text
@d145 2
a146 2
   if (myMsgFac ().mayIssue ("setFltAttrMsg"))
      myMsgFac () ("setFltAttrMsg", theAttr, oldValue, theValue);
d174 1
a174 1
      myMsgFac () ("fltLowEqSmsg", theValue, msgLB);
d177 2
a178 2
      if (myMsgFac ().mayIssue ("setFltAttrMsg"))
         myMsgFac () ("setFltAttrMsg", theAttr, oldValue, theValue);
d194 1
a194 1
      myMsgFac () ("fltLowSmsg", theValue, 0.0);
d197 2
a198 2
      if (myMsgFac ().mayIssue ("setFltAttrMsg"))
         myMsgFac () ("setFltAttrMsg", theAttr, oldValue, theValue);
d240 1
a240 1
         myMsgFac () ("fltLowEqSmsg", theValue[thePer], 0.0);
d447 1
a447 1
      myMsgFac () ("fltLowEqUpEqSmsg", theValue, 0.0, 0.99);
d450 1
a450 1
      if (myMsgFac ().mayIssue ("setFltAttrMsg"))
d452 1
a452 1
            "setFltAttrMsg", 
d499 1
a499 1
   if (myMsgFac ().mayIssue ("setBoundVecFltAttrMsg"))
d528 2
a529 2
   if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
      myMsgFac () ("setVecFltAttrMsg",
d538 2
a539 2
   if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
      myMsgFac () ("setVecFltAttrMsg",
d552 5
a556 6
      if (myMsgFac ().mayIssue ("setBoundVecFltAttrMsg"))
         myMsgFac () (
            "setBoundVecFltAttrMsg",
            theBoundSet->apiAttr (),
            myMsgFac ().myFrag (theFragID),
            WitMsgArg (theFltCVec, nPeriods ()));
d567 5
a571 6
      if (myMsgFac ().mayIssue ("setBoundVecFltAttrMsg"))
         myMsgFac () (
            "setBoundVecFltAttrMsg",
            theBoundSet->apiAttr (),
            myMsgFac ().myFrag (theFragID),
            WitMsgArg (theDblCVec, nPeriods ()));
@


1.46
log
@Double Precision.
@
text
@a217 63
void WitApiCall::prepDblVec (WitAttr theAttr, const float * theValue)
   {
   callingPrep (theAttr);

   forbidNullSetArg (theValue);

   if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
      myMsgFac () (
         "setVecFltAttrMsg",
         theAttr,
         WitMsgArg (theValue, nPeriods ()));
   }

//------------------------------------------------------------------------------

void WitApiCall::prepNonNegDblVec (WitAttr theAttr, const float * theValue)
   {
   WitPeriod thePer;

   callingPrep (theAttr);

   forbidNullSetArg (theValue);

   forEachPeriod (thePer, myProblem ())
      if (theValue[thePer] < 0.0)
         {
         errorFound (thePer);

         myMsgFac () ("fltLowEqSmsg", theValue[thePer], 0.0);
         }

   if (argsOK_)
      if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
         myMsgFac () (
            "setVecFltAttrMsg",
            theAttr,
            WitMsgArg (theValue, nPeriods ()));
   }

//------------------------------------------------------------------------------

void WitApiCall::prepObj1Vec (WitAttr theAttr, const float * theValue)
   {
   callingPrep (theAttr);

   forbidNullSetArg (theValue);

   if (not myOptComp ()->myObjFunc1 ()->isChosen ())
      {
      errorFound ();

      myMsgFac () ("reqObj1Smsg", objChoice ()->index ());
      }
   else
      if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
         myMsgFac () (
            "setVecFltAttrMsg",
            theAttr,
            WitMsgArg (theValue, nPeriods ()));
   }

//------------------------------------------------------------------------------

@


1.45
log
@Double Precision.
@
text
@d285 1
a285 1
   issueSetDblVecMsg (theAttr, theValue);
d307 1
a307 1
      issueSetDblVecMsg (theAttr, theValue);
d323 1
a323 1
      issueSetDblVecMsg (theAttr, theValue);
d475 1
a475 1
      issueSetDblVecMsg ("routingShare", theValue);
d564 3
a566 3
      issueBoundVecMsg (theBoundSet, hardLBArg, "hardLowerBoundFrag");
      issueBoundVecMsg (theBoundSet, softLBArg, "softLowerBoundFrag");
      issueBoundVecMsg (theBoundSet, hardUBArg, "hardUpperBoundFrag");
d589 52
a710 18
void WitApiCall::issueSetDblVecMsg (
      WitAttr            theAttr,
      const WitInVecRA & theValue)
   {
   WitTVec <float> theFltTVec;

   if (not myMsgFac ().mayIssue ("setVecFltAttrMsg"))
      return;

   theFltTVec.allocate (myProblem (), 0.0);

   theValue.copyInto (theFltTVec);

   myMsgFac () ("setVecFltAttrMsg", theAttr, theFltTVec);
   }

//------------------------------------------------------------------------------

a739 26

void WitApiCall::issueBoundVecMsg (
      const WitBoundSet * theBoundSet,
      const WitInVecRA &  theInVecRA,
      WitMsgFragID        theFragID)
   {
   WitTVec <float> theFltTVec;

   if (theInVecRA == NULL)
      return;

   if (not myMsgFac ().mayIssue ("setBoundVecFltAttrMsg"))
      return;

   theFltTVec.allocate (myProblem (), 0.0);

   theInVecRA.copyInto (theFltTVec);

   myMsgFac () (
      "setBoundVecFltAttrMsg",
      theBoundSet->apiAttr (),
      myMsgFac ().myFrag (theFragID),
      theFltTVec);
   }

//------------------------------------------------------------------------------
d946 1
a946 1
      issueSetDblVecMsg ("yieldRate", theValue);
@


1.44
log
@Double Precision.
@
text
@d670 1
a670 1
   theValue.convCopyInto (theFltTVec);
d700 1
a700 1
      theInVecRA.convCopyInto (mergedVec);
d722 1
a722 1
   theInVecRA.convCopyInto (theFltTVec);
@


1.43
log
@Double Precision.
@
text
@d702 1
a702 1
      mergedVec.copy (oldVec);
@


1.42
log
@Double Precision.
@
text
@d946 1
a946 1
void WitOperationApiCall::setCycleTime34 (const float * theValue)
@


1.41
log
@Double Precision.
@
text
@a140 7
void WitApiCall::prepDouble (WitAttr theAttr, double oldValue, float theValue)
   {
   prepDouble (theAttr, oldValue, dblFromFlt (theValue));
   }

//------------------------------------------------------------------------------

a153 10
      float   theValue)
   {
   prepLBDouble (theAttr, oldValue, theValue, 0.0, 0.0);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepNonNegDouble (
      WitAttr theAttr, 
      double  oldValue,
a163 12
      float   theValue,
      double  lb,
      double  msgLB)
   {
   prepLBDouble (theAttr, oldValue, dblFromFlt (theValue), lb, msgLB);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepLBDouble (
      WitAttr theAttr, 
      double  oldValue, 
a185 10
      float   theValue)
   {
   prepPosDouble (theAttr, oldValue, dblFromFlt (theValue));
   }

//------------------------------------------------------------------------------

void WitApiCall::prepPosDouble (
      WitAttr theAttr,
      double  oldValue,
d502 1
a502 1
void WitApiCall::setFalloutRate (float theValue)
d521 1
a521 1
      myConsEntry ()->setFalloutRate (dblFromFlt (theValue));
@


1.40
log
@Double Precision.
@
text
@d335 1
a335 1
   forbidNullSetArg (theValue.asaTlPtr ());
d502 1
a502 1
   forbidNullSetArg (theValue.asaTlPtr ());
d738 1
a738 1
   if (theInVecRA.asaTlPtr () != NULL)
d753 1
a753 1
   if (theInVecRA.asaTlPtr () == NULL)
d965 1
a965 1
   forbidNullSetArg (theValue.asaTlPtr ());
@


1.39
log
@Double Precision.
@
text
@a958 30
void WitOperationApiCall::setYieldRate (const float * theValue)
   {
   WitPeriod thePer;

   callingPrep ("yieldRate");

   forbidNullSetArg (theValue);

   forEachPeriod (thePer, myProblem ())
      if (not WitOperation::validYieldRate (theValue[thePer]))
         {
         errorFound (thePer);

         myMsgFac () ("yieldRateRangeSmsg", theValue[thePer]);
         }

   if (argsOK ())
      {
      if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
         myMsgFac () (
            "setVecFltAttrMsg",
            "yieldRate",
            WitMsgArg (theValue, nPeriods ()));

      myOperation_->setYieldRate (theValue);
      }
   }

//------------------------------------------------------------------------------

a989 16

   if (not wit34Compatible ())
      myMsgFac () ("settingCycleTime34WithoutCompatibility",
         myApiMgr ()->apiFuncName ());

   if (argsOK ())
      myOperation_->setCycleTime34 (theValue);
   }

//------------------------------------------------------------------------------

void WitOperationApiCall::setCycleTime34 (const WitInVecRA & theValue)
   {
   callingPrep ("cycleTime34");

   forbidNullSetArg (theValue.asaTlPtr ());
@


1.38
log
@Double Precision.
@
text
@d496 1
a496 1
void WitApiCall::setRoutingShare (const float * theValue)
d502 1
a502 1
   forbidNullSetArg (theValue);
d514 1
a514 5
      if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
         myMsgFac () (
            "setVecFltAttrMsg",
            "routingShare",
            WitMsgArg (theValue, nPeriods ()));
d522 1
a522 1
void WitApiCall::setOffset (const float * theValue)
d989 26
d1020 16
@


1.37
log
@Double Precision.
@
text
@d257 1
a257 1
void WitApiCall::prepFloatVec (WitAttr theAttr, const float * theValue)
d272 1
a272 1
void WitApiCall::prepNonNegFloatVec (WitAttr theAttr, const float * theValue)
d335 1
a335 1
   forbidNullSetArg (theValue.myUnderArgAsTlPtr ());
d531 1
a531 1
      prepFloatVec ("offset", theValue);
d742 1
a742 1
   if (theInVecRA.myUnderArgAsTlPtr () != NULL)
d757 1
a757 1
   if (theInVecRA.myUnderArgAsTlPtr () == NULL)
@


1.36
log
@Double Precision.
@
text
@a569 48
      WitBoundSet * theBoundSet,
      const float * hardLBArg,
      const float * softLBArg,
      const float * hardUBArg)
   {
   WitPeriod     thePer;

   WitDblFlexVec hardLBMrg (myProblem (), 0.0);
   WitDblFlexVec softLBMrg (myProblem (), 0.0);
   WitDblFlexVec hardUBMrg (myProblem (), 0.0);
      //
      // The merged values to which theBoundSet's vectors are to be set.

   callingPrep (theBoundSet->apiAttr ());

   mergeBoundVecs (hardLBMrg, theBoundSet->hardLB (), hardLBArg);
   mergeBoundVecs (softLBMrg, theBoundSet->softLB (), softLBArg);
   mergeBoundVecs (hardUBMrg, theBoundSet->hardUB (), hardUBArg);

      // Check for errors.
      //
   forEachPeriod (thePer, myProblem ())
      if (WitBoundSet::seqError (hardLBMrg, softLBMrg, hardUBMrg, thePer))
         {
         errorFound (thePer);

         myMsgFac () ("boundSetRangeSmsg", 
            hardLBMrg[thePer],
            softLBMrg[thePer],
            hardUBMrg[thePer]);
         }

   if (not argsOK ())
      return;

   if (myMsgFac ().mayIssue ("setBoundVecFltAttrMsg"))
      {
      issueBoundVecMsg (theBoundSet, hardLBArg, "hardLowerBoundFrag");
      issueBoundVecMsg (theBoundSet, softLBArg, "softLowerBoundFrag");
      issueBoundVecMsg (theBoundSet, hardUBArg, "hardUpperBoundFrag");
      }

   theBoundSet->set (hardLBMrg, softLBMrg, hardUBMrg);
   }

//------------------------------------------------------------------------------

void WitApiCall::setBoundSet (
a582 6
   stronglyAssert (false);
      //
      // This function doesn't work correctly yet:
      // The ctors for class InVecRA don't tolerate NULL pointers, which are
      // legitimate for BoundSets.

a739 13
      const float *         newCVec)
   {
   if (newCVec == NULL)
      mergedVec.copy     (oldVec);
   else
      mergedVec.convCopy (newCVec);
   }

//------------------------------------------------------------------------------

void WitApiCall::mergeBoundVecs (
      WitDblFlexVec &       mergedVec,
      const WitDblFlexVec & oldVec,
a745 15
   }

//------------------------------------------------------------------------------

void WitApiCall::issueBoundVecMsg (
      const WitBoundSet * theBoundSet,
      const float *       theCVec,
      WitMsgFragID        theFragID)
   {
   if (theCVec != NULL)
      myMsgFac () (
         "setBoundVecFltAttrMsg",
         theBoundSet->apiAttr (),
         myMsgFac ().myFrag (theFragID),
         WitMsgArg (theCVec, nPeriods ()));
@


1.35
log
@Double Precision.
@
text
@d617 54
d804 13
d828 26
@


1.34
log
@Double Precision.
@
text
@a430 55
void WitApiCall::prepBoundSet (
      const WitBoundSet * theBoundSet,
      const float *       hardLBval,
      const float *       softLBval,
      const float *       hardUBval)
   {
   WitPeriod thePer;

   callingPrep (theBoundSet->apiAttr ());

      // Check for errors.
      //
   forEachPeriod (thePer, myProblem ())
      if (theBoundSet->seqError (hardLBval, softLBval, hardUBval, thePer))
         {
         errorFound (thePer);

         myMsgFac () ("boundSetRangeSmsg", 
            WitBoundSet::elem (theBoundSet->hardLB (), hardLBval, thePer),
            WitBoundSet::elem (theBoundSet->softLB (), softLBval, thePer),
            WitBoundSet::elem (theBoundSet->hardUB (), hardUBval, thePer));
         }

   if (not argsOK_)
      return;

   if (not myMsgFac ().mayIssue ("setBoundVecFltAttrMsg"))
      return;

      // Display the bound set values.
      //
   if (hardLBval != NULL)
      myMsgFac () (
         "setBoundVecFltAttrMsg",
         theBoundSet->apiAttr (),
         myMsgFac ().myFrag ("hardLowerBoundFrag"),
         WitMsgArg (hardLBval, nPeriods ()));

   if (softLBval != NULL)
      myMsgFac () (
         "setBoundVecFltAttrMsg",
         theBoundSet->apiAttr (),
         myMsgFac ().myFrag ("softLowerBoundFrag"),
         WitMsgArg (softLBval, nPeriods ()));

   if (hardUBval != NULL)
      myMsgFac () (
         "setBoundVecFltAttrMsg",
         theBoundSet->apiAttr (),
         myMsgFac ().myFrag ("hardUpperBoundFrag"),
         WitMsgArg (hardUBval, nPeriods ()));
   }

//------------------------------------------------------------------------------

d569 48
d733 28
@


1.33
log
@Double Precision.
@
text
@a78 14
#if 0

void WitApiCall::prepBool (WitAttr theAttr, bool oldValue, bool theValue)
   {
   callingPrep (theAttr);

   if (myMsgFac ().mayIssue ("setBooleanAttrMsg"))
      myMsgFac () ("setBooleanAttrMsg", theAttr, oldValue, theValue);
   }

#endif

//------------------------------------------------------------------------------

d516 1
a516 1
      myDelComp ()->setSelForDel (theValue);
@


1.32
log
@Double Precision.
@
text
@d79 2
d89 12
d525 1
a525 1
void WitApiCall::setSelForDel (bool theValue)
d857 4
a860 4
      WitAttr theAttr,
      bool    oldValue,
      bool    theValue,
      WitAttr otherAttr)
@


1.31
log
@Double Precision.
@
text
@d298 31
d331 1
a331 2
   WitTVec <float> theFltTVec (myProblem (), 0.0);
   WitPeriod       thePer;
d346 1
a346 6
      if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
         {
         theValue.convCopyInto (theFltTVec);

         myMsgFac () ("setVecFltAttrMsg", theAttr, theFltTVec);
         }
d351 1
a351 1
void WitApiCall::prepObj1Vec (WitAttr theAttr, const float * theValue)
a354 2
   forbidNullSetArg (theValue);

d362 1
a362 5
      if (myMsgFac ().mayIssue ("setVecFltAttrMsg"))
         myMsgFac () (
            "setVecFltAttrMsg",
            theAttr,
            WitMsgArg (theValue, nPeriods ()));
d705 18
@


1.30
log
@Double Precision.
@
text
@d30 1
d294 28
@


1.29
log
@Continued double precision.
@
text
@d142 1
a142 1
   prepDouble (theAttr, oldValue, doubleFromFloat (theValue));
d184 1
a184 1
   prepLBDouble (theAttr, oldValue, doubleFromFloat (theValue), lb, msgLB);
d216 1
a216 1
   prepPosDouble (theAttr, oldValue, doubleFromFloat (theValue));
d571 1
a571 1
      myConsEntry ()->setFalloutRate (doubleFromFloat (theValue));
@


1.28
log
@Continued double precision.
@
text
@d142 1
a142 1
   prepDouble (theAttr, oldValue, static_cast <double> (theValue));
d167 22
d191 4
a194 4
      double oldValue, 
      float  theValue,
      double lb,
      double msgLB)
d216 10
d571 1
a571 1
      myConsEntry ()->setFalloutRate (static_cast <double> (theValue));
@


1.27
log
@Continued double precision.
@
text
@d142 7
@


1.26
log
@Continued double precision.
@
text
@d140 1
a140 1
void WitApiCall::prepStrDbl (WitAttr theAttr, StrDbl oldValue, float theValue)
d150 1
a150 1
void WitApiCall::prepNonNegStrDbl (
d152 1
a152 1
      StrDbl  oldValue,
d155 1
a155 1
   prepLBStrDbl (theAttr, oldValue, theValue, 0.0, 0.0);
d160 1
a160 1
void WitApiCall::prepLBStrDbl (
d162 1
a162 1
      StrDbl oldValue, 
d164 2
a165 2
      StrDbl lb,
      StrDbl msgLB)
d182 1
a182 1
void WitApiCall::prepPosStrDbl (
d184 1
a184 1
      StrDbl  oldValue,
d532 1
a532 1
      myConsEntry ()->setFalloutRate (StrDbl::convFloat (theValue));
@


1.25
log
@Continued double precision.
@
text
@a139 59
void WitApiCall::prepFloat (WitAttr theAttr, float oldValue, float theValue)
   {
   callingPrep (theAttr);

   if (myMsgFac ().mayIssue ("setFltAttrMsg"))
      myMsgFac () ("setFltAttrMsg", theAttr, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepNonNegFloat (
      WitAttr theAttr, 
      float   oldValue,
      float   theValue)
   {
   prepLBFloat (theAttr, oldValue, theValue, 0.0, 0.0);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepLBFloat (
      WitAttr theAttr, 
      float oldValue, 
      float theValue,
      float lb,
      float msgLB)
   {
   callingPrep (theAttr);

   if (theValue < lb)
      {
      errorFound ();

      myMsgFac () ("fltLowEqSmsg", theValue, msgLB);
      }
   else
      if (myMsgFac ().mayIssue ("setFltAttrMsg"))
         myMsgFac () ("setFltAttrMsg", theAttr, oldValue, theValue);
   }

//------------------------------------------------------------------------------

void WitApiCall::prepPosFloat (WitAttr theAttr, float oldValue, float theValue)
   {
   callingPrep (theAttr);

   if (theValue <= 0.0)
      {
      errorFound ();

      myMsgFac () ("fltLowSmsg", theValue, 0.0);
      }
   else
      if (myMsgFac ().mayIssue ("setFltAttrMsg"))
         myMsgFac () ("setFltAttrMsg", theAttr, oldValue, theValue);
   }

//------------------------------------------------------------------------------

@


1.24
log
@Continued double precision.
@
text
@d241 20
d591 1
a591 1
      myConsEntry ()->setFalloutRate (theValue);
@


1.23
log
@Continued double precision.
@
text
@d199 1
a199 1
void WitApiCall::prepDouble (WitAttr theAttr, double oldValue, float theValue)
d204 1
a204 1
      myMsgFac () ("setFltAttrMsg",theAttr, oldValue, theValue);
d209 1
a209 1
void WitApiCall::prepNonNegDouble (
d211 1
a211 1
      double  oldValue,
d214 1
a214 1
   prepLBDouble (theAttr, oldValue, theValue, 0.0, 0.0);
d219 1
a219 1
void WitApiCall::prepLBDouble (
d221 1
a221 1
      double oldValue, 
d223 2
a224 2
      double lb,
      double msgLB)
@


1.22
log
@Continued double precision.
@
text
@d209 32
@


1.21
log
@Changed the routingShare attributes from scalars to vectors.
@
text
@d199 10
@


1.20
log
@Continued implementation of proportionate routing.
@
text
@d461 1
a461 1
void WitApiCall::setRoutingShare (float theValue)
d463 2
d467 6
a472 3
   if (theValue < 1.0 - FLOAT_EPSILON)
      {
      errorFound ();
d474 2
a475 2
      myMsgFac () ("routingShareRangeSmsg", theValue);
      }
d479 3
a481 2
      if (myMsgFac ().mayIssue ("setFltAttrMsg"))
         myMsgFac () ("setFltAttrMsg",
d483 1
a483 2
            myBillEntry ()->routingShare (), 
            theValue);
@


1.19
log
@Continued implementation of proportionate routing.
@
text
@d461 1
a461 1
void WitApiCall::setExpShare (float theValue)
d463 1
a463 1
   callingPrep ("expShare");
d469 1
a469 1
      myMsgFac () ("expShareRangeSmsg", theValue);
d476 2
a477 2
            "expShare",
            myBillEntry ()->expShare (), 
d480 1
a480 1
      myBillEntry ()->setExpShare (theValue);
@


1.18
log
@Continued implementation of proportionate routing.
@
text
@d461 25
a1009 25
   }

//------------------------------------------------------------------------------

void WitBopEntryApiCall::setExpShare (float theValue)
   {
   callingPrep ("expShare");

   if (theValue < 1.0 - FLOAT_EPSILON)
      {
      errorFound ();

      myMsgFac () ("expShareRangeSmsg", theValue);
      }

   if (argsOK ())
      {
      if (myMsgFac ().mayIssue ("setFltAttrMsg"))
         myMsgFac () ("setFltAttrMsg",
            "expShare",
            myBopEnt_->expShare (), 
            theValue);

      myBopEnt_->setExpShare (theValue);
      }
@


1.17
log
@Continued implementation of proportionate routing.
@
text
@d993 3
a995 4
   if (theValue != 0.0)
      if (theValue < 1.0 - FLOAT_EPSILON)
         {
         errorFound ();
d997 2
a998 2
         myMsgFac () ("expShareRangeSmsg", theValue);
         }
@


1.16
log
@Began implementation of Proportionate Routing.
@
text
@d989 1
a989 1
void WitBopEntryApiCall::setExpFactor (float theValue)
d991 1
a991 4
   callingPrep ("expFactor");

   if (not myGlobalComp ()->allowPR ())
      myMsgFac () ("propRoutingNYISmsg");
d994 1
a994 1
      if (theValue < 0.01 - FLOAT_EPSILON)
d998 1
a998 1
         myMsgFac () ("expFactorRangeSmsg", theValue);
d1005 2
a1006 2
            "expFactor",
            myBopEnt_->expFactor (), 
d1009 1
a1009 1
      myBopEnt_->setExpFactor (theValue);
@


1.15
log
@Internal changes.
@
text
@d989 29
@


1.14
log
@Internal changes.
@
text
@d127 1
a127 1
   if ((theValue < lb) || (theValue > ub))
d261 1
a261 1
   if (! myOptComp ()->myObjFunc1 ()->isChosen ())
d364 1
a364 1
   if (! argsOK_)
d367 1
a367 1
   if (! myMsgFac ().mayIssue ("setBoundVecFltAttrMsg"))
d484 1
a484 1
   if ((theValue < 0.0) || (theValue > 0.99 + FLOAT_EPSILON))
d596 1
a596 1
      if ((theValue[thePer] < 0) || (theValue[thePer] > lastPeriod ()))
d712 1
a712 1
   if (! oldValue)
d714 1
a714 1
         if (myMaterial_->buildNstn () || myMaterial_->buildAsap ())
d802 1
a802 1
      if (! WitOperation::validYieldRate (theValue[thePer]))
d829 1
a829 1
   if (! wit34Compatible ())
@


1.13
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d58 3
a60 3
      argsOK_      (witTRUE),
      prepCalled_  (witFALSE),
      argsChecked_ (witFALSE)
d78 1
a78 4
void WitApiCall::prepBoolean (
      WitAttr      theAttr,
      WitBoolean   oldValue,
      WitBoolean   theValue)
d421 1
a421 1
void WitApiCall::setSelForDel (WitBoolean theValue)
d423 1
a423 1
   prepBoolean ("selForDel", myDelComp ()->selForDel (), theValue);
d521 1
a521 1
   stronglyAssert (witFALSE);
d530 1
a530 1
   stronglyAssert (witFALSE);
d539 1
a539 1
   stronglyAssert (witFALSE);
d548 1
a548 1
   stronglyAssert (witFALSE);
d574 1
a574 1
   argsOK_ = witFALSE;
d582 1
a582 1
      prepCalled_ = witTRUE;
d705 4
a708 4
      WitAttr    theAttr,
      WitBoolean oldValue,
      WitBoolean theValue,
      WitAttr    otherAttr)
d710 1
a710 1
   prepBoolean (theAttr, oldValue, theValue);
d716 1
a716 1
               myMsgFac () ("setBooleanAttrMsg", otherAttr, witTRUE, witFALSE);
@


1.12
log
@Continued implementation of single-source.
@
text
@d32 6
d39 1
@


1.11
log
@Began implementation of object iteration.
@
text
@d34 1
d372 1
a372 1
         myMsgFac ()["hardLowerBoundFrag"],
d379 1
a379 1
         myMsgFac ()["softLowerBoundFrag"],
d386 1
a386 1
         myMsgFac ()["hardUpperBoundFrag"],
@


1.10
log
@Continued implementation of sel-split for pen-exec.
@
text
@d32 3
@


1.9
log
@Refactoring for constrained stock reallocation.
@
text
@d513 1
a513 1
   myMsgFac () ("internalErrorFmsg", "WitApiCall::myComponent");
d522 1
a522 1
   myMsgFac () ("internalErrorFmsg", "WitApiCall::myDelComp");
d531 1
a531 1
   myMsgFac () ("internalErrorFmsg", "WitApiCall::myBillEntry");
d540 1
a540 1
   myMsgFac () ("internalErrorFmsg", "WitApiCall::myConsEntry");
@


1.8
log
@Continued development of selection splitting for multi=exec.
@
text
@d615 1
a615 1
   return (* this) ();
d637 1
a637 1
   return (* this) ();
d662 1
a662 1
   return (* this) ();
d669 1
a669 1
   return (* this) ();
d715 1
a715 1
   return (* this) ();
d722 1
a722 1
   return (* this) ();
d752 1
a752 1
   return (* this) ();
d759 1
a759 1
   return (* this) ();
d809 1
a809 1
      (* this) ()->setYieldRate (theValue);
d826 1
a826 1
      (* this) ()->setCycleTime34 (theValue);
d833 1
a833 1
   return (* this) ();
d840 1
a840 1
   return (* this) ();
d872 1
a872 1
   return (* this) ();
d879 1
a879 1
   return (* this) ();
d886 1
a886 1
   return (* this) ();
d893 1
a893 1
   return (* this) ();
d930 1
a930 1
   return (* this) ();
d937 1
a937 1
   return (* this) ();
d944 1
a944 1
   return (* this) ();
d951 1
a951 1
   return (* this) ();
d983 1
a983 1
   return (* this) ();
d990 1
a990 1
   return (* this) ();
d997 1
a997 1
   return (* this) ();
@


1.7
log
@Re-worked the controls for selection splitting.
@
text
@d852 1
a852 1
      WitApiCall  (theWitRun),
d854 1
a854 1
      myBomEntry_ (NULL)
d856 1
a856 1
   myBomEntry_ =
d906 1
a906 1
      WitApiCall  (theWitRun),
d908 1
a908 1
      mySubEntry_ (NULL)
d910 1
a910 1
   mySubEntry_ =
d963 1
a963 1
      WitApiCall  (theWitRun),
d965 1
a965 1
      myBopEntry_ (NULL)
d967 1
a967 1
   myBopEntry_ =
@


1.6
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@a712 34
void WitMaterialApiCall::setBaSplitRes (float theValue)
   {
   callingPrep ("baSplitRes");

   if (! myGlobalComp ()->allowSS ())
      {
      errorFound ();

      myMsgFac () ("splitResWoAllowSSSmsg", "baSplitRes");
      }

   if (theValue != 0.0)
      if (theValue < 0.999)
         {
         errorFound ();

         myMsgFac () ("baSplitResRangeSmsg", theValue);
         }

   if (argsOK ())
      {
      if (myMsgFac ().mayIssue ("setFltAttrMsg"))
         myMsgFac () (
            "setFltAttrMsg", 
            "baSplitRes", 
            myMaterial_->baSplitRes (), 
            theValue);

      myMaterial_->setBaSplitRes (theValue);
      }
   }

//------------------------------------------------------------------------------

@


1.5
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d677 3
a679 2
         WitRun *     theWitRun,
         const char * partName):
d683 1
a683 1
      myMaterial_ (theWitRun->setGetMaterialInit (partName))
@


1.4
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d712 34
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@a471 10
void WitApiCall::setUsageRate (float theValue)
   {
   prepFloat ("usageRate", myConsEntry ()->usageRate (), theValue);

   if (argsOK ())
      myConsEntry ()->setUsageRate (theValue);
   }

//------------------------------------------------------------------------------

@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d445 1
a445 1
      nPeriods () - 1);
d598 1
a598 1
      if ((theValue[thePer] < 0) || (theValue[thePer] > nPeriods () - 1))
d602 1
a602 1
         myMsgFac () ("intLowEqUpEqSmsg", theValue[thePer], 0, nPeriods () - 1);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

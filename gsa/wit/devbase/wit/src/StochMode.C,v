head	1.107;
access;
symbols
	sce_5_01_20080919:1.90;
locks; strict;
comment	@ * @;


1.107
date	2011.09.28.23.50.33;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2011.09.24.00.28.48;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2011.08.30.20.18.17;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2011.08.25.23.27.08;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2011.03.03.23.24.07;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2011.01.07.20.19.35;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2011.01.06.00.08.26;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.12.03.21.45.42;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2010.10.12.19.48.28;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.18.22.46.35;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.05.21.18.17.57;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.05.21.15.28.01;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2010.05.20.23.39.49;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2010.05.14.23.49.06;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2010.03.16.22.42.29;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.17.23.45.48;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2008.11.20.16.04.52;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2008.03.01.00.01.04;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2008.02.08.21.38.33;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2008.01.29.23.51.49;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2008.01.25.00.19.23;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.21.21.47.17;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.18.22.40.59;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2008.01.14.21.44.02;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2008.01.14.19.21.15;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2008.01.09.20.28.23;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.09.19.35.48;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.08.20.44.22;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.08.19.57.24;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.08.17.20.39;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.07.23.51.50;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.04.20.25.28;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.12.28.23.45.47;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.12.28.18.29.19;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.12.19.21.10.18;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.12.05.22.13.09;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.12.03.19.41.34;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.11.29.21.12.32;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.29.19.18.04;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.11.29.16.24.43;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.29.15.35.02;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.28.23.23.50;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.27.21.05.02;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.26.23.15.18;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.22.19.58.53;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.22.19.20.38;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.22.18.53.59;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.17.20.08.33;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.16.20.58.20;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.15.21.50.35;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.11.19.16.57;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.08.18.56.36;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.28.23.32.58;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.28.22.08.27;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.27.19.57.41;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.27.18.25.10;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.26.22.52.52;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.25.21.03.05;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.21.23.06.09;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.20.20.58.26;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.20.18.46.17;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.19.22.39.54;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.19.21.35.41;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.19.14.23.26;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.17.14.37.39;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.14.21.13.59;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.14.15.44.41;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.12.21.55.01;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.11.18.09.18;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.10.21.01.35;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.06.18.59.14;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.04.19.22.09;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.04.18.10.09;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.30.19.39.02;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.30.17.34.35;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.29.16.24.24;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.28.17.38.35;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.24.21.12.38;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.17.22.32.24;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.17.21.47.43;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.14.21.20.19;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.09.22.29.08;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.08.20.18.12;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.07.19.17.44;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.01.22.41.59;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.01.21.28.06;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.21.22.05.20;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.21.18.49.19;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.21.18.25.44;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.20.22.41.39;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.20.22.10.27;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.20.19.38.51;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.20.19.07.53;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.19.21.45.51;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.18.22.28.42;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.18.19.53.33;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.18.17.42.17;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.15.23.02.20;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.15.22.15.26;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.15.19.08.35;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.14.22.08.53;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.14.21.38.32;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.14.16.09.36;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.13.23.12.32;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.11.21.04.27;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.08.22.47.02;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.107
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "StochMode.C"
//
// Contains the implementation of the following classes:
//
//    StochModeMgr
//    StochAssoc
//    StochAttMgr
//    StochAtt
//------------------------------------------------------------------------------

#include <StochAttMgr.h>
#include <StochAtt.h>
#include <StageMgr.h>
#include <ScenMgr.h>
#include <ScenAttMgr.h>
#include <ScenInputAtt.h>
#include <Scenario.h>
#include <StochImpMgr.h>
#include <StochOptMgr.h>
#include <Post.h>
#include <OptStarter.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <CompMgr.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class StochModeMgr.
//------------------------------------------------------------------------------

WitStochModeMgr::WitStochModeMgr (WitProblem * theProblem):

      WitProbAssoc   (theProblem),

      myStochAttMgr_ (NULL),
      myStageMgr_    (NULL),
      myScenMgr_     (NULL),
      myScenAttMgr_  (NULL),
      myStochOptMgr_ (NULL),
      uploadingData_ (false),
      stochSolnMode_ (false),
      clearingSoln_  (false)
   {
   myMsgFac () ("enterStochModeMsg");

   validateCoreData ();

   myStochAttMgr_ = new WitStochAttMgr       (this);
   myScenMgr_     = new WitScenMgr           (this);
   myScenAttMgr_  = new WitScenAttMgr        (this);

   myStageMgr_    = WitStageMgr::newStageMgr (this);
   }

//------------------------------------------------------------------------------

WitStochModeMgr::~WitStochModeMgr ()
   {
   if (stochSolnMode_)
      clearSoln ();

   myMsgFac () ("leaveStochModeMsg");

   delete myStageMgr_;
   delete myScenAttMgr_;
   delete myScenMgr_;
   delete myStochAttMgr_;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::copyAttrsFrom (WitStochModeMgr * theStochModeMgr)
   {
   myStageMgr_  ->copyAttrsFrom (theStochModeMgr->myStageMgr_);
   myScenMgr_   ->copyAttrsFrom (theStochModeMgr->myScenMgr_);
   myScenAttMgr_->copyInputFrom (theStochModeMgr->myScenAttMgr_);
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::uploadInput ()
   {
   uploadingData_ = true;

   myScenAttMgr_->uploadInput ();

   uploadingData_ = false;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::uploadSoln ()
   {
   uploadingData_ = true;

   myScenAttMgr_->uploadSoln ();

   uploadingData_ = false;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::implode ()
   {
   stronglyAssert (myStochOptMgr_ == NULL);

   myStochOptMgr_ = new WitStochOptMgr (this);

   myStochOptMgr_->implode ();

   delete myStochOptMgr_;

   myStochOptMgr_ = NULL;

   stochSolnMode_ = true;

   myMsgFac () ("enterStochSolnModeMsg");
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::clearSoln ()
   {
   stronglyAssert (stochSolnMode_);

   myMsgFac () ("leaveStochSolnModeMsg");

   stochSolnMode_ = false;

   myScenAttMgr_->clearSoln ();

   clearCompSoln ();
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::clearCompSoln ()
   {
   WitComponent * theComp;

   myPostprocessor ()->unpostprocess ();

   clearingSoln_ = true;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->clearStochSoln ();

   clearingSoln_ = false;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::passObjValue (double theValue)
   {
   witAssert (myStochOptMgr ()->uploadingSoln ());

   uploadingData_ = true;

   myOptComp ()->storeStochObjValue (theValue);

   uploadingData_ = false;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::passBoundsValue (double theValue)
   {
   witAssert (myStochOptMgr ()->uploadingSoln ());

   uploadingData_ = true;

   myOptComp ()->storeStochBoundsValue (theValue);

   uploadingData_ = false;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::validateCoreData ()
   {
   verifyGlobalBool (  "computeCriticalList", 
      myGlobalComp  ()->computeCriticalList (), false);

   verifyGlobalBool (  "compPrices",
      myOptComp     ()->compPrices          (), false);

   verifyGlobalBool (  "accAfterOptImp",
      myOptComp     ()->accAfterOptImp      (), false);

   verifyGlobalBool (  "accAfterSoftLB",
      myOptComp     ()->accAfterSoftLB      (), false);

   verifyGlobalBool (  "mipMode",
      myOptComp     ()->mipMode             (), false);

   if (myCompMgr ()->nParts () == 0)
      myMsgFac () ("noPartsStochModeSmsg");
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::verifyGlobalBool (
      const char * theAttName,
      bool         theVal,
      bool         reqVal)
   {
   if (theVal != reqVal)
      myMsgFac () ("invBoolAttStochModeSmsg", theAttName, reqVal);
   }

//------------------------------------------------------------------------------
// Implementation of class StochAssoc.
//------------------------------------------------------------------------------

WitStochAssoc::WitStochAssoc (WitStochModeMgr * theStochModeMgr):
                        
      WitProbAssoc    (theStochModeMgr),
      myStochModeMgr_ (theStochModeMgr)
   {
   }

//------------------------------------------------------------------------------

WitStochAssoc::WitStochAssoc (WitStochAssoc * theStochAssoc):
                        
      WitProbAssoc    (theStochAssoc),
      myStochModeMgr_ (theStochAssoc->myStochModeMgr_)
   {
   }

//------------------------------------------------------------------------------

WitStochAssoc::~WitStochAssoc ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class StochAttMgr.
//------------------------------------------------------------------------------

WitStochAttMgr::WitStochAttMgr (WitStochModeMgr * theStochModeMgr):

      WitStochAssoc   (theStochModeMgr),
      myStochAttMap_  (),
      cachedStochAtt_ (NULL)
   {
   makeStochAtts ();
   }

//------------------------------------------------------------------------------

WitStochAttMgr::~WitStochAttMgr ()
   {
   WitStochAtt * theStochAtt;

   while (not myStochAttMap_.empty ())
      {
      theStochAtt = myStochAttMap_.begin ()->second;

      myStochAttMap_.erase (myStochAttMap_.begin ());

      delete theStochAtt;
      }
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::makeScenInputStochAtt (
      const char *         theName,
      WitAbsScenInputAtt * theAbsScenInputAtt)
   {
   makeStochAtt (theName, theAbsScenInputAtt);

   findStochAtt (theName)->setIsScenSpec        (true);
   findStochAtt (theName)->setCanSetInStochMode (true);
   findStochAtt (theName)->setCanSetInSolnMode  (false);
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::makeScenSolnStochAtt (const char * theName)
   {
   makeStochAtt (theName);
   findStochAtt (theName)->setIsScenSpec        (true);
   findStochAtt (theName)->setCanSetInStochMode (false);
   findStochAtt (theName)->setCanSetInSolnMode  (false);
   }

//------------------------------------------------------------------------------

bool WitStochAttMgr::valueOf (
      bool (WitStochAtt::* theAccFunc) () const, 
      const char *         theAttName)
   {
   WitStochAtt * theStochAtt;

   theStochAtt = findStochAtt (theAttName);

   if (theStochAtt == NULL)
      return false;
   else
      return (theStochAtt->*theAccFunc) ();
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::prepSetStochModeAttr (const char * theAttName)
   {
   WitStochAtt * theStochAtt;

   theStochAtt = findStochAtt (theAttName);

   stronglyAssert (theStochAtt != NULL);

   stronglyAssert (theStochAtt->canSetInStochMode ());

   if (stochSolnMode ())
      stronglyAssert (theStochAtt->canSetInSolnMode ());

   stronglyAssert (theStochAtt->myAbsScenInputAtt () == NULL);
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::prepSetScenSpecAttr (
      const char * theAttName,
      WitDelComp * theDelComp)
   {
   WitStochAtt *        theStochAtt;
   WitAbsScenInputAtt * theAbsScenInputAtt;

   stronglyAssert (not stochSolnMode ());

   theStochAtt = findStochAtt (theAttName);

   stronglyAssert (theStochAtt != NULL);

   theAbsScenInputAtt = theStochAtt->myAbsScenInputAtt ();

   stronglyAssert (theAbsScenInputAtt != NULL);

   theAbsScenInputAtt->prepSet (theDelComp);
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::prepSetBoundSet (WitBoundSet * theBoundSet)
   {
   prepSetBoundSetAttr ("hardLB", theBoundSet);
   prepSetBoundSetAttr ("softLB", theBoundSet);
   prepSetBoundSetAttr ("hardUB", theBoundSet);
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::prepSetBoundSetAttr (
      const char *  theAttName,
      WitBoundSet * theBoundSet)
   {
   WitStochAtt *        theStochAtt;
   WitAbsScenInputAtt * theAbsScenInputAtt;

   theStochAtt = findStochAtt (theAttName);

   stronglyAssert (theStochAtt != NULL);

   stronglyAssert (not stochSolnMode ());

   theAbsScenInputAtt = theStochAtt->myAbsScenInputAtt ();

   stronglyAssert (theAbsScenInputAtt != NULL);

   theAbsScenInputAtt->prepSet (theBoundSet);
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::makeStochAtts ()
   {
   makeStochAtt ("probability"    );
   findStochAtt ("probability"    )->setIsScenSpec        (true);
   findStochAtt ("probability"    )->setCanSetInStochMode (true);
   findStochAtt ("probability"    )->setCanSetInSolnMode  (false);

   makeStochAtt ("objectStage"    );
   findStochAtt ("objectStage"    )->setIsScenSpec        (false);
   findStochAtt ("objectStage"    )->setCanSetInStochMode (true);
   findStochAtt ("objectStage"    )->setCanSetInSolnMode  (false);

   makeStochAtt ("periodStage"    );
   findStochAtt ("periodStage"    )->setIsScenSpec        (false);
   findStochAtt ("periodStage"    )->setCanSetInStochMode (true);
   findStochAtt ("periodStage"    )->setCanSetInSolnMode  (false);

   makeStochAtt ("stochMode"      );
   findStochAtt ("stochMode"      )->setIsScenSpec        (false);
   findStochAtt ("stochMode"      )->setCanSetInStochMode (true);
   findStochAtt ("stochMode"      )->setCanSetInSolnMode  (true);

   makeStochAtt ("currentScenario");
   findStochAtt ("currentScenario")->setIsScenSpec        (false);
   findStochAtt ("currentScenario")->setCanSetInStochMode (true);
   findStochAtt ("currentScenario")->setCanSetInSolnMode  (true);

   makeStochAtt ("appData"        );
   findStochAtt ("appData"        )->setIsScenSpec        (false);
   findStochAtt ("appData"        )->setCanSetInStochMode (true);
   findStochAtt ("appData"        )->setCanSetInSolnMode  (true);

   makeStochAtt ("stockBounds"    );
   findStochAtt ("stockBounds"    )->setIsScenSpec        (true);
   findStochAtt ("stockBounds"    )->setCanSetInStochMode (true);
   findStochAtt ("stockBounds"    )->setCanSetInSolnMode  (false);

   makeStochAtt ("cumShipBounds"  );
   findStochAtt ("cumShipBounds"  )->setIsScenSpec        (true);
   findStochAtt ("cumShipBounds"  )->setCanSetInStochMode (true);
   findStochAtt ("cumShipBounds"  )->setCanSetInSolnMode  (false);

   makeStochAtt ("execBounds"     );
   findStochAtt ("execBounds"     )->setIsScenSpec        (true);
   findStochAtt ("execBounds"     )->setCanSetInStochMode (true);
   findStochAtt ("execBounds"     )->setCanSetInSolnMode  (false);
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::makeStochAtt (const char * theName)
   {
   makeStochAtt (theName, NULL);
   }

//------------------------------------------------------------------------------

void WitStochAttMgr::makeStochAtt (
      const char *         theName,
      WitAbsScenInputAtt * theAbsScenInputAtt)
   {
   WitStochAtt * theStochAtt;
   const char *  storedName;

   stronglyAssert (findStochAtt (theName) == NULL);

   theStochAtt                = new WitStochAtt (theName, theAbsScenInputAtt);

   storedName                 = theStochAtt->myName ().myCstring ();

   myStochAttMap_[storedName] = theStochAtt;
   }

//------------------------------------------------------------------------------

WitStochAtt * WitStochAttMgr::findStochAtt (const char * theName)
   {
   WitStochAttMap::iterator theItr;

   if (cachedStochAtt_ != NULL)
      if (cachedStochAtt_->myName () == theName)
         return cachedStochAtt_;

   theItr = myStochAttMap_.find (theName);

   if (theItr != myStochAttMap_.end ())
      cachedStochAtt_ = theItr->second;
   else
      cachedStochAtt_ = NULL;

   return cachedStochAtt_;
   }

//------------------------------------------------------------------------------
// Implementation of class StochAtt.
//------------------------------------------------------------------------------

WitStochAtt::WitStochAtt (
         const char *         theName,
         WitAbsScenInputAtt * theAbsScenInputAtt):

      myName_            (theName),
      isScenSpec_        (false),
      canSetInStochMode_ (false),
      canSetInSolnMode_  (false),
      myAbsScenInputAtt_ (theAbsScenInputAtt)
   {
   }

//------------------------------------------------------------------------------

WitStochAtt::~WitStochAtt ()
   {
   }

//------------------------------------------------------------------------------

void WitStochAtt::setIsScenSpec (bool theValue)
   {
   isScenSpec_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochAtt::setCanSetInStochMode (bool theValue)
   {
   canSetInStochMode_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochAtt::setCanSetInSolnMode (bool theValue)
   {
   canSetInSolnMode_ = theValue;
   }
@


1.106
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.105
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d43 1
a43 1
WitProbAssoc   (theProblem),
d45 16
a60 16
myStochAttMgr_ (NULL),
myStageMgr_    (NULL),
myScenMgr_     (NULL),
myScenAttMgr_  (NULL),
myStochOptMgr_ (NULL),
uploadingData_ (false),
stochSolnMode_ (false),
clearingSoln_  (false)
{
myMsgFac () ("enterStochModeMsg");

validateCoreData ();

myStochAttMgr_ = new WitStochAttMgr       (this);
myScenMgr_     = new WitScenMgr           (this);
myScenAttMgr_  = new WitScenAttMgr        (this);
d62 2
a63 2
myStageMgr_    = WitStageMgr::newStageMgr (this);
}
d68 11
a78 11
{
if (stochSolnMode_)
clearSoln ();

myMsgFac () ("leaveStochModeMsg");

delete myStageMgr_;
delete myScenAttMgr_;
delete myScenMgr_;
delete myStochAttMgr_;
}
d83 5
a87 5
{
myStageMgr_  ->copyAttrsFrom (theStochModeMgr->myStageMgr_);
myScenMgr_   ->copyAttrsFrom (theStochModeMgr->myScenMgr_);
myScenAttMgr_->copyInputFrom (theStochModeMgr->myScenAttMgr_);
}
d92 2
a93 2
{
uploadingData_ = true;
d95 1
a95 1
myScenAttMgr_->uploadInput ();
d97 2
a98 2
uploadingData_ = false;
}
d103 2
a104 2
{
uploadingData_ = true;
d106 1
a106 1
myScenAttMgr_->uploadSoln ();
d108 2
a109 2
uploadingData_ = false;
}
d114 2
a115 2
{
stronglyAssert (myStochOptMgr_ == NULL);
d117 1
a117 1
myStochOptMgr_ = new WitStochOptMgr (this);
d119 1
a119 1
myStochOptMgr_->implode ();
d121 1
a121 1
delete myStochOptMgr_;
d123 1
a123 1
myStochOptMgr_ = NULL;
d125 1
a125 1
stochSolnMode_ = true;
d127 2
a128 2
myMsgFac () ("enterStochSolnModeMsg");
}
d133 2
a134 2
{
stronglyAssert (stochSolnMode_);
d136 1
a136 1
myMsgFac () ("leaveStochSolnModeMsg");
d138 1
a138 1
stochSolnMode_ = false;
d140 1
a140 1
myScenAttMgr_->clearSoln ();
d142 2
a143 2
clearCompSoln ();
}
d148 2
a149 2
{
WitComponent * theComp;
d151 1
a151 1
myPostprocessor ()->unpostprocess ();
d153 1
a153 1
clearingSoln_ = true;
d155 2
a156 2
forEachEl (theComp, myCompMgr ()->allComponents ())
theComp->clearStochSoln ();
d158 2
a159 2
clearingSoln_ = false;
}
d164 2
a165 2
{
witAssert (myStochOptMgr ()->uploadingSoln ());
d167 1
a167 1
uploadingData_ = true;
d169 1
a169 1
myOptComp ()->storeStochObjValue (theValue);
d171 2
a172 2
uploadingData_ = false;
}
d177 2
a178 2
{
witAssert (myStochOptMgr ()->uploadingSoln ());
d180 1
a180 1
uploadingData_ = true;
d182 1
a182 1
myOptComp ()->storeStochBoundsValue (theValue);
d184 2
a185 2
uploadingData_ = false;
}
d190 3
a192 3
{
verifyGlobalBool (  "computeCriticalList",
myGlobalComp  ()->computeCriticalList (), false);
d194 2
a195 2
verifyGlobalBool (  "compPrices",
myOptComp     ()->compPrices          (), false);
d197 2
a198 2
verifyGlobalBool (  "accAfterOptImp",
myOptComp     ()->accAfterOptImp      (), false);
d200 2
a201 2
verifyGlobalBool (  "accAfterSoftLB",
myOptComp     ()->accAfterSoftLB      (), false);
d203 2
a204 2
verifyGlobalBool (  "mipMode",
myOptComp     ()->mipMode             (), false);
d206 3
a208 3
if (myCompMgr ()->nParts () == 0)
myMsgFac () ("noPartsStochModeSmsg");
}
d213 7
a219 7
const char * theAttName,
bool         theVal,
bool         reqVal)
{
if (theVal != reqVal)
myMsgFac () ("invBoolAttStochModeSmsg", theAttName, reqVal);
}
d226 5
a230 5

WitProbAssoc    (theStochModeMgr),
myStochModeMgr_ (theStochModeMgr)
{
}
d235 5
a239 5

WitProbAssoc    (theStochAssoc),
myStochModeMgr_ (theStochAssoc->myStochModeMgr_)
{
}
d244 2
a245 2
{
}
d253 6
a258 6
WitStochAssoc   (theStochModeMgr),
myStochAttMap_  (),
cachedStochAtt_ (NULL)
{
makeStochAtts ();
}
d263 2
a264 2
{
WitStochAtt * theStochAtt;
d266 9
a274 9
while (not myStochAttMap_.empty ())
{
theStochAtt = myStochAttMap_.begin ()->second;

myStochAttMap_.erase (myStochAttMap_.begin ());

delete theStochAtt;
}
}
d279 9
a287 9
const char *         theName,
WitAbsScenInputAtt * theAbsScenInputAtt)
{
makeStochAtt (theName, theAbsScenInputAtt);

findStochAtt (theName)->setIsScenSpec        (true);
findStochAtt (theName)->setCanSetInStochMode (true);
findStochAtt (theName)->setCanSetInSolnMode  (false);
}
d292 6
a297 6
{
makeStochAtt (theName);
findStochAtt (theName)->setIsScenSpec        (true);
findStochAtt (theName)->setCanSetInStochMode (false);
findStochAtt (theName)->setCanSetInSolnMode  (false);
}
d302 12
a313 12
bool (WitStochAtt::* theAccFunc) () const,
const char *         theAttName)
{
WitStochAtt * theStochAtt;

theStochAtt = findStochAtt (theAttName);

if (theStochAtt == NULL)
return false;
else
return (theStochAtt->*theAccFunc) ();
}
d318 2
a319 2
{
WitStochAtt * theStochAtt;
d321 1
a321 1
theStochAtt = findStochAtt (theAttName);
d323 1
a323 1
stronglyAssert (theStochAtt != NULL);
d325 1
a325 1
stronglyAssert (theStochAtt->canSetInStochMode ());
d327 2
a328 2
if (stochSolnMode ())
stronglyAssert (theStochAtt->canSetInSolnMode ());
d330 2
a331 2
stronglyAssert (theStochAtt->myAbsScenInputAtt () == NULL);
}
d336 5
a340 5
const char * theAttName,
WitDelComp * theDelComp)
{
WitStochAtt *        theStochAtt;
WitAbsScenInputAtt * theAbsScenInputAtt;
d342 1
a342 1
stronglyAssert (not stochSolnMode ());
d344 1
a344 1
theStochAtt = findStochAtt (theAttName);
d346 1
a346 1
stronglyAssert (theStochAtt != NULL);
d348 1
a348 1
theAbsScenInputAtt = theStochAtt->myAbsScenInputAtt ();
d350 1
a350 1
stronglyAssert (theAbsScenInputAtt != NULL);
d352 2
a353 2
theAbsScenInputAtt->prepSet (theDelComp);
}
d358 5
a362 5
{
prepSetBoundSetAttr ("hardLB", theBoundSet);
prepSetBoundSetAttr ("softLB", theBoundSet);
prepSetBoundSetAttr ("hardUB", theBoundSet);
}
d367 5
a371 5
const char *  theAttName,
WitBoundSet * theBoundSet)
{
WitStochAtt *        theStochAtt;
WitAbsScenInputAtt * theAbsScenInputAtt;
d373 1
a373 1
theStochAtt = findStochAtt (theAttName);
d375 1
a375 1
stronglyAssert (theStochAtt != NULL);
d377 1
a377 1
stronglyAssert (not stochSolnMode ());
d379 1
a379 1
theAbsScenInputAtt = theStochAtt->myAbsScenInputAtt ();
d381 1
a381 1
stronglyAssert (theAbsScenInputAtt != NULL);
d383 2
a384 2
theAbsScenInputAtt->prepSet (theBoundSet);
}
d389 46
a434 46
{
makeStochAtt ("probability"    );
findStochAtt ("probability"    )->setIsScenSpec        (true);
findStochAtt ("probability"    )->setCanSetInStochMode (true);
findStochAtt ("probability"    )->setCanSetInSolnMode  (false);

makeStochAtt ("objectStage"    );
findStochAtt ("objectStage"    )->setIsScenSpec        (false);
findStochAtt ("objectStage"    )->setCanSetInStochMode (true);
findStochAtt ("objectStage"    )->setCanSetInSolnMode  (false);

makeStochAtt ("periodStage"    );
findStochAtt ("periodStage"    )->setIsScenSpec        (false);
findStochAtt ("periodStage"    )->setCanSetInStochMode (true);
findStochAtt ("periodStage"    )->setCanSetInSolnMode  (false);

makeStochAtt ("stochMode"      );
findStochAtt ("stochMode"      )->setIsScenSpec        (false);
findStochAtt ("stochMode"      )->setCanSetInStochMode (true);
findStochAtt ("stochMode"      )->setCanSetInSolnMode  (true);

makeStochAtt ("currentScenario");
findStochAtt ("currentScenario")->setIsScenSpec        (false);
findStochAtt ("currentScenario")->setCanSetInStochMode (true);
findStochAtt ("currentScenario")->setCanSetInSolnMode  (true);

makeStochAtt ("appData"        );
findStochAtt ("appData"        )->setIsScenSpec        (false);
findStochAtt ("appData"        )->setCanSetInStochMode (true);
findStochAtt ("appData"        )->setCanSetInSolnMode  (true);

makeStochAtt ("stockBounds"    );
findStochAtt ("stockBounds"    )->setIsScenSpec        (true);
findStochAtt ("stockBounds"    )->setCanSetInStochMode (true);
findStochAtt ("stockBounds"    )->setCanSetInSolnMode  (false);

makeStochAtt ("cumShipBounds"  );
findStochAtt ("cumShipBounds"  )->setIsScenSpec        (true);
findStochAtt ("cumShipBounds"  )->setCanSetInStochMode (true);
findStochAtt ("cumShipBounds"  )->setCanSetInSolnMode  (false);

makeStochAtt ("execBounds"     );
findStochAtt ("execBounds"     )->setIsScenSpec        (true);
findStochAtt ("execBounds"     )->setCanSetInStochMode (true);
findStochAtt ("execBounds"     )->setCanSetInSolnMode  (false);
}
d439 3
a441 3
{
makeStochAtt (theName, NULL);
}
d446 5
a450 5
const char *         theName,
WitAbsScenInputAtt * theAbsScenInputAtt)
{
WitStochAtt * theStochAtt;
const char *  storedName;
d452 1
a452 1
stronglyAssert (findStochAtt (theName) == NULL);
d454 1
a454 1
theStochAtt                = new WitStochAtt (theName, theAbsScenInputAtt);
d456 1
a456 1
storedName                 = theStochAtt->myName ().myCstring ();
d458 2
a459 2
myStochAttMap_[storedName] = theStochAtt;
}
d464 2
a465 2
{
WitStochAttMap::iterator theItr;
d467 10
a476 10
if (cachedStochAtt_ != NULL)
if (cachedStochAtt_->myName () == theName)
return cachedStochAtt_;

theItr = myStochAttMap_.find (theName);

if (theItr != myStochAttMap_.end ())
cachedStochAtt_ = theItr->second;
else
cachedStochAtt_ = NULL;
d478 2
a479 2
return cachedStochAtt_;
}
d486 2
a487 2
const char *         theName,
WitAbsScenInputAtt * theAbsScenInputAtt):
d489 7
a495 7
myName_            (theName),
isScenSpec_        (false),
canSetInStochMode_ (false),
canSetInSolnMode_  (false),
myAbsScenInputAtt_ (theAbsScenInputAtt)
{
}
d500 2
a501 2
{
}
d506 3
a508 3
{
isScenSpec_ = theValue;
}
d513 3
a515 3
{
canSetInStochMode_ = theValue;
}
d520 3
a522 3
{
canSetInSolnMode_ = theValue;
}
@


1.104
log
@Removed COIN from WIT.
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d43 1
a43 1
      WitProbAssoc   (theProblem),
d45 16
a60 16
      myStochAttMgr_ (NULL),
      myStageMgr_    (NULL),
      myScenMgr_     (NULL),
      myScenAttMgr_  (NULL),
      myStochOptMgr_ (NULL),
      uploadingData_ (false),
      stochSolnMode_ (false),
      clearingSoln_  (false)
   {
   myMsgFac () ("enterStochModeMsg");

   validateCoreData ();

   myStochAttMgr_ = new WitStochAttMgr       (this);
   myScenMgr_     = new WitScenMgr           (this);
   myScenAttMgr_  = new WitScenAttMgr        (this);
d62 2
a63 2
   myStageMgr_    = WitStageMgr::newStageMgr (this);
   }
d68 11
a78 11
   {
   if (stochSolnMode_)
      clearSoln ();

   myMsgFac () ("leaveStochModeMsg");

   delete myStageMgr_;
   delete myScenAttMgr_;
   delete myScenMgr_;
   delete myStochAttMgr_;
   }
d83 5
a87 5
   {
   myStageMgr_  ->copyAttrsFrom (theStochModeMgr->myStageMgr_);
   myScenMgr_   ->copyAttrsFrom (theStochModeMgr->myScenMgr_);
   myScenAttMgr_->copyInputFrom (theStochModeMgr->myScenAttMgr_);
   }
d92 2
a93 2
   {
   uploadingData_ = true;
d95 1
a95 1
   myScenAttMgr_->uploadInput ();
d97 2
a98 2
   uploadingData_ = false;
   }
d103 2
a104 2
   {
   uploadingData_ = true;
d106 1
a106 1
   myScenAttMgr_->uploadSoln ();
d108 2
a109 2
   uploadingData_ = false;
   }
d114 2
a115 2
   {
   stronglyAssert (myStochOptMgr_ == NULL);
d117 1
a117 1
   myStochOptMgr_ = new WitStochOptMgr (this);
d119 1
a119 1
   myStochOptMgr_->implode ();
d121 1
a121 1
   delete myStochOptMgr_;
d123 1
a123 1
   myStochOptMgr_ = NULL;
d125 1
a125 1
   stochSolnMode_ = true;
d127 2
a128 2
   myMsgFac () ("enterStochSolnModeMsg");
   }
d133 2
a134 2
   {
   stronglyAssert (stochSolnMode_);
d136 1
a136 1
   myMsgFac () ("leaveStochSolnModeMsg");
d138 1
a138 1
   stochSolnMode_ = false;
d140 1
a140 1
   myScenAttMgr_->clearSoln ();
d142 2
a143 2
   clearCompSoln ();
   }
d148 2
a149 2
   {
   WitComponent * theComp;
d151 1
a151 1
   myPostprocessor ()->unpostprocess ();
d153 1
a153 1
   clearingSoln_ = true;
d155 2
a156 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->clearStochSoln ();
d158 2
a159 2
   clearingSoln_ = false;
   }
d164 2
a165 2
   {
   witAssert (myStochOptMgr ()->uploadingSoln ());
d167 1
a167 1
   uploadingData_ = true;
d169 1
a169 1
   myOptComp ()->storeStochObjValue (theValue);
d171 2
a172 2
   uploadingData_ = false;
   }
d177 2
a178 2
   {
   witAssert (myStochOptMgr ()->uploadingSoln ());
d180 1
a180 1
   uploadingData_ = true;
d182 1
a182 1
   myOptComp ()->storeStochBoundsValue (theValue);
d184 2
a185 2
   uploadingData_ = false;
   }
d190 3
a192 3
   {
   verifyGlobalBool (  "computeCriticalList", 
      myGlobalComp  ()->computeCriticalList (), false);
d194 2
a195 2
   verifyGlobalBool (  "compPrices",
      myOptComp     ()->compPrices          (), false);
d197 2
a198 2
   verifyGlobalBool (  "accAfterOptImp",
      myOptComp     ()->accAfterOptImp      (), false);
d200 2
a201 2
   verifyGlobalBool (  "accAfterSoftLB",
      myOptComp     ()->accAfterSoftLB      (), false);
d203 2
a204 2
   verifyGlobalBool (  "mipMode",
      myOptComp     ()->mipMode             (), false);
d206 3
a208 3
   if (myCompMgr ()->nParts () == 0)
      myMsgFac () ("noPartsStochModeSmsg");
   }
d213 7
a219 7
      const char * theAttName,
      bool         theVal,
      bool         reqVal)
   {
   if (theVal != reqVal)
      myMsgFac () ("invBoolAttStochModeSmsg", theAttName, reqVal);
   }
d226 5
a230 5
                        
      WitProbAssoc    (theStochModeMgr),
      myStochModeMgr_ (theStochModeMgr)
   {
   }
d235 5
a239 5
                        
      WitProbAssoc    (theStochAssoc),
      myStochModeMgr_ (theStochAssoc->myStochModeMgr_)
   {
   }
d244 2
a245 2
   {
   }
d253 6
a258 6
      WitStochAssoc   (theStochModeMgr),
      myStochAttMap_  (),
      cachedStochAtt_ (NULL)
   {
   makeStochAtts ();
   }
d263 2
a264 2
   {
   WitStochAtt * theStochAtt;
d266 9
a274 9
   while (not myStochAttMap_.empty ())
      {
      theStochAtt = myStochAttMap_.begin ()->second;

      myStochAttMap_.erase (myStochAttMap_.begin ());

      delete theStochAtt;
      }
   }
d279 9
a287 9
      const char *         theName,
      WitAbsScenInputAtt * theAbsScenInputAtt)
   {
   makeStochAtt (theName, theAbsScenInputAtt);

   findStochAtt (theName)->setIsScenSpec        (true);
   findStochAtt (theName)->setCanSetInStochMode (true);
   findStochAtt (theName)->setCanSetInSolnMode  (false);
   }
d292 6
a297 6
   {
   makeStochAtt (theName);
   findStochAtt (theName)->setIsScenSpec        (true);
   findStochAtt (theName)->setCanSetInStochMode (false);
   findStochAtt (theName)->setCanSetInSolnMode  (false);
   }
d302 12
a313 12
      bool (WitStochAtt::* theAccFunc) () const, 
      const char *         theAttName)
   {
   WitStochAtt * theStochAtt;

   theStochAtt = findStochAtt (theAttName);

   if (theStochAtt == NULL)
      return false;
   else
      return (theStochAtt->*theAccFunc) ();
   }
d318 2
a319 2
   {
   WitStochAtt * theStochAtt;
d321 1
a321 1
   theStochAtt = findStochAtt (theAttName);
d323 1
a323 1
   stronglyAssert (theStochAtt != NULL);
d325 1
a325 1
   stronglyAssert (theStochAtt->canSetInStochMode ());
d327 2
a328 2
   if (stochSolnMode ())
      stronglyAssert (theStochAtt->canSetInSolnMode ());
d330 2
a331 2
   stronglyAssert (theStochAtt->myAbsScenInputAtt () == NULL);
   }
d336 5
a340 5
      const char * theAttName,
      WitDelComp * theDelComp)
   {
   WitStochAtt *        theStochAtt;
   WitAbsScenInputAtt * theAbsScenInputAtt;
d342 1
a342 1
   stronglyAssert (not stochSolnMode ());
d344 1
a344 1
   theStochAtt = findStochAtt (theAttName);
d346 1
a346 1
   stronglyAssert (theStochAtt != NULL);
d348 1
a348 1
   theAbsScenInputAtt = theStochAtt->myAbsScenInputAtt ();
d350 1
a350 1
   stronglyAssert (theAbsScenInputAtt != NULL);
d352 2
a353 2
   theAbsScenInputAtt->prepSet (theDelComp);
   }
d358 5
a362 5
   {
   prepSetBoundSetAttr ("hardLB", theBoundSet);
   prepSetBoundSetAttr ("softLB", theBoundSet);
   prepSetBoundSetAttr ("hardUB", theBoundSet);
   }
d367 5
a371 5
      const char *  theAttName,
      WitBoundSet * theBoundSet)
   {
   WitStochAtt *        theStochAtt;
   WitAbsScenInputAtt * theAbsScenInputAtt;
d373 1
a373 1
   theStochAtt = findStochAtt (theAttName);
d375 1
a375 1
   stronglyAssert (theStochAtt != NULL);
d377 1
a377 1
   stronglyAssert (not stochSolnMode ());
d379 1
a379 1
   theAbsScenInputAtt = theStochAtt->myAbsScenInputAtt ();
d381 1
a381 1
   stronglyAssert (theAbsScenInputAtt != NULL);
d383 2
a384 2
   theAbsScenInputAtt->prepSet (theBoundSet);
   }
d389 46
a434 46
   {
   makeStochAtt ("probability"    );
   findStochAtt ("probability"    )->setIsScenSpec        (true);
   findStochAtt ("probability"    )->setCanSetInStochMode (true);
   findStochAtt ("probability"    )->setCanSetInSolnMode  (false);

   makeStochAtt ("objectStage"    );
   findStochAtt ("objectStage"    )->setIsScenSpec        (false);
   findStochAtt ("objectStage"    )->setCanSetInStochMode (true);
   findStochAtt ("objectStage"    )->setCanSetInSolnMode  (false);

   makeStochAtt ("periodStage"    );
   findStochAtt ("periodStage"    )->setIsScenSpec        (false);
   findStochAtt ("periodStage"    )->setCanSetInStochMode (true);
   findStochAtt ("periodStage"    )->setCanSetInSolnMode  (false);

   makeStochAtt ("stochMode"      );
   findStochAtt ("stochMode"      )->setIsScenSpec        (false);
   findStochAtt ("stochMode"      )->setCanSetInStochMode (true);
   findStochAtt ("stochMode"      )->setCanSetInSolnMode  (true);

   makeStochAtt ("currentScenario");
   findStochAtt ("currentScenario")->setIsScenSpec        (false);
   findStochAtt ("currentScenario")->setCanSetInStochMode (true);
   findStochAtt ("currentScenario")->setCanSetInSolnMode  (true);

   makeStochAtt ("appData"        );
   findStochAtt ("appData"        )->setIsScenSpec        (false);
   findStochAtt ("appData"        )->setCanSetInStochMode (true);
   findStochAtt ("appData"        )->setCanSetInSolnMode  (true);

   makeStochAtt ("stockBounds"    );
   findStochAtt ("stockBounds"    )->setIsScenSpec        (true);
   findStochAtt ("stockBounds"    )->setCanSetInStochMode (true);
   findStochAtt ("stockBounds"    )->setCanSetInSolnMode  (false);

   makeStochAtt ("cumShipBounds"  );
   findStochAtt ("cumShipBounds"  )->setIsScenSpec        (true);
   findStochAtt ("cumShipBounds"  )->setCanSetInStochMode (true);
   findStochAtt ("cumShipBounds"  )->setCanSetInSolnMode  (false);

   makeStochAtt ("execBounds"     );
   findStochAtt ("execBounds"     )->setIsScenSpec        (true);
   findStochAtt ("execBounds"     )->setCanSetInStochMode (true);
   findStochAtt ("execBounds"     )->setCanSetInSolnMode  (false);
   }
d439 3
a441 3
   {
   makeStochAtt (theName, NULL);
   }
d446 5
a450 5
      const char *         theName,
      WitAbsScenInputAtt * theAbsScenInputAtt)
   {
   WitStochAtt * theStochAtt;
   const char *  storedName;
d452 1
a452 1
   stronglyAssert (findStochAtt (theName) == NULL);
d454 1
a454 1
   theStochAtt                = new WitStochAtt (theName, theAbsScenInputAtt);
d456 1
a456 1
   storedName                 = theStochAtt->myName ().myCstring ();
d458 2
a459 2
   myStochAttMap_[storedName] = theStochAtt;
   }
d464 2
a465 2
   {
   WitStochAttMap::iterator theItr;
d467 10
a476 10
   if (cachedStochAtt_ != NULL)
      if (cachedStochAtt_->myName () == theName)
         return cachedStochAtt_;

   theItr = myStochAttMap_.find (theName);

   if (theItr != myStochAttMap_.end ())
      cachedStochAtt_ = theItr->second;
   else
      cachedStochAtt_ = NULL;
d478 2
a479 2
   return cachedStochAtt_;
   }
d486 2
a487 2
         const char *         theName,
         WitAbsScenInputAtt * theAbsScenInputAtt):
d489 7
a495 7
      myName_            (theName),
      isScenSpec_        (false),
      canSetInStochMode_ (false),
      canSetInSolnMode_  (false),
      myAbsScenInputAtt_ (theAbsScenInputAtt)
   {
   }
d500 2
a501 2
   {
   }
d506 3
a508 3
   {
   isScenSpec_ = theValue;
   }
d513 3
a515 3
   {
   canSetInStochMode_ = theValue;
   }
d520 3
a522 3
   {
   canSetInSolnMode_ = theValue;
   }
@


1.103
log
@Removed setting of optInitMethod in stochastic implosion.
@
text
@a433 10

   makeStochAtt ("coinSelected"   );
   findStochAtt ("coinSelected"   )->setIsScenSpec        (false);
   findStochAtt ("coinSelected"   )->setCanSetInStochMode (true);
   findStochAtt ("coinSelected"   )->setCanSetInSolnMode  (false);

   makeStochAtt ("cplexSelected"  );
   findStochAtt ("cplexSelected"  )->setIsScenSpec        (false);
   findStochAtt ("cplexSelected"  )->setCanSetInStochMode (true);
   findStochAtt ("cplexSelected"  )->setCanSetInSolnMode  (false);
@


1.102
log
@Minor correction.
@
text
@d58 3
a60 4
   myStochAttMgr_ = new WitStochAttMgr (this);

   myScenMgr_     = new WitScenMgr     (this);
   myScenAttMgr_  = new WitScenAttMgr  (this);
a62 2

   myOptComp ()->crashOptStarter ()->beChosen ();
@


1.101
log
@Allowed intExecVols, etc. with mipMode == false.
@
text
@d285 1
a285 3
   stronglyAssert (findStochAtt (theName) == NULL);

   myStochAttMap_[theName] = new WitStochAtt (theName, theAbsScenInputAtt);
d453 12
d467 5
a471 1
   myStochAttMap_[theName] = new WitStochAtt (theName);
a497 12
WitStochAtt::WitStochAtt (const char * theName):

      myName_            (theName),
      isScenSpec_        (false),
      canSetInStochMode_ (false),
      canSetInSolnMode_  (false),
      myAbsScenInputAtt_ (NULL)
   {
   }

//------------------------------------------------------------------------------

@


1.100
log
@CPLEX
@
text
@a29 1
#include <Pre.h>
a210 2

   myPreprocessor ()->verifyNoIntCons ();
@


1.99
log
@CPLEX
@
text
@a118 3
   if (myOptComp ()->cplexSelected ())
      myMsgFac () ("cplexSolveNyaSmsg", "Stochastic implosion");

@


1.98
log
@CPLEX
@
text
@d119 1
a119 1
   if (myOptComp ()->solverIsCplex ())
d446 9
a454 9
   makeStochAtt ("solverIsCoin"   );
   findStochAtt ("solverIsCoin"   )->setIsScenSpec        (false);
   findStochAtt ("solverIsCoin"   )->setCanSetInStochMode (true);
   findStochAtt ("solverIsCoin"   )->setCanSetInSolnMode  (false);

   makeStochAtt ("solverIsCplex"  );
   findStochAtt ("solverIsCplex"  )->setIsScenSpec        (false);
   findStochAtt ("solverIsCplex"  )->setCanSetInStochMode (true);
   findStochAtt ("solverIsCplex"  )->setCanSetInSolnMode  (false);
@


1.97
log
@CPLEX
@
text
@a36 1
#include <MsgFrag.h>
d120 1
a120 3
      if (not myOptComp ()->cplexAllowed ())
         myMsgFac () ("cplexSolveNyaSmsg",
            myMsgFac ().myFrag ("stochImpFrag"));
@


1.96
log
@CPLEX
@
text
@d37 1
d120 4
a123 3
   if (not COIN_EMBEDDED)
      if (CPLEX_EMBEDDED)
         myMsgFac () ("optWCplexWoCoinSmsg");
d453 5
@


1.95
log
@CPLEX
@
text
@d119 2
a120 2
   if (not WitOptComp::coinEmbedded ())
      if (WitOptComp::cplexEmbedded ())
@


1.94
log
@Preparing for CPLEX.
@
text
@d119 4
@


1.93
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d442 5
@


1.92
log
@Removing objective #2.
@
text
@d33 1
a33 1
#include <Global.h>
@


1.91
log
@Allowed appData to be set in stochastic mode.
@
text
@a209 3
   if (not myOptComp ()->myObjFunc1 ()->isChosen ())
      myMsgFac () ("invIntAttStochModeSmsg", "objChoice", 1);

@


1.90
log
@Stochastic Implosion
@
text
@d426 5
@


1.89
log
@Stochastic Implosion
@
text
@a194 4
   if (not myStochImpMgr ()->allowStageByPer ())
      verifyGlobalBool (  "stageByObject",
         myStochImpMgr ()->stageByObject    (), true);

@


1.88
log
@Stochastic Implosion
@
text
@d64 1
a64 1
   myStageMgr_    = WitStageMgr::newStageMgr (myProblem ());
@


1.87
log
@Stochastic Implosion
@
text
@d23 1
a23 2
#include <ObjStageMgr.h>
#include <PerStageMgr.h>
d35 1
a47 2
      myObjStageMgr_ (NULL),
      myPerStageMgr_ (NULL),
d64 1
a64 1
   buildStageMgr ();
d88 1
a88 1
   myStageMgr_  ->copyAttrsFrom (theStochModeMgr);
a234 18

void WitStochModeMgr::buildStageMgr ()
   {
   if (myStochImpMgr ()->stageByObject ())
      {
      myObjStageMgr_ = new WitObjStageMgr (myProblem ());

      myStageMgr_    = myObjStageMgr_;
      }
   else
      {
      myPerStageMgr_ = new WitPerStageMgr (myProblem ());

      myStageMgr_    = myPerStageMgr_;
      }
   }

//------------------------------------------------------------------------------
@


1.86
log
@Stochastic Implosion
@
text
@d16 1
a20 1
#include <StochModeMgr.h>
d255 26
d286 1
a286 1
      myStochModeMgr_ (theStochModeMgr),
d362 1
a362 1
   if (myStochModeMgr_->stochSolnMode ())
d377 1
a377 1
   stronglyAssert (not myStochModeMgr_->stochSolnMode ());
d412 1
a412 1
   stronglyAssert (not myStochModeMgr_->stochSolnMode ());
@


1.85
log
@Stochastic Implosion
@
text
@d399 39
a437 39
   makeStochAtt ("probability"     );
   findStochAtt ("probability"     )->setIsScenSpec        (true);
   findStochAtt ("probability"     )->setCanSetInStochMode (true);
   findStochAtt ("probability"     )->setCanSetInSolnMode  (false);

   makeStochAtt ("objectStage"     );
   findStochAtt ("objectStage"     )->setIsScenSpec        (false);
   findStochAtt ("objectStage"     )->setCanSetInStochMode (true);
   findStochAtt ("objectStage"     )->setCanSetInSolnMode  (false);

   makeStochAtt ("periodStage"     );
   findStochAtt ("periodStage"     )->setIsScenSpec        (false);
   findStochAtt ("periodStage"     )->setCanSetInStochMode (true);
   findStochAtt ("periodStage"     )->setCanSetInSolnMode  (false);

   makeStochAtt ("stochMode"       );
   findStochAtt ("stochMode"       )->setIsScenSpec        (false);
   findStochAtt ("stochMode"       )->setCanSetInStochMode (true);
   findStochAtt ("stochMode"       )->setCanSetInSolnMode  (true);

   makeStochAtt ("curScenarioIndex");
   findStochAtt ("curScenarioIndex")->setIsScenSpec        (false);
   findStochAtt ("curScenarioIndex")->setCanSetInStochMode (true);
   findStochAtt ("curScenarioIndex")->setCanSetInSolnMode  (true);

   makeStochAtt ("stockBounds"     );
   findStochAtt ("stockBounds"     )->setIsScenSpec        (true);
   findStochAtt ("stockBounds"     )->setCanSetInStochMode (true);
   findStochAtt ("stockBounds"     )->setCanSetInSolnMode  (false);

   makeStochAtt ("cumShipBounds"   );
   findStochAtt ("cumShipBounds"   )->setIsScenSpec        (true);
   findStochAtt ("cumShipBounds"   )->setCanSetInStochMode (true);
   findStochAtt ("cumShipBounds"   )->setCanSetInSolnMode  (false);

   makeStochAtt ("execBounds"      );
   findStochAtt ("execBounds"      )->setIsScenSpec        (true);
   findStochAtt ("execBounds"      )->setCanSetInStochMode (true);
   findStochAtt ("execBounds"      )->setCanSetInSolnMode  (false);
@


1.84
log
@Stochastic Implosion
@
text
@d404 9
a412 9
   makeStochAtt ("stageIndex"      );
   findStochAtt ("stageIndex"      )->setIsScenSpec        (false);
   findStochAtt ("stageIndex"      )->setCanSetInStochMode (true);
   findStochAtt ("stageIndex"      )->setCanSetInSolnMode  (false);

   makeStochAtt ("perStageIndex"   );
   findStochAtt ("perStageIndex"   )->setIsScenSpec        (false);
   findStochAtt ("perStageIndex"   )->setCanSetInStochMode (true);
   findStochAtt ("perStageIndex"   )->setCanSetInSolnMode  (false);
@


1.83
log
@Stochastic Implosion
@
text
@d59 1
a59 1
   verifyData ();
d66 1
a66 9
   if (myStochImpMgr ()->stageByObject ())
      myObjStageMgr_ = new WitObjStageMgr (myProblem ());
   else
      myPerStageMgr_ = new WitPerStageMgr (myProblem ());

   if (myStochImpMgr ()->stageByObject ())
      myStageMgr_ = myObjStageMgr ();
   else
      myStageMgr_ = myPerStageMgr ();
d195 1
a195 1
void WitStochModeMgr::verifyData ()
d237 18
@


1.82
log
@Stochastic Implosion
@
text
@d399 5
@


1.81
log
@Stochastic Implosion
@
text
@d24 1
d49 1
a66 1
      {
d68 2
d71 2
a72 2
      myStageMgr_    = myObjStageMgr ();
      }
d74 1
a74 1
      myMsgFac () ("stageByPeriodNYISmsg", __FILE__, __LINE__);
@


1.80
log
@Stochastic Implosion
@
text
@d46 1
d60 1
a60 1
   myObjStageMgr_ = new WitObjStageMgr (this);
d64 9
d85 1
a87 1
   delete myObjStageMgr_;
d95 3
a97 3
   myObjStageMgr_->copyAttrsFrom (theStochModeMgr->myObjStageMgr_);
   myScenMgr_    ->copyAttrsFrom (theStochModeMgr->myScenMgr_);
   myScenAttMgr_ ->copyInputFrom (theStochModeMgr->myScenAttMgr_);
@


1.79
log
@Stochastic Implosion
@
text
@d23 1
a23 1
#include <StageMgr.h>
d46 1
a46 1
      myStageMgr_    (NULL),
d59 1
a59 1
   myStageMgr_    = new WitStageMgr    (this);
d77 1
a77 1
   delete myStageMgr_;
d85 3
a87 3
   myStageMgr_  ->copyAttrsFrom (theStochModeMgr->myStageMgr_);
   myScenMgr_   ->copyAttrsFrom (theStochModeMgr->myScenMgr_);
   myScenAttMgr_->copyInputFrom (theStochModeMgr->myScenAttMgr_);
@


1.78
log
@Stochastic Implosion
@
text
@d13 1
a13 1
// Contains the implementation of the following classes and templates:
a17 1
//    StageMgr
a29 1
#include <DataWrit.h>
a31 1
#include <DetOptImpMgr.h>
a33 5
#include <Material.h>
#include <Demand.h>
#include <Opn.h>
#include <SubEntry.h>
#include <BopEntry.h>
a34 1
#include <BoundSet.h>
a35 1
#include <MsgFrag.h>
a494 223

//------------------------------------------------------------------------------
// Implementation of class StageMgr.
//------------------------------------------------------------------------------

WitStageMgr::WitStageMgr (WitStochModeMgr * theStochModeMgr):

      WitProbAssoc    (theStochModeMgr),
      myStochModeMgr_ (theStochModeMgr),
      stageIndex_     (myProblem (), defStageIndex ())
   {
   if (not myStochImpMgr ()->stageByObject ())
      myMsgFac () ("stageByPeriodNYISmsg");
   }

//------------------------------------------------------------------------------

WitStageMgr::~WitStageMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitStageMgr::writeData ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   forEachPart (thePart, myProblem ())
      writeStageIndex (thePart, "part");

   forEachOperation (theOpn, myProblem ())
      writeStageIndex (theOpn, "operation");
   }

//------------------------------------------------------------------------------

void WitStageMgr::displayData ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   myMsgFac () ("stageHeadingDdMsg");

   forEachPart (thePart, myProblem ())
      {
      myMsgFac () ("partIdDdMsg",    thePart->partName ());
      myMsgFac () ("stochNodeDdMsg", stageIndex_ (thePart));
      }

   forEachOperation (theOpn, myProblem ())
      {
      myMsgFac () ("opnIdDdMsg",     theOpn->operationName ());
      myMsgFac () ("stochNodeDdMsg", stageIndex_ (theOpn));
      }
   }

//------------------------------------------------------------------------------

void WitStageMgr::copyAttrsFrom (WitStageMgr * origStageMgr)
   {
   WitPart *      dupPart;
   WitPart *      origPart;
   WitOperation * dupOpn;
   WitOperation * origOpn;

   forEachPart (dupPart, myProblem ())
      {
      origPart =
         origStageMgr->
            myCompMgr ()->
               findPart (dupPart->partName ().myCstring ());

      stageIndex_ (dupPart) = origStageMgr->stageIndex_ (origPart);
      }

   forEachOperation (dupOpn, myProblem ())
      {
      origOpn =
         origStageMgr->
            myCompMgr ()->
               findOperation (dupOpn->operationName ().myCstring ());

      stageIndex_ (dupOpn) = origStageMgr->stageIndex_ (origOpn);
      }
   }

//------------------------------------------------------------------------------

void WitStageMgr::validateData ()
   {
   validateBomEnts ();
   validateSubs    ();
   validateBopEnts ();
   }

//------------------------------------------------------------------------------

void WitStageMgr::setStageIndex (WitNode * theNode, int theValue)
   {
   witAssert (theValue >= 0);
   witAssert (theValue <= 1);

   myProblem ()->prepSetStochModeAttr ("stageIndex");

   stageIndex_ (theNode) = theValue;
   }

//------------------------------------------------------------------------------

int WitStageMgr::stageIndex (WitNode * theNode)
   {
   return stageIndex_ (theNode);
   }

//------------------------------------------------------------------------------

int WitStageMgr::stageIndex (WitDemand * theDemand)
   {
   return stageIndex_ (theDemand->demandedPart ());
   }

//------------------------------------------------------------------------------

int WitStageMgr::stageIndex (WitBillEntry * theBillEnt)
   {
   return stageIndex_ (theBillEnt->myOperation ());
   }

//------------------------------------------------------------------------------

int WitStageMgr::stageIndex (WitBoundSet * theBoundSet)
   {
   return theBoundSet->stageIndex ();
   }

//------------------------------------------------------------------------------

void WitStageMgr::writeStageIndex (
      WitNode *    theNode,
      const char * nodeTypeName)
   {
   if (stageIndex_ (theNode) == defStageIndex ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      (nodeTypeName);
   myDataWriter ()->writeStringValue  (theNode->nodeName ());

   myDataWriter ()->writeInt (
        "stageIndex",
         stageIndex_ (theNode),
      defStageIndex ());

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitStageMgr::validateBomEnts ()
   {
   WitBomEntry * theBomEnt;
   int           stgIdxForOpn;
   int           stgIdxForPart;

   forEachBomEntry (theBomEnt, myProblem ())
      {
      stgIdxForOpn  = stageIndex_ (theBomEnt->myOperation ());
      stgIdxForPart = stageIndex_ (theBomEnt->myPart      ());

      if (stgIdxForOpn == 1)
         if (stgIdxForPart == 0)
            myMsgFac () ("bomEntStageMisMatchSmsg",
               theBomEnt->myOperationName (),
               theBomEnt->localIndex (),
               theBomEnt->myPartName ());
      }
   }

//------------------------------------------------------------------------------

void WitStageMgr::validateSubs ()
   {
   WitSubEntry * theSub;
   int           stgIdxForOpn;
   int           stgIdxForPart;

   forEachSubEntry (theSub, myProblem ())
      {
      stgIdxForOpn  = stageIndex_ (theSub->myOperation ());
      stgIdxForPart = stageIndex_ (theSub->myPart      ());

      if (stgIdxForOpn == 1)
         if (stgIdxForPart == 0)
            myMsgFac () ("subStageMisMatchSmsg",
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               theSub->myPartName ());
      }
   }

//------------------------------------------------------------------------------

void WitStageMgr::validateBopEnts ()
   {
   WitBopEntry * theBopEnt;
   int           stgIdxForOpn;
   int           stgIdxForPart;

   forEachBopEntry (theBopEnt, myProblem ())
      {
      stgIdxForOpn  = stageIndex_ (theBopEnt->myOperation ());
      stgIdxForPart = stageIndex_ (theBopEnt->myPart      ());

      if (stgIdxForOpn == 1)
         if (stgIdxForPart == 0)
            myMsgFac () ("bopEntStageMisMatchSmsg",
               theBopEnt->myOperationName (),
               theBopEnt->localIndex (),
               theBopEnt->myPartName ());
      }
   }
@


1.77
log
@Stochastic Implosion
@
text
@d202 3
a204 2
   verifyGlobalBool (  "stageByObject",
      myStochImpMgr ()->stageByObject       (), true);
d516 2
@


1.76
log
@Stochastic Implosion
@
text
@d635 1
a635 1
   return theBoundSet->myDelComp ()->stageIndex ();
@


1.75
log
@Stochastic Implosion
@
text
@a338 2
   stronglyAssert (theDelComp->stageIndex () != 0);

a373 2
   stronglyAssert (theBoundSet->myDelComp ()->stageIndex () != 0);

d633 7
@


1.74
log
@Stochastic Implosion
@
text
@d661 2
a662 2
   int           stageIndexforOpn;
   int           stageIndexforPart;
d666 2
a667 2
      stageIndexforOpn  = stageIndex_ (theBomEnt->myOperation ());
      stageIndexforPart = stageIndex_ (theBomEnt->myPart      ());
d669 2
a670 2
      if (stageIndexforOpn == 1)
         if (stageIndexforPart == 0)
d683 2
a684 2
   int           stageIndexforOpn;
   int           stageIndexforPart;
d688 2
a689 2
      stageIndexforOpn  = stageIndex_ (theSub->myOperation ());
      stageIndexforPart = stageIndex_ (theSub->myPart      ());
d691 7
a697 8
      if (stageIndexforOpn != stageIndexforPart)
         myMsgFac () ("subStageMisMatchSmsg",
            stageIndexforOpn,
            stageIndexforPart,
            theSub->myOperationName (),
            theSub->myBomEntIndex (),
            theSub->localIndex (),
            theSub->myPartName ());
d706 2
a707 2
   int           stageIndexforOpn;
   int           stageIndexforPart;
d711 2
a712 2
      stageIndexforOpn  = stageIndex_ (theBopEnt->myOperation ());
      stageIndexforPart = stageIndex_ (theBopEnt->myPart      ());
d714 2
a715 2
      if (stageIndexforOpn == 1)
         if (stageIndexforPart == 0)
@


1.73
log
@Allowing wit34Compatible in stochastic mode.
@
text
@d669 6
a674 7
      if (stageIndexforOpn != stageIndexforPart)
         myMsgFac () ("bomEntStageMisMatchSmsg",
            stageIndexforOpn,
            stageIndexforPart,
            theBomEnt->myOperationName (),
            theBomEnt->localIndex (),
            theBomEnt->myPartName ());
@


1.72
log
@Stochastic Implosion
@
text
@a207 3
   verifyGlobalBool (  "wit34Compatible",
      myGlobalComp  ()->wit34Compatible     (), false);

@


1.71
log
@Stochastic Implosion
@
text
@d317 1
a317 2
   WitStochAtt *        theStochAtt;
   WitAbsScenInputAtt * theAbsScenInputAtt;
d328 53
d382 4
a385 3
   
   if (theAbsScenInputAtt != NULL)
      theAbsScenInputAtt->prepSet ();
@


1.70
log
@Stochastic Implosion
@
text
@d27 1
d68 4
a71 4
   myStochAttMgr_ = new WitStochAttMgr;
   myStageMgr_    = new WitStageMgr   (this);
   myScenMgr_     = new WitScenMgr    (this);
   myScenAttMgr_  = new WitScenAttMgr (this);
d247 1
a247 1
WitStochAttMgr::WitStochAttMgr ():
d249 1
d303 1
a303 1
   const WitStochAtt * theStochAtt;
d315 22
d559 1
a559 1
   myStochImpMgr ()->prepSetStochModeAttr ("stageIndex");
@


1.69
log
@Stochastic Implosion
@
text
@d535 1
a535 1
   myProblem ()->prepSetStochModeAttr ("stageIndex");
@


1.68
log
@Stochastic Implosion
@
text
@d276 1
a276 1
   stronglyAssert (findStochAttInt (theName) == NULL);
d280 3
a282 3
   findStochAttInt (theName)->setIsScenSpec        (true);
   findStochAttInt (theName)->setCanSetInStochMode (true);
   findStochAttInt (theName)->setCanSetInSolnMode  (false);
d289 20
a308 4
   makeStochAtt    (theName);
   findStochAttInt (theName)->setIsScenSpec        (true);
   findStochAttInt (theName)->setCanSetInStochMode (false);
   findStochAttInt (theName)->setCanSetInSolnMode  (false);
d315 34
a348 34
   makeStochAtt    ("probability"     );
   findStochAttInt ("probability"     )->setIsScenSpec        (true);
   findStochAttInt ("probability"     )->setCanSetInStochMode (true);
   findStochAttInt ("probability"     )->setCanSetInSolnMode  (false);

   makeStochAtt    ("stageIndex"      );
   findStochAttInt ("stageIndex"      )->setIsScenSpec        (false);
   findStochAttInt ("stageIndex"      )->setCanSetInStochMode (true);
   findStochAttInt ("stageIndex"      )->setCanSetInSolnMode  (false);

   makeStochAtt    ("stochMode"       );
   findStochAttInt ("stochMode"       )->setIsScenSpec        (false);
   findStochAttInt ("stochMode"       )->setCanSetInStochMode (true);
   findStochAttInt ("stochMode"       )->setCanSetInSolnMode  (true);

   makeStochAtt    ("curScenarioIndex");
   findStochAttInt ("curScenarioIndex")->setIsScenSpec        (false);
   findStochAttInt ("curScenarioIndex")->setCanSetInStochMode (true);
   findStochAttInt ("curScenarioIndex")->setCanSetInSolnMode  (true);

   makeStochAtt    ("stockBounds"     );
   findStochAttInt ("stockBounds"     )->setIsScenSpec        (true);
   findStochAttInt ("stockBounds"     )->setCanSetInStochMode (true);
   findStochAttInt ("stockBounds"     )->setCanSetInSolnMode  (false);

   makeStochAtt    ("cumShipBounds"   );
   findStochAttInt ("cumShipBounds"   )->setIsScenSpec        (true);
   findStochAttInt ("cumShipBounds"   )->setCanSetInStochMode (true);
   findStochAttInt ("cumShipBounds"   )->setCanSetInSolnMode  (false);

   makeStochAtt    ("execBounds"      );
   findStochAttInt ("execBounds"      )->setIsScenSpec        (true);
   findStochAttInt ("execBounds"      )->setCanSetInStochMode (true);
   findStochAttInt ("execBounds"      )->setCanSetInSolnMode  (false);
d355 1
a355 1
   stronglyAssert (findStochAttInt (theName) == NULL);
d362 1
a362 1
WitStochAtt * WitStochAttMgr::findStochAttInt (const char * theName)
@


1.67
log
@Stochastic Implosion
@
text
@d514 1
a514 1
int WitStageMgr::stageIndex (WitDelComp * theDelComp)
d516 2
a517 3
   WitNode *      theNode;
   WitDemand *    theDemand;
   WitBillEntry * theBillEnt;
d519 1
a519 1
   theNode = theDelComp->thisNode ();
d521 2
a522 2
   if (theNode != NULL)
      return stageIndex_ (theNode);
d524 1
a524 1
   theDemand = theDelComp->thisDemand ();
d526 3
a528 8
   if (theDemand != NULL)
      return stageIndex_ (theDemand->demandedPart ());

   theBillEnt = theDelComp->thisBillEnt ();

   witAssert (theBillEnt != NULL);

   return stageIndex_ (theBillEnt->myOperation ());
d533 1
a533 1
void WitStageMgr::setStageIndex (WitNode * theNode, int theValue)
d535 1
a535 6
   witAssert (theValue >= 0);
   witAssert (theValue <= 1);

   myProblem ()->prepSetStochModeAttr ("stageIndex");

   stageIndex_ (theNode) = theValue;
d540 1
a540 1
int WitStageMgr::stageIndex (WitNode * theNode)
d542 1
a542 1
   return stageIndex_ (theNode);
@


1.66
log
@Stochastic Implosion
@
text
@a18 3
//    StBSMgr
//    AbsStBS
//    StBS <DerComp>
a24 2
#include <StBSMgr.h>
#include <StBS.h>
a55 1
      myStBSMgr_     (NULL),
a68 1
   myStBSMgr_     = new WitStBSMgr    (myProblem ());
a85 1
   delete myStBSMgr_;
a644 118

//------------------------------------------------------------------------------
// Implementation of class StBSMgr.
//------------------------------------------------------------------------------

WitStBSMgr::WitStBSMgr (WitProblem * theProblem):

      WitProbAssoc  (theProblem),
      myAbsStBSFor_ (theProblem)
   {
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;

   forEachMaterial  (theMat, myProblem ())
      myAbsStBSFor_ (theMat->stockBounds ()) =
         new WitStBS <WitMaterial> (theMat);

   forEachDemand    (theDemand, myProblem ())
      myAbsStBSFor_ (theDemand->cumShipBounds ()) =
         new WitStBS <WitDemand> (theDemand);

   forEachOperation (theOpn, myProblem ())
      myAbsStBSFor_ (theOpn->execBounds ()) =
         new WitStBS <WitOperation> (theOpn);
   }

//------------------------------------------------------------------------------

WitStBSMgr::~WitStBSMgr ()
   {
   WitComponent * theComp;
   WitBoundSet *  theBoundSet;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      theBoundSet = theComp->myBoundSet ();

      if (theBoundSet != NULL)
         delete myAbsStBSFor_ (theBoundSet);
      }
   }

//------------------------------------------------------------------------------

void WitStBSMgr::writeCompSetClause (WitBoundSet * theBoundSet)
   {
   myAbsStBSFor_ (theBoundSet)->writeCompSetClause ();
   }

//------------------------------------------------------------------------------
// Implementation of class AbsStBS.
//------------------------------------------------------------------------------

WitAbsStBS::WitAbsStBS (WitProblem * theProblem):

      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitAbsStBS::~WitAbsStBS ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class template StBS <DerComp>.
//------------------------------------------------------------------------------

template <typename DerComp>
      WitStBS <DerComp>::WitStBS (DerComp * theDerComp):

         WitAbsStBS (theDerComp->myProblem ()),
         myDerComp_ (theDerComp)
   {
   }

//------------------------------------------------------------------------------

template <typename DerComp>
      WitStBS <DerComp>::~WitStBS ()
   {
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// StBS <DerComp>::writeCompSetClause ().
//------------------------------------------------------------------------------

template <> 
      void WitStBS <WitMaterial>::writeCompSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (myDerComp_->partName ());
   }

//------------------------------------------------------------------------------

template <> 
      void WitStBS <WitDemand>::writeCompSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (myDerComp_->demandedPartName ());
   myDataWriter ()->writeStringValue  (myDerComp_->demandName ());
   }

//------------------------------------------------------------------------------

template <> 
      void WitStBS <WitOperation>::writeCompSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("operation");
   myDataWriter ()->writeStringValue  (myDerComp_->operationName ());
   }
@


1.65
log
@Stochastic Implosion
@
text
@d522 25
a697 7
int WitStBSMgr::stageIndex (WitBoundSet * theBoundSet)
   {
   return myAbsStBSFor_ (theBoundSet)->stageIndex ();
   }

//------------------------------------------------------------------------------

a739 27
// StBS <DerComp>::stageIndex ().
//------------------------------------------------------------------------------

template <> 
      int WitStBS <WitMaterial>::stageIndex ()
   {
   return myStochImpMgr ()->stageIndex (myDerComp_);
   }

//------------------------------------------------------------------------------

template <> 
      int WitStBS <WitDemand>::stageIndex ()
   {
   return myStochImpMgr ()->stageIndex (myDerComp_->demandedPart ());
   }

//------------------------------------------------------------------------------

template <> 
      int WitStBS <WitOperation>::stageIndex ()
   {
   return myStochImpMgr ()->stageIndex (myDerComp_);
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
@


1.64
log
@Stochastic Implosion
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d19 3
d28 2
d61 1
d75 1
d93 1
d628 152
@


1.63
log
@Stochastic Implosion
@
text
@d272 3
a274 1
void WitStochAttMgr::makeScenInputStochAtt (const char * theName)
d276 4
a279 1
   makeStochAtt    (theName);
d373 16
a388 1
      canSetInSolnMode_  (false)
@


1.62
log
@Stochastic Implosion
@
text
@d299 4
a302 4
   makeStochAtt    ("stageNo"         );
   findStochAttInt ("stageNo"         )->setIsScenSpec        (false);
   findStochAttInt ("stageNo"         )->setCanSetInStochMode (true);
   findStochAttInt ("stageNo"         )->setCanSetInSolnMode  (false);
d407 1
a407 1
      stageNo_        (myProblem (), defStageNo ())
d425 1
a425 1
      writeStageNo (thePart, "part");
d428 1
a428 1
      writeStageNo (theOpn, "operation");
d443 1
a443 1
      myMsgFac () ("stochNodeDdMsg", stageNo_ (thePart));
d449 1
a449 1
      myMsgFac () ("stochNodeDdMsg", stageNo_ (theOpn));
d469 1
a469 1
      stageNo_ (dupPart) = origStageMgr->stageNo_ (origPart);
d479 1
a479 1
      stageNo_ (dupOpn) = origStageMgr->stageNo_ (origOpn);
d494 1
a494 1
void WitStageMgr::setStageNo (WitNode * theNode, int theValue)
d499 1
a499 1
   myProblem ()->prepSetStochModeAttr ("stageNo");
d501 1
a501 1
   stageNo_ (theNode) = theValue;
d506 1
a506 1
int WitStageMgr::stageNo (WitNode * theNode)
d508 1
a508 1
   return stageNo_ (theNode);
d513 1
a513 1
void WitStageMgr::writeStageNo (
d517 1
a517 1
   if (stageNo_ (theNode) == defStageNo ())
d525 3
a527 3
        "stageNo",
         stageNo_ (theNode),
      defStageNo ());
d537 2
a538 2
   int           stageNoforOpn;
   int           stageNoforPart;
d542 2
a543 2
      stageNoforOpn  = stageNo_ (theBomEnt->myOperation ());
      stageNoforPart = stageNo_ (theBomEnt->myPart      ());
d545 1
a545 1
      if (stageNoforOpn != stageNoforPart)
d547 2
a548 2
            stageNoforOpn,
            stageNoforPart,
d560 2
a561 2
   int           stageNoforOpn;
   int           stageNoforPart;
d565 2
a566 2
      stageNoforOpn  = stageNo_ (theSub->myOperation ());
      stageNoforPart = stageNo_ (theSub->myPart      ());
d568 1
a568 1
      if (stageNoforOpn != stageNoforPart)
d570 2
a571 2
            stageNoforOpn,
            stageNoforPart,
d584 2
a585 2
   int           stageNoforOpn;
   int           stageNoforPart;
d589 2
a590 2
      stageNoforOpn  = stageNo_ (theBopEnt->myOperation ());
      stageNoforPart = stageNo_ (theBopEnt->myPart      ());
d592 2
a593 2
      if (stageNoforOpn == 1)
         if (stageNoforPart == 0)
@


1.61
log
@Stochastic Implosion
@
text
@d294 34
a327 34
   makeStochAtt    ("probability"  );
   findStochAttInt ("probability"  )->setIsScenSpec        (true);
   findStochAttInt ("probability"  )->setCanSetInStochMode (true);
   findStochAttInt ("probability"  )->setCanSetInSolnMode  (false);

   makeStochAtt    ("stageNo"      );
   findStochAttInt ("stageNo"      )->setIsScenSpec        (false);
   findStochAttInt ("stageNo"      )->setCanSetInStochMode (true);
   findStochAttInt ("stageNo"      )->setCanSetInSolnMode  (false);

   makeStochAtt    ("stochMode"    );
   findStochAttInt ("stochMode"    )->setIsScenSpec        (false);
   findStochAttInt ("stochMode"    )->setCanSetInStochMode (true);
   findStochAttInt ("stochMode"    )->setCanSetInSolnMode  (true);

   makeStochAtt    ("curScenarioNo");
   findStochAttInt ("curScenarioNo")->setIsScenSpec        (false);
   findStochAttInt ("curScenarioNo")->setCanSetInStochMode (true);
   findStochAttInt ("curScenarioNo")->setCanSetInSolnMode  (true);

   makeStochAtt    ("stockBounds"  );
   findStochAttInt ("stockBounds"  )->setIsScenSpec        (true);
   findStochAttInt ("stockBounds"  )->setCanSetInStochMode (true);
   findStochAttInt ("stockBounds"  )->setCanSetInSolnMode  (false);

   makeStochAtt    ("cumShipBounds");
   findStochAttInt ("cumShipBounds")->setIsScenSpec        (true);
   findStochAttInt ("cumShipBounds")->setCanSetInStochMode (true);
   findStochAttInt ("cumShipBounds")->setCanSetInSolnMode  (false);

   makeStochAtt    ("execBounds"   );
   findStochAttInt ("execBounds"   )->setIsScenSpec        (true);
   findStochAttInt ("execBounds"   )->setCanSetInStochMode (true);
   findStochAttInt ("execBounds"   )->setCanSetInSolnMode  (false);
@


1.60
log
@Stochastic Implosion
@
text
@d80 1
a80 1
      discardSoln ();
d142 1
a142 1
void WitStochModeMgr::discardSoln ()
@


1.59
log
@Stochastic Implosion
@
text
@d225 3
@


1.58
log
@Stochastic Implosion
@
text
@d31 1
d224 2
@


1.57
log
@Stochastic Implosion
@
text
@d59 2
a60 1
      stochSolnMode_ (false)
a121 12
void WitStochModeMgr::uploadZeroObj ()
   {
   uploadingData_ = true;

   myOptComp ()->storeStochObjValue    (0.0);
   myOptComp ()->storeStochBoundsValue (0.0);

   uploadingData_ = false;
   }

//------------------------------------------------------------------------------

d145 4
d151 4
a154 2
   uploadSoln    ();
   uploadZeroObj ();
d156 10
a165 1
   stochSolnMode_ = false;
d167 1
a167 1
   myMsgFac () ("leaveStochSolnModeMsg");
@


1.56
log
@Stochastic Implosion
@
text
@a502 14
int WitStageMgr::stageNo (WitDemand * theDemand)
   {
   return stageNo_ (theDemand->demandedPart ());
   }

//------------------------------------------------------------------------------

int WitStageMgr::stageNo (WitBoundSet * theBoundSet)
   {
   return stageNo_ (theBoundSet->myNode ());
   }

//------------------------------------------------------------------------------

@


1.55
log
@Stochastic Implosion
@
text
@d26 1
d56 1
d66 3
a68 2
   myStageMgr_    = new WitStageMgr (this);
   myScenMgr_     = new WitScenMgr  (this);
d82 1
d92 3
a94 2
   myStageMgr_->copyAttrsFrom (theStochModeMgr->myStageMgr_);
   myScenMgr_ ->copyAttrsFrom (theStochModeMgr->myScenMgr_);
d103 1
a103 1
   myScenMgr_->curScenario ()->uploadInput ();
d114 1
a114 1
   myScenMgr_->curScenario ()->uploadSoln ();
a153 2
   WitScenario * theScenario;

d156 1
a156 2
   forEachEl (theScenario, myScenMgr_->myScenarios ())
      theScenario->clearSoln ();
@


1.54
log
@Stochastic Implosion
@
text
@d40 1
d508 1
a508 1
int WitStageMgr::stageNo (WitBoundSet *)
d510 1
a510 1
   return 1;
@


1.53
log
@Stochastic Implosion
@
text
@d300 15
d507 7
@


1.52
log
@Stochastic Implosion
@
text
@d238 1
a238 2
   makeStochAtts      ();
   configureStochAtts ();
d261 4
a264 1
   makeStochAtt (theName);
d272 1
d274 1
d281 19
a299 4
   makeStochAtt ("probability"  );
   makeStochAtt ("stageNo"      );
   makeStochAtt ("stochMode"    );
   makeStochAtt ("curScenarioNo");
a312 12
void WitStochAttMgr::configureStochAtts ()
   {
   findStochAttInt ("stageNo"      )->setScenSpec          (false);
   findStochAttInt ("stochMode"    )->setScenSpec          (false);
   findStochAttInt ("curScenarioNo")->setScenSpec          (false);

   findStochAttInt ("stochMode"    )->setCanSetInSolnMode  (true);
   findStochAttInt ("curScenarioNo")->setCanSetInSolnMode  (true);
   }

//------------------------------------------------------------------------------

d338 2
a339 2
      scenSpec_          (true),
      canSetInStochMode_ (true),
d352 1
a352 1
void WitStochAtt::setScenSpec (bool theValue)
d354 1
a354 1
   scenSpec_ = theValue;
@


1.51
log
@Stochastic Implosion
@
text
@d260 15
a276 3
   makeStochAtt ("supplyVol"    );
   makeStochAtt ("demandVol"    );

a277 1

a278 1

a280 7

   makeStochAtt ("scrapVol"     );
   makeStochAtt ("stockVol"     );
   makeStochAtt ("shipVol"      );
   makeStochAtt ("cumShipVol"   );
   makeStochAtt ("execVol"      );
   makeStochAtt ("subVol"       );
a299 7
   findStochAttInt ("scrapVol"     )->setCanSetInStochMode (false);
   findStochAttInt ("stockVol"     )->setCanSetInStochMode (false);
   findStochAttInt ("shipVol"      )->setCanSetInStochMode (false);
   findStochAttInt ("cumShipVol"   )->setCanSetInStochMode (false);
   findStochAttInt ("execVol"      )->setCanSetInStochMode (false);
   findStochAttInt ("subVol"       )->setCanSetInStochMode (false);

@


1.50
log
@Stochastic Implosion
@
text
@d56 1
a56 3
      stochSolnMode_ (false),
      curWriteComp_  (NULL),
      vectorWritten_ (false)
a126 42
void WitStochModeMgr::startWriteCompData (WitComponent * theComp)
   {
   stronglyAssert (curWriteComp_ == NULL);

   curWriteComp_ = theComp;
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::finishWriteCompData ()
   {
   stronglyAssert (curWriteComp_ != NULL);

   if (vectorWritten_)
      myDataWriter ()->writeEndCommand ();

   vectorWritten_ = false;
   curWriteComp_  = NULL;
   }

//------------------------------------------------------------------------------

bool WitStochModeMgr::isWritingComp ()
   {
   return (curWriteComp_ != NULL);
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::prepWriteVector ()
   {
   if (curWriteComp_ != NULL)
      if (not vectorWritten_)
         {
         curWriteComp_->writeDataSetClause ();

         vectorWritten_ = true;
         }
   }

//------------------------------------------------------------------------------

@


1.49
log
@Stochastic Implosion
@
text
@a26 1
#include <ScenAttMgr.h>
a53 1
      myScenAttMgr_  (NULL),
d65 2
a66 3
   myStageMgr_    = new WitStageMgr   (this);
   myScenMgr_     = new WitScenMgr    (this);
   myScenAttMgr_  = new WitScenAttMgr (this);
a80 1
   delete myScenAttMgr_;
d89 2
a90 3
   myStageMgr_  ->copyAttrsFrom      (theStochModeMgr->myStageMgr_);
   myScenMgr_   ->copyAttrsFrom      (theStochModeMgr->myScenMgr_);
   myScenAttMgr_->copyInputAttrsFrom (theStochModeMgr->myScenAttMgr_);
d99 1
a99 1
   myScenAttMgr_->uploadInputFromCurScen ();
d110 1
a110 1
   myScenAttMgr_->uploadSolnFromCurScen ();
d196 2
a197 1
   myScenAttMgr_->clearSoln ();
@


1.48
log
@Stochastic Implosion.
@
text
@a510 18
void WitStageMgr::checkAttsInStage0 (
      WitScenario * theScenario1,
      WitScenario * theScenario2)
   {
   WitPart *   thePart;
   WitDemand * theDemand;

   forEachPart (thePart, myProblem ())
      if (stageNo_ (thePart) == 0)
         theScenario1->checkAttsMatch (thePart, theScenario2);

   forEachDemand (theDemand, myProblem ())
      if (stageNo_ (theDemand->demandedPart ()) == 0)
         theScenario1->checkAttsMatch (theDemand, theScenario2);
   }

//------------------------------------------------------------------------------

d523 14
@


1.47
log
@Stochastic Implosion
@
text
@d93 3
a95 2
   myScenMgr_ ->copyAttrsFrom (theStochModeMgr->myScenMgr_);
   myStageMgr_->copyAttrsFrom (theStochModeMgr->myStageMgr_);
@


1.46
log
@Stochastic Implosion
@
text
@d121 1
a121 1
void WitStochModeMgr::uploadZeroSoln ()
a122 4
   WitTVec <double> zeroVec;

   zeroVec.allocate (myProblem (), 0.0);

a127 2
   myScenAttMgr_->uploadZeroSoln ();

d200 1
a200 1
   myScenAttMgr_->clearScenSoln ();
d202 2
a203 1
   uploadZeroSoln ();
@


1.45
log
@Stochastic Implosion
@
text
@d121 1
a121 1
void WitStochModeMgr::clearSoln ()
a123 5
   WitPart *        thePart;
   WitMaterial *    theMat;
   WitDemand *      theDemand;
   WitOperation *   theOpn;
   WitSubEntry *    theSub;
d132 1
a132 17
   forEachPart     (thePart,   myProblem ())
      thePart  ->storeStochScrapVol    (zeroVec);

   forEachMaterial (theMat,    myProblem ())
      theMat   ->storeStochStockVol    (zeroVec);

   forEachDemand   (theDemand, myProblem ())
      {
      theDemand->storeStochShipVol     (zeroVec);
      theDemand->storeStochCumShipVol  (zeroVec);
      }

   forEachOperation (theOpn,   myProblem ())
      theOpn   ->storeStochExecVol     (zeroVec);

   forEachSubEntry  (theSub,   myProblem ())
      theSub   ->storeStochSubVol      (zeroVec);
d208 1
a208 1
   clearSoln ();
@


1.44
log
@Stochastic Implosion
@
text
@d227 1
a227 2
   forEachEl (theScenario, myScenMgr_->myScenarios ())
      theScenario->clearSoln ();
@


1.43
log
@Stochastic Implosion
@
text
@d69 1
a69 1
   myScenAttMgr_  = new WitScenAttMgr (myScenMgr_);
@


1.42
log
@Stochastic Implosion
@
text
@d103 1
a103 1
   myScenMgr_->curScenario ()->uploadInput ();
d114 1
a114 1
   myScenMgr_->curScenario ()->uploadSoln ();
@


1.41
log
@Stochastic Implosion
@
text
@a61 2
   WitScenario * theScenario;

d69 1
a69 4
   myScenAttMgr_  = new WitScenAttMgr (myProblem ());

   forEachEl (theScenario, myScenMgr_->myScenarios ())
      theScenario->downloadInputAttrs ();
@


1.40
log
@Stochastic Implosion
@
text
@d62 2
d73 3
@


1.39
log
@Stochastic Implosion
@
text
@d27 1
d55 1
d67 3
a69 2
   myStageMgr_    = new WitStageMgr (this);
   myScenMgr_     = new WitScenMgr  (this);
d84 1
@


1.38
log
@Stochastic Implosion
@
text
@d130 2
a131 2
   myOptComp ()->loadInStochObjValue    (0.0);
   myOptComp ()->loadInStochBoundsValue (0.0);
d134 1
a134 1
      thePart  ->loadInStochScrapVol    (zeroVec);
d137 1
a137 1
      theMat   ->loadInStochStockVol    (zeroVec);
d141 2
a142 2
      theDemand->loadInStochShipVol     (zeroVec);
      theDemand->loadInStochCumShipVol  (zeroVec);
d146 1
a146 1
      theOpn   ->loadInStochExecVol     (zeroVec);
d149 1
a149 1
      theSub   ->loadInStochSubVol      (zeroVec);
d241 1
a241 1
   myOptComp ()->loadInStochObjValue (theValue);
d254 1
a254 1
   myOptComp ()->loadInStochBoundsValue (theValue);
@


1.37
log
@Stochastic Implosion
@
text
@a54 2
      exportingSoln_ (false),
      clearingSoln_  (false),
d95 1
a95 1
void WitStochModeMgr::exportSoln ()
d97 1
a97 1
   WitComponent * theComp;
d99 1
a99 1
   exportingSoln_ = true;
d101 1
a101 4
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importStochSoln ();

   exportingSoln_ = false;
d106 1
a106 1
void WitStochModeMgr::clearSoln ()
d108 1
a108 1
   WitComponent * theComp;
d110 1
a110 1
   clearingSoln_ = true;
d112 1
a112 4
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importStochSoln ();

   clearingSoln_ = false;
d117 1
a117 1
void WitStochModeMgr::uploadInput ()
d119 9
d130 20
a149 1
   myScenMgr_->curScenario ()->uploadInput ();
a222 2
   clearSoln ();

d226 2
d235 26
@


1.36
log
@Stochastic Implosion
@
text
@d49 1
a49 1
      WitProbAssoc    (theProblem),
d51 10
a60 10
      myStochAttMgr_  (NULL),
      myStageMgr_     (NULL),
      myScenMgr_      (NULL),
      myStochOptMgr_  (NULL),
      exportingInput_ (false),
      exportingSoln_  (false),
      clearingSoln_   (false),
      stochSolnMode_  (false),
      curWriteComp_   (NULL),
      vectorWritten_  (false)
d97 1
a97 1
void WitStochModeMgr::exportInput ()
d101 1
a101 1
   exportingInput_ = true;
d104 1
a104 1
      theComp->importStochInput ();
d106 1
a106 1
   exportingInput_ = false;
d111 1
a111 1
void WitStochModeMgr::exportSoln ()
d115 1
a115 1
   exportingSoln_ = true;
d120 1
a120 1
   exportingSoln_ = false;
d125 1
a125 1
void WitStochModeMgr::clearSoln ()
d127 1
a127 3
   WitComponent * theComp;

   clearingSoln_ = true;
d129 1
a129 2
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importStochSoln ();
d131 1
a131 1
   clearingSoln_ = false;
a287 1
   makeStochAtt ("cumDemandVol" );
a320 1
   findStochAttInt ("cumDemandVol" )->setCanSetInStochMode (false);
@


1.35
log
@Stochastic Implosion
@
text
@a242 2

   verifyBounds ();
a256 33

#include <BoundSet.h>

void WitStochModeMgr::verifyBounds ()
   {
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitPeriod      thePer;

   forEachMaterial (theMat, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (
              theMat->stockBounds ()->softLB ()[thePer]
            > theMat->stockBounds ()->hardLB ()[thePer])
         myMsgFac () ("softLBStochModeSmsg");

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (
              theDemand->cumShipBounds ()->softLB ()[thePer]
            > theDemand->cumShipBounds ()->hardLB ()[thePer])
         myMsgFac () ("softLBStochModeSmsg");

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (
              theOpn->execBounds ()->softLB ()[thePer]
            > theOpn->execBounds ()->hardLB ()[thePer])
         myMsgFac () ("softLBStochModeSmsg");
   }

//------------------------------------------------------------------------------
@


1.34
log
@Stochastic Implosion
@
text
@d267 1
d270 5
a274 2
      if (not (theMat->stockBounds ()->isAtDefault ()))
         myMsgFac () ("nonDefBoundStochModeSmsg");
d277 5
a281 2
      if (not (theDemand->cumShipBounds ()->isAtDefault ()))
         myMsgFac () ("nonDefBoundStochModeSmsg");
d284 5
a288 2
      if (not (theOpn->execBounds ()->isAtDefault ()))
         myMsgFac () ("nonDefBoundStochModeSmsg");
@


1.33
log
@Stochastic Implosion
@
text
@d243 2
d259 23
@


1.32
log
@Stochastic Implosion
@
text
@a509 20
void WitStageMgr::verifyAllStage1 ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   forEachPart (thePart, myProblem ())
      if (stageNo_ (thePart) != 1)
         myMsgFac () ("stochImpStage0NodeSmsg",
            myMsgFac ().myFrag ("partFrag"),
            thePart->partName ());

   forEachOperation (theOpn, myProblem ())
      if (stageNo_ (theOpn) != 1)
         myMsgFac () ("stochImpStage0NodeSmsg",
            myMsgFac ().myFrag ("operationFrag"),
            theOpn->operationName ());
   }

//------------------------------------------------------------------------------

a606 8


      if (stageNoforOpn == 0)
         if (stageNoforPart == 1)
            myMsgFac () ("bopEntStageTempMisMatchSmsg",
               theBopEnt->myOperationName (),
               theBopEnt->localIndex (),
               theBopEnt->myPartName ());
@


1.31
log
@Stochastic Implosion
@
text
@d627 8
@


1.30
log
@Stochastic Implosion
@
text
@d295 1
a295 1
   makeStochAtt ("recourseStage");
d321 1
a321 1
   findStochAttInt ("recourseStage")->setScenSpec          (false);
d405 1
a405 1
      recourseStage_  (myProblem (), defRecourseStage ())
d423 1
a423 1
      writeRecourseStage (thePart, "part");
d426 1
a426 1
      writeRecourseStage (theOpn, "operation");
d440 2
a441 3
      myMsgFac () ("partIdDdMsg", thePart->partName ());

      myMsgFac () ("stochNodeDdMsg", recourseStage_ (thePart));
d446 2
a447 3
      myMsgFac () ("opnIdDdMsg", theOpn->operationName ());

      myMsgFac () ("stochNodeDdMsg", recourseStage_ (theOpn));
d467 1
a467 1
      recourseStage_ (dupPart) = origStageMgr->recourseStage_ (origPart);
d477 1
a477 1
      recourseStage_ (dupOpn) = origStageMgr->recourseStage_ (origOpn);
d492 1
a492 1
void WitStageMgr::checkNonRecAtts (
d500 1
a500 1
      if (not recourseStage_ (thePart))
d504 1
a504 1
      if (not recourseStage_ (theDemand->demandedPart ()))
d510 1
a510 1
void WitStageMgr::verifyAllRecourse ()
d516 2
a517 2
      if (not recourseStage_ (thePart))
         myMsgFac () ("stochImpNonRecNodeSmsg",
d522 2
a523 2
      if (not recourseStage_ (theOpn))
         myMsgFac () ("stochImpNonRecNodeSmsg",
d530 1
a530 1
void WitStageMgr::setRecourseStage (WitNode * theNode, bool theValue)
d532 2
a533 1
   myProblem ()->prepSetStochModeAttr ("recourseStage");
d535 3
a537 1
   recourseStage_ (theNode) = theValue;
d542 1
a542 1
void WitStageMgr::writeRecourseStage (
d546 1
a546 1
   if (recourseStage_ (theNode) == defRecourseStage ())
d553 4
a556 4
   myDataWriter ()->writeBool (
        "recourseStage",
         recourseStage_ (theNode),
      defRecourseStage ());
d566 2
d571 10
a580 17
      if (recourseStage_ (theBomEnt->myOperation ()))
         if (not recourseStage_ (theBomEnt->myPart ()))
            myMsgFac () ("bomEntRecMisMatchSmsg",
               true,
               false,
               theBomEnt->myOperationName (),
               theBomEnt->localIndex (),
               theBomEnt->myPartName ());

      if (not recourseStage_ (theBomEnt->myOperation ()))
         if (recourseStage_ (theBomEnt->myPart ()))
            myMsgFac () ("bomEntRecMisMatchSmsg",
               false,
               true,
               theBomEnt->myOperationName (),
               theBomEnt->localIndex (),
               theBomEnt->myPartName ());
d589 2
d594 11
a604 19
      if (recourseStage_ (theSub->myOperation ()))
         if (not recourseStage_ (theSub->myPart ()))
            myMsgFac () ("subRecMisMatchSmsg",
               true,
               false,
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               theSub->myPartName ());

      if (not recourseStage_ (theSub->myOperation ()))
         if (recourseStage_ (theSub->myPart ()))
            myMsgFac () ("subRecMisMatchSmsg",
               false,
               true,
               theSub->myOperationName (),
               theSub->myBomEntIndex (),
               theSub->localIndex (),
               theSub->myPartName ());
d613 2
d617 7
a623 3
      if (recourseStage_ (theBopEnt->myOperation ()))
         if (not recourseStage_ (theBopEnt->myPart ()))
            myMsgFac () ("bopEntRecMisMatchSmsg",
d627 1
@


1.29
log
@Stochastic Implosion
@
text
@d293 1
a293 1
   makeStochAtt ("probability" );
d298 1
a298 1
   makeStochAtt ("scenarioIndex");
d323 1
a323 1
   findStochAttInt ("scenarioIndex")->setScenSpec          (false);
d334 1
a334 1
   findStochAttInt ("scenarioIndex")->setCanSetInSolnMode  (true);
@


1.28
log
@Stochastic Implosion
@
text
@d293 1
a293 1
   makeStochAtt ("scenarioProb" );
@


1.27
log
@Stochastic Implosion
@
text
@a58 2
      objValue_       (0.0),
      boundsValue_    (0.0),
d181 1
a181 51
void WitStochModeMgr::implodeSeriesLP ()
   {
   WitScenario * origCurScenario;
   WitScenario * theScenario;
   double        scenProb;

   stronglyAssert (WitOptComp::optImpAllowed ());

   stronglyAssert (not stochSolnMode_);

   myMsgFac () ("stochImpMsg");

   myStageMgr_->validateData      ();
   myScenMgr_ ->validateData      ();
   myStageMgr_->verifyAllRecourse ();

   myScenMgr_->curScenario ()->saveInputAttrs ();

   origCurScenario = myScenMgr_->curScenario ();

   objValue_    = 0.0;
   boundsValue_ = 0.0;

   forEachEl (theScenario, myScenMgr_->myScenarios ())
      {
      myScenMgr_->setScenarioForImplode (theScenario);

      myDetOptImpMgr ()->implode ();

      myScenMgr_->curScenario ()->saveSolnAttrs ();

      scenProb = myScenMgr_->curScenario ()->scenarioProb ();

      objValue_    += myOptComp ()->objValue    () * scenProb;
      boundsValue_ += myOptComp ()->boundsValue () * scenProb;
      }

   myScenMgr_->setScenarioForImplode (origCurScenario);

   exportSoln ();

   myPostprocessor ()->postprocess ();

   stochSolnMode_ = true;

   myMsgFac () ("enterStochSolnModeMsg");
   }

//------------------------------------------------------------------------------

void WitStochModeMgr::implodeSingleLP ()
a210 2
   objValue_      = 0.0;
   boundsValue_   = 0.0;
@


1.26
log
@Stochastic Implosion
@
text
@a194 2
   myMsgFac () ("stochSeriesLPMsg");

@


1.25
log
@Stochastic Implosion
@
text
@d347 1
d381 1
@


1.24
log
@Stochastic Implosion
@
text
@d246 4
@


1.23
log
@Stochastic Implosion
@
text
@d150 13
a182 13
void WitStochModeMgr::finishWriteCompData ()
   {
   stronglyAssert (curWriteComp_ != NULL);

   if (vectorWritten_)
      myDataWriter ()->writeEndCommand ();

   vectorWritten_ = false;
   curWriteComp_  = NULL;
   }

//------------------------------------------------------------------------------

@


1.22
log
@Stochastic Implosion
@
text
@d28 1
a28 1
#include <StochImp.h>
d49 1
a49 1
      WitProbAssoc     (theProblem),
d51 12
a62 12
      myStochAttMgr_   (NULL),
      myStageMgr_      (NULL),
      myScenMgr_       (NULL),
      myStochImploder_ (NULL),
      exportingInput_  (false),
      exportingSoln_   (false),
      clearingSoln_    (false),
      stochSolnMode_   (false),
      objValue_        (0.0),
      boundsValue_     (0.0),
      curWriteComp_    (NULL),
      vectorWritten_   (false)
d237 1
a237 1
   stronglyAssert (myStochImploder_ == NULL);
d239 1
a239 1
   myStochImploder_ = new WitStochImploder (this);
d241 1
a241 1
   myStochImploder_->implode ();
d243 1
a243 1
   delete myStochImploder_;
d245 1
a245 1
   myStochImploder_ = NULL;
@


1.21
log
@Stochastic Implosion
@
text
@d31 1
a31 1
#include <OptImp.h>
d212 1
a212 1
      myOptImploder ()->implode ();
@


1.20
log
@Stochastic Implosion
@
text
@d453 1
a453 2
      WitProbAssoc    (theStochModeMgr->myProblem ()),

@


1.19
log
@Stochastic Implosion
@
text
@d197 1
a198 1
   myStageMgr_->validateData      ();
@


1.18
log
@Stochastic Implosion
@
text
@d554 1
a554 1
         theScenario1->checkStochAttsMatch (thePart, theScenario2);
d558 1
a558 1
         theScenario1->checkStochAttsMatch (theDemand, theScenario2);
@


1.17
log
@Stochastic Implosion
@
text
@d35 1
d197 3
a199 2
   myScenMgr_ ->validateData ();
   myStageMgr_->validateData ();
d538 41
a578 4
   validateBomEnts   ();
   validateSubs      ();
   validateBopEnts   ();
   verifyAllRecourse ();
a682 20

//------------------------------------------------------------------------------

void WitStageMgr::verifyAllRecourse ()
   {
   WitPart *      thePart;
   WitOperation * theOpn;

   forEachPart (thePart, myProblem ())
      if (not recourseStage_ (thePart))
         myMsgFac () ("stochImpNonRecNodeSmsg",
            myMsgFac ().myFrag ("partFrag"),
            thePart->partName ());

   forEachOperation (theOpn, myProblem ())
      if (not recourseStage_ (theOpn))
         myMsgFac () ("stochImpNonRecNodeSmsg",
            myMsgFac ().myFrag ("operationFrag"),
            theOpn->operationName ());
   }
@


1.16
log
@Stochastic Implosion
@
text
@d485 2
d491 1
a491 1
      display (thePart);
d496 3
a503 7
void WitStageMgr::display (WitNode * theNode)
   {
   myMsgFac () ("stochNodeDdMsg", recourseStage_ (theNode));
   }

//------------------------------------------------------------------------------

@


1.15
log
@Stochastic Implosion
@
text
@d480 19
@


1.14
log
@Stochastic Implosion
@
text
@d13 1
a13 1
// Contains the implementation of the following classes
a18 2
//    ScenMgr
//    Scenario
a34 1
#include <Demand.h>
a646 520

//------------------------------------------------------------------------------
// Implementation of class ScenMgr.
//------------------------------------------------------------------------------

WitScenMgr::WitScenMgr (WitStochModeMgr * theStochModeMgr):

      WitProbAssoc    (theStochModeMgr->myProblem ()),

      myStochModeMgr_ (theStochModeMgr),
      nScenarios_     (myStochImpMgr ()->nScenarios ()),
      myScenarios_    (),
      myScenByIdx_    (myStochImpMgr ()->nScenarios ()),
      curScenario_    (NULL)
   {
   int            theIdx;
   WitScenario *  theScenario;

   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      {
      theScenario          = new WitScenario (this, theIdx);

      myScenarios_.append (theScenario);

      myScenByIdx_[theIdx] = theScenario;
      }

   curScenario_ = myScenByIdx_[0];
   }

//------------------------------------------------------------------------------

WitScenMgr::~WitScenMgr ()
   {
   int theIdx;

   curScenario_ = NULL;

   myScenByIdx_.clear ();

   while (not myScenarios_.isEmpty ())
      delete myScenarios_.get ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::copyAttrsFrom (WitScenMgr * theScenMgr)
   {
   int           theIdx;
   WitScenario * dupScenario;
   WitScenario * origScenario;

   theIdx        = theScenMgr->curScenario_->myIndex ();

   curScenario_  = myScenByIdx_[theIdx];

   forEachEl (dupScenario, myScenarios_)
      {
      theIdx       = dupScenario->myIndex ();

      origScenario = theScenMgr->myScenByIdx_[theIdx];

      dupScenario->copyAttrsFrom (origScenario);
      }
   }

//------------------------------------------------------------------------------

void WitScenMgr::writeData ()
   {
   WitScenario * theScenario;

   if (not myStochModeMgr_->stochSolnMode ())
      curScenario_->saveInputAttrs ();

   forEachEl (theScenario, myScenarios_)
      theScenario->writeData ();

   myMsgFac () ("finalScenIdxWdMsg");

   curScenario_->writeScenarioIndex ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::display ()
   {
   WitScenario * theScenario;

   if (not myStochModeMgr_->stochSolnMode ())
      curScenario_->saveInputAttrs ();

   myMsgFac () ("stochImploderDdMsg", curScenario_->myIndex ());

   forEachEl (theScenario, myScenarios_)
      theScenario->display ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::validateData ()
   {
   checkScenarioProbs ();
   checkNonRecAtts    ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::setScenarioIndex (int theIdx)
   {
   myProblem ()->prepSetStochModeAttr ("scenarioIndex");

   if (not myStochModeMgr_->stochSolnMode ())
      curScenario_->saveInputAttrs ();
                                  
   curScenario_ = myScenByIdx_[theIdx];

   myStochModeMgr_->exportInput ();

   if (myStochModeMgr_->stochSolnMode ())
      {
      myStochModeMgr_->exportSoln ();

      myPostprocessor ()->postprocess ();
      }
   }

//------------------------------------------------------------------------------

void WitScenMgr::setScenarioForImplode (WitScenario * theScenario)
   {
   curScenario_ = theScenario;

   myStochModeMgr_->exportInput ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::checkScenarioProbs ()
   {
   double        totProb;
   WitScenario * theScenario;

   totProb = 0.0;

   forEachEl (theScenario, myScenarios_)
      totProb += theScenario->scenarioProb ();

   if (fabs (totProb - 1.0) > 0.001)
      myMsgFac () ("totScenProbNeq1Smsg", totProb);
   }

//------------------------------------------------------------------------------

void WitScenMgr::checkNonRecAtts ()
   {
   WitScenario * firstScenario;
   WitScenario * otherScenario;

   firstScenario = myScenByIdx_[0];

   forEachEl (otherScenario, myScenarios_)
      if (otherScenario != firstScenario)
         firstScenario->checkNonRecAtts (otherScenario);
   }

//------------------------------------------------------------------------------
// Implementation of class Scenario.
//------------------------------------------------------------------------------

WitScenario::WitScenario (WitScenMgr * theScenMgr, int theIdx):

      WitProbAssoc  (theScenMgr->myProblem ()),

      myScenMgr_    (theScenMgr),
      myIndex_      (theIdx),
      scenarioProb_ (defScenarioProb ()),
      supplyVol_    (myProblem (), 0.0),
      demandVol_    (myProblem (), 0.0),

      scrapVol_     (),
      stockVol_     (),
      shipVol_      (),
      cumShipVol_   (),
      execVol_      (),
      subVol_       ()
   {
   saveInputAttrsInt ();
   }

//------------------------------------------------------------------------------

WitScenario::~WitScenario ()
   {
   }

//------------------------------------------------------------------------------

void WitScenario::saveInputAttrs ()
   {
   stronglyAssert (this == myScenMgr_->curScenario ());

   saveInputAttrsInt ();
   }

//------------------------------------------------------------------------------

void WitScenario::saveSolnAttrs ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   stronglyAssert (this == myScenMgr_->curScenario ());

   scrapVol_  .allocate (myProblem (), 0.0);
   stockVol_  .allocate (myProblem (), 0.0);
   shipVol_   .allocate (myProblem (), 0.0);
   cumShipVol_.allocate (myProblem (), 0.0);
   execVol_   .allocate (myProblem (), 0.0);
   subVol_    .allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      scrapVol_   (thePart)   = thePart  ->scrapVol   ();
      }

   forEachMaterial (theMat, myProblem ())
      {
      stockVol_   (theMat)    = theMat   ->stockVol   ();
      }

   forEachDemand (theDemand, myProblem ())
      {
      shipVol_    (theDemand) = theDemand->shipVol    ();
      cumShipVol_ (theDemand) = theDemand->cumShipVol ();
      }

   forEachOperation (theOpn, myProblem ())
      {       
      execVol_    (theOpn)    = theOpn   ->execVol    ();
      }

   forEachSubEntry (theSub, myProblem ())
      {       
      subVol_     (theSub)    = theSub   ->subVol     ();
      }
   }

//------------------------------------------------------------------------------

void WitScenario::clearSoln ()
   {
   scrapVol_  .clear ();
   stockVol_  .clear ();
   shipVol_   .clear ();
   cumShipVol_.clear ();
   execVol_   .clear ();
   subVol_    .clear ();
   }

//------------------------------------------------------------------------------

void WitScenario::copyAttrsFrom (WitScenario * theScenario)
   {
   scenarioProb_ = theScenario->scenarioProb_;
   supplyVol_    = theScenario->supplyVol_;
   demandVol_    = theScenario->demandVol_;
   }

//------------------------------------------------------------------------------

void WitScenario::writeData ()
   {
   myMsgFac () ("scenarioHeadingWdMsg", myIndex_);

   writeScenarioIndex ();

   writeScenarioProb ();

   writePartData   ();
   writeDemandData ();
   }

//------------------------------------------------------------------------------

void WitScenario::writeScenarioIndex ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

   myDataWriter ()->writeDouble (
      "scenarioIndex",
       myIndex_,
       -1);

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitScenario::display ()
   {
   myMsgFac () ("scenarioDdMsg",
      myIndex_,
      scenarioProb_);

   displayPartData   ();
   displayDemandData ();
   }

//------------------------------------------------------------------------------

void WitScenario::checkNonRecAtts (WitScenario * otherScenario)
   {
   checkNonRecPartAtts   (otherScenario);
   checkNonRecDemandAtts (otherScenario);
   }

//------------------------------------------------------------------------------

double WitScenario::defScenarioProb ()
   {
   return 1.0 / static_cast <double> (myStochImpMgr ()->nScenarios ());
   }

//------------------------------------------------------------------------------

void WitScenario::setScenarioProb (double theValue)
   {
   stronglyAssert (theValue >= 0.0);
   stronglyAssert (theValue <= 1.0 + FEAS_TOL);

   myProblem ()->prepSetStochModeAttr ("scenarioProb");

   scenarioProb_ = theValue;
   }

//------------------------------------------------------------------------------

void WitScenario::saveInputAttrsInt ()
   {
   WitPart * thePart;
   WitDemand * theDemand;

   forEachPart (thePart, myProblem ())
      supplyVol_ (thePart) = thePart->supplyVol ();

   forEachDemand (theDemand, myProblem ())
      demandVol_ (theDemand) = theDemand->demandVol ();
   }

//------------------------------------------------------------------------------

void WitScenario::writeScenarioProb ()
   {
   if (scenarioProb_ == defScenarioProb ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

   myDataWriter ()->writeDouble (
      "scenarioProb",
       scenarioProb_,
       defScenarioProb ());

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

void WitScenario::writePartData ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      {
      myScenMgr_->myStochModeMgr ()->startWriteCompData (thePart);

      myDataWriter ()->writeVector (
         "supplyVol",
         supplyVol_ (thePart),
         WitPart::defSupplyVol ());

      myScenMgr_->myStochModeMgr ()->finishWriteCompData ();
      }
   }

//------------------------------------------------------------------------------

void WitScenario::writeDemandData ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      {
      myScenMgr_->myStochModeMgr ()->startWriteCompData (theDemand);

      myDataWriter ()->writeVector (
         "demandVol",
         demandVol_ (theDemand),
         WitDemand::defDemandVol ());

      myScenMgr_->myStochModeMgr ()->finishWriteCompData ();
      }
   }

//------------------------------------------------------------------------------

void WitScenario::displayPartData ()
   {
   WitPart *     thePart;
   WitDblFlexVec theDblFlexVec (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      myMsgFac () ("partIdDdMsg", thePart->partName ());

      theDblFlexVec = supplyVol_ (thePart);

      myProblem ()->display ("extSupplyVolDdMsg", theDblFlexVec);
      }
   }

//------------------------------------------------------------------------------

void WitScenario::displayDemandData ()
   {
   WitDemand *   theDemand;
   WitDblFlexVec theDblFlexVec (myProblem (), 0.0);

   forEachDemand (theDemand, myProblem ())
      {
      myMsgFac () ("demandIdDdMsg",
         theDemand->demandedPartName (),
         theDemand->demandName ());

      theDblFlexVec = demandVol_ (theDemand);

      myProblem ()->display ("demVolDdMsg", theDblFlexVec);
      }
   }

//------------------------------------------------------------------------------

void WitScenario::checkNonRecPartAtts (WitScenario * otherScenario)
   {
   WitPart * thePart;
   bool      recPart;
   WitPeriod thePer;
   double    supVol1;
   double    supVol2;

   forEachPart (thePart, myProblem ())
      {
      recPart =
         myScenMgr_->
            myStochModeMgr ()->
               myStageMgr ()->
                  recourseStage () (thePart);

      if (not recPart)
         forEachPeriod (thePer, myProblem ())
            {
            supVol1 =                supplyVol_ (thePart)[thePer];
            supVol2 = otherScenario->supplyVol_ (thePart)[thePer];

            if (supVol1 != supVol2)
               myMsgFac () ("nonRecPartAttMisMatchSmsg",
                  "supplyVol",
                  thePart->partName (),
                  thePer,
                  myIndex_,
                  supVol1,
                  otherScenario->myIndex_,
                  supVol2);
            }
      }
   }

//------------------------------------------------------------------------------

void WitScenario::checkNonRecDemandAtts (WitScenario * otherScenario)
   {
   WitDemand * theDemand;
   bool        recDem;
   WitPeriod   thePer;
   double      demVol1;
   double      demVol2;

   forEachDemand (theDemand, myProblem ())
      {
      recDem =
         myScenMgr_->
            myStochModeMgr ()->
               myStageMgr ()->
                  recourseStage () (theDemand->demandedPart ());

      if (not recDem)
         forEachPeriod (thePer, myProblem ())
            {
            demVol1 =                demandVol_ (theDemand)[thePer];
            demVol2 = otherScenario->demandVol_ (theDemand)[thePer];

            if (demVol1 != demVol2)
               myMsgFac () ("nonRecDemAttMisMatchSmsg",
                  "demandVol",
                  theDemand->demandedPartName (),
                  theDemand->demandName (),
                  thePer,
                  myIndex_,
                  demVol1,
                  otherScenario->myIndex_,
                  demVol2);
            }
      }
   }
@


1.13
log
@Stochastic Implosion
@
text
@d373 13
a385 13
   findStochAttInt ("scrapVol"     )->setStochModeOK     (false);
   findStochAttInt ("stockVol"     )->setStochModeOK     (false);
   findStochAttInt ("shipVol"      )->setStochModeOK     (false);
   findStochAttInt ("cumShipVol"   )->setStochModeOK     (false);
   findStochAttInt ("execVol"      )->setStochModeOK     (false);
   findStochAttInt ("subVol"       )->setStochModeOK     (false);

   findStochAttInt ("stochMode"    )->setStochSolnModeOK (true);
   findStochAttInt ("scenarioIndex")->setStochSolnModeOK (true);

   findStochAttInt ("recourseStage")->setScenSpec        (false);
   findStochAttInt ("stochMode"    )->setScenSpec        (false);
   findStochAttInt ("scenarioIndex")->setScenSpec        (false);
d414 4
a417 4
      myName_          (theName),
      stochModeOK_     (true),
      stochSolnModeOK_ (false),
      scenSpec_        (true)
d429 1
a429 1
void WitStochAtt::setStochModeOK (bool theValue)
d431 1
a431 1
   stochModeOK_ = theValue;
d436 1
a436 1
void WitStochAtt::setStochSolnModeOK (bool theValue)
d438 1
a438 1
   stochSolnModeOK_ = theValue;
d443 1
a443 1
void WitStochAtt::setScenSpec (bool theValue)
d445 1
a445 1
   scenSpec_ = theValue;
@


1.12
log
@Stochastic Implosion
@
text
@d16 2
d24 2
d53 1
a62 2
      ssiAttNames_     (),
      tempSsiAttNames_ (),
d70 3
a72 4
   myStageMgr_ = new WitStageMgr (this);
   myScenMgr_  = new WitScenMgr  (this);

   setUpSsiAttNames ();
a80 2
   int theIdx;

a85 3
   for (theIdx = 0; theIdx < ssiAttNames_.length (); theIdx ++)
      delete ssiAttNames_[theIdx];

d88 1
a88 28
   }

//------------------------------------------------------------------------------

bool WitStochModeMgr::isSsiAttName (const char * theAttName)
   {
   int loIdx;
   int hiIdx;
   int theIdx;

   loIdx = -1;
   hiIdx = ssiAttNames_.length ();

   while (hiIdx - loIdx > 1)
      {
      theIdx = (loIdx + hiIdx) / 2;

      if (ssiAttNames_.myElemAt (theIdx) < theAttName)
         loIdx = theIdx;
      else
         hiIdx = theIdx;
      }

   if (hiIdx < ssiAttNames_.length ())
      if (ssiAttNames_.myElemAt (hiIdx) == theAttName)
         return true;

   return false;
d310 2
d313 4
a316 1
void WitStochModeMgr::setUpSsiAttNames ()
d318 3
a320 1
   int theIdx;
d322 1
a322 1
   specAllSsiAttNames ();
d324 3
a326 1
   ssiAttNames_.resize (tempSsiAttNames_.nElements ());
d328 1
a328 1
   for (theIdx = 0; theIdx < ssiAttNames_.length (); theIdx ++)
d330 1
a330 1
      ssiAttNames_[theIdx] = tempSsiAttNames_.get ();
d332 3
a334 5
      if (theIdx > 0)
         stronglyAssert (
            ssiAttNames_.myElemAt (theIdx - 1)
            <
            ssiAttNames_.myElemAt (theIdx));
d340 97
a436 1
void WitStochModeMgr::specAllSsiAttNames ()
d438 1
a438 3
   specSsiAttName ("demandVol"   );
   specSsiAttName ("scenarioProb");
   specSsiAttName ("supplyVol"   );
d443 1
a443 1
void WitStochModeMgr::specSsiAttName (const char * theAttName)
d445 1
a445 1
   tempSsiAttNames_.append (new WitString (theAttName));
@


1.11
log
@Stochastic Implosion
@
text
@d461 1
a461 1
   myProblem ()->prepSetStochModeAttr ();
d689 1
a689 1
   myProblem ()->prepSetStochSolnModeAttr ();
d914 1
a914 1
   myProblem ()->prepSetStochModeAttr ();
@


1.10
log
@Stochastic Implosion
@
text
@d689 1
a689 1
   myProblem ()->prepSetStochModeAttr ();
@


1.9
log
@Stochastic Implosion
@
text
@d97 2
d101 15
a115 2
   for (theIdx = 0; theIdx < ssiAttNames_.length (); theIdx ++)
      if (ssiAttNames_.myElemAt (theIdx) == theAttName)
@


1.8
log
@Stochastic Implosion.
@
text
@d59 1
a59 1
      tempSsiAttNames_ (myProblem ()),
d330 1
a330 1
   defineAllSsiAttNames ();
d334 3
a336 2
   for (theIdx = ssiAttNames_.length () - 1; theIdx >= 0; theIdx --)
      tempSsiAttNames_.pop (ssiAttNames_[theIdx]);
d338 6
a343 5
   for (theIdx = 1; theIdx < ssiAttNames_.length (); theIdx ++)
      stronglyAssert (
         ssiAttNames_.myElemAt (theIdx - 1)
         <
         ssiAttNames_.myElemAt (theIdx));
d348 1
a348 1
void WitStochModeMgr::defineAllSsiAttNames ()
d350 3
a352 3
   addSsiAttName ("demandVol");
   addSsiAttName ("scenarioProb");
   addSsiAttName ("supplyVol");
d357 1
a357 1
void WitStochModeMgr::addSsiAttName (const char * theAttName)
d359 1
a359 1
   tempSsiAttNames_.push (new WitString (theAttName));
@


1.7
log
@Corrected a memory leak found by purify.
@
text
@d47 1
a47 1
      WitProbAssoc      (theProblem),
d49 13
a61 13
      myStageMgr_       (NULL),
      myScenMgr_        (NULL),
      myStochImploder_  (NULL),
      exportingInput_   (false),
      exportingSoln_    (false),
      clearingSoln_     (false),
      stochSolnMode_    (false),
      objValue_         (0.0),
      boundsValue_      (0.0),
      ssiAttrNames_     (),
      tempSsiAttrNames_ (myProblem ()),
      curWriteComp_     (NULL),
      vectorWritten_    (false)
d70 1
a70 1
   setUpSsiAttrNames ();
d86 2
a87 2
   for (theIdx = 0; theIdx < ssiAttrNames_.length (); theIdx ++)
      delete ssiAttrNames_[theIdx];
d95 1
a95 1
bool WitStochModeMgr::isSsiAttrName (const char * theName)
d99 2
a100 2
   for (theIdx = 0; theIdx < ssiAttrNames_.length (); theIdx ++)
      if (ssiAttrNames_.myElemAt (theIdx) == theName)
d326 1
a326 1
void WitStochModeMgr::setUpSsiAttrNames ()
d328 1
a328 2
   int         theIdx;
   WitString * theNamePtr;
d330 1
a330 1
   defineAllSsiAttrNames ();
d332 1
a332 1
   ssiAttrNames_.resize (tempSsiAttrNames_.nElements ());
d334 2
a335 2
   for (theIdx = ssiAttrNames_.length () - 1; theIdx >= 0; theIdx --)
      tempSsiAttrNames_.pop (ssiAttrNames_[theIdx]);
d337 1
a337 1
   for (theIdx = 1; theIdx < ssiAttrNames_.length (); theIdx ++)
d339 1
a339 1
         ssiAttrNames_.myElemAt (theIdx - 1)
d341 1
a341 1
         ssiAttrNames_.myElemAt (theIdx));
d346 1
a346 1
void WitStochModeMgr::defineAllSsiAttrNames ()
d348 3
a350 3
   addSsiAttrName ("demandVol");
   addSsiAttrName ("scenarioProb");
   addSsiAttrName ("supplyVol");
d355 1
a355 1
void WitStochModeMgr::addSsiAttrName (const char * theName)
d357 1
a357 1
   tempSsiAttrNames_.push (new WitString (theName));
@


1.6
log
@Stochastic Implosion
@
text
@d604 1
a604 1
      myScenarios_.get ();
@


1.5
log
@Stochastic Implosion
@
text
@d167 7
@


1.4
log
@Stochastic Implosion
@
text
@d47 1
a47 1
      WitProbAssoc     (theProblem),
d49 13
a61 11
      myStageMgr_      (NULL),
      myScenMgr_       (NULL),
      myStochImploder_ (NULL),
      exportingInput_  (false),
      exportingSoln_   (false),
      clearingSoln_    (false),
      stochSolnMode_   (false),
      objValue_        (0.0),
      boundsValue_     (0.0),
      curWriteComp_    (NULL),
      vectorWritten_   (false)
d70 2
d79 2
d86 3
d95 13
d318 37
@


1.3
log
@Stochastic Implosion
@
text
@d379 1
a379 2
   myStochImpMgr ()->prepStochModeAttr ();
   myProblem     ()->prepSetUnpostAttr ();
d607 1
a607 2
   myStochImpMgr ()->prepStochModeAttr ();
   myProblem     ()->prepSetUnpostAttr ();
d832 1
a832 2
   myStochImpMgr ()->prepStochModeAttr ();
   myProblem     ()->prepSetUnpostAttr ();
@


1.2
log
@Stochastic Implosion
@
text
@d65 1
a65 1
   myStageMgr_ = new WitStageMgr (myProblem ());
d299 1
a299 1
WitStageMgr::WitStageMgr (WitProblem * theProblem):
d301 1
a301 1
      WitProbAssoc   (theProblem),
d303 2
a304 1
      recourseStage_ (myProblem (), defRecourseStage ())
d676 1
d767 1
d781 1
d808 1
d816 2
a817 32
   WitDemand * theDemand;
   bool        recDem;
   WitPeriod   thePer;
   double      demVol1;
   double      demVol2;

   forEachDemand (theDemand, myProblem ())
      {
      recDem =
         myScenMgr_->
            myStochModeMgr ()->
               myStageMgr ()->
                  recourseStage () (theDemand->demandedPart ());

      if (not recDem)
         forEachPeriod (thePer, myProblem ())
            {
            demVol1 =                demandVol_ (theDemand)[thePer];
            demVol2 = otherScenario->demandVol_ (theDemand)[thePer];

            if (demVol1 != demVol2)
               myMsgFac () ("nonRecDemAttMisMatchSmsg",
                  "demandVol",
                  theDemand->demandedPartName (),
                  theDemand->demandName (),
                  thePer,
                  myIndex_,
                  demVol1,
                  otherScenario->myIndex_,
                  demVol2);
            }
      }
d844 1
d847 3
d874 19
d899 1
a899 3
      myScenMgr_->
         myStochModeMgr ()->
            startWriteCompData (theDemand);
d906 18
a923 3
      myScenMgr_->
         myStochModeMgr ()->
            finishWriteCompData ();
d945 75
@


1.1
log
@Stochastic Implosion
@
text
@d26 1
d47 1
a47 1
      WitProbAssoc    (theProblem),
d49 11
a59 10
      myStageMgr_     (NULL),
      myScenMgr_      (NULL),
      exportingInput_ (false),
      exportingSoln_  (false),
      clearingSoln_   (false),
      stochSolnMode_  (false),
      objValue_       (0.0),
      boundsValue_    (0.0),
      curWriteComp_   (NULL),
      vectorWritten_  (false)
d224 1
a224 9
   WitScenario * origCurScenario;

   stronglyAssert (WitOptComp::optImpAllowed ());

   stronglyAssert (not stochSolnMode_);

   myMsgFac () ("stochImpMsg");

   myMsgFac () ("stochSingleLPMsg");
d226 1
a226 2
   myScenMgr_ ->validateData ();
   myStageMgr_->validateData ();
d228 1
a228 1
   myScenMgr_->curScenario ()->saveInputAttrs ();
d230 1
a230 1
   origCurScenario = myScenMgr_->curScenario ();
d232 1
a232 1
   myOptImploder ()->stochImplode ();
@


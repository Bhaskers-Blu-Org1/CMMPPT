head	1.106;
access;
symbols
	sce_5_01_20080919:1.85
	latest_sce_4_20_20060523:1.83.0.2
	sce_4_20_20060523:1.83
	latest_sce4_20_OSL:1.82.0.2
	sce_4_20_OSL:1.82
	sce_410_withVa:1.81
	sce_4_05_20040511:1.55
	sce_4_00_20040201:1.55
	nextGenBranch:1.55.0.2
	nextGenRoot:1.55
	sce_3_30_20030627:1.55
	EndRw-branch:1.51.0.4
	Root-of-EndRw:1.51
	rwToStl:1.51.0.2
	latest_sce_3_10_20010924:1.40.0.2
	sce_3_10_20010924:1.40
	latest_sce_3_00_20010601:1.26.0.2
	sce_3_00_20010601:1.26
	latest_sce_2_31_20010308:1.11.0.2
	sce_2_31_20010308:1.11
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.106
date	2011.09.28.23.49.38;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2011.09.24.00.27.59;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2011.08.30.20.17.42;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2010.09.28.19.25.16;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2010.09.10.22.10.38;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.30.20.20.14;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.07.29.21.03.12;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.28.21.40.39;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.28.19.27.46;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.27.20.57.56;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.26.17.48.44;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.21.18.50.14;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.16.22.37.43;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.16.22.26.41;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2010.07.13.17.41.29;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2010.07.02.18.53.10;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.01.22.41.21;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.29.22.32.31;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.29.19.56.42;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.18.23.11.15;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.07.31.20.39.46;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.02.17.34.04;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2006.02.28.20.38.39;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2005.03.28.20.14.36;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.01.15.00.20.08;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.01.13.17.24.21;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2005.01.06.20.34.09;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2005.01.01.00.43.13;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.12.31.20.38.13;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.12.31.18.28.28;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.12.28.22.34.26;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.12.28.19.21.18;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.12.22.19.57.26;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.12.22.19.25.56;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.12.21.22.13.48;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.12.20.21.13.10;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.12.20.18.36.24;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.12.17.21.53.00;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.12.16.23.35.17;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.12.15.23.50.11;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.12.15.20.20.50;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.12.15.16.39.25;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.12.14.22.37.10;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.12.13.23.35.47;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.12.13.18.58.22;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.12.10.22.09.03;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.12.10.16.49.43;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.12.09.22.06.07;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.12.09.21.34.11;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.05.16.10.00;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.03.07.21.34.17;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.02.14.20.12.57;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.02.22.18.36;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2002.08.02.17.03.35;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2002.08.01.20.16.35;	author austel;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.02.21.53.03;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.24.23.00.05;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2002.04.18.14.02.37;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2002.04.15.21.21.36;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2002.04.12.21.02.01;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.11.15.36.29;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.20.22.51.18;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.19.16.20.56;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.19.16.17.11;	author bobw;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.19.18.50.58;	author bobw;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.17.18.56.28;	author bobw;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.30.20.29.24;	author bobw;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.24.22.03.21;	author bobw;	state Exp;
branches;
next	1.36;

1.36
date	2001.08.23.21.13.54;	author bobw;	state Exp;
branches;
next	1.35;

1.35
date	2001.08.22.20.41.52;	author bobw;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.21.17.31.45;	author bobw;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.17.22.00.10;	author bobw;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.15.20.53.36;	author bobw;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.14.17.41.53;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.13.20.30.24;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.13.15.02.50;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.11.19.29.11;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.01.19.23.34;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.29.22.11.27;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.25.22.59.13;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.25.14.53.25;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.10.22.31.13;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.10.17.58.19;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.08.21.35.44;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.03.15.28.39;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.30.21.29.42;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.06.23.23.52;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.06.19.22.10;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.03.19.23.05;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.23.19.43.24;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.20.21.03.59;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.12.19.48.07;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.08.16.37.06;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.29.19.26.10;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.27.00.24.39;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.26.21.46.02;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.20.00.44.19;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.15.19.01.51;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.28.22.13.38;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.23.11.44;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.14.20.27.31;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.16.33.08;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.25;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.26;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.26;	author wit;	state Exp;
branches;
next	;


desc
@@


1.106
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "MultiEx.C"
//
// Contains the implementation of the following classes:
// 
//    MeMgr.
//    MeDir.
//    NstnMeDir.
//    AsapMeDir.
//    MeSitePt.
//    MePt.
//    MeCand.
//------------------------------------------------------------------------------

#include <MeMgr.h>
#include <MeDir.h>
#include <MeCand.h>
#include <MeSitePt.h>
#include <MePt.h>
#include <DetAltPt.h>
#include <SplitPt.h>
#include <Selector.h>
#include <SglSrcMgr.h>
#include <ExecPerSch.h>
#include <GlobalComp.h>
#include <Material.h>
#include <Operation.h>
#include <BopEntry.h>
#include <MsgFac.h>
#include <PtrTVec.h>

//------------------------------------------------------------------------------
// Implementation of class MeMgr.
//------------------------------------------------------------------------------

inline bool WitMeMgr::hasMeSitePts (WitBopEntry * theBopEnt)
   {
   return myMeSitePts_.myPtrTVecAt (theBopEnt).isAllocated ();
   }

//------------------------------------------------------------------------------

WitMeMgr::WitMeMgr (WitSelector * theSelector):

      WitSelMgr        (theSelector),
      myMeDirForNstn_  (NULL),
      myMeDirForAsap_  (NULL),
      myMeSitePts_     (),
      initDirIsAsap_   (false),
      savedExecPer_    (-1),
      myRecoveryPairs_ (myProblem ())
   {
   myMsgFac () ("multiExecMsg");

   myMeDirForNstn_ = new WitNstnMeDir (this);
   myMeDirForAsap_ = new WitAsapMeDir (this);
   
   myMeSitePts_.allocate1D (myProblem ());

   buildMeSitePts ();

   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("twmeMsg");
   }

//------------------------------------------------------------------------------

WitMeMgr::~WitMeMgr ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitMeSitePt * theMeSitePt;

   forEachBopEntry (theBopEnt, myProblem ())
      if (hasMeSitePts (theBopEnt))
         {
         expPer = -1;

         while (findNextMeSitePt (theBopEnt, expPer, theMeSitePt))
            delete theMeSitePt;
         }

   delete myMeDirForAsap_;
   delete myMeDirForNstn_;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::instNeededFor (WitProblem * theProblem)
   {
   return theProblem->myGlobalComp ()->multiExecNeeded ();
   }

//------------------------------------------------------------------------------

void WitMeMgr::setInitDirIsAsap (bool theValue)
   {
   initDirIsAsap_ = theValue;
   }

//------------------------------------------------------------------------------

WitPeriod WitMeMgr::selExecPer (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitMePt * theMePt;

   theMePt = myMePtWithSel (theBopEnt, expPer);

   return
      (theMePt != NULL)?
         theMePt->selExecPer ():
         theBopEnt ->expExecPeriod ()[expPer];
   }

//------------------------------------------------------------------------------

void WitMeMgr::print ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitMeSitePt * theMeSitePt;

   fprintf (msgFile (),
      "\n"
      "Multi-Exec Selection Points:\n");

   forEachBopEntry (theBopEnt, myProblem ())
      if (hasMeSitePts (theBopEnt))
         {
         expPer = -1;

         while (findNextMeSitePt (theBopEnt, expPer, theMeSitePt))
            {
            theMeSitePt->myMePtForNstn ()->print ();

            if (myGlobalComp ()->twoWayMultiExec ())
               theMeSitePt->myMePtForAsap ()->print ();
            }
         }

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitMeMgr::saveExecPer (WitPeriod execPer)
   {
   witAssert (savedExecPer_ == -1);
   witAssert (execPer       != -1);

   savedExecPer_ = execPer;
   }

//------------------------------------------------------------------------------

void WitMeMgr::retrieveExecPer (WitPeriod & execPer)
   {
   witAssert (savedExecPer_ != -1);

   execPer       = savedExecPer_;
   savedExecPer_ = -1;
   }

//------------------------------------------------------------------------------

void WitMeMgr::storeRecoveryPair (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   myRecoveryPairs_.push (theBopEnt, expPer);
   }

//------------------------------------------------------------------------------

void WitMeMgr::recoverInitState ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitMeSitePt * theMeSitePt;

   while (myRecoveryPairs_.pop (theBopEnt, expPer))
      {
      theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);

      theMeSitePt->   myMePtForNstn ()->recoverInitState ();

      if (myGlobalComp ()->twoWayMultiExec ())
         theMeSitePt->myMePtForAsap ()->recoverInitState ();
      }
   }

//------------------------------------------------------------------------------

bool WitMeMgr::selSplitNeeded ()
   {
   WitBopEntry * theBopEnt;

   if (myGlobalComp ()->selSplit ())
      return true;

   if (myGlobalComp ()->nonMrSelSplit ())
      return true;

   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         if (theBopEnt->meSelSplit ())
            return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::selIsSplit (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitMePt * theMePt;

   if (not selSplit ())
      return false;

   theMePt = myMePtWithSel (theBopEnt, expPer);

   if (theMePt == NULL)
      return false;

   return theMePt->isSplit ();
   }

//------------------------------------------------------------------------------

void WitMeMgr::defineSplit (
      WitBopEntry *    theBopEnt,
      WitPeriod        expPer,
      double           expVol,
      WitPerDblStack & theSplitPairs,
      double &         unbddVol)
   {
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitPeriod          execPer;
   WitFixedPer *      theFixedPer;

   witAssert (selIsSplit (theBopEnt, expPer));

   myMePtWithSel (theBopEnt, expPer)->
      mySplitPt ()->
         defineSplit (expVol, theAbsSplitPairs, unbddVol);

   theSplitPairs.clear ();

   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      theSelCand->getMeData (execPer);

      theFixedPer = mySelector ()->myFixedPer ()[execPer];

      theSplitPairs.push (theFixedPer, splitVol);
      }
   }

//------------------------------------------------------------------------------

void WitMeMgr::recBopEntExecPerSS (
      WitBopEntry * theBopEnt, 
      WitPeriod     execPer, 
      double        expVol)
   {
   WitPeriod     expPer;
   WitMeSitePt * theMeSitePt;
   WitMeDir *    theMeDir;

   witAssert (selSplit ());

   if (not hasMeSitePts (theBopEnt))
      return;

   expPer      = theBopEnt->impactPeriod ()[execPer];

   theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);

   if (theMeSitePt == NULL)
      return;

   theMeDir = chooseMeDir (theBopEnt->myPart ());

   theMeDir->myMePt (theMeSitePt)->recordFlowSS (expVol);
   }

//------------------------------------------------------------------------------

WitAltPt * WitMeMgr::myAltPtFor (
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
   {
   WitPeriod expPer;
   WitMePt * theMePt;

   expPer  = theBopEnt->impactPeriod ()[execPer];

   theMePt = myMePtWithSel (theBopEnt, expPer);

   return
      (theMePt != NULL)?
         theMePt->myDetAltPt ():
         NULL;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::validForNetting ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::validForExecBounds ()
   {
   return true;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::validForLTBounds ()
   {
   return false;
   }

//------------------------------------------------------------------------------

const char * WitMeMgr::selCaseName ()
   {
   return "Multi-Exec";
   }

//------------------------------------------------------------------------------

void WitMeMgr::buildMeSitePts ()
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitPeriod     execPerF;
   WitPeriod     execPerL;

   WitExecPerSched <WitBopEntry> * theExecPerSched;

   theExecPerSched = new WitExecPerSched <WitBopEntry> (myProblem ());

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (expPer, myProblem ())
         {
         theExecPerSched->getExecPerRange (
            theBopEnt,
            expPer,
            execPerF,
            execPerL);

         for (; execPerF <= execPerL; execPerF ++)
            if (theBopEnt->execPerOKForExp (execPerF))
               break;

         for (; execPerL >= execPerF; execPerL --)
            if (theBopEnt->execPerOKForExp (execPerL))
               break;

         if (execPerF >= execPerL)
            continue;

         if (not myMeSitePts_.myPtrTVecAt (theBopEnt).isAllocated ())
            myMeSitePts_.myPtrTVecAt (theBopEnt).allocate (myProblem ());

         myMeSitePts_.myPtrAt (theBopEnt, expPer) = 
            new WitMeSitePt (
               theBopEnt,
               execPerF,
               execPerL,
               this);
         }

   delete theExecPerSched;
   }

//------------------------------------------------------------------------------

WitMePt * WitMeMgr::myMePtWithSel (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitMeSitePt * theMeSitePt;
   WitMeDir *    theMeDir;
   WitMePt *     theMePt;

   if (not hasMeSitePts (theBopEnt))
      return NULL;

   theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);

   if (theMeSitePt == NULL)
      return NULL;

   theMeDir = chooseMeDir (theBopEnt->myPart ());

   theMePt  = theMeDir->myMePt (theMeSitePt);

   return
      (theMePt->selExecPer () >= 0)?
         theMePt:
         NULL;
   }

//------------------------------------------------------------------------------

WitMeDir * WitMeMgr::chooseMeDir (WitPart * thePart)
   {
   WitMaterial * theMat;

   if (not myGlobalComp ()->twoWayMultiExec ())
      return myMeDirForNstn_;

   if (initDirIsAsap_)
      return myMeDirForAsap_;

   theMat = thePart->thisMat ();

   if (theMat != NULL)
      if (theMat->buildAsap ())
         return myMeDirForAsap_;

   return myMeDirForNstn_;
   }

//------------------------------------------------------------------------------

bool WitMeMgr::findNextMeSitePt (
      WitBopEntry *   theBopEnt,
      WitPeriod &     expPer,
      WitMeSitePt * & theMeSitePt)
   {
   while (++ expPer < nPeriods ())
      {
      theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);
   
      if (theMeSitePt != NULL)
         return true;
      }

   return false;
   }

//------------------------------------------------------------------------------
// Implementation of class MeDir.
//------------------------------------------------------------------------------

WitMeDir::~WitMeDir ()
   {
   }

//------------------------------------------------------------------------------

WitMeDir::WitMeDir (WitMeMgr * theMeMgr):

      WitProbAssoc (theMeMgr),
      myMeMgr_     (theMeMgr)
   {
   }

//------------------------------------------------------------------------------
// Implementation of class NstnMeDir.
//------------------------------------------------------------------------------

WitNstnMeDir::WitNstnMeDir (WitMeMgr * theMeMgr):
      WitMeDir (theMeMgr)
   {
   }

//------------------------------------------------------------------------------

WitNstnMeDir::~WitNstnMeDir ()
   {
   }

//------------------------------------------------------------------------------

WitMeDir * WitNstnMeDir::oppMeDir ()
   {
   return myMeMgr ()->myMeDirForAsap ();
   }

//------------------------------------------------------------------------------

WitMePt * WitNstnMeDir::myMePt (WitMeSitePt * theMeSitePt)
   {
   return theMeSitePt->myMePtForNstn ();
   }

//------------------------------------------------------------------------------

WitPeriod WitNstnMeDir::initSelExecPer (WitMeSitePt * theMeSitePt)
   {
   return theMeSitePt->lastExecPer ();
   }

//------------------------------------------------------------------------------

WitPeriod WitNstnMeDir::nextExecPer (
      WitPeriod     execPer,
      WitMeSitePt * theMeSitePt)
   {
   witAssert (execPer >= 0);

   if (execPer == theMeSitePt->firstExecPer ())
      return -1;

   if (myGlobalComp ()->twoWayMultiExec ())
      if (execPer == theMeSitePt->myMePtForAsap ()->selExecPer ())
         return -1;

   return execPer - 1;
   }

//------------------------------------------------------------------------------

const char * WitNstnMeDir::myID ()
   {
   return "NSTN";
   }

//------------------------------------------------------------------------------
// Implementation of class AsapMeDir.
//------------------------------------------------------------------------------

WitAsapMeDir::WitAsapMeDir (WitMeMgr * theMeMgr):
      WitMeDir (theMeMgr)
   {
   }

//------------------------------------------------------------------------------

WitAsapMeDir::~WitAsapMeDir ()
   {
   }

//------------------------------------------------------------------------------

WitMeDir * WitAsapMeDir::oppMeDir ()
   {
   return myMeMgr ()->myMeDirForNstn ();
   }

//------------------------------------------------------------------------------

WitMePt * WitAsapMeDir::myMePt (WitMeSitePt * theMeSitePt)
   {
   return theMeSitePt->myMePtForAsap ();
   }

//------------------------------------------------------------------------------

WitPeriod WitAsapMeDir::initSelExecPer (WitMeSitePt * theMeSitePt)
   {
   return theMeSitePt->firstExecPer ();
   }

//------------------------------------------------------------------------------

WitPeriod WitAsapMeDir::nextExecPer (
      WitPeriod     execPer,
      WitMeSitePt * theMeSitePt)
   {
   witAssert (execPer >= 0);

   if (execPer == theMeSitePt->lastExecPer ())
      return -1;

   if (execPer == theMeSitePt->myMePtForNstn ()->selExecPer ())
      return -1;

   return execPer + 1;
   }

//------------------------------------------------------------------------------

const char * WitAsapMeDir::myID ()
   {
   return "ASAP";
   }

//------------------------------------------------------------------------------
// Implementation of class MeSitePt.
//------------------------------------------------------------------------------

WitMeSitePt::WitMeSitePt (
      WitBopEntry * theBopEnt,
      WitPeriod     firstExecPerVal,
      WitPeriod     lastExecPerVal,
      WitMeMgr *    theMeMgr):

      myBopEnt_      (theBopEnt),
      firstExecPer_  (firstExecPerVal),
      lastExecPer_   (lastExecPerVal),
      myMePtForNstn_ (NULL),
      myMePtForAsap_ (NULL)
   {
   myMePtForNstn_ = new WitMePt (this, theMeMgr->myMeDirForNstn ());

   if (theMeMgr->myGlobalComp ()->twoWayMultiExec ())
      myMePtForAsap_ = new WitMePt (this, theMeMgr->myMeDirForAsap ());
   }

//------------------------------------------------------------------------------

WitMeSitePt::~WitMeSitePt ()
   {
   delete myMePtForNstn_;
   delete myMePtForAsap_;
   }

//------------------------------------------------------------------------------

WitPeriod WitMeSitePt::nextExecPer (WitPeriod execPer, WitMeDir * theMeDir)
   {
   while (true)
      {
      execPer = theMeDir->nextExecPer (execPer, this);

      if (execPer < 0)
         return -1;

      if (myBopEnt_->execPerOKForExp (execPer))
         if (myBopEnt_->impactPeriod ()[execPer] == myExpPer ())
            return execPer;
      }

   return -1;
      //
      // Avoids a compiler warning.
   }

//------------------------------------------------------------------------------

void WitMeSitePt::prtID ()
   {
   fprintf (myMePtForNstn_->myMeDir ()->myMsgFac ().myFile (),
      "   Operation:        %s\n"
      "   BOP Entry #:      %d\n"
      "   Exp Per:          %d\n",
      myBopEnt_->myOperationName ().myCstring (),
      myBopEnt_->localIndex (),
      myExpPer ());
   }

//------------------------------------------------------------------------------

WitPeriod WitMeSitePt::myExpPer ()
   {
   return myBopEnt_->impactPeriod ()[firstExecPer_];
   }

//------------------------------------------------------------------------------
// Implementation of class MePt.
//------------------------------------------------------------------------------

WitMePt::WitMePt (WitMeSitePt * theMeSitePt, WitMeDir * theMeDir):
      WitDetSelPt (),

      myMeSitePt_ (theMeSitePt),
      myMeDir_    (theMeDir),
      selExecPer_ (-1)
   {              
   select (myMeDir_->initSelExecPer (myMeSitePt_));
   }

//------------------------------------------------------------------------------

WitMePt::~WitMePt ()
   {
   }

//------------------------------------------------------------------------------

void WitMePt::print ()
   {
   FILE *        theFile;
   WitBopEntry * theBopEnt; 

   theFile   = myMeDir_->myMsgFac ().myFile ();

   theBopEnt = myMeSitePt_->myBopEnt ();
 
   fprintf (theFile,
      "\n"
      "Multi-Exec Selection Point:\n"
      "   Operation %s, BopEntry #%d, Exp Per %d, %s\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex (),
      myMeSitePt_->myExpPer (),
      myMeDir_->myID ());

   if (selExecPer_ >= 0)
      fprintf (theFile, "      Selected Exec Per: %d\n", selExecPer_);
   else
      fprintf (theFile, "      Selected Exec Per: None\n");
   }

//------------------------------------------------------------------------------

void WitMePt::select (WitPeriod execPer)
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (selExecPer_);

   selExecPer_ = execPer;
   }

//------------------------------------------------------------------------------

void WitMePt::recoverInitState ()
   {
   selExecPer_ = myMeDir_->initSelExecPer (myMeSitePt_);

   if (mySelMgr ()->selPrintLevelAt (3))
      printRecovery ();
   }

//------------------------------------------------------------------------------

WitSelMgr * WitMePt::mySelMgr ()
   {
   return myMeDir_->myMeMgr ();
   }

//------------------------------------------------------------------------------

void WitMePt::prtID ()
   {
   myMeSitePt_->prtID ();

   fprintf (myMeDir_->myMsgFac ().myFile (),
      "   Direction:        %s\n",
      myMeDir_->myID ());
   }

//------------------------------------------------------------------------------

bool WitMePt::splittable ()
   {
   if (myMeDir_->myGlobalComp ()->selSplit ())
      return true;

   if (myMeDir_->myGlobalComp ()->nonMrSelSplit ())
      return true;

   return myMeSitePt_->myBopEnt ()->meSelSplit ();
   }

//------------------------------------------------------------------------------

void WitMePt::getSortData (WitPart * & thePart, WitPeriod & thePer)
   {
   thePart = myMeSitePt_->myBopEnt ()->myPart ();
   thePer  = myMeSitePt_->myExpPer ();
   }

//------------------------------------------------------------------------------

WitSelCand * WitMePt::newSelCand ()
   {
   return new WitMeCand (selExecPer_, myMeDir_->myProblem ());
   }

//------------------------------------------------------------------------------

bool WitMePt::hasResAlt ()
   {
   WitPeriod execPer;

   witAssert (selExecPer_ >= 0);

   execPer = myMeSitePt_->nextExecPer (selExecPer_, myMeDir_);

   return (execPer >= 0);
   }

//------------------------------------------------------------------------------

void WitMePt::alterSelection ()
   {
   advanceSel ();

   if (myMeDir_->selPrintLevelAt (2))
      print ();

   if (myMeDir_->myGlobalComp ()->twoWayMultiExec ())
      if (selExecPer_ < 0)
         myMeDir_->oppMeDir ()->myMePt (myMeSitePt_)->deSelectAsNeeded ();
   }

//------------------------------------------------------------------------------

void WitMePt::storeRecoveryPt ()
   {
   myMeDir_->
      myMeMgr ()->
         storeRecoveryPair (
            myMeSitePt_->myBopEnt (),
            myMeSitePt_->myExpPer ());
   }

//------------------------------------------------------------------------------

void WitMePt::tempAlterSel ()
   {
   myMeDir_->myMeMgr ()->saveExecPer (selExecPer_);

   advanceSel ();
   }

//------------------------------------------------------------------------------

void WitMePt::cancelTempAlt ()
   {
   WitPeriod execPer;

   myMeDir_->myMeMgr ()->retrieveExecPer (execPer);

   select (execPer);
   }

//------------------------------------------------------------------------------

void WitMePt::printAlteration ()
   {
   }

//------------------------------------------------------------------------------

void WitMePt::advanceSel ()
   {
   WitPeriod execPer;

   witAssert (selExecPer_ >= 0);

   execPer = myMeSitePt_->nextExecPer (selExecPer_, myMeDir_);

   select (execPer);
   }

//------------------------------------------------------------------------------

void WitMePt::deSelectAsNeeded ()
   {
   if (selExecPer_ < 0)
      return;

   select (-1);

   if (myMeDir_->selPrintLevelAt (2))
      print ();
   }

//------------------------------------------------------------------------------

void WitMePt::printRecovery ()
   {
   fprintf (myMeDir_->myMsgFac ().myFile (),
      "\n"
      "   Initial Multi-Exec Selection Recovered:\n"
      "      Operation:  %s\n"
      "      BopEntry #: %d\n"
      "      Exp Per:    %d\n"
      "      Direction:  %s\n"
      "      Exec Per:   %d\n\n",
      myMeSitePt_->myBopEnt ()->myOperationName ().myCstring (),
      myMeSitePt_->myBopEnt ()->localIndex (),
      myMeSitePt_->myExpPer (),
      myMeDir_   ->myID     (),
      selExecPer_);
   }

//------------------------------------------------------------------------------
// Implementation of class MeCand.
//------------------------------------------------------------------------------

WitMeCand::WitMeCand (WitPeriod execPer, WitProblem * theProblem):

      WitSelCand (theProblem),
      myExecPer_ (execPer)
   {
   }

//------------------------------------------------------------------------------

WitMeCand::~WitMeCand ()
   {
   }

//------------------------------------------------------------------------------

void WitMeCand::prtID ()
   {
   fprintf (msgFile (), "      Exec Per:      %d\n", myExecPer_);
   }

//------------------------------------------------------------------------------

void WitMeCand::getMeData (WitPeriod & execPer)
   {
   execPer = myExecPer_;
   }
@


1.105
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.104
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d14 1
a14 1
//
d46 3
a48 3
{
return myMeSitePts_.myPtrTVecAt (theBopEnt).isAllocated ();
}
d54 20
a73 20
WitSelMgr        (theSelector),
myMeDirForNstn_  (NULL),
myMeDirForAsap_  (NULL),
myMeSitePts_     (),
initDirIsAsap_   (false),
savedExecPer_    (-1),
myRecoveryPairs_ (myProblem ())
{
myMsgFac () ("multiExecMsg");

myMeDirForNstn_ = new WitNstnMeDir (this);
myMeDirForAsap_ = new WitAsapMeDir (this);

myMeSitePts_.allocate1D (myProblem ());

buildMeSitePts ();

if (myGlobalComp ()->twoWayMultiExec ())
myMsgFac () ("twmeMsg");
}
d78 17
a94 17
{
WitBopEntry * theBopEnt;
WitPeriod     expPer;
WitMeSitePt * theMeSitePt;

forEachBopEntry (theBopEnt, myProblem ())
if (hasMeSitePts (theBopEnt))
{
expPer = -1;

while (findNextMeSitePt (theBopEnt, expPer, theMeSitePt))
delete theMeSitePt;
}

delete myMeDirForAsap_;
delete myMeDirForNstn_;
}
d99 3
a101 3
{
return theProblem->myGlobalComp ()->multiExecNeeded ();
}
d106 3
a108 3
{
initDirIsAsap_ = theValue;
}
d113 2
a114 2
{
WitMePt * theMePt;
d116 1
a116 1
theMePt = myMePtWithSel (theBopEnt, expPer);
d118 5
a122 5
return
(theMePt != NULL)?
theMePt->selExecPer ():
theBopEnt ->expExecPeriod ()[expPer];
}
d127 22
a148 22
{
WitBopEntry * theBopEnt;
WitPeriod     expPer;
WitMeSitePt * theMeSitePt;

fprintf (msgFile (),
"\n"
"Multi-Exec Selection Points:\n");

forEachBopEntry (theBopEnt, myProblem ())
if (hasMeSitePts (theBopEnt))
{
expPer = -1;

while (findNextMeSitePt (theBopEnt, expPer, theMeSitePt))
{
theMeSitePt->myMePtForNstn ()->print ();

if (myGlobalComp ()->twoWayMultiExec ())
theMeSitePt->myMePtForAsap ()->print ();
}
}
d150 2
a151 2
fprintf (msgFile (), "\n");
}
d156 3
a158 3
{
witAssert (savedExecPer_ == -1);
witAssert (execPer       != -1);
d160 2
a161 2
savedExecPer_ = execPer;
}
d166 2
a167 2
{
witAssert (savedExecPer_ != -1);
d169 3
a171 3
execPer       = savedExecPer_;
savedExecPer_ = -1;
}
d176 3
a178 3
{
myRecoveryPairs_.push (theBopEnt, expPer);
}
d183 15
a197 15
{
WitBopEntry * theBopEnt;
WitPeriod     expPer;
WitMeSitePt * theMeSitePt;

while (myRecoveryPairs_.pop (theBopEnt, expPer))
{
theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);

theMeSitePt->   myMePtForNstn ()->recoverInitState ();

if (myGlobalComp ()->twoWayMultiExec ())
theMeSitePt->myMePtForAsap ()->recoverInitState ();
}
}
d202 2
a203 2
{
WitBopEntry * theBopEnt;
d205 2
a206 2
if (myGlobalComp ()->selSplit ())
return true;
d208 2
a209 2
if (myGlobalComp ()->nonMrSelSplit ())
return true;
d211 4
a214 4
forEachBopEntry (theBopEnt, myProblem ())
if (theBopEnt->expAllowed ())
if (theBopEnt->meSelSplit ())
return true;
d216 2
a217 2
return false;
}
d222 2
a223 2
{
WitMePt * theMePt;
d225 2
a226 2
if (not selSplit ())
return false;
d228 1
a228 1
theMePt = myMePtWithSel (theBopEnt, expPer);
d230 2
a231 2
if (theMePt == NULL)
return false;
d233 2
a234 2
return theMePt->isSplit ();
}
d239 29
a267 29
WitBopEntry *    theBopEnt,
WitPeriod        expPer,
double           expVol,
WitPerDblStack & theSplitPairs,
double &         unbddVol)
{
WitSelCandDblStack theAbsSplitPairs (myProblem ());
WitSelCand *       theSelCand;
double             splitVol;
WitPeriod          execPer;
WitFixedPer *      theFixedPer;

witAssert (selIsSplit (theBopEnt, expPer));

myMePtWithSel (theBopEnt, expPer)->
mySplitPt ()->
defineSplit (expVol, theAbsSplitPairs, unbddVol);

theSplitPairs.clear ();

while (theAbsSplitPairs.pop (theSelCand, splitVol))
{
theSelCand->getMeData (execPer);

theFixedPer = mySelector ()->myFixedPer ()[execPer];

theSplitPairs.push (theFixedPer, splitVol);
}
}
d272 7
a278 7
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        expVol)
{
WitPeriod     expPer;
WitMeSitePt * theMeSitePt;
WitMeDir *    theMeDir;
d280 1
a280 1
witAssert (selSplit ());
d282 2
a283 2
if (not hasMeSitePts (theBopEnt))
return;
d285 1
a285 1
expPer      = theBopEnt->impactPeriod ()[execPer];
d287 1
a287 1
theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);
d289 2
a290 2
if (theMeSitePt == NULL)
return;
d292 1
a292 1
theMeDir = chooseMeDir (theBopEnt->myPart ());
d294 2
a295 2
theMeDir->myMePt (theMeSitePt)->recordFlowSS (expVol);
}
d300 17
a316 17
WitBopEntry * theBopEnt,
WitConsEntry *,
WitPeriod     execPer,
WitPeriod)
{
WitPeriod expPer;
WitMePt * theMePt;

expPer  = theBopEnt->impactPeriod ()[execPer];

theMePt = myMePtWithSel (theBopEnt, expPer);

return
(theMePt != NULL)?
theMePt->myDetAltPt ():
NULL;
}
d321 3
a323 3
{
return true;
}
d328 3
a330 3
{
return true;
}
d335 3
a337 3
{
return false;
}
d342 3
a344 3
{
return "Multi-Exec";
}
d349 40
a388 40
{
WitBopEntry * theBopEnt;
WitPeriod     expPer;
WitPeriod     execPerF;
WitPeriod     execPerL;

WitExecPerSched <WitBopEntry> * theExecPerSched;

theExecPerSched = new WitExecPerSched <WitBopEntry> (myProblem ());

forEachBopEntry (theBopEnt, myProblem ())
forEachPeriod (expPer, myProblem ())
{
theExecPerSched->getExecPerRange (
theBopEnt,
expPer,
execPerF,
execPerL);

for (; execPerF <= execPerL; execPerF ++)
if (theBopEnt->execPerOKForExp (execPerF))
break;

for (; execPerL >= execPerF; execPerL --)
if (theBopEnt->execPerOKForExp (execPerL))
break;

if (execPerF >= execPerL)
continue;

if (not myMeSitePts_.myPtrTVecAt (theBopEnt).isAllocated ())
myMeSitePts_.myPtrTVecAt (theBopEnt).allocate (myProblem ());

myMeSitePts_.myPtrAt (theBopEnt, expPer) =
new WitMeSitePt (
theBopEnt,
execPerF,
execPerL,
this);
}
d390 2
a391 2
delete theExecPerSched;
}
d396 4
a399 4
{
WitMeSitePt * theMeSitePt;
WitMeDir *    theMeDir;
WitMePt *     theMePt;
d401 2
a402 2
if (not hasMeSitePts (theBopEnt))
return NULL;
d404 1
a404 1
theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);
d406 2
a407 2
if (theMeSitePt == NULL)
return NULL;
d409 1
a409 1
theMeDir = chooseMeDir (theBopEnt->myPart ());
d411 1
a411 1
theMePt  = theMeDir->myMePt (theMeSitePt);
d413 5
a417 5
return
(theMePt->selExecPer () >= 0)?
theMePt:
NULL;
}
d422 2
a423 2
{
WitMaterial * theMat;
d425 2
a426 2
if (not myGlobalComp ()->twoWayMultiExec ())
return myMeDirForNstn_;
d428 2
a429 2
if (initDirIsAsap_)
return myMeDirForAsap_;
d431 1
a431 1
theMat = thePart->thisMat ();
d433 3
a435 3
if (theMat != NULL)
if (theMat->buildAsap ())
return myMeDirForAsap_;
d437 2
a438 2
return myMeDirForNstn_;
}
d443 11
a453 11
WitBopEntry *   theBopEnt,
WitPeriod &     expPer,
WitMeSitePt * & theMeSitePt)
{
while (++ expPer < nPeriods ())
{
theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);

if (theMeSitePt != NULL)
return true;
}
d455 2
a456 2
return false;
}
d463 2
a464 2
{
}
d470 4
a473 4
WitProbAssoc (theMeMgr),
myMeMgr_     (theMeMgr)
{
}
d480 3
a482 3
WitMeDir (theMeMgr)
{
}
d487 2
a488 2
{
}
d493 3
a495 3
{
return myMeMgr ()->myMeDirForAsap ();
}
d500 3
a502 3
{
return theMeSitePt->myMePtForNstn ();
}
d507 3
a509 3
{
return theMeSitePt->lastExecPer ();
}
d514 11
a524 11
WitPeriod     execPer,
WitMeSitePt * theMeSitePt)
{
witAssert (execPer >= 0);

if (execPer == theMeSitePt->firstExecPer ())
return -1;

if (myGlobalComp ()->twoWayMultiExec ())
if (execPer == theMeSitePt->myMePtForAsap ()->selExecPer ())
return -1;
d526 2
a527 2
return execPer - 1;
}
d532 3
a534 3
{
return "NSTN";
}
d541 3
a543 3
WitMeDir (theMeMgr)
{
}
d548 2
a549 2
{
}
d554 3
a556 3
{
return myMeMgr ()->myMeDirForNstn ();
}
d561 3
a563 3
{
return theMeSitePt->myMePtForAsap ();
}
d568 3
a570 3
{
return theMeSitePt->firstExecPer ();
}
d575 4
a578 4
WitPeriod     execPer,
WitMeSitePt * theMeSitePt)
{
witAssert (execPer >= 0);
d580 2
a581 2
if (execPer == theMeSitePt->lastExecPer ())
return -1;
d583 2
a584 2
if (execPer == theMeSitePt->myMePtForNstn ()->selExecPer ())
return -1;
d586 2
a587 2
return execPer + 1;
}
d592 3
a594 3
{
return "ASAP";
}
d601 16
a616 16
WitBopEntry * theBopEnt,
WitPeriod     firstExecPerVal,
WitPeriod     lastExecPerVal,
WitMeMgr *    theMeMgr):

myBopEnt_      (theBopEnt),
firstExecPer_  (firstExecPerVal),
lastExecPer_   (lastExecPerVal),
myMePtForNstn_ (NULL),
myMePtForAsap_ (NULL)
{
myMePtForNstn_ = new WitMePt (this, theMeMgr->myMeDirForNstn ());

if (theMeMgr->myGlobalComp ()->twoWayMultiExec ())
myMePtForAsap_ = new WitMePt (this, theMeMgr->myMeDirForAsap ());
}
d621 4
a624 4
{
delete myMePtForNstn_;
delete myMePtForAsap_;
}
d629 17
a645 17
{
while (true)
{
execPer = theMeDir->nextExecPer (execPer, this);

if (execPer < 0)
return -1;

if (myBopEnt_->execPerOKForExp (execPer))
if (myBopEnt_->impactPeriod ()[execPer] == myExpPer ())
return execPer;
}

return -1;
//
// Avoids a compiler warning.
}
d650 9
a658 9
{
fprintf (myMePtForNstn_->myMeDir ()->myMsgFac ().myFile (),
"   Operation:        %s\n"
"   BOP Entry #:      %d\n"
"   Exp Per:          %d\n",
myBopEnt_->myOperationName ().myCstring (),
myBopEnt_->localIndex (),
myExpPer ());
}
d663 3
a665 3
{
return myBopEnt_->impactPeriod ()[firstExecPer_];
}
d672 1
a672 1
WitDetSelPt (),
d674 6
a679 6
myMeSitePt_ (theMeSitePt),
myMeDir_    (theMeDir),
selExecPer_ (-1)
{
select (myMeDir_->initSelExecPer (myMeSitePt_));
}
d684 2
a685 2
{
}
d690 22
a711 22
{
FILE *        theFile;
WitBopEntry * theBopEnt;

theFile   = myMeDir_->myMsgFac ().myFile ();

theBopEnt = myMeSitePt_->myBopEnt ();

fprintf (theFile,
"\n"
"Multi-Exec Selection Point:\n"
"   Operation %s, BopEntry #%d, Exp Per %d, %s\n",
theBopEnt->myOperationName ().myCstring (),
theBopEnt->localIndex (),
myMeSitePt_->myExpPer (),
myMeDir_->myID ());

if (selExecPer_ >= 0)
fprintf (theFile, "      Selected Exec Per: %d\n", selExecPer_);
else
fprintf (theFile, "      Selected Exec Per: None\n");
}
d716 3
a718 3
{
if (mySelMgr ()->mySelector ()->sglSrc ())
mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (selExecPer_);
d720 2
a721 2
selExecPer_ = execPer;
}
d726 2
a727 2
{
selExecPer_ = myMeDir_->initSelExecPer (myMeSitePt_);
d729 3
a731 3
if (mySelMgr ()->selPrintLevelAt (3))
printRecovery ();
}
d736 3
a738 3
{
return myMeDir_->myMeMgr ();
}
d743 2
a744 2
{
myMeSitePt_->prtID ();
d746 4
a749 4
fprintf (myMeDir_->myMsgFac ().myFile (),
"   Direction:        %s\n",
myMeDir_->myID ());
}
d754 3
a756 3
{
if (myMeDir_->myGlobalComp ()->selSplit ())
return true;
d758 2
a759 2
if (myMeDir_->myGlobalComp ()->nonMrSelSplit ())
return true;
d761 2
a762 2
return myMeSitePt_->myBopEnt ()->meSelSplit ();
}
d767 4
a770 4
{
thePart = myMeSitePt_->myBopEnt ()->myPart ();
thePer  = myMeSitePt_->myExpPer ();
}
d775 3
a777 3
{
return new WitMeCand (selExecPer_, myMeDir_->myProblem ());
}
d782 2
a783 2
{
WitPeriod execPer;
d785 1
a785 1
witAssert (selExecPer_ >= 0);
d787 1
a787 1
execPer = myMeSitePt_->nextExecPer (selExecPer_, myMeDir_);
d789 2
a790 2
return (execPer >= 0);
}
d795 2
a796 2
{
advanceSel ();
d798 2
a799 2
if (myMeDir_->selPrintLevelAt (2))
print ();
d801 4
a804 4
if (myMeDir_->myGlobalComp ()->twoWayMultiExec ())
if (selExecPer_ < 0)
myMeDir_->oppMeDir ()->myMePt (myMeSitePt_)->deSelectAsNeeded ();
}
d809 7
a815 7
{
myMeDir_->
myMeMgr ()->
storeRecoveryPair (
myMeSitePt_->myBopEnt (),
myMeSitePt_->myExpPer ());
}
d820 2
a821 2
{
myMeDir_->myMeMgr ()->saveExecPer (selExecPer_);
d823 2
a824 2
advanceSel ();
}
d829 2
a830 2
{
WitPeriod execPer;
d832 1
a832 1
myMeDir_->myMeMgr ()->retrieveExecPer (execPer);
d834 2
a835 2
select (execPer);
}
d840 2
a841 2
{
}
d846 2
a847 2
{
WitPeriod execPer;
d849 1
a849 1
witAssert (selExecPer_ >= 0);
d851 1
a851 1
execPer = myMeSitePt_->nextExecPer (selExecPer_, myMeDir_);
d853 2
a854 2
select (execPer);
}
d859 9
a867 9
{
if (selExecPer_ < 0)
return;

select (-1);

if (myMeDir_->selPrintLevelAt (2))
print ();
}
d872 15
a886 15
{
fprintf (myMeDir_->myMsgFac ().myFile (),
"\n"
"   Initial Multi-Exec Selection Recovered:\n"
"      Operation:  %s\n"
"      BopEntry #: %d\n"
"      Exp Per:    %d\n"
"      Direction:  %s\n"
"      Exec Per:   %d\n\n",
myMeSitePt_->myBopEnt ()->myOperationName ().myCstring (),
myMeSitePt_->myBopEnt ()->localIndex (),
myMeSitePt_->myExpPer (),
myMeDir_   ->myID     (),
selExecPer_);
}
d894 4
a897 4
WitSelCand (theProblem),
myExecPer_ (execPer)
{
}
d902 2
a903 2
{
}
d908 3
a910 3
{
fprintf (msgFile (), "      Exec Per:      %d\n", myExecPer_);
}
d915 3
a917 3
{
execPer = myExecPer_;
}
@


1.103
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d14 1
a14 1
// 
d46 3
a48 3
   {
   return myMeSitePts_.myPtrTVecAt (theBopEnt).isAllocated ();
   }
d54 20
a73 20
      WitSelMgr        (theSelector),
      myMeDirForNstn_  (NULL),
      myMeDirForAsap_  (NULL),
      myMeSitePts_     (),
      initDirIsAsap_   (false),
      savedExecPer_    (-1),
      myRecoveryPairs_ (myProblem ())
   {
   myMsgFac () ("multiExecMsg");

   myMeDirForNstn_ = new WitNstnMeDir (this);
   myMeDirForAsap_ = new WitAsapMeDir (this);
   
   myMeSitePts_.allocate1D (myProblem ());

   buildMeSitePts ();

   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("twmeMsg");
   }
d78 17
a94 17
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitMeSitePt * theMeSitePt;

   forEachBopEntry (theBopEnt, myProblem ())
      if (hasMeSitePts (theBopEnt))
         {
         expPer = -1;

         while (findNextMeSitePt (theBopEnt, expPer, theMeSitePt))
            delete theMeSitePt;
         }

   delete myMeDirForAsap_;
   delete myMeDirForNstn_;
   }
d99 3
a101 3
   {
   return theProblem->myGlobalComp ()->multiExecNeeded ();
   }
d106 3
a108 3
   {
   initDirIsAsap_ = theValue;
   }
d113 2
a114 2
   {
   WitMePt * theMePt;
d116 1
a116 1
   theMePt = myMePtWithSel (theBopEnt, expPer);
d118 5
a122 5
   return
      (theMePt != NULL)?
         theMePt->selExecPer ():
         theBopEnt ->expExecPeriod ()[expPer];
   }
d127 22
a148 22
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitMeSitePt * theMeSitePt;

   fprintf (msgFile (),
      "\n"
      "Multi-Exec Selection Points:\n");

   forEachBopEntry (theBopEnt, myProblem ())
      if (hasMeSitePts (theBopEnt))
         {
         expPer = -1;

         while (findNextMeSitePt (theBopEnt, expPer, theMeSitePt))
            {
            theMeSitePt->myMePtForNstn ()->print ();

            if (myGlobalComp ()->twoWayMultiExec ())
               theMeSitePt->myMePtForAsap ()->print ();
            }
         }
d150 2
a151 2
   fprintf (msgFile (), "\n");
   }
d156 3
a158 3
   {
   witAssert (savedExecPer_ == -1);
   witAssert (execPer       != -1);
d160 2
a161 2
   savedExecPer_ = execPer;
   }
d166 2
a167 2
   {
   witAssert (savedExecPer_ != -1);
d169 3
a171 3
   execPer       = savedExecPer_;
   savedExecPer_ = -1;
   }
d176 3
a178 3
   {
   myRecoveryPairs_.push (theBopEnt, expPer);
   }
d183 15
a197 15
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitMeSitePt * theMeSitePt;

   while (myRecoveryPairs_.pop (theBopEnt, expPer))
      {
      theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);

      theMeSitePt->   myMePtForNstn ()->recoverInitState ();

      if (myGlobalComp ()->twoWayMultiExec ())
         theMeSitePt->myMePtForAsap ()->recoverInitState ();
      }
   }
d202 2
a203 2
   {
   WitBopEntry * theBopEnt;
d205 2
a206 2
   if (myGlobalComp ()->selSplit ())
      return true;
d208 2
a209 2
   if (myGlobalComp ()->nonMrSelSplit ())
      return true;
d211 4
a214 4
   forEachBopEntry (theBopEnt, myProblem ())
      if (theBopEnt->expAllowed ())
         if (theBopEnt->meSelSplit ())
            return true;
d216 2
a217 2
   return false;
   }
d222 2
a223 2
   {
   WitMePt * theMePt;
d225 2
a226 2
   if (not selSplit ())
      return false;
d228 1
a228 1
   theMePt = myMePtWithSel (theBopEnt, expPer);
d230 2
a231 2
   if (theMePt == NULL)
      return false;
d233 2
a234 2
   return theMePt->isSplit ();
   }
d239 29
a267 29
      WitBopEntry *    theBopEnt,
      WitPeriod        expPer,
      double           expVol,
      WitPerDblStack & theSplitPairs,
      double &         unbddVol)
   {
   WitSelCandDblStack theAbsSplitPairs (myProblem ());
   WitSelCand *       theSelCand;
   double             splitVol;
   WitPeriod          execPer;
   WitFixedPer *      theFixedPer;

   witAssert (selIsSplit (theBopEnt, expPer));

   myMePtWithSel (theBopEnt, expPer)->
      mySplitPt ()->
         defineSplit (expVol, theAbsSplitPairs, unbddVol);

   theSplitPairs.clear ();

   while (theAbsSplitPairs.pop (theSelCand, splitVol))
      {
      theSelCand->getMeData (execPer);

      theFixedPer = mySelector ()->myFixedPer ()[execPer];

      theSplitPairs.push (theFixedPer, splitVol);
      }
   }
d272 7
a278 7
      WitBopEntry * theBopEnt, 
      WitPeriod     execPer, 
      double        expVol)
   {
   WitPeriod     expPer;
   WitMeSitePt * theMeSitePt;
   WitMeDir *    theMeDir;
d280 1
a280 1
   witAssert (selSplit ());
d282 2
a283 2
   if (not hasMeSitePts (theBopEnt))
      return;
d285 1
a285 1
   expPer      = theBopEnt->impactPeriod ()[execPer];
d287 1
a287 1
   theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);
d289 2
a290 2
   if (theMeSitePt == NULL)
      return;
d292 1
a292 1
   theMeDir = chooseMeDir (theBopEnt->myPart ());
d294 2
a295 2
   theMeDir->myMePt (theMeSitePt)->recordFlowSS (expVol);
   }
d300 17
a316 17
      WitBopEntry * theBopEnt,
      WitConsEntry *,
      WitPeriod     execPer,
      WitPeriod)
   {
   WitPeriod expPer;
   WitMePt * theMePt;

   expPer  = theBopEnt->impactPeriod ()[execPer];

   theMePt = myMePtWithSel (theBopEnt, expPer);

   return
      (theMePt != NULL)?
         theMePt->myDetAltPt ():
         NULL;
   }
d321 3
a323 3
   {
   return true;
   }
d328 3
a330 3
   {
   return true;
   }
d335 3
a337 3
   {
   return false;
   }
d342 3
a344 3
   {
   return "Multi-Exec";
   }
d349 40
a388 40
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
   WitPeriod     execPerF;
   WitPeriod     execPerL;

   WitExecPerSched <WitBopEntry> * theExecPerSched;

   theExecPerSched = new WitExecPerSched <WitBopEntry> (myProblem ());

   forEachBopEntry (theBopEnt, myProblem ())
      forEachPeriod (expPer, myProblem ())
         {
         theExecPerSched->getExecPerRange (
            theBopEnt,
            expPer,
            execPerF,
            execPerL);

         for (; execPerF <= execPerL; execPerF ++)
            if (theBopEnt->execPerOKForExp (execPerF))
               break;

         for (; execPerL >= execPerF; execPerL --)
            if (theBopEnt->execPerOKForExp (execPerL))
               break;

         if (execPerF >= execPerL)
            continue;

         if (not myMeSitePts_.myPtrTVecAt (theBopEnt).isAllocated ())
            myMeSitePts_.myPtrTVecAt (theBopEnt).allocate (myProblem ());

         myMeSitePts_.myPtrAt (theBopEnt, expPer) = 
            new WitMeSitePt (
               theBopEnt,
               execPerF,
               execPerL,
               this);
         }
d390 2
a391 2
   delete theExecPerSched;
   }
d396 4
a399 4
   {
   WitMeSitePt * theMeSitePt;
   WitMeDir *    theMeDir;
   WitMePt *     theMePt;
d401 2
a402 2
   if (not hasMeSitePts (theBopEnt))
      return NULL;
d404 1
a404 1
   theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);
d406 2
a407 2
   if (theMeSitePt == NULL)
      return NULL;
d409 1
a409 1
   theMeDir = chooseMeDir (theBopEnt->myPart ());
d411 1
a411 1
   theMePt  = theMeDir->myMePt (theMeSitePt);
d413 5
a417 5
   return
      (theMePt->selExecPer () >= 0)?
         theMePt:
         NULL;
   }
d422 2
a423 2
   {
   WitMaterial * theMat;
d425 2
a426 2
   if (not myGlobalComp ()->twoWayMultiExec ())
      return myMeDirForNstn_;
d428 2
a429 2
   if (initDirIsAsap_)
      return myMeDirForAsap_;
d431 1
a431 1
   theMat = thePart->thisMat ();
d433 3
a435 3
   if (theMat != NULL)
      if (theMat->buildAsap ())
         return myMeDirForAsap_;
d437 2
a438 2
   return myMeDirForNstn_;
   }
d443 11
a453 11
      WitBopEntry *   theBopEnt,
      WitPeriod &     expPer,
      WitMeSitePt * & theMeSitePt)
   {
   while (++ expPer < nPeriods ())
      {
      theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, expPer);
   
      if (theMeSitePt != NULL)
         return true;
      }
d455 2
a456 2
   return false;
   }
d463 2
a464 2
   {
   }
d470 4
a473 4
      WitProbAssoc (theMeMgr),
      myMeMgr_     (theMeMgr)
   {
   }
d480 3
a482 3
      WitMeDir (theMeMgr)
   {
   }
d487 2
a488 2
   {
   }
d493 3
a495 3
   {
   return myMeMgr ()->myMeDirForAsap ();
   }
d500 3
a502 3
   {
   return theMeSitePt->myMePtForNstn ();
   }
d507 3
a509 3
   {
   return theMeSitePt->lastExecPer ();
   }
d514 11
a524 11
      WitPeriod     execPer,
      WitMeSitePt * theMeSitePt)
   {
   witAssert (execPer >= 0);

   if (execPer == theMeSitePt->firstExecPer ())
      return -1;

   if (myGlobalComp ()->twoWayMultiExec ())
      if (execPer == theMeSitePt->myMePtForAsap ()->selExecPer ())
         return -1;
d526 2
a527 2
   return execPer - 1;
   }
d532 3
a534 3
   {
   return "NSTN";
   }
d541 3
a543 3
      WitMeDir (theMeMgr)
   {
   }
d548 2
a549 2
   {
   }
d554 3
a556 3
   {
   return myMeMgr ()->myMeDirForNstn ();
   }
d561 3
a563 3
   {
   return theMeSitePt->myMePtForAsap ();
   }
d568 3
a570 3
   {
   return theMeSitePt->firstExecPer ();
   }
d575 4
a578 4
      WitPeriod     execPer,
      WitMeSitePt * theMeSitePt)
   {
   witAssert (execPer >= 0);
d580 2
a581 2
   if (execPer == theMeSitePt->lastExecPer ())
      return -1;
d583 2
a584 2
   if (execPer == theMeSitePt->myMePtForNstn ()->selExecPer ())
      return -1;
d586 2
a587 2
   return execPer + 1;
   }
d592 3
a594 3
   {
   return "ASAP";
   }
d601 16
a616 16
      WitBopEntry * theBopEnt,
      WitPeriod     firstExecPerVal,
      WitPeriod     lastExecPerVal,
      WitMeMgr *    theMeMgr):

      myBopEnt_      (theBopEnt),
      firstExecPer_  (firstExecPerVal),
      lastExecPer_   (lastExecPerVal),
      myMePtForNstn_ (NULL),
      myMePtForAsap_ (NULL)
   {
   myMePtForNstn_ = new WitMePt (this, theMeMgr->myMeDirForNstn ());

   if (theMeMgr->myGlobalComp ()->twoWayMultiExec ())
      myMePtForAsap_ = new WitMePt (this, theMeMgr->myMeDirForAsap ());
   }
d621 4
a624 4
   {
   delete myMePtForNstn_;
   delete myMePtForAsap_;
   }
d629 17
a645 17
   {
   while (true)
      {
      execPer = theMeDir->nextExecPer (execPer, this);

      if (execPer < 0)
         return -1;

      if (myBopEnt_->execPerOKForExp (execPer))
         if (myBopEnt_->impactPeriod ()[execPer] == myExpPer ())
            return execPer;
      }

   return -1;
      //
      // Avoids a compiler warning.
   }
d650 9
a658 9
   {
   fprintf (myMePtForNstn_->myMeDir ()->myMsgFac ().myFile (),
      "   Operation:        %s\n"
      "   BOP Entry #:      %d\n"
      "   Exp Per:          %d\n",
      myBopEnt_->myOperationName ().myCstring (),
      myBopEnt_->localIndex (),
      myExpPer ());
   }
d663 3
a665 3
   {
   return myBopEnt_->impactPeriod ()[firstExecPer_];
   }
d672 1
a672 1
      WitDetSelPt (),
d674 6
a679 6
      myMeSitePt_ (theMeSitePt),
      myMeDir_    (theMeDir),
      selExecPer_ (-1)
   {              
   select (myMeDir_->initSelExecPer (myMeSitePt_));
   }
d684 2
a685 2
   {
   }
d690 22
a711 22
   {
   FILE *        theFile;
   WitBopEntry * theBopEnt; 

   theFile   = myMeDir_->myMsgFac ().myFile ();

   theBopEnt = myMeSitePt_->myBopEnt ();
 
   fprintf (theFile,
      "\n"
      "Multi-Exec Selection Point:\n"
      "   Operation %s, BopEntry #%d, Exp Per %d, %s\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex (),
      myMeSitePt_->myExpPer (),
      myMeDir_->myID ());

   if (selExecPer_ >= 0)
      fprintf (theFile, "      Selected Exec Per: %d\n", selExecPer_);
   else
      fprintf (theFile, "      Selected Exec Per: None\n");
   }
d716 3
a718 3
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (selExecPer_);
d720 2
a721 2
   selExecPer_ = execPer;
   }
d726 2
a727 2
   {
   selExecPer_ = myMeDir_->initSelExecPer (myMeSitePt_);
d729 3
a731 3
   if (mySelMgr ()->selPrintLevelAt (3))
      printRecovery ();
   }
d736 3
a738 3
   {
   return myMeDir_->myMeMgr ();
   }
d743 2
a744 2
   {
   myMeSitePt_->prtID ();
d746 4
a749 4
   fprintf (myMeDir_->myMsgFac ().myFile (),
      "   Direction:        %s\n",
      myMeDir_->myID ());
   }
d754 3
a756 3
   {
   if (myMeDir_->myGlobalComp ()->selSplit ())
      return true;
d758 2
a759 2
   if (myMeDir_->myGlobalComp ()->nonMrSelSplit ())
      return true;
d761 2
a762 2
   return myMeSitePt_->myBopEnt ()->meSelSplit ();
   }
d767 4
a770 4
   {
   thePart = myMeSitePt_->myBopEnt ()->myPart ();
   thePer  = myMeSitePt_->myExpPer ();
   }
d775 3
a777 3
   {
   return new WitMeCand (selExecPer_, myMeDir_->myProblem ());
   }
d782 2
a783 2
   {
   WitPeriod execPer;
d785 1
a785 1
   witAssert (selExecPer_ >= 0);
d787 1
a787 1
   execPer = myMeSitePt_->nextExecPer (selExecPer_, myMeDir_);
d789 2
a790 2
   return (execPer >= 0);
   }
d795 2
a796 2
   {
   advanceSel ();
d798 2
a799 2
   if (myMeDir_->selPrintLevelAt (2))
      print ();
d801 4
a804 4
   if (myMeDir_->myGlobalComp ()->twoWayMultiExec ())
      if (selExecPer_ < 0)
         myMeDir_->oppMeDir ()->myMePt (myMeSitePt_)->deSelectAsNeeded ();
   }
d809 7
a815 7
   {
   myMeDir_->
      myMeMgr ()->
         storeRecoveryPair (
            myMeSitePt_->myBopEnt (),
            myMeSitePt_->myExpPer ());
   }
d820 2
a821 2
   {
   myMeDir_->myMeMgr ()->saveExecPer (selExecPer_);
d823 2
a824 2
   advanceSel ();
   }
d829 2
a830 2
   {
   WitPeriod execPer;
d832 1
a832 1
   myMeDir_->myMeMgr ()->retrieveExecPer (execPer);
d834 2
a835 2
   select (execPer);
   }
d840 2
a841 2
   {
   }
d846 2
a847 2
   {
   WitPeriod execPer;
d849 1
a849 1
   witAssert (selExecPer_ >= 0);
d851 1
a851 1
   execPer = myMeSitePt_->nextExecPer (selExecPer_, myMeDir_);
d853 2
a854 2
   select (execPer);
   }
d859 9
a867 9
   {
   if (selExecPer_ < 0)
      return;

   select (-1);

   if (myMeDir_->selPrintLevelAt (2))
      print ();
   }
d872 15
a886 15
   {
   fprintf (myMeDir_->myMsgFac ().myFile (),
      "\n"
      "   Initial Multi-Exec Selection Recovered:\n"
      "      Operation:  %s\n"
      "      BopEntry #: %d\n"
      "      Exp Per:    %d\n"
      "      Direction:  %s\n"
      "      Exec Per:   %d\n\n",
      myMeSitePt_->myBopEnt ()->myOperationName ().myCstring (),
      myMeSitePt_->myBopEnt ()->localIndex (),
      myMeSitePt_->myExpPer (),
      myMeDir_   ->myID     (),
      selExecPer_);
   }
d894 4
a897 4
      WitSelCand (theProblem),
      myExecPer_ (execPer)
   {
   }
d902 2
a903 2
   {
   }
d908 3
a910 3
   {
   fprintf (msgFile (), "      Exec Per:      %d\n", myExecPer_);
   }
d915 3
a917 3
   {
   execPer = myExecPer_;
   }
@


1.102
log
@Heuristic Adjustment
@
text
@a31 1
#include <RecoverySet.h>
a52 1
      WitSelMgr       (theSelector),
d54 7
a60 6
      myMeDirForNstn_ (NULL),
      myMeDirForAsap_ (NULL),
      myMeSitePts_    (),
      initDirIsAsap_  (false),
      savedExecPer_   (-1),
      myRecoverySet_  (NULL)
a70 5
   if (myGlobalComp ()->selectionRecovery ())
      {
      myRecoverySet_ = new WitRecoverySet <WitMeMgr, WitBopEntry> (this);
      }

a82 2
   delete myRecoverySet_;

d175 1
a175 1
void WitMeMgr::recoverInitState (WitBopEntry * theBopEnt, WitPeriod thePer)
d177 9
d188 3
a190 1
   theMeSitePt = myMeSitePts_.myPtrAt (theBopEnt, thePer);
d192 1
a192 1
   theMeSitePt->   myMePtForNstn ()->recoverInitState ();
d194 3
a196 2
   if (myGlobalComp ()->twoWayMultiExec ())
      theMeSitePt->myMePtForAsap ()->recoverInitState ();
d812 3
a814 4
         myRecoverySet ()->
            storeRecoveryPt (
               myMeSitePt_->myBopEnt (),
               myMeSitePt_->myExpPer ());
@


1.101
log
@Selection Recovery
@
text
@d37 1
a37 1
#include <Opn.h>
@


1.100
log
@Selection Recovery
@
text
@d32 1
a32 1
#include <AltSet.h>
d61 1
a61 1
      myAltSet_       (NULL)
d74 1
a74 1
      myAltSet_ = new WitAltSet <WitMeMgr, WitBopEntry> (this);
d89 1
a89 1
   delete myAltSet_;
d183 1
a183 1
void WitMeMgr::recoverInitSel (WitBopEntry * theBopEnt, WitPeriod thePer)
d189 1
a189 1
   theMeSitePt->   myMePtForNstn ()->recoverInitSel ();
d192 1
a192 1
      theMeSitePt->myMePtForAsap ()->recoverInitSel ();
d721 1
a721 1
void WitMePt::recoverInitSel ()
d804 1
a804 1
void WitMePt::recAltForRecovery ()
d808 2
a809 2
         myAltSet ()->
            recAltForRecovery (
@


1.99
log
@Selection Recovery
@
text
@d804 1
a804 1
void WitMePt::recordAlteration ()
d809 1
a809 1
            recordAlteration (
@


1.98
log
@Selection Recovery
@
text
@a64 5
   if (myGlobalComp ()->selectionRecovery ())
      {
      myAltSet_ = new WitAltSet <WitMeMgr, WitBopEntry> (this);
      }

d72 5
@


1.97
log
@Selection Recovery
@
text
@a716 10

   if (mySelMgr ()->myGlobalComp ()->selectionRecovery ())
      {
      myMeDir_->
         myMeMgr ()->
            myAltSet ()->
               recordAlteration (
                  myMeSitePt_->myBopEnt (),
                  myMeSitePt_->myExpPer ());
      }
d804 12
@


1.96
log
@Selection Recovery.
@
text
@d32 1
d56 6
a61 7
      myMeDirForNstn_   (NULL),
      myMeDirForAsap_   (NULL),
      myMeSitePts_      (),
      initDirIsAsap_    (false),
      savedExecPer_     (-1),
      alteredMeSitePts_ (myProblem ()),
      meAlteredAt_      ()
d66 3
a68 1
      meAlteredAt_.allocate (myProblem (), false);
d89 2
d183 1
a183 21
void WitMeMgr::recordAlteration (WitMeSitePt * theMeSitePt)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;

   witAssert (myGlobalComp ()->selectionRecovery ());

   theBopEnt = theMeSitePt->myBopEnt ();
   expPer    = theMeSitePt->myExpPer ();

   if (meAlteredAt_ (theBopEnt)[expPer])
      return;

   meAlteredAt_ (theBopEnt)[expPer] = true;

   alteredMeSitePts_.push (theMeSitePt);
   }

//------------------------------------------------------------------------------

void WitMeMgr::recoverSelections ()
a185 2
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;
d187 1
a187 3
   while (alteredMeSitePts_.pop (theMeSitePt))
      {
      theMeSitePt->   myMePtForNstn ()->recoverInitSel ();
d189 1
a189 2
      if (myGlobalComp ()->twoWayMultiExec ())
         theMeSitePt->myMePtForAsap ()->recoverInitSel ();
d191 2
a192 5
      theBopEnt = theMeSitePt->myBopEnt ();
      expPer    = theMeSitePt->myExpPer ();

      meAlteredAt_ (theBopEnt)[expPer] = false;
      }
d720 6
a725 1
      myMeDir_->myMeMgr ()->recordAlteration (myMeSitePt_);
@


1.95
log
@Selection Recovery.
@
text
@d199 22
a367 22
void WitMeMgr::recoverSelections ()
   {
   WitMeSitePt * theMeSitePt;
   WitBopEntry * theBopEnt;
   WitPeriod     expPer;

   while (alteredMeSitePts_.pop (theMeSitePt))
      {
      theMeSitePt->   myMePtForNstn ()->recoverInitSel ();

      if (myGlobalComp ()->twoWayMultiExec ())
         theMeSitePt->myMePtForAsap ()->recoverInitSel ();

      theBopEnt = theMeSitePt->myBopEnt ();
      expPer    = theMeSitePt->myExpPer ();

      meAlteredAt_ (theBopEnt)[expPer] = false;
      }
   }

//------------------------------------------------------------------------------

@


1.94
log
@Selection Recovery
@
text
@d55 7
a61 5
      myMeDirForNstn_ (NULL),
      myMeDirForAsap_ (NULL),
      myMeSitePts_    (),
      initDirIsAsap_  (false),
      savedExecPer_   (-1)
d65 3
d179 20
d348 16
d743 13
a755 1
      recAlteratOld ();
a805 33
void WitMePt::printRecoverO ()
   {
   WitPeriod initExecPer;

   initExecPer = myMeDir_->initSelExecPer (myMeSitePt_);

   if (selExecPer_ == initExecPer)
      return;

   fprintf (myMeDir_->myMsgFac ().myFile (),
      "\n"
      "   Initial Multi-Exec Selection Recovered:\n"
      "      Operation:  %s\n"
      "      BopEntry #: %d\n"
      "      Exp Per:    %d\n"
      "      Direction:  %s\n"
      "      Exec Per:   %d\n\n",
      myMeSitePt_->myBopEnt ()->myOperationName ().myCstring (),
      myMeSitePt_->myBopEnt ()->localIndex (),
      myMeSitePt_->myExpPer (),
      myMeDir_   ->myID     (),
      initExecPer);
   }

//------------------------------------------------------------------------------

void WitMePt::recoverInitSeO ()
   {
   selExecPer_ = myMeDir_->initSelExecPer (myMeSitePt_);
   }

//------------------------------------------------------------------------------

d884 19
@


1.93
log
@Selection Recovery
@
text
@d702 1
a702 1
      recAlteration ();
@


1.92
log
@Selection Recovery.
@
text
@d321 6
d753 1
a753 1
void WitMePt::printRecovery ()
d779 1
a779 1
void WitMePt::recoverInitSel ()
@


1.91
log
@Selection recovery.
@
text
@d747 1
a747 8
void WitMePt::recoverInitSel ()
   {
   selExecPer_ = myMeDir_->initSelExecPer (myMeSitePt_);
   }

//------------------------------------------------------------------------------

void WitMePt::prtRecInitSel ()
d773 7
@


1.90
log
@Name change: "selection reuse" has becomne "selection recovery".
@
text
@d747 1
a747 1
void WitMePt::restoreInitSel ()
d754 1
a754 1
void WitMePt::prtRestInitSel ()
d765 1
a765 1
      "   Initial Multi-Exec Selection Restored:\n"
@


1.89
log
@Selection reuse.
@
text
@d695 1
a695 1
   if (mySelMgr ()->myGlobalComp ()->selectionReuse ())
@


1.88
log
@Selection Reuse.
@
text
@d797 1
a797 1
   if (myMeDir_->myGlobalComp ()->selPrintLevel () >= 2)
d853 1
a853 1
   if (myMeDir_->myGlobalComp ()->selPrintLevel () >= 2)
@


1.87
log
@Lead Time Bounds
@
text
@d694 3
d747 33
@


1.86
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d307 7
@


1.85
log
@Stochastic Implosion
@
text
@d34 1
a34 1
#include <Global.h>
@


1.84
log
@Stochastic Implosion
@
text
@a434 1
      WitProbAssoc (theMeMgr->myProblem ()),
d436 1
@


1.83
log
@Updated the copyright date on all source files.
@
text
@d316 4
a319 5
   WitExecPerSched * theExecPerSched;
   WitBopEntry *     theBopEnt;
   WitPeriod         expPer;
   WitPeriod         execPerFirst;
   WitPeriod         execPerLast;
d321 3
a323 1
   theExecPerSched = new WitExecPerSched (myProblem ());
a325 6
      {
      if (not theExecPerSched->hasMultiExec (theBopEnt))
         continue;

      myMeSitePts_.myPtrTVecAt (theBopEnt).allocate (myProblem ());

d331 2
a332 2
            execPerFirst,
            execPerLast);
d334 20
a353 7
         if (execPerFirst < execPerLast)
            myMeSitePts_.myPtrAt (theBopEnt, expPer) = 
               new WitMeSitePt (
                  theBopEnt,
                  execPerFirst,
                  execPerLast,
                  this);
a354 1
      }
@


1.82
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.81
log
@Revised mappingIndex code.
@
text
@d33 1
d316 5
a320 6
   WitTVec <WitPeriod> firstExecPer;
   WitTVec <WitPeriod> lastExecPer;
   bool                multiExecFound;
   WitBopEntry *       theBopEnt;
   WitPeriod           execPer;
   WitPeriod           expPer;
d322 1
a322 4
   firstExecPer.allocate (myProblem (), -1);
   lastExecPer .allocate (myProblem (), -1);

   multiExecFound = false;
d325 2
a326 2
      {  
      if (not theBopEnt->expAllowed ())
d329 1
a329 11
      forEachPeriod (execPer, myProblem ())
         {
         if (not theBopEnt->execPerOKForExp (execPer))
            continue;

         expPer = theBopEnt->impactPeriod ()[execPer];

         if (firstExecPer[expPer] < 0)
            firstExecPer[expPer] = execPer;
         else
            multiExecFound       = true;
d331 1
a331 4
         lastExecPer[expPer]     = execPer;
         }

      if (multiExecFound)
d333 13
a345 10
         myMeSitePts_.myPtrTVecAt (theBopEnt).allocate (myProblem ());

         forEachPeriod (expPer, myProblem ())
            if (firstExecPer[expPer] != lastExecPer[expPer])
               myMeSitePts_.myPtrAt (theBopEnt, expPer) = 
                  new WitMeSitePt (
                     theBopEnt,
                     firstExecPer[expPer],
                     lastExecPer [expPer],
                     this);
a346 4
            
      firstExecPer   = -1;
      lastExecPer    = -1;
      multiExecFound = false;
d348 2
@


1.80
log
@Low-Pri Prop-Rt.
@
text
@a38 1
#include <MapIdxI.h>
@


1.79
log
@Low-Pri Prop-Rt.
@
text
@a699 6
void WitMePt::printSelection ()
   {
   }

//------------------------------------------------------------------------------

d793 6
@


1.78
log
@Low-Pri Prop-Rt.
@
text
@d58 2
a59 1
      initDirIsAsap_  (false)
d154 20
d781 2
d788 1
a788 1
void WitMePt::cancelTempAlt (WitSelCand * theSelCand)
d792 1
a792 3
   witAssert (theSelCand != NULL);

   theSelCand->getMeData (execPer);
a798 7
bool WitMePt::cancelNeedsSelCand ()
   {
   return true;
   }

//------------------------------------------------------------------------------

@


1.77
log
@Low-Pri Prop-Rt.
@
text
@a715 11
void WitMePt::restoreSelTo (WitSelCand * theSelCand)
   {
   WitPeriod execPer;

   theSelCand->getMeData (execPer);

   select (execPer);
   }

//------------------------------------------------------------------------------

d765 20
@


1.76
log
@Low-Pri Prop-Rt.
@
text
@d716 11
d737 1
a737 1
   return new WitMeCand (this);
d804 1
a804 1
WitMeCand::WitMeCand (WitMePt * theMePt):
d806 2
a807 3
      WitSelCand (theMePt->myMeDir ()->myProblem ()),
      myMePt_    (theMePt),
      myExecPer_ (theMePt->selExecPer ())
a825 7
void WitMeCand::restoreSelToThis ()
   {
   myMePt_->select (myExecPer_);
   }

//------------------------------------------------------------------------------

@


1.75
log
@Low-Pri Prop-Rt.
@
text
@d195 1
a195 1
      bool &           lastUnbdd)
a197 1
   double             unbddVol;
a208 2
   lastUnbdd = (unbddVol > 0.0);

a210 9
   if (lastUnbdd)
      {
      execPer     = selExecPer (theBopEnt, expPer);

      theFixedPer = mySelector ()->myFixedPer ()[execPer];

      theSplitPairs.push (theFixedPer, unbddVol);
      }

@


1.74
log
@Low-Pri Prop-Rt.
@
text
@a196 1
   WitSplitPt *       theSplitPt;
d198 1
d206 3
a208 1
   theSplitPt = myMePtWithSel (theBopEnt, expPer)->mySplitPt ();
d210 1
a210 1
   theSplitPt->defineSplit (expVol, theAbsSplitPairs, lastUnbdd);
d214 9
a827 7
void WitMeCand::updateToCurSel ()
   {
   myExecPer_ = myMePt_->selExecPer ();
   }

//------------------------------------------------------------------------------

@


1.73
log
@Low-Pri Prop-Rt.
@
text
@d29 1
d267 1
a267 1
         theMePt->myAltPt ():
a679 13
bool WitMePt::hasResAlt ()
   {
   WitPeriod execPer;

   witAssert (selExecPer_ >= 0);

   execPer = myMeSitePt_->nextExecPer (selExecPer_, myMeDir_);

   return (execPer >= 0);
   }

//------------------------------------------------------------------------------

d732 13
@


1.72
log
@Low-Pri Prop-Rt.
@
text
@d251 1
a251 1
WitSelAlt * WitMeMgr::mySelAltFor (
d266 1
a266 1
         theMePt->mySelAlt ():
@


1.71
log
@An attempt to fix warnings from the gcc 3.3.3 compiler.
@
text
@a736 7
void WitMePt::tempAlterSel ()
   {
   advanceSel ();
   }

//------------------------------------------------------------------------------

d758 7
@


1.70
log
@Low-Pri Prop-Rt.
@
text
@d605 1
a605 1
   fprintf (myMePtForNstn_->myProblem ()->myMsgFac ().myFile (),
a624 7
inline WitProblem * WitMePt::myProblem ()
   {
   return myMeDir_->myProblem ();
   }

//------------------------------------------------------------------------------

d648 1
a648 1
   theFile   = myProblem ()->myMsgFac ().myFile ();
d709 1
a709 1
   fprintf (myProblem ()->myMsgFac ().myFile (),
d718 1
a718 1
   if (myProblem ()->myGlobalComp ()->selSplit ())
d721 1
a721 1
   if (myProblem ()->myGlobalComp ()->nonMrSelSplit ())
d755 1
a755 1
   if (myProblem ()->myGlobalComp ()->selPrintLevel () >= 2)
d758 1
a758 1
   if (myProblem ()->myGlobalComp ()->twoWayMultiExec ())
d785 1
a785 1
   if (myProblem ()->myGlobalComp ()->selPrintLevel () >= 2)
d795 1
a795 1
      WitSelCand (theMePt->myProblem ()),
@


1.69
log
@Low-Pri Prop-Rt.
@
text
@d251 1
a251 1
WitSelPt * WitMeMgr::mySelPtForAlt (
d258 1
d260 1
a260 1
   expPer = theBopEnt->impactPeriod ()[execPer];
d262 6
a267 1
   return myMePtWithSel (theBopEnt, expPer);
a698 14
void WitMePt::alterSelection ()
   {
   advanceSel ();

   if (myProblem ()->myGlobalComp ()->selPrintLevel () >= 2)
      print ();

   if (myProblem ()->myGlobalComp ()->twoWayMultiExec ())
      if (selExecPer_ < 0)
         myMeDir_->oppMeDir ()->myMePt (myMeSitePt_)->deSelectAsNeeded ();
   }

//------------------------------------------------------------------------------

d758 14
@


1.68
log
@Low-Pri Prop-Rt.
@
text
@d627 1
a627 1
      WitSelPt    (),
@


1.67
log
@Low-Pri Prop-Rt.
@
text
@d213 1
a213 1
      execPer     = theSelCand->myMeCand ()->myExecPer ();
d831 1
a831 1
WitMeCand * WitMeCand::myMeCand ()
d833 1
a833 1
   return this;
@


1.66
log
@Low-Pri Prop-Rt.
@
text
@a286 7
WitSelCand * WitMeMgr::newSelCand ()
   {
   return new WitMeCand (this);
   }

//------------------------------------------------------------------------------

d759 1
a759 1
void WitMePt::setToMyCurSel (WitSelCand * theSelCand)
d761 1
a761 1
   theSelCand->setToCurSelOf (this);
d794 1
a794 1
WitMeCand::WitMeCand (WitMeMgr * theMeMgr):
d796 3
a798 3
      WitSelCand (theMeMgr),
      myMePt_    (NULL),
      myExecPer_ (-1)
d817 1
a817 1
void WitMeCand::restoreSelToThis ()
d819 1
a819 3
   witAssert (active ());

   myMePt_->select (myExecPer_);
d824 1
a824 1
WitMeCand * WitMeCand::myMeCand ()
d826 1
a826 3
   witAssert (active ());

   return this;
d831 1
a831 1
void WitMeCand::setToCurSelOf (WitMePt * theMePt)
d833 1
a833 4
   witAssert (active ());

   myMePt_    = theMePt;
   myExecPer_ = theMePt->selExecPer ();
@


1.65
log
@Low-Pri Prop-Rt.
@
text
@d677 10
a765 7
void WitMePt::restoreSel (WitSelCand * theSelCand)
   {
   select (theSelCand->myMeCand ()->myExecPer ());
   }

//------------------------------------------------------------------------------

a797 10

void WitMePt::select (WitPeriod execPer)
   {
   if (mySelMgr ()->mySelector ()->sglSrc ())
      mySelMgr ()->mySelector ()->mySglSrcMgr ()->saveConfigVal (selExecPer_);

   selExecPer_ = execPer;
   }

//------------------------------------------------------------------------------
d804 1
d824 9
d846 1
@


1.64
log
@Low-Pri Prop-Rt.
@
text
@d763 1
a763 1
void WitMePt::setToCurSel (WitSelCand * theSelCand)
d765 1
a765 1
   theSelCand->myMeCand ()->setToCurSel (this);
d823 1
a823 1
void WitMeCand::setToCurSel (WitMePt * theMePt)
d825 1
a825 3
   witAssert (active ());

   myExecPer_ = theMePt->selExecPer ();
d830 1
a830 1
void WitMeCand::prtID ()
d832 3
a834 1
   fprintf (msgFile (), "      Exec Per:      %d\n", myExecPer_);
d839 1
a839 1
WitMeCand * WitMeCand::myMeCand ()
d843 1
a843 1
   return this;
@


1.63
log
@Low-Pri Prop-Rt.
@
text
@d825 2
d841 2
@


1.62
log
@Low-Pri Prop-Rt.
@
text
@d19 1
a19 1
//    MeCoordPt.
d27 1
d44 1
a44 1
inline bool WitMeMgr::hasMeCoordPts (WitBopEntry * theBopEnt)
d46 1
a46 1
   return myMeCoordPts_.myPtrTVecAt (theBopEnt).isAllocated ();
d56 1
a56 1
      myMeCoordPts_   (),
d64 1
a64 1
   myMeCoordPts_.allocate1D (myProblem ());
d66 1
a66 1
   buildMeCoordPts ();
d76 3
a78 3
   WitBopEntry *  theBopEnt;
   WitPeriod      expPer;
   WitMeCoordPt * theMeCoordPt;
d81 1
a81 1
      if (hasMeCoordPts (theBopEnt))
d85 2
a86 2
         while (findNextMeCoordPt (theBopEnt, expPer, theMeCoordPt))
            delete theMeCoordPt;
d125 3
a127 3
   WitBopEntry *  theBopEnt;
   WitPeriod      expPer;
   WitMeCoordPt * theMeCoordPt;
d134 1
a134 1
      if (hasMeCoordPts (theBopEnt))
d138 1
a138 1
         while (findNextMeCoordPt (theBopEnt, expPer, theMeCoordPt))
d140 1
a140 1
            theMeCoordPt->myMePtForNstn ()->print ();
d143 1
a143 1
               theMeCoordPt->myMePtForAsap ()->print ();
d228 3
a230 3
   WitPeriod      expPer;
   WitMeCoordPt * theMeCoordPt;
   WitMeDir *     theMeDir;
d234 1
a234 1
   if (not hasMeCoordPts (theBopEnt))
d237 1
a237 1
   expPer       = theBopEnt->impactPeriod ()[execPer];
d239 1
a239 1
   theMeCoordPt = myMeCoordPts_.myPtrAt (theBopEnt, expPer);
d241 1
a241 1
   if (theMeCoordPt == NULL)
d246 1
a246 1
   theMeDir->myMePt (theMeCoordPt)->recordFlowSS (expVol);
d294 1
a294 1
void WitMeMgr::buildMeCoordPts ()
d330 1
a330 1
         myMeCoordPts_.myPtrTVecAt (theBopEnt).allocate (myProblem ());
d334 2
a335 2
               myMeCoordPts_.myPtrAt (theBopEnt, expPer) = 
                  new WitMeCoordPt (
d352 3
a354 3
   WitMeCoordPt * theMeCoordPt;
   WitMeDir *     theMeDir;
   WitMePt *      theMePt;
d356 1
a356 1
   if (not hasMeCoordPts (theBopEnt))
d359 1
a359 1
   theMeCoordPt = myMeCoordPts_.myPtrAt (theBopEnt, expPer);
d361 1
a361 1
   if (theMeCoordPt == NULL)
d366 1
a366 1
   theMePt  = theMeDir->myMePt (theMeCoordPt);
d397 4
a400 4
bool WitMeMgr::findNextMeCoordPt (
      WitBopEntry *    theBopEnt,
      WitPeriod &      expPer,
      WitMeCoordPt * & theMeCoordPt)
d404 1
a404 1
      theMeCoordPt = myMeCoordPts_.myPtrAt (theBopEnt, expPer);
d406 1
a406 1
      if (theMeCoordPt != NULL)
d454 1
a454 1
WitMePt * WitNstnMeDir::myMePt (WitMeCoordPt * theMeCoordPt)
d456 1
a456 1
   return theMeCoordPt->myMePtForNstn ();
d461 1
a461 1
WitPeriod WitNstnMeDir::initSelExecPer (WitMeCoordPt * theMeCoordPt)
d463 1
a463 1
   return theMeCoordPt->lastExecPer ();
d469 2
a470 2
      WitPeriod      execPer,
      WitMeCoordPt * theMeCoordPt)
d474 1
a474 1
   if (execPer == theMeCoordPt->firstExecPer ())
d478 1
a478 1
      if (execPer == theMeCoordPt->myMePtForAsap ()->selExecPer ())
d515 1
a515 1
WitMePt * WitAsapMeDir::myMePt (WitMeCoordPt * theMeCoordPt)
d517 1
a517 1
   return theMeCoordPt->myMePtForAsap ();
d522 1
a522 1
WitPeriod WitAsapMeDir::initSelExecPer (WitMeCoordPt * theMeCoordPt)
d524 1
a524 1
   return theMeCoordPt->firstExecPer ();
d530 2
a531 2
      WitPeriod      execPer,
      WitMeCoordPt * theMeCoordPt)
d535 1
a535 1
   if (execPer == theMeCoordPt->lastExecPer ())
d538 1
a538 1
   if (execPer == theMeCoordPt->myMePtForNstn ()->selExecPer ())
d552 1
a552 1
// Implementation of class MeCoordPt.
d555 1
a555 1
WitMeCoordPt::WitMeCoordPt (
d575 1
a575 1
WitMeCoordPt::~WitMeCoordPt ()
d583 1
a583 1
WitPeriod WitMeCoordPt::nextExecPer (WitPeriod execPer, WitMeDir * theMeDir)
d604 1
a604 1
void WitMeCoordPt::prtID ()
d617 1
a617 1
WitPeriod WitMeCoordPt::myExpPer ()
d633 2
a634 2
WitMePt::WitMePt (WitMeCoordPt * theMeCoordPt, WitMeDir * theMeDir):
      WitSelPt     (),
d636 3
a638 3
      myMeCoordPt_ (theMeCoordPt),
      myMeDir_     (theMeDir),
      selExecPer_  (-1)
d640 1
a640 1
   select (myMeDir_->initSelExecPer (myMeCoordPt_));
d658 1
a658 1
   theBopEnt = myMeCoordPt_->myBopEnt ();
d666 1
a666 1
      myMeCoordPt_->myExpPer (),
d683 1
a683 1
   execPer = myMeCoordPt_->nextExecPer (selExecPer_, myMeDir_);
d699 1
a699 1
         myMeDir_->oppMeDir ()->myMePt (myMeCoordPt_)->deSelectAsNeeded ();
d719 1
a719 1
   myMeCoordPt_->prtID ();
d736 1
a736 1
   return myMeCoordPt_->myBopEnt ()->meSelSplit ();
d743 2
a744 2
   thePart = myMeCoordPt_->myBopEnt ()->myPart ();
   thePer  = myMeCoordPt_->myExpPer ();
d776 1
a776 1
   execPer = myMeCoordPt_->nextExecPer (selExecPer_, myMeDir_);
@


1.61
log
@Low-Pri Prop-Rt.
@
text
@a52 1
      myMeCandFor_    (myProblem ()),
a57 2
   WitPeriod execPer;

a59 3
   forEachPeriod (execPer, myProblem ())
      myMeCandFor_[execPer] = new WitMeCand (execPer, this);

a89 2

   deleteContents (myMeCandFor_);
d286 7
a726 9
WitSelCand * WitMePt::curSelCand ()
   {
   witAssert (selExecPer_ >= 0);

   return myMeDir_->myMeMgr ()->myMeCandFor ()[selExecPer_];
   }

//------------------------------------------------------------------------------

d762 7
d807 1
a807 1
WitMeCand::WitMeCand (WitPeriod execPer, WitMeMgr * theMeMgr):
d810 5
d816 1
a816 1
      myExecPer_ (execPer)
d822 1
a822 1
WitMeCand::~WitMeCand ()
d824 1
@


1.60
log
@
Low-Pri Prop-Rt.
@
text
@d64 1
a64 1
      myMeCandFor_[execPer] = new WitMeCand (execPer, myProblem ());
d810 1
a810 1
WitMeCand::WitMeCand (WitPeriod execPer, WitProblem * theProblem):
d812 1
a812 1
      WitSelCand (theProblem),
@


1.59
log
@Low-Pri Prop-Rt.
@
text
@d30 1
d53 1
a53 1
      myMeCands_      (myProblem ()),
d59 1
a59 2
   WitMeCand * theMeCand;
   WitPeriod   execPer;
a62 2
   theMeCand = NULL;

d64 1
a64 7
      {
      theMeCand = new WitMeCand (execPer, theMeCand, this);

      myMeCands_.push (theMeCand);
      }

   myMeCands_.reverse ();
d97 1
a97 1
   deleteContents (myMeCands_);
d124 1
a124 1
         theMePt->selMeCand ()->myExecPer ():
d296 6
a301 7
   WitPtrTVec <WitMeCand>  firstMeCand;
   WitPtrTVec <WitMeCand>  lastMeCand;
   bool                    multiExecFound;
   WitBopEntry *           theBopEnt;
   WitObjStItr <WitMeCand> theMeCandItr;
   WitPeriod               execPer;
   WitPeriod               expPer;
d303 2
a304 2
   firstMeCand.allocate (myProblem ());
   lastMeCand .allocate (myProblem ());
d313 1
a313 3
      theMeCandItr.attachTo (myMeCands_);

      while (theMeCandItr.advance ())
a314 2
         execPer = theMeCandItr->myExecPer ();

d320 2
a321 2
         if (firstMeCand[expPer] == NULL)
            firstMeCand [expPer] = theMeCandItr.myObject ();
d325 1
a325 1
         lastMeCand [expPer]     = theMeCandItr.myObject ();
d333 1
a333 1
            if (firstMeCand[expPer] != lastMeCand[expPer])
d337 2
a338 2
                     firstMeCand[expPer],
                     lastMeCand [expPer],
d342 2
a343 3
      firstMeCand.setToNull ();
      lastMeCand .setToNull ();

d369 1
a369 1
      (theMePt->selMeCand () != NULL)?
d461 1
a461 1
WitMeCand * WitNstnMeDir::initSelMeCand (WitMeCoordPt * theMeCoordPt)
d463 1
a463 1
   return theMeCoordPt->lastMeCand ();
d468 2
a469 2
WitMeCand * WitNstnMeDir::nextMeCand (
      WitMeCand *    theMeCand,
d472 1
a472 1
   witAssert (theMeCand != NULL);
d474 2
a475 2
   if (theMeCand == theMeCoordPt->firstMeCand ())
      return NULL;
d478 2
a479 2
      if (theMeCand == theMeCoordPt->myMePtForAsap ()->selMeCand ())
         return NULL;
d481 1
a481 1
   return theMeCand->prev ();
d522 1
a522 1
WitMeCand * WitAsapMeDir::initSelMeCand (WitMeCoordPt * theMeCoordPt)
d524 1
a524 1
   return theMeCoordPt->firstMeCand ();
d529 2
a530 2
WitMeCand * WitAsapMeDir::nextMeCand (
      WitMeCand *    theMeCand,
d533 1
a533 1
   witAssert (theMeCand != NULL);
d535 2
a536 2
   if (theMeCand == theMeCoordPt->lastMeCand ())
      return NULL;
d538 2
a539 2
   if (theMeCand == theMeCoordPt->myMePtForNstn ()->selMeCand ())
      return NULL;
d541 1
a541 1
   return theMeCand->next ();
d557 2
a558 2
      WitMeCand *   firstMeCandVal,
      WitMeCand *   lastMeCandVal,
d562 2
a563 2
      firstMeCand_   (firstMeCandVal),
      lastMeCand_    (lastMeCandVal),
d583 1
a583 3
WitMeCand * WitMeCoordPt::nextMeCand (
      WitMeCand * theMeCand, 
      WitMeDir *  theMeDir)
a584 2
   WitPeriod execPer;

d587 1
a587 4
      theMeCand = theMeDir->nextMeCand (theMeCand, this);

      if (theMeCand == NULL)
         return NULL;
d589 2
a590 1
      execPer = theMeCand->myExecPer ();
d594 1
a594 1
            return theMeCand;
d597 1
a597 1
   return NULL;
d619 1
a619 1
   return myBopEnt_->impactPeriod ()[firstMeCand_->myExecPer ()];
d637 4
a640 3
      myMeDir_     (theMeDir)
   {
   select (myMeDir_->initSelMeCand (myMeCoordPt_));
d669 2
a670 4
   if (selMeCand () != NULL)
      fprintf (theFile, 
         "      Selected Exec Per: %d\n", 
         selMeCand ()->myExecPer ());
d679 1
a679 1
   witAssert (selMeCand () != NULL);
d681 5
a685 1
   return (myMeCoordPt_->nextMeCand (selMeCand (), myMeDir_) != NULL);
d698 1
a698 1
      if (selMeCand () == NULL)
d730 3
a732 1
   return selSelCand ();
d767 1
a767 4
   if (DEBUG_MODE)
      theSelCand->myMeCand ();

   select (theSelCand);
d774 7
a780 1
   select (myMeCoordPt_->nextMeCand (selMeCand (), myMeDir_));
d787 1
a787 1
   if (selMeCand () == NULL)
d790 1
a790 1
   select (NULL);
d797 10
d810 5
a814 11
WitMeCand::WitMeCand (
         WitPeriod   execPer, 
         WitMeCand * theMeCand, 
         WitMeMgr *  theMeMgr):

      WitSelCand (theMeMgr->myProblem ()),

      myExecPer_ (execPer),
      prev_      (theMeCand),
      next_      (NULL),
      myMeMgr_   (theMeMgr)
a815 2
   if (prev_ != NULL)
      prev_->next_ = this;
@


1.58
log
@Low-Pri Prop-Rt.
@
text
@d15 1
d28 1
d31 2
d35 391
@


1.57
log
@Low-Pri Prop-Rt.
@
text
@a14 1
//    MeCand.
d20 1
a32 40
// Implementation of class MeCand.
//------------------------------------------------------------------------------

WitMeCand::WitMeCand (
         WitPeriod   execPer, 
         WitMeCand * theMeCand, 
         WitMeMgr *  theMeMgr):

      WitSelCand (theMeMgr->myProblem ()),

      myExecPer_ (execPer),
      prev_      (theMeCand),
      next_      (NULL),
      myMeMgr_   (theMeMgr)
   {
   if (prev_ != NULL)
      prev_->next_ = this;
   }

//------------------------------------------------------------------------------

WitMeCand::~WitMeCand ()
   {
   }

//------------------------------------------------------------------------------

void WitMeCand::prtID ()
   {
   fprintf (msgFile (), "      Exec Per:      %d\n", myExecPer_);
   }

//------------------------------------------------------------------------------

WitMeCand * WitMeCand::myMeCand ()
   {
   return this;
   }

//------------------------------------------------------------------------------
d412 40
@


1.56
log
@Low-Pri Prop-Rt.
@
text
@d315 28
a434 28
void WitMePt::print ()
   {
   FILE *        theFile;
   WitBopEntry * theBopEnt; 

   theFile   = myProblem ()->myMsgFac ().myFile ();

   theBopEnt = myMeCoordPt_->myBopEnt ();
 
   fprintf (theFile,
      "\n"
      "Multi-Exec Selection Point:\n"
      "   Operation %s, BopEntry #%d, Exp Per %d, %s\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex (),
      myMeCoordPt_->myExpPer (),
      myMeDir_->myID ());

   if (selMeCand () != NULL)
      fprintf (theFile, 
         "      Selected Exec Per: %d\n", 
         selMeCand ()->myExecPer ());
   else
      fprintf (theFile, "      Selected Exec Per: None\n");
   }

//------------------------------------------------------------------------------

@


1.55
log
@Continued implementation of proportionate routing.
@
text
@d362 7
@


1.54
log
@Continued implementation of proportionate routing.
@
text
@a382 7
WitPeriod WitMePt::myPeriod ()
   {
   return myMeCoordPt_->myExpPer ();
   }

//------------------------------------------------------------------------------

@


1.53
log
@Continued implementation of proportionate routing.
@
text
@d62 1
a62 1
   fprintf (msgFile (), "   Exec Per:    %d\n", myExecPer_);
d272 3
a274 3
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n"
      "   Exp Per:     %d\n",
d356 1
a356 1
      "   Direction:   %s\n",
@


1.52
log
@Internal changes.
@
text
@d41 1
a41 1
      WitSelCand (theMeMgr),
d83 1
a83 1
      WitProbAssoc (theMeMgr),
@


1.51
log
@Began implementation of optimizing implosion with OSL V3.
@
text
@d248 1
a248 1
   while (witTRUE)
d315 1
a315 1
WitBoolean WitMePt::hasResAlt ()
d362 1
a362 1
WitBoolean WitMePt::splittable ()
d365 1
a365 1
      return witTRUE;
d368 1
a368 1
      return witTRUE;
@


1.50
log
@More minor changes for vacpp.

The compiler complains if member functions are passed without an ampersand:

1589c1589
<          WitRun::witSetOperationYield,
---
>          &WitRun::witSetOperationYield,

It complains if "friend" declarations don't also have the word "class":
diff -r1.1 MsgFrag.h
39,40c39,40
<       friend WitMsgArg;
<       friend WitMsgFacility;
---
>       friend class WitMsgArg;
>       friend class WitMsgFacility;

It now can't figure out that a statement after a loop may not be executed!
diff -r1.70 BuildAhd.C
575a576
>    return NULL; // unreachable, but compiler complains


It also complained about missing "template<>" in many cases,
but since this seems odd, we are just suppressing the message for now
(see config/p_power64v5).  This is an example of a change that was NOT
made, but (presumably) would have to be to avoid the compiler warning.
diff -r1.47 ConsMR.C
180a181
> template<>
@
text
@d261 4
a264 1
   return NULL; // unreachable, but compiler complains
@


1.49
log
@Continued implementation of Single-Source.
@
text
@d261 1
@


1.48
log
@Continued implementation of single-source.
@
text
@d379 7
@


1.47
log
@Began implementation of object iteration.
@
text
@d311 9
a391 9
   }

//------------------------------------------------------------------------------

WitBoolean WitMePt::hasResAlt ()
   {
   witAssert (selMeCand () != NULL);

   return (myMeCoordPt_->nextMeCand (selMeCand (), myMeDir_) != NULL);
@


1.46
log
@Continued implementation of sel-split for pen-exec.
@
text
@d28 3
@


1.45
log
@Continued implementation of sel-split for pen-exec.
@
text
@d359 1
a359 4
void WitMePt::getSortData (
      WitPart * & thePart,
      int &       caseIdx,
      WitPeriod & thePer)
a361 1
   caseIdx = 1;
@


1.44
log
@Continued implementation of sel-split for pen-exec.
@
text
@a358 7
WitPart * WitMePt::myFillPart ()
   {
   return myMeCoordPt_->myBopEnt ()->myPart ();
   }

//------------------------------------------------------------------------------

@


1.43
log
@Continued implementation of sel-split for pen-exec.
@
text
@d366 4
a369 1
WitPart * WitMePt::mySortPart ()
d371 3
a373 8
   return myMeCoordPt_->myBopEnt ()->myPart ();
   }

//------------------------------------------------------------------------------

int WitMePt::caseIndex ()
   {
   return 1;
@


1.42
log
@Continued implementation of sel-split for pen-exec.
@
text
@d366 1
a366 1
WitPart * WitMePt::sortPart ()
@


1.41
log
@Initial implementation of selection splitting for multi-route.
@
text
@d310 1
a310 1
   select (myMeCoordPt_->nextMeCand (selMeCand (), myMeDir_));
d366 31
d430 7
@


1.40
log
@Continued implementation of selective stock reallocation.
@
text
@d348 6
@


1.39
log
@Continued implmentation of selective stock reallocation.
@
text
@d25 1
@


1.38
log
@Refactoring for constrained stock reallocation.
@
text
@d63 1
a63 1
WitBoolean WitMeCand::isanMeCand ()
d65 1
a65 1
   return witTRUE;
@


1.37
log
@Refactoring for constrained stock reallocation.
@
text
@d15 1
a15 1
//    MeCand
d20 1
a20 1
//    MeSelPt
d25 1
a25 1
#include <MeSelPt.h>
d109 1
a109 1
WitMeSelPt * WitNstnMeDir::myMeSelPt (WitMeCoordPt * theMeCoordPt)
d111 1
a111 1
   return theMeCoordPt->myMeSelPtForNstn ();
d133 1
a133 1
      if (theMeCand == theMeCoordPt->myMeSelPtForAsap ()->selMeCand ())
d170 1
a170 1
WitMeSelPt * WitAsapMeDir::myMeSelPt (WitMeCoordPt * theMeCoordPt)
d172 1
a172 1
   return theMeCoordPt->myMeSelPtForAsap ();
d193 1
a193 1
   if (theMeCand == theMeCoordPt->myMeSelPtForNstn ()->selMeCand ())
d216 5
a220 5
      myBopEnt_         (theBopEnt),
      firstMeCand_      (firstMeCandVal),
      lastMeCand_       (lastMeCandVal),
      myMeSelPtForNstn_ (NULL),
      myMeSelPtForAsap_ (NULL)
d222 1
a222 2
   myMeSelPtForNstn_ =
      new WitMeSelPt (this, theMeMgr->myMeDirForNstn ());
d225 1
a225 2
      myMeSelPtForAsap_ =
         new WitMeSelPt (this, theMeMgr->myMeDirForAsap ());
d232 2
a233 2
   delete myMeSelPtForNstn_;
   delete myMeSelPtForAsap_;
d263 1
a263 1
   fprintf (myMeSelPtForNstn_->myProblem ()->myMsgFac ().myFile (),
d280 1
a280 1
// Implementation of class MeSelPt.
d283 1
a283 1
inline WitProblem * WitMeSelPt::myProblem ()
d290 1
a290 1
WitMeSelPt::WitMeSelPt (WitMeCoordPt * theMeCoordPt, WitMeDir * theMeDir):
d301 1
a301 1
WitMeSelPt::~WitMeSelPt ()
d307 1
a307 1
void WitMeSelPt::alterSelection ()
d316 1
a316 1
         myMeDir_->oppMeDir ()->myMeSelPt (myMeCoordPt_)->deSelectAsNeeded ();
d321 1
a321 1
void WitMeSelPt::printSelection ()
d327 1
a327 1
WitSelMgr * WitMeSelPt::mySelMgr ()
d334 1
a334 1
void WitMeSelPt::prtID ()
d345 1
a345 1
WitBoolean WitMeSelPt::splittable ()
d352 1
a352 1
WitPart * WitMeSelPt::myFillPart ()
d359 1
a359 1
WitBoolean WitMeSelPt::hasResAlt ()
d368 1
a368 1
void WitMeSelPt::print ()
d396 1
a396 1
void WitMeSelPt::deSelectAsNeeded ()
@


1.36
log
@Refactoring for constrained stock reallocation.
@
text
@a353 14
void WitMeSelPt::adjustSplitBound (WitSelCand * theSelCand, double & splitBound)
   {
   WitPeriod execPer;

   execPer = WitMeCand::safeCast (theSelCand)->myExecPer ();

   myMeDir_->myMeMgr ()->adjustSplitBound (
      myMeCoordPt_->myBopEnt (),
      execPer,
      splitBound);
   }

//------------------------------------------------------------------------------

@


1.35
log
@Refactoring for constrained stock reallocation.
@
text
@d56 7
a308 13
WitTlObj * WitMeSelPt::selectedObj ()
   {
   WitFixedPer * theFixedPer;

   witAssert (selMeCand () != NULL);

   theFixedPer = myProblem ()->myFixedPer ()[selMeCand ()->myExecPer ()];

   return (WitTlObj *) theFixedPer;
   }

//------------------------------------------------------------------------------

d354 1
a354 1
void WitMeSelPt::adjustSplitBound (WitTlObj * theTlObj, double & splitBound)
d358 1
a358 1
   execPer = ((WitFixedPer *) theTlObj)->myPeriod ();
@


1.34
log
@Refactoring for constrained stock reallocation.
@
text
@a23 1
#include <MeCand.h>
d55 7
a288 1
      selMeCand_   (NULL),
d291 1
a291 1
   selMeCand_ = myMeDir_->initSelMeCand (myMeCoordPt_);
d306 1
a306 1
   witAssert (selMeCand_ != NULL);
d308 1
a308 1
   theFixedPer = myProblem ()->myFixedPer ()[selMeCand_->myExecPer ()];
d317 1
a317 1
   selMeCand_ = myMeCoordPt_->nextMeCand (selMeCand_, myMeDir_);
d323 1
a323 1
      if (selMeCand_ == NULL)
d383 1
a383 1
   witAssert (selMeCand_ != NULL);
d385 1
a385 1
   return (myMeCoordPt_->nextMeCand (selMeCand_, myMeDir_) != NULL);
d411 1
a411 1
         selMeCand_->myExecPer ());
d420 1
a420 1
   if (selMeCand_ == NULL)
d423 1
a423 1
   selMeCand_ = NULL;
@


1.33
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d33 4
a36 1
WitMeCand::WitMeCand (WitPeriod execPer, WitMeMgr * theMeMgr):
d41 2
d45 2
d103 1
a103 1
int WitNstnMeDir::initSelExecPer (WitMeCoordPt * theMeCoordPt)
d105 1
a105 1
   return theMeCoordPt->lastExecPer ();
d110 3
a112 3
void WitNstnMeDir::findNextExecPer (
      WitMeCoordPt * theMeCoordPt, 
      WitPeriod &    execPer)
d114 1
a114 1
   execPer --;
d116 8
a123 5
   if (execPer < theMeCoordPt->firstExecPer ())
      execPer = -1;
   else if (myGlobalComp ()->twoWayMultiExec ())
      if (execPer < theMeCoordPt->myMeSelPtForAsap ()->selExecPer ())
         execPer = -1;
d164 1
a164 1
int WitAsapMeDir::initSelExecPer (WitMeCoordPt * theMeCoordPt)
d166 1
a166 1
   return theMeCoordPt->firstExecPer ();
d171 3
a173 3
void WitAsapMeDir::findNextExecPer (
      WitMeCoordPt * theMeCoordPt, 
      WitPeriod &    execPer)
d175 1
a175 1
   WitPeriod nstnExecPer;
d177 2
a178 1
   execPer ++;
d180 2
a181 5
   if (execPer > theMeCoordPt->lastExecPer ())
      execPer = -1;
   else
      {
      nstnExecPer = theMeCoordPt->myMeSelPtForNstn ()->selExecPer ();
d183 1
a183 4
      if (nstnExecPer >= 0)
         if (execPer > nstnExecPer)
            execPer = -1;
      }
d198 4
a201 4
         WitBopEntry * theBopEnt,
         WitPeriod     firstExecPerVal,
         WitPeriod     lastExecPerVal,
         WitMeMgr *    theMeMgr):
d204 2
a205 2
      firstExecPer_     (firstExecPerVal),
       lastExecPer_     (lastExecPerVal),
d209 2
a210 1
   myMeSelPtForNstn_    = new WitMeSelPt (this, theMeMgr->myMeDirForNstn ());
d213 2
a214 1
      myMeSelPtForAsap_ = new WitMeSelPt (this, theMeMgr->myMeDirForAsap ());
d227 3
a229 3
WitBoolean WitMeCoordPt::findNextExecPer (
      WitMeDir *  theMeDir, 
      WitPeriod & execPer)
d231 2
d235 4
a238 1
      theMeDir->findNextExecPer (this, execPer);
d240 1
a240 2
      if (execPer == -1)
         return witFALSE;
d244 1
a244 1
            return witTRUE;
d265 1
a265 1
   return myBopEnt_->impactPeriod ()[firstExecPer_];
d283 1
a283 1
      selExecPer_  (-1),
d286 1
a286 1
   selExecPer_ = myMeDir_->initSelExecPer (myMeCoordPt_);
d301 1
a301 1
   witAssert (selExecPer_ >= 0);
d303 1
a303 1
   theFixedPer = myProblem ()->myFixedPer ()[selExecPer_];
d312 1
a312 1
   myMeCoordPt_->findNextExecPer (myMeDir_, selExecPer_);
d318 1
a318 1
      if (selExecPer_ == -1)
d378 1
a378 5
   WitPeriod execPer;

   witAssert (selExecPer_ >= 0);

   execPer = selExecPer_;
d380 1
a380 1
   return myMeCoordPt_->findNextExecPer (myMeDir_, execPer);
d403 4
a406 2
   if (selExecPer () >= 0)
      fprintf (theFile, "      Selected Exec Per: %d\n", selExecPer ());
d415 1
a415 1
   if (selExecPer_ == -1)
d418 1
a418 1
   selExecPer_ = -1;
@


1.32
log
@Removed indexes from production multi-route.
Other refactoring.
@
text
@d358 7
@


1.31
log
@Created class SelCand and classes derived from it.
@
text
@d15 1
a20 1
//    MeCand
d23 2
a24 1
#include <Selector.h>
d27 20
a46 2
#include <MeCand.h>
#include <MeMgr.h>
a405 19
   }

//------------------------------------------------------------------------------
// Implementation of class MeCand.
//------------------------------------------------------------------------------

WitMeCand::WitMeCand (WitPeriod execPer, WitMeMgr * theMeMgr):

      WitSelCand (theMeMgr),

      myExecPer_ (execPer),
      myMeMgr_   (theMeMgr)
   {
   }

//------------------------------------------------------------------------------

WitMeCand::~WitMeCand ()
   {
@


1.30
log
@Fixed bug in two-way multi-exec:
   NSTN and ASAP multi-exec collisions were not being adequately detected.
@
text
@d20 1
d26 1
d387 19
@


1.29
log
@Refactoring of Multi-Exec: Removed alt-indices.
@
text
@d37 4
a40 1
WitMeDir::WitMeDir ()
d48 2
a49 2
WitNstnMeDir::WitNstnMeDir ():
      WitMeDir ()
d61 7
d90 3
d106 2
a107 2
WitAsapMeDir::WitAsapMeDir ():
      WitMeDir ()
d119 7
d144 2
d150 8
a176 1
      myMeMgr_          (theMeMgr),
d185 1
a185 1
   if (myMeMgr_->myGlobalComp ()->twoWayMultiExec ())
a217 30
void WitMeCoordPt::deSelectAsNeeded ()
   {
   if (! myMeMgr_->myGlobalComp ()->twoWayMultiExec ())
      return;

   WitMeSelPt * nstnMeSelPt;
   WitMeSelPt * asapMeSelPt;

   nstnMeSelPt = myMeSelPtForNstn_;
   asapMeSelPt = myMeSelPtForAsap_;

   witAssert (
         nstnMeSelPt->selExecPer () >= 0
      || asapMeSelPt->selExecPer () >= 0);

   if (nstnMeSelPt->selExecPer () == -1)
      asapMeSelPt->deSelect ();

   else if (asapMeSelPt->selExecPer () == -1)
      nstnMeSelPt->deSelect ();

   else if (asapMeSelPt->selExecPer () > nstnMeSelPt->selExecPer ())
      {
      nstnMeSelPt->deSelect ();
      asapMeSelPt->deSelect ();
      }
   }

//------------------------------------------------------------------------------

d220 1
a220 1
   fprintf (myMeMgr_->msgFile (),
d242 1
a242 1
   return myMeCoordPt_->myMeMgr ()->myProblem ();
d285 3
a287 1
   myMeCoordPt_->deSelectAsNeeded ();
d298 1
a298 1
WitSelMgr * WitMeSelPt::mySelMgr (WitSelector * theSelector)
d300 1
a300 1
   return theSelector->myMeMgr ();
d329 1
a329 1
   myMeCoordPt_->myMeMgr ()->adjustSplitBound (
a349 10
void WitMeSelPt::deSelect ()
   {
   selExecPer_ = -1;

   if (myProblem ()->myGlobalComp ()->selPrintLevel () >= 2)
      print ();
   }

//------------------------------------------------------------------------------

d372 13
@


1.28
log
@Refactoring.
@
text
@d65 1
a65 1
int WitNstnMeDir::initSelAltIdx (WitMeCoordPt * theMeCoordPt)
d67 1
a67 1
   return theMeCoordPt->nExecPers () - 1;
d72 3
a74 1
WitBoolean WitNstnMeDir::findNextAltIdx (WitMeCoordPt *, int & theIdx) 
d76 1
a76 1
   theIdx --;
d78 2
a79 1
   return (theIdx >= 0);
d113 1
a113 1
int WitAsapMeDir::initSelAltIdx (WitMeCoordPt *)
d115 1
a115 1
   return 0;
d120 1
a120 1
WitBoolean WitAsapMeDir::findNextAltIdx (
d122 1
a122 1
      int &          theIdx) 
d124 1
a124 1
   theIdx ++;
d126 2
a127 1
   return (theIdx < theMeCoordPt->nExecPers ());
d142 4
a145 4
         WitBopEntry *                 theBopEnt,
         int                           nExecPersVal, 
         const WitVector (WitPeriod) & execPerByIdx,
         WitMeMgr *                    theMeMgr):
d147 1
d149 2
a150 2
      myMeMgr_          (theMeMgr),
      indexedExecPer_   (nExecPersVal, -1),
d154 1
a154 3
   int theIdx;

   witAssert (nExecPers () > 1);
d156 1
a156 6
   for (theIdx = 0; theIdx < nExecPers (); theIdx ++)
      indexedExecPer_[theIdx] = execPerByIdx[theIdx];

   myMeSelPtForNstn_ = new WitMeSelPt (this, theMeMgr->myMeDirForNstn ());

   if (theMeMgr->myGlobalComp ()->twoWayMultiExec ())
d171 1
a171 2
      WitMeDir *  theMeDir,
      int &       theIdx, 
d174 3
a176 1
   WitBoolean foundAltIdx;
d178 2
a179 1
   foundAltIdx = theMeDir->findNextAltIdx (this, theIdx);
d181 4
a184 4
   if (foundAltIdx)
      execPer = indexedExecPer_[theIdx];

   return foundAltIdx;
d200 3
a202 1
   witAssert (nstnMeSelPt->hasSelExecPer () || asapMeSelPt->hasSelExecPer ());
d204 1
a204 1
   if (! nstnMeSelPt->hasSelExecPer ())
d207 1
a207 1
   else if (! asapMeSelPt->hasSelExecPer ())
d227 1
a227 1
      myBopEnt_->impactPeriod ()[indexedExecPer_[0]]);
d234 1
a234 1
   return myBopEnt_->impactPeriod ()[indexedExecPer_[0]];
d247 1
d252 1
a252 1
      selAltIdx_   (theMeDir->initSelAltIdx (theMeCoordPt)),
d255 1
a267 1
   WitPeriod     execPer;
d270 1
a270 1
   witAssert (selAltIdx_ >= 0);
d272 1
a272 3
   execPer     = myMeCoordPt_->indexedExecPer ()[selAltIdx_];

   theFixedPer = myProblem ()->myFixedPer ()[execPer];
d281 1
a281 7
   WitPeriod  execPer;
   WitBoolean foundOK;

   foundOK = myMeCoordPt_->findNextExecPer (myMeDir_, selAltIdx_, execPer);

   if (! foundOK)
      selAltIdx_ = -1;
a337 1
   int       theIdx;
d340 1
a340 1
   witAssert (selAltIdx_ >= 0);
d342 1
a342 1
   theIdx = selAltIdx_;
d344 1
a344 1
   return myMeCoordPt_->findNextExecPer (myMeDir_, theIdx, execPer);
d351 1
a351 1
   selAltIdx_ = -1;
d377 1
a377 1
   if (hasSelExecPer ())
@


1.27
log
@Continued development of selection splitting for multi=exec.
@
text
@d230 1
a230 1
WitPeriod WitMeCoordPt::expPeriod ()
d380 1
a380 1
      myMeCoordPt_->expPeriod (),
@


1.26
log
@Added meSelSplitOK development parameter.
Added meSelSplit attribute.
Refactoring for sel-split for multi-exec.
@
text
@d31 1
a31 2
WitMeDir::WitMeDir (const char * theName):
      myName_ (theName)
d37 1
a37 1
WitMeDir::~WitMeDir ()
d46 1
a46 1
      WitMeDir ("NSTN")
d80 7
d91 1
a91 1
      WitMeDir ("ASAP")
d127 7
d143 1
a143 1
      myBopEntry_       (theBopEnt),
d217 13
d232 1
a232 1
   return myBopEntry_->impactPeriod ()[indexedExecPer_[0]];
d309 11
d322 1
a322 1
   return witFALSE;
d334 1
a334 1
      myMeCoordPt_->myBopEntry (),
a340 34
void WitMeSelPt::prtSplitting (double)
   {
   WitMsgFacility::current () ("internalErrorFmsg", "WitMeSelPt::prtSplitting");
   }

//------------------------------------------------------------------------------

void WitMeSelPt::prtSplitExp (WitTlObj * splitObj)
   {
   WitBopEntry * theBopEnt;
   WitFixedPer * theFixedPer;
   WitPeriod     execPer;

   theBopEnt   = myMeCoordPt_->myBopEntry ();

   theFixedPer = (WitFixedPer *) splitObj;

   execPer     = theFixedPer->myPeriod ();

   fprintf (myProblem ()->myMsgFac ().myFile (),
      "\n"
      "Split Selection for Multiple Execution Periods:\n"
      "   Operation:   %s\n"
      "   BOP Entry #: %d\n"
      "   Exp Per:     %d\n"
      "   Exec Per:    %d\n",
      theBopEnt->myOperationName ().myCstring (),
      theBopEnt->localIndex (),
      theBopEnt->impactPeriod ()[execPer],
      execPer);
   }

//------------------------------------------------------------------------------

d372 1
a372 1
   theBopEnt = myMeCoordPt_->myBopEntry ();
d381 1
a381 1
      myMeDir_->myName ());
@


1.25
log
@Various refactorings for sel-split for multi-exec.
@
text
@d290 14
@


1.24
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d236 1
a236 1
WitTlObj * WitMeSelPt::selection ()
d293 27
@


1.23
log
@Renamed AltPt classes to SelPt classes.
@
text
@d125 1
a125 1
         WitBopEntry *                 theBopEntry,
d130 1
a130 1
      myBopEntry_       (theBopEntry),
d213 6
d236 16
d262 1
a262 1
   if (myMeCoordPt_->myMeMgr ()->myGlobalComp ()->selPrintLevel () >= 2)
d270 1
a270 1
void WitMeSelPt::splitSelection (double)
a271 1
   WitMsgFacility::current () ("internalErrorFmsg", "MeSelPt::splitSelection");
d276 1
a276 1
void WitMeSelPt::printSelection ()
d278 1
d283 1
a283 1
WitSelMgr * WitMeSelPt::mySelMgr (WitSelector * theSelector)
d285 1
a285 1
   return theSelector->myMeMgr ();
d290 1
a290 1
WitBoolean WitMeSelPt::splittable ()
d292 1
a292 1
   return witFALSE;
d315 1
a315 1
   if (myMeCoordPt_->myMeMgr ()->myGlobalComp ()->selPrintLevel () >= 2)
d326 2
a327 1
   theFile   = myMeCoordPt_->myMeMgr ()->msgFile ();
@


1.22
log
@Removed class MePrinter.
@
text
@d19 1
a19 1
//    MeAltPt
d24 1
a24 1
#include <MeAltPt.h>
d59 1
a59 1
WitMeAltPt * WitNstnMeDir::myMeAltPt (WitMeCoordPt * theMeCoordPt)
d61 1
a61 1
   return theMeCoordPt->myMeAltPtForNstn ();
d97 1
a97 1
WitMeAltPt * WitAsapMeDir::myMeAltPt (WitMeCoordPt * theMeCoordPt)
d99 1
a99 1
   return theMeCoordPt->myMeAltPtForAsap ();
d133 2
a134 2
      myMeAltPtForNstn_ (NULL),
      myMeAltPtForAsap_ (NULL)
d143 1
a143 1
   myMeAltPtForNstn_ = new WitMeAltPt (this, theMeMgr->myMeDirForNstn ());
d146 1
a146 1
      myMeAltPtForAsap_ = new WitMeAltPt (this, theMeMgr->myMeDirForAsap ());
d153 2
a154 2
   delete myMeAltPtForNstn_;
   delete myMeAltPtForAsap_;
d181 2
a182 2
   WitMeAltPt * nstnMeAltPt;
   WitMeAltPt * asapMeAltPt;
d184 2
a185 2
   nstnMeAltPt = myMeAltPtForNstn_;
   asapMeAltPt = myMeAltPtForAsap_;
d187 1
a187 1
   witAssert (nstnMeAltPt->hasSelExecPer () || asapMeAltPt->hasSelExecPer ());
d189 2
a190 2
   if (! nstnMeAltPt->hasSelExecPer ())
      asapMeAltPt->deSelect ();
d192 2
a193 2
   else if (! asapMeAltPt->hasSelExecPer ())
      nstnMeAltPt->deSelect ();
d195 1
a195 1
   else if (asapMeAltPt->selExecPer () > nstnMeAltPt->selExecPer ())
d197 2
a198 2
      nstnMeAltPt->deSelect ();
      asapMeAltPt->deSelect ();
d210 1
a210 1
// Implementation of class MeAltPt.
d213 2
a214 1
WitMeAltPt::WitMeAltPt (WitMeCoordPt * theMeCoordPt, WitMeDir * theMeDir):
d224 1
a224 1
WitMeAltPt::~WitMeAltPt ()
d230 1
a230 1
void WitMeAltPt::alterSelection ()
d248 1
a248 1
void WitMeAltPt::splitSelection (double)
d250 1
a250 1
   WitMsgFacility::current () ("internalErrorFmsg", "MeAltPt::splitSelection");
d255 1
a255 1
void WitMeAltPt::printSelection ()
d261 1
a261 1
WitSelMgr * WitMeAltPt::mySelMgr (WitSelector * theSelector)
d268 1
a268 1
WitBoolean WitMeAltPt::splittable ()
d275 1
a275 1
WitBoolean WitMeAltPt::hasResAlt ()
d289 1
a289 1
void WitMeAltPt::deSelect ()
d299 1
a299 1
void WitMeAltPt::print ()
d309 1
a309 1
      "Multi-Exec Alteration Point:\n"
@


1.21
log
@Removed class MeAltPt.
Changed name of class MeSelPt to MeAltPt.
Implemented de-selection of colliding MeAltPts.
@
text
@a25 1
#include <MePtr.h>
d240 1
a240 1
      myMeCoordPt_->myMeMgr ()->myMePrinter ()->print (this);
d293 26
a318 1
      myMeCoordPt_->myMeMgr ()->myMePrinter ()->print (this);
@


1.20
log
@Fixed a bug on multi-exec.
@
text
@d19 1
a19 2
//    MeSelPt
//    MeAltPt.
a23 1
#include <MeSelPt.h>
d60 1
a60 1
WitMeSelPt * WitNstnMeDir::myMeSelPt (WitMeCoordPt * theMeCoordPt)
d62 1
a62 1
   return theMeCoordPt->myMeSelPtForNstn ();
d98 1
a98 1
WitMeSelPt * WitAsapMeDir::myMeSelPt (WitMeCoordPt * theMeCoordPt)
d100 1
a100 1
   return theMeCoordPt->myMeSelPtForAsap ();
d133 3
a135 3
      myMeAltPt_        (nExecPersVal),
      myMeSelPtForNstn_ (NULL),
      myMeSelPtForAsap_ (NULL)
d142 1
a142 1
      myMeAltPt_[theIdx] = theMeMgr->curMeAltPt ()[execPerByIdx[theIdx]];
d144 1
a144 1
   myMeSelPtForNstn_ = new WitMeSelPt (this, theMeMgr->myMeDirForNstn ());
d147 1
a147 1
      myMeSelPtForAsap_ = new WitMeSelPt (this, theMeMgr->myMeDirForAsap ());
d154 2
a155 2
   delete myMeSelPtForNstn_;
   delete myMeSelPtForAsap_;
d160 4
a163 4
WitBoolean WitMeCoordPt::findNextMeAltPt (
      WitMeDir *     theMeDir,
      int &          theIdx, 
      WitMeAltPt * & theMeAltPt)
d170 1
a170 1
      theMeAltPt = myMeAltPt_[theIdx];
d177 1
a177 1
WitPeriod WitMeCoordPt::expPeriod ()
d179 5
a183 1
   WitPeriod execPer;
d185 2
a186 1
   execPer = myMeAltPt_[0]->execPeriod ();
d188 1
a188 2
   return myBopEntry_->impactPeriod ()[execPer];
   }
d190 2
a191 3
//------------------------------------------------------------------------------
// Implementation of class MeSelPt.
//------------------------------------------------------------------------------
d193 2
a194 1
WitMeSelPt::WitMeSelPt (WitMeCoordPt * theMeCoordPt, WitMeDir * theMeDir):
d196 5
a200 5
      myMeCoordPt_ (theMeCoordPt),
      selAltIdx_   (theMeDir->initSelAltIdx (theMeCoordPt)),
      myMeDir_     (theMeDir)
   {
   selMeAltPt ()->beChosenBy (this);
d205 1
a205 1
WitMeSelPt::~WitMeSelPt ()
d207 1
d211 2
d214 1
a214 3
void WitMeSelPt::alterSelection ()
   {
   WitMeAltPt * theMeAltPt;
d216 3
a218 10
   theMeAltPt = selMeAltPt ();

   witAssert (theMeAltPt != NULL);

   myMeCoordPt_->myMeMgr ()->preReject (theMeAltPt);
   }

//------------------------------------------------------------------------------

void WitMeSelPt::splitSelection (double)
a219 1
   WitMsgFacility::current () ("internalErrorFmsg", "MeSelPt::splitSelection");
d224 1
a224 1
void WitMeSelPt::printSelection ()
d230 1
a230 1
WitSelMgr * WitMeSelPt::mySelMgr (WitSelector * theSelector)
d232 2
a233 2
   return theSelector->myMeMgr ();
   }
d235 1
a235 1
//------------------------------------------------------------------------------
d237 2
a238 4
WitBoolean WitMeSelPt::splittable ()
   {
   return witFALSE;
   }
d240 2
a241 1
//------------------------------------------------------------------------------
d243 1
a243 5
WitBoolean WitMeSelPt::hasResAlt ()
   {
   int theIdx;

   return findNextUseableMAP (theIdx);
d248 1
a248 1
void WitMeSelPt::finishAlteration ()
d250 1
a250 4
   if (findNextUseableMAP (selAltIdx_))
      selMeAltPt ()->beChosenBy (this);
   else
      selAltIdx_ = -1;
d255 1
a255 1
WitBoolean WitMeSelPt::findNextUseableMAP (int & theIdx)
a256 11
   WitMeAltPt * theMeAltPt;

   witAssert (selAltIdx_ >= 0);

   theIdx = selAltIdx_;

   while (myMeCoordPt_->findNextMeAltPt (myMeDir_, theIdx, theMeAltPt))
      if (theMeAltPt->useable ())
         return witTRUE;

   return witFALSE;
a259 4
// Implementation of class MeAltPt.
//------------------------------------------------------------------------------

WitMeAltPt::WitMeAltPt (WitPeriod execPer, WitProblem * theProblem):
d261 1
a261 3
      useable_    (witTRUE),
      execPeriod_ (execPer),
      choosers_   (theProblem)
d263 1
d268 1
a268 1
WitMeAltPt::~WitMeAltPt ()
d270 1
d275 1
a275 1
void WitMeAltPt::reject ()
d277 2
a278 1
   WitMeSelPt * theMeSelPt;
d280 1
a280 2
   if (! useable_)
      return;
d282 1
a282 7
   useable_ = witFALSE;

   witAssert (! choosers_.isEmpty ());

   while (choosers_.pop (theMeSelPt))
      theMeSelPt->finishAlteration ();
   }
d284 1
a284 9
//------------------------------------------------------------------------------

void WitMeAltPt::beChosenBy (WitMeSelPt * theMeSelPt)
   {
   witAssert (useable ());

   witAssert (theMeSelPt->selMeAltPt () == this);

   choosers_.push (theMeSelPt);
d289 1
a289 1
WitBoolean WitMeAltPt::hasaPendingChooser ()
d291 1
a291 4
   WitObjStItr (WitMeSelPt) theItr;
   WitMeSelPt *             theMeSelPt;

   theItr.attachTo (choosers_);
d293 2
a294 5
   while (theItr.advance (theMeSelPt))
      if (theMeSelPt->pending ())
         return witTRUE;

   return witFALSE;
@


1.19
log
@Fixed uninitialized memory bugs.
Refactoring for selection splitting.
@
text
@d211 3
a213 1
   witAssert (selMeAltPt () != NULL);
d215 3
a217 1
   selMeAltPt ()->alterSelection ();
d258 1
a258 1
void WitMeSelPt::alterSelectionOld ()
d303 1
a303 1
void WitMeAltPt::alterSelection ()
d307 3
d315 1
a315 1
      theMeSelPt->alterSelectionOld ();
@


1.18
log
@Continuing development of selection splitting.
@
text
@d209 36
d254 1
a254 1
void WitMeSelPt::alterSelection ()
a263 7
void WitMeAltPt::splitSelection (double)
   {
   WitMsgFacility::current () ("internalErrorFmsg", "MeAltPt::splitSelection");
   }

//------------------------------------------------------------------------------

a284 2
      WitAltPt    (),

d308 1
a308 1
      theMeSelPt->alterSelection ();
d313 1
a313 1
void WitMeAltPt::printSelection ()
d315 1
a315 2
   WitSelector::altPrtInst ()->myMeMgr ()->myMePrinter ()->print (this);
   }
d317 1
a317 1
//------------------------------------------------------------------------------
d319 1
a319 3
WitSelMgr * WitMeAltPt::mySelMgr (WitSelector * theSelector)
   {
   return theSelector->myMeMgr ();
d324 1
a324 1
WitBoolean WitMeAltPt::splittable ()
d326 2
a327 2
   return witFALSE;
   }
d329 1
a329 1
//------------------------------------------------------------------------------
d331 3
a333 3
void WitMeAltPt::beChosenBy (WitMeSelPt * theMeSelPt)
   {
   witAssert (useable ());
d335 1
a335 3
   witAssert (theMeSelPt->selMeAltPt () == this);

   choosers_.push (theMeSelPt);
@


1.17
log
@Re-worked the controls for selection splitting.
@
text
@d300 7
@


1.16
log
@Continued implementation of selection splitting.
@
text
@a299 7
float WitMeAltPt::splitRes ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

@


1.15
log
@Continued implementation of selection splitting with the new design.
@
text
@d293 7
@


1.14
log
@Continued implementation of selection splitting with the new design.
@
text
@d286 1
a286 1
void WitMeAltPt::printSelection (WitSelector * theSelector)
d288 1
a288 1
   theSelector->myMeMgr ()->myMePrinter ()->print (this);
@


1.13
log
@Added the attribute ID to the error msg for calling an API function for a
   material part attribute and giving it a capacity part.
Began implementation of the new selection splitting design.
@
text
@d228 7
@


1.12
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d286 7
@


1.11
log
@Continued development of coarse selection splitting.
@
text
@a161 7
void WitMeCoordPt::splitSel (WitPeriod execPer)
   {
   myMeMgr_->splitSel (myBopEntry_, execPer);
   }

//------------------------------------------------------------------------------

a217 7
void WitMeSelPt::splitSel (WitPeriod execPer)
   {
   myMeCoordPt_->splitSel (execPer);
   }

//------------------------------------------------------------------------------

a266 1
   WitBoolean   selSplit;
a268 2
   selSplit = choosers_.myProblem ()->myGlobalComp ()->selSplit ();

a273 4
      {
      if (selSplit)
         theMeSelPt->splitSel (execPeriod_);

a274 1
      }
@


1.10
log
@Further implementation of coarse selection splitting.
@
text
@a23 1
#include <MeMgr.h>
d27 2
d303 1
a303 1
   theSelector->print (this);
@


1.9
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d184 11
@


1.8
log
@Implemented and used class SelMgr.
@
text
@d127 4
a130 3
      int                           nExecPersVal, 
      const WitVector (WitPeriod) & execPerByIdx,
      WitMeMgr *                    theMeMgr):
d132 2
d161 7
d213 7
d269 1
d272 2
d279 4
d284 1
@


1.7
log
@Fixed some bugs in coarse selection splitting.
@
text
@a278 4

//------------------------------------------------------------------------------

implementClearContents (WitMeAltPt)
@


1.6
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d258 1
a258 1
   while (choosers_.get (theMeSelPt))
d277 1
a277 1
   choosers_.put (theMeSelPt);
@


1.5
log
@Refactoring for selection splitting.
@
text
@d258 1
a258 1
   while (choosers_.pop (theMeSelPt))
d277 1
a277 1
   choosers_.push (theMeSelPt);
@


1.4
log
@Outer API: Merged all no-longer-documented functions into one section.
Outer API: Moved build-ahead by demand functions into the no-longer-documented
   section.
Simplified the rules for two-way multiple execution periods.
@
text
@d131 1
a131 1
      myMeAltPtTl_      (nExecPersVal, NULL),
d140 1
a140 1
      myMeAltPtForUpdate (theIdx) = theMeMgr->curMeAltPt (execPerByIdx[theIdx]);
d168 1
a168 1
      theMeAltPt = myMeAltPt (theIdx);
@


1.3
log
@Initial implementation of stock re-allocation.
@
text
@a14 1
//    MeDirMgr.
a24 1
#include <MeDirMgr.h>
a29 176
// Implementation of class MeDirMgr.
//------------------------------------------------------------------------------

WitMeDirMgr::WitMeDirMgr (WitProblem * theProblem):
      WitProbAssoc    (theProblem),

      jitExtMeDir_    (NULL),
      baExtMeDir_     (NULL),
      extPart_        (NULL),
      incPer_         (-1),
      curMeDirTl_     (),
      dirPartPers_    (myProblem ()),
      myMeDirForNstn_ (NULL),
      myMeDirForAsap_ (NULL)
   {
   myMeDirForNstn_ = new WitNstnMeDir;
   myMeDirForAsap_ = new WitAsapMeDir;

   if (myGlobalComp ()->twoWayMultiExec ())
      curMeDirTl_.allocate (myProblem (), NULL);
   }

//------------------------------------------------------------------------------

WitMeDirMgr::~WitMeDirMgr ()
   {
   delete myMeDirForAsap_;
   delete myMeDirForNstn_;
   }

//------------------------------------------------------------------------------

void WitMeDirMgr::preInc (
      WitBoolean asapMultiExec, 
      WitBoolean prefBA,
      WitPart *  thePart,
      WitPeriod  thePer)
   {
   jitExtMeDir_ = myMeDirByBool (asapMultiExec);
   baExtMeDir_  = myMeDirByBool (prefBA);
   extPart_     = thePart;
   incPer_      = thePer;
   }

//------------------------------------------------------------------------------

WitMeDir * WitMeDirMgr::chooseMeDir (
      WitBopEntry * theBopEnt,
      WitPeriod     prodPer,
      WitPeriod     fillPer)
   {
   WitPart *     thePart;
   WitMeDir *    theMeDir;
   WitMaterial * theMat;

   witAssert (prodPer <= fillPer);

   if (! myGlobalComp ()->twoWayMultiExec ())
      return myMeDirForNstn_;

   thePart = theBopEnt->myPart ();

   if (prodPer == thePart->explosionPeriod (fillPer))
      {
      theMeDir = curMeDir (thePart, fillPer);

      return 
         (theMeDir != NULL)?
            theMeDir:
            myMeDirForNstn_;
      }

   if (DEBUG_MODE)
      witAssert (thePart->isaMaterial (theMat));
   else
      thePart->isaMaterial (theMat);

   if (theMat->nstnBaNeeded ())
      return myMeDirForNstn_;

   witAssert (theMat->buildAsap ());

   return myMeDirForAsap_;
   }

//------------------------------------------------------------------------------

void WitMeDirMgr::resetCurMeDirs (WitPeriod thePer)
   {
   WitPart *  fillPart;
   WitPeriod  fillPer;
   WitMeDir * theMeDir;

   while (dirPartPers_.pop (fillPart, fillPer))
      curMeDirForUpdate (fillPart, fillPer) = NULL;

   witAssert (curMeDirIsClear ());

   theMeDir = 
      (thePer < incPer_)?
         baExtMeDir_:
         jitExtMeDir_;

   setCurMeDir (extPart_, thePer, theMeDir);
   }

//------------------------------------------------------------------------------

void WitMeDirMgr::placeReqs (
      WitBopEntry * theBopEnt,
      WitPeriod     execPer,
      WitPeriod     fillPer,
      WitPart *     consPart,
      WitPeriod     consPer)
   {
   WitPeriod  prodPer;
   WitMeDir * theMeDir;

   if (curMeDir (consPart, consPer) == myMeDirForNstn_)
      return;

   prodPer  = theBopEnt->impactPeriod ()[execPer];

   theMeDir = chooseMeDir (theBopEnt, prodPer, fillPer);

   setCurMeDir (consPart, consPer, theMeDir);
   }

//------------------------------------------------------------------------------

void WitMeDirMgr::setCurMeDir (
      WitPart *  thePart, 
      WitPeriod  fillPer, 
      WitMeDir * theMeDir)
   {
   witAssert (isMine (theMeDir));

   if (curMeDir (thePart, fillPer) == NULL)
      dirPartPers_.push (thePart, fillPer);

   curMeDirForUpdate (thePart, fillPer) = theMeDir;
   }

//------------------------------------------------------------------------------

WitMeDir * WitMeDirMgr::myMeDirByBool (WitBoolean forAsapMe)
   {
   return
      forAsapMe?
         myMeDirForAsap_:
         myMeDirForNstn_;
   }

//------------------------------------------------------------------------------

WitBoolean WitMeDirMgr::isMine (WitMeDir * theMeDir)
   {
   return 
         (theMeDir == myMeDirForNstn_)
      || (theMeDir == myMeDirForAsap_);
   }

//------------------------------------------------------------------------------

WitBoolean WitMeDirMgr::curMeDirIsClear ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      if (! (curMeDirTl_ (thePart) == (WitTypelessPtr) NULL))
         return witFALSE;

   return witTRUE;
   }

//------------------------------------------------------------------------------
d142 1
a142 2
   myMeSelPtForNstn_ = 
      new WitMeSelPt (this, theMeMgr->myMeDirMgr ()->myMeDirForNstn ());
d145 1
a145 2
      myMeSelPtForAsap_ = 
         new WitMeSelPt (this, theMeMgr->myMeDirMgr ()->myMeDirForAsap ());
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d84 1
d94 3
a96 1
   witAssert (curMeDir (thePart, fillPer) != NULL);
d98 5
a102 2
   if (prodPer == thePart->explosionPeriod (fillPer))
      return curMeDir (thePart, fillPer);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

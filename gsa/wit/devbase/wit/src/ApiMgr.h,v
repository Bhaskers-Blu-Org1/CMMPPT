head	1.94;
access;
symbols
	sce_5_01_20080919:1.89
	latest_sce_4_20_20060523:1.80.0.2
	sce_4_20_20060523:1.80
	latest_sce4_20_OSL:1.79.0.2
	sce_4_20_OSL:1.79
	sce_410_withVa:1.53
	sce_4_05_20040511:1.22
	sce_4_00_20040201:1.15
	nextGenBranch:1.12.0.2
	nextGenRoot:1.12
	sce_3_30_20030627:1.11
	EndRw-branch:1.10.0.4
	Root-of-EndRw:1.10
	rwToStl:1.10.0.2
	latest_sce_3_10_20010924:1.6.0.2
	sce_3_10_20010924:1.6
	latest_sce_3_00_20010601:1.5.0.4
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.94
date	2011.09.28.23.49.01;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2011.09.24.00.27.18;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2011.08.30.20.17.15;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2009.10.08.16.06.02;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2009.10.07.22.08.37;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.01.12.20.00.37;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.01.11.22.53.25;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.01.11.18.38.31;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2006.11.02.23.07.13;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2006.10.05.18.19.15;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2006.08.29.17.37.54;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2006.08.24.20.50.27;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2006.08.24.17.50.52;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2006.08.22.21.26.54;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2006.05.02.17.33.54;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.11.04.20.42.54;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2005.11.01.21.58.10;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2005.10.24.22.37.49;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2005.10.21.22.23.34;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2005.10.21.15.37.51;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2005.10.19.20.53.07;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2005.10.17.22.07.39;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2005.10.17.21.24.02;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2005.10.17.15.02.06;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2005.10.10.14.59.57;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.10.07.20.01.22;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.10.07.17.14.21;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.10.07.15.21.44;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2005.10.06.15.47.34;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2005.09.27.19.54.37;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2005.09.20.21.47.57;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2005.09.20.21.15.11;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2005.09.16.15.38.42;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.16.14.58.48;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2005.09.15.19.47.10;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2005.09.15.18.11.23;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2005.09.15.16.10.42;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2005.09.15.15.27.21;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.09.14.22.44.10;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.14.21.54.45;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.09.12.22.17.33;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.09.06.20.43.26;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.09.06.19.47.58;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.09.06.17.51.31;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.06.17.33.36;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.02.14.14.42;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.09.01.21.45.03;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.31.22.11.00;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.31.19.00.36;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.08.29.21.44.42;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.08.29.20.29.48;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.08.29.19.14.35;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.08.25.21.47.39;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.25.17.50.32;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.08.24.19.26.42;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.23.17.38.58;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.22.20.38.59;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.19.23.24.11;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.19.21.38.02;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.12.19.35.29;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.13.21.18.46;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.11.22.53.49;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.08.21.02.12;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.08.20.48.19;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.08.15.59.42;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.06.22.21.30;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.05.22.40.32;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.05.22.04.25;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.05.20.07.19;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.03.21.25.12;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.13.19.21.34;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.12.18.19.21;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.19.22.16.27;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.09.19.37.57;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.25.20.35.02;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.12.15.09.23;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.19.16.31.24;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.17.20.23.47;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.14.00.45.34;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.08.19.27.44;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.02.16.39.32;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.01.21.05.03;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.09.19.57.43;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.02.22.18.17;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.09.20.49.47;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.09.19.52.30;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.03.23.16.35;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.24.18.26.04;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.01.19.23.31;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.22.23.11.36;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.12.29;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.18;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.17;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.18;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.18;	author wit;	state Exp;
branches;
next	;


desc
@@


1.94
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef ApiMgrH
#define ApiMgrH

#include <TVec.h>
#include <wit.h>

//------------------------------------------------------------------------------
// Header file: "ApiMgr.h"
//
// Contains the declaration of class ApiMgr.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// class ApiMgr
// Responsible for handling the entry into and the return from wit API
// functions.
//------------------------------------------------------------------------------

class WitApiMgr
   {
   public:

      //------------------------------------------------------------------------
      // Public member data.
      //------------------------------------------------------------------------

      WitApiMgr (WitRun * theWitRun);
         //
         // myWitRun_ <-- theWitRun.

      //------------------------------------------------------------------------
      // Destructor functions.
      //------------------------------------------------------------------------

      ~WitApiMgr ();

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitRun *,      myWitRun)
      accessFunc (WitSession *,  mySession)
      accessFunc (WitInputID *,  myInputID)
      accessFunc (const char *,  apiFuncName)
      accessFunc (WitReturnCode, apiRc)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static void startApiFunc (WitRun * theWitRun, const char * theFuncName);
         //
         // This function is called from the CALL_INNER_API macro
         // just prior to calling the inner API function on theWitRun.
         //
         // theFuncName: Name of the outer API function.

      void finishApiFunc ();
         //
         // This function is called from the CALL_INNER_API macro
         // just after calling the inner API function on theWitRun.

      void handleAnyExc ();
         //
         // Handles all exceptions.

      void lockMyWitRun (const char * theFuncName);
         //
         // Puts myWitRun_ into a "locked" state: No further API functions calls
         // to myWitRun_ are allowed, other than the current one.
         // theFuncName is the name of the currently called API function.

      void unlockMyWitRun ();
         //
         // Puts myWitRun_ into an "unlocked" state: Further API functions calls
         // to myWitRun_ are now allowed.

      void skipCallMsg ();
         //
         // Tells this ApiMgr not to issue the API function call Msg for the
         // current API function.

      void allowPreInit ();
         //
         // Tells this ApiMgr to allow the API current function to be called
         // when witInitialize and witCopyData have not yet been called.

      void allowExtOptActive ();
         //
         // Tells this ApiMgr to allow the API current function to be called
         // when external optimizing implosion is active.

      void startInnerFunc ();
         //
         // Takes action appropriate at the beginning of a call to an inner API
         // function.

      void start2WitRunFunc (WitApiMgr * theApiMgr2);
         //
         // Takes action as needed at the beginning of a call to an API
         // function with two WitRun arguments.
         // theApiMgr2 is the ApiMgr for the second WitRun.

      void updateApiRc (WitReturnCode theRc);
         //
         // Sets apiRc_ to theRc, if theRc is greater.

      void resetInputID ();
         //
         // Deletes myInputID () and creates a new one.

      WitTVec <WitBoolean> & reserveTempBooleanVec ();
         //
         // Same as reserveTempDblVec, but for WitBoolean.

      WitTVec <int> & reserveTempIntVec ();
         //
         // Same as reserveTempDblVec, but for int.

      WitTVec <double> & reserveTempDblVec ();
         //
         // Asserts that the temp vectors are not currently reserved,
         // reserves them, makes tempDblVec the right size, and returns it.

      void releaseTempVecs ();
         //
         // Asserts that the temp vectors are in use, then indicates that they
         // are not.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitApiMgr);

      static void setUpNewFailure ();
         //
         // Sets up WIT's response to a failure of the "new" operator,
         // if necessary.

      static int throwBadAlloc (size_t);
         //
         // Throws a std::bad_alloc exception.
         // (The argument is ignored.)

      void handleIssueMsgExc (WitIssueMsgExc & theIssueMsgExc);
         //
         // Handles theIssueMsgExc.

      void handleAbortApiExc (WitAbortApiExc & theAbortApiExc);
         //
         // Handles theAbortApiExc.

      void abortApiFunc (
            WitAbortApiExc &  theAbortApiExc,
            const WitString & theFuncName);
         //
         // Aborts the currently running API function in the manner indicated by
         // theAbortApiExc.
         // theFuncName is the name of the API function.

      inline WitMsgFacility & myMsgFac ();

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      static bool newHandlerSet_;
         //
         // True, iff the "new handler" has been set to throwBadAlloc.

      WitRun * const myWitRun_;
         //
         // The WitRun that owns this ApiMgr.

      WitSession * mySession_;
         //
         // The Session owned by this ApiMgr.

      WitInputID * myInputID_;
         //
         // The InputID owned by this ApiMgr.

      bool myWitRunIsLocked_;
         //
         // True, iff a call to an API function for myWitRun_ is currently in
         // progress.

      const char * apiFuncName_;
         //
         // The name of the current outer API function, if any; otherwise NULL.

      bool startInnerNeeded_;
         //
         // True, iff there is currently a need to call startInnerFunc ().

      bool mustSkipCallMsg_;
         //
         // True, iff this ApiMgr is not to issue the API function call Msg for
         // the current API function.

      bool preInitAllowed_;
         //
         // True, iff the current API function is allowed to be called when
         // witInitialize and witCopyData have not yet been called.
         // Only valid between a call to startApiFunc (...) and        
         // startInnerFunc (...).

      bool extOptActAllowed_;
         //
         // True, iff the current API function is allowed to be called when
         // external optimizing implosion is currently active.
         // Only valid between a call to startApiFunc (...) and        
         // startInnerFunc (...).

      WitReturnCode apiRc_;
         //
         // Return code value which api function will return to caller

      bool prevApiAbort_;
         //
         // True, iff at least one previous call to an API function for
         // myWitRun_ aborted with a severe or fatal return code.

      WitApiMgr * myApiMgr2_;
         //
         // During a call to an API function with two WitRun arguments, if the
         // two WitRuns are distinct, myApiMgr2_ is the ApiMgr for the second
         // WitRun; otherwise NULL.

      WitTVec <int> tempIntVec_;
         //
         // Temporary int vector to be used by some API "set" compatibility
         // functions.

      WitTVec <double> tempDblVec_;
         //
         // Temporary double vector to be used by some API "set" compatibility
         // functions.

      bool tempVecsReserved_;
         //
         // true, iff the temp vectors are currently reserved.
   };

//------------------------------------------------------------------------------

namespace WitNonClass
   {
   bool asaBool (WitBoolean theBoolean);
      //
      // Converts theBoolean to a bool.
   };

#endif
@


1.93
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.92
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d29 2
a30 121
{
public:

//------------------------------------------------------------------------
// Public member data.
//------------------------------------------------------------------------

WitApiMgr (WitRun * theWitRun);
//
// myWitRun_ <-- theWitRun.

//------------------------------------------------------------------------
// Destructor functions.
//------------------------------------------------------------------------

~WitApiMgr ();

//------------------------------------------------------------------------
// Public member functions.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (WitRun *,      myWitRun)
accessFunc (WitSession *,  mySession)
accessFunc (WitInputID *,  myInputID)
accessFunc (const char *,  apiFuncName)
accessFunc (WitReturnCode, apiRc)

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

static void startApiFunc (WitRun * theWitRun, const char * theFuncName);
//
// This function is called from the CALL_INNER_API macro
// just prior to calling the inner API function on theWitRun.
//
// theFuncName: Name of the outer API function.

void finishApiFunc ();
//
// This function is called from the CALL_INNER_API macro
// just after calling the inner API function on theWitRun.

void handleAnyExc ();
//
// Handles all exceptions.

void lockMyWitRun (const char * theFuncName);
//
// Puts myWitRun_ into a "locked" state: No further API functions calls
// to myWitRun_ are allowed, other than the current one.
// theFuncName is the name of the currently called API function.

void unlockMyWitRun ();
//
// Puts myWitRun_ into an "unlocked" state: Further API functions calls
// to myWitRun_ are now allowed.

void skipCallMsg ();
//
// Tells this ApiMgr not to issue the API function call Msg for the
// current API function.

void allowPreInit ();
//
// Tells this ApiMgr to allow the API current function to be called
// when witInitialize and witCopyData have not yet been called.

void allowExtOptActive ();
//
// Tells this ApiMgr to allow the API current function to be called
// when external optimizing implosion is active.

void startInnerFunc ();
//
// Takes action appropriate at the beginning of a call to an inner API
// function.

void start2WitRunFunc (WitApiMgr * theApiMgr2);
//
// Takes action as needed at the beginning of a call to an API
// function with two WitRun arguments.
// theApiMgr2 is the ApiMgr for the second WitRun.

void updateApiRc (WitReturnCode theRc);
//
// Sets apiRc_ to theRc, if theRc is greater.

void resetInputID ();
//
// Deletes myInputID () and creates a new one.

WitTVec <WitBoolean> & reserveTempBooleanVec ();
//
// Same as reserveTempDblVec, but for WitBoolean.

WitTVec <int> & reserveTempIntVec ();
//
// Same as reserveTempDblVec, but for int.

WitTVec <double> & reserveTempDblVec ();
//
// Asserts that the temp vectors are not currently reserved,
// reserves them, makes tempDblVec the right size, and returns it.

void releaseTempVecs ();
//
// Asserts that the temp vectors are in use, then indicates that they
// are not.

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitApiMgr);
d32 228
a259 109
static void setUpNewFailure ();
//
// Sets up WIT's response to a failure of the "new" operator,
// if necessary.

static int throwBadAlloc (size_t);
//
// Throws a std::bad_alloc exception.
// (The argument is ignored.)

void handleIssueMsgExc (WitIssueMsgExc & theIssueMsgExc);
//
// Handles theIssueMsgExc.

void handleAbortApiExc (WitAbortApiExc & theAbortApiExc);
//
// Handles theAbortApiExc.

void abortApiFunc (
WitAbortApiExc &  theAbortApiExc,
const WitString & theFuncName);
//
// Aborts the currently running API function in the manner indicated by
// theAbortApiExc.
// theFuncName is the name of the API function.

inline WitMsgFacility & myMsgFac ();

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

static bool newHandlerSet_;
//
// True, iff the "new handler" has been set to throwBadAlloc.

WitRun * const myWitRun_;
//
// The WitRun that owns this ApiMgr.

WitSession * mySession_;
//
// The Session owned by this ApiMgr.

WitInputID * myInputID_;
//
// The InputID owned by this ApiMgr.

bool myWitRunIsLocked_;
//
// True, iff a call to an API function for myWitRun_ is currently in
// progress.

const char * apiFuncName_;
//
// The name of the current outer API function, if any; otherwise NULL.

bool startInnerNeeded_;
//
// True, iff there is currently a need to call startInnerFunc ().

bool mustSkipCallMsg_;
//
// True, iff this ApiMgr is not to issue the API function call Msg for
// the current API function.

bool preInitAllowed_;
//
// True, iff the current API function is allowed to be called when
// witInitialize and witCopyData have not yet been called.
// Only valid between a call to startApiFunc (...) and
// startInnerFunc (...).

bool extOptActAllowed_;
//
// True, iff the current API function is allowed to be called when
// external optimizing implosion is currently active.
// Only valid between a call to startApiFunc (...) and
// startInnerFunc (...).

WitReturnCode apiRc_;
//
// Return code value which api function will return to caller

bool prevApiAbort_;
//
// True, iff at least one previous call to an API function for
// myWitRun_ aborted with a severe or fatal return code.

WitApiMgr * myApiMgr2_;
//
// During a call to an API function with two WitRun arguments, if the
// two WitRuns are distinct, myApiMgr2_ is the ApiMgr for the second
// WitRun; otherwise NULL.

WitTVec <int> tempIntVec_;
//
// Temporary int vector to be used by some API "set" compatibility
// functions.

WitTVec <double> tempDblVec_;
//
// Temporary double vector to be used by some API "set" compatibility
// functions.

bool tempVecsReserved_;
//
// true, iff the temp vectors are currently reserved.
};
d264 5
a268 5
{
bool asaBool (WitBoolean theBoolean);
//
// Converts theBoolean to a bool.
};
@


1.91
log
@Removed multiThread.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d29 121
a149 2
   {
   public:
d151 109
a259 228
      //------------------------------------------------------------------------
      // Public member data.
      //------------------------------------------------------------------------

      WitApiMgr (WitRun * theWitRun);
         //
         // myWitRun_ <-- theWitRun.

      //------------------------------------------------------------------------
      // Destructor functions.
      //------------------------------------------------------------------------

      ~WitApiMgr ();

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitRun *,      myWitRun)
      accessFunc (WitSession *,  mySession)
      accessFunc (WitInputID *,  myInputID)
      accessFunc (const char *,  apiFuncName)
      accessFunc (WitReturnCode, apiRc)

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static void startApiFunc (WitRun * theWitRun, const char * theFuncName);
         //
         // This function is called from the CALL_INNER_API macro
         // just prior to calling the inner API function on theWitRun.
         //
         // theFuncName: Name of the outer API function.

      void finishApiFunc ();
         //
         // This function is called from the CALL_INNER_API macro
         // just after calling the inner API function on theWitRun.

      void handleAnyExc ();
         //
         // Handles all exceptions.

      void lockMyWitRun (const char * theFuncName);
         //
         // Puts myWitRun_ into a "locked" state: No further API functions calls
         // to myWitRun_ are allowed, other than the current one.
         // theFuncName is the name of the currently called API function.

      void unlockMyWitRun ();
         //
         // Puts myWitRun_ into an "unlocked" state: Further API functions calls
         // to myWitRun_ are now allowed.

      void skipCallMsg ();
         //
         // Tells this ApiMgr not to issue the API function call Msg for the
         // current API function.

      void allowPreInit ();
         //
         // Tells this ApiMgr to allow the API current function to be called
         // when witInitialize and witCopyData have not yet been called.

      void allowExtOptActive ();
         //
         // Tells this ApiMgr to allow the API current function to be called
         // when external optimizing implosion is active.

      void startInnerFunc ();
         //
         // Takes action appropriate at the beginning of a call to an inner API
         // function.

      void start2WitRunFunc (WitApiMgr * theApiMgr2);
         //
         // Takes action as needed at the beginning of a call to an API
         // function with two WitRun arguments.
         // theApiMgr2 is the ApiMgr for the second WitRun.

      void updateApiRc (WitReturnCode theRc);
         //
         // Sets apiRc_ to theRc, if theRc is greater.

      void resetInputID ();
         //
         // Deletes myInputID () and creates a new one.

      WitTVec <WitBoolean> & reserveTempBooleanVec ();
         //
         // Same as reserveTempDblVec, but for WitBoolean.

      WitTVec <int> & reserveTempIntVec ();
         //
         // Same as reserveTempDblVec, but for int.

      WitTVec <double> & reserveTempDblVec ();
         //
         // Asserts that the temp vectors are not currently reserved,
         // reserves them, makes tempDblVec the right size, and returns it.

      void releaseTempVecs ();
         //
         // Asserts that the temp vectors are in use, then indicates that they
         // are not.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitApiMgr);

      static void setUpNewFailure ();
         //
         // Sets up WIT's response to a failure of the "new" operator,
         // if necessary.

      static int throwBadAlloc (size_t);
         //
         // Throws a std::bad_alloc exception.
         // (The argument is ignored.)

      void handleIssueMsgExc (WitIssueMsgExc & theIssueMsgExc);
         //
         // Handles theIssueMsgExc.

      void handleAbortApiExc (WitAbortApiExc & theAbortApiExc);
         //
         // Handles theAbortApiExc.

      void abortApiFunc (
            WitAbortApiExc &  theAbortApiExc,
            const WitString & theFuncName);
         //
         // Aborts the currently running API function in the manner indicated by
         // theAbortApiExc.
         // theFuncName is the name of the API function.

      inline WitMsgFacility & myMsgFac ();

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      static bool newHandlerSet_;
         //
         // True, iff the "new handler" has been set to throwBadAlloc.

      WitRun * const myWitRun_;
         //
         // The WitRun that owns this ApiMgr.

      WitSession * mySession_;
         //
         // The Session owned by this ApiMgr.

      WitInputID * myInputID_;
         //
         // The InputID owned by this ApiMgr.

      bool myWitRunIsLocked_;
         //
         // True, iff a call to an API function for myWitRun_ is currently in
         // progress.

      const char * apiFuncName_;
         //
         // The name of the current outer API function, if any; otherwise NULL.

      bool startInnerNeeded_;
         //
         // True, iff there is currently a need to call startInnerFunc ().

      bool mustSkipCallMsg_;
         //
         // True, iff this ApiMgr is not to issue the API function call Msg for
         // the current API function.

      bool preInitAllowed_;
         //
         // True, iff the current API function is allowed to be called when
         // witInitialize and witCopyData have not yet been called.
         // Only valid between a call to startApiFunc (...) and        
         // startInnerFunc (...).

      bool extOptActAllowed_;
         //
         // True, iff the current API function is allowed to be called when
         // external optimizing implosion is currently active.
         // Only valid between a call to startApiFunc (...) and        
         // startInnerFunc (...).

      WitReturnCode apiRc_;
         //
         // Return code value which api function will return to caller

      bool prevApiAbort_;
         //
         // True, iff at least one previous call to an API function for
         // myWitRun_ aborted with a severe or fatal return code.

      WitApiMgr * myApiMgr2_;
         //
         // During a call to an API function with two WitRun arguments, if the
         // two WitRuns are distinct, myApiMgr2_ is the ApiMgr for the second
         // WitRun; otherwise NULL.

      WitTVec <int> tempIntVec_;
         //
         // Temporary int vector to be used by some API "set" compatibility
         // functions.

      WitTVec <double> tempDblVec_;
         //
         // Temporary double vector to be used by some API "set" compatibility
         // functions.

      bool tempVecsReserved_;
         //
         // true, iff the temp vectors are currently reserved.
   };
d264 5
a268 5
   {
   bool asaBool (WitBoolean theBoolean);
      //
      // Converts theBoolean to a bool.
   };
@


1.90
log
@Made WIT operate in multi-thread mode unconditionally.
The multithread attribute in no longer meaningful.
@
text
@d54 5
a58 10
      accessFunc (WitRun *,          myWitRun)
      accessFunc (WitSession *,      mySession)
      accessFunc (WitInputID *,      myInputID)
      accessFunc (const char *,      apiFuncName)
      accessFunc (WitReturnCode,     apiRc)

      inline static bool multiThread ()
         {
         return multiThread_;
         }
a63 4
      static void setMultiThread ();
         //
         // Sets multiThread_ to true.

a258 6

      static bool multiThread_;
         //
         // Legacy boolean.
         // This value can be set and retrieved through the API, but it has no
         // significant on WIT's behavior.
@


1.89
log
@witCopy<Object>Data
@
text
@a88 13
      static void lockWit (const char * theFuncName);
         //
         // Puts WIT into a "locked" state: No further API functions calls
         // to any WitRun are allowed, other than the current one.
         // theFuncName is the name of the currently called API function.
         // Valid only if multiThread_ is false.

      static void unlockWit ();
         //
         // Puts WIT into an "unlocked" state: Further API functions calls
         // to any WitRun are no longer prohibited by the "lockWit" function.
         // Valid only if multiThread_ is false.

d189 1
a189 1
      // Static Private member data.
a191 16
      static bool multiThread_;
         //
         // True, iff multiply-threaded calls to API functions are to be
         // allowed.

      static bool witIsLocked_;
         //
         // True, iff a call to an API function for any myWitRun_ is currently
         // in progress and multiThread_ is false.

      static const char * lockingFuncName_;
         //
         // In single-thread mode:
         //    The function name for the current API call, if any;
         //    otherwise NULL.

a195 4
      //------------------------------------------------------------------------
      // Non-static Private member data.
      //------------------------------------------------------------------------

d268 6
@


1.88
log
@witCopy<Object>Data
@
text
@d80 1
a80 1
      static void finishApiFunc (WitRun * theWitRun);
a138 10
      void finish2WitRunFunc (WitApiMgr * theApiMgr2);
         //
         // Takes action as needed at the end of a call to an API
         // function with two WitRun arguments.
         // theApiMgr2 is the ApiMgr for the second WitRun.

      void setPrevApiAbort ();
         //
         // Sets prevApiAbort_ to true.

d282 6
@


1.87
log
@witCopy<Object>Data
@
text
@d201 3
a203 1
      void abortApiFunc (int theMsgNum, const WitString & theFuncName);
d205 2
a206 2
         // Aborts the currently running API function in the manner appropriate
         // for the Msg corresponding the theMsgNum.
@


1.86
log
@External opt implosion.
@
text
@d133 1
a133 1
      void startCopyData (WitApiMgr * srcApiMgr);
d135 3
a137 2
         // Takes action as needed at the beginning of a call to
         // myWitRun_->witCopyData (srcApiMgr->myWitRun_).
d139 1
a139 1
      void finishCopyData (WitApiMgr * srcApiMgr);
d141 3
a143 2
         // Takes action as needed at the end of a call to
         // myWitRun_->witCopyData (srcApiMgr->myWitRun_).
@


1.85
log
@App controlled opt implosion.
@
text
@d57 1
a64 4
      const WitString & apiFuncName ();
         //
         // Returns the name of the current API function.

d113 20
a238 4
      WitAfrMgr * myAfrMgr_;
         //
         // The AfrMgr owned by this ApiMgr.

d252 21
a272 1
      WitApiFuncRep * curFuncRep_;
d274 4
a277 1
         // The ApiFuncRep for the current API function.
@


1.84
log
@App controlled opt implosion.
@
text
@d76 1
a76 1
      void startApiFunc (const char * theFuncName);
d79 1
a79 1
         // just prior to calling the inner API function.
d83 1
a83 1
      void finishApiFunc ();
d86 1
a86 1
         // just after calling the inner API function.
@


1.83
log
@App controlled opt implosion.
@
text
@d222 1
a222 1
      WitAfaMgr * myAfaMgr_;
d224 1
a224 1
         // The AfaMgr owned by this ApiMgr.
d239 1
a239 1
      WitApiFuncAid * curFuncAid_;
d241 1
a241 1
         // The ApiFuncAid for the current API function.
@


1.82
log
@App controlled opt implosion.
@
text
@a12 1
#include <StateTags.h>
a115 5
      void startInnerApiFunc (WitInitState::Tag, WitOptImpState::Tag);
         //
         // Takes action appropriate at the beginning of the execution of an
         // inner API function with required states indicated by the arguments.

a251 4
      bool startInnerNeeded_;
        //
        // true, iff a call to startInnerApiFunc (...) is needed.

@


1.81
log
@App controlled opt implosion.
@
text
@a14 1
#include <Str.h>
a57 1
      accessFunc (const WitString &, apiFuncName)
d65 4
d228 4
d245 1
a245 1
      WitString apiFuncName_;
d247 1
a247 1
         // Name of current API function.
@


1.80
log
@Updated the copyright date on all source files.
@
text
@d13 1
d75 1
a75 1
      void startApiFunc (const char * theFuncName, bool preInitMode);
d80 1
a80 4
         // Arguments:
         //    theFuncName: Name of the API function.
         //    preInitMode: True, iff the API function is allowed to be called
         //                 before witInitialize.
d115 5
d252 4
@


1.79
log
@[error recovery]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.78
log
@[error recovery]
@
text
@a65 5
      inline static bool errorRecovery ()
         {
         return errorRecovery_;
         }

a73 4
      static void setErrorRecovery ();
         //
         // Sets errorRecovery_ to true.

d127 1
a127 1
      void setPrevApiAbortMyWR ();
d129 1
a129 1
         // Sets prevApiAbortMyWR_ to true.
a210 5
      static bool prevApiAbortAnyWR_;
         //
         // True, iff at least one previous call to an API function for any
         // WitRun aborted with a severe or fatal return code.

a214 4
      static bool errorRecovery_;
         //
         // True, iff the new error recovery convention is to be used.

d244 1
a244 1
      bool prevApiAbortMyWR_;
@


1.77
log
@An attempt to implement the bad_alloc new error behavior
with the MS Visual C++ V6 compiler.
@
text
@d131 8
a138 1
      void finishCopyData ();
a279 7

      WitApiMgr * srcApiMgrForCopy_;
         //
         // During witCopyData (dstWitRun_, srcWitRun),
         // where dstWitRun == myWitRun_,
         // srcApiMgrForCopy_ == srcWitRun->myApiMgr_;
         // otherwise NULL.
@


1.76
log
@[error recovery]
@
text
@d172 1
a172 1
      static void throwBadAlloc ();
d175 1
@


1.75
log
@Fixed a bug that occurred when witCopyData issued a severe error.
@
text
@d184 6
@


1.74
log
@Setting bad_alloc behavior for the MS compiler.
@
text
@a59 1
      accessFunc (bool,              abortingApiFunc)
a140 6
      void abortApiFunc (int theMsgNum);
         //
         // Immediately terminates execution of the API function that was called
         // by the application program. theMsgNum is the message number of the
         // message that tiggered the termination.

a266 4
      bool abortingApiFunc_;
         //
         // true, iff abortApiFunc has been called.

@


1.73
log
@[error recovery]
@
text
@d174 9
d218 4
@


1.72
log
@Fixed a bug:
   When witCopyData detected a severe error in srcWitRun, the function was
   returning 0, instead of 3 as its return code.
@
text
@a270 7

      WitApiMgr * dstApiMgrForCopy_;
         //
         // During witCopyData (dstWitRun_, srcWitRun),
         // where srcWitRun == myWitRun_,
         // dstApiMgrForCopy_ == dstWitRun->myApiMgr_;
         // otherwise NULL.
@


1.71
log
@[error recovery]
@
text
@d267 2
a268 1
         // During myWitRun_->witCopyData (srcWitRun),
d271 7
@


1.70
log
@[multi-thread]
@
text
@d67 5
d80 4
d127 7
d204 1
a204 1
      static bool prevApiAbort_;
d206 6
a211 2
         // True, iff at least one previous call to an API function aborted with
         // a severe or fatal return code.
d242 5
d264 6
@


1.69
log
@[multi-thread]
@
text
@d107 1
a107 1
      void lockWitRun (const char * theFuncName);
d113 1
a113 1
      void unlockWitRun ();
@


1.68
log
@[multi-thread]
@
text
@d75 1
a75 4
      void startApiFunc (
            const char * theFuncName,
            bool         preInitMode,
            bool         quietMode);
a83 2
         //    quietMode:   True, iff informational messages are to be
         //                 suppressed.
@


1.67
log
@[multi-thread]
@
text
@a111 13
      static void lockWitMT (const char * theFuncName);
         //
         // Puts WIT into a "locked" state: No further API functions calls
         // to any WitRun are allowed, other than the current one.
         // theFuncName is the name of the currently called API function.
         // Valid only if multiThread_ is true.

      static void unlockWitMT ();
         //
         // Puts WIT into an "unlocked" state: Further API functions calls
         // to any WitRun are no longer prohibited by the "lockWitMT" function.
         // Valid only if multiThread_ is true.

a192 11
      static bool witIsLockedMT_;
         //
         // True, iff a call to an API function for any myWitRun_ is currently
         // in progress and multiThread_ is true.

      static const char * lockingFuncNameMT_;
         //
         // In multi-thread mode:
         //    The function name for the current API call, if any;
         //    otherwise NULL.

@


1.66
log
@[multi-thread]
@
text
@d125 11
a175 11
      void lockWitRun (const char * theFuncName);
         //
         // Puts myWitRun_ into a "locked" state: No further API functions calls
         // to myWitRun_ are allowed, other than the current one.
         // theFuncName is the name of the currently called API function.

      void unlockWitRun ();
         //
         // Puts myWitRun_ into an "unlocked" state: Further API functions calls
         // to myWitRun_ are now allowed.

@


1.65
log
@Reinstated code to catch unknown exceptions.
Added code to handle standard library exceptions.
@
text
@d99 1
a99 1
      static void sglThreadLock (const char * theFuncName);
d101 6
a106 3
         // In single-thread mode:
         //    Locks out all other API function calls to any WitRun.
         //    theFuncName is the name of the current API function.
d108 3
a110 3
         // In multi-thread mode:
         //    Same as single-thread mode, for now (with a different error msg).
         //    Later, no-op.
d112 1
a112 1
      static void sglThreadUnlock ();
d114 6
a119 2
         // In single-thread mode:
         //    Allows other API function calls to any WitRun.
d121 3
a123 3
         // In multi-thread mode:
         //    Same as single-thread mode, for now.
         //    Later, no-op.
d165 7
a171 1
      void actCallToThisError (const char * theFuncName);
d173 2
a174 5
         // Issues a non-msg severe error for calling an API function when the
         // previous function call to the same WitRun is still in progress.
         // This indicates that there are two concurrent API function calls to
         // the same WitRun in a multiply-threaded environment.
         // theFuncName is the name of the current function.
d195 6
a200 1
      static const char * sglFuncName_;
d205 7
d214 2
a215 2
         //    Same as single-thread mode, for now.
         //    Later, always NULL.
d238 1
a238 1
      bool actCallToThis_;
@


1.64
log
@[multi-thread]
@
text
@a165 4
      void handleBadAllocExc ();
         //
         // Handles a std::bad_alloc exception.

a173 4
      void handleUnknownExc ();
         //
         // Handles an unknown exception.

@


1.63
log
@[multi-thread]
@
text
@a57 1
      accessFunc (bool,              standAloneMode)
a70 2
      void setStandAloneMode (bool);

a223 4
      bool standAloneMode_;
         //
         // True if WIT is being used in standalone executable mode.

@


1.62
log
@[multi-thread]
@
text
@d58 1
a58 1
      accessFunc (bool,              apiMode)
d72 1
a72 1
      void setApiMode (bool);
d227 1
a227 1
      bool apiMode_;
d229 1
a229 2
         // True if WIT is being used via API. False if WIT is
         // being used in standalone executable mode.
@


1.61
log
@[multi-thread]
@
text
@d206 1
a206 1
      static bool errorMsgIssued_;
d208 2
a209 2
         // True, iff at least one severe or fatal error message has been issued
         // by any WitRun in the program process.
@


1.60
log
@[multi-thread]
@
text
@d121 1
a121 1
      void updateApiRc (WitReturnCode rc);
d123 1
a123 1
         // Sets apiRc_ to rc, if rc is greater.
d206 1
a206 1
      static witReturnCode maxRc_;
d208 2
a209 2
         // The maximum return code value returned by any WIT API function in
         // this program process.
@


1.59
log
@[multi-thread]
@
text
@d20 1
a20 4
// Contains the declaration of the following classes:
//
//    ApiMgr.
//    AbortApiExc.
d26 1
a26 1
// functions
d173 1
a173 1
      void handleMsgIssueExc (WitMsgIssueExc & theMsgIssueExc);
d175 1
a175 1
         // Handles theMsgIssueExc.
a272 52
//------------------------------------------------------------------------------
// Class AbortApiExc
//
// "Abort API Exception"
// Exceptions of this type are caught at the end of the outer API function that
// was called by the application program and cause it either to return execution
// to the application program or throw a WitException.
//------------------------------------------------------------------------------

class WitAbortApiExc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAbortApiExc (int);

      WitAbortApiExc (const WitAbortApiExc &);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitAbortApiExc ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (int, myMsgNum)

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      WitMsgArg & operator = (const WitMsgArg &);
         //
         // Not implemented.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      const int myMsgNum_;
         //
         // The number of the message that caused this exception to be thrown.
   };

@


1.58
log
@[multi-thread]
@
text
@d20 1
a20 1
// Contains the declaration of class  ApiMgr.
d22 2
a23 1
// Contains the declaration of struct AbortApiExc.
d277 1
a277 1
// Struct AbortApiExc
d285 1
a285 1
struct WitAbortApiExc
d287 39
a325 3
   int myMsgNum_;
      //
      // The number of the message that caused this exception to be thrown.
@


1.57
log
@[multi-thread]
@
text
@a22 1
// Contains the declaration of struct IssueFromApiExc.
d171 5
a175 1
      void handleUnknownExc ();
d177 1
a177 1
         // Handles an unknown exception.
d181 5
a185 1
         // Handles an theAbortApiExc.
@


1.56
log
@[multi-thread]
@
text
@d101 1
a101 1
      void handleInternalExc ();
d103 1
a103 1
         // Handles all WIT internal exceptions.
d172 4
@


1.55
log
@[multi-thread]
@
text
@d101 1
a101 1
      void handleBadAllocExc ();
d103 1
a103 9
         // Handles an std::bad_alloc exception.

      void handleMsgIssueExc (WitMsgIssueExc & theMsgIssueExc);
         //
         // Handles an theMsgIssueExc.

      void handleAbortApiExc (WitAbortApiExc & theAbortApiExc);
         //
         // Handles an theAbortApiExc.
d172 4
@


1.54
log
@Removed code supporting the variable-argument-list API functions.
@
text
@a16 2
#include <new>

d23 1
d105 4
d272 3
a274 3
// Exceptions of this type are caught at the end of the API function that was
// called by the application program and cause it either to return execution to
// the application program or throw an ErrorExc.
@


1.53
log
@[multi-thread]
@
text
@a24 2
//
// Contains the declaration of class  ApiVaList.
a280 54
//------------------------------------------------------------------------------
// Class ApiVaList
//
// A wrapper class for va_list.
//
// The purpose of this class is to aid in the implementation of the
// variable-argument-list (outer) API functions.
// An instance of this class owns a va_list to be used by API function.
// The dtor of this class calls va_end on the va_list.
// Thus declaring an instance of ApiVaList as a local variable in the
// implementation of an API function causes the va_end to be called
// automatically when the function returns.
//------------------------------------------------------------------------------

class WitApiVaList
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitApiVaList ();

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitApiVaList ();

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      inline va_list & operator () ()
         {
         return myVaList_;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitApiVaList);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      va_list myVaList_;
   };

@


1.52
log
@[multi-thread]
@
text
@a234 5
      void (* savedNewHandler_) ();
         //
         // The newHandler that was in effect when the application called an
         // API function.

@


1.51
log
@[multi-thread]
@
text
@d266 5
a270 9
{

bool asaBool (WitBoolean theBoolean);
   //
   // Converts theBoolean to a bool.

};
   //
   // Leaving namespace NonClass.
@


1.50
log
@[multi-thread]
@
text
@d86 2
a87 2
            bool         preInitFunc,
            bool         quietFunc);
d94 1
a94 1
         //    preInitFunc: True, iff the API function is allowed to be called
d96 1
a96 1
         //    quietFunc:   True, iff informational messages are to be
@


1.49
log
@[multi-thread]
@
text
@d84 4
a87 1
      void startApiFunc (const char * theFuncName, bool preInit, bool quiet);
d94 1
a94 1
         //    preInit:     True, iff the API function is allowed to be called
d96 1
a96 1
         //    quiet:       True, iff informational messages are to be
@


1.48
log
@[multi-thread]
@
text
@d293 8
a300 1
// The dtor calls va_end.
@


1.47
log
@[multi-thread]
@
text
@d25 2
d101 4
d289 47
@


1.46
log
@[multi-thread]
@
text
@d22 1
a22 1
// Contains the declaration of class ApiMgr.
a61 3
      accessFunc (WitApiGroup *,     defaultGroup)
      accessFunc (WitApiGroup *,     preInGroup)
      accessFunc (WitApiGroup *,     quietGroup)
d82 1
a82 1
      void startApiFunc (const char * theFuncName, WitApiGroup * theGroup);
d87 1
a87 1
         // Argument:
d89 4
a92 2
         //    theGroup:    the ApiGroup to which the API outer function
         //                 belongs.
a211 12
      WitApiGroup * defaultGroup_;
      WitApiGroup * preInGroup_;
      WitApiGroup * quietGroup_;
         //
         // The ApiGroups owned by this ApiMgr.
         // Attribute values:
         //
         //             preInitMode quietMode
         // defaultGroup     F          F
         // preInGroup       T          F
         // quietGroup       T          T

@


1.45
log
@[multi-thread]
@
text
@d63 1
a64 2
      accessFunc (WitApiGroup *,     preInGroup)
      accessFunc (WitApiGroup *,     quietPreInGroup)
d214 1
a215 2
      WitApiGroup * preInGroup_;
      WitApiGroup * quietPreInGroup_;
d220 4
a223 5
         //                quietMode preInitMode
         // defaultGroup       F          F
         // quietGroup         T          F
         // preInGroup         F          T
         // quietPreInGroup    T          T
@


1.44
log
@[multi-thread]
@
text
@a62 1
      accessFunc (WitApiGroup *,     doubleGroup)
a214 1
      WitApiGroup * doubleGroup_;
d222 5
a226 6
         //               doubleMode quietMode preInitMode
         // defaultGroup       F         F          F
         // doubleGroup        T         F          F
         // quietGroup         F         T          F
         // preInGroup         F         F          T
         // quietPreInGroup    F         T          T
@


1.43
log
@[multi-thread]
@
text
@d106 1
a106 1
      static void lockApi (const char * theFuncName);
d108 7
a114 2
         // If appropriate, puts the API into a locked state.
         // theFuncName is the name of the current API function.
d116 4
a119 1
      static void unlockApi ();
d121 3
a123 1
         // If appropriate, puts the API into an unlocked state.
d184 1
a184 1
      static bool locked_;
d186 7
a192 1
         // True, iff the API is currently in a locked state for all WitRuns.
@


1.42
log
@[multi-thread]
@
text
@d106 9
d155 1
a155 3
      void callInProgressError (
            const char * theFuncName,
            const char * suffix);
a161 2
         // suffix is an optional "Dbl" to be appended to the end of
         // theFuncName.
d166 19
a184 1
      // Private member data.
d220 1
a220 6
      static bool multiThread_;
         //
         // True, iff multiply-threaded calls to API functions are to be
         // allowed.

      bool callInProgress_;
a251 5
      static witReturnCode maxRc_;
         //
         // The maximum return code value returned by any WIT API function in
         // this program process.

@


1.41
log
@[multi-thread]
@
text
@d72 5
d83 4
d197 5
@


1.40
log
@[multi-thread]
@
text
@a205 5
      static const char * const allowBeforeInit_[];
         //
         // Required to avoid "sorry, not implemented" messages on Sun.
         // These symbols should be local to ApiMgr::checkAllowBeforeInit.

@


1.39
log
@[multi-thread]
@
text
@d66 1
a66 1
      accessFunc (WitApiGroup *,     preInQuietGroup)
d171 1
a171 1
      WitApiGroup * preInQuietGroup_;
d181 1
a181 1
         // preInQuietGroup    F         T          T
@


1.38
log
@[multi-threads]
@
text
@d65 2
a66 1
      accessFunc (WitApiGroup *,     preInitGroup)
d170 2
a171 1
      WitApiGroup * preInitGroup_;
d180 2
a181 1
         // preInitGroup       F         T          T
@


1.37
log
@[multi-threads]
@
text
@d62 4
d77 1
a77 9
      void setQuietCall ();
         //
         // Sets quietCall_ to true.

      void setDblCall ();
         //
         // Sets dblCall_ to true.

      void startApiFunc (const char * theFuncName);
d84 2
a147 4
      void checkAllowBeforeInit ();
         //
         // Test to ensure API witInitialize has been done if required.

d166 14
a184 11
      bool quietCall_;
         //
         // True, if informational messages to be suppressed in the current
         // API function call.
         // startApiFunc () uses this value and then sets it to false.

      bool dblCall_;
         //
         // True, if the name of the current outer API function ends with "Dbl".
         // startApiFunc () uses this value and then sets it to false.

a240 1
// Leaving namespace NonClass.
d242 2
@


1.36
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d73 9
a81 1
      void startApiFunc (const char * theFuncName, bool quiet);
d86 1
a86 1
         // Arguments:
a87 1
         //    quiet:       True, if informational messages to be surpressed.
d138 3
a140 1
      void callInProgressError (const char * theFuncName);
d147 2
d177 11
@


1.35
log
@[multi-threads]
@
text
@d23 2
d73 1
a73 1
      void enteringApiFunction (const char * funcName, bool quiet);
d75 2
a76 2
         // This function is invoked when an API routine is entered.  It saves
         // state information and is invoked via the PROLOG macro. 
d79 2
a80 2
         //    funcName: Name of api function.
         //    quiet:    True if informational messages to be surpressed.
d82 4
a85 15
      inline bool calledByApp () const
         {
         witAssert (nActCalls_ > 0);

         return (nActCalls_ == 1);
         }
         //
         // Returns true if current api function was invoked by
         // the application program.  Returns false if current api
         // function was invoked by an api function.

      inline bool hasActCalls ()
         {
         return (nActCalls_ > 0);
         }
a90 4
      void leavingApiFunction ();
         //
         // Update state when exiting an api function

d131 1
a131 1
      void apiCallOrder (const char * const name );
d133 5
a137 1
         // Test to ensure API witInitizlize has been done if required
d139 1
a139 1
      void appDblToFuncName ();
d141 1
a141 2
         // Appends "Dbl" to the end of apiFuncName_ for a double precision
         // function.
d166 1
a166 1
      int nActCalls_;
d168 2
a169 1
         // The number of calls to API functions that have not yet returned.
d187 1
a187 1
         // These symbols should be local to ApiMgr::apiCallOrder.
d225 16
@


1.34
log
@[exceptions]
@
text
@d80 1
a80 1
      inline bool applicationCalled () const
d82 3
a84 1
         return (apiDepth_ == 1);
d91 6
a96 1
      void handle (WitAbortApiExc & theAbortApiExc);
d176 1
a176 1
      int apiDepth_;
d178 1
a178 3
         // Depth of nested api calls. This is incremented when ever 
         // an API function is invoked and decremented when the function
         // returns.  This allows wit to internally call API functions.
@


1.33
log
@[exceptions]
@
text
@d22 1
a22 8
// Contains the declaration of the following classes:
//
//    ApiMgr.
//    InputId.
//
// Contains macros for API prolog and epilog code.
//
// Contains the declaration of struct AbortApiExc.
d59 1
a59 1
      accessFunc (WitInputId *,      myInputId)
d101 1
a101 1
      void resetInputId ();
d103 1
a103 1
         // Deletes myInputId () and creates a new one.
d105 1
a105 1
      void abortApiFunc (bool byException);
d108 2
a109 2
         // by the application program. The termintation is to be done by
         // throwing an exception iff byException is true.
d160 1
a160 1
      WitInputId * myInputId_;
d162 1
a162 1
         // The InputId owned by this ApiMgr.
a217 152
// PROLOG:       Generates code required at beginning of user callable routine.
// QUIET_PROLOG: Same as PROLOG, but suppresses informational messages.
//
// funcName: Name of api function.
// Must be called from scope WitRun.
//------------------------------------------------------------------------------

#define PROLOG(funcName)                                                       \
                                                                               \
   try                                                                         \
      {                                                                        \
      myApiMgr_->enteringApiFunction (funcName, false);                        \
                                                                               \
         {                                                                     \

#define QUIET_PROLOG(funcName)                                                 \
                                                                               \
   try                                                                         \
      {                                                                        \
      myApiMgr_->enteringApiFunction (funcName, true);                         \
                                                                               \
         {                                                                     \

//------------------------------------------------------------------------------
// EPILOG  Generates code required at end of user callable routine.
// Must be called from scope WitRun.
//------------------------------------------------------------------------------

   // Indicate  API function is being exited.
   // In catch block, if this is not the function invoked by user then
   // throw exception to move up to next API function in call tree.
   //
#define EPILOG                                                                 \
                                                                               \
         }                                                                     \
                                                                               \
      myApiMgr_->leavingApiFunction ();                                        \
                                                                               \
      } /* end of try block */                                                 \
                                                                               \
   catch (WitAbortApiExc & theExc)                                             \
      {                                                                        \
      myApiMgr_->handle (theExc);                                              \
      }                                                                        \
                                                                               \
   return myApiMgr_->apiRc ();                                                 \

//------------------------------------------------------------------------------
// Class InputId
//
// Responsible for identifying API input.
//------------------------------------------------------------------------------

class WitInputId
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitInputId (WitApiMgr * theApiMgr);
         //
         // myApiMgr_ <-- theApiMgr.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitInputId ();

      //------------------------------------------------------------------------
      // Set functions.
      //------------------------------------------------------------------------

      void setMyAttr         (WitAttr);
      void setMyPart         (WitPart *);
      void setMyOperation    (WitOperation *);
      void setMyDemand       (WitDemand *);
      void setMyBomEntry     (WitBomEntry *);
      void setMySubEntry     (WitSubEntry *);
      void setMyBopEntry     (WitBopEntry *);
      void setArgName        (const char *);
      void setArgIndex       (int);
      void setDataFileName   (const char *);
      void setDataFileLineNo (int);
      void setErrorPeriod    (WitPeriod);

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void idInput ();
         //
         // Identifies the input state of the API for certain error messages.

      inline WitPeriod & errorPeriod ()
         {
         return errorPeriod_;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitInputId);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitApiMgr * const myApiMgr_;
         //
         // The ApiMgr that owns this InputId.

      //------------------------------------------------------------------------
      // Data identifying the input state.
      //------------------------------------------------------------------------

      WitAttr        myAttr_;
      WitPart *      myPart_;
      WitOperation * myOperation_;
      WitDemand *    myDemand_;
      WitBomEntry *  myBomEnt_;
      WitSubEntry *  mySub_;
      WitBopEntry *  myBopEnt_;
      const char *   argName_;
      int            argIndex_;
      const char *   dataFileName_;
      int            dataFileLineNo_;
      WitPeriod      errorPeriod_;
   };

//------------------------------------------------------------------------------
// Struct AbortApiExc
//
// "Abort API Exception"
// Exceptions of this type are caught at the end of the API function that was
// called by the application program and cause it either to return execution to
// the application program or throw an ErrorExc.
//------------------------------------------------------------------------------

struct WitAbortApiExc
   {
   bool byException_;
      //
      // True, iff the API function is to throw an ErrorExc.
   };

//------------------------------------------------------------------------------
@


1.32
log
@[exceptions]
@
text
@d29 1
a29 1
// Contains the declaration of struct ReturnToAppExc.
a66 1
      accessFunc (bool,              throwExcOnError)
d70 1
a70 1
      accessFunc (bool,              returningToApp)
d76 1
a76 2
      void setThrowExcOnError (bool);
      void setApiMode         (bool);
d96 1
a96 1
      void handleReturnToAppExc ();
d98 1
a98 1
         // Handles a "return to application" exception.
d112 1
a112 1
      void returnToApp ();
d114 3
a116 1
         // Returns execution to the application program.
a170 5
      bool throwExcOnError_;
         //
         // true, iff API functions are to throw an exception when an error
         // condition is encountered.

d219 1
a219 1
      bool returningToApp_;
d221 1
a221 1
         // true, iff returnToApp has been called.
d265 1
a265 1
   catch (WitReturnToAppExc)                                                   \
d267 1
a267 1
      myApiMgr_->handleReturnToAppExc ();                                      \
d361 1
a361 1
// Struct ReturnToAppExc
d363 4
a366 3
// Throwing an exception of this type causes WIT to conclude the API function
// that was called by the application program and return execution to the
// application program.
d369 1
a369 1
struct WitReturnToAppExc
d371 3
@


1.31
log
@[exceptions]
@
text
@d153 2
@


1.30
log
@[exceptions]
@
text
@d29 1
a29 1
// Contains the declaration of struct RetToCallerExc.
d67 1
a67 1
      accessFunc (bool,              throwOnErrors)
d71 1
a71 1
      accessFunc (bool,              directRetCalled)
d77 2
a78 2
      void setThrowOnErrors (bool);
      void setApiMode       (bool);
d98 1
a98 1
      void handleRetToCallerExc ();
d100 1
a100 1
         // Handles a "return to caller" exception.
d114 1
a114 1
      void directlyReturnToCaller ();
d116 1
a116 1
         // Update state when exiting an api function
d169 1
a169 1
      bool throwOnErrors_;
d172 1
a172 1
         // occurs and the program is not terminate.
d222 1
a222 1
      bool directRetCalled_;
d224 1
a224 1
         // true, iff directlyReturnToCaller has ever been called.
d268 1
a268 1
   catch (WitRetToCallerExc)                                                   \
d270 1
a270 1
      myApiMgr_->handleRetToCallerExc ();                                      \
d364 1
a364 1
// Struct RetToCallerExc
d371 1
a371 1
struct WitRetToCallerExc
@


1.29
log
@[exceptions]
@
text
@d67 1
d77 2
a78 1
      void setApiMode (bool);
d98 1
a98 4
      inline bool epilogAppCalled () const
         {
         return (apiDepth_ == 0);
         }
d100 1
a100 4
         // This function is intended to only be used by the EPILOG macro.
         // Returns true if current api function was invoked by
         // the application program.  Returns false if current api
         // function was invoked by an api function.
d169 5
d239 1
a239 1
      myApiMgr ()->enteringApiFunction (funcName, false);                      \
d247 1
a247 1
      myApiMgr ()->enteringApiFunction (funcName, true);                       \
d264 1
a264 1
      myApiMgr ()->leavingApiFunction ();                                      \
d270 1
a270 4
      myApiMgr ()->leavingApiFunction ();                                      \
                                                                               \
      if (not myApiMgr ()->epilogAppCalled ())                                 \
         throw;                                                                \
d273 1
a273 1
   return myApiMgr ()->apiRc ();                                               \
@


1.28
log
@[exceptions]
@
text
@d28 2
d267 1
a267 1
   catch (...)                                                                 \
d366 12
@


1.27
log
@[exceptions]
@
text
@d186 5
a224 1
// INNER_PROLOG: Implementation of PROLOG and QUIET_PROLOG.
d228 1
a228 1
// The arguments are passed to enteringApiFunction.
d232 1
a232 7
#define INNER_PROLOG(funcName,quiet)                                           \
                                                                               \
      /* Save new error handler and set to use WIT new error handler */        \
      /*                                                             */        \
   void (* prologSaveNewHandler) ();                                           \
                                                                               \
   prologSaveNewHandler = WitNonClass::set_new_handler (newError);             \
d236 1
a236 1
      myApiMgr ()->enteringApiFunction (funcName, quiet);                      \
a238 4
                                                                               
#define PROLOG(funcName)                                                       \
                                                                               \
   INNER_PROLOG (funcName, false);                                             \
d242 5
a246 1
   INNER_PROLOG (funcName, true);                                              \
a272 2
   WitNonClass::set_new_handler (prologSaveNewHandler);                        \
                                                                               \
@


1.26
log
@Removed #define TRY_THROW_CATCH_NOT_SUPPORTED.
@
text
@d65 1
d67 1
d74 3
a76 1
      inline bool apiMode () const { return witApi_; };
d78 2
a79 3
         // Returns True if in api mode, otherwise False & in standalone mode.

      inline void setApiMode (const bool b) { witApi_=b; };
d81 3
a83 1
         // Set value of api mode flag.
d94 1
a94 1
      inline bool applicationCalled (const char * const) const
d99 1
a99 1
         // This function is intended to only be used by the PROLOG macro.
a111 22
      inline WitReturnCode getApiRc () const { return apiRc_; };
         //
         // Get api return code

      void enteringApiFunction (
         const char * const name,     // Name of api function.
         const bool quiet );          // True if informational messages
                                      // to be surpressed.

      void allowInternalApiMethodUse ();
         //
         // Permits the call of API internal methods.  The meaning of
         // internal method here, is a method which skips (or avoids)
         // the use of the PROLOG and EPILOG macros.  This is done
         // for performance reasons.  witReadData makes use of this
         // facility.  A call to noLongerAllowApiInternalMethodUse() should
         // follow a call to this method.

      void noLongerAllowInternalApiMethodUse ();
         //
         // This method is paired with allowApiInternalMethodUse().

d171 1
a171 1
      bool witApi_;
d220 3
a222 3
// PROLOG  Generates code required at beginning of user callable routine.
//
// SHORT_PROLOG optionaly issues message witFuncCalled.
d224 1
a224 2
// s    - name of function
// disp - true if witFuncCalled message to be issued.
d228 1
a228 1
#define SHORT_PROLOG(s,disp)                                                   \
d238 1
a238 1
      myApiMgr ()->enteringApiFunction (s, not disp);                          \
d242 7
a248 1
#define PROLOG(s)  SHORT_PROLOG(s,true);
d271 1
a271 1
      if (not myApiMgr ()->applicationCalled ("EPILOG"))                       \
d277 1
a277 1
   return myApiMgr ()->getApiRc ();                                            \
@


1.25
log
@Vector PropRtg.
@
text
@a18 6
#ifdef TRY_THROW_CATCH_NOT_SUPPORTED

#  include <setjmp.h>

#endif

a43 7
#ifdef TRY_THROW_CATCH_NOT_SUPPORTED

      jmp_buf apiEntryEnv;
         //
         // setjump return value.
#endif

a245 23
#ifdef TRY_THROW_CATCH_NOT_SUPPORTED

#define SHORT_PROLOG(s,disp)                                                   \
                                                                               \
   WitReturnCode prologRc;                                                     \
                                                                               \
   /* Save new error handler and set to use WIT new error handler */           \
   void (*prologSaveNewHandler)() =                                            \
      WitNonClass::set_new_handler (newError);                                 \
   if ( myApiMgr ()->applicationCalled("PROLOG") ) {                           \
      prologRc = setjmp(myApiMgr ()->apiEntryEnv);                             \
      if ( prologRc != WitINFORMATIONAL_RC ) {                                 \
         /* Long jump issued. Return to api caller */                          \
         WitNonClass::set_new_handler ( prologSaveNewHandler );                \
                                                                               \
         return prologRc;                                                      \
      }                                                                        \
   }                                                                           \
   myApiMgr ()->enteringApiFunction(s,!disp);                                  \
      {                                                                        \

#else

a259 2
#endif

a261 1

a266 16
#ifdef TRY_THROW_CATCH_NOT_SUPPORTED

    // Return to calling function.  Only get here on non-severe return codes
    // when not directly returning to calling program.  Direct returns are
    // made by a long jump to the prolog code.
    //
#   define EPILOG                                                              \
                                                                               \
         }                                                                     \
      myApiMgr ()->leavingApiFunction();                                       \
      WitNonClass::set_new_handler ( prologSaveNewHandler );                   \
                                                                               \
      return myApiMgr ()->getApiRc()                                           \

#else

d271 1
a271 1
#  define EPILOG                                                               \
d287 1
a287 1
   WitNonClass::set_new_handler ( prologSaveNewHandler );                      \
a290 2
#endif

@


1.24
log
@Fixed a bug in the ApiCall dtor in mesgStopRunning = false mode.
@
text
@d150 4
d156 1
a156 2
         // Asserts that the temp vectors are not currently reserved,
         // reserves them, makes tempIntVec the right size, and returns it.
@


1.23
log
@Added a test for an API function call after a severe or fatal condition.
@
text
@d79 1
d240 4
d281 12
a292 7
   /* Save new error handler and set to use WIT new error handler */           \
   void (*prologSaveNewHandler)() =                                            \
      WitNonClass::set_new_handler (newError);                                 \
   try {                                                                       \
       myApiMgr ()->enteringApiFunction(s,!disp);                              \
          {                                                                    \

d326 3
a328 1
      myApiMgr ()->leavingApiFunction();                                       \
d330 7
a336 3
      catch ( ... ) {                                                          \
         myApiMgr ()->leavingApiFunction();                                    \
         if ( !myApiMgr ()->applicationCalled("EPILOG") )  throw;              \
a337 1
      WitNonClass::set_new_handler ( prologSaveNewHandler );                   \
d339 3
a341 1
      return myApiMgr ()->getApiRc()                                           \
@


1.22
log
@Double Precision.
@
text
@d15 1
d234 5
@


1.21
log
@Double Precision.
@
text
@a152 5
      WitTVec <float> & reserveTempFltVec ();
         //
         // Asserts that the temp vectors are not currently reserved,
         // reserves them, makes tempFltVec the right size, and returns it.

a222 5
         // functions.

      WitTVec <float> tempFltVec_;
         //
         // Temporary float vector to be used by some API "set" compatibility
@


1.20
log
@Double Precision.
@
text
@d153 1
a153 1
      WitTVec <float> & reserveTempFloatVec ();
d156 6
a161 1
         // reserves them, makes tempFloatVec the right size, and returns it.
d230 1
a230 1
      WitTVec <float> tempFloatVec_;
d233 5
@


1.19
log
@Double Precision.
@
text
@d410 12
@


1.18
log
@Continued double precision.
@
text
@d249 1
a249 4
   WitReturnCode    prologRc;                                                  \
   WitMsgFacility * prevMsgFacPtr;                                             \
                                                                               \
   prevMsgFacPtr = myMsgFac ().becomesCurrent ();                              \
d256 1
a256 1
+     if ( prologRc != WitINFORMATIONAL_RC ) {                                 \
a259 2
         WitMsgFacility::setCurrentPtr (prevMsgFacPtr);                        \
                                                                               \
a269 4
   WitMsgFacility * prevMsgFacPtr;                                             \
                                                                               \
   prevMsgFacPtr = myMsgFac ().becomesCurrent ();                              \
                                                                               \
a298 2
      WitMsgFacility::setCurrentPtr (prevMsgFacPtr);                           \
                                                                               \
a316 2
                                                                               \
      WitMsgFacility::setCurrentPtr (prevMsgFacPtr);                           \
@


1.17
log
@Continued double precision.
@
text
@a179 4
      void checkDblMode (bool theValue);
         //
         // Verifies that the doubleMode attribute == theValue.

@


1.16
log
@Continued double precision.
@
text
@d182 1
a182 1
         // Verifies that the doublePrecision attribute == theValue.
@


1.15
log
@Continued implementation of PIP.
@
text
@d175 9
d263 1
a263 1
      if ( prologRc != WitINFORMATIONAL_RC ) {                                 \
@


1.14
log
@An attempt to fix some syntax errors on Windows.
@
text
@d251 1
a251 1
      WitUtil::set_new_handler (newError);                                     \
d256 1
a256 1
         WitUtil::set_new_handler ( prologSaveNewHandler );                    \
d276 1
a276 1
      WitUtil::set_new_handler (newError);                                     \
d301 1
a301 1
      WitUtil::set_new_handler ( prologSaveNewHandler );                       \
d322 1
a322 1
      WitUtil::set_new_handler ( prologSaveNewHandler );                       \
@


1.13
log
@Continued implementation of PIP.
@
text
@d251 1
a251 1
      set_new_handler (newError);                                              \
d256 1
a256 1
         set_new_handler ( prologSaveNewHandler );                             \
d276 1
a276 1
      set_new_handler (newError);                                              \
d301 1
a301 1
      set_new_handler ( prologSaveNewHandler );                                \
d322 1
a322 1
      set_new_handler ( prologSaveNewHandler );                                \
@


1.12
log
@Made changes to eliminate some of the compiler warnings on Linux.
@
text
@d41 1
a41 1
class WitApiMgr: public WitUtil
d336 1
a336 1
class WitInputId: public WitUtil
@


1.11
log
@Internal changes.
@
text
@d16 1
a16 1
#include <new.h>
@


1.10
log
@Continued implementation of Single-Source.
@
text
@d83 1
a83 1
      inline WitBoolean apiMode () const { return witApi_; };
d87 1
a87 1
      inline void setApiMode (const WitBoolean b) { witApi_=b; };
d91 1
a91 1
      inline WitBoolean applicationCalled () const
d100 1
a100 1
      inline WitBoolean applicationCalled (const char * const) const
d124 1
a124 1
         const WitBoolean quiet );    // True if informational messages
d191 1
a191 1
      WitBoolean witApi_;
d225 1
a225 1
      WitBoolean tempVecsReserved_;
d227 1
a227 1
         // TRUE, iff the temp vectors are currently reserved.
d236 1
a236 1
// disp - TRUE if witFuncCalled message to be issued.
d283 1
a283 1
#define PROLOG(s)  SHORT_PROLOG(s,witTRUE);
@


1.9
log
@Continued implementation of single-source.
@
text
@d13 1
d215 1
a215 1
      WitTVec <int> & tempIntVec_;
d220 1
a220 1
      WitTVec <float> & tempFloatVec_;
@


1.8
log
@Continued preliminary work on single source.
@
text
@d13 1
a13 1
#include <Util.h>
d201 1
a201 1
      WitString & apiFuncName_;
@


1.7
log
@Continued implementation of object iteration.
@
text
@d147 1
a147 1
      WitTVec (int) & reserveTempIntVec ();
d152 1
a152 1
      WitTVec (float) & reserveTempFloatVec ();
d214 1
a214 1
      WitTVec (int) & tempIntVec_;
d219 1
a219 1
      WitTVec (float) & tempFloatVec_;
@


1.6
log
@Continued development of selection splitting for multi=exec.
@
text
@a13 1
#include <wit.h>
@


1.5
log
@Refactoring for selection splitting.
@
text
@d408 3
a410 3
      WitBomEntry *  myBomEntry_;
      WitSubEntry *  mySubEntry_;
      WitBopEntry *  myBopEntry_;
@


1.4
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d169 1
a169 3
      copyCtorAndAssignment (WitApiMgr);
         //
         // Prevents unintentional copying and assignment.
d390 1
a390 3
      copyCtorAndAssignment (WitInputId);
         //
         // Prevents unintentional copying and assignment.
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d50 1
a126 1

d148 6
a153 1
      WitTVec (int) & useTempVec ();
d155 2
a156 2
         // Asserts that tempVec is not in use, indicates that it is in use,
         // makes it the right size, and returns it.
d158 1
a158 1
      void releaseTempVec ();
d160 2
a161 1
         // Asserts that tempVec is in use, and then indicates that it is not.
d217 1
a217 1
      WitTVec (int) & tempVec_;
d222 6
a227 1
      WitBoolean tempVecInUse_;
d229 1
a229 1
         // TRUE, when tempVec is being used.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d13 1
a13 1
#include <typedefs.h>
a15 1

d41 1
a41 1
class WitApiMgr
d242 1
a242 1
      WitUtil::set_new_handler (WitUtil::newError);                            \
d247 1
a247 1
         WitUtil::set_new_handler ( prologSaveNewHandler );                    \
d267 1
a267 1
      WitUtil::set_new_handler (WitUtil::newError);                            \
d292 1
a292 1
      WitUtil::set_new_handler ( prologSaveNewHandler );                       \
d313 1
a313 1
      WitUtil::set_new_handler ( prologSaveNewHandler );                       \
d327 1
a327 1
class WitInputId
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.65;
access;
symbols
	sce_5_01_20080919:1.61;
locks; strict;
comment	@ * @;


1.65
date	2011.09.28.23.50.08;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2011.09.24.00.28.34;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2011.08.30.20.18.08;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2011.01.19.00.20.54;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2008.01.25.00.19.22;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2008.01.21.21.47.17;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.26.23.58.00;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.04.00.07.15;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.03.19.41.34;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.29.21.12.32;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.28.23.23.48;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.28.20.34.28;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.22.19.20.37;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.08.18.56.36;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.02.18.32.44;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.01.19.52.16;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.01.19.02.07;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.28.23.32.58;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.28.22.08.26;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.27.18.25.10;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.26.22.52.52;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.26.20.54.40;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.26.16.06.39;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.26.14.36.17;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.25.21.03.04;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.21.23.06.08;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.21.17.47.13;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.20.22.17.57;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.20.20.58.25;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.20.18.46.16;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.19.22.57.49;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.19.21.35.41;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.19.17.41.35;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.18.18.43.14;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.17.21.46.32;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.17.18.31.59;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.17.14.37.38;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.14.22.38.32;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.14.21.13.58;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.14.15.44.41;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.13.15.23.19;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.12.23.55.00;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.12.23.09.00;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.12.21.55.00;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.11.18.09.17;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.10.21.01.35;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.29.16.24.23;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.28.17.38.35;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.24.21.12.38;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.17.22.32.24;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.16.21.27.41;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.15.21.36.42;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.14.21.20.19;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.14.15.03.01;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.09.20.45.05;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.08.20.18.12;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.01.21.28.05;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.24.22.17.32;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.27.14.52.53;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.21.18.49.19;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.21.18.25.43;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.20.23.02.37;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.20.22.10.26;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.20.19.38.51;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Scenario.C"
//
// Contains the implementation of the following classes:
//
//    ScenMgr
//    Scenario
//------------------------------------------------------------------------------

#include <ScenMgr.h>
#include <Scenario.h>
#include <ScenAttMgr.h>
#include <StochImpMgr.h>
#include <DataWrit.h>
#include <Post.h>
#include <PipMgr.h>
#include <wit/src/Variant.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class ScenMgr.
//------------------------------------------------------------------------------

WitScenMgr::WitScenMgr (WitStochModeMgr * theStochModeMgr):

      WitStochAssoc   (theStochModeMgr),
      myStochModeMgr_ (theStochModeMgr),
      nScenarios_     (myStochImpMgr ()->nScenarios ()),
      myScenarios_    (),
      myScenarioFor_  (myStochImpMgr ()->nScenarios ()),
      curScenario_    (NULL),
      isWritingData_  (false)
   {
   int           theIdx;
   WitScenario * theScenario;

   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      {
      theScenario = new WitScenario (myProblem (), theIdx);

      myScenarios_.append (theScenario);

      myScenarioFor_[theIdx] = theScenario;
      }

   curScenario_ = myScenarioFor_[0];
   }

//------------------------------------------------------------------------------

WitScenMgr::~WitScenMgr ()
   {
   int theIdx;

   curScenario_ = NULL;

   myScenarioFor_.clear ();

   while (not myScenarios_.isEmpty ())
      delete myScenarios_.get ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::copyAttrsFrom (WitScenMgr * theScenMgr)
   {
   int           theIdx;
   WitScenario * dupScenario;
   WitScenario * origScenario;

   theIdx        = theScenMgr->curScenario_->myIndex ();

   curScenario_  = myScenarioFor_[theIdx];

   forEachEl (dupScenario, myScenarios_)
      {
      theIdx       = dupScenario->myIndex ();

      origScenario = theScenMgr->myScenarioFor_[theIdx];

      dupScenario->copyAttrsFrom (origScenario);
      }
   }

//------------------------------------------------------------------------------

void WitScenMgr::writeUndiffData ()
   {
   if (not stochSolnMode ())
      myScenAttMgr ()->downloadInput ();

   myMsgFac () ("undiffScenSpecWdMsg");

   isWritingData_ = true;

   myScenAttMgr ()->writeCompData     (curScenario_, false);
   myScenAttMgr ()->writeBoundSetData (curScenario_, false);

   isWritingData_ = false;
   }

//------------------------------------------------------------------------------

void WitScenMgr::writeDiffData ()
   {
   WitScenario * theScenario;

   isWritingData_ = true;

   forEachEl (theScenario, myScenarios_)
      {
      theScenario->writeData ();

      myScenAttMgr ()->writeCompData     (theScenario, true);
      myScenAttMgr ()->writeBoundSetData (theScenario, true);
      }

   myMsgFac () ("finalScenIdxWdMsg");

   curScenario_->writeMyIndex ();

   isWritingData_ = false;
   }

//------------------------------------------------------------------------------

void WitScenMgr::displayGlobalData ()
   {
   myMsgFac () ("stochImploderDdMsg", curScenario_->myIndex ());
   }

//------------------------------------------------------------------------------

void WitScenMgr::displayData ()
   {
   WitScenario * origScenario;

   if (not stochSolnMode ())
      myScenAttMgr ()->downloadInput ();

   origScenario = curScenario_;

   forEachEl (curScenario_, myScenarios_)
      {
      myStochModeMgr ()->uploadInput ();

      myMsgFac () ("scenarioDdMsg",
         curScenario_->myIndex (),
         curScenario_->probability ());

      myProblem ()->displayNonGlobalData ();
      }

   curScenario_ = origScenario;

   myStochModeMgr ()->uploadInput ();
   }

//------------------------------------------------------------------------------

void WitScenMgr::validateData ()
   {
   double        totProb;
   WitScenario * theScenario;

   totProb = 0.0;

   forEachEl (theScenario, myScenarios_)
      totProb += theScenario->probability ();

   if (fabs (totProb - 1.0) > 0.001)
      myMsgFac () ("totScenProbNeq1Smsg", totProb);
   }

//------------------------------------------------------------------------------

void WitScenMgr::setCurScenario (WitScenario * theScenario)
   {
   witAssert (theScenario != NULL);

   if (not stochSolnMode ())
      myScenAttMgr ()->downloadInput ();

   myProblem ()->myPipMgr ()->clearShipSeq ();

   curScenario_ = theScenario;

   myStochModeMgr ()->uploadInput ();

   if (stochSolnMode ())
      {
      myStochModeMgr ()->uploadSoln ();

      myProblem ()->optVariant ()->becomesCurrent ();

      myPostprocessor ()->postprocess ();
      }
   }

//------------------------------------------------------------------------------
// Implementation of class Scenario.
//------------------------------------------------------------------------------

WitScenario::WitScenario (WitProblem * theProblem, int theIdx):

      WitProbAssoc (theProblem),
      myIndex_     (theIdx),
      probability_ (defProbability ())
   {
   }

//------------------------------------------------------------------------------

WitScenario::~WitScenario ()
   {
   }

//------------------------------------------------------------------------------

void WitScenario::copyAttrsFrom (WitScenario * thatScenario)
   {
   probability_ = thatScenario->probability_;
   }

//------------------------------------------------------------------------------

void WitScenario::writeData ()
   {
   myMsgFac () ("scenarioHeadingWdMsg", myIndex_);

   writeMyIndex ();

   writeProbability ();
   }

//------------------------------------------------------------------------------

void WitScenario::writeMyIndex ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

   myDataWriter ()->writeInt ("currentScenario", myIndex_);

   myDataWriter ()->writeEndCommand ();
   }

//------------------------------------------------------------------------------

double WitScenario::defProbability ()
   {
   return 1.0 / static_cast <double> (myStochImpMgr ()->nScenarios ());
   }

//------------------------------------------------------------------------------

void WitScenario::setProbability (double theValue)
   {
   stronglyAssert (theValue >= 0.0);
   stronglyAssert (theValue <= 1.0 + FEAS_TOL);

   myProblem ()->prepSetStochModeAttr ("probability");

   probability_ = theValue;
   }

//------------------------------------------------------------------------------

int WitScenario::nInstances (WitProblem * theProblem)
   {
   return theProblem->myStochImpMgr ()->nScenarios ();
   }

//------------------------------------------------------------------------------

void WitScenario::writeProbability ()
   {
   if (probability_ == defProbability ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

   myDataWriter ()->writeDouble (
      "probability",
       probability_,
       defProbability ());

   myDataWriter ()->writeEndCommand ();
   }
@


1.64
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.63
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d35 14
a48 14
WitStochAssoc   (theStochModeMgr),
myStochModeMgr_ (theStochModeMgr),
nScenarios_     (myStochImpMgr ()->nScenarios ()),
myScenarios_    (),
myScenarioFor_  (myStochImpMgr ()->nScenarios ()),
curScenario_    (NULL),
isWritingData_  (false)
{
int           theIdx;
WitScenario * theScenario;

for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
{
theScenario = new WitScenario (myProblem (), theIdx);
d50 1
a50 1
myScenarios_.append (theScenario);
d52 2
a53 2
myScenarioFor_[theIdx] = theScenario;
}
d55 2
a56 2
curScenario_ = myScenarioFor_[0];
}
d61 2
a62 2
{
int theIdx;
d64 1
a64 1
curScenario_ = NULL;
d66 1
a66 1
myScenarioFor_.clear ();
d68 3
a70 3
while (not myScenarios_.isEmpty ())
delete myScenarios_.get ();
}
d75 4
a78 4
{
int           theIdx;
WitScenario * dupScenario;
WitScenario * origScenario;
d80 1
a80 1
theIdx        = theScenMgr->curScenario_->myIndex ();
d82 1
a82 1
curScenario_  = myScenarioFor_[theIdx];
d84 3
a86 3
forEachEl (dupScenario, myScenarios_)
{
theIdx       = dupScenario->myIndex ();
d88 1
a88 1
origScenario = theScenMgr->myScenarioFor_[theIdx];
d90 3
a92 3
dupScenario->copyAttrsFrom (origScenario);
}
}
d97 3
a99 3
{
if (not stochSolnMode ())
myScenAttMgr ()->downloadInput ();
d101 1
a101 1
myMsgFac () ("undiffScenSpecWdMsg");
d103 1
a103 1
isWritingData_ = true;
d105 2
a106 2
myScenAttMgr ()->writeCompData     (curScenario_, false);
myScenAttMgr ()->writeBoundSetData (curScenario_, false);
d108 2
a109 2
isWritingData_ = false;
}
d114 2
a115 2
{
WitScenario * theScenario;
d117 1
a117 1
isWritingData_ = true;
d119 3
a121 3
forEachEl (theScenario, myScenarios_)
{
theScenario->writeData ();
d123 3
a125 3
myScenAttMgr ()->writeCompData     (theScenario, true);
myScenAttMgr ()->writeBoundSetData (theScenario, true);
}
d127 1
a127 1
myMsgFac () ("finalScenIdxWdMsg");
d129 1
a129 1
curScenario_->writeMyIndex ();
d131 2
a132 2
isWritingData_ = false;
}
d137 3
a139 3
{
myMsgFac () ("stochImploderDdMsg", curScenario_->myIndex ());
}
d144 2
a145 2
{
WitScenario * origScenario;
d147 2
a148 2
if (not stochSolnMode ())
myScenAttMgr ()->downloadInput ();
d150 1
a150 1
origScenario = curScenario_;
d152 3
a154 3
forEachEl (curScenario_, myScenarios_)
{
myStochModeMgr ()->uploadInput ();
d156 3
a158 3
myMsgFac () ("scenarioDdMsg",
curScenario_->myIndex (),
curScenario_->probability ());
d160 2
a161 2
myProblem ()->displayNonGlobalData ();
}
d163 1
a163 1
curScenario_ = origScenario;
d165 2
a166 2
myStochModeMgr ()->uploadInput ();
}
d171 12
a182 12
{
double        totProb;
WitScenario * theScenario;

totProb = 0.0;

forEachEl (theScenario, myScenarios_)
totProb += theScenario->probability ();

if (fabs (totProb - 1.0) > 0.001)
myMsgFac () ("totScenProbNeq1Smsg", totProb);
}
d187 2
a188 2
{
witAssert (theScenario != NULL);
d190 2
a191 2
if (not stochSolnMode ())
myScenAttMgr ()->downloadInput ();
d193 1
a193 1
myProblem ()->myPipMgr ()->clearShipSeq ();
d195 1
a195 1
curScenario_ = theScenario;
d197 1
a197 1
myStochModeMgr ()->uploadInput ();
d199 3
a201 3
if (stochSolnMode ())
{
myStochModeMgr ()->uploadSoln ();
d203 1
a203 1
myProblem ()->optVariant ()->becomesCurrent ();
d205 3
a207 3
myPostprocessor ()->postprocess ();
}
}
d215 5
a219 5
WitProbAssoc (theProblem),
myIndex_     (theIdx),
probability_ (defProbability ())
{
}
d224 2
a225 2
{
}
d230 3
a232 3
{
probability_ = thatScenario->probability_;
}
d237 2
a238 2
{
myMsgFac () ("scenarioHeadingWdMsg", myIndex_);
d240 1
a240 1
writeMyIndex ();
d242 2
a243 2
writeProbability ();
}
d248 3
a250 3
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("problem");
d252 1
a252 1
myDataWriter ()->writeInt ("currentScenario", myIndex_);
d254 2
a255 2
myDataWriter ()->writeEndCommand ();
}
d260 3
a262 3
{
return 1.0 / static_cast <double> (myStochImpMgr ()->nScenarios ());
}
d267 3
a269 3
{
stronglyAssert (theValue >= 0.0);
stronglyAssert (theValue <= 1.0 + FEAS_TOL);
d271 1
a271 1
myProblem ()->prepSetStochModeAttr ("probability");
d273 2
a274 2
probability_ = theValue;
}
d279 3
a281 3
{
return theProblem->myStochImpMgr ()->nScenarios ();
}
d286 11
a296 11
{
if (probability_ == defProbability ())
return;

myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("problem");

myDataWriter ()->writeDouble (
"probability",
probability_,
defProbability ());
d298 2
a299 2
myDataWriter ()->writeEndCommand ();
}
@


1.62
log
@CPLEX Parameters
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d35 14
a48 14
      WitStochAssoc   (theStochModeMgr),
      myStochModeMgr_ (theStochModeMgr),
      nScenarios_     (myStochImpMgr ()->nScenarios ()),
      myScenarios_    (),
      myScenarioFor_  (myStochImpMgr ()->nScenarios ()),
      curScenario_    (NULL),
      isWritingData_  (false)
   {
   int           theIdx;
   WitScenario * theScenario;

   for (theIdx = 0; theIdx < nScenarios_; theIdx ++)
      {
      theScenario = new WitScenario (myProblem (), theIdx);
d50 1
a50 1
      myScenarios_.append (theScenario);
d52 2
a53 2
      myScenarioFor_[theIdx] = theScenario;
      }
d55 2
a56 2
   curScenario_ = myScenarioFor_[0];
   }
d61 2
a62 2
   {
   int theIdx;
d64 1
a64 1
   curScenario_ = NULL;
d66 1
a66 1
   myScenarioFor_.clear ();
d68 3
a70 3
   while (not myScenarios_.isEmpty ())
      delete myScenarios_.get ();
   }
d75 4
a78 4
   {
   int           theIdx;
   WitScenario * dupScenario;
   WitScenario * origScenario;
d80 1
a80 1
   theIdx        = theScenMgr->curScenario_->myIndex ();
d82 1
a82 1
   curScenario_  = myScenarioFor_[theIdx];
d84 3
a86 3
   forEachEl (dupScenario, myScenarios_)
      {
      theIdx       = dupScenario->myIndex ();
d88 1
a88 1
      origScenario = theScenMgr->myScenarioFor_[theIdx];
d90 3
a92 3
      dupScenario->copyAttrsFrom (origScenario);
      }
   }
d97 3
a99 3
   {
   if (not stochSolnMode ())
      myScenAttMgr ()->downloadInput ();
d101 1
a101 1
   myMsgFac () ("undiffScenSpecWdMsg");
d103 1
a103 1
   isWritingData_ = true;
d105 2
a106 2
   myScenAttMgr ()->writeCompData     (curScenario_, false);
   myScenAttMgr ()->writeBoundSetData (curScenario_, false);
d108 2
a109 2
   isWritingData_ = false;
   }
d114 2
a115 2
   {
   WitScenario * theScenario;
d117 1
a117 1
   isWritingData_ = true;
d119 3
a121 3
   forEachEl (theScenario, myScenarios_)
      {
      theScenario->writeData ();
d123 3
a125 3
      myScenAttMgr ()->writeCompData     (theScenario, true);
      myScenAttMgr ()->writeBoundSetData (theScenario, true);
      }
d127 1
a127 1
   myMsgFac () ("finalScenIdxWdMsg");
d129 1
a129 1
   curScenario_->writeMyIndex ();
d131 2
a132 2
   isWritingData_ = false;
   }
d137 3
a139 3
   {
   myMsgFac () ("stochImploderDdMsg", curScenario_->myIndex ());
   }
d144 2
a145 2
   {
   WitScenario * origScenario;
d147 2
a148 2
   if (not stochSolnMode ())
      myScenAttMgr ()->downloadInput ();
d150 1
a150 1
   origScenario = curScenario_;
d152 3
a154 3
   forEachEl (curScenario_, myScenarios_)
      {
      myStochModeMgr ()->uploadInput ();
d156 3
a158 3
      myMsgFac () ("scenarioDdMsg",
         curScenario_->myIndex (),
         curScenario_->probability ());
d160 2
a161 2
      myProblem ()->displayNonGlobalData ();
      }
d163 1
a163 1
   curScenario_ = origScenario;
d165 2
a166 2
   myStochModeMgr ()->uploadInput ();
   }
d171 12
a182 12
   {
   double        totProb;
   WitScenario * theScenario;

   totProb = 0.0;

   forEachEl (theScenario, myScenarios_)
      totProb += theScenario->probability ();

   if (fabs (totProb - 1.0) > 0.001)
      myMsgFac () ("totScenProbNeq1Smsg", totProb);
   }
d187 2
a188 2
   {
   witAssert (theScenario != NULL);
d190 2
a191 2
   if (not stochSolnMode ())
      myScenAttMgr ()->downloadInput ();
d193 1
a193 1
   myProblem ()->myPipMgr ()->clearShipSeq ();
d195 1
a195 1
   curScenario_ = theScenario;
d197 1
a197 1
   myStochModeMgr ()->uploadInput ();
d199 3
a201 3
   if (stochSolnMode ())
      {
      myStochModeMgr ()->uploadSoln ();
d203 1
a203 1
      myProblem ()->optVariant ()->becomesCurrent ();
d205 3
a207 3
      myPostprocessor ()->postprocess ();
      }
   }
d215 5
a219 5
      WitProbAssoc (theProblem),
      myIndex_     (theIdx),
      probability_ (defProbability ())
   {
   }
d224 2
a225 2
   {
   }
d230 3
a232 3
   {
   probability_ = thatScenario->probability_;
   }
d237 2
a238 2
   {
   myMsgFac () ("scenarioHeadingWdMsg", myIndex_);
d240 1
a240 1
   writeMyIndex ();
d242 2
a243 2
   writeProbability ();
   }
d248 3
a250 3
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
d252 1
a252 1
   myDataWriter ()->writeInt ("currentScenario", myIndex_);
d254 2
a255 2
   myDataWriter ()->writeEndCommand ();
   }
d260 3
a262 3
   {
   return 1.0 / static_cast <double> (myStochImpMgr ()->nScenarios ());
   }
d267 3
a269 3
   {
   stronglyAssert (theValue >= 0.0);
   stronglyAssert (theValue <= 1.0 + FEAS_TOL);
d271 1
a271 1
   myProblem ()->prepSetStochModeAttr ("probability");
d273 2
a274 2
   probability_ = theValue;
   }
d279 3
a281 3
   {
   return theProblem->myStochImpMgr ()->nScenarios ();
   }
d286 11
a296 11
   {
   if (probability_ == defProbability ())
      return;

   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");

   myDataWriter ()->writeDouble (
      "probability",
       probability_,
       defProbability ());
d298 2
a299 2
   myDataWriter ()->writeEndCommand ();
   }
@


1.61
log
@Stochastic Implosion
@
text
@d252 1
a252 4
   myDataWriter ()->writeDouble (
      "currentScenario",
       myIndex_,
       -1);
@


1.60
log
@Stochastic Implosion
@
text
@a20 1
#include <StochModeMgr.h>
d35 1
a35 1
      WitProbAssoc    (theStochModeMgr),
d48 1
a48 1
      theScenario = new WitScenario (this, theIdx);
d98 2
a99 2
   if (not myStochModeMgr_->stochSolnMode ())
      myStochModeMgr_->myScenAttMgr ()->downloadInput ();
d105 2
a106 2
   myStochModeMgr_->myScenAttMgr ()->writeCompData     (curScenario_, false);
   myStochModeMgr_->myScenAttMgr ()->writeBoundSetData (curScenario_, false);
d123 2
a124 2
      myStochModeMgr_->myScenAttMgr ()->writeCompData     (theScenario, true);
      myStochModeMgr_->myScenAttMgr ()->writeBoundSetData (theScenario, true);
d147 2
a148 2
   if (not myStochModeMgr_->stochSolnMode ())
      myStochModeMgr_->myScenAttMgr ()->downloadInput ();
d154 1
a154 1
      myStochModeMgr_->uploadInput ();
d165 1
a165 1
   myStochModeMgr_->uploadInput ();
d190 2
a191 2
   if (not myStochModeMgr_->stochSolnMode ())
      myStochModeMgr_->myScenAttMgr ()->downloadInput ();
d197 1
a197 1
   myStochModeMgr_->uploadInput ();
d199 1
a199 1
   if (myStochModeMgr_->stochSolnMode ())
d201 1
a201 1
      myStochModeMgr_->uploadSoln ();
d213 1
a213 1
WitScenario::WitScenario (WitScenMgr * theScenMgr, int theIdx):
d215 3
a217 4
      WitProbAssoc  (theScenMgr),
      myScenMgr_    (theScenMgr),
      myIndex_      (theIdx),
      probability_  (defProbability ())
@


1.59
log
@Stochastic Implosion
@
text
@d255 1
a255 1
      "curScenarioIndex",
@


1.58
log
@Stochastic Implosion
@
text
@d26 1
d193 3
a195 1
                                  
@


1.57
log
@Stochastic Implosion
@
text
@d96 1
a96 1
void WitScenMgr::writeStage0Data ()
d101 1
a101 1
   myMsgFac () ("stage0CommentWdMsg");
d105 2
a106 2
   myStochModeMgr_->myScenAttMgr ()->writeCompData     (curScenario_, 0);
   myStochModeMgr_->myScenAttMgr ()->writeBoundSetData (curScenario_, 0);
d113 1
a113 1
void WitScenMgr::writeStage1Data ()
d123 2
a124 2
      myStochModeMgr_->myScenAttMgr ()->writeCompData     (theScenario, 1);
      myStochModeMgr_->myScenAttMgr ()->writeBoundSetData (theScenario, 1);
@


1.56
log
@Stochastic Implosion
@
text
@d273 1
a273 1
   myStochImpMgr ()->prepSetStochModeAttr ("probability");
@


1.55
log
@Stochastic Implosion
@
text
@d273 1
a273 1
   myProblem ()->prepSetStochModeAttr ("probability");
@


1.54
log
@Stochastic Implosion
@
text
@d105 2
a106 1
   myStochModeMgr_->myScenAttMgr ()->writeData (curScenario_, 0);
d123 2
a124 1
      myStochModeMgr_->myScenAttMgr ()->writeData (theScenario, 1);
@


1.53
log
@Stochastic Implosion
@
text
@d96 17
a112 1
void WitScenMgr::writeData ()
a117 3
   if (not myStochModeMgr_->stochSolnMode ())
      myStochModeMgr_->myScenAttMgr ()->downloadInput ();

d122 1
a122 1
      myStochModeMgr_->myScenAttMgr ()->writeData (theScenario);
@


1.52
log
@Stochastic Implosion
@
text
@d237 1
a237 1
      "curScenarioNo",
@


1.51
log
@Stochastic Implosion
@
text
@d13 1
a13 1
// Contains the implementation of the following classes and templates:
a16 5
//    AbsScenInputAtt
//    ScenInputAtt <Owner>
//    AbsScenSolnAtt
//    ScenSolnAtt  <Owner>
//    ScenAtt      <Owner>
a20 3
#include <ScenInputAtt.h>
#include <ScenSolnAtt.h>
#include <ScenAtt.h>
d22 1
a23 3
#include <StochAttMgr.h>
#include <StageMgr.h>
#include <StochOptMgr.h>
a26 6
#include <CompMgr.h>
#include <Material.h>
#include <Demand.h>
#include <Opn.h>
#include <SubEntry.h>
#include <BoundSet.h>
d41 1
a41 5
      isWritingData_  (false),
      allMats_        (),
      allDemands_     (),
      allSubs_        (),
      allBoundSets_   ()
a45 2
   listOwners ();

d103 1
a103 1
      curScenario_->downloadInput ();
d106 1
d109 3
d133 1
a133 1
      curScenario_->downloadInput ();
d157 2
a158 2
   WitScenario * theScenarioA;
   WitScenario * theScenarioB;
d160 1
a160 1
   checkProbabilities ();
d162 2
a163 1
   theScenarioA = myScenarios_.first ();
d165 2
a166 3
   forEachEl (theScenarioB, myScenarios_)
      if (theScenarioB != theScenarioA)
         theScenarioA->checkInputsInStage0 (theScenarioB);
d176 1
a176 1
      curScenario_->downloadInput ();
a192 44

void WitScenMgr::listOwners ()
   {
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitSubEntry *  theSub;
   WitOperation * theOpn;

   forEachMaterial (theMat, myProblem ())
      {
      allMats_.     append (theMat);
      allBoundSets_.append (theMat->stockBounds ());
      }

   forEachDemand   (theDemand, myProblem ())
      {
      allDemands_  .append (theDemand);
      allBoundSets_.append (theDemand->cumShipBounds ());
      }

   forEachSubEntry (theSub, myProblem ())
      allSubs_.   append (theSub);

   forEachOperation (theOpn, myProblem ())
      allBoundSets_.append (theOpn->execBounds ());
   }

//------------------------------------------------------------------------------

void WitScenMgr::checkProbabilities ()
   {
   double        totProb;
   WitScenario * theScenario;

   totProb = 0.0;

   forEachEl (theScenario, myScenarios_)
      totProb += theScenario->probability ();

   if (fabs (totProb - 1.0) > 0.001)
      myMsgFac () ("totScenProbNeq1Smsg", totProb);
   }

//------------------------------------------------------------------------------
d198 4
a201 21
      WitProbAssoc        (theScenMgr),
      myScenMgr_          (theScenMgr),
      myIndex_            (theIdx),
      probability_        (defProbability ()),
      myAbsScenInputAtts_ (),
      myAbsScenSolnAtts_  (),
      buildingInputAtts_  (false),
      buildingSolnAtts_   (false),

      supplyVol_          (NULL),
      demandVol_          (NULL),
      hardLB_             (NULL),
      softLB_             (NULL),
      hardUB_             (NULL),

      scrapVol_           (NULL),
      stockVol_           (NULL),
      shipVol_            (NULL),
      cumShipVol_         (NULL),
      execVol_            (NULL),
      subVol_             (NULL)
a202 2
   buildScenInputAtts ();
   buildScenSolnAtts  ();
a208 43
   while (not myAbsScenSolnAtts_.isEmpty ())
      delete myAbsScenSolnAtts_.get ();

   while (not myAbsScenInputAtts_.isEmpty ())
      delete myAbsScenInputAtts_.get ();
   }

//------------------------------------------------------------------------------

void WitScenario::store (WitAbsScenInputAtt * theInputAtt)
   {
   stronglyAssert (buildingInputAtts_);

   myAbsScenInputAtts_.append (theInputAtt);
   }

//------------------------------------------------------------------------------

void WitScenario::store (WitAbsScenSolnAtt * theSolnAtt)
   {
   stronglyAssert (buildingSolnAtts_);

   myAbsScenSolnAtts_.append (theSolnAtt);
   }

//------------------------------------------------------------------------------

void WitScenario::downloadInput ()
   {
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->downloadData ();
   }

//------------------------------------------------------------------------------

void WitScenario::uploadInput ()
   {
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->uploadData ();
a214 2
   WitAbsScenInputAtt * theInputAtt;

a215 23

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->copyDataFrom (thatScenario);
   }

//------------------------------------------------------------------------------

void WitScenario::uploadSoln ()
   {
   WitAbsScenSolnAtt * theSolnAtt;

   forEachEl (theSolnAtt, myAbsScenSolnAtts_)
      theSolnAtt->uploadData ();
   }

//------------------------------------------------------------------------------

void WitScenario::clearSoln ()
   {
   WitAbsScenSolnAtt * theSolnAtt;

   forEachEl (theSolnAtt, myAbsScenSolnAtts_)
      theSolnAtt->clearData ();
a221 5
   WitComponent *       theComp;
   WitBoundSet *        theBoundSet;
   bool                 attWritten;
   WitAbsScenInputAtt * theInputAtt;

a226 25

   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      attWritten = false;

      forEachEl (theInputAtt, myAbsScenInputAtts_)
         theInputAtt->writeData (theComp, attWritten);

      if (attWritten)
         myDataWriter ()->writeEndCommand ();
      }

   forEachEl (theBoundSet, myScenMgr ()->allBoundSets ())
      {
      attWritten = false;

      forEachEl (theInputAtt, myAbsScenInputAtts_)
         theInputAtt->writeData (theBoundSet, attWritten);

      if (attWritten)
         {
         myDataWriter ()->writeFirstKeyWord ("endBounds");
         myDataWriter ()->writeEndCommand ();
         }
      }
a245 10
void WitScenario::checkInputsInStage0 (WitScenario * thatScenario)
   {
   WitAbsScenInputAtt * theInputAtt;

   forEachEl (theInputAtt, myAbsScenInputAtts_)
      theInputAtt->checkValsInStage0 (thatScenario);
   }

//------------------------------------------------------------------------------

a271 88
void WitScenario::buildScenInputAtts ()
   {
   buildingInputAtts_ = true;

   supplyVol_ =
      new WitScenInputAtt     <WitPart> (this,
                                        "supplyVol",
                                WitPart::defSupplyVol (),
                              & WitPart::supplyVol,
                              & WitPart::storeStochSupplyVol,
                          & WitScenario::supplyVol);

   demandVol_ =
      new WitScenInputAtt   <WitDemand> (this,
                                        "demandVol",
                              WitDemand::defDemandVol (),
                            & WitDemand::demandVol,
                            & WitDemand::storeStochDemandVol,
                          & WitScenario::demandVol);

   hardLB_ =
      new WitScenInputAtt <WitBoundSet> (this,
                                        "hardLB",
                            WitBoundSet::defHardLB (),
                          & WitBoundSet::hardLB,
                          & WitBoundSet::storeStochHardLB,
                          & WitScenario::hardLB);

   softLB_ =
      new WitScenInputAtt <WitBoundSet> (this,
                                        "softLB",
                            WitBoundSet::defSoftLB (),
                          & WitBoundSet::softLB,
                          & WitBoundSet::storeStochSoftLB,
                          & WitScenario::softLB);

   hardUB_ =
      new WitScenInputAtt <WitBoundSet> (this,
                                        "hardUB",
                            WitBoundSet::defHardUB (),
                          & WitBoundSet::hardUB,
                          & WitBoundSet::storeStochHardUB,
                          & WitScenario::hardUB);

   buildingInputAtts_ = false;
   }

//------------------------------------------------------------------------------

void WitScenario::buildScenSolnAtts ()
   {
   buildingSolnAtts_ = true;

   scrapVol_   =
      new WitScenSolnAtt <WitPart>      (this,
                                        "scrapVol",
                        & WitPart::      storeStochScrapVol);

   stockVol_   =
      new WitScenSolnAtt <WitMaterial>  (this,
                                        "stockVol",
                        & WitMaterial::  storeStochStockVol);

   shipVol_    =
      new WitScenSolnAtt <WitDemand>    (this,
                                        "shipVol",
                        & WitDemand::    storeStochShipVol);

   cumShipVol_ =
      new WitScenSolnAtt <WitDemand>    (this,
                                        "cumShipVol",
                        & WitDemand::    storeStochCumShipVol);

   execVol_    =
      new WitScenSolnAtt <WitOperation> (this,
                                        "execVol",
                        & WitOperation:: storeStochExecVol);

   subVol_     =
      new WitScenSolnAtt <WitSubEntry>  (this,
                                        "subVol",
                        & WitSubEntry::  storeStochSubVol);

   buildingInputAtts_ = false;
   }

//------------------------------------------------------------------------------

a286 481

//------------------------------------------------------------------------------
// Implementation of class AbsScenInputAtt.
//------------------------------------------------------------------------------

WitAbsScenInputAtt::~WitAbsScenInputAtt ()
   {
   }

//------------------------------------------------------------------------------

WitAbsScenInputAtt::WitAbsScenInputAtt (WitScenario * theScenario):

      WitProbAssoc (theScenario)
   {
   theScenario->store (this);
   }

//------------------------------------------------------------------------------
// Implementation of class ScenInputAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitScenInputAtt <Owner>::WitScenInputAtt (
         WitScenario *                     theScenario,
         const char *                      theAttName,
         double                            theDefaultVal,
         const WitDblFlexVec & (Owner::*   theAccFunc) () const,
         void (Owner::*                    theStoreFunc) (
                                              const WitDblFlexVec &),
         WitScenInputAtt * (WitScenario::* theInstFunc) () const):

         WitAbsScenInputAtt (theScenario),
         myScenario_        (theScenario),
         myScenAtt_         (NULL),
         myAttName_         (theAttName),
         myDefaultVal_      (theDefaultVal),
         myAccFunc_         (theAccFunc),
         myStoreFunc_       (theStoreFunc),
         myInstFunc_        (theInstFunc)
   {
   myScenAtt_ = new WitScenAtt <Owner> (theScenario->myScenMgr ());

   downloadData ();

   if (myScenario_->myScenMgr ()->myScenarios ().isEmpty ())
      myScenario_->
         myScenMgr ()->
            myStochModeMgr ()->
               myStochAttMgr ()->
                  makeScenInputStochAtt (myAttName_);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      const WitDblFlexVec & WitScenInputAtt <Owner>::myValueFor (
         Owner * theOwner)
   {
   return myScenAtt_->myValueFor (theOwner);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitScenInputAtt <Owner>::~WitScenInputAtt ()
   {
   delete myScenAtt_;
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::downloadData ()
   {
   Owner * theOwner;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      myScenAtt_->myValueFor (theOwner) = (theOwner->*myAccFunc_) ();
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::uploadData ()
   {
   Owner * theOwner;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      (theOwner->*myStoreFunc_) (myValueFor (theOwner));
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::copyDataFrom (WitScenario * thatScenario)
   {
   WitScenInputAtt <Owner> * thatScenInputAtt;
   Owner *                   theOwner;
   
   thatScenInputAtt = (thatScenario->*myInstFunc_) ();

   forEachEl (theOwner, myScenAtt_->allOwners ())
      myScenAtt_->         myValueFor (theOwner) =
         thatScenInputAtt->myValueFor (theOwner);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::writeData (
         WitComponent * theComp,
         bool &         attWritten)
   {
   Owner * theOwner;

   theOwner = theOwnerFor (theComp);

   if (theOwner == NULL)
      return;

   if (myValueFor (theOwner) == myDefaultVal_)
      return;

   if (not attWritten)
      writeDataSetClause (theOwner);

   myDataWriter ()->
      writeVector (myAttName_, myValueFor (theOwner), myDefaultVal_);

   attWritten = true;
   }

//------------------------------------------------------------------------------
// Implementation of member function
// ScenInputAtt <Owner>::writeData (WitBoundSet *, bool &)
// Template specialized for Owner = BoundSet; otherwise not specialized.
//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::writeData (
         WitBoundSet * theBoundSet,
         bool &        attWritten)
   {
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::writeData (
         WitBoundSet * theBoundSet,
         bool &        attWritten)
   {
   if (myValueFor (theBoundSet) == myDefaultVal_)
      return;

   if (not attWritten)
      {
      theBoundSet->writeStochDataSetClause ();

      myDataWriter ()->writeFirstKeyWord (theBoundSet->myAttName ());
      }

   myDataWriter ()->
      writeVector (myAttName_, myValueFor (theBoundSet), myDefaultVal_);

   attWritten = true;
   }

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::checkValsInStage0 (
         WitScenario * thatScenario)
   {
   WitScenInputAtt <Owner> * thatScenInputAtt;
   WitStageMgr *             theStageMgr;
   Owner *                   theOwner;
   WitPeriod                 thePer;
   double                    thisValue;
   double                    thatValue;
   
   thatScenInputAtt = (thatScenario->*myInstFunc_) ();

   theStageMgr = myScenario_->myScenMgr ()->myStochModeMgr ()->myStageMgr ();

   forEachEl (theOwner, myScenAtt_->allOwners ())
      if (theStageMgr->stageNo (theOwner) == 0)
         forEachPeriod (thePer, myProblem ())
            {
            thisValue =                   myValueFor (theOwner)[thePer];
            thatValue = thatScenInputAtt->myValueFor (theOwner)[thePer];

            if (thisValue != thatValue)
               {
               myMsgFac () ("stage0AttMisMatchSmsg");

               myMsgFac () ("stage0AttMisMatchAttSmsg", myAttName_);

               issueMisMatchOwnerMsg (theOwner);

               myMsgFac () ("stage0AttMisMatchValsSmsg",
                  thePer,
                  thisValue,
                  thatScenario->myIndex (),
                  thatValue);
               }
            }
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// ScenInputAtt <Owner>::issueMisMatchOwnerMsg (...).
//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitPart>::issueMisMatchOwnerMsg (WitPart * thePart)
   {
   myMsgFac () ("stage0PartAttMisMatchSmsg", thePart->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitDemand>::issueMisMatchOwnerMsg (
         WitDemand * theDemand)
   {
   myMsgFac () ("stage0DemAttMisMatchSmsg",
      theDemand->demandedPartName (),
      theDemand->demandName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::issueMisMatchOwnerMsg (
         WitBoundSet * theBoundSet)
   {
   myMsgFac () ("stage0BoundSetAttMisMatchSmsg", theBoundSet->myAttName ());

   theBoundSet->issueStage0MisMatchMsg ();
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// ScenInputAtt <Owner>::theOwnerFor (...).
//------------------------------------------------------------------------------

template <>
      WitPart * WitScenInputAtt <WitPart>::theOwnerFor (WitComponent * theComp)
   {
   return theComp->thisPart ();
   }

//------------------------------------------------------------------------------

template <>
      WitDemand * WitScenInputAtt <WitDemand>::theOwnerFor (
         WitComponent * theComp)
   {
   return theComp->thisDemand ();
   }

//------------------------------------------------------------------------------

template <>
      WitBoundSet * WitScenInputAtt <WitBoundSet>::theOwnerFor (WitComponent *)
   {
   return NULL;
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// ScenInputAtt <Owner>::writeDataSetClause (theOwner)
//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitPart>::writeDataSetClause (WitPart * thePart)
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (thePart->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitDemand>::writeDataSetClause (
         WitDemand * theDemand)
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("demand");
   myDataWriter ()->writeStringValue  (theDemand->demandedPartName ());
   myDataWriter ()->writeStringValue  (theDemand->demandName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenInputAtt <WitBoundSet>::writeDataSetClause (WitBoundSet *)
   {
   stronglyAssert (false);
      //
      // writeDataSetClause is not to be called in the BoundSet case.
   }

//------------------------------------------------------------------------------
// Implementation of class AbsScenSolnAtt.
//------------------------------------------------------------------------------

WitAbsScenSolnAtt::~WitAbsScenSolnAtt ()
   {
   }

//------------------------------------------------------------------------------

WitAbsScenSolnAtt::WitAbsScenSolnAtt (WitScenario * theScenario):

      WitProbAssoc (theScenario)
   {
   theScenario->store (this);
   }

//------------------------------------------------------------------------------
// Implementation of class ScenSolnAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitScenSolnAtt <Owner>::WitScenSolnAtt (
            WitScenario *  theScenario,
            const char *   theAttName,
            void (Owner::* theStoreFunc) (const WitDblFlexVec &)):

         WitAbsScenSolnAtt (theScenario),
         myStochModeMgr_   (theScenario->myScenMgr ()->myStochModeMgr ()),
         myScenAtt_        (NULL),
         myStoreFunc_      (theStoreFunc)
   {
   myScenAtt_ = new WitScenAtt <Owner> (theScenario->myScenMgr ());

   if (theScenario->myScenMgr ()->myScenarios ().isEmpty ())
      myStochModeMgr_->
         myStochAttMgr ()->
            makeScenSolnStochAtt (theAttName);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenSolnAtt <Owner>::storeValueFor (
         Owner *   theOwner,
         WitPeriod thePer,
         double    theValue)
   {
   witAssert (myStochModeMgr_->myStochOptMgr ()->uploadingSoln ());

   if (theValue <= 0.0)
      return;

   myScenAtt_->myValueFor (theOwner).elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitScenSolnAtt <Owner>::~WitScenSolnAtt ()
   {
   delete myScenAtt_;
   }

//------------------------------------------------------------------------------
  
template <typename Owner>
      void WitScenSolnAtt <Owner>::uploadData ()
   {
   Owner * theOwner;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      (theOwner->*myStoreFunc_) (myScenAtt_->myValueFor (theOwner));
   }

//------------------------------------------------------------------------------
  
template <typename Owner>
      void WitScenSolnAtt <Owner>::clearData ()
   {
   Owner * theOwner;

   forEachEl (theOwner, myScenAtt_->allOwners ())
      myScenAtt_->myValueFor (theOwner) = 0.0;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class ScenSolnAtt <Owner>.
//------------------------------------------------------------------------------

template class WitScenSolnAtt <WitPart>;
template class WitScenSolnAtt <WitMaterial>;
template class WitScenSolnAtt <WitDemand>;
template class WitScenSolnAtt <WitOperation>;
template class WitScenSolnAtt <WitSubEntry>;

//------------------------------------------------------------------------------
// Implementation of class ScenAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitScenAtt <Owner>::WitScenAtt (WitScenMgr * theScenMgr):

         WitProbAssoc (theScenMgr),
         myScenMgr_   (theScenMgr),
         myValue_     (myProblem ())
   {
   Owner * theOwner;

   forEachEl (theOwner, allOwners ())
      myValue_ (theOwner) = new WitDblFlexVec (myProblem (), 0.0);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitScenAtt <Owner>::~WitScenAtt ()
   {
   Owner * theOwner;

   forEachEl (theOwner, allOwners ())
      delete myValue_ (theOwner);
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// ScenAtt <Owner>::allOwners (...).
//------------------------------------------------------------------------------

template <> 
      const WitList <WitPart> & WitScenAtt <WitPart>::allOwners ()
   {
   return myScenMgr_->myCompMgr ()->allParts ();
   }

//------------------------------------------------------------------------------

template <>
      const WitList <WitMaterial> & WitScenAtt <WitMaterial>::allOwners ()
   {
   return myScenMgr_->allMats ();
   }

//------------------------------------------------------------------------------

template <>
      const WitList <WitDemand> & WitScenAtt <WitDemand>::allOwners ()
   {
   return myScenMgr_->allDemands ();
   }

//------------------------------------------------------------------------------

template <>
      const WitList <WitOperation> & WitScenAtt <WitOperation>::allOwners ()
   {
   return myScenMgr_->myCompMgr ()->allOperations ();
   }

//------------------------------------------------------------------------------

template <>
      const WitList <WitSubEntry> & WitScenAtt <WitSubEntry>::allOwners ()
   {
   return myScenMgr_->allSubs ();
   }

//------------------------------------------------------------------------------

template <> 
      const WitList <WitBoundSet> & WitScenAtt <WitBoundSet>::allOwners ()
   {
   return myScenMgr_->allBoundSets ();
   }
@


1.50
log
@Stochastic Implosion
@
text
@d593 1
a593 1
                                              const WitTVec <double> &),
a604 2
   Owner * theOwner;

a606 3
   forEachEl (theOwner, myScenAtt_->allOwners ())
      myScenAtt_->myValueFor (theOwner).allocate (myProblem (), 0.0);

d620 1
a620 1
      const WitTVec <double> & WitScenInputAtt <Owner>::myValueFor (
d896 1
a896 1
            void (Owner::* theStoreFunc) (const WitTVec <double> &)):
d924 1
a924 4
   if (not myScenAtt_->myValueFor (theOwner).isAllocated ())
           myScenAtt_->myValueFor (theOwner).allocate (myProblem (), 0.0);

   myScenAtt_->myValueFor (theOwner)[thePer] = theValue;
d940 1
a940 4
   WitTVec <double> zeroVec;
   Owner *          theOwner;

   zeroVec.allocate (myProblem (), 0.0);
d943 1
a943 6
      {
      if (myScenAtt_->myValueFor (theOwner).isAllocated ())
         (theOwner->*myStoreFunc_) (myScenAtt_->myValueFor (theOwner));
      else
         (theOwner->*myStoreFunc_) (zeroVec);
      }
d954 1
a954 1
      myScenAtt_->myValueFor (theOwner).clear ();
d976 1
a976 1
         myValue_     (myProblem (), 0.0)
d978 4
a981 1
   myValue_.allocate1D (myProblem ());
d989 4
@


1.49
log
@Stochastic Implosion
@
text
@d372 1
d392 14
d703 37
@


1.48
log
@Stochastic Implosion
@
text
@a720 1
                  myScenario_ ->myIndex (),
d784 1
a784 2
      WitBoundSet * WitScenInputAtt <WitBoundSet>::theOwnerFor (
         WitComponent * theComp)
d786 1
a786 1
   return theComp->myBoundSet ();
@


1.47
log
@Stochastic Implosion
@
text
@d754 2
a755 1
      void WitScenInputAtt <WitBoundSet>::issueMisMatchOwnerMsg (WitBoundSet *)
d757 3
a759 1
   stronglyAssert (false);
@


1.46
log
@Stochastic Implosion
@
text
@d42 1
d60 2
a61 1
      allSubs_        ()
d214 4
a217 3
   WitMaterial * theMat;
   WitDemand *   theDemand;
   WitSubEntry * theSub;
d220 4
a223 1
      allMats_.   append (theMat);
d226 4
a229 1
      allDemands_.append (theDemand);
d233 3
d271 3
a409 10
void WitScenario::writeVector (
      const char *             theAttName,
      const WitTVec <double> & theVector,
      double                   theDefaultVal)
   {
   myDataWriter ()->writeVector (theAttName, theVector, theDefaultVal);
   }

//------------------------------------------------------------------------------

d451 6
a456 6
      new WitScenInputAtt   <WitPart> (this,
                                      "supplyVol",
                              WitPart::defSupplyVol (),
                            & WitPart::supplyVol,
                            & WitPart::storeStochSupplyVol,
                        & WitScenario::supplyVol);
d459 30
a488 6
      new WitScenInputAtt <WitDemand> (this,
                                      "demandVol",
                            WitDemand::defDemandVol (),
                          & WitDemand::demandVol,
                          & WitDemand::storeStochDemandVol,
                        & WitScenario::demandVol);
d587 1
d592 1
a592 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenario, theStoreFunc);
d640 4
a643 1
   myScenAtt_->uploadData ();
d681 2
a682 1
   myScenario_->writeVector (myAttName_, myValueFor (theOwner), myDefaultVal_);
d752 8
d780 9
d814 10
d852 2
a853 1
         myScenAtt_        (NULL)
d855 1
a855 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenario, theStoreFunc);
d895 12
a906 1
   myScenAtt_->uploadData ();
d935 5
a939 8
      WitScenAtt <Owner>::WitScenAtt (
         WitScenario *  theScenario,
         void (Owner::* theStoreFunc) (const WitTVec <double> &)):

         WitProbAssoc (theScenario),
         myScenMgr_   (theScenario->myScenMgr ()),
         myValue_     (myProblem (), 0.0),
         myStoreFunc_ (theStoreFunc)
a951 11

template <typename Owner>
      void WitScenAtt <Owner>::uploadData ()
   {
   Owner * theOwner;

   forEachEl (theOwner, allOwners ())
      (theOwner->*myStoreFunc_) (myValue_ (theOwner));
   }

//------------------------------------------------------------------------------
d993 8
@


1.45
log
@Stochastic Implosion
@
text
@d31 1
d472 1
d477 1
d482 1
d487 1
d492 1
d497 1
d568 7
d786 1
d794 5
@


1.44
log
@Stochastic Implosion
@
text
@d55 1
d119 2
d130 2
d356 1
d367 1
a367 1
      myScenMgr_->myStochModeMgr ()->startWriteCompData (theComp);
d370 1
a370 1
         theInputAtt->writeData (theComp);
d372 2
a373 1
      myScenMgr_->myStochModeMgr ()->finishWriteCompData ();
d617 3
a619 1
      void WitScenInputAtt <Owner>::writeData (WitComponent * theComp)
d631 3
d635 2
d683 1
a683 1
// WitScenInputAtt <Owner>::issueMisMatchOwnerMsg (...).
d705 1
a705 1
// WitScenInputAtt <Owner>::theOwnerFor (...).
d724 25
@


1.43
log
@Stochastic Implosion
@
text
@d278 1
a278 1
void WitScenario::store (WitAbsScenInputAtt * theAbsScenInputAtt)
d282 1
a282 1
   myAbsScenInputAtts_.append (theAbsScenInputAtt);
d287 1
a287 1
void WitScenario::store (WitAbsScenSolnAtt * theAbsScenSolnAtt)
d291 1
a291 1
   myAbsScenSolnAtts_.append (theAbsScenSolnAtt);
d298 1
a298 1
   WitAbsScenInputAtt * theAbsScenInputAtt;
d300 2
a301 2
   forEachEl (theAbsScenInputAtt, myAbsScenInputAtts_)
      theAbsScenInputAtt->downloadData ();
d308 1
a308 1
   WitAbsScenInputAtt * theAbsScenInputAtt;
d310 2
a311 2
   forEachEl (theAbsScenInputAtt, myAbsScenInputAtts_)
      theAbsScenInputAtt->uploadData ();
d318 1
a318 1
   WitAbsScenInputAtt * theAbsScenInputAtt;
d322 2
a323 2
   forEachEl (theAbsScenInputAtt, myAbsScenInputAtts_)
      theAbsScenInputAtt->copyDataFrom (thatScenario);
d330 1
a330 1
   WitAbsScenSolnAtt * theAbsScenSolnAtt;
d332 2
a333 2
   forEachEl (theAbsScenSolnAtt, myAbsScenSolnAtts_)
      theAbsScenSolnAtt->uploadData ();
d340 1
a340 1
   WitAbsScenSolnAtt * theAbsScenSolnAtt;
d342 2
a343 2
   forEachEl (theAbsScenSolnAtt, myAbsScenSolnAtts_)
      theAbsScenSolnAtt->clearData ();
d350 3
d359 9
a367 2
   writePartData   ();
   writeDemandData ();
d387 10
d399 1
a399 1
   WitAbsScenInputAtt * theAbsScenInputAtt;
d401 2
a402 2
   forEachEl (theAbsScenInputAtt, myAbsScenInputAtts_)
      theAbsScenInputAtt->checkValsInStage0 (thatScenario);
d440 1
d448 1
a507 52

void WitScenario::writePartData ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      {
      startWriteCompData (thePart);

      myDataWriter ()->writeVector (
         "supplyVol",
         supplyVol_->myValueFor (thePart),
         WitPart::defSupplyVol ());

      finishWriteCompData ();
      }
   }

//------------------------------------------------------------------------------

void WitScenario::writeDemandData ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      {
      startWriteCompData (theDemand);

      myDataWriter ()->writeVector (
         "demandVol",
         demandVol_->myValueFor (theDemand),
         WitDemand::defDemandVol ());

      finishWriteCompData ();
      }
   }

//------------------------------------------------------------------------------

void WitScenario::startWriteCompData (WitComponent * theComp)
   {
   myScenMgr_->myStochModeMgr ()->startWriteCompData (theComp);
   }

//------------------------------------------------------------------------------

void WitScenario::finishWriteCompData ()
   {
   myScenMgr_->myStochModeMgr ()->finishWriteCompData ();
   }

//------------------------------------------------------------------------------
d532 1
d542 1
d610 18
d690 2
a691 1
// Explicit instantiation of class ScenInputAtt <Owner>.
d694 14
a707 2
template class WitScenInputAtt <WitPart>;
template class WitScenInputAtt <WitDemand>;
@


1.42
log
@Stochastic Implosion
@
text
@d568 1
a571 1
         myStoreFunc_       (theStoreFunc),
d574 3
a576 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenario);
d578 2
a579 1
   myScenAtt_->allocate ();
d581 10
a590 1
   myScenAtt_->downloadData (myAccFunc_);
d606 4
a609 1
   myScenAtt_->downloadData (myAccFunc_);
d617 1
a617 1
   myScenAtt_->uploadData (myStoreFunc_);
d626 1
a626 1
   WitScenAtt <Owner> *      thatScenAtt;
d630 3
a632 3
   thatScenAtt      = thatScenInputAtt->myScenAtt_;

   myScenAtt_->copyDataFrom (thatScenAtt);
d642 5
a646 1
   WitScenAtt <Owner> *      thatScenAtt;
d650 31
a680 1
   thatScenAtt      = thatScenInputAtt->myScenAtt_;
d682 4
a685 1
   myScenAtt_->checkValsInStage0 (thatScenAtt, myAttName_);
d690 3
a692 3
template <typename Owner>
      const WitTVec <double> & WitScenInputAtt <Owner>::myValueFor (
         Owner * theOwner)
d694 3
a696 1
   return myScenAtt_->myValueFor (theOwner);
d733 2
a734 2
         myScenAtt_        (NULL),
         myStoreFunc_      (theStoreFunc)
d736 1
a736 1
   myScenAtt_ = new WitScenAtt <Owner> (theScenario);
d747 9
a755 1
   myScenAtt_->storeValueFor (theOwner, thePer, theValue);
d771 1
a771 1
   myScenAtt_->uploadData (myStoreFunc_);
d779 4
a782 1
   myScenAtt_->clear ();
d800 3
a802 1
      WitScenAtt <Owner>::WitScenAtt (WitScenario * theScenario):
d805 3
a807 2
         myScenario_  (theScenario),
         myValue_     (myProblem (), 0.0)
d822 1
a822 18
      void WitScenAtt <Owner>::allocate ()
   {
   myValue_.allocate (myProblem (), 0.0);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenAtt <Owner>::clear ()
   {
   myValue_.allocate1D (myProblem ());
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenAtt <Owner>::downloadData (
         const WitDblFlexVec & (Owner::* theAccFunc) () const)
d827 1
a827 85
      myValue_ (theOwner) = (theOwner->*theAccFunc) ();
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenAtt <Owner>::uploadData (
         void (Owner::* theStoreFunc) (const WitTVec <double> &))
   {
   Owner * theOwner;

   forEachEl (theOwner, allOwners ())
      (theOwner->*theStoreFunc) (myValue_ (theOwner));
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenAtt <Owner>::copyDataFrom (WitScenAtt * theScenAtt)
   {
   myValue_ = theScenAtt->myValue_;
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenAtt <Owner>::checkValsInStage0 (
         WitScenAtt * thatScenAtt,
         const char * theAttName)
   {
   WitStageMgr * theStageMgr;
   Owner *       theOwner;
   WitPeriod     thePer;
   double        thisValue;
   double        thatValue;

   theStageMgr = myScenario_->myScenMgr ()->myStochModeMgr ()->myStageMgr ();

   forEachEl (theOwner, allOwners ())
      if (theStageMgr->stageNo (theOwner) == 0)
         forEachPeriod (thePer, myProblem ())
            {
            thisValue =              myValue_ (theOwner)[thePer];
            thatValue = thatScenAtt->myValue_ (theOwner)[thePer];

            if (thisValue != thatValue)
               {
               myMsgFac () ("stage0AttMisMatchSmsg");

               myMsgFac () ("stage0AttMisMatchAttSmsg", theAttName);

               issueMisMatchOwnerMsg (theOwner);

               myMsgFac () ("stage0AttMisMatchValsSmsg",
                  thePer,
                  myScenario_             ->myIndex (),
                  thisValue,
                  thatScenAtt->myScenario_->myIndex (),
                  thatValue);
               }
            }
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenAtt <Owner>::storeValueFor (
            Owner *   theOwner,
            WitPeriod thePer,
            double    theValue)
   {
   witAssert (
      myScenario_->
         myScenMgr ()->
            myStochModeMgr ()->
               myStochOptMgr ()->
                  uploadingSoln ());

   if (theValue <= 0.0)
      return;

   if (not myValue_ (theOwner).isAllocated ())
           myValue_ (theOwner).allocate (myProblem (), 0.0);

   myValue_ (theOwner)[thePer] = theValue;
d838 1
a838 1
   return myScenario_->myCompMgr ()->allParts ();
d846 1
a846 1
   return myScenario_->myScenMgr ()->allMats ();
d854 1
a854 1
   return myScenario_->myScenMgr ()->allDemands ();
d862 1
a862 1
   return myScenario_->myCompMgr ()->allOperations ();
d870 1
a870 22
   return myScenario_->myScenMgr ()->allSubs ();
   }

//------------------------------------------------------------------------------
// Template specialized implementation of member function
// WitScenAtt <Owner>::issueMisMatchOwnerMsg (...).
//------------------------------------------------------------------------------

template <>
      void WitScenAtt <WitPart>::issueMisMatchOwnerMsg (WitPart * thePart)
   {
   myMsgFac () ("stage0PartAttMisMatchSmsg", thePart->partName ());
   }

//------------------------------------------------------------------------------

template <>
      void WitScenAtt <WitDemand>::issueMisMatchOwnerMsg (WitDemand * theDemand)
   {
   myMsgFac () ("stage0DemAttMisMatchSmsg",
      theDemand->demandedPartName (),
      theDemand->demandName ());
@


1.41
log
@Stochastic Implosion
@
text
@a405 75
void WitScenario::storeScrapVol (
      WitPart * thePart,
      WitPeriod thePer,
      double    theVal)
   {
   scrapVol_->storeValueFor (thePart, thePer, theVal);
   }

//------------------------------------------------------------------------------

void WitScenario::storeStockVol (
      WitMaterial * theMat,
      WitPeriod     thePer,
      double        theVal)
   {
   stockVol_->storeValueFor (theMat, thePer, theVal);
   }

//------------------------------------------------------------------------------

void WitScenario::storeShipVol (
      WitDemand * theDemand,
      WitPeriod   thePer,
      double      theVal)
   {
   shipVol_->storeValueFor (theDemand, thePer, theVal);
   }

//------------------------------------------------------------------------------

void WitScenario::storeCumShipVol (
      WitDemand * theDemand,
      WitPeriod   thePer,
      double      theVal)
   {
   cumShipVol_->storeValueFor (theDemand, thePer, theVal);
   }

//------------------------------------------------------------------------------

void WitScenario::storeExecVol (
      WitOperation * theOpn,
      WitPeriod      thePer,
      double         theVal)
   {
   execVol_->storeValueFor (theOpn, thePer, theVal);
   }

//------------------------------------------------------------------------------

void WitScenario::storeSubVol (
      WitSubEntry * theSub,
      WitPeriod     thePer,
      double        theVal)
   {
   subVol_->storeValueFor (theSub, thePer, theVal);
   }

//------------------------------------------------------------------------------
// Implementation of scenario-specific input attribute value functions.
//------------------------------------------------------------------------------

double WitScenario::supplyVol (WitPart *   thePart, WitPeriod thePer)
   {
   return supplyVol_->myValueFor (thePart)  [thePer];
   }

double WitScenario::demandVol (WitDemand * theDemand, WitPeriod thePer)
   {
   return demandVol_->myValueFor (theDemand)[thePer];
   }

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

d423 1
d688 11
a720 11

template <typename Owner>
      void WitScenSolnAtt <Owner>::storeValueFor (
         Owner *   theOwner,
         WitPeriod thePer,
         double    theValue)
   {
   myScenAtt_->storeValueFor (theOwner, thePer, theValue);
   }

//------------------------------------------------------------------------------
@


1.40
log
@Stochastic Implosion
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d17 5
a25 1
#include <ScenAttMgr.h>
d31 1
d36 1
d54 4
a57 1
      curScenario_    (NULL)
d59 4
a62 2
   int            theIdx;
   WitScenario *  theScenario;
d119 1
a119 1
      myScenAttMgr ()->downloadInputToCurScen ();
d143 1
a143 1
      myScenAttMgr ()->downloadInputToCurScen ();
d167 3
d171 6
d186 1
a186 1
      myScenAttMgr ()->downloadInputToCurScen ();
d204 18
d237 4
d242 18
a259 1
WitScenAttMgr * WitScenMgr::myScenAttMgr ()
d261 2
a262 1
   return myStochModeMgr_->myScenAttMgr ();
d266 38
a303 1
// Implementation of class Scenario.
d306 9
a314 1
WitScenario::WitScenario (WitScenMgr * theScenMgr, int theIdx):
d316 1
a316 4
      WitProbAssoc (theScenMgr),
      myScenMgr_   (theScenMgr),
      myIndex_     (theIdx),
      probability_ (defProbability ())
d318 6
d328 1
a328 1
WitScenario::~WitScenario ()
d330 4
d338 1
a338 1
void WitScenario::copyAttrsFrom (WitScenario * theScenario)
d340 4
a343 1
   probability_ = theScenario->probability_;
d377 10
d406 75
d488 55
d571 1
a571 1
         supplyVol (thePart),
d590 1
a590 1
         demandVol (theDemand),
d612 372
d985 2
a986 1
const WitTVec <double> & WitScenario::supplyVol (WitPart * thePart)
d988 1
a988 6
   return
      myScenMgr_->
         myStochModeMgr ()->
            myScenAttMgr ()->
               supplyVol ()->
                  myValue (thePart, this);
d993 2
a994 1
const WitTVec <double> & WitScenario::demandVol (WitDemand * theDemand)
d996 3
a998 6
   return
      myScenMgr_->
         myStochModeMgr ()->
            myScenAttMgr ()->
               demandVol ()->
                  myValue (theDemand, this);
@


1.39
log
@Stochastic Implosion
@
text
@a25 1
#include <StageMgr.h>
a36 4


#include <Schedule.h>

a156 1
   checkAttsInStage0  ();
a199 16
void WitScenMgr::checkAttsInStage0 ()
   {
   WitScenario * theScenario1;
   WitScenario * theScenario2;

   theScenario1 = myScenarios_.first ();

   forEachEl (theScenario2, myScenarios_)
      if (theScenario2 != theScenario1)
         myStochModeMgr_->
            myStageMgr ()->
               checkAttsInStage0 (theScenario1, theScenario2);
   }

//------------------------------------------------------------------------------

a261 53
void WitScenario::checkAttsMatch (WitPart * thePart, WitScenario * thatScenario)
   {
   WitPeriod thePer;
   double    thisVal;
   double    thatVal;

   forEachPeriod (thePer, myProblem ())
      {
      thisVal =               supplyVol (thePart)[thePer];
      thatVal = thatScenario->supplyVol (thePart)[thePer];

      if (thisVal != thatVal)
         myMsgFac () ("stage0PartAttMisMatchSmsg",
            "supplyVol",
            thePart->partName (),
            thePer,
            myIndex_,
            thisVal,
            thatScenario->myIndex_,
            thatVal);
      }
   }

//------------------------------------------------------------------------------

void WitScenario::checkAttsMatch (
      WitDemand *   theDemand,
      WitScenario * thatScenario)
   {
   WitPeriod thePer;
   double    thisVal;
   double    thatVal;

   forEachPeriod (thePer, myProblem ())
      {
      thisVal =               demandVol (theDemand)[thePer];
      thatVal = thatScenario->demandVol (theDemand)[thePer];

      if (thisVal != thatVal)
         myMsgFac () ("stage0DemAttMisMatchSmsg",
            "demandVol",
            theDemand->demandedPartName (),
            theDemand->demandName (),
            thePer,
            myIndex_,
            thisVal,
            thatScenario->myIndex_,
            thatVal);
      }
   }

//------------------------------------------------------------------------------

d358 1
a358 1
WitTVec <double> & WitScenario::supplyVol (WitPart * thePart)
d365 1
a365 2
                  myScenAtt_->
                     myValue_ (thePart) (this);
d370 1
a370 1
WitTVec <double> & WitScenario::demandVol (WitDemand * theDemand)
d377 1
a377 2
                  myScenAtt_->
                     myValue_ (theDemand) (this);
@


1.38
log
@Stochastic Implosion
@
text
@d24 1
a24 1
#include <ScenAttTable.h>
d440 1
a440 1
                  myTable_->
d453 1
a453 1
                  myTable_->
@


1.37
log
@Stochastic Implosion.
@
text
@a355 14
const WitTVec <double> & WitScenario::supplyVolAcc (WitPart * thePart)
   {
   return supplyVol (thePart);
   }

//------------------------------------------------------------------------------

const WitTVec <double> & WitScenario::demandVolAcc (WitDemand * theDemand)
   {
   return demandVol (theDemand);
   }

//------------------------------------------------------------------------------

@


1.36
log
@Stochastic Implosion
@
text
@a249 3
   WitPart *   thePart;
   WitDemand * theDemand;

a250 6

   forEachPart (thePart, myProblem ())
      supplyVol (thePart) = theScenario->supplyVol (thePart);

   forEachDemand (theDemand, myProblem ())
      demandVol (theDemand) = theScenario->demandVol (theDemand);
@


1.35
log
@Stochastic Implosion
@
text
@a247 8
void WitScenario::allocSoln ()
   {
   witAssert (
      myScenMgr_->myStochModeMgr ()->myStochOptMgr ()->uploadingSoln ());
   }

//------------------------------------------------------------------------------

@


1.34
log
@Stochastic Implosion
@
text
@a486 78

//------------------------------------------------------------------------------

WitTVec <double> & WitScenario::scrapVol (WitPart * thePart)
   {
   return
      myScenMgr_->
         myStochModeMgr ()->
            myScenAttMgr ()->
               scrapVol ()->
                  myTable_->
                     myValue_ (thePart) (this);
   }

//------------------------------------------------------------------------------

WitTVec <double> & WitScenario::stockVol (WitMaterial * theMat)
   {
   return
      myScenMgr_->
         myStochModeMgr ()->
            myScenAttMgr ()->
               stockVol ()->
                  myTable_->
                     myValue_ (theMat) (this);
   }

//------------------------------------------------------------------------------

WitTVec <double> & WitScenario::shipVol (WitDemand * theDemand)
   {
   return
      myScenMgr_->
         myStochModeMgr ()->
            myScenAttMgr ()->
               shipVol ()->
                  myTable_->
                     myValue_ (theDemand) (this);
   }

//------------------------------------------------------------------------------

WitTVec <double> & WitScenario::cumShipVol (WitDemand * theDemand)
   {
   return
      myScenMgr_->
         myStochModeMgr ()->
            myScenAttMgr ()->
               cumShipVol ()->
                  myTable_->
                     myValue_ (theDemand) (this);
   }

//------------------------------------------------------------------------------

WitTVec <double> & WitScenario::execVol (WitOperation * theOpn)
   {
   return
      myScenMgr_->
         myStochModeMgr ()->
            myScenAttMgr ()->
               execVol ()->
                  myTable_->
                     myValue_ (theOpn) (this);
   }

//------------------------------------------------------------------------------

WitTVec <double> & WitScenario::subVol (WitSubEntry * theSub)
   {
   return
      myScenMgr_->
         myStochModeMgr ()->
            myScenAttMgr ()->
               subVol ()->
                  myTable_->
                     myValue_ (theSub) (this);
   }
@


1.33
log
@Stochastic Implosion
@
text
@a255 29
void WitScenario::clearSoln ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachPart (thePart, myProblem ())
      scrapVol (thePart) = 0.0;

   forEachMaterial (theMat, myProblem ())
      stockVol (theMat) = 0.0;

   forEachDemand (theDemand, myProblem ())
      {
      shipVol    (theDemand) = 0.0;
      cumShipVol (theDemand) = 0.0;
      }

   forEachOperation (theOpn, myProblem ())
      execVol (theOpn) = 0.0;

   forEachSubEntry (theSub, myProblem ())
      subVol (theSub) = 0.0;
   }

//------------------------------------------------------------------------------

@


1.32
log
@Stochastic Implosion
@
text
@a401 60
void WitScenario::storeScrapVol (
      WitPart * thePart,
      WitPeriod thePer,
      double    theValue)
   {
   storeSolnAttr (scrapVol (thePart), thePer, theValue);
   }

//------------------------------------------------------------------------------

void WitScenario::storeStockVol (
      WitMaterial * theMat,
      WitPeriod     thePer,
      double        theValue)
   {
   storeSolnAttr (stockVol (theMat), thePer, theValue);
   }

//------------------------------------------------------------------------------

void WitScenario::storeShipVol (
      WitDemand * theDemand,
      WitPeriod   thePer,
      double      theValue)
   {
   storeSolnAttr (shipVol (theDemand), thePer, theValue);
   }

//------------------------------------------------------------------------------

void WitScenario::storeCumShipVol (
      WitDemand * theDemand,
      WitPeriod   thePer,
      double      theValue)
   {
   storeSolnAttr (cumShipVol (theDemand), thePer, theValue);
   }

//------------------------------------------------------------------------------

void WitScenario::storeExecVol (
      WitOperation * theOpn,
      WitPeriod      thePer,
      double         theValue)
   {
   storeSolnAttr (execVol (theOpn), thePer, theValue);
   }

//------------------------------------------------------------------------------

void WitScenario::storeSubVol (
      WitSubEntry * theSub,
      WitPeriod     thePer,
      double        theValue)
   {
   storeSolnAttr (subVol (theSub), thePer, theValue);
   }

//------------------------------------------------------------------------------

a422 19
void WitScenario::storeSolnAttr (
      WitTVec <double> & theAttr, 
      WitPeriod          thePer,
      double             theValue)
   {
   witAssert (
      myScenMgr_->myStochModeMgr ()->myStochOptMgr ()->uploadingSoln ());

   if (theValue <= 0.0)
      return;

   if (not theAttr.isAllocated ())
      theAttr.allocate (myProblem (), 0.0);

   theAttr[thePer] = theValue;
   }

//------------------------------------------------------------------------------

@


1.31
log
@Stochastic Implosion
@
text
@d24 1
a24 1
#include <ScenAtt.h>
d579 1
a579 1
                  myScenAtt_->
d592 2
a593 1
                  myScenAtt_->myValue_ (theDemand) (this);
d605 2
a606 1
                  myScenAtt_->myValue_ (thePart) (this);
d618 2
a619 1
                  myScenAtt_->myValue_ (theMat) (this);
d631 1
a631 1
                  myScenAtt_->
d644 1
a644 1
                  myScenAtt_->
d657 1
a657 1
                  myScenAtt_->
d670 1
a670 1
                  myScenAtt_->
@


1.30
log
@Stochastic Implosion
@
text
@d22 2
a23 1
#include <ConcScenAtt.h>
@


1.29
log
@Stochastic Implosion
@
text
@d23 1
d578 2
a579 1
                  myValue_ (thePart) (this);
d591 1
a591 1
                  myValue_ (theDemand) (this);
d603 1
a603 1
                  myValue_ (thePart) (this);
d615 1
a615 1
                  myValue_ (theMat) (this);
d627 2
a628 1
                  myValue_ (theDemand) (this);
d640 2
a641 1
                  myValue_ (theDemand) (this);
d653 2
a654 1
                  myValue_ (theOpn) (this);
d666 2
a667 1
                  myValue_ (theSub) (this);
@


1.28
log
@Stochastic Implosion
@
text
@a245 43
void WitScenario::uploadInput ()
   {
   WitPart *   thePart;
   WitDemand * theDemand;

   forEachPart (thePart, myProblem ())
      thePart->  storeStochSupplyVol (supplyVol (thePart));

   forEachDemand (theDemand, myProblem ())
      theDemand->storeStochDemandVol (demandVol (theDemand));
   }

//------------------------------------------------------------------------------

void WitScenario::uploadSoln ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachPart      (thePart,   myProblem ())
      thePart  ->storeStochScrapVol   (scrapVol   (thePart));

   forEachMaterial  (theMat,    myProblem ())
      theMat   ->storeStochStockVol   (stockVol   (theMat));

   forEachDemand    (theDemand, myProblem ())
      {
      theDemand->storeStochShipVol    (shipVol    (theDemand));
      theDemand->storeStochCumShipVol (cumShipVol (theDemand));
      }

   forEachOperation (theOpn,    myProblem ())
      theOpn   ->storeStochExecVol    (execVol    (theOpn));

   forEachSubEntry  (theSub,    myProblem ())
      theSub   ->storeStochSubVol     (subVol     (theSub));
   }

//------------------------------------------------------------------------------

@


1.27
log
@Stochastic Implosion
@
text
@d13 1
a13 1
// Contains the implementation of the following classes and templates:
a16 5
//    ScenAttMgr
//    ScenAtt
//    OwnedScenAtt <Owner>
//    ScenInputAtt <Owner>
//    ScenSolnAtt  <Owner>
d22 1
a22 1
#include <ScenAtt.h>
a705 274

//------------------------------------------------------------------------------
// Implementation of class ScenAttMgr.
//------------------------------------------------------------------------------

WitScenAttMgr::WitScenAttMgr (WitScenMgr * theScenMgr):

      WitProbAssoc (theScenMgr),
      myScenMgr_   (theScenMgr),
      myScenAtts_  (),

      supplyVol_   (NULL),
      demandVol_   (NULL),

      scrapVol_    (NULL),
      stockVol_    (NULL),
      shipVol_     (NULL),
      cumShipVol_  (NULL),
      execVol_     (NULL),
      subVol_      (NULL),
      allMats_     (),
      allDemands_  (),
      allSubs_     ()
   {
   buildOwnerLists    ();
   buildScenInputAtts ();
   buildScenSolnAtts  ();
   }

//------------------------------------------------------------------------------

WitScenAttMgr::~WitScenAttMgr ()
   {
   WitScenAtt * theScenAtt;

   while (not myScenAtts_.isEmpty ())
      delete myScenAtts_.get ();
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::downloadInputToCurScen ()
   {
   WitScenAtt * theScenAtt;

   forEachEl (theScenAtt, myScenAtts_)
      theScenAtt->downloadInputToCurScen ();
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::buildOwnerLists ()
   {
   WitMaterial * theMat;
   WitDemand *   theDemand;
   WitSubEntry * theSub;

   forEachMaterial (theMat, myProblem ())
      allMats_.   append (theMat);

   forEachDemand   (theDemand, myProblem ())
      allDemands_.append (theDemand);

   forEachSubEntry (theSub, myProblem ())
      allSubs_.   append (theSub);
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::buildScenInputAtts ()
   {
   supplyVol_ = new WitScenInputAtt <WitPart>   (this, &   WitPart::supplyVol);
   demandVol_ = new WitScenInputAtt <WitDemand> (this, & WitDemand::demandVol);

   myScenAtts_.append (supplyVol_);
   myScenAtts_.append (demandVol_);
   }

//------------------------------------------------------------------------------

void WitScenAttMgr::buildScenSolnAtts ()
   {
   scrapVol_   = new WitScenSolnAtt <WitPart>      (this);
   stockVol_   = new WitScenSolnAtt <WitMaterial>  (this);
   shipVol_    = new WitScenSolnAtt <WitDemand>    (this);
   cumShipVol_ = new WitScenSolnAtt <WitDemand>    (this);
   execVol_    = new WitScenSolnAtt <WitOperation> (this);
   subVol_     = new WitScenSolnAtt <WitSubEntry>  (this);

   myScenAtts_.append (scrapVol_);
   myScenAtts_.append (stockVol_);
   myScenAtts_.append (shipVol_);
   myScenAtts_.append (cumShipVol_);
   myScenAtts_.append (execVol_);
   myScenAtts_.append (subVol_);
   }

//------------------------------------------------------------------------------
// Implementation of class ScenAtt.
//------------------------------------------------------------------------------

WitScenAtt::~WitScenAtt ()
   {
   }

//------------------------------------------------------------------------------

void WitScenAtt::downloadInputToCurScen ()
   {
   }

//------------------------------------------------------------------------------

WitScenAtt::WitScenAtt (WitScenAttMgr * theScenAttMgr):

      WitProbAssoc (theScenAttMgr),
      myScenMgr_   (theScenAttMgr->myScenMgr ())
   {
   }

//------------------------------------------------------------------------------
// Implementation of class OwnedScenAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitOwnedScenAtt <Owner>::WitOwnedScenAtt (WitScenAttMgr * theScenAttMgr):

         WitScenAtt (theScenAttMgr),
         myValue_   (myProblem ()),
         allOwners_ (allOwnersFor (theScenAttMgr))
   {
   Owner * theOwner;

   forEachEl (theOwner, allOwners_)
      {
      myValue_.setMapFor (theOwner, * new WitSchedule <WitScenario, double>);

      myValue_ (theOwner).allocate (myProblem (), 0.0);
      }
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitOwnedScenAtt <Owner>::~WitOwnedScenAtt ()
   {
   Owner * theOwner;

   forEachEl (theOwner, allOwners_)
      delete & (myValue_ (theOwner));
   }

//------------------------------------------------------------------------------
// Non-parametric implemenation of member function
// OwnedScenAtt <Owner>::allOwnersFor (...).
//------------------------------------------------------------------------------

const WitList <WitPart> & WitOwnedScenAtt <WitPart>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
   {
   return theScenAttMgr->myCompMgr ()->allParts ();
   }

//------------------------------------------------------------------------------

const WitList <WitMaterial> & WitOwnedScenAtt <WitMaterial>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
   {
   return theScenAttMgr->allMats ();
   }

//------------------------------------------------------------------------------

const WitList <WitDemand> & WitOwnedScenAtt <WitDemand>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
   {
   return theScenAttMgr->allDemands ();
   }

//------------------------------------------------------------------------------

const WitList <WitOperation> & WitOwnedScenAtt <WitOperation>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
   {
   return theScenAttMgr->myCompMgr ()->allOperations ();
   }

//------------------------------------------------------------------------------

const WitList <WitSubEntry> & WitOwnedScenAtt <WitSubEntry>::allOwnersFor (
      WitScenAttMgr * theScenAttMgr)
   {
   return theScenAttMgr->allSubs ();
   }

//------------------------------------------------------------------------------
// Implementation of class ScenInputAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitScenInputAtt <Owner>::WitScenInputAtt (
            WitScenAttMgr * theScenAttMgr,
            AccFunc         theAccFunc):

         WitOwnedScenAtt <Owner> (theScenAttMgr),
         myAccFunc_              (theAccFunc)
   {
   WitScenario * theScenario;

   forEachEl (theScenario, myScenMgr ()->myScenarios ())
      downloadInputTo (theScenario);
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitScenInputAtt <Owner>::~WitScenInputAtt ()
   {
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::downloadInputToCurScen ()
   {
   downloadInputTo (myScenMgr ()->curScenario ());
   }

//------------------------------------------------------------------------------

template <typename Owner>
      void WitScenInputAtt <Owner>::downloadInputTo (
         WitScenario * theScenario)
   {
   Owner * theOwner;

   forEachEl (theOwner, allOwners ())
      myValue (theOwner, theScenario) = (theOwner->*myAccFunc_) ();
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class ScenInputAtt <Owner>.
//------------------------------------------------------------------------------

template class WitScenInputAtt <WitPart>;
template class WitScenInputAtt <WitDemand>;

//------------------------------------------------------------------------------
// Implementation of class ScenSolnAtt <Owner>.
//------------------------------------------------------------------------------

template <typename Owner>
      WitScenSolnAtt <Owner>::WitScenSolnAtt (WitScenAttMgr * theScenAttMgr):

         WitOwnedScenAtt <Owner> (theScenAttMgr)
   {
   }

//------------------------------------------------------------------------------

template <typename Owner>
      WitScenSolnAtt <Owner>::~WitScenSolnAtt ()
   {
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class ScenSolnAtt <Owner>.
//------------------------------------------------------------------------------

template class WitScenSolnAtt <WitPart>;
template class WitScenSolnAtt <WitMaterial>;
template class WitScenSolnAtt <WitDemand>;
template class WitScenSolnAtt <WitOperation>;
template class WitScenSolnAtt <WitSubEntry>;
@


1.26
log
@Stochastic Implosion
@
text
@d42 1
d116 1
a116 1
      curScenario_->downloadInputAttrs ();
d140 1
a140 1
      curScenario_->downloadInputAttrs ();
d175 1
a175 1
      curScenario_->downloadInputAttrs ();
d224 7
a250 14
void WitScenario::downloadInputAttrs ()
   {
   WitPart * thePart;
   WitDemand * theDemand;

   forEachPart (thePart, myProblem ())
      supplyVol (thePart) = thePart->supplyVol ();

   forEachDemand (theDemand, myProblem ())
      demandVol (theDemand) = theDemand->demandVol ();
   }

//------------------------------------------------------------------------------

d716 1
a716 1
WitScenAttMgr::WitScenAttMgr (WitProblem * theProblem):
d718 2
a719 1
      WitProbAssoc (theProblem),
d752 10
d782 2
a783 2
   supplyVol_ = new WitScenInputAtt <WitPart>   (this);
   demandVol_ = new WitScenInputAtt <WitDemand> (this);
d818 7
a824 1
WitScenAtt::WitScenAtt (WitProblem * theProblem):
d826 2
a827 1
      WitProbAssoc (theProblem)
d838 1
a838 1
         WitScenAtt (theScenAttMgr->myProblem ()),
d864 3
a874 3
// Non-parametric implemenation of member function
// OwnedScenAtt <Owner>::allOwnersFor (...).
//------------------------------------------------------------------------------
d911 3
a913 1
      WitScenInputAtt <Owner>::WitScenInputAtt (WitScenAttMgr * theScenAttMgr):
d915 2
a916 1
         WitOwnedScenAtt <Owner> (theScenAttMgr)
d918 4
d932 20
@


1.25
log
@Stochastic Implosion
@
text
@d41 3
d231 1
a231 11
      probability_ (defProbability ()),

      supplyVol_   (myProblem (), 0.0),
      demandVol_   (myProblem (), 0.0),

      scrapVol_    (),
      stockVol_    (),
      shipVol_     (),
      cumShipVol_  (),
      execVol_     (),
      subVol_      ()
a232 1
   downloadInputAttrsInt ();
d245 2
a246 1
   stronglyAssert (this == myScenMgr_->curScenario ());
d248 5
a252 1
   downloadInputAttrsInt ();
d263 1
a263 1
      thePart->  storeStochSupplyVol (supplyVol_ (thePart));
d266 1
a266 1
      theDemand->storeStochDemandVol (demandVol_ (theDemand));
d280 1
a280 1
      thePart  ->storeStochScrapVol   (scrapVol_   (thePart));
d283 1
a283 1
      theMat   ->storeStochStockVol   (stockVol_   (theMat));
d287 2
a288 2
      theDemand->storeStochShipVol    (shipVol_    (theDemand));
      theDemand->storeStochCumShipVol (cumShipVol_ (theDemand));
d292 1
a292 1
      theOpn   ->storeStochExecVol    (execVol_    (theOpn));
d295 1
a295 1
      theSub   ->storeStochSubVol     (subVol_     (theSub));
a303 7

   scrapVol_  .allocate1D (myProblem ());
   stockVol_  .allocate1D (myProblem ());
   shipVol_   .allocate1D (myProblem ());
   cumShipVol_.allocate1D (myProblem ());
   execVol_   .allocate1D (myProblem ());
   subVol_    .allocate1D (myProblem ());
d310 23
a332 6
   scrapVol_  .clear ();
   stockVol_  .clear ();
   shipVol_   .clear ();
   cumShipVol_.clear ();
   execVol_   .clear ();
   subVol_    .clear ();
d339 3
d343 6
a348 2
   supplyVol_   = theScenario->supplyVol_;
   demandVol_   = theScenario->demandVol_;
d390 2
a391 2
      thisVal =               supplyVol_ (thePart)[thePer];
      thatVal = thatScenario->supplyVol_ (thePart)[thePer];
d417 2
a418 2
      thisVal =               demandVol_ (theDemand)[thePer];
      thatVal = thatScenario->demandVol_ (theDemand)[thePer];
d459 1
a459 1
   storeSolnAttr (scrapVol_ (thePart), thePer, theValue);
d469 1
a469 1
   storeSolnAttr (stockVol_ (theMat), thePer, theValue);
d479 1
a479 1
   storeSolnAttr (shipVol_ (theDemand), thePer, theValue);
d489 1
a489 1
   storeSolnAttr (cumShipVol_ (theDemand), thePer, theValue);
d499 1
a499 1
   storeSolnAttr (execVol_ (theOpn), thePer, theValue);
d509 1
a509 1
   storeSolnAttr (subVol_ (theSub), thePer, theValue);
d514 1
a514 1
int WitScenario::nInstances (WitProblem * theProblem)
d516 1
a516 1
   return theProblem->myStochImpMgr ()->nScenarios ();
d521 1
a521 1
void WitScenario::downloadInputAttrsInt ()
d523 2
a524 2
   WitPart * thePart;
   WitDemand * theDemand;
d526 1
a526 2
   forEachPart (thePart, myProblem ())
      supplyVol_ (thePart) = thePart->supplyVol ();
d528 3
a530 2
   forEachDemand (theDemand, myProblem ())
      demandVol_ (theDemand) = theDemand->demandVol ();
d582 1
a582 1
         supplyVol_ (thePart),
d601 1
a601 1
         demandVol_ (theDemand),
d623 96
d742 1
@


1.24
log
@Stochastic Implosion
@
text
@a625 2
      allParts_    (myCompMgr ()->allParts ()),
      allOpns_     (myCompMgr ()->allOperations ()),
d666 2
a667 2
   supplyVol_ = new WitScenInputAtt <WitPart>   (allParts_,   myProblem ());
   demandVol_ = new WitScenInputAtt <WitDemand> (allDemands_, myProblem ());
d677 6
a682 6
   scrapVol_   = new WitScenSolnAtt <WitPart>      (allParts_,   myProblem ());
   stockVol_   = new WitScenSolnAtt <WitMaterial>  (allMats_,    myProblem ());
   shipVol_    = new WitScenSolnAtt <WitDemand>    (allDemands_, myProblem ());
   cumShipVol_ = new WitScenSolnAtt <WitDemand>    (allDemands_, myProblem ());
   execVol_    = new WitScenSolnAtt <WitOperation> (allOpns_,    myProblem ());
   subVol_     = new WitScenSolnAtt <WitSubEntry>  (allSubs_,    myProblem ());
d713 1
a713 3
      WitOwnedScenAtt <Owner>::WitOwnedScenAtt (
            const WitList <Owner> & theOwners,
            WitProblem *            theProblem):
d715 1
a715 1
         WitScenAtt (theProblem),
d717 1
a717 1
         allOwners_ (theOwners)
d741 43
d788 1
a788 3
      WitScenInputAtt <Owner>::WitScenInputAtt (
            const WitList <Owner> & theOwners,
            WitProblem *            theProblem):
d790 1
a790 1
         WitOwnedScenAtt <Owner> (theOwners, theProblem)
d813 1
a813 3
      WitScenSolnAtt <Owner>::WitScenSolnAtt (
            const WitList <Owner> & theOwners,
            WitProblem *            theProblem):
d815 1
a815 1
         WitOwnedScenAtt <Owner> (theOwners, theProblem)
@


1.23
log
@Stochastic Implosion
@
text
@d625 6
a630 1
      subVol_      (NULL)
d632 1
d648 18
d668 2
a669 2
   supplyVol_ = new WitScenInputAtt <WitPart>   (myProblem ());
   demandVol_ = new WitScenInputAtt <WitDemand> (myProblem ());
d679 6
a684 6
   scrapVol_   = new WitScenSolnAtt <WitPart>      (myProblem ());
   stockVol_   = new WitScenSolnAtt <WitMaterial>  (myProblem ());
   shipVol_    = new WitScenSolnAtt <WitDemand>    (myProblem ());
   cumShipVol_ = new WitScenSolnAtt <WitDemand>    (myProblem ());
   execVol_    = new WitScenSolnAtt <WitOperation> (myProblem ());
   subVol_     = new WitScenSolnAtt <WitSubEntry>  (myProblem ());
d715 3
a717 1
      WitOwnedScenAtt <Owner>::WitOwnedScenAtt (WitProblem * theProblem):
d721 1
a721 1
         allOwners_ ()
a724 2
   findAllOwners ();

a744 53
// Non-parametric implementation of member function
// OwnedScenAtt <Owner>::findAllOwners ().
//------------------------------------------------------------------------------

void WitOwnedScenAtt <WitPart>::findAllOwners ()
   {
   WitPart * thePart;

   forEachPart (thePart, myProblem ())
      allOwners_.append (thePart);
   }

//------------------------------------------------------------------------------

void WitOwnedScenAtt <WitMaterial>::findAllOwners ()
   {
   WitMaterial * theMat;

   forEachMaterial (theMat, myProblem ())
      allOwners_.append (theMat);
   }

//------------------------------------------------------------------------------

void WitOwnedScenAtt <WitDemand>::findAllOwners ()
   {
   WitDemand * theDemand;

   forEachDemand (theDemand, myProblem ())
      allOwners_.append (theDemand);
   }

//------------------------------------------------------------------------------

void WitOwnedScenAtt <WitOperation>::findAllOwners ()
   {
   WitOperation * theOpn;

   forEachOperation (theOpn, myProblem ())
      allOwners_.append (theOpn);
   }

//------------------------------------------------------------------------------

void WitOwnedScenAtt <WitSubEntry>::findAllOwners ()
   {
   WitSubEntry * theSub;

   forEachSubEntry (theSub, myProblem ())
      allOwners_.append (theSub);
   }

//------------------------------------------------------------------------------
d749 3
a751 1
      WitScenInputAtt <Owner>::WitScenInputAtt (WitProblem * theProblem):
d753 1
a753 1
         WitOwnedScenAtt <Owner> (theProblem)
d776 3
a778 1
      WitScenSolnAtt <Owner>::WitScenSolnAtt (WitProblem * theProblem):
d780 1
a780 1
         WitOwnedScenAtt <Owner> (theProblem)
@


1.22
log
@Stochastic Implosion
@
text
@d693 3
a695 1
         WitScenAtt (theProblem)
d697 10
d714 57
@


1.21
log
@Stochastic Implosion
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d17 5
d26 2
d112 1
a112 1
      curScenario_->saveInputAttrs ();
d136 1
a136 1
      curScenario_->saveInputAttrs ();
d171 1
a171 1
      curScenario_->saveInputAttrs ();
d240 1
a240 1
   saveInputAttrsInt ();
d251 1
a251 1
void WitScenario::saveInputAttrs ()
d255 1
a255 1
   saveInputAttrsInt ();
d507 1
a507 1
void WitScenario::saveInputAttrsInt ()
d607 149
@


1.20
log
@Stochastic Implosion
@
text
@d259 1
a259 1
      thePart->  loadInStochSupplyVol (supplyVol_ (thePart));
d262 1
a262 1
      theDemand->loadInStochDemandVol (demandVol_ (theDemand));
d276 1
a276 1
      thePart  ->loadInStochScrapVol   (scrapVol_   (thePart));
d279 1
a279 1
      theMat   ->loadInStochStockVol   (stockVol_   (theMat));
d283 2
a284 2
      theDemand->loadInStochShipVol    (shipVol_    (theDemand));
      theDemand->loadInStochCumShipVol (cumShipVol_ (theDemand));
d288 1
a288 1
      theOpn   ->loadInStochExecVol    (execVol_    (theOpn));
d291 1
a291 1
      theSub   ->loadInStochSubVol     (subVol_     (theSub));
d433 1
a433 1
void WitScenario::loadInScrapVol (
d438 1
a438 1
   loadInSolnAttr (scrapVol_ (thePart), thePer, theValue);
d443 1
a443 1
void WitScenario::loadInStockVol (
d448 1
a448 1
   loadInSolnAttr (stockVol_ (theMat), thePer, theValue);
d453 1
a453 1
void WitScenario::loadInShipVol (
d458 1
a458 1
   loadInSolnAttr (shipVol_ (theDemand), thePer, theValue);
d463 1
a463 1
void WitScenario::loadInCumShipVol (
d468 1
a468 1
   loadInSolnAttr (cumShipVol_ (theDemand), thePer, theValue);
d473 1
a473 1
void WitScenario::loadInExecVol (
d478 1
a478 1
   loadInSolnAttr (execVol_ (theOpn), thePer, theValue);
d483 1
a483 1
void WitScenario::loadInSubVol (
d488 1
a488 1
   loadInSolnAttr (subVol_ (theSub), thePer, theValue);
d514 1
a514 1
void WitScenario::loadInSolnAttr (
@


1.19
log
@Stochastic Implosion
@
text
@d172 1
a172 1
      myStochModeMgr_->exportSoln ();
d267 29
@


1.18
log
@Stochastic Implosion
@
text
@d135 1
a135 1
      myStochModeMgr_->exportInput ();
d146 1
a146 1
   myStochModeMgr_->exportInput ();
d168 1
a168 1
   myStochModeMgr_->exportInput ();
d218 14
a231 15
      WitProbAssoc  (theScenMgr),
      myScenMgr_    (theScenMgr),
      myIndex_      (theIdx),
      probability_  (defProbability ()),

      supplyVol_    (myProblem (), 0.0),
      demandVol_    (myProblem (), 0.0),
      cumDemandVol_ (myProblem (), 0.0),

      scrapVol_     (),
      stockVol_     (),
      shipVol_      (),
      cumShipVol_   (),
      execVol_      (),
      subVol_       ()
d253 14
d296 3
a298 4
   probability_  = theScenario->probability_;
   supplyVol_    = theScenario->supplyVol_;
   demandVol_    = theScenario->demandVol_;
   cumDemandVol_ = theScenario->cumDemandVol_;
d480 1
a480 4
      {
      demandVol_    (theDemand) = theDemand->demandVol    ();
      cumDemandVol_ (theDemand) = theDemand->cumDemandVol ();
      }
@


1.17
log
@Stochastic Implosion
@
text
@d154 1
a154 1
   checkNonRecAtts    ();
d198 1
a198 1
void WitScenMgr::checkNonRecAtts ()
d209 1
a209 1
               checkNonRecAtts (theScenario1, theScenario2);
d332 1
a332 1
         myMsgFac () ("nonRecPartAttMisMatchSmsg",
d359 1
a359 1
         myMsgFac () ("nonRecDemAttMisMatchSmsg",
@


1.16
log
@Stochastic Implosion
@
text
@d44 1
a44 1
      myScenByIdx_    (myStochImpMgr ()->nScenarios ()),
d52 1
a52 1
      theScenario          = new WitScenario (this, theIdx);
d56 1
a56 1
      myScenByIdx_[theIdx] = theScenario;
d59 1
a59 1
   curScenario_ = myScenByIdx_[0];
d70 1
a70 1
   myScenByIdx_.clear ();
d86 1
a86 1
   curScenario_  = myScenByIdx_[theIdx];
d92 1
a92 1
      origScenario = theScenMgr->myScenByIdx_[theIdx];
d112 1
a112 1
   curScenario_->writeScenarioIndex ();
d159 1
a159 1
void WitScenMgr::setScenarioIndex (int theIdx)
d161 1
a161 1
   myProblem ()->prepSetStochModeAttr ("scenarioIndex");
d166 1
a166 1
   curScenario_ = myScenByIdx_[theIdx];
d295 1
a295 1
   writeScenarioIndex ();
d305 1
a305 1
void WitScenario::writeScenarioIndex ()
d311 1
a311 1
      "scenarioIndex",
@


1.15
log
@Stochastic Implosion
@
text
@d139 1
a139 1
         curScenario_->scenarioProb ());
d153 1
a153 1
   checkScenarioProbs ();
d182 1
a182 1
void WitScenMgr::checkScenarioProbs ()
d190 1
a190 1
      totProb += theScenario->scenarioProb ();
d221 1
a221 1
      scenarioProb_ (defScenarioProb ()),
d283 1
a283 1
   scenarioProb_ = theScenario->scenarioProb_;
d297 1
a297 1
   writeScenarioProb ();
d373 1
a373 1
double WitScenario::defScenarioProb ()
d380 1
a380 1
void WitScenario::setScenarioProb (double theValue)
d385 1
a385 1
   myProblem ()->prepSetStochModeAttr ("scenarioProb");
d387 1
a387 1
   scenarioProb_ = theValue;
d495 1
a495 1
void WitScenario::writeScenarioProb ()
d497 1
a497 1
   if (scenarioProb_ == defScenarioProb ())
d504 3
a506 3
      "scenarioProb",
       scenarioProb_,
       defScenarioProb ());
@


1.14
log
@Stochastic Implosion
@
text
@a181 9
void WitScenMgr::setScenarioForImplode (WitScenario * theScenario)
   {
   curScenario_ = theScenario;

   myStochModeMgr_->exportInput ();
   }

//------------------------------------------------------------------------------

a253 38
void WitScenario::saveSolnAttrs ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   stronglyAssert (this == myScenMgr_->curScenario ());

   scrapVol_  .allocate (myProblem (), 0.0);
   stockVol_  .allocate (myProblem (), 0.0);
   shipVol_   .allocate (myProblem (), 0.0);
   cumShipVol_.allocate (myProblem (), 0.0);
   execVol_   .allocate (myProblem (), 0.0);
   subVol_    .allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      scrapVol_   (thePart)   = thePart  ->scrapVol   ();

   forEachMaterial (theMat, myProblem ())
      stockVol_   (theMat)    = theMat   ->stockVol   ();

   forEachDemand (theDemand, myProblem ())
      {
      shipVol_    (theDemand) = theDemand->shipVol    ();
      cumShipVol_ (theDemand) = theDemand->cumShipVol ();
      }

   forEachOperation (theOpn, myProblem ())
      execVol_    (theOpn)    = theOpn   ->execVol    ();

   forEachSubEntry (theSub, myProblem ())
      subVol_     (theSub)    = theSub   ->subVol     ();
   }

//------------------------------------------------------------------------------

@


1.13
log
@Stochastic Implosion
@
text
@d439 1
a439 1
void WitScenario::setScrapVol (
d444 1
a444 1
   setSolnAttr (scrapVol_ (thePart), thePer, theValue);
d449 1
a449 1
void WitScenario::setStockVol (
d454 1
a454 1
   setSolnAttr (stockVol_ (theMat), thePer, theValue);
d459 4
a462 4
void WitScenario::setExecVol (
      WitOperation * theOpn,
      WitPeriod      thePer,
      double         theValue)
d464 1
a464 1
   setSolnAttr (execVol_ (theOpn), thePer, theValue);
d469 1
a469 1
void WitScenario::setShipVol (
d474 1
a474 1
   setSolnAttr (shipVol_ (theDemand), thePer, theValue);
d479 14
a492 4
void WitScenario::setCumShipVol (
      WitDemand * theDemand,
      WitPeriod   thePer,
      double      theValue)
d494 1
a494 1
   setSolnAttr (cumShipVol_ (theDemand), thePer, theValue);
d523 1
a523 1
void WitScenario::setSolnAttr (
@


1.12
log
@Stochastic Implosion
@
text
@a280 1
      {
a281 1
      }
a283 1
      {
a284 1
      }
a292 1
      {       
a293 1
      }
a295 1
      {       
a296 1
      }
d449 10
@


1.11
log
@Stochastic Implosion
@
text
@d234 1
d341 1
d503 4
a506 1
      demandVol_ (theDemand) = theDemand->demandVol ();
@


1.10
log
@Stochastic Implosion
@
text
@d27 1
d174 2
d465 20
@


1.9
log
@Stochastic Implosion
@
text
@d491 3
@


1.8
log
@Stochastic Implosion
@
text
@d24 1
d305 15
d442 20
d483 16
d523 1
a523 1
      myScenMgr_->myStochModeMgr ()->startWriteCompData (thePart);
d530 1
a530 1
      myScenMgr_->myStochModeMgr ()->finishWriteCompData ();
d542 1
a542 1
      myScenMgr_->myStochModeMgr ()->startWriteCompData (theDemand);
d549 1
a549 1
      myScenMgr_->myStochModeMgr ()->finishWriteCompData ();
d552 14
@


1.7
log
@Stochastic Implosion
@
text
@d38 1
a38 2
      WitProbAssoc    (theStochModeMgr->myProblem ()),

d223 1
a223 2
      WitProbAssoc  (theScenMgr->myProblem ()),

@


1.6
log
@Stochastic Implosion
@
text
@d428 7
@


1.5
log
@Stochastic Implosion
@
text
@d229 1
@


1.4
log
@Stochastic Implosion
@
text
@d355 1
a355 3
void WitScenario::checkStochAttsMatch (
      WitPart *     thePart,
      WitScenario * thatScenario)
d380 1
a380 1
void WitScenario::checkStochAttsMatch (
@


1.3
log
@Stochastic Implosion
@
text
@d206 2
a207 2
   WitScenario * firstScenario;
   WitScenario * otherScenario;
d209 1
a209 1
   firstScenario = myScenByIdx_[0];
d211 5
a215 3
   forEachEl (otherScenario, myScenarios_)
      if (otherScenario != firstScenario)
         firstScenario->checkNonRecAtts (otherScenario);
d355 3
a357 1
void WitScenario::checkNonRecAtts (WitScenario * otherScenario)
d359 47
a405 2
   checkNonRecPartAtts   (otherScenario);
   checkNonRecDemandAtts (otherScenario);
a495 75

//------------------------------------------------------------------------------

void WitScenario::checkNonRecPartAtts (WitScenario * otherScenario)
   {
   WitPart * thePart;
   bool      recPart;
   WitPeriod thePer;
   double    supVol1;
   double    supVol2;

   forEachPart (thePart, myProblem ())
      {
      recPart =
         myScenMgr_->
            myStochModeMgr ()->
               myStageMgr ()->
                  recourseStage () (thePart);

      if (not recPart)
         forEachPeriod (thePer, myProblem ())
            {
            supVol1 =                supplyVol_ (thePart)[thePer];
            supVol2 = otherScenario->supplyVol_ (thePart)[thePer];

            if (supVol1 != supVol2)
               myMsgFac () ("nonRecPartAttMisMatchSmsg",
                  "supplyVol",
                  thePart->partName (),
                  thePer,
                  myIndex_,
                  supVol1,
                  otherScenario->myIndex_,
                  supVol2);
            }
      }
   }

//------------------------------------------------------------------------------

void WitScenario::checkNonRecDemandAtts (WitScenario * otherScenario)
   {
   WitDemand * theDemand;
   bool        recDem;
   WitPeriod   thePer;
   double      demVol1;
   double      demVol2;

   forEachDemand (theDemand, myProblem ())
      {
      recDem =
         myScenMgr_->
            myStochModeMgr ()->
               myStageMgr ()->
                  recourseStage () (theDemand->demandedPart ());

      if (not recDem)
         forEachPeriod (thePer, myProblem ())
            {
            demVol1 =                demandVol_ (theDemand)[thePer];
            demVol2 = otherScenario->demandVol_ (theDemand)[thePer];

            if (demVol1 != demVol2)
               myMsgFac () ("nonRecDemAttMisMatchSmsg",
                  "demandVol",
                  theDemand->demandedPartName (),
                  theDemand->demandName (),
                  thePer,
                  myIndex_,
                  demVol1,
                  otherScenario->myIndex_,
                  demVol2);
            }
      }
   }
@


1.2
log
@Stochastic Implosion
@
text
@d116 7
a149 7
void WitScenMgr::displayGlobalData ()
   {
   myMsgFac () ("stochImploderDdMsg", curScenario_->myIndex ());
   }

//------------------------------------------------------------------------------

@


1.1
log
@Stochastic Implosion
@
text
@d116 1
a116 1
void WitScenMgr::display ()
d118 1
a118 1
   WitScenario * theScenario;
d123 22
a145 3

   forEachEl (theScenario, myScenarios_)
      theScenario->display ();
a352 12
void WitScenario::display ()
   {
   myMsgFac () ("scenarioDdMsg",
      myIndex_,
      scenarioProb_);

   displayPartData   ();
   displayDemandData ();
   }

//------------------------------------------------------------------------------

a449 36
void WitScenario::displayPartData ()
   {
   WitPart *     thePart;
   WitDblFlexVec theDblFlexVec (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      myMsgFac () ("partIdDdMsg", thePart->partName ());

      theDblFlexVec = supplyVol_ (thePart);

      myProblem ()->display ("extSupplyVolDdMsg", theDblFlexVec);
      }
   }

//------------------------------------------------------------------------------

void WitScenario::displayDemandData ()
   {
   WitDemand *   theDemand;
   WitDblFlexVec theDblFlexVec (myProblem (), 0.0);

   forEachDemand (theDemand, myProblem ())
      {
      myMsgFac () ("demandIdDdMsg",
         theDemand->demandedPartName (),
         theDemand->demandName ());

      theDblFlexVec = demandVol_ (theDemand);

      myProblem ()->display ("demVolDdMsg", theDblFlexVec);
      }
   }

//------------------------------------------------------------------------------

@


head	1.61;
access;
symbols
	sce_5_01_20080919:1.53
	latest_sce_4_20_20060523:1.49.0.4
	sce_4_20_20060523:1.49
	latest_sce4_20_OSL:1.49.0.2
	sce_4_20_OSL:1.49
	sce_410_withVa:1.46
	sce_4_05_20040511:1.35
	sce_4_00_20040201:1.35
	nextGenBranch:1.33.0.2
	nextGenRoot:1.33
	sce_3_30_20030627:1.33
	EndRw-branch:1.13.0.2
	Root-of-EndRw:1.13
	rwToStl:1.10.0.2;
locks; strict;
comment	@ * @;


1.61
date	2011.09.28.23.50.12;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2011.09.24.00.28.39;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2011.08.30.20.18.11;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.10.22.10.41;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.10.14.59.26;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.29.23.25.15;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2010.06.29.22.32.32;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2010.03.16.22.42.28;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.12.16.30.12;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.09.00.40.48;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.01.21.28.06;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.27.22.17.33;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.03.16.48.13;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.05.22.24.09;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.15.21.27.24;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.28.20.14.38;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.22.21.45.54;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.22.19.09.34;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.02.23.17.53;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.03.21.31.35;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.02.02.19.31.22;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.27.21.03.28;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.26.23.50.33;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.11.21.07.58;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.10.21.58.31;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.09.19.22.51;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.02.20.46.44;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.29.19.55.33;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.19.16.48.28;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.07.23.46.17;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.06.20.28.24;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.14.20.13.02;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.27.21.17.19;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.13.22.22.14;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.02.23.40.50;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.02.22.18.50;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.17.21.32.52;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.16.16.41.22;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.14.00.55.49;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.13.00.07.58;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.06.20.38.25;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.05.19.32.53;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.04.23.37.54;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.04.22.38.58;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.04.19.17.58;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.03.00.43.29;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.26.23.28.51;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.22.21.18.00;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.21.22.54.00;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.15.20.27.14;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.30.23.47.32;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.18.22.23.57;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.11.18.53.17;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.04.21.53.37;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.25.22.47.32;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.25.17.43.54;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.24.23.15.17;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.24.18.38.11;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.23.15.18.32;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.22.19.34.00;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "SglSrcMgr.C"
//
// Contains the implementation of class SglSrcMgr.
//------------------------------------------------------------------------------

#include <SglSrcMgr.h>
#include <SglSrcSite.h>
#include <Selector.h>
#include <SelPt.h>
#include <RtSite.h>
#include <RtCand.h>
#include <RtMgr.h>
#include <MrMgr.h>
#include <HeurAtor.h>
#include <Part.h>
#include <Operation.h>
#include <BopEntry.h>
#include <SubEntry.h>
#include <Demand.h>
#include <GlobalComp.h>
#include <CompMgr.h>
#include <DataRepos.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------

WitSglSrcMgr::WitSglSrcMgr (WitSelector * theSelector):

      WitProbAssoc       (theSelector),
      mySelector_        (theSelector),
      myRtMgr_           (theSelector->myRtMgr ()),
      mySglSrcSiteFor_   (myProblem ()),
      alteredSites_      (myProblem ()),
      cmqMode_           (false),
      curPermCommIdx_    (0),
      curVisitSites_     (myProblem ()),
      incumbVisitSites_  (myProblem ()),
      pureMsMode_        (true),
      initAllocRepos_    (NULL),
      initConfigRepos_   (NULL),
      incumbAllocRepos_  (NULL),
      incumbConfigRepos_ (NULL),

      nCmq_              (0),
      nCmqFixed_         (0),
      nFullAlloc_        (0),
      nNonFullAlloc_     (0),
      nOpps_             (0),
      nDiscovered_       (0),
      nTested_           (0),
      nAccepted_         (0),
      nRejected_         (0)
   {
   WitRtSite * theRtSite;

   verifyRestrictions ();

   myMsgFac () ("sglSrcMsg");

   initAllocRepos_    = new WitDataRepos (myProblem ());
   initConfigRepos_   = new WitDataRepos (myProblem ());
   incumbAllocRepos_  = new WitDataRepos (myProblem ());
   incumbConfigRepos_ = new WitDataRepos (myProblem ());

   forEachEl (theRtSite, myRtMgr_->myRtSites ())
      if (theRtSite->myRtCands ().nElements () > 1)
         if (theRtSite->singleSource ())
            if (mySelector_->myMrMgr ()->multiChoice (theRtSite))
               mySglSrcSiteFor_ (theRtSite) = new WitSglSrcSite (theRtSite);
   }

//------------------------------------------------------------------------------

WitSglSrcMgr::~WitSglSrcMgr ()
   {
   WitRtSite * theRtSite;

   if (DEVELOPMENT)
      myMsgFac () ("sglSrcCountsMsg",
         nCmq_,
         nCmqFixed_,
         nFullAlloc_,
         nNonFullAlloc_,
         nOpps_,
         nDiscovered_,
         nTested_,
         nAccepted_,
         nRejected_);

   forEachEl (theRtSite, myRtMgr_->myRtSites ())
      delete mySglSrcSiteFor_ (theRtSite);

   delete incumbConfigRepos_;
   delete incumbAllocRepos_;
   delete initConfigRepos_;
   delete initAllocRepos_;
   }

//------------------------------------------------------------------------------

bool WitSglSrcMgr::sglSrcReq (WitProblem * theProblem)
   {
   WitPart *     thePart;
   WitBomEntry * theBomEnt;

   forEachPart (thePart, theProblem)
      if (thePart->singleSource ())
         return true;

   forEachBomEntry (theBomEnt, theProblem)
      if (theBomEnt->singleSource ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::commitMaxQty (double & netQty)
   {
   bool            fullAlloc;
   WitSglSrcSite * oppSite;

   stronglyAssert (not cmqMode_);

   cmqMode_ = true;

   nCmq_ ++;

   initMsAlloc (netQty, fullAlloc);

   if (not fullAlloc)
      {
      cmqMode_ = false;

      return;
      }

   while (true)
      {
      oppSite = nextOpp ();

      if (oppSite == NULL)
         break;

      nOpps_ ++;

      if (oppSite->nextCandIsSglSrc ())
         selectDiscovery (oppSite);
      else
         tryNextCand (netQty, oppSite);
      }

   preserveIncumb ();

   netQty = 0.0;

   cmqMode_ = false;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::recPermCommit ()
   {
   curPermCommIdx_ ++;

   if (selPrintLevelAt (2))
      fprintf (msgFile (),
         "\n"
         "Perm-Commit #%d\n",
         curPermCommIdx_);
   }

//------------------------------------------------------------------------------

bool WitSglSrcMgr::expProhibited (WitPart * thePart, WitPeriod expPer)
   {
   WitRtSite *     theRtSite;
   WitSglSrcSite * theSite;

   theRtSite = myRtMgr_->myRtSiteFor (thePart);

   theSite   = mySglSrcSiteFor_ (theRtSite);

   return expProhibited (theSite, expPer);
   }

//------------------------------------------------------------------------------

bool WitSglSrcMgr::expProhibited (WitOperation * theOpn, WitPeriod execPer)
   {
   WitBomEntry *   theBomEnt;
   WitRtSite *     theRtSite;
   WitSglSrcSite * theSite;

   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->inEffect (execPer))
         {
         theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

         theSite   = mySglSrcSiteFor_ (theRtSite);

         if (expProhibited (theSite, execPer))
            return true;
         }

   return false;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::recExp (WitBillEntry * theBillEnt)
   {
   WitRtCand *     theRtCand;
   WitSglSrcSite * theSite;

   theRtCand = myRtMgr_->myRtCandFor (theBillEnt);

   theSite   = mySglSrcSiteFor_ (theRtCand->myRtSite ());

   if (theSite == NULL)
      return;

   if (mySelector_->myHeurAtor ()->permCommActive ())
      if (theSite->curPcIdx () == -1)
         curVisitSites_.push (theSite);

   theSite->recordVisit (theRtCand, curPermCommIdx_);
   }

//------------------------------------------------------------------------------

bool WitSglSrcMgr::sglSrcMode (WitRtSite * theRtSite)
   {
   WitSglSrcSite * theSite;

   theSite = mySglSrcSiteFor_ (theRtSite);

   if (theSite != NULL)
      if (theSite->sglSrcMode ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveAllocVal (int & theVar)
   {
   if (cmqMode_)
      initAllocRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveAllocVal (double & theVar)
   {
   if (cmqMode_)
      initAllocRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveExecVol (WitOperation * theOpn, WitPeriod thePer)
   {
   if (cmqMode_)
      initAllocRepos_->saveExecVol (theOpn, thePer);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveSubVol (WitSubEntry * theSub, WitPeriod thePer)
   {
   if (cmqMode_)
      initAllocRepos_->saveSubVol (theSub, thePer);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveConfigVal (bool & theVar)
   {                                       
   if (cmqMode_)
      initConfigRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveConfigVal (int & theVar)
   {                                       
   if (cmqMode_)
      initConfigRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveConfigObjByVPVal (void * & theVar)
   {
   if (cmqMode_)
      initConfigRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::verifyRestrictions ()
   {
   WitDemand * theDemand;

   stronglyAssert (sglSrcReq (myProblem ()));

   if (mySelector_->penExec ())
      myMsgFac () ("sglSrcAndPenExecSmsg");

   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("sglSrcAndCritListSmsg");

   if (myGlobalComp ()->pgdCritListMode ())
      myMsgFac () ("pgdCritListSglSrcSmsg");

   if (myGlobalComp ()->equitability () > 1)
      myMsgFac () ("sglSrcAndEqAllSmsg");

   forEachDemand (theDemand, myProblem ())
      if (theDemand->buildAheadUB () != 0)
         myMsgFac () ("sglSrcAndBaByDemSmsg");
   }

//------------------------------------------------------------------------------

bool WitSglSrcMgr::expProhibited (WitSglSrcSite * theSite, WitPeriod thePer)
   {
   if (theSite != NULL)
      if (theSite->expProhibited (thePer))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::initMsAlloc (double & netQty, bool & fullAlloc)
   {
   double newNetQty;

   pureMsMode_ = true;

   cmqFixed (netQty, newNetQty);

   fullAlloc =
      (newNetQty <= SEARCH_TOL * mySelector_->myHeurAtor ()->searchInc ());

   if (fullAlloc)
      {
      nFullAlloc_ ++;

      saveCurAsIncumb ();
      }
   else
      {
      nNonFullAlloc_ ++;

      initAllocRepos_ ->clear ();
      initConfigRepos_->clear ();

      netQty = newNetQty;

      if (selPrintLevelAt (2))
         prtNonFull ();
      }
   }

//------------------------------------------------------------------------------

WitSglSrcSite * WitSglSrcMgr::nextOpp ()
   {
   WitObjStItr <WitSglSrcSite> theItr;
   WitSglSrcSite *             theSite;
   WitSglSrcSite *             oppSite;

   oppSite = NULL;

   incumbVisitSites_.attachItr (theItr);

   while (theItr.advance (theSite))
      if (not theSite->sglSrcMode ())
         if (theSite->hasUntried ())
            if (theSite->isPreferredTo (oppSite))
               oppSite = theSite;

   return oppSite;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::selectDiscovery (WitSglSrcSite * theSite)
   {
   nDiscovered_ ++;

   if (not theSite->altered ())
      alteredSites_.push (theSite);

   theSite->selectNext ();

   pureMsMode_ = false;

   if (selPrintLevelAt (2))
      theSite->prtSel ("Discovered");
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::tryNextCand (double netQty, WitSglSrcSite * theSite)
   {
   double newNetQty;

   nTested_ ++;

   if (not theSite->altered ())
      alteredSites_.push (theSite);

   theSite->selectNext ();

   if (selPrintLevelAt (2))
      theSite->prtSel ("Tested");

   theSite->applySel ();

   cmqFixed (netQty, newNetQty);

   if (newNetQty <= SEARCH_TOL * mySelector_->myHeurAtor ()->searchInc ())
      {
      nAccepted_ ++;

      saveCurAsIncumb ();

      pureMsMode_ = false;

      if (selPrintLevelAt (2))
         theSite->prtSel ("Accepted");
      }
   else
      {
      nRejected_ ++;

      initAllocRepos_ ->restore ();
      initConfigRepos_->restore ();

      if (selPrintLevelAt (2))
         theSite->prtSel ("Rejected");

      theSite->resumeMS ();
      }
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveCurAsIncumb ()
   {
   WitObjStItr <WitSglSrcSite> theItr;
   WitSglSrcSite *             theSite;

   initAllocRepos_ ->restoreAndSave (incumbAllocRepos_);
   initConfigRepos_->restoreAndSave (incumbConfigRepos_);

   while (incumbVisitSites_.pop (theSite))
      theSite->resetIncumb ();

   curVisitSites_.attachItr (theItr);

   while (theItr.advance (theSite))
      {
      incumbVisitSites_.push (theSite);

      theSite->saveCurAsIncumb ();
      }
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::preserveIncumb ()
   {
   WitSglSrcSite * theSite;

   if (pureMsMode_)
      incumbConfigRepos_->restore ();
   else
      incumbConfigRepos_->clear ();

   incumbAllocRepos_->restore ();

   while (alteredSites_.pop (theSite))
      theSite->reset ();
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::prtNonFull ()
   {
   fprintf (msgFile (),
      "\n"
      "------------------------------------\n"
      "-> Full Allocation Was Not Achieved.\n"
      "-> Multi-Source Allocation Used.    \n"
      "------------------------------------\n"
      "\n");
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::cmqFixed (double netQty, double & newNetQty)
   {
   WitSglSrcSite *             theSite;
   WitObjStItr <WitSglSrcSite> theItr;

   nCmqFixed_ ++;

   while (curVisitSites_.pop (theSite))
      theSite->initCmqFixed ();

   curPermCommIdx_ = 0;
   newNetQty       = netQty;

   alteredSites_.attachItr (theItr);

   while (theItr.advance (theSite))
      theSite->applySel ();

   mySelector_->commitMaxQty (newNetQty);
   }
@


1.60
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 14
@


1.59
log
@Revised the copyright date.
@
text
@d30 42
a71 42
WitProbAssoc       (theSelector),
mySelector_        (theSelector),
myRtMgr_           (theSelector->myRtMgr ()),
mySglSrcSiteFor_   (myProblem ()),
alteredSites_      (myProblem ()),
cmqMode_           (false),
curPermCommIdx_    (0),
curVisitSites_     (myProblem ()),
incumbVisitSites_  (myProblem ()),
pureMsMode_        (true),
initAllocRepos_    (NULL),
initConfigRepos_   (NULL),
incumbAllocRepos_  (NULL),
incumbConfigRepos_ (NULL),

nCmq_              (0),
nCmqFixed_         (0),
nFullAlloc_        (0),
nNonFullAlloc_     (0),
nOpps_             (0),
nDiscovered_       (0),
nTested_           (0),
nAccepted_         (0),
nRejected_         (0)
{
WitRtSite * theRtSite;

verifyRestrictions ();

myMsgFac () ("sglSrcMsg");

initAllocRepos_    = new WitDataRepos (myProblem ());
initConfigRepos_   = new WitDataRepos (myProblem ());
incumbAllocRepos_  = new WitDataRepos (myProblem ());
incumbConfigRepos_ = new WitDataRepos (myProblem ());

forEachEl (theRtSite, myRtMgr_->myRtSites ())
if (theRtSite->myRtCands ().nElements () > 1)
if (theRtSite->singleSource ())
if (mySelector_->myMrMgr ()->multiChoice (theRtSite))
mySglSrcSiteFor_ (theRtSite) = new WitSglSrcSite (theRtSite);
}
d76 2
a77 2
{
WitRtSite * theRtSite;
d79 20
a98 20
if (DEVELOPMENT)
myMsgFac () ("sglSrcCountsMsg",
nCmq_,
nCmqFixed_,
nFullAlloc_,
nNonFullAlloc_,
nOpps_,
nDiscovered_,
nTested_,
nAccepted_,
nRejected_);

forEachEl (theRtSite, myRtMgr_->myRtSites ())
delete mySglSrcSiteFor_ (theRtSite);

delete incumbConfigRepos_;
delete incumbAllocRepos_;
delete initConfigRepos_;
delete initAllocRepos_;
}
d103 11
a113 11
{
WitPart *     thePart;
WitBomEntry * theBomEnt;

forEachPart (thePart, theProblem)
if (thePart->singleSource ())
return true;

forEachBomEntry (theBomEnt, theProblem)
if (theBomEnt->singleSource ())
return true;
d115 2
a116 2
return false;
}
d121 3
a123 3
{
bool            fullAlloc;
WitSglSrcSite * oppSite;
d125 1
a125 1
stronglyAssert (not cmqMode_);
d127 1
a127 1
cmqMode_ = true;
d129 1
a129 1
nCmq_ ++;
d131 1
a131 1
initMsAlloc (netQty, fullAlloc);
d133 3
a135 3
if (not fullAlloc)
{
cmqMode_ = false;
d137 2
a138 2
return;
}
d140 3
a142 3
while (true)
{
oppSite = nextOpp ();
d144 2
a145 2
if (oppSite == NULL)
break;
d147 1
a147 1
nOpps_ ++;
d149 5
a153 5
if (oppSite->nextCandIsSglSrc ())
selectDiscovery (oppSite);
else
tryNextCand (netQty, oppSite);
}
d155 1
a155 1
preserveIncumb ();
d157 1
a157 1
netQty = 0.0;
d159 2
a160 2
cmqMode_ = false;
}
d165 2
a166 2
{
curPermCommIdx_ ++;
d168 6
a173 6
if (selPrintLevelAt (2))
fprintf (msgFile (),
"\n"
"Perm-Commit #%d\n",
curPermCommIdx_);
}
d178 3
a180 3
{
WitRtSite *     theRtSite;
WitSglSrcSite * theSite;
d182 1
a182 1
theRtSite = myRtMgr_->myRtSiteFor (thePart);
d184 1
a184 1
theSite   = mySglSrcSiteFor_ (theRtSite);
d186 2
a187 2
return expProhibited (theSite, expPer);
}
d192 15
a206 15
{
WitBomEntry *   theBomEnt;
WitRtSite *     theRtSite;
WitSglSrcSite * theSite;

forEachEl (theBomEnt, theOpn->bom ())
if (theBomEnt->inEffect (execPer))
{
theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

theSite   = mySglSrcSiteFor_ (theRtSite);

if (expProhibited (theSite, execPer))
return true;
}
d208 2
a209 2
return false;
}
d214 3
a216 3
{
WitRtCand *     theRtCand;
WitSglSrcSite * theSite;
d218 1
a218 1
theRtCand = myRtMgr_->myRtCandFor (theBillEnt);
d220 1
a220 1
theSite   = mySglSrcSiteFor_ (theRtCand->myRtSite ());
d222 2
a223 2
if (theSite == NULL)
return;
d225 3
a227 3
if (mySelector_->myHeurAtor ()->permCommActive ())
if (theSite->curPcIdx () == -1)
curVisitSites_.push (theSite);
d229 2
a230 2
theSite->recordVisit (theRtCand, curPermCommIdx_);
}
d235 2
a236 2
{
WitSglSrcSite * theSite;
d238 1
a238 1
theSite = mySglSrcSiteFor_ (theRtSite);
d240 3
a242 3
if (theSite != NULL)
if (theSite->sglSrcMode ())
return true;
d244 2
a245 2
return false;
}
d250 4
a253 4
{
if (cmqMode_)
initAllocRepos_->saveVal (theVar);
}
d258 4
a261 4
{
if (cmqMode_)
initAllocRepos_->saveVal (theVar);
}
d266 4
a269 4
{
if (cmqMode_)
initAllocRepos_->saveExecVol (theOpn, thePer);
}
d274 4
a277 4
{
if (cmqMode_)
initAllocRepos_->saveSubVol (theSub, thePer);
}
d282 4
a285 4
{
if (cmqMode_)
initConfigRepos_->saveVal (theVar);
}
d290 4
a293 4
{
if (cmqMode_)
initConfigRepos_->saveVal (theVar);
}
d298 4
a301 4
{
if (cmqMode_)
initConfigRepos_->saveVal (theVar);
}
d306 2
a307 2
{
WitDemand * theDemand;
d309 1
a309 1
stronglyAssert (sglSrcReq (myProblem ()));
d311 2
a312 2
if (mySelector_->penExec ())
myMsgFac () ("sglSrcAndPenExecSmsg");
d314 2
a315 2
if (myGlobalComp ()->computeCriticalList ())
myMsgFac () ("sglSrcAndCritListSmsg");
d317 2
a318 2
if (myGlobalComp ()->pgdCritListMode ())
myMsgFac () ("pgdCritListSglSrcSmsg");
d320 2
a321 2
if (myGlobalComp ()->equitability () > 1)
myMsgFac () ("sglSrcAndEqAllSmsg");
d323 4
a326 4
forEachDemand (theDemand, myProblem ())
if (theDemand->buildAheadUB () != 0)
myMsgFac () ("sglSrcAndBaByDemSmsg");
}
d331 4
a334 4
{
if (theSite != NULL)
if (theSite->expProhibited (thePer))
return true;
d336 2
a337 2
return false;
}
d342 2
a343 2
{
double newNetQty;
d345 1
a345 1
pureMsMode_ = true;
d347 1
a347 1
cmqFixed (netQty, newNetQty);
d349 2
a350 2
fullAlloc =
(newNetQty <= SEARCH_TOL * mySelector_->myHeurAtor ()->searchInc ());
d352 3
a354 3
if (fullAlloc)
{
nFullAlloc_ ++;
d356 5
a360 5
saveCurAsIncumb ();
}
else
{
nNonFullAlloc_ ++;
d362 2
a363 2
initAllocRepos_ ->clear ();
initConfigRepos_->clear ();
d365 1
a365 1
netQty = newNetQty;
d367 4
a370 4
if (selPrintLevelAt (2))
prtNonFull ();
}
}
d375 14
a388 14
{
WitObjStItr <WitSglSrcSite> theItr;
WitSglSrcSite *             theSite;
WitSglSrcSite *             oppSite;

oppSite = NULL;

incumbVisitSites_.attachItr (theItr);

while (theItr.advance (theSite))
if (not theSite->sglSrcMode ())
if (theSite->hasUntried ())
if (theSite->isPreferredTo (oppSite))
oppSite = theSite;
d390 2
a391 2
return oppSite;
}
d396 2
a397 2
{
nDiscovered_ ++;
d399 2
a400 2
if (not theSite->altered ())
alteredSites_.push (theSite);
d402 1
a402 1
theSite->selectNext ();
d404 1
a404 1
pureMsMode_ = false;
d406 3
a408 3
if (selPrintLevelAt (2))
theSite->prtSel ("Discovered");
}
d413 2
a414 2
{
double newNetQty;
d416 1
a416 1
nTested_ ++;
d418 2
a419 2
if (not theSite->altered ())
alteredSites_.push (theSite);
d421 1
a421 1
theSite->selectNext ();
d423 2
a424 2
if (selPrintLevelAt (2))
theSite->prtSel ("Tested");
d426 1
a426 1
theSite->applySel ();
d428 1
a428 1
cmqFixed (netQty, newNetQty);
d430 3
a432 3
if (newNetQty <= SEARCH_TOL * mySelector_->myHeurAtor ()->searchInc ())
{
nAccepted_ ++;
d434 1
a434 1
saveCurAsIncumb ();
d436 1
a436 1
pureMsMode_ = false;
d438 6
a443 6
if (selPrintLevelAt (2))
theSite->prtSel ("Accepted");
}
else
{
nRejected_ ++;
d445 2
a446 2
initAllocRepos_ ->restore ();
initConfigRepos_->restore ();
d448 2
a449 2
if (selPrintLevelAt (2))
theSite->prtSel ("Rejected");
d451 3
a453 3
theSite->resumeMS ();
}
}
d458 3
a460 3
{
WitObjStItr <WitSglSrcSite> theItr;
WitSglSrcSite *             theSite;
d462 2
a463 2
initAllocRepos_ ->restoreAndSave (incumbAllocRepos_);
initConfigRepos_->restoreAndSave (incumbConfigRepos_);
d465 2
a466 2
while (incumbVisitSites_.pop (theSite))
theSite->resetIncumb ();
d468 1
a468 1
curVisitSites_.attachItr (theItr);
d470 3
a472 3
while (theItr.advance (theSite))
{
incumbVisitSites_.push (theSite);
d474 3
a476 3
theSite->saveCurAsIncumb ();
}
}
d481 2
a482 2
{
WitSglSrcSite * theSite;
d484 10
a493 10
if (pureMsMode_)
incumbConfigRepos_->restore ();
else
incumbConfigRepos_->clear ();

incumbAllocRepos_->restore ();

while (alteredSites_.pop (theSite))
theSite->reset ();
}
d498 9
a506 9
{
fprintf (msgFile (),
"\n"
"------------------------------------\n"
"-> Full Allocation Was Not Achieved.\n"
"-> Multi-Source Allocation Used.    \n"
"------------------------------------\n"
"\n");
}
d511 3
a513 3
{
WitSglSrcSite *             theSite;
WitObjStItr <WitSglSrcSite> theItr;
d515 1
a515 1
nCmqFixed_ ++;
d517 2
a518 2
while (curVisitSites_.pop (theSite))
theSite->initCmqFixed ();
d520 2
a521 2
curPermCommIdx_ = 0;
newNetQty       = netQty;
d523 1
a523 1
alteredSites_.attachItr (theItr);
d525 2
a526 2
while (theItr.advance (theSite))
theSite->applySel ();
d528 2
a529 2
mySelector_->commitMaxQty (newNetQty);
}
@


1.58
log
@Heuristic Adjustment
@
text
@d30 42
a71 42
      WitProbAssoc       (theSelector),
      mySelector_        (theSelector),
      myRtMgr_           (theSelector->myRtMgr ()),
      mySglSrcSiteFor_   (myProblem ()),
      alteredSites_      (myProblem ()),
      cmqMode_           (false),
      curPermCommIdx_    (0),
      curVisitSites_     (myProblem ()),
      incumbVisitSites_  (myProblem ()),
      pureMsMode_        (true),
      initAllocRepos_    (NULL),
      initConfigRepos_   (NULL),
      incumbAllocRepos_  (NULL),
      incumbConfigRepos_ (NULL),

      nCmq_              (0),
      nCmqFixed_         (0),
      nFullAlloc_        (0),
      nNonFullAlloc_     (0),
      nOpps_             (0),
      nDiscovered_       (0),
      nTested_           (0),
      nAccepted_         (0),
      nRejected_         (0)
   {
   WitRtSite * theRtSite;

   verifyRestrictions ();

   myMsgFac () ("sglSrcMsg");

   initAllocRepos_    = new WitDataRepos (myProblem ());
   initConfigRepos_   = new WitDataRepos (myProblem ());
   incumbAllocRepos_  = new WitDataRepos (myProblem ());
   incumbConfigRepos_ = new WitDataRepos (myProblem ());

   forEachEl (theRtSite, myRtMgr_->myRtSites ())
      if (theRtSite->myRtCands ().nElements () > 1)
         if (theRtSite->singleSource ())
            if (mySelector_->myMrMgr ()->multiChoice (theRtSite))
               mySglSrcSiteFor_ (theRtSite) = new WitSglSrcSite (theRtSite);
   }
d76 2
a77 2
   {
   WitRtSite * theRtSite;
d79 20
a98 20
   if (DEVELOPMENT)
      myMsgFac () ("sglSrcCountsMsg",
         nCmq_,
         nCmqFixed_,
         nFullAlloc_,
         nNonFullAlloc_,
         nOpps_,
         nDiscovered_,
         nTested_,
         nAccepted_,
         nRejected_);

   forEachEl (theRtSite, myRtMgr_->myRtSites ())
      delete mySglSrcSiteFor_ (theRtSite);

   delete incumbConfigRepos_;
   delete incumbAllocRepos_;
   delete initConfigRepos_;
   delete initAllocRepos_;
   }
d103 11
a113 11
   {
   WitPart *     thePart;
   WitBomEntry * theBomEnt;

   forEachPart (thePart, theProblem)
      if (thePart->singleSource ())
         return true;

   forEachBomEntry (theBomEnt, theProblem)
      if (theBomEnt->singleSource ())
         return true;
d115 2
a116 2
   return false;
   }
d121 3
a123 3
   {
   bool            fullAlloc;
   WitSglSrcSite * oppSite;
d125 1
a125 1
   stronglyAssert (not cmqMode_);
d127 1
a127 1
   cmqMode_ = true;
d129 1
a129 1
   nCmq_ ++;
d131 1
a131 1
   initMsAlloc (netQty, fullAlloc);
d133 3
a135 3
   if (not fullAlloc)
      {
      cmqMode_ = false;
d137 2
a138 2
      return;
      }
d140 3
a142 3
   while (true)
      {
      oppSite = nextOpp ();
d144 2
a145 2
      if (oppSite == NULL)
         break;
d147 1
a147 1
      nOpps_ ++;
d149 5
a153 5
      if (oppSite->nextCandIsSglSrc ())
         selectDiscovery (oppSite);
      else
         tryNextCand (netQty, oppSite);
      }
d155 1
a155 1
   preserveIncumb ();
d157 1
a157 1
   netQty = 0.0;
d159 2
a160 2
   cmqMode_ = false;
   }
d165 2
a166 2
   {
   curPermCommIdx_ ++;
d168 6
a173 6
   if (selPrintLevelAt (2))
      fprintf (msgFile (),
         "\n"
         "Perm-Commit #%d\n",
         curPermCommIdx_);
   }
d178 3
a180 3
   {
   WitRtSite *     theRtSite;
   WitSglSrcSite * theSite;
d182 1
a182 1
   theRtSite = myRtMgr_->myRtSiteFor (thePart);
d184 1
a184 1
   theSite   = mySglSrcSiteFor_ (theRtSite);
d186 2
a187 2
   return expProhibited (theSite, expPer);
   }
d192 15
a206 15
   {
   WitBomEntry *   theBomEnt;
   WitRtSite *     theRtSite;
   WitSglSrcSite * theSite;

   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->inEffect (execPer))
         {
         theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

         theSite   = mySglSrcSiteFor_ (theRtSite);

         if (expProhibited (theSite, execPer))
            return true;
         }
d208 2
a209 2
   return false;
   }
d214 3
a216 3
   {
   WitRtCand *     theRtCand;
   WitSglSrcSite * theSite;
d218 1
a218 1
   theRtCand = myRtMgr_->myRtCandFor (theBillEnt);
d220 1
a220 1
   theSite   = mySglSrcSiteFor_ (theRtCand->myRtSite ());
d222 2
a223 2
   if (theSite == NULL)
      return;
d225 3
a227 3
   if (mySelector_->myHeurAtor ()->permCommActive ())
      if (theSite->curPcIdx () == -1)
         curVisitSites_.push (theSite);
d229 2
a230 2
   theSite->recordVisit (theRtCand, curPermCommIdx_);
   }
d235 2
a236 2
   {
   WitSglSrcSite * theSite;
d238 1
a238 1
   theSite = mySglSrcSiteFor_ (theRtSite);
d240 3
a242 3
   if (theSite != NULL)
      if (theSite->sglSrcMode ())
         return true;
d244 2
a245 2
   return false;
   }
d250 4
a253 4
   {
   if (cmqMode_)
      initAllocRepos_->saveVal (theVar);
   }
d258 4
a261 4
   {
   if (cmqMode_)
      initAllocRepos_->saveVal (theVar);
   }
d266 4
a269 4
   {
   if (cmqMode_)
      initAllocRepos_->saveExecVol (theOpn, thePer);
   }
d274 4
a277 4
   {
   if (cmqMode_)
      initAllocRepos_->saveSubVol (theSub, thePer);
   }
d282 4
a285 4
   {                                       
   if (cmqMode_)
      initConfigRepos_->saveVal (theVar);
   }
d290 4
a293 4
   {                                       
   if (cmqMode_)
      initConfigRepos_->saveVal (theVar);
   }
d298 4
a301 4
   {
   if (cmqMode_)
      initConfigRepos_->saveVal (theVar);
   }
d306 2
a307 2
   {
   WitDemand * theDemand;
d309 1
a309 1
   stronglyAssert (sglSrcReq (myProblem ()));
d311 2
a312 2
   if (mySelector_->penExec ())
      myMsgFac () ("sglSrcAndPenExecSmsg");
d314 2
a315 2
   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("sglSrcAndCritListSmsg");
d317 2
a318 2
   if (myGlobalComp ()->pgdCritListMode ())
      myMsgFac () ("pgdCritListSglSrcSmsg");
d320 2
a321 2
   if (myGlobalComp ()->equitability () > 1)
      myMsgFac () ("sglSrcAndEqAllSmsg");
d323 4
a326 4
   forEachDemand (theDemand, myProblem ())
      if (theDemand->buildAheadUB () != 0)
         myMsgFac () ("sglSrcAndBaByDemSmsg");
   }
d331 4
a334 4
   {
   if (theSite != NULL)
      if (theSite->expProhibited (thePer))
         return true;
d336 2
a337 2
   return false;
   }
d342 2
a343 2
   {
   double newNetQty;
d345 1
a345 1
   pureMsMode_ = true;
d347 1
a347 1
   cmqFixed (netQty, newNetQty);
d349 2
a350 2
   fullAlloc =
      (newNetQty <= SEARCH_TOL * mySelector_->myHeurAtor ()->searchInc ());
d352 3
a354 3
   if (fullAlloc)
      {
      nFullAlloc_ ++;
d356 5
a360 5
      saveCurAsIncumb ();
      }
   else
      {
      nNonFullAlloc_ ++;
d362 2
a363 2
      initAllocRepos_ ->clear ();
      initConfigRepos_->clear ();
d365 1
a365 1
      netQty = newNetQty;
d367 4
a370 4
      if (selPrintLevelAt (2))
         prtNonFull ();
      }
   }
d375 14
a388 14
   {
   WitObjStItr <WitSglSrcSite> theItr;
   WitSglSrcSite *             theSite;
   WitSglSrcSite *             oppSite;

   oppSite = NULL;

   incumbVisitSites_.attachItr (theItr);

   while (theItr.advance (theSite))
      if (not theSite->sglSrcMode ())
         if (theSite->hasUntried ())
            if (theSite->isPreferredTo (oppSite))
               oppSite = theSite;
d390 2
a391 2
   return oppSite;
   }
d396 2
a397 2
   {
   nDiscovered_ ++;
d399 2
a400 2
   if (not theSite->altered ())
      alteredSites_.push (theSite);
d402 1
a402 1
   theSite->selectNext ();
d404 1
a404 1
   pureMsMode_ = false;
d406 3
a408 3
   if (selPrintLevelAt (2))
      theSite->prtSel ("Discovered");
   }
d413 2
a414 2
   {
   double newNetQty;
d416 1
a416 1
   nTested_ ++;
d418 2
a419 2
   if (not theSite->altered ())
      alteredSites_.push (theSite);
d421 1
a421 1
   theSite->selectNext ();
d423 2
a424 2
   if (selPrintLevelAt (2))
      theSite->prtSel ("Tested");
d426 1
a426 1
   theSite->applySel ();
d428 1
a428 1
   cmqFixed (netQty, newNetQty);
d430 3
a432 3
   if (newNetQty <= SEARCH_TOL * mySelector_->myHeurAtor ()->searchInc ())
      {
      nAccepted_ ++;
d434 1
a434 1
      saveCurAsIncumb ();
d436 1
a436 1
      pureMsMode_ = false;
d438 6
a443 6
      if (selPrintLevelAt (2))
         theSite->prtSel ("Accepted");
      }
   else
      {
      nRejected_ ++;
d445 2
a446 2
      initAllocRepos_ ->restore ();
      initConfigRepos_->restore ();
d448 2
a449 2
      if (selPrintLevelAt (2))
         theSite->prtSel ("Rejected");
d451 3
a453 3
      theSite->resumeMS ();
      }
   }
d458 3
a460 3
   {
   WitObjStItr <WitSglSrcSite> theItr;
   WitSglSrcSite *             theSite;
d462 2
a463 2
   initAllocRepos_ ->restoreAndSave (incumbAllocRepos_);
   initConfigRepos_->restoreAndSave (incumbConfigRepos_);
d465 2
a466 2
   while (incumbVisitSites_.pop (theSite))
      theSite->resetIncumb ();
d468 1
a468 1
   curVisitSites_.attachItr (theItr);
d470 3
a472 3
   while (theItr.advance (theSite))
      {
      incumbVisitSites_.push (theSite);
d474 3
a476 3
      theSite->saveCurAsIncumb ();
      }
   }
d481 2
a482 2
   {
   WitSglSrcSite * theSite;
d484 10
a493 10
   if (pureMsMode_)
      incumbConfigRepos_->restore ();
   else
      incumbConfigRepos_->clear ();

   incumbAllocRepos_->restore ();

   while (alteredSites_.pop (theSite))
      theSite->reset ();
   }
d498 9
a506 9
   {
   fprintf (msgFile (),
      "\n"
      "------------------------------------\n"
      "-> Full Allocation Was Not Achieved.\n"
      "-> Multi-Source Allocation Used.    \n"
      "------------------------------------\n"
      "\n");
   }
d511 3
a513 3
   {
   WitSglSrcSite *             theSite;
   WitObjStItr <WitSglSrcSite> theItr;
d515 1
a515 1
   nCmqFixed_ ++;
d517 2
a518 2
   while (curVisitSites_.pop (theSite))
      theSite->initCmqFixed ();
d520 2
a521 2
   curPermCommIdx_ = 0;
   newNetQty       = netQty;
d523 1
a523 1
   alteredSites_.attachItr (theItr);
d525 2
a526 2
   while (theItr.advance (theSite))
      theSite->applySel ();
d528 2
a529 2
   mySelector_->commitMaxQty (newNetQty);
   }
@


1.57
log
@Heuristic Adjustment
@
text
@d17 1
a17 1
#include <Opn.h>
@


1.56
log
@Selection reuse.
@
text
@d35 1
d125 4
d134 3
d138 1
d158 2
d251 2
a252 1
   initAllocRepos_->saveVal (theVar);
d259 2
a260 1
   initAllocRepos_->saveVal (theVar);
d267 2
a268 1
   initAllocRepos_->saveExecVol (theOpn, thePer);
d275 2
a276 1
   initAllocRepos_->saveSubVol (theSub, thePer);
d283 2
a284 1
   initConfigRepos_->saveVal (theVar);
d291 2
a292 1
   initConfigRepos_->saveVal (theVar);
d299 2
a300 1
   initConfigRepos_->saveVal (theVar);
@


1.55
log
@Selection reuse.
@
text
@d349 2
a350 1
      prtNonFull ();
d388 2
a389 1
   theSite->prtSel ("Discovered");
d405 2
a406 1
   theSite->prtSel ("Tested");
d420 2
a421 1
      theSite->prtSel ("Accepted");
d430 2
a431 1
      theSite->prtSel ("Rejected");
d481 7
a487 8
   if (selPrintLevelAt (2))
      fprintf (msgFile (),
         "\n"
         "------------------------------------\n"
         "-> Full Allocation Was Not Achieved.\n"
         "-> Multi-Source Allocation Used.    \n"
         "------------------------------------\n"
         "\n");
@


1.54
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d157 1
a157 1
   if (myGlobalComp ()->selPrintLevel () >= 2)
d476 1
a476 1
   if (myGlobalComp ()->selPrintLevel () >= 2)
@


1.53
log
@Stochastic Implosion
@
text
@d21 1
a21 1
#include <Global.h>
@


1.52
log
@Stochastic Implosion
@
text
@d23 1
a23 1
#include <Repos.h>
d254 8
a261 1
   initAllocRepos_->saveHeurExecVol (theOpn, thePer);
@


1.51
log
@Stochastic Implosion
@
text
@d252 7
@


1.50
log
@Heuristic search increment.
@
text
@a28 1
      WitProbAssoc       (theSelector->myProblem ()),
d30 1
@


1.49
log
@[shared-resource pegging]
@
text
@d317 2
a318 1
   fullAlloc = (newNetQty <= SEARCH_TOL);
d395 1
a395 1
   if (newNetQty <= SEARCH_TOL)
@


1.48
log
@[shared-resource pegging]
@
text
@d348 1
a348 1
   incumbVisitSites_.attach (theItr);
d430 1
a430 1
   curVisitSites_.attach (theItr);
d486 1
a486 1
   alteredSites_.attach (theItr);
@


1.47
log
@[shared-resource pegging]
@
text
@d348 1
a348 1
   theItr.attachTo (incumbVisitSites_);
d430 1
a430 1
   theItr.attachTo (curVisitSites_);
d486 1
a486 1
   theItr.attachTo (alteredSites_);
@


1.46
log
@Revised mappingIndex code.
@
text
@d266 1
a266 1
void WitSglSrcMgr::saveConfigTlObjVal (WitTlObj * & theVar)
@


1.45
log
@Second attempt to correct a problem with header file inclusion on
g++ 3.3.3.
@
text
@a24 1
#include <MapIdxI.h>
@


1.44
log
@An attempt to correct a problem with header file inclusion on g++ 3.3.3.
@
text
@d16 1
@


1.43
log
@Vector PropRtg.
@
text
@a15 1
#include <Part.h>
a17 1
#include <BomEntry.h>
@


1.42
log
@Pegged Critical List.
@
text
@d294 1
a294 1
      if (not (theDemand->buildAheadUB () == 0))
@


1.41
log
@Pegged Critical List.
@
text
@d287 1
a287 1
   if (myGlobalComp ()->pgdCritListNeeded ())
@


1.40
log
@Pegged critical list.
@
text
@d287 3
@


1.39
log
@Pegged critical list.
@
text
@d209 1
a209 1
   theRtCand = theBillEnt->myRtCand ();
@


1.38
log
@Low-Pri Prop-Rt.
@
text
@d34 1
d67 1
a67 1
   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
d92 1
a92 1
   forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
d170 8
a177 1
   return expProhibited (mySglSrcSiteFor_ (thePart->myRtSite ()), expPer);
d184 3
a186 1
   WitBomEntry * theBomEnt;
d190 6
a195 1
         if (expProhibited (mySglSrcSiteFor_ (theBomEnt->myRtSite ()), execPer))
d197 1
@


1.37
log
@Low-Pri Prop-Rt.
@
text
@d200 1
a200 1
   if (not mySelector_->myHeurAtor ()->tempMode ())
@


1.36
log
@Low-Pri Prop-Rt.
@
text
@d245 7
@


1.35
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d245 2
a246 2
void WitSglSrcMgr::saveConfigVal (WitSelCand * & theVar)
   {                                       
@


1.34
log
@Continued implementation of post-implosion pegging.
@
text
@d26 1
a26 1
#include <PtrMapI.h>
@


1.33
log
@Continued implementation of proportionate routing.
@
text
@a26 1
#include <FlexVecI.h>
@


1.32
log
@Continued implementation of proportionate routing.
@
text
@d189 1
a189 1
void WitSglSrcMgr::recExp (WitRtCand * theRtCand)
d191 1
d194 3
a196 1
   theSite = mySglSrcSiteFor_ (theRtCand->myRtSite ());
@


1.31
log
@Continued implementation of proportionate routing.
@
text
@a9 1
#include <MrMgr.h>
d14 1
d70 1
a70 1
            if (theRtSite->mrMultiChoice ())
@


1.30
log
@Continued implementation of proportionate routing.
@
text
@a30 10
inline WitSglSrcSite * WitSglSrcMgr::mySglSrcSiteFor (WitRtSite * theRtSite)
   {
   return
      (theRtSite != NULL)?
         mySglSrcSiteFor_ (theRtSite):
         NULL;
   }

//------------------------------------------------------------------------------

d35 1
a35 1
      mySglSrcSiteFor_   (),
a66 2
   mySelector_->myRtMgr ()->allocate (mySglSrcSiteFor_);

d68 4
a71 3
      if (theRtSite->singleSource ())
         if (theRtSite->mrMultiChoice ())
            mySglSrcSiteFor_ (theRtSite) = new WitSglSrcSite (theRtSite);
d170 1
a170 1
   return expProhibited (mySglSrcSiteFor (thePart->myRtSite ()), expPer);
d181 1
a181 1
         if (expProhibited (mySglSrcSiteFor (theBomEnt->myRtSite ()), execPer))
d193 1
a193 4
   if (theRtCand == NULL)
      return;

   theSite = mySglSrcSiteFor (theRtCand->myRtSite ());
d211 1
a211 1
   theSite = mySglSrcSiteFor (theRtSite);
@


1.29
log
@Continued implementation of proportionate routing.
@
text
@d12 3
d31 10
d45 1
a45 2
      mySiteForPart_     (myProblem ()),
      mySiteForBomEnt_   (myProblem ()),
d66 1
a66 2
   WitPart     * thePart;
   WitBomEntry * theBomEnt;
d77 1
a77 5
   forEachPart (thePart, myProblem ())
      if (thePart->singleSource ())
         if (theSelector->myPmrMgr ()->multiChoice (thePart))
            mySiteForPart_ (thePart) =
               new WitPmrSsSite (thePart, theSelector);
d79 4
a82 5
   forEachBomEntry (theBomEnt, myProblem ())
      if (theBomEnt->singleSource ())
         if (theSelector->myCmrMgr ()->multiChoice (theBomEnt))
            mySiteForBomEnt_ (theBomEnt) =
               new WitCmrSsSite (theBomEnt, theSelector);
d89 1
a89 2
   WitPart     * thePart;
   WitBomEntry * theBomEnt;
d103 2
a104 5
   forEachPart (thePart, myProblem ())
      delete mySiteForPart_ (thePart);

   forEachBomEntry (theBomEnt, myProblem ())
      delete mySiteForBomEnt_ (theBomEnt);
d181 1
a181 1
   return expProhibited (mySiteForPart_ (thePart), expPer);
d192 1
a192 1
         if (expProhibited (mySiteForBomEnt_ (theBomEnt), execPer))
d200 1
a200 1
void WitSglSrcMgr::recExp (WitBopEntry * theBopEnt)
d202 9
a210 2
   recordVisit (mySiteForPart_ (theBopEnt->myPart ()), theBopEnt);
   }
d212 3
a214 1
//------------------------------------------------------------------------------
d216 1
a216 3
void WitSglSrcMgr::recExp (WitConsEntry * theConsEnt)
   {
   recordVisit (mySiteForBomEnt_ (theConsEnt->myBomEnt ()), theConsEnt);
d221 1
a221 1
bool WitSglSrcMgr::sglSrcMode (WitPart * thePart)
d223 3
a225 2
   return sglSrcMode (mySiteForPart_ (thePart));
   }
d227 3
a229 1
//------------------------------------------------------------------------------
d231 1
a231 3
bool WitSglSrcMgr::sglSrcMode (WitBomEntry * theBomEnt)
   {
   return sglSrcMode (mySiteForBomEnt_ (theBomEnt));
a259 2

// savePtrVal (initConfigRepos_, theVar);
a296 27
void WitSglSrcMgr::recordVisit (
      WitSglSrcSite * theSite, 
      WitBillEntry *  theBillEnt)
   {
   if (theSite == NULL)
      return;

   if (not mySelector_->myHeurAtor ()->tempMode ())
      if (theSite->curPcIdx () == -1)
         curVisitSites_.push (theSite);

   theSite->recordVisit (theBillEnt, curPermCommIdx_);
   }

//------------------------------------------------------------------------------

bool WitSglSrcMgr::sglSrcMode (WitSglSrcSite * theSite)
   {
   if (theSite != NULL)
      if (theSite->sglSrcMode ())
         return true;

   return false;
   }

//------------------------------------------------------------------------------

a332 1
   bool                        newOppFound;
d341 1
a341 10
            {
            newOppFound =

               (oppSite == NULL)?                                   true:
               (theSite->incumbPcIdx () > oppSite->incumbPcIdx ())? true:
               (theSite->incumbPcIdx () < oppSite->incumbPcIdx ())? false:
               (theSite->heightIdx   () > oppSite->heightIdx   ())? true:
                                                                    false;

            if (newOppFound)
a342 1
            }
@


1.28
log
@Began implementation of Proportionate Routing.
@
text
@d29 1
a29 1
      WitProbAssoc       (theSelector),
@


1.27
log
@Various internal changes.
@
text
@d258 1
a258 2
   WitDemand *   theDemand;
   WitBomEntry * theBomEnt;
@


1.26
log
@Internal changes.
@
text
@d249 3
a251 1
   savePtrVal (initConfigRepos_, theVar);
@


1.25
log
@Internal changes.
@
text
@d139 1
a139 1
   if (! fullAlloc)
d271 1
a271 1
      if (! (theDemand->buildAheadUB () == 0))
d295 1
a295 1
   if (! mySelector_->myHeurAtor ()->tempMode ())
d358 1
a358 1
      if (! theSite->sglSrcMode ())
d382 1
a382 1
   if (! theSite->altered ())
d400 1
a400 1
   if (! theSite->altered ())
@


1.24
log
@Removed implementation of single-source by the old algorithm.
@
text
@d38 1
a38 1
      pureMsMode_        (witTRUE),
d112 1
a112 1
WitBoolean WitSglSrcMgr::sglSrcReq (WitProblem * theProblem)
d119 1
a119 1
         return witTRUE;
d123 1
a123 1
         return witTRUE;
d125 1
a125 1
   return witFALSE;
d132 1
a132 1
   WitBoolean      fullAlloc;
d142 1
a142 1
   while (witTRUE)
d177 1
a177 1
WitBoolean WitSglSrcMgr::expProhibited (WitPart * thePart, WitPeriod expPer)
d184 1
a184 3
WitBoolean WitSglSrcMgr::expProhibited (
      WitOperation * theOpn,
      WitPeriod      execPer)
d191 1
a191 1
            return witTRUE;
d193 1
a193 1
   return witFALSE;
d212 1
a212 1
WitBoolean WitSglSrcMgr::sglSrcMode (WitPart * thePart)
d219 1
a219 1
WitBoolean WitSglSrcMgr::sglSrcMode (WitBomEntry * theBomEnt)
d240 1
a240 1
void WitSglSrcMgr::saveConfigVal (int & theVar)
d277 1
a277 3
WitBoolean WitSglSrcMgr::expProhibited (
      WitSglSrcSite * theSite, 
      WitPeriod       thePer)
d281 1
a281 1
         return witTRUE;
d283 1
a283 1
   return witFALSE;
d304 1
a304 1
WitBoolean WitSglSrcMgr::sglSrcMode (WitSglSrcSite * theSite)
d308 1
a308 1
         return witTRUE;
d310 1
a310 1
   return witFALSE;
d315 1
a315 1
void WitSglSrcMgr::initMsAlloc (double & netQty, WitBoolean & fullAlloc)
d319 1
a319 1
   pureMsMode_ = witTRUE;
d351 1
a351 1
   WitBoolean                  newOppFound;
d363 5
a367 5
               (oppSite == NULL)?                                   witTRUE:
               (theSite->incumbPcIdx () > oppSite->incumbPcIdx ())? witTRUE:
               (theSite->incumbPcIdx () < oppSite->incumbPcIdx ())? witFALSE:
               (theSite->heightIdx   () > oppSite->heightIdx   ())? witTRUE:
                                                                    witFALSE;
d387 1
a387 1
   pureMsMode_ = witFALSE;
d417 1
a417 1
      pureMsMode_ = witFALSE;
@


1.23
log
@Continued implementation of single-source by the new algorithm.
@
text
@a60 3
   if (DEVELOPMENT)
      myMsgFac () ("newSglSrcMsg");

@


1.22
log
@Continued implementation of single-source by the new algorithm.
@
text
@d29 1
a29 1
      WitProbAssoc      (theSelector),
d31 22
a52 20
      mySelector_       (theSelector),
      mySiteForPart_    (myProblem ()),
      mySiteForBomEnt_  (myProblem ()),
      alteredSites_     (myProblem ()),
      curPermCommIdx_   (0),
      curVisitSites_    (myProblem ()),
      incumbVisitSites_ (myProblem ()),
      pureMsMode_       (witTRUE),
      allocRepos_       (NULL),
      configRepos_      (NULL),

      nCmq_             (0),
      nCmqFixed_        (0),
      nFullAlloc_       (0),
      nNonFullAlloc_    (0),
      nOpps_            (0),
      nDiscovered_      (0),
      nTested_          (0),
      nAccepted_        (0),
      nRejected_        (0)
d64 4
a67 2
   allocRepos_  = new WitDataRepos (myProblem ());
   configRepos_ = new WitDataRepos (myProblem ());
d107 4
a110 2
   delete configRepos_;
   delete allocRepos_;
d160 3
a162 1
   preserveIncumb (netQty);
d233 1
a233 1
   allocRepos_->saveVal (theVar);
d240 1
a240 1
   allocRepos_->saveVal (theVar);
d247 1
a247 1
   configRepos_->saveVal (theVar);
d254 1
a254 1
   savePtrVal (configRepos_, theVar);
a335 3
      allocRepos_ ->restore ();
      configRepos_->restore ();

d342 2
a343 2
      allocRepos_ ->clear ();
      configRepos_->clear ();
a417 3
   allocRepos_ ->restore ();
   configRepos_->restore ();

d432 3
d448 3
d466 1
a466 1
void WitSglSrcMgr::preserveIncumb (double & netQty)
a467 1
   double          newNetQty;
a469 6
   cmqFixed (netQty, newNetQty);

   stronglyAssert (newNetQty <= SEARCH_TOL);

   netQty = 0.0;

d471 1
a471 1
      configRepos_->clear ();
d473 1
a473 1
      configRepos_->restore ();
d475 1
a475 1
   allocRepos_->clear ();
@


1.21
log
@Continued implementation of single-source by the new algorithm.
@
text
@a388 4
   theSite->applySel ();

   configRepos_->clear ();

a419 4
      theSite->applySel ();

      configRepos_->clear ();

d498 2
a499 1
   WitSglSrcSite * theSite;
d508 5
@


1.20
log
@Continued implementation of single-source by the new algorithm.
@
text
@d12 1
d148 2
a149 2
      if (oppSite->incumbFlowIsSglSrc ())
         selectUniqueCand (oppSite);
d195 1
a195 1
void WitSglSrcMgr::recPermExp (WitBopEntry * theBopEnt)
d202 1
a202 1
void WitSglSrcMgr::recPermExp (WitConsEntry * theConsEnt)
d294 3
a296 2
   if (theSite->curPcIdx () == -1)
      curVisitSites_.push (theSite);
d380 1
a380 1
void WitSglSrcMgr::selectUniqueCand (WitSglSrcSite * theSite)
d387 1
a387 1
   theSite->selectUniqueCand ();
@


1.19
log
@Continued implementation of single-source by the new algorithm.
@
text
@d39 11
a49 1
      configRepos_      (NULL)
d84 12
d128 2
a129 4
   double          newNetQty;
   WitSglSrcSite * theSite;

   pureMsMode_ = witTRUE;
d131 1
a131 8
   cmqFixed (netQty, newNetQty);

   if (newNetQty > SEARCH_TOL)
      {
      allocRepos_ ->clear ();
      configRepos_->clear ();

      netQty = newNetQty;
d133 1
a133 1
      prtNotFull ();
d135 1
a136 6
      }

   allocRepos_ ->restore ();
   configRepos_->restore ();

   saveAsIncumbent ();
d140 1
a140 1
      theSite = nextOpp ();
d142 1
a142 1
      if (theSite == NULL)
d145 4
a148 2
      if (theSite->incumbFlowIsSglSrc ())
         selectUniqueSel (theSite);
d150 1
a150 1
         tryNextCand (netQty, theSite);
d153 1
a153 14
   cmqFixed (netQty, newNetQty);

   stronglyAssert (newNetQty <= SEARCH_TOL);

   netQty = 0.0;

   if (pureMsMode_)
      configRepos_->clear ();
   else
      configRepos_->restore ();

   allocRepos_->clear ();

   reset ();
a272 15
void WitSglSrcMgr::cmqFixed (double netQty, double & newNetQty)
   {
   WitSglSrcSite * theSite;

   while (curVisitSites_.pop (theSite))
      theSite->initCmqFixed ();

   curPermCommIdx_ = 0;
   newNetQty       = netQty;

   mySelector_->commitMaxQty (newNetQty);
   }

//------------------------------------------------------------------------------

d312 34
d378 1
a378 1
void WitSglSrcMgr::selectUniqueSel (WitSglSrcSite * theSite)
d380 2
d385 1
a385 1
   theSite->selectUniqueSel ();
d402 2
d409 1
a409 1
   theSite->prtSel ("Considered");
d420 2
d426 1
a426 1
      saveAsIncumbent ();
d434 2
d444 1
a444 1
void WitSglSrcMgr::saveAsIncumbent ()
d458 1
a458 1
      theSite->saveAsIncumbent ();
d464 1
a464 1
void WitSglSrcMgr::reset ()
d466 1
d469 13
d488 1
a488 1
void WitSglSrcMgr::prtNotFull ()
d498 17
@


1.18
log
@Continued implementation of single-source with the new algorithm.
@
text
@a271 5

   if (myGlobalComp ()->perfPegging ())
      myMsgFac () ("genericSmsg",
         "Pegging with single-source using the new algorithm is not yet "
         "implemented.");
@


1.17
log
@Continued implementation of single-source by the new algorithm.
@
text
@d33 1
a33 1
      mySglSrcSites_    (myProblem ()),
d41 2
a42 3
   WitPart     *   thePart;
   WitBomEntry *   theBomEnt;
   WitSglSrcSite * theSite;
d57 2
a58 7
            {
            theSite = new WitPmrSsSite (thePart, theSelector);

            mySiteForPart_ (thePart) = theSite;

            mySglSrcSites_.push (theSite);
            }
d63 2
a64 7
            {
            theSite = new WitCmrSsSite (theBomEnt, theSelector);

            mySiteForBomEnt_ (theBomEnt) = theSite;

            mySglSrcSites_.push (theSite);
            }
d71 2
a72 2
   mySiteForBomEnt_.clear ();
   mySiteForPart_  .clear ();
d74 5
a78 1
   deleteContents (mySglSrcSites_);
d369 3
d389 3
d447 1
a447 2
   WitObjStItr <WitSglSrcSite> theItr;
   WitSglSrcSite *             theSite;
d449 2
a450 4
   theItr.attachTo (mySglSrcSites_);

   while (theItr.advance (theSite))
         theSite->reset ();
@


1.16
log
@Continued implementation of single-source with the new algorithm.
@
text
@d211 1
a211 1
void WitSglSrcMgr::recPermExpNet (WitConsEntry * theConsEnt)
d213 1
a213 11
   WitSglSrcSite * theSite;
   WitSubEntry *   theSub;

   theSite = mySiteForBomEnt_ (theConsEnt->myBomEnt ());

   theConsEnt->getSubEntry (theSub);

   if ((theSub != NULL) && (! theSub->expAllowed ()))
      recordVisit (theSite, NULL);
   else
      recordVisit (theSite, theConsEnt);
@


1.15
log
@Continued implementation of single-source by the new algorithm.
@
text
@d10 1
d16 1
d37 1
d57 3
a59 2
         {
         theSite = new WitPmrSsSite (thePart, theSelector);
d61 1
a61 1
         mySiteForPart_ (thePart) = theSite;
d63 2
a64 2
         mySglSrcSites_.push (theSite);
         }
d68 3
a70 2
         {
         theSite = new WitCmrSsSite (theBomEnt, theSelector);
d72 1
a72 1
         mySiteForBomEnt_ (theBomEnt) = theSite;
d74 2
a75 2
         mySglSrcSites_.push (theSite);
         }
a112 1
   WitBoolean      pureMS;
d116 1
a116 1
   pureMS = witTRUE;
d144 4
a147 1
      tryNextCand (netQty, theSite, pureMS);
d156 3
a158 1
   if (! pureMS)
a159 2
   else
      configRepos_->clear ();
d204 1
a204 1
void WitSglSrcMgr::recFillNetReq (WitPart * thePart)
d206 1
a206 1
   recordVisit (mySiteForPart_ (thePart));
d211 1
a211 1
void WitSglSrcMgr::recExp (WitBomEntry * theBomEnt)
d213 11
a223 1
   recordVisit (mySiteForBomEnt_ (theBomEnt));
d303 1
a303 1
      theSite->setCurPcIdx (-1);
d326 3
a328 1
void WitSglSrcMgr::recordVisit (WitSglSrcSite * theSite)
d336 1
a336 1
   theSite->setCurPcIdx (curPermCommIdx_);
d384 16
a399 4
void WitSglSrcMgr::tryNextCand (
      double          netQty,
      WitSglSrcSite * theSite, 
      WitBoolean &    pureMS)
d405 1
a405 1
   theSite->prtSel ("Attempt");
d422 1
a422 1
      pureMS = witFALSE;
d424 1
a424 1
      theSite->prtSel ("Kept");
d442 1
a442 1
      theSite->resetIncumbPcIdx ();
@


1.14
log
@Continued implementation of single-source by the new algorithm.
@
text
@d26 1
a26 1
      WitProbAssoc     (theSelector),
d28 9
a36 7
      mySelector_      (theSelector),
      mySiteForPart_   (myProblem ()),
      mySiteForBomEnt_ (myProblem ()),
      curFlowSites_    (myProblem ()),
      incumbFlowSites_ (myProblem ()),
      allocRepos_      (NULL),
      configRepos_     (NULL)
d38 3
a40 2
   WitPart     * thePart;
   WitBomEntry * theBomEnt;
d54 7
a60 1
         mySiteForPart_ (thePart) = new WitPmrSsSite (thePart, theSelector);
d64 7
a70 2
         mySiteForBomEnt_ (theBomEnt) =
            new WitCmrSsSite (theBomEnt, theSelector);
d77 2
a78 2
   WitBomEntry * theBomEnt;
   WitPart *     thePart;
d80 1
a80 5
   forEachBomEntry (theBomEnt, myProblem ())
      delete mySiteForBomEnt_ (theBomEnt);

   forEachPart (thePart, myProblem ())
      delete mySiteForPart_ (thePart);
d131 1
a131 1
   curFlowSites_.revCopyInto (incumbFlowSites_);
d161 13
d199 1
a199 1
   recordFlow (mySiteForPart_ (thePart));
d206 1
a206 1
   recordFlow (mySiteForBomEnt_ (theBomEnt));
d283 4
a286 1
   curFlowSites_.clear ();
d288 2
a289 1
   newNetQty = netQty;
d309 1
a309 1
void WitSglSrcMgr::recordFlow (WitSglSrcSite * theSite)
d311 7
a317 3
   if (theSite != NULL)
      if (! curFlowSites_.contains (theSite))
            curFlowSites_.push     (theSite);
d337 2
d340 3
a342 1
   theItr.attachTo (incumbFlowSites_);
d347 12
a358 1
            return theSite;
d360 1
a360 1
   return NULL;
d389 1
a389 1
      curFlowSites_.revCopyInto (incumbFlowSites_);
d405 1
a405 1
void WitSglSrcMgr::reset ()
d407 7
a413 3
   WitPart *       thePart;
   WitBomEntry *   theBomEnt;
   WitSglSrcSite * theSite;
d415 1
a415 1
   forEachPart (thePart, myProblem ())
d417 1
a417 1
      theSite = mySiteForPart_ (thePart);
d419 1
a419 2
      if (theSite != NULL)
         theSite->reset ();
d421 8
d430 1
a430 3
   forEachBomEntry (theBomEnt, myProblem ())
      {
      theSite = mySiteForBomEnt_ (theBomEnt);
d432 1
a432 1
      if (theSite != NULL)
a433 1
      }
@


1.13
log
@Continued implementation of single-source with the new algorithm.
Fixed a null pointer bug in single-source with the old algorithm.
@
text
@d13 1
d30 1
d36 2
a37 1
   WitPart * thePart;
d52 5
d63 5
a67 1
   WitPart * thePart;
d153 4
a156 1
   WitSglSrcSite * theSite;
d158 5
a162 1
   theSite = mySiteForPart_ (thePart);
d164 4
a167 3
   if (theSite != NULL)
      if (theSite->flowProhibited (expPer))
         return witTRUE;
d176 2
a177 1
   WitSglSrcSite * theSite;
d179 1
a179 1
   theSite = mySiteForPart_ (thePart);
d181 3
a183 3
   if (theSite != NULL)
      if (! curFlowSites_.contains (theSite))
            curFlowSites_.push     (theSite);
d188 1
a188 1
WitBoolean WitSglSrcMgr::sglSrcMode (WitSelPt * theSelPt)
d190 2
a191 2
   WitPart *       thePart;
   WitSglSrcSite * theSite;
d193 1
a193 1
   thePart = theSelPt->myPmrPart ();
d195 3
a197 10
   if (thePart != NULL)
      {
      theSite = mySiteForPart_ (thePart);

      if (theSite != NULL)
         if (theSite->sglSrcMode ())
            return witTRUE;
      }

   return witFALSE;
a253 5

   forEachBomEntry (theBomEnt, myProblem ())
      if (theBomEnt->singleSource ())
         myMsgFac () ("genericSmsg",
            "Single-source for BOM entries is not yet implemented.");
d269 33
d362 1
d368 8
@


1.12
log
@Continued implementation of single-source with the new algorithm.
@
text
@d132 1
a132 1
   allocRepos_ ->clear ();
d139 15
d288 1
a288 1
   theSite->applySsSel ();
d297 1
a297 1
      theSite->applySsSel ();
@


1.11
log
@Began implementation of the new single-source algorithm.
@
text
@d2 1
d4 133
a136 5
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
d139 32
d172 144
a315 1
// Source file: "SglSrcMgr.C"
d317 12
@


1.10
log
@Fixed the "interference bug" in Single-Source.
@
text
@a11 2
//
// Contains the implementation of class SglSrcMgr.
a12 569

#include <SglSrcMgr.h>
#include <HeurAtor.h>
#include <Selector.h>
#include <SelPt.h>
#include <SglSrcSite.h>
#include <Part.h>
#include <BopEntry.h>
#include <Global.h>
#include <Repos.h>
#include <MsgFac.h>
#include <PtrMapI.h>
#include <FlexVecI.h>

//------------------------------------------------------------------------------

typedef WitObjStItr <WitSglSrcSite> WitSglSrcSiteItr;

//------------------------------------------------------------------------------

WitSglSrcMgr::WitSglSrcMgr (WitSelector * theSelector):
      WitProbAssoc       (theSelector),

      mySelector_        (theSelector),
      mySsSiteForPart_   (),
      mySsSiteForBomEnt_ (),
      sglSrcMode_        (witTRUE),
      alteredSites_      (myProblem ()),
      pureMS_            (witTRUE),
      cmrMisMatch_       (witFALSE),
      misMatchSite_      (NULL),
      nextAltSite_       (NULL),
      allocRepos_        (NULL),
      configRepos_       (NULL),
      nItrs_             (0),
      nAlts_             (0),
      swToMS_            (0)
   {
   WitPart *        thePart;
   WitBomEntry *    theBomEnt;
   WitSglSrcSiteItr theItr;
   WitSglSrcSite *  theSsSite;

   allocRepos_  = new WitDataRepos (myProblem ());
   configRepos_ = new WitDataRepos (myProblem ());

   verifyRestrictions ();

   myMsgFac () ("sglSrcMsg");

   mySsSiteForPart_.allocate (myProblem ());

   forEachPart (thePart, myProblem ())
      if (thePart->singleSource ())
         mySsSiteForPart_ (thePart) =
            new WitPmrSsSite (thePart, theSelector);

   mySsSiteForBomEnt_.allocate (myProblem ());

   forEachBomEntry (theBomEnt, myProblem ())
      if (theBomEnt->singleSource ())
         mySsSiteForBomEnt_ (theBomEnt) =
            new WitCmrSsSite (theBomEnt, theSelector);
   }

//------------------------------------------------------------------------------

WitSglSrcMgr::~WitSglSrcMgr ()
   {
   WitPart *     thePart;
   WitBomEntry * theBomEnt;

   if (DEVELOPMENT)
      myMsgFac () ("sglSrcCountsMsg", nItrs_, nAlts_, swToMS_);

   forEachBomEntry (theBomEnt, myProblem ())
      delete mySsSiteForBomEnt_ (theBomEnt);

   forEachPart (thePart, myProblem ())
      delete mySsSiteForPart_ (thePart);

   delete configRepos_;
   delete allocRepos_;
   }

//------------------------------------------------------------------------------

WitBoolean WitSglSrcMgr::hasSglSrcComp (WitProblem * theProblem)
   {
   WitPart *     thePart;
   WitBomEntry * theBomEnt;

   forEachPart (thePart, theProblem)
      if (thePart->singleSource ())
         return witTRUE;

   forEachBomEntry (theBomEnt, theProblem)
      if (theBomEnt->singleSource ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::commitMaxQty (double & netQty)
   {
   double origNetQty;

   stronglyAssert (allocRepos_ ->isEmpty ());
   stronglyAssert (configRepos_->isEmpty ());

   origNetQty = netQty;

   while (witTRUE)
      {
      prepSelCMQ ();

      mySelector_->commitMaxQty (netQty);

      if (nextAltSite_ == NULL)
         if (pureMS_)
            {
            prtPureMS ();

            break;
            }

      if (netQty <= SEARCH_TOL)
         {
         configRepos_->restore ();

         prtDesIncVolAch ();

         break;
         }

      configRepos_->restore ();
      allocRepos_ ->restore ();

      netQty = origNetQty;

      if (nextAltSite_ == NULL)
         {
         exhaustedCMQ (netQty);

         break;
         }

      alterNextAltSite ();
      }

   reset ();
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::prepCmqSel ()
   {
   if (! sglSrcMode_)
      return;

   misMatchSite_ = NULL;
   }

//------------------------------------------------------------------------------

WitBoolean WitSglSrcMgr::findPmrMisMatch (
      WitPart * thePart,
      WitPeriod expPer,
      WitPeriod fillPer)
   {
   WitSglSrcSite * theSsSite;

   if (! sglSrcMode_)
      return witFALSE;

   theSsSite = mySsSiteForPart_ (thePart);

   if (theSsSite->hasMisMatch (expPer))
      {
      mySelector_->recFundShortage (thePart, fillPer);

      misMatchSite_  = theSsSite;

      return witTRUE;
      }

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::noteCmrMisMatch (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer,
      WitPeriod     fillPer,
      WitBopEntry * theBopEnt)
   {
   WitSglSrcSite * theSsSite;

   if (! sglSrcMode_)
      return;

   if (cmrMisMatch_)
      return;

   theSsSite = mySsSiteForBomEnt_ (theBomEnt);

   if (theSsSite->hasMisMatch (execPer))
      {
      mySelector_->recFundShortage (theBopEnt->myPart (), fillPer);

      misMatchSite_ = theSsSite;

      cmrMisMatch_  = witTRUE;
      }
   }

//------------------------------------------------------------------------------

WitBoolean WitSglSrcMgr::checkCmrMisMatch ()
   {
   WitBoolean cmrMM;

   if (! sglSrcMode_)
      return witFALSE;

   cmrMM        = cmrMisMatch_;

   cmrMisMatch_ = witFALSE;

   return cmrMM;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::placeReqs (WitSelPt * theSelPt)
   {
   WitSglSrcSite * theSsSite;

   if (! sglSrcMode_)
      return;

   theSsSite = mySsSiteFor (theSelPt);

   if (theSsSite != NULL)
      if (theSsSite->sglSrcMode ())
         if (pureMS_)
            if (theSsSite->nonMS ()[theSelPt->myPeriod ()])
               pureMS_ = witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitSglSrcMgr::mustSkip (WitSelPt * theSelPt)
   {
   if (sglSrcMode_)
      if (nextAltSite_ != NULL)
         if (sglSrcMode (theSelPt))
            return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitSglSrcMgr::sglSrcMode (WitSelPt * theSelPt)
   {
   WitSglSrcSite * theSsSite;

   if (! sglSrcMode_)
      return witFALSE;

   theSsSite = mySsSiteFor (theSelPt);

   if (theSsSite != NULL)
      if (theSsSite->sglSrcMode ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitSglSrcMgr::sglSrcMode (WitBomEntry * theBomEnt)
   {
   WitSglSrcSite * theSsSite;

   if (! sglSrcMode_)
      return witFALSE;

   theSsSite = mySsSiteForBomEnt_ (theBomEnt);

   if (theSsSite != NULL)
      if (theSsSite->sglSrcMode ())
         return witTRUE;

   return witFALSE;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::alterSelections ()
   {
   WitObjStItr <WitSelPt> theItr;
   WitSelPt *             theSelPt;

   if (sglSrcMode_)
      if (nextAltSite_ == NULL)
         {
         if (misMatchSite_ != NULL)
            {
            nextAltSite_  = misMatchSite_;

            prtNextAltSite (witTRUE);
 
            return;
            }

         theItr.attachTo (mySelector_->pendingPts ());

         while (theItr.advance (theSelPt))
            {
            seekNextAltSite (theSelPt);

            if (nextAltSite_ != NULL)
               return;
            }
         }

   mySelector_->alterSelections ();
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::alterSelection (WitSelPt * theSelPt)
   {
   if (sglSrcMode_)
      if (nextAltSite_ == NULL)
         {
         if (misMatchSite_ != NULL)
            {
            nextAltSite_  = misMatchSite_;

            prtNextAltSite (witTRUE);

            return;
            }

         seekNextAltSite (theSelPt);

         if (nextAltSite_ != NULL)
            return;
         }

   mySelector_->alterSelection (theSelPt);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveAllocVal (int & theVar)
   {
   if (sglSrcMode_)
      allocRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveAllocVal (double & theVar)
   {
   if (sglSrcMode_)
      allocRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveConfigVal (int & theVar)
   {                                       
   if (sglSrcMode_)
      configRepos_->saveVal (theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::saveConfigVal (WitSelCand * & theVar)
   {                                       
   if (sglSrcMode_)
      savePtrVal (configRepos_, theVar);
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::verifyRestrictions ()
   {
   WitDemand * theDemand;

   stronglyAssert (hasSglSrcComp (myProblem ()));

   if (mySelector_->penExec ())
      myMsgFac () ("sglSrcAndPenExecSmsg");

   if (myGlobalComp ()->computeCriticalList ())
      myMsgFac () ("sglSrcAndCritListSmsg");

   if (myGlobalComp ()->equitability () > 1)
      myMsgFac () ("sglSrcAndEqAllSmsg");

   forEachDemand (theDemand, myProblem ())
      if (! (theDemand->buildAheadUB () == 0))
         myMsgFac () ("sglSrcAndBaByDemSmsg");
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::prepSelCMQ ()
   {
   WitSglSrcSiteItr theItr;
   WitSglSrcSite *  theSsSite;

   nItrs_ ++;

   pureMS_      = witTRUE;

   nextAltSite_ = NULL;

   theItr.attachTo (alteredSites_);

   while (theItr.advance (theSsSite))
      if (theSsSite->sglSrcMode ())
         theSsSite->applySsSel ();
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::prtPureMS ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 2)
      fprintf (msgFile (),
         "\n"
         "---------------------------------------\n"
         "-> Allocation Retained as Multi-Source.\n"
         "---------------------------------------\n"
         "\n");
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::prtDesIncVolAch ()
   {
   if (myGlobalComp ()->selPrintLevel () >= 2)
      fprintf (msgFile (),
         "\n"
         "--------------------------------------------\n"
         "-> DesIncVol Achieved in Single-Source Mode.\n"
         "--------------------------------------------\n"
         "\n");
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::exhaustedCMQ (double & netQty)
   {
   if (myGlobalComp ()->selPrintLevel () >= 2)
      fprintf (msgFile (),
         "\n"
         "---------------------------------------\n"
         "-> No Single-Source Alteration Found.  \n"
         "-> Pure Multi-Source Mode Will Be Used.\n"
         "---------------------------------------\n"
         "\n");

   sglSrcMode_ = witFALSE;

   mySelector_->commitMaxQty (netQty);

   sglSrcMode_ = witTRUE;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::alterNextAltSite ()
   {
   if (! nextAltSite_->altered ())
      alteredSites_.push (nextAltSite_);

   nextAltSite_->alterSel ();

   if (nextAltSite_->sglSrcMode ())
      nAlts_ ++;
   else
      swToMS_ ++;
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::reset ()
   {
   WitSglSrcSite * theSsSite;

   allocRepos_ ->clear ();
   configRepos_->clear ();

   while (alteredSites_.pop (theSsSite))
      {
      theSsSite->switchToMS ();

      theSsSite->init (witTRUE);
      }
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::seekNextAltSite (WitSelPt * theSelPt)
   {
   WitSglSrcSite * theSsSite;

   theSsSite = mySsSiteFor (theSelPt);

   if (theSsSite != NULL)
      if (theSsSite->sglSrcMode ())
         {
         nextAltSite_ = theSsSite;

         prtNextAltSite (witFALSE);
         }
   }

//------------------------------------------------------------------------------

void WitSglSrcMgr::prtNextAltSite (WitBoolean forMisMatch)
   {
   if (myGlobalComp ()->selPrintLevel () < 2)
      return;

   fprintf (msgFile (),
      "\n"
      "--------------------------------------\n"
      "-> Next Single-Source Alteration Site:\n"  
      "--------------------------------------\n"
      "\n");

   nextAltSite_->prtID ();

   if (forMisMatch)
      fprintf (msgFile (),
         "\n"
         "   (Single-Source vs. Multi-Route Mis-Match)\n");
   }

//------------------------------------------------------------------------------

WitSglSrcSite * WitSglSrcMgr::mySsSiteFor (WitSelPt * theSelPt)
   {
   WitPart *     thePart;
   WitBomEntry * theBomEnt;

   thePart = theSelPt->myPmrPart ();

   if (thePart != NULL)
      return mySsSiteForPart_ (thePart);

   theBomEnt = theSelPt->myCmrBomEnt ();

   if (theBomEnt != NULL)
      return mySsSiteForBomEnt_ (theBomEnt);

   return NULL;
   }
@


1.9
log
@Continued implementation of heuristic implosion from an initial solution.
Added some debugging code to Single-Source.
@
text
@d22 1
a40 1
      mySglSrcSites_     (myProblem ()),
d42 4
a46 1
      currentSites_      (myProblem ()),
a48 1
      origNetQty_        (0.0),
a49 4
      nMisMatches_       (0),
      nPureMS_           (0),
      nAchDesInc_        (0),
      nExhaust_          (0),
d65 1
a65 2
   mySsSiteForPart_  .allocate (myProblem ());
   mySsSiteForBomEnt_.allocate (myProblem ());
d69 2
a70 2
         {
         theSsSite = new WitPmrSsSite (thePart);
d72 1
a72 4
         mySsSiteForPart_ (thePart) = theSsSite;

         mySglSrcSites_.push (theSsSite);
         }
d76 2
a77 14
         {
         theSsSite = new WitCmrSsSite (theBomEnt);

         mySsSiteForBomEnt_ (theBomEnt) = theSsSite;

         mySglSrcSites_.push (theSsSite);
         }

   mySglSrcSites_.reverse ();

   theItr.attachTo (mySglSrcSites_);

   while (theItr.advance (theSsSite))
      theSsSite->setup (theSelector);
d84 3
d88 1
a88 8
      myMsgFac () ("sglSrcCountsMsg", 
         nItrs_, 
         nMisMatches_,
         nPureMS_,
         nAchDesInc_,
         nExhaust_,
         nAlts_, 
         swToMS_);
d90 2
a91 2
   mySsSiteForBomEnt_.clear ();
   mySsSiteForPart_  .clear ();
d93 2
a94 1
   deleteContents (mySglSrcSites_);
d122 2
d127 1
a127 1
   origNetQty_ = netQty;
a130 2
      nItrs_ ++;

a134 11
      activateAsNeeded ();

      if (misMatchFound ())
         {
         fullRestore (netQty);

         nMisMatches_ ++;

         continue;
         }

d136 1
a136 1
         if (pureMultiSource ())
d138 1
a138 1
            nPureMS_ ++;
d147 1
a147 1
         nAchDesInc_ ++;
d152 4
a155 1
      fullRestore (netQty);
d159 1
a159 1
         sglSrcMode_ = witFALSE;
d161 5
a165 1
         mySelector_->commitMaxQty (netQty);
d167 2
a168 1
         sglSrcMode_ = witTRUE;
d170 1
a170 1
         nExhaust_ ++;
d172 55
a226 2
         break;
         }
d228 1
a228 1
      nextAltSite_->advance ();
d230 1
a230 4
      if (nextAltSite_->sglSrcMode ())
         nAlts_ ++;
      else
         swToMS_ ++;
d232 1
d234 14
a247 1
   reset ();
d256 3
d263 3
a265 10
         {
         if (! theSsSite->current ())
            {
            theSsSite->setCurrent (witTRUE);

            currentSites_.push (theSsSite);
            }

         theSsSite->placeReqs (theSelPt->myPeriod ());
         }
d272 6
a277 4
   return
      (nextAltSite_ == NULL)?
         witFALSE:
         sglSrcMode (theSelPt);
d286 3
d291 5
a295 4
   return
      (theSsSite != NULL)?
         theSsSite->sglSrcMode ():
         witFALSE;
d304 3
d309 5
a313 4
   return
      (theSsSite != NULL)?
         theSsSite->sglSrcMode ():
         witFALSE;
d326 9
d356 9
d378 2
a379 1
   allocRepos_->saveVal (theVar);
d386 2
a387 1
   allocRepos_->saveVal (theVar);
d394 2
a395 1
   configRepos_->saveVal (theVar);
d402 2
a403 1
   savePtrVal (configRepos_, theVar);
d435 4
d441 1
a441 1
   theItr.attachTo (currentSites_);
a443 3
      {
      theSsSite->clearReqsPlaced ();

a445 1
      }
d450 1
a450 1
void WitSglSrcMgr::activateAsNeeded ()
d452 7
a458 8
   WitSglSrcSiteItr     theItr;
   WitSglSrcSite *      theSsSite;
   WitTVec <WitBoolean> workVec (myProblem (), witFALSE);

   theItr.attachTo (currentSites_);

   while (theItr.advance (theSsSite))
      theSsSite->activateAsNeeded (workVec);
d463 1
a463 1
WitBoolean WitSglSrcMgr::misMatchFound ()
d465 7
a471 10
   WitSglSrcSiteItr theItr;
   WitSglSrcSite *  theSsSite;

   theItr.attachTo (currentSites_);

   while (theItr.advance (theSsSite))
      if (theSsSite->hasMisMatch ())
         return witTRUE;

   return witFALSE;
d476 1
a476 1
WitBoolean WitSglSrcMgr::pureMultiSource ()
d478 8
a485 2
   WitSglSrcSiteItr theItr;
   WitSglSrcSite *  theSsSite;
d487 1
a487 1
   theItr.attachTo (currentSites_);
d489 1
a489 4
   while (theItr.advance (theSsSite))
      if (theSsSite->sglSrcMode ())
         if (theSsSite->placedSSreqs ())
            return witFALSE;
d491 1
a491 1
   return witTRUE;
d496 1
a496 1
void WitSglSrcMgr::fullRestore (double & netQty)
d498 4
a501 2
   configRepos_->restore ();
   allocRepos_ ->restore ();
d503 4
a506 1
   netQty = origNetQty_;
d518 1
a518 1
   while (currentSites_.pop (theSsSite))
d520 1
a520 1
      theSsSite->reset ();
a522 2

      theSsSite->setCurrent (witFALSE);
d539 1
a539 1
         prtNextAltSite ();
d545 1
a545 1
void WitSglSrcMgr::prtNextAltSite ()
d558 5
@


1.8
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d466 1
d468 20
@


1.7
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d25 2
@


1.6
log
@Continued implementation of single-source.
@
text
@d16 1
a19 1
#include <SglSrcMgr.h>
@


1.5
log
@Continued implementation of single-source.
@
text
@d248 7
a254 2
   if (theSsSite == NULL)
      return witFALSE;
d256 10
a265 1
   return theSsSite->sglSrcMode ();
d349 3
@


1.4
log
@Continued implementation of single-source.
@
text
@d121 1
a121 1
WitBoolean WitSglSrcMgr::singleSourceNeeded (WitProblem * theProblem)
d328 1
a328 1
   stronglyAssert (singleSourceNeeded (myProblem ()));
@


1.3
log
@Continued implementation of Single-Source.
@
text
@d44 8
a51 1
      origNetQty_        (0.0)
d100 10
a143 1

d148 2
d160 2
d167 3
d171 1
d177 2
d192 2
d198 5
@


1.2
log
@Continued implementation of single-source.
@
text
@d334 1
a334 1
   WitTVec <WitBoolean> theBoolTVec (myProblem (), witFALSE);
d339 1
a339 1
      theSsSite->activateAsNeeded (theBoolTVec);
d414 1
a414 2
         if (theSelPt->hasResAlt ())
            nextAltSite_ = theSsSite;
@


1.1
log
@Continued implementation of Single-Source.
@
text
@d201 10
a212 3
   if (nextAltSite_ == NULL)
      return witFALSE;

a226 1
   WitSglSrcSite *        theSsSite;
d235 1
a235 7
            theSsSite = mySsSiteFor (theSelPt);

            if (theSsSite != NULL)
               if (theSsSite->sglSrcMode ())
                  if (theSelPt->hasResAlt ())
                     {
                     nextAltSite_ = theSsSite;
d237 2
a238 2
                     return;
                     }
d247 16
a305 5

   if (mySelector_->selSplit ())
      myMsgFac () ("genericSmsg",
      "Selection splitting combined with the single-source technique is not "
      "yet implemented.");
d402 14
@


head	1.54;
access;
symbols
	sce_5_01_20080919:1.46
	latest_sce_4_20_20060523:1.40.0.2
	sce_4_20_20060523:1.40
	latest_sce4_20_OSL:1.39.0.2
	sce_4_20_OSL:1.39
	sce_410_withVa:1.32
	sce_4_05_20040511:1.31
	sce_4_00_20040201:1.24
	nextGenBranch:1.23.0.2
	nextGenRoot:1.23
	sce_3_30_20030627:1.23
	EndRw-branch:1.17.0.4
	Root-of-EndRw:1.17
	rwToStl:1.17.0.2
	latest_sce_3_10_20010924:1.9.0.2
	sce_3_10_20010924:1.9
	latest_sce_3_00_20010601:1.8.0.4
	sce_3_00_20010601:1.8
	latest_sce_2_31_20010308:1.8.0.2
	sce_2_31_20010308:1.8
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.54
date	2011.09.28.23.49.25;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2011.09.24.00.27.45;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2011.08.30.20.17.33;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2010.09.01.16.28.24;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.17.22.04.45;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.17.22.54.48;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2009.11.13.19.01.25;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.08.01.22.41.57;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.03.08.17.02.54;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.05.21.01.52;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.02.22.11.01;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.02.16.17.19;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.02.17.34.00;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.24.20.49.13;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.21.20.47.35;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.02.19.19.09;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.27.21.50.18;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.27.17.56.33;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.26.21.44.32;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.26.18.47.56;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.28.20.14.35;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.16.22.17.26;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.10.22.53.19;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.03.22.13.06;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.30.20.09.48;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.01.19.41.10;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.23.18.12.34;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.02.23.40.41;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.02.22.18.29;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.24.22.50.47;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.23.20.44.46;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.19.17.15.21;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.18.22.23.55;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.23.18.09.11;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.09.20.49.49;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.06.18.53.39;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.05.21.19.59;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.06.20.04.14;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.18.14.02.34;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.29.23.47.07;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.25.16.08.16;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.29.16.01.31;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.26.21.46.01;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.15.19.01.50;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.28.22.13.36;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.21.20.03.23;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.21.22.45;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.57;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.22;	author wit;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "HeurImp.C"
//
// Contains the implementation of the following classes:
//
//    HeurImploder
//    HeurImpPerf
//------------------------------------------------------------------------------

#include <HeurImp.h>
#include <HeurImpP.h>
#include <EqAll.h>
#include <HeurAllMgr.h>
#include <Pre.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Material.h>
#include <Demand.h>
#include <PtrVecSort.h>
#include <Timing.h>
#include <DataWrit.h>
#include <DetOptImpMgr.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class HeurImploder.
//------------------------------------------------------------------------------

WitHeurImploder::WitHeurImploder (WitProblem * theProblem):

      WitProbAssoc    (theProblem),
      priorityPer_ (-1)
   {
   }

//------------------------------------------------------------------------------

WitHeurImploder::~WitHeurImploder ()
   {
   }

//------------------------------------------------------------------------------

void WitHeurImploder::implode ()
   {
   WitHeurImpPerf thePerf (myProblem (), false);

   thePerf.implode ();
   }

//------------------------------------------------------------------------------

void WitHeurImploder::implodeForOpt ()
   {
   WitHeurImpPerf thePerf (myProblem (), true);

   thePerf.implode ();
   }

//------------------------------------------------------------------------------

void WitHeurImploder::genPriorities (WitSchedule <WitDemand, int> & newPriority)
   {
   int         theIdx;
   WitDemand * theDemand;

   WitPtrVec    <WitDemand> theDemVec;
   WitPtrVecItr <WitDemand> theItr;

   theDemVec.resize (myCompMgr ()->nDemands ());

   theIdx = -1;

   forEachDemand (theDemand, myProblem ())
      {
      theIdx ++;

      theDemVec[theIdx] = theDemand;
      }

   forEachPeriod (priorityPer_, myProblem ())
      {
      sort (theDemVec, & WitHeurImploder::compareDemands, this);

      theDemVec.attachItr (theItr);

      while (theItr.advance (theDemand))
         newPriority (theDemand)[priorityPer_] = theItr.myIdx () + 1;
      }
   }

//------------------------------------------------------------------------------

bool WitHeurImploder::compareDemands (
      WitDemand * theDemand1,
      WitDemand * theDemand2)
   {
   double        theVal1;
   double        theVal2;
   WitMaterial * theMat1;
   WitMaterial * theMat2;
   int           theIdx1;
   int           theIdx2;

   theVal1 = theDemand1->shipReward ()[priorityPer_];
   theVal2 = theDemand2->shipReward ()[priorityPer_];

   if (theVal1 > theVal2)
      return true;

   if (theVal1 < theVal2)
      return false;

   theVal1 = theDemand1->cumShipReward ()[priorityPer_];
   theVal2 = theDemand2->cumShipReward ()[priorityPer_];

   if (theVal1 > theVal2)
      return true;

   if (theVal1 < theVal2)
      return false;

   theMat1 = theDemand1->demandedPart ()->thisMat ();
   theMat2 = theDemand2->demandedPart ()->thisMat ();

   if (theMat1 != NULL)
      if (theMat2 != NULL)
         {
         theVal1 = theMat1->stockCost ()[priorityPer_];
         theVal2 = theMat2->stockCost ()[priorityPer_];

         if (theVal1 < theVal2)
            return true;

         if (theVal1 > theVal2)
            return false;
         }

   theIdx1 = theDemand1->mappingIndex ();
   theIdx2 = theDemand2->mappingIndex ();

   return (theIdx1 < theIdx2);
   }

//------------------------------------------------------------------------------
// Implementation of class HeurImpPerf.
//------------------------------------------------------------------------------

WitHeurImpPerf::WitHeurImpPerf (WitProblem * theProblem, bool forOptVal):
      WitProbAssoc    (theProblem),

      forOpt_         (forOptVal),
      tempPriority_   (),
      sortedDemVec_   (),
      modPriority_    (theProblem, 0),
      curDemPer_      (-1),
      unmetDemandVol_ (theProblem, 0.0),
      selDemPers_     (theProblem)
   {
   sortedDemVec_ .resize (theProblem->myCompMgr ()->nDemands ());
   }

//------------------------------------------------------------------------------

WitHeurImpPerf::~WitHeurImpPerf ()
   {
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::implode ()
   {
   WitTimer::enterSection ("heuristic");

   myPreprocessor ()->preprocess ();

   myMsgFac () ("heuristicMsg");

   genPriorities ();

   init ();

   if (forOpt_)
      myProblem ()->myHeurAllMgr ()->startForOpt ();
   else
      myProblem ()->myHeurAllMgr ()->start ();

   myEqAllocator ()->activate ();

   mainLoop ();

   if (myGlobalComp ()->inputPauses ())
      myProblem ()->pauseForInput ("at the conclusion of heur implosion");

   myProblem ()->myHeurAllMgr ()->finish ();

   WitTimer::leaveSection ("heuristic");
   }

//------------------------------------------------------------------------------

int WitHeurImpPerf::origPriority (WitDemand * theDemand, WitPeriod thePer) const
   {
   return 
      forOpt_?
         tempPriority_ (theDemand)[thePer]:
         theDemand->priority ()   [thePer];
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::genPriorities ()
   {
   if (forOpt_)
      {
      tempPriority_.allocate (myProblem (), 0);

      myProblem ()->myHeurImploder ()->genPriorities (tempPriority_);
      }
   else
      {
      if (myGlobalComp ()->autoPriority ())
         WitDemand::genPriorities (myProblem ());
      }
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::init ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   int         thePri;
   int         maxPri;
   int         theIdx;

   maxPri = 1;

   forEachDemand (theDemand, myProblem ())
       forEachPeriod (thePer, myProblem ())
          setToMax (maxPri, origPriority (theDemand, thePer));

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         thePri = origPriority (theDemand, thePer);

         modPriority_ (theDemand)[thePer] = 
            (thePri > 0)?
               thePri - 1:
               maxPri;
         }

   theIdx = -1;

   forEachDemand (theDemand, myProblem ())
      {
      theIdx ++;

      sortedDemVec_[theIdx]       = theDemand;

      unmetDemandVol_ (theDemand) = theDemand->demandVol ();
      }

   if (not forOpt_)
      if (myGlobalComp ()->userHeurStart ())
         allocShipVols ();
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::allocShipVols ()
   {
   WitDemand * theDemand;
   WitPeriod   demPer;
   double      unallocShipVol;

   forEachDemand (theDemand, myProblem ())
      {
      unallocShipVol = 0.0;

      for (demPer = lastPeriod (); demPer >= 0; demPer --)
         {
         unallocShipVol += theDemand->shipVol ()[demPer];

         net (unmetDemandVol_ (theDemand)[demPer], unallocShipVol);
         }
      }
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::mainLoop ()
   {
   WitPeriod demPer;
   WitPeriod shipPer;

   forEachPeriod (demPer, myProblem ())
      {
      if (prioritiesAreDifferent (demPer))
         {
         curDemPer_ = demPer;

         sort (
              sortedDemVec_,
            & WitHeurImpPerf::compareDemands,
              this);
         }

      for (shipPer = demPer; shipPer < nPeriods (); ++ shipPer)
         allocSortedDemands (demPer, shipPer);
      }
   }

//------------------------------------------------------------------------------

bool WitHeurImpPerf::prioritiesAreDifferent (WitPeriod demPer)
   {
   WitDemand * theDemand;

   if (demPer == 0)
      return true;

   forEachDemand (theDemand, myProblem ())
      if (modPriority_ (theDemand)[demPer] !=
          modPriority_ (theDemand)[demPer - 1])
         return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitHeurImpPerf::compareDemands (
      WitDemand * theDemand1,
      WitDemand * theDemand2)
   {
   int thePri1;
   int thePri2;
   int theIdx1;
   int theIdx2;

   thePri1 = modPriority_ (theDemand1)[curDemPer_];
   thePri2 = modPriority_ (theDemand2)[curDemPer_];

   if (thePri1 < thePri2)
      return true;

   if (thePri2 < thePri1)
      return false;

   theIdx1 = theDemand1->mappingIndex ();
   theIdx2 = theDemand2->mappingIndex ();

   return (theIdx1 < theIdx2);
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::allocSortedDemands (WitPeriod demPer, WitPeriod shipPer)
   {
   bool        eqAllNeeded;
   WitDemand * theDemand;

   WitPtrVecItr <WitDemand> theItr;

   eqAllNeeded = (myGlobalComp ()->equitability () > 1);

   sortedDemVec_.attachItr (theItr);

   while (theItr.advance (theDemand))
      {
      if (unmetDemandVol_ (theDemand)[demPer] < NET_TOL)
         continue;

      if (not theDemand->shipLateAllowed ())
         if (shipPer > demPer)
            continue;

      if (shipPer - demPer > theDemand->shipLateUB ()[demPer])
         continue;

      if (eqAllNeeded)
         selectForEqAlloc (theDemand, demPer, shipPer);
      else
         incAlloc         (theDemand, demPer, shipPer);
      }

   if (eqAllNeeded)
      if (not selDemPers_.isEmpty ())
         eqAlloc (demPer);
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::selectForEqAlloc (
      WitDemand * theDemand,
      WitPeriod   demPer,
      WitPeriod   shipPer)
   {
   if (not selDemPers_.isEmpty ())
      if (modPriority_ (theDemand)[demPer]
          !=
          modPriority_ (selDemPers_.firstObject ())[demPer])

         eqAlloc (demPer);

   selDemPers_.push (theDemand, shipPer);

   myEqAllocator ()->setDesIncVol (
      theDemand, 
      shipPer,
      unmetDemandVol_ (theDemand)[demPer]);

   if (myGlobalComp ()->twoWayMultiExec ())
      myEqAllocator ()->setAsapMultiExec (theDemand, shipPer, true);
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::eqAlloc (WitPeriod demPer)
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      incVolVal;

   selDemPers_.reverse ();

   myEqAllocator ()->eqAlloc (selDemPers_);

   if (myGlobalComp ()->printEqAlloc ())
      myEqAllocator ()->print (selDemPers_);

   while (selDemPers_.pop (theDemand, thePer))
      {
      incVolVal = myEqAllocator ()->incVol (theDemand, thePer);

      if (incVolVal >= NET_TOL)
         unmetDemandVol_ (theDemand)[demPer] -= incVolVal;
      }
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::incAlloc (
      WitDemand * theDemand,
      WitPeriod   demPer,
      WitPeriod   shipPer)
   {
   bool   asapMultiExec;
   double incVolVal;

   asapMultiExec = false;

   if (myGlobalComp ()->twoWayMultiExec ())
      asapMultiExec =
         myGlobalComp ()->twmeByDemand ()?
            theDemand->selForDel ():
            true;

   incVolVal =
      myProblem ()->myHeurAllMgr ()->incHeurAlloc (
         theDemand,
         shipPer,
         unmetDemandVol_ (theDemand)[demPer],
         asapMultiExec);

   if (incVolVal >= NET_TOL)
      unmetDemandVol_ (theDemand)[demPer] -= incVolVal;
   }
@


1.53
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.52
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d40 4
a43 4
WitProbAssoc    (theProblem),
priorityPer_ (-1)
{
}
d48 2
a49 2
{
}
d54 2
a55 2
{
WitHeurImpPerf thePerf (myProblem (), false);
d57 2
a58 2
thePerf.implode ();
}
d63 2
a64 2
{
WitHeurImpPerf thePerf (myProblem (), true);
d66 2
a67 2
thePerf.implode ();
}
d72 3
a74 3
{
int         theIdx;
WitDemand * theDemand;
d76 2
a77 2
WitPtrVec    <WitDemand> theDemVec;
WitPtrVecItr <WitDemand> theItr;
d79 1
a79 1
theDemVec.resize (myCompMgr ()->nDemands ());
d81 1
a81 1
theIdx = -1;
d83 3
a85 3
forEachDemand (theDemand, myProblem ())
{
theIdx ++;
d87 2
a88 2
theDemVec[theIdx] = theDemand;
}
d90 3
a92 3
forEachPeriod (priorityPer_, myProblem ())
{
sort (theDemVec, & WitHeurImploder::compareDemands, this);
d94 1
a94 1
theDemVec.attachItr (theItr);
d96 4
a99 4
while (theItr.advance (theDemand))
newPriority (theDemand)[priorityPer_] = theItr.myIdx () + 1;
}
}
d104 43
a146 43
WitDemand * theDemand1,
WitDemand * theDemand2)
{
double        theVal1;
double        theVal2;
WitMaterial * theMat1;
WitMaterial * theMat2;
int           theIdx1;
int           theIdx2;

theVal1 = theDemand1->shipReward ()[priorityPer_];
theVal2 = theDemand2->shipReward ()[priorityPer_];

if (theVal1 > theVal2)
return true;

if (theVal1 < theVal2)
return false;

theVal1 = theDemand1->cumShipReward ()[priorityPer_];
theVal2 = theDemand2->cumShipReward ()[priorityPer_];

if (theVal1 > theVal2)
return true;

if (theVal1 < theVal2)
return false;

theMat1 = theDemand1->demandedPart ()->thisMat ();
theMat2 = theDemand2->demandedPart ()->thisMat ();

if (theMat1 != NULL)
if (theMat2 != NULL)
{
theVal1 = theMat1->stockCost ()[priorityPer_];
theVal2 = theMat2->stockCost ()[priorityPer_];

if (theVal1 < theVal2)
return true;

if (theVal1 > theVal2)
return false;
}
d148 2
a149 2
theIdx1 = theDemand1->mappingIndex ();
theIdx2 = theDemand2->mappingIndex ();
d151 2
a152 2
return (theIdx1 < theIdx2);
}
d159 1
a159 1
WitProbAssoc    (theProblem),
d161 10
a170 10
forOpt_         (forOptVal),
tempPriority_   (),
sortedDemVec_   (),
modPriority_    (theProblem, 0),
curDemPer_      (-1),
unmetDemandVol_ (theProblem, 0.0),
selDemPers_     (theProblem)
{
sortedDemVec_ .resize (theProblem->myCompMgr ()->nDemands ());
}
d175 2
a176 2
{
}
d181 2
a182 2
{
WitTimer::enterSection ("heuristic");
d184 1
a184 1
myPreprocessor ()->preprocess ();
d186 1
a186 1
myMsgFac () ("heuristicMsg");
d188 1
a188 1
genPriorities ();
d190 1
a190 1
init ();
d192 4
a195 4
if (forOpt_)
myProblem ()->myHeurAllMgr ()->startForOpt ();
else
myProblem ()->myHeurAllMgr ()->start ();
d197 1
a197 1
myEqAllocator ()->activate ();
d199 1
a199 1
mainLoop ();
d201 2
a202 2
if (myGlobalComp ()->inputPauses ())
myProblem ()->pauseForInput ("at the conclusion of heur implosion");
d204 1
a204 1
myProblem ()->myHeurAllMgr ()->finish ();
d206 2
a207 2
WitTimer::leaveSection ("heuristic");
}
d212 6
a217 6
{
return
forOpt_?
tempPriority_ (theDemand)[thePer]:
theDemand->priority ()   [thePer];
}
d222 13
a234 13
{
if (forOpt_)
{
tempPriority_.allocate (myProblem (), 0);

myProblem ()->myHeurImploder ()->genPriorities (tempPriority_);
}
else
{
if (myGlobalComp ()->autoPriority ())
WitDemand::genPriorities (myProblem ());
}
}
d239 39
a277 39
{
WitDemand * theDemand;
WitPeriod   thePer;
int         thePri;
int         maxPri;
int         theIdx;

maxPri = 1;

forEachDemand (theDemand, myProblem ())
forEachPeriod (thePer, myProblem ())
setToMax (maxPri, origPriority (theDemand, thePer));

forEachDemand (theDemand, myProblem ())
forEachPeriod (thePer, myProblem ())
{
thePri = origPriority (theDemand, thePer);

modPriority_ (theDemand)[thePer] =
(thePri > 0)?
thePri - 1:
maxPri;
}

theIdx = -1;

forEachDemand (theDemand, myProblem ())
{
theIdx ++;

sortedDemVec_[theIdx]       = theDemand;

unmetDemandVol_ (theDemand) = theDemand->demandVol ();
}

if (not forOpt_)
if (myGlobalComp ()->userHeurStart ())
allocShipVols ();
}
d282 17
a298 17
{
WitDemand * theDemand;
WitPeriod   demPer;
double      unallocShipVol;

forEachDemand (theDemand, myProblem ())
{
unallocShipVol = 0.0;

for (demPer = lastPeriod (); demPer >= 0; demPer --)
{
unallocShipVol += theDemand->shipVol ()[demPer];

net (unmetDemandVol_ (theDemand)[demPer], unallocShipVol);
}
}
}
d303 20
a322 20
{
WitPeriod demPer;
WitPeriod shipPer;

forEachPeriod (demPer, myProblem ())
{
if (prioritiesAreDifferent (demPer))
{
curDemPer_ = demPer;

sort (
sortedDemVec_,
& WitHeurImpPerf::compareDemands,
this);
}

for (shipPer = demPer; shipPer < nPeriods (); ++ shipPer)
allocSortedDemands (demPer, shipPer);
}
}
d327 2
a328 2
{
WitDemand * theDemand;
d330 2
a331 2
if (demPer == 0)
return true;
d333 4
a336 4
forEachDemand (theDemand, myProblem ())
if (modPriority_ (theDemand)[demPer] !=
modPriority_ (theDemand)[demPer - 1])
return true;
d338 2
a339 2
return false;
}
d344 13
a356 13
WitDemand * theDemand1,
WitDemand * theDemand2)
{
int thePri1;
int thePri2;
int theIdx1;
int theIdx2;

thePri1 = modPriority_ (theDemand1)[curDemPer_];
thePri2 = modPriority_ (theDemand2)[curDemPer_];

if (thePri1 < thePri2)
return true;
d358 2
a359 2
if (thePri2 < thePri1)
return false;
d361 2
a362 2
theIdx1 = theDemand1->mappingIndex ();
theIdx2 = theDemand2->mappingIndex ();
d364 2
a365 2
return (theIdx1 < theIdx2);
}
d370 32
a401 32
{
bool        eqAllNeeded;
WitDemand * theDemand;

WitPtrVecItr <WitDemand> theItr;

eqAllNeeded = (myGlobalComp ()->equitability () > 1);

sortedDemVec_.attachItr (theItr);

while (theItr.advance (theDemand))
{
if (unmetDemandVol_ (theDemand)[demPer] < NET_TOL)
continue;

if (not theDemand->shipLateAllowed ())
if (shipPer > demPer)
continue;

if (shipPer - demPer > theDemand->shipLateUB ()[demPer])
continue;

if (eqAllNeeded)
selectForEqAlloc (theDemand, demPer, shipPer);
else
incAlloc         (theDemand, demPer, shipPer);
}

if (eqAllNeeded)
if (not selDemPers_.isEmpty ())
eqAlloc (demPer);
}
d406 21
a426 21
WitDemand * theDemand,
WitPeriod   demPer,
WitPeriod   shipPer)
{
if (not selDemPers_.isEmpty ())
if (modPriority_ (theDemand)[demPer]
!=
modPriority_ (selDemPers_.firstObject ())[demPer])

eqAlloc (demPer);

selDemPers_.push (theDemand, shipPer);

myEqAllocator ()->setDesIncVol (
theDemand,
shipPer,
unmetDemandVol_ (theDemand)[demPer]);

if (myGlobalComp ()->twoWayMultiExec ())
myEqAllocator ()->setAsapMultiExec (theDemand, shipPer, true);
}
d431 20
a450 20
{
WitDemand * theDemand;
WitPeriod   thePer;
double      incVolVal;

selDemPers_.reverse ();

myEqAllocator ()->eqAlloc (selDemPers_);

if (myGlobalComp ()->printEqAlloc ())
myEqAllocator ()->print (selDemPers_);

while (selDemPers_.pop (theDemand, thePer))
{
incVolVal = myEqAllocator ()->incVol (theDemand, thePer);

if (incVolVal >= NET_TOL)
unmetDemandVol_ (theDemand)[demPer] -= incVolVal;
}
}
d455 25
a479 25
WitDemand * theDemand,
WitPeriod   demPer,
WitPeriod   shipPer)
{
bool   asapMultiExec;
double incVolVal;

asapMultiExec = false;

if (myGlobalComp ()->twoWayMultiExec ())
asapMultiExec =
myGlobalComp ()->twmeByDemand ()?
theDemand->selForDel ():
true;

incVolVal =
myProblem ()->myHeurAllMgr ()->incHeurAlloc (
theDemand,
shipPer,
unmetDemandVol_ (theDemand)[demPer],
asapMultiExec);

if (incVolVal >= NET_TOL)
unmetDemandVol_ (theDemand)[demPer] -= incVolVal;
}
@


1.51
log
@pause/resume
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d40 4
a43 4
      WitProbAssoc    (theProblem),
      priorityPer_ (-1)
   {
   }
d48 2
a49 2
   {
   }
d54 2
a55 2
   {
   WitHeurImpPerf thePerf (myProblem (), false);
d57 2
a58 2
   thePerf.implode ();
   }
d63 2
a64 2
   {
   WitHeurImpPerf thePerf (myProblem (), true);
d66 2
a67 2
   thePerf.implode ();
   }
d72 3
a74 3
   {
   int         theIdx;
   WitDemand * theDemand;
d76 2
a77 2
   WitPtrVec    <WitDemand> theDemVec;
   WitPtrVecItr <WitDemand> theItr;
d79 1
a79 1
   theDemVec.resize (myCompMgr ()->nDemands ());
d81 1
a81 1
   theIdx = -1;
d83 3
a85 3
   forEachDemand (theDemand, myProblem ())
      {
      theIdx ++;
d87 2
a88 2
      theDemVec[theIdx] = theDemand;
      }
d90 3
a92 3
   forEachPeriod (priorityPer_, myProblem ())
      {
      sort (theDemVec, & WitHeurImploder::compareDemands, this);
d94 1
a94 1
      theDemVec.attachItr (theItr);
d96 4
a99 4
      while (theItr.advance (theDemand))
         newPriority (theDemand)[priorityPer_] = theItr.myIdx () + 1;
      }
   }
d104 43
a146 43
      WitDemand * theDemand1,
      WitDemand * theDemand2)
   {
   double        theVal1;
   double        theVal2;
   WitMaterial * theMat1;
   WitMaterial * theMat2;
   int           theIdx1;
   int           theIdx2;

   theVal1 = theDemand1->shipReward ()[priorityPer_];
   theVal2 = theDemand2->shipReward ()[priorityPer_];

   if (theVal1 > theVal2)
      return true;

   if (theVal1 < theVal2)
      return false;

   theVal1 = theDemand1->cumShipReward ()[priorityPer_];
   theVal2 = theDemand2->cumShipReward ()[priorityPer_];

   if (theVal1 > theVal2)
      return true;

   if (theVal1 < theVal2)
      return false;

   theMat1 = theDemand1->demandedPart ()->thisMat ();
   theMat2 = theDemand2->demandedPart ()->thisMat ();

   if (theMat1 != NULL)
      if (theMat2 != NULL)
         {
         theVal1 = theMat1->stockCost ()[priorityPer_];
         theVal2 = theMat2->stockCost ()[priorityPer_];

         if (theVal1 < theVal2)
            return true;

         if (theVal1 > theVal2)
            return false;
         }
d148 2
a149 2
   theIdx1 = theDemand1->mappingIndex ();
   theIdx2 = theDemand2->mappingIndex ();
d151 2
a152 2
   return (theIdx1 < theIdx2);
   }
d159 1
a159 1
      WitProbAssoc    (theProblem),
d161 10
a170 10
      forOpt_         (forOptVal),
      tempPriority_   (),
      sortedDemVec_   (),
      modPriority_    (theProblem, 0),
      curDemPer_      (-1),
      unmetDemandVol_ (theProblem, 0.0),
      selDemPers_     (theProblem)
   {
   sortedDemVec_ .resize (theProblem->myCompMgr ()->nDemands ());
   }
d175 2
a176 2
   {
   }
d181 2
a182 2
   {
   WitTimer::enterSection ("heuristic");
d184 1
a184 1
   myPreprocessor ()->preprocess ();
d186 1
a186 1
   myMsgFac () ("heuristicMsg");
d188 1
a188 1
   genPriorities ();
d190 1
a190 1
   init ();
d192 4
a195 4
   if (forOpt_)
      myProblem ()->myHeurAllMgr ()->startForOpt ();
   else
      myProblem ()->myHeurAllMgr ()->start ();
d197 1
a197 1
   myEqAllocator ()->activate ();
d199 1
a199 1
   mainLoop ();
d201 2
a202 2
   if (myGlobalComp ()->inputPauses ())
      myProblem ()->pauseForInput ("at the conclusion of heur implosion");
d204 1
a204 1
   myProblem ()->myHeurAllMgr ()->finish ();
d206 2
a207 2
   WitTimer::leaveSection ("heuristic");
   }
d212 6
a217 6
   {
   return 
      forOpt_?
         tempPriority_ (theDemand)[thePer]:
         theDemand->priority ()   [thePer];
   }
d222 13
a234 13
   {
   if (forOpt_)
      {
      tempPriority_.allocate (myProblem (), 0);

      myProblem ()->myHeurImploder ()->genPriorities (tempPriority_);
      }
   else
      {
      if (myGlobalComp ()->autoPriority ())
         WitDemand::genPriorities (myProblem ());
      }
   }
d239 39
a277 39
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   int         thePri;
   int         maxPri;
   int         theIdx;

   maxPri = 1;

   forEachDemand (theDemand, myProblem ())
       forEachPeriod (thePer, myProblem ())
          setToMax (maxPri, origPriority (theDemand, thePer));

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         thePri = origPriority (theDemand, thePer);

         modPriority_ (theDemand)[thePer] = 
            (thePri > 0)?
               thePri - 1:
               maxPri;
         }

   theIdx = -1;

   forEachDemand (theDemand, myProblem ())
      {
      theIdx ++;

      sortedDemVec_[theIdx]       = theDemand;

      unmetDemandVol_ (theDemand) = theDemand->demandVol ();
      }

   if (not forOpt_)
      if (myGlobalComp ()->userHeurStart ())
         allocShipVols ();
   }
d282 17
a298 17
   {
   WitDemand * theDemand;
   WitPeriod   demPer;
   double      unallocShipVol;

   forEachDemand (theDemand, myProblem ())
      {
      unallocShipVol = 0.0;

      for (demPer = lastPeriod (); demPer >= 0; demPer --)
         {
         unallocShipVol += theDemand->shipVol ()[demPer];

         net (unmetDemandVol_ (theDemand)[demPer], unallocShipVol);
         }
      }
   }
d303 20
a322 20
   {
   WitPeriod demPer;
   WitPeriod shipPer;

   forEachPeriod (demPer, myProblem ())
      {
      if (prioritiesAreDifferent (demPer))
         {
         curDemPer_ = demPer;

         sort (
              sortedDemVec_,
            & WitHeurImpPerf::compareDemands,
              this);
         }

      for (shipPer = demPer; shipPer < nPeriods (); ++ shipPer)
         allocSortedDemands (demPer, shipPer);
      }
   }
d327 2
a328 2
   {
   WitDemand * theDemand;
d330 2
a331 2
   if (demPer == 0)
      return true;
d333 4
a336 4
   forEachDemand (theDemand, myProblem ())
      if (modPriority_ (theDemand)[demPer] !=
          modPriority_ (theDemand)[demPer - 1])
         return true;
d338 2
a339 2
   return false;
   }
d344 13
a356 13
      WitDemand * theDemand1,
      WitDemand * theDemand2)
   {
   int thePri1;
   int thePri2;
   int theIdx1;
   int theIdx2;

   thePri1 = modPriority_ (theDemand1)[curDemPer_];
   thePri2 = modPriority_ (theDemand2)[curDemPer_];

   if (thePri1 < thePri2)
      return true;
d358 2
a359 2
   if (thePri2 < thePri1)
      return false;
d361 2
a362 2
   theIdx1 = theDemand1->mappingIndex ();
   theIdx2 = theDemand2->mappingIndex ();
d364 2
a365 2
   return (theIdx1 < theIdx2);
   }
d370 32
a401 32
   {
   bool        eqAllNeeded;
   WitDemand * theDemand;

   WitPtrVecItr <WitDemand> theItr;

   eqAllNeeded = (myGlobalComp ()->equitability () > 1);

   sortedDemVec_.attachItr (theItr);

   while (theItr.advance (theDemand))
      {
      if (unmetDemandVol_ (theDemand)[demPer] < NET_TOL)
         continue;

      if (not theDemand->shipLateAllowed ())
         if (shipPer > demPer)
            continue;

      if (shipPer - demPer > theDemand->shipLateUB ()[demPer])
         continue;

      if (eqAllNeeded)
         selectForEqAlloc (theDemand, demPer, shipPer);
      else
         incAlloc         (theDemand, demPer, shipPer);
      }

   if (eqAllNeeded)
      if (not selDemPers_.isEmpty ())
         eqAlloc (demPer);
   }
d406 21
a426 21
      WitDemand * theDemand,
      WitPeriod   demPer,
      WitPeriod   shipPer)
   {
   if (not selDemPers_.isEmpty ())
      if (modPriority_ (theDemand)[demPer]
          !=
          modPriority_ (selDemPers_.firstObject ())[demPer])

         eqAlloc (demPer);

   selDemPers_.push (theDemand, shipPer);

   myEqAllocator ()->setDesIncVol (
      theDemand, 
      shipPer,
      unmetDemandVol_ (theDemand)[demPer]);

   if (myGlobalComp ()->twoWayMultiExec ())
      myEqAllocator ()->setAsapMultiExec (theDemand, shipPer, true);
   }
d431 20
a450 20
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      incVolVal;

   selDemPers_.reverse ();

   myEqAllocator ()->eqAlloc (selDemPers_);

   if (myGlobalComp ()->printEqAlloc ())
      myEqAllocator ()->print (selDemPers_);

   while (selDemPers_.pop (theDemand, thePer))
      {
      incVolVal = myEqAllocator ()->incVol (theDemand, thePer);

      if (incVolVal >= NET_TOL)
         unmetDemandVol_ (theDemand)[demPer] -= incVolVal;
      }
   }
d455 25
a479 25
      WitDemand * theDemand,
      WitPeriod   demPer,
      WitPeriod   shipPer)
   {
   bool   asapMultiExec;
   double incVolVal;

   asapMultiExec = false;

   if (myGlobalComp ()->twoWayMultiExec ())
      asapMultiExec =
         myGlobalComp ()->twmeByDemand ()?
            theDemand->selForDel ():
            true;

   incVolVal =
      myProblem ()->myHeurAllMgr ()->incHeurAlloc (
         theDemand,
         shipPer,
         unmetDemandVol_ (theDemand)[demPer],
         asapMultiExec);

   if (incVolVal >= NET_TOL)
      unmetDemandVol_ (theDemand)[demPer] -= incVolVal;
   }
@


1.50
log
@Lead Time Bounds
@
text
@d201 1
a201 1
   if (myGlobalComp ()->pauses ())
@


1.49
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d471 1
a471 1
      myProblem ()->myHeurAllMgr ()->inc (
@


1.48
log
@Removing objective #2.
@
text
@d24 1
a24 1
#include <Global.h>
@


1.47
log
@Removing objective #2.
@
text
@d26 1
a26 1
#include <Part.h>
d39 3
a41 1
      WitProbAssoc (theProblem)
d70 85
d227 1
a227 1
      myOptComp ()->objChoice ()->genPriorities (tempPriority_);
d232 1
a232 1
         myProblem ()->genPriorities ();
@


1.46
log
@Stochastic Implosion
@
text
@d380 1
a380 1
            (theDemand->grossRev () < 5.0):
@


1.45
log
@[disallowed backlog]
@
text
@d31 1
a31 1
#include <OptImp.h>
@


1.44
log
@[disallowed backlog]
@
text
@d298 1
a298 1
      if (not theDemand->backlogAllowed ())
@


1.43
log
@[disallowed backlog]
@
text
@d298 4
a304 5
      if (forOpt_)
         if (not theDemand->backlogAllowed ())
            if (shipPer > demPer)
               continue;

@


1.42
log
@[disallowed backlog]
@
text
@d302 1
a302 1
         if (theDemand->disallowBacklog ())
@


1.41
log
@App controlled opt implosion.
@
text
@d301 5
@


1.40
log
@Updated the copyright date on all source files.
@
text
@d23 1
d97 1
a97 1
   myProblem ()->preprocess ();
@


1.39
log
@Fixed bugs:
   witWriteData didn't write problem.compPrices.
   witWriteData didn't write problem.accMethod.
   witCopyData  didn't copy  problem.solverLogFileName.
   witCopyData  didn't copy  problem.accMethod.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.38
log
@GPIP
@
text
@d203 1
a203 1
      for (demPer = nPeriods () - 1; demPer >= 0; demPer --)
@


1.37
log
@[shared-resource pegging]
@
text
@d114 1
a114 1
      myProblem ()->pauseForInput ();
@


1.36
log
@[multi-thread]
@
text
@d27 1
d71 1
a71 1
      WitProbAssoc      (theProblem),
d73 7
a79 7
      forOpt_           (forOptVal),
      tempPriority_     (),
      sortedDemands_    (),
      modPriority_      (theProblem, 0),
      currDemandPeriod_ (-1),
      unmetDemandVol_   (theProblem, 0.0),
      selDemPers_       (theProblem)
d81 1
a81 1
   sortedDemands_.resize (theProblem->myCompMgr ()->nDemands ());
d156 1
d175 2
d179 3
a181 1
      sortedDemands_.append (theDemand);
d223 1
a223 1
         currDemandPeriod_ = demPer;
d225 4
a228 1
         sortedDemands_.sort (comparePriorities, this);
d255 1
a255 1
int WitHeurImpPerf::comparePriorities (
d257 1
a257 2
      WitDemand * theDemand2,
      void *      theContext)
d259 4
a262 6
   WitHeurImpPerf * theHeurImpPerf;
   WitPeriod        demPer;
   int              priority1;
   int              priority2;
   int              theIdx1;
   int              theIdx2;
d264 2
a265 1
   theHeurImpPerf = static_cast <WitHeurImpPerf *> (theContext);
d267 2
a268 9
   demPer         = theHeurImpPerf->currDemandPeriod_;

   priority1      = theHeurImpPerf->modPriority_ (theDemand1)[demPer];
   priority2      = theHeurImpPerf->modPriority_ (theDemand2)[demPer];

      // First compare the priority values
      //
   if (priority1 < priority2)
      return -1;    // theDemand1 wins.
d270 2
a271 2
   if (priority2 < priority1)
      return  1;    // theDemand2 wins.
a272 2
      // Next, check is for global index.
      //
d276 1
a276 21

   if (theIdx1 < theIdx2)
      return -1;

   if (theIdx2 < theIdx1)
      return  1;

      // Check for same Demand.
      // This is possible in some implementations of qsort.
      //
   if (theDemand1 == theDemand2)
      return 0;

   stronglyAssert (false);
      //
      // If it gets here, the Demands were distinct, but their sorting
      // data tied, which indicates an error.

   return 0;
      //
      // fatalError won't return, but this will make c++ happy
d286 2
d290 3
a292 1
   forEachElDense (theDemand, sortedDemands_)
@


1.35
log
@[multi-thread]
@
text
@a29 1
#include <DLSort.h>
d219 1
a219 4
         WitDLSorter <WitDemand, WitHeurImpPerf>::sort (
            sortedDemands_,
            comparePriorities,
            this);
d247 17
a263 10
      WitDemand *      theDemand1,
      WitDemand *      theDemand2,
      WitHeurImpPerf * theHeurImpPerf)
   {
   WitPeriod demPer = theHeurImpPerf->currDemandPeriod_;

   int p1 = theHeurImpPerf->modPriority_ (theDemand1)[demPer];
   int p2 = theHeurImpPerf->modPriority_ (theDemand2)[demPer];
   int i1;
   int i2;
d267 1
a267 1
   if (p1 < p2)
d270 1
a270 1
   if (p2 < p1)
d275 2
a276 2
   i1 = theDemand1->mappingIndex ();
   i2 = theDemand2->mappingIndex ();
d279 1
a279 1
   if (i1 < i2)
d282 1
a282 1
   if (i2 < i1)
@


1.34
log
@[multi-thread]
@
text
@d221 3
a223 3
              sortedDemands_,
            & WitHeurImpPerf::comparePriorities,
              this);
d250 4
a253 1
int WitHeurImpPerf::comparePriorities (WitDemand * d1, WitDemand * d2)
d255 1
a255 1
   WitPeriod demPer = currDemandPeriod_;
d257 2
a258 2
   int p1 = modPriority_ (d1)[demPer];
   int p2 = modPriority_ (d2)[demPer];
d265 1
a265 1
      return -1;    // d1 wins.
d268 1
a268 1
      return  1;    // d2 wins.
d272 2
a273 2
   i1 = d1->mappingIndex ();
   i2 = d2->mappingIndex ();
d285 1
a285 1
   if (d1 == d2)
@


1.33
log
@[multi-thread]
@
text
@d30 1
d220 1
a220 1
         WitNonClass::sort (
@


1.32
log
@Revised mappingIndex code.
@
text
@a68 4
WitHeurImpPerf * WitHeurImpPerf::sortingInstance_ = NULL;

//------------------------------------------------------------------------------

d219 4
a222 5
         sortingInstance_  = this;

         sortedDemands_.sort (comparePriorities);

         sortingInstance_  = NULL;
d251 1
a251 1
   WitPeriod demPer = sortingInstance_->currDemandPeriod_;
d253 2
a254 2
   int p1 = sortingInstance_->modPriority_ (d1)[demPer];
   int p2 = sortingInstance_->modPriority_ (d2)[demPer];
@


1.31
log
@PIP.
@
text
@a30 1
#include <MapIdxI.h>
@


1.30
log
@Fixed a bug that occurred when a priority was specified as MAX_INT.
@
text
@d182 1
a182 1
      theDemand->demandVol ().copyInto (unmetDemandVol_ (theDemand));
@


1.29
log
@Double Precision.
@
text
@d80 1
a80 1
      priority_         (theProblem, 0),
d159 1
a160 8
   int maxPri;
      //
      // maximum priority

      // Make one pass through the demand priority vectors to determine
      // the largest priority value.  We need this because we will change
      // all non-positive priorities to some "large enough" double value
      //
d165 1
a165 6
          if (origPriority (theDemand, thePer) > maxPri)
             maxPri = origPriority (theDemand, thePer);

      // Now increment so that maxPri > all demand priorities
      //
   maxPri++;
a167 3
      {
      sortedDemands_.append (theDemand);

d172 1
a172 1
         priority_ (theDemand)[thePer] = 
d174 1
a174 1
               thePri:
d178 4
d246 2
a247 2
      if (priority_ (theDemand)[demPer] !=
          priority_ (theDemand)[demPer - 1])
d259 2
a260 2
   int p1 = sortingInstance_->priority_ (d1)[demPer];
   int p2 = sortingInstance_->priority_ (d2)[demPer];
d336 1
a336 1
      if (priority_ (theDemand)[demPer]
d338 1
a338 1
          priority_ (selDemPers_.firstObject ())[demPer])
@


1.28
log
@Double Precision.
@
text
@d193 1
a193 1
      theDemand->demandVol ().convCopyInto (unmetDemandVol_ (theDemand));
@


1.27
log
@Double Precision.
@
text
@d166 1
a166 1
      // all non-positive priorities to some "large enough" float value
@


1.26
log
@Double Precision.
@
text
@d193 1
a193 1
      theDemand->demandVol ().copyIntoDblTVec (unmetDemandVol_ (theDemand));
@


1.25
log
@Began implementation of double precision.
@
text
@d193 1
a193 1
      copyInto (unmetDemandVol_ (theDemand), theDemand->demandVol ());
@


1.24
log
@Continued implementation of post-implosion pegging.
@
text
@d117 3
@


1.23
log
@Continued implementation of opt with COIN.
@
text
@a29 1
#include <ScheduleI.h>
d31 1
@


1.22
log
@Internal changes.
@
text
@d98 1
a98 1
   WitTimingEvent theEvent ("heuristic");
d118 2
@


1.21
log
@Internal changes.
@
text
@d191 1
a191 1
   if (! forOpt_)
d330 1
a330 1
      if (! selDemPers_.isEmpty ())
d341 1
a341 1
   if (! selDemPers_.isEmpty ())
@


1.20
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d52 1
a52 1
   WitHeurImpPerf thePerf (myProblem (), witFALSE);
d61 1
a61 1
   WitHeurImpPerf thePerf (myProblem (), witTRUE);
d74 1
a74 1
WitHeurImpPerf::WitHeurImpPerf (WitProblem * theProblem, WitBoolean forOptVal):
d244 1
a244 1
WitBoolean WitHeurImpPerf::prioritiesAreDifferent (WitPeriod demPer)
d249 1
a249 1
      return witTRUE;
d254 1
a254 1
         return witTRUE;
d256 1
a256 1
   return witFALSE;
d296 1
a296 1
   stronglyAssert (witFALSE);
d310 1
a310 1
   WitBoolean  eqAllNeeded;
d356 1
a356 1
      myEqAllocator ()->setAsapMultiExec (theDemand, shipPer, witTRUE);
d390 2
a391 2
   WitBoolean asapMultiExec;
   double     incVolVal;
d393 1
a393 1
   asapMultiExec = witFALSE;
d399 1
a399 1
            witTRUE;
@


1.19
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d191 3
a193 2
   if (myGlobalComp ()->userHeurStart ())
      allocShipVols ();
@


1.18
log
@Continued implementation of heuristic initial solution.
@
text
@d191 1
a191 1
   if (myGlobalComp ()->heurInitSoln ())
@


1.17
log
@Continued implementation of heuristic implosion from an initial solution.
Added some debugging code to Single-Source.
@
text
@d190 24
@


1.16
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d196 1
a196 1
   WitPeriod demandPer;
d199 1
a199 1
   forEachPeriod (demandPer, myProblem ())
d201 1
a201 1
      if (prioritiesAreDifferent (demandPer))
d203 1
a203 1
         currDemandPeriod_ = demandPer;
d212 2
a213 2
      for (shipPer = demandPer; shipPer < nPeriods (); ++ shipPer)
         allocSortedDemands (demandPer, shipPer);
d219 1
a219 1
WitBoolean WitHeurImpPerf::prioritiesAreDifferent (WitPeriod demandPer)
d223 1
a223 1
   if (demandPer == 0)
d227 2
a228 2
      if (priority_ (theDemand)[demandPer] !=
          priority_ (theDemand)[demandPer - 1])
d238 1
a238 1
   WitPeriod demandPer = sortingInstance_->currDemandPeriod_;
d240 2
a241 2
   int p1 = sortingInstance_->priority_ (d1)[demandPer];
   int p2 = sortingInstance_->priority_ (d2)[demandPer];
d283 1
a283 1
void WitHeurImpPerf::allocSortedDemands (WitPeriod demandPer, WitPeriod shipPer)
d292 1
a292 1
      if (unmetDemandVol_ (theDemand)[demandPer] < NET_TOL)
d295 1
a295 1
      if (shipPer - demandPer > theDemand->shipLateUB ()[demandPer])
d299 1
a299 1
         selectForEqAlloc (theDemand, demandPer, shipPer);
d301 1
a301 1
         incAlloc         (theDemand, demandPer, shipPer);
d306 1
a306 1
         eqAlloc (demandPer);
d313 1
a313 1
      WitPeriod   demandPer,
d317 1
a317 1
      if (priority_ (theDemand)[demandPer]
d319 1
a319 1
          priority_ (selDemPers_.firstObject ())[demandPer])
d321 1
a321 1
         eqAlloc (demandPer);
d328 1
a328 1
      unmetDemandVol_ (theDemand)[demandPer]);
d336 1
a336 1
void WitHeurImpPerf::eqAlloc (WitPeriod demandPer)
d340 1
d350 6
a355 4
      decUnmetDemand (
         theDemand,
         demandPer,
         myEqAllocator ()->incVol (theDemand, thePer));
d362 1
a362 1
      WitPeriod   demandPer,
d380 1
a380 1
         unmetDemandVol_ (theDemand)[demandPer],
a382 10
   decUnmetDemand (theDemand, demandPer, incVolVal);
   }

//------------------------------------------------------------------------------

void WitHeurImpPerf::decUnmetDemand (
      WitDemand * theDemand,
      WitPeriod   demandPer,
      double      incVolVal)
   {
d384 1
a384 1
      unmetDemandVol_ (theDemand)[demandPer] -= incVolVal;
@


1.15
log
@Continued implementation of Single-Source.
@
text
@d23 4
@


1.14
log
@Continued implementation of Single-Source.
@
text
@a25 1
#include <Dense.h>
d75 1
a75 1
      sortedDemands_    (* new WitDenseList <WitDemand>),
a87 1
   delete & sortedDemands_;
@


1.13
log
@Continued implementation of single-source.
@
text
@d27 1
@


1.12
log
@Continued preliminary work on single source.
@
text
@d123 1
a123 1
         tempPriority_ (theDemand, thePer):
d179 1
a179 1
         priority_ (theDemand, thePer) = 
d224 2
a225 2
      if (priority_ (theDemand, demandPer) !=
          priority_ (theDemand, demandPer - 1))
d237 2
a238 2
   int p1 = sortingInstance_->priority_ (d1, demandPer);
   int p2 = sortingInstance_->priority_ (d2, demandPer);
d289 1
a289 1
      if (unmetDemandVol_ (theDemand, demandPer) < NET_TOL)
d314 1
a314 1
      if (priority_ (theDemand,                  demandPer)
d316 1
a316 1
          priority_ (selDemPers_.firstObject (), demandPer))
d325 1
a325 1
      unmetDemandVol_ (theDemand, demandPer));
d374 1
a374 1
         unmetDemandVol_ (theDemand, demandPer),
d388 1
a388 1
      unmetDemandVol_ (theDemand, demandPer) -= incVolVal;
@


1.11
log
@Began implementation of object iteration.
@
text
@d26 1
d75 1
a75 1
      sortedDemands_    (theProblem->myCompMgr ()->nDemands ()),
d81 1
d88 1
@


1.10
log
@Continued implementation of sel-split for pen-exec.
@
text
@d26 1
@


1.9
log
@Initial implementation of pegging.
@
text
@d264 2
a267 3
      //
   WitMsgFacility::current () ("internalErrorFmsg",
      "WitHeurImpPerf::comparePriorities");
@


1.8
log
@Corrected a recent bug in two-way multi-exec.
@
text
@d22 1
a22 1
#include <HeurAll.h>
d102 1
a102 1
      myProblem ()->myHeurAllocator ()->startForOpt ();
d104 1
a104 1
      myProblem ()->myHeurAllocator ()->start ();
d110 1
a110 1
   myProblem ()->myHeurAllocator ()->finish ();
d368 1
a368 1
      myProblem ()->myHeurAllocator ()->inc (
@


1.7
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d325 1
a325 1
      myEqAllocator ()->setAsapMultiExec (theDemand, shipPer, witFALSE);
@


1.6
log
@Fixed some bugs in coarse selection splitting.
@
text
@d77 1
a77 2
      selDemPers_       (theProblem),
      asapMultiExec_    (witFALSE)
a182 5

   asapMultiExec_ =
      myGlobalComp ()->twoWayMultiExec ()?
         myGlobalComp ()->twmeIsAsap ():
         witFALSE;
d325 1
a325 1
      myEqAllocator ()->setAsapMultiExec (theDemand, shipPer, asapMultiExec_);
d356 10
a365 1
   double incVolVal;
d372 1
a372 1
         asapMultiExec_);
@


1.5
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d323 1
a323 1
   selDemPers_.put (theDemand, shipPer);
d348 1
a348 1
   while (selDemPers_.get (theDemand, thePer))
@


1.4
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d323 1
a323 1
   selDemPers_.push (theDemand, shipPer);
d348 1
a348 1
   while (selDemPers_.pop (theDemand, thePer))
@


1.3
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d182 1
a182 1
      copyTo (unmetDemandVol_ (theDemand), theDemand->demandVol ());
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d182 1
a182 1
      copy (unmetDemandVol_ (theDemand), theDemand->demandVol ());
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.44;
access;
symbols
	sce_5_01_20080919:1.38
	latest_sce_4_20_20060523:1.35.0.2
	sce_4_20_20060523:1.35
	latest_sce4_20_OSL:1.34.0.2
	sce_4_20_OSL:1.34
	sce_410_withVa:1.30
	sce_4_05_20040511:1.27
	sce_4_00_20040201:1.23
	nextGenBranch:1.19.0.2
	nextGenRoot:1.19
	sce_3_30_20030627:1.16
	EndRw-branch:1.9.0.4
	Root-of-EndRw:1.9
	rwToStl:1.9.0.2
	latest_sce_3_10_20010924:1.6.0.2
	sce_3_10_20010924:1.6
	latest_sce_3_00_20010601:1.5.0.4
	sce_3_00_20010601:1.5
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2011.09.28.23.50.38;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.24.00.28.53;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.08.30.20.18.21;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.02.18.18.50.54;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.09.18.13.39;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.12.19.52.25;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2008.02.25.19.37.57;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.08.01.22.41.59;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.11.16.19.12;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.02.17.34.15;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.15.18.57.52;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.14.21.54.45;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.13.19.38.08;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.13.19.31.57;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.06.21.30.28;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.06.20.43.26;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.07.15.16.24;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.12.15.09.24;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.20.22.46.03;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.20.16.38.01;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.08.19.27.44;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.01.21.05.06;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.06.23.31.50;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.06.21.37.20;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.24.15.31.12;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.24.01.25.47;	author fasano;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.10.20.24.47;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.23.18.12.40;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.06.20.22.45;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.29.15.04.01;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.28.17.40.31;	author dpc;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.23.20.47.21;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.02.23.40.53;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.02.22.18.54;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.24.18.26.09;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.14.02.47;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.29.23.47.12;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.23.21.13.55;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.27.00.24.40;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.28;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.10.23.17.46;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.04;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.31;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.31;	author wit;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Util.C"
//
// Contains the implementation of utility functions declared in Util.h.
//------------------------------------------------------------------------------

#include <DetOptImpMgr.h>
#include <Timing.h>
#include <MsgFac.h>
#include <Session.h>

#include <stdlib.h>

//------------------------------------------------------------------------------

bool WitNonClass::equalCstrings (const char * lhs, const char * rhs)
   {
   return (strcmp (lhs, rhs) == 0);
   }

//------------------------------------------------------------------------------

void WitNonClass::net (double & val1, double & val2)
   {
   if (val1 <= val2)
      {
      val2 -= val1;
      val1  = 0.0;
      }
   else
      {
      val1 -= val2;
      val2  = 0.0;
      }
   }

//------------------------------------------------------------------------------

int WitNonClass::sign (int theVal)
   {
   if (theVal > 0)
      return +1;

   if (theVal < 0)
      return -1;

   return 0;
   }

//------------------------------------------------------------------------------

int WitNonClass::sign (double theVal)
   {
   if (theVal > + FLOAT_EPSILON)
      return +1;

   if (theVal < - FLOAT_EPSILON)
      return -1;

   return 0;
   }

//------------------------------------------------------------------------------

void WitNonClass::assertFunc (
      bool         assertion,
      const char * srcFileName,
      int          lineNo,
      const char * assertionString)
   {
   if (not assertion)
      WitMsgFacility::issueByException ("assertFailFmsg",
         srcFileName,
         lineNo,
         assertionString);
   }

//------------------------------------------------------------------------------

void WitNonClass::nonMsgAssertFunc (
      bool         assertion,
      const char * srcFileName,
      int          lineNo,
      const char * assertionString)
   {
   if (not assertion)
      {
      fprintf (stderr,
         "\n"
         "FATAL ERROR encountered by WIT.\n"
         "\n"
         "   Non-message assertion failure:\n"
         "      Source File: %s\n"
         "      Line #:      %d\n"
         "      Assertion:   %s\n",
         srcFileName,
         lineNo,
         assertionString);

      exitWitNonMsg (4);
      }
   }

//------------------------------------------------------------------------------

void WitNonClass::forbidNullArg (
      const void * theArg,
      const char * argName,
      const char * funcName)
   {
   if (theArg != NULL)
      return;

   startNonMsgSevereError ();

   fprintf (stderr,
      "A function argument was passed as a null pointer "
      "where this in not allowed.\n"
      "\n"
      "   Argument: %s\n"
      "   Function: %s\n",
      argName, funcName);

   finishNonMsgSevereError ();
   }

//------------------------------------------------------------------------------

bool WitNonClass::isNullCstring (const char * theCstring)
   {
   return (strlen (theCstring) == 0);
   }

//------------------------------------------------------------------------------

double WitNonClass::percentToFrac (int thePercent)
   {
   return
      (thePercent == 0)?
         0.0:
         static_cast <double> (thePercent) / 100.0;
   }

//------------------------------------------------------------------------------

int WitNonClass::fracToPercent (double theFrac)
   {
   return static_cast <int> (floor (theFrac * 100.0 + 0.5));
   }

//------------------------------------------------------------------------------

void WitNonClass::startNonMsgSevereError ()
   {
   fprintf (stderr,
      "\n"
      "SEVERE ERROR encountered by WIT:\n"
      "\n");
   }

//------------------------------------------------------------------------------

void WitNonClass::finishNonMsgSevereError ()
   {
   exitWitNonMsg (3);
   }

//------------------------------------------------------------------------------

void WitNonClass::issueNonMsgFatalError (const char * funcName)
   {
   fprintf (stderr,
      "\n"
      "FATAL ERROR encountered by WIT.\n"
      "\n"
      "The error occurred in function %s.\n",
      funcName);

   exitWitNonMsg (4);
   }

//------------------------------------------------------------------------------

void WitNonClass::exitWitNonMsg (int theRc)
   {
   if (theRc == 4)
      fprintf (stderr,
         "\n"
         "The above message indicates that there is a programming error in "
         "WIT.\n");

   fprintf (stderr,
      "\n"
      "WIT is now terminating execution of the program.\n"
      "The return code is %d.\n"
      "\n",
      theRc);

   fflush (stderr);

   exit (theRc);
   }
@


1.43
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.42
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d26 3
a28 3
{
return (strcmp (lhs, rhs) == 0);
}
d33 12
a44 12
{
if (val1 <= val2)
{
val2 -= val1;
val1  = 0.0;
}
else
{
val1 -= val2;
val2  = 0.0;
}
}
d49 3
a51 3
{
if (theVal > 0)
return +1;
d53 2
a54 2
if (theVal < 0)
return -1;
d56 2
a57 2
return 0;
}
d62 3
a64 3
{
if (theVal > + FLOAT_EPSILON)
return +1;
d66 2
a67 2
if (theVal < - FLOAT_EPSILON)
return -1;
d69 2
a70 2
return 0;
}
d75 11
a85 11
bool         assertion,
const char * srcFileName,
int          lineNo,
const char * assertionString)
{
if (not assertion)
WitMsgFacility::issueByException ("assertFailFmsg",
srcFileName,
lineNo,
assertionString);
}
d90 22
a111 22
bool         assertion,
const char * srcFileName,
int          lineNo,
const char * assertionString)
{
if (not assertion)
{
fprintf (stderr,
"\n"
"FATAL ERROR encountered by WIT.\n"
"\n"
"   Non-message assertion failure:\n"
"      Source File: %s\n"
"      Line #:      %d\n"
"      Assertion:   %s\n",
srcFileName,
lineNo,
assertionString);

exitWitNonMsg (4);
}
}
d116 16
a131 16
const void * theArg,
const char * argName,
const char * funcName)
{
if (theArg != NULL)
return;

startNonMsgSevereError ();

fprintf (stderr,
"A function argument was passed as a null pointer "
"where this in not allowed.\n"
"\n"
"   Argument: %s\n"
"   Function: %s\n",
argName, funcName);
d133 2
a134 2
finishNonMsgSevereError ();
}
d139 3
a141 3
{
return (strlen (theCstring) == 0);
}
d146 6
a151 6
{
return
(thePercent == 0)?
0.0:
static_cast <double> (thePercent) / 100.0;
}
d156 3
a158 3
{
return static_cast <int> (floor (theFrac * 100.0 + 0.5));
}
d163 6
a168 6
{
fprintf (stderr,
"\n"
"SEVERE ERROR encountered by WIT:\n"
"\n");
}
d173 3
a175 3
{
exitWitNonMsg (3);
}
d180 7
a186 7
{
fprintf (stderr,
"\n"
"FATAL ERROR encountered by WIT.\n"
"\n"
"The error occurred in function %s.\n",
funcName);
d188 2
a189 2
exitWitNonMsg (4);
}
d194 13
a206 13
{
if (theRc == 4)
fprintf (stderr,
"\n"
"The above message indicates that there is a programming error in "
"WIT.\n");

fprintf (stderr,
"\n"
"WIT is now terminating execution of the program.\n"
"The return code is %d.\n"
"\n",
theRc);
d208 1
a208 1
fflush (stderr);
d210 2
a211 2
exit (theRc);
}
@


1.41
log
@Fixed a bug in the assertion code.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d26 3
a28 3
   {
   return (strcmp (lhs, rhs) == 0);
   }
d33 12
a44 12
   {
   if (val1 <= val2)
      {
      val2 -= val1;
      val1  = 0.0;
      }
   else
      {
      val1 -= val2;
      val2  = 0.0;
      }
   }
d49 3
a51 3
   {
   if (theVal > 0)
      return +1;
d53 2
a54 2
   if (theVal < 0)
      return -1;
d56 2
a57 2
   return 0;
   }
d62 3
a64 3
   {
   if (theVal > + FLOAT_EPSILON)
      return +1;
d66 2
a67 2
   if (theVal < - FLOAT_EPSILON)
      return -1;
d69 2
a70 2
   return 0;
   }
d75 11
a85 11
      bool         assertion,
      const char * srcFileName,
      int          lineNo,
      const char * assertionString)
   {
   if (not assertion)
      WitMsgFacility::issueByException ("assertFailFmsg",
         srcFileName,
         lineNo,
         assertionString);
   }
d90 22
a111 22
      bool         assertion,
      const char * srcFileName,
      int          lineNo,
      const char * assertionString)
   {
   if (not assertion)
      {
      fprintf (stderr,
         "\n"
         "FATAL ERROR encountered by WIT.\n"
         "\n"
         "   Non-message assertion failure:\n"
         "      Source File: %s\n"
         "      Line #:      %d\n"
         "      Assertion:   %s\n",
         srcFileName,
         lineNo,
         assertionString);

      exitWitNonMsg (4);
      }
   }
d116 16
a131 16
      const void * theArg,
      const char * argName,
      const char * funcName)
   {
   if (theArg != NULL)
      return;

   startNonMsgSevereError ();

   fprintf (stderr,
      "A function argument was passed as a null pointer "
      "where this in not allowed.\n"
      "\n"
      "   Argument: %s\n"
      "   Function: %s\n",
      argName, funcName);
d133 2
a134 2
   finishNonMsgSevereError ();
   }
d139 3
a141 3
   {
   return (strlen (theCstring) == 0);
   }
d146 6
a151 6
   {
   return
      (thePercent == 0)?
         0.0:
         static_cast <double> (thePercent) / 100.0;
   }
d156 3
a158 3
   {
   return static_cast <int> (floor (theFrac * 100.0 + 0.5));
   }
d163 6
a168 6
   {
   fprintf (stderr,
      "\n"
      "SEVERE ERROR encountered by WIT:\n"
      "\n");
   }
d173 3
a175 3
   {
   exitWitNonMsg (3);
   }
d180 7
a186 7
   {
   fprintf (stderr,
      "\n"
      "FATAL ERROR encountered by WIT.\n"
      "\n"
      "The error occurred in function %s.\n",
      funcName);
d188 2
a189 2
   exitWitNonMsg (4);
   }
d194 13
a206 13
   {
   if (theRc == 4)
      fprintf (stderr,
         "\n"
         "The above message indicates that there is a programming error in "
         "WIT.\n");

   fprintf (stderr,
      "\n"
      "WIT is now terminating execution of the program.\n"
      "The return code is %d.\n"
      "\n",
      theRc);
d208 1
a208 1
   fflush (stderr);
d210 2
a211 2
   exit (theRc);
   }
@


1.40
log
@When comparing a file name to WitSTDOUT, changed from pointer equality
to string equality.
@
text
@d74 1
a74 1
void WitNonClass::debugAssert (
d81 1
a81 1
      WitMsgFacility::issueByException ("debugAssertFmsg",
a88 7
void WitNonClass::strongAssertFailure (const char * srcFileName, int lineNo)
   {
   WitMsgFacility::issueByException ("stronglyAssertFmsg", srcFileName, lineNo);
   }

//------------------------------------------------------------------------------

d95 13
a107 2
   if (assertion)
      return;
d109 2
a110 13
   fprintf (stderr,
      "\n"
      "FATAL ERROR encountered by WIT.\n"
      "\n"
      "   Non-message assertion violation:\n"
      "      Source File: %s\n"
      "      Line #:      %d\n"
      "      Assertion:   %s\n",
      srcFileName,
      lineNo,
      assertionString);

   exitWitNonMsg (4);
@


1.39
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@d25 7
@


1.38
log
@Object name change.
@
text
@d21 2
@


1.37
log
@Stochastic Implosion
@
text
@d136 1
a136 1
bool WitNonClass::isNullString (const char * theCstring)
@


1.36
log
@Assisted opt implosion.
@
text
@d16 1
a16 1
#include <OptImp.h>
@


1.35
log
@Updated the copyright date on all source files.
@
text
@d103 1
a103 6
      "      Assertion:   %s\n"
      "\n"
      "The above message indicates that there is a programming error in WIT.\n"
      "\n"
      "WIT stops running. Return code is 4.\n"
      "\n",
d108 1
a108 3
   fflush (stderr);

   exit (4);
d172 1
a172 8
   fprintf (stderr,
      "\n"
      "WIT stops running. Return code is 3.\n"
      "\n");

   fflush (stderr);

   exit (3);
d183 17
a199 1
      "The error occurred in function %s.\n"
d201 2
a202 3
      "The above message indicates that there is a programming error in WIT.\n"
      "\n"
      "WIT stops running. Return code is 4.\n"
d204 1
a204 1
      funcName);
d208 1
a208 1
   exit (4);
@


1.34
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.33
log
@[multi-thread]
@
text
@d87 33
@


1.32
log
@[multi-thread]
@
text
@d68 1
a68 1
      int lineNo,
d72 1
a72 1
      curMsgFac () ("debugAssertFmsg",
d82 1
a82 1
   curMsgFac () ("stronglyAssertFmsg", srcFileName, lineNo);
a175 7

//------------------------------------------------------------------------------

WitMsgFacility & WitNonClass::curMsgFac ()
   {
   return WitSession::curSession ()->myMsgFac ();
   }
@


1.31
log
@[multi-thread]
@
text
@a20 2
#include <ctype.h>

@


1.30
log
@[multi-thread]
@
text
@a21 11
#include <errno.h>

#ifdef WIN32

#  include <new.h>

#else

#  include <new>

#endif
a88 21
FILE * WitNonClass::openFile (
      const WitString & fileName,
      const WitString & mode)
   {
   FILE * openedFile;

   openedFile = fopen (fileName.myCstring (), mode.myCstring ());

   if (not openedFile)
      curMsgFac () (
         "fopenSmsg",
         fileName,
         mode,
         errno,
         strerror (errno));

   return openedFile;
   }

//------------------------------------------------------------------------------

a180 22
#ifdef NO_ANSI_STRERROR

extern int  sys_nerr;
extern char *sys_errlist[];

const char * WitNonClass::strerror (int errnum)
   {
   return
      (errnum < sys_nerr)?
         sys_errlist[errnum]:
         curMsgFac ().fragText ("undocumentedErrnoFrag");
   }

#else

const char * WitNonClass::strerror (int errnum)
   {
   return ::strerror (errnum);
   }

//------------------------------------------------------------------------------

a184 2

#endif
@


1.29
log
@[multi-thread]
@
text
@a150 17
WitSimpleFuncPtr WitNonClass::set_new_handler (WitSimpleFuncPtr theHandler)
   {
#ifdef WIN32

   return
      (WitSimpleFuncPtr)
         ::_set_new_handler ((int (__cdecl *)(unsigned int))theHandler);

#else

   return std::set_new_handler (theHandler);

#endif
   }

//------------------------------------------------------------------------------

@


1.28
log
@[exceptions]
@
text
@a99 7
void WitNonClass::newError ()
   {
   curMsgFac () ("memoryErrorSmsg");
   }

//------------------------------------------------------------------------------

@


1.27
log
@Double Precision.
@
text
@d102 1
a102 1
   curMsgFac () ("memoryErrorMsg");
d117 1
a117 1
         "fopenError",
@


1.26
log
@Double Precision.
@
text
@d52 1
a52 1
int WitNonClass::sign (float val1)
d54 1
a54 1
   if (val1 > + FLOAT_EPSILON)
d57 14
a70 1
   if (val1 < - FLOAT_EPSILON)
d180 1
a180 1
         static_cast <float> (thePercent) / 100.0;
@


1.25
log
@Continued double precision.
@
text
@d19 1
d72 1
a72 1
      WitMsgFacility::current () ("debugAssertFmsg",
d82 1
a82 1
   WitMsgFacility::current () ("stronglyAssertFmsg", srcFileName, lineNo);
d89 1
a89 1
   WitMsgFacility::current () ("memoryErrorMsg");
d103 1
a103 1
      WitMsgFacility::current () (
d203 21
d234 1
a234 1
         WitMsgFacility::current ().fragText ("undocumentedErrnoFrag");
d242 7
@


1.24
log
@Continued double precision.
@
text
@d161 1
a161 1
float WitNonClass::percentToFrac (int thePercent)
d171 1
a171 1
int WitNonClass::fracToPercent (float theFrac)
@


1.23
log
@Continued implementation of PIP.
@
text
@a113 7
void WitNonClass::forbidNullWitRun (WitRun * theWitRun, const char * funcName)
   {
   forbidNullArg (theWitRun, "theWitRun", funcName);
   }

//------------------------------------------------------------------------------

@


1.22
log
@Continued implementation of PIP.
@
text
@d13 1
a13 1
// Contains the implementation of namespace Util.
a33 2
// Implementation of class Util.
//------------------------------------------------------------------------------
d35 1
a35 1
void WitUtil::net (double & val1, double & val2)
d51 1
a51 1
int WitUtil::sign (float val1)
d64 1
a64 1
void WitUtil::debugAssert (
d79 1
a79 1
void WitUtil::strongAssertFailure (const char * srcFileName, int lineNo)
d86 1
a86 1
void WitUtil::newError ()
d93 1
a93 1
FILE * WitUtil::openFile (
d114 1
a114 1
void WitUtil::forbidNullWitRun (WitRun * theWitRun, const char * funcName)
d121 1
a121 1
void WitUtil::forbidNullArg (
d144 1
a144 1
bool WitUtil::isNullString (const char * theCstring)
d151 1
a151 1
WitSimpleFuncPtr WitUtil::set_new_handler (WitSimpleFuncPtr theHandler)
d168 1
a168 1
float WitUtil::percentToFrac (int thePercent)
d178 1
a178 1
int WitUtil::fracToPercent (float theFrac)
d185 1
a185 1
void WitUtil::startNonMsgSevereError ()
d195 1
a195 1
void WitUtil::finishNonMsgSevereError ()
d214 1
a214 1
const char * WitUtil::strerror (int errnum)
d224 1
a224 1
const char * WitUtil::strerror (int errnum)
@


1.21
log
@Eliminated the "tempnam" linker warning on Linux.
@
text
@d13 1
a13 1
// Contains the implementation of class Util.
@


1.20
log
@Continued implementation of opt with COIN.
@
text
@a93 66
// The following function prototype is for a unix utility used by
// Util::tempFileName.
// This utility's prototype is in stdio on SunOS 4.1.2, and it takes const
// parameters
//------------------------------------------------------------------------------

#ifdef RS6K

// AIX4.1.3 already has tempnam defined
#ifndef _POWER
   char * tempnam (char * , char * );
#endif

#endif

//------------------------------------------------------------------------------

#if    defined (RS6K)        \
    or defined (SUN4)        \
    or defined (__OS2__)     \
    or defined (WIN32)       \
    or defined (__WINDOWS__) \
    or defined (__GNUC__)

char * WitUtil::tempFileName (char * stemName)
   {
   char * theName;

   theName = tempnam (NULL, stemName);

   if (theName == NULL)
      WitMsgFacility::current () ("tempnamError", errno, strerror (errno));

   return theName;
   }

#else
#if defined (WATCOM)

char * WitUtil::tempFileName (char * stemName)
   {
   char* tFName;
   if (tFName == NULL)
      WitMsgFacility::current () ("tempnamError", errno, strerror (errno));

   tmpnam (tFName);

   if (tFName == NULL)
      WitMsgFacility::current () ("tempnamError", errno, strerror (errno));

   return tFName;
   }

#else

char * WitUtil::tempFileName (char *)
   {
   WitMsgFacility::current () ("tempFileNamePortFmsg", __FILE__, __LINE__);

   return NULL;
   }

#endif
#endif

//------------------------------------------------------------------------------
@


1.19
log
@Minor changes.
@
text
@d120 1
a120 1
   char * tFName = tempnam (NULL, stemName);
d122 3
a124 1
   if (tFName == NULL)
d127 1
a127 1
   return tFName;
@


1.18
log
@Modified to build on windows with ms visual c++ version 6 compiler
@
text
@d22 1
d24 1
d26 1
d28 1
d30 1
@


1.17
log
@Eliminated all compiler warnings on Linux.
Made compiler treat warnings as errors on Linux.
@
text
@d22 5
a26 2

#include <new>
@


1.16
log
@Continued implementation of opt with COIN.
@
text
@a19 1
#include <new.h>
d23 2
d219 1
a219 1
   return ::set_new_handler (theHandler);
d238 1
a238 1
   return floor (theFrac * 100.0 + 0.5);
@


1.15
log
@Continued implementation of proportionate routing.
@
text
@d17 1
@


1.14
log
@Minor changes relating to the Linux port.
@
text
@d139 1
a139 1
   WitMsgFacility::current () ("tempFileNamePortSmsg", __LINE__);
@


1.13
log
@added __GNUC__ for defining tempFileName method
@
text
@d139 1
a139 1
   stronglyAssert (false);
@


1.12
log
@Changed some C style casts to C++ style.
@
text
@d105 2
a106 1
    or defined (__WINDOWS__)
@


1.11
log
@Internal changes.
@
text
@d228 1
a228 1
         ((float) thePercent) / 100.0;
@


1.10
log
@Internal changes.
@
text
@d62 1
a62 1
   if (! (assertion))
d101 5
a105 5
#if defined (RS6K)        || \
    defined (SUN4)        || \
    defined (__OS2__)     || \
    defined (WIN32)       || \
    defined (__WINDOWS__)
d156 1
a156 1
   if (! openedFile)
@


1.9
log
@Continued implementation of object iteration.
@
text
@d57 1
a57 1
      WitBoolean   assertion,
d138 1
a138 1
   stronglyAssert (witFALSE);
d199 1
a199 1
WitBoolean WitUtil::isNullString (const char * theCstring)
@


1.8
log
@Began implementation of object iteration.
@
text
@d201 1
a201 8
   return streq (theCstring, "");
   }

//------------------------------------------------------------------------------

WitBoolean WitUtil::streqn (const char * x, const char * y, int n)
   {
   return (strncmp (x, y, n) == 0);
@


1.7
log
@Continued implementation of sel-split for pen-exec.
@
text
@d17 1
d57 1
a57 1
      WitBoolean assertion,
d67 7
@


1.6
log
@Refactoring for constrained stock reallocation.
@
text
@d55 1
a55 1
void WitUtil::utilAssert (
d62 1
a62 1
      WitMsgFacility::current () ("assertFailedFmsg",
d128 1
a128 1
char * WitUtil::tempFileName (char * stemName)
d130 1
a130 1
   WitMsgFacility::current () ("internalErrorFmsg",  "WitRun::tempFileName");
@


1.5
log
@Further implementation of coarse selection splitting.
@
text
@d13 1
a13 4
// Contains the implementation of the following classes:
//
//    Util
//    FixedPer
a16 1
#include <FixedPer.h>
a283 15

//------------------------------------------------------------------------------
// Implementation of class FixedPer.
//------------------------------------------------------------------------------

WitFixedPer::WitFixedPer (WitPeriod thePer):
      myPeriod_ (thePer)
   {
   }

//------------------------------------------------------------------------------

WitFixedPer::~WitFixedPer ()
   {
   }
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d13 4
a16 1
// Contains the implementation of class Util.
d20 1
d288 15
@


1.3
log
@Replaced "PRM" with "WIT".
Replaced "Production Resource Manager" with "Watson Implosion Technology".
Upgraded release # to 6.0.
@
text
@a15 1
#include <HeurAll.h>
d23 1
a23 13

float WitUtil::positivePart (float x)
   {
   return max (0.0f, x);
   }

//------------------------------------------------------------------------------

double WitUtil::positivePart (double x)
   {
   return max (0.0, x);
   }

d26 1
a26 1
void WitUtil::net (double & x, double & y)
d28 1
a28 1
   if (x <= y)
d30 2
a31 2
      y -= x;
      x  = 0.0;
d35 2
a36 2
      x -= y;
      y  = 0.0;
d42 1
a42 1
int WitUtil::sign (float x)
d44 1
a44 1
   if (x > + FLOAT_EPSILON)
d47 1
a47 1
   if (x < - FLOAT_EPSILON)
a52 1

d77 1
a77 1
// WitUtil::tempFileName.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d257 1
a257 1
      "SEVERE ERROR encountered by PRM:\n"
d267 1
a267 1
      "PRM stops running. Return code is 3.\n"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

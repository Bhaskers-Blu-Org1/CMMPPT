head	1.67;
access;
symbols
	sce_5_01_20080919:1.62;
locks; strict;
comment	@ * @;


1.67
date	2011.09.28.23.50.31;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2011.09.24.00.28.47;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2011.08.30.20.18.17;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2010.09.10.22.10.42;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2009.12.11.22.03.13;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2008.03.01.00.01.04;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2008.02.09.00.11.58;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.08.00.08.10;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2008.02.07.21.49.36;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2008.02.07.18.41.40;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.30.21.07.16;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.29.23.51.49;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.21.21.47.17;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.18.22.40.59;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.14.19.21.15;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2008.01.12.00.20.45;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.11.21.47.41;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.09.19.35.48;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2008.01.08.20.44.22;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.08.17.20.39;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.07.23.51.50;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.05.22.13.09;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.04.00.07.15;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.03.19.41.34;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.29.21.12.32;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.29.19.18.04;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.29.16.24.43;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.29.15.35.02;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.28.23.23.49;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.28.20.34.28;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.27.22.24.43;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.22.19.58.53;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.22.19.20.37;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.22.18.53.58;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.18.23.14.45;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.15.21.50.35;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.12.23.04.58;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.02.22.23.06;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.27.19.57.41;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.26.22.52.52;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.20.18.46.17;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.19.22.39.54;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.11.18.09.18;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.10.21.01.35;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.29.16.24.23;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.28.17.38.35;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.24.21.12.38;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.17.22.32.24;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.17.21.47.43;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.14.21.20.19;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.09.22.29.08;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.07.21.22.36;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.20.22.41.38;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.20.22.10.27;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.20.19.07.53;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.19.21.45.50;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.18.22.28.42;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.18.21.53.31;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.18.19.53.32;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.18.15.36.14;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.15.22.15.26;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.14.22.08.53;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.14.21.38.31;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.14.16.09.36;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.13.23.12.32;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.12.21.56.45;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.08.22.47.02;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.67
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "StochImpMgr.C"
//
// Contains the implementation of class StochImpMgr.
//------------------------------------------------------------------------------

#include <StochImpMgr.h>
#include <StochAttMgr.h>
#include <StochAtt.h>
#include <Stage.h>
#include <StageMgr.h>
#include <ScenMgr.h>
#include <Scenario.h>
#include <ScenAttMgr.h>
#include <StochOptMgr.h>
#include <DataWrit.h>
#include <OptComp.h>
#include <Material.h>
#include <Demand.h>
#include <Operation.h>
#include <SubEntry.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class StochImpMgr.
//------------------------------------------------------------------------------

WitStochImpMgr::WitStochImpMgr (WitProblem * theProblem):

      WitProbAssoc    (theProblem),

      stageByObject_  (defStageByObject ()),
      nScenarios_     (defNScenarios ()),
      stochMode_      (defStochMode ()),
      myStochModeMgr_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitStochImpMgr::~WitStochImpMgr ()
   {
   delete myStochModeMgr_;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::copyAttrsFrom (WitStochImpMgr * theStochImpMgr)
   {
   stageByObject_ = theStochImpMgr->stageByObject_;
   nScenarios_    = theStochImpMgr->nScenarios_;

   if (stochMode_ != theStochImpMgr->stochMode_)
      setStochMode (theStochImpMgr->stochMode_);

   if (stochMode_)
      myStochModeMgr ()->copyAttrsFrom (theStochImpMgr->myStochModeMgr ());
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::writeData ()
   {
   if (not writeDataNeeded ())
      return;

   if (stochMode_)
      myStochModeMgr ()->myScenMgr  ()->writeUndiffData ();

   myMsgFac () ("stochImpPreCommentWdMsg");

   writeDataID ();

   writeDataAttrs ();

   myDataWriter ()->writeEndCommand ();

   if (stochMode_)
      {
      myStochModeMgr ()->myStageMgr ()->writeData     ();
      myStochModeMgr ()->myScenMgr  ()->writeDiffData ();
      }

   myMsgFac () ("stochImpPostCommentWdMsg");
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::skipWriteData (
      const char *   theAttName,
      WitComponent * theComp)
   {
   if (stochMode_)
      if (isScenSpec (theAttName))
         if (not myStochModeMgr ()->myScenMgr ()->isWritingData ())
            return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::displayGlobalData ()
   {
   myMsgFac () ("stochMgrDdMsg",
      stochMode_,
      stageByObject_,
      nScenarios_);

   if (stochMode_)
      myStochModeMgr ()->myScenMgr ()->displayGlobalData ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setStageByObject (bool theValue)
   {
   myProblem ()->prepSetUnpostAttr ();

   stageByObject_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setNScenarios (int theValue)
   {
   stronglyAssert (theValue >= 1);

   myProblem ()->prepSetUnpostAttr ();

   nScenarios_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setStochMode (bool theValue)
   {
   myProblem ()->prepSetStochModeAttr ("stochMode");

   if (theValue == stochMode_)
      return;

   if (theValue)
      {
      stronglyAssert (not myOptComp ()->multiObjMode ());

      myStochModeMgr_ = new WitStochModeMgr (myProblem ());

      myStochModeMgr ()->clearCompSoln ();
      }
   else
      {
      delete myStochModeMgr_;

      myStochModeMgr_ = NULL;
      }

   stochMode_ = theValue;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::prepSetStochModeAttr (const char * theAttName)
   {
   myStochModeMgr ()->myStochAttMgr ()->prepSetStochModeAttr (theAttName);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::prepSetScenSpecAttr (
      const char * theAttName,
      WitDelComp * theDelComp)
   {
   myStochModeMgr ()->
      myStochAttMgr ()->
         prepSetScenSpecAttr (theAttName, theDelComp);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::prepSetBoundSet (WitBoundSet * theBoundSet)
   {
   myStochModeMgr ()->myStochAttMgr ()->prepSetBoundSet (theBoundSet);
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::isScenSpec (const char * theAttName)
   {
   return
      myStochModeMgr ()->
         myStochAttMgr ()->
            valueOf (& WitStochAtt::isScenSpec, theAttName);
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::canSetInStochMode (const char * theAttName)
   {
   return
      myStochModeMgr ()->
         myStochAttMgr ()->
            valueOf (& WitStochAtt::canSetInStochMode, theAttName);
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::canSetInStochSolnMode (const char * theAttName)
   {
   return
      myStochModeMgr ()->
         myStochAttMgr ()->
            valueOf (& WitStochAtt::canSetInSolnMode, theAttName);
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::uploadingData ()
   {
   return myStochModeMgr ()->uploadingData ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::displayDataStochMode ()
   {
   myStochModeMgr ()->myScenMgr  ()->displayData ();
   myStochModeMgr ()->myStageMgr ()->displayData ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::implode ()
   {
   myStochModeMgr ()->implode ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::clearSoln ()
   {
   myStochModeMgr ()->clearSoln ();
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setCurrentScenario (int theIdx)
   {
   WitScenario * theScenario;

   myProblem ()->prepSetStochModeAttr ("currentScenario");

   theScenario = myStochModeMgr ()->myScenMgr ()->myScenarioFor (theIdx);

   myStochModeMgr ()->myScenMgr ()->setCurScenario (theScenario);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setProbability (double theValue)
   {
   myStochModeMgr ()->myScenMgr ()->curScenario ()->setProbability (theValue);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setObjectStageIdx (WitNode * theNode, int theStageIdx)
   {
   myStochModeMgr ()->myStageMgr ()->setObjectStageIdx (theNode, theStageIdx);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setPeriodStageIdx (WitPeriod thePer, int theStageIdx)
   {
   myStochModeMgr ()->myStageMgr ()->setPeriodStageIdx (thePer, theStageIdx);
   }

//------------------------------------------------------------------------------

int WitStochImpMgr::currentScenario ()
   {
   return myStochModeMgr ()->myScenMgr ()->curScenario ()->myIndex ();
   }

//------------------------------------------------------------------------------

double WitStochImpMgr::probability ()
   {
   return myStochModeMgr ()->myScenMgr ()->curScenario ()->probability ();
   }

//------------------------------------------------------------------------------

int WitStochImpMgr::objectStageIdx (WitNode * theNode)
   {
   return myStochModeMgr ()->myStageMgr ()->objectStage (theNode)->myIndex ();
   }

//------------------------------------------------------------------------------

int WitStochImpMgr::periodStageIdx (WitPeriod thePer)
   {
   return myStochModeMgr ()->myStageMgr ()->periodStage (thePer)->myIndex ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::stochSolnMode ()
   {
   return myStochModeMgr ()->stochSolnMode ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::clearingSoln ()
   {
   return myStochModeMgr ()->clearingSoln ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::writeDataNeeded ()
   {
   if (stageByObject_ != defStageByObject ())
      return true;

   if (nScenarios_ != defNScenarios ())
      return true;

   if (stochMode_)
      return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::writeDataAttrs ()
   {
   myDataWriter ()->writeBool (
        "stageByObject",
         stageByObject_,
      defStageByObject ());

   myDataWriter ()->writeInt (
        "nScenarios",
         nScenarios_,
      defNScenarios ());

   myDataWriter ()->writeBool (
        "stochMode",
         stochMode_,
      defStochMode ());
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::setSolnAttr (
            WitDblFlexVec &    theAttr,
      const WitTVec <double> & theTVec)
   {
   if (theTVec.isAllocated ())
      theAttr = theTVec;
   else
      theAttr = 0.0;
   }
@


1.66
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.65
log
@Revised the copyright date.
@
text
@d6 2
a7 2
//     IBM Confidential
//
d39 1
a39 1
WitProbAssoc    (theProblem),
d41 6
a46 6
stageByObject_  (defStageByObject ()),
nScenarios_     (defNScenarios ()),
stochMode_      (defStochMode ()),
myStochModeMgr_ (NULL)
{
}
d51 3
a53 3
{
delete myStochModeMgr_;
}
d58 10
a67 10
{
stageByObject_ = theStochImpMgr->stageByObject_;
nScenarios_    = theStochImpMgr->nScenarios_;

if (stochMode_ != theStochImpMgr->stochMode_)
setStochMode (theStochImpMgr->stochMode_);

if (stochMode_)
myStochModeMgr ()->copyAttrsFrom (theStochImpMgr->myStochModeMgr ());
}
d72 3
a74 3
{
if (not writeDataNeeded ())
return;
d76 2
a77 2
if (stochMode_)
myStochModeMgr ()->myScenMgr  ()->writeUndiffData ();
d79 1
a79 1
myMsgFac () ("stochImpPreCommentWdMsg");
d81 1
a81 1
writeDataID ();
d83 1
a83 1
writeDataAttrs ();
d85 1
a85 1
myDataWriter ()->writeEndCommand ();
d87 5
a91 5
if (stochMode_)
{
myStochModeMgr ()->myStageMgr ()->writeData     ();
myStochModeMgr ()->myScenMgr  ()->writeDiffData ();
}
d93 2
a94 2
myMsgFac () ("stochImpPostCommentWdMsg");
}
d99 7
a105 7
const char *   theAttName,
WitComponent * theComp)
{
if (stochMode_)
if (isScenSpec (theAttName))
if (not myStochModeMgr ()->myScenMgr ()->isWritingData ())
return true;
d107 2
a108 2
return false;
}
d113 9
a121 9
{
myMsgFac () ("stochMgrDdMsg",
stochMode_,
stageByObject_,
nScenarios_);

if (stochMode_)
myStochModeMgr ()->myScenMgr ()->displayGlobalData ();
}
d126 2
a127 2
{
myProblem ()->prepSetUnpostAttr ();
d129 2
a130 2
stageByObject_ = theValue;
}
d135 2
a136 2
{
stronglyAssert (theValue >= 1);
d138 1
a138 1
myProblem ()->prepSetUnpostAttr ();
d140 2
a141 2
nScenarios_ = theValue;
}
d146 2
a147 2
{
myProblem ()->prepSetStochModeAttr ("stochMode");
d149 2
a150 2
if (theValue == stochMode_)
return;
d152 3
a154 3
if (theValue)
{
stronglyAssert (not myOptComp ()->multiObjMode ());
d156 1
a156 1
myStochModeMgr_ = new WitStochModeMgr (myProblem ());
d158 5
a162 5
myStochModeMgr ()->clearCompSoln ();
}
else
{
delete myStochModeMgr_;
d164 2
a165 2
myStochModeMgr_ = NULL;
}
d167 2
a168 2
stochMode_ = theValue;
}
d173 3
a175 3
{
myStochModeMgr ()->myStochAttMgr ()->prepSetStochModeAttr (theAttName);
}
d180 7
a186 7
const char * theAttName,
WitDelComp * theDelComp)
{
myStochModeMgr ()->
myStochAttMgr ()->
prepSetScenSpecAttr (theAttName, theDelComp);
}
d191 3
a193 3
{
myStochModeMgr ()->myStochAttMgr ()->prepSetBoundSet (theBoundSet);
}
d198 6
a203 6
{
return
myStochModeMgr ()->
myStochAttMgr ()->
valueOf (& WitStochAtt::isScenSpec, theAttName);
}
d208 6
a213 6
{
return
myStochModeMgr ()->
myStochAttMgr ()->
valueOf (& WitStochAtt::canSetInStochMode, theAttName);
}
d218 6
a223 6
{
return
myStochModeMgr ()->
myStochAttMgr ()->
valueOf (& WitStochAtt::canSetInSolnMode, theAttName);
}
d228 3
a230 3
{
return myStochModeMgr ()->uploadingData ();
}
d235 4
a238 4
{
myStochModeMgr ()->myScenMgr  ()->displayData ();
myStochModeMgr ()->myStageMgr ()->displayData ();
}
d243 3
a245 3
{
myStochModeMgr ()->implode ();
}
d250 3
a252 3
{
myStochModeMgr ()->clearSoln ();
}
d257 2
a258 2
{
WitScenario * theScenario;
d260 1
a260 1
myProblem ()->prepSetStochModeAttr ("currentScenario");
d262 1
a262 1
theScenario = myStochModeMgr ()->myScenMgr ()->myScenarioFor (theIdx);
d264 2
a265 2
myStochModeMgr ()->myScenMgr ()->setCurScenario (theScenario);
}
d270 3
a272 3
{
myStochModeMgr ()->myScenMgr ()->curScenario ()->setProbability (theValue);
}
d277 3
a279 3
{
myStochModeMgr ()->myStageMgr ()->setObjectStageIdx (theNode, theStageIdx);
}
d284 3
a286 3
{
myStochModeMgr ()->myStageMgr ()->setPeriodStageIdx (thePer, theStageIdx);
}
d291 3
a293 3
{
return myStochModeMgr ()->myScenMgr ()->curScenario ()->myIndex ();
}
d298 3
a300 3
{
return myStochModeMgr ()->myScenMgr ()->curScenario ()->probability ();
}
d305 3
a307 3
{
return myStochModeMgr ()->myStageMgr ()->objectStage (theNode)->myIndex ();
}
d312 3
a314 3
{
return myStochModeMgr ()->myStageMgr ()->periodStage (thePer)->myIndex ();
}
d319 3
a321 3
{
return myStochModeMgr ()->stochSolnMode ();
}
d326 3
a328 3
{
return myStochModeMgr ()->clearingSoln ();
}
d333 3
a335 3
{
if (stageByObject_ != defStageByObject ())
return true;
d337 2
a338 2
if (nScenarios_ != defNScenarios ())
return true;
d340 2
a341 2
if (stochMode_)
return true;
d343 2
a344 2
return false;
}
d349 4
a352 4
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("problem");
}
d357 16
a372 16
{
myDataWriter ()->writeBool (
"stageByObject",
stageByObject_,
defStageByObject ());

myDataWriter ()->writeInt (
"nScenarios",
nScenarios_,
defNScenarios ());

myDataWriter ()->writeBool (
"stochMode",
stochMode_,
defStochMode ());
}
d377 8
a384 8
WitDblFlexVec &    theAttr,
const WitTVec <double> & theTVec)
{
if (theTVec.isAllocated ())
theAttr = theTVec;
else
theAttr = 0.0;
}
@


1.64
log
@Heuristic Adjustment
@
text
@d6 2
a7 2
//     IBM Confidential 
// 
d39 1
a39 1
      WitProbAssoc    (theProblem),
d41 6
a46 6
      stageByObject_  (defStageByObject ()),
      nScenarios_     (defNScenarios ()),
      stochMode_      (defStochMode ()),
      myStochModeMgr_ (NULL)
   {
   }
d51 3
a53 3
   {
   delete myStochModeMgr_;
   }
d58 10
a67 10
   {
   stageByObject_ = theStochImpMgr->stageByObject_;
   nScenarios_    = theStochImpMgr->nScenarios_;

   if (stochMode_ != theStochImpMgr->stochMode_)
      setStochMode (theStochImpMgr->stochMode_);

   if (stochMode_)
      myStochModeMgr ()->copyAttrsFrom (theStochImpMgr->myStochModeMgr ());
   }
d72 3
a74 3
   {
   if (not writeDataNeeded ())
      return;
d76 2
a77 2
   if (stochMode_)
      myStochModeMgr ()->myScenMgr  ()->writeUndiffData ();
d79 1
a79 1
   myMsgFac () ("stochImpPreCommentWdMsg");
d81 1
a81 1
   writeDataID ();
d83 1
a83 1
   writeDataAttrs ();
d85 1
a85 1
   myDataWriter ()->writeEndCommand ();
d87 5
a91 5
   if (stochMode_)
      {
      myStochModeMgr ()->myStageMgr ()->writeData     ();
      myStochModeMgr ()->myScenMgr  ()->writeDiffData ();
      }
d93 2
a94 2
   myMsgFac () ("stochImpPostCommentWdMsg");
   }
d99 7
a105 7
      const char *   theAttName,
      WitComponent * theComp)
   {
   if (stochMode_)
      if (isScenSpec (theAttName))
         if (not myStochModeMgr ()->myScenMgr ()->isWritingData ())
            return true;
d107 2
a108 2
   return false;
   }
d113 9
a121 9
   {
   myMsgFac () ("stochMgrDdMsg",
      stochMode_,
      stageByObject_,
      nScenarios_);

   if (stochMode_)
      myStochModeMgr ()->myScenMgr ()->displayGlobalData ();
   }
d126 2
a127 2
   {
   myProblem ()->prepSetUnpostAttr ();
d129 2
a130 2
   stageByObject_ = theValue;
   }
d135 2
a136 2
   {
   stronglyAssert (theValue >= 1);
d138 1
a138 1
   myProblem ()->prepSetUnpostAttr ();
d140 2
a141 2
   nScenarios_ = theValue;
   }
d146 2
a147 2
   {
   myProblem ()->prepSetStochModeAttr ("stochMode");
d149 2
a150 2
   if (theValue == stochMode_)
      return;
d152 3
a154 3
   if (theValue)
      {
      stronglyAssert (not myOptComp ()->multiObjMode ());
d156 1
a156 1
      myStochModeMgr_ = new WitStochModeMgr (myProblem ());
d158 5
a162 5
      myStochModeMgr ()->clearCompSoln ();
      }
   else
      {
      delete myStochModeMgr_;
d164 2
a165 2
      myStochModeMgr_ = NULL;
      }
d167 2
a168 2
   stochMode_ = theValue;
   }
d173 3
a175 3
   {
   myStochModeMgr ()->myStochAttMgr ()->prepSetStochModeAttr (theAttName);
   }
d180 7
a186 7
      const char * theAttName,
      WitDelComp * theDelComp)
   {
   myStochModeMgr ()->
      myStochAttMgr ()->
         prepSetScenSpecAttr (theAttName, theDelComp);
   }
d191 3
a193 3
   {
   myStochModeMgr ()->myStochAttMgr ()->prepSetBoundSet (theBoundSet);
   }
d198 6
a203 6
   {
   return
      myStochModeMgr ()->
         myStochAttMgr ()->
            valueOf (& WitStochAtt::isScenSpec, theAttName);
   }
d208 6
a213 6
   {
   return
      myStochModeMgr ()->
         myStochAttMgr ()->
            valueOf (& WitStochAtt::canSetInStochMode, theAttName);
   }
d218 6
a223 6
   {
   return
      myStochModeMgr ()->
         myStochAttMgr ()->
            valueOf (& WitStochAtt::canSetInSolnMode, theAttName);
   }
d228 3
a230 3
   {
   return myStochModeMgr ()->uploadingData ();
   }
d235 4
a238 4
   {
   myStochModeMgr ()->myScenMgr  ()->displayData ();
   myStochModeMgr ()->myStageMgr ()->displayData ();
   }
d243 3
a245 3
   {
   myStochModeMgr ()->implode ();
   }
d250 3
a252 3
   {
   myStochModeMgr ()->clearSoln ();
   }
d257 2
a258 2
   {
   WitScenario * theScenario;
d260 1
a260 1
   myProblem ()->prepSetStochModeAttr ("currentScenario");
d262 1
a262 1
   theScenario = myStochModeMgr ()->myScenMgr ()->myScenarioFor (theIdx);
d264 2
a265 2
   myStochModeMgr ()->myScenMgr ()->setCurScenario (theScenario);
   }
d270 3
a272 3
   {
   myStochModeMgr ()->myScenMgr ()->curScenario ()->setProbability (theValue);
   }
d277 3
a279 3
   {
   myStochModeMgr ()->myStageMgr ()->setObjectStageIdx (theNode, theStageIdx);
   }
d284 3
a286 3
   {
   myStochModeMgr ()->myStageMgr ()->setPeriodStageIdx (thePer, theStageIdx);
   }
d291 3
a293 3
   {
   return myStochModeMgr ()->myScenMgr ()->curScenario ()->myIndex ();
   }
d298 3
a300 3
   {
   return myStochModeMgr ()->myScenMgr ()->curScenario ()->probability ();
   }
d305 3
a307 3
   {
   return myStochModeMgr ()->myStageMgr ()->objectStage (theNode)->myIndex ();
   }
d312 3
a314 3
   {
   return myStochModeMgr ()->myStageMgr ()->periodStage (thePer)->myIndex ();
   }
d319 3
a321 3
   {
   return myStochModeMgr ()->stochSolnMode ();
   }
d326 3
a328 3
   {
   return myStochModeMgr ()->clearingSoln ();
   }
d333 3
a335 3
   {
   if (stageByObject_ != defStageByObject ())
      return true;
d337 2
a338 2
   if (nScenarios_ != defNScenarios ())
      return true;
d340 2
a341 2
   if (stochMode_)
      return true;
d343 2
a344 2
   return false;
   }
d349 4
a352 4
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
   }
d357 16
a372 16
   {
   myDataWriter ()->writeBool (
        "stageByObject",
         stageByObject_,
      defStageByObject ());

   myDataWriter ()->writeInt (
        "nScenarios",
         nScenarios_,
      defNScenarios ());

   myDataWriter ()->writeBool (
        "stochMode",
         stochMode_,
      defStochMode ());
   }
d377 8
a384 8
            WitDblFlexVec &    theAttr,
      const WitTVec <double> & theTVec)
   {
   if (theTVec.isAllocated ())
      theAttr = theTVec;
   else
      theAttr = 0.0;
   }
@


1.63
log
@*** empty log message ***
@
text
@d29 1
a29 1
#include <Opn.h>
@


1.62
log
@Stochastic Implosion
@
text
@d26 1
d154 2
@


1.61
log
@Stochastic Implosion
@
text
@d38 1
a38 1
      WitProbAssoc     (theProblem),
d40 4
a43 5
      allowStageByPer_ (false),
      stageByObject_   (defStageByObject ()),
      nScenarios_      (defNScenarios ()),
      stochMode_       (defStochMode ()),
      myStochModeMgr_  (NULL)
d58 2
a59 3
   allowStageByPer_  = theStochImpMgr->allowStageByPer_;
   stageByObject_    = theStochImpMgr->stageByObject_;
   nScenarios_       = theStochImpMgr->nScenarios_;
a123 7
void WitStochImpMgr::setAllowStageByPer (bool theValue)
   {
   allowStageByPer_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.60
log
@Stochastic Implosion
@
text
@d282 1
a282 1
void WitStochImpMgr::setObjectStageIdx (WitNode * theNode, int theValue)
d284 1
a284 5
   WitStage * theStage;

   theStage = myStochModeMgr ()->myStageMgr ()->myStageFor (theValue);

   myStochModeMgr ()->myStageMgr ()->setObjectStage (theNode, theStage);
d289 1
a289 1
void WitStochImpMgr::setPeriodStageIdx (const int * theValue)
d291 1
a291 10
   WitPeriod  thePer;
   WitStage * theStage;

   forEachPeriod (thePer, myProblem ())
      {
      theStage =
         myStochModeMgr ()->myStageMgr ()->myStageFor (theValue[thePer]);

      myStochModeMgr ()->myStageMgr ()->setPeriodStage (thePer, theStage);
      }
@


1.59
log
@Stochastic Implosion
@
text
@d295 2
a296 2
   WitPtrTVec <WitStage> theStageVec (myProblem ());
   WitPeriod             thePer;
d299 2
a300 1
      theStageVec[thePer] =
d303 2
a304 1
   myStochModeMgr ()->myStageMgr ()->setPeriodStage (theStageVec);
@


1.58
log
@Stochastic Implosion
@
text
@a125 7
int WitStochImpMgr::defPeriodStageIdx ()
   {
   return WitStageMgr::defPeriodStageIdx ();
   }

//------------------------------------------------------------------------------

@


1.57
log
@Stochastic Implosion
@
text
@d19 1
d126 1
a126 1
int WitStochImpMgr::defPeriodStage ()
d128 1
a128 1
   return WitStageMgr::defPeriodStage ();
d289 1
a289 1
void WitStochImpMgr::setObjectStage (WitNode * theNode, int theValue)
d291 5
a295 1
   myStochModeMgr ()->myStageMgr ()->setObjectStage (theNode, theValue);
d300 1
a300 1
void WitStochImpMgr::setPeriodStage (const int * theValue)
d302 8
a309 1
   myStochModeMgr ()->myStageMgr ()->setPeriodStage (theValue);
d328 1
a328 1
int WitStochImpMgr::objectStage (WitNode * theNode)
d330 1
a330 1
   return myStochModeMgr ()->myStageMgr ()->objectStage (theNode);
d335 1
a335 1
int WitStochImpMgr::periodStage (WitPeriod thePer)
d337 1
a337 1
   return myStochModeMgr ()->myStageMgr ()->periodStage (thePer);
@


1.56
log
@Stochastic Implosion
@
text
@d323 1
a323 1
const WitTVec <int> & WitStochImpMgr::periodStage ()
d325 1
a325 1
   return myStochModeMgr ()->myStageMgr ()->periodStage ();
@


1.55
log
@Stochastic Implosion
@
text
@a16 1
#include <StochModeMgr.h>
d19 1
a19 2
#include <ObjStageMgr.h>
#include <PerStageMgr.h>
d127 1
a127 1
   return WitPerStageMgr::defPeriodStage ();
d290 1
a290 1
   myStochModeMgr ()->myObjStageMgr ()->setObjectStage (theNode, theValue);
d297 1
a297 1
   myStochModeMgr ()->myPerStageMgr ()->setPeriodStage (theValue);
d318 1
a318 1
   return myStochModeMgr ()->myObjStageMgr ()->objectStage (theNode);
d325 1
a325 1
   return myStochModeMgr ()->myPerStageMgr ()->periodStage ();
@


1.54
log
@Stochastic Implosion
@
text
@d270 1
a270 1
void WitStochImpMgr::setCurScenarioIndex (int theIdx)
d274 1
a274 1
   myProblem ()->prepSetStochModeAttr ("curScenarioIndex");
d304 1
a304 1
int WitStochImpMgr::curScenarioIndex ()
a389 7
WitScenario * WitStochImpMgr::curScenario ()
   {
   return myStochModeMgr ()->myScenMgr ()->curScenario ();
   }

//------------------------------------------------------------------------------

@


1.53
log
@Stochastic Implosion
@
text
@d127 1
a127 1
int WitStochImpMgr::defPerStageIndex ()
d129 1
a129 1
   return WitPerStageMgr::defPerStageIndex ();
d290 1
a290 1
void WitStochImpMgr::setStageIndex (WitNode * theNode, int theValue)
d292 1
a292 1
   myStochModeMgr ()->myObjStageMgr ()->setStageIndex (theNode, theValue);
d297 1
a297 1
void WitStochImpMgr::setPerStageIndex (const int * theValue)
d299 1
a299 1
   myStochModeMgr ()->myPerStageMgr ()->setPerStageIndex (theValue);
d318 1
a318 1
int WitStochImpMgr::stageIndex (WitNode * theNode)
d320 1
a320 1
   return myStochModeMgr ()->myObjStageMgr ()->stageIndex (theNode);
d325 1
a325 1
const WitTVec <int> & WitStochImpMgr::perStageIndex ()
d327 1
a327 1
   return myStochModeMgr ()->myPerStageMgr ()->perStageIndex ();
@


1.52
log
@Stochastic Implosion
@
text
@d127 7
d297 1
a297 1
void WitStochImpMgr::setStageIndex (const int * theValue)
d299 1
a299 1
   myStochModeMgr ()->myPerStageMgr ()->setStageIndex (theValue);
d325 1
a325 1
const WitTVec <int> & WitStochImpMgr::stageIndex ()
d327 1
a327 1
   return myStochModeMgr ()->myPerStageMgr ()->stageIndex ();
@


1.51
log
@Stochastic Implosion
@
text
@d60 3
a62 2
   stageByObject_ = theStochImpMgr->stageByObject_;
   nScenarios_    = theStochImpMgr->nScenarios_;
@


1.50
log
@Stochastic Implosion
@
text
@d21 1
d289 7
d317 7
@


1.49
log
@Stochastic Implosion
@
text
@d89 2
a90 2
      myStochModeMgr ()->myObjStageMgr ()->writeData     ();
      myStochModeMgr ()->myScenMgr     ()->writeDiffData ();
d241 2
a242 2
   myStochModeMgr ()->myScenMgr     ()->displayData ();
   myStochModeMgr ()->myObjStageMgr ()->displayData ();
@


1.48
log
@Stochastic Implosion
@
text
@d20 1
a20 1
#include <StageMgr.h>
d89 2
a90 2
      myStochModeMgr ()->myStageMgr ()->writeData     ();
      myStochModeMgr ()->myScenMgr  ()->writeDiffData ();
d241 2
a242 2
   myStochModeMgr ()->myScenMgr  ()->displayData ();
   myStochModeMgr ()->myStageMgr ()->displayData ();
d283 1
a283 1
   myStochModeMgr ()->myStageMgr ()->setStageIndex (theNode, theValue);
d304 1
a304 1
   return myStochModeMgr ()->myStageMgr ()->stageIndex (theNode);
@


1.47
log
@Stochastic Implosion
@
text
@d38 1
a38 1
      WitProbAssoc    (theProblem),
d40 5
a44 4
      stageByObject_  (defStageByObject ()),
      nScenarios_     (defNScenarios ()),
      stochMode_      (defStochMode ()),
      myStochModeMgr_ (NULL)
d125 7
@


1.46
log
@Stochastic Implosion
@
text
@a300 14
int WitStochImpMgr::stageIndex (WitDemand * theDemand)
   {
   return myStochModeMgr ()->myStageMgr ()->stageIndex (theDemand);
   }

//------------------------------------------------------------------------------

int WitStochImpMgr::stageIndex (WitBillEntry * theBillEnt)
   {
   return myStochModeMgr ()->myStageMgr ()->stageIndex (theBillEnt);
   }

//------------------------------------------------------------------------------

@


1.45
log
@Stochastic Implosion
@
text
@d176 18
@


1.44
log
@Stochastic Implosion
@
text
@d76 1
a76 1
      myStochModeMgr ()->myScenMgr  ()->writeStage0Data ();
d88 2
a89 2
      myStochModeMgr ()->myStageMgr ()->writeData       ();
      myStochModeMgr ()->myScenMgr  ()->writeStage1Data ();
@


1.43
log
@Stochastic Implosion
@
text
@a55 15
void WitStochImpMgr::prepSetStochModeAttr (const char * theAttName)
   {
   if (stochMode ())
      {
      stronglyAssert (canSetInStochMode (theAttName));

      if (stochSolnMode ())
         stronglyAssert (canSetInStochSolnMode (theAttName));
      }

   myProblem ()->resetSoln ();
   }

//------------------------------------------------------------------------------

d146 1
a146 1
   prepSetStochModeAttr ("stochMode");
d169 7
d239 1
a239 1
   prepSetStochModeAttr ("curScenarioIndex");
@


1.42
log
@Stochastic Implosion
@
text
@d56 15
d161 1
a161 1
   myProblem ()->prepSetStochModeAttr ("stochMode");
d247 1
a247 1
   myProblem ()->prepSetStochModeAttr ("curScenarioIndex");
@


1.41
log
@Stochastic Implosion
@
text
@d101 4
a104 1
   const WitStochAtt * theStochAtt;
d106 1
a106 18
   if (not stochMode_)
      return false;

   if (myStochModeMgr ()->myScenMgr ()->isWritingData ())
      return false;

   theStochAtt =
      myStochModeMgr ()->
         myStochAttMgr ()->
            findStochAtt (theAttName);

   if (theStochAtt == NULL)
      return false;

   if (not theStochAtt->isScenSpec ())
      return false;

   return true;
d169 1
a169 1
bool WitStochImpMgr::canSetInStochMode (const char * theAttName)
d171 5
a175 1
   const WitStochAtt * theStochAtt;
d177 1
a177 1
   theStochAtt = myStochModeMgr ()->myStochAttMgr ()->findStochAtt (theAttName);
d179 6
a184 4
   if (theStochAtt == NULL)
      return false;
   else
      return theStochAtt->canSetInStochMode ();
d191 4
a194 8
   const WitStochAtt * theStochAtt;

   theStochAtt = myStochModeMgr ()->myStochAttMgr ()->findStochAtt (theAttName);

   if (theStochAtt == NULL)
      return false;
   else
      return theStochAtt->canSetInSolnMode ();
@


1.40
log
@Stochastic Implosion
@
text
@a217 7
int WitStochImpMgr::stageIndex (WitDelComp * theDelComp)
   {
   return myStochModeMgr ()->myStageMgr ()->stageIndex (theDelComp);
   }

//------------------------------------------------------------------------------

d288 14
@


1.39
log
@Stochastic Implosion
@
text
@a23 1
#include <StBSMgr.h>
@


1.38
log
@Stochastic Implosion
@
text
@d219 1
a219 1
int WitStochImpMgr::stageIndex (WitBoundSet * theBoundSet)
d221 1
a221 1
   return myStochModeMgr ()->myStBSMgr ()->stageIndex (theBoundSet);
@


1.37
log
@Stochastic Implosion
@
text
@d23 1
d76 3
d89 2
a90 2
      myStochModeMgr ()->myStageMgr ()->writeData ();
      myStochModeMgr ()->myScenMgr  ()->writeData ();
d121 1
a121 1
   return (theComp->stageIndex () == 1);
@


1.36
log
@Stochastic Implosion
@
text
@d23 1
d100 16
a115 13
   if (stochMode_)
      if (not myStochModeMgr ()->myScenMgr ()->isWritingData ())
         {
         theStochAtt =
            myStochModeMgr ()->
               myStochAttMgr ()->
                  findStochAtt (theAttName);

         if (theStochAtt != NULL)
            if (theStochAtt->isScenSpec ())
               if (theComp->stageIndex () == 1)
                  return true;
         }
d117 1
a117 1
   return false;
d215 7
@


1.35
log
@Stochastic Implosion
@
text
@d109 1
a109 1
               if (theComp->stageNo () == 1)
d253 1
a253 1
void WitStochImpMgr::setStageNo (WitNode * theNode, int theValue)
d255 1
a255 1
   myStochModeMgr ()->myStageMgr ()->setStageNo (theNode, theValue);
d274 1
a274 1
int WitStochImpMgr::stageNo (WitNode * theNode)
d276 1
a276 1
   return myStochModeMgr ()->myStageMgr ()->stageNo (theNode);
@


1.34
log
@Stochastic Implosion
@
text
@d233 1
a233 1
void WitStochImpMgr::setCurScenarioNo (int theIdx)
d237 1
a237 1
   myProblem ()->prepSetStochModeAttr ("curScenarioNo");
d260 1
a260 1
int WitStochImpMgr::curScenarioNo ()
@


1.33
log
@Stochastic Implosion
@
text
@d226 1
a226 1
void WitStochImpMgr::discardSoln ()
d228 1
a228 1
   myStochModeMgr ()->discardSoln ();
@


1.32
log
@Stochastic Implosion
@
text
@d93 3
a95 1
bool WitStochImpMgr::skipWriteData (const char * theAttName)
d109 2
a110 1
               return true;
@


1.31
log
@Stochastic Implosion
@
text
@d159 1
a159 2
      myStochModeMgr ()->uploadSoln    ();
      myStochModeMgr ()->uploadZeroObj ();
d285 7
@


1.30
log
@Stochastic Implosion
@
text
@d95 2
d99 10
a108 2
         if (isaScenSpecAtt (theAttName))
            return true;
a173 14
bool WitStochImpMgr::isaScenSpecAtt (const char * theAttName)
   {
   const WitStochAtt * theStochAtt;

   theStochAtt = myStochModeMgr ()->myStochAttMgr ()->findStochAtt (theAttName);

   if (theStochAtt == NULL)
      return false;
   else
      return theStochAtt->isScenSpec ();
   }

//------------------------------------------------------------------------------

@


1.29
log
@Stochastic Implosion
@
text
@d37 1
a37 1
      WitProbAssoc     (theProblem),
d39 4
a42 5
      stochImpAllowed_ (false),
      stageByObject_   (defStageByObject ()),
      nScenarios_      (defNScenarios ()),
      stochMode_       (defStochMode ()),
      myStochModeMgr_  (NULL)
d57 2
a58 3
   stochImpAllowed_ = theStochImpMgr->stochImpAllowed_;
   stageByObject_   = theStochImpMgr->stageByObject_;
   nScenarios_      = theStochImpMgr->nScenarios_;
a117 7
void WitStochImpMgr::setStochImpAllowed (bool theValue)
   {
   stochImpAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

a119 2
   stronglyAssert (stochImpAllowed_);

a128 2
   stronglyAssert (stochImpAllowed_);

a139 2
   stronglyAssert (stochImpAllowed_);

@


1.28
log
@Stochastic Implosion
@
text
@d99 1
a99 1
         if (isScenSpecAtt (theAttName))
d179 1
a179 1
bool WitStochImpMgr::isScenSpecAtt (const char * theAttName)
d185 4
a188 5
   if (theStochAtt != NULL)
      if (theStochAtt->scenSpec ())
         return true;

   return false;
d199 4
a202 5
   if (theStochAtt != NULL)
      if (theStochAtt->canSetInStochMode ())
         return true;

   return false;
d213 4
a216 5
   if (theStochAtt != NULL)
      if (theStochAtt->canSetInSolnMode ())
         return true;

   return false;
@


1.27
log
@Stochastic Implosion
@
text
@d98 1
a98 1
      if (not myStochModeMgr ()->isWritingComp ())
a106 8
void WitStochImpMgr::prepWriteVector ()
   {
   if (stochMode_)
      myStochModeMgr ()->prepWriteVector ();
   }

//------------------------------------------------------------------------------

@


1.26
log
@Stochastic Implosion
@
text
@d172 2
a173 1
      myStochModeMgr ()->uploadZeroSoln ();
@


1.25
log
@Stochastic Implosion
@
text
@d172 1
a172 1
      myStochModeMgr ()->clearSoln ();
@


1.24
log
@Stochastic Implosion
@
text
@a259 101
void WitStochImpMgr::exportSoln (
      WitOptComp *,
      double &    objValueRef,
      double & boundsValueRef)
   {
   if (clearingSoln ())
      {
         objValueRef = 0.0;
      boundsValueRef = 0.0;
      }
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitPart *       thePart,
      WitDblFlexVec & scrapVolRef)
   {
   if (exportingSoln ())
      setSolnAttr (scrapVolRef, curScenario ()->scrapVol () (thePart));

   else if (clearingSoln ())
      scrapVolRef = 0.0;

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitMaterial *   theMat,
      WitDblFlexVec & stockVolRef)
   {
   if (exportingSoln ())
      setSolnAttr (stockVolRef, curScenario ()->stockVol () (theMat));

   else if (clearingSoln ())
      stockVolRef = 0.0;

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitDemand *     theDemand,
      WitDblFlexVec &    shipVolRef,
      WitDblFlexVec & cumShipVolRef)
   {
   if (exportingSoln ())
      {
      setSolnAttr (shipVolRef,    curScenario ()->shipVol    () (theDemand));
      setSolnAttr (cumShipVolRef, curScenario ()->cumShipVol () (theDemand));
      }

   else if (clearingSoln ())
      {
      shipVolRef    = 0.0;
      cumShipVolRef = 0.0;
      }

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitOperation *  theOpn,
      WitDblFlexVec & execVolRef)
   {
   if (exportingSoln ())
      setSolnAttr (execVolRef, curScenario ()->execVol () (theOpn));

   else if (clearingSoln ())
      execVolRef = 0.0;

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportSoln (
      WitSubEntry *   theSub,
      WitDblFlexVec & subVolRef)
   {
   if (exportingSoln ())
      setSolnAttr (subVolRef, curScenario ()->subVol () (theSub));

   else if (clearingSoln ())
      subVolRef = 0.0;

   else
      stronglyAssert (false);
   }

//------------------------------------------------------------------------------

a314 10
bool WitStochImpMgr::uploadingSoln ()
   {
   return
      myStochModeMgr ()->imploding ()?
         myStochModeMgr ()->myStochOptMgr ()->uploadingSoln ():
         false;
   }

//------------------------------------------------------------------------------

a365 14
bool WitStochImpMgr::exportingSoln ()
   {
   return myStochModeMgr ()->exportingSoln ();
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::clearingSoln ()
   {
   return myStochModeMgr ()->clearingSoln ();
   }

//------------------------------------------------------------------------------

@


1.23
log
@Stochastic Implosion
@
text
@d231 7
a259 24
void WitStochImpMgr::exportInput (
      WitPart *       thePart,
      WitDblFlexVec & supplyVolRef)
   {
   stronglyAssert (exportingInput ());

   supplyVolRef = curScenario ()->supplyVol () (thePart);
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::exportInput (
      WitDemand *     theDemand,
      WitDblFlexVec & demandVolRef,
      WitDblFlexVec & cumDemandVolRef)
   {
   stronglyAssert (exportingInput ());

   demandVolRef    = curScenario ()->demandVol    () (theDemand);
   cumDemandVolRef = curScenario ()->cumDemandVol () (theDemand);
   }

//------------------------------------------------------------------------------

a476 7
bool WitStochImpMgr::exportingInput ()
   {
   return myStochModeMgr ()->exportingInput ();
   }

//------------------------------------------------------------------------------

@


1.22
log
@Stochastic Implosion
@
text
@d398 1
a398 1
void WitStochImpMgr::setRecourseStage (WitNode * theNode, bool theValue)
d400 1
a400 1
   myStochModeMgr ()->myStageMgr ()->setRecourseStage (theNode, theValue);
d419 1
a419 1
bool WitStochImpMgr::recourseStage (WitNode * theNode)
d421 1
a421 1
   return myStochModeMgr ()->myStageMgr ()->recourseStage () (theNode);
@


1.21
log
@Stochastic Implosion
@
text
@d378 1
a378 1
void WitStochImpMgr::setScenarioIndex (int theIdx)
d380 7
a386 1
   myStochModeMgr ()->myScenMgr ()->setScenarioIndex (theIdx);
d405 1
a405 1
int WitStochImpMgr::scenarioIndex ()
@


1.20
log
@Stochastic Implosion
@
text
@d385 1
a385 1
void WitStochImpMgr::setScenarioProb (double theValue)
d387 1
a387 1
   myStochModeMgr ()->myScenMgr ()->curScenario ()->setScenarioProb (theValue);
d406 1
a406 1
double WitStochImpMgr::scenarioProb ()
d408 1
a408 1
   return myStochModeMgr ()->myScenMgr ()->curScenario ()->scenarioProb ();
@


1.19
log
@Stochastic Implosion
@
text
@a39 1
      singleStochLP_   (true),
a134 9
void WitStochImpMgr::setSingleStochLP (bool theValue)
   {
   myProblem ()->prepSetUnpostAttr ();

   singleStochLP_ = theValue;
   }

//------------------------------------------------------------------------------

d241 1
a241 4
   if (singleStochLP_)
      myStochModeMgr ()->implodeSingleLP ();
   else
      myStochModeMgr ()->implodeSeriesLP ();
d282 1
a282 10
   if (exportingSoln ())
      {
      if (not singleStochLP_)
         {
         objValueRef    = myStochModeMgr ()->objValue    ();
         boundsValueRef = myStochModeMgr ()->boundsValue ();
         }
      }

   else if (clearingSoln ())
a286 3

   else
      stronglyAssert (false);
@


1.18
log
@Stochastic Implosion
@
text
@d40 1
a40 1
      singleStochLP_   (false),
@


1.17
log
@Stochastic Implosion
@
text
@d279 2
a280 1
      WitDblFlexVec & demandVolRef)
d284 2
a285 1
   demandVolRef = curScenario ()->demandVol () (theDemand);
@


1.16
log
@Stochastic Implosion
@
text
@d295 5
a299 2
         objValueRef = myStochModeMgr ()->   objValue ();
      boundsValueRef = myStochModeMgr ()->boundsValue ();
d319 1
a319 1
      scrapVolRef = curScenario ()->scrapVol () (thePart);
d335 1
a335 1
      stockVolRef = curScenario ()->stockVol () (theMat);
d353 2
a354 2
      shipVolRef    = curScenario ()->shipVol    () (theDemand);
      cumShipVolRef = curScenario ()->cumShipVol () (theDemand);
d374 1
a374 1
      execVolRef = curScenario ()->execVol () (theOpn);
d390 1
a390 1
      subVolRef = curScenario ()->subVol () (theSub);
d529 12
@


1.15
log
@Stochastic Implosion
@
text
@d23 1
d447 10
@


1.14
log
@Stochastic Implosion
@
text
@a127 8
void WitStochImpMgr::display (WitNode * theNode)
   {
   if (stochMode_)
      myStochModeMgr ()->myStageMgr ()->display (theNode);
   }

//------------------------------------------------------------------------------

d242 2
a243 1
   myStochModeMgr ()->myScenMgr ()->displayData ();
@


1.13
log
@Stochastic Implosion
@
text
@d115 1
a115 1
void WitStochImpMgr::display ()
d123 1
a123 1
      myStochModeMgr ()->myScenMgr ()->display ();
d248 7
@


1.12
log
@Stochastic Implosion
@
text
@d99 1
a99 1
         if (attIsScenSpec (theAttName))
d203 1
a203 1
bool WitStochImpMgr::attIsScenSpec (const char * theAttName)
d209 5
a213 4
   return
      (theStochAtt != NULL)?
         theStochAtt->scenSpec ():
         false;
d218 1
a218 1
bool WitStochImpMgr::attIsStochModeOK (const char * theAttName)
d224 5
a228 4
   return
      (theStochAtt != NULL)?
         theStochAtt->stochModeOK ():
         false;
d233 1
a233 1
bool WitStochImpMgr::attIsStochSolnModeOK (const char * theAttName)
d239 3
a241 5
   return
      (theStochAtt != NULL)?
         theStochAtt->stochSolnModeOK ():
         false;
   }
d243 1
a243 7
//------------------------------------------------------------------------------

bool WitStochImpMgr::isStochSolnModeAttName (const char * theAttName)
   {
   return
         equal (theAttName, "stochMode")
      or equal (theAttName, "scenarioIndex");
@


1.11
log
@Stochastic Implosion
@
text
@d18 2
d99 1
a99 1
         if (isSsiAttName (theAttName))
d203 1
a203 1
bool WitStochImpMgr::isSsiAttName (const char * theAttName)
d205 8
a212 1
   return myStochModeMgr ()->isSsiAttName (theAttName);
d217 1
a217 1
bool WitStochImpMgr::isStochModeAttName (const char * theAttName)
d219 18
d238 3
a240 4
         isSsiAttName (theAttName)
      or equal (theAttName, "stochMode")
      or equal (theAttName, "scenarioIndex")
      or equal (theAttName, "recourseStage");
@


1.10
log
@Stochastic Implosion
@
text
@d178 1
a178 1
   myProblem ()->prepSetStochSolnModeAttr ();
@


1.9
log
@Stochastic Implosion
@
text
@d208 20
@


1.8
log
@Stochastic Implosion
@
text
@d178 1
a178 1
   myProblem ()->prepSetStochModeAttr ();
@


1.7
log
@Stochastic Implosion.
@
text
@d203 1
a203 1
   myStochModeMgr ()->isSsiAttName (theAttName);
@


1.6
log
@Stochastic Implosion
@
text
@d93 1
a93 1
bool WitStochImpMgr::skipWriteData (const char * theAttrName)
d97 1
a97 1
         if (isSsiAttrName (theAttrName))
d201 1
a201 1
bool WitStochImpMgr::isSsiAttrName (const char * theName)
d203 1
a203 1
   myStochModeMgr ()->isSsiAttrName (theName);
@


1.5
log
@Stochastic Implosion
@
text
@d34 1
a34 1
      WitProbAssoc      (theProblem),
d36 6
a41 7
      stochImpAllowed_  (false),
      singleStochLP_    (false),
      stageByObject_    (defStageByObject ()),
      nScenarios_       (defNScenarios ()),
      stochMode_        (defStochMode ()),
      myStochModeMgr_   (NULL),
      toWriteStochAttr_ (false)
d93 1
a93 1
void WitStochImpMgr::prepWriteStochAttr ()
d95 4
a98 1
   stronglyAssert (not toWriteStochAttr_);
d100 1
a100 14
   toWriteStochAttr_ = true;
   }

//------------------------------------------------------------------------------

bool WitStochImpMgr::skipVectorWrite ()
   {
   bool skip;

   skip              = (stochMode_ and toWriteStochAttr_);

   toWriteStochAttr_ = false;

   return skip;
@


1.4
log
@Stochastic Implosion
@
text
@d212 7
@


1.3
log
@Stochastic Implosion
@
text
@d34 1
a34 1
      WitProbAssoc        (theProblem),
d36 7
a42 8
      stochImpAllowed_    (false),
      singleStochLP_      (false),
      stageByObject_      (defStageByObject ()),
      nScenarios_         (defNScenarios ()),
      stochMode_          (defStochMode ()),
      myStochModeMgr_     (NULL),
      toWriteStochAttr_   (false),
      toSetStochModeAttr_ (false)
a144 19
void WitStochImpMgr::prepStochModeAttr ()
   {
   stronglyAssert (not toSetStochModeAttr_);

   toSetStochModeAttr_ = true;
   }

//------------------------------------------------------------------------------

void WitStochImpMgr::prepSetAttr ()
   {
   if (stochMode_)
      stronglyAssert (toSetStochModeAttr_);

   toSetStochModeAttr_ = false;
   }

//------------------------------------------------------------------------------

d189 1
a189 3
   prepStochModeAttr ();

   myProblem ()->prepSetUnpostAttr ();
@


1.2
log
@Stochastic Implosion
@
text
@d252 11
@


1.1
log
@Stochastic Implosion
@
text
@d174 2
@


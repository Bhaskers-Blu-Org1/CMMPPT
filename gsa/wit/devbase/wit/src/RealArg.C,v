head	1.45;
access;
symbols
	sce_5_01_20080919:1.41
	latest_sce_4_20_20060523:1.37.0.2
	sce_4_20_20060523:1.37
	latest_sce4_20_OSL:1.36.0.2
	sce_4_20_OSL:1.36
	sce_410_withVa:1.34
	sce_4_05_20040511:1.29;
locks; strict;
comment	@ * @;


1.45
date	2011.09.28.23.50.02;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.24.00.28.26;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.08.30.20.18.03;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.04.22.27.35;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.02.17.48.37;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.06.22.53.02;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2006.10.04.18.45.07;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2006.09.21.15.42.27;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.02.17.34.10;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.21.15.44.15;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.17.17.07.18;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.19.21.38.03;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.17.18.15.10;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.11.17.20.36;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.24.23.23.57;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.22.19.25.56;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.19.18.25.18;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.14.21.25.36;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.09.15.52.47;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.06.18.16.57;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.06.15.42.17;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.05.20.06.11;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.02.20.54.16;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.29.19.12.39;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.27.00.08.20;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.26.17.03.33;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.26.16.27.03;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.26.16.07.23;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.25.23.28.07;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.25.22.00.36;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.25.21.21.58;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.24.22.21.33;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.24.17.03.32;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.24.16.50.34;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.23.21.37.45;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.19.22.00.53;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.18.16.49.52;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.09.18.42.54;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.26.20.40.26;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.26.18.59.42;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.25.18.59.38;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "RealArg.C"
//
// Contains the implementation of the following classes:
//
//    RealArg
//    ISRealArg
//    OSRealArg
//    IVRealArg
//    OVRealArg
//    OTDARealArg
//------------------------------------------------------------------------------

#include <ISRealArg.h>
#include <OSRealArg.h>
#include <IVRealArg.h>
#include <OVRealArg.h>
#include <OTDARealArg.h>
#include <Vector.h>
#include <WitRun.h>
#include <FlexVec.h>
#include <ApiCall.h>

//------------------------------------------------------------------------------
// Implementation of class RealArg.
//------------------------------------------------------------------------------

WitRealArg::WitRealArg (bool floatCaseVal):

      floatCase_ (floatCaseVal)
   {
   }

//------------------------------------------------------------------------------

WitRealArg::~WitRealArg ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class ISRealArg.
//------------------------------------------------------------------------------

WitISRealArg::WitISRealArg (float theFloat):

      WitRealArg (true),
      myFlt_     (theFloat),
      myDbl_     (0.0)
   {
   }

//------------------------------------------------------------------------------

WitISRealArg::WitISRealArg (double theDouble):

      WitRealArg (false),
      myFlt_     (0.0),
      myDbl_     (theDouble)
   {
   }

//------------------------------------------------------------------------------

WitISRealArg::~WitISRealArg ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class OSRealArg.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Inline member functions.
//------------------------------------------------------------------------------

inline float & WitOSRealArg::myFlt () const
   {
   nonMsgAssert (floatCase ());

   return (* myFltPtr_);
   }

//------------------------------------------------------------------------------

inline double & WitOSRealArg::myDbl () const
   {
   nonMsgAssert (doubleCase ());

   return (* myDblPtr_);
   }

//------------------------------------------------------------------------------
// Non-inline member functions.
//------------------------------------------------------------------------------

WitOSRealArg::WitOSRealArg (float * theFloatPtr):

      WitRealArg (true),
      myFltPtr_  (theFloatPtr),
      myDblPtr_  (NULL)
   {
   }

//------------------------------------------------------------------------------

WitOSRealArg::WitOSRealArg (double * theDoublePtr):

      WitRealArg (false),
      myFltPtr_  (NULL),
      myDblPtr_  (theDoublePtr)
   {
   }

//------------------------------------------------------------------------------

WitOSRealArg::~WitOSRealArg ()
   {
   }

//------------------------------------------------------------------------------

void WitOSRealArg::operator = (double theValue) const
   {
   if (floatCase ())
      myFlt () = fltFromDbl (theValue);
   else 
      myDbl () =             theValue;
   }

//------------------------------------------------------------------------------

WitOSRealArg::operator void * () const
   {
   if (floatCase ())
      return myFltPtr_;
   else
      return myDblPtr_;
   }

//------------------------------------------------------------------------------

double WitOSRealArg::appVarVal () const
   {
   return 
      floatCase ()?
         dblFromFlt (myFlt ()):
                     myDbl ();
   }

//------------------------------------------------------------------------------
// Implementation of class IVRealArg.
//------------------------------------------------------------------------------

WitIVRealArg::WitIVRealArg (const float * theFltCVec):

      WitRealArg (true),
      myFltCVec_ (theFltCVec),
      myDblCVec_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitIVRealArg::WitIVRealArg (const double * theDblCVec):

      WitRealArg (false),
      myFltCVec_ (NULL),
      myDblCVec_ (theDblCVec)
   {
   }

//------------------------------------------------------------------------------

WitIVRealArg::~WitIVRealArg ()
   {
   }

//------------------------------------------------------------------------------

void WitIVRealArg::copyInto (WitDblFlexVec & theDblFlexVec) const
   {
   if (floatCase ())
      theDblFlexVec = myFltCVec ();
   else
      theDblFlexVec = myDblCVec ();
   }

//------------------------------------------------------------------------------

WitIVRealArg::operator const void * () const
   {
   if (floatCase ())
      return myFltCVec ();
   else
      return myDblCVec ();
   }

//------------------------------------------------------------------------------

bool WitIVRealArg::isNonNeg (int length) const
   {
   int theIdx;

   for (theIdx = 0; theIdx < length; theIdx ++)
      if ((* this)[theIdx] < 0.0)
         return false;

   return true;
   }

//------------------------------------------------------------------------------

void WitIVRealArg::issueSetDblVecMsg (
      const char * theAttName,
      WitApiCall & theApiCall)
      const
   {
   if (floatCase ())
      theApiCall.issueSetDblVecMsg (theAttName, myFltCVec ());
   else
      theApiCall.issueSetDblVecMsg (theAttName, myDblCVec ());
   }

//------------------------------------------------------------------------------

void WitIVRealArg::issueBoundVecMsg (
      WitBoundSet * theBoundSet,
      WitMsgFragID  theFragID,
      WitApiCall &  theApiCall)
      const
   {
   if (floatCase ())
      theApiCall.issueBoundVecMsg (theBoundSet, myFltCVec (), theFragID);
   else
      theApiCall.issueBoundVecMsg (theBoundSet, myDblCVec (), theFragID);
   }

//------------------------------------------------------------------------------
// Implementation of class OVRealArg.
//------------------------------------------------------------------------------

WitOVRealArg::WitOVRealArg (float * * theFltCVecPtr):

      WitRealArg    (true),
      myFltCVecPtr_ (theFltCVecPtr),
      myDblCVecPtr_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitOVRealArg::WitOVRealArg (double * * theDblCVecPtr):

      WitRealArg    (false),
      myFltCVecPtr_ (NULL),
      myDblCVecPtr_ (theDblCVecPtr)
   {
   }

//------------------------------------------------------------------------------

WitOVRealArg::~WitOVRealArg ()
   {
   }

//------------------------------------------------------------------------------

void WitOVRealArg::apiAlloc (int nElems) const
   {
   if (floatCase ())
      WitNonClass::apiAlloc (myFltCVecPtr_, nElems);
   else
      WitNonClass::apiAlloc (myDblCVecPtr_, nElems);
   }

//------------------------------------------------------------------------------

void WitOVRealArg::operator = (const WitDblFlexVec & theDblFlexVec) const
   {
   if (floatCase ())
      theDblFlexVec.copyInto (myFltCVec ());
   else
      theDblFlexVec.copyInto (myDblCVec ());
   }

//------------------------------------------------------------------------------

void WitOVRealArg::operator = (const WitVector <double> & theDblVec) const
   {
   int theIdx;

   if (floatCase ())
      for (theIdx = 0; theIdx < theDblVec.length (); theIdx ++)
         myFltCVec ()[theIdx] = fltFromDbl (theDblVec[theIdx]);
   else
      theDblVec.copyInto (myDblCVec ());
   }

//------------------------------------------------------------------------------

WitOVRealArg::operator void * () const
   {
   if (floatCase ())
      return myFltCVecPtr_;
   else
      return myDblCVecPtr_;
   }

//------------------------------------------------------------------------------
// Implementation of class OTDARealArg.
//------------------------------------------------------------------------------

WitOTDARealArg::WitOTDARealArg (float * * * theFltArPtr):

      WitRealArg  (true),
      myFltArPtr_ (theFltArPtr),
      myDblArPtr_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitOTDARealArg::WitOTDARealArg (double * * * theDblArPtr):

      WitRealArg  (false),
      myFltArPtr_ (NULL),
      myDblArPtr_ (theDblArPtr)
   {
   }

//------------------------------------------------------------------------------

WitOTDARealArg::~WitOTDARealArg ()
   {
   }

//------------------------------------------------------------------------------

void WitOTDARealArg::apiAlloc (int nRows, int nCols) const
   {
   int theIdx;

   if (floatCase ())
      WitNonClass::apiAlloc (myFltArPtr_, nRows);
   else
      WitNonClass::apiAlloc (myDblArPtr_, nRows);

   for (theIdx = 0; theIdx < nRows; theIdx ++)
      if (floatCase ())
         WitNonClass::apiAlloc (& ((* myFltArPtr_)[theIdx]), nCols);
      else
         WitNonClass::apiAlloc (& ((* myDblArPtr_)[theIdx]), nCols);
   }

//------------------------------------------------------------------------------

void WitOTDARealArg::copyIntoRow (
      int                   theIdx,
      const WitDblFlexVec & theDblFlexVec)
      const
   {
   if (floatCase ())
      theDblFlexVec.copyInto ((* myFltArPtr_)[theIdx]);
   else
      theDblFlexVec.copyInto ((* myDblArPtr_)[theIdx]);
   }

//------------------------------------------------------------------------------

WitOTDARealArg::operator void * () const
   {
   if (floatCase ())
      return myFltArPtr_;
   else
      return myDblArPtr_;
   }
@


1.44
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.43
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d39 3
a41 3
floatCase_ (floatCaseVal)
{
}
d46 2
a47 2
{
}
d55 5
a59 5
WitRealArg (true),
myFlt_     (theFloat),
myDbl_     (0.0)
{
}
d65 5
a69 5
WitRealArg (false),
myFlt_     (0.0),
myDbl_     (theDouble)
{
}
d74 2
a75 2
{
}
d86 2
a87 2
{
nonMsgAssert (floatCase ());
d89 2
a90 2
return (* myFltPtr_);
}
d95 2
a96 2
{
nonMsgAssert (doubleCase ());
d98 2
a99 2
return (* myDblPtr_);
}
d107 5
a111 5
WitRealArg (true),
myFltPtr_  (theFloatPtr),
myDblPtr_  (NULL)
{
}
d117 5
a121 5
WitRealArg (false),
myFltPtr_  (NULL),
myDblPtr_  (theDoublePtr)
{
}
d126 2
a127 2
{
}
d132 6
a137 6
{
if (floatCase ())
myFlt () = fltFromDbl (theValue);
else
myDbl () =             theValue;
}
d142 6
a147 6
{
if (floatCase ())
return myFltPtr_;
else
return myDblPtr_;
}
d152 6
a157 6
{
return
floatCase ()?
dblFromFlt (myFlt ()):
myDbl ();
}
d165 5
a169 5
WitRealArg (true),
myFltCVec_ (theFltCVec),
myDblCVec_ (NULL)
{
}
d175 5
a179 5
WitRealArg (false),
myFltCVec_ (NULL),
myDblCVec_ (theDblCVec)
{
}
d184 2
a185 2
{
}
d190 6
a195 6
{
if (floatCase ())
theDblFlexVec = myFltCVec ();
else
theDblFlexVec = myDblCVec ();
}
d200 6
a205 6
{
if (floatCase ())
return myFltCVec ();
else
return myDblCVec ();
}
d210 2
a211 2
{
int theIdx;
d213 3
a215 3
for (theIdx = 0; theIdx < length; theIdx ++)
if ((* this)[theIdx] < 0.0)
return false;
d217 2
a218 2
return true;
}
d223 9
a231 9
const char * theAttName,
WitApiCall & theApiCall)
const
{
if (floatCase ())
theApiCall.issueSetDblVecMsg (theAttName, myFltCVec ());
else
theApiCall.issueSetDblVecMsg (theAttName, myDblCVec ());
}
d236 10
a245 10
WitBoundSet * theBoundSet,
WitMsgFragID  theFragID,
WitApiCall &  theApiCall)
const
{
if (floatCase ())
theApiCall.issueBoundVecMsg (theBoundSet, myFltCVec (), theFragID);
else
theApiCall.issueBoundVecMsg (theBoundSet, myDblCVec (), theFragID);
}
d253 5
a257 5
WitRealArg    (true),
myFltCVecPtr_ (theFltCVecPtr),
myDblCVecPtr_ (NULL)
{
}
d263 5
a267 5
WitRealArg    (false),
myFltCVecPtr_ (NULL),
myDblCVecPtr_ (theDblCVecPtr)
{
}
d272 2
a273 2
{
}
d278 6
a283 6
{
if (floatCase ())
WitNonClass::apiAlloc (myFltCVecPtr_, nElems);
else
WitNonClass::apiAlloc (myDblCVecPtr_, nElems);
}
d288 6
a293 6
{
if (floatCase ())
theDblFlexVec.copyInto (myFltCVec ());
else
theDblFlexVec.copyInto (myDblCVec ());
}
d298 2
a299 2
{
int theIdx;
d301 6
a306 6
if (floatCase ())
for (theIdx = 0; theIdx < theDblVec.length (); theIdx ++)
myFltCVec ()[theIdx] = fltFromDbl (theDblVec[theIdx]);
else
theDblVec.copyInto (myDblCVec ());
}
d311 6
a316 6
{
if (floatCase ())
return myFltCVecPtr_;
else
return myDblCVecPtr_;
}
d324 5
a328 5
WitRealArg  (true),
myFltArPtr_ (theFltArPtr),
myDblArPtr_ (NULL)
{
}
d334 5
a338 5
WitRealArg  (false),
myFltArPtr_ (NULL),
myDblArPtr_ (theDblArPtr)
{
}
d343 2
a344 2
{
}
d349 2
a350 2
{
int theIdx;
d352 11
a362 11
if (floatCase ())
WitNonClass::apiAlloc (myFltArPtr_, nRows);
else
WitNonClass::apiAlloc (myDblArPtr_, nRows);

for (theIdx = 0; theIdx < nRows; theIdx ++)
if (floatCase ())
WitNonClass::apiAlloc (& ((* myFltArPtr_)[theIdx]), nCols);
else
WitNonClass::apiAlloc (& ((* myDblArPtr_)[theIdx]), nCols);
}
d367 9
a375 9
int                   theIdx,
const WitDblFlexVec & theDblFlexVec)
const
{
if (floatCase ())
theDblFlexVec.copyInto ((* myFltArPtr_)[theIdx]);
else
theDblFlexVec.copyInto ((* myDblArPtr_)[theIdx]);
}
d380 6
a385 6
{
if (floatCase ())
return myFltArPtr_;
else
return myDblArPtr_;
}
@


1.42
log
@Changed some witAsserts into nonMsgAsserts.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d39 3
a41 3
      floatCase_ (floatCaseVal)
   {
   }
d46 2
a47 2
   {
   }
d55 5
a59 5
      WitRealArg (true),
      myFlt_     (theFloat),
      myDbl_     (0.0)
   {
   }
d65 5
a69 5
      WitRealArg (false),
      myFlt_     (0.0),
      myDbl_     (theDouble)
   {
   }
d74 2
a75 2
   {
   }
d86 2
a87 2
   {
   nonMsgAssert (floatCase ());
d89 2
a90 2
   return (* myFltPtr_);
   }
d95 2
a96 2
   {
   nonMsgAssert (doubleCase ());
d98 2
a99 2
   return (* myDblPtr_);
   }
d107 5
a111 5
      WitRealArg (true),
      myFltPtr_  (theFloatPtr),
      myDblPtr_  (NULL)
   {
   }
d117 5
a121 5
      WitRealArg (false),
      myFltPtr_  (NULL),
      myDblPtr_  (theDoublePtr)
   {
   }
d126 2
a127 2
   {
   }
d132 6
a137 6
   {
   if (floatCase ())
      myFlt () = fltFromDbl (theValue);
   else 
      myDbl () =             theValue;
   }
d142 6
a147 6
   {
   if (floatCase ())
      return myFltPtr_;
   else
      return myDblPtr_;
   }
d152 6
a157 6
   {
   return 
      floatCase ()?
         dblFromFlt (myFlt ()):
                     myDbl ();
   }
d165 5
a169 5
      WitRealArg (true),
      myFltCVec_ (theFltCVec),
      myDblCVec_ (NULL)
   {
   }
d175 5
a179 5
      WitRealArg (false),
      myFltCVec_ (NULL),
      myDblCVec_ (theDblCVec)
   {
   }
d184 2
a185 2
   {
   }
d190 6
a195 6
   {
   if (floatCase ())
      theDblFlexVec = myFltCVec ();
   else
      theDblFlexVec = myDblCVec ();
   }
d200 6
a205 6
   {
   if (floatCase ())
      return myFltCVec ();
   else
      return myDblCVec ();
   }
d210 2
a211 2
   {
   int theIdx;
d213 3
a215 3
   for (theIdx = 0; theIdx < length; theIdx ++)
      if ((* this)[theIdx] < 0.0)
         return false;
d217 2
a218 2
   return true;
   }
d223 9
a231 9
      const char * theAttName,
      WitApiCall & theApiCall)
      const
   {
   if (floatCase ())
      theApiCall.issueSetDblVecMsg (theAttName, myFltCVec ());
   else
      theApiCall.issueSetDblVecMsg (theAttName, myDblCVec ());
   }
d236 10
a245 10
      WitBoundSet * theBoundSet,
      WitMsgFragID  theFragID,
      WitApiCall &  theApiCall)
      const
   {
   if (floatCase ())
      theApiCall.issueBoundVecMsg (theBoundSet, myFltCVec (), theFragID);
   else
      theApiCall.issueBoundVecMsg (theBoundSet, myDblCVec (), theFragID);
   }
d253 5
a257 5
      WitRealArg    (true),
      myFltCVecPtr_ (theFltCVecPtr),
      myDblCVecPtr_ (NULL)
   {
   }
d263 5
a267 5
      WitRealArg    (false),
      myFltCVecPtr_ (NULL),
      myDblCVecPtr_ (theDblCVecPtr)
   {
   }
d272 2
a273 2
   {
   }
d278 6
a283 6
   {
   if (floatCase ())
      WitNonClass::apiAlloc (myFltCVecPtr_, nElems);
   else
      WitNonClass::apiAlloc (myDblCVecPtr_, nElems);
   }
d288 6
a293 6
   {
   if (floatCase ())
      theDblFlexVec.copyInto (myFltCVec ());
   else
      theDblFlexVec.copyInto (myDblCVec ());
   }
d298 2
a299 2
   {
   int theIdx;
d301 6
a306 6
   if (floatCase ())
      for (theIdx = 0; theIdx < theDblVec.length (); theIdx ++)
         myFltCVec ()[theIdx] = fltFromDbl (theDblVec[theIdx]);
   else
      theDblVec.copyInto (myDblCVec ());
   }
d311 6
a316 6
   {
   if (floatCase ())
      return myFltCVecPtr_;
   else
      return myDblCVecPtr_;
   }
d324 5
a328 5
      WitRealArg  (true),
      myFltArPtr_ (theFltArPtr),
      myDblArPtr_ (NULL)
   {
   }
d334 5
a338 5
      WitRealArg  (false),
      myFltArPtr_ (NULL),
      myDblArPtr_ (theDblArPtr)
   {
   }
d343 2
a344 2
   {
   }
d349 2
a350 2
   {
   int theIdx;
d352 11
a362 11
   if (floatCase ())
      WitNonClass::apiAlloc (myFltArPtr_, nRows);
   else
      WitNonClass::apiAlloc (myDblArPtr_, nRows);

   for (theIdx = 0; theIdx < nRows; theIdx ++)
      if (floatCase ())
         WitNonClass::apiAlloc (& ((* myFltArPtr_)[theIdx]), nCols);
      else
         WitNonClass::apiAlloc (& ((* myDblArPtr_)[theIdx]), nCols);
   }
d367 9
a375 9
      int                   theIdx,
      const WitDblFlexVec & theDblFlexVec)
      const
   {
   if (floatCase ())
      theDblFlexVec.copyInto ((* myFltArPtr_)[theIdx]);
   else
      theDblFlexVec.copyInto ((* myDblArPtr_)[theIdx]);
   }
d380 6
a385 6
   {
   if (floatCase ())
      return myFltArPtr_;
   else
      return myDblArPtr_;
   }
@


1.41
log
@Removed many conversions of string constant to char *.
@
text
@d87 1
a87 1
   witAssert (floatCase ());
d96 1
a96 1
   witAssert (doubleCase ());
@


1.40
log
@Stochastic Implosion
@
text
@d223 1
a223 1
      WitAttr      theAttr,
d228 1
a228 1
      theApiCall.issueSetDblVecMsg (theAttr, myFltCVec ());
d230 1
a230 1
      theApiCall.issueSetDblVecMsg (theAttr, myDblCVec ());
@


1.39
log
@App controlled opt implosion.
@
text
@d236 3
a238 3
      const WitBoundSet * theBoundSet,
      WitMsgFragID        theFragID,
      WitApiCall &        theApiCall)
@


1.38
log
@App controlled opt implosion.
@
text
@d297 1
a297 1
void WitOVRealArg::setElem (int theIdx, double theVal) const
d299 2
d302 2
a303 1
      myFltCVec ()[theIdx] = fltFromDbl (theVal);
d305 1
a305 1
      myDblCVec ()[theIdx] =             theVal;
@


1.37
log
@Updated the copyright date on all source files.
@
text
@d209 13
@


1.36
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.35
log
@[shared-resource pegging]
@
text
@d264 1
a264 1
void WitOVRealArg::apiAlloc (WitSiz nElems) const
d332 1
a332 1
void WitOTDARealArg::apiAlloc (WitSiz nRows, WitSiz nCols) const
@


1.34
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d264 1
a264 1
void WitOVRealArg::apiAlloc (size_t nElems) const
d332 1
a332 1
void WitOTDARealArg::apiAlloc (size_t nRows, size_t nCols) const
@


1.33
log
@[multi-thread]
@
text
@a36 19
int WitRealArg::nFloatArgs_  = 0;
int WitRealArg::nDoubleArgs_ = 0;

//------------------------------------------------------------------------------

bool WitRealArg::floatArgsExist ()
   {
   return (nFloatArgs_ >= 1);
   }

//------------------------------------------------------------------------------

bool WitRealArg::doubleArgsExist ()
   {
   return (nDoubleArgs_ >= 1);
   }

//------------------------------------------------------------------------------

a40 4
   if (floatCase_)
      nFloatArgs_  ++;
   else
      nDoubleArgs_ ++;
a46 4
   if (floatCase_)
      nFloatArgs_  --;
   else
      nDoubleArgs_ --;
@


1.32
log
@Vector PropRtg.
@
text
@d60 4
a63 1
   nSameCaseArgs () ++;
d70 4
a73 11
   nSameCaseArgs () --;
   }

//------------------------------------------------------------------------------

int & WitRealArg::nSameCaseArgs ()
   {
   return
      floatCase_?
         nFloatArgs_:
         nDoubleArgs_;
@


1.31
log
@Vector PropRt.
@
text
@d86 3
a88 2
      WitRealArg  (true),
      myUnderArg_ (dblFromFlt (theFloat))
d96 3
a98 2
      WitRealArg  (false),
      myUnderArg_ (theDouble)
@


1.30
log
@An attempt to fix warnings from the gcc 3.3.3 compiler.
@
text
@d16 5
a20 5
//    InScalRA
//    OutScalRA
//    InVecRA
//    OutVecRA
//    Out2DARA
d23 5
a27 5
#include <InScalRA.h>
#include <OutScalRA.h>
#include <InVecRA.h>
#include <OutVecRA.h>
#include <Out2DARA.h>
d81 1
a81 1
// Implementation of class InScalRA.
d84 1
a84 1
WitInScalRA::WitInScalRA (float theFloat):
d93 1
a93 1
WitInScalRA::WitInScalRA (double theDouble):
d102 1
a102 1
WitInScalRA::~WitInScalRA ()
d107 1
a107 1
// Implementation of class OutScalRA.
d114 1
a114 1
inline float & WitOutScalRA::myFlt () const
d123 1
a123 1
inline double & WitOutScalRA::myDbl () const
d134 1
a134 1
WitOutScalRA::WitOutScalRA (float * theFloatPtr):
d144 1
a144 1
WitOutScalRA::WitOutScalRA (double * theDoublePtr):
d154 1
a154 1
WitOutScalRA::~WitOutScalRA ()
d160 1
a160 1
void WitOutScalRA::operator = (double theValue) const
d170 1
a170 1
WitOutScalRA::operator void * () const
d180 1
a180 1
double WitOutScalRA::appVarVal () const
d189 1
a189 1
// Implementation of class InVecRA.
d192 1
a192 1
WitInVecRA::WitInVecRA (const float * theFltCVec):
d202 1
a202 1
WitInVecRA::WitInVecRA (const double * theDblCVec):
d212 1
a212 1
WitInVecRA::~WitInVecRA ()
d218 1
a218 1
void WitInVecRA::copyInto (WitDblFlexVec & theDblFlexVec) const
d228 1
a228 1
WitInVecRA::operator const void * () const
d238 1
a238 1
void WitInVecRA::issueSetDblVecMsg (
d251 1
a251 1
void WitInVecRA::issueBoundVecMsg (
d264 1
a264 1
// Implementation of class OutVecRA.
d267 1
a267 1
WitOutVecRA::WitOutVecRA (float * * theFltCVecPtr):
d277 1
a277 1
WitOutVecRA::WitOutVecRA (double * * theDblCVecPtr):
d287 1
a287 1
WitOutVecRA::~WitOutVecRA ()
d293 1
a293 1
void WitOutVecRA::apiAlloc (size_t nElems) const
d303 1
a303 1
void WitOutVecRA::operator = (const WitDblFlexVec & theDblFlexVec) const
d313 1
a313 1
void WitOutVecRA::setElem (int theIdx, double theVal) const
d323 1
a323 1
WitOutVecRA::operator void * () const
d332 1
a332 1
// Implementation of class Out2DARA.
d335 1
a335 1
WitOut2DARA::WitOut2DARA (float * * * theFltArPtr):
d345 1
a345 1
WitOut2DARA::WitOut2DARA (double * * * theDblArPtr):
d355 1
a355 1
WitOut2DARA::~WitOut2DARA ()
d361 1
a361 1
void WitOut2DARA::apiAlloc (size_t nRows, size_t nCols) const
d379 1
a379 1
void WitOut2DARA::copyIntoRow (
d392 1
a392 1
WitOut2DARA::operator void * () const
@


1.29
log
@Double Precision.
@
text
@d110 24
a188 18

inline float & WitOutScalRA::myFlt () const
   {
   witAssert (floatCase ());

   return (* myFltPtr_);
   }

//------------------------------------------------------------------------------

inline double & WitOutScalRA::myDbl () const
   {
   witAssert (doubleCase ());

   return (* myDblPtr_);
   }

//------------------------------------------------------------------------------
@


1.28
log
@Double Precision.
@
text
@a211 10
void WitInVecRA::copyInto (WitTVec <float> & theFltTVec) const
   {
   if (floatCase ())
      theFltTVec = myFltCVec ();
   else
      copy (theFltTVec, myDblCVec ());
   }

//------------------------------------------------------------------------------

@


1.27
log
@Double Precision.
@
text
@d31 1
d238 27
@


1.26
log
@Double Precision.
@
text
@d211 1
a211 1
void WitInVecRA::convCopyInto (WitTVec <float> & theFltTVec) const
d216 1
a216 1
      convCopy (theFltTVec, myDblCVec ());
d221 1
a221 1
void WitInVecRA::convCopyInto (WitDblFlexVec & theDblFlexVec) const
d282 1
a282 1
      theDblFlexVec.convCopyInto (myFltCVec ());
d284 1
a284 1
      theDblFlexVec.convCopyInto (myDblCVec ());
d355 1
a355 1
void WitOut2DARA::convCopyIntoRow (
d361 1
a361 1
      theDblFlexVec.convCopyInto ((* myFltArPtr_)[theIdx]);
d363 1
a363 1
      theDblFlexVec.convCopyInto ((* myDblArPtr_)[theIdx]);
@


1.25
log
@Double Precision.
@
text
@d135 1
a135 1
void WitOutScalRA::setTo (double theValue) const
d214 1
a214 1
      theFltTVec.convCopy (myFltCVec ());
d224 1
a224 1
      theDblFlexVec.convCopy (myFltCVec ());
d226 1
a226 1
      theDblFlexVec.convCopy (myDblCVec ());
d279 1
a279 1
void WitOutVecRA::convCopy (const WitDblFlexVec & theDblFlexVec) const
@


1.24
log
@Double Precision.
@
text
@d20 1
d27 1
d305 69
@


1.23
log
@Double Precision.
@
text
@d270 1
a270 1
      WitNonClass::apiAlloc (myFltCVec (), nElems);
d272 1
a272 1
      WitNonClass::apiAlloc (myDblCVec (), nElems);
d287 1
a287 1
WitOutVecRA::operator void * () const
d290 1
a290 1
      return myFltCVecPtr_;
d292 1
a292 1
      return myDblCVecPtr_;
d297 1
a297 1
void WitOutVecRA::setElem (int theIdx, double theVal) const
d300 1
a300 1
      myFltCVec ()[theIdx] = fltFromDbl (theVal);
d302 1
a302 1
      myDblCVec ()[theIdx] =             theVal;
@


1.22
log
@Double Precision.
@
text
@d143 1
a143 1
WitTlObj * WitOutScalRA::asaTlPtr () const
d145 4
a148 4
   return 
      floatCase ()?
         toTlObj_cast (myFltPtr_):
         toTlObj_cast (myDblPtr_);
d229 1
a229 1
const WitTlObj * WitInVecRA::asaTlPtr () const
d231 4
a234 4
   return 
      floatCase ()?
         toConstTlObj_cast (myFltCVec ()):
         toConstTlObj_cast (myDblCVec ());
d287 1
a287 1
WitTlObj * WitOutVecRA::asaTlPtr () const
d289 4
a292 4
   return 
      floatCase ()?
         toTlObj_cast (myFltCVecPtr_):
         toTlObj_cast (myDblCVecPtr_);
@


1.21
log
@Double Precision.
@
text
@d287 10
a302 10
   }

//------------------------------------------------------------------------------

WitTlObj * WitOutVecRA::asaTlPtr () const
   {
   return 
      floatCase ()?
         toTlObj_cast (myFltCVecPtr_):
         toTlObj_cast (myDblCVecPtr_);
@


1.20
log
@Double Precision.
@
text
@d287 10
@


1.19
log
@Double Precision.
@
text
@d143 1
a143 1
WitTlObj * WitOutScalRA::myUnderArgAsTlPtr () const
d229 1
a229 1
const WitTlObj * WitInVecRA::myUnderArgAsTlPtr () const
d287 1
a287 1
WitTlObj * WitOutVecRA::myUnderArgAsTlPtr () const
@


1.18
log
@Double Precision.
@
text
@a188 1
   witAssert (theFltCVec != NULL);
a198 1
   witAssert (theDblCVec != NULL);
@


1.17
log
@Double Precision.
@
text
@d272 1
a272 1
      WitRun::apiAlloc (myFltCVec (), nElems);
d274 1
a274 1
      WitRun::apiAlloc (myDblCVec (), nElems);
@


1.16
log
@Double Precision.
@
text
@d269 1
a269 1
void WitOutVecRA::apiAlloc (size_t nElems)
d275 10
@


1.15
log
@Double Precision.
@
text
@d53 1
a53 1
WitRealArg::WitRealArg (bool doubleCaseVal):
d55 1
a55 1
      doubleCase_ (doubleCaseVal)
d72 3
a74 3
      doubleCase_?
         nDoubleArgs_:
         nFloatArgs_;
d83 1
a83 1
      WitRealArg  (false),
d92 1
a92 1
      WitRealArg  (true),
d109 1
a109 1
      WitRealArg (false),
d119 1
a119 1
      WitRealArg (true),
d135 3
a137 1
   if (doubleCase ())
a138 2
   else 
      myFlt () = fltFromDbl (theValue);
d146 3
a148 3
      doubleCase ()?
         toTlObj_cast (myDblPtr_):
         toTlObj_cast (myFltPtr_);
d156 3
a158 3
      doubleCase ()?
                     myDbl ():
         dblFromFlt (myFlt ());
d185 1
a185 1
      WitRealArg (false),
d196 1
a196 1
      WitRealArg (true),
d213 3
a215 1
   if (doubleCase ())
a216 2
   else
      theFltTVec.convCopy (myFltCVec ());
d223 3
a225 1
   if (doubleCase ())
a226 2
   else
      theDblFlexVec.convCopy (myFltCVec ());
d234 3
a236 3
      doubleCase ()?
         toConstTlObj_cast (myDblCVec ()):
         toConstTlObj_cast (myFltCVec ());
d245 1
a245 1
      WitRealArg    (false),
d255 1
a255 1
      WitRealArg    (true),
d271 3
a273 1
   if (doubleCase ())
a274 2
   else
      WitRun::apiAlloc (myFltCVec (), nElems);
d282 3
a284 3
      doubleCase ()?
         toTlObj_cast (myDblCVecPtr_):
         toTlObj_cast (myFltCVecPtr_);
@


1.14
log
@Double Precision.
@
text
@d27 1
d136 1
a136 1
      * myDblPtr () =             theValue;
d138 11
a148 1
      * myFltPtr () = fltFromDbl (theValue);
d157 20
a176 2
                     * myDblPtr ():
         dblFromFlt (* myFltPtr ());
d230 10
d265 20
@


1.13
log
@Double Precision.
@
text
@d19 1
d25 1
d198 28
@


1.12
log
@Double Precision.
@
text
@a58 9
WitRealArg::WitRealArg (const WitRealArg & theRealArg):

      doubleCase_ (theRealArg.doubleCase_)
   {
   nSameCaseArgs () ++;
   }

//------------------------------------------------------------------------------

a123 10
WitOutScalRA::WitOutScalRA (const WitOutScalRA & theOutScalRA):

      WitRealArg (theOutScalRA),
      myFltPtr_  (theOutScalRA.myFltPtr_),
      myDblPtr_  (theOutScalRA.myDblPtr_)
   {
   }

//------------------------------------------------------------------------------

d130 1
a130 1
void WitOutScalRA::setTo (double theValue)
@


1.11
log
@Double Precision.
@
text
@a104 9
WitInScalRA::WitInScalRA (const WitInScalRA & theInScalRA):

      WitRealArg  (theInScalRA),
      myUnderArg_ (theInScalRA.myUnderArg_)
   {
   }

//------------------------------------------------------------------------------

@


1.10
log
@Double Precision.
@
text
@d218 1
a218 1
void WitInVecRA::convCopyInto (WitFlexVec <double> & theDblFlexVec) const
d223 1
a223 1
      convCopy (theDblFlexVec, myFltCVec ());
@


1.9
log
@Double Precision.
@
text
@a201 10
WitInVecRA::WitInVecRA (const WitInVecRA & theInVecRA):

      WitRealArg (theInVecRA),
      myFltCVec_ (theInVecRA.myFltCVec_),
      myDblCVec_ (theInVecRA.myDblCVec_)
   {
   }

//------------------------------------------------------------------------------

@


1.8
log
@Double Precision.
@
text
@d218 10
@


1.7
log
@Double Precision.
@
text
@d25 1
d218 1
a218 1
void WitInVecRA::convCopyInto (float * theFltCVec, int nElems)
d221 1
a221 1
      convCopy (theFltCVec, myDblCVec (), nElems);
d223 1
a223 11
      copy     (theFltCVec, myFltCVec (), nElems);
   }

//------------------------------------------------------------------------------
 
bool WitInVecRA::hasSingleValue (int nElems)
   {
   return
      doubleCase ()?
         WitNonClass::hasSingleValue (myDblCVec (), nElems):
         WitNonClass::hasSingleValue (myFltCVec (), nElems);
@


1.6
log
@Double Precision.
@
text
@d24 1
d185 1
d196 1
d213 20
@


1.5
log
@Double Precision.
@
text
@d18 1
d23 1
d122 3
a124 1
      WitRealArg (false)
a125 1
   myFltPtr_ = theFloatPtr;
d132 3
a134 1
      WitRealArg (true)
a135 1
   myDblPtr_ = theDoublePtr;
d142 3
a144 1
      WitRealArg (theOutScalRA)
a145 4
   if (doubleCase ())
      myDblPtr_ = theOutScalRA.myDblPtr_;
   else
      myFltPtr_ = theOutScalRA.myFltPtr_;
d159 1
a159 1
      * myDblPtr_ =             theValue;
d161 1
a161 1
      * myFltPtr_ = fltFromDbl (theValue);
d170 34
a203 2
                     * myDblPtr_:
         dblFromFlt (* myFltPtr_);
d206 5
@


1.4
log
@Double Precision.
@
text
@d120 1
a120 2
      WitRealArg  (false),
      myUnderArg_ (toTlObj_cast (theFloatPtr))
d122 1
d129 1
a129 2
      WitRealArg  (true),
      myUnderArg_ (toTlObj_cast (theDoublePtr))
d131 1
d138 1
a138 2
      WitRealArg  (theOutScalRA),
      myUnderArg_ (theOutScalRA.myUnderArg_)
d140 4
d157 1
a157 1
      * fromTlObj_cast <double> (myUnderArg_) =             theValue;
d159 1
a159 1
      * fromTlObj_cast <float>  (myUnderArg_) = fltFromDbl (theValue);
d168 2
a169 2
                     * fromTlObj_cast <double> (myUnderArg_):
         dblFromFlt (* fromTlObj_cast <float>  (myUnderArg_));
@


1.3
log
@Double Precision.
@
text
@d86 1
a86 1
      myUnderArg_ (doubleFromFloat (theFloat))
d154 1
a154 1
      * fromTlObj_cast <double> (myUnderArg_) =                  theValue;
d156 1
a156 1
      * fromTlObj_cast <float>  (myUnderArg_) = floatFromDouble (theValue);
d165 2
a166 2
                          * fromTlObj_cast <double> (myUnderArg_):
         doubleFromFloat (* fromTlObj_cast <float>  (myUnderArg_));
@


1.2
log
@Double Precision.
@
text
@a21 1
#include <Session.h>
@


1.1
log
@Double Precision.
@
text
@d15 3
a17 3
//    Wit::RealArg
//    Wit::InScalRA
//    Wit::OutScalRA
d25 1
a25 1
// Implementation of class Wit::RealArg.
d28 2
a29 2
int RealArg::nFloatArgs_  = 0;
int RealArg::nDoubleArgs_ = 0;
d33 1
a33 1
bool RealArg::floatArgsExist ()
d40 1
a40 1
bool RealArg::doubleArgsExist ()
d47 1
a47 1
RealArg::RealArg (bool doubleCaseVal):
d56 1
a56 1
RealArg::RealArg (const RealArg & theRealArg):
d65 1
a65 1
RealArg::~RealArg ()
d72 1
a72 1
int & RealArg::nSameCaseArgs ()
d81 1
a81 1
// Implementation of class Wit::InScalRA.
d84 1
a84 1
InScalRA::InScalRA (float theFloat):
d86 1
a86 1
      RealArg     (false),
d93 1
a93 1
InScalRA::InScalRA (double theDouble):
d95 1
a95 1
      RealArg     (true),
d102 1
a102 1
InScalRA::InScalRA (const InScalRA & theInScalRA):
d104 1
a104 1
      RealArg     (theInScalRA),
d111 1
a111 1
InScalRA::~InScalRA ()
d116 1
a116 1
// Implementation of class Wit::OutScalRA.
d119 1
a119 1
OutScalRA::OutScalRA (float * theFloatPtr):
d121 1
a121 1
      RealArg     (false),
d128 1
a128 1
OutScalRA::OutScalRA (double * theDoublePtr):
d130 1
a130 1
      RealArg     (true),
d137 1
a137 1
OutScalRA::OutScalRA (const OutScalRA & theOutScalRA):
d139 1
a139 1
      RealArg     (theOutScalRA),
d146 1
a146 1
OutScalRA::~OutScalRA ()
d152 1
a152 1
void OutScalRA::setTo (double theValue)
d162 1
a162 1
double OutScalRA::appVarVal () const
d169 1
@


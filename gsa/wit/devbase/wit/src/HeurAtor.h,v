head	1.116;
access;
symbols
	sce_5_01_20080919:1.95
	latest_sce_4_20_20060523:1.87.0.2
	sce_4_20_20060523:1.87
	latest_sce4_20_OSL:1.86.0.2
	sce_4_20_OSL:1.86
	sce_410_withVa:1.85
	sce_4_05_20040511:1.75
	sce_4_00_20040201:1.74
	nextGenBranch:1.73.0.2
	nextGenRoot:1.73
	sce_3_30_20030627:1.73
	EndRw-branch:1.46.0.2
	Root-of-EndRw:1.46
	rwToStl:1.44.0.2
	latest_sce_3_10_20010924:1.14.0.2
	sce_3_10_20010924:1.14;
locks; strict;
comment	@ * @;


1.116
date	2011.09.28.23.49.25;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2011.09.24.00.27.44;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2011.08.30.20.17.33;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2010.09.24.18.17.21;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2010.09.24.00.16.26;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2010.09.13.21.13.20;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.10.23.22.43;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.10.23.17.47;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2010.09.10.22.10.38;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2010.09.10.20.12.07;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2010.09.10.16.03.50;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2010.09.07.23.50.34;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2010.09.02.18.58.24;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2010.09.01.20.25.24;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2010.08.12.23.18.15;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2010.06.18.23.11.14;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.18.16.26.07;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2010.06.18.14.41.17;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.06.17.22.04.44;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.17.16.17.14;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.16.21.41.26;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.11.12.16.30.12;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.09.00.40.47;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.02.28.20.04.57;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.02.27.19.59.31;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.02.10.00.08.14;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.08.22.47.34;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2006.09.27.22.17.33;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2006.09.27.20.10.16;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2006.05.02.17.34.00;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2005.03.10.21.11.24;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2005.03.02.23.56.51;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2005.02.03.21.20.29;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2005.01.31.23.59.29;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2005.01.19.23.50.58;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.01.11.21.07.58;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.01.10.22.34.47;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2004.12.23.17.24.20;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.12.06.22.38.15;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.08.16.15.55.34;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.03.24.22.21.31;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2003.12.15.23.22.31;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2003.05.02.18.26.46;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2003.05.01.22.42.31;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2003.04.30.21.07.47;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2003.04.29.14.27.45;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2003.04.21.17.11.07;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2003.04.17.23.34.19;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2003.04.14.23.31.39;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2003.04.11.19.08.25;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2003.04.01.22.39.33;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2003.04.01.20.34.25;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2003.03.21.23.36.50;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2003.03.19.16.48.17;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2003.03.06.20.28.18;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2003.03.03.21.07.27;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2003.03.01.01.17.30;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.02.28.20.47.34;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.02.27.19.20.18;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.02.26.23.51.31;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.26.21.42.53;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.02.24.23.44.31;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.02.21.18.56.25;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.02.16.23.58.10;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.01.31.21.28.54;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.01.29.19.16.46;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.01.02.22.18.29;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2002.12.24.22.50.47;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2002.12.17.21.32.46;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2002.11.21.22.53.55;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.15.20.27.08;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.10.30.23.47.30;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.10.17.19.11.08;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.04.21.26.28;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.19.16.10.49;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.12.23.36.13;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.11.22.48.28;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.09.19.52.32;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.06.18.53.38;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.05.19.31.32;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.17.21.45.02;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.16.23.32.06;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.13.21.31.39;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.10.18.02.11;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.08.19.21.51;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.07.20.14.57;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.18.14.02.34;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.12.21.01.59;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.03.16.34.55;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.22.21.23.21;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.12.01.08.45;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.10.22.06.53;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.28.18.09.15;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.27.23.15.39;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.17.16.25.41;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.01.00.25.40;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.07.23.03.55;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.05.20.53.57;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.05.18.55.27;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.03.18.55.11;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.28.00.12.58;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.19.18.50.57;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.16.21.42.30;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.12.21.19.51;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.04.15.44.37;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.27.21.12.13;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.17.22.00.09;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.14.20.43.54;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.06.17.31.07;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.03.18.40.42;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.14.55.30;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.30.15.12.10;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.28.00.48.34;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.27.21.28.39;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.25.16.08.16;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.116
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef HeurAtorH
#define HeurAtorH

//------------------------------------------------------------------------------
// Header file: "HeurAtor.h"
//
// Contains the declaration of class HeurAtor.
//------------------------------------------------------------------------------

#include <Demand.h>
#include <Operation.h>
#include <SubEntry.h>
#include <Schedule.h>
#include <Mapping.h>

//------------------------------------------------------------------------------
// class HeurAtor
//
// This class is responsible for actually performing a heuristic allocation.
// An instance of this class exists only when heuristic allocation is active.
//------------------------------------------------------------------------------

class WitHeurAtor: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitHeurAtor (WitProblem *, WitPegger *, bool forOpt);
         //
         // forOpt == true indicates heur allocation is for opt implosion.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitHeurAtor ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      double incHeurAlloc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            double      desIncVol,
            bool        asapMultiExec);
         //
         // Performs a heuristic allocation.
         // See HeurAllMgr::inc for argument meanings.

      void enforceStockSLBs ();
         //
         // Enforces stock soft lower bounds.

      void commitMaxQtySel (double & netQty);
         //
         // Commits the heuristically maximum possible quantity of topPart_ 
         // in topPer_, for a given selection configuration.

      bool tempCommit (double qty);
         //
         // Calls commit on temp data.
         // Returns true iff the commit attempt succeeded.

      void permCommit1SS ();
         //
         // Does a perm-commit of 1 unit for selection splitting purposes.
         // Valid only in sel-split mode.

      bool incAvailPos (WitPart * thePart, WitPeriod thePer);
         //
         // Returns true, iff there is positive incremental availability of
         // thePart in thePer.

      bool selectiveSR (WitMaterial *);
         //
         // See AvailSched.

      void saveVal (int    & theVar);
      void saveVal (double & theVar);
         //
         // Saves the current value of theVar.

      void saveExecVol (WitOperation * theOpn, WitPeriod thePer);
         //
         // Saves the execVol for theOpn in thePer.

      void saveSubVol (WitSubEntry * theSub, WitPeriod thePer);
         //
         // Saves the subVol for theSub in thePer.

      void printAvailSched ();
         //
         // Prints the availability schedule.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool,   buildAhead)
      accessFunc (int,    ltbMinPer)
      accessFunc (bool,   tempCommActive)
      accessFunc (bool,   permCommActive)
      accessFunc (bool,   failedOn1)
      accessFunc (bool,   userHeurStart)
      accessFunc (double, searchInc)
                                  
      accessNonNull (WitHeurModifier *, myHeurModifier)
      accessNonNull (WitSelector *,     mySelector)
      accessNonNull (WitPart *,         topPart)
      accessNonNull (WitSsrMgr *,       mySsrMgr)

      inline bool multiSel () 
         {
         return (mySelector_ != NULL);
         }

      inline WitPeriod topPer ()
         {
         witAssert (topPer_ >= 0);

         return topPer_;
         }

      inline const WitMapping <WitBomEntry, bool> & hasSubsToNet ()
         {
         return hasSubsToNet_;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitHeurAtor);

      void initBlocked ();
         //
         // Initializes blocked_.

      void setUpSelection ();
         //
         // Sets up the Selection Subsystem, as needed.

      void initSoln ();
         //
         // Initializes the implosion solution.

      void compLeadTimeBounds ();
         //
         // Computes and sets the value of leadTimeBounds_.

      void setUpLeadTimeBounds ();
         //
         // Sets up the lead time bounds capability.

      double compDemandedIncVol (
            WitDemand * theDemand,
            WitPeriod   thePer,
            double      desIncVol);
         //
         // Computes and returns the portion of desIncVol that's demanded for
         // theDemand in thePer.

      double minUnmetCumDem (WitDemand * theDemand, WitPeriod thePer);
         //
         // Computes and returns the min value of cumDemandVol - cumShipVol over
         // {thePer, ..., nPeriods - 1}

      void preIncHeurAlloc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            bool        asapMultiExec);
         //
         // Takes actions appropriate at the beginning of incHeurAlloc.

      void doBaByDemand (
            WitDemand * theDemand, 
            WitPeriod   lastPer,
            double &    netQty);
         //
         // Does build-ahead by demand and theDemand in lastPer and earlier
         // periods.

      void postIncHeurAlloc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            double      desIncVol,
            double      incVol);
         //
         // Takes actions appropriate at the conclusion of incHeurAlloc.

      void enforceStockSLBs (WitPart * thePart);
         //
         // Enforces the stock soft lower bounds for thePart in all periods.

      void enforceStockSLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Enforces the stock soft lower bound for theMat in thePer.
         // This function assumes that none of theMat's stockVol in thePer has
         // already been reserved for stock softLBs. Thus this function should
         // only be called once for each Material and period.

      void commitMaxQty (WitPart * thePart, WitPeriod thePer, double & netQty);
         //
         // Commits the heuristically maximum possible quantity of thePart in
         // thePer, considering multiple selections, if appropriate.

      void permCommit (double qty);
         //
         // Calls commit on perm data.
         // Verifies that the commit attempt succeeded.

      double findMaxQty (double desQty);
         //
         // Determines the heuristic maximum lotsize-feasible quantity of
         // topPart_ that is <= desQty and can be made in topPer_.
         // The search considers only lotsize feasible quantities.
         // If the minimum lot-sized quantity is not feasible, 0.0 is returned.
         // Otherwise, if the desired quantity is feasible, it is returned.
         // Otherwise the max quantity is found by a binary search.

      double binarySearch (double incQty);
         //
         // Does the binary search aspect of findMaxQty, where 1.0 is assumed
         // feasible and desQty is assumed infeasible.

      bool commit (double qty);
         //
         // Attempts to commit qty units of topPart () to a shipment in 
         // topPer (). 
         // Returns true iff the attempt succeeded.

      bool innerCommit (double qty);
         //
         // Does most of the work for commit.

      bool fillReq (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    theReqVol);
         //
         // Attempts to meet theReqVol units of requirement of thePart in
         // fillPer. Returns true iff the attempt succeeded.

      bool fillNetReq (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    theReqVol);
         //
         // Attempts to meet theReqVol units of requirement of thePart in
         // fillPer by explosion. Returns true iff the attempt succeeded.

      bool fillNetReqBASS (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    netReqVol);
         //
         // Similar to fillNetReq.
         // Valid only in sel-split mode.

      bool explodePart (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Attempts to explode expVol units thru thePart in period expPer, to
         // fill demand in fillPer. 
         // Returns true iff the explosion was successful.

      bool explodePartSS (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Performs selection-split explosions of expVol units of thePart 
         // in expPer in order to meet requirements in fillPer.
         // Valid only in sel-split mode.

      bool explodePartPRSS (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Explodes expVol units of thePart in expPer in order to meet
         // requirements in fillPer, for prop-routing selection splitting.

      bool explodePartMRSS (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Explodes expVol units of thePart in expPer in order to meet
         // requirements in fillPer, for multi-route selection splitting.

      bool explodePartPR (
            WitPart * thePart,
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Performs a proportionate explosion of expVol units of thePart 
         // in expPer in order to meet requirements in fillPer.
         // Valid only in proportionate routing mode.

      bool explodeBopEntSS (
            WitBopEntry * theBopEnt,
            WitPeriod     expPer,
            double        expVol,
            WitPeriod     fillPer);
         //
         // Explodes theBopEnt in expPer.
         // Valid only in sel-split mode.

      bool explodeBopEntMESS (
            WitBopEntry * theBopEnt,
            WitPeriod     expPer,
            double        expVol,
            WitPeriod     fillPer);
         //
         // Explodes theBopEnt in expPer, using sel-split for multi-exec.

      bool explodeBopEnt (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        qty,
            WitPeriod     fillPer);
         //
         // Attempts to explode qty units thru theBopEnt by executing in period
         // execPer, to fill demand in fillPer. 
         // Returns true iff the explosion was successful.

      bool checkExecBound (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        oldExecVol,
            double        deltaExecVol,
            WitPeriod     fillPer);
         //
         // Returns true, iff exploding thru theBopEnt by increasing
         // the Operation's execVol in execPer from oldExecVol by deltaExecVol,
         // to fill demand in fillPer would satisfy the appropriate upper bound
         // on execVol.  
         // In the false case, records the failure, if appropriate.

      void recClShortage (WitPart * thePart, WitPeriod fillPer);
         //
         // Records a shortage of thePart in fillPer for the critical list and
         // the pegged critical list.

      void innerExplodeBopEnt (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        qty,
            double        deltaExecVol,
            WitPeriod     fillPer);
         //
         // Explodes qty units thru theBopEnt by executing deltaExecVol units in
         // execPer, to fill demand in fillPer. 

      void explodeBopEntries (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        deltaExecVol);
         //
         // Does the BopEntry accounting for exploding deltaExecVol units 
         // through theBopEnt in execPer.

      void netAndRollReq (
            WitMaterial * theMat,
            WitPeriod     thePer,
            double &      netReqVol,
            bool &        bddSsrSplit);
         //
         // Nets netReqVol for against the availability of theMat in thePer 
         // and rolls netted amount to the next period. If the rollVol is for a
         // bounded split of SSR, sets bddSsrSplit to true.
         // Valid only in stock reallocation mode.

      void explodeBomEntry (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Explodes deltaExecVol units along theBomEnt in exec period execPer,
         // for filling demand in fillPer, exploding thru theBopEnt.

      void explodeBomEntryMRSS (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Explodes deltaExecVol units along theBomEnt in execPer, for filling
         // demand in fillPer, exploding thru theBopEnt, for multi-route
         // selection splitting.

      void netConsEntries (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double &      netExecQty,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Nets the requirement for theBomEnt using both theBomEnt and
         // its SubEntries.

      void netSubEntry (
            WitSubEntry * theSub,
            WitPeriod     execPer,
            double &      netExecQty,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Nets the requirement of an Operation along a SubEntry.

      void netConsEntry (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double &       netExecQty,
            WitPeriod      fillPer,
            WitBopEntry *  theBopEnt);
         //
         // Nets the requirement of an Operation along a ConsEntry.

      void explodeBomEntryPRSS (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Does a split proportionate explosion of deltaExecVol units along
         // theBomEnt in exec period execPer, filling demand in fillPer,
         // exploding thru theBopEnt.

      void explodeBomEntryPR (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Does a proportionate explosion of deltaExecVol units along theBomEnt
         // in exec period execPer, filling demand in fillPer, exploding thru
         // theBopEnt.

      void explodeConsEntry (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double         netExecQty,
            WitPeriod      fillPer,
            WitBopEntry *  theBopEnt);
         //
         // Explodes netExecQty units along theConsEnt in exec period execPer
         // for filling demand in fillPer, exploding thru theBopEnt.

      void explodeSub (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double         netExecQty);
         //
         // Performs whatever additional actions are appropriate for exploding
         // netExecQty units thru theConsEnt in execPer, when theConsEnt is a
         // SubEntry, if necessary.

      inline bool critListMode () 
         {
         return (myHeurCritList_ != NULL);
         }

      inline bool pclMode () 
         {
         return (myPclBldr_ != NULL);
         }

      WitBopEntry * expBopEntry (WitPart * thePart, WitPeriod expPer);
         //
         // Returns the BopEntry to be used for explosions in order to produce
         // thePart in expPer.

      WitPeriod execPerFor (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Returns the execution period to be used when exploding through 
         // theBopEnt in expPer.

      //------------------------------------------------------------------------

      accessNonNull (WitHeurCritList *, myHeurCritList)
      accessNonNull (WitPclBldr *,      myPclBldr)
      accessNonNull (WitMrMgr *,        myMrMgr)
      accessNonNull (WitPrMgr *,        myPrMgr)
      accessNonNull (WitBaMgr *,        myBaMgr)
      accessNonNull (WitMeMgr *,        myMeMgr)
      accessNonNull (WitPenExMgr *,     myPenExMgr)
      accessNonNull (WitSglSrcMgr *,    mySglSrcMgr)

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitAvailSched * myAvailSched_;
         //
         // The AvailSched owned by this HeurAtor.

      WitReqSched * myReqSched_;
         //
         // The requirement schedule for this HeurAtor.

      WitHeurCritList * myHeurCritList_;
         //
         // The HeurCritList owned by this HeurAtor, if any; otherwise NULL.

      WitPclBldr * myPclBldr_;
         //
         // The PclBldr owned by this HeurAtor in pegged crit list mode;
         // otherwise NULL.

      WitHeurModifier * myHeurModifier_;
         //
         // The HeurModifier owned by this HeurAtor, during modifiable heuristic
         // allocation; otherwise NULL.

      WitSelector * mySelector_;
         //
         // The Selector owned by this HeurAtor, if any; otherwise NULL.

      WitMrMgr * myMrMgr_;
         //
         // The MrMgr associated with this HeurAtor, if multiRoute_ is true;
         // otherwise NULL.

      WitPrMgr * myPrMgr_;
         //
         // The PrMgr associated with this HeurAtor, in new propRtg mode;
         // otherwise NULL.

      WitBaMgr * myBaMgr_;
         //
         // The BaMgr associated with this HeurAtor, if buildAhead_ is true;
         // otherwise NULL.

      WitMeMgr * myMeMgr_;
         //
         // The MeMgr associated with this HeurAtor, if multiExec_ is true;
         // otherwise NULL.

      WitSsrMgr * mySsrMgr_;
         //
         // The SsrMgr associated with this HeurAtor, if any; otherwise NULL.

      WitPenExMgr * myPenExMgr_;
         //
         // The PenExMgr associated with this HeurAtor, if penExec_ is true;
         // otherwise NULL.

      WitSglSrcMgr * mySglSrcMgr_;
         //
         // The SglSrcMgr associated with this HeurAtor, if sglSrc_ is
         // true; otherwise NULL.
 
      WitPegger * myPegger_;
         //
         // The Pegger for this HeurAtor, if perfPegging_ is true; 
         // otherwise NULL.

      WitDataRepos * tempCommRepos_;
         //
         // Saves values during a temp commit.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      bool multiRoute_;
         //
         // true, iff the multiple routes technique is to be performed.

      bool buildAhead_;
         //
         // true, iff build-ahead by Material is to be performed.

      bool multiExec_;
         //
         // true, iff the multiple execution periods technique is to be 
         // performed.

      bool penExec_;
         //
         // true, iff penalized execution is to be performed.

      bool selSplit_;
         //
         // true, iff selection splitting is to be performed.

      bool sglSrc_;
         //
         // true, iff new single-source is to be performed.

      bool perfPegging_;
         //
         // true, iff pegging is to be performed.

      bool userHeurStart_;
         //
         // true, iff user-specified heuristic starting solution is to be used.

      bool finiteExecBounds_;
         //
         // true, iff myProblem () includes any execBounds with finite hardUBs.

      bool leadTimeBounds_;
         //
         // true, iff the lead time bounds capability is to be used.

      int ltbMinPer_;
         //
         // If leadTimeBounds_ is true, then ltbMinPer_ is the earliest period
         // eligible for explosion in the current incHeurAlloc.

      bool tempCommActive_;
         //
         // true, iff heuristic allocation is currently performing a temp
         // commit.

      bool permCommActive_;
         //
         // true, iff heuristic allocation is currently performing a perm
         // commit.

      WitSchedule <WitPart, WitPeriod> blocked_;
         //
         // blocked_ (thePart)[thePer] is true, iff an attempt to meet external
         // demand for thePart in thePer has failed.
         // Only allocated for Parts with positive demand.

      WitMapping <WitBomEntry, bool> hasSubsToNet_;
         //
         // hasSubsToNet_ (theBomEnt) is true, iff theBomEnt has at least one
         // substitute for which netAllowed is true.

      double searchInc_;
         //
         // Search increment for the current Demand, if any;
         // otherwise 1.0.

      WitPart * topPart_;
         //
         // The Part for which commitMaxQty was called, if any, else NULL.

      WitPeriod topPer_;
         //
         // The Period for which commitMaxQty was called, if any, else -1.

      int nMaxCommits_;
         //
         // # calls to commitMaxQty.

      int nSelCommits_;
         //
         // # calls to commitMaxQtySel.

      int nBsearches_;
         //
         // # binary searches.

      int nTempComms_;
      int nPermComms_;
      int nComms_;
         //
         // # calls to:
         //    tempCommit
         //    permCommit
         //    commit

      bool failedOn1_;
         //
         // true, iff the final failing temp-commit was for one unit.
   };

#endif
@


1.115
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.114
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d33 2
a34 2
{
public:
d36 668
a703 668
//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitHeurAtor (WitProblem *, WitPegger *, bool forOpt);
//
// forOpt == true indicates heur allocation is for opt implosion.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitHeurAtor ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

double incHeurAlloc (
WitDemand * theDemand,
WitPeriod   thePer,
double      desIncVol,
bool        asapMultiExec);
//
// Performs a heuristic allocation.
// See HeurAllMgr::inc for argument meanings.

void enforceStockSLBs ();
//
// Enforces stock soft lower bounds.

void commitMaxQtySel (double & netQty);
//
// Commits the heuristically maximum possible quantity of topPart_
// in topPer_, for a given selection configuration.

bool tempCommit (double qty);
//
// Calls commit on temp data.
// Returns true iff the commit attempt succeeded.

void permCommit1SS ();
//
// Does a perm-commit of 1 unit for selection splitting purposes.
// Valid only in sel-split mode.

bool incAvailPos (WitPart * thePart, WitPeriod thePer);
//
// Returns true, iff there is positive incremental availability of
// thePart in thePer.

bool selectiveSR (WitMaterial *);
//
// See AvailSched.

void saveVal (int    & theVar);
void saveVal (double & theVar);
//
// Saves the current value of theVar.

void saveExecVol (WitOperation * theOpn, WitPeriod thePer);
//
// Saves the execVol for theOpn in thePer.

void saveSubVol (WitSubEntry * theSub, WitPeriod thePer);
//
// Saves the subVol for theSub in thePer.

void printAvailSched ();
//
// Prints the availability schedule.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

accessFunc (bool,   buildAhead)
accessFunc (int,    ltbMinPer)
accessFunc (bool,   tempCommActive)
accessFunc (bool,   permCommActive)
accessFunc (bool,   failedOn1)
accessFunc (bool,   userHeurStart)
accessFunc (double, searchInc)

accessNonNull (WitHeurModifier *, myHeurModifier)
accessNonNull (WitSelector *,     mySelector)
accessNonNull (WitPart *,         topPart)
accessNonNull (WitSsrMgr *,       mySsrMgr)

inline bool multiSel ()
{
return (mySelector_ != NULL);
}

inline WitPeriod topPer ()
{
witAssert (topPer_ >= 0);

return topPer_;
}

inline const WitMapping <WitBomEntry, bool> & hasSubsToNet ()
{
return hasSubsToNet_;
}

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitHeurAtor);

void initBlocked ();
//
// Initializes blocked_.

void setUpSelection ();
//
// Sets up the Selection Subsystem, as needed.

void initSoln ();
//
// Initializes the implosion solution.

void compLeadTimeBounds ();
//
// Computes and sets the value of leadTimeBounds_.

void setUpLeadTimeBounds ();
//
// Sets up the lead time bounds capability.

double compDemandedIncVol (
WitDemand * theDemand,
WitPeriod   thePer,
double      desIncVol);
//
// Computes and returns the portion of desIncVol that's demanded for
// theDemand in thePer.

double minUnmetCumDem (WitDemand * theDemand, WitPeriod thePer);
//
// Computes and returns the min value of cumDemandVol - cumShipVol over
// {thePer, ..., nPeriods - 1}

void preIncHeurAlloc (
WitDemand * theDemand,
WitPeriod   thePer,
bool        asapMultiExec);
//
// Takes actions appropriate at the beginning of incHeurAlloc.

void doBaByDemand (
WitDemand * theDemand,
WitPeriod   lastPer,
double &    netQty);
//
// Does build-ahead by demand and theDemand in lastPer and earlier
// periods.

void postIncHeurAlloc (
WitDemand * theDemand,
WitPeriod   thePer,
double      desIncVol,
double      incVol);
//
// Takes actions appropriate at the conclusion of incHeurAlloc.

void enforceStockSLBs (WitPart * thePart);
//
// Enforces the stock soft lower bounds for thePart in all periods.

void enforceStockSLB (WitMaterial * theMat, WitPeriod thePer);
//
// Enforces the stock soft lower bound for theMat in thePer.
// This function assumes that none of theMat's stockVol in thePer has
// already been reserved for stock softLBs. Thus this function should
// only be called once for each Material and period.

void commitMaxQty (WitPart * thePart, WitPeriod thePer, double & netQty);
//
// Commits the heuristically maximum possible quantity of thePart in
// thePer, considering multiple selections, if appropriate.

void permCommit (double qty);
//
// Calls commit on perm data.
// Verifies that the commit attempt succeeded.

double findMaxQty (double desQty);
//
// Determines the heuristic maximum lotsize-feasible quantity of
// topPart_ that is <= desQty and can be made in topPer_.
// The search considers only lotsize feasible quantities.
// If the minimum lot-sized quantity is not feasible, 0.0 is returned.
// Otherwise, if the desired quantity is feasible, it is returned.
// Otherwise the max quantity is found by a binary search.

double binarySearch (double incQty);
//
// Does the binary search aspect of findMaxQty, where 1.0 is assumed
// feasible and desQty is assumed infeasible.

bool commit (double qty);
//
// Attempts to commit qty units of topPart () to a shipment in
// topPer ().
// Returns true iff the attempt succeeded.

bool innerCommit (double qty);
//
// Does most of the work for commit.

bool fillReq (
WitPart * thePart,
WitPeriod fillPer,
double    theReqVol);
//
// Attempts to meet theReqVol units of requirement of thePart in
// fillPer. Returns true iff the attempt succeeded.

bool fillNetReq (
WitPart * thePart,
WitPeriod fillPer,
double    theReqVol);
//
// Attempts to meet theReqVol units of requirement of thePart in
// fillPer by explosion. Returns true iff the attempt succeeded.

bool fillNetReqBASS (
WitPart * thePart,
WitPeriod fillPer,
double    netReqVol);
//
// Similar to fillNetReq.
// Valid only in sel-split mode.

bool explodePart (
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer);
//
// Attempts to explode expVol units thru thePart in period expPer, to
// fill demand in fillPer.
// Returns true iff the explosion was successful.

bool explodePartSS (
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer);
//
// Performs selection-split explosions of expVol units of thePart
// in expPer in order to meet requirements in fillPer.
// Valid only in sel-split mode.

bool explodePartPRSS (
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer);
//
// Explodes expVol units of thePart in expPer in order to meet
// requirements in fillPer, for prop-routing selection splitting.

bool explodePartMRSS (
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer);
//
// Explodes expVol units of thePart in expPer in order to meet
// requirements in fillPer, for multi-route selection splitting.

bool explodePartPR (
WitPart * thePart,
WitPeriod expPer,
double    expVol,
WitPeriod fillPer);
//
// Performs a proportionate explosion of expVol units of thePart
// in expPer in order to meet requirements in fillPer.
// Valid only in proportionate routing mode.

bool explodeBopEntSS (
WitBopEntry * theBopEnt,
WitPeriod     expPer,
double        expVol,
WitPeriod     fillPer);
//
// Explodes theBopEnt in expPer.
// Valid only in sel-split mode.

bool explodeBopEntMESS (
WitBopEntry * theBopEnt,
WitPeriod     expPer,
double        expVol,
WitPeriod     fillPer);
//
// Explodes theBopEnt in expPer, using sel-split for multi-exec.

bool explodeBopEnt (
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        qty,
WitPeriod     fillPer);
//
// Attempts to explode qty units thru theBopEnt by executing in period
// execPer, to fill demand in fillPer.
// Returns true iff the explosion was successful.

bool checkExecBound (
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        oldExecVol,
double        deltaExecVol,
WitPeriod     fillPer);
//
// Returns true, iff exploding thru theBopEnt by increasing
// the Operation's execVol in execPer from oldExecVol by deltaExecVol,
// to fill demand in fillPer would satisfy the appropriate upper bound
// on execVol.
// In the false case, records the failure, if appropriate.

void recClShortage (WitPart * thePart, WitPeriod fillPer);
//
// Records a shortage of thePart in fillPer for the critical list and
// the pegged critical list.

void innerExplodeBopEnt (
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        qty,
double        deltaExecVol,
WitPeriod     fillPer);
//
// Explodes qty units thru theBopEnt by executing deltaExecVol units in
// execPer, to fill demand in fillPer.

void explodeBopEntries (
WitBopEntry * theBopEnt,
WitPeriod     execPer,
double        deltaExecVol);
//
// Does the BopEntry accounting for exploding deltaExecVol units
// through theBopEnt in execPer.

void netAndRollReq (
WitMaterial * theMat,
WitPeriod     thePer,
double &      netReqVol,
bool &        bddSsrSplit);
//
// Nets netReqVol for against the availability of theMat in thePer
// and rolls netted amount to the next period. If the rollVol is for a
// bounded split of SSR, sets bddSsrSplit to true.
// Valid only in stock reallocation mode.

void explodeBomEntry (
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol,
WitPeriod     fillPer,
WitBopEntry * theBopEnt);
//
// Explodes deltaExecVol units along theBomEnt in exec period execPer,
// for filling demand in fillPer, exploding thru theBopEnt.

void explodeBomEntryMRSS (
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol,
WitPeriod     fillPer,
WitBopEntry * theBopEnt);
//
// Explodes deltaExecVol units along theBomEnt in execPer, for filling
// demand in fillPer, exploding thru theBopEnt, for multi-route
// selection splitting.

void netConsEntries (
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double &      netExecQty,
WitPeriod     fillPer,
WitBopEntry * theBopEnt);
//
// Nets the requirement for theBomEnt using both theBomEnt and
// its SubEntries.

void netSubEntry (
WitSubEntry * theSub,
WitPeriod     execPer,
double &      netExecQty,
WitPeriod     fillPer,
WitBopEntry * theBopEnt);
//
// Nets the requirement of an Operation along a SubEntry.

void netConsEntry (
WitConsEntry * theConsEnt,
WitPeriod      execPer,
double &       netExecQty,
WitPeriod      fillPer,
WitBopEntry *  theBopEnt);
//
// Nets the requirement of an Operation along a ConsEntry.

void explodeBomEntryPRSS (
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol,
WitPeriod     fillPer,
WitBopEntry * theBopEnt);
//
// Does a split proportionate explosion of deltaExecVol units along
// theBomEnt in exec period execPer, filling demand in fillPer,
// exploding thru theBopEnt.

void explodeBomEntryPR (
WitBomEntry * theBomEnt,
WitPeriod     execPer,
double        deltaExecVol,
WitPeriod     fillPer,
WitBopEntry * theBopEnt);
//
// Does a proportionate explosion of deltaExecVol units along theBomEnt
// in exec period execPer, filling demand in fillPer, exploding thru
// theBopEnt.

void explodeConsEntry (
WitConsEntry * theConsEnt,
WitPeriod      execPer,
double         netExecQty,
WitPeriod      fillPer,
WitBopEntry *  theBopEnt);
//
// Explodes netExecQty units along theConsEnt in exec period execPer
// for filling demand in fillPer, exploding thru theBopEnt.

void explodeSub (
WitConsEntry * theConsEnt,
WitPeriod      execPer,
double         netExecQty);
//
// Performs whatever additional actions are appropriate for exploding
// netExecQty units thru theConsEnt in execPer, when theConsEnt is a
// SubEntry, if necessary.

inline bool critListMode ()
{
return (myHeurCritList_ != NULL);
}

inline bool pclMode ()
{
return (myPclBldr_ != NULL);
}

WitBopEntry * expBopEntry (WitPart * thePart, WitPeriod expPer);
//
// Returns the BopEntry to be used for explosions in order to produce
// thePart in expPer.

WitPeriod execPerFor (WitBopEntry * theBopEnt, WitPeriod expPer);
//
// Returns the execution period to be used when exploding through
// theBopEnt in expPer.

//------------------------------------------------------------------------

accessNonNull (WitHeurCritList *, myHeurCritList)
accessNonNull (WitPclBldr *,      myPclBldr)
accessNonNull (WitMrMgr *,        myMrMgr)
accessNonNull (WitPrMgr *,        myPrMgr)
accessNonNull (WitBaMgr *,        myBaMgr)
accessNonNull (WitMeMgr *,        myMeMgr)
accessNonNull (WitPenExMgr *,     myPenExMgr)
accessNonNull (WitSglSrcMgr *,    mySglSrcMgr)

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Associations.
//------------------------------------------------------------------------

WitAvailSched * myAvailSched_;
//
// The AvailSched owned by this HeurAtor.

WitReqSched * myReqSched_;
//
// The requirement schedule for this HeurAtor.

WitHeurCritList * myHeurCritList_;
//
// The HeurCritList owned by this HeurAtor, if any; otherwise NULL.

WitPclBldr * myPclBldr_;
//
// The PclBldr owned by this HeurAtor in pegged crit list mode;
// otherwise NULL.

WitHeurModifier * myHeurModifier_;
//
// The HeurModifier owned by this HeurAtor, during modifiable heuristic
// allocation; otherwise NULL.

WitSelector * mySelector_;
//
// The Selector owned by this HeurAtor, if any; otherwise NULL.

WitMrMgr * myMrMgr_;
//
// The MrMgr associated with this HeurAtor, if multiRoute_ is true;
// otherwise NULL.

WitPrMgr * myPrMgr_;
//
// The PrMgr associated with this HeurAtor, in new propRtg mode;
// otherwise NULL.

WitBaMgr * myBaMgr_;
//
// The BaMgr associated with this HeurAtor, if buildAhead_ is true;
// otherwise NULL.

WitMeMgr * myMeMgr_;
//
// The MeMgr associated with this HeurAtor, if multiExec_ is true;
// otherwise NULL.

WitSsrMgr * mySsrMgr_;
//
// The SsrMgr associated with this HeurAtor, if any; otherwise NULL.

WitPenExMgr * myPenExMgr_;
//
// The PenExMgr associated with this HeurAtor, if penExec_ is true;
// otherwise NULL.

WitSglSrcMgr * mySglSrcMgr_;
//
// The SglSrcMgr associated with this HeurAtor, if sglSrc_ is
// true; otherwise NULL.

WitPegger * myPegger_;
//
// The Pegger for this HeurAtor, if perfPegging_ is true;
// otherwise NULL.

WitDataRepos * tempCommRepos_;
//
// Saves values during a temp commit.

//------------------------------------------------------------------------
// Other private member data.
//------------------------------------------------------------------------

bool multiRoute_;
//
// true, iff the multiple routes technique is to be performed.

bool buildAhead_;
//
// true, iff build-ahead by Material is to be performed.

bool multiExec_;
//
// true, iff the multiple execution periods technique is to be
// performed.

bool penExec_;
//
// true, iff penalized execution is to be performed.

bool selSplit_;
//
// true, iff selection splitting is to be performed.

bool sglSrc_;
//
// true, iff new single-source is to be performed.

bool perfPegging_;
//
// true, iff pegging is to be performed.

bool userHeurStart_;
//
// true, iff user-specified heuristic starting solution is to be used.

bool finiteExecBounds_;
//
// true, iff myProblem () includes any execBounds with finite hardUBs.

bool leadTimeBounds_;
//
// true, iff the lead time bounds capability is to be used.

int ltbMinPer_;
//
// If leadTimeBounds_ is true, then ltbMinPer_ is the earliest period
// eligible for explosion in the current incHeurAlloc.

bool tempCommActive_;
//
// true, iff heuristic allocation is currently performing a temp
// commit.

bool permCommActive_;
//
// true, iff heuristic allocation is currently performing a perm
// commit.

WitSchedule <WitPart, WitPeriod> blocked_;
//
// blocked_ (thePart)[thePer] is true, iff an attempt to meet external
// demand for thePart in thePer has failed.
// Only allocated for Parts with positive demand.

WitMapping <WitBomEntry, bool> hasSubsToNet_;
//
// hasSubsToNet_ (theBomEnt) is true, iff theBomEnt has at least one
// substitute for which netAllowed is true.

double searchInc_;
//
// Search increment for the current Demand, if any;
// otherwise 1.0.

WitPart * topPart_;
//
// The Part for which commitMaxQty was called, if any, else NULL.

WitPeriod topPer_;
//
// The Period for which commitMaxQty was called, if any, else -1.

int nMaxCommits_;
//
// # calls to commitMaxQty.

int nSelCommits_;
//
// # calls to commitMaxQtySel.

int nBsearches_;
//
// # binary searches.

int nTempComms_;
int nPermComms_;
int nComms_;
//
// # calls to:
//    tempCommit
//    permCommit
//    commit

bool failedOn1_;
//
// true, iff the final failing temp-commit was for one unit.
};
@


1.113
log
@Modifiable heuristic allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d33 2
a34 2
   {
   public:
d36 668
a703 668
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitHeurAtor (WitProblem *, WitPegger *, bool forOpt);
         //
         // forOpt == true indicates heur allocation is for opt implosion.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitHeurAtor ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      double incHeurAlloc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            double      desIncVol,
            bool        asapMultiExec);
         //
         // Performs a heuristic allocation.
         // See HeurAllMgr::inc for argument meanings.

      void enforceStockSLBs ();
         //
         // Enforces stock soft lower bounds.

      void commitMaxQtySel (double & netQty);
         //
         // Commits the heuristically maximum possible quantity of topPart_ 
         // in topPer_, for a given selection configuration.

      bool tempCommit (double qty);
         //
         // Calls commit on temp data.
         // Returns true iff the commit attempt succeeded.

      void permCommit1SS ();
         //
         // Does a perm-commit of 1 unit for selection splitting purposes.
         // Valid only in sel-split mode.

      bool incAvailPos (WitPart * thePart, WitPeriod thePer);
         //
         // Returns true, iff there is positive incremental availability of
         // thePart in thePer.

      bool selectiveSR (WitMaterial *);
         //
         // See AvailSched.

      void saveVal (int    & theVar);
      void saveVal (double & theVar);
         //
         // Saves the current value of theVar.

      void saveExecVol (WitOperation * theOpn, WitPeriod thePer);
         //
         // Saves the execVol for theOpn in thePer.

      void saveSubVol (WitSubEntry * theSub, WitPeriod thePer);
         //
         // Saves the subVol for theSub in thePer.

      void printAvailSched ();
         //
         // Prints the availability schedule.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (bool,   buildAhead)
      accessFunc (int,    ltbMinPer)
      accessFunc (bool,   tempCommActive)
      accessFunc (bool,   permCommActive)
      accessFunc (bool,   failedOn1)
      accessFunc (bool,   userHeurStart)
      accessFunc (double, searchInc)
                                  
      accessNonNull (WitHeurModifier *, myHeurModifier)
      accessNonNull (WitSelector *,     mySelector)
      accessNonNull (WitPart *,         topPart)
      accessNonNull (WitSsrMgr *,       mySsrMgr)

      inline bool multiSel () 
         {
         return (mySelector_ != NULL);
         }

      inline WitPeriod topPer ()
         {
         witAssert (topPer_ >= 0);

         return topPer_;
         }

      inline const WitMapping <WitBomEntry, bool> & hasSubsToNet ()
         {
         return hasSubsToNet_;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitHeurAtor);

      void initBlocked ();
         //
         // Initializes blocked_.

      void setUpSelection ();
         //
         // Sets up the Selection Subsystem, as needed.

      void initSoln ();
         //
         // Initializes the implosion solution.

      void compLeadTimeBounds ();
         //
         // Computes and sets the value of leadTimeBounds_.

      void setUpLeadTimeBounds ();
         //
         // Sets up the lead time bounds capability.

      double compDemandedIncVol (
            WitDemand * theDemand,
            WitPeriod   thePer,
            double      desIncVol);
         //
         // Computes and returns the portion of desIncVol that's demanded for
         // theDemand in thePer.

      double minUnmetCumDem (WitDemand * theDemand, WitPeriod thePer);
         //
         // Computes and returns the min value of cumDemandVol - cumShipVol over
         // {thePer, ..., nPeriods - 1}

      void preIncHeurAlloc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            bool        asapMultiExec);
         //
         // Takes actions appropriate at the beginning of incHeurAlloc.

      void doBaByDemand (
            WitDemand * theDemand, 
            WitPeriod   lastPer,
            double &    netQty);
         //
         // Does build-ahead by demand and theDemand in lastPer and earlier
         // periods.

      void postIncHeurAlloc (
            WitDemand * theDemand, 
            WitPeriod   thePer, 
            double      desIncVol,
            double      incVol);
         //
         // Takes actions appropriate at the conclusion of incHeurAlloc.

      void enforceStockSLBs (WitPart * thePart);
         //
         // Enforces the stock soft lower bounds for thePart in all periods.

      void enforceStockSLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Enforces the stock soft lower bound for theMat in thePer.
         // This function assumes that none of theMat's stockVol in thePer has
         // already been reserved for stock softLBs. Thus this function should
         // only be called once for each Material and period.

      void commitMaxQty (WitPart * thePart, WitPeriod thePer, double & netQty);
         //
         // Commits the heuristically maximum possible quantity of thePart in
         // thePer, considering multiple selections, if appropriate.

      void permCommit (double qty);
         //
         // Calls commit on perm data.
         // Verifies that the commit attempt succeeded.

      double findMaxQty (double desQty);
         //
         // Determines the heuristic maximum lotsize-feasible quantity of
         // topPart_ that is <= desQty and can be made in topPer_.
         // The search considers only lotsize feasible quantities.
         // If the minimum lot-sized quantity is not feasible, 0.0 is returned.
         // Otherwise, if the desired quantity is feasible, it is returned.
         // Otherwise the max quantity is found by a binary search.

      double binarySearch (double incQty);
         //
         // Does the binary search aspect of findMaxQty, where 1.0 is assumed
         // feasible and desQty is assumed infeasible.

      bool commit (double qty);
         //
         // Attempts to commit qty units of topPart () to a shipment in 
         // topPer (). 
         // Returns true iff the attempt succeeded.

      bool innerCommit (double qty);
         //
         // Does most of the work for commit.

      bool fillReq (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    theReqVol);
         //
         // Attempts to meet theReqVol units of requirement of thePart in
         // fillPer. Returns true iff the attempt succeeded.

      bool fillNetReq (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    theReqVol);
         //
         // Attempts to meet theReqVol units of requirement of thePart in
         // fillPer by explosion. Returns true iff the attempt succeeded.

      bool fillNetReqBASS (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    netReqVol);
         //
         // Similar to fillNetReq.
         // Valid only in sel-split mode.

      bool explodePart (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Attempts to explode expVol units thru thePart in period expPer, to
         // fill demand in fillPer. 
         // Returns true iff the explosion was successful.

      bool explodePartSS (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Performs selection-split explosions of expVol units of thePart 
         // in expPer in order to meet requirements in fillPer.
         // Valid only in sel-split mode.

      bool explodePartPRSS (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Explodes expVol units of thePart in expPer in order to meet
         // requirements in fillPer, for prop-routing selection splitting.

      bool explodePartMRSS (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Explodes expVol units of thePart in expPer in order to meet
         // requirements in fillPer, for multi-route selection splitting.

      bool explodePartPR (
            WitPart * thePart,
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Performs a proportionate explosion of expVol units of thePart 
         // in expPer in order to meet requirements in fillPer.
         // Valid only in proportionate routing mode.

      bool explodeBopEntSS (
            WitBopEntry * theBopEnt,
            WitPeriod     expPer,
            double        expVol,
            WitPeriod     fillPer);
         //
         // Explodes theBopEnt in expPer.
         // Valid only in sel-split mode.

      bool explodeBopEntMESS (
            WitBopEntry * theBopEnt,
            WitPeriod     expPer,
            double        expVol,
            WitPeriod     fillPer);
         //
         // Explodes theBopEnt in expPer, using sel-split for multi-exec.

      bool explodeBopEnt (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        qty,
            WitPeriod     fillPer);
         //
         // Attempts to explode qty units thru theBopEnt by executing in period
         // execPer, to fill demand in fillPer. 
         // Returns true iff the explosion was successful.

      bool checkExecBound (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        oldExecVol,
            double        deltaExecVol,
            WitPeriod     fillPer);
         //
         // Returns true, iff exploding thru theBopEnt by increasing
         // the Operation's execVol in execPer from oldExecVol by deltaExecVol,
         // to fill demand in fillPer would satisfy the appropriate upper bound
         // on execVol.  
         // In the false case, records the failure, if appropriate.

      void recClShortage (WitPart * thePart, WitPeriod fillPer);
         //
         // Records a shortage of thePart in fillPer for the critical list and
         // the pegged critical list.

      void innerExplodeBopEnt (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        qty,
            double        deltaExecVol,
            WitPeriod     fillPer);
         //
         // Explodes qty units thru theBopEnt by executing deltaExecVol units in
         // execPer, to fill demand in fillPer. 

      void explodeBopEntries (
            WitBopEntry * theBopEnt,
            WitPeriod     execPer,
            double        deltaExecVol);
         //
         // Does the BopEntry accounting for exploding deltaExecVol units 
         // through theBopEnt in execPer.

      void netAndRollReq (
            WitMaterial * theMat,
            WitPeriod     thePer,
            double &      netReqVol,
            bool &        bddSsrSplit);
         //
         // Nets netReqVol for against the availability of theMat in thePer 
         // and rolls netted amount to the next period. If the rollVol is for a
         // bounded split of SSR, sets bddSsrSplit to true.
         // Valid only in stock reallocation mode.

      void explodeBomEntry (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Explodes deltaExecVol units along theBomEnt in exec period execPer,
         // for filling demand in fillPer, exploding thru theBopEnt.

      void explodeBomEntryMRSS (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Explodes deltaExecVol units along theBomEnt in execPer, for filling
         // demand in fillPer, exploding thru theBopEnt, for multi-route
         // selection splitting.

      void netConsEntries (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double &      netExecQty,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Nets the requirement for theBomEnt using both theBomEnt and
         // its SubEntries.

      void netSubEntry (
            WitSubEntry * theSub,
            WitPeriod     execPer,
            double &      netExecQty,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Nets the requirement of an Operation along a SubEntry.

      void netConsEntry (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double &       netExecQty,
            WitPeriod      fillPer,
            WitBopEntry *  theBopEnt);
         //
         // Nets the requirement of an Operation along a ConsEntry.

      void explodeBomEntryPRSS (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Does a split proportionate explosion of deltaExecVol units along
         // theBomEnt in exec period execPer, filling demand in fillPer,
         // exploding thru theBopEnt.

      void explodeBomEntryPR (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            double        deltaExecVol,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Does a proportionate explosion of deltaExecVol units along theBomEnt
         // in exec period execPer, filling demand in fillPer, exploding thru
         // theBopEnt.

      void explodeConsEntry (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double         netExecQty,
            WitPeriod      fillPer,
            WitBopEntry *  theBopEnt);
         //
         // Explodes netExecQty units along theConsEnt in exec period execPer
         // for filling demand in fillPer, exploding thru theBopEnt.

      void explodeSub (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double         netExecQty);
         //
         // Performs whatever additional actions are appropriate for exploding
         // netExecQty units thru theConsEnt in execPer, when theConsEnt is a
         // SubEntry, if necessary.

      inline bool critListMode () 
         {
         return (myHeurCritList_ != NULL);
         }

      inline bool pclMode () 
         {
         return (myPclBldr_ != NULL);
         }

      WitBopEntry * expBopEntry (WitPart * thePart, WitPeriod expPer);
         //
         // Returns the BopEntry to be used for explosions in order to produce
         // thePart in expPer.

      WitPeriod execPerFor (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Returns the execution period to be used when exploding through 
         // theBopEnt in expPer.

      //------------------------------------------------------------------------

      accessNonNull (WitHeurCritList *, myHeurCritList)
      accessNonNull (WitPclBldr *,      myPclBldr)
      accessNonNull (WitMrMgr *,        myMrMgr)
      accessNonNull (WitPrMgr *,        myPrMgr)
      accessNonNull (WitBaMgr *,        myBaMgr)
      accessNonNull (WitMeMgr *,        myMeMgr)
      accessNonNull (WitPenExMgr *,     myPenExMgr)
      accessNonNull (WitSglSrcMgr *,    mySglSrcMgr)

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitAvailSched * myAvailSched_;
         //
         // The AvailSched owned by this HeurAtor.

      WitReqSched * myReqSched_;
         //
         // The requirement schedule for this HeurAtor.

      WitHeurCritList * myHeurCritList_;
         //
         // The HeurCritList owned by this HeurAtor, if any; otherwise NULL.

      WitPclBldr * myPclBldr_;
         //
         // The PclBldr owned by this HeurAtor in pegged crit list mode;
         // otherwise NULL.

      WitHeurModifier * myHeurModifier_;
         //
         // The HeurModifier owned by this HeurAtor, during modifiable heuristic
         // allocation; otherwise NULL.

      WitSelector * mySelector_;
         //
         // The Selector owned by this HeurAtor, if any; otherwise NULL.

      WitMrMgr * myMrMgr_;
         //
         // The MrMgr associated with this HeurAtor, if multiRoute_ is true;
         // otherwise NULL.

      WitPrMgr * myPrMgr_;
         //
         // The PrMgr associated with this HeurAtor, in new propRtg mode;
         // otherwise NULL.

      WitBaMgr * myBaMgr_;
         //
         // The BaMgr associated with this HeurAtor, if buildAhead_ is true;
         // otherwise NULL.

      WitMeMgr * myMeMgr_;
         //
         // The MeMgr associated with this HeurAtor, if multiExec_ is true;
         // otherwise NULL.

      WitSsrMgr * mySsrMgr_;
         //
         // The SsrMgr associated with this HeurAtor, if any; otherwise NULL.

      WitPenExMgr * myPenExMgr_;
         //
         // The PenExMgr associated with this HeurAtor, if penExec_ is true;
         // otherwise NULL.

      WitSglSrcMgr * mySglSrcMgr_;
         //
         // The SglSrcMgr associated with this HeurAtor, if sglSrc_ is
         // true; otherwise NULL.
 
      WitPegger * myPegger_;
         //
         // The Pegger for this HeurAtor, if perfPegging_ is true; 
         // otherwise NULL.

      WitDataRepos * tempCommRepos_;
         //
         // Saves values during a temp commit.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      bool multiRoute_;
         //
         // true, iff the multiple routes technique is to be performed.

      bool buildAhead_;
         //
         // true, iff build-ahead by Material is to be performed.

      bool multiExec_;
         //
         // true, iff the multiple execution periods technique is to be 
         // performed.

      bool penExec_;
         //
         // true, iff penalized execution is to be performed.

      bool selSplit_;
         //
         // true, iff selection splitting is to be performed.

      bool sglSrc_;
         //
         // true, iff new single-source is to be performed.

      bool perfPegging_;
         //
         // true, iff pegging is to be performed.

      bool userHeurStart_;
         //
         // true, iff user-specified heuristic starting solution is to be used.

      bool finiteExecBounds_;
         //
         // true, iff myProblem () includes any execBounds with finite hardUBs.

      bool leadTimeBounds_;
         //
         // true, iff the lead time bounds capability is to be used.

      int ltbMinPer_;
         //
         // If leadTimeBounds_ is true, then ltbMinPer_ is the earliest period
         // eligible for explosion in the current incHeurAlloc.

      bool tempCommActive_;
         //
         // true, iff heuristic allocation is currently performing a temp
         // commit.

      bool permCommActive_;
         //
         // true, iff heuristic allocation is currently performing a perm
         // commit.

      WitSchedule <WitPart, WitPeriod> blocked_;
         //
         // blocked_ (thePart)[thePer] is true, iff an attempt to meet external
         // demand for thePart in thePer has failed.
         // Only allocated for Parts with positive demand.

      WitMapping <WitBomEntry, bool> hasSubsToNet_;
         //
         // hasSubsToNet_ (theBomEnt) is true, iff theBomEnt has at least one
         // substitute for which netAllowed is true.

      double searchInc_;
         //
         // Search increment for the current Demand, if any;
         // otherwise 1.0.

      WitPart * topPart_;
         //
         // The Part for which commitMaxQty was called, if any, else NULL.

      WitPeriod topPer_;
         //
         // The Period for which commitMaxQty was called, if any, else -1.

      int nMaxCommits_;
         //
         // # calls to commitMaxQty.

      int nSelCommits_;
         //
         // # calls to commitMaxQtySel.

      int nBsearches_;
         //
         // # binary searches.

      int nTempComms_;
      int nPermComms_;
      int nComms_;
         //
         // # calls to:
         //    tempCommit
         //    permCommit
         //    commit

      bool failedOn1_;
         //
         // true, iff the final failing temp-commit was for one unit.
   };
@


1.112
log
@Heuristic Adjustment
@
text
@d120 1
a120 1
      accessNonNull (WitHeurAdjuster *, myHeurAdjuster)
d543 1
a543 1
      WitHeurAdjuster * myHeurAdjuster_;
d545 2
a546 2
         // The HeurAdjuster owned by this HeurAtor, if heuristic adjustment is
         // enabled; otherwise NULL.
@


1.111
log
@Heuristic Adjustment
@
text
@a62 8
      void adjustIncAvailVol (
            WitPart * thePart, 
            WitPeriod thePer, 
            double    deltaAvailVol);
         //
         // Adds deltaAvailVol to the incremental availability of thePart in
         // thePer for heuristic adjustment.

d120 4
a123 3
      accessNonNull (WitSelector *, mySelector)
      accessNonNull (WitPart *,     topPart)
      accessNonNull (WitSsrMgr *,   mySsrMgr)
d543 5
@


1.110
log
@Heuristic Adjustment
@
text
@d112 4
@


1.109
log
@Heuristic Adjustment
@
text
@a111 4
      void updateForAdjust ();
         //
         // Updates this HeurAtor for a heuristic adjustment.

@


1.108
log
@Heuristic Adjustment
@
text
@d66 1
a66 1
            double    deltaVol);
d68 2
a69 2
         // Adds deltaVol to the incremental availability of thePart in thePer
         // for heuristic adjustment.
@


1.107
log
@Heuristic Adjustment
@
text
@d20 1
a20 1
#include <Opn.h>
@


1.106
log
@Heuristic Adjustment
@
text
@d63 4
a66 4
      void adjustForShipVol (
            WitDemand * theDemand,
            WitPeriod   shipPer,
            double      deltaShipVol);
d68 2
a69 3
         // Adjusts the state of heuristic allocation for a change to
         // theDemand->shipVol ()[shipPer] of deltaShipVol, which may be
         // positive or negative.
@


1.105
log
@Heuristic Adjustment
@
text
@d63 9
@


1.104
log
@Pause/Resume
@
text
@d104 4
@


1.103
log
@Pause / Resume
@
text
@a108 1
      accessFunc (bool,   paused)
a621 4
      bool paused_;
         //
         // True, iff heuristic allocation is currently paused.

@


1.102
log
@Lead Time Bounds.
@
text
@d109 1
d623 4
@


1.101
log
@Lead Time Bounds
@
text
@d109 1
@


1.100
log
@Lead Time Bounds.
@
text
@a306 4
      void recFundShortage (WitPart * thePart, WitPeriod fillPer);
         //
         // Records a fundamental shortage of thePart in fillPer.

d357 5
@


1.99
log
@Lead Time Bounds
@
text
@d348 1
a348 1
      bool checkExecBounds (
d351 2
a352 1
            double        theExecVol,
d356 3
a358 2
         // the Operation's execVol in execPer to theExecVol, to fill demand in
         // fillPer would satisfy the appropriate upper bound on execVol.  
@


1.98
log
@Lead Time Bounds
@
text
@d269 10
a306 9
      bool findExpPer (
            WitPart *   thePart, 
            WitPeriod   fillPer, 
            WitPeriod & expPer);
         //
         // Sets expPer to the period appropriate for exploding thePer to fill
         // reqs in fillPer. Returns true, iff thePart is explodeable for
         // fillPer.

d338 1
a338 1
      bool explode (
d359 1
a359 1
      void innerExplode (
@


1.97
log
@Bounded Lead Times
@
text
@d54 1
a54 1
      double inc (
d164 8
d177 7
d192 8
d304 5
a308 1
         // fillPer. In the false case, takes the appropiate recording actions.
d622 7
@


1.96
log
@Bounded lead times.
@
text
@d156 1
a156 1
      void compBoundedLTs ();
d158 1
a158 1
         // Computes and sets the value of boundedLTs.
d160 1
a160 1
      void setUpBoundedLTs ();
d162 1
a162 1
         // Sets up the bounded lead times capability.
d594 1
a594 1
      bool boundedLTs_;
@


1.95
log
@Stochastic Implosion
@
text
@d156 8
d594 2
@


1.94
log
@Stochastic Implosion
@
text
@d100 4
@


1.93
log
@[disallowed backlog]
@
text
@d96 4
@


1.92
log
@Rescinded all changed made since 1/31/07.
@
text
@a96 19
      // Functions for receiving data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      //------------------------------------------------------------------------

      static void receiveDMPs (
         WitDblFlexVec            WitDemand::* shipVolArg);

      static void receiveDMPs (
         WitDblFlexVec         WitOperation::* execVolArg);

      static void receiveDMPs (
         WitDblFlexVec          WitSubEntry::* subVolArg);

      static void receiveDMPs (
         WitList <WitPartPer> WitGlobalComp::* criticalListArg,
         WitList <WitPclEl>   WitGlobalComp::* pgdCritListArg);

      //------------------------------------------------------------------------
a469 11
      // Data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      // E.g., theOpn->*execVol_ == theOpn->execVol_.
      //------------------------------------------------------------------------

      static WitDblFlexVec    WitDemand::* shipVol_;
      static WitDblFlexVec WitOperation::* execVol_;
      static WitDblFlexVec  WitSubEntry::* subVol_;

      //------------------------------------------------------------------------
@


1.91
log
@[disallowed backlog]
@
text
@d103 9
d489 11
@


1.90
log
@[disallowed backlog]
@
text
@a102 3
         WitDblFlexVec          WitSubEntry::* subVolArg);

      static void receiveDMPs (
a479 9
      // Data member pointers.
      //
      // See comment on transmitAllDMPs in CompMgr.h.
      // E.g., theOpn->*execVol_ == theOpn->execVol_.
      //------------------------------------------------------------------------

      static WitDblFlexVec WitSubEntry::* subVol_;

      //------------------------------------------------------------------------
@


1.89
log
@Heuristic search increment.
@
text
@a102 6
         WitDblFlexVec            WitDemand::* shipVolArg);

      static void receiveDMPs (
         WitDblFlexVec         WitOperation::* execVolArg);

      static void receiveDMPs (
d489 1
a489 3
      static WitDblFlexVec    WitDemand::* shipVol_;
      static WitDblFlexVec WitOperation::* execVol_;
      static WitDblFlexVec  WitSubEntry::* subVol_;
@


1.88
log
@Heuristic search increment.
@
text
@d119 6
a124 5
      accessFunc (bool, buildAhead)
      accessFunc (bool, tempCommActive)
      accessFunc (bool, permCommActive)
      accessFunc (bool, failedOn1)
      accessFunc (bool, userHeurStart)
d631 2
a632 1
         // Search increment for the current Demand.
@


1.87
log
@Updated the copyright date on all source files.
@
text
@d628 4
@


1.86
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.85
log
@Fixed a bug in penalized execution:
   canPseudoNet needed to skip BomEnts that won't be netted.
@
text
@d40 1
a40 9
      WitHeurAtor (
                  WitProblem *, 
                  WitPegger *, 
                  bool                                      forOpt,
            const WitRefMap <WitDemand,    WitDblFlexVec> & shipVolArg,
            const WitRefMap <WitOperation, WitDblFlexVec> & execVolArg,
            const WitRefMap <WitSubEntry,  WitDblFlexVec> & subVolArg,
                  WitList   <WitPartPer>                  & criticalListArg,
                  WitList   <WitPclEl>                    & pgdCritListArg);
d97 19
d488 4
a491 1
      // Mappings to data loaded in from Components.
d494 3
a496 5
      const WitRefMap <WitDemand,    WitDblFlexVec> & shipVol_;
      const WitRefMap <WitOperation, WitDblFlexVec> & execVol_;
      const WitRefMap <WitSubEntry,  WitDblFlexVec> & subVol_;

      WitList <WitPartPer>                          & criticalList_;
@


1.84
log
@Vector PropRtg.
@
text
@d130 5
@


1.83
log
@pegged Critical List.
@
text
@d513 1
a513 1
         // The PrMgr associated with this HeurAtor, in new propRouting mode;
@


1.82
log
@Pegged Critical List.
@
text
@d41 8
a48 7
            WitProblem *, 
            WitPegger *, 
            bool                                      forOpt,
            WitRefMap <WitDemand,    WitDblFlexVec> & shipVolArg,
            WitRefMap <WitOperation, WitDblFlexVec> & execVolArg,
            WitRefMap <WitSubEntry,  WitDblFlexVec> & subVolArg,
            WitRef    <WitList <WitPartPer> >       & criticalListArg);
d441 1
a441 1
      inline bool pgdCritListMode () 
d443 1
a443 1
         return (myPclMgr_ != NULL);
d459 1
a459 1
      accessNonNull (WitPclMgr *,       myPclMgr)
d475 3
a477 3
      WitRefMap <WitDemand,    WitDblFlexVec> & shipVol_;
      WitRefMap <WitOperation, WitDblFlexVec> & execVol_;
      WitRefMap <WitSubEntry,  WitDblFlexVec> & subVol_;
d479 1
a479 1
      WitRef    <WitList <WitPartPer> >              & criticalList_;
d497 1
a497 1
      WitPclMgr * myPclMgr_;
d499 1
a499 1
         // The PclMgr for this HeurAtor in pegged crit list mode;
@


1.81
log
@Low-Pri Prop-Rt.
@
text
@d437 1
a437 1
         return myHeurCritList_ != NULL;
d440 1
a440 1
      inline WitHeurCritList * myHeurCritList () 
d442 1
a442 3
         witAssert (critListMode ());

         return myHeurCritList_;
d457 8
a464 6
      accessNonNull (WitMrMgr *,     myMrMgr)
      accessNonNull (WitPrMgr *,     myPrMgr)
      accessNonNull (WitBaMgr *,     myBaMgr)
      accessNonNull (WitMeMgr *,     myMeMgr)
      accessNonNull (WitPenExMgr *,  myPenExMgr)
      accessNonNull (WitSglSrcMgr *, mySglSrcMgr)
d494 6
a499 1
         // The HeurCritList owned by this HeurAtor.
@


1.80
log
@Low-Pri Prop-Rt.
@
text
@a136 7
      inline WitExpRest * myExpRest ()
         {
         witAssert (penExec_);

         return myExpRest_;
         }

d463 1
d524 1
a524 1
      WitExpRest * myExpRest_;
d526 1
a526 1
         // The ExpRest associated with this HeurAtor, if penExec_ is true;
@


1.79
log
@Low-Pri Prop-Rt.
@
text
@d108 2
a109 1
      accessFunc (bool, tempMode)
d545 1
a545 1
      WitDataRepos * tempModeRepos_;
d547 1
a547 1
         // Saves values during temp mode.
d590 1
a590 1
      bool tempMode_;
d592 7
a598 1
         // true, iff heuristic allocation is currently in temp mode.
@


1.78
log
@Low-Pri Prop-Rt.
@
text
@a465 1
      accessNonNull (WitPoMgr *,     myPoMgr)
a509 5
      WitPoMgr * myPoMgr_;
         //
         // The PoMgr associated with this HeurAtor, in old propRouting mode;
         // otherwise NULL.

@


1.77
log
@Low-Pri Prop-Rt.
@
text
@d467 1
d513 6
a518 1
         // The PoMgr associated with this HeurAtor, in propRouting mode;
@


1.76
log
@Minor change to BomEntry netting.
@
text
@d466 1
a466 1
      accessNonNull (WitPrMgr *,     myPrMgr)
d510 1
a510 1
      WitPrMgr * myPrMgr_;
d512 1
a512 1
         // The PrMgr associated with this HeurAtor, in propRouting mode;
@


1.75
log
@Double Precision.
@
text
@d599 1
a599 1
      WitMapping <WitBomEntry, bool> netAllowed_;
d601 1
a601 1
         // netAllowed_ (theBomEnt) is true, iff theBomEnt has at least one
@


1.74
log
@Continued implementation of PIP.
@
text
@d43 5
a47 5
            bool                                             forOpt,
            WitRefMap <WitDemand,    WitFlexVec <double> > & shipVolArg,
            WitRefMap <WitOperation, WitFlexVec <double> > & execVolArg,
            WitRefMap <WitSubEntry,  WitFlexVec <double> > & subVolArg,
            WitRef    <WitList <WitPartPer> >              & criticalListArg);
d479 3
a481 3
      WitRefMap <WitDemand,    WitFlexVec <double> > & shipVol_;
      WitRefMap <WitOperation, WitFlexVec <double> > & execVol_;
      WitRefMap <WitSubEntry,  WitFlexVec <double> > & subVol_;
@


1.73
log
@Continued implementation of proportionate routing.
@
text
@d47 1
a47 1
            WitRef    <WitList <WitDatedPart> >            & criticalListArg);
d483 1
a483 1
      WitRef    <WitList <WitDatedPart> >            & criticalList_;
@


1.72
log
@Continued implementation of proportionate routing.
@
text
@d400 11
@


1.71
log
@Continued implementation of proportionate routing.
@
text
@a255 6
      bool explodeRtCandPRSS (
            WitRtCand * theRtCand,
            WitPeriod   expPer,
            double      splitVol,
            WitPeriod   fillPer);

@


1.70
log
@Continued implementation of proportionate routing.
@
text
@d256 6
@


1.69
log
@Continued implementation of proportionate routing.
@
text
@d247 9
d274 10
a299 10

      bool explodePartPR (
            WitPart * thePart,
            WitPeriod expPer,
            double    expVol,
            WitPeriod fillPer);
         //
         // Performs a proportionate explosion of expVol units of thePart 
         // in expPer in order to meet requirements in fillPer.
         // Valid only in proportionate routing mode.
@


1.68
log
@Continued implementation of proportionate routing.
Fixed a bug in selection splitting for selective stock reallocation.
@
text
@d283 1
a283 1
            WitPart * thePart, 
a400 11

      void explodeConsEntryPR (
            WitConsEntry * theConsEnt,
            WitPeriod      execPer,
            double         deltaExecVol,
            WitPeriod      fillPer,
            WitBopEntry *  theBopEnt);
         //
         // Does theConsEnt's share of a proportionate explosion of deltaExecVol
         // units in exec period execPer, filling demand in fillPer, exploding
         // thru theBopEnt.
@


1.67
log
@Continued implementation of proportionate routing.
@
text
@d334 2
a335 1
            double &      netReqVol);
d338 2
a339 1
         // and rolls netted amount to the next period.
@


1.66
log
@Continued implementation of proportionate routing.
@
text
@d274 8
@


1.65
log
@Continued implementation of proportionate routing.
@
text
@d23 1
d247 9
d342 1
a342 1
      void explodeBomEntrySS (
d349 3
a351 2
         // Performs actions of explodeBomEntry specific to selection splitting.
         // Valid only in sel-split mode.
d579 5
@


1.64
log
@Continued implementation of proportionate routing.
@
text
@d482 1
a482 1
         // The PrMgr associated with this HeurAtor, if propRouting_ is true;
a524 4

      bool propRouting_;
         //
         // true, iff the proportionate routing technique is to be performed.
@


1.63
log
@Continued implementation of propotionate routing.
@
text
@d435 2
a436 4
      accessNonNull (WitPmrMgr *,    myPmrMgr)
      accessNonNull (WitCmrMgr *,    myCmrMgr)
      accessNonNull (WitPprMgr *,    myPprMgr)
      accessNonNull (WitCprMgr *,    myCprMgr)
d475 1
a475 2
      WitPmrMgr * myPmrMgr_;
      WitCmrMgr * myCmrMgr_;
d477 2
a478 2
         // The PmrMgr and CmrMgr associated with this HeurAtor, if
         // multiRoute_ is true; otherwise NULL.
d480 1
a480 2
      WitPprMgr * myPprMgr_;
      WitCprMgr * myCprMgr_;
d482 2
a483 2
         // The PprMgr and CprMgr associated with this HeurAtor, if propRouting_
         // is true; otherwise NULL.
@


1.62
log
@Continued implementation of proportionate routing.
@
text
@d435 4
a438 4
      accessNonNull (WitPmrSelMgr *, myPmrSelMgr)
      accessNonNull (WitCmrSelMgr *, myCmrSelMgr)
      accessNonNull (WitPprSelMgr *, myPprSelMgr)
      accessNonNull (WitCprSelMgr *, myCprSelMgr)
d477 2
a478 2
      WitPmrSelMgr * myPmrSelMgr_;
      WitCmrSelMgr * myCmrSelMgr_;
d480 1
a480 1
         // The PmrSelMgr and CmrSelMgr associated with this HeurAtor, if
d483 2
a484 2
      WitPprSelMgr * myPprSelMgr_;
      WitCprSelMgr * myCprSelMgr_;
d486 2
a487 2
         // The PprSelMgr and CprSelMgr associated with this HeurAtor, if
         // propRouting_ is true; otherwise NULL.
@


1.61
log
@Continued implementation of proportionate routing.
@
text
@d435 4
a438 3
      accessNonNull (WitPmrMgr *,    myPmrMgr)
      accessNonNull (WitCmrMgr *,    myCmrMgr)
      accessNonNull (WitPrMgr *,     myPrMgr)
d477 2
a478 1
      WitPmrMgr * myPmrMgr_;
d480 5
a484 4
         // The PmrMgr associated with this HeurAtor, if multiRoute_ is true;
         // otherwise NULL.
 
      WitCmrMgr * myCmrMgr_;
d486 2
a487 2
         // The CmrMgr associated with this HeurAtor, if multiRoute_ is true;
         // otherwise NULL.
a488 5
      WitPrMgr * myPrMgr_;
         //
         // The PrMgr associated with this HeurAtor, if propRouting_ is
         // true; otherwise NULL.
 
@


1.60
log
@Continued implementation of proportionate routing.
@
text
@d106 4
a109 5
      accessFunc (WitRtMgr *, myRtMgr)
      accessFunc (bool,       buildAhead)
      accessFunc (bool,       tempMode)
      accessFunc (bool,       failedOn1)
      accessFunc (bool,       userHeurStart)
a470 4

      WitRtMgr * myRtMgr_;
         //
         // The RtMgr owned by this HeurAtor.
@


1.59
log
@Continued implementation of proportionate routing.
@
text
@d265 1
a265 1
      bool explodePartOldPR (
d271 1
a271 1
         // Performs an old proportionate explosion of expVol units of thePart 
d273 1
a273 1
         // Proportionate routing mode.
a437 2
      accessNonNull (WitProdOpMgr *, myProdOpMgr)
      accessNonNull (WitConsOpMgr *, myConsOpMgr)
a490 10
      WitProdOpMgr * myProdOpMgr_;
         //
         // The ProdOpMgr associated with this HeurAtor, if oldPr_ is
         // true; otherwise NULL.
 
      WitConsOpMgr * myConsOpMgr_;
         //
         // The ConsOpMgr associated with this HeurAtor, if oldPr_ is
         // true; otherwise NULL.
 
a535 5

      bool oldPr_;
         //
         // true, iff the old proportionate routing technique is to be
         // performed.
@


1.58
log
@Continued implementation of proportionate routing.
@
text
@d265 1
a265 1
      bool explodePartPR (
d271 1
a271 1
         // Performs a proportionate explosion of expVol units of thePart 
@


1.57
log
@Continued implementation of proportionate routing.
@
text
@d440 1
d495 1
a495 1
         // The ProdOpMgr associated with this HeurAtor, if propRouting_ is
d500 6
a505 1
         // The ConsOpMgr associated with this HeurAtor, if propRouting_ is
d548 5
@


1.56
log
@Continued implementation of proportionate routing.
@
text
@d438 2
a439 2
      accessNonNull (WitProdPrMgr *, myProdPrMgr)
      accessNonNull (WitConsPrMgr *, myConsPrMgr)
d492 1
a492 1
      WitProdPrMgr * myProdPrMgr_;
d494 1
a494 1
         // The ProdPrMgr associated with this HeurAtor, if propRouting_ is
d497 1
a497 1
      WitConsPrMgr * myConsPrMgr_;
d499 1
a499 1
         // The ConsPrMgr associated with this HeurAtor, if propRouting_ is
@


1.55
log
@Continued implementation of proportionate routing.
@
text
@d106 5
a110 4
      accessFunc (bool, buildAhead)
      accessFunc (bool, tempMode)
      accessFunc (bool, failedOn1)
      accessFunc (bool, userHeurStart)
@


1.54
log
@Continued implementation of proportionate routing.
@
text
@d473 4
@


1.53
log
@Continued implementation of proportionate routing.
@
text
@d370 22
d402 9
d438 1
d490 5
@


1.52
log
@Continued implementation of proportionate routing.
@
text
@d406 1
a406 1
      accessNonNull (WitPprMgr *,    myPprMgr)
d455 1
a455 1
      WitPprMgr * myPprMgr_;
d457 2
a458 2
         // The PprMgr associated with this HeurAtor, if propRouting_ is true;
         // otherwise NULL.
@


1.51
log
@Continued implementation of proportionate routing.
@
text
@d406 1
a406 1
      accessNonNull (WitPrMgr *,     myPrMgr)
d455 1
a455 1
      WitPrMgr * myPrMgr_;
d457 1
a457 1
         // The PrMgr associated with this HeurAtor, if propRouting_ is true;
@


1.50
log
@Continued implementation of Proportionate Routing.
@
text
@d242 1
a242 1
         // Performs selection-split explosions of netReqVol units of thePart 
d264 10
d406 1
d455 5
d499 5
a503 1
         // true, iff the multiple routes periods technique is to be performed.
@


1.49
log
@Internal changes.
@
text
@d146 4
@


1.48
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d42 1
a42 1
            WitBoolean                                       forOpt,
d48 1
a48 1
         // forOpt == TRUE indicates heur allocation is for opt implosion.
d64 1
a64 1
            WitBoolean  asapMultiExec);
d78 1
a78 1
      WitBoolean tempCommit (double qty);
d81 1
a81 1
         // Returns TRUE iff the commit attempt succeeded.
d88 1
a88 1
      WitBoolean incAvailPos (WitPart * thePart, WitPeriod thePer);
d90 1
a90 1
         // Returns TRUE, iff there is positive incremental availability of
d93 1
a93 1
      WitBoolean selectiveSR (WitMaterial *);
d106 4
a109 4
      accessFunc    (WitBoolean,  buildAhead)
      accessFunc    (WitBoolean,  tempMode)
      accessFunc    (WitBoolean,  failedOn1)
      accessFunc    (WitBoolean,  userHeurStart)
d115 1
a115 1
      inline WitBoolean multiSel () 
d198 1
a198 1
      WitBoolean commit (double qty);
d202 1
a202 1
         // Returns TRUE iff the attempt succeeded.
d204 1
a204 1
      WitBoolean innerCommit (double qty);
d208 1
a208 1
      WitBoolean fillReq (
d214 1
a214 1
         // fillPer. Returns TRUE iff the attempt succeeded.
d216 1
a216 1
      WitBoolean fillNetReq (
d222 1
a222 1
         // fillPer by explosion. Returns TRUE iff the attempt succeeded.
d224 1
a224 1
      WitBoolean fillNetReqBASS (
d232 1
a232 1
      WitBoolean explodePartSS (
d242 1
a242 1
      WitBoolean findExpPer (
d248 2
a249 2
         // reqs in fillPer. Returns TRUE, iff thePart is explodeable for
         // fillPer. In the FALSE case, takes the appropiate recording actions.
d251 1
a251 1
      WitBoolean explodeBopEntSS (
d260 1
a260 1
      WitBoolean explode (
d268 1
a268 1
         // Returns TRUE iff the explosion was successful.
d270 1
a270 1
      WitBoolean checkExecBounds (
d276 1
a276 1
         // Returns TRUE, iff exploding thru theBopEnt by increasing
d279 1
a279 1
         // In the FALSE case, records the failure, if appropriate.
d366 1
a366 1
      inline WitBoolean critListMode () 
d432 1
a432 1
         // The PmrMgr associated with this HeurAtor, if multiRoute_ is TRUE;
d437 1
a437 1
         // The CmrMgr associated with this HeurAtor, if multiRoute_ is TRUE;
d442 1
a442 1
         // The BaMgr associated with this HeurAtor, if buildAhead_ is TRUE;
d447 1
a447 1
         // The MeMgr associated with this HeurAtor, if multiExec_ is TRUE;
d456 1
a456 1
         // The ExpRest associated with this HeurAtor, if penExec_ is TRUE;
d462 1
a462 1
         // TRUE; otherwise NULL.
d466 1
a466 1
         // The Pegger for this HeurAtor, if perfPegging_ is TRUE; 
d477 1
a477 1
      WitBoolean multiRoute_;
d479 1
a479 1
         // TRUE, iff the multiple routes periods technique is to be performed.
d481 1
a481 1
      WitBoolean buildAhead_;
d483 1
a483 1
         // TRUE, iff build-ahead by Material is to be performed.
d485 1
a485 1
      WitBoolean multiExec_;
d487 1
a487 1
         // TRUE, iff the multiple execution periods technique is to be 
d490 1
a490 1
      WitBoolean penExec_;
d492 1
a492 1
         // TRUE, iff penalized execution is to be performed.
d494 1
a494 1
      WitBoolean selSplit_;
d496 1
a496 1
         // TRUE, iff selection splitting is to be performed.
d498 1
a498 1
      WitBoolean sglSrc_;
d500 1
a500 1
         // TRUE, iff new single-source is to be performed.
d502 1
a502 1
      WitBoolean perfPegging_;
d504 1
a504 1
         // TRUE, iff pegging is to be performed.
d506 1
a506 1
      WitBoolean userHeurStart_;
d508 1
a508 1
         // TRUE, iff user-specified heuristic starting solution is to be used.
d510 1
a510 1
      WitBoolean finiteExecBounds_;
d512 1
a512 1
         // TRUE, iff myProblem () includes any execBounds with finite hardUBs.
d514 1
a514 1
      WitBoolean tempMode_;
d516 1
a516 1
         // TRUE, iff heuristic allocation is currently in temp mode.
d520 1
a520 1
         // blocked_ (thePart)[thePer] is TRUE, iff an attempt to meet external
d553 1
a553 1
      WitBoolean failedOn1_;
d555 1
a555 1
         // TRUE, iff the final failing temp-commit was for one unit.
@


1.47
log
@Removed implementation of single-source by the old algorithm.
@
text
@d109 1
d505 4
@


1.46
log
@Continued implementation of single-source with the new algorithm.
@
text
@a392 1
      accessNonNull (WitOldSglMgr *, myOldSglMgr)
a457 5
      WitOldSglMgr * myOldSglMgr_;
         //
         // The OldSglMgr associated with this HeurAtor, if oldSglSrc_ is
         // TRUE; otherwise NULL.
 
a495 4

      WitBoolean oldSglSrc_;
         //
         // TRUE, iff old single-source is to be performed.
@


1.45
log
@Began implementation of the new single-source algorithm.
@
text
@d394 1
d464 5
d505 5
a509 1
         // TRUE, iff single-source is to be performed.
@


1.44
log
@Fixed the "interference bug" in Single-Source.
@
text
@d393 1
a393 1
      accessNonNull (WitSglSrcMgr *, mySglSrcMgr)
d458 1
a458 1
      WitSglSrcMgr * mySglSrcMgr_;
d460 1
a460 1
         // The SglSrcMgr associated with this HeurAtor, if singleSource_ is
d497 1
a497 1
      WitBoolean singleSource_;
@


1.43
log
@Fixed a cumulative shipment bug in heuristic allocation.
@
text
@d377 1
a377 6
      inline WitPeriod expPerFor (WitPart * thePart, WitPeriod fillPer);
         //
         // Returns the explosion period to be used when filling requirements
         // for thePart in fillPer, or fillPer, if there is none.

      inline WitBopEntry * expBopEntry (WitPart * thePart, WitPeriod expPer);
d382 1
a382 1
      inline WitPeriod execPerFor (WitBopEntry * theBopEnt, WitPeriod expPer);
d389 5
a393 4
      accessNonNull (WitPmrMgr *,   myPmrMgr)
      accessNonNull (WitCmrMgr *,   myCmrMgr)
      accessNonNull (WitBaMgr *,    myBaMgr)
      accessNonNull (WitMeMgr *,    myMeMgr)
d458 5
@


1.42
log
@Continued implementation of 2-level lot sizes.
@
text
@d149 1
a149 1
      double cumShipVol (WitDemand * theDemand, WitPeriod thePer);
d151 2
a152 1
         // Computes and returns the cumShipVol of theDemand in thePer.
@


1.41
log
@Continued implementation of Single-Source.
@
text
@d191 1
a191 1
      void defSearchGrid (double & minQty, double & incQty);
d193 2
a194 13
         // Sets minQty and incQty to define the set of values to
         // be examined by the binary search. In lot size mode, this is the lot
         // size grid; otherwise it is the whole numbers.

      static WitBoolean isAnInteger (double theDbl);
         //
         // Returns TRUE, iff theDbl is an integer.

      double binarySearch (double desQty, double minQty, double incQty);
         //
         // Does the binary search aspect of findMaxQty, where minQty and incQty
         // define the search grid, minQty is assumed feasible and desQty is
         // assumed infeasible.
@


1.40
log
@Continued implementation of Single-Source.
@
text
@a92 4
      void resConsStock (WitMaterial *, WitPeriod);
         //
         // See AvailSched.

d168 3
@


1.39
log
@Continued implementation of Single-Source.
@
text
@d114 8
a121 2
      accessNonNull (WitPart *,   topPart)
      accessNonNull (WitSsrMgr *, mySsrMgr)
a387 5
      inline WitBoolean multiSel () 
         {
         return (mySelector_ != NULL);
         }

a404 1
      accessNonNull (WitSelector *, mySelector)
d507 1
a507 1
      WitBoolean sglSrc_;
@


1.38
log
@Continued implementation of single-source.
@
text
@d41 1
a41 1
            WitPegMgr *, 
d473 1
a473 1
      WitPegMgr * myPegMgr_;
d475 1
a475 1
         // The PegMgr owned by this HeurAtor, if perfPegging_ is TRUE; 
@


1.37
log
@Continued implementation of Single-Source.
@
text
@d478 1
a478 1
      WitDataRepos & tempModeRepos_;
@


1.36
log
@Continued implementation of single-source.
@
text
@d22 1
d523 1
a523 1
      WitSchedule <WitPart, WitPeriod> & blocked_;
@


1.35
log
@Continued implementation of single-source.
@
text
@a18 1
#include <AccFlag.h>
d38 8
a45 1
      WitHeurAtor (WitProblem *, WitAccFlag *, WitPegMgr *, WitBoolean forOpt);
a128 12
      //------------------------------------------------------------------------
      // Component data access functions.
      //------------------------------------------------------------------------

      refAccess (WitDemand,    WitFlexVec <double>, shipVol)
      refAccess (WitOperation, WitFlexVec <double>, execVol)
      refAccess (WitSubEntry,  WitFlexVec <double>, subVol)

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

d414 10
a483 4

      WitAccFlag * const myAccFlag_;
         //
         // Ptr to HeurAllMgr::myAccFlag_.
@


1.34
log
@Continued implementation of single source.
@
text
@d508 1
a508 1
         // TRUE, iff single source is to be performed.
@


1.33
log
@Continued implementation of single source.
@
text
@d506 4
@


1.32
log
@Continued implementation of single source.
@
text
@d94 5
d473 1
a473 1
      WitDataRepos & myDataRepos_;
d475 1
a475 1
         // The DataRepos owned by this HeurAtor.
@


1.31
log
@Preliminary work on single source.
@
text
@a104 10
      inline WitArchive <double> * myDblArch ()
         {
         return myDblArch_;
         }

      inline WitArchive <WitPeriod> * myPerArch ()
         {
         return myPerArch_;
         }

a417 5
      WitArchive <double> *    myDblArch_;
      WitArchive <WitPeriod> * myPerArch_;
         //
         // The Archives owned by this HeurAtor.

d467 4
@


1.30
log
@Continued preliminary work on single source.
@
text
@d132 3
a134 3
      refAccess (WitDemand,    WitFlexVec (double), shipVol)
      refAccess (WitOperation, WitFlexVec (double), execVol)
      refAccess (WitSubEntry,  WitFlexVec (double), subVol)
@


1.29
log
@Began implementation of object iteration.
@
text
@a18 2
#include <Mapping.h>
#include <Schedule.h>
d20 3
d524 1
a524 1
      WitSchedule (WitPart, WitPeriod) blocked_;
@


1.28
log
@Continued implementation of sel-split for pen-exec.
@
text
@a412 2
      accessWrapper (WitBoolean,    skipFailures, myGlobalComp ())

@


1.27
log
@Continued implementation of sel-split for pen-exec.
@
text
@a415 1
      accessNonNull (WitSplitter *, mySplitter)
a449 5
      WitSplitter * mySplitter_;
         //
         // The Splitter associated with this HeurAtor, if selSplit_ is TRUE;
         // otherwise NULL.
 
@


1.26
log
@Continued implementation of sel-split for pen-exec.
@
text
@d99 2
a100 1

d556 13
@


1.25
log
@Refactored build-ahead by demand.
@
text
@d325 1
a325 1
            WitBopEntry * theExpBopEntry);
d328 1
a328 1
         // for filling demand in fillPer, exploding thru theExpBopEntry.
d335 1
a335 1
            WitBopEntry * theExpBopEntry);
d343 3
a345 1
            double &      netExecQty);
d348 1
a348 1
         // its subEntries.
d353 3
a355 1
            double &      netExecQty);
d361 1
d363 2
a364 1
            WitPeriod      execPer);
d373 1
a373 1
            WitBopEntry *  theExpBopEntry);
d376 1
a376 1
         // for filling demand in fillPer, exploding thru theExpBopEntry.
@


1.24
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d159 4
a162 6
      double resAlloc (
            WitPart *  thePart,
            WitPeriod  lastPer,
            double     qty,
            WitPeriod  firstPer,
            WitBoolean prefBA);
d164 2
a165 6
         // Allocates resources by:
         //    determining what portion of a desired quantity of the requested
         //    part can  be provided in the requested period, commiting the
         //    required resources, and returning that quantity. Tries allocating
         //    in periods between firstPer and lastPer.
         // Preferential build-ahead is to be used iff prefBA is TRUE.
@


1.23
log
@More improvements to pen-exec.
@
text
@d103 1
a103 1
      inline WitDblArch * myDblArch ()
d108 1
a108 1
      inline WitPerArch * myPerArch ()
d429 2
a430 2
      WitDblArch * myDblArch_;
      WitPerArch * myPerArch_;
@


1.22
log
@Added allowSSPE dev param.
Switched pen-exec to single-shortage logic.
Made pen-exec exploit sparse penalties.
@
text
@d299 1
a299 1
      WitBoolean innerExplode (
a307 1
         // Returns TRUE, iff the explosion was feasible.
d331 1
a331 2
            WitBopEntry * theExpBopEntry,
            WitBoolean &  expOK);
a334 2
         // If the explosion is not feasible (which can only happen in pen-exec
         // mode) expOK gets set to FALSE.
d349 1
a349 2
            double &      netExecQty,
            WitBoolean &  expOK);
d352 1
a352 1
         // its subEntries. See explodeBomEntry for meaning of expOK.
d357 1
a357 2
            double &      netExecQty,
            WitBoolean &  expOK);
a359 1
         // See explodeBomEntry for meaning of expOK.
d364 1
a364 2
            WitPeriod      execPer,
            WitBoolean &   expOK);
@


1.21
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d234 1
a234 1
      WitBoolean fillNetReqNss (
a240 9
         // Valid only in non-sel-split mode.

      WitBoolean fillNetReqSS (
            WitPart * thePart, 
            WitPeriod fillPer, 
            double    theReqVol);
         //
         // Similar to fillNetReqNss.
         // Valid only in sel-split mode.
@


1.20
log
@Changed some comments.
@
text
@d80 5
d89 1
a89 1
      WitBoolean incAvailPos (WitPart * thePart, WitPeriod thePer);
d91 1
a91 2
         // Returns TRUE, iff there is positive incremental availability of
         // thePart in thePer.
a118 4

      WitBoolean selectiveSR (WitMaterial * theMat);
         //
         // See AvailSched.
@


1.19
log
@Made stock reallocation use ssr vs. usr on a part-by-part basis.
@
text
@d68 1
a68 1
         // in topPer_, for a given selection scheme.
@


1.18
log
@Changed selStockRe attribute to stockReallocation (fullSR, internally).
@
text
@d116 4
a429 2
      accessWrapper (WitBoolean,    pureUncondSR, myGlobalComp ())
      accessWrapper (WitBoolean,    fullSR,       myGlobalComp ())
d494 1
a494 2
         // The SsrMgr associated with this HeurAtor, if fullSR_ is TRUE;
         // otherwise NULL.
a525 4

      WitBoolean fullSR_;
         //
         // TRUE, iff selective stock reallocation is to be performed.
@


1.17
log
@Replaced uncondStockRe attribute with the old stockRealloc attribute.
@
text
@d427 1
a427 1
      accessWrapper (WitBoolean,    selStockRe,   myGlobalComp ())
d492 1
a492 1
         // The SsrMgr associated with this HeurAtor, if selStockRe_ is TRUE;
d526 1
a526 1
      WitBoolean selStockRe_;
@


1.16
log
@Renamed mandatory stock reallocation to unconditional stock reallocation.
@
text
@d425 3
a427 3
      accessWrapper (WitBoolean,    skipFailures,   myGlobalComp ())
      accessWrapper (WitBoolean,    uncondStockRe,  myGlobalComp ())
      accessWrapper (WitBoolean,    selStockRe,     myGlobalComp ())
@


1.15
log
@Continued development of Selective Stock Reallocation.
@
text
@d425 3
a427 3
      accessWrapper (WitBoolean,    skipFailures, myGlobalComp ())
      accessWrapper (WitBoolean,    mandStockRe,  myGlobalComp ())
      accessWrapper (WitBoolean,    selStockRe,   myGlobalComp ())
@


1.14
log
@Continued implementation of selective stock reallocation.
@
text
@d324 3
a326 3
            WitPart * thePart,
            WitPeriod thePer,
            double &  netReqVol);
d328 1
a328 1
         // Nets netReqVol for against the availability of thePart in thePer 
@


1.13
log
@Continued implementation of selective stock reallocation.
@
text
@d80 9
d93 2
a94 3
      accessFunc    (const WitAvailSched *, myAvailSched)
      accessFunc    (WitBoolean,            buildAhead)
      accessFunc    (WitBoolean,            tempMode)
d96 2
a97 2
      accessNonNull (WitPart *,             topPart)
      accessNonNull (WitSsrMgr *,           mySsrMgr)
@


1.12
log
@Tightly integrated stock reallocation and stock non-reallocation in preparation
for selective stock reallocation.
@
text
@d89 1
d418 2
a419 1
      accessWrapper (WitBoolean,    stockRealloc, myGlobalComp ())
d479 6
a484 1
         // The MeMgr associated with this HeurAtor, if MultiExec_ is TRUE;
@


1.11
log
@Continuing implementation of selective stock reallocation.
@
text
@d306 8
@


1.10
log
@Fixed a latent bug.
@
text
@d503 4
@


1.9
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@a536 4
      WitBoolean committing_;
         //
         // TRUE, iff commit () is being executed.

@


1.8
log
@Created and used Archive template.
@
text
@a21 1
#include <Archive.h>
d90 10
d160 8
a373 8
      void enforceStockSLBs (WitPart * thePart);
         //
         // Enforces the stock soft lower bounds for thePart in all periods.

      void enforceStockSLB (WitMaterial * theMat, WitPeriod thePer);
         //
         // Enforces the stock soft lower bound for theMat in thePer.

d412 1
d426 5
d447 5
a551 4

      WitArchive <double> execVolArch_;
         //
         // Saves and restores values of Operation::execVol_.
@


1.7
log
@Minor change.
@
text
@d22 1
d85 5
a89 3
      accessFunc    (const WitAllocMode *, myAllocMode)
      accessFunc    (WitBoolean,           buildAhead)
      accessNonNull (WitPart *,            topPart)
a407 4
      inline WitAvailSched * curAvailSched ();
         //
         // Wrapper for myAllocMode_->curAvailSched ().

d416 1
a416 1
      WitAllocMode * myAllocMode_;
d418 1
a418 1
         // The AllocMode owned by this HeurAtor.
d499 4
d532 4
@


1.6
log
@Continued implementation of pegging.
@
text
@d460 1
a460 1
         // The PegMgr owned by this HeurAtor, if peggingNeeded_ is TRUE; 
d492 1
a492 1
      WitBoolean peggingNeeded_;
@


1.5
log
@Continued implementation of pegging.
@
text
@d460 2
a461 2
         // The PegMgr owned by this HeurAtor, if pegging_ is TRUE; otherwise
         // NULL.
d492 1
a492 1
      WitBoolean pegging_;
@


1.4
log
@Continued implementation of pegging.
@
text
@d38 1
a38 1
      WitHeurAtor (WitProblem *, WitAccFlag *, WitBoolean forOpt);
a60 6
      void setUpPeggedIncAlloc (WitObjStack <WitOpnPegEl> & thePegEls);
      void setUpPeggedIncAlloc (WitObjStack <WitSubPegEl> & thePegEls);
         //
         // Each of these functions sets up pegging for an incHeurAlloc by
         // updating thePegEls.

d458 1
a458 2
      WitPegger <WitOperation> * myOpnPegger_;
      WitPegger <WitSubEntry>  * mySubPegger_;
d460 1
a460 1
         // The Peggers owned by this HeurAtor, if pegging_ is TRUE; otherwise
@


1.3
log
@Continued implementation of pegging.
@
text
@d467 2
a468 2
         // The Peggers owned by this HeurAtor, if perfPegging_ is TRUE; 
         // otherwise NULL.
d499 1
a499 1
      WitBoolean perfPegging_;
@


1.2
log
@Continued implementation of pegging.
@
text
@d467 2
a468 2
         // The Peggers owned by this HeurAtor, if doPegging_ is TRUE; otherwise
         // NULL.
d499 1
a499 1
      WitBoolean doPegging_;
@


1.1
log
@Initial implementation of pegging.
@
text
@d61 6
d464 2
a465 1
      WitPegger * myPegger_;
d467 2
a468 2
         // The Pegger owned by this HeurAtor, if doPegging_ is TRUE; 
         // otherwise NULL.
@


head	1.82;
access;
symbols
	sce_5_01_20080919:1.61
	latest_sce_4_20_20060523:1.46.0.2
	sce_4_20_20060523:1.46
	latest_sce4_20_OSL:1.44.0.2
	sce_4_20_OSL:1.44
	sce_410_withVa:1.33
	sce_4_05_20040511:1.30
	sce_4_00_20040201:1.22
	nextGenBranch:1.21.0.2
	nextGenRoot:1.21
	sce_3_30_20030627:1.20
	EndRw-branch:1.15.0.4
	Root-of-EndRw:1.15
	rwToStl:1.15.0.2
	latest_sce_3_10_20010924:1.7.0.6
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.7.0.4
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.7.0.2
	sce_2_31_20010308:1.7
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.82
date	2011.09.30.15.41.54;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2011.09.29.18.22.24;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2011.09.28.23.49.31;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2011.09.28.20.02.45;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2011.09.28.18.32.23;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2011.09.24.00.27.53;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2011.08.30.20.17.38;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2011.08.26.22.54.46;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2011.08.25.23.27.02;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2011.02.09.19.13.23;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.29.22.32.31;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.28.18.08.30;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.27.23.06.03;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.21.15.28.01;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.20.23.18.42;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2010.05.19.21.09.04;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2010.05.13.18.36.17;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2009.11.17.23.45.47;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2009.11.17.22.54.48;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.07.22.08.37;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2008.02.22.21.36.10;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.21.23.58.46;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.14.17.18.54;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.08.01.21.28.04;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.31.20.39.46;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.03.02.20.56.22;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.28.20.04.57;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2006.12.27.20.19.29;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2006.12.27.19.55.08;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.22.17.24.35;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.18.22.27.40;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.17.19.36.39;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.28.20.21.29;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.19.19.17.06;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.02.17.40.29;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.02.17.34.02;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.01.20.35.54;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.01.18.29.12;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.28.22.28.08;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.21.22.23.34;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.19.19.21.17;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.18.20.56.21;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.26.23.02.18;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.15.19.58.21;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.13.19.31.57;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.08.21.16.36;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.24.19.42.38;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.19.21.38.03;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.13.21.18.46;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.12.15.09.23;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.11.16.36.17;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.10.22.53.19;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.27.21.00.29;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.26.20.40.26;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.17.20.23.47;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.11.21.30.54;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.10.23.57.45;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.24.23.08.17;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.10.22.58.16;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.11.19.35.37;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.14.20.12.56;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.23.20.47.16;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.02.23.40.42;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.22.18.32;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.29.17.57.49;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.09.19.52.32;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.05.19.31.33;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.21.58.54;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.20.14.59;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.03.19.58.27;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.01.14.25.57;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.18.14.02.36;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.20.00.44.18;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.06.19.58.38;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.14.22.38.34;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.13.17.08.58;	author fasano;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.10.23.17.43;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.12;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.24;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.24;	author wit;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Relocated the proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Misc.C"
//
// Contains the implementation of the following classes and templates:
//
//    Session
//    ProbAssoc
//    Variant
//    NodeTable
//    ExecPerSched <Entry>.
//    OptStarter
//------------------------------------------------------------------------------

#include <Assoc.h>
#include <Session.h>
#include <wit/src/Variant.h>
#include <NodeTable.h>
#include <ExecPerSch.h>
#include <OptStarter.h>
#include <CompMgr.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Node.h>
#include <BopEntry.h>
#include <ApiMgr.h>
#include <FSS.h>
#include <MsgFac.h>
#include <MsgFrag.h>
#include <ObjStack.h>

#include <ctype.h>
#include <time.h>
#include <errno.h>

//------------------------------------------------------------------------------
// Defining EXE_TYPE_TEXT, which will be the initial value for
// Session::exeTypeText_.
//------------------------------------------------------------------------------

#ifndef EXE_TYPE

#define EXE_TYPE unknown

#endif

#define STR(x)  #x
#define XSTR(x) STR (x)

#define EXE_TYPE_TEXT XSTR (EXE_TYPE)

//------------------------------------------------------------------------------
// Implementation of class Session.
//------------------------------------------------------------------------------

const char * WitSession::proprietaryStmt_ =
   "\n"
   "=======================================================\n"
   "Licensed Materials - Property of IBM\n"
   "\n"
   "Watson Implosion Technology\n"
   "\n"
   "(C) Copyright IBM Corp. 1993, 2011  All Rights Reserved\n"
   "\n"
   "US Government Users Restricted Rights -\n"
   "Use, duplication or disclosure restricted by\n"
   "GSA ADP Schedule Contract with IBM Corp.\n"
   "=======================================================\n";

//------------------------------------------------------------------------------

WitSession::WitSession (WitApiMgr * theApiMgr):

      myApiMgr_    (theApiMgr),
      myWitRun_    (theApiMgr->myWitRun ()),
      myMsgFacPtr_ (NULL),
      exeTypeText_ (EXE_TYPE_TEXT),
      startTime_   (currentTime ()),
      myProblem_   (NULL)
   {
   myMsgFacPtr_ = new WitMsgFacility (this);

   if (not exeTypeText_.isNull ())
      exeTypeText_[0] = toupper (exeTypeText_[0]);
   }

//------------------------------------------------------------------------------

WitSession::~WitSession ()
   {
   delete myProblem_;

   myProblem_ = NULL;

   delete myMsgFacPtr_;
   }

//------------------------------------------------------------------------------

void WitSession::writeHeading (FILE * outFile)
   {
   fprintf (outFile,
      "%s\n"
      "Watson Implosion Technology\n"
      "Release         %s\n"
      "Build Date:     %s\n"
      "CPLEX Embedded? %s\n"
      "Build Type:     %s\n"
      "Run Started At: %s\n",
      proprietaryStmt_,
      RELEASE_NO,
      __DATE__,
      WitOptComp::cplexEmbedded ()? "Yes": "No",
      exeTypeText_.myCstring (),
      startTime_.myCstring ());
   }

//------------------------------------------------------------------------------

void WitSession::printHeading ()
   {
   const char * embFragID;

   embFragID = WitOptComp::cplexEmbedded ()? "yesFrag": "noFrag";

   myMsgFac () ("headingMsg",
      proprietaryStmt_,
      RELEASE_NO,
      __DATE__,
      myMsgFac ().myFrag (embFragID),
      exeTypeText_,
      startTime_);
   }

//------------------------------------------------------------------------------

void WitSession::activate ()
   {
   deactivate ();

   printHeading ();

   myProblem_ = new WitProblem (this);
   }

//------------------------------------------------------------------------------

void WitSession::deactivate ()
   {
   delete myProblem_;

   myProblem_ = NULL;

   myApiMgr ()->resetInputID ();
   }

//------------------------------------------------------------------------------

void WitSession::copyData (WitSession * srcSession)
   {
   if (srcSession == this)
      return;

   activate ();

   srcSession->myProblem ()->copyProblemInto (myProblem ());
   }

//------------------------------------------------------------------------------
// openFile (...)
//
// Note that errno is global and therefore its value is not completely reliable
// in a multi-threaded environment. However, the risk of it having the wrong
// value seems to be minimal.
//------------------------------------------------------------------------------

FILE * WitSession::openFile (const char * fileName, const char * mode)
   {
   FILE * openedFile;

   errno      = 0;

   openedFile = fopen (fileName, mode);

   if (not openedFile)
      myMsgFac () (
         "fopenSmsg",
         fileName,
         mode,
         errno,
         strerror (errno));

   return openedFile;
   }

//------------------------------------------------------------------------------

#if defined(NO_TIME_T)

const char * WitSession::currentTime ()
   {
   return "<Date Unknown>\n";
   }

#else

const char * WitSession::currentTime ()
   {
   time_t startTime_t;

   startTime_t = time (NULL);

   return ctime (& startTime_t);
   }

#endif

//------------------------------------------------------------------------------
// Implementation of class ProbAssoc.
//------------------------------------------------------------------------------

FILE * WitProbAssoc::msgFile () const
   {
   return myMsgFac ().myFile ();
   }

//------------------------------------------------------------------------------

bool WitProbAssoc::tempParIsSet (int index)
   {
   return myGlobalComp ()->tempParIsSet (index);
   }

//------------------------------------------------------------------------------

FILE * WitProbAssoc::openFile (const char * fileName, const char * mode)
   {
   return myProblem_->mySession ()->openFile (fileName, mode);
   }

//------------------------------------------------------------------------------

bool WitProbAssoc::fssComputed () const
   {
   return myProblem_->myFSS ()->computed ();
   }

//------------------------------------------------------------------------------

bool WitProbAssoc::selPrintLevelAt (int theLevel)
   {
   return (myGlobalComp ()->selPrintLevel () >= theLevel);
   }

//------------------------------------------------------------------------------

WitProbAssoc::WitProbAssoc (WitProblem * theProblem):

      myProblem_ (NULL)
   {
   witAssert (theProblem != NULL);

   myProblem_ = theProblem;
   }

//------------------------------------------------------------------------------

WitProbAssoc::WitProbAssoc (const WitProbAssoc * theProbAssoc):

      myProblem_ (theProbAssoc->myProblem_)
   {
   }

//------------------------------------------------------------------------------

WitProbAssoc::~WitProbAssoc ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class Variant
//------------------------------------------------------------------------------

WitVariant::WitVariant (WitProblem * theProblem):

      myProblem_        (theProblem),
      myFragID_         (""),
      internalSoln_     (false),
      compsSecScheds_   (false),
      respectsLotSizes_ (false),
      respectsOptCons_  (false)
   {
   myProblem ()->store (this);
   }

//------------------------------------------------------------------------------

WitVariant::~WitVariant ()
   {
   }

//------------------------------------------------------------------------------

void WitVariant::configure ()
   {
   bool isOpt;
   bool isExtOpt;
   bool isHeur;
   bool isHeurOpt;
   bool isInput;

   isOpt     = (this == myProblem ()->optVariant     ());
   isExtOpt  = (this == myProblem ()->extOptVariant  ());
   isHeur    = (this == myProblem ()->heurVariant    ());
   isHeurOpt = (this == myProblem ()->heurOptVariant ());
   isInput   = (this == myProblem ()->inputVariant   ());

   myFragID_ =
      isOpt?     "optImpFrag":
      isExtOpt?  "extOptImpFrag":
      isHeur?    "heurImpAllFrag":
      isHeurOpt? "heurOptImpFrag":
      isInput?   "userInputFrag":
                 "";

   internalSoln_     = isOpt or isExtOpt or isHeur or isHeurOpt;
   compsSecScheds_   = isOpt or isExtOpt;
   respectsLotSizes_ =                      isHeur              or isInput;
   respectsOptCons_  = isOpt or isExtOpt                        or isInput;
   }

//------------------------------------------------------------------------------

void WitVariant::becomesCurrent ()
   {
   myProblem ()->makeCurrent (this);
   }

//------------------------------------------------------------------------------

bool WitVariant::isCurrent ()
   {
   return (this == myProblem ()->currentVariant ());
   }

//------------------------------------------------------------------------------
// Implementation of class NodeTable.
//------------------------------------------------------------------------------

void WitNodeTable::remove (WitNode * theNode)
   {
   const char *         theName;
   WitNodeMap::iterator theItr;

   cachedNode_ = NULL;

   theName     = theNode->nodeName ().myCstring ();

   theItr      = myNodeMap_.find (theName);

   witAssert (theItr != myNodeMap_.end ());

   myNodeMap_.erase (theItr);
   }

//------------------------------------------------------------------------------

void WitNodeTable::purge ()
   {
   WitNodeMap::iterator theItr;

   cachedNode_ = NULL;

   theItr      = myNodeMap_.begin ();

   while (theItr != myNodeMap_.end ())
      {
      if (theItr->second->selForDel ())
         myNodeMap_.erase (theItr ++);
      else
         theItr ++;
      }
   }

//------------------------------------------------------------------------------

WitNodeTable::WitNodeTable (WitProblem * theProblem):

      WitProbAssoc (theProblem),

      myNodeMap_   (),
      cachedNode_  (NULL)
   {
   }

//------------------------------------------------------------------------------

WitNodeTable::~WitNodeTable ()
   {
   }

//------------------------------------------------------------------------------

void WitNodeTable::insertNode (WitNode * theNode)
   {
   const char * theName;

   theName = theNode->nodeName ().myCstring ();

   witAssert (findNode (theName) == NULL);

   myNodeMap_[theName] = theNode;

   cachedNode_         = theNode;
   }

//------------------------------------------------------------------------------

WitNode * WitNodeTable::findNode (const char * theName)
   {
   WitNodeMap::iterator theItr;

   if (cachedNode_ != NULL)
      if (cachedNode_->nodeName () == theName)
         return cachedNode_;

   theItr = myNodeMap_.find (theName);

   if (theItr == myNodeMap_.end ())
      return NULL;

   cachedNode_ = theItr->second;

   return theItr->second;
   }

//------------------------------------------------------------------------------
// Implementation of class template ExecPerSched.
//------------------------------------------------------------------------------

template <typename Entry>
      WitExecPerSched <Entry>::WitExecPerSched (WitProblem * theProblem):

         WitProbAssoc  (theProblem),
         firstExecPer_ (theProblem, -1),
         lastExecPer_  (theProblem, -2)
   {
   WitObjStack <Entry> theEntries (myProblem ());
   Entry *             theEntry;
   WitPeriod           execPer;
   WitPeriod           impactPer;

   Entry::getAllInstances (myProblem (), theEntries);

   while (theEntries.pop (theEntry))
      forEachPeriod (execPer, myProblem ())
         {
         if (not theEntry->inEffect (execPer))
            continue;

         impactPer = theEntry->impactPeriod ()[execPer];

         if (firstExecPer_ (theEntry)[impactPer] == -1)
             firstExecPer_ (theEntry)[impactPer] = execPer;

         lastExecPer_      (theEntry)[impactPer] = execPer;
         }
   }

//------------------------------------------------------------------------------

template <typename Entry>
      WitExecPerSched <Entry>::~WitExecPerSched ()
   {
   }

//------------------------------------------------------------------------------

template <typename Entry>
      void WitExecPerSched <Entry>::getExecPerRange (
         Entry *     theEntry,
         WitPeriod   impactPer,
         WitPeriod & execPerFirst,
         WitPeriod & execPerLast)
   {
   execPerFirst = firstExecPer_ (theEntry)[impactPer];
   execPerLast  = lastExecPer_  (theEntry)[impactPer];
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template ExecPerSched <Entry>.
//------------------------------------------------------------------------------

template class WitExecPerSched <WitBillEntry>;
template class WitExecPerSched <WitBopEntry>;

//------------------------------------------------------------------------------
// Implementation of class OptStarter.
//------------------------------------------------------------------------------

WitOptStarter::WitOptStarter (
         WitOptComp * theOptComp,
         const char * theParamValue,
         WitAttr      theApiAttr,
         WitMsgID     theMsgID,
         bool         externalVal):

      myOptComp_  (theOptComp),
      paramValue_ (theParamValue),
      myApiAttr_  (theApiAttr),
      myMsgID_    (theMsgID),
      external_   (externalVal)
   {
   myOptComp ()->store (this);
   }

//------------------------------------------------------------------------------

WitOptStarter::~WitOptStarter ()
   {
   }

//------------------------------------------------------------------------------

void WitOptStarter::beChosen ()
   {
   myOptComp ()->choose (this);
   }

//------------------------------------------------------------------------------

bool WitOptStarter::isChosen ()
   {
   return (this == myOptComp ()->optInitMethod ());
   }

//------------------------------------------------------------------------------

const WitString & WitOptStarter::paramValue (
      const WitOptStarter * theOptStarter)
   {
   return theOptStarter->paramValue ();
   }

//------------------------------------------------------------------------------

void WitOptStarter::display ()
   {
   myOptComp ()->myMsgFac () (myMsgID_);
   }
@


1.81
log
@Revised some comments.
@
text
@d116 1
d122 2
a123 2
      "Run Started At: %s"
      "%s\n",
d128 1
a128 2
      startTime_.myCstring (),
      proprietaryStmt_);
d140 1
d145 1
a145 2
      startTime_,
      proprietaryStmt_);
@


1.80
log
@Revised the source code proprietary statement.
@
text
@a69 1

@


1.79
log
@Revised the proprietary statement.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.78
log
@Revised the propietery statement in the object code and at run time.
@
text
@d70 1
a70 1
   "Watson Implosion Technology, Release " RELEASE_NO "\n"
d117 1
a117 1
      "Time of Run:    %s"
@


1.77
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d64 17
a110 6
   fprintf (outFile, "Watson Implosion Technology (%s)\n", __DATE__);

   fprintf (outFile, "Build Type: %s\n", exeTypeText_.myCstring ());

   fprintf (outFile, "Release %s\n", RELEASE_NO);

d112 13
a124 8
      "\n"
      "Licensed Materials - Property of IBM\n"
      "(C) COPYRIGHT IBM Corp. 1993,1996,2000,2006\n"
      "All Rights Reserved.\n\n"

      "Run on %s"
      "===============================\n\n",
      startTime_.myCstring ());
d131 1
a131 1
   const char * solverFragID;
d133 1
a133 1
   solverFragID = WitOptComp::cplexEmbedded ()? "cplexFrag": "noSolverFrag";
d136 1
d138 4
a141 4
      RELEASE_NO,
      exeTypeText_.myCstring (),
      myMsgFac ().myFrag (solverFragID),
      startTime_);
@


1.76
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d66 12
a77 12
myApiMgr_    (theApiMgr),
myWitRun_    (theApiMgr->myWitRun ()),
myMsgFacPtr_ (NULL),
exeTypeText_ (EXE_TYPE_TEXT),
startTime_   (currentTime ()),
myProblem_   (NULL)
{
myMsgFacPtr_ = new WitMsgFacility (this);

if (not exeTypeText_.isNull ())
exeTypeText_[0] = toupper (exeTypeText_[0]);
}
d82 2
a83 2
{
delete myProblem_;
d85 1
a85 1
myProblem_ = NULL;
d87 2
a88 2
delete myMsgFacPtr_;
}
d93 2
a94 2
{
fprintf (outFile, "Watson Implosion Technology (%s)\n", __DATE__);
d96 1
a96 1
fprintf (outFile, "Build Type: %s\n", exeTypeText_.myCstring ());
d98 1
a98 1
fprintf (outFile, "Release %s\n", RELEASE_NO);
d100 10
a109 10
fprintf (outFile,
"\n"
"Licensed Materials - Property of IBM\n"
"(C) COPYRIGHT IBM Corp. 1993,2011\n"
"All Rights Reserved.\n\n"

"Run on %s"
"===============================\n\n",
startTime_.myCstring ());
}
d114 2
a115 2
{
const char * solverFragID;
d117 1
a117 1
solverFragID = WitOptComp::cplexEmbedded ()? "cplexFrag": "noSolverFrag";
d119 7
a125 7
myMsgFac () ("headingMsg",
__DATE__,
RELEASE_NO,
exeTypeText_.myCstring (),
myMsgFac ().myFrag (solverFragID),
startTime_);
}
d130 2
a131 2
{
deactivate ();
d133 1
a133 1
printHeading ();
d135 2
a136 2
myProblem_ = new WitProblem (this);
}
d141 2
a142 2
{
delete myProblem_;
d144 1
a144 1
myProblem_ = NULL;
d146 2
a147 2
myApiMgr ()->resetInputID ();
}
d152 3
a154 3
{
if (srcSession == this)
return;
d156 1
a156 1
activate ();
d158 2
a159 2
srcSession->myProblem ()->copyProblemInto (myProblem ());
}
d170 2
a171 2
{
FILE * openedFile;
d173 1
a173 1
errno      = 0;
d175 1
a175 1
openedFile = fopen (fileName, mode);
d177 7
a183 7
if (not openedFile)
myMsgFac () (
"fopenSmsg",
fileName,
mode,
errno,
strerror (errno));
d185 2
a186 2
return openedFile;
}
d193 3
a195 3
{
return "<Date Unknown>\n";
}
d200 2
a201 2
{
time_t startTime_t;
d203 1
a203 1
startTime_t = time (NULL);
d205 2
a206 2
return ctime (& startTime_t);
}
d215 3
a217 3
{
return myMsgFac ().myFile ();
}
d222 3
a224 3
{
return myGlobalComp ()->tempParIsSet (index);
}
d229 3
a231 3
{
return myProblem_->mySession ()->openFile (fileName, mode);
}
d236 3
a238 3
{
return myProblem_->myFSS ()->computed ();
}
d243 3
a245 3
{
return (myGlobalComp ()->selPrintLevel () >= theLevel);
}
d251 3
a253 3
myProblem_ (NULL)
{
witAssert (theProblem != NULL);
d255 2
a256 2
myProblem_ = theProblem;
}
d262 3
a264 3
myProblem_ (theProbAssoc->myProblem_)
{
}
d269 2
a270 2
{
}
d278 9
a286 9
myProblem_        (theProblem),
myFragID_         (""),
internalSoln_     (false),
compsSecScheds_   (false),
respectsLotSizes_ (false),
respectsOptCons_  (false)
{
myProblem ()->store (this);
}
d291 2
a292 2
{
}
d297 26
a322 26
{
bool isOpt;
bool isExtOpt;
bool isHeur;
bool isHeurOpt;
bool isInput;

isOpt     = (this == myProblem ()->optVariant     ());
isExtOpt  = (this == myProblem ()->extOptVariant  ());
isHeur    = (this == myProblem ()->heurVariant    ());
isHeurOpt = (this == myProblem ()->heurOptVariant ());
isInput   = (this == myProblem ()->inputVariant   ());

myFragID_ =
isOpt?     "optImpFrag":
isExtOpt?  "extOptImpFrag":
isHeur?    "heurImpAllFrag":
isHeurOpt? "heurOptImpFrag":
isInput?   "userInputFrag":
"";

internalSoln_     = isOpt or isExtOpt or isHeur or isHeurOpt;
compsSecScheds_   = isOpt or isExtOpt;
respectsLotSizes_ =                      isHeur              or isInput;
respectsOptCons_  = isOpt or isExtOpt                        or isInput;
}
d327 3
a329 3
{
myProblem ()->makeCurrent (this);
}
d334 3
a336 3
{
return (this == myProblem ()->currentVariant ());
}
d343 3
a345 3
{
const char *         theName;
WitNodeMap::iterator theItr;
d347 1
a347 1
cachedNode_ = NULL;
d349 1
a349 1
theName     = theNode->nodeName ().myCstring ();
d351 1
a351 1
theItr      = myNodeMap_.find (theName);
d353 1
a353 1
witAssert (theItr != myNodeMap_.end ());
d355 2
a356 2
myNodeMap_.erase (theItr);
}
d361 2
a362 2
{
WitNodeMap::iterator theItr;
d364 1
a364 1
cachedNode_ = NULL;
d366 1
a366 1
theItr      = myNodeMap_.begin ();
d368 8
a375 8
while (theItr != myNodeMap_.end ())
{
if (theItr->second->selForDel ())
myNodeMap_.erase (theItr ++);
else
theItr ++;
}
}
d381 1
a381 1
WitProbAssoc (theProblem),
d383 4
a386 4
myNodeMap_   (),
cachedNode_  (NULL)
{
}
d391 2
a392 2
{
}
d397 2
a398 2
{
const char * theName;
d400 1
a400 1
theName = theNode->nodeName ().myCstring ();
d402 1
a402 1
witAssert (findNode (theName) == NULL);
d404 1
a404 1
myNodeMap_[theName] = theNode;
d406 2
a407 2
cachedNode_         = theNode;
}
d412 2
a413 2
{
WitNodeMap::iterator theItr;
d415 3
a417 3
if (cachedNode_ != NULL)
if (cachedNode_->nodeName () == theName)
return cachedNode_;
d419 1
a419 1
theItr = myNodeMap_.find (theName);
d421 2
a422 2
if (theItr == myNodeMap_.end ())
return NULL;
d424 1
a424 1
cachedNode_ = theItr->second;
d426 2
a427 2
return theItr->second;
}
d434 1
a434 1
WitExecPerSched <Entry>::WitExecPerSched (WitProblem * theProblem):
d436 25
a460 25
WitProbAssoc  (theProblem),
firstExecPer_ (theProblem, -1),
lastExecPer_  (theProblem, -2)
{
WitObjStack <Entry> theEntries (myProblem ());
Entry *             theEntry;
WitPeriod           execPer;
WitPeriod           impactPer;

Entry::getAllInstances (myProblem (), theEntries);

while (theEntries.pop (theEntry))
forEachPeriod (execPer, myProblem ())
{
if (not theEntry->inEffect (execPer))
continue;

impactPer = theEntry->impactPeriod ()[execPer];

if (firstExecPer_ (theEntry)[impactPer] == -1)
firstExecPer_ (theEntry)[impactPer] = execPer;

lastExecPer_      (theEntry)[impactPer] = execPer;
}
}
d465 3
a467 3
WitExecPerSched <Entry>::~WitExecPerSched ()
{
}
d472 9
a480 9
void WitExecPerSched <Entry>::getExecPerRange (
Entry *     theEntry,
WitPeriod   impactPer,
WitPeriod & execPerFirst,
WitPeriod & execPerLast)
{
execPerFirst = firstExecPer_ (theEntry)[impactPer];
execPerLast  = lastExecPer_  (theEntry)[impactPer];
}
d494 14
a507 14
WitOptComp * theOptComp,
const char * theParamValue,
WitAttr      theApiAttr,
WitMsgID     theMsgID,
bool         externalVal):

myOptComp_  (theOptComp),
paramValue_ (theParamValue),
myApiAttr_  (theApiAttr),
myMsgID_    (theMsgID),
external_   (externalVal)
{
myOptComp ()->store (this);
}
d512 2
a513 2
{
}
d518 3
a520 3
{
myOptComp ()->choose (this);
}
d525 3
a527 3
{
return (this == myOptComp ()->optInitMethod ());
}
d532 4
a535 4
const WitOptStarter * theOptStarter)
{
return theOptStarter->paramValue ();
}
d540 3
a542 3
{
myOptComp ()->myMsgFac () (myMsgID_);
}
@


1.75
log
@Revisions for the removal of COIN.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d66 12
a77 12
      myApiMgr_    (theApiMgr),
      myWitRun_    (theApiMgr->myWitRun ()),
      myMsgFacPtr_ (NULL),
      exeTypeText_ (EXE_TYPE_TEXT),
      startTime_   (currentTime ()),
      myProblem_   (NULL)
   {
   myMsgFacPtr_ = new WitMsgFacility (this);

   if (not exeTypeText_.isNull ())
      exeTypeText_[0] = toupper (exeTypeText_[0]);
   }
d82 2
a83 2
   {
   delete myProblem_;
d85 1
a85 1
   myProblem_ = NULL;
d87 2
a88 2
   delete myMsgFacPtr_;
   }
d93 2
a94 2
   {
   fprintf (outFile, "Watson Implosion Technology (%s)\n", __DATE__);
d96 1
a96 1
   fprintf (outFile, "Build Type: %s\n", exeTypeText_.myCstring ());
d98 1
a98 1
   fprintf (outFile, "Release %s\n", RELEASE_NO);
d100 10
a109 10
   fprintf (outFile,
      "\n"
      "Licensed Materials - Property of IBM\n"
      "(C) COPYRIGHT IBM Corp. 1993,1996,2000,2006\n"
      "All Rights Reserved.\n\n"

      "Run on %s"
      "===============================\n\n",
      startTime_.myCstring ());
   }
d114 2
a115 2
   {
   const char * solverFragID;
d117 1
a117 1
   solverFragID = WitOptComp::cplexEmbedded ()? "cplexFrag": "noSolverFrag";
d119 7
a125 7
   myMsgFac () ("headingMsg",
      __DATE__,
      RELEASE_NO,
      exeTypeText_.myCstring (),
      myMsgFac ().myFrag (solverFragID),
      startTime_);
   }
d130 2
a131 2
   {
   deactivate ();
d133 1
a133 1
   printHeading ();
d135 2
a136 2
   myProblem_ = new WitProblem (this);
   }
d141 2
a142 2
   {
   delete myProblem_;
d144 1
a144 1
   myProblem_ = NULL;
d146 2
a147 2
   myApiMgr ()->resetInputID ();
   }
d152 3
a154 3
   {
   if (srcSession == this)
      return;
d156 1
a156 1
   activate ();
d158 2
a159 2
   srcSession->myProblem ()->copyProblemInto (myProblem ());
   }
d170 2
a171 2
   {
   FILE * openedFile;
d173 1
a173 1
   errno      = 0;
d175 1
a175 1
   openedFile = fopen (fileName, mode);
d177 7
a183 7
   if (not openedFile)
      myMsgFac () (
         "fopenSmsg",
         fileName,
         mode,
         errno,
         strerror (errno));
d185 2
a186 2
   return openedFile;
   }
d193 3
a195 3
   {
   return "<Date Unknown>\n";
   }
d200 2
a201 2
   {
   time_t startTime_t;
d203 1
a203 1
   startTime_t = time (NULL);
d205 2
a206 2
   return ctime (& startTime_t);
   }
d215 3
a217 3
   {
   return myMsgFac ().myFile ();
   }
d222 3
a224 3
   {
   return myGlobalComp ()->tempParIsSet (index);
   }
d229 3
a231 3
   {
   return myProblem_->mySession ()->openFile (fileName, mode);
   }
d236 3
a238 3
   {
   return myProblem_->myFSS ()->computed ();
   }
d243 3
a245 3
   {
   return (myGlobalComp ()->selPrintLevel () >= theLevel);
   }
d251 3
a253 3
      myProblem_ (NULL)
   {
   witAssert (theProblem != NULL);
d255 2
a256 2
   myProblem_ = theProblem;
   }
d262 3
a264 3
      myProblem_ (theProbAssoc->myProblem_)
   {
   }
d269 2
a270 2
   {
   }
d278 9
a286 9
      myProblem_        (theProblem),
      myFragID_         (""),
      internalSoln_     (false),
      compsSecScheds_   (false),
      respectsLotSizes_ (false),
      respectsOptCons_  (false)
   {
   myProblem ()->store (this);
   }
d291 2
a292 2
   {
   }
d297 26
a322 26
   {
   bool isOpt;
   bool isExtOpt;
   bool isHeur;
   bool isHeurOpt;
   bool isInput;

   isOpt     = (this == myProblem ()->optVariant     ());
   isExtOpt  = (this == myProblem ()->extOptVariant  ());
   isHeur    = (this == myProblem ()->heurVariant    ());
   isHeurOpt = (this == myProblem ()->heurOptVariant ());
   isInput   = (this == myProblem ()->inputVariant   ());

   myFragID_ =
      isOpt?     "optImpFrag":
      isExtOpt?  "extOptImpFrag":
      isHeur?    "heurImpAllFrag":
      isHeurOpt? "heurOptImpFrag":
      isInput?   "userInputFrag":
                 "";

   internalSoln_     = isOpt or isExtOpt or isHeur or isHeurOpt;
   compsSecScheds_   = isOpt or isExtOpt;
   respectsLotSizes_ =                      isHeur              or isInput;
   respectsOptCons_  = isOpt or isExtOpt                        or isInput;
   }
d327 3
a329 3
   {
   myProblem ()->makeCurrent (this);
   }
d334 3
a336 3
   {
   return (this == myProblem ()->currentVariant ());
   }
d343 3
a345 3
   {
   const char *         theName;
   WitNodeMap::iterator theItr;
d347 1
a347 1
   cachedNode_ = NULL;
d349 1
a349 1
   theName     = theNode->nodeName ().myCstring ();
d351 1
a351 1
   theItr      = myNodeMap_.find (theName);
d353 1
a353 1
   witAssert (theItr != myNodeMap_.end ());
d355 2
a356 2
   myNodeMap_.erase (theItr);
   }
d361 2
a362 2
   {
   WitNodeMap::iterator theItr;
d364 1
a364 1
   cachedNode_ = NULL;
d366 1
a366 1
   theItr      = myNodeMap_.begin ();
d368 8
a375 8
   while (theItr != myNodeMap_.end ())
      {
      if (theItr->second->selForDel ())
         myNodeMap_.erase (theItr ++);
      else
         theItr ++;
      }
   }
d381 1
a381 1
      WitProbAssoc (theProblem),
d383 4
a386 4
      myNodeMap_   (),
      cachedNode_  (NULL)
   {
   }
d391 2
a392 2
   {
   }
d397 2
a398 2
   {
   const char * theName;
d400 1
a400 1
   theName = theNode->nodeName ().myCstring ();
d402 1
a402 1
   witAssert (findNode (theName) == NULL);
d404 1
a404 1
   myNodeMap_[theName] = theNode;
d406 2
a407 2
   cachedNode_         = theNode;
   }
d412 2
a413 2
   {
   WitNodeMap::iterator theItr;
d415 3
a417 3
   if (cachedNode_ != NULL)
      if (cachedNode_->nodeName () == theName)
         return cachedNode_;
d419 1
a419 1
   theItr = myNodeMap_.find (theName);
d421 2
a422 2
   if (theItr == myNodeMap_.end ())
      return NULL;
d424 1
a424 1
   cachedNode_ = theItr->second;
d426 2
a427 2
   return theItr->second;
   }
d434 1
a434 1
      WitExecPerSched <Entry>::WitExecPerSched (WitProblem * theProblem):
d436 25
a460 25
         WitProbAssoc  (theProblem),
         firstExecPer_ (theProblem, -1),
         lastExecPer_  (theProblem, -2)
   {
   WitObjStack <Entry> theEntries (myProblem ());
   Entry *             theEntry;
   WitPeriod           execPer;
   WitPeriod           impactPer;

   Entry::getAllInstances (myProblem (), theEntries);

   while (theEntries.pop (theEntry))
      forEachPeriod (execPer, myProblem ())
         {
         if (not theEntry->inEffect (execPer))
            continue;

         impactPer = theEntry->impactPeriod ()[execPer];

         if (firstExecPer_ (theEntry)[impactPer] == -1)
             firstExecPer_ (theEntry)[impactPer] = execPer;

         lastExecPer_      (theEntry)[impactPer] = execPer;
         }
   }
d465 3
a467 3
      WitExecPerSched <Entry>::~WitExecPerSched ()
   {
   }
d472 9
a480 9
      void WitExecPerSched <Entry>::getExecPerRange (
         Entry *     theEntry,
         WitPeriod   impactPer,
         WitPeriod & execPerFirst,
         WitPeriod & execPerLast)
   {
   execPerFirst = firstExecPer_ (theEntry)[impactPer];
   execPerLast  = lastExecPer_  (theEntry)[impactPer];
   }
d494 14
a507 14
         WitOptComp * theOptComp,
         const char * theParamValue,
         WitAttr      theApiAttr,
         WitMsgID     theMsgID,
         bool         externalVal):

      myOptComp_  (theOptComp),
      paramValue_ (theParamValue),
      myApiAttr_  (theApiAttr),
      myMsgID_    (theMsgID),
      external_   (externalVal)
   {
   myOptComp ()->store (this);
   }
d512 2
a513 2
   {
   }
d518 3
a520 3
   {
   myOptComp ()->choose (this);
   }
d525 3
a527 3
   {
   return (this == myOptComp ()->optInitMethod ());
   }
d532 4
a535 4
      const WitOptStarter * theOptStarter)
   {
   return theOptStarter->paramValue ();
   }
d540 3
a542 3
   {
   myOptComp ()->myMsgFac () (myMsgID_);
   }
@


1.74
log
@Removed COIN from WIT.
@
text
@a34 1
#include <SolverMgr.h>
d117 1
a117 2
   solverFragID =
      WitSolverMgr::cplexEmbedded ()? "cplexFrag": "noSolverFrag";
@


1.73
log
@CPLEX
@
text
@a115 1
   bool         bothEmbedded;
a117 4
   bothEmbedded =
      WitSolverMgr:: coinEmbedded () and
      WitSolverMgr::cplexEmbedded ();

d119 1
a119 4
                     bothEmbedded   ? "coinCplexFrag":
      WitSolverMgr:: coinEmbedded ()? "coinFrag":
      WitSolverMgr::cplexEmbedded ()? "cplexFrag":
                                      "noSolverFrag";
@


1.72
log
@Selection reuse.
@
text
@d35 1
d116 1
d119 4
d124 4
a127 4
      (coinEmbedded () and cplexEmbedded ())? "coinCplexFrag":
       coinEmbedded ()?                       "coinFrag":
      cplexEmbedded ()?                       "cplexFrag":
                                              "noSolverFrag";
@


1.71
log
@CPLEX
@
text
@d241 8
a248 1
   return myProblem ()->myFSS ()->computed ();
@


1.70
log
@CPLEX
@
text
@d118 4
a121 4
      (COIN_EMBEDDED and cplexEmbedded ())? "coinCplexFrag":
       COIN_EMBEDDED?                       "coinFrag":
      cplexEmbedded ()?                     "cplexFrag":
                                            "noSolverFrag";
@


1.69
log
@CPLEX
@
text
@d118 4
a121 4
      (COIN_EMBEDDED and CPLEX_EMBEDDED)? "coinCplexFrag":
       COIN_EMBEDDED?                     "coinFrag":
      CPLEX_EMBEDDED?                     "cplexFrag":
                                          "noSolverFrag";
@


1.68
log
@CPLEX
@
text
@d117 5
a121 11
   if (WitOptComp::coinEmbedded () and WitOptComp::cplexEmbedded ())
      solverFragID = "coinCplexFrag";

   else if (WitOptComp::coinEmbedded ())
      solverFragID = "coinFrag";

   else if (WitOptComp::cplexEmbedded ())
      solverFragID = "cplexFrag";

   else
      solverFragID = "noSolverFrag";
@


1.67
log
@Preparing for embedded CPLEX.
@
text
@d117 11
a127 4
   solverFragID =
      WitOptComp::coinEmbedded ()?
         "coinFrag":
         "noSolverFrag";
@


1.66
log
@Revising the build procedure.
@
text
@d118 1
a118 1
      COIN_EMBEDDED?
@


1.65
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d37 1
d115 7
d124 1
d126 1
a126 1
      RELEASE_NO,
@


1.64
log
@Removing objective #2.
@
text
@d30 1
a30 1
#include <Global.h>
@


1.63
log
@Removing objective #2.
@
text
@a214 7
WitObjFunc * WitProbAssoc::objChoice () const
   {
   return myOptComp ()->objChoice ();
   }

//------------------------------------------------------------------------------

@


1.62
log
@Made WIT operate in multi-thread mode unconditionally.
The multithread attribute in no longer meaningful.
@
text
@d13 1
a13 1
// Contains the implementation of the following classes:
d19 2
a20 2
//
// Contains the implementation of class template ExecPerSched <Entry>.
d28 1
d482 55
@


1.61
log
@Object name changing.
@
text
@d155 6
d172 1
a172 1
         (WitApiMgr::multiThread ()? "fopenMTSmsg": "fopenSmsg"),
@


1.60
log
@Object name change.
@
text
@d329 18
@


1.59
log
@Stochastic Implosion
@
text
@d329 19
d365 1
a365 1
void WitNodeTable::insert (WitNode * theNode)
d371 1
a371 1
   witAssert (namedNode (theName) == NULL);
d380 1
a380 1
WitNode * WitNodeTable::namedNode (const char * theName)
a398 19

void WitNodeTable::purge ()
   {
   WitNodeMap::iterator theItr;

   cachedNode_ = NULL;

   theItr      = myNodeMap_.begin ();

   while (theItr != myNodeMap_.end ())
      {
      if (theItr->second->selForDel ())
         myNodeMap_.erase (theItr ++);
      else
         theItr ++;
      }
   }

//------------------------------------------------------------------------------
@


1.58
log
@Stochastic Implosion
@
text
@d31 1
@


1.57
log
@Stochastic Implosion
@
text
@d200 1
a200 2
WitProbAssoc::WitProbAssoc (WitProblem * theProblem):
      myProblem_ (NULL)
d202 4
a205 1
   witAssert (theProblem != NULL);
d207 3
a209 1
   myProblem_ = theProblem;
d214 1
a214 1
WitProbAssoc::~WitProbAssoc ()
d216 1
d221 1
a221 1
FILE * WitProbAssoc::msgFile () const
d223 1
a223 1
   return myMsgFac ().myFile ();
d228 1
a228 1
WitObjFunc * WitProbAssoc::objChoice () const
d230 1
a230 1
   return myOptComp ()->objChoice ();
d235 3
a237 1
bool WitProbAssoc::tempParIsSet (int index)
d239 3
a241 1
   return myGlobalComp ()->tempParIsSet (index);
d246 3
a248 1
FILE * WitProbAssoc::openFile (const char * fileName, const char * mode)
a249 1
   return myProblem_->mySession ()->openFile (fileName, mode);
d254 1
a254 1
bool WitProbAssoc::fssComputed () const
a255 1
   return myProblem ()->myFSS ()->computed ();
@


1.56
log
@[disallowed backlog]
@
text
@d19 2
d27 1
d31 1
d387 60
@


1.55
log
@[disallowed backlog]
@
text
@d251 6
a256 7
      myProblem_           (theProblem),
      myFragID_            (""),
      internalSoln_        (false),
      compsSecScheds_      (false),
      respectsAllBounds_   (false),
      respectsLotSizes_    (false),
      respectsIntegrality_ (false)
d271 11
a281 5
   const bool isOpt     = (this == myProblem ()->optVariant     ());
   const bool isExtOpt  = (this == myProblem ()->extOptVariant  ());
   const bool isHeur    = (this == myProblem ()->heurVariant    ());
   const bool isHeurOpt = (this == myProblem ()->heurOptVariant ());
   const bool isInput   = (this == myProblem ()->inputVariant   ());
d291 4
a294 5
   internalSoln_        = isOpt or isExtOpt or isHeur or isHeurOpt;
   compsSecScheds_      = isOpt or isExtOpt;
   respectsAllBounds_   = isOpt or isExtOpt                        or isInput;
   respectsLotSizes_    =                      isHeur              or isInput;
   respectsIntegrality_ = isOpt or isExtOpt                        or isInput;
@


1.54
log
@External opt implosion.
@
text
@a69 2

   WitCompMgr::transmitAllDMPs ();
@


1.53
log
@External optimizing implosion.
@
text
@d274 5
a278 5
   const bool isOpt     = (this == myProblem ()->myOptVariant     ());
   const bool isExtOpt  = (this == myProblem ()->myExtOptVariant  ());
   const bool isHeur    = (this == myProblem ()->myHeurVariant    ());
   const bool isHeurOpt = (this == myProblem ()->myHeurOptVariant ());
   const bool isInput   = (this == myProblem ()->myInputVariant   ());
@


1.52
log
@External optimizing implosion.
@
text
@d275 1
d282 1
d288 5
a292 5
   internalSoln_        = not isInput;
   compsSecScheds_      =     isOpt;
   respectsAllBounds_   =     isOpt  or isInput;
   respectsLotSizes_    =     isHeur or isInput;
   respectsIntegrality_ =     isOpt  or isInput;
@


1.51
log
@App controlled opt implosion.
@
text
@d253 7
a259 6
      myProblem_         (theProblem),
      myFragID_          (""),
      internalSoln_      (false),
      compsSecScheds_    (false),
      respectsAllBounds_ (false),
      respectsLotSizes_  (false)
d286 5
a290 4
   internalSoln_      = not isInput;
   compsSecScheds_    =     isOpt;
   respectsAllBounds_ =     isOpt  or isInput;
   respectsLotSizes_  =     isHeur or isInput;
@


1.50
log
@App controlled opt implosion.
@
text
@a17 1
//    DataAlt
a23 1
#include <DataAlt.h>
a305 22
// Implementation of class DataAlt.
//------------------------------------------------------------------------------

WitDataAlt::WitDataAlt (WitProblem * theProblem):
      WitProbAssoc (theProblem)
   {
   }

//------------------------------------------------------------------------------

WitDataAlt::~WitDataAlt ()
   {
   }

//------------------------------------------------------------------------------

void WitDataAlt::incur ()
   {
   myProblem ()->incur (this);
   }

//------------------------------------------------------------------------------
@


1.49
log
@Removed optimizing implosion with lot sizes.
@
text
@d324 1
a324 1
void WitDataAlt::incur () const
@


1.48
log
@Fixed a bug in witPurgeData.
@
text
@a307 9

void WitVariant::checkOptWithLotSizes ()
   {
   witAssert (this == myProblem ()->myOptVariant ());

   respectsLotSizes_ = myProblem ()->myOptComp ()->optWithLotSizes ();
   }

//------------------------------------------------------------------------------
@


1.47
log
@Replaced WIT's hash tables with std:maps.
@
text
@d398 3
a400 1
   theItr = myNodeMap_.begin ();
@


1.46
log
@Updated the copyright date on output.
@
text
@d19 1
a19 1
//    HashTable
d26 1
a26 1
#include <Hash.h>
d339 1
a339 1
// Implementation of class HashTable.
d342 1
a342 1
const double WitHashTable::growthFactor_ = 1.5;
d344 1
a344 4
//------------------------------------------------------------------------------

WitHashTable::WitHashTable (WitProblem * theProblem):
      WitProbAssoc   (theProblem),
d346 2
a347 3
      internalTable_ (),
      nNodesHashed_  (0),
      cachedNode_    (NULL)
d353 1
a353 1
WitHashTable::~WitHashTable ()
a354 1
   resize (0);
d359 1
a359 1
void WitHashTable::insert (WitNode * theNode)
d361 1
a361 8
   if (nNodesHashed_ == 0)
      init ();
   else if (nNodesHashed_ >= internalTable_.length ())
      expand ();

   const WitString & theName = theNode->nodeName ();
   const int         key     = hashKey (theName.myCstring ());
   WitNode *         dupNode;
d363 1
a363 7
   if (DEBUG_MODE)
      {
      dupNode = 
         internalTable_ (key).find (& WitNode::nodeName, theName.myCstring ());

      witAssert (dupNode == NULL);
      }
d365 1
a365 1
   internalTable_ (key).prepend (theNode);
d367 1
a367 1
   ++ nNodesHashed_;
d369 1
a369 1
   cachedNode_ = theNode;
d374 1
a374 1
WitNode * WitHashTable::namedNode (const char * theName)
d376 1
a376 2
   if (nNodesHashed_ == 0)
      return NULL;
d382 1
a382 4
   return
      cachedNode_ =
         internalTable_ (hashKey (theName)).find (& WitNode::nodeName, theName);
   }
d384 2
a385 21
//------------------------------------------------------------------------------

void WitHashTable::purge ()
   {
   int i;

   witAssert (myCompMgr ()->purging ());

   nNodesHashed_ = 0;

   for (i = 0; i < internalTable_.length (); ++ i)
      {
      WitDelComp::purgeSelComps (internalTable_ (i));

      nNodesHashed_ += internalTable_ (i).nElements ();
      }

   cachedNode_ = NULL;
   }

//------------------------------------------------------------------------------
d387 1
a387 3
void WitHashTable::init ()
   {
   witAssert (myGlobalComp ()->hashTableSize () > 0);
d389 1
a389 1
   resize (myGlobalComp ()->hashTableSize ());
d394 1
a394 1
void WitHashTable::expand ()
d396 1
a396 11
   int       theKey;
   WitNode * theNode;
   int       newSize;

   WitObjStack <WitNode> hashedNodes (myProblem ());
      //
      // List of Nodes hashed by this HashTable.

   for (theKey = 0; theKey < internalTable_.length (); ++ theKey)
      forEachEl (theNode, internalTable_ (theKey))
         hashedNodes.push (theNode);
d398 1
a398 1
   hashedNodes.reverse ();
d400 1
a400 6
   newSize =
      static_cast <int> (ceil (internalTable_.length () * growthFactor_));

   resize (newSize);

   while (hashedNodes.pop (theNode))
d402 4
a405 3
      theKey = hashKey (theNode->nodeName ().myCstring ());

      internalTable_ (theKey).append (theNode);
a407 30

//------------------------------------------------------------------------------

int WitHashTable::hashKey (const char * theName) const
   {
   int i;
   long int key = 0;

   witAssert (theName != NULL);

   for (i = 0; theName[i] != '\0'; ++ i)
      key += (i + 1) * theName[i];

   return static_cast <int> (key % internalTable_.length ());
   }

//------------------------------------------------------------------------------

void WitHashTable::resize (int theSize)
   {
   int idx;

   for (idx = 0; idx < internalTable_.length (); idx ++)
      delete internalTable_[idx];

   internalTable_.resize (theSize);

   for (idx = 0; idx < internalTable_.length (); idx ++)
      internalTable_[idx] = new WitList <WitNode>;
   }
@


1.45
log
@Updated the copyright date on all source files.
@
text
@d100 1
a100 1
      "(C) COPYRIGHT IBM Corp. 1993,1996,2000\n"
@


1.44
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.43
log
@Corrected a declaration.
@
text
@d33 1
a33 1
#include <Dense.h>
d443 1
a443 1
   WitDenseList <WitNode> hashedNodes (nNodesHashed_);
d449 3
a451 1
         hashedNodes.append (theNode);
d458 1
a458 1
   forEachElDense (theNode, hashedNodes)
@


1.42
log
@[error recovery]
@
text
@d155 1
a155 1
FILE * WitSession::openFile (const char * fileName, const WitString & mode)
d161 1
a161 1
   openedFile = fopen (fileName, mode.myCstring ());
d237 1
a237 1
FILE * WitProbAssoc::openFile (const char * fileName, const WitString & mode)
@


1.41
log
@[error recovery]
@
text
@a28 1
#include <DataRead.h>
a175 8
void WitSession::recordError ()
   {
   if (active ())
      myProblem ()->myDataReader ()->recordError ();
   }

//------------------------------------------------------------------------------

@


1.40
log
@Minor update.
@
text
@d29 1
d177 8
@


1.39
log
@Made WIT's use of errno relatively thread-safe.
@
text
@d65 1
a65 1
      startTime_   (),
a72 14
#if defined(NO_TIME_T)

   startTime_ = "<Date Unknown>\n";

#else

   time_t startTime_t;

   startTime_t = time (NULL);

   startTime_.copyCstring (ctime (& startTime_t));

#endif

d175 22
@


1.38
log
@[multi-thread]
@
text
@d169 1
a169 1
FILE * WitSession::openFile (const WitString & fileName, const WitString & mode)
d173 3
a175 1
   openedFile = fopen (fileName.myCstring (), mode.myCstring ());
d179 1
a179 1
         "fopenSmsg",
d229 1
a229 3
FILE * WitProbAssoc::openFile (
      const WitString & fileName,
      const WitString & mode)
@


1.37
log
@[multi-thread]
@
text
@d87 1
a87 1
   WitCompMgr::transmitData ();
@


1.36
log
@[multi-thread]
@
text
@d86 2
@


1.35
log
@[multi-thread]
@
text
@a58 4
WitSession * WitSession::curSession_ = NULL;

//------------------------------------------------------------------------------

a67 2
   becomesCurrent ();

a85 2

   becomesUncurrent ();
a91 2
   becomesCurrent ();

a96 32

   becomesUncurrent ();
   }

//------------------------------------------------------------------------------

void WitSession::becomesCurrent ()
   {
   if (curSession_ != NULL)
      issueNonMsgFatalError ("WitSession::becomesCurrent");

   curSession_ = this;
   }

//------------------------------------------------------------------------------

void WitSession::becomesUncurrent ()
   {
   if (curSession_ != this)
      issueNonMsgFatalError ("WitSession::becomesUncurrent");

   curSession_ = NULL;
   }

//------------------------------------------------------------------------------

WitSession * WitSession::curSession ()
   {
   if (curSession_ == NULL)
      issueNonMsgFatalError ("WitSession::curSession");

   return curSession_;
@


1.34
log
@[multi-thread]
@
text
@d37 1
d208 19
d267 9
@


1.33
log
@Attempt to fix syntax errors found by the MS compiler.
@
text
@d176 11
a191 4

   printHeading ();

   myProblem_ = new WitProblem (this);
@


1.32
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d36 1
@


1.31
log
@[exceptions]
@
text
@d11 1
a11 1
// Source file: "Hash.C"
@


1.30
log
@Double Precision.
@
text
@d179 1
a179 1
   myApiMgr ()->resetInputId ();
@


1.29
log
@Double Precision.
@
text
@d57 4
d70 2
d90 2
d98 2
d105 32
@


1.28
log
@Double Precision.
@
text
@a145 26
#if 0

void WitSession::activate ()
   {
   deactivate ();

   printHeading ();

   myProblem_ = new WitProblem (this);
   }

//------------------------------------------------------------------------------

void WitSession::deactivate ()
   {
   delete myProblem_;

   myProblem_ = NULL;

   myApiMgr ()->resetInputId ();
   }

#endif

//------------------------------------------------------------------------------

@


1.27
log
@Double Precision.
@
text
@d321 1
a321 1
const float WitHashTable::growthFactor_ = 1.5;
@


1.26
log
@Double Precision.
@
text
@d133 17
d167 2
@


1.25
log
@Continued double precision.
@
text
@a56 4
bool WitSession::doubleMode_ = false;

//------------------------------------------------------------------------------

a126 9
   }

//------------------------------------------------------------------------------

void WitSession::setDoubleMode (bool theVal)
   {
   witAssert (WitProblem::nInstances () == 0);

   doubleMode_ = theVal;
@


1.24
log
@Continued double precision.
@
text
@d57 1
a57 1
bool WitSession::doublePrecision_ = false;
d135 1
a135 1
void WitSession::setDoublePrecision (bool theVal)
d139 1
a139 1
   doublePrecision_ = theVal;
@


1.23
log
@Continued double precision.
@
text
@d146 11
a161 4

   printHeading ();

   myProblem_ = new WitProblem (this);
@


1.22
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d57 4
d131 9
@


1.21
log
@Added some optional warnings on Linux.
@
text
@d255 7
@


1.20
log
@Modifications for Linux port.
@
text
@d295 1
a296 1
      internalTable_ (),
@


1.19
log
@Continued implementation of proportionate routing.
@
text
@d324 1
a324 1
         internalTable_ (key).find (WitNode::nodeName, theName.myCstring ());
d349 1
a349 1
         internalTable_ (hashKey (theName)).find (WitNode::nodeName, theName);
@


1.18
log
@Changed some C style casts to C++ style.
@
text
@a169 11
WitProbAssoc::WitProbAssoc (const WitProbAssoc * theAssoc):

      myProblem_ (NULL)
   {
   witAssert (theAssoc != NULL);

   myProblem_ = theAssoc->myProblem ();
   }

//------------------------------------------------------------------------------

@


1.17
log
@Internal changes.
@
text
@d408 2
a409 1
   newSize = (int) ceil (internalTable_.length () * growthFactor_);
d433 1
a433 1
   return (int) (key % internalTable_.length ());
@


1.16
log
@Internal changes.
@
text
@d68 1
a68 1
   if (! exeTypeText_.isNull ())
d251 4
a254 4
   internalSoln_      = ! isInput;
   compsSecScheds_    =   isOpt;
   respectsAllBounds_ =   isOpt  || isInput;
   respectsLotSizes_  =   isHeur || isInput;
@


1.15
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d201 1
a201 1
WitBoolean WitProbAssoc::tempParIsSet (int index)
d208 1
a208 1
WitBoolean WitProbAssoc::fssComputed () const
d221 4
a224 4
      internalSoln_      (witFALSE),
      compsSecScheds_    (witFALSE),
      respectsAllBounds_ (witFALSE),
      respectsLotSizes_  (witFALSE)
d239 4
a242 4
   const WitBoolean isOpt     = (this == myProblem ()->myOptVariant     ());
   const WitBoolean isHeur    = (this == myProblem ()->myHeurVariant    ());
   const WitBoolean isHeurOpt = (this == myProblem ()->myHeurOptVariant ());
   const WitBoolean isInput   = (this == myProblem ()->myInputVariant   ());
@


1.14
log
@Continued implementation of single-source.
@
text
@d265 9
@


1.13
log
@Continued implementation of single-source.
@
text
@d62 2
a63 2
      exeTypeText_ (* new WitString (EXE_TYPE_TEXT)),
      startTime_   (* new WitString),
d90 1
a90 3
   delete & startTime_;
   delete & exeTypeText_;
   delete   myProblem_;
@


1.12
log
@Preliminary work on single source.
@
text
@a19 1
//    AccFlag
a31 1
#include <AccFlag.h>
a441 45

//------------------------------------------------------------------------------
// Implementation of class AccFlag.
//------------------------------------------------------------------------------

WitAccFlag::WitAccFlag ():
      accObject_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitAccFlag::~WitAccFlag ()
   {
   }

//------------------------------------------------------------------------------

#if DEBUG_MODE

void WitAccFlag::access (const void * theObject)
   {
   witAssert (theObject  != NULL);
   witAssert (accObject_ == NULL);

   accObject_ = theObject;
   }

//------------------------------------------------------------------------------

void WitAccFlag::reset ()
   {
   witAssert (accObject_ != NULL);

   accObject_ = NULL;
   }

//------------------------------------------------------------------------------

WitBoolean WitAccFlag::accessing (const void * theObject) const
   {
   return (theObject == accObject_);
   }

#endif
@


1.11
log
@Continued preliminary work on single source.
@
text
@d83 1
a83 1
   startTime_  = ctime (& startTime_t);
@


1.10
log
@More preliminary work on single source.
@
text
@d28 1
@


1.9
log
@Preliminary work on single source.
@
text
@d394 1
a394 1
   WitDenseList (WitNode) hashedNodes (nNodesHashed_);
@


1.8
log
@Began implementation of object iteration.
@
text
@d441 1
a441 1
      internalTable_[idx] = new WitList (WitNode);
@


1.7
log
@Implemented and used class SelMgr.
@
text
@d33 1
@


1.6
log
@Some minor changes.
@
text
@d172 1
a172 1
WitProbAssoc::WitProbAssoc (WitProbAssoc * theAssoc):
a264 6

//------------------------------------------------------------------------------

implementClearContents (WitVariant)
   //
   // See RWClient.h.
@


1.5
log
@Replaced WitPart.[Ch] with Part.[Ch].
@
text
@d33 1
d315 1
d334 1
a334 1
         internalTable_[key].find (WitNode::nodeName, theName.myCstring ());
d339 1
a339 1
   internalTable_[key].prepend (theNode);
d359 1
a359 1
         internalTable_[hashKey (theName)].find (WitNode::nodeName, theName);
d374 1
a374 1
      WitDelComp::purgeSelComps (internalTable_[i]);
d376 1
a376 1
      nNodesHashed_ += internalTable_[i].nElements ();
d388 1
a388 1
   internalTable_.resize (myGlobalComp ()->hashTableSize ());
d397 1
d404 1
a404 1
      forEachEl (theNode, internalTable_[theKey])
d407 1
a407 3
   const int newSize = (int) ceil (internalTable_.length () * growthFactor_);
      //
      // Size of new internal table.
d409 1
a409 1
   internalTable_.resize (newSize);
d415 1
a415 1
      internalTable_[theKey].append (theNode);
d432 15
@


1.4
log
@Removed the PRM PID number (product id number).
@
text
@a110 1
   /* "5799-QYH\n"                               */
@


1.3
log
@Replaced "PRM" with "WIT".
Replaced "Production Resource Manager" with "Watson Implosion Technology".
Upgraded release # to 6.0.
@
text
@d111 1
a111 1
      "5799-QYH\n"
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d102 1
a102 1
   fprintf (outFile, "Production Resource Manager (%s)\n", __DATE__);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
d112 1
a112 1
      "(C) COPYRIGHT IBM Corp. 1993,1996\n"
@


1.1.1.1
log
@Import wit
@
text
@@

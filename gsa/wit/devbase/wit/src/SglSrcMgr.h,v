head	1.61;
access;
symbols
	sce_5_01_20080919:1.57
	latest_sce_4_20_20060523:1.55.0.2
	sce_4_20_20060523:1.55
	latest_sce4_20_OSL:1.54.0.2
	sce_4_20_OSL:1.54
	sce_410_withVa:1.52
	sce_4_05_20040511:1.49
	sce_4_00_20040201:1.49
	nextGenBranch:1.49.0.2
	nextGenRoot:1.49
	sce_3_30_20030627:1.49
	EndRw-branch:1.36.0.2
	Root-of-EndRw:1.36
	rwToStl:1.33.0.2;
locks; strict;
comment	@ * @;


1.61
date	2011.09.28.23.50.12;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2011.09.24.00.28.39;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2011.08.30.20.18.11;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.10.14.59.26;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.12.16.30.12;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.09.00.40.48;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.02.17.34.13;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.11.15.21.27.24;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.11.15.19.55.21;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.26.23.50.33;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.12.10.21.58.31;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.12.09.19.22.51;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.04.29.19.55.33;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.03.07.23.46.17;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.06.20.28.24;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.02.22.18.50;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2002.12.17.17.01.44;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2002.12.16.16.41.23;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2002.12.13.00.07.58;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.06.20.38.26;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.04.23.37.55;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.04.22.38.58;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.04.19.17.59;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.03.00.43.29;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.26.23.28.51;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.22.21.18.01;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.21.22.54.00;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.15.20.27.14;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.30.23.47.33;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.18.22.23.57;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.22.21.16.23;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.25.22.47.32;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.25.17.43.55;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.24.23.15.17;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.23.15.18.32;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.22.19.34.00;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.15.19.34.03;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.09.20.49.50;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.09.19.52.37;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.08.18.15.39;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.02.21.53.09;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.02.19.21.00;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.01.20.15.33;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.28.19.40.16;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.21.18.13.44;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.19.22.41.16;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.19.18.53.27;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.18.21.42.06;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.18.17.54.45;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.17.22.08.18;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.17.17.29.27;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.13.21.50.14;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.12.17.18.42;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.10.21.55.15;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.07.23.45.12;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.06.18.53.42;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.24.23.00.08;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.21.19.10.28;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.17.21.45.05;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.16.23.32.10;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.13.21.31.42;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef SglSrcMgrH
#define SglSrcMgrH

//------------------------------------------------------------------------------
// Header file: "SglSrcMgr.h"
//
// Contains the declaration of class SglSrcMgr.
//------------------------------------------------------------------------------

#include <PtrMap.h>
#include <ObjStack.h>
#include <Assoc.h>

//------------------------------------------------------------------------------
// Class SglSrcMgr
//
// "Single-Source Manager"
//
// Performs single-source heuristic allocation.
//
// This class is part of the implementation of the new single-source algorithm.
//------------------------------------------------------------------------------

class WitSglSrcMgr: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSglSrcMgr (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitSglSrcMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static bool sglSrcReq (WitProblem * theProblem);
         //
         // Returns TRUE, iff single-source has been requested for the Problem

      void commitMaxQty (double & netQty);
         //
         // Does commitMaxQty in sgl-src mode.

      void recPermCommit ();
         //
         // Records the fact that a perm-commit is being initiated.

      bool expProhibited (WitPart * thePart, WitPeriod expPer);
         //
         // Returns true, iff the sgl-src subsystem currently prohibits
         // explosion thru thePart in expPer.

      bool expProhibited (WitOperation * theOpn, WitPeriod execPer);
         //
         // Returns true, iff the sgl-src subsystem currently prohibits
         // explosion thru theOpn in execPer.

      void recExp (WitBillEntry * theBillEnt);
         //
         // Records the fact that requirements were exploded thru theBillEnt.

      bool sglSrcMode (WitRtSite * theRtSite);
         //
         // Returns true, iff theRtSite is currently in sgl-src mode.

      void saveAllocVal (int    & theVar);
      void saveAllocVal (double & theVar);
         //
         // Saves the current value of theVar to be restored as part of the
         // allocation.

      void saveExecVol (WitOperation * theOpn, WitPeriod thePer);
         //
         // Saves the execVol for theOpn in thePer.

      void saveSubVol (WitSubEntry * theSub, WitPeriod thePer);
         //
         // Saves the subVol for theSub in thePer.

      void saveConfigVal (bool & theVar);
      void saveConfigVal (int  & theVar);
         //
         // Saves the current value of theVar to be restored as part of the
         // selection configuration.

      template <typename ObjByPtr>
            inline void saveConfigVal (ObjByPtr * & theVar)
         {
         saveConfigObjByVPVal (reinterpret_cast <void * &> (theVar));
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      void saveConfigObjByVPVal (void * & theVar);
         //
         // Saves the current value of theVar to be restored as part of the
         // selection configuration.

      void verifyRestrictions ();
         //
         // Verifies that all of the problem restrictions required for sgl-src 
         // hold.

      bool expProhibited (WitSglSrcSite * theSite, WitPeriod thePer);
         //
         // Returns true, iff explosion thru theSite is prohibited in thePer.

      void initMsAlloc (double & netQty, bool & fullAlloc);
         //
         // Performs the initial multi-source allocation on netQty.
         // On return, fullAlloc is true, iff a full allocation was achieved.

      WitSglSrcSite * nextOpp ();
         //
         // Finds and returns the next SglSrcSite to consider for sgl-src,
         // if any, else NULL.

      void selectDiscovery (WitSglSrcSite * theSite);
         //
         // Has theSite select its next RtCand, having discovered that it
         // already has a sgl-src flow.

      void tryNextCand (double netQty, WitSglSrcSite * theSite);
         //
         // Attempts to use the next RtCand of theSite as its sgl-src
         // selection, and keeps it, if it's successful.

      void saveCurAsIncumb ();
         //
         // Saves the current sgl-src configuration as the incumbent.

      void preserveIncumb ();
         //
         // Preserves the incumbent allocation.

      void prtNonFull ();
         //
         // Does printing for a non-full allocation.

      void cmqFixed (double netQty, double & newNetQty);
         //
         // Does commitMaxQty for a fixed sgl-src configuration.
         // The resulting new value of netQty is stored in newNetQty.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector that owns this SglSrcMgr.

      WitRtMgr * const myRtMgr_;
         //
         // The RtMgr for this SglSrcMgr.

      WitPtrMap <WitRtSite, WitSglSrcSite> mySglSrcSiteFor_;
         //
         // mySglSrcSiteFor_ (theRtSite) is the SglSrcSite owned by this
         // SglSrcMgr corresponding to theRtSite, if any, else NULL.

      WitObjStack <WitSglSrcSite> alteredSites_;
         //
         // The set of SglSrcSites whose selection has been altered since the
         // most resent call to reset.

      bool cmqMode_;
         //
         // True, iff commitMaxQty (...) is currently executing.

      int curPermCommIdx_;
         //
         // The index of the current perm-commit.

      WitObjStack <WitSglSrcSite> curVisitSites_;
         //
         // The set of SglSrcSites visited in perm mode during the most recent
         // call to cmqFixed.

      WitObjStack <WitSglSrcSite> incumbVisitSites_;
         //
         // The set of SglSrcSites visited during the incumbent call to
         // cmqFixed.

      bool pureMsMode_;
         //
         // True, iff no sgl-src selections have been made in the incumbent
         // sgl-src configuration.

      //------------------------------------------------------------------------
      // Data Repositories.
      //------------------------------------------------------------------------

      WitDataRepos * initAllocRepos_;
         //
         // The DataRepos for restoring the allocation to its initial state.

      WitDataRepos * initConfigRepos_;
         //
         // The DataRepos for restoring the selection configuration to its
         // initial state.

      WitDataRepos * incumbAllocRepos_;
         //
         // The DataRepos for restoring the allocation to its incumbent state.

      WitDataRepos * incumbConfigRepos_;
         //
         // The DataRepos for restoring the selection configuration to its
         // incumbent state.

      //------------------------------------------------------------------------
      // Algorithmic event counts.
      //------------------------------------------------------------------------

      int nCmq_;
      int nCmqFixed_;
      int nFullAlloc_;
      int nNonFullAlloc_;
      int nOpps_;
      int nDiscovered_;
      int nTested_;
      int nAccepted_;
      int nRejected_;
         //
         // Number of occurrences of:
         //    commitMaxQty
         //    cmqFixed
         //    Full     allocation
         //    Non-full allocation
         //    Sgl-src opportunity considered
         //    Sgl-src selection discovered
         //    Sgl-src selection tested
         //    Sgl-src selection accepted
         //    Sgl-src selection rejected
   };

#endif
@


1.60
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.59
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d34 2
a35 153
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitSglSrcMgr (WitSelector *);

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitSglSrcMgr ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

static bool sglSrcReq (WitProblem * theProblem);
//
// Returns TRUE, iff single-source has been requested for the Problem

void commitMaxQty (double & netQty);
//
// Does commitMaxQty in sgl-src mode.

void recPermCommit ();
//
// Records the fact that a perm-commit is being initiated.

bool expProhibited (WitPart * thePart, WitPeriod expPer);
//
// Returns true, iff the sgl-src subsystem currently prohibits
// explosion thru thePart in expPer.

bool expProhibited (WitOperation * theOpn, WitPeriod execPer);
//
// Returns true, iff the sgl-src subsystem currently prohibits
// explosion thru theOpn in execPer.

void recExp (WitBillEntry * theBillEnt);
//
// Records the fact that requirements were exploded thru theBillEnt.

bool sglSrcMode (WitRtSite * theRtSite);
//
// Returns true, iff theRtSite is currently in sgl-src mode.

void saveAllocVal (int    & theVar);
void saveAllocVal (double & theVar);
//
// Saves the current value of theVar to be restored as part of the
// allocation.

void saveExecVol (WitOperation * theOpn, WitPeriod thePer);
//
// Saves the execVol for theOpn in thePer.

void saveSubVol (WitSubEntry * theSub, WitPeriod thePer);
//
// Saves the subVol for theSub in thePer.

void saveConfigVal (bool & theVar);
void saveConfigVal (int  & theVar);
//
// Saves the current value of theVar to be restored as part of the
// selection configuration.

template <typename ObjByPtr>
inline void saveConfigVal (ObjByPtr * & theVar)
{
saveConfigObjByVPVal (reinterpret_cast <void * &> (theVar));
}

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

void saveConfigObjByVPVal (void * & theVar);
//
// Saves the current value of theVar to be restored as part of the
// selection configuration.

void verifyRestrictions ();
//
// Verifies that all of the problem restrictions required for sgl-src
// hold.

bool expProhibited (WitSglSrcSite * theSite, WitPeriod thePer);
//
// Returns true, iff explosion thru theSite is prohibited in thePer.

void initMsAlloc (double & netQty, bool & fullAlloc);
//
// Performs the initial multi-source allocation on netQty.
// On return, fullAlloc is true, iff a full allocation was achieved.

WitSglSrcSite * nextOpp ();
//
// Finds and returns the next SglSrcSite to consider for sgl-src,
// if any, else NULL.

void selectDiscovery (WitSglSrcSite * theSite);
//
// Has theSite select its next RtCand, having discovered that it
// already has a sgl-src flow.

void tryNextCand (double netQty, WitSglSrcSite * theSite);
//
// Attempts to use the next RtCand of theSite as its sgl-src
// selection, and keeps it, if it's successful.

void saveCurAsIncumb ();
//
// Saves the current sgl-src configuration as the incumbent.

void preserveIncumb ();
//
// Preserves the incumbent allocation.

void prtNonFull ();
//
// Does printing for a non-full allocation.

void cmqFixed (double netQty, double & newNetQty);
//
// Does commitMaxQty for a fixed sgl-src configuration.
// The resulting new value of netQty is stored in newNetQty.

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

WitSelector * const mySelector_;
//
// The Selector that owns this SglSrcMgr.

WitRtMgr * const myRtMgr_;
//
// The RtMgr for this SglSrcMgr.

WitPtrMap <WitRtSite, WitSglSrcSite> mySglSrcSiteFor_;
//
// mySglSrcSiteFor_ (theRtSite) is the SglSrcSite owned by this
// SglSrcMgr corresponding to theRtSite, if any, else NULL.

WitObjStack <WitSglSrcSite> alteredSites_;
//
// The set of SglSrcSites whose selection has been altered since the
// most resent call to reset.
d37 221
a257 70
bool cmqMode_;
//
// True, iff commitMaxQty (...) is currently executing.

int curPermCommIdx_;
//
// The index of the current perm-commit.

WitObjStack <WitSglSrcSite> curVisitSites_;
//
// The set of SglSrcSites visited in perm mode during the most recent
// call to cmqFixed.

WitObjStack <WitSglSrcSite> incumbVisitSites_;
//
// The set of SglSrcSites visited during the incumbent call to
// cmqFixed.

bool pureMsMode_;
//
// True, iff no sgl-src selections have been made in the incumbent
// sgl-src configuration.

//------------------------------------------------------------------------
// Data Repositories.
//------------------------------------------------------------------------

WitDataRepos * initAllocRepos_;
//
// The DataRepos for restoring the allocation to its initial state.

WitDataRepos * initConfigRepos_;
//
// The DataRepos for restoring the selection configuration to its
// initial state.

WitDataRepos * incumbAllocRepos_;
//
// The DataRepos for restoring the allocation to its incumbent state.

WitDataRepos * incumbConfigRepos_;
//
// The DataRepos for restoring the selection configuration to its
// incumbent state.

//------------------------------------------------------------------------
// Algorithmic event counts.
//------------------------------------------------------------------------

int nCmq_;
int nCmqFixed_;
int nFullAlloc_;
int nNonFullAlloc_;
int nOpps_;
int nDiscovered_;
int nTested_;
int nAccepted_;
int nRejected_;
//
// Number of occurrences of:
//    commitMaxQty
//    cmqFixed
//    Full     allocation
//    Non-full allocation
//    Sgl-src opportunity considered
//    Sgl-src selection discovered
//    Sgl-src selection tested
//    Sgl-src selection accepted
//    Sgl-src selection rejected
};
@


1.58
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d34 153
a186 2
   {
   public:
d188 70
a257 221
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSglSrcMgr (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitSglSrcMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static bool sglSrcReq (WitProblem * theProblem);
         //
         // Returns TRUE, iff single-source has been requested for the Problem

      void commitMaxQty (double & netQty);
         //
         // Does commitMaxQty in sgl-src mode.

      void recPermCommit ();
         //
         // Records the fact that a perm-commit is being initiated.

      bool expProhibited (WitPart * thePart, WitPeriod expPer);
         //
         // Returns true, iff the sgl-src subsystem currently prohibits
         // explosion thru thePart in expPer.

      bool expProhibited (WitOperation * theOpn, WitPeriod execPer);
         //
         // Returns true, iff the sgl-src subsystem currently prohibits
         // explosion thru theOpn in execPer.

      void recExp (WitBillEntry * theBillEnt);
         //
         // Records the fact that requirements were exploded thru theBillEnt.

      bool sglSrcMode (WitRtSite * theRtSite);
         //
         // Returns true, iff theRtSite is currently in sgl-src mode.

      void saveAllocVal (int    & theVar);
      void saveAllocVal (double & theVar);
         //
         // Saves the current value of theVar to be restored as part of the
         // allocation.

      void saveExecVol (WitOperation * theOpn, WitPeriod thePer);
         //
         // Saves the execVol for theOpn in thePer.

      void saveSubVol (WitSubEntry * theSub, WitPeriod thePer);
         //
         // Saves the subVol for theSub in thePer.

      void saveConfigVal (bool & theVar);
      void saveConfigVal (int  & theVar);
         //
         // Saves the current value of theVar to be restored as part of the
         // selection configuration.

      template <typename ObjByPtr>
            inline void saveConfigVal (ObjByPtr * & theVar)
         {
         saveConfigObjByVPVal (reinterpret_cast <void * &> (theVar));
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      void saveConfigObjByVPVal (void * & theVar);
         //
         // Saves the current value of theVar to be restored as part of the
         // selection configuration.

      void verifyRestrictions ();
         //
         // Verifies that all of the problem restrictions required for sgl-src 
         // hold.

      bool expProhibited (WitSglSrcSite * theSite, WitPeriod thePer);
         //
         // Returns true, iff explosion thru theSite is prohibited in thePer.

      void initMsAlloc (double & netQty, bool & fullAlloc);
         //
         // Performs the initial multi-source allocation on netQty.
         // On return, fullAlloc is true, iff a full allocation was achieved.

      WitSglSrcSite * nextOpp ();
         //
         // Finds and returns the next SglSrcSite to consider for sgl-src,
         // if any, else NULL.

      void selectDiscovery (WitSglSrcSite * theSite);
         //
         // Has theSite select its next RtCand, having discovered that it
         // already has a sgl-src flow.

      void tryNextCand (double netQty, WitSglSrcSite * theSite);
         //
         // Attempts to use the next RtCand of theSite as its sgl-src
         // selection, and keeps it, if it's successful.

      void saveCurAsIncumb ();
         //
         // Saves the current sgl-src configuration as the incumbent.

      void preserveIncumb ();
         //
         // Preserves the incumbent allocation.

      void prtNonFull ();
         //
         // Does printing for a non-full allocation.

      void cmqFixed (double netQty, double & newNetQty);
         //
         // Does commitMaxQty for a fixed sgl-src configuration.
         // The resulting new value of netQty is stored in newNetQty.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector that owns this SglSrcMgr.

      WitRtMgr * const myRtMgr_;
         //
         // The RtMgr for this SglSrcMgr.

      WitPtrMap <WitRtSite, WitSglSrcSite> mySglSrcSiteFor_;
         //
         // mySglSrcSiteFor_ (theRtSite) is the SglSrcSite owned by this
         // SglSrcMgr corresponding to theRtSite, if any, else NULL.

      WitObjStack <WitSglSrcSite> alteredSites_;
         //
         // The set of SglSrcSites whose selection has been altered since the
         // most resent call to reset.

      bool cmqMode_;
         //
         // True, iff commitMaxQty (...) is currently executing.

      int curPermCommIdx_;
         //
         // The index of the current perm-commit.

      WitObjStack <WitSglSrcSite> curVisitSites_;
         //
         // The set of SglSrcSites visited in perm mode during the most recent
         // call to cmqFixed.

      WitObjStack <WitSglSrcSite> incumbVisitSites_;
         //
         // The set of SglSrcSites visited during the incumbent call to
         // cmqFixed.

      bool pureMsMode_;
         //
         // True, iff no sgl-src selections have been made in the incumbent
         // sgl-src configuration.

      //------------------------------------------------------------------------
      // Data Repositories.
      //------------------------------------------------------------------------

      WitDataRepos * initAllocRepos_;
         //
         // The DataRepos for restoring the allocation to its initial state.

      WitDataRepos * initConfigRepos_;
         //
         // The DataRepos for restoring the selection configuration to its
         // initial state.

      WitDataRepos * incumbAllocRepos_;
         //
         // The DataRepos for restoring the allocation to its incumbent state.

      WitDataRepos * incumbConfigRepos_;
         //
         // The DataRepos for restoring the selection configuration to its
         // incumbent state.

      //------------------------------------------------------------------------
      // Algorithmic event counts.
      //------------------------------------------------------------------------

      int nCmq_;
      int nCmqFixed_;
      int nFullAlloc_;
      int nNonFullAlloc_;
      int nOpps_;
      int nDiscovered_;
      int nTested_;
      int nAccepted_;
      int nRejected_;
         //
         // Number of occurrences of:
         //    commitMaxQty
         //    cmqFixed
         //    Full     allocation
         //    Non-full allocation
         //    Sgl-src opportunity considered
         //    Sgl-src selection discovered
         //    Sgl-src selection tested
         //    Sgl-src selection accepted
         //    Sgl-src selection rejected
   };
@


1.57
log
@Stochastic Implosion
@
text
@d188 4
d208 1
a208 1
         // true, iff no sgl-src selections have been made in the incumbent
@


1.56
log
@Stochastic Implosion
@
text
@d93 4
@


1.55
log
@Updated the copyright date on all source files.
@
text
@d89 4
@


1.54
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.53
log
@[shared-resource pegging]
@
text
@d98 1
a98 1
         saveConfigTlObjVal (toTlObjRef_cast (theVar));
d107 1
a107 1
      void saveConfigTlObjVal (WitTlObj * & theVar);
@


1.52
log
@Pegged critical list.
@
text
@d95 2
a96 2
      template <typename ObjType>
            inline void saveConfigVal (ObjType * & theVar)
@


1.51
log
@Low-Pri Prop-Rt.
@
text
@d166 4
@


1.50
log
@Low-Pri Prop-Rt.
@
text
@d90 1
@


1.49
log
@Continued implementation of proportionate routing.
@
text
@d89 1
a89 2
      void saveConfigVal (bool &         theVar);
      void saveConfigVal (WitSelCand * & theVar);
d94 6
d106 5
@


1.48
log
@Continued implementation of proportionate routing.
@
text
@d75 1
a75 1
      void recExp (WitRtCand * theRtCand);
d77 1
a77 1
         // Records the fact that requirements were exploded thru theRtCand.
@


1.47
log
@Continued implementation of proportionate routing.
@
text
@a146 4
      inline WitSglSrcSite * mySglSrcSiteFor (WitRtSite *);
         //
         // Data access

@


1.46
log
@Internal changes.
@
text
@d55 1
a55 1
         // Returns true, iff sgl-src has been requested for theProblem.
d75 1
a75 1
      void recExp (WitBopEntry * theBopEnt);
d77 1
a77 1
         // Records the fact that requirements were exploded thru theBopEnt.
d79 1
a79 1
      void recExp (WitConsEntry * theConsEnt);
d81 1
a81 9
         // Records the fact that requirements were exploded thru theConsEnt.

      bool sglSrcMode (WitPart * thePart);
         //
         // Returns true, iff thePart is currently in sgl-src mode.

      bool sglSrcMode (WitBomEntry * theBomEnt);
         //
         // Returns true, iff theBomEnt is currently in sgl-src mode.
a109 9
      void recordVisit (WitSglSrcSite * theSite, WitBillEntry * theBillEnt);
         //
         // If theSite is not NULL, this function records the fact that theSite
         // is being visited, using theBillEnt as its selection.

      bool sglSrcMode (WitSglSrcSite * theSite);
         //
         // Returns true, iff theSite is not NULL and currently in sgl-src mode.

d122 1
a122 1
         // Has theSite select its next SglSrcCand, having discovered that it
d127 1
a127 1
         // Attempts to use the next SglSrcCand of theSite as its sgl-src
d147 4
d159 1
a159 6
      WitPtrMap <WitPart, WitSglSrcSite> mySiteForPart_;
         //
         // mySiteForPart_ (thePart) is the SglSrcSite owned by this SglSrcMgr
         // corresponding to thePart, if any, else NULL.

      WitPtrMap <WitBomEntry, WitSglSrcSite> mySiteForBomEnt_;
d161 2
a162 2
         // mySiteForBomEnt_ (theBomEnt) is the SglSrcSite owned by this
         // SglSrcMgr corresponding to theBomEnt, if any, else NULL.
@


1.45
log
@Cut-over single-source to use the new algorithm.
@
text
@d53 1
a53 1
      static WitBoolean sglSrcReq (WitProblem * theProblem);
d55 1
a55 1
         // Returns TRUE, iff sgl-src has been requested for theProblem.
d65 1
a65 1
      WitBoolean expProhibited (WitPart * thePart, WitPeriod expPer);
d67 1
a67 1
         // Returns TRUE, iff the sgl-src subsystem currently prohibits
d70 1
a70 1
      WitBoolean expProhibited (WitOperation * theOpn, WitPeriod execPer);
d72 1
a72 1
         // Returns TRUE, iff the sgl-src subsystem currently prohibits
d83 1
a83 1
      WitBoolean sglSrcMode (WitPart * thePart);
d85 1
a85 1
         // Returns TRUE, iff thePart is currently in sgl-src mode.
d87 1
a87 1
      WitBoolean sglSrcMode (WitBomEntry * theBomEnt);
d89 1
a89 1
         // Returns TRUE, iff theBomEnt is currently in sgl-src mode.
d97 1
a97 1
      void saveConfigVal (int &          theVar);
d114 1
a114 1
      WitBoolean expProhibited (WitSglSrcSite * theSite, WitPeriod thePer);
d116 1
a116 1
         // Returns TRUE, iff explosion thru theSite is prohibited in thePer.
d123 1
a123 1
      WitBoolean sglSrcMode (WitSglSrcSite * theSite);
d125 1
a125 1
         // Returns TRUE, iff theSite is not NULL and currently in sgl-src mode.
d127 1
a127 1
      void initMsAlloc (double & netQty, WitBoolean & fullAlloc);
d130 1
a130 1
         // On return, fullAlloc is TRUE, iff a full allocation was achieved.
d201 1
a201 1
      WitBoolean pureMsMode_;
d203 1
a203 1
         // TRUE, iff no sgl-src selections have been made in the incumbent
@


1.44
log
@Continued implementation of single-source by the new algorithm.
@
text
@d206 4
@


1.43
log
@Continued implementation of single-source by the new algorithm.
@
text
@d151 1
a151 1
      void preserveIncumb (double & netQty);
d206 1
a206 1
      WitDataRepos * allocRepos_;
d208 1
a208 1
         // The DataRepos for saving and restoring the allocation.
d210 1
a210 1
      WitDataRepos * configRepos_;
d212 11
a222 1
         // The DataRepos for saving and restoring the selection configuration.
@


1.42
log
@Continued implementation of single-source by the new algorithm.
@
text
@d75 1
a75 1
      void recPermExp (WitBopEntry * theBopEnt);
d77 1
a77 2
         // Records the fact that requirements were exploded thru theBopEnt in
         // perm mode.
d79 1
a79 1
      void recPermExp (WitConsEntry * theConsEnt);
d81 1
a81 2
         // Records the fact that requirements were exploded thru theConsEnt in
         // perm mode.
d137 1
a137 1
      void selectUniqueCand (WitSglSrcSite * theSite);
d139 2
a140 1
         // Has theSite select its incumbent unique SglSrcCand.
d193 2
a194 2
         // The set of SglSrcSites visited during the most recent call to
         // cmqFixed.
@


1.41
log
@Continued implementation of single-source with the new algorithm.
@
text
@a115 5
      void cmqFixed (double netQty, double & newNetQty);
         //
         // Does commitMaxQty for a fixed sgl-src configuration.
         // The resulting new value of netQty is stored in newNetQty.

d129 5
d139 1
a139 1
      void selectUniqueSel (WitSglSrcSite * theSite);
d141 1
a141 1
         // Has theSite select its incumbent unique selection.
d148 1
a148 1
      void saveAsIncumbent ();
d152 5
a156 1
      void reset ();
d158 1
a158 1
         // Resets this SglSrcMgr.
d160 1
a160 1
      void prtNotFull ();
d162 2
a163 1
         // Does printing for when full allocation was not achieved.
d214 25
@


1.40
log
@Continued implementation of single-source by the new algorithm.
@
text
@d178 1
a178 1
      WitObjStack <WitSglSrcSite> mySglSrcSites_;
d180 2
a181 1
         // The set of all SglSrcSites owned by this SglSrcMgr.
@


1.39
log
@Continued implementation of single-source with the new algorithm.
@
text
@d80 1
a80 1
      void recPermExpNet (WitConsEntry * theConsEnt);
d82 2
a83 2
         // Records the fact that requirements were exploded or netted thru
         // theConsEnt in perm mode.
@


1.38
log
@Continued implementation of single-source by the new algorithm.
@
text
@d75 1
a75 1
      void recFillNetReq (WitPart * thePart);
d77 1
a77 1
         // Records the fact that net requirements were filled for thePart in
d80 1
a80 1
      void recExp (WitBomEntry * theBomEnt);
d82 2
a83 2
         // Records the fact requirements were exploded thru theBomEnt or one of
         // its substitutes in perm mode.
d125 1
a125 1
      void recordVisit (WitSglSrcSite * theSite);
d128 1
a128 1
         // is being visited.
d139 5
a143 4
      void tryNextCand (
            double          netQty,
            WitSglSrcSite * theSite, 
            WitBoolean &    pureMS);
a146 1
         // If the attempt is successful, pureMS is set to FALSE.
d195 5
@


1.37
log
@Continued implementation of single-source by the new algorithm.
@
text
@d61 4
d125 1
a125 1
      void recordFlow (WitSglSrcSite * theSite);
d127 2
a128 1
         // Records the fact flow occurred thru theSite, if not NULL.
d148 4
d178 9
a186 1
      WitObjStack <WitSglSrcSite> curFlowSites_;
d188 2
a189 2
         // The set of SglSrcSites through which flow occurred during the most
         // recent call to cmqFixed.
d191 1
a191 1
      WitObjStack <WitSglSrcSite> incumbFlowSites_;
d193 2
a194 2
         // The set of SglSrcSites through which flow occurred during the call
         // to cmqFixed with the incumbant sgl-src configuration.
@


1.36
log
@Continued implementation of single-source with the new algorithm.
Fixed a null pointer bug in single-source with the old algorithm.
@
text
@d66 5
d73 7
a79 2
         // Records the fact net requirements were filled for thePart in perm 
         // mode.
d81 1
a81 1
      WitBoolean sglSrcMode (WitSelPt * theSelPt);
d83 5
a87 1
         // Returns TRUE, iff theSelPt is currently in sgl-src mode.
d117 12
d163 5
@


1.35
log
@Continued implementation of single-source with the new algorithm.
@
text
@d61 5
@


1.34
log
@Began implementation of the new single-source algorithm.
@
text
@d15 2
d18 135
@


1.33
log
@Fixed the "interference bug" in Single-Source.
@
text
@a14 2
//
// Contains the declaration of class SglSrcMgr.
a15 231

#include <ObjStack.h>
#include <PtrMap.h>
#include <Assoc.h>

//------------------------------------------------------------------------------
// Class SglSrcMgr
//
// "Single-Source Manager"
//
// Performs single-source heuristic allocation.
//------------------------------------------------------------------------------

class WitSglSrcMgr: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSglSrcMgr (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitSglSrcMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static WitBoolean hasSglSrcComp (WitProblem * theProblem);
         //
         // Returns TRUE, iff theProblem has at least one Part or BomEntry with
         // singleSource () == TRUE.

      void commitMaxQty (double & netQty);
         //
         // Does commitMaxQty in single-source mode.

      void prepCmqSel ();
         //
         // Prepares for a call to HeurAtor::commitMaxQtySel.

      WitBoolean findPmrMisMatch (
            WitPart * thePart,
            WitPeriod expPer,
            WitPeriod fillPer);
         //
         // Returns TRUE, iff there is a selection mis-match between 
         // single-source and PMR for exploding thePart in expPer.
         // If there is a mis-match, a fundamental shortage is recorded.

      void noteCmrMisMatch (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            WitPeriod     fillPer,
            WitBopEntry * theBopEnt);
         //
         // Looks for a selection mis-match between single-source and CMR for
         // exploding through theBopEnt and theBomEnt in execPer for reqs in
         // fillPer. If a mis-match is found, it is recorded and a fundamental
         // shortage is recorded.

      WitBoolean checkCmrMisMatch ();
         //
         // Tells this SglSrcMgr that the current call to HeurAtor::explode is
         // finished. 
         // Returns TRUE, iff a CMR mis-match was found during the call.

      void placeReqs (WitSelPt * theSelPt);
         //
         // Records the fact that requirements were placed by exploding thru
         // theSelPt.

      WitBoolean mustSkip (WitSelPt * theSelPt);
         //
         // Returns TRUE, iff alteration at theSelPt is to be skipped.

      WitBoolean sglSrcMode (WitSelPt * theSelPt);
         //
         // Returns TRUE, iff theSelPt is currently in single-source mode.

      WitBoolean sglSrcMode (WitBomEntry * theBomEnt);
         //
         // Returns TRUE, iff theBomEnt is currently in single-source mode.

      void alterSelections ();
         //
         // Does alterSelections in single-source mode.

      void alterSelection (WitSelPt * theSelPt);
         //
         // Does alterSelection in single-source mode.

      void saveAllocVal (int    & theVar);
      void saveAllocVal (double & theVar);
         //
         // Saves the current value of theVar to be restored as part of the
         // allocation.

      void saveConfigVal (int &          theVar);
      void saveConfigVal (WitSelCand * & theVar);
         //
         // Saves the current value of theVar to be restored as part of the
         // selection configuration.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      void verifyRestrictions ();
         //
         // Verifies that all of the problem restrictions required for
         // single-source hold.

      void prepSelCMQ ();
         //
         // Prepares for a call to Selector::commitMaxQty.

      void prtPureMS ();
         //
         // Prints when the allocation is retained as pure multi-source.

      void prtDesIncVolAch ();
         //
         // Prints when desIncVol was acheived in a non-pure multi-source
         // iterations.

      void exhaustedCMQ (double & netQty);
         //
         // Does commitMaxQty in pure muliti-source mode for the single-source-
         // alternatives-exhausted case.

      void alterNextAltSite ();
         //
         // Alters the selection at nextAltSite_.

      void reset ();
         //
         // Resets this SglSrcMgr.

      void seekNextAltSite (WitSelPt * theSelPt);
         //
         // Sets nextAltSite_ to the SglSrcSite for theSelPt, if appropriate.

      void prtNextAltSite (WitBoolean forMisMatch);
         //
         // Prints nextAltSite_, as needed.
         // forMisMatch is TRUE, iff the Alt is for a mis-match.

      WitSglSrcSite * mySsSiteFor (WitSelPt * theSelPt);
         //
         // Returns theSglSrcSite corresponding to theSelPt, if any;
         // otherwise NULL.

      noCopyCtorAssign (WitSglSrcMgr);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitSelector * const mySelector_;
         //
         // The Selector that owns this SglSrcMgr.

      WitPtrMap <WitPart, WitSglSrcSite> mySsSiteForPart_;
         //
         // mySsSiteForPart_ (thePart) is the SglSrcSite owned by this SglSrcMgr
         // corresponding to thePart, if any, else NULL.

      WitPtrMap <WitBomEntry, WitSglSrcSite> mySsSiteForBomEnt_;
         //
         // mySsSiteForBomEnt_ (theBomEnt) is the SglSrcSite owned by this
         // SglSrcMgr corresponding to theBomEnt, if any, else NULL.

      WitBoolean sglSrcMode_;
         //
         // TRUE  --> this SglSrcMgr is single-source mode.
         // FALSE --> this SglSrcMgr is  multi-source mode.

      WitObjStack <WitSglSrcSite> alteredSites_;
         //
         // The set of all SglSrcSites whose selection has been altered.

      WitBoolean pureMS_;
         //
         // TRUE, iff the most recent call to commitMaxQty, was pure 
         // multi-source, i.e., whenever reqs were placed, the single-source
         // selection matched the multi-source selection.

      WitBoolean cmrMisMatch_;
         //
         // TRUE, iff a CMR mis-match was found during the current call to
         // HeurAtor::explode.

      WitSglSrcSite * misMatchSite_;
         //
         // The SglSrcSite at which the most recent mis-match was found.

      WitSglSrcSite * nextAltSite_;
         //
         // The SglSrcSite at which the next single-source alteration is to be
         // performed, if any; otherwise NULL.

      WitDataRepos * allocRepos_;
         //
         // The DataRepos for saving and restoring the allocation.

      WitDataRepos * configRepos_;
         //
         // The DataRepos for saving and restoring the selection configuration.

      int nItrs_;
         //
         // # iterations for commitMaxQty.

      int nAlts_;
         //
         // # single-source alterations.

      int swToMS_;
         //
         // # switchings to multi-source mode.
   };

#endif
@


1.32
log
@Continued implementation of heuristic implosion from an initial solution.
Added some debugging code to Single-Source.
@
text
@d60 30
d142 1
a142 1
      void activateAsNeeded ();
d144 1
a144 1
         // Calls activateAsNeeded for all relevent SglSrcSites.
d146 4
a149 4
      WitBoolean misMatchFound ();
         //          
         // Returns TRUE, iff a mis-match exists at any SglSrcSite in
         // Single-Source mode.
d151 1
a151 1
      WitBoolean pureMultiSource ();
d153 2
a154 2
         // Returns TRUE, iff the most recent iteration of CMQ was actually
         // a pure multi-source iteration.
d156 1
a156 1
      void fullRestore (double & netQty);
d158 1
a158 2
         // Restores heuristic allocation and selection to its state as of the
         // beginning of commitMaxQty. netQty is to be passed from commitMaxQty.
d168 1
a168 1
      void prtNextAltSite ();
d171 1
a197 4
      WitObjStack <WitSglSrcSite> mySglSrcSites_;
         //
         // The set of all SglSrcSites owned by this SglSrcMgr.

d203 19
a226 5
      WitObjStack <WitSglSrcSite> currentSites_;
         //
         // The set of all SglSrcSites being used by the current call to
         // commitMaxQty.

a234 4
      double origNetQty_;
         //
         // The value of netQty at the beginning of commitMaxQty.

d237 1
a237 17
         // # iterations for commitMatQty.

      int nMisMatches_;
         //
         // # iterations in which a mis-match was found.

      int nPureMS_;
         //
         // # pure multi-source iterations.

      int nAchDesInc_;
         //
         // # non-pure multi-source iterations in which desIncVol was acheived.

      int nExhaust_;
         //
         // # iterations in which the single-source alternatives were exhausted.
@


1.31
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d139 4
@


1.30
log
@Continued implementation of single-source.
@
text
@a22 2
template <class DomEl, class RangeEl> class WitPtrMap;

@


1.29
log
@Continued implementation of single-source.
@
text
@d75 4
@


1.28
log
@Continued implementation of single-source.
@
text
@d53 1
a53 1
      static WitBoolean singleSourceNeeded (WitProblem * theProblem);
d55 2
a56 1
         // Returns TRUE, iff single-source has been requested for theProblem.
@


1.27
log
@Continued implementation of single-source.
@
text
@d191 28
@


1.26
log
@Continued implementation of Single-Source.
@
text
@d70 4
d131 4
@


1.25
log
@Continued implementation of Single-Source.
@
text
@a30 2
//
// Implemented in SglSrc.C.
d73 4
@


1.24
log
@Continued implementation of Single-Source.
@
text
@d68 4
a74 4

      WitBoolean mustSkip (WitSelPt * theSelPt);
         //
         // Returns TRUE, iff alteration at theSelPt is to be skipped.
@


1.23
log
@Continued implementation of single-source.
@
text
@d19 2
d141 1
a141 1
      WitPtrMap <WitPart, WitSglSrcSite> & mySsSiteForPart_;
d146 1
a146 1
      WitPtrMap <WitBomEntry, WitSglSrcSite> & mySsSiteForBomEnt_;
d151 1
a151 1
      WitObjStack <WitSglSrcSite> & mySglSrcSites_;
d165 1
a165 1
      WitObjStack <WitSglSrcSite> & currentSites_;
@


1.22
log
@Continued implementation of Single-Source.
@
text
@d168 1
a168 1
      WitDataRepos & allocRepos_;
d172 1
a172 1
      WitDataRepos & configRepos_;
@


1.21
log
@Continued implementation of Single-Source.
@
text
@d97 1
a97 5
      void initSites ();
         //
         // Call init for all SglSrcSites.

      void prepCMQ ();
d151 1
a151 1
         // The set of all SglSrcSite owned by this SglSrcMgr.
d162 5
@


1.20
log
@Continued implementation of Single-Source.
@
text
@d61 1
a61 4
      void placeReqs (
            WitBopEntry *  theBopEnt, 
            WitConsEntry * theConsEnt,
            WitPeriod      execPer);
d64 1
a64 1
         // theBopEnt and theConsEnt in execPer.
@


1.19
log
@Continued implementation of Single-Source.
@
text
@d61 4
a64 1
      void placeReqs (WitBopEntry * theBopEnt, WitPeriod execPer);
d67 1
a67 1
         // theBopEnt in execPer.
d131 1
a131 1
      WitSglSrcSite * mySglSrcSiteFor (WitSelPt * theSelPt);
d146 1
a146 1
      WitPtrMap <WitPart, WitSglSrcSite> & mySglSrcSiteFor_;
d148 1
a148 1
         // mySglSrcSiteFor_ (thePart) is the SglSrcSite owned by this SglSrcMgr
d150 5
@


1.18
log
@Continued implementation of Single-Source.
@
text
@a85 8
      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitSelector *, mySelector)

      inline WitSglSrcCand * mySglSrcCandFor (WitBopEntry *);

a150 5

      WitPtrMap <WitBopEntry, WitSglSrcCand> & mySglSrcCandFor_;
         //
         // mySglSrcCandFor_ (theBopEnt) is the SglSrcSite owned by this
         // SglSrcMgr corresponding to theBopEnt, if any, else NULL.
@


1.17
log
@Continued implementation of Single-Source.
@
text
@d26 2
d29 2
d92 2
d159 5
@


1.16
log
@Continued implementation of Single-Source.
@
text
@d99 12
d121 5
d171 4
@


1.15
log
@Continued implementation of Single-Source.
@
text
@d103 6
a108 1
                                                   
@


1.14
log
@Continued implementation of Single-Source.
@
text
@d99 5
@


1.13
log
@Continued implementation of Single-Source.
@
text
@a98 18
      void initSites ();
         //
         // Inititializes all the SglSrcSites.

      void prepCMQ ();
         //
         // Prepares to call Selector::commitMaxQty.

      WitBoolean hasMisMatch ();
         //
         // Returns TRUE, iff there is a mis-match between the current selection
         // at any SglSrcSite in Single-Source mode and that at its Part in any
         // period in which requires were placed during Selector::commitMaxQty.

      void activatePersUsed ();
         //
         // Calls activatePersUsed for each SglSrcSite.

@


1.12
log
@Continued implementation of Single-Source.
@
text
@d117 4
@


1.11
log
@Continued implementation of Single-Source.
@
text
@d107 6
@


1.10
log
@Continued implementation of Single-Source.
@
text
@d57 5
d103 5
a107 1
      void applySglSrcSels ();
d109 1
a109 2
         // Applies the selections of the SglSrcSites to the corresponding
         // SelPts.
@


1.9
log
@Continued implementation of Single-Source.
@
text
@d94 1
a94 1
      WitBoolean sglSrcSelsExist ();
d96 1
a96 2
         // Returns TRUE, iff at least one of the SglSrcSites currently has a
         // selection.
a102 4
      void reset ();
         //
         // Resets the state of single-source.

d123 4
a135 4

      WitObjStack <WitSglSrcSite> & activeSites_;
         //
         // The set of SglSrcSites not in their default state.
@


1.8
log
@Continued implementation of Single-Source.
@
text
@d133 1
a133 1
      WitSglSrcSite * altSite_;
@


1.7
log
@Continued implementation of single-source.
@
text
@d94 5
d127 5
@


1.6
log
@Continued implementation of Single-Source.
@
text
@d130 1
a130 1
         // The set of SglSrcSites for which theSite->selBopEntry_ != NULL.
@


1.5
log
@Continued implementation of single-source.
@
text
@d123 1
a123 1
      WitSglSrcSite * skipSite_;
d125 2
a126 2
         // The first SglSrcSite that was skipped for alteration during the
         // current iteration, if any, else NULL.
@


1.4
log
@Continued implementation of single-source.
@
text
@d53 5
a57 1
      void commitMaxQtyTest (double & netQty);
d59 1
a59 2
         // Does commitMaxQty, but also tests single-source by doing a
         // hypo-commitMaxQty first.
d61 1
a61 1
      void commitMaxQty (double & netQty);
d63 1
a63 1
         // Does commitMaxQty in single-source mode.
d71 2
a72 2
      void saveSelectVal (int &          theVar);
      void saveSelectVal (WitSelCand * & theVar);
a76 4
      WitBoolean sglSrcMode (WitPart * thePart);
         //
         // Returns TRUE, iff thePart is currently is in single-source mode.

d81 2
d94 14
d118 14
d136 1
a136 1
      WitDataRepos & selectRepos_;
a138 5

      WitPtrMap <WitPart, WitSglSrcSite> & mySglSrcSiteFor_;
         //
         // mySglSrcSiteFor_ (thePart) is the SglSrcSite owned by this SglSrcMgr
         // corresponding to thePart, if any, else NULL.
@


1.3
log
@Continued implementation of single-source.
@
text
@d21 2
d58 4
d74 4
d88 5
d110 5
@


1.2
log
@Continued implementation of single source.
@
text
@d47 4
d53 1
a53 1
         // Does commitMaxQty, but also tests single source by doing a
@


1.1
log
@Continued implementation of single source.
@
text
@d52 2
a53 2
      void saveVal (int    & theVar);
      void saveVal (double & theVar);
d55 8
a62 1
         // Saves the current value of theVar.
d82 5
a86 1
         // The Selector that owns thys SglSrcMgr.
d88 1
a88 1
      WitDataRepos & myDataRepos_;
d90 1
a90 1
         // The DataRepos owned by this ReqSched.
@


head	1.46;
access;
symbols
	sce_5_01_20080919:1.14;
locks; strict;
comment	@ * @;


1.46
date	2011.09.28.23.49.46;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.24.00.28.07;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2011.08.30.20.17.48;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2011.08.26.22.54.49;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2011.08.25.23.27.03;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.02.09.19.13.25;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.02.03.22.30.53;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2010.12.10.00.40.26;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.17.20.20.53;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.11.04.19.59.01;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2010.10.12.22.42.24;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2010.10.12.19.48.28;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2010.08.20.21.07.36;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.19.18.00.13;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.24.20.32.08;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.24.18.20.51;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.24.18.15.34;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.21.23.46.13;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.21.18.17.57;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.19.16.07.35;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.18.22.54.24;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.18.22.40.40;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.14.21.20.56;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.12.18.38.07;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.07.23.18.59;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.24.21.31.02;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.11.22.36.23;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.16.20.47.04;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.26.21.06.11;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.16.00.09.08;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.15.17.13.03;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.13.19.52.08;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.29.23.24.29;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.27.23.19.10;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.27.22.49.17;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.07.15.19.29;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.06.18.59.13;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.15.22.02.08;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.15.19.15.33;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.09.20.17.42;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.09.19.30.36;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.08.23.27.44;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.02.19.39.47;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.01.21.28.05;	author rjw;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.01.20.47.54;	author rjw;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.01.20.38.22;	author rjw;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "OptMisc.C"
//
// Implementation of the following classes:
//
//    BoundPair
//    Coeff
//    OptVC
//    OptVar
//    OptCon
//------------------------------------------------------------------------------

#include <Coeff.h>
#include <OptVar.h>
#include <OptCon.h>
#include <OptProblem.h>
#include <OptComp.h>
#include <Timing.h>

#include <float.h>

//------------------------------------------------------------------------------
// Implementation of class BoundPair.
//------------------------------------------------------------------------------

WitBoundPair::WitBoundPair ():

      lower_ (0.0),
      upper_ (0.0)
   {
   }

//------------------------------------------------------------------------------

WitBoundPair::WitBoundPair (double lowerInit, double upperInit):
      lower_ (lowerInit),
      upper_ (upperInit)
   {
   }

//------------------------------------------------------------------------------

void WitBoundPair::operator = (const WitBoundPair & theBoundPair)
   {
   lower () = theBoundPair.lower ();
   upper () = theBoundPair.upper ();
   }

//------------------------------------------------------------------------------

WitBoundPair::~WitBoundPair ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class Coeff.
//------------------------------------------------------------------------------

WitCoeff::WitCoeff (WitOptCon * theCon, WitOptVar * theVar, double theValue):

      myCon_   (theCon),
      myVar_   (theVar),
      myValue_ (theValue)
   {
   }

//------------------------------------------------------------------------------

WitCoeff::~WitCoeff ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class OptVC.
//------------------------------------------------------------------------------

WitOptVC::WitOptVC (WitOptProblem * theOptProblem, int theIndex):

      myCoeffVec_ (),
      nCoeffs_    (0),
      bounds_     (0.0, 0.0),
      index_      (theIndex)
   {
   }

//------------------------------------------------------------------------------

WitOptVC::~WitOptVC ()
   {
   }

//------------------------------------------------------------------------------

void WitOptVC::writeExtReal (
      FILE * outFile,
      const char * fFormat,
      const char * sFormat,
      double val)
   {
   if      (val == + DBL_MAX)
      fprintf (outFile, sFormat, "+Infty");

   else if (val == - DBL_MAX)
      fprintf (outFile, sFormat, "-Infty");

   else
      fprintf (outFile, fFormat, val);
   }

//------------------------------------------------------------------------------

void WitOptVC::allocMyCoeffs (int nCoeffsForOptVC)
   {
   myCoeffVec_.resize (nCoeffsForOptVC);
   }

//------------------------------------------------------------------------------

void WitOptVC::clearMyCoeffs ()
   {
   nCoeffs_ = 0;
   }

//------------------------------------------------------------------------------

void WitOptVC::store (WitCoeff * theCoeff)
   {
   myCoeffVec_[nCoeffs_] = theCoeff;

   nCoeffs_ ++;
   }

//------------------------------------------------------------------------------

void WitOptVC::compBounds ()
   {
   bounds_.upper () = upperBoundVal ();
   bounds_.lower () = lowerBoundVal ();
   }

//------------------------------------------------------------------------------

void WitOptVC::printID ()
   {
   fprintf (myOptProblem ()->optProbFile (), "%s #%-7d %-12s",
      kindText (), index (), classText ());

   printSource ();
   }

//------------------------------------------------------------------------------

void WitOptVC::printBounds (const WitBoundPair & preScreenBounds)
   {
   writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
      bounds ().lower ());

   writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
      bounds ().upper ());

   if (preScreenBounds.lower () == bounds ().lower ())
      fprintf (myOptProblem ()->optProbFile (), " %7s", "");
   else
      writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
         preScreenBounds.lower ());

   if (preScreenBounds.upper () == bounds ().upper ())
      fprintf (myOptProblem ()->optProbFile (), " %7s", "");
   else
      writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
         preScreenBounds.upper ());

   fprintf (myOptProblem ()->optProbFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitOptVC::attachCoeffItr (WitCoeffItr & theItr)
   {
   myCoeffVec_.attachItr (theItr);
   }

//------------------------------------------------------------------------------

WitProblem * WitOptVC::myProblem ()
   {
   return myOptProblem ()->myProblem ();
   }

//------------------------------------------------------------------------------
// Implementation of class OptVar.
//------------------------------------------------------------------------------

WitOptVar::WitOptVar (WitOptProblem * theOptProblem):

      WitOptVC  (theOptProblem, theOptProblem->nOptVars ()),
      objCoeff_ (0.0)
   {
   theOptProblem->store (this);
   }

//------------------------------------------------------------------------------

WitOptVar::~WitOptVar ()
   {
   }

//------------------------------------------------------------------------------

double WitOptVar::solnValue ()
   {
   return primalValue ();
   }

//------------------------------------------------------------------------------

double WitOptVar::indepInitValue ()
   {
   return 0.0;
   }

//------------------------------------------------------------------------------

bool WitOptVar::isAnIntVar ()
   {
   return false;
   }

//------------------------------------------------------------------------------

const char * WitOptVar::lexObjElemName ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

void WitOptVar::reportLexUnbounded ()
   {
   stronglyAssert (false);
   }

//------------------------------------------------------------------------------

WitDetVar * WitOptVar::mandDetVar ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

WitStochVar * WitOptVar::mandStochVar ()
   {
   stronglyAssert (false);

   return NULL;
   }

//------------------------------------------------------------------------------

void WitOptVar::incCoeff (double delta)
   {
   witAssert (this != NULL);

   myOptProblem ()->incCoeff (this, delta);
   }

//------------------------------------------------------------------------------

void WitOptVar::generateObjCoeff ()
   {
   if (myOptProblem ()->myOptComp ()->multiObjMode ())
      {
      objCoeff_ = 0.0;
      }
   else
      objCoeff_ = compObjCoeff ();
   }

//------------------------------------------------------------------------------

void WitOptVar::print ()
   {
   printID ();

   fprintf (myOptProblem ()->optProbFile (), 
      " %1s %8.1f",
      isAnIntVar ()? "I": " ",
      objCoeff ());

   printBounds (myOptProblem ()->preScreenBounds (this));
   }

//------------------------------------------------------------------------------

double WitOptVar::reducedReward ()
   {
   double      rrVal;
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   rrVal = objCoeff ();

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      rrVal -= theCoeff->myCon ()->dualValue () * theCoeff->myValue ();

    return rrVal;
   }

//------------------------------------------------------------------------------

void WitOptVar::setPrimalValue (double theValue)
   {
   primalValue_ = theValue;
   }

//------------------------------------------------------------------------------

const char * WitOptVar::kindText ()
   {
   return "Var";
   }

//------------------------------------------------------------------------------
// Implementation of class OptCon.
//------------------------------------------------------------------------------

WitOptCon::WitOptCon (WitOptProblem * theOptProblem):

      WitOptVC   (theOptProblem, theOptProblem->nOptCons ()),

      dualValue_ (0.0)
   {
   theOptProblem->store (this);
   }

//------------------------------------------------------------------------------

WitOptCon::~WitOptCon ()
   {
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      delete theCoeff;
   }

//------------------------------------------------------------------------------

double WitOptCon::solnValue ()
   {
   return dualValue ();
   }

//------------------------------------------------------------------------------
// screenable
//
// Returns true, iff this OptCon can be screened.
//
// It is assumed that all variables that intersect this OptCon are
// constrained (implicitly or explicitly) to be nonnegative.
// The following conditions are tested:
//
// A. The upper bound on this OptCon is zero.
// B. Each variable whose Coeff in this OptCon is negative has an upper bound
//    of zero.
// C. Each variable whose Coeff in this OptCon is non-zero has a nonpositive
//    lower bound and a nonnegative upper bound.
//
// When A and B hold, it follows that any variable with non-zero Coeff in
// this OptCon must be zero to be feasible. If, in addition, C fails to hold,
// then this OptCon causes an infeasibility and so it should not be screened.
// Otherwise, if A, B, and C hold, then this OptCon should be screened.
//------------------------------------------------------------------------------

bool WitOptCon::screenable ()
   {
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   if (fabs (bounds ().upper ()) > FLOAT_EPSILON)
      return false;
         //
         // A fails.

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      if (theCoeff->myValue () < - FLOAT_EPSILON)
         if (fabs (theCoeff->myVar ()->bounds ().upper ()) > FLOAT_EPSILON)
            return false;
               //
               // B fails.

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      {
      if (fabs (theCoeff->myValue ()) <= FLOAT_EPSILON)
         continue;

      if (theCoeff->myVar ()->bounds ().lower () > + FLOAT_EPSILON)
         return false;
            //
            // C fails.

      if (theCoeff->myVar ()->bounds ().upper () < - FLOAT_EPSILON)
         return false;
            //
            // C fails.
      }

   return true;
   }

//------------------------------------------------------------------------------

void WitOptCon::print ()
   {
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   fprintf     (myOptProblem ()->optProbFile (), "\n");
   printID     ();
   printBounds (myOptProblem ()->preScreenBounds (this));

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      {
      theCoeff->myVar ()->printID ();

      fprintf (myOptProblem ()->optProbFile (),
         " %7.1f\n",
         theCoeff->myValue ());
      }
   }

//------------------------------------------------------------------------------

void WitOptCon::setDualValue (double theValue)
   {
   dualValue_ = theValue;
   }

//------------------------------------------------------------------------------

const char * WitOptCon::kindText ()
   {
   return "Con";
   }
@


1.45
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.44
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d37 4
a40 4
lower_ (0.0),
upper_ (0.0)
{
}
d45 4
a48 4
lower_ (lowerInit),
upper_ (upperInit)
{
}
d53 4
a56 4
{
lower () = theBoundPair.lower ();
upper () = theBoundPair.upper ();
}
d61 2
a62 2
{
}
d70 5
a74 5
myCon_   (theCon),
myVar_   (theVar),
myValue_ (theValue)
{
}
d79 2
a80 2
{
}
d88 6
a93 6
myCoeffVec_ (),
nCoeffs_    (0),
bounds_     (0.0, 0.0),
index_      (theIndex)
{
}
d98 2
a99 2
{
}
d104 14
a117 14
FILE * outFile,
const char * fFormat,
const char * sFormat,
double val)
{
if      (val == + DBL_MAX)
fprintf (outFile, sFormat, "+Infty");

else if (val == - DBL_MAX)
fprintf (outFile, sFormat, "-Infty");

else
fprintf (outFile, fFormat, val);
}
d122 3
a124 3
{
myCoeffVec_.resize (nCoeffsForOptVC);
}
d129 3
a131 3
{
nCoeffs_ = 0;
}
d136 2
a137 2
{
myCoeffVec_[nCoeffs_] = theCoeff;
d139 2
a140 2
nCoeffs_ ++;
}
d145 4
a148 4
{
bounds_.upper () = upperBoundVal ();
bounds_.lower () = lowerBoundVal ();
}
d153 3
a155 3
{
fprintf (myOptProblem ()->optProbFile (), "%s #%-7d %-12s",
kindText (), index (), classText ());
d157 2
a158 2
printSource ();
}
d163 18
a180 18
{
writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
bounds ().lower ());

writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
bounds ().upper ());

if (preScreenBounds.lower () == bounds ().lower ())
fprintf (myOptProblem ()->optProbFile (), " %7s", "");
else
writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
preScreenBounds.lower ());

if (preScreenBounds.upper () == bounds ().upper ())
fprintf (myOptProblem ()->optProbFile (), " %7s", "");
else
writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
preScreenBounds.upper ());
d182 2
a183 2
fprintf (myOptProblem ()->optProbFile (), "\n");
}
d188 3
a190 3
{
myCoeffVec_.attachItr (theItr);
}
d195 3
a197 3
{
return myOptProblem ()->myProblem ();
}
d205 5
a209 5
WitOptVC  (theOptProblem, theOptProblem->nOptVars ()),
objCoeff_ (0.0)
{
theOptProblem->store (this);
}
d214 2
a215 2
{
}
d220 3
a222 3
{
return primalValue ();
}
d227 3
a229 3
{
return 0.0;
}
d234 3
a236 3
{
return false;
}
d241 2
a242 2
{
stronglyAssert (false);
d244 2
a245 2
return NULL;
}
d250 3
a252 3
{
stronglyAssert (false);
}
d257 2
a258 2
{
stronglyAssert (false);
d260 2
a261 2
return NULL;
}
d266 2
a267 2
{
stronglyAssert (false);
d269 2
a270 2
return NULL;
}
d275 2
a276 2
{
witAssert (this != NULL);
d278 2
a279 2
myOptProblem ()->incCoeff (this, delta);
}
d284 8
a291 8
{
if (myOptProblem ()->myOptComp ()->multiObjMode ())
{
objCoeff_ = 0.0;
}
else
objCoeff_ = compObjCoeff ();
}
d296 2
a297 2
{
printID ();
d299 4
a302 4
fprintf (myOptProblem ()->optProbFile (),
" %1s %8.1f",
isAnIntVar ()? "I": " ",
objCoeff ());
d304 2
a305 2
printBounds (myOptProblem ()->preScreenBounds (this));
}
d310 4
a313 4
{
double      rrVal;
WitCoeffItr theItr;
WitCoeff *  theCoeff;
d315 1
a315 1
rrVal = objCoeff ();
d317 1
a317 1
attachCoeffItr (theItr);
d319 2
a320 2
while (theItr.advance (theCoeff))
rrVal -= theCoeff->myCon ()->dualValue () * theCoeff->myValue ();
d322 2
a323 2
return rrVal;
}
d328 3
a330 3
{
primalValue_ = theValue;
}
d335 3
a337 3
{
return "Var";
}
d345 1
a345 1
WitOptVC   (theOptProblem, theOptProblem->nOptCons ()),
d347 4
a350 4
dualValue_ (0.0)
{
theOptProblem->store (this);
}
d355 9
a363 9
{
WitCoeffItr theItr;
WitCoeff *  theCoeff;

attachCoeffItr (theItr);

while (theItr.advance (theCoeff))
delete theCoeff;
}
d368 3
a370 3
{
return dualValue ();
}
d394 35
a428 3
{
WitCoeffItr theItr;
WitCoeff *  theCoeff;
d430 2
a431 34
if (fabs (bounds ().upper ()) > FLOAT_EPSILON)
return false;
//
// A fails.

attachCoeffItr (theItr);

while (theItr.advance (theCoeff))
if (theCoeff->myValue () < - FLOAT_EPSILON)
if (fabs (theCoeff->myVar ()->bounds ().upper ()) > FLOAT_EPSILON)
return false;
//
// B fails.

attachCoeffItr (theItr);

while (theItr.advance (theCoeff))
{
if (fabs (theCoeff->myValue ()) <= FLOAT_EPSILON)
continue;

if (theCoeff->myVar ()->bounds ().lower () > + FLOAT_EPSILON)
return false;
//
// C fails.

if (theCoeff->myVar ()->bounds ().upper () < - FLOAT_EPSILON)
return false;
//
// C fails.
}

return true;
}
d436 19
a454 19
{
WitCoeffItr theItr;
WitCoeff *  theCoeff;

fprintf     (myOptProblem ()->optProbFile (), "\n");
printID     ();
printBounds (myOptProblem ()->preScreenBounds (this));

attachCoeffItr (theItr);

while (theItr.advance (theCoeff))
{
theCoeff->myVar ()->printID ();

fprintf (myOptProblem ()->optProbFile (),
" %7.1f\n",
theCoeff->myValue ());
}
}
d459 3
a461 3
{
dualValue_ = theValue;
}
d466 3
a468 3
{
return "Con";
}
@


1.43
log
@Revisions for the removal of COIN.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d37 4
a40 4
      lower_ (0.0),
      upper_ (0.0)
   {
   }
d45 4
a48 4
      lower_ (lowerInit),
      upper_ (upperInit)
   {
   }
d53 4
a56 4
   {
   lower () = theBoundPair.lower ();
   upper () = theBoundPair.upper ();
   }
d61 2
a62 2
   {
   }
d70 5
a74 5
      myCon_   (theCon),
      myVar_   (theVar),
      myValue_ (theValue)
   {
   }
d79 2
a80 2
   {
   }
d88 6
a93 6
      myCoeffVec_ (),
      nCoeffs_    (0),
      bounds_     (0.0, 0.0),
      index_      (theIndex)
   {
   }
d98 2
a99 2
   {
   }
d104 14
a117 14
      FILE * outFile,
      const char * fFormat,
      const char * sFormat,
      double val)
   {
   if      (val == + DBL_MAX)
      fprintf (outFile, sFormat, "+Infty");

   else if (val == - DBL_MAX)
      fprintf (outFile, sFormat, "-Infty");

   else
      fprintf (outFile, fFormat, val);
   }
d122 3
a124 3
   {
   myCoeffVec_.resize (nCoeffsForOptVC);
   }
d129 3
a131 3
   {
   nCoeffs_ = 0;
   }
d136 2
a137 2
   {
   myCoeffVec_[nCoeffs_] = theCoeff;
d139 2
a140 2
   nCoeffs_ ++;
   }
d145 4
a148 4
   {
   bounds_.upper () = upperBoundVal ();
   bounds_.lower () = lowerBoundVal ();
   }
d153 3
a155 3
   {
   fprintf (myOptProblem ()->optProbFile (), "%s #%-7d %-12s",
      kindText (), index (), classText ());
d157 2
a158 2
   printSource ();
   }
d163 18
a180 18
   {
   writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
      bounds ().lower ());

   writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
      bounds ().upper ());

   if (preScreenBounds.lower () == bounds ().lower ())
      fprintf (myOptProblem ()->optProbFile (), " %7s", "");
   else
      writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
         preScreenBounds.lower ());

   if (preScreenBounds.upper () == bounds ().upper ())
      fprintf (myOptProblem ()->optProbFile (), " %7s", "");
   else
      writeExtReal (myOptProblem ()->optProbFile (), " %7.1f", " %7s",
         preScreenBounds.upper ());
d182 2
a183 2
   fprintf (myOptProblem ()->optProbFile (), "\n");
   }
d188 3
a190 3
   {
   myCoeffVec_.attachItr (theItr);
   }
d195 3
a197 3
   {
   return myOptProblem ()->myProblem ();
   }
d205 5
a209 5
      WitOptVC  (theOptProblem, theOptProblem->nOptVars ()),
      objCoeff_ (0.0)
   {
   theOptProblem->store (this);
   }
d214 2
a215 2
   {
   }
d220 3
a222 3
   {
   return primalValue ();
   }
d227 3
a229 3
   {
   return 0.0;
   }
d234 3
a236 3
   {
   return false;
   }
d241 2
a242 2
   {
   stronglyAssert (false);
d244 2
a245 2
   return NULL;
   }
d250 3
a252 3
   {
   stronglyAssert (false);
   }
d257 2
a258 2
   {
   stronglyAssert (false);
d260 2
a261 2
   return NULL;
   }
d266 2
a267 2
   {
   stronglyAssert (false);
d269 2
a270 2
   return NULL;
   }
d275 2
a276 2
   {
   witAssert (this != NULL);
d278 2
a279 2
   myOptProblem ()->incCoeff (this, delta);
   }
d284 8
a291 8
   {
   if (myOptProblem ()->myOptComp ()->multiObjMode ())
      {
      objCoeff_ = 0.0;
      }
   else
      objCoeff_ = compObjCoeff ();
   }
d296 2
a297 2
   {
   printID ();
d299 4
a302 4
   fprintf (myOptProblem ()->optProbFile (), 
      " %1s %8.1f",
      isAnIntVar ()? "I": " ",
      objCoeff ());
d304 2
a305 2
   printBounds (myOptProblem ()->preScreenBounds (this));
   }
d310 4
a313 4
   {
   double      rrVal;
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;
d315 1
a315 1
   rrVal = objCoeff ();
d317 1
a317 1
   attachCoeffItr (theItr);
d319 2
a320 2
   while (theItr.advance (theCoeff))
      rrVal -= theCoeff->myCon ()->dualValue () * theCoeff->myValue ();
d322 2
a323 2
    return rrVal;
   }
d328 3
a330 3
   {
   primalValue_ = theValue;
   }
d335 3
a337 3
   {
   return "Var";
   }
d345 1
a345 1
      WitOptVC   (theOptProblem, theOptProblem->nOptCons ()),
d347 4
a350 4
      dualValue_ (0.0)
   {
   theOptProblem->store (this);
   }
d355 9
a363 9
   {
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      delete theCoeff;
   }
d368 3
a370 3
   {
   return dualValue ();
   }
d394 3
a396 35
   {
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   if (fabs (bounds ().upper ()) > FLOAT_EPSILON)
      return false;
         //
         // A fails.

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      if (theCoeff->myValue () < - FLOAT_EPSILON)
         if (fabs (theCoeff->myVar ()->bounds ().upper ()) > FLOAT_EPSILON)
            return false;
               //
               // B fails.

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      {
      if (fabs (theCoeff->myValue ()) <= FLOAT_EPSILON)
         continue;

      if (theCoeff->myVar ()->bounds ().lower () > + FLOAT_EPSILON)
         return false;
            //
            // C fails.

      if (theCoeff->myVar ()->bounds ().upper () < - FLOAT_EPSILON)
         return false;
            //
            // C fails.
      }
d398 34
a431 2
   return true;
   }
d436 19
a454 19
   {
   WitCoeffItr theItr;
   WitCoeff *  theCoeff;

   fprintf     (myOptProblem ()->optProbFile (), "\n");
   printID     ();
   printBounds (myOptProblem ()->preScreenBounds (this));

   attachCoeffItr (theItr);

   while (theItr.advance (theCoeff))
      {
      theCoeff->myVar ()->printID ();

      fprintf (myOptProblem ()->optProbFile (),
         " %7.1f\n",
         theCoeff->myValue ());
      }
   }
d459 3
a461 3
   {
   dualValue_ = theValue;
   }
d466 3
a468 3
   {
   return "Con";
   }
@


1.42
log
@Removed COIN from WIT.
@
text
@a19 1
//    SolverMgr
a24 2
#include <CplexMgr.h>
#include <SolverMgr.h>
a468 127

//------------------------------------------------------------------------------
// Implementation of class SolverMgr.
//------------------------------------------------------------------------------

WitSolverMgr::~WitSolverMgr ()
   {
   }

//------------------------------------------------------------------------------

#ifdef CPLEX_EMBEDDED

bool WitSolverMgr::cplexEmbedded ()
   {
   return true;
   }

#else

bool WitSolverMgr::cplexEmbedded ()
   {
   return false;
   }

#endif

//------------------------------------------------------------------------------

WitSolverMgr * WitSolverMgr::newInstance (WitOptProblem * theOptProblem)
   {
   return newInstanceForCplex (theOptProblem);
   }

//------------------------------------------------------------------------------

WitSolverMgr::WitSolverMgr (WitOptProblem * theOptProblem):

      WitProbAssoc  (theOptProblem),
      myOptProblem_ (theOptProblem)
   {
   }

//------------------------------------------------------------------------------

void WitSolverMgr::getInitSoln (WitVector <double> & initSoln)
   {
   WitOptVar * theVar;
      
   WitTimer::enterSection ("opt-prob");

   initSoln.resize (myOptProblem ()->nOptVars (), 0.0);

   forEachEl (theVar, myOptProblem ()->myOptVars ())
      initSoln[theVar->index ()] = theVar->primalValue ();

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitSolverMgr::storePrimalSoln (const double * primalSoln)
   {
   WitOptVar * theVar;
   double      thePrimalVal;

   WitTimer::enterSection ("opt-prob");

   forEachEl (theVar, myOptProblem ()->myOptVars ())
      {
      thePrimalVal = primalSoln[theVar->index ()];

      theVar->setPrimalValue (thePrimalVal);
      }

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

void WitSolverMgr::storeDualSoln (const double * dualSoln)
   {
   WitOptCon * theCon;
   double      theDualVal;

   WitTimer::enterSection ("opt-prob");

   forEachEl (theCon, myOptProblem ()->myOptCons ())
      {
      theDualVal = dualSoln[theCon->index ()];

      theCon->setDualValue (theDualVal);
      }

   WitTimer::leaveSection ("opt-prob");
   }

//------------------------------------------------------------------------------

bool WitSolverMgr::mipMode ()
   {
   return myOptComp ()->mipMode ();
   }

//------------------------------------------------------------------------------

#ifdef CPLEX_EMBEDDED

WitSolverMgr * WitSolverMgr::newInstanceForCplex (WitOptProblem * theOptProblem)
   {
   return new WitCplexMgr (theOptProblem);
   }

#endif

//------------------------------------------------------------------------------

#ifndef CPLEX_EMBEDDED

WitSolverMgr * WitSolverMgr::newInstanceForCplex (WitOptProblem * theOptProblem)
   {
   stronglyAssert (false);

   return NULL;
   }

#endif
@


1.41
log
@CPLEX
@
text
@a25 1
#include <CoinMgr.h>
a482 18
#ifdef COIN_EMBEDDED

bool WitSolverMgr::coinEmbedded ()
   {
   return true;
   }

#else

bool WitSolverMgr::coinEmbedded ()
   {
   return false;
   }

#endif

//------------------------------------------------------------------------------

d503 1
a503 16
   if      (theOptProblem->myOptComp ()->coinSelected ())
      {
      return newInstanceForCoin (theOptProblem);
      }

   else if (theOptProblem->myOptComp ()->cplexSelected ())
      {
      return newInstanceForCplex (theOptProblem);
      }

   else
      {
      stronglyAssert (false);

      return NULL;
      }
a577 24
#ifdef COIN_EMBEDDED

WitSolverMgr * WitSolverMgr::newInstanceForCoin (WitOptProblem * theOptProblem)
   {
   return new WitCoinMgr (theOptProblem);
   }

#endif

//------------------------------------------------------------------------------

#ifndef COIN_EMBEDDED

WitSolverMgr * WitSolverMgr::newInstanceForCoin (WitOptProblem * theOptProblem)
   {
   stronglyAssert (false);

   return NULL;
   }

#endif

//------------------------------------------------------------------------------

@


1.40
log
@CPLEX
@
text
@d26 2
d478 42
d524 1
a524 1
      return newSolverMgrForCoin (theOptProblem);
d529 1
a529 1
      return newSolverMgrForCplex (theOptProblem);
a541 6
WitSolverMgr::~WitSolverMgr ()
   {
   }

//------------------------------------------------------------------------------

d609 48
@


1.39
log
@CPLEX
@
text
@a20 1
//    NoSolverMgr
d26 1
a26 1
#include <NoSolverMgr.h>
d490 3
a492 1
      return new WitNoSolverMgr (theOptProblem);
a570 23

//------------------------------------------------------------------------------
// Implementation of class NoSolverMgr.
//------------------------------------------------------------------------------

WitNoSolverMgr::WitNoSolverMgr (WitOptProblem * theOptProblem):

      WitSolverMgr (theOptProblem)
   {
   }

//------------------------------------------------------------------------------

WitNoSolverMgr::~WitNoSolverMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitNoSolverMgr::solveOptProb ()
   {
   stronglyAssert (false);
   }
@


1.38
log
@CPLEX
@
text
@d565 7
@


1.37
log
@Fixed a bug:
   External optimizing implosion issued a fatal error when invoked without
   a selected solver.
@
text
@d582 1
a582 1
void WitNoSolverMgr::solve ()
@


1.36
log
@CPLEX
@
text
@d21 1
d27 1
a27 1
#include <SolverMgr.h>
d479 1
a479 1
   if (theOptProblem->myOptComp ()->coinSelected ())
d484 1
a484 1
   if (theOptProblem->myOptComp ()->cplexSelected ())
d489 4
a492 3
   stronglyAssert (false);

   return NULL;
d563 23
@


1.35
log
@CPLEX
@
text
@d482 2
a483 1
   else if (theOptProblem->myOptComp ()->cplexSelected ())
d487 4
a490 4
   else
      {
      return NULL;
      }
@


1.34
log
@CPLEX
@
text
@d478 1
a478 1
   if (theOptProblem->myOptComp ()->solverIsCoin ())
d482 1
a482 1
   else if (theOptProblem->myOptComp ()->solverIsCplex ())
@


1.33
log
@CPLEX
@
text
@d29 1
d506 54
@


1.32
log
@CPLEX
@
text
@d27 1
a27 1
#include <OptModel.h>
d87 1
a87 1
WitOptVC::WitOptVC (WitOptModel * theOptModel, int theIndex):
d155 1
a155 1
   fprintf (myOptModel ()->modelFile (), "%s #%-7d %-12s",
d165 1
a165 1
   writeExtReal (myOptModel ()->modelFile (), " %7.1f", " %7s",
d168 1
a168 1
   writeExtReal (myOptModel ()->modelFile (), " %7.1f", " %7s",
d172 1
a172 1
      fprintf (myOptModel ()->modelFile (), " %7s", "");
d174 1
a174 1
      writeExtReal (myOptModel ()->modelFile (), " %7.1f", " %7s",
d178 1
a178 1
      fprintf (myOptModel ()->modelFile (), " %7s", "");
d180 1
a180 1
      writeExtReal (myOptModel ()->modelFile (), " %7.1f", " %7s",
d183 1
a183 1
   fprintf (myOptModel ()->modelFile (), "\n");
d197 1
a197 1
   return myOptModel ()->myProblem ();
d204 1
a204 1
WitOptVar::WitOptVar (WitOptModel * theOptModel):
d206 1
a206 1
      WitOptVC  (theOptModel, theOptModel->nOptVars ()),
d209 1
a209 1
   theOptModel->store (this);
d279 1
a279 1
   myOptModel ()->incCoeff (this, delta);
d286 1
a286 1
   if (myOptModel ()->myOptComp ()->multiObjMode ())
d300 1
a300 1
   fprintf (myOptModel ()->modelFile (), 
d305 1
a305 1
   printBounds (myOptModel ()->preScreenBounds (this));
d344 1
a344 1
WitOptCon::WitOptCon (WitOptModel * theOptModel):
d346 1
a346 1
      WitOptVC   (theOptModel, theOptModel->nOptCons ()),
d350 1
a350 1
   theOptModel->store (this);
d441 1
a441 1
   fprintf     (myOptModel ()->modelFile (), "\n");
d443 1
a443 1
   printBounds (myOptModel ()->preScreenBounds (this));
d451 3
a453 1
      fprintf (myOptModel ()->modelFile (), " %7.1f\n", theCoeff->myValue ());
d475 1
a475 1
WitSolverMgr * WitSolverMgr::newInstance (WitOptModel * theOptModel)
d477 1
a477 1
   if (theOptModel->myOptComp ()->solverIsCoin ())
d479 1
a479 1
      return newSolverMgrForCoin (theOptModel);
d481 1
a481 1
   else if (theOptModel->myOptComp ()->solverIsCplex ())
d483 1
a483 1
      return newSolverMgrForCplex (theOptModel);
d499 1
a499 1
WitSolverMgr::WitSolverMgr (WitOptModel * theOptModel):
d501 2
a502 2
      WitProbAssoc (theOptModel),
      myOptModel_  (theOptModel)
@


1.31
log
@*** empty log message ***
@
text
@a26 1
#include <CplexMgr.h>
d481 1
a481 1
      return new WitCplexMgr (theOptModel);
@


1.30
log
@Embedded CPLEX.
@
text
@a20 1
//    NoSolverMgr
a26 1
#include <NoSolverMgr.h>
a503 23

//------------------------------------------------------------------------------
// Implementation of class NoSolverMgr.
//------------------------------------------------------------------------------

WitNoSolverMgr::WitNoSolverMgr (WitOptModel * theOptModel):

      WitSolverMgr (theOptModel)
   {
   }

//------------------------------------------------------------------------------

WitNoSolverMgr::~WitNoSolverMgr ()
   {
   }

//------------------------------------------------------------------------------

void WitNoSolverMgr::solve ()
   {
   stronglyAssert (false);
   }
@


1.29
log
@CPLEX
@
text
@d488 1
a488 1
      return new WitNoSolverMgr (theOptModel);
@


1.28
log
@CPLEX
@
text
@a28 1
#include <CoinMgr.h>
d480 1
a480 1
      return new WitCoinMgr (theOptModel);
@


1.27
log
@Preparing for embedded CPLEX.
@
text
@d30 1
d481 5
a485 1
      return new WitCoinMgr     (theOptModel);
@


1.26
log
@Preparing for embedded CPLEX.
@
text
@d480 1
a480 1
      return newInstanceForCoin (theOptModel);
a503 17

WitSolverMgr * WitSolverMgr::newInstanceForCoin (WitOptModel * theOptModel)
   {
#if COIN_EMBEDDED

   return new WitCoinMgr (theOptModel);

#else

   stronglyAssert (false);

   return NULL;

#endif
   }

//------------------------------------------------------------------------------
@


1.25
log
@Preparing for embedded CPLEX.
@
text
@d478 8
a485 9
#if COIN_EMBEDDED

   return new WitCoinMgr     (theOptModel);

#else

   return new WitNoSolverMgr (theOptModel);

#endif
a523 2
#if ! SOLVER_EMBEDDED

a541 2

#endif // not SOLVER_EMBEDDED
@


1.24
log
@Revising the build procedure.
@
text
@d505 17
@


1.23
log
@Revising the build procedure.
@
text
@d508 1
a508 1
#if ! COIN_EMBEDDED
d529 1
a529 1
#endif // not COIN_EMBEDDED
@


1.22
log
@Revising the build procedure.
@
text
@d478 1
a478 1
#if WIT_EMBEDS_COIN
d508 1
a508 1
#if ! WIT_EMBEDS_COIN
d529 1
a529 1
#endif // not WIT_EMBEDS_COIN
@


1.21
log
@Removed OptObj classes.
@
text
@a475 2
#ifdef OPT_IMPLODE

d478 3
a480 2
   return new WitCoinMgr (theOptModel);
   }
a483 2
WitSolverMgr * WitSolverMgr::newInstance (WitOptModel * theOptModel)
   {
a484 1
   }
d487 1
d508 1
a508 1
#ifndef OPT_IMPLODE
d529 1
a529 1
#endif // non-OPT_IMPLODE
@


1.20
log
@Multi-Obj Mode
@
text
@a16 1
//    OptObj
a24 1
#include <OptObj.h>
d31 1
a86 60
// Implementation of class OptObj.
//------------------------------------------------------------------------------

WitOptObj::~WitOptObj ()
   {
   }

//------------------------------------------------------------------------------

void WitOptObj::print ()
   {
   WitOptVar * theVar;
   double      varCoeffVal;

   fprintf (myOptModel_->modelFile (), "\n%s:\n", myText ());

   forEachEl (theVar, myOptModel_->myOptVars ())
      {
      varCoeffVal = coeffVal (theVar);

      if (fabs (varCoeffVal) > FLOAT_EPSILON)
         {
         theVar->printID ();

         fprintf (myOptModel_->modelFile (), " %8.1f\n", varCoeffVal);
         }
      }
   }

//------------------------------------------------------------------------------

double WitOptObj::myValue ()
   {
   WitOptVar * theVar;
   double      varVal;
   double      val = 0.0;

   forEachEl (theVar, myOptModel_->myOptVars ())
      {
      varVal = theVar->primalValue ();

      if (fabs (varVal) > FLOAT_EPSILON)
         val += coeffVal (theVar) * varVal;
      }

   return val;
   }

//------------------------------------------------------------------------------

WitOptObj::WitOptObj (const char * theText, WitOptModel * theOptModel):

      WitProbAssoc (theOptModel),
      myText_      (theText),
      myOptModel_  (theOptModel)
   {
   myOptModel_->store (this);
   }

//------------------------------------------------------------------------------
d209 2
a210 3
      WitOptVC         (theOptModel, theOptModel->nOptVars ()),

      mainObjCoeffVal_ (0.0)
d287 1
a287 1
void WitOptVar::compMainObjCoeffVal ()
d289 6
a294 1
   mainObjCoeffVal_ = myOptModel ()->mainObj ()->coeffVal (this);
d306 1
a306 1
      mainObjCoeffVal ());
d319 1
a319 1
   rrVal = mainObjCoeffVal ();
@


1.19
log
@Multi-Obj Mode
@
text
@d306 1
a306 1
const char * WitOptVar::lexObjCompName ()
@


1.18
log
@Multi-objective mode
@
text
@d306 1
a306 1
const char * WitOptVar::lexObjElemName ()
@


1.17
log
@Multi-objective mode
@
text
@d306 1
a306 1
const WitString & WitOptVar::lexObjElemName ()
d310 1
a310 1
   exit (4);
@


1.16
log
@Multi-objective mode
@
text
@d315 7
@


1.15
log
@Multi-objective mode
@
text
@d306 9
@


1.14
log
@Stochastic Implosion
@
text
@d21 2
a22 1
//    OptSolver
d29 3
a31 1
#include <OptSolver.h>
a32 1
#include <CoinSolver.h>
d514 1
a514 1
// OPT_IMPLODE mode implementation of class OptSolver.
d519 4
a522 1
WitOptSolver::WitOptSolver (WitOptModel * theOptModel):
d524 3
a526 2
      WitProbAssoc  (theOptModel),
      myCoinSolver_ (NULL)
d528 1
a528 1
   myCoinSolver_ = new WitCoinSolver (theOptModel);
d531 2
d535 1
a535 1
WitOptSolver::~WitOptSolver ()
a536 1
   delete myCoinSolver_;
d541 4
a544 1
void WitOptSolver::solve ()
a545 1
   myCoinSolver_->solve ();
a547 2
#endif // OPT_IMPLODE

d549 1
a549 1
// Non-OPT_IMPLODE mode implementation of class OptSolver.
d554 1
a554 1
WitOptSolver::WitOptSolver (WitOptModel * theOptModel):
d556 1
a556 2
      WitProbAssoc  (theOptModel),
      myCoinSolver_ (NULL)
d562 1
a562 1
WitOptSolver::~WitOptSolver ()
d568 1
a568 1
void WitOptSolver::solve ()
@


1.13
log
@Stochastic Implosion
@
text
@d100 1
a100 1
   fprintf (myOptModel_->optProbFile (), "\n%s:\n", myText ());
d110 1
a110 1
         fprintf (myOptModel_->optProbFile (), " %8.1f\n", varCoeffVal);
d217 1
a217 1
   fprintf (myOptModel ()->optProbFile (), "%s #%-7d %-12s",
d227 1
a227 1
   writeExtReal (myOptModel ()->optProbFile (), " %7.1f", " %7s",
d230 1
a230 1
   writeExtReal (myOptModel ()->optProbFile (), " %7.1f", " %7s",
d234 1
a234 1
      fprintf (myOptModel ()->optProbFile (), " %7s", "");
d236 1
a236 1
      writeExtReal (myOptModel ()->optProbFile (), " %7.1f", " %7s",
d240 1
a240 1
      fprintf (myOptModel ()->optProbFile (), " %7s", "");
d242 1
a242 1
      writeExtReal (myOptModel ()->optProbFile (), " %7.1f", " %7s",
d245 1
a245 1
   fprintf (myOptModel ()->optProbFile (), "\n");
d342 1
a342 1
   fprintf (myOptModel ()->optProbFile (), 
d483 1
a483 1
   fprintf     (myOptModel ()->optProbFile (), "\n");
d493 1
a493 1
      fprintf (myOptModel ()->optProbFile (), " %7.1f\n", theCoeff->myValue ());
@


1.12
log
@Stochastic Implosion
@
text
@d29 1
a29 1
#include <OptProb.h>
d100 1
a100 1
   fprintf (myOptProb_->optProbFile (), "\n%s:\n", myText ());
d102 1
a102 1
   forEachEl (theVar, myOptProb_->myOptVars ())
d110 1
a110 1
         fprintf (myOptProb_->optProbFile (), " %8.1f\n", varCoeffVal);
d123 1
a123 1
   forEachEl (theVar, myOptProb_->myOptVars ())
d136 1
a136 1
WitOptObj::WitOptObj (const char * theText, WitOptProb * theOptProb):
d138 1
a138 1
      WitProbAssoc (theOptProb),
d140 1
a140 1
      myOptProb_   (theOptProb)
d142 1
a142 1
   myOptProb_->store (this);
d149 1
a149 1
WitOptVC::WitOptVC (WitOptProb * theOptProb, int theIndex):
d217 1
a217 1
   fprintf (myOptProb ()->optProbFile (), "%s #%-7d %-12s",
d227 1
a227 1
   writeExtReal (myOptProb ()->optProbFile (), " %7.1f", " %7s",
d230 1
a230 1
   writeExtReal (myOptProb ()->optProbFile (), " %7.1f", " %7s",
d234 1
a234 1
      fprintf (myOptProb ()->optProbFile (), " %7s", "");
d236 1
a236 1
      writeExtReal (myOptProb ()->optProbFile (), " %7.1f", " %7s",
d240 1
a240 1
      fprintf (myOptProb ()->optProbFile (), " %7s", "");
d242 1
a242 1
      writeExtReal (myOptProb ()->optProbFile (), " %7.1f", " %7s",
d245 1
a245 1
   fprintf (myOptProb ()->optProbFile (), "\n");
d259 1
a259 1
   return myOptProb ()->myProblem ();
d266 1
a266 1
WitOptVar::WitOptVar (WitOptProb * theOptProb):
d268 1
a268 1
      WitOptVC         (theOptProb, theOptProb->nOptVars ()),
d272 1
a272 1
   theOptProb->store (this);
d326 1
a326 1
   myOptProb ()->incCoeff (this, delta);
d333 1
a333 1
   mainObjCoeffVal_ = myOptProb ()->mainObj ()->coeffVal (this);
d342 1
a342 1
   fprintf (myOptProb ()->optProbFile (), 
d347 1
a347 1
   printBounds (myOptProb ()->preScreenBounds (this));
d386 1
a386 1
WitOptCon::WitOptCon (WitOptProb * theOptProb):
d388 1
a388 1
      WitOptVC   (theOptProb, theOptProb->nOptCons ()),
d392 1
a392 1
   theOptProb->store (this);
d483 1
a483 1
   fprintf     (myOptProb ()->optProbFile (), "\n");
d485 1
a485 1
   printBounds (myOptProb ()->preScreenBounds (this));
d493 1
a493 1
      fprintf (myOptProb ()->optProbFile (), " %7.1f\n", theCoeff->myValue ());
d517 1
a517 1
WitOptSolver::WitOptSolver (WitOptProb * theOptProb):
d519 1
a519 1
      WitProbAssoc  (theOptProb),
d522 1
a522 1
   myCoinSolver_ = new WitCoinSolver (theOptProb);
d547 1
a547 1
WitOptSolver::WitOptSolver (WitOptProb * theOptProb):
d549 1
a549 1
      WitProbAssoc  (theOptProb),
@


1.11
log
@Stochastic Implosion
@
text
@d18 1
a18 1
//    OptProbEl
d146 1
a146 1
// Implementation of class OptProbEl.
d149 1
a149 1
WitOptProbEl::WitOptProbEl (WitOptProb * theOptProb, int theIndex):
d160 1
a160 1
WitOptProbEl::~WitOptProbEl ()
d166 1
a166 1
void WitOptProbEl::writeExtReal (
d184 1
a184 1
void WitOptProbEl::allocMyCoeffs (int nCoeffsForOptProbEl)
d186 1
a186 1
   myCoeffVec_.resize (nCoeffsForOptProbEl);
d191 1
a191 1
void WitOptProbEl::clearMyCoeffs ()
d198 1
a198 1
void WitOptProbEl::store (WitCoeff * theCoeff)
d207 1
a207 1
void WitOptProbEl::compBounds ()
d215 1
a215 1
void WitOptProbEl::printID ()
d225 1
a225 1
void WitOptProbEl::printBounds (const WitBoundPair & preScreenBounds)
d250 1
a250 1
void WitOptProbEl::attachCoeffItr (WitCoeffItr & theItr)
d257 1
a257 1
WitProblem * WitOptProbEl::myProblem ()
d268 1
a268 1
      WitOptProbEl     (theOptProb, theOptProb->nOptVars ()),
d388 1
a388 1
      WitOptProbEl (theOptProb, theOptProb->nOptCons ()),
d390 1
a390 1
      dualValue_   (0.0)
@


1.10
log
@Stochastic Implosion
@
text
@d110 1
a110 1
         fprintf (myOptProb_->optProbFile (), " %7.1f\n", varCoeffVal);
d343 1
a343 1
      " %1s %7.1f",
@


1.9
log
@Stochastic Implosion
@
text
@d343 1
a343 1
      " %1s %7.2f",
@


1.8
log
@Stochastic Implosion
@
text
@d209 2
a210 2
   bounds_.upper () = compUpperBound ();
   bounds_.lower () = compLowerBound ();
@


1.7
log
@Stochastic Implosion
@
text
@a183 8
void WitOptProbEl::setBoundsTo (double theLower, double theUpper)
   {
   bounds_.lower () = theLower;
   bounds_.upper () = theUpper;
   }

//------------------------------------------------------------------------------

d207 8
a282 7
void WitOptVar::compBounds ()
   {
   setBoundsTo (0.0, + DBL_MAX);
   }

//------------------------------------------------------------------------------

@


1.6
log
@Stochastic Implosion
@
text
@d95 1
a95 1
void WitOptObj::print () const
d117 1
a117 1
double WitOptObj::myValue () const
@


1.5
log
@Stochastic Implosion
@
text
@d215 1
a215 1
void WitOptProbEl::printID () const
d225 1
a225 1
void WitOptProbEl::printBounds (const WitBoundPair & preScreenBounds) const
d250 1
a250 1
void WitOptProbEl::attachCoeffItr (WitCoeffItr & theItr) const
d257 1
a257 1
WitProblem * WitOptProbEl::myProblem () const
d290 1
a290 1
double WitOptVar::solnValue () const
d297 1
a297 1
double WitOptVar::indepInitValue () const
d304 1
a304 1
bool WitOptVar::isAnIntVar () const
d311 1
a311 1
const WitDetVar * WitOptVar::mandDetVar () const
d320 1
a320 1
const WitStochVar * WitOptVar::mandStochVar () const
d345 1
a345 1
void WitOptVar::print () const
d359 1
a359 1
double WitOptVar::reducedReward () const
d384 1
a384 1
const char * WitOptVar::kindText () const
d417 1
a417 1
double WitOptCon::solnValue () const
d443 1
a443 1
bool WitOptCon::screenable () const
d485 1
a485 1
void WitOptCon::print () const
d513 1
a513 1
const char * WitOptCon::kindText () const
@


1.4
log
@Stochastic Implosion
@
text
@d311 1
a311 1
double WitOptVar::boundsCoeffVal () const
d315 1
a315 1
   return 0.0;
d320 1
a320 1
double WitOptVar::primaryCoeffVal () const
d324 1
a324 46
   return 0.0;
   }

//------------------------------------------------------------------------------

double WitOptVar::revCoeffVal () const
   {
   stronglyAssert (false);

   return 0.0;
   }

//------------------------------------------------------------------------------

double WitOptVar::invCoeffVal () const
   {
   stronglyAssert (false);

   return 0.0;
   }

//------------------------------------------------------------------------------

double WitOptVar::servCoeffVal () const
   {
   stronglyAssert (false);

   return 0.0;
   }

//------------------------------------------------------------------------------

double WitOptVar::subCoeffVal () const
   {
   stronglyAssert (false);

   return 0.0;
   }

//------------------------------------------------------------------------------

double WitOptVar::stochCoeffVal () const
   {
   stronglyAssert (false);

   return 0.0;
@


1.3
log
@Stochastic Implosion
@
text
@d304 7
d313 2
d322 2
d331 2
d340 2
d349 2
d358 2
d365 1
a365 1
bool WitOptVar::isAnIntVar () const
d367 3
a369 1
   return false;
@


1.2
log
@Stochastic Implosion
@
text
@d138 1
a138 1
      WitProbAssoc (theOptProb->myProblem ()),
d550 1
a550 2
      WitProbAssoc  (theOptProb->myProblem ()),

d580 1
a580 2
      WitProbAssoc  (theOptProb->myProblem ()),

@


1.1
log
@Stochastic Implosion
@
text
@d21 1
d28 1
d30 1
d541 60
@


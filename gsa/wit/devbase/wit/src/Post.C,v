head	1.105;
access;
symbols
	sce_5_01_20080919:1.99
	latest_sce_4_20_20060523:1.71.0.2
	sce_4_20_20060523:1.71
	latest_sce4_20_OSL:1.70.0.2
	sce_4_20_OSL:1.70
	sce_410_withVa:1.68
	sce_4_05_20040511:1.65
	sce_4_00_20040201:1.48
	nextGenBranch:1.34.0.2
	nextGenRoot:1.34
	sce_3_30_20030627:1.34
	EndRw-branch:1.25.0.4
	Root-of-EndRw:1.25
	rwToStl:1.25.0.2
	latest_sce_3_10_20010924:1.7.0.2
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.6.0.4
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.105
date	2011.09.28.23.49.56;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2011.09.24.00.28.19;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2011.08.30.20.17.57;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2010.09.10.22.10.40;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2010.03.16.22.42.27;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.03.16.20.22.39;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.11.14.17.18.55;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.11.08.19.16.40;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.11.07.21.50.13;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.03.08.17.02.55;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.03.02.22.11.02;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.03.02.20.56.22;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2007.02.28.22.52.10;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2007.02.28.20.04.58;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2007.02.27.21.03.04;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.10.00.08.14;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.02.08.22.47.35;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.07.17.30.33;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.07.00.13.08;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.02.02.21.36.41;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.02.01.16.31.02;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.01.31.23.30.59;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.31.21.58.02;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.09.19.14.15;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2006.11.22.21.45.07;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2006.11.22.17.24.35;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2006.09.19.17.50.55;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2006.09.08.16.16.01;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2006.09.07.21.29.23;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2006.09.07.20.49.24;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2006.09.06.23.07.07;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2006.09.06.21.17.04;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2006.09.05.21.11.06;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.02.17.34.08;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.09.26.23.02.18;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.03.28.20.14.37;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.02.03.21.20.30;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2005.01.28.19.34.27;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.14.21.25.36;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.13.21.50.14;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.23.19.14.25;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.22.16.37.18;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.12.17.21.55;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.05.00.06.54;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.04.19.53.27;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.03.22.13.06;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.03.20.05.07;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.03.19.07.28;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.02.23.52.14;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.20.15.37.36;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.18.21.53.52;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.31.21.44.53;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.23.16.18.47;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.17.22.30.00;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.15.18.12.02;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.13.00.46.35;	author fasano;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.09.22.44.06;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.31.15.37.55;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.28.19.45.34;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.01.20.53.59;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.30.15.40.55;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.26.20.55.13;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.25.18.51.09;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.24.23.08.17;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.23.18.12.37;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.25.21.07.42;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.23.20.47.19;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.02.23.40.47;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.02.22.18.43;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.12.26.18.35.02;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.12.24.22.50.48;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.23.20.44.47;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.20.22.48.01;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.10.16.22.30.21;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.09.18.42.12;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.07.21.46.37;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.11.18.53.14;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.09.19.52.35;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.05.21.20.00;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.05.19.31.36;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.04.23.07.23;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.03.22.35.21;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.03.16.01.51;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.30.20.09.00;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.21.35.47;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.08.19.21.54;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.07.20.15.01;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.03.23.16.40;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.14.02.41;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.29.23.47.10;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.28.00.12.59;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.25.16.08.18;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.21.20.03.26;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.29.21.22.46;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.26;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.33;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.44;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.28;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.28;	author wit;	state Exp;
branches;
next	;


desc
@@


1.105
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Post.C"
//
// Contains the implementation of class Postprocessor.
//------------------------------------------------------------------------------

#include <Post.h>
#include <FeasChkr.h>
#include <Pre.h>
#include <CompMgr.h>
#include <BoundSet.h>
#include <PipMgr.h>
#include <Timing.h>
#include <HeurAllMgr.h>
#include <FSS.h>
#include <wit/src/Variant.h>
#include <GlobalComp.h>
#include <OptComp.h>
#include <Material.h>
#include <Demand.h>
#include <Operation.h>
#include <BomEntry.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class Postprocessor.
//------------------------------------------------------------------------------

WitPostprocessor::WitPostprocessor (WitProblem * theProblem):

      WitProbAssoc    (theProblem),

      postprocessing_ (false),
      postprocessed_  (false),
      myFeasChkr_     (NULL)
   {
   myFeasChkr_ = new WitFeasChkr (myProblem ());
   }

//------------------------------------------------------------------------------

WitPostprocessor::~WitPostprocessor ()
   {
   delete myFeasChkr_;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::postprocess ()
   {
   WitDemand * theDemand;

   if (postprocessed_)
      return;

   myProblem ()->myHeurAllMgr ()->reset ();

   myPreprocessor ()->preprocess ();

   WitTimer::enterSection ("postproc");

   postprocessing_ = true;

   forEachDemand (theDemand, myProblem ())
      theDemand->initFssShipVolForPost ();

   compNonSubVols ();

   compConsVols ();
   compProdVols ();

   if (not myProblem ()->currentVariant ()->compsSecScheds ())
      {
      compCapacityScrapVols      ();
      compMaterialStockScrapVols ();
      }
 
   compCumShipVols  ();
   compCapResidVols ();

   if (myGlobalComp ()->nstnResidual ())
      compMatResidVolsNstn ();
   else
      compMatResidVolsAsap ();

   myFeasChkr_->compFeasible ();

   postprocessing_ = false;

   postprocessed_  =
      myMsgFac ().displayStateChange (
        "postStateMsg",
         postprocessed_,
         true);

   WitTimer::leaveSection ("postproc");
   }

//------------------------------------------------------------------------------

void WitPostprocessor::unpostprocess ()
   {
   if (not postprocessed_)
      return;

   myFeasChkr_    ->unpostprocess ();
   myOptComp    ()->unpostprocess ();
   myGlobalComp ()->unpostprocess ();

   myProblem ()->myPipMgr ()->clearPegging ();

   myProblem ()->myFSS ()->uncompute ();

   postprocessed_ =
      myMsgFac ().displayStateChange (
        "unpostStateMsg",
         postprocessed_,
         false);
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compNonSubVol (
      WitBomEntry *      theBomEnt,
      WitTVec <double> & nonSubVolVec)
   {
   WitSubEntry * theSub;
   WitPeriod     execPer;

   nonSubVolVec = theBomEnt->myOperation ()->execVol ();

   forEachPeriod (execPer, myProblem ())
      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (theSub->inEffect (execPer))
            nonSubVolVec[execPer] -= theSub->subVol ()[execPer];
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compProdVol (
      WitPart *          thePart,
      WitTVec <double> & prodVolVec)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   prodVolVec = 0.0;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      forEachPeriod (execPer, myProblem ())
         if (theBopEnt->inEffect (execPer))
            prodVolVec[theBopEnt->impactPeriod ()[execPer]] +=
               theBopEnt->effProdRate ()[execPer] *
               theBopEnt->myOperation ()->execVol ()[execPer];
   }

//------------------------------------------------------------------------------

double WitPostprocessor::compExcessVol (WitPart * thePart, WitPeriod thePer)
   {
   double        excVol;
   WitMaterial * theMat;

   excVol = thePart->residualVol ()[thePer];

   if (myGlobalComp ()->minimalExcess ())
      {
      excVol -= thePart->prodVol ()[thePer];

      excVol -= positivePart (- thePart->consVol ()[thePer]);

      theMat  = thePart->thisMat ();

      if (theMat != NULL)
         if (thePer > 0)
            excVol -= stockLB (theMat, thePer - 1);

      excVol  = positivePart (excVol);
      }

   setToMin (excVol, thePart->supplyVol ()[thePer]);

   return excVol;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compNonSubVols ()
   {
   WitTVec <double> nonSubVolVec;
   WitBomEntry *    theBomEnt;

   nonSubVolVec.allocate  (myProblem (), 0.0);

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         {
         compNonSubVol (theBomEnt, nonSubVolVec);

         theBomEnt->storePostNonSubVol (nonSubVolVec);
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compConsVols ()
   {
   WitPart *        thePart;
   WitBomEntry *    theBomEnt;
   WitSubEntry *    theSub;
   WitTVec <double> consVolVec (myProblem (), 0.0);
   WitTVec <double> execVolVec (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      consVolVec = 0.0;

      forEachEl (theBomEnt, thePart->consumingBomEntries ())
         {
         execVolVec = theBomEnt->nonSubVol ();

         theBomEnt->incConsVol (consVolVec, execVolVec);
         }

      forEachEl (theSub, thePart->consumingSubEntries ())
         {
         execVolVec = theSub->subVol ();

         theSub->incConsVol (consVolVec, execVolVec);
         }

      thePart->storePostConsVol (consVolVec);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compProdVols ()
   {
   WitPart *        thePart;
   WitTVec <double> prodVolVec (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      compProdVol (thePart, prodVolVec);

      thePart->storePostProdVol (prodVolVec);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compCapacityScrapVols ()
   {
   WitPart *        thePart;
   WitPeriod        thePer;
   WitTVec <double> scrapVolVec (myProblem (), 0.0);

   forEachPart (thePart, this)
      if (thePart->thisCap () != NULL)
         {
         forEachPeriod (thePer, myProblem ())
            scrapVolVec[thePer] = unstockedScrapVol (thePart, thePer);

         thePart->storePostScrapVol (scrapVolVec);
         }
   }

//------------------------------------------------------------------------------
// compMaterialStockScrapVols.
// Computes scrapVol and stockVol.
// This is done by rolling the inventory forward in time, allocating as much of
// it as possible to stock and scrapping the rest. Then rollBackScrap is
// applied. Lower bounds on stock are respected to the extent possible given
// the production and shipment schedules. Upper bounds on stock are respected
// if appropriate for the currentVariant. If the solution implies a negative
// stockVol or scrapVol (due to a numerical problem or a genuine constraint
// violation), the negative value is assigned to the scrapVol rather than the
// stockVol.
//------------------------------------------------------------------------------

void WitPostprocessor::compMaterialStockScrapVols ()
   {
   WitMaterial * theMat;
   WitPeriod     thePer;
   double        rollingInv;  // Rolling inventory in thePer.
   double        stockVolVal; // stockVol[thePer].

   WitTVec <double> stockVolVec (myProblem (), 0.0);
   WitTVec <double> scrapVolVec (myProblem (), 0.0);

   forEachMaterial (theMat, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         {
         rollingInv = unstockedScrapVol (theMat, thePer);

         if (thePer > 0)
            rollingInv += stockVolVec[thePer - 1];

         stockVolVal = rollingInv;

         if (not theMat->canStock (thePer))
            stockVolVal = 0.0;

         if (myProblem ()->currentVariant ()->respectsOptCons ())
            if (theMat->stockBounds ()->hardUBIsFinite (thePer))
               setToMin (
                  stockVolVal,
                  theMat->stockBounds ()->hardUB ()[thePer]);

         if (stockVolVal < 0.0)
             stockVolVal = 0.0;

         stockVolVec[thePer] = stockVolVal;
         scrapVolVec[thePer] = rollingInv - stockVolVal;
         }

      theMat->rollBackScrap (stockVolVec, scrapVolVec);

      theMat->storePostStockVol (stockVolVec);
      theMat->storePostScrapVol (scrapVolVec);
      }
   }

//------------------------------------------------------------------------------

double WitPostprocessor::unstockedScrapVol (WitPart * thePart, WitPeriod thePer)
   {
   WitDemand * theDemand;
   double      usVol;

   usVol =
        thePart->supplyVol ()[thePer]
      + thePart->prodVol   ()[thePer]
      - thePart->consVol   ()[thePer];

   forEachEl (theDemand, thePart->myDemands ())
      usVol -= theDemand->shipVol ()[thePer];

   return usVol;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compCumShipVols ()
   {
   WitTVec <double> cumShipVolVec;
   WitDemand *      theDemand;
   double           cumSum;
   WitPeriod        thePer;

   cumShipVolVec.allocate (myProblem (), 0.0);

   forEachDemand (theDemand, myProblem ())
      {
      if (myProblem ()->currentVariant ()->compsSecScheds ())
         if (theDemand->shipLateAllowed ())
            continue;

      if (theDemand->shipVol () == 0.0)
         cumShipVolVec = 0.0;
      else
         {
         cumSum = 0.0;

         forEachPeriod (thePer, myProblem ())
            {
            cumSum               += theDemand->shipVol ()[thePer];

            cumShipVolVec[thePer] = cumSum;
            }
         }

      theDemand->storePostCumShipVol (cumShipVolVec);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compCapResidVols ()
   {
   WitTVec <double> resVolVec;
   WitPart *        thePart;
   WitPeriod        thePer;

   resVolVec.allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      if (thePart->thisCap () != NULL)
         {
         resVolVec = thePart->scrapVol ();

         forEachPeriod (thePer, myProblem ())
            if (resVolVec[thePer] <= NET_TOL)
               resVolVec[thePer] = 0.0;

         thePart->storePostResidualVol (resVolVec);
         }
   }

//------------------------------------------------------------------------------
// compMatResidVolsAsap.
// Computes the residualVols as follows:
// Create a temporary usedStockVol, the portion of stockVol that is used by the
//    solution and let residualVol be the corresponding scrapVol.
// Let usedStockVol and residualVol reflect the following scrapping policy:
// * Any stock in the last period in excess of the softLB on stock is scrapped.
// * All scrapping is done in the earliest possible period.
//------------------------------------------------------------------------------

void WitPostprocessor::compMatResidVolsAsap ()
   {
   WitTVec <double> resVolVec;
   WitTVec <double> usedStockVol;
   WitMaterial *    theMat;
   double           unusedFinalStock;
   WitPeriod        lastPer;
   WitPeriod        thePer;

   resVolVec   .allocate (myProblem (), 0.0);
   usedStockVol.allocate (myProblem (), 0.0);

   lastPer = lastPeriod ();

   forEachMaterial (theMat, myProblem ())
      {
      usedStockVol = theMat->stockVol ();
      resVolVec    = theMat->scrapVol ();

      unusedFinalStock =
         usedStockVol[lastPer] - theMat->stockBounds ()->softLB ()[lastPer];

      if (unusedFinalStock > FLOAT_EPSILON)
         {
         usedStockVol[lastPer] -= unusedFinalStock;
         resVolVec   [lastPer] += unusedFinalStock;
         }

      theMat->rollBackScrap (usedStockVol, resVolVec);

      forEachPeriod (thePer, myProblem ())
         setToMax (resVolVec[thePer], 0.0);

      theMat->storePostResidualVol (resVolVec);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compMatResidVolsNstn ()
   {
   WitTVec <double> resVolVec;
   WitTVec <double> unstockConsVol;
   WitMaterial *    theMat;
   double           netConsVol;
   WitPeriod        thePer;
   double           resVol;

   resVolVec     .allocate (myProblem (), 0.0);
   unstockConsVol.allocate (myProblem (), 0.0);

   forEachMaterial (theMat, myProblem ())
      {
      netConsVol = compCumConsVol (theMat, unstockConsVol);

      resVolVec  = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         if (thePer > 0)
            netConsVol += unstockConsVol[thePer];

         resVol     =                 theMat->supplyVol ()[thePer];

         resVol    +=                 theMat->prodVol   ()[thePer];

         resVol    += positivePart (- theMat->consVol   ()[thePer]);

         if (thePer > 0)
            resVol += stockLB (theMat, thePer - 1);

         net (resVol, netConsVol);

         if (resVol > NET_TOL)
            resVolVec[thePer] = resVol;
         }

      theMat->storePostResidualVol (resVolVec);
      }
   }

//------------------------------------------------------------------------------

double WitPostprocessor::compCumConsVol (
      WitMaterial *      theMat, 
      WitTVec <double> & unstockConsVol)
   {
   double      cumConsVol;
   WitPeriod   thePer;
   WitDemand * theDemand;
   double      boundGap;
   bool        gapIsFinite;

   cumConsVol     = 0.0;

   unstockConsVol = 0.0;

   for (thePer = lastPeriod (); thePer >= 0; thePer --)
      {
      forEachEl (theDemand, theMat->myDemands ())
         cumConsVol += theDemand->shipVol ()[thePer];

      cumConsVol    += positivePart (theMat->consVol ()[thePer]);

      cumConsVol    += stockLB (theMat, thePer);

      if (thePer > 0)
         {
         boundGap = stockBndGap (theMat, thePer - 1, gapIsFinite);

         if (gapIsFinite)
            if (boundGap < cumConsVol - NET_TOL)
               {
               unstockConsVol[thePer] = cumConsVol - boundGap;

               cumConsVol             = boundGap;
               }
         }
      }

   return cumConsVol;
   }

//------------------------------------------------------------------------------

double WitPostprocessor::stockBndGap (
      WitMaterial * theMat,
      WitPeriod     thePer,
      bool &        gapIsFinite)
   {
   gapIsFinite = true;

   if (not theMat->canStock (thePer))
      return 0.0;

   if (not theMat->stockBounds ()->hardUBIsFinite (thePer))
      {
      gapIsFinite = false;

      return 0.0;
      }

   return
        theMat->stockBounds ()->hardUB ()[thePer]
      - stockLB (theMat, thePer);
   }

//------------------------------------------------------------------------------

double WitPostprocessor::stockLB (WitMaterial * theMat, WitPeriod thePer)
   {
   return
      min (
         theMat->stockBounds ()->softLB ()[thePer],
         theMat->stockVol    ()           [thePer]);
   }
@


1.104
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.103
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d43 1
a43 1
WitProbAssoc    (theProblem),
d45 6
a50 6
postprocessing_ (false),
postprocessed_  (false),
myFeasChkr_     (NULL)
{
myFeasChkr_ = new WitFeasChkr (myProblem ());
}
d55 3
a57 3
{
delete myFeasChkr_;
}
d62 2
a63 2
{
WitDemand * theDemand;
d65 2
a66 2
if (postprocessed_)
return;
d68 1
a68 1
myProblem ()->myHeurAllMgr ()->reset ();
d70 1
a70 1
myPreprocessor ()->preprocess ();
d72 1
a72 1
WitTimer::enterSection ("postproc");
d74 1
a74 1
postprocessing_ = true;
d76 2
a77 2
forEachDemand (theDemand, myProblem ())
theDemand->initFssShipVolForPost ();
d79 1
a79 1
compNonSubVols ();
d81 2
a82 2
compConsVols ();
compProdVols ();
d84 8
a91 5
if (not myProblem ()->currentVariant ()->compsSecScheds ())
{
compCapacityScrapVols      ();
compMaterialStockScrapVols ();
}
d93 4
a96 2
compCumShipVols  ();
compCapResidVols ();
d98 1
a98 4
if (myGlobalComp ()->nstnResidual ())
compMatResidVolsNstn ();
else
compMatResidVolsAsap ();
d100 1
a100 1
myFeasChkr_->compFeasible ();
d102 5
a106 1
postprocessing_ = false;
d108 2
a109 8
postprocessed_  =
myMsgFac ().displayStateChange (
"postStateMsg",
postprocessed_,
true);

WitTimer::leaveSection ("postproc");
}
d114 18
a131 18
{
if (not postprocessed_)
return;

myFeasChkr_    ->unpostprocess ();
myOptComp    ()->unpostprocess ();
myGlobalComp ()->unpostprocess ();

myProblem ()->myPipMgr ()->clearPegging ();

myProblem ()->myFSS ()->uncompute ();

postprocessed_ =
myMsgFac ().displayStateChange (
"unpostStateMsg",
postprocessed_,
false);
}
d136 13
a148 13
WitBomEntry *      theBomEnt,
WitTVec <double> & nonSubVolVec)
{
WitSubEntry * theSub;
WitPeriod     execPer;

nonSubVolVec = theBomEnt->myOperation ()->execVol ();

forEachPeriod (execPer, myProblem ())
forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->inEffect (execPer))
nonSubVolVec[execPer] -= theSub->subVol ()[execPer];
}
d153 15
a167 15
WitPart *          thePart,
WitTVec <double> & prodVolVec)
{
WitBopEntry * theBopEnt;
WitPeriod     execPer;

prodVolVec = 0.0;

forEachEl (theBopEnt, thePart->producingBopEntries ())
forEachPeriod (execPer, myProblem ())
if (theBopEnt->inEffect (execPer))
prodVolVec[theBopEnt->impactPeriod ()[execPer]] +=
theBopEnt->effProdRate ()[execPer] *
theBopEnt->myOperation ()->execVol ()[execPer];
}
d172 3
a174 3
{
double        excVol;
WitMaterial * theMat;
d176 1
a176 1
excVol = thePart->residualVol ()[thePer];
d178 3
a180 3
if (myGlobalComp ()->minimalExcess ())
{
excVol -= thePart->prodVol ()[thePer];
d182 1
a182 1
excVol -= positivePart (- thePart->consVol ()[thePer]);
d184 1
a184 1
theMat  = thePart->thisMat ();
d186 3
a188 3
if (theMat != NULL)
if (thePer > 0)
excVol -= stockLB (theMat, thePer - 1);
d190 2
a191 2
excVol  = positivePart (excVol);
}
d193 1
a193 1
setToMin (excVol, thePart->supplyVol ()[thePer]);
d195 2
a196 2
return excVol;
}
d201 14
a214 14
{
WitTVec <double> nonSubVolVec;
WitBomEntry *    theBomEnt;

nonSubVolVec.allocate  (myProblem (), 0.0);

forEachBomEntry (theBomEnt, myProblem ())
if (not theBomEnt->mySubEntries ().isEmpty ())
{
compNonSubVol (theBomEnt, nonSubVolVec);

theBomEnt->storePostNonSubVol (nonSubVolVec);
}
}
d219 28
a246 28
{
WitPart *        thePart;
WitBomEntry *    theBomEnt;
WitSubEntry *    theSub;
WitTVec <double> consVolVec (myProblem (), 0.0);
WitTVec <double> execVolVec (myProblem (), 0.0);

forEachPart (thePart, myProblem ())
{
consVolVec = 0.0;

forEachEl (theBomEnt, thePart->consumingBomEntries ())
{
execVolVec = theBomEnt->nonSubVol ();

theBomEnt->incConsVol (consVolVec, execVolVec);
}

forEachEl (theSub, thePart->consumingSubEntries ())
{
execVolVec = theSub->subVol ();

theSub->incConsVol (consVolVec, execVolVec);
}

thePart->storePostConsVol (consVolVec);
}
}
d251 11
a261 11
{
WitPart *        thePart;
WitTVec <double> prodVolVec (myProblem (), 0.0);

forEachPart (thePart, myProblem ())
{
compProdVol (thePart, prodVolVec);

thePart->storePostProdVol (prodVolVec);
}
}
d266 14
a279 14
{
WitPart *        thePart;
WitPeriod        thePer;
WitTVec <double> scrapVolVec (myProblem (), 0.0);

forEachPart (thePart, this)
if (thePart->thisCap () != NULL)
{
forEachPeriod (thePer, myProblem ())
scrapVolVec[thePer] = unstockedScrapVol (thePart, thePer);

thePart->storePostScrapVol (scrapVolVec);
}
}
d295 42
a336 42
{
WitMaterial * theMat;
WitPeriod     thePer;
double        rollingInv;  // Rolling inventory in thePer.
double        stockVolVal; // stockVol[thePer].

WitTVec <double> stockVolVec (myProblem (), 0.0);
WitTVec <double> scrapVolVec (myProblem (), 0.0);

forEachMaterial (theMat, myProblem ())
{
forEachPeriod (thePer, myProblem ())
{
rollingInv = unstockedScrapVol (theMat, thePer);

if (thePer > 0)
rollingInv += stockVolVec[thePer - 1];

stockVolVal = rollingInv;

if (not theMat->canStock (thePer))
stockVolVal = 0.0;

if (myProblem ()->currentVariant ()->respectsOptCons ())
if (theMat->stockBounds ()->hardUBIsFinite (thePer))
setToMin (
stockVolVal,
theMat->stockBounds ()->hardUB ()[thePer]);

if (stockVolVal < 0.0)
stockVolVal = 0.0;

stockVolVec[thePer] = stockVolVal;
scrapVolVec[thePer] = rollingInv - stockVolVal;
}

theMat->rollBackScrap (stockVolVec, scrapVolVec);

theMat->storePostStockVol (stockVolVec);
theMat->storePostScrapVol (scrapVolVec);
}
}
d341 8
a348 8
{
WitDemand * theDemand;
double      usVol;

usVol =
thePart->supplyVol ()[thePer]
+ thePart->prodVol   ()[thePer]
- thePart->consVol   ()[thePer];
d350 2
a351 2
forEachEl (theDemand, thePart->myDemands ())
usVol -= theDemand->shipVol ()[thePer];
d353 2
a354 2
return usVol;
}
d359 31
a389 31
{
WitTVec <double> cumShipVolVec;
WitDemand *      theDemand;
double           cumSum;
WitPeriod        thePer;

cumShipVolVec.allocate (myProblem (), 0.0);

forEachDemand (theDemand, myProblem ())
{
if (myProblem ()->currentVariant ()->compsSecScheds ())
if (theDemand->shipLateAllowed ())
continue;

if (theDemand->shipVol () == 0.0)
cumShipVolVec = 0.0;
else
{
cumSum = 0.0;

forEachPeriod (thePer, myProblem ())
{
cumSum               += theDemand->shipVol ()[thePer];

cumShipVolVec[thePer] = cumSum;
}
}

theDemand->storePostCumShipVol (cumShipVolVec);
}
}
d394 19
a412 19
{
WitTVec <double> resVolVec;
WitPart *        thePart;
WitPeriod        thePer;

resVolVec.allocate (myProblem (), 0.0);

forEachPart (thePart, myProblem ())
if (thePart->thisCap () != NULL)
{
resVolVec = thePart->scrapVol ();

forEachPeriod (thePer, myProblem ())
if (resVolVec[thePer] <= NET_TOL)
resVolVec[thePer] = 0.0;

thePart->storePostResidualVol (resVolVec);
}
}
d425 35
a459 35
{
WitTVec <double> resVolVec;
WitTVec <double> usedStockVol;
WitMaterial *    theMat;
double           unusedFinalStock;
WitPeriod        lastPer;
WitPeriod        thePer;

resVolVec   .allocate (myProblem (), 0.0);
usedStockVol.allocate (myProblem (), 0.0);

lastPer = lastPeriod ();

forEachMaterial (theMat, myProblem ())
{
usedStockVol = theMat->stockVol ();
resVolVec    = theMat->scrapVol ();

unusedFinalStock =
usedStockVol[lastPer] - theMat->stockBounds ()->softLB ()[lastPer];

if (unusedFinalStock > FLOAT_EPSILON)
{
usedStockVol[lastPer] -= unusedFinalStock;
resVolVec   [lastPer] += unusedFinalStock;
}

theMat->rollBackScrap (usedStockVol, resVolVec);

forEachPeriod (thePer, myProblem ())
setToMax (resVolVec[thePer], 0.0);

theMat->storePostResidualVol (resVolVec);
}
}
d464 7
a470 7
{
WitTVec <double> resVolVec;
WitTVec <double> unstockConsVol;
WitMaterial *    theMat;
double           netConsVol;
WitPeriod        thePer;
double           resVol;
d472 2
a473 2
resVolVec     .allocate (myProblem (), 0.0);
unstockConsVol.allocate (myProblem (), 0.0);
d475 3
a477 3
forEachMaterial (theMat, myProblem ())
{
netConsVol = compCumConsVol (theMat, unstockConsVol);
d479 1
a479 1
resVolVec  = 0.0;
d481 4
a484 4
forEachPeriod (thePer, myProblem ())
{
if (thePer > 0)
netConsVol += unstockConsVol[thePer];
d486 1
a486 1
resVol     =                 theMat->supplyVol ()[thePer];
d488 1
a488 1
resVol    +=                 theMat->prodVol   ()[thePer];
d490 1
a490 1
resVol    += positivePart (- theMat->consVol   ()[thePer]);
d492 2
a493 2
if (thePer > 0)
resVol += stockLB (theMat, thePer - 1);
d495 1
a495 1
net (resVol, netConsVol);
d497 3
a499 3
if (resVol > NET_TOL)
resVolVec[thePer] = resVol;
}
d501 3
a503 3
theMat->storePostResidualVol (resVolVec);
}
}
d508 35
a542 35
WitMaterial *      theMat,
WitTVec <double> & unstockConsVol)
{
double      cumConsVol;
WitPeriod   thePer;
WitDemand * theDemand;
double      boundGap;
bool        gapIsFinite;

cumConsVol     = 0.0;

unstockConsVol = 0.0;

for (thePer = lastPeriod (); thePer >= 0; thePer --)
{
forEachEl (theDemand, theMat->myDemands ())
cumConsVol += theDemand->shipVol ()[thePer];

cumConsVol    += positivePart (theMat->consVol ()[thePer]);

cumConsVol    += stockLB (theMat, thePer);

if (thePer > 0)
{
boundGap = stockBndGap (theMat, thePer - 1, gapIsFinite);

if (gapIsFinite)
if (boundGap < cumConsVol - NET_TOL)
{
unstockConsVol[thePer] = cumConsVol - boundGap;

cumConsVol             = boundGap;
}
}
}
d544 2
a545 2
return cumConsVol;
}
d550 20
a569 20
WitMaterial * theMat,
WitPeriod     thePer,
bool &        gapIsFinite)
{
gapIsFinite = true;

if (not theMat->canStock (thePer))
return 0.0;

if (not theMat->stockBounds ()->hardUBIsFinite (thePer))
{
gapIsFinite = false;

return 0.0;
}

return
theMat->stockBounds ()->hardUB ()[thePer]
- stockLB (theMat, thePer);
}
d574 6
a579 6
{
return
min (
theMat->stockBounds ()->softLB ()[thePer],
theMat->stockVol    ()           [thePer]);
}
@


1.102
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d43 1
a43 1
      WitProbAssoc    (theProblem),
d45 6
a50 6
      postprocessing_ (false),
      postprocessed_  (false),
      myFeasChkr_     (NULL)
   {
   myFeasChkr_ = new WitFeasChkr (myProblem ());
   }
d55 3
a57 3
   {
   delete myFeasChkr_;
   }
d62 2
a63 2
   {
   WitDemand * theDemand;
d65 2
a66 2
   if (postprocessed_)
      return;
d68 1
a68 1
   myProblem ()->myHeurAllMgr ()->reset ();
d70 1
a70 1
   myPreprocessor ()->preprocess ();
d72 1
a72 1
   WitTimer::enterSection ("postproc");
d74 1
a74 1
   postprocessing_ = true;
d76 2
a77 2
   forEachDemand (theDemand, myProblem ())
      theDemand->initFssShipVolForPost ();
d79 1
a79 1
   compNonSubVols ();
d81 2
a82 2
   compConsVols ();
   compProdVols ();
d84 5
a88 8
   if (not myProblem ()->currentVariant ()->compsSecScheds ())
      {
      compCapacityScrapVols      ();
      compMaterialStockScrapVols ();
      }
 
   compCumShipVols  ();
   compCapResidVols ();
d90 2
a91 4
   if (myGlobalComp ()->nstnResidual ())
      compMatResidVolsNstn ();
   else
      compMatResidVolsAsap ();
d93 4
a96 1
   myFeasChkr_->compFeasible ();
d98 1
a98 1
   postprocessing_ = false;
d100 1
a100 5
   postprocessed_  =
      myMsgFac ().displayStateChange (
        "postStateMsg",
         postprocessed_,
         true);
d102 8
a109 2
   WitTimer::leaveSection ("postproc");
   }
d114 18
a131 18
   {
   if (not postprocessed_)
      return;

   myFeasChkr_    ->unpostprocess ();
   myOptComp    ()->unpostprocess ();
   myGlobalComp ()->unpostprocess ();

   myProblem ()->myPipMgr ()->clearPegging ();

   myProblem ()->myFSS ()->uncompute ();

   postprocessed_ =
      myMsgFac ().displayStateChange (
        "unpostStateMsg",
         postprocessed_,
         false);
   }
d136 13
a148 13
      WitBomEntry *      theBomEnt,
      WitTVec <double> & nonSubVolVec)
   {
   WitSubEntry * theSub;
   WitPeriod     execPer;

   nonSubVolVec = theBomEnt->myOperation ()->execVol ();

   forEachPeriod (execPer, myProblem ())
      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (theSub->inEffect (execPer))
            nonSubVolVec[execPer] -= theSub->subVol ()[execPer];
   }
d153 15
a167 15
      WitPart *          thePart,
      WitTVec <double> & prodVolVec)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     execPer;

   prodVolVec = 0.0;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      forEachPeriod (execPer, myProblem ())
         if (theBopEnt->inEffect (execPer))
            prodVolVec[theBopEnt->impactPeriod ()[execPer]] +=
               theBopEnt->effProdRate ()[execPer] *
               theBopEnt->myOperation ()->execVol ()[execPer];
   }
d172 3
a174 3
   {
   double        excVol;
   WitMaterial * theMat;
d176 1
a176 1
   excVol = thePart->residualVol ()[thePer];
d178 3
a180 3
   if (myGlobalComp ()->minimalExcess ())
      {
      excVol -= thePart->prodVol ()[thePer];
d182 1
a182 1
      excVol -= positivePart (- thePart->consVol ()[thePer]);
d184 1
a184 1
      theMat  = thePart->thisMat ();
d186 3
a188 3
      if (theMat != NULL)
         if (thePer > 0)
            excVol -= stockLB (theMat, thePer - 1);
d190 2
a191 2
      excVol  = positivePart (excVol);
      }
d193 1
a193 1
   setToMin (excVol, thePart->supplyVol ()[thePer]);
d195 2
a196 2
   return excVol;
   }
d201 14
a214 14
   {
   WitTVec <double> nonSubVolVec;
   WitBomEntry *    theBomEnt;

   nonSubVolVec.allocate  (myProblem (), 0.0);

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         {
         compNonSubVol (theBomEnt, nonSubVolVec);

         theBomEnt->storePostNonSubVol (nonSubVolVec);
         }
   }
d219 28
a246 28
   {
   WitPart *        thePart;
   WitBomEntry *    theBomEnt;
   WitSubEntry *    theSub;
   WitTVec <double> consVolVec (myProblem (), 0.0);
   WitTVec <double> execVolVec (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      consVolVec = 0.0;

      forEachEl (theBomEnt, thePart->consumingBomEntries ())
         {
         execVolVec = theBomEnt->nonSubVol ();

         theBomEnt->incConsVol (consVolVec, execVolVec);
         }

      forEachEl (theSub, thePart->consumingSubEntries ())
         {
         execVolVec = theSub->subVol ();

         theSub->incConsVol (consVolVec, execVolVec);
         }

      thePart->storePostConsVol (consVolVec);
      }
   }
d251 11
a261 11
   {
   WitPart *        thePart;
   WitTVec <double> prodVolVec (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      compProdVol (thePart, prodVolVec);

      thePart->storePostProdVol (prodVolVec);
      }
   }
d266 14
a279 14
   {
   WitPart *        thePart;
   WitPeriod        thePer;
   WitTVec <double> scrapVolVec (myProblem (), 0.0);

   forEachPart (thePart, this)
      if (thePart->thisCap () != NULL)
         {
         forEachPeriod (thePer, myProblem ())
            scrapVolVec[thePer] = unstockedScrapVol (thePart, thePer);

         thePart->storePostScrapVol (scrapVolVec);
         }
   }
d295 42
a336 42
   {
   WitMaterial * theMat;
   WitPeriod     thePer;
   double        rollingInv;  // Rolling inventory in thePer.
   double        stockVolVal; // stockVol[thePer].

   WitTVec <double> stockVolVec (myProblem (), 0.0);
   WitTVec <double> scrapVolVec (myProblem (), 0.0);

   forEachMaterial (theMat, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         {
         rollingInv = unstockedScrapVol (theMat, thePer);

         if (thePer > 0)
            rollingInv += stockVolVec[thePer - 1];

         stockVolVal = rollingInv;

         if (not theMat->canStock (thePer))
            stockVolVal = 0.0;

         if (myProblem ()->currentVariant ()->respectsOptCons ())
            if (theMat->stockBounds ()->hardUBIsFinite (thePer))
               setToMin (
                  stockVolVal,
                  theMat->stockBounds ()->hardUB ()[thePer]);

         if (stockVolVal < 0.0)
             stockVolVal = 0.0;

         stockVolVec[thePer] = stockVolVal;
         scrapVolVec[thePer] = rollingInv - stockVolVal;
         }

      theMat->rollBackScrap (stockVolVec, scrapVolVec);

      theMat->storePostStockVol (stockVolVec);
      theMat->storePostScrapVol (scrapVolVec);
      }
   }
d341 8
a348 8
   {
   WitDemand * theDemand;
   double      usVol;

   usVol =
        thePart->supplyVol ()[thePer]
      + thePart->prodVol   ()[thePer]
      - thePart->consVol   ()[thePer];
d350 2
a351 2
   forEachEl (theDemand, thePart->myDemands ())
      usVol -= theDemand->shipVol ()[thePer];
d353 2
a354 2
   return usVol;
   }
d359 31
a389 31
   {
   WitTVec <double> cumShipVolVec;
   WitDemand *      theDemand;
   double           cumSum;
   WitPeriod        thePer;

   cumShipVolVec.allocate (myProblem (), 0.0);

   forEachDemand (theDemand, myProblem ())
      {
      if (myProblem ()->currentVariant ()->compsSecScheds ())
         if (theDemand->shipLateAllowed ())
            continue;

      if (theDemand->shipVol () == 0.0)
         cumShipVolVec = 0.0;
      else
         {
         cumSum = 0.0;

         forEachPeriod (thePer, myProblem ())
            {
            cumSum               += theDemand->shipVol ()[thePer];

            cumShipVolVec[thePer] = cumSum;
            }
         }

      theDemand->storePostCumShipVol (cumShipVolVec);
      }
   }
d394 19
a412 19
   {
   WitTVec <double> resVolVec;
   WitPart *        thePart;
   WitPeriod        thePer;

   resVolVec.allocate (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      if (thePart->thisCap () != NULL)
         {
         resVolVec = thePart->scrapVol ();

         forEachPeriod (thePer, myProblem ())
            if (resVolVec[thePer] <= NET_TOL)
               resVolVec[thePer] = 0.0;

         thePart->storePostResidualVol (resVolVec);
         }
   }
d425 35
a459 35
   {
   WitTVec <double> resVolVec;
   WitTVec <double> usedStockVol;
   WitMaterial *    theMat;
   double           unusedFinalStock;
   WitPeriod        lastPer;
   WitPeriod        thePer;

   resVolVec   .allocate (myProblem (), 0.0);
   usedStockVol.allocate (myProblem (), 0.0);

   lastPer = lastPeriod ();

   forEachMaterial (theMat, myProblem ())
      {
      usedStockVol = theMat->stockVol ();
      resVolVec    = theMat->scrapVol ();

      unusedFinalStock =
         usedStockVol[lastPer] - theMat->stockBounds ()->softLB ()[lastPer];

      if (unusedFinalStock > FLOAT_EPSILON)
         {
         usedStockVol[lastPer] -= unusedFinalStock;
         resVolVec   [lastPer] += unusedFinalStock;
         }

      theMat->rollBackScrap (usedStockVol, resVolVec);

      forEachPeriod (thePer, myProblem ())
         setToMax (resVolVec[thePer], 0.0);

      theMat->storePostResidualVol (resVolVec);
      }
   }
d464 7
a470 7
   {
   WitTVec <double> resVolVec;
   WitTVec <double> unstockConsVol;
   WitMaterial *    theMat;
   double           netConsVol;
   WitPeriod        thePer;
   double           resVol;
d472 2
a473 2
   resVolVec     .allocate (myProblem (), 0.0);
   unstockConsVol.allocate (myProblem (), 0.0);
d475 3
a477 3
   forEachMaterial (theMat, myProblem ())
      {
      netConsVol = compCumConsVol (theMat, unstockConsVol);
d479 1
a479 1
      resVolVec  = 0.0;
d481 4
a484 4
      forEachPeriod (thePer, myProblem ())
         {
         if (thePer > 0)
            netConsVol += unstockConsVol[thePer];
d486 1
a486 1
         resVol     =                 theMat->supplyVol ()[thePer];
d488 1
a488 1
         resVol    +=                 theMat->prodVol   ()[thePer];
d490 1
a490 1
         resVol    += positivePart (- theMat->consVol   ()[thePer]);
d492 2
a493 2
         if (thePer > 0)
            resVol += stockLB (theMat, thePer - 1);
d495 1
a495 1
         net (resVol, netConsVol);
d497 3
a499 3
         if (resVol > NET_TOL)
            resVolVec[thePer] = resVol;
         }
d501 3
a503 3
      theMat->storePostResidualVol (resVolVec);
      }
   }
d508 35
a542 35
      WitMaterial *      theMat, 
      WitTVec <double> & unstockConsVol)
   {
   double      cumConsVol;
   WitPeriod   thePer;
   WitDemand * theDemand;
   double      boundGap;
   bool        gapIsFinite;

   cumConsVol     = 0.0;

   unstockConsVol = 0.0;

   for (thePer = lastPeriod (); thePer >= 0; thePer --)
      {
      forEachEl (theDemand, theMat->myDemands ())
         cumConsVol += theDemand->shipVol ()[thePer];

      cumConsVol    += positivePart (theMat->consVol ()[thePer]);

      cumConsVol    += stockLB (theMat, thePer);

      if (thePer > 0)
         {
         boundGap = stockBndGap (theMat, thePer - 1, gapIsFinite);

         if (gapIsFinite)
            if (boundGap < cumConsVol - NET_TOL)
               {
               unstockConsVol[thePer] = cumConsVol - boundGap;

               cumConsVol             = boundGap;
               }
         }
      }
d544 2
a545 2
   return cumConsVol;
   }
d550 20
a569 20
      WitMaterial * theMat,
      WitPeriod     thePer,
      bool &        gapIsFinite)
   {
   gapIsFinite = true;

   if (not theMat->canStock (thePer))
      return 0.0;

   if (not theMat->stockBounds ()->hardUBIsFinite (thePer))
      {
      gapIsFinite = false;

      return 0.0;
      }

   return
        theMat->stockBounds ()->hardUB ()[thePer]
      - stockLB (theMat, thePer);
   }
d574 6
a579 6
   {
   return
      min (
         theMat->stockBounds ()->softLB ()[thePer],
         theMat->stockVol    ()           [thePer]);
   }
@


1.101
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d30 1
a30 1
#include <Opn.h>
@


1.100
log
@Multi-Obj Mode
@
text
@d26 1
a26 1
#include <Global.h>
@


1.99
log
@Stochastic Implosion
@
text
@d27 1
d119 1
@


1.98
log
@Stochastic Implosion
@
text
@a18 4
#include <Global.h>
#include <Material.h>
#include <BomEntry.h>
#include <BopEntry.h>
d26 7
@


1.97
log
@Stochastic Implosion
@
text
@d73 1
a73 1
      theDemand->storePostFssShipVol (theDemand->shipVol ());
@


1.96
log
@[disallowed backlog]
@
text
@a24 1
#include <PostAccess.h>
d39 1
a39 1
      WitProbAssoc   (theProblem),
d41 3
a43 2
      myFeasChkr_    (NULL),
      postprocessed_ (false)
d70 2
d73 1
a73 1
      WitPostAccess::fssShipVol (theDemand) = theDemand->shipVol ();
d96 3
a98 1
   postprocessed_ =
d114 2
a115 1
   myFeasChkr_->unpostprocess ();
d131 2
a132 2
      WitBomEntry *   theBomEnt,
      WitDblFlexVec & nonSubVolVec)
d142 1
a142 1
            nonSubVolVec.elemRef (execPer) -= theSub->subVol ()[execPer];
d197 4
a200 1
   WitBomEntry * theBomEnt;
d204 5
a208 1
         compNonSubVol (theBomEnt, WitPostAccess::nonSubVol (theBomEnt));
d239 1
a239 1
      WitPostAccess::consVol (thePart) = consVolVec;
d254 1
a254 1
      WitPostAccess::prodVol (thePart) = prodVolVec;
d272 1
a272 1
         WitPostAccess::scrapVol (thePart) = scrapVolVec;
d328 2
a329 2
      WitPostAccess::stockVol (theMat) = stockVolVec;
      WitPostAccess::scrapVol (theMat) = scrapVolVec;
d355 6
a360 3
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;
d369 1
a369 1
         WitPostAccess::cumShipVol (theDemand) = 0.0;
d376 1
a376 1
            cumSum += theDemand->shipVol ()[thePer];
d378 1
a378 1
            WitPostAccess::cumShipVol (theDemand).elemRef (thePer) = cumSum;
d381 2
d390 5
a394 3
   WitPart * thePart;
   WitPeriod thePer;
   double    resVol;
d399 1
a399 1
         WitPostAccess::residualVol (thePart) = 0.0;
d402 2
a403 2
            {
            resVol = positivePart (thePart->scrapVol ()[thePer]);
d405 1
a405 3
            if (resVol > NET_TOL)
               WitPostAccess::residualVol (thePart).elemRef (thePer) = resVol;
            }
d421 6
a426 4
   WitMaterial * theMat;
   double        unusedFinalStock;
   WitPeriod     lastPer;
   WitPeriod     thePer;
d428 2
a429 2
   WitTVec <double> theResidualVol (myProblem (), 0.0);
   WitTVec <double> usedStockVol   (myProblem (), 0.0);
d435 2
a436 2
      usedStockVol   = theMat->stockVol ();
      theResidualVol = theMat->scrapVol ();
d443 2
a444 2
         usedStockVol  [lastPer] -= unusedFinalStock;
         theResidualVol[lastPer] += unusedFinalStock;
d447 1
a447 1
      theMat->rollBackScrap (usedStockVol, theResidualVol);
d450 1
a450 1
         setToMax (theResidualVol[thePer], 0.0);
d452 1
a452 1
      WitPostAccess::residualVol (theMat) = theResidualVol;
d460 1
d467 1
d474 1
a474 1
      WitPostAccess::residualVol (theMat) = 0.0;
d493 1
a493 1
            WitPostAccess::residualVol (theMat).elemRef (thePer) = resVol;
d495 2
@


1.95
log
@[disallowed backlog]
@
text
@d350 1
a350 1
         if (theDemand->backlogAllowed ())
@


1.94
log
@[disallowed backlog]
@
text
@d350 1
a350 1
         if (not theDemand->disallowBacklog ())
@


1.93
log
@[disallowed backlog]
@
text
@d301 1
a301 1
         if (myProblem ()->currentVariant ()->respectsAllBounds ())
@


1.92
log
@[disallowed backlog]
@
text
@d59 2
a63 4
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;

d80 1
a80 2
      compCapacityScrapVols ();

a81 15

      forEachDemand (theDemand, myProblem ())
         if (theDemand->shipVol () == 0.0)
            WitPostAccess::cumShipVol (theDemand) = 0.0;
         else
            {
            cumSum = 0.0;

            forEachPeriod (thePer, myProblem ())
               {
               cumSum += theDemand->shipVol ()[thePer];

               WitPostAccess::cumShipVol (theDemand).elemRef (thePer) = cumSum;
               }
            }
d84 1
d341 30
@


1.91
log
@[disallowed backlog]
@
text
@a37 14
//------------------------------------------------------------------------------
// Static data initialization.
//------------------------------------------------------------------------------

WitDblFlexVec     WitPart::* WitPostprocessor::consVol_     = NULL;
WitDblFlexVec     WitPart::* WitPostprocessor::prodVol_     = NULL;
WitDblFlexVec     WitPart::* WitPostprocessor::scrapVol_    = NULL;
WitDblFlexVec     WitPart::* WitPostprocessor::residualVol_ = NULL;
WitDblFlexVec WitMaterial::* WitPostprocessor::stockVol_    = NULL;
WitDblFlexVec   WitDemand::* WitPostprocessor::cumShipVol_  = NULL;
WitDblFlexVec   WitDemand::* WitPostprocessor::fssShipVol_  = NULL;

//------------------------------------------------------------------------------

d73 1
a73 1
      theDemand->*fssShipVol_ = theDemand->shipVol ();
d88 1
a88 1
            theDemand->*cumShipVol_ = 0.0;
d97 1
a97 1
               (theDemand->*cumShipVol_).elemRef (thePer) = cumSum;
a206 31
void WitPostprocessor::receiveDMPs (
      WitDblFlexVec WitPart::* consVolArg,
      WitDblFlexVec WitPart::* prodVolArg,
      WitDblFlexVec WitPart::* scrapVolArg,
      WitDblFlexVec WitPart::* residualVolArg)
   {
   consVol_     = consVolArg;
   prodVol_     = prodVolArg;
   scrapVol_    = scrapVolArg;
   residualVol_ = residualVolArg;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::receiveDMPs (WitDblFlexVec WitMaterial::* stockVolArg)
   {
   stockVol_ = stockVolArg;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::receiveDMPs (
      WitDblFlexVec WitDemand::* cumShipVolArg,
      WitDblFlexVec WitDemand::* fssShipVolArg)
   {
   cumShipVol_ = cumShipVolArg;
   fssShipVol_ = fssShipVolArg;
   }

//------------------------------------------------------------------------------

d244 1
a244 1
      thePart->*consVol_ = consVolVec;
d259 1
a259 1
      thePart->*prodVol_ = prodVolVec;
d277 1
a277 1
         thePart->*scrapVol_ = scrapVolVec;
d333 2
a334 2
      theMat->*stockVol_ = stockVolVec;
      theMat->*scrapVol_ = scrapVolVec;
d367 1
a367 1
         thePart->*residualVol_ = 0.0;
d374 1
a374 1
               (thePart->*residualVol_).elemRef (thePer) = resVol;
d420 1
a420 1
      theMat->*residualVol_ = theResidualVol;
d440 1
a440 1
      theMat->*residualVol_ = 0.0;
d459 1
a459 1
            (theMat->*residualVol_).elemRef (thePer) = resVol;
@


1.90
log
@Rescinded all changed made since 1/31/07.
@
text
@d21 1
d25 1
a48 1
WitDblFlexVec WitBomEntry::* WitPostprocessor::nonSubVol_   = NULL;
a251 7
void WitPostprocessor::receiveDMPs (WitDblFlexVec WitBomEntry::* nonSubVolArg)
   {
   nonSubVol_ = nonSubVolArg;
   }

//------------------------------------------------------------------------------

d258 1
a258 1
         compNonSubVol (theBomEnt, theBomEnt->*nonSubVol_);
@


1.89
log
@[disallowed backlog]
@
text
@d40 8
a47 1
WitDblFlexVec WitBomEntry::* WitPostprocessor::nonSubVol_ = NULL;
d75 4
d85 2
a86 1
   myFSS ()->compDefFssShipVols ();
d95 2
a96 1
      compCapacityScrapVols      ();
d98 15
a114 1
   compCumShipVols  ();
d220 31
d295 1
a295 1
      thePart->consVol_ () = consVolVec;
d310 1
a310 1
      thePart->prodVol_ () = prodVolVec;
d328 1
a328 1
         thePart->scrapVol_ () = scrapVolVec;
d384 2
a385 2
      theMat->stockVol_ () = stockVolVec;
      theMat->scrapVol_ () = scrapVolVec;
a408 30
void WitPostprocessor::compCumShipVols ()
   {
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;
 
   forEachDemand (theDemand, myProblem ())
      {
      if (myProblem ()->currentVariant ()->compsSecScheds ())
         if (theDemand->backlogAllowed ())
            continue;

      if (theDemand->shipVol () == 0.0)
         theDemand->cumShipVol_ () = 0.0;
      else
         {
         cumSum = 0.0;

         forEachPeriod (thePer, myProblem ())
            {
            cumSum += theDemand->shipVol ()[thePer];

            theDemand->cumShipVol_ ().elemRef (thePer) = cumSum;
            }
         }
      }
   }

//------------------------------------------------------------------------------

d418 1
a418 1
         thePart->residualVol_ () = 0.0;
d425 1
a425 1
               thePart->residualVol_ ().elemRef (thePer) = resVol;
d471 1
a471 1
      theMat->residualVol_ () = theResidualVol;
d491 1
a491 1
      theMat->residualVol_ () = 0.0;
d510 1
a510 1
            theMat->residualVol_ ().elemRef (thePer) = resVol;
@


1.88
log
@[disallowed backlog]
@
text
@d237 1
a237 1
      thePart->consVol_.forUpdate () = consVolVec;
d252 1
a252 1
      thePart->prodVol_.forUpdate () = prodVolVec;
d270 1
a270 1
         thePart->scrapVol_.forUpdate () = scrapVolVec;
d326 2
a327 2
      theMat->stockVol_.forUpdate () = stockVolVec;
      theMat->scrapVol_.forUpdate () = scrapVolVec;
d364 1
a364 1
         theDemand->cumShipVol_.forUpdate () = 0.0;
d373 1
a373 1
            theDemand->cumShipVol_->elemRef (thePer) = cumSum;
d390 1
a390 1
         thePart->residualVol_.forUpdate () = 0.0;
d397 1
a397 1
               thePart->residualVol_->elemRef (thePer) = resVol;
d443 1
a443 1
      theMat->residualVol_.forUpdate () = theResidualVol;
d463 1
a463 1
      theMat->residualVol_.forUpdate () = 0.0;
d482 1
a482 1
            theMat->residualVol_->elemRef (thePer) = resVol;
@


1.87
log
@[disallowed backlog]
@
text
@d40 1
a40 4
WitDblFlexVec WitMaterial::* WitPostprocessor::stockVol_   = NULL;
WitDblFlexVec   WitDemand::* WitPostprocessor::cumShipVol_ = NULL;
WitDblFlexVec   WitDemand::* WitPostprocessor::fssShipVol_ = NULL;
WitDblFlexVec WitBomEntry::* WitPostprocessor::nonSubVol_  = NULL;
a67 4
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;

d74 1
a74 2
   forEachDemand (theDemand, myProblem ())
      theDemand->*fssShipVol_ = theDemand->shipVol ();
a192 17
void WitPostprocessor::receiveDMPs (WitDblFlexVec WitMaterial::* stockVolArg)
   {
   stockVol_ = stockVolArg;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::receiveDMPs (
      WitDblFlexVec WitDemand::* cumShipVolArg,
      WitDblFlexVec WitDemand::* fssShipVolArg)
   {
   cumShipVol_ = cumShipVolArg;
   fssShipVol_ = fssShipVolArg;
   }

//------------------------------------------------------------------------------

d326 2
a327 2
      theMat->*stockVol_              = stockVolVec;
      theMat-> scrapVol_.forUpdate () = scrapVolVec;
d364 1
a364 1
         theDemand->*cumShipVol_ = 0.0;
d373 1
a373 1
            (theDemand->*cumShipVol_).elemRef (thePer) = cumSum;
d397 1
a397 1
               thePart->residualVol_.forUpdate ().elemRef (thePer) = resVol;
d482 1
a482 1
            theMat->residualVol_.forUpdate ().elemRef (thePer) = resVol;
@


1.86
log
@[disallowed backlog]
@
text
@d262 1
a262 1
      thePart->myPostData ().consVol_ = consVolVec;
d277 1
a277 1
      thePart->myPostData ().prodVol_ = prodVolVec;
d295 1
a295 1
         thePart->myOptPostData ().scrapVol_ = scrapVolVec;
d351 2
a352 2
      theMat->*                stockVol_ = stockVolVec;
      theMat->myOptPostData ().scrapVol_ = scrapVolVec;
d415 1
a415 1
         thePart->myPostData ().residualVol_ = 0.0;
d422 1
a422 1
               thePart->myPostData ().residualVol_.elemRef (thePer) = resVol;
d468 1
a468 1
      theMat->myPostData ().residualVol_ = theResidualVol;
d488 1
a488 1
      theMat->myPostData ().residualVol_ = 0.0;
d507 1
a507 1
            theMat->myPostData ().residualVol_.elemRef (thePer) = resVol;
@


1.85
log
@Disallowed backlog.
@
text
@d40 4
a43 7
WitDblFlexVec     WitPart::* WitPostprocessor::consVol_     = NULL;
WitDblFlexVec     WitPart::* WitPostprocessor::scrapVol_    = NULL;
WitDblFlexVec     WitPart::* WitPostprocessor::residualVol_ = NULL;
WitDblFlexVec WitMaterial::* WitPostprocessor::stockVol_    = NULL;
WitDblFlexVec   WitDemand::* WitPostprocessor::cumShipVol_  = NULL;
WitDblFlexVec   WitDemand::* WitPostprocessor::fssShipVol_  = NULL;
WitDblFlexVec WitBomEntry::* WitPostprocessor::nonSubVol_   = NULL;
a200 12
void WitPostprocessor::receiveDMPs (
      WitDblFlexVec WitPart::* consVolArg,
      WitDblFlexVec WitPart::* scrapVolArg,
      WitDblFlexVec WitPart::* residualVolArg)
   {
   consVol_     = consVolArg;
   scrapVol_    = scrapVolArg;
   residualVol_ = residualVolArg;
   }

//------------------------------------------------------------------------------

d262 1
a262 1
      thePart->*consVol_ = consVolVec;
d295 1
a295 1
         thePart->*scrapVol_ = scrapVolVec;
d351 2
a352 2
      theMat->*stockVol_ = stockVolVec;
      theMat->*scrapVol_ = scrapVolVec;
d415 1
a415 1
         thePart->*residualVol_ = 0.0;
d422 1
a422 1
               (thePart->*residualVol_).elemRef (thePer) = resVol;
d468 1
a468 1
      theMat->*residualVol_ = theResidualVol;
d488 1
a488 1
      theMat->*residualVol_ = 0.0;
d507 1
a507 1
            (theMat->*residualVol_).elemRef (thePer) = resVol;
@


1.84
log
@[disAllowed backlog]
@
text
@a39 1
WitDblFlexVec     WitPart::* WitPostprocessor::prodVol_     = NULL;
a204 1
      WitDblFlexVec WitPart::* prodVolArg,
a208 1
   prodVol_     = prodVolArg;
d292 1
a292 1
      thePart->*prodVol_ = prodVolVec;
@


1.83
log
@[backlog avoidance]
@
text
@d40 1
d206 1
d211 1
d295 1
a295 1
      thePart->prodVol.forUpdate () = prodVolVec;
@


1.82
log
@[backlog avoidance]
@
text
@d94 1
a94 2
      compCapacityScrapVols ();

a95 15

      forEachDemand (theDemand, myProblem ())
         if (theDemand->shipVol () == 0.0)
            theDemand->*cumShipVol_ = 0.0;
         else
            {
            cumSum = 0.0;

            forEachPeriod (thePer, myProblem ())
               {
               cumSum += theDemand->shipVol ()[thePer];

               (theDemand->*cumShipVol_).elemRef (thePer) = cumSum;
               }
            }
d98 1
d391 30
@


1.81
log
@witCopy<Object>Data
@
text
@a40 1
WitDblFlexVec     WitPart::* WitPostprocessor::prodVol_     = NULL;
a220 1
      WitDblFlexVec WitPart::* prodVolArg,
a224 1
   prodVol_     = prodVolArg;
d307 1
a307 1
      thePart->*prodVol_ = prodVolVec;
@


1.80
log
@external opt implosion.
@
text
@d323 1
a323 1
      if (thePart->isaCapacity ())
@


1.79
log
@External optimizing implosion.
@
text
@d17 1
d40 8
a47 9
WitDblFlexVec       WitPart::* WitPostprocessor::consVol_     = NULL;
WitDblFlexVec       WitPart::* WitPostprocessor::prodVol_     = NULL;
WitDblFlexVec       WitPart::* WitPostprocessor::scrapVol_    = NULL;
WitDblFlexVec       WitPart::* WitPostprocessor::residualVol_ = NULL;
WitDblFlexVec   WitMaterial::* WitPostprocessor::stockVol_    = NULL;
WitDblFlexVec     WitDemand::* WitPostprocessor::cumShipVol_  = NULL;
WitDblFlexVec     WitDemand::* WitPostprocessor::fssShipVol_  = NULL;
WitDblFlexVec   WitBomEntry::* WitPostprocessor::nonSubVol_   = NULL;
bool          WitGlobalComp::* WitPostprocessor::feasible_    = NULL;
d55 2
a56 2
      postprocessed_ (false),
      maxViolation_  (0.0)
d58 1
d65 1
a84 2
   witAssert (solnIsNonnegative ());

d122 1
a122 1
   compFeasible ();
d140 2
a143 4
   maxViolation_ = 0.0;

   myGlobalComp ()->unpostprocess ();

a154 14
void WitPostprocessor::verifyUhsFeas ()
   {
   stronglyAssert (myGlobalComp ()->userHeurStart ());

   verifyUhsNonExecCon ();

   verifyUhsSubCon ();
   verifyUhsCumDemandCon ();
   verifyUhsExecHUBCon ();
   verifyUhsLotSizeCon ();
   }

//------------------------------------------------------------------------------

a257 30
void WitPostprocessor::receiveDMPs (bool WitGlobalComp::* feasibleArg)
   {
   feasible_ = feasibleArg;
   }

//------------------------------------------------------------------------------

bool WitPostprocessor::solnIsNonnegative ()
   {
   WitDemand *    theDemand;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachDemand (theDemand, myProblem ())
      if (not (theDemand->shipVol () >= 0.0))
         return false;

   forEachOperation (theOpn, myProblem ())
      if (not (theOpn->execVol () >= 0.0))
         return false;

   forEachSubEntry (theSub, myProblem ())
      if (not (theSub->subVol () >= 0.0))
         return false;

   return true;
   }

//------------------------------------------------------------------------------

a589 769

//------------------------------------------------------------------------------

void WitPostprocessor::compFeasible ()
   {
   maxViolation_ = 0.0;

   checkFeasReq ();

   if (myProblem ()->currentVariant ()->respectsAllBounds ())
      checkFeasAllBounds ();
   else
      checkFeasLimitedBounds ();

   if (myProblem ()->currentVariant ()->respectsLotSizes ())
      checkFeasLotSizes ();

   if (myProblem ()->currentVariant ()->respectsIntegrality ())
      checkIntegrality ();

   if (myGlobalComp ()->reportIncViol ())
      fprintf (msgFile (), "\n");

   if (DEVELOPMENT)
      myMsgFac () ("maxViolationMsg", maxViolation ());

   myGlobalComp ()->*feasible_ = (maxViolation_ <= FEAS_TOL);

   if (DEVELOPMENT)
      if (myProblem ()->currentVariant ()->internalSoln ())
         if (not myGlobalComp ()->feasible ())
            myMsgFac () (
               "infeasWmsg",
               myMsgFac ().myFrag (
                  myProblem ()->currentVariant ()->myFragID ()),
                  maxViolation ());
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkFeasReq ()
   {
   checkScrapVolNonneg   ();
   checkStockVolNonneg   ();
   checkExecVolNonneg    ();
   checkSubVolNonneg     ();
   checkShipVolNonneg    ();
   checkCumShipVolNonneg ();

   checkStockVols        ();
   checkExecVols         ();
   checkNonSubVols       ();
   checkCumShipVols      ();
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkScrapVolNonneg ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - thePart->scrapVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "scrapVol");

            myMsgFac () ("maxViolObjectMsg", "Part:", thePart->partName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkStockVolNonneg ()
   {
   WitMaterial * theMat;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachMaterial (theMat, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theMat->stockVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "stockVol");

            myMsgFac () ("maxViolObjectMsg", "Part:", theMat->partName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkExecVolNonneg ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theOpn->execVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "execVol");

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theOpn->operationName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkSubVolNonneg ()
   {
   WitSubEntry * theSub;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachSubEntry (theSub, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theSub->subVol()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "subVol");

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theSub->myOperationName ());

            myMsgFac () ("maxViolIndexMsg",
               "BOM Entry #:",
               theSub->myBomEnt ()->localIndex ());

            myMsgFac () ("maxViolIndexMsg",
               "Substitute #:",
               theSub->localIndex ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkShipVolNonneg ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theDemand->shipVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "shipVol");

            myMsgFac () ("maxViolObjectMsg",
               "Part:",
               theDemand->demandedPartName ());

            myMsgFac () ("maxViolObjectMsg",
               "Demand:",
               theDemand->demandName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkCumShipVolNonneg ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = - theDemand->cumShipVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("nonnegConstraintViolMsg", "cumShipVol");

            myMsgFac () ("maxViolObjectMsg",
               "Part:",
               theDemand->demandedPartName ());

            myMsgFac () ("maxViolObjectMsg",
               "Demand:",
               theDemand->demandName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkStockVols ()
   {
   WitMaterial * theMat;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachMaterial (theMat, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theMat->canStock (thePer))
            {
            theViol = theMat->stockVol ()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolMandECFrag"));

               myMsgFac () ("maxViolObjectMsg", "Part:", theMat->partName ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkExecVols ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theOpn->executable ()[thePer])
            {
            theViol = theOpn->execVol ()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolExecutableFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theOpn->operationName ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkNonSubVols ()
   {
   WitBomEntry * theBomEnt;
   WitPeriod     thePer;
   double        theViol;
   bool          reportNeeded;

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         forEachPeriod (thePer, myProblem ())
            {
            theViol = - theBomEnt->nonSubVol()[thePer];

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("maxViolConstraintMsg",
                  myMsgFac ().myFrag ("maxViolTotSubVolFrag"));

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theBomEnt->myOperationName ());

               myMsgFac () ("maxViolIndexMsg",
                  "BOM Entry #:",
                  theBomEnt->localIndex ());

               myMsgFac () ("maxViolPeriodMsg", thePer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkCumShipVols ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      theViol;
   bool        reportNeeded;

   forEachDemand (theDemand, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         theViol = 
              theDemand->cumShipVol   ()[thePer]
            - theDemand->cumDemandVol ()[thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("maxViolConstraintMsg",
               myMsgFac ().myFrag ("maxViolCumShipVolFrag"));

            myMsgFac () ("maxViolObjectMsg",
               "Part:",
               theDemand->demandedPartName ());

            myMsgFac () ("maxViolObjectMsg",
               "Demand:",
               theDemand->demandName ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkFeasAllBounds ()
   {
   WitComponent *      theComp;
   const WitBoundSet * theBoundSet;

   forEachEl (theComp, myCompMgr ()->allComponents ())
      {
      theBoundSet = theComp->myBoundSet ();

      if (theBoundSet != NULL)
         {
         checkFeasHardLB (theBoundSet);
         checkFeasHardUB (theBoundSet);
         }
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkFeasLimitedBounds ()
   {
   WitOperation * theOpn;

   forEachOperation (theOpn, myProblem ())
      checkFeasHardUB (theOpn->execBounds ());
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkFeasHardLB (const WitBoundSet * theBoundSet)
   {
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPeriod (thePer, myProblem ())
      {
      theViol = 
           theBoundSet->hardLB ()  [thePer]
         - theBoundSet->boundedVal (thePer);

      recordViolation (theViol, reportNeeded);

      if (reportNeeded)
         {
         myMsgFac () ("maxViolConstraintMsg",
            myMsgFac ().myFrag ("maxViolHardLBFrag"));

         myMsgFac () ("maxViolIndexMsg",
            "Boundset #:",
            theBoundSet->mappingIndex ());

         myMsgFac () ("maxViolPeriodMsg", thePer);
         }
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkFeasHardUB (const WitBoundSet * theBoundSet)
   {
   WitPeriod thePer;
   double    theViol;
   bool      reportNeeded;

   forEachPeriod (thePer, myProblem ())
      if (theBoundSet->hardUBIsFinite (thePer))
         {
         theViol = 
              theBoundSet->boundedVal (thePer)
            - theBoundSet->hardUB ()  [thePer];

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("maxViolConstraintMsg",
               myMsgFac ().myFrag ("maxViolHardUBFrag"));

            myMsgFac () ("maxViolIndexMsg",
               "Boundset #:",
               theBoundSet->mappingIndex ());

            myMsgFac () ("maxViolPeriodMsg", thePer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkFeasLotSizes ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         {
         theViol = lotSizeViol (theOpn, execPer);

         recordViolation (theViol, reportNeeded);

         if (reportNeeded)
            {
            myMsgFac () ("maxViolConstraintMsg",
               myMsgFac ().myFrag ("maxViolLotSizeFrag"));

            myMsgFac () ("maxViolObjectMsg",
               "Operation:",
               theOpn->operationName ());

            myMsgFac () ("maxViolPeriodMsg", execPer);
            }
         }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::checkIntegrality ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         theViol;
   bool           reportNeeded;

   forEachOperation (theOpn, myProblem ())
      if (theOpn->intExecVols ())
         forEachPeriod (execPer, myProblem ())
            {
            theViol = integralityViolation (theOpn->execVol ()[execPer]);

            recordViolation (theViol, reportNeeded);

            if (reportNeeded)
               {
               myMsgFac () ("intConstraintViolMsg", "execVol");

               myMsgFac () ("maxViolObjectMsg",
                  "Operation:",
                  theOpn->operationName ());

               myMsgFac () ("maxViolPeriodMsg", execPer);
               }
            }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::recordViolation (
      double theViolation,
      bool & reportNeeded)
   {
   reportNeeded = false;

   if (theViolation > maxViolation_)
      {
      maxViolation_ = theViolation;

      if (myGlobalComp ()->reportIncViol ())
         {
         myMsgFac () ("maxViolHeadingMsg", maxViolation_);

         reportNeeded = true;
         }
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::verifyUhsNonExecCon ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (not theOpn->executable ()[thePer])
            if (theOpn->execVol ()[thePer] > 0.0)
               myMsgFac () ("uhsNonExecConViolSmsg", 
                  theOpn->operationName (),
                  thePer,
                  theOpn->execVol ()[thePer]);
   }

//------------------------------------------------------------------------------

void WitPostprocessor::verifyUhsSubCon ()
   {
   WitBomEntry * theBomEnt;
   WitPeriod     thePer;
   double        maxViol;
   WitBomEntry * mvBomEnt;
   WitPeriod     mvPer;

   maxViol  = FEAS_TOL;
   mvBomEnt = NULL;
   mvPer    = -1;

   WitDblFlexVec nonSubVolVec (myProblem (), 0.0);

   forEachBomEntry (theBomEnt, myProblem ())
      if (not theBomEnt->mySubEntries ().isEmpty ())
         {
         compNonSubVol (theBomEnt, nonSubVolVec);

         forEachPeriod (thePer, myProblem ())
            if (- nonSubVolVec[thePer] > maxViol)
               {
               maxViol  = - nonSubVolVec[thePer];
               mvBomEnt = theBomEnt;
               mvPer    = thePer;
               }
         }

   if (mvBomEnt != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsSubConViolWmsg",
         maxViol,
         mvBomEnt->myOperationName (),
         mvBomEnt->localIndex (),
         mvPer,
         mvBomEnt->myOperation ()->execVol ()[mvPer],
         mvBomEnt->myOperation ()->execVol ()[mvPer] + maxViol);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::verifyUhsCumDemandCon ()
   {
   WitDemand * theDemand;
   WitPeriod   thePer;
   double      cumDemandVolVal;
   double      cumShipVolVal;
   double      maxViol;
   WitDemand * mvDemand;
   WitPeriod   mvPer;
   double      mvCumDemVol;

   maxViol     = FEAS_TOL;
   mvDemand    = NULL;
   mvPer       = -1;
   mvCumDemVol = 0.0;

   forEachDemand (theDemand, myProblem ())
      {
      cumDemandVolVal = 0.0;
      cumShipVolVal   = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         cumDemandVolVal += theDemand->demandVol ()[thePer];
         cumShipVolVal   += theDemand->shipVol ()[thePer];

         if (cumShipVolVal - cumDemandVolVal > maxViol)
            {
            maxViol     = cumShipVolVal - cumDemandVolVal;
            mvDemand    = theDemand;
            mvPer       = thePer;
            mvCumDemVol = cumDemandVolVal;
            }
         }
      }

   if (mvDemand != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsCumDemandConViolWmsg",
         maxViol,
         mvDemand->demandedPartName (),
         mvDemand->demandName (),
         mvPer,
         mvCumDemVol + maxViol,
         mvCumDemVol);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::verifyUhsExecHUBCon ()
   {
   WitOperation * theOpn;
   WitPeriod      thePer;
   double         hardUBVal;
   double         maxViol;
   WitOperation * mvOpn;
   WitPeriod      mvPer;

   maxViol = FEAS_TOL;
   mvOpn   = NULL;
   mvPer   = -1;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (thePer, myProblem ())
         if (theOpn->execBounds ()->hardUBIsFinite (thePer))
            {
            hardUBVal = theOpn->execBounds ()->hardUB ()[thePer];

            if (theOpn->execVol ()[thePer] - hardUBVal > maxViol)
               {
               maxViol = theOpn->execVol ()[thePer] - hardUBVal;
               mvOpn   = theOpn;
               mvPer   = thePer;
               }
            }

   if (mvOpn != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsExecHUBConViolWmsg",
         maxViol,
         mvOpn->operationName (),
         mvPer,
         mvOpn->execVol ()[mvPer],
         mvOpn->execBounds ()->hardUB ()[mvPer]);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::verifyUhsLotSizeCon ()
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         maxViol;
   WitOperation * mvOpn;
   WitPeriod      mvPer;

   maxViol = FEAS_TOL;
   mvOpn   = NULL;
   mvPer   = -1;

   forEachOperation (theOpn, myProblem ())
      forEachPeriod (execPer, myProblem ())
         if (lotSizeViol (theOpn, execPer) > maxViol)
            {
            maxViol = lotSizeViol (theOpn, execPer);
            mvOpn   = theOpn;
            mvPer   = execPer;
            }

   if (mvOpn != NULL)
      {
      myMsgFac () ("uhsConViolIntroWmsg");

      myMsgFac () ("uhsLotSizeConViolWmsg",
         maxViol,
         mvOpn->operationName (),
         mvPer,
         mvOpn->execVol ()[mvPer]);
      }
   }

//------------------------------------------------------------------------------

double WitPostprocessor::lotSizeViol (WitOperation * theOpn, WitPeriod execPer)
   {
   double upDelta;
   double downDelta;

   upDelta =
      theOpn->lotSizeDelta (
         execPer,
         theOpn->execVol ()[execPer],
         0.0,
         false);

   downDelta =
      theOpn->lotSizeDelta (
         execPer,
         theOpn->execVol ()[execPer],
         - 0.5,
         false);

   return min (fabs (upDelta), fabs (downDelta));
      //
      // The error is the minimum of the distance to the nearest lot-size
      // grid point above the execVol and the nearest one below it.
   }

//------------------------------------------------------------------------------

double WitPostprocessor::integralityViolation (double theValue)
   {
   return
      min (
         theValue        - floor (theValue),
         ceil (theValue) - theValue);
   }
@


1.78
log
@App controlled opt implosion.
@
text
@d653 3
d678 21
a698 6
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitBomEntry *  theBomEnt;
   WitDemand *    theDemand;
   WitPeriod      thePer;
d702 6
a707 1
         if (recordViolation (- thePart->scrapVol ()[thePer]))
d709 1
a709 1
            displayViolConstraint ("maxViolScrapVolNNFrag");
d715 11
d730 5
a734 1
         if (recordViolation (- theMat->stockVol ()[thePer]))
d736 1
a736 1
            displayViolConstraint ("maxViolStockVolNNFrag");
d742 117
d860 28
d889 6
a894 1
            if (recordViolation (theMat->stockVol ()[thePer]))
d896 2
a897 1
               displayViolConstraint ("maxViolMandECFrag");
d899 1
a899 3
               myMsgFac () ("maxViolObjectMsg",
                  "Part:",
                  theMat->partName ());
d903 11
a913 1
         }
d918 6
a923 1
            if (recordViolation (theOpn->execVol ()[thePer]))
d925 2
a926 1
               displayViolConstraint ("maxViolExecutableFrag");
d934 11
d949 6
a954 1
            if (recordViolation (- theBomEnt->nonSubVol()[thePer]))
d956 2
a957 1
               displayViolConstraint ("maxViolTotSubVolFrag");
d969 11
d983 8
a990 4
         if (
            recordViolation (
               theDemand->cumShipVol   ()[thePer] -
               theDemand->cumDemandVol ()[thePer]))
d992 2
a993 1
            displayViolConstraint ("maxViolCumShipVolFrag");
d1005 1
d1042 2
d1046 8
a1053 3
      if (
         recordViolation (
            theBoundSet->hardLB ()[thePer] - theBoundSet->boundedVal (thePer)))
d1055 2
a1056 1
         displayViolConstraint ("maxViolHardLBFrag");
d1064 1
d1072 2
d1077 8
a1084 4
         if (
            recordViolation (
                 theBoundSet->boundedVal (thePer)
               - theBoundSet->hardUB ()  [thePer]))
d1086 2
a1087 1
            displayViolConstraint ("maxViolHardUBFrag");
d1095 1
d1104 2
d1109 6
a1114 1
         if (recordViolation (lotSizeViol (theOpn, execPer)))
d1116 2
a1117 1
            displayViolConstraint ("maxViolLotSizeFrag");
d1125 31
d1160 3
a1162 1
bool WitPostprocessor::recordViolation (double theViolation)
d1164 2
d1174 1
a1174 1
         return true;
a1176 9

   return false;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::displayViolConstraint (WitMsgFragID theFragID)
   {
   myMsgFac () ("maxViolConstraintMsg", myMsgFac ().myFrag (theFragID));
d1395 10
@


1.77
log
@NSTN residualVol.
@
text
@d17 1
d70 1
a70 1
   if (postprocessed ())
d79 1
a79 1
   myProblem ()->preprocess ();
d137 1
a137 1
   if (not postprocessed ())
@


1.76
log
@NSTN residualVol.
@
text
@d213 1
a213 1
   if (myGlobalComp ()->nstnResidual ())
@


1.75
log
@NSTN residualVol.
@
text
@d117 1
a117 1
      compMatResidVolsNstnV2 ();
d208 2
a209 1
   double excVol;
d219 6
d522 1
a522 98
void WitPostprocessor::compMatResidVolsNstnV1 ()
   {
   WitTVec <double> unstockConsVol;
   WitMaterial *    theMat;
   double           netConsVol;
   WitPeriod        thePer;
   double           resVol;

   unstockConsVol.allocate (myProblem (), 0.0);

   forEachMaterial (theMat, myProblem ())
      {
      netConsVol = compCumConsVolV1 (theMat, unstockConsVol);

      theMat->*residualVol_ = 0.0;

      forEachPeriod (thePer, myProblem ())
         {
         netConsVol += unstockConsVol[thePer];

         resVol      =                 theMat->supplyVol ()[thePer];

         resVol     +=                 theMat->prodVol   ()[thePer];

         resVol     += positivePart (- theMat->consVol   ()[thePer]);

         resVol     += positivePart (- incStockLB (theMat,  thePer));

         net (resVol, netConsVol);

         if (resVol > NET_TOL)
            (theMat->*residualVol_).elemRef (thePer) = resVol;
         }
      }
   }

//------------------------------------------------------------------------------

double WitPostprocessor::compCumConsVolV1 (
      WitMaterial *      theMat, 
      WitTVec <double> & unstockConsVol)
   {
   double      cumConsVol;
   WitPeriod   thePer;
   WitDemand * theDemand;
   double      boundGap;
   bool        gapIsFinite;

   cumConsVol     = 0.0;

   unstockConsVol = 0.0;

   for (thePer = lastPeriod (); thePer >= 0; thePer --)
      {
      forEachEl (theDemand, theMat->myDemands ())
         cumConsVol += theDemand->shipVol ()[thePer];

      cumConsVol    += positivePart (theMat->consVol ()[thePer]);

      cumConsVol    += positivePart (incStockLB (theMat, thePer));

      if (thePer > 0)
         {
         boundGap = stockBndGap (theMat, thePer - 1, gapIsFinite);

         if (gapIsFinite)
            if (boundGap < cumConsVol - NET_TOL)
               {
               unstockConsVol[thePer] = cumConsVol - boundGap;

               cumConsVol             = boundGap;
               }
         }
      }

   return cumConsVol;
   }

//------------------------------------------------------------------------------

double WitPostprocessor::incStockLB (WitMaterial * theMat, WitPeriod thePer)
   {
   double curStockLB;
   double prevStockLB;

   curStockLB = stockLB (theMat, thePer);

   prevStockLB =
      (thePer == 0)?
         0.0:
         stockLB (theMat, thePer - 1);

   return curStockLB - prevStockLB;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compMatResidVolsNstnV2 ()
d534 1
a534 1
      netConsVol = compCumConsVolV2 (theMat, unstockConsVol);
d562 1
a562 1
double WitPostprocessor::compCumConsVolV2 (
@


1.74
log
@NSTN residualVol.
@
text
@d533 1
a533 2
         if (thePer > 0)
            netConsVol += unstockConsVol[thePer];
d535 1
a535 1
         resVol  =                 theMat->supplyVol ()[thePer];
d537 1
a537 1
         resVol +=                 theMat->prodVol   ()[thePer];
d539 1
a539 1
         resVol += positivePart (- theMat->consVol   ()[thePer]);
d541 1
a541 1
         resVol += positivePart (- incStockLB (theMat,  thePer));
@


1.73
log
@NSTN residualVol.
@
text
@d117 1
a117 1
      compMatResidVolsNstn ();
a217 2
      excVol -= positivePart (- incStockLB (thePart, thePer));

d515 1
a515 1
void WitPostprocessor::compMatResidVolsNstn ()
d527 1
a527 1
      netConsVol = compCumConsVol (theMat, unstockConsVol);
d554 1
a554 1
double WitPostprocessor::compCumConsVol (
d596 133
a1196 55

//------------------------------------------------------------------------------

double WitPostprocessor::incStockLB (WitPart * thePart, WitPeriod thePer)
   {
   WitMaterial * theMat;
   double        prevStockLB;
   double        curStockLB;

   theMat = thePart->thisMat ();

   if (theMat == NULL)
      return 0.0;

   curStockLB =
      min (
         theMat->stockBounds ()->softLB ()[thePer],
         theMat->stockVol    ()           [thePer]);

   prevStockLB =
      (thePer == 0)?
         0.0:
         min (
            theMat->stockBounds ()->softLB ()[thePer - 1],
            theMat->stockVol    ()           [thePer - 1]);

   return curStockLB - prevStockLB;
   }

//------------------------------------------------------------------------------

double WitPostprocessor::stockBndGap (
      WitMaterial * theMat,
      WitPeriod     thePer,
      bool &        gapIsFinite)
   {
   gapIsFinite = true;

   if (not theMat->canStock (thePer))
      return 0.0;

   if (not theMat->stockBounds ()->hardUBIsFinite (thePer))
      {
      gapIsFinite = false;

      return 0.0;
      }

   return
        theMat   ->stockBounds ()->hardUB ()[thePer]
      - min (
           theMat->stockBounds ()->softLB ()[thePer],
           theMat->stockVol    ()           [thePer]);
      
   }
@


1.72
log
@NSTN residualVols
@
text
@d116 4
a119 1
   compMatResidVolsAsap ();
d519 5
a523 5
   WitMaterial * theMat;
   double        netConsVol;
   WitPeriod     thePer;
   WitDemand *   theDemand;
   double        resVol;
d525 1
a525 1
   stronglyAssert (false);
d529 1
a529 1
      stronglyAssert (theMat->stockBounds ()->isAtDefault ());
d531 1
a531 1
      netConsVol = 0.0;
d535 2
a536 12
         netConsVol += positivePart (theMat->consVol ()[thePer]);

         netConsVol +=
            min (
               theMat->stockBounds ()->softLB ()[thePer],
               theMat->stockVol    ()           [thePer]);
         }

      forEachEl (theDemand, theMat->myDemands ())
         netConsVol += theDemand->cumShipVol ()[lastPeriod ()];

      theMat->*residualVol_ = 0.0;
a537 2
      forEachPeriod (thePer, myProblem ())
         {
d544 1
a544 5
         if (thePer > 0)
            resVol +=
               min (
                  theMat->stockBounds ()->softLB ()[thePer - 1],
                  theMat->stockVol    ()           [thePer - 1]);
d556 42
d1094 27
@


1.71
log
@Updated the copyright date on all source files.
@
text
@d41 1
a42 1
WitDblFlexVec   WitMaterial::* WitPostprocessor::residualVol_ = NULL;
d113 2
d116 1
a116 1
   compResidualVols ();
d203 24
d230 2
a231 1
      WitDblFlexVec WitPart::* scrapVolArg)
d233 4
a236 3
   consVol_  = consVolArg;
   prodVol_  = prodVolArg;
   scrapVol_ = scrapVolArg;
d241 1
a241 3
void WitPostprocessor::receiveDMPs (
      WitDblFlexVec WitMaterial::* stockVolArg,
      WitDblFlexVec WitMaterial::* residualVolArg)
d243 1
a243 2
   stockVol_    = stockVolArg;
   residualVol_ = residualVolArg;
d445 24
a468 1
// compResidualVols.
d477 1
a477 1
void WitPostprocessor::compResidualVols ()
d482 1
d505 3
d514 55
d1037 28
@


1.70
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.69
log
@[multi-thread]
@
text
@d31 2
d34 2
a35 2
WitDblFlexVec WitPart::* WitPostprocessor::consVolPtr_ = NULL;

d38 9
a46 4
void WitPostprocessor::receiveData (WitDblFlexVec WitPart::* consVolPtrArg)
   {
   consVolPtr_ = consVolPtrArg;
   }
a81 2
   loadData ();

d85 1
a85 1
      fssShipVol_ (theDemand) = theDemand->shipVol ();
d100 1
a100 1
            cumShipVol_ (theDemand) = 0.0;
d109 1
a109 1
               cumShipVol_ (theDemand).elemRef (thePer) = cumSum;
a117 2
   clearLoadedData ();

d201 4
a204 17
void WitPostprocessor::loadDataFrom (
      WitPart *       thePart,
      WitDblFlexVec & consVolArg,
      WitDblFlexVec & prodVolArg,
      WitDblFlexVec & scrapVolArg)
   {
   consVol_ .setMapFor (thePart, consVolArg);
   prodVol_ .setMapFor (thePart, prodVolArg);
   scrapVol_.setMapFor (thePart, scrapVolArg);
   }

//------------------------------------------------------------------------------

void WitPostprocessor::loadDataFrom (
      WitMaterial *   theMat,
      WitDblFlexVec & stockVolArg,
      WitDblFlexVec & residualVolArg)
d206 3
a208 2
   stockVol_   .setMapFor (theMat, stockVolArg);
   residualVol_.setMapFor (theMat, residualVolArg);
d213 3
a215 4
void WitPostprocessor::loadDataFrom (
      WitDemand *     theDemand,
      WitDblFlexVec & cumShipVolArg,
      WitDblFlexVec & fssShipVolArg)
d217 2
a218 2
   cumShipVol_.setMapFor (theDemand, cumShipVolArg);
   fssShipVol_.setMapFor (theDemand, fssShipVolArg);
d223 3
a225 3
void WitPostprocessor::loadDataFrom (
      WitBomEntry *   theBomEnt,
      WitDblFlexVec & nonSubVolArg)
d227 2
a228 1
   nonSubVol_.setMapFor (theBomEnt, nonSubVolArg);
d233 1
a233 2
void WitPostprocessor::loadDataFromGlobalComp (
      bool                & feasibleArg)
d235 1
a235 1
   feasible_.attachTo (feasibleArg);
d240 1
a240 1
void WitPostprocessor::loadData ()
d242 1
a242 28
   WitComponent * theComp;

   consVol_    .allocate (myProblem ());
   prodVol_    .allocate (myProblem ());
   scrapVol_   .allocate (myProblem ());
   stockVol_   .allocate (myProblem ());
   residualVol_.allocate (myProblem ());
   cumShipVol_ .allocate (myProblem ());
   fssShipVol_ .allocate (myProblem ());
   nonSubVol_  .allocate (myProblem ());

   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->loadPost ();
   }

//------------------------------------------------------------------------------

void WitPostprocessor::clearLoadedData ()
   {
   consVol_    .clear ();
   prodVol_    .clear ();
   scrapVol_   .clear ();
   stockVol_   .clear ();
   residualVol_.clear ();
   cumShipVol_ .clear ();
   fssShipVol_ .clear ();
   nonSubVol_  .clear ();
   feasible_   .clear ();
d276 1
a276 1
         compNonSubVol (theBomEnt, nonSubVol_ (theBomEnt));
d307 1
a307 3
//    consVol_ (thePart) = consVolVec;

      thePart->*consVolPtr_ = consVolVec;
d322 1
a322 1
      prodVol_ (thePart) = prodVolVec;
d340 1
a340 1
         scrapVol_ (thePart) = scrapVolVec;
d396 2
a397 2
      stockVol_ (theMat) = stockVolVec;
      scrapVol_ (theMat) = scrapVolVec;
d456 1
a456 1
      residualVol_ (theMat) = theResidualVol;
d482 1
a482 1
   feasible_ () = (maxViolation_ <= FEAS_TOL);
@


1.68
log
@Revised mappingIndex code.
@
text
@d32 11
d344 3
a346 1
      consVol_ (thePart) = consVolVec;
@


1.67
log
@pegged Critical List.
@
text
@a28 1
#include <MapIdxI.h>
@


1.66
log
@Tie Breaking Prop-Rt.
@
text
@d235 1
a235 1
   feasible_.refTo (feasibleArg);
@


1.65
log
@PIP.
@
text
@d22 1
a22 1
#include <PipSysMgr.h>
d121 1
a121 1
   myProblem ()->myPipSysMgr ()->clearPegging ();
@


1.64
log
@Double Precision.
@
text
@d322 1
a322 1
         theBomEnt->nonSubVol ().copyInto (execVolVec);
d329 1
a329 1
         theSub->subVol ().copyInto (execVolVec);
d469 2
a470 2
      theMat->stockVol ().copyInto (usedStockVol);
      theMat->scrapVol ().copyInto (theResidualVol);
@


1.63
log
@Double Precision.
@
text
@d322 1
a322 1
         theBomEnt->nonSubVol ().convCopyInto (execVolVec);
d329 1
a329 1
         theSub->subVol ().convCopyInto (execVolVec);
d469 2
a470 2
      theMat->stockVol ().convCopyInto (usedStockVol);
      theMat->scrapVol ().convCopyInto (theResidualVol);
@


1.62
log
@Double Precision.
@
text
@d85 1
a85 1
            cumShipVol_ (theDemand).setToScalar (0.0);
d176 1
a176 1
   prodVolVec.setToScalar (0.0);
d318 1
a318 1
      consVolVec.setToScalar (0.0);
d334 1
a334 1
      consVol_ (thePart).convCopy (consVolVec);
d349 1
a349 1
      prodVol_ (thePart).convCopy (prodVolVec);
d367 1
a367 1
         scrapVol_ (thePart).convCopy (scrapVolVec);
d423 2
a424 2
      stockVol_ (theMat).convCopy (stockVolVec);
      scrapVol_ (theMat).convCopy (scrapVolVec);
d483 1
a483 1
      residualVol_ (theMat).convCopy (theResidualVol);
@


1.61
log
@Double Precision.
@
text
@d70 1
a70 1
      fssShipVol_ (theDemand).copy (theDemand->shipVol ());
d159 1
a159 1
   nonSubVolVec.copy (theBomEnt->myOperation ()->execVol ());
@


1.60
log
@Double Precision.
@
text
@d153 2
a154 2
      WitBomEntry *         theBomEnt,
      WitFlexVec <double> & nonSubVolVec)
d189 4
a192 4
      WitPart *             thePart,
      WitFlexVec <double> & consVolArg,
      WitFlexVec <double> & prodVolArg,
      WitFlexVec <double> & scrapVolArg)
d202 3
a204 3
      WitMaterial *         theMat,
      WitFlexVec <double> & stockVolArg,
      WitFlexVec <double> & residualVolArg)
d213 3
a215 3
      WitDemand *           theDemand,
      WitFlexVec <double> & cumShipVolArg,
      WitFlexVec <double> & fssShipVolArg)
d224 2
a225 2
      WitBomEntry *         theBomEnt,
      WitFlexVec <double> & nonSubVolArg)
d772 1
a772 1
   WitFlexVec <double> nonSubVolVec (myProblem (), 0.0);
@


1.59
log
@Double Precision.
@
text
@d70 1
a70 1
      fssShipVol_ (theDemand).convCopy (theDemand->shipVol ());
d94 1
a94 1
               cumShipVol_ (theDemand).setElem (thePer, cumSum);
d189 4
a192 4
      WitPart *    thePart,
      WitRealVec & consVolArg,
      WitRealVec & prodVolArg,
      WitRealVec & scrapVolArg)
d202 3
a204 3
      WitMaterial * theMat,
      WitRealVec &  stockVolArg,
      WitRealVec &  residualVolArg)
d213 3
a215 3
      WitDemand *   theDemand,
      WitRealVec &  cumShipVolArg,
      WitRealVec &  fssShipVolArg)
@


1.58
log
@Double Precision.
@
text
@d203 1
a203 1
      WitRealTVc &  stockVolArg,
d214 2
a215 2
      WitRealVec  & cumShipVolArg,
      WitRealTVc &  fssShipVolArg)
@


1.57
log
@Double Precision.
@
text
@d203 1
a203 1
      WitRealVec &  stockVolArg,
d215 1
a215 1
      WitRealVec &  fssShipVolArg)
@


1.56
log
@Double Precision.
@
text
@d357 3
a359 3
   WitPart *       thePart;
   WitPeriod       thePer;
   WitTVec <float> scrapVolVec (myProblem (), 0.0);
d717 1
a717 1
bool WitPostprocessor::recordViolation (float theViolation)
@


1.55
log
@Double Precision.
@
text
@d94 1
a94 1
               cumShipVol_ (theDemand).elemRef (thePer) = cumSum;
d213 3
a215 3
      WitDemand *           theDemand,
      WitFlexVec <float>  & cumShipVolArg,
      WitRealVec &          fssShipVolArg)
@


1.54
log
@Double Precision.
@
text
@d70 1
a70 1
      fssShipVol_ (theDemand).copyDblFlexVec (theDemand->shipVol ());
d322 1
a322 1
         theBomEnt->nonSubVol ().copyIntoTVec (execVolVec);
d329 1
a329 1
         theSub->subVol ().copyIntoTVec (execVolVec);
d334 1
a334 1
      consVol_ (thePart).copyDblTVec (consVolVec);
d349 1
a349 1
      prodVol_ (thePart).copyDblTVec (prodVolVec);
d367 1
a367 1
         scrapVol_ (thePart).copyFltTVec (scrapVolVec);
d423 2
a424 2
      stockVol_ (theMat).copyDblTVec (stockVolVec);
      scrapVol_ (theMat).copyDblTVec (scrapVolVec);
d469 2
a470 2
      theMat->stockVol ().copyIntoDblTVec (usedStockVol);
      theMat->scrapVol ().copyIntoDblTVec (theResidualVol);
d483 1
a483 1
      residualVol_ (theMat).copyDblTVec (theResidualVol);
@


1.53
log
@Double Precision.
@
text
@d70 1
a70 1
      copyInto (fssShipVol_ (theDemand), theDemand->shipVol ());
d215 1
a215 1
      WitTVec    <float>  & fssShipVolArg)
@


1.52
log
@Double Precision.
@
text
@d412 1
a412 1
                  doubleFromFloat (theMat->stockBounds ()->hardUB ()[thePer]));
@


1.51
log
@Double Precision.
@
text
@d189 4
a192 4
      WitPart *             thePart,
      WitRealVec &          consVolArg,
      WitFlexVec <float>  & prodVolArg,
      WitFlexVec <float>  & scrapVolArg)
d202 3
a204 3
      WitMaterial *         theMat,
      WitTVec    <float>  & stockVolArg,
      WitFlexVec <float>  & residualVolArg)
d349 1
a349 1
      copyInto (prodVol_ (thePart), prodVolVec);
d367 1
a367 1
         scrapVol_ (thePart).copyTVec (scrapVolVec);
d423 2
a424 2
      copyInto (stockVol_ (theMat), stockVolVec);
      copyInto (scrapVol_ (theMat), scrapVolVec);
d469 2
a470 2
      copyInto (usedStockVol,   theMat->stockVol ());
      copyInto (theResidualVol, theMat->scrapVol ());
d483 1
a483 1
      copyInto (residualVol_ (theMat), theResidualVol);
@


1.50
log
@Continued double precision.
@
text
@d190 1
a190 1
      WitFlexVec <float>  & consVolArg,
d334 1
a334 1
      copyInto (consVol_ (thePart), consVolVec);
@


1.49
log
@Replaced the severe error for most constraint violations in the
   user-specified heuristic starting solution with a warning.
@
text
@d412 1
a412 2
                  static_cast <double> (
                     theMat->stockBounds ()->hardUB ()[thePer]));
@


1.48
log
@Continued implementation of PIP.
@
text
@d143 1
a752 3
               {
               myMsgFac () ("uhsConViolIntroSmsg");

a756 1
               }
d765 7
d781 1
a781 1
            if (nonSubVolVec[thePer] < - FEAS_TOL)
d783 3
a785 9
               myMsgFac () ("uhsConViolIntroSmsg");

               myMsgFac () ("uhsSubConViolSmsg",
                  theBomEnt->myOperationName (),
                  theBomEnt->localIndex (),
                  thePer,
                  theBomEnt->myOperation ()->execVol ()[thePer],
                    theBomEnt->myOperation ()->execVol ()[thePer]
                  - nonSubVolVec[thePer]);
d788 13
d811 9
d831 1
a831 1
         if (cumShipVolVal > cumDemandVolVal + FEAS_TOL)
d833 4
a836 8
            myMsgFac () ("uhsConViolIntroSmsg");

            myMsgFac () ("uhsCumDemandConViolSmsg",
               theDemand->demandedPartName (),
               theDemand->demandName (),
               thePer,
               cumShipVolVal,
               cumDemandVolVal);
d840 13
d862 7
d876 1
a876 1
            if (theOpn->execVol ()[thePer] > hardUBVal + FEAS_TOL)
d878 3
a880 7
               myMsgFac () ("uhsConViolIntroSmsg");

               myMsgFac () ("uhsExecHUBConViolSmsg",
                  theOpn->operationName (),
                  thePer,
                  theOpn->execVol ()[thePer],
                  hardUBVal);
d883 12
d903 7
d913 1
a913 1
         if (lotSizeViol (theOpn, execPer) > FEAS_TOL)
d915 8
a922 1
            myMsgFac () ("uhsConViolIntroSmsg");
d924 6
a929 5
            myMsgFac () ("uhsLotSizeConViolSmsg",
               theOpn->operationName (),
               execPer,
               theOpn->execVol ()[execPer]);
            }
@


1.47
log
@Continued implementation of PIP.
@
text
@d22 1
a22 1
#include <PipMgr.h>
d121 1
a121 1
   myProblem ()->myPipMgr ()->clearPegging ();
@


1.46
log
@Continued implementation of PIP.
@
text
@a104 4
   if (myGlobalComp ()->pip ())
      if (myProblem ()->myHeurVariant ()->isCurrent ())
         myProblem ()->myPipMgr ()->buildPegging ();

d121 1
a121 3
   if (myGlobalComp ()->pip ())
      if (myProblem ()->myHeurVariant ()->isCurrent ())
         myProblem ()->myPipMgr ()->clearPegging ();
@


1.45
log
@Continued implementation of PIP.
@
text
@d22 1
a22 1
#include <PipInt.h>
d107 1
a107 1
         myProblem ()->myPipInt ()->buildPegging ();
d127 1
a127 1
         myProblem ()->myPipInt ()->clearPegging ();
@


1.44
log
@Added implementation of template function to avoid link time error on windows
@
text
@d319 1
d326 9
a334 1
         incConsVol (theBomEnt, consVolVec, theBomEnt->nonSubVol ());
d336 2
a337 2
      forEachEl (theSub,    thePart->consumingSubEntries ())
         incConsVol (theSub,    consVolVec, theSub    ->subVol ());
a904 40

//------------------------------------------------------------------------------
// Implementation of NonClass function template incConsVol.
//------------------------------------------------------------------------------

template <typename VecType> 
      void WitNonClass::incConsVol (
         WitConsEntry *     theConsEnt,
         WitTVec <double> & consVolArg,
         const VecType    & execVolArg)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, theConsEnt->myProblem ())
      if (theConsEnt->inEffect (thePer))
         consVolArg[theConsEnt->impactPeriod ()[thePer]] += 
            theConsEnt->effConsRate ()[thePer] * execVolArg[thePer];
   }

//------------------------------------------------------------------------------
// Explicit instantiation of NonClass function template incConsVol.
//------------------------------------------------------------------------------

template 
   void WitNonClass::incConsVol <WitTVec <float> > (
      WitConsEntry *,
      WitTVec <double> &,
      const WitTVec <float> &);

template 
   void WitNonClass::incConsVol <WitFlexVec <float> > (
      WitConsEntry *,
      WitTVec <double> &,
      const WitFlexVec <float> &);

template 
   void WitNonClass::incConsVol <WitFlexVec <double> > (
      WitConsEntry *,
      WitTVec <double> &,
      const WitFlexVec <double> &);
@


1.43
log
@Continued implementation of PIP.
@
text
@d930 6
@


1.42
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d16 4
a21 2
#include <BopEntry.h>
#include <Post.h>
d896 34
@


1.41
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d103 1
a103 1
   if (myGlobalComp ()->perfPIPegging ())
d123 1
a123 1
   if (myGlobalComp ()->perfPIPegging ())
@


1.40
log
@Continued implementation of post-implosion pegging.
@
text
@d353 1
a353 1
   WitTVec <float> theScrapVol (myProblem (), 0.0);
d359 1
a359 1
            theScrapVol[thePer] = unstockedScrapVol (thePart, thePer);
d361 1
a361 1
         scrapVol_ (thePart).copyTVec (theScrapVol);
d385 2
a386 2
   WitTVec <double> theStockVol (myProblem (), 0.0);
   WitTVec <double> theScrapVol (myProblem (), 0.0);
d395 1
a395 1
            rollingInv += theStockVol[thePer - 1];
d412 2
a413 2
         theStockVol[thePer] = stockVolVal;
         theScrapVol[thePer] = rollingInv - stockVolVal;
d416 1
a416 1
      theMat->rollBackScrap (theStockVol, theScrapVol);
d418 2
a419 2
      copyInto (stockVol_ (theMat), theStockVol);
      copyInto (scrapVol_ (theMat), theScrapVol);
@


1.39
log
@Continued implementation of post-implosion pegging.
@
text
@d27 1
a27 1
#include <RefMapI.h>
@


1.38
log
@Continued implementation of post-implosion pegging.
@
text
@d20 1
a20 1
#include <PIPegInt.h>
d105 1
a105 1
         myProblem ()->myPIPegInt ()->formPegging ();
d125 1
a125 1
         myProblem ()->myPIPegInt ()->clearPegging ();
@


1.37
log
@Continued implementation of post-implosion pegging.
@
text
@d105 1
a105 1
         myProblem ()->myPIPegInt ()->peg ();
d125 1
a125 1
         myProblem ()->myPIPegInt ()->clear ();
@


1.36
log
@Continued implementation of post-implosion pegging.
@
text
@a27 1
#include <FlexVecI.h>
@


1.35
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d104 1
a104 1
   if (myGlobalComp ()->perfPegging ())
d124 1
a124 1
   if (myGlobalComp ()->perfPegging ())
@


1.34
log
@Continued implementation of opt with COIN.
@
text
@d20 1
d104 4
d123 4
@


1.33
log
@Continued implementation of proportionate routing.
@
text
@d61 1
a61 1
   WitTimingEvent theEvent ("postproc");
d108 2
@


1.32
log
@Changed some C style casts to C++ style.
@
text
@a26 1
#include <RefI.h>
@


1.31
log
@Internal changes.
@
text
@d397 2
a398 1
                  (double) theMat->stockBounds ()->hardUB ()[thePer]);
@


1.30
log
@Internal changes.
@
text
@d76 1
a76 1
   if (! myProblem ()->currentVariant ()->compsSecScheds ())
d115 1
a115 1
   if (! postprocessed ())
d275 1
a275 1
      if (! (theDemand->shipVol () >= 0.0))
d279 1
a279 1
      if (! (theOpn->execVol () >= 0.0))
d283 1
a283 1
      if (! (theSub->subVol () >= 0.0))
d296 1
a296 1
      if (! theBomEnt->mySubEntries ().isEmpty ())
d390 1
a390 1
         if (! theMat->canStock (thePer))
d498 1
a498 1
         if (! myGlobalComp ()->feasible ())
d540 1
a540 1
         if (! theMat->canStock (thePer))
d555 1
a555 1
         if (! theOpn->executable ()[thePer])
d568 1
a568 1
      if (! theBomEnt->mySubEntries ().isEmpty ())
d735 1
a735 1
         if (! theOpn->executable ()[thePer])
d757 1
a757 1
      if (! theBomEnt->mySubEntries ().isEmpty ())
@


1.29
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d36 1
a36 1
      postprocessed_ (witFALSE),
d108 1
a108 1
         witTRUE);
d128 1
a128 1
         witFALSE);
d227 1
a227 1
      WitBoolean          & feasibleArg)
d268 1
a268 1
WitBoolean WitPostprocessor::solnIsNonnegative ()
d276 1
a276 1
         return witFALSE;
d280 1
a280 1
         return witFALSE;
d284 1
a284 1
         return witFALSE;
d286 1
a286 1
   return witTRUE;
d702 1
a702 1
WitBoolean WitPostprocessor::recordViolation (float theViolation)
d712 1
a712 1
         return witTRUE;
d716 1
a716 1
   return witFALSE;
d870 1
a870 1
         witFALSE);
d877 1
a877 1
         witFALSE);
@


1.28
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@a475 2
   WitBoolean solnFromUHS;

d499 4
a502 15
            {
            solnFromUHS = witFALSE;

            if (myGlobalComp ()->userHeurStart ())
               if (   myProblem ()->currentVariant () 
                   == myProblem ()->myHeurVariant ())
                  solnFromUHS = witTRUE;

            if (solnFromUHS)
               myMsgFac () ("infeasUHSWmsg", maxViolation ());
            else
               myMsgFac () (
                  "infeasWmsg",
                  myMsgFac ().myFrag (
                     myProblem ()->currentVariant ()->myFragID ()),
a503 1
            }
@


1.27
log
@Continued implementation of user-specified heuristic starting solution.
@
text
@d133 13
d372 3
a374 3
   WitPeriod     t;
   double        invT;      // Rolling inventory in period t.
   double        stockVolT; // stockVol[t].
d381 1
a381 1
      forEachPeriod (t, myProblem ())
d383 1
a383 1
         invT = unstockedScrapVol (theMat, t);
d385 2
a386 2
         if (t > 0)
            invT += theStockVol[t-1];
d388 1
a388 1
         stockVolT = invT;
d390 2
a391 2
         if (! theMat->canStock (t))
            stockVolT = 0.0;
d394 1
a394 1
            if (theMat->stockBounds ()->hardUBIsFinite (t))
d396 2
a397 2
                  stockVolT,
                  (double) theMat->stockBounds ()->hardUB ()[t]);
d399 2
a400 2
         if (stockVolT < 0.0)
             stockVolT = 0.0;
d402 2
a403 2
         theStockVol[t] = stockVolT;
         theScrapVol[t] = invT - stockVolT;
a475 1
   float      feasTol;
a477 1
   feasTol       = 0.001;
d496 1
a496 1
   feasible_ () = (maxViolation_ <= feasTol);
a504 1
               {
a508 5
               if (   myProblem ()->currentVariant () 
                   == myProblem ()->myHeurOptVariant ())
                  solnFromUHS = witTRUE;
               }

d529 1
a529 1
   WitPeriod      t;
d532 2
a533 2
      forEachPeriod (t, myProblem ())
         if (recordViolation (- thePart->scrapVol ()[t]))
d539 1
a539 1
            myMsgFac () ("maxViolPeriodMsg", t);
d543 1
a543 1
      forEachPeriod (t, myProblem ())
d545 1
a545 1
         if (recordViolation (- theMat->stockVol ()[t]))
d551 1
a551 1
            myMsgFac () ("maxViolPeriodMsg", t);
d554 2
a555 2
         if (! theMat->canStock (t))
            if (recordViolation (theMat->stockVol ()[t]))
d563 1
a563 1
               myMsgFac () ("maxViolPeriodMsg", t);
d568 3
a570 3
      forEachPeriod (t, myProblem ())
         if (! theOpn->executable ()[t])
            if (recordViolation (theOpn->execVol ()[t]))
d578 1
a578 1
               myMsgFac () ("maxViolPeriodMsg", t);
d583 2
a584 2
         forEachPeriod (t, myProblem ())
            if (recordViolation (- theBomEnt->nonSubVol()[t]))
d596 1
a596 1
               myMsgFac () ("maxViolPeriodMsg", t);
d600 1
a600 1
      forEachPeriod (t, myProblem ())
d603 2
a604 2
               theDemand->cumShipVol   ()[t] -
               theDemand->cumDemandVol ()[t]))
d616 1
a616 1
            myMsgFac () ("maxViolPeriodMsg", t);
d653 1
a653 1
   WitPeriod t;
d655 1
a655 1
   forEachPeriod (t, myProblem ())
d658 1
a658 1
            theBoundSet->hardLB ()[t] - theBoundSet->boundedVal (t)))
d666 1
a666 1
         myMsgFac () ("maxViolPeriodMsg", t);
d674 1
a674 1
   WitPeriod t;
d676 2
a677 2
   forEachPeriod (t, myProblem ())
      if (theBoundSet->hardUBIsFinite (t))
d680 2
a681 1
               theBoundSet->boundedVal (t) - theBoundSet->hardUB ()[t]))
d689 1
a689 1
            myMsgFac () ("maxViolPeriodMsg", t);
d698 1
a698 4
   WitPeriod      thePer;
   double         upDelta;
   double         downDelta;
   double         theViolation;
d701 2
a702 22
      forEachPeriod (thePer, myProblem ())
         {
         upDelta =
            theOpn->lotSizeDelta (
               thePer,
               theOpn->execVol ()[thePer],
               0.0,
               witFALSE);

         downDelta =
            theOpn->lotSizeDelta (
               thePer,
               theOpn->execVol ()[thePer],
               - 0.5,
               witFALSE);

         theViolation = min (fabs (upDelta), fabs (downDelta));
            //
            // The error is the minimum of the distance to the nearest lot-size
            // grid point above the execVol and the nearest one below it.

         if (recordViolation (theViolation))
d710 1
a710 1
            myMsgFac () ("maxViolPeriodMsg", thePer);
a711 1
         }
d738 159
@


1.26
log
@Continued implementation of heuristic implosion from an initial solution.
Fixed a bug in build-ahead by demand.
Removed RWClient.C.
@
text
@d464 1
a464 1
   WitBoolean solnFromHIS;
d491 1
a491 1
            solnFromHIS = witFALSE;
d493 1
a493 1
            if (myGlobalComp ()->heurInitSoln ())
d497 1
a497 1
                  solnFromHIS = witTRUE;
d501 1
a501 1
                  solnFromHIS = witTRUE;
d504 2
a505 2
            if (solnFromHIS)
               myMsgFac () ("infeasHISWmsg", maxViolation ());
@


1.25
log
@Began implementation of heuristic implosion from an initial solution.
@
text
@d463 2
a464 1
   float feasTol = 0.001;
d466 1
d490 23
a512 5
            myMsgFac () (
               "infeasWmsg",
               myMsgFac ().myFrag (
                  myProblem ()->currentVariant ()->myFragID ()),
               maxViolation ());
@


1.24
log
@Continued implementation of 2-level lot sizes.
@
text
@d133 36
d280 1
a280 4
   WitBomEntry *    theBomEnt;
   WitTVec <double> theNonSubVol (myProblem (), 0.0);
   WitSubEntry *    theSub;
   WitPeriod        thePer;
d283 2
a284 13
      {
      if (theBomEnt->mySubEntries ().isEmpty ())
         continue;

      theBomEnt->myOperation ()->execVol ().copyIntoTVec (theNonSubVol);

      forEachEl (theSub, theBomEnt->mySubEntries ())
         forEachPeriod (thePer, myProblem ())
            if (theSub->inEffect (thePer))
               theNonSubVol[thePer] -= theSub->subVol ()[thePer];

      nonSubVol_ (theBomEnt).copyTVec (theNonSubVol);
      }
d294 1
a294 1
   WitTVec <double> theConsVol (myProblem (), 0.0);
d298 1
a298 1
      theConsVol.setToScalar (0.0);
d301 1
a301 1
         incConsVol (theBomEnt, theConsVol, theBomEnt->nonSubVol ());
d304 1
a304 1
         incConsVol (theSub,    theConsVol, theSub    ->subVol ());
d306 1
a306 1
      copyInto (consVol_ (thePart), theConsVol);
d315 1
a315 3
   WitBopEntry *    theBopEnt;
   WitPeriod        t;
   WitTVec <double> theProdVol (myProblem (), 0.0);
d319 1
a319 8
      theProdVol.setToScalar (0.0);

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         forEachPeriod (t, myProblem ())
            if (theBopEnt->inEffect (t))
               theProdVol[theBopEnt->impactPeriod ()[t]] +=
                  theBopEnt->effProdRate ()[t] *
                  theBopEnt->myOperation ()->execVol ()[t];
d321 1
a321 1
      copyInto (prodVol_ (thePart), theProdVol);
d405 1
a405 1
   double      theVol;
d407 1
a407 1
   theVol =
d413 1
a413 1
      theVol -= theDemand->shipVol ()[thePer];
d415 1
a415 1
   return theVol;
@


1.23
log
@Continued implementation of 2-level lot sizes.
@
text
@d678 1
a678 1
               - theOpn->incLotSize ()[thePer] / 2.0,
@


1.22
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d659 1
a659 1
   WitPeriod      t;
d665 1
a665 1
      forEachPeriod (t, myProblem ())
d667 13
a679 2
         upDelta   = 0.0;
         downDelta = 0.0;
d681 1
a681 15
         theOpn->lotSizeDelta (
            t,
            theOpn->execVol ()[t],
            upDelta,
            witTRUE,
            witFALSE);

         theOpn->lotSizeDelta (
            t,
            theOpn->execVol ()[t],
            downDelta,
            witFALSE,
            witFALSE);

         theViolation = min (upDelta, - downDelta);
d694 1
a694 1
            myMsgFac () ("maxViolPeriodMsg", t);
@


1.21
log
@Continued implementation of single-source.
@
text
@d24 2
d28 1
a28 2
#include <MsgFrag.h>
#include <MsgFac.h>
@


1.20
log
@Continued implementation of single-source.
@
text
@d26 1
d476 2
a477 2
               myMsgFac ()[
                  myProblem ()->currentVariant ()->myFragID ()],
d724 1
a724 1
   myMsgFac () ("maxViolConstraintMsg", myMsgFac ()[theFragID]);
@


1.19
log
@Continued implementation of single-source.
@
text
@d277 1
a277 1
         theBomEnt->incConsVol (theConsVol, theBomEnt->nonSubVol ());
d279 2
a280 2
      forEachEl (theSub,      thePart->consumingSubEntries ())
         theSub   ->incConsVol (theConsVol, theSub    ->subVol ());
@


1.18
log
@Continued implementation of single-source.
@
text
@a33 9
      consVol_       (),
      prodVol_       (),
      scrapVol_      (),
      stockVol_      (),
      residualVol_   (),
      cumShipVol_    (),
      fssShipVol_    (),
      nonSubVol_     (),
      feasible_      (),
@


1.17
log
@Continued implementation of single-source.
@
text
@d24 2
a25 1
#include <RefMap.h>
d34 9
a42 10
      consVol_       (* new WitRefMap <WitPart,     WitFlexVec <float>  >), 
      prodVol_       (* new WitRefMap <WitPart,     WitFlexVec <float>  >), 
      scrapVol_      (* new WitRefMap <WitPart,     WitFlexVec <float>  >), 
      stockVol_      (* new WitRefMap <WitMaterial, WitTVec    <float>  >), 
      residualVol_   (* new WitRefMap <WitMaterial, WitFlexVec <float>  >), 
      cumShipVol_    (* new WitRefMap <WitDemand,   WitFlexVec <float>  >), 
      fssShipVol_    (* new WitRefMap <WitDemand,   WitTVec    <float>  >), 
      nonSubVol_     (* new WitRefMap <WitBomEntry, WitFlexVec <double> >), 

      feasiblePtr_   (NULL),
a51 8
   delete & consVol_;
   delete & prodVol_;
   delete & scrapVol_;
   delete & stockVol_;
   delete & residualVol_;
   delete & cumShipVol_;
   delete & fssShipVol_;
   delete & nonSubVol_;
d187 1
a187 1
   feasiblePtr_ = & feasibleArg;
d221 1
a221 2

   feasiblePtr_ = NULL;
d226 1
a226 1
WitBoolean WitPostprocessor::solnIsNonnegative () const
d249 1
a249 1
void WitPostprocessor::compNonSubVols () const
d274 1
a274 1
void WitPostprocessor::compConsVols () const
d297 1
a297 1
void WitPostprocessor::compProdVols () const
d321 1
a321 1
void WitPostprocessor::compCapacityScrapVols () const
d350 1
a350 1
void WitPostprocessor::compMaterialStockScrapVols () const
d396 1
a396 4
double WitPostprocessor::unstockedScrapVol (
      WitPart * thePart,
      WitPeriod thePer)
      const
d422 1
a422 1
void WitPostprocessor::compResidualVols () const
d477 1
a477 1
   feasible () = (maxViolation_ <= feasTol);
d730 1
a730 1
void WitPostprocessor::displayViolConstraint (WitMsgFragID theFragID) const
@


1.16
log
@Continued implementation of single-source.
@
text
@d24 1
d33 10
a42 1
      myAccFlag_     (new WitAccFlag),
d52 8
a59 1
   delete myAccFlag_;
d79 2
d84 1
a84 1
      copyInto (fssShipVol (theDemand), theDemand->shipVol ());
d99 1
a99 1
            cumShipVol (theDemand).setToScalar (0.0);
d108 1
a108 1
               cumShipVol (theDemand).elemRef (thePer) = cumSum;
d117 2
d133 3
a135 2
   maxViolation_              = 0.0;
   feasible (myGlobalComp ()) = witFALSE;
d148 87
d277 1
a277 1
      nonSubVol (theBomEnt).copyTVec (theNonSubVol);
d300 1
a300 1
      copyInto (consVol (thePart), theConsVol);
d324 1
a324 1
      copyInto (prodVol (thePart), theProdVol);
d342 1
a342 1
         scrapVol (thePart).copyTVec (theScrapVol);
d398 2
a399 2
      copyInto (stockVol (theMat), theStockVol);
      copyInto (scrapVol (theMat), theScrapVol);
d461 1
a461 1
      copyInto (residualVol (theMat), theResidualVol);
d489 1
a489 1
   feasible (myGlobalComp ()) = (maxViolation_ <= feasTol);
@


1.15
log
@Continued implementation of single-source.
@
text
@d32 1
d42 1
d52 3
a54 7
   WitDemand *   theDemand;
   WitBomEntry * theBomEnt;
   WitPart *     thePart;
   WitMaterial * theMat;

   WitTVec <double> theDblTVec1 (myProblem (), 0.0);
   WitTVec <double> theDblTVec2 (myProblem (), 0.0);
d65 1
a65 3
      {
      if (! myProblem ()->currentVariant ()->compsSecScheds ())
         theDemand->compCumShipVol ();
d67 1
a67 2
      theDemand->compDefFssShipVol ();
      }
d69 2
a70 2
   forEachBomEntry (theBomEnt, myProblem ())
      theBomEnt->compNonSubVol ();
d72 1
a72 1
   forEachPart (thePart, myProblem ())
d74 1
a74 2
      thePart->compConsVol (theDblTVec1);
      thePart->compProdVol (theDblTVec1);
d76 1
a76 2
      if (! myProblem ()->currentVariant ()->compsSecScheds ())
         thePart->compStockScrapVol (theDblTVec1, theDblTVec2);
d78 6
a83 1
      thePart->getMaterial (theMat);
d85 7
a91 2
      if (theMat != NULL)
         theMat->compResidualVol (theDblTVec1, theDblTVec2);
d94 3
a96 1
   findViols ();
d112 2
a113 3
   maxViolation_ = 0.0;

   myGlobalComp ()->unpostprocess ();
d126 1
a126 1
WitBoolean WitPostprocessor::solnIsNonnegative ()
d149 210
a358 1
void WitPostprocessor::findViols ()
d360 2
d380 1
a380 1
   myGlobalComp ()->compFeasible ();
d401 1
a401 1
   WitPeriod      thePer;
d404 2
a405 2
      forEachPeriod (thePer, myProblem ())
         if (recordViolation (- thePart->scrapVol ()[thePer]))
d411 1
a411 1
            myMsgFac () ("maxViolPeriodMsg", thePer);
d415 1
a415 1
      forEachPeriod (thePer, myProblem ())
d417 1
a417 1
         if (recordViolation (- theMat->stockVol ()[thePer]))
d423 1
a423 1
            myMsgFac () ("maxViolPeriodMsg", thePer);
d426 2
a427 2
         if (! theMat->canStock (thePer))
            if (recordViolation (theMat->stockVol ()[thePer]))
d435 1
a435 1
               myMsgFac () ("maxViolPeriodMsg", thePer);
d440 3
a442 3
      forEachPeriod (thePer, myProblem ())
         if (! theOpn->executable ()[thePer])
            if (recordViolation (theOpn->execVol ()[thePer]))
d450 1
a450 1
               myMsgFac () ("maxViolPeriodMsg", thePer);
d455 2
a456 2
         forEachPeriod (thePer, myProblem ())
            if (recordViolation (- theBomEnt->nonSubVol ()[thePer]))
d468 1
a468 1
               myMsgFac () ("maxViolPeriodMsg", thePer);
d472 1
a472 1
      forEachPeriod (thePer, myProblem ())
d475 2
a476 2
               theDemand->cumShipVol   ()[thePer] -
               theDemand->cumDemandVol ()[thePer]))
d488 1
a488 1
            myMsgFac () ("maxViolPeriodMsg", thePer);
d633 1
a633 1
void WitPostprocessor::displayViolConstraint (WitMsgFragID theFragID)
@


1.14
log
@Continued implementation of single-source.
@
text
@a31 7
      consVol_       (),
      prodVol_       (),
      scrapVol_      (),
      stockVol_      (),
      residualVol_   (),
      cumShipVol_    (),
      nonSubVol_     (),
a44 7
WitBoolean WitPostprocessor::feasible ()
   {
   return (maxViolation_ <= FEAS_TOL);
   }

//------------------------------------------------------------------------------

d50 7
a56 2
   WitDemand *    theDemand;
   WitComponent * theComp;
d66 4
a69 1
   allocateScheds ();
a70 1
   forEachDemand (theDemand, myProblem ())
d72 1
d74 2
a75 1
   compNonSubVols ();
d77 4
a80 2
   compConsVols ();
   compProdVols ();
d82 2
a83 5
   if (myProblem ()->currentVariant ()->compsSecScheds ())
      importSecScheds ();
   else
      {
      compCapacityScrapVols ();
d85 1
a85 1
      compMaterialStockScrapVols ();
d87 2
a88 1
      compCumShipVols ();
a90 2
   compResidualVols ();

a92 5
   forEachEl (theComp, myCompMgr ()->allComponents ())
      theComp->importPostprocResults ();

   clearScheds ();

a121 26
void WitPostprocessor::allocateScheds ()
   {
   consVol_    .allocate (myProblem (), 0.0);
   prodVol_    .allocate (myProblem (), 0.0);
   scrapVol_   .allocate (myProblem (), 0.0);
   stockVol_   .allocate (myProblem (), 0.0);
   residualVol_.allocate (myProblem (), 0.0);
   cumShipVol_ .allocate (myProblem (), 0.0);
   nonSubVol_  .allocate (myProblem (), 0.0);
   }

//------------------------------------------------------------------------------

void WitPostprocessor::clearScheds ()
   {
   consVol_    .clear ();
   prodVol_    .clear ();
   scrapVol_   .clear ();
   stockVol_   .clear ();
   residualVol_.clear ();
   cumShipVol_ .clear ();
   nonSubVol_  .clear ();
   }

//------------------------------------------------------------------------------

a144 241
void WitPostprocessor::compNonSubVols ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitPeriod     thePer;

   forEachBomEntry (theBomEnt, myProblem ())
      {
      theBomEnt->myOperation ()->execVol ().
         copyIntoTVec (nonSubVol_ (theBomEnt));

      forEachEl (theSub, theBomEnt->mySubEntries ())
         forEachPeriod (thePer, myProblem ())
            if (theSub->inEffect (thePer))
               nonSubVol_ (theBomEnt)[thePer] -= theSub->subVol ()[thePer];
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compConsVols ()
   {
   WitPart *        thePart;
   WitBomEntry *    theBomEnt;
   WitSubEntry *    theSub;
   WitTVec <double> theConsVol (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      theConsVol.setToScalar (0.0);

      forEachEl (theBomEnt, thePart->consumingBomEntries ())
         theBomEnt->incConsVol (theConsVol, nonSubVol_ (theBomEnt));

      forEachEl (theSub,    thePart->consumingSubEntries ())
         theSub   ->incConsVol (theConsVol, theSub->subVol ());

      copyInto (consVol_ (thePart), theConsVol);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compProdVols ()
   {
   WitPart *        thePart;
   WitBopEntry *    theBopEnt;
   WitPeriod        t;
   WitTVec <double> theProdVol (myProblem (), 0.0);

   forEachPart (thePart, myProblem ())
      {
      theProdVol.setToScalar (0.0);

      forEachEl (theBopEnt, thePart->producingBopEntries ())
         forEachPeriod (t, myProblem ())
            if (theBopEnt->inEffect (t))
               theProdVol[theBopEnt->impactPeriod ()[t]] +=
                  theBopEnt->effProdRate ()[t] *
                  theBopEnt->myOperation ()->execVol ()[t];

      copyInto (prodVol_ (thePart), theProdVol);
      }
   }

//------------------------------------------------------------------------------

void WitPostprocessor::importSecScheds ()
   {
   WitPart *     thePart;
   WitMaterial * theMat;
   WitDemand *   theDemand;

   witAssert (myProblem ()->currentVariant ()->compsSecScheds ());

   forEachPart (thePart, myProblem ())
      thePart->scrapVol ().copyIntoTVec (scrapVol_ (thePart));

   forEachMaterial (theMat, myProblem ())
      stockVol_ (theMat).copy (theMat->stockVol ());

   forEachDemand (theDemand, myProblem ())
      theDemand->cumShipVol ().copyIntoTVec (cumShipVol_ (theDemand));
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compCapacityScrapVols ()
   {
   WitPart * thePart;
   WitPeriod thePer;

   forEachPart (thePart, this)
      if (thePart->isaCapacity ())
         forEachPeriod (thePer, myProblem ())
            scrapVol_ (thePart, thePer) = unstockedScrapVol (thePart, thePer);
   }

//------------------------------------------------------------------------------
// compMaterialStockScrapVols.
// Computes scrapVol and stockVol.
// This is done by rolling the inventory forward in time, allocating as much of
// it as possible to stock and scrapping the rest. Then rollBackScrap is
// applied. Lower bounds on stock are respected to the extent possible given
// the production and shipment schedules. Upper bounds on stock are respected
// if appropriate for the currentVariant. If the solution implies a negative
// stockVol or scrapVol (due to a numerical problem or a genuine constraint
// violation), the negative value is assigned to the scrapVol rather than the
// stockVol.
//------------------------------------------------------------------------------

void WitPostprocessor::compMaterialStockScrapVols ()
   {
   WitMaterial * theMat;
   WitPeriod     t;
   double        invT;      // Rolling inventory in period t.
   double        stockVolT; // stockVol[t].

   WitTVec <double> theStockVol (myProblem (), 0.0);
   WitTVec <double> theScrapVol (myProblem (), 0.0);

   forEachMaterial (theMat, myProblem ())
      {
      forEachPeriod (t, myProblem ())
         {
         invT = unstockedScrapVol (theMat, t);

         if (t > 0)
            invT += theStockVol[t-1];

         stockVolT = invT;

         if (! theMat->canStock (t))
            stockVolT = 0.0;

         if (myProblem ()->currentVariant ()->respectsAllBounds ())
            if (theMat->stockBounds ()->hardUBIsFinite (t))
               setToMin (
                  stockVolT,
                  (double) theMat->stockBounds ()->hardUB ()[t]);

         if (stockVolT < 0.0)
             stockVolT = 0.0;

         theStockVol[t] = stockVolT;
         theScrapVol[t] = invT - stockVolT;
         }

      theMat->rollBackScrap (theStockVol, theScrapVol);

      copyInto (stockVol_ (theMat), theStockVol);
      copyInto (scrapVol_ (theMat), theScrapVol);
      }
   }

//------------------------------------------------------------------------------

double WitPostprocessor::unstockedScrapVol (WitPart * thePart, WitPeriod thePer)
   {
   WitDemand * theDemand;
   double      theVol;

   theVol =
        thePart->supplyVol ()[thePer]

      + prodVol_ (thePart, thePer)
      - consVol_ (thePart, thePer);

   forEachEl (theDemand, thePart->myDemands ())
      theVol -= theDemand->shipVol ()[thePer];

   return theVol;
   }

//------------------------------------------------------------------------------

void WitPostprocessor::compCumShipVols ()
   {
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;

   forEachDemand (theDemand, myProblem ())
      if (theDemand->shipVol () == 0.0)
         cumShipVol_ (theDemand).setToScalar (0.0);
      else
         {
         cumSum = 0.0;

         forEachPeriod (thePer, myProblem ())
            {
            cumSum += theDemand->shipVol ()[thePer];

            cumShipVol_ (theDemand, thePer) = cumSum;
            }
         }
   }

//------------------------------------------------------------------------------
// compResidualVols.
// Computes the residualVols as follows:
// Create a temporary usedStockVol, the portion of stockVol that is used by the
//    solution and let residualVol be the corresponding scrapVol.
// Let usedStockVol and residualVol reflect the following scrapping policy:
// * Any stock in the last period in excess of the softLB on stock is scrapped.
// * All scrapping is done in the earliest possible period.
//------------------------------------------------------------------------------

void WitPostprocessor::compResidualVols ()
   {
   WitMaterial * theMat;
   double        unusedFinalStock;
   WitPeriod     lastPer;

   WitTVec <double> theResidualVol (myProblem (), 0.0);
   WitTVec <double> usedStockVol   (myProblem (), 0.0);

   lastPer = lastPeriod ();

   forEachMaterial (theMat, myProblem ())
      {
      copyInto (usedStockVol,   stockVol_ (theMat));
      copyInto (theResidualVol, scrapVol_ (theMat));

      unusedFinalStock =
         usedStockVol[lastPer] - theMat->stockBounds ()->softLB ()[lastPer];

      if (unusedFinalStock > FLOAT_EPSILON)
         {
         usedStockVol  [lastPer] -= unusedFinalStock;
         theResidualVol[lastPer] += unusedFinalStock;
         }

      theMat->rollBackScrap (usedStockVol, theResidualVol);

      copyInto (residualVol_ (theMat), theResidualVol);
      }
   }

//------------------------------------------------------------------------------

d165 2
d169 1
a169 1
         if (! feasible ())
d190 1
a190 1
         if (recordViolation (- scrapVol_ (thePart, thePer)))
d202 1
a202 1
         if (recordViolation (- stockVol_ (theMat, thePer)))
d212 1
a212 1
            if (recordViolation (stockVol_ (theMat, thePer)))
d241 1
a241 1
            if (recordViolation (- nonSubVol_ (theBomEnt, thePer)))
d260 1
a260 1
               cumShipVol_ (theDemand,    thePer) -
@


1.13
log
@Preliminary work on single source.
@
text
@d32 7
a38 1
      myAccFlag_     (new WitAccFlag),
d48 7
a54 1
   delete myAccFlag_;
d64 2
a65 3
   WitDemand * theDemand;
   double      cumSum;
   WitPeriod   thePer;
d75 2
d78 1
a78 1
      copyInto (fssShipVol (theDemand), theDemand->shipVol ());
d85 3
a87 1
   if (! myProblem ()->currentVariant ()->compsSecScheds ())
d93 2
a94 6
      forEachDemand (theDemand, myProblem ())
         if (theDemand->shipVol () == 0.0)
            cumShipVol (theDemand).setToScalar (0.0);
         else
            {
            cumSum = 0.0;
d96 1
a96 3
            forEachPeriod (thePer, myProblem ())
               {
               cumSum += theDemand->shipVol ()[thePer];
d98 1
a98 4
               cumShipVol (theDemand).elemRef (thePer) = cumSum;
               }
            }
      }
d100 2
a101 1
   compResidualVols ();
d103 1
a103 1
   compFeasible ();
d119 3
a121 2
   maxViolation_              = 0.0;
   feasible (myGlobalComp ()) = witFALSE;
d134 27
a160 1
WitBoolean WitPostprocessor::solnIsNonnegative () const
d183 1
a183 1
void WitPostprocessor::compNonSubVols () const
d185 3
a187 4
   WitBomEntry *    theBomEnt;
   WitTVec <double> theNonSubVol (myProblem (), 0.0);
   WitSubEntry *    theSub;
   WitPeriod        thePer;
d191 2
a192 4
      if (theBomEnt->mySubEntries ().isEmpty ())
         continue;

      theBomEnt->myOperation ()->execVol ().copyIntoTVec (theNonSubVol);
d197 1
a197 3
               theNonSubVol[thePer] -= theSub->subVol ()[thePer];

      nonSubVol (theBomEnt).copyTVec (theNonSubVol);
d203 1
a203 1
void WitPostprocessor::compConsVols () const
d215 1
a215 1
         theBomEnt->incConsVol (theConsVol, theBomEnt->nonSubVol ());
d217 2
a218 2
      forEachEl (theSub,      thePart->consumingSubEntries ())
         theSub   ->incConsVol (theConsVol, theSub    ->subVol ());
d220 1
a220 1
      copyInto (consVol (thePart), theConsVol);
d226 1
a226 1
void WitPostprocessor::compProdVols () const
d244 1
a244 1
      copyInto (prodVol (thePart), theProdVol);
d250 1
a250 1
void WitPostprocessor::compCapacityScrapVols () const
d252 22
a273 3
   WitPart *       thePart;
   WitPeriod       thePer;
   WitTVec <float> theScrapVol (myProblem (), 0.0);
a276 1
         {
d278 1
a278 4
            theScrapVol[thePer] = unstockedScrapVol (thePart, thePer);

         scrapVol (thePart).copyTVec (theScrapVol);
         }
d294 1
a294 1
void WitPostprocessor::compMaterialStockScrapVols () const
d333 2
a334 2
      copyInto (stockVol (theMat), theStockVol);
      copyInto (scrapVol (theMat), theScrapVol);
d340 1
a340 4
double WitPostprocessor::unstockedScrapVol (
      WitPart * thePart,
      WitPeriod thePer)
      const
d347 3
a349 2
      + thePart->prodVol   ()[thePer]
      - thePart->consVol   ()[thePer];
d358 24
d391 1
a391 1
void WitPostprocessor::compResidualVols () const
d404 2
a405 2
      copyInto (usedStockVol,   theMat->stockVol ());
      copyInto (theResidualVol, theMat->scrapVol ());
d418 1
a418 1
      copyInto (residualVol (theMat), theResidualVol);
d424 1
a424 1
void WitPostprocessor::compFeasible ()
a425 2
   float feasTol = 0.001;

a443 2
   feasible (myGlobalComp ()) = (maxViolation_ <= feasTol);

d446 1
a446 1
         if (! myGlobalComp ()->feasible ())
d463 1
a463 1
   WitPeriod      t;
d466 2
a467 2
      forEachPeriod (t, myProblem ())
         if (recordViolation (- thePart->scrapVol ()[t]))
d473 1
a473 1
            myMsgFac () ("maxViolPeriodMsg", t);
d477 1
a477 1
      forEachPeriod (t, myProblem ())
d479 1
a479 1
         if (recordViolation (- theMat->stockVol ()[t]))
d485 1
a485 1
            myMsgFac () ("maxViolPeriodMsg", t);
d488 2
a489 2
         if (! theMat->canStock (t))
            if (recordViolation (theMat->stockVol ()[t]))
d497 1
a497 1
               myMsgFac () ("maxViolPeriodMsg", t);
d502 3
a504 3
      forEachPeriod (t, myProblem ())
         if (! theOpn->executable ()[t])
            if (recordViolation (theOpn->execVol ()[t]))
d512 1
a512 1
               myMsgFac () ("maxViolPeriodMsg", t);
d517 2
a518 2
         forEachPeriod (t, myProblem ())
            if (recordViolation (- theBomEnt->nonSubVol()[t]))
d530 1
a530 1
               myMsgFac () ("maxViolPeriodMsg", t);
d534 1
a534 1
      forEachPeriod (t, myProblem ())
d537 2
a538 2
               theDemand->cumShipVol   ()[t] -
               theDemand->cumDemandVol ()[t]))
d550 1
a550 1
            myMsgFac () ("maxViolPeriodMsg", t);
d695 1
a695 1
void WitPostprocessor::displayViolConstraint (WitMsgFragID theFragID) const
@


1.12
log
@Continued preliminary work on single source.
@
text
@d80 1
a80 1
            cumShipVol (theDemand) = 0.0;
d161 1
a161 1
      theBomEnt->myOperation ()->execVol ().copySelfInto (theNonSubVol);
d168 1
a168 1
      nonSubVol (theBomEnt) = theNonSubVol;
d183 1
a183 1
      theConsVol.setTo (0.0);
d206 1
a206 1
      theProdVol.setTo (0.0);
d233 1
a233 1
         scrapVol (thePart) = theScrapVol;
@


1.11
log
@Continued preliminary work on single source.
@
text
@d16 3
@


1.10
log
@Began implementation of object iteration.
@
text
@d149 1
a149 1
   WitTVec (double) theNonSubVol (myProblem (), 0.0);
d176 1
a176 1
   WitTVec (double) theConsVol (myProblem (), 0.0);
d180 1
a180 1
      theConsVol = 0.0;
d199 1
a199 1
   WitTVec (double) theProdVol (myProblem (), 0.0);
d203 1
a203 1
      theProdVol = 0.0;
d222 1
a222 1
   WitTVec (float) theScrapVol (myProblem (), 0.0);
d254 2
a255 2
   WitTVec (double) theStockVol (myProblem (), 0.0);
   WitTVec (double) theScrapVol (myProblem (), 0.0);
d328 2
a329 2
   WitTVec (double) theResidualVol (myProblem (), 0.0);
   WitTVec (double) usedStockVol   (myProblem (), 0.0);
@


1.9
log
@Continued implementation of sel-split for pen-exec.
@
text
@d21 1
@


1.8
log
@Continued development of Selective Stock Reallocation.
@
text
@d58 1
a58 3
   if (DEBUG_MODE)
      if (! solnIsNonnegative ())
         myMsgFac () ("internalErrorFmsg", "WitPostprocessor::postprocess");
@


1.7
log
@Initial implementation of pegging.
@
text
@d221 1
a221 1
   WitCapacity *   theCap;
d225 5
a229 4
   forEachCapacity (theCap, myProblem ())
      {
      forEachPeriod (thePer, myProblem ())
         theScrapVol[thePer] = unstockedScrapVol (theCap, thePer);
d231 2
a232 2
      scrapVol (theCap) = theScrapVol;
      }
@


1.6
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d18 1
a18 1
#include <HeurAll.h>
d52 1
a52 1
   myProblem ()->myHeurAllocator ()->reset ();
@


1.5
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d63 1
a63 1
      copyTo (fssShipVol (theDemand), theDemand->shipVol ());
d159 1
a159 1
      theBomEnt->myOperation ()->execVol ().copyInto (theNonSubVol);
d189 1
a189 1
      copyTo (consVol (thePart), theConsVol);
d213 1
a213 1
      copyTo (prodVol (thePart), theProdVol);
d286 2
a287 2
      copyTo (stockVol (theMat), theStockVol);
      copyTo (scrapVol (theMat), theScrapVol);
d335 2
a336 2
      copyTo (usedStockVol,   theMat->stockVol ());
      copyTo (theResidualVol, theMat->scrapVol ());
d349 1
a349 1
      copyTo (residualVol (theMat), theResidualVol);
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d63 1
a63 1
      fssShipVol (theDemand) = theDemand->shipVol ();
d149 4
a152 4
   WitBomEntry * theBomEnt;
   WitPeriod     t;
   WitSubEntry * theSub;
   double        theNonSubVolT;
d155 5
a159 4
      if (! theBomEnt->mySubEntries ().isEmpty ())
         forEachPeriod (t, myProblem ())
            {
            theNonSubVolT = theBomEnt->myOperation ()->execVol ()[t];
d161 4
a164 3
            forEachEl (theSub, theBomEnt->mySubEntries ())
               if (theSub->inEffect (t))
                  theNonSubVolT -= theSub->subVol ()[t];
d166 2
a167 2
            nonSubVol (theBomEnt)[t] = theNonSubVolT;
            }
d189 1
a189 1
      copy (consVol (thePart), theConsVol);
d213 1
a213 1
      copy (prodVol (thePart), theProdVol);
d286 2
a287 2
      copy (stockVol (theMat), theStockVol);
      copy (scrapVol (theMat), theScrapVol);
d335 2
a336 2
      copy (usedStockVol,   theMat->stockVol ());
      copy (theResidualVol, theMat->scrapVol ());
d349 1
a349 1
      copy (residualVol (theMat), theResidualVol);
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d271 1
a271 1
               WitUtil::setToMin (
d324 1
a324 1
   WitPeriod     tLast;
d329 1
a329 1
   tLast = myProblem ()->lPeriod ();
d337 1
a337 1
         usedStockVol[tLast] - theMat->stockBounds ()->softLB ()[tLast];
d341 2
a342 2
         usedStockVol  [tLast] -= unusedFinalStock;
         theResidualVol[tLast] += unusedFinalStock;
d589 1
a589 1
         theViolation = WitUtil::min (upDelta, - downDelta);
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d271 1
a271 1
               WitUtil::updateToMin (
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.167;
access;
symbols
	sce_5_01_20080919:1.153
	latest_sce_4_20_20060523:1.105.0.2
	sce_4_20_20060523:1.105
	latest_sce4_20_OSL:1.104.0.2
	sce_4_20_OSL:1.104
	sce_410_withVa:1.99
	sce_4_05_20040511:1.86
	sce_4_00_20040201:1.57
	nextGenBranch:1.35.0.2
	nextGenRoot:1.35
	sce_3_30_20030627:1.35
	EndRw-branch:1.31.0.4
	Root-of-EndRw:1.31
	rwToStl:1.31.0.2
	latest_sce_3_10_20010924:1.20.0.2
	sce_3_10_20010924:1.20
	latest_sce_3_00_20010601:1.11.0.4
	sce_3_00_20010601:1.11
	latest_sce_2_31_20010308:1.11.0.2
	sce_2_31_20010308:1.11
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.167
date	2011.09.28.23.50.45;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2011.09.24.00.29.01;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2011.08.30.20.18.26;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2010.09.24.15.46.16;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2010.09.22.20.21.54;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2010.09.21.21.19.13;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2010.09.10.22.10.43;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2010.09.07.21.14.15;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2010.06.17.22.04.45;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2010.06.16.20.56.30;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2010.03.16.22.42.29;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2009.11.13.19.01.27;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2009.02.04.23.11.40;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2008.11.12.19.52.26;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2008.02.25.22.35.11;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2008.02.25.19.37.58;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2007.11.29.19.18.04;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2007.10.15.21.50.36;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2007.10.11.19.16.58;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2007.08.01.22.41.59;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2007.06.15.17.44.36;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2007.06.14.21.38.32;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2007.05.21.15.20.11;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2007.05.04.17.44.58;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2007.05.03.22.05.29;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2007.05.03.19.36.17;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2007.04.25.23.30.30;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2007.04.25.20.39.59;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2007.04.16.17.53.22;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2007.04.04.22.08.19;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2007.04.04.20.04.40;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2007.04.04.16.16.02;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2007.04.02.23.01.16;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2007.04.02.21.21.20;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2007.03.08.17.02.56;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2007.03.02.22.22.36;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2007.03.02.22.11.03;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2007.02.28.23.09.07;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2007.02.28.22.15.49;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2007.02.27.19.59.33;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2007.02.08.22.47.36;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2007.01.29.23.12.43;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2007.01.16.16.53.45;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2007.01.16.00.25.06;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2007.01.15.23.06.08;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2007.01.15.22.25.31;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2006.12.27.22.45.41;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2006.11.20.17.04.53;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2006.11.17.17.22.01;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2006.11.17.16.57.48;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2006.11.14.23.10.27;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2006.11.02.23.07.14;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2006.10.12.20.48.12;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2006.09.27.22.28.16;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2006.09.27.20.10.18;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2006.08.24.20.50.27;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2006.08.22.21.26.55;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2006.08.17.22.50.39;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2006.08.16.21.57.13;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2006.08.16.15.49.19;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2006.08.09.18.36.41;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2006.08.08.18.31.21;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2006.05.02.17.34.16;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2006.03.08.23.57.12;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2006.02.03.16.48.13;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2005.12.05.22.24.10;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2005.09.13.19.38.08;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2005.09.12.22.17.33;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2005.09.01.21.45.04;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2005.08.24.18.24.24;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2005.08.23.19.45.20;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2005.08.19.21.38.04;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2005.08.12.19.35.30;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2005.07.13.21.18.47;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2005.06.13.16.48.48;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2005.03.21.21.49.27;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2005.03.04.00.00.29;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2005.02.24.23.23.58;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2005.02.08.20.36.19;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2005.01.28.19.34.28;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2004.05.12.19.43.31;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2004.05.05.15.43.59;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2004.04.09.19.37.58;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.06.18.55.59;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2004.04.06.18.16.58;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2004.04.06.15.42.17;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2004.04.05.23.04.57;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2004.04.05.22.18.08;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.04.02.20.54.17;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.04.01.21.05.13;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.03.30.00.05.33;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.03.29.22.25.14;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.03.27.00.08.20;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.03.26.22.29.41;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.25.22.00.37;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.25.21.21.59;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.25.20.35.03;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.25.19.59.38;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.03.03.22.36.22;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.02.26.18.59.43;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.02.24.21.32.06;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.02.24.19.37.23;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.02.20.22.46.03;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.20.15.37.36;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.02.12.19.13.41;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.02.06.21.03.05;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.06.00.17.34;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.16.18.48.26;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.31.21.44.54;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.31.20.09.19;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.30.18.52.17;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.29.19.13.43;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.24.23.25.56;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.24.21.09.47;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.12.23.17.56.21;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.23.16.18.48;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.19.19.01.02;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.17.22.30.00;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.17.21.23.00;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.15.19.35.59;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.12.19.49.45;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.11.21.56.33;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.10.23.45.57;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.10.23.20.43;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.04.16.45.16;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.11.18.29.15;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.31.16.10.07;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.31.15.37.55;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.22.23.13.52;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.19.16.48.30;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.27.23.26.14;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.02.23.40.54;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.02.22.18.57;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.12.20.09.40;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.11.22.48.31;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.09.20.49.51;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.17.21.45.08;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.08.19.21.58;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.07.20.15.06;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.03.23.16.44;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.25.19.14.55;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.24.18.26.12;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.22.14.32.16;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.18.14.02.48;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.31.00.26.26;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.06.17.31.10;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.03.18.40.44;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.01.14.55.32;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.30.15.12.13;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.28.00.48.37;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.27.21.28.41;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.25.16.08.22;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.03.20.07.32;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.26.21.46.03;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.15.19.01.53;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.28.22.13.40;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.22.16.18.28;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.05.19.05.33;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.04.22.07.40;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.29;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.12.37;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.29;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.18;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.33;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.33;	author wit;	state Exp;
branches;
next	;


desc
@@


1.167
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "demApi.C"
//
// Inner API functions relating to Demands.
//------------------------------------------------------------------------------

#include <WitRun.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <ApiCall.h>
#include <ISRealArg.h>
#include <OSRealArg.h>
#include <IVRealArg.h>
#include <OVRealArg.h>
#include <EqAll.h>
#include <HeurAllMgr.h>
#include <PegEl.h>
#include <PipMgr.h>
#include <DetOptImpMgr.h>
#include <ExtOptMgr.h>
#include <GlobalComp.h>
#include <Part.h>
#include <Demand.h>
#include <Operation.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <BoundSet.h>
#include <ObjStack.h>
#include <PairStack.h>
#include <TripStack.h>
#include <MsgFrag.h>
#include <MsgFac.h>

#include <stdlib.h>

//------------------------------------------------------------------------------
// setGetDemandInit
// Initilization of wit[S|G]etDemand* functions.
//------------------------------------------------------------------------------

WitDemand * WitRun::setGetDemandInit (
      const char *  partName,
      const char *  demandName)
   {
   forbidNullArg (partName,   "demandedPartName");
   forbidNullArg (demandName, "demandName");

   if (myMsgFac ().mayIssue ("partNameMsg"))
      myMsgFac () ("partNameMsg", partName);

   if (myMsgFac ().mayIssue ("demandNameMsg"))
      myMsgFac () ("demandNameMsg", demandName);

   return getDemandP (partName, demandName);
   }

//------------------------------------------------------------------------------

void WitRun::witAddDemand (
      const char * partName,
      const char * demandName)
   {
   WitPart * thePart;

   myApiMgr_->startInnerFunc ();

   forbidNullArg (partName,   "partName");
   forbidNullArg (demandName, "demandName");

   if (myMsgFac ().mayIssue ("demandNameAdMsg"))
      myMsgFac () ("demandNameAdMsg", partName, demandName);

   thePart = myCompMgr ()->findPart (partName);

   if (thePart == NULL)
      myMsgFac () ("undefinedPartMsg", partName);

   myInputID ()->setMyPart (thePart);

   if (isNullCstring (demandName))
      myMsgFac () ("nullStringSmsg", "demandName");

   if (myCompMgr ()->findDemand (thePart, demandName) != NULL)
      myMsgFac () ("duplicateDemNameAdMsg", demandName);

   addingDelComp ("demandFrag");

   new WitDemand (demandName, thePart);

   myInputID ()->setMyPart (NULL);
   }

//------------------------------------------------------------------------------
// witAppendToPipSeq
// Append a shipment triple to the end of the PIP shipment sequence.
//------------------------------------------------------------------------------

void WitRun::witAppendToPipSeq (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      const WitISRealArg & incShipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   if (myMsgFac ().mayIssue ("shipPerMsg"))
      myMsgFac () ("shipPerMsg", shipPeriod);

   if (myMsgFac ().mayIssue ("incShipVolMsg"))
      myMsgFac () ("incShipVolMsg", incShipVol);

   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputID ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }

   if (not (incShipVol.asaDbl () >= 0.0))
      {
      myInputID ()->setArgName ("incShipVol");

      myMsgFac () ("argRangeValGeDblSmsg", incShipVol, 0.0);
      }

   myProblem ()->
      myPipMgr ()->
         appendToShipSeq (theCall.myDemand (), shipPeriod, incShipVol);
   }

//------------------------------------------------------------------------------

void WitRun::witCopyDemandData (
      const char * dupPartName,
      const char * dupDemandName,
      WitRun *     origWitRun,
      const char * origPartName,
      const char * origDemandName)
   {
   startCopyObjData (origWitRun);

   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("demandFrag"));

   WitDemandApiCall  dupCall (this,        dupPartName,  dupDemandName);

   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("demandFrag"));

   WitDemandApiCall origCall (origWitRun, origPartName, origDemandName);

   if (dupCall.myDemand () == origCall.myDemand ())
      myMsgFac () ("copyObjectToSelfSmsg",
         myMsgFac ().myFrag ("demandFrag"));

   dupCall.myDemand ()->copyAttrsFrom (origCall.myDemand ());
   }

//------------------------------------------------------------------------------
// witEqHeurAlloc
// API function to equitably increment heuristic allocation.
//------------------------------------------------------------------------------

void WitRun::witEqHeurAlloc (
      int                  lenLists,
      const char * const * partNameList,
      const char * const * demandNameList,
      const int *          shipPeriodList,
      const WitIVRealArg & desIncVolList,
      const WitOVRealArg & incVolList)
   {
   myApiMgr_->startInnerFunc ();

   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("wrongFuncForTwmeSmsg",
         "witEqHeurAlloc",
         true,
         "witEqHeurAllocTwme");

   eqHeurAlloc (
      lenLists,
      partNameList,
      demandNameList,
      shipPeriodList,
      desIncVolList,
      incVolList,
      NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witEqHeurAllocTwme (
      int                  lenLists,
      const char * const * partNameList,
      const char * const * demandNameList,
      const int *          shipPeriodList,
      const WitIVRealArg & desIncVolList,
      const WitOVRealArg & incVolList,
      const WitBoolean *   asapMultiExecList)
   {
   myApiMgr_->startInnerFunc ();

   if (not myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("wrongFuncForTwmeSmsg",
         "witEqHeurAllocTwme",
         false,
         "witEqHeurAlloc");


   eqHeurAlloc (
      lenLists,
      partNameList,
      demandNameList,
      shipPeriodList,
      desIncVolList,
      incVolList,
      asapMultiExecList);
   }

//------------------------------------------------------------------------------

void WitRun::witGetObjItrDemand (
      char * * partName,
      char * * demandName)
   {
   WitDemand * theDemand;

   myApiMgr_->startInnerFunc ();

   theDemand =
      curItrDelCompForGet (WitAT_DEMAND, "demandFrag")->
         thisDemand ();

   stronglyAssert (theDemand != NULL);

   apiGet (partName,   "partName",   theDemand->demandedPartName ());
   apiGet (demandName, "demandName", theDemand->demandName ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandAppData (
      const char * partName,
      const char * demandName,
      void * *    appData)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (appData, "appData", theCall.myDemand ()->appData ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandBuildAheadUB (
      const char * partName,
      const char * demandName,
      int * *      buildAheadUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (buildAheadUB, "buildAheadUB", theCall.myDemand ()->buildAheadUB ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandBuildAheadLimit (
      const char * partName,
      const char * demandName,
      int *        buildAheadLimit)
   {
   int * buildAheadUBval;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "demand",
         "buildAheadLimit",
         "buildAheadUB");

   witGetDemandBuildAheadUB (partName, demandName, & buildAheadUBval);

   forbidNullArg (buildAheadLimit, "buildAheadLimit");

   * buildAheadLimit = buildAheadUBval[0];

   free (buildAheadUBval);
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandCoExecVolPip (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              bopEntryIndexList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedVolList)
   {
   WitBopEntTripStack coExecVolTrips (myProblem ());
   int                nTrips;
   int                theIdx;
   WitBopEntry *      theBopEnt;
   WitPeriod          execPer;
   double             pgdCoExecVol;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getCoExecVolTrips (theCall.myDemand (), shipPeriod, coExecVolTrips);

   nTrips = coExecVolTrips.nElements ();

   apiGet (lenLists, "lenLists", nTrips);

   forbidNullArg (operationNameList, "operationNameList");
   forbidNullArg (bopEntryIndexList, "bopEntryIndexList");
   forbidNullArg (execPeriodList,    "execPeriodList");
   forbidNullArg (peggedVolList,     "peggedVolList");

   apiAlloc (operationNameList, nTrips);
   apiAlloc (bopEntryIndexList, nTrips);
   apiAlloc (execPeriodList,    nTrips);
   apiAlloc (peggedVolList,     nTrips);

   theIdx = -1;

   while (coExecVolTrips.pop (theBopEnt, execPer, pgdCoExecVol))
      {
      theIdx ++;

      (* operationNameList)[theIdx] = 
         theBopEnt->myOperationName ().apiDupCstring ();

      (* bopEntryIndexList)[theIdx] = theBopEnt->localIndex ();
      (* execPeriodList)   [theIdx] = execPer;
      peggedVolList        [theIdx] = pgdCoExecVol;
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandConsVolPip (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   WitPartTripStack thePegTrips (myProblem ());

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getConsVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

   getPartPip (
      thePegTrips,
      lenLists,
      partNameList,
      periodList,
      peggedVolList);
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandCumShipBounds (
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & hardLB,
      const WitOVRealArg & softLB,
      const WitOVRealArg & hardUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (hardLB, softLB, hardUB, theCall.myDemand ()->cumShipBounds ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandCumShipReward (
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & cumShipReward)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
       cumShipReward,
      "cumShipReward",
      theCall.myDemand ()->cumShipReward ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandCumShipSlbConIndex (
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        cumShipSlbConIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       cumShipSlbConIndex,
      "cumShipSlbConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            cumShipSlbConIndex (theCall.myDemand (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandCumShipSlbvVarIndex (
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        cumShipSlbvVarIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       cumShipSlbvVarIndex,
      "cumShipSlbvVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            cumShipSlbvVarIndex (theCall.myDemand (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandCumShipVarIndex (
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        cumShipVarIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       cumShipVarIndex,
      "cumShipVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            cumShipVarIndex (theCall.myDemand (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandDemandVol (
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & demandVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (demandVol, "demandVol", theCall.myDemand ()->demandVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandExecVolPegging (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedExecVolList)
   {
   WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());
   WitObjStItr <WitFixedPegEl> theItr;
   int                         nOpnPegEls;
   int                         theIdx;
   WitFixedPegEl *             theFixedPegEl;
   WitOperation *              theOpn;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPegging (shipPeriod);

   theCall.myDemand ()->getMyFixedPegEls (shipPeriod, theFixedPegEls);

   nOpnPegEls = 0;

   theFixedPegEls.attachItr (theItr);

   while (theItr.advance (theFixedPegEl))
      if (theFixedPegEl->myOpn () != NULL)
         nOpnPegEls ++;

   apiGet (lenLists, "lenLists", nOpnPegEls);

   forbidNullArg (operationNameList, "operationNameList");
   forbidNullArg (execPeriodList,    "execPeriodList");
   forbidNullArg (peggedExecVolList, "peggedExecVolList");

   apiAlloc (operationNameList, nOpnPegEls);
   apiAlloc (execPeriodList,    nOpnPegEls);
   apiAlloc (peggedExecVolList, nOpnPegEls);

   theIdx = 0;

   while (theFixedPegEls.pop (theFixedPegEl))
      {
      theOpn = theFixedPegEl->myOpn ();

      if (theOpn == NULL)
         continue;

      (* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();

      (* execPeriodList)   [theIdx] = theFixedPegEl->myExecPer ();

      peggedExecVolList    [theIdx] = theFixedPegEl->peggedVol ();

      theIdx ++;
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandExecVolPip (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedVolList)
   {
   WitOpnTripStack execVolTrips (myProblem ());
   int             nTrips;
   int             theIdx;
   WitOperation *  theOpn;
   WitPeriod       execPer;
   double          pgdExecVol;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getExecVolTrips (theCall.myDemand (), shipPeriod, execVolTrips);

   nTrips = execVolTrips.nElements ();

   apiGet (lenLists, "lenLists", nTrips);

   forbidNullArg (operationNameList, "operationNameList");
   forbidNullArg (execPeriodList,    "execPeriodList");
   forbidNullArg (peggedVolList,     "peggedVolList");

   apiAlloc (operationNameList, nTrips);
   apiAlloc (execPeriodList,    nTrips);
   apiAlloc (peggedVolList,     nTrips);

   theIdx = -1;

   while (execVolTrips.pop (theOpn, execPer, pgdExecVol))
      {
      theIdx ++;

      (* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();

      (* execPeriodList)   [theIdx] = execPer;

      peggedVolList        [theIdx] = pgdExecVol;
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandFocusHorizon (
      const char * partName,
      const char * demandName,
      int *        focusHorizon)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (focusHorizon, "focusHorizon", theCall.myDemand ()->focusHorizon ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandFssShipVol (
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & fssShipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (fssShipVol, "fssShipVol", theCall.myDemand ()->fssShipVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandIntShipVols (
      const char * partName,
      const char * demandName,
      WitBoolean * intShipVols)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      intShipVols, 
      "intShipVols", 
      theCall.myDemand ()->intShipVols ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandLeadTimeUB (
      const char * partName,
      const char * demandName,
      int * *      leadTimeUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (leadTimeUB, "leadTimeUB", theCall.myDemand ()->leadTimeUB ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandObj1CumShipReward (
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & obj1CumShipReward)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "demand",
         "obj1CumShipReward",
         "cumShipReward");

   witGetDemandCumShipReward (
      partName,
      demandName,
      obj1CumShipReward);
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandObj1ShipReward (
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & obj1ShipReward)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "demand",
         "obj1ShipReward",
         "shipReward");

   witGetDemandShipReward (
      partName,
      demandName,
      obj1ShipReward);
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandPrefBuildAhead (
      const char * partName,
      const char * demandName,
      WitBoolean * prefBuildAhead)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      prefBuildAhead, 
      "prefBuildAhead", 
      theCall.myDemand ()->prefBuildAhead ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandPriority (
      const char * partName,
      const char * demandName,
      int * *      priority)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (priority, "priority", theCall.myDemand ()->priority ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandProdVolPip (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   WitPartTripStack thePegTrips (myProblem ());

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getProdVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

   getPartPip (
      thePegTrips,
      lenLists,
      partNameList,
      periodList,
      peggedVolList);
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandSearchInc (
      const char *         partName,
      const char *         demandName,
      const WitOSRealArg & searchInc)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (searchInc, "searchInc", theCall.myDemand ()->searchInc ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandSelForDel (
      const char * partName,
      const char * demandName,
      WitBoolean * selForDel)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (selForDel, "selForDel", theCall.myDemand ()->selForDel ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandShipConIndex (
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        shipConIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       shipConIndex,
      "shipConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            shipConIndex (theCall.myDemand (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandShipLateAllowed (
      const char * partName,
      const char * demandName,
      WitBoolean * shipLateAllowed)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      shipLateAllowed, 
      "shipLateAllowed", 
      theCall.myDemand ()->shipLateAllowed ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandShipLateLimit (
      const char * partName,
      const char * demandName,
      int *        shipLateLimit)
   {
   int * shipLateUBval;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "demand",
         "shipLateLimit",
         "shipLateUB");

   witGetDemandShipLateUB (partName, demandName, & shipLateUBval);

   forbidNullArg (shipLateLimit, "shipLateLimit");

   * shipLateLimit = shipLateUBval[0];

   free (shipLateUBval);
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandShipLateUB (
      const char * partName,
      const char * demandName,
      int * *      shipLateUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (shipLateUB, "shipLateUB", theCall.myDemand ()->shipLateUB ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandShipReward (
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & shipReward)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
       shipReward,
      "shipReward",
      theCall.myDemand ()->shipReward ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandShipVarIndex (
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        shipVarIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       shipVarIndex,
      "shipVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            shipVarIndex (theCall.myDemand (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandShipVol (
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & shipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (shipVol, "shipVol", theCall.myDemand ()->shipVol ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandSideVolPip (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   WitPartTripStack thePegTrips (myProblem ());

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getSideVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

   getPartPip (
      thePegTrips,
      lenLists,
      partNameList,
      periodList,
      peggedVolList);
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandSubVolPegging (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              bomEntryIndexList,
      int * *              subsBomEntryIndexList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedSubVolList)
   {
   WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());
   WitObjStItr <WitFixedPegEl> theItr;
   int                         nSubPegEls;
   int                         theIdx;
   WitFixedPegEl *             theFixedPegEl;
   WitSubEntry *               theSub;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPegging (shipPeriod);

   theCall.myDemand ()->getMyFixedPegEls (shipPeriod, theFixedPegEls);

   nSubPegEls = 0;

   theFixedPegEls.attachItr (theItr);

   while (theItr.advance (theFixedPegEl))
      if (theFixedPegEl->mySub () != NULL)
         nSubPegEls ++;

   apiGet (lenLists, "lenLists", nSubPegEls);

   forbidNullArg (operationNameList,     "operationNameList");
   forbidNullArg (bomEntryIndexList,     "bomEntryIndexList");
   forbidNullArg (subsBomEntryIndexList, "subsBomEntryIndexList");
   forbidNullArg (execPeriodList,        "execPeriodList");
   forbidNullArg (peggedSubVolList,      "peggedSubVolList");

   apiAlloc (operationNameList,     nSubPegEls);
   apiAlloc (bomEntryIndexList,     nSubPegEls);
   apiAlloc (subsBomEntryIndexList, nSubPegEls);
   apiAlloc (execPeriodList,        nSubPegEls);
   apiAlloc (peggedSubVolList,      nSubPegEls);
   
   theIdx = 0;

   while (theFixedPegEls.pop (theFixedPegEl))
      {
      theSub = theFixedPegEl->mySub ();

      if (theSub == NULL)
         continue;

      (* operationNameList)    [theIdx] = 
         theSub->myOperationName ().apiDupCstring ();

      (* bomEntryIndexList)    [theIdx] = theSub       ->myBomEntIndex ();
      (* subsBomEntryIndexList)[theIdx] = theSub       ->localIndex ();
      (* execPeriodList)       [theIdx] = theFixedPegEl->myExecPer ();
      peggedSubVolList         [theIdx] = theFixedPegEl->peggedVol ();

      theIdx ++;
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandSubVolPip (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              bomEntryIndexList,
      int * *              subsBomEntryIndexList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedVolList)
   {
   WitSubTripStack subVolTrips (myProblem ());
   int             nTrips;
   int             theIdx;
   WitSubEntry *   theSub;
   WitPeriod       execPer;
   double          pgdSubVol;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getSubVolTrips (theCall.myDemand (), shipPeriod, subVolTrips);

   nTrips = subVolTrips.nElements ();

   apiGet (lenLists, "lenLists", nTrips);

   forbidNullArg (operationNameList,     "operationNameList");
   forbidNullArg (bomEntryIndexList,     "bomEntryIndexList");
   forbidNullArg (subsBomEntryIndexList, "subsBomEntryIndexList");
   forbidNullArg (execPeriodList,        "execPeriodList");
   forbidNullArg (peggedVolList,         "peggedVolList");

   apiAlloc (operationNameList,     nTrips);
   apiAlloc (bomEntryIndexList,     nTrips);
   apiAlloc (subsBomEntryIndexList, nTrips);
   apiAlloc (execPeriodList,        nTrips);
   apiAlloc (peggedVolList,         nTrips);

   theIdx = -1;

   while (subVolTrips.pop (theSub, execPer, pgdSubVol))
      {
      theIdx ++;

      (* operationNameList)    [theIdx] = 
         theSub->myOperationName ().apiDupCstring ();

      (* bomEntryIndexList)    [theIdx] = theSub->myBomEntIndex ();
      (* subsBomEntryIndexList)[theIdx] = theSub->localIndex ();
      (* execPeriodList)       [theIdx] = execPer;
      peggedVolList            [theIdx] = pgdSubVol;
      }
   }

//------------------------------------------------------------------------------

void WitRun::witGetDemandSupplyVolPip (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   WitPartTripStack thePegTrips (myProblem ());

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getSupplyVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

   getPartPip (
      thePegTrips,
      lenLists,
      partNameList,
      periodList,
      peggedVolList);
   }

//------------------------------------------------------------------------------

void WitRun::witIncHeurAlloc (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      const WitISRealArg & desIncVol,
      const WitOSRealArg & incVol)
   {
   myApiMgr_->startInnerFunc ();

   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("wrongFuncForTwmeSmsg",
         "witIncHeurAlloc",
         true,
         "witIncHeurAllocTwme");

   incHeurAlloc (
      partName,
      demandName,
      shipPeriod,
      desIncVol,
      incVol,
      false);
   }

//------------------------------------------------------------------------------

void WitRun::witIncHeurAllocTwme (
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      const WitISRealArg & desIncVol,
      const WitOSRealArg & incVol,
      WitBoolean           asapMultiExec)
   {
   myApiMgr_->startInnerFunc ();

   if (not myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("wrongFuncForTwmeSmsg",
         "witIncHeurAllocTwme",
         false,
         "witIncHeurAlloc");

   incHeurAlloc (
      partName,
      demandName,
      shipPeriod,
      desIncVol,
      incVol,
      asapMultiExec);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandAppData (
      const char * partName,
      const char * demandName,
      void *       appData)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.setAppData (appData);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandBuildAheadUB (
      const char * partName,
      const char * demandName,
      const int *  buildAheadUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBuildAheadUB (buildAheadUB);

   if (theCall.argsOK ())
      theCall.myDemand ()->setBuildAheadUB (buildAheadUB);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandBuildAheadLimit (
      const char * partName,
      const char * demandName,
      int          buildAheadLimit)
   {
   WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "demand",
         "buildAheadLimit",
         "buildAheadUB");

   buildAheadUBVec = buildAheadLimit;

   witSetDemandBuildAheadUB (
      partName, 
      demandName, 
      buildAheadUBVec.myCVec ());

   myApiMgr ()->releaseTempVecs ();
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandCumShipBounds (
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & hardLB,
      const WitIVRealArg & softLB,
      const WitIVRealArg & hardUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.setBoundSet (
      theCall.myDemand ()->cumShipBounds (), 
      hardLB,
      softLB,
      hardUB);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandCumShipReward (
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & cumShipReward)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepDblVec ("cumShipReward", cumShipReward);

   if (theCall.argsOK ())
      theCall.myDemand ()->setCumShipReward (cumShipReward);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandDemandName (
      const char * partName,
      const char * demandName,
      const char * newName)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   forbidNullArg (newName, "newName");

   if (isNullCstring (newName))
      myMsgFac () ("nullStringSmsg", "newName");

   if (myCompMgr ()->findDemand (theCall.myDemand ()->demandedPart (), newName))
      myMsgFac () ("setDemandNameToDupSmsg", newName);

   theCall.prepString (
                          "demandName",
      theCall.myDemand ()->demandName (),
                              newName);

   if (theCall.argsOK ())
      theCall.myDemand ()->setDemandName (newName);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandDemandVol (
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & demandVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepNonNegDblVec ("demandVol", demandVol);

   if (theCall.argsOK ())
      theCall.myDemand ()->setDemandVol (demandVol);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandFocusHorizon (
      const char * partName,
      const char * demandName,
      int          focusHorizon)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepRangedInt (
      "focusHorizon",
      theCall.myDemand ()->focusHorizon (),
      focusHorizon,
      - 1,
      theCall.myDemand ()->lastPeriod ());

   if (theCall.argsOK ())
      theCall.myDemand ()->setFocusHorizon (focusHorizon);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandFssShipVol (
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & fssShipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepNonNegDblVec ("fssShipVol", fssShipVol);

   if (theCall.argsOK ())
      theCall.myDemand ()->setFssShipVol (fssShipVol);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandIntShipVols (
      const char * partName,
      const char * demandName,
      WitBoolean   intShipVols)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBool (
      "intShipVols",
      theCall.myDemand ()->intShipVols (),
      intShipVols);

   if (theCall.argsOK ())
      theCall.myDemand ()->setIntShipVols (asaBool (intShipVols));
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandLeadTimeUB (
      const char * partName,
      const char * demandName,
      const int *  leadTimeUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepLeadTimeUB (leadTimeUB);

   if (theCall.argsOK ())
      theCall.myDemand ()->setLeadTimeUB (leadTimeUB);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandObj1CumShipReward (
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & obj1CumShipReward)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "demand",
         "obj1CumShipReward",
         "cumShipReward");

   witSetDemandCumShipReward (
      partName,
      demandName,
      obj1CumShipReward);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandObj1ShipReward (
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & obj1ShipReward)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "demand",
         "obj1ShipReward",
         "shipReward");

   witSetDemandShipReward (
      partName,
      demandName,
      obj1ShipReward);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandPrefBuildAhead (
      const char * partName,
      const char * demandName,
      WitBoolean   prefBuildAhead)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBool (
      "prefBuildAhead",
      theCall.myDemand ()->prefBuildAhead (),
      prefBuildAhead);

   if (theCall.argsOK ())
      theCall.myDemand ()->setPrefBuildAhead (asaBool (prefBuildAhead));
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandPriority (
      const char * partName,
      const char * demandName,
      const int *  priority)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepIntVec ("priority", priority);

   if (theCall.argsOK ())
      theCall.myDemand ()->setPriority (priority);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandSearchInc (
      const char *         partName,
      const char *         demandName,
      const WitISRealArg & searchInc)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepLBDouble (
      "searchInc",
      theCall.myDemand ()->searchInc (),
      searchInc,
      0.000999,
      0.001);

   if (theCall.argsOK ())
      theCall.myDemand ()->setSearchInc (searchInc);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandSelForDel (
      const char * partName,
      const char * demandName,
      WitBoolean   selForDel)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.setSelForDel (selForDel);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandShipLateAllowed (
      const char * partName,
      const char * demandName,
      WitBoolean   shipLateAllowed)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBool (
      "shipLateAllowed",
      theCall.myDemand ()->shipLateAllowed (),
      shipLateAllowed);

   if (theCall.argsOK ())
      theCall.myDemand ()->setShipLateAllowed (asaBool (shipLateAllowed));
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandShipLateLimit (
      const char * partName,
      const char * demandName,
      int          shipLateLimit)
   {
   WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "demand",
         "shipLateLimit",
         "shipLateUB");

   buildAheadUBVec = shipLateLimit;

   witSetDemandShipLateUB (
      partName, 
      demandName, 
      buildAheadUBVec.myCVec ());

   myApiMgr ()->releaseTempVecs ();
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandShipLateUB (
      const char * partName,
      const char * demandName,
      const int *  shipLateUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepShipLateUB (shipLateUB);

   if (theCall.argsOK ())
      theCall.myDemand ()->setShipLateUB (shipLateUB);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandShipReward (
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & shipReward)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepDblVec ("shipReward", shipReward);

   if (theCall.argsOK ())
      theCall.myDemand ()->setShipReward (shipReward);
   }

//------------------------------------------------------------------------------

void WitRun::witSetDemandShipVol (
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & shipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepNonNegDblVec ("shipVol", shipVol);

   if (theCall.argsOK ())
      theCall.myDemand ()->setShipVol (shipVol);
   }

//------------------------------------------------------------------------------
// getDemandP
// Get pointer to Demand.
//------------------------------------------------------------------------------

WitDemand * WitRun::getDemandP (const char * partName, const char * demandName)
   {
   WitDemand * retVal;
   WitPart   * partP;

   partP = getPartP (partName);

   myInputID ()->setMyPart (partP);

   retVal = myCompMgr ()->findDemand (partP, demandName);

   if (retVal == NULL)
      myMsgFac () ("undefinedDemandMsg", demandName, partP->partName ());

   myInputID ()->setMyDemand (retVal);

   return retVal;
   }

//------------------------------------------------------------------------------
// eqHeurAlloc
//
// Does the work common to witEqHeurAlloc and witEqHeurAllocTwme.
//------------------------------------------------------------------------------

void WitRun::eqHeurAlloc (
      int                  lenLists,
      const char * const * partNameList,
      const char * const * demandNameList,
      const int *          shipPeriodList,
      const WitIVRealArg & desIncVolList,
      const WitOVRealArg & incVolList,
      const WitBoolean *   asapMultiExecList)
   {
   int              listIndex;
   int              dupIndex1;
   int              dupIndex2;
   WitDemand *      theDemand;
   WitPeriod        shipPer;
   bool             asapMultiExec;
   WitEqAllocator * theEqAllocator;
   WitDemPerStack   theDemPers (myProblem ());

   forbidStochMode ();

   forbidNullArg (partNameList,   "demandedPartNameList");
   forbidNullArg (demandNameList, "demandNameList");
   forbidNullArg (shipPeriodList, "shipPeriodList");
   forbidNullArg (desIncVolList,  "desIncVolList");
   forbidNullArg (incVolList   ,  "incVolList");

   if (myGlobalComp ()->twoWayMultiExec ())
      forbidNullArg (asapMultiExecList, "asapMultiExecList");
   else
      witAssert (asapMultiExecList == NULL);

   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");

   theEqAllocator = myProblem ()->myEqAllocator ();

   theEqAllocator->activate ();

   if (lenLists < 1)
      {
      myInputID ()->setArgName ("lenLists");

      myMsgFac () ("argRangeValGeIntSmsg", lenLists, 1);
      }

   for (listIndex = 0; listIndex < lenLists; ++ listIndex)
      {
      myInputID ()->setArgIndex (listIndex);

      asapMultiExec = 
         myGlobalComp ()->twoWayMultiExec ()?
            asaBool (asapMultiExecList[listIndex]):
            false;

      defineAllocTarget (
         partNameList  [listIndex],
         demandNameList[listIndex],
         shipPeriodList[listIndex],
         desIncVolList [listIndex],
         asapMultiExec,
         theDemPers);
      }

   theDemPers.reverse ();

   myInputID ()->setArgIndex (-1);

   if (theEqAllocator->containsDup (theDemPers, dupIndex1, dupIndex2))
      myMsgFac () ("dupTargetSmsg",
         dupIndex1,
         dupIndex2,
         partNameList  [dupIndex1],
         demandNameList[dupIndex1],
         shipPeriodList[dupIndex1]);

   theEqAllocator->eqAlloc (theDemPers);

   theEqAllocator->print (theDemPers);

   apiAlloc (incVolList, lenLists);

   listIndex = -1;

   while (theDemPers.pop (theDemand, shipPer))
      {
      listIndex ++;

      incVolList[listIndex] = theEqAllocator->incVol (theDemand, shipPer);
      }
   }

//------------------------------------------------------------------------------
// incHeurAlloc
//
// Does the work common to witIncHeurAlloc and witIncHeurAllocTwme.
//------------------------------------------------------------------------------

void WitRun::incHeurAlloc (
      const char *         partName,
      const char *         demandName,
      int                  shipPer,
      const WitISRealArg & desIncVol,
      const WitOSRealArg & incVol,
      WitBoolean           asapMultiExec)
   {
   WitDemandApiCall theCall (this, partName, demandName);
   double           incVolVal;

   if (myGlobalComp ()->twoWayMultiExec ())
      myProblem ()->myHeurAllMgr ()->printMeDir (asaBool (asapMultiExec));

   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");

   if (not ((shipPer >= 0) and (shipPer < nPeriods ())))
      {
      myInputID ()->setArgName ("shipPer");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPer, 0, nPeriods ());
      }

   if (not (desIncVol.asaDbl () >= 0.0))
      {
      myInputID ()->setArgName ("desIncVol");

      myMsgFac () ("argRangeValGeDblSmsg", desIncVol, 0.0);
      }

   incVolVal =
      myProblem ()->myHeurAllMgr ()->incHeurAlloc (
         theCall.myDemand (), 
         shipPer, 
         desIncVol,
         asaBool (asapMultiExec));

   apiGet (incVol, "incVol", incVolVal);

   if (myMsgFac ().mayIssue ("incHeurDataMsg"))
      myMsgFac () ("incHeurDataMsg", shipPer, desIncVol, incVolVal);
   }

//------------------------------------------------------------------------------

void WitRun::defineAllocTarget (
      const char *     partName,
      const char *     demandName,
      int              shipPer,
      double           desIncVol,
      bool             asapMultiExec,
      WitDemPerStack & theDemPers)
   {
   WitPart *   thePart;
   WitDemand * theDemand;


   forbidNullArg (partName, "demandedPartNameList");

   thePart = myCompMgr ()->findPart (partName);

   if (thePart == NULL)
      {
      myInputID ()->setArgName ("demandedPartNameList");

      myMsgFac () ("undefinedPartMsg", partName);
      }

   forbidNullArg (demandName, "demandNameList");

   theDemand = myCompMgr ()->findDemand (thePart, demandName);

   if (theDemand == NULL)
      {
      myInputID ()->setArgName ("demandNameList");

      myMsgFac () ("undefinedDemandMsg", demandName, partName);
      }

   if ((shipPer < 0) or (shipPer >= nPeriods ()))
      {
      myInputID ()->setArgName ("shipPeriodList");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPer, 0, nPeriods ());
      }

   theDemPers.push (theDemand, shipPer);

   if (desIncVol < 0.0)
      {
      myInputID ()->setArgName ("desIncVolList");

      myMsgFac () ("argRangeValGeDblSmsg", desIncVol, 0.0);
      }

   myProblem ()->myEqAllocator ()->setDesIncVol (theDemand, shipPer, desIncVol);

   if (myGlobalComp ()->twoWayMultiExec ())
       myProblem ()->myEqAllocator ()->setAsapMultiExec (
          theDemand, 
          shipPer, 
          asapMultiExec);
   }

//------------------------------------------------------------------------------

void WitRun::prepGetPegging (int shipPeriod)
   {
   if (myMsgFac ().mayIssue ("shipPerMsg"))
      myMsgFac () ("shipPerMsg", shipPeriod);

   if (not myGlobalComp ()->perfPegging ())
      myMsgFac () ("reqPerfPeggingSmsg");

   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputID ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }
   }

//------------------------------------------------------------------------------

void WitRun::getPartPip (
      WitPartTripStack &   thePegTrips,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   int       nTrips;
   int       theIdx;
   WitPart * thePart;
   WitPeriod pegPer;
   double    pegVol;

   nTrips = thePegTrips.nElements ();

   apiGet (lenLists, "lenLists", nTrips);

   forbidNullArg (partNameList,  "partNameList");
   forbidNullArg (periodList,    "periodList");
   forbidNullArg (peggedVolList, "peggedVolList");

   apiAlloc (partNameList,  nTrips);
   apiAlloc (periodList,    nTrips);
   apiAlloc (peggedVolList, nTrips);

   theIdx = -1;

   while (thePegTrips.pop (thePart, pegPer, pegVol))
      {
      theIdx ++;

      (* partNameList) [theIdx] = thePart->partName ().apiDupCstring ();
      (* periodList)   [theIdx] = pegPer;
      peggedVolList    [theIdx] = pegVol;
      }
   }

//------------------------------------------------------------------------------

void WitRun::prepGetPip (int shipPeriod)
   {
   if (myMsgFac ().mayIssue ("shipPerMsg"))
      myMsgFac () ("shipPerMsg", shipPeriod);

   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputID ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }

   if (not myProblem ()->myPipMgr ()->peggingExists ())
      myMsgFac () ("needPipExistsSmsg");
   }
@


1.166
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.165
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d51 5
a55 5
const char *  partName,
const char *  demandName)
{
forbidNullArg (partName,   "demandedPartName");
forbidNullArg (demandName, "demandName");
d57 2
a58 2
if (myMsgFac ().mayIssue ("partNameMsg"))
myMsgFac () ("partNameMsg", partName);
d60 2
a61 2
if (myMsgFac ().mayIssue ("demandNameMsg"))
myMsgFac () ("demandNameMsg", demandName);
d63 2
a64 2
return getDemandP (partName, demandName);
}
d69 4
a72 4
const char * partName,
const char * demandName)
{
WitPart * thePart;
d74 1
a74 1
myApiMgr_->startInnerFunc ();
d76 2
a77 2
forbidNullArg (partName,   "partName");
forbidNullArg (demandName, "demandName");
d79 2
a80 2
if (myMsgFac ().mayIssue ("demandNameAdMsg"))
myMsgFac () ("demandNameAdMsg", partName, demandName);
d82 1
a82 1
thePart = myCompMgr ()->findPart (partName);
d84 2
a85 2
if (thePart == NULL)
myMsgFac () ("undefinedPartMsg", partName);
d87 1
a87 1
myInputID ()->setMyPart (thePart);
d89 2
a90 2
if (isNullCstring (demandName))
myMsgFac () ("nullStringSmsg", "demandName");
d92 2
a93 2
if (myCompMgr ()->findDemand (thePart, demandName) != NULL)
myMsgFac () ("duplicateDemNameAdMsg", demandName);
d95 1
a95 1
addingDelComp ("demandFrag");
d97 1
a97 1
new WitDemand (demandName, thePart);
d99 2
a100 2
myInputID ()->setMyPart (NULL);
}
d108 31
a138 31
const char *         partName,
const char *         demandName,
int                  shipPeriod,
const WitISRealArg & incShipVol)
{
WitDemandApiCall theCall (this, partName, demandName);

if (myMsgFac ().mayIssue ("shipPerMsg"))
myMsgFac () ("shipPerMsg", shipPeriod);

if (myMsgFac ().mayIssue ("incShipVolMsg"))
myMsgFac () ("incShipVolMsg", incShipVol);

if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
{
myInputID ()->setArgName ("shipPeriod");

myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
}

if (not (incShipVol.asaDbl () >= 0.0))
{
myInputID ()->setArgName ("incShipVol");

myMsgFac () ("argRangeValGeDblSmsg", incShipVol, 0.0);
}

myProblem ()->
myPipMgr ()->
appendToShipSeq (theCall.myDemand (), shipPeriod, incShipVol);
}
d143 7
a149 7
const char * dupPartName,
const char * dupDemandName,
WitRun *     origWitRun,
const char * origPartName,
const char * origDemandName)
{
startCopyObjData (origWitRun);
d151 1
a151 1
myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("demandFrag"));
d153 1
a153 1
WitDemandApiCall  dupCall (this,        dupPartName,  dupDemandName);
d155 1
a155 1
myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("demandFrag"));
d157 1
a157 1
WitDemandApiCall origCall (origWitRun, origPartName, origDemandName);
d159 3
a161 3
if (dupCall.myDemand () == origCall.myDemand ())
myMsgFac () ("copyObjectToSelfSmsg",
myMsgFac ().myFrag ("demandFrag"));
d163 2
a164 2
dupCall.myDemand ()->copyAttrsFrom (origCall.myDemand ());
}
d172 24
a195 24
int                  lenLists,
const char * const * partNameList,
const char * const * demandNameList,
const int *          shipPeriodList,
const WitIVRealArg & desIncVolList,
const WitOVRealArg & incVolList)
{
myApiMgr_->startInnerFunc ();

if (myGlobalComp ()->twoWayMultiExec ())
myMsgFac () ("wrongFuncForTwmeSmsg",
"witEqHeurAlloc",
true,
"witEqHeurAllocTwme");

eqHeurAlloc (
lenLists,
partNameList,
demandNameList,
shipPeriodList,
desIncVolList,
incVolList,
NULL);
}
d200 26
a225 26
int                  lenLists,
const char * const * partNameList,
const char * const * demandNameList,
const int *          shipPeriodList,
const WitIVRealArg & desIncVolList,
const WitOVRealArg & incVolList,
const WitBoolean *   asapMultiExecList)
{
myApiMgr_->startInnerFunc ();

if (not myGlobalComp ()->twoWayMultiExec ())
myMsgFac () ("wrongFuncForTwmeSmsg",
"witEqHeurAllocTwme",
false,
"witEqHeurAlloc");


eqHeurAlloc (
lenLists,
partNameList,
demandNameList,
shipPeriodList,
desIncVolList,
incVolList,
asapMultiExecList);
}
d230 16
a245 16
char * * partName,
char * * demandName)
{
WitDemand * theDemand;

myApiMgr_->startInnerFunc ();

theDemand =
curItrDelCompForGet (WitAT_DEMAND, "demandFrag")->
thisDemand ();

stronglyAssert (theDemand != NULL);

apiGet (partName,   "partName",   theDemand->demandedPartName ());
apiGet (demandName, "demandName", theDemand->demandName ());
}
d250 5
a254 5
const char * partName,
const char * demandName,
void * *    appData)
{
WitDemandApiCall theCall (this, partName, demandName);
d256 2
a257 2
apiGet (appData, "appData", theCall.myDemand ()->appData ());
}
d262 5
a266 5
const char * partName,
const char * demandName,
int * *      buildAheadUB)
{
WitDemandApiCall theCall (this, partName, demandName);
d268 2
a269 2
apiGet (buildAheadUB, "buildAheadUB", theCall.myDemand ()->buildAheadUB ());
}
d274 15
a288 15
const char * partName,
const char * demandName,
int *        buildAheadLimit)
{
int * buildAheadUBval;

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
myMsgFac () (
"getVecAttrAsScalMsg",
apiFuncName (),
"demand",
"buildAheadLimit",
"buildAheadUB");
d290 1
a290 1
witGetDemandBuildAheadUB (partName, demandName, & buildAheadUBval);
d292 1
a292 1
forbidNullArg (buildAheadLimit, "buildAheadLimit");
d294 1
a294 1
* buildAheadLimit = buildAheadUBval[0];
d296 2
a297 2
free (buildAheadUBval);
}
d302 52
a353 52
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           operationNameList,
int * *              bopEntryIndexList,
int * *              execPeriodList,
const WitOVRealArg & peggedVolList)
{
WitBopEntTripStack coExecVolTrips (myProblem ());
int                nTrips;
int                theIdx;
WitBopEntry *      theBopEnt;
WitPeriod          execPer;
double             pgdCoExecVol;

WitDemandApiCall theCall (this, partName, demandName);

prepGetPip (shipPeriod);

myProblem ()->
myPipMgr ()->
getCoExecVolTrips (theCall.myDemand (), shipPeriod, coExecVolTrips);

nTrips = coExecVolTrips.nElements ();

apiGet (lenLists, "lenLists", nTrips);

forbidNullArg (operationNameList, "operationNameList");
forbidNullArg (bopEntryIndexList, "bopEntryIndexList");
forbidNullArg (execPeriodList,    "execPeriodList");
forbidNullArg (peggedVolList,     "peggedVolList");

apiAlloc (operationNameList, nTrips);
apiAlloc (bopEntryIndexList, nTrips);
apiAlloc (execPeriodList,    nTrips);
apiAlloc (peggedVolList,     nTrips);

theIdx = -1;

while (coExecVolTrips.pop (theBopEnt, execPer, pgdCoExecVol))
{
theIdx ++;

(* operationNameList)[theIdx] =
theBopEnt->myOperationName ().apiDupCstring ();

(* bopEntryIndexList)[theIdx] = theBopEnt->localIndex ();
(* execPeriodList)   [theIdx] = execPer;
peggedVolList        [theIdx] = pgdCoExecVol;
}
}
d358 25
a382 25
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           partNameList,
int * *              periodList,
const WitOVRealArg & peggedVolList)
{
WitPartTripStack thePegTrips (myProblem ());

WitDemandApiCall theCall (this, partName, demandName);

prepGetPip (shipPeriod);

myProblem ()->
myPipMgr ()->
getConsVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

getPartPip (
thePegTrips,
lenLists,
partNameList,
periodList,
peggedVolList);
}
d387 7
a393 7
const char *         partName,
const char *         demandName,
const WitOVRealArg & hardLB,
const WitOVRealArg & softLB,
const WitOVRealArg & hardUB)
{
WitDemandApiCall theCall (this, partName, demandName);
d395 2
a396 2
apiGet (hardLB, softLB, hardUB, theCall.myDemand ()->cumShipBounds ());
}
d401 11
a411 11
const char *         partName,
const char *         demandName,
const WitOVRealArg & cumShipReward)
{
WitDemandApiCall theCall (this, partName, demandName);

apiGet (
cumShipReward,
"cumShipReward",
theCall.myDemand ()->cumShipReward ());
}
d416 16
a431 16
const char * partName,
const char * demandName,
const int    thePer,
int *        cumShipSlbConIndex)
{
WitDemandApiCall theCall (this, partName, demandName);

prepGetIndex (thePer);

apiGet (
cumShipSlbConIndex,
"cumShipSlbConIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
cumShipSlbConIndex (theCall.myDemand (), thePer));
}
d436 16
a451 16
const char * partName,
const char * demandName,
const int    thePer,
int *        cumShipSlbvVarIndex)
{
WitDemandApiCall theCall (this, partName, demandName);

prepGetIndex (thePer);

apiGet (
cumShipSlbvVarIndex,
"cumShipSlbvVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
cumShipSlbvVarIndex (theCall.myDemand (), thePer));
}
d456 16
a471 16
const char * partName,
const char * demandName,
const int    thePer,
int *        cumShipVarIndex)
{
WitDemandApiCall theCall (this, partName, demandName);

prepGetIndex (thePer);

apiGet (
cumShipVarIndex,
"cumShipVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
cumShipVarIndex (theCall.myDemand (), thePer));
}
d476 5
a480 5
const char *         partName,
const char *         demandName,
const WitOVRealArg & demandVol)
{
WitDemandApiCall theCall (this, partName, demandName);
d482 2
a483 2
apiGet (demandVol, "demandVol", theCall.myDemand ()->demandVol ());
}
d488 14
a501 14
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           operationNameList,
int * *              execPeriodList,
const WitOVRealArg & peggedExecVolList)
{
WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());
WitObjStItr <WitFixedPegEl> theItr;
int                         nOpnPegEls;
int                         theIdx;
WitFixedPegEl *             theFixedPegEl;
WitOperation *              theOpn;
d503 1
a503 1
WitDemandApiCall theCall (this, partName, demandName);
d505 1
a505 1
prepGetPegging (shipPeriod);
d507 1
a507 1
theCall.myDemand ()->getMyFixedPegEls (shipPeriod, theFixedPegEls);
d509 1
a509 1
nOpnPegEls = 0;
d511 1
a511 1
theFixedPegEls.attachItr (theItr);
d513 3
a515 3
while (theItr.advance (theFixedPegEl))
if (theFixedPegEl->myOpn () != NULL)
nOpnPegEls ++;
d517 1
a517 1
apiGet (lenLists, "lenLists", nOpnPegEls);
d519 3
a521 3
forbidNullArg (operationNameList, "operationNameList");
forbidNullArg (execPeriodList,    "execPeriodList");
forbidNullArg (peggedExecVolList, "peggedExecVolList");
d523 3
a525 3
apiAlloc (operationNameList, nOpnPegEls);
apiAlloc (execPeriodList,    nOpnPegEls);
apiAlloc (peggedExecVolList, nOpnPegEls);
d527 1
a527 1
theIdx = 0;
d529 3
a531 3
while (theFixedPegEls.pop (theFixedPegEl))
{
theOpn = theFixedPegEl->myOpn ();
d533 2
a534 2
if (theOpn == NULL)
continue;
d536 1
a536 1
(* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();
d538 1
a538 1
(* execPeriodList)   [theIdx] = theFixedPegEl->myExecPer ();
d540 1
a540 1
peggedExecVolList    [theIdx] = theFixedPegEl->peggedVol ();
d542 3
a544 3
theIdx ++;
}
}
d549 48
a596 48
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           operationNameList,
int * *              execPeriodList,
const WitOVRealArg & peggedVolList)
{
WitOpnTripStack execVolTrips (myProblem ());
int             nTrips;
int             theIdx;
WitOperation *  theOpn;
WitPeriod       execPer;
double          pgdExecVol;

WitDemandApiCall theCall (this, partName, demandName);

prepGetPip (shipPeriod);

myProblem ()->
myPipMgr ()->
getExecVolTrips (theCall.myDemand (), shipPeriod, execVolTrips);

nTrips = execVolTrips.nElements ();

apiGet (lenLists, "lenLists", nTrips);

forbidNullArg (operationNameList, "operationNameList");
forbidNullArg (execPeriodList,    "execPeriodList");
forbidNullArg (peggedVolList,     "peggedVolList");

apiAlloc (operationNameList, nTrips);
apiAlloc (execPeriodList,    nTrips);
apiAlloc (peggedVolList,     nTrips);

theIdx = -1;

while (execVolTrips.pop (theOpn, execPer, pgdExecVol))
{
theIdx ++;

(* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();

(* execPeriodList)   [theIdx] = execPer;

peggedVolList        [theIdx] = pgdExecVol;
}
}
d601 5
a605 5
const char * partName,
const char * demandName,
int *        focusHorizon)
{
WitDemandApiCall theCall (this, partName, demandName);
d607 2
a608 2
apiGet (focusHorizon, "focusHorizon", theCall.myDemand ()->focusHorizon ());
}
d613 5
a617 5
const char *         partName,
const char *         demandName,
const WitOVRealArg & fssShipVol)
{
WitDemandApiCall theCall (this, partName, demandName);
d619 2
a620 2
apiGet (fssShipVol, "fssShipVol", theCall.myDemand ()->fssShipVol ());
}
d625 11
a635 11
const char * partName,
const char * demandName,
WitBoolean * intShipVols)
{
WitDemandApiCall theCall (this, partName, demandName);

apiGet (
intShipVols,
"intShipVols",
theCall.myDemand ()->intShipVols ());
}
d640 5
a644 5
const char * partName,
const char * demandName,
int * *      leadTimeUB)
{
WitDemandApiCall theCall (this, partName, demandName);
d646 2
a647 2
apiGet (leadTimeUB, "leadTimeUB", theCall.myDemand ()->leadTimeUB ());
}
d652 19
a670 19
const char *         partName,
const char *         demandName,
const WitOVRealArg & obj1CumShipReward)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
myMsgFac () (
"getAttrNewNameMsg",
apiFuncName (),
"demand",
"obj1CumShipReward",
"cumShipReward");

witGetDemandCumShipReward (
partName,
demandName,
obj1CumShipReward);
}
d675 19
a693 19
const char *         partName,
const char *         demandName,
const WitOVRealArg & obj1ShipReward)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
myMsgFac () (
"getAttrNewNameMsg",
apiFuncName (),
"demand",
"obj1ShipReward",
"shipReward");

witGetDemandShipReward (
partName,
demandName,
obj1ShipReward);
}
d698 11
a708 11
const char * partName,
const char * demandName,
WitBoolean * prefBuildAhead)
{
WitDemandApiCall theCall (this, partName, demandName);

apiGet (
prefBuildAhead,
"prefBuildAhead",
theCall.myDemand ()->prefBuildAhead ());
}
d713 5
a717 5
const char * partName,
const char * demandName,
int * *      priority)
{
WitDemandApiCall theCall (this, partName, demandName);
d719 2
a720 2
apiGet (priority, "priority", theCall.myDemand ()->priority ());
}
d725 25
a749 25
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           partNameList,
int * *              periodList,
const WitOVRealArg & peggedVolList)
{
WitPartTripStack thePegTrips (myProblem ());

WitDemandApiCall theCall (this, partName, demandName);

prepGetPip (shipPeriod);

myProblem ()->
myPipMgr ()->
getProdVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

getPartPip (
thePegTrips,
lenLists,
partNameList,
periodList,
peggedVolList);
}
d754 5
a758 5
const char *         partName,
const char *         demandName,
const WitOSRealArg & searchInc)
{
WitDemandApiCall theCall (this, partName, demandName);
d760 2
a761 2
apiGet (searchInc, "searchInc", theCall.myDemand ()->searchInc ());
}
d766 5
a770 5
const char * partName,
const char * demandName,
WitBoolean * selForDel)
{
WitDemandApiCall theCall (this, partName, demandName);
d772 2
a773 2
apiGet (selForDel, "selForDel", theCall.myDemand ()->selForDel ());
}
d778 16
a793 16
const char * partName,
const char * demandName,
const int    thePer,
int *        shipConIndex)
{
WitDemandApiCall theCall (this, partName, demandName);

prepGetIndex (thePer);

apiGet (
shipConIndex,
"shipConIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
shipConIndex (theCall.myDemand (), thePer));
}
d798 11
a808 11
const char * partName,
const char * demandName,
WitBoolean * shipLateAllowed)
{
WitDemandApiCall theCall (this, partName, demandName);

apiGet (
shipLateAllowed,
"shipLateAllowed",
theCall.myDemand ()->shipLateAllowed ());
}
d813 15
a827 15
const char * partName,
const char * demandName,
int *        shipLateLimit)
{
int * shipLateUBval;

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
myMsgFac () (
"getVecAttrAsScalMsg",
apiFuncName (),
"demand",
"shipLateLimit",
"shipLateUB");
d829 1
a829 1
witGetDemandShipLateUB (partName, demandName, & shipLateUBval);
d831 1
a831 1
forbidNullArg (shipLateLimit, "shipLateLimit");
d833 1
a833 1
* shipLateLimit = shipLateUBval[0];
d835 2
a836 2
free (shipLateUBval);
}
d841 5
a845 5
const char * partName,
const char * demandName,
int * *      shipLateUB)
{
WitDemandApiCall theCall (this, partName, demandName);
d847 2
a848 2
apiGet (shipLateUB, "shipLateUB", theCall.myDemand ()->shipLateUB ());
}
d853 11
a863 11
const char *         partName,
const char *         demandName,
const WitOVRealArg & shipReward)
{
WitDemandApiCall theCall (this, partName, demandName);

apiGet (
shipReward,
"shipReward",
theCall.myDemand ()->shipReward ());
}
d868 16
a883 16
const char * partName,
const char * demandName,
const int    thePer,
int *        shipVarIndex)
{
WitDemandApiCall theCall (this, partName, demandName);

prepGetIndex (thePer);

apiGet (
shipVarIndex,
"shipVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
shipVarIndex (theCall.myDemand (), thePer));
}
d888 5
a892 5
const char *         partName,
const char *         demandName,
const WitOVRealArg & shipVol)
{
WitDemandApiCall theCall (this, partName, demandName);
d894 2
a895 2
apiGet (shipVol, "shipVol", theCall.myDemand ()->shipVol ());
}
d900 25
a924 25
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           partNameList,
int * *              periodList,
const WitOVRealArg & peggedVolList)
{
WitPartTripStack thePegTrips (myProblem ());

WitDemandApiCall theCall (this, partName, demandName);

prepGetPip (shipPeriod);

myProblem ()->
myPipMgr ()->
getSideVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

getPartPip (
thePegTrips,
lenLists,
partNameList,
periodList,
peggedVolList);
}
d929 65
a993 65
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           operationNameList,
int * *              bomEntryIndexList,
int * *              subsBomEntryIndexList,
int * *              execPeriodList,
const WitOVRealArg & peggedSubVolList)
{
WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());
WitObjStItr <WitFixedPegEl> theItr;
int                         nSubPegEls;
int                         theIdx;
WitFixedPegEl *             theFixedPegEl;
WitSubEntry *               theSub;

WitDemandApiCall theCall (this, partName, demandName);

prepGetPegging (shipPeriod);

theCall.myDemand ()->getMyFixedPegEls (shipPeriod, theFixedPegEls);

nSubPegEls = 0;

theFixedPegEls.attachItr (theItr);

while (theItr.advance (theFixedPegEl))
if (theFixedPegEl->mySub () != NULL)
nSubPegEls ++;

apiGet (lenLists, "lenLists", nSubPegEls);

forbidNullArg (operationNameList,     "operationNameList");
forbidNullArg (bomEntryIndexList,     "bomEntryIndexList");
forbidNullArg (subsBomEntryIndexList, "subsBomEntryIndexList");
forbidNullArg (execPeriodList,        "execPeriodList");
forbidNullArg (peggedSubVolList,      "peggedSubVolList");

apiAlloc (operationNameList,     nSubPegEls);
apiAlloc (bomEntryIndexList,     nSubPegEls);
apiAlloc (subsBomEntryIndexList, nSubPegEls);
apiAlloc (execPeriodList,        nSubPegEls);
apiAlloc (peggedSubVolList,      nSubPegEls);

theIdx = 0;

while (theFixedPegEls.pop (theFixedPegEl))
{
theSub = theFixedPegEl->mySub ();

if (theSub == NULL)
continue;

(* operationNameList)    [theIdx] =
theSub->myOperationName ().apiDupCstring ();

(* bomEntryIndexList)    [theIdx] = theSub       ->myBomEntIndex ();
(* subsBomEntryIndexList)[theIdx] = theSub       ->localIndex ();
(* execPeriodList)       [theIdx] = theFixedPegEl->myExecPer ();
peggedSubVolList         [theIdx] = theFixedPegEl->peggedVol ();

theIdx ++;
}
}
d998 56
a1053 56
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           operationNameList,
int * *              bomEntryIndexList,
int * *              subsBomEntryIndexList,
int * *              execPeriodList,
const WitOVRealArg & peggedVolList)
{
WitSubTripStack subVolTrips (myProblem ());
int             nTrips;
int             theIdx;
WitSubEntry *   theSub;
WitPeriod       execPer;
double          pgdSubVol;

WitDemandApiCall theCall (this, partName, demandName);

prepGetPip (shipPeriod);

myProblem ()->
myPipMgr ()->
getSubVolTrips (theCall.myDemand (), shipPeriod, subVolTrips);

nTrips = subVolTrips.nElements ();

apiGet (lenLists, "lenLists", nTrips);

forbidNullArg (operationNameList,     "operationNameList");
forbidNullArg (bomEntryIndexList,     "bomEntryIndexList");
forbidNullArg (subsBomEntryIndexList, "subsBomEntryIndexList");
forbidNullArg (execPeriodList,        "execPeriodList");
forbidNullArg (peggedVolList,         "peggedVolList");

apiAlloc (operationNameList,     nTrips);
apiAlloc (bomEntryIndexList,     nTrips);
apiAlloc (subsBomEntryIndexList, nTrips);
apiAlloc (execPeriodList,        nTrips);
apiAlloc (peggedVolList,         nTrips);

theIdx = -1;

while (subVolTrips.pop (theSub, execPer, pgdSubVol))
{
theIdx ++;

(* operationNameList)    [theIdx] =
theSub->myOperationName ().apiDupCstring ();

(* bomEntryIndexList)    [theIdx] = theSub->myBomEntIndex ();
(* subsBomEntryIndexList)[theIdx] = theSub->localIndex ();
(* execPeriodList)       [theIdx] = execPer;
peggedVolList            [theIdx] = pgdSubVol;
}
}
d1058 25
a1082 25
const char *         partName,
const char *         demandName,
int                  shipPeriod,
int *                lenLists,
char * * *           partNameList,
int * *              periodList,
const WitOVRealArg & peggedVolList)
{
WitPartTripStack thePegTrips (myProblem ());

WitDemandApiCall theCall (this, partName, demandName);

prepGetPip (shipPeriod);

myProblem ()->
myPipMgr ()->
getSupplyVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

getPartPip (
thePegTrips,
lenLists,
partNameList,
periodList,
peggedVolList);
}
d1087 22
a1108 22
const char *         partName,
const char *         demandName,
int                  shipPeriod,
const WitISRealArg & desIncVol,
const WitOSRealArg & incVol)
{
myApiMgr_->startInnerFunc ();

if (myGlobalComp ()->twoWayMultiExec ())
myMsgFac () ("wrongFuncForTwmeSmsg",
"witIncHeurAlloc",
true,
"witIncHeurAllocTwme");

incHeurAlloc (
partName,
demandName,
shipPeriod,
desIncVol,
incVol,
false);
}
d1113 23
a1135 23
const char *         partName,
const char *         demandName,
int                  shipPeriod,
const WitISRealArg & desIncVol,
const WitOSRealArg & incVol,
WitBoolean           asapMultiExec)
{
myApiMgr_->startInnerFunc ();

if (not myGlobalComp ()->twoWayMultiExec ())
myMsgFac () ("wrongFuncForTwmeSmsg",
"witIncHeurAllocTwme",
false,
"witIncHeurAlloc");

incHeurAlloc (
partName,
demandName,
shipPeriod,
desIncVol,
incVol,
asapMultiExec);
}
d1140 5
a1144 5
const char * partName,
const char * demandName,
void *       appData)
{
WitDemandApiCall theCall (this, partName, demandName);
d1146 2
a1147 2
theCall.setAppData (appData);
}
d1152 11
a1162 11
const char * partName,
const char * demandName,
const int *  buildAheadUB)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepBuildAheadUB (buildAheadUB);

if (theCall.argsOK ())
theCall.myDemand ()->setBuildAheadUB (buildAheadUB);
}
d1167 22
a1188 22
const char * partName,
const char * demandName,
int          buildAheadLimit)
{
WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
myMsgFac () (
"setVecAttrToScalMsg",
apiFuncName (),
"demand",
"buildAheadLimit",
"buildAheadUB");

buildAheadUBVec = buildAheadLimit;

witSetDemandBuildAheadUB (
partName,
demandName,
buildAheadUBVec.myCVec ());
d1190 2
a1191 2
myApiMgr ()->releaseTempVecs ();
}
d1196 14
a1209 14
const char *         partName,
const char *         demandName,
const WitIVRealArg & hardLB,
const WitIVRealArg & softLB,
const WitIVRealArg & hardUB)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.setBoundSet (
theCall.myDemand ()->cumShipBounds (),
hardLB,
softLB,
hardUB);
}
d1214 11
a1224 11
const char *         partName,
const char *         demandName,
const WitIVRealArg & cumShipReward)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepDblVec ("cumShipReward", cumShipReward);

if (theCall.argsOK ())
theCall.myDemand ()->setCumShipReward (cumShipReward);
}
d1229 22
a1250 22
const char * partName,
const char * demandName,
const char * newName)
{
WitDemandApiCall theCall (this, partName, demandName);

forbidNullArg (newName, "newName");

if (isNullCstring (newName))
myMsgFac () ("nullStringSmsg", "newName");

if (myCompMgr ()->findDemand (theCall.myDemand ()->demandedPart (), newName))
myMsgFac () ("setDemandNameToDupSmsg", newName);

theCall.prepString (
"demandName",
theCall.myDemand ()->demandName (),
newName);

if (theCall.argsOK ())
theCall.myDemand ()->setDemandName (newName);
}
d1255 11
a1265 11
const char *         partName,
const char *         demandName,
const WitIVRealArg & demandVol)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepNonNegDblVec ("demandVol", demandVol);

if (theCall.argsOK ())
theCall.myDemand ()->setDemandVol (demandVol);
}
d1270 16
a1285 16
const char * partName,
const char * demandName,
int          focusHorizon)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepRangedInt (
"focusHorizon",
theCall.myDemand ()->focusHorizon (),
focusHorizon,
- 1,
theCall.myDemand ()->lastPeriod ());

if (theCall.argsOK ())
theCall.myDemand ()->setFocusHorizon (focusHorizon);
}
d1290 11
a1300 11
const char *         partName,
const char *         demandName,
const WitIVRealArg & fssShipVol)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepNonNegDblVec ("fssShipVol", fssShipVol);

if (theCall.argsOK ())
theCall.myDemand ()->setFssShipVol (fssShipVol);
}
d1305 14
a1318 14
const char * partName,
const char * demandName,
WitBoolean   intShipVols)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepBool (
"intShipVols",
theCall.myDemand ()->intShipVols (),
intShipVols);

if (theCall.argsOK ())
theCall.myDemand ()->setIntShipVols (asaBool (intShipVols));
}
d1323 11
a1333 11
const char * partName,
const char * demandName,
const int *  leadTimeUB)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepLeadTimeUB (leadTimeUB);

if (theCall.argsOK ())
theCall.myDemand ()->setLeadTimeUB (leadTimeUB);
}
d1338 19
a1356 19
const char *         partName,
const char *         demandName,
const WitIVRealArg & obj1CumShipReward)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
myMsgFac () (
"setAttrNewNameMsg",
apiFuncName (),
"demand",
"obj1CumShipReward",
"cumShipReward");

witSetDemandCumShipReward (
partName,
demandName,
obj1CumShipReward);
}
d1361 19
a1379 19
const char *         partName,
const char *         demandName,
const WitIVRealArg & obj1ShipReward)
{
myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
myMsgFac () (
"setAttrNewNameMsg",
apiFuncName (),
"demand",
"obj1ShipReward",
"shipReward");

witSetDemandShipReward (
partName,
demandName,
obj1ShipReward);
}
d1384 14
a1397 14
const char * partName,
const char * demandName,
WitBoolean   prefBuildAhead)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepBool (
"prefBuildAhead",
theCall.myDemand ()->prefBuildAhead (),
prefBuildAhead);

if (theCall.argsOK ())
theCall.myDemand ()->setPrefBuildAhead (asaBool (prefBuildAhead));
}
d1402 11
a1412 11
const char * partName,
const char * demandName,
const int *  priority)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepIntVec ("priority", priority);

if (theCall.argsOK ())
theCall.myDemand ()->setPriority (priority);
}
d1417 16
a1432 16
const char *         partName,
const char *         demandName,
const WitISRealArg & searchInc)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepLBDouble (
"searchInc",
theCall.myDemand ()->searchInc (),
searchInc,
0.000999,
0.001);

if (theCall.argsOK ())
theCall.myDemand ()->setSearchInc (searchInc);
}
d1437 5
a1441 5
const char * partName,
const char * demandName,
WitBoolean   selForDel)
{
WitDemandApiCall theCall (this, partName, demandName);
d1443 2
a1444 2
theCall.setSelForDel (selForDel);
}
d1449 14
a1462 14
const char * partName,
const char * demandName,
WitBoolean   shipLateAllowed)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepBool (
"shipLateAllowed",
theCall.myDemand ()->shipLateAllowed (),
shipLateAllowed);

if (theCall.argsOK ())
theCall.myDemand ()->setShipLateAllowed (asaBool (shipLateAllowed));
}
d1467 22
a1488 22
const char * partName,
const char * demandName,
int          shipLateLimit)
{
WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
myMsgFac () (
"setVecAttrToScalMsg",
apiFuncName (),
"demand",
"shipLateLimit",
"shipLateUB");

buildAheadUBVec = shipLateLimit;

witSetDemandShipLateUB (
partName,
demandName,
buildAheadUBVec.myCVec ());
d1490 2
a1491 2
myApiMgr ()->releaseTempVecs ();
}
d1496 11
a1506 11
const char * partName,
const char * demandName,
const int *  shipLateUB)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepShipLateUB (shipLateUB);

if (theCall.argsOK ())
theCall.myDemand ()->setShipLateUB (shipLateUB);
}
d1511 11
a1521 11
const char *         partName,
const char *         demandName,
const WitIVRealArg & shipReward)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepDblVec ("shipReward", shipReward);

if (theCall.argsOK ())
theCall.myDemand ()->setShipReward (shipReward);
}
d1526 11
a1536 11
const char *         partName,
const char *         demandName,
const WitIVRealArg & shipVol)
{
WitDemandApiCall theCall (this, partName, demandName);

theCall.prepNonNegDblVec ("shipVol", shipVol);

if (theCall.argsOK ())
theCall.myDemand ()->setShipVol (shipVol);
}
d1544 3
a1546 3
{
WitDemand * retVal;
WitPart   * partP;
d1548 1
a1548 1
partP = getPartP (partName);
d1550 1
a1550 1
myInputID ()->setMyPart (partP);
d1552 1
a1552 1
retVal = myCompMgr ()->findDemand (partP, demandName);
d1554 2
a1555 2
if (retVal == NULL)
myMsgFac () ("undefinedDemandMsg", demandName, partP->partName ());
d1557 1
a1557 1
myInputID ()->setMyDemand (retVal);
d1559 2
a1560 2
return retVal;
}
d1569 89
a1657 89
int                  lenLists,
const char * const * partNameList,
const char * const * demandNameList,
const int *          shipPeriodList,
const WitIVRealArg & desIncVolList,
const WitOVRealArg & incVolList,
const WitBoolean *   asapMultiExecList)
{
int              listIndex;
int              dupIndex1;
int              dupIndex2;
WitDemand *      theDemand;
WitPeriod        shipPer;
bool             asapMultiExec;
WitEqAllocator * theEqAllocator;
WitDemPerStack   theDemPers (myProblem ());

forbidStochMode ();

forbidNullArg (partNameList,   "demandedPartNameList");
forbidNullArg (demandNameList, "demandNameList");
forbidNullArg (shipPeriodList, "shipPeriodList");
forbidNullArg (desIncVolList,  "desIncVolList");
forbidNullArg (incVolList   ,  "incVolList");

if (myGlobalComp ()->twoWayMultiExec ())
forbidNullArg (asapMultiExecList, "asapMultiExecList");
else
witAssert (asapMultiExecList == NULL);

if (not myProblem ()->myHeurAllMgr ()->active ())
myMsgFac () ("inactiveHeurAllocSmsg");

theEqAllocator = myProblem ()->myEqAllocator ();

theEqAllocator->activate ();

if (lenLists < 1)
{
myInputID ()->setArgName ("lenLists");

myMsgFac () ("argRangeValGeIntSmsg", lenLists, 1);
}

for (listIndex = 0; listIndex < lenLists; ++ listIndex)
{
myInputID ()->setArgIndex (listIndex);

asapMultiExec =
myGlobalComp ()->twoWayMultiExec ()?
asaBool (asapMultiExecList[listIndex]):
false;

defineAllocTarget (
partNameList  [listIndex],
demandNameList[listIndex],
shipPeriodList[listIndex],
desIncVolList [listIndex],
asapMultiExec,
theDemPers);
}

theDemPers.reverse ();

myInputID ()->setArgIndex (-1);

if (theEqAllocator->containsDup (theDemPers, dupIndex1, dupIndex2))
myMsgFac () ("dupTargetSmsg",
dupIndex1,
dupIndex2,
partNameList  [dupIndex1],
demandNameList[dupIndex1],
shipPeriodList[dupIndex1]);

theEqAllocator->eqAlloc (theDemPers);

theEqAllocator->print (theDemPers);

apiAlloc (incVolList, lenLists);

listIndex = -1;

while (theDemPers.pop (theDemand, shipPer))
{
listIndex ++;

incVolList[listIndex] = theEqAllocator->incVol (theDemand, shipPer);
}
}
d1666 42
a1707 42
const char *         partName,
const char *         demandName,
int                  shipPer,
const WitISRealArg & desIncVol,
const WitOSRealArg & incVol,
WitBoolean           asapMultiExec)
{
WitDemandApiCall theCall (this, partName, demandName);
double           incVolVal;

if (myGlobalComp ()->twoWayMultiExec ())
myProblem ()->myHeurAllMgr ()->printMeDir (asaBool (asapMultiExec));

if (not myProblem ()->myHeurAllMgr ()->active ())
myMsgFac () ("inactiveHeurAllocSmsg");

if (not ((shipPer >= 0) and (shipPer < nPeriods ())))
{
myInputID ()->setArgName ("shipPer");

myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPer, 0, nPeriods ());
}

if (not (desIncVol.asaDbl () >= 0.0))
{
myInputID ()->setArgName ("desIncVol");

myMsgFac () ("argRangeValGeDblSmsg", desIncVol, 0.0);
}

incVolVal =
myProblem ()->myHeurAllMgr ()->incHeurAlloc (
theCall.myDemand (),
shipPer,
desIncVol,
asaBool (asapMultiExec));

apiGet (incVol, "incVol", incVolVal);

if (myMsgFac ().mayIssue ("incHeurDataMsg"))
myMsgFac () ("incHeurDataMsg", shipPer, desIncVol, incVolVal);
}
d1712 9
a1720 9
const char *     partName,
const char *     demandName,
int              shipPer,
double           desIncVol,
bool             asapMultiExec,
WitDemPerStack & theDemPers)
{
WitPart *   thePart;
WitDemand * theDemand;
d1723 1
a1723 1
forbidNullArg (partName, "demandedPartNameList");
d1725 1
a1725 1
thePart = myCompMgr ()->findPart (partName);
d1727 3
a1729 3
if (thePart == NULL)
{
myInputID ()->setArgName ("demandedPartNameList");
d1731 2
a1732 2
myMsgFac () ("undefinedPartMsg", partName);
}
d1734 1
a1734 1
forbidNullArg (demandName, "demandNameList");
d1736 1
a1736 1
theDemand = myCompMgr ()->findDemand (thePart, demandName);
d1738 3
a1740 3
if (theDemand == NULL)
{
myInputID ()->setArgName ("demandNameList");
d1742 2
a1743 2
myMsgFac () ("undefinedDemandMsg", demandName, partName);
}
d1745 3
a1747 3
if ((shipPer < 0) or (shipPer >= nPeriods ()))
{
myInputID ()->setArgName ("shipPeriodList");
d1749 2
a1750 2
myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPer, 0, nPeriods ());
}
d1752 1
a1752 1
theDemPers.push (theDemand, shipPer);
d1754 3
a1756 3
if (desIncVol < 0.0)
{
myInputID ()->setArgName ("desIncVolList");
d1758 2
a1759 2
myMsgFac () ("argRangeValGeDblSmsg", desIncVol, 0.0);
}
d1761 1
a1761 1
myProblem ()->myEqAllocator ()->setDesIncVol (theDemand, shipPer, desIncVol);
d1763 6
a1768 6
if (myGlobalComp ()->twoWayMultiExec ())
myProblem ()->myEqAllocator ()->setAsapMultiExec (
theDemand,
shipPer,
asapMultiExec);
}
d1773 14
a1786 14
{
if (myMsgFac ().mayIssue ("shipPerMsg"))
myMsgFac () ("shipPerMsg", shipPeriod);

if (not myGlobalComp ()->perfPegging ())
myMsgFac () ("reqPerfPeggingSmsg");

if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
{
myInputID ()->setArgName ("shipPeriod");

myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
}
}
d1791 35
a1825 35
WitPartTripStack &   thePegTrips,
int *                lenLists,
char * * *           partNameList,
int * *              periodList,
const WitOVRealArg & peggedVolList)
{
int       nTrips;
int       theIdx;
WitPart * thePart;
WitPeriod pegPer;
double    pegVol;

nTrips = thePegTrips.nElements ();

apiGet (lenLists, "lenLists", nTrips);

forbidNullArg (partNameList,  "partNameList");
forbidNullArg (periodList,    "periodList");
forbidNullArg (peggedVolList, "peggedVolList");

apiAlloc (partNameList,  nTrips);
apiAlloc (periodList,    nTrips);
apiAlloc (peggedVolList, nTrips);

theIdx = -1;

while (thePegTrips.pop (thePart, pegPer, pegVol))
{
theIdx ++;

(* partNameList) [theIdx] = thePart->partName ().apiDupCstring ();
(* periodList)   [theIdx] = pegPer;
peggedVolList    [theIdx] = pegVol;
}
}
d1830 14
a1843 14
{
if (myMsgFac ().mayIssue ("shipPerMsg"))
myMsgFac () ("shipPerMsg", shipPeriod);

if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
{
myInputID ()->setArgName ("shipPeriod");

myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
}

if (not myProblem ()->myPipMgr ()->peggingExists ())
myMsgFac () ("needPipExistsSmsg");
}
@


1.164
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d51 5
a55 5
      const char *  partName,
      const char *  demandName)
   {
   forbidNullArg (partName,   "demandedPartName");
   forbidNullArg (demandName, "demandName");
d57 2
a58 2
   if (myMsgFac ().mayIssue ("partNameMsg"))
      myMsgFac () ("partNameMsg", partName);
d60 2
a61 2
   if (myMsgFac ().mayIssue ("demandNameMsg"))
      myMsgFac () ("demandNameMsg", demandName);
d63 2
a64 2
   return getDemandP (partName, demandName);
   }
d69 4
a72 4
      const char * partName,
      const char * demandName)
   {
   WitPart * thePart;
d74 1
a74 1
   myApiMgr_->startInnerFunc ();
d76 2
a77 2
   forbidNullArg (partName,   "partName");
   forbidNullArg (demandName, "demandName");
d79 2
a80 2
   if (myMsgFac ().mayIssue ("demandNameAdMsg"))
      myMsgFac () ("demandNameAdMsg", partName, demandName);
d82 1
a82 1
   thePart = myCompMgr ()->findPart (partName);
d84 2
a85 2
   if (thePart == NULL)
      myMsgFac () ("undefinedPartMsg", partName);
d87 1
a87 1
   myInputID ()->setMyPart (thePart);
d89 2
a90 2
   if (isNullCstring (demandName))
      myMsgFac () ("nullStringSmsg", "demandName");
d92 2
a93 2
   if (myCompMgr ()->findDemand (thePart, demandName) != NULL)
      myMsgFac () ("duplicateDemNameAdMsg", demandName);
d95 1
a95 1
   addingDelComp ("demandFrag");
d97 1
a97 1
   new WitDemand (demandName, thePart);
d99 2
a100 2
   myInputID ()->setMyPart (NULL);
   }
d108 31
a138 31
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      const WitISRealArg & incShipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   if (myMsgFac ().mayIssue ("shipPerMsg"))
      myMsgFac () ("shipPerMsg", shipPeriod);

   if (myMsgFac ().mayIssue ("incShipVolMsg"))
      myMsgFac () ("incShipVolMsg", incShipVol);

   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputID ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }

   if (not (incShipVol.asaDbl () >= 0.0))
      {
      myInputID ()->setArgName ("incShipVol");

      myMsgFac () ("argRangeValGeDblSmsg", incShipVol, 0.0);
      }

   myProblem ()->
      myPipMgr ()->
         appendToShipSeq (theCall.myDemand (), shipPeriod, incShipVol);
   }
d143 7
a149 7
      const char * dupPartName,
      const char * dupDemandName,
      WitRun *     origWitRun,
      const char * origPartName,
      const char * origDemandName)
   {
   startCopyObjData (origWitRun);
d151 1
a151 1
   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("demandFrag"));
d153 1
a153 1
   WitDemandApiCall  dupCall (this,        dupPartName,  dupDemandName);
d155 1
a155 1
   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("demandFrag"));
d157 1
a157 1
   WitDemandApiCall origCall (origWitRun, origPartName, origDemandName);
d159 3
a161 3
   if (dupCall.myDemand () == origCall.myDemand ())
      myMsgFac () ("copyObjectToSelfSmsg",
         myMsgFac ().myFrag ("demandFrag"));
d163 2
a164 2
   dupCall.myDemand ()->copyAttrsFrom (origCall.myDemand ());
   }
d172 24
a195 24
      int                  lenLists,
      const char * const * partNameList,
      const char * const * demandNameList,
      const int *          shipPeriodList,
      const WitIVRealArg & desIncVolList,
      const WitOVRealArg & incVolList)
   {
   myApiMgr_->startInnerFunc ();

   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("wrongFuncForTwmeSmsg",
         "witEqHeurAlloc",
         true,
         "witEqHeurAllocTwme");

   eqHeurAlloc (
      lenLists,
      partNameList,
      demandNameList,
      shipPeriodList,
      desIncVolList,
      incVolList,
      NULL);
   }
d200 26
a225 26
      int                  lenLists,
      const char * const * partNameList,
      const char * const * demandNameList,
      const int *          shipPeriodList,
      const WitIVRealArg & desIncVolList,
      const WitOVRealArg & incVolList,
      const WitBoolean *   asapMultiExecList)
   {
   myApiMgr_->startInnerFunc ();

   if (not myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("wrongFuncForTwmeSmsg",
         "witEqHeurAllocTwme",
         false,
         "witEqHeurAlloc");


   eqHeurAlloc (
      lenLists,
      partNameList,
      demandNameList,
      shipPeriodList,
      desIncVolList,
      incVolList,
      asapMultiExecList);
   }
d230 16
a245 16
      char * * partName,
      char * * demandName)
   {
   WitDemand * theDemand;

   myApiMgr_->startInnerFunc ();

   theDemand =
      curItrDelCompForGet (WitAT_DEMAND, "demandFrag")->
         thisDemand ();

   stronglyAssert (theDemand != NULL);

   apiGet (partName,   "partName",   theDemand->demandedPartName ());
   apiGet (demandName, "demandName", theDemand->demandName ());
   }
d250 5
a254 5
      const char * partName,
      const char * demandName,
      void * *    appData)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d256 2
a257 2
   apiGet (appData, "appData", theCall.myDemand ()->appData ());
   }
d262 5
a266 5
      const char * partName,
      const char * demandName,
      int * *      buildAheadUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d268 2
a269 2
   apiGet (buildAheadUB, "buildAheadUB", theCall.myDemand ()->buildAheadUB ());
   }
d274 15
a288 15
      const char * partName,
      const char * demandName,
      int *        buildAheadLimit)
   {
   int * buildAheadUBval;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "demand",
         "buildAheadLimit",
         "buildAheadUB");
d290 1
a290 1
   witGetDemandBuildAheadUB (partName, demandName, & buildAheadUBval);
d292 1
a292 1
   forbidNullArg (buildAheadLimit, "buildAheadLimit");
d294 1
a294 1
   * buildAheadLimit = buildAheadUBval[0];
d296 2
a297 2
   free (buildAheadUBval);
   }
d302 52
a353 52
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              bopEntryIndexList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedVolList)
   {
   WitBopEntTripStack coExecVolTrips (myProblem ());
   int                nTrips;
   int                theIdx;
   WitBopEntry *      theBopEnt;
   WitPeriod          execPer;
   double             pgdCoExecVol;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getCoExecVolTrips (theCall.myDemand (), shipPeriod, coExecVolTrips);

   nTrips = coExecVolTrips.nElements ();

   apiGet (lenLists, "lenLists", nTrips);

   forbidNullArg (operationNameList, "operationNameList");
   forbidNullArg (bopEntryIndexList, "bopEntryIndexList");
   forbidNullArg (execPeriodList,    "execPeriodList");
   forbidNullArg (peggedVolList,     "peggedVolList");

   apiAlloc (operationNameList, nTrips);
   apiAlloc (bopEntryIndexList, nTrips);
   apiAlloc (execPeriodList,    nTrips);
   apiAlloc (peggedVolList,     nTrips);

   theIdx = -1;

   while (coExecVolTrips.pop (theBopEnt, execPer, pgdCoExecVol))
      {
      theIdx ++;

      (* operationNameList)[theIdx] = 
         theBopEnt->myOperationName ().apiDupCstring ();

      (* bopEntryIndexList)[theIdx] = theBopEnt->localIndex ();
      (* execPeriodList)   [theIdx] = execPer;
      peggedVolList        [theIdx] = pgdCoExecVol;
      }
   }
d358 25
a382 25
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   WitPartTripStack thePegTrips (myProblem ());

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getConsVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

   getPartPip (
      thePegTrips,
      lenLists,
      partNameList,
      periodList,
      peggedVolList);
   }
d387 7
a393 7
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & hardLB,
      const WitOVRealArg & softLB,
      const WitOVRealArg & hardUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d395 2
a396 2
   apiGet (hardLB, softLB, hardUB, theCall.myDemand ()->cumShipBounds ());
   }
d401 11
a411 11
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & cumShipReward)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
       cumShipReward,
      "cumShipReward",
      theCall.myDemand ()->cumShipReward ());
   }
d416 16
a431 16
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        cumShipSlbConIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       cumShipSlbConIndex,
      "cumShipSlbConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            cumShipSlbConIndex (theCall.myDemand (), thePer));
   }
d436 16
a451 16
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        cumShipSlbvVarIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       cumShipSlbvVarIndex,
      "cumShipSlbvVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            cumShipSlbvVarIndex (theCall.myDemand (), thePer));
   }
d456 16
a471 16
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        cumShipVarIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       cumShipVarIndex,
      "cumShipVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            cumShipVarIndex (theCall.myDemand (), thePer));
   }
d476 5
a480 5
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & demandVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d482 2
a483 2
   apiGet (demandVol, "demandVol", theCall.myDemand ()->demandVol ());
   }
d488 14
a501 14
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedExecVolList)
   {
   WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());
   WitObjStItr <WitFixedPegEl> theItr;
   int                         nOpnPegEls;
   int                         theIdx;
   WitFixedPegEl *             theFixedPegEl;
   WitOperation *              theOpn;
d503 1
a503 1
   WitDemandApiCall theCall (this, partName, demandName);
d505 1
a505 1
   prepGetPegging (shipPeriod);
d507 1
a507 1
   theCall.myDemand ()->getMyFixedPegEls (shipPeriod, theFixedPegEls);
d509 1
a509 1
   nOpnPegEls = 0;
d511 1
a511 1
   theFixedPegEls.attachItr (theItr);
d513 3
a515 3
   while (theItr.advance (theFixedPegEl))
      if (theFixedPegEl->myOpn () != NULL)
         nOpnPegEls ++;
d517 1
a517 1
   apiGet (lenLists, "lenLists", nOpnPegEls);
d519 3
a521 3
   forbidNullArg (operationNameList, "operationNameList");
   forbidNullArg (execPeriodList,    "execPeriodList");
   forbidNullArg (peggedExecVolList, "peggedExecVolList");
d523 3
a525 3
   apiAlloc (operationNameList, nOpnPegEls);
   apiAlloc (execPeriodList,    nOpnPegEls);
   apiAlloc (peggedExecVolList, nOpnPegEls);
d527 1
a527 1
   theIdx = 0;
d529 3
a531 3
   while (theFixedPegEls.pop (theFixedPegEl))
      {
      theOpn = theFixedPegEl->myOpn ();
d533 2
a534 2
      if (theOpn == NULL)
         continue;
d536 1
a536 1
      (* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();
d538 1
a538 1
      (* execPeriodList)   [theIdx] = theFixedPegEl->myExecPer ();
d540 1
a540 1
      peggedExecVolList    [theIdx] = theFixedPegEl->peggedVol ();
d542 3
a544 3
      theIdx ++;
      }
   }
d549 48
a596 48
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedVolList)
   {
   WitOpnTripStack execVolTrips (myProblem ());
   int             nTrips;
   int             theIdx;
   WitOperation *  theOpn;
   WitPeriod       execPer;
   double          pgdExecVol;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getExecVolTrips (theCall.myDemand (), shipPeriod, execVolTrips);

   nTrips = execVolTrips.nElements ();

   apiGet (lenLists, "lenLists", nTrips);

   forbidNullArg (operationNameList, "operationNameList");
   forbidNullArg (execPeriodList,    "execPeriodList");
   forbidNullArg (peggedVolList,     "peggedVolList");

   apiAlloc (operationNameList, nTrips);
   apiAlloc (execPeriodList,    nTrips);
   apiAlloc (peggedVolList,     nTrips);

   theIdx = -1;

   while (execVolTrips.pop (theOpn, execPer, pgdExecVol))
      {
      theIdx ++;

      (* operationNameList)[theIdx] = theOpn->operationName ().apiDupCstring ();

      (* execPeriodList)   [theIdx] = execPer;

      peggedVolList        [theIdx] = pgdExecVol;
      }
   }
d601 5
a605 5
      const char * partName,
      const char * demandName,
      int *        focusHorizon)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d607 2
a608 2
   apiGet (focusHorizon, "focusHorizon", theCall.myDemand ()->focusHorizon ());
   }
d613 5
a617 5
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & fssShipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d619 2
a620 2
   apiGet (fssShipVol, "fssShipVol", theCall.myDemand ()->fssShipVol ());
   }
d625 11
a635 11
      const char * partName,
      const char * demandName,
      WitBoolean * intShipVols)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      intShipVols, 
      "intShipVols", 
      theCall.myDemand ()->intShipVols ());
   }
d640 5
a644 5
      const char * partName,
      const char * demandName,
      int * *      leadTimeUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d646 2
a647 2
   apiGet (leadTimeUB, "leadTimeUB", theCall.myDemand ()->leadTimeUB ());
   }
d652 19
a670 19
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & obj1CumShipReward)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "demand",
         "obj1CumShipReward",
         "cumShipReward");

   witGetDemandCumShipReward (
      partName,
      demandName,
      obj1CumShipReward);
   }
d675 19
a693 19
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & obj1ShipReward)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getAttrNewNameMsg"))
      myMsgFac () (
         "getAttrNewNameMsg",
         apiFuncName (),
         "demand",
         "obj1ShipReward",
         "shipReward");

   witGetDemandShipReward (
      partName,
      demandName,
      obj1ShipReward);
   }
d698 11
a708 11
      const char * partName,
      const char * demandName,
      WitBoolean * prefBuildAhead)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      prefBuildAhead, 
      "prefBuildAhead", 
      theCall.myDemand ()->prefBuildAhead ());
   }
d713 5
a717 5
      const char * partName,
      const char * demandName,
      int * *      priority)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d719 2
a720 2
   apiGet (priority, "priority", theCall.myDemand ()->priority ());
   }
d725 25
a749 25
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   WitPartTripStack thePegTrips (myProblem ());

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getProdVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

   getPartPip (
      thePegTrips,
      lenLists,
      partNameList,
      periodList,
      peggedVolList);
   }
d754 5
a758 5
      const char *         partName,
      const char *         demandName,
      const WitOSRealArg & searchInc)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d760 2
a761 2
   apiGet (searchInc, "searchInc", theCall.myDemand ()->searchInc ());
   }
d766 5
a770 5
      const char * partName,
      const char * demandName,
      WitBoolean * selForDel)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d772 2
a773 2
   apiGet (selForDel, "selForDel", theCall.myDemand ()->selForDel ());
   }
d778 16
a793 16
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        shipConIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       shipConIndex,
      "shipConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            shipConIndex (theCall.myDemand (), thePer));
   }
d798 11
a808 11
      const char * partName,
      const char * demandName,
      WitBoolean * shipLateAllowed)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      shipLateAllowed, 
      "shipLateAllowed", 
      theCall.myDemand ()->shipLateAllowed ());
   }
d813 15
a827 15
      const char * partName,
      const char * demandName,
      int *        shipLateLimit)
   {
   int * shipLateUBval;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "demand",
         "shipLateLimit",
         "shipLateUB");
d829 1
a829 1
   witGetDemandShipLateUB (partName, demandName, & shipLateUBval);
d831 1
a831 1
   forbidNullArg (shipLateLimit, "shipLateLimit");
d833 1
a833 1
   * shipLateLimit = shipLateUBval[0];
d835 2
a836 2
   free (shipLateUBval);
   }
d841 5
a845 5
      const char * partName,
      const char * demandName,
      int * *      shipLateUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d847 2
a848 2
   apiGet (shipLateUB, "shipLateUB", theCall.myDemand ()->shipLateUB ());
   }
d853 11
a863 11
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & shipReward)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
       shipReward,
      "shipReward",
      theCall.myDemand ()->shipReward ());
   }
d868 16
a883 16
      const char * partName,
      const char * demandName,
      const int    thePer,
      int *        shipVarIndex)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   prepGetIndex (thePer);

   apiGet (
       shipVarIndex,
      "shipVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            shipVarIndex (theCall.myDemand (), thePer));
   }
d888 5
a892 5
      const char *         partName,
      const char *         demandName,
      const WitOVRealArg & shipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d894 2
a895 2
   apiGet (shipVol, "shipVol", theCall.myDemand ()->shipVol ());
   }
d900 25
a924 25
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   WitPartTripStack thePegTrips (myProblem ());

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getSideVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

   getPartPip (
      thePegTrips,
      lenLists,
      partNameList,
      periodList,
      peggedVolList);
   }
d929 65
a993 65
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              bomEntryIndexList,
      int * *              subsBomEntryIndexList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedSubVolList)
   {
   WitObjStack <WitFixedPegEl> theFixedPegEls (myProblem ());
   WitObjStItr <WitFixedPegEl> theItr;
   int                         nSubPegEls;
   int                         theIdx;
   WitFixedPegEl *             theFixedPegEl;
   WitSubEntry *               theSub;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPegging (shipPeriod);

   theCall.myDemand ()->getMyFixedPegEls (shipPeriod, theFixedPegEls);

   nSubPegEls = 0;

   theFixedPegEls.attachItr (theItr);

   while (theItr.advance (theFixedPegEl))
      if (theFixedPegEl->mySub () != NULL)
         nSubPegEls ++;

   apiGet (lenLists, "lenLists", nSubPegEls);

   forbidNullArg (operationNameList,     "operationNameList");
   forbidNullArg (bomEntryIndexList,     "bomEntryIndexList");
   forbidNullArg (subsBomEntryIndexList, "subsBomEntryIndexList");
   forbidNullArg (execPeriodList,        "execPeriodList");
   forbidNullArg (peggedSubVolList,      "peggedSubVolList");

   apiAlloc (operationNameList,     nSubPegEls);
   apiAlloc (bomEntryIndexList,     nSubPegEls);
   apiAlloc (subsBomEntryIndexList, nSubPegEls);
   apiAlloc (execPeriodList,        nSubPegEls);
   apiAlloc (peggedSubVolList,      nSubPegEls);
   
   theIdx = 0;

   while (theFixedPegEls.pop (theFixedPegEl))
      {
      theSub = theFixedPegEl->mySub ();

      if (theSub == NULL)
         continue;

      (* operationNameList)    [theIdx] = 
         theSub->myOperationName ().apiDupCstring ();

      (* bomEntryIndexList)    [theIdx] = theSub       ->myBomEntIndex ();
      (* subsBomEntryIndexList)[theIdx] = theSub       ->localIndex ();
      (* execPeriodList)       [theIdx] = theFixedPegEl->myExecPer ();
      peggedSubVolList         [theIdx] = theFixedPegEl->peggedVol ();

      theIdx ++;
      }
   }
d998 56
a1053 56
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           operationNameList,
      int * *              bomEntryIndexList,
      int * *              subsBomEntryIndexList,
      int * *              execPeriodList,
      const WitOVRealArg & peggedVolList)
   {
   WitSubTripStack subVolTrips (myProblem ());
   int             nTrips;
   int             theIdx;
   WitSubEntry *   theSub;
   WitPeriod       execPer;
   double          pgdSubVol;

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getSubVolTrips (theCall.myDemand (), shipPeriod, subVolTrips);

   nTrips = subVolTrips.nElements ();

   apiGet (lenLists, "lenLists", nTrips);

   forbidNullArg (operationNameList,     "operationNameList");
   forbidNullArg (bomEntryIndexList,     "bomEntryIndexList");
   forbidNullArg (subsBomEntryIndexList, "subsBomEntryIndexList");
   forbidNullArg (execPeriodList,        "execPeriodList");
   forbidNullArg (peggedVolList,         "peggedVolList");

   apiAlloc (operationNameList,     nTrips);
   apiAlloc (bomEntryIndexList,     nTrips);
   apiAlloc (subsBomEntryIndexList, nTrips);
   apiAlloc (execPeriodList,        nTrips);
   apiAlloc (peggedVolList,         nTrips);

   theIdx = -1;

   while (subVolTrips.pop (theSub, execPer, pgdSubVol))
      {
      theIdx ++;

      (* operationNameList)    [theIdx] = 
         theSub->myOperationName ().apiDupCstring ();

      (* bomEntryIndexList)    [theIdx] = theSub->myBomEntIndex ();
      (* subsBomEntryIndexList)[theIdx] = theSub->localIndex ();
      (* execPeriodList)       [theIdx] = execPer;
      peggedVolList            [theIdx] = pgdSubVol;
      }
   }
d1058 25
a1082 25
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   WitPartTripStack thePegTrips (myProblem ());

   WitDemandApiCall theCall (this, partName, demandName);

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getSupplyVolTrips (theCall.myDemand (), shipPeriod, thePegTrips);

   getPartPip (
      thePegTrips,
      lenLists,
      partNameList,
      periodList,
      peggedVolList);
   }
d1087 22
a1108 22
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      const WitISRealArg & desIncVol,
      const WitOSRealArg & incVol)
   {
   myApiMgr_->startInnerFunc ();

   if (myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("wrongFuncForTwmeSmsg",
         "witIncHeurAlloc",
         true,
         "witIncHeurAllocTwme");

   incHeurAlloc (
      partName,
      demandName,
      shipPeriod,
      desIncVol,
      incVol,
      false);
   }
d1113 23
a1135 23
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      const WitISRealArg & desIncVol,
      const WitOSRealArg & incVol,
      WitBoolean           asapMultiExec)
   {
   myApiMgr_->startInnerFunc ();

   if (not myGlobalComp ()->twoWayMultiExec ())
      myMsgFac () ("wrongFuncForTwmeSmsg",
         "witIncHeurAllocTwme",
         false,
         "witIncHeurAlloc");

   incHeurAlloc (
      partName,
      demandName,
      shipPeriod,
      desIncVol,
      incVol,
      asapMultiExec);
   }
d1140 5
a1144 5
      const char * partName,
      const char * demandName,
      void *       appData)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d1146 2
a1147 2
   theCall.setAppData (appData);
   }
d1152 11
a1162 11
      const char * partName,
      const char * demandName,
      const int *  buildAheadUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBuildAheadUB (buildAheadUB);

   if (theCall.argsOK ())
      theCall.myDemand ()->setBuildAheadUB (buildAheadUB);
   }
d1167 22
a1188 22
      const char * partName,
      const char * demandName,
      int          buildAheadLimit)
   {
   WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "demand",
         "buildAheadLimit",
         "buildAheadUB");

   buildAheadUBVec = buildAheadLimit;

   witSetDemandBuildAheadUB (
      partName, 
      demandName, 
      buildAheadUBVec.myCVec ());
d1190 2
a1191 2
   myApiMgr ()->releaseTempVecs ();
   }
d1196 14
a1209 14
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & hardLB,
      const WitIVRealArg & softLB,
      const WitIVRealArg & hardUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.setBoundSet (
      theCall.myDemand ()->cumShipBounds (), 
      hardLB,
      softLB,
      hardUB);
   }
d1214 11
a1224 11
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & cumShipReward)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepDblVec ("cumShipReward", cumShipReward);

   if (theCall.argsOK ())
      theCall.myDemand ()->setCumShipReward (cumShipReward);
   }
d1229 22
a1250 22
      const char * partName,
      const char * demandName,
      const char * newName)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   forbidNullArg (newName, "newName");

   if (isNullCstring (newName))
      myMsgFac () ("nullStringSmsg", "newName");

   if (myCompMgr ()->findDemand (theCall.myDemand ()->demandedPart (), newName))
      myMsgFac () ("setDemandNameToDupSmsg", newName);

   theCall.prepString (
                          "demandName",
      theCall.myDemand ()->demandName (),
                              newName);

   if (theCall.argsOK ())
      theCall.myDemand ()->setDemandName (newName);
   }
d1255 11
a1265 11
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & demandVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepNonNegDblVec ("demandVol", demandVol);

   if (theCall.argsOK ())
      theCall.myDemand ()->setDemandVol (demandVol);
   }
d1270 16
a1285 16
      const char * partName,
      const char * demandName,
      int          focusHorizon)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepRangedInt (
      "focusHorizon",
      theCall.myDemand ()->focusHorizon (),
      focusHorizon,
      - 1,
      theCall.myDemand ()->lastPeriod ());

   if (theCall.argsOK ())
      theCall.myDemand ()->setFocusHorizon (focusHorizon);
   }
d1290 11
a1300 11
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & fssShipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepNonNegDblVec ("fssShipVol", fssShipVol);

   if (theCall.argsOK ())
      theCall.myDemand ()->setFssShipVol (fssShipVol);
   }
d1305 14
a1318 14
      const char * partName,
      const char * demandName,
      WitBoolean   intShipVols)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBool (
      "intShipVols",
      theCall.myDemand ()->intShipVols (),
      intShipVols);

   if (theCall.argsOK ())
      theCall.myDemand ()->setIntShipVols (asaBool (intShipVols));
   }
d1323 11
a1333 11
      const char * partName,
      const char * demandName,
      const int *  leadTimeUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepLeadTimeUB (leadTimeUB);

   if (theCall.argsOK ())
      theCall.myDemand ()->setLeadTimeUB (leadTimeUB);
   }
d1338 19
a1356 19
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & obj1CumShipReward)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "demand",
         "obj1CumShipReward",
         "cumShipReward");

   witSetDemandCumShipReward (
      partName,
      demandName,
      obj1CumShipReward);
   }
d1361 19
a1379 19
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & obj1ShipReward)
   {
   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setAttrNewNameMsg"))
      myMsgFac () (
         "setAttrNewNameMsg",
         apiFuncName (),
         "demand",
         "obj1ShipReward",
         "shipReward");

   witSetDemandShipReward (
      partName,
      demandName,
      obj1ShipReward);
   }
d1384 14
a1397 14
      const char * partName,
      const char * demandName,
      WitBoolean   prefBuildAhead)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBool (
      "prefBuildAhead",
      theCall.myDemand ()->prefBuildAhead (),
      prefBuildAhead);

   if (theCall.argsOK ())
      theCall.myDemand ()->setPrefBuildAhead (asaBool (prefBuildAhead));
   }
d1402 11
a1412 11
      const char * partName,
      const char * demandName,
      const int *  priority)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepIntVec ("priority", priority);

   if (theCall.argsOK ())
      theCall.myDemand ()->setPriority (priority);
   }
d1417 16
a1432 16
      const char *         partName,
      const char *         demandName,
      const WitISRealArg & searchInc)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepLBDouble (
      "searchInc",
      theCall.myDemand ()->searchInc (),
      searchInc,
      0.000999,
      0.001);

   if (theCall.argsOK ())
      theCall.myDemand ()->setSearchInc (searchInc);
   }
d1437 5
a1441 5
      const char * partName,
      const char * demandName,
      WitBoolean   selForDel)
   {
   WitDemandApiCall theCall (this, partName, demandName);
d1443 2
a1444 2
   theCall.setSelForDel (selForDel);
   }
d1449 14
a1462 14
      const char * partName,
      const char * demandName,
      WitBoolean   shipLateAllowed)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBool (
      "shipLateAllowed",
      theCall.myDemand ()->shipLateAllowed (),
      shipLateAllowed);

   if (theCall.argsOK ())
      theCall.myDemand ()->setShipLateAllowed (asaBool (shipLateAllowed));
   }
d1467 22
a1488 22
      const char * partName,
      const char * demandName,
      int          shipLateLimit)
   {
   WitTVec <int> & buildAheadUBVec = myApiMgr ()->reserveTempIntVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "demand",
         "shipLateLimit",
         "shipLateUB");

   buildAheadUBVec = shipLateLimit;

   witSetDemandShipLateUB (
      partName, 
      demandName, 
      buildAheadUBVec.myCVec ());
d1490 2
a1491 2
   myApiMgr ()->releaseTempVecs ();
   }
d1496 11
a1506 11
      const char * partName,
      const char * demandName,
      const int *  shipLateUB)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepShipLateUB (shipLateUB);

   if (theCall.argsOK ())
      theCall.myDemand ()->setShipLateUB (shipLateUB);
   }
d1511 11
a1521 11
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & shipReward)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepDblVec ("shipReward", shipReward);

   if (theCall.argsOK ())
      theCall.myDemand ()->setShipReward (shipReward);
   }
d1526 11
a1536 11
      const char *         partName,
      const char *         demandName,
      const WitIVRealArg & shipVol)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepNonNegDblVec ("shipVol", shipVol);

   if (theCall.argsOK ())
      theCall.myDemand ()->setShipVol (shipVol);
   }
d1544 3
a1546 3
   {
   WitDemand * retVal;
   WitPart   * partP;
d1548 1
a1548 1
   partP = getPartP (partName);
d1550 1
a1550 1
   myInputID ()->setMyPart (partP);
d1552 1
a1552 1
   retVal = myCompMgr ()->findDemand (partP, demandName);
d1554 2
a1555 2
   if (retVal == NULL)
      myMsgFac () ("undefinedDemandMsg", demandName, partP->partName ());
d1557 1
a1557 1
   myInputID ()->setMyDemand (retVal);
d1559 2
a1560 2
   return retVal;
   }
d1569 89
a1657 89
      int                  lenLists,
      const char * const * partNameList,
      const char * const * demandNameList,
      const int *          shipPeriodList,
      const WitIVRealArg & desIncVolList,
      const WitOVRealArg & incVolList,
      const WitBoolean *   asapMultiExecList)
   {
   int              listIndex;
   int              dupIndex1;
   int              dupIndex2;
   WitDemand *      theDemand;
   WitPeriod        shipPer;
   bool             asapMultiExec;
   WitEqAllocator * theEqAllocator;
   WitDemPerStack   theDemPers (myProblem ());

   forbidStochMode ();

   forbidNullArg (partNameList,   "demandedPartNameList");
   forbidNullArg (demandNameList, "demandNameList");
   forbidNullArg (shipPeriodList, "shipPeriodList");
   forbidNullArg (desIncVolList,  "desIncVolList");
   forbidNullArg (incVolList   ,  "incVolList");

   if (myGlobalComp ()->twoWayMultiExec ())
      forbidNullArg (asapMultiExecList, "asapMultiExecList");
   else
      witAssert (asapMultiExecList == NULL);

   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");

   theEqAllocator = myProblem ()->myEqAllocator ();

   theEqAllocator->activate ();

   if (lenLists < 1)
      {
      myInputID ()->setArgName ("lenLists");

      myMsgFac () ("argRangeValGeIntSmsg", lenLists, 1);
      }

   for (listIndex = 0; listIndex < lenLists; ++ listIndex)
      {
      myInputID ()->setArgIndex (listIndex);

      asapMultiExec = 
         myGlobalComp ()->twoWayMultiExec ()?
            asaBool (asapMultiExecList[listIndex]):
            false;

      defineAllocTarget (
         partNameList  [listIndex],
         demandNameList[listIndex],
         shipPeriodList[listIndex],
         desIncVolList [listIndex],
         asapMultiExec,
         theDemPers);
      }

   theDemPers.reverse ();

   myInputID ()->setArgIndex (-1);

   if (theEqAllocator->containsDup (theDemPers, dupIndex1, dupIndex2))
      myMsgFac () ("dupTargetSmsg",
         dupIndex1,
         dupIndex2,
         partNameList  [dupIndex1],
         demandNameList[dupIndex1],
         shipPeriodList[dupIndex1]);

   theEqAllocator->eqAlloc (theDemPers);

   theEqAllocator->print (theDemPers);

   apiAlloc (incVolList, lenLists);

   listIndex = -1;

   while (theDemPers.pop (theDemand, shipPer))
      {
      listIndex ++;

      incVolList[listIndex] = theEqAllocator->incVol (theDemand, shipPer);
      }
   }
d1666 42
a1707 42
      const char *         partName,
      const char *         demandName,
      int                  shipPer,
      const WitISRealArg & desIncVol,
      const WitOSRealArg & incVol,
      WitBoolean           asapMultiExec)
   {
   WitDemandApiCall theCall (this, partName, demandName);
   double           incVolVal;

   if (myGlobalComp ()->twoWayMultiExec ())
      myProblem ()->myHeurAllMgr ()->printMeDir (asaBool (asapMultiExec));

   if (not myProblem ()->myHeurAllMgr ()->active ())
      myMsgFac () ("inactiveHeurAllocSmsg");

   if (not ((shipPer >= 0) and (shipPer < nPeriods ())))
      {
      myInputID ()->setArgName ("shipPer");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPer, 0, nPeriods ());
      }

   if (not (desIncVol.asaDbl () >= 0.0))
      {
      myInputID ()->setArgName ("desIncVol");

      myMsgFac () ("argRangeValGeDblSmsg", desIncVol, 0.0);
      }

   incVolVal =
      myProblem ()->myHeurAllMgr ()->incHeurAlloc (
         theCall.myDemand (), 
         shipPer, 
         desIncVol,
         asaBool (asapMultiExec));

   apiGet (incVol, "incVol", incVolVal);

   if (myMsgFac ().mayIssue ("incHeurDataMsg"))
      myMsgFac () ("incHeurDataMsg", shipPer, desIncVol, incVolVal);
   }
d1712 9
a1720 9
      const char *     partName,
      const char *     demandName,
      int              shipPer,
      double           desIncVol,
      bool             asapMultiExec,
      WitDemPerStack & theDemPers)
   {
   WitPart *   thePart;
   WitDemand * theDemand;
d1723 1
a1723 1
   forbidNullArg (partName, "demandedPartNameList");
d1725 1
a1725 1
   thePart = myCompMgr ()->findPart (partName);
d1727 3
a1729 3
   if (thePart == NULL)
      {
      myInputID ()->setArgName ("demandedPartNameList");
d1731 2
a1732 2
      myMsgFac () ("undefinedPartMsg", partName);
      }
d1734 1
a1734 1
   forbidNullArg (demandName, "demandNameList");
d1736 1
a1736 1
   theDemand = myCompMgr ()->findDemand (thePart, demandName);
d1738 3
a1740 3
   if (theDemand == NULL)
      {
      myInputID ()->setArgName ("demandNameList");
d1742 2
a1743 2
      myMsgFac () ("undefinedDemandMsg", demandName, partName);
      }
d1745 3
a1747 3
   if ((shipPer < 0) or (shipPer >= nPeriods ()))
      {
      myInputID ()->setArgName ("shipPeriodList");
d1749 2
a1750 2
      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPer, 0, nPeriods ());
      }
d1752 1
a1752 1
   theDemPers.push (theDemand, shipPer);
d1754 3
a1756 3
   if (desIncVol < 0.0)
      {
      myInputID ()->setArgName ("desIncVolList");
d1758 2
a1759 2
      myMsgFac () ("argRangeValGeDblSmsg", desIncVol, 0.0);
      }
d1761 1
a1761 1
   myProblem ()->myEqAllocator ()->setDesIncVol (theDemand, shipPer, desIncVol);
d1763 6
a1768 6
   if (myGlobalComp ()->twoWayMultiExec ())
       myProblem ()->myEqAllocator ()->setAsapMultiExec (
          theDemand, 
          shipPer, 
          asapMultiExec);
   }
d1773 14
a1786 14
   {
   if (myMsgFac ().mayIssue ("shipPerMsg"))
      myMsgFac () ("shipPerMsg", shipPeriod);

   if (not myGlobalComp ()->perfPegging ())
      myMsgFac () ("reqPerfPeggingSmsg");

   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputID ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }
   }
d1791 35
a1825 35
      WitPartTripStack &   thePegTrips,
      int *                lenLists,
      char * * *           partNameList,
      int * *              periodList,
      const WitOVRealArg & peggedVolList)
   {
   int       nTrips;
   int       theIdx;
   WitPart * thePart;
   WitPeriod pegPer;
   double    pegVol;

   nTrips = thePegTrips.nElements ();

   apiGet (lenLists, "lenLists", nTrips);

   forbidNullArg (partNameList,  "partNameList");
   forbidNullArg (periodList,    "periodList");
   forbidNullArg (peggedVolList, "peggedVolList");

   apiAlloc (partNameList,  nTrips);
   apiAlloc (periodList,    nTrips);
   apiAlloc (peggedVolList, nTrips);

   theIdx = -1;

   while (thePegTrips.pop (thePart, pegPer, pegVol))
      {
      theIdx ++;

      (* partNameList) [theIdx] = thePart->partName ().apiDupCstring ();
      (* periodList)   [theIdx] = pegPer;
      peggedVolList    [theIdx] = pegVol;
      }
   }
d1830 14
a1843 14
   {
   if (myMsgFac ().mayIssue ("shipPerMsg"))
      myMsgFac () ("shipPerMsg", shipPeriod);

   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputID ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }

   if (not myProblem ()->myPipMgr ()->peggingExists ())
      myMsgFac () ("needPipExistsSmsg");
   }
@


1.163
log
@Heuristic Adjustment
@
text
@a1601 3
   if (myProblem ()->myHeurAllMgr ()->heurAdjustActive ())
      myMsgFac () ("activeHeurAdjSmsg", myApiMgr_->apiFuncName ());

a1681 3
   if (myProblem ()->myHeurAllMgr ()->heurAdjustActive ())
      myMsgFac () ("activeHeurAdjSmsg", myApiMgr_->apiFuncName ());

@


1.162
log
@Heuristic Adjustment
@
text
@a25 1
#include <HeurAdjuster.h>
d1602 1
a1602 1
   if (myProblem ()->myHeurAdjuster ()->active ())
d1685 1
a1685 1
   if (myProblem ()->myHeurAdjuster ()->active ())
@


1.161
log
@Heuristic Adjustment
@
text
@d26 1
a26 1
#include <HeurAdjMgr.h>
d1603 1
a1603 1
   if (myProblem ()->myHeurAdjMgr ()->active ())
d1686 1
a1686 1
   if (myProblem ()->myHeurAdjMgr ()->active ())
@


1.160
log
@Heuristic Adjustment
@
text
@d34 1
a34 1
#include <Opn.h>
@


1.159
log
@Lead Time Bounds
@
text
@d26 1
d1603 3
d1686 3
@


1.158
log
@Bounded Lead Times
@
text
@d1697 1
a1697 1
      myProblem ()->myHeurAllMgr ()->inc (
@


1.157
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d639 12
d1322 15
@


1.156
log
@Removing objective #2.
@
text
@d30 1
a30 1
#include <Global.h>
@


1.155
log
@Fixed bug: myApiMgr_->startInnerFunc () was not being called.
@
text
@a623 12
void WitRun::witGetDemandGrossRev (
      const char *         partName,
      const char *         demandName,
      const WitOSRealArg & grossRev)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (grossRev, "grossRev", theCall.myDemand ()->grossRev ());
   }

//------------------------------------------------------------------------------

a1291 18
void WitRun::witSetDemandGrossRev (
      const char *         partName,
      const char *         demandName,
      const WitISRealArg & grossRev)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepNonNegDouble (
      "grossRev", 
      theCall.myDemand ()->grossRev (), 
      grossRev);

   if (theCall.argsOK ())
      theCall.myDemand ()->setGrossRev (grossRev);
   }

//------------------------------------------------------------------------------

@


1.154
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@d1093 2
d1120 2
@


1.153
log
@Object name change.
@
text
@d43 2
@


1.152
log
@Object name change.
@
text
@d88 1
a88 1
      myMsgFac () ("nullNameSmsg", demandName);
d1222 26
@


1.151
log
@Stochastic Implosion
@
text
@d87 1
a87 1
   if (isNullString (demandName))
@


1.150
log
@Stochastic Implosion
@
text
@d1229 1
a1229 1
   theCall.prepSetDemandDemandVol (demandVol);
@


1.149
log
@Stochastic Implosion
@
text
@a891 2
   theCall.prepGetStochSolnAttr ("shipVol");

@


1.148
log
@Stochastic Implosion
@
text
@d1231 1
a1231 1
   theCall.prepNonNegDblVec ("demandVol", demandVol);
@


1.147
log
@Stochastic Implosion
@
text
@d28 1
a28 1
#include <OptImp.h>
d426 1
a426 1
      myOptImploder ()->
d446 1
a446 1
      myOptImploder ()->
d466 1
a466 1
      myOptImploder ()->
d788 1
a788 1
      myOptImploder ()->
d878 1
a878 1
      myOptImploder ()->
@


1.146
log
@Stochastic Implosion
@
text
@a479 2
   theCall.prepGetStochAttr ();

@


1.145
log
@Stochastic Implosion
@
text
@a1232 2
   theCall.prepStochModeAttr ();

@


1.144
log
@Stochastic Implosion
@
text
@d1233 1
a1233 1
   theCall.prepStochDataModeAttr ();
d1563 1
a1563 1
   forbidStochDataMode ();
@


1.143
log
@Stochastic Implosion.
@
text
@d1554 8
a1561 7
   int               listIndex;
   int               dupIndex1;
   int               dupIndex2;
   WitDemand *       theDemand;
   WitPeriod         shipPer;
   bool              asapMultiExec;
   WitEqAllocator *  theEqAllocator;
d1563 1
a1563 3
   WitDemPerStack theDemPers (myProblem ());

   theEqAllocator = myProblem ()->myEqAllocator ();
d1579 2
@


1.142
log
@Stochastic Implosion
@
text
@d480 2
a482 2

   theCall.issueScenMsg ();
d894 2
a896 2

   theCall.issueScenMsg ();
@


1.141
log
@Stochastic Implosion
@
text
@d1233 1
a1233 1
   theCall.prepStochAttr ();
a1508 2
   theCall.prepStochAttr ();

@


1.140
log
@Stochastic Implosion
@
text
@d481 2
d895 2
d1233 1
a1233 1
   theCall.prepSetStochDataModeAttr ();
d1509 2
@


1.139
log
@Stochastic Implosion
@
text
@d1229 1
a1229 1
   theCall.setsStochModeAttr ();
@


1.138
log
@Stochastic Implosion.
@
text
@d1229 1
a1229 1
   theCall.setsStochAttr ();
@


1.137
log
@Stochastic implosion.
@
text
@d93 2
d1229 1
a1229 1
   theCall.allowStochAct ();
@


1.136
log
@Stochastic implosion.
@
text
@d1227 1
a1227 1
   theCall.attrIsDiffable ();
@


1.135
log
@Stochastic implosion.
@
text
@d1227 2
@


1.134
log
@Stochastic implosion.
@
text
@a92 2
   forbidAddStochAct ("demandFrag");

@


1.133
log
@[disallowed backlog]
@
text
@d93 2
@


1.132
log
@[disallowed backlog]
@
text
@a256 15
void WitRun::witGetDemandBacklogAllowed (
      const char * partName,
      const char * demandName,
      WitBoolean * backlogAllowed)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      backlogAllowed, 
      "backlogAllowed", 
      theCall.myDemand ()->backlogAllowed ());
   }

//------------------------------------------------------------------------------

d793 1
a793 1
void WitRun::witGetDemandShipLateUB (
d796 1
a796 1
      int * *      shipLateUB)
d800 4
a803 1
   apiGet (shipLateUB, "shipLateUB", theCall.myDemand ()->shipLateUB ());
d836 12
a1142 18
void WitRun::witSetDemandBacklogAllowed (
      const char * partName,
      const char * demandName,
      WitBoolean   backlogAllowed)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   theCall.prepBool (
      "backlogAllowed",
      theCall.myDemand ()->backlogAllowed (),
      backlogAllowed);

   if (theCall.argsOK ())
      theCall.myDemand ()->setBacklogAllowed (asaBool (backlogAllowed));
   }

//------------------------------------------------------------------------------

d1417 1
a1417 1
void WitRun::witSetDemandShipLateUB (
d1420 1
a1420 1
      const int *  shipLateUB)
d1424 4
a1427 1
   theCall.prepShipLateUB (shipLateUB);
d1430 1
a1430 1
      theCall.myDemand ()->setShipLateUB (shipLateUB);
d1464 15
@


1.131
log
@[disallowed backlog]
@
text
@a1149 3
   if (not myGlobalComp ()->allowDBL ())
      myMsgFac () ("attNYASmsg", "backlogAllowed");

@


1.130
log
@[disallowed backlog]
@
text
@d257 15
a497 15
void WitRun::witGetDemandDisallowBacklog (
      const char * partName,
      const char * demandName,
      WitBoolean * disallowBacklog)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      disallowBacklog, 
      "disallowBacklog", 
      theCall.myDemand ()->disallowBacklog ());
   }

//------------------------------------------------------------------------------

d1143 21
a1255 21
void WitRun::witSetDemandDisallowBacklog (
      const char * partName,
      const char * demandName,
      WitBoolean   disallowBacklog)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   if (not myGlobalComp ()->allowDBL ())
      myMsgFac () ("attNYASmsg", "disallowBacklog");

   theCall.prepBool (
      "disallowBacklog",
      theCall.myDemand ()->disallowBacklog (),
      disallowBacklog);

   if (theCall.argsOK ())
      theCall.myDemand ()->setDisallowBacklog (asaBool (disallowBacklog));
   }

//------------------------------------------------------------------------------

@


1.129
log
@[disallowed backlog]
@
text
@d1242 1
a1242 1
   if (not myGlobalComp ()->allowBLA ())
@


1.128
log
@Rescinded all changed made since 1/31/07.
@
text
@a256 15
void WitRun::witGetDemandBacklogAllowed (
      const char * partName,
      const char * demandName,
      WitBoolean * backlogAllowed)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   apiGet (
      backlogAllowed, 
      "backlogAllowed", 
      theCall.myDemand ()->backlogAllowed ());
   }

//------------------------------------------------------------------------------

d483 15
a1142 21
void WitRun::witSetDemandBacklogAllowed (
      const char * partName,
      const char * demandName,
      WitBoolean   backlogAllowed)
   {
   WitDemandApiCall theCall (this, partName, demandName);

   if (not myGlobalComp ()->allowBLA ())
      myMsgFac () ("attNYASmsg", "backlogAllowed");

   theCall.prepBool (
      "backlogAllowed",
      theCall.myDemand ()->backlogAllowed (),
      backlogAllowed);

   if (theCall.argsOK ())
      theCall.myDemand ()->setBacklogAllowed (asaBool (backlogAllowed));
   }

//------------------------------------------------------------------------------

d1235 21
@


1.127
log
@[disallowed backlog]
@
text
@a29 1
#include <FSS.h>
d1286 1
a1286 1
      myProblem ()->myFSS ()->setFssShipVol (theCall.myDemand (), fssShipVol);
@


1.126
log
@[backlog avoidance]
@
text
@d30 1
d1287 1
a1287 1
      theCall.myDemand ()->setFssShipVol (fssShipVol);
@


1.125
log
@witCopy<Object>Data
@
text
@d257 15
d1143 21
@


1.124
log
@witCopy<Object>Data
@
text
@d147 1
a147 1
   myMsgFac () ("dupObjectMsg",  myMsgFac ().myFrag ("demandFrag"));
d149 1
a149 1
   WitDemandApiCall dupCall (this,      dupPartName, dupDemandName);
@


1.123
log
@witCopy<Object>Data
@
text
@d139 5
a143 5
      const char * dstPartName,
      const char * dstDemandName,
      WitRun *     srcWitRun,
      const char * srcPartName,
      const char * srcDemandName)
d145 1
a145 1
   startCopyObjData (srcWitRun);
d147 1
a147 1
   myMsgFac () ("dstObjectMsg", myMsgFac ().myFrag ("demandFrag"));
d149 1
a149 1
   WitDemandApiCall dstCall (this,      dstPartName, dstDemandName);
d151 1
a151 1
   myMsgFac () ("srcObjectMsg", myMsgFac ().myFrag ("demandFrag"));
d153 1
a153 1
   WitDemandApiCall srcCall (srcWitRun, srcPartName, srcDemandName);
d155 1
a155 1
   if (dstCall.myDemand () == srcCall.myDemand ())
d159 1
a159 1
   dstCall.myDemand ()->copyAttrsFrom (srcCall.myDemand ());
@


1.122
log
@witCopy<Object>Data
@
text
@d147 2
d150 3
@


1.121
log
@External opt implosion.
@
text
@d40 1
d137 21
@


1.120
log
@External opt implosion.
@
text
@d29 1
a29 1
#include <ExtOptHand.h>
d398 1
a398 1
         myExtOptHandler ()->
d418 1
a418 1
         myExtOptHandler ()->
d438 1
a438 1
         myExtOptHandler ()->
d760 1
a760 1
         myExtOptHandler ()->
d835 1
a835 1
         myExtOptHandler ()->
@


1.119
log
@External opt implosion.
@
text
@d384 40
@


1.118
log
@External opt implosion.
@
text
@d388 1
a388 1
      int *        colIndex)
d395 2
a396 2
       colIndex,
      "colIndex",
d710 1
a710 1
      int *        rowIndex)
d717 2
a718 2
       rowIndex,
      "rowIndex",
d785 1
a785 1
      int *        colIndex)
d792 2
a793 2
       colIndex,
      "colIndex",
@


1.117
log
@External opt implosion.
@
text
@d392 1
a392 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d714 1
a714 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d789 1
a789 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
@


1.116
log
@External opt implosion.
@
text
@d28 2
d384 24
d710 24
d789 24
@


1.115
log
@External opt implosion.
@
text
@d69 2
d146 2
d175 2
d202 5
a206 1
   theDemand = curItrDelCompForGet (WitAT_DEMAND, "demandFrag")->thisDemand ();
d247 2
a332 1
   WitDemandApiCall theCall     (this, partName, demandName);
d335 2
a402 1
   WitDemandApiCall            theCall        (this, partName, demandName);
d410 2
d563 2
d586 2
a639 1
   WitDemandApiCall theCall     (this, partName, demandName);
d642 2
d703 2
a759 1
   WitDemandApiCall theCall     (this, partName, demandName);
d762 2
a790 1
   WitDemandApiCall            theCall        (this, partName, demandName);
d798 2
a917 1
   WitDemandApiCall theCall     (this, partName, demandName);
d920 2
d1021 2
d1167 2
d1190 2
d1295 2
@


1.114
log
@Heuristic search increment.
@
text
@d529 1
a529 1
void WitRun::witGetDemandIntConShipVols (
d532 1
a532 1
      WitBoolean * intConShipVols)
d537 3
a539 3
      intConShipVols, 
      "intConShipVols", 
      theCall.myDemand ()->intConShipVols ());
d1118 1
a1118 1
void WitRun::witSetDemandIntConShipVols (
d1121 1
a1121 1
      WitBoolean   intConShipVols)
d1126 3
a1128 3
      "intConShipVols",
      theCall.myDemand ()->intConShipVols (),
      intConShipVols);
d1131 1
a1131 1
      theCall.myDemand ()->setIntConShipVols (asaBool (intConShipVols));
@


1.113
log
@Heuristic search increment.
@
text
@a647 3
   if (not DEVELOPMENT)
      myMsgFac () ("attNotAvailSmsg", "demand", "searchInc");

a1217 3
   if (not DEVELOPMENT)
      myMsgFac () ("attNotAvailSmsg", "demand", "searchInc");

@


1.112
log
@App controlled opt implosion.
@
text
@d641 15
d1214 23
@


1.111
log
@App controlled opt implosion.
@
text
@a66 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a103 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a143 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a170 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a193 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a210 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a222 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a234 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a265 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a320 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a346 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a358 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a373 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a389 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a449 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a497 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a509 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a521 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a533 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a548 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a569 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a590 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a605 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a621 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a645 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a657 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a669 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a695 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a710 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a726 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a756 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a824 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a882 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a908 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a933 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a955 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a967 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a982 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1011 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1027 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1042 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1057 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1077 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1092 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1110 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1128 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1149 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1170 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1188 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1203 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1215 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1230 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1257 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a1272 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

@


1.110
log
@Integrality constraints.
@
text
@d67 4
d108 4
d152 4
d183 4
d210 4
d231 4
d247 4
d263 4
d298 4
d357 4
d387 4
d403 4
d422 4
d442 4
d506 4
d558 4
d574 4
d590 4
d606 4
d625 4
d650 4
d675 4
d694 4
d714 4
d742 4
d758 4
d774 4
d804 4
d823 4
d843 4
d877 4
d949 4
d1011 4
d1041 4
d1070 4
d1096 4
d1112 4
d1131 4
d1164 4
d1184 4
d1203 4
d1222 4
d1246 4
d1265 4
d1287 4
d1309 4
d1334 4
d1359 4
d1381 4
d1400 4
d1416 4
d1435 4
d1466 4
d1485 4
@


1.109
log
@Integrality constraints.
@
text
@d529 1
a529 1
void WitRun::witGetDemandIntShipVols (
d532 1
a532 1
      WitBoolean * intShipVols)
d537 3
a539 3
      intShipVols, 
      "intShipVols", 
      theCall.myDemand ()->intShipVols ());
d1106 1
a1106 1
void WitRun::witSetDemandIntShipVols (
d1109 1
a1109 1
      WitBoolean   intShipVols)
d1114 3
a1116 3
      "intShipVols",
      theCall.myDemand ()->intShipVols (),
      intShipVols);
d1119 1
a1119 1
      theCall.myDemand ()->setIntShipVols (asaBool (intShipVols));
@


1.108
log
@Opt implosion with integrality constraints.
@
text
@a1112 3
   if (not myGlobalComp ()->allowIntVars ())
      myMsgFac () ("attNYASmsg", "intShipVols");

@


1.107
log
@ExecVol pegging for BOP entries.
@
text
@d529 15
d1106 21
@


1.106
log
@BOP entry execVol pegging.
@
text
@d256 1
a256 1
void WitRun::witGetDemandCoexVolPip (
d266 1
a266 1
   WitBopEntTripStack coexVolTrips (myProblem ());
d271 1
a271 1
   double             pgdCoexVol;
d279 1
a279 1
         getCoexVolTrips (theCall.myDemand (), shipPeriod, coexVolTrips);
d281 1
a281 1
   nTrips = coexVolTrips.nElements ();
d297 1
a297 1
   while (coexVolTrips.pop (theBopEnt, execPer, pgdCoexVol))
d306 1
a306 1
      peggedVolList        [theIdx] = pgdCoexVol;
@


1.105
log
@Updated the copyright date on all source files.
@
text
@d33 1
d256 56
d448 1
a448 1
      const WitOVRealArg & peggedExecVolList)
d471 1
a471 1
   forbidNullArg (peggedExecVolList, "peggedExecVolList");
d475 1
a475 1
   apiAlloc (peggedExecVolList, nTrips);
d487 1
a487 1
      peggedExecVolList    [theIdx] = pgdExecVol;
d808 1
a808 1
      const WitOVRealArg & peggedSubVolList)
d833 1
a833 1
   forbidNullArg (peggedSubVolList,      "peggedSubVolList");
d839 1
a839 1
   apiAlloc (peggedSubVolList,      nTrips);
d853 1
a853 1
      peggedSubVolList         [theIdx] = pgdSubVol;
@


1.104
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.103
log
@[shared-resource pegging]
@
text
@d264 9
d274 1
a274 4
      partName,
      demandName,
      shipPeriod,
      WitPipPartAtt::consVol,
d550 9
d560 1
a560 4
      partName,
      demandName,
      shipPeriod,
      WitPipPartAtt::prodVol,
d655 9
d665 1
a665 4
      partName,
      demandName,
      shipPeriod,
      WitPipPartAtt::sideVol,
d811 9
d821 1
a821 4
      partName,
      demandName,
      shipPeriod,
      WitPipPartAtt::supplyVol,
d1443 1
a1443 4
      const char *         partName,
      const char *         demandName,
      int                  shipPeriod,
      WitPipPartAtt::Tag   theAttTag,
d1449 5
a1453 14
   WitDemandApiCall theCall     (this, partName, demandName);
   WitPartTripStack thePegTrips (myProblem ());
   int              nTrips;
   int              theIdx;
   WitPart *        thePart;
   WitPeriod        pegPer;
   double           pegVol;

   prepGetPip (shipPeriod);

   myProblem ()->
      myPipMgr ()->
         getPartPegTrips (
            theCall.myDemand (), shipPeriod, theAttTag, thePegTrips);
@


1.102
log
@[shared-resource pegging]
@
text
@d341 1
a341 1
   theFixedPegEls.attach (theItr);
d681 1
a681 1
   theFixedPegEls.attach (theItr);
@


1.101
log
@[multi-thread]
@
text
@d341 1
a341 1
   theItr.attachTo (theFixedPegEls);
d681 1
a681 1
   theItr.attachTo (theFixedPegEls);
@


1.100
log
@Removed code supporting the variable-argument-list API functions.
@
text
@a38 2
#include <ctype.h>

@


1.99
log
@[multi-thread]
@
text
@a94 71

void WitRun::witAddDemandVa (
      const char * partName,
      const char * demandName,
      va_list      argp)
   {
   WitAttr theAttr;
   float * hardlbP;
   float * softlbP;
   float * hardubP;

   witAddDemand (partName, demandName);

   if (argp == NULL)
      return;

   //--------------------------------------------------
   // Loop once for each attribute in calling sequence.
   //--------------------------------------------------

   for (theAttr =  va_arg (argp, WitAttr);
        theAttr != NULL;
        theAttr =  va_arg(argp, WitAttr))
      {
      if (theAttr == WitNbuildAheadLimit)
         witSetDemandBuildAheadLimit (partName, demandName, va_arg (argp, int));

      else if (theAttr == WitNpriority)
         witSetDemandPriority (partName, demandName, va_arg (argp, int *));

      else if (theAttr == WitNdemandVol)
         witSetDemandDemandVol (partName, demandName, va_arg (argp, float *));

      else if (theAttr == WitNobj1ShipReward)
         witSetDemandObj1ShipReward (
            partName,
            demandName,
            va_arg (argp, float *));

      else if (theAttr == WitNobj1CumShipReward)
         witSetDemandObj1CumShipReward (
            partName,
            demandName,
            va_arg (argp, float *));

      else if (theAttr == WitNcumShipBounds)
         {
         hardlbP = va_arg (argp, float *);
         softlbP = va_arg (argp, float *);
         hardubP = va_arg (argp, float *);

         witSetDemandCumShipBounds (
            partName,
            demandName,
            hardlbP,
            softlbP,
            hardubP);
         }

      else if (theAttr == WitNgrossRev)
         witSetDemandGrossRev (partName, demandName, va_arg (argp, double));

      else if (theAttr == WitNshipLateLimit)
         witSetDemandShipLateLimit (partName, demandName, va_arg (argp, int));

      else
         myMsgFac () ("undefinedAttrErrorMsg");
      }
   }

//------------------------------------------------------------------------------
@


1.98
log
@[multi-thread]
@
text
@a39 1
#include <stdarg.h>
@


1.97
log
@[multi-thread]
@
text
@d66 2
a67 2
      const char * partNameParm,
      const char * demandNameParm)
d69 7
a75 2
   witAddDemandVa (partNameParm, demandNameParm, NULL);
   }
d77 1
a77 1
//------------------------------------------------------------------------------
d79 2
a80 11
void WitRun::witAddDemandVa (
      const char * partNameParm,
      const char * demandNameParm,
      va_list      argp)
   {
   WitAttr     attr;
   WitDemand * newDemand;
   WitPart *   partP;
   float *     hardlbP;
   float *     softlbP;
   float *     hardubP;
d82 1
a82 2
   forbidNullArg (partNameParm,   "partName");
   forbidNullArg (demandNameParm, "demandName");
d84 2
a85 2
   if (myMsgFac ().mayIssue ("demandNameAdMsg"))
      myMsgFac () ("demandNameAdMsg", partNameParm, demandNameParm);
d87 2
a88 1
   partP = myCompMgr ()->findPart (partNameParm);
d90 1
a90 2
   if (partP == NULL)
      myMsgFac () ("undefinedPartMsg", partNameParm);
d92 2
a93 1
   myInputID ()->setMyPart (partP);
d95 1
a95 2
   if (isNullString (demandNameParm))
      myMsgFac () ("nullNameSmsg", demandNameParm);
d97 9
a105 2
   if (myCompMgr ()->findDemand (partP, demandNameParm) != NULL)
      myMsgFac () ("duplicateDemNameAdMsg", demandNameParm);
d107 1
a107 1
   newDemand = new WitDemand (demandNameParm, partP);
d109 2
a110 1
   myInputID ()->setMyDemand (newDemand);
d116 26
a141 4
   if (argp != NULL)
      for (attr =  va_arg (argp, WitAttr);
           attr != NULL;
           attr =  va_arg(argp, WitAttr))
d143 11
a153 55
         if (attr == WitNbuildAheadLimit)
            witSetDemandBuildAheadLimit (
               newDemand->demandedPartName ().myCstring (),
               newDemand->demandName       ().myCstring (),
               va_arg (argp, int));

         else if (attr == WitNpriority)
            witSetDemandPriority (
               newDemand->demandedPartName ().myCstring (),
               newDemand->demandName       ().myCstring (),
               va_arg (argp, int *));

         else if (attr == WitNdemandVol)
            witSetDemandDemandVol (
               newDemand->demandedPartName ().myCstring (),
               newDemand->demandName       ().myCstring (),
               va_arg (argp, float *));

         else if (attr == WitNobj1ShipReward)
            witSetDemandObj1ShipReward (
               newDemand->demandedPartName ().myCstring (),
               newDemand->demandName       ().myCstring (),
               va_arg (argp, float *));

         else if (attr == WitNobj1CumShipReward)
            witSetDemandObj1CumShipReward (
               newDemand->demandedPartName ().myCstring (),
               newDemand->demandName       ().myCstring (),
               va_arg (argp, float *));

         else if (attr == WitNcumShipBounds)
            {
            hardlbP = va_arg (argp, float *);
            softlbP = va_arg (argp, float *);
            hardubP = va_arg (argp, float *);

            witSetDemandCumShipBounds (
               newDemand->demandedPartName ().myCstring (),
               newDemand->demandName       ().myCstring (),
               hardlbP,
               softlbP,
               hardubP);
            }

         else if (attr == WitNgrossRev)
            witSetDemandGrossRev (
               newDemand->demandedPartName ().myCstring (),
               newDemand->demandName       ().myCstring (),
               va_arg (argp, double));

         else if (attr == WitNshipLateLimit)
            witSetDemandShipLateLimit (
               newDemand->demandedPartName ().myCstring (),
               newDemand->demandName       ().myCstring (),
               va_arg (argp, int));
d155 2
a156 3
         else
            myMsgFac () ("undefinedAttrErrorMsg");
      }
d158 2
a159 3
   //------------
   // End of Loop
   //------------
d161 3
a163 2
   myInputID ()->setMyPart   (NULL);
   myInputID ()->setMyDemand (NULL);
@


1.96
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d40 1
@


1.95
log
@[multi-threads]
@
text
@a16 1
#include <ProEpilog.h>
d64 1
a64 1
WitReturnCode WitRun::witAddDemand (
a67 6
   PROLOG ("witAddDemand");

   if (myApiMgr ()->calledByApp ())
      if (myMsgFac ().mayIssue ("demandNameAdMsg"))
         myMsgFac () ("demandNameAdMsg", partNameParm, demandNameParm);

a68 2

   EPILOG;
d73 1
a73 1
WitReturnCode WitRun::witAddDemandVa (
a84 2
   PROLOG ("witAddDemandVa");

d88 2
a89 3
   if (myApiMgr ()->calledByApp ())
      if (myMsgFac ().mayIssue ("demandNameAdMsg"))
         myMsgFac () ("demandNameAdMsg", partNameParm, demandNameParm);
a182 2

   EPILOG;
d190 1
a190 1
WitReturnCode WitRun::witAppendToPipSeq (
a195 2
   PROLOG ("witAppendToPipSeq");

a220 2

   EPILOG;
d228 1
a228 1
WitReturnCode WitRun::witEqHeurAlloc (
a235 2
   PROLOG ("witEqHeurAlloc");

a249 2

   EPILOG;
d254 1
a254 1
WitReturnCode WitRun::witEqHeurAllocTwme (
a262 2
   PROLOG ("witEqHeurAllocTwme");

a277 2

   EPILOG;
d282 1
a282 1
WitReturnCode WitRun::witGetObjItrDemand (
a287 2
   PROLOG ("witGetObjItrDemand");

a293 2

   EPILOG;
d298 1
a298 1
WitReturnCode WitRun::witGetDemandAppData (
a302 2
   PROLOG ("witGetDemandAppData");

a305 2

   EPILOG;
d310 1
a310 1
WitReturnCode WitRun::witGetDemandBuildAheadUB (
a314 2
   PROLOG ("witGetDemandBuildAheadUB");

a317 2

   EPILOG;
d322 1
a322 1
WitReturnCode WitRun::witGetDemandBuildAheadLimit (
a326 2
   PROLOG ("witGetDemandBuildAheadLimit");

a343 2

   EPILOG;
d348 1
a348 1
WitReturnCode WitRun::witGetDemandConsVolPip (
a356 2
   PROLOG ("witGetDemandConsVolPip");

a365 2

   EPILOG;
d370 1
a370 1
WitReturnCode WitRun::witGetDemandCumShipBounds (
a376 2
   PROLOG ("witGetDemandCumShipBounds");

a379 2

   EPILOG;
d384 1
a384 1
WitReturnCode WitRun::witGetDemandCumShipReward (
a388 2
   PROLOG ("witGetDemandCumShipReward");

a394 2

   EPILOG;
d399 1
a399 1
WitReturnCode WitRun::witGetDemandDemandVol (
a403 2
   PROLOG ("witGetDemandDemandVol");

a406 2

   EPILOG;
d411 1
a411 1
WitReturnCode WitRun::witGetDemandExecVolPegging (
a419 2
   PROLOG ("witGetDemandExecVolPegging");

a466 2

   EPILOG;
d471 1
a471 1
WitReturnCode WitRun::witGetDemandExecVolPip (
a479 2
   PROLOG ("witGetDemandExecVolPip");

a518 2

   EPILOG;
d523 1
a523 1
WitReturnCode WitRun::witGetDemandFocusHorizon (
a527 2
   PROLOG ("witGetDemandFocusHorizon");

a530 2

   EPILOG;
d535 1
a535 1
WitReturnCode WitRun::witGetDemandFssShipVol (
a539 2
   PROLOG ("witGetDemandFssShipVol");

a542 2

   EPILOG;
d547 1
a547 1
WitReturnCode WitRun::witGetDemandGrossRev (
a551 2
   PROLOG ("witGetDemandGrossRev");

a554 2

   EPILOG;
d559 1
a559 1
WitReturnCode WitRun::witGetDemandObj1CumShipReward (
a563 2
   PROLOG ("witGetDemandObj1CumShipReward");

a575 2

   EPILOG;
d580 1
a580 1
WitReturnCode WitRun::witGetDemandObj1ShipReward (
a584 2
   PROLOG ("witGetDemandObj1ShipReward");

a596 2

   EPILOG;
d601 1
a601 1
WitReturnCode WitRun::witGetDemandPrefBuildAhead (
a605 2
   PROLOG ("witGetDemandPrefBuildAhead");

a611 2

   EPILOG;
d616 1
a616 1
WitReturnCode WitRun::witGetDemandPriority (
a620 2
   PROLOG ("witGetDemandPriority");

a623 2

   EPILOG;
d628 1
a628 1
WitReturnCode WitRun::witGetDemandProdVolPip (
a636 2
   PROLOG ("witGetDemandProdVolPip");

a645 2

   EPILOG;
d650 1
a650 1
WitReturnCode WitRun::witGetDemandSelForDel (
a654 2
   PROLOG ("witGetDemandSelForDel");

a657 2

   EPILOG;
d662 1
a662 1
WitReturnCode WitRun::witGetDemandShipLateUB (
a666 2
   PROLOG ("witGetDemandShipLateUB");

a669 2

   EPILOG;
d674 1
a674 1
WitReturnCode WitRun::witGetDemandShipLateLimit (
a678 2
   PROLOG ("witGetDemandShipLateLimit");

a695 2

   EPILOG;
d700 1
a700 1
WitReturnCode WitRun::witGetDemandShipReward (
a704 2
   PROLOG ("witGetDemandShipReward");

a710 2

   EPILOG;
d715 1
a715 1
WitReturnCode WitRun::witGetDemandShipVol (
a719 2
   PROLOG ("witGetDemandShipVol");

a722 2

   EPILOG;
d727 1
a727 1
WitReturnCode WitRun::witGetDemandSideVolPip (
a735 2
   PROLOG ("witGetDemandSideVolPip");

a744 2

   EPILOG;
d749 1
a749 1
WitReturnCode WitRun::witGetDemandSubVolPegging (
a759 2
   PROLOG ("witGetDemandSubVolPegging");

a812 2

   EPILOG;
d817 1
a817 1
WitReturnCode WitRun::witGetDemandSubVolPip (
a827 2
   PROLOG ("witGetDemandSubVolPip");

a872 2

   EPILOG;
d877 1
a877 1
WitReturnCode WitRun::witGetDemandSupplyVolPip (
a885 2
   PROLOG ("witGetDemandSupplyVolPip");

a894 2

   EPILOG;
d899 1
a899 1
WitReturnCode WitRun::witIncHeurAlloc (
a905 2
   PROLOG ("witIncHeurAlloc");

a918 2

   EPILOG;
d923 1
a923 1
WitReturnCode WitRun::witIncHeurAllocTwme (
a930 2
   PROLOG ("witIncHeurAllocTwme");

a943 2

   EPILOG;
d948 1
a948 1
WitReturnCode WitRun::witSetDemandAppData (
a952 2
   PROLOG ("witSetDemandAppData");

a955 2

   EPILOG;
d960 1
a960 1
WitReturnCode WitRun::witSetDemandBuildAheadUB (
a964 2
   PROLOG ("witSetDemandBuildAheadUB");

a970 2

   EPILOG;
d975 1
a975 1
WitReturnCode WitRun::witSetDemandBuildAheadLimit (
a979 2
   PROLOG ("witSetDemandBuildAheadLimit");

a997 2

   EPILOG;
d1002 1
a1002 1
WitReturnCode WitRun::witSetDemandCumShipBounds (
a1008 2
   PROLOG ("witSetDemandCumShipBounds");

a1015 2

   EPILOG;
d1020 1
a1020 1
WitReturnCode WitRun::witSetDemandCumShipReward (
a1024 2
   PROLOG ("witSetDemandCumShipReward");

a1030 2

   EPILOG;
d1035 1
a1035 1
WitReturnCode WitRun::witSetDemandDemandVol (
a1039 2
   PROLOG ("witSetDemandDemandVol");

a1045 2

   EPILOG;
d1050 1
a1050 1
WitReturnCode WitRun::witSetDemandFocusHorizon (
a1054 2
   PROLOG ("witSetDemandFocusHorizon");

a1065 2

   EPILOG;
d1070 1
a1070 1
WitReturnCode WitRun::witSetDemandFssShipVol (
a1074 2
   PROLOG ("witSetDemandFssShipVol");

a1080 2

   EPILOG;
d1085 1
a1085 1
WitReturnCode WitRun::witSetDemandGrossRev (
a1089 2
   PROLOG ("witSetDemandGrossRev");

a1098 2

   EPILOG;
d1103 1
a1103 1
WitReturnCode WitRun::witSetDemandObj1CumShipReward (
a1107 2
   PROLOG ("witSetDemandObj1CumShipReward");

a1119 2

   EPILOG;
d1124 1
a1124 1
WitReturnCode WitRun::witSetDemandObj1ShipReward (
a1128 2
   PROLOG ("witSetDemandObj1ShipReward");

a1140 2

   EPILOG;
d1145 1
a1145 1
WitReturnCode WitRun::witSetDemandPrefBuildAhead (
a1149 2
   PROLOG ("witSetDemandPrefBuildAhead");

a1158 2

   EPILOG;
d1163 1
a1163 1
WitReturnCode WitRun::witSetDemandPriority (
a1167 2
   PROLOG ("witSetDemandPriority");

a1173 2

   EPILOG;
d1178 1
a1178 1
WitReturnCode WitRun::witSetDemandSelForDel (
a1182 2
   PROLOG ("witSetDemandSelForDel");

a1185 2

   EPILOG;
d1190 1
a1190 1
WitReturnCode WitRun::witSetDemandShipLateUB (
a1194 2
   PROLOG ("witSetDemandShipLateUB");

a1200 2

   EPILOG;
d1205 1
a1205 1
WitReturnCode WitRun::witSetDemandShipLateLimit (
a1209 2
   PROLOG ("witSetDemandShipLateLimit");

a1227 2

   EPILOG;
d1232 1
a1232 1
WitReturnCode WitRun::witSetDemandShipReward (
a1236 2
   PROLOG ("witSetDemandShipReward");

a1242 2

   EPILOG;
d1247 1
a1247 1
WitReturnCode WitRun::witSetDemandShipVol (
a1251 2
   PROLOG ("witSetDemandShipVol");

a1257 2

   EPILOG;
@


1.94
log
@[exceptions]
@
text
@d71 1
a71 1
   if (myApiMgr ()->applicationCalled ())
d99 1
a99 1
   if (myApiMgr ()->applicationCalled ())
@


1.93
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@d17 1
d19 1
d108 1
a108 1
   myInputId ()->setMyPart (partP);
d118 1
a118 1
   myInputId ()->setMyDemand (newDemand);
d193 2
a194 2
   myInputId ()->setMyPart   (NULL);
   myInputId ()->setMyDemand (NULL);
d222 1
a222 1
      myInputId ()->setArgName ("shipPeriod");
d229 1
a229 1
      myInputId ()->setArgName ("incShipVol");
d1486 1
a1486 1
   myInputId ()->setMyPart (partP);
d1493 1
a1493 1
   myInputId ()->setMyDemand (retVal);
d1543 1
a1543 1
      myInputId ()->setArgName ("lenLists");
d1550 1
a1550 1
      myInputId ()->setArgIndex (listIndex);
d1568 1
a1568 1
   myInputId ()->setArgIndex (-1);
d1619 1
a1619 1
      myInputId ()->setArgName ("shipPer");
d1626 1
a1626 1
      myInputId ()->setArgName ("desIncVol");
d1664 1
a1664 1
      myInputId ()->setArgName ("demandedPartNameList");
d1675 1
a1675 1
      myInputId ()->setArgName ("demandNameList");
d1682 1
a1682 1
      myInputId ()->setArgName ("shipPeriodList");
d1691 1
a1691 1
      myInputId ()->setArgName ("desIncVolList");
d1717 1
a1717 1
      myInputId ()->setArgName ("shipPeriod");
d1783 1
a1783 1
      myInputId ()->setArgName ("shipPeriod");
@


1.92
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d432 19
d642 7
a648 1
   WitDemandApiCall theCall (this, partName, demandName);
d650 4
a653 4
   apiGet (
       obj1CumShipReward,
      "obj1CumShipReward",
      theCall.myDemand ()->obj1CumShipReward ());
d667 7
a673 1
   WitDemandApiCall theCall (this, partName, demandName);
d675 4
a678 4
   apiGet (
       obj1ShipReward,
      "obj1ShipReward",
      theCall.myDemand ()->obj1ShipReward ());
d808 19
d1176 19
d1286 7
a1292 1
   WitDemandApiCall theCall (this, partName, demandName);
d1294 4
a1297 4
   theCall.prepDblVec ("obj1CumShipReward", obj1CumShipReward);

   if (theCall.argsOK ())
      theCall.myDemand ()->setObj1CumShipReward (obj1CumShipReward);
d1311 7
a1317 1
   WitDemandApiCall theCall (this, partName, demandName);
d1319 4
a1322 4
   theCall.prepDblVec ("obj1ShipReward", obj1ShipReward);

   if (theCall.argsOK ())
      theCall.myDemand ()->setObj1ShipReward (obj1ShipReward);
d1436 19
@


1.91
log
@Vector PropRtg.
@
text
@d625 1
a625 1
   apiGetObj1Vector (
d644 1
a644 1
   apiGetObj1Vector (
d1219 1
a1219 1
   theCall.prepObj1Vec ("obj1CumShipReward", obj1CumShipReward);
d1238 1
a1238 1
   theCall.prepObj1Vec ("obj1ShipReward", obj1ShipReward);
@


1.90
log
@Vector PropRt.
@
text
@d1080 1
a1080 1
   WitTVec <int> & tempIntVecRef = myApiMgr ()->reserveTempIntVec ();
d1090 1
a1090 1
   tempIntVecRef = buildAheadLimit;
d1095 1
a1095 1
      tempIntVecRef.myCVec ());
d1331 1
a1331 1
   WitTVec <int> & tempIntVecRef = myApiMgr ()->reserveTempIntVec ();
d1341 1
a1341 1
   tempIntVecRef = shipLateLimit;
d1346 1
a1346 1
      tempIntVecRef.myCVec ());
@


1.89
log
@Pegged Critical List.
@
text
@d19 4
a22 4
#include <InScalRA.h>
#include <OutScalRA.h>
#include <InVecRA.h>
#include <OutVecRA.h>
d204 3
a206 3
      const char *        demandName,
      int                 shipPeriod,
      const WitInScalRA & incShipVol)
d249 2
a250 2
      const WitInVecRA &   desIncVolList,
      const WitOutVecRA &  incVolList)
d279 2
a280 2
      const WitInVecRA &   desIncVolList,
      const WitOutVecRA &  incVolList,
d389 7
a395 7
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      int *               lenLists,
      char * * *          partNameList,
      int * *             periodList,
      const WitOutVecRA & peggedVolList)
d415 5
a419 5
      const char *        partName,
      const char *        demandName,
      const WitOutVecRA & hardLB,
      const WitOutVecRA & softLB,
      const WitOutVecRA & hardUB)
d433 3
a435 3
      const char *        partName,
      const char *        demandName,
      const WitOutVecRA & demandVol)
d449 7
a455 7
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      int *               lenLists,
      char * * *          operationNameList,
      int * *             execPeriodList,
      const WitOutVecRA & peggedExecVolList)
d513 7
a519 7
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      int *               lenLists,
      char * * *          operationNameList,
      int * *             execPeriodList,
      const WitOutVecRA & peggedExecVolList)
d585 3
a587 3
      const char *        partName,
      const char *        demandName,
      const WitOutVecRA & fssShipVol)
d603 1
a603 1
      const WitOutScalRA & grossRev)
d617 3
a619 3
      const char *        partName,
      const char *        demandName,
      const WitOutVecRA & obj1CumShipReward)
d636 3
a638 3
      const char *        partName,
      const char *        demandName,
      const WitOutVecRA & obj1ShipReward)
d690 7
a696 7
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      int *               lenLists,
      char * * *          partNameList,
      int * *             periodList,
      const WitOutVecRA & peggedVolList)
d778 3
a780 3
      const char *        partName,
      const char *        demandName,
      const WitOutVecRA & shipVol)
d794 7
a800 7
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      int *               lenLists,
      char * * *          partNameList,
      int * *             periodList,
      const WitOutVecRA & peggedVolList)
d820 9
a828 9
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      int *               lenLists,
      char * * *          operationNameList,
      int * *             bomEntryIndexList,
      int * *             subsBomEntryIndexList,
      int * *             execPeriodList,
      const WitOutVecRA & peggedSubVolList)
d892 9
a900 9
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      int *               lenLists,
      char * * *          operationNameList,
      int * *             bomEntryIndexList,
      int * *             subsBomEntryIndexList,
      int * *             execPeriodList,
      const WitOutVecRA & peggedSubVolList)
d956 7
a962 7
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      int *               lenLists,
      char * * *          partNameList,
      int * *             periodList,
      const WitOutVecRA & peggedVolList)
d985 2
a986 2
      const WitInScalRA &  desIncVol,
      const WitOutScalRA & incVol)
d1013 2
a1014 2
      const WitInScalRA &  desIncVol,
      const WitOutScalRA & incVol,
d1105 5
a1109 5
      const char *       partName,
      const char *       demandName,
      const WitInVecRA & hardLB,
      const WitInVecRA & softLB,
      const WitInVecRA & hardUB)
d1127 3
a1129 3
      const char *       partName,
      const char *       demandName,
      const WitInVecRA & demandVol)
d1170 3
a1172 3
      const char *       partName,
      const char *       demandName,
      const WitInVecRA & fssShipVol)
d1189 3
a1191 3
      const char *        partName,
      const char *        demandName,
      const WitInScalRA & grossRev)
d1211 3
a1213 3
      const char *       partName,
      const char *       demandName,
      const WitInVecRA & obj1CumShipReward)
d1230 3
a1232 3
      const char *       partName,
      const char *       demandName,
      const WitInVecRA & obj1ShipReward)
d1356 3
a1358 3
      const char *       partName,
      const char *       demandName,
      const WitInVecRA & shipVol)
d1407 2
a1408 2
      const WitInVecRA &   desIncVolList,
      const WitOutVecRA &  incVolList,
d1502 2
a1503 2
      const WitInScalRA &  desIncVol,
      const WitOutScalRA & incVol,
d1624 8
a1631 8
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      WitPipPartAtt::Tag  theAttTag,
      int *               lenLists,
      char * * *          partNameList,
      int * *             periodList,
      const WitOutVecRA & peggedVolList)
@


1.88
log
@Tie Breaking Prop-Rt.
@
text
@d498 1
a498 1
      (* operationNameList)[theIdx] = dupCstring (theOpn->operationName ());
d556 1
a556 1
      (* operationNameList)[theIdx] = dupCstring (theOpn->operationName ());
d876 1
a876 1
         dupCstring (theSub->myOperationName ());
d941 2
a942 2
      (* operationNameList)    [theIdx] =
         dupCstring (theSub->myOperationName ());
d1666 1
a1666 1
      (* partNameList) [theIdx] = dupCstring (thePart->partName ());
@


1.87
log
@Minor change.
@
text
@d26 1
a26 1
#include <PipSysMgr.h>
d232 3
a234 4
   myProblem ()->myPipSysMgr ()->appendToShipSeq (
      theCall.myDemand (),
      shipPeriod,
      incShipVol);
d403 1
a403 1
      WitPip::consVolAtt,
d534 3
a536 4
   myProblem ()->myPipSysMgr ()->getExecVolTrips (
      theCall.myDemand (), 
      shipPeriod, 
      execVolTrips);
d704 1
a704 1
      WitPip::prodVolAtt,
d808 1
a808 1
      WitPip::sideVolAtt,
d915 3
a917 4
   myProblem ()->myPipSysMgr ()->getSubVolTrips (
      theCall.myDemand (), 
      shipPeriod, 
      subVolTrips);
d970 1
a970 1
      WitPip::supplyVolAtt,
d1627 1
a1627 1
      WitPip::PartAtt     thePartAtt,
d1643 4
a1646 5
   myProblem ()->myPipSysMgr ()->getPartPegTrips (
      theCall.myDemand (), 
      shipPeriod, 
      thePartAtt,
      thePegTrips);
d1686 1
a1686 1
   if (not myProblem ()->myPipSysMgr ()->peggingExists ())
@


1.86
log
@Removed portableFree.
@
text
@a32 1
#include <wit.h>
@


1.85
log
@Double Precision.
@
text
@d383 1
a383 1
   portableFree (buildAheadUBval);
d773 1
a773 1
   portableFree (shipLateUBval);
@


1.84
log
@Double Precision.
@
text
@d230 1
a230 1
      myMsgFac () ("argRangeValGeFloatSmsg", incShipVol, 0.0);
d1530 1
a1530 1
      myMsgFac () ("argRangeValGeFloatSmsg", desIncVol, 0.0);
d1595 1
a1595 1
      myMsgFac () ("argRangeValGeFloatSmsg", desIncVol, 0.0);
@


1.83
log
@Double Precision.
@
text
@d1094 1
a1094 1
   tempIntVecRef.setToScalar (buildAheadLimit);
d1345 1
a1345 1
   tempIntVecRef.setToScalar (shipLateLimit);
@


1.82
log
@Double Precision.
@
text
@d226 1
a226 1
   if (not (incShipVol >= 0.0))
d1526 1
a1526 1
   if (not (desIncVol >= 0.0))
@


1.81
log
@Double Precision.
@
text
@d391 7
a397 7
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   partNameList,
      int * *      periodList,
      float * *    peggedVolList)
d515 7
a521 7
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   operationNameList,
      int * *      execPeriodList,
      float * *    peggedExecVolList)
d563 1
a563 1
      (* peggedExecVolList)[theIdx] = pgdExecVol;
d693 7
a699 7
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   partNameList,
      int * *      periodList,
      float * *    peggedVolList)
d797 7
a803 7
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   partNameList,
      int * *      periodList,
      float * *    peggedVolList)
d895 9
a903 9
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   operationNameList,
      int * *      bomEntryIndexList,
      int * *      subsBomEntryIndexList,
      int * *      execPeriodList,
      float * *    peggedSubVolList)
d951 1
a951 1
      (* peggedSubVolList)     [theIdx] = pgdSubVol;
d960 7
a966 7
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   partNameList,
      int * *      periodList,
      float * *    peggedVolList)
d1628 8
a1635 8
      const char *    partName,
      const char *    demandName,
      int             shipPeriod,
      WitPip::PartAtt thePartAtt,
      int *           lenLists,
      char * * *      partNameList,
      int * *         periodList,
      float * *       peggedVolList)
d1673 1
a1673 1
      (* peggedVolList)[theIdx] = pegVol;
@


1.80
log
@Double Precision.
@
text
@d487 3
a489 4
   apiAlloc (* operationNameList, nOpnPegEls);
   apiAlloc (* execPeriodList,    nOpnPegEls);

   peggedExecVolList.apiAlloc (nOpnPegEls);
d549 3
a551 3
   apiAlloc    (* operationNameList, nTrips);
   apiAlloc    (* execPeriodList,    nTrips);
   apiAlloc    (* peggedExecVolList, nTrips);
d863 5
a867 6
   apiAlloc (* operationNameList,     nSubPegEls);
   apiAlloc (* bomEntryIndexList,     nSubPegEls);
   apiAlloc (* subsBomEntryIndexList, nSubPegEls);
   apiAlloc (* execPeriodList,        nSubPegEls);

   peggedSubVolList.apiAlloc (nSubPegEls);
d933 5
a937 5
   apiAlloc    (* operationNameList,     nTrips);
   apiAlloc    (* bomEntryIndexList,     nTrips);
   apiAlloc    (* subsBomEntryIndexList, nTrips);
   apiAlloc    (* execPeriodList,        nTrips);
   apiAlloc    (* peggedSubVolList,      nTrips);
d1484 1
a1484 1
   incVolList.apiAlloc (lenLists);
d1661 3
a1663 3
   apiAlloc    (* partNameList,  nTrips);
   apiAlloc    (* periodList,    nTrips);
   apiAlloc    (* peggedVolList, nTrips);
@


1.79
log
@Double Precision.
@
text
@d483 3
a485 3
   forbidNullArg (operationNameList,             "operationNameList");
   forbidNullArg (execPeriodList,                "execPeriodList");
   forbidNullArg (peggedExecVolList.asaTlPtr (), "peggedExecVolList");
d858 5
a862 5
   forbidNullArg (operationNameList,            "operationNameList");
   forbidNullArg (bomEntryIndexList,            "bomEntryIndexList");
   forbidNullArg (subsBomEntryIndexList,        "subsBomEntryIndexList");
   forbidNullArg (execPeriodList,               "execPeriodList");
   forbidNullArg (peggedSubVolList.asaTlPtr (), "peggedSubVolList");
d1429 5
a1433 5
   forbidNullArg (partNameList,              "demandedPartNameList");
   forbidNullArg (demandNameList,            "demandNameList");
   forbidNullArg (shipPeriodList,            "shipPeriodList");
   forbidNullArg (desIncVolList.asaTlPtr (), "desIncVolList");
   forbidNullArg (incVolList   .asaTlPtr (), "incVolList");
@


1.78
log
@Double Precision.
@
text
@d451 7
a457 7
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   operationNameList,
      int * *      execPeriodList,
      float * *    peggedExecVolList)
d483 8
a490 3
   forbidNullArg (operationNameList, "operationNameList");
   forbidNullArg (execPeriodList,    "execPeriodList");
   forbidNullArg (peggedExecVolList, "peggedExecVolList");
a491 4
   apiAlloc    (* operationNameList, nOpnPegEls);
   apiAlloc    (* execPeriodList,    nOpnPegEls);
   apiAlloc    (* peggedExecVolList, nOpnPegEls);
   
d504 2
a505 1
      (* peggedExecVolList)[theIdx] = theFixedPegEl->peggedVol ();
d824 9
a832 9
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   operationNameList,
      int * *      bomEntryIndexList,
      int * *      subsBomEntryIndexList,
      int * *      execPeriodList,
      float * *    peggedSubVolList)
d858 12
a869 11
   forbidNullArg (operationNameList,     "operationNameList");
   forbidNullArg (bomEntryIndexList,     "bomEntryIndexList");
   forbidNullArg (subsBomEntryIndexList, "subsBomEntryIndexList");
   forbidNullArg (execPeriodList,        "execPeriodList");
   forbidNullArg (peggedSubVolList,      "peggedSubVolList");

   apiAlloc    (* operationNameList,     nSubPegEls);
   apiAlloc    (* bomEntryIndexList,     nSubPegEls);
   apiAlloc    (* subsBomEntryIndexList, nSubPegEls);
   apiAlloc    (* execPeriodList,        nSubPegEls);
   apiAlloc    (* peggedSubVolList,      nSubPegEls);
d886 1
a886 1
      (* peggedSubVolList)     [theIdx] = theFixedPegEl->peggedVol ();
@


1.77
log
@Double Precision.
@
text
@d22 1
d251 2
a252 2
      const float *        desIncVolList,
      float * *            incVolList)
d281 2
a282 2
      const float *        desIncVolList,
      float * *            incVolList,
d1410 2
a1411 2
      const float *        desIncVolList,
      float * *            incVolList,
d1426 5
a1430 5
   forbidNullArg (partNameList, "demandedPartNameList");
   forbidNullArg (demandNameList,       "demandNameList");
   forbidNullArg (shipPeriodList,       "shipPeriodList");
   forbidNullArg (desIncVolList,        "desIncVolList");
   forbidNullArg (incVolList,           "incVolList");
d1442 1
a1442 1
   if (not (lenLists >= 1))
d1483 1
a1483 1
   apiAlloc (* incVolList, lenLists);
d1488 5
a1492 2
      (* incVolList)[++ listIndex] = 
         theEqAllocator->incVol (theDemand, shipPer);
d1551 1
a1551 1
      float            desIncVol,
d1581 1
a1581 1
   if (not ((shipPer >= 0) and (shipPer < nPeriods ())))
d1585 1
a1585 1
      myMsgFac () ("argRangeIntLeValLtIntSmsg",shipPer, 0, nPeriods ());
d1590 1
a1590 1
   if (not (desIncVol >= 0.0))
@


1.76
log
@Double Precision.
@
text
@d434 3
a436 3
      const char * partName,
      const char * demandName,
      float * *    demandVol)
d586 3
a588 3
      const char * partName,
      const char * demandName,
      float * *    fssShipVol)
d618 3
a620 3
      const char * partName,
      const char * demandName,
      float * *    obj1CumShipReward)
d637 3
a639 3
      const char * partName,
      const char * demandName,
      float * *    obj1ShipReward)
d779 3
a781 3
      const char * partName,
      const char * demandName,
      float * *    shipVol)
@


1.75
log
@Double Precision.
@
text
@d1129 3
a1131 3
      const char *  partName,
      const char *  demandName,
      const float * demandVol)
d1172 3
a1174 3
      const char *  partName,
      const char *  demandName,
      const float * fssShipVol)
d1213 3
a1215 3
      const char *  partName,
      const char *  demandName,
      const float * obj1CumShipReward)
d1232 3
a1234 3
      const char *  partName,
      const char *  demandName,
      const float * obj1ShipReward)
d1358 3
a1360 3
      const char *  partName,
      const char *  demandName,
      const float * shipVol)
@


1.74
log
@Double Precision.
@
text
@d626 1
a626 1
   witGetObj1Vector (
d645 1
a645 1
   witGetObj1Vector (
@


1.73
log
@Double Precision.
@
text
@d1137 1
a1137 1
   theCall.prepNonNegFloatVec ("demandVol", demandVol);
d1180 1
a1180 1
   theCall.prepNonNegFloatVec ("fssShipVol", fssShipVol);
d1366 1
a1366 1
   theCall.prepNonNegFloatVec ("shipVol", shipVol);
@


1.72
log
@Double Precision.
@
text
@d416 5
a420 5
      const char * partName,
      const char * demandName,
      float * *    hardLB,
      float * *    softLB,
      float * *    hardUB)
d1107 5
a1111 5
      const char *  partName,
      const char *  demandName,
      const float * hardLB,
      const float * softLB,
      const float * hardUB)
@


1.71
log
@Double Precision.
@
text
@d21 1
@


1.70
log
@Double Precision.
@
text
@d1116 1
a1116 1
   theCall.prepBoundSet (
a1120 3

   if (theCall.argsOK ())
      theCall.myDemand ()->cumShipBounds ()->set (hardLB, softLB, hardUB);
@


1.69
log
@Double Precision.
@
text
@d601 3
a603 3
      const char * partName,
      const char * demandName,
      WitOutScalRA grossRev)
d983 5
a987 5
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      const WitInScalRA & desIncVol,
      WitOutScalRA        incVol)
d1011 6
a1016 6
      const char *        partName,
      const char *        demandName,
      int                 shipPeriod,
      const WitInScalRA & desIncVol,
      WitOutScalRA        incVol,
      WitBoolean          asapMultiExec)
d1500 6
a1505 6
      const char *        partName,
      const char *        demandName,
      int                 shipPer,
      const WitInScalRA & desIncVol,
      WitOutScalRA        incVol,
      WitBoolean          asapMultiExec)
@


1.68
log
@Double Precision.
@
text
@d202 4
a205 4
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      WitInScalRA  incShipVol)
d983 5
a987 5
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      WitInScalRA  desIncVol,
      WitOutScalRA incVol)
d1011 6
a1016 6
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      WitInScalRA  desIncVol,
      WitOutScalRA incVol,
      WitBoolean   asapMultiExec)
d1193 3
a1195 3
      const char * partName,
      const char * demandName,
      WitInScalRA  grossRev)
d1500 6
a1505 6
      const char * partName,
      const char * demandName,
      int          shipPer,
      WitInScalRA  desIncVol,
      WitOutScalRA incVol,
      WitBoolean   asapMultiExec)
@


1.67
log
@Double Precision.
@
text
@d1267 1
a1267 1
      theCall.myDemand ()->setPrefBuildAhead (prefBuildAhead);
d1456 1
a1456 1
            asapMultiExecList[listIndex]:
d1511 1
a1511 1
      myProblem ()->myHeurAllMgr ()->printMeDir (asapMultiExec);
d1535 1
a1535 1
         asapMultiExec);
@


1.66
log
@Double Precision.
@
text
@d281 1
a281 1
      const witBoolean *   asapMultiExecList)
d657 1
a657 1
      witBoolean * prefBuildAhead)
d718 1
a718 1
      witBoolean * selForDel)
d1016 1
a1016 1
      witBoolean   asapMultiExec)
d1255 1
a1255 1
      witBoolean   prefBuildAhead)
d1296 1
a1296 1
      witBoolean   selForDel)
d1413 1
a1413 1
      const witBoolean *   asapMultiExecList)
d1505 1
a1505 1
      witBoolean   asapMultiExec)
@


1.65
log
@Double Precision.
@
text
@d1096 1
a1096 1
      tempIntVecRef.myCvector ());
d1350 1
a1350 1
      tempIntVecRef.myCvector ());
@


1.64
log
@Continued double precision.
@
text
@d205 1
a205 1
      InScalRA     incShipVol)
d603 1
a603 1
      OutScalRA    grossRev)
d986 2
a987 2
      InScalRA     desIncVol,
      OutScalRA    incVol)
d1014 2
a1015 2
      InScalRA     desIncVol,
      OutScalRA    incVol,
d1195 1
a1195 1
      InScalRA     grossRev)
d1503 2
a1504 2
      InScalRA     desIncVol,
      OutScalRA    incVol,
@


1.63
log
@Continued double precision.
@
text
@d205 1
a205 1
      float        incShipVol)
d986 2
a987 2
      float        desIncVol,
      float *      incVol)
d1014 2
a1015 2
      float        desIncVol,
      float *      incVol,
d1503 2
a1504 2
      float        desIncVol,
      float *      incVol,
d1540 1
a1540 1
      myMsgFac () ("incHeurDataMsg", shipPer, desIncVol, * incVol);
@


1.62
log
@Continued double precision.
@
text
@d19 2
a20 2
#include <RealSInArg.h>
#include <RealSOutArg.h>
d603 1
a603 1
      RealSOutArg  grossRev)
d1195 1
a1195 1
      RealSInArg   grossRev)
@


1.61
log
@Continued double precision.
@
text
@d19 2
d603 1
a603 1
      float *      grossRev)
d1195 1
a1195 1
      float        grossRev)
d1207 1
a1207 1
      theCall.myDemand ()->setGrossRev (doubleFromFloat (grossRev));
@


1.60
log
@Continued double precision.
@
text
@d1205 1
a1205 1
      theCall.myDemand ()->setGrossRev (static_cast <double> (grossRev));
@


1.59
log
@Continued double precision.
@
text
@d1199 1
a1199 1
   theCall.prepNonNegStrDbl (
d1205 1
a1205 1
      theCall.myDemand ()->setGrossRev (StrDbl::convFloat (grossRev));
@


1.58
log
@Continued double precision.
@
text
@d1506 1
a1506 1
   float            incVolVal;
@


1.57
log
@Continued implementation of PIP.
@
text
@d1199 1
a1199 1
   theCall.prepNonNegFloat (
d1205 1
a1205 1
      theCall.myDemand ()->setGrossRev (grossRev);
@


1.56
log
@Continued implementation of PIP.
@
text
@d43 1
a43 1
      const char *  demandedPartName,
d46 2
a47 2
   forbidNullArg (demandedPartName, "demandedPartName");
   forbidNullArg (demandName,       "demandName");
d50 1
a50 1
      myMsgFac () ("partNameMsg", demandedPartName);
d55 1
a55 1
   return getDemandP (demandedPartName, demandName);
d127 1
a127 1
               newDemand->demandName ()      .myCstring (),
d133 1
a133 1
               newDemand->demandName ()      .myCstring (),
d139 1
a139 1
               newDemand->demandName ()      .myCstring (),
d145 1
a145 1
               newDemand->demandName ()      .myCstring (),
d151 1
a151 1
               newDemand->demandName ()      .myCstring (),
d162 1
a162 1
               newDemand->demandName ()      .myCstring (),
d171 1
a171 1
               newDemand->demandName ()      .myCstring (),
d177 1
a177 1
               newDemand->demandName ()      .myCstring (),
d244 1
a244 1
      const char * const * demandedPartNameList,
d260 1
a260 1
      demandedPartNameList,
d274 1
a274 1
      const char * const * demandedPartNameList,
d292 1
a292 1
      demandedPartNameList,
d325 1
a325 1
      const char * demandedPartName,
d331 1
a331 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d341 1
a341 1
      const char * demandedPartName,
d347 1
a347 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d357 1
a357 1
      const char * demandedPartName,
d373 1
a373 1
   witGetDemandBuildAheadUB (demandedPartName, demandName, & buildAheadUBval);
d413 1
a413 1
      const char * demandedPartName,
d421 1
a421 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d431 1
a431 1
      const char * demandedPartName,
d437 1
a437 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d567 1
a567 1
      const char * demandedPartName,
d573 1
a573 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d583 1
a583 1
      const char * demandedPartName,
d589 1
a589 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d599 1
a599 1
      const char * demandedPartName,
d605 1
a605 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d615 1
a615 1
      const char * demandedPartName,
d621 1
a621 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d634 1
a634 1
      const char * demandedPartName,
d640 1
a640 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d653 1
a653 1
      const char * demandedPartName,
d659 1
a659 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d672 1
a672 1
      const char * demandedPartName,
d678 1
a678 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d714 1
a714 1
      const char * demandedPartName,
d720 1
a720 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d730 1
a730 1
      const char * demandedPartName,
d736 1
a736 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d746 1
a746 1
      const char * demandedPartName,
d762 1
a762 1
   witGetDemandShipLateUB (demandedPartName, demandName, & shipLateUBval);
d776 1
a776 1
      const char * demandedPartName,
d782 1
a782 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d981 1
a981 1
      const char * demandedPartName,
d996 1
a996 1
      demandedPartName,
d1009 1
a1009 1
      const char * demandedPartName,
d1025 1
a1025 1
      demandedPartName,
d1038 1
a1038 1
      const char * demandedPartName,
d1044 1
a1044 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1054 1
a1054 1
      const char * demandedPartName,
d1060 1
a1060 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1073 1
a1073 1
      const char * demandedPartName,
d1092 1
a1092 1
      demandedPartName, 
d1104 1
a1104 1
      const char *  demandedPartName,
d1112 1
a1112 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1129 1
a1129 1
      const char *  demandedPartName,
d1135 1
a1135 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1148 1
a1148 1
      const char * demandedPartName,
d1154 1
a1154 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1172 1
a1172 1
      const char *  demandedPartName,
d1178 1
a1178 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1191 1
a1191 1
      const char * demandedPartName,
d1197 1
a1197 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1213 1
a1213 1
      const char *  demandedPartName,
d1219 1
a1219 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1232 1
a1232 1
      const char *  demandedPartName,
d1238 1
a1238 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1251 1
a1251 1
      const char * demandedPartName,
d1257 1
a1257 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1273 1
a1273 1
      const char * demandedPartName,
d1279 1
a1279 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1292 1
a1292 1
      const char * demandedPartName,
d1298 1
a1298 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1308 1
a1308 1
      const char * demandedPartName,
d1314 1
a1314 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1327 1
a1327 1
      const char * demandedPartName,
d1346 1
a1346 1
      demandedPartName, 
d1358 1
a1358 1
      const char *  demandedPartName,
d1364 1
a1364 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1379 1
a1379 3
WitDemand * WitRun::getDemandP (
      const char * demandedPartName,
      const char * demandName)
d1384 1
a1384 1
   partP = getPartP (demandedPartName);
d1406 1
a1406 1
      const char * const * demandedPartNameList,
d1425 1
a1425 1
   forbidNullArg (demandedPartNameList, "demandedPartNameList");
d1458 4
a1461 4
         demandedPartNameList[listIndex],
         demandNameList      [listIndex],
         shipPeriodList      [listIndex],
         desIncVolList       [listIndex],
d1474 3
a1476 3
         demandedPartNameList[dupIndex1],
         demandNameList      [dupIndex1],
         shipPeriodList      [dupIndex1]);
d1498 1
a1498 1
      const char * demandedPartName,
d1505 1
a1505 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d1544 1
a1544 1
      const char *     demandedPartName,
d1555 1
a1555 1
   forbidNullArg (demandedPartName, "demandedPartNameList");
d1557 1
a1557 1
   thePart = myCompMgr ()->findPart (demandedPartName);
d1563 1
a1563 1
      myMsgFac () ("undefinedPartMsg", demandedPartName);
d1574 1
a1574 1
      myMsgFac () ("undefinedDemandMsg", demandName, demandedPartName);
@


1.55
log
@Implemented API function witAppendToPipSeq.
@
text
@d22 1
a22 1
#include <PipMgr.h>
d229 1
a229 1
   myProblem ()->myPipMgr ()->appendToShipSeq (
d531 1
a531 1
   myProblem ()->myPipMgr ()->getExecVolTrips (
d913 1
a913 1
   myProblem ()->myPipMgr ()->getSubVolTrips (
d1644 1
a1644 1
   myProblem ()->myPipMgr ()->getPartPegTrips (
d1688 1
a1688 1
   if (not myProblem ()->myPipMgr ()->peggingExists ())
@


1.54
log
@Continued implementation of PIP.
@
text
@d195 43
d1608 2
a1609 2
   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", shipPeriod);
d1678 2
a1679 2
   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", shipPeriod);
@


1.53
log
@Continued implementation of PIP.
@
text
@d1644 3
@


1.52
log
@Continued implementation of PIP.
@
text
@d32 1
@


1.51
log
@Continued implementation of PIP.
@
text
@a31 1
#include <PerPair.h>
d476 1
a476 1
   WitOpnTripStOld execVolTrips (myProblem ());
d506 1
a506 1
   while (popTriple (execVolTrips, theOpn, execPer, pgdExecVol))
d858 1
a858 1
   WitSubTripStOld subVolTrips (myProblem ());
d892 1
a892 1
   while (popTriple (subVolTrips, theSub, execPer, pgdSubVol))
d1591 1
a1591 1
   WitPartTripStOld thePegTrips (myProblem ());
d1620 1
a1620 1
   while (popTriple (thePegTrips, thePart, pegPer, pegVol))
@


1.50
log
@Continued implementation of PIP.
@
text
@d477 1
a477 1
   WitOpnTripStack execVolTrips (myProblem ());
d859 1
a859 1
   WitSubTripStack subVolTrips (myProblem ());
d1592 1
a1592 1
   WitPartTripStack thePegTrips (myProblem ());
@


1.49
log
@Continued implementation of PIP.
@
text
@d32 1
d507 1
a507 1
   while (pop (execVolTrips, theOpn, execPer, pgdExecVol))
d893 1
a893 1
   while (pop (subVolTrips, theSub, execPer, pgdSubVol))
d1621 1
a1621 1
   while (pop (thePegTrips, thePart, pegPer, pegVol))
@


1.48
log
@Continued implementation of PIP.
@
text
@a866 1

a1635 3

   if (not myGlobalComp ()->pip ())
      myMsgFac () ("reqPipSmsg");
@


1.47
log
@Continued implementation of PIP.
@
text
@a22 1
#include <PipSrc.h>
d476 6
a481 6
   WitPip::OpnPairStack         execVolPairs (myProblem ());
   int                          nPairs;
   int                          theIdx;
   WitPip::Src <WitOperation> * thePipSrc;
   double                       pgdExecVol;
   WitOperation *               theOpn;
d487 1
a487 1
   myProblem ()->myPipMgr ()->getExecVolPairs (
d490 1
a490 1
      execVolPairs);
d492 1
a492 1
   nPairs = execVolPairs.nElements ();
d494 1
a494 1
   apiGet (lenLists, "lenLists", nPairs);
d500 3
a502 3
   apiAlloc    (* operationNameList, nPairs);
   apiAlloc    (* execPeriodList,    nPairs);
   apiAlloc    (* peggedExecVolList, nPairs);
d506 1
a506 1
   while (execVolPairs.pop (thePipSrc, pgdExecVol))
a509 2
      theOpn = thePipSrc->mySrcComp ();

d512 1
a512 1
      (* execPeriodList)   [theIdx] = thePipSrc->myPer ();
d858 6
a863 6
   WitPip::SubPairStack        subVolPairs (myProblem ());
   int                         nPairs;
   int                         theIdx;
   WitPip::Src <WitSubEntry> * thePipSrc;
   double                      pgdSubVol;
   WitSubEntry *               theSub;
d870 1
a870 1
   myProblem ()->myPipMgr ()->getSubVolPairs (
d873 1
a873 1
      subVolPairs);
d875 1
a875 1
   nPairs = subVolPairs.nElements ();
d877 1
a877 1
   apiGet (lenLists, "lenLists", nPairs);
d885 5
a889 5
   apiAlloc    (* operationNameList,     nPairs);
   apiAlloc    (* bomEntryIndexList,     nPairs);
   apiAlloc    (* subsBomEntryIndexList, nPairs);
   apiAlloc    (* execPeriodList,        nPairs);
   apiAlloc    (* peggedSubVolList,      nPairs);
d893 1
a893 1
   while (subVolPairs.pop (thePipSrc, pgdSubVol))
a896 2
      theSub = thePipSrc->mySrcComp ();

d900 3
a902 3
      (* bomEntryIndexList)    [theIdx] = theSub   ->myBomEntIndex ();
      (* subsBomEntryIndexList)[theIdx] = theSub   ->localIndex ();
      (* execPeriodList)       [theIdx] = thePipSrc->myPer ();
d1591 7
a1597 7
   WitDemandApiCall        theCall      (this, partName, demandName);
   WitPip::PartPairStack   thePartPairs (myProblem ());
   int                     nPairs;
   int                     theIdx;
   WitPip::Src <WitPart> * thePipSrc;
   double                  pegVol;
   WitPart *               thePart;
d1601 1
a1601 1
   myProblem ()->myPipMgr ()->getPartPegPairs (
d1605 1
a1605 1
      thePartPairs);
d1607 1
a1607 1
   nPairs = thePartPairs.nElements ();
d1609 1
a1609 1
   apiGet (lenLists, "lenLists", nPairs);
d1615 3
a1617 3
   apiAlloc    (* partNameList,  nPairs);
   apiAlloc    (* periodList,    nPairs);
   apiAlloc    (* peggedVolList, nPairs);
d1621 1
a1621 1
   while (thePartPairs.pop (thePipSrc, pegVol))
a1624 2
      thePart = thePipSrc->mySrcComp ();

d1626 1
a1626 1
      (* periodList)   [theIdx] = thePipSrc->myPer ();
@


1.46
log
@Continued implementation of PIP.
@
text
@d22 1
a22 1
#include <PipInt.h>
d488 1
a488 1
   myProblem ()->myPipInt ()->getExecVolPairs (
d873 1
a873 1
   myProblem ()->myPipInt ()->getSubVolPairs (
d1606 1
a1606 1
   myProblem ()->myPipInt ()->getPartPegPairs (
@


1.45
log
@Continued implementation of PIP.
@
text
@a485 1

d1645 1
a1645 1
   if (not myGlobalComp ()->perfPegging ())
@


1.44
log
@Continued implementation of PIP.
@
text
@d477 1
a477 1
   WitPip::WitOpnPipStack       execVolPairs (myProblem ());
d862 1
a862 1
   WitPip::WitSubPipStack      subVolPairs (myProblem ());
d1597 2
a1598 2
   WitDemandApiCall        theCall     (this, partName, demandName);
   WitPip::WitPartPipStack thePegPairs (myProblem ());
d1611 1
a1611 1
      thePegPairs);
d1613 1
a1613 1
   nPairs = thePegPairs.nElements ();
d1627 1
a1627 1
   while (thePegPairs.pop (thePipSrc, pegVol))
@


1.43
log
@Continued implementation of PIP.
@
text
@d358 1
a358 1
      WitPIP::consVolAtt,
d477 6
a482 6
   WitPIP::WitOpnPipStack             execVolPairs (myProblem ());
   int                                nPairs;
   int                                theIdx;
   WitPIP::WitPipSrc <WitOperation> * thePipSrc;
   double                             pgdExecVol;
   WitOperation *                     theOpn;
d662 1
a662 1
      WitPIP::prodVolAtt,
d766 1
a766 1
      WitPIP::sideVolAtt,
d862 6
a867 6
   WitPIP::WitSubPipStack            subVolPairs (myProblem ());
   int                               nPairs;
   int                               theIdx;
   WitPIP::WitPipSrc <WitSubEntry> * thePipSrc;
   double                            pgdSubVol;
   WitSubEntry *                     theSub;
d932 1
a932 1
      WitPIP::supplyVolAtt,
d1591 1
a1591 1
      WitPIP::PartAtt thePartAtt,
d1597 7
a1603 7
   WitDemandApiCall              theCall     (this, partName, demandName);
   WitPIP::WitPartPipStack       thePegPairs (myProblem ());
   int                           nPairs;
   int                           theIdx;
   WitPIP::WitPipSrc <WitPart> * thePipSrc;
   double                        pegVol;
   WitPart *                     thePart;
@


1.42
log
@Continued implementation of PIP.
@
text
@d358 1
a358 1
      WitPip::consVolAtt,
d477 6
a482 6
   WitOpnPipStack             execVolPairs (myProblem ());
   int                        nPairs;
   int                        theIdx;
   WitPipSrc <WitOperation> * thePipSrc;
   double                     pgdExecVol;
   WitOperation *             theOpn;
d662 1
a662 1
      WitPip::prodVolAtt,
d766 1
a766 1
      WitPip::sideVolAtt,
d862 6
a867 6
   WitSubPipStack            subVolPairs (myProblem ());
   int                       nPairs;
   int                       theIdx;
   WitPipSrc <WitSubEntry> * thePipSrc;
   double                    pgdSubVol;
   WitSubEntry *             theSub;
d932 1
a932 1
      WitPip::supplyVolAtt,
d1591 1
a1591 1
      WitPip::PartAtt thePartAtt,
d1597 7
a1603 7
   WitDemandApiCall      theCall     (this, partName, demandName);
   WitPartPipStack       thePegPairs (myProblem ());
   int                   nPairs;
   int                   theIdx;
   WitPipSrc <WitPart> * thePipSrc;
   double                pegVol;
   WitPart *             thePart;
@


1.41
log
@Continued implementation of PIP.
@
text
@d1607 1
a1607 1
   myProblem ()->myPipInt ()->getPegPairs (
@


1.40
log
@Continued implementation of PIP.
@
text
@a353 10
   WitDemandApiCall theCall      (this, partName, demandName);
   WitPartPipStack  consVolPairs (myProblem ());

   prepGetPip (shipPeriod);

   myProblem ()->myPipInt ()->getConsVolPairs (
      theCall.myDemand (), 
      shipPeriod, 
      consVolPairs);

d355 4
a358 1
      consVolPairs,
a657 10
   WitDemandApiCall theCall      (this, partName, demandName);
   WitPartPipStack  prodVolPairs (myProblem ());

   prepGetPip (shipPeriod);

   myProblem ()->myPipInt ()->getProdVolPairs (
      theCall.myDemand (), 
      shipPeriod, 
      prodVolPairs);

d659 4
a662 1
      prodVolPairs,
a761 10
   WitDemandApiCall theCall      (this, partName, demandName);
   WitPartPipStack  sideVolPairs (myProblem ());

   prepGetPip (shipPeriod);

   myProblem ()->myPipInt ()->getSideVolPairs (
      theCall.myDemand (), 
      shipPeriod, 
      sideVolPairs);

d763 4
a766 1
      sideVolPairs,
a927 10
   WitDemandApiCall theCall        (this, partName, demandName);
   WitPartPipStack  supplyVolPairs (myProblem ());

   prepGetPip (shipPeriod);

   myProblem ()->myPipInt ()->getSupplyVolPairs (
      theCall.myDemand (), 
      shipPeriod, 
      supplyVolPairs);

d929 4
a932 1
      supplyVolPairs,
a1586 18
void WitRun::prepGetPip (int shipPeriod)
   {
   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", shipPeriod);

   if (not myGlobalComp ()->perfPegging ())
      myMsgFac () ("reqPipSmsg");

   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputId ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }
   }

//------------------------------------------------------------------------------

d1588 8
a1595 5
      WitPartPipStack & thePegPairs,
      int *             lenLists,
      char * * *        partNameList,
      int * *           periodList,
      float * *         peggedVolList)
d1597 2
d1605 8
d1636 18
@


1.39
log
@Removed a bad function overload.
@
text
@d765 33
@


1.38
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d269 1
a269 1
   theDemand = curItrDelCompForGet (WitAT_DEMAND, "demandFrag")->myDemand ();
@


1.37
log
@Continued implementation of Post-Implosion Pegging.
@
text
@d1600 1
a1600 1
WitReturnCode WitRun::getPartPip (
@


1.36
log
@Continued implementation of post-implosion pegging.
@
text
@d22 2
d343 33
d447 3
a449 3
   apiAlloc (* operationNameList, nOpnPegEls);
   apiAlloc (* execPeriodList,    nOpnPegEls);
   apiAlloc (* peggedExecVolList, nOpnPegEls);
d473 60
d654 33
d806 5
a810 5
   apiAlloc (* operationNameList,     nSubPegEls);
   apiAlloc (* bomEntryIndexList,     nSubPegEls);
   apiAlloc (* subsBomEntryIndexList, nSubPegEls);
   apiAlloc (* execPeriodList,        nSubPegEls);
   apiAlloc (* peggedSubVolList,      nSubPegEls);
d837 101
d1577 59
@


1.35
log
@Continued implementation of proportionate routing.
@
text
@d394 1
a394 6
   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", shipPeriod);

   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputId ()->setArgName ("shipPeriod");
a395 6
      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }

   if (not myGlobalComp ()->perfPegging ())
      myMsgFac () ("reqPerfPeggingSmsg");
      
d658 1
a658 12
   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", shipPeriod);

   if (not myGlobalComp ()->perfPegging ())
      myMsgFac () ("reqPerfPeggingSmsg");
      
   if (not ((shipPeriod >= 0) and (shipPeriod < nPeriods ())))
      {
      myInputId ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }
d1331 18
@


1.34
log
@Removed all const_casts from WIT.
@
text
@d267 1
a267 1
   curItrDelCompForGet (WitAT_DEMAND, "demandFrag")->getDemand (theDemand);
@


1.33
log
@Internal changes.
@
text
@d386 7
a392 7
   WitDemandApiCall             theCall   (this, partName, demandName);
   WitObjStack <const WitPegEl> thePegEls (myProblem ());
   WitObjStItr <const WitPegEl> theItr;
   int                          nOpnPegEls;
   int                          theIdx;
   const WitPegEl *             thePegEl;
   WitOperation *               theOpn;
d407 1
a407 1
   theCall.myDemand ()->getMyPegEls (shipPeriod, thePegEls);
d411 1
a411 1
   theItr.attachTo (thePegEls);
d413 2
a414 2
   while (theItr.advance (thePegEl))
      if (thePegEl->myOpn () != NULL)
d429 1
a429 1
   while (thePegEls.pop (thePegEl))
d431 1
a431 1
      theOpn = thePegEl->myOpn ();
d438 2
a439 2
      (* execPeriodList)   [theIdx] = thePegEl->myExecPer ();
      (* peggedExecVolList)[theIdx] = thePegEl->peggedVol ();
d661 7
a667 7
   WitDemandApiCall             theCall   (this, partName, demandName);
   WitObjStack <const WitPegEl> thePegEls (myProblem ());
   WitObjStItr <const WitPegEl> theItr;
   int                          nSubPegEls;
   int                          theIdx;
   const WitPegEl *             thePegEl;
   WitSubEntry *                theSub;
d682 1
a682 1
   theCall.myDemand ()->getMyPegEls (shipPeriod, thePegEls);
d686 1
a686 1
   theItr.attachTo (thePegEls);
d688 2
a689 2
   while (theItr.advance (thePegEl))
      if (thePegEl->mySub () != NULL)
d708 1
a708 1
   while (thePegEls.pop (thePegEl))
d710 1
a710 1
      theSub = thePegEl->mySub ();
d718 4
a721 4
      (* bomEntryIndexList)    [theIdx] = theSub  ->myBomEntIndex ();
      (* subsBomEntryIndexList)[theIdx] = theSub  ->localIndex ();
      (* execPeriodList)       [theIdx] = thePegEl->myExecPer ();
      (* peggedSubVolList)     [theIdx] = thePegEl->peggedVol ();
@


1.32
log
@Internal changes.
@
text
@d238 1
a238 1
   if (! myGlobalComp ()->twoWayMultiExec ())
d397 1
a397 1
   if (! ((shipPeriod >= 0) && (shipPeriod < nPeriods ())))
d404 1
a404 1
   if (! myGlobalComp ()->perfPegging ())
d672 1
a672 1
   if (! myGlobalComp ()->perfPegging ())
d675 1
a675 1
   if (! ((shipPeriod >= 0) && (shipPeriod < nPeriods ())))
d769 1
a769 1
   if (! myGlobalComp ()->twoWayMultiExec ())
d1189 1
a1189 1
   if (! myProblem ()->myHeurAllMgr ()->active ())
d1194 1
a1194 1
   if (! (lenLists >= 1))
d1264 1
a1264 1
   if (! myProblem ()->myHeurAllMgr ()->active ())
d1267 1
a1267 1
   if (! ((shipPer >= 0) && (shipPer < nPeriods ())))
d1274 1
a1274 1
   if (! (desIncVol >= 0.0))
d1330 1
a1330 1
   if (! ((shipPer >= 0) && (shipPer < nPeriods ())))
d1339 1
a1339 1
   if (! (desIncVol >= 0.0))
@


1.31
log
@Continued implementation of Single-Source.
@
text
@d210 1
a210 1
         witTRUE,
d234 1
a234 1
      const WitBoolean *   asapMultiExecList)
d241 1
a241 1
         witFALSE,
d538 1
a538 1
      WitBoolean * prefBuildAhead)
d573 1
a573 1
      WitBoolean * selForDel)
d743 1
a743 1
         witTRUE,
d752 1
a752 1
      witFALSE);
d765 1
a765 1
      WitBoolean   asapMultiExec)
d772 1
a772 1
         witFALSE,
d1004 1
a1004 1
      WitBoolean   prefBuildAhead)
d1010 1
a1010 1
   theCall.prepBoolean (
d1045 1
a1045 1
      WitBoolean   selForDel)
d1164 1
a1164 1
      const WitBoolean *   asapMultiExecList)
d1171 1
a1171 1
   WitBoolean        asapMultiExec;
d1208 1
a1208 1
            witFALSE;
d1256 1
a1256 1
      WitBoolean   asapMultiExec)
d1301 1
a1301 1
      WitBoolean       asapMultiExec,
@


1.30
log
@Continued implementation of Single-Source.
@
text
@d388 2
a389 1
   int                          nPegEls;
d407 1
a407 1
   theCall.myDemand ()->getMyOpnPegEls (shipPeriod, thePegEls);
d409 1
a409 1
   nPegEls = thePegEls.nElements ();
d411 7
a417 1
   apiGet (lenLists, "lenLists", nPegEls);
d423 3
a425 3
   apiAlloc (* operationNameList, nPegEls);
   apiAlloc (* execPeriodList,    nPegEls);
   apiAlloc (* peggedExecVolList, nPegEls);
d433 2
a434 1
      witAssert (theOpn != NULL);
d436 1
a436 1
      (* operationNameList)[theIdx]  = dupCstring (theOpn->operationName ());
d438 2
a439 2
      (* execPeriodList)    [theIdx] = thePegEl->myExecPer ();
      (* peggedExecVolList) [theIdx] = thePegEl->peggedVol ();
d663 2
a664 1
   int                          nPegEls;
d682 5
a686 1
   theCall.myDemand ()->getMySubPegEls (shipPeriod, thePegEls);
d688 3
a690 1
   nPegEls = thePegEls.nElements ();
d692 1
a692 1
   apiGet (lenLists, "lenLists", nPegEls);
d700 5
a704 5
   apiAlloc (* operationNameList,     nPegEls);
   apiAlloc (* bomEntryIndexList,     nPegEls);
   apiAlloc (* subsBomEntryIndexList, nPegEls);
   apiAlloc (* execPeriodList,        nPegEls);
   apiAlloc (* peggedSubVolList,      nPegEls);
d712 2
a713 1
      witAssert (theSub != NULL);
@


1.29
log
@Continued implementation of Single-Source.
@
text
@a20 1
#include <PegSite.h>
d386 6
a391 5
   WitDemandApiCall                theCall   (this, partName, demandName);
   WitObjStack <const WitOpnPegEl> thePegEls (myProblem ());
   int                             nPegEls;
   int                             theIdx;
   const WitOpnPegEl *             thePegEl;
d406 1
a406 1
   theCall.myDemand ()->myPegSite ()->getMyOpnPegEls (shipPeriod, thePegEls);
d424 5
a428 2
      (* operationNameList)[theIdx] =
         dupCstring (thePegEl->myAllocComp ()->operationName ());
d653 6
a658 6
   WitDemandApiCall                theCall   (this, partName, demandName);
   WitObjStack <const WitSubPegEl> thePegEls (myProblem ());
   int                             nPegEls;
   int                             theIdx;
   const WitSubPegEl *             thePegEl;
   WitSubEntry *                   theSub;
d673 1
a673 1
   theCall.myDemand ()->myPegSite ()->getMySubPegEls (shipPeriod, thePegEls);
d695 3
a697 1
      theSub                            = thePegEl->myAllocComp ();
@


1.28
log
@Continued implementation of single-source.
@
text
@a18 1
#include <DelCompItr.h>
@


1.27
log
@Preliminary work on single source.
@
text
@a524 73
WitReturnCode WitRun::witGetDemandSubVolPegging (
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   operationNameList,
      int * *      bomEntryIndexList,
      int * *      subsBomEntryIndexList,
      int * *      execPeriodList,
      float * *    peggedSubVolList)
   {
   PROLOG ("witGetDemandSubVolPegging");

   WitDemandApiCall                theCall   (this, partName, demandName);
   WitObjStack <const WitSubPegEl> thePegEls (myProblem ());
   int                             nPegEls;
   int                             theIdx;
   const WitSubPegEl *             thePegEl;
   WitSubEntry *                   theSub;

   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", shipPeriod);

   if (! myGlobalComp ()->perfPegging ())
      myMsgFac () ("reqPerfPeggingSmsg");
      
   if (! ((shipPeriod >= 0) && (shipPeriod < nPeriods ())))
      {
      myInputId ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }

   theCall.myDemand ()->myPegSite ()->getMySubPegEls (shipPeriod, thePegEls);

   nPegEls = thePegEls.nElements ();

   apiGet (lenLists, "lenLists", nPegEls);

   forbidNullArg (operationNameList,     "operationNameList");
   forbidNullArg (bomEntryIndexList,     "bomEntryIndexList");
   forbidNullArg (subsBomEntryIndexList, "subsBomEntryIndexList");
   forbidNullArg (execPeriodList,        "execPeriodList");
   forbidNullArg (peggedSubVolList,      "peggedSubVolList");

   apiAlloc (* operationNameList,     nPegEls);
   apiAlloc (* bomEntryIndexList,     nPegEls);
   apiAlloc (* subsBomEntryIndexList, nPegEls);
   apiAlloc (* execPeriodList,        nPegEls);
   apiAlloc (* peggedSubVolList,      nPegEls);
   
   theIdx = 0;

   while (thePegEls.pop (thePegEl))
      {
      theSub                            = thePegEl->myAllocComp ();

      (* operationNameList)    [theIdx] = 
         dupCstring (theSub->myOperationName ());

      (* bomEntryIndexList)    [theIdx] = theSub  ->myBomEntIndex ();
      (* subsBomEntryIndexList)[theIdx] = theSub  ->localIndex ();
      (* execPeriodList)       [theIdx] = thePegEl->myExecPer ();
      (* peggedSubVolList)     [theIdx] = thePegEl->peggedVol ();

      theIdx ++;
      }

   EPILOG;
   }

//------------------------------------------------------------------------------

d560 16
d638 2
a639 2
WitReturnCode WitRun::witGetDemandSelForDel (
      const char * demandedPartName,
d641 7
a647 1
      WitBoolean * selForDel)
d649 48
a696 1
   PROLOG ("witGetDemandSelForDel");
d698 4
a701 1
   WitDemandApiCall theCall (this, demandedPartName, demandName);
d703 2
a704 1
   apiGet (selForDel, "selForDel", theCall.myDemand ()->selForDel ());
d1022 16
a1100 16

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witSetDemandSelForDel (
      const char * demandedPartName,
      const char * demandName,
      WitBoolean   selForDel)
   {
   PROLOG ("witSetDemandSelForDel");

   WitDemandApiCall theCall (this, demandedPartName, demandName);

   theCall.setSelForDel (selForDel);
@


1.26
log
@Continued preliminary work on single source.
@
text
@d820 1
a820 1
   tempIntVecRef.setTo (buildAheadLimit);
d1058 1
a1058 1
   tempIntVecRef.setTo (shipLateLimit);
@


1.25
log
@Continued preliminary work on single source.
@
text
@d24 2
d27 3
a29 1
#include <Global.h>
@


1.24
log
@Continued implementation of object iteration.
@
text
@d806 1
a806 1
   WitTVec (int) & tempIntVecRef = myApiMgr ()->reserveTempIntVec ();
d816 1
a816 1
   tempIntVecRef = buildAheadLimit;
d1044 1
a1044 1
   WitTVec (int) & tempIntVecRef = myApiMgr ()->reserveTempIntVec ();
d1054 1
a1054 1
   tempIntVecRef = shipLateLimit;
@


1.23
log
@Continued implementation of object iteration.
@
text
@d257 1
a257 1
WitReturnCode WitRun::witGetItrDemand (
d263 1
a263 1
   PROLOG ("witGetItrDemand");
@


1.22
log
@Continued implementation of object iteration.
@
text
@d26 1
d251 20
@


1.21
log
@Began implementation of object iteration.
@
text
@d19 1
@


1.20
log
@Refactoring for constrained stock reallocation.
@
text
@d11 1
a11 1
// Source file: "demApi.c"
d18 1
d24 1
a24 1
#include <ApiCall.h>
d27 1
@


1.19
log
@Minor change.
@
text
@d262 1
a262 1
   apiGet (appData, "appData", theCall ()->appData ());
d278 1
a278 1
   apiGet (buildAheadUB, "buildAheadUB", theCall ()->buildAheadUB ());
d326 1
a326 1
   apiGet (hardLB, softLB, hardUB, theCall ()->cumShipBounds ());
d342 1
a342 1
   apiGet (demandVol, "demandVol", theCall ()->demandVol ());
d379 1
a379 1
   theCall ()->myPegSite ()->getMyOpnPegEls (shipPeriod, thePegEls);
d420 1
a420 1
   apiGet (focusHorizon, "focusHorizon", theCall ()->focusHorizon ());
d436 1
a436 1
   apiGet (fssShipVol, "fssShipVol", theCall ()->fssShipVol ());
d452 1
a452 1
   apiGet (grossRev, "grossRev", theCall ()->grossRev ());
d471 1
a471 1
      theCall ()->obj1CumShipReward ());
d490 1
a490 1
      theCall ()->obj1ShipReward ());
d530 1
a530 1
   theCall ()->myPegSite ()->getMySubPegEls (shipPeriod, thePegEls);
d579 4
a582 1
   apiGet (prefBuildAhead, "prefBuildAhead", theCall ()->prefBuildAhead ());
d598 1
a598 1
   apiGet (priority, "priority", theCall ()->priority ());
d614 1
a614 1
   apiGet (shipLateUB, "shipLateUB", theCall ()->shipLateUB ());
d660 1
a660 1
   apiGet (shipVol, "shipVol", theCall ()->shipVol ());
d676 1
a676 1
   apiGet (selForDel, "selForDel", theCall ()->selForDel ());
d768 1
a768 1
      theCall ()->setBuildAheadUB (buildAheadUB);
d817 5
a821 1
   theCall.prepBoundSet (theCall ()->cumShipBounds (), hardLB, softLB, hardUB);
d824 1
a824 1
      theCall ()->cumShipBounds ()->set (hardLB, softLB, hardUB);
d843 1
a843 1
      theCall ()->setDemandVol (demandVol);
d861 1
a861 1
      theCall ()->focusHorizon (),
d864 1
a864 1
      theCall ()->lastPeriod ());
d867 1
a867 1
      theCall ()->setFocusHorizon (focusHorizon);
d886 1
a886 1
      theCall ()->setFssShipVol (fssShipVol);
d902 4
a905 1
   theCall.prepNonNegFloat ("grossRev", theCall ()->grossRev (), grossRev);
d908 1
a908 1
      theCall ()->setGrossRev (grossRev);
d927 1
a927 1
      theCall ()->setObj1CumShipReward (obj1CumShipReward);
d946 1
a946 1
      theCall ()->setObj1ShipReward (obj1ShipReward);
d964 1
a964 1
      theCall ()->prefBuildAhead (),
d968 1
a968 1
      theCall ()->setPrefBuildAhead (prefBuildAhead);
d987 1
a987 1
      theCall ()->setPriority (priority);
d1006 1
a1006 1
      theCall ()->setShipLateUB (shipLateUB);
d1056 1
a1056 1
      theCall ()->setShipVol (shipVol);
d1235 1
a1235 1
         theCall (), 
@


1.18
log
@Continued implementation of pegging.
@
text
@d376 2
a377 2
   if (! myGlobalComp ()->peggingNeeded ())
      myMsgFac () ("reqPeggingNeededSmsg");
d520 2
a521 2
   if (! myGlobalComp ()->peggingNeeded ())
      myMsgFac () ("reqPeggingNeededSmsg");
@


1.17
log
@Continued implementation of pegging.
@
text
@d349 62
d497 1
a497 63
WitReturnCode WitRun::witGetDemandPeggedExecVols (
      const char * partName,
      const char * demandName,
      int          shipPeriod,
      int *        lenLists,
      char * * *   operationNameList,
      int * *      execPeriodList,
      float * *    peggedExecVolList)
   {
   PROLOG ("witGetDemandPeggedExecVols");

   WitDemandApiCall                theCall   (this, partName, demandName);
   WitObjStack <const WitOpnPegEl> thePegEls (myProblem ());
   int                             nPegEls;
   int                             theIdx;
   const WitOpnPegEl *             thePegEl;

   if (myMsgFac ().mayIssue ("periodMsg"))
      myMsgFac () ("periodMsg", shipPeriod);

   if (! myGlobalComp ()->pegging ())
      myMsgFac () ("needPeggingSmsg");
      
   if (! ((shipPeriod >= 0) && (shipPeriod < nPeriods ())))
      {
      myInputId ()->setArgName ("shipPeriod");

      myMsgFac () ("argRangeIntLeValLtIntSmsg", shipPeriod, 0, nPeriods ());
      }

   theCall ()->myPegSite ()->getMyOpnPegEls (shipPeriod, thePegEls);

   nPegEls = thePegEls.nElements ();

   apiGet (lenLists, "lenLists", nPegEls);

   forbidNullArg (operationNameList, "operationNameList");
   forbidNullArg (execPeriodList,    "execPeriodList");
   forbidNullArg (peggedExecVolList, "peggedExecVolList");

   apiAlloc (* operationNameList, nPegEls);
   apiAlloc (* execPeriodList,    nPegEls);
   apiAlloc (* peggedExecVolList, nPegEls);
   
   theIdx = 0;

   while (thePegEls.pop (thePegEl))
      {
      (* operationNameList)[theIdx] =
         dupCstring (thePegEl->myAllocComp ()->operationName ());

      (* execPeriodList)    [theIdx] = thePegEl->myExecPer ();
      (* peggedExecVolList) [theIdx] = thePegEl->peggedVol ();

      theIdx ++;
      }

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witGetDemandPeggedSubVols (
d508 1
a508 1
   PROLOG ("witGetDemandPeggedSubVols");
d520 2
a521 2
   if (! myGlobalComp ()->pegging ())
      myMsgFac () ("needPeggingSmsg");
@


1.16
log
@Continued implementation of pegging.
@
text
@d465 1
a465 1
   theCall ()->myOpnPegSite ()->getMyPegEls (shipPeriod, thePegEls);
d530 1
a530 1
   theCall ()->mySubPegSite ()->getMyPegEls (shipPeriod, thePegEls);
@


1.15
log
@Continued implementation of pegging.
@
text
@d455 2
a456 2
   if (! myGlobalComp ()->perfPegging ())
      myMsgFac () ("needPerfPeggingSmsg");
d520 2
a521 2
   if (! myGlobalComp ()->perfPegging ())
      myMsgFac () ("needPerfPeggingSmsg");
@


1.14
log
@Continued implementation of pegging.
@
text
@d452 5
a456 2
   if (! myGlobalComp ()->doPegging ())
      myMsgFac () ("needDoPeggingSmsg");
d517 5
a521 2
   if (! myGlobalComp ()->doPegging ())
      myMsgFac () ("needDoPeggingSmsg");
@


1.13
log
@Initial implementation of pegging.
@
text
@d442 1
a442 1
      float * *    deltaExecVolList)
d446 5
a450 6
   WitDemandApiCall             theCall   (this, partName, demandName);
   WitObjStack <const WitPegEl> thePegEls (myProblem ());
   int                          nPegEls;
   WitObjStItr <const WitPegEl> theItr;
   int                          theIdx;
   const WitPegEl *             thePegEl;
d462 1
a462 1
   theCall ()->myPegSite ()->getMyPegEls (shipPeriod, thePegEls);
d470 1
a470 1
   forbidNullArg (deltaExecVolList,  "deltaExecVolList");
d474 1
a474 1
   apiAlloc (* deltaExecVolList,  nPegEls);
d476 49
a524 1
   theItr.attachTo (thePegEls);
d526 16
d544 1
a544 1
   while (theItr.advance (thePegEl))
d546 4
a549 2
      (* operationNameList)[theIdx] =
         dupCstring (thePegEl->myOpn ()->operationName ());
d551 4
a554 2
      (* execPeriodList)   [theIdx] = thePegEl->myExecPer ();
      (* deltaExecVolList) [theIdx] = thePegEl->deltaExecVol ();
@


1.12
log
@Moved Stack template implementations to header files.
@
text
@d19 3
a21 1
#include <HeurAll.h>
d24 1
d435 62
d1058 1
a1058 1
   if (! myProblem ()->myHeurAllocator ()->active ())
d1131 1
a1131 1
      myProblem ()->myHeurAllocator ()->printMeDir (asapMultiExec);
d1133 1
a1133 1
   if (! myProblem ()->myHeurAllocator ()->active ())
d1151 1
a1151 1
      myProblem ()->myHeurAllocator ()->inc (
@


1.11
log
@Implemented coarse selection splitting for multiple exec periods.
@
text
@d22 1
a22 1
#include <PairSt.h>
@


1.10
log
@Fixed some bugs in coarse selection splitting.
@
text
@d1153 4
a1156 2
       myProblem ()->myEqAllocator ()->
          setAsapMultiExec (theDemand, shipPer, asapMultiExec);
@


1.9
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d1043 1
a1043 1
   while (theDemPers.get (theDemand, shipPer))
d1141 1
a1141 1
   theDemPers.put (theDemand, shipPer);
@


1.8
log
@Further development of coarse selection splitting.
@
text
@d1043 1
a1043 1
   while (theDemPers.pop (theDemand, shipPer))
d1141 1
a1141 1
   theDemPers.push (theDemand, shipPer);
@


1.7
log
@Some minor modifications.
@
text
@d22 1
a22 1
#include <Stack.h>
@


1.6
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d22 1
a22 1
#include <DynStack.h>
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d978 1
a978 1
   WitDemPerDynStack theDemPers (myProblem ());
d1101 6
a1106 6
      const char *        demandedPartName,
      const char *        demandName,
      int                 shipPer,
      float               desIncVol,
      WitBoolean          asapMultiExec,
      WitDemPerDynStack & theDemPers)
@


1.4
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d22 1
a22 1
#include <DynPer.h>
d970 7
a976 7
   int              listIndex;
   int              dupIndex1;
   int              dupIndex2;
   WitDemand *      theDemand;
   WitPeriod        shipPer;
   WitBoolean       asapMultiExec;
   WitEqAllocator * theEqAllocator;
d978 1
a978 1
   WitDemPerStack   theDemPers (myProblem ());
d1101 6
a1106 6
      const char *     demandedPartName,
      const char *     demandName,
      int              shipPer,
      float            desIncVol,
      WitBoolean       asapMultiExec,
      WitDemPerStack & theDemPers)
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d641 1
a641 1
   WitTVec (int) & tempVecRef = myApiMgr ()->useTempVec ();
d651 1
a651 1
   tempVecRef = buildAheadLimit;
d656 1
a656 1
      tempVecRef.myCvector ());
d658 1
a658 1
   myApiMgr ()->releaseTempVec ();
d872 1
a872 1
   WitTVec (int) & tempVecRef = myApiMgr ()->useTempVec ();
d882 1
a882 1
   tempVecRef = shipLateLimit;
d887 1
a887 1
      tempVecRef.myCvector ());
d889 1
a889 1
   myApiMgr ()->releaseTempVec ();
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d94 1
a94 1
   if (WitUtil::isNullString (demandNameParm))
d305 1
a305 1
   WitUtil::portableFree (buildAheadUBval);
d503 1
a503 1
   WitUtil::portableFree (shipLateUBval);
d719 1
a719 1
      nPeriods () - 1);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

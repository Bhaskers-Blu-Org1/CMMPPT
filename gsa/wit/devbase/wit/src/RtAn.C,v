head	1.114;
access;
symbols
	sce_5_01_20080919:1.104
	latest_sce_4_20_20060523:1.102.0.2
	sce_4_20_20060523:1.102
	latest_sce4_20_OSL:1.101.0.2
	sce_4_20_OSL:1.101
	sce_410_withVa:1.99
	sce_4_05_20040511:1.55
	sce_4_00_20040201:1.55
	nextGenBranch:1.52.0.2
	nextGenRoot:1.52
	sce_3_30_20030627:1.51
	EndRw-branch:1.33.0.4
	Root-of-EndRw:1.33
	rwToStl:1.33.0.2
	latest_sce_3_10_20010924:1.21.0.2
	sce_3_10_20010924:1.21
	latest_sce_3_00_20010601:1.12.0.2
	sce_3_00_20010601:1.12
	latest_sce_2_31_20010308:1.10.0.2
	sce_2_31_20010308:1.10
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.114
date	2011.09.28.23.50.04;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2011.09.24.00.28.28;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2011.08.30.20.18.05;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2010.09.28.19.25.16;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2010.08.12.23.18.16;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.30.20.20.14;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2010.07.30.16.07.52;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2010.07.29.21.03.12;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2010.06.29.23.25.15;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2010.06.29.22.32.31;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.08.01.21.28.05;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2006.09.25.21.11.58;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2006.05.02.17.34.11;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2006.02.03.16.48.13;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2005.12.05.22.24.09;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2005.03.28.20.14.38;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2005.03.10.21.11.25;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2005.03.02.23.56.52;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2005.03.02.23.32.16;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2005.03.02.23.17.53;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2005.03.02.22.34.37;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2005.03.02.21.59.46;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2005.01.27.23.13.45;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2005.01.27.21.03.28;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2005.01.26.23.50.33;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2005.01.21.23.01.51;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2005.01.19.23.50.58;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2005.01.19.18.31.04;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.01.14.21.34.40;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2005.01.14.16.20.05;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2005.01.14.00.01.17;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2005.01.13.21.27.25;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2005.01.12.22.48.38;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2005.01.11.20.28.37;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.01.10.22.34.48;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.01.10.19.02.25;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2005.01.07.23.40.56;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2004.12.23.20.30.08;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2004.12.23.17.24.20;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2004.12.06.22.38.16;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2004.11.30.20.24.49;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2004.11.30.00.19.47;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2004.11.29.21.26.24;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2004.11.24.22.45.30;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2004.11.24.00.05.54;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2004.11.23.20.50.07;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2004.11.16.21.46.04;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2004.11.15.22.02.00;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.11.12.23.50.51;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.11.12.21.03.46;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.11.12.17.02.44;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.11.22.16.12;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.11.21.25.09;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.11.20.11.10;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.11.16.30.21;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.11.10.20.41.42;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.11.10.19.00.43;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.11.09.23.08.00;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.11.06.00.30.34;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.01.19.41.11;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.09.26.16.06.06;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.25.20.44.44;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.10.22.58.17;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.09.18.55.42;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.04.29.19.55.31;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.04.29.14.27.49;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.04.21.17.11.09;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.04.01.22.39.34;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.01.20.34.30;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.31.23.09.49;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.28.23.05.33;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.24.17.24.33;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.21.23.36.55;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.21.21.35.31;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.20.19.03.58;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.03.19.16.48.26;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.14.20.13.00;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.02.23.40.49;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.02.22.18.46;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.12.30.21.57.26;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.12.30.20.37.27;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.26.19.05.30;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.04.19.14.59;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.06.18.53.41;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.05.21.20.01;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.07.20.15.03;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.22.14.32.13;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.18.14.02.43;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.12.21.02.02;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.20.04.02;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.07.23.24.29;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.21.21.55.17;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.10.22.06.57;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.28.20.30.27;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.25.16.08.19;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.18.21.44.45;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.12.17.57.02;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.20.20.07.06;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.19.14.42.52;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.11.19.29.12;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.08.18.00.28;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.01.19.23.35;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.25.20.54.36;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.21.21.55.48;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.15.19.01.51;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.11.16.35.10;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.04.22.27.53;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.28.22.13.38;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.05.19.05.31;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.04.22.07.39;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.21.20.03.28;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.25.20.12.35;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.52;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.30;	author wit;	state Exp;
branches;
next	;


desc
@@


1.114
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "RtAn.C"
//
// Contains the implementation of class RtAnalyzer.
//------------------------------------------------------------------------------

#include <RtAn.h>
#include <ExpRest.h>
#include <MrMgr.h>
#include <PrMgr.h>
#include <RtMgr.h>
#include <RtSite.h>
#include <RtCand.h>
#include <Selector.h>
#include <HeurAtor.h>
#include <BopEntry.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class RtAnalyzer.
//------------------------------------------------------------------------------

WitRtAnalyzer::WitRtAnalyzer (
         WitSelector * theSelector,
         WitExpRest *  theExpRest):

      WitProbAssoc    (theSelector),
      mySelector_     (theSelector),
      myExpRest_      (theExpRest),
      myMrMgr_        (theSelector->myMrMgr ()),
      myPrMgr_        (NULL),
      myRtMgr_        (theSelector->myRtMgr ()),
      curMrMods_      (myProblem ()),
      curPrActMods_   (myProblem ()),
      curPrDeactMods_ (myProblem ()),
      toPreAn_        (myProblem ()),
      dependents_     (myProblem ()),
      nPrereqsToAna_  (myProblem (), 0),
      toAnalyze_      (myProblem ()),
      minPen_         (myProblem (), 0.0),
      minPenValid_    (),
      printMode_      (selPrintLevelAt (1)),
      curPen_         (0.0),
      totCommitVol_   (0.0),
      weightedTotPen_ (0.0),
      inTheModPts_    ()
   {
   WitPart *   thePart;
   WitPeriod   thePer;
   WitRtCand * theRtCand;
   WitRtSite * theRtSite;

   if (mySelector_->propRtg ())
      myPrMgr_ = mySelector_->myPrMgr ();

   checkInput ();

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         dependents_.myPtrAt (thePart, thePer) = 
            new WitPartPerStack (myProblem ());

   if (DEBUG_MODE)
      minPenValid_.allocate (myProblem (), false);

   if (mySelector_->propRtg ())
      {
      if (myGlobalComp ()->tieBreakPropRt ())
         myMsgFac () ("tieBreakPropRtMsg");
      else
         myMsgFac () ("highPriPropRtgMsg");
      }
   }

//------------------------------------------------------------------------------

WitRtAnalyzer::~WitRtAnalyzer ()
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    aveExecPen;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete dependents_.myPtrAt (thePart, thePer);

   aveExecPen =
      (totCommitVol_ > FLOAT_EPSILON)?
         weightedTotPen_ / totCommitVol_:
         0.0;

   myMsgFac () ("aveExecPenMsg", aveExecPen);
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::modifyRouting ()
   {
   WitRtCand * theRtCand;
   WitPeriod   thePer;
   bool        actStat;

   findRoutingMods ();

   if (selPrintLevelAt (3))
      printMrMods ();

   while (curMrMods_.pop (theRtCand, thePer))
      {
      myMrMgr_->select (theRtCand, thePer);

      if (myGlobalComp ()->selectionRecovery ())
         myMrMgr_->storeRecoveryPair (theRtCand->myRtSite (), thePer);
      }

   if (mySelector_->tbprMode ())
      {
      if (selPrintLevelAt (3))
         printLpprMods ();

      while (curPrActMods_.pop (theRtCand, thePer))
         myPrMgr_->setActive (theRtCand, thePer, true);

      while (curPrDeactMods_.pop (theRtCand, thePer))
         {
         myPrMgr_->setActive (theRtCand, thePer, false);

         if (myGlobalComp ()->selectionRecovery ())
            myPrMgr_->storeRecoveryPair (theRtCand, thePer);
         }
      }
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::findHypoModPts (WitObjStack <WitSelPt> & theModPts)
   {
   WitRtCand * theRtCand;
   WitPeriod   thePer;
   WitSelPt *  theSelPt;
   WitRtSite * theRtSite;

   witAssert (mySelector_->selSplit ());

   myExpRest_->startTempMode ();

   myExpRest_->updatePsSup ();

   findRoutingMods ();

   myExpRest_->finishTempMode ();

   theModPts.clear ();

   while (curMrMods_.pop (theRtCand, thePer))
      {
      theRtSite = theRtCand->myRtSite ();

      theSelPt  = myMrMgr_->mySelPtFor (theRtSite, thePer);

      theModPts.push (theSelPt);
      }

   if (mySelector_->tbprMode ())
      addHypoPrModPts (theModPts);
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::recCommitVol (double commitVol)
   {
   totCommitVol_   += commitVol;

   weightedTotPen_ += commitVol * curPen_;
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::checkInput ()
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   bool          hasPenalty;

   forEachBomEntry (theBomEnt, myProblem ())
      {
      hasPenalty = (theBomEnt->execPenalty () > 0.0);

      if (not hasPenalty)
         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->execPenalty () > 0.0)
               {
               hasPenalty = true;

               break;
               }

      if (not hasPenalty)
         continue;
      
      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (theSub->netAllowed ())
            myMsgFac () ("netExecPenaltySmsg",
               theBomEnt->myOperationName (),
               theBomEnt->localIndex ());
      }
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::findRoutingMods ()
   {
   WitPart *       thePart;
   WitPeriod       fillPer;
   WitPartPerStack validPartPers (myProblem ());
      //
      // The set of pairs (thePart, thePer) for which
      // minPenValid_ (thePart)[thePer] is true.

   witAssert (inInitState ());

   if (selPrintLevelAt (3))
      printAnaHead ();

   toPreAn_.push (
      mySelector_->myHeurAtor ()->topPart (),
      mySelector_->myHeurAtor ()->topPer ());

   while (toPreAn_.pop (thePart, fillPer))
      preAnalyze (thePart, fillPer);

   while (toAnalyze_.pop (thePart, fillPer))
      {
      minPen_ (thePart)[fillPer] = analyze (thePart, fillPer);

      if (DEBUG_MODE)
         {
         minPenValid_ (thePart)[fillPer] = true;

         validPartPers.push (thePart, fillPer);
         }

      postAnalyze (thePart, fillPer);
      }

   curPen_ = 
      minPen_ (mySelector_->myHeurAtor ()->topPart ())
              [mySelector_->myHeurAtor ()->topPer ()];

   if (DEBUG_MODE)
      while (validPartPers.pop (thePart, fillPer))
         minPenValid_ (thePart)[fillPer] = false;
   }

//------------------------------------------------------------------------------

bool WitRtAnalyzer::inInitState ()
   {
   WitPart * thePart;
   WitPeriod thePer;

   if (curMrMods_.isNonEmpty ())
      return false;

   if (mySelector_->tbprMode ())
      {
      if (curPrActMods_.isNonEmpty ())
         return false;

      if (curPrDeactMods_.isNonEmpty ())
         return false;
      }

   if (toPreAn_.isNonEmpty ())
      return false;

   if (toAnalyze_.isNonEmpty ())
      return false;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         if (nPrereqsToAna_ (thePart)[thePer] != 0)
            return false;

         if (dependents_.myElemAt (thePart, thePer).isNonEmpty ())
            return false;
         }

   return true;
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::preAnalyze (WitPart * fillPart, WitPeriod fillPer)
   {
   WitPeriod     expPer;
   WitBopEntry * theBopEnt;
   WitRtCand *   theRtCand;
   WitPeriod     execPer;
   WitBomEntry * theBomEnt;

   if (selPrintLevelAt (3))
      printPreAn (fillPart, fillPer);

   if (needToAnalyze (fillPart, fillPer, expPer))
      forEachEl (theBopEnt, fillPart->producingBopEntries ())
         {
         theRtCand = myRtMgr_->myRtCandFor (theBopEnt);

         if (not activeForPreAn (theRtCand, expPer))
            continue;

         execPer = mySelector_->modelessExecPer (theBopEnt, expPer);

         forEachEl (theBomEnt, theBopEnt->myOperation ()->bom ())
            recBomEntPrereq (fillPart, fillPer, theBomEnt, execPer);
         }

   if (nPrereqsToAna_ (fillPart)[fillPer] == 0)
      toAnalyze_.push (fillPart, fillPer);

   if (selPrintLevelAt (3))
      printGap ();
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::recBomEntPrereq (
      WitPart *     fillPart, 
      WitPeriod     fillPer,
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitSubEntry * theSub;

   if (not theBomEnt->inEffect (execPer))
      return;

   if (theBomEnt->hasSubsInEffect ()[execPer])
      {
      if (canPseudoNet (theBomEnt, execPer))
         return;

      recConsEntPrereq (fillPart, fillPer, theBomEnt, execPer);

      forEachEl (theSub, theBomEnt->mySubEntries ())
         recConsEntPrereq (fillPart, fillPer, theSub, execPer);
      }
   else
      recConsEntPrereq (fillPart, fillPer, theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::recConsEntPrereq (
      WitPart *      fillPart, 
      WitPeriod      fillPer,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer)
   {
   WitRtCand * theRtCand;

   theRtCand = myRtMgr_->myRtCandFor (theConsEnt);

   if (activeForPreAn (theRtCand, execPer))
      if (theConsEnt->effConsRate ()[execPer] > 0.0)
         recordPrereq (
            fillPart, 
            fillPer, 
            theConsEnt->myPart (),
            theConsEnt->impactPeriod ()[execPer]);
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::recordPrereq (
      WitPart * depPart, 
      WitPeriod depPer,
      WitPart * prereqPart, 
      WitPeriod prereqPer)
   {
   if (dependents_.myElemAt (prereqPart, prereqPer).isEmpty ())
      toPreAn_.push (prereqPart, prereqPer);

   dependents_.myElemAt (prereqPart, prereqPer).push (depPart, depPer);

   nPrereqsToAna_ (depPart)[depPer] ++;

   if (selPrintLevelAt (3))
      printPrereq (prereqPart, prereqPer);
   }

//------------------------------------------------------------------------------

bool WitRtAnalyzer::activeForPreAn (WitRtCand * theRtCand, WitPeriod thePer)
   {
   if (not theRtCand->myRtSite ()->propRtg ()[thePer])
      return myMrMgr_->activeForPE (theRtCand, thePer);

   else
      return myPrMgr_->allowed     (theRtCand, thePer);
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::analyze (WitPart * fillPart, WitPeriod fillPer)
   {
   WitPeriod   expPer;
   WitRtSite * theRtSite;

   if (not needToAnalyze (fillPart, fillPer, expPer))
      return 0.0;

   theRtSite = myRtMgr_->myRtSiteFor (fillPart);

   if (not fillPart->propRtg ()[expPer])
      return penThruRtSiteMR   (theRtSite, expPer);

   else if (not myGlobalComp ()->tieBreakPropRt ())
      return penThruRtSiteOPR  (theRtSite, expPer);

   else
      return penThruRtSiteTBPR (theRtSite, expPer);
   }

//------------------------------------------------------------------------------

bool WitRtAnalyzer::needToAnalyze (
      WitPart *   fillPart, 
      WitPeriod   fillPer, 
      WitPeriod & expPer)
   {
   if (fillPart->producingBopEntries ().isEmpty ())
      return false;

   if (myExpRest_->hasPseudoSup (fillPart, fillPer))
      return false;

   expPer = mySelector_->modelessExpPer (fillPart, fillPer);

   if (not fillPart->explodeable (expPer))
      return false;

   if (fillPart->boundedLeadTimes ())
      if (expPer < mySelector_->myHeurAtor ()->ltbMinPer ())
         return false;

   return true;
   }  

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruBopEnt (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         penThruOpn;
   WitBomEntry *  theBomEnt;

   theOpn     = theBopEnt  ->myOperation ();
   execPer    = mySelector_->modelessExecPer (theBopEnt, expPer);
   penThruOpn = theOpn     ->execPenalty ();

   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->inEffect (execPer))
         penThruOpn += penThruBomEnt (theBomEnt, execPer);

   return penThruOpn;
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruBomEnt (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   WitRtSite * theRtSite;

   if (not theBomEnt->hasSubsInEffect ()[execPer])
      return    penThruConsEnt    (theBomEnt, execPer);

   if (not theBomEnt->propRtg ()[execPer])
      return    penThruBomEntMR   (theBomEnt, execPer);
   else
      {
      theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

      if (not myGlobalComp ()->tieBreakPropRt ())
         return penThruRtSiteOPR  (theRtSite, execPer);
      else
         return penThruRtSiteTBPR (theRtSite, execPer);
      }
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruBomEntMR (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitRtSite * theRtSite;

   if (canPseudoNet (theBomEnt, execPer))
      return 0.0;

   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

   return penThruRtSiteMR (theRtSite, execPer);
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruRtSiteMR (WitRtSite * theRtSite, WitPeriod thePer)
   {
   WitRtCand * minRtCand;
   double      minPen;
   WitRtCand * theRtCand;
   double      thePen;

   minRtCand = NULL;
   minPen    = 0.0;

   forEachEl (theRtCand, theRtSite->myRtCands ())
      if (myMrMgr_->activeForPE (theRtCand, thePer))
         {
         thePen = penThruRtCand (theRtCand, thePer);

         if ((minRtCand == NULL) or (thePen < minPen))
            {
            minRtCand = theRtCand;
            minPen    = thePen;
            }
         }

   witAssert (minRtCand != NULL);

   if (minRtCand != myMrMgr_->selRtCand (theRtSite, thePer))
      curMrMods_.push (minRtCand, thePer);

   return minPen;
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruRtSiteOPR (
      WitRtSite * theRtSite,
      WitPeriod   thePer)
   {
   double            totPen;
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            normShare;

   totPen = 0.0;

   myPrMgr_->definePropExp (theRtSite, thePer, 1.0, theExpPairs);

   while (theExpPairs.pop (theRtCand, normShare))
      totPen += normShare * penThruRtCand (theRtCand, thePer);

   return totPen;
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruRtSiteTBPR (
      WitRtSite * theRtSite,
      WitPeriod   thePer)
   {
   WitRtCand * theRtCand;
   double      thePen;
   double      minPen;
   bool        isMinimal;

   WitPairStack <WitRtCand, double> theCandPens (myProblem ());

   forEachEl (theRtCand, theRtSite->myRtCands ())
      if (myPrMgr_->allowed (theRtCand, thePer))
         {
         thePen = penThruRtCand (theRtCand, thePer);

         if (theCandPens.isEmpty ())
            minPen = thePen;

         setToMin (minPen, thePen);

         theCandPens.push (theRtCand, thePen);
         }

   witAssert (theCandPens.isNonEmpty ());

   while (theCandPens.pop (theRtCand, thePen))
      {
      isMinimal = (thePen <= minPen + FLOAT_EPSILON);

      if (isMinimal)
         if (not myPrMgr_->active (theRtCand, thePer))
            curPrActMods_.push (theRtCand, thePer);

      if (not isMinimal)
         if (myPrMgr_->active (theRtCand, thePer))
            curPrDeactMods_.push (theRtCand, thePer);
      }

   return minPen;
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruRtCand (WitRtCand * theRtCand, WitPeriod thePer)
   {
   return
      theRtCand->myRtSite ()->isForProd ()?
         penThruBopEnt  (theRtCand->myBopEnt  (), thePer):
         penThruConsEnt (theRtCand->myConsEnt (), thePer);
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruConsEnt (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer)
   {
   WitPart * consPart;
   WitPeriod consPer;

   if (theConsEnt->effConsRate ()[execPer] <= 0.0)
      return theConsEnt->execPenalty ();

   consPart = theConsEnt->myPart ();
   consPer  = theConsEnt->impactPeriod ()[execPer];

   witAssert (minPenValid_ (consPart)[consPer]);

   return theConsEnt->execPenalty () + minPen_ (consPart)[consPer];
   }

//------------------------------------------------------------------------------

bool WitRtAnalyzer::canPseudoNet (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   WitSubEntry * theSub;

   if (theBomEnt->propRtg ()[execPer])
      return false;

   if (not mySelector_->myHeurAtor ()->hasSubsToNet () (theBomEnt))
      return false;

   if (canDirPseudoNet (theBomEnt, execPer))
      return true;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->inEffect (execPer))
         if (theSub->netAllowed ())
            if (canDirPseudoNet (theSub, execPer))
               return true;

   return false;
   }

//------------------------------------------------------------------------------

bool WitRtAnalyzer::canDirPseudoNet (
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer)
   {
   WitPart * consPart;
   WitPeriod consPer;

   witAssert (theConsEnt->inEffect (execPer));

   consPart = theConsEnt->myPart ();
   consPer  = theConsEnt->impactPeriod ()[execPer];

   return myExpRest_->hasPseudoSup (consPart, consPer);
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::postAnalyze (WitPart * anaPart, WitPeriod anaPer)
   {
   WitPart * depPart;
   WitPeriod depPer;

   if (selPrintLevelAt (3))
      printAnalysis (anaPart, anaPer);

   while (dependents_.myElemAt (anaPart, anaPer).pop (depPart, depPer))
      {
      nPrereqsToAna_ (depPart)[depPer] --;

      if (nPrereqsToAna_ (depPart)[depPer] == 0)
         toAnalyze_.push (depPart, depPer);
      }
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::addHypoPrModPts (WitObjStack <WitSelPt> & theModPts)
   {
   WitRtCand * theRtCand;
   WitPeriod   thePer;
   WitRtSite * theRtSite;
   WitSelPt *  theSelPt;

   WitPairStack <WitRtSite, WitPeriod> thePrModPairs (myProblem ());
   WitPairStItr <WitRtSite, WitPeriod> theItr;

   witAssert (mySelector_->tbprMode ());

   if (inTheModPts_.domainSize () == 0)
      {
      inTheModPts_.allocate1D (myProblem ());

      forEachEl (theRtSite, myRtMgr_->myRtSites ())
         if (theRtSite->propRtg () != false)
            inTheModPts_ (theRtSite).allocate (myProblem (), false);
      }

   while (curPrActMods_.pop (theRtCand, thePer))
      thePrModPairs.push (theRtCand->myRtSite (), thePer);

   while (curPrDeactMods_.pop (theRtCand, thePer))
      thePrModPairs.push (theRtCand->myRtSite (), thePer);

   thePrModPairs.attachItr (theItr);

   while (theItr.advance (theRtSite, thePer))
      {
      if (inTheModPts_ (theRtSite)[thePer])
         continue;

      theSelPt = myPrMgr_->mySelPtFor (theRtSite, thePer);

      theModPts.push (theSelPt);

      inTheModPts_ (theRtSite)[thePer] = true;
      }

   while (thePrModPairs.pop (theRtSite, thePer))
      inTheModPts_ (theRtSite)[thePer] = false;
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::printAnaHead ()
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (),
      "\n"
      "Analyzing routings for part %s in period %d.\n\n",
      mySelector_->myHeurAtor ()->topPart ()->partName ().myCstring (),
      mySelector_->myHeurAtor ()->topPer ());
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::printPreAn (WitPart * thePart, WitPeriod thePer)
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (),
      "   Pre-analyzing Part %s in Period %d.\n",
      thePart->partName ().myCstring (),
      thePer);
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::printPrereq (WitPart * thePart, WitPeriod thePer)
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (),
      "      Prereq:    Part %s in Period %d.\n",
      thePart->partName ().myCstring (),
      thePer);
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::printGap ()
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (), "\n");
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::printAnalysis (WitPart * thePart, WitPeriod thePer)
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (), 
      "   Part %s, Period %d: Min Pen: %.0f\n", 
      thePart->partName ().myCstring (),
      thePer,
      minPen_ (thePart)[thePer]);
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::printMrMods ()
   {
   WitPairStItr <WitRtCand, WitPeriod> theItr;
   WitRtCand *                         theRtCand;
   WitPeriod                           thePer;

   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (), "\n" "Multi-Route Modifications:\n");

   if (curMrMods_.isEmpty ())
      {
      fprintf (msgFile (),
         "\n"
         "   None\n");

      return;
      }

   curMrMods_.attachItr (theItr);

   while (theItr.advance (theRtCand, thePer))
      {
      fprintf (msgFile (), "\n");

      theRtCand->myRtSite ()->printID          (4, 22);
      theRtCand->myRtSite ()->printPer (thePer, 4, 22);
      theRtCand->             printID          (7, 22);
      }
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::printLpprMods ()
   {
   if (not myExpRest_->tempMode ())
      {
      printLpprMods (curPrActMods_,   "Activations");
      printLpprMods (curPrDeactMods_, "Deactivations");
      }
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::printLpprMods (
      const WitRtCandPerStack & theRtCandPers,
      const char *              statText)
   {
   WitPairStItr <WitRtCand, WitPeriod> theItr;
   WitRtCand *                         theRtCand;
   WitPeriod                           thePer;

   witAssert (printMode_);

   fprintf (msgFile (),
      "\n"
      "Proportionate Routing %s:\n",
      statText);

   if (theRtCandPers.isEmpty ())
      {
      fprintf (msgFile (),"\n   None\n");

      return;
      }

   theRtCandPers.attachItr (theItr);

   while (theItr.advance (theRtCand, thePer))
      {
      fprintf (msgFile (),"\n");

      theRtCand->myRtSite ()->printID          (4, 22);
      theRtCand->myRtSite ()->printPer (thePer, 4, 22);
      theRtCand->             printID          (7, 22);
      }
   }
@


1.113
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.112
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d33 2
a34 2
WitSelector * theSelector,
WitExpRest *  theExpRest):
d36 47
a82 47
WitProbAssoc    (theSelector),
mySelector_     (theSelector),
myExpRest_      (theExpRest),
myMrMgr_        (theSelector->myMrMgr ()),
myPrMgr_        (NULL),
myRtMgr_        (theSelector->myRtMgr ()),
curMrMods_      (myProblem ()),
curPrActMods_   (myProblem ()),
curPrDeactMods_ (myProblem ()),
toPreAn_        (myProblem ()),
dependents_     (myProblem ()),
nPrereqsToAna_  (myProblem (), 0),
toAnalyze_      (myProblem ()),
minPen_         (myProblem (), 0.0),
minPenValid_    (),
printMode_      (selPrintLevelAt (1)),
curPen_         (0.0),
totCommitVol_   (0.0),
weightedTotPen_ (0.0),
inTheModPts_    ()
{
WitPart *   thePart;
WitPeriod   thePer;
WitRtCand * theRtCand;
WitRtSite * theRtSite;

if (mySelector_->propRtg ())
myPrMgr_ = mySelector_->myPrMgr ();

checkInput ();

forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
dependents_.myPtrAt (thePart, thePer) =
new WitPartPerStack (myProblem ());

if (DEBUG_MODE)
minPenValid_.allocate (myProblem (), false);

if (mySelector_->propRtg ())
{
if (myGlobalComp ()->tieBreakPropRt ())
myMsgFac () ("tieBreakPropRtMsg");
else
myMsgFac () ("highPriPropRtgMsg");
}
}
d87 13
a99 13
{
WitPart * thePart;
WitPeriod thePer;
double    aveExecPen;

forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
delete dependents_.myPtrAt (thePart, thePer);

aveExecPen =
(totCommitVol_ > FLOAT_EPSILON)?
weightedTotPen_ / totCommitVol_:
0.0;
d101 2
a102 2
myMsgFac () ("aveExecPenMsg", aveExecPen);
}
d107 35
a141 35
{
WitRtCand * theRtCand;
WitPeriod   thePer;
bool        actStat;

findRoutingMods ();

if (selPrintLevelAt (3))
printMrMods ();

while (curMrMods_.pop (theRtCand, thePer))
{
myMrMgr_->select (theRtCand, thePer);

if (myGlobalComp ()->selectionRecovery ())
myMrMgr_->storeRecoveryPair (theRtCand->myRtSite (), thePer);
}

if (mySelector_->tbprMode ())
{
if (selPrintLevelAt (3))
printLpprMods ();

while (curPrActMods_.pop (theRtCand, thePer))
myPrMgr_->setActive (theRtCand, thePer, true);

while (curPrDeactMods_.pop (theRtCand, thePer))
{
myPrMgr_->setActive (theRtCand, thePer, false);

if (myGlobalComp ()->selectionRecovery ())
myPrMgr_->storeRecoveryPair (theRtCand, thePer);
}
}
}
d146 5
a150 5
{
WitRtCand * theRtCand;
WitPeriod   thePer;
WitSelPt *  theSelPt;
WitRtSite * theRtSite;
d152 1
a152 1
witAssert (mySelector_->selSplit ());
d154 1
a154 1
myExpRest_->startTempMode ();
d156 1
a156 1
myExpRest_->updatePsSup ();
d158 1
a158 1
findRoutingMods ();
d160 1
a160 1
myExpRest_->finishTempMode ();
d162 1
a162 1
theModPts.clear ();
d164 3
a166 3
while (curMrMods_.pop (theRtCand, thePer))
{
theRtSite = theRtCand->myRtSite ();
d168 1
a168 1
theSelPt  = myMrMgr_->mySelPtFor (theRtSite, thePer);
d170 2
a171 2
theModPts.push (theSelPt);
}
d173 3
a175 3
if (mySelector_->tbprMode ())
addHypoPrModPts (theModPts);
}
d180 2
a181 2
{
totCommitVol_   += commitVol;
d183 2
a184 2
weightedTotPen_ += commitVol * curPen_;
}
d189 28
a216 28
{
WitBomEntry * theBomEnt;
WitSubEntry * theSub;
bool          hasPenalty;

forEachBomEntry (theBomEnt, myProblem ())
{
hasPenalty = (theBomEnt->execPenalty () > 0.0);

if (not hasPenalty)
forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->execPenalty () > 0.0)
{
hasPenalty = true;

break;
}

if (not hasPenalty)
continue;

forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->netAllowed ())
myMsgFac () ("netExecPenaltySmsg",
theBomEnt->myOperationName (),
theBomEnt->localIndex ());
}
}
d221 42
a262 42
{
WitPart *       thePart;
WitPeriod       fillPer;
WitPartPerStack validPartPers (myProblem ());
//
// The set of pairs (thePart, thePer) for which
// minPenValid_ (thePart)[thePer] is true.

witAssert (inInitState ());

if (selPrintLevelAt (3))
printAnaHead ();

toPreAn_.push (
mySelector_->myHeurAtor ()->topPart (),
mySelector_->myHeurAtor ()->topPer ());

while (toPreAn_.pop (thePart, fillPer))
preAnalyze (thePart, fillPer);

while (toAnalyze_.pop (thePart, fillPer))
{
minPen_ (thePart)[fillPer] = analyze (thePart, fillPer);

if (DEBUG_MODE)
{
minPenValid_ (thePart)[fillPer] = true;

validPartPers.push (thePart, fillPer);
}

postAnalyze (thePart, fillPer);
}

curPen_ =
minPen_ (mySelector_->myHeurAtor ()->topPart ())
[mySelector_->myHeurAtor ()->topPer ()];

if (DEBUG_MODE)
while (validPartPers.pop (thePart, fillPer))
minPenValid_ (thePart)[fillPer] = false;
}
d267 31
a297 31
{
WitPart * thePart;
WitPeriod thePer;

if (curMrMods_.isNonEmpty ())
return false;

if (mySelector_->tbprMode ())
{
if (curPrActMods_.isNonEmpty ())
return false;

if (curPrDeactMods_.isNonEmpty ())
return false;
}

if (toPreAn_.isNonEmpty ())
return false;

if (toAnalyze_.isNonEmpty ())
return false;

forEachPart (thePart, myProblem ())
forEachPeriod (thePer, myProblem ())
{
if (nPrereqsToAna_ (thePart)[thePer] != 0)
return false;

if (dependents_.myElemAt (thePart, thePer).isNonEmpty ())
return false;
}
d299 2
a300 2
return true;
}
d305 30
a334 30
{
WitPeriod     expPer;
WitBopEntry * theBopEnt;
WitRtCand *   theRtCand;
WitPeriod     execPer;
WitBomEntry * theBomEnt;

if (selPrintLevelAt (3))
printPreAn (fillPart, fillPer);

if (needToAnalyze (fillPart, fillPer, expPer))
forEachEl (theBopEnt, fillPart->producingBopEntries ())
{
theRtCand = myRtMgr_->myRtCandFor (theBopEnt);

if (not activeForPreAn (theRtCand, expPer))
continue;

execPer = mySelector_->modelessExecPer (theBopEnt, expPer);

forEachEl (theBomEnt, theBopEnt->myOperation ()->bom ())
recBomEntPrereq (fillPart, fillPer, theBomEnt, execPer);
}

if (nPrereqsToAna_ (fillPart)[fillPer] == 0)
toAnalyze_.push (fillPart, fillPer);

if (selPrintLevelAt (3))
printGap ();
}
d339 23
a361 23
WitPart *     fillPart,
WitPeriod     fillPer,
WitBomEntry * theBomEnt,
WitPeriod     execPer)
{
WitSubEntry * theSub;

if (not theBomEnt->inEffect (execPer))
return;

if (theBomEnt->hasSubsInEffect ()[execPer])
{
if (canPseudoNet (theBomEnt, execPer))
return;

recConsEntPrereq (fillPart, fillPer, theBomEnt, execPer);

forEachEl (theSub, theBomEnt->mySubEntries ())
recConsEntPrereq (fillPart, fillPer, theSub, execPer);
}
else
recConsEntPrereq (fillPart, fillPer, theBomEnt, execPer);
}
d366 17
a382 17
WitPart *      fillPart,
WitPeriod      fillPer,
WitConsEntry * theConsEnt,
WitPeriod      execPer)
{
WitRtCand * theRtCand;

theRtCand = myRtMgr_->myRtCandFor (theConsEnt);

if (activeForPreAn (theRtCand, execPer))
if (theConsEnt->effConsRate ()[execPer] > 0.0)
recordPrereq (
fillPart,
fillPer,
theConsEnt->myPart (),
theConsEnt->impactPeriod ()[execPer]);
}
d387 15
a401 15
WitPart * depPart,
WitPeriod depPer,
WitPart * prereqPart,
WitPeriod prereqPer)
{
if (dependents_.myElemAt (prereqPart, prereqPer).isEmpty ())
toPreAn_.push (prereqPart, prereqPer);

dependents_.myElemAt (prereqPart, prereqPer).push (depPart, depPer);

nPrereqsToAna_ (depPart)[depPer] ++;

if (selPrintLevelAt (3))
printPrereq (prereqPart, prereqPer);
}
d406 7
a412 7
{
if (not theRtCand->myRtSite ()->propRtg ()[thePer])
return myMrMgr_->activeForPE (theRtCand, thePer);

else
return myPrMgr_->allowed     (theRtCand, thePer);
}
d417 3
a419 3
{
WitPeriod   expPer;
WitRtSite * theRtSite;
d421 2
a422 2
if (not needToAnalyze (fillPart, fillPer, expPer))
return 0.0;
d424 1
a424 1
theRtSite = myRtMgr_->myRtSiteFor (fillPart);
d426 2
a427 2
if (not fillPart->propRtg ()[expPer])
return penThruRtSiteMR   (theRtSite, expPer);
d429 2
a430 2
else if (not myGlobalComp ()->tieBreakPropRt ())
return penThruRtSiteOPR  (theRtSite, expPer);
d432 3
a434 3
else
return penThruRtSiteTBPR (theRtSite, expPer);
}
d439 18
a456 18
WitPart *   fillPart,
WitPeriod   fillPer,
WitPeriod & expPer)
{
if (fillPart->producingBopEntries ().isEmpty ())
return false;

if (myExpRest_->hasPseudoSup (fillPart, fillPer))
return false;

expPer = mySelector_->modelessExpPer (fillPart, fillPer);

if (not fillPart->explodeable (expPer))
return false;

if (fillPart->boundedLeadTimes ())
if (expPer < mySelector_->myHeurAtor ()->ltbMinPer ())
return false;
d458 2
a459 2
return true;
}
d464 13
a476 13
{
WitOperation * theOpn;
WitPeriod      execPer;
double         penThruOpn;
WitBomEntry *  theBomEnt;

theOpn     = theBopEnt  ->myOperation ();
execPer    = mySelector_->modelessExecPer (theBopEnt, expPer);
penThruOpn = theOpn     ->execPenalty ();

forEachEl (theBomEnt, theOpn->bom ())
if (theBomEnt->inEffect (execPer))
penThruOpn += penThruBomEnt (theBomEnt, execPer);
d478 2
a479 2
return penThruOpn;
}
d484 2
a485 2
{
WitRtSite * theRtSite;
d487 2
a488 2
if (not theBomEnt->hasSubsInEffect ()[execPer])
return    penThruConsEnt    (theBomEnt, execPer);
d490 12
a501 12
if (not theBomEnt->propRtg ()[execPer])
return    penThruBomEntMR   (theBomEnt, execPer);
else
{
theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

if (not myGlobalComp ()->tieBreakPropRt ())
return penThruRtSiteOPR  (theRtSite, execPer);
else
return penThruRtSiteTBPR (theRtSite, execPer);
}
}
d506 4
a509 4
WitBomEntry * theBomEnt,
WitPeriod     execPer)
{
WitRtSite * theRtSite;
d511 2
a512 2
if (canPseudoNet (theBomEnt, execPer))
return 0.0;
d514 1
a514 1
theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);
d516 2
a517 2
return penThruRtSiteMR (theRtSite, execPer);
}
d522 20
a541 20
{
WitRtCand * minRtCand;
double      minPen;
WitRtCand * theRtCand;
double      thePen;

minRtCand = NULL;
minPen    = 0.0;

forEachEl (theRtCand, theRtSite->myRtCands ())
if (myMrMgr_->activeForPE (theRtCand, thePer))
{
thePen = penThruRtCand (theRtCand, thePer);

if ((minRtCand == NULL) or (thePen < minPen))
{
minRtCand = theRtCand;
minPen    = thePen;
}
}
d543 1
a543 1
witAssert (minRtCand != NULL);
d545 2
a546 2
if (minRtCand != myMrMgr_->selRtCand (theRtSite, thePer))
curMrMods_.push (minRtCand, thePer);
d548 2
a549 2
return minPen;
}
d554 9
a562 9
WitRtSite * theRtSite,
WitPeriod   thePer)
{
double            totPen;
WitRtCandDblStack theExpPairs (myProblem ());
WitRtCand *       theRtCand;
double            normShare;

totPen = 0.0;
d564 1
a564 1
myPrMgr_->definePropExp (theRtSite, thePer, 1.0, theExpPairs);
d566 2
a567 2
while (theExpPairs.pop (theRtCand, normShare))
totPen += normShare * penThruRtCand (theRtCand, thePer);
d569 2
a570 2
return totPen;
}
d575 37
a611 37
WitRtSite * theRtSite,
WitPeriod   thePer)
{
WitRtCand * theRtCand;
double      thePen;
double      minPen;
bool        isMinimal;

WitPairStack <WitRtCand, double> theCandPens (myProblem ());

forEachEl (theRtCand, theRtSite->myRtCands ())
if (myPrMgr_->allowed (theRtCand, thePer))
{
thePen = penThruRtCand (theRtCand, thePer);

if (theCandPens.isEmpty ())
minPen = thePen;

setToMin (minPen, thePen);

theCandPens.push (theRtCand, thePen);
}

witAssert (theCandPens.isNonEmpty ());

while (theCandPens.pop (theRtCand, thePen))
{
isMinimal = (thePen <= minPen + FLOAT_EPSILON);

if (isMinimal)
if (not myPrMgr_->active (theRtCand, thePer))
curPrActMods_.push (theRtCand, thePer);

if (not isMinimal)
if (myPrMgr_->active (theRtCand, thePer))
curPrDeactMods_.push (theRtCand, thePer);
}
d613 2
a614 2
return minPen;
}
d619 6
a624 6
{
return
theRtCand->myRtSite ()->isForProd ()?
penThruBopEnt  (theRtCand->myBopEnt  (), thePer):
penThruConsEnt (theRtCand->myConsEnt (), thePer);
}
d629 8
a636 8
WitConsEntry * theConsEnt,
WitPeriod      execPer)
{
WitPart * consPart;
WitPeriod consPer;

if (theConsEnt->effConsRate ()[execPer] <= 0.0)
return theConsEnt->execPenalty ();
d638 2
a639 2
consPart = theConsEnt->myPart ();
consPer  = theConsEnt->impactPeriod ()[execPer];
d641 1
a641 1
witAssert (minPenValid_ (consPart)[consPer]);
d643 2
a644 2
return theConsEnt->execPenalty () + minPen_ (consPart)[consPer];
}
d649 2
a650 2
{
WitSubEntry * theSub;
d652 2
a653 2
if (theBomEnt->propRtg ()[execPer])
return false;
d655 2
a656 2
if (not mySelector_->myHeurAtor ()->hasSubsToNet () (theBomEnt))
return false;
d658 8
a665 8
if (canDirPseudoNet (theBomEnt, execPer))
return true;

forEachEl (theSub, theBomEnt->mySubEntries ())
if (theSub->inEffect (execPer))
if (theSub->netAllowed ())
if (canDirPseudoNet (theSub, execPer))
return true;
d667 2
a668 2
return false;
}
d673 5
a677 5
WitConsEntry * theConsEnt,
WitPeriod      execPer)
{
WitPart * consPart;
WitPeriod consPer;
d679 1
a679 1
witAssert (theConsEnt->inEffect (execPer));
d681 2
a682 2
consPart = theConsEnt->myPart ();
consPer  = theConsEnt->impactPeriod ()[execPer];
d684 2
a685 2
return myExpRest_->hasPseudoSup (consPart, consPer);
}
d690 15
a704 15
{
WitPart * depPart;
WitPeriod depPer;

if (selPrintLevelAt (3))
printAnalysis (anaPart, anaPer);

while (dependents_.myElemAt (anaPart, anaPer).pop (depPart, depPer))
{
nPrereqsToAna_ (depPart)[depPer] --;

if (nPrereqsToAna_ (depPart)[depPer] == 0)
toAnalyze_.push (depPart, depPer);
}
}
d709 5
a713 5
{
WitRtCand * theRtCand;
WitPeriod   thePer;
WitRtSite * theRtSite;
WitSelPt *  theSelPt;
d715 2
a716 2
WitPairStack <WitRtSite, WitPeriod> thePrModPairs (myProblem ());
WitPairStItr <WitRtSite, WitPeriod> theItr;
d718 1
a718 1
witAssert (mySelector_->tbprMode ());
d720 3
a722 3
if (inTheModPts_.domainSize () == 0)
{
inTheModPts_.allocate1D (myProblem ());
d724 4
a727 4
forEachEl (theRtSite, myRtMgr_->myRtSites ())
if (theRtSite->propRtg () != false)
inTheModPts_ (theRtSite).allocate (myProblem (), false);
}
d729 2
a730 2
while (curPrActMods_.pop (theRtCand, thePer))
thePrModPairs.push (theRtCand->myRtSite (), thePer);
d732 2
a733 2
while (curPrDeactMods_.pop (theRtCand, thePer))
thePrModPairs.push (theRtCand->myRtSite (), thePer);
d735 1
a735 1
thePrModPairs.attachItr (theItr);
d737 4
a740 4
while (theItr.advance (theRtSite, thePer))
{
if (inTheModPts_ (theRtSite)[thePer])
continue;
d742 1
a742 1
theSelPt = myPrMgr_->mySelPtFor (theRtSite, thePer);
d744 1
a744 1
theModPts.push (theSelPt);
d746 2
a747 2
inTheModPts_ (theRtSite)[thePer] = true;
}
d749 3
a751 3
while (thePrModPairs.pop (theRtSite, thePer))
inTheModPts_ (theRtSite)[thePer] = false;
}
d756 10
a765 10
{
if (myExpRest_->tempMode ())
return;

fprintf (msgFile (),
"\n"
"Analyzing routings for part %s in period %d.\n\n",
mySelector_->myHeurAtor ()->topPart ()->partName ().myCstring (),
mySelector_->myHeurAtor ()->topPer ());
}
d770 9
a778 9
{
if (myExpRest_->tempMode ())
return;

fprintf (msgFile (),
"   Pre-analyzing Part %s in Period %d.\n",
thePart->partName ().myCstring (),
thePer);
}
d783 9
a791 9
{
if (myExpRest_->tempMode ())
return;

fprintf (msgFile (),
"      Prereq:    Part %s in Period %d.\n",
thePart->partName ().myCstring (),
thePer);
}
d796 3
a798 3
{
if (myExpRest_->tempMode ())
return;
d800 2
a801 2
fprintf (msgFile (), "\n");
}
d806 10
a815 10
{
if (myExpRest_->tempMode ())
return;

fprintf (msgFile (),
"   Part %s, Period %d: Min Pen: %.0f\n",
thePart->partName ().myCstring (),
thePer,
minPen_ (thePart)[thePer]);
}
d820 30
a849 30
{
WitPairStItr <WitRtCand, WitPeriod> theItr;
WitRtCand *                         theRtCand;
WitPeriod                           thePer;

if (myExpRest_->tempMode ())
return;

fprintf (msgFile (), "\n" "Multi-Route Modifications:\n");

if (curMrMods_.isEmpty ())
{
fprintf (msgFile (),
"\n"
"   None\n");

return;
}

curMrMods_.attachItr (theItr);

while (theItr.advance (theRtCand, thePer))
{
fprintf (msgFile (), "\n");

theRtCand->myRtSite ()->printID          (4, 22);
theRtCand->myRtSite ()->printPer (thePer, 4, 22);
theRtCand->             printID          (7, 22);
}
}
d854 7
a860 7
{
if (not myExpRest_->tempMode ())
{
printLpprMods (curPrActMods_,   "Activations");
printLpprMods (curPrDeactMods_, "Deactivations");
}
}
d865 32
a896 32
const WitRtCandPerStack & theRtCandPers,
const char *              statText)
{
WitPairStItr <WitRtCand, WitPeriod> theItr;
WitRtCand *                         theRtCand;
WitPeriod                           thePer;

witAssert (printMode_);

fprintf (msgFile (),
"\n"
"Proportionate Routing %s:\n",
statText);

if (theRtCandPers.isEmpty ())
{
fprintf (msgFile (),"\n   None\n");

return;
}

theRtCandPers.attachItr (theItr);

while (theItr.advance (theRtCand, thePer))
{
fprintf (msgFile (),"\n");

theRtCand->myRtSite ()->printID          (4, 22);
theRtCand->myRtSite ()->printPer (thePer, 4, 22);
theRtCand->             printID          (7, 22);
}
}
@


1.111
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d33 2
a34 2
         WitSelector * theSelector,
         WitExpRest *  theExpRest):
d36 47
a82 47
      WitProbAssoc    (theSelector),
      mySelector_     (theSelector),
      myExpRest_      (theExpRest),
      myMrMgr_        (theSelector->myMrMgr ()),
      myPrMgr_        (NULL),
      myRtMgr_        (theSelector->myRtMgr ()),
      curMrMods_      (myProblem ()),
      curPrActMods_   (myProblem ()),
      curPrDeactMods_ (myProblem ()),
      toPreAn_        (myProblem ()),
      dependents_     (myProblem ()),
      nPrereqsToAna_  (myProblem (), 0),
      toAnalyze_      (myProblem ()),
      minPen_         (myProblem (), 0.0),
      minPenValid_    (),
      printMode_      (selPrintLevelAt (1)),
      curPen_         (0.0),
      totCommitVol_   (0.0),
      weightedTotPen_ (0.0),
      inTheModPts_    ()
   {
   WitPart *   thePart;
   WitPeriod   thePer;
   WitRtCand * theRtCand;
   WitRtSite * theRtSite;

   if (mySelector_->propRtg ())
      myPrMgr_ = mySelector_->myPrMgr ();

   checkInput ();

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         dependents_.myPtrAt (thePart, thePer) = 
            new WitPartPerStack (myProblem ());

   if (DEBUG_MODE)
      minPenValid_.allocate (myProblem (), false);

   if (mySelector_->propRtg ())
      {
      if (myGlobalComp ()->tieBreakPropRt ())
         myMsgFac () ("tieBreakPropRtMsg");
      else
         myMsgFac () ("highPriPropRtgMsg");
      }
   }
d87 13
a99 13
   {
   WitPart * thePart;
   WitPeriod thePer;
   double    aveExecPen;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         delete dependents_.myPtrAt (thePart, thePer);

   aveExecPen =
      (totCommitVol_ > FLOAT_EPSILON)?
         weightedTotPen_ / totCommitVol_:
         0.0;
d101 2
a102 2
   myMsgFac () ("aveExecPenMsg", aveExecPen);
   }
d107 35
a141 35
   {
   WitRtCand * theRtCand;
   WitPeriod   thePer;
   bool        actStat;

   findRoutingMods ();

   if (selPrintLevelAt (3))
      printMrMods ();

   while (curMrMods_.pop (theRtCand, thePer))
      {
      myMrMgr_->select (theRtCand, thePer);

      if (myGlobalComp ()->selectionRecovery ())
         myMrMgr_->storeRecoveryPair (theRtCand->myRtSite (), thePer);
      }

   if (mySelector_->tbprMode ())
      {
      if (selPrintLevelAt (3))
         printLpprMods ();

      while (curPrActMods_.pop (theRtCand, thePer))
         myPrMgr_->setActive (theRtCand, thePer, true);

      while (curPrDeactMods_.pop (theRtCand, thePer))
         {
         myPrMgr_->setActive (theRtCand, thePer, false);

         if (myGlobalComp ()->selectionRecovery ())
            myPrMgr_->storeRecoveryPair (theRtCand, thePer);
         }
      }
   }
d146 5
a150 5
   {
   WitRtCand * theRtCand;
   WitPeriod   thePer;
   WitSelPt *  theSelPt;
   WitRtSite * theRtSite;
d152 1
a152 1
   witAssert (mySelector_->selSplit ());
d154 1
a154 1
   myExpRest_->startTempMode ();
d156 1
a156 1
   myExpRest_->updatePsSup ();
d158 1
a158 1
   findRoutingMods ();
d160 1
a160 1
   myExpRest_->finishTempMode ();
d162 1
a162 1
   theModPts.clear ();
d164 3
a166 3
   while (curMrMods_.pop (theRtCand, thePer))
      {
      theRtSite = theRtCand->myRtSite ();
d168 1
a168 1
      theSelPt  = myMrMgr_->mySelPtFor (theRtSite, thePer);
d170 2
a171 2
      theModPts.push (theSelPt);
      }
d173 3
a175 3
   if (mySelector_->tbprMode ())
      addHypoPrModPts (theModPts);
   }
d180 2
a181 2
   {
   totCommitVol_   += commitVol;
d183 2
a184 2
   weightedTotPen_ += commitVol * curPen_;
   }
d189 28
a216 28
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   bool          hasPenalty;

   forEachBomEntry (theBomEnt, myProblem ())
      {
      hasPenalty = (theBomEnt->execPenalty () > 0.0);

      if (not hasPenalty)
         forEachEl (theSub, theBomEnt->mySubEntries ())
            if (theSub->execPenalty () > 0.0)
               {
               hasPenalty = true;

               break;
               }

      if (not hasPenalty)
         continue;
      
      forEachEl (theSub, theBomEnt->mySubEntries ())
         if (theSub->netAllowed ())
            myMsgFac () ("netExecPenaltySmsg",
               theBomEnt->myOperationName (),
               theBomEnt->localIndex ());
      }
   }
d221 42
a262 42
   {
   WitPart *       thePart;
   WitPeriod       fillPer;
   WitPartPerStack validPartPers (myProblem ());
      //
      // The set of pairs (thePart, thePer) for which
      // minPenValid_ (thePart)[thePer] is true.

   witAssert (inInitState ());

   if (selPrintLevelAt (3))
      printAnaHead ();

   toPreAn_.push (
      mySelector_->myHeurAtor ()->topPart (),
      mySelector_->myHeurAtor ()->topPer ());

   while (toPreAn_.pop (thePart, fillPer))
      preAnalyze (thePart, fillPer);

   while (toAnalyze_.pop (thePart, fillPer))
      {
      minPen_ (thePart)[fillPer] = analyze (thePart, fillPer);

      if (DEBUG_MODE)
         {
         minPenValid_ (thePart)[fillPer] = true;

         validPartPers.push (thePart, fillPer);
         }

      postAnalyze (thePart, fillPer);
      }

   curPen_ = 
      minPen_ (mySelector_->myHeurAtor ()->topPart ())
              [mySelector_->myHeurAtor ()->topPer ()];

   if (DEBUG_MODE)
      while (validPartPers.pop (thePart, fillPer))
         minPenValid_ (thePart)[fillPer] = false;
   }
d267 31
a297 31
   {
   WitPart * thePart;
   WitPeriod thePer;

   if (curMrMods_.isNonEmpty ())
      return false;

   if (mySelector_->tbprMode ())
      {
      if (curPrActMods_.isNonEmpty ())
         return false;

      if (curPrDeactMods_.isNonEmpty ())
         return false;
      }

   if (toPreAn_.isNonEmpty ())
      return false;

   if (toAnalyze_.isNonEmpty ())
      return false;

   forEachPart (thePart, myProblem ())
      forEachPeriod (thePer, myProblem ())
         {
         if (nPrereqsToAna_ (thePart)[thePer] != 0)
            return false;

         if (dependents_.myElemAt (thePart, thePer).isNonEmpty ())
            return false;
         }
d299 2
a300 2
   return true;
   }
d305 30
a334 30
   {
   WitPeriod     expPer;
   WitBopEntry * theBopEnt;
   WitRtCand *   theRtCand;
   WitPeriod     execPer;
   WitBomEntry * theBomEnt;

   if (selPrintLevelAt (3))
      printPreAn (fillPart, fillPer);

   if (needToAnalyze (fillPart, fillPer, expPer))
      forEachEl (theBopEnt, fillPart->producingBopEntries ())
         {
         theRtCand = myRtMgr_->myRtCandFor (theBopEnt);

         if (not activeForPreAn (theRtCand, expPer))
            continue;

         execPer = mySelector_->modelessExecPer (theBopEnt, expPer);

         forEachEl (theBomEnt, theBopEnt->myOperation ()->bom ())
            recBomEntPrereq (fillPart, fillPer, theBomEnt, execPer);
         }

   if (nPrereqsToAna_ (fillPart)[fillPer] == 0)
      toAnalyze_.push (fillPart, fillPer);

   if (selPrintLevelAt (3))
      printGap ();
   }
d339 23
a361 23
      WitPart *     fillPart, 
      WitPeriod     fillPer,
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitSubEntry * theSub;

   if (not theBomEnt->inEffect (execPer))
      return;

   if (theBomEnt->hasSubsInEffect ()[execPer])
      {
      if (canPseudoNet (theBomEnt, execPer))
         return;

      recConsEntPrereq (fillPart, fillPer, theBomEnt, execPer);

      forEachEl (theSub, theBomEnt->mySubEntries ())
         recConsEntPrereq (fillPart, fillPer, theSub, execPer);
      }
   else
      recConsEntPrereq (fillPart, fillPer, theBomEnt, execPer);
   }
d366 17
a382 17
      WitPart *      fillPart, 
      WitPeriod      fillPer,
      WitConsEntry * theConsEnt,
      WitPeriod      execPer)
   {
   WitRtCand * theRtCand;

   theRtCand = myRtMgr_->myRtCandFor (theConsEnt);

   if (activeForPreAn (theRtCand, execPer))
      if (theConsEnt->effConsRate ()[execPer] > 0.0)
         recordPrereq (
            fillPart, 
            fillPer, 
            theConsEnt->myPart (),
            theConsEnt->impactPeriod ()[execPer]);
   }
d387 15
a401 15
      WitPart * depPart, 
      WitPeriod depPer,
      WitPart * prereqPart, 
      WitPeriod prereqPer)
   {
   if (dependents_.myElemAt (prereqPart, prereqPer).isEmpty ())
      toPreAn_.push (prereqPart, prereqPer);

   dependents_.myElemAt (prereqPart, prereqPer).push (depPart, depPer);

   nPrereqsToAna_ (depPart)[depPer] ++;

   if (selPrintLevelAt (3))
      printPrereq (prereqPart, prereqPer);
   }
d406 7
a412 7
   {
   if (not theRtCand->myRtSite ()->propRtg ()[thePer])
      return myMrMgr_->activeForPE (theRtCand, thePer);

   else
      return myPrMgr_->allowed     (theRtCand, thePer);
   }
d417 3
a419 3
   {
   WitPeriod   expPer;
   WitRtSite * theRtSite;
d421 2
a422 2
   if (not needToAnalyze (fillPart, fillPer, expPer))
      return 0.0;
d424 1
a424 1
   theRtSite = myRtMgr_->myRtSiteFor (fillPart);
d426 2
a427 2
   if (not fillPart->propRtg ()[expPer])
      return penThruRtSiteMR   (theRtSite, expPer);
d429 2
a430 2
   else if (not myGlobalComp ()->tieBreakPropRt ())
      return penThruRtSiteOPR  (theRtSite, expPer);
d432 3
a434 3
   else
      return penThruRtSiteTBPR (theRtSite, expPer);
   }
d439 18
a456 18
      WitPart *   fillPart, 
      WitPeriod   fillPer, 
      WitPeriod & expPer)
   {
   if (fillPart->producingBopEntries ().isEmpty ())
      return false;

   if (myExpRest_->hasPseudoSup (fillPart, fillPer))
      return false;

   expPer = mySelector_->modelessExpPer (fillPart, fillPer);

   if (not fillPart->explodeable (expPer))
      return false;

   if (fillPart->boundedLeadTimes ())
      if (expPer < mySelector_->myHeurAtor ()->ltbMinPer ())
         return false;
d458 2
a459 2
   return true;
   }  
d464 13
a476 13
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         penThruOpn;
   WitBomEntry *  theBomEnt;

   theOpn     = theBopEnt  ->myOperation ();
   execPer    = mySelector_->modelessExecPer (theBopEnt, expPer);
   penThruOpn = theOpn     ->execPenalty ();

   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->inEffect (execPer))
         penThruOpn += penThruBomEnt (theBomEnt, execPer);
d478 2
a479 2
   return penThruOpn;
   }
d484 2
a485 2
   {
   WitRtSite * theRtSite;
d487 2
a488 2
   if (not theBomEnt->hasSubsInEffect ()[execPer])
      return    penThruConsEnt    (theBomEnt, execPer);
d490 12
a501 12
   if (not theBomEnt->propRtg ()[execPer])
      return    penThruBomEntMR   (theBomEnt, execPer);
   else
      {
      theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

      if (not myGlobalComp ()->tieBreakPropRt ())
         return penThruRtSiteOPR  (theRtSite, execPer);
      else
         return penThruRtSiteTBPR (theRtSite, execPer);
      }
   }
d506 4
a509 4
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitRtSite * theRtSite;
d511 2
a512 2
   if (canPseudoNet (theBomEnt, execPer))
      return 0.0;
d514 1
a514 1
   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);
d516 2
a517 2
   return penThruRtSiteMR (theRtSite, execPer);
   }
d522 20
a541 20
   {
   WitRtCand * minRtCand;
   double      minPen;
   WitRtCand * theRtCand;
   double      thePen;

   minRtCand = NULL;
   minPen    = 0.0;

   forEachEl (theRtCand, theRtSite->myRtCands ())
      if (myMrMgr_->activeForPE (theRtCand, thePer))
         {
         thePen = penThruRtCand (theRtCand, thePer);

         if ((minRtCand == NULL) or (thePen < minPen))
            {
            minRtCand = theRtCand;
            minPen    = thePen;
            }
         }
d543 1
a543 1
   witAssert (minRtCand != NULL);
d545 2
a546 2
   if (minRtCand != myMrMgr_->selRtCand (theRtSite, thePer))
      curMrMods_.push (minRtCand, thePer);
d548 2
a549 2
   return minPen;
   }
d554 9
a562 9
      WitRtSite * theRtSite,
      WitPeriod   thePer)
   {
   double            totPen;
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            normShare;

   totPen = 0.0;
d564 1
a564 1
   myPrMgr_->definePropExp (theRtSite, thePer, 1.0, theExpPairs);
d566 2
a567 2
   while (theExpPairs.pop (theRtCand, normShare))
      totPen += normShare * penThruRtCand (theRtCand, thePer);
d569 2
a570 2
   return totPen;
   }
d575 37
a611 37
      WitRtSite * theRtSite,
      WitPeriod   thePer)
   {
   WitRtCand * theRtCand;
   double      thePen;
   double      minPen;
   bool        isMinimal;

   WitPairStack <WitRtCand, double> theCandPens (myProblem ());

   forEachEl (theRtCand, theRtSite->myRtCands ())
      if (myPrMgr_->allowed (theRtCand, thePer))
         {
         thePen = penThruRtCand (theRtCand, thePer);

         if (theCandPens.isEmpty ())
            minPen = thePen;

         setToMin (minPen, thePen);

         theCandPens.push (theRtCand, thePen);
         }

   witAssert (theCandPens.isNonEmpty ());

   while (theCandPens.pop (theRtCand, thePen))
      {
      isMinimal = (thePen <= minPen + FLOAT_EPSILON);

      if (isMinimal)
         if (not myPrMgr_->active (theRtCand, thePer))
            curPrActMods_.push (theRtCand, thePer);

      if (not isMinimal)
         if (myPrMgr_->active (theRtCand, thePer))
            curPrDeactMods_.push (theRtCand, thePer);
      }
d613 2
a614 2
   return minPen;
   }
d619 6
a624 6
   {
   return
      theRtCand->myRtSite ()->isForProd ()?
         penThruBopEnt  (theRtCand->myBopEnt  (), thePer):
         penThruConsEnt (theRtCand->myConsEnt (), thePer);
   }
d629 8
a636 8
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer)
   {
   WitPart * consPart;
   WitPeriod consPer;

   if (theConsEnt->effConsRate ()[execPer] <= 0.0)
      return theConsEnt->execPenalty ();
d638 2
a639 2
   consPart = theConsEnt->myPart ();
   consPer  = theConsEnt->impactPeriod ()[execPer];
d641 1
a641 1
   witAssert (minPenValid_ (consPart)[consPer]);
d643 2
a644 2
   return theConsEnt->execPenalty () + minPen_ (consPart)[consPer];
   }
d649 2
a650 2
   {
   WitSubEntry * theSub;
d652 2
a653 2
   if (theBomEnt->propRtg ()[execPer])
      return false;
d655 2
a656 2
   if (not mySelector_->myHeurAtor ()->hasSubsToNet () (theBomEnt))
      return false;
d658 8
a665 8
   if (canDirPseudoNet (theBomEnt, execPer))
      return true;

   forEachEl (theSub, theBomEnt->mySubEntries ())
      if (theSub->inEffect (execPer))
         if (theSub->netAllowed ())
            if (canDirPseudoNet (theSub, execPer))
               return true;
d667 2
a668 2
   return false;
   }
d673 5
a677 5
      WitConsEntry * theConsEnt, 
      WitPeriod      execPer)
   {
   WitPart * consPart;
   WitPeriod consPer;
d679 1
a679 1
   witAssert (theConsEnt->inEffect (execPer));
d681 2
a682 2
   consPart = theConsEnt->myPart ();
   consPer  = theConsEnt->impactPeriod ()[execPer];
d684 2
a685 2
   return myExpRest_->hasPseudoSup (consPart, consPer);
   }
d690 15
a704 15
   {
   WitPart * depPart;
   WitPeriod depPer;

   if (selPrintLevelAt (3))
      printAnalysis (anaPart, anaPer);

   while (dependents_.myElemAt (anaPart, anaPer).pop (depPart, depPer))
      {
      nPrereqsToAna_ (depPart)[depPer] --;

      if (nPrereqsToAna_ (depPart)[depPer] == 0)
         toAnalyze_.push (depPart, depPer);
      }
   }
d709 5
a713 5
   {
   WitRtCand * theRtCand;
   WitPeriod   thePer;
   WitRtSite * theRtSite;
   WitSelPt *  theSelPt;
d715 2
a716 2
   WitPairStack <WitRtSite, WitPeriod> thePrModPairs (myProblem ());
   WitPairStItr <WitRtSite, WitPeriod> theItr;
d718 1
a718 1
   witAssert (mySelector_->tbprMode ());
d720 3
a722 3
   if (inTheModPts_.domainSize () == 0)
      {
      inTheModPts_.allocate1D (myProblem ());
d724 4
a727 4
      forEachEl (theRtSite, myRtMgr_->myRtSites ())
         if (theRtSite->propRtg () != false)
            inTheModPts_ (theRtSite).allocate (myProblem (), false);
      }
d729 2
a730 2
   while (curPrActMods_.pop (theRtCand, thePer))
      thePrModPairs.push (theRtCand->myRtSite (), thePer);
d732 2
a733 2
   while (curPrDeactMods_.pop (theRtCand, thePer))
      thePrModPairs.push (theRtCand->myRtSite (), thePer);
d735 1
a735 1
   thePrModPairs.attachItr (theItr);
d737 4
a740 4
   while (theItr.advance (theRtSite, thePer))
      {
      if (inTheModPts_ (theRtSite)[thePer])
         continue;
d742 1
a742 1
      theSelPt = myPrMgr_->mySelPtFor (theRtSite, thePer);
d744 1
a744 1
      theModPts.push (theSelPt);
d746 2
a747 2
      inTheModPts_ (theRtSite)[thePer] = true;
      }
d749 3
a751 3
   while (thePrModPairs.pop (theRtSite, thePer))
      inTheModPts_ (theRtSite)[thePer] = false;
   }
d756 10
a765 10
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (),
      "\n"
      "Analyzing routings for part %s in period %d.\n\n",
      mySelector_->myHeurAtor ()->topPart ()->partName ().myCstring (),
      mySelector_->myHeurAtor ()->topPer ());
   }
d770 9
a778 9
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (),
      "   Pre-analyzing Part %s in Period %d.\n",
      thePart->partName ().myCstring (),
      thePer);
   }
d783 9
a791 9
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (),
      "      Prereq:    Part %s in Period %d.\n",
      thePart->partName ().myCstring (),
      thePer);
   }
d796 3
a798 3
   {
   if (myExpRest_->tempMode ())
      return;
d800 2
a801 2
   fprintf (msgFile (), "\n");
   }
d806 10
a815 10
   {
   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (), 
      "   Part %s, Period %d: Min Pen: %.0f\n", 
      thePart->partName ().myCstring (),
      thePer,
      minPen_ (thePart)[thePer]);
   }
d820 30
a849 30
   {
   WitPairStItr <WitRtCand, WitPeriod> theItr;
   WitRtCand *                         theRtCand;
   WitPeriod                           thePer;

   if (myExpRest_->tempMode ())
      return;

   fprintf (msgFile (), "\n" "Multi-Route Modifications:\n");

   if (curMrMods_.isEmpty ())
      {
      fprintf (msgFile (),
         "\n"
         "   None\n");

      return;
      }

   curMrMods_.attachItr (theItr);

   while (theItr.advance (theRtCand, thePer))
      {
      fprintf (msgFile (), "\n");

      theRtCand->myRtSite ()->printID          (4, 22);
      theRtCand->myRtSite ()->printPer (thePer, 4, 22);
      theRtCand->             printID          (7, 22);
      }
   }
d854 7
a860 7
   {
   if (not myExpRest_->tempMode ())
      {
      printLpprMods (curPrActMods_,   "Activations");
      printLpprMods (curPrDeactMods_, "Deactivations");
      }
   }
d865 32
a896 32
      const WitRtCandPerStack & theRtCandPers,
      const char *              statText)
   {
   WitPairStItr <WitRtCand, WitPeriod> theItr;
   WitRtCand *                         theRtCand;
   WitPeriod                           thePer;

   witAssert (printMode_);

   fprintf (msgFile (),
      "\n"
      "Proportionate Routing %s:\n",
      statText);

   if (theRtCandPers.isEmpty ())
      {
      fprintf (msgFile (),"\n   None\n");

      return;
      }

   theRtCandPers.attachItr (theItr);

   while (theItr.advance (theRtCand, thePer))
      {
      fprintf (msgFile (),"\n");

      theRtCand->myRtSite ()->printID          (4, 22);
      theRtCand->myRtSite ()->printPer (thePer, 4, 22);
      theRtCand->             printID          (7, 22);
      }
   }
@


1.110
log
@Lead Time Bounds.
@
text
@d122 1
a122 1
         myMrMgr_->storeRecoveryPt (theRtCand->myRtSite (), thePer);
d138 1
a138 1
            myPrMgr_->storeRecoveryPt (theRtCand, thePer);
@


1.109
log
@Selection Recovery
@
text
@d451 8
a458 1
   return fillPart->explodeable (expPer);
@


1.108
log
@Selection Recovery
@
text
@d122 1
a122 1
         myMrMgr_->recAltForRecovery (theRtCand->myRtSite (), thePer);
d138 1
a138 1
            myPrMgr_->recAltForRecovery (theRtCand, thePer);
@


1.107
log
@Selection Recovery
@
text
@d134 1
d136 4
@


1.106
log
@Selection reuse.
@
text
@d118 1
d121 4
@


1.105
log
@Selection reuse.
@
text
@d114 1
a114 1
   if (printMode_) 
d122 1
a122 1
      if (printMode_) 
d221 1
a221 1
   if (printMode_) 
d302 1
a302 1
   if (printMode_) 
d322 1
a322 1
   if (printMode_) 
d389 1
a389 1
   if (printMode_) 
d677 1
a677 1
   if (printMode_) 
a739 5
   witAssert (printMode_);

   if (not selPrintLevelAt (3))
      return;

a753 5
   witAssert (printMode_);

   if (not selPrintLevelAt (3))
      return;

a766 5
   witAssert (printMode_);

   if (not selPrintLevelAt (3))
      return;

a779 5
   witAssert (printMode_);

   if (not selPrintLevelAt (3))
      return;

a789 5
   witAssert (printMode_);

   if (not selPrintLevelAt (3))
      return;

a807 5
   witAssert (printMode_);

   if (not selPrintLevelAt (3))
      return;

d838 5
a842 8
   witAssert (printMode_);

   if (selPrintLevelAt (3))
      if (not myExpRest_->tempMode ())
         {
         printLpprMods (curPrActMods_,   "Activations");
         printLpprMods (curPrDeactMods_, "Deactivations");
         }
@


1.104
log
@Stochastic Implosion
@
text
@d51 1
a51 1
      printMode_      (myGlobalComp ()->selPrintLevel () >= 1),
d742 1
a742 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d761 1
a761 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d779 1
a779 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d797 1
a797 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d812 1
a812 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d835 1
a835 1
   if (myGlobalComp ()->selPrintLevel () < 3)
d870 1
a870 1
   if (myGlobalComp ()->selPrintLevel () >= 3)
@


1.103
log
@Heuristic search increment.
@
text
@d36 1
a36 2
      WitProbAssoc    (theSelector->myProblem ()),

@


1.102
log
@Updated the copyright date on all source files.
@
text
@d170 1
a170 1
void WitRtAnalyzer::recCommitVol (double commitVol, bool byExp)
d172 1
a172 1
   totCommitVol_      += commitVol;
d174 1
a174 2
   if (byExp)
      weightedTotPen_ += commitVol * curPen_;
@


1.101
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.100
log
@[shared-resource pegging]
@
text
@d720 1
a720 1
   thePrModPairs.attach (theItr);
d854 1
a854 1
   curMrMods_.attach (theItr);
d904 1
a904 1
   theRtCandPers.attach (theItr);
@


1.99
log
@Revised mappingIndex code.
@
text
@d720 1
a720 1
   theItr.attachTo (thePrModPairs);
d854 1
a854 1
   theItr.attachTo (curMrMods_);
d904 1
a904 1
   theItr.attachTo (theRtCandPers);
@


1.98
log
@Fixed a bug in penalized execution:
   canPseudoNet needed to skip BomEnts that won't be netted.
@
text
@a26 1
#include <MapIdxI.h>
@


1.97
log
@Vector PropRtg.
@
text
@d641 3
@


1.96
log
@Vector PropRtg.
@
text
@d64 1
a64 1
   if (mySelector_->propRouting ())
d77 1
a77 1
   if (mySelector_->propRouting ())
@


1.95
log
@Vector PropRtg.
@
text
@d400 4
a403 1
   if (theRtCand->myRtSite ()->propRtg ()[thePer])
a404 2

   return    myMrMgr_->activeForPE (theRtCand, thePer);
d419 2
a420 4
   if (fillPart->propRtg ()[expPer])
      {
      if (myGlobalComp ()->tieBreakPropRt ())
         return penThruRtSiteTBPR (theRtSite, expPer);
d422 2
a423 2
      return    penThruRtSiteOPR  (theRtSite, expPer);
      }
d425 2
a426 1
   return       penThruRtSiteMR   (theRtSite, expPer);
d474 1
a474 1
      return penThruConsEnt (theBomEnt, execPer);
d476 3
a478 1
   if (theBomEnt->propRtg ()[execPer])
d482 3
a484 1
      if (myGlobalComp ()->tieBreakPropRt ())
a485 2

      return    penThruRtSiteOPR  (theRtSite, execPer);
a486 2

   return       penThruBomEntMR   (theBomEnt, execPer);
@


1.94
log
@Vector PropRtg.
@
text
@d708 2
a709 6
         {
         if (theRtSite->propRtg () == false)
            continue;

         inTheModPts_ (theRtSite).allocate (myProblem (), false);
         }
@


1.93
log
@Vector Prop-Rtg.
@
text
@d82 1
a82 1
         myMsgFac () ("highPriPropRtMsg");
d400 1
a400 1
   if (theRtCand->myRtSite ()->propRt ()[thePer])
d418 1
a418 1
   if (fillPart->propRt ()[expPer])
d476 1
a476 1
   if (theBomEnt->propRt ()[execPer])
d638 1
a638 1
   if (theBomEnt->propRt ()[execPer])
d709 1
a709 1
         if (theRtSite->propRt () == false)
@


1.92
log
@Tie breaking prop-rt.
@
text
@d400 1
a400 1
   if (theRtCand->myRtSite ()->propRouting ())
d418 1
a418 1
   if (fillPart->propRouting ())
d474 1
a474 1
      return penThruConsEnt    (theBomEnt,              execPer);
d476 1
a476 1
   if (theBomEnt->propRouting ())
d638 1
a638 1
   if (theBomEnt->propRouting ())
d708 6
a713 2
         if (theRtSite->propRouting ())
            inTheModPts_ (theRtSite).allocate (myProblem (), false);
@


1.91
log
@Pegged critical list.
@
text
@d449 58
a613 58
double WitRtAnalyzer::penThruBopEnt (WitBopEntry * theBopEnt, WitPeriod expPer)
   {
   WitOperation * theOpn;
   WitPeriod      execPer;
   double         penThruOpn;
   WitBomEntry *  theBomEnt;

   theOpn     = theBopEnt  ->myOperation ();
   execPer    = mySelector_->modelessExecPer (theBopEnt, expPer);
   penThruOpn = theOpn     ->execPenalty ();

   forEachEl (theBomEnt, theOpn->bom ())
      if (theBomEnt->inEffect (execPer))
         penThruOpn += penThruBomEnt (theBomEnt, execPer);

   return penThruOpn;
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruBomEnt (WitBomEntry * theBomEnt, WitPeriod execPer)
   {
   WitRtSite * theRtSite;

   if (not theBomEnt->hasSubsInEffect ()[execPer])
      return penThruConsEnt    (theBomEnt,              execPer);

   if (theBomEnt->propRouting ())
      {
      theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

      if (myGlobalComp ()->tieBreakPropRt ())
         return penThruRtSiteTBPR (theRtSite, execPer);

      return    penThruRtSiteOPR  (theRtSite, execPer);
      }

   return       penThruBomEntMR   (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruBomEntMR (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitRtSite * theRtSite;

   if (canPseudoNet (theBomEnt, execPer))
      return 0.0;

   theRtSite = myRtMgr_->myRtSiteFor (theBomEnt);

   return penThruRtSiteMR (theRtSite, execPer);
   }

//------------------------------------------------------------------------------

@


1.90
log
@Pegged critical list.
@
text
@d301 1
d311 3
a313 1
         if (not activeForPreAn (theBopEnt->myRtCand (), expPer))
d364 5
a368 1
   if (activeForPreAn (theConsEnt->myRtCand (), execPer))
@


1.89
log
@Changed terminology from "low priority proportionate routing" to
"tie breaking proportionate routing".
@
text
@d43 1
d79 3
a81 1
      if (not myGlobalComp ()->tieBreakPropRt ())
a82 2
      else
         myMsgFac () ("tieBreakPropRtMsg");
d393 1
a393 3
   if (not theRtCand->myRtSite ()->propRouting ())
      return myMrMgr_->activeForPE (theRtCand, thePer);
   else
d395 2
d409 1
a409 1
   theRtSite = fillPart->myRtSite ();
d411 4
a414 2
   if (not fillPart->propRouting ())
      return penThruRtSiteMR   (theRtSite, expPer);
d416 2
a417 2
   else if (not myGlobalComp ()->tieBreakPropRt ())
      return penThruRtSiteOPR  (theRtSite, expPer);
d419 1
a419 2
   else
      return penThruRtSiteTBPR (theRtSite, expPer);
d571 2
d576 3
a578 2
   else if (not theBomEnt->propRouting ())
      return penThruBomEntMR   (theBomEnt,              execPer);
d580 2
a581 2
   else if (not myGlobalComp ()->tieBreakPropRt ())
      return penThruRtSiteOPR  (theBomEnt->myRtSite (), execPer);
d583 4
a586 2
   else
      return penThruRtSiteTBPR (theBomEnt->myRtSite (), execPer);
d595 2
d599 4
a602 2
   else
      return penThruRtSiteMR (theBomEnt->myRtSite (), execPer);
d700 1
a700 1
      forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
@


1.88
log
@Low-Pri Prop-Rt.
@
text
@d78 1
a78 1
      if (not myGlobalComp ()->lowPriPropRt ())
d81 1
a81 1
         myMsgFac () ("lowPriPropRtMsg");
d121 1
a121 1
   if (mySelector_->lpprMode ())
d164 1
a164 1
   if (mySelector_->lpprMode ())
d266 1
a266 1
   if (mySelector_->lpprMode ())
d413 2
a414 2
   else if (not myGlobalComp ()->lowPriPropRt ())
      return penThruRtSiteHPPR (theRtSite, expPer);
d417 1
a417 1
      return penThruRtSiteLPPR (theRtSite, expPer);
d472 1
a472 1
double WitRtAnalyzer::penThruRtSiteHPPR (
d493 1
a493 1
double WitRtAnalyzer::penThruRtSiteLPPR (
d575 2
a576 2
   else if (not myGlobalComp ()->lowPriPropRt ())
      return penThruRtSiteHPPR (theBomEnt->myRtSite (), execPer);
d579 1
a579 1
      return penThruRtSiteLPPR (theBomEnt->myRtSite (), execPer);
d683 1
a683 1
   witAssert (mySelector_->lpprMode ());
@


1.87
log
@Low-Pri Prop-Rt.
@
text
@d33 3
a35 1
WitRtAnalyzer::WitRtAnalyzer (WitSelector * theSelector):
d40 1
a41 1
      myExpRest_      (theSelector->myExpRest ()),
@


1.86
log
@Low-Pri Prop-Rt.
@
text
@d538 1
a538 1
      (theRtCand->myRtSite ()->myRtCase () == prodRtCase)?
@


1.85
log
@Low-Pri Prop-Rt.
@
text
@d114 1
a114 1
      printMods ();
d807 1
a807 1
void WitRtAnalyzer::printMods ()
d821 1
a821 1
   fprintf (msgFile (), "\n" "Routing Modifications:\n");
@


1.84
log
@Low-Pri Prop-Rt.
@
text
@a73 10
   if (mySelector_->lpprMode ())
      if (mySelector_->selSplit ())
         {
         inTheModPts_.allocate1D (myProblem ());

         forEachEl (theRtSite, mySelector_->myRtMgr ()->myRtSites ())
            if (theRtSite->propRouting ())
               inTheModPts_ (theRtSite).allocate (myProblem (), false);
         }

d683 9
a717 51
#if 0

void WitRtAnalyzer::addHypoPrModPts (WitObjStack <WitSelPt> & theModPts)
   {
   WitRtCand * theRtCand;
   WitPeriod   thePer;
   WitRtSite * theRtSite;
   WitSelPt *  theSelPt;

   WitPairStack <WitRtSite, WitPeriod> theSitePers (myProblem ());

   witAssert (mySelector_->lpprMode ());

   while (curPrActMods_.pop (theRtCand, thePer))
      {
      theRtSite = theRtCand->myRtSite ();

      if (inTheModPts_ (theRtSite)[thePer])
         continue;

      theSitePers.push (theRtSite, thePer);

      inTheModPts_ (theRtSite)[thePer] = true;
      }

   while (curPrDeactMods_.pop (theRtCand, thePer))
      {
      theRtSite = theRtCand->myRtSite ();

      if (inTheModPts_ (theRtSite)[thePer])
         continue;

      theSitePers.push (theRtSite, thePer);

      inTheModPts_ (theRtSite)[thePer] = true;
      }

   while (theSitePers.pop (theRtSite, thePer))
      {
      inTheModPts_ (theRtSite)[thePer] = false;

      theSelPt = myPrMgr_->mySelPtFor (theRtSite, thePer);

      theModPts.push (theSelPt);
      }
   }

#endif

//------------------------------------------------------------------------------

@


1.83
log
@Low-Pri Prop-Rt.
@
text
@d53 2
a54 1
      weightedTotPen_ (0.0)
d59 1
d74 10
d151 2
d171 3
d681 89
@


1.82
log
@Low-Pri Prop-Rt.
@
text
@d42 2
a43 2
      curLpprMods_    (myProblem ()),
      modLpprActStat_ (),
a68 9
   if (mySelector_->lpprMode ())
      {
      modLpprActStat_.allocate1D (myProblem ());

      forEachEl (theRtCand, mySelector_->myRtMgr ()->myRtCands ())
         if (theRtCand->myRtSite ()->propRouting ())
            modLpprActStat_ (theRtCand).allocate (myProblem (), true);
      }

d122 2
a123 3
      while (curLpprMods_.pop (theRtCand, thePer))
         {
         actStat = modLpprActStat_ (theRtCand)[thePer];
d125 2
a126 2
         myPrMgr_->setActive (theRtCand, thePer, actStat);
         }
d258 5
a262 1
      if (curLpprMods_.isNonEmpty ())
d264 1
d514 7
a520 6
      if (isMinimal == myPrMgr_->active (theRtCand, thePer))
         continue;

      curLpprMods_.push (theRtCand, thePer);

      modLpprActStat_ (theRtCand)[thePer] = isMinimal;
d794 16
d816 4
a819 5
   if (myGlobalComp ()->selPrintLevel () < 3)
      return;

   if (myExpRest_->tempMode ())
      return;
d821 1
a821 3
   fprintf (msgFile (), "\n" "LPPR Routing Modifications:\n");

   if (curLpprMods_.isEmpty ())
d823 1
a823 3
      fprintf (msgFile (),
         "\n"
         "   None\n");
d828 1
a828 1
   theItr.attachTo (curLpprMods_);
d832 5
a836 10
      fprintf (msgFile (),
         "\n"
         "   %s:\n",
         modLpprActStat_ (theRtCand)[thePer]?
            "Activated":
            "Deactivated");

      theRtCand->myRtSite ()->printID           (7, 22);
      theRtCand->myRtSite ()->printPer (thePer,  7, 22);
      theRtCand->             printID          (10, 22);
@


1.81
log
@Low-Pri Prop-Rt.
@
text
@d142 1
a142 1
void WitRtAnalyzer::findRoutingMods (WitRtCandPerStack & theMrMods)
d144 9
d155 12
a166 1
   theMrMods.takeContents (curMrMods_);
@


1.80
log
@Low-Pri Prop-Rt.
@
text
@d739 1
a739 1
   WitPairStItr <WitRtCand, WitPeriod> theRtCandItr;
d762 1
a762 1
   theRtCandItr.attachTo (curMrMods_);
d764 1
a764 1
   while (theRtCandItr.advance (theRtCand, thePer))
d778 1
a778 1
   WitPairStItr <WitRtCand, WitPeriod> theRtCandItr;
d801 1
a801 1
   theRtCandItr.attachTo (curLpprMods_);
d803 1
a803 1
   while (theRtCandItr.advance (theRtCand, thePer))
@


1.79
log
@Low-Pri Prop-Rt.
@
text
@a18 1
#include <PoMgr.h>
a39 1
      myPoMgr_        (NULL),
d60 1
a60 6
      {
      if (myGlobalComp ()->newPropRt ())
         myPrMgr_ = mySelector_->myPrMgr ();
      else
         myPoMgr_ = mySelector_->myPoMgr ();
      }
d135 1
a135 4
         if (myGlobalComp ()->newPropRt ())
            myPrMgr_->setActive (theRtCand, thePer, actStat);
         else
            myPoMgr_->setActive (theRtCand, thePer, actStat);
d369 1
a369 1
      return myMrMgr_->activeForPE  (theRtCand, thePer);
d371 1
a371 6
      {
      if (myGlobalComp ()->newPropRt ())
         return myPrMgr_->allowed   (theRtCand, thePer);
      else
         return myPoMgr_->potActive (theRtCand, thePer);
      }
d459 1
a459 4
   if (myGlobalComp ()->newPropRt ())
      myPrMgr_->definePropExp (theRtSite, thePer, 1.0, theExpPairs);
   else
      myPoMgr_->definePropExp (theRtSite, thePer, 1.0, theExpPairs);
d480 2
a481 2
   if (myGlobalComp ()->newPropRt ())
      forEachEl (theRtCand, theRtSite->myRtCands ())
d483 1
a483 3
         if (myPrMgr_->allowed (theRtCand, thePer))
            {
            thePen = penThruRtCand (theRtCand, thePer);
d485 2
a486 2
            if (theCandPens.isEmpty ())
               minPen = thePen;
d488 1
a488 14
            setToMin (minPen, thePen);
   
            theCandPens.push (theRtCand, thePen);
            }
         }
   else
      forEachEl (theRtCand, theRtSite->myRtCands ())
         {
         if (myPoMgr_->potActive (theRtCand, thePer))
            {
            thePen = penThruRtCand (theRtCand, thePer);

            if (theCandPens.isEmpty ())
               minPen = thePen;
d490 1
a490 4
            setToMin (minPen, thePen);
   
            theCandPens.push (theRtCand, thePen);
            }
d499 2
a500 10
      if (myGlobalComp ()->newPropRt ())
         {
         if (isMinimal == myPrMgr_->active (theRtCand, thePer))
            continue;
         }
      else
         {
         if (isMinimal == myPoMgr_->active (theRtCand, thePer))
            continue;
         }
@


1.78
log
@Low-Pri Prop-Rt.
@
text
@d143 1
a143 1
            myPrMgr_->setLpprAct (theRtCand, thePer, actStat);
d145 1
a145 1
            myPoMgr_->setActive  (theRtCand, thePer, actStat);
d383 1
a383 1
         return myPrMgr_->active    (theRtCand, thePer);
d501 1
a501 1
         if (myPrMgr_->active (theRtCand, thePer))
d537 1
a537 1
         if (isMinimal == myPrMgr_->lpprAct (theRtCand, thePer))
d854 1
a854 1
            "Provisionally Deactivated");
@


1.77
log
@Low-Pri Prop-Rt.
@
text
@d143 1
a143 1
            myPrMgr_->setActive (theRtCand, thePer, actStat);
d145 1
a145 1
            myPoMgr_->setActive (theRtCand, thePer, actStat);
d383 1
a383 1
         return myPrMgr_->potActive (theRtCand, thePer);
d501 1
a501 1
         if (myPrMgr_->potActive (theRtCand, thePer))
d537 1
a537 1
         if (isMinimal == myPrMgr_->active (theRtCand, thePer))
@


1.76
log
@Low-Pri Prop-Rt.
@
text
@d152 1
a152 3
void WitRtAnalyzer::findRoutingMods (
      WitRtCandPerStack & theMrMods,
      WitRtCandPerStack & theLpprMods)
a156 3

   if (mySelector_->lpprMode ())
      theLpprMods.takeContents (curLpprMods_);
@


1.75
log
@Low-Pri Prop-Rt.
@
text
@d20 1
d42 1
d62 6
a67 1
      myPoMgr_ = mySelector_->myPoMgr ();
d142 4
a145 1
         myPoMgr_->setActive (theRtCand, thePer, actStat);
d384 1
a384 1
      return myMrMgr_->activeForPE (theRtCand, thePer);
d386 6
a391 1
      return myPoMgr_->potActive   (theRtCand, thePer);
d479 4
a482 1
   myPoMgr_->definePropExp (theRtSite, thePer, 1.0, theExpPairs);
d503 2
a504 3
   forEachEl (theRtCand, theRtSite->myRtCands ())
      {
      if (myPoMgr_->potActive (theRtCand, thePer))
d506 3
a508 1
         thePen = penThruRtCand (theRtCand, thePer);
d510 2
a511 2
         if (theCandPens.isEmpty ())
            minPen = thePen;
d513 11
a523 1
         setToMin (minPen, thePen);
d525 7
a531 1
         theCandPens.push (theRtCand, thePen);
a532 1
      }
d540 10
a549 2
      if (isMinimal == myPoMgr_->active (theRtCand, thePer))
         continue;
@


1.74
log
@Low-Pri Prop-Rt.
@
text
@d19 1
a19 1
#include <PrMgr.h>
d40 1
a40 1
      myPrMgr_        (NULL),
d60 1
a60 1
      myPrMgr_ = mySelector_->myPrMgr ();
d135 1
a135 1
         myPrMgr_->setActive (theRtCand, thePer, actStat);
d376 1
a376 1
      return myPrMgr_->potActive   (theRtCand, thePer);
d464 1
a464 1
   myPrMgr_->definePropExp (theRtSite, thePer, 1.0, theExpPairs);
d487 1
a487 1
      if (myPrMgr_->potActive (theRtCand, thePer))
d506 1
a506 1
      if (isMinimal == myPrMgr_->active (theRtCand, thePer))
@


1.73
log
@Low-Pri Prop-Rt.
@
text
@d815 3
a817 1
         modLpprActStat_ (theRtCand)[thePer]? "Activated": "Deactivated");
@


1.72
log
@Low-Pri Prop-Rt.
@
text
@d41 2
a42 2
      modRtCandPers_  (myProblem ()),
      lpprRtCandPers_ (myProblem ()),
d123 1
a123 1
   while (modRtCandPers_.pop (theRtCand, thePer))
d131 1
a131 1
      while (lpprRtCandPers_.pop (theRtCand, thePer))
d142 3
a144 1
void WitRtAnalyzer::findRoutingMods (WitRtCandPerStack & theRtCandPers)
d148 4
a151 1
   theRtCandPers.takeContents (modRtCandPers_);
d249 1
a249 1
   if (modRtCandPers_.isNonEmpty ())
d253 1
a253 1
      if (lpprRtCandPers_.isNonEmpty ())
d446 1
a446 1
      modRtCandPers_.push (minRtCand, thePer);
d509 1
a509 1
      lpprRtCandPers_.push (theRtCand, thePer);
d760 1
a760 1
   if (modRtCandPers_.isEmpty ())
d769 1
a769 1
   theRtCandItr.attachTo (modRtCandPers_);
d799 1
a799 1
   if (lpprRtCandPers_.isEmpty ())
d808 1
a808 1
   theRtCandItr.attachTo (lpprRtCandPers_);
@


1.71
log
@Low-Pri Prop-Rt.
@
text
@d371 1
a371 1
      return myPrMgr_->fundActive  (theRtCand, thePer);
d482 1
a482 1
      if (myPrMgr_->fundActive (theRtCand, thePer))
@


1.70
log
@Low-Pri Prop-Rt.
@
text
@d53 1
a53 2
      weightedTotPen_ (0.0),
      fundActForLPPR_ ()
a75 12

      fundActForLPPR_.allocate1D (myProblem ());

      forEachEl (theRtCand, mySelector_->myRtMgr ()->myRtCands ())
         if (theRtCand->myRtSite ()->propRouting ())
            {
            fundActForLPPR_ (theRtCand).allocate (myProblem (), true);

            forEachPeriod (thePer, myProblem ())
               fundActForLPPR_ (theRtCand)[thePer] =
                  myPrMgr_->active (theRtCand, thePer);
            }
a160 25
void WitRtAnalyzer::fundDeactivateForLPPR (
      WitRtCand * theRtCand,
      WitPeriod   thePer)
   {
   witAssert (mySelector_->lpprMode ());

   witAssert (fundActForLPPR_ (theRtCand)[thePer]);

   fundActForLPPR_ (theRtCand)[thePer] = false;

   if (printMode_)
      printLpprFundDeact (theRtCand, thePer);
   }

//------------------------------------------------------------------------------

bool WitRtAnalyzer::fundActForLPPR (WitRtCand * theRtCand, WitPeriod thePer)
   {
   witAssert (mySelector_->lpprMode ());

   return fundActForLPPR_ (theRtCand)[thePer];
   }

//------------------------------------------------------------------------------

a369 4

   else if (not myGlobalComp ()->lowPriPropRt ())
      return myPrMgr_->active (theRtCand, thePer);

d371 1
a371 1
      return fundActForLPPR_ (theRtCand)[thePer];
d482 1
a482 1
      if (fundActForLPPR_ (theRtCand)[thePer])
a816 18

//------------------------------------------------------------------------------

void WitRtAnalyzer::printLpprFundDeact (
      WitRtCand * theRtCand,
      WitPeriod   thePer)
   {
   witAssert (printMode_);

   if (myGlobalComp ()->selPrintLevel () < 3)
      return;

   fprintf (msgFile (), "\n" "LPPR Fundamental Deactivation:\n");

   theRtCand->myRtSite ()->printID          (4, 22);
   theRtCand->myRtSite ()->printPer (thePer, 4, 22);
   theRtCand->             printID          (7, 22);
   }
@


1.69
log
@Low-Pri Prop-Rt.
@
text
@d183 12
d787 2
a794 2
   witAssert (printMode_);

d826 2
a833 2
   witAssert (printMode_);

d859 18
@


1.68
log
@Low-Pri Prop-Rt.
@
text
@d42 2
d54 1
a54 1
      allowedForLPPR_ ()
d70 1
a70 1
   if (myGlobalComp ()->lowPriPropRt ())
d72 1
a72 1
      allowedForLPPR_.allocate1D (myProblem ());
d76 13
a88 1
            allowedForLPPR_ (theRtCand).allocate (myProblem (), true);
d93 8
d129 1
d138 13
d174 3
a176 1
bool WitRtAnalyzer::allowedForLPPR (WitRtCand * theRtCand, WitPeriod thePer)
d178 3
a180 1
   witAssert (myGlobalComp ()->lowPriPropRt ());
d182 1
a182 1
   return allowedForLPPR_ (theRtCand)[thePer];
d273 4
d311 1
a311 1
         if (not active (theBopEnt->myRtCand (), expPer))
d362 1
a362 1
   if (active (theConsEnt->myRtCand (), execPer))
d392 1
a392 1
bool WitRtAnalyzer::active (WitRtCand * theRtCand, WitPeriod thePer)
d394 8
a401 4
   return
      theRtCand->myRtSite ()->propRouting ()?
         myPrMgr_->active      (theRtCand, thePer):
         myMrMgr_->activeForPE (theRtCand, thePer);
d506 1
d512 1
a512 3
      allowedForLPPR_ (theRtCand)[thePer] = false;

      if (myPrMgr_->active (theRtCand, thePer))
d528 7
a534 1
      allowedForLPPR_ (theRtCand)[thePer] = (thePen <= minPen + FLOAT_EPSILON);
d536 2
a537 2
   if (printMode_) 
      printAllForLPPR (theRtSite, thePer);
d808 1
a808 1
void WitRtAnalyzer::printAllForLPPR (WitRtSite * theRtSite, WitPeriod thePer)
d810 19
a828 1
   WitRtCand * theRtCand;
d830 2
a831 3
   fprintf (msgFile (),
      "\n"
      "Routing Candidates Allowed for Low Priority Prop Routing:\n\n");
d833 1
a833 2
   theRtSite->printID          (4, 25);
   theRtSite->printPer (thePer, 4, 25);
d835 6
a840 3
   forEachEl (theRtCand, theRtSite->myRtCands ())
      if (allowedForLPPR (theRtCand, thePer))
         theRtCand->printID (7, 25);
d842 4
a845 1
   fprintf (msgFile (), "\n");
@


1.67
log
@Low-Pri Prop-Rt.
@
text
@d761 1
a761 1
      "   Routing Candidates Allowed for Low Priority Prop Routing:\n");
d763 2
a764 2
   theRtSite->printID          (7, 25);
   theRtSite->printPer (thePer, 7, 25);
d768 1
a768 1
         theRtCand->printID (10, 25);
@


1.66
log
@Low-Pri Prop-Rt.
@
text
@d451 40
a549 40
double WitRtAnalyzer::penThruRtSiteLPPR (
      WitRtSite * theRtSite,
      WitPeriod   thePer)
   {
   WitRtCand * theRtCand;
   double      thePen;
   double      minPen;

   WitPairStack <WitRtCand, double> theCandPens (myProblem ());

   forEachEl (theRtCand, theRtSite->myRtCands ())
      {
      allowedForLPPR_ (theRtCand)[thePer] = false;

      if (myPrMgr_->active (theRtCand, thePer))
         {
         thePen = penThruRtCand (theRtCand, thePer);

         if (theCandPens.isEmpty ())
            minPen = thePen;

         setToMin (minPen, thePen);

         theCandPens.push (theRtCand, thePen);
         }
      }

   witAssert (theCandPens.isNonEmpty ());

   while (theCandPens.pop (theRtCand, thePen))
      allowedForLPPR_ (theRtCand)[thePer] = (thePen <= minPen + FLOAT_EPSILON);

   if (printMode_) 
      printAllForLPPR (theRtSite, thePer);

   return minPen;
   }

//------------------------------------------------------------------------------

@


1.65
log
@Low-Pri Prop-Rt.
@
text
@d267 1
a267 1
         if (not active (theBopEnt, expPer))
d318 1
a318 1
   if (active (theConsEnt, execPer))
d348 1
a348 1
bool WitRtAnalyzer::active (WitBillEntry * theBillEnt, WitPeriod thePer)
d350 4
a353 8
   WitRtCand * theRtCand;

   theRtCand = theBillEnt->myRtCand ();

   if (theRtCand->myRtSite ()->propRouting ())
      return myPrMgr_->active      (theRtCand, thePer);
   else
      return myMrMgr_->activeForPE (theBillEnt, thePer);
d360 2
a361 1
   WitPeriod expPer;
d366 2
d369 1
a369 1
      return analyzeMR   (fillPart, expPer);
d372 1
a372 1
      return analyzeHPPR (fillPart, expPer);
d375 1
a375 1
      return analyzeLPPR (fillPart->myRtSite (), expPer);
d398 1
a398 1
double WitRtAnalyzer::analyzeMR (WitPart * thePart, WitPeriod expPer)
d400 4
a403 4
   WitRtCand *   minRtCand;
   double        minPen;
   WitBopEntry * theBopEnt;
   double        thePen;
d408 2
a409 2
   forEachEl (theBopEnt, thePart->producingBopEntries ())
      if (myMrMgr_->activeForPE (theBopEnt, expPer))
d411 1
a411 1
         thePen = penThruBopEnt (theBopEnt, expPer);
d413 5
a417 1
         updateMinRtCand (minRtCand, minPen, theBopEnt, thePen);
d420 4
a423 1
   addToMods (minRtCand, expPer);
d430 3
a432 1
double WitRtAnalyzer::analyzeHPPR (WitPart * thePart, WitPeriod expPer)
d441 1
a441 1
   myPrMgr_->definePropExp (thePart->myRtSite (), expPer, 1.0, theExpPairs);
d444 1
d446 4
a449 1
      totPen += normShare * penThruBopEnt (theRtCand->myBopEnt (), expPer);
d451 6
a456 1
   return totPen;
d484 1
a484 1
      return penThruConsEnt    (theBomEnt, execPer);
d487 1
a487 1
      return penThruBomEntMR   (theBomEnt, execPer);
d490 1
a490 1
      return penThruBomEntHPPR (theBomEnt, execPer);
d493 1
a493 1
      return analyzeLPPR       (theBomEnt->myRtSite (), execPer);
a501 4
   WitRtCand *   minRtCand;
   double        minPen;
   WitSubEntry * theSub;

d504 2
a505 30

   minRtCand = NULL;
   minPen    = 0.0;

   analyze (theBomEnt, execPer, minRtCand, minPen);

   forEachEl (theSub, theBomEnt->mySubEntries ())
      analyze (theSub, execPer, minRtCand, minPen);

   addToMods (minRtCand, execPer);

   return minPen;
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::analyze (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      WitRtCand * &  minRtCand,
      double &       minPen)
   {
   double thePen;

   if (not myMrMgr_->activeForPE (theConsEnt, execPer))
      return;

   thePen = penThruConsEnt (theConsEnt, execPer);

   updateMinRtCand (minRtCand, minPen, theConsEnt, thePen);
d510 3
a512 23
double WitRtAnalyzer::penThruBomEntHPPR (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   double            totPen;
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            normShare;

   totPen = 0.0;

   myPrMgr_->definePropExp (theBomEnt->myRtSite (), execPer, 1.0, theExpPairs);

   while (theExpPairs.pop (theRtCand, normShare))

      totPen += normShare * penThruConsEnt (theRtCand->myConsEnt (), execPer);

   return totPen;
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::analyzeLPPR (WitRtSite * theRtSite, WitPeriod thePer)
d526 1
a526 4
         thePen =
            (theRtSite->myRtCase () == prodRtCase)?
               penThruBopEnt  (theRtCand->myBopEnt  (), thePer):
               penThruConsEnt (theRtCand->myConsEnt (), thePer);
a607 26
void WitRtAnalyzer::updateMinRtCand (
      WitRtCand * &  minRtCand,
      double &       minPen,
      WitBillEntry * theBillEnt,
      double         thePen)
   {
   if (   (minRtCand == NULL)
       or (thePen    <  minPen))
      {
      minRtCand = theBillEnt->myRtCand ();
      minPen    = thePen;
      }
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::addToMods (WitRtCand * theRtCand, WitPeriod thePer)
   {
   witAssert (theRtCand != NULL);

   if (theRtCand != myMrMgr_->selRtCand (theRtCand->myRtSite (), thePer))
      modRtCandPers_.push (theRtCand, thePer);
   }

//------------------------------------------------------------------------------

@


1.64
log
@Low-Pri Prop-Rt.
@
text
@a22 1
#include <RtSitePtr.h>
d376 1
a376 1
      return analyzeLPPR (fillPart, expPer);
d433 1
a433 1
   myPrMgr_->definePropExp (thePart, expPer, 1.0, theExpPairs);
d476 1
a476 1
      return analyzeLPPR       (theBomEnt, execPer);
d536 1
a536 1
   myPrMgr_->definePropExp (theBomEnt, execPer, 1.0, theExpPairs);
d547 1
a547 1
double WitRtAnalyzer::analyzeLPPR (WitRtSitePtr theRtSite, WitPeriod thePer)
@


1.63
log
@Low-Pri Prop-Rt.
@
text
@a444 42
double WitRtAnalyzer::analyzeLPPR (WitPart * thePart, WitPeriod expPer)
   {
   double        minPen;
   WitBopEntry * theBopEnt;
   WitRtCand *   theRtCand;
   double        thePen;

   WitPairStack <WitRtCand, double> theCandPens (myProblem ());

   minPen = -1.0;

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      {
      theRtCand = theBopEnt->myRtCand ();

      allowedForLPPR_ (theRtCand)[expPer] = false;

      if (myPrMgr_->active (theRtCand, expPer))
         {
         thePen = penThruBopEnt (theBopEnt, expPer);

         theCandPens.push (theRtCand, thePen);

         if ((minPen < -0.5) or (thePen < minPen))
            minPen = thePen;
         }
      }

   witAssert (minPen > -0.5);

   while (theCandPens.pop (theRtCand, thePen))
      if (thePen <= minPen + FLOAT_EPSILON)
         allowedForLPPR_ (theRtCand)[expPer] = true;

   if (printMode_) 
      printAllForLPPR (thePart, expPer);

   return minPen;
   }

//------------------------------------------------------------------------------

d477 1
a477 1
      return penThruBomEntLPPR (theBomEnt, execPer);
d548 1
a548 3
double WitRtAnalyzer::penThruBomEntLPPR (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
d550 3
a552 4
   double        minPen;
   WitSubEntry * theSub;
   WitRtCand *   theRtCand;
   double        thePen;
d556 1
a556 7
   minPen    = -1.0;

   theRtCand = theBomEnt->myRtCand ();

   allowedForLPPR_ (theRtCand)[execPer] = false;

   if (myPrMgr_->active (theRtCand, execPer))
d558 1
a558 1
      thePen = penThruConsEnt (theBomEnt, execPer);
d560 6
a565 1
      theCandPens.push (theRtCand, thePen);
d567 2
a568 3
      if ((minPen < -0.5) or (thePen < minPen))
         minPen = thePen;
      }
d570 1
a570 9
   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      theRtCand = theSub->myRtCand ();

      allowedForLPPR_ (theRtCand)[execPer] = false;

      if (myPrMgr_->active (theRtCand, execPer))
         {
         thePen = penThruConsEnt (theSub, execPer);
a572 3

         if ((minPen < -0.5) or (thePen < minPen))
            minPen = thePen;
d576 1
a576 1
   witAssert (minPen > -0.5);
d579 1
a579 2
      if (thePen <= minPen + FLOAT_EPSILON)
         allowedForLPPR_ (theRtCand)[execPer] = true;
d582 1
a582 1
      printAllForLPPR (theBomEnt, execPer);
d820 1
a820 1
void WitRtAnalyzer::printAllForLPPR (WitRtSitePtr theRtSite, WitPeriod thePer)
@


1.62
log
@Low-Pri Prop-Rt.
@
text
@d879 1
a879 3
void WitRtAnalyzer::printAllForLPPR (
      WitRtSitePtr theRtSitePtr,
      WitPeriod    thePer)
d887 2
a888 2
   theRtSitePtr ()->printID          (7, 25);
   theRtSitePtr ()->printPer (thePer, 7, 25);
d890 1
a890 1
   forEachEl (theRtCand, theRtSitePtr ()->myRtCands ())
@


1.61
log
@Low-Pri Prop-Rt.
@
text
@d871 3
a873 3
      theRtCand->myRtSite ()->printID          (22);
      theRtCand->myRtSite ()->printPer (thePer, 22);
      theRtCand->             printID          (22);
d889 2
a890 2
   theRtSitePtr ()->printID          (14);
   theRtSitePtr ()->printPer (thePer, 14);
d894 1
a894 1
         theRtCand->printID (14);
@


1.60
log
@Low-pri prop-rt.
@
text
@d480 1
a480 1
      printAllowedForPr (thePart, expPer);
d641 1
a641 1
      printAllowedForPr (theBomEnt, execPer);
d879 3
a881 1
void WitRtAnalyzer::printAllowedForPr (WitPart * thePart, WitPeriod expPer)
d883 1
a883 2
   WitBopEntry * theBopEnt;
   WitRtCand *   theRtCand;
d887 1
a887 18
      "   Part %s, Exp Per %d:\n"
      "      BopEntries Allowed for Low Priority Prop Routing:\n",
      thePart->partName ().myCstring (),
      expPer);

   forEachEl (theBopEnt, thePart->producingBopEntries ())
      {
      theRtCand = theBopEnt->myRtCand ();

      if (allowedForLPPR (theRtCand, expPer))
         fprintf (msgFile (),
            "         BopEntry: %s #%d\n",
            theBopEnt->myOperationName ().myCstring (),
            theBopEnt->localIndex ());
      }

   fprintf (msgFile (), "\n");
   }
d889 2
a890 1
//------------------------------------------------------------------------------
d892 3
a894 29
void WitRtAnalyzer::printAllowedForPr (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   WitRtCand *   theRtCand;
   WitSubEntry * theSub;

   fprintf (msgFile (),
      "\n"
      "   BomEntry %s, #%d Exec Per %d:\n"
      "      ConsEntries Allowed for Low Priority Prop Routing:\n",
      theBomEnt->myOperationName ().myCstring (),
      theBomEnt->localIndex (),
      execPer);

   theRtCand = theBomEnt->myRtCand ();

   if (allowedForLPPR (theRtCand, execPer))
      fprintf (msgFile (), "         Self\n");

   forEachEl (theSub, theBomEnt->mySubEntries ())
      {
      theRtCand = theSub->myRtCand ();

      if (allowedForLPPR (theRtCand, execPer))
         fprintf (msgFile (),
            "         SubEntry #%d\n",
            theSub->localIndex ());
      }
@


1.59
log
@Low-pri prop-rt.
@
text
@d53 1
a53 1
      allowedForPr_   ()
d71 1
a71 1
      allowedForPr_.allocate1D (myProblem ());
d75 1
a75 1
            allowedForPr_ (theRtCand).allocate (myProblem (), true);
d139 1
a139 1
bool WitRtAnalyzer::allowedForPr (WitRtCand * theRtCand, WitPeriod thePer)
d143 1
a143 1
   return allowedForPr_ (theRtCand)[thePer];
d460 1
a460 1
      allowedForPr_ (theRtCand)[expPer] = false;
d473 2
d477 1
a477 1
         allowedForPr_ (theRtCand)[expPer] = true;
d510 4
a513 1
      return penThruConsEnt  (theBomEnt, execPer);
d515 2
a516 2
   else if (theBomEnt->propRouting ())
      return penThruBomEntPR (theBomEnt, execPer);
d519 1
a519 23
      return penThruBomEntMR (theBomEnt, execPer);
   }

//------------------------------------------------------------------------------

double WitRtAnalyzer::penThruBomEntPR (
      WitBomEntry * theBomEnt,
      WitPeriod     execPer)
   {
   double            totPen;
   WitRtCandDblStack theExpPairs (myProblem ());
   WitRtCand *       theRtCand;
   double            normShare;

   totPen = 0.0;

   myPrMgr_->definePropExp (theBomEnt, execPer, 1.0, theExpPairs);

   while (theExpPairs.pop (theRtCand, normShare))

      totPen += normShare * penThruConsEnt (theRtCand->myConsEnt (), execPer);

   return totPen;
d568 80
d887 1
a887 1
      "      BopEntries Allowed for Prop Routing:\n",
d895 1
a895 2
      if (allowedForPr (theRtCand, expPer))
         {
d900 35
a934 1
         }
@


1.58
log
@Low-Priority Prop Routing.
@
text
@d53 1
a53 1
      excludedForPr_  ()
d71 1
a71 1
      excludedForPr_.allocate1D (myProblem ());
d75 1
a75 1
            excludedForPr_ (theRtCand).allocate (myProblem (), false);
d139 1
a139 1
bool WitRtAnalyzer::excludedForPr (WitRtCand * theRtCand, WitPeriod thePer)
d143 1
a143 1
   return excludedForPr_ (theRtCand)[thePer];
d460 1
a460 1
      excludedForPr_ (theRtCand)[expPer] = true;
d475 4
a478 1
         excludedForPr_ (theRtCand)[expPer] = false;
d813 30
@


1.57
log
@Continued implmentation of low priority proportionate routing.
@
text
@d370 2
a371 2
   if (fillPart->propRouting ())
      return analyzePR (fillPart, expPer);
d373 5
a377 1
   return analyzeMR (fillPart, expPer);
d400 26
a425 1
double WitRtAnalyzer::analyzePR (WitPart * thePart, WitPeriod expPer)
d445 1
a445 1
double WitRtAnalyzer::analyzeMR (WitPart * thePart, WitPeriod expPer)
a446 1
   WitRtCand *   minRtCand;
d449 1
d452 3
a454 2
   minRtCand = NULL;
   minPen    = 0.0;
d457 6
a462 1
      if (myMrMgr_->activeForPE (theBopEnt, expPer))
d466 4
a469 1
         updateMinRtCand (minRtCand, minPen, theBopEnt, thePen);
d471 1
d473 3
a475 1
   addToMods (minRtCand, expPer);
@


1.56
log
@Continued implementation of pen-exec override of prop-rt.
@
text
@d36 1
a36 1
      WitProbAssoc     (theSelector->myProblem ()),
d38 16
a53 16
      mySelector_      (theSelector),
      myMrMgr_         (theSelector->myMrMgr ()),
      myExpRest_       (theSelector->myExpRest ()),
      myPrMgr_         (NULL),
      modRtCandPers_   (myProblem ()),
      toPreAn_         (myProblem ()),
      dependents_      (myProblem ()),
      nPrereqsToAna_   (myProblem (), 0),
      toAnalyze_       (myProblem ()),
      minPen_          (myProblem (), 0.0),
      minPenValid_     (),
      printMode_       (myGlobalComp ()->selPrintLevel () >= 1),
      curPen_          (0.0),
      totCommitVol_    (0.0),
      weightedTotPen_  (0.0),
      prohibitedForPr_ ()
d69 1
a69 1
   if (myGlobalComp ()->penExecOverPropRt ())
d71 1
a71 1
      prohibitedForPr_.allocate1D (myProblem ());
d75 1
a75 1
            prohibitedForPr_ (theRtCand).allocate (myProblem (), false);
d139 1
a139 1
bool WitRtAnalyzer::prohibitedForPr (WitRtCand * theRtCand, WitPeriod thePer)
d141 1
a141 1
   witAssert (myGlobalComp ()->penExecOverPropRt ());
d143 1
a143 1
   return prohibitedForPr_ (theRtCand)[thePer];
@


1.55
log
@Continued implementation of post-implosion pegging.
@
text
@d20 1
d36 1
a36 1
      WitProbAssoc    (theSelector->myProblem ()),
d38 16
a53 15
      mySelector_     (theSelector),
      myMrMgr_        (theSelector->myMrMgr ()),
      myExpRest_      (theSelector->myExpRest ()),
      myPrMgr_        (NULL),
      modRtCandPers_  (myProblem ()),
      toPreAn_        (myProblem ()),
      dependents_     (myProblem ()),
      nPrereqsToAna_  (myProblem (), 0),
      toAnalyze_      (myProblem ()),
      minPen_         (myProblem (), 0.0),
      minPenValid_    (),
      printMode_      (myGlobalComp ()->selPrintLevel () >= 1),
      curPen_         (0.0),
      totCommitVol_   (0.0),
      weightedTotPen_ (0.0)
d55 3
a57 2
   WitPart * thePart;
   WitPeriod thePer;
d69 9
d139 9
d367 1
a367 8
   if (needToAnalyze (fillPart, fillPer, expPer))
      {
      if (fillPart->propRouting ())
         return analyzePR (fillPart, expPer);
      else
         return analyzeMR (fillPart, expPer);
      }
   else
d369 5
@


1.54
log
@Corrected a file inclusion AIX porting bug.
@
text
@a25 1
#include <ScheduleI.h>
@


1.53
log
@Continued implementation of post-implosion pegging.
@
text
@d28 1
@


1.52
log
@Added some optional warnings on Linux.
@
text
@a27 1
#include <PtrSchedI.h>
@


1.51
log
@Attempt to fix syntax errors from GCC compiler.
@
text
@a485 1
   double        thePen;
@


1.50
log
@Continued implementation of proportionate routing.
@
text
@d22 1
a22 1
#include <RtSiteComp.h>
@


1.49
log
@Continued implementation of proportionate routing.
@
text
@d22 1
a24 1
#include <Part.h>
d338 1
a338 1
      return myMrMgr_->activeForPE (theRtCand, thePer);
d387 1
a387 1
   myPrMgr_->definePropExp (thePart->myRtSite (), expPer, 1.0, theExpPairs);
d409 1
a409 1
      if (myMrMgr_->activeForPE (theBopEnt->myRtCand (), expPer))
d413 1
a413 1
         updateMinRtCand (minRtCand, minPen, theBopEnt->myRtCand (), thePen);
d468 1
a468 1
   myPrMgr_->definePropExp (theBomEnt->myRtSite (), execPer, 1.0, theExpPairs);
d514 1
a514 1
   if (not myMrMgr_->activeForPE (theConsEnt->myRtCand (), execPer))
d519 1
a519 1
   updateMinRtCand (minRtCand, minPen, theConsEnt->myRtCand (), thePen);
d583 4
a586 4
      WitRtCand * & minRtCand,
      double &      minPen,
      WitRtCand *   theRtCand,
      double        thePen)
d591 1
a591 1
      minRtCand = theRtCand;
@


1.48
log
@Continued implementation of proportionate routing.
@
text
@d248 1
a248 1
         if (not active (theBopEnt->myRtCand (), expPer))
d299 1
a299 1
   if (active (theConsEnt->myRtCand (), execPer))
d329 1
a329 1
bool WitRtAnalyzer::active (WitRtCand * theRtCand, WitPeriod thePer)
d331 4
@


1.47
log
@Continued implementation of proportionate routing.
@
text
@d376 4
a379 4
   double        totPen;
   WitBopEntry * theBopEnt;
   double        thePen;
   double        normShare;
d383 1
a383 4
   forEachEl (theBopEnt, thePart->producingBopEntries ())
      if (myPrMgr_->active (theBopEnt, expPer))
         {
         thePen    = penThruBopEnt (theBopEnt, expPer);
d385 1
a385 1
         normShare = myPrMgr_->normExpShare (theBopEnt, expPer);
d387 1
a387 2
         totPen   += normShare * thePen;
         }
d457 4
a460 2
   double        totPen;
   WitSubEntry * theSub;
d464 3
a466 1
   updateTotPen (theBomEnt, execPer, totPen);
d468 1
a468 2
   forEachEl (theSub, theBomEnt->mySubEntries ())
      updateTotPen (theSub, execPer, totPen);
a470 20
   }

//------------------------------------------------------------------------------

void WitRtAnalyzer::updateTotPen (
      WitConsEntry * theConsEnt,
      WitPeriod      execPer,
      double &       totPen)
   {
   double thePen;
   double normShare;

   if (myPrMgr_->active (theConsEnt, execPer))
      {
      thePen    = penThruConsEnt (theConsEnt, execPer);

      normShare = myPrMgr_->normExpShare (theConsEnt, execPer);

      totPen   += normShare * thePen;
      }
@


1.46
log
@Continued implementation of proportionate routing.
@
text
@d331 4
a334 5
   if (mySelector_->propRouting ())
      if (myPrMgr_->propRouting (theRtCand->myRtSite (), thePer))
         return myPrMgr_->active (theRtCand, thePer);

   return myMrMgr_->activeForPE (theRtCand, thePer);
d345 4
a348 5
      if (mySelector_->propRouting ())
         if (myPrMgr_->propRouting (fillPart, expPer))
            return analyzePR (fillPart, expPer);

      return analyzeMR (fillPart, expPer);
d446 1
a446 1
      return penThruConsEnt (theBomEnt, execPer);
d448 2
a449 3
   if (mySelector_->propRouting ())
      if (myPrMgr_->propRouting (theBomEnt, execPer))
         return penThruBomEntPR (theBomEnt, execPer);
d451 2
a452 1
   return penThruBomEntMR (theBomEnt, execPer);
@


1.45
log
@Continued implementation of proportionate routing.
@
text
@a19 1
#include <PrSecMgr.h>
d282 1
a282 2
      if (active (theBomEnt->myRtCand (), execPer))
         recConsEntPrereq (fillPart, fillPer, theBomEnt, execPer);
d285 1
a285 2
         if (active (theSub->myRtCand (), execPer))
            recConsEntPrereq (fillPart, fillPer, theSub, execPer);
d299 7
a305 6
   if (theConsEnt->effConsRate ()[execPer] > 0.0)
      recordPrereq (
         fillPart, 
         fillPer, 
         theConsEnt->myPart (),
         theConsEnt->impactPeriod ()[execPer]);
d347 1
a347 1
         if (myPrMgr_->myPprMgr ()->propRouting (fillPart, expPer))
d386 1
a386 1
      if (myPrMgr_->myPprMgr ()->active (theBopEnt, expPer))
d390 1
a390 1
         normShare = myPrMgr_->myPprMgr ()->normExpShare (theBopEnt, expPer);
d451 1
a451 1
      if (myPrMgr_->myCprMgr ()->propRouting (theBomEnt, execPer))
d486 1
a486 1
   if (myPrMgr_->myCprMgr ()->active (theConsEnt, execPer))
d490 1
a490 1
      normShare = myPrMgr_->myCprMgr ()->normExpShare (theConsEnt, execPer);
@


1.44
log
@Continued implementation of proportionate routing.
@
text
@d96 3
d104 2
a105 3
   myMrMgr_->modifyRouting (modRtCandPers_);

   modRtCandPers_.clear ();
a266 11
bool WitRtAnalyzer::active (WitRtCand * theRtCand, WitPeriod thePer)
   {
   if (mySelector_->propRouting ())
      if (myPrMgr_->propRouting (theRtCand->myRtSite (), thePer))
         return myPrMgr_->active (theRtCand, thePer);

   return myMrMgr_->activeForPE (theRtCand, thePer);
   }

//------------------------------------------------------------------------------

d331 11
d355 1
a355 1
      return false;
d429 1
a430 1
   WitOperation * theOpn;
d434 1
a435 1
   theOpn     = theBopEnt  ->myOperation ();
d440 1
a440 4
         penThruOpn += 
            theBomEnt->hasSubsInEffect ()[execPer]?
               penThruBomEntOrSubs (theBomEnt, execPer):
               penThruConsEnt      (theBomEnt, execPer);
d447 54
a500 1
double WitRtAnalyzer::penThruBomEntOrSubs (
d535 1
a535 1
   if (not active (theConsEnt->myRtCand (), execPer))
d568 3
@


1.43
log
@Continued implementation of proportionate routing.
@
text
@d236 4
a239 7
   WitPeriod      expPer;
   WitRtCand *    theRtCand;
   WitBopEntry *  theBopEnt;
   WitPeriod      execPer;
   WitBomEntry *  theBomEnt;
   WitRtCandStack theRtCands (myProblem ());

d244 5
a248 1
   defExpData (fillPart, fillPer, expPer, theRtCands);
d250 1
a250 3
   while (theRtCands.pop (theRtCand))
      {
      theBopEnt = theRtCand->myBillEnt ()->myBopEnt ();
d252 3
a254 5
      execPer   = mySelector_->modelessExecPer (theBopEnt, expPer);

      forEachEl (theBomEnt, theBopEnt->myOperation ()->bom ())
         recBomEntPrereq (fillPart, fillPer, theBomEnt, execPer);
      }
d265 11
d282 1
a282 4
   WitRtCandStack theRtCands (myProblem ());
   WitRtCand *    theRtCand;
   WitConsEntry * theConsEnt;

d292 2
a293 5
      myMrMgr_->findExpRtCands (theBomEnt->myRtSite (), execPer, theRtCands);

      while (theRtCands.pop (theRtCand))
         {
         theConsEnt = theRtCand->myBillEnt ()->myConsEnt ();
d295 3
a297 2
         recConsEntPrereq (fillPart, fillPer, theConsEnt, execPer);
         }
d342 1
a342 13
   WitPeriod      expPer;
   WitRtCand *    minRtCand;
   double         minRtCandPen;
   WitRtCand *    theRtCand;
   WitBopEntry *  theBopEnt;
   double         thePen;

   WitRtCandStack theRtCands (myProblem ());

   defExpData (fillPart, fillPer, expPer, theRtCands);

   if (theRtCands.isEmpty ())
      return 0.0;
d344 1
a344 8
   if (mySelector_->propRouting ())
      if (myPrMgr_->myPprMgr ()->propRouting (fillPart, expPer))
         return analyzePR (fillPart, expPer, theRtCands);

   minRtCand    = NULL;
   minRtCandPen = 0.0;

   while (theRtCands.pop (theRtCand))
d346 3
a348 1
      theBopEnt = theRtCand->myBillEnt ()->myBopEnt ();
d350 1
a350 3
      thePen    = penThruBopEnt (theBopEnt, expPer);

      updateMinRtCand (minRtCand, minRtCandPen, theRtCand, thePen);
d352 2
a353 4

   addToMods (minRtCand, expPer);

   return minRtCandPen;
d358 4
a361 5
void WitRtAnalyzer::defExpData (
      WitPart *        fillPart, 
      WitPeriod        fillPer, 
      WitPeriod &      expPer, 
      WitRtCandStack & theRtCands)
a362 4
   WitRtSite * theRtSite;

   theRtCands.clear ();

d364 1
a364 1
      return;
d367 1
a367 1
      return;
d371 11
a381 2
   if (not fillPart->explodeable (expPer))
      return;
d383 1
a383 1
   theRtSite = fillPart->myRtSite ();
d385 2
a386 2
   if (mySelector_->propRouting ())
      if (myPrMgr_->myPprMgr ()->propRouting (fillPart, expPer))
d388 3
a390 1
         myPrMgr_->findExpRtCands (theRtSite, expPer, theRtCands);
d392 1
a392 1
         return;
d395 1
a395 1
   myMrMgr_->findExpRtCands (theRtSite, expPer, theRtCands);
d400 1
a400 4
double WitRtAnalyzer::analyzePR (
      WitPart *        thePart, 
      WitPeriod        expPer, 
      WitRtCandStack & theRtCands)
d402 2
a403 2
   double        totPen;
   WitRtCand *   theRtCand;
a405 1
   double        normShare;
d407 2
a408 1
   totPen = 0.0;
d410 4
a413 3
   while (theRtCands.pop (theRtCand))
      {
      theBopEnt = theRtCand->myBillEnt ()->myBopEnt ();
d415 2
a416 1
      thePen    = penThruBopEnt (theBopEnt, expPer);
d418 1
a418 1
      normShare = myPrMgr_->myPprMgr ()->normExpShare (theBopEnt, expPer);
d420 1
a420 4
      totPen   += normShare * thePen;
      }

   return totPen;
d452 4
a455 7
   WitRtCand *    minRtCand;
   WitRtCand *    theRtCand;
   WitConsEntry * theConsEnt;
   double         thePen;
   double         minRtCandPen;
   WitRtCandStack theRtCands (myProblem ());

d460 4
a463 2
   minRtCand    = NULL;
   minRtCandPen = 0.0;
d465 4
a468 1
   myMrMgr_->findExpRtCands (theBomEnt->myRtSite (), execPer, theRtCands);
d470 2
a471 3
   while (theRtCands.pop (theRtCand))
      {
      theConsEnt = theRtCand->myBillEnt ()->myConsEnt ();
d473 1
a473 1
      thePen     = penThruConsEnt (theConsEnt, execPer);
d475 10
a484 2
      updateMinRtCand (minRtCand, minRtCandPen, theRtCand, thePen);
      }
d486 1
a486 1
   addToMods (minRtCand, execPer);
d488 1
a488 1
   return minRtCandPen;
d550 1
a550 1
      double &      minRtCandPen,
d555 1
a555 1
       or (thePen    <  minRtCandPen))
d557 2
a558 2
      minRtCand    = theRtCand;
      minRtCandPen = thePen;
@


1.42
log
@Continued implementation of propotionate routing.
@
text
@d350 3
d355 1
a355 4
         return 0.0;

   if (theRtCands.isEmpty ())
      return 0.0;
d399 36
a434 2
   if (    mySelector_->propRouting ()
       and myPrMgr_->myPprMgr ()->propRouting (fillPart, expPer))
d436 1
a436 3
      myPrMgr_->findExpRtCands (theRtSite, expPer, theRtCands);
   else
      myMrMgr_->findExpRtCands (theRtSite, expPer, theRtCands);
@


1.41
log
@Continued implementation of proportionate routing.
@
text
@d20 1
a20 1
#include <PrSelMgr.h>
d351 1
a351 1
      if (myPrMgr_->myPprSelMgr ()->propRouting (fillPart, expPer))
d400 1
a400 1
       and myPrMgr_->myPprSelMgr ()->propRouting (fillPart, expPer))
@


1.40
log
@Continued implementation of proportionate routing.
@
text
@d19 2
a20 1
#include <MrSelMgr.h>
d42 1
d58 3
d237 1
d241 1
a241 1
   WitConsEntry * theConsEnt;
a242 2
   WitBopEntStack  expBopEnts  (myProblem ());
   WitConsEntStack expConsEnts (myProblem ());
d247 1
a247 1
   defExpData (fillPart, fillPer, expPer, expBopEnts);
d249 1
a249 1
   while (expBopEnts.pop (theBopEnt))
d251 3
a253 1
      execPer = mySelector_->modelessExecPer (theBopEnt, expPer);
d256 1
a256 18
         if (theBomEnt->inEffect (execPer))
            {
            if (theBomEnt->hasSubsInEffect ()[execPer])
               {
               if (canPseudoNet (theBomEnt, execPer))
                  continue;

               myMrMgr_->myCmrSelMgr ()->findExpConsEnts (
                  theBomEnt,
                  execPer,
                  expConsEnts);
                
               while (expConsEnts.pop (theConsEnt))
                  recConsEntPrereq (fillPart, fillPer, theConsEnt, execPer);
               }
            else
               recConsEntPrereq (fillPart, fillPer, theBomEnt, execPer);
            }
d268 34
d341 2
a343 1
   double         minPen;
a344 1
   WitBopEntStack expBopEnts (myProblem ());
d346 1
a346 1
   defExpData (fillPart, fillPer, expPer, expBopEnts);
d348 7
a354 1
   if (expBopEnts.isEmpty ())
d357 2
a358 2
   minRtCand = NULL;
   minPen    = 0.0;
d360 1
a360 1
   while (expBopEnts.pop (theBopEnt))
d362 1
a362 1
      thePen = penThruBopEnt (theBopEnt, expPer);
d364 3
a366 1
      updateMinRtCand (minRtCand, minPen, theBopEnt->myRtCand (), thePen);
d371 1
a371 1
   return minPen;
d380 1
a380 1
      WitBopEntStack & expBopEnts)
d382 3
a384 1
   expBopEnts.clear ();
d397 8
a404 1
   myMrMgr_->myPmrSelMgr ()->findExpBopEnts (fillPart, expPer, expBopEnts);
d437 1
d440 2
a441 1
   double         minPen;
a442 1
   WitConsEntStack expConsEnts (myProblem ());
d447 2
a448 2
   minRtCand = NULL;
   minPen    = 0.0;
d450 1
a450 1
   myMrMgr_->myCmrSelMgr ()->findExpConsEnts (theBomEnt, execPer, expConsEnts);
d452 1
a452 1
   while (expConsEnts.pop (theConsEnt))
d454 1
a454 1
      thePen = penThruConsEnt (theConsEnt, execPer);
d456 3
a458 1
      updateMinRtCand (minRtCand, minPen, theConsEnt->myRtCand (), thePen);
d463 1
a463 1
   return minPen;
a471 1
   double    effConsRateVal;
d475 1
a475 3
   effConsRateVal = theConsEnt->effConsRate ()[execPer];

   if (effConsRateVal <= 0.0)
d525 1
a525 1
      double &      minPen,
d530 1
a530 1
       or (thePen    <  minPen))
d532 2
a533 2
      minRtCand = theRtCand;
      minPen    = thePen;
@


1.39
log
@Continued implementation of proportionate routing.
@
text
@d20 1
d41 1
d91 1
a91 9
   WitBopEntry *  theBopEnt;
   WitConsEntry * theConsEnt;
   WitPeriod      thePer;

   WitBopEntPerStack  modBopEntPers  (myProblem ());
   WitConsEntPerStack modConsEntPers (myProblem ());
   WitRtCandPerStack  modRtCandPers  (myProblem ());

   findRoutingMods (modBopEntPers, modConsEntPers);
d94 1
a94 4
      printMods (modBopEntPers, modConsEntPers);

   while (modBopEntPers.pop (theBopEnt, thePer))
      modRtCandPers.push (theBopEnt->myRtCand (), thePer);
d96 1
a96 2
   while (modConsEntPers.pop (theConsEnt, thePer))
      modRtCandPers.push (theConsEnt->myRtCand (), thePer);
d98 1
a98 3
   modRtCandPers.reverse ();

   myMrMgr_->modifyRouting (modRtCandPers);
d103 1
a103 3
void WitRtAnalyzer::findRoutingMods (
      WitBopEntPerStack  & modBopEntPers,
      WitConsEntPerStack & modConsEntPers)
d105 1
a105 33
   WitPart *       thePart;
   WitPeriod       fillPer;
   WitPartPerStack validPartPers (myProblem ());
      //
      // The set of pairs (thePart, thePer) for which
      // minPenValid_ (thePart)[thePer] is true.

   witAssert (inInitState ());

   witAssert (modBopEntPers .isEmpty ());
   witAssert (modConsEntPers.isEmpty ());

  if (printMode_) 
     printAnaHead ();

   toPreAn_.push (
      mySelector_->myHeurAtor ()->topPart (),
      mySelector_->myHeurAtor ()->topPer ());

   while (toPreAn_.pop (thePart, fillPer))
      preAnalyze (thePart, fillPer);

   while (toAnalyze_.pop (thePart, fillPer))
      {
      minPen_ (thePart)[fillPer] = 
         analyze (thePart, fillPer, modBopEntPers, modConsEntPers);

      if (DEBUG_MODE)
         {
         minPenValid_ (thePart)[fillPer] = true;

         validPartPers.push (thePart, fillPer);
         }
d107 1
a107 10
      postAnalyze (thePart, fillPer);
      }

   curPen_ = 
      minPen_ (mySelector_->myHeurAtor ()->topPart ())
              [mySelector_->myHeurAtor ()->topPer ()];

   if (DEBUG_MODE)
      while (validPartPers.pop (thePart, fillPer))
         minPenValid_ (thePart)[fillPer] = false;
d154 46
d205 3
a234 1
   WitRtCand *    theRtCand;
d237 2
a238 2
   WitBopEntStack expBopEnts (myProblem ());
   WitRtCandStack theRtCands (myProblem ());
d257 2
a258 2
               myMrMgr_->findRtCands (
                  theBomEnt->myRtSite (),
d260 1
a260 1
                  theRtCands);
d262 1
a262 4
               while (theRtCands.pop (theRtCand))
                  {
                  theConsEnt = theRtCand->myBillEnt ()->myConsEnt ();

a263 1
                  }
d314 1
a314 5
double WitRtAnalyzer::analyze (
      WitPart *            fillPart,
      WitPeriod            fillPer, 
      WitBopEntPerStack &  modBopEntPers,
      WitConsEntPerStack & modConsEntPers)
d317 1
a317 1
   WitBopEntry *  minBopEnt;
d319 2
a320 2
   double         minBopEntPen;
   double         theBopEntPen;
d328 2
a329 2
   minBopEnt    = NULL;
   minBopEntPen = 0.0;
d333 1
a333 1
      theBopEntPen = penThruBopEnt (theBopEnt, expPer, modConsEntPers);
d335 1
a335 6
      if (minBopEnt != NULL)
         if (theBopEntPen >= minBopEntPen)
            continue;

      minBopEnt    = theBopEnt;
      minBopEntPen = theBopEntPen;
d338 1
a338 2
   if (minBopEnt != myMrMgr_->myPmrSelMgr ()->selBopEnt (fillPart, expPer))
      modBopEntPers.push (minBopEnt, expPer);
d340 1
a340 1
   return minBopEntPen;
a350 3
   WitRtCandStack theRtCands (myProblem ());
   WitRtCand *    theRtCand;

d364 1
a364 6
   myMrMgr_->findRtCands (fillPart->myRtSite (), expPer, theRtCands);

   while (theRtCands.pop (theRtCand))
      expBopEnts.push (theRtCand->myBillEnt ()->myBopEnt ());

   expBopEnts.reverse ();
d369 1
a369 4
double WitRtAnalyzer::penThruBopEnt (
      WitBopEntry *        theBopEnt, 
      WitPeriod            expPer,
      WitConsEntPerStack & modConsEntPers)
d384 1
a384 1
               penThruBomEntOrSubs (theBomEnt, execPer, modConsEntPers):
d393 2
a394 3
      WitBomEntry *        theBomEnt, 
      WitPeriod            execPer,
      WitConsEntPerStack & modConsEntPers)
d396 1
a396 1
   WitConsEntry * minConsEnt;
d398 2
a399 3
   double         theConsEntPen;
   double         minConsEntPen;
   WitRtCand *    theRtCand;
d401 1
a401 1
   WitRtCandStack theRtCands (myProblem ());
d406 2
a407 2
   minConsEnt    = NULL;
   minConsEntPen = 0.0;
d409 1
a409 1
   myMrMgr_->findRtCands (theBomEnt->myRtSite (), execPer, theRtCands);
d411 1
a411 1
   while (theRtCands.pop (theRtCand))
d413 1
a413 1
      theConsEnt    = theRtCand->myBillEnt ()->myConsEnt ();
d415 1
a415 8
      theConsEntPen = penThruConsEnt (theConsEnt, execPer);

      if (minConsEnt != NULL)
         if (theConsEntPen >= minConsEntPen)
            continue;

      minConsEnt    = theConsEnt;
      minConsEntPen = theConsEntPen;
d418 1
a418 1
   witAssert (minConsEnt != NULL);
d420 1
a420 4
   if (minConsEnt != myMrMgr_->myCmrSelMgr ()->selConsEnt (theBomEnt, execPer))
      modConsEntPers.push (minConsEnt, execPer);

   return minConsEntPen;
d483 26
d617 1
a617 3
void WitRtAnalyzer::printMods (
      const WitBopEntPerStack  & modBopEntPers,
      const WitConsEntPerStack & modConsEntPers)
d619 4
a628 10
   WitBopEntry *  theBopEnt;
   WitPeriod      expPer;
   WitConsEntry * theConsEnt;
   WitPeriod      execPer;
   WitSubEntry *  theSub;
   WitBomEntry *  theBomEnt;

   WitPairStItr <WitBopEntry, WitPeriod>  theBopEntItr;
   WitPairStItr <WitConsEntry, WitPeriod> theConsEntItr;

d631 1
a631 1
   fprintf (msgFile (), "\n" "Routing Modifications:\n\n");
d633 5
a637 4
   if (modBopEntPers.isEmpty ())
      if (modConsEntPers.isEmpty ())
         {
         fprintf (msgFile (), "   None\n");
d639 2
a640 11
         return;
         }

   theBopEntItr.attachTo (modBopEntPers);

   while (theBopEntItr.advance (theBopEnt, expPer))
      fprintf (msgFile (),
         "   Operation %s, BOP entry #%d, Exp Per %d\n",
         theBopEnt->myOperationName ().myCstring (),
         theBopEnt->localIndex (),
         expPer);
d642 1
a642 1
   theConsEntItr.attachTo (modConsEntPers);
d644 1
a644 1
   while (theConsEntItr.advance (theConsEnt, execPer))
d646 1
a646 12
      theSub = theConsEnt->mySub ();

      if (theSub != NULL)
         fprintf (msgFile (),
            "   Operation %s, BOM entry #%d, Sub #%d, Exec Per %d\n",
            theSub->myOperationName ().myCstring (),
            theSub->myBomEntIndex (),
            theSub->localIndex (),
            execPer);
      else
         {
         theBomEnt = theConsEnt->myBomEnt ();
d648 3
a650 6
         fprintf (msgFile (),
            "   Operation %s, BOM entry #%d, Exec Per %d\n",
            theBomEnt->myOperationName ().myCstring (),
            theBomEnt->localIndex (),
            execPer);
         }
@


1.38
log
@Continued implementation of proportionate routing.
@
text
@d19 2
d38 1
a38 2
      myPmrMgr_       (theSelector->myPmrMgr ()),
      myCmrMgr_       (theSelector->myCmrMgr ()),
d89 4
d95 1
d102 9
a110 2
   myPmrMgr_->modifyRouting (modBopEntPers);
   myCmrMgr_->modifyRouting (modConsEntPers);
d241 1
d244 2
a245 2
   WitBopEntStack  expBopEnts  (myProblem ());
   WitConsEntStack expConsEnts (myProblem ());
d264 8
a271 1
               myCmrMgr_->findExpConsEnts (theBomEnt, execPer, expConsEnts);
a272 1
               while (expConsEnts.pop (theConsEnt))
d274 1
d358 1
a358 1
   if (minBopEnt != myPmrMgr_->selBopEntry (fillPart, expPer))
d372 3
d377 15
a391 4
   if (not fillPart->producingBopEntries ().isEmpty ())
      if (not myExpRest_->hasPseudoSup (fillPart, fillPer))
         {
         expPer = mySelector_->modelessExpPer (fillPart, fillPer);
d393 1
a393 3
         if (fillPart->explodeable (expPer))
            myPmrMgr_->findExpBopEnts (fillPart, expPer, expBopEnts);
         }
d433 1
d435 1
a435 1
   WitConsEntStack expConsEnts (myProblem ());
a439 2
   myCmrMgr_->findExpConsEnts (theBomEnt, execPer, expConsEnts);

d443 3
a445 1
   while (expConsEnts.pop (theConsEnt))
d447 2
d461 1
a461 1
   if (minConsEnt != myCmrMgr_->selConsEntry (theBomEnt, execPer))
d680 1
a680 1
      theConsEnt->getSubEntry (theSub);
@


1.37
log
@Internal changes.
@
text
@d33 1
a33 1
      WitProbAssoc    (theSelector),
@


1.36
log
@Internal changes.
@
text
@d174 1
a174 1
      if (! hasPenalty)
d183 1
a183 1
      if (! hasPenalty)
d353 2
a354 2
   if (! fillPart->producingBopEntries ().isEmpty ())
      if (! myExpRest_->hasPseudoSup (fillPart, fillPer))
@


1.35
log
@Continued implementation of execPenalties on BOM entries and subs.
@
text
@d61 1
a61 1
      minPenValid_.allocate (myProblem (), witFALSE);
d111 1
a111 1
      // minPenValid_ (thePart)[thePer] is TRUE.
d135 1
a135 1
         minPenValid_ (thePart)[fillPer] = witTRUE;
d149 1
a149 1
         minPenValid_ (thePart)[fillPer] = witFALSE;
d154 1
a154 1
void WitRtAnalyzer::recCommitVol (double commitVol, WitBoolean byExp)
d168 1
a168 1
   WitBoolean    hasPenalty;
d178 1
a178 1
               hasPenalty = witTRUE;
d196 1
a196 1
WitBoolean WitRtAnalyzer::inInitState ()
d202 1
a202 1
      return witFALSE;
d205 1
a205 1
      return witFALSE;
d211 1
a211 1
            return witFALSE;
d214 1
a214 1
            return witFALSE;
d217 1
a217 1
   return witTRUE;
d456 1
a456 3
WitBoolean WitRtAnalyzer::canPseudoNet (
      WitBomEntry * theBomEnt, 
      WitPeriod     execPer)
d461 1
a461 1
      return witTRUE;
d467 1
a467 1
               return witTRUE;
d469 1
a469 1
   return witFALSE;
d474 1
a474 1
WitBoolean WitRtAnalyzer::canDirPseudoNet (
@


1.34
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d172 1
a172 1
      hasPenalty = (theBomEnt->usePenalty () > 0.0);
d176 1
a176 1
            if (theSub->usePenalty () > 0.0)
d188 1
a188 1
            myMsgFac () ("netUsePenaltySmsg",
d444 1
a444 1
      return theConsEnt->usePenalty ();
d451 1
a451 1
   return theConsEnt->usePenalty () + minPen_ (consPart)[consPer];
@


1.33
log
@Began implementation of multi-level lot sizes.
@
text
@d53 2
d164 32
a302 5
// analyze
//
// Note: minBopEntPen is given an initial value in order to avoid a compiler
// warning on AIX 4.1.5.
//------------------------------------------------------------------------------
a389 5
// penThruBomEntOrSubs
//
// Note: minConsEntPen is given an initial value in order to avoid a compiler
// warning on AIX 4.1.5.
//------------------------------------------------------------------------------
d444 1
a444 1
      return 0.0;
d451 1
a451 1
   return minPen_ (consPart)[consPer];
@


1.32
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d18 1
a18 2
#include <PmrMgr.h>
#include <CmrMgr.h>
@


1.31
log
@Continued implementation of Single-Source.
@
text
@d26 1
@


1.30
log
@Continued implementation of single-source.
@
text
@d24 1
@


1.29
log
@Continued preliminary work on single source.
@
text
@d108 1
a108 1
      // minPenValid_ (thePart, thePer) is TRUE.
d127 1
a127 1
      minPen_ (thePart, fillPer) = 
d132 1
a132 1
         minPenValid_ (thePart, fillPer) = witTRUE;
d141 2
a142 3
      minPen_ (
         mySelector_->myHeurAtor ()->topPart (), 
         mySelector_->myHeurAtor ()->topPer ());
d146 1
a146 1
         minPenValid_ (thePart, fillPer) = witFALSE;
d175 1
a175 1
         if (nPrereqsToAna_ (thePart, thePer) != 0)
d225 1
a225 1
   if (nPrereqsToAna_ (fillPart, fillPer) == 0)
d261 1
a261 1
   nPrereqsToAna_ (depPart, depPer) ++;
d424 1
a424 1
   witAssert (minPenValid_ (consPart, consPer));
d426 1
a426 1
   return minPen_ (consPart, consPer);
d478 1
a478 1
      nPrereqsToAna_ (depPart, depPer) --;
d480 1
a480 1
      if (nPrereqsToAna_ (depPart, depPer) == 0)
d571 1
a571 1
      minPen_ (thePart, thePer));
@


1.28
log
@Continued implementation of object iteration.
@
text
@d22 2
@


1.27
log
@Began implementation of object iteration.
@
text
@d619 2
a620 3
      if (theConsEnt->isaSubEntry ())
         {
         theSub = theConsEnt->asaSubEntry ();
d622 1
a628 1
         }
d639 1
@


1.26
log
@Continued implementation of sel-split for pen-exec.
@
text
@d22 1
a22 1
#include <Global.h>
@


1.25
log
@Continued implementation of sel-split for pen-exec,
@
text
@d165 1
a165 1
   if (! toPreAn_.isEmpty ())
d168 1
a168 1
   if (! toAnalyze_.isEmpty ())
d177 1
a177 1
         if (! dependents_.myElemAt (thePart, thePer).isEmpty ())
@


1.24
log
@Continued implementation of sel-split fpr pen-exec.
@
text
@a201 3
   if (mySelector_->selSplit ())
      mySelector_->mergeSplitBopEnts (fillPart, expPer, expBopEnts);

@


1.23
log
@Continued implementation of pen-exec for sel-split.
@
text
@d202 3
@


1.22
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d493 3
d512 3
d530 3
d545 7
a551 2
   if (myGlobalComp ()->selPrintLevel () >= 3)
      fprintf (msgFile (), "\n");
d563 3
d580 3
@


1.21
log
@Refactoring for constrained stock reallocation.
@
text
@d28 1
a28 4
WitRtAnalyzer::WitRtAnalyzer (
         WitSelector * theSelector,
         WitPmrMgr *   thePmrMgr,
         WitCmrMgr *   theCmrMgr):
d30 1
a30 1
      WitProbAssoc    (thePmrMgr),
d33 2
a34 2
      myPmrMgr_       (thePmrMgr),
      myCmrMgr_       (theCmrMgr),
a82 2
   WitPart *          thePart;
   WitPeriod          fillPer;
d85 19
a103 1
   WitPartPerStack    validPartPers  (myProblem ());
d110 3
d117 1
a117 1
      mySelector_->myHeurAtor ()->topPart (), 
a145 6

   if (printMode_) 
      printMods (modBopEntPers, modConsEntPers);

   mySelector_->myPmrMgr ()->modifyRouting (modBopEntPers);
   mySelector_->myCmrMgr ()->modifyRouting (modConsEntPers);
@


1.20
log
@Initial implementation of pegging.
@
text
@d33 1
a33 1
      WitProbAssoc    (thePmrMgr->mySelMgr ()),
@


1.19
log
@Implemented class template PtrSched <*, *>.
@
text
@d21 1
a21 1
#include <HeurAllP.h>
d55 1
a55 1
         dependents_.ptrAt (thePart, thePer) = 
d72 1
a72 1
         delete dependents_.ptrAt (thePart, thePer);
d101 2
a102 2
      mySelector_->myHeurAllPerf ()->topPart (), 
      mySelector_->myHeurAllPerf ()->topPer ());
d124 2
a125 2
         mySelector_->myHeurAllPerf ()->topPart (), 
         mySelector_->myHeurAllPerf ()->topPer ());
d167 1
a167 1
         if (! dependents_.elemAt (thePart, thePer).isEmpty ())
d245 1
a245 1
   if (dependents_.elemAt (prereqPart, prereqPer).isEmpty ())
d248 1
a248 1
   dependents_.elemAt (prereqPart, prereqPer).push (depPart, depPer);
d465 1
a465 1
   while (dependents_.elemAt (anaPart, anaPer).pop (depPart, depPer))
d486 2
a487 2
      mySelector_->myHeurAllPerf ()->topPart ()->partName ().myCstring (),
      mySelector_->myHeurAllPerf ()->topPer ());
@


1.18
log
@Templatized consumption multi-route.
@
text
@d33 1
a33 1
      WitProbAssoc     (thePmrMgr->mySelMgr ()),
d35 14
a48 14
      mySelector_      (theSelector),
      myPmrMgr_        (thePmrMgr),
      myCmrMgr_        (theCmrMgr),
      myExpRest_       (theSelector->myExpRest ()),
      toPreAn_         (myProblem ()),
      dependentsPtrTl_ (myProblem (), NULL),
      nPrereqsToAna_   (myProblem (), 0),
      toAnalyze_       (myProblem ()),
      minPen_          (myProblem (), 0.0),
      minPenValid_     (),
      printMode_       (myGlobalComp ()->selPrintLevel () >= 1),
      curPen_          (0.0),
      totCommitVol_    (0.0),
      weightedTotPen_  (0.0)
d55 2
a56 1
         dependentsPtr (thePart, thePer) = new WitPartPerStack (myProblem ());
d72 1
a72 1
         delete dependentsPtr (thePart, thePer);
d167 1
a167 1
         if (! dependents (thePart, thePer).isEmpty ())
d245 1
a245 1
   if (dependents (prereqPart, prereqPer).isEmpty ())
d248 1
a248 1
   dependents (prereqPart, prereqPer).push (depPart, depPer);
d465 1
a465 1
   while (dependents (anaPart, anaPer).pop (depPart, depPer))
@


1.17
log
@Converted several generic classes into class templates.
@
text
@d33 1
a33 1
      WitProbAssoc     (theCmrMgr),
@


1.16
log
@Minor changes.
@
text
@d561 2
a562 2
   WitPairStItr (WitBopEntry, WitPeriod)  theBopEntItr;
   WitPairStItr (WitConsEntry, WitPeriod) theConsEntItr;
@


1.15
log
@Refactoring.
@
text
@a400 1
   double    penThruConsPart;
@


1.14
log
@Refactoring.
@
text
@d193 1
a193 1
      execPer = mySelector_->modelessExecPeriod (theBopEnt, expPer);
d314 1
a314 1
         expPer = mySelector_->modelessExpPeriod (fillPart, fillPer);
d333 1
a333 1
   execPer    = mySelector_->modelessExecPeriod (theBopEnt, expPer);
@


1.13
log
@Continued development of selection splitting for multi=exec.
@
text
@d316 2
a317 1
         myPmrMgr_->findExpBopEnts (fillPart, expPer, expBopEnts);
@


1.12
log
@Refactoring for selection splitting.
@
text
@d595 1
a595 1
            theSub->myBomEntryIndex (),
d601 1
a601 1
         theBomEnt = theConsEnt->myBomEntry ();
@


1.11
log
@Continued implementation of selection splitting with the new design.
@
text
@d18 2
a19 2
#include <ProdRtr.h>
#include <ConsRtr.h>
d30 2
a31 2
         WitProdRtr *  theProdRtr,
         WitConsRtr *  theConsRtr):
d33 1
a33 1
      WitProbAssoc     (theConsRtr),
d36 2
a37 2
      myProdRtr_       (theProdRtr),
      myConsRtr_       (theConsRtr),
d133 2
a134 2
   mySelector_->myProdRtr ()->modifyRouting (modBopEntPers);
   mySelector_->myConsRtr ()->modifyRouting (modConsEntPers);
d203 1
a203 1
               myConsRtr_->findExpConsEnts (theBomEnt, execPer, expConsEnts);
d295 1
a295 1
   if (minBopEnt != myProdRtr_->selBopEntry (fillPart, expPer))
d316 1
a316 1
         myProdRtr_->findExpBopEnts (fillPart, expPer, expBopEnts);
d368 1
a368 1
   myConsRtr_->findExpConsEnts (theBomEnt, execPer, expConsEnts);
d387 1
a387 1
   if (minConsEnt != myConsRtr_->selConsEntry (theBomEnt, execPer))
@


1.10
log
@Fixed some bugs in coarse selection splitting.
@
text
@d21 1
d83 1
a83 5
void WitRtAnalyzer::analyzeRoutings (
      WitPart *            topPart, 
      WitPeriod            topPer,
      WitBopEntPerStack &  modBopEntPers,
      WitConsEntPerStack & modConsEntPers)
d85 5
a89 4
   WitPart * thePart;
   WitPeriod fillPer;

   WitPartPerStack validPartPers (myProblem ());
a93 1

d97 1
a97 4
     printAnaHead (topPart, topPer);

   modBopEntPers .clear ();
   modConsEntPers.clear ();
d99 3
a101 1
   toPreAn_.push (topPart, topPer);
d121 4
a124 1
   curPen_ = minPen_ (topPart, topPer);
d132 3
d475 1
a475 1
void WitRtAnalyzer::printAnaHead (WitPart * thePart, WitPeriod thePer)
d485 2
a486 2
      thePart->partName ().myCstring (),
      thePer);
@


1.9
log
@Initial implementation of coarse selection splitting for build-ahead.
@
text
@d105 1
a105 1
   toPreAn_.put (topPart, topPer);
d107 1
a107 1
   while (toPreAn_.get (thePart, fillPer))
d110 1
a110 1
   while (toAnalyze_.get (thePart, fillPer))
d119 1
a119 1
         validPartPers.put (thePart, fillPer);
d128 1
a128 1
      while (validPartPers.get (thePart, fillPer))
d189 1
a189 1
   while (expBopEnts.get (theBopEnt))
d203 1
a203 1
               while (expConsEnts.get (theConsEnt))
d212 1
a212 1
      toAnalyze_.put (fillPart, fillPer);
d243 1
a243 1
      toPreAn_.put (prereqPart, prereqPer);
d245 1
a245 1
   dependents (prereqPart, prereqPer).put (depPart, depPer);
d281 1
a281 1
   while (expBopEnts.get (theBopEnt))
d294 1
a294 1
      modBopEntPers.put (minBopEnt, expPer);
d371 1
a371 1
   while (expConsEnts.get (theConsEnt))
d386 1
a386 1
      modConsEntPers.put (minConsEnt, execPer);
d462 1
a462 1
   while (dependents (anaPart, anaPer).get (depPart, depPer))
d467 1
a467 1
         toAnalyze_.put (depPart, depPer);
@


1.8
log
@Coarse selection splitting.
@
text
@a21 1
#include <StackItr.h>
d559 2
a560 2
   WitPairStackItr (WitBopEntry, WitPeriod)  theBopEntItr;
   WitPairStackItr (WitConsEntry, WitPeriod) theConsEntItr;
@


1.7
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d18 2
a19 1
#include <MrMgr.h>
d28 6
a33 2
WitRtAnalyzer::WitRtAnalyzer (WitMrMgr * theMrMgr, WitSelector * theSelector):
      WitProbAssoc     (theMrMgr),
a34 1
      myMrMgr_         (theMrMgr),
d36 3
a38 1
      myExpRest_       (theMrMgr->myExpRest ()),
d202 1
a202 1
               myMrMgr_->findExpConsEnts (theBomEnt, execPer, expConsEnts);
d294 1
a294 1
   if (minBopEnt != myMrMgr_->selBopEntry (fillPart, expPer))
d315 1
a315 1
         myMrMgr_->findExpBopEnts (fillPart, expPer, expBopEnts);
d367 1
a367 1
   myMrMgr_->findExpConsEnts (theBomEnt, execPer, expConsEnts);
d386 1
a386 1
   if (minConsEnt != myMrMgr_->selConsEntry (theBomEnt, execPer))
@


1.6
log
@Some minor modifications.
@
text
@d100 1
a100 1
   toPreAn_.push (topPart, topPer);
d102 1
a102 1
   while (toPreAn_.pop (thePart, fillPer))
d105 1
a105 1
   while (toAnalyze_.pop (thePart, fillPer))
d114 1
a114 1
         validPartPers.push (thePart, fillPer);
d123 1
a123 1
      while (validPartPers.pop (thePart, fillPer))
d184 1
a184 1
   while (expBopEnts.pop (theBopEnt))
d186 1
a186 1
      execPer = mySelector_->modelessExecPeriod (theBopEnt, expPer, fillPer);
d198 1
a198 1
               while (expConsEnts.pop (theConsEnt))
d207 1
a207 1
      toAnalyze_.push (fillPart, fillPer);
d238 1
a238 1
      toPreAn_.push (prereqPart, prereqPer);
d240 1
a240 1
   dependents (prereqPart, prereqPer).push (depPart, depPer);
d276 1
a276 1
   while (expBopEnts.pop (theBopEnt))
d278 1
a278 1
      theBopEntPen = penThruBopEnt (theBopEnt, expPer, modConsEntPers, fillPer);
d289 1
a289 1
      modBopEntPers.push (minBopEnt, expPer);
d318 1
a318 2
      WitConsEntPerStack & modConsEntPers,
      WitPeriod            fillPer)
d325 1
a325 1
   execPer    = mySelector_->modelessExecPeriod (theBopEnt, expPer, fillPer);
d366 1
a366 1
   while (expConsEnts.pop (theConsEnt))
d381 1
a381 1
      modConsEntPers.push (minConsEnt, execPer);
d457 1
a457 1
   while (dependents (anaPart, anaPer).pop (depPart, depPer))
d462 1
a462 1
         toAnalyze_.push (depPart, depPer);
@


1.5
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d21 1
a21 1
#include <DynItr.h>
d176 2
a177 2
   WitObjDynStack (WitBopEntry)  expBopEnts  (myProblem ());
   WitObjDynStack (WitConsEntry) expConsEnts (myProblem ());
d261 6
a266 7
   WitPeriod     expPer;
   WitBopEntry * minBopEnt;
   WitBopEntry * theBopEnt;
   double        minBopEntPen;
   double        theBopEntPen;

   WitObjDynStack (WitBopEntry) expBopEnts (myProblem ());
d297 4
a300 4
      WitPart *                      fillPart, 
      WitPeriod                      fillPer, 
      WitPeriod &                    expPer, 
      WitObjDynStack (WitBopEntry) & expBopEnts)
d357 1
a357 1
   WitObjDynStack (WitConsEntry) expConsEnts (myProblem ());
d555 2
a556 2
   WitPairDynItr (WitBopEntry, WitPeriod)  theBopEntItr;
   WitPairDynItr (WitConsEntry, WitPeriod) theConsEntItr;
@


1.4
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d49 1
a49 2
         dependentsPtr (thePart, thePer) = 
            new WitPartPerDynStack (myProblem ());
d78 4
a81 4
      WitPart *               topPart, 
      WitPeriod               topPer,
      WitBopEntPerDynStack &  modBopEntPers,
      WitConsEntPerDynStack & modConsEntPers)
d86 1
a86 1
   WitPartPerDynStack validPartPers (myProblem ());
d256 4
a259 4
      WitPart *               fillPart,
      WitPeriod               fillPer, 
      WitBopEntPerDynStack &  modBopEntPers,
      WitConsEntPerDynStack & modConsEntPers)
d317 4
a320 4
      WitBopEntry *           theBopEnt, 
      WitPeriod               expPer,
      WitConsEntPerDynStack & modConsEntPers,
      WitPeriod               fillPer)
d349 3
a351 3
      WitBomEntry *           theBomEnt, 
      WitPeriod               execPer,
      WitConsEntPerDynStack & modConsEntPers)
d543 2
a544 2
      const WitBopEntPerDynStack  & modBopEntPers,
      const WitConsEntPerDynStack & modConsEntPers)
d571 3
a573 1
   for (theBopEntItr = modBopEntPers; theBopEntItr (theBopEnt, expPer);)
d580 3
a582 1
   for (theConsEntItr = modConsEntPers; theConsEntItr (theConsEnt, execPer);)
@


1.3
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d21 1
d50 1
a50 1
            new WitDynPerStack (WitPart) (myProblem ());
d79 4
a82 4
      WitPart *                       topPart, 
      WitPeriod                       topPer,
      WitDynPerStack (WitBopEntry) &  modBopEntPers,
      WitDynPerStack (WitConsEntry) & modConsEntPers)
d87 1
a87 1
   WitDynPerStack (WitPart) validPartPers (myProblem ());
d177 2
a178 2
   WitDynStack (WitBopEntry)  expBopEnts  (myProblem ());
   WitDynStack (WitConsEntry) expConsEnts (myProblem ());
d257 4
a260 4
      WitPart *                       fillPart,
      WitPeriod                       fillPer, 
      WitDynPerStack (WitBopEntry) &  modBopEntPers,
      WitDynPerStack (WitConsEntry) & modConsEntPers)
d268 1
a268 1
   WitDynStack (WitBopEntry) expBopEnts (myProblem ());
d299 4
a302 4
      WitPart *                   fillPart, 
      WitPeriod                   fillPer, 
      WitPeriod &                 expPer, 
      WitDynStack (WitBopEntry) & expBopEnts)
d318 4
a321 4
      WitBopEntry *                   theBopEnt, 
      WitPeriod                       expPer,
      WitDynPerStack (WitConsEntry) & modConsEntPers,
      WitPeriod                       fillPer)
d350 3
a352 3
      WitBomEntry *                   theBomEnt, 
      WitPeriod                       execPer,
      WitDynPerStack (WitConsEntry) & modConsEntPers)
d359 1
a359 1
   WitDynStack (WitConsEntry) expConsEnts (myProblem ());
d544 2
a545 2
      const WitDynPerStack (WitBopEntry)  & modBopEntPers,
      const WitDynPerStack (WitConsEntry) & modConsEntPers)
d550 6
a555 8
   WitDynPerItr (WitBopEntry)  theBopEntItr;
   WitBopEntry *               theBopEnt;
   WitPeriod                   expPer;
   WitDynPerItr (WitConsEntry) theConsEntItr;
   WitConsEntry *              theConsEnt;
   WitPeriod                   execPer;
   WitSubEntry *               theSub;
   WitBomEntry *               theBomEnt;
d557 2
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d221 1
a221 1
   if (theConsEnt->effUsageRate () > 0.0)
d394 1
a394 1
   double    effUsageRateVal;
d399 1
a399 1
   effUsageRateVal = theConsEnt->effUsageRate ();
d401 1
a401 1
   if (effUsageRateVal <= 0.0)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

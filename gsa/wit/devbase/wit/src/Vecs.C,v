head	1.69;
access;
symbols
	sce_5_01_20080919:1.60
	latest_sce_4_20_20060523:1.56.0.2
	sce_4_20_20060523:1.56
	latest_sce4_20_OSL:1.55.0.2
	sce_4_20_OSL:1.55
	sce_410_withVa:1.39
	sce_4_05_20040511:1.38
	sce_4_00_20040201:1.25
	nextGenBranch:1.19.0.2
	nextGenRoot:1.19
	sce_3_30_20030627:1.19
	EndRw-branch:1.15.0.4
	Root-of-EndRw:1.15
	rwToStl:1.15.0.2
	latest_sce_3_10_20010924:1.4.0.2
	sce_3_10_20010924:1.4
	latest_sce_3_00_20010601:1.2.0.2
	sce_3_00_20010601:1.2
	latest_sce_2_31_20010308:1.1.0.2
	sce_2_31_20010308:1.1;
locks; strict;
comment	@ * @;


1.69
date	2011.09.28.23.50.39;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2011.09.24.00.28.56;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2011.08.30.20.18.23;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2010.06.28.18.37.16;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2010.03.16.22.42.29;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2010.01.28.23.16.58;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2010.01.28.20.10.12;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2010.01.25.19.45.19;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.09.18.13.39;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.18.21.53.31;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.18.17.42.17;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.11.22.37.21;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.24.17.50.53;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.02.17.34.15;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2006.03.02.21.55.49;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2006.02.21.15.44.15;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2006.02.17.17.07.18;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.02.16.22.37.08;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.02.16.16.48.45;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.02.10.16.51.59;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.27.23.16.22;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.15.21.27.24;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.31.22.00.50;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.09.27.21.50.19;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.09.27.20.31.00;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.27.17.56.33;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.09.26.21.44.32;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.26.18.47.56;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.22.14.59.51;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.14.21.54.46;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.02.08.20.36.19;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.19.22.16.29;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.14.21.29.57;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.14.21.25.36;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.13.21.50.14;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.24.19.50.32;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.19.22.00.53;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.16.22.39.28;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.12.15.09.24;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.04.22.05.10;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.04.16.44.30;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.03.22.36.22;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.15.23.22.33;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.11.18.37.27;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.10.17.27.37;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.09.23.20.58;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.09.22.44.06;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.25.23.49.57;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.23.20.47.21;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.22.19.32.14;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.02.22.18.54;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.25.15.15.23;	author rwToStl;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.11.18.53.18;	author rjw;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.06.26.15.38.28;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.08.21.58.59;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.19.21.57;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.20.15.06;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.06.20.04.15;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.03.23.16.43;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.03.19.58.30;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.02.20.53.17;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.01.14.26.02;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.18.14.02.47;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.06.17.30.58;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.05.20.02.05;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.25.14.53.29;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.20.00.44.23;	author bobw;	state Exp;
branches;
next	;

1.15.2.1
date	2002.11.08.16.11.33;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "Vecs.C"
//               
// Contains the implementations of the following:
//
//    Class String
//    Class Template TVec   <Elem>, with explicit instantiation.
//    Class Template Vector <Elem>, with explicit instantiation.
//    NonClass functions with arguments belonging to specific Vector classes.
//------------------------------------------------------------------------------

#include <Str.h>
#include <List.h>
#include <Problem.h>
#include <FlexVec.h>
#include <WitRun.h>
#include <GlobalComp.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------
// Implementation of class String.
//------------------------------------------------------------------------------

WitString::WitString ():
      myVector_ ()
   {
   operator = ("");
   }

//------------------------------------------------------------------------------

WitString::WitString (const char * theCstring):
      myVector_ ()
   {
   operator = (theCstring);
   }

//------------------------------------------------------------------------------

WitString::WitString (int nBlanks):
      myVector_ ()
   {
   resize (nBlanks);
   }

//------------------------------------------------------------------------------

WitString::WitString (const WitString & theString):
      myVector_ ()
   {
   operator = (theString.myCstring ());
   }

//------------------------------------------------------------------------------

WitString::~WitString ()
   {
   }

//------------------------------------------------------------------------------

void WitString::operator = (const char * theCstring)
   {
   myVector_.resize (strlen (theCstring) + 1);

   strcpy (myCstringForUpdate (), theCstring);
   }

//------------------------------------------------------------------------------

bool WitString::operator < (const char * theCstring) const
   {
   return (strcmp (myCstring (), theCstring) < 0);
   }

//------------------------------------------------------------------------------

void WitString::resize (int nChars)
   {
   myVector_.resize (nChars + 1, ' ');

   (* this)[static_cast <int> (nChars)] = '\0';
   }

//------------------------------------------------------------------------------

char * WitString::apiDupCstring () const
   {
   char * theCstring;

   apiAlloc (& theCstring, length () + 1);

   copyInto (theCstring);

   return theCstring;
   }

//------------------------------------------------------------------------------

void WitString::copyInto (char * theCstring) const
   {
   strcpy (theCstring, myCstring ());
   }

//------------------------------------------------------------------------------
// Implementation of class template TVec <Elem>
//------------------------------------------------------------------------------

template <typename Elem> 
      WitTVec <Elem>::WitTVec ():
         WitVector <Elem> ()
   {
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      WitTVec <Elem>::WitTVec (WitProblem * theProblem, Elem initValue):
         WitVector <Elem> ()
   {
   allocate (theProblem, initValue);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      WitTVec <Elem>::~WitTVec ()
   {
   }

//------------------------------------------------------------------------------

template <typename Elem>
      void WitTVec <Elem>::operator = (
         const WitFlexVec <Elem> & theFlexVec)
   {
   theFlexVec.copyInto (* this);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitTVec <Elem>::allocate (WitProblem * theProblem, Elem theScalar)
   {
   resize (theProblem->nPeriods (), theScalar);
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template TVec <Elem>
//------------------------------------------------------------------------------

template class WitTVec <bool>;
template class WitTVec <int>;
template class WitTVec <double>;
template class WitTVec <void *>;

//------------------------------------------------------------------------------
// Implementation of class template Vector <Elem>
//------------------------------------------------------------------------------

template <typename Elem> 
      WitVector <Elem>::WitVector ():
         myCVec_ (NULL),
         length_ (0)
   {
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      WitVector <Elem>::WitVector (int nElems, Elem initValue):
         myCVec_ (NULL),
         length_ (0)
   {
   resize (nElems, initValue);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      WitVector <Elem>::~WitVector ()
   {
   delete[] myCVec_;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitVector <Elem>::operator = (const WitVector & theVector)
   {
   witAssert (length_ == theVector.length_);

   copy (myCVec_, theVector.myCVec_, length_);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitVector <Elem>::operator = (Elem theScalar)
   {
   int theIdx;

   for (theIdx = 0; theIdx < length_; theIdx ++)
      myCVec_[theIdx] = theScalar;
   }  

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitVector <Elem>::operator = (const Elem * theCVec)
   {
   copy (myCVec_, theCVec, length_);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitVector <Elem>::copyInto (Elem * theCVec) const
   {
   copy (theCVec, myCVec_, length_);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitVector <Elem>::clear ()
   {
   resize (0);
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitVector <Elem>::resize (int nElems, Elem theScalar)
   {
   resize (nElems);

   (* this) = theScalar;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
       void WitVector <Elem>::resize (int nElems)
   {
   delete[] myCVec_;

   myCVec_ = new Elem[nElems];
   length_ = nElems;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      bool WitVector <Elem>::operator == (Elem theScalar) const
   {
   int theIdx;

   for (theIdx = 0; theIdx < length (); theIdx ++)
      if (myCVec_[theIdx] != theScalar)
         return false;

   return true;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitVector <Elem>::checkBounds (int theIdx) const
   {
   if (theIdx < 0)
      WitMsgFacility::issueByException ("negativeIndexFmsg", theIdx);

   if (theIdx >= length_)
      WitMsgFacility::issueByException ("indexTooLargeFmsg",
         theIdx,
         length_ - 1);
   }

//------------------------------------------------------------------------------
// Explicit instantiation of class template Vector <Elem>
//------------------------------------------------------------------------------

template class WitVector <bool>;
template class WitVector <char>;
template class WitVector <int>;
template class WitVector <double>;
template class WitVector <void *>;
template class WitVector <const char *>;

//------------------------------------------------------------------------------
// Implementation of NonClass functions with arguments belonging to Vector
// classes and C-vector types.
//------------------------------------------------------------------------------

bool WitNonClass::operator >= (
      const WitVector <double> & theVector,
      double                     theScalar)
   {
   int theIdx;

   for (theIdx = 0; theIdx < theVector.length (); theIdx ++)
      if (theVector[theIdx] < theScalar)
         return false;

   return true;
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitNonClass::copy (
         Elem *       dstCVec, 
         const Elem * srcCVec, 
         int          nElems)
   {
   int theIdx;

   if (DEBUG_MODE)
      if (nElems > 0)
         {
         witAssert (dstCVec != NULL);
         witAssert (srcCVec != NULL);
         }

   for (theIdx = 0; theIdx < nElems; theIdx ++)
      dstCVec[theIdx] = srcCVec[theIdx];
   }

//------------------------------------------------------------------------------
// Explicit instantiation of function template NonClass::copy.
//------------------------------------------------------------------------------

template void WitNonClass::copy <bool>   (bool *,   const bool *,   int);
template void WitNonClass::copy <int>    (int *,    const int *,    int);
template void WitNonClass::copy <double> (double *, const double *, int);
template void WitNonClass::copy <void *> (void * *, void * const *, int);

//------------------------------------------------------------------------------

template <typename Elem> 
      bool WitNonClass::hasSingleValue (const Elem * theCVec, int nElems)
   {
   Elem valAt0;
   int  theIdx;

   witAssert (theCVec != NULL);

   valAt0 = theCVec[0];

   for (theIdx = 1; theIdx < nElems; theIdx ++)
      if (theCVec[theIdx] != valAt0)
         return false;

   return true;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of function template NonClass::hasSingleValue.
//------------------------------------------------------------------------------

template bool WitNonClass::hasSingleValue <bool>   (const bool *,       int);
template bool WitNonClass::hasSingleValue <int>    (const int *,        int);
template bool WitNonClass::hasSingleValue <float>  (const float *,      int);
template bool WitNonClass::hasSingleValue <double> (const double *,     int);
template bool WitNonClass::hasSingleValue <void *> (void * const *,     int);
@


1.68
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.67
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d12 1
a12 1
//
d34 4
a37 4
myVector_ ()
{
operator = ("");
}
d42 4
a45 4
myVector_ ()
{
operator = (theCstring);
}
d50 4
a53 4
myVector_ ()
{
resize (nBlanks);
}
d58 4
a61 4
myVector_ ()
{
operator = (theString.myCstring ());
}
d66 2
a67 2
{
}
d72 2
a73 2
{
myVector_.resize (strlen (theCstring) + 1);
d75 2
a76 2
strcpy (myCstringForUpdate (), theCstring);
}
d81 3
a83 3
{
return (strcmp (myCstring (), theCstring) < 0);
}
d88 2
a89 2
{
myVector_.resize (nChars + 1, ' ');
d91 2
a92 2
(* this)[static_cast <int> (nChars)] = '\0';
}
d97 2
a98 2
{
char * theCstring;
d100 1
a100 1
apiAlloc (& theCstring, length () + 1);
d102 1
a102 1
copyInto (theCstring);
d104 2
a105 2
return theCstring;
}
d110 3
a112 3
{
strcpy (theCstring, myCstring ());
}
d118 5
a122 5
template <typename Elem>
WitTVec <Elem>::WitTVec ():
WitVector <Elem> ()
{
}
d126 6
a131 6
template <typename Elem>
WitTVec <Elem>::WitTVec (WitProblem * theProblem, Elem initValue):
WitVector <Elem> ()
{
allocate (theProblem, initValue);
}
d135 4
a138 4
template <typename Elem>
WitTVec <Elem>::~WitTVec ()
{
}
d143 5
a147 5
void WitTVec <Elem>::operator = (
const WitFlexVec <Elem> & theFlexVec)
{
theFlexVec.copyInto (* this);
}
d151 5
a155 5
template <typename Elem>
void WitTVec <Elem>::allocate (WitProblem * theProblem, Elem theScalar)
{
resize (theProblem->nPeriods (), theScalar);
}
d170 6
a175 6
template <typename Elem>
WitVector <Elem>::WitVector ():
myCVec_ (NULL),
length_ (0)
{
}
d179 7
a185 7
template <typename Elem>
WitVector <Elem>::WitVector (int nElems, Elem initValue):
myCVec_ (NULL),
length_ (0)
{
resize (nElems, initValue);
}
d189 5
a193 5
template <typename Elem>
WitVector <Elem>::~WitVector ()
{
delete[] myCVec_;
}
d197 4
a200 4
template <typename Elem>
void WitVector <Elem>::operator = (const WitVector & theVector)
{
witAssert (length_ == theVector.length_);
d202 2
a203 2
copy (myCVec_, theVector.myCVec_, length_);
}
d207 8
a214 8
template <typename Elem>
void WitVector <Elem>::operator = (Elem theScalar)
{
int theIdx;

for (theIdx = 0; theIdx < length_; theIdx ++)
myCVec_[theIdx] = theScalar;
}
d218 5
a222 5
template <typename Elem>
void WitVector <Elem>::operator = (const Elem * theCVec)
{
copy (myCVec_, theCVec, length_);
}
d226 5
a230 5
template <typename Elem>
void WitVector <Elem>::copyInto (Elem * theCVec) const
{
copy (theCVec, myCVec_, length_);
}
d234 5
a238 5
template <typename Elem>
void WitVector <Elem>::clear ()
{
resize (0);
}
d242 4
a245 4
template <typename Elem>
void WitVector <Elem>::resize (int nElems, Elem theScalar)
{
resize (nElems);
d247 2
a248 2
(* this) = theScalar;
}
d252 8
a259 8
template <typename Elem>
void WitVector <Elem>::resize (int nElems)
{
delete[] myCVec_;

myCVec_ = new Elem[nElems];
length_ = nElems;
}
d263 8
a270 8
template <typename Elem>
bool WitVector <Elem>::operator == (Elem theScalar) const
{
int theIdx;

for (theIdx = 0; theIdx < length (); theIdx ++)
if (myCVec_[theIdx] != theScalar)
return false;
d272 2
a273 2
return true;
}
d277 11
a287 11
template <typename Elem>
void WitVector <Elem>::checkBounds (int theIdx) const
{
if (theIdx < 0)
WitMsgFacility::issueByException ("negativeIndexFmsg", theIdx);

if (theIdx >= length_)
WitMsgFacility::issueByException ("indexTooLargeFmsg",
theIdx,
length_ - 1);
}
d306 11
a316 11
const WitVector <double> & theVector,
double                     theScalar)
{
int theIdx;

for (theIdx = 0; theIdx < theVector.length (); theIdx ++)
if (theVector[theIdx] < theScalar)
return false;

return true;
}
d320 18
a337 18
template <typename Elem>
void WitNonClass::copy (
Elem *       dstCVec,
const Elem * srcCVec,
int          nElems)
{
int theIdx;

if (DEBUG_MODE)
if (nElems > 0)
{
witAssert (dstCVec != NULL);
witAssert (srcCVec != NULL);
}

for (theIdx = 0; theIdx < nElems; theIdx ++)
dstCVec[theIdx] = srcCVec[theIdx];
}
d350 13
a362 13
template <typename Elem>
bool WitNonClass::hasSingleValue (const Elem * theCVec, int nElems)
{
Elem valAt0;
int  theIdx;

witAssert (theCVec != NULL);

valAt0 = theCVec[0];

for (theIdx = 1; theIdx < nElems; theIdx ++)
if (theCVec[theIdx] != valAt0)
return false;
d364 2
a365 2
return true;
}
@


1.66
log
@Removed sizeof test.
Added explicit implementation of WitVector <char>.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d12 1
a12 1
//               
d34 4
a37 4
      myVector_ ()
   {
   operator = ("");
   }
d42 4
a45 4
      myVector_ ()
   {
   operator = (theCstring);
   }
d50 4
a53 4
      myVector_ ()
   {
   resize (nBlanks);
   }
d58 4
a61 4
      myVector_ ()
   {
   operator = (theString.myCstring ());
   }
d66 2
a67 2
   {
   }
d72 2
a73 2
   {
   myVector_.resize (strlen (theCstring) + 1);
d75 2
a76 2
   strcpy (myCstringForUpdate (), theCstring);
   }
d81 3
a83 3
   {
   return (strcmp (myCstring (), theCstring) < 0);
   }
d88 2
a89 2
   {
   myVector_.resize (nChars + 1, ' ');
d91 2
a92 2
   (* this)[static_cast <int> (nChars)] = '\0';
   }
d97 2
a98 2
   {
   char * theCstring;
d100 1
a100 1
   apiAlloc (& theCstring, length () + 1);
d102 1
a102 1
   copyInto (theCstring);
d104 2
a105 2
   return theCstring;
   }
d110 3
a112 3
   {
   strcpy (theCstring, myCstring ());
   }
d118 5
a122 5
template <typename Elem> 
      WitTVec <Elem>::WitTVec ():
         WitVector <Elem> ()
   {
   }
d126 6
a131 6
template <typename Elem> 
      WitTVec <Elem>::WitTVec (WitProblem * theProblem, Elem initValue):
         WitVector <Elem> ()
   {
   allocate (theProblem, initValue);
   }
d135 4
a138 4
template <typename Elem> 
      WitTVec <Elem>::~WitTVec ()
   {
   }
d143 5
a147 5
      void WitTVec <Elem>::operator = (
         const WitFlexVec <Elem> & theFlexVec)
   {
   theFlexVec.copyInto (* this);
   }
d151 5
a155 5
template <typename Elem> 
      void WitTVec <Elem>::allocate (WitProblem * theProblem, Elem theScalar)
   {
   resize (theProblem->nPeriods (), theScalar);
   }
d170 6
a175 6
template <typename Elem> 
      WitVector <Elem>::WitVector ():
         myCVec_ (NULL),
         length_ (0)
   {
   }
d179 7
a185 7
template <typename Elem> 
      WitVector <Elem>::WitVector (int nElems, Elem initValue):
         myCVec_ (NULL),
         length_ (0)
   {
   resize (nElems, initValue);
   }
d189 5
a193 5
template <typename Elem> 
      WitVector <Elem>::~WitVector ()
   {
   delete[] myCVec_;
   }
d197 4
a200 4
template <typename Elem> 
      void WitVector <Elem>::operator = (const WitVector & theVector)
   {
   witAssert (length_ == theVector.length_);
d202 2
a203 2
   copy (myCVec_, theVector.myCVec_, length_);
   }
d207 8
a214 8
template <typename Elem> 
      void WitVector <Elem>::operator = (Elem theScalar)
   {
   int theIdx;

   for (theIdx = 0; theIdx < length_; theIdx ++)
      myCVec_[theIdx] = theScalar;
   }  
d218 5
a222 5
template <typename Elem> 
      void WitVector <Elem>::operator = (const Elem * theCVec)
   {
   copy (myCVec_, theCVec, length_);
   }
d226 5
a230 5
template <typename Elem> 
      void WitVector <Elem>::copyInto (Elem * theCVec) const
   {
   copy (theCVec, myCVec_, length_);
   }
d234 5
a238 5
template <typename Elem> 
      void WitVector <Elem>::clear ()
   {
   resize (0);
   }
d242 4
a245 4
template <typename Elem> 
      void WitVector <Elem>::resize (int nElems, Elem theScalar)
   {
   resize (nElems);
d247 2
a248 2
   (* this) = theScalar;
   }
d252 8
a259 8
template <typename Elem> 
       void WitVector <Elem>::resize (int nElems)
   {
   delete[] myCVec_;

   myCVec_ = new Elem[nElems];
   length_ = nElems;
   }
d263 8
a270 8
template <typename Elem> 
      bool WitVector <Elem>::operator == (Elem theScalar) const
   {
   int theIdx;

   for (theIdx = 0; theIdx < length (); theIdx ++)
      if (myCVec_[theIdx] != theScalar)
         return false;
d272 2
a273 2
   return true;
   }
d277 11
a287 11
template <typename Elem> 
      void WitVector <Elem>::checkBounds (int theIdx) const
   {
   if (theIdx < 0)
      WitMsgFacility::issueByException ("negativeIndexFmsg", theIdx);

   if (theIdx >= length_)
      WitMsgFacility::issueByException ("indexTooLargeFmsg",
         theIdx,
         length_ - 1);
   }
d306 11
a316 11
      const WitVector <double> & theVector,
      double                     theScalar)
   {
   int theIdx;

   for (theIdx = 0; theIdx < theVector.length (); theIdx ++)
      if (theVector[theIdx] < theScalar)
         return false;

   return true;
   }
d320 18
a337 18
template <typename Elem> 
      void WitNonClass::copy (
         Elem *       dstCVec, 
         const Elem * srcCVec, 
         int          nElems)
   {
   int theIdx;

   if (DEBUG_MODE)
      if (nElems > 0)
         {
         witAssert (dstCVec != NULL);
         witAssert (srcCVec != NULL);
         }

   for (theIdx = 0; theIdx < nElems; theIdx ++)
      dstCVec[theIdx] = srcCVec[theIdx];
   }
d350 13
a362 13
template <typename Elem> 
      bool WitNonClass::hasSingleValue (const Elem * theCVec, int nElems)
   {
   Elem valAt0;
   int  theIdx;

   witAssert (theCVec != NULL);

   valAt0 = theCVec[0];

   for (theIdx = 1; theIdx < nElems; theIdx ++)
      if (theCVec[theIdx] != valAt0)
         return false;
d364 2
a365 2
   return true;
   }
@


1.65
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d294 1
@


1.64
log
@Multi-objective mode
@
text
@d26 1
a26 1
#include <Global.h>
@


1.63
log
@Multi-objective mode.
@
text
@d102 1
a102 1
   strcpy   (theCstring, myCstring ());
d108 7
@


1.62
log
@Multi-objective mode
@
text
@d290 1
@


1.61
log
@When comparing a file name to WitSTDOUT, changed from pointer equality
to string equality.
@
text
@d36 1
a36 1
   copyCstring ("");
d44 1
a44 1
   copyCstring (theCstring);
d60 1
a60 1
   copyCstring (theString.myCstring ());
d71 1
a71 1
void WitString::operator = (const WitString & theString)
d73 3
a75 1
   copyCstring (theString.myCstring ());
a86 9
void WitString::copyCstring (const char * theCstring)
   {
   myVector_.resize (strlen (theCstring) + 1);

   strcpy (myCstringForUpdate (), theCstring);
   }

//------------------------------------------------------------------------------

@


1.60
log
@Stochastic Implosion
@
text
@a29 7

bool WitNonClass::equal (const char * lhs, const char * rhs)
   {
   return (strcmp (lhs, rhs) == 0);
   }

//------------------------------------------------------------------------------
@


1.59
log
@Stochastic Implosion
@
text
@d30 7
a84 7
bool WitString::operator == (const char * theCstring) const
   {
   return (strcmp (myCstring (), theCstring) == 0);
   }

//------------------------------------------------------------------------------

@


1.58
log
@Assisted opt implosion.
@
text
@d71 7
d85 1
a85 1
bool WitString::operator < (const WitString & theString) const
d87 1
a87 1
   return (strcmp (myCstring (), theString.myCstring ()) < 0);
a100 7
void WitString::operator = (const WitString & theString)
   {
   copyCstring (theString.myCstring ());
   }

//------------------------------------------------------------------------------

@


1.57
log
@App controlled opt implosion.
@
text
@d333 6
a338 2
   witAssert (dstCVec != NULL);
   witAssert (srcCVec != NULL);
@


1.56
log
@Updated the copyright date on all source files.
@
text
@d78 7
@


1.55
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.54
log
@[shared-resource pegging]
@
text
@a15 6
//    Class AbsDenseList
//    Class Template DenseList <Elem>, with explicit instantiation.
//    NonClass function templates that use DenseList.
//    Class AbsDLSorter
//    Class template DLSorter <Elem>
//    Class DLSortEl
a21 2
#include <Dense.h>
#include <DLSort.h>
a114 264
// Implementation of class WitAbsDenseList.
//------------------------------------------------------------------------------

WitAbsDenseList::WitAbsDenseList (int maxNElements):
      myVector_  (maxNElements, NULL),
      nElements_ (0)
   {
   }

//------------------------------------------------------------------------------

WitAbsDenseList::~WitAbsDenseList ()
   {
   }

//------------------------------------------------------------------------------

void WitAbsDenseList::appendAbs (void * theObject)
   {
   witAssert (nElements_ < storageCapacity ());

   witAssert (theObject != NULL);

   myVector_[static_cast <int> (nElements_)] = theObject;

   ++ nElements_;
   }

//------------------------------------------------------------------------------

void WitAbsDenseList::resize (int maxNElements)
   {
   myVector_.resize (maxNElements, NULL);

   nElements_ = 0;
   }

//------------------------------------------------------------------------------

bool WitAbsDenseList::advanceAbs (int & theIndex, void * & theElement) const
   {
   theIndex ++;

   if (theIndex < static_cast <int> (nElements_))
      {
      theElement = myVector_[theIndex];

      return true;
      }
   else
      {
      theElement = NULL;

      return false;
      }
   }

//------------------------------------------------------------------------------
// Implementation of NonClass function template copyIntoDense (DenseList, List).
//------------------------------------------------------------------------------

template <typename Elem> 
      void WitNonClass::copyIntoDense (
         WitDenseList <Elem>  & theDenseList,
         const WitList <Elem> & theList)
   {
   Elem * theObject;

   theDenseList.clear ();

   forEachEl (theObject, theList)
      theDenseList.append (theObject);
   }

//------------------------------------------------------------------------------
// Implementation of Class Template DenseList <Elem>
//------------------------------------------------------------------------------

template <typename Elem> 
      WitDenseList <Elem>::WitDenseList (int newStorageCapacity):
         WitAbsDenseList (newStorageCapacity)
   {
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      WitDenseList <Elem>::~WitDenseList ()
   {
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      void WitDenseList <Elem>::sort (
         WitCompFunc theCompFunc,
         void *      theContext)
   {
   WitDLSorter <Elem> * theDLSorter;

   theDLSorter = new WitDLSorter <Elem> (theCompFunc, theContext);

   theDLSorter->sort (* this);

   delete theDLSorter;
   }

//------------------------------------------------------------------------------
// Explicit instantiation of Class Template DenseList <Elem>
//------------------------------------------------------------------------------

template class WitDenseList <WitNode>;
template class WitDenseList <WitPart>;
template class WitDenseList <WitDemand>;
template class WitDenseList <WitSubEntry>;
template class WitDenseList <WitBopEntry>;
template class WitDenseList <WitPartPer>;
template class WitDenseList <WitCoeff>;

//------------------------------------------------------------------------------
// Explicit instantiation of NonClass function template copyIntoDense.
//------------------------------------------------------------------------------

template
   void WitNonClass::copyIntoDense <WitSubEntry> (
      WitDenseList <WitSubEntry>  &,
      const WitList <WitSubEntry> &);

template
   void WitNonClass::copyIntoDense <WitBopEntry> (
      WitDenseList <WitBopEntry>  &,
      const WitList <WitBopEntry> &);

//------------------------------------------------------------------------------
// Implementation of class AbsDLSorter.
//------------------------------------------------------------------------------

WitAbsDLSorter::WitAbsDLSorter ()
   {
   }

//------------------------------------------------------------------------------

WitAbsDLSorter::~WitAbsDLSorter ()
   {
   }

//------------------------------------------------------------------------------

void WitAbsDLSorter::sortAbs (WitAbsDenseList & theAbsDenseList)
   {
   WitDLSortEl * theDLSortElVec;
   int           theIdx;

   theDLSortElVec = new WitDLSortEl[theAbsDenseList.nElements ()];

   for (theIdx = 0; theIdx < theAbsDenseList.nElements (); theIdx ++)
      theDLSortElVec[theIdx].setData (theAbsDenseList.myVector_[theIdx], this);

   qsort (
      theDLSortElVec,
      theAbsDenseList.nElements (),
      sizeof (WitDLSortEl),
      compareForQsort);

   for (theIdx = 0; theIdx < theAbsDenseList.nElements (); theIdx ++)
      theAbsDenseList.myVector_[theIdx] = theDLSortElVec[theIdx].myElem ();

   delete[] theDLSortElVec;
   }

//------------------------------------------------------------------------------

int WitAbsDLSorter::compareForQsort (
      const void * theVoid1,
      const void * theVoid2)
   {
   const WitDLSortEl * theDLSortEl1;
   const WitDLSortEl * theDLSortEl2;

   theDLSortEl1 = static_cast <const WitDLSortEl *> (theVoid1);
   theDLSortEl2 = static_cast <const WitDLSortEl *> (theVoid2);

   witAssert (theDLSortEl1->myAbsDLSorter () == theDLSortEl2->myAbsDLSorter ());

   return
      theDLSortEl1->
         myAbsDLSorter ()->
            compare (theDLSortEl1, theDLSortEl2);
   }

//------------------------------------------------------------------------------
// Implementation of Class Template DLSorter <Elem>
//------------------------------------------------------------------------------

template <typename Elem>
      WitDLSorter <Elem>::WitDLSorter (
            WitCompFunc theCompFunc,
            void *      theContext):

         WitAbsDLSorter (),

         myCompFunc_    (theCompFunc),
         myContext_     (theContext)
   {
   }

//------------------------------------------------------------------------------

template <typename Elem>
      WitDLSorter <Elem>::~WitDLSorter ()
   {
   }

//------------------------------------------------------------------------------

template <typename Elem>
      void WitDLSorter <Elem>::sort (WitDenseList <Elem> & theDenseList)
   {
   sortAbs (theDenseList);
   }

//------------------------------------------------------------------------------

template <typename Elem>
      int WitDLSorter <Elem>::compare (
         const WitDLSortEl * theDLSortEl1,
         const WitDLSortEl * theDLSortEl2)
   {
   Elem * theElem1;
   Elem * theElem2;

   theElem1 = reinterpret_cast <Elem *> (theDLSortEl1->myElem ());
   theElem2 = reinterpret_cast <Elem *> (theDLSortEl2->myElem ());

   return myCompFunc_ (theElem1, theElem2, myContext_);
   }

//------------------------------------------------------------------------------
// Implementation of class DLSortEl.
//------------------------------------------------------------------------------

WitDLSortEl::WitDLSortEl ():

      myElem_        (NULL),
      myAbsDLSorter_ (NULL)
   {
   }

//------------------------------------------------------------------------------

WitDLSortEl::~WitDLSortEl ()
   {
   }

//------------------------------------------------------------------------------

void WitDLSortEl::setData (void * theElem, WitAbsDLSorter * theAbsDLSorter)
   {
   myElem_        = theElem;
   myAbsDLSorter_ = theAbsDLSorter;
   }

//------------------------------------------------------------------------------
@


1.53
log
@[shared-resource pegging]
@
text
@d57 1
a57 1
WitString::WitString (WitSiz nBlanks):
d102 1
a102 1
void WitString::resize (WitSiz nChars)
d126 1
a126 1
WitAbsDenseList::WitAbsDenseList (WitSiz maxNElements):
d153 1
a153 1
void WitAbsDenseList::resize (WitSiz maxNElements)
d202 1
a202 1
      WitDenseList <Elem>::WitDenseList (WitSiz newStorageCapacity):
d452 1
a452 1
      WitVector <Elem>::WitVector (WitSiz nElems, Elem initValue):
d515 1
a515 1
      void WitVector <Elem>::resize (WitSiz nElems, Elem theScalar)
d525 1
a525 1
       void WitVector <Elem>::resize (WitSiz nElems)
@


1.52
log
@[shared-resource pegging]
@
text
@d57 1
a57 1
WitString::WitString (size_t nBlanks):
d102 1
a102 1
void WitString::resize (size_t nChars)
d126 1
a126 1
WitAbsDenseList::WitAbsDenseList (size_t maxNElements):
d153 1
a153 1
void WitAbsDenseList::resize (size_t maxNElements)
d202 1
a202 1
      WitDenseList <Elem>::WitDenseList (size_t newStorageCapacity):
d452 1
a452 1
      WitVector <Elem>::WitVector (size_t nElems, Elem initValue):
d515 1
a515 1
      void WitVector <Elem>::resize (size_t nElems, Elem theScalar)
d525 1
a525 1
       void WitVector <Elem>::resize (size_t nElems)
@


1.51
log
@[shared-resource pegging]
@
text
@a568 1
template class WitVector <WitSrpSeqEl *>;
@


1.50
log
@[shared-resource pegging]
@
text
@a568 1
template class WitVector <WitSrpReqSpec *>;
@


1.49
log
@[shared-resource pegging]
@
text
@d570 1
@


1.48
log
@[shared-resource pegging]
@
text
@d569 1
@


1.47
log
@Minor update.
@
text
@d140 1
a140 1
void WitAbsDenseList::appendAbs (WitTlObj * theObject)
d162 1
a162 4
bool WitAbsDenseList::advanceAbs (
      int &        theIndex, 
      WitTlObj * & theElement) 
      const
d289 1
a289 1
      theAbsDenseList.myVector_[theIdx] = theDLSortElVec[theIdx].myTlObj ();
d355 2
a356 2
   theElem1 = fromTlObj_cast <Elem> (theDLSortEl1->myTlObj ());
   theElem2 = fromTlObj_cast <Elem> (theDLSortEl2->myTlObj ());
d367 1
a367 1
      myTlObj_       (NULL),
d380 1
a380 1
void WitDLSortEl::setData (WitTlObj * theTlObj, WitAbsDLSorter * theAbsDLSorter)
d382 1
a382 1
   myTlObj_       = theTlObj;
d436 1
a436 1
template class WitTVec <WitTlObj *>;
d568 1
a568 1
template class WitVector <WitTlObj *>;
d612 1
a612 3

template 
   void WitNonClass::copy <WitTlObj *> (WitTlObj * *, WitTlObj * const *, int);
d641 1
a641 2
template bool WitNonClass::hasSingleValue <WitTlObj *>
                                                   (WitTlObj * const *, int);
@


1.46
log
@[multi-thread]
@
text
@d65 8
@


1.45
log
@[multi-thread]
@
text
@d20 1
a20 1
//    Class template DLSorter <Elem, Context>
d210 16
d310 1
a310 1
// Implementation of Class Template DLSorter <Elem, Context>
d313 4
a316 7
template <typename Elem, typename Context>
      void WitDLSorter <Elem, Context>::sort (
         WitDenseList <Elem> & theDenseList,
         WitCompFunc           theCompFunc,
         Context *             theContext)
   {
   WitDLSorter <Elem, Context> * theDLSorter;
d318 1
a318 1
   theDLSorter = new WitDLSorter <Elem, Context> (theCompFunc, theContext);
d320 3
a322 3
   theDLSorter->sortAbs (theDenseList);

   delete theDLSorter;
d327 2
a328 9
template <typename Elem, typename Context>
      WitDLSorter <Elem, Context>::WitDLSorter (
            WitCompFunc theCompFunc,
            Context *   theContext):

         WitAbsDLSorter (),

         myCompFunc_    (theCompFunc),
         myContext_     (theContext)
d334 2
a335 2
template <typename Elem, typename Context>
      WitDLSorter <Elem, Context>::~WitDLSorter ()
d337 1
d342 2
a343 2
template <typename Elem, typename Context>
      int WitDLSorter <Elem, Context>::compare (
a356 12
// Explicit instantiation of Class Template DLSorter <Elem, Context>.
//------------------------------------------------------------------------------

template class WitDLSorter <WitDemand,   WitHeurImpPerf>;
template class WitDLSorter <WitDemand,   WitObjFunc1>;
template class WitDLSorter <WitDemand,   void>;
template class WitDLSorter <WitPartPer,  WitOptImploder>;
template class WitDLSorter <WitPart,     void>;
template class WitDLSorter <WitBopEntry, void>;
template class WitDLSorter <WitSubEntry, void>;

//------------------------------------------------------------------------------
@


1.44
log
@[multi-thread]
@
text
@d355 1
a355 1
template class WitDLSorter <WitDemand,   WitObjFunc2>;
d357 3
a359 3
template class WitDLSorter <WitPart,     WitBelowLister>;
template class WitDLSorter <WitBopEntry, WitAvSorter <WitBopEntry> >;
template class WitDLSorter <WitSubEntry, WitAvSorter <WitSubEntry> >;
@


1.43
log
@[multi-thread]
@
text
@d346 1
a346 1
   return (myContext_->*myCompFunc_) (theElem1, theElem2);
@


1.42
log
@[multi-thread]
@
text
@d19 2
a20 3
//    Class AbsDLSortCrit
//    Class template GenDLSortCrit <Elem>
//    Class template DLSortCrit <Elem, Context>
a175 45

void WitAbsDenseList::sortAbs (WitAbsDLSortCrit * theAbsDLSortCrit)
   {
   WitDLSortEl * theDLSortElVec;
   int           theIdx;

   theDLSortElVec = new WitDLSortEl[nElements_];

   for (theIdx = 0; theIdx < nElements_; theIdx ++)
      theDLSortElVec[theIdx].setData (myVector_[theIdx], theAbsDLSortCrit);

   qsort (
      theDLSortElVec,
      nElements_,
      sizeof (WitDLSortEl),
      compareForQsort);

   for (theIdx = 0; theIdx < nElements_; theIdx ++)
      myVector_[theIdx] = theDLSortElVec[theIdx].myTlObj ();

   delete[] theDLSortElVec;
   }

//------------------------------------------------------------------------------

int WitAbsDenseList::compareForQsort (
      const void * theVoid1,
      const void * theVoid2)
   {
   const WitDLSortEl * theDLSortEl1;
   const WitDLSortEl * theDLSortEl2;

   theDLSortEl1 = static_cast <const WitDLSortEl *> (theVoid1);
   theDLSortEl2 = static_cast <const WitDLSortEl *> (theVoid2);

   witAssert (
      theDLSortEl1->myAbsDLSortCrit () == theDLSortEl2->myAbsDLSortCrit ());

   return
      theDLSortEl1->
         myAbsDLSortCrit ()->
            compare (theDLSortEl1, theDLSortEl2);
   }

//------------------------------------------------------------------------------
a192 20
// Implementation of NonClass function template 
//    sort (theDenseList, theCompFunc, theContext).
//------------------------------------------------------------------------------

template <typename Elem, typename Context>
      void WitNonClass::sort (
         WitDenseList <Elem> & theDenseList,
         int (Context::*       theCompFunc) (Elem *, Elem *),
         Context *             theContext)
   {
   WitDLSortCrit <Elem, Context> * theDLSortCrit;

   theDLSortCrit = new WitDLSortCrit <Elem, Context> (theCompFunc, theContext);

   theDenseList.sort (theDLSortCrit);

   delete theDLSortCrit;
   }

//------------------------------------------------------------------------------
a209 9

template <typename Elem> 
      void WitDenseList <Elem>::sort (
         WitGenDLSortCrit <Elem> * theGenDLSortCrit)
   {
   sortAbs (theGenDLSortCrit);
   }

//------------------------------------------------------------------------------
d236 1
a236 1
// Implementation of class AbsDLSortCrit.
d239 1
a239 1
WitAbsDLSortCrit::WitAbsDLSortCrit ()
d245 1
a245 1
WitAbsDLSortCrit::~WitAbsDLSortCrit ()
d250 23
a272 1
// Implementation of Class Template GenDLSortCrit <Elem>
d275 11
a285 2
template <typename Elem>
      WitGenDLSortCrit <Elem>::WitGenDLSortCrit ():
d287 4
a290 2
         WitAbsDLSortCrit ()
   {
d294 2
d297 5
a301 2
template <typename Elem>
      WitGenDLSortCrit <Elem>::~WitGenDLSortCrit ()
d303 7
a312 2
// Implementation of Class Template DLSortCrit <Elem, Context>
//------------------------------------------------------------------------------
d315 1
a315 1
      WitDLSortCrit <Elem, Context>::WitDLSortCrit (
d319 1
a319 1
         WitGenDLSortCrit <Elem> (),
d321 2
a322 2
         myCompFunc_             (theCompFunc),
         myContext_              (theContext)
d329 1
a329 1
      WitDLSortCrit <Elem, Context>::~WitDLSortCrit ()
d336 1
a336 1
      int WitDLSortCrit <Elem, Context>::compare (
d350 1
a350 18

template <typename Elem, typename Context>
      void WitDLSortCrit <Elem, Context>::instantiateSort ()
   {
   WitDenseList <Elem> theDenseList;
   int (Context::*     theCompFunc) (Elem *, Elem *);
   Context *           theContext;

   stronglyAssert (false);

   theCompFunc = NULL;
   theContext  = NULL;

   WitNonClass::sort (theDenseList, theCompFunc, theContext);
   }

//------------------------------------------------------------------------------
// Explicit instantiation of Class Template DLSortCrit <Elem, Context>.
d353 7
a359 7
template class WitDLSortCrit <WitDemand,   WitHeurImpPerf>;
template class WitDLSortCrit <WitDemand,   WitObjFunc1>;
template class WitDLSortCrit <WitDemand,   WitObjFunc2>;
template class WitDLSortCrit <WitPartPer,  WitOptImploder>;
template class WitDLSortCrit <WitPart,     WitBelowLister>;
template class WitDLSortCrit <WitBopEntry, WitAvSorter <WitBopEntry> >;
template class WitDLSortCrit <WitSubEntry, WitAvSorter <WitSubEntry> >;
d367 2
a368 2
      myTlObj_         (NULL),
      myAbsDLSortCrit_ (NULL)
d380 1
a380 3
void WitDLSortEl::setData (
      WitTlObj *         theTlObj,
      WitAbsDLSortCrit * theAbsDLSortCrit)
d382 2
a383 2
   myTlObj_         = theTlObj;
   myAbsDLSortCrit_ = theAbsDLSortCrit;
@


1.41
log
@[multi-thread]
@
text
@d19 4
a22 3
//    Class AbsSortRule
//    Class template SortRule <Elem>
//    Class SortEl
d30 1
d178 1
a178 1
void WitAbsDenseList::sortAbs (WitAbsSortRule * theAbsSortRule)
d180 2
a181 2
   WitSortEl * theSortElVec;
   int         theIdx;
d183 1
a183 1
   theSortElVec = new WitSortEl[nElements_];
d186 1
a186 1
      theSortElVec[theIdx].setData (myVector_[theIdx], theAbsSortRule);
d189 1
a189 1
      theSortElVec,
d191 1
a191 1
      sizeof (WitSortEl),
d195 1
a195 1
      myVector_[theIdx] = theSortElVec[theIdx].myTlObj();
d197 1
a197 1
   delete[] theSortElVec;
d203 2
a204 2
      const void * elemPtr1,
      const void * elemPtr2)
d206 5
a210 5
   const WitSortEl * theSortElPtr1;
   const WitSortEl * theSortElPtr2;
   
   theSortElPtr1 = static_cast <const WitSortEl *> (elemPtr1);
   theSortElPtr2 = static_cast <const WitSortEl *> (elemPtr2);
d213 1
a213 1
      theSortElPtr1->myAbsSortRule () == theSortElPtr2->myAbsSortRule ());
d216 3
a218 5
      theSortElPtr1->
         myAbsSortRule ()->
            compare (
               theSortElPtr1->myTlObj (),
               theSortElPtr2->myTlObj ());
d239 20
d278 2
a279 1
      void WitDenseList <Elem>::sort (WitCompareFunc theCompFunc)
d281 1
a281 7
   WitSortRule <Elem> * theSortRule;

   theSortRule = new WitSortRule <Elem> (theCompFunc);

   sortAbs (theSortRule);

   delete theSortRule;
d311 15
a325 1
// Implementation of class AbsSortRule.
d328 4
a331 1
WitAbsSortRule::WitAbsSortRule ()
d337 2
a338 1
WitAbsSortRule::~WitAbsSortRule ()
d343 1
a343 1
// Implementation of Class Template SortRule <Elem>
d346 6
a351 2
template <typename Elem> 
      WitSortRule <Elem>::WitSortRule (WitCompareFunc theCompFunc):
d353 2
a354 1
      myCompareFunc_ (theCompFunc)
a355 1
   witAssert (theCompFunc != NULL);
d360 2
a361 2
template <typename Elem> 
      WitSortRule <Elem>::~WitSortRule ()
d367 18
a384 4
template <typename Elem> 
      int WitSortRule <Elem>::compare (
         WitTlObj * theTlObj1,
         WitTlObj * theTlObj2)
d386 10
a395 4
   return
      myCompareFunc_ (
         fromTlObj_cast <Elem> (theTlObj1),
         fromTlObj_cast <Elem> (theTlObj2));
d399 13
a411 1
// Implementation of class SortEl.
d414 1
a414 1
WitSortEl::WitSortEl ():
d416 2
a417 2
      myTlObj_       (NULL),
      myAbsSortRule_ (NULL)
d423 1
a423 1
WitSortEl::~WitSortEl ()
d429 3
a431 3
void WitSortEl::setData (
      WitTlObj *       theTlObj,
      WitAbsSortRule * theAbsSortRule)
d433 2
a434 2
   myTlObj_       = theTlObj;
   myAbsSortRule_ = theAbsSortRule;
@


1.40
log
@[multi-thread]
@
text
@d17 1
a17 1
//    Class Template DenseList <TheType>, with explicit instantiation.
d19 5
a23 2
//    Class Template TVec   <TheType>, with explicit instantiation.
//    Class Template Vector <TheType>, with explicit instantiation.
a116 4
const WitAbsDenseList * WitAbsDenseList::curAbsDenseList_ = NULL;

//------------------------------------------------------------------------------

d176 1
a176 1
void WitAbsDenseList::sortAbs ()
d178 2
a179 2
   if (isEmpty ())
      return;
d181 1
a181 1
   stronglyAssert (curAbsDenseList_ == NULL);
d183 2
a184 1
   curAbsDenseList_ = this;
d187 1
a187 1
      myVector_.myCVecForUpdate (),
d189 5
a193 2
      sizeof (WitTlObj *),
      qsortCompFunc);
d195 1
a195 1
   curAbsDenseList_ = NULL;
d200 1
a200 1
int WitAbsDenseList::qsortCompFunc (
d204 15
a218 3
   witAssert (curAbsDenseList_ != NULL);

   return curAbsDenseList_->compare (elemPtr1, elemPtr2);
d225 1
a225 1
template <typename TheType> 
d227 2
a228 2
         WitDenseList <TheType>  & theDenseList,
         const WitList <TheType> & theList)
d230 1
a230 1
   TheType * theObject;
d239 1
a239 1
// Implementation of Class Template DenseList <TheType>
d242 5
a246 3
template <typename TheType> 
      typename WitDenseList <TheType>::WitCompareFunc
      WitDenseList <TheType>::curCompFunc_ = NULL;
d250 2
a251 2
template <typename TheType> 
      void WitDenseList <TheType>::sort (WitCompareFunc theCompFunc)
a252 8
   stronglyAssert (curCompFunc_  == NULL);
   stronglyAssert (theCompFunc  != NULL);

   curCompFunc_ = theCompFunc;

   sortAbs ();

   curCompFunc_ = NULL;
d257 2
a258 5
template <typename TheType> 
      int WitDenseList <TheType>::compare (
         const void * elemPtr1, 
         const void * elemPtr2) 
         const
d260 1
a260 2
   TheType * elem1;
   TheType * elem2;
d262 1
a262 1
   witAssert (curCompFunc_ != NULL);
d264 1
a264 2
   elem1 = * static_cast <TheType * const *> (elemPtr1);
   elem2 = * static_cast <TheType * const *> (elemPtr2);
d266 1
a266 1
   return curCompFunc_ (elem1, elem2);
d270 1
a270 1
// Explicit instantiation of Class Template DenseList <TheType>
d296 74
a369 1
// Implementation of class template TVec <TheType>
d372 3
a374 3
template <typename TheType> 
      WitTVec <TheType>::WitTVec ():
         WitVector <TheType> ()
d380 3
a382 3
template <typename TheType> 
      WitTVec <TheType>::WitTVec (WitProblem * theProblem, TheType initValue):
         WitVector <TheType> ()
d389 2
a390 2
template <typename TheType> 
      WitTVec <TheType>::~WitTVec ()
d396 3
a398 3
template <typename TheType>
      void WitTVec <TheType>::operator = (
         const WitFlexVec <TheType> & theFlexVec)
d405 2
a406 4
template <typename TheType> 
      void WitTVec <TheType>::allocate (
         WitProblem * theProblem,
         TheType      theScalar)
d412 1
a412 1
// Explicit instantiation of class template TVec <TheType>
d421 1
a421 1
// Implementation of class template Vector <TheType>
d424 2
a425 2
template <typename TheType> 
      WitVector <TheType>::WitVector ():
d433 2
a434 2
template <typename TheType> 
      WitVector <TheType>::WitVector (size_t nElems, TheType initValue):
d443 2
a444 2
template <typename TheType> 
      WitVector <TheType>::~WitVector ()
d451 2
a452 2
template <typename TheType> 
      void WitVector <TheType>::operator = (const WitVector & theVector)
d461 2
a462 2
template <typename TheType> 
      void WitVector <TheType>::operator = (TheType theScalar)
d472 2
a473 2
template <typename TheType> 
      void WitVector <TheType>::operator = (const TheType * theCVec)
d480 2
a481 2
template <typename TheType> 
      void WitVector <TheType>::copyInto (TheType * theCVec) const
d488 2
a489 2
template <typename TheType> 
      void WitVector <TheType>::clear ()
d496 2
a497 2
template <typename TheType> 
      void WitVector <TheType>::resize (size_t nElems, TheType theScalar)
d506 2
a507 2
template <typename TheType> 
       void WitVector <TheType>::resize (size_t nElems)
d511 1
a511 1
   myCVec_ = new TheType[nElems];
d517 2
a518 2
template <typename TheType> 
      bool WitVector <TheType>::operator == (TheType theScalar) const
d531 2
a532 2
template <typename TheType> 
      void WitVector <TheType>::checkBounds (int theIdx) const
d544 1
a544 1
// Explicit instantiation of class template Vector <TheType>
d572 1
a572 1
template <typename TheType> 
d574 3
a576 3
         TheType *       dstCVec, 
         const TheType * srcCVec, 
         int             nElems)
d600 2
a601 2
template <typename TheType> 
      bool WitNonClass::hasSingleValue (const TheType * theCVec, int nElems)
d603 2
a604 2
   TheType valAt0;
   int     theIdx;
@


1.39
log
@Pegged Critical List.
@
text
@d460 1
a460 1
      curMsgFac () ("negativeIndexFmsg", theIdx);
d463 1
a463 1
      curMsgFac () ("indexTooLargeFmsg",
@


1.38
log
@PIP.
@
text
@d29 2
a31 1
#include <Global.h>
d98 13
@


1.37
log
@Double Precision.
@
text
@d19 1
d28 1
a29 5

//------------------------------------------------------------------------------
// Implementation of TVecUtil functions.
//------------------------------------------------------------------------------

a31 5
int WitTVecUtil::nPeriodsForTVec (WitProblem * theProblem)
   {
   return theProblem->nPeriods ();
   }

d278 54
d532 6
a537 4
template bool WitNonClass::hasSingleValue <bool>   (const bool *,   int);
template bool WitNonClass::hasSingleValue <int>    (const int *,    int);
template bool WitNonClass::hasSingleValue <float>  (const float *,  int);
template bool WitNonClass::hasSingleValue <double> (const double *, int);
@


1.36
log
@Double Precision.
@
text
@a413 1
template class WitVector <float>;
a422 15
      const WitVector <float> & theVector,
      float                     theScalar)
   {
   int theIdx;

   for (theIdx = 0; theIdx < theVector.length (); theIdx ++)
      if (theVector[theIdx] < theScalar)
         return false;

   return true;
   }

//------------------------------------------------------------------------------

bool WitNonClass::operator >= (
a436 116
void WitNonClass::copy (
      WitVector <double> &      theDblVec,
      const WitVector <float> & theFltVec)
   {
   witAssert (theDblVec.length () == theFltVec.length ());

   copy (
      theDblVec.myCVecForUpdate (),
      theFltVec.myCVec (),
      theDblVec.length ());
   }

//------------------------------------------------------------------------------

void WitNonClass::copy (
      WitVector <double> & theDblVec,
      const float *        theFltCVec)
   {
   witAssert (theFltCVec != NULL);

   copy (
      theDblVec.myCVecForUpdate (), 
      theFltCVec, 
      theDblVec.length ());
   }

//------------------------------------------------------------------------------

void WitNonClass::copy (
      double *                  theDblCVec,
      const WitVector <float> & theFltVec)
   {
   witAssert (theDblCVec != NULL);

   copy (
      theDblCVec,
      theFltVec.myCVec (),
      theFltVec.length ());
   }

//------------------------------------------------------------------------------

void WitNonClass::copy (
      WitVector <float> &        theFltVec,
      const WitVector <double> & theDblVec)
   {
   witAssert (theFltVec.length () == theDblVec.length ());

   copy (
      theFltVec.myCVecForUpdate (),
      theDblVec.myCVec (),
      theFltVec.length ());
   }

//------------------------------------------------------------------------------

void WitNonClass::copy (
      WitVector <float> & theFltVec,
      const double *      theDblCVec)
   {
   witAssert (theDblCVec != NULL);

   copy (
      theFltVec.myCVecForUpdate (),
      theDblCVec,
      theFltVec.length ());
   }

//------------------------------------------------------------------------------

void WitNonClass::copy (
      float *                    theFltCVec,
      const WitVector <double> & theDblVec)
   {
   witAssert (theFltCVec != NULL);

   copy (
      theFltCVec,
      theDblVec.myCVec (),
      theDblVec.length ());
   }

//------------------------------------------------------------------------------

void WitNonClass::copy (
      double *      theDblCVec,
      const float * theFltCVec,
      int           length)
   {
   int theIdx;

   witAssert (theDblCVec != NULL);
   witAssert (theFltCVec != NULL);

   for (theIdx = 0; theIdx < length; theIdx ++)
      theDblCVec[theIdx] = dblFromFlt (theFltCVec[theIdx]);
   }

//------------------------------------------------------------------------------

void WitNonClass::copy (
      float *        theFltCVec,
      const double * theDblCVec,
      int            length)
   {
   int theIdx;

   witAssert (theFltCVec != NULL);
   witAssert (theDblCVec != NULL);

   for (theIdx = 0; theIdx < length; theIdx ++)
      theFltCVec[theIdx] = fltFromDbl (theDblCVec[theIdx]);
   }

//------------------------------------------------------------------------------

a457 1
template void WitNonClass::copy <float>  (float *,  const float *,  int);
@


1.35
log
@Double Precision.
@
text
@d321 1
a321 1
   WitNonClass::copy (myCVec_, theVector.myCVec_, length_);
d340 1
a340 1
   WitNonClass::copy (myCVec_, theCVec, length_);
d348 1
a348 1
   WitNonClass::copy (theCVec, myCVec_, length_);
@


1.34
log
@Double Precision.
@
text
@d346 1
a346 1
      void WitVector <TheType>::convCopyInto (TheType * theCVec) const
d453 1
a453 1
void WitNonClass::convCopy (
d459 1
a459 1
   convCopy (
d467 1
a467 1
void WitNonClass::convCopy (
d473 1
a473 1
   convCopy (
d481 1
a481 1
void WitNonClass::convCopy (
d487 1
a487 1
   convCopy (
d495 1
a495 1
void WitNonClass::convCopy (
d501 1
a501 1
   convCopy (
d509 1
a509 1
void WitNonClass::convCopy (
d515 1
a515 1
   convCopy (
d523 1
a523 1
void WitNonClass::convCopy (
d529 1
a529 1
   convCopy (
d537 1
a537 1
void WitNonClass::convCopy (
d553 1
a553 1
void WitNonClass::convCopy (
@


1.33
log
@Double Precision.
@
text
@d317 1
a317 1
      void WitVector <TheType>::setToScalar (TheType theValue)
d319 1
a319 1
   int theIdx;
d321 2
a322 3
   for (theIdx = 0; theIdx < length_; theIdx ++)
      myCVec_[theIdx] = theValue;
   }  
d327 1
a327 1
      void WitVector <TheType>::operator = (const WitVector & theVector)
d329 1
a329 1
   witAssert (length_ == theVector.length_);
d331 3
a333 2
   WitNonClass::copy (myCVec_, theVector.myCVec_, length_);
   }
d338 1
a338 1
      void WitVector <TheType>::convCopy (const TheType * theCVec)
d362 1
a362 1
      void WitVector <TheType>::resize (size_t nElems, TheType theValue)
d366 1
a366 1
   setToScalar (theValue);
d383 1
a383 1
      bool WitVector <TheType>::operator == (TheType theValue) const
d388 1
a388 1
      if (myCVec_[theIdx] != theValue)
d425 1
a425 1
      float                     theValue)
d430 1
a430 1
      if (theVector[theIdx] < theValue)
d440 1
a440 1
      double                     theValue)
d445 1
a445 1
      if (theVector[theIdx] < theValue)
@


1.32
log
@Double Precision.
@
text
@d90 1
a90 1
void WitString::copy (const WitString & theString)
d328 1
a328 1
      void WitVector <TheType>::copy (const WitVector & theVector)
@


1.31
log
@Double Precision.
@
text
@d585 12
@


1.30
log
@Double Precision.
@
text
@d332 1
a332 1
   copyCVecIntoCVec (myCVec_, theVector.myCVec_);
d340 1
a340 1
   copyCVecIntoCVec (myCVec_, theCVec);
d348 1
a348 1
   copyCVecIntoCVec (theCVec, myCVec_);
a396 17
      void WitVector <TheType>::copyCVecIntoCVec (
               TheType * dstCVec, 
         const TheType * srcCVec)
         const
   {
   int theIdx;

   witAssert (dstCVec != NULL);
   witAssert (srcCVec != NULL);

   for (theIdx = 0; theIdx < length_; theIdx ++)
      dstCVec[theIdx] = srcCVec[theIdx];
   }

//------------------------------------------------------------------------------

template <typename TheType> 
d419 2
a420 2
// Implementation of NonClass functions with arguments belonging to specific
//    Vector classes.
d471 2
d485 2
d513 2
d527 2
d544 3
d560 3
d566 45
@


1.29
log
@Double Precision.
@
text
@d319 1
a319 1
   size_t theIdx;
d385 1
a385 1
   size_t theIdx;
d402 1
a402 1
   size_t theIdx;
d444 1
a444 1
   size_t i;
d446 2
a447 2
   for (i = 0; i < theVector.length (); ++i)
      if (theVector[i] < theValue)
d459 1
a459 1
   size_t i;
d461 2
a462 2
   for (i = 0; i < theVector.length (); ++i)
      if (theVector[i] < theValue)
d470 17
a486 1
void WitNonClass::convCopy (WitVector <double> & dstVec, const float * srcCVec)
d488 7
a494 1
   size_t i;
d496 8
a503 2
   for (i = 0; i < dstVec.length (); ++ i)
      dstVec[i] = srcCVec[i];
d509 2
a510 2
      WitVector <double> &      dstVec,
      const WitVector <float> & srcVec)
d512 1
a512 1
   witAssert (dstVec.length () == srcVec.length ());
d514 4
a517 1
   convCopy (dstVec, srcVec.myCVec ());
d523 2
a524 2
      WitVector <float> &        dstVec,
      const WitVector <double> & srcVec)
d526 7
a532 1
   witAssert (dstVec.length () == srcVec.length ());
d534 31
a564 1
   size_t i;
d566 2
a567 2
   for (i = 0; i < dstVec.length (); ++ i)
      dstVec[i] = srcVec[i];
@


1.28
log
@Double Precision.
@
text
@d33 2
d417 1
a417 1
      WitMsgFacility::current () ("negativeIndexFmsg", theIdx);
d420 1
a420 1
      WitMsgFacility::current () ("indexTooLargeFmsg",
@


1.27
log
@Double Precision.
@
text
@d19 1
d284 1
a284 1
// Implementation of VectorUtil functions.
d287 126
a412 1
void WitVectorUtil::checkBounds (int theIdx, size_t lengthVal)
d417 1
a417 1
   if (theIdx >= lengthVal)
d420 1
a420 1
         lengthVal - 1);
d424 10
d453 15
a498 15
   }

//------------------------------------------------------------------------------

bool WitNonClass::operator >= (
      const WitVector <double> & theVector,
      double                     theValue)
   {
   size_t i;

   for (i = 0; i < theVector.length (); ++i)
      if (theVector[i] < theValue)
         return false;

   return true;
@


1.26
log
@Double Precision.
@
text
@d317 1
a317 1
void WitNonClass::copyInto (WitVector <double> & dstVec, const float * srcCVec)
d327 1
a327 1
void WitNonClass::copyInto (
d333 1
a333 1
   copyInto (dstVec, srcVec.myCVec ());
d338 1
a338 1
void WitNonClass::copyInto (
@


1.25
log
@Continued implementation of PIP.
@
text
@d178 1
a178 1
      myVector_.myCvectorForUpdate (),
d333 1
a333 1
   copyInto (dstVec, srcVec.myCvector ());
@


1.24
log
@Continued implementation of PIP.
@
text
@d265 1
a265 1
template class WitDenseList <WitDatedPart>;
@


1.23
log
@Continued implementation of PIP.
@
text
@d29 1
a29 1
// Implementation of namespace TVecUtil
d283 1
a283 1
// Implementation of namespace VectorUtil.
@


1.22
log
@Continued implementation of PIP.
@
text
@d198 1
a198 1
// Implementation of NonClass function template copyIntoD (DenseList, List).
d202 1
a202 1
      void WitNonClass::copyIntoD (
d269 1
a269 1
// Explicit instantiation of NonClass function template copyIntoD.
d273 1
a273 1
   void WitNonClass::copyIntoD <WitSubEntry> (
d278 1
a278 1
   void WitNonClass::copyIntoD <WitBopEntry> (
@


1.21
log
@Continued implementation of PIP.
@
text
@d198 1
a198 1
// Implementation of NonClass function template copyInto (DenseList, List).
d202 1
a202 1
      void WitNonClass::copyInto (
d269 1
a269 1
// Explicit instantiation of NonClass function template copyInto.
d273 1
a273 1
   void WitNonClass::copyInto <WitSubEntry> (
d278 1
a278 1
   void WitNonClass::copyInto <WitBopEntry> (
@


1.20
log
@Continued implementation of post-implosion pegging.
@
text
@d17 3
a19 2
//    Global functions used by class template Vector <TheType>.
//    Global functions with arguments belonging to specific Vector classes.
d24 1
d29 2
d32 1
a32 1
int nPeriodsForTVec (WitProblem * theProblem)
d198 86
a283 1
// Implementation of global functions used by class template Vector <TheType>.
d286 1
a286 1
void witCheckBoundsForVector (int theIdx, size_t lengthVal)
d292 3
a294 1
      WitMsgFacility::current () ("indexTooLargeFmsg", theIdx, lengthVal - 1);
d298 1
a298 1
// Implementation of global functions with arguments belonging to specific
d302 3
a304 1
bool operator >= (const WitVector <float> & theVector, float theValue)
d317 1
a317 1
void copyInto (WitVector <double> & dstVec, const float * srcCVec)
d327 3
a329 1
void copyInto (WitVector <double> & dstVec, const WitVector <float> & srcVec)
d338 3
a340 1
void copyInto (WitVector <float> & dstVec, const WitVector <double> & srcVec)
d352 3
a354 1
bool operator >= (const WitVector <double> & theVector, double theValue)
@


1.19
log
@Changed some C style casts to C++ style.
@
text
@d18 1
a18 2
//    Global functions with arguments belonging to specific Vector  classes.
//    Global functions with arguments belonging to specific FlexVec classes.
a20 1
#include <FlexVecI.h>
a263 85
   }

//------------------------------------------------------------------------------
// Implementation of global functions with arguments belonging to specific
//    FlexVec classes.
//------------------------------------------------------------------------------

void copyInto (
      WitTVec <double> &         theDoubleTVec,
      const WitFlexVec <float> & theFloatFlexVec)
   {
   witAssert (theDoubleTVec.length () == theFloatFlexVec.length ());

   if (theFloatFlexVec.repIsByVec ())
      copyInto (theDoubleTVec, theFloatFlexVec.myVecRep ());
   else
      theDoubleTVec.setToScalar (theFloatFlexVec.myScalRep ());
   }

//------------------------------------------------------------------------------

void copyInto (
      WitFlexVec <float> &     theFloatFlexVec,
      const WitTVec <double> & theDoubleTVec)
   {
   witAssert (theFloatFlexVec.length () == theDoubleTVec.length ());

   if (theDoubleTVec == theDoubleTVec[0])
      theFloatFlexVec.setToScalar (theDoubleTVec[0]);
   else
      copyInto (theFloatFlexVec.myRepMadeVec (), theDoubleTVec);
   }

//------------------------------------------------------------------------------

void copyInto (
      WitFlexVec <float> &        theFloatFlexVec,
      const WitFlexVec <double> & theDoubleFlexVec)
   {
   witAssert (theFloatFlexVec.length () == theDoubleFlexVec.length ());

   if (theDoubleFlexVec.repIsByVec ())
      copyInto (theFloatFlexVec.myRepMadeVec (), theDoubleFlexVec.myVecRep ());
   else
      theFloatFlexVec.myRepMadeScal () = theDoubleFlexVec.myScalRep ();
   }

//------------------------------------------------------------------------------

void copyInto (
      WitTVec <float> &           theFloatTVec,
      const WitFlexVec <double> & theDoubleFlexVec)
   {
   witAssert (theFloatTVec.length () == theDoubleFlexVec.length ());

   if (theDoubleFlexVec.repIsByVec ())
      copyInto (theFloatTVec, theDoubleFlexVec.myVecRep ());
   else 
      theFloatTVec.setToScalar (theDoubleFlexVec.myScalRep ());
   }

//------------------------------------------------------------------------------

void copyInto (
      float *                     theFloatCvector,
      const WitFlexVec <double> & theDoubleFlexVec)
   {
   WitPeriod thePer;

   witAssert (theFloatCvector != NULL);

   forEachPeriod (thePer, theDoubleFlexVec.myProblem ())
      theFloatCvector[thePer] = theDoubleFlexVec[thePer];
   }

//------------------------------------------------------------------------------

void copyInto (
      WitFlexVec <double> & theDoubleFlexVec,
      const float *         theFloatCvector)
   {
   if (hasSingleValue (theFloatCvector, theDoubleFlexVec.myProblem ()))
      theDoubleFlexVec.myRepMadeScal () = theFloatCvector[0];
   else
      copyInto (theDoubleFlexVec.myRepMadeVec (), theFloatCvector);
@


1.18
log
@Replaced some C-style casts with C++ style casts.
@
text
@d96 1
a96 1
   (* this)[(int) nChars] = '\0';
d127 1
a127 1
   myVector_[(int) nElements_] = theObject;
d150 1
a150 1
   if (theIndex < (int) nElements_)
@


1.17
log
@Internal changes.
@
text
@d121 1
a121 1
WitTlObj * WitAbsDenseList::appendAbs (WitTlObj * theObject)
a129 2

   return theObject;
@


1.16
log
@modications to change rogueWave tools.h++ to STL
@
text
@d69 1
a69 1
WitBoolean WitString::operator == (const char * theCstring) const
d145 1
a145 1
WitBoolean WitAbsDenseList::advanceAbs (
d156 1
a156 1
      return witTRUE;
d162 1
a162 1
      return witFALSE;
d215 1
a215 1
WitBoolean operator >= (const WitVector <float> & theVector, float theValue)
d221 1
a221 1
         return witFALSE;
d223 1
a223 1
   return witTRUE;
d259 1
a259 1
WitBoolean operator >= (const WitVector <double> & theVector, double theValue)
d265 1
a265 1
         return witFALSE;
d267 1
a267 1
   return witTRUE;
@


1.15
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d217 1
a217 1
   int i;
d230 1
a230 1
   int i;
d251 1
a251 1
   int i;
d261 1
a261 1
   int i;
@


1.15.2.1
log
@Migration from Roguewave tools.h++ to STL
@
text
@d217 1
a217 1
   size_t i;
d230 1
a230 1
   size_t i;
d251 1
a251 1
   size_t i;
d261 1
a261 1
   size_t i;
@


1.14
log
@Minor change.
@
text
@d22 1
a22 1
#include <Problem.h>
d25 1
a25 1
#include <FlexVec.h>
@


1.13
log
@Preliminary work on single source.
@
text
@d69 7
@


1.12
log
@Preliminary work on single source.
@
text
@d42 1
a42 1
   (* this) = "";
d50 1
a50 9
   (* this) = theCstring;
   }

//------------------------------------------------------------------------------

WitString::WitString (const WitString & theString):
      myVector_ ()
   {
   (* this) = theString;
d69 1
a69 1
void WitString::operator = (const char * theCstring)
d78 1
a78 1
void WitString::operator = (const WitString & theString)
d80 1
a80 1
   (* this) = theString.myCstring ();
@


1.11
log
@Continued preliminary work on single source.
@
text
@d12 2
d15 5
a19 4
// Contains the implementation of the following classes:
//
//    String
//    AbsDenseList
d25 1
d212 2
a213 2
// Implementation of global functions that use specific Vector <TheType> 
// classes.
d269 85
@


1.10
log
@Continued preliminary work on single source.
@
text
@d25 7
@


1.9
log
@Continued preliminary work on single source.
@
text
@d93 1
a93 1
WitTlObj * WitAbsDenseList::compareFuncForSort_ = NULL;
d158 1
a158 3
void WitAbsDenseList::sortAbs (
      WitTlObj *             theCompareFunc,
      WitQsortCompareFunc    theQsortCompareFunc)
a159 3
   witAssert (compareFuncForSort_ == NULL);
   witAssert (theCompareFunc      != NULL);

d163 3
a165 1
   compareFuncForSort_ = theCompareFunc;
d171 12
a182 1
      theQsortCompareFunc);
d184 1
a184 1
   compareFuncForSort_ = NULL;
@


1.8
log
@More preliminary work on single source.
@
text
@a14 1
//    TVec (TheType)
a24 35
// Implementation macro for generic class TVec (TheType)
//------------------------------------------------------------------------------

#define WitTVecimplement(TheType)                                              \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitTVec (TheType)::WitTVec (TheType) (): WitVector <TheType> ()                \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitTVec (TheType)::WitTVec (TheType) (                                         \
         WitProblem * theProblem,                                              \
         TheType      initValue):                                              \
                                                                               \
      WitVector <TheType> (theProblem->nPeriods (), initValue)                 \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitTVec (TheType)::~WitTVec (TheType) ()                                       \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitTVec (TheType)::allocate (WitProblem * theProblem, TheType initValue)  \
   {                                                                           \
   WitVector <TheType>::resize (theProblem->nPeriods (), initValue);           \
   }                                                                           \
                                                                               \
//------------------------------------------------------------------------------
a250 11

//------------------------------------------------------------------------------
// Implementations of all specific cases of the generic classes and functions
// declared in this file.
//------------------------------------------------------------------------------

implement (WitTVec, int)
implement (WitTVec, float)
implement (WitTVec, double)
implement (WitTVec, WitTlObjPtr)

@


1.7
log
@Preliminary work on single source.
@
text
@a17 1
//    DenseList (TheType)
a215 105
// Macro witCompareDenseListEls(TheType)
//
// Used as the parameterized name of a generic global function used by
// DenseList (TheType).
//------------------------------------------------------------------------------

#define witCompareDenseListEls(TheType)                                        \
                                                                               \
   name2 (witCompareDenseListEls, TheType)                                     \

//------------------------------------------------------------------------------
// Implementation macro for generic class WitDenseList (TheType).
//------------------------------------------------------------------------------

#define WitDenseListimplement(TheType)                                         \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Implementation of class DenseList (TheType).                              */\
/*---------------------------------------------------------------------------*/\
                                                                               \
extern "C" int witCompareDenseListEls(TheType) (                               \
      const void * pElement1,                                                  \
      const void * pElement2)                                                  \
   {                                                                           \
   WitCompareFunc(TheType) compare =                                           \
      (WitCompareFunc(TheType)) WitDenseList (TheType)::compareFuncForSort (); \
                                                                               \
   TheType * element1 = * (TheType * const *) pElement1;                       \
   TheType * element2 = * (TheType * const *) pElement2;                       \
                                                                               \
   return compare (element1, element2);                                        \
   }                                                                           \
   /*                                                                        */\
   /* This is the compare function passed from DenseList (TheType)::sort to  */\
   /* WitAbsDenseList::sort to qsort. It is a wrapper around                 */\
   /* WitAbsDenseList::compareFuncForSort_, which is the compare             */\
   /* function that was passed from the client to DenseList (TheType)::sort. */\
   /* Thus when qsort calls this function, the client's compare function is  */\
   /* called. The purpose of this wrapper function is simply to cast the     */\
   /* relevant void *'s to the appropriate type. The extern "C" linkage and  */\
   /* declaration as a global function are necessary on C Set/2.             */\
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitDenseList (TheType)::WitDenseList (TheType) (size_t maxNElements):          \
      WitAbsDenseList (maxNElements)                                           \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitDenseList (TheType)::~WitDenseList (TheType) ()                             \
   {                                                                           \
   }                                                                           \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
void WitDenseList (TheType)::sort (WitCompareFunc(TheType) theFunc)            \
   {                                                                           \
   sortAbs ((WitTlObj *) theFunc, witCompareDenseListEls(TheType));            \
   }                                                                           \

//------------------------------------------------------------------------------
                                                                               
#define copyIntoDenseListFromListimplement(TheType)                            \
                                                                               \
void copyInto (                                                                \
      WitDenseList (TheType)  & theDenseList,                                  \
      const WitList <TheType> & theList)                                       \
   {                                                                           \
   TheType * theObject;                                                        \
                                                                               \
   theDenseList.clear ();                                                      \
                                                                               \
   forEachEl (theObject, theList)                                              \
      theDenseList.append (theObject);                                         \
   }                                                                           \

//------------------------------------------------------------------------------
// Implementations of all specific cases of the generic classes and functions
// declared in this file.
//------------------------------------------------------------------------------

implement (WitTVec,                   int)
implement (WitTVec,                   float)
implement (WitTVec,                   double)
implement (WitTVec,                   WitTlObjPtr)

implement (WitDenseList,              WitComponent)
implement (WitDenseList,              WitNode)
implement (WitDenseList,              WitPart)
implement (WitDenseList,              WitMaterial)
implement (WitDenseList,              WitOperation)
implement (WitDenseList,              WitSubEntry)
implement (WitDenseList,              WitBopEntry)
implement (WitDenseList,              WitDemand)
implement (WitDenseList,              WitDatedPart)
implement (WitDenseList,              WitCoeff)

implement (copyIntoDenseListFromList, WitBopEntry)
implement (copyIntoDenseListFromList, WitOperation)
implement (copyIntoDenseListFromList, WitPart)
implement (copyIntoDenseListFromList, WitSubEntry)

//------------------------------------------------------------------------------
d287 10
@


1.6
log
@Preliminary work on single source.
@
text
@d24 1
d34 1
a34 1
WitTVec (TheType)::WitTVec (TheType) (): WitVector (TheType) ()                \
d44 1
a44 1
      WitVector (TheType) (theProblem->nPeriods (), initValue)                 \
d58 1
a58 1
   WitVector (TheType)::resize (theProblem->nPeriods (), initValue);           \
d321 38
d360 33
@


1.5
log
@Began implementation of object iteration.
@
text
@d284 1
a284 1
      const WitList (TheType) & theList)                                       \
@


1.4
log
@Minor change.
@
text
@d22 1
@


1.3
log
@Corrected a file inclusion error in non-OPT_IMPLODE (i.e., 64-bit) mode.
@
text
@a23 6
#ifdef OPT_IMPLODE

#  include <ImpLp.h>

#endif

d312 1
a319 5
#ifdef OPT_IMPLODE

implement (WitDenseList, WitCoeff)

#endif
@


1.2
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d22 1
@


1.1
log
@Implemented and used class SelMgr.
@
text
@d133 1
a133 1
WitTl * WitAbsDenseList::compareFuncForSort_ = NULL;
d151 1
a151 1
WitTl * WitAbsDenseList::appendAbs (WitTl * theObject)
d176 2
a177 2
      int &     theIndex, 
      WitTl * & theElement) 
d199 2
a200 2
      WitTl *             theCompareFunc,
      WitQsortCompareFunc theQsortCompareFunc)
d213 1
a213 1
      sizeof (WitTl *),
d279 1
a279 1
   sortAbs ((WitTl *) theFunc, witCompareDenseListEls(TheType));               \
d306 1
a306 1
implement (WitTVec,                   WitTlPtr)
@


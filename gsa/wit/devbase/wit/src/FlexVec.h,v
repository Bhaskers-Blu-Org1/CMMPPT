head	1.57;
access;
symbols
	sce_5_01_20080919:1.53
	latest_sce_4_20_20060523:1.48.0.2
	sce_4_20_20060523:1.48
	latest_sce4_20_OSL:1.47.0.2
	sce_4_20_OSL:1.47
	sce_410_withVa:1.47
	sce_4_05_20040511:1.39
	sce_4_00_20040201:1.20
	nextGenBranch:1.15.0.2
	nextGenRoot:1.15
	sce_3_30_20030627:1.15
	EndRw-branch:1.12.0.4
	Root-of-EndRw:1.12
	rwToStl:1.12.0.2
	latest_sce_3_10_20010924:1.7.0.6
	sce_3_10_20010924:1.7
	latest_sce_3_00_20010601:1.7.0.4
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.7.0.2
	sce_2_31_20010308:1.7
	latest_sce_2_31_20001003:1.5.0.2
	sce_2_31_20001003:1.5
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2011.09.28.23.49.22;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2011.09.24.00.27.42;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2011.08.30.20.17.31;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2009.12.23.22.39.54;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.27.19.59.31;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.08.22.47.34;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.07.17.30.32;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.01.16.31.02;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.31.21.58.01;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.02.17.33.58;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.09.06.19.47.58;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.22.20.38.59;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.02.23.17.53;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.24.23.23.55;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.20.19.06.05;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.20.15.08.54;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.18.00.35.39;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.04.16.30.13;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.30.23.27.43;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.19.22.16.28;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.29.19.58.27;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.24.22.21.30;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.24.20.17.02;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.24.19.17.33;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.22.23.16.37;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.20.00.12.11;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.19.22.00.53;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.16.23.29.49;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.16.22.39.28;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.05.00.06.54;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.04.16.44.29;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.02.23.52.13;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.13.00.17.51;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.11.18.37.26;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.09.22.44.05;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.25.23.49.55;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.25.22.58.26;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.15.21.01.19;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.13.22.22.08;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.02.22.18.26;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.11.18.53.07;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.10.18.02.10;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.08.19.21.50;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.03.23.16.38;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.02.20.53.11;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.22.23.11.40;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.21.20.03.22;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.25.20.12.31;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.29.21.22.43;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.18.00.15.59;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.48;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.21;	author wit;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef FlexVecH
#define FlexVecH

//------------------------------------------------------------------------------
// Header file: "FlexVec.h"
//
// Contains the declaration of class template FlexVec <Elem>.
// Contains the declaration of class          DblFlexVec.
//------------------------------------------------------------------------------

#include <FlexVAsst.h>

//------------------------------------------------------------------------------
// Class template FlexVec <Elem>
//
// "Flexible Vector"
// A vector whose representation changes dynamically between a scalar
// representation and a vector representation.
// The length of the represented vector is nPeriods for the corresponding
// Problem.
//------------------------------------------------------------------------------

template <typename Elem> 
      class WitFlexVec
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions
      //------------------------------------------------------------------------

      WitFlexVec (WitProblem *, Elem initValue);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitFlexVec ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void operator = (const WitFlexVec &);
      void operator = (Elem);
      void operator = (const WitTVec <Elem> &);
      void operator = (const Elem *);
         //
         // Assignment operators.

      void copyInto (WitTVec <Elem> &) const;
      void copyInto (Elem *)           const;
         //
         // Each of these functions copies the elements of this FlexVec
         // into the corresponding elements of the argument vector.

      inline Elem operator [] (WitPeriod thePer) const;
         //
         // Returns the value of the element of the represented vector indexed
         // by thePer.

      inline Elem & elemRef (int theIndex);
         //
         // Same as [], but returns a reference.

      bool operator == (Elem) const;
      bool operator != (Elem) const;
      bool operator >= (Elem) const;

      accessWrapper (int,          nPeriods,  curAsst_)
      accessWrapper (WitProblem *, myProblem, curAsst_)

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      accessWrapper (bool, vectorMode, curAsst_)
      accessWrapper (bool, scalarMode, curAsst_)

      inline void beInVectorMode ()
         {
         if (scalarMode ())
            switchToVectorMode ();
         }

      inline void beInScalarMode ()
         {
         if (vectorMode ())
            switchToScalarMode ();
         }

      inline Elem * myCVec () const
         {
         witAssert (vectorMode ());

         return myCVecFromUnion_;
         }

      inline Elem & myScalar ()
         {
         witAssert (scalarMode ());

         return myScalarFromUnion_;
         }

      inline Elem myScalar () const
         {
         witAssert (scalarMode ());

         return myScalarFromUnion_;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtor (WitFlexVec);

      void checkBounds (WitPeriod thePer) const;
         //
         // Verifies that thePer is in [0, nPeriods ()).

      void switchToVectorMode ();
         //
         // Valid only in scalar mode.
         // Switches to   vector mode.

      void switchToScalarMode ();
         //
         // Valid only in vector mode.
         // Switches to   scalar mode.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitFlexVAsst * curAsst_;
         //
         // The current FlexVAsst for this FlexVec.

      union
         {
         Elem * myCVecFromUnion_;
            //
            // The c-vector representation of the vector.
            // Valid only in vector mode.

         Elem myScalarFromUnion_;
            //
            // The scalar representation of the vector.
            // Valid only in scalar mode.
         };
   };

//------------------------------------------------------------------------------
// Implementation of inlines.
//------------------------------------------------------------------------------

template <typename Elem> 
      inline Elem WitFlexVec <Elem>::operator [] (WitPeriod thePer) const
   {
   ifDebug (checkBounds (thePer));

   return
      curAsst_->vectorMode ()?
         myCVec   ()[thePer]:
         myScalar ();
   }

//------------------------------------------------------------------------------

template <typename Elem>
      inline Elem & WitFlexVec <Elem>::elemRef (WitPeriod thePer)
   {
   ifDebug (checkBounds (thePer));

   beInVectorMode ();

   return myCVec ()[thePer];
   }

//------------------------------------------------------------------------------
// Class DblFlexVec
//
// "Double Flexible Vector"
//------------------------------------------------------------------------------

class WitDblFlexVec: public WitFlexVec <double>
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions
      //------------------------------------------------------------------------

      WitDblFlexVec (WitProblem *, double initValue);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitDblFlexVec ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void operator = (const WitDblFlexVec &);
      void operator = (double);
      void operator = (const WitTVec <double> &);
      void operator = (const double *);
      void operator = (const float *);
      void operator = (const WitIVRealArg &);
         //
         // Assignment operators.

      void copyInto (double *) const;
      void copyInto (float *)  const;
         //
         // Each of these functions copies the elements of this DblFlexVec
         // into the corresponding elements of the argument vector.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      inline WitFlexVec <double> & thisFlexVec ()
         {
         return (* this);
         }

      inline const WitFlexVec <double> & thisFlexVec () const
         {
         return (* this);
         }

      noCopyCtor (WitDblFlexVec);
   };

//------------------------------------------------------------------------------
// NonClass functions with arguments belonging to specific FlexVec classes.
//------------------------------------------------------------------------------

namespace WitNonClass
   {
   void copy (WitFlexVec <bool> & theFlexVec, const WitBoolean * theCVec);

   void copy (WitBoolean * theCVec, const WitFlexVec <bool> & theFlexVec);
   };

#endif
@


1.56
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.55
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d32 135
a166 135
template <typename Elem>
class WitFlexVec
{
public:

//------------------------------------------------------------------------
// Constructor functions
//------------------------------------------------------------------------

WitFlexVec (WitProblem *, Elem initValue);

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitFlexVec ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void operator = (const WitFlexVec &);
void operator = (Elem);
void operator = (const WitTVec <Elem> &);
void operator = (const Elem *);
//
// Assignment operators.

void copyInto (WitTVec <Elem> &) const;
void copyInto (Elem *)           const;
//
// Each of these functions copies the elements of this FlexVec
// into the corresponding elements of the argument vector.

inline Elem operator [] (WitPeriod thePer) const;
//
// Returns the value of the element of the represented vector indexed
// by thePer.

inline Elem & elemRef (int theIndex);
//
// Same as [], but returns a reference.

bool operator == (Elem) const;
bool operator != (Elem) const;
bool operator >= (Elem) const;

accessWrapper (int,          nPeriods,  curAsst_)
accessWrapper (WitProblem *, myProblem, curAsst_)

protected:

//------------------------------------------------------------------------
// Protected member functions.
//------------------------------------------------------------------------

accessWrapper (bool, vectorMode, curAsst_)
accessWrapper (bool, scalarMode, curAsst_)

inline void beInVectorMode ()
{
if (scalarMode ())
switchToVectorMode ();
}

inline void beInScalarMode ()
{
if (vectorMode ())
switchToScalarMode ();
}

inline Elem * myCVec () const
{
witAssert (vectorMode ());

return myCVecFromUnion_;
}

inline Elem & myScalar ()
{
witAssert (scalarMode ());

return myScalarFromUnion_;
}

inline Elem myScalar () const
{
witAssert (scalarMode ());

return myScalarFromUnion_;
}

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtor (WitFlexVec);

void checkBounds (WitPeriod thePer) const;
//
// Verifies that thePer is in [0, nPeriods ()).

void switchToVectorMode ();
//
// Valid only in scalar mode.
// Switches to   vector mode.

void switchToScalarMode ();
//
// Valid only in vector mode.
// Switches to   scalar mode.

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

WitFlexVAsst * curAsst_;
//
// The current FlexVAsst for this FlexVec.

union
{
Elem * myCVecFromUnion_;
//
// The c-vector representation of the vector.
// Valid only in vector mode.

Elem myScalarFromUnion_;
//
// The scalar representation of the vector.
// Valid only in scalar mode.
};
};
d172 10
a181 10
template <typename Elem>
inline Elem WitFlexVec <Elem>::operator [] (WitPeriod thePer) const
{
ifDebug (checkBounds (thePer));

return
curAsst_->vectorMode ()?
myCVec   ()[thePer]:
myScalar ();
}
d186 3
a188 3
inline Elem & WitFlexVec <Elem>::elemRef (WitPeriod thePer)
{
ifDebug (checkBounds (thePer));
d190 1
a190 1
beInVectorMode ();
d192 2
a193 2
return myCVec ()[thePer];
}
d202 2
a203 35
{
public:

//------------------------------------------------------------------------
// Constructor functions
//------------------------------------------------------------------------

WitDblFlexVec (WitProblem *, double initValue);

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitDblFlexVec ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

void operator = (const WitDblFlexVec &);
void operator = (double);
void operator = (const WitTVec <double> &);
void operator = (const double *);
void operator = (const float *);
void operator = (const WitIVRealArg &);
//
// Assignment operators.

void copyInto (double *) const;
void copyInto (float *)  const;
//
// Each of these functions copies the elements of this DblFlexVec
// into the corresponding elements of the argument vector.

private:
d205 46
a250 13
//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

inline WitFlexVec <double> & thisFlexVec ()
{
return (* this);
}

inline const WitFlexVec <double> & thisFlexVec () const
{
return (* this);
}
d252 2
a253 2
noCopyCtor (WitDblFlexVec);
};
d260 2
a261 2
{
void copy (WitFlexVec <bool> & theFlexVec, const WitBoolean * theCVec);
d263 2
a264 2
void copy (WitBoolean * theCVec, const WitFlexVec <bool> & theFlexVec);
};
@


1.54
log
@Multi-Objective Mode
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d32 135
a166 135
template <typename Elem> 
      class WitFlexVec
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions
      //------------------------------------------------------------------------

      WitFlexVec (WitProblem *, Elem initValue);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitFlexVec ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void operator = (const WitFlexVec &);
      void operator = (Elem);
      void operator = (const WitTVec <Elem> &);
      void operator = (const Elem *);
         //
         // Assignment operators.

      void copyInto (WitTVec <Elem> &) const;
      void copyInto (Elem *)           const;
         //
         // Each of these functions copies the elements of this FlexVec
         // into the corresponding elements of the argument vector.

      inline Elem operator [] (WitPeriod thePer) const;
         //
         // Returns the value of the element of the represented vector indexed
         // by thePer.

      inline Elem & elemRef (int theIndex);
         //
         // Same as [], but returns a reference.

      bool operator == (Elem) const;
      bool operator != (Elem) const;
      bool operator >= (Elem) const;

      accessWrapper (int,          nPeriods,  curAsst_)
      accessWrapper (WitProblem *, myProblem, curAsst_)

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      accessWrapper (bool, vectorMode, curAsst_)
      accessWrapper (bool, scalarMode, curAsst_)

      inline void beInVectorMode ()
         {
         if (scalarMode ())
            switchToVectorMode ();
         }

      inline void beInScalarMode ()
         {
         if (vectorMode ())
            switchToScalarMode ();
         }

      inline Elem * myCVec () const
         {
         witAssert (vectorMode ());

         return myCVecFromUnion_;
         }

      inline Elem & myScalar ()
         {
         witAssert (scalarMode ());

         return myScalarFromUnion_;
         }

      inline Elem myScalar () const
         {
         witAssert (scalarMode ());

         return myScalarFromUnion_;
         }

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtor (WitFlexVec);

      void checkBounds (WitPeriod thePer) const;
         //
         // Verifies that thePer is in [0, nPeriods ()).

      void switchToVectorMode ();
         //
         // Valid only in scalar mode.
         // Switches to   vector mode.

      void switchToScalarMode ();
         //
         // Valid only in vector mode.
         // Switches to   scalar mode.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitFlexVAsst * curAsst_;
         //
         // The current FlexVAsst for this FlexVec.

      union
         {
         Elem * myCVecFromUnion_;
            //
            // The c-vector representation of the vector.
            // Valid only in vector mode.

         Elem myScalarFromUnion_;
            //
            // The scalar representation of the vector.
            // Valid only in scalar mode.
         };
   };
d172 10
a181 10
template <typename Elem> 
      inline Elem WitFlexVec <Elem>::operator [] (WitPeriod thePer) const
   {
   ifDebug (checkBounds (thePer));

   return
      curAsst_->vectorMode ()?
         myCVec   ()[thePer]:
         myScalar ();
   }
d186 3
a188 3
      inline Elem & WitFlexVec <Elem>::elemRef (WitPeriod thePer)
   {
   ifDebug (checkBounds (thePer));
d190 1
a190 1
   beInVectorMode ();
d192 2
a193 2
   return myCVec ()[thePer];
   }
d202 35
a236 2
   {
   public:
d238 13
a250 46
      //------------------------------------------------------------------------
      // Constructor functions
      //------------------------------------------------------------------------

      WitDblFlexVec (WitProblem *, double initValue);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitDblFlexVec ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void operator = (const WitDblFlexVec &);
      void operator = (double);
      void operator = (const WitTVec <double> &);
      void operator = (const double *);
      void operator = (const float *);
      void operator = (const WitIVRealArg &);
         //
         // Assignment operators.

      void copyInto (double *) const;
      void copyInto (float *)  const;
         //
         // Each of these functions copies the elements of this DblFlexVec
         // into the corresponding elements of the argument vector.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      inline WitFlexVec <double> & thisFlexVec ()
         {
         return (* this);
         }

      inline const WitFlexVec <double> & thisFlexVec () const
         {
         return (* this);
         }
d252 2
a253 2
      noCopyCtor (WitDblFlexVec);
   };
d260 2
a261 2
   {
   void copy (WitFlexVec <bool> & theFlexVec, const WitBoolean * theCVec);
d263 2
a264 2
   void copy (WitBoolean * theCVec, const WitFlexVec <bool> & theFlexVec);
   };
@


1.53
log
@Rescinded all changed made since 1/31/07.
@
text
@d79 2
a80 1
      accessWrapper (int,  nPeriods, curAsst_)
@


1.52
log
@[disallowed backlog]
@
text
@d41 1
a41 1
      WitFlexVec (WitProblem *, Elem initValue = static_cast <Elem> (0));
d208 1
a208 1
      WitDblFlexVec (WitProblem *, double initValue = 0.0);
@


1.51
log
@[disallowed backlog]
@
text
@d41 1
a41 1
      WitFlexVec (WitProblem *, Elem initValue);
@


1.50
log
@[disAllowed backlog]
@
text
@d208 1
a208 1
      WitDblFlexVec (WitProblem *, double initValue);
@


1.49
log
@[backlog avoidance]
@
text
@d208 1
a208 1
      WitDblFlexVec (WitProblem *, double initValue = 0.0);
@


1.48
log
@Updated the copyright date on all source files.
@
text
@d208 1
a208 1
      WitDblFlexVec (WitProblem *, double initValue);
@


1.47
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.46
log
@[multi-threads]
@
text
@d259 2
a260 1
{
d262 2
a263 7
void copy (WitFlexVec <bool> & theFlexVec, const WitBoolean * theCVec);

void copy (WitBoolean * theCVec, const WitFlexVec <bool> & theFlexVec);

};
   //
   // Leaving namespace NonClass.
@


1.45
log
@Vector PropRtg.
@
text
@a264 1
// Leaving namespace NonClass.
d266 2
@


1.44
log
@Vector PropRt.
@
text
@d76 1
@


1.43
log
@Another attempt to fix a warning condition on gcc 3.3.3.
@
text
@d224 1
a224 1
      void operator = (const WitInVecRA &);
@


1.42
log
@Another attempt to fix a warning condition from the gcc 3.3.3 complier.
@
text
@d176 1
a176 1
      vectorMode  ()?
@


1.41
log
@An attempt to eliminate a warning from the gcc 3.3.3 compiler.
@
text
@d87 1
a87 5

      inline bool scalarMode () const
         {
         return (not vectorMode ());
         }
@


1.40
log
@Initial work on [vector propRouting attribute].
@
text
@d86 7
a104 7
      accessWrapper (bool, vectorMode, curAsst_)

      inline bool scalarMode () const
         {
         return (not vectorMode ());
         }

@


1.39
log
@PIP.
@
text
@d78 2
a98 1
      accessWrapper (int,  nPeriods,   curAsst_)
d257 14
@


1.38
log
@Double Precision.
@
text
@d231 2
a232 3
      void copyInto (WitTVec <double> &) const;
      void copyInto (double *)           const;
      void copyInto (float *)            const;
@


1.37
log
@Double Precision.
@
text
@a232 1
      void copyInto (WitTVec <float>  &) const;
@


1.36
log
@Double Precision.
@
text
@d60 2
a61 2
      void convCopyInto (WitTVec <Elem> &) const;
      void convCopyInto (Elem *)           const;
a62 1
         // "Convert-Copy Into"
d231 4
a234 4
      void convCopyInto (WitTVec <double> &) const;
      void convCopyInto (double *)           const;
      void convCopyInto (WitTVec <float>  &) const;
      void convCopyInto (float *)            const;
a235 1
         // "Convert-Copy Into"
@


1.35
log
@Double Precision.
@
text
@d53 4
a56 1
      void operator = (const WitFlexVec & theFlexVec);
d58 1
a58 12
         // Copies theFlexVec into this FlexVec.

      void setToScalar (Elem theValue);
         //
         // Sets every element of this FlexVec to theValue.

      void convCopy (const WitTVec <Elem> &);
      void convCopy (const Elem *);
         //
         // "Convert-Copy"
         // Each of these functions copies the elements of the argument vector
         // into the corresponding elements of this FlexVec.
d76 2
a77 2
      bool operator == (Elem theValue) const;
      bool operator >= (Elem theValue) const;
d223 6
a228 1
      void operator = (const WitDblFlexVec & theDblFlexVec);
d230 1
a230 10
         // Copies theDblFlexVec into this DblFlexVec.

      void convCopy (const WitTVec <double> &);
      void convCopy (const double *);
      void convCopy (const float *);
      void convCopy (const WitInVecRA &);
         //
         // "Convert-Copy"
         // Each of these functions copies the elements of the argument vector
         // into the corresponding elements of this DblFlexVec.
d246 10
@


1.34
log
@Double Precision.
@
text
@d53 1
a53 1
      void copy (const WitFlexVec & theFlexVec);
d140 1
a140 1
      noCopyCtorAssign (WitFlexVec);
d231 4
d259 1
a259 1
      noCopyCtorAssign (WitDblFlexVec);
@


1.33
log
@Double Precision.
@
text
@d234 1
@


1.32
log
@Double Precision.
@
text
@d17 1
a22 19
// NonClass "convCopy" functions.
// "Convert-Copy"
// Each of these functions copies the elements of the 2nd vector
// into the corresponding elements of the 1st vector.
// In each case, the 2 vectors are instances of 2 different classes, and one or
// both of the classes is a FlexVec <> class.
//------------------------------------------------------------------------------

namespace WitNonClass
{

void convCopy (WitFlexVec <double> &, const             float   *);
void convCopy (WitTVec    <float>  &, const WitFlexVec <double> &);
void convCopy (            float   *, const WitFlexVec <double> &);

// Leaving namespace NonClass.
}

//------------------------------------------------------------------------------
a34 16
      //------------------------------------------------------------------------
      // Friends.
      //------------------------------------------------------------------------

      friend void WitNonClass::convCopy (
         WitFlexVec <double> &,
         const float *);

      friend void WitNonClass::convCopy (
         WitTVec <float> &,
         const WitFlexVec <double> &);

      friend void WitNonClass::convCopy (
         float *,
         const WitFlexVec <double> &);

a52 7
      void convCopyInto (WitTVec <Elem> &) const;
      void convCopyInto (Elem *)           const;
         //
         // "Convert-Copy Into"
         // Each of these functions copies the elements of this FlexVec
         // into the corresponding elements of the argument vector.

d68 7
d87 1
a87 1
   private:
d90 1
a90 1
      // Private member functions.
a92 6
      noCopyCtorAssign (WitFlexVec);

      void checkBounds (WitPeriod thePer) const;
         //
         // Verifies that thePer is in [0, nPeriods ()).

a104 10
      void switchToVectorMode ();
         //
         // Valid only in scalar mode.
         // Switches to   vector mode.

      void switchToScalarMode ();
         //
         // Valid only in vector mode.
         // Switches to   scalar mode.

d134 22
d206 50
@


1.31
log
@Double Precision.
@
text
@d33 1
a33 1
void convCopy (WitFlexVec <double> &, const WitTVec    <float>  &);
a35 1
void convCopy (WitFlexVec <double> &, const             float   *);
d59 1
a59 1
         const WitTVec <float> &);
a67 4

      friend void WitNonClass::convCopy (
         WitFlexVec <double> &,
         const float *);
@


1.30
log
@Double Precision.
@
text
@a32 2
void convCopy (WitTVec    <double> &, const WitFlexVec <float>  &);
void convCopy (WitFlexVec <float>  &, const WitTVec    <double> &);
a33 1
void convCopy (WitFlexVec <float>  &, const WitFlexVec <double> &);
a58 8
         WitTVec <double> &,
         const WitFlexVec <float>  &);

      friend void WitNonClass::convCopy (
         WitFlexVec <float> &,
         const WitTVec <double> &);

      friend void WitNonClass::convCopy (
a60 4

      friend void WitNonClass::convCopy (
         WitFlexVec <float> &,
         const WitFlexVec <double> &);
@


1.29
log
@Double Precision.
@
text
@d19 1
a19 1
#include <FlexVData.h>
d153 13
a165 1
      inline void beInVectorMode ();
d167 2
a168 1
         // If this FlexVec is in scalar mode, it is switched to vector mode.
d170 1
a170 1
      inline void beInScalarMode ();
d172 21
a192 1
         // If this FlexVec is in vector mode, it is switched to scalar mode.
d194 6
a199 3
      //------------------------------------------------------------------------
      // Wrappers for the corresponding functions in myData_.
      //------------------------------------------------------------------------
d201 2
a202 5
      inline bool   vectorMode () const;
      inline bool   scalarMode () const;
      inline int    nPeriods   () const;
      inline Elem * myCVec     () const;
      inline Elem & myScalar   () const;
d208 1
a208 1
      mutable WitFlexVData <Elem> myData_;
d210 14
a223 1
         // The FlexVData owned by this FlexVec.
a250 58
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline void WitFlexVec <Elem>::beInVectorMode ()
   {
   if (scalarMode ())
      myData_.switchToVectorMode ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline void WitFlexVec <Elem>::beInScalarMode ()
   {
   if (vectorMode ())
      myData_.switchToScalarMode ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline bool WitFlexVec <Elem>::vectorMode () const
   {
   return myData_.vectorMode ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline bool WitFlexVec <Elem>::scalarMode () const
   {
   return myData_.scalarMode ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline int WitFlexVec <Elem>::nPeriods () const
   {
   return myData_.nPeriods ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline Elem * WitFlexVec <Elem>::myCVec () const
   {
   return myData_.myCVec ();
   }

//------------------------------------------------------------------------------

template <typename Elem> 
      inline Elem & WitFlexVec <Elem>::myScalar () const
   {
   return myData_.myScalar ();
@


1.28
log
@Double Precision.
@
text
@d16 1
a16 1
// Contains the declaration of class template OFlxVec <TheType>.
d19 1
a19 2
#include <FlexVecR.h>
#include <NFlxVec.h>
d27 1
a27 1
// both of the classes is a OFlxVec <> class.
d33 7
a39 7
void convCopy (WitTVec    <double> &, const WitOFlxVec <float>  &);
void convCopy (WitOFlxVec <float>  &, const WitTVec    <double> &);
void convCopy (WitOFlxVec <double> &, const WitTVec    <float>  &);
void convCopy (WitOFlxVec <float>  &, const WitOFlxVec <double> &);
void convCopy (WitTVec    <float>  &, const WitOFlxVec <double> &);
void convCopy (            float   *, const WitOFlxVec <double> &);
void convCopy (WitOFlxVec <double> &, const             float   *);
d45 1
a45 1
// Class template OFlxVec <TheType>
d47 1
a47 1
// "Old Flexible Vector"
d50 2
a51 1
// Its length is Problem::nPeriods for its associated Problem.
d54 2
a55 2
template <typename TheType> 
      class WitOFlxVec: private WitFlexVecRep <TheType>
d63 1
a63 1
         const WitOFlxVec <float>  &);
d66 1
a66 1
         WitOFlxVec <float> &,
d70 1
a70 1
         WitOFlxVec <double> &,
d74 2
a75 2
         WitOFlxVec <float> &,
         const WitOFlxVec <double> &);
d79 1
a79 1
         const WitOFlxVec <double> &);
d83 1
a83 1
         const WitOFlxVec <double> &);
d86 1
a86 1
         WitOFlxVec <double> &,
d95 1
a95 3
      WitOFlxVec (WitProblem *, TheType initValue);
         //
         // FlexVecRep <<< initValue.
d101 1
a101 1
      ~WitOFlxVec ();
d107 2
a108 2
      void convCopyInto (WitTVec <TheType> &) const;
      void convCopyInto (TheType *)           const;
d111 1
a111 1
         // Each of these functions copies the elements of this OFlxVec
d114 1
a114 1
      void copy (const WitOFlxVec & theOFlxVec);
d116 1
a116 1
         // Copies theOFlxVec into this OFlxVec.
d118 1
a118 1
      void setToScalar (TheType theValue);
d120 1
a120 1
         // Sets every element of this OFlxVec to theValue.
d122 2
a123 2
      void convCopy (const WitTVec <TheType> &);
      void convCopy (const TheType *);
d127 1
a127 1
         // into the corresponding elements of this OFlxVec.
d129 4
a132 7
      inline TheType operator [] (WitPeriod thePer) const
         {
         return
            repIsByVec   ()?
               myVecRep  ()[thePer]:
               myScalRep ();
         }
d134 1
a134 1
      inline TheType & elemRef (int theIndex);
d138 10
a147 1
      bool operator == (TheType theValue) const;
d149 3
a151 1
      bool operator >= (TheType theValue) const;
d153 3
a155 1
      inline int length () const;
d157 3
a159 1
   private:
d162 1
a162 1
      // Private member functions.
d165 5
a169 1
      noCopyCtorAssign (WitOFlxVec);
d171 5
a175 1
      bool myVecRepGE (TheType theValue) const;
d177 1
a177 1
         // Returns true, iff myVecRep () >= theValue.
d184 69
a252 2
template <typename TheType> 
      inline TheType & WitOFlxVec <TheType>::elemRef (int theIndex)
d254 1
a254 1
   return myRepMadeVec ()[theIndex];
d259 2
a260 2
template <typename TheType> 
      inline int WitOFlxVec <TheType>::length () const
d262 1
a262 1
   return nPeriods ();
@


1.27
log
@Double Precision.
@
text
@a156 7
      static bool hasSingleValue (
            const TheType * theCVec,
            WitProblem *    theProblem);
         //
         // Returns true, iff all the elements of theCVec have the same
         // value.

@


1.26
log
@Double Precision.
@
text
@d16 1
a16 1
// Contains the declaration of class template FlexVec <TheType>.
d20 1
d28 1
a28 1
// both of the classes is a FlexVec <> class.
d34 7
a40 7
void convCopy (WitTVec    <double> &, const WitFlexVec <float>  &);
void convCopy (WitFlexVec <float>  &, const WitTVec    <double> &);
void convCopy (WitFlexVec <double> &, const WitTVec    <float>  &);
void convCopy (WitFlexVec <float>  &, const WitFlexVec <double> &);
void convCopy (WitTVec    <float>  &, const WitFlexVec <double> &);
void convCopy (            float   *, const WitFlexVec <double> &);
void convCopy (WitFlexVec <double> &, const             float   *);
d46 1
a46 1
// Class template FlexVec <TheType>
d48 1
a48 1
// "Flexible Vector"
d55 1
a55 1
      class WitFlexVec: private WitFlexVecRep <TheType>
d63 1
a63 1
         const WitFlexVec <float>  &);
d66 1
a66 1
         WitFlexVec <float> &,
d70 1
a70 1
         WitFlexVec <double> &,
d74 2
a75 2
         WitFlexVec <float> &,
         const WitFlexVec <double> &);
d79 1
a79 1
         const WitFlexVec <double> &);
d83 1
a83 1
         const WitFlexVec <double> &);
d86 1
a86 1
         WitFlexVec <double> &,
d95 1
a95 1
      WitFlexVec (WitProblem *, TheType initValue);
d103 1
a103 1
      ~WitFlexVec ();
d113 1
a113 1
         // Each of these functions copies the elements of this FlexVec
d116 1
a116 1
      void copy (const WitFlexVec & theFlexVec);
d118 1
a118 1
         // Copies theFlexVec into this FlexVec.
d122 1
a122 1
         // Sets every element of this FlexVec to theValue.
d129 1
a129 1
         // into the corresponding elements of this FlexVec.
d155 1
a155 1
      noCopyCtorAssign (WitFlexVec);
d174 1
a174 1
      inline TheType & WitFlexVec <TheType>::elemRef (int theIndex)
d182 1
a182 1
      inline int WitFlexVec <TheType>::length () const
@


1.25
log
@Double Precision.
@
text
@a147 7
      static bool hasSingleValue (
            const TheType * theCVec,
            WitProblem *    theProblem);
         //
         // Returns true, iff all the elements of theCVec have the same
         // value.

d155 7
@


1.24
log
@Double Precision.
@
text
@d33 7
a39 7
void convCopy (WitTVec <double> &,    const WitFlexVec <float> &);
void convCopy (WitFlexVec <float> &,  const WitTVec <double> &);
void convCopy (WitFlexVec <double> &, const WitTVec <float> &);
void convCopy (WitFlexVec <float> &,  const WitFlexVec <double> &);
void convCopy (WitTVec <float> &,     const WitFlexVec <double> &);
void convCopy (float *,               const WitFlexVec <double> &);
void convCopy (WitFlexVec <double> &, const float *);
@


1.23
log
@Double Precision.
@
text
@d22 6
a27 1
// NonClass functions with arguments belonging to specific FlexVec classes.
d33 7
a39 41
void convCopy (
      WitTVec <double> &         theDoubleTVec,
      const WitFlexVec <float> & theFloatFlexVec);
   //
   // Copies the elements of theFloatFlexVec into theDoubleTVec.

void convCopy (
      WitFlexVec <float> &     theFloatFlexVec,
      const WitTVec <double> & theDoubleTVec);
   //
   // Copies the elements of theDoubleTVec into theFloatFlexVec.

void convCopy (
      WitFlexVec <double> &   theDoubleFlexVec,
      const WitTVec <float> & theFloatTVec);
   //
   // Copies the elements of theFloatTVec into theDoubleFlexVec.

void convCopy (
      WitFlexVec <float> &        theFloatFlexVec,
      const WitFlexVec <double> & theDoubleFlexVec);
   //
   // Copies the elements of theDoubleFlexVec into theFloatFlexVec.

void convCopy (
      WitTVec <float> &           theFloatTVec,
      const WitFlexVec <double> & theDoubleFlexVec);
   //
   // Copies the elements of theDoubleFlexVec into theFloatTVec.

void convCopy (
      float *                     theFloatCVec,
      const WitFlexVec <double> & theDoubleFlexVec);
   //
   // Copies the elements of theDoubleFlexVec into theFloatCVec.

void convCopy (
      WitFlexVec <double> & theDoubleFlexVec,
      const float *         theFloatCVec);
   //
   // Copies the elements of theFloatCVec into theDoubleFlexVec.
d108 2
a109 1
      void copyIntoTVec (WitTVec <TheType> & theTVec) const;
d111 3
a113 5
         // Copies the elements of this FlexVec into theTVec.

      void copyIntoCVec (TheType * theCVec) const;
         //
         // Copies the elements of this FlexVec into theCVec.
d123 2
a124 5
      void copyTVec (const WitTVec <TheType> & theTVec);
         //
         // Copies theTVec into this FlexVec.

      void copyCVec (const TheType * theCVec);
d126 3
a128 4
         // Copies the elements of theCVec into the corresponding
         // elements of this FlexVec.
         // The length of theCVec is assumed match that of this
         // FlexVec, but this assumption cannot be verified.
@


1.22
log
@Double Precision.
@
text
@d28 1
a28 1
void copyInto (
d34 1
a34 1
void copyInto (
d40 1
a40 1
void copyInto (
d46 1
a46 1
void copyInto (
d52 1
a52 1
void copyInto (
d58 1
a58 1
void copyInto (
d64 1
a64 1
void copyInto (
d89 1
a89 1
      friend void WitNonClass::copyInto (
d93 1
a93 1
      friend void WitNonClass::copyInto (
d97 1
a97 1
      friend void WitNonClass::copyInto (
d101 1
a101 1
      friend void WitNonClass::copyInto (
d105 1
a105 1
      friend void WitNonClass::copyInto (
d109 1
a109 1
      friend void WitNonClass::copyInto (
d113 1
a113 1
      friend void WitNonClass::copyInto (
@


1.21
log
@Double Precision.
@
text
@d59 1
a59 1
      float *                     theFloatCvector,
d62 1
a62 1
   // Copies the elements of theDoubleFlexVec into theFloatCvector.
d66 1
a66 1
      const float *         theFloatCvector);
d68 1
a68 1
   // Copies the elements of theFloatCvector into theDoubleFlexVec.
d141 1
a141 1
      void copyIntoCvector (TheType * theCvector) const;
d143 1
a143 1
         // Copies the elements of this FlexVec into theCvector.
d157 1
a157 1
      void copyCvector (const TheType * theCvector);
d159 1
a159 1
         // Copies the elements of theCvector into the corresponding
d161 1
a161 1
         // The length of theCvector is assumed match that of this
d183 1
a183 1
            const TheType * theCvector,
d186 1
a186 1
         // Returns true, iff all the elements of theCvector have the same
@


1.20
log
@An attempt to fix more syntax errors from on Windows.
@
text
@d41 6
d95 5
a99 1
         const WitTVec    <double> &);
@


1.19
log
@Continued implementation of PIP.
@
text
@d172 7
a190 17

//------------------------------------------------------------------------------
// Namespace FlexVecUtil.
//
// Functions to be used by class template FlexVec <TheType>.
//------------------------------------------------------------------------------

namespace WitFlexVecUtil
{

template <typename TheType> 
      bool hasSingleValue (const TheType * theCvector, WitProblem * theProblem);
   //
   // Returns true, iff all the elements of theCvector have the same value.

// Leaving namespace FlexVecUtil.
}
@


1.18
log
@Continued implementation of PIP.
@
text
@d26 40
a65 37
   {
   void copyInto (
         WitTVec <double> &         theDoubleTVec,
         const WitFlexVec <float> & theFloatFlexVec);
      //
      // Copies the elements of theFloatFlexVec into theDoubleTVec.

   void copyInto (
         WitFlexVec <float> &     theFloatFlexVec,
         const WitTVec <double> & theDoubleTVec);
      //
      // Copies the elements of theDoubleTVec into theFloatFlexVec.

   void copyInto (
         WitFlexVec <float> &        theFloatFlexVec,
         const WitFlexVec <double> & theDoubleFlexVec);
      //
      // Copies the elements of theDoubleFlexVec into theFloatFlexVec.

   void copyInto (
         WitTVec <float> &           theFloatTVec,
         const WitFlexVec <double> & theDoubleFlexVec);
      //
      // Copies the elements of theDoubleFlexVec into theFloatTVec.

   void copyInto (
         float *                     theFloatCvector,
         const WitFlexVec <double> & theDoubleFlexVec);
      //
      // Copies the elements of theDoubleFlexVec into theFloatCvector.

   void copyInto (
         WitFlexVec <double> & theDoubleFlexVec,
         const float *         theFloatCvector);
      //
      // Copies the elements of theFloatCvector into theDoubleFlexVec.
   }
d192 9
a200 8
   {
   template <typename TheType> 
         bool hasSingleValue (
            const TheType * theCvector,
            WitProblem *    theProblem);
      //
      // Returns true, iff all the elements of theCvector have the same value.
   }
@


1.17
log
@Continued implementation of post-implosion pegging.
@
text
@d22 43
d80 1
a80 1
      friend void copyInto (
d84 1
a84 1
      friend void copyInto (
d88 1
a88 1
      friend void copyInto (
d92 1
a92 1
      friend void copyInto (
d96 1
a96 1
      friend void copyInto (
d100 1
a100 1
      friend void copyInto (
d183 1
a183 11

template <typename TheType> 
      bool hasSingleValue (
         const TheType * theCvector,
         WitProblem *    theProblem);
   //
   // Returns true, iff all the elements of theCvector have the same value.
   // A global function used by class FlexVec <TheType>.

//------------------------------------------------------------------------------
// Global functions with arguments belonging to specific FlexVec classes.
d185 1
a185 1
// Implemented in Vecs.C.
d188 9
a196 45
void copyInto (
      WitTVec <double> &         theDoubleTVec,
      const WitFlexVec <float> & theFloatFlexVec);
   //
   // Copies the elements of theFloatFlexVec into theDoubleTVec.

//------------------------------------------------------------------------------

void copyInto (
      WitFlexVec <float> &     theFloatFlexVec,
      const WitTVec <double> & theDoubleTVec);
   //
   // Copies the elements of theDoubleTVec into theFloatFlexVec.

//------------------------------------------------------------------------------

void copyInto (
      WitFlexVec <float> &        theFloatFlexVec,
      const WitFlexVec <double> & theDoubleFlexVec);
   //
   // Copies the elements of theDoubleFlexVec into theFloatFlexVec.

//------------------------------------------------------------------------------

void copyInto (
      WitTVec <float> &           theFloatTVec,
      const WitFlexVec <double> & theDoubleFlexVec);
   //
   // Copies the elements of theDoubleFlexVec into theFloatTVec.

//------------------------------------------------------------------------------

void copyInto (
      float *                     theFloatCvector,
      const WitFlexVec <double> & theDoubleFlexVec);
   //
   // Copies the elements of theDoubleFlexVec into theFloatCvector.

//------------------------------------------------------------------------------

void copyInto (
      WitFlexVec <double> & theDoubleFlexVec,
      const float *         theFloatCvector);
   //
   // Copies the elements of theFloatCvector into theDoubleFlexVec.
@


1.16
log
@Continued implementation of post-implosion pegging.
@
text
@a27 2
//
// Implemented in FlexVecI.h.
@


1.15
log
@Various internal changes.
@
text
@d122 1
a122 1
      inline bool operator == (TheType theValue) const;
d124 1
a124 1
      inline bool operator >= (TheType theValue) const;
d202 20
@


1.14
log
@Various internal changes.
@
text
@d91 1
a91 1
      void copy (const WitFlexVec <TheType> & theFlexVec);
d134 1
a134 1
      noCopyCtorAssignTemp (WitFlexVec, TheType);
@


1.13
log
@Internal changes.
@
text
@d32 1
a32 1
template <class TheType> 
d143 1
a143 1
template <class TheType> 
@


1.12
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d122 1
a122 1
      inline WitBoolean operator == (TheType theValue) const;
d124 1
a124 1
      inline WitBoolean operator >= (TheType theValue) const;
d136 1
a136 1
      WitBoolean myVecRepGE (TheType theValue) const;
d138 1
a138 1
         // Returns TRUE, iff myVecRep () >= theValue.
d144 1
a144 1
      WitBoolean hasSingleValue (
d148 1
a148 1
   // Returns TRUE, iff all the elements of theCvector have the same value.
@


1.11
log
@Continued implementation of single source.
@
text
@d16 1
a16 2
// Contains the declaration and implementation of class template
// FlexVec <TheType>.
d28 2
d91 1
a91 1
      inline void copy (const WitFlexVec <TheType> & theFlexVec);
d95 1
a95 1
      inline void setToScalar (TheType theValue);
d118 1
a118 4
      inline TheType & elemRef (int theIndex)
         {
         return myRepMadeVec ()[theIndex];
         }
d122 1
a122 15
      inline WitBoolean operator == (TheType theValue) const
         {
         return
            repIsByVec ()?
               (myVecRep  () == theValue):
               (myScalRep () == theValue);
         }

      inline WitBoolean operator >= (TheType theValue) const
         {
         return
            repIsByVec ()?
            myVecRepGE      (theValue):
            (myScalRep () >= theValue);
         }
d124 1
a124 4
      inline int length () const
         {
         return nPeriods ();
         }
d126 1
a126 4
      inline WitBoolean repIsByVec () const
         {
         return WitFlexVecRep <TheType>::repIsByVec ();
         }
d136 1
a136 1
      inline WitBoolean myVecRepGE (TheType theValue) const;
a141 87
// Implementation of class template FlexVec <TheType>
//------------------------------------------------------------------------------

template <class TheType> 
      WitFlexVec <TheType>::WitFlexVec (
         WitProblem * theProblem,
         TheType      initValue):

     WitFlexVecRep <TheType> (theProblem, initValue)
   {
   }

//------------------------------------------------------------------------------

template <class TheType> 
      WitFlexVec <TheType>::~WitFlexVec ()
   {
   }

//------------------------------------------------------------------------------

template <class TheType> 
      void WitFlexVec <TheType>::copyIntoTVec (
         WitTVec <TheType> & theTVec)
         const
   {
   if (repIsByVec ())
      theTVec.copy        (myVecRep ());
   else
      theTVec.setToScalar (myScalRep ());
   }

//------------------------------------------------------------------------------

template <class TheType> 
      void WitFlexVec <TheType>::copyIntoCvector (TheType * theCvector) const
   {
   if (repIsByVec ())
      myVecRep ().copyIntoCvector (theCvector);
   else
      {
      WitPeriod thePer;

      witAssert (theCvector != NULL);

      forEachPeriod (thePer, myProblem ())
         theCvector[thePer] = myScalRep ();
      }
   }

//------------------------------------------------------------------------------

template <class TheType> 
      inline void WitFlexVec <TheType>::copy (
         const WitFlexVec <TheType> & theFlexVec)
   {
   witAssert (length () == theFlexVec.length ());

   if (theFlexVec.repIsByVec ())
      myRepMadeVec  ().copy (theFlexVec.myVecRep  ());
   else
      myRepMadeScal () =     theFlexVec.myScalRep ();
   }

//------------------------------------------------------------------------------

template <class TheType> 
      inline void WitFlexVec <TheType>::setToScalar (TheType theValue)
   {
   myRepMadeScal () = theValue;
   }

//------------------------------------------------------------------------------

template <class TheType> 
      void WitFlexVec <TheType>::copyTVec (
         const WitTVec <TheType> & theTVec)
   {
   witAssert (length () == theTVec.length ());

   if (theTVec == theTVec[0])
      setToScalar          (theTVec[0]);
   else
      myRepMadeVec ().copy (theTVec);
   }

//------------------------------------------------------------------------------
d144 1
a144 28
      void WitFlexVec <TheType>::copyCvector (const TheType * theCvector)
   {
   if (hasSingleValue (theCvector, myProblem ()))
      myRepMadeScal () = theCvector[0];
   else
      myRepMadeVec ().copyCvector (theCvector);
   }

//------------------------------------------------------------------------------

template <class TheType> 
      inline WitBoolean WitFlexVec <TheType>::myVecRepGE (
         TheType theValue) 
         const
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      if (myVecRep ()[thePer] < theValue)
         return witFALSE;

   return witTRUE;
   }

//------------------------------------------------------------------------------

template <class TheType> 
      inline WitBoolean hasSingleValue (
d146 1
a146 15
         WitProblem *    theProblem)
   {
   TheType   valAt0;
   WitPeriod thePer;

   witAssert (theCvector != NULL);

   valAt0 = theCvector[0];

   for (thePer = 1; thePer < theProblem->nPeriods (); ++ thePer)
      if (theCvector[thePer] != valAt0)
         return witFALSE;

   return witTRUE;
   }
@


1.10
log
@Preliminary work on single source.
@
text
@d16 1
a16 1
// Contains the declaration and inline implementation of class template 
d68 1
a68 1
      inline WitFlexVec (WitProblem *, TheType initValue);
d76 1
a76 1
      inline ~WitFlexVec ();
d82 1
a82 1
      inline void copyIntoTVec (WitTVec <TheType> & theTVec) const;
d86 1
a86 1
      inline void copyIntoCvector (TheType * theCvector) const;
d98 1
a98 1
      inline void copyTVec (const WitTVec <TheType> & theTVec);
d102 1
a102 1
      inline void copyCvector (const TheType * theCvector);
d164 2
d168 1
a168 1
      inline WitFlexVec <TheType>::WitFlexVec (
d179 1
a179 1
      inline WitFlexVec <TheType>::~WitFlexVec ()
d186 1
a186 1
      inline void WitFlexVec <TheType>::copyIntoTVec (
d199 1
a199 3
      inline void WitFlexVec <TheType>::copyIntoCvector (
         TheType * theCvector)
         const
d239 1
a239 1
      inline void WitFlexVec <TheType>::copyTVec (
d253 1
a253 1
      inline void WitFlexVec <TheType>::copyCvector (const TheType * theCvector)
@


1.9
log
@Continued preliminary work on single source.
@
text
@d16 2
a17 1
// Contains the declaration of generic class FlexVec (TheType).
d23 1
a23 1
// Generic Class FlexVec (TheType)
d31 183
d215 13
a227 1
// Generic class declaration macro.
d230 5
a234 167
#define WitFlexVecdeclare(TheType)                                             \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitFlexVecRepdeclare (TheType)                                                 \
   /*                                                                        */\
   /* Declares FlexVecRep (TheType)                                          */\
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitFlexVec (TheType): private WitFlexVecRep (TheType)                    \
   {                                                                           \
      /*---------------------------------------------------------------------*/\
      /* Friends.                                                            */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      friend void copyInto (                                                   \
         WitTVec <double> &,                                                   \
         const WitFlexVec (float)  &);                                         \
                                                                               \
      friend void copyInto (                                                   \
         WitFlexVec (float) &,                                                 \
         const WitTVec    <double> &);                                         \
                                                                               \
      friend void copyInto (                                                   \
         WitFlexVec (float) &,                                                 \
         const WitFlexVec (double) &);                                         \
                                                                               \
      friend void copyInto (                                                   \
         WitTVec <float> &,                                                    \
         const WitFlexVec (double) &);                                         \
                                                                               \
      friend void copyInto (                                                   \
         float *,                                                              \
         const WitFlexVec (double) &);                                         \
                                                                               \
      friend void copyInto (                                                   \
         WitFlexVec (double) &,                                                \
         const float *);                                                       \
                                                                               \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      WitFlexVec (TheType) (WitProblem * theProblem, TheType initValue);       \
         /*                                                                  */\
         /* FlexVecRep <<< theProblem.                                       */\
         /* FlexVecRep <<< initValue.                                        */\
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      ~WitFlexVec (TheType) ();                                                \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Other public member functions.                                      */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      void copySelfInto (WitTVec <TheType> & theTVec) const;                   \
         /*                                                                  */\
         /* Copies the elements of this FlexVec into theTVec.                */\
                                                                               \
      void copySelfInto (TheType * theCvector) const;                          \
         /*                                                                  */\
         /* Copies the elements of this FlexVec into theCvector.             */\
                                                                               \
      inline void operator = (const WitFlexVec (TheType) & theFlexVec)         \
         {                                                                     \
         witAssert (length () == theFlexVec.length ());                        \
                                                                               \
         if (theFlexVec.repIsByVec ())                                         \
            myRepMadeVec  ().copy (theFlexVec.myVecRep  ());                   \
         else                                                                  \
            myRepMadeScal () =     theFlexVec.myScalRep ();                    \
         }                                                                     \
         /*                                                                  */\
         /* Ordinary assignment.                                             */\
                                                                               \
      inline void operator = (TheType theValue)                                \
         {                                                                     \
         myRepMadeScal () = theValue;                                          \
         }                                                                     \
                                                                               \
      void operator = (const WitTVec <TheType> &);                             \
         /*                                                                  */\
         /* Assignment from a TVec.                                          */\
                                                                               \
      void operator = (const TheType * theCvector);                            \
         /*                                                                  */\
         /* Copies the elements of theCvector into the corresponding         */\
         /* elements of this FlexVec.                                        */\
         /* The length of theCvector is assumed match that of this           */\
         /* FlexVec, but this assumption cannot be verified.                 */\
                                                                               \
      inline TheType operator [] (WitPeriod thePer) const                      \
         {                                                                     \
         return                                                                \
            repIsByVec   ()?                                                   \
               myVecRep  ()[thePer]:                                           \
               myScalRep ();                                                   \
         }                                                                     \
                                                                               \
      inline TheType & elemRef (int theIndex)                                  \
         {                                                                     \
         return myRepMadeVec ()[theIndex];                                     \
         }                                                                     \
         /*                                                                  */\
         /* Same as [], but returns a reference.                             */\
                                                                               \
      inline WitBoolean operator == (TheType theValue) const                   \
         {                                                                     \
         return                                                                \
            repIsByVec ()?                                                     \
               (myVecRep  () == theValue):                                     \
               (myScalRep () == theValue);                                     \
         }                                                                     \
                                                                               \
      inline WitBoolean operator >= (TheType theValue) const                   \
         {                                                                     \
         return                                                                \
            repIsByVec ()?                                                     \
            myVecRepGE      (theValue):                                        \
            (myScalRep () >= theValue);                                        \
         }                                                                     \
                                                                               \
      inline int length () const                                               \
         {                                                                     \
         return nPeriods ();                                                   \
         }                                                                     \
                                                                               \
      inline WitBoolean repIsByVec () const                                    \
         {                                                                     \
         return WitFlexVecRep (TheType)::repIsByVec ();                        \
         }                                                                     \
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtor (WitFlexVec (TheType));                                       \
                                                                               \
      WitBoolean myVecRepGE (TheType theValue) const;                          \
         /*                                                                  */\
         /* Returns TRUE, iff myVecRep () >= theValue.                       */\
   };                                                                          \
                                                                               \
/*---------------------------------------------------------------------------*/\
                                                                               \
WitBoolean hasSingleValue (                                                    \
      const TheType * theCvector,                                              \
      WitProblem *    theProblem);                                             \
   /*                                                                        */\
   /* Returns TRUE, iff all the elements of theCvector have the same value.  */\
   /* A global function used by class FlexVec (TheType).                     */\

//------------------------------------------------------------------------------
// Declarations of all specific cases of generic class FlexVec.
//------------------------------------------------------------------------------

declare (WitFlexVec, float)
declare (WitFlexVec, double)
declare (WitFlexVec, int)
d237 66
a302 1
// Global functions with FlexVec arguments.
d304 1
a304 1
// (They are global, because they're appropriate only for specific types.)
d309 1
a309 1
      const WitFlexVec (float) & theFloatFlexVec);
d316 1
a316 1
      WitFlexVec (float) &     theFloatFlexVec,
d323 3
a325 11
inline void copyInto (
      WitFlexVec (float) &        theFloatFlexVec,
      const WitFlexVec (double) & theDoubleFlexVec)
   {
   witAssert (theFloatFlexVec.length () == theDoubleFlexVec.length ());

   if (theDoubleFlexVec.repIsByVec ())
      copyInto (theFloatFlexVec.myRepMadeVec (), theDoubleFlexVec.myVecRep ());
   else
      theFloatFlexVec.myRepMadeScal () = theDoubleFlexVec.myScalRep ();
   }
d333 1
a333 1
      const WitFlexVec (double) & theDoubleFlexVec);
d341 1
a341 1
      const WitFlexVec (double) & theDoubleFlexVec);
d348 1
a348 1
      WitFlexVec (double) & theDoubleFlexVec,
@


1.8
log
@Preliminary work on single source.
@
text
@d51 1
a51 1
         WitTVec (double) &,                                                   \
d56 1
a56 1
         const WitTVec    (double) &);                                         \
d63 1
a63 1
         WitTVec (float) &,                                                    \
d95 1
a95 1
      void copySelfInto (WitTVec (TheType) & theTVec) const;                   \
d108 1
a108 1
            myRepMadeVec  () = theFlexVec.myVecRep  ();                        \
d110 1
a110 1
            myRepMadeScal () = theFlexVec.myScalRep ();                        \
d120 1
a120 1
      void operator = (const WitTVec (TheType) &);                             \
d209 1
a209 1
      WitTVec (double) &         theDoubleTVec,
d218 1
a218 1
      const WitTVec (double) & theDoubleTVec);
d241 1
a241 1
      WitTVec (float) &           theFloatTVec,
@


1.7
log
@Refactoring for selection splitting.
@
text
@a145 4
      WitBoolean operator == (const WitFlexVec (TheType) &) const;             \
         /*                                                                  */\
         /* Vector equality.                                                 */\
                                                                               \
@


1.6
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d182 2
a186 4
                                                                               \
      WitFlexVec (TheType) (const WitFlexVec (TheType) &);                     \
         /*                                                                  */\
         /* Not implemented: prevents accidental copying.                    */\
@


1.5
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d50 23
a72 6
      friend void copyTo (WitTVec (double) &,    const WitFlexVec (float)  &); \
      friend void copyTo (WitFlexVec (float) &,  const WitTVec    (double) &); \
      friend void copyTo (WitFlexVec (float) &,  const WitFlexVec (double) &); \
      friend void copyTo (WitTVec (float) &,     const WitFlexVec (double) &); \
      friend void copyTo (float *,               const WitFlexVec (double) &); \
      friend void copyTo (WitFlexVec (double) &, const float *);               \
d95 1
a95 1
      void copyInto (WitTVec (TheType) & theTVec) const;                       \
d99 1
a99 1
      void copyInto (TheType * theCvector) const;                              \
d214 1
a214 1
void copyTo (
d222 1
a222 1
void copyTo (
d230 1
a230 1
inline void copyTo (
d237 1
a237 1
      copyTo (theFloatFlexVec.myRepMadeVec (), theDoubleFlexVec.myVecRep ());
d246 1
a246 1
void copyTo (
d254 1
a254 1
void copyTo (
d262 1
a262 1
void copyTo (
@


1.4
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d154 5
@


1.3
log
@Began implementation of stock bounds.
Changed the default value of the stockRealloc attribute to FALSE.
@
text
@d50 6
a55 3
      friend void copy (WitTVec (double) &, const WitFlexVec (float) &);       \
                                                                               \
      friend void copy (WitFlexVec (float) &, const WitTVec (double) &);       \
d168 9
d183 1
d192 3
a194 3
void copy (
               WitTVec (double) & theDoubleTVec,
      const WitFlexVec (float)  & theFloatFlexVec);
d200 2
a201 2
void copy (
         WitFlexVec (float)  & theFloatFlexVec,
d207 38
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d126 4
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

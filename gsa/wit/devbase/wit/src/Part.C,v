head	1.173;
access;
symbols
	sce_5_01_20080919:1.154
	latest_sce_4_20_20060523:1.89.0.2
	sce_4_20_20060523:1.89
	latest_sce4_20_OSL:1.88.0.2
	sce_4_20_OSL:1.88
	sce_410_withVa:1.80
	sce_4_05_20040511:1.63
	sce_4_00_20040201:1.46
	nextGenBranch:1.42.0.2
	nextGenRoot:1.42
	sce_3_30_20030627:1.42
	EndRw-branch:1.35.0.4
	Root-of-EndRw:1.35
	rwToStl:1.35.0.2
	latest_sce_3_10_20010924:1.13.0.2
	sce_3_10_20010924:1.13
	latest_sce_3_00_20010601:1.7.0.4
	sce_3_00_20010601:1.7
	latest_sce_2_31_20010308:1.7.0.2
	sce_2_31_20010308:1.7
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2;
locks; strict;
comment	@ * @;


1.173
date	2011.09.28.23.49.50;	author rjw;	state Exp;
branches;
next	1.172;

1.172
date	2011.09.24.00.28.11;	author rjw;	state Exp;
branches;
next	1.171;

1.171
date	2011.08.30.20.17.52;	author rjw;	state Exp;
branches;
next	1.170;

1.170
date	2010.06.22.19.55.35;	author rjw;	state Exp;
branches;
next	1.169;

1.169
date	2010.06.18.18.03.49;	author rjw;	state Exp;
branches;
next	1.168;

1.168
date	2010.06.18.14.15.18;	author rjw;	state Exp;
branches;
next	1.167;

1.167
date	2010.03.16.22.42.27;	author rjw;	state Exp;
branches;
next	1.166;

1.166
date	2010.01.06.20.42.40;	author rjw;	state Exp;
branches;
next	1.165;

1.165
date	2009.12.30.18.30.37;	author rjw;	state Exp;
branches;
next	1.164;

1.164
date	2009.12.29.23.24.32;	author rjw;	state Exp;
branches;
next	1.163;

1.163
date	2009.12.29.20.42.58;	author rjw;	state Exp;
branches;
next	1.162;

1.162
date	2009.12.29.20.17.18;	author rjw;	state Exp;
branches;
next	1.161;

1.161
date	2009.12.29.19.39.06;	author rjw;	state Exp;
branches;
next	1.160;

1.160
date	2009.12.29.16.33.45;	author rjw;	state Exp;
branches;
next	1.159;

1.159
date	2009.12.28.23.07.44;	author rjw;	state Exp;
branches;
next	1.158;

1.158
date	2009.12.25.00.10.47;	author rjw;	state Exp;
branches;
next	1.157;

1.157
date	2009.11.18.19.00.02;	author rjw;	state Exp;
branches;
next	1.156;

1.156
date	2009.11.17.22.54.49;	author rjw;	state Exp;
branches;
next	1.155;

1.155
date	2009.11.13.19.01.26;	author rjw;	state Exp;
branches;
next	1.154;

1.154
date	2008.02.25.16.36.34;	author rjw;	state Exp;
branches;
next	1.153;

1.153
date	2007.12.11.22.00.28;	author rjw;	state Exp;
branches;
next	1.152;

1.152
date	2007.12.05.22.13.08;	author rjw;	state Exp;
branches;
next	1.151;

1.151
date	2007.11.29.21.12.31;	author rjw;	state Exp;
branches;
next	1.150;

1.150
date	2007.11.15.17.15.34;	author rjw;	state Exp;
branches;
next	1.149;

1.149
date	2007.11.14.17.18.54;	author rjw;	state Exp;
branches;
next	1.148;

1.148
date	2007.11.13.23.02.17;	author rjw;	state Exp;
branches;
next	1.147;

1.147
date	2007.11.13.20.17.39;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2007.11.07.21.50.12;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2007.10.22.19.58.52;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2007.10.15.21.50.35;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2007.10.11.19.16.57;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2007.10.02.18.32.43;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2007.09.28.22.08.26;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2007.09.26.22.52.51;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2007.09.11.18.09.17;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2007.09.10.21.01.34;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2007.08.01.22.41.58;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2007.06.20.22.41.38;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2007.06.18.22.28.41;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2007.06.14.22.08.53;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2007.06.14.16.09.36;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2007.06.13.23.12.31;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2007.06.08.18.09.40;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2007.06.06.16.28.02;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2007.06.05.21.06.01;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2007.06.05.16.15.24;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2007.06.01.23.29.46;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2007.05.30.16.01.19;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2007.05.25.18.39.11;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2007.05.24.18.52.22;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2007.05.22.20.58.38;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2007.05.22.20.44.26;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2007.05.22.15.46.52;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2007.05.15.19.45.43;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2007.05.14.19.05.39;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2007.05.14.16.18.39;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2007.05.11.20.43.56;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2007.05.10.21.58.11;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2007.05.10.17.22.15;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.04.23.27.11;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2007.04.05.20.23.52;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2007.04.04.22.08.18;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2007.04.03.22.04.04;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2007.04.02.23.01.15;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2007.03.09.20.13.07;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2007.03.08.22.47.18;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.28.20.04.58;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.27.22.59.30;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2007.02.08.00.14.25;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2007.02.07.22.14.54;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2007.02.07.19.55.37;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2007.02.07.17.30.33;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2007.02.07.00.13.08;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2007.02.02.21.36.41;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2007.02.01.16.31.02;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2007.01.31.21.58.02;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2007.01.09.19.14.15;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2006.09.19.17.50.55;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2006.09.07.20.49.24;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2006.09.05.21.11.06;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2006.05.02.17.34.07;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2006.03.24.17.03.38;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2006.03.01.19.23.24;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2005.11.22.18.42.39;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2005.11.22.18.39.14;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2005.11.22.18.23.58;	author dpc;	state Exp;
branches;
next	1.83;

1.83
date	2005.11.22.18.19.28;	author dpc;	state Exp;
branches;
next	1.82;

1.82
date	2005.09.30.21.57.56;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2005.09.26.23.02.18;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2005.06.13.18.12.01;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2005.06.13.16.48.47;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2005.03.16.17.00.31;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.04.00.00.28;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.03.21.25.12;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2005.03.02.22.34.36;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2005.03.02.21.59.46;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.28.22.04.11;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.25.21.26.10;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2005.02.25.16.08.38;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.02.24.23.23.57;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.02.16.18.25.02;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.02.10.19.46.47;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2005.02.10.18.38.30;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2005.01.26.23.50.32;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.06.07.15.18.25;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.30.23.27.44;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.14.21.25.35;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.04.13.21.50.14;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.30.00.05.33;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.29.19.58.27;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.24.23.06.32;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.24.22.21.32;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2004.03.24.16.50.34;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2004.03.10.22.53.20;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.02.23.52.13;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.02.16.19.31;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.09.22.44.05;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.08.19.27.44;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.11.11.18.29.13;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.25.23.49.56;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.18.21.12.49;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.19.16.48.22;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.26.21.42.55;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.14.20.12.58;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.13.23.06.30;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.02.23.40.47;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.02.22.18.42;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.11.18.53.12;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.08.22.21.16.21;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.25.17.43.53;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.09.19.52.35;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.05.19.31.35;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.04.23.07.22;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.03.22.35.20;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.03.16.01.50;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.30.20.08.59;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.29.21.35.47;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.29.14.32.41;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.28.19.44.57;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.17.21.45.03;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.08.19.21.54;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.07.20.15.01;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.03.23.16.40;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.03.19.58.29;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.25.19.14.52;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.24.18.26.08;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.22.14.32.11;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.18.14.02.40;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.28.00.12.59;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.19.18.50.58;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.30.15.51.48;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.29.21.37.20;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.17.22.00.11;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.21.18.24.32;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.01.19.23.34;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.20.00.44.21;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.04.22.27.52;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.06.19.58.40;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.46;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.20.03.26;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.25.20.12.34;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.14.22.38.35;	author bobw;	state Exp;
branches;
next	;


desc
@@


1.173
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "WitPart.C"
//
// Contains the implementation of class Part.
//------------------------------------------------------------------------------

#include <Material.h>
#include <Demand.h>
#include <SubEntry.h>
#include <BopEntry.h>
#include <GlobalComp.h>
#include <BoundSet.h>
#include <CompMgr.h>
#include <DataWrit.h>
#include <Pre.h>
#include <Post.h>
#include <FSS.h>
#include <DetOptImpMgr.h>
#include <OrigMrp.h>
#include <StochImpMgr.h>
#include <OptComp.h>
#include <wit.h>
#include <MsgFrag.h>
#include <MsgFac.h>
#include <IVRealArg.h>
#include <MsgFrag.h>

//------------------------------------------------------------------------------
// Implementation of class Part.
//------------------------------------------------------------------------------

WitPart::~WitPart ()
   {
   }

//------------------------------------------------------------------------------

WitBopEntry * WitPart::expBopEntry (WitPeriod thePer)
   {
   witAssert (explodeable (thePer));

   return expBopEntry_[thePer];
   }

//------------------------------------------------------------------------------

int WitPart::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nParts ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitPart::setPartName (const char * theName)
   {
   myCompMgr ()->setPartName (this, theName);
   }

//------------------------------------------------------------------------------

void WitPart::setSupplyVol (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   witAssert (theValue.isNonNeg (nPeriods ()));

   prepSetScenSpecAttr ("supplyVol");

   supplyVol_ = theValue;
   }

//------------------------------------------------------------------------------

void WitPart::setSingleSource (bool theValue)
   {
   prepSetUnpostAttr ();

   singleSource_ = theValue;
   }

//------------------------------------------------------------------------------

void WitPart::setPropRtg (const WitBoolean * theValue)
   {
   witAssert (theValue != NULL);

   prepSetUnpostAttr ();

   copy (propRtg_, theValue);
   }

//------------------------------------------------------------------------------

void WitPart::setBoundedLeadTimes (bool theValue)
   {
   prepSetUnpostAttr ();

   boundedLeadTimes_ = theValue;
   }

//------------------------------------------------------------------------------

void WitPart::setScrapAllowed (bool theValue)
   {
   prepSetUnpreAttr ();

   scrapAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

void WitPart::setScrapCost (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   prepSetScenSpecAttr ("scrapCost");

   scrapCost_.curDblFlexVec () = theValue;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitPart::storePreSortedPartIndex (int theValue)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   sortedPartIndex_ = theValue;
   }

//------------------------------------------------------------------------------

void WitPart::storePreBelowList (const WitPtrVec <WitPart> & thePtrVec)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   belowList_.resize (thePtrVec.length ());

   belowList_ = thePtrVec;
   }

//------------------------------------------------------------------------------

void WitPart::storePreExpPerGaps (bool theValue)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   expPerGaps_ = theValue;
   }

//------------------------------------------------------------------------------

void WitPart::storePreProducingBopEntries (
      const WitList <WitBopEntry> & theList)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   producingBopEntries_ = theList;
   }

//------------------------------------------------------------------------------

void WitPart::storePreExpBopEntry (const WitPtrTVec <WitBopEntry> & thePtrTVec)
   {
   witAssert (myPreprocessor ()->preprocessing ());
   
   expBopEntry_.allocate (myProblem ());

   expBopEntry_ = thePtrTVec;
   }

//------------------------------------------------------------------------------

void WitPart::storePostConsVol (const WitTVec <double> & theTVec)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   consVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitPart::storePostProdVol (const WitTVec <double> & theTVec)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   prodVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitPart::storePostScrapVol (const WitTVec <double> & theTVec)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   scrapVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitPart::storePostResidualVol (const WitTVec <double> & theTVec)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   residualVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitPart::storeOptScrapVol (WitPeriod thePer, double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   scrapVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitPart::storeOptShadowPrice (WitPeriod thePer, double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   shadowPrice_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitPart::storeStochSupplyVol (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   supplyVol_ = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitPart::storeStochScrapCost (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   scrapCost_.curDblFlexVec () = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitPart::storeStochScrapVol (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   scrapVol_ = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitPart::storeMrpReqVol (const WitTVec <double> & theTVec)
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());

   reqVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitPart::storeMrpMrpConsVol (const WitTVec <double> & theTVec)
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());

   mrpConsVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitPart::storeMrpMrpResidualVol (const WitTVec <double> & theTVec)
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());

   mrpResidualVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitPart::storeFssFocShortageVol (const WitTVec <double> & theTVec)
   {
   witAssert (myFSS ()->uploadingSoln ());

   focShortageVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitPart::insert (WitBomEntry * theBomEnt)
   {
   consumingBomEntries_.appendUniquely (theBomEnt);
   }

//------------------------------------------------------------------------------

void WitPart::insert (WitSubEntry * theSub)
   {
   consumingSubEntries_.appendUniquely (theSub);
   }

//------------------------------------------------------------------------------

void WitPart::insert (WitBopEntry * theBopEnt)
   {
   producingBopEntries_.appendUniquely (theBopEnt);
   }

//------------------------------------------------------------------------------

void WitPart::insert (WitDemand * theDemand)
   {
   myDemands_.appendUniquely (theDemand);
   }

//------------------------------------------------------------------------------

bool WitPart::inserted ()
   {
   return (myCompMgr ()->findPart (partName ().myCstring ()) == this);
   }

//------------------------------------------------------------------------------

void WitPart::writeMultiObjVecs (WitObjective * theObj)
   {
   scrapCost_.writeDataMulti ("scrapCost", this, theObj);
   }

//------------------------------------------------------------------------------

void WitPart::unpreprocess ()
   {
   expBopEntry_.clear ();

   belowList_.resize (0);
   }

//------------------------------------------------------------------------------

void WitPart::clearOptSoln  ()
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());

   scrapVol_    = 0.0;
   shadowPrice_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitPart::clearStochSoln ()
   {
   WitComponent::clearStochSoln ();

   prodVol_     = 0.0;
   consVol_     = 0.0;
   scrapVol_    = 0.0;
   residualVol_ = 0.0;
   }

//------------------------------------------------------------------------------

WitPart * WitPart::thisPart ()
   {
   return this;
   }

//------------------------------------------------------------------------------

void WitPart::identifyInstance ()
   {
   if (myMsgFac ().mayIssue ("partInstIDMsg"))
      myMsgFac () ("partInstIDMsg", partName ());
   }

//------------------------------------------------------------------------------

void WitPart::writeSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (partName ());
   }

//------------------------------------------------------------------------------

WitMsgFrag WitPart::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("partFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitPart::apiObjItrState ()
   {
   return WitAT_PART;
   }

//------------------------------------------------------------------------------

int WitPart::nodeIndex () const
   {
   return mappingIndex_;
   }

//------------------------------------------------------------------------------

void WitPart::display ()
   {
   WitDemand   *          theDemand;
   WitBomEntry *          theBomEnt;
   WitSubEntry *          theSub;
   WitBopEntry *          theBopEnt;
   WitPart     *          thePart;
   WitPeriod              thePer;
   WitPtrVecItr <WitPart> theItr;

   myMsgFac () ("partIdDdMsg", partName ());

   myMsgFac () ("partScalarsDdMsg",
      categoryFrag (),
      mappingIndex_,
      singleSource_,
      boundedLeadTimes_,
      scrapAllowed_);

   if (myPreprocessor ()->preprocessed ())
      myMsgFac () ("partPreDdMsg", sortedPartIndex_, expPerGaps_);

   myProblem ()->display ("extSupplyVolDdMsg", supplyVol_);
   myProblem ()->display ("scrapCostDdMsg",    scrapCost_);
   myProblem ()->display ("propRtgDdMsg",      propRtg_);

   if (not myDemands_.isEmpty ())
      {
      myMsgFac () ("myDemandsHeadingDdMsg");

      forEachEl (theDemand, myDemands_)
         myMsgFac () ("myDemandsDataDdMsg", theDemand->demandName ());
      }

   if (not consumingBomEntries_.isEmpty ())
      {
      myMsgFac () ("consBomHeadingDdMsg");

      forEachEl (theBomEnt, consumingBomEntries_)
         myMsgFac () ("consBomDataDdMsg",
            theBomEnt->myOperationName (), theBomEnt->localIndex ());
      }

   if (not consumingSubEntries_.isEmpty ())
      {
      myMsgFac () ("consSubsHeadingDdMsg");

      forEachEl (theSub, consumingSubEntries_)
         myMsgFac () ("consSubsDataDdMsg",
            theSub->myOperationName (),
            theSub->myBomEnt ()->myPartName (),
            theSub->myBomEntIndex (),
            theSub->localIndex ());
      }

   if (not producingBopEntries_.isEmpty ())
      {
      myMsgFac () ("prodBopHeadingDdMsg");

      forEachEl (theBopEnt, producingBopEntries_)
         myMsgFac () ("prodBopDataDdMsg",
            theBopEnt->myOperationName (),
            theBopEnt->localIndex ());
      }

   if (myPreprocessor ()->preprocessed ())
      if (not producingBopEntries_.isEmpty ())
         {
         myMsgFac () ("expBopHeadDdMsg");

         forEachPeriod (thePer, myProblem ())
            if (explodeable (thePer))
               myMsgFac () ("expBopDataDdMsg",
                  thePer,
                  expBopEntry (thePer)->myOperationName (),
                  expBopEntry (thePer)->localIndex ());
         }

   if (myPreprocessor ()->preprocessed ())
      {
      myMsgFac () ("belowHeadingDdMsg");

      belowList_.attachItr (theItr);

      while (theItr.advance (thePart))
         myMsgFac () ("belowDataDdMsg", thePart->partName ());
      }

   WitDelComp::display ();
   }

//------------------------------------------------------------------------------

bool WitPart::explodeable (WitPeriod thePer)
   {
   return expBopEntry_.isAllocated () and expBopEntry_[thePer] != NULL;
   }

//------------------------------------------------------------------------------

double WitPart::net (
      WitPeriod          reqPer,
      double             reqQty,
      WitTVec <double> & supply)
   {
   WitPeriod supplyPer;
   double    qty;

   qty = reqQty;

   for (supplyPer = reqPer; supplyPer >= 0; -- supplyPer)
      {
      if (supplyPer < reqPer)
         if (not canStock (supplyPer))
            break;

      if (supply[supplyPer] > NET_TOL)
         {
         WitNonClass::net (qty, supply[supplyPer]);

         if (qty <= NET_TOL)
            return 0.0;
         }
      }

   return qty;
   }

//------------------------------------------------------------------------------

void WitPart::writeSoln ()
   {
   WitPeriod     thePer;
   WitMaterial * theMat;
   WitDemand *   theDemand;
   double        shipVolVal;

   fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());

   fprintf (solnFile (),
              "Period"
       "    SupplyVol"
       "      ProdVol"
       "      ConsVol"
       "      ShipVol"
       "     StockVol"
       "     ScrapVol"
       "  ResidualVol");

   if (myGlobalComp ()->printExcessVol ())
      fprintf (solnFile (), "    ExcessVol");

   else if (fssComputed ())
      fprintf (solnFile (), "  ShortageVol");

   fprintf (solnFile (), "\n");

   forEachPeriod (thePer, myProblem ())
      {
      shipVolVal = 0.0;

      forEachEl (theDemand, myDemands ())
         shipVolVal += theDemand->shipVol ()[thePer];

      fprintf (solnFile (), "%6d", thePer);

      writeSolnValue (supplyVol_[thePer]);
      writeSolnValue (prodVol_  [thePer]);
      writeSolnValue (consVol_  [thePer]);
      writeSolnValue (shipVolVal);

      theMat = thisMat ();

      writeSolnValue (
         (theMat != NULL)?
            theMat->stockVol ()[thePer]:
            0.0);

      writeSolnValue (scrapVol_   [thePer]);
      writeSolnValue (residualVol_[thePer]);

      if (myGlobalComp ()->printExcessVol ())
         writeSolnValue (myPostprocessor ()->compExcessVol (this, thePer));

      else if (fssComputed ())
         writeSolnValue (focShortageVol_[thePer]);

      fprintf (solnFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

void WitPart::writeDualSoln ()
   {
   WitPeriod thePer;

   witAssert (myOptComp ()->compPrices ());

   fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());

   fprintf (solnFile (),"Period  Shadow Price\n");

   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d ", thePer);

      writeSolnValue (shadowPrice_[thePer]);

      fprintf (solnFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

void WitPart::writeMrpSoln ()
   {
   WitPeriod thePer;

   fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());

   fprintf (solnFile (),
              "Period"
       "    SupplyVol"
       "   MrpConsVol"
       "       ReqVol"
       "  MrpResidualVol\n");

   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d", thePer);

      writeSolnValue (supplyVol  ()[thePer]);
      writeSolnValue (mrpConsVol ()[thePer]);
      writeSolnValue (reqVol     ()[thePer]);

      fprintf (solnFile (), "   ");

      writeSolnValue (mrpResidualVol ()[thePer]);

      fprintf (solnFile (), "\n");
      }
   }

//------------------------------------------------------------------------------

void WitPart::resetShadowPrice ()
   {
   shadowPrice_ = 0.0;
   }

//------------------------------------------------------------------------------

WitPart::WitPart (const char * theName, WitCompMgr * theCompMgr):
      WitNode              (theName, theCompMgr),

      mappingIndex_        (myCompMgr ()->nParts ()),
      myDemands_           (),
      consumingBomEntries_ (),
      consumingSubEntries_ (),
      producingBopEntries_ (),
      supplyVol_           (myProblem (), defSupplyVol        ()),
      singleSource_        (              defSingleSource     ()),
      propRtg_             (myProblem (), defPropRtg          ()),
      boundedLeadTimes_    (              defBoundedLeadTimes ()),
      scrapAllowed_        (              defScrapAllowed     ()),
      scrapCost_           (myProblem (), defScrapCost        ()),
      sortedPartIndex_     (-1),
      expBopEntry_         (),
      belowList_           (),
      expPerGaps_          (false),
      shadowPrice_         (myProblem (), 0.0),
      consVol_             (myProblem (), 0.0),
      prodVol_             (myProblem (), 0.0),
      scrapVol_            (myProblem (), 0.0),
      residualVol_         (myProblem (), 0.0),
      reqVol_              (myProblem (), 0.0),
      mrpConsVol_          (myProblem (), 0.0),
      mrpResidualVol_      (myProblem (), 0.0),
      focShortageVol_      (myProblem (), 0.0)
   {
   if (PART_LIMIT >= 0)
      if (myCompMgr ()->nParts () > PART_LIMIT)
         myMsgFac () ("partLimitExceededSmsg", PART_LIMIT);
   }

//------------------------------------------------------------------------------

void WitPart::recountPart ()
   {
   mappingIndex_ = myCompMgr ()->nParts ();
   }

//------------------------------------------------------------------------------

void WitPart::writeDataAttrs ()
   {
   WitNode::writeDataAttrs ();

   myDataWriter ()->writeVector (
        "supplyVol",
         supplyVol_,
      defSupplyVol ());

   myDataWriter ()->writeBool (
        "singleSource",
         singleSource_,
      defSingleSource ());

   myDataWriter ()->writeVector (
        "propRtg",
         propRtg_,
      defPropRtg ());

   myDataWriter ()->writeBool (
        "boundedLeadTimes",
         boundedLeadTimes_,
      defBoundedLeadTimes ());

   myDataWriter ()->writeBool (
        "scrapAllowed",
         scrapAllowed_,
      defScrapAllowed ());

   myDataWriter ()->writeObjVec (
        "scrapCost",
         scrapCost_,
      defScrapCost ());
   }

//------------------------------------------------------------------------------

void WitPart::copyAttrsFrom (WitPart * thePart)
   {
   WitNode::copyAttrsFrom (thePart);

   supplyVol_        = thePart->supplyVol_;
   singleSource_     = thePart->singleSource_;
   propRtg_          = thePart->propRtg_;
   boundedLeadTimes_ = thePart->boundedLeadTimes_;
   scrapAllowed_     = thePart->scrapAllowed_;
   scrapCost_        = thePart->scrapCost_;
   }

//------------------------------------------------------------------------------

void WitPart::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (partName ());
   myDataWriter ()->writeKeyWord      (categoryKeyWord ());
   }

//------------------------------------------------------------------------------

void WitPart::purgeCompListsSpec ()
   {
   purgeSelComps (consumingBomEntries_);
   purgeSelComps (consumingSubEntries_);
   purgeSelComps (producingBopEntries_);
   purgeSelComps (myDemands_);
   }

//------------------------------------------------------------------------------

void WitPart::clearDepListsSpec ()
   {
   consumingBomEntries_.clear ();
   consumingSubEntries_.clear ();
   producingBopEntries_.clear ();
   myDemands_          .clear ();
   }
@


1.172
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 6
a6 1
//------------------------------------------------------------------------------
d8 1
a8 4
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential
d10 4
a13 1
//------------------------------------------------------------------------------
@


1.171
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d42 2
a43 2
{
}
d48 2
a49 2
{
witAssert (explodeable (thePer));
d51 2
a52 2
return expBopEntry_[thePer];
}
d57 3
a59 3
{
return theProblem->myCompMgr ()->nParts ();
}
d66 3
a68 3
{
myCompMgr ()->setPartName (this, theName);
}
d73 2
a74 2
{
witAssert (theValue != NULL);
d76 1
a76 1
witAssert (theValue.isNonNeg (nPeriods ()));
d78 1
a78 1
prepSetScenSpecAttr ("supplyVol");
d80 2
a81 2
supplyVol_ = theValue;
}
d86 2
a87 2
{
prepSetUnpostAttr ();
d89 2
a90 2
singleSource_ = theValue;
}
d95 2
a96 2
{
witAssert (theValue != NULL);
d98 1
a98 1
prepSetUnpostAttr ();
d100 2
a101 2
copy (propRtg_, theValue);
}
d106 2
a107 2
{
prepSetUnpostAttr ();
d109 2
a110 2
boundedLeadTimes_ = theValue;
}
d115 2
a116 2
{
prepSetUnpreAttr ();
d118 2
a119 2
scrapAllowed_ = theValue;
}
d124 2
a125 2
{
witAssert (theValue != NULL);
d127 1
a127 1
prepSetScenSpecAttr ("scrapCost");
d129 2
a130 2
scrapCost_.curDblFlexVec () = theValue;
}
d137 2
a138 2
{
witAssert (myPreprocessor ()->preprocessing ());
d140 2
a141 2
sortedPartIndex_ = theValue;
}
d146 2
a147 2
{
witAssert (myPreprocessor ()->preprocessing ());
d149 1
a149 1
belowList_.resize (thePtrVec.length ());
d151 2
a152 2
belowList_ = thePtrVec;
}
d157 2
a158 2
{
witAssert (myPreprocessor ()->preprocessing ());
d160 2
a161 2
expPerGaps_ = theValue;
}
d166 3
a168 3
const WitList <WitBopEntry> & theList)
{
witAssert (myPreprocessor ()->preprocessing ());
d170 2
a171 2
producingBopEntries_ = theList;
}
d176 4
a179 2
{
witAssert (myPreprocessor ()->preprocessing ());
d181 2
a182 4
expBopEntry_.allocate (myProblem ());

expBopEntry_ = thePtrTVec;
}
d187 2
a188 2
{
witAssert (myPostprocessor ()->postprocessing ());
d190 2
a191 2
consVol_ = theTVec;
}
d196 2
a197 2
{
witAssert (myPostprocessor ()->postprocessing ());
d199 2
a200 2
prodVol_ = theTVec;
}
d205 2
a206 2
{
witAssert (myPostprocessor ()->postprocessing ());
d208 2
a209 2
scrapVol_ = theTVec;
}
d214 2
a215 2
{
witAssert (myPostprocessor ()->postprocessing ());
d217 2
a218 2
residualVol_ = theTVec;
}
d223 2
a224 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d226 2
a227 2
scrapVol_.elemRef (thePer) = theValue;
}
d232 2
a233 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d235 2
a236 2
shadowPrice_.elemRef (thePer) = theValue;
}
d241 2
a242 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d244 2
a245 2
supplyVol_ = theFlexVec;
}
d250 2
a251 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d253 2
a254 2
scrapCost_.curDblFlexVec () = theFlexVec;
}
d259 2
a260 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d262 2
a263 2
scrapVol_ = theFlexVec;
}
d268 2
a269 2
{
witAssert (myOrigMrpExp ()->uploadingSoln ());
d271 2
a272 2
reqVol_ = theTVec;
}
d277 2
a278 2
{
witAssert (myOrigMrpExp ()->uploadingSoln ());
d280 2
a281 2
mrpConsVol_ = theTVec;
}
d286 2
a287 2
{
witAssert (myOrigMrpExp ()->uploadingSoln ());
d289 2
a290 2
mrpResidualVol_ = theTVec;
}
d295 2
a296 2
{
witAssert (myFSS ()->uploadingSoln ());
d298 2
a299 2
focShortageVol_ = theTVec;
}
d304 3
a306 3
{
consumingBomEntries_.appendUniquely (theBomEnt);
}
d311 3
a313 3
{
consumingSubEntries_.appendUniquely (theSub);
}
d318 3
a320 3
{
producingBopEntries_.appendUniquely (theBopEnt);
}
d325 3
a327 3
{
myDemands_.appendUniquely (theDemand);
}
d332 3
a334 3
{
return (myCompMgr ()->findPart (partName ().myCstring ()) == this);
}
d339 3
a341 3
{
scrapCost_.writeDataMulti ("scrapCost", this, theObj);
}
d346 2
a347 2
{
expBopEntry_.clear ();
d349 2
a350 2
belowList_.resize (0);
}
d355 2
a356 2
{
witAssert (myDetOptImpMgr ()->clearingSoln ());
d358 3
a360 3
scrapVol_    = 0.0;
shadowPrice_ = 0.0;
}
d365 2
a366 2
{
WitComponent::clearStochSoln ();
d368 5
a372 5
prodVol_     = 0.0;
consVol_     = 0.0;
scrapVol_    = 0.0;
residualVol_ = 0.0;
}
d377 3
a379 3
{
return this;
}
d384 4
a387 4
{
if (myMsgFac ().mayIssue ("partInstIDMsg"))
myMsgFac () ("partInstIDMsg", partName ());
}
d392 5
a396 5
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("part");
myDataWriter ()->writeStringValue  (partName ());
}
d401 3
a403 3
{
return myMsgFac ().myFrag ("partFrag");
}
d408 3
a410 3
{
return WitAT_PART;
}
d415 3
a417 3
{
return mappingIndex_;
}
d422 86
a507 86
{
WitDemand   *          theDemand;
WitBomEntry *          theBomEnt;
WitSubEntry *          theSub;
WitBopEntry *          theBopEnt;
WitPart     *          thePart;
WitPeriod              thePer;
WitPtrVecItr <WitPart> theItr;

myMsgFac () ("partIdDdMsg", partName ());

myMsgFac () ("partScalarsDdMsg",
categoryFrag (),
mappingIndex_,
singleSource_,
boundedLeadTimes_,
scrapAllowed_);

if (myPreprocessor ()->preprocessed ())
myMsgFac () ("partPreDdMsg", sortedPartIndex_, expPerGaps_);

myProblem ()->display ("extSupplyVolDdMsg", supplyVol_);
myProblem ()->display ("scrapCostDdMsg",    scrapCost_);
myProblem ()->display ("propRtgDdMsg",      propRtg_);

if (not myDemands_.isEmpty ())
{
myMsgFac () ("myDemandsHeadingDdMsg");

forEachEl (theDemand, myDemands_)
myMsgFac () ("myDemandsDataDdMsg", theDemand->demandName ());
}

if (not consumingBomEntries_.isEmpty ())
{
myMsgFac () ("consBomHeadingDdMsg");

forEachEl (theBomEnt, consumingBomEntries_)
myMsgFac () ("consBomDataDdMsg",
theBomEnt->myOperationName (), theBomEnt->localIndex ());
}

if (not consumingSubEntries_.isEmpty ())
{
myMsgFac () ("consSubsHeadingDdMsg");

forEachEl (theSub, consumingSubEntries_)
myMsgFac () ("consSubsDataDdMsg",
theSub->myOperationName (),
theSub->myBomEnt ()->myPartName (),
theSub->myBomEntIndex (),
theSub->localIndex ());
}

if (not producingBopEntries_.isEmpty ())
{
myMsgFac () ("prodBopHeadingDdMsg");

forEachEl (theBopEnt, producingBopEntries_)
myMsgFac () ("prodBopDataDdMsg",
theBopEnt->myOperationName (),
theBopEnt->localIndex ());
}

if (myPreprocessor ()->preprocessed ())
if (not producingBopEntries_.isEmpty ())
{
myMsgFac () ("expBopHeadDdMsg");

forEachPeriod (thePer, myProblem ())
if (explodeable (thePer))
myMsgFac () ("expBopDataDdMsg",
thePer,
expBopEntry (thePer)->myOperationName (),
expBopEntry (thePer)->localIndex ());
}

if (myPreprocessor ()->preprocessed ())
{
myMsgFac () ("belowHeadingDdMsg");

belowList_.attachItr (theItr);

while (theItr.advance (thePart))
myMsgFac () ("belowDataDdMsg", thePart->partName ());
}
d509 2
a510 2
WitDelComp::display ();
}
d515 3
a517 3
{
return expBopEntry_.isAllocated () and expBopEntry_[thePer] != NULL;
}
d522 23
a544 23
WitPeriod          reqPer,
double             reqQty,
WitTVec <double> & supply)
{
WitPeriod supplyPer;
double    qty;

qty = reqQty;

for (supplyPer = reqPer; supplyPer >= 0; -- supplyPer)
{
if (supplyPer < reqPer)
if (not canStock (supplyPer))
break;

if (supply[supplyPer] > NET_TOL)
{
WitNonClass::net (qty, supply[supplyPer]);

if (qty <= NET_TOL)
return 0.0;
}
}
d546 2
a547 2
return qty;
}
d552 5
a556 5
{
WitPeriod     thePer;
WitMaterial * theMat;
WitDemand *   theDemand;
double        shipVolVal;
d558 1
a558 1
fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());
d560 9
a568 9
fprintf (solnFile (),
"Period"
"    SupplyVol"
"      ProdVol"
"      ConsVol"
"      ShipVol"
"     StockVol"
"     ScrapVol"
"  ResidualVol");
d570 2
a571 2
if (myGlobalComp ()->printExcessVol ())
fprintf (solnFile (), "    ExcessVol");
d573 2
a574 2
else if (fssComputed ())
fprintf (solnFile (), "  ShortageVol");
d576 1
a576 1
fprintf (solnFile (), "\n");
d578 3
a580 3
forEachPeriod (thePer, myProblem ())
{
shipVolVal = 0.0;
d582 2
a583 2
forEachEl (theDemand, myDemands ())
shipVolVal += theDemand->shipVol ()[thePer];
d585 1
a585 1
fprintf (solnFile (), "%6d", thePer);
d587 4
a590 4
writeSolnValue (supplyVol_[thePer]);
writeSolnValue (prodVol_  [thePer]);
writeSolnValue (consVol_  [thePer]);
writeSolnValue (shipVolVal);
d592 1
a592 1
theMat = thisMat ();
d594 4
a597 4
writeSolnValue (
(theMat != NULL)?
theMat->stockVol ()[thePer]:
0.0);
d599 2
a600 2
writeSolnValue (scrapVol_   [thePer]);
writeSolnValue (residualVol_[thePer]);
d602 2
a603 2
if (myGlobalComp ()->printExcessVol ())
writeSolnValue (myPostprocessor ()->compExcessVol (this, thePer));
d605 2
a606 2
else if (fssComputed ())
writeSolnValue (focShortageVol_[thePer]);
d608 3
a610 3
fprintf (solnFile (), "\n");
}
}
d615 2
a616 2
{
WitPeriod thePer;
d618 1
a618 1
witAssert (myOptComp ()->compPrices ());
d620 1
a620 1
fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());
d622 1
a622 1
fprintf (solnFile (),"Period  Shadow Price\n");
d624 3
a626 3
forEachPeriod (thePer, myProblem ())
{
fprintf (solnFile (), "%6d ", thePer);
d628 1
a628 1
writeSolnValue (shadowPrice_[thePer]);
d630 3
a632 3
fprintf (solnFile (), "\n");
}
}
d637 2
a638 2
{
WitPeriod thePer;
d640 1
a640 1
fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());
d642 6
a647 6
fprintf (solnFile (),
"Period"
"    SupplyVol"
"   MrpConsVol"
"       ReqVol"
"  MrpResidualVol\n");
d649 3
a651 3
forEachPeriod (thePer, myProblem ())
{
fprintf (solnFile (), "%6d", thePer);
d653 3
a655 3
writeSolnValue (supplyVol  ()[thePer]);
writeSolnValue (mrpConsVol ()[thePer]);
writeSolnValue (reqVol     ()[thePer]);
d657 1
a657 1
fprintf (solnFile (), "   ");
d659 1
a659 1
writeSolnValue (mrpResidualVol ()[thePer]);
d661 3
a663 3
fprintf (solnFile (), "\n");
}
}
d668 3
a670 3
{
shadowPrice_ = 0.0;
}
d675 1
a675 1
WitNode              (theName, theCompMgr),
d677 29
a705 29
mappingIndex_        (myCompMgr ()->nParts ()),
myDemands_           (),
consumingBomEntries_ (),
consumingSubEntries_ (),
producingBopEntries_ (),
supplyVol_           (myProblem (), defSupplyVol        ()),
singleSource_        (              defSingleSource     ()),
propRtg_             (myProblem (), defPropRtg          ()),
boundedLeadTimes_    (              defBoundedLeadTimes ()),
scrapAllowed_        (              defScrapAllowed     ()),
scrapCost_           (myProblem (), defScrapCost        ()),
sortedPartIndex_     (-1),
expBopEntry_         (),
belowList_           (),
expPerGaps_          (false),
shadowPrice_         (myProblem (), 0.0),
consVol_             (myProblem (), 0.0),
prodVol_             (myProblem (), 0.0),
scrapVol_            (myProblem (), 0.0),
residualVol_         (myProblem (), 0.0),
reqVol_              (myProblem (), 0.0),
mrpConsVol_          (myProblem (), 0.0),
mrpResidualVol_      (myProblem (), 0.0),
focShortageVol_      (myProblem (), 0.0)
{
if (PART_LIMIT >= 0)
if (myCompMgr ()->nParts () > PART_LIMIT)
myMsgFac () ("partLimitExceededSmsg", PART_LIMIT);
}
d710 3
a712 3
{
mappingIndex_ = myCompMgr ()->nParts ();
}
d717 2
a718 2
{
WitNode::writeDataAttrs ();
d720 30
a749 30
myDataWriter ()->writeVector (
"supplyVol",
supplyVol_,
defSupplyVol ());

myDataWriter ()->writeBool (
"singleSource",
singleSource_,
defSingleSource ());

myDataWriter ()->writeVector (
"propRtg",
propRtg_,
defPropRtg ());

myDataWriter ()->writeBool (
"boundedLeadTimes",
boundedLeadTimes_,
defBoundedLeadTimes ());

myDataWriter ()->writeBool (
"scrapAllowed",
scrapAllowed_,
defScrapAllowed ());

myDataWriter ()->writeObjVec (
"scrapCost",
scrapCost_,
defScrapCost ());
}
d754 2
a755 2
{
WitNode::copyAttrsFrom (thePart);
d757 7
a763 7
supplyVol_        = thePart->supplyVol_;
singleSource_     = thePart->singleSource_;
propRtg_          = thePart->propRtg_;
boundedLeadTimes_ = thePart->boundedLeadTimes_;
scrapAllowed_     = thePart->scrapAllowed_;
scrapCost_        = thePart->scrapCost_;
}
d768 6
a773 6
{
myDataWriter ()->writeFirstKeyWord ("add");
myDataWriter ()->writeKeyWord      ("part");
myDataWriter ()->writeStringValue  (partName ());
myDataWriter ()->writeKeyWord      (categoryKeyWord ());
}
d778 6
a783 6
{
purgeSelComps (consumingBomEntries_);
purgeSelComps (consumingSubEntries_);
purgeSelComps (producingBopEntries_);
purgeSelComps (myDemands_);
}
d788 6
a793 6
{
consumingBomEntries_.clear ();
consumingSubEntries_.clear ();
producingBopEntries_.clear ();
myDemands_          .clear ();
}
@


1.170
log
@Lead Time Bounds
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d42 2
a43 2
   {
   }
d48 2
a49 2
   {
   witAssert (explodeable (thePer));
d51 2
a52 2
   return expBopEntry_[thePer];
   }
d57 3
a59 3
   {
   return theProblem->myCompMgr ()->nParts ();
   }
d66 3
a68 3
   {
   myCompMgr ()->setPartName (this, theName);
   }
d73 2
a74 2
   {
   witAssert (theValue != NULL);
d76 1
a76 1
   witAssert (theValue.isNonNeg (nPeriods ()));
d78 1
a78 1
   prepSetScenSpecAttr ("supplyVol");
d80 2
a81 2
   supplyVol_ = theValue;
   }
d86 2
a87 2
   {
   prepSetUnpostAttr ();
d89 2
a90 2
   singleSource_ = theValue;
   }
d95 2
a96 2
   {
   witAssert (theValue != NULL);
d98 1
a98 1
   prepSetUnpostAttr ();
d100 2
a101 2
   copy (propRtg_, theValue);
   }
d106 2
a107 2
   {
   prepSetUnpostAttr ();
d109 2
a110 2
   boundedLeadTimes_ = theValue;
   }
d115 2
a116 2
   {
   prepSetUnpreAttr ();
d118 2
a119 2
   scrapAllowed_ = theValue;
   }
d124 2
a125 2
   {
   witAssert (theValue != NULL);
d127 1
a127 1
   prepSetScenSpecAttr ("scrapCost");
d129 2
a130 2
   scrapCost_.curDblFlexVec () = theValue;
   }
d137 2
a138 2
   {
   witAssert (myPreprocessor ()->preprocessing ());
d140 2
a141 2
   sortedPartIndex_ = theValue;
   }
d146 2
a147 2
   {
   witAssert (myPreprocessor ()->preprocessing ());
d149 1
a149 1
   belowList_.resize (thePtrVec.length ());
d151 2
a152 2
   belowList_ = thePtrVec;
   }
d157 2
a158 2
   {
   witAssert (myPreprocessor ()->preprocessing ());
d160 2
a161 2
   expPerGaps_ = theValue;
   }
d166 3
a168 3
      const WitList <WitBopEntry> & theList)
   {
   witAssert (myPreprocessor ()->preprocessing ());
d170 2
a171 2
   producingBopEntries_ = theList;
   }
d176 2
a177 4
   {
   witAssert (myPreprocessor ()->preprocessing ());
   
   expBopEntry_.allocate (myProblem ());
d179 4
a182 2
   expBopEntry_ = thePtrTVec;
   }
d187 2
a188 2
   {
   witAssert (myPostprocessor ()->postprocessing ());
d190 2
a191 2
   consVol_ = theTVec;
   }
d196 2
a197 2
   {
   witAssert (myPostprocessor ()->postprocessing ());
d199 2
a200 2
   prodVol_ = theTVec;
   }
d205 2
a206 2
   {
   witAssert (myPostprocessor ()->postprocessing ());
d208 2
a209 2
   scrapVol_ = theTVec;
   }
d214 2
a215 2
   {
   witAssert (myPostprocessor ()->postprocessing ());
d217 2
a218 2
   residualVol_ = theTVec;
   }
d223 2
a224 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d226 2
a227 2
   scrapVol_.elemRef (thePer) = theValue;
   }
d232 2
a233 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d235 2
a236 2
   shadowPrice_.elemRef (thePer) = theValue;
   }
d241 2
a242 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d244 2
a245 2
   supplyVol_ = theFlexVec;
   }
d250 2
a251 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d253 2
a254 2
   scrapCost_.curDblFlexVec () = theFlexVec;
   }
d259 2
a260 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d262 2
a263 2
   scrapVol_ = theFlexVec;
   }
d268 2
a269 2
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());
d271 2
a272 2
   reqVol_ = theTVec;
   }
d277 2
a278 2
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());
d280 2
a281 2
   mrpConsVol_ = theTVec;
   }
d286 2
a287 2
   {
   witAssert (myOrigMrpExp ()->uploadingSoln ());
d289 2
a290 2
   mrpResidualVol_ = theTVec;
   }
d295 2
a296 2
   {
   witAssert (myFSS ()->uploadingSoln ());
d298 2
a299 2
   focShortageVol_ = theTVec;
   }
d304 3
a306 3
   {
   consumingBomEntries_.appendUniquely (theBomEnt);
   }
d311 3
a313 3
   {
   consumingSubEntries_.appendUniquely (theSub);
   }
d318 3
a320 3
   {
   producingBopEntries_.appendUniquely (theBopEnt);
   }
d325 3
a327 3
   {
   myDemands_.appendUniquely (theDemand);
   }
d332 3
a334 3
   {
   return (myCompMgr ()->findPart (partName ().myCstring ()) == this);
   }
d339 3
a341 3
   {
   scrapCost_.writeDataMulti ("scrapCost", this, theObj);
   }
d346 2
a347 2
   {
   expBopEntry_.clear ();
d349 2
a350 2
   belowList_.resize (0);
   }
d355 2
a356 2
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());
d358 3
a360 3
   scrapVol_    = 0.0;
   shadowPrice_ = 0.0;
   }
d365 2
a366 2
   {
   WitComponent::clearStochSoln ();
d368 5
a372 5
   prodVol_     = 0.0;
   consVol_     = 0.0;
   scrapVol_    = 0.0;
   residualVol_ = 0.0;
   }
d377 3
a379 3
   {
   return this;
   }
d384 4
a387 4
   {
   if (myMsgFac ().mayIssue ("partInstIDMsg"))
      myMsgFac () ("partInstIDMsg", partName ());
   }
d392 5
a396 5
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (partName ());
   }
d401 3
a403 3
   {
   return myMsgFac ().myFrag ("partFrag");
   }
d408 3
a410 3
   {
   return WitAT_PART;
   }
d415 3
a417 3
   {
   return mappingIndex_;
   }
d422 86
a507 86
   {
   WitDemand   *          theDemand;
   WitBomEntry *          theBomEnt;
   WitSubEntry *          theSub;
   WitBopEntry *          theBopEnt;
   WitPart     *          thePart;
   WitPeriod              thePer;
   WitPtrVecItr <WitPart> theItr;

   myMsgFac () ("partIdDdMsg", partName ());

   myMsgFac () ("partScalarsDdMsg",
      categoryFrag (),
      mappingIndex_,
      singleSource_,
      boundedLeadTimes_,
      scrapAllowed_);

   if (myPreprocessor ()->preprocessed ())
      myMsgFac () ("partPreDdMsg", sortedPartIndex_, expPerGaps_);

   myProblem ()->display ("extSupplyVolDdMsg", supplyVol_);
   myProblem ()->display ("scrapCostDdMsg",    scrapCost_);
   myProblem ()->display ("propRtgDdMsg",      propRtg_);

   if (not myDemands_.isEmpty ())
      {
      myMsgFac () ("myDemandsHeadingDdMsg");

      forEachEl (theDemand, myDemands_)
         myMsgFac () ("myDemandsDataDdMsg", theDemand->demandName ());
      }

   if (not consumingBomEntries_.isEmpty ())
      {
      myMsgFac () ("consBomHeadingDdMsg");

      forEachEl (theBomEnt, consumingBomEntries_)
         myMsgFac () ("consBomDataDdMsg",
            theBomEnt->myOperationName (), theBomEnt->localIndex ());
      }

   if (not consumingSubEntries_.isEmpty ())
      {
      myMsgFac () ("consSubsHeadingDdMsg");

      forEachEl (theSub, consumingSubEntries_)
         myMsgFac () ("consSubsDataDdMsg",
            theSub->myOperationName (),
            theSub->myBomEnt ()->myPartName (),
            theSub->myBomEntIndex (),
            theSub->localIndex ());
      }

   if (not producingBopEntries_.isEmpty ())
      {
      myMsgFac () ("prodBopHeadingDdMsg");

      forEachEl (theBopEnt, producingBopEntries_)
         myMsgFac () ("prodBopDataDdMsg",
            theBopEnt->myOperationName (),
            theBopEnt->localIndex ());
      }

   if (myPreprocessor ()->preprocessed ())
      if (not producingBopEntries_.isEmpty ())
         {
         myMsgFac () ("expBopHeadDdMsg");

         forEachPeriod (thePer, myProblem ())
            if (explodeable (thePer))
               myMsgFac () ("expBopDataDdMsg",
                  thePer,
                  expBopEntry (thePer)->myOperationName (),
                  expBopEntry (thePer)->localIndex ());
         }

   if (myPreprocessor ()->preprocessed ())
      {
      myMsgFac () ("belowHeadingDdMsg");

      belowList_.attachItr (theItr);

      while (theItr.advance (thePart))
         myMsgFac () ("belowDataDdMsg", thePart->partName ());
      }
d509 2
a510 2
   WitDelComp::display ();
   }
d515 3
a517 3
   {
   return expBopEntry_.isAllocated () and expBopEntry_[thePer] != NULL;
   }
d522 23
a544 23
      WitPeriod          reqPer,
      double             reqQty,
      WitTVec <double> & supply)
   {
   WitPeriod supplyPer;
   double    qty;

   qty = reqQty;

   for (supplyPer = reqPer; supplyPer >= 0; -- supplyPer)
      {
      if (supplyPer < reqPer)
         if (not canStock (supplyPer))
            break;

      if (supply[supplyPer] > NET_TOL)
         {
         WitNonClass::net (qty, supply[supplyPer]);

         if (qty <= NET_TOL)
            return 0.0;
         }
      }
d546 2
a547 2
   return qty;
   }
d552 5
a556 5
   {
   WitPeriod     thePer;
   WitMaterial * theMat;
   WitDemand *   theDemand;
   double        shipVolVal;
d558 1
a558 1
   fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());
d560 9
a568 9
   fprintf (solnFile (),
              "Period"
       "    SupplyVol"
       "      ProdVol"
       "      ConsVol"
       "      ShipVol"
       "     StockVol"
       "     ScrapVol"
       "  ResidualVol");
d570 2
a571 2
   if (myGlobalComp ()->printExcessVol ())
      fprintf (solnFile (), "    ExcessVol");
d573 2
a574 2
   else if (fssComputed ())
      fprintf (solnFile (), "  ShortageVol");
d576 1
a576 1
   fprintf (solnFile (), "\n");
d578 3
a580 3
   forEachPeriod (thePer, myProblem ())
      {
      shipVolVal = 0.0;
d582 2
a583 2
      forEachEl (theDemand, myDemands ())
         shipVolVal += theDemand->shipVol ()[thePer];
d585 1
a585 1
      fprintf (solnFile (), "%6d", thePer);
d587 4
a590 4
      writeSolnValue (supplyVol_[thePer]);
      writeSolnValue (prodVol_  [thePer]);
      writeSolnValue (consVol_  [thePer]);
      writeSolnValue (shipVolVal);
d592 1
a592 1
      theMat = thisMat ();
d594 4
a597 4
      writeSolnValue (
         (theMat != NULL)?
            theMat->stockVol ()[thePer]:
            0.0);
d599 2
a600 2
      writeSolnValue (scrapVol_   [thePer]);
      writeSolnValue (residualVol_[thePer]);
d602 2
a603 2
      if (myGlobalComp ()->printExcessVol ())
         writeSolnValue (myPostprocessor ()->compExcessVol (this, thePer));
d605 2
a606 2
      else if (fssComputed ())
         writeSolnValue (focShortageVol_[thePer]);
d608 3
a610 3
      fprintf (solnFile (), "\n");
      }
   }
d615 2
a616 2
   {
   WitPeriod thePer;
d618 1
a618 1
   witAssert (myOptComp ()->compPrices ());
d620 1
a620 1
   fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());
d622 1
a622 1
   fprintf (solnFile (),"Period  Shadow Price\n");
d624 3
a626 3
   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d ", thePer);
d628 1
a628 1
      writeSolnValue (shadowPrice_[thePer]);
d630 3
a632 3
      fprintf (solnFile (), "\n");
      }
   }
d637 2
a638 2
   {
   WitPeriod thePer;
d640 1
a640 1
   fprintf (solnFile (), "\nPart %s:\n", partName ().myCstring ());
d642 6
a647 6
   fprintf (solnFile (),
              "Period"
       "    SupplyVol"
       "   MrpConsVol"
       "       ReqVol"
       "  MrpResidualVol\n");
d649 3
a651 3
   forEachPeriod (thePer, myProblem ())
      {
      fprintf (solnFile (), "%6d", thePer);
d653 3
a655 3
      writeSolnValue (supplyVol  ()[thePer]);
      writeSolnValue (mrpConsVol ()[thePer]);
      writeSolnValue (reqVol     ()[thePer]);
d657 1
a657 1
      fprintf (solnFile (), "   ");
d659 1
a659 1
      writeSolnValue (mrpResidualVol ()[thePer]);
d661 3
a663 3
      fprintf (solnFile (), "\n");
      }
   }
d668 3
a670 3
   {
   shadowPrice_ = 0.0;
   }
d675 1
a675 1
      WitNode              (theName, theCompMgr),
d677 29
a705 29
      mappingIndex_        (myCompMgr ()->nParts ()),
      myDemands_           (),
      consumingBomEntries_ (),
      consumingSubEntries_ (),
      producingBopEntries_ (),
      supplyVol_           (myProblem (), defSupplyVol        ()),
      singleSource_        (              defSingleSource     ()),
      propRtg_             (myProblem (), defPropRtg          ()),
      boundedLeadTimes_    (              defBoundedLeadTimes ()),
      scrapAllowed_        (              defScrapAllowed     ()),
      scrapCost_           (myProblem (), defScrapCost        ()),
      sortedPartIndex_     (-1),
      expBopEntry_         (),
      belowList_           (),
      expPerGaps_          (false),
      shadowPrice_         (myProblem (), 0.0),
      consVol_             (myProblem (), 0.0),
      prodVol_             (myProblem (), 0.0),
      scrapVol_            (myProblem (), 0.0),
      residualVol_         (myProblem (), 0.0),
      reqVol_              (myProblem (), 0.0),
      mrpConsVol_          (myProblem (), 0.0),
      mrpResidualVol_      (myProblem (), 0.0),
      focShortageVol_      (myProblem (), 0.0)
   {
   if (PART_LIMIT >= 0)
      if (myCompMgr ()->nParts () > PART_LIMIT)
         myMsgFac () ("partLimitExceededSmsg", PART_LIMIT);
   }
d710 3
a712 3
   {
   mappingIndex_ = myCompMgr ()->nParts ();
   }
d717 2
a718 2
   {
   WitNode::writeDataAttrs ();
d720 30
a749 30
   myDataWriter ()->writeVector (
        "supplyVol",
         supplyVol_,
      defSupplyVol ());

   myDataWriter ()->writeBool (
        "singleSource",
         singleSource_,
      defSingleSource ());

   myDataWriter ()->writeVector (
        "propRtg",
         propRtg_,
      defPropRtg ());

   myDataWriter ()->writeBool (
        "boundedLeadTimes",
         boundedLeadTimes_,
      defBoundedLeadTimes ());

   myDataWriter ()->writeBool (
        "scrapAllowed",
         scrapAllowed_,
      defScrapAllowed ());

   myDataWriter ()->writeObjVec (
        "scrapCost",
         scrapCost_,
      defScrapCost ());
   }
d754 2
a755 2
   {
   WitNode::copyAttrsFrom (thePart);
d757 7
a763 7
   supplyVol_        = thePart->supplyVol_;
   singleSource_     = thePart->singleSource_;
   propRtg_          = thePart->propRtg_;
   boundedLeadTimes_ = thePart->boundedLeadTimes_;
   scrapAllowed_     = thePart->scrapAllowed_;
   scrapCost_        = thePart->scrapCost_;
   }
d768 6
a773 6
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (partName ());
   myDataWriter ()->writeKeyWord      (categoryKeyWord ());
   }
d778 6
a783 6
   {
   purgeSelComps (consumingBomEntries_);
   purgeSelComps (consumingSubEntries_);
   purgeSelComps (producingBopEntries_);
   purgeSelComps (myDemands_);
   }
d788 6
a793 6
   {
   consumingBomEntries_.clear ();
   consumingSubEntries_.clear ();
   producingBopEntries_.clear ();
   myDemands_          .clear ();
   }
@


1.169
log
@Lead Time Bounds.
@
text
@a106 2
   stronglyAssert (myGlobalComp ()->ltbAllowed ());

@


1.168
log
@Lead Time Bounds.
@
text
@d105 1
a105 1
void WitPart::setBoundedLeadTime (bool theValue)
d111 1
a111 1
   boundedLeadTime_ = theValue;
d439 1
a439 1
      boundedLeadTime_,
d684 6
a689 6
      supplyVol_           (myProblem (), defSupplyVol       ()),
      singleSource_        (              defSingleSource    ()),
      propRtg_             (myProblem (), defPropRtg         ()),
      boundedLeadTime_     (              defBoundedLeadTime ()),
      scrapAllowed_        (              defScrapAllowed    ()),
      scrapCost_           (myProblem (), defScrapCost       ()),
d738 3
a740 3
        "boundedLeadTime",
         boundedLeadTime_,
      defBoundedLeadTime ());
d759 6
a764 6
   supplyVol_       = thePart->supplyVol_;
   singleSource_    = thePart->singleSource_;
   propRtg_         = thePart->propRtg_;
   boundedLeadTime_ = thePart->boundedLeadTime_;
   scrapAllowed_    = thePart->scrapAllowed_;
   scrapCost_       = thePart->scrapCost_;
@


1.167
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d105 11
d439 1
d684 6
a689 5
      supplyVol_           (myProblem (), defSupplyVol    ()),
      singleSource_        (              defSingleSource ()),
      propRtg_             (myProblem (), defPropRtg      ()),
      scrapAllowed_        (              defScrapAllowed ()),
      scrapCost_           (myProblem (), defScrapCost    ()),
d723 2
a724 2
      "supplyVol",
      supplyVol_,
d728 2
a729 2
      "singleSource",
      singleSource_,
d733 2
a734 2
      "propRtg",
      propRtg_,
d738 7
a744 2
      "scrapAllowed",
      scrapAllowed_,
d748 2
a749 2
      "scrapCost",
      scrapCost_,
d759 6
a764 5
   supplyVol_    = thePart->supplyVol_;
   singleSource_ = thePart->singleSource_;
   propRtg_      = thePart->propRtg_;
   scrapAllowed_ = thePart->scrapAllowed_;
   scrapCost_    = thePart->scrapCost_;
@


1.166
log
@Multi-objective mode
@
text
@d20 1
a20 1
#include <Global.h>
@


1.165
log
@Multi-Objective Mode
@
text
@d120 1
a120 1
   scrapCostObjVec_ = theValue;
d244 1
a244 1
   scrapCostObjVec_ = theFlexVec;
d331 1
a331 1
   scrapCostObjVec_.writeDataMulti ("scrapCost", this, theObj);
d434 1
a434 1
   myProblem ()->display ("scrapCostDdMsg",    scrapCostObjVec_);
d676 1
a676 1
      scrapCostObjVec_     (myProblem (), defScrapCost    ()),
d731 1
a731 1
      scrapCostObjVec_,
d741 5
a745 5
   supplyVol_       = thePart->supplyVol_;
   singleSource_    = thePart->singleSource_;
   propRtg_         = thePart->propRtg_;
   scrapAllowed_    = thePart->scrapAllowed_;
   scrapCostObjVec_ = thePart->scrapCostObjVec_;
@


1.164
log
@Multi-Objective Mode
@
text
@d120 1
a120 1
   scrapCost_ = theValue;
d244 1
a244 1
   scrapCost_ = theFlexVec;
d331 1
a331 1
   scrapCost_.writeDataMulti ("scrapCost", this, theObj);
d434 1
a434 1
   myProblem ()->display ("scrapCostDdMsg",    scrapCost_);
d676 1
a676 1
      scrapCost_           (myProblem (), defScrapCost    ()),
d731 1
a731 1
      scrapCost_,
d741 5
a745 5
   supplyVol_    = thePart->supplyVol_;
   singleSource_ = thePart->singleSource_;
   propRtg_      = thePart->propRtg_;
   scrapAllowed_ = thePart->scrapAllowed_;
   scrapCost_    = thePart->scrapCost_;
@


1.163
log
@Multi-Objective Mode
@
text
@d672 5
a676 5
      supplyVol_           (myProblem (), defSupplyVol ()),
      singleSource_        (defSingleSource ()),
      propRtg_             (myProblem (), defPropRtg ()),
      scrapAllowed_        (defScrapAllowed ()),
      scrapCost_           (myProblem ()),
@


1.162
log
@Multi-Objective Mode
@
text
@d729 4
a732 1
   scrapCost_.writeDataSingle ("scrapCost");
@


1.161
log
@Multi-Objective Mode
@
text
@d434 1
a434 3

   scrapCost_   .display ("scrapCostDdMsg");

@


1.160
log
@Multi-Objective Mode
@
text
@d120 1
a120 1
   scrapCost_.curDblFlexVec () = theValue;
d244 1
a244 1
   scrapCost_.curDblFlexVec () = theFlexVec;
d744 1
a744 2

   scrapCost_.copyFrom (thePart->scrapCost_);
@


1.159
log
@Multi-Objective Mode
@
text
@a42 1
   delete scrapCost_;
d120 1
a120 1
   scrapCost_->curDblFlexVec () = theValue;
d244 1
a244 1
   scrapCost_->curDblFlexVec () = theFlexVec;
d331 1
a331 1
   scrapCost_->writeDataMulti ("scrapCost", this, theObj);
d435 1
a435 1
   scrapCost_  ->display ("scrapCostDdMsg");
d678 1
a678 1
      scrapCost_           (NULL),
a695 2

   scrapCost_ = newObjVec (myProblem ());
d731 1
a731 1
   scrapCost_->writeDataSingle ("scrapCost");
d745 1
a745 1
   scrapCost_->copyFrom (thePart->scrapCost_);
@


1.158
log
@Multi-Objective Mode
@
text
@d43 1
d121 1
a121 1
   scrapCost_ = theValue;
d245 1
a245 1
   scrapCost_ = theFlexVec;
d330 7
d435 3
a437 1
   myProblem ()->display ("scrapCostDdMsg",    scrapCost_);
d679 1
a679 1
      scrapCost_           (myProblem (), defScrapCost ()),
d697 2
d734 1
a734 4
   myDataWriter ()->writeVector (
        "scrapCost",
        scrapCost_,
        defScrapCost ());
d747 2
a748 1
   scrapCost_    = thePart->scrapCost_;
@


1.157
log
@Removing objective #2.
@
text
@d375 9
@


1.156
log
@Removing objective #2.
@
text
@a21 1
#include <ObjFunc.h>
@


1.155
log
@Removing objective #2.
@
text
@d419 2
a420 4

   objChoice ()->displayForObj1 ("scrapCostDdMsg", scrapCost_);

   myProblem ()->display ("propRtgDdMsg", propRtg_);
@


1.154
log
@Object name change.
@
text
@a105 11
void WitPart::setUnitCost (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   unitCost_ = theValue;
   }

//------------------------------------------------------------------------------

a417 2
   objChoice ()->displayForObj2 ("partUnitCostDdMsg", unitCost_);

a661 1
      unitCost_            (defUnitCost ()),
a710 5
   myDataWriter ()->writeDouble (
      "unitCost",
      unitCost_,
      defUnitCost ());

a730 1
   unitCost_     = thePart->unitCost_;
@


1.153
log
@Stochastic Implosion
@
text
@d66 7
@


1.152
log
@Stochastic Implosion
@
text
@d123 1
a123 1
   prepSetUnpostAttr ();
d245 9
@


1.151
log
@Stochastic Implosion
@
text
@d72 1
a72 1
   prepSetStochModeAttr ("supplyVol");
@


1.150
log
@Stochastic Implosion
@
text
@a73 4
   if (DEBUG_MODE)
      if (myStochImpMgr ()->stochMode ())
         witAssert (myStochImpMgr ()->stageIndex (this) != 0);

@


1.149
log
@Stochastic Implosion
@
text
@d136 51
a186 1
void WitPart::storePostConsVol (const WitTVec <double> & theValue)
d190 1
a190 1
   consVol_ = theValue;
d195 1
a195 1
void WitPart::storePostProdVol (const WitTVec <double> & theValue)
d199 1
a199 1
   prodVol_ = theValue;
d204 1
a204 1
void WitPart::storePostScrapVol (const WitTVec <double> & theValue)
d208 1
a208 1
   scrapVol_ = theValue;
d213 1
a213 1
void WitPart::storePostResidualVol (const WitTVec <double> & theValue)
d217 1
a217 1
   residualVol_ = theValue;
d240 1
a240 1
void WitPart::storeStochSupplyVol (const WitDblFlexVec & theValue)
d244 1
a244 1
   supplyVol_ = theValue;
d249 1
a249 1
void WitPart::storeStochScrapVol (const WitDblFlexVec & theValue)
d253 1
a253 1
   scrapVol_ = theValue;
d258 1
a258 1
void WitPart::storeMrpReqVol (const WitTVec <double> & theValue)
d262 1
a262 1
   reqVol_ = theValue;
d267 1
a267 1
void WitPart::storeMrpMrpConsVol (const WitTVec <double> & theValue)
d271 1
a271 1
   mrpConsVol_ = theValue;
d276 1
a276 1
void WitPart::storeMrpMrpResidualVol (const WitTVec <double> & theValue)
d280 1
a280 1
   mrpResidualVol_ = theValue;
d285 1
a285 1
void WitPart::storeFssFocShortageVol (const WitTVec <double> & theValue)
d289 1
a289 1
   focShortageVol_ = theValue;
a328 14
void WitPart::passPreRefs ()
   {
   myPreprocessor ()->
      receiveRefs (
         this, 
         expPerGaps_,
         producingBopEntries_,
         expBopEntry_,
         sortedPartIndex_,
         belowList_);
   }

//------------------------------------------------------------------------------

@


1.148
log
@Stochastic Implosion
@
text
@d235 9
a311 7
void WitPart::passFssRefs ()
   {
   myFSS ()->receivePartRefs (focShortageVol_);
   }

//------------------------------------------------------------------------------

@


1.147
log
@Stochastic Implosion
@
text
@d208 27
a302 7
void WitPart::passMrpRefs ()
   {
   myOrigMrpExp ()->receivePartRefs (reqVol_, mrpConsVol_, mrpResidualVol_);
   }

//------------------------------------------------------------------------------

@


1.146
log
@Stochastic Implosion
@
text
@d172 18
d266 6
a271 3
void WitPart::importOptSoln ()
   {
   myDetOptImpMgr ()->exportSoln (this, scrapVol_, shadowPrice_);
@


1.145
log
@Stochastic Implosion
@
text
@d136 36
@


1.144
log
@Stochastic Implosion
@
text
@d76 1
a76 1
         witAssert (myStochImpMgr ()->stageNo (this) != 0);
@


1.143
log
@Stochastic Implosion
@
text
@d233 12
@


1.142
log
@Stochastic Implosion
@
text
@d74 4
@


1.141
log
@Stochastic Implosion
@
text
@d132 1
a132 1
void WitPart::storeStochSupplyVol (const WitTVec <double> & theValue)
d141 1
a141 1
void WitPart::storeStochScrapVol (const WitTVec <double> & theValue)
@


1.140
log
@Stochastic Implosion
@
text
@d134 3
a136 1
   storeStochAttr (supplyVol_, theValue);
d143 3
a145 1
   storeStochAttr (scrapVol_, theValue);
@


1.139
log
@Stochastic Implosion
@
text
@a239 9
void WitPart::writeDataSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("part");
   myDataWriter ()->writeStringValue  (partName ());
   }

//------------------------------------------------------------------------------

@


1.138
log
@Stochastic Implosion
@
text
@d132 1
a132 1
void WitPart::loadInStochSupplyVol (const WitTVec <double> & theValue)
d134 1
a134 1
   loadInStochAttr (supplyVol_, theValue);
d139 1
a139 1
void WitPart::loadInStochScrapVol (const WitTVec <double> & theValue)
d141 1
a141 1
   loadInStochAttr (scrapVol_, theValue);
@


1.137
log
@Stochastic Implosion
@
text
@d132 1
a132 1
void WitPart::loadInStochSupplyVol (const WitTVec <double> & supplyVolArg)
d134 8
a141 1
   loadInStochAttr (supplyVol_, supplyVolArg);
a210 7
void WitPart::importStochSoln ()
   {
   myStochImpMgr ()->exportSoln (this, scrapVol_);
   }

//------------------------------------------------------------------------------

@


1.136
log
@Stochastic Implosion
@
text
@d132 7
a203 7
void WitPart::importStochInput ()
   {
   myStochImpMgr ()->exportInput (this, supplyVol_);
   }

//------------------------------------------------------------------------------

@


1.135
log
@Stochastic Implosion
@
text
@d28 1
a28 1
#include <OptImp.h>
d192 1
a192 1
   myOptImploder ()->exportSoln (this, scrapVol_, shadowPrice_);
@


1.134
log
@Stochastic Implosion
@
text
@a287 2
   myStochImpMgr ()->display (this);

@


1.133
log
@Stochastic Implosion
@
text
@d72 1
a72 1
   prepSetStochModeAttr ();
@


1.132
log
@Stochastic Implosion
@
text
@a573 2
   myStochImpMgr ()->prepWriteStochAttr ();

@


1.131
log
@Stochastic Implosion
@
text
@d72 1
a72 3
   myStochImpMgr ()->prepStochModeAttr ();

   prepSetUnpostAttr ();
@


1.130
log
@Stochastic Implosion
@
text
@d72 2
d199 7
d242 9
d282 3
a284 2
   myMsgFac () ("partDdMsg",
      partName (),
d576 2
@


1.129
log
@Stochastic Implosion
@
text
@d190 1
a190 1
void WitPart::acquireOptSoln ()
d192 1
a192 1
   myOptImploder ()->provideSoln (this, scrapVol_, shadowPrice_);
d197 1
a197 1
void WitPart::passMrpRefs ()
d199 1
a199 1
   myOrigMrpExp ()->receivePartRefs (reqVol_, mrpConsVol_, mrpResidualVol_);
d204 1
a204 1
void WitPart::passFssRefs ()
d206 1
a206 1
   myFSS ()->receivePartRefs (focShortageVol_);
d211 1
a211 1
void WitPart::passStochRefs ()
d213 1
a213 1
   myStochImpMgr ()->receivePartRefs (scrapVol_);
@


1.128
log
@Stochastic Implosion
@
text
@d192 1
a192 1
   myOptImploder ()->providePartSoln (scrapVol_, shadowPrice_);
@


1.127
log
@Stochastic Implosion
@
text
@a25 1
#include <PreData.h>
a180 8
void WitPart::importPreData ()
   {
   sortedPartIndex_     = expPreData ()->sortedPartIndex ()  (this);
   producingBopEntries_ = expPreData ()->producingBopEntries (this);
   }

//------------------------------------------------------------------------------

@


1.126
log
@Stochastic Implosion
@
text
@d168 14
@


1.125
log
@Stochastic Implosion
@
text
@d170 2
a171 1
   sortedPartIndex_ = expPreData ()->sortedPartIndex () (this);
@


1.124
log
@Stochastic Implosion
@
text
@d26 1
d168 7
@


1.123
log
@Stochastic Implosion
@
text
@d176 1
a176 1
void WitPart::importOptImpSoln (WitPeriod thePer)
d178 1
a178 5
   scrapVol_.elemRef (thePer) = myOptImploder ()->scrapVol (this, thePer);

   if (myOptComp ()->compPrices ())
      shadowPrice_.elemRef (thePer) =
         myOptImploder ()->shadowPrice (this, thePer);
@


1.122
log
@Stochastic Implosion
@
text
@d187 1
a187 1
void WitPart::passMrpData ()
d189 1
a189 1
   myOrigMrpExp ()->receivePartData (reqVol_, mrpConsVol_, mrpResidualVol_);
d194 1
a194 1
void WitPart::passFssData ()
d196 1
a196 1
   myFSS ()->receivePartData (focShortageVol_);
d201 1
a201 1
void WitPart::passStochData ()
d203 1
a203 1
   myStochImpMgr ()->receivePartData (scrapVol_);
@


1.121
log
@Stochastic Implosion
@
text
@d189 1
a189 6
   myOrigMrpExp ()->
      receiveData (
         this,
         reqVol_,
         mrpConsVol_,
         mrpResidualVol_);
@


1.120
log
@Stochastic Implosion
@
text
@d189 6
a194 5
   myOrigMrpExp ()->receiveData (
      this,
      reqVol_,
      mrpConsVol_,
      mrpResidualVol_);
d201 1
a201 1
   myFSS ()->receiveData (this, focShortageVol_);
d208 1
a208 2
   myStochImpMgr ()->
      receivePartData (scrapVol_);
@


1.119
log
@Stochastic Implosion
@
text
@d205 1
a205 1
void WitPart::clearStochSoln ()
d207 2
a208 8
   scrapVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitPart::restoreStochSoln ()
   {
   scrapVol_ = myStochImpMgr ()->scrapVol (this);
@


1.118
log
@Stochastic Implosion
@
text
@d272 2
@


1.117
log
@Stochastic Implosion
@
text
@d187 1
a187 1
void WitPart::importMrpSoln ()
d189 5
a193 3
   reqVol_         = myOrigMrpExp ()->reqVol         (this);
   mrpConsVol_     = myOrigMrpExp ()->mrpConsVol     (this);
   mrpResidualVol_ = myOrigMrpExp ()->mrpResidualVol (this);
@


1.116
log
@Stochastic Implosion
@
text
@d27 1
d196 7
@


1.115
log
@Stochastic Implosion
@
text
@d28 1
d186 9
@


1.114
log
@Stochastic Implosion
@
text
@a164 22
void WitPart::identifyInstance ()
   {
   if (myMsgFac ().mayIssue ("partInstIDMsg"))
      myMsgFac () ("partInstIDMsg", partName ());
   }

//------------------------------------------------------------------------------

WitMsgFrag WitPart::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("partFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitPart::apiObjItrState ()
   {
   return WitAT_PART;
   }

//------------------------------------------------------------------------------

d206 22
@


1.113
log
@Stochastic Implosion
@
text
@d27 1
d196 11
@


1.112
log
@Stochastic Implosion
@
text
@d27 1
d195 14
@


1.111
log
@Stochastic implosion.
@
text
@d68 1
a68 1
   settingUnpostAttr ();
d77 1
a77 1
   settingUnpostAttr ();
d88 1
a88 1
   settingUnpostAttr ();
d99 1
a99 1
   settingUnpostAttr ();
d108 1
a108 1
   settingUnpreAttr ();
d119 1
a119 1
   settingUnpostAttr ();
@


1.110
log
@Stochastic Implosion.
@
text
@d68 1
a68 1
   myProblem ()->resetSoln ();
d77 1
a77 1
   myProblem ()->resetSoln ();
d88 1
a88 1
   myProblem ()->resetSoln ();
d99 1
a99 1
   myProblem ()->resetSoln ();
d108 1
a108 1
   myPreprocessor ()->unpreprocess ();
d119 1
a119 1
   myProblem ()->resetSoln ();
@


1.109
log
@Stochastic Implosion.
@
text
@a490 2
   forbidAddStochAct ();

@


1.108
log
@Stochastic implosion.
@
text
@d29 1
d163 1
a163 1
WitMsgFragID WitPart::classFragID ()
d165 2
a166 1
   return "partFrag";
d171 1
a171 1
void WitPart::identifyInstance ()
d173 1
a173 2
   if (myMsgFac ().mayIssue ("partInstIDMsg"))
      myMsgFac () ("partInstIDMsg", partName ());
d491 1
a491 1
   forbidAddStochAct ("partFrag");
@


1.107
log
@[disallowed scrap]
@
text
@d490 2
@


1.106
log
@[disallowing scrap]
@
text
@a106 2
   stronglyAssert (myGlobalComp ()->allowSA ());

@


1.105
log
@[disallowed backlog]
@
text
@d105 11
d223 2
a224 1
      singleSource_);
d476 1
d530 5
d551 1
@


1.104
log
@[disallowed backlog]
@
text
@a26 3
#include <FSS.h>
#include <OrigMrp.h>
#include <OptImp.h>
a451 16
void WitPart::transmitDMPs ()
   {
   WitOptImploder  ::receiveDMPs (& WitPart::scrapVol_,
                                  & WitPart::shadowPrice_);
   WitPostprocessor::receiveDMPs (& WitPart::consVol_,
                                  & WitPart::prodVol_,
                                  & WitPart::scrapVol_,
                                  & WitPart::residualVol_);
   WitOrigMrpExp   ::receiveDMPs (& WitPart::reqVol_,
                                  & WitPart::mrpConsVol_,
                                  & WitPart::mrpResidualVol_);
   WitFSS          ::receiveDMPs (& WitPart::focShortageVol_);
   }

//------------------------------------------------------------------------------

@


1.103
log
@Rescinded all changed made since 1/31/07.
@
text
@a456 5
   WitPreprocessor ::receiveDMPs (& WitPart::expPerGaps_,
                                  & WitPart::producingBopEntries_,
                                  & WitPart::expBopEntry_,
                                  & WitPart::sortedPartIndex_,
                                  & WitPart::belowList_);
@


1.102
log
@[disallowed backlog]
@
text
@a25 1
#include <AvSorter.h>
d50 1
a50 1
   return expBopEntry_.myValue ()[thePer];
d178 9
d218 1
a218 1
      myMsgFac () ("partPreDdMsg", sortedPartIndex (), expPerGaps_.myValue ());
d284 1
a284 1
      belowList ().attachItr (theItr);
a294 13
void WitPart::sortBopEntries (WitProblem * theProblem)
   {
   WitPart * thePart;

   WitAvSorter <WitBopEntry> theSorter (
      theProblem->myCompMgr ()->nBopEntries ());

   forEachPart (thePart, theProblem)
      theSorter.sort (thePart->producingBopEntries_);
   }

//------------------------------------------------------------------------------

d297 1
a297 3
   return
           expBopEntry_.myValue ().isAllocated ()
      and (expBopEntry_.myValue ()[thePer] != NULL);
d369 2
a370 2
      writeSolnValue (prodVol ()[thePer]);
      writeSolnValue (consVol ()[thePer]);
d380 2
a381 2
      writeSolnValue (scrapVol ()   [thePer]);
      writeSolnValue (residualVol ()[thePer]);
d387 1
a387 1
         writeSolnValue (focShortageVol ()[thePer]);
d409 1
a409 1
      writeSolnValue (shadowPrice ()[thePer]);
d448 28
a478 14
      sortedPartIndex_     (-1),
      expBopEntry_         (),
      belowList_           (),
      expPerGaps_          (false),
      prodVol_             (myProblem ()),
      consVol_             (myProblem ()),
      residualVol_         (myProblem ()),
      scrapVol_            (myProblem ()),
      shadowPrice_         (myProblem ()),
      reqVol_              (myProblem ()),
      mrpConsVol_          (myProblem ()),
      mrpResidualVol_      (myProblem ()),
      focShortageVol_      (myProblem ()),

d488 14
a501 1
      scrapCost_           (myProblem (), defScrapCost ())
@


1.101
log
@[disallowed backlog]
@
text
@d26 1
d287 13
d394 1
a394 1
         writeSolnValue (focShortageVol_[thePer]);
d416 1
a416 1
      writeSolnValue (shadowPrice_[thePer]);
a454 24
void WitPart::resetShadowPrice ()
   {
   shadowPrice_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitPart::transmitDMPs ()
   {
   WitPreprocessor ::receiveDMPs (  NULL,
                                  & WitPart::producingBopEntries_,
                                    NULL,
                                    NULL,
                                    NULL);
   WitOptImploder  ::receiveDMPs (  NULL,
                                  & WitPart::shadowPrice_);
   WitOrigMrpExp   ::receiveDMPs (& WitPart::reqVol_,
                                  & WitPart::mrpConsVol_,
                                  & WitPart::mrpResidualVol_);
   WitFSS          ::receiveDMPs (& WitPart::focShortageVol_);
   }

//------------------------------------------------------------------------------

d466 5
d481 1
a481 6
      scrapCost_           (myProblem (), defScrapCost ()),
      shadowPrice_         (myProblem (), 0.0),
      reqVol_              (myProblem (), 0.0),
      mrpConsVol_          (myProblem (), 0.0),
      mrpResidualVol_      (myProblem (), 0.0),
      focShortageVol_      (myProblem (), 0.0)
@


1.100
log
@[disallowed backlog]
@
text
@d50 1
a50 1
   return expBopEntry_[thePer];
a177 9
void WitPart::unpreprocess ()
   {
   expBopEntry_.clear ();

   belowList_.resize (0);
   }

//------------------------------------------------------------------------------

d209 1
a209 1
      myMsgFac () ("partPreDdMsg", sortedPartIndex (), expPerGaps_);
d275 1
a275 1
      belowList_.attachItr (theItr);
d288 3
a290 1
   return expBopEntry_.isAllocated () and expBopEntry_[thePer] != NULL;
d450 1
a450 1
   WitPreprocessor ::receiveDMPs (& WitPart::expPerGaps_,
d452 3
a454 3
                                  & WitPart::expBopEntry_,
                                  NULL,
                                  & WitPart::belowList_);
d469 3
a486 3
      expBopEntry_         (),
      belowList_           (),
      expPerGaps_          (false),
@


1.99
log
@[disallowed backlog]
@
text
@d218 1
a218 1
      myMsgFac () ("partPreDdMsg", sortedPartIndex_, expPerGaps_);
d460 1
a460 1
                                  & WitPart::sortedPartIndex_,
d475 1
a490 1
      sortedPartIndex_     (-1),
@


1.98
log
@[disallowed backlog]
@
text
@d13 1
a13 5
// Contains the implementation of the following classes:
//
//    PartPostData
//    PartOptPostData
//    Part
a36 32
// Implementation of class PartPostData.
//------------------------------------------------------------------------------

WitPartPostData::WitPartPostData (WitProblem * theProblem):
      prodVol_     (theProblem, 0.0),
      consVol_     (theProblem, 0.0),
      residualVol_ (theProblem, 0.0)
   {
   }

//------------------------------------------------------------------------------

WitPartPostData::~WitPartPostData ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class PartOptPostData.
//------------------------------------------------------------------------------

WitPartOptPostData::WitPartOptPostData (WitProblem * theProblem):
      scrapVol_ (theProblem, 0.0)
   {
   }

//------------------------------------------------------------------------------

WitPartOptPostData::~WitPartOptPostData ()
   {
   }

//------------------------------------------------------------------------------
d475 5
d498 1
a498 4
      focShortageVol_      (myProblem (), 0.0),

      myPostData_          (myProblem ()),
      myOptPostData_       (myProblem ())
@


1.97
log
@Disallowed backlog.
@
text
@d16 1
d45 3
a47 1
      prodVol_ (theProblem, 0.0)
d58 15
d406 1
a406 1
      writeSolnValue (consVol_  [thePer]);
d416 2
a417 2
      writeSolnValue (scrapVol_   [thePer]);
      writeSolnValue (residualVol_[thePer]);
d498 1
a498 1
   WitOptImploder  ::receiveDMPs (& WitPart::scrapVol_,
a499 3
   WitPostprocessor::receiveDMPs (& WitPart::consVol_,
                                  & WitPart::scrapVol_,
                                  & WitPart::residualVol_);
a525 3
      consVol_             (myProblem (), 0.0),
      scrapVol_            (myProblem (), 0.0),
      residualVol_         (myProblem (), 0.0),
d531 2
a532 1
      myPostData_          (myProblem ())
@


1.96
log
@[disAllowed backlog]
@
text
@d13 4
a16 1
// Contains the implementation of class Part.
d40 15
d387 1
a387 1
      writeSolnValue (prodVol_  [thePer]);
d482 1
a482 2
   WitPostprocessor::receiveDMPs (& WitPart::prodVol_,
                                  & WitPart::consVol_,
a510 1
      prodVol_             (myProblem (), 0.0),
d517 3
a519 1
      focShortageVol_      (myProblem (), 0.0)
@


1.95
log
@[backlog avoidance]
@
text
@d369 1
a369 1
      writeSolnValue (prodVol ()[thePer]);
d464 2
a465 1
   WitPostprocessor::receiveDMPs (& WitPart::consVol_,
a478 2
      prodVol              (myProblem ()),

d494 1
@


1.94
log
@witCopy<Object>Data
@
text
@d369 1
a369 1
      writeSolnValue (prodVol_  [thePer]);
a464 1
                                  & WitPart::prodVol_,
d478 2
a495 1
      prodVol_             (myProblem (), 0.0),
@


1.93
log
@App controlled opt implosion.
@
text
@a200 7
bool WitPart::isaCapacity ()
   {
   return (thisCap () != NULL);
   }

//------------------------------------------------------------------------------

d213 1
a213 1
      myMsgFac ().myFrag (categoryFragID ()),
@


1.92
log
@App controlled opt implosion.
@
text
@a24 1
#include <DataAlt.h>
d66 7
a72 1
   supplyVol_ = prepNonNegDblVec (theValue, postprocAlt ());
d79 3
a81 1
   singleSource_ = prepBool (theValue, postprocAlt ());
d88 5
a92 1
   copy (propRtg_, prepBoolVec (theValue, postprocAlt ()));
d99 5
a103 1
   unitCost_ = prepNonNegDouble (theValue, postprocAlt ());
d110 5
a114 1
   scrapCost_ = prepDblVec (theValue, postprocAlt ());
@


1.91
log
@NSTN residualVol.
@
text
@d205 1
a205 1
   if (myProblem ()->preprocessed ())
d255 1
a255 1
   if (myProblem ()->preprocessed ())
d268 1
a268 1
   if (myProblem ()->preprocessed ())
@


1.90
log
@NSTN residualVols
@
text
@d339 4
a342 1
   if (fssComputed ())
d371 4
a374 1
      if (fssComputed ())
@


1.89
log
@Updated the copyright date on all source files.
@
text
@d20 2
d353 3
a355 3
      writeSolnValue (supplyVol ()[thePer]);
      writeSolnValue (prodVol   ()[thePer]);
      writeSolnValue (consVol   ()[thePer]);
d365 2
a366 2
      writeSolnValue (scrapVol    ()[thePer]);
      writeSolnValue (residualVol ()[thePer]);
d369 1
a369 1
         writeSolnValue (focShortageVol ()[thePer]);
d448 2
a449 1
                                  & WitPart::scrapVol_);
d474 1
d479 1
a479 1
      expPerGaps_          (false),
@


1.88
log
@Fixed a bug:
   part.scrapVol was not being copied by witCopyData.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.87
log
@[shared-resource pegging]
@
text
@d531 1
d535 1
a535 1
   supplyVol_    = thePart->supplyVol_;
@


1.86
log
@Clean up from cvs test.
@
text
@d189 7
a195 6
   WitDemand   * theDemand;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
   WitPart     * theBelowPart;
   WitPeriod     thePer;
d270 4
a273 2
      forEachElDense (theBelowPart, belowList_)
         myMsgFac () ("belowDataDdMsg", theBelowPart->partName ());
@


1.85
log
@CVS Test.
@
text
@a14 1
// CVS test V3
@


1.84
log
@*** empty log message ***
@
text
@d15 1
a15 1
// CVS test V2
@


1.83
log
@*** empty log message ***
@
text
@d15 1
a15 1
// CVS test
@


1.82
log
@[multi-thread]
@
text
@d15 1
@


1.81
log
@[multi-thread]
@
text
@a31 2
#include <PtrTVec.h>
#include <Dense.h>
a38 7
void WitPart::transmitData ()
   {
   WitPostprocessor::receiveData (& WitPart::consVol_);
   }

//------------------------------------------------------------------------------

a40 2
   delete & belowList_;
   delete & expBopEntry_;
a172 45
void WitPart::loadPre ()
   {
   myPreprocessor ()->loadDataFrom (
      this, 
      sortedPartIndex_,
      expPerGaps_,
      producingBopEntries_,
      expBopEntry_,
      belowList_);
   }

//------------------------------------------------------------------------------

void WitPart::loadPost ()
   {
   myPostprocessor ()->loadDataFrom (this, consVol_, prodVol_, scrapVol_);
   }

//------------------------------------------------------------------------------

void WitPart::loadMrp ()
   {
   myOrigMrpExp ()->loadDataFrom (
      this, 
      reqVol_, 
      mrpConsVol_, 
      mrpResidualVol_);
   }

//------------------------------------------------------------------------------

void WitPart::loadFss ()
   {
   myFSS ()->loadDataFrom (this, focShortageVol_);
   }

//------------------------------------------------------------------------------

void WitPart::loadOpt ()
   {
   myOptImploder ()->loadDataFrom (this, scrapVol_, shadowPrice_);
   }

//------------------------------------------------------------------------------

d432 20
d466 2
a467 2
      expBopEntry_         (* new WitPtrTVec <WitBopEntry>),
      belowList_           (* new WitDenseList <WitPart>),
@


1.80
log
@Fixed a bug in witWriteData.
@
text
@d41 7
@


1.79
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@a548 5

   myDataWriter ()->writeVector (
        "scrapCost",
        scrapCost_,
        defScrapCost ());
@


1.78
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d95 1
a95 1
void WitPart::setObj1ScrapCost (const WitIVRealArg & theValue)
d97 1
a97 1
   obj1ScrapCost_ = prepDblVec (theValue, postprocAlt ());
d258 1
a258 1
   objChoice ()->displayForObj1 ("obj1ScrapDdMsg", obj1ScrapCost_);
d493 1
a493 1
      obj1ScrapCost_       (myProblem (), defObj1ScrapCost ()),
d546 8
a553 3
        "obj1ScrapCost",
        obj1ScrapCost_,
        defObj1ScrapCost ());
d562 4
a565 5
   singleSource_  = thePart->singleSource_;
   propRtg_       = thePart->propRtg_;
   unitCost_      = thePart->unitCost_;
   supplyVol_     = thePart->supplyVol_;
   obj1ScrapCost_ = thePart->obj1ScrapCost_;
@


1.77
log
@Vector PropRtg.
@
text
@d97 1
a97 1
   obj1ScrapCost_ = prepObj1DblVec (theValue, postprocAlt ());
@


1.76
log
@Vector PropRtg.
@
text
@a36 2
#include <Global.h>

a80 7
void WitPart::setPropRouting (bool theValue)
   {
   propRtg_ = prepBool (theValue, postprocAlt ());
   }

//------------------------------------------------------------------------------

a82 2
   stronglyAssert (myGlobalComp ()->allowVecPR ());

d249 1
a249 2
      singleSource_,
      propRtg_[0]);
d260 1
a260 2
   if (myGlobalComp ()->allowVecPR ())
      myProblem ()->display ("propRtgDdMsg", propRtg_);
d535 4
a538 10
   if (myGlobalComp ()->allowVecPR ())
      myDataWriter ()->writeVector (
         "propRtg",
         propRtg_,
         defPropRtg ());
   else
      myDataWriter ()->writeBool (
         "propRouting",
         propRtg_[0],
         defPropRtg ());
@


1.75
log
@Vector PropRtg.
@
text
@d85 1
a85 1
   propRtg_     = prepBool (theValue, postprocAlt ());
a93 2
   stronglyAssert (hasSingleValue (theValue, nPeriods ()));

@


1.74
log
@Vector PropRtg.
@
text
@d85 1
a85 3
   propRouting_ = prepBool (theValue, postprocAlt ());

   propRtg_     = propRouting_;
a96 2

   propRouting_ = propRtg_[0];
d263 1
a263 1
      propRouting_);
a505 1
      propRouting_         (defPropRouting ()),
d558 2
a559 2
         propRouting_,
         defPropRouting ());
a578 1
   propRouting_   = thePart->propRouting_;
@


1.73
log
@Vector Prop-Rtg.
@
text
@d87 1
a87 1
   propRt_      = propRouting_;
d92 1
a92 1
void WitPart::setPropRt (const WitBoolean * theValue)
d98 1
a98 1
   copy (propRt_, prepBoolVec (theValue, postprocAlt ()));
d100 1
a100 1
   propRouting_ = propRt_[0];
d279 1
a279 1
      myProblem ()->display ("propRtDdMsg", propRt_);
d511 1
a511 1
      propRt_              (myProblem (), defPropRt ()),
d557 3
a559 3
         "propRt",
         propRt_,
         defPropRt ());
d585 1
a585 1
   propRt_        = thePart->propRt_;
@


1.72
log
@Vector PropRt.
@
text
@d87 1
a87 2
   if (myGlobalComp ()->allowVecPR ())
      propRt_ = propRouting_;
d96 2
a554 5
   myDataWriter ()->writeBool (
      "propRouting",
      propRouting_,
      defPropRouting ());

d560 5
@


1.71
log
@Vector PropRt.
@
text
@d86 3
d98 2
@


1.70
log
@Vector PropRt.
@
text
@d37 2
a89 2
#include <Global.h>

@


1.69
log
@Vector PropRt.
@
text
@a88 1
#include <ApiMgr.h>
a91 3
   WitFlexVec <WitBoolean> propRtAsWB (myProblem (), false);
   WitPeriod               thePer;

d94 1
a94 7
   propRtAsWB = prepBoolVec (theValue, postprocAlt ());

   if (propRtAsWB == propRtAsWB[0])
      propRt_ = asaBool (propRtAsWB[0]);
   else
      forEachPeriod (thePer, myProblem ())
         propRt_.elemRef (thePer) = asaBool (propRtAsWB[thePer]);
@


1.68
log
@Vector Prop-Rt.
@
text
@d34 1
a34 1
#include <InVecRA.h>
d67 1
a67 1
void WitPart::setSupplyVol (const WitInVecRA & theValue)
d116 1
a116 1
void WitPart::setObj1ScrapCost (const WitInVecRA & theValue)
@


1.67
log
@Vector PropRt.
@
text
@a564 7
      {
      WitTVec <int> propRtAsIntVec (myProblem (), 0);
      WitPeriod     thePer;

      forEachPeriod (thePer, myProblem ())
         propRtAsIntVec[thePer] = (propRt_[thePer]? 1: 0);

d567 2
a568 3
         propRtAsIntVec,
         defPropRt ()? 1: 0);
      }
@


1.66
log
@Vector propRt.
@
text
@d283 1
a283 8
      {
      WitFlexVec <int> propRtAsIntVec (myProblem (), 0);

      forEachPeriod (thePer, myProblem ())
         propRtAsIntVec.elemRef (thePer) = (propRt_[thePer]? 1: 0);

      myProblem ()->display ("propRtDdMsg", propRtAsIntVec);
      }
@


1.65
log
@Pegged critical list.
@
text
@d88 21
d267 1
a267 1
      partName   (),
d270 2
a271 2
      singleSource (),
      propRouting ());
d276 1
a276 1
   objChoice ()->displayForObj2 ("partUnitCostDdMsg", unitCost ());
d278 1
a278 1
   myProblem ()->display ("extSupplyVolDdMsg", supplyVol ());
d280 1
a280 1
   objChoice ()->displayForObj1 ("obj1ScrapDdMsg", obj1ScrapCost ());
d282 11
a292 1
   if (not myDemands ().isEmpty ())
d296 1
a296 1
      forEachEl (theDemand, myDemands ())
d300 1
a300 1
   if (not consumingBomEntries ().isEmpty ())
d304 1
a304 1
      forEachEl (theBomEnt, consumingBomEntries ())
d309 1
a309 1
   if (not consumingSubEntries ().isEmpty ())
d313 1
a313 1
      forEachEl (theSub, consumingSubEntries ())
d321 1
a321 1
   if (not producingBopEntries ().isEmpty ())
d325 1
a325 1
      forEachEl (theBopEnt, producingBopEntries ())
d332 1
a332 1
      if (not producingBopEntries ().isEmpty ())
d348 1
a348 1
      forEachElDense (theBelowPart, belowList ())
d522 1
d571 14
d604 1
@


1.64
log
@Fixed a bug in the screening of the optimization model.
@
text
@a479 18
void WitPart::attach (WitRtSite * theRtSite)
   {
   witAssert (myRtSite_ == NULL);

   myRtSite_ = theRtSite;
   }

//------------------------------------------------------------------------------

void WitPart::detachRtSite ()
   {
   witAssert (myRtSite_ != NULL);

   myRtSite_ = NULL;
   }

//------------------------------------------------------------------------------

a495 1
      myRtSite_            (NULL),
@


1.63
log
@PIP.
@
text
@a164 2
   isCoproduced_ = false;

a181 1
      isCoproduced_,
d238 6
a243 8
   WitDemand   *  theDemand;
   WitBomEntry *  theBomEnt;
   WitSubEntry *  theSub;
   WitBopEntry *  theBopEnt;
   WitPart     *  theBelowPart;
   bool           isCoprod;
   WitPeriod      thePer;
   WitTVec <bool> isCoprodVec;
a252 1
      {
a254 22
      isCoprod = false;

      forEachPeriod (thePer, myProblem ())
         if (isCoproduced ()[thePer])
            {
            isCoprod = true;

            break;
            }

      if (isCoprod)
         {
         isCoprodVec.allocate (myProblem (), false);

         isCoprodVec = isCoproduced ();

         myProblem ()->displayBoolVec ("isCoproducedDdMsg", isCoprodVec);
         }
      else
         myMsgFac () ("isNotCoprodDdMsg");
      }

a513 1
      isCoproduced_        (myProblem (), false),
@


1.62
log
@Double Precision.
@
text
@d275 1
a275 1
         isCoproduced ().copyInto (isCoprodVec);
@


1.61
log
@Double Precision.
@
text
@d275 1
a275 1
         isCoproduced ().convCopyInto (isCoprodVec);
@


1.60
log
@Double Precision.
@
text
@d69 1
a69 1
   supplyVol_.convCopy (prepNonNegDblVec (theValue, postprocAlt ()));
d97 1
a97 1
   obj1ScrapCost_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
d165 1
a165 1
   isCoproduced_.setToScalar (false);
d503 1
a503 1
   shadowPrice_.setToScalar (0.0);
@


1.59
log
@Double Precision.
@
text
@d604 5
a608 6
   singleSource_ = thePart->singleSource_;
   propRouting_  = thePart->propRouting_;
   unitCost_     = thePart->unitCost_;

   supplyVol_    .copy (thePart->supplyVol_);
   obj1ScrapCost_.copy (thePart->obj1ScrapCost_);
@


1.58
log
@Double Precision.
@
text
@d95 1
a95 1
void WitPart::setObj1ScrapCost (const float * theValue)
@


1.57
log
@Double Precision.
@
text
@d97 1
a97 1
   obj1ScrapCost_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
@


1.56
log
@Double Precision.
@
text
@d69 1
a69 1
   prepNonNegDblVec (theValue, postprocAlt ()).convCopyInto (supplyVol_);
@


1.55
log
@Double Precision.
@
text
@a66 7
void WitPart::setSupplyVol (const float * theValue)
   {
   supplyVol_.convCopy (prepNonNegFloatVec (theValue, postprocAlt ()));
   }

//------------------------------------------------------------------------------

@


1.54
log
@Double Precision.
@
text
@d69 1
a69 1
   convCopy (supplyVol_, prepNonNegFloatVec (theValue, postprocAlt ()));
d104 1
a104 1
   convCopy (obj1ScrapCost_, prepObj1FloatVec (theValue, postprocAlt ()));
@


1.53
log
@Double Precision.
@
text
@d34 1
d70 7
@


1.52
log
@Double Precision.
@
text
@d68 1
a68 1
   supplyVol_.convCopy (prepNonNegFloatVec (theValue, postprocAlt ()));
d96 1
a96 1
   obj1ScrapCost_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
@


1.51
log
@Double Precision.
@
text
@d395 1
a395 1
   float         shipVolVal;
@


1.50
log
@Double Precision.
@
text
@d68 1
a68 1
   supplyVol_.copyFltCVec (prepNonNegFloatVec (theValue, postprocAlt ()));
d96 1
a96 1
   obj1ScrapCost_.copyFltCVec (prepObj1FloatVec (theValue, postprocAlt ()));
d274 1
a274 1
         isCoproduced ().copyIntoTVec (isCoprodVec);
@


1.49
log
@Double Precision.
@
text
@d68 1
a68 1
   supplyVol_.copyCvector (prepNonNegFloatVec (theValue, postprocAlt ()));
d96 1
a96 1
   obj1ScrapCost_.copyCvector (prepObj1FloatVec (theValue, postprocAlt ()));
@


1.48
log
@Continued double precision.
@
text
@d573 1
a573 1
      supplyVol (),
d578 1
a578 1
      singleSource (),
d583 1
a583 1
      propRouting (),
d588 1
a588 1
      unitCost (),
d593 1
a593 1
        obj1ScrapCost (),
d603 3
a605 3
   singleSource_ = thePart->singleSource ();
   propRouting_  = thePart->propRouting ();
   unitCost_     = thePart->unitCost ();
d607 2
a608 2
   supplyVol_    .copy (thePart->supplyVol ());
   obj1ScrapCost_.copy (thePart->obj1ScrapCost ());
@


1.47
log
@Continued double precision.
@
text
@d87 1
a87 1
void WitPart::setUnitCost (StrDbl theValue)
d89 1
a89 1
   unitCost_ = prepNonNegStrDbl (theValue, postprocAlt ());
d586 1
a586 1
   myDataWriter ()->writeStrDbl (
@


1.46
log
@Continued implementation of PIP.
@
text
@d87 1
a87 1
void WitPart::setUnitCost (float theValue)
d89 1
a89 1
   unitCost_ = prepNonNegFloat (theValue, postprocAlt ());
d586 1
a586 1
   myDataWriter ()->writeFloat (
@


1.45
log
@Continued implementation of PIP.
@
text
@d16 4
a30 3
#include <Demand.h>
#include <SubEntry.h>
#include <BopEntry.h>
@


1.44
log
@Removed a bad function overload.
@
text
@d377 1
a377 1
         WitUtil::net (qty, supply[supplyPer]);
@


1.43
log
@Continued implementation of post-implosion pegging.
@
text
@d170 1
a170 1
WitPart * WitPart::myPart ()
d232 1
a232 1
   return (myMat () == NULL);
d427 1
a427 1
      theMat = myMat ();
@


1.42
log
@Made modifications to improve the speed of witPurgeData.
@
text
@a33 1
#include <FlexVecI.h>
@


1.41
log
@Continued implementation of proportionate routing.
@
text
@d147 2
a148 1
   myMsgFac () ("partInstIDMsg", partName ());
@


1.40
log
@Continued implementation of proportionate routing.
@
text
@d170 1
a170 1
void WitPart::getPart (WitPart * & thePart)
d172 1
a172 1
   thePart = this;
d232 1
a232 5
   WitMaterial * theMat;

   getMaterial (theMat);

   return (theMat == NULL);
d427 1
a427 1
      getMaterial (theMat);
@


1.39
log
@Continued implementation of proportionate routing.
@
text
@d510 18
d545 1
@


1.38
log
@Continued implementation of proportionate routing.
@
text
@d80 7
d256 2
a257 1
      singleSource ());
d520 1
d565 5
d588 1
@


1.37
log
@Internal changes.
@
text
@d56 7
@


1.36
log
@Internal changes.
@
text
@d276 1
a276 1
   if (! myDemands ().isEmpty ())
d284 1
a284 1
   if (! consumingBomEntries ().isEmpty ())
d293 1
a293 1
   if (! consumingSubEntries ().isEmpty ())
d305 1
a305 1
   if (! producingBopEntries ().isEmpty ())
d316 1
a316 1
      if (! producingBopEntries ().isEmpty ())
d343 1
a343 1
   return expBopEntry_.isAllocated () && expBopEntry_[thePer] != NULL;
d361 1
a361 1
         if (! canStock (supplyPer))
@


1.35
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d66 1
a66 1
void WitPart::setSingleSource (WitBoolean theValue)
d68 1
a68 1
   singleSource_ = prepBoolean (theValue, postprocAlt ());
d117 1
a117 1
WitBoolean WitPart::inserted ()
d149 1
a149 1
   isCoproduced_.setToScalar (witFALSE);
d216 1
a216 1
WitBoolean WitPart::isaCapacity ()
d229 8
a236 8
   WitDemand   *        theDemand;
   WitBomEntry *        theBomEnt;
   WitSubEntry *        theSub;
   WitBopEntry *        theBopEnt;
   WitPart     *        theBelowPart;
   WitBoolean           isCoprod;
   WitPeriod            thePer;
   WitTVec <WitBoolean> isCoprodVec;
d248 1
a248 1
      isCoprod = witFALSE;
d253 1
a253 1
            isCoprod = witTRUE;
d260 1
a260 1
         isCoprodVec.allocate (myProblem (), witFALSE);
d264 1
a264 1
         myMsgFac () ("isCoproducedDdMsg", isCoprodVec);
d341 1
a341 1
WitBoolean WitPart::explodeable (WitPeriod thePer)
d510 1
a510 1
      isCoproduced_        (myProblem (), witFALSE),
d515 1
a515 1
      expPerGaps_          (witFALSE),
d544 1
a544 1
   myDataWriter ()->writeBoolean (
@


1.34
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d34 1
@


1.33
log
@Continued implementation of single-source.
@
text
@d29 1
@


1.32
log
@Continued implementation of single-source.
@
text
@a65 2
   stronglyAssert (myGlobalComp ()->allowSglSrc ());

@


1.31
log
@Continued implementation of single-source.
@
text
@d32 1
d240 1
a240 1
      myMsgFac ()[categoryFragID ()],
@


1.30
log
@Continued implementation of single-source.
@
text
@d24 1
d197 7
@


1.29
log
@Continued implementation of single-source.
@
text
@d143 11
d157 14
@


1.28
log
@Continued implementation of single-source.
@
text
@d21 3
d146 25
@


1.27
log
@Continued implementation of single-source.
@
text
@a20 3
#include <Post.h>
#include <OrigMrp.h>
#include <FSS.h>
d25 1
a27 2
#include <wit/src/Variant.h>
#include <MsgFac.h>
a146 17
void WitPart::importMrpResults ()
   {
   copyInto (reqVol_,         myOrigMrpExp ()->reqVol         (this));
   copyInto (mrpResidualVol_, myOrigMrpExp ()->mrpResidualVol (this));

   mrpConsVol_.copyTVec (myOrigMrpExp ()->mrpConsVol (this));
   }

//------------------------------------------------------------------------------

void WitPart::importFssResults ()
   {
   copyInto (focShortageVol_, myFSS ()->focShortageVol (this));
   }

//------------------------------------------------------------------------------

a432 37
void WitPart::compConsVol (WitTVec <double> & theDblTVec)
   {
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;

   theDblTVec.setToScalar (0.0);

   forEachEl (theBomEnt, consumingBomEntries_)
      theBomEnt->incConsVol (theDblTVec, theBomEnt->nonSubVol ());

   forEachEl (theSub,    consumingSubEntries_)
      theSub   ->incConsVol (theDblTVec, theSub   ->subVol    ());

   copyInto (consVol_, theDblTVec);
   }

//------------------------------------------------------------------------------

void WitPart::compProdVol (WitTVec <double> & theDblTVec)
   {
   WitBopEntry * theBopEnt;
   WitPeriod     thePer;

   theDblTVec.setToScalar (0.0);

   forEachEl (theBopEnt, producingBopEntries_)
      forEachPeriod (thePer, myProblem ())
         if (theBopEnt->inEffect (thePer))
            theDblTVec[theBopEnt->impactPeriod ()[thePer]] +=
               theBopEnt->effProdRate ()[thePer] *
               theBopEnt->myOperation ()->execVol ()[thePer];

   copyInto (prodVol_, theDblTVec);
   }

//------------------------------------------------------------------------------

a508 18
   }

//------------------------------------------------------------------------------

double WitPart::unstockedScrapVol (WitPeriod thePer)
   {
   WitDemand * theDemand;
   double      scrapVolVal;

   scrapVolVal =
        supplyVol_[thePer]
      + prodVol_  [thePer]
      - consVol_  [thePer];

   forEachEl (theDemand, myDemands_)
      scrapVolVal -= theDemand->shipVol ()[thePer];

   return scrapVolVal;
@


1.26
log
@Continued implementation of single-source.
@
text
@a150 11
void WitPart::importPostprocResults ()
   {
   consVol_ .copyTVec (myPostprocessor ()->consVol (this));
   prodVol_ .copyTVec (myPostprocessor ()->prodVol (this));

   if (! myProblem ()->currentVariant ()->compsSecScheds ())
      scrapVol_.copyTVec (myPostprocessor ()->scrapVol (this));
   }

//------------------------------------------------------------------------------

d454 37
d567 18
@


1.25
log
@Continued implementation of single-source.
@
text
@d21 1
a27 1
#include <MsgFac.h>
d30 2
d147 11
@


1.24
log
@Continued implementation of single-source.
@
text
@d22 1
d155 7
@


1.23
log
@Continued implementation of single-source.
@
text
@d21 1
d144 10
@


1.22
log
@Preliminary work on single source.
@
text
@d59 9
d179 2
a180 1
      mappingIndex_);
d442 1
d482 5
d504 2
a505 1
   unitCost_ = thePart->unitCost ();
@


1.21
log
@Continued preliminary work on single source.
@
text
@d54 1
a54 1
   supplyVol_ = prepNonNegFloatVec (theValue, postprocAlt ());
d68 1
a68 1
   obj1ScrapCost_ = prepObj1FloatVec (theValue, postprocAlt ());
d190 1
a190 1
         isCoproduced ().copySelfInto (isCoprodVec);
d418 1
a418 1
   shadowPrice_ = 0.0;
d488 4
a491 3
   supplyVol_     = thePart->supplyVol ();
   unitCost_      = thePart->unitCost ();
   obj1ScrapCost_ = thePart->obj1ScrapCost ();
@


1.20
log
@Continued preliminary work on single source.
@
text
@d23 2
@


1.19
log
@More preliminary work on single source.
@
text
@d163 1
a163 1
   WitTVec (WitBoolean) isCoprodVec;
d277 1
a277 1
      WitTVec (double) & supply)
@


1.18
log
@Continued implementation of object iteration.
@
text
@d434 1
a434 1
      belowList_           (* new WitDenseList (WitPart)),
@


1.17
log
@Continued implementation of object iteration.
@
text
@d122 1
a122 1
WitAttr WitPart::apiItrState ()
@


1.16
log
@Continued implementation of object iteration.
@
text
@d124 1
a124 1
   return WitITR_AT_PART;
@


1.15
log
@Began implementation of object iteration.
@
text
@d22 1
a30 32
WitPart::WitPart (const char * theName, WitCompMgr * theCompMgr):
      WitNode              (theName, theCompMgr),

      mappingIndex_        (myCompMgr ()->nParts ()),
      myDemands_           (),
      consumingBomEntries_ (),
      consumingSubEntries_ (),
      producingBopEntries_ (),
      supplyVol_           (myProblem (), defSupplyVol ()),
      unitCost_            (defUnitCost ()),
      obj1ScrapCost_       (myProblem (), defObj1ScrapCost ()),
      sortedPartIndex_     (-1),
      expBopEntry_         (* new WitPtrTVec <WitBopEntry>),
      belowList_           (* new WitDenseList (WitPart)),
      isCoproduced_        (myProblem (), witFALSE),
      shadowPrice_         (myProblem (), 0.0),
      consVol_             (myProblem (), 0.0),
      prodVol_             (myProblem (), 0.0),
      scrapVol_            (myProblem (), 0.0),
      expPerGaps_          (witFALSE),
      reqVol_              (myProblem (), 0.0),
      mrpConsVol_          (myProblem (), 0.0),
      mrpResidualVol_      (myProblem (), 0.0),
      focShortageVol_      (myProblem (), 0.0)
   {
   if (PART_LIMIT >= 0)
      if (myCompMgr ()->nParts () > PART_LIMIT)
         myMsgFac () ("partLimitExceededSmsg", PART_LIMIT);
   }

//------------------------------------------------------------------------------

d122 14
d143 1
a143 1
WitMaterial * WitPart::myMat ()
d145 5
a149 1
   return NULL;
a266 7
WitBoolean WitPart::isaPart ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

d342 2
d345 2
a346 2
         (myMat () != NULL)?
            myMat ()->stockVol ()[thePer]:
d417 32
@


1.14
log
@Continued development of Selective Stock Reallocation.
@
text
@d22 1
@


1.13
log
@Continued implementation of selective stock reallocation.
@
text
@d159 1
a159 1
WitBoolean WitPart::getMyMaterial (WitMaterial * & theMat)
d161 1
a161 12
   theMat = NULL;

   return witFALSE;
   }

//------------------------------------------------------------------------------

WitBoolean WitPart::getMyCapacity (WitCapacity * & theCap)
   {
   theCap = NULL;

   return witFALSE;
d362 2
a363 2
         getMyMaterial (theMat)?
            theMat->stockVol ()[thePer]:
@


1.12
log
@Minor change to shadow price code.
@
text
@d159 1
a159 1
WitBoolean WitPart::isaMaterial (WitMaterial * & theMat)
d168 1
a168 1
WitBoolean WitPart::isaCapacity (WitCapacity * & theCap)
d373 1
a373 1
         isaMaterial (theMat)?
@


1.11
log
@Added shadowPrice and compPrices attributes.
@
text
@d442 7
@


1.10
log
@Implemented selection splitting speed-up by partial allocation reuse.
@
text
@d44 1
d382 22
@


1.9
log
@More templates.
@
text
@d40 1
d194 1
a194 1
      myMsgFac () ("expPerGapsDdMsg", expPerGaps_);
@


1.8
log
@Continued development of selection splitting for multi=exec.
@
text
@d40 1
a40 1
      expBopEntry_         (* new WitPtrTVec (WitBopEntry)),
@


1.7
log
@Implemented and used class SelMgr.
@
text
@d247 2
a248 2
            theSub->myBomEntry ()->myPartName (),
            theSub->myBomEntryIndex (),
@


1.6
log
@Coarse selection splitting.
@
text
@a484 6

//------------------------------------------------------------------------------

implementClearContents (WitPart)
   //
   // See RWClient.h.
@


1.5
log
@Some minor changes.
@
text
@d418 7
a453 7
   }

//------------------------------------------------------------------------------

void WitPart::setPartIndex ()
   {
   mappingIndex_ = myCompMgr ()->nParts ();
@


1.4
log
@Refactoring for selection splitting.
@
text
@d22 2
d40 2
a41 2
      expBopEntry_         (),
      belowList_           (),
d61 11
d291 7
@


1.3
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d38 1
a38 1
      expBopEntryTl_       (),
@


1.2
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d196 1
a196 1
         isCoproduced ().copyInto (isCoprodVec);
@


1.1
log
@Replaced WitPart.[Ch] with Part.[Ch].
@
text
@d40 1
a40 1
      isCoproduced_        (witFALSE),
d164 8
a171 6
   WitDemand   * theDemand;
   WitBomEntry * theBomEnt;
   WitSubEntry * theSub;
   WitBopEntry * theBopEnt;
   WitPart     * theBelowPart;
   WitPeriod     thePer;
d182 20
a201 2
      if (isCoproduced ())
         myMsgFac () ("isCoproducedDdMsg");
@


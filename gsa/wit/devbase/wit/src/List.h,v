head	1.34;
access;
symbols
	sce_5_01_20080919:1.31
	latest_sce_4_20_20060523:1.30.0.2
	sce_4_20_20060523:1.30
	latest_sce4_20_OSL:1.29.0.2
	sce_4_20_OSL:1.29
	sce_410_withVa:1.23
	sce_4_05_20040511:1.20
	sce_4_00_20040201:1.19
	nextGenBranch:1.18.0.2
	nextGenRoot:1.18
	sce_3_30_20030627:1.17
	EndRw-branch:1.6.0.4
	Root-of-EndRw:1.6
	rwToStl:1.6.0.2
	latest_sce_3_10_20010924:1.3.0.4
	sce_3_10_20010924:1.3
	latest_sce_3_00_20010601:1.3.0.2
	sce_3_00_20010601:1.3
	latest_sce_2_31_20010308:1.1.0.2
	sce_2_31_20010308:1.1;
locks; strict;
comment	@ * @;


1.34
date	2011.09.28.23.49.29;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2011.09.24.00.27.49;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2011.08.30.20.17.36;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.14.21.38.31;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.02.17.34.01;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.28.21.38.00;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.21.15.44.14;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.17.17.07.17;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.15.21.45.26;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.15.21.27.23;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.22.14.59.51;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.06.20.43.26;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.08.21.00.40;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.03.21.20.29;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.01.21.05.03;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.10.22.58.16;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.08.18.41.20;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.23.18.12.34;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.27.23.26.12;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.27.21.34.05;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.27.21.17.17;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.23.21.23.11;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.22.19.32.12;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.15.21.01.21;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.13.22.22.10;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.02.22.18.31;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.25.15.15.22;	author rwToStl;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.02.20.53.12;	author rjw;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2002.05.01.14.25.56;	author rjw;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.18.14.02.34;	author rjw;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.25.14.53.24;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.08.21.35.43;	author bobw;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.20.00.44.17;	author bobw;	state Exp;
branches;
next	;

1.6.2.1
date	2002.11.08.16.11.34;	author rwToStl;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef ListH
#define ListH

//------------------------------------------------------------------------------
// Header file: "List.h"
//
// Contains the declaration of the following classes and templates:
//
//    AbsList
//    ListItr
//    List <Elem>
//------------------------------------------------------------------------------

#include <Util.h>

#include <list>

//------------------------------------------------------------------------------
// class WitAbsList (Abstract List)
//
// An AbsList is a list whose elements are void pointers.
// It is implemented as a wrapper for std::list <void *>.
//
// AbsList
//    List <Elem>
//------------------------------------------------------------------------------

typedef const WitString & (* WitAbsListKeyFunc) (const void *);
   //
   // "Key" function for AbsList::findAbs.

class WitAbsList
   {
      friend class WitListItr;

   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      void clear ();
         //
         // Removes all of the elements from this AbsList.

      inline bool isEmpty () const
            //
            // Returns true iff this AbsList is empty.
         {
         return (nElements_ == 0);
         }

      accessFunc (int, nElements)

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAbsList ();
         //
         // Constructs an empty list.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitAbsList ();

      //------------------------------------------------------------------------
      // Other protected wrappers.
      //------------------------------------------------------------------------

      void copyAbs (const WitAbsList & theAbsList);
         //
         // Makes this AbsList a copy of theAbsList.

      void appendAbs (void * theObject);
         //
         // Adds theObject to the end of this AbsList.
         // Generates a severe error if the appending was unsuccessful, or
         // if theObject is NULL.

      void * firstAbs () const;
         //
         // Returns the first element in this AbsList.

      void * getAbs ();
         //
         // Returns and removes the first element in this AbsList.

      void * lastAbs () const;
         //
         // Returns the last element in this AbsList.

      void prependAbs (void * theObjByVP);
         //
         // Adds theObjByVP to the beginning of this AbsList.
         // The ObjByVP must not be NULL.

      void * atAbs (int theIndex) const;
         //
         // Returns a pointer to the element in this AbsList whose index ==
         // theIndex, where the indices are 0, 1, ..., nElements - 1.
         // If theIndex is outside this range, an RW error is issued.
         // Use this carefuly: this is a very expensive method to call,
         // and should not be used from a loop.

      void * findAbs (
            WitAbsListKeyFunc theFunc,
            const char *      theCstring)
            const;
         //
         // Return the first element of this AbsList, theElement, such that
         // theFunc (theElement) == theCstring, if any, else NULL.

      //------------------------------------------------------------------------
      // Non-wrapper member functions.
      //------------------------------------------------------------------------

      void appendUniquelyAbs (void * theObject);
         //
         // Same as append, but asserts that theObject is not already in this
         // AbsList.

      bool containsAbs (void * theObject) const;
         //
         // Returns true, iff theObject is in this AbsList.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitAbsList);

      std::list <void *> myListData_;
         //
         // The std::list <void *> for which this AbsList is a wrapper.

      int nElements_;
         //
         // The number of elements in this AbsList.
   };

//------------------------------------------------------------------------------
// Class ListItr
//
// "List Iterator"
//
// An iterator for an AbsList. Facilitates interating thru the elements of an
// AbsList, to which is it "attached" at contruction time. Implemented as
// a wrapper for class list::iterator <void *>. Since AbsList is only a base
// class for generic class List <Elem>, ListItrs are actually always attached
// List <Elem>s, but only interact with them using the AbsList interface.
// Class ListItr is not intended to be used directly, but instead, used only
// thru various macros:
//    forEachEl       in List.h
//    forEach<object> in Problem.h
//------------------------------------------------------------------------------

class WitListItr
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitListItr (const WitAbsList & theAbsList);
         //
         // Constucts an ListItr attached to theAbsList.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitListItr ();

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      void * key ();
         //
         // Returns the element to which this ListItr points.

      bool advance ();
         //
         // Advances this Itr in its AbsList.
         // Returns true iff the advance did not move beyond the end of the
         // AbsList.

      bool advance (
            void * &           theElement, 
            const WitAbsList & theAbsList);
         //
         // Advances this Itr. If this Itr is still within theAbsList after the
         // advance, this function sets theElement to its key and returns
         // true. Otherwise this function sets theElement to NULL and
         // returns false. This Itr is required to be attached to theAbsList.

   private:

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      std::list <void *>::const_iterator myListIterator_;

      const WitAbsList & myAbsList_;

      bool iterating_;
   };

//------------------------------------------------------------------------------
// Class template List <Elem>
//
// A List <Elem> is a singly-linked list whose elements are instances of Elem.
//
// Class Hierarchy:
//
// AbsList
//    List <Elem>
//
// All implementation is inline.
//------------------------------------------------------------------------------

template <typename Elem> 
      class WitList: public WitAbsList
   {
   public:

      //-----------------------------------------------------------------------
      // Constructor functions.
      //-----------------------------------------------------------------------

      inline WitList ():
            WitAbsList ()
         {
         }

      //-----------------------------------------------------------------------
      // Destructor function.
      //-----------------------------------------------------------------------

      inline ~WitList ()
         {
         }

      //-----------------------------------------------------------------------
      // Wrappers around AbsList member functions.
      //-----------------------------------------------------------------------

      inline void operator = (const WitList & theList)
         {
         copyAbs (theList);
         }

      inline void append (Elem * theInstance)
         {
         appendAbs (theInstance);
         }

      inline Elem * first () const
         {
         return reinterpret_cast <Elem *> (firstAbs ());
         }

      inline Elem * get ()
         {
         return reinterpret_cast <Elem *> (getAbs ());
         }

      inline Elem * last () const
         {
         return reinterpret_cast <Elem *> (lastAbs ());
         }

      inline void prepend (Elem * theInstance)
         {
         prependAbs (theInstance);
         }

      inline Elem * at (int theIndex) const
         {
         return reinterpret_cast <Elem *> (atAbs (theIndex));
         }

      inline bool advance (WitListItr & theItr, Elem * & theElement) const
         {
         return
            theItr.advance (
                 reinterpret_cast <void * &> (theElement),
               * this);
         }

      inline void appendUniquely (Elem * theObject)
         {
         appendUniquelyAbs (theObject);
         }

      inline bool contains (Elem * theObject) const
         {
         return containsAbs (theObject);
         }

      inline Elem * find (
            const WitString & (* theFunc) (const Elem *),
            const char *         theCstring)
            const
         {
         return
            reinterpret_cast <Elem *> (
               findAbs (
                  reinterpret_cast <WitAbsListKeyFunc> (theFunc),
                  theCstring));
         }

   private:

      //-----------------------------------------------------------------------
      // Private member functions.
      //-----------------------------------------------------------------------

      noCopyCtor (WitList);
   };

//------------------------------------------------------------------------------
// macro forEachEl (theElement, theList)
//
// Expands to a header of a for loop that iterates thru each element in
// theList.
//
// Arguments:
//
//    theList:    Type: const List <Elem>, for some type, Elem.
//                The list being iterated.
//
//    theElement: Type: Elem *
//                A pointer that will be set to each element of theList, in
//                sequence. The body of the for loop should normally make use
//                of this pointer.
//
// Note: If theList is empty, the forEachEl loop does nothing (which is to be
// expected).
//
// Example:
//
// WitList <WitBomEntry> bom;
//
// ...Fill up bom with BomEntries...
//
// WitBomEntry * theBomEnt;
//
// forEachEl (theBomEnt, bom)
//    {
//    ...statements using theBomEnt...
//    }
//
// The implementation of this macro calls the macro forEachElItr (defined
// below), which expands to a name unique to the line of source code from which
// the forEachElItr macro was called. This name is used as the name of a
// ListItr, which is used to implement the forEachEl macro. It is necessary for
// the forEachEl macro to use a different name for its ListItr each time it is
// called, because it might get called more than once from within the same
// scope.
//------------------------------------------------------------------------------

#define forEachElItr name2 (forEachElItrOnLine, __LINE__)

//------------------------------------------------------------------------------

#define forEachEl(theElement, theList)                                         \
                                                                               \
   for (                                                                       \
      WitListItr forEachElItr (theList);                                       \
      (theList).advance (forEachElItr, theElement);                            \
      )                                                                        \

#endif
@


1.33
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.32
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d38 2
a39 2
//
// "Key" function for AbsList::findAbs.
d42 2
a43 103
{
friend class WitListItr;

public:

//------------------------------------------------------------------------
// Public member functions.
//------------------------------------------------------------------------

void clear ();
//
// Removes all of the elements from this AbsList.

inline bool isEmpty () const
//
// Returns true iff this AbsList is empty.
{
return (nElements_ == 0);
}

accessFunc (int, nElements)

protected:

//------------------------------------------------------------------------
// Protected member functions.
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitAbsList ();
//
// Constructs an empty list.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitAbsList ();

//------------------------------------------------------------------------
// Other protected wrappers.
//------------------------------------------------------------------------

void copyAbs (const WitAbsList & theAbsList);
//
// Makes this AbsList a copy of theAbsList.

void appendAbs (void * theObject);
//
// Adds theObject to the end of this AbsList.
// Generates a severe error if the appending was unsuccessful, or
// if theObject is NULL.

void * firstAbs () const;
//
// Returns the first element in this AbsList.

void * getAbs ();
//
// Returns and removes the first element in this AbsList.

void * lastAbs () const;
//
// Returns the last element in this AbsList.

void prependAbs (void * theObjByVP);
//
// Adds theObjByVP to the beginning of this AbsList.
// The ObjByVP must not be NULL.

void * atAbs (int theIndex) const;
//
// Returns a pointer to the element in this AbsList whose index ==
// theIndex, where the indices are 0, 1, ..., nElements - 1.
// If theIndex is outside this range, an RW error is issued.
// Use this carefuly: this is a very expensive method to call,
// and should not be used from a loop.

void * findAbs (
WitAbsListKeyFunc theFunc,
const char *      theCstring)
const;
//
// Return the first element of this AbsList, theElement, such that
// theFunc (theElement) == theCstring, if any, else NULL.

//------------------------------------------------------------------------
// Non-wrapper member functions.
//------------------------------------------------------------------------

void appendUniquelyAbs (void * theObject);
//
// Same as append, but asserts that theObject is not already in this
// AbsList.

bool containsAbs (void * theObject) const;
//
// Returns true, iff theObject is in this AbsList.

private:
d45 1
a45 9
//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitAbsList);

std::list <void *> myListData_;
//
// The std::list <void *> for which this AbsList is a wrapper.
d47 113
a159 4
int nElements_;
//
// The number of elements in this AbsList.
};
d178 2
a179 41
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitListItr (const WitAbsList & theAbsList);
//
// Constucts an ListItr attached to theAbsList.

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitListItr ();

//------------------------------------------------------------------------
// Public member functions.
//------------------------------------------------------------------------

void * key ();
//
// Returns the element to which this ListItr points.

bool advance ();
//
// Advances this Itr in its AbsList.
// Returns true iff the advance did not move beyond the end of the
// AbsList.

bool advance (
void * &           theElement,
const WitAbsList & theAbsList);
//
// Advances this Itr. If this Itr is still within theAbsList after the
// advance, this function sets theElement to its key and returns
// true. Otherwise this function sets theElement to NULL and
// returns false. This Itr is required to be attached to theAbsList.

private:
d181 42
a222 3
//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------
d224 1
a224 1
std::list <void *>::const_iterator myListIterator_;
d226 1
a226 1
const WitAbsList & myAbsList_;
d228 2
a229 2
bool iterating_;
};
d244 96
a339 96
template <typename Elem>
class WitList: public WitAbsList
{
public:

//-----------------------------------------------------------------------
// Constructor functions.
//-----------------------------------------------------------------------

inline WitList ():
WitAbsList ()
{
}

//-----------------------------------------------------------------------
// Destructor function.
//-----------------------------------------------------------------------

inline ~WitList ()
{
}

//-----------------------------------------------------------------------
// Wrappers around AbsList member functions.
//-----------------------------------------------------------------------

inline void operator = (const WitList & theList)
{
copyAbs (theList);
}

inline void append (Elem * theInstance)
{
appendAbs (theInstance);
}

inline Elem * first () const
{
return reinterpret_cast <Elem *> (firstAbs ());
}

inline Elem * get ()
{
return reinterpret_cast <Elem *> (getAbs ());
}

inline Elem * last () const
{
return reinterpret_cast <Elem *> (lastAbs ());
}

inline void prepend (Elem * theInstance)
{
prependAbs (theInstance);
}

inline Elem * at (int theIndex) const
{
return reinterpret_cast <Elem *> (atAbs (theIndex));
}

inline bool advance (WitListItr & theItr, Elem * & theElement) const
{
return
theItr.advance (
reinterpret_cast <void * &> (theElement),
* this);
}

inline void appendUniquely (Elem * theObject)
{
appendUniquelyAbs (theObject);
}

inline bool contains (Elem * theObject) const
{
return containsAbs (theObject);
}

inline Elem * find (
const WitString & (* theFunc) (const Elem *),
const char *         theCstring)
const
{
return
reinterpret_cast <Elem *> (
findAbs (
reinterpret_cast <WitAbsListKeyFunc> (theFunc),
theCstring));
}

private:

//-----------------------------------------------------------------------
// Private member functions.
//-----------------------------------------------------------------------
d341 2
a342 2
noCopyCtor (WitList);
};
d390 5
a394 5
\
for (                                                                       \
WitListItr forEachElItr (theList);                                       \
(theList).advance (forEachElItr, theElement);                            \
)                                                                        \
@


1.31
log
@Stochastic Implosion
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d38 2
a39 2
   //
   // "Key" function for AbsList::findAbs.
d42 103
a144 2
   {
      friend class WitListItr;
d146 9
a154 1
   public:
d156 4
a159 113
      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      void clear ();
         //
         // Removes all of the elements from this AbsList.

      inline bool isEmpty () const
            //
            // Returns true iff this AbsList is empty.
         {
         return (nElements_ == 0);
         }

      accessFunc (int, nElements)

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitAbsList ();
         //
         // Constructs an empty list.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitAbsList ();

      //------------------------------------------------------------------------
      // Other protected wrappers.
      //------------------------------------------------------------------------

      void copyAbs (const WitAbsList & theAbsList);
         //
         // Makes this AbsList a copy of theAbsList.

      void appendAbs (void * theObject);
         //
         // Adds theObject to the end of this AbsList.
         // Generates a severe error if the appending was unsuccessful, or
         // if theObject is NULL.

      void * firstAbs () const;
         //
         // Returns the first element in this AbsList.

      void * getAbs ();
         //
         // Returns and removes the first element in this AbsList.

      void * lastAbs () const;
         //
         // Returns the last element in this AbsList.

      void prependAbs (void * theObjByVP);
         //
         // Adds theObjByVP to the beginning of this AbsList.
         // The ObjByVP must not be NULL.

      void * atAbs (int theIndex) const;
         //
         // Returns a pointer to the element in this AbsList whose index ==
         // theIndex, where the indices are 0, 1, ..., nElements - 1.
         // If theIndex is outside this range, an RW error is issued.
         // Use this carefuly: this is a very expensive method to call,
         // and should not be used from a loop.

      void * findAbs (
            WitAbsListKeyFunc theFunc,
            const char *      theCstring)
            const;
         //
         // Return the first element of this AbsList, theElement, such that
         // theFunc (theElement) == theCstring, if any, else NULL.

      //------------------------------------------------------------------------
      // Non-wrapper member functions.
      //------------------------------------------------------------------------

      void appendUniquelyAbs (void * theObject);
         //
         // Same as append, but asserts that theObject is not already in this
         // AbsList.

      bool containsAbs (void * theObject) const;
         //
         // Returns true, iff theObject is in this AbsList.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitAbsList);

      std::list <void *> myListData_;
         //
         // The std::list <void *> for which this AbsList is a wrapper.

      int nElements_;
         //
         // The number of elements in this AbsList.
   };
d178 41
a218 2
   {
   public:
d220 3
a222 42
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitListItr (const WitAbsList & theAbsList);
         //
         // Constucts an ListItr attached to theAbsList.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitListItr ();

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      void * key ();
         //
         // Returns the element to which this ListItr points.

      bool advance ();
         //
         // Advances this Itr in its AbsList.
         // Returns true iff the advance did not move beyond the end of the
         // AbsList.

      bool advance (
            void * &           theElement, 
            const WitAbsList & theAbsList);
         //
         // Advances this Itr. If this Itr is still within theAbsList after the
         // advance, this function sets theElement to its key and returns
         // true. Otherwise this function sets theElement to NULL and
         // returns false. This Itr is required to be attached to theAbsList.

   private:

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------
d224 1
a224 1
      std::list <void *>::const_iterator myListIterator_;
d226 1
a226 1
      const WitAbsList & myAbsList_;
d228 2
a229 2
      bool iterating_;
   };
d244 96
a339 96
template <typename Elem> 
      class WitList: public WitAbsList
   {
   public:

      //-----------------------------------------------------------------------
      // Constructor functions.
      //-----------------------------------------------------------------------

      inline WitList ():
            WitAbsList ()
         {
         }

      //-----------------------------------------------------------------------
      // Destructor function.
      //-----------------------------------------------------------------------

      inline ~WitList ()
         {
         }

      //-----------------------------------------------------------------------
      // Wrappers around AbsList member functions.
      //-----------------------------------------------------------------------

      inline void operator = (const WitList & theList)
         {
         copyAbs (theList);
         }

      inline void append (Elem * theInstance)
         {
         appendAbs (theInstance);
         }

      inline Elem * first () const
         {
         return reinterpret_cast <Elem *> (firstAbs ());
         }

      inline Elem * get ()
         {
         return reinterpret_cast <Elem *> (getAbs ());
         }

      inline Elem * last () const
         {
         return reinterpret_cast <Elem *> (lastAbs ());
         }

      inline void prepend (Elem * theInstance)
         {
         prependAbs (theInstance);
         }

      inline Elem * at (int theIndex) const
         {
         return reinterpret_cast <Elem *> (atAbs (theIndex));
         }

      inline bool advance (WitListItr & theItr, Elem * & theElement) const
         {
         return
            theItr.advance (
                 reinterpret_cast <void * &> (theElement),
               * this);
         }

      inline void appendUniquely (Elem * theObject)
         {
         appendUniquelyAbs (theObject);
         }

      inline bool contains (Elem * theObject) const
         {
         return containsAbs (theObject);
         }

      inline Elem * find (
            const WitString & (* theFunc) (const Elem *),
            const char *         theCstring)
            const
         {
         return
            reinterpret_cast <Elem *> (
               findAbs (
                  reinterpret_cast <WitAbsListKeyFunc> (theFunc),
                  theCstring));
         }

   private:

      //-----------------------------------------------------------------------
      // Private member functions.
      //-----------------------------------------------------------------------
d341 2
a342 2
      noCopyCtor (WitList);
   };
d390 5
a394 5
                                                                               \
   for (                                                                       \
      WitListItr forEachElItr (theList);                                       \
      (theList).advance (forEachElItr, theElement);                            \
      )                                                                        \
@


1.30
log
@Updated the copyright date on all source files.
@
text
@d325 1
a325 1
            const char * theCstring)
@


1.29
log
@[shared-resource pegging]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.28
log
@[shared-resource pegging]
@
text
@a26 4
#define  name2(a,b) _name2(a,b) // to force the args to be evaluated here

#define _name2(a,b) a##b

d30 2
a31 6
// An AbsList is a singly-linked list whose elements are void pointers.
// It is Implemented as a wrapper for list(void).
// This class functions as a base class for the generic class List <Elem>.
// Its purpose is to implement all type-independent aspects of List <Elem>.
// Since this function is intended to be used only as a base class, its
// ctors and dtor are protected.
d48 1
a48 2
      // The following functions and operators are wrappers around the
      // corresponding list member functions and operators.
d67 1
a67 2
      // The following functions and operators are wrappers around the
      // corresponding list member functions and operators.
d164 1
a164 1
// (List Iterator)
d168 1
a168 1
// a wrapper for class list::iterator (Tl). Since AbsList is only a base
d173 1
a173 1
//    forEachEl       in RWCLient.h
@


1.27
log
@[shared-resource pegging]
@
text
@d125 1
a125 1
      void * atAbs (WitSiz theIndex) const;
d310 1
a310 1
      inline Elem * at (WitSiz theIndex) const
@


1.26
log
@[shared-resource pegging]
@
text
@d125 1
a125 1
      void * atAbs (size_t theIndex) const;
d310 1
a310 1
      inline Elem * at (size_t theIndex) const
@


1.25
log
@[shared-resource pegging]
@
text
@d34 1
a34 1
// An AbsList is a singly-linked list whose elements are TlPtrs.
@


1.24
log
@[multi-thread]
@
text
@a23 1
#include <TlObj.h>
d45 1
a45 1
typedef const WitString & (* WitAbsListKeyFunc) (const WitTlObj *);
d102 1
a102 1
      void appendAbs (WitTlObj * theObject);
d108 1
a108 1
      WitTlObj * firstAbs () const;
d112 1
a112 1
      WitTlObj * getAbs ();
d116 1
a116 1
      WitTlObj * lastAbs () const;
d120 1
a120 1
      void prependAbs (WitTlObj * theTlObj);
d122 2
a123 2
         // Adds theTlObj to the beginning of this AbsList.
         // The TlObj must not be NULL.
d125 1
a125 1
      WitTlObj * atAbs (size_t theIndex) const;
d133 1
a133 1
      WitTlObj * findAbs (
d145 1
a145 1
      void appendUniquelyAbs (WitTlObj * theObject);
d150 1
a150 1
      bool containsAbs (WitTlObj * theObject) const;
d162 1
a162 1
      std::list <WitTlObj *> myListData_;
d164 1
a164 1
         // The std::list <TlObj> for which this AbsList is a wrapper.
d209 1
a209 1
      WitTlObj * key ();
d220 1
a220 1
            WitTlObj * &       theElement, 
d234 1
a234 1
      std::list <WitTlObj *>::const_iterator myListIterator_;
d287 1
a287 1
         appendAbs (toTlObj_cast (theInstance));
d292 1
a292 1
         return fromTlObj_cast <Elem> (firstAbs ());
d297 1
a297 1
         return fromTlObj_cast <Elem> (getAbs ());
d302 1
a302 1
         return fromTlObj_cast <Elem> (lastAbs ());
d307 1
a307 1
         prependAbs (toTlObj_cast (theInstance));
d312 1
a312 1
         return fromTlObj_cast <Elem> (atAbs (theIndex));
d317 4
a320 1
         return theItr.advance (toTlObjRef_cast (theElement), * this);
d325 1
a325 1
         appendUniquelyAbs (toTlObj_cast (theObject));
d330 1
a330 1
         return containsAbs (toTlObj_cast (theObject));
d339 1
a339 1
            fromTlObj_cast <Elem> (
@


1.23
log
@[multi-thread]
@
text
@d20 1
a20 1
//    List <TheType>
d37 2
a38 2
// This class functions as a base class for the generic class List (TheType).
// Its purpose is to implement all type-independent aspects of List (TheType).
d43 1
a43 1
//    List <TheType>
d180 2
a181 2
// class for generic class List (TheType), ListItrs are actually always attached
// List (TheType)s, but only interact with them using the AbsList interface.
d243 1
a243 1
// Class template List <TheType>
d245 1
a245 2
// A List <TheType> is a singly-linked list whose elements are instances of
// TheType.
d250 1
a250 1
//    List <TheType>
d255 1
a255 1
template <typename TheType> 
d286 1
a286 1
      inline void append (TheType * theInstance)
d291 1
a291 1
      inline TheType * first () const
d293 1
a293 1
         return fromTlObj_cast <TheType> (firstAbs ());
d296 1
a296 1
      inline TheType * get ()
d298 1
a298 1
         return fromTlObj_cast <TheType> (getAbs ());
d301 1
a301 1
      inline TheType * last () const
d303 1
a303 1
         return fromTlObj_cast <TheType> (lastAbs ());
d306 1
a306 1
      inline void prepend (TheType * theInstance)
d311 1
a311 1
      inline TheType * at (size_t theIndex) const
d313 1
a313 1
         return fromTlObj_cast <TheType> (atAbs (theIndex));
d316 1
a316 1
      inline bool advance (WitListItr & theItr, TheType * & theElement) const
d321 1
a321 1
      inline void appendUniquely (TheType * theObject)
d326 1
a326 1
      inline bool contains (TheType * theObject) const
d331 2
a332 2
      inline TheType * find (
            const WitString & (* theFunc) (const TheType *),
d337 1
a337 1
            fromTlObj_cast <TheType> (
d360 1
a360 1
//    theList:    Type: const List (TheType), for some type, TheType.
d363 1
a363 1
//    theElement: Type: TheType *
@


1.22
log
@Pegged Critical List.
@
text
@d121 1
a121 1
      void prependAbs (WitTlObj * theObject);
d123 2
a124 3
         // Adds theObject to the beginning of this AbsList.
         // Generates a severe error if the prepending was unsuccessful,
         // or if theObject is NULL.
@


1.21
log
@pegged Critical List.
@
text
@d238 1
a238 1
      const WitAbsList &                     myAbsList_;
d240 1
a240 1
      bool                                   iterating_;
@


1.20
log
@Double Precision.
@
text
@d28 1
a28 1
#define  name2(a,b) _name2(a,b) /* to force the args to be evaluated here */
@


1.19
log
@Continued implementation of PIP.
@
text
@d283 1
a283 1
      inline void copy (const WitList & theList)
d351 1
a351 1
      noCopyCtorAssign (WitList);
@


1.18
log
@Added some optional warnings on Linux.
@
text
@d50 1
a50 1
class WitAbsList: public WitUtil
d189 1
a189 1
class WitListItr: public WitUtil
@


1.17
log
@Made List::elements run in constant time.
@
text
@d340 4
a343 2
               findAbs ((WitAbsListKeyFunc) theFunc, theCstring));
      }
@


1.16
log
@Continued implementation of opt with COIN.
@
text
@a64 7
      inline size_t nElements () const
            //
            // Returns the number of elements in this AbsList.
         {
         return myListData_.size ();
         }

d69 1
a69 1
         return myListData_.empty ();
d72 2
d167 4
@


1.15
log
@Removed all const_casts from WIT.
@
text
@d126 1
a126 1
      void       prependAbs (WitTlObj * theObject);
@


1.14
log
@Eliminated a const_cast.
@
text
@a139 5
      void removeReferenceAbs (const WitTlObj * theElement);
         //
         // Removes and returns the first element in this AbsList whose
         // address == theElement, or returns NULL, if no match is found.

d157 1
a157 1
      bool containsAbs (const WitTlObj * theObject) const;
a313 5
      inline void removeReference (const TheType * theElement)
         {
         removeReferenceAbs (toTlObj_cast (theElement));
         }

d329 1
a329 1
      inline bool contains (const TheType * theObject) const
@


1.13
log
@Began implementation of Proportionate Routing.
@
text
@d242 5
a246 3
      std::list <WitTlObj *>::iterator myListIterator_;
      WitAbsList &                     myAbsList_;
      bool                             iterating_;
@


1.12
log
@Minor changes.
@
text
@d242 3
a244 3
      std::list<WitTlObj*>::iterator myListIterator_;
      WitAbsList&                    theList_;
      bool                           iterating_;
@


1.11
log
@Replaced some C-style casts with C++ style casts.
@
text
@d140 1
a140 1
      void       removeReferenceAbs (const WitTlObj * theElement);
d174 1
a174 1
      std::list<WitTlObj*> myListData_;
d176 1
a176 1
         // The std::list (TlObj) for which this AbsList is a wrapper.
d180 3
a182 1
// Class ListItr (List Iterator)
@


1.10
log
@Various internal changes.
@
text
@d24 1
d28 2
a29 1
#define name2(a,b) _name2(a,b) /* to force the args to be evaluated here */
d292 1
a292 1
         appendAbs ((WitTlObj *) theInstance);
d297 1
a297 1
         return (TheType *) firstAbs ();
d302 1
a302 1
         return (TheType *) getAbs ();
d307 1
a307 1
         return (TheType *) lastAbs ();
d312 1
a312 1
         prependAbs ((WitTlObj *) theInstance);
d317 1
a317 1
         removeReferenceAbs ((WitTlObj *) theElement);
d322 1
a322 1
         return (TheType *) atAbs (theIndex);
d327 1
a327 1
         return theItr.advance ((WitTlObj * &) theElement, * this);
d332 1
a332 1
         appendUniquelyAbs ((WitTlObj *) theObject);
d337 1
a337 1
         return containsAbs ((WitTlObj *) theObject);
d345 3
a347 1
         return (TheType *) findAbs ((WitAbsListKeyFunc) theFunc, theCstring);
@


1.9
log
@Various internal changes.
@
text
@d283 1
a283 1
      inline void copy (const WitList <TheType> & theList)
d352 1
a352 1
      noCopyCtorAssignTemp (WitList, TheType);
@


1.8
log
@Internal changes.
@
text
@d257 1
a257 1
template <class TheType> 
@


1.7
log
@modications to change rogueWave tools.h++ to STL
@
text
@d70 1
a70 1
      inline WitBoolean isEmpty () const
d72 1
a72 1
            // Returns TRUE iff this AbsList is empty.
d160 1
a160 1
      WitBoolean containsAbs (const WitTlObj * theObject) const;
d162 1
a162 1
         // Returns TRUE, iff theObject is in this AbsList.
d217 1
a217 1
      WitBoolean advance ();
d220 1
a220 1
         // Returns TRUE iff the advance did not move beyond the end of the
d223 1
a223 1
      WitBoolean advance (
d229 2
a230 2
         // TRUE. Otherwise this function sets theElement to NULL and
         // returns FALSE. This Itr is required to be attached to theAbsList.
d323 1
a323 4
      inline WitBoolean advance (
            WitListItr & theItr,
            TheType * &  theElement)
            const
d333 1
a333 1
      inline WitBoolean contains (const TheType * theObject) const
@


1.6
log
@Preliminary work on single source.
@
text
@d25 4
a28 1
#include <rw/gslist.h>
d34 1
a34 1
// It is Implemented as a wrapper for RWGSlist(void).
a47 2
declare (RWGSlist, WitTlObj)

d56 1
a56 1
      // corresponding RWGSlist member functions and operators.
d67 1
a67 1
         return myRWData_.entries ();
d74 1
a74 1
         return myRWData_.isEmpty ();
d81 1
a81 1
      // corresponding RWGSlist member functions and operators.
d124 1
a124 1
      WitTlObj * prependAbs (WitTlObj * theObject);
d126 2
a127 2
         // Adds theObject to the beginning of this AbsList and returns
         // it. Generates a severe error if the prepending was unsuccessful,
d135 2
d138 1
a138 1
      WitTlObj * removeReferenceAbs (const WitTlObj * theElement);
d172 1
a172 1
      RWGSlist (WitTlObj) myRWData_;
d174 1
a174 1
         // The RWGSlist (TlObj) for which this AbsList is a wrapper.
d182 1
a182 1
// a wrapper for class RWGSlistIterator (Tl). Since AbsList is only a base
d238 3
a240 1
      RWGSlistIterator (WitTlObj) myRWData_;
d308 1
a308 1
      inline TheType * prepend (TheType * theInstance)
d310 1
a310 1
         return (TheType *) prependAbs ((WitTlObj *) theInstance);
d313 1
a313 1
      inline TheType * removeReference (const TheType * theElement)
d315 1
a315 1
         return (TheType *) removeReferenceAbs ((WitTlObj *) theElement);
d347 1
a347 1
         }
@


1.6.2.1
log
@Migration from Roguewave tools.h++ to STL
@
text
@d25 1
a25 4
#include <list>

#define name2(a,b) _name2(a,b) /* to force the args to be evaluated here */
#define _name2(a,b) a##b
d31 1
a31 1
// It is Implemented as a wrapper for list(void).
d45 2
d55 1
a55 1
      // corresponding list member functions and operators.
d66 1
a66 1
         return myListData_.size ();
d73 1
a73 1
         return myListData_.empty ();
d80 1
a80 1
      // corresponding list member functions and operators.
d123 1
a123 1
      void       prependAbs (WitTlObj * theObject);
d125 2
a126 2
         // Adds theObject to the beginning of this AbsList.
         // Generates a severe error if the prepending was unsuccessful,
a133 2
         // Use this carefuly: this is a very expensive method to call,
         // and should not be used from a loop.
d135 1
a135 1
      void       removeReferenceAbs (const WitTlObj * theElement);
d169 1
a169 1
      std::list<WitTlObj*> myListData_;
d171 1
a171 1
         // The std::list (TlObj) for which this AbsList is a wrapper.
d179 1
a179 1
// a wrapper for class list::iterator (Tl). Since AbsList is only a base
d235 1
a235 3
      std::list<WitTlObj*>::iterator myListIterator_;
      WitAbsList&                    theList_;
      bool                           iterating_;
d303 1
a303 1
      inline void prepend (TheType * theInstance)
d305 1
a305 1
         prependAbs ((WitTlObj *) theInstance);
d308 1
a308 1
      inline void removeReference (const TheType * theElement)
d310 1
a310 1
         removeReferenceAbs ((WitTlObj *) theElement);
d342 1
a342 1
      }
@


1.5
log
@Preliminary work on single source.
@
text
@d101 1
a101 1
      void copyOf (const WitAbsList & theAbsList);
d278 1
a278 1
      inline void copyOf (const WitList <TheType> & theList)
d280 1
a280 1
         WitAbsList::copyOf (theList);
@


1.4
log
@Began implementation of object iteration.
@
text
@d16 1
a16 1
// Contains the declaration of the following classes:
d20 1
a20 1
//    List (TheType)
d36 3
d101 1
a101 1
      void operator = (const WitAbsList & theAbsList);
d103 1
a103 2
         // Assignment operator. 
         // Makes this AbsList a shallow copy of theAbsList.
d167 1
a167 1
      noCopyCtor (WitAbsList);
d239 1
a239 4
// generic class List (TheType)
//
// A List (TheType) is a singly-linked list whose elements are instances of
// TheType. Derived from class AbsList.
d241 2
a242 2
// This is a pointer-based collection class: its methods do not use the copy
// constructor for TheType.
d244 1
a244 3
// To declare and implement this generic classe for YourType,
// check the "Declarations of all specific cases of generic class List",
// which appears in this file, and look for the following line:
d246 2
a247 1
//     declare (WitList, YourType)
d252 78
a329 3
//------------------------------------------------------------------------------
// Declaration macro for generic class List (TheType).
//------------------------------------------------------------------------------
d331 4
a334 105
#define WitListdeclare(TheType)                                                \
                                                                               \
/*---------------------------------------------------------------------------*/\
/* Declaration of class List (TheType).                                      */\
/*---------------------------------------------------------------------------*/\
                                                                               \
class WitList (TheType): public WitAbsList                                     \
   {                                                                           \
   public:                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Constructor functions.                                              */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline WitList (TheType) ():                                             \
            WitAbsList ()                                                      \
         {                                                                     \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Destructor function.                                                */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline ~WitList (TheType) ()                                             \
         {                                                                     \
         }                                                                     \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Wrappers around AbsList member functions.                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      inline void operator = (const WitList (TheType) & theList)               \
         {                                                                     \
         WitAbsList::operator = (theList);                                     \
         }                                                                     \
                                                                               \
      inline void append (TheType * theInstance)                               \
         {                                                                     \
         appendAbs ((WitTlObj *) theInstance);                                 \
         }                                                                     \
                                                                               \
      inline TheType * first () const                                          \
         {                                                                     \
         return (TheType *) firstAbs ();                                       \
         }                                                                     \
                                                                               \
      inline TheType * get ()                                                  \
         {                                                                     \
         return (TheType *) getAbs ();                                         \
         }                                                                     \
                                                                               \
      inline TheType * last () const                                           \
         {                                                                     \
         return (TheType *) lastAbs ();                                        \
         }                                                                     \
                                                                               \
      inline TheType * prepend (TheType * theInstance)                         \
         {                                                                     \
         return (TheType *) prependAbs ((WitTlObj *) theInstance);             \
         }                                                                     \
                                                                               \
      inline TheType * removeReference (const TheType * theElement)            \
         {                                                                     \
         return (TheType *) removeReferenceAbs ((WitTlObj *) theElement);      \
         }                                                                     \
                                                                               \
      inline TheType * at (size_t theIndex) const                              \
         {                                                                     \
         return (TheType *) atAbs (theIndex);                                  \
         }                                                                     \
                                                                               \
      inline WitBoolean advance (                                              \
            WitListItr & theItr,                                               \
            TheType * &  theElement)                                           \
            const                                                              \
         {                                                                     \
         return theItr.advance ((WitTlObj * &) theElement, * this);            \
         }                                                                     \
                                                                               \
      inline void appendUniquely (TheType * theObject)                         \
         {                                                                     \
         appendUniquelyAbs ((WitTlObj *) theObject);                           \
         }                                                                     \
                                                                               \
      inline WitBoolean contains (const TheType * theObject) const             \
         {                                                                     \
         return containsAbs ((WitTlObj *) theObject);                          \
         }                                                                     \
                                                                               \
      inline TheType * find (                                                  \
            const WitString & (* theFunc) (const TheType *),                   \
            const char * theCstring)                                           \
            const                                                              \
         {                                                                     \
         return (TheType *) findAbs ((WitAbsListKeyFunc) theFunc, theCstring); \
         }                                                                     \
                                                                               \
   private:                                                                    \
                                                                               \
      /*---------------------------------------------------------------------*/\
      /* Private member functions.                                           */\
      /*---------------------------------------------------------------------*/\
                                                                               \
      noCopyCtor (WitList (TheType));                                          \
   };                                                                          \
d336 7
a342 3
//------------------------------------------------------------------------------
// Declarations of all specific cases of generic class List.
//------------------------------------------------------------------------------
d344 1
a344 2
declare (WitList, void)
declare (WitList, int)
d346 3
a348 1
declare (WitList, WitString)
d350 2
a351 31
declare (WitList, WitComponent)
declare (WitList, WitNode)
declare (WitList, WitPart)
declare (WitList, WitOperation)
declare (WitList, WitBomEntry)
declare (WitList, WitSubEntry)
declare (WitList, WitBopEntry)
declare (WitList, WitDemand)

declare (WitList, WitDatedPart)

declare (WitList, WitParam)
declare (WitList, WitStringParam)
declare (WitList, WitIntParam)
declare (WitList, WitChoiceParam)

declare (WitList, WitTimingSection)

declare (WitList, WitVariant)

declare (WitList, WitObjFunc)
declare (WitList, WitOptStarter)

declare (WitList, WitSelMgr)

declare (WitList, WitBoundedVar)
declare (WitList, WitCoeff)
declare (WitList, WitLpCon)
declare (WitList, WitLpObj)
declare (WitList, WitLpVar)
declare (WitList, WitModelEl)
d374 1
a374 1
// WitList (WitBomEntry) bom;
@


1.3
log
@Implemented and used class SplitPt.
Removed generic class StackSpSched.
@
text
@d23 1
a23 1
#include <Vector.h>
@


1.2
log
@Removed class MeAltPt.
Changed name of class MeSelPt to MeAltPt.
Implemented de-selection of colliding MeAltPts.
@
text
@d38 1
a38 1
typedef const WitString & (* WitAbsListKeyFunc) (const WitTl *);
d42 1
a42 1
declare (RWGSlist, WitTl)
d103 1
a103 1
      void appendAbs (WitTl * theObject);
d109 1
a109 1
      WitTl * firstAbs () const;
d113 1
a113 1
      WitTl * getAbs ();
d117 1
a117 1
      WitTl * lastAbs () const;
d121 1
a121 1
      WitTl * prependAbs (WitTl * theObject);
d127 1
a127 1
      WitTl * atAbs (size_t theIndex) const;
d133 1
a133 1
      WitTl * removeReferenceAbs (const WitTl * theElement);
d138 1
a138 1
      WitTl * findAbs (
d150 1
a150 1
      void appendUniquelyAbs (WitTl * theObject);
d155 1
a155 1
      WitBoolean containsAbs (const WitTl * theObject) const;
d167 1
a167 1
      RWGSlist (WitTl) myRWData_;
d169 1
a169 1
         // The RWGSlist (Tl) for which this AbsList is a wrapper.
d208 1
a208 1
      WitTl * key ();
d218 3
a220 1
      WitBoolean advance (WitTl * & theElement, const WitAbsList & theAbsList);
d233 1
a233 1
      RWGSlistIterator (WitTl) myRWData_;
d296 1
a296 1
         appendAbs ((WitTl *) theInstance);                                    \
d316 1
a316 1
         return (TheType *) prependAbs ((WitTl *) theInstance);                \
d321 1
a321 1
         return (TheType *) removeReferenceAbs ((WitTl *) theElement);         \
d334 1
a334 1
         return theItr.advance ((WitTl * &) theElement, * this);               \
d339 1
a339 1
         appendUniquelyAbs ((WitTl *) theObject);                              \
d344 1
a344 1
         return containsAbs ((WitTl *) theObject);                             \
@


1.1
log
@Implemented and used class SelMgr.
@
text
@a393 1
declare (WitList, WitMeAltPt)
@


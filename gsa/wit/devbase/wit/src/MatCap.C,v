head	1.105;
access;
symbols
	sce_5_01_20080919:1.90
	latest_sce_4_20_20060523:1.52.0.2
	sce_4_20_20060523:1.52
	latest_sce4_20_OSL:1.51.0.2
	sce_4_20_OSL:1.51
	sce_410_withVa:1.49
	sce_4_05_20040511:1.45
	sce_4_00_20040201:1.33
	nextGenBranch:1.29.0.2
	nextGenRoot:1.29
	sce_3_30_20030627:1.28
	EndRw-branch:1.24.0.4
	Root-of-EndRw:1.24
	rwToStl:1.24.0.2
	latest_sce_3_10_20010924:1.11.0.2
	sce_3_10_20010924:1.11
	latest_sce_3_00_20010601:1.10.0.2
	sce_3_00_20010601:1.10
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.105
date	2011.09.28.23.49.29;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2011.09.24.00.27.49;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2011.08.30.20.17.37;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2010.06.23.18.25.16;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2010.06.18.14.15.17;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.17.16.29.47;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2010.06.17.16.17.14;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.06.16.18.33.37;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.01.06.20.42.40;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2009.12.30.18.30.36;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.29.23.24.32;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.29.21.28.04;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.18.19.00.01;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2009.11.17.22.54.48;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2007.12.11.22.00.27;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2007.11.15.17.15.33;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.13.20.17.39;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2007.11.07.21.50.12;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2007.10.15.21.50.34;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2007.10.02.18.32.43;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2007.09.28.22.08.25;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.11.18.55.18;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.11.18.09.17;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.10.14.44.07;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.08.01.22.41.57;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.07.17.22.10.26;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.07.16.20.14.59;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.07.16.18.12.33;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.13.23.05.32;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.08.18.09.39;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.06.16.28.02;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.05.21.06.00;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.05.16.15.23;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.30.22.57.06;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.30.16.01.19;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.25.18.39.10;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.24.18.52.21;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.22.15.46.52;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.10.21.58.10;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.10.17.22.14;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.04.23.27.10;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.02.28.20.04.57;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.27.22.59.29;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.27.19.59.31;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.08.22.47.34;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.01.09.21.07.48;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.01.09.19.14.15;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.05.21.11.05;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.02.17.34.01;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.24.22.28.52;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.30.21.57.55;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.13.16.48.47;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.24.23.23.56;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.10.19.46.47;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.14.21.16.17;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.01.21.05.12;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.31.22.56.08;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.24.22.21.31;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.23.19.14.24;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.10.22.53.19;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.04.19.53.26;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.03.22.36.21;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.03.19.07.27;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.09.22.44.05;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.11.18.29.13;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.08.19.27.49;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.25.23.49.55;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.10.22.58.16;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.19.16.48.18;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.13.23.06.28;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.02.23.40.42;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.02.22.18.31;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.11.18.53.09;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.05.19.31.33;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.04.23.07.21;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.03.22.35.19;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.03.16.01.49;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.30.20.08.59;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.29.21.35.46;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.08.19.21.51;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.03.23.16.38;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.22.14.32.08;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.18.14.02.35;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.29.23.47.08;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.28.00.12.58;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.19.18.50.57;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.17.20.02.19;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.17.15.11.14;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.06.19.22.09;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.16.37.05;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.04.22.27.51;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.20.03.24;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.19.55.23;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.22.35.32;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.05;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.24;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.24;	author wit;	state Exp;
branches;
next	;


desc
@@


1.105
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "MatCap.C"
//
// Contains the implementation of the following classes:
//
//    Material
//    Capacity
//------------------------------------------------------------------------------

#include <Material.h>
#include <Capacity.h>
#include <GlobalComp.h>
#include <StockBS.h>
#include <CompMgr.h>
#include <DataWrit.h>
#include <wit.h>
#include <Pre.h>
#include <Post.h>
#include <DetOptImpMgr.h>
#include <StochImpMgr.h>
#include <OptComp.h>
#include <IVRealArg.h>
#include <MsgFac.h>
#include <MsgFrag.h>

//------------------------------------------------------------------------------
// Implementation of class Material.
//------------------------------------------------------------------------------

WitMaterial::WitMaterial (const char * theName, WitCompMgr * theCompMgr):

      WitPart       (theName, theCompMgr),

      mappingIndex_ (myCompMgr ()->nMaterials ()),
      stockCost_    (myProblem (), defStockCost ()),
      stockBounds_  (NULL),
      myBaDir_      (noBa),
      buildAheadUB_ (myProblem (), defBuildAheadUB (myProblem ())),
      baSelSplit_   (defBaSelSplit ()),
      asapPipOrder_ (defAsapPipOrder ()),
      mandEC_       (myProblem (), false),
      stockVol_     (myProblem (), 0.0)
   {
   stockBounds_ = new WitStockBoundSet (this);

   myCompMgr ()->insert (this);
   }

//------------------------------------------------------------------------------

WitMaterial::~WitMaterial ()
   {
   delete stockBounds_;
   }

//------------------------------------------------------------------------------

int WitMaterial::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nMaterials ();
   }

//------------------------------------------------------------------------------

int WitMaterial::defBuildAheadUB (WitProblem * theProblem)
   {
   return theProblem->lastPeriod ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitMaterial::setStockCost (const WitIVRealArg & theValue)
   {
   witAssert (theValue != NULL);

   prepSetScenSpecAttr ("stockCost");

   stockCost_.curDblFlexVec () = theValue;
   }

//------------------------------------------------------------------------------

void WitMaterial::setBuildNstn (bool theValue)
   {
   prepSetUnpostAttr ();

   if (theValue != buildNstn ())
      myBaDir_ = theValue? nstn: noBa;
   }

//------------------------------------------------------------------------------

void WitMaterial::setBuildAsap (bool theValue)
   {
   prepSetUnpostAttr ();

   if (theValue != buildAsap ())
      myBaDir_ = theValue? asap: noBa;
   }

//------------------------------------------------------------------------------

void WitMaterial::setBuildAheadUB (const int * theValue)
   {
   WitPeriod thePer;

   witAssert (theValue != NULL);

   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         witAssert    (theValue[thePer] >= 0);
         witAssert    (theValue[thePer] <  nPeriods ());

         if (thePer <= nPeriods () - 2)
            witAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
         }

   prepSetUnpostAttr ();

   buildAheadUB_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMaterial::setBaSelSplit (bool theValue)
   {
   prepSetUnpostAttr ();

   baSelSplit_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMaterial::setAsapPipOrder (bool theValue)
   {
   prepSetUnpostAttr ();

   asapPipOrder_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMaterial::storePreMandEC (WitPeriod thePer, bool theValue)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   mandEC_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitMaterial::storePostStockVol (const WitTVec <double> & theTVec)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   stockVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitMaterial::storeOptStockVol (WitPeriod thePer, double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   stockVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitMaterial::storeStochStockCost (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   stockCost_.curDblFlexVec () = theFlexVec;
   }

//------------------------------------------------------------------------------

void WitMaterial::storeStochStockVol (const WitDblFlexVec & theFlexVec)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   stockVol_ = theFlexVec;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitMaterial::writeMultiObjVecs (WitObjective * theObj)
   {
   WitPart::writeMultiObjVecs (theObj);

   stockCost_.writeDataMulti ("stockCost", this, theObj);
   }

//------------------------------------------------------------------------------

void WitMaterial::copySelfInto (WitCompMgr * theCompMgr)
   {
   WitMaterial * theMat;

   theMat = new WitMaterial (partName ().myCstring (), theCompMgr);

   theMat->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitMaterial::recount ()
   {
   recountPart ();

   mappingIndex_ = myCompMgr ()->nMaterials ();

   myCompMgr ()->recountMaterial (this);
   }

//------------------------------------------------------------------------------

void WitMaterial::unpreprocess ()
   {
   mandEC_ = false;

   WitPart::unpreprocess ();
   }

//------------------------------------------------------------------------------

void WitMaterial::clearOptSoln  ()
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());

   WitPart::clearOptSoln  ();

   stockVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitMaterial::clearStochSoln ()
   {
   WitPart::clearStochSoln ();

   stockVol_ = 0.0;
   }

//------------------------------------------------------------------------------

WitMaterial * WitMaterial::thisMat ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitMsgFrag WitMaterial::categoryFrag ()
   {
   WitMsgFragID theFragID;

   theFragID =
      not wit34Compatible ()?            "materialFrag":
      producingBopEntries ().isEmpty ()? "rawMaterialFrag":
                                         "productFrag";

   return myMsgFac ().myFrag (theFragID);
   }

//------------------------------------------------------------------------------

WitAttr WitMaterial::apiCategory ()
   {
   if (not wit34Compatible ())
      return WitMATERIAL;

   if (producingBopEntries ().isEmpty ())
      return WitRAW;

   return WitPRODUCT;
   }

//------------------------------------------------------------------------------

bool WitMaterial::canStock (WitPeriod thePer)
   {
   return not mandEC ()[thePer];
   }

//------------------------------------------------------------------------------

void WitMaterial::display ()
   {
   WitPart::display ();

   myMsgFac () ("materialDdMsg", 
      partName (), 
      mappingIndex_,
      nstnBaNeeded (),
      buildAsap (),
      baSelSplit_,
      asapPipOrder_);

   myProblem ()->display ("buildAheadUBDdMsg", buildAheadUB_);
   myProblem ()->display ("stockCostDdMsg",    stockCost_);

   stockBounds_->display ();

   if (myPreprocessor ()->preprocessed ())
      myProblem ()->display ("mecDdMsg", mandEC_);
   }

//------------------------------------------------------------------------------

void WitMaterial::copyAttrsFrom (WitMaterial * theMat)
   {
   WitPart::copyAttrsFrom (theMat);

   stockCost_      = theMat->stockCost_;
   myBaDir_        = theMat->myBaDir_;
   buildAheadUB_   = theMat->buildAheadUB_;
   baSelSplit_     = theMat->baSelSplit_;
   asapPipOrder_   = theMat->asapPipOrder_;
   stockBounds_->
      copyAttrsFrom (theMat->stockBounds_);
   }

//------------------------------------------------------------------------------

bool WitMaterial::nstnBaNeeded ()
   {
   return
      buildNstn ()?                        true:
      buildAsap ()?                        false:
      myGlobalComp ()->localBuildAhead ()? true:
                                           false;
   }

//------------------------------------------------------------------------------
// rollBackScrap.
// Moves scrapping of theMat backward in time so all
// scrapping of theMat is done as early as possible. The volume of
// scrap, rollBackVol, that can be rolled back from period t+1 to period t is
// the minimum of the amount by which the stock volume in period t exceeds its
// soft lower bound (if any) and the scrap volume in period t+1.
//------------------------------------------------------------------------------

void WitMaterial::rollBackScrap (
      WitTVec <double> & theStockVol,
      WitTVec <double> & theScrapVol)
   {
   WitPeriod thePer;
   double    rollBackVol;

   for (thePer = lastPeriod () - 1; thePer >= 0; thePer --)
      {
      rollBackVol = theStockVol[thePer] - stockBounds_->softLB ()[thePer];

      setToMin (rollBackVol, theScrapVol[thePer + 1]);

      if (rollBackVol > FLOAT_EPSILON)
         {
         theScrapVol[thePer + 1] -= rollBackVol;
         theStockVol[thePer]     -= rollBackVol;
         theScrapVol[thePer]     += rollBackVol;
         }
      }
   }

//------------------------------------------------------------------------------

WitBoundSet * WitMaterial::myBoundSet ()
   {
   return stockBounds_;
   }

//------------------------------------------------------------------------------

const char * WitMaterial::categoryKeyWord ()
   {
   return "material";
   }

//------------------------------------------------------------------------------

void WitMaterial::writeDataAttrs ()
   {
   WitPart::writeDataAttrs ();

   myDataWriter ()->writeObjVec (
        "stockCost",
         stockCost_,
      defStockCost ());

   stockBounds_->writeData ();

   myDataWriter ()->writeBool ("buildNstn", buildNstn (), false);
   myDataWriter ()->writeBool ("buildAsap", buildAsap (), false);

   myDataWriter ()->writeVector (
      "buildAheadUB",
      buildAheadUB (),
      defBuildAheadUB (myProblem ()));

   myDataWriter ()->writeBool ("baSelSplit", baSelSplit (), defBaSelSplit ());

   myDataWriter ()->
      writeBool ("asapPipOrder", asapPipOrder (), defAsapPipOrder ());
   }

//------------------------------------------------------------------------------

WitPeriod WitMaterial::findExplosionPeriod (WitPeriod fillPer)
   {
   WitPeriod expPer;

   for (expPer = fillPer; expPer >= 0; expPer --)
      {
      if (expPer < fillPer)
         if (mandEC ()[expPer])
            break;

      if (explodeable (expPer))
         return expPer;
      }

   return fillPer;
   }

//------------------------------------------------------------------------------
// Implementation of class Capacity.
//------------------------------------------------------------------------------

WitCapacity::WitCapacity (const char * theName, WitCompMgr * theCompMgr):

      WitPart (theName, theCompMgr)
   {
   myCompMgr ()->insert (this);
   }

//------------------------------------------------------------------------------

WitCapacity::~WitCapacity ()
   {
   }

//------------------------------------------------------------------------------

void WitCapacity::copySelfInto (WitCompMgr * theCompMgr)
   {
   WitCapacity * theCap;

   theCap = new WitCapacity (partName ().myCstring (), theCompMgr);

   theCap->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitCapacity::recount ()
   {
   recountPart ();

   myCompMgr ()->recountCapacity (this);
   }

//------------------------------------------------------------------------------

WitCapacity * WitCapacity::thisCap ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitMsgFrag WitCapacity::categoryFrag ()
   {
   return myMsgFac ().myFrag ("capacityFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitCapacity::apiCategory ()
   {
   return WitCAPACITY;
   }

//------------------------------------------------------------------------------

bool WitCapacity::canStock (WitPeriod)
   {
   return false;
   }

//------------------------------------------------------------------------------

void WitCapacity::copyAttrsFrom (WitCapacity * theCap)
   {
   WitPart::copyAttrsFrom (theCap);
   }

//------------------------------------------------------------------------------

const char * WitCapacity::categoryKeyWord ()
   {
   return "capacity";
   }

//------------------------------------------------------------------------------

void WitCapacity::writeDataAttrs ()
   {
   WitPart::writeDataAttrs ();
   }

//------------------------------------------------------------------------------

WitPeriod WitCapacity::findExplosionPeriod (WitPeriod)
   {
   stronglyAssert (false);

   return -1;
   }
@


1.104
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.103
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d41 1
a41 1
WitPart       (theName, theCompMgr),
d43 11
a53 11
mappingIndex_ (myCompMgr ()->nMaterials ()),
stockCost_    (myProblem (), defStockCost ()),
stockBounds_  (NULL),
myBaDir_      (noBa),
buildAheadUB_ (myProblem (), defBuildAheadUB (myProblem ())),
baSelSplit_   (defBaSelSplit ()),
asapPipOrder_ (defAsapPipOrder ()),
mandEC_       (myProblem (), false),
stockVol_     (myProblem (), 0.0)
{
stockBounds_ = new WitStockBoundSet (this);
d55 2
a56 2
myCompMgr ()->insert (this);
}
d61 3
a63 3
{
delete stockBounds_;
}
d68 3
a70 3
{
return theProblem->myCompMgr ()->nMaterials ();
}
d75 3
a77 3
{
return theProblem->lastPeriod ();
}
d84 2
a85 2
{
witAssert (theValue != NULL);
d87 1
a87 1
prepSetScenSpecAttr ("stockCost");
d89 2
a90 2
stockCost_.curDblFlexVec () = theValue;
}
d95 2
a96 2
{
prepSetUnpostAttr ();
d98 3
a100 3
if (theValue != buildNstn ())
myBaDir_ = theValue? nstn: noBa;
}
d105 2
a106 2
{
prepSetUnpostAttr ();
d108 3
a110 3
if (theValue != buildAsap ())
myBaDir_ = theValue? asap: noBa;
}
d115 2
a116 2
{
WitPeriod thePer;
d118 1
a118 1
witAssert (theValue != NULL);
d120 5
a124 5
if (DEBUG_MODE)
forEachPeriod (thePer, myProblem ())
{
witAssert    (theValue[thePer] >= 0);
witAssert    (theValue[thePer] <  nPeriods ());
d126 3
a128 3
if (thePer <= nPeriods () - 2)
witAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
}
d130 1
a130 1
prepSetUnpostAttr ();
d132 2
a133 2
buildAheadUB_ = theValue;
}
d138 2
a139 2
{
prepSetUnpostAttr ();
d141 2
a142 2
baSelSplit_ = theValue;
}
d147 2
a148 2
{
prepSetUnpostAttr ();
d150 2
a151 2
asapPipOrder_ = theValue;
}
d156 2
a157 2
{
witAssert (myPreprocessor ()->preprocessing ());
d159 2
a160 2
mandEC_.elemRef (thePer) = theValue;
}
d165 2
a166 2
{
witAssert (myPostprocessor ()->postprocessing ());
d168 2
a169 2
stockVol_ = theTVec;
}
d174 2
a175 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d177 2
a178 2
stockVol_.elemRef (thePer) = theValue;
}
d183 2
a184 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d186 2
a187 2
stockCost_.curDblFlexVec () = theFlexVec;
}
d192 2
a193 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d195 2
a196 2
stockVol_ = theFlexVec;
}
d203 2
a204 2
{
WitPart::writeMultiObjVecs (theObj);
d206 2
a207 2
stockCost_.writeDataMulti ("stockCost", this, theObj);
}
d212 2
a213 2
{
WitMaterial * theMat;
d215 1
a215 1
theMat = new WitMaterial (partName ().myCstring (), theCompMgr);
d217 2
a218 2
theMat->copyAttrsFrom (this);
}
d223 2
a224 2
{
recountPart ();
d226 1
a226 1
mappingIndex_ = myCompMgr ()->nMaterials ();
d228 2
a229 2
myCompMgr ()->recountMaterial (this);
}
d234 2
a235 2
{
mandEC_ = false;
d237 2
a238 2
WitPart::unpreprocess ();
}
d243 2
a244 2
{
witAssert (myDetOptImpMgr ()->clearingSoln ());
d246 1
a246 1
WitPart::clearOptSoln  ();
d248 2
a249 2
stockVol_ = 0.0;
}
d254 2
a255 2
{
WitPart::clearStochSoln ();
d257 2
a258 2
stockVol_ = 0.0;
}
d263 3
a265 3
{
return this;
}
d270 2
a271 2
{
WitMsgFragID theFragID;
d273 4
a276 4
theFragID =
not wit34Compatible ()?            "materialFrag":
producingBopEntries ().isEmpty ()? "rawMaterialFrag":
"productFrag";
d278 2
a279 2
return myMsgFac ().myFrag (theFragID);
}
d284 3
a286 3
{
if (not wit34Compatible ())
return WitMATERIAL;
d288 2
a289 2
if (producingBopEntries ().isEmpty ())
return WitRAW;
d291 2
a292 2
return WitPRODUCT;
}
d297 3
a299 3
{
return not mandEC ()[thePer];
}
d304 2
a305 2
{
WitPart::display ();
d307 16
a322 16
myMsgFac () ("materialDdMsg",
partName (),
mappingIndex_,
nstnBaNeeded (),
buildAsap (),
baSelSplit_,
asapPipOrder_);

myProblem ()->display ("buildAheadUBDdMsg", buildAheadUB_);
myProblem ()->display ("stockCostDdMsg",    stockCost_);

stockBounds_->display ();

if (myPreprocessor ()->preprocessed ())
myProblem ()->display ("mecDdMsg", mandEC_);
}
d327 2
a328 2
{
WitPart::copyAttrsFrom (theMat);
d330 8
a337 8
stockCost_      = theMat->stockCost_;
myBaDir_        = theMat->myBaDir_;
buildAheadUB_   = theMat->buildAheadUB_;
baSelSplit_     = theMat->baSelSplit_;
asapPipOrder_   = theMat->asapPipOrder_;
stockBounds_->
copyAttrsFrom (theMat->stockBounds_);
}
d342 7
a348 7
{
return
buildNstn ()?                        true:
buildAsap ()?                        false:
myGlobalComp ()->localBuildAhead ()? true:
false;
}
d360 20
a379 20
WitTVec <double> & theStockVol,
WitTVec <double> & theScrapVol)
{
WitPeriod thePer;
double    rollBackVol;

for (thePer = lastPeriod () - 1; thePer >= 0; thePer --)
{
rollBackVol = theStockVol[thePer] - stockBounds_->softLB ()[thePer];

setToMin (rollBackVol, theScrapVol[thePer + 1]);

if (rollBackVol > FLOAT_EPSILON)
{
theScrapVol[thePer + 1] -= rollBackVol;
theStockVol[thePer]     -= rollBackVol;
theScrapVol[thePer]     += rollBackVol;
}
}
}
d384 3
a386 3
{
return stockBounds_;
}
d391 3
a393 3
{
return "material";
}
d398 2
a399 2
{
WitPart::writeDataAttrs ();
d401 4
a404 4
myDataWriter ()->writeObjVec (
"stockCost",
stockCost_,
defStockCost ());
d406 1
a406 1
stockBounds_->writeData ();
d408 2
a409 2
myDataWriter ()->writeBool ("buildNstn", buildNstn (), false);
myDataWriter ()->writeBool ("buildAsap", buildAsap (), false);
d411 4
a414 4
myDataWriter ()->writeVector (
"buildAheadUB",
buildAheadUB (),
defBuildAheadUB (myProblem ()));
d416 1
a416 1
myDataWriter ()->writeBool ("baSelSplit", baSelSplit (), defBaSelSplit ());
d418 3
a420 3
myDataWriter ()->
writeBool ("asapPipOrder", asapPipOrder (), defAsapPipOrder ());
}
d425 2
a426 2
{
WitPeriod expPer;
d428 9
a436 9
for (expPer = fillPer; expPer >= 0; expPer --)
{
if (expPer < fillPer)
if (mandEC ()[expPer])
break;

if (explodeable (expPer))
return expPer;
}
d438 2
a439 2
return fillPer;
}
d447 4
a450 4
WitPart (theName, theCompMgr)
{
myCompMgr ()->insert (this);
}
d455 2
a456 2
{
}
d461 2
a462 2
{
WitCapacity * theCap;
d464 1
a464 1
theCap = new WitCapacity (partName ().myCstring (), theCompMgr);
d466 2
a467 2
theCap->copyAttrsFrom (this);
}
d472 2
a473 2
{
recountPart ();
d475 2
a476 2
myCompMgr ()->recountCapacity (this);
}
d481 3
a483 3
{
return this;
}
d488 3
a490 3
{
return myMsgFac ().myFrag ("capacityFrag");
}
d495 3
a497 3
{
return WitCAPACITY;
}
d502 3
a504 3
{
return false;
}
d509 3
a511 3
{
WitPart::copyAttrsFrom (theCap);
}
d516 3
a518 3
{
return "capacity";
}
d523 3
a525 3
{
WitPart::writeDataAttrs ();
}
d530 2
a531 2
{
stronglyAssert (false);
d533 2
a534 2
return -1;
}
@


1.102
log
@Lead Time Bounds
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d41 1
a41 1
      WitPart       (theName, theCompMgr),
d43 11
a53 11
      mappingIndex_ (myCompMgr ()->nMaterials ()),
      stockCost_    (myProblem (), defStockCost ()),
      stockBounds_  (NULL),
      myBaDir_      (noBa),
      buildAheadUB_ (myProblem (), defBuildAheadUB (myProblem ())),
      baSelSplit_   (defBaSelSplit ()),
      asapPipOrder_ (defAsapPipOrder ()),
      mandEC_       (myProblem (), false),
      stockVol_     (myProblem (), 0.0)
   {
   stockBounds_ = new WitStockBoundSet (this);
d55 2
a56 2
   myCompMgr ()->insert (this);
   }
d61 3
a63 3
   {
   delete stockBounds_;
   }
d68 3
a70 3
   {
   return theProblem->myCompMgr ()->nMaterials ();
   }
d75 3
a77 3
   {
   return theProblem->lastPeriod ();
   }
d84 2
a85 2
   {
   witAssert (theValue != NULL);
d87 1
a87 1
   prepSetScenSpecAttr ("stockCost");
d89 2
a90 2
   stockCost_.curDblFlexVec () = theValue;
   }
d95 2
a96 2
   {
   prepSetUnpostAttr ();
d98 3
a100 3
   if (theValue != buildNstn ())
      myBaDir_ = theValue? nstn: noBa;
   }
d105 2
a106 2
   {
   prepSetUnpostAttr ();
d108 3
a110 3
   if (theValue != buildAsap ())
      myBaDir_ = theValue? asap: noBa;
   }
d115 2
a116 2
   {
   WitPeriod thePer;
d118 1
a118 1
   witAssert (theValue != NULL);
d120 5
a124 5
   if (DEBUG_MODE)
      forEachPeriod (thePer, myProblem ())
         {
         witAssert    (theValue[thePer] >= 0);
         witAssert    (theValue[thePer] <  nPeriods ());
d126 3
a128 3
         if (thePer <= nPeriods () - 2)
            witAssert (theValue[thePer + 1] <= theValue[thePer] + 1);
         }
d130 1
a130 1
   prepSetUnpostAttr ();
d132 2
a133 2
   buildAheadUB_ = theValue;
   }
d138 2
a139 2
   {
   prepSetUnpostAttr ();
d141 2
a142 2
   baSelSplit_ = theValue;
   }
d147 2
a148 2
   {
   prepSetUnpostAttr ();
d150 2
a151 2
   asapPipOrder_ = theValue;
   }
d156 2
a157 2
   {
   witAssert (myPreprocessor ()->preprocessing ());
d159 2
a160 2
   mandEC_.elemRef (thePer) = theValue;
   }
d165 2
a166 2
   {
   witAssert (myPostprocessor ()->postprocessing ());
d168 2
a169 2
   stockVol_ = theTVec;
   }
d174 2
a175 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d177 2
a178 2
   stockVol_.elemRef (thePer) = theValue;
   }
d183 2
a184 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d186 2
a187 2
   stockCost_.curDblFlexVec () = theFlexVec;
   }
d192 2
a193 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d195 2
a196 2
   stockVol_ = theFlexVec;
   }
d203 2
a204 2
   {
   WitPart::writeMultiObjVecs (theObj);
d206 2
a207 2
   stockCost_.writeDataMulti ("stockCost", this, theObj);
   }
d212 2
a213 2
   {
   WitMaterial * theMat;
d215 1
a215 1
   theMat = new WitMaterial (partName ().myCstring (), theCompMgr);
d217 2
a218 2
   theMat->copyAttrsFrom (this);
   }
d223 2
a224 2
   {
   recountPart ();
d226 1
a226 1
   mappingIndex_ = myCompMgr ()->nMaterials ();
d228 2
a229 2
   myCompMgr ()->recountMaterial (this);
   }
d234 2
a235 2
   {
   mandEC_ = false;
d237 2
a238 2
   WitPart::unpreprocess ();
   }
d243 2
a244 2
   {                              
   witAssert (myDetOptImpMgr ()->clearingSoln ());
d246 1
a246 1
   WitPart::clearOptSoln  ();
d248 2
a249 2
   stockVol_ = 0.0;
   }
d254 2
a255 2
   {
   WitPart::clearStochSoln ();
d257 2
a258 2
   stockVol_ = 0.0;
   }
d263 3
a265 3
   {
   return this;
   }
d270 2
a271 2
   {
   WitMsgFragID theFragID;
d273 4
a276 4
   theFragID =
      not wit34Compatible ()?            "materialFrag":
      producingBopEntries ().isEmpty ()? "rawMaterialFrag":
                                         "productFrag";
d278 2
a279 2
   return myMsgFac ().myFrag (theFragID);
   }
d284 3
a286 3
   {
   if (not wit34Compatible ())
      return WitMATERIAL;
d288 2
a289 2
   if (producingBopEntries ().isEmpty ())
      return WitRAW;
d291 2
a292 2
   return WitPRODUCT;
   }
d297 3
a299 3
   {
   return not mandEC ()[thePer];
   }
d304 2
a305 2
   {
   WitPart::display ();
d307 16
a322 16
   myMsgFac () ("materialDdMsg", 
      partName (), 
      mappingIndex_,
      nstnBaNeeded (),
      buildAsap (),
      baSelSplit_,
      asapPipOrder_);

   myProblem ()->display ("buildAheadUBDdMsg", buildAheadUB_);
   myProblem ()->display ("stockCostDdMsg",    stockCost_);

   stockBounds_->display ();

   if (myPreprocessor ()->preprocessed ())
      myProblem ()->display ("mecDdMsg", mandEC_);
   }
d327 2
a328 2
   {
   WitPart::copyAttrsFrom (theMat);
d330 8
a337 8
   stockCost_      = theMat->stockCost_;
   myBaDir_        = theMat->myBaDir_;
   buildAheadUB_   = theMat->buildAheadUB_;
   baSelSplit_     = theMat->baSelSplit_;
   asapPipOrder_   = theMat->asapPipOrder_;
   stockBounds_->
      copyAttrsFrom (theMat->stockBounds_);
   }
d342 7
a348 7
   {
   return
      buildNstn ()?                        true:
      buildAsap ()?                        false:
      myGlobalComp ()->localBuildAhead ()? true:
                                           false;
   }
d360 20
a379 20
      WitTVec <double> & theStockVol,
      WitTVec <double> & theScrapVol)
   {
   WitPeriod thePer;
   double    rollBackVol;

   for (thePer = lastPeriod () - 1; thePer >= 0; thePer --)
      {
      rollBackVol = theStockVol[thePer] - stockBounds_->softLB ()[thePer];

      setToMin (rollBackVol, theScrapVol[thePer + 1]);

      if (rollBackVol > FLOAT_EPSILON)
         {
         theScrapVol[thePer + 1] -= rollBackVol;
         theStockVol[thePer]     -= rollBackVol;
         theScrapVol[thePer]     += rollBackVol;
         }
      }
   }
d384 3
a386 3
   {
   return stockBounds_;
   }
d391 3
a393 3
   {
   return "material";
   }
d398 2
a399 2
   {
   WitPart::writeDataAttrs ();
d401 4
a404 4
   myDataWriter ()->writeObjVec (
        "stockCost",
         stockCost_,
      defStockCost ());
d406 1
a406 1
   stockBounds_->writeData ();
d408 2
a409 2
   myDataWriter ()->writeBool ("buildNstn", buildNstn (), false);
   myDataWriter ()->writeBool ("buildAsap", buildAsap (), false);
d411 4
a414 4
   myDataWriter ()->writeVector (
      "buildAheadUB",
      buildAheadUB (),
      defBuildAheadUB (myProblem ()));
d416 1
a416 1
   myDataWriter ()->writeBool ("baSelSplit", baSelSplit (), defBaSelSplit ());
d418 3
a420 3
   myDataWriter ()->
      writeBool ("asapPipOrder", asapPipOrder (), defAsapPipOrder ());
   }
d425 2
a426 2
   {
   WitPeriod expPer;
d428 9
a436 9
   for (expPer = fillPer; expPer >= 0; expPer --)
      {
      if (expPer < fillPer)
         if (mandEC ()[expPer])
            break;

      if (explodeable (expPer))
         return expPer;
      }
d438 2
a439 2
   return fillPer;
   }
d447 4
a450 4
      WitPart (theName, theCompMgr)
   {
   myCompMgr ()->insert (this);
   }
d455 2
a456 2
   {
   }
d461 2
a462 2
   {
   WitCapacity * theCap;
d464 1
a464 1
   theCap = new WitCapacity (partName ().myCstring (), theCompMgr);
d466 2
a467 2
   theCap->copyAttrsFrom (this);
   }
d472 2
a473 2
   {
   recountPart ();
d475 2
a476 2
   myCompMgr ()->recountCapacity (this);
   }
d481 3
a483 3
   {
   return this;
   }
d488 3
a490 3
   {
   return myMsgFac ().myFrag ("capacityFrag");
   }
d495 3
a497 3
   {
   return WitCAPACITY;
   }
d502 3
a504 3
   {
   return false;
   }
d509 3
a511 3
   {
   WitPart::copyAttrsFrom (theCap);
   }
d516 3
a518 3
   {
   return "capacity";
   }
d523 3
a525 3
   {
   WitPart::writeDataAttrs ();
   }
d530 2
a531 2
   {
   stronglyAssert (false);
d533 2
a534 2
   return -1;
   }
@


1.101
log
@Lead Time Bounds.
@
text
@d126 2
a127 2
         if (thePer > 0)
            witAssert (theValue[thePer] <= theValue[thePer - 1] + 1);
@


1.100
log
@Lead Time Bounds.
@
text
@d41 1
a41 1
      WitPart          (theName, theCompMgr),
d43 9
a51 10
      mappingIndex_    (myCompMgr ()->nMaterials ()),
      stockCost_       (myProblem (), defStockCost ()),
      stockBounds_     (NULL),
      myBaDir_         (noBa),
      buildAheadUB_    (myProblem (), defBuildAheadUB (myProblem ())),
      boundedLeadTime_ (defBoundedLeadTime ()),
      baSelSplit_      (defBaSelSplit ()),
      asapPipOrder_    (defAsapPipOrder ()),
      mandEC_          (myProblem (), false),
      stockVol_        (myProblem (), 0.0)
a136 11
void WitMaterial::setBoundedLeadTime (bool theValue)
   {
   stronglyAssert (myGlobalComp ()->ltbAllowed ());

   prepSetUnpostAttr ();

   boundedLeadTime_ = theValue;
   }

//------------------------------------------------------------------------------

a311 1
      boundedLeadTime_,
d330 5
a334 6
   stockCost_       = theMat->stockCost_;
   myBaDir_         = theMat->myBaDir_;
   buildAheadUB_    = theMat->buildAheadUB_;
   boundedLeadTime_ = theMat->boundedLeadTime_;
   baSelSplit_      = theMat->baSelSplit_;
   asapPipOrder_    = theMat->asapPipOrder_;
d336 1
a336 1
      copyAttrsFrom  (theMat->stockBounds_);
a415 6
   myDataWriter ()->
      writeBool (
         "boundedLeadTime",
         boundedLeadTime (),
         defBoundedLeadTime ());

@


1.99
log
@Bounded Lead Times
@
text
@d140 1
a140 1
   stronglyAssert (myGlobalComp ()->bltAllowed ());
@


1.98
log
@Bounded Lead Times
@
text
@d41 1
a41 1
      WitPart           (theName, theCompMgr),
d43 10
a52 10
      mappingIndex_     (myCompMgr ()->nMaterials ()),
      stockCost_        (myProblem (), defStockCost ()),
      stockBounds_      (NULL),
      myBaDir_          (noBa),
      buildAheadUB_     (myProblem (), defBuildAheadUB (myProblem ())),
      boundedLeadTimes_ (defBoundedLeadTimes ()),
      baSelSplit_       (defBaSelSplit ()),
      asapPipOrder_     (defAsapPipOrder ()),
      mandEC_           (myProblem (), false),
      stockVol_         (myProblem (), 0.0)
d138 1
a138 1
void WitMaterial::setBoundedLeadTimes (bool theValue)
d144 1
a144 1
   boundedLeadTimes_ = theValue;
d324 1
a324 1
      boundedLeadTimes_,
d343 6
a348 6
   stockCost_        = theMat->stockCost_;
   myBaDir_          = theMat->myBaDir_;
   buildAheadUB_     = theMat->buildAheadUB_;
   boundedLeadTimes_ = theMat->boundedLeadTimes_;
   baSelSplit_       = theMat->baSelSplit_;
   asapPipOrder_     = theMat->asapPipOrder_;
d350 1
a350 1
      copyAttrsFrom   (theMat->stockBounds_);
d432 3
a434 3
         "boundedLeadTimes",
         boundedLeadTimes (),
         defBoundedLeadTimes ());
@


1.97
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d41 1
a41 1
      WitPart       (theName, theCompMgr),
d43 10
a52 9
      mappingIndex_ (myCompMgr ()->nMaterials ()),
      stockCost_    (myProblem (), defStockCost ()),
      stockBounds_  (NULL),
      myBaDir_      (noBa),
      buildAheadUB_ (myProblem (), defBuildAheadUB (myProblem ())),
      baSelSplit_   (defBaSelSplit ()),
      asapPipOrder_ (defAsapPipOrder ()),
      mandEC_       (myProblem (), false),
      stockVol_     (myProblem (), 0.0)
d138 11
d324 1
d343 6
a348 5
   stockCost_      = theMat->stockCost_;
   myBaDir_        = theMat->myBaDir_;
   buildAheadUB_   = theMat->buildAheadUB_;
   baSelSplit_     = theMat->baSelSplit_;
   asapPipOrder_   = theMat->asapPipOrder_;
d350 1
a350 1
      copyAttrsFrom (theMat->stockBounds_);
d430 6
@


1.96
log
@Multi-objective mode
@
text
@d21 1
a21 1
#include <Global.h>
@


1.95
log
@Multi-Objective Mode
@
text
@d41 1
a41 1
      WitPart          (theName, theCompMgr),
d43 9
a51 9
      mappingIndex_    (myCompMgr ()->nMaterials ()),
      stockCostObjVec_ (myProblem (), defStockCost ()),
      stockBounds_     (NULL),
      myBaDir_         (noBa),
      buildAheadUB_    (myProblem (), defBuildAheadUB (myProblem ())),
      baSelSplit_      (defBaSelSplit ()),
      asapPipOrder_    (defAsapPipOrder ()),
      mandEC_          (myProblem (), false),
      stockVol_        (myProblem (), 0.0)
d89 1
a89 1
   stockCostObjVec_ = theValue;
d186 1
a186 1
   stockCostObjVec_ = theFlexVec;
d206 1
a206 1
   stockCostObjVec_.writeDataMulti ("stockCost", this, theObj);
d316 1
a316 1
   myProblem ()->display ("stockCostDdMsg",    stockCostObjVec_);
d330 5
a334 5
   stockCostObjVec_ = theMat->stockCostObjVec_;
   myBaDir_         = theMat->myBaDir_;
   buildAheadUB_    = theMat->buildAheadUB_;
   baSelSplit_      = theMat->baSelSplit_;
   asapPipOrder_    = theMat->asapPipOrder_;
d336 1
a336 1
      copyAttrsFrom  (theMat->stockBounds_);
d403 1
a403 1
         stockCostObjVec_,
@


1.94
log
@Multi-Objective Mode
@
text
@d41 1
a41 1
      WitPart       (theName, theCompMgr),
d43 9
a51 9
      mappingIndex_ (myCompMgr ()->nMaterials ()),
      stockCost_    (myProblem (), defStockCost ()),
      stockBounds_  (NULL),
      myBaDir_      (noBa),
      buildAheadUB_ (myProblem (), defBuildAheadUB (myProblem ())),
      baSelSplit_   (defBaSelSplit ()),
      asapPipOrder_ (defAsapPipOrder ()),
      mandEC_       (myProblem (), false),
      stockVol_     (myProblem (), 0.0)
d89 1
a89 1
   stockCost_ = theValue;
d186 1
a186 1
   stockCost_ = theFlexVec;
d206 1
a206 1
   stockCost_.writeDataMulti ("stockCost", this, theObj);
d316 1
a316 1
   myProblem ()->display ("stockCostDdMsg",    stockCost_);
d330 5
a334 5
   stockCost_    =   theMat->stockCost_;
   myBaDir_      =   theMat->myBaDir_;
   buildAheadUB_ =   theMat->buildAheadUB_;
   baSelSplit_   =   theMat->baSelSplit_;
   asapPipOrder_ =   theMat->asapPipOrder_;
d336 1
a336 1
      copyAttrsFrom (theMat->stockBounds_);
d403 1
a403 1
         stockCost_,
@


1.93
log
@Multi-Objective Mode
@
text
@d44 1
a44 1
      stockCost_    (myProblem ()),
@


1.92
log
@Removing objective #2.
@
text
@d44 1
a44 1
      stockCost_    (myProblem (), defStockCost ()),
d202 9
d401 1
a401 1
   myDataWriter ()->writeVector (
d403 1
a403 1
         stockCost (),
@


1.91
log
@Removing objective #2.
@
text
@a23 1
#include <ObjFunc.h>
@


1.90
log
@Stochastic Implosion
@
text
@d304 2
a305 2
      baSelSplit (),
      asapPipOrder ());
d307 2
a308 3
   myProblem ()->display ("buildAheadUBDdMsg", buildAheadUB ());

   objChoice ()->displayForObj1 ("stockCostDdMsg", stockCost ());
d313 1
a313 1
      myProblem ()->display ("mecDdMsg", mandEC ());
@


1.89
log
@Stochastic Implosion
@
text
@d88 1
a88 1
   prepSetUnpostAttr ();
d183 9
@


1.88
log
@Stochastic Implosion
@
text
@d156 10
a165 1
void WitMaterial::storePostStockVol (const WitTVec <double> & theValue)
d169 1
a169 1
   stockVol_ = theValue;
d183 1
a183 1
void WitMaterial::storeStochStockVol (const WitDblFlexVec & theValue)
d187 1
a187 1
   stockVol_ = theValue;
a215 9
void WitMaterial::passPreRefs ()
   {
   WitPart::passPreRefs ();

   myPreprocessor ()->receiveRefs (this, mandEC_);
   }

//------------------------------------------------------------------------------

@


1.87
log
@Stochastic Implosion
@
text
@d165 9
d225 5
a229 3
void WitMaterial::importOptSoln ()
   {
   WitPart::importOptSoln ();
d231 1
a231 1
   myDetOptImpMgr ()->exportSoln (this, stockVol_);
@


1.86
log
@Stochastic Implosion
@
text
@d28 1
d156 9
@


1.85
log
@Stochastic Implosion
@
text
@d215 9
@


1.84
log
@Stochastic Implosion
@
text
@d155 1
a155 1
void WitMaterial::storeStochStockVol (const WitTVec <double> & theValue)
@


1.83
log
@Stochastic Implosion
@
text
@d157 3
a159 1
   storeStochAttr (stockVol_, theValue);
d272 1
a272 1
   stockBounds ()->display ();
d284 7
a290 7
   stockCost_    = theMat->stockCost_;
   myBaDir_      = theMat->myBaDir_;
   buildAheadUB_ = theMat->buildAheadUB_;
   baSelSplit_   = theMat->baSelSplit_;
   asapPipOrder_ = theMat->asapPipOrder_;

   stockBounds_->set (theMat->stockBounds_);
d322 1
a322 1
      rollBackVol = theStockVol[thePer] - stockBounds ()->softLB ()[thePer];
d337 1
a337 1
WitBoundSet * WitMaterial::myBoundSetForUpdate ()
d360 1
a360 1
   stockBounds ()->writeData ();
@


1.82
log
@Stochastic Implosion
@
text
@d155 1
a155 1
void WitMaterial::loadInStochStockVol (const WitTVec <double> & theValue)
d157 1
a157 1
   loadInStochAttr (stockVol_, theValue);
@


1.81
log
@Stochastic Implosion
@
text
@d154 7
a212 9
void WitMaterial::importStochSoln ()
   {
   WitPart::importStochSoln ();

   myStochImpMgr ()->exportSoln (this, stockVol_);
   }

//------------------------------------------------------------------------------

@


1.80
log
@Stochastic Implosion
@
text
@a16 1
//    StockBoundSet
a488 53

//------------------------------------------------------------------------------
// Implementation of class StockBoundSet.
//------------------------------------------------------------------------------

WitStockBoundSet::WitStockBoundSet (WitMaterial * theMat):
      WitBoundSet (theMat->myProblem ()),
      myMaterial_ (theMat)
   {
   }

//------------------------------------------------------------------------------

WitStockBoundSet::~WitStockBoundSet ()
   {
   }

//------------------------------------------------------------------------------

double WitStockBoundSet::boundedVal (WitPeriod thePer) const
   {
   return myMaterial_->stockVol ()[thePer];
   }

//------------------------------------------------------------------------------

WitAttr WitStockBoundSet::apiAttr () const
   {
   return "stockBounds";
   }

//------------------------------------------------------------------------------

WitMsgID WitStockBoundSet::headingMsgID () const
   {
   return "stockBoundsHeadingDdMsg";
   }

//------------------------------------------------------------------------------

WitAttr WitStockBoundSet::boundedVectorName () const
   {
   return "StockVol";
   }

//------------------------------------------------------------------------------

void WitStockBoundSet::idObjectForSoln () const
   {
   fprintf (myProblem ()->solnFile (),
      "material part \"%s\":\n",
      myMaterial_->partName ().myCstring ());
   }
@


1.79
log
@ASAP Pegging Order.
@
text
@d29 1
a29 1
#include <OptImp.h>
d202 1
a202 1
   myOptImploder ()->exportSoln (this, stockVol_);
@


1.78
log
@ASAP Pegging Order
@
text
@a148 2
   stronglyAssert (myGlobalComp ()->allowAsapPip ());

@


1.77
log
@ASAP Pegging Order
@
text
@d50 1
a50 1
      asapPip_      (defAsapPip ()),
d147 1
a147 1
void WitMaterial::setAsapPip (bool theValue)
d153 1
a153 1
   asapPip_ = theValue;
d269 1
a269 1
      asapPip ());
d291 1
a291 1
   asapPip_      = theMat->asapPip_;
d375 2
a376 1
   myDataWriter ()->writeBool ("asapPip",    asapPip (),    defAsapPip ());
@


1.76
log
@ASAP pegging order
@
text
@d146 11
d291 1
d373 3
a375 1
   myDataWriter ()->writeBool ("baSelSplit", baSelSplit (), false);
@


1.75
log
@Stochastic Implosion
@
text
@d50 1
d257 2
a258 1
      baSelSplit ());
@


1.74
log
@Stochastic Implosion
@
text
@d188 1
a188 1
void WitMaterial::acquireOptSoln ()
d190 1
a190 1
   WitPart::acquireOptSoln ();
d192 1
a192 1
   myOptImploder ()->provideSoln (this, stockVol_);
d197 1
a197 1
void WitMaterial::passStochRefs ()
d199 1
a199 1
   WitPart::passStochRefs ();
d201 1
a201 1
   myStochImpMgr ()->receiveMaterialRefs (stockVol_);
@


1.73
log
@Stochastic Implosion
@
text
@d192 1
a192 1
   myOptImploder ()->provideMaterialSoln (stockVol_);
@


1.72
log
@Stochastic Implosion
@
text
@a28 1
#include <PreData.h>
a169 9
void WitMaterial::importPreData ()
   {
   WitPart::importPreData ();

   mandEC_ = expPreData ()->mandEC () (this);
   }

//------------------------------------------------------------------------------

@


1.71
log
@Stochastic Implosion
@
text
@d180 9
@


1.70
log
@Stochastic Implosion
@
text
@d29 1
d174 2
@


1.69
log
@Stochastic Implosion
@
text
@d170 7
@


1.68
log
@Stochastic Implosion
@
text
@d179 1
a179 1
void WitMaterial::importOptImpSoln (WitPeriod thePer)
d181 1
a181 1
   stockVol_.elemRef (thePer) = myOptImploder ()->stockVol (this, thePer);
d183 1
a183 1
   WitPart::importOptImpSoln (thePer);
@


1.67
log
@Stochastic Implosion
@
text
@d188 1
a188 1
void WitMaterial::passStochData ()
d190 1
a190 1
   WitPart::passStochData ();
d192 1
a192 2
   myStochImpMgr ()->
      receiveMaterialData (stockVol_);
@


1.66
log
@Stochastic Implosion
@
text
@d188 1
a188 1
void WitMaterial::clearStochSoln ()
d190 1
a190 1
   WitPart::clearStochSoln ();
d192 2
a193 10
   stockVol_ = 0.0;
   }

//------------------------------------------------------------------------------

void WitMaterial::restoreStochSoln ()
   {
   WitPart::restoreStochSoln ();

   stockVol_ = myStochImpMgr ()->stockVol (this);
@


1.65
log
@Stochastic Implosion
@
text
@a147 57
WitMsgFrag WitMaterial::categoryFrag ()
   {
   WitMsgFragID theFragID;

   theFragID =
      not wit34Compatible ()?            "materialFrag":
      producingBopEntries ().isEmpty ()? "rawMaterialFrag":
                                         "productFrag";

   return myMsgFac ().myFrag (theFragID);
   }

//------------------------------------------------------------------------------

WitAttr WitMaterial::apiCategory ()
   {
   if (not wit34Compatible ())
      return WitMATERIAL;

   if (producingBopEntries ().isEmpty ())
      return WitRAW;

   return WitPRODUCT;
   }

//------------------------------------------------------------------------------

bool WitMaterial::canStock (WitPeriod thePer)
   {
   return not mandEC ()[thePer];
   }

//------------------------------------------------------------------------------

void WitMaterial::display ()
   {
   WitPart::display ();

   myMsgFac () ("materialDdMsg", 
      partName (), 
      mappingIndex_,
      nstnBaNeeded (),
      buildAsap (),
      baSelSplit ());

   myProblem ()->display ("buildAheadUBDdMsg", buildAheadUB ());

   objChoice ()->displayForObj1 ("stockCostDdMsg", stockCost ());

   stockBounds ()->display ();

   if (myPreprocessor ()->preprocessed ())
      myProblem ()->display ("mecDdMsg", mandEC ());
   }

//------------------------------------------------------------------------------

d213 57
a399 14
WitMsgFrag WitCapacity::categoryFrag ()
   {
   return myMsgFac ().myFrag ("capacityFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitCapacity::apiCategory ()
   {
   return WitCAPACITY;
   }

//------------------------------------------------------------------------------

d427 14
@


1.64
log
@Stochastic Implosion
@
text
@d29 1
d236 9
@


1.63
log
@Stochastic Implosion
@
text
@d29 1
d235 18
@


1.62
log
@Stochastic implosion.
@
text
@d85 1
a85 1
   settingUnpostAttr ();
d94 1
a94 1
   settingUnpostAttr ();
d104 1
a104 1
   settingUnpostAttr ();
d128 1
a128 1
   settingUnpostAttr ();
d137 1
a137 1
   settingUnpostAttr ();
@


1.61
log
@[disallowed backlog]
@
text
@d85 1
a85 1
   myProblem ()->resetSoln ();
d94 1
a94 1
   myProblem ()->resetSoln ();
d104 1
a104 1
   myProblem ()->resetSoln ();
d128 1
a128 1
   myProblem ()->resetSoln ();
d137 1
a137 1
   myProblem ()->resetSoln ();
@


1.60
log
@[disallowed backlog]
@
text
@a28 2
#include <Post.h>
#include <OptImp.h>
a296 8
void WitMaterial::transmitDMPs ()
   {
   WitOptImploder  ::receiveDMPs (& WitMaterial::stockVol_);
   WitPostprocessor::receiveDMPs (& WitMaterial::stockVol_);
   }

//------------------------------------------------------------------------------

@


1.59
log
@Rescinded all changed made since 1/31/07.
@
text
@a300 1
   WitPreprocessor ::receiveDMPs (& WitMaterial::mandEC_);
@


1.58
log
@[disallowed backlog]
@
text
@a43 3
      mandEC_       (myProblem ()),
      stockVol_     (myProblem ()),

d49 3
a51 1
      baSelSplit_   (defBaSelSplit ())
d227 9
d299 9
@


1.57
log
@witCopy<Object>Data
@
text
@d44 3
d52 1
a52 3
      baSelSplit_   (defBaSelSplit ()),
      mandEC_       (myProblem (), false),
      stockVol_     (myProblem (), 0.0)
a227 9
void WitMaterial::unpreprocess ()
   {
   mandEC_ = false;

   WitPart::unpreprocess ();
   }

//------------------------------------------------------------------------------

a290 9
void WitMaterial::transmitDMPs ()
   {
   WitPreprocessor ::receiveDMPs (& WitMaterial::mandEC_);
   WitOptImploder  ::receiveDMPs (& WitMaterial::stockVol_);
   WitPostprocessor::receiveDMPs (& WitMaterial::stockVol_);
   }

//------------------------------------------------------------------------------

@


1.56
log
@witCopy<Object>Data
@
text
@d150 1
a150 2
   if (not wit34Compatible ())
      return myMsgFac ().myFrag ("materialFrag");
d152 4
a155 2
   else if (producingBopEntries ().isEmpty ())
      return myMsgFac ().myFrag ("rawMaterialFrag");
d157 1
a157 2
   else
      return myMsgFac ().myFrag ("productFrag");
d243 14
a345 14
void WitMaterial::copyAttrsFrom (WitMaterial * theMat)
   {
   WitPart::copyAttrsFrom (theMat);

   stockCost_    = theMat->stockCost ();
   stockBounds_->set (theMat->stockBounds ());

   myBaDir_      = theMat->myBaDir_;
   buildAheadUB_ = theMat->buildAheadUB ();
   baSelSplit_   = theMat->baSelSplit ();
   }

//------------------------------------------------------------------------------

d430 1
a430 1
const char * WitCapacity::categoryKeyWord ()
d432 1
a432 1
   return "capacity";
d437 1
a437 1
void WitCapacity::writeDataAttrs ()
d439 1
a439 1
   WitPart::writeDataAttrs ();
d444 1
a444 1
void WitCapacity::copyAttrsFrom (WitCapacity * theCap)
d446 1
a446 1
   WitPart::copyAttrsFrom (theCap);
@


1.55
log
@App controlled opt implosion.
@
text
@d34 1
d148 1
a148 1
WitMsgFragID WitMaterial::categoryFragID ()
d151 1
a151 1
      return "materialFrag";
d153 2
a154 2
   if (producingBopEntries ().isEmpty ())
      return "rawMaterialFrag";
d156 2
a157 1
   return "productFrag";
d382 1
a382 1
WitMsgFragID WitCapacity::categoryFragID ()
d384 1
a384 1
   return "capacityFrag";
@


1.54
log
@App controlled opt implosion.
@
text
@a27 1
#include <DataAlt.h>
d32 1
d84 5
a88 1
   stockCost_ = prepDblVec (theValue, postprocAlt ());
d95 1
a95 1
   postprocAlt ()->incur ();
d105 1
a105 1
   postprocAlt ()->incur ();
d115 17
a131 1
   buildAheadUB_ = prepBuildAheadUB (theValue);
d138 3
a140 1
   baSelSplit_ = prepBool (theValue, postprocAlt ());
@


1.53
log
@NSTN residualVols
@
text
@d175 1
a175 1
   if (myProblem ()->preprocessed ())
@


1.52
log
@Updated the copyright date on all source files.
@
text
@d50 1
a50 2
      stockVol_     (myProblem (), 0.0),
      residualVol_  (myProblem (), 0.0)
a260 7
const WitDblFlexVec & WitMaterial::residualVol ()
   {
   return residualVol_;
   }

//------------------------------------------------------------------------------

d265 1
a265 2
   WitPostprocessor::receiveDMPs (& WitMaterial::stockVol_,
                                  & WitMaterial::residualVol_);
a405 7
const WitDblFlexVec & WitCapacity::residualVol ()
   {
   return scrapVol ();
   }

//------------------------------------------------------------------------------

@


1.51
log
@Minor changes.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.50
log
@[multi-thread]
@
text
@d297 7
a312 7

   stockBounds ()->writeData ();

   myDataWriter ()->writeVector (
        "stockCost",
         stockCost (),
      defStockCost ());
d321 1
d325 1
a326 2
   stockCost_    = theMat->stockCost ();
   buildAheadUB_ = theMat->buildAheadUB ();
@


1.49
log
@Changed names of obj1 attributes, e.g., obj1ScrapCost to scrapCost.
@
text
@a219 27
void WitMaterial::loadPre ()
   {
   WitPart::loadPre ();

   myPreprocessor ()->loadDataFrom (this, mandEC_);
   }

//------------------------------------------------------------------------------

void WitMaterial::loadPost ()
   {
   WitPart::loadPost ();

   myPostprocessor ()->loadDataFrom (this, stockVol_, residualVol_);
   }

//------------------------------------------------------------------------------

void WitMaterial::loadOpt ()
   {
   WitPart::loadOpt ();

   myOptImploder ()->loadDataFrom (this, stockVol_);
   }

//------------------------------------------------------------------------------

d269 10
@


1.48
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d41 1
a41 1
      WitPart        (theName, theCompMgr),
d43 9
a51 9
      mappingIndex_  (myCompMgr ()->nMaterials ()),
      obj1StockCost_ (myProblem (), defObj1StockCost ()),
      stockBounds_   (NULL),
      myBaDir_       (noBa),
      buildAheadUB_  (myProblem (), defBuildAheadUB (myProblem ())),
      baSelSplit_    (defBaSelSplit ()),
      mandEC_        (myProblem (), false),
      stockVol_      (myProblem (), 0.0),
      residualVol_   (myProblem (), 0.0)
d83 1
a83 1
void WitMaterial::setObj1StockCost (const WitIVRealArg & theValue)
d85 1
a85 1
   obj1StockCost_ = prepDblVec (theValue, postprocAlt ());
d172 1
a172 1
   objChoice ()->displayForObj1 ("stockCostDdMsg", obj1StockCost ());
d327 3
a329 3
        "obj1StockCost",
         obj1StockCost (),
      defObj1StockCost ());
d340 4
a343 4
   myBaDir_       = theMat->myBaDir_;
   baSelSplit_    = theMat->baSelSplit ();
   obj1StockCost_ = theMat->obj1StockCost ();
   buildAheadUB_  = theMat->buildAheadUB ();
@


1.47
log
@Vector PropRt.
@
text
@d85 1
a85 1
   obj1StockCost_ = prepObj1DblVec (theValue, postprocAlt ());
@


1.46
log
@Vector PropRt.
@
text
@d83 1
a83 1
void WitMaterial::setObj1StockCost (const WitInVecRA & theValue)
@


1.45
log
@Double Precision.
@
text
@d177 1
a177 1
      myProblem ()->displayBoolVec ("mecDdMsg", mandEC ());
@


1.44
log
@Double Precision.
@
text
@d85 1
a85 1
   obj1StockCost_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
d112 1
a112 1
   buildAheadUB_.convCopy (prepBuildAheadUB (theValue));
d206 1
a206 1
   mandEC_.setToScalar (false);
@


1.43
log
@Double Precision.
@
text
@d340 4
a343 5
   myBaDir_    = theMat->myBaDir_;
   baSelSplit_ = theMat->baSelSplit ();

   obj1StockCost_.copy (theMat->obj1StockCost ());
   buildAheadUB_ .copy (theMat->buildAheadUB ());
@


1.42
log
@Double Precision.
@
text
@a82 7
void WitMaterial::setObj1StockCost (const float * theValue)
   {
   obj1StockCost_.convCopy (prepObj1DblVec (theValue, postprocAlt ()));
   }

//------------------------------------------------------------------------------

@


1.41
log
@Double Precision.
@
text
@d90 7
@


1.40
log
@Double Precision.
@
text
@d85 1
a85 1
   obj1StockCost_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
@


1.39
log
@Double Precision.
@
text
@d85 1
a85 1
   convCopy (obj1StockCost_, prepObj1FloatVec (theValue, postprocAlt ()));
d289 1
a289 1
const WitFlexVec <double> & WitMaterial::residualVol ()
d433 1
a433 1
const WitFlexVec <double> & WitCapacity::residualVol ()
@


1.38
log
@Double Precision.
@
text
@d85 1
a85 1
   obj1StockCost_.convCopy (prepObj1FloatVec (theValue, postprocAlt ()));
d289 1
a289 1
const WitRealVec & WitMaterial::residualVol ()
d433 1
a433 1
const WitRealVec & WitCapacity::residualVol ()
@


1.37
log
@Double Precision.
@
text
@d486 1
a486 1
float WitStockBoundSet::boundedVal (WitPeriod thePer) const
d488 1
a488 1
   return fltFromDbl (myMaterial_->stockVol ()[thePer]);
@


1.36
log
@Double Precision.
@
text
@d85 1
a85 1
   obj1StockCost_.copyFltCVec (prepObj1FloatVec (theValue, postprocAlt ()));
d112 1
a112 1
   buildAheadUB_.copyCVec (prepBuildAheadUB (theValue));
@


1.35
log
@Double Precision.
@
text
@d488 1
a488 1
   return floatFromDouble (myMaterial_->stockVol ()[thePer]);
@


1.34
log
@Double Precision.
@
text
@d112 1
a112 1
   buildAheadUB_.copyCvector (prepBuildAheadUB (theValue));
@


1.33
log
@Continued implementation of PIP.
@
text
@d85 1
a85 1
   obj1StockCost_.copyCvector (prepObj1FloatVec (theValue, postprocAlt ()));
d289 1
a289 1
const WitFlexVec <float> & WitMaterial::residualVol ()
d433 1
a433 1
const WitFlexVec <float> & WitCapacity::residualVol ()
d486 1
a486 1
float WitStockBoundSet::boundedVal (WitPeriod t) const
d488 1
a488 1
   return myMaterial_->stockVol ()[t];
@


1.32
log
@Removed a bad function overload.
@
text
@d20 1
d22 1
@


1.31
log
@Continued implementation of post-implosion pegging.
@
text
@d211 1
a211 1
WitMaterial * WitMaterial::myMat ()
d417 1
a417 1
WitCapacity * WitCapacity::myCap ()
@


1.30
log
@Continued implementation of post-implosion pegging.
@
text
@d417 7
@


1.29
log
@Added some optional warnings on Linux.
@
text
@a31 1
#include <FlexVecI.h>
@


1.28
log
@Continued implementation of proportionate routing.
@
text
@a42 3
      mandEC_        (myProblem (), false),
      stockVol_      (myProblem (), 0.0),
      residualVol_   (myProblem (), 0.0),
d47 4
a50 1
      baSelSplit_    (defBaSelSplit ())
d453 1
a453 1
WitPeriod WitCapacity::findExplosionPeriod (WitPeriod fillPer)
@


1.27
log
@Continued implementation of proportionate routing.
@
text
@d212 1
a212 1
void WitMaterial::getMaterial (WitMaterial * & theMat)
d214 1
a214 1
   theMat = this;
@


1.26
log
@Internal changes.
@
text
@d66 7
@


1.25
log
@Internal changes.
@
text
@d120 1
a120 1
   if (! wit34Compatible ())
d133 1
a133 1
   if (! wit34Compatible ())
d146 1
a146 1
   return ! mandEC ()[thePer];
@


1.24
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d43 1
a43 1
      mandEC_        (myProblem (), WitFALSE),
d82 1
a82 1
void WitMaterial::setBuildNstn (WitBoolean theValue)
d92 1
a92 1
void WitMaterial::setBuildAsap (WitBoolean theValue)
d109 1
a109 1
void WitMaterial::setBaSelSplit (WitBoolean theValue)
d111 1
a111 1
   baSelSplit_ = prepBoolean (theValue, postprocAlt ());
d144 1
a144 1
WitBoolean WitMaterial::canStock (WitPeriod thePer)
d169 1
a169 1
      myProblem ()->display ("mecDdMsg", mandEC ());
d198 1
a198 1
   mandEC_.setToScalar (witFALSE);
d239 1
a239 1
WitBoolean WitMaterial::nstnBaNeeded ()
d242 4
a245 4
      buildNstn ()?                        witTRUE:
      buildAsap ()?                        witFALSE:
      myGlobalComp ()->localBuildAhead ()? witTRUE:
                                           witFALSE;
d306 2
a307 2
   myDataWriter ()->writeBoolean ("buildNstn", buildNstn (), witFALSE);
   myDataWriter ()->writeBoolean ("buildAsap", buildAsap (), witFALSE);
d314 1
a314 1
   myDataWriter ()->writeBoolean ("baSelSplit", baSelSplit (), witFALSE);
d411 1
a411 1
WitBoolean WitCapacity::canStock (WitPeriod)
d413 1
a413 1
   return witFALSE;
d448 1
a448 1
   stronglyAssert (witFALSE);
@


1.23
log
@Continued implementation of single-source.
@
text
@d32 1
@


1.22
log
@Continued implementation of single-source.
@
text
@d29 1
d225 9
@


1.21
log
@Continued implementation of single-source.
@
text
@d194 9
d206 9
@


1.20
log
@Continued implementation of single-source.
@
text
@d28 1
d197 9
@


1.19
log
@Continued implementation of single-source.
@
text
@a27 1
#include <Post.h>
a28 1
#include <wit/src/Variant.h>
a169 91
// compStockScrapVol.
//
// Computes scrapVol_ and stockVol_.
// This is done by rolling the inventory forward in time, allocating as much of
// it as possible to stock and scrapping the rest. Then rollBackScrap is
// applied. Lower bounds on stock are respected to the extent possible given
// the production and shipment schedules. Upper bounds on stock are respected
// if appropriate for the currentVariant. If the solution implies a negative
// stockVol or scrapVol (due to a numerical problem or a genuine constraint
// violation), the negative value is assigned to the scrapVol rather than the
// stockVol.
//------------------------------------------------------------------------------

void WitMaterial::compStockScrapVol (
      WitTVec <double> & stockVolDbl,
      WitTVec <double> & scrapVolDbl)
   {
   WitPeriod thePer;
   double    rollInv;     // Rolling inventory in period thePer.
   double    curStockVol; // stockVol_[thePer].

   stockVolDbl.setToScalar (0.0);
   scrapVolDbl.setToScalar (0.0);

   forEachPeriod (thePer, myProblem ())
      {
      rollInv = unstockedScrapVol (thePer);

      if (thePer > 0)
         rollInv += stockVolDbl[thePer - 1];

      curStockVol =
         canStock (thePer)?
            rollInv:
            0.0;

      if (myProblem ()->currentVariant ()->respectsAllBounds ())
         if (stockBounds ()->hardUBIsFinite (thePer))
            setToMin (curStockVol, (double) stockBounds ()->hardUB ()[thePer]);

      if (curStockVol < 0.0)
          curStockVol = 0.0;

      stockVolDbl[thePer] =           curStockVol;
      scrapVolDbl[thePer] = rollInv - curStockVol;
      }

   rollBackScrap (stockVolDbl, scrapVolDbl);

   copyInto (stockVol_,            stockVolDbl);

   copyInto (scrapVolForUpdate (), scrapVolDbl);
   }

//------------------------------------------------------------------------------
// compResidualVol.
//
// Computes residualVol_ as follows:
// Create a temporary usedStockVol, the portion of stockVol that is used by the
//    solution and let residualVol be the corresponding scrapVol.
// Let usedStockVol and residualVol reflect the following scrapping policy:
// * Any stock in the last period in excess of the softLB on stock is scrapped.
// * All scrapping is done in the earliest possible period.
//------------------------------------------------------------------------------

void WitMaterial::compResidualVol (
      WitTVec <double> & residualVolDbl, 
      WitTVec <double> & usedStockVol)
   {
   double    unusedFinalStock;
   WitPeriod lastPer;

   lastPer = lastPeriod ();

   copyInto (usedStockVol,   stockVol_);
   copyInto (residualVolDbl, scrapVol ());

   unusedFinalStock = stockVol_[lastPer] - stockBounds ()->softLB ()[lastPer];

   if (unusedFinalStock > FLOAT_EPSILON)
      {
      usedStockVol  [lastPer] -= unusedFinalStock;
      residualVolDbl[lastPer] += unusedFinalStock;
      }

   rollBackScrap (usedStockVol, residualVolDbl);

   copyInto (residualVol_, residualVolDbl);
   }

//------------------------------------------------------------------------------
a381 10
   }

//------------------------------------------------------------------------------

void WitCapacity::compStockScrapVol (WitTVec <double> &, WitTVec <double> &)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      scrapVolForUpdate ().elemRef (thePer) = unstockedScrapVol (thePer);
@


1.18
log
@Continued implementation of single-source.
@
text
@d172 91
a292 12
void WitMaterial::importPostprocResults ()
   {
   WitPart::importPostprocResults ();

   if (! myProblem ()->currentVariant ()->compsSecScheds ())
      stockVol_.copy (myPostprocessor ()->stockVol (this));

   residualVol_.copyTVec (myPostprocessor ()->residualVol (this));
   }

//------------------------------------------------------------------------------

d475 10
@


1.17
log
@Preliminary work on single source.
@
text
@d28 1
d30 1
d198 12
@


1.16
log
@Continued preliminary work on single source.
@
text
@d74 1
a74 1
   obj1StockCost_ = prepObj1FloatVec (theValue, postprocAlt ());
d101 1
a101 1
   buildAheadUB_ = prepBuildAheadUB (theValue);
d242 1
a242 1
const WitFlexVec (float) & WitMaterial::residualVol ()
d293 5
a297 4
   obj1StockCost_ = theMat->obj1StockCost ();
   myBaDir_       = theMat->myBaDir_;
   buildAheadUB_  = theMat->buildAheadUB ();
   baSelSplit_    = theMat->baSelSplit ();
d379 1
a379 1
const WitFlexVec (float) & WitCapacity::residualVol ()
@


1.15
log
@Continued implementation of object iteration.
@
text
@d219 2
a220 2
      WitTVec (double) & theStockVol,
      WitTVec (double) & theScrapVol)
@


1.14
log
@Began implementation of object iteration.
@
text
@a147 7
WitMaterial * WitMaterial::myMat ()
   {
   return this;
   }

//------------------------------------------------------------------------------

d189 7
@


1.13
log
@Continued implementation of sel-split for pen-exec.
@
text
@d20 1
d29 1
@


1.12
log
@Continued development of Selective Stock Reallocation.
@
text
@d406 1
a406 1
   myMsgFac () ("internalErrorFmsg", "WitCapacity::findExplosionPeriod");
@


1.11
log
@Continued implementation of selective stock reallocation.
@
text
@d146 1
a146 1
WitBoolean WitMaterial::getMyMaterial (WitMaterial * & theMat)
d148 1
a148 3
   theMat = this;

   return witTRUE;
a371 9
   }

//------------------------------------------------------------------------------

WitBoolean WitCapacity::getMyCapacity (WitCapacity * & theCap)
   {
   theCap = this;

   return witTRUE;
@


1.10
log
@Removed allowSS development parameter.
@
text
@d146 1
a146 1
WitBoolean WitMaterial::isaMaterial (WitMaterial * & theMat)
d378 1
a378 1
WitBoolean WitCapacity::isaCapacity (WitCapacity * & theCap)
@


1.9
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@a105 3
   if (! myGlobalComp ()->allowSS ())
      myMsgFac () ("internalErrorFmsg", "WitMaterial::setBaSelSplit");

@


1.8
log
@Re-worked the controls for selection splitting.
@
text
@d44 2
a45 1
      buildAheadUB_  (myProblem (), defBuildAheadUB (myProblem ()))
d103 10
d166 2
a167 1
      buildAsap ());
d278 2
d299 1
@


1.7
log
@Removed the coarse selection splitting code that's not needed for the new
design of selection splitting.
@
text
@d44 1
a44 2
      buildAheadUB_  (myProblem (), defBuildAheadUB (myProblem ())),
      baSplitRes_    (defBaSplitRes ())
a101 13

void WitMaterial::setBaSplitRes (float theValue)
   {
   witAssert (myGlobalComp ()->allowSS ());

   witAssert ((theValue == 0) || (theValue >= 0.999));

   postprocAlt ()->incur ();

   baSplitRes_ = theValue;
   }

//------------------------------------------------------------------------------
a156 3
   if (myGlobalComp ()->allowSS ())
      myMsgFac () ("splitResDdMsg", baSplitRes ());
   
a265 6
   if (myGlobalComp ()->allowSS ())
      myDataWriter ()->writeFloat (
         "baSplitRes",
         baSplitRes (),
         defBaSplitRes ());

a284 3

   if (myGlobalComp ()->allowSS ())
      baSplitRes_ = theMat->baSplitRes ();
@


1.6
log
@Coarse selection splitting.
@
text
@d44 2
a45 1
      buildAheadUB_  (myProblem (), defBuildAheadUB (myProblem ()))
d103 13
d171 3
d283 6
d308 3
@


1.5
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d182 1
a182 1
   setPartIndex ();
d186 1
a186 1
   myCompMgr ()->recount (this);
d352 1
a352 1
   setPartIndex ();
d354 1
a354 1
   myCompMgr ()->recount (this);
@


1.4
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d169 1
a169 1
void WitMaterial::copyInto (WitCompMgr * theCompMgr)
d339 1
a339 1
void WitCapacity::copyInto (WitCompMgr * theCompMgr)
@


1.3
log
@Continued implementation of stock re-allocation.
@
text
@d62 1
a62 1
   return theProblem->nPeriods () - 1;
d213 1
a213 1
   WitPeriod t;
d216 1
a216 1
   for (t = myProblem ()->lPeriod () - 1; t >= 0; t--)
d218 1
a218 1
      rollBackVol = theStockVol[t] - stockBounds ()->softLB ()[t];
d220 1
a220 1
      WitUtil::setToMin (rollBackVol, theScrapVol[t+1]);
d224 3
a226 3
         theScrapVol[t+1] -= rollBackVol;
         theStockVol[t]   -= rollBackVol;
         theScrapVol[t]   += rollBackVol;
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d220 1
a220 1
      WitUtil::updateToMin (rollBackVol, theScrapVol[t+1]);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

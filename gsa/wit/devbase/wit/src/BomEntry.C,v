head	1.90;
access;
symbols
	sce_5_01_20080919:1.84
	latest_sce_4_20_20060523:1.57.0.2
	sce_4_20_20060523:1.57
	latest_sce4_20_OSL:1.56.0.2
	sce_4_20_OSL:1.56
	sce_410_withVa:1.55
	sce_4_05_20040511:1.44
	sce_4_00_20040201:1.29
	nextGenBranch:1.26.0.2
	nextGenRoot:1.26
	sce_3_30_20030627:1.26
	EndRw-branch:1.19.0.4
	Root-of-EndRw:1.19
	rwToStl:1.19.0.2
	latest_sce_3_10_20010924:1.6.0.6
	sce_3_10_20010924:1.6
	latest_sce_3_00_20010601:1.6.0.4
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.6.0.2
	sce_2_31_20010308:1.6
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.90
date	2011.09.28.23.49.05;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2011.09.24.00.27.22;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2011.08.30.20.17.18;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2010.09.10.22.10.37;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2010.03.16.22.42.23;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2009.12.25.00.10.45;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.25.19.37.56;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2007.12.06.22.01.20;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.15.17.15.31;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.13.20.17.37;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.07.21.50.11;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2007.08.01.22.41.55;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.05.21.05.59;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.05.16.15.22;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.01.22.25.06;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.31.20.05.48;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.30.16.01.17;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.10.21.58.10;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.25.19.56.53;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.17.20.19.01;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.06.19.34.17;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.05.20.23.51;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.04.22.08.17;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.03.22.04.03;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.02.23.01.14;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.27.22.59.28;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.02.27.21.03.03;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.02.27.19.59.29;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.02.10.00.08.13;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.02.08.22.47.33;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.01.15.22.25.29;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2006.09.21.15.42.25;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.09.19.17.50.54;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.02.17.33.55;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2005.09.30.21.57.54;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.16.17.00.30;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.04.00.00.28;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.03.21.25.12;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.02.22.34.35;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.02.21.59.45;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.02.28.22.04.11;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.02.25.21.26.10;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.24.23.23.55;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.10.19.46.47;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.26.23.50.31;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.29.20.44.54;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.20.18.25.21;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.19.22.16.27;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.14.21.16.16;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.13.21.50.12;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.09.21.24.26;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.02.23.45.20;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.31.22.56.07;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.24.22.21.28;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.23.19.14.22;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.05.22.19.56;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.05.00.06.53;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.04.16.31.45;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.20.15.37.35;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.12.19.13.38;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.07.00.12.09;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.09.22.44.05;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.11.18.29.11;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.25.23.49.54;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.18.21.12.47;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.19.16.48.12;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.26.21.42.51;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.21.18.56.22;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.13.23.06.24;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.02.23.40.36;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.02.22.18.19;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.11.18.53.05;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.23.18.09.10;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.24.22.02.24;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.04.23.07.17;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.03.22.35.16;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.03.16.01.45;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.30.20.08.55;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.29.21.35.43;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.08.19.21.46;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.25.19.14.48;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.24.18.26.04;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.22.14.32.03;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.18.14.02.26;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.20.00.44.15;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.04.22.27.48;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.21.20.03.20;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.21.22.42;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.55.21;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.19;	author wit;	state Exp;
branches;
next	;


desc
@@


1.90
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "BomEntry.C"
//
// Contains the implementation of class BomEntry.
//------------------------------------------------------------------------------

#include <SubEntry.h>
#include <Part.h>
#include <Operation.h>
#include <GlobalComp.h>
#include <DetOptImpMgr.h>
#include <DataWrit.h>
#include <Pre.h>
#include <Post.h>
#include <CompMgr.h>
#include <IVRealArg.h>
#include <wit.h>
#include <MsgFrag.h>
#include <MsgFac.h>

//------------------------------------------------------------------------------

WitBomEntry::WitBomEntry (WitOperation * theOpn, WitPart * thePart):

      WitConsEntry     (thePart, theOpn->bom ().nElements ()),

      mappingIndex_    (myCompMgr ()->nBomEntries ()),
      myOperation_     (theOpn),
      mySubEntries_    (),
      mandEC_          (defMandEC ()),
      singleSource_    (defSingleSource ()),
      propRtg_         (myProblem (), defPropRtg ()),
      hasSubsInEffect_ (myProblem (), false),
      nonSubVol_       (myProblem (), 0.0)
   {
   witAssert (theOpn->myCompMgr () == thePart->myCompMgr ());

   if (wit34Compatible ())
      offsetRef () = myOperation ()->cycleTime34 ();
         //
         // This results in a default usageTime34 of 0.0.

   myCompMgr   ()->insert (this);
   myOperation ()->insert (this);
   myPart      ()->insert (this);
   }

//------------------------------------------------------------------------------

WitBomEntry::~WitBomEntry ()
   {
   }

//------------------------------------------------------------------------------

const WitDblFlexVec & WitBomEntry::nonSubVol ()
   {
   if (mySubEntries ().isEmpty ())
      return myOperation ()->execVol ();
   else
      return nonSubVol_;
   }

//------------------------------------------------------------------------------

int WitBomEntry::nInstances (WitProblem * theProblem)
   {
   return theProblem->myCompMgr ()->nBomEntries ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitBomEntry::setMandEC (bool theValue)
   {
   prepSetUnpreAttr ();

   mandEC_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBomEntry::setSingleSource (bool theValue)
   {
   prepSetUnpostAttr ();

   singleSource_ = theValue;
   }

//------------------------------------------------------------------------------

void WitBomEntry::setPropRtg (const WitBoolean * theValue)
   {
   witAssert (theValue != NULL);

   prepSetUnpostAttr ();

   copy (propRtg_, theValue);
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitBomEntry::storePreMySubEntries (const WitList <WitSubEntry> & theList)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   mySubEntries_ = theList;
   }

//------------------------------------------------------------------------------

void WitBomEntry::storePreHasSubsInEffect (const WitTVec <bool> & theTVec)
   {
   witAssert (myPreprocessor ()->preprocessing ());

   hasSubsInEffect_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitBomEntry::storePostNonSubVol (const WitTVec <double> & theTVec)
   {
   witAssert (myPostprocessor ()->postprocessing ());

   nonSubVol_ = theTVec;
   }

//------------------------------------------------------------------------------

void WitBomEntry::storeOptNonSubVol (WitPeriod thePer, double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   nonSubVol_.elemRef (thePer) = theValue;
   }

//------------------------------------------------------------------------------

void WitBomEntry::insert (WitSubEntry * theSub)
   {
   mySubEntries_.appendUniquely (theSub);
   }

//------------------------------------------------------------------------------

bool WitBomEntry::inserted ()
   {
   return (myOperation ()->bom ().contains (this));
   }

//------------------------------------------------------------------------------

void WitBomEntry::identifyInstance ()
   {
   if (myMsgFac ().mayIssue ("bomEntryInstIDMsg"))
      myMsgFac () ("bomEntryInstIDMsg",
         myOperationName (),
         localIndex (),
         myPartName ());
   }

//------------------------------------------------------------------------------

void WitBomEntry::writeSetClause ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("bomEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (localIndex      ());
   }

//------------------------------------------------------------------------------

void WitBomEntry::copySelfInto (WitCompMgr * theCompMgr)
   {
   WitOperation * theOpn;
   WitPart *      thePart;
   WitBomEntry *  theBomEnt;

   theOpn    = theCompMgr->myMatchFor (myOperation ());
   thePart   = theCompMgr->myMatchFor (myPart      ());

   theBomEnt = new WitBomEntry (theOpn, thePart);

   theBomEnt->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitBomEntry::recount ()
   {
   recountConsEntry ();

   mappingIndex_ = myCompMgr ()->nBomEntries ();

   myCompMgr ()->recountBomEntry (this);
   }

//------------------------------------------------------------------------------

void WitBomEntry::unpreprocess ()
   {
   hasSubsInEffect_ = false;
   nonSubVol_       = 0.0;

   WitConsEntry::unpreprocess ();
   }

//------------------------------------------------------------------------------

WitBomEntry * WitBomEntry::thisBomEnt ()
   {
   return this;
   }

//------------------------------------------------------------------------------

WitMsgFrag WitBomEntry::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("bomEntryFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitBomEntry::apiObjItrState ()
   {
   return WitAT_BOM_ENTRY;
   }

//------------------------------------------------------------------------------

void WitBomEntry::copyAttrsFrom (WitBomEntry * theBomEnt)
   {
   WitConsEntry::copyAttrsFrom (theBomEnt);

   mandEC_       = theBomEnt->mandEC_;
   singleSource_ = theBomEnt->singleSource_;
   propRtg_      = theBomEnt->propRtg_;
   }

//------------------------------------------------------------------------------

void WitBomEntry::setUsageTime34 (double theValue)
   {
   WitPeriod thePer;

   witAssert (wit34Compatible ());

   prepSetUnpreAttr ();

   if (myOperation ()->cycleTime34 () == myOperation ()->cycleTime34 ()[0])
      offsetRef () = (myOperation ()->cycleTime34 ()[0] - theValue);
   else
      forEachPeriod (thePer, myProblem ())
         offsetRef ().elemRef (thePer) =
            myOperation ()->cycleTime34 ()[thePer] - theValue;
   }

//------------------------------------------------------------------------------

double WitBomEntry::usageTime34 (WitPeriod thePer)
   {
   double ut34;

   witAssert (wit34Compatible ());

   ut34 = myOperation ()->cycleTime34 ()[thePer] - offset ()[thePer];

   return ut34;
   }

//------------------------------------------------------------------------------

double WitBomEntry::usageTime34 ()
   {
   return usageTime34 (0);
   }

//------------------------------------------------------------------------------

void WitBomEntry::adjustOffset (const WitIVRealArg & newCycleTime34)
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      offsetRef ().elemRef (thePer) +=
         newCycleTime34[thePer] - myOperation ()->cycleTime34 ()[thePer];
   }

//------------------------------------------------------------------------------

void WitBomEntry::display ()
   {
   WitSubEntry * theSub;

   myMsgFac () ("bomEntryDdMsg",
      myOperationName (),
      localIndex (),
      myPartName (),
      mappingIndex_,
      singleSource ());

   if (wit34Compatible ())
      myMsgFac () ("usageTime34DdMsg", usageTime34 ());

   myProblem ()->display ("propRtgDdMsg", propRtg_);

   if (myPreprocessor ()->preprocessed ())
      if (not mySubEntries ().isEmpty ())
         myProblem ()->display (
            "hasSubsInEffectDdMsg",
            hasSubsInEffect ());

   if (not mySubEntries ().isEmpty ())
      {
      myMsgFac () ("bomSubHeadingDdMsg");

      forEachEl (theSub, mySubEntries ())
         myMsgFac () ("bomSubDataDdMsg",
            theSub->myPartName (),
            theSub->localIndex ());
      }

   WitConsEntry::display ();
   }

//------------------------------------------------------------------------------

void WitBomEntry::writeSubSoln ()
   {
   WitSubEntry * theSub;
   WitPeriod     thePer;

   if (mySubEntries ().isEmpty ())
      return;

   fprintf (solnFile (), "\n"
      "Consuming Operation: %s,  Part Replaced: %s,  BOM Entry #%d:\n\n",
      myOperationName ().myCstring (),
      myPartName ().myCstring (),
      localIndex ());

   fprintf (solnFile (),
         "Period  Substitute       Sub #"
         "                     Volume");

   if (fssComputed ())
      fprintf (solnFile (), "                          Volume");

   fprintf (solnFile (), "\n");

   forEachPeriod (thePer, myProblem ())
      {
      if (hasSubsInEffect ()[thePer])
         {
         fprintf (solnFile (),
            "   %3d                          Non-SubVol: ",
            thePer);

         writeSolnValue (nonSubVol ()[thePer]);

         fprintf (solnFile (), "\n");
         }

      forEachEl (theSub, mySubEntries ())
         if (theSub->inEffect (thePer))
            {
            fprintf (solnFile (),
               "   %3d  %-12s  %8d      SubVol: ",
               thePer,
               theSub->myPartName ().myCstring (),
               theSub->localIndex ());

            writeSolnValue (theSub->subVol ()[thePer]);

            if (fssComputed ())
               {
               fprintf (solnFile (), "        FssSubVol: ");

               writeSolnValue (theSub->fssSubVol ()[thePer]);
               }

            fprintf (solnFile (), "\n");
            }

      if (hasSubsInEffect ()[thePer])
         {
         fprintf (solnFile (),
            "   %3d                             ExecVol: ",
            thePer);

         writeSolnValue (myOperation ()->execVol ()[thePer]);

         fprintf (solnFile (), "\n\n");
         }
      }
   }

//------------------------------------------------------------------------------

void WitBomEntry::writeMrpSubSoln ()
   {
   WitSubEntry * theSub;
   WitPeriod     t;

   if (mySubEntries ().isEmpty ())
      return;

   fprintf (solnFile (), "\n"
      "Consuming Operation: %s,  Part Replaced: %s,  BOM Entry #%d:\n\n",
      myOperationName ().myCstring (),
      myPartName ().myCstring (),
      localIndex ());

   fprintf (solnFile (),
         "Period  Substitute       Sub #"
         "                          Volume\n");

   forEachPeriod (t, myProblem ())
      {
      forEachEl (theSub, mySubEntries ())
         if (theSub->inEffect (t))
            {
            fprintf (solnFile (),
               "   %3d  %-12s  %8d        MrpSubVol: ",
               t,
               theSub->myPartName ().myCstring (),
               theSub->localIndex ());

            writeSolnValue (theSub->mrpSubVol ()[t]);

            fprintf (solnFile (), "\n");
            }

      if (hasSubsInEffect ()[t])
         {
         fprintf (solnFile (),
            "   %3d                               MrpExecVol: ",
            t);

         writeSolnValue (myOperation ()->mrpExecVol ()[t]);

         fprintf (solnFile (), "\n\n");
         }
      }
   }

//------------------------------------------------------------------------------

WitOperation * WitBomEntry::derivedOperation ()
   {
   return myOperation ();
   }

//------------------------------------------------------------------------------

void WitBomEntry::displayMandEC ()
   {
   myMsgFac () ("mandECDdMsg", mandEC ());
   }

//------------------------------------------------------------------------------

WitBomEntry * WitBomEntry::derivedBomEntry ()
   {
   return this;
   }

//------------------------------------------------------------------------------

void WitBomEntry::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("bomEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeStringValue  (myPartName ());
   }

//------------------------------------------------------------------------------

void WitBomEntry::writeDataAttrs ()
   {
   WitConsEntry::writeDataAttrs ();

   if (wit34Compatible ())
      writeOffset34 ();
   else
      writeOffset ();

   myDataWriter ()->writeBool (
      "mandEC",
      mandEC (),
      defMandEC ());

   myDataWriter ()->writeBool (
      "singleSource",
      singleSource (),
      defSingleSource ());

   myDataWriter ()->writeVector (
      "propRtg",
      propRtg_,
      defPropRtg ());
   }

//------------------------------------------------------------------------------

void WitBomEntry::findPrereqs (WitDelComp * & prereq1, WitDelComp * & prereq2)
   {
   prereq1 = myOperation ();
   prereq2 = myPart ();
   }

//------------------------------------------------------------------------------

void WitBomEntry::purgeCompListsSpec ()
   {
   purgeSelComps (mySubEntries_);
   }

//------------------------------------------------------------------------------

void WitBomEntry::clearDepListsSpec ()
   {
   mySubEntries_.clear ();
   }

//------------------------------------------------------------------------------

void WitBomEntry::writeOffset34 ()
   {
   WitMsgID  theMsgID;
   WitPeriod thePer;

   myProblem ()->myDataWriter ()->writeFirstKeyWord ("offset");

   theMsgID =
      myProblem ()->myGlobalComp ()->highPrecisionWD ()?
         "doubleDenseVectorHpWdMsg":
         "doubleDenseVectorWdMsg";

   myMsgFac () ("startVectorWdMsg", "dense");

   forEachPeriod (thePer, myProblem ())
      myMsgFac () (theMsgID,
         ((thePer == 0)? "": " "),
         offset ()[thePer]);

   myMsgFac () ("endVectorWdMsg");
   }
@


1.89
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.88
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d34 1
a34 17
WitConsEntry     (thePart, theOpn->bom ().nElements ()),

mappingIndex_    (myCompMgr ()->nBomEntries ()),
myOperation_     (theOpn),
mySubEntries_    (),
mandEC_          (defMandEC ()),
singleSource_    (defSingleSource ()),
propRtg_         (myProblem (), defPropRtg ()),
hasSubsInEffect_ (myProblem (), false),
nonSubVol_       (myProblem (), 0.0)
{
witAssert (theOpn->myCompMgr () == thePart->myCompMgr ());

if (wit34Compatible ())
offsetRef () = myOperation ()->cycleTime34 ();
//
// This results in a default usageTime34 of 0.0.
d36 20
a55 4
myCompMgr   ()->insert (this);
myOperation ()->insert (this);
myPart      ()->insert (this);
}
d60 2
a61 2
{
}
d66 6
a71 6
{
if (mySubEntries ().isEmpty ())
return myOperation ()->execVol ();
else
return nonSubVol_;
}
d76 3
a78 3
{
return theProblem->myCompMgr ()->nBomEntries ();
}
d85 2
a86 2
{
prepSetUnpreAttr ();
d88 2
a89 2
mandEC_ = theValue;
}
d94 2
a95 2
{
prepSetUnpostAttr ();
d97 2
a98 2
singleSource_ = theValue;
}
d103 2
a104 2
{
witAssert (theValue != NULL);
d106 1
a106 1
prepSetUnpostAttr ();
d108 2
a109 2
copy (propRtg_, theValue);
}
d116 2
a117 2
{
witAssert (myPreprocessor ()->preprocessing ());
d119 2
a120 2
mySubEntries_ = theList;
}
d125 2
a126 2
{
witAssert (myPreprocessor ()->preprocessing ());
d128 2
a129 2
hasSubsInEffect_ = theTVec;
}
d134 2
a135 2
{
witAssert (myPostprocessor ()->postprocessing ());
d137 2
a138 2
nonSubVol_ = theTVec;
}
d143 2
a144 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d146 2
a147 2
nonSubVol_.elemRef (thePer) = theValue;
}
d152 3
a154 3
{
mySubEntries_.appendUniquely (theSub);
}
d159 3
a161 3
{
return (myOperation ()->bom ().contains (this));
}
d166 7
a172 7
{
if (myMsgFac ().mayIssue ("bomEntryInstIDMsg"))
myMsgFac () ("bomEntryInstIDMsg",
myOperationName (),
localIndex (),
myPartName ());
}
d177 6
a182 6
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("bomEntry");
myDataWriter ()->writeStringValue  (myOperationName ());
myDataWriter ()->writeIntValue     (localIndex      ());
}
d187 4
a190 4
{
WitOperation * theOpn;
WitPart *      thePart;
WitBomEntry *  theBomEnt;
d192 2
a193 2
theOpn    = theCompMgr->myMatchFor (myOperation ());
thePart   = theCompMgr->myMatchFor (myPart      ());
d195 1
a195 1
theBomEnt = new WitBomEntry (theOpn, thePart);
d197 2
a198 2
theBomEnt->copyAttrsFrom (this);
}
d203 2
a204 2
{
recountConsEntry ();
d206 1
a206 1
mappingIndex_ = myCompMgr ()->nBomEntries ();
d208 2
a209 2
myCompMgr ()->recountBomEntry (this);
}
d214 3
a216 3
{
hasSubsInEffect_ = false;
nonSubVol_       = 0.0;
d218 2
a219 2
WitConsEntry::unpreprocess ();
}
d224 3
a226 3
{
return this;
}
d231 3
a233 3
{
return myMsgFac ().myFrag ("bomEntryFrag");
}
d238 3
a240 3
{
return WitAT_BOM_ENTRY;
}
d245 2
a246 2
{
WitConsEntry::copyAttrsFrom (theBomEnt);
d248 4
a251 4
mandEC_       = theBomEnt->mandEC_;
singleSource_ = theBomEnt->singleSource_;
propRtg_      = theBomEnt->propRtg_;
}
d256 2
a257 2
{
WitPeriod thePer;
d259 1
a259 1
witAssert (wit34Compatible ());
d261 1
a261 1
prepSetUnpreAttr ();
d263 7
a269 7
if (myOperation ()->cycleTime34 () == myOperation ()->cycleTime34 ()[0])
offsetRef () = (myOperation ()->cycleTime34 ()[0] - theValue);
else
forEachPeriod (thePer, myProblem ())
offsetRef ().elemRef (thePer) =
myOperation ()->cycleTime34 ()[thePer] - theValue;
}
d274 2
a275 2
{
double ut34;
d277 1
a277 1
witAssert (wit34Compatible ());
d279 1
a279 1
ut34 = myOperation ()->cycleTime34 ()[thePer] - offset ()[thePer];
d281 2
a282 2
return ut34;
}
d287 3
a289 3
{
return usageTime34 (0);
}
d294 2
a295 2
{
WitPeriod thePer;
d297 4
a300 4
forEachPeriod (thePer, myProblem ())
offsetRef ().elemRef (thePer) +=
newCycleTime34[thePer] - myOperation ()->cycleTime34 ()[thePer];
}
d305 2
a306 2
{
WitSubEntry * theSub;
d308 27
a334 27
myMsgFac () ("bomEntryDdMsg",
myOperationName (),
localIndex (),
myPartName (),
mappingIndex_,
singleSource ());

if (wit34Compatible ())
myMsgFac () ("usageTime34DdMsg", usageTime34 ());

myProblem ()->display ("propRtgDdMsg", propRtg_);

if (myPreprocessor ()->preprocessed ())
if (not mySubEntries ().isEmpty ())
myProblem ()->display (
"hasSubsInEffectDdMsg",
hasSubsInEffect ());

if (not mySubEntries ().isEmpty ())
{
myMsgFac () ("bomSubHeadingDdMsg");

forEachEl (theSub, mySubEntries ())
myMsgFac () ("bomSubDataDdMsg",
theSub->myPartName (),
theSub->localIndex ());
}
d336 2
a337 2
WitConsEntry::display ();
}
d342 68
a409 68
{
WitSubEntry * theSub;
WitPeriod     thePer;

if (mySubEntries ().isEmpty ())
return;

fprintf (solnFile (), "\n"
"Consuming Operation: %s,  Part Replaced: %s,  BOM Entry #%d:\n\n",
myOperationName ().myCstring (),
myPartName ().myCstring (),
localIndex ());

fprintf (solnFile (),
"Period  Substitute       Sub #"
"                     Volume");

if (fssComputed ())
fprintf (solnFile (), "                          Volume");

fprintf (solnFile (), "\n");

forEachPeriod (thePer, myProblem ())
{
if (hasSubsInEffect ()[thePer])
{
fprintf (solnFile (),
"   %3d                          Non-SubVol: ",
thePer);

writeSolnValue (nonSubVol ()[thePer]);

fprintf (solnFile (), "\n");
}

forEachEl (theSub, mySubEntries ())
if (theSub->inEffect (thePer))
{
fprintf (solnFile (),
"   %3d  %-12s  %8d      SubVol: ",
thePer,
theSub->myPartName ().myCstring (),
theSub->localIndex ());

writeSolnValue (theSub->subVol ()[thePer]);

if (fssComputed ())
{
fprintf (solnFile (), "        FssSubVol: ");

writeSolnValue (theSub->fssSubVol ()[thePer]);
}

fprintf (solnFile (), "\n");
}

if (hasSubsInEffect ()[thePer])
{
fprintf (solnFile (),
"   %3d                             ExecVol: ",
thePer);

writeSolnValue (myOperation ()->execVol ()[thePer]);

fprintf (solnFile (), "\n\n");
}
}
}
d414 45
a458 45
{
WitSubEntry * theSub;
WitPeriod     t;

if (mySubEntries ().isEmpty ())
return;

fprintf (solnFile (), "\n"
"Consuming Operation: %s,  Part Replaced: %s,  BOM Entry #%d:\n\n",
myOperationName ().myCstring (),
myPartName ().myCstring (),
localIndex ());

fprintf (solnFile (),
"Period  Substitute       Sub #"
"                          Volume\n");

forEachPeriod (t, myProblem ())
{
forEachEl (theSub, mySubEntries ())
if (theSub->inEffect (t))
{
fprintf (solnFile (),
"   %3d  %-12s  %8d        MrpSubVol: ",
t,
theSub->myPartName ().myCstring (),
theSub->localIndex ());

writeSolnValue (theSub->mrpSubVol ()[t]);

fprintf (solnFile (), "\n");
}

if (hasSubsInEffect ()[t])
{
fprintf (solnFile (),
"   %3d                               MrpExecVol: ",
t);

writeSolnValue (myOperation ()->mrpExecVol ()[t]);

fprintf (solnFile (), "\n\n");
}
}
}
d463 3
a465 3
{
return myOperation ();
}
d470 3
a472 3
{
myMsgFac () ("mandECDdMsg", mandEC ());
}
d477 3
a479 3
{
return this;
}
d484 6
a489 6
{
myDataWriter ()->writeFirstKeyWord ("add");
myDataWriter ()->writeKeyWord      ("bomEntry");
myDataWriter ()->writeStringValue  (myOperationName ());
myDataWriter ()->writeStringValue  (myPartName ());
}
d494 2
a495 2
{
WitConsEntry::writeDataAttrs ();
d497 20
a516 20
if (wit34Compatible ())
writeOffset34 ();
else
writeOffset ();

myDataWriter ()->writeBool (
"mandEC",
mandEC (),
defMandEC ());

myDataWriter ()->writeBool (
"singleSource",
singleSource (),
defSingleSource ());

myDataWriter ()->writeVector (
"propRtg",
propRtg_,
defPropRtg ());
}
d521 4
a524 4
{
prereq1 = myOperation ();
prereq2 = myPart ();
}
d529 3
a531 3
{
purgeSelComps (mySubEntries_);
}
d536 3
a538 3
{
mySubEntries_.clear ();
}
d543 17
a559 17
{
WitMsgID  theMsgID;
WitPeriod thePer;

myProblem ()->myDataWriter ()->writeFirstKeyWord ("offset");

theMsgID =
myProblem ()->myGlobalComp ()->highPrecisionWD ()?
"doubleDenseVectorHpWdMsg":
"doubleDenseVectorWdMsg";

myMsgFac () ("startVectorWdMsg", "dense");

forEachPeriod (thePer, myProblem ())
myMsgFac () (theMsgID,
((thePer == 0)? "": " "),
offset ()[thePer]);
d561 2
a562 2
myMsgFac () ("endVectorWdMsg");
}
@


1.87
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d34 17
a50 1
      WitConsEntry     (thePart, theOpn->bom ().nElements ()),
d52 4
a55 20
      mappingIndex_    (myCompMgr ()->nBomEntries ()),
      myOperation_     (theOpn),
      mySubEntries_    (),
      mandEC_          (defMandEC ()),
      singleSource_    (defSingleSource ()),
      propRtg_         (myProblem (), defPropRtg ()),
      hasSubsInEffect_ (myProblem (), false),
      nonSubVol_       (myProblem (), 0.0)
   {
   witAssert (theOpn->myCompMgr () == thePart->myCompMgr ());

   if (wit34Compatible ())
      offsetRef () = myOperation ()->cycleTime34 ();
         //
         // This results in a default usageTime34 of 0.0.

   myCompMgr   ()->insert (this);
   myOperation ()->insert (this);
   myPart      ()->insert (this);
   }
d60 2
a61 2
   {
   }
d66 6
a71 6
   {
   if (mySubEntries ().isEmpty ())
      return myOperation ()->execVol ();
   else
      return nonSubVol_;
   }
d76 3
a78 3
   {
   return theProblem->myCompMgr ()->nBomEntries ();
   }
d85 2
a86 2
   {
   prepSetUnpreAttr ();
d88 2
a89 2
   mandEC_ = theValue;
   }
d94 2
a95 2
   {
   prepSetUnpostAttr ();
d97 2
a98 2
   singleSource_ = theValue;
   }
d103 2
a104 2
   {
   witAssert (theValue != NULL);
d106 1
a106 1
   prepSetUnpostAttr ();
d108 2
a109 2
   copy (propRtg_, theValue);
   }
d116 2
a117 2
   {
   witAssert (myPreprocessor ()->preprocessing ());
d119 2
a120 2
   mySubEntries_ = theList;
   }
d125 2
a126 2
   {
   witAssert (myPreprocessor ()->preprocessing ());
d128 2
a129 2
   hasSubsInEffect_ = theTVec;
   }
d134 2
a135 2
   {
   witAssert (myPostprocessor ()->postprocessing ());
d137 2
a138 2
   nonSubVol_ = theTVec;
   }
d143 2
a144 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d146 2
a147 2
   nonSubVol_.elemRef (thePer) = theValue;
   }
d152 3
a154 3
   {
   mySubEntries_.appendUniquely (theSub);
   }
d159 3
a161 3
   {
   return (myOperation ()->bom ().contains (this));
   }
d166 7
a172 7
   {
   if (myMsgFac ().mayIssue ("bomEntryInstIDMsg"))
      myMsgFac () ("bomEntryInstIDMsg",
         myOperationName (),
         localIndex (),
         myPartName ());
   }
d177 6
a182 6
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("bomEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeIntValue     (localIndex      ());
   }
d187 4
a190 4
   {
   WitOperation * theOpn;
   WitPart *      thePart;
   WitBomEntry *  theBomEnt;
d192 2
a193 2
   theOpn    = theCompMgr->myMatchFor (myOperation ());
   thePart   = theCompMgr->myMatchFor (myPart      ());
d195 1
a195 1
   theBomEnt = new WitBomEntry (theOpn, thePart);
d197 2
a198 2
   theBomEnt->copyAttrsFrom (this);
   }
d203 2
a204 2
   {
   recountConsEntry ();
d206 1
a206 1
   mappingIndex_ = myCompMgr ()->nBomEntries ();
d208 2
a209 2
   myCompMgr ()->recountBomEntry (this);
   }
d214 3
a216 3
   {
   hasSubsInEffect_ = false;
   nonSubVol_       = 0.0;
d218 2
a219 2
   WitConsEntry::unpreprocess ();
   }
d224 3
a226 3
   {
   return this;
   }
d231 3
a233 3
   {
   return myMsgFac ().myFrag ("bomEntryFrag");
   }
d238 3
a240 3
   {
   return WitAT_BOM_ENTRY;
   }
d245 2
a246 2
   {
   WitConsEntry::copyAttrsFrom (theBomEnt);
d248 4
a251 4
   mandEC_       = theBomEnt->mandEC_;
   singleSource_ = theBomEnt->singleSource_;
   propRtg_      = theBomEnt->propRtg_;
   }
d256 2
a257 2
   {
   WitPeriod thePer;
d259 1
a259 1
   witAssert (wit34Compatible ());
d261 1
a261 1
   prepSetUnpreAttr ();
d263 7
a269 7
   if (myOperation ()->cycleTime34 () == myOperation ()->cycleTime34 ()[0])
      offsetRef () = (myOperation ()->cycleTime34 ()[0] - theValue);
   else
      forEachPeriod (thePer, myProblem ())
         offsetRef ().elemRef (thePer) =
            myOperation ()->cycleTime34 ()[thePer] - theValue;
   }
d274 2
a275 2
   {
   double ut34;
d277 1
a277 1
   witAssert (wit34Compatible ());
d279 1
a279 1
   ut34 = myOperation ()->cycleTime34 ()[thePer] - offset ()[thePer];
d281 2
a282 2
   return ut34;
   }
d287 3
a289 3
   {
   return usageTime34 (0);
   }
d294 2
a295 2
   {
   WitPeriod thePer;
d297 4
a300 4
   forEachPeriod (thePer, myProblem ())
      offsetRef ().elemRef (thePer) +=
         newCycleTime34[thePer] - myOperation ()->cycleTime34 ()[thePer];
   }
d305 2
a306 2
   {
   WitSubEntry * theSub;
d308 27
a334 27
   myMsgFac () ("bomEntryDdMsg",
      myOperationName (),
      localIndex (),
      myPartName (),
      mappingIndex_,
      singleSource ());

   if (wit34Compatible ())
      myMsgFac () ("usageTime34DdMsg", usageTime34 ());

   myProblem ()->display ("propRtgDdMsg", propRtg_);

   if (myPreprocessor ()->preprocessed ())
      if (not mySubEntries ().isEmpty ())
         myProblem ()->display (
            "hasSubsInEffectDdMsg",
            hasSubsInEffect ());

   if (not mySubEntries ().isEmpty ())
      {
      myMsgFac () ("bomSubHeadingDdMsg");

      forEachEl (theSub, mySubEntries ())
         myMsgFac () ("bomSubDataDdMsg",
            theSub->myPartName (),
            theSub->localIndex ());
      }
d336 2
a337 2
   WitConsEntry::display ();
   }
d342 68
a409 68
   {
   WitSubEntry * theSub;
   WitPeriod     thePer;

   if (mySubEntries ().isEmpty ())
      return;

   fprintf (solnFile (), "\n"
      "Consuming Operation: %s,  Part Replaced: %s,  BOM Entry #%d:\n\n",
      myOperationName ().myCstring (),
      myPartName ().myCstring (),
      localIndex ());

   fprintf (solnFile (),
         "Period  Substitute       Sub #"
         "                     Volume");

   if (fssComputed ())
      fprintf (solnFile (), "                          Volume");

   fprintf (solnFile (), "\n");

   forEachPeriod (thePer, myProblem ())
      {
      if (hasSubsInEffect ()[thePer])
         {
         fprintf (solnFile (),
            "   %3d                          Non-SubVol: ",
            thePer);

         writeSolnValue (nonSubVol ()[thePer]);

         fprintf (solnFile (), "\n");
         }

      forEachEl (theSub, mySubEntries ())
         if (theSub->inEffect (thePer))
            {
            fprintf (solnFile (),
               "   %3d  %-12s  %8d      SubVol: ",
               thePer,
               theSub->myPartName ().myCstring (),
               theSub->localIndex ());

            writeSolnValue (theSub->subVol ()[thePer]);

            if (fssComputed ())
               {
               fprintf (solnFile (), "        FssSubVol: ");

               writeSolnValue (theSub->fssSubVol ()[thePer]);
               }

            fprintf (solnFile (), "\n");
            }

      if (hasSubsInEffect ()[thePer])
         {
         fprintf (solnFile (),
            "   %3d                             ExecVol: ",
            thePer);

         writeSolnValue (myOperation ()->execVol ()[thePer]);

         fprintf (solnFile (), "\n\n");
         }
      }
   }
d414 45
a458 45
   {
   WitSubEntry * theSub;
   WitPeriod     t;

   if (mySubEntries ().isEmpty ())
      return;

   fprintf (solnFile (), "\n"
      "Consuming Operation: %s,  Part Replaced: %s,  BOM Entry #%d:\n\n",
      myOperationName ().myCstring (),
      myPartName ().myCstring (),
      localIndex ());

   fprintf (solnFile (),
         "Period  Substitute       Sub #"
         "                          Volume\n");

   forEachPeriod (t, myProblem ())
      {
      forEachEl (theSub, mySubEntries ())
         if (theSub->inEffect (t))
            {
            fprintf (solnFile (),
               "   %3d  %-12s  %8d        MrpSubVol: ",
               t,
               theSub->myPartName ().myCstring (),
               theSub->localIndex ());

            writeSolnValue (theSub->mrpSubVol ()[t]);

            fprintf (solnFile (), "\n");
            }

      if (hasSubsInEffect ()[t])
         {
         fprintf (solnFile (),
            "   %3d                               MrpExecVol: ",
            t);

         writeSolnValue (myOperation ()->mrpExecVol ()[t]);

         fprintf (solnFile (), "\n\n");
         }
      }
   }
d463 3
a465 3
   {
   return myOperation ();
   }
d470 3
a472 3
   {
   myMsgFac () ("mandECDdMsg", mandEC ());
   }
d477 3
a479 3
   {
   return this;
   }
d484 6
a489 6
   {
   myDataWriter ()->writeFirstKeyWord ("add");
   myDataWriter ()->writeKeyWord      ("bomEntry");
   myDataWriter ()->writeStringValue  (myOperationName ());
   myDataWriter ()->writeStringValue  (myPartName ());
   }
d494 2
a495 2
   {
   WitConsEntry::writeDataAttrs ();
d497 20
a516 20
   if (wit34Compatible ())
      writeOffset34 ();
   else
      writeOffset ();

   myDataWriter ()->writeBool (
      "mandEC",
      mandEC (),
      defMandEC ());

   myDataWriter ()->writeBool (
      "singleSource",
      singleSource (),
      defSingleSource ());

   myDataWriter ()->writeVector (
      "propRtg",
      propRtg_,
      defPropRtg ());
   }
d521 4
a524 4
   {
   prereq1 = myOperation ();
   prereq2 = myPart ();
   }
d529 3
a531 3
   {
   purgeSelComps (mySubEntries_);
   }
d536 3
a538 3
   {
   mySubEntries_.clear ();
   }
d543 17
a559 17
   {
   WitMsgID  theMsgID;
   WitPeriod thePer;

   myProblem ()->myDataWriter ()->writeFirstKeyWord ("offset");

   theMsgID =
      myProblem ()->myGlobalComp ()->highPrecisionWD ()?
         "doubleDenseVectorHpWdMsg":
         "doubleDenseVectorWdMsg";

   myMsgFac () ("startVectorWdMsg", "dense");

   forEachPeriod (thePer, myProblem ())
      myMsgFac () (theMsgID,
         ((thePer == 0)? "": " "),
         offset ()[thePer]);
d561 2
a562 2
   myMsgFac () ("endVectorWdMsg");
   }
@


1.86
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d18 1
a18 1
#include <Opn.h>
@


1.85
log
@Multi-Objective Mode
@
text
@d19 1
a19 1
#include <Global.h>
@


1.84
log
@Object name change.
@
text
@d176 10
@


1.83
log
@Stochastic Implosion
@
text
@d34 1
a34 2
      WitConsEntry     (  preconstruct (theOpn, thePart),
                          theOpn->bom ().nElements ()),
d45 2
a451 12
WitPart * WitBomEntry::preconstruct (WitOperation * theOpn, WitPart * thePart)
   {
   witAssert (theOpn  != NULL);
   witAssert (thePart != NULL);

   witAssert (theOpn->myCompMgr () == thePart->myCompMgr ());

   return thePart;
   }

//------------------------------------------------------------------------------

@


1.82
log
@Stochastic Implosion
@
text
@d177 3
a179 1
   WitBomEntry * theBomEnt;
d181 4
a184 4
   theBomEnt =
      new WitBomEntry (
         theCompMgr->match (myOperation ()),
         theCompMgr->match (myPart ()));
@


1.81
log
@Stochastic Implosion
@
text
@d114 19
a132 1
void WitBomEntry::storePostNonSubVol (const WitTVec <double> & theValue)
d136 1
a136 1
   nonSubVol_ = theValue;
a199 9
void WitBomEntry::passPreRefs ()
   {
   WitConsEntry::passPreRefs ();

   myPreprocessor ()->receiveRefs (this, hasSubsInEffect_, mySubEntries_);
   }

//------------------------------------------------------------------------------

@


1.80
log
@Stochastic Implosion
@
text
@d123 9
@


1.79
log
@Stochastic Implosion
@
text
@d23 1
d114 9
@


1.78
log
@Stochastic Implosion
@
text
@d20 1
a20 1
#include <OptImp.h>
@


1.77
log
@Stochastic Implosion
@
text
@a22 1
#include <PreData.h>
a171 10
void WitBomEntry::importPreData ()
   {
   WitConsEntry::importPreData ();

   hasSubsInEffect_ = expPreData ()->hasSubsInEffect () (this);
   mySubEntries_    = expPreData ()->mySubEntries       (this);
   }

//------------------------------------------------------------------------------

@


1.76
log
@Stochastic Implosion
@
text
@d164 9
@


1.75
log
@Stochastic Implosion
@
text
@d169 1
@


1.74
log
@Stochastic Implosion
@
text
@d23 1
d167 2
@


1.73
log
@Stochastic Implosion
@
text
@d163 7
@


1.72
log
@Stochastic Implosion
@
text
@a137 14
WitMsgFrag WitBomEntry::objTypeMsgFrag ()
   {
   return myMsgFac ().myFrag ("bomEntryFrag");
   }

//------------------------------------------------------------------------------

WitAttr WitBomEntry::apiObjItrState ()
   {
   return WitAT_BOM_ENTRY;
   }

//------------------------------------------------------------------------------

d180 14
@


1.71
log
@Stochastic Implosion
@
text
@d84 1
a84 1
   settingUnpreAttr ();
d93 1
a93 1
   settingUnpostAttr ();
d104 1
a104 1
   settingUnpostAttr ();
d211 1
a211 1
   settingUnpreAttr ();
@


1.70
log
@Stochastic implosion.
@
text
@d19 1
d460 1
a460 4
      myDataWriter ()->writeVectorUncond (
         "offset",
         offset (),
         defOffset ());
a462 4
         //
         // If in wit 3.4 compatibility mode, must write offset
         // unconditionally, because in this case, offset is initialized to
         // cycleTime34 rather than defOffset ().
d501 24
@


1.69
log
@Stochastic implosion.
@
text
@d210 2
@


1.68
log
@Stochastic Implosion.
@
text
@d83 1
a83 1
   myPreprocessor ()->unpreprocess ();
d92 1
a92 1
   myProblem ()->resetSoln ();
d103 1
a103 1
   myProblem ()->resetSoln ();
@


1.67
log
@Stochastic Implosion.
@
text
@a43 2
   forbidAddStochAct ();

@


1.66
log
@Stochastic implosion.
@
text
@d25 1
d44 1
a44 1
   forbidAddStochAct ("bomEntryFrag");
a127 7
WitMsgFragID WitBomEntry::classFragID ()
   {
   return "bomEntryFrag";
   }

//------------------------------------------------------------------------------

d139 7
@


1.65
log
@[disallowed backlog]
@
text
@d43 2
@


1.64
log
@[disallowed backlog]
@
text
@a407 8
void WitBomEntry::transmitDMPs ()
   {
   WitPreprocessor ::receiveDMPs (& WitBomEntry::hasSubsInEffect_,
                                  & WitBomEntry::mySubEntries_);
   }

//------------------------------------------------------------------------------

@


1.63
log
@Rescinded all changed made since 1/31/07.
@
text
@a21 1
#include <Post.h>
a411 1
   WitPostprocessor::receiveDMPs (& WitBomEntry::nonSubVol_);
@


1.62
log
@[disallowed backlog]
@
text
@a21 1
#include <AvSorter.h>
a34 1
      hasSubsInEffect_ (myProblem ()),
d41 1
d178 4
a181 1
   nonSubVol_ = 0.0;
a287 13
void WitBomEntry::sortSubEntries (WitProblem * theProblem)
   {
   WitBomEntry * theBomEnt;

   WitAvSorter <WitSubEntry> theSorter (
      theProblem->myCompMgr ()->nSubEntries ());

   forEachBomEntry (theBomEnt, theProblem)
      theSorter.sort (theBomEnt->mySubEntries_);
   }

//------------------------------------------------------------------------------

d411 2
@


1.61
log
@[disallowed backlog]
@
text
@d22 1
d36 1
a42 1
      hasSubsInEffect_ (myProblem (), false),
d179 1
a179 2
   hasSubsInEffect_ = false;
   nonSubVol_       = 0.0;
d286 13
a421 2
   WitPreprocessor ::receiveDMPs (& WitBomEntry::hasSubsInEffect_,
                                  & WitBomEntry::mySubEntries_);
@


1.60
log
@witCopy<Object>Data
@
text
@a179 2

   WitConsEntry::unpreprocess ();
@


1.59
log
@App controlled opt implosion.
@
text
@d193 11
a494 11
void WitBomEntry::copyAttrsFrom (WitBomEntry * theBomEnt)
   {
   WitConsEntry::copyAttrsFrom (theBomEnt);

   mandEC_       = theBomEnt->mandEC_;
   singleSource_ = theBomEnt->singleSource_;
   propRtg_      = theBomEnt->propRtg_;
   }

//------------------------------------------------------------------------------

@


1.58
log
@App controlled opt implosion.
@
text
@a20 1
#include <DataAlt.h>
d83 3
a85 1
   mandEC_ = prepBool (theValue, preprocAlt ());
d92 3
a94 1
   singleSource_ = prepBool (theValue, postprocAlt ());
d101 5
a105 1
   copy (propRtg_, prepBoolVec (theValue, postprocAlt ()));
@


1.57
log
@Updated the copyright date on all source files.
@
text
@d249 1
a249 1
   if (myProblem ()->preprocessed ())
@


1.56
log
@[multi-thread]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.55
log
@Vector PropRtg.
@
text
@a185 16
void WitBomEntry::loadPre ()
   {
   WitConsEntry::loadPre ();

   myPreprocessor ()->loadDataFrom (this, hasSubsInEffect_, mySubEntries_);
   }

//------------------------------------------------------------------------------

void WitBomEntry::loadPost ()
   {
   myPostprocessor ()->loadDataFrom (this, nonSubVol_);
   }

//------------------------------------------------------------------------------

d391 9
@


1.54
log
@Vector PropRtg.
@
text
@a28 2
#include <Global.h>

a95 7
void WitBomEntry::setPropRouting (bool theValue)
   {
   propRtg_ = prepBool (theValue, postprocAlt ());
   }

//------------------------------------------------------------------------------

a97 2
   stronglyAssert (myGlobalComp ()->allowVecPR ());

d258 1
a258 2
      singleSource (),
      propRtg_[0]);
d263 1
a263 2
   if (myGlobalComp ()->allowVecPR ())
      myProblem ()->display ("propRtgDdMsg", propRtg_);
d476 4
a479 10
   if (myGlobalComp ()->allowVecPR ())
      myDataWriter ()->writeVector (
         "propRtg",
         propRtg_,
         defPropRtg ());
   else
      myDataWriter ()->writeBool (
         "propRouting",
         propRtg_[0],
         defPropRtg ());
@


1.53
log
@Vector PropRtg.
@
text
@a108 2
   stronglyAssert (hasSingleValue (theValue, nPeriods ()));

@


1.52
log
@Vector PropRtg.
@
text
@a42 1
      propRouting_     (defPropRouting ()),
d100 1
a100 3
   propRouting_ = prepBool (theValue, postprocAlt ());

   propRtg_     = propRouting_;
a111 2

   propRouting_ = propRtg_[0];
d272 1
a272 1
      propRouting ());
d499 2
a500 2
         propRouting (),
         defPropRouting ());
a510 1
   propRouting_  = theBomEnt->propRouting_;
@


1.51
log
@Vector Prop-Rtg.
@
text
@d44 1
a44 1
      propRt_          (myProblem (), defPropRt ()),
d103 1
a103 1
   propRt_      = propRouting_;
d108 1
a108 1
void WitBomEntry::setPropRt (const WitBoolean * theValue)
d114 1
a114 1
   copy (propRt_, prepBoolVec (theValue, postprocAlt ()));
d116 1
a116 1
   propRouting_ = propRt_[0];
d283 1
a283 1
      myProblem ()->display ("propRtDdMsg", propRt_);
d498 3
a500 3
         "propRt",
         propRt_,
         defPropRt ());
d517 1
a517 1
   propRt_       = theBomEnt->propRt_;
@


1.50
log
@Vector PropRt.
@
text
@d103 1
a103 2
   if (myGlobalComp ()->allowVecPR ())
      propRt_ = propRouting_;
d112 2
a495 5
   myDataWriter ()->writeBool (
      "propRouting",
      propRouting (),
      defPropRouting ());

d501 5
@


1.49
log
@Vector PropRt.
@
text
@d102 3
d114 2
@


1.48
log
@Vector PropRt.
@
text
@d29 2
d44 1
d105 9
d276 3
a292 2

      myMsgFac () ("blankMsg");
d494 6
d508 4
a511 3
   mandEC_       = theBomEnt->mandEC ();
   singleSource_ = theBomEnt->singleSource ();
   propRouting_  = theBomEnt->propRouting ();
@


1.47
log
@Vector PropRt.
@
text
@d25 1
a25 1
#include <InVecRA.h>
d238 1
a238 1
void WitBomEntry::adjustOffset (const WitInVecRA & newCycleTime34)
@


1.46
log
@Pegged critical list.
@
text
@d266 1
a266 1
         myProblem ()->displayBoolVec (
@


1.45
log
@Low-Pri Prop-Rt.
@
text
@d43 1
a43 2
      nonSubVol_       (myProblem (), 0.0),
      myRtSite_        (NULL)
a407 18
void WitBomEntry::attach (WitRtSite * theRtSite)
   {
   witAssert (myRtSite_ == NULL);

   myRtSite_ = theRtSite;
   }

//------------------------------------------------------------------------------

void WitBomEntry::detachRtSite ()
   {
   witAssert (myRtSite_ != NULL);

   myRtSite_ = NULL;
   }

//------------------------------------------------------------------------------

@


1.44
log
@Double Precision.
@
text
@d313 11
a347 8
            "   %3d                          Non-SubVol: ",
            thePer);

         writeSolnValue (nonSubVol ()[thePer]);

         fprintf (solnFile (), "\n");

         fprintf (solnFile (),
@


1.43
log
@Double Precision.
@
text
@d221 1
a221 1
   double ut34Flt;
d225 1
a225 1
   ut34Flt = myOperation ()->cycleTime34 ()[thePer] - offset ()[thePer];
d227 1
a227 1
   return ut34Flt;
@


1.42
log
@Double Precision.
@
text
@d221 1
a221 1
   float ut34Flt;
d227 1
a227 1
   return dblFromFlt (ut34Flt);
@


1.41
log
@Double Precision.
@
text
@d172 2
a173 2
   hasSubsInEffect_.setToScalar (false);
   nonSubVol_      .setToScalar (0.0);
d210 1
a210 1
      offsetRef ().setToScalar (myOperation ()->cycleTime34 ()[0] - theValue);
@


1.40
log
@Double Precision.
@
text
@d47 1
a47 1
      offsetRef ().copy (myOperation ()->cycleTime34 ());
@


1.39
log
@Double Precision.
@
text
@d25 1
d239 1
a239 1
void WitBomEntry::adjustOffset (const float * newCycleTime34)
@


1.38
log
@Double Precision.
@
text
@a24 1
#include <InVecRA.h>
a238 11
   {
   WitPeriod thePer;

   forEachPeriod (thePer, myProblem ())
      offsetRef ().elemRef (thePer) +=
         newCycleTime34[thePer] - myOperation ()->cycleTime34 ()[thePer];
   }

//------------------------------------------------------------------------------

void WitBomEntry::adjustOffset (const WitInVecRA & newCycleTime34)
@


1.37
log
@Double Precision.
@
text
@d25 1
d240 11
@


1.36
log
@Double Precision.
@
text
@d63 1
a63 1
const WitFlexVec <double> & WitBomEntry::nonSubVol ()
@


1.35
log
@Double Precision.
@
text
@a204 1
   double    offsetVal;
d212 2
a213 5
         {
         offsetVal = myOperation ()->cycleTime34 ()[thePer] - theValue;

         offsetRef ().setElem (thePer, offsetVal);
         }
a240 1
   double    delta;
d243 2
a244 5
      {
      delta = newCycleTime34[thePer] - myOperation ()->cycleTime34 ()[thePer];

      offsetRef ().incElem (thePer, delta);
      }
@


1.34
log
@Double Precision.
@
text
@d46 1
a46 1
      myOperation ()->cycleTime34 ().convCopyInto (offsetRef ());
d205 1
d213 5
a217 2
         offsetRef ().elemRef (thePer) = 
            myOperation ()->cycleTime34 ()[thePer] - theValue;
d245 1
d248 5
a252 2
      offsetRef ().elemRef (thePer) += 
         newCycleTime34[thePer] - myOperation ()->cycleTime34 ()[thePer];
@


1.33
log
@Double Precision.
@
text
@d46 1
a46 1
      offsetRef ().copy (myOperation ()->cycleTime34 ());
@


1.32
log
@Continued double precision.
@
text
@d226 1
a226 1
   return doubleFromFloat (ut34Flt);
@


1.31
log
@Continued double precision.
@
text
@d226 1
a226 1
   return static_cast <double> (ut34Flt);
@


1.30
log
@Continued double precision.
@
text
@d202 1
a202 1
void WitBomEntry::setUsageTime34 (StrDbl theValue)
d218 1
a218 1
StrDbl WitBomEntry::usageTime34 (WitPeriod thePer)
d226 1
a226 1
   return StrDbl::convFloat (ut34Flt);
d231 1
a231 1
StrDbl WitBomEntry::usageTime34 ()
@


1.29
log
@Continued implementation of PIP.
@
text
@d202 1
a202 1
void WitBomEntry::setUsageTime34 (float theValue)
d218 1
a218 1
float WitBomEntry::usageTime34 (WitPeriod thePer)
d220 2
d224 3
a226 1
   return myOperation ()->cycleTime34 ()[thePer] - offset ()[thePer];
d231 1
a231 1
float WitBomEntry::usageTime34 ()
@


1.28
log
@Removed a bad function overload.
@
text
@d16 3
a24 2
#include <Opn.h>
#include <SubEntry.h>
@


1.27
log
@Continued implementation of post-implosion pegging.
@
text
@d178 1
a178 1
WitBomEntry * WitBomEntry::myBomEnt ()
@


1.26
log
@Made modifications to improve the speed of witPurgeData.
@
text
@a25 1
#include <FlexVecI.h>
@


1.25
log
@Continued implementation of proportionate routing.
@
text
@d128 5
a132 4
   myMsgFac () ("bomEntryInstIDMsg",
      myOperationName (),
      localIndex (),
      myPartName ());
@


1.24
log
@Continued implementation of proportionate routing.
@
text
@d178 1
a178 1
void WitBomEntry::getBomEntry (WitBomEntry * & theBomEnt)
d180 1
a180 1
   theBomEnt = this;
@


1.23
log
@Continued implementation of proportionate routing.
@
text
@d42 2
a43 1
      nonSubVol_       (myProblem (), 0.0)
d396 18
@


1.22
log
@Continued implementation of proportionate routing.
@
text
@d40 1
d94 7
d252 2
a253 1
      singleSource ());
d467 5
d482 1
@


1.21
log
@Internal changes.
@
text
@d70 7
@


1.20
log
@Internal changes.
@
text
@d243 1
a243 1
      if (! mySubEntries ().isEmpty ())
d248 1
a248 1
   if (! mySubEntries ().isEmpty ())
@


1.19
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d40 1
a40 1
      hasSubsInEffect_ (myProblem (), witFALSE),
d73 1
a73 1
void WitBomEntry::setMandEC (WitBoolean theValue)
d75 1
a75 1
   mandEC_ = prepBoolean (theValue, preprocAlt ());
d80 1
a80 1
void WitBomEntry::setSingleSource (WitBoolean theValue)
d82 1
a82 1
   singleSource_ = prepBoolean (theValue, postprocAlt ());
d96 1
a96 1
WitBoolean WitBomEntry::inserted ()
d154 1
a154 1
   hasSubsInEffect_.setToScalar (witFALSE);
d244 1
a244 1
         myProblem ()->display (
d442 1
a442 1
   myDataWriter ()->writeBoolean (
d447 1
a447 1
   myDataWriter ()->writeBoolean (
@


1.18
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d26 1
@


1.17
log
@Continued implementation of Single-Source.
@
text
@d22 2
@


1.16
log
@Continued implementation of single-source.
@
text
@d36 1
d76 7
d233 2
a234 1
      mappingIndex_);
d443 5
d456 2
a457 1
   mandEC_ = theBomEnt->mandEC ();
@


1.15
log
@Continued implementation of single-source.
@
text
@d141 10
d154 9
@


1.14
log
@Continued implementation of single-source.
@
text
@d20 1
d144 7
@


1.13
log
@Continued implementation of single-source.
@
text
@a19 1
#include <Post.h>
a221 18
   }

//------------------------------------------------------------------------------

void WitBomEntry::compNonSubVol ()
   {
   WitSubEntry * theSub;
   WitPeriod     thePer;

   if (mySubEntries_.isEmpty ())
      return;

   nonSubVol_.copy (myOperation ()->execVol ());

   forEachEl (theSub, mySubEntries_)
      forEachPeriod (thePer, myProblem ())
         if (theSub->inEffect (thePer))
            nonSubVol_.elemRef (thePer) -= theSub->subVol ()[thePer];
@


1.12
log
@Continued implementation of single-source.
@
text
@a147 7
void WitBomEntry::importPostprocResults ()
   {
   nonSubVol_.copyTVec (myPostprocessor ()->nonSubVol (this));
   }

//------------------------------------------------------------------------------

d223 18
@


1.11
log
@Preliminary work on single source.
@
text
@d20 1
d144 7
@


1.10
log
@Continued implementation of object iteration.
@
text
@d39 1
a39 1
      offsetRef () = myOperation ()->cycleTime34 ();
d56 1
a56 1
const WitFlexVec (double) & WitBomEntry::nonSubVol ()
d154 1
a154 1
      offsetRef () = myOperation ()->cycleTime34 ()[0] - theValue;
@


1.9
log
@Continued implementation of object iteration.
@
text
@d108 1
a108 1
WitAttr WitBomEntry::apiItrState ()
@


1.8
log
@Continued implementation of object iteration.
@
text
@d110 1
a110 1
   return WitITR_AT_BOM_ENTRY;
@


1.7
log
@Began implementation of object iteration.
@
text
@d21 1
d108 7
d136 7
@


1.6
log
@Implemented and used class SelMgr.
@
text
@d21 1
d51 10
@


1.5
log
@Coarse selection splitting.
@
text
@a412 6

//------------------------------------------------------------------------------

implementClearContents (WitBomEntry)
   //
   // See RWClient.h.
@


1.4
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d112 1
a112 1
   setBillEntryIndex ();
d116 1
a116 1
   myCompMgr ()->recount (this);
@


1.3
log
@Fixed bug: MCL Client Error on emptyBom msg.
@
text
@d96 1
a96 1
void WitBomEntry::copyInto (WitCompMgr * theCompMgr)
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d34 1
a34 1
      nonSubVol_       ()
d203 1
a203 1
   WitPeriod     t;
d223 1
a223 1
   forEachPeriod (t, myProblem ())
d226 1
a226 1
         if (theSub->inEffect (t))
d230 1
a230 1
               t,
d234 1
a234 1
            writeSolnValue (theSub->subVol ()[t]);
d240 1
a240 1
               writeSolnValue (theSub->fssSubVol ()[t]);
d246 1
a246 1
      if (hasSubsInEffect ()[t])
d250 1
a250 1
            t);
d252 1
a252 1
         writeSolnValue (nonSubVol ()[t]);
d258 1
a258 1
            t);
d260 1
a260 1
         writeSolnValue (myOperation ()->execVol ()[t]);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

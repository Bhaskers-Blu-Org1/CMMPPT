head	1.79;
access;
symbols
	sce_5_01_20080919:1.72
	latest_sce_4_20_20060523:1.56.0.2
	sce_4_20_20060523:1.56
	latest_sce4_20_OSL:1.55.0.2
	sce_4_20_OSL:1.55
	sce_410_withVa:1.54
	sce_4_05_20040511:1.40
	sce_4_00_20040201:1.21
	nextGenBranch:1.19.0.2
	nextGenRoot:1.19
	sce_3_30_20030627:1.19
	EndRw-branch:1.12.0.4
	Root-of-EndRw:1.12
	rwToStl:1.12.0.2
	latest_sce_3_10_20010924:1.5.0.2
	sce_3_10_20010924:1.5
	latest_sce_3_00_20010601:1.4.0.6
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.4.0.4
	sce_2_31_20010308:1.4
	latest_sce_2_31_20001003:1.4.0.2
	sce_2_31_20001003:1.4
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.79
date	2011.09.28.23.50.44;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2011.09.24.00.28.59;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2011.08.30.20.18.25;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2010.09.10.22.10.42;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2010.03.26.22.22.54;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2010.03.16.22.42.29;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.12.19.52.26;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2007.08.01.22.41.59;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.04.22.08.19;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.02.23.01.16;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.02.21.21.20;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.26.21.03.16;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.19.23.47.08;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.16.16.53.45;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.16.16.27.40;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2006.12.27.22.45.40;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.17.17.22.01;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.17.16.57.48;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.14.23.10.27;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2006.11.02.23.07.14;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2006.09.19.17.50.56;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2006.08.24.20.50.27;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.22.21.26.55;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.02.17.34.16;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.12.22.17.33;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2005.09.01.21.45.04;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.24.18.24.24;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2005.08.23.19.45.20;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.19.21.38.04;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.12.19.35.30;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.13.21.18.47;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.16.17.00.31;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.04.00.00.29;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.03.21.25.12;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.02.22.34.37;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.02.21.59.46;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.25.21.26.10;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.24.23.23.58;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.12.19.43.31;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.05.15.43.59;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.14.21.16.18;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.09.19.37.57;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.02.20.54.17;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.01.21.05.13;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.29.23.21.28;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.25.22.00.37;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.25.21.21.59;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.25.20.35.02;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.25.19.59.38;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.04.16.31.46;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.03.22.36.22;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.26.18.59.43;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.24.19.37.23;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.20.22.46.03;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.20.15.37.36;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.07.00.12.10;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.11.18.29.15;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.05.20.18.24;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.07.18.06.19;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.19.16.48.29;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.21.18.56.30;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.23.40.54;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.02.22.18.57;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.30.21.57.28;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.30.20.37.30;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.25.17.43.55;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.24.22.02.28;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.08.19.21.58;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.03.23.16.44;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.25.19.14.55;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.24.18.26.11;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.18.14.02.48;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.31.00.26.26;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.25.20.12.37;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.55.29;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.57.16;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.33;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.33;	author wit;	state Exp;
branches;
next	;


desc
@@


1.79
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "bomApi.C"
//
// Inner API functions relating to BomEntries.
//------------------------------------------------------------------------------

#include <WitRun.h>
#include <ApiMgr.h>
#include <InputID.h>
#include <ApiCall.h>
#include <ISRealArg.h>
#include <OSRealArg.h>
#include <IVRealArg.h>
#include <OVRealArg.h>
#include <Pre.h>
#include <DetOptImpMgr.h>
#include <ExtOptMgr.h>
#include <CompMgr.h>
#include <Operation.h>
#include <BomEntry.h>
#include <GlobalComp.h>
#include <MsgFrag.h>
#include <MsgFac.h>

#include <stdlib.h>

//------------------------------------------------------------------------------
// setBomEntryInit
// Initilization of witSetBomEntry* functions.
//------------------------------------------------------------------------------

WitBomEntry * WitRun::setGetBomEntryInit (
      const char * operationName,
      int          bomEntryIndex)
   {
   forbidNullArg (operationName, "operationName");

   if (myMsgFac ().mayIssue ("operationNameMsg"))
      myMsgFac () ("operationNameMsg", operationName );

   if (myMsgFac ().mayIssue ("bomEntryIndexMsg"))
      myMsgFac () ("bomEntryIndexMsg", bomEntryIndex);

   return getBomEntryP (operationName, bomEntryIndex);
   }

//------------------------------------------------------------------------------

void WitRun::witAddBomEntry (
      const char * consumingOperationName,
      const char * consumedPartName)
   {
   WitOperation * theOpn;
   WitPart *      thePart;

   myApiMgr_->startInnerFunc ();

   forbidNullArg (consumingOperationName, "consumingOperationName");
   forbidNullArg (consumedPartName,       "consumedPartName");

   if (myMsgFac ().mayIssue ("addBomEntryMsg"))
      myMsgFac () ("addBomEntryMsg",
         consumingOperationName,
         consumedPartName);

   theOpn = myCompMgr ()->findOperation (consumingOperationName);

   if (theOpn == NULL)
      myMsgFac () ("undefinedOperationMsg", consumingOperationName);

   myInputID ()->setMyOperation (theOpn);

   thePart = myCompMgr ()->findPart (consumedPartName);

   if (thePart == NULL)
      myMsgFac () ("undefinedPartMsg", consumedPartName);

   addingDelComp ("bomEntryFrag");

   new WitBomEntry (theOpn, thePart);

   myInputID ()->setMyOperation (NULL);
   }

//------------------------------------------------------------------------------

void WitRun::witCopyBomEntryData (
      const char * dupOperationName,
      int          dupBomEntryIndex,
      WitRun *     origWitRun,
      const char * origOperationName,
      int          origBomEntryIndex)
   {
   startCopyObjData (origWitRun);

   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("bomEntryFrag"));

   WitBomEntryApiCall dupCall  (
      this,
      dupOperationName,
      dupBomEntryIndex);

   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("bomEntryFrag"));

   WitBomEntryApiCall origCall  (
      origWitRun,
      origOperationName,
      origBomEntryIndex);

   if (dupCall.myBomEnt () == origCall.myBomEnt ())
      myMsgFac () ("copyObjectToSelfSmsg",
         myMsgFac ().myFrag ("bomEntryFrag"));

   dupCall.myBomEnt ()->copyAttrsFrom (origCall.myBomEnt ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetObjItrBomEntry (
      char * * consumingOperationName,
      int *    bomEntryIndex)
   {
   WitBomEntry * theBomEnt;

   myApiMgr_->startInnerFunc ();

   theBomEnt =
      curItrDelCompForGet (WitAT_BOM_ENTRY, "bomEntryFrag")->
         thisBomEnt ();

   stronglyAssert (theBomEnt != NULL);

   apiGet (
      consumingOperationName, 
      "consumingOperationName", 
      theBomEnt->myOperationName ());

   apiGet (bomEntryIndex, "bomEntryIndex", theBomEnt->localIndex ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryAppData (
      const char * consumingOperationName,
      int          bomEntryIndex,
      void * *     appData)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (appData, "appData", theCall.myBomEnt ()->appData ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryConsRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOVRealArg & consRate)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (consRate, "consRate", theCall.myBomEnt ()->consRate ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryConsumedPart(
      const char * consumingOperationName,
      int          bomEntryIndex,
      char * *     consumedPartName)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (
       consumedPartName, 
      "consumedPartName", 
      theCall.myBomEnt ()->myPartName ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryEarliestPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        earliestPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (                earliestPeriod, 
                          "earliestPeriod", 
      theCall.myBomEnt ()->earliestPeriod ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryExecPenalty (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOSRealArg & execPenalty)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (execPenalty, "execPenalty", theCall.myBomEnt ()->execPenalty ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryFallout (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        fallout )
   {
   double theFalloutRate;

   myApiMgr_->startInnerFunc ();

   myMsgFac () (
      "getPre50AttrMsg",
      apiFuncName (),
      "bomEntry",
      "fallout",
      "falloutRate");

   witGetBomEntryFalloutRate (
      consumingOperationName,
      bomEntryIndex,
      & theFalloutRate);

   apiGet (fallout, "fallout", fracToPercent (theFalloutRate));
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryFalloutRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOSRealArg & falloutRate)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (falloutRate, "falloutRate", theCall.myBomEnt ()->falloutRate ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryImpactPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int **       impactPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   myProblem ()->myPreprocessor ()->preprocess ();

   apiGet (impactPeriod, "impactPeriod", theCall.myBomEnt ()->impactPeriod ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryLatestPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        latestPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (latestPeriod, "latestPeriod", theCall.myBomEnt ()->latestPeriod ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryMandEC (
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean * mandEC)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (mandEC, "mandEC", theCall.myBomEnt ()->mandEC ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryNSubsBomEntries (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        nSubsBomEntries)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (
       nSubsBomEntries,
      "nSubsBomEntries",
      theCall.myBomEnt ()->mySubEntries ().nElements ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryNonSubVarIndex (
      const char * consumingOperationName,
      int          bomEntryIndex,
      const int    thePer,
      int *        nonSubVarIndex)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   prepGetIndex (thePer);

   apiGet (
       nonSubVarIndex,
      "nonSubVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            nonSubVarIndex (theCall.myBomEnt (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryOffset (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOVRealArg & offset)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (offset, "offset", theCall.myBomEnt ()->offset ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryPropRouting (
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean * propRouting)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "BOM entry",
         "propRouting",
         "propRtg");

   apiGet (propRouting, "propRouting", theCall.myBomEnt ()->propRtg ()[0]);
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryPropRtg (
      const char *   consumingOperationName,
      int            bomEntryIndex,
      WitBoolean * * propRtg)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (propRtg, "propRtg", theCall.myBomEnt ()->propRtg ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryRoutingShare (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOVRealArg & routingShare)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (routingShare, "routingShare", theCall.myBomEnt ()->routingShare ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntrySelForDel (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        selForDel)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (selForDel, "selForDel", theCall.myBomEnt ()->selForDel ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntrySingleSource (
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean * singleSource)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (singleSource, "singleSource", theCall.myBomEnt ()->singleSource ());
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntrySubConIndex (
      const char * consumingOperationName,
      int          bomEntryIndex,
      const int    thePer,
      int *        subConIndex)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   prepGetIndex (thePer);

   apiGet (
       subConIndex,
      "subConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            subConIndex (theCall.myBomEnt (), thePer));
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryUsageRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOSRealArg & usageRate)
   {
   double * consRateCVec;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "BOM entry",
         "usageRate",
         "consRate");

   witGetBomEntryConsRate (
      consumingOperationName, 
      bomEntryIndex, 
      & consRateCVec);

   forbidNullArg (usageRate, "usageRate");

   usageRate = consRateCVec[0];

   free (consRateCVec);
   }

//------------------------------------------------------------------------------

void WitRun::witGetBomEntryUsageTime (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOSRealArg & usageTime)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   if (not wit34Compatible ())
      myMsgFac () ("getting34AttributeWithoutCompatibilityUsageTime",
         apiFuncName ());

   myMsgFac () ("getting34AttributeWithCompatibilityUsageTime", apiFuncName ());

   apiGet (usageTime, "usageTime", theCall.myBomEnt ()->usageTime34 ());
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryAppData (
      const char * consumingOperationName,
      int          bomEntryIndex,
      void *       appData)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.setAppData (appData);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryConsRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitIVRealArg & consRate)
   {
   WitPeriod thePer;

   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepDblVec ("consRate", consRate);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setConsRate (consRate);

   forEachPeriod (thePer, myProblem ())
      if (consRate[thePer] < 0.0)
         myMsgFac () ("negConsRateMsg",
            bomEntryIndex,
            consumingOperationName,
            consRate[thePer],
            thePer);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryEarliestPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          earliestPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.setEarliestPeriod (earliestPeriod);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryExecPenalty (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitISRealArg & execPenalty)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepNonNegDouble (
      "execPenalty", 
      theCall.myBomEnt ()->execPenalty (),
      execPenalty);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setExecPenalty (execPenalty);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryFallout (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          fallout)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () (
      "setPre50AttrMsg",
      apiFuncName (),
      "bomEntry",
      "fallout",
      "falloutRate");

   witSetBomEntryFalloutRate (
      consumingOperationName,
      bomEntryIndex,
      percentToFrac (fallout));
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryFalloutRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitISRealArg & falloutRate)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepNonNegUBDouble (
      "falloutRate", 
      theCall.myBomEnt ()->falloutRate (), 
      falloutRate,
      0.99 + FLOAT_EPSILON,
      0.99);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setFalloutRate (falloutRate);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryLatestPeriod (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          latestPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.setLatestPeriod (latestPeriod);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryMandEC (
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean   mandEC)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepBool ("mandEC", theCall.myBomEnt ()->mandEC (), mandEC);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setMandEC (asaBool (mandEC));
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryOffset (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitIVRealArg & offset)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.setOffset (offset);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryPropRouting (
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean   propRouting)
   {
   WitTVec <WitBoolean> & propRtgVec = myApiMgr ()->reserveTempBooleanVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "BOM entry",
         "propRouting",
         "propRtg");

   propRtgVec = propRouting;

   witSetBomEntryPropRtg (
      consumingOperationName,
      bomEntryIndex,
      propRtgVec.myCVec ());

   myApiMgr ()->releaseTempVecs ();
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryPropRtg (
      const char *       consumingOperationName,
      int                bomEntryIndex,
      const WitBoolean * propRtg)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepBoolVec ("propRtg", propRtg);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setPropRtg (propRtg);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryRoutingShare (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitIVRealArg & routingShare)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.setRoutingShare (routingShare);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntrySelForDel (
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          selForDel)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.setSelForDel (selForDel);
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntrySingleSource (
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean   singleSource)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepBool (
                          "singleSource", 
      theCall.myBomEnt ()->singleSource (), 
                           singleSource);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setSingleSource (asaBool (singleSource));
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryUsageRate (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitISRealArg & usageRate)
   {
   WitTVec <double> & consRateVec = myApiMgr ()->reserveTempDblVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "BOM entry",
         "usageRate",
         "consRate");

   consRateVec = usageRate;

   witSetBomEntryConsRate (
      consumingOperationName,
      bomEntryIndex,
      consRateVec.myCVec ());

   myApiMgr ()->releaseTempVecs ();
   }

//------------------------------------------------------------------------------

void WitRun::witSetBomEntryUsageTime (
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitISRealArg & inpVal)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   if (not wit34Compatible ())
      myMsgFac () ("setting34AttributeWithoutCompatibilityUsageTime",
         apiFuncName () );

   myMsgFac () ("setting34AttributeWithCompatibilityUsageTime", apiFuncName ());

   theCall.prepDouble (
      "usageTime",
      theCall.myBomEnt ()->usageTime34 (),
      inpVal);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setUsageTime34 (inpVal);
   }

//------------------------------------------------------------------------------
// getBomEntryP
// Get pointer to WitBomEntry.
//------------------------------------------------------------------------------

WitBomEntry * WitRun::getBomEntryP (
      const char * consumingOperationName,
      int          bomEntryIndex)
   {
   WitBomEntry *  retVal;
   WitOperation * theOpn;

   theOpn = getOperationP (consumingOperationName);

   myInputID ()->setMyOperation (theOpn);

   if (theOpn->bom ().isEmpty ())
      myMsgFac () ("emptyBom");

   if (bomEntryIndex < 0 or bomEntryIndex >= theOpn->bom ().nElements ())
      myMsgFac () ("bomEntryIndexRangeSmsg",
         bomEntryIndex,
         0,
         theOpn->bom ().nElements ());

   retVal = myCompMgr ()->findBomEntry (theOpn, bomEntryIndex);

   witAssert (retVal != NULL);

   myInputID ()->setMyBomEntry (retVal);

   return retVal;
   }
@


1.78
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.77
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d42 4
a45 4
const char * operationName,
int          bomEntryIndex)
{
forbidNullArg (operationName, "operationName");
d47 2
a48 2
if (myMsgFac ().mayIssue ("operationNameMsg"))
myMsgFac () ("operationNameMsg", operationName );
d50 2
a51 2
if (myMsgFac ().mayIssue ("bomEntryIndexMsg"))
myMsgFac () ("bomEntryIndexMsg", bomEntryIndex);
d53 2
a54 2
return getBomEntryP (operationName, bomEntryIndex);
}
d59 5
a63 5
const char * consumingOperationName,
const char * consumedPartName)
{
WitOperation * theOpn;
WitPart *      thePart;
d65 1
a65 1
myApiMgr_->startInnerFunc ();
d67 2
a68 2
forbidNullArg (consumingOperationName, "consumingOperationName");
forbidNullArg (consumedPartName,       "consumedPartName");
d70 4
a73 4
if (myMsgFac ().mayIssue ("addBomEntryMsg"))
myMsgFac () ("addBomEntryMsg",
consumingOperationName,
consumedPartName);
d75 1
a75 1
theOpn = myCompMgr ()->findOperation (consumingOperationName);
d77 2
a78 2
if (theOpn == NULL)
myMsgFac () ("undefinedOperationMsg", consumingOperationName);
d80 1
a80 1
myInputID ()->setMyOperation (theOpn);
d82 1
a82 1
thePart = myCompMgr ()->findPart (consumedPartName);
d84 2
a85 2
if (thePart == NULL)
myMsgFac () ("undefinedPartMsg", consumedPartName);
d87 1
a87 1
addingDelComp ("bomEntryFrag");
d89 1
a89 1
new WitBomEntry (theOpn, thePart);
d91 2
a92 2
myInputID ()->setMyOperation (NULL);
}
d97 25
a121 25
const char * dupOperationName,
int          dupBomEntryIndex,
WitRun *     origWitRun,
const char * origOperationName,
int          origBomEntryIndex)
{
startCopyObjData (origWitRun);

myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("bomEntryFrag"));

WitBomEntryApiCall dupCall  (
this,
dupOperationName,
dupBomEntryIndex);

myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("bomEntryFrag"));

WitBomEntryApiCall origCall  (
origWitRun,
origOperationName,
origBomEntryIndex);

if (dupCall.myBomEnt () == origCall.myBomEnt ())
myMsgFac () ("copyObjectToSelfSmsg",
myMsgFac ().myFrag ("bomEntryFrag"));
d123 2
a124 2
dupCall.myBomEnt ()->copyAttrsFrom (origCall.myBomEnt ());
}
d129 17
a145 17
char * * consumingOperationName,
int *    bomEntryIndex)
{
WitBomEntry * theBomEnt;

myApiMgr_->startInnerFunc ();

theBomEnt =
curItrDelCompForGet (WitAT_BOM_ENTRY, "bomEntryFrag")->
thisBomEnt ();

stronglyAssert (theBomEnt != NULL);

apiGet (
consumingOperationName,
"consumingOperationName",
theBomEnt->myOperationName ());
d147 2
a148 2
apiGet (bomEntryIndex, "bomEntryIndex", theBomEnt->localIndex ());
}
d153 5
a157 5
const char * consumingOperationName,
int          bomEntryIndex,
void * *     appData)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d159 2
a160 2
apiGet (appData, "appData", theCall.myBomEnt ()->appData ());
}
d165 5
a169 5
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitOVRealArg & consRate)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d171 2
a172 2
apiGet (consRate, "consRate", theCall.myBomEnt ()->consRate ());
}
d177 11
a187 11
const char * consumingOperationName,
int          bomEntryIndex,
char * *     consumedPartName)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

apiGet (
consumedPartName,
"consumedPartName",
theCall.myBomEnt ()->myPartName ());
}
d192 10
a201 10
const char * consumingOperationName,
int          bomEntryIndex,
int *        earliestPeriod)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

apiGet (                earliestPeriod,
"earliestPeriod",
theCall.myBomEnt ()->earliestPeriod ());
}
d206 5
a210 5
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitOSRealArg & execPenalty)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d212 2
a213 2
apiGet (execPenalty, "execPenalty", theCall.myBomEnt ()->execPenalty ());
}
d218 19
a236 19
const char * consumingOperationName,
int          bomEntryIndex,
int *        fallout )
{
double theFalloutRate;

myApiMgr_->startInnerFunc ();

myMsgFac () (
"getPre50AttrMsg",
apiFuncName (),
"bomEntry",
"fallout",
"falloutRate");

witGetBomEntryFalloutRate (
consumingOperationName,
bomEntryIndex,
& theFalloutRate);
d238 2
a239 2
apiGet (fallout, "fallout", fracToPercent (theFalloutRate));
}
d244 5
a248 5
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitOSRealArg & falloutRate)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d250 2
a251 2
apiGet (falloutRate, "falloutRate", theCall.myBomEnt ()->falloutRate ());
}
d256 5
a260 5
const char * consumingOperationName,
int          bomEntryIndex,
int **       impactPeriod)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d262 1
a262 1
myProblem ()->myPreprocessor ()->preprocess ();
d264 2
a265 2
apiGet (impactPeriod, "impactPeriod", theCall.myBomEnt ()->impactPeriod ());
}
d270 5
a274 5
const char * consumingOperationName,
int          bomEntryIndex,
int *        latestPeriod)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d276 2
a277 2
apiGet (latestPeriod, "latestPeriod", theCall.myBomEnt ()->latestPeriod ());
}
d282 5
a286 5
const char * consumingOperationName,
int          bomEntryIndex,
WitBoolean * mandEC)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d288 2
a289 2
apiGet (mandEC, "mandEC", theCall.myBomEnt ()->mandEC ());
}
d294 11
a304 11
const char * consumingOperationName,
int          bomEntryIndex,
int *        nSubsBomEntries)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

apiGet (
nSubsBomEntries,
"nSubsBomEntries",
theCall.myBomEnt ()->mySubEntries ().nElements ());
}
d309 16
a324 16
const char * consumingOperationName,
int          bomEntryIndex,
const int    thePer,
int *        nonSubVarIndex)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

prepGetIndex (thePer);

apiGet (
nonSubVarIndex,
"nonSubVarIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
nonSubVarIndex (theCall.myBomEnt (), thePer));
}
d329 5
a333 5
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitOVRealArg & offset)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d335 2
a336 2
apiGet (offset, "offset", theCall.myBomEnt ()->offset ());
}
d341 13
a353 13
const char * consumingOperationName,
int          bomEntryIndex,
WitBoolean * propRouting)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
myMsgFac () (
"getVecAttrAsScalMsg",
apiFuncName (),
"BOM entry",
"propRouting",
"propRtg");
d355 2
a356 2
apiGet (propRouting, "propRouting", theCall.myBomEnt ()->propRtg ()[0]);
}
d361 5
a365 5
const char *   consumingOperationName,
int            bomEntryIndex,
WitBoolean * * propRtg)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d367 2
a368 2
apiGet (propRtg, "propRtg", theCall.myBomEnt ()->propRtg ());
}
d373 5
a377 5
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitOVRealArg & routingShare)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d379 2
a380 2
apiGet (routingShare, "routingShare", theCall.myBomEnt ()->routingShare ());
}
d385 5
a389 5
const char * consumingOperationName,
int          bomEntryIndex,
int *        selForDel)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d391 2
a392 2
apiGet (selForDel, "selForDel", theCall.myBomEnt ()->selForDel ());
}
d397 5
a401 5
const char * consumingOperationName,
int          bomEntryIndex,
WitBoolean * singleSource)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d403 2
a404 2
apiGet (singleSource, "singleSource", theCall.myBomEnt ()->singleSource ());
}
d409 16
a424 16
const char * consumingOperationName,
int          bomEntryIndex,
const int    thePer,
int *        subConIndex)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

prepGetIndex (thePer);

apiGet (
subConIndex,
"subConIndex",
myDetOptImpMgr ()->
myExtOptMgr ()->
subConIndex (theCall.myBomEnt (), thePer));
}
d429 20
a448 20
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitOSRealArg & usageRate)
{
double * consRateCVec;

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
myMsgFac () (
"getVecAttrAsScalMsg",
apiFuncName (),
"BOM entry",
"usageRate",
"consRate");

witGetBomEntryConsRate (
consumingOperationName,
bomEntryIndex,
& consRateCVec);
d450 1
a450 1
forbidNullArg (usageRate, "usageRate");
d452 1
a452 1
usageRate = consRateCVec[0];
d454 2
a455 2
free (consRateCVec);
}
d460 9
a468 9
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitOSRealArg & usageTime)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

if (not wit34Compatible ())
myMsgFac () ("getting34AttributeWithoutCompatibilityUsageTime",
apiFuncName ());
d470 1
a470 1
myMsgFac () ("getting34AttributeWithCompatibilityUsageTime", apiFuncName ());
d472 2
a473 2
apiGet (usageTime, "usageTime", theCall.myBomEnt ()->usageTime34 ());
}
d478 5
a482 5
const char * consumingOperationName,
int          bomEntryIndex,
void *       appData)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d484 2
a485 2
theCall.setAppData (appData);
}
d490 21
a510 21
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitIVRealArg & consRate)
{
WitPeriod thePer;

WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

theCall.prepDblVec ("consRate", consRate);

if (theCall.argsOK ())
theCall.myBomEnt ()->setConsRate (consRate);

forEachPeriod (thePer, myProblem ())
if (consRate[thePer] < 0.0)
myMsgFac () ("negConsRateMsg",
bomEntryIndex,
consumingOperationName,
consRate[thePer],
thePer);
}
d515 5
a519 5
const char * consumingOperationName,
int          bomEntryIndex,
int          earliestPeriod)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d521 2
a522 2
theCall.setEarliestPeriod (earliestPeriod);
}
d527 14
a540 14
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitISRealArg & execPenalty)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

theCall.prepNonNegDouble (
"execPenalty",
theCall.myBomEnt ()->execPenalty (),
execPenalty);

if (theCall.argsOK ())
theCall.myBomEnt ()->setExecPenalty (execPenalty);
}
d545 18
a562 18
const char * consumingOperationName,
int          bomEntryIndex,
int          fallout)
{
myApiMgr_->startInnerFunc ();

myMsgFac () (
"setPre50AttrMsg",
apiFuncName (),
"bomEntry",
"fallout",
"falloutRate");

witSetBomEntryFalloutRate (
consumingOperationName,
bomEntryIndex,
percentToFrac (fallout));
}
d567 16
a582 16
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitISRealArg & falloutRate)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

theCall.prepNonNegUBDouble (
"falloutRate",
theCall.myBomEnt ()->falloutRate (),
falloutRate,
0.99 + FLOAT_EPSILON,
0.99);

if (theCall.argsOK ())
theCall.myBomEnt ()->setFalloutRate (falloutRate);
}
d587 5
a591 5
const char * consumingOperationName,
int          bomEntryIndex,
int          latestPeriod)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d593 2
a594 2
theCall.setLatestPeriod (latestPeriod);
}
d599 11
a609 11
const char * consumingOperationName,
int          bomEntryIndex,
WitBoolean   mandEC)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

theCall.prepBool ("mandEC", theCall.myBomEnt ()->mandEC (), mandEC);

if (theCall.argsOK ())
theCall.myBomEnt ()->setMandEC (asaBool (mandEC));
}
d614 5
a618 5
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitIVRealArg & offset)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d620 2
a621 2
theCall.setOffset (offset);
}
d626 22
a647 22
const char * consumingOperationName,
int          bomEntryIndex,
WitBoolean   propRouting)
{
WitTVec <WitBoolean> & propRtgVec = myApiMgr ()->reserveTempBooleanVec ();

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
myMsgFac () (
"setVecAttrToScalMsg",
apiFuncName (),
"BOM entry",
"propRouting",
"propRtg");

propRtgVec = propRouting;

witSetBomEntryPropRtg (
consumingOperationName,
bomEntryIndex,
propRtgVec.myCVec ());
d649 2
a650 2
myApiMgr ()->releaseTempVecs ();
}
d655 11
a665 11
const char *       consumingOperationName,
int                bomEntryIndex,
const WitBoolean * propRtg)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

theCall.prepBoolVec ("propRtg", propRtg);

if (theCall.argsOK ())
theCall.myBomEnt ()->setPropRtg (propRtg);
}
d670 5
a674 5
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitIVRealArg & routingShare)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d676 2
a677 2
theCall.setRoutingShare (routingShare);
}
d682 5
a686 5
const char * consumingOperationName,
int          bomEntryIndex,
int          selForDel)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d688 2
a689 2
theCall.setSelForDel (selForDel);
}
d694 14
a707 14
const char * consumingOperationName,
int          bomEntryIndex,
WitBoolean   singleSource)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

theCall.prepBool (
"singleSource",
theCall.myBomEnt ()->singleSource (),
singleSource);

if (theCall.argsOK ())
theCall.myBomEnt ()->setSingleSource (asaBool (singleSource));
}
d712 22
a733 22
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitISRealArg & usageRate)
{
WitTVec <double> & consRateVec = myApiMgr ()->reserveTempDblVec ();

myApiMgr_->startInnerFunc ();

if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
myMsgFac () (
"setVecAttrToScalMsg",
apiFuncName (),
"BOM entry",
"usageRate",
"consRate");

consRateVec = usageRate;

witSetBomEntryConsRate (
consumingOperationName,
bomEntryIndex,
consRateVec.myCVec ());
d735 2
a736 2
myApiMgr ()->releaseTempVecs ();
}
d741 20
a760 20
const char *         consumingOperationName,
int                  bomEntryIndex,
const WitISRealArg & inpVal)
{
WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

if (not wit34Compatible ())
myMsgFac () ("setting34AttributeWithoutCompatibilityUsageTime",
apiFuncName () );

myMsgFac () ("setting34AttributeWithCompatibilityUsageTime", apiFuncName ());

theCall.prepDouble (
"usageTime",
theCall.myBomEnt ()->usageTime34 (),
inpVal);

if (theCall.argsOK ())
theCall.myBomEnt ()->setUsageTime34 (inpVal);
}
d768 5
a772 5
const char * consumingOperationName,
int          bomEntryIndex)
{
WitBomEntry *  retVal;
WitOperation * theOpn;
d774 1
a774 1
theOpn = getOperationP (consumingOperationName);
d776 1
a776 1
myInputID ()->setMyOperation (theOpn);
d778 2
a779 2
if (theOpn->bom ().isEmpty ())
myMsgFac () ("emptyBom");
d781 5
a785 5
if (bomEntryIndex < 0 or bomEntryIndex >= theOpn->bom ().nElements ())
myMsgFac () ("bomEntryIndexRangeSmsg",
bomEntryIndex,
0,
theOpn->bom ().nElements ());
d787 1
a787 1
retVal = myCompMgr ()->findBomEntry (theOpn, bomEntryIndex);
d789 1
a789 1
witAssert (retVal != NULL);
d791 1
a791 1
myInputID ()->setMyBomEntry (retVal);
d793 2
a794 2
return retVal;
}
@


1.76
log
@Heuristic Adjustment
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d42 4
a45 4
      const char * operationName,
      int          bomEntryIndex)
   {
   forbidNullArg (operationName, "operationName");
d47 2
a48 2
   if (myMsgFac ().mayIssue ("operationNameMsg"))
      myMsgFac () ("operationNameMsg", operationName );
d50 2
a51 2
   if (myMsgFac ().mayIssue ("bomEntryIndexMsg"))
      myMsgFac () ("bomEntryIndexMsg", bomEntryIndex);
d53 2
a54 2
   return getBomEntryP (operationName, bomEntryIndex);
   }
d59 5
a63 5
      const char * consumingOperationName,
      const char * consumedPartName)
   {
   WitOperation * theOpn;
   WitPart *      thePart;
d65 1
a65 1
   myApiMgr_->startInnerFunc ();
d67 2
a68 2
   forbidNullArg (consumingOperationName, "consumingOperationName");
   forbidNullArg (consumedPartName,       "consumedPartName");
d70 4
a73 4
   if (myMsgFac ().mayIssue ("addBomEntryMsg"))
      myMsgFac () ("addBomEntryMsg",
         consumingOperationName,
         consumedPartName);
d75 1
a75 1
   theOpn = myCompMgr ()->findOperation (consumingOperationName);
d77 2
a78 2
   if (theOpn == NULL)
      myMsgFac () ("undefinedOperationMsg", consumingOperationName);
d80 1
a80 1
   myInputID ()->setMyOperation (theOpn);
d82 1
a82 1
   thePart = myCompMgr ()->findPart (consumedPartName);
d84 2
a85 2
   if (thePart == NULL)
      myMsgFac () ("undefinedPartMsg", consumedPartName);
d87 1
a87 1
   addingDelComp ("bomEntryFrag");
d89 1
a89 1
   new WitBomEntry (theOpn, thePart);
d91 2
a92 2
   myInputID ()->setMyOperation (NULL);
   }
d97 25
a121 25
      const char * dupOperationName,
      int          dupBomEntryIndex,
      WitRun *     origWitRun,
      const char * origOperationName,
      int          origBomEntryIndex)
   {
   startCopyObjData (origWitRun);

   myMsgFac ()  ("dupObjectMsg", myMsgFac ().myFrag ("bomEntryFrag"));

   WitBomEntryApiCall dupCall  (
      this,
      dupOperationName,
      dupBomEntryIndex);

   myMsgFac () ("origObjectMsg", myMsgFac ().myFrag ("bomEntryFrag"));

   WitBomEntryApiCall origCall  (
      origWitRun,
      origOperationName,
      origBomEntryIndex);

   if (dupCall.myBomEnt () == origCall.myBomEnt ())
      myMsgFac () ("copyObjectToSelfSmsg",
         myMsgFac ().myFrag ("bomEntryFrag"));
d123 2
a124 2
   dupCall.myBomEnt ()->copyAttrsFrom (origCall.myBomEnt ());
   }
d129 17
a145 17
      char * * consumingOperationName,
      int *    bomEntryIndex)
   {
   WitBomEntry * theBomEnt;

   myApiMgr_->startInnerFunc ();

   theBomEnt =
      curItrDelCompForGet (WitAT_BOM_ENTRY, "bomEntryFrag")->
         thisBomEnt ();

   stronglyAssert (theBomEnt != NULL);

   apiGet (
      consumingOperationName, 
      "consumingOperationName", 
      theBomEnt->myOperationName ());
d147 2
a148 2
   apiGet (bomEntryIndex, "bomEntryIndex", theBomEnt->localIndex ());
   }
d153 5
a157 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      void * *     appData)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d159 2
a160 2
   apiGet (appData, "appData", theCall.myBomEnt ()->appData ());
   }
d165 5
a169 5
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOVRealArg & consRate)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d171 2
a172 2
   apiGet (consRate, "consRate", theCall.myBomEnt ()->consRate ());
   }
d177 11
a187 11
      const char * consumingOperationName,
      int          bomEntryIndex,
      char * *     consumedPartName)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (
       consumedPartName, 
      "consumedPartName", 
      theCall.myBomEnt ()->myPartName ());
   }
d192 10
a201 10
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        earliestPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (                earliestPeriod, 
                          "earliestPeriod", 
      theCall.myBomEnt ()->earliestPeriod ());
   }
d206 5
a210 5
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOSRealArg & execPenalty)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d212 2
a213 2
   apiGet (execPenalty, "execPenalty", theCall.myBomEnt ()->execPenalty ());
   }
d218 19
a236 19
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        fallout )
   {
   double theFalloutRate;

   myApiMgr_->startInnerFunc ();

   myMsgFac () (
      "getPre50AttrMsg",
      apiFuncName (),
      "bomEntry",
      "fallout",
      "falloutRate");

   witGetBomEntryFalloutRate (
      consumingOperationName,
      bomEntryIndex,
      & theFalloutRate);
d238 2
a239 2
   apiGet (fallout, "fallout", fracToPercent (theFalloutRate));
   }
d244 5
a248 5
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOSRealArg & falloutRate)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d250 2
a251 2
   apiGet (falloutRate, "falloutRate", theCall.myBomEnt ()->falloutRate ());
   }
d256 5
a260 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      int **       impactPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d262 1
a262 1
   myProblem ()->myPreprocessor ()->preprocess ();
d264 2
a265 2
   apiGet (impactPeriod, "impactPeriod", theCall.myBomEnt ()->impactPeriod ());
   }
d270 5
a274 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        latestPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d276 2
a277 2
   apiGet (latestPeriod, "latestPeriod", theCall.myBomEnt ()->latestPeriod ());
   }
d282 5
a286 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean * mandEC)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d288 2
a289 2
   apiGet (mandEC, "mandEC", theCall.myBomEnt ()->mandEC ());
   }
d294 11
a304 11
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        nSubsBomEntries)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (
       nSubsBomEntries,
      "nSubsBomEntries",
      theCall.myBomEnt ()->mySubEntries ().nElements ());
   }
d309 16
a324 16
      const char * consumingOperationName,
      int          bomEntryIndex,
      const int    thePer,
      int *        nonSubVarIndex)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   prepGetIndex (thePer);

   apiGet (
       nonSubVarIndex,
      "nonSubVarIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            nonSubVarIndex (theCall.myBomEnt (), thePer));
   }
d329 5
a333 5
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOVRealArg & offset)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d335 2
a336 2
   apiGet (offset, "offset", theCall.myBomEnt ()->offset ());
   }
d341 13
a353 13
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean * propRouting)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "BOM entry",
         "propRouting",
         "propRtg");
d355 2
a356 2
   apiGet (propRouting, "propRouting", theCall.myBomEnt ()->propRtg ()[0]);
   }
d361 5
a365 5
      const char *   consumingOperationName,
      int            bomEntryIndex,
      WitBoolean * * propRtg)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d367 2
a368 2
   apiGet (propRtg, "propRtg", theCall.myBomEnt ()->propRtg ());
   }
d373 5
a377 5
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOVRealArg & routingShare)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d379 2
a380 2
   apiGet (routingShare, "routingShare", theCall.myBomEnt ()->routingShare ());
   }
d385 5
a389 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      int *        selForDel)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d391 2
a392 2
   apiGet (selForDel, "selForDel", theCall.myBomEnt ()->selForDel ());
   }
d397 5
a401 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean * singleSource)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d403 2
a404 2
   apiGet (singleSource, "singleSource", theCall.myBomEnt ()->singleSource ());
   }
d409 16
a424 16
      const char * consumingOperationName,
      int          bomEntryIndex,
      const int    thePer,
      int *        subConIndex)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   prepGetIndex (thePer);

   apiGet (
       subConIndex,
      "subConIndex",
      myDetOptImpMgr ()->
         myExtOptMgr ()->
            subConIndex (theCall.myBomEnt (), thePer));
   }
d429 20
a448 20
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOSRealArg & usageRate)
   {
   double * consRateCVec;

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("getVecAttrAsScalMsg"))
      myMsgFac () (
         "getVecAttrAsScalMsg",
         apiFuncName (),
         "BOM entry",
         "usageRate",
         "consRate");

   witGetBomEntryConsRate (
      consumingOperationName, 
      bomEntryIndex, 
      & consRateCVec);
d450 1
a450 1
   forbidNullArg (usageRate, "usageRate");
d452 1
a452 1
   usageRate = consRateCVec[0];
d454 2
a455 2
   free (consRateCVec);
   }
d460 9
a468 9
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitOSRealArg & usageTime)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   if (not wit34Compatible ())
      myMsgFac () ("getting34AttributeWithoutCompatibilityUsageTime",
         apiFuncName ());
d470 1
a470 1
   myMsgFac () ("getting34AttributeWithCompatibilityUsageTime", apiFuncName ());
d472 2
a473 2
   apiGet (usageTime, "usageTime", theCall.myBomEnt ()->usageTime34 ());
   }
d478 5
a482 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      void *       appData)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d484 2
a485 2
   theCall.setAppData (appData);
   }
d490 21
a510 21
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitIVRealArg & consRate)
   {
   WitPeriod thePer;

   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepDblVec ("consRate", consRate);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setConsRate (consRate);

   forEachPeriod (thePer, myProblem ())
      if (consRate[thePer] < 0.0)
         myMsgFac () ("negConsRateMsg",
            bomEntryIndex,
            consumingOperationName,
            consRate[thePer],
            thePer);
   }
d515 5
a519 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          earliestPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d521 2
a522 2
   theCall.setEarliestPeriod (earliestPeriod);
   }
d527 14
a540 14
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitISRealArg & execPenalty)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepNonNegDouble (
      "execPenalty", 
      theCall.myBomEnt ()->execPenalty (),
      execPenalty);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setExecPenalty (execPenalty);
   }
d545 18
a562 18
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          fallout)
   {
   myApiMgr_->startInnerFunc ();

   myMsgFac () (
      "setPre50AttrMsg",
      apiFuncName (),
      "bomEntry",
      "fallout",
      "falloutRate");

   witSetBomEntryFalloutRate (
      consumingOperationName,
      bomEntryIndex,
      percentToFrac (fallout));
   }
d567 16
a582 16
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitISRealArg & falloutRate)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepNonNegUBDouble (
      "falloutRate", 
      theCall.myBomEnt ()->falloutRate (), 
      falloutRate,
      0.99 + FLOAT_EPSILON,
      0.99);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setFalloutRate (falloutRate);
   }
d587 5
a591 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          latestPeriod)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d593 2
a594 2
   theCall.setLatestPeriod (latestPeriod);
   }
d599 11
a609 11
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean   mandEC)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepBool ("mandEC", theCall.myBomEnt ()->mandEC (), mandEC);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setMandEC (asaBool (mandEC));
   }
d614 5
a618 5
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitIVRealArg & offset)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d620 2
a621 2
   theCall.setOffset (offset);
   }
d626 22
a647 22
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean   propRouting)
   {
   WitTVec <WitBoolean> & propRtgVec = myApiMgr ()->reserveTempBooleanVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "BOM entry",
         "propRouting",
         "propRtg");

   propRtgVec = propRouting;

   witSetBomEntryPropRtg (
      consumingOperationName,
      bomEntryIndex,
      propRtgVec.myCVec ());
d649 2
a650 2
   myApiMgr ()->releaseTempVecs ();
   }
d655 11
a665 11
      const char *       consumingOperationName,
      int                bomEntryIndex,
      const WitBoolean * propRtg)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepBoolVec ("propRtg", propRtg);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setPropRtg (propRtg);
   }
d670 5
a674 5
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitIVRealArg & routingShare)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d676 2
a677 2
   theCall.setRoutingShare (routingShare);
   }
d682 5
a686 5
      const char * consumingOperationName,
      int          bomEntryIndex,
      int          selForDel)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d688 2
a689 2
   theCall.setSelForDel (selForDel);
   }
d694 14
a707 14
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitBoolean   singleSource)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepBool (
                          "singleSource", 
      theCall.myBomEnt ()->singleSource (), 
                           singleSource);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setSingleSource (asaBool (singleSource));
   }
d712 22
a733 22
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitISRealArg & usageRate)
   {
   WitTVec <double> & consRateVec = myApiMgr ()->reserveTempDblVec ();

   myApiMgr_->startInnerFunc ();

   if (myMsgFac ().mayIssue ("setVecAttrToScalMsg"))
      myMsgFac () (
         "setVecAttrToScalMsg",
         apiFuncName (),
         "BOM entry",
         "usageRate",
         "consRate");

   consRateVec = usageRate;

   witSetBomEntryConsRate (
      consumingOperationName,
      bomEntryIndex,
      consRateVec.myCVec ());
d735 2
a736 2
   myApiMgr ()->releaseTempVecs ();
   }
d741 20
a760 20
      const char *         consumingOperationName,
      int                  bomEntryIndex,
      const WitISRealArg & inpVal)
   {
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   if (not wit34Compatible ())
      myMsgFac () ("setting34AttributeWithoutCompatibilityUsageTime",
         apiFuncName () );

   myMsgFac () ("setting34AttributeWithCompatibilityUsageTime", apiFuncName ());

   theCall.prepDouble (
      "usageTime",
      theCall.myBomEnt ()->usageTime34 (),
      inpVal);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setUsageTime34 (inpVal);
   }
d768 5
a772 5
      const char * consumingOperationName,
      int          bomEntryIndex)
   {
   WitBomEntry *  retVal;
   WitOperation * theOpn;
d774 1
a774 1
   theOpn = getOperationP (consumingOperationName);
d776 1
a776 1
   myInputID ()->setMyOperation (theOpn);
d778 2
a779 2
   if (theOpn->bom ().isEmpty ())
      myMsgFac () ("emptyBom");
d781 5
a785 5
   if (bomEntryIndex < 0 or bomEntryIndex >= theOpn->bom ().nElements ())
      myMsgFac () ("bomEntryIndexRangeSmsg",
         bomEntryIndex,
         0,
         theOpn->bom ().nElements ());
d787 1
a787 1
   retVal = myCompMgr ()->findBomEntry (theOpn, bomEntryIndex);
d789 1
a789 1
   witAssert (retVal != NULL);
d791 1
a791 1
   myInputID ()->setMyBomEntry (retVal);
d793 2
a794 2
   return retVal;
   }
@


1.75
log
@Multi-Obj Mode
@
text
@d28 1
a28 1
#include <Opn.h>
@


1.74
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d573 9
a581 1
   theCall.setFalloutRate (falloutRate);
@


1.73
log
@Alterations to allow compilation with the GCC 4.3.2 compiler.
@
text
@d30 1
a30 1
#include <Global.h>
@


1.72
log
@Stochastic Implosion
@
text
@d34 2
@


1.71
log
@Stochastic Implosion.
@
text
@d25 1
a25 1
#include <OptImp.h>
d319 1
a319 1
      myOptImploder ()->
d419 1
a419 1
      myOptImploder ()->
@


1.70
log
@Stochastic implosion.
@
text
@d85 2
@


1.69
log
@Stochastic implosion.
@
text
@a84 2
   forbidAddStochAct ("bomEntryFrag");

@


1.68
log
@witCopy<Object>Data
@
text
@d85 2
@


1.67
log
@witCopy<Object>Data
@
text
@d93 1
a93 1
      const char * dupConsumingOperationName,
d96 1
a96 1
      const char * origConsumingOperationName,
d105 1
a105 1
      dupConsumingOperationName,
d112 1
a112 1
      origConsumingOperationName,
@


1.66
log
@witCopy<Object>Data
@
text
@d111 1
a111 1
      this,
@


1.65
log
@witCopy<Object>Data
@
text
@d101 1
a101 1
   myMsgFac () ( "dupObjectMsg", myMsgFac ().myFrag ("bomEntryFrag"));
@


1.64
log
@External opt implosion.
@
text
@d31 1
d92 32
@


1.63
log
@External opt implosion.
@
text
@d26 1
a26 1
#include <ExtOptHand.h>
d285 1
a285 1
         myExtOptHandler ()->
d385 1
a385 1
         myExtOptHandler ()->
@


1.62
log
@External opt implosion.
@
text
@d275 1
a275 1
      int *        colIndex)
d282 2
a283 2
       colIndex,
      "colIndex",
d375 1
a375 1
      int *        rowIndex)
d382 2
a383 2
       rowIndex,
      "rowIndex",
@


1.61
log
@External opt implosion.
@
text
@d279 1
a279 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
d379 1
a379 5
   if (not DEVELOPMENT)
      myMsgFac () ("funcNotAvailSmsg", apiFuncName ());

   if (not myOptImploder ()->extOptActive ())
      myMsgFac () ("extOptInactiveSmsg", apiFuncName ());
@


1.60
log
@External opt implosion.
@
text
@d25 2
d271 24
d375 24
@


1.59
log
@App controlled opt implosion.
@
text
@d60 2
d95 2
d98 2
a99 1
      curItrDelCompForGet (WitAT_BOM_ENTRY, "bomEntryFrag")->thisBomEnt ();
d185 2
d356 2
d470 2
d545 2
d631 2
@


1.58
log
@App controlled opt implosion.
@
text
@d24 1
d216 1
a216 1
   myProblem ()->preprocess ();
@


1.57
log
@App controlled opt implosion.
@
text
@a55 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a89 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a111 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a123 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a135 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a150 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a164 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a176 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a200 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a212 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a226 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a238 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a250 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a265 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a277 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a297 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a309 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a321 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a333 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a345 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a374 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a392 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a404 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a429 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a441 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a459 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a479 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a491 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a503 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a518 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a530 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a557 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a572 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a584 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a596 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a614 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

a641 4
   startInnerApiFunc (
      WitInitState  ::postInit,
      WitOptImpState::any);

@


1.56
log
@Updated the copyright date on all source files.
@
text
@d56 4
d94 4
d120 4
d136 4
d152 4
d171 4
d189 4
d205 4
d233 4
d249 4
d267 4
d283 4
d299 4
d318 4
d334 4
d358 4
d374 4
d390 4
d406 4
d422 4
d455 4
d477 4
d493 4
d522 4
d538 4
d560 4
d584 4
d600 4
d616 4
d635 4
d651 4
d682 4
d701 4
d717 4
d733 4
d755 4
d786 4
@


1.55
log
@Removed code supporting the variable-argument-list API functions.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.54
log
@[multi-thread]
@
text
@a85 76
void WitRun::witAddBomEntryVa (
      const char * consumingOperationName,
      const char * consumedPartName,
      va_list      argp)
   {
   int     theBomEntIdx;
   WitAttr theAttr;

   witAddBomEntry (consumingOperationName, consumedPartName);

   if (argp == NULL)
      return;

   theBomEntIdx =
      myCompMgr ()->
         findOperation (consumingOperationName)->
            bom ().
               nElements () - 1;

   //--------------------------------------------------
   // Loop once for each attribute in calling sequence.
   //--------------------------------------------------

   for (theAttr  = va_arg (argp, WitAttr);
        theAttr != NULL;
        theAttr  = va_arg (argp, WitAttr))
      {
      if (theAttr == WitNusageTime)
         witSetBomEntryUsageTime (
            consumingOperationName,
            theBomEntIdx,
            va_arg (argp, double));

      else if (theAttr == WitNusageRate)
         witSetBomEntryUsageRate (
            consumingOperationName,
            theBomEntIdx,
            va_arg (argp, double));

      else if (theAttr == WitNfallout)
         witSetBomEntryFallout (
            consumingOperationName,
            theBomEntIdx,
            va_arg (argp, int));

      else if (theAttr == WitNearliestPeriod)
         witSetBomEntryEarliestPeriod (
            consumingOperationName,
            theBomEntIdx,
            va_arg (argp, int));

      else if (theAttr == WitNlatestPeriod)
         witSetBomEntryLatestPeriod (
            consumingOperationName,
            theBomEntIdx,
            va_arg (argp, int));

      else if (theAttr == WitNmandEC)
         witSetBomEntryMandEC (
            consumingOperationName,
            theBomEntIdx,
            va_arg (argp, WitBoolean));

      else if (theAttr == WitNoffset)
         witSetBomEntryOffset (
            consumingOperationName,
            theBomEntIdx,
            va_arg (argp, float *));

      else
         myMsgFac () ("undefinedAttrErrorMsg");
      }
   }

//------------------------------------------------------------------------------

@


1.53
log
@[multi-thread]
@
text
@a29 2
#include <stdarg.h>

@


1.52
log
@[multi-thread]
@
text
@d55 2
a56 2
      const char * consumingOperation,
      const char * consumedPartNameParm)
d58 26
a83 1
   witAddBomEntryVa (consumingOperation, consumedPartNameParm, NULL);
d89 2
a90 2
      const char * consumingOperation,
      const char * consumedPartNameParm,
d93 4
a96 4
   WitAttr        attr;
   WitPart *      consumedP;
   WitOperation * operationP ;
   WitBomEntry *  newBomEntry;
d98 2
a99 2
   forbidNullArg (consumingOperation, "consumingOperation");
   forbidNullArg (consumedPartNameParm, "consumedPartName");
d101 5
a105 4
   if (myMsgFac ().mayIssue ("addBomEntryMsg"))
      myMsgFac () ("addBomEntryMsg",
         consumingOperation,
         consumedPartNameParm);
d107 3
a109 1
   operationP = myCompMgr ()->findOperation (consumingOperation);
d111 9
a119 2
   if (operationP == NULL)
      myMsgFac () ("undefinedOperationMsg", consumingOperation);
d121 5
a125 1
   myInputID ()->setMyOperation (operationP);
d127 5
a131 1
   consumedP = myCompMgr ()->findPart (consumedPartNameParm);
d133 5
a137 2
   if (consumedP == NULL)
      myMsgFac () ("undefinedPartMsg", consumedPartNameParm);
d139 5
a143 1
   newBomEntry = new WitBomEntry (operationP, consumedP);
d145 5
a149 3
   //--------------------------------------------------
   // Loop once for each attribute in calling sequence.
   //--------------------------------------------------
d151 5
a155 52
   if (argp != NULL)
      for (attr  = va_arg (argp, WitAttr);
           attr != NULL;
           attr  = va_arg (argp, WitAttr))
         if (attr == WitNusageTime)
            witSetBomEntryUsageTime (
               operationP->operationName ().myCstring (),
               operationP->bom ().nElements () - 1,
               va_arg (argp, double));

         else if (attr == WitNusageRate)
            witSetBomEntryUsageRate (
               newBomEntry->myOperationName ().myCstring (),
               newBomEntry->localIndex (),
               va_arg (argp, double));

         else if (attr == WitNfallout)
            witSetBomEntryFallout (
               newBomEntry->myOperationName ().myCstring (),
               newBomEntry->localIndex (),
               va_arg (argp, int));

         else if (attr == WitNearliestPeriod)
            witSetBomEntryEarliestPeriod (
               newBomEntry->myOperationName ().myCstring (),
               newBomEntry->localIndex (),
               va_arg (argp, int));

         else if (attr == WitNlatestPeriod)
            witSetBomEntryLatestPeriod (
               newBomEntry->myOperationName ().myCstring (),
               newBomEntry->localIndex (),
               va_arg (argp, int));

         else if (attr == WitNmandEC)
            witSetBomEntryMandEC (
               newBomEntry->myOperationName ().myCstring (),
               newBomEntry->localIndex (),
               va_arg (argp, WitBoolean));

         else if (attr == WitNoffset)
            witSetBomEntryOffset (
               newBomEntry->myOperationName ().myCstring (),
               newBomEntry->localIndex (),
               va_arg (argp, float *));

         else
            myMsgFac () ("undefinedAttrErrorMsg");

   //------------
   // End of Loop
   //------------
d157 3
a159 2
   myInputID ()->setMyOperation (NULL);
   myInputID ()->setMyBomEntry  (NULL);
d742 3
a744 3
WitBomEntry * WitRun::getBomEntryP(
      const char *  consumingOperationName,
      int           bomEntryIndex)
@


1.51
log
@[multi-thread]:
   Moved PROLOG/EPILOG responsibility from the inner layer of the API
   to the outer layer.
@
text
@d30 2
@


1.50
log
@[multi-threads]
@
text
@a16 1
#include <ProEpilog.h>
d52 1
a52 1
WitReturnCode WitRun::witAddBomEntry (
a55 6
   PROLOG("witAddBomEntry");

   if (myApiMgr ()->calledByApp ())
      if (myMsgFac ().mayIssue ("parmsAbiMsg"))
         myMsgFac () ("parmsAbiMsg", consumingOperation, consumedPartNameParm);

a56 2

   EPILOG;
d61 1
a61 1
WitReturnCode WitRun::witAddBomEntryVa (
a70 2
   PROLOG ("witAddBomEntryVa");

d74 4
a77 3
   if (myApiMgr ()->calledByApp ())
      if (myMsgFac ().mayIssue ("parmsAbiMsg"))
         myMsgFac () ("parmsAbiMsg", consumingOperation, consumedPartNameParm);
a151 2

   EPILOG;
d156 1
a156 1
WitReturnCode WitRun::witGetObjItrBomEntry (
a161 2
   PROLOG ("witGetObjItrBomEntry");

a172 2

   EPILOG;
d177 1
a177 1
WitReturnCode WitRun::witGetBomEntryAppData (
a181 2
   PROLOG ("witGetBomEntryAppData");

a184 2

   EPILOG;
d189 1
a189 1
WitReturnCode WitRun::witGetBomEntryConsRate (
a193 2
   PROLOG ("witGetBomEntryConsRate");

a196 2

   EPILOG;
d201 1
a201 1
WitReturnCode WitRun::witGetBomEntryConsumedPart(
a205 2
   PROLOG ("witGetBomEntryConsumedPart");

a211 2

   EPILOG;
d216 1
a216 1
WitReturnCode WitRun::witGetBomEntryEarliestPeriod (
a220 2
   PROLOG ("witGetBomEntryEarliestPeriod");

a225 2

   EPILOG;
d230 1
a230 1
WitReturnCode WitRun::witGetBomEntryExecPenalty (
a234 2
   PROLOG ("witGetBomEntryExecPenalty");

a237 2

   EPILOG;
d242 1
a242 1
WitReturnCode WitRun::witGetBomEntryFallout (
a246 2
   PROLOG ("witGetBomEntryFallout");

a261 2

   EPILOG;
d266 1
a266 1
WitReturnCode WitRun::witGetBomEntryFalloutRate (
a270 2
   PROLOG ("witGetBomEntryFalloutRate");

a273 2

   EPILOG;
d278 1
a278 1
WitReturnCode WitRun::witGetBomEntryImpactPeriod (
a282 2
   PROLOG ("witGetBomEntryImpactPeriod");

a287 2

   EPILOG;
d292 1
a292 1
WitReturnCode WitRun::witGetBomEntryLatestPeriod (
a296 2
   PROLOG ("witGetBomEntryLatestPeriod");

a299 2

   EPILOG;
d304 1
a304 1
WitReturnCode WitRun::witGetBomEntryMandEC (
a308 2
   PROLOG ("witGetBomEntryMandEC");

a311 2

   EPILOG;
d316 1
a316 1
WitReturnCode WitRun::witGetBomEntryNSubsBomEntries (
a320 2
   PROLOG ("witGetBomEntryNSubsBomEntries");

a326 2

   EPILOG;
d331 1
a331 1
WitReturnCode WitRun::witGetBomEntryOffset (
a335 2
   PROLOG ("witGetBomEntryOffset");

a338 2

   EPILOG;
d343 1
a343 1
WitReturnCode WitRun::witGetBomEntryPropRouting (
a347 2
   PROLOG ("witGetBomEntryPropRouting");

a358 2

   EPILOG;
d363 1
a363 1
WitReturnCode WitRun::witGetBomEntryPropRtg (
a367 2
   PROLOG ("witGetBomEntryPropRtg");

a370 2

   EPILOG;
d375 1
a375 1
WitReturnCode WitRun::witGetBomEntryRoutingShare (
a379 2
   PROLOG ("witGetBomEntryRoutingShare");

a382 2

   EPILOG;
d387 1
a387 1
WitReturnCode WitRun::witGetBomEntrySelForDel (
a391 2
   PROLOG ("witGetBomEntrySelForDel");

a394 2

   EPILOG;
d399 1
a399 1
WitReturnCode WitRun::witGetBomEntrySingleSource (
a403 2
   PROLOG ("witGetBomEntrySingleSource");

a406 2

   EPILOG;
d411 1
a411 1
WitReturnCode WitRun::witGetBomEntryUsageRate (
a415 2
   PROLOG ("witGetBomEntryUsageRate");

a435 2

   EPILOG;
d440 1
a440 1
WitReturnCode WitRun::witGetBomEntryUsageTime (
a444 2
   PROLOG ("witGetBomEntryUsageTime");

a453 2

   EPILOG;
d458 1
a458 1
WitReturnCode WitRun::witSetBomEntryAppData (
a462 2
   PROLOG ("witSetBomEntryAppData");

a465 2

   EPILOG;
d470 1
a470 1
WitReturnCode WitRun::witSetBomEntryConsRate (
a474 2
   PROLOG ("witSetBomEntryConsRate");

a490 2

   EPILOG;
d495 1
a495 1
WitReturnCode WitRun::witSetBomEntryEarliestPeriod (
a499 2
   PROLOG ("witSetBomEntryEarliestPeriod");

a502 2

   EPILOG;
d507 1
a507 1
WitReturnCode WitRun::witSetBomEntryExecPenalty (
a511 2
   PROLOG ("witSetBomEntryExecPenalty");

a520 2

   EPILOG;
d525 1
a525 1
WitReturnCode WitRun::witSetBomEntryFallout (
a529 2
   PROLOG ("witSetBomEntryFallout");

a540 2

   EPILOG;
d545 1
a545 1
WitReturnCode WitRun::witSetBomEntryFalloutRate (
a549 2
   PROLOG ("witSetBomEntryFalloutRate");

a552 2

   EPILOG;
d557 1
a557 1
WitReturnCode WitRun::witSetBomEntryLatestPeriod (
a561 2
   PROLOG ("witSetBomEntryLatestPeriod");

a564 2

   EPILOG;
d569 1
a569 1
WitReturnCode WitRun::witSetBomEntryMandEC (
a573 2
   PROLOG ("witSetBomEntryMandEC");

a579 2

   EPILOG;
d584 1
a584 1
WitReturnCode WitRun::witSetBomEntryOffset (
a588 2
   PROLOG ("witSetBomEntryOffset");

a591 2

   EPILOG;
d596 1
a596 1
WitReturnCode WitRun::witSetBomEntryPropRouting (
a600 2
   PROLOG ("witSetBomEntryPropRouting");

a618 2

   EPILOG;
d623 1
a623 1
WitReturnCode WitRun::witSetBomEntryPropRtg (
a627 2
   PROLOG ("witSetBomEntryPropRtg");

a633 2

   EPILOG;
d638 1
a638 1
WitReturnCode WitRun::witSetBomEntryRoutingShare (
a642 2
   PROLOG ("witSetBomEntryRoutingShare");

a645 2

   EPILOG;
d650 1
a650 1
WitReturnCode WitRun::witSetBomEntrySelForDel (
a654 2
   PROLOG ("witSetBomEntrySelForDel");

a657 2

   EPILOG;
d662 1
a662 1
WitReturnCode WitRun::witSetBomEntrySingleSource (
a666 2
   PROLOG ("witSetBomEntrySingleSource");

a675 2

   EPILOG;
d680 1
a680 1
WitReturnCode WitRun::witSetBomEntryUsageRate (
a684 2
   PROLOG ("witSetBomEntryUsageRate");

a702 2

   EPILOG;
d707 1
a707 1
WitReturnCode WitRun::witSetBomEntryUsageTime (
a711 2
   PROLOG ("witSetBomEntryUsageTime");

a726 2

   EPILOG;
@


1.49
log
@[exceptions]
@
text
@d59 1
a59 1
   if (myApiMgr ()->applicationCalled ())
d85 1
a85 1
   if (myApiMgr ()->applicationCalled ())
@


1.48
log
@Vector PropRtg.
@
text
@d17 1
d19 1
d94 1
a94 1
   myInputId ()->setMyOperation (operationP);
d160 2
a161 2
   myInputId ()->setMyOperation (NULL);
   myInputId ()->setMyBomEntry  (NULL);
d899 1
a899 1
   myInputId ()->setMyOperation (theOpn);
d914 1
a914 1
   myInputId ()->setMyBomEntry (retVal);
@


1.47
log
@Vector PropRtg.
@
text
@d414 8
a437 3
   if (not myGlobalComp ()->allowVecPR ())
      myMsgFac () ("propRtgNYISmsg");

d729 11
a739 1
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d741 4
a744 4
   theCall.prepBool (
                          "propRouting", 
      theCall.myBomEnt ()->propRtg ()[0], 
                           propRouting);
d746 1
a746 2
   if (theCall.argsOK ())
      theCall.myBomEnt ()->setPropRouting (asaBool (propRouting));
a761 3
   if (not myGlobalComp ()->allowVecPR ())
      myMsgFac () ("propRtgNYISmsg");

@


1.46
log
@Vector PropRtg.
@
text
@d495 1
a495 1
   double * consRateVal;
d508 1
a508 1
      & consRateVal);
d512 1
a512 1
   usageRate = consRateVal[0];
d514 1
a514 1
   free (consRateVal);
a750 3
   if (not hasSingleValue (propRtg, nPeriods ()))
      myMsgFac () ("propRtgNonSglSmsg");

d822 1
a822 1
   WitTVec <double> & consRateVal = myApiMgr ()->reserveTempDblVec ();
d832 1
a832 1
   consRateVal = usageRate;
d837 1
a837 1
      consRateVal.myCVec ());
@


1.45
log
@Vector PropRtg.
@
text
@d414 1
a414 1
   apiGet (propRouting, "propRouting", theCall.myBomEnt ()->propRouting ());
d728 1
a728 1
      theCall.myBomEnt ()->propRouting (), 
@


1.44
log
@Vector Prop-Rtg.
@
text
@d421 1
a421 1
WitReturnCode WitRun::witGetBomEntryPropRt (
d424 1
a424 1
      WitBoolean * * propRt)
d426 1
a426 1
   PROLOG ("witGetBomEntryPropRt");
d431 1
a431 1
      myMsgFac () ("propRtNYISmsg");
d433 1
a433 1
   apiGet (propRt, "propRt", theCall.myBomEnt ()->propRt ());
d739 1
a739 1
WitReturnCode WitRun::witSetBomEntryPropRt (
d742 1
a742 1
      const WitBoolean * propRt)
d744 1
a744 1
   PROLOG ("witSetBomEntryPropRt");
d749 1
a749 1
      myMsgFac () ("propRtNYISmsg");
d751 2
a752 2
   if (not hasSingleValue (propRt, nPeriods ()))
      myMsgFac () ("propRtNonSglSmsg");
d754 1
a754 1
   theCall.prepBoolVec ("propRt", propRt);
d757 1
a757 1
      theCall.myBomEnt ()->setPropRt (propRt);
@


1.43
log
@Vector PropRt.
@
text
@d751 3
@


1.42
log
@Vector PropRt.
@
text
@d421 19
d739 22
@


1.41
log
@Minor change.
@
text
@d19 4
a22 4
#include <InScalRA.h>
#include <OutScalRA.h>
#include <InVecRA.h>
#include <OutVecRA.h>
d208 3
a210 3
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      const WitOutVecRA & consRate)
d263 1
a263 1
      const WitOutScalRA & execPenalty)
d307 1
a307 1
      const WitOutScalRA & falloutRate)
d390 3
a392 3
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      const WitOutVecRA & offset)
d422 3
a424 3
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      const WitOutVecRA & routingShare)
d472 1
a472 1
      const WitOutScalRA & usageRate)
d505 1
a505 1
      const WitOutScalRA & usageTime)
d541 3
a543 3
      const char *       consumingOperationName,
      int                bomEntryIndex,
      const WitInVecRA & consRate)
d586 3
a588 3
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      const WitInScalRA & execPenalty)
d632 3
a634 3
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      const WitInScalRA & falloutRate)
d683 3
a685 3
      const char *       consumingOperationName,
      int                bomEntryIndex,
      const WitInVecRA & offset)
d721 3
a723 3
      const char *       consumingOperationName,
      int                bomEntryIndex,
      const WitInVecRA & routingShare)
d775 3
a777 3
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      const WitInScalRA & usageRate)
d806 3
a808 3
      const char *        consumingOperationName,
      int                 bomEntryIndex,
      const WitInScalRA & inpVal)
@


1.40
log
@Removed portableFree.
@
text
@a26 1
#include <wit.h>
@


1.39
log
@Double Precision.
@
text
@d496 1
a496 1
   portableFree (consRateVal);
@


1.38
log
@Double Precision.
@
text
@d494 1
a494 1
   usageRate.setTo (consRateVal[0]);
d792 1
a792 1
   consRateVal.setToScalar (usageRate);
@


1.37
log
@Double Precision.
@
text
@d471 3
a473 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      float *      usageRate)
d477 1
a477 1
   float * consRateVal;
d494 1
a494 1
   * usageRate = consRateVal[0];
d504 3
a506 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      float *      usageTime)
d510 2
d518 1
a518 1
   witGetBomEntryUsageTime34 (consumingOperationName, bomEntryIndex, usageTime);
d776 3
a778 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      float        usageRate)
d782 1
a782 1
   WitTVec <float> & consRateVal = myApiMgr ()->reserveTempFloatVec ();
d807 3
a809 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      float        inpVal)
d813 2
d821 7
a827 1
   witSetBomEntryUsageTime34 ( consumingOperationName, bomEntryIndex, inpVal);
a863 38
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witGetBomEntryUsageTime34 (
      const char * consumingOperationName,
      int          bomEntryIndex,
      float *      retVal)
   {
   PROLOG ("witGetBomEntryUsageTime34");

   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (retVal, "usageTime", theCall.myBomEnt ()->usageTime34 ());

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witSetBomEntryUsageTime34 (
      const char * consumingOperationName,
      int          bomEntryIndex,
      float        inpVal)
   {
   PROLOG ("witSetBomEntryUsageTime");

   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepDouble (
      "usageTime",
      theCall.myBomEnt ()->usageTime34 (),
      inpVal);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setUsageTime34 (dblFromFlt (inpVal));

   EPILOG;
@


1.36
log
@Double Precision.
@
text
@d22 1
d209 3
a211 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      float * *    consRate)
d391 3
a393 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      float * *    offset)
d423 3
a425 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      float * *    routingShare)
@


1.35
log
@Double Precision.
@
text
@d21 1
d539 3
a541 3
      const char *  consumingOperationName,
      int           bomEntryIndex,
      const float * consRate)
d681 3
a683 3
      const char *  consumingOperationName,
      int           bomEntryIndex,
      const float * offset)
d719 3
a721 3
      const char *  consumingOperationName,
      int           bomEntryIndex,
      const float * routingShare)
@


1.34
log
@Double Precision.
@
text
@d548 1
a548 1
   theCall.prepFloatVec ("consRate", consRate);
@


1.33
log
@Double Precision.
@
text
@d260 3
a262 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitOutScalRA execPenalty)
d304 3
a306 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitOutScalRA falloutRate)
@


1.32
log
@Double Precision.
@
text
@d583 3
a585 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitInScalRA  execPenalty)
d629 3
a631 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      WitInScalRA  falloutRate)
@


1.31
log
@Double Precision.
@
text
@d672 1
a672 1
      theCall.myBomEnt ()->setMandEC (mandEC);
d710 1
a710 1
      theCall.myBomEnt ()->setPropRouting (propRouting);
d764 1
a764 1
      theCall.myBomEnt ()->setSingleSource (singleSource);
@


1.30
log
@Double Precision.
@
text
@d142 1
a142 1
               va_arg (argp, witBoolean));
d356 1
a356 1
      witBoolean * mandEC)
d407 1
a407 1
      witBoolean * propRouting)
d455 1
a455 1
      witBoolean * singleSource)
d663 1
a663 1
      witBoolean   mandEC)
d698 1
a698 1
      witBoolean   propRouting)
d752 1
a752 1
      witBoolean   singleSource)
@


1.29
log
@Double Precision.
@
text
@d887 1
a887 1
      theCall.myBomEnt ()->setUsageTime34 (doubleFromFloat (inpVal));
@


1.28
log
@Double Precision.
@
text
@d793 1
a793 1
      consRateVal.myCvector ());
@


1.27
log
@Continued double precision.
@
text
@d262 1
a262 1
      OutScalRA    execPenalty)
d306 1
a306 1
      OutScalRA    falloutRate)
d585 1
a585 1
      InScalRA     execPenalty)
d631 1
a631 1
      InScalRA     falloutRate)
@


1.26
log
@Continued double precision.
@
text
@d19 2
a20 2
#include <RealSInArg.h>
#include <RealSOutArg.h>
d262 1
a262 1
      RealSOutArg  execPenalty)
d306 1
a306 1
      RealSOutArg  falloutRate)
d585 1
a585 1
      RealSInArg   execPenalty)
d631 1
a631 1
      RealSInArg   falloutRate)
@


1.25
log
@Continued double precision.
@
text
@d19 2
d262 1
a262 1
      float *      execPenalty)
d282 1
a282 1
   float theFalloutRate;
d306 1
a306 1
      float *      falloutRate)
d585 1
a585 1
      float        execPenalty)
d597 1
a597 1
      theCall.myBomEnt ()->setExecPenalty (doubleFromFloat (execPenalty));
d631 1
a631 1
      float        falloutRate)
@


1.24
log
@Continued double precision.
@
text
@d595 1
a595 1
      theCall.myBomEnt ()->setExecPenalty (static_cast <double> (execPenalty));
d885 1
a885 1
      theCall.myBomEnt ()->setUsageTime34 (static_cast <double> (inpVal));
@


1.23
log
@Continued double precision.
@
text
@d589 1
a589 1
   theCall.prepNonNegStrDbl (
d595 1
a595 1
      theCall.myBomEnt ()->setExecPenalty (StrDbl::convFloat (execPenalty));
d879 1
a879 1
   theCall.prepStrDbl (
d885 1
a885 1
      theCall.myBomEnt ()->setUsageTime34 (StrDbl::convFloat (inpVal));
@


1.22
log
@Continued double precision.
@
text
@d879 4
a882 1
   theCall.prepFloat ("usageTime", theCall.myBomEnt ()->usageTime34 (), inpVal);
d885 1
a885 1
      theCall.myBomEnt ()->setUsageTime34 (inpVal);
@


1.21
log
@Removed a bad function overload.
@
text
@d589 1
a589 1
   theCall.prepNonNegFloat (
d595 1
a595 1
      theCall.myBomEnt ()->setExecPenalty (execPenalty);
@


1.20
log
@Changed the routingShare attributes from scalars to vectors.
@
text
@d172 1
a172 1
      curItrDelCompForGet (WitAT_BOM_ENTRY, "bomEntryFrag")->myBomEnt ();
@


1.19
log
@Continued implementation of proportionate routing.
@
text
@d421 1
a421 1
      float *      routingShare)
d716 3
a718 3
      const char * consumingOperationName,
      int          bomEntryIndex,
      float        routingShare)
@


1.18
log
@Continued implementation of proportionate routing.
@
text
@a272 16
WitReturnCode WitRun::witGetBomEntryExpShare (
      const char * consumingOperationName,
      int          bomEntryIndex,
      float *      expShare)
   {
   PROLOG ("witGetBomEntryExpShare");

   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (expShare, "expShare", theCall.myBomEnt ()->expShare ());

   EPILOG;
   }

//------------------------------------------------------------------------------

d418 16
a601 16
WitReturnCode WitRun::witSetBomEntryExpShare (
      const char * consumingOperationName,
      int          bomEntryIndex,
      float        expShare)
   {
   PROLOG ("witSetBomEntryExpShare");

   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.setExpShare (expShare);

   EPILOG;
   }

//------------------------------------------------------------------------------

d709 16
@


1.17
log
@Continued implementation of proportionate routing.
@
text
@d171 2
a172 2
   curItrDelCompForGet (WitAT_BOM_ENTRY, "bomEntryFrag")->
      getBomEntry (theBomEnt);
@


1.16
log
@Internal changes.
@
text
@d273 16
d418 16
d602 16
d703 22
@


1.15
log
@Internal changes.
@
text
@d474 1
a474 1
   if (! wit34Compatible ())
d737 1
a737 1
   if (! wit34Compatible ())
d767 1
a767 1
   if (bomEntryIndex < 0 || bomEntryIndex >= theOpn->bom ().nElements ())
@


1.14
log
@Continued implementation of execPenalties on BOM entries and subs.
@
text
@d140 1
a140 1
               va_arg (argp, WitBoolean));
d354 1
a354 1
      WitBoolean * mandEC)
d421 1
a421 1
      WitBoolean * singleSource)
d629 1
a629 1
      WitBoolean   mandEC)
d635 1
a635 1
   theCall.prepBoolean ("mandEC", theCall.myBomEnt ()->mandEC (), mandEC);
d680 1
a680 1
      WitBoolean   singleSource)
d686 1
a686 1
   theCall.prepBoolean (
@


1.13
log
@Added penalties on BOM entries and substitutes to pen-exec.
@
text
@d257 16
a486 16
WitReturnCode WitRun::witGetBomEntryUsePenalty (
      const char * consumingOperationName,
      int          bomEntryIndex,
      float *      usePenalty)
   {
   PROLOG ("witGetBomEntryUsePenalty");

   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   apiGet (usePenalty, "usePenalty", theCall.myBomEnt ()->usePenalty ());

   EPILOG;
   }

//------------------------------------------------------------------------------

d548 22
a743 22

   EPILOG;
   }

//------------------------------------------------------------------------------

WitReturnCode WitRun::witSetBomEntryUsePenalty (
      const char * consumingOperationName,
      int          bomEntryIndex,
      float        usePenalty)
   {
   PROLOG ("witSetBomEntryUsePenalty");

   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);

   theCall.prepNonNegFloat (
      "usePenalty", 
      theCall.myBomEnt ()->usePenalty (),
      usePenalty);

   if (theCall.argsOK ())
      theCall.myBomEnt ()->setUsePenalty (usePenalty);
@


1.12
log
@Continued implementation of single-source.
@
text
@d471 16
d722 22
@


1.11
log
@Continued implementation of Single-Source.
@
text
@a647 4
   if (! myGlobalComp ()->allowSglSrc ())
      myMsgFac () ("genericSmsg",
         "The Single-Source technique is not yet available.");

@


1.10
log
@Preliminary work on single source.
@
text
@d22 1
d338 1
a338 1
      int *        mandEC)
d402 16
d591 1
a591 1
      int          mandEC)
d633 26
@


1.9
log
@Continued preliminary work on single source.
@
text
@d639 1
a639 1
   consRateVal.setTo (usageRate);
@


1.8
log
@Continued implementation of object iteration.
@
text
@d629 1
a629 1
   WitTVec (float) & consRateVal = myApiMgr ()->reserveTempFloatVec ();
d639 1
a639 1
   consRateVal = usageRate;
@


1.7
log
@Continued implementation of object iteration.
@
text
@d162 1
a162 1
WitReturnCode WitRun::witGetItrBomEntry (
d168 1
a168 1
   PROLOG ("witGetItrBomEntry");
@


1.6
log
@Began implementation of object iteration.
@
text
@d22 1
d156 25
@


1.5
log
@Refactoring for constrained stock reallocation.
@
text
@d11 1
a11 1
// Source file: "bomApi.c"
d18 1
d20 3
a22 1
#include <ApiCall.h>
@


1.4
log
@Replaced some scalar attributes with vector attributes:

   BOM entry  usageRate ==> consRate
   substitute usageRate ==> consRate
   BOP entry  prodRate  ==> productRate
@
text
@d167 1
a167 1
   apiGet (appData, "appData", theCall ()->appData ());
d183 1
a183 1
   apiGet (consRate, "consRate", theCall ()->consRate ());
d199 4
a202 1
   apiGet (consumedPartName, "consumedPartName", theCall ()->myPartName ());
d218 3
a220 1
   apiGet (earliestPeriod, "earliestPeriod", theCall ()->earliestPeriod ());
d264 1
a264 1
   apiGet (falloutRate, "falloutRate", theCall ()->falloutRate ());
d282 1
a282 1
   apiGet (impactPeriod, "impactPeriod", theCall ()->impactPeriod ());
d298 1
a298 1
   apiGet (latestPeriod, "latestPeriod", theCall ()->latestPeriod ());
d314 1
a314 1
   apiGet (mandEC, "mandEC", theCall ()->mandEC ());
d333 1
a333 1
      theCall ()->mySubEntries ().nElements ());
d349 1
a349 1
   apiGet (offset, "offset", theCall ()->offset ());
d365 1
a365 1
   apiGet (selForDel, "selForDel", theCall ()->selForDel ());
d455 1
a455 1
      theCall ()->setConsRate (consRate);
d551 1
a551 1
   theCall.prepBoolean ("mandEC", theCall ()->mandEC (), mandEC);
d554 1
a554 1
      theCall ()->setMandEC (mandEC);
d687 1
a687 1
   apiGet (retVal, "usageTime", theCall ()->usageTime34 ());
d703 1
a703 1
   theCall.prepFloat ("usageTime", theCall ()->usageTime34 (), inpVal);
d706 1
a706 1
      theCall ()->setUsageTime34 (inpVal);
@


1.3
log
@Continued implementation of stock reallocation.
Added emptyFss development control parameter.
@
text
@d174 16
d374 18
a391 1
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d393 1
a393 1
   apiGet (usageRate, "usageRate", theCall ()->usageRate ());
d436 29
d595 11
a605 1
   WitBomEntryApiCall theCall (this, consumingOperationName, bomEntryIndex);
d607 4
a610 1
   theCall.setUsageRate (usageRate);
d612 1
a612 5
   if (usageRate < 0.0)
      myMsgFac () ("negUsageRateMsg",
         bomEntryIndex,
         consumingOperationName,
         usageRate);
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d227 1
a227 1
   apiGet (fallout, "fallout", WitUtil::fracToPercent (theFalloutRate));
d436 1
a436 1
      WitUtil::percentToFrac (fallout));
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

head	1.78;
access;
symbols
	sce_5_01_20080919:1.71
	latest_sce_4_20_20060523:1.71.0.2
	sce_4_20_20060523:1.71
	latest_sce4_20_OSL:1.70.0.2
	sce_4_20_OSL:1.70
	sce_410_withVa:1.70
	sce_4_05_20040511:1.59
	sce_4_00_20040201:1.59
	nextGenBranch:1.59.0.2
	nextGenRoot:1.59
	sce_3_30_20030627:1.59
	EndRw-branch:1.39.0.2
	Root-of-EndRw:1.39
	rwToStl:1.38.0.2
	latest_sce_3_10_20010924:1.27.0.2
	sce_3_10_20010924:1.27
	latest_sce_3_00_20010601:1.12.0.4
	sce_3_00_20010601:1.12
	latest_sce_2_31_20010308:1.12.0.2
	sce_2_31_20010308:1.12
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.78
date	2011.09.28.23.49.34;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2011.09.24.00.27.54;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2011.08.30.20.17.39;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2010.09.28.19.25.16;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2010.07.30.20.20.14;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2010.07.29.21.03.11;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2010.07.26.21.47.11;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.02.17.34.02;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2005.01.27.21.03.27;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2005.01.26.23.50.32;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2005.01.19.18.31.04;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2005.01.18.22.45.41;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2004.12.31.22.28.29;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2004.12.13.23.35.47;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2004.12.09.19.22.50;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.30.00.19.46;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.12.23.50.51;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.12.21.03.46;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.11.22.16.12;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.09.18.55.40;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.29.19.55.29;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.29.14.27.47;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.15.20.50.10;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2003.04.11.19.08.27;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.01.20.34.27;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2003.03.31.23.09.49;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2003.03.28.23.05.31;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.21.23.36.51;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.21.21.35.28;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2003.03.20.19.03.56;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2003.03.19.16.48.19;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.07.21.34.17;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2003.02.27.17.21.25;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.07.23.29.09;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.29.19.16.47;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.15.21.01.21;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.13.22.22.10;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.02.22.18.33;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.04.19.17.57;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.21.22.53.55;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.26.19.05.27;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.02.21.53.03;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.24.23.00.04;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.18.14.02.36;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.12.21.02.00;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.22.21.23.22;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.15.05.47;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.07.23.24.27;	author bobw;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.10.22.06.54;	author bobw;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.19.16.17.10;	author bobw;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.17.16.25.41;	author bobw;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.17.18.56.28;	author bobw;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.04.15.44.38;	author bobw;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.30.20.29.23;	author bobw;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.28.20.30.26;	author bobw;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.24.22.03.20;	author bobw;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.23.21.13.53;	author bobw;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.22.20.41.49;	author bobw;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.12.19.58.25;	author bobw;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.12.17.57.01;	author bobw;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.11.20.47.37;	author bobw;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.06.23.36.01;	author bobw;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.06.16.13.37;	author bobw;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.28.23.11.16;	author bobw;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.28.17.35.18;	author bobw;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.21.45.11;	author bobw;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.04.22.27.51;	author bobw;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.03.15.56.49;	author bobw;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.28.22.13.37;	author bobw;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.20.20.08.36;	author bobw;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.15.23.45.58;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.13.19.57.25;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.05.19.05.30;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.04.22.07.37;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.43;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.20.03.24;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.16;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.25;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.25;	author wit;	state Exp;
branches;
next	;


desc
@@


1.78
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

#ifndef MrMgrH
#define MrMgrH

//------------------------------------------------------------------------------
// Header file: "MrMgr.h"
//
// Contains the declaration of class MrMgr.
//------------------------------------------------------------------------------

#include <Assoc.h>

//------------------------------------------------------------------------------
// Class MrMgr
//
// "Multi-Route Manager"
//
// Main Interface to the Multi-Route Subsystem.
//
// Class Hierarchy:
//
// ProbAssoc
//    MrMgr
//
// Implemented in MultiRoute.C.
//------------------------------------------------------------------------------

class WitMrMgr: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitMrMgr (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitMrMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static bool instNeededFor (WitProblem * theProblem);
         //
         // Returns TRUE, iff a MrMgr is needed for theProblem.

      WitBopEntry * selBopEnt (WitPart * thePart, WitPeriod expPer);
         //
         // Returns the currently selected BopEntry to be used when exploding
         // through thePart in expPer.

      WitConsEntry * selConsEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Similar to selConsEnt (WitPart *, ...).

      WitRtCand * selRtCand (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Returns the currently selected RtCand to be used when exploding thru
         // theRtSite in thePer.

      bool activeForPE (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns true, iff theRtCand is currently active in thePer for
         // pen-exec purposes .

      bool multiChoice (WitRtSite * theRtSite);
         //
         // Returns true, iff there are at least two RtCands eligible for
         // explosion from theRtSite.

      bool valid (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns true, iff theRtCand is currently valid for selection in
         // thePer.

      void select (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Causes theRtCand to be selected by its RtSite in thePer.

      WitSelPt * mySelPtFor (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Returns the multi-route SelPt for theRtSite and thePer.

      void print ();
         //
         // Prints the multi-route subsystem.

      void storeRecoveryPair (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Stores (theRtSite, thePer) as a pair at which the multi-route
         // configuration is to be restored to its initial state.

      void recoverInitState ();
         //
         // Restores the multi-route configuration to its initial state.

      //------------------------------------------------------------------------
      // Selection splitting functions.
      //------------------------------------------------------------------------

      bool selIsSplit (WitPart * thePart, WitPeriod expPer);
         //
         // Returns true, iff there is a split routing selection for exploding
         // thru thePart in expPer. Valid only in sel-split mode.

      bool selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Similar to selIsSplit (WitPart *, ...).

      void defineSplit (
            WitPart *           thePart,
            WitPeriod           expPer,
            double              expVol,
            WitRtCandDblStack & theSplitPairs,
            double &            unbddVol);
         //
         // Sets theSplitPairs to be the split pairs for a split explosion of
         // expVol units at thePart in expPer. Sets unbddVol to the splitVol
         // of the unbounded split explosion, if any; otherwise 0.

      void defineSplit (
            WitBomEntry *       theBomEnt,
            WitPeriod           execPer,
            double              expVol,
            WitRtCandDblStack & theSplitPairs,
            double &            unbddVol);
         //
         // Similar to defineSplit (WitPart *, ...).

      void recordFlowSS (
            WitBillEntry * theBillEnt,
            WitPeriod      thePer,
            double         incFlowVol);
         //
         // Records the fact that incFlowVol additional units are being flowed
         // through theBillEnt in thePer, for sel-split purposes.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      WitSelMgr * mySelMgrForProd ();
      WitSelMgr * mySelMgrForCons ();

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitMrMgr);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitMrCoord * myMrCoord_;
         //
         // The MrCoord owned by this MrMgr.

      WitRtMgr * myRtMgr_;
         //
         // The RtMgr for this MrMgr.
   };

#endif
@


1.77
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.76
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d37 2
a38 68
{
public:

//------------------------------------------------------------------------
// Constructor functions.
//------------------------------------------------------------------------

WitMrMgr (WitSelector *);

//------------------------------------------------------------------------
// Destructor function.
//------------------------------------------------------------------------

~WitMrMgr ();

//------------------------------------------------------------------------
// Other public member functions.
//------------------------------------------------------------------------

static bool instNeededFor (WitProblem * theProblem);
//
// Returns TRUE, iff a MrMgr is needed for theProblem.

WitBopEntry * selBopEnt (WitPart * thePart, WitPeriod expPer);
//
// Returns the currently selected BopEntry to be used when exploding
// through thePart in expPer.

WitConsEntry * selConsEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
//
// Similar to selConsEnt (WitPart *, ...).

WitRtCand * selRtCand (WitRtSite * theRtSite, WitPeriod thePer);
//
// Returns the currently selected RtCand to be used when exploding thru
// theRtSite in thePer.

bool activeForPE (WitRtCand * theRtCand, WitPeriod thePer);
//
// Returns true, iff theRtCand is currently active in thePer for
// pen-exec purposes .

bool multiChoice (WitRtSite * theRtSite);
//
// Returns true, iff there are at least two RtCands eligible for
// explosion from theRtSite.

bool valid (WitRtCand * theRtCand, WitPeriod thePer);
//
// Returns true, iff theRtCand is currently valid for selection in
// thePer.

void select (WitRtCand * theRtCand, WitPeriod thePer);
//
// Causes theRtCand to be selected by its RtSite in thePer.

WitSelPt * mySelPtFor (WitRtSite * theRtSite, WitPeriod thePer);
//
// Returns the multi-route SelPt for theRtSite and thePer.

void print ();
//
// Prints the multi-route subsystem.

void storeRecoveryPair (WitRtSite * theRtSite, WitPeriod thePer);
//
// Stores (theRtSite, thePer) as a pair at which the multi-route
// configuration is to be restored to its initial state.
d40 138
a177 72
void recoverInitState ();
//
// Restores the multi-route configuration to its initial state.

//------------------------------------------------------------------------
// Selection splitting functions.
//------------------------------------------------------------------------

bool selIsSplit (WitPart * thePart, WitPeriod expPer);
//
// Returns true, iff there is a split routing selection for exploding
// thru thePart in expPer. Valid only in sel-split mode.

bool selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer);
//
// Similar to selIsSplit (WitPart *, ...).

void defineSplit (
WitPart *           thePart,
WitPeriod           expPer,
double              expVol,
WitRtCandDblStack & theSplitPairs,
double &            unbddVol);
//
// Sets theSplitPairs to be the split pairs for a split explosion of
// expVol units at thePart in expPer. Sets unbddVol to the splitVol
// of the unbounded split explosion, if any; otherwise 0.

void defineSplit (
WitBomEntry *       theBomEnt,
WitPeriod           execPer,
double              expVol,
WitRtCandDblStack & theSplitPairs,
double &            unbddVol);
//
// Similar to defineSplit (WitPart *, ...).

void recordFlowSS (
WitBillEntry * theBillEnt,
WitPeriod      thePer,
double         incFlowVol);
//
// Records the fact that incFlowVol additional units are being flowed
// through theBillEnt in thePer, for sel-split purposes.

//------------------------------------------------------------------------
// Data access functions.
//------------------------------------------------------------------------

WitSelMgr * mySelMgrForProd ();
WitSelMgr * mySelMgrForCons ();

private:

//------------------------------------------------------------------------
// Private member functions.
//------------------------------------------------------------------------

noCopyCtorAssign (WitMrMgr);

//------------------------------------------------------------------------
// Private member data.
//------------------------------------------------------------------------

WitMrCoord * myMrCoord_;
//
// The MrCoord owned by this MrMgr.

WitRtMgr * myRtMgr_;
//
// The RtMgr for this MrMgr.
};
@


1.75
log
@Modifiable Heuristic Allocation
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d37 68
a104 2
   {
   public:
d106 72
a177 138
      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitMrMgr (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitMrMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      static bool instNeededFor (WitProblem * theProblem);
         //
         // Returns TRUE, iff a MrMgr is needed for theProblem.

      WitBopEntry * selBopEnt (WitPart * thePart, WitPeriod expPer);
         //
         // Returns the currently selected BopEntry to be used when exploding
         // through thePart in expPer.

      WitConsEntry * selConsEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Similar to selConsEnt (WitPart *, ...).

      WitRtCand * selRtCand (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Returns the currently selected RtCand to be used when exploding thru
         // theRtSite in thePer.

      bool activeForPE (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns true, iff theRtCand is currently active in thePer for
         // pen-exec purposes .

      bool multiChoice (WitRtSite * theRtSite);
         //
         // Returns true, iff there are at least two RtCands eligible for
         // explosion from theRtSite.

      bool valid (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Returns true, iff theRtCand is currently valid for selection in
         // thePer.

      void select (WitRtCand * theRtCand, WitPeriod thePer);
         //
         // Causes theRtCand to be selected by its RtSite in thePer.

      WitSelPt * mySelPtFor (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Returns the multi-route SelPt for theRtSite and thePer.

      void print ();
         //
         // Prints the multi-route subsystem.

      void storeRecoveryPair (WitRtSite * theRtSite, WitPeriod thePer);
         //
         // Stores (theRtSite, thePer) as a pair at which the multi-route
         // configuration is to be restored to its initial state.

      void recoverInitState ();
         //
         // Restores the multi-route configuration to its initial state.

      //------------------------------------------------------------------------
      // Selection splitting functions.
      //------------------------------------------------------------------------

      bool selIsSplit (WitPart * thePart, WitPeriod expPer);
         //
         // Returns true, iff there is a split routing selection for exploding
         // thru thePart in expPer. Valid only in sel-split mode.

      bool selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Similar to selIsSplit (WitPart *, ...).

      void defineSplit (
            WitPart *           thePart,
            WitPeriod           expPer,
            double              expVol,
            WitRtCandDblStack & theSplitPairs,
            double &            unbddVol);
         //
         // Sets theSplitPairs to be the split pairs for a split explosion of
         // expVol units at thePart in expPer. Sets unbddVol to the splitVol
         // of the unbounded split explosion, if any; otherwise 0.

      void defineSplit (
            WitBomEntry *       theBomEnt,
            WitPeriod           execPer,
            double              expVol,
            WitRtCandDblStack & theSplitPairs,
            double &            unbddVol);
         //
         // Similar to defineSplit (WitPart *, ...).

      void recordFlowSS (
            WitBillEntry * theBillEnt,
            WitPeriod      thePer,
            double         incFlowVol);
         //
         // Records the fact that incFlowVol additional units are being flowed
         // through theBillEnt in thePer, for sel-split purposes.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      WitSelMgr * mySelMgrForProd ();
      WitSelMgr * mySelMgrForCons ();

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitMrMgr);

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      WitMrCoord * myMrCoord_;
         //
         // The MrCoord owned by this MrMgr.

      WitRtMgr * myRtMgr_;
         //
         // The RtMgr for this MrMgr.
   };
@


1.74
log
@Selection Recovery
@
text
@d101 1
a101 1
      void storeRecoveryPt (WitRtSite * theRtSite, WitPeriod thePer);
d103 1
a103 1
         // Stores (theRtSite, thePer) as a point at which the multi-route
d108 1
a108 2
         // Restores the multi-route selection configuration to its initial
         // state.
@


1.73
log
@Selection Recovery
@
text
@d101 1
a101 1
      void recAltForRecovery (WitRtSite * theRtSite, WitPeriod thePer);
d103 2
a104 3
         // Records the fact that the multi-route configuration is being altered
         // at theRtSite and thePer.
         // Used for selection recovery.
d106 1
a106 1
      void recoverSelections ();
d108 2
a109 3
         // Restores the multi-route selection configuration to its original
         // state, recovering all discarded selection candidates.
         // Valid only in selection recovery mode.
@


1.72
log
@Selection Recovery
@
text
@d101 6
@


1.71
log
@Updated the copyright date on all source files.
@
text
@d101 6
@


1.70
log
@Pegged critical list.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.69
log
@Pegged critical list.
@
text
@d135 3
a137 3
            WitRtCand * theRtCand,
            WitPeriod   thePer,
            double      incFlowVol);
d140 1
a140 1
         // through theRtCand in thePer, for sel-split purposes.
@


1.68
log
@Low-Pri Prop-Rt.
@
text
@d60 9
d105 1
a105 1
      bool selIsSplit (WitRtSite * theRtSite, WitPeriod thePer);
d108 5
a112 1
         // thru theRtSite in thePer. Valid only in sel-split mode.
d115 2
a116 2
            WitRtSite *         theRtSite, 
            WitPeriod           thePer,
d122 1
a122 1
         // expVol units at theRtSite in thePer. Sets unbddVol to the splitVol
d125 9
d135 1
a135 1
            WitRtSite * theRtSite,
d140 1
a140 1
         // through theRtSite in thePer, for sel-split purposes.
d164 4
@


1.67
log
@Low-Pri Prop-Rt.
@
text
@a18 1
#include <RtCase.h>
@


1.66
log
@Low-Pri Prop-Rt.
@
text
@d125 2
a126 1
      WitSelMgr * mySelMgrFor (WitRtCase theRtCase);
@


1.65
log
@Low-Pri Prop-Rt.
@
text
@d107 1
a107 1
            bool &              lastUnbdd);
d110 2
a111 2
         // expVol units at theRtSite in thePer. Sets lastUnbdd to be true,
         // iff the last pair is for an unbounded split explosion.
@


1.64
log
@Low-Pri Prop-Rt.
@
text
@d125 1
a125 1
      WitSelMgr * mySelMgr (WitRtCase theRtCase);
@


1.63
log
@Low-Pri Prop-Rt.
@
text
@d33 2
@


1.62
log
@Low-Pri Prop-Rt.
@
text
@d83 1
a83 1
      WitSelPt * mySelPt (WitRtSite * theRtSite, WitPeriod thePer);
d85 1
a85 1
         // Returns the SelPt for theRtSite and thePer.
@


1.61
log
@Low-Pri Prop-Rt.
@
text
@d64 1
a64 1
      bool activeForPE (WitBillEntry * theBillEnt, WitPeriod thePer);
d66 1
a66 1
         // Returns true, iff theBillEnt is currently active in thePer for
@


1.60
log
@Low-Pri Prop-Rt.
@
text
@a63 5
      WitRtCand * selRtCand (WitRtSitePtr theRtSite, WitPeriod thePer);
         //
         // Returns the currently selected RtCand to be used when exploding thru
         // theRtSite in thePer.

d95 1
a95 1
      bool selIsSplit (WitRtSitePtr theRtSite, WitPeriod thePer);
d101 1
a101 1
            WitRtSitePtr        theRtSite, 
d112 3
a114 3
            WitRtSitePtr theRtSite,
            WitPeriod    thePer,
            double       incFlowVol);
@


1.59
log
@Attempt to fix syntax errors from GCC compiler.
@
text
@d64 1
a64 1
      WitRtCand * selRtCand (WitRtSitePtr theRtSitePtr, WitPeriod thePer);
d67 1
a67 1
         // theRtSitePtr in thePer.
d100 1
a100 1
      bool selIsSplit (WitRtSitePtr theRtSitePtr, WitPeriod thePer);
d103 1
a103 1
         // thru theRtSitePtr in thePer. Valid only in sel-split mode.
d106 1
a106 1
            WitRtSitePtr        theRtSitePtr, 
d113 1
a113 1
         // expVol units at theRtSitePtr in thePer. Sets lastUnbdd to be true,
d117 1
a117 1
            WitRtSitePtr theRtSitePtr,
d122 1
a122 1
         // through theRtSitePtr in thePer, for sel-split purposes.
@


1.58
log
@Continued implementation of proportionate routing.
@
text
@d64 1
a64 1
      WitRtCand * selRtCand (WitRtSiteComp theRtSiteComp, WitPeriod thePer);
d67 1
a67 1
         // theRtSiteComp in thePer.
d100 1
a100 1
      bool selIsSplit (WitRtSiteComp theRtSiteComp, WitPeriod thePer);
d103 1
a103 1
         // thru theRtSiteComp in thePer. Valid only in sel-split mode.
d106 1
a106 1
            WitRtSiteComp       theRtSiteComp, 
d113 1
a113 1
         // expVol units at theRtSiteComp in thePer. Sets lastUnbdd to be true,
d117 3
a119 3
            WitRtSiteComp theRtSiteComp,
            WitPeriod     thePer,
            double        incFlowVol);
d122 1
a122 1
         // through theRtSiteComp in thePer, for sel-split purposes.
@


1.57
log
@Continued implementation of proportionate routing.
@
text
@d64 1
a64 1
      bool activeForPE (WitRtCand * theRtCand, WitPeriod thePer);
d66 6
a71 1
         // Returns true, iff theRtCand is currently active in thePer for
d100 1
a100 1
      bool selIsSplit (WitRtSite * theRtSite, WitPeriod thePer);
d103 1
a103 1
         // thru theRtSite in thePer. Valid only in sel-split mode.
d106 1
a106 1
            WitRtSite *         theRtSite, 
d113 2
a114 2
         // expVol units at theRtSite in thePer. Sets lastUnbdd to be true, iff
         // the last pair is for an unbounded split explosion.
d117 3
a119 3
            WitRtSite * theRtSite,
            WitPeriod   thePer,
            double      incFlowVol);
d122 1
a122 1
         // through theRtSite in thePer, for sel-split purposes.
@


1.56
log
@Continued implementation of proportionate routing.
@
text
@d112 1
a112 1
            WitRtCand * theRtCand,
d117 1
a117 1
         // through theRtCand in thePer, for sel-split purposes.
@


1.55
log
@Continued implementation of proportionate routing.
@
text
@d19 1
a90 10
      WitBopEntry * selBopEnt (WitPart * thePart, WitPeriod expPer);
         //
         // Returns the currently selected BopEnt to be used when exploding thru
         // thePart in expPer.

      WitConsEntry * selConsEnt (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Returns the currently selected ConsEnt to be used when exploding
         // thru theBomEnt in execPer.

d111 4
a114 15
      void setProdBoundedSplit (bool);
      void setConsBoundedSplit (bool);

      void recExpPartSS (
            WitPart * thePart,
            WitPeriod expPer,
            double    expVol);
         //
         // Records the fact that expVol units were exploded thru thePart in
         // expPer.

      void recExpBomEntSS (
            WitBomEntry * theBomsEnt, 
            WitPeriod     execPer, 
            double        deltaExecVol);
d116 2
a117 2
         // Records the fact deltaExecVol units were exploded thru theBomEnt in
         // execPer.
d123 1
a123 2
      WitSelMgr * mySelMgrForProd ();
      WitSelMgr * mySelMgrForCons ();
@


1.54
log
@Continued implementation of proportionate routing.
@
text
@d104 4
a107 4
      void startSplitExp (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol);
d109 10
a118 4
      void startSplitExp (
            WitBomEntry * theBomEnt, 
            WitPeriod     execPer,
            double        execVolVal);
d120 2
a121 8
      bool selIsSplit (WitPart *     thePart,   WitPeriod expPer);
      bool selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer);

      bool findNextSplit (WitBopEntry * &  theBopEnt,  double & splitExpVol);
      bool findNextSplit (WitConsEntry * & theConsEnt, double & splitExecVol);

      void finishProdSplitExp ();
      void finishConsSplitExp ();
@


1.53
log
@Continued implementation of proportionate routing.
@
text
@d90 49
d143 2
a144 2
      WitPmrMgr * myPmrMgr ();
      WitCmrMgr * myCmrMgr ();
@


1.52
log
@Continued implementation of proportionate routing.
@
text
@a67 4
      void modifyRouting (WitRtCandPerStack & theRtCandPers);
         //
         // Modifies the current routing as indicated by theRtCandPers.

@


1.51
log
@Continued implementation of propotionate routing.
@
text
@d63 5
a76 5
      void getRtCands (WitRtSite * theRtSite, WitRtCandStack & theRtCands);
         //
         // Sets theRtCands to be the ordered list of RtCands for multi-route
         // for theRtSite.

a92 8

      void findExpRtCands (
            WitRtSite *      theRtSite,
            WitPeriod        thePer,
            WitRtCandStack & theRtCands);
         //
         // Sets theRtCands to be the set of RtCands currently under
         // consideration for explosion from theRtSite in thePer.
@


1.50
log
@Continued implementation of proportionate routing.
@
text
@d26 1
a26 1
// General Interface to the Multi-Route Subsystem.
d106 2
a107 2
      WitPmrSelMgr * myPmrSelMgr ();
      WitCmrSelMgr * myCmrSelMgr ();
@


1.49
log
@Continued implementation of proportionate routing.
@
text
@d72 1
a72 3
      void getRtCands (
            WitRtSite *               theRtSite,
            WitObjStack <WitRtCand> & theRtCands);
d93 8
@


1.48
log
@Continued implementation of proportionate routing.
@
text
@a66 8
      void findRtCands (
            WitRtSite *      theRtSite,
            WitPeriod        thePer,
            WitRtCandStack & theRtCands);
         //
         // Sets theRtCands to be the set of RtCands currently under
         // consideration for explosion from theRtSite in thePer.

@


1.47
log
@Continued implementation of proportionate routing.
@
text
@d16 1
a16 6
// Contains the declaration of the following classes and templates:
//
//    MrMgr
//    SpecMrMgr <MrArgs>
//    PmrMgr
//    CmrMgr
d19 1
a19 2
#include <SelMgr.h>
#include <PtrMap.h>
d24 3
a26 2
// Multi-Route Manager.
// Base class interface to the multi-route subsystem.
d31 1
a31 6
//    SelMgr
//       MrMgr
//          SpecMrMgr <Pmr>
//             PmrMgr
//          SpecMrMgr <Cmr>
//             CmrMgr
d34 1
a34 1
class WitMrMgr: public WitSelMgr
a38 20
      // Overrides from class SelMgr.
      //------------------------------------------------------------------------

      virtual bool selSplitNeeded ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      virtual void store (WitMrCand * theMrCand) = 0;
         //
         // Stores theMrCand into the appropriate mapping.

   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
d48 1
a48 1
      virtual ~WitMrMgr ();
d51 1
a51 1
      // Selection splitting functions.
d54 1
a54 4
      void recordFlowSS (
            WitMrSite * theMrSite,
            WitPeriod   thePer,
            double      incFlowVol);
d56 1
a56 2
         // Records the fact that incFlowVol additional units are being flowed
         // through theMrSite in thePer, for sel-split purposes.
d58 1
a58 1
      bool selIsSplit (WitMrSite * theMrSite, WitPeriod thePer);
d60 2
a61 11
         // Returns true, iff there is a split routing selection for exploding
         // thru theMrSite in thePer. Valid only in sel-split mode.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitMrMgr);
   };
d63 1
a63 80
//------------------------------------------------------------------------------
// Template argument macros for Class Template SpecMrMgr.
//
// These macros are for code compactness and clarity.
//------------------------------------------------------------------------------

#define MrArgDecs  typename SelComp,     typename CandComp
#define MrArgs              SelComp,              CandComp
#define Pmr                 WitPart,              WitBopEntry
#define Cmr                 WitBomEntry,          WitConsEntry

//------------------------------------------------------------------------------
// Class Template SpecMrMgr <MrArgs>
//
// "Multi-Route Manager.
// One of the intermediate interfaces to the multi-route subsystem, either the
// Production Multi-Route (Prod-MR) interface or the Consumption Multi-Route
// (Cons-MR) interface.
//
// Template Arguments <SelComp, CandComp>:
//
//    SelComp  is the class of the component in the BOM structure at which a
//             routing alternative is to be selected.
//    CandComp is the class of the component in the BOM structure that functions
//             as a candidate for routing selection.
//
// Generally, the macro MrArgs is used as a short-hand for "SelComp, CandComp",
// so SpecMrMgr <SelComp, CandComp> is usually coded as: SpecMrMgr <MrArgs>
//
// This template is designed to have only two cases:
//    One for Production  Multi-Route (Prod-MR, also Pmr)
//    One for Consumption Multi-Route (Cons-MR, also Cmr)
//
// Template Argument Values:
//
//    Subsys    SelComp   CandComp
//    ------    -------   --------
//    Prod-MR   Part      BopEntry
//    Cons-MR   BomEntry  ConsEntry
//
// This class template has no public interface: all access is through its
// derived classes.
//
// Class Hierarchy:
//
// ProbAssoc
//    SelMgr
//       MrMgr
//          SpecMrMgr <Pmr>
//             PmrMgr
//          SpecMrMgr <Cmr>
//             CmrMgr
//------------------------------------------------------------------------------

template <MrArgDecs>
      class WitSpecMrMgr: public WitMrMgr
   {
   protected:

      //------------------------------------------------------------------------
      // Protected member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitSpecMrMgr (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitSpecMrMgr ();

      //------------------------------------------------------------------------
      // Other protected member functions.
      //------------------------------------------------------------------------

      CandComp * selCandComp (SelComp * theSelComp, WitPeriod thePer);
d65 1
a65 2
         // selCandComp (theSelComp, thePer) is the currently selected CandComp
         // to be used when exploding thru theSelComp in thePer.
d67 4
a70 1
      void modifyRouting (WitPairStack <CandComp, WitPeriod> & theCandCompPers);
d72 2
a73 1
         // Modifies the current routing as indicated by theCandCompPers.
d75 1
a75 4
      void findCandComps (
            SelComp *                theSelComp, 
            WitPeriod                thePer,
            WitObjStack <CandComp> & theCandComps);
d77 2
a78 2
         // Sets theCandComps to be the set of CandComps currently under
         // consideration for explosion from theSelComp in thePer.
d80 3
a82 1
      void select (CandComp * theCandComp, WitPeriod thePer);
d84 2
a85 1
         // Causes theCandComp to be selected by its SelComp in thePer.
d87 1
a87 3
      void getCandComps (
            SelComp *                theSelComp,
            WitObjStack <CandComp> & theCandComps);
d89 2
a90 2
         // Sets theCandComps to be the ordered list of candidate CandComps for
         // theSelComp.
d92 1
a92 13
      //------------------------------------------------------------------------
      // Selection splitting functions.
      //------------------------------------------------------------------------

      bool selIsSplit (SelComp * theSelComp, WitPeriod thePer);
         //
         // Returns true, iff there is a split routing selection for exploding
         // thru theSelComp in thePer. Valid only in sel-split mode.

      void startSplitExp (
            SelComp * theSelComp, 
            WitPeriod thePer,
            double    expVol);
d94 1
a94 1
         // See SelMgr.
d96 1
a96 1
      bool findNextSplit (CandComp * & theCandComp, double & splitExpVol);
d98 1
a98 1
         // See SelMgr.
d100 1
a100 4
      void recordFlowSS (
            SelComp * theSelComp, 
            WitPeriod thePer, 
            double    incFlowVol);
d102 1
a102 6
         // Records the fact that incFlowVol additional units are being flowed
         // through theSelComp in thePer, for sel-split purposes.

      void storeMrSiteFor (SelComp * theSelComp, WitMrSite * theMrSite);
         //
         // Stores theMrSite as this SpecMrMgr's MrSite for theSelComp.
d105 1
a105 1
      // Access functions.
d108 2
a109 9
      inline WitMrSite * myMrSiteFor (SelComp * theSelComp)
         {
         return myMrSiteFor_ (theSelComp);
         }

      inline WitMrCand * myMrCandFor (CandComp * theCandComp)
         {
         return myMrCandFor_ (theCandComp);
         }
d117 1
a117 10
      virtual void store (WitMrCand *);
         //
         // Override from class MrMgr.

      CandComp * theCompFor (WitMrCand * theMrCand);
         //
         // Asserts that theMrCand represents an object of type CandComp.
         // Returns that CandComp.

      noCopyCtorAssign (WitSpecMrMgr);
d123 1
a123 72
      WitPtrMap <SelComp, WitMrSite> myMrSiteFor_;
         //
         // myMrSiteFor_ (theSelComp) is this MrMgr's MrSite for theSelComp.

      WitPtrMap <CandComp, WitMrCand> myMrCandFor_;
         //
         // myMrCandFor_ (theCandComp) is this MrMgr's MrCand for theCandComp.
   };

//------------------------------------------------------------------------------
// Class PmrMgr
//
// The production multi-route interface to the multi-route subsystem.
//
// Class Hierarchy:
//
// ProbAssoc
//    SelMgr
//       MrMgr
//          SpecMrMgr <Pmr>
//             PmrMgr
//
// Implemented in MrMgr.C.
//------------------------------------------------------------------------------

class WitPmrMgr: public WitSpecMrMgr <Pmr>
   {
   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPmrMgr (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitPmrMgr ();

      //------------------------------------------------------------------------
      // Wrappers for class SpecMrMgr <Pmr>.
      //------------------------------------------------------------------------

      void setUp ();

      WitBopEntry * selBopEntry (WitPart * thePart, WitPeriod expPer);

      void modifyRouting (WitBopEntPerStack & theBopEntPers);

      void findExpBopEnts (
            WitPart *        thePart, 
            WitPeriod        expPer,
            WitBopEntStack & theBopEnts);

      bool selIsSplit (WitPart * thePart, WitPeriod expPer);

      void startSplitExp (
            WitPart * thePart, 
            WitPeriod expPer,
            double    expVol);

      bool findNextSplit (WitBopEntry * & theBopEnt, double & splitExpVol);
 
      void getCandBopEnts (WitPart * thePart, WitBopEntStack & theBopEnts);

      bool valid (WitBopEntry * theBopEnt, WitPeriod expPer);
d125 1
a125 188
         // Returns true, iff theBopEntry is currently valid for selection in
         // expPer.

      inline WitMrCand * myMrCandFor (WitBopEntry * theBopEnt)
         {
         return WitSpecMrMgr <Pmr>::myMrCandFor (theBopEnt);
         }

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void recPartExpPerSS (
            WitPart * thePart,
            WitPeriod expPer,
            double    expVol);
         //
         // Records the fact that expVol units were exploded thru thePart in
         // expPer.

      void printHasAlt ();
         //
         // Prints those MrPts for which hasAlt () is true.

      WitSelPt * mySelPt (WitPart * thePart, WitPeriod thePer);
         //
         // Returns the SelPt for PMR at thePart and thePer.

      void select (WitBopEntry * theBopEnt, WitPeriod expPer);
         //
         // Causes theBopEnt to be selected by its Part in expPer.

      bool multiChoice (WitPart * thePart);
         //
         // Returns true, iff there are at least two BopEntries eligible for
         // explosion from thePart.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Overrides from class SelMgr.
      //------------------------------------------------------------------------

      virtual WitSelPt *   mySelPtForAlt      (WitBopEntry *,
                                               WitConsEntry *,
                                               WitPeriod,
                                               WitPeriod);
      virtual bool         validForNetting    ();
      virtual bool         validForExecBounds ();
      virtual const char * selCaseName        ();

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPmrMgr);
   };

//------------------------------------------------------------------------------
// Class CmrMgr
//
// The consumption multi-route interface to the multi-route subsystem.
//
// Class Hierarchy:
//
// ProbAssoc
//    SelMgr
//       MrMgr
//          SpecMrMgr <Cmr>
//             CmrMgr
//
// Implemented in MrMgr.C.
//------------------------------------------------------------------------------

class WitCmrMgr: public WitSpecMrMgr <Cmr>
   {
   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitCmrMgr (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      virtual ~WitCmrMgr ();

      //------------------------------------------------------------------------
      // Wrappers for class SpecMrMgr <Pmr>.
      //------------------------------------------------------------------------

      void setUp ();

      WitConsEntry * selConsEntry (WitBomEntry * theBomEnt, WitPeriod execPer);

      void modifyRouting (WitConsEntPerStack & theConsEntPers);

      void findExpConsEnts (
            WitBomEntry *     theBomEnt, 
            WitPeriod         execPer,
            WitConsEntStack & theConsEnts);

      bool selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer);

      void startSplitExp (
            WitBomEntry * theBomEnt, 
            WitPeriod     execPer,
            double        execVolVal);

      bool findNextSplit (WitConsEntry * & theConsEnt, double & splitExpVol);
 
      void getCandConsEnts (
            WitBomEntry *     theBomEnt,
            WitConsEntStack & theConsEnts);

      bool valid (WitConsEntry * theConsEnt, WitPeriod thePer);
         //
         // Returns true, iff theConsEntry is currently valid for selection in
         // thePer.

      inline WitMrCand * myMrCandFor (WitConsEntry * theConsEnt)
         {
         return WitSpecMrMgr <Cmr>::myMrCandFor (theConsEnt);
         }

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      void recExpBomEntSS (
            WitBomEntry * theBomsEnt, 
            WitPeriod     execPer, 
            double        deltaExecVol);
         //
         // Records the fact deltaExecVol units were exploded thru theBomEnt in
         // execPer.

      void printHasAlt ();
         //
         // Prints those MrPts for which hasAlt () is true.

      WitSelPt * mySelPt (WitBomEntry * theBomEnt, WitPeriod thePer);
         //
         // Returns the SelPt for CMR at theBomEnt and thePer.

      void select (WitConsEntry * theConsEnt, WitPeriod execPer);
         //
         // Causes theConsEnt to be selected by its BomEntry in execPer.

      bool multiChoice (WitBomEntry * theBomEnt);
         //
         // Returns true, iff there are at least two ConsEntries eligible for
         // explosion from theBomEnt.

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Overrides from class SelMgr.
      //------------------------------------------------------------------------

      virtual WitSelPt *   mySelPtForAlt      (WitBopEntry *,
                                               WitConsEntry *,
                                               WitPeriod,
                                               WitPeriod);
      virtual bool         validForNetting    ();
      virtual bool         validForExecBounds ();
      virtual const char * selCaseName        ();

      //------------------------------------------------------------------------
      // Other private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitCmrMgr);
@


1.46
log
@Continued implementation of proportionate routing.
@
text
@d269 5
@


1.45
log
@Continued implementation of proportionate routing.
@
text
@a359 4
      static bool instNeededFor (WitProblem * theProblem);
         //
         // Returns TRUE, iff a PmrMgr is needed for theProblem.

a486 4

      static bool instNeededFor (WitProblem * theProblem);
         //
         // Returns TRUE, iff a CmrMgr is needed for theProblem.
@


1.44
log
@Continued implementation of Proportionate Routing.
@
text
@d399 1
a399 1
      virtual WitSelPt *   mySelPt            (WitBopEntry *,
d531 1
a531 1
      virtual WitSelPt *   mySelPt            (WitBopEntry *,
@


1.43
log
@Various internal changes.
@
text
@d360 4
d491 4
@


1.42
log
@Various internal changes.
@
text
@d269 1
a269 1
      noCopyCtorAssignTemp (WitSpecMrMgr, MrArgs);
@


1.41
log
@Internal changes.
@
text
@d112 4
a115 4
#define MrArgDecs  class SelComp,     class CandComp
#define MrArgs           SelComp,           CandComp
#define Pmr              WitPart,           WitBopEntry
#define Cmr              WitBomEntry,       WitConsEntry
@


1.40
log
@Continued implementation of single-source with the new algorithm.
@
text
@d52 1
a52 1
      virtual WitBoolean selSplitNeeded ();
d92 1
a92 1
      WitBoolean selIsSplit (WitMrSite * theMrSite, WitPeriod thePer);
d94 1
a94 1
         // Returns TRUE, iff there is a split routing selection for exploding
d217 1
a217 1
      WitBoolean selIsSplit (SelComp * theSelComp, WitPeriod thePer);
d219 1
a219 1
         // Returns TRUE, iff there is a split routing selection for exploding
d229 1
a229 1
      WitBoolean findNextSplit (CandComp * & theCandComp, double & splitExpVol);
d335 1
a335 1
      WitBoolean selIsSplit (WitPart * thePart, WitPeriod expPer);
d342 1
a342 3
      WitBoolean findNextSplit (
            WitBopEntry * & theBopEnt, 
            double &        splitExpVol);
d346 1
a346 1
      WitBoolean valid (WitBopEntry * theBopEnt, WitPeriod expPer);
d348 1
a348 1
         // Returns TRUE, iff theBopEntry is currently valid for selection in
d370 1
a370 1
         // Prints those MrPts for which hasAlt () is TRUE.
d380 1
a380 1
      WitBoolean multiChoice (WitPart * thePart);
d382 1
a382 1
         // Returns TRUE, iff there are at least two BopEntries eligible for
d399 2
a400 2
      virtual WitBoolean   validForNetting    ();
      virtual WitBoolean   validForExecBounds ();
d461 1
a461 1
      WitBoolean selIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer);
d468 1
a468 3
      WitBoolean findNextSplit (
            WitConsEntry * & theConsEnt, 
            double &         splitExpVol);
d474 1
a474 1
      WitBoolean valid (WitConsEntry * theConsEnt, WitPeriod thePer);
d476 1
a476 1
         // Returns TRUE, iff theConsEntry is currently valid for selection in
d498 1
a498 1
         // Prints those MrPts for which hasAlt () is TRUE.
d508 1
a508 1
      WitBoolean multiChoice (WitBomEntry * theBomEnt);
d510 1
a510 1
         // Returns TRUE, iff there are at least two ConsEntries eligible for
d527 2
a528 2
      virtual WitBoolean   validForNetting    ();
      virtual WitBoolean   validForExecBounds ();
@


1.39
log
@Continued implementation of single-source with the new algorithm.
@
text
@d382 5
d511 5
@


1.38
log
@Began implementation of multi-level lot sizes.
@
text
@d367 2
a368 1
         // Records the fact expVol units were exploded thru thePart in expPer.
@


1.37
log
@Continued implementation of Single-Source.
@
text
@d16 6
a21 1
// Contains the declaration of class template MrMgr <MrArgs>.
a24 3
#include <Part.h>
#include <BomEntry.h>
#include <BopEntry.h>
d28 1
a28 1
// General Comments on the Multi-Route Class Templates
d30 2
d33 1
a33 1
// There are four multi-route class templates:
d35 89
a123 4
//    MrMgr     <SelComp, CandComp>
//    MrSelSite <SelComp, CandComp>
//    MrCand    <SelComp, CandComp>
//    MrPt      <SelComp, CandComp>
d133 1
a133 1
// so the four multi-route class templates usually appear as:
d135 1
a135 6
//    MrMgr     <MrArgs>
//    MrSelSite <MrArgs>
//    MrCand    <MrArgs>
//    MrPt      <MrArgs>
//
// The multi-route templates are designed to have only two cases:
d146 2
a147 38
// Altogether, the Production Multi-Route Subsystem consists of the following
// classes and template classes:
//
//    PmrMgr
//    MrMgr     <Part, BopEntry>
//    MrSelSite <Part, BopEntry>
//    MrCand    <Part, BopEntry>
//    MrPt      <Part, BopEntry>
//
// The code specific to Prod-MR tends to use the following template argument
// macro:
//
//    Pmr --> Part, BopEntry
//
// Similarly, the Consumption Multi-Route Subsystem will consist of the
// following template classes:
//
//    CmrMgr
//    MrMgr     <BomEntry, ConsEntry>
//    MrSelSite <BomEntry, ConsEntry>
//    MrCand    <BomEntry, ConsEntry>
//    MrPt      <BomEntry, ConsEntry>
//
// The code specific to Cons-MR will tend to use the following template argument
// macro:
//
//    Cmr --> BomEntry, ConsEntry
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Class Template MrMgr <MrArgs>
//
// "Multi-Route Manager.
// Base class for the interface to one of the multi-route subsystems, 
//    either Prod-MR or Cons-MR.
//
// For more information on this template, see:
//    "General Comments on the Multi-Route Class Templates" above.
d153 5
a157 6
//       MrMgr <Pmr>
//       MrMgr <Cmr>
//
// Parametric     implementation         in MultiRoute_TI.h.
// Non-parametric implementation for Pmr in ProdMR.C.
// Non-parametric implementation for Cmr in ConsMR.C.
d161 1
a161 1
      class WitMrMgr: public WitSelMgr
d163 1
a163 1
   public:
d166 1
a166 1
      // Public member functions.
d173 1
a173 1
      WitMrMgr (WitSelector *);
d179 1
a179 1
      virtual ~WitMrMgr ();
d182 1
a182 1
      // Other public member functions.
d202 1
a202 4
      void recordFlowSS (
            SelComp * theSelComp, 
            WitPeriod thePer, 
            double    incFlowVol);
d204 1
a204 2
         // Records the fact that incFlowVol additional units are being flowed
         // through theSelComp in thePer, for sel-split purposes.
d206 3
a208 1
      WitMrPt <MrArgs> * myMrPt (SelComp * theSelComp, WitPeriod thePer);
d210 2
a211 1
         // See SelMgr::mySelPt ().
d233 4
a236 3
      void getCandComps (
            SelComp *                theSelComp,
            WitObjStack <CandComp> & theCandComps);
d238 2
a239 2
         // Sets theCandComps to be the ordered list of candidate CandComps for
         // theSelComp.
d241 1
a241 1
      WitBoolean valid (CandComp * theCandComp, WitPeriod thePer);
d243 1
a243 2
         // Returns TRUE, iff theCandComp is currently valid for selection in
         // thePer.
d249 105
a353 1
      inline WitMrSelSite <MrArgs> * myMrSelSiteFor (SelComp * theSelComp)
d355 1
a355 1
         return myMrSelSiteFor_ (theSelComp);
d358 23
a397 1
      virtual WitBoolean   selSplitNeeded     ();
d403 68
a470 3
      void buildMrSelSites ();
         //
         // Builds the MrSelSites for this MrMgr.
d472 1
a472 1
      inline static SelComp * theSelCompFor (CandComp * theCandComp);
d474 2
a475 1
         // Returns the SelComp corresponding to theCandComp.
d477 4
a480 1
      noCopyCtorAssignTemp (WitMrMgr, MrArgs);
d483 1
a483 1
      // Private member data.
d486 17
a502 1
      WitPtrMap <SelComp, WitMrSelSite <MrArgs> > myMrSelSiteFor_;
d504 7
a510 3
         // myMrSelSiteFor_ (theSelComp) is this MrMgr's MrSelSite for 
         // theSelComp.
   };
d512 3
a514 4
//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrMgr <Pmr> inline member
// functions.
//------------------------------------------------------------------------------
d516 7
a522 4
inline WitPart * WitMrMgr <Pmr>::theSelCompFor (WitBopEntry * theBopEnt)
   {
   return theBopEnt->myPart ();
   }
d524 3
a526 4
//------------------------------------------------------------------------------
// Non-parametric implementation of template class MrMgr <Cmr> inline member
// functions.
//------------------------------------------------------------------------------
d528 2
a529 5
inline WitBomEntry * WitMrMgr <Cmr>::theSelCompFor (
      WitConsEntry * theConsEnt)
   {
   return theConsEnt->myBomEnt ();
   }
@


1.36
log
@Continued implementation of single-source.
@
text
@d187 12
@


1.35
log
@Began implementation of object iteration.
@
text
@d163 1
a163 4
      WitSelPt * mySelPt (
            SelComp *    theSelComp,
            WitPeriod    thePer,
            WitBoolean & resFound);
d209 1
a209 2
                                               WitPeriod,
                                               WitBoolean &);
@


1.34
log
@Continued implementation of sel-split for pen-exec.
@
text
@d20 3
@


1.33
log
@Continued implementation of sel-split for pen-exec.
@
text
@d152 1
a152 1
      void recordFlow (
d158 1
a158 1
         // through theSelComp in thePer.
@


1.32
log
@Continued implementation of sel-split for pen-exec.
@
text
@d211 1
@


1.31
log
@Continued implementation of sel-split fpr pen-exec.
@
text
@a186 8
      void setPrevSel (
            CandComp *  theCandComp, 
            WitPeriod   thePer,
            WitBoolean  theVal);
         //
         // Sets the prevSel Boolean for theCandComp in thePer to theVal.
         // Used by sel-split for pen-exec.

@


1.30
log
@Implemented initial prototype of sel-split for pen-exec.
@
text
@d187 8
@


1.29
log
@Initial implementation of selection splitting for multi-route.
@
text
@d160 7
a221 7

      WitSelPt * mySelPt (
            CandComp *   theCandComp,
            WitPeriod    thePer,
            WitBoolean & resFound);
         //
         // See SelMgr::mySelPt ().
@


1.28
log
@Implementing Selection Splitting for Stock Reallocation.
@
text
@d149 10
a158 2
         // Sets theCandComps to be the set of CandComps currently
         // under consideration for explosion from theSelComp in thePer.
@


1.27
log
@Continued implmentation of selective stock reallocation.
@
text
@d32 1
a32 1

@


1.26
log
@Continuing implementation of selective stock reallocation.
@
text
@a88 11
// Template argument macros for multi-route.
//
// These macros are for code compactness and clarity.
//------------------------------------------------------------------------------

#define MrArgDecs  class SelComp,     class CandComp
#define MrArgs           SelComp,           CandComp
#define Pmr              WitPart,           WitBopEntry
#define Cmr              WitBomEntry,       WitConsEntry

//------------------------------------------------------------------------------
@


1.25
log
@Refactoring for constrained stock reallocation.
@
text
@d111 4
a114 3
// SelMgr
//    MrMgr <Pmr>
//    MrMgr <Cmr>
a209 1
      virtual void         postSplitCommit    ();
@


1.24
log
@Refactoring for constrained stock reallocation.
@
text
@d31 1
a31 1
//    MrSelPt   <SelComp, CandComp>
d46 1
a46 1
//    MrSelPt   <MrArgs>
d66 1
a66 1
//    MrSelPt   <Part, BopEntry>
d80 1
a80 1
//    MrSelPt   <BomEntry, ConsEntry>
@


1.23
log
@Refactoring for constrained stock reallocation.
@
text
@d62 1
a63 1
//       PmrMgr
d76 1
a77 1
//       CmrMgr
a112 1
//       PmrMgr   [private]
a113 1
//       CmrMgr   [private]
d123 1
a123 1
   protected:
d126 1
a126 1
      // Protected member functions.
d142 1
a142 1
      // Other protected member functions.
@


1.22
log
@Refactoring for constrained stock reallocation.
@
text
@a19 1
#include <DblSpSch.h>
a124 14
   public:

      //------------------------------------------------------------------------
      // Public member functions.
      //------------------------------------------------------------------------

      virtual void adjustSplitBound (
            CandComp * theCandComp, 
            WitPeriod  thePer, 
            double &   splitBound) = 0;
         //
         // Adjusts splitBound as appropriate when performing a multi-route
         // split explosion through theCandComp in thePer.

@


1.21
log
@Refactoring for constrained stock reallocation.
@
text
@a139 5
      inline static WitBoolean forPmr ();
         //
         // Returns TRUE,  for class MrMgr <Pmr>,
         //         FALSE, for class MrMgr <Cmr>.

d195 3
a197 5
      inline WitBoolean findNextSplit (
            CandComp * & theCandComp, 
            double &     splitExpVol)
         {
         witAssert (selSplit ());
a198 3
         return findNextSplitAbs ((WitTlObj * &) theCandComp, splitExpVol);
         }
 
a224 1
      virtual void         prtSelCandID       (WitTlObj *);
a263 7
inline WitBoolean WitMrMgr <Pmr>::forPmr ()
   {
   return witTRUE;
   }

//------------------------------------------------------------------------------

a271 7
//------------------------------------------------------------------------------

inline WitBoolean WitMrMgr <Cmr>::forPmr ()
   {
   return witFALSE;
   }

@


1.20
log
@Refactoring.
@
text
@d72 1
a72 1
//    PmrArgs --> Part, BopEntry
d86 1
a86 1
//    CmrArgs --> BomEntry, ConsEntry
d97 2
a98 2
#define PmrArgs          WitPart,           WitBopEntry
#define CmrArgs          WitBomEntry,       WitConsEntry
d113 8
a120 8
//    MrMgr <PmrArgs>
//       PmrMgr       [private]
//    MrMgr <CmrArgs>
//       CmrMgr       [private]
//
// Parametric     implementation             in MrMgr_TI.h.
// Non-parametric implementation for PmrArgs in ProdMR.C.
// Non-parametric implementation for CmrArgs in ConsMR.C.
d140 5
d271 1
a271 1
// Non-parametric implementation of template class MrMgr <PmrArgs> inline member
d275 8
a282 1
inline WitPart * WitMrMgr <PmrArgs>::theSelCompFor (WitBopEntry * theBopEnt)
d288 1
a288 1
// Non-parametric implementation of template class MrMgr <CmrArgs> inline member
d292 8
a299 1
inline WitBomEntry * WitMrMgr <CmrArgs>::theSelCompFor (
@


1.19
log
@Templatized consumption multi-route.
@
text
@d118 3
a120 1
// Implemented in MultiRoute.C.
@


1.18
log
@Continued refactoring.
@
text
@a26 4
// Note: This is work in progress; the comments below describe the multi-route
// templates as they intended to be, once they are fully implemented.
//
//
d95 4
a98 3
#define MrArgDecs  class SelComp, class CandComp
#define MrArgs           SelComp,       CandComp
#define PmrArgs          WitPart,       WitBopEntry
d115 2
d169 1
a169 1
      void findConsComps (
d236 4
d262 21
@


1.17
log
@Replaced Mapping (*, WitTlObjPtr) with PtrMap <*, *>.
@
text
@d37 1
a37 1
//
d117 1
a117 1
//       PmrMgr
d131 4
a134 1
      WitBopEntry * selBopEntry (WitPart * thePart, WitPeriod expPer);
d136 4
a139 3
         // selBopEntry (thePart, expPer) is the currently selected BopEntry to
         // be used for explosions in order to produce thePart in expPer.
         // Invalid, if thePart is not explodeable in expPer.
d142 1
a142 1
      // Overrides from class SelPt.
d145 11
a155 8
      virtual WitSelPt *   mySelPt            (WitBopEntry *,
                                               WitConsEntry *,
                                               WitPeriod,
                                               WitPeriod,
                                               WitBoolean &);
      virtual WitBoolean   validForExecBounds ();
      virtual const char * selCaseName        ();
      virtual void         prtSelCandID       (WitTlObj *);
d158 1
a158 1
      // Other public member functions.
d161 1
a161 1
      void printHasAlt ();
d163 2
a164 1
         // Prints those MrSelPts for which hasAlt () is TRUE.
d166 1
a166 1
      void modifyRouting (WitBopEntPerStack & theBopEntPers);
d168 1
a168 1
         // Modifies the current routing as indicated by theBopEntPers.
d170 4
a173 4
      void findExpBopEnts (
            WitPart *        thePart, 
            WitPeriod        expPer,
            WitBopEntStack & theBopEnts);
d175 2
a176 2
         // Sets theBopEnts to be the set of BOP entries currently
         // under consideration for explosion from thePart in expPer.
d182 1
a182 5
      virtual WitBoolean selSplitNeeded ();
         //
         // Override from class SelMgr.

      WitBoolean selIsSplit (WitPart * thePart, WitPeriod expPer);
d185 1
a185 1
         // thru thePart in expPer. Valid only in sel-split mode.
d188 2
a189 2
            WitPart * thePart, 
            WitPeriod expPer,
d195 2
a196 2
            WitBopEntry * & theBopEnt, 
            double &        splitExpVol)
d200 1
a200 1
         return findNextSplitAbs ((WitTlObj * &) theBopEnt, splitExpVol);
d203 3
a205 7
      void adjustSplitBound (
            WitBopEntry * theBopEnt, 
            WitPeriod     expPer, 
            double &      splitBound);
         //
         // Adjusts splitBound as appropriate when performing a production
         // multi-route split explosion through theBopEnt in expPer.
d207 4
a210 7
      void recBopEntExpPerSS (
            WitBopEntry * theBopEnt, 
            WitPeriod     expPer, 
            double        expVol);
         //
         // Records the fact expVol units were exploded thru theBopEnt in
         // expPer.
d212 1
a212 9
      virtual void postCommitSS ();
         //
         // Override from class SelMgr.

      virtual void postSplitCommit ();
         //
         // Override from class SelMgr.

   protected:
d215 1
a215 1
      // Protected member functions.
d219 1
a219 1
      // Constructor functions.
d222 10
a231 1
      WitMrMgr (WitSelector *);
d234 1
a234 1
      // Destructor function.
d237 6
a242 7
      virtual ~WitMrMgr ();

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------
d244 1
a244 1
      virtual void setUpDerivedSS ();
d246 1
a246 1
         // Override from class SelMgr.
d254 1
a254 1
      WitPtrMap <WitPart, WitMrSelSite <MrArgs> > myMrSelSiteFor_;
a257 12

      //------------------------------------------------------------------------
      // Selection splitting data.
      //------------------------------------------------------------------------

      WitDblSpSched (WitBopEntry) totExpVol_;
         //
         // Valid only in sel-split mode.
         // totExpVol_ (theBopEnt, expPer) is the total expVol that has been 
         // exploded thru theBopEnt in expPer during the current commit. 
         // totExpVol_ (theBopEnt) is only valid if theBopEnt
         // corresponds to a multi-choice MrBopEnt.
@


1.16
log
@Minor modification.
@
text
@d21 1
a246 8
      inline WitMrSelSite <MrArgs> * & myMrSelSite (SelComp * theSelComp)
            //
            // myMrSelSite (theSelComp) is this MrMgr's MrSelSite for 
            // theSelComp.
         {
         return (WitMrSelSite <MrArgs> * &) myMrSelSiteTl_ (theSelComp);
         }

d257 1
a257 1
      WitMapping (WitPart, WitTlObjPtr) myMrSelSiteTl_;
d259 2
a260 1
         // Data for myMrSelSite (Part *).
@


1.15
log
@Refactoring.
@
text
@d118 1
a118 1
// Implemented in MultiRt.C.
@


1.14
log
@Replaced non-template based production multi-route with template based
production multi-route.
@
text
@d246 1
a246 1
      inline WitMrSelSite <MrArgs> * & myMrSelSite (WitPart * thePart)
d248 2
a249 1
            // myMrSelSite (thePart) is this MrMgr's MrSelSite for thePart.
d251 1
a251 1
         return (WitMrSelSite <MrArgs> * &) myMrSelSiteTl_ (thePart);
@


1.13
log
@Initial implementation of multi-route class templates.
@
text
@d16 1
a16 4
// Contains the declaration of the following classes and class templates:
//
//    MrMgr <MrArgs>
//    PmrMgN 
d77 2
a78 2
// Similarly, the Consumption Multi-Route Subsystem consists of the following
// template classes:
d86 1
a86 1
// The code specific to Cons-MR tends to use the following template argument
d116 1
a116 1
//       PmrMgN
a277 41
   };

//------------------------------------------------------------------------------
// Class PmrMgN
//
// The interface to the production multi-route subsystem.
// This class will eventually be renamed PmrMgr, replacing the current class
// with that name.
//
// Class Hierarchy:
//
// SelMgr
//    MrMgr <PmrArgs>
//       PmrMgN
//
// Implemented in MultiRt.C.
//------------------------------------------------------------------------------

class WitPmrMgN: public WitMrMgr <PmrArgs>
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitPmrMgN (WitSelector *);

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitPmrMgN ();

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitPmrMgN);
@


1.12
log
@Coarse selection splitting.
@
text
@d1 324
@


1.11
log
@Fixed some bugs in coarse selection splitting.
@
text
@a0 325
//------------------------------------------------------------------------------
//
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------

#ifndef MrMgrH
#define MrMgrH

//------------------------------------------------------------------------------
// Header file: "MrMgr.h"
//
// Contains the declaration of class MrMgr.
//------------------------------------------------------------------------------

#include <Mapping.h>
#include <DblSpSch.h>
#include <StSpSch.h>

//------------------------------------------------------------------------------
// Class MrMgr
//
// Interface to the multi-route subsystem.
// The multi-route subsystem is responsible for maintaining the selections for 
// multi-route mode.
//
// Implemented in MultiRt.C.
//------------------------------------------------------------------------------

class WitMrMgr: public WitProbAssoc
   {
   public:

      //------------------------------------------------------------------------
      // Constructor functions.
      //------------------------------------------------------------------------

      WitMrMgr (WitSelector * theSelector);
         //
         // myRtAnalyzer_ <<< theSelector.

      //------------------------------------------------------------------------
      // Destructor function.
      //------------------------------------------------------------------------

      ~WitMrMgr ();

      //------------------------------------------------------------------------
      // Other public member functions.
      //------------------------------------------------------------------------

      WitBopEntry * selBopEntry (WitPart * thePart, WitPeriod thePer);
         //
         // selBopEntry (thePart, thePer) is the currently selected BopEntry to
         // be used for explosions in order to produce thePart in thePer.
         // Invalid, if thePart is not explodeable in thePer.

      WitConsEntry * selConsEntry (WitBomEntry * theBomEnt, WitPeriod thePer);
         //
         // selConsEntry (theBomEnt, thePer) is the currently selected
         // ConsEntry to be used when exploding theBomEnt in thePer. It may be
         // either theBomEnt itself or one of the SubEntries associated with 
         // it. Invalid, if theBomEnt is not in effect in thePer.

       WitAltPt * myAltPt (
            WitBomEntry * theBomEnt,
            WitPeriod     execPer,
            WitBoolean &  resFound);
         //
         // Returns the AltPt representing the selection of a ConsEntry when
         // exploding thru theBomEnt in execution period execPer, or NULL, if
         // there is none. On return resFound indicates whether or not a 
         // resolving alteration was found.

      WitAltPt * myAltPt (
            WitPart *    thePart,
            WitPeriod    prodPer,
            WitBoolean & resFound);
         //
         // Returns the AltPt representing the selection of a BopEntry when
         // exploding thru thePart in production period prodPer, or NULL, if
         // there is none. On return resFound indicates whether or not a 
         // resolving alteration was found.

      void printHasAlt ();
         //
         // Prints those MrAltPts for which hasAlt () is TRUE.

      void printMultiChoices ();
         //
         // Prints those MrComps for which multiChoice_ is TRUE.

      void modifyRouting (WitPart * thePart, WitPeriod thePer);
         //
         // Modifies the current routing as appropriate in order to fill a small
         // incremental requirement for thePart in thePer at a heuristically
         // minimal exec penalty.

      void recCommitVol (double commitVol, WitBoolean byExp);
         //
         // See RtAnalyzer::recCommitVol.

      void findExpBopEnts (
            WitPart *        thePart, 
            WitPeriod        expPer,
            WitBopEntStack & theBopEnts);
         //
         // Sets theBopEnts to be the set of BOP entries currently
         // under consideration for explosion from thePart in expPer.

      void findExpConsEnts (
            WitBomEntry *     theBomEnt,
            WitPeriod         execPer,
            WitConsEntStack & theConsEnts);
         //
         // Sets theConsEnts to be the set of cons entries currently
         // under consideration for explosion at theBomEnt in execPer.

      //------------------------------------------------------------------------
      // Selection splitting functions.
      //------------------------------------------------------------------------

      void recExpBopEntSS (
            WitBopEntry * theBopEnt, 
            WitPeriod     expPer, 
            double        expVol);
         //
         // Records the fact expVol units were exploded thru theBopEnt in
         // expPer.

      void recExpConsEntSS (
            WitConsEntry * theConsEnt, 
            WitPeriod      execPer, 
            double         deltaExecVol);
         //
         // Records the fact deltaExecVol units were exploded thru theConsEnt in
         // execPer.

      void postCommitSS (WitBoolean tempSuccess);
         //
         // Performs the actions to be taken for multi-route sel-split, just
         // after a commit. tempSuccess is to be TRUE, iff the commit was
         // successful and in temp mode.

      void preAltAttSS ();
         //
         // Performs actions to be taken for multi-route sel-split just before a
         // selection alteration is attempted.

      void postAltAttSS ();
         //
         // Performs actions to be taken for multi-route sel-split just after a
         // selection alteration has been attempted.

      void postPermCommitSS ();
         //
         // Performs the actions to be taken for multi-route sel-split,
         // just after a perm commit.

      WitBoolean routingIsSplit (WitPart * thePart, WitPeriod expPer);
         //
         // Returns TRUE, iff there is a split selection for exploding thru
         // thePart in expPer. Valid only in sel-split mode.

      WitBoolean routingIsSplit (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // Returns TRUE, iff there is a split selection for exploding thru
         // theBomEnt in execPer. Valid only in sel-split mode.

      void splitSel (WitBopEntry * theBopEnt, WitPeriod thePer);
         //
         // Records a split selection thru theBopEnt in thePer.

      void getSplitList (
            WitPart *           thePart,
            WitPeriod           expPer,
            WitBopEntDblStack & theSplitList);
         //
         // Sets theSplitList to be the ordered list of (BopEntry, splitVol)
         // pairs to be used when exploding thru thePart in expPer.

      void setExpBopEntIsSplit (WitBoolean);
         //
         // "Set" function for expBopEntIsSplit_.

      void splitSel (WitConsEntry * theConsEnt, WitPeriod thePer);
         //
         // Records a split selection thru theConsEnt in thePer.

      void getSplitList (
            WitBomEntry *        theBomEnt, 
            WitPeriod            execPer,
            WitConsEntDblStack & theSplitList);
         //
         // Sets theSplitList to be the ordered list of (ConsEntry, splitVol)
         // pairs to be used when exploding through theBomEnt in execPer.

      void setExpConsEntIsSplit (WitBoolean);
         //
         // "Set" function for expConsEntIsSplit_.

      //------------------------------------------------------------------------
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitExpRest *, myExpRest)
      accessFunc (WitBoolean,   penExec)
      accessFunc (WitBoolean,   ssmrForBopEnts)

   private:

      //------------------------------------------------------------------------
      // Private member functions.
      //------------------------------------------------------------------------

      noCopyCtorAssign (WitMrMgr);

      inline WitMrPart * & myMrPart (WitPart * thePart)
            //
            // myMrPart (thePart) is this MrMgr's MrPart for thePart.
         {
         return (WitMrPart * &) myMrPartTl_ (thePart);
         }

      inline WitMrBomEnt * & myMrBomEnt (WitBomEntry * theBomEnt)
            //
            // myMrBomEnt (theBomEnt) is this MrMgr's MrBomEnt for theBomEnt.
         {
         return (WitMrBomEnt * &) myMrBomEntTl_ (theBomEnt);
         }

      void setupPenExec (WitSelector * theSelector);
         //
         // Determines whether or not penalized execution is to be performed, 
         // and if so, sets it up.
         // myRtAnalyzer_ <<< theSelector.

      void setupSelSplit ();
         //
         // Sets up data for selection splitting.

      //------------------------------------------------------------------------
      // Private member data.
      //------------------------------------------------------------------------

      //------------------------------------------------------------------------
      // Associations.
      //------------------------------------------------------------------------

      WitExpRest * myExpRest_;
         //
         // The ExpRest owned by this MrMgr, in pen-exec mode; otherwise NULL.

      WitRtAnalyzer * myRtAnalyzer_;
         //
         // The RtAnalyzer owned by this ExecPen, in pen-exec mode; otherwise 
         // NULL.

      //------------------------------------------------------------------------
      // Other private member data.
      //------------------------------------------------------------------------

      WitMapping (WitPart, WitTlPtr) myMrPartTl_;
         //
         // Data for myMrPart (Part *).

      WitMapping (WitBomEntry, WitTlPtr) myMrBomEntTl_;
         //
         // Data for myMrBomEnt (BomEntry *).

      WitBoolean penExec_;
         //
         // TRUE, iff penalized execution is to be performed.

      WitStackSpSched (WitPart, WitBopEntry) myPartSplitSched_;
         //
         // Valid only in sel-split mode.
         // myPartSplitSched_ (theBomEnt, thePer) is the list of
         // (ConsEntry, splitVol) pairs to be used when exploding at
         // myBomEntry_ in thePer. The pairs are stored in reverse order.
         // myPartSplitSched_ (theBomEnt, thePer) is only valid if theBomEnt
         // corresponds to a multi-choice MrBomEnt.

      WitDblSpSched (WitBillEntry) totExpVol_;
         //
         // Valid only in sel-split mode.
         // totExpVol_ (theBillEnt, thePer) is the total execVol that has been 
         // exploded thru theBillEnt in thePer during the current commit. 
         // During selection alteration, its values reflect
         // the most recent successful temp commit, if any, else 0.
         // totExpVol_ (theBillEnt) is only valid if theBillEnt
         // corresponds to a multi-choice MrComp.

      WitStackSpSched (WitBomEntry, WitConsEntry) myBomEntSplitSched_;
         //
         // Valid only in sel-split mode.
         // myBomEntSplitSched_ (theBomEnt, thePer) is the list of
         // (ConsEntry, splitVol) pairs to be used when exploding at
         // myBomEntry_ in thePer. The pairs are stored in reverse order.
         // myBomEntSplitSched_ (theBomEnt, thePer) is only valid if theBomEnt
         // corresponds to a multi-choice MrBomEnt.

      WitBoolean ssmrForBopEnts_;
         //
         // Valid only in sel-split mode.
         // TRUE iff multiRoute for BOP entries is being performed.
         // Temporary data for development purposes only.

      WitBoolean expBopEntIsSplit_;
         //
         // TRUE, iff the BopEntry currently being exploded is using a finite
         // splitVol.
         // FALSE, if non sel-split mode.

      WitBoolean expConsEntIsSplit_;
         //
         // TRUE, iff the ConsEntry currently being exploded is using a finite
         // splitVol.
         // FALSE, if non sel-split mode.
   };

#endif
@


1.10
log
@Completed a limited implementation of coarse selection splitting for BOP
entries.
@
text
@d185 4
d201 4
d311 12
@


1.9
log
@Further development of coarse selection splitting.
@
text
@d126 8
d136 1
a136 1
            WitPeriod      thePer, 
d140 1
a140 1
         // thePer.
d163 26
a196 7
      void splitSel (
            WitBomEntry *  theBomEnt, 
            WitPeriod      thePer, 
            WitConsEntry * theConsEnt);
         //
         // Records a split selection for theBomEnt in thePer thru theConsEnt.

d203 1
d233 4
d270 1
a270 1
      WitDblSpSched (WitBomEntry) totExecVol_;
d273 4
a276 3
         // totExecVol_ (theBomEnt, thePer) is the total execVol that has been 
         // exploded thru this theBomEnt and its subs in thePer during the 
         // current commit. totExecVol_ (theBomEnt) is only valid if theBomEnt
d279 1
a279 1
      WitStackSpSched (WitBomEntry, WitConsEntry) splitListSched_;
d282 11
a292 1
         // splitListSched_ (theBomEnt, thePer) is the list of
d295 1
a295 1
         // splitListSched_ (theBomEnt, thePer) is only valid if theBomEnt
d297 6
@


1.8
log
@Futher development of selection splitting.
@
text
@d21 1
a21 1
#include <Stack.h>
d163 4
a166 1
      void firstSplit (WitMrBomEnt * theMrBomEnt, WitPeriod thePer);
d168 1
a168 7
         // Records the first splitting of the selection at theMrBomEnt in
         // thePer.

      inline double totExecVol (WitBomEntry * theBomEnt, WitPeriod thePer)
         {
         return totExecVol_ (theBomEnt, thePer);
         }
d226 1
a226 1
      WitMapping (WitPart, WitTypelessPtr) myMrPartTl_;
d230 1
a230 1
      WitMapping (WitBomEntry, WitTypelessPtr) myMrBomEntTl_;
d238 1
a238 1
      WitMrBomEntPerStack nonEmpSplits_;
d241 4
a244 2
         // The set of pairs (theMrBomEnt, thePer) such that
         // theMrBomEnt->splitList_ (thePer) is not empty.
d246 1
a246 1
      WitDblSpSched (WitBomEntry) totExecVol_;
d249 4
a252 3
         // totExecVol_ (theBomEnt)[thePer] is the total execVol that has been 
         // exploded thru this theBomEnt and its subs in thePer during the 
         // current commit. totExecVol_ (theBomEnt) is only valid if theBomEnt
@


1.7
log
@Further development of selection splitting for multi-route on substitutes.
@
text
@d20 1
d168 5
a207 5
      void clearExecVols ();
         //
         // Valid only in sel-split mode.
         // Sets theMrBomEnt->totExecVol_ to 0 for all MrBomEnts.

d241 1
a241 1
      WitMrBomEntPerStack nzExecVols_;
d245 1
a245 1
         // theMrBomEnt->totExecVol_[thePer] != 0.0.
d247 1
a247 1
      WitMrBomEntPerDblStack savedExecVols_;
d250 4
a253 9
         // The set of triples (theMrBomEnt, thePer, theValue) such that
         // theMrBomEnt->totExecVol_[thePer] == theValue > 0.0 on the most
         // recent successful EBS iteration.

      WitMrBomEntPerStack nonEmpSplits_;
         //
         // Valid only in sel-split mode.
         // The set of pairs (theMrBomEnt, thePer) such that
         // theMrBomEnt->splitList_ (thePer) is not empty.
@


1.6
log
@Some minor modifications.
@
text
@d20 1
a66 9
      void getSplitList (
            WitBomEntry *        theBomEnt, 
            WitPeriod            execPer,
            WitConsEntDblStack & theSplitList);
         //
         // Valid only in sel-split mode.
         // Sets theSplitList to be the ordered list of (ConsEntry, splitVol)
         // pairs to be used when exploding through theBomEnt in execPer.

a86 26
      void setSplitVol (
            WitBomEntry * theBomEnt, 
            WitPeriod     thePer, 
            double        theValue);
         //
         // Valid only in sel-split mode.
         // Sets the current split vol for theBomEnt in thePer to theValue.

      void postTempCommitSS (WitBoolean success);
         //
         // Valid only in sel-split mode.
         // Performs actions to be taken for multi-route sel-split just after a
         // temp commit.

      void postAltAttSS ();
         //
         // Valid only in sel-split mode.
         // Performs actions to be taken for multi-route sel-split just after a
         // selection alteration has been attempted.

      void postPermCommitSS ();
         //
         // Performs the actions to be taken for multi-route sel-split,
         // just after a perm commit.
         // Valid only in sel-split mode.

d122 46
d202 5
d239 19
@


1.5
log
@Added print_global control parameter.
Completed a very restricted form of coarse selection splitting.
@
text
@d140 3
a142 3
            WitPart *                      thePart, 
            WitPeriod                      expPer,
            WitObjDynStack (WitBopEntry) & theBopEnts);
d148 3
a150 3
            WitBomEntry *                   theBomEnt,
            WitPeriod                       execPer,
            WitObjDynStack (WitConsEntry) & theConsEnts);
@


1.4
log
@Refactoring for selection splitting.
@
text
@a49 7
      // Data access functions.
      //------------------------------------------------------------------------

      accessFunc (WitExpRest *, myExpRest)
      accessFunc (WitBoolean,   penExec)

      //------------------------------------------------------------------------
a52 6
      WitBoolean splitting ();
         //
         // Returns TRUE if this Selector is splitting the current selection.
         // (This means that another extended binary search will be needed.)
         // Only valid in sel split mode.

d66 8
a73 21
      void findSelConsEntries (WitBomEntry * theBomEnt, WitPeriod execPer);
         //
         // See findNextConsEntry.
         // Invalid, if theBomEnt is not in effect in execPer.
         // Only valid in sel-split mode.

      void findNextConsEntry (
            WitConsEntry * & theConsEnt,
            WitBoolean &     splitVolFinite,
            double &         splitVolVal);
         //
         // Finds the next ConsEntry to be used when exploding according to
         // the most recent call to findSelConsEntries.
         // theConsEnt     <-- the selected ConsEntry
         // splitVolFinite <-- TRUE, iff the splitVol for theConsEnt is finite.
         // splitVolVal    <-- the splitVol for theConsEnt, if splitVolFinite
         //                    is TRUE, else undefined.
         // Only valid in sel-split mode.
         // Invalid if a BomEntry has not been specified through
         // findSelConsEntries, or if the infinite splitVol ConsEnt for the
         // BomEntry has already been returned.
d95 26
d155 7
a205 9

      //------------------------------------------------------------------------
      // Selection splitting data.
      //------------------------------------------------------------------------

      WitConsEntry * ssConsEnt_;
         //
         // The currently selected ConsEntry for selection splitting, if any,
         // else NULL.
@


1.3
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d161 1
a161 3
      copyCtorAndAssignment (WitMrMgr);
         //
         // Prevents unintentional copying and assignment.
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d60 6
d79 22
d140 3
a142 3
            WitPart *                   thePart, 
            WitPeriod                   expPer,
            WitDynStack (WitBopEntry) & theBopEnts);
d148 3
a150 3
            WitBomEntry *                theBomEnt,
            WitPeriod                    execPer,
            WitDynStack (WitConsEntry) & theConsEnts);
d201 9
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

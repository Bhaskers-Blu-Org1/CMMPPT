head	1.42;
access;
symbols
	sce_5_01_20080919:1.35
	latest_sce_4_20_20060523:1.32.0.2
	sce_4_20_20060523:1.32
	latest_sce4_20_OSL:1.31.0.2
	sce_4_20_OSL:1.31
	sce_410_withVa:1.23
	sce_4_05_20040511:1.16
	sce_4_00_20040201:1.13
	nextGenBranch:1.12.0.2
	nextGenRoot:1.12
	sce_3_30_20030627:1.11
	EndRw-branch:1.8.0.4
	Root-of-EndRw:1.8
	rwToStl:1.8.0.2
	latest_sce_3_10_20010924:1.5.0.2
	sce_3_10_20010924:1.5
	latest_sce_3_00_20010601:1.4.0.4
	sce_3_00_20010601:1.4
	latest_sce_2_31_20010308:1.4.0.2
	sce_2_31_20010308:1.4
	latest_sce_2_31_20001003:1.3.0.2
	sce_2_31_20001003:1.3
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2011.09.28.23.49.37;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.24.00.27.59;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2011.08.30.20.17.42;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2010.10.29.18.18.27;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.16.22.42.26;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.25.19.45.18;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.08.15.11.31;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.09.17.35.34;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.11.22.53.25;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.08.19.46.41;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.02.17.34.03;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.28.21.03.05;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.21.22.23.34;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.21.18.50.59;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.21.15.37.51;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.20.21.47.58;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.20.21.15.11;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.19.14.49.33;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.15.18.57.52;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.06.22.10.50;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.14.18.16.50;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.13.21.18.46;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.11.22.53.49;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.11.19.51.28;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.08.20.48.19;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.13.20.45.27;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.19.22.19.22;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.13.21.50.13;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.25.23.28.07;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.01.21.05.04;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.10.22.58.16;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.23.19.13.21;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.02.23.40.43;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.02.22.18.35;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.15.20.03.45;	author rjw;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.09.19.52.34;	author rjw;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.08.21.58.55;	author rjw;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.21.18.24.31;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.23.11.44;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.10.23.17.45;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.23;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.26;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.26;	author wit;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "MsgMgr.C"
//
// Contains the implementation of the following classes:
//
//    OutputDisplayer.
//    Msg.
//    MsgMgr.
//------------------------------------------------------------------------------

#include <MsgMgr.h>
#include <Msg.h>
#include <OutDisp.h>
#include <MsgBuilder.h>
#include <DataRead.h>
#include <Session.h>
#include <ApiMgr.h>
#include <AbortApiExc.h>
#include <InputID.h>
#include <SaeMgr.h>
#include <Problem.h>
#include <GlobalComp.h>

//------------------------------------------------------------------------------
// Implementation of class OutputDisplayer.
//------------------------------------------------------------------------------

WitOutputDisplayer::WitOutputDisplayer (WitMsgMgr * theMsgMgr):
      MclOutputDisplayer (),

      myMsgMgr_          (theMsgMgr),
      myFile_            (stdout),
      fileName_          ("stdout"),
      accessMode_        ("w")
   {
   }

//------------------------------------------------------------------------------

WitOutputDisplayer::~WitOutputDisplayer ()
   {
   bool closeResult;

   if (myFile_ == stdout)
      fflush (stdout);
   else
      {
      closeResult = fclose (myFile_);

      if (closeResult != 0)
         {
         startNonMsgSevereError ();

         fprintf (stderr,
            "An error was encountered when closing the message file.\n"
            "\n"
            "   File Name: %s\n",
            fileName_.myCstring ());

         finishNonMsgSevereError ();
         }
      }
   }

//------------------------------------------------------------------------------

void WitOutputDisplayer::setAccessMode (const char * theValue)
   {
   accessMode_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOutputDisplayer::setMyFile (FILE * theFile, const char * theName)
   {
   myFile_   = theFile;
   fileName_ = theName;
   }

//------------------------------------------------------------------------------

void WitOutputDisplayer::output (const char * finalText)
   {
   if (     (myMsgMgr_->issuedMsg ()->myLevel () == MclLevel::info ())
         or (myFile_ != stdout))
      {
      fprintf (myFile_, "%s", finalText);
      }

   if (WitSaeMgr::standAloneMode ())
      if (myMsgMgr_->issuedMsg ()->dupToStdout ())
         if (myFile_ != stdout)
            {
            printf ("%s", finalText);
            }
   }

//------------------------------------------------------------------------------

void WitOutputDisplayer::outputError (const char * finalText)
   {
   fflush (myFile ());

   fprintf (stderr, "%s", finalText);

   fflush (stderr);
   }

//------------------------------------------------------------------------------
// Implementation of class Msg.
//------------------------------------------------------------------------------

WitMsg::WitMsg (
         WitMsgMgr *      theMsgMgr,
         WitMsgID         theMsgID,
         const MclLevel & theLevel,
         const char *     textVal,
         int              extNum):

      MclMsg (
         theMsgMgr->myMclFacility (),
         theMsgID,
         theLevel,
         textVal,
         extNum),

      myMsgMgr_       (theMsgMgr),
      delayedSevere_  (false),
      stopRunning_    (true),
      throwErrorExc_  (false),
      dupToStdout_    (false),
      issueDuringRD_  (theLevel >  MclLevel::info ()),
      idInputOnIssue_ (false),
      testable_       (theLevel <= MclLevel::warning ())
   {
   vectorIndent (6);

   myMsgMgr_->record (this);
   }

//------------------------------------------------------------------------------

WitMsg::~WitMsg ()
   {
   }

//------------------------------------------------------------------------------

void WitMsg::delayedSevere (bool theValue)
   {
   int dummyVar;

   if (theValue)
      nonMsgAssert (myLevel () == MclLevel::severe ());

   set (dummyVar, "delayedSevere", theValue);

   delayedSevere_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMsg::stopRunning (bool theValue)
   {
   int dummyVar;

   if (theValue)
      throwErrorExc_ = false;

   set (dummyVar, "stopRunning", theValue);

   stopRunning_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMsg::throwErrorExc (bool theValue)
   {
   int dummyVar;

   if (theValue)
      stopRunning_ = false;

   set (dummyVar, "throwErrorExc", theValue);

   throwErrorExc_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMsg::dupToStdout (bool theValue)
   {
   int dummyVar;

   nonMsgAssert (myLevel () == MclLevel::info ());

   set (dummyVar, "dupToStdout", theValue);

   dupToStdout_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMsg::issueDuringRD (bool theValue)
   {
   int dummyVar;

   set (dummyVar, "issueDuringRD", theValue);

   issueDuringRD_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMsg::idInputOnIssue (bool theValue)
   {
   int dummyVar;

   set (dummyVar, "idInputOnIssue", theValue);

   idInputOnIssue_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMsg::testable (bool theValue)
   {
   int dummyVar;

   set (dummyVar, "testable", theValue);

   testable_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMsg::postIssue ()
   {
   }

//------------------------------------------------------------------------------
// Implementation of class MsgMgr.
//------------------------------------------------------------------------------

WitMsgMgr::WitMsgMgr (WitMsgFacility & theMsgFac):
      myMsgFac_         (theMsgFac),
      myDispPtr_        (NULL),
      myMclFacilityPtr_ (NULL),
      myApiMgr_         (theMsgFac.mySession ()->myApiMgr ()),
      extNumMsg_        (10000),
      errorsIssued_     (false),
      issuedMsg_        (NULL),
      crashOnFatal_     (false)
   {
   myDispPtr_        = new WitOutputDisplayer (this);
   myMclFacilityPtr_ = new MclFacility        ("WIT", myDisp ());

   WitMsgBuilder theBuilder (this);

   theBuilder.buildMsgFrags ();

   theBuilder.buildMsgs ();

   myMclFacility ().booleanMsgFrags (
      myMclFacility ().findMsgFrag ("trueFrag"),
      myMclFacility ().findMsgFrag ("falseFrag"));

   resizeExtNumMsg ();
   }

//------------------------------------------------------------------------------

WitMsgMgr::~WitMsgMgr ()
   {
   delete myMclFacilityPtr_;
   delete myDispPtr_;
   }

//------------------------------------------------------------------------------

void WitMsgMgr::record (WitMsg * theMsg)
   {
   nonMsgAssert (extNumMsg (theMsg->externalNumber ()) == NULL);

   extNumMsg_[theMsg->externalNumber ()] = theMsg;
   }

//------------------------------------------------------------------------------

void WitMsgMgr::issue (WitMsgID theMsgID, const MclArgList & theArgList)
   {
   MclMsg * theMclMsg;
   WitMsg * theMsg;
   WitMsg * prevIssuedMsg;

   theMclMsg = myMclFacility ().findMsg (theMsgID);

   if (theMclMsg == NULL)
      myMsgFac () ("invalidMsgIDFmsg", theMsgID);

   theMsg = myMsg (theMclMsg);

   if (not theMsg->delayedSevere ())
      myApiMgr ()->updateApiRc (theMsg->myLevel ().severity ());

   if (theMsg->myLevel () >= MclLevel::error ())
      errorsIssued_ = true;

   prevIssuedMsg = issuedMsg_;
   issuedMsg_    = theMsg;

   if (issueAllowed (theMsg))
      theMsg->issue (theArgList);

   issuedMsg_    = prevIssuedMsg;

   if (theMsg->myLevel () == MclLevel::fatal ())
      {
      myMsgFac () ("explainFatalMessageMsg");

      if (crashOnFatal_)
         crashForFatal ();
      }

   if (theMsg->idInputOnIssue ())
      myApiMgr ()->myInputID ()->idInput ();

   if (theMsg->myLevel () >= MclLevel::error ())
      if (not theMsg->delayedSevere ())
         throw WitAbortApiExc (theMsg);
   }

//------------------------------------------------------------------------------

WitMsg * WitMsgMgr::myMsg (MclMsg * theMclMsg) const
   {
   WitMsg * theMsg;

   theMsg = extNumMsg (theMclMsg->externalNumber ());

   nonMsgAssert (theMsg != NULL);

   return theMsg;
   }

//------------------------------------------------------------------------------

WitMsg * WitMsgMgr::extNumMsg (int theExtNum) const
   {
   if (theExtNum < 0)
      return NULL;

   if (theExtNum >= extNumMsg_.length ())
      return NULL;

   return extNumMsg_[theExtNum];
   }

//------------------------------------------------------------------------------

bool WitMsgMgr::issueAllowed (WitMsg * theMsg) const
   {
   if (not mySession ()->active ())
      return true;

   if (not mySession ()->myProblem ()->myDataReader ()->active ())
      return true;

   if (mySession ()->myProblem ()->myGlobalComp ()->readDataMsgs ())
      return true;

   return (theMsg->issueDuringRD ());
   }

//------------------------------------------------------------------------------

void WitMsgMgr::setCrashOnFatal (bool theValue)
   {
   crashOnFatal_ = theValue;
   }

//------------------------------------------------------------------------------

void WitMsgMgr::resizeExtNumMsg ()
   {
   int maxExtNum;
   int theExtNum;

   WitPtrVec <WitMsg> tempExtNumMsg;


   maxExtNum = -1;

   for (theExtNum = 0; theExtNum < 10000; ++ theExtNum)
      if (extNumMsg (theExtNum) != NULL)
         maxExtNum = theExtNum;

   tempExtNumMsg.resize (maxExtNum + 1);

   for (theExtNum = 0; theExtNum <= maxExtNum; ++ theExtNum)
      tempExtNumMsg[theExtNum] = extNumMsg_[theExtNum];

   extNumMsg_.resize (maxExtNum + 1);

   extNumMsg_ = tempExtNumMsg;
   }

//------------------------------------------------------------------------------

void WitMsgMgr::crashForFatal ()
   {
   void (* theFunc) ();

   theFunc = NULL;

   myMsgFac () ("crashMsg");

   fflush (stdout);

   theFunc ();
      //
      // Causes a segmentation fault on Linux.
   }
@


1.41
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.40
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d38 1
a38 1
MclOutputDisplayer (),
d40 6
a45 6
myMsgMgr_          (theMsgMgr),
myFile_            (stdout),
fileName_          ("stdout"),
accessMode_        ("w")
{
}
d50 2
a51 2
{
bool closeResult;
d53 20
a72 20
if (myFile_ == stdout)
fflush (stdout);
else
{
closeResult = fclose (myFile_);

if (closeResult != 0)
{
startNonMsgSevereError ();

fprintf (stderr,
"An error was encountered when closing the message file.\n"
"\n"
"   File Name: %s\n",
fileName_.myCstring ());

finishNonMsgSevereError ();
}
}
}
d77 3
a79 3
{
accessMode_ = theValue;
}
d84 4
a87 4
{
myFile_   = theFile;
fileName_ = theName;
}
d92 14
a105 14
{
if (     (myMsgMgr_->issuedMsg ()->myLevel () == MclLevel::info ())
or (myFile_ != stdout))
{
fprintf (myFile_, "%s", finalText);
}

if (WitSaeMgr::standAloneMode ())
if (myMsgMgr_->issuedMsg ()->dupToStdout ())
if (myFile_ != stdout)
{
printf ("%s", finalText);
}
}
d110 2
a111 2
{
fflush (myFile ());
d113 1
a113 1
fprintf (stderr, "%s", finalText);
d115 2
a116 2
fflush (stderr);
}
d123 23
a145 23
WitMsgMgr *      theMsgMgr,
WitMsgID         theMsgID,
const MclLevel & theLevel,
const char *     textVal,
int              extNum):

MclMsg (
theMsgMgr->myMclFacility (),
theMsgID,
theLevel,
textVal,
extNum),

myMsgMgr_       (theMsgMgr),
delayedSevere_  (false),
stopRunning_    (true),
throwErrorExc_  (false),
dupToStdout_    (false),
issueDuringRD_  (theLevel >  MclLevel::info ()),
idInputOnIssue_ (false),
testable_       (theLevel <= MclLevel::warning ())
{
vectorIndent (6);
d147 2
a148 2
myMsgMgr_->record (this);
}
d153 2
a154 2
{
}
d159 2
a160 2
{
int dummyVar;
d162 2
a163 2
if (theValue)
nonMsgAssert (myLevel () == MclLevel::severe ());
d165 1
a165 1
set (dummyVar, "delayedSevere", theValue);
d167 2
a168 2
delayedSevere_ = theValue;
}
d173 2
a174 2
{
int dummyVar;
d176 2
a177 2
if (theValue)
throwErrorExc_ = false;
d179 1
a179 1
set (dummyVar, "stopRunning", theValue);
d181 2
a182 2
stopRunning_ = theValue;
}
d187 2
a188 2
{
int dummyVar;
d190 2
a191 2
if (theValue)
stopRunning_ = false;
d193 1
a193 1
set (dummyVar, "throwErrorExc", theValue);
d195 2
a196 2
throwErrorExc_ = theValue;
}
d201 2
a202 2
{
int dummyVar;
d204 1
a204 1
nonMsgAssert (myLevel () == MclLevel::info ());
d206 1
a206 1
set (dummyVar, "dupToStdout", theValue);
d208 2
a209 2
dupToStdout_ = theValue;
}
d214 2
a215 2
{
int dummyVar;
d217 1
a217 1
set (dummyVar, "issueDuringRD", theValue);
d219 2
a220 2
issueDuringRD_ = theValue;
}
d225 2
a226 2
{
int dummyVar;
d228 1
a228 1
set (dummyVar, "idInputOnIssue", theValue);
d230 2
a231 2
idInputOnIssue_ = theValue;
}
d236 2
a237 2
{
int dummyVar;
d239 1
a239 1
set (dummyVar, "testable", theValue);
d241 2
a242 2
testable_ = theValue;
}
d247 2
a248 2
{
}
d255 21
a275 21
myMsgFac_         (theMsgFac),
myDispPtr_        (NULL),
myMclFacilityPtr_ (NULL),
myApiMgr_         (theMsgFac.mySession ()->myApiMgr ()),
extNumMsg_        (10000),
errorsIssued_     (false),
issuedMsg_        (NULL),
crashOnFatal_     (false)
{
myDispPtr_        = new WitOutputDisplayer (this);
myMclFacilityPtr_ = new MclFacility        ("WIT", myDisp ());

WitMsgBuilder theBuilder (this);

theBuilder.buildMsgFrags ();

theBuilder.buildMsgs ();

myMclFacility ().booleanMsgFrags (
myMclFacility ().findMsgFrag ("trueFrag"),
myMclFacility ().findMsgFrag ("falseFrag"));
d277 2
a278 2
resizeExtNumMsg ();
}
d283 4
a286 4
{
delete myMclFacilityPtr_;
delete myDispPtr_;
}
d291 2
a292 2
{
nonMsgAssert (extNumMsg (theMsg->externalNumber ()) == NULL);
d294 2
a295 2
extNumMsg_[theMsg->externalNumber ()] = theMsg;
}
d300 4
a303 4
{
MclMsg * theMclMsg;
WitMsg * theMsg;
WitMsg * prevIssuedMsg;
d305 1
a305 1
theMclMsg = myMclFacility ().findMsg (theMsgID);
d307 2
a308 2
if (theMclMsg == NULL)
myMsgFac () ("invalidMsgIDFmsg", theMsgID);
d310 1
a310 1
theMsg = myMsg (theMclMsg);
d312 2
a313 2
if (not theMsg->delayedSevere ())
myApiMgr ()->updateApiRc (theMsg->myLevel ().severity ());
d315 2
a316 2
if (theMsg->myLevel () >= MclLevel::error ())
errorsIssued_ = true;
d318 2
a319 2
prevIssuedMsg = issuedMsg_;
issuedMsg_    = theMsg;
d321 2
a322 2
if (issueAllowed (theMsg))
theMsg->issue (theArgList);
d324 1
a324 1
issuedMsg_    = prevIssuedMsg;
d326 3
a328 3
if (theMsg->myLevel () == MclLevel::fatal ())
{
myMsgFac () ("explainFatalMessageMsg");
d330 3
a332 3
if (crashOnFatal_)
crashForFatal ();
}
d334 2
a335 2
if (theMsg->idInputOnIssue ())
myApiMgr ()->myInputID ()->idInput ();
d337 4
a340 4
if (theMsg->myLevel () >= MclLevel::error ())
if (not theMsg->delayedSevere ())
throw WitAbortApiExc (theMsg);
}
d345 2
a346 2
{
WitMsg * theMsg;
d348 1
a348 1
theMsg = extNumMsg (theMclMsg->externalNumber ());
d350 1
a350 1
nonMsgAssert (theMsg != NULL);
d352 2
a353 2
return theMsg;
}
d358 3
a360 3
{
if (theExtNum < 0)
return NULL;
d362 2
a363 2
if (theExtNum >= extNumMsg_.length ())
return NULL;
d365 2
a366 2
return extNumMsg_[theExtNum];
}
d371 3
a373 3
{
if (not mySession ()->active ())
return true;
d375 2
a376 2
if (not mySession ()->myProblem ()->myDataReader ()->active ())
return true;
d378 2
a379 2
if (mySession ()->myProblem ()->myGlobalComp ()->readDataMsgs ())
return true;
d381 2
a382 2
return (theMsg->issueDuringRD ());
}
d387 3
a389 3
{
crashOnFatal_ = theValue;
}
d394 3
a396 3
{
int maxExtNum;
int theExtNum;
d398 1
a398 1
WitPtrVec <WitMsg> tempExtNumMsg;
d401 1
a401 1
maxExtNum = -1;
d403 3
a405 3
for (theExtNum = 0; theExtNum < 10000; ++ theExtNum)
if (extNumMsg (theExtNum) != NULL)
maxExtNum = theExtNum;
d407 1
a407 1
tempExtNumMsg.resize (maxExtNum + 1);
d409 2
a410 2
for (theExtNum = 0; theExtNum <= maxExtNum; ++ theExtNum)
tempExtNumMsg[theExtNum] = extNumMsg_[theExtNum];
d412 1
a412 1
extNumMsg_.resize (maxExtNum + 1);
d414 2
a415 2
extNumMsg_ = tempExtNumMsg;
}
d420 2
a421 2
{
void (* theFunc) ();
d423 1
a423 1
theFunc = NULL;
d425 1
a425 1
myMsgFac () ("crashMsg");
d427 1
a427 1
fflush (stdout);
d429 4
a432 4
theFunc ();
//
// Causes a segmentation fault on Linux.
}
@


1.39
log
@Changed some file names.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d38 1
a38 1
      MclOutputDisplayer (),
d40 6
a45 6
      myMsgMgr_          (theMsgMgr),
      myFile_            (stdout),
      fileName_          ("stdout"),
      accessMode_        ("w")
   {
   }
d50 2
a51 2
   {
   bool closeResult;
d53 20
a72 20
   if (myFile_ == stdout)
      fflush (stdout);
   else
      {
      closeResult = fclose (myFile_);

      if (closeResult != 0)
         {
         startNonMsgSevereError ();

         fprintf (stderr,
            "An error was encountered when closing the message file.\n"
            "\n"
            "   File Name: %s\n",
            fileName_.myCstring ());

         finishNonMsgSevereError ();
         }
      }
   }
d77 3
a79 3
   {
   accessMode_ = theValue;
   }
d84 4
a87 4
   {
   myFile_   = theFile;
   fileName_ = theName;
   }
d92 14
a105 14
   {
   if (     (myMsgMgr_->issuedMsg ()->myLevel () == MclLevel::info ())
         or (myFile_ != stdout))
      {
      fprintf (myFile_, "%s", finalText);
      }

   if (WitSaeMgr::standAloneMode ())
      if (myMsgMgr_->issuedMsg ()->dupToStdout ())
         if (myFile_ != stdout)
            {
            printf ("%s", finalText);
            }
   }
d110 2
a111 2
   {
   fflush (myFile ());
d113 1
a113 1
   fprintf (stderr, "%s", finalText);
d115 2
a116 2
   fflush (stderr);
   }
d123 23
a145 23
         WitMsgMgr *      theMsgMgr,
         WitMsgID         theMsgID,
         const MclLevel & theLevel,
         const char *     textVal,
         int              extNum):

      MclMsg (
         theMsgMgr->myMclFacility (),
         theMsgID,
         theLevel,
         textVal,
         extNum),

      myMsgMgr_       (theMsgMgr),
      delayedSevere_  (false),
      stopRunning_    (true),
      throwErrorExc_  (false),
      dupToStdout_    (false),
      issueDuringRD_  (theLevel >  MclLevel::info ()),
      idInputOnIssue_ (false),
      testable_       (theLevel <= MclLevel::warning ())
   {
   vectorIndent (6);
d147 2
a148 2
   myMsgMgr_->record (this);
   }
d153 2
a154 2
   {
   }
d159 2
a160 2
   {
   int dummyVar;
d162 2
a163 2
   if (theValue)
      nonMsgAssert (myLevel () == MclLevel::severe ());
d165 1
a165 1
   set (dummyVar, "delayedSevere", theValue);
d167 2
a168 2
   delayedSevere_ = theValue;
   }
d173 2
a174 2
   {
   int dummyVar;
d176 2
a177 2
   if (theValue)
      throwErrorExc_ = false;
d179 1
a179 1
   set (dummyVar, "stopRunning", theValue);
d181 2
a182 2
   stopRunning_ = theValue;
   }
d187 2
a188 2
   {
   int dummyVar;
d190 2
a191 2
   if (theValue)
      stopRunning_ = false;
d193 1
a193 1
   set (dummyVar, "throwErrorExc", theValue);
d195 2
a196 2
   throwErrorExc_ = theValue;
   }
d201 2
a202 2
   {
   int dummyVar;
d204 1
a204 1
   nonMsgAssert (myLevel () == MclLevel::info ());
d206 1
a206 1
   set (dummyVar, "dupToStdout", theValue);
d208 2
a209 2
   dupToStdout_ = theValue;
   }
d214 2
a215 2
   {
   int dummyVar;
d217 1
a217 1
   set (dummyVar, "issueDuringRD", theValue);
d219 2
a220 2
   issueDuringRD_ = theValue;
   }
d225 2
a226 2
   {
   int dummyVar;
d228 1
a228 1
   set (dummyVar, "idInputOnIssue", theValue);
d230 2
a231 2
   idInputOnIssue_ = theValue;
   }
d236 2
a237 2
   {
   int dummyVar;
d239 1
a239 1
   set (dummyVar, "testable", theValue);
d241 2
a242 2
   testable_ = theValue;
   }
d247 2
a248 2
   {
   }
d255 21
a275 21
      myMsgFac_         (theMsgFac),
      myDispPtr_        (NULL),
      myMclFacilityPtr_ (NULL),
      myApiMgr_         (theMsgFac.mySession ()->myApiMgr ()),
      extNumMsg_        (10000),
      errorsIssued_     (false),
      issuedMsg_        (NULL),
      crashOnFatal_     (false)
   {
   myDispPtr_        = new WitOutputDisplayer (this);
   myMclFacilityPtr_ = new MclFacility        ("WIT", myDisp ());

   WitMsgBuilder theBuilder (this);

   theBuilder.buildMsgFrags ();

   theBuilder.buildMsgs ();

   myMclFacility ().booleanMsgFrags (
      myMclFacility ().findMsgFrag ("trueFrag"),
      myMclFacility ().findMsgFrag ("falseFrag"));
d277 2
a278 2
   resizeExtNumMsg ();
   }
d283 4
a286 4
   {
   delete myMclFacilityPtr_;
   delete myDispPtr_;
   }
d291 2
a292 2
   {
   nonMsgAssert (extNumMsg (theMsg->externalNumber ()) == NULL);
d294 2
a295 2
   extNumMsg_[theMsg->externalNumber ()] = theMsg;
   }
d300 4
a303 4
   {
   MclMsg * theMclMsg;
   WitMsg * theMsg;
   WitMsg * prevIssuedMsg;
d305 1
a305 1
   theMclMsg = myMclFacility ().findMsg (theMsgID);
d307 2
a308 2
   if (theMclMsg == NULL)
      myMsgFac () ("invalidMsgIDFmsg", theMsgID);
d310 1
a310 1
   theMsg = myMsg (theMclMsg);
d312 2
a313 2
   if (not theMsg->delayedSevere ())
      myApiMgr ()->updateApiRc (theMsg->myLevel ().severity ());
d315 2
a316 2
   if (theMsg->myLevel () >= MclLevel::error ())
      errorsIssued_ = true;
d318 2
a319 2
   prevIssuedMsg = issuedMsg_;
   issuedMsg_    = theMsg;
d321 2
a322 2
   if (issueAllowed (theMsg))
      theMsg->issue (theArgList);
d324 1
a324 1
   issuedMsg_    = prevIssuedMsg;
d326 3
a328 3
   if (theMsg->myLevel () == MclLevel::fatal ())
      {
      myMsgFac () ("explainFatalMessageMsg");
d330 3
a332 3
      if (crashOnFatal_)
         crashForFatal ();
      }
d334 2
a335 2
   if (theMsg->idInputOnIssue ())
      myApiMgr ()->myInputID ()->idInput ();
d337 4
a340 4
   if (theMsg->myLevel () >= MclLevel::error ())
      if (not theMsg->delayedSevere ())
         throw WitAbortApiExc (theMsg);
   }
d345 2
a346 2
   {
   WitMsg * theMsg;
d348 1
a348 1
   theMsg = extNumMsg (theMclMsg->externalNumber ());
d350 1
a350 1
   nonMsgAssert (theMsg != NULL);
d352 2
a353 2
   return theMsg;
   }
d358 3
a360 3
   {
   if (theExtNum < 0)
      return NULL;
d362 2
a363 2
   if (theExtNum >= extNumMsg_.length ())
      return NULL;
d365 2
a366 2
   return extNumMsg_[theExtNum];
   }
d371 3
a373 3
   {
   if (not mySession ()->active ())
      return true;
d375 2
a376 2
   if (not mySession ()->myProblem ()->myDataReader ()->active ())
      return true;
d378 2
a379 2
   if (mySession ()->myProblem ()->myGlobalComp ()->readDataMsgs ())
      return true;
d381 2
a382 2
   return (theMsg->issueDuringRD ());
   }
d387 3
a389 3
   {
   crashOnFatal_ = theValue;
   }
d394 3
a396 3
   {
   int maxExtNum;
   int theExtNum;
d398 1
a398 1
   WitPtrVec <WitMsg> tempExtNumMsg;
d401 1
a401 1
   maxExtNum = -1;
d403 3
a405 3
   for (theExtNum = 0; theExtNum < 10000; ++ theExtNum)
      if (extNumMsg (theExtNum) != NULL)
         maxExtNum = theExtNum;
d407 1
a407 1
   tempExtNumMsg.resize (maxExtNum + 1);
d409 2
a410 2
   for (theExtNum = 0; theExtNum <= maxExtNum; ++ theExtNum)
      tempExtNumMsg[theExtNum] = extNumMsg_[theExtNum];
d412 1
a412 1
   extNumMsg_.resize (maxExtNum + 1);
d414 2
a415 2
   extNumMsg_ = tempExtNumMsg;
   }
d420 2
a421 2
   {
   void (* theFunc) ();
d423 1
a423 1
   theFunc = NULL;
d425 1
a425 1
   myMsgFac () ("crashMsg");
d427 1
a427 1
   fflush (stdout);
d429 4
a432 4
   theFunc ();
      //
      // Causes a segmentation fault on Linux.
   }
@


1.38
log
@Changed source file names:
   Global.h ==> GlobalComp.h
   Global.C ==> GlobalComp.C
@
text
@d23 1
a23 1
#include <MsgBuild.h>
@


1.37
log
@Multi-objective mode
@
text
@d31 1
a31 1
#include <Global.h>
@


1.36
log
@Changed the default value of msegFileAccessMode from "a" to 'w".
@
text
@d78 1
a78 1
   accessMode_.copyCstring (theValue);
d85 2
a86 3
   myFile_ = theFile;

   fileName_.copyCstring (theName);
@


1.35
log
@Stochastic Implosion
@
text
@d43 1
a43 1
      accessMode_        ("a")
@


1.34
log
@witCopy<Object>Data
@
text
@d94 1
a94 2
   if (
            (myMsgMgr_->issuedMsg ()->myLevel () == MclLevel::info ())
d96 1
d98 1
d102 4
a105 1
         printf ("%s", finalText);
@


1.33
log
@witCopy<Object>Data.
@
text
@d336 1
a336 1
         throw WitAbortApiExc (theMsg->externalNumber ());
@


1.32
log
@Updated the copyright date on all source files.
@
text
@d155 1
a155 1
WitMsg * WitMsg::delayedSevere (bool theValue)
a164 2

   return this;
d169 1
a169 1
WitMsg * WitMsg::stopRunning (bool theValue)
a178 2

   return this;
d183 1
a183 1
WitMsg * WitMsg::throwErrorExc (bool theValue)
a192 2

   return this;
d197 1
a197 1
WitMsg * WitMsg::dupToStdout (bool theValue)
a205 2

   return this;
d210 1
a210 1
WitMsg * WitMsg::issueDuringRD (bool theValue)
a216 2

   return this;
d221 1
a221 1
WitMsg * WitMsg::idInputOnIssue (bool theValue)
a227 2

   return this;
d232 1
a232 1
WitMsg * WitMsg::testable (bool theValue)
a238 2

   return this;
@


1.31
log
@[error recovery]
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.30
log
@[error recovery]
@
text
@d386 1
a386 1
   if (not mySession ()->myProblem ()->myDataReader ()->thisReadDataActive ())
@


1.29
log
@Minor updates.
@
text
@d350 1
a350 5
         {
         WitAbortApiExc theAbortApiExc (theMsg->externalNumber ());

         throw theAbortApiExc;
         }
d386 1
a386 1
   if (not mySession ()->myProblem ()->myDataReader ()->readingData ())
@


1.28
log
@Fixed a bug that occurred when witCopyData issued a severe error.
@
text
@d350 5
a354 1
         abort (theMsg);
d446 1
a446 21
      // Causes an "Illegal instruction(coredump)" on AIX.
   }

//------------------------------------------------------------------------------

void WitMsgMgr::abort (const WitMsg * theMsg) const
   {
   if (theMsg->stopRunning ())
      {
      myMsgFac () ("witStopsMsg", theMsg->myLevel ().severity ());

      fflush (stdout);

      exit (theMsg->myLevel ().severity ());
      }
   else
      {
      WitAbortApiExc theAbortApiExc (theMsg->externalNumber ());

      throw theAbortApiExc;
      }
@


1.27
log
@[multi-thread]
@
text
@d27 1
d457 3
d461 2
a462 1
   myApiMgr ()->abortApiFunc (theMsg->externalNumber ());
@


1.26
log
@[multi-thread]
@
text
@d28 1
d98 1
a98 1
   if (myMsgMgr_->myApiMgr ()->standAloneMode ())
@


1.25
log
@Updated WIT's exception throwing capability.
@
text
@d97 1
a97 1
   if (not myMsgMgr_->myApiMgr ()->apiMode ())
@


1.24
log
@[multi-thread]
@
text
@d134 1
a134 1
      throwException_ (false),
d174 1
a174 1
      throwException_ = false;
d185 1
a185 1
WitMsg * WitMsg::throwException (bool theValue)
d192 1
a192 1
   set (dummyVar, "throwException", theValue);
d194 1
a194 1
   throwException_ = theValue;
@


1.23
log
@Fixed bug:
   When witSetMesgStopRunning was called with
   (msg #) == (last existing msg # + 1), WIT issued a fatal error.
@
text
@d158 1
a158 1
      witAssert (myLevel () == MclLevel::severe ());
d205 1
a205 1
   witAssert (myLevel () == MclLevel::info ());
d301 1
a301 1
   witAssert (extNumMsg (theMsg->externalNumber ()) == NULL);
d359 1
a359 1
   witAssert (theMsg != NULL);
@


1.22
log
@[exceptions]
@
text
@d371 1
a371 1
   if (theExtNum > extNumMsg_.length ())
@


1.21
log
@[exceptions]
@
text
@d133 1
a133 1
      stopOnAbort_    (true),
d169 1
a169 1
WitMsg * WitMsg::stopOnAbort (bool theValue)
d176 1
a176 1
   set (dummyVar, "stopOnAbort", theValue);
d178 1
a178 1
   stopOnAbort_ = theValue;
d190 1
a190 1
      stopOnAbort_ = false;
d447 1
a447 1
   if (theMsg->stopOnAbort ())
@


1.20
log
@[exceptions]
@
text
@d27 1
d344 1
a344 1
      myApiMgr ()->myInputId ()->idInput ();
a446 3
   if (theMsg->throwException ())
      myApiMgr ()->abortApiFunc (true);

d456 1
a456 1
   myApiMgr ()->abortApiFunc (false);
@


1.19
log
@[exceptions]
@
text
@d133 1
d172 3
d184 16
d446 2
a447 2
   if (myApiMgr ()->throwExcOnError ())
      myApiMgr ()->returnToApp ();
d457 2
a458 2
   else
      myApiMgr ()->returnToApp ();
@


1.18
log
@[exceptions]
@
text
@d20 3
@


1.17
log
@Made behavior of severe errors with delayed aborting consistent between
mesgStopRunning = true mode and mesgStopRunning = false mode.
@
text
@d423 3
d435 1
a435 1
      myApiMgr ()->directlyReturnToCaller ();
@


1.16
log
@Minor correction.
@
text
@d128 1
a128 1
      abortOnIssue_   (theLevel >= MclLevel::error ()),
d148 1
a148 1
WitMsg * WitMsg::abortOnIssue (bool theValue)
d152 2
a153 1
   set (dummyVar, "abortOnIssue", theValue);
d155 3
a157 1
   abortOnIssue_ = theValue;
d297 2
a298 1
   myApiMgr ()->updateApiRc (theMsg->myLevel ().severity ());
d322 3
a324 2
   if (theMsg->abortOnIssue ())
      abort (theMsg);
@


1.15
log
@Double Precision.
@
text
@d244 1
a244 2
//    crashOnFatal_     (false)
      crashOnFatal_     (true)
@


1.14
log
@Double Precision.
@
text
@d395 1
a395 1
   extNumMsg_.copy (tempExtNumMsg);
@


1.13
log
@Continued implementation of PIP.
@
text
@d244 2
a245 1
      crashOnFatal_     (false)
@


1.12
log
@Added some optional warnings on Linux.
@
text
@d55 1
a55 1
         WitUtil::startNonMsgSevereError ();
d63 1
a63 1
         WitUtil::finishNonMsgSevereError ();
@


1.11
log
@Replaced some C style casts with C++ style casts.
@
text
@d118 1
a118 1
         int              externalNumber):
d125 1
a125 1
         externalNumber),
d128 1
a128 1

a129 1
      abortOnIssue_   (theLevel >= MclLevel::error ()),
@


1.10
log
@Internal changes.
@
text
@d346 1
a346 1
   return (WitMsg *) extNumMsg_[theExtNum];
@


1.9
log
@Internal changes.
@
text
@d89 2
a90 2
         (myMsgMgr_->issuedMsg ()->myLevel () == MclLevel::info ()) ||
         (myFile_ != stdout))
d93 1
a93 1
   if (! myMsgMgr_->myApiMgr ()->apiMode ())
d353 1
a353 1
   if (! mySession ()->active ())
d356 1
a356 1
   if (! mySession ()->myProblem ()->myDataReader ()->readingData ())
@


1.8
log
@Continued implementation of opt implosion with OSL V3.
@
text
@d45 1
a45 1
   WitBoolean closeResult;
d129 1
a129 1
      stopOnAbort_    (witTRUE),
d131 1
a131 1
      dupToStdout_    (witFALSE),
d133 1
a133 1
      idInputOnIssue_ (witFALSE),
d149 1
a149 1
WitMsg * WitMsg::abortOnIssue (WitBoolean theValue)
d151 5
a155 1
   set (abortOnIssue_, "abortOnIssue", theValue);
d162 1
a162 1
WitMsg * WitMsg::stopOnAbort (WitBoolean theValue)
d164 5
a168 1
   set (stopOnAbort_, "stopOnAbort", theValue);
d175 1
a175 1
WitMsg * WitMsg::dupToStdout (WitBoolean theValue)
d177 2
d181 3
a183 1
   set (dupToStdout_, "dupToStdout", theValue);
d190 1
a190 1
WitMsg * WitMsg::issueDuringRD (WitBoolean theValue)
d192 5
a196 1
   set (issueDuringRD_, "issueDuringRD", theValue);
d203 1
a203 1
WitMsg * WitMsg::idInputOnIssue (WitBoolean theValue)
d205 5
a209 1
   set (idInputOnIssue_, "idInputOnIssue", theValue);
d216 1
a216 1
WitMsg * WitMsg::testable (WitBoolean theValue)
d218 5
a222 1
   set (testable_, "testable", theValue);
d243 1
a243 1
      errorsIssued_     (witFALSE),
d245 1
a245 1
      crashOnFatal_     (witFALSE)
d298 1
a298 1
      errorsIssued_ = witTRUE;
d351 1
a351 1
WitBoolean WitMsgMgr::issueAllowed (WitMsg * theMsg) const
d354 1
a354 1
      return witTRUE;
d357 1
a357 1
      return witTRUE;
d360 1
a360 1
      return witTRUE;
d367 1
a367 1
void WitMsgMgr::setCrashOnFatal (WitBoolean theValue)
@


1.7
log
@Continued implementation of single-source.
@
text
@a394 3
   if (mySession ()->active ())
      mySession ()->myProblem ()->closeFilesAtExit ();

@


1.6
log
@Preliminary work on single source.
@
text
@d36 2
a37 2
      fileName_          (* new WitString ("stdout")),
      accessMode_        (* new WitString ("a"))
a65 3

   delete & accessMode_;
   delete & fileName_;
@


1.5
log
@More templates.
@
text
@d75 1
a75 1
   accessMode_ = theValue;
d82 3
a84 2
   myFile_   = theFile;
   fileName_ = theName;
d374 1
a374 1
   extNumMsg_ = tempExtNumMsg;
@


1.4
log
@Refactoring for selection splitting.
@
text
@d357 1
a357 1
   WitPtrVec (WitMsg) tempExtNumMsg;
@


1.3
log
@Replaced "PRM" with "WIT".
Replaced "Production Resource Manager" with "Watson Implosion Technology".
Upgraded release # to 6.0.
@
text
@d220 1
a220 1
      extNumMsgTl_      (10000, NULL),
d255 1
a255 1
   extNumMsgRef (theMsg->externalNumber ()) = theMsg;
d321 1
a321 1
   if (theExtNum > extNumMsgTl_.length ())
d324 1
a324 1
   return (WitMsg *) extNumMsgTl_[theExtNum];
d357 1
a357 1
   WitVector (WitTypelessPtr) tempExtNumMsgTl;
d366 1
a366 1
   tempExtNumMsgTl.resize (maxExtNum + 1, NULL);
d369 1
a369 1
      tempExtNumMsgTl[theExtNum] = extNumMsgTl_[theExtNum];
d371 1
a371 1
   extNumMsgTl_.resize (maxExtNum + 1, NULL);
d373 1
a373 1
   extNumMsgTl_ = tempExtNumMsgTl;
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d402 1
a402 1
      myMsgFac () ("prmStopsMsg", theMsg->myLevel ().severity ());
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@

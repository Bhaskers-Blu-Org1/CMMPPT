head	1.147;
access;
symbols
	sce_5_01_20080919:1.67
	latest_sce_4_20_20060523:1.45.0.2
	sce_4_20_20060523:1.45
	latest_sce4_20_OSL:1.41.0.2
	sce_4_20_OSL:1.41
	sce_410_withVa:1.40
	sce_4_05_20040511:1.34
	sce_4_00_20040201:1.32
	nextGenBranch:1.26.0.2
	nextGenRoot:1.26
	sce_3_30_20030627:1.24
	EndRw-branch:1.18.0.4
	Root-of-EndRw:1.18
	rwToStl:1.18.0.2
	latest_sce_3_10_20010924:1.8.0.2
	sce_3_10_20010924:1.8
	latest_sce_3_00_20010601:1.6.0.2
	sce_3_00_20010601:1.6
	latest_sce_2_31_20010308:1.5.0.2
	sce_2_31_20010308:1.5
	latest_sce_2_31_20001003:1.2.0.2
	sce_2_31_20001003:1.2
	start:1.1.1.1
	IBM:1.1.1;
locks; strict;
comment	@ * @;


1.147
date	2011.09.28.23.49.45;	author rjw;	state Exp;
branches;
next	1.146;

1.146
date	2011.09.24.00.28.06;	author rjw;	state Exp;
branches;
next	1.145;

1.145
date	2011.08.30.20.17.47;	author rjw;	state Exp;
branches;
next	1.144;

1.144
date	2011.08.30.18.14.52;	author rjw;	state Exp;
branches;
next	1.143;

1.143
date	2011.08.26.22.54.48;	author rjw;	state Exp;
branches;
next	1.142;

1.142
date	2011.08.25.23.27.03;	author rjw;	state Exp;
branches;
next	1.141;

1.141
date	2011.03.02.00.21.13;	author rjw;	state Exp;
branches;
next	1.140;

1.140
date	2011.02.28.18.50.41;	author rjw;	state Exp;
branches;
next	1.139;

1.139
date	2011.02.18.22.28.18;	author rjw;	state Exp;
branches;
next	1.138;

1.138
date	2011.02.16.17.02.44;	author rjw;	state Exp;
branches;
next	1.137;

1.137
date	2011.02.15.23.26.02;	author rjw;	state Exp;
branches;
next	1.136;

1.136
date	2011.02.15.21.20.16;	author rjw;	state Exp;
branches;
next	1.135;

1.135
date	2011.02.10.00.46.33;	author rjw;	state Exp;
branches;
next	1.134;

1.134
date	2011.02.09.23.31.44;	author rjw;	state Exp;
branches;
next	1.133;

1.133
date	2011.02.09.21.27.51;	author rjw;	state Exp;
branches;
next	1.132;

1.132
date	2011.02.09.19.13.24;	author rjw;	state Exp;
branches;
next	1.131;

1.131
date	2011.02.08.23.54.40;	author rjw;	state Exp;
branches;
next	1.130;

1.130
date	2011.02.08.23.21.10;	author rjw;	state Exp;
branches;
next	1.129;

1.129
date	2011.02.08.21.49.04;	author rjw;	state Exp;
branches;
next	1.128;

1.128
date	2011.02.07.15.45.57;	author rjw;	state Exp;
branches;
next	1.127;

1.127
date	2011.01.31.21.21.53;	author rjw;	state Exp;
branches;
next	1.126;

1.126
date	2011.01.27.19.55.49;	author rjw;	state Exp;
branches;
next	1.125;

1.125
date	2011.01.25.00.22.59;	author rjw;	state Exp;
branches;
next	1.124;

1.124
date	2011.01.24.23.57.07;	author rjw;	state Exp;
branches;
next	1.123;

1.123
date	2011.01.20.00.26.47;	author rjw;	state Exp;
branches;
next	1.122;

1.122
date	2011.01.19.00.20.51;	author rjw;	state Exp;
branches;
next	1.121;

1.121
date	2011.01.18.23.27.19;	author rjw;	state Exp;
branches;
next	1.120;

1.120
date	2011.01.14.00.35.20;	author rjw;	state Exp;
branches;
next	1.119;

1.119
date	2011.01.12.23.09.29;	author rjw;	state Exp;
branches;
next	1.118;

1.118
date	2011.01.11.22.08.28;	author rjw;	state Exp;
branches;
next	1.117;

1.117
date	2011.01.08.00.19.26;	author rjw;	state Exp;
branches;
next	1.116;

1.116
date	2011.01.06.23.31.27;	author rjw;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.14.00.22.49;	author rjw;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.04.00.29.44;	author rjw;	state Exp;
branches;
next	1.113;

1.113
date	2010.12.03.17.19.04;	author rjw;	state Exp;
branches;
next	1.112;

1.112
date	2010.11.17.20.20.52;	author rjw;	state Exp;
branches;
next	1.111;

1.111
date	2010.11.12.22.23.19;	author rjw;	state Exp;
branches;
next	1.110;

1.110
date	2010.10.29.18.07.07;	author rjw;	state Exp;
branches;
next	1.109;

1.109
date	2010.10.19.20.13.46;	author rjw;	state Exp;
branches;
next	1.108;

1.108
date	2010.10.14.16.07.27;	author rjw;	state Exp;
branches;
next	1.107;

1.107
date	2010.10.12.22.02.21;	author rjw;	state Exp;
branches;
next	1.106;

1.106
date	2010.10.12.19.48.28;	author rjw;	state Exp;
branches;
next	1.105;

1.105
date	2010.10.07.15.41.00;	author rjw;	state Exp;
branches;
next	1.104;

1.104
date	2010.09.10.22.10.39;	author rjw;	state Exp;
branches;
next	1.103;

1.103
date	2010.08.24.16.30.30;	author rjw;	state Exp;
branches;
next	1.102;

1.102
date	2010.08.19.18.00.13;	author rjw;	state Exp;
branches;
next	1.101;

1.101
date	2010.05.28.18.08.30;	author rjw;	state Exp;
branches;
next	1.100;

1.100
date	2010.05.28.14.40.36;	author rjw;	state Exp;
branches;
next	1.99;

1.99
date	2010.05.27.23.06.03;	author rjw;	state Exp;
branches;
next	1.98;

1.98
date	2010.05.21.20.07.08;	author rjw;	state Exp;
branches;
next	1.97;

1.97
date	2010.05.21.18.17.56;	author rjw;	state Exp;
branches;
next	1.96;

1.96
date	2010.05.21.15.28.01;	author rjw;	state Exp;
branches;
next	1.95;

1.95
date	2010.05.20.23.24.16;	author rjw;	state Exp;
branches;
next	1.94;

1.94
date	2010.05.20.23.18.43;	author rjw;	state Exp;
branches;
next	1.93;

1.93
date	2010.05.19.21.09.04;	author rjw;	state Exp;
branches;
next	1.92;

1.92
date	2010.05.19.20.34.10;	author rjw;	state Exp;
branches;
next	1.91;

1.91
date	2010.05.17.15.48.49;	author rjw;	state Exp;
branches;
next	1.90;

1.90
date	2010.05.14.23.49.06;	author rjw;	state Exp;
branches;
next	1.89;

1.89
date	2010.05.14.21.42.32;	author rjw;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.14.20.54.46;	author rjw;	state Exp;
branches;
next	1.87;

1.87
date	2010.03.26.22.22.53;	author rjw;	state Exp;
branches;
next	1.86;

1.86
date	2010.03.16.20.22.39;	author rjw;	state Exp;
branches;
next	1.85;

1.85
date	2010.03.09.20.12.24;	author rjw;	state Exp;
branches;
next	1.84;

1.84
date	2010.03.05.00.10.14;	author rjw;	state Exp;
branches;
next	1.83;

1.83
date	2010.02.01.22.10.14;	author rjw;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.25.19.45.18;	author rjw;	state Exp;
branches;
next	1.81;

1.81
date	2009.12.31.20.45.09;	author rjw;	state Exp;
branches;
next	1.80;

1.80
date	2009.12.31.17.10.09;	author rjw;	state Exp;
branches;
next	1.79;

1.79
date	2009.12.30.23.08.01;	author rjw;	state Exp;
branches;
next	1.78;

1.78
date	2009.12.11.22.03.13;	author rjw;	state Exp;
branches;
next	1.77;

1.77
date	2009.12.02.20.06.07;	author rjw;	state Exp;
branches;
next	1.76;

1.76
date	2009.12.01.23.34.38;	author rjw;	state Exp;
branches;
next	1.75;

1.75
date	2009.12.01.22.42.27;	author rjw;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.26.00.24.09;	author rjw;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.18.19.00.01;	author rjw;	state Exp;
branches;
next	1.72;

1.72
date	2009.11.17.23.45.48;	author rjw;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.17.22.54.49;	author rjw;	state Exp;
branches;
next	1.70;

1.70
date	2009.11.17.19.31.38;	author rjw;	state Exp;
branches;
next	1.69;

1.69
date	2009.11.13.19.01.25;	author rjw;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.12.17.36.36;	author rjw;	state Exp;
branches;
next	1.67;

1.67
date	2008.02.27.23.19.10;	author rjw;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.13.20.17.39;	author rjw;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.15.21.50.35;	author rjw;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.28.22.08.26;	author rjw;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.11.18.55.19;	author rjw;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.11.18.09.17;	author rjw;	state Exp;
branches;
next	1.61;

1.61
date	2007.08.07.21.22.36;	author rjw;	state Exp;
branches;
next	1.60;

1.60
date	2007.08.01.22.41.57;	author rjw;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.08.21.54.42;	author rjw;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.25.19.56.54;	author rjw;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.06.19.34.17;	author rjw;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.05.20.23.52;	author rjw;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.03.22.04.04;	author rjw;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.27.19.59.32;	author rjw;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.08.00.14.25;	author rjw;	state Exp;
branches;
next	1.52;

1.52
date	2006.12.06.19.52.46;	author rjw;	state Exp;
branches;
next	1.51;

1.51
date	2006.12.01.21.36.35;	author rjw;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.01.19.55.17;	author rjw;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.29.22.56.40;	author rjw;	state Exp;
branches;
next	1.48;

1.48
date	2006.09.29.18.40.58;	author rjw;	state Exp;
branches;
next	1.47;

1.47
date	2006.09.21.15.42.26;	author rjw;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.17.19.36.39;	author rjw;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.16.22.01.07;	author rjw;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.02.17.34.05;	author rjw;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.20.15.42.09;	author rjw;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.18.14.31.03;	author rjw;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.24.20.49.13;	author rjw;	state Exp;
branches;
next	1.40;

1.40
date	2005.06.09.17.30.39;	author rjw;	state Exp;
branches;
next	1.39;

1.39
date	2005.06.08.18.39.28;	author rjw;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.17.17.30.43;	author rjw;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.30.20.23.31;	author rjw;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.21.21.49.26;	author rjw;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.12.21.29.50;	author rjw;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.12.19.13.40;	author rjw;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.06.00.17.33;	author rjw;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.15.23.06.11;	author rjw;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.04.19.32.47;	author rjw;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.03.18.09.57;	author rjw;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.01.23.05.39;	author rjw;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.01.21.01.38;	author rjw;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.29.21.07.35;	author rjw;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.28.20.34.12;	author rjw;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.09.20.56.44;	author rjw;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.20.19.03.27;	author rjw;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.30.18.19.10;	author rjw;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.28.22.19.30;	author rjw;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.24.20.40.19;	author rjw;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.02.23.40.45;	author rjw;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.02.22.18.38;	author rjw;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.11.19.53.55;	author rjw;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.11.18.53.11;	author rjw;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.09.16.04.37;	author rjw;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.29.17.57.50;	author rjw;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.23.18.09.13;	author rjw;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.22.14.01.47;	author rjw;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.08.21.58.55;	author rjw;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.22.14.32.11;	author rjw;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.18.14.02.38;	author rjw;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.29.23.47.09;	author rjw;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.30.15.51.48;	author bobw;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.29.21.37.19;	author bobw;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.17.15.11.16;	author bobw;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.20.00.44.20;	author bobw;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.04.22.27.52;	author bobw;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.20.03.26;	author bobw;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.07.16.56.30;	author fasano;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.24.13.53.27;	author wit;	state Exp;
branches;
next	;


desc
@@


1.147
log
@Revised the source code proprietary statement.
@
text
@//==============================================================================
// IBM Confidential
//
// OCO Source Materials
//
// Watson Implosion Technology
//
// (C) Copyright IBM Corp. 1993, 2011  All Rights Reserved
//
// The Source code for this program is not published or otherwise divested of
// its trade secrets, irrespective of what has been deposited with the U. S.
// Copyright office.
//==============================================================================

//------------------------------------------------------------------------------
// Source file: "OptComp.C"
//
// Contains the implementation of class OptComp.
//------------------------------------------------------------------------------

#include <OptComp.h>
#include <OptStarter.h>
#include <CpxParSpecMgr.h>
#include <MultiObjMgr.h>
#include <Objective.h>
#include <Pre.h>
#include <Part.h>
#include <DataWrit.h>
#include <DetOptImpMgr.h>
#include <StochImpMgr.h>
#include <Material.h>
#include <Operation.h>
#include <SubEntry.h>
#include <CplexGateway.h>
#include <wit/src/Variant.h>
#include <wit.h>
#include <CompMgr.h>
#include <MsgFac.h>
#include <MsgFrag.h>

//------------------------------------------------------------------------------

inline double & WitOptComp::sglObjValue () const
   {
   witAssert (not multiObjMode_);

   return * sglObjValuePtr_;
   }

//------------------------------------------------------------------------------

WitOptComp::WitOptComp (WitCompMgr * theCompMgr):
      WitComponent       (theCompMgr),

       heurOptStarter_   (NULL),
        accOptStarter_   (NULL),
      schedOptStarter_   (NULL),
      crashOptStarter_   (NULL),

      allOptStarters_    (),
      myCpxParSpecMgr_   (NULL),
      myMultiObjMgr_     (NULL),

      compPrices_        (defCompPrices        ()),
      accAfterOptImp_    (defAccAfterOptImp    ()),
      accAfterSoftLB_    (defAccAfterSoftLB    ()),
      mipMode_           (defMipMode           ()),
      multiObjMode_      (defMultiObjMode      ()),
      objChoice_         (defObjChoice         ()),
      wbounds_           (defWbounds           ()),
      optInitMethod_     (NULL),
      solverLogFileName_ (defSolverLogFileName ()),
      sglObjValuePtr_    (NULL),
      boundsValue_       (0.0),
      boundsValueValid_  (false),
      cplexStatusCode_   (-1),
      cplexStatusText_   ("The CPLEX solution status is not yet defined."),
      cplexMipBound_     (0.0),
      cplexMipRelGap_    (-1.0),
      printOptProblem_   (false),
      printMatByCols_    (false),
      printInitSoln_     (false),
      printOptSoln_      (false),
      printMps_          (false),
      skipScreening_     (false)
   {
   myCpxParSpecMgr_ = new WitCpxParSpecMgr (myProblem ());

   sglObjValuePtr_ = new double (0.0);

   setUpOptStarters ();

   myCompMgr ()->insert (this);
   }

//------------------------------------------------------------------------------

WitOptComp::~WitOptComp ()
   {
   delete myMultiObjMgr_;
   delete myCpxParSpecMgr_;

   while (not  allOptStarters_.isEmpty ())
      delete allOptStarters_.get ();

   delete sglObjValuePtr_;
   }

//------------------------------------------------------------------------------

WitOptStarter * WitOptComp::defOptInitMethod () const
   {
   return crashOptStarter ();
   }

//------------------------------------------------------------------------------
// "Set" functions.
//------------------------------------------------------------------------------

void WitOptComp::setCompPrices (bool theValue)
   {
   WitPart * thePart;

   prepSetUnpostAttr ();

   if (compPrices_)
      if (not theValue)
         forEachPart (thePart, myProblem ())
            thePart->resetShadowPrice ();

   compPrices_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setAccAfterOptImp (bool theValue)
   {
   if (not theValue)
      myDetOptImpMgr ()->shutDown ();

   prepSetUnpostAttr ();

   accAfterOptImp_ = theValue;

   checkAccAfter ();
   }

//------------------------------------------------------------------------------

void WitOptComp::setAccAfterSoftLB (bool theValue)
   {
   prepSetUnpostAttr ();

   if (theValue != accAfterSoftLB ())
      myDetOptImpMgr ()->shutDown ();

   accAfterSoftLB_ = theValue;

   checkAccAfter ();
   }

//------------------------------------------------------------------------------

void WitOptComp::setMipMode (bool theValue)
   {
   prepSetUnpreAttr ();

   mipMode_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setMultiObjMode (bool theValue)
   {
   witAssert (myCompMgr ()->nNodes () == 0);

   witAssert (not myStochImpMgr ()->stochMode ());

   prepSetUnpreAttr ();

   if (multiObjMode_ == theValue)
      return;

   if (theValue)
      {
      myMultiObjMgr_  = new WitMultiObjMgr (myProblem ());

      delete sglObjValuePtr_;

      sglObjValuePtr_ = NULL;
      }
   else
      {
      delete myMultiObjMgr_;

      myMultiObjMgr_  = NULL;

      sglObjValuePtr_ = new double (0.0);
      }

   multiObjMode_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setObjChoice (int theValue)
   {
   witAssert (theValue >= 0);
   witAssert (theValue <= 1);

   prepSetUnpreAttr ();

   objChoice_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setWbounds (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   wbounds_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setSolverLogFileName (const char * theValue)
   {
   witAssert (theValue != NULL);

   prepSetNonUnpostAttr ();

   solverLogFileName_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setPrintOptProblem (bool theValue)
   {
   printOptProblem_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setPrintMatByCols (bool theValue)
   {
   printMatByCols_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setPrintInitSoln (bool theValue)
   {
   printInitSoln_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setPrintOptSoln (bool theValue)
   {
   printOptSoln_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setPrintMps (bool theValue)
   {
   printMps_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setSkipScreening (bool theValue)
   {
   skipScreening_ = theValue;
   }

//------------------------------------------------------------------------------
// Other functions.
//------------------------------------------------------------------------------

void WitOptComp::storeOptObjValue (double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   sglObjValue () = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::storeOptBoundsValue (double theValue)
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());

   boundsValue_      = theValue;
   boundsValueValid_ = true;
   }

//------------------------------------------------------------------------------

void WitOptComp::storeStochObjValue (double theValue)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   sglObjValue () = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::storeStochBoundsValue (double theValue)
   {
   witAssert (myStochImpMgr ()->uploadingData ());

   boundsValue_      = theValue;
   boundsValueValid_ = true;
   }

//------------------------------------------------------------------------------

void WitOptComp::storeCplexStatusCode (int theValue)
   {
   witAssert (cplexEmbedded ());

   cplexStatusCode_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::storeCplexStatusText (const char * theValue)
   {
   witAssert (cplexEmbedded ());

   cplexStatusText_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::storeCplexMipBound (double theValue)
   {
   witAssert (cplexEmbedded ());

   cplexMipBound_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::storeCplexMipRelGap (double theValue)
   {
   witAssert (cplexEmbedded ());
   
   cplexMipRelGap_ = theValue;
   }

//------------------------------------------------------------------------------

bool WitOptComp::inserted ()
   {
   return (myCompMgr ()->myOptComp () == this);
   }

//------------------------------------------------------------------------------

void WitOptComp::copySelfInto (WitCompMgr * theCompMgr)
   {
   theCompMgr->myOptComp ()->copyAttrsFrom (this);
   }

//------------------------------------------------------------------------------

void WitOptComp::recount ()
   {
   myCompMgr ()->recountOptComp (this);
   }

//------------------------------------------------------------------------------

void WitOptComp::clearStochSoln ()
   {
   WitComponent::clearStochSoln ();

   boundsValueValid_ = false;
   boundsValue_      = 0.0;
   sglObjValue ()    = 0.0;
   }

//------------------------------------------------------------------------------

double WitOptComp::objValue () const
   {
   return
      multiObjMode_?
         myMultiObjMgr_->currentObjective ()->objValue ():
         sglObjValue ();
   }

//------------------------------------------------------------------------------

void WitOptComp::unpostprocess ()
   {
   boundsValueValid_ = false;
   }

//------------------------------------------------------------------------------

void WitOptComp::display ()
   {
   myMsgFac () ("optAttDdMsg",
      cplexEmbedded (),
      compPrices_,
      accAfterOptImp_,
      accAfterSoftLB_,
      mipMode_,
      multiObjMode_,
      wbounds_,
      solverLogFileName_);

   if (multiObjMode_)
      myMultiObjMgr ()->display ();
   }

//------------------------------------------------------------------------------

void WitOptComp::choose (WitOptStarter * theOptStarter)
   {
   witAssert (theOptStarter != NULL);

   witAssert (theOptStarter->myOptComp () == this);

   if (theOptStarter == accOptStarter_)
      stronglyAssert     (myDetOptImpMgr ()->accelerated ());
   else
      stronglyAssert (not myDetOptImpMgr ()->accelerated ());

   optInitMethod_ = theOptStarter;
   }

//------------------------------------------------------------------------------

void WitOptComp::store (WitOptStarter * theOptStarter)
   {
   allOptStarters_.append (theOptStarter);
   }

//------------------------------------------------------------------------------

bool WitOptComp::negativeCostsExist ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachPart (thePart, myProblem ())
      if (not (thePart->scrapCost () >= 0.0))
         return true;

   forEachMaterial (theMat, myProblem ())
      if (not (theMat->stockCost () >= 0.0))
         return true;

   forEachOperation (theOpn, myProblem ())
      if (not (theOpn->execCost () >= 0.0))
         return true;

   forEachSubEntry (theSub, myProblem ())
      if (not (theSub->subCost () >= 0.0))
         return true;

   return false;
   }

//------------------------------------------------------------------------------

void WitOptComp::requireCplex ()
   {
   if (not cplexEmbedded ())
      myMsgFac () ("cplexNeededSmsg");
   }

//------------------------------------------------------------------------------

void WitOptComp::writeObjValue ()
   {
   if (multiObjMode_)
      {
      myMultiObjMgr_->writeObjValues ();
      }
   else
      myMsgFac () ("sglObjValueMsg", objValue ());
   }

//------------------------------------------------------------------------------

bool WitOptComp::cplexEmbedded ()
   {
   return WitCplexGateway::cplexEmbedded ();
   }

//------------------------------------------------------------------------------

void WitOptComp::setUpOptStarters ()
   {
   heurOptStarter_ =
      new WitOptStarter (
        this,
        "heur",
        WitHEUR_OPT_INIT_METHOD,
        "heurOptStarterMsg",
        true);

   accOptStarter_ =
      new WitOptStarter (
        this,
        "acc",
        WitACC_OPT_INIT_METHOD,
        "accOptStarterMsg",
        false);

   schedOptStarter_ =
      new WitOptStarter (
        this,
        "sched",
        WitSCHED_OPT_INIT_METHOD,
        "schedOptStarterMsg",
        true);

   crashOptStarter_ =
      new WitOptStarter (
        this,
        "crash",
        WitCRASH_OPT_INIT_METHOD,
        "crashOptStarterMsg",
        false);

   choose (defOptInitMethod ());
   }

//------------------------------------------------------------------------------

void WitOptComp::checkAccAfter ()
   {
   if (accAfterSoftLB ())
      if (not accAfterOptImp ())
         myMsgFac () ("accAfterSoftLBNotOptImpMsg");
   }

//------------------------------------------------------------------------------

void WitOptComp::writeDataID ()
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
   }

//------------------------------------------------------------------------------

void WitOptComp::writeDataAttrs ()
   {
   WitComponent::writeDataAttrs ();

   myDataWriter ()->writeBool (
        "compPrices",
         compPrices (),
      defCompPrices ());

   myDataWriter ()->writeBool (
        "accAfterOptImp",
         accAfterOptImp (),
      defAccAfterOptImp ());

   myDataWriter ()->writeBool (
        "accAfterSoftLB",
         accAfterSoftLB (),
      defAccAfterSoftLB ());

   myDataWriter ()->writeBool (
        "mipMode",
         mipMode (),
      defMipMode ());

   myDataWriter ()->writeInt   (
        "objChoice",
         objChoice (),
      defObjChoice ());

   myDataWriter ()->writeDouble (
        "wbounds",
         wbounds (),
      defWbounds ());

   myDataWriter ()->writeString (
        "solverLogFileName",
         solverLogFileName (),
      defSolverLogFileName ());

   myDataWriter ()->writeBool (
        "multiObjMode",
         multiObjMode (),
      defMultiObjMode ());

   if (multiObjMode_)
      myMultiObjMgr_->writeDataAttrs ();
   }

//------------------------------------------------------------------------------

void WitOptComp::copyAttrsFrom (WitOptComp * theOptComp)
   {
   WitComponent::copyAttrsFrom (theOptComp);

   compPrices_        = theOptComp->compPrices_;
   mipMode_           = theOptComp->mipMode_;
   wbounds_           = theOptComp->wbounds_;
   solverLogFileName_ = theOptComp->solverLogFileName_;
   objChoice_         = theOptComp->objChoice_;

   setAccAfterOptImp   (theOptComp->accAfterOptImp_);
   setAccAfterSoftLB   (theOptComp->accAfterSoftLB_);
   setMultiObjMode     (theOptComp->multiObjMode_);

   myCpxParSpecMgr_->  copyAttrsFrom (theOptComp->myCpxParSpecMgr_);

   if (multiObjMode_)
      myMultiObjMgr_->copyAttrsFrom (theOptComp->myMultiObjMgr_);
   }
@


1.146
log
@Reverted to the version of 8-30-2011, which has the following differences:
   Release 7.0
   Old copyright dates (2006)
   The leading blanks in each line, which were lost with the 2011 copyright
      update, are restored.
Restored release # as 8.0.
@
text
@d1 8
a8 1
//------------------------------------------------------------------------------
d10 4
a13 6
//     (c) Copyright IBM Corp. 2006.
//     (Unpublished)
//     OCO Source Modules
//     IBM Confidential 
// 
//------------------------------------------------------------------------------
@


1.145
log
@Revised the copyright date.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2011.
d6 2
a7 2
//     IBM Confidential
//
d39 2
a40 2
{
witAssert (not multiObjMode_);
d42 2
a43 2
return * sglObjValuePtr_;
}
d48 1
a48 1
WitComponent       (theCompMgr),
d50 33
a82 33
heurOptStarter_   (NULL),
accOptStarter_   (NULL),
schedOptStarter_   (NULL),
crashOptStarter_   (NULL),

allOptStarters_    (),
myCpxParSpecMgr_   (NULL),
myMultiObjMgr_     (NULL),

compPrices_        (defCompPrices        ()),
accAfterOptImp_    (defAccAfterOptImp    ()),
accAfterSoftLB_    (defAccAfterSoftLB    ()),
mipMode_           (defMipMode           ()),
multiObjMode_      (defMultiObjMode      ()),
objChoice_         (defObjChoice         ()),
wbounds_           (defWbounds           ()),
optInitMethod_     (NULL),
solverLogFileName_ (defSolverLogFileName ()),
sglObjValuePtr_    (NULL),
boundsValue_       (0.0),
boundsValueValid_  (false),
cplexStatusCode_   (-1),
cplexStatusText_   ("The CPLEX solution status is not yet defined."),
cplexMipBound_     (0.0),
cplexMipRelGap_    (-1.0),
printOptProblem_   (false),
printMatByCols_    (false),
printInitSoln_     (false),
printOptSoln_      (false),
printMps_          (false),
skipScreening_     (false)
{
myCpxParSpecMgr_ = new WitCpxParSpecMgr (myProblem ());
d84 1
a84 1
sglObjValuePtr_ = new double (0.0);
d86 1
a86 1
setUpOptStarters ();
d88 2
a89 2
myCompMgr ()->insert (this);
}
d94 3
a96 3
{
delete myMultiObjMgr_;
delete myCpxParSpecMgr_;
d98 2
a99 2
while (not  allOptStarters_.isEmpty ())
delete allOptStarters_.get ();
d101 2
a102 2
delete sglObjValuePtr_;
}
d107 3
a109 3
{
return crashOptStarter ();
}
d116 2
a117 2
{
WitPart * thePart;
d119 1
a119 1
prepSetUnpostAttr ();
d121 4
a124 4
if (compPrices_)
if (not theValue)
forEachPart (thePart, myProblem ())
thePart->resetShadowPrice ();
d126 2
a127 2
compPrices_ = theValue;
}
d132 3
a134 3
{
if (not theValue)
myDetOptImpMgr ()->shutDown ();
d136 1
a136 1
prepSetUnpostAttr ();
d138 1
a138 1
accAfterOptImp_ = theValue;
d140 2
a141 2
checkAccAfter ();
}
d146 2
a147 2
{
prepSetUnpostAttr ();
d149 2
a150 2
if (theValue != accAfterSoftLB ())
myDetOptImpMgr ()->shutDown ();
d152 1
a152 1
accAfterSoftLB_ = theValue;
d154 2
a155 2
checkAccAfter ();
}
d160 2
a161 2
{
prepSetUnpreAttr ();
d163 2
a164 2
mipMode_ = theValue;
}
d169 2
a170 2
{
witAssert (myCompMgr ()->nNodes () == 0);
d172 1
a172 1
witAssert (not myStochImpMgr ()->stochMode ());
d174 1
a174 1
prepSetUnpreAttr ();
d176 2
a177 2
if (multiObjMode_ == theValue)
return;
d179 3
a181 3
if (theValue)
{
myMultiObjMgr_  = new WitMultiObjMgr (myProblem ());
d183 1
a183 1
delete sglObjValuePtr_;
d185 5
a189 5
sglObjValuePtr_ = NULL;
}
else
{
delete myMultiObjMgr_;
d191 1
a191 1
myMultiObjMgr_  = NULL;
d193 2
a194 2
sglObjValuePtr_ = new double (0.0);
}
d196 2
a197 2
multiObjMode_ = theValue;
}
d202 3
a204 3
{
witAssert (theValue >= 0);
witAssert (theValue <= 1);
d206 1
a206 1
prepSetUnpreAttr ();
d208 2
a209 2
objChoice_ = theValue;
}
d214 2
a215 2
{
witAssert (theValue >= 0.0);
d217 1
a217 1
prepSetUnpostAttr ();
d219 2
a220 2
wbounds_ = theValue;
}
d225 2
a226 2
{
witAssert (theValue != NULL);
d228 1
a228 1
prepSetNonUnpostAttr ();
d230 2
a231 2
solverLogFileName_ = theValue;
}
d236 3
a238 3
{
printOptProblem_ = theValue;
}
d243 3
a245 3
{
printMatByCols_ = theValue;
}
d250 3
a252 3
{
printInitSoln_ = theValue;
}
d257 3
a259 3
{
printOptSoln_ = theValue;
}
d264 3
a266 3
{
printMps_ = theValue;
}
d271 3
a273 3
{
skipScreening_ = theValue;
}
d280 2
a281 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d283 2
a284 2
sglObjValue () = theValue;
}
d289 2
a290 2
{
witAssert (myDetOptImpMgr ()->uploadingSoln ());
d292 3
a294 3
boundsValue_      = theValue;
boundsValueValid_ = true;
}
d299 2
a300 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d302 2
a303 2
sglObjValue () = theValue;
}
d308 2
a309 2
{
witAssert (myStochImpMgr ()->uploadingData ());
d311 3
a313 3
boundsValue_      = theValue;
boundsValueValid_ = true;
}
d318 2
a319 2
{
witAssert (cplexEmbedded ());
d321 2
a322 2
cplexStatusCode_ = theValue;
}
d327 2
a328 2
{
witAssert (cplexEmbedded ());
d330 2
a331 2
cplexStatusText_ = theValue;
}
d336 2
a337 2
{
witAssert (cplexEmbedded ());
d339 2
a340 2
cplexMipBound_ = theValue;
}
d345 5
a349 5
{
witAssert (cplexEmbedded ());

cplexMipRelGap_ = theValue;
}
d354 3
a356 3
{
return (myCompMgr ()->myOptComp () == this);
}
d361 3
a363 3
{
theCompMgr->myOptComp ()->copyAttrsFrom (this);
}
d368 3
a370 3
{
myCompMgr ()->recountOptComp (this);
}
d375 2
a376 2
{
WitComponent::clearStochSoln ();
d378 4
a381 4
boundsValueValid_ = false;
boundsValue_      = 0.0;
sglObjValue ()    = 0.0;
}
d386 6
a391 6
{
return
multiObjMode_?
myMultiObjMgr_->currentObjective ()->objValue ():
sglObjValue ();
}
d396 3
a398 3
{
boundsValueValid_ = false;
}
d403 14
a416 14
{
myMsgFac () ("optAttDdMsg",
cplexEmbedded (),
compPrices_,
accAfterOptImp_,
accAfterSoftLB_,
mipMode_,
multiObjMode_,
wbounds_,
solverLogFileName_);

if (multiObjMode_)
myMultiObjMgr ()->display ();
}
d421 2
a422 2
{
witAssert (theOptStarter != NULL);
d424 1
a424 1
witAssert (theOptStarter->myOptComp () == this);
d426 4
a429 4
if (theOptStarter == accOptStarter_)
stronglyAssert     (myDetOptImpMgr ()->accelerated ());
else
stronglyAssert (not myDetOptImpMgr ()->accelerated ());
d431 2
a432 2
optInitMethod_ = theOptStarter;
}
d437 3
a439 3
{
allOptStarters_.append (theOptStarter);
}
d444 21
a464 21
{
WitPart *      thePart;
WitMaterial *  theMat;
WitOperation * theOpn;
WitSubEntry *  theSub;

forEachPart (thePart, myProblem ())
if (not (thePart->scrapCost () >= 0.0))
return true;

forEachMaterial (theMat, myProblem ())
if (not (theMat->stockCost () >= 0.0))
return true;

forEachOperation (theOpn, myProblem ())
if (not (theOpn->execCost () >= 0.0))
return true;

forEachSubEntry (theSub, myProblem ())
if (not (theSub->subCost () >= 0.0))
return true;
d466 2
a467 2
return false;
}
d472 4
a475 4
{
if (not cplexEmbedded ())
myMsgFac () ("cplexNeededSmsg");
}
d480 8
a487 8
{
if (multiObjMode_)
{
myMultiObjMgr_->writeObjValues ();
}
else
myMsgFac () ("sglObjValueMsg", objValue ());
}
d492 3
a494 3
{
return WitCplexGateway::cplexEmbedded ();
}
d499 32
a530 32
{
heurOptStarter_ =
new WitOptStarter (
this,
"heur",
WitHEUR_OPT_INIT_METHOD,
"heurOptStarterMsg",
true);

accOptStarter_ =
new WitOptStarter (
this,
"acc",
WitACC_OPT_INIT_METHOD,
"accOptStarterMsg",
false);

schedOptStarter_ =
new WitOptStarter (
this,
"sched",
WitSCHED_OPT_INIT_METHOD,
"schedOptStarterMsg",
true);

crashOptStarter_ =
new WitOptStarter (
this,
"crash",
WitCRASH_OPT_INIT_METHOD,
"crashOptStarterMsg",
false);
d532 2
a533 2
choose (defOptInitMethod ());
}
d538 5
a542 5
{
if (accAfterSoftLB ())
if (not accAfterOptImp ())
myMsgFac () ("accAfterSoftLBNotOptImpMsg");
}
d547 4
a550 4
{
myDataWriter ()->writeFirstKeyWord ("set");
myDataWriter ()->writeKeyWord      ("problem");
}
d555 2
a556 2
{
WitComponent::writeDataAttrs ();
d558 43
a600 43
myDataWriter ()->writeBool (
"compPrices",
compPrices (),
defCompPrices ());

myDataWriter ()->writeBool (
"accAfterOptImp",
accAfterOptImp (),
defAccAfterOptImp ());

myDataWriter ()->writeBool (
"accAfterSoftLB",
accAfterSoftLB (),
defAccAfterSoftLB ());

myDataWriter ()->writeBool (
"mipMode",
mipMode (),
defMipMode ());

myDataWriter ()->writeInt   (
"objChoice",
objChoice (),
defObjChoice ());

myDataWriter ()->writeDouble (
"wbounds",
wbounds (),
defWbounds ());

myDataWriter ()->writeString (
"solverLogFileName",
solverLogFileName (),
defSolverLogFileName ());

myDataWriter ()->writeBool (
"multiObjMode",
multiObjMode (),
defMultiObjMode ());

if (multiObjMode_)
myMultiObjMgr_->writeDataAttrs ();
}
d605 2
a606 2
{
WitComponent::copyAttrsFrom (theOptComp);
d608 15
a622 15
compPrices_        = theOptComp->compPrices_;
mipMode_           = theOptComp->mipMode_;
wbounds_           = theOptComp->wbounds_;
solverLogFileName_ = theOptComp->solverLogFileName_;
objChoice_         = theOptComp->objChoice_;

setAccAfterOptImp   (theOptComp->accAfterOptImp_);
setAccAfterSoftLB   (theOptComp->accAfterSoftLB_);
setMultiObjMode     (theOptComp->multiObjMode_);

myCpxParSpecMgr_->  copyAttrsFrom (theOptComp->myCpxParSpecMgr_);

if (multiObjMode_)
myMultiObjMgr_->copyAttrsFrom (theOptComp->myMultiObjMgr_);
}
@


1.144
log
@Replaced class SolverMgr with class CplexGateway.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 2006.
d6 2
a7 2
//     IBM Confidential 
// 
d39 2
a40 2
   {
   witAssert (not multiObjMode_);
d42 2
a43 2
   return * sglObjValuePtr_;
   }
d48 1
a48 1
      WitComponent       (theCompMgr),
d50 33
a82 33
       heurOptStarter_   (NULL),
        accOptStarter_   (NULL),
      schedOptStarter_   (NULL),
      crashOptStarter_   (NULL),

      allOptStarters_    (),
      myCpxParSpecMgr_   (NULL),
      myMultiObjMgr_     (NULL),

      compPrices_        (defCompPrices        ()),
      accAfterOptImp_    (defAccAfterOptImp    ()),
      accAfterSoftLB_    (defAccAfterSoftLB    ()),
      mipMode_           (defMipMode           ()),
      multiObjMode_      (defMultiObjMode      ()),
      objChoice_         (defObjChoice         ()),
      wbounds_           (defWbounds           ()),
      optInitMethod_     (NULL),
      solverLogFileName_ (defSolverLogFileName ()),
      sglObjValuePtr_    (NULL),
      boundsValue_       (0.0),
      boundsValueValid_  (false),
      cplexStatusCode_   (-1),
      cplexStatusText_   ("The CPLEX solution status is not yet defined."),
      cplexMipBound_     (0.0),
      cplexMipRelGap_    (-1.0),
      printOptProblem_   (false),
      printMatByCols_    (false),
      printInitSoln_     (false),
      printOptSoln_      (false),
      printMps_          (false),
      skipScreening_     (false)
   {
   myCpxParSpecMgr_ = new WitCpxParSpecMgr (myProblem ());
d84 1
a84 1
   sglObjValuePtr_ = new double (0.0);
d86 1
a86 1
   setUpOptStarters ();
d88 2
a89 2
   myCompMgr ()->insert (this);
   }
d94 3
a96 3
   {
   delete myMultiObjMgr_;
   delete myCpxParSpecMgr_;
d98 2
a99 2
   while (not  allOptStarters_.isEmpty ())
      delete allOptStarters_.get ();
d101 2
a102 2
   delete sglObjValuePtr_;
   }
d107 3
a109 3
   {
   return crashOptStarter ();
   }
d116 2
a117 2
   {
   WitPart * thePart;
d119 1
a119 1
   prepSetUnpostAttr ();
d121 4
a124 4
   if (compPrices_)
      if (not theValue)
         forEachPart (thePart, myProblem ())
            thePart->resetShadowPrice ();
d126 2
a127 2
   compPrices_ = theValue;
   }
d132 3
a134 3
   {
   if (not theValue)
      myDetOptImpMgr ()->shutDown ();
d136 1
a136 1
   prepSetUnpostAttr ();
d138 1
a138 1
   accAfterOptImp_ = theValue;
d140 2
a141 2
   checkAccAfter ();
   }
d146 2
a147 2
   {
   prepSetUnpostAttr ();
d149 2
a150 2
   if (theValue != accAfterSoftLB ())
      myDetOptImpMgr ()->shutDown ();
d152 1
a152 1
   accAfterSoftLB_ = theValue;
d154 2
a155 2
   checkAccAfter ();
   }
d160 2
a161 2
   {
   prepSetUnpreAttr ();
d163 2
a164 2
   mipMode_ = theValue;
   }
d169 2
a170 2
   {
   witAssert (myCompMgr ()->nNodes () == 0);
d172 1
a172 1
   witAssert (not myStochImpMgr ()->stochMode ());
d174 1
a174 1
   prepSetUnpreAttr ();
d176 2
a177 2
   if (multiObjMode_ == theValue)
      return;
d179 3
a181 3
   if (theValue)
      {
      myMultiObjMgr_  = new WitMultiObjMgr (myProblem ());
d183 1
a183 1
      delete sglObjValuePtr_;
d185 5
a189 5
      sglObjValuePtr_ = NULL;
      }
   else
      {
      delete myMultiObjMgr_;
d191 1
a191 1
      myMultiObjMgr_  = NULL;
d193 2
a194 2
      sglObjValuePtr_ = new double (0.0);
      }
d196 2
a197 2
   multiObjMode_ = theValue;
   }
d202 3
a204 3
   {
   witAssert (theValue >= 0);
   witAssert (theValue <= 1);
d206 1
a206 1
   prepSetUnpreAttr ();
d208 2
a209 2
   objChoice_ = theValue;
   }
d214 2
a215 2
   {
   witAssert (theValue >= 0.0);
d217 1
a217 1
   prepSetUnpostAttr ();
d219 2
a220 2
   wbounds_ = theValue;
   }
d225 2
a226 2
   {
   witAssert (theValue != NULL);
d228 1
a228 1
   prepSetNonUnpostAttr ();
d230 2
a231 2
   solverLogFileName_ = theValue;
   }
d236 3
a238 3
   {
   printOptProblem_ = theValue;
   }
d243 3
a245 3
   {
   printMatByCols_ = theValue;
   }
d250 3
a252 3
   {
   printInitSoln_ = theValue;
   }
d257 3
a259 3
   {
   printOptSoln_ = theValue;
   }
d264 3
a266 3
   {
   printMps_ = theValue;
   }
d271 3
a273 3
   {
   skipScreening_ = theValue;
   }
d280 2
a281 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d283 2
a284 2
   sglObjValue () = theValue;
   }
d289 2
a290 2
   {
   witAssert (myDetOptImpMgr ()->uploadingSoln ());
d292 3
a294 3
   boundsValue_      = theValue;
   boundsValueValid_ = true;
   }
d299 2
a300 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d302 2
a303 2
   sglObjValue () = theValue;
   }
d308 2
a309 2
   {
   witAssert (myStochImpMgr ()->uploadingData ());
d311 3
a313 3
   boundsValue_      = theValue;
   boundsValueValid_ = true;
   }
d318 2
a319 2
   {
   witAssert (cplexEmbedded ());
d321 2
a322 2
   cplexStatusCode_ = theValue;
   }
d327 2
a328 2
   {
   witAssert (cplexEmbedded ());
d330 2
a331 2
   cplexStatusText_ = theValue;
   }
d336 2
a337 2
   {
   witAssert (cplexEmbedded ());
d339 2
a340 2
   cplexMipBound_ = theValue;
   }
d345 5
a349 5
   {
   witAssert (cplexEmbedded ());
   
   cplexMipRelGap_ = theValue;
   }
d354 3
a356 3
   {
   return (myCompMgr ()->myOptComp () == this);
   }
d361 3
a363 3
   {
   theCompMgr->myOptComp ()->copyAttrsFrom (this);
   }
d368 3
a370 3
   {
   myCompMgr ()->recountOptComp (this);
   }
d375 2
a376 2
   {
   WitComponent::clearStochSoln ();
d378 4
a381 4
   boundsValueValid_ = false;
   boundsValue_      = 0.0;
   sglObjValue ()    = 0.0;
   }
d386 6
a391 6
   {
   return
      multiObjMode_?
         myMultiObjMgr_->currentObjective ()->objValue ():
         sglObjValue ();
   }
d396 3
a398 3
   {
   boundsValueValid_ = false;
   }
d403 14
a416 14
   {
   myMsgFac () ("optAttDdMsg",
      cplexEmbedded (),
      compPrices_,
      accAfterOptImp_,
      accAfterSoftLB_,
      mipMode_,
      multiObjMode_,
      wbounds_,
      solverLogFileName_);

   if (multiObjMode_)
      myMultiObjMgr ()->display ();
   }
d421 2
a422 2
   {
   witAssert (theOptStarter != NULL);
d424 1
a424 1
   witAssert (theOptStarter->myOptComp () == this);
d426 4
a429 4
   if (theOptStarter == accOptStarter_)
      stronglyAssert     (myDetOptImpMgr ()->accelerated ());
   else
      stronglyAssert (not myDetOptImpMgr ()->accelerated ());
d431 2
a432 2
   optInitMethod_ = theOptStarter;
   }
d437 3
a439 3
   {
   allOptStarters_.append (theOptStarter);
   }
d444 21
a464 21
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachPart (thePart, myProblem ())
      if (not (thePart->scrapCost () >= 0.0))
         return true;

   forEachMaterial (theMat, myProblem ())
      if (not (theMat->stockCost () >= 0.0))
         return true;

   forEachOperation (theOpn, myProblem ())
      if (not (theOpn->execCost () >= 0.0))
         return true;

   forEachSubEntry (theSub, myProblem ())
      if (not (theSub->subCost () >= 0.0))
         return true;
d466 2
a467 2
   return false;
   }
d472 4
a475 4
   {
   if (not cplexEmbedded ())
      myMsgFac () ("cplexNeededSmsg");
   }
d480 8
a487 8
   {
   if (multiObjMode_)
      {
      myMultiObjMgr_->writeObjValues ();
      }
   else
      myMsgFac () ("sglObjValueMsg", objValue ());
   }
d492 3
a494 3
   {
   return WitCplexGateway::cplexEmbedded ();
   }
d499 32
a530 32
   {
   heurOptStarter_ =
      new WitOptStarter (
        this,
        "heur",
        WitHEUR_OPT_INIT_METHOD,
        "heurOptStarterMsg",
        true);

   accOptStarter_ =
      new WitOptStarter (
        this,
        "acc",
        WitACC_OPT_INIT_METHOD,
        "accOptStarterMsg",
        false);

   schedOptStarter_ =
      new WitOptStarter (
        this,
        "sched",
        WitSCHED_OPT_INIT_METHOD,
        "schedOptStarterMsg",
        true);

   crashOptStarter_ =
      new WitOptStarter (
        this,
        "crash",
        WitCRASH_OPT_INIT_METHOD,
        "crashOptStarterMsg",
        false);
d532 2
a533 2
   choose (defOptInitMethod ());
   }
d538 5
a542 5
   {
   if (accAfterSoftLB ())
      if (not accAfterOptImp ())
         myMsgFac () ("accAfterSoftLBNotOptImpMsg");
   }
d547 4
a550 4
   {
   myDataWriter ()->writeFirstKeyWord ("set");
   myDataWriter ()->writeKeyWord      ("problem");
   }
d555 2
a556 2
   {
   WitComponent::writeDataAttrs ();
d558 43
a600 43
   myDataWriter ()->writeBool (
        "compPrices",
         compPrices (),
      defCompPrices ());

   myDataWriter ()->writeBool (
        "accAfterOptImp",
         accAfterOptImp (),
      defAccAfterOptImp ());

   myDataWriter ()->writeBool (
        "accAfterSoftLB",
         accAfterSoftLB (),
      defAccAfterSoftLB ());

   myDataWriter ()->writeBool (
        "mipMode",
         mipMode (),
      defMipMode ());

   myDataWriter ()->writeInt   (
        "objChoice",
         objChoice (),
      defObjChoice ());

   myDataWriter ()->writeDouble (
        "wbounds",
         wbounds (),
      defWbounds ());

   myDataWriter ()->writeString (
        "solverLogFileName",
         solverLogFileName (),
      defSolverLogFileName ());

   myDataWriter ()->writeBool (
        "multiObjMode",
         multiObjMode (),
      defMultiObjMode ());

   if (multiObjMode_)
      myMultiObjMgr_->writeDataAttrs ();
   }
d605 2
a606 2
   {
   WitComponent::copyAttrsFrom (theOptComp);
d608 15
a622 15
   compPrices_        = theOptComp->compPrices_;
   mipMode_           = theOptComp->mipMode_;
   wbounds_           = theOptComp->wbounds_;
   solverLogFileName_ = theOptComp->solverLogFileName_;
   objChoice_         = theOptComp->objChoice_;

   setAccAfterOptImp   (theOptComp->accAfterOptImp_);
   setAccAfterSoftLB   (theOptComp->accAfterSoftLB_);
   setMultiObjMode     (theOptComp->multiObjMode_);

   myCpxParSpecMgr_->  copyAttrsFrom (theOptComp->myCpxParSpecMgr_);

   if (multiObjMode_)
      myMultiObjMgr_->copyAttrsFrom (theOptComp->myMultiObjMgr_);
   }
@


1.143
log
@Revisions for the removal of COIN.
@
text
@d29 1
a29 2
#include <OptProblem.h>
#include <SolverMgr.h>
d493 1
a493 1
   return WitOptProblem::cplexEmbedded ();
@


1.142
log
@Removed COIN from WIT.
@
text
@d29 1
d320 1
a320 1
   witAssert (WitSolverMgr::cplexEmbedded ());
d329 1
a329 1
   witAssert (WitSolverMgr::cplexEmbedded ());
d338 1
a338 1
   witAssert (WitSolverMgr::cplexEmbedded ());
d347 1
a347 1
   witAssert (WitSolverMgr::cplexEmbedded ());
d406 1
a406 1
      WitSolverMgr::cplexEmbedded (),
d474 1
a474 1
   if (not WitSolverMgr::cplexEmbedded ())
d492 7
@


1.141
log
@Added severe error for selecting a solver that's not embedded.
@
text
@a57 1
      coinLogLevel_      (1),
a58 2
      coinSelected_      (defCoinSelected      ()),
      cplexSelected_     (defCplexSelected     ()),
a67 1
      accMethod_         (defAccMethod         ()),
d108 1
a108 17
   return heurOptStarter ();
   }

//------------------------------------------------------------------------------

bool WitOptComp::defCoinSelected ()
   {
   return
              WitSolverMgr::coinEmbedded  ()
      and not WitSolverMgr::cplexEmbedded ();
   }

//------------------------------------------------------------------------------

bool WitOptComp::defCplexSelected ()
   {
   return WitSolverMgr::cplexEmbedded ();
a114 45
void WitOptComp::setCoinLogLevel (int theValue)
   {
   stronglyAssert (theValue >= 0);

   coinLogLevel_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setCoinSelected (bool theValue)
   {
   prepSetUnpreAttr ();

   if (theValue)
      {
      stronglyAssert (WitSolverMgr::coinEmbedded ());

      cplexSelected_ = false;

      heurOptStarter_->beChosen ();
      }

   coinSelected_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setCplexSelected (bool theValue)
   {
   prepSetUnpreAttr ();

   if (theValue)
      {
      stronglyAssert (WitSolverMgr::cplexEmbedded ());

      coinSelected_ = false;

      crashOptStarter_->beChosen ();
      }

   cplexSelected_ = theValue;
   }

//------------------------------------------------------------------------------

a234 10
void WitOptComp::setAccMethod (int theValue)
   {
   witAssert (theValue >= 0);
   witAssert (theValue <= 3);

   accMethod_ = theValue;
   }

//------------------------------------------------------------------------------

d319 1
a319 1
   witAssert (cplexSelected_);
d328 1
a328 1
   witAssert (cplexSelected_);
d337 1
a337 1
   witAssert (cplexSelected_);
d346 1
a346 1
   witAssert (cplexSelected_);
a404 1
      WitSolverMgr:: coinEmbedded (),
a405 2
      coinSelected_,
      cplexSelected_,
d471 1
a471 1
void WitOptComp::requireSolver ()
d473 2
a474 3
   if    (not coinSelected_)
      if (not cplexSelected_)
         myMsgFac () ("solverNeededSmsg");
a551 8
        "coinSelected",
         coinSelected ());

   myDataWriter ()->writeBool (
        "cplexSelected",
         cplexSelected ());

   myDataWriter ()->writeBool (
a585 5
   myDataWriter ()->writeInt (
        "accMethod",
         accMethod (),
      defAccMethod ());

a600 2
   coinSelected_      = theOptComp->coinSelected_;
   cplexSelected_     = theOptComp->cplexSelected_;
a604 1
   accMethod_         = theOptComp->accMethod_;
@


1.140
log
@Revised the default values of coinSelected and cplexSelected.
@
text
@d150 2
d168 2
d549 1
a549 1
void WitOptComp::validateSolver ()
a552 1
         {
a553 13
         }

   if (coinSelected_)
      if (not WitSolverMgr::coinEmbedded ())
         {
         myMsgFac () ("solverNotEmbeddedSmsg", "COIN", "coin");
         }

   if (cplexSelected_)
      if (not WitSolverMgr::cplexEmbedded ())
         {
         myMsgFac () ("solverNotEmbeddedSmsg", "CPLEX", "cplex");
         }
@


1.139
log
@Fixed a bug in optInitMethod
@
text
@d116 16
d642 1
a642 2
         coinSelected (),
      defCoinSelected ());
d646 1
a646 2
         cplexSelected (),
      defCplexSelected ());
@


1.138
log
@CPLEX
@
text
@d485 3
a487 1
      stronglyAssert (myDetOptImpMgr ()->accelerated ());
@


1.137
log
@CPLEX
@
text
@d77 2
a78 2
      cplexObjBound_     (0.0),
      cplexObjRelGap_    (-1.0),
d390 1
a390 1
void WitOptComp::storeCplexObjBound (double theValue)
d394 1
a394 1
   cplexObjBound_ = theValue;
d399 1
a399 1
void WitOptComp::storeCplexObjRelGap (double theValue)
d403 1
a403 1
   cplexObjRelGap_ = theValue;
@


1.136
log
@CPLEX
@
text
@d78 1
a78 1
      cplexMipRelGap_    (-1.0),
d399 1
a399 1
void WitOptComp::storeCplexMipRelGap (double theValue)
d403 1
a403 1
   cplexMipRelGap_ = theValue;
@


1.135
log
@CPLEX
@
text
@d78 1
d372 1
a372 3
void WitOptComp::storeCplexStatus (
      int          theStatusCode,
      const char * theStatusText)
d376 10
a385 2
   cplexStatusCode_ = theStatusCode;
   cplexStatusText_ = theStatusText;
d399 9
@


1.134
log
@CPLEX
@
text
@d77 1
d383 9
@


1.133
log
@CPLEX
@
text
@a388 7
WitMsgFrag WitOptComp::classMsgFrag ()
   {
   return myMsgFac ().myFrag ("globalFrag");
   }

//------------------------------------------------------------------------------

@


1.132
log
@CPLEX
@
text
@d603 9
a611 4
   if (cplexSelected ())
      myDataWriter ()->writeBool (
           "cplexSelected",
            true);
@


1.131
log
@CPLEX
@
text
@d29 1
d441 2
a442 2
      coinEmbedded   (),
      cplexEmbedded  (),
d517 1
a517 1
      if (not coinEmbedded ())
d523 1
a523 1
      if (not cplexEmbedded ())
@


1.130
log
@CPLEX
@
text
@d75 1
a75 1
      cplexStatusText_   ("(undefined)"),
@


1.129
log
@CPLEX
@
text
@d75 1
d369 3
a371 1
void WitOptComp::storeCplexStatusCode (int theValue)
d375 2
a376 1
   cplexStatusCode_ = theValue;
@


1.128
log
@CPLEX Parameters
@
text
@d74 1
a74 1
      cplexSolnStatus_   (-1),
d368 1
a368 1
void WitOptComp::storeCplexSolnStatus (int theValue)
d372 1
a372 1
   cplexSolnStatus_ = theValue;
@


1.127
log
@CPLEX solution status
@
text
@d74 1
a74 1
      cpxSolnStatus_     (-1),
d368 1
a368 1
void WitOptComp::storeCpxSolnStatus (int theValue)
d372 1
a372 1
   cpxSolnStatus_ = theValue;
@


1.126
log
@CPLEX Solution Status
@
text
@d74 1
a74 1
      cpxStat_           (-1),
d368 1
a368 1
void WitOptComp::storeCpxStat (int theValue)
d372 1
a372 1
   cpxStat_ = theValue;
@


1.125
log
@CPLEX Parameters
@
text
@d74 1
d368 9
@


1.124
log
@CPLEX Parameters
@
text
@d79 1
a79 2
      skipScreening_     (false),
      cpxSimDisplay_     (1)
a325 7

void WitOptComp::setCpxSimDisplay (int theValue)
   {
   cpxSimDisplay_ = theValue;
   }

//------------------------------------------------------------------------------
@


1.123
log
@CPLEX Parameters
@
text
@d80 1
a80 2
      cpxSimDisplay_     (1),
      allowCpxParSpec_   (false)
a333 7

void WitOptComp::setAllowCpxParSpec (bool theValue)
   {
   allowCpxParSpec_ = theValue;
   }

//------------------------------------------------------------------------------
@


1.122
log
@CPLEX Parameters
@
text
@a653 2
   myCpxParSpecMgr_->writeDataAttrs ();

@


1.121
log
@CPLEX Parameters
@
text
@d607 1
a607 2
            true,
            false);
@


1.120
log
@CPLEX Param Specs
@
text
@a453 2
   myCpxParSpecMgr_->display ();

@


1.119
log
@CPX Param Specs
@
text
@d657 2
@


1.118
log
@CPX Params
@
text
@d18 1
a18 1
#include <CpxParamMgr.h>
d55 1
a55 1
      myCpxParamMgr_     (NULL),
d81 1
a81 1
      allowCpxParams_    (false)
d83 1
a83 1
   myCpxParamMgr_  = new WitCpxParamMgr (myProblem ());
d97 1
a97 1
   delete myCpxParamMgr_;
d336 1
a336 1
void WitOptComp::setAllowCpxParams (bool theValue)
d338 1
a338 1
   allowCpxParams_ = theValue;
d454 1
a454 1
   myCpxParamMgr_->display ();
d680 1
a680 1
   myCpxParamMgr_->   copyAttrsFrom (theOptComp->myCpxParamMgr_);
@


1.117
log
@CPX Params
@
text
@d454 2
d680 2
@


1.116
log
@CPX Params
@
text
@d18 1
d55 1
d83 2
d97 1
d223 1
a223 1
      myMultiObjMgr_   = new WitMultiObjMgr (myProblem ());
@


1.115
log
@CPLEX
@
text
@d78 2
a79 1
      cpxSimDisplay_     (1)
d330 7
@


1.114
log
@CPLEX
@
text
@a77 1
      allowMultiCplex_   (false),
a322 7
void WitOptComp::setAllowMultiCplex (bool theValue)
   {
   allowMultiCplex_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.113
log
@CPLEX
@
text
@d78 1
d324 7
@


1.112
log
@CPLEX
@
text
@d78 1
a78 2
      cpxSimDisplay_     (1),
      allowMipCplex_     (false)
a328 7

void WitOptComp::setAllowMipCplex (bool theValue)
   {
   allowMipCplex_ = theValue;
   }

//------------------------------------------------------------------------------
@


1.111
log
@CPLEX
@
text
@d78 2
a79 1
      cpxSimDisplay_     (1)
d330 7
@


1.110
log
@CPLEX
@
text
@d78 1
a78 2
      cpxSimDisplay_     (1),
      accCplexAllowed_   (false)
a328 7

void WitOptComp::setAccCplexAllowed (bool theValue)
   {
   accCplexAllowed_ = theValue;
   }

//------------------------------------------------------------------------------
@


1.109
log
@CPLEX
@
text
@d78 2
a79 1
      cpxSimDisplay_     (1)
d330 7
@


1.108
log
@CPLEX
@
text
@d124 1
d127 4
a130 1
   coinSelected_     = theValue;
d140 1
d143 4
a146 1
   cplexSelected_   = theValue;
@


1.107
log
@CPLEX
@
text
@a120 3
   if (theValue)
      stronglyAssert (coinEmbedded ());

a132 3
   if (theValue)
      stronglyAssert (cplexEmbedded ());

d488 23
@


1.106
log
@CPLEX
@
text
@a34 11
// Implementation NonClass function solverEmbedded ().
//
// Declared in SolverMgr.h.
//------------------------------------------------------------------------------

bool WitNonClass::solverEmbedded ()
   {
   return (coinEmbedded () or cplexEmbedded ());
   }

//------------------------------------------------------------------------------
d119 1
a119 1
void WitOptComp::setCoinSelectedTrue ()
d121 2
a122 1
   stronglyAssert (coinEmbedded ());
d126 4
a129 2
   coinSelected_  = true;
   cplexSelected_ = false;
d134 1
a134 1
void WitOptComp::setCplexSelectedTrue ()
d136 2
a137 1
   stronglyAssert (cplexEmbedded ());
d141 4
a144 2
   cplexSelected_ = true;
   coinSelected_  = false;
a426 1
      solverEmbedded (),
@


1.105
log
@CPLEX
@
text
@d68 2
a69 2
      solverIsCoin_      (defSolverIsCoin      ()),
      solverIsCplex_     (defSolverIsCplex     ()),
d130 1
a130 1
void WitOptComp::setSolverIsCoinTrue ()
d136 2
a137 2
   solverIsCoin_  = true;
   solverIsCplex_ = false;
d142 1
a142 1
void WitOptComp::setSolverIsCplexTrue ()
d148 2
a149 2
   solverIsCplex_ = true;
   solverIsCoin_  = false;
d435 2
a436 2
      solverIsCoin_,
      solverIsCplex_,
d572 1
a572 1
   if (solverIsCplex ())
d574 1
a574 1
           "solverIsCplex",
d633 2
a634 2
   solverIsCoin_      = theOptComp->solverIsCoin_;
   solverIsCplex_     = theOptComp->solverIsCplex_;
@


1.104
log
@Heuristic Adjustment
@
text
@a82 1
      cplexAllowed_      (false),
a283 7
void WitOptComp::setCplexAllowed (bool theValue)
   {
   cplexAllowed_ = theValue;
   }

//------------------------------------------------------------------------------

@


1.103
log
@CPLEX
@
text
@d26 1
a26 1
#include <Opn.h>
@


1.102
log
@CPLEX
@
text
@d89 2
a90 1
      skipScreening_     (false)
d333 7
@


1.101
log
@CPLEX
@
text
@d84 1
a84 1
      printOptModel_     (false),
d291 1
a291 1
void WitOptComp::setPrintOptModel (bool theValue)
d293 1
a293 1
   printOptModel_ = theValue;
@


1.100
log
@CPLEX
@
text
@d42 1
a42 1
   return (COIN_EMBEDDED or cplexEmbedded ());
d132 1
a132 1
   stronglyAssert (COIN_EMBEDDED);
d433 2
a434 2
      COIN_EMBEDDED,
      cplexEmbedded (),
@


1.99
log
@CPLEX
@
text
@d35 11
a411 7
bool WitOptComp::solverEmbedded ()
   {
   return (COIN_EMBEDDED or cplexEmbedded ());
   }

//------------------------------------------------------------------------------

@


1.98
log
@CPLEX
@
text
@d133 1
a133 1
   stronglyAssert (CPLEX_EMBEDDED);
d403 1
a403 1
   return COIN_EMBEDDED or CPLEX_EMBEDDED;
d430 1
a430 1
      CPLEX_EMBEDDED,
@


1.97
log
@CPLEX
@
text
@a567 6
   if (solverIsCoin ())
      myDataWriter ()->writeBool (
           "solverIsCoin",
            true,
         defSolverIsCoin ());

d572 1
a572 1
         defSolverIsCplex ());
@


1.96
log
@CPLEX
@
text
@d58 1
d119 1
a119 1
void WitOptComp::setSolverIsCoin (bool theValue)
a120 1
   stronglyAssert (theValue);
d125 14
a138 1
   solverIsCoin_ = theValue;
d432 1
d574 6
d636 1
@


1.95
log
@CPLEX
@
text
@a30 2
#include <CoinMgr.h>
#include <CplexMgr.h>
d121 1
a121 1
   stronglyAssert (coinEmbedded ());
d390 1
a390 15
   return coinEmbedded () or cplexEmbedded ();
   }

//------------------------------------------------------------------------------

bool WitOptComp::coinEmbedded ()
   {
   return WitCoinMgr::coinEmbedded ();
   }

//------------------------------------------------------------------------------

bool WitOptComp::cplexEmbedded ()
   {
   return WitCplexMgr::cplexEmbedded ();
d416 2
a417 2
      coinEmbedded (),
      cplexEmbedded (),
@


1.94
log
@CPLEX
@
text
@d392 1
a392 1
   return coinEmbedded ();
@


1.93
log
@Preparing for embedded CPLEX.
@
text
@d32 1
d73 1
d262 7
d404 7
d433 1
@


1.92
log
@Preparing for embedded CPLEX.
@
text
@d31 1
d121 1
a121 1
   stronglyAssert (COIN_EMBEDDED);
d381 14
d416 1
a416 1
      COIN_EMBEDDED,
@


1.91
log
@Preparing for embedded CPLEX.
@
text
@d400 1
a400 1
      SOLVER_EMBEDDED,
@


1.90
log
@Preparing for CPLEX.
@
text
@d122 1
a122 1
   prepSetUnpostAttr ();
@


1.89
log
@Revising the build procedure.
@
text
@d57 1
d117 12
d402 1
d538 6
d599 1
@


1.88
log
@Revising the build procedure.
@
text
@d387 1
@


1.87
log
@Multi-Obj Mode
@
text
@d387 1
@


1.86
log
@Multi-Obj Mode
@
text
@d75 1
a75 2
      skipScreening_     (false),
      multiObjTol_       (1.0e-7)
a286 9

void WitOptComp::setMultiObjTol (double theValue)
   {
   stronglyAssert (theValue >= 0.0);

   multiObjTol_ = theValue;
   }

//------------------------------------------------------------------------------
@


1.85
log
@Multi-Obj Mode
@
text
@d69 1
d313 2
a314 1
   boundsValue_ = theValue;
d332 2
a333 1
   boundsValue_ = theValue;
d370 3
a372 2
   sglObjValue () = 0.0;
   boundsValue_   = 0.0;
d387 7
@


1.84
log
@Multi-Obj Mode
@
text
@d75 1
a75 1
      multiObjTol_       (0.0)
d290 2
@


1.83
log
@Multi-objective mode
@
text
@d74 2
a75 1
      skipScreening_     (false)
d287 7
@


1.82
log
@Multi-objective mode
@
text
@d74 1
a74 2
      skipScreening_     (false),
      allowMultiObj_     (false)
a169 2
   witAssert (allowMultiObj_);

a285 7

void WitOptComp::setAllowMultiObj (bool theValue)
   {
   allowMultiObj_ = theValue;
   }

//------------------------------------------------------------------------------
d575 1
a575 3

   if (allowMultiObj_)
      setMultiObjMode  (theOptComp->multiObjMode_);
@


1.81
log
@Multi-objective mode
@
text
@d233 1
a233 1
   solverLogFileName_.copyCstring (theValue);
@


1.80
log
@Multi-objective mode
@
text
@d414 47
a591 35

//------------------------------------------------------------------------------

void WitOptComp::store (WitOptStarter * theOptStarter)
   {
   allOptStarters_.append (theOptStarter);
   }

//------------------------------------------------------------------------------

bool WitOptComp::negativeCostsExist ()
   {
   WitPart *      thePart;
   WitMaterial *  theMat;
   WitOperation * theOpn;
   WitSubEntry *  theSub;

   forEachPart (thePart, myProblem ())
      if (not (thePart->scrapCost () >= 0.0))
         return true;

   forEachMaterial (theMat, myProblem ())
      if (not (theMat->stockCost () >= 0.0))
         return true;

   forEachOperation (theOpn, myProblem ())
      if (not (theOpn->execCost () >= 0.0))
         return true;

   forEachSubEntry (theSub, myProblem ())
      if (not (theSub->subCost () >= 0.0))
         return true;

   return false;
   }
@


1.79
log
@Multi-Objective Mode
@
text
@d36 9
d67 1
a67 1
      sglObjValue_       (0.0),
d77 2
d92 2
d184 5
a188 1
      myMultiObjMgr_ = new WitMultiObjMgr (myProblem ());
d194 3
a196 1
      myMultiObjMgr_ = NULL;
a301 1
   witAssert (not multiObjMode_);
d303 1
a303 1
   sglObjValue_ = theValue;
a319 1
   witAssert (not multiObjMode_);
d321 1
a321 1
   sglObjValue_ = theValue;
d367 2
a368 4
   witAssert (not multiObjMode_);

   sglObjValue_ = 0.0;
   boundsValue_ = 0.0;
d378 1
a378 1
         sglObjValue_;
@


1.78
log
@*** empty log message ***
@
text
@d19 1
d58 1
a58 1
      objValue_          (0.0),
d283 1
d285 1
a285 1
   objValue_ = theValue;
d302 1
d304 1
a304 1
   objValue_ = theValue;
d350 3
a352 1
   objValue_    = 0.0;
d358 10
@


1.77
log
@Multi-Obj mode.
@
text
@d161 2
@


1.76
log
@multi-objective mode
@
text
@d361 3
@


1.75
log
@Multi-objective mode.
@
text
@d485 1
a485 1
      myMultiObjMgr_->writeData ();
@


1.74
log
@Multi-objective mode.
@
text
@d166 1
a166 1
   if (multiObjMode_)
@


1.73
log
@Removing objective #2.
@
text
@d18 1
d44 1
a44 1

d76 2
d163 14
a458 5
   myDataWriter ()->writeBool (
        "multiObjMode",
         multiObjMode (),
      defMultiObjMode ());

d478 8
a495 1
   multiObjMode_      = theOptComp->multiObjMode_;
d503 6
@


1.72
log
@Removing objective #2.
@
text
@a36 5
      myObjFunc0_        (NULL),
      myObjFunc1_        (NULL),

      allObjFuncs_       (),

a65 1
   setUpObjFuncs ();
a76 3

   while (not  allObjFuncs_.isEmpty ())
      delete allObjFuncs_.get ();
a347 9
void WitOptComp::choose (WitObjFunc * theObjFunc)
   {
   witAssert (theObjFunc != NULL);

   witAssert (theObjFunc->myProblem () == myProblem ());
   }

//------------------------------------------------------------------------------

a361 8
void WitOptComp::setUpObjFuncs ()
   {
   myObjFunc0_ = new WitObjFunc0 (this);
   myObjFunc1_ = new WitObjFunc1 (this);
   }

//------------------------------------------------------------------------------

a409 6
void WitOptComp::chooseObjFunc (int theIndex)
   {
   }

//------------------------------------------------------------------------------

a487 7
void WitOptComp::store (WitObjFunc * theObjFunc)
   {
   allObjFuncs_.append (theObjFunc);
   }

//------------------------------------------------------------------------------

@


1.71
log
@Removing objective #2.
@
text
@d56 1
a56 1
      objChoice_         (NULL),
a89 7
WitObjFunc * WitOptComp::defObjChoice () const
   {
   return myObjFunc1 ();
   }

//------------------------------------------------------------------------------

d177 1
a177 1
   witAssert (theValue <= allObjFuncs ().nElements () - 1);
d181 1
a181 1
   chooseObjFunc (theValue);
a361 2

   objChoice_ = theObjFunc;
a383 2

   choose (defObjChoice ());
a437 11
   WitObjFunc * theObjFunc;

   forEachEl (theObjFunc, allObjFuncs ())
      if (theObjFunc->index () == theIndex)
         {
         theObjFunc->beChosen ();

         return;
         }

   stronglyAssert (false);
d481 2
a482 2
         objChoice ()->index (),
      defObjChoice ()->index ());
d512 1
a515 2

   chooseObjFunc       (theOptComp->objChoice_->index ());
@


1.70
log
@Removing objective #2.
@
text
@d23 3
d554 28
@


1.69
log
@Removing objective #2.
@
text
@a54 1
      periodsPerYear_    (defPeriodsPerYear    ()),
a200 11
void WitOptComp::setPeriodsPerYear (double theValue)
   {
   witAssert (theValue > 0.0);

   prepSetUnpostAttr ();

   periodsPerYear_ = theValue;
   }

//------------------------------------------------------------------------------

a507 5
   myDataWriter ()->writeDouble (
        "periodsPerYear",
         periodsPerYear (),
      defPeriodsPerYear ());

a528 1
   periodsPerYear_    = theOptComp->periodsPerYear_;
@


1.68
log
@Multi-obj mode.
@
text
@a35 1
      myObjFunc2_        (NULL),
a54 4
      obj2Wrev_          (defObj2Wrev          ()),
      obj2Winv_          (defObj2Winv          ()),
      obj2Wserv_         (defObj2Wserv         ()),
      obj2Wsub_          (defObj2Wsub          ()),
a55 2
      capCost_           (defCapCost           ()),
      invCost_           (defInvCost           ()),
a201 44
void WitOptComp::setObj2Wrev (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   obj2Wrev_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setObj2Winv (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   obj2Winv_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setObj2Wserv (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   obj2Wserv_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setObj2Wsub (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   obj2Wsub_ = theValue;
   }

//------------------------------------------------------------------------------

a212 22
void WitOptComp::setCapCost (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   capCost_ = theValue;
   }

//------------------------------------------------------------------------------

void WitOptComp::setInvCost (double theValue)
   {
   witAssert (theValue >= 0.0);

   prepSetUnpostAttr ();

   invCost_ = theValue;
   }

//------------------------------------------------------------------------------

a368 13

   if (not myObjFunc1 ()->isChosen ())
      myMsgFac () ("objChoiceDdMsg", objChoice ()->index ());

   if (myObjFunc2 ()->isChosen ())
      myMsgFac () ("obj2ParmsDdMsg",
         periodsPerYear (),
         capCost        (),
         invCost        (),
         obj2Wrev       (),
         obj2Winv       (),
         obj2Wserv      (),
         obj2Wsub       ());
a401 1
   myObjFunc2_ = new WitObjFunc2 (this);
a520 20
        "obj2Wrev",
         obj2Wrev (),
      defObj2Wrev ());

   myDataWriter ()->writeDouble (
        "obj2Winv",
         obj2Winv (),
      defObj2Winv ());

   myDataWriter ()->writeDouble (
        "obj2Wserv",
         obj2Wserv (),
      defObj2Wserv ());

   myDataWriter ()->writeDouble (
        "obj2Wsub",
         obj2Wsub (),
      defObj2Wsub ());

   myDataWriter ()->writeDouble (
a524 10
   myDataWriter ()->writeDouble (
        "capCost",
         capCost (),
      defCapCost ());

   myDataWriter ()->writeDouble (
        "invCost",
         invCost (),
      defInvCost ());

a545 4
   obj2Wrev_          = theOptComp->obj2Wrev_;
   obj2Winv_          = theOptComp->obj2Winv_;
   obj2Wserv_         = theOptComp->obj2Wserv_;
   obj2Wsub_          = theOptComp->obj2Wsub_;
a546 2
   capCost_           = theOptComp->capCost_;
   invCost_           = theOptComp->invCost_;
@


1.67
log
@Stochastic Implosion
@
text
@d53 1
d73 2
a74 1
      skipScreening_     (false)
d173 13
d348 7
d439 1
d592 5
d661 1
@


1.66
log
@Stochastic Implosion
@
text
@d67 1
a67 1
      printOptProb_      (false),
d292 1
a292 1
void WitOptComp::setPrintOptProb (bool theValue)
d294 1
a294 1
   printOptProb_ = theValue;
@


1.65
log
@Stochastic Implosion
@
text
@d336 18
a662 7

//------------------------------------------------------------------------------

void WitOptComp::importObjs ()
   {
   myDetOptImpMgr ()->exportObjs (objValue_, boundsValue_);
   }
@


1.64
log
@Stochastic Implosion
@
text
@d382 10
@


1.63
log
@Stochastic Implosion
@
text
@d338 3
a340 1
   storeStochAttr (objValue_, theValue);
d347 3
a349 1
   storeStochAttr (boundsValue_, theValue);
@


1.62
log
@Stochastic Implosion
@
text
@d336 1
a336 1
void WitOptComp::loadInStochObjValue (double theValue)
d338 1
a338 1
   loadInStochAttr (objValue_, theValue);
d343 1
a343 1
void WitOptComp::loadInStochBoundsValue (double theValue)
d345 1
a345 1
   loadInStochAttr (boundsValue_, theValue);
@


1.61
log
@Stochastic Implosion
@
text
@d336 14
a377 7
void WitOptComp::importStochSoln ()
   { 
   myStochImpMgr ()->exportSoln (this, objValue_, boundsValue_);
   }

//------------------------------------------------------------------------------

a637 12

//------------------------------------------------------------------------------

void WitOptComp::loadInObjVals (
      double objValueArg,
      double boundsValueArg)
   {
   witAssert (myStochImpMgr ()->uploadingSoln ());

   objValue_    = objValueArg;
   boundsValue_ = boundsValueArg;
   }
@


1.60
log
@Stochastic Implosion
@
text
@d631 12
@


1.59
log
@Stochastic Implosion
@
text
@d21 1
a21 1
#include <OptImp.h>
d137 1
a137 1
      myOptImploder ()->shutDown ();
d153 1
a153 1
      myOptImploder ()->shutDown ();
d415 1
a415 1
      stronglyAssert (myOptImploder ()->accelerated ());
d629 1
a629 1
   myOptImploder ()->exportObjs (objValue_, boundsValue_);
@


1.58
log
@Stochastic Implosion
@
text
@d22 1
d65 2
d364 7
d624 7
@


1.57
log
@Stochastic implosion.
@
text
@d119 1
a119 1
   settingUnpostAttr ();
d136 1
a136 1
   settingUnpostAttr ();
d147 1
a147 1
   settingUnpostAttr ();
d161 1
a161 1
   settingUnpreAttr ();
d173 1
a173 1
   settingUnpreAttr ();
d184 1
a184 1
   settingUnpostAttr ();
d195 1
a195 1
   settingUnpostAttr ();
d206 1
a206 1
   settingUnpostAttr ();
d217 1
a217 1
   settingUnpostAttr ();
d228 1
a228 1
   settingUnpostAttr ();
d239 1
a239 1
   settingUnpostAttr ();
d250 1
a250 1
   settingUnpostAttr ();
d261 1
a261 1
   settingUnpostAttr ();
d272 1
a272 1
   settingNonUnpostAttr ();
@


1.56
log
@Stochastic implosion.
@
text
@d272 2
@


1.55
log
@Stochastic Implosion.
@
text
@d119 1
a119 1
   myProblem ()->resetSoln ();
d136 1
a136 1
   myProblem ()->resetSoln ();
d147 1
a147 1
   myProblem ()->resetSoln ();
d161 1
a161 1
   myPreprocessor ()->unpreprocess ();
d173 1
a173 1
   myPreprocessor ()->unpreprocess ();
d184 1
a184 1
   myProblem ()->resetSoln ();
d195 1
a195 1
   myProblem ()->resetSoln ();
d206 1
a206 1
   myProblem ()->resetSoln ();
d217 1
a217 1
   myProblem ()->resetSoln ();
d228 1
a228 1
   myProblem ()->resetSoln ();
d239 1
a239 1
   myProblem ()->resetSoln ();
d250 1
a250 1
   myProblem ()->resetSoln ();
d261 1
a261 1
   myProblem ()->resetSoln ();
@


1.54
log
@Rescinded all changed made since 1/31/07.
@
text
@d26 1
d338 7
@


1.53
log
@[disallowed backlog]
@
text
@d122 2
a123 1
         myOptImploder ()->resetShadowPrices ();
@


1.52
log
@External opt implosion.
@
text
@d122 1
a122 2
         forEachPart (thePart, myProblem ())
            thePart->resetShadowPrice ();
@


1.51
log
@External opt implosion.
@
text
@d50 1
a50 1
      allowIntCons_      (defAllowIntCons      ()),
d158 1
a158 1
void WitOptComp::setAllowIntCons (bool theValue)
d162 1
a162 1
   allowIntCons_ = theValue;
d357 1
a357 1
      allowIntCons_,
d506 3
a508 3
        "allowIntCons",
         allowIntCons (),
      defAllowIntCons ());
d573 1
a573 1
   allowIntCons_      = theOptComp->allowIntCons_;
@


1.50
log
@External opt implosion.
@
text
@d50 1
a50 1
      enforceIntCons_    (defEnforceIntCons    ()),
d158 1
a158 1
void WitOptComp::setEnforceIntCons (bool theValue)
d162 1
a162 1
   enforceIntCons_ = theValue;
d354 6
a359 6
      compPrices (),
      accAfterOptImp (),
      accAfterSoftLB (),
      enforceIntCons (),
      wbounds (),
      solverLogFileName ());
d506 3
a508 3
        "enforceIntCons",
         enforceIntCons (),
      defEnforceIntCons ());
d573 1
a573 1
   enforceIntCons_    = theOptComp->enforceIntCons_;
@


1.49
log
@App controlled opt implosion.
@
text
@d50 1
d158 9
d357 1
d505 5
d572 17
a588 14
   compPrices_        = theOptComp->compPrices        ();
   setAccAfterOptImp   (theOptComp->accAfterOptImp    ());
   setAccAfterSoftLB   (theOptComp->accAfterSoftLB    ());
   chooseObjFunc       (theOptComp->objChoice         ()->index ());
   wbounds_           = theOptComp->wbounds           ();
   obj2Wrev_          = theOptComp->obj2Wrev          ();
   obj2Winv_          = theOptComp->obj2Winv          ();
   obj2Wserv_         = theOptComp->obj2Wserv         ();
   obj2Wsub_          = theOptComp->obj2Wsub          ();
   periodsPerYear_    = theOptComp->periodsPerYear    ();
   capCost_           = theOptComp->capCost           ();
   invCost_           = theOptComp->invCost           ();
   solverLogFileName_ = theOptComp->solverLogFileName ();
   accMethod_         = theOptComp->accMethod         ();
@


1.48
log
@App controlled opt implosion.
@
text
@d66 2
a67 1
      printMps_          (false)
d310 7
@


1.47
log
@App controlled opt implosion.
@
text
@d61 6
a66 1
      accMethod_         (defAccMethod         ())
d274 35
@


1.46
log
@Removed optimizing implosion with lot sizes.
@
text
@d18 1
a21 1
#include <DataAlt.h>
d111 2
d118 1
a118 1
   compPrices_ = prepBool (theValue, postprocAlt ());
d128 3
a130 1
   accAfterOptImp_ = prepBool (theValue, postprocAlt ());
d139 2
d144 1
a144 1
   accAfterSoftLB_ = prepBool (theValue, postprocAlt ());
d153 4
a156 1
   prepRangedInt (theValue, preprocAlt (), 0, allObjFuncs ().nElements () - 1);
d165 5
a169 1
   wbounds_ = prepNonNegDouble (theValue, postprocAlt ());
d176 5
a180 1
   obj2Wrev_ = prepNonNegDouble (theValue, postprocAlt ());
d187 5
a191 1
   obj2Winv_ = prepNonNegDouble (theValue, postprocAlt ());
d198 5
a202 1
   obj2Wserv_ = prepNonNegDouble (theValue, postprocAlt ());
d209 5
a213 1
   obj2Wsub_ = prepNonNegDouble (theValue, postprocAlt ());
d222 3
a224 1
   periodsPerYear_ = prepDouble (theValue, postprocAlt ());
d231 5
a235 1
   capCost_ = prepNonNegDouble (theValue, postprocAlt ());
d242 5
a246 1
   invCost_ = prepNonNegDouble (theValue, postprocAlt ());
d253 3
a255 1
   solverLogFileName_.copyCstring (prepString (theValue, noOpAlt ()));
@


1.45
log
@Removed the postSolveRecovery attribute.
@
text
@a49 1
      optWithLotSizes_   (defOptWithLotSizes   ()),
a144 9
void WitOptComp::setOptWithLotSizes (bool theValue)
   {
   optWithLotSizes_ = prepBool (theValue, preprocAlt ());

   myProblem ()->myOptVariant ()->checkOptWithLotSizes ();
   }

//------------------------------------------------------------------------------

a257 1
      optWithLotSizes (),
a404 5
   myDataWriter ()->writeBool (
        "optWithLotSizes",
         optWithLotSizes (),
      defOptWithLotSizes ());

a469 1
   optWithLotSizes_   = theOptComp->optWithLotSizes   ();
@


1.44
log
@Updated the copyright date on all source files.
@
text
@a50 1
      postSolveRecovery_ (defPostSolveRecovery ()),
a154 7
void WitOptComp::setPostSolveRecovery (bool theValue)
   {
   postSolveRecovery_ = prepBool (theValue, postprocAlt ());
   }

//------------------------------------------------------------------------------

a420 5
   myDataWriter ()->writeBool (
        "postSolveRecovery",
         postSolveRecovery (),
      defPostSolveRecovery ());

a486 1
   postSolveRecovery_ = theOptComp->postSolveRecovery ();
@


1.43
log
@Removed some OSL items.
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996,2000.
@


1.42
log
@Removed access to the oslMesgFileName attribute.
@
text
@a61 1
      oslMesgFileName_   (defOslMesgFileName   ()),
a229 7
void WitOptComp::setOslMesgFileName (const char * theValue)
   {
   oslMesgFileName_.copyCstring (prepString (theValue, noOpAlt ()));
   }

//------------------------------------------------------------------------------

@


1.41
log
@Fixed bugs:
   witWriteData didn't write problem.compPrices.
   witWriteData didn't write problem.accMethod.
   witCopyData  didn't copy  problem.solverLogFileName.
   witCopyData  didn't copy  problem.accMethod.
@
text
@a285 1
      oslMesgFileName (),
@


1.40
log
@Moved objective #2 functions to the undocumented section of wit.h., etc.
@
text
@d64 1
a64 1
      accMethod_         (0)
d418 4
a421 4
   myDataWriter ()->writeString (
        "solverLogFileName",
         solverLogFileName (),
      defSolverLogFileName ());
d487 10
d519 2
@


1.39
log
@Changed the default value of the objChoice attribute from 2 to 1.
@
text
@a284 1
      objChoice ()->index (),
d289 3
@


1.38
log
@Made opt implosion use COIN unconditionally when COIN_BUILD is defined.
@
text
@d87 1
a87 1
   return myObjFunc2 ();
@


1.37
log
@Modified the behavior of setting optInitMethod:
   Setting it to "accelerated" is now a severe error.
   Setting it takes WIT out of an accelerated state.
@
text
@a51 1
      solverIsCoin_      (defSolverIsCoin      ()),
a156 7
void WitOptComp::setSolverIsCoin (bool theValue)
   {
   solverIsCoin_ = theValue;
   }

//------------------------------------------------------------------------------

d288 1
a288 2
      solverLogFileName (),
      solverIsCoin ()? "COIN": "OSL");
a440 5
   myDataWriter ()->writeBool (
        "solverIsCoin",
         solverIsCoin (),
      defSolverIsCoin ());

a497 1
   solverIsCoin_      = theOptComp->solverIsCoin      ();
@


1.36
log
@Allowed obj1 attributes to be set and retrieved when objChoice != 1.
Allowed objChoice to be set when parts or operations exist.
@
text
@d329 2
a330 1
   witAssert (not theOptStarter->accConflict ());
@


1.35
log
@Added "solverIsCoin" attribute.
@
text
@a173 2
   witAssert (myCompMgr ()->nNodes () == 0);

@


1.34
log
@Continued double precision.
@
text
@d52 1
a64 1
      optWithCoin_       (false),
d158 7
a254 7
void WitOptComp::setOptWithCoin (bool theValue)
   {
   optWithCoin_ = theValue;
   }

//------------------------------------------------------------------------------

d298 2
a299 1
      solverLogFileName ());
d451 5
d513 1
@


1.33
log
@Continued double precision.
@
text
@d176 1
a176 1
void WitOptComp::setWbounds (StrDbl theValue)
d178 1
a178 1
   wbounds_ = prepNonNegStrDbl (theValue, postprocAlt ());
d183 1
a183 1
void WitOptComp::setObj2Wrev (StrDbl theValue)
d185 1
a185 1
   obj2Wrev_ = prepNonNegStrDbl (theValue, postprocAlt ());
d190 1
a190 1
void WitOptComp::setObj2Winv (StrDbl theValue)
d192 1
a192 1
   obj2Winv_ = prepNonNegStrDbl (theValue, postprocAlt ());
d197 1
a197 1
void WitOptComp::setObj2Wserv (StrDbl theValue)
d199 1
a199 1
   obj2Wserv_ = prepNonNegStrDbl (theValue, postprocAlt ());
d204 1
a204 1
void WitOptComp::setObj2Wsub (StrDbl theValue)
d206 1
a206 1
   obj2Wsub_ = prepNonNegStrDbl (theValue, postprocAlt ());
d211 1
a211 1
void WitOptComp::setPeriodsPerYear (StrDbl theValue)
d215 1
a215 1
   periodsPerYear_ = prepStrDbl (theValue, postprocAlt ());
d220 1
a220 1
void WitOptComp::setCapCost (StrDbl theValue)
d222 1
a222 1
   capCost_ = prepNonNegStrDbl (theValue, postprocAlt ());
d227 1
a227 1
void WitOptComp::setInvCost (StrDbl theValue)
d229 1
a229 1
   invCost_ = prepNonNegStrDbl (theValue, postprocAlt ());
d455 1
a455 1
   myDataWriter ()->writeStrDbl (
d460 1
a460 1
   myDataWriter ()->writeStrDbl (
d465 1
a465 1
   myDataWriter ()->writeStrDbl (
d470 1
a470 1
   myDataWriter ()->writeStrDbl (
d475 1
a475 1
   myDataWriter ()->writeStrDbl (
d480 1
a480 1
   myDataWriter ()->writeStrDbl (
d485 1
a485 1
   myDataWriter ()->writeStrDbl (
d490 1
a490 1
   myDataWriter ()->writeStrDbl (
@


1.32
log
@Continued implementation of opt with COIN.
@
text
@d176 1
a176 1
void WitOptComp::setWbounds (float theValue)
d178 1
a178 1
   wbounds_ = prepNonNegFloat (theValue, postprocAlt ());
d183 1
a183 1
void WitOptComp::setObj2Wrev (float theValue)
d185 1
a185 1
   obj2Wrev_ = prepNonNegFloat (theValue, postprocAlt ());
d190 1
a190 1
void WitOptComp::setObj2Winv (float theValue)
d192 1
a192 1
   obj2Winv_ = prepNonNegFloat (theValue, postprocAlt ());
d197 1
a197 1
void WitOptComp::setObj2Wserv (float theValue)
d199 1
a199 1
   obj2Wserv_ = prepNonNegFloat (theValue, postprocAlt ());
d204 1
a204 1
void WitOptComp::setObj2Wsub (float theValue)
d206 1
a206 1
   obj2Wsub_ = prepNonNegFloat (theValue, postprocAlt ());
d211 1
a211 1
void WitOptComp::setPeriodsPerYear (float theValue)
d213 1
a213 1
   witAssert (theValue > 0);
d215 1
a215 1
   periodsPerYear_ = prepFloat (theValue, postprocAlt ());
d220 1
a220 1
void WitOptComp::setCapCost (float theValue)
d222 1
a222 1
   capCost_ = prepNonNegFloat (theValue, postprocAlt ());
d227 1
a227 1
void WitOptComp::setInvCost (float theValue)
d229 1
a229 1
   invCost_ = prepNonNegFloat (theValue, postprocAlt ());
d455 1
a455 1
   myDataWriter ()->writeFloat (
d460 1
a460 1
   myDataWriter ()->writeFloat (
d465 1
a465 1
   myDataWriter ()->writeFloat (
d470 1
a470 1
   myDataWriter ()->writeFloat (
d475 1
a475 1
   myDataWriter ()->writeFloat (
d480 1
a480 1
   myDataWriter ()->writeFloat (
d485 1
a485 1
   myDataWriter ()->writeFloat (
d490 1
a490 1
   myDataWriter ()->writeFloat (
@


1.31
log
@Continued implementation of opt with COIN.
@
text
@d45 1
a45 1
      coinLogLevel_      (2),
@


1.30
log
@Continued implementation of opt with COIN.
@
text
@d425 5
@


1.29
log
@Continued implementation of opt with COIN.
@
text
@d63 3
a65 2
      coinLogFileName_   (defCoinLogFileName   ()),
      optWithCoin_       (false)
d241 1
a241 1
void WitOptComp::setCoinLogFileName (const char * theValue)
d243 1
a243 1
   coinLogFileName_.copyCstring (prepString (theValue, noOpAlt ()));
d254 10
d298 1
a298 1
      coinLogFileName ());
@


1.28
log
@Continued implementation of opt with COIN.
@
text
@d45 2
d99 9
@


1.27
log
@Continued implementation of opt with COIN.
@
text
@d61 1
a61 1
      coinMesgFileName_  (defCoinMesgFileName  ()),
d229 1
a229 1
void WitOptComp::setCoinMesgFileName (const char * theValue)
d231 1
a231 1
   coinMesgFileName_.copyCstring (prepString (theValue, noOpAlt ()));
d276 1
a276 1
      coinMesgFileName ());
@


1.26
log
@Continued implementation of opt with COIN.
@
text
@d62 1
a62 1
      myOptSolveMethod_  (oslDirMethod)
d236 1
a236 1
void WitOptComp::setMyOptSolveMethod (WitOptSolveMethod theValue)
d238 1
a238 1
   myOptSolveMethod_ = theValue;
@


1.25
log
@Removed temporary control parameter undoc1.
@
text
@d45 4
a48 4
      compPrices_        (defCompPrices      ()),
      accAfterOptImp_    (defAccAfterOptImp  ()),
      accAfterSoftLB_    (defAccAfterSoftLB  ()),
      optWithLotSizes_   (defOptWithLotSizes ()),
d51 8
a58 8
      wbounds_           (defWbounds         ()),
      obj2Wrev_          (defObj2Wrev        ()),
      obj2Winv_          (defObj2Winv        ()),
      obj2Wserv_         (defObj2Wserv       ()),
      obj2Wsub_          (defObj2Wsub        ()),
      periodsPerYear_    (defPeriodsPerYear  ()),
      capCost_           (defCapCost         ()),
      invCost_           (defInvCost         ()),
d60 2
a61 1
      oslMesgFileName_   (defOslMesgFileName ()),
d229 7
d275 2
a276 1
      oslMesgFileName ());
@


1.24
log
@Added a temporary undocumented control parameter to turn off ekk_preSolve.
@
text
@d61 1
a61 2
      myOptSolveMethod_  (oslDirMethod),
      skipPreSolve_      (false)
a230 7
   }

//------------------------------------------------------------------------------

void WitOptComp::setSkipPreSolve (bool theValue)
   {
   skipPreSolve_ = theValue;
@


1.23
log
@Continued implementation of opt with COIN.
@
text
@d61 2
a62 1
      myOptSolveMethod_  (oslDirMethod)
d232 7
@


1.22
log
@Continued implementation of opt with COIN.
@
text
@d61 1
a61 1
      myOptSolveMethod_  (dirOslMethod)
@


1.21
log
@Implemented OSL postSolve error recovery.
@
text
@d60 2
a61 1
      oslMesgFileName_   (defOslMesgFileName ())
d224 7
@


1.20
log
@Internal changes.
@
text
@d30 1
a30 1
      WitComponent     (theCompMgr),
d32 29
a60 28
      myObjFunc0_      (NULL),
      myObjFunc1_      (NULL),
      myObjFunc2_      (NULL),

      allObjFuncs_     (),

       heurOptStarter_ (NULL),
        accOptStarter_ (NULL),
      schedOptStarter_ (NULL),
      crashOptStarter_ (NULL),

      allOptStarters_  (),

      compPrices_      (defCompPrices      ()),
      accAfterOptImp_  (defAccAfterOptImp  ()),
      accAfterSoftLB_  (defAccAfterSoftLB  ()),
      optWithLotSizes_ (defOptWithLotSizes ()),
      objChoice_       (NULL),
      wbounds_         (defWbounds         ()),
      obj2Wrev_        (defObj2Wrev        ()),
      obj2Winv_        (defObj2Winv        ()),
      obj2Wserv_       (defObj2Wserv       ()),
      obj2Wsub_        (defObj2Wsub        ()),
      periodsPerYear_  (defPeriodsPerYear  ()),
      capCost_         (defCapCost         ()),
      invCost_         (defInvCost         ()),
      optInitMethod_   (NULL),
      oslMesgFileName_ (defOslMesgFileName ())
d144 7
d401 5
d458 14
a471 13
   compPrices_      = theOptComp->compPrices      ();
   setAccAfterOptImp (theOptComp->accAfterOptImp  ());
   setAccAfterSoftLB (theOptComp->accAfterSoftLB  ());
   optWithLotSizes_ = theOptComp->optWithLotSizes ();
   chooseObjFunc     (theOptComp->objChoice       ()->index ());
   wbounds_         = theOptComp->wbounds         ();
   obj2Wrev_        = theOptComp->obj2Wrev        ();
   obj2Winv_        = theOptComp->obj2Winv        ();
   obj2Wserv_       = theOptComp->obj2Wserv       ();
   obj2Wsub_        = theOptComp->obj2Wsub        ();
   periodsPerYear_  = theOptComp->periodsPerYear  ();
   capCost_         = theOptComp->capCost         ();
   invCost_         = theOptComp->invCost         ();
@


1.19
log
@Internal changes.
@
text
@d71 1
a71 1
   while (!  allOptStarters_.isEmpty ())
d74 1
a74 1
   while (!  allObjFuncs_.isEmpty ())
d101 1
a101 1
      if (! theValue)
d112 1
a112 1
   if (! theValue)
d283 1
a283 1
   witAssert (! theOptStarter->accConflict ());
d343 1
a343 1
      if (! accAfterOptImp ())
@


1.18
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d96 1
a96 1
void WitOptComp::setCompPrices (WitBoolean theValue)
d105 1
a105 1
   compPrices_ = prepBoolean (theValue, postprocAlt ());
d110 1
a110 1
void WitOptComp::setAccAfterOptImp (WitBoolean theValue)
d115 1
a115 1
   accAfterOptImp_ = prepBoolean (theValue, postprocAlt ());
d122 1
a122 1
void WitOptComp::setAccAfterSoftLB (WitBoolean theValue)
d127 1
a127 1
   accAfterSoftLB_ = prepBoolean (theValue, postprocAlt ());
d134 1
a134 1
void WitOptComp::setOptWithLotSizes (WitBoolean theValue)
d136 1
a136 1
   optWithLotSizes_ = prepBoolean (theValue, preprocAlt ());
d221 1
a221 1
WitBoolean WitOptComp::inserted ()
d309 1
a309 1
        witTRUE);
d317 1
a317 1
        witFALSE);
d325 1
a325 1
        witTRUE);
d333 1
a333 1
        witFALSE);
d361 1
a361 1
   stronglyAssert (witFALSE);
d378 1
a378 1
   myDataWriter ()->writeBoolean (
d383 1
a383 1
   myDataWriter ()->writeBoolean (
d388 1
a388 1
   myDataWriter ()->writeBoolean (
@


1.17
log
@Continued implementation of opt implosion with lot sizes.
@
text
@a44 2
      allowMLS_        (witFALSE),

a93 7
//------------------------------------------------------------------------------

void WitOptComp::setAllowMLS (WitBoolean theValue)
   {
   allowMLS_ = theValue;
   }

@


1.16
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d122 1
a122 1
      myOptImploder ()->unaccelerate ();
d134 1
a134 1
      myOptImploder ()->unaccelerate ();
@


1.15
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d45 2
d96 7
@


1.14
log
@Continued implementation of opt implosion with lot sizes.
@
text
@d22 1
a48 1
      allowOWLS_       (witFALSE),
a135 2
   stronglyAssert (allowOWLS_);

a136 1
   }
d138 1
a138 5
//------------------------------------------------------------------------------

void WitOptComp::setAllowOWLS (WitBoolean theValue)
   {
   allowOWLS_ = theValue;
@


1.13
log
@Began implementation of opt implosion with lot sizes.
@
text
@d16 3
@


1.12
log
@Preliminary work on single source.
@
text
@d44 2
d131 16
d252 1
d392 5
d449 13
a461 12
   compPrices_      = theOptComp->compPrices     ();
   setAccAfterOptImp (theOptComp->accAfterOptImp ());
   setAccAfterSoftLB (theOptComp->accAfterSoftLB ());
   chooseObjFunc     (theOptComp->objChoice      ()->index ());
   wbounds_         = theOptComp->wbounds        ();
   obj2Wrev_        = theOptComp->obj2Wrev       ();
   obj2Winv_        = theOptComp->obj2Winv       ();
   obj2Wserv_       = theOptComp->obj2Wserv      ();
   obj2Wsub_        = theOptComp->obj2Wsub       ();
   periodsPerYear_  = theOptComp->periodsPerYear ();
   capCost_         = theOptComp->capCost        ();
   invCost_         = theOptComp->invCost        ();
@


1.11
log
@Continued implementation of object iteration.
@
text
@d200 1
a200 1
   oslMesgFileName_ = prepString (theValue, noOpAlt ());
@


1.10
log
@Began implementation of object iteration.
@
text
@d200 1
a200 1
   oslMesgFileName_ = prepString (theValue, noopAlt ());
@


1.9
log
@Continued implementation of sel-split for pen-exec.
@
text
@d21 1
@


1.8
log
@Minor change to shadow price code.
@
text
@d345 1
a345 1
   myMsgFac () ("internalErrorFmsg", "WitOptComp::chooseObjFunc");
@


1.7
log
@Added shadowPrice and compPrices attributes.
@
text
@d92 7
@


1.6
log
@Used rusage for timing on AIX.
Made generic class StackSpSched use only 1 argument.
Added baSelSplit attribute.
Removed selSplit development parameter.
Added selSplitAll development parameter.
@
text
@d40 1
d90 7
d223 1
d417 1
@


1.5
log
@Implemented and used class SelMgr.
@
text
@d54 2
a55 2
   setupObjFuncs ();
   setupOptStarters ();
d258 1
a258 1
void WitOptComp::setupObjFuncs ()
d269 1
a269 1
void WitOptComp::setupOptStarters ()
@


1.4
log
@Coarse selection splitting.
@
text
@d64 5
a68 2
   allOptStarters_.clearContents ();
   allObjFuncs_   .clearContents ();
@


1.3
log
@Began implementation of coarse selection splitting.
Made DynStack classes more general.
@
text
@d202 7
@


1.2
log
@Updating wit/src in /u/wit/devbase to be in synch with /u/implode/devbase
@
text
@d195 1
a195 1
void WitOptComp::copyInto (WitCompMgr * theCompMgr)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
//     (c) Copyright IBM Corp. 1993,1994,1996.
@


1.1.1.1
log
@Import wit
@
text
@@
